Abracadabra - The magic word.  (You were expecting maybe a genie?)

&"!" - The factorial operator, which is the product of all the integers
from 1 up to its argument.  Thus 5! = 1*2*3*4*5 = 120.  The value of
the option FACTLIM[-1] gives the highest factorial which is
automatically expanded.  If it is -1 then all integers are expanded.
See also the FACTORIAL, MINFACTORIAL, and FACTCOMB commands.

&"!!" - Stands for double factorial which is defined as the product of
all the consecutive odd (or even) integers from 1 (or 2) to the odd
(or even) argument.  Thus 8!! is 2*4*6*8 = 384.

&"#" - The logical operator "Not equals".

&% The last D-line computed by MACSYMA (whether or not it was printed
out).  (See also %%.)

&%% The value of the last computation performed while in a
(MACSYMA-BREAK).  Also may be used in compound statements in the nth
statement to refer to the value of the (n-1)th statement.  E.g.
F(N):=(INTEGRATE(X^N,X),SUBST(3,X,%%)-SUBST(2,X,%%)); is in essence
equivalent to F(N):=BLOCK([%%], %%:INTEGRATE(X^N,X),
SUBST(3,X,%%)-SUBST(2,X,%%)); This will also work for communicating
between the (n-1)th and nth (non-atomic) BLOCK statements.

&%E The MACSYMA representation for the base of natural logarithms

&%E_TO_NUMLOG default: [FALSE] - when TRUE, "r" some rational
number, and "x" some expression, %E^(r*LOG(x)) will be simplified into
x^r .  (If "r" is an integer, this simplification happens by default.)
It should be noted that the RADCAN command also does this
transformation, and more complicated transformations of this ilk as
well.

&%EDISPFLAG default: [FALSE] - if TRUE, MACSYMA displays %E to a
negative exponent as a quotient, i.e. %E^-X as 1/%E^X.

&%EMODE default: [TRUE] when TRUE %E^(%PI*%I*X) will be simplified as
follows: it will become COS(%PI*X)+%I*SIN(%PI*X) if X is an integer or
a multiple of 1/2, 1/3, 1/4, or 1/6 and thus will simplify further.
For other numerical X it will become %E^(%PI*%I*Y) where Y is X-2*k
for some integer k such that ABS(Y)<1.  If %EMODE is FALSE no
simplification of %E^(%PI*%I*X) will take place.

&%ENUMER default: [FALSE] when TRUE will reliably cause %E to be
converted into 2.718...  whenever NUMER is TRUE.  The default is that
this conversion will take place only if the exponent in %E^X evaluates
to a number.

&%GAMMA - The Euler-Mascheroni constant.  The notation %GAMMA is used
for consistency with standard texts which use the Greek letter gamma;
it can be defined as follows:
                                      M
                                     ====
                                     \     1
           %GAMMA   =    limit    ((  >    -) - LOG(M))
                         M -> INF    /     N
                                     ====
                                     N = 1

Currently %GAMMA has a NUMER property of .577215665 and a CONSTANT
property.  It is used along with the Polygamma simplification routines
to permit their reduction to closed forms.

&%I The MACSYMA representation for "i", the square root of -1 Some
commands and switches which handle %I are, LOGNEGINT, REALPART,
IMAGPART, RECTFORM, POLARFORM, ABS, CARG, and CABS.  See also
DESCRIBE(COMPLEX).

&%J [index](expr) - Bessel Funct 1st Kind (in SPECINT)
&%K [index](expr) - Bessel Funct 2nd Kind (in SPECINT)
                  - Constant, in ODE2

&%PHI The constant (SQRT(5)+1)/2 = 1.618033989).  If you want the
Rational Function Package to know about %PHI do
TELLRAT(%PHI^2-%PHI-1)$ ALGEBRAIC:TRUE$ .  See also FIBTOPHI.

&%PI The MACSYMA representation for pi.

&%R - The arbitrary parameters used by ALGSYS.  Do DESCRIBE(ALGSYS); .
&%RNUM_LIST default: [] - When %R variables are introduced in solutions
by the ALGSYS command, they are added to %RNUM_LIST in the order they
are created.  This is convenient for doing substitutions into the
solution later on.  It's recommended to use this list rather than
doing CONCAT('%R,J).

&%TH(i) is the ith previous computation.  That is, if the next
expression to be computed is D(j) this is D(j-i).  This is useful in
BATCH files or for referring to a group of D expressions.  For
example, if SUM is initialized to 0 then FOR I:1 THRU 10 DO
SUM:SUM+%TH(I) will set SUM to the sum of the last ten D expressions.

&"'" - (single quote) has the effect of preventing evaluation.  E.g.
'(F(X)) means do not evaluate the expression F(X).  'F(X) means
return the noun form of F applied to [X].

&"''" - (two single quotes) causes an extra evaluation to occur.  E.g.
''c4; will re-execute line C4.  ''(F(X)) means evaluate the
expression F(X) an extra time.  ''F(X) means return the verb form of F
applied to [X].

&":" - The assignment operator.  E.g. A:3 sets the variable A to 3.

&"::" - Assignment operator.  :: assigns the value of the expression
on its right to the value of the quantity on its left, which must
evaluate to an atomic variable or subscripted variable.

&"::=" - The "::=" is used instead of ":=" to indicate that what
follows is a macro definition, rather than an ordinary functional
definition.  See DESCRIBE(MACROS).

&":=" - The function definition operator.  E.g. F(X):=SIN(X) defines
a function F.

&"." - The dot operator, for matrix (non-commutative) multiplication.
When "." is used in this way, spaces should be left on both sides of
it, e.g. A . B.  This distinguishes it plainly from a decimal point in
a floating point number.  Do APROPOS(DOT); for a list of the switches
which affect the dot operator.  DESCRIBE(switch-name); will explain
them.

&"3D" - in the plotting functions, indicates a 3 Dimensional plot
will be made.

&"?" - As prefix to a function or variable name, signifies that the
function or variable is a LISP token, not a MACSYMA token.  Two
question marks typed together, ??, will flush the current MACSYMA
command line.

&"=" - denotes an equation to MACSYMA.  To the pattern matcher in
MACSYMA it denotes a total relation that holds between two expressions
if and only if the expressions are syntactically identical.

&ABS(X) - absolute value of X.  ABSBOXCHAR[!]  is the character used
to draw absolute value signs around expressions which are more than a
single line high.

&ABSBOXCHAR default: [!] is the character used to draw absolute value
signs around expressions which are more than a single line high.

&ACKNOWLEDGEMENT - Papers which reference MACSYMA should contain
the following acknowledgement:

(work (or computations) reported in this paper)...... was
done with the aid of MACSYMA, a large symbolic manipulation
program developed at the MIT Laboratory for Computer Science
and supported from 1975 to 1983 by the National Aeronautics
and Space Administration under grant NSG 1323, by the Office
of Naval Research under grant N00014-77-C-0641, by the U. S.
Department of Energy under grant ET-78-C-02-4687, and by the
U. S. Air Force under grant F49620-79-C-020, and since 1982
by Symbolics, Inc. of Cambridge, Mass.  MACSYMA is a
trademark of Symbolics, Inc.

&ACKNOWLEDGMENT - See ACKNOWLEDGEMENT.
&ACOS - Arc Cosine
&ACOSH - Hyperbolic Arc Cosine
&ACOT - Arc Cotangent
&ACOTH - Hyperbolic Arc Cotangent
&ACSC - Arc Cosecant
&ACSCH - Hyperbolic Arc Cosecant

&ACTIVATE(cont1, cont2, ...) causes the specified contexts conti to be
activated.  The facts in these contexts are used in making deductions
and retrieving information.  The facts in these contexts are not
listed when FACTS(); is done.  The variable ACTIVECONTEXTS is the list
of contexts which are active by way of the ACTIVATE function.

&ACTIVECONTEXTS default: [] is a list of the contexts which are active
by way of the ACTIVATE function, as opposed to being active because
they are subcontexts of the current context.

&ADDCOL(M,list1,list2,...,listn) appends the column(s) given by the one
or more lists (or matrices) onto the matrix M.

&ADDITIVE - If DECLARE(F,ADDITIVE) has been executed, then:
(1) If F is univariate, whenever the simplifier encounters F applied
to a sum, F will be distributed over that sum.  I.e. F(Y+X); will
simplify to F(Y)+F(X).
(2) If F is a function of 2 or more arguments, additivity is defined as 
additivity in the first argument to F, as in the case of 'SUM or 
'INTEGRATE, i.e. F(H(X)+G(X),X); will simplify to F(H(X),X)+F(G(X),X).
This simplification does not occur when F is applied to expressions of
the form SUM(X[I],I,lower-limit,upper-limit).

&ADDROW(M,list1,list2,...,listn) appends the row(s) given by the one or
more lists (or matrices) onto the matrix M.

&ADJOINT(matrix) computes the adjoint of a matrix.

&AIRY(X) returns the Airy function Ai of real argument X.
The file SHARE1;AIRY FASL contains routines to evaluate the Airy functions
Ai(X), Bi(X), and their derivatives dAi(X), dBi(X).  Ai and Bi satisfy the
AIRY eqn diff(y(x),x,2)-x*y(x)=0.  Read SHARE1;AIRY USAGE for details.

&ALARMCLOCK(arg1, arg2, arg3) will execute the function of no
arguments whose name is arg3 when the time specified by arg1 and arg2
elapses.  If arg1 is the atom "TIME" then arg3 will be executed after
arg2 seconds of real-time has elapsed while if arg1 is the atom
"RUNTIME" then arg3 will be executed after arg2 milliseconds of cpu
time. If arg2 is negative then the arg1 timer is shut off.

&ALGEBRAIC default: [FALSE] must be set to TRUE in order for the
simplification of algebraic integers to take effect.

&ALGEPSILON default: [10^8] The value of epsilon used by ALGSYS.

&ALGEXACT default: [FALSE] affects the behavior of ALGSYS as follows:
If ALGEXACT is TRUE, ALGSYS always calls SOLVE and then uses REALROOTS
on SOLVE's failures.  If ALGEXACT is FALSE, SOLVE is called only if
the eliminant was not univariate, or if it was a quadratic or
biquadratic.  Thus ALGEXACT:TRUE doesn't guarantee only exact
solutions, just that ALGSYS will first try as hard as it can to give
exact solutions, and only yield approximations when all else fails.

&ALGSYS([exp1, exp2, ...], [var1, var2, ...]) solves the list of
simultaneous polynomials or polynomial equations (which can be
non-linear) for the list of variables.  The symbols %R1, %R2, etc.
will be used to represent arbitrary parameters when needed for the
solution (the variable %RNUM_LIST holds these).  In the process
described below, ALGSYS is entered recursively if necessary.

    The method is as follows:

(1) First the equations are FACTORed and split into subsystems.

(2) For each subsystem Si, an equation E and a variable var are
selected (the var is chosen to have lowest nonzero degree).  Then the
resultant of E and Ej with respect to var is computed for each of the
remaining equations Ej in the subsystem Si.  This yields a new
subsystem S'i in one fewer variables (var has been eliminated).  The
process now returns to (1).

(3) Eventually, a subsystem consisting of a single equation is
obtained.  If the equation is multivariate and no approximations in
the form of floating point numbers have been introduced, then SOLVE is
called to find an exact solution.  (The user should realize that SOLVE
may not be able to produce a solution or if it does the solution may
be a very large expression.)
    If the equation is univariate and is either linear, quadratic, or
bi-quadratic, then again SOLVE is called if no approximations have
been introduced.  If approximations have been introduced or the
equation is not univariate and neither linear, quadratic, or
bi-quadratic, then if the switch REALONLY[FALSE] is TRUE, the function
REALROOTS is called to find the real-valued solutions.  If
REALONLY:FALSE then ALLROOTS is called which looks for real and
complex-valued solutions.  If ALGSYS produces a solution which has
fewer significant digits than required, the user can change the value
of ALGEPSILON[10^8] to a higher value.  If ALGEXACT[FALSE] is set to
TRUE, SOLVE will always be called.

(4) Finally, the solutions obtained in step (3) are re-inserted into
previous levels and the solution process returns to (1).

The user should be aware of several caveats:

    When ALGSYS encounters a multivariate equation which contains
floating point approximations (usually due to its failing to find
exact solutions at an earlier stage), then it does not attempt to
apply exact methods to such equations and instead prints the message:
        "ALGSYS cannot solve - system too complicated."

    Interactions with RADCAN can produce large or complicated
expressions.  In that case, the user may use PICKAPART or REVEAL to
analyze the solution.  Occasionally, RADCAN may introduce an apparent
%I into a solution which is actually real-valued.  Do EXAMPLE(ALGSYS);
for examples.

&ALIAS(newname1, oldname1, newname2, oldname2, ...)  provides an
alternate name for a (user or system) function, variable, array, etc.
Any even number of arguments may be used.

&ALIASES default: [] atoms which have a user defined alias (set up by
the ALIAS, ORDERGREAT, ORDERLESS functions or by DECLAREing the atom a
NOUN).

&ALLBUT works with the PART commands (i.e. PART, INPART, SUBSTPART,
SUBSTINPART, DPART, and LPART).  For example, if EXPR is E+D+C+B+A,
then PART(EXPR,[2,5]); gives D+A, while PART(EXPR,ALLBUT(2,5)); gives
E+C+B.  It also works with the KILL command,
KILL(ALLBUT(name1,...,namek)) will do a KILL(ALL) except it will not
KILL the names specified.  (Note: namei means a name such as function
name such as U, F, FOO, or G, not an infolist such as FUNCTIONS.)

&ALLOC - This command has two forms:
(1) On PDP10/20 systems it takes any number of arguments which are
the same as the replies to the "run out of space" question.  It
increases allocations accordingly.  E.g.  If the user knows initially
that his problem will require much space, he can say ALLOC(4); to
allocate the maximum amount initially.  See also the DYNAMALLOC
switch.
(2) On VAX systems alloc(<spacetype>,<numberofpages>) allocates some
number of pages.  Spacetype is likely to be list, but could be fixnum
or other "Franz" spaces.  Try alloc(list,1000); for example. There are
64 cons-cells on a page.

&ALLROOTS(poly) - finds all the real and complex roots of the real
polynomial poly which must be univariate and may be an equation, e.g.
poly=0.  For complex polynomials an algorithm by Jenkins and Traub is
used (Algorithm 419, Comm. ACM, vol. 15, (1972), p. 97).  For real
polynomials the algorithm used is due to Jenkins (Algorithm 493, TOMS,
vol. 1, (1975), p.178).  The flag POLYFACTOR[FALSE] when true causes
ALLROOTS to factor the polynomial over the real numbers if the
polynomial is real, or over the complex numbers, if the polynomial is
complex.  ALLROOTS may give inaccurate results in case of multiple
roots.  (If poly is real and you get inaccurate answers, you may want
to try ALLROOTS(%I*poly);) Do EXAMPLE(ALLROOTS); for an example.
ALLROOTS rejects non-polynomials.  It requires that the numerator
after RATting should be a polynomial, and it requires that the
denominator be at most a complex number.  As a result of this ALLROOTS
will always return an equivalent (but factored) expression, if
POLYFACTOR is TRUE.

&ALLSYM default: [TRUE] - If TRUE then all indexed objects are assumed
symmetric in all of their covariant and contravariant indices. If
FALSE then no symmetries of any kind are assumed in these indices.
Derivative indices are always taken to be symmetric.

&ALPHABETIC - adds to MACSYMA's alphabet (initially A-Z,% and _).
Thus, DECLARE("~",ALPHABETIC) enables NEW~VALUE to be used as a name.

&ANTID - A routine for evaluating integrals of expressions involving
an arbitrary unspecified function and its derivatives.  It may be used
by LOAD(ANTID); , after which, the function ANTIDIFF may be used.
E.g.  ANTIDIFF(G,X,U(X)); where G is the expression involving U(X)
(U(X) arbitrary) and its derivatives, whose integral with respect to X
is desired.

The functions NONZEROANDFREEOF and LINEAR are also defined, as well as
ANTID.  ANTID is the same as ANTIDIFF except that it returns a list of
two parts, the first part is the integrated part of the expression and
the second part of the list is the non-integrable remainder.

&ANTIDIFF - See ANTID.
&ANTISYMMETRIC - If DECLARE(H,ANTISYMMETRIC); is done, this tells the
simplifier that H is antisymmetric.  E.g. H(X,Z,Y) will simplify to -
H(X, Y, Z).  That is, it will give (-1)^n times the result given by
SYMMETRIC or COMMUTATIVE, where n is the number of interchanges of two
arguments necessary to convert it to that form.

&APPEND(list1, list2, ...) returns a single list of the elements of
list1 followed by the elements of list2,...  APPEND also works on
general expressions, e.g. APPEND(F(A,B), F(C,D,E)); -> F(A,B,C,D,E).
Do EXAMPLE(APPEND); for an example.

&APPENDFILE(filename1, filename2, DSK, directory) is like
WRITEFILE(DSK,directory) but appends to the file whose name is
specified by the first two arguments.  A subsequent CLOSEFILE will
delete the original file and rename the appended file.

&APPLY(function, list) gives the result of applying the function to
the list of its arguments.  This is useful when it is desired to
compute the arguments to a function before applying that function.
For example, if L is the list [1, 5, -10.2, 4, 3], then APPLY(MIN,L)
gives -10.2.  APPLY is also useful when calling functions which do not
have their arguments evaluated if it is desired to cause evaluation of
them.  For example, if FILESPEC is a variable bound to the list [TEST,
CASE] then APPLY(CLOSEFILE,FILESPEC) is equivalent to
CLOSEFILE(TEST,CASE).  In general the first argument to APPLY should
be preceded by a ' to make it evaluate to itself.  Since some atomic
variables have the same name as certain functions the values of the
variable would be used rather than the function because APPLY has its
first argument evaluated as well as its second.

&APPLY_NOUNS(exp) causes the application of noun forms in an
expression.  E.g. EXP:'DIFF(X^2/2,X); APPLY_NOUNS(EXP); gives X.  This
gives the same result as EV(EXP,NOUNS); except that it can be faster
and use less storage.  It also can be used in translated code, where
EV may cause problems.  Note that it is called APPLY_NOUNS, not
EV_NOUNS, because what it does is to APPLY the rules corresponding to
the noun-form operators, which is not evaluation.

&APPLY1(exp, rule1, ..., rulen) repeatedly applies the first rule to
exp until it fails, then repeatedly applies the same rule to all
subexpressions of exp, left-to-right, until the first rule has failed
on all subexpressions.  Call the result of transforming exp in this
manner exp'.  Then the second rule is applied in the same fashion
starting at the top of exp'.  When the final rule fails on the final
subexpression, the application is finished.

&APPLY2(exp, rule1, ..., rulen) differs from APPLY1 in that if the
first rule fails on a given subexpression, then the second rule is
repeatedly applied, etc.  Only if they all fail on a given
subexpression is the whole set of rules repeatedly applied to the next
subexpression.  If one of the rules succeeds, then the same
subexpression is reprocessed, starting with the first rule.
MAXAPPLYDEPTH[10000] is the maximum depth to which APPLY1 and APPLY2
will delve.

&APPLYB1(exp, rule1, ..., rulen) is similar to APPLY1 but works from
the "bottom up" instead of from the "top down".  That is, it processes
the smallest subexpression of exp, then the next smallest, etc.
MAXAPPLYHEIGHT[10000] - is the maximum height to which APPLYB1 will
reach before giving up.

&APROPOS(string) takes a character string as argument and looks at all
the MACSYMA names for ones with that string appearing anywhere within
them.  Thus, APROPOS(EXP); will return a long list of all the flags
and functions which have EXP as part of their names, such as EXPAND,
EXP, EXPONENTIALIZE.  Thus if you can only remember part of the name
of something you can use this command to find the rest of the name.
Similarily, you could say APROPOS(TR_); to find a list of many of the
switches relating to the TRANSLATOR (most of which begin with TR_).

&ARGS(exp) - returns a list of the args of exp.  I.e. it is
essentially equivalent to SUBSTPART("[",exp,0) .  (Both ARGS and
SUBSTPART depend on the setting of INFLAG.)

&ARRAY(name, dim1, dim2, ..., dimk) This sets up a k-dimensional
array.  A maximum of five dimensions may be used.  The subscripts for
the ith dimension are the integers running from 0 to dimi.  If the
user assigns to a subscripted variable before declaring the
corresponding array, an undeclared array is set up.  If the user has
more than one array to be set up the same way, they may all be set up
at the same time, by ARRAY([list-of-names],dim1, dim2, ..., dimk).

Undeclared arrays, otherwise known as hashed arrays (because hash
coding is done on the subscripts), are more general than declared
arrays.  The user does not declare their maximum size, and they grow
dynamically by hashing as more elements are assigned values.  The
subscripts of undeclared arrays need not even be numbers.  However,
unless an array is rather sparse, it is probably more efficient to
declare it when possible than to leave it undeclared.  The ARRAY
function can be used to transform an undeclared array into a declared
array.

&ARRAYAPPLY(array,[sub1, ... ,subk]) is like APPLY except the first
argument is an array.

&ARRAYINFO(a) returns a list of information about the array a.  For
hashed arrays it returns a list of "HASHED", the number of subscripts,
and the subscripts of every element which has a value.  For declared
arrays it returns a list of "DECLARED", the number of subscripts, and
the bounds that were given the the ARRAY function when it was called
on a.  Do EXAMPLE(ARRAYINFO); for an example.

&ARRAYMAKE(name,[i1,i2,...]) returns name[i1,i2,...].

&ARRAYS default: [] a list of all the arrays that have been allocated,
both declared and undeclared.  Functions which deal with arrays are:
ARRAY, ARRAYAPPLY, ARRAYINFO, ARRAYMAKE, FILLARRAY, LISTARRAY, and
REARRAY.

&ASEC - Arc Secant
&ASECH - Hyperbolic Arc Secant
&ASIN - Arc Sine
&ASINH - Hyperbolic Arc Sine

&ASKEXP default: [] contains the expression upon which ASKSIGN is
called.  A user may enter a MACSYMA break with ^A and inspect this
expression in order to answer questions asked by ASKSIGN.

&ASKINTEGER(exp,<optional-arg>) - exp is any valid macsyma expression
and optional-arg is EVEN,ODD,INTEGER and defaults to INTEGER if not
given.  This function attempts to determine from the data-base whether
exp is EVEN, ODD or just an INTEGER.  It will ask the user if it
cannot tell otherwise and attempt to install the information in the
data-base if possible.

&ASKSIGN(exp) first attempts to determine whether the specified
expression is positive, negative, or zero.  If it cannot, it asks the
user the necessary questions to complete its deduction.  The user's
answer is recorded in the data base for the duration of the current
computation (one "C-line"). The value of ASKSIGN is one of POS, NEG,
or ZERO.

&ASSIGNMENT - There are two assignment operators in MACSYMA, : and :: .
E.g. A:3 sets the variable A to 3.  :: assigns the value of the
expression on its right to the value of the quantity on its left,
which must evaluate to an atomic variable or subscripted variable.

&ASSUME(pred1, pred2, ...) - First checks the specified predicates for
redundancy and consistency with the current data base.  If the
predicates are consistent and non-redundant, they are added to the
data base; if inconsistent or redundant, no action is taken.  ASSUME
returns a list whose entries are the predicates added to the data base
and the atoms REDUNDANT or INCONSISTENT where applicable.

&ASSUME_POS default:[FALSE] - When using INTEGRATE, etc. one often
introduces parameters which are real and positive or one's
calculations can often be constructed so that this is true.  There is
a switch ASSUME_POS (default FALSE) such that if set to TRUE, MACSYMA
will assume one's parameters are positive.  The intention here is to
cut down on the number of questions MACSYMA needs to ask.  Obviously,
ASSUME information or any contextual information present will take
precedence.  The user can control what is considered to be a parameter
for this purpose.  Parameters by default are those which satisfy
SYMBOLP(x) OR SUBVARP(x).  The user can change this by setting the
option ASSUME_POS_PRED [default FALSE] to the name of a predicate
function of one argument.  E.g. if you want only symbols to be
parameters, you can do ASSUME_POS:TRUE$ ASSUME_POS_PRED:'SYMBOLP$
SIGN(A); -> POS, SIGN(A[1]); -> PNZ.

&ASSUME_POS_PRED default:[FALSE] - may be set to one argument to control
what will be considered a parameter for the "assumptions" that INTEGRATE
will make... see ASSUME and ASSUME_POS .

&ASSUMESCALAR default: [TRUE] - helps govern whether expressions "exp"
for which NONSCALARP(exp) is FALSE are assumed to behave like scalars
for certain transformations as follows: Let "exp" represent any
non-list/non-matrix, and "[1,2,3]" any list or matrix.  exp.[1,2,3];
will give [exp,2*exp,3*exp] if ASSUMESCALAR is TRUE or SCALARP(exp) is
TRUE or CONSTANTP(exp) is TRUE.  If ASSUMESCALAR is TRUE, such
expressions will behave like scalars only for the commutative
operators, but not for ".".  If ASSUMESCALAR is FALSE, such
expressions will behave like non-scalars.  If ASSUMESCALAR is ALL,
such expressions will behave like scalars for all the operators listed
above.

&ASYMP - A preliminary version of a program to find the asymptotic behavior
of Feynman diagrams has been installed on the SHARE1; directory.
For further information, see the file SHARE1;ASYMP USAGE.
(For Asymptotic Analysis functions, see ASYMPA.)

&ASYMPA - Asymptotic Analysis - The file SHARE1;ASYMPA > contains
simplification functions for asymptotic analysis, including the big-O
and little-o functions that are widely used in complexity analysis and
numerical analysis.  Do BATCH(ASYMPA,>,SHARE1); .
(For asymptotic behavior of Feynman diagrams, see ASYMP.)

&AT(exp, list) will evaluate exp (which may be any expression) with
the variables assuming the values as specified for them in the list of
equations or the single equation similar to that given to the ATVALUE
function.  If a subexpression depends on any of the variables in list
but it hasn't had an atvalue specified and it can't be evaluated then
a noun form of the AT will be returned which will display in a
two-dimensional form.  Do EXAMPLE(AT); for an example.

&ATAN - Arc Tangent

&ATAN2(Y,X) - yields the value of ATAN(Y/X) in the interval -%PI to
%PI.

&ATANH - Hyperbolic Arc Tangent

&ATOM(exp) is TRUE if exp is atomic (i.e. a number or name) else
FALSE.  Thus ATOM(5) is TRUE while ATOM(A[1]) and ATOM(SIN(X)) are
FALSE.  (Assuming A[1] and X are unbound.)

&ATOMGRAD - the atomic gradient property of an expression.
May be set by GRADEF.

&ATRIG1 - SHARE1;ATRIG1 FASL contains several additional
simplification rules for inverse trig functions.  Together with rules
already known to Macsyma, the following angles are fully implemented:
0, %PI/6, %PI/4, %PI/3, and %PI/2.  Corresponding angles in the other
three quadrants are also available.  Do LOAD(ATRIG1); to use them.

&ATVALUE(form, list, value) enables the user to assign the boundary
value value to form at the points specified by list.

(C1) ATVALUE(F(X,Y),[X=0,Y=1],A**2)$

    The form must be a function, f(v1,v2,...), or a derivative,
DIFF(f(v1,v2,...),vi,ni,vj,nj,...) in which the functional arguments
explicitly appear (ni is the order of differentiation with respect
vi).

    The list of equations determine the "boundary" at which the value
is given; list may be a list of equations, as above, or a single
equation, vi = expr.

    The symbols @1, @2,... will be used to represent the functional
variables v1,v2,... when atvalues are displayed.

    PRINTPROPS([f1, f2,...], ATVALUE) will display the atvalues of
the functions f1,f2,... as specified in previously given uses of the
ATVALUE function. If the list contains just one element then the
element can be given without being in a list.  If a first argument of
ALL is given then atvalues for all functions which have them will be
displayed.  Do EXAMPLE(ATVALUE); for an example.

&AUGCOEFMATRIX([eq1, ...], [var1, ...]) the augmented coefficient
matrix for the variables var1,... of the system of linear equations
eq1,....  This is the coefficient matrix with a column adjoined for
the constant terms in each equation (i.e. those not dependent upon
var1,...).  Do EXAMPLE(AUGCOEFMATRIX); for an example.

&AUTOLOAD - See SETUP_AUTOLOAD.
&BACKSUBST default: [TRUE] if set to FALSE will prevent back
substitution after the equations have been triangularized.  This may
be necessary in very big problems where back substitution would cause
the generation of extremely large expressions.  (On MC this could cause
storage capacity to be exceeded.)

&BACKTRACE default: [] (when DEBUGMODE:ALL has been done) has as value
a list of all functions currently entered.

&BACKUP - To "back up" and see what you did, see PLAYBACK.

&BASHINDICES(expr) - transforms the expression expr by giving each
summation and product a unique index. This gives CHANGEVAR greater
precision when it is working with summations or products.  The form of
the unique index is J<number>. The quantity <number> is determined by
referring to GENSUMNUM, which can be changed by the user.  For
example, GENSUMNUM:0$ resets it.

&BATCH(file-specification) reads in and evaluates MACSYMA command
lines from a file - A facility for executing command lines stored on a
disk file rather than in the usual on-line mode. This facility has
several uses, namely to provide a reservoir for working command lines,
for giving error-free demonstrations, or helping in organizing one's
thinking in complex problem-solving situations where modifications may
be done via a text editor.

A batch file consists of a set of MACSYMA command lines, each with its
terminating ; or $, which may be further separated by spaces,
carriage- returns, form-feeds, and the like.

The BATCH function calls for reading in the command lines from the
file one at a time, echoing them on the user console, and executing
them in turn.  Control is returned to the user console only when
serious errors occur or when the end of the file is met.  Of course,
the user may quit out of the file-processing by typing control-G at
any point.

BATCH files may be created using a text editor or by use of the
STRINGOUT command.  Do DESCRIBE(STRINGOUT) for details.

SHARE2;BATCH FASL has some functions in it that may be useful to users
who use BATCH to run MACSYMA while not being logged in.  Such things
as checking the status of a disowned running macsyma without stopping
it.  Do PRINTFILE(BATCH,USAGE,SHARE2); for details.

&BATCHKILL default: [FALSE] if TRUE then the effect of all previous
BATCH files is nullified because a KILL(ALL) and a RESET() will be
done automatically when the next one is read in.  If BATCHKILL is
bound to any other atom then a KILL of the value of BATCHKILL will be
done.

&BATCHLOAD(file-specification) - Batches in the file silently without
terminal output or labels.

&BATCON(argument) continues BATCHing in a file which was interrupted.

&BATCOUNT default: [0] may be set to the number of the last expression
BATCHed in from a file.  Thus BATCON(BATCOUNT-1) will resume BATCHing
from the expression before the last BATCHed in from before.

&BERLEFACT default: [TRUE] if FALSE then the Kronecker factoring
algorithm will be used otherwise the Berlekamp algorithm, which is the
default, will be used.

&BERN(x) - gives the Xth Bernoulli number for integer X.
ZEROBERN[TRUE] if set to FALSE excludes the zero BERNOULLI numbers.
(See also BURN).

&BERNPOLY(v, n) generates the nth Bernoulli polynomial in the
variable v.

&BESSEL(Z,A) returns the Bessel function J for complex Z and real A >
0.0 .  Also an array BESSELARRAY is set up such that BESSELARRAY[I] =
J[I+A- ENTIER(A)](Z).

&BETA(X, Y) - same as GAMMA(X)*GAMMA(Y)/GAMMA(X+Y).

&BEZOUT(p1, p2, var) - an alternative to the RESULTANT command.  It
returns a matrix. DETERMINANT of this matrix is the desired resultant.

&BFAC - This command is obsolete, use BFFAC.
&BFFAC(exp,n) - BFLOAT version of the Factorial (shifted Gamma)
function.  The 2nd argument is how many digits to retain and return,
it's a good idea to request a couple of extra.  This function is
available by doing LOAD(BFFAC); .

&BFLOAT(X) - converts all numbers and functions of numbers to bigfloat
numbers.  Setting FPPREC[16] to N, sets the bigfloat precision to N
digits.  If FLOAT2BF[FALSE] is FALSE a warning message is printed when
a floating point number is converted into a bigfloat number (since
this may lead to loss of precision).

&BFLOATP(exp) is TRUE if exp is a bigfloat number else FALSE.

&BFPSI(n,z,fpprec) gives polygammas of real arg and integer order.
For digamma, BFPSI0(z,fpprec) is more direct.  Note -BFPSI0(1,fpprec)
provides BFLOATed %GAMMA.  To use this do LOAD(BFFAC);

&BFTORAT default: [FALSE] controls the conversion of bfloats to
rational numbers.  If BFTORAT:FALSE, RATEPSILON will be used to
control the conversion (this results in relatively small rational
numbers).  If BFTORAT:TRUE, the rational number generated will
accurately represent the bfloat.

&BFTRUNC default: [TRUE] causes trailing zeroes in non-zero bigfloat
numbers not to be displayed.  Thus, if BFTRUNC:FALSE, BFLOAT(1);
displays as 1.000000000000000B0. Otherwise, this is displayed as
1.0B0.

&BFZETA(exp,n) - BFLOAT version of the Riemann Zeta function.  The 2nd
argument is how many digits to retain and return, it's a good idea to
request a couple of extra.  This function is available by doing
LOAD(BFFAC); .

&BGZETA(S, FPPREC) - BGZETA is like BZETA, but avoids arithmetic
overflow errors on large arguments, is faster on medium size arguments
(say S=55, FPPREC=69), and is slightly slower on small arguments.  It
may eventually replace BZETA.  BGZETA is available by doing
LOAD(BFAC);.

&BHZETA(S,H,FPPREC) - gives FPPREC digits of SUM((K+H)^-S,K,0,INF).
This is available by doing LOAD(BFFAC);.

&BINDTEST - causes ai to signal an error if it ever is used in a
computation unbound.

&BINOMIAL(X, Y) - the binomial coefficient X*(X-1)*...*(X-Y+1)/Y!. If X
and Y are integers, then the numerical value of the binomial
coefficient is computed.  If Y, or the value X-Y, is an integer, the
binomial coefficient is expressed as a polynomial.

&BLOCK([v1,...,vk], statement1,...,statementj) Blocks in MACSYMA are
somewhat analogous to subroutines in FORTRAN or procedures in ALGOL or
PL/I.  Blocks are like compound statements but also enable the user to
label statements within the block and to assign "dummy" variables to
values which are local to the block.  The vi are variables which are
local to the BLOCK and the stmti are any MACSYMA expressions.  If no
variables are to be made local then the list may be omitted.  A block
uses these local variables to avoid conflict with variables having the
same names used outside of the block (i.e. global to the block).  In
this case, upon entry to the block, the global values are saved onto a
stack and are inaccessible while the block is being executed.  The
local variables then are unbound so that they evaluate to themselves.
They may be bound to arbitrary values within the block but when the
block is exited the saved values are restored to these variables.  The
values created in the block for these local variables are lost.  Where
a variable is used within a block and is not in the list of local
variables for that block it will be the same as the variable used
outside of the block.

    If it is desired to save and restore other local properties
besides VALUE, for example ARRAY (except for complete arrays),
FUNCTION, DEPENDENCIES, ATVALUE, MATCHDECLARE, ATOMGRAD, CONSTANT, and
NONSCALAR then the function LOCAL should be used inside of the block
with arguments being the names of the variables.

    The value of the block is the value of the last statement or the
value of the argument to the function RETURN which may be used to exit
explicitly from the block. The function GO may be used to transfer
control to the statement of the block that is tagged with the argument
to GO.  To tag a statement, precede it by an atomic argument as
another statement in the BLOCK.  For example:
BLOCK([X],X:1,LOOP,X:X+1,...,GO(LOOP),...).  The argument to GO must
be the name of a tag appearing within the BLOCK.  One cannot use GO to
transfer to a tag in a BLOCK other than the one containing the GO.

    Blocks typically appear on the right side of a function definition
but can be used in other places as well.

&BOTHCASES default: [FALSE] if TRUE will cause MACSYMA to retain lower
case text as well as upper case. Note, however, that the names of any
MACSYMA special variables or functions must be typed in upper case.
(For historical reasons this is also a function, but it should be used
as a switch.  Please use it as described here, not as a function.)

&BOTHCOEF(exp, var) returns a list whose first member is the
coefficient of var in exp (as found by RATCOEF if exp is in CRE form
otherwise by COEFF) and whose second member is the remaining part of
exp.  That is, [A,B] where exp=A*var+B.

(C1) ISLINEAR(EXP,VAR):=BLOCK([C],
        C:BOTHCOEF(RAT(EXP,VAR),VAR),
        IS(FREEOF(VAR,C) AND C[1]#0))$

(C2) ISLINEAR((R**2-(X-R)**2)/X,X);

(D2)                              TRUE

&BOX(expr) returns expr enclosed in a box.  The box is actually part
of the expression.  BOX(expr,label) encloses expr in a labelled box.
label is a name which will be truncated in display if it is too long.

    BOXCHAR["] - is the character used to draw the box in this and in
the DPART and LPART functions.

&BOXCHAR default: ["] is the character used to draw the box in the BOX
and in the DPART and LPART functions.

&BREAK(arg1, ...) will evaluate and print its arguments and will then
cause a (MACSYMA-BREAK) at which point the user can examine and change
his environment.  Upon typing EXIT; the computation resumes.

Control-A (^A) will enter a MACSYMA-BREAK from any point
interactively.  EXIT; will continue the computation.  Control-X may be
used inside the MACSYMA-BREAK to quit locally, without quitting the
main computation.

&BREAKUP default: [TRUE] if FALSE will cause SOLVE to express the
solutions of cubic or quartic equations as single expressions rather
than as made up of several common subexpressions which is the default.
BREAKUP:TRUE only works when PROGRAMMODE is FALSE.

&BUG("message") similar to mail, sends a message to MACSYMA Mail.
This may be used for reporting bugs or suspected bugs in MACSYMA.
Expressions may be included by referring to them, outside double
quotes, e.g.

BUG("I am trying to integrate",D3,"but it asks for more list space.
What should I do?");

&BUILDQ - See DESCRIBE(MACROS); .

&BURN(N) is like BERN(N), but without computing all of the uncomputed
Bernoullis of smaller index.  So BURN works efficiently for large,
isolated N.  (BERN(402) takes about 645 secs vs 13.5 secs for
BURN(402).  BERN's time growth seems to be exponential, while BURN's
is about cubic.  But if next you do BERN(404), it only takes 12 secs,
since BERN remembers all in an array, whereas BURN(404) will take
maybe 14 secs or maybe 25, depending on whether MACSYMA needs to
BFLOAT a better value of %PI.)  BURN is available by doing LOAD(BFFAC);.

BURN uses an observation of WGD that (rational) Bernoulli numbers can be
approximated by (transcendental) zetas with tolerable efficiency.

&BZETA - This function is obsolete, see BFZETA.

&CABS(exp) returns the complex absolute value (the complex modulus) of
exp.

&CANFORM(exp) [Tensor Package] Simplifies exp by renaming dummy
indices and reordering all indices as dictated by symmetry conditions
imposed on them. If ALLSYM is TRUE then all indices are assumed
symmetric, otherwise symmetry information provided by DECSYM
declarations will be used. The dummy indices are renamed in the same
manner as in the RENAME function. When CANFORM is applied to a large
expression the calculation may take a considerable amount of time.
This time can be shortened by calling RENAME on the expression first.
Also see the example under DECSYM. Note: CANFORM may not be able to
reduce an expression completely to its simplest form although it will
always return a mathematically correct result.

&CANTEN(exp) [Tensor Package] Simplifies exp by renaming (see RENAME)
and permuting dummy indices. CANTEN is restricted to sums of tensor
products in which no derivatives are present. As such it is limited
and should only be used if CANFORM is not capable of carrying out the
required simplification.

&CARG(exp) returns the argument (phase angle) of exp.  Due to the
conventions and restrictions, principal value cannot be guaranteed
unless exp is numeric.

&CARTAN - The exterior calculus of differential forms is a basic tool
of differential geometry developed by Elie Cartan and has important
applications in the theory of partial differential equations.  The
present implementation is due to F.B. Estabrook and H.D. Wahlquist.
The program is self-explanatory and can be accessed by doing
BATCH(CARTAN,START,DSK,SHARE2); which will give a description with
examples.

&CATCH(exp1,...,expn) evaluates its arguments one by one; if the
structure of the expi leads to the evaluation of an expression of the
form THROW(arg), then the value of the CATCH is the value of
THROW(arg).  This "non-local return" thus goes through any depth of
nesting to the nearest enclosing CATCH.  There must be a CATCH
corresponding to a THROW, else an error is generated.  If the
evaluation of the expi does not lead to the evaluation of any THROW
then the value of the CATCH is the value of expn.

(C1) G(L):=CATCH(MAP(LAMBDA([X],
       IF X<0 THEN THROW(X) ELSE F(X)),L))$

(C2) G([1,2,3,7]);
(D2)                     [F(1), F(2), F(3), F(7)]

(C3) G([1,2,-3,7]);
(D3)                                - 3

  The function G returns a list of F of each element of L if L
consists only of non-negative numbers; otherwise, G "catches" the
first negative element of L and "throws" it up.

&CAUCHYSUM default: [FALSE] - When multiplying together sums with INF
as their upper limit, if SUMEXPAND is TRUE and CAUCHYSUM is set to
TRUE then the Cauchy product will be used rather than the usual
product.  In the Cauchy product the index of the inner summation is a
function of the index of the outer one rather than varying
independently.  That is: SUM(F(I),I,0,INF)*SUM(G(J),J,0,INF) becomes
SUM(SUM(F(I)*G(J-I),I,0,J),J,0,INF)

&CBFAC(z,fpprec) - a factorial for complex bfloats.  It may be used by
doing LOAD(BFAC); For more details see SHARE2;BFAC USAGE.

&CENTERPLOT default: [] - VIEWPT and CENTERPLOT determine the
perspective view taken for plotting commands.  They are defaulted to
be unbound.  VIEWPT may be set to a list of 3 numbers and gives the
point from which the projection should be made.  CENTERPLOT may
likewise be set to a list of 3 numbers and gives a point on the line
of sight.  The projection will be made onto a plane perpendicular to a
line joining VIEWPT and CENTERPLOT.

  If VIEWPT and CENTERPLOT are unbound (the default) then they will be
chosen as follows: the extreme values of the coordinates are
determined.  This gives the two points min: [xmin,ymin,zmin],
max:[xmax,ymax,zmax]. CENTERPLOT is chosen as (min+max)/2, and VIEWPT
is chosen as max+3*(max-min).  The view is then one in which the z
axis is vertical, the x axis is increasing towards you to the left and
the y axis is increasing towards you to the right.

  If CENTERPLOT is FALSE then the old type of perspective view will be
given (like setting the x and z components of CENTERPLOT to the
corresponding components of VIEWPT).

&CF(exp) converts exp into a continued fraction.  exp is an expression
composed of arithmetic operators and lists which represent continued
fractions.  A continued fraction a+1/(b+1/(c+...)) is represented by
the list [a,b,c,...]. a,b,c,.. must be integers.  Exp may also involve
SQRT(n) where n is an integer.  In this case CF will give as many
terms of the continued fraction as the value of the variable
CFLENGTH[1] times the period.  Thus the default is to give one period.
(CF binds LISTARITH to FALSE so that it may carry out its function.)

&CFDISREP(list) converts the continued fraction represented by list
into general representation.

(C1) CF([1,2,-3]+[1,-2,1]);

(D1)                 [1, 1, 1, 2]

(C2) CFDISREP(%);
                            1
(D2)                1 + ---------
                              1
                        1 + -----
                                1
                            1 + -
                                2

&CFEXPAND(x) gives a matrix of the numerators and denominators of the
next-to-last and last convergents of the continued fraction x.

(C1) CF(SQRT(3));
(D1)                 [1, 1, 2, 1, 2, 1, 2, 1]

(C2) CFEXPAND(%);
                             [71  97]
(D2)                         [      ]
                             [41  56]

(C3) D2[1,2]/D2[2,2],NUMER;
(D3)                        1.7321429

&CFLENGTH default: [1] controls the number of terms of the continued
fraction the function CF will give, as the value CFLENGTH[1] times the
period.  Thus the default is to give one period.

&CGAMMA - The Gamma function in the complex plane.  Do LOAD(CGAMMA) to
use these functions.  Functions Cgamma, Cgamma2, and LogCgamma2.
These functions evaluate the Gamma function over the complex plane
using the algorithm of Kuki, CACM algorithm 421.  Calculations are
performed in single precision and the relative error is typically
around 1.0E-7; evaluation at one point costs less than 1 msec.  The
algorithm provides for an error estimate, but the Macsyma
implementation currently does not use it.

Cgamma is the general function and may be called with a symbolic or
numeric argument.  With symbolic arguments, it returns as is; with
real floating or rational arguments, it uses the Macsyma Gamma
function; and for complex numeric arguments, it uses the Kuki
algorithm.

Cgamma2 of two arguments, real and imaginary, is for numeric arguments
only; LogCgamma2 is the same, but the log-gamma function is
calculated.  These two functions are somewhat more efficient.

&CGAMMA2 - See CGAMMA.

&CHANGE_FILEDEFAULTS default: [TRUE] on MIT-MC, and FALSE elsewhere.
Controls whether the user doing a LOADFILE, RESTORE, BATCH or DEMO has
his file defaults changed to the file referenced in such a command.
The TRUE setting is for people who like DDT-style file defaulting.
The FALSE setting is for people who like the conventions of other
operating systems, who like LISP-style file defaulting, or who write
packages which do LOADFILEs or BATCHes which should not interfere with
their user's file defaults.

&CHANGEVAR(exp,f(x,y),y,x) makes the change of variable given by
f(x,y) = 0 in all integrals occurring in exp with integration with
respect to x; y is the new variable.

    (C1) 'INTEGRATE(%E**SQRT(A*Y),Y,0,4);

                        4
                       /
                       [    SQRT(A) SQRT(Y)
    (D1)               I (%E               ) dY
                       ]
                       /
                        0

    (C2) CHANGEVAR(D1,Y-Z^2/A,Z,Y);

                                   2 SQRT(A)
                                  /
                                  [              Z
                                2 I          Z %E  dZ
                                  ]
                                  /
                                   0
    (D4)                        ---------------------
                                          A

CHANGEVAR may also be used to changes in the indices of a sum or
product.  However, it must be realized that when a change is made in a
sum or product, this change must be a shift, i.e. I=J+ ..., not a
higher degree function.  E.g.

(C3) SUM(A[I]*X^(I-2),I,0,INF);

                               INF
                               ====
                               \         I - 2
(D3)                            >    A  X
                               /      I
                               ====
                               I = 0

(C4) CHANGEVAR(%,I-2-N,N,I);

                              INF
                              ====
                              \               N
(D4)                           >      A      X
                              /        N + 2
                              ====
                              N = - 2

&CHARACTERS - MACSYMA makes use of a number of control characters in
the version of MACSYMA which runs on the MC machine and on the DEC-20.
Some of these characters may not work or may have different effects in
the Vax, Multics or Lisp Machine versions of MACSYMA.  Control
characters are typed by holding down the key labeled "Control" or
"Ctrl" and typing the indicated letter, much the same way the "Shift"
key is used.  MACSYMA's control characters and their actions are:

  Control-A (^A) - makes a breakpoint in MACSYMA and suspends the
computation.  At this point the user is in a MACSYMA break loop.  If a
user function was being executed at the time of the break, its values
may be printed or changed.  Aside from this, it is almost like being
at top-level MACSYMA.  To exit and resume the computation type EXIT;

  Control-^ (^^) - enters top-level LISP after resetting all locally
bound variables and breaking out of all functions.  It is not possible
to continue an interrupted calculation after a control-^, but typing
(CONTINUE) will return to MACSYMA.

  Control-X (^X) - quits a computation started in a control-A break without
quitting the top-level computation, specifically the action is:
    (a) If you are at MACSYMA-TOPLEVEL, as if you typed ^G.
    (b) If  you are in a MACSYMA-BREAK, it quits back to the break.
    (c) If you are in LISP-TOPLEVEL or LISP-BREAK, it does what typing
         ^X to LISP does, namely an (ERROR 'QUIT).

  Control-] (^]) - prints the time used so far in a computation
(without interrupting it).

  Control-U (^U) - the User-Interrupt-Character.  To use this feature,
one sets TTYINTFUN (default FALSE meaning feature not in use) to a
function of no arguments.  Then whenever ^U is typed, this function is
run.  E.g. suppose you have a FOR statement loop which increments I,
and you want an easy way of checking on the value of I while the FOR
statement is running.  You can do: TTYINTFUN:PRINTI$
PRINTI():=PRINT(I)$ , then whenever you type (e.g.)  ^U you get the
check you want.  (Another character may be chosen for this function,
by resetting TTYINTNUM[21] to the ascii value of some other
character.)

  Control-K (^K) - reprints the current input line.  This is useful
when many rubouts have obscured the line (on hardcopy devices).

  Control-Y (^Y) - gets the last command string. (The last thing you
typed on a C-line.)

  Control-L (^L) - clears the screen on display consoles and reprints
the current line.

  Control-W (^W) - stops printout at the console while the computation
continues. (If the user is connected to MACSYMA via the ARPA network,
printout will not stop until the Arpanet buffer is emptied.) The
switch TTYOFF[FALSE] if set to TRUE also stops the printout.  This is
useful for temporarily turning off the display for functions which
might generate a lot of printing like BATCH.  Setting the switch to
FALSE causes printing to be resumed.

  Control-S (^S) - turns printout off until just before the next
C-line which prompts for input from the console is to be printed.
(Typing ^V or a quit character will also resume printout in this
case.)  ^S should prove useful for shutting off long D-line displays
and all printout from running a BATCH file.  One just issues a call to
BATCH, and types ^S any time after the batch starts.  Printout will
resume when the batch is done (or when necessary, e.g.  to allocate
space).

  Control-V (^V) - resumes printout at the console turned off by
control-W or control-S.

  Control-G (^G) - aborts a computation and returns control to
top-level MACSYMA.  This is like control-^ immediately followed by
(CONTINUE) and is useful for breaking out of infinite loops or for
terminating a computation prematurely.

  Control-B (^B) - makes a "breakpoint" in MACSYMA, enters LISP, and
prints the time used in the current computation.  Control-B does not
reset any values.  Altmode (or Escape) P (for proceed) followed by a
space will return to MACSYMA and resume the computation.

  Control-H (^H) or BACKSPACE probably does not do what you expect or
want: it no longer gives a LISP breakpoint (Type ^B to get that) and
it is not equivalent to erasing the previous character, although on a
display this may APPEAR to be the effect.  Instead, typing ^H will
print out a message telling you to use the RUBOUT or DEL(ETE) key to
erase a character, and will then simulate a ^K, i.e. reprint the
current string, to clear the air.

  Control-D (^D) - causes garbage collection statistics to be printed
out each time a garbage collection takes place.  Typing it a second time
turns off the printout.

&CHARPOLY(M, var) computes the characteristic polynomial for Matrix M
with respect to var.  That is, DETERMINANT(M - DIAGMATRIX(LENGTH(M),var)).
For examples of this command, do EXAMPLE(CHARPOLY); .

&CHR1([i,j,k]) yields the Christoffel symbol of the first kind via the
definition

       (g      + g      - g     )/2 .
         ik,j     jk,i     ij,k

To evaluate the Christoffel symbols for a particular metric, the
variable METRIC must be assigned a name as in the example under CHR2.

&CHR2([i,j],[k]) yields the Christoffel symbol of the second kind
defined by the relation

                       ks
    CHR2([i,j],[k]) = g    (g      + g      - g     )/2
                             is,j     js,i     ij,s

&CHRISTOF(arg) - A function in the CTENSR (Component Tensor
Manipulation) package.  It computes the Christoffel symbols of both
kinds.  The arg determines which results are to be immediately
displayed.  The Christoffel symbols of the first and second kinds are
stored in the arrays LCS[i,j,k] and MCS[i,j,k] respectively and
defined to be symmetric in the first two indices. If the argument to
CHRISTOF is LCS or MCS then the unique non-zero values of LCS[i,j,k]
or MCS[i,j,k], respectively, will be displayed. If the argument is ALL
then the unique non-zero values of LCS[i,j,k] and MCS[i,j,k] will be
displayed.  If the argument is FALSE then the display of the elements
will not occur. The array elements MCS[i,j,k] are defined in such a
manner that the final index is contravariant.

&CLEARSCREEN() - Clears the screen.  The same as typing control-L.

&CLOSEFILE(filename1, filename2) closes a file opened by WRITEFILE and
gives it the name filename1 filename2.  (On a Lisp Machine one need
only say CLOSEFILE();.)  Thus to save a file consisting of the display
of all input and output during some part of a session with MACSYMA the
user issues a WRITEFILE, transacts with MACSYMA, then issues a
CLOSEFILE.  The user can also issue the PLAYBACK function after a
WRITEFILE to save the display of previous transactions.  (Note that
what is saved this way is a copy of the display of expressions not the
expressions themselves).  To save the actual expression in internal
form the SAVE function may be used.  The expression can then be
brought back into MACSYMA via the LOADFILE function.  To save the
expression in a linear form which may then be BATCHed in later, the
STRINGOUT function is used.

&CMD - an abbreviation commonly used for "command", i.e. the name of a
MACSYMA function which performs some operation.  DESCRIBE(cmd) means
put the name of a MACSYMA command in place of "cmd", e.g.
DESCRIBE(INTEGRATE); .

&COEFF(exp, v, n) obtains the coefficient of v**n in exp.  n may be
omitted if it is 1.  v may be an atom, or complete subexpression of
exp e.g., X, SIN(X), A[I+1], X+Y, etc. (In the last case the
expression (X+Y) should occur in exp).  Sometimes it may be necessary
to expand or factor exp in order to make v^n explicit.  This is not
done automatically by COEFF.

(C1) COEFF(2*A*TAN(X)+TAN(X)+B=5*TAN(X)+3,TAN(X));

(D1)                         2 A + 1 = 5

(C2) COEFF(Y+X*%E**X+1,X,0);
(D2)                            Y + 1

&COEFMATRIX([eq1, ...], [var1, ...]) the coefficient matrix for the
variables var1,... of the system of linear equations eq1,...

&COL(M,i) gives a matrix of the ith column of the matrix M.

&COLLAPSE(expression) - "collapses" its argument by causing all of its
common (i.e. equal) subexpressions to share (i.e. use the same cells),
thereby saving space.  (COLLAPSE is a subroutine used by the OPTIMIZE
command.)  Thus, calling COLLAPSE may be useful before using FASSAVE
or after loading in a SAVE file.  You can collapse several expressions
together by using COLLAPSE([expr1,...,exprN])$.  Similarly, you can
collapse the elements of the array A by doing
COLLAPSE(LISTARRAY('A))$.

&COLUMNVECTOR(X) - a function in the EIGEN package.  Do LOAD(EIGEN) to
use it.  COLUMNVECTOR takes a LIST as its argument and returns a
column vector the components of which are the elements of the list.
The first element is the first component,...etc...(This is useful if
you want to use parts of the outputs of the functions in this package
in matrix calculations.)

&COMBINE(exp) simplifies the sum exp by combining terms with the same
denominator into a single term.

&COMEXP(exp)  This command no longer exists.  See OPTIMIZE.

&COMMAND - A MACSYMA function which performs some operation.  E.g.
INTEGRATE, DIFF, etc.  DESCRIBE(command) means use the name of a
MACSYMA command in place of the word "command", e.g.
DESCRIBE(INTEGRATE); .

&COMMUTATIVE - If DECLARE(H,COMMUTATIVE); is done, this tells the
simplifier that H is a commutative function.  E.g. H(X,Z,Y) will
simplify to H(X, Y, Z).  This is the same as SYMMETRIC.

&COMPFILE([filespec], f1, f2, ..., fn) - Compiles functions fi into
the file "filespec".  For convenience, see the COMPILE function.

&COMPGRIND default: [FALSE] when TRUE function definitions output by
COMPFILE are pretty-printed.

&COMPILE - The COMPILE command is a convenience feature in macsyma. It
handles the calling of the function COMPFILE, which translates macsyma
functions into lisp, the calling of the lisp compiler on the file
produced by COMPFILE, and the loading of the output of the compiler,
know as a FASL file, into the macsyma. It also checks the compiler
comment listing output file for certain common errors.  Do
PRINTFILE(MCOMPI,DOC,MAXDOC); for more details.

COMPILE(); causes macsyma to prompt for arguments. 

COMPILE(function1,function2,...); compiles the functions, it uses the name
of function1 as the first name of the file to put the lisp output.

COMPILE(ALL); or COMPILE(FUNCTIONS); will compile all functions.

COMPILE([file-name],function1,function2,...); N.B. all arguments are
evaluated, just like a normal function (it is a normal function!).
Therefore, if you have variables with the same name as part of the
file you can not ignore that fact.

&COMPILE_LISP_FILE("input filename") which takes an optional second
argument of "output filename," can be used in conjunction with
TRANSLATE_FILE("filename").  For convenience you might define
	Compile_and_load(FILENAME):=
	 LOAD(COMPILE_LISP_FILE(TRANSLATE_FILE(FILENAME)[2]))[2]);
These file-oriented commands are to be preferred over the use of
COMPILE, COMPFILE, and the TRANSLATE SAVE combination.

&COMPLEX - A complex expression is specified in MACSYMA by adding the
real part of the expression to %I times the imaginary part.  Thus the
roots of the equation X^2-4*X+13=0 are 2+3*%I and 2-3*%I.  Note that
simplification of products of complex expressions can be effected by
expanding the product.  Simplification of quotients, roots, and other
functions of complex expressions can usually be accomplished by using
the REALPART, IMAGPART, RECTFORM, POLARFORM, ABS, CARG functions.

&COMPRESS - This command has been withdrawn, see COLLAPSE.
&COMPRESS_FILE - This command has been withdrawn, see COLLAPSE.
&CONCAT(arg1, arg2, ...) evaluates its arguments and returns the
concatenation of their values resulting in a name or a quoted string
the type being given by that of the first argument.  Thus if X is
bound to 1 and D is unbound then CONCAT(X,2)="12" and
CONCAT(D,X+1)=D2.

&CONJUGATE(X) - a function in the EIGEN package on the SHARE
directory.  It returns the complex conjugate of its argument.  This
package may be loaded by LOAD(EIGEN); .  For a complete description
of this package, do PRINTFILE(EIGEN,USAGE,SHARE); .

&CONS(exp, list) returns a new list constructed of the element exp as
its first element, followed by the elements of list.  CONS also works
on other expressions, e.g. CONS(X, F(A,B,C));  ->  F(X,A,B,C).

&CONSTANT - makes ai a constant as is %PI.

&CONSTANTP(exp) is TRUE if exp is a constant (i.e.  composed of
numbers and %PI, %E, %I or any variables bound to a constant or
DECLAREd constant) else FALSE.  Any function whose arguments are
constant is also considered to be a constant.

&CONTENT(p1, var1, ..., varn) returns a list whose first element is
the greatest common divisor of the coefficients of the terms of the
polynomial p1 in the variable varn (this is the content) and whose
second element is the polynomial p1 divided by the content.

(C1) CONTENT(2*X*Y+4*X**2*Y**2,Y);

(D1)            [2*X, 2*X*Y**2+Y].

&CONTEXT default: INITIAL. Whenever a user assumes a new fact, it is
placed in the context named as the current value of the variable
CONTEXT.  Similarly, FORGET references the current value of CONTEXT.
To change contexts, simply bind CONTEXT to the desired context.  If
the specified context does not exist it will be created by an
invisible call to NEWCONTEXT.  The context specified by the value of
CONTEXT is automatically activated.  (Do DESCRIBE(CONTEXTS); for a
general description of the CONTEXT mechanism.)

&CONTEXTS default: [INITIAL,GLOBAL] is a list of the contexts which
currently exist, including the currently active context.

The context mechanism makes it possible for a user to bind together
and name a selected portion of his data base, called a context.  Once
this is done, the user can have MACSYMA assume or forget large numbers
of facts merely by activating or deactivating their context.  Any
symbolic atom can be a context, and the facts contained in that
context will be retained in storage until the user destroys them
individually by using FORGET or destroys them as a whole by using KILL
to destroy the context to which they belong.

    Contexts exist in a formal hierarchy, with the root always being
the context GLOBAL, which contains information about MACSYMA that some
functions need.  When in a given context, all the facts in that
context are "active" (meaning that they are used in deductions and
retrievals) as are all the facts in any context which is an inferior
of that context.  When a fresh MACSYMA is started up, the user is in a
context called INITIAL, which has GLOBAL as a subcontext.

The functions which deal with contexts are: FACTS, NEWCONTEXT,
SUPCONTEXT, KILLCONTEXT, ACTIVATE, DEACTIVATE, ASSUME, and FORGET.

&CONTINUE - Control-^ typed while in MACSYMA causes LISP to be
entered.  The user can now type any LISP S-expression and have it
evaluated.  Typing (CONTINUE) or ^G (control-G) causes MACSYMA to be
re-entered.

&CONTOUR default: [] An option in the PLOT3D package to allow contour
plotting.

&CONTRACT(exp) carries out all possible contractions in exp, which may
be any well-formed combination of sums and products.  This function
uses the information given to the DEFCON function.  Since all tensors
are considered to be symmetric in all indices, the indices are sorted
into alphabetical order.  Also all dummy indices are renamed using the
symbols !1,!2,... to permit the expression to be simplified as much as
possible by reducing equivalent terms to a canonical form.  For best
results exp should be fully expanded.  RATEXPAND is the fastest way to
expand products and powers of sums if there are no variables in the
denominators of the terms.  The GCD switch should be FALSE if gcd
cancellations are unnecessary.

&CONTROL - For a description of the various Control-characters which
MACSYMA uses to control computation, do DESCRIBE(CHARACTERS);

&COPYLIST(L) creates a copy of the list L.

&COPYMATRIX(M) creates a copy of the matrix M.  This is the only way
to make a copy aside from recreating M elementwise.  Copying a matrix
may be useful when SETELMX is used.

&COPYRIGHT - (c) 1976,1984, Massachusetts Institute of Technology.
All Rights Reserved.
Enhancements (c) 1984, Symbolics, Inc. All Rights Reserved.

The data and information in the Enhancements is proprietary
to, and a valuable trade secret of, SYMBOLICS, INC., a
Delaware corporation.  It is given in confidence by
SYMBOLICS, and may not be used as the basis of manufacture,
or be reproduced or copied, or distributed to any other
party, in whole or in part, without the prior written
consent of SYMBOLICS.

&COS - Cosine &COSH - Hyperbolic Cosine
&COT - Cotangent &COTH - Hyperbolic Cotangent

&COUNTER default: [1] determines the numerical suffix to be used in
generating the next dummy index in the tensor package.  The prefix is
determined by the option DUMMYX[#].

&COVDIFF(exp,v1,v2,...) yields the covariant derivative of exp with
respect to the variables vi in terms of the Christoffel symbols of the
second kind (CHR2).  In order to evaluate these, one should use
EV(exp,CHR2).

&CPU - Do DESCRIBE(STATUS) for information about finding the CPU time
for your computation.

&CRE - Canonical Rational Expressions constitute a kind of
representation which is especially suitable for expanded polynomials
and rational functions (as well as for partially factored polynomials
and rational functions when RATFAC[FALSE] is set to TRUE).  In this
CRE form an ordering of variables (from most to least main) is assumed
for each expression.  Polynomials are represented recursively by a
list consisting of the main variable followed by a series of pairs of
expressions, one for each term of the polynomial.  The first member of
each pair is the exponent of the main variable in that term and the
second member is the coefficient of that term which could be a number
or a polynomial in another variable again represented in this form.
Thus the principal part of the CRE form of 3*X^2-1 is (X 2 3 0 -1) and
that of 2*X*Y+X-3 is (Y 1 (X 1 2) 0 (X 1 1 0 -3)) assuming Y is the
main variable, and is (X 1 (Y 1 2 0 1) 0 -3) assuming X is the main
variable. "Main"-ness is usually determined by reverse alphabetical
order.

The "variables" of a CRE expression needn't be atomic.  In fact any
subexpression whose main operator is not + - * / or ^ with integer
power will be considered a "variable" of the expression (in CRE form)
in which it occurs.  For example the CRE variables of the expression
X+SIN(X+1)+2*SQRT(X)+1 are X, SQRT(X), and SIN(X+1).  If the user does
not specify an ordering of variables by using the RATVARS function
MACSYMA will choose an alphabetic one.  Integer exponents in CRE
expressions are assumed to be fixnums.

In general, CRE's represent rational expressions, that is, ratios of
polynomials, where the numerator and denominator have no common
factors, and the denominator is positive.  The internal form is
essentially a pair of polynomials (the numerator and denominator)
preceded by the variable ordering list.

If an expression to be displayed is in CRE form or if it contains any
subexpressions in CRE form, the symbol /R/ will follow the line label.
See the RAT function for converting an expression to CRE form.

An extended CRE form is used for the representation of Taylor series.
The notion of a rational expression is extended so that the exponents
of the variables can be positive or negative rational numbers rather
than just positive integers and the coefficients can themselves be
rational expressions as described above rather than just polynomials.
These are represented internally by a recursive polynomial form which
is similar to and is a generalization of CRE form, but carries
additional information such as the degree of truncation.

As with CRE form, the symbol /T/ follows the line label of such
expressions.

&CTENSR - Component Tensor Manipulation Package.  To use the CTENSR
package, type TSETUP(); which automatically loads it from within
MACSYMA (if it is not already loaded) and then prompts the user to
input his coordinate system.  The user is first asked to specify the
dimension of the manifold. If the dimension is 2, 3 or 4 then the list
of coordinates defaults to [X,Y], [X,Y,Z] or [X,Y,Z,T] respectively.
These names may be changed by assigning a new list of coordinates to
the variable OMEGA (described below) and the user is queried about
this.

** Care must be taken to avoid the coordinate names conflicting
with other object definitions **.

Next, the user enters the metric either directly or from a file by
specifying its ordinal position. As an example of a file of common
metrics, see TENSOR;METRIC FILE. The metric is stored in the matrix
LG. Finally, the metric inverse is computed and stored in the matrix
UG. One has the option of carrying out all calculations in a power
series.

A sample protocol is begun below for the static, spherically symmetric
metric (standard coordinates) which will be applied to the problem of
deriving Einstein's vacuum equations (which lead to the Schwarzschild
solution) as an example. Many of the functions in CTENSR will be
displayed for the standard metric as examples.

(C2) TSETUP();
Enter the dimension of the coordinate system: 
4;
Do you wish to change the coordinate names?
N;
Do you want to
1. Enter a new metric?
2. Enter a metric from a file?
3. Approximate a metric with a Taylor series?
Enter 1, 2 or 3 
1;

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;

Row 1 Column 1:  A;

Row 2 Column 2:  X^2;

Row 3 Column 3:  X^2*SIN(Y)^2;

Row 4 Column 4:  -D;

Matrix entered.
Enter functional dependencies with the DEPENDS function or 'N' if none 
DEPENDS([A,D],X);
Do you wish to see the metric? 
Y;
                          [ A  0       0        0  ]
                          [                        ]
                          [     2                  ]
                          [ 0  X       0        0  ]
                          [                        ]
                          [         2    2         ]
                          [ 0  0   X  SIN (Y)   0  ]
                          [                        ]
                          [ 0  0       0       - D ]

Do you wish to see the metric inverse? 
N;

&CSC - Cosecant
&CSCH - Hyperbolic Cosecant

&CURRENT_LET_RULE_PACKAGE default:[DEFAULT_LET_RULE_PACKAGE] - the
name of the rule package that is presently being used.  The user may
reset this variable to the name of any rule package previously defined
via the LET command.  Whenever any of the functions comprising the let
package are called with no package name the value of
CURRENT_LET_RULE_PACKAGE is used.  If a call such as
LETSIMP(expr,rule_pkg_name); is made, the rule package rule_pkg_name
is used for that LETSIMP command only, i.e.  the value of
CURRENT_LET_RULE_PACKAGE is not changed.

&CURSOR default: [$] is the prompt symbol of the MACSYMA editor.

&CURSORDISP default: [TRUE] If TRUE, causes expressions to be drawn by
the displayer in logical sequence.  This only works with a console
which can do cursor movement.  If FALSE, expressions are simply
printed line by line.  CURSORDISP is FALSE when a WRITEFILE is in
effect.

&CURVATURE([i,j,k],[h]) - (Indicial Tensor Package) yields the Riemann
curvature tensor in terms of the Christoffel symbols of the second
kind (CHR2).  The following notation is used:

               h            h           h        %1        h
      CURVATURE     = - CHR2      - CHR2     CHR2    + CHR2
               i j k        i k,j       %1 j     i k       i j,k

                              h         %1
                        + CHR2      CHR2
                              %1 k      i j

&DBLINT('F,'R,'S,a,b) - a double-integral routine which was written in
top-level macsyma and then translated and compiled to machine code.
Use LOAD(DBLINT); to access this package.  It uses the Simpson's Rule
method in both the x and y directions to calculate

/B /S(X)
|  |
|  |    F(X,Y) DY DX .
|  |
/A /R(X)

The function F(X,Y) must be a translated or compiled function of two
variables, and R(X) and S(X) must each be a translated or compiled
function of one variable, while a and b must be floating point
numbers. The routine has two global variables which determine the
number of divisions of the x and y intervals: DBLINT_X and DBLINT_Y,
both of which are initially 10, and can be changed independently to
other integer values (there are 2*DBLINT_X+1 points computed in the x
direction, and 2*DBLINT_Y+1 in the y direction).

The routine subdivides the X axis and then for each value of X it
first computes R(X) and S(X); then the Y axis between R(X) and S(X) is
subdivided and the integral along the Y axis is performed using
Simpson's Rule; then the integral along the X axis is done using
Simpson's Rule with the function values being the Y-integrals. This
procedure may be numerically unstable for a great variety of reasons,
but is reasonably fast: avoid using it on highly oscillatory functions
and functions with singularities (poles or branch points in the
region).  The Y integrals depend on how far apart R(X) and S(X) are,
so if the distance S(X)-R(X) varies rapidly with X, there may be
substantial errors arising from truncation with different step-sizes
in the various Y integrals. One can increase DBLINT_X and DBLINT_Y in
an effort to improve the coverage of the region, at the expense of
computation time. The function values are not saved, so if the
function is very time-consuming, you will have to wait for
re-computation if you change anything (sorry).

It is required that the functions F, R, and S be either translated or
compiled prior to calling DBLINT. This will result in orders of
magnitude speed improvement over interpreted code in many cases! Ask
LPH (or GJC) about using these numerical aids.  The file SHARE1;DBLINT
DEMO can be run in batch or demo mode to illustrate the usage on a
sample problem; the file SHARE1;DBLNT DEMO1 is an extension of the DEMO
which also makes use of other numerical aids, FLOATDEFUNK and QUANC8.
Please send all bug notes and questions to LPH@MIT-MC.

&DCADRE - The IMSL version of Romberg integration is now available in
Macsyma.  For documentation, Do PRINTFILE(DCADRE,USAGE,IMSL1); .  For
a demo, do BATCH(DCADRE,DEMO,DSK,IMSL1); .
This is a numerical integration package using cautious, adaptive
Romberg extrapolation.

The DCADRE package is written to call the IMSL fortran library routine
DCADRE. This is documentation for that program. Send bugs/comments to
KMP@MC.

To load this package, do 

  LOADFILE(IMSL,FASL,SHARE2)$

For a demo of this package, do

  BATCH(DCADRE,DEMO,SHARE2)$

The worker function takes the following syntax:

IMSL_ROMBERG(fn,low,hi)

where fn is a function of 1 argument; low and hi should be the lower and
upper bounds of integration. fn must return floating point values.

IMSL_ROMBERG(exp,var,low,hi)

  where exp should be integrated over the range var=low to hi. The result
  of evaluating exp must always be a floating point number.

FAST_IMSL_ROMBERG(fn,low,hi)

  This function does no error checking but may achieve a speed gain over
  the IMSL_ROMBERG function. It expects that fn is a Lisp function (or
  translated Macsyma function) which accepts a floating point argument 
  and that it always returns a floating point value.
           
Returns either

 [SUCCESS, answer, error] where answer is the result of the integration and
  error is the estimated bound on the absolute error of the output, DCADRE,
  as described in PURPOSE below.

or

 [WARNING, n, answer, error] where n is a warning code, answer is the answer,
  and error is the estimated bound on the absolute error of the output, DCADRE,
  as described in PURPOSE below. The following warnings may occur:

     65 = One or more singularities were successfully handled.

     66 = In some subinterval(s), the estimate of the integral was accepted
          merely because the estimated error was small, even though no regular
          behavior was recognized.

or

 [ERROR, errorcode] where error code is the IMSL-generated 
   error code. The following error codes may occur:

     131 = Failure due to insufficient internal working storage.

     132 = Failure. This may be due to too much noise in function 
           (relative to the given error requirements) or due to an
           ill-behaved integrand.

     133 = RERR is greater than 0.1 or less than 0.0 or is too small
           for the precision of the machine.
  
The following flags have an influence upon the operation of IMSL_ROMBERG --

ROMBERG_AERR [Default 1.0E-5] -- Desired absolute error in answer.

ROMBERG_RERR [Default 0.0] -- Desired relative error in the answer.

Note: If IMSL signals an error, a message will be printed on the user's
        console stating the nature of the error. (This error message 
        may be supressed by setting IMSLVERBOSE to FALSE.)

Note: Because this uses a translated Fortran routine, it may not be
        recursively invoked. It does not call itself, but the user should
        be aware that he may not type ^A in the middle of an IMSL_ROMBERG
        computation, begin another calculation using the same package,
        and expect to win -- IMSL_ROMBERG will complain if it was already
        doing one project when you invoke it. This should cause minimal
        problems.

Purpose (modified version of the IMSL documentation)
----------------------------------------------------

DCADRE attempts to solve the following problem: Given a real-valued 
function F of one argument, two real numbers A and B, find a number
DCADRE such that:

|   / B               |        [                              | / B      | ]
|   [                 |        [                              | [        | ]
|   I F(x)dx - DCADRE | <= max [ ROMBERG_AERR, ROMBERG_RERR * | I F(x)dx | ]
|   ]                 |        [                              | ]        | ]
|   / A               |        [                              | / A      | ]

Algorithm (modified version of the IMSL documentation)
------------------------------------------------------

This routine uses a scheme whereby DCADRE is computed as the sum of
estimates for the integral of F(x) over suitably chosen subintervals of
the given interval of integration. Starting with the interval of
integration itself as the first such subinterval, cautious Romberg
extrapolation is used to find an acceptable estimate on a given
subinterval. If this attempt fails, the subinterval is divided into two
subintervals of equal length, each of which is considered separately.

Programming Notes (modified version of the IMSL documentation)
--------------------------------------------------------------

1. DCADRE (the translated-Fortran base for IMSL_ROMBERG) can, in many cases,
   handle jump discontinuities and certain algebraic discontinuities. See 
   reference for full details.

2. The relative error parameter ROMBERG_RERR must be in the interval [0.0,0.1].
   For example, ROMBERG_RERR=0.1 indicates that the estimate of the intergral 
   is to be correct to one digit, where as ROMBERG_RERR=1.0E-4 calls for four
   digits of accuracy. If DCADRE determines that the relative accuracy
   requirement cannot be satisfied, IER is set to 133 (ROMBERG_RERR should be
   large enough that, when added to 100.0, the result is a number greater than
   100.0 (this will not be true of very tiny floating point numbers due to
   the nature of machine arithmetic)).

3. The absolute error parameter, ROMBERG_AERR, should be nonnegative. In
   order to give a reasonable value for ROMBERG_AERR, the user must know 
   the approximate magnitude of the integral being computed. In many cases,
   it is satisfactory to use AERR=0.0. In this case, only the relative error
   requirement is satisfied in the compuatation.

4. We quote from the reference, ``A very cautious man would accept DCADRE 
   only if IER [the warning or error code] is 0 or 65. The merely reasonable
   man would keep the faith even if IER is 66. The adventurous man is quite 
   often right in accepting DCADRE even if the IER is 131 or 132.'' Even when
   IER is not 0, DCADRE returns the best estimate that has been computed.

-----
For references on this technique, see

de Boor, Calr, ``CADRE: An Algorithm for Numerical Quadrature,''
  Mathematical Software (John R. Rice, Ed.), New York, Academic Press,
  1971, Chapter 7.

&DDT() - Exits from MACSYMA to the operating system level.  (The same
as control-Z on ITS, or control-C on Tops-20.)

&DEACTIVATE(cont1, cont2, ...) causes the specified contexts conti to
be deactivated.

&DEBUG() - LISPDEBUGMODE(); DEBUGPRINTMODE(); and DEBUG(); make
available to the user debugging features used by systems programmers.
These tools are powerful, and although some conventions are different
from the usual macsyma level it is felt their use is very intuitive.
[Some printout may be verbose for slow terminals, there are switches
for controlling this.]  These commands were designed for the user who
must debug translated macsyma code, as such they are a boon.  See
MACDOC;TRDEBG USAGE for more information.  For more help, consult GJC.

&DEBUGMODE default: [FALSE] - causes MACSYMA to enter a MACSYMA break
loop whenever a MACSYMA error occurs if it is TRUE and to terminate
that mode if it is FALSE.  If it is set to ALL then the user may
examine BACKTRACE for the list of functions currently entered.

&DEBUGPRINTMODE() - LISPDEBUGMODE(); DEBUGPRINTMODE(); and DEBUG();
make available to the user debugging features used by systems
programmers.  These tools are powerful, and although some conventions
are different from the usual macsyma level it is felt their use is
very intuitive.  [Some printout may be verbose for slow terminals,
there are switches for controlling this.]  These commands were
designed for the user who must debug translated macsyma code, as such
they are a boon.  See MACDOC;TRDEBG USAGE for more information.  For
more help, consult GJC.

&DECLARE(a1, f1, a2, f2, ...) gives the atom ai the flag fi.  The ai's
and fi's may also be lists of atoms and flags respectively in which
case each of the atoms gets all of the properties.  The possible flags
and their meanings are:

CONSTANT - makes ai a constant as is %PI.

MAINVAR - makes ai a MAINVAR.  The ordering scale for atoms: numbers <
constants (e.g. %E,%PI) < scalars < other variables < mainvars.

SCALAR - makes ai a scalar.

NONSCALAR - makes ai behave as does a list or matrix with respect to
the dot operator.

NOUN - makes the function ai a noun so that it won't be evaluated
automatically.

EVFUN - makes ai known to the EV function so that it will get applied
if its name is mentioned.  Initial evfuns are FACTOR, TRIGEXPAND,
TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, and RADCAN.

EVFLAG - makes ai known to the EV function so that it will be bound to
TRUE during the execution of EV if it is mentioned.  Initial evflags
are FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE, DEMOIVRE, KEEPFLOAT,
LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC, RATALGDENOM, FACTORFLAG,
%EMODE, LOGARC, LOGNUMER, RADEXPAND, RATSIMPEXPONS, RATMX, RATFAC,
INFEVAL, %ENUMER, PROGRAMMODE, LOGNEGINT, LOGABS, LETRAT, HALFANGLES,
EXPTISOLATE, ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM, NUMER_PBRANCH,
M1PBRANCH, DOTSCRULES, and LOGEXPAND.

BINDTEST - causes ai to signal an error if it ever is used in a
computation unbound.  DECLARE([var1, var2, ...], BINDTEST) causes
MACSYMA to give an error message whenever any of the vari occur
unbound in a computation.

MACSYMA currently recognizes and uses the following features of
objects: EVEN, ODD, INTEGER, RATIONAL, IRRATIONAL, REAL, IMAGINARY,
and COMPLEX.  The useful features of functions include: INCREASING,
DECREASING, ODDFUN (odd function), EVENFUN (even function),
COMMUTATIVE (or SYMMETRIC), ANTISYMMETRIC, LASSOCIATIVE and
RASSOCIATIVE.

DECLARE(F,INCREASING) is in all respects equivalent to
ASSUME(KIND(F,INCREASING)).  The ai and fi may also be lists of
objects or features.  The command FEATUREP(object,feature) may be used
to determine if an object has been DECLAREd to have "feature".  See
DESCRIBE(FEATURES); .

&DEFAULT_LET_RULE_PACKAGE - the name of the rule package used when one
is not explicitly set by the user with LET or by changing the value of
CURRENT_LET_RULE_PACKAGE.

&DEFCON(tensor1,<tensor2,tensor3>) gives tensor1 the property that the
contraction of a product of tensor1 and tensor2 results in tensor3
with the appropriate indices.  If only one argument, tensor1, is
given, then the contraction of the product of tensor1 with any indexed
object having the appropriate indices (say tensor) will yield an
indexed object with that name, i.e.tensor, and with a new set of
indices reflecting the contractions performed.

    For example, if METRIC: G, then DEFCON(G) will implement the
raising and lowering of indices through contraction with the metric
tensor.

    More than one DEFCON can be given for the same indexed object; the
latest one given which applies in a particular contraction will be
used.

CONTRACTIONS is a list of those indexed objects which have been given
contraction properties with DEFCON.

&DEFINE(f(x1, ...), body) is equivalent to f(x1,...):=''body but when
used inside functions it happens at execution time rather than at the
time of definition of the function which contains it.

&DEFINE_VARIABLE(name,default-binding,mode,optional-documentation) -
introduces a global variable into the MACSYMA environment.  This is
for user-written packages, which are often translated or compiled.
E.g.: DEFINE_VARIABLE(FOO,TRUE,BOOLEAN);  does the following:
(1) MODE_DECLARE(FOO,BOOLEAN); sets it up for the translator.
(2) If the variable is unbound, it sets it:  FOO:TRUE.
(3) DECLARE(FOO,SPECIAL); declares it special.
(4) Sets up an assign property for it to make sure that it never 
    gets set to a value of the wrong mode.
    E.g.  FOO:44 would be an error once FOO is defined BOOLEAN.

See DESCRIBE(MODE_DECLARE); for a list of the possible "modes".

The optional 4th argument is a documentation string.  When
TRANSLATE_FILE is used on a package which includes documentation
strings, a second file is output in addition to the LISP file which
will contain the documentation strings, formatted suitably for use in
manuals, usage files, or (for instance) DESCRIBE.

With any variable which has been DEFINE_VARIABLE'd with mode other
than ANY, you can give a VALUE_CHECK property, which is a function of
one argument called on the value the user is trying to set the
variable to.

PUT('G5,LAMBDA([U],IF U#'G5 THEN ERROR("Don't set G5")),'VALUE_CHECK);
Use DEFINE_VARIABLE(G5,'G5,ANY_CHECK, "this ain't supposed to be set
by anyone but me.")

ANY_CHECK is a mode which means the same as ANY, but which keeps
DEFINE_VARIABLE from optimizing away the assign property.

&DEFINT(exp, var, low, high) - DEFinite INTegration, the same as
INTEGRATE(exp,var,low,high).

&DEFMATCH(progname, pattern, parm1, ..., parmn) creates a function of
n+1 arguments with the name progname which tests an expression to see
if it can match a particular pattern.  The pattern is some expression
containing pattern variables and parameters.  The parms are given
explicitly as arguments to DEFMATCH while the pattern variables (if
supplied) were given implicitly in a previous MATCHDECLARE function.
The first argument to the created function progname, is an expression
to be matched against the "pattern" and the other n arguments are the
actual variables occurring in the expression which are to take the
place of dummy variables occurring in the "pattern".  Thus the parms
in the DEFMATCH are like the dummy arguments to the SUBROUTINE
statement in FORTRAN.  When the function is "called" the actual
arguments are substituted.  For example:

(C1)  NONZEROANDFREEOF(X,E):=  IF E#0 AND FREEOF(X,E)
            THEN TRUE ELSE FALSE$

(IS(E#0 AND FREEOF(X,E)) is an  equivalent function
definition)

(C2)  MATCHDECLARE(A,NONZEROANDFREEOF(X),B,FREEOF(X))$
(C3)  DEFMATCH(LINEAR,A*X+B,X)$

    This has caused the function LINEAR(exp,var1) to be defined.  It
tests exp to see if it is of the form A*var1+B where A and B do not
contain var1 and A is not zero.  DEFMATCHed functions return (if the
match is successful) a list of equations whose left sides are the
pattern variables and parms and whose right sides are the expressions
which the pattern variables and parameters matched.  The pattern
variables, but not the parameters, are set to the matched expressions.
If the match fails, the function returns FALSE.  Thus
LINEAR(3*Z+(Y+1)*Z+Y**2,Z) would return [B=Y**2, A=Y+4, X=Z].  Any
variables not declared as pattern variables in MATCHDECLARE or as
parameters in DEFMATCH which occur in pattern will match only
themselves so that if the third argument to the DEFMATCH in (C4) had
been omitted, then LINEAR would only match expressions linear in X,
not in any other variable.

    A pattern which contains no parameters or pattern variables
returns TRUE if the match succeeds.
Do EXAMPLE(DEFMATCH); for more examples.

&DEFRULE(rulename, pattern, replacement) defines and names a
replacement rule for the given pattern.  If the rule named rulename is
applied to an expression (by one of the APPLY functions below), every
subexpression matching the pattern will be replaced by the
replacement.  All variables in the replacement which have been
assigned values by the pattern match are assigned those values in the
replacement which is then simplified.  The rules themselves can be
treated as functions which will transform an expression by one
operation of the pattern match and replacement.  If the pattern fails,
the original expression is returned.

&DEFTAYLOR(function, exp) allows the user to define the Taylor series
(about 0) of an arbitrary function of one variable as exp which may be
a polynomial in that variable or which may be given implicitly as a
power series using the SUM function.

    In order to display the information given to DEFTAYLOR one can use
POWERSERIES(F(X),X,0). (see below).

(C1) DEFTAYLOR(F(X),X**2+SUM(X**I/(2**I*I!**2),
        I,4,INF));
(D1)                          [F]

(C2) TAYLOR(%E**SQRT(F(X)),X,0,4);

                     2         3          4
                    X    3073 X    12817 X
(D2)/R/     1 + X + -- + ------- + -------- +  . . .
                    2     18432     307200

&DELETE(exp1, exp2) removes all occurrences of exp1 from exp2.  Exp1
may be a term of exp2 (if it is a sum) or a factor of exp2 (if it is a
product).

(C1)  DELETE(SIN(X),X+SIN(X)+Y);

(D1)               Y + X

DELETE(exp1, exp2, integer) removes the first integer occurrences of
exp1 from exp2.  Of course, if there are fewer than integer
occurrences of exp1 in exp2 then all occurrences will be deleted.

&DELFILE(file-specification) will delete the file given by the
file-specification (i.e. firstname, secondname, device, user) from the
given device.

&DELTA - This is the Dirac Delta function.  Currently only LAPLACE
knows about the DELTA function:

(C1) LAPLACE(DELTA(T-A)*SIN(B*T),T,S);

Is A positive, negative or zero?

POS;
                                          - A S
(D1)                           SIN(A B) %E

&DEMO(file-specification) same as BATCH but pauses after each command
line and continues when the appropriate character is typed.  On MC and
TOPS-20 this is a space and anything else will terminate the demo.  On
Multics and UNIX systems where a carriage return is required after
each command, a carriage return is used to tell the demo to proceed,
and anything else followed by a carriage return terminates the demo.

&DEMOIVRE default: [FALSE] if TRUE will cause %E^(A+B*%I) to become
%E^A*(COS(B)+%I*SIN(B)) if B is free of %I.  A and B are not expanded.
(DEMOIVRE:TRUE; is the way to reverse the effect of
EXPONENTIALIZE:TRUE;)

DEMOIVRE(exp) will cause the conversion without setting the switch or
having to re-evaluate the expression with EV.

&DENOM(exp) returns the denominator of the rational expression exp.

&DEPENDENCIES default: [] - the list of atoms which have functional
dependencies (set up by the DEPENDS or GRADEF functions).  The command
DEPENDENCIES has been replaced by the DEPENDS command.  Do
DESCRIBE(DEPENDS);

&DEPENDS(funlist1,varlist1,funlist2,varlist2,...) declares functional
dependencies for variables to be used by DIFF.
DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T) informs DIFF that F and G
depend on X and Y, that R and S depend on U,V, and W, and that U
depends on T.  The arguments to DEPENDS are evaluated.  The variables
in each funlist are declared to depend on all the variables in the
next varlist.  A funlist can contain the name of an atomic variable or
array.  In the latter case, it is assumed that all the elements of the
array depend on all the variables in the succeeding varlist.
Initially, DIFF(F,X) is 0; executing DEPENDS(F,X) causes future
differentiations of F with respect to X to give dF/dX or Y (if
DERIVABBREV:TRUE).

(C1) DEPENDS([F,G],[X,Y],[R,S],[U,V,W],U,T);
(D1)           [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]

(C2) DEPENDENCIES;
(D2)           [F(X, Y), G(X, Y), R(U, V, W), S(U, V, W), U(T)]
(C3) DIFF(R.S,U);
                               dR           dS
(D3)                           -- . S + R . --
                               dU           dU

Since MACSYMA knows the chain rule for symbolic derivatives, it takes
advantage of the given dependencies as follows:

(C4) DIFF(R.S,T);
                           dR dU             dS dU
(D4)                      (-- --) . S + R . (-- --)
                           dU dT             dU dT
If we set

(C5) DERIVABBREV:TRUE;
(D5)                                 TRUE

then re-executing the command C4, we obtain

(C6) ''C4;
(D6)                      (R  U ) . S + R . (S  U )
                            U  T              U  T

To eliminate a previously declared dependency, the REMOVE command can
be used.  For example, to say that R no longer depends on U as
declared in C1, the user can type REMOVE(R,DEPENDENCY).  This will
eliminate all dependencies that may have been declared for R.

(C7) REMOVE(R,DEPENDENCY);
(D7)                                 DONE

(C8) ''C4;
(D8)                             R . (S  U )
                                  U    T

CAVEAT: DIFF is the only MACSYMA command which uses DEPENDENCIES
information.  The arguments to INTEGRATE, LAPLACE, etc. must be given
their dependencies explicitly in the command, e.g., INTEGRATE(F(X),X).

&DERIVABBREV default: [FALSE] if TRUE will cause derivatives to
display as subscripts.

&DERIVDEGREE(exp, dv, iv) finds the highest degree of the derivative
of the dependent variable dv with respect to the independent variable
iv occuring in exp.

(C1) 'DIFF(Y,X,2)+'DIFF(Y,Z,3)*2+'DIFF(Y,X)*X**2$
(C2) DERIVDEGREE(%,Y,X);
(D2)                           2

&DERIVLIST(var1,...,vark) causes only differentiations with respect to
the indicated variables, within the EV command.

&DERIVSUBST default: [FALSE] - controls non-syntactic substitutions
such as SUBST(X,'DIFF(Y,T),'DIFF(Y,T,2)); If DERIVSUBST is set to
true, this gives 'DIFF(X,T).

&DESCRIBE(cmd) prints out information about "cmd", which may be any
MACSYMA command, switch or variable.  Certain key words have also been
included, where they seem appropriate, thus DESCRIBE(TRIG); will print
out a list of the trig functions implemented in MACSYMA.  Some
function names or operators may require quotation marks around them,
e.g.  DESCRIBE("DO"); or DESCRIBE(".");.  See also APROPOS(string)
which allows you to locate command names even if you aren't sure of
the full name.  Do DESCRIBE(APROPOS); for details.

&DESOLVE([eq1,...,eqn],[var1,...,varn]) where the eq's are linear
differential equations in the dependent variables var1,...,varn.  The
functional relationships must be explicitly indicated in both the
equations and the variables. For example

(C1) 'DIFF(F,X,2)=SIN(X)+'DIFF(G,X);
(C2) 'DIFF(F,X)+X^2-F=2*'DIFF(G,X,2);

is NOT the proper format.  The correct way is:

(C3) 'DIFF(F(X),X,2)=SIN(X)+'DIFF(G(X),X);
(C4) 'DIFF(F(X),X)+X^2-F(X)=2*'DIFF(G(X),X,2);

The call is then DESOLVE([D3,D4],[F(X),G(X)]);

If initial conditions at 0 are known, they should be supplied before
calling DESOLVE by using ATVALUE.


(C11) 'DIFF(F(X),X)='DIFF(G(X),X)+SIN(X);
                        d         d
(D11)                   -- F(X) = -- G(X) + SIN(X)
                        dX        dX
(C12) 'DIFF(G(X),X,2)='DIFF(F(X),X)-COS(X);
                         2
                        d          d
(D12)                   --- G(X) = -- F(X) - COS(X)
                          2        dX
                        dX
(C13) ATVALUE('DIFF(G(X),X),X=0,A);
(D13)                                A

(C14) ATVALUE(F(X),X=0,1);
(D14)                                1

(C15) DESOLVE([D11,D12],[F(X),G(X)]);

                X                            X
(D16) [F(X)=A %E  - A+1, G(X) = COS(X) + A %E  - A + G(0) - 1]

/* VERIFICATION */
(C17) [D11,D12],D16,DIFF;
                  X       X      X                X
(D17)        [A %E  = A %E , A %E  - COS(X) = A %E  - COS(X)]

If DESOLVE cannot obtain a solution, it returns "FALSE".

&DETERMINANT(M) computes the determinant of M by a method similar to
Gaussian elimination.  The form of the result depends upon the setting
of the switch RATMX.  There is a special routine for dealing with
sparse determininants which can be used by setting the switches
RATMX:TRUE and SPARSE:TRUE.

&DETOUT default: [FALSE] if TRUE will cause the determinant of a
matrix whose inverse is computed to be kept outside of the inverse.
For this switch to have an effect DOALLMXOPS and DOSCMXOPS should be
FALSE (see their descriptions).  Alternatively this switch can be
given to EV which causes the other two to be set correctly.

&DEVICE default: [DSK] The value of this variable is the default
device for file loading or saving.  It is initialized to DSK, meaning
the disk of the MIT-MC machine.

&DIAGMATRIX(n, x) returns a diagonal matrix of size n by n with the
diagonal elements all x.  An identity matrix is created by
DIAGMATRIX(n,1), or one may use IDENT(n).

&DIAGMETRIC default:[] - An option in the CTENSR (Component Tensor
Manipulation) package.  If DIAGMETRIC is TRUE special routines compute
all geometrical objects (which contain the metric tensor explicitly)
by taking into consideration the diagonality of the metric. Reduced
run times will, of course, result. Note: this option is set
automatically by TSETUP if a diagonal metric is specified.

&DIFF - [flag] causes all differentiations indicated in exp to be
performed.

DIFF(exp, v1, n1, v2, n2, ...)  differentiates exp with respect to
each vi, ni times.  If just the first derivative with respect to one
variable is desired then the form DIFF(exp,v) may be used.  If the
noun form of the function is required (as, for example, when writing a
differential equation), 'DIFF should be used and this will display in
a two dimensional format.

DERIVABBREV[FALSE] if TRUE will cause derivatives to display as
subscripts.

DIFF(exp) gives the "total differential", that is, the sum of the
derivatives of exp with respect to each of its variables times the
function DEL of the variable.  No further simplification of DEL is
offered.

(C1) DIFF(EXP(F(X)),X,2);
                             2
                      F(X)  d             F(X)  d         2
(D1)                %E     (--- F(X)) + %E     (-- (F(X)))
                              2                 dX
                            dX

(C2) DERIVABBREV:TRUE$

(C3) 'INTEGRATE(F(X,Y),Y,G(X),H(X));

                                H(X)
                               /
                               [
(D3)                           I     F(X, Y) dY
                               ]
                               /
                                G(X)
(C4) DIFF(%,X);

            H(X)
           /
           [
(D4)       I     F(X, Y)  dY + F(X, H(X)) H(X)  - F(X, G(X)) G(X)
           ]            X                     X                  X
           /
            G(X)

For the tensor package, the following modifications have been
incorporated:

1) the derivatives of any indexed objects in exp will have the
variables vi appended as additional arguments.  Then all the
derivative indices will be sorted.

2) the vi may be integers from 1 up to the value of the variable
DIMENSION[default value: 4].  This will cause the differentiation to
be carried out wrt the vith member of the list COORDINATES which
should be set to a list of the names of the coordinates, e.g.,
[x,y,z,t]. If COORDINATES is bound to an atomic variable, then that
variable subscripted by vi will be used for the variable of
differentiation.  This permits an array of coordinate names or
subscripted names like X[1], X[2],... to be used.  If COORDINATES has
not been assigned a value, then the variables will be treated as in 1)
above.

&DILOGARITHM - See POLYLOGARITHMS.
&DILOGARITHMS - See POLYLOGARITHMS.
&DILOGS - See POLYLOGARITHMS.

&DIM default:[4] - An option in the CTENSR (Component Tensor
Manipulation) package.  DIM is the dimension of the manifold with the
default 4. The command DIM:N; will reset the dimension to any other
integral value.

&DIMENSION(equation or list of equations) - The file SHARE1;DIMEN >
contains functions for automatic dimensional analysis.  LOAD(DIMEN);
will load it up for you.  There is a demonstration available in
SHARE1;DIMEN DEMO.   Do DEMO(DIMEN,DEMO,SHARE1); to run it.

&DIREC - The value of this variable is the default file directory for
SAVE, STORE, FASSAVE, and STRINGOUT.  It is initialized to the user's
login name, if he has a disk directory, and to one of the USERSi
directories otherwise.  DIREC determines to what directory disk files
will be written.

&DISKFREE() With no args or an arg of TRUE, will return the total
number of free blocks of disk space in the system.  With an arg of 0,
1, or 13, it will return the number of free blocks of diskspace on the
respective disk pack.  With an arg of SECONDARY or PRIMARY, it will
return the total number of free blocks of disk space on the secondary
or primary disk pack respectively.

&DISKUSE(username) returns the total number of disk blocks in use by a
user.  The result is of the form <n>*BLOCKS

&DISOLATE(exp, var1, var2, ..., varN) is similar to ISOLATE(exp, var)
(Do DESCRIBE(ISOLATE);) except that it enables the user to isolate
more than one variable simultaneously.  This might be useful, for
example, if one were attempting to change variables in a multiple
integration, and that variable change involved two or more of the
integration variables.  To access this function, do
LOAD(DISOL)$ .  A demo is available by DEMO(DISOL,DEMO,SHARE2); .

&DISP(expr1,expr2, ...) is like DISPLAY but only the value of the
arguments are displayed rather than equations.  This is useful for
complicated arguments which don't have names or where only the value
of the argument is of interest and not the name.

&DISPCON(tensor1,tensor2,...) displays the contraction properties of
the tensori as were given to DEFCON.  DISPCON(ALL) displays all the
contraction properties which were defined.

&DISPFLAG default: [TRUE] if set to FALSE within a BLOCK will inhibit
the display of output generated by the SOLVE functions when using
PROGRAMMODE:FALSE called from within the BLOCK.  Termination of the
command line with a dollar sign, $, sets DISPFLAG to FALSE.

&DISPFORM(exp) returns the external representation of exp (wrt its
main operator).  This should be useful in conjunction with PART which
also deals with the external representation.  Suppose EXP is -A .
Then the internal representation of EXP is "*"(-1,A), while the
external representation is "-"(A). DISPFORM(exp,ALL) converts the
entire expression (not just the top-level) to external format.  For
example, if EXP:SIN(SQRT(X)), then FREEOF(SQRT,EXP) and
FREEOF(SQRT,DISPFORM(EXP)) give TRUE, while
FREEOF(SQRT,DISPFORM(EXP,ALL)) gives FALSE.

&DISPFUN(f1, f2, ...) displays the definition of the user defined
functions f1, f2, ... which may also be the names of array associated
functions, subscripted functions, or functions with constant
subscripts which are the same as those used when the functions were
defined.  DISPFUN(ALL) will display all user defined functions as
given on the FUNCTIONS and ARRAYS lists except subscripted functions
with constant subscripts.  E.g. if the user has defined a function
F(x), DISPFUN(F); will display the definition.

&DISPLAY(expr1, expr2, ...)  displays equations whose left side is
expri unevaluated, and whose right side is the value of the expression
centered on the line.  This function is useful in blocks and FOR
statements in order to have intermediate results displayed.  The
arguments to DISPLAY are usually atoms, subscripted variables, or
function calls.  (see the DISP function.)

(C1) DISPLAY(B[1,2]);

                                      2
                         B     = X - X
                          1, 2

(D1)                            DONE

&DISPLAY_FORMAT_INTERNAL default: [FALSE] - if set to TRUE will cause
expressions to be displayed without being transformed in ways that
hide the internal mathematical representation.  The display then
corresponds to what the INPART command returns rather than the PART
command.  Examples:

User     PART       INPART

a-b;      A - B     A + (- 1) B

           A            - 1
a/b;       -         A B
           B
                       1/2
sqrt(x);   SQRT(X)    X

          4 X        4
X*4/3;    ---        - X
           3         3

&DISPLAY2D default: [TRUE] - if set to FALSE will cause the standard
display to be a string (1-dimensional) form rather than a display
(2-dimensional) form.  This may be of benefit for users on printing
consoles who would like to conserve paper.

&DISPRULE(rulename1, rulename2, ...) will display rules with the names
rulename1, rulename2, as were given by DEFRULE, TELLSIMP, or
TELLSIMPAFTER or a pattern defined by DEFMATCH.  For example, the
first rule modifying SIN will be called SINRULE1.  DISPRULE(ALL);
will display all rules.

&DISPTERMS(expr) displays its argument in parts one below the other.
That is, first the operator of 'expr' is displayed, then each term in
a sum, or factor in a product, or part of a more general expression is
displayed separately.  This is useful if expr is too large to be
otherwise displayed.  For example if P1, P2, ...  are very large
expressions then the display program may run out of storage space in
trying to display P1+P2+...  all at once.  However,
DISPTERMS(P1+P2+...) will display P1, then below it P2, etc.  When not
using DISPTERMS, if an exponential expression is too wide to be
displayed as A**B it will appear as EXPT(A,B) (or as NCEXPT(A,B) in
the case of A^^B).

&DISTRIB(exp) distributes sums over products.  It differs from EXPAND
in that it works at only the top level of an expression, i.e. it doesn't
recurse and it is faster than EXPAND.  It differs from MULTTHRU in
that it expands all sums at that level. For example, 
DISTRIB((A+B)*(C+D)) -> A C + A D + B C + B D 
MULTTHRU ((A+B)*(C+D)) -> (A + B) C + (A + B) D

DISTRIB (1/((A+B)*(C+D))) ->  1/ ((A+B) *(C+D))
EXPAND(1/((A+B)*(C+D)),1,0) -> 1/(A C + A D + B C + B D)

&DIVIDE(p1, p2, var1, ..., varn) computes the quotient and remainder
of the polynomial p1 divided by the polynomial p2, in a main
polynomial variable, varn.  The other variables are as in the RATVARS
function.  The result is a list whose first element is the quotient
and whose second element is the remainder.

(C1) DIVIDE(X+Y,X-Y,X);
(D1)                        [1, 2 Y]

(C2) DIVIDE(X+Y,X-Y);
(D2)                      [ - 1, 2 X]

(Note that Y is the main variable in C2)

&DIVSUM(n,k) adds up all the factors of n raised to the kth power
where k is a non-negative integer.  If only one argument is given
then k is assumed to be 1.

&DO - The DO statement is used for performing iteration.  Due to its
great generality the DO statement will be described in two parts.
First the usual form will be given which is analogous to that used in
several other programming languages (FORTRAN, ALGOL, PL/I, etc.); then
the other features will be mentioned.

1.  There are three variants of this form that differ only in their
terminating conditions.  They are:

(a)  FOR variable : initial-value STEP increment
      THRU limit DO body

(b)  FOR variable : initial-value STEP increment
      WHILE condition DO body

(c)  FOR variable : initial-value STEP increment
      UNLESS condition DO body

(Alternatively, the STEP may be given after the termination condition
or limit.)

    The initial-value, increment, limit, and body can be any
expressions.  If the increment is 1 then "STEP 1" may be omitted.

    The execution of the DO statement proceeds by first assigning the
initial-value to the variable (henceforth called the
control-variable). Then: (1) If the control-variable has exceeded the
limit of a THRU specification, or if the condition of the UNLESS is
TRUE, or if the condition of the WHILE is FALSE then the DO
terminates. (2) The body is evaluated.  (3) The increment is added to
the control-variable.  The process from (1) to (3) is performed
repeatedly until the termination condition is satisfied.  One may also
give several termination conditions in which case the DO terminates
when any of them is satisfied.

    In general the THRU test is satisfied when the control-variable is
greater than the limit if the increment was non-negative, or when the
control-variable is less than the limit if the increment was negative.
The increment and limit may be non-numeric expressions as long as this
inequality can be determined.  However, unless the increment is
syntactically negative (e.g. is a negative number) at the time the DO
statement is input, MACSYMA assumes it will be positive when the DO is
executed.  If it is not positive, then the DO may not terminate
properly.

    Note that the limit, increment, and termination condition are
evaluated each time through the loop.  Thus if any of these involve
much computation, and yield a result that does not change during all
the executions of the body, then it is more efficient to set a
variable to their value prior to the DO and use this variable in the
DO form.

    The value normally returned by a DO statement is the atom DONE, as
every statement in MACSYMA returns a value.  However, the function
RETURN may be used inside the body to exit the DO prematurely and give
it any desired value.  Note however that a RETURN within a DO that
occurs in a BLOCK will exit only the DO and not the BLOCK.  Note also
that the GO function may not be used to exit from a DO into a
surrounding BLOCK.

    The control-variable is always local to the DO and thus any
variable may be used without affecting the value of a variable with
the same name outside of the DO.  The control-variable is unbound
after the DO terminates.

(C1)   FOR A:-3 THRU 26 STEP 7 DO LDISPLAY(A)$
(E1)          A = -3
(E2)          A =  4
(E3)          A = 11
(E4)          A = 18
(E5)          A = 25

The function LDISPLAY generates intermediate labels; DISPLAY does not.

(C6)   S:0$
(C7)   FOR I:1 WHILE I<=10 DO S:S+I;
(D7)          DONE
(C8)   S;
(D8)          55

Note that the condition in C7 is equivalent to UNLESS I > 10 and also
THRU 10

(C9)   SERIES:1$
(C10)  TERM:EXP(SIN(X))$
(C11)  FOR P:1 UNLESS P>7 DO
          (TERM:DIFF(TERM,X)/P,
          SERIES:SERIES+SUBST(X=0,TERM)*X^P)$
(C12)   SERIES;
                7    6     5    4    2
(D12)          X    X     X    X    X
               -- - --- - -- - -- + -- + X + 1
               96   240   15   8    2

which gives 8 terms of the Taylor series for e^sin(x).

(C13) POLY:0$
(C14) FOR I:1 THRU 5 DO
        FOR J:I STEP -1 THRU 1 DO
           POLY:POLY+I*X^J$

(C15) POLY;
              5      4       3       2
(D15)      5 X  + 9 X  + 12 X  + 14 X  + 15 X

(C16) GUESS:-3.0$

(C17) FOR I:1 THRU 10 DO (GUESS:SUBST(GUESS,X,.5*(X+10/X)),
         IF ABS(GUESS^2-10)<.00005 THEN RETURN(GUESS));

(D17)                  - 3.1622807

    This example computes the negative square root of 10 using the
Newton- Raphson iteration a maximum of 10 times.  Had the convergence
criterion not been met the value returned would have been "DONE".

Additional Forms of the DO Statement

    Instead of always adding a quantity to the control-variable one
may sometimes wish to change it in some other way for each iteration.
In this case one may use "NEXT expression" instead of "STEP
increment".  This will cause the control-variable to be set to the
result of evaluating expression each time through the loop.

(C1)  FOR COUNT:2 NEXT 3*COUNT THRU 20
         DO DISPLAY(COUNT)$

                    COUNT = 2
                    COUNT = 6
                    COUNT = 18

    As an alternative to FOR variable:value ...DO... the syntax FOR
variable FROM value ...DO...  may be used.  This permits the "FROM
value" to be placed after the step or next value or after the
termination condition.  If "FROM value" is omitted then 1 is used as
the initial value.

    Sometimes one may be interested in performing an iteration where
the control-variable is never actually used.  It is thus permissible
to give only the termination conditions omitting the initialization
and updating information as in the following example to compute the
square-root of 5 using a poor initial guess.

(C1) X:1000
(C2)  THRU 10 WHILE X#0.0 DO X:.5*(X+5.0/X)$
(C3) X;
(D3)               2.236068

    If it is desired one may even omit the termination conditions
entirely and just give "DO body" which will continue to evaluate the
body indefinitely.  In this case the function RETURN should be used to
terminate execution of the DO.

(C1) NEWTON(F,GUESS):=
  BLOCK([NUMER,Y],
        LOCAL(DF),
        NUMER:TRUE,
        DEFINE(DF(X),DIFF(F(X),X)),
        DO (Y:DF(GUESS),
            IF Y=0.0 THEN ERROR("Derivative at:",GUESS," is zero."),
            GUESS:GUESS-F(GUESS)/Y,
            IF ABS(F(GUESS))<5.0E-6 THEN RETURN(GUESS)))$

(C2) SQR(X):=X^2-5.0$

(C3) NEWTON(SQR,1000);
(D3)                    2.236068

    (Note that RETURN, when executed, causes the current value of
GUESS to be returned as the value of the DO.  The BLOCK is exited and
this value of the DO is returned as the value of the BLOCK because the
DO is the last statement in the block.)

    One other form of the DO is available in MACSYMA.  The syntax is:

                   FOR variable IN list [end-tests] DO body

    The members of the list are any expressions which will
successively be assigned to the variable on each iteration of the
body.  The optional end-tests can be used to terminate execution of
the DO; otherwise it will terminate when the list is exhausted or when
a RETURN is executed in the body.  (In fact, list may be any
non-atomic expression, and successive parts are taken.)

(C1)  FOR F IN [LOG, RHO, ATAN] DO LDISP(F(1))$

(E1)                                  0

(E2)                                RHO(1)

                                     %PI
(E3)                                 ---
                                      4

(C4) EV(E3,NUMER);

(D4)                             0.78539816

&DOALLMXOPS default: [TRUE] if TRUE all operations relating to
matrices are carried out.  If it is FALSE then the setting of the
individual DOT switches govern which operations are performed.

&DOMAIN default: [REAL] - if set to COMPLEX, SQRT(X^2) will remain
SQRT(X^2) instead of returning ABS(X).  The notion of a "domain" of
simplification is still in its infancy, and controls little more than
this at the moment.

&DOMXEXPT default: [TRUE] if TRUE, %E^MATRIX([1,2],[3,4]); gives
MATRIX([%E,%E^2],[%E^3,%E^4]).  In general, this transformation
affects expressions of the form <base>^<power> where <base> is an
expression assumed scalar or constant, and <power> is a list or
matrix.  This transformation is turned off if this switch is set to
FALSE.

&DOMXMXOPS default: [TRUE] if TRUE then all matrix-matrix or
matrix-list operations are carried out (but not scalar-matrix
operations); if this switch is FALSE they are not.

&DOMXNCTIMES default: [FALSE] Causes non-commutative products of
matrices to be carried out.

&DONTFACTOR default: [] may be set to a list of variables with respect
to which factoring is not to occur.  (It is initially empty).
Factoring also will not take place with respect to any variables which
are less important (using the variable ordering assumed for CRE form)
than those on the DONTFACTOR list.

&DOSCMXOPS default: [FALSE] if TRUE then scalar-matrix operations are
performed.

&DOSCMXPLUS default: [FALSE] if TRUE will cause SCALAR + MATRIX to
give a matrix answer.  This switch is not subsumed under DOALLMXOPS.

&DOT - . The dot operator, for matrix (non-commutative)
multiplication.  When "." is used in this way, spaces should be left
on both sides of it, e.g. A . B.  This distinguishes it plainly from a
decimal point in a floating point number.  Do APROPOS(DOT); for a list
of the switches which affect the dot operator.

&DOT0NSCSIMP default: [TRUE] Causes a non-commutative product of zero
and a nonscalar term to be simplified to a commutative product.

&DOT0SIMP default: [TRUE] Causes a non-commutative product of zero and
a scalar term to be simplified to a commutative product.

&DOT1SIMP default: [TRUE] Causes a non-commutative product of one and
another term to be simplified to a commutative product.

&DOTASSOC default: [TRUE] when TRUE causes (A.B).C to simplify to
A.(B.C)

&DOTCONSTRULES default: [TRUE] Causes a non-commutative product of a
constant and another term to be simplified to a commutative product.
Turning on this flag effectively turns on DOT0SIMP, DOT0NSCSIMP, and
DOT1SIMP as well.

&DOTDISTRIB default: [FALSE] if TRUE will cause A.(B+C) to simplify to
A.B+A.C

&DOTEXPTSIMP default: [TRUE] when TRUE causes A.A to simplify to A^^2

&DOTIDENT default: [1]  The value to be returned by X^^0.

&DOTSCRULES default: [FALSE] when TRUE will cause A.SC or SC.A to
simplify to SC*A and A.(SC*B) to simplify to SC*(A.B)

&DOVARD_FILE(filespecification) - takes an ARDS file produced by PLOT2
(when in the PLOTMODE(G) mode), and creates a PRESS file suitable for
output to the DOVER.  The command DOVER_FILE will queue the file.  For
example, after you have done PLOTMODE(G,GR), and PLOT2(X,X,0,1); you
can then do (DOVARD_FILE(),DOVER_FILE()); to queue the plot.

In the near future the HARDCOPY and PLOTMODE commands may be extended 
to include this option, calling the functions in question for you.

Advantage: The DOVER output device is *many* times faster than the XGP
           and its use is *much* less a drain on the system than then
           the GLP/XGP combination. Output is also of higher quality.
Disadvantage: DOVER has a higher chance of jamming, and complicated
              3d-plots may bomb out.

&DOVARD_VIEWPORT default: [1,7,1,7] determines the perspective for
Dover output plots, similar to VIEWPT.  It accepts 4 arguments,
[XMIN,XMAX,YMIN,YMAX] in inches on the page.

&DOVER - A high speed, high resolution Xerox output device connected
to MC.  It should only be used from local terminals, or by agreement
with people at local terminals, since it is prone to jamming and needs
"tending" while files are being printed.  It works with the PLOT
commands (see DOVARD_FILE).

&DOVER_FILE(filespecification) - will queues a PLOT file to the DOVER.

&DPART(exp, n1, ..., nk) selects the same subexpression as PART, but
instead of just returning that subexpression as its value, it returns
the whole expression with the selected subexpression displayed inside
a box.  The box is actually part of the expression.

(C1) DPART(X+Y/Z**2,1,2,1);

                       Y
(D1)                  ---- + X
                         2
                     *****
                     * Z *
                     *****

&DSCALAR(function) applies the scalar d'Alembertian to the scalar
function.

(C41) DEPENDENCIES(FIELD(R));
(D41)                           [FIELD(R)]

(C42) DSCALAR(FIELD);

(D43)
    -M
  %E  ((FIELD  N - FIELD  M + 2 FIELD   ) R + 4 FIELD )
             R  R       R  R         R R             R
- -----------------------------------------------------
                             2 R

&DSKALL default: [] If TRUE will cause values, functions, arrays, and
rules to be written periodically onto the disk in addition to labelled
expressions.  TRUE is the default value whereas if DSKALL is FALSE
then only labelled expresions will be written.

&DSKGC default: [FALSE] if TRUE will cause user defined values,
functions, arrays, and line labelled expressions to be automatically
stored on disk whenever the system determines that the available
in-core space is getting low.  (For historical reasons this is also
a function, but it should be used as a switch.  Please use it as
described here, not as a function.)

&DSKUSE default: [FALSE] if TRUE, from this point in the computation
on labelled expressions will be written out periodically onto the
disk.  (A labelled expression is one which is referred to by a line
label, e.g. D4, C7, E12.)  Once an expression is written onto the disk
it will no longer reside in main memory and most of the main memory
storage taken up by it will be released. When the user attempts to
reference an expression which has been stored onto the disk, MACSYMA
will retrieve the correct value from the disk file.

&DUMMY(i1,i2,...) will set each index i1,i2,... to name of the form !n
where n is a positive integer.  This guarantees that dummy indices
which are needed in forming expressions will not conflict with indices
already in use.  COUNTER[default 1] determines the numerical suffix to
be used in generating the next dummy index.  The prefix is determined
by the option DUMMYX[!].

&DUMMYX default: [#] The prefix which will be used by the DUMMY
function in generating dummy indices in the Tensor package.

&DYNAMALLOC default: [FALSE] if TRUE will allocate additional space
whenever necessary.

&E - The base of natural logarithms, e, is represented in MACSYMA
as %E.

&ECHELON(M) produces the echelon form of the matrix M.  That is, M
with elementary row operations performed on it such that the first
non-zero element in each row in the resulting matrix is a one and the
column elements under the first one in each row are all zero.

                        [2  1 - A  -5 B ]
(D2)                    [               ]
                        [A    B      C  ]

(C3) ECHELON(D2);

                 [      A - 1        5 B      ]
                 [1   - -----      - ---      ]
                 [        2           2       ]
(D3)             [                            ]
                 [                2 C + 5 A B ]
                 [0     1         ------------]
                 [                       2    ]
                 [                2 B + A  - A]

&EDITOR - There is a line editor in MACSYMA, which you may enter by
typing an altmode (the "esc" key on most consoles) for PDP-10 versions
of MACSYMA, and & (ampersand) for Multics.  Your current command line
will be automatically brought into the editor for you to edit.  Commands
are terminated by two altmodes (two &'s on Multics).  An additional
two altmodes will return you to MACSYMA with the edited string on your
command line.

Some useful commands:

Command         Action
-------         ______
nC              moves the cursor past n characters.
nR              moves the cursor past n characters in the
                 reverse direction (nR = -nC).

nSstring<$>     moves the cursor to the right (left if n is
                 negative) of the nth occurrence of "string" in
                 the input string.

) or ]          moves the cursor right from the current position
                 over the next balanced pair of parentheses (or
                 brackets).

( or [          similar to ) or ] but moves left.

nD              deletes n characters, and saves them in the
                 "save-register" (see the GR command below).

nK              deletes all the characters through the nth carriage return
                 (0K kills left), and saves them in the "save-register";
                 e.g., K deletes the remainder of this line.

Istring<$>      inserts the characters "string" at the current cursor
                 position.  The cursor is positioned at the right of
                 the inserted text.  If no argument is given then the
                 string of the last I command which had one is used.

GR              inserts at the current cursor position the characters
                 deleted by the last use of D or K.  Thus GR may be used
                 in combination with D or K to move characters from one
                 place to another in the input string; or to recover
                 from an accidental use of D or K.  There is only one
                 "save-register".

&EIGEN - See EIGENVALUES.
&EIGENVALUES - There is a package on the SHARE; directory which
contains functions for computing EIGENVALUES and EIGENVECTORS and
related matrix computations.  For information on it do
PRINTFILE(EIGEN,USAGE,SHARE); . 

EIGENVALUES(mat) takes a MATRIX as its argument and returns a list of
lists the first sublist of which is the list of eigenvalues of the
matrix and the other sublist of which is the list of the
multiplicities of the eigenvalues in the corresponding order.  [ The
MACSYMA function SOLVE is used here to find the roots of the
characteristic polynomial of the matrix.  Sometimes SOLVE may not be
able to find the roots of the polynomial;in that case nothing in this
package except CONJUGATE, INNERPRODUCT, UNITVECTOR, COLUMNVECTOR and
GRAMSCHMIDT will work unless you know the eigenvalues.  In some cases
SOLVE may generate very messy eigenvalues.  You may want to simplify
the answers yourself before you go on.  There are provisions for this
and they will be explained below.  ( This usually happens when SOLVE
returns a not-so-obviously real expression for an eigenvalue which is
supposed to be real...)]  The EIGENVALUES command is available
directly from MACSYMA.  To use the other functions you must have
loaded in the EIGEN package, either by a previous call to EIGENVALUES,
or by doing LOADFILE(EIGEN,FASL,SHARE); .

&EIGENVECTORS(MAT) takes a MATRIX as its argument and returns a list
of lists the first sublist of which is the output of the EIGENVALUES
command and the other sublists of which are the eigenvectors of the
matrix corresponding to those eigenvalues respectively.  This function
will work directly from MACSYMA, but if you wish to take advantage of
the flags for controlling it (see below), you must first load in the
EIGEN package from the SHARE; directory.  You may do that by
LOADFILE(EIGEN,FASL,SHARE);.  The flags that affect this function are:

NONDIAGONALIZABLE[FALSE] will be set to TRUE or FALSE depending on
whether the matrix is nondiagonalizable or diagonalizable after an
EIGENVECTORS command is executed.

HERMITIANMATRIX[FALSE] If set to TRUE will cause the degenerate
eigenvectors of the hermitian matrix to be orthogonalized using the
Gram-Schmidt algorithm.

KNOWNEIGVALS[FALSE] If set to TRUE the EIGEN package will assume the
eigenvalues of the matrix are known to the user and stored under the
global name LISTEIGVALS.  LISTEIGVALS should be set to a list similar
to the output of the EIGENVALUES command.  ( The MACSYMA function
ALGSYS is used here to solve for the eigenvectors. Sometimes if the
eigenvalues are messy, ALGSYS may not be able to produce a solution.
In that case you are advised to try to simplify the eigenvalues by
first finding them using EIGENVALUES command and then using whatever
marvelous tricks you might have to reduce them to something simpler.
You can then use the KNOWNEIGVALS flag to proceed further. )

&EINSTEIN(dis) A function in the CTENSR (Component Tensor
Manipulation) package.  EINSTEIN computes the mixed Einstein tensor
after the Christoffel symbols and Ricci tensor have been obtained
(with the functions CHRISTOF and RICCICOM).  If the argument dis is
TRUE, then the non-zero values of the mixed Einstein tensor G[i,j]
will be displayed where j is the contravariant index.
RATEINSTEIN[TRUE] if TRUE will cause the rational simplification on
these components. If RATFAC[FALSE] is TRUE then the components will
also be factored.

&ELIMINATE([eq1,eq2,...,eqn],[v1,v2,...,vk]) eliminates variables from
equations (or expressions assumed equal to zero) by taking successive
resultants. This returns a list of n-k expressions with the k
variables v1,...,vk eliminated.  First v1 is eliminated yielding n-1
expressions, then v2 is, etc.  If k=n then a single expression in a
list is returned free of the variables v1,...,vk.  In this case SOLVE
is called to solve the last resultant for the last variable.

Example:

(C1) EXP1:2*X^2+Y*X+Z;
                                    2
(D1)                   Z + X Y + 2 X

(C2) EXP2:3*X+5*Y-Z-1;
(D2)                - Z + 5 Y + 3 X - 1

(C3) EXP3:Z^2+X-Y^2+5;
                       2    2
(D3)                  Z  - Y  + X + 5

(C4) ELIMINATE([EXP3,EXP2,EXP1],[Y,Z]);

            8         7         6          5          4
(D3) [7425 X  - 1170 X  + 1299 X  + 12076 X  + 22887 X

                               3         2
                       - 5154 X  - 1291 X  + 7688 X + 15376]

&ELLIPT - A package on the SHARE directory for Numerical routines for
Elliptic Functions and Complete Elliptic Integrals.  (Notation of
Abramowitz and Stegun, Chs 16 and 17) Do LOAD(ELLIPT); to use this
package.  At present all arguments MUST be floating point.  You'll get
nonsense otherwise.  Be warned.  The functions available are:

Jacobian elliptic functions
AM(U,M) - amplitude with modulus M
AM1(U,M1) - ampiltude with complementary modulus M1
AM(U,M):=AM1(U,1-M); so use AM1 if M ~ 1
SN(U,M):=SIN(AM(U,M));
CN(U,M):=COS(AM(U,M));
DN(U,M):=SQRT(1-M*SN(U,M)^2);
(These functions come defined like this.  Others CD, NS etc.  may be
similarly defined.)

Complete Elliptic Integrals
ELLIPTK(M) - Complete elliptic integral of first kind
ELLIPTK1(M1) - Same but with complementary modulus. 
ELLIPTK(M):=ELLIPTK1(1-M); so use if M ~ 1
ELLIPTE(M) - Complete elliptic integral of second kind
ELLIPTE1(M1) - Same but with complementary modulus. 
ELLIPTE(M):=ELLIPTE1(1-M); so use if M ~ 1

&EMACS() - loads up an EMACS editor as a sub-job under your MACSYMA,
so that you can edit batch files, or expressions.  EMACS is an editor
for CRT consoles, which is best at speeds of 1200 or greater.  Try
:TEACHE for a tutorial in how to use EMACS.  At this time it is
unfortunately not possible to "zap" an expression from a command line
down into an editor under your MACSYMA, but it is possible to "zap" an
edited expression back up to your MACSYMA for evaluation.

&EMATRIX(m, n, x, i, j) will create an m by n matrix all of whose
elements are zero except for the i,j element which is x.

&ENDCONS(exp, list) returns a new list consisting of the elements of
list followed by exp.  ENDCONS also works on general expressions, e.g.
ENDCONS(X, F(A,B,C));  ->  F(A,B,C,X).

&ENTERMATRIX(m, n) allows one to enter a matrix element by element
with MACSYMA requesting values for each of the m*n entries.

(C1) ENTERMATRIX(3,3);

Is the matrix  1. Diagonal  2. Symmetric  3. Antisymmetric  4. General
Answer 1, 2, 3 or 4
1;

Row 1 Column 1:  A;

Row 2 Column 2:  B;

Row 3 Column 3:  C;

Matrix entered.
                                 [ A  0  0 ]
                                 [         ]
(D1)                             [ 0  B  0 ]
                                 [         ]
                                 [ 0  0  C ]

&ENTIER(X) - largest integer <= X where X is numeric.  FIX (as in
FIXnum) is a synonym for this, so FIX(X); is precisely the same.

&EQUAL(expr1,expr2) - used with an "IS", returns TRUE (or FALSE) if
and only if expr1 and expr2 are equal (or not equal) for all possible
values of their variables (as determined by RATSIMP).  Thus
IS(EQUAL((X+1)**2,X**2+2*X+1)) returns TRUE whereas if X is unbound
IS((X+1)**2=X**2+2*X+1) returns FALSE.  Note also that IS(RAT(0)=0)
gives FALSE but IS(EQUAL(RAT(0),0)) gives TRUE.  If a determination
can't be made with EQUAL then a simplified but equivalent form is
returned whereas = always causes either TRUE or FALSE to be returned.
All variables occurring in exp are presumed to be real valued.
EV(exp,PRED) is equivalent to IS(exp).

(C1) IS(X**2 >= 2*X-1);
(D1)                               TRUE

(C2) ASSUME(A>1);
(D2)                               DONE

(C3) IS(LOG(LOG(A+1)+1)>0 AND A^2+1>2*A);

(D3)                               TRUE

&ERF(X) - the error function, whose derivative is:
2*EXP(-X^2)/SQRT(%PI).

&ERFFLAG default: [TRUE] if FALSE prevents RISCH from introducing the
ERF function in the answer if there were none in the integrand to
begin with.

&ERRCATCH(exp1, exp2, ...) evaluates its arguments one by one and
returns a list of the value of the last one if no error occurs.  If an
error occurs in the evaluation of any arguments, ERRCATCH "catches"
the error and immediately returns [] (the empty list).  This function
is useful in BATCH files where one suspects an error might occur which
would otherwise have terminated the BATCH if the error weren't caught.

&ERREXP default: [ERREXP] When an error occurs in the course of a
computation, MACSYMA prints out an error message and terminates the
computation.  ERREXP is set to the offending expression and the
message "ERREXP contains the offending expression" is printed.  The
user can then type ERREXP; to see this and hopefully find the problem.

&ERRINTSCE default: [TRUE] - If a call to the INTSCE routine is not of
the form

EXP(A*X+B)*COS(C*X)^N*SIN(C*X)^M

then the regular integration program will be invoked if the switch
ERRINTSCE[TRUE] is TRUE.  If it is FALSE then INTSCE will err out.

&ERROR(arg1, arg2, ...)  will evaluate and print its arguments and
then will cause an error return to top level MACSYMA or to the nearest
enclosing ERRCATCH.  This is useful for breaking out of nested
functions if an error condition is detected, or wherever one can't
type control-^.

The variable ERROR is set to a list describing the error, the first of
it being a string of text, and the rest the objects in question.
ERRORMSG(); is the preferred way to see the last error message.

ERRORFUN default: [FALSE] - if set to the name of a function of no
arguments will cause that function to be executed whenever an error
occurs.  This is useful in BATCH files where the user may want his
MACSYMA killed or his terminal logged out if an error occurs.  In
these cases ERRORFUN would be set to QUIT or LOGOUT.

&ERROR_SIZE default: [20 for a display terminal, 10 for others].
controls the size of error messages.  For example, let
U:(C^D^E+B+A)/(COS(X-1)+1); .  U has an error size of 24.  So if
ERROR_SIZE has value < 24 then 

(C1) ERROR("The function", FOO,"doesn't like", U,"as input.");

prints as:

The function FOO doesn't like ERREXP1 as input.

If ERROR_SIZE>24 then as:
                                 E
                                D
                               C   + B + A
The function FOO doesn't like -------------- as input.
                              COS(X - 1) + 1

Expressions larger than ERROR_SIZE are replaced by symbols, and the
symbols are set to the expressions.  The symbols are taken from the
user-settable list ERROR_SYMS:[ERREXP1,ERREXP2,ERREXP3].
The default value of this switch might change depending on user
experience.  If you find the defaults either too big or two small
for your tastes, send mail to MACSYMA.

&ERROR_SYMS default: [ERREXP1,ERREXP2,ERREXP3] - In error messages,
expressions larger than ERROR_SIZE are replaced by symbols, and the
symbols are set to the expressions.  The symbols are taken from the
list ERROR_SYMS, and are initially ERREXP1, ERREXP2, ERREXP3, etc.
After an error message is printed, e.g. "The function FOO doesn't
like ERREXP1 as input.", the user can type ERREXP1; to see the
expression.  ERROR_SYMS may be set by the user to a different set
of symbols, if desired.

&ERRORFUN default: [FALSE] - if set to the name of a function of no
arguments will cause that function to be executed whenever an error
occurs.  This is useful in BATCH files where the user may want his
MACSYMA killed or his terminal logged out if an error occurs.  In
these cases ERRORFUN would be set to QUIT or LOGOUT.

&ERRORMSG() reprints the last error message.  This is very helpful if
you are using a display console and the message has gone off the
screen.  The variable ERROR is set to a list describing the error,
the first of it being a string of text, and the rest the objects in
question.

TTYINTFUN:LAMBDA([],ERRORMSG(),PRINT(""))$ will set up the user-interrupt
character (^U) to reprint the message.

&ETENSR - This package has been renamed CTENSR.

&EULER(X) - gives the Xth Euler number for integer X.  For the
Euler-Mascheroni constant, see %GAMMA.

&EULERPOLY(v, n) generates the nth Euler polynomial in the variable v.
(See EULER)

&EV(exp, arg1, ..., argn) is one of MACSYMA's most powerful and
versatile commands. It evaluates the expression exp in the environment
specified by the argi.  This is done in steps, as follows:

    (1) First the environment is set up by scanning the argi which may
be as follows:

SIMP causes exp to be simplified regardless of the setting of the
switch SIMP which inhibits simplification if FALSE.

NOEVAL supresses the evaluation phase of EV (see step (4) below).
This is useful in conjunction with the other switches and in causing
exp to be resimplified without being reevaluated.

EXPAND causes expansion.

EXPAND(m,n) causes expansion, setting the values of MAXPOSEX and
MAXNEGEX to m and n respectively.

DETOUT causes any matrix inverses computed in exp to have their
determinant kept outside of the inverse rather than dividing through
each element.

DIFF causes all differentiations indicated in exp to be performed.

DERIVLIST(var1,...,vark) causes only differentiations with respect to
the indicated variables.

FLOAT causes non-integral rational numbers to be converted to floating
point.

NUMER causes some mathematical functions (including exponentiation)
with numerical arguments to be evaluated in floating point.  It causes
variables in exp which have been given numervals to be replaced by
their values.  It also sets the FLOAT switch on.

PRED causes predicates (expressions which evaluate to TRUE or FALSE)
to be evaluated.

EVAL causes an extra post-evaluation of exp to occur. (See step (5)
below.)

E where E is an atom declared to be an EVFLAG causes E to be bound to
TRUE during the evaluation of exp.

V:expression (or alternately V=expression) causes V to be bound to the
value of expression during the evaluation of exp.  Note that if V is a
MACSYMA option, then expression is used for its value during the
evaluation of exp.  If more than one argument to EV is of this type
then the binding is done in parallel.  If V is a non-atomic expression
then a substitution rather than a binding is performed.

E where E, a function name, has been declared to be an EVFUN causes E
to be applied to exp.

Any other function names (e.g.  SUM) cause evaluation of occurrences
of those names in exp as though they were verbs.

In addition a function occurring in exp (say F(args)) may be defined
locally for the purpose of this evaluation of exp by giving
F(args):=body as an argument to EV.

If an atom not mentioned above or a subscripted variable or
subscripted expression was given as an argument, it is evaluated and
if the result is an equation or assignment then the indicated binding
or substitution is performed.  If the result is a list then the
members of the list are treated as if they were additional arguments
given to EV. This permits a list of equations to be given (e.g. [X=1,
Y=A**2] ) or a list of names of equations (e.g.  [E1,E2] where E1 and
E2 are equations) such as that returned by SOLVE.

The argi of EV may be given in any order with the exception of
substitution equations which are handled in sequence, left to right,
and EVFUNS which are composed, e.g. EV(exp,RATSIMP,REALPART) is
handled as REALPART(RATSIMP(exp)).

The SIMP, NUMER, FLOAT, and PRED switches may also be set locally in a
block, or globally at the "top level" in MACSYMA so that they will
remain in effect until being reset.

If exp is in CRE form then EV will return a result in CRE form
provided the NUMER and FLOAT switches are not both TRUE.

    (2) During step (1), a list is made of the non-subscripted
variables appearing on the left side of equations in the argi or in
the value of some argi if the value is an equation.  The variables
(both subscripted variables which do not have associated array
functions, and non-subscripted variables) in the expression exp are
replaced by their global values, except for those appearing in this
list.  Usually, exp is just a label or % (as in (C2) below), so this
step simply retrieves the expression named by the label, so that EV
may work on it.

    (3) If any substitutions are indicated by the argi, they are
carried out now.

    (4) The resulting expression is then re-evaluated (unless one of
the argi was NOEVAL) and simplified according the the argi.  Note that
any function calls in exp will be carried out after the variables in
it are evaluated and that EV(F(X)) thus may behave like F(EV(X)).

    (5) If one of the argi was EVAL, steps (3) and (4) are repeated.

                     Examples

(C1) SIN(X)+COS(Y)+(W+1)**2+'DIFF(SIN(W),W);
                        d                 2
(D1)  COS(Y) + SIN(X) + -- SIN(W) + (W + 1)
                        dW
(C2) EV(%,SIN,EXPAND,DIFF,X=2,Y=1);
                    2
(D2)      COS(W) + W  + 2 W + COS(1) + 1.90929742

An alternate "top level" syntax has been provided for EV, whereby one
may just type in its arguments, without the EV().  That is, one may
write simply exp,arg1,...,argn.  (This is not permitted as part of
another expression, i.e. in functions, blocks, etc.)

(C4) X+Y,X:A+Y,Y:2;
(D4)                Y + A + 2

(Notice the parallel binding process)

(C5) 2*X-3*Y=3$

(C6) -3*X+2*Y=-4$

(C7) SOLVE([D5,D6]);
SOLUTION
                                1
(E7)                     Y =  - -
                                5
                          6
(E8)                  X = -
                          5

(D8)               [E7, E8]

(C9) D6,D8;
(D9)               - 4 =  - 4

(C10) X+1/X > GAMMA(1/2);

                    1
(D10)           X + - > SQRT(%PI)
                    X

(C11) %,NUMER,X=1/2;

(D11)            2.5 > 1.7724539

(C12) %,PRED;
(D12)                  TRUE

&EVAL causes an extra post-evaluation of exp to occur.

&EVENP(exp) is TRUE if exp is an even integer.  FALSE is returned in
all other cases.

&EVFLAG default: [] - the list of things known to the EV function.  An
item will be bound to TRUE during the execution of EV if it is
mentioned in the call to EV, e.g. EV(%,numer);.  Initial evflags are
FLOAT, PRED, SIMP, NUMER, DETOUT, EXPONENTIALIZE, DEMOIVRE, KEEPFLOAT,
LISTARITH, TRIGEXPAND, SIMPSUM, ALGEBRAIC, RATALGDENOM, FACTORFLAG,
%EMODE, LOGARC, LOGNUMER, RADEXPAND, RATSIMPEXPONS, RATMX, RATFAC,
INFEVAL, %ENUMER, PROGRAMMODE, LOGNEGINT, LOGABS, LETRAT, HALFANGLES,
EXPTISOLATE, ISOLATE_WRT_TIMES, SUMEXPAND, CAUCHYSUM, NUMER_PBRANCH,
M1PBRANCH, DOTSCRULES, and LOGEXPAND.

&EVFUN - the list of functions known to the EV function which will get
applied if their name is mentioned.  Initial evfuns are FACTOR,
TRIGEXPAND, TRIGREDUCE, BFLOAT, RATSIMP, RATEXPAND, RADCAN,
LOGCONTRACT, RECTFORM, and POLARFORM.

&EXAMPLE(command) will start up a demonstration of how command works
on some expressions.  After each command line it will pause and wait
for a space to be typed, as in the DEMO command.

&EXP(X) - the exponential function.  It is represented internally as
%E^X.

  DEMOIVRE[FALSE] - if TRUE will cause %E^(A+B*%I) to become
%E^A*(COS(B)+%I*SIN(B)) if B is free of %I.  A and B are not expanded.

  %EMODE[TRUE] - when TRUE %E^(%PI*%I*X) will be simplified as
follows: it will become COS(%PI*X)+%I*SIN(%PI*X) if X is an integer or
a multiple of 1/2, 1/3, 1/4, or 1/6 and thus will simplify further.
For other numerical X it will become %E^(%PI*%I*Y) where Y is X-2*k
for some integer k such that ABS(Y)<1.  If %EMODE is FALSE no
simplification of %E^(%PI*%I*X) will take place.

  %ENUMER[FALSE] - when TRUE will cause %E to be converted into
2.718...  whenever NUMER is TRUE.  The default is that this conversion
will take place only if the exponent in %E^X evaluates to a number.

&EXPAND(exp) will cause products of sums and exponentiated sums to be
multiplied out, numerators of rational expressions which are sums to
be split into their respective terms, and multiplication (commutative
and non-commutative) to be distributed over addition at all levels of
exp.  For polynomials one should usually use RATEXPAND which uses a
more efficient algorithm (see DESCRIBE(RATEXPAND);).

MAXNEGEX[1000] and MAXPOSEX[1000] control the maximum negative and
positive exponents, respectively, which will expand.

EXPAND(exp,p,n) expands exp, using p for MAXPOSEX and n for MAXNEGEX.
This is useful in order to expand part but not all of an expression.

EXPON[0] - the exponent of the largest negative power which is
automatically expanded (independent of calls to EXPAND).  For example
if EXPON is 4 then (X+1)**(-5) will not be automatically expanded.

EXPOP[0] - the highest positive exponent which is automatically
expanded.  Thus (X+1)**3, when typed, will be automatically expanded
only if EXPOP is greater than or equal to 3.  If it is desired to have
(X+1)**N expanded where N is greater than EXPOP then executing
EXPAND((X+1)**N) will work only if MAXPOSEX is not less than N.

The EXPAND flag used with EV (see EV) causes expansion.

The file SHARE1;FACEXP FASL contains several related functions 
(FACSUM and COLLECTTERMS are two) that provide the user with the 
ability to structure expressions by controlled expansion.
Brief function descriptions are available in SHARE1;FACEXP USAGE.
A demo is available by doing BATCH(FACEXP,DEMO,DSK,SHARE1)$ .

&EXPANDWRT(exp,var1,var2,...) expands exp with respect to the vari.
All products involving the vari appear explicitly.  The form returned
will be free of products of sums of expressions that are not free of
the vari.  The vari may be variables, operators, or expressions.  By
default, denominators are not expanded, but this can be controlled by
means of the switch EXPANDWRT_DENOM.  Do LOAD(STOPEX); to use this
function.

&EXPANDWRT_DENOM default:[FALSE] controls the treatment of rational
expressions by EXPANDWRT.  If TRUE, then both the numerator and
denominator of the expression will be expanded according to the
arguments of EXPANDWRT, but if EXPANDWRT_DENOM is FALSE, then only the
numerator will be expanded in that way.  Do LOAD(STOPEX) to use.

&EXPANDWRT_FACTORED(exp, var1, var2, ..., varN) is similar to
EXPANDWRT, but treats expressions that are products somewhat
differently.  EXPANDWRT_FACTORED will perform the required expansion
only on those factors of exp that contain the variables in the
argument list of EXPANDWRT_FACTORED.  Do LOAD(STOPEX) to use this
function.

&EXPON default: [0] - the exponent of the largest negative power which
is automatically expanded (independent of calls to EXPAND).  For
example if EXPON is 4 then (X+1)**(-5) will not be automatically
expanded.

&EXPONENTIALIZE default: [FALSE] if TRUE will cause all circular and
hyperbolic functions to be converted to exponential form.  (Setting
DEMOIVRE:TRUE; will reverse the effect.)

EXPONENTIALIZE(exp) will cause the conversion to exponential form of an
expression without setting the switch or having to re-evaluate the
expression with EV.

&EXPOP default: [0] - the highest positive exponent which is
automatically expanded.  Thus (X+1)**3, when typed, will be
automatically expanded only if EXPOP is greater than or equal to 3.
If it is desired to have (X+1)**n expanded where n is greater than
EXPOP then executing EXPAND((X+1)**n) will work only if MAXPOSEX is
not less than n.

&EXPRESS(expression) - The result uses the noun form of any
derivatives arising from expansion of the vector differential
operators.  To force evaluation of these derivatives, the built-in EV
function can be used together with the DIFF evflag, after using the
built-in DEPENDS function to establish any new implicit dependencies.

&EXPT(A,B) - if an exponential expression is too wide to be displayed
as A^B it will appear as EXPT(A,B) (or as NCEXPT(A,B) in the case of
A^^B).

&EXPTDISPFLAG default: [TRUE] - if TRUE, MACSYMA displays expressions
with negative exponents using quotients e.g., X**(-1) as 1/X.

&EXPTISOLATE default: [FALSE] if TRUE will cause ISOLATE(expr,var); to
examine exponents of atoms (like %E) which contain var.

&EXPTSUBST default: [FALSE] if TRUE permits substitutions such as Y
for %E**X in %E**(A*X) to take place.

&EZGCD(p1, p2, ...) gives a list whose first element is the g.c.d of
the polynomials p1,p2,...  and whose remaining elements are the
polynomials divided by the g.c.d.  This always uses the EZGCD
algorithm.

&FACEXPAND default: [TRUE] controls whether the irreducible factors
returned by FACTOR are in expanded (the default) or recursive (normal
CRE) form.

&FACTCOMB(exp) tries to combine the coefficients of factorials in exp
with the factorials themselves by converting, for example, (N+1)*N!
into (N+1)!.

SUMSPLITFACT[TRUE] if set to FALSE will cause MINFACTORIAL to be
applied after a FACTCOMB.

(C1) (N+1)^2*N!^2;
                                      2   2
(D1)                           (N + 1)  N!

(C2) FACTCOMB(%);
                                         2
(D1)                             (N + 1)!

&FACTLIM default: [-1] gives the highest factorial which is
automatically expanded.  If it is -1 then all integers are expanded.

&FACTOR(exp) factors the expression exp, containing any number of
variables or functions, into factors irreducible over the integers.

FACTOR(exp, p) factors exp over the field of integers with an element
adjoined whose minimum polynomial is p.

FACTORFLAG[FALSE] if FALSE suppresses the factoring of integer factors
of rational expressions.

DONTFACTOR may be set to a list of variables with respect to which
factoring is not to occur.  (It is initially empty).  Factoring also
will not take place with respect to any variables which are less
important (using the variable ordering assumed for CRE form) than
those on the DONTFACTOR list.

SAVEFACTORS[FALSE] if TRUE causes the factors of an expression which
is a product of factors to be saved by certain functions in order to
speed up later factorizations of expressions containing some of the
same factors.

BERLEFACT[TRUE] if FALSE then the Kronecker factoring algorithm will
be used otherwise the Berlekamp algorithm, which is the default, will
be used.

INTFACLIM[1000] is the largest divisor which will be tried when
factoring a bignum integer.  If set to FALSE (this is the case when
the user calls FACTOR explicitly), or if the integer is a fixnum (i.e.
fits in one machine word), complete factorization of the integer will
be attempted.  The user's setting of INTFACLIM is used for internal
calls to FACTOR. Thus, INTFACLIM may be reset to prevent MACSYMA from
taking an inordinately long time factoring large integers.

NEWFAC[FALSE] may be set to true to use the new factoring routines.

When FACTOR is applied to integers, note that the value returned by
FACTOR when used in other computations may not lead to a simplified
result.  It is advisable to resimplify an expression after FACTORing
it.

Do EXAMPLE(FACTOR); for examples.

&FACTORFLAG default: [FALSE] if FALSE suppresses the factoring of
integer factors of rational expressions.

&FACTORIAL(X) - The factorial function.  FACTORIAL(X) = X! .
See also MINFACTORIAL and FACTCOMB.  The factorial operator is !,
and the double factorial operator is !!.

&FACTOROUT(exp,var1,var2,...) rearranges the sum exp into a sum of
terms of the form f(var1,var2,...)*g where g is a product of
expressions not containing the vari's and f is factored.

&FACTORSUM(exp) tries to group terms in factors of exp which are sums
into groups of terms such that their sum is factorable.  It can
recover the result of EXPAND((X+Y)^2+(Z+W)^2) but it can't recover
EXPAND((X+1)^2+(X+Y)^2) because the terms have variables in common.

(C1) (X+1)*((U+V)^2+A*(W+Z)^2),EXPAND;

      2      2                            2      2
(D1) A X Z  + A Z  + 2 A W X Z + 2 A W Z + A W  X + V  X

                     2        2    2            2
        + 2 U V X + U  X + A W  + V  + 2 U V + U

(C2) FACTORSUM(%);
                                   2          2
(D2)                 (X + 1) (A (Z + W)  + (V + U) )

&FACTS(item) - If 'item' is the name of a context then FACTS returns a list
of the facts in the specified context.  If no argument is given, it
lists the current context.  If 'item' is not the name of a context
then it returns a list of the facts known about 'item' in the current
context.  Facts that are active, but in a different context, are not
listed.

&FALSE - the Boolean constant, false. (NIL in LISP)

&FASSAVE(args) is similar to SAVE but produces a FASL file in which
the sharing of subexpressions which are shared in core is preserved in
the file created.  Hence, expressions which have common subexpressions
will consume less space when loaded back from a file created by
FASSAVE rather than by SAVE.  Files created with FASSAVE are reloaded
using LOADFILE, just as files created with SAVE.  FASSAVE returns a
list of the form [<name of file>,<size of file in blocks>,...] where
...  are the things saved.  Warnings are printed out in the case of
large files.  FASSAVE may be used while a WRITEFILE is in progress.

&FASTTIMES(p1, p2) multiplies the polynomials p1 and p2 by using a
special algorithm for multiplication of polynomials.  They should be
multivariate, dense, and nearly the same size.  Classical
multiplication is of order N*M where N and M are the degrees.
FASTTIMES is of order MAX(N,M)**1.585.

&FEATURE - A nice adjunct to the system.  STATUS(FEATURE) gives you a
list of system features. At present the list for MC is: MACSYMA,
NOLDMSG, MACLISP, PDP10, BIGNUM, FASLOAD, HUNK, FUNARG, ROMAN, NEWIO,
SFA, PAGING, MC, and ITS.  Any of these "features" may be given as a
second argument to STATUS(FEATURE,...); If the specified feature
exists, TRUE will be returned, else FALSE.  Note: these are system
features, and not really "user related".  See also DESCRIBE(features);
for more user-oriented features.

&FEATUREP(a,f) attempts to determine whether the object a has the
feature f on the basis of the facts in the current data base.  If so,
it returns TRUE, else FALSE.  See DESCRIBE(FEATURES); .

(C1) DECLARE(J,EVEN)$
(C2) FEATUREP(J,INTEGER);
(D2)                                TRUE

&FEATURES - MACSYMA has built-in properties which are handled by the
data base.  These are called FEATURES.  One can do DECLARE(N,INTEGER),
etc.  One can also DECLARE one's own FEATURES by e.g.
DECLARE(INCREASING,FEATURE); which will then allow one to say
DECLARE(F,INCREASING);.  One can then check if F is INCREASING by
using the predicate FEATUREP via FEATUREP(F,INCREASING).  There is
an infolist FEATURES which is a list of known FEATURES.  At present
known FEATURES are: INTEGER, NONINTEGER, EVEN, ODD, RATIONAL,
IRRATIONAL, REAL, IMAGINARY, COMPLEX, ANALYTIC, INCREASING,
DECREASING, ODDFUN, EVENFUN, POSFUN, COMMUTATIVE, LASSOCIATIVE,
RASSOCIATIVE, SYMMETRIC, and ANTISYMMETRIC.  [Note: system "features"
may be checked with STATUS(FEATURE,...); See DESCRIBE(STATUS); or
DESCRIBE(FEATURE); for details.]

&FFT(real-array, imag-array) - Fast Fourier Transform.  This
package may be loaded by doing LOAD(FFT); There is also an IFT
command, for Inverse Fourier Transform.  These functions perform a
(complex) fast fourier transform on either 1 or 2 dimensional
FLOATING-POINT arrays, obtained by: ARRAY(<ary>,FLOAT,<dim1>); or
ARRAY(<ary>,FLOAT,<dim1>,<dim2>); For 1D arrays <dim1> must equal
2^n-1, and for 2D arrays <dim1>=<dim2>=2^n-1 (i.e. the array is
square).  (Recall that MACSYMA arrays are indexed from a 0 origin so
that there will be 2^n and (2^n)^2 arrays elements in the above two
cases.)  This package also contains two other functions, POLARTORECT
and RECTTOPOLAR.  Do DESCRIBE(cmd) for details. For details on the
implementation, do PRINTFILE(FFT,USAGE,SHARE); .

&FIB(X) - the Xth Fibonacci number with FIB(0)=0, FIB(1)=1, and
FIB(-N)=(-1)^(N+1) *FIB(N).  PREVFIB is FIB(X-1), the Fibonacci number
preceding the last one computed.

&FIBTOPHI(exp) - converts FIB(n) to its closed form definition.
This involves the constant %PHI (= (SQRT(5)+1)/2 = 1.618033989).
If you want the Rational Function Package to know 
About %PHI do TELLRAT(%PHI^2-%PHI-1)$  ALGEBRAIC:TRUE$ .

&FILE - A file on ITS has two names, each of up to 6 characters in
length, a device (DSK is the default) and a directory (the default is
your home directory for the machine you are on).  See FILEDEFAULTS,
for more details.  DESCRIBE(FILES); has more information.

&FILE_SEARCH default:["SHARE;","SHARE1;","SHARE2;","SHAREM;"] - the
list of directories which will be searched when the LOAD function is
used.

FILE_SEARCH("filename"); searches on those directories and devices
specified by the FILE_SEARCH variable, and returns the name of the
first file it finds.  This function is invoked by the LOAD function,
which is why LOAD("FFT") finds and loads DSK:SHARE;FFT FASL.  You may
do FILE_SEARCH:CONS("dsk:dir\;",FILE_SEARCH); to add other directories
to the search rules.

&FILE_STRING_PRINT default: [FALSE] on MC, [TRUE] elsewhere.  If
TRUE, filenames are output as strings; if FALSE, as lists.  For
example, the message when an out of core file is loaded into
MACSYMA (e.g. the LIMIT package), appears on MC in list format as
  LIMIT FASL DSK MACSYM being loaded
and in string format as:
  DSK:MACSYM;LIMIT FASL being loaded
The string format is like the top level (DDT) file specifications.

&FILE_TYPE("filename"); returns FASL, LISP, or MACSYMA, depending on
what kind of file it is.

&FILEDEFAULTS() - returns a list of the current defaults
[filename1,filename2,device,directory] exactly like that returned by
the CLOSEFILE, DELFILE, or SAVE commands.  This is the file
specification which will be tried for LOADFILE or BATCH if they are
called with no arguments.

FILEDEFAULTS('[file]) - sets the current filedefaults to "file".  The
argument to FILEDEFAULTS is evaluated as it is anticipated that the
command will be used mainly in programs.  The "file" need not be a
real file, so one can use this function e.g.  if one's real purpose is
to set the "device" field back to "DSK", where one does not care about
the settings for the other fields.
E.g. FILEDEFAULTS('[FN1,FN2,DSK,USER]); .

&FILELENGTH(name1,name2,directory) Gives the length of the file
(name1,name2) in blocks and fractions of blocks.

&FILENAME default: [] - The value of this variable is the first name
of the files which are generated by the automatic disk storage scheme.
The default value is the first three characters of the user's login
name concatenated with the lowest unused integer, e.g. ECR1.

&FILENAME_MERGE("filename1","filename2",...); merges together
filenames, using a "*" convention for unspecified components of
filenames, with the leftmost filenames getting precedence.

&FILENAMES - Filenames on ITS consist of 6 characters each.  A
complete file specification on ITS consists of a device (DSK in most
cases) a directory (your "home directory", usually one of the USERSi
directories) and the two file names.  When you use a group directory,
you should use your login name as the first filename, so as to be sure
that you can easily identify your own files.  The complete file
specification is similar to what is called a "pathname" on UNIX and
Multics systems.  See FILE and FILEDEFAULTS for more information. 

&FILENUM default: [0] - The default second file name for files generated
by SAVE, STRINGOUT, or FASSAVE if no file names are specified by the
user.  It is an integer, and is incremented by one each time a new file
is written.

&FILEOP - SHARE;FILEOP -- some file primitives for MC Macsyma users.
Macsyma now provides some useful simple file primitives which were
formerly only available in other system programs.

To print the contents of a file on your terminal, say
PRINTFILE(file,name,dsk,me);

To list your directory, say LISTFILES(dsk,me).  If you use a shared
directory such as USERS or PLASMA, only your files--the ones
with your login name as first file name--will be shown.
The length and date of creation of each file is also shown.

The function FILELENGTH returns the length of the file argument
in blocks and fractional blocks.

In order to list just the names of your files without the
length and date information, use QLISTFILES (Quick LIST Files)
with the same arguments as LISTFILES.

The function RENAMEFILE(oldname,newname) renames a file from oldname
to newname.

Details.

The PRINTFILE command takes the same argument syntax as LOADFILE;
the other two take the syntax of WRITEFILE.  LISTFILES indicates
whether each file is stored on secondary disk and whether it
has been backed up to tape (an exclamation point appears if
it has not).

The FILELENGTH command returns the length in blocks and fractional
blocks: there are five characters in a word and 1024 words in a disk block.
(So if it returns 5.6, the file is 6 blocks long, but the last block
is only 60% full.  This file would be 5.6*1024*5 (= 28672) characters
long.)  If the file named does not exist, an error message is printed,
and False is returned to permit easier recovery in a program.

Files may not be renamed across directories or devices. Both oldname
and newname must be on the same directory. Renaming a file to a filename
that already exists gives an error. You must explicitly DELFILE the
existing file first if that's what you want.  Both oldname and newname
must be list-type filespecs. example: 
RENAMEFILE([myold,file,dsk,foo],[mynew,file]);

&FILES - A file is simply an area on a particular storage device which
contains data or text.  The only storage devices which are used on the
MC machine are disks and tapes.  Files on the disks are figuratively
grouped into "directories".  A directory is just a list of all the
files stored under a given user name.  Do DESCRIBE(FILEOP); for
details of how you may inspect your files using MACSYMA.  Other
commands which deal with files are: SAVE, FASSAVE, STORE, LOAD,
LOADFILE, RESTORE, UNSTORE, STRINGOUT, BATCH, BATCON, DEMO, WRITEFILE,
CLOSEFILE, DELFILE, REMFILE, and APPENDFILE.

&FILESIZE default: [] - The value of this variable is the number of
expressions written into each file by the automatic disk storage
scheme.  The default value is 16.

&FILLARRAY(array,list-or-array) fills array from list-or-array.  If
array is a floating-point (integer) array then list-or-array should be
either a list of floating-point (integer) numbers or another
floating-point (integer) array.  If the dimensions of the arrays are
different array is filled in row-major order.  If there are not enough
elements in list-or-array the last element is used to fill out the
rest of array.  If there are too many the remaining ones are thrown
away.  FILLARRAY returns its first argument.

&FIRST(exp) yields the first part of exp which may result in the first
element of a list, the first row of a matrix, the first term of a sum,
etc.  Note that FIRST and its related functions, REST and LAST, work
on the form of exp which is displayed not the form which is typed on
input.  If the variable INFLAG [FALSE] is set to TRUE however, these
functions will look at the internal form of exp.  Note that the
simplifier re-orders expressions.  Thus FIRST(X+Y) will be X if INFLAG
is TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X) gives the same
results).

&FIX(x) - a synonym for ENTIER(X) - largest integer <= X where X is
numeric.

&FLOAT(exp) - converts integers, rational numbers and bigfloats in exp
to floating point numbers.  It is also an EVFLAG.  FLOAT causes
non-integral rational numbers and bigfloat numbers to be converted to
floating point.

&FLOAT2BF default: [FALSE] if FALSE, a warning message is printed when
a floating point number is converted into a bigfloat number (since
this may lead to loss of precision).

&FLOATDEFUNK - is a utility for making floating point functions from
mathematical expression. It will take the input expression and FLOAT it,
then OPTIMIZE it, and then insert MODE_DECLAREations for all the variables.
This is THE way to use ROMBERG, PLOT2, INTERPOLATE, etc. e.g.
EXP:some-hairy-macsyma-expression;
FLOATDEFUNK('F,['X],EXP); will define the function F(X) for you.
(Do PRINTFILE(MCOMPI,DOC,MAXDOC); for more details.)

&FLOATNUMP(exp) is TRUE if exp is a floating point number else FALSE.

&FLUSH(exp,tensor1,tensor2,...) Tensor Package - will set to zero, in
exp, all occurrences of the tensori that have no derivative indices.

&FLUSHD(exp,tensor1,tensor2,...) Tensor Package - will set to zero, in
exp, all occurrences of the tensori that have derivative indices.

&FLUSHND(exp,tensor,n) Tensor Package - will set to zero, in exp, all
occurrences of the differentiated object tensor that have n or more
derivative indices as the following example demonstrates.
(C1) SHOW(A([I],[J,R],K,R)+A([I],[J,R,S],K,R,S));
                               J R S      J R
(D1)                          A        + A
                               I,K R S    I,K R

(C2) SHOW(FLUSHND(D1,A,3));
                                     J R
(D2)                                A
                                     I,K R

&FOR - Used in iterations, do DESCRIBE("DO"); for a description of
MACSYMA's iteration facilities.

&FORGET(pred1, pred2, ...)  removes relations established by ASSUME.
The predicates may be expressions equivalent to (but not necessarily
identical to) those previously ASSUMEd.  FORGET(list) is also a legal
form.

&FORTINDENT default: [0] - controls the left margin indentation of
expressions printed out by the FORTRAN command.  0 gives normal
printout (i.e. 6 spaces), and positive values will causes the
expressions to be printed farther to the right.

&FORTMX(name,matrix) converts a MACSYMA matrix into a sequence of
FORTRAN assignment statements of the form name(i,j)=<corresponding
matrix element>.  This command is now obsolete.  FORTMX(name,matrix);
may now be done as FORTRAN(name=matrix);.  (If "name" is bound,
FORTRAN('name=matrix); may be necessary.)  Please convert code that
uses the FORTMX command as it may be flushed some day.

&FORTRAN(exp) converts exp into a FORTRAN linear expression in legal
FORTRAN with 6 spaces inserted at the beginning of each line,
continuation lines, and ** rather than ^ for exponentiation.  When the
option FORTSPACES[FALSE] is TRUE, the FORTRAN command fills out to 80
columns using spaces.  If FORTRAN is called on a bound symbolic atom,
e.g. FORTRAN(X); where X:A*B$ has been done, then X={value of X}, e.g.
X=A*B will be generated.  In particular, if e.g. M:MATRIX(...); has
been done, then FORTRAN(M); will generate the appropriate assignment
statements of the form name(i,j)=<corresponding matrix element>.
FORTINDENT[0] controls the left margin of expressions printed out, 0
is the normal margin (i.e. indented 6 spaces), increasing it will
cause the expression to be printed further to the right.

&FORTSPACES default: [FALSE] - if TRUE, the FORTRAN command fills out
to 80 columns using spaces.

&FOURIER - There is a Fast Fourier Transform package, do DESCRIBE(FFT)
for details.  There is also a Fourier Series package.  It may be
loaded with LOAD(FOURIE).  It will also calculate Fourier integral
coefficients and has various other functions to do such things as
replace all occurrences of F(ARG) by ARG in expression (like changing
ABS(a*x+b) to a*x+b).  Do PRINTFILE(FOURIE,USAGE,DSK,SHARE1); for
a list of the functions included.

&FPPRINTPREC default: [0] - The number of digits to print when
printing a bigfloat number, making it possible to compute with a large
number of digits of precision, but have the answer printed out with a
smaller number of digits.  If FPPRINTPREC is 0 (the default), or >=
FPPREC, then the value of FPPREC controls the number of digits used
for printing.  However, if FPPRINTPREC has a value between 2 and
FPPREC-1, then it controls the number of digits used.  (The minimal
number of digits used is 2, one to the left of the point and one to
the right.  The value 1 for FPPRINTPREC is illegal.)

&FPPREC default: [16] - Floating Point PRECision.  Can be set to an
integer representing the desired precision.

&FREEOF(x1, x2, ..., exp) yields TRUE if the xi do not occur in exp
and FALSE otherwise.  The xi are atoms or they may be subscripted
names, functions (e.g.  SIN(X) ), or operators enclosed in "s.  If
'var' is a "dummy variable" of 'exp', then FREEOF(var,exp); will
return TRUE.  "Dummy variables" are mathematical things like the index
of a sum or product, the limit variable, and the definite integration
variable.  Example: FREEOF(I,'SUM(F(I),I,0,N)); returns TRUE.  Do
EXAMPLE(FREEOF); for more examples.

&FULLDISKUSE(username) If no name is supplied, it defaults to the
current user's.  Returns long list of info about user's disk usage of
the form:

  [["TOTAL FREE BLOCKS", [<pack-type>, <pack-number>, <n> BLOCKS],
                         [<pack-type>, <pack-number>, <n> BLOCKS], ...]
   ["DIRECTORY BLOCK USAGE", <directory-name>
                             ["PRIMARY", <n> BLOCKS],
                             ["SECONDARY", <n> BLOCKS]]
   ["USER BLOCK USAGE", <user-name>,
                        [PRIMARY, <n> BLOCKS],
                        [SECONDARY, <n> BLOCKS]]]

If the user has his own directory, the last element of the list ("USER
BLOCK USAGE") is omitted since it would be the same as "DIRECTORY
BLOCK USAGE".

        <pack-type> ::= "PRIMARY PACK" or "SECONDARY PACK"
        <pack-number> ::= a fixed point number
        <n> ::= a fixed point number

Occurrences of `<n> BLOCKS' are in the form of a Macsyma multiplication
between a fixnum <n> and the Macsyma symbol BLOCKS.

&FULLMAP(fn, exp1, ...) is similar to MAP but it will keep mapping
down all subexpressions until the main operators are no longer the
same.  The user should be aware that FULLMAP is used by the MACSYMA
simplifier for certain matrix manipulations; thus, the user might see
an error message concerning FULLMAP even though FULLMAP was not
explicitly called by the user.  FULLMAP is affected by the setting of
INFLAG, do DESCRIBE(INFLAG) for details.

(C1) A+B*C$

(C2) FULLMAP(G,%);

(D2)              G(B) G(C) + G(A)

(C3)  MAP(G,D1);

(D3)                G(B C) + G(A)

&FULLMAPL(fn, list1, ...) is similar to FULLMAP but it only maps onto
lists and matrices.

(C1) FULLMAPL("+",[3,[4,5]],[[A,1],[0,-1.5]]);

(D1)                      [[A + 3, 4], [4, 3.5]]

&FULLRATSIMP(exp) When non-rational expressions are involved, one call
to RATSIMP followed as is usual by non-rational ("general")
simplification may not be sufficient to return a simplified result.
Sometimes, more than one such call may be necessary.  The command
FULLRATSIMP makes this process convenient.  FULLRATSIMP repeatedly
applies RATSIMP followed by non-rational simplification to an
expression until no further change occurs.  For example, consider
For the expression  EXP:   (X^(A/2)+1)^2*(X^(A/2)-1)^2/(X^A-1) .
RATSIMP(EXP); gives (X^(2*A)-2*X^A+1)/(X^A-1) .
FULLRATSIMP(EXP); gives   X^A-1 .  The problem may be seen by looking at 
RAT(EXP); which gives  ((X^(A/2))^4-2*(X^(A/2))^2+1)/(X^A-1) .
FULLRATSIMP(exp,var1,...,varn) takes one or more arguments similar 
to RATSIMP and RAT.

&FULLRATSUBST(a,b,c) is the same as RATSUBST except that it calls
itself recursively on its result until that result stops changing.
This function is useful when the replacement expression and the
replaced expression have one or more variables in common.
FULLRATSUBST will also accept its arguments in the format of
LRATSUBST.  That is, the first argument may be a single substitution
equation or a list of such equations, while the second argument is the
expression being processed.  There is a demo available by
DEMO(LRATS,DEMO,SHARE2); .

&FUNCSOLVE(eqn,g(t)) gives [g(t) = ...]  or [], depending on whether
or not there exists a rational fcn g(t) satisfying eqn, which must be
a first order, linear polynomial in (for this case) g(t) and g(t+1).

(C1) FUNCSOLVE((N+1)*FOO(N)-(N+3)*FOO(N+1)/(N+1) =
(N-1)/(N+2),FOO(N));
                                   N
(D1)               FOO(N) = ---------------
                            (N + 1) (N + 2)

Warning: this is a very rudimentary implementation--many safety checks
and obvious generalizations are missing.

&FUNCTION - To define a function in MACSYMA you use the := operator.
E.g. F(X):=SIN(X) defines a function F.  See also DEFINE.

&FUNCTIONS default: [] - all user defined functions (set up by
f(x):=...).

&FUNDEF(functionname) - returns the function definition associated
with "functionname".  FUNDEF(fnname); is similar to DISPFUN(fnname);
except that FUNDEF does not invoke display.

&FUNMAKE(name,[arg1,...,argn]) returns name(arg1,...,argn) without
calling the function name.

&GAMALG - This package is no longer supported.

&GAMMA(X) - the gamma function. GAMMA(I)=(I-1)!  for I a positive
integer.  For the Euler-Mascheroni constant, see %GAMMA.  See also the
MAKEGAMMA function.  The variable GAMMALIM[1000000] (which see)
controls simplification of the gamma function.

&GAMMALIM default: [1000000] controls simplification of the gamma
function for integral and rational number arguments.  If the absolute
value of the argument is not greater than GAMMALIM, then
simplification will occur.  Note that the FACTLIM switch controls
simplification of the result of GAMMA of an integer argument as well.

&GAUSS(mean,sd) returns a random floating point number from a normal
distribution with mean MEAN and standard deviation SD.  This is part
of the BESSEL function package, do LOAD(BESSEL); to use it.

&GCD(p1, p2, var1, ...) computes the greatest common divisor of p1 and
p2.  The flag GCD[SPMOD] determines which algorithm is employed.
Setting GCD to EZ, EEZ, SUBRES, RED, or SPMOD selects the EZGCD, New
EEZ GCD, subresultant PRS, reduced, or modular algorithm,
respectively.  If GCD:FALSE then GCD(p1,p2,var) will always return 1
for all var.  Many functions (e.g.  RATSIMP, FACTOR, etc.) cause gcd's
to be taken implicitly.  For homogeneous polynomials it is recommended
that GCD:SUBRES be used.  To take the gcd when an algebraic is
present, e.g. GCD(X^2-2*SQRT(2)*X+2,X-SQRT(2)); , ALGEBRAIC must be
TRUE and GCD must not be EZ.  SUBRES is a new algorithm, and people
who have been using the RED setting should probably change it to
SUBRES.

The GCD flag, default: [SPMOD], if FALSE will also prevent the greatest
common divisor from being taken when expressions are converted to CRE
form.  This will sometimes speed the calculation if gcds are not
required.

&GCFACTOR(n) factors the gaussian integer n over the gaussians, i.e.
numbers of the form a + b i where a and b are rational integers (i.e.
ordinary integers).  Factors are normalized by making a and b
non-negative.

&GENDIFF - Sometimes DIFF(E,X,N) can be reduced even though N is
"symbolic".  BATCH(GENDIF,>,SHARE2)$ and you can try, for example,
DIFF(%E^(A*X),X,Q) by using GENDIFF rather than DIFF.  Unevaluable
items come out quoted.  Some items are in terms of "GENFACT", which
see.

&GENFACT(X, Y, Z) is the generalized factorial of X which is:
X*(X-Z)*(X-2*Z)*...*(X-(Y-1)*Z).  Thus, for integral X,
GENFACT(X,X,1)=X!  and GENFACT(X,X/2,2)=X!!

&GENINDEX default: [I] is the alphabetic prefix used to generate the
next variable of summation when necessary.

&GENMATRIX(array, i2, j2, i1, j1) generates a matrix from the array
using array(i1,j1) for the first (upper-left) element and array(i2,j2)
for the last (lower-right) element of the matrix.  If j1=i1 then j1
may be omitted. If j1=i1=1 then i1 and j1 may both be omitted. If a
selected element of the array doesn't exist a symbolic one will be
used.

(C1) H[I,J]:=1/(I+J-1)$

(C2) GENMATRIX(H,3,3);
                           [   1  1]
                           [1  -  -]
                           [   2  3]
                           [       ]
                           [1  1  1]
(D2)                       [-  -  -]
                           [2  3  4]
                           [       ]
                           [1  1  1]
                           [-  -  -]
                           [3  4  5]

&GENSUMNUM[0] is the numeric suffix used to generate the next variable
of summation.  If it is set to FALSE then the index will consist only
of GENINDEX with no numeric suffix.

&GET(a, i) retrieves the user property indicated by i associated with
atom a or returns FALSE if a doesn't have property i.

(C1) PUT(%E,'TRANSCENDENTAL,'TYPE);
(D1) 			        TRANSCENDENTAL

(C2) PUT(%PI,'TRANSCENDENTAL,'TYPE)$

(C3) PUT(%I,'ALGEBRAIC,'TYPE)$

(C4) TYPEOF(EXP) := BLOCK([Q],
                        IF NUMBERP(EXP)
                        THEN RETURN('ALGEBRAIC),
                        IF NOT ATOM(EXP)
                        THEN RETURN(MAPLIST('TYPEOF, EXP)),
                        Q : GET(EXP, 'TYPE),
                        IF Q=FALSE
			THEN ERRCATCH(ERROR(EXP,"is not numeric.")) ELSE Q)$

(C5) TYPEOF(2*%E+X*%PI);
X is not numeric.
(D5) 	     [[TRANSCENDENTAL, []], [ALGEBRAIC, TRANSCENDENTAL]]

(C6) TYPEOF(2*%E+%PI);
(D6) 	        [TRANSCENDENTAL, [ALGEBRAIC, TRANSCENDENTAL]]

&GETCHAR(a, i) returns the ith character of the quoted string or
atomic name a.  This function is useful in manipulating the LABELS
list.

&GFACTOR(exp) factors the polynomial exp over the Gaussian integers
(i.  e.  with SQRT(-1) = %I adjoined).  This is like
FACTOR(exp,A**2+1) where A is %I.

(C1)  GFACTOR(X**4-1);
(D1)        (X - 1) (X + 1) (X + %I) (X - %I)

&GFACTORSUM(exp) is similar to FACTORSUM but applies GFACTOR instead
of FACTOR.

&GLOBALSOLVE default: [FALSE] if set to TRUE then variables which are
SOLVEd for will be set to the solution of the set of simultaneous
equations.

&GLOG - This function has been removed.  The LOG function should be
used instead.  (Do DESCRIBE(LOG);)  If you have a SAVEd file with
expressions in it containing GLOG, you want to substitute LOG for
GLOG, or contact ELLEN or JPG for assistance.

&GO(tag) is used within a BLOCK to transfer control to the statement
of the block which is tagged with the argument to GO.  To tag a
statement, precede it by an atomic argument as another statement in
the BLOCK.  For example: BLOCK([X],X:1,LOOP,X+1,...,GO(LOOP),...).
The argument to GO must be the name of a tag appearing in the same
BLOCK.  One cannot use GO to transfer to tag in a BLOCK other than the
one containing the GO.

&GRADEF(f(x1, ..., xn), g1, ..., gn) defines the derivatives of the
function f with respect to its n arguments.  That is, df/dxi = gi,
etc.  If fewer than n gradients, say i, are given, then they refer to
the first i arguments of f.  The xi are merely dummy variables as in
function definition headers and are used to indicate the ith argument
of f.  All arguments to GRADEF except the first are evaluated so that
if g is a defined function then it is invoked and the result is used.
Gradients are needed when, for example, a function is not known
explicitly but its first derivatives are and it is desired to obtain
higher order derivatives.  GRADEF may also be used to redefine the
derivatives of MACSYMA's predefined functions (e.g.
GRADEF(SIN(X),SQRT(1-SIN(X)**2)) ).  It is not permissible to use
GRADEF on subscripted functions.

GRADEFS is a list of the functions which have been given gradients by
use of the GRADEF command (i.e. GRADEF(f(x1, ..., xn), g1, ..., gn)).
PRINTPROPS([f1,f2,...],GRADEF) may be used to display the gradefs of
the functions f1,f2,..

GRADEF(a,v,exp) may be used to state that the derivative of the atomic
variable a with respect to v is exp.  This automatically does a
DEPENDS(a,v).

PRINTPROPS([a1,a2,...],ATOMGRAD) may be used to display the atomic
gradient properties of a1,a2,...

&GRADEFS default: [] - a list of the functions which have been given
gradients by use of the GRADEF command (i.e. GRADEF(f(x1, ..., xn),
g1, ..., gn).)

&GRAMSCHMIDT(X) - a function in the EIGEN package.  Do LOAD(EIGEN) to
use it.  GRAMSCHMIDT takes a LIST of lists the sublists of which are
of equal length and not necessarily orthogonal (with respect to the
innerproduct defined above) as its argument and returns a similar list
each sublist of which is orthogonal to all others.  (Returned results
may contain integers that are factored.  This is due to the fact that
the MACSYMA function FACTOR is used to simplify each substage of the
Gram-Schmidt algorithm.  This prevents the expressions from getting
very messy and helps to reduce the sizes of the numbers that are
produced along the way.)

&GRAPH(xlist, ylist, xlabel, ylabel) graphs the two lists of data
points, and labels the axes as indicated or omits labels if just the
first two arguments are given.

GRAPH([x1, x2, x3, ..., xn], [y1, y2, y3, ..., yn]) - Graphs the two
sets of data points.

GRAPH([[x1, y1], [x2, y2], ..., [xn, yn]]) - Graphs the points
specified by the list of coordinate pairs.

GRAPH(xset, [yset1, yset2,..., ysetn],optional-args) - allows graphing
of one x-domain with several y- ranges; e.g.
GRAPH([0,1],[[0,1],[1,2]],["&"]).

&GRAPH2(x-lists,y-lists,optional-args) plots points specified by the
first x-lists and y-lists.

The format for x-lists can be one of
  i) [x-pt1,x-pt2, .. ,x-pti, .. ,x-ptn] where x-pti evaluates to a
number
  ii) arrayname where arrayname is the name of a declared
one-dimensional array of floating point numbers
  iii) 2d-arrayname where 2d-arrayname is the name of a declared
two-dimensional array of floating point numbers (i.e. by
ARRAY(2d-arrayname, FLOAT, max-row-index,max-col-index);)
  iv) [x-list1,x-list2, .. ,x-listi, .. ,x-listk] where x-listi can
have the form of either i) or ii).

The format of y-lists is similar.  The format of optional-args is the
same as for PLOT2.

(Note that GRAPH2 is more similar to the MACSYMA function MULTIGRAPH 
than to GRAPH.)

&GRAPH3D(x-lists,y-lists,z-lists,optional-args) takes 3 arguments
(GRAPH2 takes 2) and interprets them as lists of x, y, and z points
which it uses to draw lines using the 3d transformations.  It can be
used to add lines (e.g.  axes) to your 3D plot.  The hidden line
routines are not used.

&GRIND(arg) prints out arg in a more readable format than the STRING
command.  It returns DONE as its value.

The GRIND switch, default: [FALSE], if TRUE will cause the STRING,
STRINGOUT, and PLAYBACK commands to use "grind" mode instead of
"string" mode.  For PLAYBACK, "grind" mode can also be turned on (for
processing input lines) by specifying GRIND as an option.

&HACH(a,b,m,n,l) - An implementation of Hacijan's linear programming
algorithm is available by doing BATCH(KACH,>,SHARE1)$.  Details of use
are available by doing BATCH(KACH,DEMO,SHARE1);

&HACIJAN - An implementation of Hacijan's linear programming algorithm
is available by doing BATCH(KACH,>,SHARE1)$.  Details of use are
available by doing BATCH(KACH,DEMO,SHARE1);

&HALFANGLES default: [FALSE] - if TRUE causes half-angles to be
simplified away.

&HELP - For introductory help with MACSYMA you may try the on-line
Primer, which is an interactive tutorial.  Type  :TEACHMACSYMA<cr>
at DDT level or PRIMER(); from in MACSYMA.

For HELP with MACSYMA the DESCRIBE command is useful.  DESCRIBE();
will tell you how to use it, or to find out about a specific MACSYMA
command, do DESCRIBE(command);

To request help on-line from someone in the Mathlab group, see
DESCRIBE(SEND);

To order documentation, you should write to
        MACSYMA Group
        Symbolics, Inc.
        257 Vassar Street
        Cambridge, MA 02139
Request "The MACSYMA Reference Manual".  The current version is
version 10, second printing December 1983.  The manual costs $40.00,
plus $3.00 for shipping and handling, which should be included with
the request.

&HIPOW(exp, v) the highest explicit exponent of v in exp.  Sometimes
it may be necessary to expand exp since this is not done automatically
by HIPOW.  Thus HIPOW(Y**3*X**2+X*Y**4,X) is 2.

&HORNER(exp, var) will convert exp into a rearranged representation as
in Horner's rule, using var as the main variable if it is specified.
Var may also be omitted in which case the main variable of the CRE
form of exp is used.  HORNER sometimes improves stability if expr is
to be numerically evaluated.  It is also useful if MACSYMA is used to
generate programs to be run in FORTRAN (see DESCRIBE(STRINGOUT);)

(C1) 1.0E-20*X^2-5.5*X+5.2E20;
                                2
(D1)                   1.0E-20 X  - 5.5 X + 5.2E+20

(C2) HORNER(%,X),KEEPFLOAT:TRUE;
(D2)                  X (1.0E-20 X - 5.5) + 5.2E+20

(C3) D1,X=1.0E20;
ARITHMETIC OVERFLOW

(C4) D2,X=1.0E20;
(D4)                          6.9999999E+19

&HYPERGEOMETRIC - Do DESCRIBE(SPECINT); .
&HYPERGEOMETRIC_FUNCTIONS - Do DESCRIBE(SPECINT); .
&HYPGEO - See DESCRIBE(SPECINT); .
&IBASE default: [10] - the base for inputting numbers.

&IC1(exp,var,var) In order to solve initial value problems (IVPs) and
boundary value problems (BVPs), the routine IC1 is available in the
ODE2 package for first order equations, and IC2 and BC2 for second
order IVPs and BVPs, respectively.  Do LOAD(ODE2) to access these.
They are used as in the following examples:

(C1) X^2*'DIFF(Y,X) + 3*X*Y = SIN(X)/X;
                         2 dY           SIN(X)
(D1)                    X  -- + 3 X Y = ------
                           dX             X
(C2) ODE2(%,Y,X);
                                %C - COS(X)
(D2)                        Y = -----------
                                     3
                                    X
(C3) IC1(D2,X=%PI,Y=0);
                         COS(X) + 1
(D3)               Y = - ----------
                              3
                             X

(C4) 'DIFF(Y,X,2) + Y*'DIFF(Y,X)^3 = 0;
                       2
                      d Y      dY 3
(D4)                  --- + Y (--)  = 0
                        2      dX
                      dX

(C5) ODE2(%,Y,X);
                 3
                Y  - 6 %K1 Y - 6 X
(D7)            ------------------ = %K2
                        3

(C8) RATSIMP(IC2(D7,X=0,Y=0,'DIFF(Y,X)=2));
                     3
                  2 Y  - 3 Y + 6 X
(D9)            - ---------------- = 0
                         3

(C10) BC2(D7,X=0,Y=1,X=1,Y=3);
                 3
                Y  - 10 Y - 6 X
(D11)           --------------- = - 3
                       3

In order to see more clearly which methods have been implemented, a
demonstration file is available.  To run it, you may do
DEMO(ODE2,DEMO,DSK,SHARE);.

&IC2 - do DESCRIBE(IC1);.
&BC2 - do DESCRIBE(IC1);.

&IDENT(n) produces an n by n identity matrix.

&IEQN(ie,unk,tech,n,guess) - Integral Equation solving routine.  Do
LOAD(INTEQN); to access it.  CAVEAT: To free some storage, a
KILL(LABELS) is included in this file.  Therefore, before loading the
integral equation package, the user should give names to any
expressions he wants to keep.

ie is the integral equation; unk is the unknown function; tech is the
technique to be tried from those given above (tech = FIRST means: try
the first technique which finds a solution; tech = ALL means: try all
applicable techniques); n is the maximum number of terms to take for
TAYLOR, NEUMANN, FIRSTKINDSERIES, or FREDSERIES (it is also the
maximum depth of recursion for the differentiation method); guess is
the initial guess for NEUMANN or FIRSTKINDSERIES.

Default values for the 2nd thru 5th parameters are:
unk: P(X), where P is the first function encountered in an integrand
which is unknown to MACSYMA and X is the variable which occurs as an
argument to the first occurrence of P found outside of an integral in
the case of SECONDKIND equations, or is the only other variable
besides the variable of integration in FIRSTKIND equations.  If the
attempt to search for X fails, the user will be asked to supply the
independent variable;
tech: FIRST;
n: 1;
guess: NONE, which will cause NEUMANN and FIRSTKINDSERIES to use F(X)
as an initial guess.

&IEQNPRINT default: [TRUE] - governs the behavior of the result
returned by the IEQN command (which see).  If IEQNPRINT is set to
FALSE, the lists returned by the IEQN function are of the form

   [SOLUTION, TECHNIQUE USED, NTERMS, FLAG]

where FLAG is absent if the solution is exact.  Otherwise, it is the
word APPROXIMATE or INCOMPLETE corresponding to an inexact or
non-closed form solution, respectively. If a series method was used,
NTERMS gives the number of terms taken (which could be less than the n
given to IEQN if an error prevented generation of further terms).

&IF - The IF statement is used for conditional execution.  The syntax
is:
    IF condition THEN expression1 ELSE expression2.

The result of an IF statement is expression1 if condition is true and
expression2 if it is false.  expression1 and expression2 are any
MACSYMA expressions (including nested IF statements), and condition is
an expression which evaluates to TRUE or FALSE and is composed of
relational and logical operators which are as follows:

Operator name       Symbol      Type

greater than        >           relational infix
equal to            = , EQUAL   "  "
not equal to        #           "  "
less than           <           "  "
greater than        >=
  or equal to                   "  "
less than           <=
  or equal to                   "  "
and                 AND         logical infix
or                  OR          "  "
not                 NOT         logical prefix

&IFT(real-array, imag-array) - Inverse Fourier Transform.  Do
LOAD(FFT); to load in this package.  These functions (FFT and IFT)
perform a (complex) fast fourier transform on either 1 or 2
dimensional FLOATING-POINT arrays, obtained by:
ARRAY(<ary>,FLOAT,<dim1>); or ARRAY(<ary>,FLOAT,<dim1>,<dim2>); For 1D
arrays <dim1> must equal 2^n-1, and for 2D arrays <dim1>=<dim2>=2^n-1
(i.e. the array is square).  (Recall that MACSYMA arrays are indexed
from a 0 origin so that there will be 2^n and (2^n)^2 arrays elements
in the above two cases.)  For details on the implementation, do
PRINTFILE(FFT,USAGE,SHARE); .

&ILT(exp, lvar, ovar) takes the inverse Laplace transform of exp with
respect to lvar and parameter ovar.  exp must be a ratio of
polynomials whose denominator has only linear and quadratic factors.
By using the functions LAPLACE and ILT together with the SOLVE or
LINSOLVE functions the user can solve a single differential or
convolution integral equation or a set of them.

(C1) 'INTEGRATE(SINH(A*X)*F(T-X),X,0,T)+B*F(T)=T**2;

              T
             /
             [                                     2
(D1)         I (SINH(A X) F(T - X)) dX + B F(T) = T
             ]
             /
             0

(C2) LAPLACE(%,T,S);

            A LAPLACE(F(T), T, S)
(D2)        ---------------------
                    2    2
                   S  - A

                                          2
                + B LAPLACE(F(T), T, S) = --
                                           3
                                          S

(C3) LINSOLVE([%],['LAPLACE(F(T),T,S)]);
SOLUTION

                                        2      2
                                     2 S  - 2 A
(E3)       LAPLACE(F(T), T, S) = --------------------
                                    5         2     3
                                 B S  + (A - A  B) S

(D3)                         [E3]

(C4) ILT(E3,S,T);

IS  A B (A B - 1)  POSITIVE, NEGATIVE, OR ZERO?
POS;

                                       2
                       SQRT(A) SQRT(A B  - B) T
                2 COSH(------------------------)
                                  B
(D4)  F(T) =  - --------------------------------
                               A

              2
           A T             2
        + ------- + ------------------
          A B - 1    3  2      2
                    A  B  - 2 A  B + A

&IMAGPART(exp) returns the imaginary part of the expression exp.

&IMSL - For information on MACSYMA-IMSL packages available do:
PRINTFILE(IMSL,USAGE,SHARE2); IMSL-based routines currently return
[SUCCESS, ...] or [ERROR, ...].  They will soon be changed to return
[SUCCESS, ...], [WARNING, ...] and [ERROR, ...].

&INCHAR default: [C] - the alphabetic prefix of the names of
expressions typed by the user.

&INRT(X,n) - takes two integer arguments, X and n, and returns the
integer nth root of the absolute value of X.

&INDEX_FILE_DIM,symbol-returned-by-OPEN_INDEX_FILE) - returns an
integer indicating the number of expressions in the indexed file.
See DESCRIBE(OPEN_INDEX_FILE);.

&INDICES(exp) returns a list of two elements.  The first is a list of
the free indices in exp (those that occur only once); the second is
the list of dummy indices in exp (those that occur exactly twice).

&INEQUALITIES - See INEQUALITY.
&INEQUALITY - MACSYMA has the usual inequality operators:
less than:  <
greater than:  >
greater than or equal to:  >=
less than or equal to:  <=

&INF - real positive infinity.

&INFEVAL leads to an "infinite evaluation" mode.  EV repeatedly
evaluates an expression until it stops changing.  To prevent a
variable, say X, from being evaluated away in this mode, simply
include X='X as an argument to EV.  Of course expressions such as
EV(X,X=X+1,INFEVAL); will generate an infinite loop.  CAVEAT
EVALUATOR.

&INFINITY - complex infinity, an infinite magnitude of arbitrary phase
angle.  (See also INF and MINF.)

&INFIX - INFIX operators are used to denote functions of two
arguments, one given before the operator and one after, e.g. A^2 .
The INFIX("x") function is a syntax extention function to declare x to
be an INFIX operator.  Do DESCRIBE(SYNTAX); for more details.

&INFLAG default: [FALSE] if set to TRUE, the functions for part
extraction will look at the internal form of exp.  Note that the
simplifier re-orders expressions.  Thus FIRST(X+Y) will be X if INFLAG
is TRUE and Y if INFLAG is FALSE.  (FIRST(Y+X) gives the same
results).  Also, setting INFLAG to TRUE and calling PART/SUBSTPART is
the same as calling INPART/SUBSTINPART.  Functions affected by the
setting of INFLAG are: PART, SUBSTPART, FIRST, REST, LAST, LENGTH, the
FOR ... IN construct, MAP, FULLMAP, MAPLIST, REVEAL, ARGS and
PICKAPART.

&INFO - A program on the ITS machines which has information about
system utilities.  Type :INFO<carriage return> at DDT level and then
type H (for "help") to learn how to use this program.  The "MACSYMA"
node has a short introduction to get people started on MACSYMA.

&INFOLISTS default: [] a list of the names of all of the information
lists in MACSYMA. These are:

LABELS - all bound C,D, and E labels.

VALUES - all bound atoms, i.e. user variables, not MACSYMA
Options or Switches, (set up by : , :: , or functional binding).

FUNCTIONS - all user defined functions (set up by f(x):=...).

ARRAYS - declared and undeclared arrays (set up by : , :: , or :=...)

MACROS - any Macros defined by the user.

MYOPTIONS - all options ever reset by the user (whether or not they
get reset to their default value).

RULES - user defined pattern matching and simplification rules (set up
by TELLSIMP, TELLSIMPAFTER, DEFMATCH, or, DEFRULE.)

ALIASES - atoms which have a user defined alias (set up by the ALIAS,
ORDERGREAT, ORDERLESS functions or by DECLAREing the atom a NOUN).

DEPENDENCIES - atoms which have functional dependencies (set up by the
DEPENDS or GRADEF functions).

GRADEFS - functions which have user defined derivatives (set up by the
GRADEF function).

PROPS - atoms which have any property other than those mentioned
above, such as atvalues, matchdeclares, etc.  as well as properties
specified in the DECLARE function.

LET_RULE_PACKAGES - a list of all the user-defined let rule packages
plus the special package DEFAULT_LET_RULE_PACKAGE.
(DEFAULT_LET_RULE_PACKAGE is the name of the rule package used when
one is not explicitly set by the user.)

&INIT - A file which is loaded automatically for you when you start up
a MACSYMA, to customize MACSYMA for you.  It is possible to have an
init file written as a BATCH file of macsyma commands.  We hope this
makes it easier for users to customize their macsyma environment.
Here is an example init file

        /*-*-macsyma-*-*/ 
        setup_autoload("share\;bessel",j0,j1,jn);
        showtime:all; comgrind:true;

The strange looking comment at the top of the file "/*-*-macsyma-*-*/"
tells that it is a macsyma-language file. 

Also: "SETUP_AUTOLOAD" can be used to make functions in BATCH files
autoloading, meaning that you can then use (for instance, here) the
functions J0, J1 and Jn from the BESSEL package directly because when
you use the function the BESSEL package will be loaded in for you
automatically.  If the second file name in the argument to
SETUP_AUTOLOAD is not specified (the preferred usage) then the
standard search for second file names of "FASL", "TRLISP", and ">" is
done.

&INNERPRODUCT(X,Y) - a function in the EIGEN package.  Do LOAD(EIGEN)
to use it.  INNERPRODUCT takes two LISTS of equal length as its
arguments and returns their inner (scalar) product defined by (Complex
Conjugate of X).Y (The "dot" operation is the same as the usual one
defined for vectors).

&INPART(exp, n1, ..., nk) is similar to PART but works on the internal
representation of the expression rather than the displayed form and
thus may be faster since no formatting is done.  Care should be taken
with respect to the order of subexpressions in sums and products
(since the order of variables in the internal form is often different
from that in the displayed form) and in dealing with unary minus,
subtraction, and division (since these operators are removed from the
expression). PART(X+Y,0) or INPART(X+Y,0) yield +, though in order to
refer to the operator it must be enclosed in "s.  For example
...IF INPART(D9,0)="+" THEN ...

(C1)  X+Y+W*Z;

(D1)                  W Z + Y + X

(C2)  INPART(D1,3,2);

(D2)                  Z
(C3)  PART(D1,1,2);

(D3)                  Z

(C4) 'LIMIT(F(X)**G(X+1),X,0,MINUS);
                                      G(X + 1)
(D4)                      LIMIT   F(X)
                          X ->0-

(C5) INPART(%,1,2);
(D5)                            G(X + 1)

&INTEGERP(exp) is TRUE if exp is an integer else FALSE.

&INTEGRALS - MACSYMA has several routines for handling integration.
The INTEGRATE command makes use of most of them.  There is also the
ANTID package, which handles an unspecified function (and its
derivatives, of course).  For numerical uses, there is the ROMBERG
function, and the IMSL version of Romberg, DCADRE.  There is also an
adaptave integrator which uses the Newton-Cotes 8 panel quadrature
rule, called QUANC8.  Hypergeometric Functions are being worked on,
do DESCRIBE(SPECINT); for details.

Generally speaking, MACSYMA only handles integrals which are
integrable in terms of the "elementary functions" (rational functions,
trigonometrics, logs, exponentials, radicals, etc.) and a few
extensions (error function, dilogarithm).  It does not handle
integrals in terms of unknown functions such as g(x) and h(x).

&INTEGRATE(exp, var) integrates exp with respect to var or returns an
integral expression (the noun form) if it cannot perform the
integration (see note 1 below).  Roughly speaking three stages are
used:

    (1) INTEGRATE sees if the integrand is of the form
F(G(X))*DIFF(G(X),X) by testing whether the derivative of some
subexpression (i.e. G(X) in the above case) divides the integrand.  If
so it looks up F in a table of integrals and substitutes G(X) for X in
the integral of F.  This may make use of gradients in taking the
derivative.  (If an unknown function appears in the integrand it must
be eliminated in this stage or else INTEGRATE will return the noun
form of the integrand.)

    (2) INTEGRATE tries to match the integrand to a form for which a
specific method can be used, e.g.  trigonometric substitutions.

    (3) If the first two stages fail it uses the Risch algorithm.

    Functional relationships must be explicitly represented in order
for INTEGRATE to work properly.  INTEGRATE is not affected by
DEPENDENCIES set up with the DEPENDS command.

INTEGRATE(exp, var, low, high) finds the definite integral of exp with
respect to var from low to high or returns the noun form if it cannot
perform the integration.  The limits should not contain var.  Several
methods are used, including direct substitution in the indefinite
integral and contour integration.  Improper integrals may use the
names INF for positive infinity and MINF for negative infinity.  If an
integral "form" is desired for manipulation (for example, an integral
which cannot be computed until some numbers are substituted for some
parameters), the noun form 'INTEGRATE may be used and this will
display with an integral sign.  (See Note 1 below.)

    The function LDEFINT uses LIMIT to evaluate the integral at the
lower and upper limits.

    Sometimes during integration the user may be asked what the sign
of an expression is.  Suitable responses are POS;, ZERO;, or NEG;.

(C1) INTEGRATE(SIN(X)**3,X);

                    3
                 COS (X)
(D1)             ------- - COS(X)
                    3

(C2) INTEGRATE(X**A/(X+1)**(5/2),X,0,INF);
IS  A + 1  POSITIVE, NEGATIVE, OR ZERO?

POS;
IS  2 A - 3  POSITIVE, NEGATIVE, OR ZERO?

NEG;
                            3
(D2)            BETA(A + 1, - - A)
                            2

(C3) GRADEF(Q(X),SIN(X**2));
(D3)                              Q(X)

(C4) DIFF(LOG(Q(R(X))),X);

                           d             2
                          (-- R(X)) SIN(R (X))
                           dX
(D4)                      --------------------
                                Q(R(X))

(C5) INTEGRATE(%,X);
(D5)                          LOG(Q(R(X)))

Note 1) The fact that MACSYMA does not perform certain integrals does
not always imply that the integral does not exist in closed form. In
the example below the integration call returns the noun form but the
integral can be found fairly easily. For example, one can compute the
roots of X^3+X+1 = 0 to rewrite the integrand in the form
1/((X-A)*(X-B)*(X-C)) where A, B and C are the roots. MACSYMA will
integrate this equivalent form although the integral is quite
complicated.

(C6) INTEGRATE(1/(X^3+X+1),X);

                          /
                          [     1
(D6)                      I ---------- dX
                          ]  3
                          / X  + X + 1

&INTEGRATION - Do DESCRIBE(INTEGRALS);
&INTEGRATION_CONSTANT_COUNTER - a counter which is updated each time a
constant of integration (called by MACSYMA, e.g., "INTEGRATIONCONSTANT1")
is introduced into an expression by indefinite integration of an equation.

&INTERPOLATE(func,x,a,b) finds the zero of func as x varies.  The last
two args give the range to look in.  The function must have a
different sign at each endpoint.  If this condition is not met, the
action of the of the function is governed by INTPOLERROR[TRUE]).  If
INTPOLERROR is TRUE then an error occurs, otherwise the value of
INTPOLERROR is returned (thus for plotting INTPOLERROR might be set to
0.0).  Otherwise (given that MACSYMA can evaluate the first argument
in the specified range, and that it is continuous) INTERPOLATE is
guaranteed to come up with the zero (or one of them if there is more
than one zero).  The accuracy of INTERPOLATE is governed by
INTPOLABS[0.0] and INTPOLREL[0.0] which must be non-negative floating
point numbers.  INTERPOLATE will stop when the first arg evaluates to
something less than or equal to INTPOLABS or if successive
approximants to the root differ by no more than INTPOLREL * <one of
the approximants>.  The default values of INTPOLABS and INTPOLREL are
0.0 so INTERPOLATE gets as good an answer as is possible with the
single precision arithmetic we have.  The first arg may be an
equation.  The order of the last two args is irrelevant.  Thus

INTERPOLATE(SIN(X)=X/2,X,%PI,.1);

is equivalent to

INTERPOLATE(SIN(X)=X/2,X,.1,%PI);

The method used is a binary search in the range specified by the last
two args.  When it thinks the function is close enough to being
linear, it starts using linear interpolation.

An alternative syntax has been added to interpolate, this replaces the
first two arguments by a function name.  The function MUST be
TRANSLATEd or compiled function of one argument.  No checking of the
result is done, so make sure the function returns a floating point
number.

F(X):=(MODE_DECLARE(X,FLOAT),SIN(X)-X/2.0);

INTERPOLATE(SIN(X)-X/2,X,0.1,%PI)       time= 60 msec
INTERPOLATE(F(X),X,0.1,%PI);            time= 68 msec
TRANSLATE(F);
INTERPOLATE(F(X),X,0.1,%PI);            time= 26 msec
INTERPOLATE(F,0.1,%PI);                 time=  5 msec

There is also a Newton method interpolation routine, do DESCRIBE(NEWTON); .

&INTERRUPTS - There are several ways the user can interrupt a MACSYMA
computation, usually with a control character.  Do
DESCRIBE(CHARACTERS); for details.  MACSYMA will also be interrupted
if ^Z (control-Z) is typed, as this will exit back to DDT level
(system monitor level).  If a "SEND" (message sent to your terminal)
is received that will temporarily interrupt the computation, but it
will be resumed immediately, and the message "back to MACSYMA,
computation continuing" will be printed.

&INTFACLIM default: [1000] is the largest divisor which will be tried
when factoring a bignum integer.  If set to FALSE (this is the case
when the user calls FACTOR explicitly), or if the integer is a fixnum
(i.e. fits in one machine word), complete factorization of the integer
will be attempted.  The user's setting of INTFACLIM is used for
internal calls to FACTOR. Thus, INTFACLIM may be reset to prevent
MACSYMA from taking an inordinately long time factoring large
integers.

&INTOPOIS(A) converts A into a Poisson encoding.

&INTOSUM(expr) - will take all things that a summation is multiplied
by, and put them inside the summation. If the index is used in the
outside expression, then the function tries to find a reasonable
index, the same as it does for SUMCONTRACT.  This is essentially the
reverse idea of the OUTATIVE property of summations, but note that it
does not remove this property, it only bypasses it.  In some cases, a
SCANMAP(MULTTHRU,expr) may be necessary before the INTOSUM.

&INTPOLABS default: [0.0] - The accuracy of the INTERPOLATE command is
governed by INTPOLABS[0.0] and INTPOLREL[0.0] which must be
non-negative floating point numbers.  INTERPOLATE will stop when the
first arg evaluates to something less than or equal to INTPOLABS or if
successive approximants to the root differ by no more than INTPOLREL *
<one of the approximants>.  The default values of INTPOLABS and
INTPOLREL are 0.0 so INTERPOLATE gets as good an answer as is possible
with the single precision arithmetic we have.

&INTPOLERROR default: [TRUE] - Governs the behavior of INTERPOLATE.
When INTERPOLATE is called, it determines whether or not the function
to be interpolated satisfies the condition that the values of the
function at the endpoints of the interpolation interval are opposite
in sign.  If they are of opposite sign, the interpolation proceeds.
If they are of like sign, and INTPOLERROR is TRUE, then an error is
signaled.  If they are of like sign and INTPOLERROR is not TRUE, the
value of INTPOLERROR is returned.  Thus for plotting, INTPOLERROR
might be set to 0.0.

&INTPOLREL default: [0.0] - The accuracy of the INTERPOLATE command is
governed by INTPOLABS[0.0] and INTPOLREL[0.0] which must be
non-negative floating point numbers.  INTERPOLATE will stop when the
first arg evaluates to something less than or equal to INTPOLABS or if
successive approximants to the root differ by no more than INTPOLREL *
<one of the approximants>.  The default values of INTPOLABS and
INTPOLREL are 0.0 so INTERPOLATE gets as good an answer as is possible
with the single precision arithmetic we have.

&INTSCE(expr,var) - INTSCE LISP contains a routine, written by Richard
Bogen, for integrating products of sines,cosines and exponentials of
the form

  EXP(A*X+B)*COS(C*X)^N*SIN(C*X)^M

The call is INTSCE(expr,var) expr may be any expression, but if it
is not in the above form then the regular integration program will be
invoked if the switch ERRINTSCE[TRUE] is TRUE.  If it is FALSE then
INTSCE will err out.

&INVERT(matrix) finds the inverse of a matrix using the adjoint
method.  This allows a user to compute the inverse of a matrix with
bfloat entries or polynomials with floating pt. coefficients without
converting to cre-form.  The DETERMINANT command is used to compute
cofactors, so if RATMX is FALSE (the default) the inverse is computed
without changing the representation of the elements.  The current
implementation is inefficient for matrices of high order.

The DETOUT flag if true keeps the determinant factored out of the
inverse.

Note: the results are not automatically expanded.  If the matrix
originally had polynomial entries, better appearing output can be
generated by EXPAND(INVERT(mat)),DETOUT.  If it is desirable to then
divide through by the determinant this can be accomplished by XTHRU(%)
or alternatively from scratch by
EXPAND(ADJOINT(mat))/EXPAND(DETERMINANT(mat)).
INVERT(mat):=ADJOINT(mat)/DETERMINANT(mat).

See also DESCRIBE("^^"); for another method of inverting a matrix.

&IRREDUCIBLE - This command has been removed.

&IS(exp) attempts to determine whether exp (which must evaluate to a
predicate) is provable from the facts in the current data base.  IS
returns TRUE if the predicate is true for all values of its variables
consistent with the data base and returns FALSE if it is false for all
such values.  Otherwise, its action depends on the setting of the
switch PREDERROR (default: TRUE). IS errs out if the value of
PREDERROR is TRUE and returns UNKNOWN if PREDERROR is FALSE.

&ISOLATE(exp, var) returns exp with subexpressions which are sums and
which do not contain var replaced by intermediate expression labels
(these being atomic symbols like E1, E2, ...).  This is often useful
to avoid unnecessary expansion of subexpressions which don't contain
the variable of interest.  Since the intermediate labels are bound to
the subexpressions they can all be substituted back by evaluating the
expression in which they occur.

EXPTISOLATE[FALSE] if TRUE will cause ISOLATE to examine exponents of
atoms (like %E) which contain var.

ISOLATE_WRT_TIMES[FALSE] if TRUE, then ISOLATE will also isolate wrt
products.  E.g. compare both settings of the switch on
ISOLATE(EXPAND((A+B+C)^2),C); .

Do EXAMPLE(ISOLATE); for examples.

&ISOLATE_WRT_TIMES default: [FALSE] - if set to TRUE, then ISOLATE
will also isolate wrt products.  E.g. compare both settings of the
switch on ISOLATE(EXPAND((A+B+C)^2),C); .

&ISQRT(X) - takes one integer argument and returns the "integer SQRT"
of its absolute value.

&ITENSR - Indicial Tensor Manipulation package.  It may be loaded by
LOADFILE(ITENSR,FASL,SHARE); A manual for the Tensor packages is
available in SHARE;TENSOR DESCR.  A demo is available by
DEMO(ITENSO,DEMO1,TENSOR); (and additional demos are in
(ITENSO,DEMO2,TENSOR), (ITENSO,DEMO3,TENSOR) and following).

&ITERATION - MACSYMA provides a DO loop for iteration, do DESCRIBE("DO");
for more information.

&ITS - The operating system under which MACSYMA runs on the MIT-MC
machine.  It stands for "Incompatible Timesharing System".

&JACOBI(p,q) is the Jacobi symbol of p and q.

&KDELTA(L1,L2) is the generalized Kronecker delta function defined in
the Tensor package with L1 the list of covariant indices and L2 the
list of contravariant indices.  KDELTA([i],[j]) returns the ordinary
Kronecker delta.  The command EV(EXP,KDELTA) causes the evaluation of
an expression containing KDELTA([],[]) to the dimension of the
manifold.

&KEEPFLOAT default: [FALSE] - if set to TRUE will prevent floating
point numbers from being rationalized when expressions which contain
them are converted to CRE form.

&KILL(arg1, arg2, ...)  eliminates its arguments from the MACSYMA
system.  If argi is a variable (including a single array element),
function, or array, the designated item with all of its properties is
removed from core.  If argi=LABELS then all input, intermediate, and
output lines to date (but not other named items) are eliminated. If
argi=CLABELS then only input lines will be eliminated; if argi=ELABELS
then only intermediate E-lines will be eliminated; if argi=DLABELS
only the output lines will be eliminated.  If argi is the name of any
of the other information lists (the elements of the MACSYMA variable
INFOLISTS), then every item in that class (and its properties) is
KILLed and if argi=ALL then every item on every information list
previously defined as well as LABELS is KILLed.  If argi=a number (say
n), then the last n lines (i.e. the lines with the last n line
numbers) are deleted.  If argi is of the form [m,n] then all lines
with numbers between m and n inclusive are killed. Note that
KILL(VALUES) or KILL(variable) will not free the storage occupied
unless the labels which are pointing to the same expressions are also
KILLed.  Thus if a large expression was assigned to X on line C7 one
should do KILL(D7) as well as KILL(X) to release the storage occupied.

KILL(ALLBUT(name1,...,namek) will do a KILL(ALL) except it will not
KILL the names specified.  (Note: namei means a name such as U, V, F,
G, not an infolist such as FUNCTIONS.)

    KILL removes all properties from the given argument thus
KILL(VALUES) will kill all properties associated with every item on
the VALUES list whereas the REMOVE set of functions
(REMVALUE,REMFUNCTION,REMARRAY,REMRULE) remove a specific property.
Also the latter print out a list of names or FALSE if the specific
argument doesn't exist whereas KILL always has value "DONE" even if
the named item doesn't exist.

    Note that killing expressions will not help the problem which
occurs on MC indicated by "NO CORE - FASLOAD" which results when
either too many FASL files have been loaded in or when allocation
level has gotten too high.  In either of these cases, no amount of
killing will cause the size of these spaces to decrease.  Killing
expressions only causes some spaces to get emptied out but not made
smaller.

&KILLCONTEXT(context1,context2,...,contextn) kills the specified
contexts.  If one of them is the current context, the new current
context will become the first available subcontext of the current
context which has not been killed.  If the first available unkilled
context is GLOBAL then INITIAL is used instead.  If the INITIAL
context is killed, a new INITIAL is created, which is empty of facts.
KILLCONTEXT doesn't allow the user to kill a context which is
currently active, either because it is a subcontext of the current
context, or by use of the function ACTIVATE.

&LABELS(char) takes a char C,D,or E as arg and generates a list of all
C-labels,D-labels, or E- labels, respectively.  (If you've generated
many E- labels via SOLVE, then FIRST(REST(LABELS(C))); reminds you
what the last C-label was.)

LABELS will take as arg any symbolic name, so if you have reset INCHAR,
OUTCHAR, or LINECHAR, it will return the list of labels whose first
character matches the first character of the arg you give to LABELS.

The variable, LABELS, default: [], is a list of C, D, and E lines
which are bound.

&LAPLACE(exp, ovar, lvar) takes the Laplace transform of exp with
respect to the variable ovar and transform parameter lvar.  Exp may
only involve the functions EXP, LOG, SIN, COS, SINH, COSH, and ERF.
It may also be a linear, constant coefficient differential equation in
which case ATVALUE of the dependent variable will be used.  These may
be supplied either before or after the transform is taken.  Since the
initial conditions must be specified at zero, if one has boundary
conditions imposed elsewhere he can impose these on the general
solution and eliminate the constants by solving the general solution
for them and substituting their values back. Exp may also involve
convolution integrals.  Functional relationships must be explicitly
represented in order for LAPLACE to work properly. That is, if F
depends on X and Y it must be written as F(X,Y) wherever F occurs as
in LAPLACE('DIFF(F(X,Y),X),X,S).  LAPLACE is not affected by DEPENDENCIES
set up with the DEPENDS command.

(C1) LAPLACE(%E**(2*T+A)*SIN(T)*T,T,S);

                     A
                 2 %E  (S - 2)
(D1)            ---------------
                        2     2
                ((S - 2)  + 1)

&LASSOCIATIVE - If DECLARE(G,LASSOCIATIVE); is done, this tells the
simplifier that G is left-associative.  E.g.  G(G(A,B),G(C,D)) will
simplify to G(G(G(A,B),C),D).

&LAST(exp) yields the last part (term, row, element, etc.) of the exp.
LAST is affected by the setting of INFLAG, do DESCRIBE(INFLAG) for
details.

&LASTTIME - the time to compute the last expression in milliseconds
presented as a list of "time" and "gctime".

&LC(L) is the permutation (or Levi-Civita) tensor which yields 1 if
the list L consists of an even permutation of integers, -1 if it
consists of an odd permutation, and 0 if some indices in L are
repeated.

&LCM(exp1,exp2,...) returns the Least Common Multiple of its arguments.
Do LOAD(FUNCTS); to access this function.

&LDEFINT(exp,var,ll,ul) yields the definite integral of exp by using
LIMIT to evaluate the indefinite integral of exp with respect to var
at the upper limit ul and at the lower limit ll.

&LDISP(expr1,expr2,...) is like DISP but also generates intermediate
labels.

&LDISPLAY(expr1,expr2,...)  is like DISPLAY but also generates
intermediate labels.

&LENGTH(exp) gives (by default) the number of parts in the external
(displayed) form of exp.  For lists this is the number of elements,
for matrices it is the number of rows, and for sums it is the number
of terms. (See DISPFORM).  The LENGTH command is affected by the
INFLAG switch [default FALSE].  So, e.g. LENGTH(A/(B*C)); gives 2 if
INFLAG is FALSE (Assuming EXPTDISPFLAG is TRUE), but 3 if INFLAG is
TRUE (the internal representation is essentially A*B^-1*C^-1).

&LET(prod, repl, predname, arg1, arg2, ..., argn) defines a
substitution rule for LETSIMP such that prod gets replaced by repl.
prod is a product of positive or negative powers of the following
types of terms:

    (1) Atoms which LETSIMP will search for literally unless previous
to calling LETSIMP the MATCHDECLARE function is used to associate a
predicate with the atom.  In this case LETSIMP will match the atom to
any term of a product satisfying the predicate.

    (2) Kernels such as SIN(X), N!, F(X,Y), etc.  As with atoms above
LETSIMP will look for a literal match unless MATCHDECLARE is used to
associate a predicate with the argument of the kernel.

A term to a positive power will only match a term having at least that
power in the expression being LETSIMPed.  A term to a negative power
on the other hand will only match a term with a power at least as
negative.  In the case of negative powers in "product" the switch
LETRAT must be set to TRUE (see below).

If a predicate is included in the LET function followed by a list of
arguments, a tentative match (i.e. one that would be accepted if the
predicate were omitted) will be accepted only if
predname(arg1',...,argn') evaluates to TRUE where argi' is the value
matched to argi.  The argi may be the name of any atom or the argument
of any kernel appearing in prod.  repl may be any rational expression.
If any of the atoms or arguments from prod appear in repl the
appropriate substitutions will be made.

    LETRAT[FALSE] when FALSE, LETSIMP will simplify the numerator and
denominator of expr independently and return the result.
Substitutions such as N!/N goes to (N-1)!  will fail.  To handle such
situations LETRAT should be set to TRUE, then the numerator,
denominator, and their quotient will be simplified in that order.

    These substitution functions allow you to work with several
rulepackages at once. Each rulepackage can contain any number of LETed
rules and is referred to by a user supplied name.  To insert a rule
into the rulepackage name, do LET([prod,repl,pred,arg1,...],name).  To
apply the rules in rulepackage name, do LETSIMP(expr, name).  The
function LETSIMP(expr,name1,name2,...)  is equivalent to doing
LETSIMP(expr,name1) followed by LETSIMP(%,name2) etc.

CURRENT_LET_RULE_PACKAGE is the name of the rule package that is
presently being used.  The user may reset this variable to the name of
any rule package previously defined via the LET command.  Whenever any
of the functions comprising the let package are called with no package
name the value of CURRENT_LET_RULE_PACKAGE is used.  If a call such as
LETSIMP(expr,rule_pkg_name); is made, the rule package rule_pkg_name
is used for that LETSIMP command only, i.e.  the value of
CURRENT_LET_RULE_PACKAGE is not changed.

There is a DEFAULT_LET_RULE_PACKAGE which is assumed when no other
name is supplied to any of the functions.  Whenever a LET includes a
rulepackage name that is used as the CURRENT_LET_RULE_PACKAGE.

&LET_RULE_PACKAGES default:[DEFAULT_LET_RULE_PACKAGE] - The value of
LET_RULE_PACKAGES is a list of all the user-defined let rule packages
plus the special package DEFAULT_LET_RULE_PACKAGE.
DEFAULT_LET_RULE_PACKAGE is the name of the rule package used when one
is not explicitly set by the user.

&LETRAT default: [FALSE] - when FALSE, LETSIMP will simplify the
numerator and denominator of expr independently and return the result.
Substitutions such as N!/N goes to (N-1)! will fail.  To handle such
situations LETRAT should be set to TRUE, then the numerator,
denominator, and their quotient will be simplified in that order.

&LETRULES() displays the rules in the current rulepackage (initially
DEFAULT_LET_RULE_PACKAGE).  LETRULES(name) displays the rules in the
named rulepackage.  The current rulepackage is the value of
CURRENT_LET_RULE_PACKAGE.

&LETSIMP(exp) will continually apply the substitution rules previously
defined by the function LET until no further change is made to exp.
LETSIMP(expr,rule_pkg_name); will cause the rule package rule_pkg_name
to be used for that LETSIMP command only, i.e.  the value of
CURRENT_LET_RULE_PACKAGE is not changed.

&LHOSPITALLIM default: [4] - the maximum number of times L'Hospital's
rule is used in LIMIT.  This prevents infinite looping in cases like
LIMIT(COT(X)/CSC(X),X,0).

&LHS(eqn) the left side of the equation eqn.  If eqn is not an equation,
LHS(exp) returns exp.

&LI - This is the notation MACSYMA uses for Polylogarithms and
Dilogarithms.  See POLYLOGARITHMS.

&LIMIT(exp, var, val, dir) finds the limit of exp as the real variable
var approaches the value val from the direction dir.  Dir may have the
value PLUS for a limit from above, MINUS for a limit from below, or
may be omitted (implying a two-sided limit is to be computed).  For
the method see Wang, P., "Evaluation of Definite Integrals by Symbolic
Manipulation" - Ph.D. Thesis - MAC TR-92 October 1971.  LIMIT uses the
following special symbols: INF (positive infinity) and MINF (negative
infinity).  On output it may also use UND (undefined), IND (indefinite
but bounded) and INFINITY (complex infinity).

LHOSPITALLIM[4] is the maximum number of times L'Hospital's rule
is used in LIMIT.  This prevents infinite looping in cases like
LIMIT(COT(X)/CSC(X),X,0).

TLIMSWITCH[FALSE] when true will cause the limit package to use
Taylor series when possible.

LIMSUBST[FALSE] prevents LIMIT from attempting substitutions on
unknown forms.  This is to avoid bugs like LIMIT(F(N)/F(N+1),N,INF);
giving 1.  Setting LIMSUBST to TRUE will allow such substitutions.

Since LIMIT is often called upon to simplify constant expressions,
for example, INF-1, LIMIT may be used in such cases with only one
argument, e.g. LIMIT(INF-1);

Do EXAMPLE(LIMIT); for examples.

&LINEAR - One of MACSYMA's OPPROPERTIES.  For univariate f so
declared, "expansion" F(X+Y) -> F(X)+F(Y), F(A*X) -> A*F(X) takes
place where A is a "constant".  For functions F of >=2 args,
"linearity" is defined to be as in the case of 'SUM or 'INTEGRATE,
i.e. F(A*X+B,X) -> A*F(X,X)+B*F(1,X) for A,B FREEOF X.  (LINEAR is
just ADDITIVE + OUTATIVE.)

&LINECHAR default: [E] - the alphabetic prefix of the names of
intermediate displayed expressions.

&LINEDISP default: [TRUE] - Allows the use of line graphics in the
drawing of equations on those systems which support them (e.g. the
Lisp Machine).  This can be disabled by setting LINEDISP to FALSE.  It
is automatically disabled during WRITEFILE.

&LINEL default: [] - the number of characters which are printed on a
line. It is initially set by MACSYMA to the line length of the type of
terminal being used (as far as is known) but may be reset at any time
by the user.  The user may have to reset it in DDT with :TCTYP as
well.

&LINENUM - the line number of the last expression.

&LINSOLVE([exp1, exp2, ...], [var1, var2, ...]) solves the list of
simultaneous linear equations for the list of variables.  The expi
must each be polynomials in the variables and may be equations.

If GLOBALSOLVE[FALSE] is set to TRUE then variables which are SOLVEd
for will be set to the solution of the set of simultaneous equations.

BACKSUBST[TRUE] if set to FALSE will prevent back substitution after
the equations have been triangularized.  This may be necessary in very
big problems where back substitution would cause the generation of
extremely large expressions.  (On MC this could cause the storage
capacity to be exceeded.)

LINSOLVE_PARAMS[TRUE] If TRUE, LINSOLVE also generates the %Ri symbols
used to represent arbitrary parameters described in the manual under
ALGSYS.  If FALSE, LINSOLVE behaves as before, i.e. when it meets up
with an under-determined system of equations, it solves for some of
the variables in terms of others.

(C1) X+Z=Y$

(C2) 2*A*X-Y=2*A**2$

(C3) Y-2*Z=2$

(C4) LINSOLVE([D1,D2,D3],[X,Y,Z]),GLOBALSOLVE:TRUE;
SOLUTION

(E4)                            X : A + 1

(E5)                             Y : 2 A

(E6)                            Z : A - 1

(D6)                          [E4, E5, E6]

&LINSOLVE_PARAMS default: [TRUE] - If TRUE, LINSOLVE also generates
the %Ri symbols used to represent arbitrary parameters described in
the manual under ALGSYS.  If FALSE, LINSOLVE behaves as before, i.e.
when it meets up with an under-determined system of equations, it
solves for some of the variables in terms of others.

&LINSOLVEWARN default: [TRUE] - if FALSE will cause the message
"Dependent equations eliminated" to be suppressed.

&LISPDEBUGMODE() - LISPDEBUGMODE(); DEBUGPRINTMODE(); and DEBUG();
make available to the user debugging features used by systems
programmers.  These tools are powerful, and although some conventions
are different from the usual macsyma level it is felt their use is
very intuitive.  [Some printout may be verbose for slow terminals,
there are switches for controlling this.]  These commands were
designed for the user who must debug translated macsyma code, as such
they are a boon.  See MACDOC;TRDEBG USAGE for more information.  For
more help, consult GJC.

&LISTARITH default: [TRUE] - if FALSE causes any arithmetic operations
with lists to be suppressed; when TRUE, list-matrix operations are
contagious causing lists to be converted to matrices yielding a result
which is always a matrix.  However, list-list operations should return
lists.

&LISTARRAY(array) returns a list of the elements of a declared or
hashed array.  the order is row-major.  For declared arrays, elements
which have not been defined will be shown by #####.  For hashed arrays
obviously Macsyma has no notion of undefined elements.  See also
DESCRIBE(ARRAYINFO).

&LISTCONSTVARS default: [FALSE] - if TRUE will cause LISTOFVARS to
include %E, %PI, %I, and any variables declared constant in the list
it returns if they appear in the expression LISTOFVARS is called on.
The default is to omit these.

&LISTDUMMYVARS default: [TRUE] - if FALSE, "dummy variables" in the
expression will not be included in the list returned by LISTOFVARS.
(The meaning of "dummy variables" is as given in DESCRIBE(FREEOF):
"Dummy variables" are mathematical things like the index of a sum or
product, the limit variable, and the definite integration variable.)
Example: LISTOFVARS('SUM(F(I),I,0,N)); gives [I,N] if LISTDUMMYVARS is
TRUE, and [N] if LISTDUMMYVARS is FALSE.

&LISTFILES(DSK,username) To list your directory.  If you use a shared
directory such as Users or Plasma, only your files--the ones with your
login name as first file name--will be shown.  The length and date of
creation of each file is also shown.  There is a shorter list command,
QLISTFILES(DSK,username) which gives just the file names and no length
or date information.

&LISTOFVARS(exp) yields a list of the variables in exp.

LISTCONSTVARS[FALSE] if TRUE will cause LISTOFVARS to include %E, %PI,
%I, and any variables declared constant in the list it returns if they
appear in exp.  The default is to omit these.

(C1) LISTOFVARS(F(X[1]+Y)/G**(2+A));

(D1)                            [X[1], Y, A, G]

&LISTP(exp) is TRUE if exp is a list else FALSE.

&LMXCHAR default: [[] - The character used to display the (left)
delimiter of a matrix (see also RMXCHAR).

&LOAD("filename"); takes one argument, a filename represented as a
"string" (i.e. inside quotation marks), or as list (e.g. inside square
brackets), and locates and loads in the indicated file.  If no
directory is specified, it then searches the SHAREi directories and
any other directories listed in the FILE_SEARCH variable and loads the
indicated file. LOAD("EIGEN") will load the eigen package without the
need for the user to be aware of the details of whether the package
was compiled, translated, saved, or fassaved, i.e. LOAD will work on
both LOADILEable and BATCHable files.  Note: LOAD will use BATCHLOAD
if it finds the file is BATCHable (which means that it will BATCH the
file in "silently" without terminal output or labels).

Other MACSYMA commands to load in files are: LOADFILE, RESTORE,
BATCH, and DEMO.  Do DESCRIBE(command); for details.  LOADFILE and
RESTORE work for files written with SAVE; BATCH and DEMO for those
files written with STRINGOUT or created as lists of commands with a
text editor.

&LOADFILE(fn1, fn2, DSK, directory) loads a file as designated by its
arguments.  This function may be used to bring back quantities that
were stored from a prior MACSYMA session by use of the SAVE or STORE
functions.  If DSK and directory are omitted then the last directory
seen (initially the same as the user's login name or the appropriate
USERSi directory if the user has no file directory) will be used.  DSK
may be omitted.  Also, fn2 may be omitted if fn1 > is to be loaded in
(where > follows the conventions of ITS's file system).  Fn1 fn2 must
be a file of LISP functions and expressions, not of MACSYMA command
lines, in which case BATCH or DEMO is to be used.  It is possible to
type in file specifications in standard ITS format, provided the file
specification is enclosed in double quotes and the ";" after the
directory name is preceded by a backslash (e.g. "USERS1\;FOO >").

&LOADPRINT default: [TRUE] - governs the printing of messages
accompanying loading of files.  The following options are available:
TRUE means always print the message; 'LOADFILE means print only when
the LOADFILE command is used; 'AUTOLOAD means print only when a file
is automatically loaded in (e.g. the integration file SIN FASL); FALSE
means never print the loading message.

&LOCAL(v1, v2, ...)  causes the variables v1,v2,... to be local with
respect to all the properties in the statement in which this function
is used.  LOCAL may only be used in BLOCKs, in the body of function
definitions or LAMBDA expressions, or in the EV function and only one
occurrence is permitted in each.  LOCAL is independent of CONTEXT.

&LOG(X) - the natural logarithm.

  LOGEXPAND[TRUE] - causes LOG(A^B) to become B*LOG(A).  If it is set
to ALL, LOG(A*B) will also simplify to LOG(A)+LOG(B).  If it is set to
SUPER, then LOG(A/B) will also simplify to LOG(A)-LOG(B) for rational
numbers a/b, a#1.  (LOG(1/B), for B integer, always simplifies.)  If
it is set to FALSE, all of these simplifications will be turned off.

  LOGSIMP[TRUE] - if FALSE then no simplification of %E to a power
containing LOG's is done.

  LOGNUMER[FALSE] - if TRUE then negative floating point arguments to
LOG will always be converted to their absolute value before the log is
taken.  If NUMER is also TRUE, then negative integer arguments to LOG
will also be converted to their absolute value.

  LOGNEGINT[FALSE] - if TRUE implements the rule LOG(-n) ->
LOG(n)+%i*%pi for n a positive integer.

  %E_TO_NUMLOG[FALSE] - when TRUE, "r" some rational number, and
"x" some expression, %E^(r*LOG(x)) will be simplified into x^r .  It
should be noted that the RADCAN command also does this transformation,
and more complicated transformations of this ilk as well.

The LOGCONTRACT command "contracts" expressions containing LOG.

&LOGABS default: [FALSE] - when doing indefinite integration where
logs are generated, e.g. INTEGRATE(1/X,X), the answer is given in
terms of LOG(ABS(...)) if LOGABS is TRUE, but in terms of LOG(...) if
LOGABS is FALSE.  For definite integration, the LOGABS:TRUE setting is
used, because here "evaluation" of the indefinite integral at the
endpoints is often needed.

&LOGARC default: [FALSE] - if TRUE will cause the inverse circular and
hyperbolic functions to be converted into logarithmic form.

LOGARC(exp) will cause this conversion for a particular expression without
setting the switch or having to re-evaluate the expression with EV.

&LOGCGAMMA2 - See CGAMMA.
&LOGCONTRACT(exp) recursively scans an exp, transforming
subexpressions of the form a1*LOG(b1) + a2*LOG(b2) + c into
LOG(RATSIMP(b1^a1 * b2^a2)) + c

(C1) 2*(A*LOG(X) + 2*A*LOG(Y))$

(C2) LOGCONTRACT(%);
                                        2  4
(D3)                             A LOG(X  Y )

If you do DECLARE(N,INTEGER); then LOGCONTRACT(2*A*N*LOG(X)); gives
A*LOG(X^(2*N)).  The coefficients that "contract" in this manner are
those such as the 2 and the N here which satisfy
FEATUREP(coeff,INTEGER).  The user can control which coefficients are
contracted by setting the option LOGCONCOEFFP[FALSE] to the name of a
predicate function of one argument.  E.g. if you like to generate
SQRTs, you can do LOGCONCOEFFP:'LOGCONFUN$
LOGCONFUN(M):=FEATUREP(M,INTEGER) OR RATNUMP(M)$ .  Then
LOGCONTRACT(1/2*LOG(X)); will give LOG(SQRT(X)).

&LOGCONCOEFFP default:[FALSE] - controls which coefficients are
contracted when using LOGCONTRACT.  It may be set to the name of a
predicate function of one argument.  E.g. if you like to generate
SQRTs, you can do LOGCONCOEFFP:'LOGCONFUN$
LOGCONFUN(M):=FEATUREP(M,INTEGER) OR RATNUMP(M)$ .  Then
LOGCONTRACT(1/2*LOG(X)); will give LOG(SQRT(X)).

&LOGEXPAND default: [TRUE] - causes LOG(A^B) to become B*LOG(A).  If
it is set to ALL, LOG(A*B) will also simplify to LOG(A)+LOG(B).  If it
is set to SUPER, then LOG(A/B) will also simplify to LOG(A)-LOG(B) for
rational numbers a/b, a#1.  (LOG(1/B), for B integer, always
simplifies.)  If it is set to FALSE, all of these simplifications will
be turned off.

&LOGNEGINT default: [FALSE] - if TRUE implements the rule 
LOG(-n) -> LOG(n)+%i*%pi   for n a positive integer.

&LOGNUMER default: [FALSE] - if TRUE then negative floating point
arguments to LOG will always be converted to their absolute value
before the log is taken.  If NUMER is also TRUE, then negative integer
arguments to LOG will also be converted to their absolute value.

&LOGOUT() - On MC and Multics, causes the user to be logged out and
all jobs deleted.  This is useful when it is desired to BATCH in a
file and have the terminal logged out automatically when the
computations are finished.  (Equivalent to ^Z and :LOGOUT).  On other
systems, LOGOUT(); works like QUIT();

&LOGSIMP default: [TRUE] - if FALSE then no simplification of %E to a
power containing LOG's is done.

&LOPOW(exp, v) the lowest exponent of v which explicitly appears in
exp.  Thus LOPOW((X+Y)**2+(X+Y)**A,X+Y) is MIN(A,2).

&LORENTZ(exp) imposes the Lorentz condition by substituting 0 for all
indexed objects in exp that have a derivative index identical to a
contravariant index.

&LPART(label, expr, n1, ..., nk) is similar to DPART but uses a
labelled box. A labelled box is similar to the one produced by DPART
but it has a name in the top line.

&LRATSUBST(list,exp) is analogous to SUBST(list_of_equations,exp)
except that it uses RATSUBST instead of SUBST.  The first argument of
LRATSUBST must be an equation or a list of equations identical in
format to that accepted by SUBST (see DESCRIBE(SUBST);).  The
substitutions are made in the order given by the list of equations,
that is, from left to right.  A demo is available by doing
DEMO(LRATS,DEMO,SHARE2); .

&LRICCICOM(dis) - A function in the CTENSR (Component Tensor
Manipulation) package.  LRICCICOM computes the covariant (symmetric)
components LR[i,j] of the Ricci tensor.  If the argument dis is TRUE,
then the non-zero components are displayed.

&M1PBRANCH default: [FALSE] - "principal branch for -1 to a power".
Quantities such as (-1)^(1/3) [i.e. "odd" rational exponent] and 
(-1)^(1/4) [i.e. "even" rational exponent] are now handled as 
indicated in the following chart: 
     DOMAIN:REAL(default)  |                 DOMAIN:COMPLEX
                           |   M1PBRANCH:FALSE(default)   M1PBRANCH:TRUE
(-1)^(1/3):      -1        |    (-1)^(1/3)               1/2+%i*sqrt(3)/2
(-1)^(1/4):   (-1)^(1/4)   |    (-1)^(1/4)         sqrt(2)/2+%i*sqrt(2)/2

&MACRO - Do DESCRIBE(MACROS);

&MACROEXPANSION default:[FALSE] - Controls advanced features which
affect the efficiency of macros. Possible settings:
 FALSE -- Macros expand normally each time they are called.
 EXPAND -- The first time a particular call is evaluated, the
expansion is "remembered" internally, so that it doesn't have to be
recomputed on subsequent calls making subsequent calls faster.  The
macro call still GRINDs and DISPLAYs normally, however extra memory is
required to remember all of the expansions.
 DISPLACE -- The first time a particular call is evaluated, the
expansion is substituted for the call.  This requires slightly less
storage than when MACROEXPANSION is set to EXPAND and is just as fast,
but has the disadvantage that the original macro call is no longer
remembered and hence the expansion will be seen if DISPLAY or GRIND is
called.  See documentation for TRANSLATE and MACROS for more details.

&MACROS - The Macsyma Macro facility is now available.  Documentation
and examples of this facility and related topics are available in the
following places on MC:

Topic           Usage Information       How to Get a Demo

MACROs          DEMO;MACRO USAGE        BATCH(MACRO,DEMO,DSK,DEMO);
MACRO-Expansion DEMO;MACRO USAGE        BATCH(MACEX,DEMO,DSK,DEMO);
BUILDQ          DEMO;BUILDQ USAGE       BATCH(BUILDQ,DEMO,DSK,DEMO);

BUILDQ is a MACSYMA function for constructing pieces of code to be
executed.  It will be very useful in conjunction with macros, but may
have other applications as well.

More documentation will be forthcoming as we receive feedback from users
saying what questions are not answered by the existing documentation.
Please send bugs/questions/comments to KMP@MC

&MAIL("message") will send mail to MACSYMA.  This may be used to report
problems or bugs.

MAIL(username,"message") will send mail to a specific user.

Expressions may be included by referring to them, outside double
quotes, when (and only when) a username is given, e.g.

MAIL(ELLEN,"I am trying to integrate",D3,"but it asks for more list
space.  What should I do?");

&MAINVAR - You may DECLARE variables to be MAINVAR.  The ordering
scale for atoms is essentially: numbers < constants (e.g. %E,%PI) <
scalars < other variables < mainvars.  E.g. compare EXPAND((X+Y)^4);
with (DECLARE(X,MAINVAR), EXPAND((X+Y)^4)); .  (Note: Care should be
taken if you elect to use the above feature.  E.g. if you subtract an
expression in which X is a MAINVAR from one in which X isn't a
MAINVAR, resimplification e.g. with EV(expression,SIMP) may be
necessary if cancellation is to occur.  Also, if you SAVE an
expression in which X is a MAINVAR, you probably should also SAVE X.)

&MAKE_ARRAY(type,dim1,dim2,...,dimn) - creates an array.  "type" may
be 'ANY, 'FLONUM, 'FIXNUM, 'HASHED or 'FUNCTIONAL.  This is similar to
the ARRAY command, except that the created array is a functional array
object.  The advantage of this over ARRAY is that it doesn't have a
name, and once a pointer to it goes away, it will also go away.  e.g.
Y:MAKE_ARRAY(....); Y now points to an object which takes up space,
but do Y:FALSE, and Y no longer points to that object, so the object
will get garbage collected.  Note: the "dimi" here are different from
the ARRAY command, since they go from 0 to i-1, i.e.  a "dimension"
of 10 means you have elements from 0 to 9.

Y:MAKE_ARRAY('FUNCTIONAL,'F,'HASHED,1) - The second argument to
MAKE_ARRAY in this case is the function to call to calculate array
elements, and the rest of the arguments are passed recursively to
MAKE_ARRAY to generate the "memory" for the array function object.

&MAKE_INDEX_FILE("filename"); will parse a batch file without
evaluating it.  This is useful for debugging init files.  See
DESCRIBE(init); and DESCRIBE(OPEN_INDEX_FILE);.

&MAKEBOX(exp) will display exp in the same manner as SHOW; however,
any tensor d'Alembertian occurring in exp will be indicated using the
symbol [].  For example, []P([M],[N]) represents
G([],[I,J])*P([M],[N],I,J).

&MAKEFACT(exp) transforms occurrences of binomial,gamma, and beta
functions in exp to factorials.

&MAKEGAMMA(exp) transforms occurrences of binomial,factorial, and beta
functions in exp to gamma functions.

&MAKELIST - returns a list as value.  MAKELIST may be called as
MAKELIST(exp,var,lo,hi) ["lo" and "hi" must be integers], or as
MAKELIST(exp,var,list).  In the first case MAKELIST is analogous to
SUM, whereas in the second case MAKELIST is similar to MAP.  Examples:
   MAKELIST(CONCAT(X,I),I,1,6) yields [X1,X2,X3,X4,X5,X6]
   MAKELIST(X=Y,Y,[A,B,C]) yields [X=A,X=B,X=C]

&MANUAL - To order documentation, you should write to
        MACSYMA Group
        Symbolics, Inc.
        257 Vassar Street
        Cambridge, MA 02139
Request "The MACSYMA Reference Manual".  The current version is
version 10, second printing December 1983.  The manual costs $40.00,
plus $3.00 for shipping and handling, which should be included with
the request.

&MAP(fn, exp1, exp2, ...) returns an expression whose leading operator
is the same as that of the expi but whose subparts are the results of
applying fn to the corresponding subparts of the expi.  Fn is either
the name of a function of n arguments (where n is the number of expi)
or is a LAMBDA form of n arguments.  MAP is affected by the setting of
INFLAG, do DESCRIBE(INFLAG) for details.

MAPERROR[TRUE] - if FALSE will cause all of the mapping functions to
(1) stop when they finish going down the shortest expi if not all of
the expi are of the same length and (2) apply fn to [exp1, exp2,...]
if the expi are not all the same type of object. If MAPERROR is TRUE
then an error message will be given in the above two instances.

One of the uses of this function is to MAP a function (e.g. PARTFRAC)
onto each term of a very large expression where it ordinarily wouldn't
be possible to use the function on the entire expression due to an
exhaustion of list storage space in the course of the computation.

(C1) MAP(F,X+A*Y+B*Z);
(D1)                        F(B Z) + F(A Y) + F(X)

(C2) MAP(LAMBDA([U],PARTFRAC(U,X)),X+1/(X^3+4*X^2+5*X+2));

                           1       1        1
(D2)                     ----- - ----- + -------- + X
                         X + 2   X + 1          2
                                         (X + 1)

(C3) MAP(RATSIMP, X/(X^2+X)+(Y^2+Y)/Y);
                                      1
(D3)                            Y + ----- + 1
                                    X + 1

(C4) MAP("=",[A,B],[-0.5,3]);
(D4)                          [A = - 0.5, B = 3]

&MAP_OVER_INDEX_FILE,|function, fileobject|) is convenient for
generating an index list of properties of the objects in a file vs.
their positions in the file.  See DESCRIBE(MAKE_INDEX_FILE);.

&MAPATOM(expr) is TRUE if and only if expr is treated by the MAPping
routines as an "atom", a unit.  "Mapatoms" are atoms, numbers
(including rational numbers), and subscripted variables.

&MAPERROR default: [TRUE] - if FALSE will cause all of the mapping
functions (e.g. MAP(fn,exp1,exp2,...)) to (1) stop when they finish
going down the shortest expi if not all of the expi are of the same
length and (2) apply fn to [exp1, exp2,...] if the expi are not all
the same type of object.  If MAPERROR is TRUE then an error message
will be given in the above two instances.

&MAPLIST(fn, exp1, exp2, ...)  yields a list of the applications of fn
to the parts of the expi.  This differs from MAP(fn,exp1,exp2,...)
which returns an expression with the same main operator as expi has
(except for simplifications and the case where MAP does an APPLY).  Fn
is of the same form as in MAP.  MAPLIST is affected by the setting of
INFLAG, do DESCRIBE(INFLAG) for details.

&MATCHDECLARE(patternvar, predicate, ...)  associates a predicate with
a pattern variable so that the variable will only match expressions
for which the predicate is not FALSE.  (The matching is accomplished
by one of the functions described below).  For example after
MATCHDECLARE(Q,FREEOF(X,%E)) is executed, Q will match any expression
not containing X or %E.  If the match succeeds then the variable is
set to the matched expression.  The predicate (in this case FREEOF) is
written without the last argument which should be the one against
which the pattern variable is to be tested.  Note that the patternvar
and the arguments to the predicate are evaluated at the time the match
is performed.  CAVEAT: MATCHDECLARE variables are supposed to be
matched with expressions, not operators.  Operators (i.e. items in the
operator position of expressions, including names of subscripted
variables) are assumed to be constant.

The odd numbered argument may also be a list of pattern variables all
of which are to have the associated predicate.  Any even number of
arguments may be given.

For pattern matching, predicates refer to functions which are either
FALSE or not FALSE (any non FALSE value acts like TRUE).

MATCHDECLARE(var,TRUE) will permit var to match any expression.

&MATCHFIX - MATCHFIX operators are used to denote functions of any
number of arguments which are passed to the function as a list.  The
arguments occur between the main operator and its "matching"
delimiter.  The MATCHFIX("x",...) function is a syntax extension
function which declares x to be a MATCHFIX operator.  Do
DESCRIBE(SYNTAX); for more details.

&MATRICES - See DESCRIBE(MATRIX); .
&MATRIX(row1, ..., rown) defines a rectangular matrix with the
indicated rows.  Each row has the form of a list of expressions, e.g.
[A, X**2, Y, 0] is a list of 4 elements.  There are a number of
MACSYMA commands which deal with matrices, for example:  DETERMINANT,
CHARPOLY, GENMATRIX, ADDCOL, ADDROW, COPYMATRIX, TRANSPOSE, ECHELON,
and RANK.  There is also a package on the SHARE directory for 
computing EIGENVALUES.  Try DESCRIBE on these for more information.

Matrix multiplication is effected by using the dot operator, ".",
which is also convenient if the user wishes to represent other
non-commutative algebraic operations.  The exponential of the "."
operation is "^^" .

Thus, for a matrix A, A.A = A^^2 and, if it exists, A^^-1 is the
inverse of A.

The operations +,-,*,** are all element-by-element operations; all
operations are normally carried out in full, including the . (dot)
operation.  Many switches exist for controlling simplification rules
involving dot and matrix-list operations.

Options Relating to Matrices:

LMXCHAR, RMXCHAR, RATMX, LISTARITH, DETOUT, DOALLMXOPS, DOMXEXPT
DOMXMXOPS, DOSCMXOPS, DOSCMXPLUS, SCALARMATRIX, and SPARSE.
Do DESCRIBE(option) for details on them.

&MATRIXMAP(fn, M) will map the function fn onto each element of the
matrix M.

&MATRIXP(exp) is TRUE if exp is a matrix else FALSE.

&MATRIX_ELEMENT_ADD default: [+] - May be set to "?"; may also be the
name of a function, or a LAMBDA expression.  In this way, a rich
variety of algebraic structures may be simulated.  For more details,
do DEMO(MATRIX,DEMO1,DEMO); and DEMO(MATRIX,DEMO2,DEMO);.

&MATRIX_ELEMENT_MULT default: [*] - May be set to "."; may also be the
name of a function, or a LAMBDA expression.  In this way, a rich
variety of algebraic structures may be simulated.  For more details,
do DEMO(MATRIX,DEMO1,DEMO); and DEMO(MATRIX,DEMO2,DEMO);.

&MATRIX_ELEMENT_TRANSPOSE default: [FALSE] - Other useful settings are
TRANSPOSE and NONSCALARS; may also be the name of a function, or a
LAMBDA expression.  In this way, a rich variety of algebraic
structures may be simulated.  For more details, do
DEMO(MATRIX,DEMO1,DEMO); and DEMO(MATRIX,DEMO2,DEMO);.

&MATTRACE(M) computes the trace [sum of the elements on the main diagonal] of
the square matrix M.  It is used by NCHARPOLY, an alternative to MACSYMA's
CHARPOLY.  It is used by doing LOAD(NCHRPL);

&MAX(X1, X2, ...) yields the maximum of its arguments (or returns a
simplified form if some of its arguments are non-numeric).

&MAXAPPLYDEPTH default: [10000] - the maximum depth to which APPLY1
and APPLY2 will delve.

&MAXAPPLYHEIGHT default: [10000] - the maximum height to which APPLYB1
will reach before giving up.

&MAXNEGEX default: [1000] - the largest negative exponent which will
be expanded by the EXPAND command (see also MAXPOSEX).

&MAXPOSEX default: [1000] - the largest exponent which will be
expanded with the EXPAND command (see also MAXNEGEX).

&MAXPRIME default: [489318] - the largest number which may be given to
the PRIME(n) command, which returns the nth prime.

&MAXTAYORDER default: [TRUE] - if TRUE, then during algebraic
manipulation of (truncated) Taylor series, TAYLOR will try to retain
as many terms as are certain to be correct.

&MEMBER(exp, list) returns TRUE if exp occurs as a member of list (not
within a member).  Otherwise FALSE is returned.  Member also works on
non-list expressions, e.g. MEMBER(B, F(A,B,C));  ->  TRUE.

&METRIC(G) specifies the metric by assigning the variable METRIC:G; in
addition, the contraction properties of the metric G are set up by
executing the commands DEFCON(G), DEFCON(G,G,KDELTA).

The variable METRIC, default: [], is bound to the metric, assigned by
the METRIC(g) command.

&MIN(X1, X2, ...) yields the minimum of its arguments (or returns a
simplified form if some of its arguments are non-numeric).

&MINF - real minus infinity.

&MINFACTORIAL(exp) examines exp for occurrences of two factorials
which differ by an integer.  It then turns one into a polynomial times
the other.  If exp involves binomial coefficients then they will be
converted into ratios of factorials.

(C1) N!/(N+1)!;
                                    N!
(D1)                             --------
                                 (N + 1)!

(C2) MINFACTORIAL(%);
                                     1
(D2)                               -----
                                   N + 1

&MINOR(M, i, j) computes the i,j minor of the matrix M.  That is, M
with row i and column j removed.

&MOD(poly) converts the polynomial poly to a modular representation
with respect to the current modulus which is the value of the variable
MODULUS.  

MOD(poly,m) specifies a MODULUS m to be used for converting poly, if
it is desired to override the current global value of MODULUS.
See DESCRIBE(MODULUS); .

&MODE_CHECKP default: [TRUE] - If TRUE, MODE_DECLARE checks the modes
of bound variables.

&MODE_CHECK_WARNP default: [TRUE] - If TRUE, mode errors are
described.

&MODE_CHECK_ERRORP default: [FALSE] - If TRUE, MODE_DECLARE calls
error.

&MODE_DECLARE(y1, mode1, y2, mode2, ...) - MODEDECLARE is a synonym
for this.  MODE_DECLARE is used to declare the modes of variables and
functions for subsequent translation or compilation of functions. Its
arguments are pairs consisting of a variable yi, and a mode which is
one of BOOLEAN, FIXNUM, NUMBER, RATIONAL, or FLOAT.  Each yi may also
be a list of variables all of which are declared to have modei.

If yi is an array, and if every element of the array which is
referenced has a value then ARRAY(yi, COMPLETE, dim1, dim2, ...)
rather than ARRAY(yi, dim1, dim2, ...) should be used when first
declaring the bounds of the array.  If all the elements of the array
are of mode FIXNUM (FLOAT), use FIXNUM (FLOAT) instead of COMPLETE.
Also if every element of the array is of the same mode, say m, then
MODE_DECLARE(COMPLETEARRAY(yi),m)) should be used for efficient
translation.  Also numeric code using arrays can be made to run faster
by declaring the expected size of the array, as in:

MODE_DECLARE(COMPLETEARRAY(A[10,10]),FLOAT)

for a floating point number array which is 10 x 10.

Additionally one may declare the mode of the result of a function by
using FUNCTION(F1,F2,...) as an argument; here F1,F2,... are the names
of functions.  For example the expression,

MODE_DECLARE([FUNCTION(F1,F2,...),X],FIXNUM,Q,COMPLETEARRAY(Q),FLOAT)

declares that X and the values returned by F1,F2,... are single-word
integers and that Q is an array of floating point numbers.
MODE_DECLARE is used either immediately inside of a function
definition or at top-level for global variables.  Do
PRINTFILE(MCOMPI,DOC,MAXDOC); for some examples of the use of
MODE_DECLARE in translation and compilation.

&MODE_IDENTITY(arg1,arg2) - A special form used with MODE_DECLARE and
MACROS to delcare, e.g., a list of lists of flonums, or other compound
data object.  The first argument to MODE_IDENTITY is a primitive value
mode name as given to MODE_DECLARE (i.e. [FLOAT,FIXNUM,NUMBER,
LIST,ANY]), and the second argument is an expression which is
evaluated and returned as the value of MODE_IDENTITY.  However, if the
return value is not allowed by the mode declared in the first
argument, an error or warning is signalled.  The important thing is
that the MODE of the expression as determined by the MACSYMA to Lisp
translator, will be that given as the first argument, independent of
anything that goes on in the second argument.

E.g. X:3.3; MODE_IDENTITY(FIXNUM,X); is an error.  MODE_IDENTITY(FLONUM,X) 
returns 3.3 . 

This has a number of uses, e.g., if you knew that FIRST(L) returned a
number then you might write MODE_IDENTITY(NUMBER,FIRST(L)).  However,
a more efficient way to do it would be to define a new primitive,
FIRSTNUMB(X)::=BUILDQ([X],MODE_IDENTITY(NUMBER,X))$ and use FIRSTNUMB
every time you take the first of a list of numbers.

&MODRESULT - This switch is obsolete.  The new RESULTANT switch should
be used.  Do DESCRIBE(RESULTANT); for details.

&MODULUS default: [FALSE] - if set to a positive prime p, then all
arithmetic in the rational function routines will be done modulo p.
That is all integers will be reduced to less than p/2 in absolute
value (if p=2 then all integers are reduced to 1 or 0).  This is the
so called "balanced" modulus system, e.g. N MOD 5 = -2, -1, 0, 1, or
2.  Warning: If EXP is already in CRE form when you reset MODULUS,
then you may need to re-rat EXP, e.g. EXP:RAT(RATDISREP(EXP)), in
order to get correct results. (If MODULUS is set to a positive
non-prime integer, this setting will be accepted, but a warning will
be given.)

&MORE Processing - The term used to describe the action of a CRT
console when it stops at the bottom of the screen to allow the user
to finish reading.  See PAGEPAUSE and MOREWAIT for details.

&MOREWAIT default: [FALSE] - Controls the action of more processing.
In its default FALSE setting, a space typed at --More Display?-- will
continue the display, a rubout (or delete) will flush the display of
the expression (to both the terminal and any WRITEFILE which is open)
and anything else will flush only output to the terminal.  Type-ahead
is allowed (i.e. you can begin typing the next command-line and the
display to the console will be flushed and your typing will be saved
and put on the C-line).  "carriage return" is frequently used for this
last function of just flushing the output to the terminal.  If
MOREWAIT is set to TRUE, then space and rubout work as above, but only
carriage return is enabled to flush display to the terminal, and type-
ahead is ignored.  If MOREWAIT is set to ALL, then only space (to
continue output) and carriage return (to flush it) are enabled, and
any other characters (including rubout) are ignored.  This may be useful
for users on noisy connections where rubouts transmitted by the phone
line sometimes flush output accidently.

&MOTION(dis) - A function in the CTENSR (Component Tensor
Manipulation) package.  MOTION computes the geodesic equations of
motion for a given metric.  They are stored in the array EM[i].  If
the argument dis is TRUE then these equations are displayed.

&MULTIGRAPH([[xset1, yset1], ..., [xsetn, ysetn]], optional-args) -
allows the user to produce a scatter-graph involving several x-domains
each with a single y-range; e.g.
MULTIGRAPH([[[0,1],[0,1]],[[3,4],[1,2]]],["&"]).

&MULTIPLICATIVE - If DECLARE(F,MULTIPLICATIVE) has been executed,
then:
(1) If F is univariate, whenever the simplifier encounters F applied
to a product, F will be distributed over that product.  I.e. F(X*Y);
will simplify to F(X)*F(Y).
(2) If F is a function of 2 or more arguments, multiplicativity is
defined as multiplicativity in the first argument to F, i.e.
F(G(X)*H(X),X); will simplify to F(G(X),X)*F(H(X),X).
This simplification does not occur when F is applied to expressions of
the form PRODUCT(X[I],I,lower-limit,upper-limit).

&MULTIPLICITIES default: [NOT_SET_YET] - will be set to a list of the
multiplicities of the individual solutions returned by SOLVE or
REALROOTS.

&MULTTHRU(exp) multiplies a factor (which should be a sum) of exp by
the other factors of exp.  That is exp is f1*f2*...*fn where at least
one factor, say fi, is a sum of terms.  Each term in that sum is
multiplied by the other factors in the product.  (Namely all the
factors except fi).  MULTTHRU does not expand exponentiated sums.
This function is the fastest way to distribute products (commutative
or noncommutative) over sums.  Since quotients are represented as
products MULTTHRU can be used to divide sums by products as well.

MULTTHRU(exp1, exp2) multiplies each term in exp2 (which should be a
sum or an equation) by exp1.  If exp1 is not itself a sum then this
form is equivalent to MULTTHRU(exp1*exp2).

(C1) X/(X-Y)**2-1/(X-Y)-F(X)/(X-Y)**3;

               1        X         F(X)
(D1)       - ----- + -------- - --------
             X - Y          2          3
                     (X - Y)    (X - Y)

(C2) MULTTHRU((X-Y)**3,%);

                    2
(D2)       - (X - Y)  + X (X - Y) - F(X)

(C3) RATEXPAND(D2);
                           2
(D3)                    - Y  + X Y - F(X)

(C4) ((A+B)**10*S**2+2*A*B*S+(A*B)**2)/(A*B*S**2);

                         10  2              2  2
                (B  + A )   S  + 2 A B S + A  B
(D4)            --------------------------------
                                   2
                              A B S

(C5) MULTTHRU(%);

                                          10
                        2   A B   (B  + A)
(D5)                    - + --- + -------
                        S    2      A B
                            S

(notice that (B+A)**10 is not expanded)

(C6) MULTTHRU(A.(B+C.(D+E)+F));

(D6)                A . F + A . (C . (E + D)) + A . B

(compare with similar example under EXPAND)

&MYOPTIONS default: [] - all options ever reset by the user (whether
or not they get reset to their default value).

&NARY - An NARY operator is used to denote a function of any number of
arguments, each of which is separated by an occurrence of the
operator, e.g. A+B or A+B+C.  The NARY("x") function is a syntax
extension function to declare x to be an NARY operator.  Do
DESCRIBE(SYNTAX); for more details.  Functions may be DECLAREd to be
NARY.  If DECLARE(J,NARY); is done, this tells the simplifier to
simplify, e.g. J(J(A,B),J(C,D)) to J(A, B, C, D).

&NCEXPT(A,B) - if an (non-commutative) exponential expression is too
wide to be displayed as A^^B it will appear as NCEXPT(A,B).

&NCHARPOLY(M,var) finds the characteristic polynomial of the matrix M
with respect to var.  This is an alternative to MACSYMA's CHARPOLY.
NCHARPOLY works by computing traces of powers of the given matrix,
which are known to be equal to sums of powers of the roots of the
characteristic polynomial.  From these quantities the symmetric
functions of the roots can be calculated, which are nothing more than
the coefficients of the characteristic polynomial.  CHARPOLY works by
forming the determinant of VAR * IDENT [N] - A.  Thus NCHARPOLY wins,
for example, in the case of large dense matrices filled with integers,
since it avoids polynomial arithmetic altogether.  It may be used by
doing LOAD(NCHRPL);

&NDIFFQ - a package residing on the SHARE directory for numerical
solutions of differential equations.  LOAD("NDIFFQ"); will load it
in for use.  An example of its use would be:
Define_Variable(N,0.3,FLOAT);
Define_Variable(H,0.175,FLOAT);
F(X,E):=(Mode_Declare([X,E],FLOAT),N*EXP(X)/(E+X^(2*H)*EXP(H*X)));
Compile(F);
Array([X,E],FLOAT,35);
Init_Float_Array(X,1.0E-3,6.85); /* Fills X with the interval */
E[0]:5.0;                        /* Initial condition */
Runge_Kutta(F,X,E);              /* Solve it */
Graph2(X,E);                     /* Graph the solution */

p.s. Runge_Kutta(F,X,E,E_Prime) would be the call for a second-order 
equation.

&NEGDISTRIB default: [TRUE] - when TRUE allows -1 to be distributed
over an expression.  E.g. -(X+Y) becomes -Y-X.  Setting it to FALSE
will allow -(X+Y) to be displayed like that.  This is sometimes useful
but be very careful: like the SIMP flag, this is one flag you do not
want to set to FALSE as a matter of course or necessarily for other
than local use in your MACSYMA.

&NEGSUMDISPFLAG default: [TRUE] - when TRUE, X-Y displays as X-Y
instead of as -Y+X.  Setting it to FALSE causes the special check in
display for the difference of two expressions to not be done.  One
application is that thus A+%I*B and A-%I*B may both be displayed the
same way.

&NEWCONTEXT(name) creates a new (empty) context, called name, which
has GLOBAL as its only subcontext.  The new context created will
become the currently active context.

&NEWDET(M,n) also computes the determinant of M but uses the
Johnson-Gentleman tree minor algorithm.  M may be the name of a
matrix or array.  The argument n is the order; it is optional if M is
a matrix.

&NEWTON(exp,var,X0,eps) - The file NEWTON 1 on the SHARE directory
contains a function which will do interpolation using Newton's method.
It may be accessed by LOAD(NEWTON); .  The Newton method can do things
that INTERPOLATE will refuse to handle, since INTERPOLATE requires
that everything evaluate to a flonum. Thus

NEWTON(x^2-a^2,x,a/2,a^2/100);

will say that it can't tell if flonum*a^2<a^2/100. Doing ASSUME(a>0);
and then doing NEWTON again works. You get x=a+<small flonum>*a which
is symbolic all the way.  INTERPOLATE(x^2-a^2,x,a/2,2*a); complains
that .5*a is not flonum...

An adaptive integrator which uses the Newton-Cotes 8 panel quadrature
rule is available in SHARE1;QQ FASL.  Do DESCRIBE(QQ) for details.

&NICEINDICES(expr) - will take the expression and change all the
indices of sums and products to something easily understandable. It
makes each index it can "I" , unless "I" is in the internal
expression, in which case it sequentially tries
J,K,L,M,N,I0,I1,I2,I3,I4,...  until it finds a legal index.

&NICEINDICESPREF default: [I,J,K,L,M,N] - the list which NICEINDICES
uses to find indices for sums and products.  This allows the user to
set the order of preference of how NICEINDICES finds the "nice
indices".  E.g.  NICEINDICESPREF:[Q,R,S,T,INDEX]$.  Then if
NICEINDICES finds that it cannot use any of these as indices in a
particular summation, it uses the first as a base to try and tack on
numbers.  Here, if the list is exhausted, Q0, then Q1, etc, will be
tried.

&NOEVAL - suppresses the evaluation phase of EV.  This is useful in
conjunction with other switches and in causing expressions      
to be resimplified without being reevaluated.

&NOFIX - NOFIX operators are used to denote functions of no arguments.
The mere presence of such an operator in a command will cause the
corresponding function to be evaluated.  For example, when one types
"exit;" to exit from a MACSYMA break, "exit" is behaving similar to a
NOFIX operator.  The function NOFIX("x") is a syntax extension
function which declares x to be a NOFIX operator.  Do
DESCRIBE(SYNTAX); for more details.

&NOLABELS default: [FALSE] - if TRUE then no labels will be bound
except for E lines generated by the solve functions.  This is most
useful in the "BATCH" mode where it eliminates the need to do
KILL(LABELS) in order to free up storage.

&NONSCALAR - makes ai behave as does a list or matrix with respect to
the dot operator.

&NONSCALARP(exp) is TRUE if exp is a non-scalar, i.e.  it contains
atoms declared as non-scalars, lists, or matrices.

&NOSTRING displays all input lines when playing back rather than
STRINGing them.  If arg=GRIND then the display will be in a more
readable format.  One may include any number of options as in
PLAYBACK([5,10],20,TIME,SLOW).

&NOT3D - The addition of NOT3D as an argument to PLOT3D causes exactly
the same points as in the bare PLOT3D to be calculated.  Instead of
plotting a 3-dimensional representation of the data, the data is
plotted in a 2D one.  Specifically 1 2D curve of z vs. x for each y
value, and so is a convenient way to plot several curves on the same
plot.

&NOUN - One of the options of the DECLARE command.  It makes a
function so DECLAREd a "noun", meaning that it won't be evaluated
automatically.

&NOUNDISP default: [FALSE] - if TRUE will cause NOUNs to display with
a single quote.  This switch is always TRUE when displaying function
definitions.

&NOUNIFY(f) returns the noun form of the function name f.  This is
needed if one wishes to refer to the name of a verb function as if it
were a noun.  Note that some verb functions will return their noun
forms if they can't be evaluated for certain arguments.  This is also
the form returned if a function call is preceded by a quote.

&NOUNS (EVFLAG) when used as an option to the EV command, converts all
"noun" forms occurring in the expression being EV'd to "verbs", i.e.
evaluates them.  See also NOUN, NOUNIFY, VERB, and VERBIFY.

&NROOTS(poly, low, high) finds the number of real roots of the real
univariate polynomial poly in the half-open interval (low,high].  The
endpoints of the interval may also be MINF,INF respectively for minus
infinity and plus infinity.  The method of Sturm sequences is used.

(C1) POLY1:X**10-2*X**4+1/2$
(C2) NROOTS(POLY1,-6,9.1);
RAT REPLACED 0.5 BY 1/2 = 0.5
(D2)                               4

&NTERMS(exp) gives the number of terms that exp would have if it were
fully expanded out and no cancellations or combination of terms
occurred. Note that expressions like SIN(E), SQRT(E), EXP(E), etc.
count as just one term regardless of how many terms E has (if it is a
sum).

&NTERMSG() gives the user a quick picture of the "size" of the
Einstein tensor.  It returns a list of pairs whose second elements
give the number of terms in the components specified by the first
elements.

&NTERMSRCI() returns a list of pairs, whose second elements give the
number of terms in the RICCI component specified by the first
elements.  In this way, it is possible to quickly find the non-zero
expressions and attempt simplification.

&NTHROOT(p,n) where p is a polynomial with integer coefficients and
n is a positive integer returns q, a polynomial over the integers, such
that q^n=p or prints an error message indicating that p is not a perfect
nth power. This routine is much faster than FACTOR or even SQFR.

&NTRIG - SHARE1;NTRIG FASL allows MACSYMA to compute trig functions
with arguments of the form N*%PI/10 for integer N.  Do LOAD(NTRIG) to
access this. The main functions are USIN(N) and UCOS(N).

&NUM(exp) obtains the numerator, exp1, of the rational expression
exp = exp1/exp2.

&NUMBERP(exp) is TRUE if exp is an integer, a rational number, a
floating point number or a bigfloat else FALSE.

&NUMER causes some mathematical functions (including exponentiation)
with numerical arguments to be evaluated in floating point. It causes
variables in exp which have been given numervals to be replaced by
their values.  It also sets the FLOAT switch on.

&NUMERICAL - There are a number of packages for numerical methods in
MACSYMA.  See IMSL and the SHARE directories.

&NUMERVAL(var1, exp1, var2, exp2, ...) declares vari to have a
numerval of expi which is evaluated and substituted for the variable
in any expressions in which the variable occurs if the NUMER flag is
TRUE. (see the EV function).

&NUMFACTOR(exp) gives the numerical factor multiplying the expression
exp which should be a single term.  If the gcd of all the terms in a
sum is desired the CONTENT function may be used.

(C1) GAMMA(7/2);

(D1)               15 SQRT(%PI)
                   ------------
                        8

(C2) NUMFACTOR(%)
                    15
(D2)                --
                     8

&NUSUM(exp,var,low,high) performs indefinite summation of exp with
respect to var using a decision procedure due to R.W. Gosper.  exp and
the potential answer must be expressible as products of nth powers,
factorials, binomials, and rational functions.  The terms "definite"
and "indefinite summation" are used analogously to "definite" and
"indefinite integration".  To sum indefinitely means to give a closed
form for the sum over intervals of variable length, not just e.g. 0 to
inf.  Thus, since there is no formula for the general partial sum of
the binomial series, NUSUM can't do it.

&NZETA(Z) returns the complex value of the Plasma Dispersion Function
for complex Z.  NZETAR(Z) returns REALPART(NZETA(Z)).  NZETAI(Z)
returns IMAGPART(NZETA(Z)).  This function is related to the complex
error function by NZETA(Z) = %I*SQRT(%PI)*EXP(-Z^2)*(1-ERF(-%I*Z)).

&OBASE default: [10] the base for display of numbers.

&ODDP(exp) is TRUE if exp is an odd integer.  FALSE is returned in all
other cases.

&ODE(equation,y,x) - a pot-pourri of Ordinary Differential solvers
combined in such a way as to attempt more and more difficult methods
as each fails. For example, the first attempt is with ODE2, so
therefore, a user using ODE can assume he has all the capabilities of
ODE2 at the very beginning and if he has been using ODE2 in programs
they will still run if he substitutes ODE (the returned values, and
calling sequence are identical).

In addition, ODE has a number of user features which can assist an
experienced ODE solver if the basic system cannot handle the equation.
The equation is of the same form as required for ODE2 (which see) and
the y and x are dependent and independent variables, as with ODE2.
For more details, do PRINTFILE(ODE,USAGE,SHARE); .

&ODE2(exp,dvar,ivar) takes three arguments: an ODE of first or second
order (only the left hand side need be given if the right hand side is
0), the dependent variable, and the independent variable.  When
successful, it returns either an explicit or implicit solution for the
dependent variable.  %C is used to represent the constant in the case
of first order equations, and %K1 and %K2 the constants for second
order equations.  If ODE2 cannot obtain a solution for whatever
reason, it returns FALSE, after perhaps printing out an error message.

The methods implemented for first order equations in the order in
which they are tested are: linear, separable, exact - perhaps
requiring an integrating factor, homogeneous, Bernoulli's equation,
and a generalized homogeneous method.

For second order: constant coefficient, exact, linear homogeneous with
non-constant coefficients which can be transformed to constant
coefficient, the Euler or equidimensional equation, the method of
variation of parameters, and equations which are free of either the
independent or of the dependent variable so that they can be reduced
to two first order linear equations to be solved sequentially.

In the course of solving ODEs, several variables are set purely for
informational purposes: METHOD denotes the method of solution used
e.g. LINEAR, INTFACTOR denotes any integrating factor used, ODEINDEX
denotes the index for Bernoulli's method or for the generalized
homogeneous method, and YP denotes the particular solution for the
variation of parameters technique.

&OMEGA default:[] - An option in the CTENSR (Component Tensor
Manipulation) package.  OMEGA assigns a list of coordinates to the
variable. While normally defined when the function TSETUP is called,
one may redefine the coordinates with the assignment
OMEGA:[j1,j2,...jn] where the j's are the new coordinate names. A call
to OMEGA will return the coordinate name list.  Also see
DESCRIBE(TSETUP); .

&OPEN_INDEX_FILE(filename) - returns a symbol which represents the
indexed file.  It is easiest to use if the user sets a variable to the
value returned, or refers to it by its D-line number.  E.g.
F:OPEN_INDEX_FILE(KAM1,EXP,DSK,ODE); sets the variable F to the symbol
which represents the indexed file object.

&OPERATOR - See OPERATORS
&OPERATORS - MACSYMA uses the standard Mathematical operators:
  !  for Factorial,
  !! for Double factorial,
  ^ or ** for Exponentiation,
  *  for Multiplication,
  .  for non-commutative multiplication
  /  for Division, 
  +  for Addition, and
  -  for Subtraction.
In addition, it uses some other operators:
  :  for variable assignment (e.g. A:3 sets A to 3).
  := for function definition (e.g. F(X):=SIN(X) defines a function F).

Note: the term operator is used in either of two senses: syntactic
(meaning that it has special syntax properties in the MACSYMA
language) or semantic (referring to its functionality).  In the
syntactic sense it is something which usually consists of
non-alphanumeric characters, e.g. "+" or "*" (exceptions include
"AND", "OR", and "NOT").  Semantically we sometimes refer to the
"operator of an expression", meaning that thing which is in the
operator part of the expression, such as the "+" in "A+B" or SIN in
"SIN(x)".  Note: "+" in this latter example is also an operator in the
syntactic sense, whereas SIN is a mathematical function.

&OPPROPERTIES - the list of the special operator-properties handled by
the MACSYMA simplifier: LINEAR, ADDITIVE, MULTIPLICATIVE, OUTATIVE,
EVENFUN, ODDFUN, COMMUTATIVE, SYMMETRIC, ANTISYMMETRIC, NARY,
LASSOCIATIVE, and RASSOCIATIVE.

&OPSUBST default:[TRUE] - if FALSE, SUBST will not attempt to
substitute into the operator of an expression.  E.g. (OPSUBST:FALSE,
SUBST(X^2,R,R+R[0])); will work.

&OPTIMIZATION - When using TRANSLATE and generating code with MACSYMA,
there are a number of techniques which can save time and be helpful.
Do DEMO(OPTIMU,DEMO,TRANSL) for a demonstration.  In particular, the
function FLOATDEFUNK from TRANSL;OPTIMU FASL, creates a function
definition from a math-like expression, but it optimizes it (with
OPTIMIZE) and puts in the MODE_DECLAREations needed to COMPILE
correctly. (This can be done by hand, of course).  The demo will only
run in a fresh macsyma.

&OPTIMIZE(exp) returns an expression that produces the same value and
side effects as exp but does so more efficiently by avoiding the
recomputation of common subexpressions.  OPTIMIZE also has the side
effect of "collapsing" its argument so that all common subexpressions
are shared.
Do EXAMPLE(OPTIMIZE); for examples.

&OPTIMPREFIX default: [%] - The prefix used for generated symbols by
the OPTIMIZE command.

&OPTIONS() enters the OPTIONS interpreter which is a structured list
of MACSYMA commands.  You type the number of the subject of interest,
followed by a ";" to see the list of commands available for that
subject.  To move back up the list the command BACK; will go back up
one level, and TOP; will get you back to the original entry list.
EXIT; will quit out of OPTIONS.  DESCRIBE may be called inside OPTIONS
on the commands listed, either by number or by name.
OPTIONS(command); will give the various commands and switches
associated with command.

&OPTIONSET default: [FALSE] - if TRUE, MACSYMA will print out a
message whenever a MACSYMA option is reset.  This is useful if the
user is doubtful of the spelling of some option and wants to make sure
that the variable he assigned a value to was truly an option variable.

&ORDERGREAT(V1, ..., Vn) sets up aliases for the variables V1, ..., Vn
such that V1 > V2 > ...  > Vn > any other variable not mentioned as an
argument.  See also ORDERLESS.  Caveat:  do EXAMPLE(ORDERGREAT); for
some specifics.

&ORDERGREATP(exp1,exp2) returns TRUE if exp2 precedes exp1 in the
ordering set up with the ORDERGREAT function (see DESCRIBE(ORDERGREAT);).

&ORDERLESS(V1, ..., Vn) sets up aliases for the variables V1, ..., Vn
such that V1 < V2 < ...  < Vn < any other variable not mentioned as an
argument.  Thus the complete ordering scale is: numerical constants <
declared constants < declared scalars < first argument to ORDERLESS <
...  < last argument to ORDERLESS < variables which begin with A < ...
< variables which begin with Z < last argument to ORDERGREAT <
 ... < first argument to ORDERGREAT < declared MAINVARs.  Caveat: do
EXAMPLE(ORDERLESS); for some specifics.  For another ordering scheme,
see DESCRIBE(MAINVAR);.

&ORDERLESSP(exp1,exp2) returns TRUE if exp1 precedes exp2 in the
ordering set up by the ORDERLESS command (see DESCRIBE(ORDERLESS);).

&OUTATIVE - If DECLARE(F,OUTATIVE) has been executed, then:
(1) If F is univariate, whenever the simplifier encounters F applied
to a product, that product will be partitioned into factors that are
constant and factors that are not and the constant factors will be
pulled out.  I.e. F(A*X); will simplify to A*F(X) where A is a
constant.  Non-atomic constant factors will not be pulled out.
(2) If F is a function of 2 or more arguments, outativity is defined
as in the case of 'SUM or 'INTEGRATE, i.e. F(A*G(X),X); will simplify
to A*F(G(X),X) for A free-of X.
Initially, 'SUM, 'INTEGRATE, and 'LIMIT are declared to be OUTATIVE.

&OUTCHAR default: [D] - the alphabetic prefix of the names of
outputted expressions.

&OUTOFPOIS(A) converts A from Poisson encoding to general
representation.  If A is not in Poisson form, it will make the
conversion, i.e.  it will look like the result of
OUTOFPOIS(INTOPOIS(A)).  This function is thus a canonical simplifier
for sums of powers of SIN's and COS's of a particular type.

&PACKAGEFILE default:[FALSE] - Package designers who use SAVE,
FASSAVE, or TRANSLATE to create packages (files) for others
to use may want to set PACKAGEFILE:TRUE$ to prevent information
from being added to MACSYMA's information-lists (e.g. VALUES,
FUNCTIONS) except where necessary when the file is loaded in.
In this way, the contents of the package will not get in the
user's way when he adds his own data.  Note that this will not
solve the problem of possible name conflicts.  Also note that
the flag simply affects what is output to the package file.
Setting the flag to TRUE is also useful for creating MACSYMA
init files.

&PADE(taylor-series,num-deg-bound,denom-deg-bound) returns a list of
all rational functions which have the given taylor-series expansion
where the sum of the degrees of the numerator and the denominator is
less than or equal to the truncation level of the power series, i.e.
are "best" approximants, and which additionally satisfy the specified
degree bounds.  Its first argument must be a univariate taylor-series;
the second and third are positive integers specifying degree bounds on
the numerator and denominator.

PADE's first argument can also be a Laurent series, and the degree
bounds can be INF which causes all rational functions whose total
degree is less than or equal to the length of the power series to be
returned.  Total degree is num-degree + denom-degree.  Length of a
power series is "truncation level" + 1 - minimum(0,"order of series").

&PAGEPAUSE default: [] - This switch only works in the ITS version of
MACSYMA (the MIT-MC machine) - This is set by MACSYMA according to
what the system knows about your terminal type.  If it is set to TRUE,
then "more" processing, which involves the printing of --More
display?-- or --Pause-- at the bottom of your screen or after so many
lines on a printing terminal, and pausing, will be enabled.  It may be
set to FALSE to turn off the "more" processing on a display terminal.
PAGEPAUSE is sometimes useful in batch files on slow lines where you
just wish to watch the output run past, and can keep up with the line
speed well enough.

&PARAMPLOT(f1(t),f2(t),t,low,high) plots the plane curve f(t) =
(f1(t),f2(t)) with parameter t.  The syntax is basically like that of
plot.  For example,

PARAMPLOT(COS(T),SIN(T),T,0,2*%PI)

PARAMPLOT([f1(t), g1(t), ...h1(t)], [f2(t), g2(t),..., h2(t)], t,
low, high, [list of plotting characters]) plots the plane curves
f(t) = (f1,f2), g(t) = (g1,g2),...,h(t) = (h1,h2) using the specified
plotting characters or the default "*".  For example,

PARAMPLOT([COS(T),COS(T)+7],[SIN(T),SIN(T)],
                T,0,2*%PI,["@"])

plots two circles.

&PARAMPLOT2(x-exprs,y-exprs,variable,var-range,optional-args) plots
x-exprs as the x coordinate against y-exprs as the y coordinate.

The format for the first two arguments is the same as that for the
first argument to PLOT2.  Thus if x-exprs is [x-expr1, x-expr2, ..
,x-expri, .. ,x-exprn] and y-exprs is [y-expr1,y-expr2, .. ,y-expri,
.. ,y-exprk], then max(n,k) curves will be plotted. They will be
(assuming n > k):

x-expr1 vs. y-expr1, .. ,x-exprk vs. y-exprk,

x-expr(k+1) vs. y-exprk, .. ,x-exprn vs. y-exprk

The format for the remaining arguments is the same as for PLOT2.

PARAMPLOT2(x-funs.y-funs,var-range,optional-args) efficiently
evaluates its first 2 arguments in the same way that the alternative
form of PLOT2 works.

Examples
  TRANSLATE:TRUE;       causes automatic translation
  F(X):=(MODE_DECLARE(X,FLOAT),COS(X)); 
  G(X):=(MODE_DECLARE(X,FLOAT),SIN(X));
  PARAMPLOT2(F,G,0,2*%PI); plots F(x) vs G(x) as x goes from 0 to 2*%PI

  PARAMPLOT2(SIN(T),COS(T),T,0,2*%PI); plots sin(T) for the x-axis and
cos(T) for the y-axis as T takes on PLOTNUM values between 0 and
2*%PI.  (If EQUALSCALE is TRUE this draws a circle.)

PLOTNUM[20] is the number of points PLOT2 and PARAMPLOT2 plot when
given the low,high type of variable range.  The default when
PLOT2 is first called is 20, which is sufficient for trying things out.
100 is a suitable value for a final hard copy.

&PARSEWINDOW default:[10] - the maximum number of "lexical tokens"
that are printed out on each side of the error-point when a syntax
(parsing) error occurs.  This option is especially useful on slow
terminals.  Setting it to -1 causes the entire input string to be
printed out when an error occurs.

&PART(exp, n1, ..., nk) deals with the displayed form of exp. It
obtains the part of exp as specified by the indices n1,...,nk.  First
part n1 of exp is obtained, then part n2 of that, etc.  The result is
part nk of ... part n2 of part n1 of exp.  Thus PART(Z+2*Y,2,1) yields
2.  PART can be used to obtain an element of a list, a row of a
matrix, etc.  PART is affected by the setting of INFLAG, do
DESCRIBE(INFLAG) for details.

If the last argument to a Part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus PART(X+Y+Z,[1,3]) is Z+X.

PIECE holds the last expression selected when using the Part
functions.  It is set during the execution of the function and thus
may be referred to in the function itself as shown below.

If PARTSWITCH[FALSE] is set to TRUE then END is returned when a
selected part of an expression doesn't exist, otherwise an error
message is given.

For examples, do EXAMPLE(PART);

&PARTFRAC(exp, var) expands the expression exp in partial fractions
with respect to the main variable, var.  PARTFRAC does a complete
partial fraction decomposition.  The algorithm employed is based on
the fact that the denominators of the partial fraction expansion (the
factors of the original denominator) are relatively prime.  The
numerators can be written as linear combinations of denominators, and
the expansion falls out.  See EXAMPLE(PARTFRAC); for examples.

&PARTITION(exp, var) returns a list of two expressions.  They are (1)
the factors of exp (if it is a product), the terms of exp (if it is a
sum), or the list (if it is a list) which don't contain var and, (2)
the factors, terms, or list which do.

(C1) PARTITION(2*A*X*F(X),X);

(D1)                 [ 2 A , X F(X) ]

(C2) PARTITION(A+B,X);

(D2)                 [ A + B , 0 ]

(C3) PARTITION([A,B,F(A),C],A); 
(D3)                [[B,C],[A,F(A)]]

&PARTSWITCH default: [FALSE] - if set to TRUE then END is returned
when a selected part of an expression doesn't exist, otherwise an
error message is given.

&PAUSE() - Causes the display to "pause", printing "--Pause--" and
waiting for the usual "space" for "yes" to resume printing.  Then it
clears the screen and continues.  PAUSE("--Something else--"); will
use "--Something else--" as the string printed instead of "--Pause--".
PAUSE("--Something else--","--And some more--"); will use "--Something
else--" instead of "--Pause--" and "--And some more--" instead of
"--Continued--".

&PERMANENT(M,n) computes the permanent of the matrix M.  A permanent
is like a determinant but with no sign changes.

&PERSPECTIVE default: [TRUE] - In the plotting functions, if
PERSPECTIVE is set to FALSE, it causes a non-perspective view to be
taken.  This is equivalent to extending the viewing position out to
infinity along a line connecting the origin and VIEWPT.

&PFEFORMAT default: [FALSE] - if TRUE will cause rational numbers to
display in a linear form and denominators which are integers to
display as rational number multipliers.

&PI - "pi" is represented in MACSYMA as %PI.

&PICKAPART(exp,depth) will assign E labels to all subexpressions of
exp down to the specified integer depth.  This is useful for dealing
with large expressions and for automatically assigning parts of an
expression to a variable without having to use the part functions.
PICKAPART is affected by the setting of INFLAG, do DESCRIBE(INFLAG)
for details.

(C1) EXP:(A+B)/2+SIN(X^2)/3-LOG(1+SQRT(X+1));
                                                 2
                                            SIN(X )   B + A
(D1)               - LOG(SQRT(X + 1) + 1) + ------- + -----
                                               3        2

(C2) PICKAPART(%,1);

(E2)                    - LOG(SQRT(X + 1) + 1)

                                    2
                               SIN(X )
(E3)                           -------
                                  3

                                B + A
(E4)                            -----
                                  2

(D4)                         E4 + E3 + E2

&PIECE - holds the last expression selected when using the Part
functions.  It is set during the execution of the function and thus
may be referred to in the function itself.

&PLAYBACK(arg) "plays back" input and output lines.  If arg=n (a
number) the last n expressions (Ci, Di, and Ei count as 1 each) are
"played-back", while if arg is omitted, all lines are.  If arg=INPUT
then only input lines are played back. If arg=[m,n] then all lines
with numbers from m to n inclusive are played-back.  If m=n then [m]
is sufficient for arg.  Arg=SLOW places PLAYBACK in a slow-mode
similar to DEMO's (as opposed to the "fast" BATCH).  This is useful in
conjunction with SAVE or STRINGOUT when creating a secondary-storage
file in order to pick out useful expressions.  If arg=TIME then the
computation times are displayed as well as the expressions.  If
arg=GCTIME or TOTALTIME, then a complete breakdown of computation
times are displayed, as with SHOWTIME:ALL;.  Arg=STRING strings-out
(see STRING function) all input lines when playing back rather than
displaying them.  If ARG=GRIND "grind" mode can also be turned on (for
processing input lines) (see GRIND).  One may include any number of
options as in PLAYBACK([5,10],20,TIME,SLOW).

&PLOG(X) - the principal branch of the complex-valued natural
logarithm with -%PI < CARG(X) <= +%PI .

&PLOT(exp, var, low, high) produces a character-plot of the expression
exp as var (the independent variable) ranges from low to high.  An
optional fifth argument of INTEGER causes PLOT to choose only integer
values for var in the given domain.  For graphics terminals there are
routines which do more sophisticated plots, do DESCRIBE(PLOT2);
Do DESCRIBE(PLOTTING); for a more complete list of Plotting commands.

PLOT(F(x), x, [x1, x2, x3, ..., xn]) - Plots the function F(x) for the
values x1,x2,x3,...,xn.

&PLOT2(y-exprs,variable,var-range,optionals-args) plots y-exprs on the
y axis as variable (the x axis) takes on values specified by
var-range.

y-exprs can take one of two forms:
  i) expr plots a curve of expr against variable
  ii) [expr1,expr2, .. ,expri, .. ,exprn] plots n curves of expri
against variable.  expri gets evaluated in the context
FLOAT(EV(expri,variable=value gotten from var-range, NUMER)). It is an
error if this doesn't result in a floating point number.

var-range can have the following forms:
  i) low,high, where low and high evaluate to numbers.  low may be
either greater or less than high.  variable will take on PLOTNUM
values equally spaced between low and high.

(Note that the first argument will be evaluated at low first e.g.
PLOT2(1/X,X,-1,-3); calculates 1/(-1.0) before 1/(-3.0). This will
only make a difference if the computation of the first arg changes a
variable which changes the value returned by subsequent computation.
Whether or not low < high, min(low,high) will be on the left of the
plot.)

  ii) low,high,INTEGER.  As in i), except variable will take on all
integer values between low and high inclusive.
  iii) [val1,val2, ... , valn] . variable takes the values specified
by the list
  iv) arrayname where arrayname is the name of a declared
floating-point one-dimensional array (i.e. declared by
ARRAY(arrayname,FLOAT, max-index);).  variable takes the values from
arrayname[0] thru arrayname[max-index] (max-index is the maximum index
of arrayname

optional-args can be any of the following:
  i) X-Label, Y-Label or Title descriptor
  ii) Line type descriptor
  iii) FIRST, SAME and LAST
  iv) POLAR, LOG, LINLOG, LOGLIN

The optional arguments may appear in any order.  The rule for   evaluation
of the optional args is as follows.  If the argument is atomic it gets
evaluated.  The resulting arguments are the     ones that get used.

If you want to plot more than 3-4 curves on the same plot investigate
using the NOT3D option to PLOT3D.

Examples

  PLOT2(SIN(X),X,-%PI,%PI);     plots sin(X) against X as X takes on
                                PLOTNUM values between -%PI to %PI
  PLOT2(X!,X,0,6,INTEGER);      plots X! as X takes integral values
                                between 0 and 6
  F(X):=SQRT(X);
  PLOT2(F(X),X,[-2,3,100.12]);  plots F(X) as X takes the values in the
                                values in the list
  PLOT2([X+1,X^2+1],X,-1,1);    plots 2 curves on top of each other

PLOT2(y-funs,var-range,optionals-args) is the alternative form for
PLOT2.  y-funs must be a function of one argument or a list of
functions of one argument.  The functions must be either translated or
compiled functions which return a floating point number when it is
given floating point arg (or integer arg if the INTEGER arg to PLOT2
is given).  This form of PLOT2 acts as though you had given a argument
to the y-funs, and also specified that argument as the variable in the
form above. E.g. PLOT2(F,-2,2); acts like PLOT2(F(X),X,-2,2); This is
supposed to provide a quicker evaluation of the first arg and for that
reason NO checking is done on the result.  If the wrong kind of number
is returned, the resulting plot will not be meaningful.

EXAMPLE:
      TRANSLATE:TRUE;
      F(X):=(MODE_DECLARE(X,FLOAT),EXP(-X*X));
      PLOT2(F,-2,2);
      PLOT2(F,[-2,-1,0,1,2]); 
      ARRAY(V,FLOAT,10);
      FOR I FROM 0 THRU 10 DO V[I]:FLOAT(I*I);
      PLOT2(F,V);

Note:  PLOT2 does not work in Tops20 MACSYMA.

&PLOT3D(z-exprs,x-var,var-range,y-var,var1-range,optional-args) makes
a 3-dimensional plot of z-exprs against x-var and y-var.  The plot
consists of curves of y-exprs against x-var (the x coordinate) with
y-var (the y coordinate) held fixed.  Perspective is used and curves
further away from the viewer have those parts of them which are hidden
by the closer curves removed.

The format of y-exprs is the same as for PLOT2.  The context of
evaluation is FLOAT(EV(expri,x-var=value gotten from
var-range,y-var=value gotten from var1-range,NUMER)).

The format for var-range and var1-range is the same as for PLOT2
except that if var1-range is of the form low,high then y-var will take
on PLOTNUM1 values.

The format of optional-args is the same as for PLOT2 except that
additional options NOT3D, \3D, and CONTOUR are available.

PLOT3D(z-funs,var-range,var1-range,optional-args) is analogous to the
alternative form for PLOT2.  z-funs must be a function or list of
functions of 2 arguments, which must return a floating point argument
when given floating point (integer, if the INTEGER argument is used
for either var-range or var1-range) arguments.  The functions must be
translated or compiled.  If you expect to make several 3D plots this
form is recommended.

 A simple example is 
  TRANSLATE:TRUE;       causes automatic translation
  G(X,Y):=(MODECLARE(X,FLOAT),EXP(-X*X-Y*Y));   defines a funtion G
  PLOT3D(G,-2,2,-2,2);  plots it 

&PLOTBELL default: [TRUE] - when FALSE inhibits the dinging of the
bell.

&PLOTBOTMAR default: [320] - adjusts the bottom margin for XGP plots.
This defaults to values (in increments of 1/200 inch) such that the
plots will fit comfortably on an 8 1/2 x 11 page.

&PLOTHEIGHT default: [] - the height of the area used for plotting, in
terms of characters.

&PLOTNUM default: [20] is the number of points PLOT2 and PARAMPLOT2
plot when given the low,high type of variable range.  The default when
PLOT2 is first called is 20, which is sufficient for trying things
out.  100 is a suitable value for a final hard copy.

&PLOTTING - MACSYMA has a large number of PLOT commands, ranging from
simple character plots of specified functions and data points to plotting
3 dimensional surfaces.  Tektronix 4010 and 4013, Imlac PDS 1 and PDS 4
(using ARDS Graphics conventions), the XGP and the Gould Line printer
(at MIT), as well as printing and display consoles are supported by the
plot packages.  See PLOT, PLOT2, PLOT3D, GRAPH, GRAPH2, GRAPH3D,
MULTIGRAPH, PARAMPLOT, and PARAMPLOT2 for details, as well as the
file SHARE;PLOT2 USAGE.

&PLOTLFTMAR default: [128] - adjust the left margin for XGP plots.
This defaults to values (in increments of 1/200 inch) such that the
plots will fit comfortably on an 8 1/2 x 11 page.

&POISDIFF(A, B) differentiates A with respect to B.  B must occur only
in the trig arguments or only in the coefficients.

&POISEXPT(A, B) (B a positive integer) is functionally identical to
INTOPOIS(A**B).

&POISINT(A, B) integrates in a similarly restricted sense (to
POISDIFF).  Non-periodic terms in B are dropped if B is in the trig
arguments.

&POISLIM default: [5] - determines the domain of the coefficients in
the arguments of the trig functions.  The initial value of 5
corresponds to the interval [-2^(5-1)+1,2^(5-1)], or [-15,16], but it
can be set to [-2^(n-1)+1, 2^(n-1)].

&POISMAP(series, sinfn, cosfn) will map the functions sinfn on the
sine terms and cosfn on the cosine terms of the poisson series given.
sinfn and cosfn are functions of two arguments which are a coefficient
and a trigonometric part of a term in series respectively.

&POISPLUS(A, B) is functionally identical to INTOPOIS(A+B).

&POISSIMP(A) converts A into a Poisson series for A in general
representation.

&POISSON - The Symbol /P/ follows the line label of Poisson series
expressions.

&POISSUBST(A, B, C) substitutes A for B in C.  C is a Poisson series.
(1) Where B is a variable U, V, W, X, Y, or Z then A must be an
expression linear in those variables (e.g. 6*U+4*V).
(2) Where B is other than those variables, then A must also be
free of those variables, and furthermore, free of sines or cosines.

POISSUBST(A, B, C, D, N) is a special type of substitution which
operates on A and B as in type (1) above, but where D is a Poisson
series, expands COS(D) and SIN(D) to order N so as to provide the
result of substituting A+D for B in C.  The idea is that D is an
expansion in terms of a small parameter.  For example,
POISSUBST(U,V,COS(V),E,3) results in COS(U)*(1-E^2/2) -
SIN(U)*(E-E^3/6).

&POISTIMES(A, B) is functionally identical to INTOPOIS(A*B).

&POISTRIM() is a reserved function name which (if the user has defined
it) gets applied during Poisson multiplication.  It is a predicate
function of 6 arguments which are the coefficients of the U, V,..., Z
in a term.  Terms for which POISTRIM is TRUE (for the coefficients of
that term) are eliminated during multiplication.

&POLARFORM(exp) returns R*%E^(%I*THETA) where R and THETA are purely
real.  POLARFORM binds %EMODE to FALSE while it is working.

&POLARTORECT(magnitude-array, phase-array) - converts from
magnitude/phase form into real/imaginary form putting the real part in
the magnitude array and the imaginary part into the phase array
(<real>=<magnitude>*COS(<phase>) and
<imaginary>=<magnitude>*SIN(<phase>).)  This function is part of the
FFT package.  Do LOAD(FFT); to use it.  Like FFT and IFT this function
accepts 1 or 2 dimensional arrays.  However, the array dimensions need
not be a power of 2, nor need the 2D arrays be square.

&POLY_DISCRIMINANT(exp,var) - computes the discriminant of a
polynomial, with respect to var.  I.e. the square of the product of
the differences of all pairs of roots.

&POLYDECOMP(poly,var) - returns a list of polynomials
[f1(var),f2(var),...fn(var)] such that poly = f1(f2(...fn(var)...)).
There is no other decomposition which involves more polynomials
excepting linear fi.

&POLYFACTOR default: [FALSE] - when true causes ALLROOTS to factor the
polynomial over the real numbers if the polynomial is real, or over
the complex numbers, if the polynomial is complex.

&POLYGAMMA - Basic simplification routines for the polylogs and
polygamma functions have been introduced in Macsyma. We have decided
to use subscripted notation in order to be consistent with standard
reference texts for these functions.  (Note that the the Macsyma
notation doesn't imply Macsyma can produce the definitions)

POLYGAMMAS:
 Notation: PSI[N](X) = DIFF(PSI[0](X),X,N) where PSI[0](X) =
DIFF(LOG(GAMMA(X)),X)
 Simplification: Closed forms for: (in SIN, COS, or ZETA functions)
rational X, N = 0; N integral, > -1 and X integral or half-integral;
 Notes: Currently there are no numerical routines for the polygammas.
The following flags permit some control over simplification, they MUST
be set to fixnum (integer) values ...
 MAXPSIPOSINT - the largest value of the integral part of X for which
a closed form will be computed. Default: 20
 MAXPSINEGINT - for negative X > this no closed forms will be
computed. Default: -10
 The following control simplification of PSI[0](P/Q) for P and Q
integral and 0 < P/Q < 1 (i.e. the fractional part of arguments)
 MAXPSIFRACNUM - the largest P for which simplification occurs.
 MAXPSIFRACDENOM - the largest Q   "       "       "      "   
the above two default to 4.  Further details may be obtained from
WGD@MC.

&POLYGAMMAS - See POLYGAMMA.
&POLYLOGARITHM - See POLYLOGARITHMS.
&POLYLOGARITHMS - Basic simplification routines for the polylogs and
polygamma functions have been introduced in Macsyma. We have decided
to use subscripted notation in order to be consistent with standard
reference texts for these functions.  (Note that the the Macsyma
notation doesn't imply Macsyma can produce the definitions.)

POLYLOGS:
 Notation: LI[N](X) = INTEGRATE(LI[N-1](T)/T,T,0,X) where LI[1](X) = -
LOG(1-X)
 Simplification: Closed forms for argument 1, -1 when N is +integral
(involving ZETA functions); closed form for LI[2](1/2); numerical
routine for LI[2](X).  Fast numeric routines are now available for
LI[2](x) and LI[3](x).  Chebyshev expansions are used in the
approximations.

 Notes: The extension for large real values of X is adopted following
Lewin, i.e. when X is greater than unity LI[2](X) has - %I %PI LOG(X)
as its imaginary part. Currently this only concerns the numerical
routine.

&POLYLOGS - See POLYLOGARITHMS.
&POLYROOTS(polynomial) - The IMSL ZRPOLY routine for finding the zeros
of simple polynomials (single variable, real coefficients,
non-negative integer exponents), using the Jenkins-Traub technique.
To use it, do:  LOADFILE(IMSL,FASL,SHARE2);
For more info, do: PRINTFILE(ZRPOLY,USAGE,SHARE2);
For a demo do: DEMO(ZRPOLY,DEMO,SHARE2); 
For general info on MACSYMA-IMSL packages, PRINTFILE(IMSL,USAGE,SHARE2);
Bugs/Comments/Questions to KMP@MC.

&POLYSIGN(X) - same as SIGNUM but always returns a numerical result by
looking at the numerical factor of the highest degree term in X.

&POLYSOLVE(exp,var) - a program for finding the roots of polynomials.
For information on how to use this program do
BATCH(POLSOL,DEMO,DSK,SHARE2);.  To access the package use
LOAD(POLSOL);.

&POSFUN - POSitive FUNction, e.g. DECLARE(F,POSFUN); IS(F(X)>0); ->
TRUE.

&POSTFIX - POSTFIX operators like the PREFIX variety denote functions
of a single argument, but in this case the argument immediately
precedes an occurrence of the operator in the input string, e.g. 3! .
The POSTFIX("x") function is a syntax extension function to declare x
to be a POSTFIX operator.  Do DESCRIBE(SYNTAX); for details.

&POTENTIAL(givengradient) - The calculation makes use of the global
variable POTENTIALZEROLOC[0], which must be NONLIST or of the form
[indeterminatej=expressionj, indeterminatek=expressionk, ...], the
former being equivalent to the nonlist expression for all right-hand
sides in the latter.  The indicated right-hand sides are used as the
lower limit of integration.  The success of the integrations may
depend upon their values and order.  POTENTIALZEROLOC is initially set
to 0.

&POWERDISP default: [FALSE] - if TRUE will cause sums to be displayed
with their terms in the reverse order.  Thus polynomials would display
as truncated power series, i.e., with the lowest power first.

&POWERS(expr, var) gives the powers of var occuring in expr.  To use
it, do LOAD(POWERS);.  For details on usage, do
PRINTFILE(POWERS,USAGE,SHARE2);.

&POWERSERIES(exp, var, pt) generates the general form of the power
series expansion for exp in the variable var about the point pt (which
may be INF for infinity).  If POWERSERIES is unable to expand exp, the
TAYLOR function may give the first several terms of the series.

VERBOSE[FALSE] - if TRUE will cause comments about the progress of
POWERSERIES to be printed as the execution of it proceeds.


(C1) VERBOSE:TRUE$

(C2) POWERSERIES(LOG(SIN(X)/X),X,0);
Can't expand 
                                 LOG(SIN(X))

So we'll try again after applying the rule:
                                        d
                                      / -- (SIN(X))
                                      [ dX
                        LOG(SIN(X)) = I ----------- dX
                                      ]   SIN(X)
                                      /

In the first simplification we have returned:
                             /
                             [
                             I COT(X) dX - LOG(X)
                             ]
                             /


                    INF
                    ====        I1  2 I1             2 I1
                    \      (- 1)   2     BERN(2 I1) X
                     >     ------------------------------
                    /                I1 (2 I1)!
                    ====
                    I1 = 1
(D2)                -------------------------------------
                                      2
&PRED (EVFLAG) causes predicates (expressions which evaluate to TRUE
or FALSE) to be evaluated.

&PREDERROR default: [TRUE] - If TRUE, an error message is signalled
whenever the predicate of an IF statement or an IS function fails to
evaluate to either TRUE or FALSE.  If FALSE, UNKNOWN is returned
instead in this case.  The PREDERROR:FALSE mode is not supported in
translated code.

&PREFIX - A PREFIX operator is one which signifies a function of one
argument, which argument immediately follows an occurrence of the
operator.  PREFIX("x") is a syntax extension function to declare x to
be a PREFIX operator.  Do DESCRIBE(SYNTAX); for more details.

&PRIME(n) gives the nth prime. MAXPRIME[489318] is the largest number
accepted as argument.  Note:  The PRIME command does not work in
Tops20 MACSYMA.

&PRIMEP(n) returns TRUE if n is a prime, FALSE if not.

&PRIMER() starts up the on-line PRIMER in MACSYMA.  The first time it
is run by a particular user, the script CONSOLEPRIMER is gone through
to make sure the user knows how to use a console.  Subsequently it
will start up offering a list of scripts to choose from.

PRIMER(script) will start it with a particular script.

At DDT level the command  :TEACHMACSYMA will start MACSYMA and start
up the PRIMER automatically.

&PRINT(exp1, exp2, ...)  evaluates and displays its arguments one
after the other "on a line" starting at the leftmost position.  If
expi is unbound or is preceded by a single quote or is enclosed in "s
then it is printed literally.  For example, PRINT("THE VALUE OF X IS
",X).  The value returned by PRINT is the value of its last argument.
No intermediate lines are generated.  (For "printing" files, see
the PRINTFILE function.)

&PRINTDISKUSE(username) displays in English information about a user's
disk usage.

&PRINTFILE(file-specification) prints the contents of the file
specified on the user's terminal (this is equivalent to going up to
DDT level and using the :PRINT command).

&PRINTPOIS(A) prints a Poisson series in a readable format.  In common
with OUTOFPOIS, it will convert A into a Poisson encoding first, if
necessary.

&PRINTPROPS(a, i) will display the property with the indicator i
associated with the atom a. a may also be a list of atoms or the atom
ALL in which case all of the atoms with the given property will be
used.  For example, PRINTPROPS([F,G],ATVALUE).  PRINTPROPS is for
properties that cannot otherwise be displayed, i.e. for
ATVALUE, ATOMGRAD, GRADEF, and MATCHDECLARE.

&PRODHACK default: [FALSE] - if set to TRUE then PRODUCT(F(I),I,3,1); 
will yield 1/F(2), by the identity 
PRODUCT(F(I),I,A,B) = 1/PRODUCT(F(I),I,B+1,A-1) when A>B.

&PRODUCT(exp, ind, lo, hi) gives the product of the values of exp as
the index ind varies from lo to hi.  The evaluation is similar to that
of SUM.  No simplification of products is available at this time.
If hi is one less than lo, we have an "empty product" and PRODUCT 
returns 1 rather than erring out.  Also see DESCRIBE(PRODHACK).

(C1)  PRODUCT(X+I*(I+1)/2,I,1,4);

(D1)             (X + 1) (X + 3) (X + 6) (X + 10)

&PROGRAMMODE default: [TRUE] - when FALSE will cause SOLVE, REALROOTS,
ALLROOTS, and LINSOLVE to print E-labels (intermediate line labels) to
label answers.  When TRUE, SOLVE, etc. return answers as elements in a
list.  (Except when BACKSUBST is set to FALSE, in which case
PROGRAMMODE:FALSE is also used.)

&PROMPT default: [_] is the prompt symbol of the DEMO function,
PLAYBACK(SLOW) mode, and (MACSYMA-BREAK).

&PROPERTIES(a) will yield a list showing the names of all the
properties associated with the atom a.

&PROPS - atoms which have any property other than those explicitly
mentioned in INFOLISTS, such as atvalues, matchdeclares, etc. as well
as properties specified in the DECLARE function.

&PROPVARS(prop) - yields a list of those atoms on the PROPS list which
have the property indicated by prop.  Thus PROPVARS(ATVALUE) will
yield a list of atoms which have atvalues.

&PSEXPAND default: [FALSE] - if TRUE will cause extended rational
function expressions to display fully expanded.  (RATEXPAND will also
cause this.)  If FALSE, multivariate expressions will be displayed
just as in the rational function package.  If PSEXPAND:MULTI, then
terms with the same total degree in the variables are grouped
together.

&PSI(X) - derivative of LOG(GAMMA(X)).  At this time, MACSYMA does not
have numerical evaluation capabilities for PSI.  For information on
the PSI[N](X) notation, see POLYGAMMA.

&PUT(a, p, i) associates with the atom a the property p with the
indicator i.  This enables the user to give an atom any arbitrary
property.

&QLISTFILES(DSK,username) "Quick LISTFILES" lists the names of your
files.  See also LISTFILES.

&QPUT(a, p, i) is similar to PUT but it doesn't have its arguments
evaluated.

&QQ - The file SHARE1;QQ FASL (which may be loaded with LOAD("QQ");)
contains a function QUANC8 which can take either 3 or 4 arguments. The
3 arg version computes the integral of the function specified as the
first argument over the interval from lo to hi as in
QUANC8('function name,lo,hi); .
The function name should be quoted.  The 4 arg version will compute
the integral of the function or expression (first arg) with respect to
the variable (second arg) over the interval from lo to hi as in
QUANC8(<f(x) or expression in x>,x,lo,hi).

The method used is the Newton-Cotes 8th order polynomial quadrature,
and the routine is adaptive. It will thus spend time dividing the
interval only when necessary to achieve the error conditions specified
by the global variables QUANC8_RELERR (default value=1.0e-4) and
QUANC8_ABSERR (default value=1.0e-8) which give the relative error
test:
|integral(function)-computed value|< quanc8_relerr*|integral(function)|
and the absolute error test:
|integral(function)-computed value|<quanc8_abserr. 

Do PRINTFILE(QQ,USAGE,SHARE1) for details.

&QUANC8('function name,lo,hi) - An adaptive integrator, available in
SHARE1;QQ FASL.  DEMO and USAGE files are provided.  The method is to
use Newton-Cotes 8-panel quadrature rule, hence the function name
QUANC8, available in 3 or 4 arg versions.  Absolute and relative error
checks are used.  To use it do LOAD("QQ");  For more details do
DESCRIBE(QQ); .

&QUIT() kills the current MACSYMA but doesn't affect the user's other
jobs.  (Equivalent to ^Z and :KILL).  [Note: on Tops-20 this halts the
job but does not kill it.]

The "quit" character for MACSYMA is Control-G (^G).  This will get you
back to MACSYMA Top-level from any point.  Control-X (^X) will cause
a quit in a computation started within a MACSYMA-BREAK without disrupting
the suspended main computation.

&QUNIT(n) gives the principal unit of the real quadratic number field
SQRT(n) where n is an integer, i.e.  the element whose norm is unity.
This amounts to solving Pell's equation A**2- n*B**2=1.

(C1) QUNIT(17);
(D1)              SQRT(17)+4

(C2)  EXPAND(%*(SQRT(17)-4));

(D2)               1

&QUOTIENT(p1, p2, var1, ...) computes the quotient of the polynomial
p1 divided by the polynomial p2.

&RADCAN(exp) simplifies exp, which can contain logs, exponentials, and
radicals, by converting it into a form which is canonical over a large
class of expressions and a given ordering of variables; that is, all
functionally equivalent forms are mapped into a unique form.  For a
somewhat larger class of expressions, RADCAN produces a regular form.
Two equivalent expressions in this class will not necessarily have the
same appearance, but their difference will be simplified by RADCAN to
zero.  For some expressions RADCAN can be quite time consuming.  This
is the cost of exploring certain relationships among the components of
the expression for simplifications based on factoring and
partial-fraction expansions of exponents.  %E_TO_NUMLOG (default:
[FALSE]) - when set to TRUE, for "r" some rational number, and "x" some
expression, %E^(r*LOG(x)) will be simplified into x^r .

RADEXPAND[TRUE] when set to FALSE will inhibit certain
transformations: RADCAN(SQRT(1-X)) will remain SQRT(1-X) and will not
become %I SQRT(X-1).  RADCAN(SQRT(X^2-2*X+1)) will remain SQRT(X^2-2*X
+ 1) and will not be transformed to X- 1.

Do EXAMPLE(RADCAN); for examples.

&RADEXPAND default: [TRUE] - if set to ALL will cause nth roots of
factors of a product which are powers of n to be pulled outside of the
radical.  E.g. if RADEXPAND is ALL, SQRT(16*X^2) will become 4*X .
More particularly, consider SQRT(X^2).
(a) If RADEXPAND is ALL or ASSUME(X>0) has been done, SQRT(X^2) will 
become X.
(b) If RADEXPAND is TRUE and DOMAIN is REAL (its default), SQRT(X^2) 
will become ABS(X).
(c) If RADEXPAND is FALSE, or RADEXPAND is TRUE and DOMAIN is COMPLEX, 
SQRT(X^2) will be returned.
(The notion of DOMAIN with settings of REAL or COMPLEX is still in 
its infancy.  Note that its setting here only matters when RADEXPAND is 
TRUE.)

&RADPRODEXPAND - this switch has been renamed RADEXPAND.

&RADSUBSTFLAG default: [FALSE] - if TRUE permits RATSUBST to make
substitutions such as U for SQRT(X) in X.

&RAISERIEMANN(dis) returns the contravariant components of the Riemann
curvature tensor as array elements UR[I,J,K,L].  These are displayed
if dis is TRUE.

&RANDOM(X) - returns a random integer between 0 and X-1.  X must be a
FIXNUM.  If no argument is given, the random integer produced will be
dependent on the particular machine.  For MC it will produce a random
integer between -2^(35) and 2^(35) -1.  If X is FALSE then the random
sequence is restarted from the beginning.

&RANK(M) computes the rank of the matrix M.  That is, the order of the
largest non-singular subdeterminant of M.  Caveat: RANK may return the
wrong answer if it cannot determine that a matrix element that is
equivalent to zero is indeed so.

&RASSOCIATIVE - If DECLARE(G,RASSOCIATIVE); is done, this tells the
simplifier that G is right-associative.  E.g. 
G(G(A,B),G(C,D)) will simplify to G(A,G(B,G(C,D))).

&RAT(exp, v1, ..., vn) converts exp to CRE form by expanding and
combining all terms over a common denominator and cancelling out the
greatest common divisor of the numerator and denominator as well as
converting floating point numbers to rational numbers within a
tolerance of RATEPSILON[2.0E-8].  The variables are ordered according
to the v1,...,vn as in RATVARS, if these are specified.  RAT does not
generally simplify functions other than + , - , * , / , and
exponentiation to an integer power whereas RATSIMP does handle these
cases.  Note that atoms (numbers and names) in CRE form are not the
same as they are in the general form.  Thus RAT(X)- X results in
RAT(0) which has a different internal representation than 0.

RATFAC[FALSE] when TRUE invokes a partially factored form for CRE
rational expressions.  During rational operations the expression is
maintained as fully factored as possible without an actual call to the
factor package.  This should always save space and may save some time
in some computations.  The numerator and denominator are still made
relatively prime (e.g.  RAT((X^2 -1)^4/(X+1)^2); yields
(X-1)^4*(X+1)^2), but the factors within each part may not be
relatively prime.

RATPRINT[TRUE] if FALSE suppresses the printout of the message
informing the user of the conversion of floating point numbers to
rational numbers.

KEEPFLOAT[FALSE] if TRUE prevents floating point numbers from being
converted to rational numbers.

(Also see the RATEXPAND and  RATSIMP functions.)

(C1) ((X-2*Y)**4/(X**2-4*Y**2)**2+1)*(Y+A)*(2*Y+X)
        /(4*Y**2+X**2);
                                           4
                                  (X - 2 Y)
              (Y + A) (2 Y + X) (------------ + 1)
                                   2      2 2
                                 (X  - 4 Y )
(D1)          ------------------------------------
                              2    2
                           4 Y  + X

(C2) RAT(%,Y,A,X);
                            2 A + 2 Y
(D2)/R/                     ---------
                             X + 2 Y

&RATALGDENOM default: [TRUE] - if TRUE allows rationalization of
denominators wrt.  radicals to take effect.  To do this one must use
CRE form with the ALGEBRAIC switch set to TRUE, i.e. ALGEBRAIC:TRUE$

&RATCOEF(exp, v, n) returns the coefficient, C, of the expression v**n
in the expression exp.  n may be omitted if it is 1.  C will be free
(except possibly in a non-rational sense) of the variables in v.  If
no coefficient of this type exists, zero will be returned.  RATCOEF
expands and rationally simplifies its first argument and thus it may
produce answers different from those of COEFF which is purely
syntactic.  Thus RATCOEF((X+1)/Y+X,X) returns (Y+1)/Y whereas COEFF
returns 1.  RATCOEF(exp,v,0), viewing exp as a sum, gives a sum of
those terms which do not contain v.  Therefore if v occurs to any
negative powers, RATCOEF should not be used.  Since exp is rationally
simplified before it is examined, coefficients may not appear quite
the way they were envisioned.

(C1) S:A*X+B*X+5$

(C2) RATCOEF(S,A+B);

(D2)               X

&RATDENOM(exp) obtains the denominator of the rational expression exp.
If exp is in general form then the DENOM function should be used
instead, unless one wishes to get a CRE result.

&RATDENOMDIVIDE default: [TRUE] - if FALSE will stop the splitting up
of the terms of the numerator of RATEXPANDed expressions from
occurring.

&RATDIFF(exp, var) differentiates the rational expression exp (which
must be a ratio of polynomials or a polynomial in the variable var)
with respect to var.  For rational expressions this is much faster
than DIFF.  The result is returned in CRE form if the argument is in
CRE form, otherwise it is returned in general representation.
However, RATDIFF should not be used on factored CRE forms; use DIFF
instead for such expressions.

(C1) (4*X^3+10*X-11)/(X^5+5);

                                         3
                                      4 X  + 10 X - 11
(D1)                                  ----------------
                                            5
                                           X  + 5

(C2) MODULUS:3$

(C3) MOD(D1);
                                2
                               X  + X - 1
(D3)                      --------------------
                           4    3    2
                          X  + X  + X  + X + 1

(C4) RATDIFF(D1,X);
                          5    4    3
                         X  - X  - X  + X - 1
(D4)                ------------------------------
                     8    7    5    4    3
                    X  - X  + X  - X  + X  - X + 1

&RATDISREP(exp) changes its argument from CRE form to general form.
This is sometimes convenient if one wishes to stop the "contagion", or
use rational functions in non-rational contexts.  Most CRE functions
will work on either CRE or non-CRE expressions, but the answers may
take different forms.  If RATDISREP is given a non-CRE for an
argument, it returns its argument unchanged.  See also TOTALDISREP.

&RATEINSTEIN default: [] - if TRUE rational simplification will be
performed on the non-zero components of Einstein tensors; if
FACRAT:TRUE then the components will also be factored.

&RATEPSILON default: [2.0E-8] - the tolerance used in the conversion
of floating point numbers to rational numbers.

&RATEXPAND(exp) expands exp by multiplying out products of sums and
exponentiated sums, combining fractions over a common denominator,
cancelling the greatest common divisor of the numerator and
denominator, then splitting the numerator (if a sum) into its
respective terms divided by the denominator.  This is accomplished by
converting exp to CRE form and then back to general form.

The switch RATEXPAND, default: [FALSE], if TRUE will cause CRE
expressions to be fully expanded when they are converted back to
general form or displayed, while if it is FALSE then they will be put
into a recursive form. (see RATSIMP)

RATDENOMDIVIDE[TRUE] - if FALSE will stop the splitting up of the
terms of the numerator of RATEXPANDed expressions from occurring.

KEEPFLOAT[FALSE] if set to TRUE will prevent floating point numbers
from being rationalized when expressions which contain them are
converted to CRE form.

(C1) RATEXPAND((2*X-3*Y)**3);

                3         2       2        3
(D1)      - 27 Y  + 54 X Y  - 36 X  Y + 8 X

(C2) (X-1)/(X+1)**2+1/(X-1);

                              X - 1       1
(D2)                         -------- + -----
                                    2   X - 1
                             (X + 1)

(C3) EXPAND(D2);

                         X              1           1
(D3)                ------------ - ------------ + -----
                     2              2             X - 1
                    X  + 2 X + 1   X  + 2 X + 1

(C4) RATEXPAND(D2);

                             2
                          2 X                 2
(D4)                 --------------- + ---------------
                      3    2            3    2
                     X  + X  - X - 1   X  + X  - X - 1


&RATFAC default: [FALSE] - when TRUE invokes a partially factored form
for CRE rational expressions.  During rational operations the
expression is maintained as fully factored as possible without an
actual call to the factor package.  This should always save space and
may save some time in some computations.  The numerator and
denominator are still made relatively prime, for example

RAT((X^2 -1)^4/(X+1)^2);  yields (X-1)^4*(X+1)^2),

but the factors within each part may not be relatively prime.

In the CTENSR (Component Tensor Manipulation) Package, if RATFAC is
TRUE, it causes the Ricci, Einstein, Riemann, and Weyl tensors and the
Scalar Curvature to be factored automatically.  ** This should only be
set for cases where the tensorial components are known to consist of
few terms **.

Note: The RATFAC and RATWEIGHT schemes are incompatible and may not
both be used at the same time.

&RATMX default: [FALSE] - if FALSE will cause determinant and matrix
addition, subtraction, and multiplication to be performed in the
representation of the matrix elements and will cause the result of
matrix inversion to be left in general representation.  If it is TRUE,
the 4 operations mentioned above will be performed in CRE form and the
result of matrix inverse will be in CRE form.  Note that this may
cause the elements to be expanded (depending on the setting of RATFAC)
which might not always be desired.

&RATNUMER(exp) obtains the numerator of the rational expression exp.
If exp is in general form then the NUM function should be used
instead, unless one wishes to get a CRE result.

&RATNUMP(exp) is TRUE if exp is a rational number (includes integers)
else FALSE.

&RATP(exp) is TRUE if exp is in CRE or extended CRE form else FALSE.

&RATPRINT default: [TRUE] - if FALSE suppresses the printout of the
message informing the user of the conversion of floating point numbers
to rational numbers.

&RATRIEMAN - This switch has been renamed RATRIEMANN.
&RATRIEMANN default: [] - one of the switches which controls
simplification of Riemann tensors; if TRUE, then rational
simplification will be done; if FACRAT:TRUE then each of the
components will also be factored.

&RATSIMP(exp) "rationally" simplifies (similar to RATEXPAND) the
expression exp and all of its subexpressions including the arguments
to non- rational functions.  The result is returned as the quotient of
two polynomials in a recursive form, i.e.  the coefficients of the
main variable are polynomials in the other variables.  Variables may,
as in RATEXPAND, include non-rational functions (e.g. SIN(X**2+1) )
but with RATSIMP, the arguments to non-rational functions are
rationally simplified.  Note that RATSIMP is affected by some of the
variables which affect RATEXPAND.

RATSIMP(exp,v1,v2,...,vn) - enables rational simplification with the
specification of variable ordering as in RATVARS.

RATSIMPEXPONS[FALSE] - if TRUE will cause exponents of expressions to
be RATSIMPed automatically during simplification.

(C1) SIN(X/(X^2+X))=%E^((LOG(X)+1)**2-LOG(X)**2);

                                           2          2
                    X          (LOG(X) + 1)  - LOG (X)
(D1)          SIN(------) = %E
                   2
                  X  + X

(C2) RATSIMP(%);
                                  1          2
(D2)                        SIN(-----) = %E X
                                X + 1

(C3) ((X-1)**(3/2)-(X+1)*SQRT(X-1))/SQRT((X-1)*(X+1));

                       3/2
                (X - 1)    - SQRT(X - 1) (X + 1)
(D3)            --------------------------------
                    SQRT(X - 1) SQRT(X + 1)

(C4) RATSIMP(%);

                                 2
(D4)                      - -----------
                            SQRT(X + 1)

(C5)  X**(A+1/A),RATSIMPEXPONS:TRUE;

                    2
                   A  + 1
                   ------
                     A
(D5)              X

&RATSIMPEXPONS default: [FALSE] - if TRUE will cause exponents of
expressions to be RATSIMPed automatically during general
simplification.

&RATSUBST(a, b, c) substitutes a for b in c.  b may be a sum, product,
power, etc.  RATSUBST knows something of the meaning of expressions
whereas SUBST does a purely syntactic substitution.  Thus
SUBST(A,X+Y,X+Y+Z) returns X+Y+Z whereas RATSUBST would return Z+A.

RADSUBSTFLAG[FALSE] if TRUE permits RATSUBST to make substitutions
like U for SQRT(X) in X.

Do EXAMPLE(RATSUBST); for examples.

&RATVARS(var1, var2, ..., varn) forms its n arguments into a list in
which the rightmost variable varn will be the main variable of future
rational expressions in which it occurs, and the other variables will
follow in sequence.  If a variable is missing from the RATVARS list,
it will be given lower priority than the leftmost variable var1. The
arguments to RATVARS can be either variables or non-rational functions
(e.g. SIN(X)).  The variable RATVARS is a list of the arguments which
have been given to this function.

&RATWEIGHT(v1, w1, ..., vn, wn) assigns a weight of wi to the variable
vi.  This causes a term to be replaced by 0 if its weight exceeds the
value of the variable RATWTLVL [default is FALSE which means no
truncation].  The weight of a term is the sum of the products of the
weight of a variable in the term times its power.  Thus the weight of
3*v1**2*v2 is 2*w1+w2.  This truncation occurs only when multiplying
or exponentiating CRE forms of expressions.

(C5) RATWEIGHT(A,1,B,1);

(D5)                         [[B, 1], [A, 1]]

(C6) EXP1:RAT(A+B+1)$

(C7) %**2;
                      2                  2
(D7)/R/              B  + (2 A + 2) B + A  + 2 A + 1

(C8) RATWTLVL:1$

(C9) EXP1**2;
(D9)/R/                       2 B + 2 A + 1

Note: The RATFAC and RATWEIGHT schemes are incompatible and may not
both be used at the same time.

&RATWEIGHTS - a list of weight assignments (set up by the RATWEIGHT
function), RATWEIGHTS; or RATWEIGHT(); will show you the list.
KILL(...,RATWEIGHTS), and SAVE(...,RATWEIGHTS); both work.

&RATWEYL default: [] - one of the switches controlling the
simplification of components of the Weyl conformal tensor; if TRUE,
then the components will be rationally simplified; if FACRAT is TRUE
then the results will be factored as well.

&RATWTLVL default: [FALSE] - used in combination with the RATWEIGHT
function to control the truncation of rational (CRE form) expressions
(for the default value of FALSE, no truncation occurs).

&READ(string1, ...) prints its arguments, then reads in and evaluates
one expression.  For example: A:READ("ENTER THE NUMBER OF VALUES").

&READ_NTH_OBJECT(n,symbol-returned-by-OPEN_INDEX_FILE) - returns the
n'th object in an indexed file.  See DESCRIBE(OPEN_INDEX_FILE);.

&READONLY(string1,...) prints its arguments, then reads in an
expression (which in contrast to READ is not evaluated).

&REALONLY default: [FALSE] - if TRUE causes ALGSYS to return only
those solutions which are free of %I.

&REALPART(exp) gives the real part of exp.  REALPART and IMAGPART will
work on expressions involving trigonometic and hyperbolic functions,
as well as SQRT, LOG, and exponentiation.

&REALROOTS(poly, bound) finds all of the real roots of the real
univariate polynomial poly within a tolerance of bound which, if less
than 1, causes all integral roots to be found exactly.  The parameter
bound may be arbitrarily small in order to achieve any desired
accuracy.  The first argument may also be an equation.  REALROOTS sets
MULTIPLICITIES, useful in case of multiple roots.  REALROOTS(poly) is
equivalent to REALROOTS(poly,ROOTSEPSILON).  ROOTSEPSILON[1.0E-7] is a
real number used to establish the confidence interval for the roots.
Do EXAMPLE(REALROOTS); for an example.

&REARRAY(array,dim1, ... ,dimk) can be used to change the size or
dimensions of an array.  The new array will be filled with the
elements of the old one in row-major order.  If the old array was too
small, FALSE, 0.0 or 0 will be used to fill the remaining elements,
depending on the type of the array.  The type of the array cannot be
changed.

&RECTFORM(exp) returns an expression of the form A + B*%I, where A and
B are purely real.

&RECTTOPOLAR(real-array, imag-array) - undoes POLARTORECT.  The
phase is given in the range from -%PI to %PI.  This function is part
of the FFT package.  Do LOAD(FFT); to use it.  Like FFT and IFT this
function accepts 1 or 2 dimensional arrays.  However, the array
dimensions need not be a power of 2, nor need the 2D arrays be square.

&REFCHECK default: [FALSE] - if TRUE causes a message to be printed
each time a bound variable is used for the first time in a
computation.

&REM(a, i) removes the property indicated by i from the atom a.

&REMAINDER(p1, p2, var1, ...) computes the remainder of the polynomial
p1 divided by the polynomial p2.

&REMARRAY(name1, name2, ...) removes arrays and array associated
functions and frees the storage occupied.  If name is ALL then all
arrays are removed.  It may be necessary to use this function if it is
desired to redefine the values in a hashed array.

&REMBOX(expr, arg) removes boxes from expr according to arg.  If arg
is UNLABELED then all unlabelled boxes are removed.  If arg is the
name of some label then only boxes with that label are removed.  If
arg is omitted then all boxes labelled and unlabelled are removed.

&REMCON(tensor1,tensor2,...)  removes all the contraction properties
from the tensori.  REMCON(ALL) removes all contraction properties from
all indexed objects.

&REMFILE() removes files created by the secondary storage scheme in
the MACSYMA under use.  REMFILE(TRUE) does what REMFILE() does and in
addition deletes any files which have been created by the SAVE or
STORE functions but which have not been assigned names by the user.

&REMFUNCTION(f1, f2, ...)  removes the user defined functions
f1,f2,... from MACSYMA.  If there is only one argument of ALL then all
functions are removed.

&REMLET(prod, name) deletes the substitution rule, prod --> repl, most
recently defined by the LET function.  If name is supplied the rule is
deleted from the rule package name.  REMLET() and REMLET(ALL) delete
all substitution rules from the current rulepackage. If the name of a
rulepackage is supplied, e.g. REMLET(ALL,name), the rulepackage, name,
is also deleted.  If a substitution is to be changed using the same
product, REMLET need not be called, just redefine the substitution
using the same product (literally) with the LET function and the new
replacement and/or predicate name.  Should REMLET(product) now be
called the original substitution rule will be revived.

&REMOVE(args) will remove some or all of the properties associated
with variables or functions.

REMOVE(a1, p1, a2, p2, ...)  removes the property pi from the atom ai.
Ai and pi may also be lists as with DECLARE.  Pi may be any property
e.g.  FUNCTION, MODE_DECLARE, etc.  It may also be TRANSFUN implying
that the translated LISP version of the function is to be removed.
This is useful if one wishes to have the MACSYMA version of the
function executed rather than the translated version. Pi may also be
OP or OPERATOR to remove a syntax extension given to ai (see Appendix
II).  If ai is "ALL" then the property indicated by pi is removed from
all atoms which have it.  Unlike the more specific remove functions
(REMVALUE, REMARRAY, REMFUNCTION, and REMRULE) REMOVE does not
indicate when a given property is non-existent; it always returns
"DONE".

&REMRULE(function, rulename) will remove a rule with the name rulename
from the function which was placed there by DEFRULE, DEFMATCH,
TELLSIMP, or TELLSIMPAFTER.  If rule-name is ALL, then all rules will
be removed.

&REMTRACE() - This function is no longer used with the new TRACE
package.

&REMVALUE(name1, name2, ...) removes the values of user variables
(which can be subscripted) from the system.  If name is ALL then the
values of all user variables are removed.  Values are those items
given names by the user as opposed to those which are automatically
labeled by MACSYMA as Ci, Di, or Ei.

&RENAME(exp) returns an expression equivalent to exp but with the
dummy indices in each term chosen from the set [!1,!2,...].  Each
dummy index in a product will be different; for a sum RENAME will try
to make each dummy index in a sum the same.  In addition, the indices
will be sorted alphanumerically.

&RENAMEFILE(oldfilename, newfilename) - Gives a new name to a file.
Oldfilename may name any file. It should use the list filename format
- eg, [MYOLD,FILE,DSK,USERS5].  Newfilename must be a filename on the
same device and directory.  Hence only filename1 and filename2 should
be specified.  For example, [MYNEW,FILE].  Attempting to change the
name of a file that does not exist, or to rename a file to the name of
a file that exists already will generate an error; hence, it is not
possible to inadvertently destroy a file using this command.

&RESET() causes all MACSYMA options to be set to their default values.
(Please note that this does not include features of terminals such as
LINEL which can only be changed by assignment as they are not
considered to be computational features of MACSYMA.)

&RESIDUE(exp, var, val) computes the residue in the complex plane of
the expression exp when the variable var assumes the value val.  The
residue is the coefficient of (var-val)**(-1) in the Laurent series
for exp.

(C1) RESIDUE(S/(S**2+A**2),S,A*%I);

                        1
(D1)                    -
                        2

(C2) RESIDUE(SIN(A*X)/X**4,X,0);

                        3
                       A
(D2)                 - --
                       6

&REST(exp, n) yields exp with its first n elements removed if n is
positive and its last -n elements removed if n is negative.  If n is 1
it may be omitted.  Exp may be a list, matrix, or other expression.
REST is affected by the setting of INFLAG, do DESCRIBE(INFLAG) for
details.

&RESTORE(file-specification) reinitializes all quantities filed away
by a use of the SAVE or STORE functions, in a prior MACSYMA session,
from the file given by file-specification without bringing them into
core.

&RESULTANT(p1, p2, var) computes the resultant of the two polynomials
p1 and p2, eliminating the variable var.  The resultant is a
determinant of the coefficients of var in p1 and p2 which equals zero
if and only if p1 and p2 have a non-constant factor in common.  If p1
or p2 can be factored, it may be desirable to call FACTOR before
calling RESULTANT.

RESULTANT[SUBRES] - controls which algorithm will be used to compute
the resultant.  SUBRES for subresultant prs [the default], MOD for
modular resultant algorithm, and RED for reduced prs.  On most
problems SUBRES should be best.  On some large degree univariate or
bivariate problems MOD may be better.  Another alternative is the
BEZOUT command which takes the same arguments as RESULTANT and returns
a matrix.  DETERMINANT of this matrix is the desired resultant.

&RETURN(value) - may be used to exit explicitly from a BLOCK, bringing
its argument.  Do DESCRIBE(BLOCK); for more information.

&REVEAL(exp,depth) will display exp to the specified integer depth
with the length of each part indicated.  Sums will be displayed as
Sum(n) and products as Product(n) where n is the number of subparts of
the sum or product.  Exponentials will be displayed as Expt.  REVEAL
is affected by the setting of INFLAG, do DESCRIBE(INFLAG) for details.

(C1) INTEGRATE(1/(X^3+2),X)$

(C2) REVEAL(%,2);

(D2)                    Negterm + Quotient + Quotient

(C3) REVEAL(D1,3);
                                     ATAN         LOG
(D3)                 - Quotient + ---------- + ----------
                                  Product(2)   Product(2)

&REVERSE(list) - reverses the order of the members of the list (not
the members themselves).  REVERSE also works on general expressions,
e.g.  REVERSE(A=B); gives B=A.

REVERSE default: [FALSE] - in the Plotting functions, if TRUE cause a
left-handed coordinate system to be assumed.

&REVERT(expression,variable) - Does reversion of Taylor Series.
"Variable" is the variable the original Taylor expansion is in.  Do
LOAD(REVERT) to access this function.  Try
REVERT2(expression,variable,hipower) also.  REVERT only works on
expansions around 0.

&RHS(eqn) the right side of the equation eqn.  If eqn is not an
equation, RHS(exp) returns 0.

&RICCI - The Ricci tensor, do DESCRIBE(RICCICOM);

&RICCICOM(dis) (Tensor package) This function first computes the
covariant components LR[i,j] of the Ricci tensor (LR is a mnemonic for
"lower Ricci").  Then the mixed Ricci tensor is computed using the
contravariant metric tensor.  If the value of the argument to RICCICOM
is TRUE, then these mixed components, RICCI[i,j] (the index i is
covariant and the index j is contravariant), will be displayed
directly.  Otherwise, RICCICOM(FALSE) will simply compute the entries
of the array RICCI[i,j] without displaying the results.

&RIEMANN(dis) - A function in the CTENSR (Component Tensor
Manipulation) Package.  RIEMANN computes the Riemann curvature tensor
from the given metric and the corresponding Christoffel symbols.  If
dis is TRUE, the non-zero components R[i,j,k,l] will be displayed. All
the indicated indices are covariant.  As with the Einstein tensor,
various switches set by the user control the simplification of the
components of the Riemann tensor.  If RATRIEMAN[TRUE] is TRUE then
rational simplification will be done. If RATFAC[FALSE] is TRUE then
each of the components will also be factored.

&RINVARIANT() (Tensor package) forms the invariant obtained by
contracting the tensors R[i,j,k,l]*UR[i,j,k,l].  This object is not
automatically simplified since it can be very large.

&RISCH(exp, var) integrates exp with respect to var using the
transcendental case of the Risch algorithm.  (The algebraic case of
the Risch algorithm has not been implemented.)  This currently
handles the cases of nested exponentials and logarithms which the main
part of INTEGRATE can't do.  INTEGRATE will automatically apply RISCH
if given these cases.

ERFFLAG[TRUE] - if FALSE prevents RISCH from introducing the ERF
function in the answer if there were none in the integrand to begin
with.

(C1) RISCH(X^2*ERF(X),X);

            2     2
         - X     X             3           2
       %E     (%E   SQRT(%PI) X  ERF(X) + X  + 1)
(D1)   ------------------------------------------
                      3 SQRT(%PI)

(C2) DIFF(%,X),RATSIMP;
                                 2
(D2)                            X  ERF(X)

&RMXCHAR default: []] - The character used to display the (right)
delimiter of a matrix (see also LMXCHAR).

&RNCOMBINE(exp) transforms exp by combining all terms of exp that have
identical denominators or denominators that differ from each other by
numerical factors only.  This is slightly different from the behavior
of COMBINE, which collects terms that have identical denominators.
Setting PFEFORMAT:TRUE and using COMBINE will achieve results similar
to those that can be obtained with RNCOMBINE, but RNCOMBINE takes the
additional step of cross-multiplying numerical denominator factors.
This results in neater forms, and the possiblity of recognizing some
cancellations.  Bugs to ASB.

&ROMBERG(exp,var,ll,ul) or ROMBERG(exp,ll,ul) - Romberg Integration.
You need not load in any file to use ROMBERG, it is autoloading.
There are two ways to use this function.  The first is an inefficient
way like the definite integral version of INTEGRATE:

ROMBERG(<integrand>,<variable of integration>,<lower limit>,
                <upper limit>);
Examples:
        ROMBERG(SIN(Y),Y,1,%PI);
                TIME= 39 MSEC.          1.5403023
        F(X):=1/(X^5+X+1);
        ROMBERG(F(X),X,1.5,0);
                TIME= 162 MSEC.         - 0.75293843

The second is an efficient way that is used as follows:

ROMBERG(<function name>,<lower limit>,<upper limit>);

Example:
        F(X):=(MODE_DECLARE([FUNCTION(F),X],FLOAT),1/(X^5+X+1));
        TRANSLATE(F);
        ROMBERG(F,1.5,0);
                TIME= 13 MSEC.          - 0.75293843

The first argument must be a TRANSLATEd or compiled function.  (If it
is compiled it must be declared to return a FLONUM.)  If the first
argument is not already TRANSLATEd, ROMBERG will not attempt to
TRANSLATE it but will give an error.

The accuracy of the integration is governed by the global variables
ROMBERGTOL (default value 1.E-4) and ROMBERGIT (default value 11).
ROMBERG will return a result if the relative difference in successive
approximations is less than ROMBERGTOL.  It will try halving the
stepsize ROMBERGIT times before it gives up.  The number of iterations
and function evaluations which ROMBERG will do is governed by
ROMBERGABS and ROMBERGMIN, do DESCRIBE(ROMBERGABS,ROMBERGMIN); for
details.

ROMBERG may be called recursively and thus can do double and triple
integrals.
Example:
        INTEGRATE(INTEGRATE(X*Y/(X+Y),Y,0,X/2),X,1,3);
                                13/3 (2 LOG(2/3) + 1)
        %,NUMER;
                                0.81930233

        DEFINE_VARIABLE(X,0.0,FLOAT,"Global variable in function F")$
        F(Y):=(MODE_DECLARE(Y,FLOAT), X*Y/(X+Y) )$
        G(X):=ROMBERG('F,0,X/2)$  
        ROMBERG(G,1,3);
                                0.8193023

The advantage with this way is that the function F can be used for other 
purposes, like plotting. The disadvantage is that you have to think up 
a name for both the function F and its free variable X.

Or, without the global:
        G1(X):=(MODE_DECLARE(X,FLOAT), ROMBERG(X*Y/(X+Y),Y,0,X/2))$
        ROMBERG(G1,1,3);
                                0.8193023
The advantage here is shortness.

        Q(A,B):=ROMBERG(ROMBERG(X*Y/(X+Y),Y,0,X/2),X,A,B)$
        Q(1,3);
                                0.8193023
It is even shorter this way, and the variables do not need to be declared 
because they are in the context of ROMBERG.

Use of ROMBERG for multiple integrals can have great disadvantages,
though.  The amount of extra calculation needed because of the
geometric information thrown away by expressing multiple integrals
this way can be incredible.  The user should be sure to understand and
use the ROMBERGTOL and ROMBERGIT switches.

(The IMSL version of Romberg integration is now available in Macsyma.
Do DESCRIBE(DCADRE); for more information.)

&ROMBERGABS default: [0.0] (0.0B0) Assuming that successive estimates
produced by ROMBERG are Y[0], Y[1], Y[2] etc., then ROMBERG will
return after N iterations if (roughly speaking)
 (ABS(Y[N]-Y[N-1]) <= ROMBERGABS OR
 ABS(Y[N]-Y[N-1])/(IF Y[N]=0.0 THEN 1.0 ELSE Y[N]) <= ROMBERGTOL)
is TRUE.  (The condition on the number of iterations given by
ROMBERGMIN must also be satisfied.)

Thus if ROMBERGABS is 0.0 (the default) you just get the relative
error test.  The usefulness of the additional variable comes when you
want to perform an integral, where the dominant contribution comes
from a small region.  Then you can do the integral over the small
dominant region first, using the relative accuracy check, followed by
the integral over the rest of the region using the absolute accuracy
check.

Example:  Suppose you want to compute
   Integral(exp(-x),x,0,50)
(numerically) with a relative accuracy of  1 part in 10000000.

  /* Define the function.  N is a counter, so we can see how many
     function evaluations were needed. */
F(X):=(MODE_DECLARE(N,INTEGER,X,FLOAT),N:N+1,EXP(-X))$
TRANSLATE(F)$
  /* First of all try doing the whole integral at once */
BLOCK([ROMBERGTOL:1.E-6,ROMBERABS:0.],N:0,ROMBERG(F,0,50)); ==> 1.00000003
N; ==> 257  /* Number of function evaluations*/
  /* Now do the integral intelligently, by first doing
     Integral(exp(-x),x,0,10) and then setting ROMBERGABS to 1.E-6*(this
     partial integral).  */
BLOCK([ROMBERGTOL:1.E-6,ROMBERGABS:0.,SUM:0.],
      N:0,SUM:ROMBERG(F,0,10),ROMBERGABS:SUM*ROMBERGTOL,ROMBERGTOL:0.,
      SUM+ROMBERG(F,10,50));  ==> 1.00000001  /* Same as before */
N;  ==> 130

So if F(X) were a function that took a long time to compute, the
second method would be about 2 times quicker.

&ROMBERGIT default: [11] - The accuracy of the ROMBERG integration
command is governed by the global variables ROMBERGTOL[1.E-4] and
ROMBERGIT[11].  ROMBERG will return a result if the relative
difference in successive approximations is less than ROMBERGTOL.  It
will try halving the stepsize ROMBERGIT times before it gives up.

&ROMBERGTOL default: [1.E-4] - The accuracy of the ROMBERG integration
command is governed by the global variables ROMBERGTOL[1.E-4] and
ROMBERGIT[11].  ROMBERG will return a result if the relative
difference in successive approximations is less than ROMBERGTOL.  It
will try halving the stepsize ROMBERGIT times before it gives up.

&ROMBERGMIN default: [0] - governs the minimum number of function
evaluations that ROMBERG will make.  ROMBERG will evaluate its first
arg. at least 2^(ROMBERGMIN+2)+1 times.  This is useful for
integrating oscillatory functions, when the normal converge test might
sometimes wrongly pass.

&ROOTSCONMODE default: [TRUE] - Determines the behavior of the
ROOTSCONTRACT command.  Do DESCRIBE(ROOTSCONTRACT); for details.

&ROOTSCONTRACT(exp) converts products of roots into roots of products.
For example, ROOTSCONTRACT(SQRT(X)*Y^(3/2)); gives SQRT(X*Y^3).  When
RADEXPAND is TRUE and DOMAIN is REAL (their defaults), ROOTSCONTRACT
converts ABS into SQRT, e.g. ROOTSCONTRACT(ABS(X)*SQRT(Y)); gives
SQRT(X^2*Y).  There is an option ROOTSCONMODE (default value TRUE),
which affects ROOTSCONTRACT as follows:

Problem      Value of ROOTSCONMODE     Result of applying ROOTSCONTRACT
X^(1/2)*Y^(3/2)         FALSE              (X*Y^3)^(1/2)
X^(1/2)*Y^(1/4)         FALSE              X^(1/2)*Y^(1/4)
X^(1/2)*Y^(1/4)         TRUE               (X*Y^(1/2))^(1/2)
X^(1/2)*Y^(1/3)         TRUE               X^(1/2)*Y^(1/3)
X^(1/2)*Y^(1/4)         ALL                (X^2*Y)^(1/4)
X^(1/2)*Y^(1/3)         ALL                (X^3*Y^2)^(1/6)

(The above examples and more may be tried out by typing 
EXAMPLE(ROOTSCONTRACT); .)
When ROOTSCONMODE is FALSE, ROOTSCONTRACT contracts only wrt rational 
number exponents whose denominators are the same.  The key to the 
ROOTSCONMODE:TRUE$ examples is simply that 2 divides into 4 but not 
into 3.  ROOTSCONMODE:ALL$ involves taking the lcm (least common multiple)
of the denominators of the exponents.
ROOTSCONTRACT uses RATSIMP in a manner similar to LOGCONTRACT (see the 
manual).  

&ROOTSEPSILON default: [1.0E-7] - a real number used to establish the
confidence interval for the roots found by the REALROOTS function.

&ROW(M, i) gives a matrix of the ith row of matrix M.

&RULES - user defined pattern matching and simplification rules (set
up by TELLSIMP, TELLSIMPAFTER, DEFMATCH, or, DEFRULE.)

&SAVE([optional file spec],arg1, arg2,...,argi) saves quantities
described by its arguments on disk and keeps them in core also.  The
optional file spec is in the form NAME1,NAME2,DSK,DIRECTORY and is
enclosed in square brackets, e.g.  [JAMU,FUNCS,DSK,USERS2].  Do
DESCRIBE(FILES) for more details on file specifications.  If you omit
the file spec, MACSYMA will select a file name for you consisting of
the first three letters of your login name followed by a digit (the
lowest digit which will give a unique file name).  The second file
name will be a number.  The arg's are the expressions to be SAVEd.
ALL is the simplest, but note that saving ALL will save the entire
contents of your MACSYMA, which in the case of a large computation may
result in a file which is too large to be reloaded.  VALUES,
FUNCTIONS, or any other items on the INFOLISTS (do
DESCRIBE(INFOLISTS); for the list) may be SAVEd, as may functions and
variables by name.  C and D lines may also be saved, but it is better
to give them explicit names, which may be done in the command line,
e.g.  SAVE(RES1=D15); Files saved with SAVE should be reloaded with
LOADFILE.  SAVE returns a list of the form [<name of file>,<size of
file in blocks>,...] where ... are the things saved.  Warnings are
printed out in the case of large files, or if an empty file is
accidently generated.  It is possible to do a SAVE when a WRITEFILE is
in progress.

&SAVEDEF default: [TRUE] - if TRUE will cause the MACSYMA version of a
user function to remain when the function is TRANSLATEd.  This permits
the definition to be displayed by DISPFUN and allows the function to
be edited.  If SAVEDEF is FALSE, the names of translated functions are
removed from the FUNCTIONS list.

&SAVEFACTORS default: [FALSE] - if TRUE causes the factors of an
expression which is a product of factors to be saved by certain
functions in order to speed up later factorizations of expressions
containing some of the same factors.

&SCALARMATRIXP default: [TRUE] - if TRUE, then whenever a 1 x 1 matrix
is produced as a result of computing the dot product of matrices it
will be converted to a scalar, namely the only element of the matrix.
If set to ALL, then this conversion occurs whenever a 1 x 1 matrix is
simplified.  If set to FALSE, no conversion will be done.

&SCALARP(exp) is TRUE if exp is a number, constant, or variable
DECLAREd SCALAR, or composed entirely of numbers, constants, and such
variables, but not containing matrices or lists.

&SCALEFACTORS(coordinatetransform) - Here coordinatetransform
evaluates to the form [[expression1, expression2, ...],
indeterminate1, indeterminat2, ...], where indeterminate1,
indeterminate2, etc. are the curvilinear coordinate variables and
where a set of rectangular Cartesian components is given in terms of
the curvilinear coordinates by [expression1, expression2, ...].
COORDINATES is set to the vector [indeterminate1, indeterminate2,...],
and DIMENSION is set to the length of this vector.  SF[1], SF[2],
..., SF[DIMENSION] are set to the coordinate scale factors, and SFPROD
is set to the product of these scale factors.  Initially, COORDINATES
is [X, Y, Z], DIMENSION is 3, and SF[1]=SF[2]=SF[3]=SFPROD=1,
corresponding to 3-dimensional rectangular Cartesian coordinates.

To expand an expression into physical components in the current
coordinate system, there is a function with usage of the form

&SCANMAP(function,exp) recursively applies function to exp, in a "top
down" manner.  This is most useful when "complete" factorization is
desired, for example:

(C1) EXP:(A^2+2*A+1)*Y + X^2$

(C2) SCANMAP(FACTOR,EXP);
                                    2      2
(D2)                         (A + 1)  Y + X

Note the way in which SCANMAP applies the given function FACTOR to the
constituent subexpressions of exp; if another form of exp is presented
to SCANMAP then the result may be different.  Thus, D2 is not
recovered when SCANMAP is applied to the expanded form of exp:

(C3) SCANMAP(FACTOR,EXPAND(EXP));
                           2                  2
(D3)                      A  Y + 2 A Y + Y + X

Here is another example of the way in which SCANMAP recursively
applies a given function to all subexpressions, including exponents:

(C4) EXPR : U*V^(A*X+B) + C$

(C5) SCANMAP('F, EXPR);

                    F(F(F(A) F(X)) + F(B))
(D5) F(F(F(U) F(F(V)                      )) + F(C))

SCANMAP(function,expression,BOTTOMUP) applies function to exp in a
"bottom-up" manner.  E.g., for undefined F, SCANMAP(F,A*X+B) ->
F(A*X+B) -> F(F(A*X)+F(B)) -> F(F(F(A)*F(X))+F(B)).
SCANMAP(F,A*X+B,BOTTOMUP) -> F(A)*F(X)+F(B) -> F(F(A)*F(X))+F(B) ->
F(F(F(A)*F(X))+F(B)).  (In this case, you get the same answer both
ways.)

&SCSIMP(exp,rule1, rule2,...,rulen) (Sequential Comparative
Simplification [Stoute]) takes an expression (its first argument) and
a set of identities, or rules (its other arguments) and tries
simplifying.  If a smaller expression is obtained, the process
repeats.  Otherwise after all simplifications are tried, it returns
the original answer.  For examples, try EXAMPLE(SCSIMP); .

&SCURVATURE() returns the scalar curvature (obtained by contracting
the Ricci tensor) of the Riemannian manifold with the given metric.

&SEC - Secant
&SECH - Hyperbolic Secant

&SEND("message") - will send your message to some MACSYMA system
programmer who is logged in at that time.  Note that message must
begin and end with double quotes.

SEND(username,"message") - sends the message to a specified user.

Expressions may be included by referring to them, outside double
quotes, when (and only when) a username is given, e.g.

SEND(ELLEN,"I am trying to integrate",D3,"but it asks for more list
space.  What should I do?");

&SET - See SETS.

&SETCHECK default: [FALSE] - if set to a list of variables (which can
be subscripted) will cause a printout whenever the variables, or
subscripted occurrences of them, are bound (with : or :: or function
argument binding).  The printout consists of the variable and the
value it is bound to.  SETCHECK may be set to ALL or TRUE thereby
including all variables.  Note: No printout is generated when a
SETCHECKed variable is set to itself, e.g. X:'X.

&SETCHECKBREAK default: [FALSE] - if set to TRUE will cause a
(MACSYMA-BREAK) to occur whenever the variables on the SETCHECK list
are bound.  The break occurs before the binding is done.  At this
point, SETVAL holds the value to which the variable is about to be
set.  Hence, one may change this value by resetting SETVAL.

&SETELMX(x, i, j, M) changes the i,j element of M to x.  The altered
matrix is returned as the value.  The notation M[i,j]:x may also be
used, altering M in a similar manner, but returning x as the value.

&SETS - MACSYMA has two packages for Set Theory.  One uses MACSYMA's
list representation, meaning you can convert easily between lists and
sets.  It contains commands such as UNION, INTERSECTION, COMPLEMENT,
etc.  It may be accessed by LOAD(SET); .  For a description, do
PRINTFILE(SET,USAGE,DSK,SHARE2); .  The other Sets package, which also
contains commands for the usual sorts of operations performed on sets,
uses a different representation and is computationally faster.  It is
available by doing LOAD(SETS); .  Do PRINTFILE(SETS,USAGE,DSK,SHARE1);
for information on this.

&SETUP() - this has been renamed to TSETUP();  Sets up a metric for
Tensor calculations.

&SETUP_AUTOLOAD(file,func1,...,funcN) which takes two or more
arguments: a file specification, and one or more function names,
"funcI", and which indicates that if a call to "funcI" is made and
"funcI" is not defined, that the file specified by "file" is to be
automatically loaded in via LOAD, which file should contain a
definition for "funcI".  (This is the process by which calling e.g.
INTEGRATE in a fresh MACSYMA causes various files to be loaded in.)
As with the other file-handling commands in MACSYMA, the arguments to
SETUP_AUTOLOAD are not evaluated.
Example:
SETUP_AUTOLOAD([BESSEL,FASL,SHARE],J1)$ J1(0.0); .

Note: SETUP_AUTOLOAD does not work for array functions.

&SETVAL - holds the value to which a variable is about to be set when
a SETCHECKBREAK occurs.  Hence, one may change this value by resetting
SETVAL.  (See SETCHECKBREAK).

&SHARE - The SHARE directory on MC or on a DEC20 version of MACSYMA
contains programs, information files, etc.  which are considered to be
of interest to the MACSYMA community.  Most files on SHARE; are not
part of the MACSYMA system per se and must be loaded individually by
the user, e.g.  LOADFILE(ARRAY,FASL,DSK,SHARE);. Many files on SHARE;
were contributed by MACSYMA users.  Do PRINTFILE(SHARE,USAGE,SHARE);
for more details and the conventions for contributing to the SHARE
directory.  For an annotated "table of contents" of the directory, do:
PRINTFILE(SHARE,>,SHARE);

&SHOW(exp) will display exp with the indexed objects in it shown
having covariant indices as subscripts,contravariant indices as
superscripts.  The derivative indices will be displayed as subscripts,
separated from the covariant indices by a comma.

&SHOWRATVARS(exp) returns a list of the RATVARS (CRE variables) of
exp.

&SHOWTIME default: [FALSE] - if TRUE then the computation time will be
printed automatically with each output expression.  By setting
SHOWTIME:ALL, in addition to the cpu time MACSYMA now also prints out
(when not zero) the amount of time spent in garbage collection (gc) in
the course of a computation.  This time is of course included in the
time printed out as "time=" .  (It should be noted that since the
"time=" time only includes computation time and not any intermediate
display time or time it takes to load in out-of-core files, and since
it is difficult to ascribe "responsibility" for gc's, the gctime
printed will include all gctime incurred in the course of the
computation and hence may in rare cases even be larger than "time=").

&SIGN(exp) attempts to determine the sign of its specified expression
on the basis of the facts in the current data base.  It returns one of
the following answers: POS (positive), NEG (negative), ZERO, PZ
(positive or zero), NZ (negative or zero), PN (positive or negative),
or PNZ (positive, negative, or zero, i.e. nothing known).

&SIGNUM(X) - if X<0 then -1 else if X>0 then 1 else 0.  If X is not
numeric then a simplified but equivalent form is returned. For
example, SIGNUM(-X) gives -SIGNUM(X).

&SIMILARITYTRANSFORM(MAT) - a function in the EIGEN package.  Do
LOAD(EIGEN) to use it.  SIMILARITYTRANSFORM takes a MATRIX as its
argument and returns a list which is the output of the
UNITEIGENVECTORS command.  In addition if the flag NONDIAGONALIZABLE
is FALSE two global matrices LEFTMATRIX and RIGHTMATRIX will be
generated.  These matrices have the property that
LEFTMATRIX.MAT.RIGHTMATRIX is a diagonal matrix with the eigenvalues
of MAT on the diagonal.  If NONDIAGONALIZABLE is TRUE these two
matrices will not be generated.  If the flag HERMITIANMATRIX is TRUE
then LEFTMATRIX is the complex conjugate of the transpose of
RIGHTMATRIX.  Otherwise LEFTMATRIX is the inverse of RIGHTMATRIX.
RIGHTMATRIX is the matrix the columns of which are the unit
eigenvectors of MAT.  The other flags (see DESCRIBE(EIGENVALUES); and
DESCRIBE(EIGENVECTORS);) have the same effects since
SIMILARITYTRANSFORM calls the other functions in the package in order
to be able to form RIGHTMATRIX.

&SIMP causes exp to be simplified regardless of the setting of the
switch SIMP which inhibits simplification if FALSE.

&SIMPSUM default: [FALSE] - if TRUE, the result of a SUM is
simplified.  This simplification may sometimes be able to produce a
closed form.  If SIMPSUM is FALSE or if 'SUM is used, the value is a
sum noun form which is a representation of the sigma notation used in
mathematics.

&SIN - Sine
&SINH - Hyperbolic Sine

&SIZE - See DESCRIBE(NTERMS); and DESCRIBE(LENGTH); for two ways to
get an idea of the size of an expression.

&SOLVE(exp, var) solves the algebraic equation exp for the variable
var and returns a list of solution equations in var.  If exp is not an
equation, it is assumed to be an expression to be set equal to zero.
Var may be a function (e.g. F(X)), or other non-atomic expression
except a sum or product. It may be omitted if exp contains only one
variable.  Exp may be a rational expression, and may contain
trigonometric functions, exponentials, etc.  The following method is
used:

Let E be the expression and X be the variable.  If E is linear in X
then it is trivially solved for X.  Otherwise if E is of the form
A*X**N+B then the result is (-B/A)**(1/N) times the Nth roots of
unity.

If E is not linear in X then the gcd of the exponents of X in E (say
N) is divided into the exponents and the multiplicity of the roots is
multiplied by N.  Then SOLVE is called again on the result.

If E factors then SOLVE is called on each of the factors.  Finally
SOLVE will use the quadratic, cubic, or quartic formulas where
necessary.

In the case where E is a polynomial in some function of the variable
to be solved for, say F(X), then it is first solved for F(X) (call the
result C), then the equation F(X)=C can be solved for X provided the
inverse of the function F is known.

BREAKUP[TRUE] if FALSE will cause SOLVE to express the solutions of
cubic or quartic equations as single expressions rather than as made
up of several common subexpressions which is the default.

MULTIPLICITIES[NOT_SET_YET] - will be set to a list of the multiplicities of
the individual solutions returned by SOLVE, REALROOTS, or ALLROOTS.

Try APROPOS(SOLVE) for the switches which affect SOLVE.  DESCRIBE may
then by used on the individual switch names if their purpose is not
clear.

Note: SOLVE binds KEEPFLOAT to FALSE.  If you want to retain floating
point numbers and are solving a system of linear equations, set
KEEPFLOAT to TRUE and use LINSOLVE.

SOLVE([eq1, ..., eqn], [v1, ..., vn]) solves a system of simultaneous
(linear or non-linear) polynomial equations by calling LINSOLVE or
ALGSYS and returns a list of the solution lists in the variables.  In
the case of LINSOLVE this list would contain a single list of
solutions.  It takes two lists as arguments.  The first list (eqi,
i=1,...,n) represents the equations to be solved; the second list is a
list of the unknowns to be determined.  If the total number of
variables in the equations is equal to the number of equations, the
second argument-list may be omitted.  For linear systems if the given
equations are not compatible, the message INCONSISTENT will be
displayed (see the SOLVE_INCONSISTENT_ERROR switch); if no unique
solution exists, then SINGULAR will be displayed.  For examples, do
EXAMPLE(SOLVE);

&SOLVE_INCONSISTENT_ERROR default: [TRUE] - If TRUE, SOLVE and
LINSOLVE give an error if they meet up with a set of inconsistent
linear equations, e.g. SOLVE([A+B=1,A+B=2]).  If FALSE, they return []
in this case.  (This is the new mode, previously gotten only by
calling ALGSYS.)

&SOLVEDECOMPOSES default: [TRUE] - if TRUE, will induce SOLVE to use
POLYDECOMP (see POLYDECOMP) in attempting to solve polynomials.

&SOLVEEXPLICIT default: [FALSE] - if TRUE, inhibits SOLVE from
returning implicit solutions i.e. of the form F(x)=0.

&SOLVEFACTORS default: [TRUE] - if FALSE then SOLVE will not try to
factor the expression.  The FALSE setting may be desired in some cases
where factoring is not necessary.

&SOLVENULLWARN default: [TRUE] - if TRUE the user will be warned if he
calls SOLVE with either a null equation list or a null variable list.
For example, SOLVE([],[]); would print two warning messages and return
[].

&SOLVERADCAN default: [FALSE] - if TRUE then SOLVE will use RADCAN
which will make SOLVE slower but will allow certain problems
containing exponentials and logs to be solved.

&SOLVETRIGWARN default: [TRUE] - if set to FALSE will inhibit printing
by SOLVE of the warning message saying that it is using inverse
trigonometric functions to solve the equation, and thereby losing
solutions.

&SORT(list,optional-predicate) sorts the list using a suitable
optional-predicate of two arguments (such as "<" or ORDERLESSP).  If
the optional-predicate is not given, then MACSYMA's built-in ordering
predicate is used.

&SPARSE default: [FALSE] - if TRUE and if RATMX:TRUE then DETERMINANT
will use special routines for computing sparse determinants.

&SPECINT - The Hypergeometric Special Functions Package HYPGEO is
still under development.  At the moment it will find the Laplace
Transform or rather, the integral from 0 to INF of some special
functions or combinations of them.  The factor, EXP(-P*var) must be
explicitly stated.  The syntax is as follows:

SPECINT(EXP(-P*var)*expr,var);

        where var is the variable of integration and expr may be
any expression containing special functions (at your own risk).
Special function notation follows:

%J[index](expr)         Bessel Funct 1st Kind
%K[index](expr)           "     "    2nd Kind
%I[     ](    )         Modified Bessel
%HE[     ](  )          Hermite Poly
%P[  ]( )               Legendre Funct
%Q[  ]( )               Legendre of second kind
HSTRUVE[ ]( )           Struve H Function
LSTRUVE[ ]( )             "    L Function
%F[ ]([],[],expr)       Hypergeometric Function
GAMMA()
GAMMAGREEK()
GAMMAINCOMPLETE()
SLOMMEL
%M[]()                  Whittaker Funct 1st Kind
%W[]()                     "       "    2nd  "

For a better feeling for what it can do, do DEMO(HYPGEO,DEMO,SHARE1); .

&SQFR(exp) is similar to FACTOR except that the polynomial factors are
"square-free." That is, they have factors only of degree one.  This
algorithm, which is also used by the first stage of FACTOR, utilizes
the fact that a polynomial has in common with its nth derivative all
its factors of degree > n.  Thus by taking gcds with the polynomial of
the derivatives with respect to each variable in the polynomial, all
factors of degree > 1 can be found.

(C1) SQFR(4*X**4+4*X**3-3*X**2-4*X-1);

                             2               2
(D1)                       (X  - 1) (2 X + 1)

&SQRT(X) - the square root of X. It is represented internally by
X^(1/2).  Also see ROOTSCONTRACT.

RADEXPAND[TRUE] - if TRUE will cause nth roots of factors of a product
which are powers of n to be pulled outside of the radical, e.g.
SQRT(16*X^2) will become 4*X only if RADEXPAND is TRUE.

&SQRTDISPFLAG default: [TRUE] - if FALSE causes SQRT to display with
exponent 1/2.

&SRRAT(exp) - this command has been renamed to TAYTORAT.

&SSTATUS(feature,package) - meaning SET STATUS.  It can be used to
SSTATUS(FEATURE,HACK_PACKAGE) so that STATUS(FEATURE,HACK_PACKAGE)
will then return TRUE.  This can be useful for package writers, to
keep track of what FEATURES they have loaded in.

&STARDISP default: [FALSE] - if TRUE will cause multiplication to be
displayed explicitly with an * between operands.

&STATUS(arg) will return miscellaneous status information about the
user's MACSYMA depending upon the arg given.  Permissible arguments
and results are as follows:

TIME - the time used so far in the computation.
DAY - the day of the week.
DATE - a list of the year, month, and day.
DAYTIME - a list of the hour, minute, and second.
RUNTIME - accumulated cpu time times the atom "MILLISECONDS" in the current
   MACSYMA.  
REALTIME - the real time (in sec) elapsed since the user started up
   his MACSYMA.
GCTIME - the garbage collection time used so far in the current
   computation.
TOTALGCTIME - gives the total garbage collection time used in MACSYMA
   so far.
FREECORE - the number of blocks of core your MACSYMA can expand
   before it runs out of address space.  (A block is 1024 words.)
   Subtracting that value from 250*BLOCKS (the maximum you can get on MC)
   tells you how many blocks of core your MACSYMA is using up.  (A
   MACSYMA with no "fix" file starts at approx. 191 blocks.)

FEATURE - gives you a list of system features. At present the list for
   MC is: MACSYMA, NOLDMSG, MACLISP, PDP10, BIGNUM, FASLOAD, HUNK,
   FUNARG, ROMAN, NEWIO, SFA, PAGING, MC, and ITS.  Any of these
   "features" may be given as a second argument to STATUS(FEATURE,...);
   If the specified feature exists, TRUE will be returned, else FALSE.
   Note: these are system features, and not really "user related".

For information about your files, see the FILEDEFAULTS(); command.

&STORE(args) same as SAVE but doesn't retain quantities in core.  Like
SAVE, STORE returns a list of the form [<name of file>,<size of file
in blocks>,...] where ... are the things saved.  Warnings are printed
out in the case of large files, or if an empty file is accidently
generated.  It is possible to do a STORE when a WRITEFILE is in
progress.

&STORENUM - The value of this variable, an integer, is the second name
of the last file written by the automatic storage scheme.  (See
DESCRIBE(DSKGC)).  Each time a file is written, STORENUM is first
increased by 1, so it must always be an integer.  It is initially set
to 1000.

&STRING(expr) converts expr to MACSYMA's linear notation (similar to
FORTRAN's) just as if it had been typed in and puts expr into the
buffer for possible editing (in which case expr is usually Ci).  The
STRING'ed expression should not be used in a computation.  Setting the
GRIND[FALSE] switch to TRUE will make STRING's output a little more
readable.

&STRINGOUT(args) will output an expression to a file in a linear
format.  Such files are then used by the BATCH or DEMO commands.

STRINGOUT(file-specification, A1, A2, ...)  outputs to a file given by
file-specification ([filename1,filename2,DSK, directory]) the values
given by A1,A2,..  in a MACSYMA readable format.  The
file-specification may be omitted, in which case the default values
will be used. The Ai are usually C labels or may be INPUT meaning the
value of all C labels.  Another option is to make ai FUNCTIONS which
will cause all of the user's function definitions to be strungout
(i.e. all those retrieved by DISPFUN(ALL)).  Likewise the ai may be
VALUES, and all the variables to which the user has assigned values
will be strungout.  ai may also be a list [m,n] which means to
stringout all labels in the range m through n inclusive.  This
function may be used to create a file of FORTRAN statements by doing
some simple editing on the strungout expressions.  If the GRIND switch
is set to TRUE, then STRINGOUT will use GRIND format instead of STRING
format.  Note: a STRINGOUT may be done while a WRITEFILE is in
progress.

&SUBLIS(list,expr) allows multiple substitutions into an expression in
parallel.  Sample syntax:
        SUBLIS([A=B,B=A],SIN(A)+COS(B));
         => SIN(B) + COS(A)
The variable SUBLIS_APPLY_LAMBDA[TRUE] controls simplification after
SUBLIS.  For full documentation, see the file SHARE2;SUBLIS INFO.

&SUBLIS_APPLY_LAMBDA default:[TRUE] - controls whether LAMBDA's
substituted are applied in simplification after SUBLIS is used or
whether you have to do an EV to get things to apply. TRUE means do the
application.

&SUBLIST(L,F) returns the list of elements of the list L for which the
function F returns TRUE.  E.g., SUBLIST([1,2,3,4],EVENP); returns
[2,4].

&SUBMATRIX(m1, ..., M, n1, ...)  creates a new matrix composed of the
matrix M with rows mi deleted, and columns ni deleted.

&SUBST(a, b, c) substitutes a for b in c.  b must be an atom, or a
complete subexpression of c.  For example, X+Y+Z is a complete
subexpression of 2*(X+Y+Z)/W while X+Y is not. When b does not have
these characteristics, one may sometimes use SUBSTPART or RATSUBST
(see below).  Alternatively, if b is of the form e/f then one could
use SUBST(a*f,e,c) while if b is of the form e**(1/f) then one could
use SUBST(a**f,e,c).  The SUBST command also discerns the X^Y in X^-Y
so that SUBST(A,SQRT(X),1/SQRT(X)) yields 1/A.  a and b may also be
operators of an expression enclosed in "s or they may be function
names.  If one wishes to substitute for the independent variable in
derivative forms then the AT function (see below) should be used.
Note:  SUBST is an alias for SUBSTITUTE.

SUBST(eq1,exp) or SUBST([eq1,...,eqk],exp) are other permissible
forms.  The eqi are equations indicating substitutions to be made.
For each equation, the right side will be substituted for the left in
the expression exp.

EXPTSUBST[FALSE] if TRUE permits substitutions like Y for %E**X in
%E**(A*X) to take place.

OPSUBST[TRUE] if FALSE, SUBST will not attempt to substitute into the
operator of an expression.  E.g. (OPSUBST:FALSE, SUBST(X^2,R,R+R[0]));
will work.

(C1) SUBST(A,X+Y,X+(X+Y)**2+Y);
                                 2
(D1)                    Y + X + A

(C2) SUBST(-%I,%I,A+B*%I);
(D2)                             A - %I B

(Note that C2 is one way of obtaining the complex conjugate of an analytic
expression.)  For further examples, do EXAMPLE(SUBST);

&SUBSTINPART(x, exp, n1, ...) is like SUBSTPART but works on the
internal representation of exp.

(C1) X.'DIFF(F(X),X,2);
                                   2
                                  d
(D1)                         X . (--- F(X))
                                    2
                                  dX

(C2) SUBSTINPART(D**2,%,2);
                                      2
(D2)                             X . D

(C3) SUBSTINPART(F1,F[1](X+1),0);

(D3)                            F1(X + 1)

              Additional Information

If the last argument to a part function is a list of indices then
several subexpressions are picked out, each one corresponding to an
index of the list.  Thus PART(X+Y+Z,[1,3]) is Z+X.

PIECE holds the value of the last expression selected when using the
part functions.  It is set during the execution of the function and
thus may be referred to in the function itself as shown below.

If PARTSWITCH[FALSE] is set to TRUE then END is returned when a
selected part of an expression doesn't exist, otherwise an error
message is given.

(C1)  27*Y**3+54*X*Y**2+36*X**2*Y+Y+8*X**3+X+1;

            3         2       2            3
(D1)    27 Y  + 54 X Y  + 36 X  Y + Y + 8 X  + X + 1

(C2)  PART(D1,2,[1,3]);

                  2
(D2)          54 Y

(C3)  SQRT(PIECE/54);

(D3)            Y

(C4)  SUBSTPART(FACTOR(PIECE),D1,[1,2,3,5]);

                          3
(D4)           (3 Y + 2 X) + Y + X + 1

(C5) 1/X+Y/X-1/Z;
                                 1   Y   1
(D5)                           - - + - + -
                                 Z   X   X

(C6) SUBSTPART(XTHRU(PIECE),%,[2,3]);

                                Y + 1   1
(D6)                            ----- - -
                                  X     Z

Also, setting the option INFLAG to TRUE and calling PART/SUBSTPART is 
the same as calling INPART/SUBSTINPART.

&SUBSTPART(x, exp, n1, ..., nk) substitutes x for the subexpression
picked out by the rest of the arguments as in PART.  It returns the
new value of exp.  x may be some operator to be substituted for an
operator of exp.  In some cases it needs to be enclosed in "s (e.g.
SUBSTPART("+",A*B,0); -> B + A ).

(C1) 1/(X**2+2);
                                    1
(D1)                              ------
                                   2
                                  X  + 2

(C2) SUBSTPART(3/2,%,2,1,2);
                                    1
(D2)                             --------
                                  3/2
                                 X    + 2

(C3) A*X+F(B,Y);
(D3)                          A X + F(B, Y)

(C4) SUBSTPART("+",%,1,0);
(D4)                         X + F(B, Y) + A

Also, setting the option INFLAG to TRUE and calling PART/SUBSTPART is
the same as calling INPART/SUBSTINPART.  Do DESCRIBE(INFLAG) for
details.

&SUBVARP(exp) is TRUE if exp is a subscripted variable, for example
A[I].

&SUM(exp, ind, lo, hi) performs a summation of the values of exp as
the index ind varies from lo to hi.  If the upper and lower limits
differ by an integer then each term in the sum is evaluated and added
together.  Otherwise, if the SIMPSUM [FALSE] is TRUE the result is
simplified.  This simplification may sometimes be able to produce a
closed form.  If SIMPSUM is FALSE or if 'SUM is used, the value is a
SUM noun form which is a representation of the sigma notation used in
mathematics.

If hi is one less than lo, we have an "empty sum" and SUM returns 0 
rather than erring out.

Sums may be differentiated, added, subtracted, or multiplied with some
automatic simplification being performed.

SUM evaluates its first argument only once like almost every other
MACSYMA command.  This implies that things like F(X):=SUM(X,I,1,3)$
F(-X); (Answer: -3*X) and SUM(T[I],I,1,3); (Answer: retrieve and sum
up T[1],T[2],T[3] without reevaluating the elements) will work
correctly whereas I^2; SUM(%,I,1,3); (Answer: 3*I^2) will not (if the
desired answer is 14).  To do the latter one will have to type
SUM(EV(%),I,1,3); or SUM(''%,I,1,3); . (PRODUCT and ROMBERG behave
similarly.)

CAUCHYSUM[FALSE] when TRUE causes the Cauchy product to be used when
multiplying sums together rather than the usual product.  In the
Cauchy product the index of the inner summation is a function of the
index of the outer one rather than varying independently.

GENINDEX[I] is the alphabetic prefix used to generate the next
variable of summation.

GENSUMNUM[0] is the numeric suffix used to generate the next variable
of summation.  If it is set to FALSE then the index will consist only
of GENINDEX with no numeric suffix.

Do EXAMPLE(SUM); for examples.  See also SUMCONTRACT, SUMEXPAND,
SUMHACK, INTOSUM, BASHINDICES, and NICEINDICES.

&SUMCONTRACT(expr) - will combine all sums of an addition that have
upper and lower bounds that differ by constants. The result will be an
expression containing one summation for each set of such summations
added to all appropriate extra terms that had to be extracted to form
this sum.  SUMCONTRACT will combine all compatible sums and use one of
the indices from one of the sums if it can, and then try to form a
reasonable index if it cannot use any supplied.  It may be necessary
to do an INTOSUM(expr) before the SUMCONTRACT.

&SUMEXPAND default: [FALSE] if TRUE, products of sums and
exponentiated sums are converted into nested sums.
E.g.,   SUMEXPAND:TRUE$
        SUM(F(I),I,0,M)*SUM(G(J),J,0,N); ->
                        'SUM('SUM(F(I1)*G(I2),I2,0,N),I1,0,M)
        SUM(F(I),I,0,M)^2; -> 'SUM('SUM(F(I3)*F(I4),I4,0,M),I3,0,M)
If FALSE, they are left alone.  See also CAUCHYSUM.

&SUMHACK default: [FALSE] - if set to TRUE then SUM(F(I),I,3,1); will
yield -F(2), by the identity SUM(F(I),I,A,B) = - SUM(F(I),I,B+1,A-1) 
when A>B.

&SUMSPLITFACT default: [TRUE] - if set to FALSE will cause
MINFACTORIAL to be applied after a FACTCOMB.

&SUPCONTEXT(name,context) will create a new context (called name)
whose subcontext is context.  If context is not specified, the current
context will be assumed.  If it is specified, context must exist.

&SYMBOLP(exp) returns TRUE if "exp" is a "symbol" or "name", else
FALSE.  I.e., in effect, SYMBOLP(X):=ATOM(X) AND NOT NUMBERP(X)$ .

&SYMMETRIC - If DECLARE(H,SYMMETRIC); is done, this tells the
simplifier that H is a symmetric function.  E.g. H(X,Z,Y) will
simplify to H(X, Y, Z).  This is the same as COMMUTATIVE.

&SYNTAX - It is possible to add new operators to MACSYMA (infix,
prefix, postfix, unary, or matchfix with given precedences), to remove
existing operators, or to redefine the precedence of existing
operators.  While MACSYMA's syntax should be adequate for most
ordinary applications, it is possible to define new operators or
eliminate predefined ones that get in the user's way.  The extension
mechanism is rather straightforward and should be evident from the
examples below.

(C1) PREFIX("DDX")$

(C2) DDX Y$             means                   "DDX"(Y)

(C3) INFIX("<-")$

(C4) A<-DDX Y$          means               "<-"(A,"DDX"(Y))

For each of the types of operator except SPECIAL, there is a
corresponding creation function that will give the lexeme specified
the corresponding parsing properties.  Thus "PREFIX("DDX")" will make
"DDX" a prefix operator just like "-" or "NOT".  Of course, certain
extension functions require additional information such as the
matching keyword for a matchfix operator.  In addition, binding powers
and parts of speech must be specified for all keywords defined.  This
is done by passing additional arguments to the extension functions.
If a user does not specify these additional parameters, MACSYMA will
assign default values.  The six extension functions with binding
powers and parts of speech defaults (enclosed in brackets) are
summarized below.

PREFIX(operator, rbp[180], rpos[ANY], pos[ANY])
POSTFIX(operator, lbp[180], lpos[ANY], pos[ANY])
INFIX(operator, lbp[180], rbp[180], lpos[ANY], rpos[ANY],pos[ANY])
NARY(operator, bp[180], argpos[ANY], pos[ANY])
NOFIX(operator, pos[ANY])
MATCHFIX(operator, match, argpos[ANY], pos[ANY])

    The defaults have been provided so that a user who does not wish
to concern himself with parts of speech or binding powers may simply
omit those arguments to the extension functions.  Thus the following
are all equivalent.

PREFIX("DDX",180,ANY,ANY)$
PREFIX("DDX",180)$
PREFIX("DDX")$

    It is also possible to remove the syntax properties of an operator
by using the functions REMOVE or KILL.  Specifically,
"REMOVE("DDX",OP)" or "KILL("DDX")" will return "DDX" to operand
status; but in the second case all the other properties of "DDX" will
also be removed.

&TAG_FILE_INSERT(file-to-insert-into, file-to-insert) - Inserts a file
created by the translator into a multiple entry tags file.

&TAN - Tangent
&TANH - Hyperbolic Tangent

&TAYLOR(exp, var, pt, pow) expands the expression exp in a truncated
Taylor series (or Laurent series, if required) in the variable var
around the point pt.  The terms through (var-pt)**pow are generated.
If exp is of the form f(var)/g(var) and g(var) has no terms up to
degree pow then TAYLOR will try to expand g(var) up to degree 2*pow.
If there are still no non-zero terms TAYLOR will keep doubling the
degree of the expansion of g(var) until reaching pow*2**n where n is
the value of the variable TAYLORDEPTH[3].  If MAXTAYORDER[FALSE] is
set to TRUE, then during algebraic manipulation of (truncated) Taylor
series, TAYLOR will try to retain as many terms as are certain to be
correct.  Do EXAMPLE(TAYLOR); for examples.

TAYLOR(exp,[var1,pt1,ord1],[var2,pt2,ord2],...)  returns a truncated
power series in the variables vari about the points pti, truncated at
ordi.

PSEXPAND[FALSE] if TRUE will cause extended rational function
expressions to display fully expanded.  (RATEXPAND will also cause
this.) If FALSE, multivariate expressions will be displayed just as in
the rational function package.  If PSEXPAND:MULTI, then terms with the
same total degree in the variables are grouped together.

TAYLOR(exp, [var1, var2, .  . .], pt, ord) where each of pt and ord
may be replaced by a list which will correspond to the list of
variables.  that is, the nth items on each of the lists will be
associated together.

TAYLOR(exp, [x,pt,ord,ASYMP]) will give an expansion of exp in
negative powers of (x-pt).  The highest order term will be (x-pt)^(-ord).
The ASYMP is a syntactic device and not to be assigned to.

See also the TAYLOR_LOGEXPAND switch for controlling expansion.

&TAYLORP(exp) a predicate function which returns TRUE if and only if
the expression 'exp' is in Taylor series representation.

&TAYLOR_LOGEXPAND default: [TRUE] controls expansions of logarithms in
TAYLOR series.  When TRUE all log's are expanded fully so that
zero-recognition problems involving logarithmic identities do not
disturb the expansion process.  However, this scheme is not always
mathematically correct since it ignores branch information.  If
TAYLOR_LOGEXPAND is set to FALSE, then the only expansion of log's
that will occur is that necessary to obtain a formal power series.

&TAYLOR_ORDER_COEFFICIENTS default: [TRUE] controls the ordering of
coefficients in the expression.  The default (TRUE) is that
coefficients of taylor series will be ordered canonically.

&TAYLOR_SIMPLIFIER - A function of one argument which TAYLOR uses to
simplify coefficients of power series.

&TAYLOR_TRUNCATE_POLYNOMIALS default: [TRUE] When FALSE polynomials
input to TAYLOR are considered to have infinite precison; otherwise
(the default) they are truncated based upon the input truncation
levels.

&TAYLORDEPTH default: [3] - If there are still no non-zero terms
TAYLOR will keep doubling the degree of the expansion of g(var) until
reaching pow*2**n where n is the value of the variable TAYLORDEPTH[3].

&TAYLORINFO(exp) returns FALSE if exp is not a Taylor series.
Otherwise, a list of lists is returned describing the particulars of
the Taylor expansion.  For example,

(C3) TAYLOR((1-Y^2)/(1-X),X,0,3,[Y,A,INF]);
             2                        2
(D3)/R/ 1 - A  - 2 A (Y - A) - (Y - A)

                    2                        2
            + (1 - A  - 2 A (Y - A) - (Y - A) ) X

         2                        2   2
 + (1 - A  - 2 A (Y - A) - (Y - A) ) X

                    2                        2   3
            + (1 - A  - 2 A (Y - A) - (Y - A) ) X

     + . . .
(C4) TAYLORINFO(D3);
(D4)                       [[Y, A, INF], [X, 0, 3]]

&TAYTORAT(exp) converts exp from TAYLOR form to CRE form, i.e. it is
like RAT(RATDISREP(exp)) although much faster.

&TECO() - loads up a TECO editor as a sub-job under your MACSYMA, so
that you can edit batch files, or expressions.  This is perhaps a more
convenient way to run TECO than going up to DDT (top) level and starting
up a second job, as from MACSYMA the command TECO(); will put you in the
editor, and one control-Z will bring you back up to your MACSYMA.  TECO
commands are described in the "Introduction to ITS".

&TELLRAT(poly) adds to the ring of algebraic integers known to
MACSYMA, the element which is the solution of the polynomial with
integer coefficients.  MACSYMA initially knows about %I and all roots
of integers. TELLRAT(X); means substitute 0 for X in rational
functions.  There is a command UNTELLRAT which takes kernels and
removes TELLRAT properties.  When TELLRATing a multivariate
polynomial, e.g. TELLRAT(X^2-Y^2);, there would be an ambiguity as to
whether to substitute Y^2 for X^2 or vice versa.  The system will pick
a particular ordering, but if the user wants to specify which, e.g.
TELLRAT(Y^2=X^2); provides a syntax which says replace Y^2 by X^2.
TELLRAT and UNTELLRAT both can take any number of arguments, and
TELLRAT(); returns a list of the current substitutions.  Note: When
you TELLRAT reducible polynomials, you want to be careful not to
attempt to rationalize a denominator with a zero divisor.  E.g.
TELLRAT(W^3-1)$ ALGEBRAIC:TRUE$ RAT(1/(W^2-W)); will give "quotient by
zero".  This error can be avoided by setting RATALGDENOM:FALSE$.

ALGEBRAIC[FALSE] must be set to TRUE in order for the simplification of
algebraic integers to take effect.

Do EXAMPLE(TELLRAT); for examples.

&TELLSIMP(pattern, replacement) is similar to TELLSIMPAFTER but places
new information before old so that it is applied before the built-in
simplification rules.  TELLSIMP is used when it is important to modify
the expression before the simplifier works on it, for instance if the
simplifier "knows" something about the expression, but what it returns
is not to your liking.  If the simplifier "knows" something about the
main operator of the expression, but is simply not doing enough for
you, you probably want to use TELLSIMPAFTER.  The pattern may not be a
sum, product, single variable, or number.  RULES is a list of names
having simplification rules added to them by DEFRULE, DEFMATCH,
TELLSIMP, or TELLSIMPAFTER.  Do EXAMPLE(TELLSIMP); for examples.

&TELLSIMPAFTER(pattern, replacement) defines a replacement for pattern
which the MACSYMA simplifier uses after it applies the built-in
simplification rules.  The pattern may be anything but a single
variable or a number.

&TENSOR - Do DESCRIBE(TENSORS);

&TENSORS - There are two tensor packages in MACSYMA, CTENSR and
ITENSR.  CTENSR is Component Tensor Manipulation, and may be accessed
with LOAD(CTENSR); .  ITENSR is Indicial Tensor Manipulation, and is
loaded by doing LOAD(ITENSR); A manual for CTENSR AND ITENSR is
available from the LCS Publications Office.  Request MIT/LCS/TM-167.
In addition, demos exist on the TENSOR; directory under the filenames
CTENSO DEMO1, DEMO2, etc. and ITENSO DEMO1, DEMO2, etc.  Do
DEMO(CTENSO,DEMO1,TENSOR); or DEMO(ITENSO,DEMO1,TENSOR); Send bugs or
comments to RP or TENSOR.

&THROW(exp) evaluates exp and throws the value back to the most recent
CATCH.  THROW is used with CATCH as a structured nonlocal exit
mechanism.

&TIME(Di1, Di2, ...) gives a list of the times in milliseconds taken
to compute the Di.  (Note: the Variable SHOWTIME, default: [FALSE],
may be set to TRUE to have computation times printed out with each
D-line.)

&TIMEDATE() prints out the current date and time.

&TIMER(F); will put a timer-wrapper on the function F, within the TRACE
package, i.e. it will print out the time spent in computing F.

&TIMER_DEVALUE default: [FALSE] - when set to TRUE then the time
charged against a function is the time spent dynamically inside the
function devalued by the time spent inside other TIMED functions.

&TIMER_INFO(F); will print the information on timing which is stored
also as GET('F,'CALLS); GET('F,'RUNTIME); and GET('F,'GCTIME); .  This
is a TRACE package function.

&TLDEFINT(exp,var,ll,ul) is just LDEFINT with TLIMSWITCH set to TRUE.

&TLIMIT(exp,var,val,dir) is just the function LIMIT with TLIMSWITCH
set to TRUE.

&TLIMSWITCH default: [FALSE] - if true will cause the limit package to
use Taylor series when possible.

&TO_LISP() - enters the LISP system under MACSYMA.  This is useful on
those systems where control-uparrow is not available for this
function.

&TOBREAK() - causes the MACSYMA break which was left by typing
TOPLEVEL; to be re-entered.  If TOBREAK is given any argument
whatsoever, then the break will be exited, which is equivalent to
typing TOBREAK() immediately followed by EXIT;.

&TOPLEVEL - During a break one may type TOPLEVEL;.  This will cause
top-level MACSYMA to be entered recursively.  Labels will now be bound
as usual.  Everything will be identical to the previous top-level
state except that the computation which was interrupted is saved.  The
function TOBREAK() will cause the break which was left by typing
TOPLEVEL; to be re-entered.  If TOBREAK is given any argument
whatsoever, then the break will be exited, which is equivalent to
typing TOBREAK() immediately followed by EXIT;.

&TOTALDISREP(exp) converts every subexpression of exp from CRE to
general form.  If exp is itself in CRE form then this is identical to
RATDISREP but if not then RATDISREP would return exp unchanged while
TOTALDISREP would "totally disrep" it.  This is useful for
ratdisrepping expressions e.g., equations, lists, matrices, etc. which
have some subexpressions in CRE form.

&TOTIENT(n) is the number of integers less than or equal to n which
are relatively prime to n.

&TRACE(name1, name2, ...)  gives a trace printout whenever the
functions mentioned are called.  TRACE() prints a list of the
functions currently under TRACE.  On MC see MACDOC;TRACE USAGE for
more information.  Also, DEMO(TRACE,DEMO,DEMO); .  To remove tracing,
see UNTRACE.

&TRACE_OPTIONS(F,option1,option2,...) - gives the function F the
options indicated.  An option is either a keyword or an expression.
The possible Keywords are:

 Keyword     Meaning of return value
----------------------------------------
 NOPRINT     If TRUE do no printing. 
 BREAK       If TRUE give a breakpoint.
 LISP_PRINT  If TRUE use lisp printing.
 INFO        Extra info to print.
 ERRORCATCH  If TRUE errors are caught.

A keyword means that the option is in effect.  Using a keyword as an
expression, e.g. NOPRINT(predicate_function) means to apply the
predicate_function (which is user-defined) to some arguments to
determine if the option is in effect. The argument list to this
predicate_function is always [LEVEL, DIRECTION, FUNCTION, ITEM] where
LEVEL is the recursion level for the function.  DIRECTION is either
ENTER or EXIT.  FUNCTION is the name of the function.  ITEM is either
the argument list or the return value.  On MC see
DEMO(TRACE,DEMO,DEMO); for more details.

&TRADE_SECRET - (c) 1976,1984, Massachusetts Institute of Technology.
All Rights Reserved.
Enhancements (c) 1984, Symbolics, Inc. All Rights Reserved.

The data and information in the Enhancements are proprietary to, and a
valuable trade secret of, SYMBOLICS, INC., a Delaware corporation.
They are given in confidence by SYMBOLICS, pursuant to the license
agreement between Symbolics and their recipient, and may not be used,
reproduced, or copied, or distributed to any other party, in whole or
in part, without the prior written consent of SYMBOLICS, except as
permitted by the license agreement.

&TRANSBIND default: [FALSE] - if TRUE removes global declarations in
the local context.  This applies to variables which are formal
parameters to functions which one is TRANSLATE-ing from MACSYMA code
to LISP.

&TRANSCOMPILE default:[FALSE] - if true, TRANSLATE will generate the
declarations necessary for possible compilation.  The COMPFILE command
uses TRANSCOMPILE:TRUE;.

&TRANSFORM - The TRANSFORM command in the CTENSR package has been
renamed to TTRANSFORM.

&TRANSLATE(f1, f2, ...) translates the user defined functions
f1,f2,... from the MACSYMA language to LISP (i.e. it makes them
EXPRs).  This results in a gain in speed when they are called.  There
is now a version of macsyma with the macsyma to lisp translator
pre-loaded into it.  It is available by typing :TM (for
TranslateMacsyma) at DDT level.  When given a file name, E.g. :TM
GJC;TMTEST > , it gives that file to the function TRANSLATE_FILE, and
proceeds without further user interaction.  If no file name is given,
:TM gives a regular macsyma "(C1)" line.  P.s. A user init file with
second name "TM" will be loaded if it exists.  You may just want to
link this to your macsyma init file.

Functions to be translated should include a call to MODE_DECLARE at the
beginning when possible in order to produce more efficient code.  For
example:

F(X1,X2,...):=BLOCK([v1,v2,...],
        MODE_DECLARE(v1,mode1,v2,mode2,...),...)

where the X1,X2,...  are the parameters to the function and the
v1,v2,... are the local variables.  The names of translated functions
are removed from the FUNCTIONS list if SAVEDEF is FALSE (see below)
and are added to the PROPS lists.  Functions should not be translated
unless they are fully debugged.  Also, expressions are assumed
simplified; if they are not, correct but non- optimal code gets
generated.  Thus, the user should not set the SIMP switch to FALSE
which inhibits simplification of the expressions to be translated.

The switch TRANSLATE, default: [FALSE], If TRUE, causes automatic
translation of a user's function to LISP.  Note that translated
functions may not run identically to the way they did before
translation as certain incompatabilities may exist between the LISP
and MACSYMA versions.  Principally, the RAT function with more than
one argument and the RATVARS function should not be used if any
variables are MODE_DECLAREd CRE.  Also the PREDERROR:FALSE setting
will not translate.

SAVEDEF[TRUE] - if TRUE will cause the MACSYMA version of a user
function to remain when the function is TRANSLATEd.  This permits the
definition to be displayed by DISPFUN and allows the function to be
edited.

TRANSRUN[TRUE] - if FALSE will cause the interpreted version of all
functions to be run (provided they are still around) rather than the
translated version.

One can translate functions stored in a file by giving TRANSLATE an
argument which is a file specification.  This is a list of the form
[fn1,fn2,DSK,dir] where fn1 fn2 is the name of the file of MACSYMA
functions, and dir is the name of a file directory.

The result returned by TRANSLATE is a list of the names of the
functions TRANSLATEd.  In the case of a file translation the
corresponding element of the list is a list of the first and second
new file names containing the LISP code resulting from the
translation.  This will be fn1 LISP on the disk directory dir.  The
file of LISP code may be read into MACSYMA by using the LOADFILE
function.

&TRANSLATE_FILE(file) - translates a file of MACSYMA code into a file
of LISP code.  It takes one or two arguments.  The first argument is
the name of the MACSYMA file, and the optional second argument is the
name of the LISP file to produce.  The second argument defaults to the
first argument with second file name the value of
TR_OUTPUT_FILE_DEFAULT which defaults to TRLISP.  For example:
TRANSLATE_FILE(TEST); will translate GJC;TEST > into GJC;TEST TRLISP.
TRANSLATE_FILE([TEST,MAX,DSK,FOO]); translates FOO;TEST MAX producing
FOO;TEST TRLISP.  Also produced is a file of translator warning
messages of various degrees of severity.  The second file name is
always UNLISP.  This file contains valuable (albeit obsure for some)
information for tracking down bugs in translated code.  Do
APROPOS(TR_) to get a list of TR (for TRANSLATE) switches.  In
summary, TRANSLATE_FILE([FOO,BAR]), LOADFILE(FOO,TRLISP) is "=" to
BATCH(FOO,BAR) modulo certain restrictions (the use of '' and % for
example).

&TRANSPOSE(M) produces the transpose of the matrix M.

&TRANSRUN default: [TRUE] - if FALSE will cause the interpreted
version of all functions to be run (provided they are still around)
rather than the translated version.

&TRIANGULARIZE(M) produces the upper triangular form of the matrix M
which needn't be square.

&TRIG - MACSYMA has many Trig functions defined.  Not all Trig
identities are programmed, but it is possible for the user to add many
of them using the pattern matching capabilities of the system.  The
Trig functions defined in MACSYMA are: ACOS, ACOSH, ACOT, ACOTH, ACSC,
ACSCH, ASEC, ASECH, ASIN, ASINH, ATAN, ATANH, COS, COSH, COT, COTH,
CSC, CSCH, SEC, SECH, SIN, SINH, TAN, and TANH.  There are a number of
commands especially for handling Trig functions, see TRIGEXPAND,
TRIGREDUCE, and the switch TRIGSIGN.  Two SHARE packages extend the
simplification rules built into MACSYMA, NTRIG and ATRIG1.  Do
DESCRIBE(cmd) for details.

&TRIGEXPAND(exp) expands trigonometric and hyperbolic functions of
sums of angles and of multiple angles occurring in exp.  For best
results, exp should be expanded.  To enhance user control of
simplification, this function expands only one level at a time,
expanding sums of angles or multiple angles.  To obtain full expansion
into sines and cosines immediately, set the switch TRIGEXPAND:TRUE.

TRIGEXPAND default: [FALSE] - if TRUE causes expansion of all
expressions containing SINs and COSs occurring subsequently.

HALFANGLES[FALSE] - if TRUE causes half-angles to be simplified away.

TRIGEXPANDPLUS[TRUE] - controls the "sum" rule for TRIGEXPAND,
expansion of sums (e.g. SIN(X+Y)) will take place only if
TRIGEXPANDPLUS is TRUE.

TRIGEXPANDTIMES[TRUE] - controls the "product" rule for TRIGEXPAND,
expansion of products (e.g. SIN(2*X)) will take place only if
TRIGEXPANDTIMES is TRUE.

(C1) X+SIN(3*X)/SIN(X),TRIGEXPAND=TRUE,EXPAND;

                              2           2
(D1)                     - SIN (X) + 3 COS (X) + X
(C2) TRIGEXPAND(SIN(10*X+Y));

(D2)               COS(10 X) SIN(Y) + SIN(10 X) COS(Y)

&TRIGEXPANDPLUS default: [TRUE] - controls the "sum" rule for
TRIGEXPAND.  Thus, when the TRIGEXPAND command is used or the
TRIGEXPAND switch set to TRUE, expansion of sums (e.g. SIN(X+Y)) will
take place only if TRIGEXPANDPLUS is TRUE.

&TRIGEXPANDTIMES default: [TRUE] - controls the "product" rule for
TRIGEXPAND.  Thus, when the TRIGEXPAND command is used or the
TRIGEXPAND switch set to TRUE, expansion of products (e.g. SIN(2*X))
will take place only if TRIGEXPANDTIMES is TRUE.

&TRIGINVERSES default: [ALL] - controls the simplification of the
composition of trig and hyperbolic functions with their inverse
functions: If ALL, both e.g. ATAN(TAN(X)) and TAN(ATAN(X)) simplify to
X.  If TRUE, the arcfunction(function(x)) simplification is turned
off.  If FALSE, both the arcfun(fun(x)) and fun(arcfun(x))
simplifications are turned off.

&TRIGONOMETRY - MACSYMA has many Trig functions defined.  Not all Trig
identities are programmed, but it is possible for the user to add many
of them using the pattern matching capabilities of the system.  The
Trig functions defined in MACSYMA are: ACOS, ACOSH, ACOT, ACOTH, ACSC,
ACSCH, ASEC, ASECH, ASIN, ASINH, ATAN, ATANH, COS, COSH, COT, COTH,
CSC, CSCH, SEC, SECH, SIN, SINH, TAN, and TANH.  There are a number of
commands especially for handling Trig functions, see TRIGEXPAND,
TRIGREDUCE, and the switch TRIGSIGN.

&TRIGREDUCE(exp, var) combines products and powers of trigonometric
and hyperbolic SINs and COSs of var into those of multiples of var.
It also tries to eliminate these functions when they occur in
denominators.  If var is omitted then all variables in exp are used.
Also see the POISSIMP function (6.6).

(C4) TRIGREDUCE(-SIN(X)^2+3*COS(X)^2+X);
(D4)                        2 COS(2 X) + X + 1

The trigonometric simplification routines will use declared
information in some simple cases.  Declarations about variables are
used as follows, e.g.

(C5) DECLARE(J, INTEGER, E, EVEN, O, ODD)$

(C6) SIN(X + (E + 1/2)*%PI)$

(D6)                      COS(X)

(C7) SIN(X + (O + 1/2) %PI);

(D7)                     - COS(X)

&TRIGSIGN default: [TRUE] - if TRUE permits simplification of negative
arguments to trigonometric functions. E.g., SIN(-X) will become
-SIN(X) only if TRIGSIGN is TRUE.

&TRIGSIMP(expr) - employs the identities sin(x)^2 + cos(x)^2 = 1 and
cosh(x)^2 - sinh(x)^2 = 1 to simplify expressions containing tan, sec,
etc. to sin, cos, sinh, cosh so that further simplification may be
obtained by using TRIGREDUCE on the result.  Some examples may be seen
by doing DEMO(TRGSMP,DEMO,SHARE); .  See also the TRIGSUM function.

&TRIGSUM - This function is no longer available.
&TRUE - the Boolean constant, true. (T in LISP)

&TRUNC(exp) - causes exp which is in general representation to be
displayed as if its sums were truncated Taylor series.  E.g. compare
EXP1:X^2+X+1; with EXP2:TRUNC(X^2+X+1); .  Note that IS(EXP1=EXP2);
gives TRUE.

&TR_ARRAY_AS_REF default: [TRUE] - If TRUE runtime code uses the value
of the variable as the array.

&TR_BOUND_FUNCTION_APPLYP default: [TRUE] - Gives a warning if a bound
variable is found being used as a function.

&TR_FILE_TTY_MESSAGESP default: [FALSE] - Determines whether messages
generated by TRANSLATE_FILE during translation of a file will be sent
to the TTY.  If FALSE (the default), messages about translation of the
file are only inserted into the UNLISP file.  If TRUE, the messages
are sent to the TTY and are also inserted into the UNLISP file.

&TR_FLOAT_CAN_BRANCH_COMPLEX default: [TRUE] - States whether the arc
functions might return complex results.  The arc functions are SQRT,
LOG, ACOS, etc.  e.g. When it is TRUE then ACOS(X) will be of mode ANY
even if X is of mode FLOAT. When FALSE then ACOS(X) will be of mode
FLOAT if and only if X is of mode FLOAT.

&TR_FUNCTION_CALL_DEFAULT default: [GENERAL] - FALSE means give up and
call MEVAL, EXPR means assume Lisp fixed arg function.  GENERAL, the
default gives code good for MEXPRS and MLEXPRS but not MACROS.
GENERAL assures variable bindings are correct in compiled code.  In
GENERAL mode, when translating F(X), if F is a bound variable, then it
assumes that APPLY(F,[X]) is meant, and translates a such, with
apropriate warning. There is no need to turn this off.  With the
default settings, no warning messages implies full compatibility of
translated and compiled code with the macsyma interpreter.

&TR_GEN_TAGS default: [FALSE] - If TRUE, TRANSLATE_FILE generates a
TAGS file for use by the text editor.

&TR_NUMER default: [FALSE] - If TRUE numer properties are used for
atoms which have them, e.g. %PI.

&TR_OPTIMIZE_MAX_LOOP default: [100] - The maximum number of times the
macro-expansion and optimization pass of the translator will loop in
considering a form.  This is to catch MACRO expansion errors, and
non-terminating optimization properties.

&TR_OUTPUT_FILE_DEFAULT default: [TRLISP] - This is the second file
name to be used for translated lisp output.

&TR_PREDICATE_BRAIN_DAMAGE default: [FALSE] - If TRUE, output possible
multiple evaluations in an attempt to interface to the COMPARE
package.

&TR_SEMICOMPILE default: [FALSE] - If TRUE TRANSLATE_FILE and COMPFILE
output forms which will be macroexpanded but not compiled into machine
code by the lisp compiler.

&TR_STATE_VARS default: [TRANSCOMPILE, TR_SEMICOMPILE,
TR_WARN_UNDECLARED, TR_WARN_MEVAL, TR_WARN_FEXPR, TR_WARN_MODE,
TR_WARN_UNDEFINED_VARIABLE, TR_FUNCTION_CALL_DEFAULT, TR_ARRAY_AS_REF,
TR_NUMER] - The list of the switches that affect the form of the
translated output.  This information is useful to system people when
trying to debug the translator.  By comparing the translated product
to what should have been produced for a given state, it is possible to
track down bugs.

&TR_TRUE_NAME_OF_FILE_BEING_TRANSLATED default: [FALSE] is bound to
the quoted string form of the true name of the file most recently
translated by TRANSLATE_FILE.

&TR_VERSION - The version number of the translator.

&TR_WARN_BAD_FUNCTION_CALLS default: [TRUE] - Gives a warning when
when function calls are being made which may not be correct due to
improper declarations that were made at translate time.

&TR_WARN_FEXPR default: [COMPFILE] - Gives a warning if any FEXPRs are
encountered.  FEXPRs should not normally be output in translated code,
all legitimate special program forms are translated.

&TR_WARN_MEVAL default: [COMPFILE] - Gives a warning if the function
MEVAL gets called.  If MEVAL is called that indicates problems in the
translation.

&TR_WARN_MODE default: [ALL] - Gives a warning when variables are
assigned values inappropriate for their mode.

&TR_WARN_UNDECLARED default: [COMPILE] - Determines when to send
warnings about undeclared variables to the TTY.

&TR_WARN_UNDEFINED_VARIABLE default: [ALL] - Gives a warning when
undefined global variables are seen.

&TR_WARNINGS_GET() - Prints a list of warnings which have been given by
the translator during the current translation.

&TR_WINDY default: [TRUE] - Generate "helpfull" comments and
programming hints.

&TSETUP() - A function in the CTENSR (Component Tensor Manipulation)
package which automatically loads the CTENSR package from within
MACSYMA (if it is not already loaded) and then prompts the user to
make use of it.  Do DESCRIBE(CTENSR); for more details.

&TTRANSFORM(matrix) - A function in the CTENSR (Component Tensor
Manipulation) package which will perform a coordinate transformation
upon an arbitrary square symmetric matrix. The user must input the
functions which define the transformation.  (Formerly called TRANSFORM.)

&TTY_INIT() - ("initialize TTY") is an MC-only command of no arguments
which can be used if you change your TCTYP after starting up a MACSYMA
or when you reown a MACSYMA on a terminal with different
characteristics from the terminal from which the MACSYMA was disowned.
TTY_INIT(); informs MACSYMA of your terminal's new characteristics,
e.g.  linelength, pagesize, etc.

&TTYINTFUN default: [FALSE] - Governs the function which will be run
whenever the User-interrupt-character is typed.  To use this feature,
one sets TTYINTFUN (default FALSE meaning feature not in use) to a
function of no arguments.  Then whenever (e.g.) ^U (control-U) is
typed, this function is run.  E.g. suppose you have a FOR statement
loop which increments I, and you want an easy way of checking on the
value of I while the FOR statement is running.  You can do:
TTYINTFUN:PRINTI$ PRINTI():=PRINT(I)$ , then whenever you type (e.g.)
^U you get the check you want.

&TTYINTNUM default: [21] (the ascii value of Control-U (^U), U being
the 21st letter of the alphabet).  This controls what character
becomes the User-interrupt-character.  ^U was chosen for it mnemonic
value.  Most users should not reset TTYINTNUM unless they are already
using ^U for something else.

&TTYOFF default: [FALSE] - if TRUE stops printing output to the
console.

&UNDECLAREDWARN default: [COMPFILE] - A switch in the Translator.
There are four relevant settings:
SETTING     | ACTION
------------------------------------------------------------
FALSE       | never print warning messages. 
COMPFILE    | warn when in COMPFILE
TRANSLATE   | warn when in TRANSLATE and when TRANSLATE:TRUE
ALL         | warn in COMPFILE and TRANSLATE            
------------------------------------------------------------
Do MODE_DECLARE(<variable>,ANY) to declare a variable to be a general 
macsyma variable (i.e. not limited to being FLOAT or FIXNUM).  The extra 
work in declaring all your variables in code  to be compiled should pay 
off.

&UNDIFF(exp) returns an expression equivalent to exp but with all
derivatives of indexed objects replaced by the noun form of the DIFF
function with arguments which would yield that indexed object if the
differentiation were carried out.  This is useful when it is desired
to replace a differentiated indexed object with some function
definition and then carry out the differentiation by saying
EV(...,DIFF).

&UNITEIGENVECTORS(MAT) - a function in the EIGEN package.  Do
LOAD(EIGEN) to use it.  UNITEIGENVECTORS takes a MATRIX as its
argument and returns a list of lists the first sublist of which is the
output of the EIGENVALUES command and the other sublists of which are
the unit eigenvectors of the matrix corresponding to those eigenvalues
respectively.  The flags mentioned in the description of the
EIGENVECTORS command have the same effects in this one as well.  In
addition there is a flag which may be useful :

KNOWNEIGVECTS[FALSE] - If set to TRUE the EIGEN package will assume
that the eigenvectors of the matrix are known to the user and are
stored under the global name LISTEIGVECTS.  LISTEIGVECTS should be set
to a list similar to the output of the EIGENVECTORS command.  (If
KNOWNEIGVECTS is set to TRUE and the list of eigenvectors is given the
setting of the flag NONDIAGONALIZABLE may not be correct.  If that is
the case please set it to the correct value.  The author assumes that
the user knows what he is doing and will not try to diagonalize a
matrix the eigenvectors of which do not span the vector space of the
appropriate dimension...)

&UNITVECTOR(X) - a function in the EIGEN package.  Do LOAD(EIGEN) to
use it.  UNITVECTOR takes a LIST as its argument and returns a unit
list.  (i.e. a list with unit magnitude).

&UNKNOWN(exp) returns TRUE iff exp contains an operator or function
not known to the built-in simplifier.

&UNORDER() stops the aliasing created by the last use of the ordering
commands ORDERGREAT and ORDERLESS.  ORDERGREAT and ORDERLESS may not
be used more than one time each without calling UNORDER.  Do
DESCRIBE(ORDERGREAT); and DESCRIBE(ORDERLESS);, and also do
EXAMPLE(UNORDER); for specifics.

&UNSTORE(name1, ...) brings the named expressions into core that were
stored away by use of the STORE function in the current MACSYMA.

&UNSUM(fun,n) is the first backward difference fun(n) - fun(n-1).

(C1) G(P):=P*4^N/BINOMIAL(2*N,N);
                                            N
                                         P 4
(D1)                       G(P) := ----------------
                                   BINOMIAL(2 N, N)

(C2) G(N^4);
                                     4  N
                                    N  4
(D2)                           ----------------
                               BINOMIAL(2 N, N)
(C3) NUSUM(D2,N,0,N);
                         4        3       2              N
          2 (N + 1) (63 N  + 112 N  + 18 N  - 22 N + 3) 4      2
(D3)      ------------------------------------------------ - ------
                        693 BINOMIAL(2 N, N)                 3 11 7

(C4) UNSUM(%,N);
                                     4  N
                                    N  4
(D4)                           ----------------
                               BINOMIAL(2 N, N)

&UNTELLRAT(x) takes kernels and removes TELLRAT properties.

&UNTRACE(name1, ...) removes tracing invoked by the TRACE function.
UNTRACE() removes tracing from all functions.

&UPDATE - The Update file has been moved to the MACDOC directory, so
you should do PRINTFILE(UPDATE,>,MACDOC); to read it.  Also, you may
find information of a useful nature on this directory, so you may want 
to list it (LISTFILES(MACDOC); in MACSYMA) and print some other files
also.

The Current Acknowledgement for a paper which references MACSYMA
is available as ACKNOWLEDGEMENT.

&VALUES default:[] - all bound atoms, i.e. user variables, not MACSYMA
Options or Switches, (set up by : , :: , or functional binding).

&VECT - See VECTORS

&VECT_CROSS default:[FALSE] - If TRUE allows DIFF(X~Y,T) to work where
~ is defined in SHARE;VECT (where VECT_CROSS is set to TRUE, anyway.)

&VECTOR - See VECTORS
&VECTORS - The file SHARE;VECT > contains a vector analysis package,
SHARE;VECT DEMO contains a corresponding demonstration, and SHARE;VECT
ORTH contains definitions of various orthogonal curvilinear coordinate
systems.  LOAD(VECT); will load this package for you.

The vector analysis package can combine and simplify symbolic 
expressions including dot products and cross products, together with
the gradient, divergence, curl, and Laplacian operators.  The
distribution of these operators over sums or products is under
user control, as are various other expansions, including expansion
into components in any specific orthogonal coordinate systems.
There is also a capability for deriving the scalar or vector potential
of a field.

The package contains the following commands: VECTORSIMP, SCALEFACTORS,
EXPRESS, POTENTIAL, and VECTORPOTENTIAL.  Do DESCRIBE(cmd) on these
command names, or PRINTFILE(VECT,USAGE,SHARE); for details.
Warning:  The VECT package declares "." to be a commutative operator.

&VECTORPOTENTIAL(givencurl) - Returns the vector potential of a given
curl vector, in the current coordinate system.

POTENTIALZEROLOC has a similar role as for POTENTIAL, but the order of
the left-hand sides of the equations must be a cyclic permutation of
the coordinate variables.

&VECTORSIMP(vectorexpression) - This function employs additional
non-controversial simplifications, together with various optional
expansions according to the settings of the following global flags:

EXPANDALL, EXPANDDOT, EXPANDDOTPLUS, EXPANDCROSS, EXPANDCROSSPLUS,
EXPANDCROSSCROSS, EXPANDGRAD, EXPANDGRADPLUS, EXPANDGRADPROD,
EXPANDDIV, EXPANDDIVPLUS, EXPANDDIVPROD, EXPANDCURL, EXPANDCURLPLUS,
EXPANDCURLCURL, EXPANDLAPLACIAN, EXPANDLAPLACIANPLUS,
EXPANDLAPLACIANPROD.

All these flags have default value FALSE. The PLUS suffix refers to
employing additivity or distributivity.  The PROD suffix refers to the
expansion for an operand that is any kind of product.
EXPANDCROSSCROSS refers to replacing p~(q~r) with (p.r)*q-(p.q)*r, and
EXPANDCURLCURL refers to replacing CURL CURL p with GRAD DIV p + DIV
GRAD p.  EXPANDCROSS:TRUE has the same effect as
EXPANDCROSSPLUS:EXPANDCROSSCROSS:TRUE, etc.  Two other flags,
EXPANDPLUS and EXPANDPROD, have the same effect as setting all
similarly suffixed flags true.  When TRUE, another flag named
EXPANDLAPLACIANTODIVGRAD, replaces the LAPLACIAN operator with the
composition DIV GRAD.  All of these flags are initially FALSE.  For
convenience, all of these flags have been declared EVFLAG.

For orthogonal curvilinear coordinates, the global variables
COORDINATES[[X,Y,Z]], DIMENSION[3], SF[[1,1,1]], and SFPROD[1] are set
by the function invocation

&VERB - the opposite of "noun", i.e. a function form which "does
something" ("action" - for most functions the usual case).  E.g.
INTEGRATE integrates a function, unless it is DECLAREd to be a "noun",
in which case it represents the INTEGRAL of the function.  See NOUN,
NOUNIFY, and VERBIFY.

&VERBIFY(f) returns the function name f in its verb form (See also VERB,
NOUN, and NOUNIFY).

&VERBOSE default: [FALSE] - if TRUE will cause comments about the
progress of POWERSERIES to be printed as the execution of it proceeds.

&VERSION default: [304] - is the version number of MACSYMA.  This
could be useful if the user wants to label his output, or to associate
bugs with a particular version.

&VIEWPT default: [] VIEWPT and CENTERPLOT determine the perspective
view taken for plotting commands.  They are defaulted to be unbound.
VIEWPT may be set to a list of 3 numbers and gives the point from
which the projection should be made.  CENTERPLOT may likewise be set
to a list of 3 numbers and gives a point on the line of sight.  The
projection will be made onto a plane perpendicular to a line joining
VIEWPT and CENTERPLOT.

If VIEWPT and CENTERPLOT are unbound (the default) then they will be
chosen as follows: the extreme values of the coordinates are
determined.  This gives the two points min: [xmin,ymin,zmin],
max:[xmax,ymax,zmax]. CENTERPLOT is chosen as (min+max)/2, and VIEWPT
is chosen as max+3*(max-min).  The view is then one in which the z
axis is vertical, the x axis is increasing towards you to the left and
the y axis is increasing towards you to the right.

If CENTERPLOT is FALSE then the old type of perspective view will be
given (like setting the x and z components of CENTERPLOT to the
corresponding components of VIEWPT).

&WEYL(dis) computes the Weyl conformal tensor.  If the argument dis is
TRUE, the non-zero components W[I,J,K,L] will be displayed to the
user.  Otherwise, these components will simply be computed and stored.
If the switch RATWEYL is set to TRUE, then the components will be
rationally simplified; if FACRAT is TRUE then the results will be
factored as well.

&WHO() [MC and Multics only] - prints out the currently logged in users.

&WRITEFILE(DSK, directory) opens up a file for writing.  On a Lisp
Machine one uses WRITEFILE("filename").  All interaction between the
user and MACSYMA is then recorded in this file, just as it is on the
console.  Such a file is a transcript of the session, and is not
reloadable or batchable into MACSYMA again.  (See also CLOSEFILE.)

&XAXIS default: [FALSE] - if set to TRUE will cause the Y=0 axis to be
displayed (in PLOT commands).

&XGP - The Xerox Graphic Printer, an output device connected to MC.
It should only be used from local terminals or by agreement with
people at local terminals, as it often needs tending during the
printing process.  It can be used by the PLOT commands.

&XTHRU(exp) combines all terms of exp (which should be a sum) over a
common denominator without expanding products and exponentiated sums
as RATSIMP does.  XTHRU cancels common factors in the numerator and
denominator of rational expressions but only if the factors are
explicit.  Sometimes it is better to use XTHRU before RATSIMPing an
expression in order to cause explicit factors of the gcd of the
numerator and denominator to be canceled thus simplifying the
expression to be RATSIMPed.

(C1) ((X+2)**20-2*Y)/(X+Y)**20+(X+Y)**-19-X/(X+Y)**20;

                                                20
                     1           X       (X + 2)   - 2 Y
(D1)             --------- - --------- + ---------------
                        19          20             20
                 (Y + X)     (Y + X)        (Y + X)

(C2) XTHRU(%);

                                     20
                              (X + 2)   - Y
(D2)                          -------------
                                       20
                                (Y + X)

&YAXIS default: [FALSE] - if set to TRUE will cause the X=0 axis to be
displayed (in PLOT commands).

&ZEROBERN default: [TRUE] - if set to FALSE excludes the zero
BERNOULLI numbers.  (See the BERN function.)

&ZEROEQUIV(exp,var) tests whether the expression exp in the variable
var is equivalent to zero.  It returns either TRUE, FALSE, or
DONTKNOW.  For example ZEROEQUIV(SIN(2*X) - 2*SIN(X)*COS(X),X) returns
TRUE and ZEROEQUIV(%E^X+X,X) returns FALSE.  On the other hand
ZEROEQUIV(LOG(A*B) - LOG(A) - LOG(B),A) will return DONTKNOW because
of the presence of an extra parameter.  The restrictions are:

(1) Do not use functions that MACSYMA does not know how to
differentiate and evaluate.

(2) If the expression has poles on the real line, there may be errors
in the result (but this is unlikely to occur).

(3) If the expression contains functions which are not solutions to
first order differential equations (e.g.  Bessel functions) there may
be incorrect results.

(4) The algorithm uses evaluation at randomly chosen points for
carefully selected subexpressions.  This is always a somewhat
hazardous business, although the algorithm tries to minimize the
potential for error.

&ZEROMATRIX(m,n) - takes integers m,n as arguments and returns an m by
n matrix of 0's.

&ZETA(X) - gives the Riemann zeta function for certain integer values
of X.

&ZETA%PI default: [TRUE] - if FALSE, suppresses ZETA(n) giving
coeff*%PI^n for n even.

&ZRPOLY - The IMSL ZRPOLY routine for finding the zeros of simple
polynomials (single variable, real coefficients, non-negative integer
exponents), using the Jenkins-Traub technique.
To use it, do:  LOADFILE(IMSL,FASL,SHARE2);
The command is POLYROOTS(polynomial);
For more info, do: PRINTFILE(ZRPOLY,USAGE,SHARE2);
For a demo do: DEMO(ZRPOLY,DEMO,SHARE2); 
For general info on MACSYMA-IMSL packages, PRINTFILE(IMSL,USAGE,SHARE2);
Bugs/Comments/Questions to KMP@MC.

&ZSOLVE - For those who can make use of approximate numerical
solutions to problems, there is a package which calls a routine which
has been translated from the IMSL fortran library to solve N
simultaneous non-linear equations in N unknowns.  It uses black-box
techniques that probably aren't desirable if an exact solution can be
obtained from one of the smarter solvers (LINSOLVE, ALGSYS, etc).  But
for things that the other solvers don't attempt to handle, this can
probably give some very useful results.  For documentation, do
PRINTFILE(ZSOLVE,USAGE,SHARE2);.  For a demo do
BATCH(ZSOLVE,DEMO,SHARE2)$

&ZUNDERFLOW default: [TRUE] - if FALSE, an error will be signaled if
floating point underflow occurs.

&"[" - [ and ] are the characters which MACSYMA uses to delimit a
list.

&^^ - The non-commutative exponentiation operator.  The inverse of a
matrix may be obtained by using a negative exponent, i.e.  M^^-1.  See
also the INVERT command.
&