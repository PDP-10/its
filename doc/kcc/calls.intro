From Sun Release 3.2     Last change: 16 July 1986
Liberated 4/15/88 by ALAN 


INTRO(2)                  SYSTEM CALLS                   INTRO(2)



NAME
     intro - introduction to system calls and error numbers

SYNOPSIS
     #include <errno.h>

DESCRIPTION
     This section describes all of the system  calls.   A  "(2V)"
     heading  indicates that the system call performs differently
     when called from programs that use the  System  V  libraries
     (programs  compiled  using  /usr/5bin/cc).   On these pages,
     both the regular behavior  and  the  System  V  behavior  is
     described.

     Most of these calls have one  or  more  error  returns.   An
     error  condition  is  indicated  by  an otherwise impossible
     return value.  This is  almost  always  -1;  the  individual
     descriptions  specify  the  details.   Note that a number of
     system calls overload the meanings of these  error  numbers,
     and  that  the meanings must be interpreted according to the
     type and circumstances of the call.

     As with normal arguments, all return codes and  values  from
     functions  are  of  type integer unless otherwise noted.  An
     error number is also made available in the external variable
     errno, which is not cleared on successful calls.  Thus errno
     should be tested only after an error has occurred.

     Each system call description attempts to list  all  possible
     error  numbers.   The  following  is  a complete list of the
     errors and their names as given in <errno.h>.

     0    Error 0
          Unused.

     1  EPERM  Not owner
          Typically this error indicates an attempt to  modify  a
          file  in  some  way  forbidden  except  to its owner or
          super-user.  It is also returned for attempts by  ordi-
          nary users to do things allowed only to the super-user.

     2  ENOENT  No such file or directory
          This error occurs when a filename is specified and  the
          file  should  exist  but  doesn't,  or  when one of the
          directories in a pathname does not exist.

     3  ESRCH  No such process
          The process or process group  whose  number  was  given
          does not exist, or any such process is already dead.

     4  EINTR  Interrupted system call
          An asynchronous signal (such  as  interrupt  or  quit),
          which  the user has elected to catch, occurred during a
          system call.  If execution is resumed after  processing
          the  signal,  and  the system call is not restarted, it
          will appear as if the interrupted system call  returned
          this error condition.

     5  EIO  I/O error
          Some physical I/O error occurred.  This  error  may  in
          some  cases  occur on a call following the one to which
          it actually applies.

     6  ENXIO  No such device or address
          I/O on a special file refers to a subdevice which  does
          not  exist, or beyond the limits of the device.  It may
          also occur when, for example, a tape drive is  not  on-
          line or a disk pack is not loaded on a drive.

     7  E2BIG  Arg list too long
          An argument list longer than 10240 bytes  is  presented
          to execve.

     8  ENOEXEC  Exec format error
          A request is made to execute a file which, although  it
          has  the appropriate permissions, does not start with a
          valid magic number (see a.out(5)).

     9  EBADF  Bad file number
          Either a file descriptor refers to no open file,  or  a
          read  (respectively,  write)  request is made to a file
          which is open only for writing (respectively, reading).

     10  ECHILD  No children
          A wait was executed by a process that had  no  existing
          or unwaited-for child processes.

     11  EAGAIN  No more processes
          A fork failed because the  system's  process  table  is
          full  or  the  user  is  not allowed to create any more
          processes.

     12  ENOMEM  Not enough memory
          During an execve, brk, or sbrk, a program asks for more
          address  space or swap space than the system is able to
          supply, or a process size limit would be  exceeded.   A
          lack  of  swap space is normally a temporary condition;
          however, a lack of address space  is  not  a  temporary
          condition.   The  maximum  size  of the text, data, and
          stack segments is a system parameter.  Soft limits  may
          be increased to their corresponding hard limits.

     13  EACCES  Permission denied
          An attempt was made to access a file in a way forbidden
          by the protection system.

     14  EFAULT  Bad address
          The system encountered a hardware fault  in  attempting
          to access the arguments of a system call.

     15  ENOTBLK  Block device required
          A file which is not a block device was mentioned  where
          a block device was required, for example, in mount.

     16  EBUSY  Device busy
          An attempt to mount a  file  system  that  was  already
          mounted  or an attempt was made to dismount a file sys-
          tem on which  there  is  an  active  file  (open  file,
          current directory, mounted-on file, or active text seg-
          ment).

     17  EEXIST  File exists
          An existing file was mentioned in an inappropriate con-
          text, for example, link.

     18  EXDEV  Cross-device link
          A hard link to  a  file  on  another  file  system  was
          attempted.

     19  ENODEV  No such device
          An attempt was made to apply  an  inappropriate  system
          call  to  a  device  (for example, an attempt to read a
          write-only device) or an attempt was made to use a dev-
          ice not configured by the system.

     20  ENOTDIR  Not a directory
          A non-directory was  specified  where  a  directory  is
          required,  for example, in a pathname or as an argument
          to chdir.

     21  EISDIR  Is a directory
          An attempt was made to write on a directory.

     22  EINVAL  Invalid argument
          A system call was made with an  invalid  argument;  for
          example,  dismounting  a  non-mounted file system, men-
          tioning an unknown signal in sigvec or kill, reading or
          writing a file for which lseek has generated a negative
          pointer, or some other argument inappropriate  for  the
          call.  Also set by math functions, see intro(3).

     23  ENFILE  File table overflow
          The system's table of open  files  is  full,  and  tem-
          porarily no more opens can be accepted.

     24  EMFILE  Too many open files
          A process tried to have more open files than the system
          allows  a process to have.  The customary configuration
          limit is 30 per process.

     25  ENOTTY  Inappropriate ioctl for device
          The code used in an ioctl call is not supported by  the
          object that the file descriptor in the call refers to.

     26  ETXTBSY  Text file busy
          An attempt to execute a pure-procedure program which is
          currently  open  for  writing.  Also an attempt to open
          for writing a pure-procedure program that is being exe-
          cuted.

     27  EFBIG  File too large
          The size of a  file  exceeded  the  maximum  file  size
          (1,082,201,088 bytes).

     28  ENOSPC  No space left on device
          A write to an ordinary file, the creation of  a  direc-
          tory  or  symbolic link, or the creation of a directory
          entry failed because no more disk blocks are  available
          on the file system, or the allocation of an inode for a
          newly created file failed because no  more  inodes  are
          available on the file system.

     29  ESPIPE  Illegal seek
          An lseek was issued to a socket or  pipe.   This  error
          may also be issued for other non-seekable devices.

     30  EROFS  Read-only file system
          An attempt to modify a file or directory was made on  a
          file system mounted read-only.

     31  EMLINK  Too many links
          An attempt to make more than  32767  hard  links  to  a
          file.

     32  EPIPE  Broken pipe
          An attempt was made to write on a pipe  or  socket  for
          which  there is no process to read the data.  This con-
          dition  normally  generates  a  signal;  the  error  is
          returned if the signal is caught or ignored.

     33  EDOM  Math argument
          The argument of a function  in  the  math  library  (as
          described  in  section  3M) is out of the domain of the
          function.

     34  ERANGE  Result too large
          The value  of  a  function  in  the  math  library  (as
          described  in  section  3M)  is  unrepresentable within
          machine precision.

     35  EWOULDBLOCK  Operation would block
          An operation which would cause a process to  block  was
          attempted  on  an  object  in  non-blocking  mode  (see
          ioctl(2)).

     36  EINPROGRESS  Operation now in progress
          An operation which takes a long time to complete  (such
          as a connect(2)) was attempted on a non-blocking object
          (see ioctl(2)).

     37  EALREADY  Operation already in progress
          An operation was attempted  on  a  non-blocking  object
          which already had an operation in progress.

     38  ENOTSOCK  Socket operation on non-socket
          Self-explanatory.

     39  EDESTADDRREQ  Destination address required
          A required address was omitted from an operation  on  a
          socket.

     40  EMSGSIZE  Message too long
          A message sent on a socket was larger than the internal
          message buffer.

     41  EPROTOTYPE  Protocol wrong type for socket
          A protocol was specified which  does  not  support  the
          semantics  of  the  socket type requested. For example,
          you cannot use the ARPA Internet UDP protocol with type
          SOCK_STREAM.

     42  ENOPROTOOPT  Option not supported by protocol
          A bad option was specified in a getsockopt(2)  or  set-
          sockopt(2) call.

     43  EPROTONOSUPPORT  Protocol not supported
          The protocol has not been configured into the system or
          no implementation for it exists.

     44  ESOCKTNOSUPPORT  Socket type not supported
          The support for the socket type has not been configured
          into the system or no implementation for it exists.

     45  EOPNOTSUPP  Operation not supported on socket
          For  example,  trying  to  accept  a  connection  on  a
          datagram socket.

     46  EPFNOSUPPORT  Protocol family not supported
          The protocol family has not been  configured  into  the
          system or no implementation for it exists.

     47  EAFNOSUPPORT  Address family not supported  by  protocol
          family
          An address incompatible with the requested protocol was
          used.  For example, you shouldn't necessarily expect to
          be able to use PUP Internet addresses with ARPA  Inter-
          net protocols.

     48  EADDRINUSE  Address already in use
          Only one usage of each address is normally permitted.

     49  EADDRNOTAVAIL  Can't assign requested address
          Normally results from an attempt  to  create  a  socket
          with an address not on this machine.

     50  ENETDOWN  Network is down
          A socket operation encountered a dead network.

     51  ENETUNREACH  Network is unreachable
          A socket operation was attempted to an unreachable net-
          work.

     52  ENETRESET  Network dropped connection on reset
          The host you were connected to crashed and rebooted.

     53  ECONNABORTED  Software caused connection abort
          A connection abort was caused  internal  to  your  host
          machine.

     54  ECONNRESET  Connection reset by peer
          A connection was forcibly closed by a peer.  This  nor-
          mally  results  from  the  peer executing a shutdown(2)
          call.

     55  ENOBUFS  No buffer space available
          An operation on a socket  or  pipe  was  not  performed
          because the system lacked sufficient buffer space.

     56  EISCONN  Socket is already connected
          A connect request was  made  on  an  already  connected
          socket;  or, a sendto or sendmsg request on a connected
          socket specified a destination other than the connected
          party.

     57  ENOTCONN  Socket is not connected
          An request to  send  or  receive  data  was  disallowed
          because the socket is not connected.

     58  ESHUTDOWN  Can't send after socket shutdown
          A request to  send  data  was  disallowed  because  the
          socket  had  already  been  shut  down  with a previous
          shutdown(2) call.

     59  unused

     60  ETIMEDOUT  Connection timed out
          A connect request failed because  the  connected  party
          did  not properly respond after a period of time.  (The
          timeout period is dependent on the communication proto-
          col.)

     61  ECONNREFUSED  Connection refused
          No connection could be made because the target  machine
          actively  refused it.  This usually results from trying
          to connect to  a  service  which  is  inactive  on  the
          foreign host.

     62  ELOOP  Too many levels of symbolic links
          A pathname lookup involved more than 8 symbolic links.

     63  ENAMETOOLONG  File name too long
          A component of a pathname exceeded 255  characters,  or
          an entire pathname exceeded 1023 characters.

     64  EHOSTDOWN  Host is down
          A socket operation failed because the destination  host
          was down.

     65  EHOSTUNREACH  Host is unreachable
          A socket operation  was  attempted  to  an  unreachable
          host.

     66  ENOTEMPTY  Directory not empty
          An attempt was made to remove a directory with  entries
          other  than  . and .. by performing a rmdir system call
          or a rename system call with that  directory  specified
          as the target directory.

     67  unused

     68  unused

     69  EDQUOT  Disc quota exceeded
          A write to an ordinary file, the creation of  a  direc-
          tory  or  symbolic link, or the creation of a directory
          entry failed because the user's quota  of  disk  blocks
          was  exhausted,  or  the  allocation  of an inode for a
          newly created file failed because the user's  quota  of
          inodes was exhausted.

     70  ESTALE  Stale NFS file handle
          A client referenced a an open file, when the  file  has
          been deleted.

     71  EREMOTE  Too many levels of remote in path
          An attempt was made to remotely  mount  a  file  system
          into  a  path which already has a remotely mounted com-
          ponent.

     72  unused

     73  unused

     74  unused

     75  ENOMSG  No message of desired type
          An attempt was made to receive a message of a type that
          does  not  exist  on  the  specified message queue; see
          msgop(2).

     76  unused

     77  EIDRM  Identifier removed
          This error is returned to processes that resume  execu-
          tion  due  to the removal of an identifier from the IPC
          system's name  space  (see  msgctl(2),  semctl(2),  and
          shmctl(2)).

DEFINITIONS
  Descriptor
     An integer assigned by the system when a file is  referenced
     by open(2V), dup(2), or pipe(2) or a socket is referenced by
     socket(2) or  socketpair(2)  which  uniquely  identifies  an
     access  path  to that file or socket from a given process or
     any of its children.

  Directory
     A directory is a special type of file which contains entries
     which  are references to other files.  Directory entries are
     called links.  By convention, a directory contains at  least
     two  links, . and .., referred to as dot and dot-dot respec-
     tively.  Dot refers to  the  directory  itself  and  dot-dot
     refers to its parent directory.

  Effective User ID, Effective Group ID, and Access Groups
     Access to system resources is governed by three values:  the
     effective  user  ID,  the  effective group ID, and the group
     access list.

     The effective user ID and effective group ID  are  initially
     the  process's  real user ID and real group ID respectively.
     Either may be modified through execution of a set-user-ID or
     set-group-ID  file  (possibly  by one of its ancestors) (see
     execve(2)).

     The group access list is an additional  set  of  group  ID's
     used  only  in  determining  resource accessibility.  Access
     checks are performed as described  below  in  ``File  Access
     Permissions''.

  File Access Permissions
     Every file in the file system has a set  of  access  permis-
     sions.   These permissions are used in determining whether a
     process may perform a requested operation on the file  (such
     as  opening  a  file  for  writing).  Access permissions are
     established at the time a file  is  created.   They  may  be
     changed at some later time through the chmod(2) call.

     File access is broken down according to whether a  file  may
     be:  read,  written,  or  executed.  Directory files use the
     execute permission  to  control  if  the  directory  may  be
     searched.

     File access permissions are interpreted  by  the  system  as
     they apply to three different classes of users: the owner of
     the file, those users in  the  file's  group,  anyone  else.
     Every  file has an independent set of access permissions for
     each of these classes.  When an access check  is  made,  the
     system  decides  if permission should be granted by checking
     the access information applicable to the caller.

     Read, write, and execute/search permissions on  a  file  are
     granted to a process if:

          The process's effective user ID is that of  the  super-
          user.

          The process's effective user ID matches the user ID  of
          the  owner  of the file and the owner permissions allow
          the access.

          The process's effective user ID does not match the user
          ID  of  the owner of the file, and either the process's
          effective group ID matches the group ID of the file, or
          the  group  ID  of  the  file is in the process's group
          access  list,  and  the  group  permissions  allow  the
          access.

          Neither the effective user ID nor  effective  group  ID
          and   group  access  list  of  the  process  match  the
          corresponding user ID and group ID of the file, but the
          permissions for ``other users'' allow access.

     Otherwise, permission is denied.

  File Name
     Names consisting of up to 255 characters may be used to name
     an ordinary file, special file, or directory.

     These characters may be selected from the set of  all  ASCII
     character  excluding  \0  (null)  and  the  ASCII code for /
     (slash).  (The parity bit, bit 8, must be 0.)

     Note that it is generally unwise to use *, ?,  [,  or  ]  as
     part of filenames because of the special meaning attached to
     these characters by the shell.  See sh(1).  Although permit-
     ted, it is advisable to avoid the use of unprintable charac-
     ters in filenames.

  Message Queue Identifier
     A message queue identifier  (msqid)  is  a  unique  positive
     integer  created by a msgget(2) system call.  Each msqid has
     a message queue and a data  structure  associated  with  it.
     The  data  structure is referred to as msqid_ds and contains
     the following members:

          struct  ipc_perm msg_perm;  /* operation permission struct */
          ushort  msg_qnum;           /* number of msgs on q */
          ushort  msg_qbytes;         /* max number of bytes on q */
          ushort  msg_lspid;          /* pid of last msgsnd operation */
          ushort  msg_lrpid;          /* pid of last msgrcv operation */
          time_t  msg_stime;          /* last msgsnd time */
          time_t  msg_rtime;          /* last msgrcv time */
          time_t  msg_ctime;          /* last change time */
                                      /* Times measured in secs since */
                                      /* 00:00:00 GMT, Jan. 1, 1970 */

     msg_perm is an ipc_perm structure that specifies the message
     operation  permission  (see below).  This structure includes
     the following members:

          ushort  cuid;       /* creator user id */
          ushort  cgid;       /* creator group id */
          ushort  uid;        /* user id */
          ushort  gid;        /* group id */
          ushort  mode;       /* r/w permission */

     msg_qnum is the number of messages currently on  the  queue.
     msg_qbytes  is  the  maximum  number of bytes allowed on the
     queue.  msg_lspid is the process id of the last process that
     performed  a  msgsnd operation.  msg_lrpid is the process id
     of the last  process  that  performed  a  msgrcv  operation.
     msg_stime   is  the  time  of  the  last  msgsnd  operation,
     msg_rtime is the time of  the  last  msgrcv  operation,  and
     msg_ctime  is  the time of the last msgctl(2) operation that
     changed a member of the above structure.

  Message Operation Permissions
     In the msgop(2) and msgctl(2) system call descriptions,  the
     permission  required for an operation is given as "{token}",
     where "token" is the type of permission  needed  interpreted
     as follows:

            00400          Read by user
            00200          Write by user
            00060          Read, Write by group
            00006          Read, Write by others

     Read and Write permissions on a msqid are granted to a  pro-
     cess if one or more of the following are true:

          The effective user ID of the process is super-user.

          The  effective  user  ID   of   the   process   matches
          msg_perm.[c]uid  in  the data structure associated with
          msqid and the appropriate bit of the  ``user''  portion
          (0600) of msg_perm.mode is set.

          The effective user ID of the  process  does  not  match
          msg_perm.[c]uid  and the effective group ID of the pro-
          cess matches msg_perm.[c]gid and the appropriate bit of
          the ``group'' portion (060) of msg_perm.mode is set.

          The effective user ID of the  process  does  not  match
          msg_perm.[c]uid  and the effective group ID of the pro-
          cess does not match msg_perm.[c]gid and the appropriate
          bit  of  the ``other'' portion (06) of msg_perm.mode is
          set.

     Otherwise, the corresponding permissions are denied.

  Parent Process ID
     A new process is created by a currently active process  (see
     fork(2)).  The parent process ID of a process is the process
     ID of its creator.

  Path Name and Path Prefix
     A pathname is a null-terminated  character  string  starting
     with  an optional slash (/), followed by zero or more direc-
     tory names separated by slashes, optionally  followed  by  a
     filename.   The total length of a pathname must be less than
     {MAXPATHLEN} (1024) characters.

     More precisely, a pathname is  a  null-terminated  character
     string constructed as follows:

          <path-name>::=<file-name>|<path-prefix><file-name>|/
          <path-prefix>::=<rtprefix>|/<rtprefix>
          <rtprefix>::=<dirname>/|<rtprefix><dirname>/

     where <file-name> is a string of 1 to 255  characters  other
     than  the ASCII slash and null, and <dirname> is a string of
     1 to 255 characters (other than the ASCII  slash  and  null)
     that names a directory.

     If a pathname begins with a slash, the search begins at  the
     root directory.  Otherwise, the search begins at the current
     working directory.

     A slash, by itself, names the  root  directory.  A  dot  (.)
     names the current working directory.

     A null pathname also refers to the current  directory.  How-
     ever,  this  is  not true of all UNIX systems. (On such sys-
     tems, accidental use of a null  pathname  in  routines  that
     don't  check  for  it may corrupt the current working direc-
     tory.) For portable  code,  specify  the  current  directory
     explicitly using ".", rather than "".

  Process Group ID
     Each active process is a member of a process group  that  is
     identified  by  a  positive integer called the process group
     ID.  This is the process  ID  of  the  group  leader.   This
     grouping  permits  the  signaling  of related processes (see
     killpg(2)) and the job control mechanisms of csh(1).

  Process ID
     Each active process in the system is uniquely identified  by
     a  positive  integer called a process ID.  The range of this
     ID is from 0 to 30000.

  Real User ID and Real Group ID
     Each user on the system is identified by a positive  integer
     termed the real user ID.

     Each user is also a member of one or  more  groups.  One  of
     these groups is distinguished from others and used in imple-
     menting  accounting  facilities.    The   positive   integer
     corresponding to this distinguished group is termed the real
     group ID.

     All processes have a real user ID and real group ID.   These
     are  initialized  from the equivalent attributes of the pro-
     cess which created it.

  Root Directory and Current Working Directory
     Each process has associated with it  a  concept  of  a  root
     directory and a current working directory for the purpose of
     resolving path name searches.  A  process's  root  directory
     need not be the root directory of the root file system.

  Semaphore Identifier
     A semaphore identifier (semid) is a unique positive  integer
     created by a semget(2) system call.  Each semid has a set of
     semaphores and a data structure  associated  with  it.   The
     data  structure  is referred to as semid_ds and contains the
     following members:

          struct  ipc_perm sem_perm;  /* operation permission struct */
          ushort  sem_nsems;          /* number of sems in set */
          time_t  sem_otime;          /* last operation time */
          time_t  sem_ctime;          /* last change time */
                                      /* Times measured in secs since */
                                      /* 00:00:00 GMT, Jan. 1, 1970 */

     sem_perm is an ipc_perm structure that specifies  the  sema-
     phore  operation  permission  (see  below).   This structure
     includes the following members:

          ushort  cuid;       /* creator user id */
          ushort  cgid;       /* creator group id */
          ushort  uid;        /* user id */
          ushort  gid;        /* group id */
          ushort  mode;       /* r/a permission */

     The value of sem_nsems is equal to the number of  semaphores
     in  the  set.   Each semaphore in the set is referenced by a
     positive integer referred to as a sem_num.   sem_num  values
     run  sequentially  from 0 to the value of sem_nsems minus 1.
     sem_otime is the time of the last  semop(2)  operation,  and
     sem_ctime  is  the time of the last semctl(2) operation that
     changed a member of the above structure.

     A semaphore is a data structure that contains the  following
     members:

          ushort  semval;     /* semaphore value */
          short   sempid;     /* pid of last operation  */
          ushort  semncnt;    /* # awaiting semval > cval */
          ushort  semzcnt;    /* # awaiting semval = 0 */

     semval is a non-negative integer.  sempid is  equal  to  the
     process  ID  of  the last process that performed a semaphore
     operation on this semaphore.  semncnt  is  a  count  of  the
     number  of  processes  that are currently suspended awaiting
     this semaphore's semval to become greater than  its  current
     value.   semzcnt  is a count of the number of processes that
     are currently suspended awaiting this semaphore's semval  to
     become zero.

  Semaphore Operation Permissions
     In the semop(2) and semctl(2) system call descriptions,  the
     permission  required for an operation is given as "{token}",
     where "token" is the type of permission  needed  interpreted
     as follows:

            00400          Read by user
            00200          Alter by user
            00060          Read, Alter by group
            00006          Read, Alter by others

     Read and Alter permissions on a semid are granted to a  pro-
     cess if one or more of the following are true:

          The effective user ID of the process is super-user.

          The  effective  user  ID   of   the   process   matches
          sem_perm.[c]uid  in  the data structure associated with
          semid and the appropriate bit of the  ``user''  portion
          (0600) of sem_perm.mode is set.

          The effective user ID of the  process  does  not  match
          sem_perm.[c]uid  and the effective group ID of the pro-
          cess matches sem_perm.[c]gid and the appropriate bit of
          the ``group'' portion (060) of sem_perm.mode is set.

          The effective user ID of the  process  does  not  match
          sem_perm.[c]uid  and the effective group ID of the pro-
          cess does not match sem_perm.[c]gid and the appropriate
          bit  of  the ``other'' portion (06) of sem_perm.mode is
          set.

     Otherwise, the corresponding permissions are denied.

  Shared Memory Identifier
     A shared memory identifier  (shmid)  is  a  unique  positive
     integer  created by a shmget(2) system call.  Each shmid has
     a segment of memory (referred to as a shared memory segment)
     and a data structure associated with it.  The data structure
     is referred  to  as  shmid_ds  and  contains  the  following
     members:

          struct  ipc_perm shm_perm;  /* operation permission struct */
          int     shm_segsz;          /* size of segment */
          ushort  shm_cpid;           /* creator pid */
          ushort  shm_lpid;           /* pid of last operation */
          short   shm_nattch;         /* number of current attaches */
          time_t  shm_atime;          /* last attach time */
          time_t  shm_dtime;          /* last detach time */
          time_t  shm_ctime;          /* last change time */
                                      /* Times measured in secs since */
                                      /* 00:00:00 GMT, Jan. 1, 1970 */

     shm_perm is an ipc_perm structure that specifies the  shared
     memory  operation  permission  (see  below).  This structure
     includes the following members:

          ushort  cuid;       /* creator user id */
          ushort  cgid;       /* creator group id */
          ushort  uid;        /* user id */
          ushort  gid;        /* group id */
          ushort  mode;       /* r/w permission */

     shm_segsz specifies the size of the shared  memory  segment.
     shm_cpid  is  the process id of the process that created the
     shared memory identifier.  shm_lpid is the process id of the
     last   process   that   performed   a   shmop(2)  operation.
     shm_nattch is the number of processes  that  currently  have
     this  segment  attached.   shm_atime is the time of the last
     shmat operation, shm_dtime is the time  of  the  last  shmdt
     operation,  and  shm_ctime is the time of the last shmctl(2)
     operation that changed one  of  the  members  of  the  above
     structure.

  Shared Memory Operation Permissions
     In the shmop(2) and shmctl(2) system call descriptions,  the
     permission  required for an operation is given as "{token}",
     where "token" is the type of permission  needed  interpreted
     as follows:

            00400          Read by user
            00200          Write by user
            00060          Read, Write by group
            00006          Read, Write by others

     Read and Write permissions on a shmid are granted to a  pro-
     cess if one or more of the following are true:

          The effective user ID of the process is super-user.

          The  effective  user  ID   of   the   process   matches
          shm_perm.[c]uid  in  the data structure associated with
          shmid and the appropriate bit of the  ``user''  portion
          (0600) of shm_perm.mode is set.

          The effective user ID of the  process  does  not  match
          shm_perm.[c]uid  and the effective group ID of the pro-
          cess matches shm_perm.[c]gid and the appropriate bit of
          the ``group'' portion (060) of shm_perm.mode is set.

          The effective user ID of the  process  does  not  match
          shm_perm.[c]uid  and the effective group ID of the pro-
          cess does not match shm_perm.[c]gid and the appropriate
          bit  of  the ``other'' portion (06) of shm_perm.mode is
          set.

     Otherwise, the corresponding permissions are denied.

  Sockets and Address Families
     A socket is an endpoint for communication between processes.
     Each socket has queues for sending and receiving data.

     Sockets are typed according to their communications  proper-
     ties.   These  properties  include whether messages sent and
     received at a  socket  require  the  name  of  the  partner,
     whether communication is reliable, the format used in naming
     message recipients, etc.

     Each instance of the  system  supports  some  collection  of
     socket  types;  consult socket(2) for more information about
     the types available and their properties.

     Each instance of the system supports some number of sets  of
     communications   protocols.    Each  protocol  set  supports
     addresses of a certain format.  An Address Family is the set
     of addresses for a specific group of protocols.  Each socket
     has an address chosen from the address family in  which  the
     socket was created.

  Special Processes
     The processes with a process ID's of 0, 1, and  2  are  spe-
     cial.   Process  0  is the scheduler.  Process 1 is the ini-
     tialization process init, and is the ancestor of every other
     process  in  the  system.  It is used to control the process
     structure.  Process 2 is the paging daemon.

  Super-user
     A process is recognized  as  a  super-user  process  and  is
     granted special privileges if its effective user ID is 0.

  Tty Group ID
     Each active process can be a member of a terminal group that
     is identified by a positive integer called the tty group ID.
     This grouping is used to  arbitrate  between  multiple  jobs
     contending for the same terminal (see csh(1), and tty(4)).

SEE ALSO
     intro(3), perror(3)


LIST OF SYSTEM CALLS
     Name                Appears on Page          Description

     _exit               exit(2)                  terminate a process
     accept              accept(2)                accept a connection on a socket
     access              access(2)                determine accessibility of file
     acct                acct(2)                  turn accounting on or off
     adjtime             adjtime(2)               correct the time to allow synchronization of the system clock
     async_daemon        nfssvc(2)                NFS daemons
     bind                bind(2)                  bind a name to a socket
     brk                 brk(2)                   change data segment size
     chdir               chdir(2)                 change current working directory
     chmod               chmod(2)                 change mode of file
     chown               chown(2)                 change owner and group of a file
     chroot              chroot(2)                change root directory
     close               close(2)                 delete a descriptor
     connect             connetc(2)               initiate a connection on a socket
     creat               creat(2)                 create a new file
     dup                 dup(2)                   duplicate a descriptor
     dup2                dup(2)                   duplicate a descriptor
     execve              execve(2)                execute a file
     fchmod              chmod(2)                 change mode of file
     fchown              chown(2)                 change owner and group of a file
     fcntl               fcntl(2)                 file control
     flock               flock(2)                 apply or remove an advisory lock on an open file
     fork                fork(2)                  create a new process
     fstat               stat(2)                  get file status
     fsync               fsync(2)                 synchronize a file's in-core state with that on disk
     ftruncate           truncate(2)              truncate a file to a specified length
     getdirentries       getdirentries(2)         gets directory entries in a filesystem independent format
     getdomainname       getdomainname(2)         get name of current domain
     getdtablesize       getdtablesize(2)         get descriptor table size
     getegid             getgid(2)                get group identity
     geteuid             getuid(2)                get effective user identity
     getgid              getgid(2)                get group identity
     getgroups           getgroups(2)             get group access list
     gethostid           gethostid(2)             get unique identifier of current host
     gethostname         gethostname(2)           get name of current host
     getitimer           getitimer(2)             get value of interval timer
     getpagesize         getpagesizename(2)       get system page size
     getpeername         getpeername(2)           get name of connected peer
     getpgrp             setpgrp(2V)              set and/or return the process group of a process
     getpid              getpid(2)                get parent process identification
     getppid             getpid(2)                get process identification
     getpriority         getpriority(2)           get program scheduling priority
     getrlimit           getrlimit(2)             control maximum system resource consumption
     getrusage           getrusage(2)             get information about resource utilization
     getsockname         getsockname(2)           get socket name
     getsockopt          getsockopt(2)            get options on sockets
     gettimeofday        gettimeofday(2)          get date and time
     getuid              getuid(2)                get user identity
     ioctl               ioctl(2)                 control device
     kill                kill(2)                  send signal to a process
     killpg              killpg(2)                send signal to a process group
     link                link(2)                  make a hard link to a file
     listen              listen(2)                listen for connections on a socket
     lseek               lseek(2)                 move read/write pointer
     lstat               stat(2)                  get file status
     mkdir               mkdir(2)                 make a directory file
     mknod               mknod(2)                 make a special file
     mmap                mmap(2)                  map or unmap pages of memory
     mount               mount(2)                 mount file system
     msgctl              msgctl(2)                message control operations
     msgget              msgget(2)                get message queue
     msgop               msgop(2)                 message operations
     msgrcv              msgop(2)                 message operations
     msgsnd              msgop(2)                 message operations
     munmap              munmap(2)                map or unmap pages of memory
     nfssvc              nfssvc(2)                NFS daemons
     open                open(2V)                 open or create a file for reading or writing
     pipe                pipe(2)                  create an interprocess communication channel
     profil              profil(2)                execution time profile
     ptrace              ptrace(2)                process trace
     quotactl            quotactl(2)              manipulate disk quotas
     read                read(2V)                 read input
     readlink            readlink(2)              read value of a symbolic link
     readv               read(2V)                 read input
     reboot              reboot(2)                reboot system or halt processor
     recv                recv(2)                  receive a message from a socket
     recvfrom            recv(2)                  receive a message from a socket
     recvmsg             recv(2)                  receive a message from a socket
     rename              rename(2)                change the name of a file
     rmdir               rmdir(2)                 remove a directory file
     sbrk                brk(2)                   change data segment size
     select              select(2)                synchronous I/O multiplexing
     semctl              semctl(2)                semaphore control operations
     semget              semget(2)                get set of semaphores
     semop               semop(2)                 semaphore operations
     send                send(2)                  send a message from a socket
     sendmsg             send(2)                  send a message from a socket
     sendto              send(2)                  send a message from a socket
     setdomainname       getdomainname(2)         set name of current domain
     setgroups           getgroups(2)             set group access list
     sethostname         gethostname(2)           set name of current host
     setitimer           getitimer(2)             set value of interval timer
     setpgrp             setpgrp(2V)              set and/or return the process group of a process
     setpriority         getpriority(2)           set program scheduling priority
     setregid            setregid(2)              set real and effective group IDs
     setreuid            setreuid(2)              set real and effective user IDs
     setrlimit           getrlimit(2)             control maximum system resource consumption
     setsockopt          getsockopt(2)            set options on sockets
     settimeofday        gettimeofday(2)          set date and time
     shmat               shmop(2)                 shared memory operations
     shmctl              shmctl(2)                shared memory control operations
     shmdt               shmop(2)                 shared memory operations
     shmget              shmget(2)                get shared memory segment
     shmop               shmop(2)                 shared memory operations
     shutdown            shutdown(2)              shut down part of a full-duplex connection
     sigblock            sigblock(2)              block signals
     sigpause            sigpause(2)              atomically release blocked signals and wait for interrupt
     sigsetmask          sigsetmask(2)            set current signal mask
     sigstack            sigstack(2)              set and/or get signal stack context
     sigvec              sigvec(2)                software signal facilities
     socket              socket(2)                create an endpoint for communication
     socketpair          socketpair(2)            create a pair of connected sockets
     stat                stat(2)                  get file status
     statfs              statfs(2)                get file system statistics
     swapon              swapon(2)                add a swap device for interleaved paging/swapping
     symlink             symlink(2)               make symbolic link to a file
     sync                sync(2)                  update super-block
     syscall             syscall(2)               indirect system call
     tell                lseek(2)                 locate read/write pointer
     truncate            truncate(2)              truncate a file to a specified length
     umask               umask(2)                 set file creation mode mask
     uname               uname(2V)                get name of current UNIX system
     unlink              unlink(2)                remove directory entry
     unmount             umount(2)                remove a file system
     utimes              utimes(2)                set file times
     vadvise             vadvise(2)               give advice to paging system
     vfork               vfork(2)                 spawn new process in a virtual memory efficient way
     vhangup             vhangup(2)               virtually ``hangup'' the current control terminal
     wait                wait(2)                  wait for process to terminate or stop
     wait3               wait(2)                  wait for process to terminate or stop
     write               write(2V)                write output
     writev              write(2V)                write output
