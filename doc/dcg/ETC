ON A KA10
FORTY	=>	40
UUOH	=>	XUUOH

000040		MUUO SAVE
000041		JSR UUOH

THIS IS WHAT A UUO DOES
WHEN RUNNING IN THE UUO HANDLER THE FL,,PC OF THE JOB THAT IS
DOING THE UUO IS LYING IN XUUOH
	
XUUOH:		0
UUOH0:		SAVE AC'S INTO SHADOW
			...
			JRST URET
URET:		RESTORE AC'S FROM SHADOW
			JRST ULEAVE
ULEAVE:		JRST 2,@UUOH

THIS IS WHAT THE CLOCK DOES
THE CLOCK IS THE THING THAT DOES ALL THE RESCHEDULING
WHEN A JOB IS RUNNING, THE ACS ARE IN THE ACS, AND
(1)		THE MOVEM AT CLUSAV HAS AN ABSOLUTE ADDRESS THAT POINTS TO AC17S(U)
(2)		THE JRST 2 AT UEXIT HAS AN ABSOLUTE ADDRESS THAT POINTS TO XUUOH ON THE KA (SO THE
		UPDATE IS A WASTE) AND AT XUUOH(U) ON THE OTHERS (WHICH ISN'T)
WHEN A JOB ISN'T RUNNING, THE ACS ARE IN AC0S(U) THROUGH AC17S(U), FL,,PC IS IN UPC(U)
THE JOB MAY BE RUNNING IN A UUO, IN WHICH CASE
(1)		THE OP/AC/EA FOR THE UUO IS IN ABSOLUTE LOCATION 000040
(2)		THE FL,,PC FOR THE UUO IS IN XUUOH (WHERE JSR IN 41 POINTS, HENCE @41)
(3)		THE USER'S UUO ACS ARE IN UUOACS(U) (LOC 0-17 OF XCTR, BECAUSE OF REMAP)
WHEN A JOB IS NOT RUNNING
(1)		THE UUO WORD (FROM LOCATION 000040) IS IN SV40(U)
(2)		XUUOH IS IN SUUOH(U)
(3)		THE USER'S UUO ACS ARE IN UUOACS(U) (LOC 0-17 OF XCTR, BECAUSE OF REMAP)

ALL MUUOS (AND EXEC MODE LUUOS) ARE PROCESSED BY UUOH (THERE IS A JSR UUOH IN 000041)
ON NON-KA MACHINES THE SYSJOB ALLOWS MUUOS, BUT EVERYONE ELSE BUGCHECKS

TRAPS ARE PROCESSED AT CODE THAT BEGINS AT CLKB1, INVOKED BY THE APR
(CLK) PI HANDLER TRAPS CAN BE PROCESSED AT LOW PRIORITY BECAUSE THE CLK
PI HANDLER DOES THE CONTEXT SWITCHING, AND THE CHECK FOR TRAPS HAPPENS
BEFORE ANY CONTEXT SWITCHING, SO THE CLK PI HANDLER IS GUARANTEED TO
HAVE INTERRUPTED THE RIGHT JOB (ALTHOUGH BAD THINGS WOULD HAPPEN IF A
HIGHER-PRIORITY PI ROUTINE EVERY SET A TRAP FLAG, SINCE THE TRAP WOULD
HANG AROUND UNTIL THE HIGHER-PRIORITY HANDLER EXITED, AND THEN THE USER
JOB WOULD BE INTERRUPTED, BUT THE JOB ISN'T DOING ANYTHING RELATED TO
THE TRAP) THE CODE IN THE CLK PI HANDLER CALLS ROUTINES LIKE "AROV"
WHICH TURNS OFF BITS IN THE SAVED FLAGS IN CLKBRK, AND SETS SW PI BITS
IN A, WHICH EVENTUALLY GET TRANSFORMED INTO ITS-STYLE SOFTWARE
INTERRUPTS

THERE ARE USET VARIABLES WITH NAMES LIKE TR1INS AND SUCH ON THE KA,
THESE ARE SOMEWHAT DEGENERATE THE BIG TABLE AT USETL HAS THE TRAP
VARIABLES WITH MODE 2, 2, 0, 0 WHICH MEANS CALL ROUTINE ON READ, AND
ILLEGAL ON WRITE THE READ ROUTINES (URTRnI) SIMPLY READS THE "TRAP
INSTRUCTION" FOR THE KA WHICH IS ALWAYS A 0,,%PIXXX WORD, BECAUSE
POSTING AN INTERRUPT IS THE ONLY THING THAT IS POSSIBLE

KA10 PAGING ERROR CHECK IS AT CLKB1H

IF XCTRI DID NOT WHACK DATAI PAG, AND WE DID NOT NEED TO RUN THE ERROR
HANDLER AT HIGH PRIORITY SO THAT THE HIGH PRIORITY HANDLER COULD MOVE
THE RESULT OF THE DATAI PAG TO SOME PLACE IN THE USER VARIABLES, COULD
THE ERROR AND TRAP PI BE RUN AT PI 7 ?

THE KA IS A LITTLE BIT LIKE THIS
IT'S EQUIVALENT OF BY DATAI PAG IS SPM, WHICH STORES THE MAPS
CLKBRK DOES ONE OF THESE RIGHT AT THE START, INTO UPGML (NULL JOB) OR UPGML(U) (OTHERS)
UPJPC:		0		FAULT ADDRESS,,0
UPOPC:		0		OLDFL,,OLDPC					USED TO TELL IF PC MOVES ?
UPMAR:		0		MAR ADDRESS AND CONDITION
UPQUAN:		0		EXPGNG+1,,0						PE, QUAN
UPDBR1:		0		USER MAP
UPDBR2:		0		USER MAP
UPDBR3:		0		EXEUMP (EXEC MODE UPPER MAP)	LOADED WITH EXECMP, BUT IT'S UNDEFINED
UPACP:		0		B KEY, C KEY, AC POINTER		LOCATION OF USER 00-17 ?
LATER ON (CLKB1H) CODE THAT DEALS WITH FAULTS LOOKS AT UPQUAN(U) TO
FIGURE OUT WHAT HAPPENED

 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+---------------------------------------------------------------------+-+
|                                                                     |A|
|                                                                     |R|
|                                                                     |E|
+---------------------------------------------------------------------+-+

ARE		AC Remap Enable
		0	AC Remap Disabled (Reset Value)
		1	AC Remap Enabled

 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
+---------------------------+-----------------------------------+-------+
|                           |                 A                 |       |
|                           |                 R                 |       |
|                           |                 B                 |       |
+---------------------------+-----------------------------------+-------+

ARB		AC Remap Base
		Address of 16-word block in physical memory
		
The AC remap function, if enabled, provides a special mapping
for virtual addresses 00-17 in both the exec and user virtual address spaces.
If AC remap is enabled (ARE=1), any virtual address in the range
00-17 is mapped into a physical address by combining the base address
in ARB with the low 4 bits of the virtual address. This check happens before
the check if paging is enabled; if ARE=1 and PE=0 then two chunks
of memory can be accessed; a 16-word chunk anywhere in the physical address
space, and locations 20-777777.

The remap function is done on all virtual addresses in the range
00-17 that make it to PAG. The only way for a program to generate these
addresses is to execute an instruction with a memory address in
this range under an XCTR relocation; if the address is used in an ordinary
way, or is used under an XCTR in a way that does not require
relocation, then the address will be an AC reference, and will not
be delivered to PAG. Addresses generated by ITS will, in
all likelyhood, be user mode addresses, generated by XCTR when the
previous mode flag is set to 1.

KA XCTR SKIPS ON VIOLATION, JUST LIKE XCTRI, AND THE UPOPC IS USED TO BACK
UP THE PC (DOESN'T DO THE RIGHT THING IF INTERRUPT IS INHIBITED)

PGLDU HAS A MODE WHICH SAYS WHICH CAN SWITCH BETWEEN AC0S AND UUOACS
IT LOOKS AT %UMSOA AND DECIDES IF RH OF UPACP SHOULD HOLD AC0S(X) OR UUOACS(X)
IF %UMSOA IS 0 WE GET UUOACS(X)
SO WHEN THE CONTEXT SWITCH WRITES SOMETHING INTO THE SHADOW, IT'S ACTUALLY CONTROLLED
BY THIS FIELD (IT'S NOT WRITING INTO LOCATIONS 00-17 OF USER MODE MEMORY)
UMAPS(X) IS NORMALLY 0, SO WHEN PGLDU IS CALLED, IT POINTS UPACP AT UUOACS(X)

IS UPACP A PHYSICAL ADDRESS OR AN EXEC MODE VIRTUAL ADDRESS ?
STACY REMEMBERS IT AS A PHYSICAL ADDRESS

CLKBRK:		0
			XCT CLUSAV			MOVEM U,AC17S(U), MADE ABSOLUTE
			MOVE U,CLKBRK
			MOVEM U,CLKBRS
			SPM UPGML(U)
			MOVEM T,AC16S(U)
			BLT REST OF AC'S INTO AC0S-AC17S
			MOVE U,USER
			MOVE P,CPDLP
			...
SCHED:		MOVE T,CLKBRK		CLKBRK HOLDS FL,,PC WHILE IN CLK PI
			MOVEM T,UPC(U)		SAVE IN USER BLOCK
			COPY UEXIT- INTO UUO(U)..SUEXND-1(U)	SAVE UEXIT AREA
; EFFECTIVELY, THIS COPY IS
			MOVE T,XUUOH
			MOVEM T,SUUOH(U)
; END EFFECTIVELY
	IF SWITCH, SAVE OLD
			MOVE T,40			SAVE THE UUO CODE
			MOVEM T,SV40(U)
	IF SWITCH, LOAD NEW
			MOVE T,SV40(U)
			MOVEM T,40			RESTORE THE UUO CODE
			MOVE T,UPC(U)		JOBS FL,,PC TO CLKBRK FOR RETURN
			MOEM T,CLKBRK
			MOVSI T,UUO(U)		RESTORE UEXIT AREA
			HRRI T,UEXIT
			BLT T,UEXND-1
; EFFECTIVELY
; THE SWAP OF JRST 2,@XUUOH IS A WASTE ON KA (ON KL/KS IT NEED TO POINT INTO UPT)
			MOVEI T,AC17S(U)
			HRRM T,CLUSAV		MAKE THE MOVEM U,AC17S(U) ABSOLUTE
			MOVE T,SUUOH(U)
			MOVEM T,XUUOH
; END EFFECTIVELY
			RELOAD AC FROM AC0S(U)-AC17S(U)
			JRST 12,@CLKBRK
