Copyright (c) 1999 Massachusetts Institute of Technology
See the COPYING file at the top-level directory of this project.
------------------------------

ITS CALLS:

This file attempts to maintain up-to-date documentation on all
symbolic ("new") system calls.  Those wonderful souls who update the
information in any way (additions, deletions, corrections) should
describe their modifications in a brief note to INFO-ITS@AI so that
interested parties can correct their copies or conceptions without
needing to print or read the entire file again.  For example:

	:MAIL INFO-ITS@AI I added more details to the "FOO" call ^C

If you want to be put on the INFO-ITS mailing list,
just say so in a message to it.
-------------------------------------------------

The format for executing a new system call is:

CALL:	.CALL CALBLK		;the call itself
	;error return is to CALL+1
	;successful return is to CALL+2


	...

CALBLK:	SETZ		;always
	SIXBIT /NAME/	;where "NAME" is any implemented call
	parm1		;parameters start here
	parm2

	...

	SETZ parmn	;bit 4.9 (SETZ) => last argument

A list of all implemented system calls may be seen in
AI:SYSTEM;ITS > starting at SYSCTB:.  The actual addresses
within ITS where each call is executed may be found from the
table starting at SYSCTD:.

There are four types of parameters:
	(input)		argument
	(output)	value
	(error)		error return code
	(input)		control

Bits 4.1-4.3 of the parameter word form an "op code"
for that parameter:

    Op Code	Meaning			Symbol   Value

	0	argument		%CLIN	 0000
	1	immediate argument	%CLIMM	 1000
	2	value			%CLOUT	 2000
	3	error return code	%CLERR	 3000
	4	control			%CLBTW	 4000
	5	immediate control	%CLBIT	 5000


The indirect, index, and address fields are used to calculate
an effective address, PDP-10 style. These point to the location
where the argument is or the output is to be placed. For
immediate parameters the address itself is the argument or
control bits. (Some calls update their input arguments. Such
arguments may not be immediate.)

The order of the input arguments matters; so does the order of
the output values. Other than that, the order is irrelevant.
(As a matter of style, one normally writes them in the order
"control, arguments, values, errors" for clarity.  In the descriptions
given here the parameters will always be described in that order.)

If too many input arguments are present, the excess are ignored,
except that more than 9 arguments will cause error 15. If too
few arguments are present, error 30 occurs. If too many output
values are specified, the extra values will be garbage. If too
few output values are specified, only those specified will
receive information, and any extra output is thrown away.
Specifying more than one error return parameter causes error 15.
Specifying an illegal sixbit name for the call causes error 43.

If an error return parameter is specified, then if the call
takes the non-skip return an error code will (probably) have
been stored into the error return parameter.  It is also
stored into the I/O Status Word of some channel, as before.
If the call fails but no error code is returned, the error
return parameter is zeroed.  Note that the error return parameter
is also zeroed if the call succeeds.  Also, since this zeroing
takes place when the arguments are first processed, the error
return parameter should not be located on top of any input
arguments.  Only one error return parameter is permitted.

The values of all control bit parameters given are XOR'ed 
together, and the result may or may not be used by the system
call. Only the right half of a non-immediate control bit
parameter is significant. Some system calls XOR the left
half of their first argument with the control bits as well.

FAILURE CODES:	Returned by New System CALLs (and .OPEN's, etc.)

The failure code from a new system call that doesn't skip can be
obtained by reading the .USET variable .BCHN to find the number of
the channel on which the code was returned, and then reading
that channel's .IOS variable (using the .STATUS uuo or
the STATUS symbolic call) to get a word with the error code
in bits 3.6-3.1.

Alternatively an error return code argument may be specified and the error
code will be stored right-justified (not in bits 3.6-3.1, but bits 1.6-1.1).
To get the corresponding message from the ERR device, use a first file
name of 4 (number, not sixbit) and use the error code as the second file name.

The error codes which may be returned by each individual call are described
in the documentation for that call.  Note that if the call is interpreted
by a job device, any error code may be returned, not just those documented;
job devices should, however, adhere as closely as possible to normal
error code conventions.  Errors codes 15, 30, 43, and 44 may be returned by
any symbolic system call, and so are not included under the individual
descriptions.

The ERR device can be used to get a corresponding message as indicated in
the table on the following page.  See the OPEN system call for information
on the ERR device.

The error codes have symbolic names, which are pre-defined in DDT and
MIDAS.  The first two characters in the name are "%E".  The remaining
letters usually follow the following conventions.  3rd and 4th letters:
"TM" = "too many", "BD" = "bad or illegal", "TF" = "too few", "RO" =
"read-only", "NA" = "not available", "NS" = "no such", "EX" = "already
exists", "FL" = "full", "NR" = "not ready".  5th and 6th letters: "JB" =
"job", "RG" = "arg", "DV" = "device", "DR" = "directory", "IO" =
"direction", "FL" = "file", "FN" = "file name".

ERROR CODES:

Number	Symbolic	Message
------	--------	-------
1	%ENSDV		NO SUCH DEVICE
2	%ENSIO		WRONG DIRECTION
3	%ETMTR		TOO MANY TRANSLATIONS
4	%ENSFL		FILE NOT FOUND
5	%EFLDR		DIRECTORY FULL
6	%EFLDV		DEVICE FULL
7	%ENRDV		DEVICE NOT READY
10	%ENADV		DEVICE NOT AVAILABLE
11	%EBDFN		ILLEGAL FILE NAME
12	%ENSMD		MODE NOT AVAILABLE
13	%EEXFL		FILE ALREADY EXISTS
14	%EBDCH		BAD CHANNEL NUMBER
15	%ETMRG		TOO MANY ARGUMENTS
16	%ENAPK		PACK NOT MOUNTED
17	%ENADR		DIRECTORY NOT AVAIL
20	%ENSDR		NON-EXISTENT DIRECTORY
21	%ELCDV		LOCAL DEVICE ONLY
22	%ESCO		SELF-CONTRADICTORY OPEN
23	%ENAFL		FILE LOCKED
24	%ETMDR		M.F.D. FULL
25	%EMCHN		DEVICE NOT ASSIGNABLE TO THIS PROCESSOR
26	%ERODV		DEVICE WRITE-LOCKED
27	%ETMLK		LINK DEPTH EXCEEDED
30	%ETFRG		TOO FEW ARGUMENTS
31	%EROJB		CAN'T MODIFY JOB
32	%EROPG		CAN'T GET THAT ACCESS TO PAGE
33	%EBDRG		MEANINGLESS ARGS
34	%EBDDV		WRONG TYPE DEVICE
35	%ENSJB		NO SUCH JOB
36	%EBOJ		VALID CLEAR OR STORED SET
37	%ENACR		NO CORE AVAILABLE
40	%ETOP		NOT TOP LEVEL
41	%ENAPP		OTHER END OF PIPELINE GONE OR NOT OPEN
42	%ENAJB		JOB GONE OR GOING AWAY
43	%ENSCL		ILLEGAL SYSTEM CALL NAME
44	%ENSCH		CHANNEL NOT OPEN
45	%ENRBF		INPUT BUFFER EMPTY OR OUTPUT BUFFER FULL
46	%EBDFL		UNRECOGNIZABLE FILE
47	%EBDLK		LINK TO NON-EXISTENT FILE

ARGS:	Special Common Types of Arguments

<TTY>	TTY channel #
	STY channel #  (accesses TTY which is STY's alter ego)
	400000 + TTY #  (may be used to examine TTY variables,
		but not to alter them or to transact input/output)

<JOB>	channel # for USR device
	channel # for JOB device (means job on other end,
		unless argument may also be a <JOBDEV>, in which
		case the job device will interpret things)
	channel # for BOJ device (means calling job)
	channel # for STY device (means job possessing
		the corresponding TTY)
	400000 + job # (user index)
	-1 or 777777 specifies self.
	400377 specifies superior.
	400376 specifies the pdp6.

	The symbols %JSELF (777777), %JSNUM (400000), %JSSIX (400376),
	and %JSSUP (400377) are pre-defined in MIDAS and DDT.
	Various other symbols beginning with %JS are defined
	for special codes that can be used instead of a
	<JOB> spec with certain calls; they are documented
	under those calls.

<JOBDEV>	channel # for JOB device

	Many symbolic system calls which take a channel number
	as the first argument may be passed to JOB devices
	for interpretation by that device.  A few act on the device
	itself, and are not passed for interpretation.  Those
	passed for interpretation include:
		ACCESS		CNSGET		CNSSET
		DIRSIZ		DSKUPD		FILBLK
		FILLEN		FINISH		FORCE
		JOBCAL		JOBGET		JOBINT
		JOBIOC		JOBRET		JOBSTS
		LISTEN		NETAC		NETBLK
		NETINT		RAUTH		RHCST
		RCPOS		RDMPBT		RENMWO
		RESET		RESRDT		RFDATE
		RFPNTR		RSSIZE		SAUTH
		SCML		SCPOS		SDMPBT
		SETIOC		SFDATE		SRDATE
		SREAPB		STLGET		STYGET
		TTYGET		TTYSET		TTYVAR
		TVWHER		WHOLIN		WHYINT

	The JOB device may of course interpret such calls in
	any way desired, and return any results desired.
	It is of course advisable to adhere as closely to
	the standard actions of each call as possible.

	Most of the above calls simply pass the symbolic
	call name and arguments along to the JOB device.  The
	following have special interfaces for historical reasons:

		ACCESS		RCHST		RENMWO
		RESET

	The following calls can open up a JOB device if their
	sixbit device name argument is not the name of a
	device that is built into the system:

		DELETE		MLINK		OPEN
		RENAME

	Those calls which are definitely NOT passed for
	interpretation include:
		CLOSE
		IOT
		SIOT
		STATUS
		RFNAME
		IOPUSH
		IOPOP
	These calls interact with the JOB device in another way.

A number of these calls include special bits and fields in their
arguments or return values.  Several files exist which contain
symbolic definitions of these bits and fields.  These files
can be inserted into a MIDAS program with .INSRT.  In addition,
most of the symbols are predefined in MIDAS and DDT through
a symbol table in the system.  The symbols defined are the same
as used in this documentation.

The following files exist on the SYSENG directory.

	FSDEFS >	Bits in fields used by the file system,
			including the format of directories.
	ITS BITS	Miscellaneous bits and codes.

The following errors are standard for all calls that take <JOB>
arguments, and are generally not documented under the individual
calls:

 14	BAD CHANNEL NUMBER
	The argument was not a special negative code, not
	400000+a user number, and not a valid channel number.
 33	MEANINGLESS ARGS
	A random number that could not be decoded was given
	as a <JOB> argument.
 34	WRONG TYPE DEVICE
	A channel number was specified that did not have open an
	appropriate type of device (generally USR, STY, or BOJ).
 35	NO SUCH JOB
	400000+user number was specified, but the user number
	did not correspond to a currently-existing job, or
	400377 was given, specifying the superior, but the job
	was top-level.
 41	OTHER END OF PIPELINE GONE OR NOT OPEN
	A STY channel number was specified, but the corresponding
	TTY was free and had no associated job.
 42	JOB GONE OR GOING AWAY
	The specified job exists but is in process of being killed.

The following errors are standard for all calls that take <TTY> arguments: 

  1	NO SUCH DEVICE
	400000+tty number was specified, but there is no tty with the
	indicated number.
 14	BAD CHANNEL NUMBER
	The argument was not 400000+tty number and was not a valid
	channel number.
 34	WRONG TYPE DEVICE
	A channel number argument does not refer to a channel open
	to a STY or a TTY.
 44	CHANNEL NOT OPEN
	The specified channel is not open.

ACCESS:	set file access pointer

	arg 1	Channel number.
	arg 2	New access pointer.  This pointer is
		the number of bytes from the beginning
		of the file of the next byte to be
		processed.  Note that in block mode,
		even ASCII block mode, a byte is always
		a full word.

	This is useful primarily for DSK and disk-like job devices;
	that is, any device which has "files."
	
	See also the .ACCESS uuo.

Errors:

 14	BAD CHANNEL NUMBER

 If the ACCESS pointer is set to more than the number of words in
 in the file, an IOC error 2 will occur on the next IOT operation
 on that channel.

ATTACH:	attach a job-tree to a console				(ITS DETACH)

	cbits	2.9	If there are 2 args, causes the jname
			of the job being attached to be changed
			to HACTRN, unless there is already a HACTRN.
		1.3	"P" the job by clearing bit 4.4 of .USTP
	arg 1	<JOB> to be attached to the console.
	arg 2	Optional: <TTY> to attach it to.  Must be free.
		If not present, the executing job must be
		top-level and console-controlled; it is logged
		out, and its console used as the tty to attach to.

	Attaching a job tree to a tty causes the job tree to be
	console-controlled with the specified tty as its console.
	The specified job must be either the top-level job of
	a disowned job tree, or a direct inferior of the job executing
	the ATTACH; in the latter case the specified job is disowned
	first.  The tty to be attached to must be free.  In the
	one-argument case the job executing the ATTACH must be the
	top-level job of a console-controlled job tree; it is logged
	out to make the console free.  The one-argument case furthermore
	causes the attached job to take on the jname of the job
	executing the ATTACH.  In the 2-argument case, control bit
	400000 causes the attached job to take on the jname HACTRN,
	unless that would cause it to have the same names as an
	existing job.

	The one-argument case is made available in DDT via the
	command :ATTACH, which attaches the current job to the console.
	Also, when a user logs in (say as FOO), DDT checks for the
	existence of a job called FOO HACTRO; if it exists, DDT asks:
		--ATTACH YOUR DETACHED JOB--
	If at this point the user types a space, DDT executes the
	commands "HACTROJ :ATTACH ", thereby attaching the HACTRO to
	the console, and changing the HACTRO's name to HACTRN.
	This affords a convenient method of recovery from automatic
	detachment.

	See the DETACH symbolic system call.

Errors:

 10	DEVICE NOT AVAILABLE
	This job's tree is not console-controlled (one argument);
	the specified tty is not free or does not exist (two arguments).
 14	BAD CHANNEL NUMBER
	The first argument is not a valid channel number.
 31	CAN'T MODIFY JOB
	The specified job is not disowned or a direct inferior.
 34	WRONG TYPE DEVICE
	First argument must be a job.
 35	NO SUCH JOB
	First argument specified a non-existent job.
 40	NOT TOP LEVEL
	The executing job must be a top-level job (one argument).

ATTY:	pass tty to inferior

	arg 1	<JOB>

	The tree's console tty is passed to the <JOB>, which must
	be a direct inferior.  This is the same as the .ATTY uuo.

Errors:

31	CAN'T MODIFY JOB
	The specified job is not a direct inferior.

34	WRONG TYPE DEVICE
	The specified job is the pdp-6.

42	JOB GONE OR GOING AWAY
	The specified job is dying.

CALL:	perform system call

	arg 1	Name of symbolic system call to perform.

	The other arguments serve as the arguments to the
	specified symbolic call.  The values and errors returned by
	that call become the values and errors of this call.
	This is useful if the name of a symbolic call is to be
	determined dynamically.  Lisp hackers should think of this
	as the "Funcall" system call.

CHAOSO:	open Chaosnet connection		<MOON;CHAORD>

	arg 1 - receive channel number
	arg 2 - transmit channel number
	arg 3 - receive window size

	First, the two specified channels are closed.  Then an index
	is assigned to the user and the two channels are set up to
	point to it.  Two channels are used since in general ITS
	channels are unidirectional, and to allow to the user to
	handle receive and transmit interrupts differently.

	The created index is placed in the Closed state.  To set up
	a connection, IOT an RFC or LSN packet down the transmit
	channel.

CHAOSQ:	Chaosnet Queue					<MOON;CHAORD>

	arg 1 - address of a 126.-word block (packet buffer)

	This is a special system call for use by the ATSIGN CHAOS
	program, which is a daemon program that gets run when
	an RFC is received that does not match up against an
	existing LSN.  

	The first packet on the pending-RFC queue is copied
	into the packet buffer, then moved to the end of the
	queue (so that the right thing happens when several
	RFC's are pending at the same time.)

	The call fails if the pending-RFC queue is empty.

	The program should use the contact name in this
	packet to choose a server program to execute.  This
	server program will then LSN to (presumably) the same
	contact name, thus picking up the RFC.

CLOSE:	close input/output channel

	arg 1	Channel number to close.

	The specified input/output channel is closed.

	For TCP connections:
	A CLOSE on the output channel will cause an automatic FORCE,
	and a FIN segment will be sent to the remote host indicating
	"no more data to send".  However, the input channel will
	remain open, and data can continue to be read from it.
	A CLOSE on the input channel will cause any further input received
	to be thrown away by ITS.  Output can continue to be sent.
	Return from this call is immediate; it will not hang.  Note that,
	like NCP, this does not allow the user to determine
	whether the last stuff successfully reached the destination or
	not.  When this is desirable, a FINISH should be done prior to
	the CLOSE.

For the Chaosnet:
	Immediately closes the connection.  All buffers and other
	information associated with the index are discarded.  Normally
	the user should first IOT a CLS
	packet containing an ascii explanation for why it is
	closing.  Note that any data previously written on the
	connection but not yet received by the other end will be
	lost.  The system will attempt to send a CLS with reason
	"channel closed", but this will only be sent if buffer space
	is available.

	See also the .CLOSE uuo.

CNSGET:	get various console parameters				(ITS TTY)

	arg 1	<TTY> or <JOBDEV>
	val 1	Vertical screen size.
	val 2	Horizontal screen size.
	val 3	TCTYP variable.
		0	%TNPRT	Printing terminal.
		1	%TNDP	Good Datapoint.
		2	%TNODP	Bad Datapoint ("loser").
		3	%TNIML	Imlac.
		4	%TNTEK	Tektronix.
		5	%TNTV	PDP-11 TV.
		6	%TNMEM	Memowreck.
		7	%TNSFW	Software terminal (accepts internal
				ITS display codes, such as live in
				internal terminal output buffers;
				see ITS TTY for details).
		10	%TNTRM	Terminet.
		11	%TNESC	Display using ASCII standard display codes.
		12	%TNDTM	Datamedia.
		13	%TNRAY	Teleray 1061
		14	%TNHDS	Concept 100
		15	%TNH19	H19
		16	%TNAAA	Ann Arbor Ambassador
	val 4	TTYCOM variable.
		4.9		Communicate mode.
		4.8	%TCLFT	Local feed through (my job sees his typing).
		4.7	%TCRFT	Remote feed through (his job sees my typing).
		4.6	%TCICO	Input comm override (my job sees my typing).
		4.5	%TCOCO	Output comm override (I see my job's typing).
		4.4	%TCRFS	Refuse comm messages.
		4.3	%TCQRY	Query me if comm attempted to me.
		4.2	%TCMTR	The tty's motor is off, and must be
				turned on before next output.
				(Currently only Terminets get turned off.)
		4.1	%TCECH	The last output to this tty was PI echo.
		3.9	%TCINP	Someone waited for input since last home-up.
		3.8	%TCDET	Console's tree detached by top level interrupt.
		3.7	%TCDNG	Type bell (input buffer full).
		3.6	%TCCBK	Reading uname or tty number after ^_K.
		3.5	%TCCBS	Reading uname or tty number after ^_S.
		3.4	%TCFPD	First part of an output code sequence is done.
		3.3	%TCTPN	Type ^_N on leaving comm (unless user types it).
		3.2	%TCPAD	0 => padding necessary on datapoint.
		3.1	%TCHNG	Done flag seems to be fried - time out quickly.
		2.9-1.1	-1 if not in comm mode; otherwise number of
			next tty in circular list of those in comm mode
			together.
	val 5	TTYOPT variable.
		4.8	%TOALT	Standardize altmodes.
		4.7	%TOCLC	Convert lower case input to upper case.
		4.6	%TOERS	This tty can selectively erase.
		4.5	%TOHDX	This tty is half-duplex.
		4.4	%TOMVB	This tty can backspace directly.
		4.3	%TOSAI	This tty handles SAIL characters.
		4.2	%TOSA1	Used to initialize %TSSAI for new jobs.
		4.1	%TOOVR	This tty can overprint correctly.
		3.9	%TOMVU	This tty can move its cursor upward.
		3.8	%TOMOR	Used to initialize %TSMOR for new jobs.
		3.7	%TOROL	Used to initialize %TSROL for new jobs.
		3.6	%TORAW	Don't optimize cursor motion.
		3.5	%TOLWR	This tty has a lower case keyboard.
		3.4	%TOFCI	This tty's keyboard has the full TV character set.
		3.3	%TOIML	This tty acts like an IMLAC.
		2.9-2.7	$TPPLF	How to pad line feeds:
				0	Don't.
				1	Two pad chars (Memorex, 2741).
				2	Terminet.
		2.6-2.4	$TPPCR	How to pad carriage returns:
				0	Don't.		4	Execuport.
				1	Normal.		5	2741.
				2	Double.		6	Memorex.
				3	Unused.		7	Unused.
				For a Datapoint, number of pad chars before
				each string of cursor motion commands.
				For a Terminet, 0=no padding, 1,2,3,4,5
				correspond to 10,15,30,60,120 cps.
		2.3-2.1	$TPPTB	How to pad tabs:
				0	Tabs not allowed.
				<n>	Use <n-1> pad chars.
				On displays,
				0	don't use tabs.
				1	use tabs.
				2	use VT52-style absolute positioning.
		1.6	%TPCBS	The ^\ intelligent terminal protocol is enabled.
		1.5	%TP11T	PDP-11 TV.  Reflects %TY11T.
		1.4	%TPORS	Output reset really does something.
		1.3	%TPRSC  This tty can do region scrolling
		1.2	%TPIBC	Oddball 2741-like tty.
		1.1	%TPIBM	It really is a 2741.
	val 6	TTYTYP variable.
		4.9	%TTLCL	Local tty (i.e. right near the PDP-10).
		4.8	%TT340	Near the 340 or a 340 slave.
		4.7	%TT3HP	High priority for grabbing 340.
		4.3	%TTPAR	Tty needs a parity bit generated by software.
		4.2	%TTDDI	Don't ding bell on excess input.
		4.1	%TTIBM	Datel (2741) line.
		3.8-3.5	$TTISP	Input speed code:
		0 = unknown		6 = 1800 baud		13 = 40K baud
		1 = 600 baud		7 = 2400 baud		14 = 50K baud
		2 = 110 baud	       10 = 4800 baud		15 = 80K baud
		3 = 150 baud	       11 = 9600 baud		16 unused
		4 = 300 baud	       12 = 25K baud		17 unused
		5 = 1200 baud
		3.4-3.1	$TTOSP	Output speed code, as above.
		2.9	%TYDPK	Datapoint controller line.
		2.8	%TYSTY	Alter ego to a STY.
		2.7	%TYNVA	Nova tty (requiescat in pace).
		2.6	%TYMTY	Morton controller line.
		2.5	%TYDIL	Dial-up line.
		2.4	%TY11T	PDP-11 TV tty.
		2.3	%TYDL	DL-10 tty.
		2.2	%TYOTY	KA-10 console tty.
		2.1	%TYETY	DTE-20 tty.
		1.9	%TYNTY	TK-10 tty.
		1.8	%TYMDM	Dial-up line with modem control.
		1.7	%TYKST	KS-10 console tty.
		1.6	%TYDZT	DZ-11 tty on a KS-10.
		1.5	%TYRLM	ROLM data switch tty.
	val 7	TTYSMT variable.
		4.9-4.7	%TQMCH	Machine type
		  0 = nothing special	1 = PDP11		2 = PDS4
		  3 = PDS1
		4.6-4.2	%TQHGT	Character height in dots
		4.1-3.7	%TQWID	Character width in dots
		3.6	%TQVIR	Terminal implements virtual coordinates
		3.5	%TQBNK	Terminal implements blinking
		3.4	%TQXOR	Terminal implements XOR mode
		3.3	%TQREC	Terminal implements rectangle commands
		3.2	%TQSET	Terminal implements multiple object sets
		3.1	%TQGRF	Terminal understands graphics protocol
		2.9	%TRGIN	Terminal has graphic imput
		2.8	%TRGHC	Terminal has graphic hardcopy
		2.7	%TRLED	Terminal has local editing protocol
		2.6	%TRSCN	Terminal implements raster commands
		2.5-2.3	%TRLSV	<>0 means terminal supports 4**N saved lines
		2.2-1.7	%TRTIM	signed offset from GMT minus 20 or zero if
				terminal's timezone is unknowable.

	See also the CNSSET, TTYGET, and TTYSET symbolic system calls.

CNSSET:	set various console parameters				(ITS TTY)

	arg 1	<TTY> or <JOBDEV>
	arg 2	Vertical screen size (negative => no change).
	arg 3	Horizontal screen size (negative => no change).
	arg 4	TCTYP variable (negative => no change).
		0	%TNPRT	Printing terminal.
		1	%TNDP	Good Datapoint.
		2	%TNODP	Bad Datapoint ("loser").
		3	%TNIML	Imlac.
		4	%TNTEK	Tektronix.
		5	%TNTV	PDP-11 TV.
		6	%TNMEM	Memowreck.
		7	%TNSFW	Software terminal (accepts internal
				ITS display codes, such as live in
				internal terminal output buffers;
				see ITS TTY for details).
		10	%TNTRM	Terminet.
		11	%TNESC	Display using ASCII standard display codes.
		12	%TNDTM	Datamedia.
		13	%TNRAY	Teleray 1061
		14	%TNHDS	Concept 100
		15	%TNH19	H19
		16	%TNAAA	Ann Arbor Ambassador
	arg 5	TTYCOM variable.
		4.6	%TCICO	Input comm override (my job sees my typing).
		4.5	%TCOCO	Output comm override (I see my job's typing).
		4.4	%TCRFS	Refuse comm messages.
		4.3	%TCQRY	Query me if comm attempted to me.
		4.2	%TCMTR	The tty's motor is off, and must be
				turned on before next output.
				(Currently only Terminets get turned off.)
		3.9	%TCINP	Someone waited for input since last home-up.
		The remaining bits, documented under CNSGET, may not be changed.
	arg 6	TTYOPT variable.
		4.8	%TOALT	Standardize altmodes.
		4.7	%TOCLC	Convert lower case input to upper case.
		4.6	%TOERS	This tty can selectively erase.
		4.5	%TOHDX	This tty is half-duplex.
		4.4	%TOMVB	This tty can backspace directly.
		4.3	%TOSAI	This tty handles SAIL characters.
		4.2	%TOSA1	Used to initialize %TSSAI for new jobs.
		4.1	%TOOVR	This tty can overprint correctly.
		3.9	%TOMVU	This tty can move its cursor upward.
		3.8	%TOMOR	Used to initialize %TSMOR for new jobs.
		3.7	%TOROL	Used to initialize %TSROL for new jobs.
		3.6	%TORAW	Don't optimize cursor motion.
		3.5	%TOLWR	This tty has a lower case keyboard.
		3.4	%TOFCI	This tty's keyboard has the full TV character set.
		3.3	%TOIML	This tty acts like an IMLAC.
		2.9-2.7	$TPPLF	How to pad line feeds:
				0	Don't.
				1	Two pad chars (Memorex, 2741).
				2	Terminet.
		2.6-2.4	$TPPCR	How to pad carriage returns:
				0	Don't.		4	Execuport.
				1	Normal.		5	2741.
				2	Double.		6	Memorex.
				3	Unused.		7	Unused.
				For a Datapoint, number of pad chars before
				each string of cursor motion commands.
				For a Terminet, 0=no padding, 1,2,3,4,5
				correspond to 10,15,30,60,120 cps.
		2.3-2.1	$TPPTB	How to pad tabs:
				0	Tabs not allowed.
				<n>	Use <n-1> pad chars.
				On displays,
				0	don't use tabs.
				1	use tabs.
				2	use VT52-style absolute positioning.
		1.6	%TPCBS	The ^\ intelligent terminal protocol is enabled.
		1.5	%TP11T	PDP-11 TV.  Reflects %TY11T.
		1.4	%TPORS	Output reset really does something.
		1.3	%TPRSC	This tty can do region scrolling.
		1.2	%TPIBC	Oddball 2741-like tty.
		1.1	%TPIBM	It really is a 2741.

	Omitting an argument also means no change (only works
	if all arguments after it are also omitted, of course.)
	Not all bits of the variables are settable;  those explicitly
	not user-settable have been omitted above.  If contradictory
	bits are supplied, the system will reconcile the conflicts.
	See also the CNSGET, TTYGET, and TTYSET symbolic system calls.

CORBLK:	modify blocks of core in page map			(ITS CORBLK)

	cbits	2.9	%CBWRT	Try to get write access; okay if can't.
		2.8	%CBRED	Try to get read access; okay if can't.
		2.7	%CBNDW	Try to get write access; fail if can't.
		2.6	%CBPUB	Make page public.  This operation fails if
			  an attempt to get write access would fail;
			  however, it does not actually get write
			  access unless bit 2.7 is set also.
			  Any job is allowed to get write access to
			  a public page.
		2.5	%CBPRV	Make page private.  This operation fails if
			  an attempt to get write access would fail;
			  however, it does not actually get write
			  access unless bit 2.7 is set also.
			  A job can have write access to a private page
			  only if it is getting the page from itself or
			  a job it is allowed to write in, and that job
			  has write access itself.  Pages are usually private.
		2.4	%CBNDR	Fail if can't get read access
			  (attempting to share with a non-existent page).
		2.3	%CBCPY	Make a copy (disk files only).
		2.2	%CBLOK	Lock page in core (don't allow swap out.)
		2.1	%CBULK	Unlock page from core.
		1.9	%CBSLO	Force page to reside in slowest memory.
				This is useful when trying to get
				reproduceable run time measurements.
		1.8	%CBUSL	Undo the effect of %CBSLO			
		Bits 2.2-1.8 are not yet implemented.
		All zero means delete page from page map.
	arg 1	RH and LH are XOR'd with control bits.
	arg 2   <JOB> to put page into (or delete it from).
	arg 3	Page number within job specified by arg 2.
		If LH negative, block mode operation:
		After doing operation, increment arg 5 if any,
		AOBJN arg 3, write args back into user core,
		and repeat the operation, until LH of arg 3
		becomes positive.
	arg 4	Any one of the following:
			<JOB> to get page from.
			Disk channel number.
				When disk file pages are inserted,
				the access pointer is left pointing
				after the last word of the last page
				inserted.
				If the pages so inserted are inserted
				with write access for modification,
				the DSKUPD symbolic system call may
				be used to set the creation and
				reference dates for the file.
			PDP-6 channel number.
			One of the following special negative codes.
			Only the right-half matters.
			-2 %JSTVB means video buffer pages.
				Pages 0-7 are video buffer.
				First word of page 10 contains
				console register and ALU.
				See the .TVCREG user variable,
				and the VIDBUF and VIDSW symbolic
				system calls.
			-5 %JSNEW get a fresh page.  A new page, not
				shared with any other, will be created.
				The system tries to zero it out, but
				currently may fail to if there is already
				a page at the destination address.  If
				wasn't very difficult to fix, I'd fix it
				instead of documenting it.
			-6 %JSABS an absolute page.  Arg 5 specifies the
				desired page of physical memory.  You are
				not permitted write access to such a page.
			400000 specifies the system job (job # 0).  Sharing
				a page with the system job is almost like
				getting an absolute page via %JSABS, since
				the system job's address space mostly
				corresponds to physical memory.
			400001 specifies the core job.  For historical
				reasons, this is taken to mean get a fresh
				page instead.  This special case will go
				away some day, so use %JSNEW instead.
		If arg 4 is omitted, it is the same as arg 2.
	arg 5	Page number within source specified by arg 4.
		Arg 5 is ignored for fresh page.
		If omitted, same as arg 3 if source is a job.
		If source is a disk file, the current access
		pointer rounded down to a page boundary
		is the default.

Errors:

 10	DEVICE NOT AVAILABLE
	PDP-11 TV not available for mapping.
 14	BAD CHANNEL NUMBER
	Argument 2 or 4 is invalid.
 31	CAN'T MODIFY JOB
	Executing job doesn't have modification rights to the job
	specified by argument 2.
 32	CAN'T GET THAT ACCESS TO PAGE
	Can't satisfy access requested by cbits 2.7-2.4.
	This usually means that the page does not exist in the
	source specified in argument 4, or that it exists but
	write access is not permissible.  It may also mean that
	an absolute page which normally exists is currently down.
 33	MEANINGLESS ARGS
	Page number outside range 0-377 for another job's page,
	or outside 0-10 for a video buffer page,
	or outside 0-17 for a PDP-6 page.
	The allowed range for absolute pages depends on the machine.
 34	WRONG TYPE DEVICE
	Can't map pages from any device other than those listed above.
 35	NO SUCH JOB
	Argument 2 or 4 specified a non-existent job.
 37	NO CORE AVAILABLE
	Tried to get fresh page, but no more (virtual) core is available.
	The total number of distinct pages in the system is limited
	by the size of the MMP table.

CORTYP:	determine type info from page map			(ITS CORBLK)

If one argument:
	arg 1	Page number within current job.
If two arguments:
	arg 1	<JOB>
	arg 2	Page number within specified job.
	val 1	4.9	%CBWRT	  Page is writable.
		4.8	%CBRED	  Page is readable (exists).
		4.6	%CBPUB	  Page is public (writable by anyone)
		4.2	%CBLOK	  page is locked in core
				  (inhibited from swapout)
		3.9	%CBSLO	  Page is in slow memory
				  (Doesn't work; Moon says it never will)
		For non-existent page, whole word is zero.
		Thus, this value is:
			zero => no page.
			positive => read-only page,
			negative => writable page.
	val 2	0	Absolute page.
		-1	Unshared page.
		other	User index of next job in circular
			list of jobs sharing the page.
	val 3	For val 2 = 0, absolute page number.
		For val 2 = -1, zero.
		Otherwise, page number within job specified
		by val 2.
	val 4	4.9	Page is in core.
		2.9-1.1	Number of times page is shared (zero
			for absolute or non-existent page,
			else >=1 ).

Errors:

 14	BAD CHANNEL NUMBER
 33	MEANINGLESS ARGS
	Page number was outside range 0-377.
 34	WRONG TYPE DEVICE
	Channel not open on USR, BOJ, JOB, or STY device.
 35	NO SUCH JOB

DELETE:	delete a file

  Either
	arg 1	Byte pointer to ASCIZ filename string,
		or aobjn pointer to block of such byte pointers.

  or
	arg 1	Left-justified device name, in SIXBIT.
	arg 2	File name 1 in SIXBIT.
	arg 3	File name 2 in SIXBIT.
	arg 4	Sname in SIXBIT.

	The file specified either by the four SIXBIT names or by the
	ASCIZ string(s) is deleted.

	See the SOPEN symbolic system call for how the byte or AOBJN
	pointer argument should be formatted and how the string(s) are
	parsed.

DELEWO: Delete file While Open.

	arg 1	Channel number.

	The file open on the channel is marked for deletion.
	It is actually deleted as soon as all channels referencing
	it (including the one used by the DELEWO) are closed.
	In the meantime, it is inaccessible (starred in the directory).
	Either an input channel or an output channel can be used.

Errors:

 34	WRONG TYPE DEVICE
	This call works only on DSK, and such job devices as simulate DSK.

DEMSIG:	demon signal

	arg 1	Sixbit name of demon to signal.
	arg 2	Optional:
		zero => signal once only.
		positive => signal repeatedly every 2*n minutes.
		negative => load demon but do not signal.

	A demon is a program which runs (and perhaps even exists)
	only when a request has been signaled for it.  If the
	demon with the specified demon is not currently running,
	the system job creates a demon job and loads it from the
	file SYS:ATSIGN <name>, where <name> is the name of the
	demon.
	When the demon runs, it can acknowledge receipt of one
	or more signals by using the .DEMON uuo (q.v.).
	The status of a demon can be examined and altered by
	using the RDDMST and STDMST symbolic system calls.
	When the system is started up, there is a once-only
	signal for the DEMSTR demon pending; this demon normally
	signals requests for all other standard systemic demons.

	Demons were much used on the DM machine for various purposes.
	Standard demons which are started by the DEMSTR demon include
	(as of July 23, 1975):
	NAME	REPT RATE	PURPOSE
	TCTYP	0		Set terminal types?? (Doesn't exist on SYS)
	UNSPOO	0		Line printer unspooler (TPL).
	SURVEY	10.		Network survey generator.
	LDRDEM	0		Loader demon (obsolete).
	BATCHM	0		Old batch monitor (obsolete).
	COMSYS	0		Old message demon (obsolete).
	NETRJS	0		CCN remote job server demon.
	ZONE	0		MUDDLE compile batcher.
	MG	0		Maze Guncher - kills games of MAZE
				in an obscure way.  AV doesn't like them.
	COMDMN	0		Communications demon (replaces COMSYS).
	BATCHN	0		Batch monitor (replaces BATCHM).
	RFC402	0		Message archival demon.

DETACH:	detach a job tree from a console			(ITS DETACH)

	arg 1	<JOB> for any job in the tree to be detached.
		If omitted, the tree referred to is that
		of the executing job.
	cbits	1.1	Leave the detached tree as a non-disowned,
			non-console-controlled tree, instead of as
			a disowned tree.
		1.2	Use system tree's resource word instead
			of disowned resource word.  This is to
			be used only by legitimate system daemons.
		1.3	"P" the job by clearing bit 4.4 of .USTP
		1.4	if an hour goes by and the detached tree
			does not run and is not reowned or attached,
			it will be killed automatically by the system.
		1.5	suppress the console-free message that would
			otherwise be printed on the tree's console.
	The entire job tree which the specified job belongs
	to is made to be disowned.  If it was controlled by
	a console, that console is made free.  If the tree is
	already disowned, nothing happens, but the DETACH call
	skips anyway.  If the top level job of the tree has a
	jname of HACTRN, the jname is incremented to be HACTRO
	and then re-incremented as necessary to make its uname-
	jname pair unique.

	DDT provides a command :DETACH which detaches the tree
	the DDT itself is in.  LOCK provides a DETACH command
	for detaching other trees conveniently:
	<n>DETACH		detaches the tree containing the
				job with user index <n>.
	DETACH<uname> <jname> 	detaches the tree containing
				the job named <uname> <jname>.

	Automatic detachment by the system job:
	Fatal interrupts in top-level jobs will cause them to be stopped
	and then detached by the system job, which will type the message
		TOP LEVEL INTERRUPT, TREE DETACHED
	on the console detached from, followed by the normal
	console-free message.  A message is also printed on the system
	console saying which job was detached from which terminal.

	If the PDP-11 controlling the TV consoles crashes, the system
	job automatically detaches all job trees controlled by TV
	consoles.  This allows the user to log back in and re-attach
	his job tree when the PDP-11 is restarted.
	If the ARPA network crashes (that is, the local network
	attachment crashes, or the host which is connected to
	the console of a particular console-controlled tree 
	crashes) the server telnets automatically detach those
	job trees whose consoles are no longer connected to anything.
	On some ITS machines if a dial-up line is disconnected
	the job tree controlled by that line will be automatically
	detached.  Other ITS machines do not have the hardware to
	to detect disconnection.
	When a tree is detached because its tty, whether TV, network
	connection, or dialup line, has disconnected, then if the
	tree is not logged in it will be killed immediately.

	Whenever a tree is detached automatically for any of the
	reasons mentioned above, control bit 1.4 is used, so the
	tree will go away if it is not touched for an hour.

	See the ATTACH and DISOWN symbolic system calls.

Errors:

 14	BAD CHANNEL NUMBER
 31	CAN'T MODIFY JOB
	Cannot detach the SYS or CORE jobs, or the PDP-6.
 34	WRONG TYPE DEVICE
 35	NO SUCH JOB

DL10MP:	Hack the DL10 (pdp11 interface)

	THIS SYSTEM CALL CAN CRASH THE SYSTEM IF MISUSED.  IT SHOULD
	NOT BE USED LIGHTLY.

	arg 1	Page number
	val 1	AOBJN pointer to DL10 control area
	val 2	Pointer to 3 words for pdp11 examine/deposit commands
	val 3	Pointer to first free word in DL10 control area

	A read/write, unencached, absolute page is created at the
	specified page number in the user's address space.  The page
	contains the DL10 control area, which can be used to examine,
	deposit, or bootload the pdp11.  A message is printed on the
	system console when this call is used.

Errors:

13	FILE ALREADY EXISTS
	The page slot specified is already in use.

33	MEANINGLESS ARGS
	The page number is invalid.

DIRSIZ:	read the total size of files in a directory.

	arg 1	The number of a channel open on the DSK device,
		or a <JOBDEV>.  The channel should be open to a file
		in the directory to be hacked.

	arg 2	(optional) quota

	arg 3	(optional) dsk number,,allocation

	val 1	quota,,total number of disk blocks used by files
		this directory

	val 2	dsk number,,allocation (normally 0).

DISMIS:	dismiss an interrupt					(ITS INTRUP)

	arg 1	Points to the third of three words which
		are the new .DF1, .DF2, and .UPC
		variables for use in dismissing the interrupt
		(but see the cbits for this call).
		If not an immediate argument, it is assumed to
		be a pdl pointer which is appropriately
		popped three times to get these items.
		It is then popped twice more to flush the
		two interrupt words pushed by a new-style
		vectored interrupt.
		If the job has enabled the pdl overflow
		interrupt (bit 2.8 of the .MASK user variable)
		then it will receive such an interrupt if the
		popping by DISMIS causes pdl underflow.
	arg 2	If present, overrides the new pc on the
		stack specified by arg 1.
	arg 3	If present, overrides the new .DF1 on
		the stack specified by arg 1.
	arg 4	If present, overrides the new .DF2 on
		the stack specified by arg 1.  Thus if four
		arguments are supplied, the first is
		effectively ignored, except for popping.
	arg 5	If present, is the <losing insn addr>,,<lossage code>
		for a LOSE that is done, uninterruptably,
		after the interrupt has been dismissed.

	cbits	The control-bits for this argument specify
		extra words to be popped off the pdl pointer
		which is the first arg, BEFORE the PC and defer
		words are popped.  The cbits are ignored if the
		first arg is immediate.  The intention is that
		the cbits will tell DISMIS how to pop exactly
		what was pushed when the interrupt happened. The
		format of the cbits is the same as that of the LH of
		the first word of the interrupt table (for new-style
		vectored interrupts) (see ITS INTRUP), which is what
		specifies what is to be pushed when an interrupt happens.
		It is:
		2.9=1 => throw away three words first thing.  Throws away
		   the debugging info that interrupts can push.
		1.1-1.5 nonzero => it is number of ACs to be popped,
		   and 1.7-2.1 is the number of the lowest AC to be popped.
		The ACs to be popped are BLT'ed out of the stack.
		
	If four arguments are supplied and the first is
	immediate, then the first is totally ignored (except
	that the address calculation is performed).
	Thus this call is good for dismissing old-style
	interrupts as well as new-style (stack oriented)
	interrupts.

	Note that if the job is using the feature that interrupts
	automatically push some accumulators or some debugging info,
	it must explicitly request (with the control bits) that the
	same words be popped.  DISMIS does NOT vary its function
	according to the job's interrupt table, for a given set of args.

	If the interrupt handler wishes to pretend that a class 2
	interrupt had not been enabled, it can dismiss the interrupt
	and supply a fifth argument which is like the first argument
	to a symbolic LOSE system call.  Making the rh of that
	argument 1+.LZ <interrupt bit> will cause DDT to print the
	error message appropriate to an unhandled interrupt on that
	bit.  The lh. of that argument should be the address of
	the instruction that caused the interrupt.

	See also the .DISMISS uuo.

DISOWN:	disown an inferior job

	cbits	1.4	Set BUMRTL, saying that if for one hour the
			job does not run and is not attached or reowned
			it should be gunned down by the system.
		1.3	Perform .USET <channel>,[.SUSTP,,[0]].
			In this way the job is not started until
			after being disowned.
		1.2	Use the system resource word instead of
			the disowned job resource word for scheduling.
		1.1	Make this job not disowned, but rather the
			top-level job of a non-disowned, non-console
			controlled job tree.  This prevents the job
			from receiving 1/4'th priority as ordinary
			disowned jobs do.
	arg 1	A directly inferior <JOB>.

	Please do not misuse the 1.1 and 1.2 control bits.  These are
	intended for generally useful "system daemons" only.

	The specified job is caused to be no longer an inferior of
	the executing job, and is made to be the top level
	job of a disowned job tree.  Because of this, the disowned
	job will continue to exist even if its erstwhile superior
	does not (if, for example, the user logs out).

	Disowning is illegal if the executing job has given control
	of its console to the job to be disowned (see .ATTY).

	All channels on which the executing job has open the job being
	disowned will be closed in the process of disowning (see the
	.CLOSE uuo).  If the disowned job has opened the
	console, then the channels are not closed, but
	are marked as "disowned tty"; certain operations
	on such a channel will succeed, and others will hang
	until the job is re-owned and a console tty given
	to the job.  Such channels appear to be open on
	tty number %TINON=77 octal.
	A disowned job is distinguished by the fact that
	bit 4.9 of its .APRC user variable is set.
	A disowned job never succeeds in executing the RELOAD symbolic
	system call, even if it is the top level job in its tree.
	When a job tree is logged out, any micro-tapes assigned
	to the uname of that job tree are de-assigned (see the
	.ASSIGN and .DESIGN uuo's), but only if the job tree is
	not disowned.
	All disowned jobs share a resource word for purposes of
	scheduling, in the same way that all jobs in a single
	non-disowned tree share a resource word.  Thus all disowned
	jobs tend collectively to use no more runtime than any
	single non-disowned job tree.
	Furthermore, individual disowned jobs are given only 1/4
	the priority to run as a non-disowned job.  This does
	not apply, however, if the disowned job in question has
	.MASTER mode, or controls the 340 display, the E&S display,
	the vidisector, the arm, the LPT (line printer), or the
	PLT (plotter).
	When operating under heavy loads, the swapper prefers to
	swap out disowned jobs rather than non-disowned jobs.

	The DETACH symbolic system call makes a non-disowned tree
	disowned.  See also the %OPDET bit of the .OPTION user
	variable.

Errors:

 31	CAN'T MODIFY JOB
	The specified job must be a direct inferior.

DSKUPD:	disk update

	arg 1	Disk channel number or <JOBDEV>

	The creation and reference dates for the disk file
	open on the channel are set to the current date and time.
	The dump check bit is cleared (! will show in the
	directory).
	This is useful for programs which modify a file by
	mapping pages of the file into their page maps with write
	access, and which want to indicate this fact by setting
	the creation and reference dates.  See the CORBLK symbolic
	system call for mapping pages of disk files.

	See also the FILBLK, RESRDT, RFDATE, and RQDATE
	symbolic system calls.

Errors:

 34	WRONG TYPE DEVICE
	The supplied channel number must be a disk or JOB device channel.

ECHOIN: echo characters and store them in a buffer, until a break character

	arg 1	TTY channel number
	arg 2	Byte pointer to buffer
	arg 3	Number of characters left in buffer
	arg 4	Address of break table
	arg 5	Address of TECO buffer block (or zero)

	The second and third arguments are counted out as characters
	are stored.  When the call returns due to a break character, the
	count will still be greater than zero.

	ECHOIN tells the system to echo characters and insert them in
	the buffer specified by the second and third arguments without
	requiring the user program to be executed.  This is more
	efficient and gets visibly faster response time.  Echoing
	stops when either the count is exhausted or a break character
	is input.  When this happens, the ECHOIN returns.  If it returns
	because of a break character, then the break character
	is available for normal input.	Non-break characters following
	the break character are not handled.

	Break characters are specified by the break table,
	a four-word block pointed to by the fourth argument.  Each of
	the four words says, for 32 characters, whether they break
	or not.  In the first word, the sign bit is for SAIL code 0,
	and bit 1.5 is for SAIL code 37.  The sign bit of the second
	word is for Space, and bit 1.5 is for ?.  And so on.
	Characters with Control or Meta set (including ASCII control
	characters on non-Meta keyboards) are always break characters.

	To prevent timing errors, ECHOIN will return immediately if
	there are characters in the input buffer already.

	For use by TECO, ECHOIN can update the block of counters which
	TECO uses to remember the extent of the buffer.  The fifth
	argument should point to this block, the "Buffer block", which
	is seven words long.  When a character is inserted, the first
	two words of the buffer block are not changed, the next four
	are incremented, and th next one is decremented.  Passing the
	buffer block to ECHOIN allows ECHOIN to insert characters
	directly into TECO's buffer as an indivisible operation.
	Note that the insertion of the characters themselves is still
	controlled by the byte pointer and count arguments.
	However, in the future this may change; when ECHOIN is made
	able to handle operations besides insertion, it will use the
	buffer block for updating the buffer (which may involve deletion)
	but will still insert all characters it processes down the byte
	pointer.  This way, TECO will have both an updated buffer and
	a list of the commands which the user typed.

FILBLK:	get contents of file parameter block

	arg 1	Disk channel number or <JOBDEV>
	val 1	First file name.
	val 2	Second file name.
	val 3	Random information:
		4.9	Dump check bit.
		4.7-3.7	Word count of last block.
		3.6	Has been deleted from an
			unmounted pack.
		3.5	Delete the file when closed.
		3.4	GC mark bit.
		3.3	Open for writing.
		3.2	The grim file reaper should not reap this file.
		3.1	This is a link, not a file.
		2.9-2.5	Pack number.
		2.4-1.1	Pointer to internal UFD descriptor.
	val 4	File creation date and time in disk format:
		4.7-4.1	Year (mod 100.).
		3.9-3.6	Month (January = 1).
		3.5-3.1	Day of month.
		2.9-1.1	Time of creation, in half-seconds
			after midnight.
	val 5	File reference date in disk format:
		4.7-4.1	Year (mod 100.).
		3.9-3.6	Month (January = 1).
		3.5-3.1	Day of month.
		2.1-2.9 Author, as M.F.D. index.
		1.1-1.9 File byte size and bit count in compressed form.

	See also the DSKUPD, RESRDT, RFDATE, RQDATE, SFDATE,
	and SRDATE symbolic system calls.

FILLEN:	get file length

	arg 1	Disk channel number or <JOBDEV>
	val 1	File length in bytes of the size
		the channel is open in.
	val 2	The size of those bytes.
	val 3	File length in bytes of the size used to
		write it (actually, the size in use the
		last time it was opened for writing).
	val 4	The size of those bytes.

	The length of the file open on the specified channel
	is returned.


Errors:

 34	WRONG TYPE DEVICE
	Currently FILLEN works only for disk files and job devices.

FINISH:	wait for output to reach the device

	arg 1:	channel #

	Does a FORCE (see below) then waits until all buffered
	output has reached the device.

	The following devices currently support FINISH.

	TTY:	STY:	DSK:	NET:	CHA:	TCP:

	TCP: Does a FORCE (ensures that data is PUSH'd out) and
	waits until all data thus far has been ACK'd, i.e. acknowledged
	by the foreign host.

	Chaosnet: (channels opened with CHAOSO)
	On an output channel, does FORCE and then waits until
	there are no queued output buffers.  I.e., waits for
	all output to be received and acknowledged by the foreign
	host.  This in fact waits for acknowledge, not just receipt.

Errors:
*	Any errors which the FORCE call might encounter.

FLAP:	flap a micro-tape

	arg 1	Micro-tape number (typically 1-4).

	The directory for the micro-tape is written back onto
	the tape if it is currently in core; the tape is then
	physically dismounted by running the tape back onto
	the original reel (thereby making the tape go flap, flap,
	flap ...).  Micro-tapes should not be manually dismounted,
	for this will cause the directories to get out of phase,
	messing up the dismounted tape and also the next one to
	use the drive.  The FLAP will fail if any files are still
	open on the specified drive, or if any one else has the
	drive assigned to him.
	See also the .UDISMT uuo.

FLUSH:	wait for output to reach the device

	arg 1:	channel #

	This call has been renamed to FINISH (in ITS 1052).
	The old name will be kept around for a while, but new
	programs should not use it.

FORCE:	empty out device's output buffers

	arg 1 - channel #

	If any output is buffered for the device, it is now sent
	to the device.  Note that this is not needed for the TTY
	device since output is always sent as soon as possible.

	It is not necessary to do a FORCE before doing CLOSE.

	The following devices currently support FORCE:

	NET:	Causes output to be sent as soon as possible;
		otherwise it would only be sent when the buffer
		was full or when 2 seconds have elapsed since
		output was first put in the buffer.

	TCP:	Same as NET, except that the PUSH flag is set
		in outgoing segments.  If there is no buffered data,
		nothing is sent.  (Note that ITS TCP always sets PUSH
		in all outgoing segments whether FORCEd or not.
		Otherwise, a FORCE with an empty buffer would require ITS
		to re-send old data with PUSH set in order to nudge the
		remote site into action.)

	DSK:	Causes the current output buffer and the directory
		to be written to disk.

	Chaosnet: (channels opened with CHAOSO)
		If there is a partially-filled output packet (created by IOT
		or SIOT), it is transmitted.

	The following devices ignore FORCE (it always skip returns)
	because they don't need it:

	TTY:	STY:	LPT:	PLT:	PTP:	COD:

Errors:
 2	WRONG DIRECTION
	TCP: Channel is not an output channel.
 7	DEVICE NOT READY
	TCP: Connection not open for writing.
34	WRONG TYPE DEVICE
	The device is not an output device, or does not have
	the kind of buffered up output which needs this call.

IOPOP:	pop input/output channel

	arg 1	Channel number

	The top entry on the job's IO pdl is popped into the
	specified channel.  Entries on the IO pdl are made
	only by pushing channels with IOPUSH.  If a channel
	is pushed with IOPUSH and then popped into with IOPOP,
	it is in exactly the same state as it would have been
	if left untouched; however, the channel is available
	for other use in the meantime.

IOPUSH:	push input/output channel

	arg 1	Channel number

	The contents of the specified channel are pushed onto
	the job's IO pdl, and the channel is put into a
	"closed" state.  If the channel had been open, the
	open file is not closed, but is instead now open on
	the IO pdl slot instead of on the channel.  It is
	not accessible to the job for IOT'ing, etc., while
	there, but it can be popped back into a channel with
	IOPOP and then will be available for IO.


IOT:	input/output transfer

	cbits	Per-IOT mode bits.  Device dependent.
	arg 1	Channel number.  LH XOR'd with control bits.
	arg 2	Location for input/output transfer.
		May not be immediate.
		For unit mode, this is the word to
		output from or read into.
		For block mode this is an AOBJN
		pointer to a buffer.
	arg 3	(Optional) device-independent special mode bits.
		These are not currently used.

	For ease of use, in unit input mode arg 2 and arg 3
	may be omitted and val 1 will then be the word read.

For TTY and Tnn devices (terminals in general),
	the following control bits are effective for IOT.
	They are XOR'd into the left half of the I/O channel
	word both before and after the IOT (see the .IOC user
	variable).  Thus one can modify the tty's
	characteristics temporarily for just one IOT.
								(ITS TTY)
	Control bits on input:
	2.6 	%TIECH	Read even if char needs pi echoing
	2.5 	%TIPEK	Don't remove char from buffer (peek)
	2.3 	%TIACT	Don't wait for activation char
	2.2 	%TIINT	Read even if char is an interrupt
			char and hasn't interrupted yet.
	2.1	%TINWT	If no input available, don't wait, but return -1.
	1.9	%TIFUL	Use full character set (for Imlacs and TV's).

	Control bits on output:
	2.6 	%TJECH	Echo mode output.
	2.5 	%TJCTN	Don't do line continuation.
	2.3 	%TJDIS	Recognize ^P cursor codes.
	2.2 	%TJSIO	Super-image output.  No padding
			or cursor control is performed.
	2.1 	%TJMOR	Do not do **MORE** processing.
	1.9 	%TJPP2	Output in the echo area if it exists.
	1.7	%TJHDE	Account for cursor motion due to characters
			echoed on a half-duplex tty.
For the Chaosnet (channel opened with CHAOSO):
	1.4	??	Don't hang.

	This can be used to do unit-mode 8-bit-byte transfers.
	Control bit 1.4 means don't-hang, and applies to both input
	and output.  Only data packets with opcode 200 will be
	transferred.  Anything else on input causes the transfer
	to stop, like an end-of-file.  Use PKTIOT to find out what
	the story is.  (The correct way is to verify that there are
	some packets in the input buffer, then do a (S)IOT, and if it
	transfers 0 bytes then the first packet in the input buffer
	must not be a data packet, so PKTIOT it in.)

	There can be input available to (S)IOT even when the state is
	not %CSOPN (e.g. if the input buffer contains data and
	a CLS packet.)  In this case, you should first (S)IOT (if you
	care to pick up the data) then PKTIOT.


Errors:

 14	BAD CHANNEL NUMBER
 33	MEANINGLESS ARGS
	The second argument was immediate.

IPKIOT:	Internet packet (datagram) I/O

	This call is similar to PKTIOT and works for channels
	opened on the IPQ device.  It should NOT BE USED without
	a good understanding of Internet Protocol datagram formats.
	This call is still subject to change and thus is not
	documented further.  Ask KLH if you think you need to use it.

ITYIC:	read tty interrupt character

	arg 1	<TTY>
	val 1	a character

	This call fails to skip if there is no input
	interrupt character to be read from the tty.
	Otherwise, it returns the next un-ITYIC'ed
	input interrupt character.
	ITYIC'ing a character does not remove it from
	the input buffer - it is still there to be IOT'ed
	in its turn, along with the non-interrupt characters.
	ITYIC makes it possible for a program to scan input
	interrupt characters as they interrupt, without
	interfering with the IOT'ing that will take place
	later.

JOBCAL:	get info on how job device was called

	arg 1	BOJ channel number or <JOBDEV>
	arg 2	Optional: AOBJN pointer for job call data.
	arg 3	Optional: sixbit device name for PEEK and who-lines.
	val 1	"opcode" for requested operation.

	See ITS JOB for information on job devices.

	This call is to be executed by a JOB device when it
	receives an interrupt on its BOJ channel.  It returns
	data describing the operation desired by the calling job.
	Note that the second argument is an AOBJN pointer
	to an area in which the call will place data, not get it!

	The third argument, if present, is a device name to be used
	by PEEK and who-lines for printing things like ARCBO.
	(This name is initialized to the device name returned as word
	4 by OPEN - see below.  The unknown-device handler, if involved
	in the process (see the OPEN symbolic system call), resets
	this to the second file name of the JOBDEV file it actually
	succeeded in loading (this name may have had digits stripped off).)

	The "opcode" describes the operation to be performed:
		4.9-4.7	Open mode, if 2.9-1.1 contains 0.
		4.6	Close 
		4.5	Close (both bits always the same)
		4.1	SIOT rather than IOT
		3.8	pclsred call restarting
		2.9-1.1	0	.OPEN
			1	.IOT
			2	MLINK (make a link)
			3	.RESET
			4	.RCHST
			5	.ACCESS
			6	.FDELE (delete or rename)
			7	.FDELE (rename while open)
			8	.CALL

	The second argument should point to a block of 12
	words (0-11) in which the following data are deposited:

	OPEN
		wd 1	First file name.
		wd 2	Second file name.
		wd 3	Directory name.
		wd 4	Device name.
		wd 5	Full 18.-bit open mode in right half.
		wd 7	BP or AOBJN ptr specifying filename, if
			the SOPEN call was used to do the open.
			Zero otherwise.

	IOT
		wd 0	For block IOTs, the loser's IOT
			pointer.  The left half contains the
			negative of the desired number of words.
			For SIOTs, the byte count.  1 for unit IOTs.

	ACCESS
		wd 0	The address within the file to access.
			The beginning of the file is 0.

	MLINK
		wd 0	Linked-to FN1.
		wd 1	FN1 of the link.
		wd 2	FN2 of the link.
		wd 3	Directory name of the link.
		wd 4	Device name of the link.
		wd 5	Linked-to FN2.
		wd 6	Linked-to directory.
		wd 7	BP or AOBJN ptr specifying name of link,
			or 0 if the name was specified as SIXBIT.
		wd 10	BP or AOBJN ptr specifying name to link to,
			or 0 if the name was specified as SIXBIT.
	  (note links from one device to another don't exist).

	FDELE (rename or delete)
		wd 0	Zero implies delete.  Otherwise, the
			new first file name.
		wd 1	Old first file name.
		wd 2	Old second file name.
		wd 3	Name of directory.
		wd 4	Name of device.
		wd 5	Zero implies delete.  Otherwise, the
			new second file name.
		wd 7	BP or AOBJN ptr specifying file to act on,
			or 0 if the name was specified as SIXBIT.
		wd 10	BP or AOBJN ptr specifying name to rename to,
			or 0 if the name was specified as SIXBIT.

	FDELE (rename while open)
		wd 0	Zero implies delete.  Otherwise, the
			new first file name.
		wd 5	Zero implies delete.  Otherwise, the
			new second file name.
		wd 10	BP or AOBJN ptr specifying name to rename to,
			or 0 if the name was specified as SIXBIT.

	CALL
		wd 0	Name of operation in sixbit.
		wd 1	Control bits for the call.
		wd 2	Number of following words.
		wds 3-n	Input arguments to call.  The first
			will almost always be a channel number.
			Values may be returned via the
			JOBRET symbolic system call.

Errors:

 34	WRONG TYPE DEVICE
	The first argument must be a BOJ channel number or
	a JOB device channel number.

JOBGET:	get job device information

	This symbolic system call is ARCHAIC and OBSOLETE.
	It is documented here for historical purposes only.
	Its use in new programs is to be avoided.
	Its function has been superseded by the JOBCAL
	symbolic system call.

	arg 1	BOJ channel number or <JOBDEV>

	The individual returned values are identical to
	the words returned by JOBCAL in the area specified
	by JOBCAL's second argument.

JOBINT:	cause caller of JOB device to get an interrupt

	arg 1	BOJ channel number or <JOBDEV>

	See ITS JOB for information on job devices.

	This is used by JOB devices to cause the calling job
	to receive a word 2 interrupt for the channel it has
	the JOB device open on.  See also the SETIOC
	symbolic system call.

Errors:

 34	WRONG TYPE DEVICE
	The first argument must be a BOJ channel number
	or a JOB device channel number.
 41	OTHER END OF PIPELINE GONE OR NOT OPEN

JOBIOC:	set input/output channel error

	arg 1	BOJ channel number or <JOBDEV>
	arg 2	IOC error code.

	This is used by JOB devices to cause the calling job
	to receive a word 1 IOC interrupt.  This interrupt
	will be given when the calling job next attempts
	an IOT operation.  The .BCHN variable for that job
	will be set to the channel it has the JOB device 
	open on, and bits 4.1-4.5 of the corresponding
	.IOS word are set to the specified IOC error code.
	See also the JOBINT symbolic system call.

	Valid IOC error codes are as follows:
	  1	ILLEGAL HARDWARE OPERATION ATTEMPTED
	  2	ATTEMPTED RANDOM ACCESS TO ADDRESS BEYOND END OF FILE
	  3	NON-RECOVERABLE DATA ERROR
	  4	NON-EXISTENT SUB-DEVICE
	  5	OVER IOPOP
	  6	OVER IOPUSH
	  7	USR OP CHNL DOES NOT HAVE USR OPEN
	 10	CHNL NOT OPEN
	 11	DEVICE FULL (can also mean a directory is full)
	 12	CHNL IN ILLEGAL MODE ON IOT
	 13	ILLEGAL CHR AFTER CNTRL P ON TTY DISPLAY
	 14	DIRECTORY FULL
	 15	DIRECTORY'S ALLOCATION EXHAUSTED

Errors:

 33	MEANINGLESS ARGS
	Second argument is not a valid IOC error code.
 34	WRONG TYPE DEVICE
	First argument is not a BOJ channel number.
 41	OTHER END OF PIPELINE GONE OR NOT OPEN

JOBRET:	return values to loser and let him continue

	arg 1	BOJ channel number or <JOBDEV>
	arg 2	LH contains error code, or 0 if none.
		RH contains amount for loser to skip.
	arg 3	Optional AOBJN pointer to a block
		of values to be returned to the loser.

	See ITS JOB for information on job devices.

	This call is used by JOB devices to cause the
	calling job to continue after an input/output request.
	The second argument specifies an error code in its LH;
	if non-zero it is placed in bits 3.6-3.1 of the .IOS
	word for the JOB device (see the STATUS symbolic
	system call).  The RH contains the amount by which
	the loser should skip upon continuing if he used a .CALL;
	this amount is usually 0 or 1.  The third argument is
	an AOBJN pointer to a block of values which are
	passed back to the .CALL or to the .RCHST.

Errors:

 34	WRONG TYPE DEVICE
	First argument must be a BOJ channel number
	or a JOB device channel number.
 36	VALID CLEAR OR STORED SET

JOBREU:	Lets a JOB device handler offer itself for re-use

	arg 1	Device name that the handler can handle
	arg 2	FN1 of file the handler was loaded from
	arg 3	FN2 of file the handler was loaded from
	arg 4	SNAME of file the handler was loaded from
		(Note:  the only device it could have been
		 loaded from is DSK).
	arg 5	Amount of time to wait (for someone to try
		to re-use us) before giving up and taking the
		failure return, in 30'ths of a second.
		Alternatively, minus the time to wait until
		(in 30'ths since the system was started up).
		If the argument is positive (a duration) it
		is converted to a negative one (time to stop)
		and written back.

	Some job device handlers take a considerable amount of
	work to initialize themselves - for example, the ML device
	must set up network connections to another machine.
	Improved performance results if the same handler job
	can be used for several OPENs, instead of having to
	load a new job and open a new set of network connections
	for each one.  The JOBREU call makes this possible.
	The time to use it is when the handler has completed all
	of the business for one operation - it has received a
	"CLOSE" from its creator, has tidied up its data bases,
	and would otherwise have nothing to do except log out.
	Instead, it can do a JOBREU.  During the time period
	specified in the JOBREU, if any job tries to do an OPEN
	on a job device which this handler could be used for,
	this handler job will in fact be used.  In this case,
	the JOBREU will skip return.  The handler should then
	act as if it had just been loaded, and do the "initial
	JOBGET".  If nobody tries to reuse the handler in the
	specified time period, the JOBREU will return without
	skipping, and the handler should log out.

	Note that one should not do a JOBREU immediately upon
	receiving a close when the JOBRET of the initial OPEN
	has failed, because the creator has pclsred and is
	likely to be coming back.  In order to make it use the
	same job device when it comes back, JOBREU should not
	be done; instead, a PCLSRed JOB device open automatically
	finds the right job and sends another request to it.
	You should time out and if this second request does not
	come in, then give up and do a CLOSE and a JOBREU.

	There are two kinds of OPENs that can invoke the JOB device:
	 1) An open of JOB:<filenames> explicitly.  It can reuse a
	    job device handler if <filenames> match the FN1, FN2,
	    and SNAME specified in the JOBREU.
	 2) An open of a device name (such as ARC) that is not
	    built into the system.  Such an open can reuse a job
	    device handler if the device name matches the one
	    specified in the JOBREU.


Errors:

 10	DEVICE NOT AVAILABLE
	This job isn't a JOB-device handler.
 13	FILE ALREADY EXISTS
	This job device handler is already (still) in use
	by a creator.
 41	OTHER END OF PIPELINE GONE OR NOT OPEN
	Nobody tried to reuse this job, and the time period ran out.

JOBSTS:	set JOB device status

	arg 1	BOJ channel number or <JOBDEV>
	arg 2	New JOB device status - stored in the RH of
		the job channel's .IOS word, where .STATUS
		on the job channel will find it.
		This may be arbitrary, of course, but the
		standard bits are as follows:
		2.9-2.3	Device dependent.
		2.2	Buffering capacity empty.
		2.1	Buffering capacity full.
		1.9-1.7	Mode in which device was opened.
			1.9	0 = ascii, 1 = image.
			1.8	0 = unit, 1 = block.
			1.7	0 = input, 1 = output.
		1.6-1.1	ITS internal physical device code.
			For a job device this should be 22,
			unless you really know what you are
			doing.
		If omitted, 000022 is used.
	arg 3	Sets the "device name" of this channel.
		The device name is used by the RFNAME
		and RCHST system calls, and by PEEK
		and who-lines, to say what device a job
		is transferring to or waiting for in the
		job's status.  The argument is optional.
	arg 4	Sets the "file name 1". Optional.
	arg 5	Sets the "file name 2". Optional.
	arg 6	Sets the "system name". Optional.
	arg 7	Sets the "open mode" that will be returned
		by the RFNAME system call.  Optional.
	arg 8	Optional byte pointer to ASCIZ string in device handler's
		address space containing full filenames.  The byte pointer
		my not be indexed or indirect.  Note that ITS might decide
		to read a string from this byte pointer at any time, so the
		string must continue to exist even after the JOBSTS call
		has returned.

	When the channel is first opened the device, file
	name 1, file name 2, system name, and open mode
	are set to the ones by which the channel was opened.
	JOB device programs may change these if they wish,
	but are not required to.	

	See the STATUS symbolic system call, the .STATUS uuo,
	and the RFNAME system call.

	See ITS JOB for information on job devices.

KLPERF:	Use KL10 performance analysis counter

	arg 1	<JOB> whose performance is to be measured
		-3 (%JSNUL) => the null job
		-4 (%JSALL) => all jobs
		0,,-3 and 0,,-4 are also acceptable.
	arg 2	Performance Analysis Enables word
		0 => turn off the performance counter
		and make it available for other users.
		See DEC drawing M8538-0-MTR4 for the bits in this
		argument.
	val 1	Previous <JOB> setting; -3, -4, or a job number
	val 2	Previous Performance Analysis Enables word
	val 3	High-order word of the time base
	val 4	Low-order word of the time base
	val 5	High-order word of the performance counter
	val 6	Low-order word of the performance counter

	If no arguments are supplied, the state of the counter
	is not changed and the six values are returned.

	If arguments are supplied, the performance analysis counter
	is siezed so no other users can interfere and performance
	measurement begins.  When the specified job is running
	and the conditions specified in the Enables word are met,
	the performance counter counts.  A bit in the Enables
	word controls whether it counts the duration, in microseconds,
	that the conditions were satisfied, or the number of times
	that the conditions became satisfied.  While the specified
	job is running, the time base counts microseconds.  If -4
	(all jobs) was specified, this is the elapsed real time.
	Issuing the KLPERF call again allows the results to be
	determined by subtracting the values obtained the first time
	from the values obtained the second time.

	The two counters are double-precision numbers.  The high-order
	35 bits are in bits 1.1-4.8 of the high-order word, and
	the low-order 23 bits are in bits 2.4-4.8 of the low-order
	word.

Errors:

 10	DEVICE NOT AVAILABLE
	Someone else is using the performance analysis counter.
 14	BAD CHANNEL NUMBER
	Argument 1 is invalid.
 35	NO SUCH JOB
	Argument 1 specified a non-existent job.

LISTEN:	listen for any typed-ahead input			(ITS TTY)

	arg 1	<TTY> (but not a STY channel) or <JOBDEV>
	val 1	Number of typed-ahead characters pending.

	Waits for output buffer to empty before listening.
	To check for input without waiting for output use
	.STATUS.  The uuo .LISTEN is the same as LISTEN,
	but applies only to the job's console, and furthermore
	returns zero if the job doesn't possess the tty.

Errors:

 14	BAD CHANNEL NUMBER

LNKEDP:	find out whether open file was reached via a link

	arg 1	Channel number of open disk file
	val 1	Nonzero if file was reached via a link.

	The file open was reached through a link if the names
	actually specified in the OPEN were the names of a link
	which pointed at this file.  It is not a question of
	what file is open, but of what names were specified to
	open the file.

Errors:

14	BAD CHANNEL NUMBER
	Arg 1 is not between 0 and 17.
34	WRONG TYPE DEVICE
	Arg 1 does not specify a disk channel.

LOAD:	load file (a program) into a job

	arg 1	<JOB>
	arg 2	Disk channel number (freshly opened for reading).
	arg 3	Optional argument which causes part of the file
		to be ignored:  either <start>,,<end>, to load
		only between addresses <start> and <end> (inclusive),
		or zero meaning load only pure pages.
		The default is 0,,-1 normally, 20,,-1 when loading
		oneself, and 20,,37777 when loading the PDP6.
		When loading a PDUMP format file, <start> and <end>
		are rounded outward to page boundaries.

	The file open on the input channel is loaded into
	the specified job.  The file may be in one of two formats:
	PDUMP format, or SBLK format.  The former is produced by
	the PDUMP symbolic system call, under which its format
	is documented.  The latter is described below.
	The two formats are distinguished by the
	fact that a PDUMP format file begins with a zero word,
	but an SBLK format file begins with a non-zero word.

	SBLK format:
	First off, any words in the file are ignored until a word
	254000,,1 (JRST 1) is found.  This should be followed
	by zero or more blocks of the following form:
	wd 0	-<n>,,<loc>
	wds 1-n	data words
	wd n+1	checksum
	That is, the first word is an AOBJN pointer describing where
	to load <n> consecutive words of data into the job; this is
	effectively used as a block .IOT pointer to load the words.
	Following the data is a checksum, which is ignored.
	(Historically, when microtapes were used, the checksum was
	necessary for error checking.)
	Following the last block must be a non-negative word
	to denote the fact that there are no more blocks.
	This word and all succeeding words in the file are ignored.
	(DDT assumes that this word contains the starting
	address of the program, and that following words contain
	the symbol table for the program.)  The disk channel
	is left open, with the access pointer pointing to the
	positive word which followed the last block.

	The standard form of symbol table is:
	-<2*n>,,0
	squoze code,symbol  --  these 2 words are
	value of symbol     --  repeated n times

	The word after the symbol table is another copy of the starting address.

Errors:

7	DEVICE NOT READY
	A disk read error occurred.
31	CAN'T MODIFY JOB
	The calling job may not write into the job being loaded.
32	CAN'T GET THAT ACCESS TO PAGE
	You tried to create an absolute page pointing to memory
	that the system doesn't have.
34	WRONG TYPE DEVICE
	Arg 2 does not specify a disk read channel, or
	you tried to load a PDUMP file into the PDP-6.
37	NO CORE AVAILABLE
	The MMP was full so a needed page could not be created.
46	UNRECOGNIZABLE FILE
	The file open on the specified channel is not in
	valid SBLK format, nor in valid PDUMP format.

LOGIN:	log in a job tree

	arg 1	Sixbit name to log in under.
		" " (0) and "___xxx" (-1 in left half) are illegal.
	arg 2	Sixbit name of "terminal."  This is not required 
		for hard-wired terminals.  When this field specifies
		a network host, the standard form is HSTnnn, where
		nnn is the octal host number, however often the English
		name of the host, abbreviated to six letters, is used.
	arg 3	Sixbit XUNAME.  This is normally the same as arg 1
		except that if arg 1 is changed to make it unique,
		this should not be changed.  The XUNAME is what is
		used for accounting purposes.

	The uname for the job tree is changed from "___nnn"
	(where "nnn" is the top-level job's user index in
	sixbit octal characters), which is the initial uname of
	a non-logged-in job tree, to the specified sixbit name.
	If the job tree already has a uname other than "___nnn",
	the LOGIN fails.  Only top-level jobs with no direct
	inferiors may LOGIN.

Errors:

 11	ILLEGAL FILE NAME
	Cannot log in as "___xxx" or " ".
 12	MODE NOT AVAILABLE
	Jobs with direct inferiors may not log in.
 13	FILE ALREADY EXISTS
	Someone is already logged in under the specified name.
 31	CAN'T MODIFY JOB
	Already logged in.
 40	NOT TOP LEVEL
	Only top-level jobs may log in.

LOGOUT:	log out a job tree

	No arguments or values (note, however, that at least
	one must be present in order to contain the 4.9 bit
	terminating the argument list).  If the executing
	job is the top level job in its job tree, then the
	entire job tree is expunged from the system.
	Does not skip if not a top level job.  This is not
	considered an error, however; no error code is returned.
	See also the .LOGOUT uuo.

LOSE:	report lossage

	arg 1	left half - address of losing instruction
		right half - lossage code (defined by DDT.)
	arg 2	new PC.  If omitted, the address of the .CALL
		minus one is used.
	control bits:
	1.1	default arg 2 to the address of the .CALL plus one.
	1.2	do SETZM @.40ADDR, i.e. clear the location
		in the job where a UUO returned from the
		system would be stored.
	1.3	Really take the left half of arg 1 as the address
		of the losing instruction.  If this control bit
		is not specified, the new PC is used instead.

	The job's Program Counter is set to the new PC,
	the job's .VAL user variable is set to the address
	of the losing instruction,,the lossage code, and the
	job is given a %PILOS interrupt.  If the job does not
	enable this interrupt, and its superior is DDT, a
	helpful error message will be printed.

	The LOSE symbolic system call is a more general version
	of the .LOSE UUO.  .LOSE is simpler, and usually good
	enough.  Symbolic LOSE is for situations where sophisticated
	error reporting is needed. Symbolic LOSE allows the new PC
	value to be specified explicitly, and therefore is suitable
	for use inside an error-handling subroutine.  In addition,
	the address of the "culpable" instruction can be specified
	independantly from the address to restart at.  Thus, the
	program can provide more complicated error recovery
	than simply restarting at the losing instruction.

	The lossage codes are defined by DDT's interpretation of them.
	The defined values are:

	%LSSYS==1000	The last error code returned by a failing
		system call describes the problem.

	%LSFIL==1400	The last error code returned by a failing
		system call, together with the name of the file
		it was operating on, describe the problem.
		The "culpable instruction" address should point
		at the failing system call.
		DDT will decode it to determine the filenames
		(if it is an OPEN) or the channel number and then
		the filenames via an RFNAME.

	%LSSYS+errcode	Means that the system call error code
		<errcode> describes the problem.

	%LSFIL+errcode	Means that the error code <errcode>
		together with the filenames being used
		describe the problem.

	0	Signifies some other nondescript error condition.

	1+.LZ <interrupt bit>
		Means that the error should be handled as if it
		were a fatal interrupt on the specified interrupt
		bit.  For example, 1+.LZ %PIMPV will make DDT tell the
		user that the job received a fatal MPV interrupt.  Why
		might a program wish to do this?  It might have
		enabled its own handling of MPV, and then received an
		MPV interrupt at a time when one was not expected and
		was not recoverable.  At such a time the ideal thing
		to do is to report the MPV back to DDT, so that DDT
		will handle it - to "pretend" that MPV wasn't enabled
		at all.  To make the pretense complete, the program's
		own MPV interrupt handler should dismiss the
		interrupt, and leave the PC pointing at the guilty
		instruction, since that would be the state of things
		if the program had not handled the interrupt.  That
		can be done with a special feature of the DISMIS
		symbolic system call, which can do a .LOSE after
		dismissing the interrupt and restoring the PC.

	This call never gets an error, and never returns.

MLINK:	make link

  Either
	arg 1	Byte pointer to ASCIZ string specifying name for link,
		or AOBJN pointer to block of byte pointers,
	arg 2	Byte pointer to ASCIZ string specifying name to link to,
		or AOBJN pointer to block of byte pointers,

  Or
	arg 1	Left-justified "from" device.
	arg 2	"from" file name 1.
	arg 3	"from" file name 2.
	arg 4	"from" sname.
	arg 5	"to" file name 1.
	arg 6	"to" file name 2.
	arg 7	"to" sname.

	A link is created on the specified device.
	The only standard device which accepts links
	is DSK; of course, various job devices (such as
	the AI, ML, DM, and MC devices) also implement it.
	Links cause an indirection when opened
	for reading;  writing or deleting a link affects
	the link itself.
	The "from" file names are subject to file name
	translation.  See the TRANAD and TRANDL symbolic
	system calls.

	See the SOPEN symbolic system call for a description of
	how the byte or AOBJN pointer arguments should be formatted
	and how the strings are parsed into filenames.

NETAC:	accept network connection		OBSOLETE	(ITS NCP)

	This system call is obsolete, and has been flushed.
	It is documented here for historical purposes only.

	arg 1 - channel # of an Arpanet NCP channel

	If the channel is in the RFC-received state, the
	connection is accepted.  Use CLOSE to refuse a
	request for connection.

	See also the .NETAC UUO.

	This call only works for NCP and is obsolete.  It isn't needed
	for TCP since incoming requests that satisfy a LISTEN will
	automatically be hooked up and the connection opened.

Errors:

34	WRONG TYPE DEVICE
	The specified channel is not an Arpanet NCP channel
41	OTHER END OF PIPELINE GONE OR NOT OPEN
	The socket is not in the %NSRFC (request for
	connection received) state.

NETBLK:	network block						(ITS NCP)

	arg 1	Channel number - should be a network channel.
		NCP, TCP, and CHAOS are allowed.
	arg 2	Connection state code.
		NCP: Socket state as returned in the right
		half of word 4 by the .RCHST uuo:
		0	%NSCLS	CLS received.
		1	%NSLSN	Listening for RFC.
		2	%NSRFC	RFC received while listening.
		3	%NSRCL	CLS received while in RFC received state.
		4	%NSRFS	RFC sent.
		5	%NSOPN	Connection open.
		6	%NSRFN	RFNM wait on write link.
		7	%NSCLW	CLS sent.  Waiting for matching CLS.
		10	%NSCLI	CLS received, but input still available.
		11	%NSINP	Input available.
		CHAOS:
		TCP: basically the same as NCP.  See WHYINT for state list.
	arg 3	Optional: address of a word containing an argument
		as for the .SLEEP uuo.  This word must be writable,
		as it will be replaced by an appropriate negative
		number as for .SLEEP.
		If not supplied, positive infinity (377777,,777777)
		is assumed by default for the time to sleep.
	val 1	New connection state.
	val 2	Time left, in thirtieths of a second.
		(Meaningful only if arg 3 supplied.)

	The executing job hangs until one of two conditions
	becomes true: either the network conection associated
	with the specified channel enters a state different
	from the specified state, or the amount of time
	specified by arg 3 has passed.

	Example:  suppose that a NCP socket is in state 1
	(listening for RFC).  This call will return when
	the socket is no longer in that state, or after 5
	seconds, whichever comes first:

		MOVEI AC,5*30.		;five seconds
		.CALL [ SETZ
			SIXBIT \NETBLK\		;network block
			  1000,,CHNUM		;channel number
			  1000,,%NSLSN		;old state
			      ,,AC		;time to sleep
			  2000,,NSTATE		;new state
			402000,,TLEFT	]	;time left

Errors:

34	WRONG TYPE DEVICE
	The specified channel is not a network (NCP, TCP, CHAOS) channel.

NETHST:	net host status						(ITS NCP)

	arg 1	Host number (-1 for self).
	arg 2	Reason for going down (optional, valid
		only if arg 1 is -1).
		5	Going down for scheduled P.M.
		6	Going down for scheduled hardware work.
		7	Going down for scheduled software work.
		10	Going down for emergency restart.
		11	Going down because of power outage.
		12	Stopping at software breakpoint.
		13	Going down because of hardware failure.
		14	Going down because not scheduled to be up.
	val 2	Host number (useful if arg 1 is -1).
		Note THESE ARE OUT OF ORDER (because "val 1" is so long).
	val 1	Host status
		4.9	1 => RFNM wait on link 0.
		4.8-4.3	Unused.
		4.2-4.1	Host status:
			0	Down.
			1	RST sent.
			2	Up.
		3.9-3.1	Time (as returned by .RDTIME) modulo 1000
			the last RFNM sent on link 0.
		2.9-1.1	Last message from IMP about "host dead status"
			for this host.  (See BBN Report #1822, Chapter 3.)
			2.7-1.5	Time host will come back up, Greenwich Mean Time:
				2.7-2.5	Day of week (0=Monday, ..., 6=Sunday).
				2.4-1.9	Hour of day (0-23.).
				1.8-1.5	Five-minute interval within hour (0-11.).
				-1 means more than a week.
				-2 means time coming back up is unknown.
			1.4-1.1	Reason host is down:
				1	Foreign host not communicating
					with network (took ready-line down
					without saying why).
				2	Foreign host not communicating with
					network (host was tardy in accepting
					network traffic without saying why).
				3	Foreign host does not exist, to the
					knowledge of the Network Control Center.
				4	The IMP software is preventing
					communication with foreign host
					(this usually indicates IMP software
					initialization at the foreign site).
				5	Foreign host down for scheduled P.M.
				6	Foreign host down for scheduled
					hardware work.
				7	Foreign host down for scheduled
					software work.
				10	Foreign host down for emergency restart.
				11	Foreign host down because of power outage.
				12	Foreign host stopped at software
					breakpoint.
				13	Foreign host down because of hardware
					failure.
				14	Foreign host not scheduled to be up.
				17	Foreign host in process of coming up.

	If one argument is supplied, then the host status word
	for the specified host is returned.  If two arguments are
	supplied, then the "reason for going down" word for the
	local host is set.  (As of June 30, 1975, setting this
	word doesn't seem to do anything at all.  Didn't the code
	for sending this data to the IMP ever get written??)

NETIMP:	network IMP status					(ITS NCP)

	If no arguments are present, three values are returned:
	val 1	Last message from IMP about going down.
		4.9	IMP really is down now.
		1.2-1.1	Reason:
			0	"Last warning" or "panic restart";
				the IMP is going down in 30. seconds or less.
			1	Scheduled hardware P.M.
			2	Scheduled software reload.
			3	Emergency restart.
	val 2	Time going down, as returned by .RDTIME.
	val 3	Time coming back up, as returned by .RDTIME.

	If arguments are present, three must be present.
	They are used to set three default values which are returned
	if the IMP itself has not set the above three values.
	Presumably this is good for logically disabling network software?

Errors:

30	TOO FEW ARGUMENTS
	Must have either 3 arguments or no arguments.

NETINT:	Send network interrupt			OBSOLETE	(ITS NCP)

	This system call is obsolete, and has been flushed.
	It is documented here for historical purposes only.

	arg 1	channel #

	An INR or INS message is sent, depending on the send/receive
	gender of the socket specified by the channel #.  What this does
	depends on the protocol being used and the program at the
	other end of the connection.

	This call only works for NCP and is obsolete.
Errors:

34	WRONG TYPE DEVICE
	The channel specified is not an Arpanet NCP channel.

NETRFC:	Get pending Request For Connection for a specified network

	cbits
		%NQREF	Arg 2 is a previously returned identifier,
			refuse connection and flush from queue.
	arg 1 - SIXBIT name of network
		one of CHAOS, TCP, or ARPNCP (obsolete)
	arg 2 - optional network-dependent arg
		for CHAOS: pointer to packet buffer
		for TCP: If %NQREF set, is <id>,,<port #> of request to
			reject (as returned from previous NETRFC call)
	val 1 - network-dependent value
		for TCP: <id>,,<port #>
		for ARPNCP: <id>,,<socket #>

	This call is intended for use by very specialized programs
	which ITS invokes upon receiving unsolicited requests for
	connections.  ITS will queue the request for a short time
	and start an appropriate job which uses NETRFC to obtain
	the request and process it.  Currently these programs are
		NCP:	SYS;ATSIGN NETRFC
		TCP:	SYS;ATSIGN TCP
		CHAOS:	SYS;ATSIGN CHAOS

	Normally the program will execute a NETRFC appropriate for its
	network, and obtain a returned request value.  Accepting the
	request is device dependent, but refusal can always be done
	by calling NETRFC again with the %NQREF control bit set and
	furnishing the appropriate request identifier.

	See the CHAOSQ system call, which NETRFC is replacing.

ERRORS
  4	- TCP: No pending RFCs, or %NQREF with non-existent <id>,,<port>.
 12	- CHAOS: can't handle %NQREF yet.
 33	- Unknown network specified.

OPEN:	open a file

	cbits	Device dependent. Standard bits are:
		2.7-2.9	0 = normal, 1 = write-over mode.
		1.3	0 = ascii, 1 = image.
		1.2	0 = unit, 1 = block.
		1.1	0 = read, 1 = write.
	arg 1	Channel number.  LH XOR'd with control bits.
	arg 2	Left-justified device name.
	arg 3	File name 1.
	arg 4	File name 2.
	arg 5	Sname.  If not present, defaults to executing
		job's current sname (see the .SNAM user variable).

	See also the .OPEN uuo.

	The file names used for opening are subject to translation.
	See the TRANAD and TRANDL symbolic system calls.

	The file names  .FILE. (DIR)  are special:
	they cause the directory for the given device
	(and sname, if applicable) to be read.  It is
	illegal to write the directory.  If a device has
	no directory, then opening  .FILE. (DIR)  will
	supply the string "NON-DIRECTORY DEVICE", presumably.
	(This is a function of the unknown-device handler
	(see below) and hence the exact results may vary).
	Opening a directory in ascii mode yields an
	ascii string for people to look at; opening it
	in image mode yields a device-dependent file
	(or possibly a MODE NOT AVAILABLE error).

	For the DSK device, the control bits are:
	1.4	%DONRF	Don't set the reference date.
	1.5	%DONLK	Don't chase links.  (I. E., if
			this is a link, open the link itself,
			not the file at which the link points.
	1.6	%DORWT	Readers wait.  On output open, makes would-be
			readers wait till we close.
	2.7	%DOWOV	Write-over mode.  Writes on the existing
			file of that name, instead of replacing
			it with a new file.

	The file names  M.F.D. (FILE)  when opened for
	input yield a master file directory for all
	disks.  In ascii mode this is an ascii string
	containing the names of all directories, separated
	by a cr/lf sequence.

	The file names  ..NEW. (UDIR)  cause a new directory
	to be created with the given sname if none already
	exists.  Creating a directory in this way causes a
	message to be printed on the system console.
	(A directory is destroyed only when the disks are
	salvaged by the stand-alone salvager, which is generally
	run just before the time-sharing system is restarted.
	A directory is then destroyed iff it contains no files.)

	If  <  or  >  is used as a file name, it is treated
	specially according to an algorithm no one
	understands, but which attempts to let it stand
	for the numerically smallest or largest file name
	among those in the directory.  In particular,
	if you call your files  FOO nnn, where nnn is a version
	number, then reading  FOO >  will read in the latest
	version, writing  FOO >  will write out a version
	one higher than the latest one (or  FOO 1  if there
	is no file named  FOO nnn), and deleting  FOO <
	will delete the oldest one.  Writing FOO < doesn't
	recreate an old file; it is the same as FOO >.
	If a file with numbers and letters in its name,
	for example  FOO BAR27, already exists,
	writing  FOO >  will generate  FOO BAR28
	and not FOO 1.  Letters to the right of numbers are
	generally ignored as far as < and > are concerned.

	Note that < and > may be used as first
	file names as well; this is mainly useful for the
	.LPTR. directory.  It is illegal to use  <  or  >  for
	both file names at once.

	The SYS device ignores the sname, and otherwise
	is like using the device-sname pair  DSK:SYS; .
	Writing new files or altering old ones on the SYS
	device (or even on DSK:SYS;) causes a message to
	appear on the system console documenting who the
	culprit is and what he did.  This is because system
	programs and other files critical to system operation
	are kept on SYS:.  In fact this applies to writing
	or altering files on any disk directory whose name
	begins with the three letters "SYS".  Standard
	directories whose names begin with "SYS" include:
	SYS1	Extension for SYS directory (holds programs).
	SYS2	Extension for SYS directory (holds programs).
	SYS3	Extension for SYS directory (holds programs).
	SYSENG	Source files for many system programs.
	SYSEN1	Extension for SYSENG directory.
	SYSEN2	Extension for SYSENG directory.
	SYSBIN	Binary files for many system programs.
	SYSTEM	Files having to do with ITS itself.
	SYSDOC	Documentation for ITS itself.
	SYSNET	Files having to do with Chaosnet and TCP.

	The COM device ignores the sname, and otherwise
	is like using the device-sname pair  DSK:COMMON; .

	The TPL device ignores the sname, and otherwise
	is like using the device-sname pair  DSK:.LPTR.; .
	(On systems without lineprinters the TPL device is
	generally just a JOB device.)
	On output, it furthermore ignores the file names,
	and instead uses the uname of the opening job as
	the second file name, and randomly generates a
	first file name.  The system job prints files
	it finds on .LPTR. on the line printer, whenever it
	has nothing better to do and the line printer happens
	to be free; these files are subsequently deleted.
	Thus the TPL device provides a printer spooling facility.
	Attempts to rename a file on the TPL device are
	ignored, because the name controls the spooling order.

	For the LPT device, opening succeeds only if no one
	has the LPT, or the same user already has the LPT;
	in the former case the opening job must be in a tree
	controlled by a "local" tty as defined by its TTYTYP
	variable.  In all other cases the OPEN is converted
	to use the TPL device instead.

	For the USR device, the file names should be the
	uname-jname pair of the job to open.  If the uname is
	zero, it is equivalent to using the uname of the
	job doing the call.  If the jname is zero, then the
	uname is interpreted as a <JOB> specification;
	in this way one can open a job given its user index.
	A jname of PDP6 or PDP10 opens up the PDP-6
	as the "job".  (PDP10 as a jname goes back to the
	days when the PDP-6 ran ITS and the PDP-10 was the
	auxiliary processor!)
	Control bits:
	1.4	Insist on opening an already existing job;
		i.e. do not create a new one.  The job will
		be opened as a foreign job, not as an inferior.
	Here is an algorithm for deciding whether job Y will
	be a direct inferior or merely a foreign job when
	opened by job X:
		(DEFUN USR-OPEN-RESULT (X Y BIT-1*4)
		       (COND (BIT-1*4 (COND ((EXISTS Y) 'FOREIGN)
					    (T (ERROR))))
			     ((EXISTS Y)
			      (COND ((INFERIOR Y X) 'INFERIOR)
				    ((DISOWNED X) 'FOREIGN)
				    ((NOT (DISOWNED Y)) 'FOREIGN)
				    ((TOPLEVEL Y)
				     (MAKE-NON-DISOWNED Y)
				     (CHANGE-ALL-UNAMES Y (UNAME X))
				     (FIX-UP-TTY-CHANNELS Y)
				     'INFERIOR)
				    (T 'FOREIGN)))
			     ((= (UNAME X) (UNAME Y))
			      (CREATE-USR Y)
			      (AND (DISOWNED X)
				   (MAKE-DISOWNED Y))
			      'INFERIOR)
			     (T (ERROR))))

	For the ERR device, the first file name must be
	numerically 1, 2, 3, or 4.  If it is 1, then the .IOS
	word specified by the user variable .BCHN is
	examined.  If it is 2, the .IOS word for the channel
	numerically specified by the second file name is
	examined.  If it is 3, the second file name is itself
	the status word.  Bits 3.1-4.5 of the specified word
	yield a the number of an error message which can then
	be read from the open ERR device.  If the first file
	name is 4, the second file name must be the value
	returned into an error code return argument by a symbolic
	system .CALL that didn't skip.  The corresponding error
	message can be read from the open ERR device.

	For TTY and Tnn devices (terminals in general),
	some of the control bits set first-time options,
	and some are per-channel.  Those which are per-channel
	are marked below with a *.  The standard names for
	these bits are also given.			(ITS TTY)
	Control bits on input:
	2.6 *	%TIECH	Read even if char needs pi echoing
	2.5 *	%TIPEK	Don't remove char from buffer (peek)
	2.3 *	%TIACT	Don't wait for activation char
	2.2 *	%TIINT	Read even if char is an interrupt
			char and hasn't interrupted yet.

	2.1 *	%TINWT	Do not wait for input.  If no input
			is available, return -1 in unit mode, or
			return a partially filled block in block mode.
	1.9 *	%TIFUL	Use the full TV character set if possible.
			In this mode, characters have this form:
			2.3	%TXTOP	Top.
			2.2	Obsolete.  Used to be Shift lock.
			2.1	%TXSUP	Super.  Used to be Shift.
			1.9	%TXMTA	Meta.
			1.8	%TXCTL	Control.
			1.7-1.1	%TXASC	Ascii part of character.
			Of course, for non-TV's only %TXASC
			will be non-zero.
	1.6	Set up 3 line echo area (like SCML of 3).
	1.4	"DDT" mode.  Initially clear the %TGPIE and
		%TGMPE bits for carriage return, line feed,
		and tab, thus causing them not to echo.
	1.3	Image mode.  Initially clear the %TGPIE
		and %TGMPE bits for all characters.
	1.2	0 = unit mode, 1 = block mode.  In block mode,
		^C causes a block mode end of file.
	1.1	0 = input.
	Control bits on output:
	2.6 *	%TJECH	Echo mode output.
	2.5 *	%TJCTN	Don't do line continuation.
	2.4 *	%TJSTP	Channel is hung in **MORE**.
		Unusual in that the system modifies this bit.
	2.3 *	%TJDIS	Recognize ^P cursor codes.
	2.2 *	%TJSIO	Super-image output.  No padding
			or cursor control is performed.
	2.1 *	%TJMOR	Do not do **MORE** processing.
	1.9 *	%TJPP2	Output in the echo area if it exists.
	1.6	Same as 2.2 - turns on %TJSIO.
	1.5	Same as 2.3 - turns on %TJDIS.
	1.4	Turns on %TJECH, %TJPP2, %TJMOR.
	1.3	Image mode.  Initially set %TGIMG bits
		for all characters.
	1.2	0 = unit mode, 1 = block mode.  In block mode
		output all ^C's are ignored.
	1.1	1 = output.

	For STY device input, control bit 1.4 means that
	input IOTs, instead of hanging, will input a -1 in
	unit mode or not count out the AOBJN pointer in block
	mode (see ITS TTY for details).
	For STY output, control bit 1.4 means that output IOTs,
	instead of hanging when the tty's input buffer is full,
	will cause a ^G to be output, just as on normal ttys.
	Control bit 1.5, on input or output, causes a %TDORS
	character to be available as input when an output
	reset is done on the sty's alter ego.
	Control bit 1.3 is copied into the %TOHDX bit of the
	associated tty, thus making it half-duplex if set.
	These control bits are not per-channel, but rather
	will affect all channels open on the same STY.

	For the LOCK device, the first file name is the name of the lock to
	seize.  Control bit 1.4 causes the open to hang if the lock is
	already locked.  See ITS LOCKS for details.

	For the UBI device, the first file name is of the form:
	<Unibus adaptor number>,,<Interrupt address>.

	For the PTR and PTP devices (paper tape reader and
	punch), if the 1.4 control bit is on, then the 1.2 bit
	must be 0 and the 1.3 bit is ignored.  In this mode
	all eight paper tape channels may be read or punched.

	For the NET device, the arguments are as follows:
	cbits	2.1-2.6	byte size for image mode
		1.7	Use 8 times as large a buffer.
		1.6	If ascii mode, use 8-bit bytes
			instead of 7-bit bytes.
			If image mode, use byte size in
			bits 2.1-2.6.
		1.5	Open socket in listen mode.
		1.4	0 = use arg 3 as local socket number.
			1 = generate unique local socket number.
			(A generated socket number can be examined
			after opening by using the .RCHST uuo).
		1.1-1.3	Standard.
	arg 1	Channel number.
	arg 2	Left-justified device name (i.e. NET).
	arg 3	Local socket number.
	arg 4	Foreign socket number.
	arg 5	Foreign host number.

	For the STK device (Stanford keyboard):
	cbits	1.7	If 1.6 = 1 and 1.5 = 0,
			then don't input the meta bit.
		1.6	0 = Stanford mode:
				meta = 400
				ctrl = 200
				top+shift+others generate 0-177
			1 = ITS mode:
				meta = 200
				ctrl means ctrl, and works
				with others to generate 0-177
		1.5	0 = convert according to 1.6-1.7.
			1 = don't convert characters.
		1.4	Don't hang if no character
			available for input - return -1
			instead.

	If the device name used in the OPEN is not one known to
	to the system, the "unknown-device handler" is invoked.
	The system creates a job device and loads SYS:ATSIGN DEVICE
	into it; this program then has the responsibility for
	handling the OPEN.  The normal action of this program is
	to look for a file DSK:DEVICE;JOBDEV <name>, where <name>
	is the requested device name.  For example, if an attempt
	is made to OPEN the FOOBAR device, and the file
	DSK:DEVICE;JOBDEV FOOBAR exists, the program contained in
	this file will be used to interpret the OPEN via the JOB device.
	If such a file does not exist, but the device name has trailing
	digits, the unknown-device handler will try stripping successive
	trailing digits and retrying.  For example, opening the
	AR1 device causes the unknown-device handler to look first for
	JOBDEV AR1, and then for JOBDEV AR.  If the handler succeeds,
	it sets device name for PEEK and who-lines to the second
	file name that finally succeeded (see the JOBSTS symbolic
	system call).
	The unknown-device handler also handles requests for the
	directories of certain built-in devices whose directories
	are seldom asked for.  If there is nothing better to return for
	a directory, the string "NON-DIRECTORY DEVICE" is returned.

Errors:

	OPEN can return many errors.  The following errors in
	particular are relevant to OPEN on the DSK device:

  4	FILE NOT FOUND
	The specified directory exists, but the specified file
	does not.
  5	DIRECTORY FULL
	There is no room in the directory to create an entry
	for the new output file.
  7	DEVICE NOT READY
	The disk pack containing the file is offline (should
	never really happen).
 10	DEVICE NOT AVAILABLE
	a specific unit was selected, by opening DKn, and that
	unit is off-line or contains a reserved pack.  Or, a
	specific pack was selected by opening PKn or Pnn,
	and that pack is reserved.  The reserved-pack check
	only applies when writing.  Reserved means secondary-pack,
	or reserved for the exclusive use of certain directories.
 11	ILLEGAL FILE NAME
	One or both file names were zero; or, for an output file,
	the file names were M.F.D. (FILE) or .FILE. (DIR), which
	are names reserved for directories.
 12	MODE NOT AVAILABLE
	Control bits 2.9-2.7 specified an illegal mode.
 14	BAD CHANNEL NUMBER
	This is a RENMWO error.
 16	PACK NOT MOUNTED
	The pack specified by opening PKn or Pnn is not
	mounted, or the pack containing the file being read
	is not mounted.
 20	NON-EXISTENT DIRECTORY
	The specified directory does not exist.
 22	SELF-CONTRADICTORY OPEN
	Control bits 2.9-2.7 specified an illegal mode.
 23	FILE LOCKED
	An attempt to open a file in write-over mode failed
	because someone has the file open for reading; or
	an attempt to open a file for read, write-over, rename,
	or delete failed because someone is writing the file
	or because the file has been deleted, but hasn't gone
	away yet because someone is reading it (i.e. there is
	a star next to it in the directory listing.)  wait a while
	and try again.
 24	M.F.D. FULL
	Cannot create a new directory because the master file directory
	is full.
 27	LINK DEPTH EXCEEDED
	Links may not be chained to a length of greater than 100 links.
	This error probably means a circular chain of links.
 47	LINK TO NON-EXISTENT FILE
	Error 4 or 20 occurred after following a link.

PDUMP:	pure dump a job

	arg 1	<JOB>.
	arg 2	Disk output channel number.
		Should have been freshly opened
		for output.
	arg 3	State word; should be 0 initially.
		This word is updated as the PDUMP
		progresses; a value of 400000,,<n> means
		that page <n> is about to be dumped.

	The pages of the specified job are dumped onto
	the disk file in a form that can be efficiently
	loaded.  In particular, information as to whether
	each page is read-only or not is saved so that
	when the program is run it can be swapped
	efficiently.  If the same file is loaded into
	several jobs, they will all share the same
	physical copies of the read-only pages.
	In addition, absolute pages are remembered.
	A number of 2000-word (1K) blocks are dumped onto
	the file.  The first block is as follows:
	wd 0		Contains zero.  This distinguishes
			PDUMP'ed programs from, for example,
			MIDAS output.
	wds 1-400	Word <n> contains information about
			block <n-1> of the dumped job.  This
			information is as follows:
			4.9	Absolute page (shared with system).
			2.9-2.8	00	Non-existent page.
				01	Read-only page.
				10,11	Read/write page.
			2.2-1.1	If 4.9=1, absolute page number.
	wds 401-777	Zero.
	wds 1000-1017	The contents of the accumulators.
			Note that the accumulators aren't part of
			any page, so they wouldn't be saved if it were
			not for this special hack.
	The following blocks of the file are the successive
	pages of the job, but only those which need to be dumped.
	That is, absolute and non-existent pages are not dumped.
	Thus, suppose the pages of a job are laid out as follows:
		pg 0	Read/write.
		pg 1-5	Read-only.
		pg 6-7	Absolute (e.g., system symbol table).
		pg 100	Read/write.
		pg 200	Read/write.
		others	Non-existent.
	Then nine blocks would be dumped out:
		blk 0	Descriptor block.
		blk 1	Page 0.
		blk 2-6	Pages 1-5.
		blk 7	Page 100 (octal).
		blk 10	Page 200 (octal).
	This is all that PDUMP writes out, leaving the file's access
	pointer at the end of the last block written.  At this point
	the job doing the PDUMP will normally write out the
	symbol table, if any, for the dumped job onto the disk
	channel, preceded and followed by JUMPA instructions
	containing the starting address.  When this is done,
	the resulting file can be loaded and run as a program
	under DDT.
	See the LOAD symbolic system call.

Errors:

 14	BAD CHANNEL NUMBER
 31	CAN'T MODIFY JOB
	Can't dump the PDP-6 job.
 34	WRONG TYPE DEVICE
	First argument was some oddball channel, or
	second argument was not a disk output channel number.
 35	NO SUCH JOB

PGWRIT:	Cause page to be written to disk

	arg 1	(Optional)  A <JOB>
	arg 2	Virtual page number within that job (a number from 0 to 377).
	control bits:
	1.1	1 => don't wait for the page to finish getting written out,
		     return immediately.  Issue the call again with this bit 0
		     if you later want to wait for it to get written out.
	1.2	1 => unlock the page.
		0 => if the page is locked, swap it out anyway, but when it
		     next gets swapped in again it will be locked again.

	If there is only one argument, it is arg 2.  The <JOB> is
	assumed to be the job issuing the call.

	The disk copy of the specified page is brought up to date;
	if the in-core copy has been modified by the specified <JOB>
	the page is written out.  The PGDUMP call does not return until
	the disk has finished recording the page.

	This is useful when pages of a file have been mapped into
	the user's address space.

	If the page cannot be swapped out because no disk space is available,
	or some job that is using it cannot be pclsr'ed, it waits a while
	and tries again.  It does not return.

	This call used to be called PGDUMP, but the name was
	changed to avoid confusion with PDUMP.

Errors:

 12	MODE NOT AVAILABLE
	Page is absolute or tied down by exec pages.
 14	BAD CHANNEL NUMBER
	The <JOB> argument is invalid.
 31	CAN'T MODIFY JOB
	Executing job doesn't have modification rights to the job
	specified by argument 1.
 32	CAN'T GET THAT ACCESS TO PAGE
	The page number in argument 2 is not between 0 and 377; or the
	job does not have a page at that position in its address space.
 34	WRONG TYPE DEVICE
	The <JOB> specifies the pdp-6, which does not have paging.
 35	NO SUCH JOB
	The <JOB> argument specified a non-existent job.

PKTIOT:	transfer one Chaosnet packet			<MOON;CHAORD>
	arg 1 - channel number
	arg 2 - address of a 126.-word block.

	Always transfers exactly one packet.
	The format of the 126.-word block is:
			 16		  16	      4
		-----------------------------------------
		| opcode | unused | fc |   nbytes   | 0 |
		-----------------------------------------
		|destination host |destination index| 0 |
		-----------------------------------------
		|   source host   |   source index  | 0 |
		-----------------------------------------
		|    packet #     |  ack packet #   | 0 |
		-----------------------------------------
		| data1  |  data2  ...
	
		                            ... data487 |
		-----------------------------------------

	For details of how to use these packets, see the Chaosnet
	protocol documentation.

RAUTH:	read a file's author.

	arg 1	Number of a channel open on the DSK device,
		or a <JOBDEV>.

	val 1	Sixbit name of the file's author (the last
		person to write on the file.)

RCHST:	read channel status.
	Note:  This system call is obsolete.  Use the RFNAME,
		RFPNTR, or WHYINT system call to obtain the
		information you want.

	arg 1	channel number

	val 1	The fullword sixbit name of the device open
		on the specified channel, or 0 if the channel
		is closed.
	val 2	The first file name of the file open on the
		channel, or 0 if filenames mean nothing on
		the device which is open.
	val 3	The second file name, or 0.
	val 4	The directory name of the open file, assuming
		that "directory name" has some meaning for the
		device which is in use; otherwise, 0.
	val 5	The channel's access pointer, if it is randomly
		accessible; otherwise, -1.
	val 6...additional device-dependent results

	The values may not be the same as the filenames, etc.
	that were used to open the channel.  The results of
	this call are quite device-dependent.
	in the open-mode returned by RCHST.

	The following devices return the access pointer as -1
	and the filenames and directory name as 0:
	NUL	LPT	NVD	PLT	PTP	IMX	OMX
	PTR	DIS	IDS	COD	TVC	TAB	MT0
	MSP	STK

	The data stored by other specific devices is described below.
	If a specific numbered value is not mentioned, then the default
	is returned by that device - 0 for values 2, 3 and 4;
	-1, for value 5.

	DIRECTORIES
	val 1	The device name
	val 2	sixbit/.FILE./
	val 3	sixbit/(DIR)/
	val 4	the directory name, on a multi-directory device

	DISK MFD's
	val 1	sixbit/DSK/
	val 2	sixbit/M.F.D./
	val 3	sixbit/(FILE)/

	ERR
	val 1	'ERR,,
	val 2	3
	val 3	a word in the format of a channel status word,
		which has the error codes that the ERR device
		is describing.

	Closed channel:
	vals 1-4 0
	val 5	-1

	TTY (as a console)
	val 1	'TTY,,

	TTY (as a device)
	val 1	'Tnm,,

	STY
	val 1	'Snm,,

	USR (including PDP-6)
	val 1	'USR,,
	val 2	Uname of job.
	val 3	Jname of job.
	val 4	0
	val 5	Access pointer.

	UTn (micro-tape)
	val 1	'UTn,,
	val 2	File name 1.
	val 3	File name 2.
	val 4	Uname assigned to, or zero if none (see the .ASSIGN uuo).

	CLI, CLO, CLA, CLU
	val 1	'CLO,,
	val 2	File name 1.
	val 3	File name 2.
	val 4	Sname.

	DSK
	val 1	'DSK,,
	val 2	File name 1.
	val 3	File name 2.
	val 4	Directory name.
	val 5	Access pointer.  May be a byte pointer if character mode.

	BOJ
	val 1	'BOJ,,
	val 2	Uname of creator (zero if he has gone away).
	val 3	Jname of creator (zero if he has gone away).

	JOB
	vals 1-n	Whatever the job device decides to return.
		See the JOBSTS and JOBRET symbolic system calls.
		Note that the job sets the results for vals 1-4 once
		using the JOBSTS call, and only the values 5, 6, ...
		are taken from the JOBRET that responds to the RCHST.

	NET
	val 1	'NET,,
	val 2	Local socket number.
	val 3	Foreign socket number.
	val 4	4.9	Network interrupt (INR/INS) received.
		2.9-2.1	Byte size.
		1.9-1.1	Foreign host number.
	val 5	4.9-3.1	Time until IMP goes down, in thirtieths
			of a second.
			0 => IMP down.
			-1 => IMP doesn't plan to go down.
		2.9-1.1	Socket state:
			0	%NSCLS	CLS received.  val 6 gives reason.
			1	%NSLSN	Listening for RFC.
			2	%NSRFC	RFC received while listening.
			3	%NSRCL	CLS received while in RFC received state.
			4	%NSRFS	RFC sent.
			5	%NSOPN	Connection open.
			6	%NSRFN	RFNM wait on write link.
			7	%NSCLW	CLS sent.  Waiting for matching CLS.
			10	%NSCLI	CLS received, but input still available.
			11	%NSINP	Input available.
	val 7	Reason for closing:
		0	%NCNTO	Never open.
		1	%NCUSR	Closed by user.
		2	%NCFRN	Closed by foreign host.
		3	%NCRST	Foreign host Reset itself.
		4	%NCDED	Foreign host dead.
		5	%NCINC	Incomplete transmission.
		6	%NCBYT	Byte size mismatch.
		7	%NCNCP	Local NCP went down.
		10	%NCRFS	Connection refused.
	val 8	Input: number of bits available.
		Output: number of bits of buffer free.

	TCP: (Internet TCP)
	val 1	SIXBIT /TCP/
	val 2	Local port #
	val 3	Foreign port #
	val 4	Foreign net address (HOSTS3 format)

	Chaosnet:
	val 1 	SIXBIT /CHAOS/
	val 2	Local index
	val 3	Foreign index
	val 4	Foreign net address (HOSTS3 format)

	SPY:
	val 1	SIXBIT /SPY/
	val 2	TTY number

	DIRHNG:
	val 1	SIXBIT /DIRHNG/
	val 2	0
	val 3	0
	val 4	Directory name

	LOCK:
	val 1	SIXBIT /LOCK/
	val 2	Lock name

	UBI:
	val 1	SIXBIT /UBI/
	val 2	<Unibus adaptor number>,,<Interrupt address>

RCPOS:	read cursor position					(ITS TTY)

	arg 1	<TTY> or <JOBDEV>
	val 1	Main program area cursor position.
	val 2	Echo area cursor position.

	Each cursor position is returned as a word with the
	vertical position in the left half and the horizontal
	position in the right half.
	See the SCML symbolic system call for setting up an
	echo area.

RDDMST:	read demon status

	arg 1	Either the sixbit name or the user index
		of a demon job.
	val 1	If arg 1 was the sixbit name, the user index;
		if it was the user index, the sixbit name.
	val 2	4.9-3.1	If non-zero, the time in two-minute ticks
			between automatic signals for the demon.
		2.9-1.1	Number of requests pending for the demon.
	val 3	Time in two-minute ticks until the next automatic
		signal will occur (meaningful only if arg 2 bits
		4.9-3.1 not zero).

	See also the DEMSIG and STDMST symbolic system calls,
	and the .DEMON uuo.

RDMPBT:	read dump bit

	arg 1	Disk channel number or <JOBDEV>
	val 1	A word, all zero, except with the dump check
		bit for the file in bit 1.1.

	The dump check bit is used by the magtape file backup
	system to keep track of which files have been backed
	up on magtape.  This bit therefore should not be
	twiddled light-heartedly.  The "!" you sometimes see
	in front of a date in a disk file directory is present
	iff the dump check bit for the file is zero.

	See also the .DMPCH uuo and the SDMPBT
	symbolic system call.

RELOAD:	reload top-level job					(ITS DETACH)

	No arguments or values.  Note, however, that an
	argument of some kind must be supplied so that the
	SETZ bit may be present to terminate the set of
	arguments.

	The executing job must be the top level job of
	a non-disowned job tree.

	Most of the job's system variables are initialized;
	the file  SYS:ATSIGN <jname>  is then loaded and
	started up, where <jname> is the jname of the job
	(see the .JNAME user variable).
	For example, if the jname of the job is HACTRN,
	then the file  SYS:ATSIGN HACTRN  (which is DDT)
	is loaded and started.  This is how DDT performs
	the U. command.  Note that the translation lists for
	the job are not cleared before this loading; thus one
	can translate the file names  SYS:ATSIGN <jname>  and
	cause a different file to be loaded.

	More specifically, the way the job is loaded is that
	the following program is put into the job's ac's
	and started at location 0:

	0/	JFCL		;unused word
	1/	.OPEN 1,7	;open up file SYS:ATSIGN <jname>
	2/	 JRST 0		;retry on failure
	3/	.CALL 12	;load up program
	4/	 .LOGOUT	;logout if loading fails
	5/	.IOT 1,2	;read in starting address
	6/	JRST (2)	;go there
	7/	4,,'SYS		;SYS device, image unit input
	10/	SIXBIT \ATSIGN\
	11/	0		;<jname> is placed here
	12/	SETZ
	13/	SIXBIT \LOAD\	;load file into job
	14/	16		;job specification
	15/	SETZ 17		;channel number
	16/	-1		;job is me
	17/	1		;channel number is 1

	Typically the first thing a job used as a top level
	(such as DDT) does is close channel 1.  Now you know
	why.  The LOAD system call leaves channel 1 open
	so that the start address and symbol table can be
	read in.

Errors:

 40	NOT TOP LEVEL

RENAME:	rename a file

  Either
	arg 1	Byte pointer to ASCIZ string specifying the old name,
		or AOBJN pointer to block of byte pointers,
	arg 2	Byte pointer to ASCIZ string specifying the new name,
		or AOBJN pointer to block of byte pointers,

  Or
	arg 1	Left-justified device name.
	arg 2	Old file name 1.
	arg 3	Old file name 2.
	arg 4	Sname.  If zero, the executing job's sname
		is used (see the .SNAM user variable).
	arg 5	New file name 1.
	arg 6	New file name 2.

	The file specified by the first four names is renamed
	according to the last two.  It is not possible to
	"rename" a file into a new directory or device.
	Attempting to rename to an already existing file will
	fail with error code 13 (File already exists).

	The old file names are subject to file name translation.
	See the TRANAD and TRANDL symbolic system calls.

	See the SOPEN symbolic system call for how the byte or AOBJN
	pointer argument should be formatted and how the string(s) are
	parsed.

	See also the .FDELE uuo.

RENMWO:	rename while open

  Either
	arg 1	Channel number of channel with file open on it.
	arg 2	Byte pointer to ASCIZ string specifying the new name,
		or AOBJN pointer to block of byte pointers,

  Or
	arg 1	Channel number of channel with file open on it.
	arg 2	New file name 1.
	arg 3	New file name 2.

	The file open on the specified channel is renamed
	according to the specified names.

	Ordinarily this is used in connection with output.  Often
	one opens a file for output with artificial file names, for
	instance _TECO_ OUTPUT, instead of the real desired names.
	This is so that if something should happen, causing the
	channel to be closed before writing to the file is finished,
	any previous file with the desired names will not be
	replaced by the new, incomplete file.  When all the
	necessary data have been written into the file,
	one RENMWO's to the desired names and then CLOSE's.
	This causes the new, good file to replace the old one of
	the same names.  (By convention, file names beginning
	with "_" are artificial names reserved for this purpose.
	Ordinarily a program FOO will use the first file name
	_FOO_ and a second file name indicating the nature of
	the output file; thus _FOO_ OUTPUT, _FOO_ CRFOUT,
	_FOO_ LSTOUT, etc.)

	See the SOPEN symbolic system call for how the byte or AOBJN
	pointer argument should be formatted and how the string(s) are
	parsed.

	See also the .FDELE uuo.

REOWN:	re-own a disowned job

	arg 1	channel #

	The foreign job open on the specified channel is made
	an inferior of the current job.  The sub-tree of that job
	becomes part of the sub-tree of the current job.  The UNAMEs
	of the specified job and all its inferiors are changed to
	the UNAME of the current job.  The JNAMEs are altered where
	necessary to keep all UNAME-JNAME pairs in the system unique.

Errors:

5	DIRECTORY FULL
	The current job already has the maximum number of inferiors (8).
31	CAN'T MODIFY JOB
	The specified job is not top-level, or not disowned.
34	WRONG TYPE DEVICE
	Specified channel is not open on the USR device,
	or the job is already an inferior of the current job.
42	JOB GONE OR GOING AWAY
	The specified job is in the process of logging out.

RESET:	reset input/output channel

	arg 1	Channel number.

	See also the .RESET uuo.

	This is a device-dependent operation.  In general
	the intent is to reset the state of the device to
	some standard setting.

	For TTY input:
	If the particular TTY involved is the console,
	wait until the executing job possesses the tty.
	(If the %TBINT bit is set for the job, give a
	word 1 interrupt on bit 4.2 if the job doesn't
	have the tty.)  If the TTY is in communicate mode,
	wait until it leaves communicate mode.
	All characters pending in the input buffer are
	thrown away.  Any interrupt characters which have
	not yet interrupted will not interrupt.  Any echoing
	characters which have not yet echoed will not echo.

	For TTY output:
	If the particular TTY involved is the console,
	wait until the executing job possesses the tty.
	(If the %TBINT bit is set for the job, give a
	word 1 interrupt on bit 4.2 if the job doesn't
	have the tty.)  If the TTY is in communicate mode,
	wait until it leaves communicate mode.
	Any characters in the output buffer are thrown away
	iff the %TPORS bit is 1.  If the channel was hung in
	a **MORE**, the **MORE** is forgotten.  If the job
	was interrupted in the middle of ^P code typeout,
	the ^P is forgotten.  Other oddball state bits are
	also reset to their normal state.
	If the intelligent terminal protocol is in use on
	the tty, then a %TDORS code will be sent to it,
	and a reply stating the terminal's actual cursor
	position awaited before any more output is allowed.
	See the description of this protocol in the TTY documentation.

	For the USR device:
	This is like doing a .UCLOSE and then re-opening the
	job, but with less overhead.  All pages of the job
	are flushed, and a single page, page 0, is created
	and cleared.  All resource variables and other variables
	are initialized.  The %TBNOT and %TBDTY bits are set
	in the .TTY variable.  The .SNAM variable is initialized
	to the uname of the job.  The .40ADDR variable is set
	to 40 octal.  The .APRC variable is set to 447 octal.

	For the LPT device:
	The line currently being physically output is terminated
	and output.  All characters pending in the output buffer
	are flushed.  The printer is skipped to a new page.

	For the PLT device:
	All buffered plotter commands are flushed.

	For the PTR device:
	All buffered input characters are flushed.

	For the PTP device:
	All buffered output characters are flushed.

	For the COD device:
	All buffered output characters are flushed.

	For the PDP-6:
	The core of the PDP-6 is cleared.  If it is running,
	this should cause it to loop, executing the zero word
	in location 41.  A routine is then placed in core to
	clear the PI flags, clear the processor flags, release
	all shared devices, clear the accumulators, and finally
	clear itself from core.  If the routine fails to run
	(the PDP-6 is not running), then the routine is cleared
	out of the PDP-6 memory again anyway.

	For the NET device:
	Any pending interrupt (INR or INS) is cleared.

	For TCP channels:
	Currently does nothing.

	For the Chaosnet (channels opened with CHAOSO):
	Does nothing.

	For the STY device:
	An input reset is much like an output reset for the
	tty which is the STY's alter ego; similarly, an output
	reset is much like an input reset for the associated tty.
	One difference is that a STY input reset does not
	reset certain channel-related bits that a tty output
	reset would; on the other hand, it always succeeds in
	flushing characters even if the %TPORS bit is not set.

	For the STK device:
	All buffered input characters are flushed.

RESRDT:	restore file reference date

	arg 1	Disk channel number or <JOBDEV>

	The reference date for the disk file is restored to
	its value prior to the opening of the file.
	Note that control bit 1.4 avoids setting the
	reference date when a disk file is opened.  See
	the OPEN symbolic system call.

	See also the DSKUPD, FILBLK, RQDATE and SRDATE symbolic
	system calls.

RFDATE:	read file creation date

	arg 1	Disk channel number or <JOBDEV>
	val 1	The creation date of the file:
		4.7-4.1	Year (mod 100.).
		3.9-3.6	Month (January = 1).
		3.5-3.1	Day of month.
		2.9-1.1	Time of creation, in half-seconds
			after midnight.

	See also the RQDATE and SFDATE symbolic system calls.

RFNAME:	read name of file channel is open to

	arg 1	<JOB> whose channel should be read. (OPTIONAL)
		If omitted, self is assumed.
	arg 2	channel number
	arg 3	Optional byte pointer to store ASCIZ filename string through.
	arg 4	Optional maximum number of characters to store.

	val 1	The fullword sixbit name of the device open
		on the specified channel, or 0 if the channel
		is closed.
	val 2	The first file name of the file open on the
		channel, or 0 if filenames mean nothing on
		the device which is open.
	val 3	The second file name, or 0.
	val 4	The directory name of the open file, assuming
		that "directory name" has some meaning for the
		device which is in use; otherwise, 0.
	val 5	The mode in which the channel is open.

	The filenames and mode as described by the RFNAME may
	not be the same as those specified in the original open.
	That is because they are intended to be the "real"
	filenames, etc., as opposed to those that were specified.
	In other words, they are supposed to be the canonical
	arguments to specify to attempt to re-open the file.
	For example, the results of filename translation and
	link following will show up in the names returned by
	RFNAME, as opposed to the translated names or the names
	of the link that was followed.  Similarly, if COM or SYS
	is opened, RFNAME will return DSK:COMMON; or DSK:SYS;
	since COM and SYS are equivalent to those disk directories.
	The core link devices CLO, CLU, CLA and CLI
	perform different functions when first opened, but after the
	open they result in indistinguishable channels, and the file
	could be re-opened in any case by specifying CLO with the
	right filenames, so RFNAME will for all four devices return
	the device name CLO.
	Some open-mode bits also have only an initial effect, and
	they too are likely to be missing (or else always present!)
	in the open-mode returned by RFNAME.


	The following devices return the filenames and directory name as 0:
	NUL	LPT	NVD	PLT	PTP	IMX	OMX
	PTR	DIS	IDS	COD	TVC	TAB	MT0
	MSP	STK

	The data stored by other specific devices is described below.
	If a specific numbered value is not mentioned, then the default
	is returned by that device - 0 for values 2, 3 and 4;
	bits 1.1, 1.2, 1.3 with their standard meanings
	for the open-mode (value 5).

	DIRECTORIES
	val 1	The device name
	val 2	sixbit/.FILE./
	val 3	sixbit/(DIR)/
	val 4	the directory name, on a multi-directory device

	DISK MFD's
	val 1	'DSK,,
	val 2	sixbit/M.F.D./
	val 3	sixbit/(FILE)/

	ERR
	val 1	'ERR,,
	val 2	3
	val 3	a word in the format of a channel status word,
		which has the error codes that the ERR device
		is describing.

	Closed channel:
	vals 1-5 0

	TTY (as a console)
	val 1	'TTY,,
	val 5	see TTY as a device

	TTY (as a device)
	val 1	'Tnm,,
	val 5	Bits 1.1 and 1.2 are standard.
		For output channels, all the %TJ... bits
		are returned also as they were in the OPEN.
		For input channels, all the %TI... bits are
		returned as they were specfied in the OPEN.

	STY
	val 1	'Snm,,
	val 5	All the bits of a STY open are returned.

	USR (including PDP-6)
	val 1	'USR,,
	val 2	Uname of job.
	val 3	Jname of job.
	val 4	0
	val 5	bits 1.1 and 1.2 as standard
		bit 1.4 1 if the job is not an inferior
		of the job which has it open.

	UTn (micro-tape)
	val 1	'UTn,,
	val 2	File name 1.
	val 3	File name 2.
	val 4	Uname assigned to, or zero if none (see the .ASSIGN uuo).

	CLI, CLO, CLA, CLU
	val 1	'CLO,,
	val 2	File name 1.
	val 3	File name 2.
	val 4	Sname.

	DSK
	val 1	'DSK,,
	val 2	File name 1.
	val 3	File name 2.
	val 4	Directory name.

	BOJ
	val 1	'BOJ,,
	val 2	Uname of creator (zero if he has gone away).
	val 3	Jname of creator (zero if he has gone away).

	JOB
	vals 1-n	Whatever the job device decides to return.
		See the JOBSTS system call.  Note that the JOB device
		is not specifically consulted when the RFNAME call is
		given; it sets up the file names and open mode once
		and then these values are returned whenever a user
		asks for them with RFNAME.

	NET: (Arpanet NCP)
	Note that val 4 is slightly nonstandard.
	val 1	'NET,,
	val 2	Local socket number.
	val 3	Foreign socket number.
	val 4	4.9	Network interrupt (INR/INS) received.
		2.9-2.1	Byte size.
		1.9-1.1	Foreign host number.

	TCP: (Internet TCP)
	val 1	SIXBIT /TCP/
	val 2	Local port #
	val 3	Foreign port #
	val 4	Foreign net address (HOSTS3 format)

	Chaosnet:
	val 1 	SIXBIT /CHAOS/
	val 2	Local index
	val 3	Foreign index
	val 4	Foreign net address (HOSTS3 format)
	val 5	0 or 1  (i.e. .UAI or .UAO)

	SPY:
	val 1	SIXBIT /SPY/
	val 2	TTY number

	DIRHNG:
	val 1	SIXBIT /DIRHNG/
	val 2	0
	val 3	0
	val 4	Directory name

	LOCK:
	val 1	SIXBIT /LOCK/
	val 2	Lock name

	UBI:
	val 1	SIXBIT /UBI/
	val 2	<Unibus adaptor number>,,<Interrupt address>

RFPNTR:	read channel's random access pointer

	arg 1	channel # (or <JOBDEV>)

	val 1	random access pointer
	val 2	channel byte size.  The acces pointer
		is in terms of bytes of this size.

	The random access pointer is the number of bytes
	into the file at which the next reading or writing
	operation will occur.

	See also the ACCESS system call, the .ACCESS UUO,
	the RCHST system call, and the .RCHST UUO.

Errors:

34	WRONG TYPE DEVICE
	The device open on the specified channel is not random-access.

RQDATE:	read disk format date

	val 1	Current date and time in disk format:
		4.7-4.1	Year (mod 100.).
		3.9-3.6	Month (January = 1).
		3.5-3.1	Day of month.
		2.9-1.1	Time in half-seconds after midnight.
		If date and time are unknown, -1 is returned.
	val 2	Date and time the system came up in disk format.
		If date and time are unknown, -1 is returned.

	See also the DSKUPD, FILBLK, RESRDT, RFDATE, and SFDATE
	symbolic system calls.

RSSIZE:	read screen size					(ITS TTY)

	arg 1	<TTY> or <JOBDEV>
	val 1	Vertical size of screen (huge if printing).
	val 2	Horizontal size of screen (print width).

	See also the CNSGET and CNSSET symbolic system calls.

SAUTH:	set a file's author

	arg 1	The number of a channel open on the DSK
		device, or a <JOBDEV>.

	arg 2	The sixbit name of the file's author.

	Note:  the author is actually stored as a directory
	number, so if the author does not have a directory
	SIXBIT /______/ will be substituted.  Trailing digits
	are deleted in an attempt to find the author's directory.

SCML:	set the number of TTY command lines			(ITS TTY)

	arg 1	<TTY> or <JOBDEV>
	arg 2	Number of command lines (typical value is 4).
		Must be less than the height of the screen.
		If zero, no echo area.

	This causes an echo area to be set up at the bottom
	of the display screen, using the last <n> lines.
	Characters typed in, or characters output in echo
	mode, are output to this area rather than the main area.
	Note that control bit 1.6 in an OPEN symbolic
	system call for TTY input does an implicit SCML
	with a second argument of 3.

SCPOS:	set tty cursor position					(ITS TTY)

	arg 1	<TTY> or <JOBDEV>
	arg 2	vertical position (optional).
	arg 3	horizontal position (optional).
	arg 4	TTOALC word (optional).
	val 1	old vertical position.
	val 2	old horixontal position.
	val 3	old TTOALC word.

	This call tells the system what the main-program-level
	cursor position of the specified tty really is.  It
	does NOT request that the cursor be MOVED there;
	it asserts that the cursor is expected to end up there
	as a result of the characters already IOT'ed.
	This call is necessary only when the system cannot figure
	the resulting cursor position out for itself.
	There are two cases when that happens:

	1) The system does not compute cursor motion when
	super-image output is done.  If the user program, which
	presumably knows how the characters are being used, knows
	that the cursor will be moved by them, it should inform
	the system.  This is necessary even if the user program
	is just trying to save time by generating the internal
	system output buffer codes itself.

	2) When an output reset is done on a tty of type %TNSFW
	(a "software tty"), the system does not know where the
	tty's cursor is physically located.  Since the system
	does not actually interpret the output characters at
	interrupt level, but merely passes them off to the
	tty, it does not know how much the tty had done when
	the output reset happened.  To recover, the system
	sets the LH of the tty's TTOALC word to 0, and sends
	a %TDORS character to the tty.  The tty should respond by
	informing the system of the current cursor position and
	setting the LH of TTOALC to -1.  Physical ttys must
	use the intelligent terminal protocol to do that,
	but STY users may do it with SCPOS.

SDMPBT:	set dump bit

	arg 1	Disk channel number or <JOBDEV>
	arg 2	A word with the new value for the dump check
		bit in bit 1.1.

	The dump check bit is used by the magtape file backup
	system to keep track of which files have been backed
	up on magtape.  This bit therefore should not be
	twiddled light-heartedly.  The "!" you sometimes see
	in front of a date in a disk file directory is present
	iff the dump check bit for the file is zero.

	See also the .DMPCH uuo and the RDMPBT
	symbolic system call.

SETIOC:	set input/output channel error

	This symbolic system call is ARCHAIC and OBSOLETE.
	It is documented here for historical purposes only.
	Its use in new programs is to be avoided.
	Its function has been superseded by the JOBIOC
	symbolic system call.

	arg 1	BOJ channel number or <JOBDEV>
	arg 2	IOC error code.

	This is used by JOB devices to cause the calling job
	to receive a word 1 IOC interrupt.  This interrupt
	will be given when the calling job next attempts
	an IOT operation.  The .BCHN variable for that job
	will be set to the channel it has the JOB device 
	pen on, and bits 4.1-4.5 of the corresponding
	.IOS word are set to the specified IOC error code.
	See also the JOBINT symbolic system call.

	Valid IOC error codes are as follows:
	  1	ILLEGAL HARDWARE OPERATION ATTEMPTED
	  2	ATTEMPTED RANDOM ACCESS TO ADDRESS BEYOND END OF FILE
	  3	NON-RECOVERABLE DATA ERROR
	  4	NON-EXISTENT SUB-DEVICE
	  5	OVER IOPOP
	  6	OVER IOPUSH
	  7	USR OP CHNL DOES NOT HAVE USR OPEN
	 10	CHNL NOT OPEN
	 11	DEVICE FULL (can also mean a directory is full)
	 12	CHNL IN ILLEGAL MODE ON IOT
	 13	ILLEGAL CHR AFTER CNTRL P ON TTY DISPLAY
	 14	DIRECTORY FULL
	 15	DIRECTORY'S ALLOCATION EXHAUSTED

Errors:

 33	MEANINGLESS ARGS
	Second argument is not a valid IOC error code.
 34	WRONG TYPE DEVICE
	First argument is not a BOJ channel number.
 41	OTHER END OF PIPELINE GONE OR NOT OPEN

SFDATE:	set file creation date

	arg 1	Disk channel number or <JOBDEV>
	arg 2	New creation date and time in disk format:
		4.7-4.1	Year (mod 100.).
		3.9-3.6	Month (January = 1).
		3.5-3.1	Day of month.
		2.9-1.1	Time of creation, in half-seconds
			after midnight.

	See also the DSKUPD, FILBLK, RFDATE, RQDATE and SRDATE
	symbolic system calls.

SIOT:	byte-string in/out transfer

	cbits	Same as for IOT symbolic system call (q.v.).
	arg 1	I/O channel number.
	arg 2	Byte pointer to string to transfer
		(must not be indexed or indirect).
	arg 3	Count of bytes to be transferred.
	arg 4	(Optional) device-independent special mode bits.

	The second and third arguments are updated as the
	transfer proceeds.  If an end of file condition occurs
	or the job is interrupted out of the system call, they
	may not be fully counted out.

	SIOT is notably efficient for STY input and TTY superimage
	output - much faster than block mode.  For details of Chaosnet
	SIOT, see the description of IOT.

	Supposedly some esoteric devices don't support this mode of
	I/O transfer, but I can't think of any.  Also, it is alleged
	that on some devices, SIOT is not yet as efficient as block
	mode.

Errors:

 12	MODE NOT AVAILABLE
	The device open on this channel doesn't support SIOT.
 14	BAD CHANNEL NUMBER
 33	MEANINGLESS ARGS
	The second or third argument was immediate.

SOPEN: open file, using strings to specify the filename

	arg 1	mode bits,,channel number
	arg 2	byte pointer to ASCIZ filename string,
		 or AOBJN pointer to a block of byte pointers
		 to strings to be concatenated.

If the second argument's left half is between -63. and -1, then the
argument is treated as an AOBJN pointer to a block of byte pointers to
ASCIZ strings.  Those ASCIZ strings are effectively concatenated for
parsing.  Otherwise, the second argument is treated as one byte
pointer.  0 may be used as the left half of a byte pointer, and is an
abbreviation for 440700.

The combined string is parsed using the ordinary ITS filename syntax, with
colon indicating a device name, semicolon indicating a directory name, and
space separating filenames.  ^Q is used for quoting colon, semicolon,
space, ^Q and ^@ (which would otherwise terminate the string); it cannot
hurt to quote other characters with ^Q.  SOPEN defaults the device to
"DSK", the second filename to ">", and the directory to the executing job's
current sname.

Multiple devices, directories and names may be significant with some job
devices, and perhaps with disk files as well at some time in the future.

Once the string has been parsed into filenames, operation proceeds as
for the OPEN symbolic system call, which see.

SOPEN appears to a job device handler just like any other OPEN, except
that the original second argument byte or AOBJN pointer is available
as one of the values of the JOBCAL symbolic system call (which see).
For an ordinary OPEN, that value from JOBCAL is zero.

SRDATE:	set file reference date

	arg 1	Disk channel number or <JOBDEV>
	arg 2	New reference date in disk format:
		4.7-4.1	Year (mod 100.).
		3.9-3.6	Month (January = 1).
		3.5-3.1	Day of month.

	See also the DSKUPD, FILBLK, RESRDT, and RQDATE
	symbolic system calls.

SREAPB:	set the do not reap bit

	arg 1	Disk channel or <JOBDEV>
	arg 2	0 for the normal case.
		1 to request the grim file reaper to
		leave this file alone.

	The do not reap bit of the file open on the channel
	is set.  The G*** F*** R**P** doesn't
	respect this bit yet.

	The bit can be read using the FILBLK system call.
	It is UNREAP in the FSDEFS insert file.

SSERVE:	set server job

	arg 1	<JOB>	Client job  (OPTIONAL)
		If omitted, self is assumed.
	arg 2	<JOB>	Server job

	The .SERVER variable of the client job is modified to point to the
	server job.  See the description of .SERVER in .INFO.;ITS USETS.
	This system call permits .SERVER to be updated without trafficking
	in user indices.

Errors:

 34	WRONG TYPE DEVICE
	Neither the client nor the server can be the PDP6
 31	CAN'T MODIFY JOB
	Executing job must be able to modify the client job.

SSTATU:	get various system status variables

	val 1	If non-negative, the time (in thirtieths of a
		second) until the system will go down.
		-1 if the system does not intend to go down.
		-2 if the system is already down (can happen
		in a job with %OPLIV set).
		Obtained from the ITS variable SHUTDN.
		See the .DIETIME, .SHUTDN, and .REVIVE uuos.
	val 2	Non-zero if the system is being debugged.
		This state causes the message
			XX ITS ### BEING DEBUGGED
		to appear on free consoles instead of the
			XX ITS ### IN OPERATION
		message usually seen when the system comes up.
		If negative, the system is officially down;
		^Z is accepted only from tty 0 (the terminal
		physically next to the PDP-10 console) or from
		the tty whose number is the absolute value of
		the contents of this quantity.  A ^Z is also
		accepted from a tty associated with a STY;
		this is so that STY devices may be debugged!
		It is the responsibility of the STELNT server
		to examine this quantity and keep network users
		from logging in when the system is being debugged.
		Obtained from the ITS variable SYSDBG.
	val 3	Number of users on the system.  This is a
		count of logged-in, console-controlled job
		trees in the system.  This variable is
		incremented whenever a user logs in from a
		console, and decremented whenever a console-
		controlled tree is detached, gunned, or logged out.
		This is the ITS variable SUSRS.
	val 4	Sum of parity and nxm memory errors during this
		incarnation of the system.  This is the sum of
		the ITS variables PARERR and NXMERR.
	val 5	Time the system has been up, in thirtieths of
		a second.  This is the ITS variable TIME.
		See the .RDTIME uuo.
	val 6	The left-justified name of the machine, i.e. one of:
			SIXBIT \AI\	;A.I. Lab KS-10
			SIXBIT \ML\	;Mathlab KS-10
			SIXBIT \MC\	;Mail Computer KS-10
			SIXBIT \MD\	;Mostly Development KS-10
			SIXBIT \MX\	;Macsyma Consortium KL-10
			SIXBIT \SI\	;Stacken ITS KS-10
			SIXBIT \PM\	;PandaMonium KS-10
			SIXBIT \FU\	;Australian KS-10
			SIXBIT \DM\	;Dynamic Modeling KA-10 (R.I.P.)
			SIXBIT \MLKA\	;Mathlab KA-10 (R.I.P.)
			SIXBIT \AIKA\	;A.I. Lab KA-10 (R.I.P.?)
		This is the name which appears for XX in such
		messages as
			XX ITS ### IN OPERATION
		and which serves as a device name for that
		machine's disks (i.e. the ML device is the
		DSK device of the ML (Mathlab) machine).
		If more ITS machines come into existence,
		naturally more machine names will be invented.
	val 7	The system version number, in sixbit.  This is
		the ### in such messages as above.
	val 8	The number of free job slots.

	DDT uses much of this information to print out its
	greeting to you:
	If value 2 is non-zero DDT prints out
		ITS BEING DEBUGGED!
	If value 1 is non-negative DDT prints out
		XX ITS GOING DOWN IN 1:23
	if e.g. ITS were going down in 1 minute, 23 seconds.
	(DDT also prints the contents of the file SYS:DOWN MAIL
	if that file exists.)
	Value 3 is used to print out the number of users as
		23. LUSERS
	(if your DDT has not logged in itself, it increments
	this value so as to count you also).
	Values 4 and 5 are used to compute the number of memory
	errors per hour, printed as:
		MEM ERRS .034142/HOUR
	The DDT command :SSTATU will print out all
	this information.

STATUS:	get input/output status word

	arg 1	Channel number.
	val 1	Status word for specified channel.

	This call returns a word describing the state of
	the specified channel:
	4.9-4.6	Always zero.  See the .IOPUSH and .IOPOP
		uuo's, and the .IOP and .IOS user variables.
	4.5-4.1	If non-zero, the number of a non-display
		input/output error (see table below).
	3.9-3.7	If non-zero, the number of an interpreted
		display input/output error (see table below).
	3.6-3.1	If non-zero, the number of a standard error.
		These are the same as the error codes returned
		by failing .CALL's.
	2.9-2.3	Device dependent (see below).
	2.2	Buffering capacity empty.
	2.1	Buffering capacity full.
	1.9-1.7	Mode in which device was opened.
		1.9	0 = ascii, 1 = image.
		1.8	0 = unit, 1 = block.
		1.7	0 = input, 1 = output.
	1.6-1.1	ITS internal physical device code.
		 0	TTY	Console input.
		 1	TTY	Printing console output.
		 2	TTY	Display console output.
		 3	LPT	Data Products line printer.
		 4	VID	Vidisector ???
		 5	BAT	Vidisector ???
		 6	PLT	Calcomp plotter.
		 7	PTP	Paper tape punch.
		10	IMX	Input multiplexor.
		11	OMX	Output multiplexor.
		12	PTR	Paper tape reader.
		13	DIS	DEC 340 display, ascii output.
		14	IDS	Interpreted 340 display.	???
		15	MTn	Magnetic tape.
		16	COD	Morse code device.
		17	TAB	Tablet.	???
		21	NUL	Source of zeroes, or output sink.
		22	JOB	Job device.
		23	BOJ	Inverse of JOB.
		24	SPY	Spy on another console.
		25	STY 	Pseudo-teletype.
		26	NET	ARPAnet (NCP).
		27	LPT	Vogue line printer (yech!)
		30	STK	Stanford keyboard.
		31	MSP	(DM) Interprocess message protocol.
		32	CHAOS	CHAOS net.
		33	TCP	TCP Internet.
		34	TRAP	Trap "device"
		35	IPQ	Internet IP Queue.
		36	UBI	KS10 Unibus interrupt
		41	UTn	Microtape (DECtape).
		43	DSK	2311 disk drives or equivalent.
		60	USR	A not immediately inferior procedure.
		61	USR	An immediately inferior procedure.
		62	CLx	Various core link devices (CLA, CLI, CLO, CLU)
		63	---	File directory or ERR device.
		64	USR	The PDP-6.
		65	DIRHNG	Directory hang "device"
		66	LOCK	Lock "device"

	Device dependent bits for TTY input:
	2.9	Local tty.
	2.8	Next to the 340 or a 340 slave.
	2.5	Chars pending which have been .ITYIC'ed but not IOT'ed.
	2.4	The job possesses the tty.

	Device dependent bits for TTY output:
	2.4	The job possesses the tty.

	Device dependent bits for Data Products LPT:
	2.9-2.3	Current column (left margin = 0).

	Device dependent bits for MTn (macro-tape):
	2.9	Chunk, write EOR after each IOT (should be block) on output,
			don't ignore them on input.   See magtap info.
	2.8	0 => odd parity, 1 => even parity.
	2.7-2.6	Density: 00 => 800, 01 => 200, 10 => 556.
		Apparently 11 => IBM 9 track 800 bpi??
	2.5	0 => 7 track, 1 => 9 track.
	2.4	End of tape.
	2.3	Read compare error.

	Device dependent bits for NET:
	2.9-2.4	Socket state:
		0	%NSCLS	CLS received or net down.  Connection closed.
		1	%NSLSN	Listening for RFC.
		2	%NSRFC	RFC received while listening.
		3	%NSRCL	CLS received while in state 2.
		4	%NSRFS	RFC sent.
		5	%NSOPN	Connection open.
		6	%NSRFN	RFNM wait on write link.
		7	%NSCLW	CLS sent; waiting for matching CLS.
		10	%NSCLI	CLS received but input still available.
		11	%NSINP	Input available.

	Device dependent bits for TCP:
	2.9-2.4 Connection state - see WHYINT call for state codes.

	CHAOSnet provides no device dependent bits.

	A STATUS word can be supplied to the ERR
	device to obtain corresponding error message, if any.

	See also the JOBSTS symbolic system call, the .STATUS uuo,
	and the .IOS user variable.

STDMST:	set demon status

	arg 1	Either the sixbit name or the user index
		of a demon job.
	arg 2	If negative, flush all requests for the specified demon.
		Otherwise:
		4.9-3.1	If non-zero, the time in two-minute ticks
			between automatic signals for the demon.
		2.9-1.1	Number of requests pending for the demon.
	arg 3	Time in two-minute ticks until the next automatic
		signal will occur (meaningful only if arg 2 bits
		4.9-3.1 not zero).

	See also the DEMSIG and RDDMST symbolic system calls,
	and the .DEMON uuo.

STLGET:	get information from Server Telnet

	arg 1	a <TTY>

	val 1	XJNAME of server telnet
	val 2	TRMNAM of server telnet
		This is the sixbit name of the host connected to.
	val 3	SNAME of server telnet
	val 4   In LH: STY status bits
		In RH: index of telnet server job which owns the STY.

	This call can be used to find out where in the network
	a TTY really is.

	The STY status bits are from the STYSTS table in ITS.
	Some of the more interesting ones include:
	%SSNET==4000	;4.3 = 1 => THIS STY CONNECTED TO SOME NET SOCKETS.
	%SSCHA==2000	;4.2 = 0 FOR ARPANET, 1 FOR CHAOS NET
	%SSTCP==1000	;4.1 = 1 for TCP internet (%SSCHA must be 0)

Errors:

34	WRONG TYPE DEVICE
	Specified TTY is not controlled by a server telnet.

STYGET:	get information about STY

	arg 1	<TTY>  (need not be associated with a STY)
	val 1	STY status word:
		4.9	%SSHNG	Don't hang on input IOT.
		4.8	%SSUSE	STY is in use.
		4.7	%SSINT	Have given interrupt on STY output channels.
		4.6	%SSONT	Have given interrupt on STY input channels.
		4.5	%SSOHG	Don't hang on output IOT.
		4.4	%SSORS	Give a %TDORS whenever an output RESET is
				done on the controlled tty, regardless
				of whether the tty is a software tty.
		2.9-1.1	User index of job which owns the STY.
		Zero if STY is not in use, or if TTY is not
		associated with a STY.
	val 2	User index of job which owns the TTY, either as a device
		or as a currently possessed console; or -1 if TTY is free.
	val 3	-1 if the TTY is not a console or is free.  Otherwise,
		2.9-1.1 is the user index of the top-level job of the
		job tree controlled by the TTY.
		4.8 = 1 if that job is in the process of logging out.
		4.7 = 1 if that job is logged in.

	val 4	4.9	Owner of TTY is in a TTY output wait on the TTY.
		1.1	Owner of TTY is in a TTY input wait on the TTY.
		These bits probably don't work very well.
	val 5	4.9	TTY input available.
		4.8	TTY output buffer has room.
	val 6	The tty's TTYSTA word.
		4.9	%TACFM	TTY does not need a console free message
				eventually (hasn't been in use since
				the last one).
		4.8	%TAC.Z  TTY is being ^Z'd.  Shouldn't be on with
				%TACFM.  If %TACFM and %TAC.Z are both 0,
				the tty is being freed and a console free
				message is immanent.
		4.7	%TANJS	This ^Z is being flushed because no job
				slots are available.  If set, %TAC.Z
				will be 1 and %TACFM will be 0.

	This symbolic system call originally was intended to return
	STY information, but now returns useful data concerning any TTY.

STYNET:	Connect a STY to a pair of Network connections.

	arg 1	Sty channel (either direction).
	arg 2	-1 to disconnect the STY from its network channels
		(in which case args 3 and 4 are unnecessary),
		or Net input channel (to connect STY output to).
		This may be a NCP, TCP, or CHAOS channel.
	arg 3	Net output channel (to connect STY input to).
	arg 4	Characters to send out on net
		when an output .RESET is done on the STY's TTY.
		Up to 3 8-bit characters, left-justified.

	It is possible with this call to connect a STY to a pair
	of network channels, one open for input, and one open for output.
	When the direct connection is established, anything received by
	the net input socket will be fed automatically to the
	STY, and any type-out that the STY receives from its TTY will be
	fed automatically to the net output channel.  The transfer of
	data is handled by the system at clock level, eliminating
	the need for the program to wake up at each character.

	Only one input and one output net channel can be connected to
	a STY, and only one STY can be connected to any net channel.
	Both sides of a STY are connected and disconnected at once.
	A job can connect a STY if it has the STY open in either direction
	(but it will generally want to have both directions open).

	Once established, the direct connection will last until
	broken explicitly by the user, or until an escape condition
	is detected by the system.  Escape conditions include receipt
	of a TELNET control character on the net input channel (any
	character with the 200's bit on), and
	either net channel's getting into an abnormal state (other
	than %NSOPN, %NSINP, or %NSCLI) - in general, things which
	the system expects that the user program will want to take
	action on.  

	The connection can be broken explicitly by the user either
	by a STYNET call with arg 2 negative, or by a CLOSE of any
	of the channels involved (this also happens when the job 
	is killed.)  It is an error to IOT on any of the channels
	without breaking the connection first.

	The STYNET call returns immediately, without actually
	transferring any data.  The program can assume that the
	connection is still in effect until it is notified of
	a disconnection by an interrupt on the net input channel.
	While the connection lasts, interrupts on the net channels
	due to arriving data are intercepted by the system, so
	an interrupt implies that the connection has been broken.

	When a %TDORS comes out of the STY, indicating that the TTY's
	output buffer has been cleared, this is indicated to the net
	output channel by means of a network interrupt (NCP only), and the
	string of up to 3 characters specified as the fourth argument
	to the STYNET call.  If TCP, these characters are PUSHed with the
	URGENT bit set.

	If you use STYNET with the official TELNET protocol, you must
	turn on the %TPTEL bit in the STY TTY's TTYOPT variable, to
	cause the sequence CR-LF to be turned into just a CR.

	For the Chaosnet:
	arg 1 - STY channel
	arg 2 - Chaos channel to connect to, or
		-1 to disconnect
	arg 3 - Other Chaos channel (not actually used)
	arg 4 - Output-reset character sequence, up to 3 8-bit
		characters left-justified.

	This works the same as on the Arpanet.  The specified STY
	is connected to or disconnected from a Chaos net channel.
	Data is transferred in and out by the system without the
	need for intervention by the user program.  If an unusual
	condition occurs, the STY is disconnected from the Chaos
	channel and the user is interrupted.  It is illegal to do
	I/O on any of the involved channels while they are connected.

	This call is provided for the benefit of the "Telnet" server.

Errors:

 2	WRONG DIRECTION
	An input net channel was supplied as the third argument, or
	an output channel was supplied as the second argument.
 23	FILE LOCKED
	The STY or one of the network channels is already direct-connected
	to another network channel or another STY.
 41	OTHER END OF PIPELINE GONE OR NOT OPEN
	An attempt was made to disconnect a STY not already connected.

T11MP:	PDP-10 to PDP-11 map

	arg 1	Page number within the user's core.  That page
		must be either non-existent or shared with an
		absolute page.  The user's virtual page is made
		to share with some arbitrarily chosen absolute
		page, which is then made to share with PDP-11 memory
		according to argument 2.
	arg 2	Desired PDP-10 to PDP-11 map word.
		4.9	Valid (must be 1).
		4.8	Write enable.
		4.7-4.3	Unused.
		4.2-3.9	PDP-11 number.  See below.
		3.8-2.2	Relocation (origin of segment in PDP-11
			address space).  <PDP-11 address> = 4*<relocation>.
		2.1-1.1	Protection (number of accessible words - 1).
			<PDP-11 protection> = 4*<protection>.
			If protection=0 then only one 16-bit word
			is accessible.

	The CORBLK symbolic system call may be used in the special
	case of mapping one's TV console video buffer memory.

	The AI KA-10 has a PDP-10 to PDP-11 interface which lets the PDP-10
	programmer directly access the memories of up to eight PDP-11's.
	PDP-10 pages are mapped into segments of variable size in the
	PDP-11's memory.  The PDP-10 to PDP-11 page map is also directly
	addressable in memory (it currently lives in absolute locations
	2,,776000 - 2,,776377).  There are 256. such entries, one for each
	page in the range 2,,0 - 2,,777777, which are the addresses fielded
	by the PDP-10 to PDP-11 interface.  ITS allocates these pages
	and their corresponding map entries randomly as needed.

	When the PDP-10 attempts to access a physical address in the range
	2,,0 to 2,,777777, the interface uses the 776000 bits to index
	the map words.  If the appropriate map word does not have its
	valid bit set, the memory is considered non-existent.  The same
	is true if the reference would violate the protection bounds.
	The reference also fails if it is a write reference and the
	map word does not have the write enable bit set.
	Otherwise, the relocation quantity is added to the 1777 bits,
	and this determines which PDP-11 double-word to access.
	The PDP-11 number determines which PDP-11 to access, of course.
	The PDP-11 double-word corresponds to the high 32. bits of the
	PDP-10 word, as follows:
	PDP-10 BIT	PDP-11 WORD AND BIT
	4.9		0	15
	4.8		0	14
	4.7		0	13
	---		---	---
	3.4		0	01
	3.3		0	00
	3.2		1	15
	3.1		1	14
	---		---	---
	1.6		1	01
	1.5		1	00
	When reading the PDP-11 memory, bits 1.4-1.1 are read as zeros.
	When writing, 1.4=1 means don't change word 0, 1.3=1 means don't
	change word 1, and 1.2-1.1 are ignored.  Split cycles do the right
	thing, so ILDB and IDPB should work correctly.
	Note that accessing consecutive 16.-bit PDP-10 bytes will access
	consecutive PDP-11 words, but accessing consecutive 8-bit PDP-10
	bytes will not access consecutive PDP-11 bytes!  Rather, the PDP-11
	bytes are accessed in the order 1, 0, 3, 2.

	The following PDP11s are currently (4/2/76) attached.

		0	The pdp11 that runs the AI KA-10 TV system.
		1	The pdp11 that runs the AI KA-10 XGP.
		2	The Lisp Machine GT40.
		3	The Chess Machine (not really a pdp11.)
		4	The Logo pdp11/45.
		5	The Micro-Automation pdp11/45.

Errors:

  1	NO SUCH DEVICE
	There is no PDP-11 connected to this PDP-10.
  3	DEVICE NOT READY
	The PDP-11 is not ready.
 33	MEANINGLESS ARGS
	The page number is invalid, or the map word has bit 4.9=0.
 37	NO CORE AVAILABLE
	No map words free.

TCPOPN: open a TCP Internet connection		(TCP;TCPDOC >)

	arg 1 - receive channel number
	arg 2 - transmit channel number
	arg 3 - local port #	(-1 to gensym a unique local port #)
	arg 4 - foreign port #	(-1 for wild port)
	arg 5 - foreign host address (HOSTS3 fmt) (-1 for wild host)
	arg 6 - Retransmission timeout (optional, not yet used)

Control bits:
	- None needed for channels - they are opened as .UAI and .UAO
		automatically (no other modes possible).
	- 7 vs 8 bit ASCII transfers can be determined by user-space byte
		pointer used in SIOT.  System buffers are always 8-bit bytes.
	%NOLSN - Listen mode

	Note a value of -1 for either the foreign port or host will imply
	that the call is a "listen".  Return is always immediate, use NETBLK
	to determine when the channels become open.  For a non-listen call,
	there is an internal ITS timeout, but for listen the state can persist
	forever.

ERRORS:
  6	- No free TCBs or buffers available (system has too many active conns)
  7	- TCP disabled in system.
 11	- Bad local or fgn port #
 13	- Connection already exists with these ports
 14	- Bad channel # arguments.
 33	- Illegal to use same channel for both input/output.

TRANAD:	add a translation entry					(ITS TRANSL)

	cbits	2.9	Atomic translation (do not retranslate).
		2.8	0 => TRNLST, 1 => TRNLS1.
			The TRNLST applies only to the specified job;
			the TRNLS1 applies to the job and its inferiors,
			direct or indirect.
		1.2	Output translation.
		1.1	Input translation.
		Before the control bits are interpreted, the LH
		of arg 1 is XOR'd into them.
	arg 1	RH is a <JOB>.  LH XOR'd into cbits.
	arg 2	AOBJN pointer to a block of "from" names.
	arg 3	AOBJN pointer to a block of "new" names.

	Each AOBJN pointer should point to a block of
	from one to four words.  These are, in order, the
	device, file name 1, file name 2, and sname which
	are to be translated.  All names are left-justified
	within a word.  A zero or omitted word is equivalent
	to *.
	Before creating the translation, a TRANDL is
	performed on the first two arguments to prevent
	duplicate translations.

	Uuos and symbolic system calls affected by translation
	include .FDELE, .OPEN, MLINK, RENAME, and OPEN.

Errors:

  5	DIRECTORY FULL
	No room in system for new translation entry.
 14	BAD CHANNEL NUMBER
 31	CAN'T MODIFY JOB
 33	MEANINGLESS ARGS
 34	WRONG TYPE DEVICE
	Not meaningful to put a translation on the PDP-6.
 35	NO SUCH JOB

TRANCL:	clear translation list	(delete all entries)		(ITS TRANSL)

	cbits	2.8	Clear TRNLS1.
		2.7	Clear TRNLST.
		The TRNLST applies only to the
		specified job;  the TRNLS1 applies
		to the job and its inferiors,
		direct or indirect.
		Before the control bits are interpreted, the LH
		of arg 1 is XOR'd into them.
	arg 1	RH is a <JOB>.  LH XOR'd into cbits.


	Either or both lists may be cleared with a single call.
Errors:

 14	BAD CHANNEL NUMBER
 31	CAN'T MODIFY JOB
 33	MEANINGLESS ARGS
 34	WRONG TYPE DEVICE
	Not meaningful to clear translation lists for PDP-6.
 35	NO SUCH JOB

TRANDL:	delete a translation entry				(ITS TRANSL)

	cbits	2.8	0 means TRNLST, 1 means TRNLS1.
			The TRNLST applies only to the
			specified job;  the TRNLS1 applies
			to the job and its inferiors,
			direct or indirect.
		1.2	Stop translating for output.
		1.1	Stop translating for input.
		Before the control bits are interpreted, the LH
		of arg 1 is XOR'd into them.
	arg 1	RH is a <JOB>.  LH XOR'd into cbits.
	arg 2	An AOBJN pointer to a block of names.

	The AOBJN pointer should point to a block of
	from one to four words.  These are, in order, the
	device, file name 1, file name 2, and sname which
	are no longer to be translated.  All names are
	left-justified within a word.  A zero or omitted
	word is equivalent to *.

Errors:

  4	FILE NOT FOUND
	No such translation entry to delete.
 14	BAD CHANNEL NUMBER
 31	CAN'T MODIFY JOB
 33	MEANINGLESS ARGS
 34	WRONG TYPE DEVICE
	Not meaningful to delete translation entry for PDP-6.
 35	NO SUCH JOB

TRANEX:	examine a translation list				(ITS TRANSL)

	cbits	2.8	0 means TRNLST, 1 means TRNLS1.
			The TRNLST applies only to the
			specified job;  the TRNLS1 applies
			to the job and its inferiors,
			direct or indirect.
		Before the control bits are interpreted, the LH
		of arg 1 is XOR'd into them.
	arg 1	RH is a <JOB>.  LH XOR'd into cbits.
	arg 2	AOBJN pointer to array in core.
	val 1	AOBJN pointer to tail end of array,
		i.e. the part not needed to hold the data.

	The translation list is stored as consecutive
	nine-word blocks of translation information.
	Each block has the following form:
		wd 0	4.9	Atomic translation entry.
			3.2	Output translation.
			3.1	Input translation.
		wd 1	"from" device name.
		wd 2	"from" file name 1.
		wd 3	"from" file name 2.
		wd 4	"from" sname.
		wd 5	"to" device name.
		wd 6	"to" file name 1.
		wd 7	"to" file name 2.
		wd 8	"to" sname.
	A zero word for a "from" name means translate for any
	name in that position; a zero "to" word means don't
	change that name when translating.

Errors:

 14	BAD CHANNEL NUMBER
 33	MEANINGLESS ARGS
 34	WRONG TYPE DEVICE
	Not meaningful to examine translation list for PDP-6.
 35	NO SUCH JOB
 37	NO CORE AVAILABLE
	Supplied array too small to hold data.

TRANS:	translate some file names				(ITS TRANSL)

	cbits	1.1	0 for input, 1 for output.
	arg 1	"from" device name.
	arg 2	"from" file name 1 (defaults to zero).
	arg 3	"from" file name 2 (defaults to zero).
	arg 4	"from" sname (defaults to job's current sname).
	arg 5	mode (XOR'd with control bits; defaults to 0).
	val 1	"to" device name.
	val 2	"to" file name 1.
	val 3	"to" file name 2.
	val 4	"to" sname.

	The given file names are translated by the same rules
	for translation governing the operations of OPEN,
	RENAME, DELETE, and MLINK.  These rules are as follows.

	Translation lists are searched in the order:
		executing job's TRNLST
		executing job's TRNLS1
		executing job's superior's TRNLS1
		that job's superior's TRNLS1
		. . .
		top-level job's TRNLS1
		system job's TRNLS1
	The lists are searched for an entry matching the given "from"
	file names.  A translation entry is said to match if each
	"from" name matches the entry's corresponding name,
	and if the translation entry applies to the mode (input or output).
	A name in turn matches if the entry's name is the same as
	the given name, or if the entry's name is * (matches anything).
	If a match is found, the given file names are replaced by the "to"
	file names in the translation entry, except that in the entry
	a "to" file name of * means don't change the given name;
	the process is then repeated from the beginning unless the
	matching translation entry is atomic.  When this happens, or
	when a full search finds no matching translation entries,
	the translation process is complete.  To prevent endless
	retranslation, it is considered an error to repeat the
	translation process more than eight times.

	When a job is first created its TRNLST and TRNLS1 are null.
	The TRANAD, TRANCL, TRANDL, and TRANEX symbolic system calls
	may be used to examine and modify translation lists.

Errors:

  3	TOO MANY TRANSLATIONS
	No more than eight consecutive translations are permitted.

TRPOPN:	Open trap-device channel

	arg 1	<JOB>
	arg 2	channel number in that job
	arg 3	IOCHNM word (only LH is used)
	arg 4	IOCHST word

	The specified channel of the specified job is made a trap-device
	channel.  Almost any attempt to use it will cause a %PITRP interrupt.
	See documentation of the TRAP: device.

Errors:

13	FILE ALREADY EXISTS
	The specified channel is open.

14	BAD CHANNEL NUMBER
	arg 2 is invalid.

31	CAN'T MODIFY JOB
	The <JOB> is not clobberable.

34	WRONG TYPE DEVICE
	The <JOB> is the pdp-6.

TTYESC: simulate type-in of ^_

	arg 1	<TTY>

	Pretends that the user has just typed in a ^_.
	The next character the user types will be interpreted
	as a ^_ command.

	The intended use of this is for programs which use
	super-image input, so that ^_ does not have its normal
	effect, but which wish to provide an escape convention
	so that the effect of ^_ can be obtained.  When the program
	sees the escape character sequence as input, it should
	do a TTYESC.

Errors:

7	DEVICE NOT READY
	The terminal is already in the middle of a ^_ code
	being typed by the user.

TTYFLS:	flush TTY input

	arg 1	<TTY>
	control bits:
	1.1	0 => cause the last interrupt character .ITYIC'ed
		     to be ignored by .IOT.
		1 => discard all input up to and including the last
		     character .ITYIC'ed.

	This call is normally used by TTY input interrupt handlers.

TTYGET:	read the variables TTYST1, TTYST2, TTYSTS		(ITS TTY)

	arg 1	<TTY> or <JOBDEV>
	val 1	TTYST1 variable.
		This variable contains six groups of six bits.
		Each group is as follows:
		1.6	%TGMPE	Echo at main program level (when IOT'ed).
		1.5	%TGPIE	Echo at interrupt level (when typed).
		1.4	%TGIMG	Echo in image mode.
		1.3	%TGSPC	Special hack: convert lower case to upper.
		1.2	%TGACT	Activation character.
		1.1	%TGINT	Interrupt character.
		The character groups are:
		4.9-4.4		^@-^F ^K ^L ^N-^R ^T-^Z ^\-^_
		4.3-3.7		Upper and lower case letters.
		3.6-3.1		Digits.
		2.9-2.4		! " # $ % & ' , . : ; ? @ \ ` | ~
		2.3-1.7		+ * - / = ^ _
		1.6-1.1		< > ( ) [ ] { }
	val 2	TTYST2 variable.
		Six more groups of six bits:
		4.9-4.4		^G ^S
		4.3-3.7		^I ^J  (tab, linefeed)
		3.6-3.1		altmode  (33)
		2.9-2.4		^M  (carriage return)
		2.3-1.7		rubout  (177)
		1.6-1.1		space, ^H  (backspace)
	val 3	TTYSTS variable.
		4.9	%TSFRE	Free console (not in use).
		4.8	%TSCLE	^L should echo as "^L" (normally
				clears screen on displays).
		4.7	%TSHDX	Same as %TOHDX.  Vestigial.
		4.6	%TSFCO	Use full 12-bit TV char set for output and
				echoing: echo CONTROL as ALPHA, echo META
				as BETA, echo SUPER as EPSILON, and use
				Sail graphics if TOP is set.
		4.5	%TSALT	Do not standardize altmodes.
		4.4	%TSROL	Scroll mode.
		4.3	%TSSAI	Echo and ascii output use SAIL
				character set.
		4.2	%TSACT	Next input IOT shouldn't wait
				for an activation character.
		4.1	%TSNEA	Don't echo in echo area; echo in M.P. Area.
		3.9	%TSINT	Next input character should
				interrupt even if it ordinarily
				would not (%TGINT = 0).
		3.8	%TSMOR	Inhibit **MORE** processing.
		3.7	%TSATY	Set whenever an .ATTY executed by
				some superior returns the tty to
				the job.
		3.4	%TSNOE	Defer echoing.
		3.3	%TSLCZ	Last character typed was ^Z.
				This bit causes .ATTY's to fail.
		3.2	%TSSII	Super-image input.  The special
				actions of ^Z and ^_ are suppressed.
		3.1	%TSCNS	This is a console, not a device.
		2.9-1.1	The user index of the job which controls
			the tty, or -1 if the tty is free.
	val 4	the TTYTYP variable
		See the CNSGET documentation.
	val 5	the TCTYP variable
		See the CNSGET documentation.

	Values 4 and 5 probably should not be depended upon.

	See also the CNSGET, CNSSET, and TTYSET symbolic system calls.

Errors:

  1	NO SUCH DEVICE
	No tty exists with the specified number.
 14	BAD CHANNEL NUMBER
 34	WRONG TYPE DEVICE

TTYSET:	set the variables TTYST1, TTYST2, TTYSTS		(ITS TTY)

	arg 1	<TTY> or <JOBDEV>
	arg 2	TTYST1 variable.  See under TTYGET.
	arg 3	TTYST2 variable.  See under TTYGET.
	arg 4	TTYSTS variable (optional).  See under TTYGET.
		%TSFRE, %TSHDX, %TSLCZ, and %TSCNS may not be altered,
		nor may the RH.

	See also the CNSGET, CNSSET, and TTYGET symbolic system calls.

Errors:

  1	NO SUCH DEVICE
	No tty exists with the specified number.
 14	BAD CHANNEL NUMBER
 34	WRONG TYPE DEVICE

TTYVAR: read or set a variable associated with a TTY.

	arg 1	<TTY> or <JOBDEV>

	In the simplest mode:

	arg 2	the name of a tty variable, in SIXBIT.
	arg 3	(if writing) the new value.

	If arg 3 is not supplied, you are reading, and
	val 1	is the value of the variable.

	In immediate-instruction mode:

	arg 2	the SIXBIT name of a tty variable.
	arg 3	ignored
	arg 4	the instruction

	This mode is detected by the presence of four arguments.

	The specified instruction is executed as if the
	variable was in ac 0.  MOVE can be used to set the
	variable, MOVEM to read it, but you can also use
	TLO to set bits, ADDI to increment, etc.

	In block mode

	arg 2	an AOBJN pointer to a block of pairs of words.

	This mode is detected by bits 4.1-4.9 of arg 2 being all
	ones.

	The first word in each pair is the SIXBIT name of a tty
	variable, and the second word is an instruction to be
	executed as if that variable were in ac 0.  The block pointer
	argument is updated.

	The TTY variables include HEIGHT, WIDTH, ISPEED, OSPEED, TTYOPT,
	TTYTYP, TTYCOM, TCTYP, TTYROL, TTYSMT, and IDLTIM.  See
	.INFO.;ITS TTY for a description of their meanings.

	The instructions allowed in immediate-instruction and
	block modes are:  MOVx, MOVxI, MOVEM, ADD, ADDI, SUB, SUBI,
	all Booleans in normal and immediate modes, and TxZ, TxC,
	and TxO (i.e. all Test instructions that modify and don't
	skip.)

Errors:

 11	ILLEGAL FILE NAME
	Unrecognized tty variable name.
 26	DEVICE WRITE-LOCKED
	Specified variable or specified tty cannot be written.
 33	MEANINGLESS ARGS
	Attempt to store an illegal value in the TCTYP variable,
	or an illegal instruction was specified in immediate-
	instruction or block mode.

TVWHER:	tell where a TV is

	arg 1	<TTY> or <JOBDEV>
	val 1	The keyboard number of the physical
		terminal in use.
		The correspondence between keyboard numbers
		and physical locations is in the file
		SYSENG;TVKBD ROOMS, which is how the NAME
		program gets this information.  If this table
		and that file disagree, that file is correct,
		and please update this table.
		As of February 7, 1977, these correspondences
		were in effect:
		KBD #	ROOM	WHO LIVES THERE
		0	809	Fahlman, Holloway, Knight x7807
		1	810	Lavin, Kuipers, Miller, Bruss x7836 
		2	919	Very Small Data Bases north x6765 
		3	812	Yvonne, Karen x5876 
		4	813	Hewitt x5873 
		5	814	Sussman, McDermott x5874 
		6	808	Freiling, Lozano-Perez, Ullman x5875 
		10	817	Jabari x6218 
		13	819	Goldstein x5879 
		14	820	Minsky x5864 
		17	822	Marr x2082 
		21	824	Rich, Levin, DeKleer x6032 
		22	825	Purcell, Doyle x5848 
		23	826	Fredkin's Folly x5904
		30	925	Moon (Tycho, north wall) x6765 
		31	902	Mason, Raibert, Hollerbach x3483 
		32	919	Very Small Data Bases south x6765 
		33	344	Edwards, Lebel x6765 
		34	913	Baisley, Greenblatt x6765 
		35	914	Gosper's Fishbowl x2076 
		36	912	9th Floor Lounge x6765 
		37	907	Chess, Lisp Machines x6765 

	val 2	The number of the TV video buffer in use
		on this tty (0-17 octal).  This is NOT a
		Video Switch input number.

Errors:

  1	NO SUCH DEVICE
	No tty exists with the specified number.
 10	DEVICE NOT AVAILABLE
	The PDP-11 which services the TV consoles is down.
 34	WRONG TYPE DEVICE
	The specified tty was not a TV, or the specified
	channel was not a <TTY> or <JOBDEV>.

UNLOCK:	Unlock JOB's locks.

	arg 1	<JOB>

	If the specified job is writable, and is using the locks
	feature, its locks are unlocked.  (Usually this is used on
	onesself.)  See the ITS LOCKS file for more information
	on locks.

	(Note that this has nothing to do with the LOCK device.  In
	particular it will -not- close LOCK device channels.)

Errors:

 31	CAN'T MODIFY JOB
	The specified job is not writable.

 Plus the usual errors for <JOB> arguments.

USRMEM: Read or write another job's memory

	cbits	2.9	Allow writing into any job
		1.1	If page isn't readable or writable give an
			MPV or pure interrupt to the job being
			referenced.

	arg 1	<JOB>
	Other args are like USRVAR and TTYVAR.  In place of
	a variable-specifier you put the address in the job
	of the word to be read or written.

	arg 2	Address to read or write (non-negative)

	Straight reading:

	Specify only 2 arguments.

	Straight writing:

	arg 3	New value

	Writing with an instruction:

	arg 3	Ignored
	arg 4	Instruction to write with

	Block mode:

	arg 2	An AOBJN pointer to a block of pairs, first address
		and then instruction.

	val 1	Previous contents (these are not valid in block mode)
	val 2	New contents


	Reading:
		The content of the specified address in <JOB>
		is returned as val 1.

	Writing:
		Arg 3 is written into the specified address
		in <JOB>.  The previous contents are returned
		as val 1.

	Writing with an instruction:
		The instruction should modify its AC as if the spec'd job's
		memory location were in it.  The memory operand is fetched
		from your own address space and is not stored back.
		No jobs can run while the location is being modified, that is
		between the fetching of the old value and the storing of
		the new value.
		The previous contents are returned as val 1, the new
		contents as val 2.

Errors:

 31	CAN'T MODIFY JOB
	The specified job is not writable.
 32	CAN'T GET THAT ACCESS TO PAGE
	The specified page is either nonexistant
	or is read-only.
 33	MEANINGLESS ARGS
	Attempt to specify an illegal instruction for writing.

USRVAR:	Read or set some of a job's variables

	arg 1	<JOB>

	In the simplest mode:

	arg 2	user variable specifier (see below).
	arg 3	(if writing) the new value.

	If arg 3 is not supplied, you are reading, and
	val 1	is the value of the variable.

	In immediate-instruction mode:

	arg 2	user variable specifier (see below).
	arg 3	ignored
	arg 4	the instruction

	This mode is detected by the presence of four arguments.

	The specified instruction is executed as if the
	variable was in ac 0.  MOVE can be used to set the
	variable, MOVEM to read it, but you can also use
	TLO to set bits, ADDI to increment, etc.

	In block mode

	arg 2	an AOBJN pointer to a block of pairs of words.

	This mode is detected by bits 4.1-4.9 of arg 2 being all
	ones.

	The first word in each pair is the user variable specifier
	(see below), and the second word is an instruction to be
	executed as if that variable were in ac 0.  The block pointer
	argument is updated.

	The instructions allowed in immediate-instruction and
	block modes are:  MOVx, MOVxI, MOVEM, ADD, ADDI, SUB, SUBI,
	all Booleans in normal and immediate modes, and TxZ, TxC,
	and TxO (i.e. all Test instructions that modify and don't
	skip.)

	This call is the symbolic equivalent of the .USET and .SUSET
	UUO's.  It can read, write, or both (but you are usually not
	allowed to write any job except yourself or an inferior);
	it is a .SUSET if the <JOB> is %JSELF, or a .USET if given a
	channel number as the <JOB>, or it can be given other kinds
	of job specs.

	The user variable specifier can be either numeric or sixbit.
	If sixbit, it is the same as the name given in the ITS USETS
	file except without the dot at the beginning.  Sixbit specifiers
	are good for programs which take arguments as to which user
	variable to operate on, and are useful to allow a program
	which uses a new variable to assemble before that variable is
	actually put in the system (it will get error code 11 when it
	tries to refer to the variable.)

	A numeric specifier is a small integer similar to those used
	with the .USET and .USET uuos.  Predefined symbols exist for
	these, consisting of ".R" followed by the name of the variable.
	(Use ".R" rather than ".S" even if you are writing.)  Do not
	use the symbols without the "R" (these are something else.)
	The .IOC, .IOS, .IOP, and .PMAP arrays of user variables
	can only be specified numerically.

	See the .SUSET and .USET UUO's (in .INFO.;ITS UUOS)
	for more information on particular user variables.

Errors:

 11	ILLEGAL FILE NAME
	Unrecognized sixbit user variable specifier, or numeric specifier
	larger than the legal range.
 12	MODE NOT AVAILABLE
	The specified variable is not available for the current combination
	of reading versus writing and self versus other job.
 13	FILE ALREADY EXISTS
	Attempt to cause two jobs in the system to have the same UNAME/JNAME pair.
 31	CAN'T MODIFY JOB
	Attempt to write into a user variable of a job which is not writable.
 33	MEANINGLESS ARGS
	Attempt to specify an illegal instruction in immediate-
	instruction or block mode; or attempt to store an illegal value
	into a user variable (e.g. zero into the .UNAME).
 34	WRONG TYPE DEVICE
	Attempt to access user variables of the pdp-6 other than .UIND
	or .MEMT.
 40	NOT TOP LEVEL
	Attempt to set a user variable for a job that is not top level,
	when only top-level jobs are allowed to set that variable, for
	example the .UNAME and .JNAME.

VIDBUF:	request/release video buffer

	arg 1	If non-negative, the number of a video buffer
		to release.  If negative, requests a video buffer.
	val 1	If arg 1 was negative, the number of the buffer obtained.

	A video buffer for the PDP-11 TV consoles is assigned or
	released.  If assigned, the video switch input number
	of that buffer is returned.  This value can be placed
	in bits 4.1-3.3 of the .TVCREG user variable in order to
	cause video buffer pages in one's page map to refer to
	the allocated video buffer.

	A video buffer is a segment of PDP-11 memory large enough
	to represent all the bits on a TV display.  A display
	is 1100=576. bits wide by 706=454. lines high.  Every
	line is represented by 36. 16.-bit PDP-11 words;
	this corresponds to 18. PDP-10 words as mapped through
	the PDP-10 to PDP-11 interface (see the T11MP symbolic
	system call).  The word with the lowest address holds
	the leftmost displayed bits; furthermore within each word
	bit 15 is the leftmost displayed bit.  Thus, as seen by the
	PDP-10 bits are displayed in the "obvious" manner.
	The entire buffer is 16344.=37730 PDP-11 words long;
	this corresponds to 8172.=17754 PDP-10 words.
	The word 77777 PDP-11 words (17777 PDP-10 words) from the
	origin of the video buffer is a special control register:
	3.2-2.9	15-13	Unused.
	2.8	12	0 => white on black, 1 => black on white.
	2.7-1.5	11-00	Scroll offset: video buffer wraps around;
			the first word displayed is that 4*<offset>
			PDP-11 bytes from the buffer origin.  For
			best results this should be a multiple
			of 9 (for vertical scrolling).
	The PDP-11 always sees a video buffer as beginning at its
	location 60000 (byte address); which video buffer it is looking
	at is controlled by the console register at location 164044 octal.
	Thus the PDP-11 sees the scroll register as being at address
	157776 octal.

	See also the VIDSW symbolic system call.
Errors:

  4	FILE NOT FOUND
	Attempt to release a buffer not assigned to the job.
  7	DEVICE NOT READY
	The PDP-11 is not ready.
 33	MEANINGLESS ARGS
	Arg 1 is non-negative but not a valid video buffer number.

VIDSW:	set video switch

	arg 1	Video switch input number.
	arg 2	Video switch output number.

	The video switch is set up so that the specified video
	output will gobble bits from the specified video input.

	As of July 25, 1975, the only video inputs are TV
	video buffers.  These correspond to Tnm device numbers
	as follows:

	Tnm	Video Input Number
	T47	24		T47 is used for console free buffer.
	T52	1		When you type ESC<n>S, <n> is
	T53	2		the video input number.  The PDP-11
	T54	5		merely switches that input to your
	T55	6		TV display, which is a video output.
	T56	7
	T57	10
	T60	21
	T61	22
	T62	23

	The possible video outputs are mostly TV displays, but also
	the Tektronix hard-copy device which sits next to the XGP.
	(The keyboard number may be relevant to use of the TVWHER
	symbolic system call.)  As of July 25, 1975:

	Video Output	Keyboard	Location of TV
	 0		 0		809 Fahlman, Holloway, Knight
	 1		14		820 Minsky
	 2		21		824 Rich, McDonald, deKleer
	 3		 6		815 Freiling, Perez, Ullman
	 4		10		817 Jabari
	 5		22		825 Freuder, Grossman, Purcell
	 6		 4		813 Hewitt
	 7		 5		814 Brown, McDermott, Sussman
	10		13		819 Goldstein, Woods
	11		17		822 Marr, Sandewall
	12		35		915 Cohen, Gosper, etc.
	13		34		913 Baisley, Greenblatt
	14		33		334 Lebel
	15		30		925 Jarvis, Moon
	16		31		918 Freeman
	17		32		920 Computer room, near PDP-11
	20		 3		812 Yvonne, Williams
	21		36		912 9th Floor Lounge
	22		37		914 Larson, Lebel, Mousouriss
	23		1		810 Kuipers
	27		Tektronix hard-copy output device.

Errors:

  7	DEVICE NOT READY
	The PDP-11 is not ready.

WHOLIN:	examine and set TV who-line				(ITS TV)

	arg 1	<TTY> or <JOBDEV>
		Must be a TV terminal if a <TTY>.
	arg 2	If present, used to set new who mode:
		-1	No who-line.
		0	User who-line; migrates with TTY.
		1	User who-line; frozen on who job.
		4	System who-line.
	arg 3	If present, used to set new who <JOB>.
	val 1	Old who mode.
	val 2	Old who job.

	The TTY must be specified by a channel number and not
	by 400000 + tty number if the variables are to be altered.

	See ITS TV.

Errors:

  1	NO SUCH DEVICE
	No tty exists with the specified number.
 10	DEVICE NOT AVAILABLE
	The PDP-11 which services the TV consoles is down.
 34	WRONG TYPE DEVICE
	The specified tty was not a TV, or the specified
	channel was not a <TTY> or <JOBDEV>.

WHYINT:	Find out reason for second-word interrupt

	arg 1	channel # (or <JOBDEV>)

	val 1	%WY code (see below)
	val 2-n	device-dependent

	This system call is the standard response to a second-word
	(.IFPIR) interrupt.  The first value returned is a code
	number which indicates the type of device on the channel.
	Usually a program will know what type of device is present,
	because it only tries to use one type, but this value
	is provided just in case.  The codes are:

		1    %WYTYI	TTY input
		2    %WYTYO	TTY output
		3    %WYSTI	STY input
		4    %WYSTO	STY output
		5    %WYNET	(Arpa)NET
		6    %WYCHA	CHAosnet
		7    %WYTCP	TCP Internet
		10   %WYUBI	KS10 Unibus interrupt (UBI device)

	The device-dependent values returned are:

	For a TTY input channel:
	val 1	%WYTYI
	val 2	character typed.  Reading characters this way
		does not interfere with later reading them via
		normal IOT.  This allows characters to be processed
		both as interrupt characters at the time they are
		typed, and as normal input.  The call fails to
		skip if there are no more interrupt characters.
		The program should keep calling WHYINT until
		it fails to skip, then DISMIS the interrupt.

	For a TTY output channel:
	val 1	%WYTYO
	val 2	bit mask of reasons.  The only reason that presently
		exists is:
			4.9	--MORE-- interrupt.  (Typeout reached
				the bottom of the screen.)

	For a STY input channel:
	val 1	%WYSTI

	For a STY output channel:
	val 1	%WYSTO

	For a UBI channel:
	val 1	%WYUBI
	val 2	Count of all interrupts ever signalled at the
		given interrupt address.

	For a NET (Arpanet NCP) channel:
	val 1	%WYNET
	val 2	Sign bit 1 if "network interrupt" received.
		Right Half Socket state:
		0	%NSCLS	Connection closed.
		1	%NSLSN	Listening for RFC.
		2	%NSRFC	RFC received while listening.
		3	%NSRCL	CLS received while in %NSRFC state.
		4	%NSRFS	RFC sent.
		5	%NSOPN	Connection open.
		6	%NSRFN	RFNM wait on write link.
		7	%NSCLW	CLS sent, waiting for matching CLS.
		10	%NSCLI	CLS received but input still available.
		11	%NSINP	Input available.
	val 3	Number of bytes of input available (if input channel).
		Number of bytes free in output buffer (if output channel.)
	val 4	Close reason.  Only valid if val 2 is %NSCLS.
		0	%NCNTO	Never opened.
		1	%NCUSR	Closed by user.
		2	%NCFRN	Closed by foreign host.
		3	%NCRST	Foreign host reset itself.
		4	%NCDED	Foreign host dead.
		5	%NCINC	Incomplete transmission.
		6	%NCBYT	Byte size mismatch.
		7	%NCNCP	Local NCP went down (local host dead).
		10	%NCRFS	Request for Connection rejected by fgn host.

	For a TCP channel:
	val 1	%WYTCP
	val 2	state code (see below)
	val 3	input: # bytes avail, output: # bytes free in buffer
	val 4	Close reason (same values/meanings as for NET.  See
		definition of %NX== in SYSTEM;BITS > if curious.)

	The TCP state codes are defined in SYSTEM;BITS > at %NT==:
	; Legend: - Pre-Open, * Open, + Post-open, ? impossible.
	;	I = can read, O = can write.
	; Note that the input and output channels for a TCP connection
	; will usually have different states.  Also, note that
	; for all practical purposes, %NT and %NS symbols with the same
	; value have the same meaning.  SYN = Request for connection.
			; In Out
	%NTCLS==:0	; -  -	Closed (reason available from WHYINT)
	%NTLSN==:1	; -  -	Listening for a SYN
	%NTSYR==:2	; -  -	SYN received
	%NTCLU==:3	; +  ?	Being closed by fgn host
	%NTSYN==:4	; -  -	SYN sent, waiting for response
	%NTOPN==:5	; *I *O	Open
	%NTWRT==:6	; ?  *O	Output buffer full
	%NTCLX==:7	; ?  +	Being closed by user
	%NTCLI==:10	; +I ?	Closing/closed, input still available
	%NTINP==:11	; *I ?	Open, input available


	Chaosnet:
	val 1 - %WYCHA
	val 2 - state
	val 3 - number of packets queued (receive,,transmit)
	val 4 - window size (receive,,transmit)
	val 5 - input channel#,,output channel# (-1 if not open or I/O-pushed)

	LH(val 3) is the number of packets available to input IOT.
		  This is different from the number of received packets
		  if some are out of order.  This is increased by 1 if
		  there is a partially-read buffer available to SIOT;
		  this packet is not available to PKTIOT.  This is zero
		  if the connection is direct-connected to a STY.

	RH(val 3) is the number of packet slots available in the output
		  window, i.e. the window size minus the number of packets
		  which have been transmitted by output IOT but which have
		  not yet been received and acknowledged by the foreign
		  host.
		  
	The state codes are:

		%CSCLS	Closed
		%CSLSN	Listen
		%CSRFC	RFC-received
		%CSRFS	RFC-sent
		%CSOPN	Open
		%CSLOS	Broken by receipt of "LOS" packet.
		%CSINC	Broken by incomplete transmission (no acknowledge
			for a long time)

Errors:

34	WRONG TYPE DEVICE
	The specified channel supposedly never gives interrupts.

XGPIM:	xerox graphic printer image output

	arg 1	Address of a word with the number of pages of
		data in the left half and the number of the first
		data page in right half.
		This word must be in writable memory.

	Bits are shoved out onto the XGP.

	I wonder what the precise semantics of this kludge are?
