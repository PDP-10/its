
							PAGE  1



                     M.I.G.S.
                      MANUAL


IDENTIFICATION
     M.I.G.S. - MUDDLE INTERACTIVE GRAPHICS SYSTEM
     RICHARD R. SHIFFMAN
     OCTOBER 30, 1973

MOTIVATION
     I HAVE FOUND THAT THERE IS A GENERAL NEED FOR AN
   INTERACTIVE GRAPHICS SYSTEM THAT RUNS IN A TIMESHARING
   ENVIRONMENT. THE GREATEST USE FOR SUCH A SYSTEM WOULD BE
   IN ENGINEERING, MATH, AND PHYSICS. THE ADVANTAGES OF 
   INTERACTIVE GRAPHICS OVER
   NORMAL COMPUTER AIDED INSTRUCTION ARE OBVIOUS. A
   STUDENT OR RESEARCHER CAN SIT DOWN AT A LOW COST GRAPHICS
   TERMINAL AND SEE A PICTURE OF THE FUNCTION HE IS
   INTERESTED IN. THIS LEADS TO A BETTER UNDERSTANDING OF
   THE PROBLEM, AND ALSO ALLOWS EXPERIMENTATION THAT WOULD
   BE TOO DIFFICULT TO DO BY HAND. FOR A STUDENT THIS WOULD
   MEAN GREATER INTEREST IN THE SUBJECT AND HOPEFULLY
   BETTER UNDERSTANDING OF IT.
     I BELIEVE THAT THE ARPA NETWORK IS IDEAL FOR THE
   DEVELOPMENT OF SUCH A SYSTEM, SINCE IT IS EASILY ACCESSIBLE
   FROM MANY COLLEGES AND RESEARCH CENTERS IN THE COUNTRY.
   MY ORIGINAL CHOICE OF M.I.T.-D.M.C.G. AND MUDDLE TO
   DEVELOP THIS PACKAGE WAS TAKEN AT RANDOM, BUT THE RESEARCH
   ORIENTED ATMOSPHERE OF DMCG AND THE POWERFUL INTERACTIVE
   ENVIRONMENT OF MUDDLE (A RECURSIVE LIST PROCESSING
   LANGUAGE) PROVED IDEAL FOR THIS PROJECT

REFERENCES
     1) A MUDDLE PRIMER, GREG PFISTER (SYS.11.01)
     2) MICRO MUDDLE MANUAL, BRUCE DANIELS (SYS.11.03)
     3) PRINCIPLES OF INTERACTIVE COMPUTER GRAPHICS, NEUMAN AND SPROULL

ACKNOWLEDGEMENTS
     NOT BEING A MEMBER OF PROJECT MAC, BUT JUST A PERSON WHO
   APPEARED ON THE SYSTEM, I WOULD REALLY LIKE TO
   THANK EVERYBODY AT DMCG FOR TOLERATING ME ON THE SYSTEM.
   IN THIS RESPECT I WOULD LIKE TO THANK AL VEZZA FOR THE
   DIRECTORY AND THE CPU TIME. I WOULD ALSO LIKE TO THANK
   GREG PFISTER, BRUCE DANIELS, AND CHRIS REEVE, WHO
   REMAINED CIVIL, EVEN THOUGH I ALWAYS SEEMED TO LINK TO
   THEM AT INOPPORTUNE TIMES AND ASKED MANY QUESTIONS.
							PAGE  2







Ó

DESCRIPTION
     AT THE PRESENT TIME MIGS IS STILL UNDER DEVELOPMENT,
   BUT IT IS QUITE USEABLE, AS DEMONSTRATED BY ITS USE ON
   THE NETWORK MUDDLE SOCKET BY SEVERAL STUDENTS HERE AT
   USC AND A RESEARCH GROUP IN THE EE DEPARTMENT WHO
   USES MIGS TO STUDY RADAR AMBIGUITY FUNCTIONS. AT THIS
   TIME MIGS IS ABLE TO SUPPORT FOUR OF THE MOST COMMONLY
   USED GRAPHICS TERMINALS; TEKTRONIX (4002, 4010), ARDS,
   GT42'S AND IMLACS.
      THE PACKAGE CONSISTS OF THREE MAIN PARTS.
   THE FIRST IS THE INITIATOR WHICH ASKS THE USER WHAT TYPE
   OF TERMINAL HE IS ON, AND LOADS THE APPROPRIATE FILES.
   THE SECOND PART IS THE ON LINE HELP SUBSYSTEM, WHICH
   EXPLAINS HOW TO USE MIGS TO A NEW USER. THE THIRD
   PART CONSISTS OF THE GRAPHICS PRIMITIVES AS WELL AS THE
   MORE COMPLEX DISPLAY SUBPROGRAMS. THESE FUNCTIONS WILL LET THE
   USER MOVE AND DRAW TO HIS HEARTS CONTENT; PERFORM
   CARTESIAN, POLAR, AND PARAMETRIC PLOTS OF A FUNCTION OF
   ONE VARIABLE. MIGS ALSO WILL LET THE USER PRODUCE A
   SURFACE PLOT OF A FUNCTION OF TWO VARIABLES WITH HIDDEN
   LINES REMOVED. A CONTOUR PLOTTER WILL BE ADDED SOON.
     SOME OF THE NEW DEVELOPMENTS THAT HAVE  BEEN
   RELEASED TO GENERAL USE, ARE THE DISPLAY COMPILER AND
   DISPLAY PROCESSOR. THE DISPLAY COMPILER AND
   PROCESSOR WILL GIVE THE USER THE ABILITY TO CREATE
   PICTURES AND SUBPICTURES, AND THEN TRANSFORM THEM (I.E.
   ROTATION, TRANSLATION, AND SCALING).
							PAGE  3




CONTENTS					PAGE
   CHAPTER 0. LOADING MIGS
   0.1. LOADING MUDDLE AND MIGS			4
   0.2. TENEX MUDDLE				4

   CHAPTER 1. INITIALIZATION OF MIGS
   1.1 DESCRIBING YOUR TERMINAL TO MIGS		5
   1.2 USE OF THE HELP FUNCTION			5

   CHAPTER 2. MIGS PRIMITIVES
   2.1. MOVE AND DRAW				6
   2.2. POINT					7
   2.3. LINE					7
   2.4. PLOTV AND PLOTVDSK			7
   2.5. DSKIMAGE				8
   2.6. CIRCLE AND ELIPSE			8
   2.7. PAGE					8
   2.8. MOVE3D AND DRAW3D			9
   2.9. POINT3D					9
   2.10. LINE3D					10
   2.11. PLOTV3D				10
   2.12. PROJ					11
   2.13. SETORG AND SETPROJ			11

   CHAPTER 3. PLOTTING FUNCTIONS
   3.1. FNCTG					13
   3.2. PARAG					14
   3.3. POLRP					15

   CHAPTER 4. SURFACE PLOTTING
   4.1. SFXYP					16
   4.2. MIJPL					17
   4.3. M3D AND M3DSK				18

   CHAPTER 5. THE DISPLAY COMPILER
   5.1. MCELL					19
   5.2. DISP					22
   5.3. CALL					22
   5.4. XLATE					23
   5.5. SCALE					24
   5.6. ROTZ					24
   5.7. ROTX					25
   5.8. ROTY					25
   5.9. CREATING YOUR OWN TRANSFORMS		25
   5.10. SETCLIP				26


   APPENDICIES
   A.1 SOME EXAMPLES OF THE USE OF MIGS PRIMITIVES	27
   A.2 EXAMPLES OF THE DISPLAY COMPILER AND PROCESSOR	28
							PAGE  4





BODY



		      CHAPTER 0
	            LOADING MIGS

   0.1 LOADING MUDDLE AND MIGS

    IF YOU ARE ON AN "ITS" SYSTEM, DMS, SAY MUDDLE^K OR :MUDDLE<CR> TO
   DDT. THIS WILL LOAD A MUDDLE AND START IT RUNNING FOR YOU. ON "ITS"
   TO DELETE A CHARACTER USE RUBOUT. IF YOU ARE ON A TENEX, SAY MUDDLE<CR>
   OR <MUDDLE>MUDDLE.SAV<CR> TO THE EXEC. REMEMBER THAT ON TENEX,
   ^A IS USED TO DELETE A CHARACTER. ^S, ^G, ^D, AND ^L
   WORK THE SAME IN EITHER "ITS" OR TENEX, IN TENEX THE MEANING OF ^Z
   AND ^C ARE REVERSED.
    NOW THAT YOU HAVE  A MUDDLE, THE NEXT THING IS TO LOAD MIGS. IF 
   YOU ARE ON DM ("ITS"), SAY <FLOAD RRS;MIGS INIT>$ TO MUDDLE.
   IF YOU ARE USING THE TENEX AT USCECL TYPE <FLOAD "<MUDDLE>MIGS.INIT">$
   AT MUDDLE. IF YOU ARE ON ANOTHER TENEX THAT HAS MUDDLE AND MIGS, 
   REPLACE "<MUDDLE>" WITH THE NAME OF THE DIRECTORY THAT MIGS IS IN.

   0.2 TENEX MUDDLE

    THERE IS ONE SMALL DIFFERENCE IN MIGS FOR TENEX MUDDLE, AT THE
   PRESENT TIME. WHEN MIGSINT IS ASKING YOU WHAT KIND OF TERMINAL YOU
   ARE ON, YOU HAVE TO TYPE AN <ESC> AFTER THE CHARACTER. THIS IS BECAUSE
   AT THIS TIME THERE ISN'T A TYI IN TENEX MUDDLE. MIGS LOADS IT OWN
   TYI RSUBR AT THE END OF MIGSINIT.
							PAGE  5










                   CHAPTER 1
            INITIALIZATION OF MIGS

   1.1 DESCRIBING YOUR TERMINAL TO MIGS

     WHEN MIGS STARTS TO RUN THE FIRST THING IT DOES IS  ASK
   YOU WHAT TYPE OF TERMINAL YOU ARE USING. TO TELL MIGS,  YOU TYPE
   ONE LETTER AT IT; 'A' IS FOR ARDS AND IMLACS, 'T' IS FOR TEKTRONIX,
   AND 'G' IS FOR GT42'S. AT THIS TIME YOU CAN ALSO TYPE 'H' AND INVOKE
   THE HELP SUBSYSTEM. MIGS WILL THEN LOAD THE RIGHT GRAPHICAL 
   PRIMITIVES FOR YOUR TERMINAL, AND INFORM YOU THAT IT HAS DONE
   SO. NEXT IT WILL ASK IF YOU WANT THE DISPLAY COMPILER. THE DISPLAY
   COMPILER IS QUITE LARGE, SO IF YOU JUST WANT TO HACK AROUND AND
   PLOT FUNCTIONS YOU WONT NEED IT, BUT IF YOU WANT TO DO MORE COMPLEX 
   THINGS LOAD IT. ONCE YOU DECIDE TYPE 'Y' FOR YES, OR 'N' FOR NO.
   AFTER A LITTLE WHILE MIGS WILL REPLY 'MIGS LOAD', NOW YOU ARE READY
   TO PLOT TO YOUR HEARTS CONTENT. IF YOU DECIDE THAT YOU  WANT THE
   DISPLAY COMPILER AT SOME LATER TIME, OR WANT TO CHANGE TERMINALS
   TYPE <MIGSINIT>$ AND REPEAT THE ABOVE.

   1.2 THE HELP SUBSYSTEM

     THE MIGS HELP SUBSYSTEM IS AVAILABLE  ANY TIME MIGS IS LOADED.Ó.
   WHEN MIGS IS BEING INITIALIZED IT MAY BE INVOKED BY TYPING A 'H'
   TO MIGS, AS I DESCRIBED ABOVE. AT ANY OTHER TIME TYPE <MIGSHELP>$
   AND YOU'LL GET THE HELP SUBSYSTEM. THIS SUBSYSTEM WILL GIVE YOU A
   A SHORT DESCRIPTION OF THE FUNCTION IN MIGS. YOU CAN TYPE HELP$
   AND IT WILL LIST THE THINGS FOR WHICH IT HAS INFO. THEN YOU TYPE THE
   NAME OF THE FUNCTION YOU'RE INTERESTED IN FOLLOWED BY AN $, AND THE 
   HELP SUBSYSTEM WILL DESCRIBE IT. THE DESCRIPTION IS OF THE FOLLOWING
   FORM: FUNCTION NAME, NUMBER OF ARGS., HOW TO USE IT. TO LEAVE
   THE HELP SUBSYSTEM TYPE RETURN$.
							PAGE  6





                 CHAPTER 2
             MIGS PRIMITIVES

     BEFORE I GO ON I WOULD LIKE TO POINT OUT THAT THROUGHOUT THIS
   MANUAL I AM ASSUMING THAT THE ORIGIN IS AT THE LOWER LEFT 
   CORNER OF THE SCREEN, AND THE UPPER RIGHT CORNER IS AT (1023,1023).
   IF YOU LIKE THE ORIGIN AT THE CENTER OF THE SCREEN READ HOW TO USE
   SETORG, SETPROJ, AND SETCLIP.

   2.1 MOVE AND DRAW
     THIS SEEMS LIKE A GOOD PLACE TO START SINCE MOVING AND DRAWING
   THE BEAM AROUND ON THE SCOPE IS ABOUT THE MOST BASIC THING YOU CAN
   DO. THE FUNCTION MOVE TAKES TWO ARGUMENTS, THE X AND Y POSITION
   OF WHERE YOU WANT THE BEAM. THEN IT SET THE SCOPE IN GRAPHICS MODE AND
   MOVES THE BEAM THERE INVISIBLY. THE FUNCTION DRAW TAKES A X AND Y
   POSITION AND DRAWS (MOVES THE BEAM VISIBLY) FROM WHERE IT WAS TO
   POSITION YOU GAVE IT. SINCE MOVE SET THE SCOPE IN GRAPHICS MODE IT MUST
   BE CALLED BEFORE THE FIRST CALL TO DRAW, ALSO YOU SHOULDNT DROP OUT
   OF GRAPHICS MODE INÓBETWEEN DRAWS. THE ARGUMENT TO MOVE AND DRAW
   MUST BE INTEGER AND SHOULD BE INSIDE THE SCREEN BOUNDARIES OR
   STRANGE THINGS WILL HAPPEN. I WILL NOW GIVE A COUPLE OF EXAMPLES
   ILLUSTRATING THE RIGHT AND  WRONG WAY TO USE MOVE AND DRAW.

   EX 2.1.1 THE RIGHT WAY
      <PROG () <MOVE 100 100> <DRAW 500 600>>;"THIS WILL DRAW A LINE
						FROM (100,100) TO
						(500,600)."$

     <PROG () <MOVE 0 0>
              <DRAW 0 1023>
	      <DRAW 1023 1023>
	      <DRAW 1023 0>
              <DRAW 0 0>>;"DRAWS A BIG SQUARE"$

   EX 2.1.2 THE WRONG WAY
      <MOVE 0 0><DRAW 60 100>;"THIS WILL DROP OUT OF GRAPHICS MODE
		                INÓBETWEEN THE MOVE AND DRAW"$
 
      <PROG () <DRAW 76 68> <MOVE 50 300>>;" THERE MUST BE A MOVE BEFORE
					     DRAW"$
							PAGE  7






   2.2 POINT
     THIS FUNCTION TAKES TWO ARGUMENTS THE X AND Y COORDINATES
   THEN DISPLAYS A POINT  ON THE SCREEN. THE ARGUMENTS TO POINT
   MUST BE OF TYPE FIX AND SHOULD BE IN THE VISIBLE
   AREA OF THE SCREEN.

   EX 2.2.1
      <POINT 500 500>;"PUT A POINT AT (500,500)"$

   EX 2.2.2
     <DEFINE FOO ( "AUX" (X 400) Y)
	     <REPEAT ()
		     <SET Y </ <* <- .X 500> <- .X 500>> 10>>
		     <POINT .X .Y>
		     <POINT .X 0>
		     <POINT 500 .Y>
		     <COND (<G? <SET X <+ .X 1>> 599> <RETURN "DONE">)>>>
		     ;"THIS WILL PRODUCE A PARABOLA AND AXES ON THE
		       SCREEN WHEN USED."$
	<FOO>;"LETS TRY IT"$



   2.3 LINE
     THE FUNCTION LINE DISPLAYS A LINE ON THE SCREEN, WHICH IS 
   SPECIFIED BY ITS END-POINTS. THE FUNCTION TAKE 4 ARGUMENTS
   WHICH MUST BE FIXED. THE FIRST TWO ARE THE X AND Y COORDINATES
   OF THE FIRST END-POINT THE LAST TWO ARE X AND Y COORDINATES 
  FOR THE SECOND END-POINT OF THE LINE SEGMENT YOU WANT TO DRAW.

   EX 2.3.1
      <LINE 100 100 100 800>
      <LINE 100 800 800 800>
      <LINE 800 800 800 100>
      <LINE 800 100 100 100>;"THIS WILL DRAW A RECTANGLE ON
			      THE SCREEN. NOTICE THAT LINE
			      DOESNT HAVE TO BE IN A FUNCTION
			      OR A PROG."$


   2.4 PLOTV AND PLOTVDSK
     PLOTV IS USED TO PLOT TWO LISTS, VECTORS, OR UVECTORS
   AGAINST EACH OTHER. THE FIRST LIST (VECTOR,UVECTOR) IS USED
   AS THE X COORDINATES, AND THE SECOND IS USED AS THE Y
   COORDINATES. PLOTV MOVES THE BEAM TO THE FIRST PAIR OF
   COORDINATES AND DRAWS TO THE REST. THE ELEMENTS OF THE LISTS
   (VECTORS, UVECTORS) MUST BE OF TYPE FIX, AND THE LISTS MUST
   BE OF THE SAME LENGTH,OR YOU GET AN ERROR.
     PLOTVDSK IS IDENTICAL TO PLOTV IN HOW IT HANDLES ITS FIRST
   TWO ARGUMENTS, BUT IT TAKES A THIRD ARGUMENT A DSK CHANNEL
   TO WRITE ITS OUTPUT ON. YOU CAN VIEW THIS BY USING THE FUNCTION
   DSKIMAGE.

  EX 2.4.1
     <PLOTV ![100 800 800 100 100]
	    ![100 100 800 800 100]>;"THIS DRAWS THE RECTANGLE AGAIN"$
							PAGE  8



   2.5 DSKIMAGE
     DSKIMAGE IS USED TO DISPLAY A DISK  FILE IN IMAGE MODE ON YOUR
   SCOPE. IT TAKES ONE OPTIONAL ARGUMENT, A STRING WHICH IS THE
   THE NAME OF THE DSK FILE YOU WANT TO DISPLAY. DSKIMAGE DEFAULTS
   TO <STRING <SNAME> ";M3D MIGPUT">. THIS FUNCTION IS USED
   IN CONJUNCTION WITH M3DSK OR PLOTVDSK, BUT CAN BE USED TO DISPLAY
   ANY FILE (NOTE IF IT CONTAINS A CONTROL-L IT WILL CLEAR THE SCREEN).

   EX 2.5.1
      SUPPOSE THAT YOU HAVE A SURFACE PLOT PRODUCED BY M3DSK IN A FILE IN
      YOUR DIRECTORY NAMED FOO BAR.
      <DSKIMAGE "FOO BAR">;"THIS DISPLAYS FOO BAR FOR YOU"$


   2.6 CIRCLE AND ELIPSE
     CIRCLE TAKES FOUR ARGUMENTS OF TYPE FIX. THE FIRST TWO
   ARE THE X AND Y COORDINATES OF THE CENTER OF THE CIRCLE TO
   BE DISPLAYED, THE NEXT IS THE RADIUS OF THE CIRCLE, AND
   THE LAST IS THE NUMBER OF POINTS IN IT. BESIDES DRAWING
   CIRCLES, CIRCLE CAN BE USED TO GENERATE REGULAR POLYGONS.
     ELIPSE IS SIMILAR TO CIRCLE EXCEPT THAT IT TAKES FIVE
   ARGUMENTS AND DRAWS AN ELLIPSE. THE FIRST TWO ARGUMENTS ARE
   COORDINATES OF THE CENTER. THE NEXT TWO ARE THE LENGTHS OF
   THE X AND Y SEMI-AXIS RESPECTIVELY. THE LAST IS THE NUMBER
   OF POINTS IN THE ELLIPSE. IF THE THIRD AND FOURTH ARGUMENTS
   ARE EQUAL THEN ELIPSE WILL HAPPILY DRAW A CIRCLE.

   EX 2.6.1
      <CIRCLE 500 500 300 100>;" MAKES A CIRCLE AT THE CENTER OF
                                 THE SCREEN (500,500), WITH RADIUS
                                 OF 300, AND 100 POINTS IN IT"$
      <CIRCLE 500 500 300 6>;" THIS INSCRIBES A HEXAGON IN THE
                               CIRCLE WE JUST DREW"$

   EX 2.6.2
      <ELIPSE 500 500 400 300 100>;" PUT AN ELLIPSE AROUND THE
                                     THE CIRCLE AND HEXAGON THAT
                                     TOUCHES THE TOP AND BOTTOM
                                     OF THE CIRCLE."$


   2.7 PAGE
     IF YOU GET TIRED OF PUSHING THE ERASE OR THE FORM KEY ON YOUR
   TERMINAL WHEN YOU WANT WHATS ON THE SCREEN TO GO AWAY, YOU CAN
   USE PAGE AND GET THE SAME RESULTS. PAGE TAKES NO ARGUMENTS.
   IF YOU USE PAGE IN A PROGRAM AND ARE ON AN ARDS OR TEKTRONIX
   YOU SHOULD ALLOW  ABOUT ONE SECOND BEFORE YOU DRAW AGAIN TO
   MAKE THE SCOPE HAPPY. NOTE THAT THIS IS USEFUL IN TENEX MUDDLE, WHICH
   DOESN'T KNOW HOW TO CLEAR THE SCREEN.

   EX 2.7.1
      <PAGE>;" WELL I GAVE AN EXAMPLE FOR EVERYTHING ELSE"$
							PAGE  9






   2.8 MOVE3D AND DRAW3D
     THIS IS THE START OF THE DESCRIPTION OF THE THREE
   DIMENSIONAL PRIMITIVES. THEY ARE SIMILAR TO THEIR TWO DIMENSIONAL
   COUNTERPARTS, EXCEPT THAT THEY TAKE A Z COORDINATE. ALSO THE
   3D PRIMITIVES WILL WORK WITH ARGUMENTS OF THE TYPE FIX OR FLOAT. I 
   WOULD LIKE TO POINT OUT AT THIS TIME THAT THE POSITIVE DIRECTION OF
   THE Z AXIS IS INTO THE SCREEN, AND Z = 0 IS AT THE SCREEN.
     THE FUNCTION MOVE3D SETS THE SCOPE IN GRAPHICS MODE AND 
   MOVES THE BEAM INVISIBLY TO THE POINT YOU SPECIFY. MOVE3D TAKES 
   THREE ARGUMENTS; THE X, THE Y, AND THE Z COORDINATE OF THE POINT. SINCE
   MOVE3D SETS THE SCOPE IN GRAPHICS MODE IT MUST BE CALLED BEFORE THE
   FIRST CALL TO DRAW3D.
     DRAW3D MOVES THE BEAM VISIBLY FROM WHERE IT IS TO THE COORDINATES THAT 
   YOU GIVE IT. DRAW3D TAKES THREE ARGUMENTS, THEY ARE THE SAME AS THE
   ARGUMENT TO MOVE3D. BEFORE YOU CAN USE DRAW3D YOU MUST BE IN GRAPHICS
   MODE, AND DON'T DROP OUT OF GRAPHICS MODE INÓBETWEEN CALLS TO DRAW3D.

   EX 2.8.1
    <PROG () <MOVE3D 0 0 0>
               <DRAW3D 100 200 300>
             <DRAW3D 500 400 -300>
             <DRAW3D 0 0 0>>;"THIS WILL DRAW A TRIANGLE WITH ITS
                              VERTICES AT (0,0,0),(100,200,300),
                              AND (500,400,-300)"$


   2.9 POINT3D
     THIS FUNCTION TAKES THREE ARGUMENTS. THE ARE THE X,
   THE Y, AND THE Z COORDINATES OF A POINT TO DISPLAY ON THE
   SCREEN. POINT3D ENTERS GRAPHICS MODE DISPLAYS THE POINT AND
   THEN DROPS OUT OF GRAPHICS MODE WHENEVER IT IS INVOKED, SO
   IT IS SAFE TO USE AT ANY TIME. THE ONLY RESTRICTION IS THE
   PROJECTION OF THE POINT SHOULD BE VISIBLE.

   EX 2.9.1
      <REPEAT ((X 0)(Y 0) (Z 0))
	      <POINT3D .X 
		       <+ 500 .Y>
		       .Z>
	      <SET X <+ 10 .X>>
	      <SET Y <* 500 <SIN <* 6.28E-3 .X>>>>
	      <SET Z .X>

	      <COND (<G? .X 1000> <RETURN ,NULL>)>>;"
	      THIS WILL DRAW A SIN WAVE WHICH STARTS ON THE
	      LEFT SIDE OF THE SCREEN AND HEADS OFF INTO THE DISTANCE
	      UNTIL IT RUNS OUT OF POINTS."$
							PAGE  10







   2.10 LINE3D
     THE FUNCTION LINE3D WILL DISPLAY THE PROJECTION OF A LINE
   IN THREE SPACE ON THE SCREEN OF YOUR TERMINAL. LINE3D TAKES
   SIX ARGUMENTS, THEY ARE THE X, Y, AND Z COORDINATES OF THE TWO
   END-POINTS OF THE LINE. THE END-POINTS SHOULD BE ON THE VISIBLE
   PART OF THE SCREEN OR STRANGE THINGS WILL HAPPEN. LINE3D ENTERS AND
    LEAVES GRAPHICS MODE ITSELF SO IT CAN BE CALLED AT ANY TIME.

   EX 2.10.1
      <LINE3D 0 0 0 1000 1000 1000>
     <LINE3D 1000  0 1000 600 0 600>
     <LINE3D 600 0 600 0 0 0>
     <LINE3D 0 0 0 500 1000 500>
     <LINE3D 1000 0 1000 500 1000 500>
      <LINE3D 600 0 600 500 1000 500>;"THIS WILL DRAW A PYRAMID
                                      ON THE SCOPE."$


   2.11 PLOTV3D
     THIS FUNCTION IS QUITE SIMILAR TO ITS TWO DIMENSIONAL ANALOG,
   PLOTV. PLOTV3D TAKES THREE ARGUMENTS THEY MUST BE OF TYPE LIST,
   VECTOR, OR UVECTOR. THE FIRST ARGUMENT IS TAKEN
   AS THE X COORDINATES, THE SECOND IS THE Y COORDINATES, AND THE 
   THIRD IS THE Z COORDINATES. THE LISTS, VECTORS, OR UVECTORS
   THAT ARE THE X, Y, AND Z COORDINATES MUST BE OF THE SAME LENGTH
   OR ELSE YOU WILL GET AN ERROR.

EX 2.11.1
       <DEFINE CUBE (X0 Y0 Z0 X1 Y1 Z1);"THIS FUNCTION WILL DRAW
                                         CUBE ON THE SCREEN. IT USES
                                         PLOTV3D AND LINE3D."
               <PLOTV3D ![.X0 .X0 .X1 .X1 .X0]
                        ![.Y0 .Y1 .Y1 .Y0 .Y0]
                        ![.Z0 .Z0 .Z0 .Z0 .Z0]>
               <PLOTV3D ![.X0 .X0 .X1 .X1 .X0]
                        ![.Y0 .Y1 .Y1 .Y0 .Y0]
                        ![.Z1 .Z1 .Z1 .Z1 .Z1]>
                <LINE3D .X0 .Y0 .Z0 .X0 .Y0 .Z1>
               <LINE3D .X0 .Y1 .Z0 .X0 .Y1 .Z1>
               <LINE3D .X1 .Y1 .Z0 .X1 .Y1 .Z1>
                <LINE3D .X1 .Y0 .Z0 .X1 .Y0 .Z1>>$

       <CUBE 200 200 0 400 400 200>;"DRAW A CUBE WITH ONE CORNER
                                  AT (200,200,0) AND THE OPPOSITE
				  CORNER AT (400,400,200)."$
							PAGE  11



   2.12 PROJ
     PROJ IS NOT A GRAPHICAL PRIMITIVE, BUT IS MIGS'S PROJECTION
   ROUTINE. I FIGURED THAT IT MIGHT BE OF SOME USE IN FUNCTIONS
   THAT A USER MIGHT WRITE SO I WILL DESCRIBE IT. PROJ TAKES
   FOUR ARGUMENTS. THE FIRST THREE ARE REQUIRED AND ARE THE
   X, Y, AND Z COORDINATES OF A POINT IN THREE SPACE. THE FOURTH
   ARGUMENT IS THE DISTANCE FROM THE SCREEN TO THE EYE AND IS
   OPTIONAL. THE DEFAULT EYE POSITION IS (512 512 1024), THAT IS
   THE CENTER OF THE SCREEN AND ABOUT 10 INCHES IN FRONT OF IT.
   THIS CAN BE CHANGED BY THE FUNCTION SETPROJ DESCRIBED IN 2.13.
   PROJ RETURNS A TWO ELEMENT LIST, WHICH IS THE X AND Y CO-
   ORDINATES OF THE POINT PROJECTED ON THE Z=0 PLANE.

   EX  2.12.1
       <DEFINE POINT3 (X Y Z);"THIS FUNCTION IS A 3D POINT PLOTTER
                               IT USES POINT AND PROJ."
               <POINT !<PROJ .X .Y .Z>>>;"NOTE THE USE OF
                                           THE SEGMENT TO MAKE
                                           POINT HAPPY"$
       <POINT3 200 300 400>;"DISPLAY A POINT AT (200,300,400)."$

   2.13 SETORG AND SETPROJ
     THE FUNCTIONS SETORG AND SETPROJ LET THE USER CHANGE THE
   ORIGIN AND THE EYE POSITION FOR PROJECTION RESPECTIVELY.
   BY THE USE OF THESE TWO FUNCTIONS YOU CAN MOVE THE ORIGIN
   TO THE CENTER OF THE SCREEN  IF YOU DON'T LIKE IT IN THE
   LOWER LEFT CORNER.
     SETORG TAKES TWO OPTIONAL ARGUMENTS (DEFAULT IS 0),
   THEY ARE THE COORDINATES OF THE LOGICAL ORIGIN IN THE PHYSICAL
   COORDINATES OF THE TERMINAL YOU ARE USING. IF THE SCOPE YOU
   ARE USING IS A TEKTRONIX, THEN THE SCOPE'S COORDINATES RUN FROM
   0 TO 1023 AND THE PHYSICAL ORIGIN IS AT THE LOWER LEFT (0,0).
   IF YOU THEN WANT THE LOGICAL ORIGIN AT THE CENTER OF THE SCREEN
   A SETORG OF 512,512 WOULD DO IT. IF YOU ARE ON AN ARDS OR IMLAC
   THE PHYSICAL ORIGIN IS AT THE CENTER OF THE SCREEN AND THE
   COORDINATES RUN FROM -511 TO 511. TO SHIFT THE  COORDINATE SYSTEM
   TO WHAT THE TEKTRONIX USES, DO A SETORG OF -512,-512.
   WHEN YOU LOAD MIGS IT DEFAULTS TO THE LOGICAL ORIGIN AT LOWER
   LEFT OF THE SCREEN.
   SETPROJ TAKES THREE OPTIONAL ARGUMENTS; THE X AND Y COORDINATES
   OF THE EYE AND THE DISTANCE FROM THE EYE TO THE SCREEN. I FIND
   THAT THE CENTER OF THE SCREEN AND AN EYE DISTANCE OF 800 TO
   1024 LOOKS BEST. IF THE LOGICAL ORIGIN IS AT THE LOWER
   LEFT CORNER  THEN THE ARGUMENTS TO SETPROJ WOULD BE 512,512,1000. IF
   THE LOGICAL ORIGIN IS AT THE CENTER OF THE SCREEN THEN THE
   ARGS. WOULD BE 0,0,1000.
							PAGE  12




   EX 2.13.1
      FOR TEKTRONIX SCOPES
      ORIGIN AT THE LEFT

      <SETORG 0 0>
      <SETPROJ 511 511 1000>$

      ORIGIN AT CENTER

      <SETORG 512 512>
      <SETPROJ 0 0 1000>$

   EX 2.13.2
      FOR ARDS AND IMLACS
      ORIGIN AT THE LOWER LEFT

      <SETORG -511 -511>
      <SETPROJ 511 511 1000>$

      ORIGIN AT CENTER

      <SETORG 0 0 >
      <SETPROJ 0 0 1000>$
							PAGE  13




                         CHAPTER 3

                     PLOTTING FUNCTIONS

     IN THIS CHAPTER I WILL DISCUSS THE FUNCTIONS THAT MIGS PROVIDES
   FOR PLOTTING FUNCTIONS OF ONE VARIABLE. THE NEXT CHAPTER WILL
   COVER SURFACE PLOTTING. AT THE MOMENT MIGS HAS THREE FUNCTIONS
   THAT CONCERN THEMSELVES WITH PLOTTING, THEY ARE FNCTG, PARAG, AND
   POLRP. RESPECTIVELY THEY PERFORM LINEAR, PARAMETRIC, AND POLAR
   PLOTS OF THE FUNCTION THEY ARE GIVEN. IF YOU HAVE ANY FUNCTIONS
   THAT YOU THINK ARE USEFUL LEAVE ME MAIL, AND I WILL SEE ABOUT ADDING
   THEM TO MIGS.
     ONE WORD OF WARNING, AT THE PRESENT TIME THE ORIGIN MUST BE AT THE
   LOWER LEFT CORNER FOR THE PLOTTING FUNCTIONS TO WORK CORRECTLY.
   THIS BUG WILL BE FIXED IN THE NEXT VERSION OF MIGS WHICH IS COMING
   SOON.

   3.1 FNCTG

     THIS FUNCTION PRODUCES A LINEAR PLOT OF A FUNCTION OF ONE VARIABLE
   VERSUS THAT VARIABLE. FNCTG TAKES SIX ARGUMENTS, OF THESE THE LAST
   THREE ARE OPTIONAL. THE FIRST AND SECOND ARGUMENTS ARE THE LOWER
   AND UPPER LIMIT OF THE VARIABLE RESPECTIVELY (WHICH IS PLOTTED
   ALONG THE X AXIS). THIRD ARGUMENT MUST BE OF THE TYPE FUNCTION,
   OR SUBR, OR RSUBR. IT IS APPLIED TO THE VARIABLE AND PLOTTED ON THE
   Y AXIS. THE NEXT IS THE SCALE FACTOR. THIS IS A TWO ELEMENT LIST
   CONTAINING THE X AND Y SCALE. THE FIFTH IS A TWO ELEMENT LIST
   WHICH IS USED AS AN X,Y DISPLACEMENT OF THE PLOT. THE VALUE OF THIS LIST
   SHOULD BE (<* .5 <+ .XMAX .XMIN>> <* .5 <+ .YMAX .YMIN>>). THIS
   POINT IS MAPPED INTO THE CENTER OF THE SCREEN. THE SIXTH ARGUMENT IS
   THE NUMBER OF POINTS TO PLOT, IT MUST BE OF TYPE FIX AND THE DEFAULT
   IS SIXTY POINTS
     IF THE ABOVE SOUNDS COMPLICATED, JUST GIVE FNCTG THE FIRST THREE
   ARGUMENTS AND IT WILL DO THE REST (IT WILL AUTO-SCALE THE PLOT FOR 
   YOU). IF YOU STILL WANT AUTO-SCALING BUT WANT TO CHANGE THE NUMBER OF
   POINTS MAKE THE FOURTH AND FIFTH ARGUMENTS TWO ELEMENT LISTS OF 0.
      FNCTG RETURNS A TEN ELEMENT LIST THAT HAS USEFUL INFO ABOUT THE 
   PLOT IN IT. THIS IS PRINTED ON THE LEFT SIDE OF THE SCREEN UNLESS IT 
   IS SNARFED UP BY THE FUNCTION WHICH CALLED FNCTG.
							PAGE  14



   EX 3.1.1
      <FNCTG 0 9 #FUNCTION((X) <* .X <COS .X>>)>
      "THIS WILL PLOT THE FUNCTION F(X)=XCOS(X) FROM 0 TO 9"$
      
      <DEFINE BAR (Y) <* .Y .Y>>$
      <FNCTG -4.0 4.0 ,BAR>;"THIS WILL PLOT X**2 FOR X=-4 TO 4"$


   EX 3.1.2
      <FNCTG -4.0 4.0 ,BAR (0 0) (0 0) 120>;"THIS WILL PLOT THE
      FUNCTION BAR WITH 120 POINTS INSTEAD OF 60"$

   EX 3.1.3
      <FNCTG -1 1 ,BAR (800 800)(.5 .5) 100>;"THIS WILL PLOT
      BAR FROM -1 1, WITHOUT AUTO-SCALING AND WITH 100 POINTS"$

   3.2 PARAG
     THE FUNCTION, PARAG, PRODUCES A PARAMETRIC PLOT OF THE TWO
   FUNCTIONS, OR RSUBRS THAT PARAG IS GIVEN AS ARGUMENTS. PARAG
   TAKES 8 ARGUMENTS. THE FIRST FOUR ARE REQUIRED AND THE LAST FOUR
   ARE OPTIONAL. THE FIRST AND SECOND ARGUMENTS ARE THE LOWER AND 
   UPPER BOUNDS OF THE PARAMETER RESPECTIVELY. THE NEXT TWO ARGUMENTS
   ARE THE ATOMS WHOSE GVAL ,OR LVAL ARE THE FUNCTIONS YOU WANT 
   TO PLOT. THE FIFTH ARGUMENT IS THE NUMBER OF POINTS TO BE PLOTTED. IT
   MUST BE OF TYPE FIX AND THE DEFAULT IS 60 POINTS. THE NEXT ARGUMENT
   SELECTS THE SCALING MODE .IT MUST BE A STRING. PARAG HAS THREE 
   SCALING MODES, "SAS",SINGLE AUTO-SCALE SCALE THE PLOT SO ONE AXIS
   WILL FILL THE SCREEN. THIS IS THE DEFAULT MODE. IN "DAS",DOUBLE 
   AUTO-SCALING MODE, THE PLOT WILL BE SCALED SO
   IT FILLS THE SCREEN ALONG BOTH THE X AND Y AXES. ONE SHOULD NOTE THAT
   THIS MODE DOES NOT PRESERVE THE ANGLE BETWEEN LINES, I.E. AN
   ELLIPSE WILL BE STRETCHED INTO A CIRCLE. THE LAST MODE IS "NAS",
   NO AUTO-SCALE. IN THIS MODE YOU MUST USE THE NEXT TWO ARGUMENTS,
   THESE ARE BOTH TWO ELEMENT LISTS. THE FIRST ONE IS THE SCALE FACTORS
   FOR THE PLOT (THE X SCALE AND THE Y SCALE). THE LAST ONE
   IS AN X AND Y DISPLACEMENT FOR THE PLOT . THIS IS A TWO ELEMENT 
   LIST ALSO. I WOULD RECOMMEND THAT YOU STICK WITH "SAS" AND "DAS" MODES.

   EX 3.2.1
     <DEFINE A(X) <* .X <COS .X>>>$
     <DEFINE B(Y) <*  .Y <SIN .Y>>>;"MAKE TWO FUNCTIONS TO PLAY WITH"
     <PARAG 0.0 10.0 A B>;"PLOT A SPIRAL"$

   EX 3.2.2
     <PARAG 0.0 <* .66667 3.14159E3> A B 100>;"HERE IS A SIRO NEIL"

   EX 3.2.3
     <PARAG 1.0 100. A LOG 200 "DAS">;"
     THIS WILL PLOT A AGAINST LOG WITH 200 POINTS AND WILL EXPAND THE
     PLOT TO FULL SCALE ALONG BOTH AXES.
							PAGE  15


   3.3 POLRP
     THIS FUNCTION WILL PRODUCE A POLAR PLOT OF THE FUNCTION OR RSUBR
   THAT YOU GIVE IT. POLRP TAKES  SEVEN ARGUMENTS, OF WHICH THE FIRST
   THREE ARE REQUIRED AND THE REST ARE OPTIONAL. THE FIRST TWO ARGUMENTS
   ARE THE  LOWER AND UPPER LIMITS ON THETA RESPECTIVELY. THE NEXT 
   ARGUMENT IS THE ATOM WHOSE GVAL IS THE FUNCTION YOU WANT PLOTTED.
   THE LAST FOUR ARE ;THE NUMBER OF POINTS, THE MODE, SCALE, AND 
   THE X AND Y DISPLACEMENT. THESE ARGUMENTS ARE THE SAME AS THE LAST
   FOUR ARGUMENTS OF PARAG. AS A MATTER OF FACT, POLRP CALLS PARAG AND
   GIVES IT THE PARAMETRIC FORM OF YOUR  POLAR FUNCTION.

   EX 3.3.1
     <POLRP 0.0 9 A>;"THIS WILL PLOT A=X*COS(X) IN POLAR COORDINATES,
     FROM THETA EQUAL TO 0.0 TO 9.0 WITH 60 POINTS AND SINGLE AUTO-SCALING."$
							PAGE  16



                        CHAPTER 4
                  SURFACE PLOTTING

 THIS CHAPTER DESCRIBES HOW TO USE MIGS'S BUILT IN SURFACE PLOTTING
ABILITY. THERE ARE FOUR FUNCTIONS FOR SURFACE PLOTTING. THEY ARE
SFXYP, MIJPL, M3D, AND M3DSK. SFXYP WILL PLOT A FUNCTION OF TWO
VARIABLES FOR YOU. MIJPL WILL PLOT A SQUARE MATRIX , AND M3D(M3DSK)
IS USED BY BOTH OF THESE FUNCTIONS TO DO THE HIDDEN LINE ELIMINATION
AND THE DISPLAY. AT THE PRESENT TIME THE ORIGIN MUST BE AT THE
LOWER LEFT CORNER FOR SURFACE PLOTTING. NOTE THAT IF YOU ARE ON
AN IMLAC, DON'T TRY TO HAVE A DISPLAY OF MORE THAN 37X37 VECTORS OR
YOU WILL RUN OUT OF CORE.

4.1 SFXYP
 THIS FUNCTION PLOTS FOR YOU ANY FUNCTION OF TWO INDEPENDENT VARIABLES
(I.E. Z=F(X,Y)). IT WILL AUTO-SCALE THE PLOT TO WHAT IT THINKS IS THE
BEST POSSIBLE DISPLAY. THE USER HAS THE OPTION OF PICKING THE 
RESOLUTION, AND WHETHER THE OUTPUT GOES TO YOUR TERMINAL OR
DISK(THIS OPTION IS RARELY USED NOW THAT THE DISPLAY COMPILER
IS WORKING). THE CALL TO SFXYP IS
<SFXYP .XL .XH .YL .YH FUNCT .PARAM RES .DSK .FILE>.
THE FIRST 5 ARGUMENTS ARE REQUIRED THE REST ARE OPTIONAL. XL AND XH
ARE THE LIMITS ON X (LOW AND HIGH). THE Y LIMITS ARE YL , YH.
THE X AND Y LIMITS CAN BE FIXED OR FLOATS. FUNCT IS
THE ATOM WHOSE GVAL(LVAL) IS THE FUNCTION, RSUBR, FSUBR, OR SUBR THAT
YOU WANT TO PLOT. PARAM IS AN OPTIONAL LIST OF EXTRA ARGUMENTS 
FOR THE FUNCTION. IF THE FUNCTION DOESN'T NEED ANY ,BUT YOU
WANT TO HAVE MORE ARGUMENTS TO SFXYP (SET THE RESOLUTION TO SOMETHING
OTHER THAT THE DEFAULT) MAKE IT AN EMPTY LIST. RES IS THE RESOLUTION
THAT WILL BE USED. THE DEFAULT IS 60. THIS MEANS THAT THE FUNCTION IS 
PLOTTED ON A 60X60 GRID. RES MUST BE A FIX, AND THE TIME THAT SFXYP
TAKES GOES UP AS THE SQUARE OF RES, SO BE FOREWARNED. DSK DETERMINES
WHETHER SFXYP DOES ITS OUTPUT TO THE TERMINAL. IT CAN BE A TRUE
(ANYTHING THAT ISN'T FALSE) ,OR A FALSE (THIS IS THE DEFAULT). IF IT IS 
TRUE THE OUTPUT GOES TO A DISK FILE, AND THE LAST ARG BETTER BE A
STRING WHICH IS THE NAME OF THE FILE. IF YOU DO THIS YOU CAN LOOK AT 
THIS FILE WITH DSKIMAGE.
							PAGE  17



EX 4.1.1
<DEFINE FOOBAR (X Y "AUX" (X1 <+ .X 1.0E-7>) (Y1 <+ .Y 1.0E-7>)
			  (R <SQRT <+ <* .X1 .X1><* .Y1 .Y1>>>))
	</ <SIN <* 4.0 .R>> .R>>$

<SFXYP -6 6 -6 6 FOOBAR>;"TRY THIS IT IS PRETTY"$
<SFXYP -6 6 -6 6 FOOBAR () 37>;"THIS IS FOR AN IMLAC"

EX4.1.2
<SFXYP -6 6 -6 6 FOOBAR () 100>
;"THIS WILL PLOT FOOBAR ON A 100X100 GRID."

4.2 MIJPL
 THIS FUNCTION TAKES AN N BY M MATRIX AND DOES A SURFACE PLOT WITH 
HIDDEN LINE ELIMINATION. BY MATRIX I MEAN AN OBJECT OF THE FORM
<VECTOR [REST <VECTOR [REST <OR FIX FLOAT>]>]>. THE INNER VECTOR
IS THE ROW OR X AXIS OF THE PLOT. THE OUTER VECTOR WOULD BE THE
COLUMNS OR THE Y DIRECTION OF THE PLOT. IF YOU DON'T UNDERSTAND
WHAT I SAID LOOK AT THE EXAMPLES OR READ DECL SYNTAX (I THINK ITS IN
.INFO.). IF YOU STILL DON'T ASK ME FOR HELP. THE Z IS THE VALUE OF THE
MATRIX ELEMENT. THE CALL TO MIJPL LOOKS LIKE
<MIJPL .MATRIX .DSK .FILE>.
ALL BUT THE FIRST ARGUMENT ARE OPTIONAL. MATRIX IS THE TYPE OF MUDDLE
OBJECT THAT I WAS JUST TALKING ABOUT. DSK CAN BE AN ATOM OR FALSE, ITS 
DEFAULT IS FALSE. IF DSK IS TRUE THEN MIJPL WILL PUT ITS OUTPUT ON
DISK (AS I SAID BEFORE IT IS MUCH BETTER TO MAKE AN MCELL OUT OF IT
AND PPRINT IT OUT). IF YOU DO THIS YOU CAN LOOK AT THE PLOT WITH
DSKIMAGE. FILE IS A STRING THAT IS THE NAME OF THE DSKFILE YOU WANT.
IT DEFAULTS TO <SNAME>;M3D MIGPUT.

EX 4.2.1
<SET MAT [ [1 1 1 1 1 1 1 1 1]
	    [1 3 3 3 3 3 3 3 1]
	    [1 3 9 9 9 9 9 3 1]
	    [1 3 9 27 27 27 9 3 1]
	    [1 3 9 27 81 27 9 3 1]
	    [1 3 9 27 27 27 9 3 1]
	    [1 3 9 9 9 9 9 3 1]
	    [1 3 3 3 3 3 3 3 1]
	    [1 1 1 1 1 1 1 1 1]]>;"THIS IS WHAT I MEANT BY MATRIX"$
<MIJPL .MAT>$ ;"I DON'T KNOW WHAT THIS LOOKS LIKE BUT IT MIGHT BE 
INTERESTING. <1<1 .MAT>> IS THE POINT THAT IS CLOSEST TO YOU AND
THE FARTHEST TO THE LEFT."$
							PAGE  18




4.3 M3D AND M3DSK
THESE TWO FUNCTIONS DO THE ACTUAL HIDDEN LINE ELIMINATION FOR SFXYP
AND MIJPL. M3D SENDS ITS OUTPUT TO YOUR TERMINAL AND M3DSK OUTPUTS
TO A DSK FILE. BOTH FUNCTIONS HAVE THE SAME FIRST ARGUMENT MATRIX.
THIS IS A VECTOR OF VECTORS OF TYPE FIX.THE VALUES OF THE FIXES
SHOULD BE FROM 0 TO 420, OR YOU WILL DRAW THE BEAM OFF THE SCOPE
AND WEIRD THINGS WILL HAPPEN. THE CALL TO M3D LOOKS LIKE
<M3D .MATRIX>
WHERE MATRIX IS THE MUDDLE OBJECT I DESCRIBED ABOVE. THE CALL FOR
M3DSK IS
<M3DSK .MATRIX .FILE>
FILE IS AN OPTIONAL ARGUMENT THAT DEFAULTS TO <-SNAME->;M3D MIGPUT
. BE CAREFUL IF YOU GIVE IT A FILE NAME BUT NO SNAME IT WILL
USE WHAT EVER '<SNAME>$' WILL RETURN. DSKIMAGE CAN BE USED TO VIEW THE
 FILE ON YOUR TERMINAL

EX 4.3.1

<SET I -1>
<SET FOO 
     <IVECTOR 60
	       <IVECTOR 60
			 '<FIX <+ 200
				  <* 175 <SIN <* %</ 6.28 60>
					  <SET I <+ .I 1>>>>> >> >>>>
;"THIS WILL BUILD THE MATRIX"$

<M3D .FOO>$

EX 4.3.2

<M3DSK .FOO "ZORCH;GLEEP 1">;"THIS WILL WRITE OUT WHAT M3D DREW IN
THE ABOVE EXAMPLE TO DSK:ZORCH;GLEEP 1"$
<DSKIMAGE "ZORCH;GLEEP 1">;"THIS WILL DISPLAY IT ON YOUR
TERMINAL"$
							PAGE  19




                     CHAPTER 5
             THE DISPLAY COMPILER AND PROCESSOR

THIS IS THE PART OF MIGS THAT MAKES IT DIFFERENT FROM THE AVERAGE
GRAPHICS PACKAGE. BY USE OF THE SOFTWARE DISPLAY COMPILER AND PROCESSOR
MIGS CAN EMULATE MANY OF THE FEATURES OF THE E&S LDS-1.ONCE ONE HAS 
DEFINED A PICTURE OR MCELL AS I CALL IT, YOU CAN TRANSLATE IT, ROTATE 
IT, SCALE IT, AND MAKE UP YOUR OWN TRANSFORMS TO APPLY TO THE MCELL IN
2 OR 3 SPACE. ALSO ONCE DEFINED AN MCELL CAN BE USED AS A
SUBPICTURE IN ANY OTHER MCELL. THIS SUBPICTURING AND TRANSFORMING
CAN BE CARRIED OUT TO ANY LEVEL. THAT IS EXCEPT INFINITE(WHICH WOULD 
GIVE MUDDLE A BAD STOMACH ACHE, SO MIGS DOESNT LET YOU DO THAT.). THIS
FEATURE IS GOOD FOR CATCHING INFINITE RECURSION, THAT HAPPENED BY
MISTAKE.THE ONLY REAL LIMIT OF WHAT YOU CAN DO WITH MIGS IS YOUR IMAGINATION.
 NOTICE THAT IN THIS SECTION OF THIS MANUAL, YOU DON'T HAVE TO
WORRY ABOUT DRAWING OFF OF THE VISIBLE PART OF THE SCREEN, WHEN USING
THE DISPLAY COMPILER. THAT IS BECAUSE THE INTERNAL (SOFTWARE)
CLIPPING-DIVIDER TAKES CARE OF ANYTHING THAT ISN'T VISIBLE. ALSO ALL OF
THE TWO DIMENSIONAL PRIMITIVES WILL HANDLE THREE DIMENSIONAL DATA
CORRECTLY. WHEN USING THE DISPLAY COMPILER THE ARGUMENTS TO THE 
PRIMITIVES CAN BE FIXED OR FLOATS.


5.1 MCELL
THE FUNCTION MCELL MAKES AN MCELL (PICTURE) FOR YOU AND THEN RETURNS
"DONE". THIS WILL SOON BE CHANGED TO THE ATOM LESS TRAILER, WHOSE LVAL
IS THE MCELL THAT WAS JUST CREATED.
 MCELLS ARE HIDDEN ON THE OBLIST MCELLS(THE-NAME-YOU-GAVE-IT!-MCELLS).
LET ME EXPLAIN THE CALL TO MCELL AND IT WILL BECOME CLEAR HOW TO USE IT.
<MCELL NAME () () .DIMENSION .BLANK <-BODY-> >
NAME IS THE ATOM WHOS PNAME IS THE NAME OF THE MCELL TO BE CREATED.
THE NEXT TWO ARGUMENTS DON'T DO ANYTHING YET ,BUT THEY BETTER BE THERE OR ELSE
ERROR. THERE HAVE TO BE LISTS (AT THE PRESENT TIME EMPTY ONES ARE FINE).
ONE OF THE LISTS WILL MOST PROBABLY BE THE COLOR OF THE MCELL, WHEN
COLOR GRAPHS TERMINALS BECOME AVAILABLE.
 DIMENSION IS A TRUE(ATOM) OR FALSE. IF IT IS TRUE THEN THE MCELL IS
THREE DIMENSIONAL, IF IT IS FALSE THE MCELL IS TWO DIMENSIONAL. BLANK
IS A TRUE OR FALSE. IF IT IS TRUE THE MCELL WILL NOT BE VISIBLE WHEN
YOU DISPLAY IT.
 BODY IS THE MOST INTERESTING ARG TO THIS FUNCTION. IT CAN BE ANY MUDDLE
OBJECT OR OBJECTS. MCELL REALLY DROPS INTO ITS OWN EVAL(LIKE THE ONE THAT
YOU ARE IN, WHEN IN THE NORMAL MUDDLE READ EVAL PRINT LOOP.)
IN THIS ENVIRONMENT ALL THE MIGS PRIMITVES PUT THEIR OUTPUT INTO THE
MCELL. BECAUSE OF THIS IT'S A GOOD IDEA TO HAVE SOME MIGS PRIMITIVES IN
THE BODY OF THE CALL TO MCELL, OR YOU WILL GET AN MCELL WITH NO DATA IN
IT.
							PAGE  20




EX 5.1.1

<MCELL TRIP () () 3D <>
	<REPEAT ((8PI <* 8.0 3.14159>)
		 (T .8PI)
		 (DT </ 50.0 .8PI>)
		 (SF </ 500.0 .8PI>))
	     <CALL C <ROTZ <- .T>>
		     <XLATE <* .SF .T <COS .T>>
			    <* .SF .T <SIN .T>>
			    <- 10000 <* 20 .SF .T>> >>
	     <COND (<L? <SET T <- .T .DT>> 0> <RETURN T>)> >>

<MCELL C () () 3D <>
	<CUBE -50 -50 -50 50 50 50>>;" I KNOW THAT THIS EXAMPLE
IS HARD TO UNDERSTAND, BUT I WILL EXPLAIN IT IN THE REST OF THE 
CHAPTER. I WANTED TO SHOW OFF SOME OF THE POWER OF MCELL. I AM
ASSUMING THAT RRS;TEST GRAPHS HAS BEEN FLOADED."$

EX 5.1.2

<MCELL TRIANGLE () () <> <>
	<MOVE 0 0>
	<DRAW 600 500>
	<DRAW 400 650>
	<DRAW 0 0> >;"THIS WILL CREATE AN MCELL CALLED TRIANGLE, WITH A
                      TRIANGLE IN IT.
		      NOTE THAT IT IS TWO DIMENSIONAL NOT LIKE THE LAST
		      ONE"

IT ISN'T NECESSARY TO UNDERSTAND WHAT I AM GOING TO SAY NEXT TO BE
ABLE TO USE THE DISPLAY COMPILER AND PROCESSER. FOR THE HACKERS THAT
WANT TO KNOW WHAT AN MCELL(MUDDLE OBJECT) IS I'LL DESCRIBE IT NOW. 
AN MCELL IS AN OBJECT OF PRIMTYPE LIST AND TYPE MCELL.
 THE DECL FOR IT IS
<LIST LIST
      LIST
      [2 <OR ATOM FALSE>]
      [REST <LIST FIX [REST <OR FIX FLOAT FORM ATOM>]>] >.
THE FIRST FIX IN <2<2<5 .DECL>>> IS THE OP-CODE FOR THE DISPLAY
PROCESSOR. THE REST OF IT IS DEPENDENT ON THE OP-CODE AND WHETHER IT
IS A 2 OR 3 DIMENSIONAL MCELL.
SOME OF THE OP-CODES ARE GIVEN BELOW

OPCODE    MNEMONIC
____________________
0	  MOVE
1	  DRAW
-1	  CALL
2	  SETPROJ
3	  SETORG
4	  SETCLIP
5	  PAGE
6	  HCOPY
7	  DASH-ON
8	  DASH-OFF
							PAGE  21




EX 5.1.3
IF YOU ARE STILL INTERESTED HERE IS WHAT MCELL MADE FOR TRIP AND C


<SET TRIP!-MCELLS
     '#MCELL (()
	      ()
	      3D
	      #FALSE ()
	      (-1
	       C!-MCELLS
	       <ROTZ -25.132719>
	       <XLATE 500.0 -0.10440012E-1 0.0000000>)
	      (-1
	       C!-MCELLS
	       <ROTZ -24.630065>
	       <XLATE 429.38532 -236.06818 200.0>)
                    .
                    .
		    .
	      (-1
	       C!-MCELLS
	       <ROTZ -0.11920928E-5>
	       <XLATE 0.23715954E-4 0.28271621E-10 9999.9995>))>

<SET C!-MCELLS
     '#MCELL (()
	      ()
	      3D
	      #FALSE ()
	      (0 -50 -50 -50)
	      (1 -50 50 -50)
	      (1 50 50 -50)
	      (1 50 -50 -50)
	      (1 -50 -50 -50)
	      (0 -50 -50 50)
	      (1 -50 50 50)
	      (1 50 50 50)
	      (1 50 -50 50)
	      (1 -50 -50 50)
	      (0 -50 -50 -50)
	      (1 -50 -50 50)
	      (0 -50 50 -50)
	      (1 -50 50 50)
	      (0 50 50 -50)
	      (1 50 50 50)
	      (0 50 -50 -50)
	      (1 50 -50 50))>

NOW THAT YOU KNOW WHAT A MCELL IS, I SHOULD SHOW WHAT TO DO ONCE
YOU MAKE ONE.
							PAGE  22




5.2 DISP
 THIS FUNCTION IS USED TO DISPLAY AN MCELL. BESIDES DISPLAYING AN MCELL
YOU CAN APPLY ALL THE TOP LEVEL TRANSFORMS YOU WANT. I WILL TALK
ABOUT TRANSFORMS A LITTLE LATER IN THIS MANUAL, SO BEAR WITH ME A
LITTLE LONGER. THE INCANTATION FOR DISP IS
<DISP <-MCELL-> <-TRANS1-> ... <-TRANSN->>.
<-MCELL-> IS THE PNAME OF THE ATOM ,LESS TRAILER (!-MCELLS),
WHOS LVAL IS THE MCELL. <-TRANS1-> THROUGH <-TRANSN-> ARE THE OPTIONAL
TRANSFORMS TO APPLY TO THE MCELL.

EX 5.2.1
<DISP TRIANGLE>;"THIS WILL DISPLAY THE 2 DIMENSIONAL TRIANGLE I MADE
        	 WHEN I WAS DISCUSSING THE MCELL FUNCTION. NOTICE THAT I
		 DIDNT HAVE TO TELL DISP THAT IT WAS 2D, BECAUSE THAT
		 INFORMATION IS CONTAINED IN THE MCELL."

EX 5.2.2
<PAGE>;"CLEAR THE SCREEN"$
<DISP TRIANGLE <ROTZ %</ 3.14159 4>>>;"DISPLAY THE TRIANGLE AGAIN,
				       BUT ROTATE IT 45 DEGREES"$

EX 5.2.3
<REPEAT ((T 0.0) (DT </ 6.28 20.0>) (2PI 6.28))
	<PAGE>;"CLEAR THE SCREEN"
	<SLEEP 2>;"WAIT"
	<DISP TRIANGLE <ROTZ <SET T <+ .T .DT>>>>;"DISPLAY IT AND 
						   ROTATE IT BY
						   T+DT."
	<SLEEP 2>;"SLEEP FOR 2 SECONDS,SO YOU CAN LOOK AT IT."
	<COND (<G=? .T .2PI> <RETURN "DONE">)>>;"IF T<= 2PI THEN
						 DO IT AGAIN"

EX 5.2.4
<DISP TRIP <ROTY </ 3.14159 2>><XLATE 500 350 50>>;"
DISPLAY THE 'TRIP' MCELL THAT WE MADE EARLIER. ROTATE IT ABOUT THE
Y AXIS AND TRANSLATE IT TO 500,350,50."$

5.3 CALL
CALL IS THE FUNCTION THAT ONE WOULD USE TO INVOKE A SUBPICTURE(ANOTHER
MCELL),WHILE YOU ARE CREATING AN MCELL. THE USE OF CALL IS VERY
SIMILAR TO DISP, EXCEPT IT IS USED IN AN MCELL. THE MCELL THAT YOU CALL
DOESNT HAVE TO BE DEFINED, UNTIL YOU DISPLAY THE MCELL THAT THE CALL IS IN.
THE APPLICATION OF CALL LOOKS LIKE
<CALL <-MCELL-> <-TRANS1-> ... <-TRANSN-> >.
WHERE <-MCELL-> IS THE ATOM (LESS TRAILER) WHOS LVAL IS THE MCELL YOU
WANT. <-TRANS1-> THROUGH <-TRANSN-> ARE THE OPTIONAL TRANSFORMS TO
APPLY TO THE MCELL.
							PAGE  23



EX 5.3.1
<MCELL GLEEP () () <> <>
	<CALL TRIANGLE >;"CALL TRIANGLE WITH NO TRANSFORMS"
	<CALL TRIANGLE <XLATE 300 10>>;"CALL TRIANGLE AND TRANSLATE IT
				        300 ,10 SCREEN UNITES."
	<CALL TRIANGLE  <XLATE -300 -325>;"MOVE IT AROUND THE ORIGIN"
			   <SCALE .25 .25>;"MAKE IT 1/4 THE SIZE "
			   <ROTZ %</ 3.14159 6>>;"ROTATE IT 30 DEGREES"
			   <XLATE 300 200>;"MOVE IT TO 300,200">>$

<DISP GLEEP>;"LETS SEE IT"

5.4 XLATE
 THIS IS THE START OF WHERE I WILL DESCRIBE THE TYPE OF TRANSFORMATIONS
THAT YOU CAN APPLY TO AN MCELL, SO I BETTER DESCRIBE THE TRANSFORMATION
SYSTEM THAT I USE. THE METHOD, THAT I USE, IS HOMOGENEOUS 
COORDINATES. IF YOU AREN'T SURE WHAT THAT IS I WOULD RECOMMEND THAT
YOU READ ABOUT IT IN PRINCIPLES OF INTERACTIVE COMPUTER GRAPHICS BY NEUMAN 
AND SPROULL. FOR A 3D POINT I USE A FOUR ELEMENT ROW VECTOR. A
2D POINT IS A THREE VECTOR. THE LAST ELEMENT IN THE VECTOR IS THE
SCALE FACTOR, WHICH MIGS ALWAYS KEEPS EQUAL TO ONE.
 A TRANSFORM IS A 4X4 MATRIX FOR A THREE DIMENSIONAL POINT, AND A
3X3 MATRIX IF THE POINT IS 2D. THE VECTOR IS ALWAYS ON THE LEFT SIDE
OF THE MATRIX DURING MULTIPLICATION. MATRICES ARE CONCATENATED BY
MY MATRIX MULTIPLIER FOR COMPOUND TRANSFORMATIONS. THE COMPOUND
TRANSFORMATIONS ARE SAVED ON AN INTERNAL STACK IN MIGS, SO THEY
DON'T HAVE TO BE RECALCULATED WHEN YOU POP UP A LEVEL IN SUBPICTURES.
 THIS WAS MEANT FOR THE HACKER THAT WAS INTERESTED IN HOW MIGS HANDLED
THIS.YOU DON'T HAVE TO PAY ANY ATTENTION TO THIS IF YOU ARE
JUST INTERESTED IN USING MIGS TO DRAW PRETTY PICTURES.

 XLATE IS THE TRANSFORM THAT YOU USE TO MOVE THE DISPLAY OF AN
MCELL TO A DIFFERENT LOCATION ON THE SCOPE. XLATE LIKE ALL OF
THE TRANSFORMS CAN BE USED IN DISP TO CAUSE A TOP LEVEL TRANSFORM
TO BE APPLIED TO THE MCELL( PICTURE ), OR IN A CALL TO A SUBPICTURE.
THE CALL TO XLATE LOOKS LIKE
<XLATE .X .Y>
FOR A TWO DIMENSIONAL MCELL. FOR A 3D MCELL IT IS
<XLATE .X .Y .Z>.
THE ARGUMENTS CAN BE FIX OR FLOAT. ACTUALLY ANYTHING THAT 
EVALS TO A FIX OR FLOAT. X IS THE HORIZONTAL DISPLACEMENT AND
Y IS THE VERTICAL. Z IS ONLY USED IN 3D MCELLS. IT IS THE DISPLACEMENT
INTO AND OUT OF THE SCREEN. ITS DEFAULT VALUE IS 0 (REMEMBER PLUS
Z IS INTO THE SCREEN).
							PAGE  24



EX 5.4.1
<DISP TRIP <XLATE 500 400 25>>;"DISPLAY TRIP AND MOVE ITS CENTER
				  TO 500,400,25. THAT IS THE CENTER
				  OF THE SCREEN AND 25 UNITS IN
				  TO IT"$

<MCELL BLECH ()()<><> ;"MAKE A 2D MCELL"
	.
	.
	.
	<CALL TRIANGLE <XLATE  -100 300>>>;"CALL AND TRANSFORM THE
					    SUBPICTURE TRIANGLE"$
5.5 SCALE
 SCALE DOES EXACTLY WHAT ITS NAME IMPLIES. YOU CAN ADJUST THE X,Y,
AND Z SIZE OF AN MCELL TO ANYTHING YOU WANT. IF ONE OF THE
SCALE FACTORS IS LESS THAN ONE THEN THE MCELL IS SQUASHED ALONG
THAT AXIS. IF IT IS GREATER THAN ONE THEN THE MCELL IS EXPANDED
ALONG THAT AXIS. IF THE SCALE FACTOR IS ONE THEN NOTHING IS DONE.
 THE CALL TO SCALE LOOKS LIKE <SCALE .X .Y .Z>. WHERE X IS THE X 
COMPONENT OF THE SCALE FOR THE MCELL TO BE DISPLAYED.THE Y AND Z 
COMPONENTS ACT
LIKE THE X COMPONENT BUT ARE FOR THE Y AND Z AXIS. Z IS USED IF THE
MCELL IS THREE DIMENSIONAL. X,Y, AND Z CAN BE ANYTHING THAT
EVALS TO A FIX OR A FLOAT. IF Y OR Z ISN'T GIVEN THEY WILL DEFAULT
TO THE VALUE OF X. IF Z IS GIVEN IN A 2D MCELL IT IS IGNORED.
 
EX 5.5.1
<DISP TRIANGLE <SCALE .5>>;"DISPLAY THE TRIANGLE AGAIN, BUT
			    SCALE THE WHOLE WORLD TO ONE HALF ITS SIZE"

5.6 ROTZ
THIS TRANSFORM IS USED TO ROTATE AN MCELL ABOUT THE Z OF THE SCOPE.
BECAUSE THE POSITIVE Z AXIS POINTS INTO THE SCREEN A POSITIVE
ROTATION MOVES CLOCKWISE. THE ARGUMENT TO ROTZ IS IN RADIANS AND
MUST BE OF TYPE FLOAT. ROTZ IS THE LAST OF THE TRANSFORMS ,SO FAR
LISTED THAT WILL WORK ON TWO OR THREE DIMENSIONAL MCELLS. THE CALL
TO ROTZ IS <ROTZ .T>, WHERE THE LVAL OF T IS A FLOAT.

EX 5.6.1
<DISP TRIANGLE <XLATE -300 -325>;"CENTER IT AT THE ORIGIN."
	       <ROTZ %</ 3.14159 4>>;"ROTATE IT 45 DEGREES"
		<XLATE 500 400>;PUT IT AT THE CENTER OF THE SCREEN">$
							PAGE  25




5.7 ROTX
 ROTX IS QUITE SIMILAR TO ROTZ, EXCEPT THAT IT ONLY WORKS ON THREE
DIMENSIONAL MCELLS. ROTX WILL ROTATE AN MCELL ABOUT THE X AXIS. ITS
ARGUMENT IS A FLOAT WHO IS THE ANGLE IN RADIANS THAT YOU WANT TO
ROTATE THE MCELL BY.

5.8 ROTY
 THIS TRANSFORM IS IDENTICAL TO ROTX AND ROTZ, BUT IT PERFORMS THE 
ROTATION ABOUT THE Y AXIS. AGAIN ROTY'S ARGUMENT IS OF TYPE FLOAT
AND IS THE ANGLE IN RADIANS. AT THIS TIME YOU SHOULD BE ABLE TO
UNDERSTAND EXAMPLE 5.1, THE TRIP MCELL.

5.9 CREATING YOUR OWN TRANSFORMS
 A TRANSFORM IS A FUNCTION OR RSUBR THAT RETURNS A 3X3 MATRIX IF
IT IS A 2D MCELL OR A 4X4 MATRIX IF ITS A 3D MCELL. THE DATA STRUCTURE
FOR THIS MATRIX IS
#DECL ((MATRIX) <VECTOR FIX FIX <VECTOR [REST FLOAT]>>).
THE TWO FIXES ARE THE DIMENSION OF THE MATRIX. THE FLOATS ARE THE
MATRIX ELEMENTS.
 I WILL NOW GIVE TWO EXAMPLES THAT WILL MAKE WHAT I JUST SAID
MUCH CLEARER. THE FIRST ONE IS THE XLATE TRANSFORM IN MIGS.

EX 5.9.1
<DEFINE XLATE (X1 Y1 "OPTIONAL" (Z1 0.0)
		     "AUX" (X <FLOAT .X1>)
			   (Y <FLOAT .Y1>)
			   (Z <FLOAT .Z1>))
	<COND (<1 .3DSK!-DISPCOM> ;"TRUE IF THE MCELL 3D"
	       [4 4 [1.0 0.0 0.0 0.0
	    	     0.0 1.0 0.0 0.0
		     0.0 0.0 1.0 0.0
		     .X  .Y  .Z  1.0]])
	      (T ;"MUST BE 2D"
		 [3 3[1.0 0.0 0.0
		      0.0 1.0 0.0
		      .X  .Y  1.0]])>>

 FOR THE SECOND EXAMPLE I WILL PRESENT THE ZOOM TRANSFORM. THIS
TRANSFORM ONLY WORKS ON 3D MCELLS. IT IS THE ONE THAT I
FORGOT WHEN I WROTE MIGS.
 
EX 5.9.2
<DEFINE ZOOM (ZF) ;"MAKE LIKE A ZOOM LENS"
	[4 4[1.0 0.0 0.0 0.0
	     0.0 1.0 0.0 0.0
	     0.0 0.0 1.0 </ 1.0 .ZF>
	     0.0 0.0 0.0 1.0]]>
							PAGE  26




5.10 SETCLIP
 THIS FUNCTION IS USED TO SET THE WINDOW FOR THE CLIPPING-DIVIDER.
THE CLIPPING-DIVIDER WILL SOON BE CHANGED TO FIX A KNOWN BUG,
IF THE OBJECT IS BEHIND YOU IT WILL TURN INSIDE OUT AND BE VISIBLE ON
THE SCREEN. SO WHEN THE CLIPPING-DIVIDER IS FIXED, SETCLIP WILL MOST
LIKELY BE CHANGED. THEREFORE, THIS DESCRIPTION IS ONLY TEMPORARY.
THE CALL TO SETCLIP IS
<SETCLIP .LX .RX .BY .TY>$.
ALL OF THE ARGUMENTS ARE OPTIONAL. IT DEFAULTS A WINDOW THAT IS THE BOX
[0,0 0,1023 1023,1023 1023,0]. LX IS THE LEFT LIMIT, RX IS THE RIGHT
LIMIT, BY IS THE BOTTOM OF THE VISIBLE SCREEN, AND TY IS THE TOP.

EX 5.10.1
<SETCLIP 0 1023 0 1023> ;"THE ORIGIN IS AT THE LOWER LEFT CORNER
			  AND THE WINDOW IS THE WHOLE SCREEN"$

<SETCLIP -510 510 -510 510> ;"THE ORIGIN IS AT THE CENTER OF THE
			      SCREEN AND THE WINDOW IS THE WHOLE
			      SCREEN"$
							PAGE  27




APPENDICIES
A.1 SOME EXAMPLES OF THE USE OF MIGS PRIMITIVES

A.1.1


<DEFINE SPIRAL ("AUX" A B T X Y)	;"THIS IS THE CLASSIC SPIRAL PROGRAM.
					IT USES THE PARAMETRIC EQUATION:
					(X,Y)=(T*COS(T),T*SIN(T))" 
	<REPEAT ((A <RANDOM 3927>))
		<PAGE>
		<SLEEP 2>
		<SET A </ <RANDOM> 1000000.0>>
		<SET A <* <SIN .A> 314.15900>>
		<SET B <- 0.0000000 .A>>	;"DELTA T IS PICKED AT RANDOM"
		<SET T <IUVECTOR 100 '<SET B <+ .B .A>>>>
		<SET X <MAPF ,UVECTOR #FUNCTION ((T) <* .T <COS .T>>) .T>>
		<SET Y <MAPF ,UVECTOR #FUNCTION ((T) <* .T <SIN .T>>) .T>>
		<SET A
		     <MAX !<MAPF ,UVECTOR ,ABS .X!> !<MAPF ,UVECTOR ,ABS .Y!>>>
		<PLOTV <MAPF ,UVECTOR
			     #FUNCTION ((X) <FIX <+ 501 <* .X </ 400 .A>>>>)
			     .X>
		       <MAPF ,UVECTOR
			     #FUNCTION ((Y) <FIX <+ 401 <* .Y </ 400 .A>>>>)
			     .Y>>	;"PLOTV IS USED TO PLOT THE PATTERN"
		<SLEEP 5>>>

A.1.2

<DEFINE THIS ()
	<THAT 0 0 1020 0 1020 1020>
	<THAT 1020 0 1020 1020 0 1020>
	<THAT 1020 1020 0 1020 0 0>
	<THAT 0 1020 0 0 1020 0>
	<THAT 510 0 510 510 1020 510 25>
	<THAT 510 1020 510 510 1020 510 25>
	<THAT 510 1020 510 510 0 510 25>
	<THAT 510 0 510 510 0 510 25>>

<DEFINE THAT (X1 Y1 X2 Y2 X3 Y3 "OPTIONAL" (INK 51) "AUX" X1I X2I Y1I Y2I)
	";THAT DRAWS A HYPERBOLA AS A RULED SURFACE"
	<SET X1I </ <- .X2 <FLOAT .X1>> .INK>>
	<SET Y1I </ <- .Y2 <FLOAT .Y1>> .INK>>
	<SET X2I </ <- .X3 <FLOAT .X2>> .INK>>
	<SET Y2I </ <- .Y3 <FLOAT .Y2>> .INK>>
	<LINE3D .X1 .Y1 0 .X2 .Y2 0>
	<REPEAT ()
		<COND (<L? <SET INK <- .INK 1>> 0> <RETURN ,NULL>)>
		<LINE3D <SET X1 <+ .X1 .X1I>>
		      <SET Y1 <+ .Y1 .Y1I>> 0
		      <SET X2 <+ .X2 .X2I>>
		      <SET Y2 <+ .Y2 .Y2I>> 0>>>
							PAGE  28




A.2 EXAMPLES OF THE DISPLAY COMPILER AND PROCESSOR

A.2.1 THIS EXAMPLE CREATES AN OBJECT (I CALL POLY-THING) AND THEN
      ROTATES AND DISPLAYS IT.

<MCELL P0 ()()3D<> 	;"HAS A HEXAGON CENTERED ON 3 LINES THAT ARE
			  PERPENDICULAR TO EACH OTHER."
	<CIRCLE 0 0 50 6>
	<LINE -45 0 45 0>
	<LINE 0 45 0 -45>
	<LINE 0 0 -45 0 0 -45>>	;"LINE WHEN USED IN THE DISPLAY COMPILER
				  CAN BE USE FOR 2 OR 3 DIMENSIONS"

<MCELL P1 ()()3D<>	"MAKE A DUMBBELL OUT OF TWO HEXAGONS AND A LINE"
	<CALL P0 <XLATE 0 0 100>>
	<LINE 0 0 100 0 0 -100>
	<CALL P0 <XLATE 0 0 -100>>>

<MCELL P2 ()()3D<>	;"STICK THREE DUMBELLS TOGETHER TO MAKE A POLY-THING"
	<CALL P1 <ROTX 1.57>>
	<CALL P1 <ROTY 1.57>>
	<CALL P1>>

<SETORG 0 0>;"IF YOU ARE ON AN IMLAC"
<SETPROJ 0 0 855>
<SETCLIP -510 510 -510 510>;"MOVE THE ORIGIN TO THE CENTER OF THE SCREEN"

<DEFINE RPT ()		;"ROTATE AND DISPLAY THE P2 MCELL OR POLY-THING"
	<REPEAT ((I .1) (X 0.0)
		<SLEEP 2>
		<DISP P2 <SCALE 2><ROTX .X><ROTY <* 1.4 .X>>>
		<COND (<G? <SET X <+ .X .I>> 6.28> <RETURN FOOBAR>)>
		<SLEEP 3>
		<PAGE>>>$

							PAGE  29
 	;"STICK THREE DUMBELLS TOGETHER TO MAKE A POLY-THING"
	<CALL P1 <ROTX 1.57>>
	<CALL P1 <ROTY 1.57>>
	<CALL P1>>

<SETORG 0 0>;"IF YOU ARE ON AN IMLAC"
<SETPROJ 0 0 855>
<SETCLIP -510 510 -510 510>;"MOVE THE ORIGIN TO THE CENTER OF THE SCREEN"

<DEFINE RPT ()		;"ROTATE AND DISPLAY THE P2 MCELL OR POLY-T