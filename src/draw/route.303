;<DRAW>ROUTE.FAI.8, 15-NOV-75 18:08:32, EDIT BY HELLIWELL
;bit array initializer - - clobbers T, TT, TTT, A, B, C, D, E, F, G.
ROUTE,<
PRINTX !!! ROUTE STUFF HASN'T BEEN CONVERTED !!!!
;FRELNK CHANGED TO FRLINK
;FIND.P AND FP1 DON'T RETURN EXTRA GOODIES ANY MORE
VERSION(ROUTE,2)
MPC,<
BITINI:	MOVE T,[ARRAYA,,ARRAYA+1]
	SETZM ARRAYA
	BLT T,ARRAYB+ARRAYB-ARRAYA-1	;CLEAR ARRAYS
	TLO M,%ROUTE
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ROUTING TABLES INITIALIZED!
/]
	PUSHJ P,BITIN1
BITIN1:	SKIPE B,PONPNT
	PUSHJ P,MARK
	HRRZ B,CRDLST
	JUMPE B,BITIN2
	HRRZ B,(B)
	MOVEI G,3			;MARK IT SOLIDLY
	JUMPN B,BITIN3
	JRST BITIN2
BITIN4:	MOVE E,1(B)
	TRNE E,1
	JRST BITIN3
	MOVE F,1(A)
	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/CARD EDGE EXCEEDS ARRAY BOUNDS!
/]
BITIN3:	MOVE A,B
	HRRZ B,(B)
	JUMPN B,BITIN4
BITIN2:	SWITCH
	POPJ P,

;bit array display routine - - clobbers T, TT, TTT, A, B, C, D, E, F, G.
PDISP:	MOVEI T,2
	PUSHJ P,DPYBIG
	SKIPN A,RCL1
	JRST NRCL1
	MOVE T,1(A)
	PUSHJ P,AIVECT
	MOVE T,[ASCID/_/]
	PUSHJ P,TXTDPB
NRCL1:	SKIPN A,RCL2
	JRST NRCL2
	MOVE T,1(A)
	PUSHJ P,AIVECT
	MOVE T,[ASCID//]
	PUSHJ P,TXTDPB
NRCL2:	TLNN M,RDISP
	POPJ P,
	MOVEI T,0		;FIND PIC COORDINATE OF LOWER LEFT
	ADJUST(SUB,T,<[%XCEN,,%YCEN]>)	;CORNER OF POINT ARRAY.
	MOVE TT,[%XSIZ,,%YSIZ]
	ADJUST(SUB,TT,<[%XCEN,,%YCEN]>)	;AND UPPER RIGHT
	MOVNI A,20000		;NOW CORNERS OF SCREEN
	IDIV A,NSCALE
	IDIVI A,%GRAIN
	IMULI A,%GRAIN
	HRL A,A
	MOVSI B,1
	SUB B,A
	HRL C,XOFF
	HRR C,YOFF
	ADJUST(ADD,A,C)		;LOWER LEFT IN A
	ADJUST(ADD,B,C)		;UPPER RIGHT IN B
	MOVE TTT,A
	ADJUST(SUB,TTT,T)	;FIND GREATER OF LOWER LEFT CORNER OF
	TLNN TTT,400000		;POINT ARRAY AND SCREEN
	HLL T,A
	TRNN TTT,400000
	HRR T,A
	MOVE TTT,B
	ADJUST(SUB,TTT,TT)	;FIND LESSER OF UPPER RIGHT CORNER OF
	TLNE TTT,400000		;POINT ARRAY AND SCREEN
	HLL TT,B
	TRNE TTT,400000
	HRR TT,B
	ADJUST(SUB,TT,T)	;FIND DELTA X AND Y FOR PORTION OF
	TDNE TT,[400000,,400000];SCREEN WE WILL DISPLAY
	POPJ P,			;ONE OR BOTH WERE NEGATIVE(NOTHING TO DISPLAY)
	MOVE A,T
	HLRZ T,TT		;NOW GET DELTA X AND Y IN ARRAY STEPS
	HRRZ TT,TT
	IDIVI TT,%GRAIN
	MOVE B,TT		;Y STEPS IN B
	IDIVI T,%GRAIN
	EXCH T,A		;X STEPS IN A AND X,Y COORD'S IN T.
	MOVE F,T		;SAVE COPY OF X,Y FOR APOINT.
	PUSHJ P,BITBYT		;MAKE BYTE POINTER
	JRST OUTDPY		;WHAT A SCREW-UP
	MOVE C,TTT		;TTT GETS CLOBBERED BY APOINT, USE C.
PDISP1:	MOVE G,F		;RESET X,Y (BEGIN NEXT ROW)
	MOVE E,A		;RESET X COUNT
	MOVE D,C		;RESET BYTE POINTER
PDISP2:	LDB T,D			;PICK UP A BYTE
	JUMPE T,PDISP3		;PUT A POINT HERE?
	MOVE T,G
	PUSHJ P,APOINT
PDISP3:	HRLZI T,%GRAIN
	ADD G,T			;INC X,Y BY ONE GRAIN.
	IBP D
	SOJG E,PDISP2		;LOOP ON ROW
	ADDI C,%ROW		;INC SAVED BYTE POINTER BY ONE ROW
	ADDI F,%GRAIN		;INC SAVED X,Y BY ONE ROW
	SOJG B,PDISP1		;AND LOOP ON ROW
	POPJ P,
;initialization routine - - mark all lines to this point
;and the point if a pin or feed through
;clobbers T, TT, TTT, A, B, C, D, E, F, G.
;G=1 to set bits | G=0 to clear bits.
MARK:	HLRZ A,(B)
	HLRZ C,1(A)
	JUMPE C,MARK31
MARK1:	MOVEI D,2
MARK2:	XCT (D)[	HLRZ E,(C)
			HLRZ E,1(C)
			HRRZ E,1(C)]
	JUMPE E,MARK3
	MOVE E,1(E)
	MOVE F,1(B)
	MOVEI G,1		;1 FOR LINES
	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/
POINT EXCEEDS ARRAY BOUNDS!/]
MARK3:	SOJGE D,MARK2
	HRRZ C,(C)
	JUMPN C,MARK1
MARK31:	HRRZ C,1(A)
	HLL C,1(C)
	TDNN C,[ISPIN!FEEDTH!CPIN,,-1]	;DRILL HOLE OR SOME PAD!
	JRST MARK4
	MOVEI G,3		;3 FOR PADS!
	TRNN C,-1		;UNPADDED?
	MOVEI G,2		;IN WHICH CASE WE USE 2
	MOVE E,1(B)
	MOVE F,E		;MARK LINE FROM POINT TO ITSELF
	TLNN C,CPIN		;CPIN MUST BE DONE SPECIAL
	JRST MRKPNT
	ADDI F,%SEPAR	;MARK ABOVE
	ADDI E,-%SEPAR	;AND BELOW
	TLZ F,1
	TLZ E,1
	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/CONNECTOR NOT IN ARRAY!
/]
	MOVE E,1(B)
	HRRZ F,(C)		;CPIN OTHER END POINTER
	MOVE F,1(F)
	PUSHJ P,MRKLIN		;MAKE A LINE TO FLUSH CROSSING OF CPIN
	OUTSTR[ASCIZ/CONNECTOR STICKS OUT OF ARRAY!
/]
MRKPNT:	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/
POINT EXCEEDS ARRAY BOUNDS!/]
MARK4:	HRRZ B,(B)
	JUMPN B,MARK
	POPJ P,
;MARK A LINE IN THE BIT ARRAY (UGH,BLETCH)!
;one endpoint in E the other in F.
;clobbers T, TT, TTT, E, F, G.
;G0 check for clear path(skip if clear)
;G=0 clear bits
;G=1 sets line bits
;G=2 sets unpadded feed through bits
;G=3 sets pad bits
MRKLIN:	TDZ F,[1,,1]
	TDZ E,[1,,1]
	CAMG F,E
	EXCH F,E
	MOVE T,F
	PUSHJ P,BITBYT
	POPJ P,
	MOVE T,E
	PUSHJ P,BITBYT
	POPJ P,
	MOVE T,F
	ADJUST(SUB,T,E)
	HRLM T,(P)	;SAVE HERE TEMPORARILY
	HLRE T,T
	IDIVI T,%GRAIN
	JUMPE TT,.+2
	ADDI T,1
	MOVEM T,DX
	HLRE T,(P)
	IDIVI T,%GRAIN
	JUMPE TT,.+4
	JUMPG TT,.+2
	SUBI T,2
	ADDI T,1
	MOVEI E,%ROW
	JUMPGE T,.+2
	MOVNI E,%ROW
	MOVMM T,DY
	MOVM T,T
	SETZM XCNT
	SETZM YCNT
	SETZ TT,
	CAMGE T,DX
	JRST CASE2C
	MOVNI T,%STEP/2
	MOVEM T,YCNT
	IMUL T,E
	ADD TTT,T
	MOVNI T,%STEP/2
	IMUL T,DX
	IDIV T,DY
	MOVEM T,XCNT
	SUBI T,%STEP/2
	CAIA
	PUSHJ P,DBP
	AOJLE T,.-1
	MOVE T,YCNT
	JRST CASE1

CASE2C:	MOVNI T,%STEP/2
	MOVEM T,XCNT
	CAIA
	PUSHJ P,DBP
	AOJLE T,.-1
	MOVNI T,%STEP/2
	IMUL T,DY
	IDIV T,DX
	MOVEM T,YCNT
	SUBI T,%STEP/2
	IMUL T,E
	ADD TTT,T
	MOVE T,XCNT
	JRST CASE2
CASE1:	IMUL T,DX
	IDIV T,DY
IFG %STEP-1,<
	JUMPGE TT,.+2
	SUBI T,1
	CAMGE T,XCNT
	JRST CASE1A
	CAMG T,XCNT
	JUMPE TT,CASE1A
>
IFLE %STEP-1,<
	CAMG T,XCNT
	JRST CASE1A
>
	IBP TTT
	AOS XCNT
CASE1A:	JUMPE G,CASE1J
	LDB F,TTT
	JUMPG G,CASE1I
	JUMPN F,CPOPJ
	JRST CASE1K
CASE1I:	CAMGE F,G
CASE1J:	DPB G,TTT
CASE1K:	MOVE T,TTT
IFG %STEP-2,<
REPEAT %STEP-2,<
	ILDB F,T
	JUMPGE G,.+3
	JUMPN F,CPOPJ
	JRST .+4
	JUMPE G,.+2
	CAMGE F,G
	DPB G,T
>
>
IFLE %STEP-1,<
	JUMPE TT,CASE1B
>
IFG %STEP-1,<
	JUMPN TT,CASE1B
>
	ILDB F,T
	JUMPGE G,.+3
	JUMPN G,CPOPJ
	JRST CASE1B
	JUMPE G,.+2
	CAMGE F,G
	DPB G,T
CASE1B:	AOS T,YCNT
	SUBI T,%STEP/2
	CAMLE T,DY
	JRST CPOPJ1
	ADDI T,%STEP/2
	ADD TTT,E
	JRST CASE1
CASE2:	IMUL T,DY
	IDIV T,DX
IFG %STEP-1,<
	JUMPGE TT,.+2
	SUBI T,1
	CAMGE T,YCNT
	JRST CASE2A
	CAMG T,YCNT
	JUMPE TT,CASE2A
>
IFLE %STEP-1,<
	CAMG T,YCNT
	JRST CASE2A
>
	AOS YCNT
	ADD TTT,E
CASE2A:	JUMPE G,CASE2J
	LDB F,TTT
	JUMPG G,CASE2I
	JUMPN F,CPOPJ
	JRST CASE2K
CASE2I:	CAMGE F,G
CASE2J:	DPB G,TTT
CASE2K:	MOVE T,TTT
IFG %STEP-2,<
REPEAT %STEP-2,<
	ADD T,E
	LDB F,T
	JUMPGE G,.+3
	JUMPN F,CPOPJ
	JRST .+4
	JUMPE G,.+2
	CAMGE F,G
	DPB G,T
>
>
IFLE %STEP-1,<
	JUMPE TT,CASE2B
>
IFG %STEP-1,<
	JUMPN TT,CASE2B
>
	ADD T,E
	JUMPE G,CASE2L
	LDB F,T
	JUMPG G,.+3
	JUMPN F,CPOPJ
	JRST CASE2B
	CAMGE F,G
CASE2L:	DPB G,T
CASE2B:	AOS T,XCNT
	SUBI T,%STEP/2
	CAMLE T,DX
	JRST CPOPJ1
	ADDI T,%STEP/2
	IBP TTT
	JRST CASE2

RSET1:	PUSHJ P,GETCLS
	JRST PERRET
	CAMN A,RCL2
	JRST PERRET
	MOVEM A,RCL1
	TRO MCHG
	POPJ P,

RSET2:	PUSHJ P,GETCLS
	JRST PERRET
	CAMN A,RCL1
	JRST PERRET
	MOVEM A,RCL2
	TRO MCHG
	POPJ P,
;HERE WE TRY TO ACTUALLY ROUTE A WIRE
DOROUTE:
	TLNN M,%ROUTE
	PUSHJ P,BITINI		;INTIALIZE FOR HIM!
	SKIPE B,RLIST
	PUSHJ P,PUTFS
	SETZM RLIST
	SKIPE D,RCL1
	SKIPN E,RCL2
	JRST PERRET
	MOVE T,1(D)
	CAMLE T,1(E)
	EXCH E,D
	MOVE F,RCODE		;SET UP ROUTING CODE
	HLRZ A,(E)
	HRRZ A,1(A)
	MOVE A,1(A)
	TLNE A,FEEDTH!ISPIN	;IS THIS POINT ONLY ON ONE SIDE?
	JRST REACHB		;NO.
	XCT STAB1(F)		;YES, ARE WE ROUTING ON THAT SIDE?
	JRST NTROUTE		;NO, LOSE
REACHB:	MOVE T,1(E)		;X2,Y2
	HRREM T,Y2
	HLREM T,X2
	PUSHJ P,BITBYA
	JRST NTROUTE
	MOVEM TTT,ENDBYT
	TLNE A,FEEDTH!ISPIN	;CAN WE END ON EITHER SIDE?
	XCT STAB2(F)		;YES, COMPUTE OTHER SIDE POINTER
	MOVEM TTT,ENDBY2	;THIS IS ANOTHER WINNING BYTE POINTER
	MOVE TTT,ENDBYT		;GET RIGHT ONE BACK
	HLRZ A,(D)
	HRRZ A,1(A)
	MOVE A,1(A)
	TLNE A,FEEDTH!ISPIN
	JRST REACHC
	XCT STAB1(F)
	JRST NTROUTE
REACHC:	MOVE T,1(D)
	HRREM T,Y1
	HLREM T,X1
	MOVE B,T
	PUSHJ P,BITBYA
	JRST NTROUTE
	MOVE T,Y1
	SUB T,Y2
	MOVEI TT,0
	JUMPL T,.+2
	MOVEI TT,1
	MOVEM TT,ROUIDX		;SAVE AS ROUTING INDEX
	TRZ TFLG		;MAGIC FLAG FOR SKIP RETURN
	SETZB G,RTCNT		;CLEAR COUNTS
NXTG1:	OUTSTR[ASCIZ/TRYING /]
	MOVE T,G
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	PUSHJ P,RBEGIN
	JRST RWIN		;WIN BIG
	TRZE TFLG		;ADVANCING ONE OR LEAVING?
	CAIA
	JRST NOROU1		;LEAVING
	AOS G,RTCNT
	JRST NXTG1

NTROUTE:OUTSTR[ASCIZ/NO ROUTING POSSIBLE!
/]
NOROU1:	TRO NEEDCL		;GET IT ON (BIGPG)
	POPJ P,
RWIN:	MOVEM SID,SIDSAV		;GET REAL SID FROM STORAGE
	XCT (F)[TLNE SID,FRONT
		TLNN SID,FRONT
		JFCL
		JFCL]
	JRST MAKRT
	SWITCH
MAKRT:	MOVE A,RLIST
	JRST MAKRT1
MAKRT2:	MOVE T,1(A)
	TLNE SID,FRONT
	TRC T,1
	TRNN T,1
	JRST RTSID
	SWITCH
RTSID:	MOVE T,1(A)
	XOR T,1(B)
	CAIN T,1
	JRST MAKFED
	PUSH P,B
	PUSH P,A
	MOVE E,1(A)
	MOVE F,1(B)
	MOVEI G,1
	PUSHJ P,MRKLIN
	OUTSTR[ASCIZ/LINE EXCEEDS ARRAY BOUNDS!
/]
	POP P,A
	MOVE TTT,1(A)
	TDZ TTT,[1,,1]
	PUSHJ P,FIND.P
	PUSH P,D
	PUSH P,TTT
	MOVE TTT,1(B)
	TDZ TTT,[1,,1]
	PUSHJ P,FIND.P
	POP P,T
	PUSHJ P,FRELNK
	XCT (T)PUTAB
	MOVE T,TTT
	POP P,D
	PUSHJ P,FRELNK
	XCT (T)PUTAB
	POP P,A
MAKRT1:	HRRZ B,(A)
	JUMPN B,MAKRT2
	TRO MCHG
	TLO M,%ROUTE		;PUTPNT CLEARED THIS!
NOTYET:	SKIPE B,RLIST		;FOR NOW JUST GIVE BACK THE ROUTE
	PUSHJ P,PUTFS
	SETZM RLIST
	MOVE T,SIDSAV
	EQV T,SID
	JUMPL T,CPOPJ		;ON RIGHT SIDE ALREADY?
	SWITCH			;NO, GET THERE
	POPJ P,
MAKFED:	PUSH P,B
	PUSH P,E
	MOVE TTT,1(A)
	TDZ TTT,[1,,1]
	PUSHJ P,FIND.P
	MOVE G,D
	PUSHJ P,RDFEED
	JRST CANTFD
	PUSH P,SID
	MOVE G,D
	TLZ SID,FRONT
	MOVE T,1(G)
	PUSHJ P,BITBYT
	JRST NOTINA
	MOVEI T,2
	DPB T,TTT
	ADDI TTT,ARRAYB-ARRAYA
	DPB T,TTT
NOTINA:	POP P,SID
CANTFD:	POP P,E
	POP P,A
	JRST MAKRT1
STKN__6			;NUMBER OF THINGS PUSHED ON STACK IN RECURSIVE ROUTINES

%LIMIT__%SEPAR*4	;LIMIT SIZE OF SEARCH BOX!


RBEGIN:	HRRZM P,PSAV
	PUSH P,G
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	SETZM DX		;USE THIS AS COUNTER FOR WHEN TO TRY INCHRS
	ADD G,.CNR		;COMPENSATE FOR ROUTINES THINKING THIS IS A CORNER
	MOVEI H,XPNF		;ASSUME THIS
	XCT (F)[JRST XRLOC
		JRST XRLOC
		TLNN A,FEEDTH!ISPIN
		TLNN A,FEEDTH!ISPIN]
	JRST XRLOC
	MOVEI H,XR0
	JRST XRLOC

PVB:	XCT VTAB(F)
PVB1:	MOVE C,.CNR
	MOVEI H,XPV
	JRST PVAB

PVA:	XCT VTAB(F)
PVA1:	MOVE C,.CNR
	MOVEI H,XPVA
PVAB:	ADD C,.BAK
	JRST PVI

PV:	XCT VTAB(F)
PV1:	MOVE C,.CNR
	MOVEI H,XPV
PVI:	PUSH P,G
	SUB G,C		;DO WEIGHTING
	JUMPL G,GPOPJ2
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	HRRE T,B
	MOVE TT,ROUIDX
	SUB T,(TT)[%LIMIT
		 -%LIMIT]
	XCT (TT)[CAMLE T,Y2
		CAMGE T,Y2]
	JRST SKIP2A
	ADD TTT,(TT)[%ROW
		   -%ROW]
	ADD B,(TT)[%SEPAR
		0,,-%SEPAR]
	TLZ B,1
	JRST XLOCA	;ENTER MAIN LOOP
NVB:	XCT VTAB(F)
NVB1:	MOVE C,.CNR
	MOVEI H,XNV
	JRST NVAB

NVA:	XCT VTAB(F)
NVA1:	MOVE C,.CNR
	MOVEI H,XNVA
NVAB:	ADD C,.BAK
	JRST NVI

NV:	XCT VTAB(F)
NV1:	MOVE C,.CNR
	MOVEI H,XNV
NVI:	PUSH P,G
	SUB G,C
	JUMPL G,GPOPJ2
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	HRRE T,B
	MOVE TT,ROUIDX
	ADD T,(TT)[%LIMIT
		 -%LIMIT]
	XCT (TT)[CAMGE T,Y1
		CAMLE T,Y1]
	JRST SKIP2A
	ADD TTT,(TT)[-%ROW
		     %ROW]
	ADD B,(TT)[0,,-%SEPAR
		  %SEPAR	]
	TLZ B,1
	JRST XLOCA
PHB:	XCT HTAB(F)
PHB1:	MOVE C,.CNR
	MOVEI H,XPH
	JRST PHAB

PHA:	XCT HTAB(F)
PHA1:	MOVE C,.CNR
	MOVEI H,XPHA
PHAB:	ADD C,.BAK
	JRST PHI

PH:	XCT HTAB(F)
PH1:	MOVE C,.CNR
	MOVEI H,XPH
PHI:	PUSH P,G
	SUB G,C
	JUMPL G,GPOPJ2
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	HLRE T,B
	SUBI T,%LIMIT
	CAMLE T,X2
	JRST SKIP2A
	IBP TTT
	ADD B,[%SEPAR,,0]
	JRST XLOCA
NHB:	XCT HTAB(F)
NHB1:	MOVE C,.CNR
	MOVEI H,XNH
	JRST NHAB

NHA:	XCT HTAB(F)
NHA1:	MOVE C,.CNR
	MOVEI H,XNHA
NHAB:	ADD C,.BAK
	JRST NHI

NH:	XCT HTAB(F)
NH1:	MOVE C,.CNR
	MOVEI H,XNH
NHI:	PUSH P,G
	SUB G,C
	JUMPL G,GPOPJ2
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	HLRE T,B
	ADDI T,%LIMIT
	CAMGE T,X1
	JRST SKIP2A
	PUSHJ P,DBP
	ADD B,[-%SEPAR,,0]
	JRST XLOCA
PNF:	XCT FTAB(F)
	MOVEI H,XPNF
	PUSH P,G
	SUB G,.FED
	JUMPL G,GPOPJ2
	ADD G,.CNR		;ACCOUNT FOR IMPLIED CORNER COMING UP
	PUSH P,TTT
	PUSH P,B
	PUSH P,A
	PUSHJ P,DBP
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	IBP TTT
	ILDB T,TTT
	CAIL T,3
	JRST SKIP2A
	MOVE TTT,-2(P)
	ADDI TTT,%ROW
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	SUBI TTT,%ROW*2
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	PUSHJ P,OBYT	;GET TO OTHER SIDE
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	ADDI TTT,%ROW*2
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	SUBI TTT,%ROW
	PUSHJ P,DBP
	LDB T,TTT
	CAIL T,3
	JRST SKIP2A
	IBP TTT
	ILDB T,TTT
	CAIL T,3
	JRST SKIP2A
	PUSHJ P,DBP	;GET REAL BYTE POINTER
	TLC A,FRONT
XLOCA:	CAME TTT,ENDBYT	;AT ENDPOINT?
	CAMN TTT,ENDBY2		;EITHER OF THEM?
	JRST PWIN		;YES
	LDB T,TTT
	JUMPN T,SKIP2A
	MOVEI T,1
	DPB T,TTT
RDEBUG:	JRST ENDBUG
	MOVEI T,-2(P)
	MOVEM T,STARLOC
	MOVEI T,UPROUTE
	MOVEM T,SPDISP
	MOVE T,[ASCIZ/RD/]
	MOVEM T,SPMODT
	MOVEI T,SPM
	PUSHJ P,TCHNGM
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/_____
/]
	PUSHJ P,GETCHR
	PUSHJ P,RCHNGM
ENDBUG:
XRLOC:	PUSHJ P,HJUST
	HRLI H,(<POINT 5,0>)	;MAKE IT INTO A BYTE POINTER
	PUSH P,H		;SAVE BYTE POINTER
XLOC:	ILDB H,(P)		;GET INDEX
	XCT XCTAB(H)		;AND CALL ROUTINE
	JRST WIN
	JRST SKIP1
	JRST XLOC
LOSE:	MOVEI T,0
	CAME TTT,-3(P)			;CROCKISH WAY TO TELL IF THIS IS THE GUY
					;WE SHOULDN'T CLOBBER!!!!!! ARRG****
	DPB T,TTT
	POP P,(P)
SKIP2A:	POP P,A
	POP P,B
	POP P,TTT
GPOPJ2:	POP P,G
	SOSL DX		;TIME TO CHECK YET?
	JRST CPOPJ2	;NO
	MOVEI T,20	;WAIT A WHILE
	MOVEM T,DX
	INCHRS T	;LET HIM OUT HERE IF NECESSARY!!!
	JRST CPOPJ2
	OUTSTR[ASCIZ/_____
/]
	CAIN T,ALTMOD	;ONLY ALTMODE WILL WORK!
	JRST CPOPJ1	;YES, SINGLE SKIP RETURN
	TRZE T,600	;MUST HAVE CTRL BITS!
	CAIE T," "	;**SPACE WILL GO TO NEW COUNT
	CAIA
	TROA TFLG
	AOS (P)
	JRST CPOPJ1

SKIP1:	MOVEI T,0
	DPB T,TTT
	POP P,(P)
SKIP1A:	POP P,A
	POP P,B
	POP P,TTT
	POP P,G
	JRST CPOPJ1

WIN:	TRZ B,1
	TLNE A,FRONT
	TRO B,1
	SKIPN T,RLIST
	JRST NOLIST
	HRRZ H,(T)
	JUMPE H,NOLIST
	MOVE TT,B
	XOR TT,1(T)
	CAIN TT,1
	JRST NOLIST
	MOVE TT,1(H)
	XOR TT,B
	TRNN TT,1
	TLNE TT,-1
	TRNN TT,-1
	JRST [	MOVEM B,1(T)
		JRST ISLIST]
NOLIST:	GETFS(TT)
	HRRZM T,(TT)
	HRRZM TT,RLIST
	MOVEM B,1(TT)
ISLIST:	MOVEI T,0
	DPB T,TTT
	POP P,(P)
	POP P,A
	POP P,B
	POP P,TTT
	POP P,G
	POPJ P,
SDIF__ARRAYB-ARRAYA

HJUST:	HLRE T,B
	CAML T,X2
	ADDI H,2
	CAMLE T,X2
	ADDI H,2
	HRRE T,B
	MOVE TT,ROUIDX
	XCT (TT)[CAML T,Y2
		CAMG T,Y2]
	ADDI H,6
	XCT (TT)[CAMLE T,Y2
		CAMGE T,Y2]
	ADDI H,6
	POPJ P,

OBYTA:	PUSHJ P,OBYT
	TLC A,FRONT
	JRST CPOPJ2

OBYT:	TLNN A,FRONT
	ADDI TTT,SDIF*2
	SUBI TTT,SDIF
	POPJ P,

STAB1:	TLNN A,FRONT
	TLNE A,FRONT
	CAIA
	CAIA

STAB2:	JFCL
	JFCL
	PUSHJ P,OBYT
	PUSHJ P,OBYT

VTAB:	SKIPA C,[0]
	SKIPA C,[0]
	PUSHJ P,BACKTB
	PUSHJ P,FRNTTB

HTAB:	SKIPA C,[0]
	SKIPA C,[0]
	PUSHJ P,FRNTTB
	PUSHJ P,BACKTB

BACKTB:	TLNN A,FRONT
	TDZA C,C
	MOVEI C,%SID
	JRST CPOPJ1

FRNTTB:	TLNE A,FRONT
	TDZA C,C
	MOVEI C,%SID
	JRST CPOPJ1

FTAB:	JRST CPOPJ2
	JRST CPOPJ2
	JFCL
	JFCL

XCTAB:	JRST LOSE
	PUSHJ P,PV
	PUSHJ P,NV
	PUSHJ P,PH
	PUSHJ P,NH
	PUSHJ P,PV1
	PUSHJ P,NV1
	PUSHJ P,PH1
	PUSHJ P,NH1
	PUSHJ P,PVA
	PUSHJ P,NVA
	PUSHJ P,PHA
	PUSHJ P,NHA
	PUSHJ P,PVA1
	PUSHJ P,NVA1
	PUSHJ P,PHA1
	PUSHJ P,NHA1
	PUSHJ P,PVB
	PUSHJ P,NVB
	PUSHJ P,PHB
	PUSHJ P,NHB
	PUSHJ P,PVB1
	PUSHJ P,NVB1
	PUSHJ P,PHB1
	PUSHJ P,NHB1
	PUSHJ P,PNF
	PUSHJ P,OBYTA
%__0		;SO BLANK CONCATINATED WITH % IS 0.
%PV__1
%NV__2
%PH__3
%NH__4
%PV1__5
%NV1__6
%PH1__7
%NH1__10
%PVA__11
%NVA__12
%PHA__13
%NHA__14
%PVA1__15
%NVA1__16
%PHA1__17
%NHA1__20
%PVB__21
%NVB__22
%PHB__23
%NHB__24
%PVB1__25
%NVB1__26
%PHB1__27
%NHB1__30
%PNF__31
%OBYTA__32

DEFINE XD $ (A,B,C,D,E,F,G,H,I,J,K,L,M)
<	BYTE (5)%$A,%$B,%$C,%$D,%$E,%$F,%$G,%$H,%$I,%$J,%$K,%$L,%$M,0
>

XR0:	XD	PV1,PH1,NVA1,NHA1,OBYTA,PV1,PH1,NVB1,NHB1,OBYTA,NVB1,NHB1
	XD	PV1,NHA1,PHA1,NVA1,OBYTA,PV1,NHB1,PHB1,NVB1,OBYTA,NHB1,PHB1,NVB1
	XD	PV1,NH1,PHA1,NVA1,OBYTA,PV1,NH1,PHB1,NVB1,OBYTA,PHB1,NVB1
	XD	PH1,NVA1,PVA1,NHA1,OBYTA,PH1,NVB1,PVB1,NHB1,OBYTA,NVB1,PVB1,NHB1
	0
	XD	NH1,PVA1,NVA1,PHA1,OBYTA,NH1,PVB1,NVB1,PHB1,OBYTA,PVB1,NVB1,PHB1
	XD	NV1,PH1,NHA1,PVA1,OBYTA,NV1,PH1,NHB1,PVB1,OBYTA,NHB1,PVB1
	XD	NV1,PHA1,NHA1,PVA1,OBYTA,NV1,PHB1,NHB1,PVB1,OBYTA,PHB1,NHB1,PVB1
	XD	NV1,NH1,PVA1,PHA1,OBYTA,NV1,NH1,PVB1,PHB1,OBYTA,PVB1,PHB1

XPNF:	XD	PV1,PH1,PNF,NVB1,NHB1
	XD	PV1,PNF,NHB1,PHB1,NVB1
	XD	PV1,NH1,PNF,PHB1,NVB1
	XD	PH1,PNF,NVB1,PVB1,NHB1
	XD	PNF
	XD	NH1,PNF,PVB1,NVB1,PHB1
	XD	NV1,PH1,PNF,NHB1,PVB1
	XD	NV1,PNF,PHB1,NHB1,PVB1
	XD	NV1,NH1,PNF,PVB1,PHB1

XPV:	XD	PV,PH1,NHA1,PNF,NHB1
	XD	PV,PHA1,NHA1,PNF,PHB1,NHB1
	XD	NH1,PV,PHA1,PNF,PHB1
	XD	PH1,PVA,NHA1,PNF,PVB,NHB1
	XD	PNF
	XD	NH1,PVA,PHA1,PNF,PVB,PHB1
	XD	PH1,PVA,NHA1,PNF,PVB,NHB1
	XD	PHA1,NHA1,PVA,PNF,PHB1,NHB1,PVB
	XD	NH1,PVA,PHA1,PNF,PVB,PHB1

XPVA:	XD	PVA,PHA1,NHA1
	XD	PVA,PHA1,NHA1
	XD	NHA1,PVA,PHA1
	XD	PHA1,PVA,NHA1
	XD	PNF
	XD	NHA1,PVA,PHA1
	XD	PHA1,PVA,NHA1
	XD	PHA1,PVA,NHA1
	XD	NHA1,PVA,PHA1
XNV:	XD	PH1,NVA,NHA1,PNF,NVB,NHB1
	XD	PHA1,NHA1,NVA,PNF,PHB1,NHB1,NVB
	XD	NH1,NVA,PHA1,PNF,NVB,PHB1
	XD	PH1,NVA,NHA1,PNF,NVB,NHB1
	XD	PNF
	XD	NH1,NVA,PHA1,PNF,NVB,PHB1
	XD	NV,PH1,NHA1,PNF,NHB1
	XD	NV,PHA1,NHA1,PNF,PHB1,NHB1
	XD	NV,NH1,PHA1,PNF,PHB1

XNVA:	XD	PHA1,NVA,NHA1
	XD	PHA1,NVA,NHA1
	XD	NHA1,PHA1,NVA
	XD	PHA1,NVA,PHA1
	XD	PNF
	XD	NHA1,NVA,PHA1
	XD	NVA,PHA1,NHA1
	XD	NVA,NHA1,PHA1
	XD	NVA,NHA1,PHA1

XPH:	XD	PH,PV1,NVA1,PNF,NVB1
	XD	PV1,PHA,NVA1,PNF,PHB,NVB1
	XD	PV1,PHA,NVA1,PNF,PHB,NVB1
	XD	PH,PVA1,NVA1,PNF,PVB1,NVB1
	XD	PNF
	XD	PVA1,NVA1,PHA,PNF,PVB1,NVB1,PHB
	XD	PH,NV1,PVA1,PNF,PVB1
	XD	NV1,PHA,PVA1,PNF,PHB,PVB1
	XD	NV1,PHA,PVA1,PNF,PHB,PVB1

XPHA:	XD	PHA,PVA1,NVA1
	XD	PVA1,PHA,NVA1
	XD	PVA1,PHA,NVA1
	XD	PHA,NVA1,PVA1
	XD	PNF
	XD	PVA1,PHA,NVA1
	XD	PHA,NVA1,PVA1
	XD	NVA1,PHA,PVA1
	XD	NVA1,PHA,PVA1

XNH:	XD	PV1,NHA,NVA1,PNF,NHB,NVB1
	XD	PV1,NVA1,NHA,PNF,NVB1,NHB
	XD	NH,PV1,NVA1,PNF,NVB1
	XD	PVA1,NVA1,NHA,PNF,PVB1,NVB1,NHB
	XD	PNF
	XD	NH,NVA1,PVA1,PNF,NVB1,PVB1
	XD	NV1,PVA1,NHA,PNF,PVB1,NHB
	XD	NV1,PVA1,NHA,PNF,PVB1,NHB
	XD	NH,NV1,PVA1,PNF,PVB1

XNHA:	XD	PVA1,NHA,NVA1
	XD	PVA1,NHA,NVA1
	XD	PVA1,NHA,NVA1
	XD	PVA1,NHA,NVA1
	XD	PNF
	XD	NHA,PVA1,NVA1
	XD	NVA1,PVA1,NHA
	XD	NVA1,NHA,PVA1
	XD	NHA,NVA1,PVA1
PWIN:	JUMPG G,SKIP2A		;COUNT MUST BE EXACT!
	MOVEI T,-1(P)		;GET POINTER TO OUR STACK
	MOVEM T,STARLOC		;PASS AS DATUM
	MOVEI T,UPROUTE
	MOVEM T,SPDISP
	MOVE T,[ASCIZ/R/]
	MOVEM T,SPMODT
	MOVEI T,SPM
	PUSHJ P,TCHNGM
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/HOW ABOUT THIS ONE?/]
	PUSHJ P,GETCHR
	PUSHJ P,RCHNGM		;RETURN TO OLD MODE
	CAIN C,ALTMOD		;ALTMODE?
	JRST SKIP1A		;YES, GET OUT OF HERE
	CAIE C,"Y"
	CAIN C,"y"
	JRST [	PUSH P,(P)	;HE EXPECTS SOMETHING ON THE STACK
		JRST WIN]
	TRZE C,600
	CAIE C,40		;CTRL SPACE?
	JRST SKIP2A		;TRY ANOTHER ROUTE
	TRO TFLG		;FLAG TO SKIP TO NEXT # OF CORNERS
	JRST SKIP1A
;ROUTER DISPLAY
UPROUTER:
	PUSHJ P,SPSETUP
	MOVE D,STARLOC		;GET POINTER TO NEXT X,Y BACK UP STACK
	MOVE T,B
	PUSHJ P,AIVECT		;START HERE
	MOVE T,B
	MOVE E,A		;SIDE OF LAST POINT PLOTTED
	JRST PLOP1		;ENTER LOOP

PLOP:	MOVE TT,T		;LAST POINT WE DREW
	XOR TT,(D)
	TDZ TT,[1,,1]
	TLNE TT,-1		;SAME X
	TRNN TT,-1		;OR Y
	CAIA			;WELL, SAME POS.
	JRST PLOTIT
	MOVE TT,E
	XOR TT,1(D)		;STILL ON SAME SIDE?
	JUMPGE TT,PLOP1		;YES, SKIP IT
PLOTIT:	MOVEI T,7		;ASSUME ON CURRENT SIDE
	MOVE TT,STKN+1(D)	;GET WHAT SIDE HE'S ON
	EQV TT,SID		;IS HE ON BRIGHT SIDE?
	JUMPL TT,.+2		;YES
	MOVE T,DEFBRT		;NO
	PUSHJ P,DPYBRT
	MOVE T,B		;GET LAST POINT STILL IN LINE
	PUSHJ P,AVECT		;PLOT IT
	MOVE T,B
	MOVE E,STKN+1(D)
PLOP1:	MOVE B,(D)		;GET NEXT X,Y FROM STACK
	SUBI D,STKN		;BACK UP STACK
	CAMLE D,PSAV		;OFF TOP?
	JRST PLOP		;NO, CONTINUE CHECK
	MOVE T,BTHBRT		;ASSUME ON CURRENT SIDE
	MOVE TT,STKN+1(D)	;GET WHAT SIDE HE'S ON
	EQV TT,SID		;IS HE ON BRIGHT SIDE?
	JUMPL TT,.+2		;YES
	MOVE T,DEFBRT		;NO
	PUSHJ P,DPYBRT
	MOVE T,B
	PUSHJ P,AVECT		;PLOT LAST POINT
	JRST BLINKO		;DISPLAY IT
;BITBYA, BITBYT
BITBYA:	PUSH P,SID
	MOVE SID,A
	PUSHJ P,BITBYT
	CAIA
	AOS -1(P)
	POP P,SID
	POPJ P,

BITBYT:	ADJUST(ADD,T,<[%XCEN,,%YCEN]>)	;MAKE IT ALL POS.
	TDNE T,[400000,,400000]
	POPJ P,
	HRRZ TT,T
	HLRZ T,T
	CAIG T,%XSIZ
	CAILE TT,%YSIZ
	POPJ P,
	IDIVI TT,%GRAIN
	MOVE TTT,TT
	IMULI TTT,%ROW		;GET INDEX TO BEGGINING OF ROW
	IDIVI T,%GRAIN
	IDIVI T,=36/BYTSIZ
	ADD TTT,T
	IMULI TT,BYTSIZ		;LOW ORDER BIT OF BYTE + 1 - BYTSIZ
	SUBI TT,=36-BYTSIZ
	MOVN TT,TT
	LSH TT,=12
	TRO TT,BYTSIZ6
	HRL TTT,TT
	ADDI TTT,ARRAYA
	JUMPGE SID,CPOPJ1
	ADDI TTT,ARRAYB-ARRAYA
	JRST CPOPJ1

;DECREMENT BYTE POINTER IN TTT.
DBP:	ADD TTT,[BYTE (6)BYTSIZ]
	JUMPGE TTT,CPOPJ
	TLNE TTT,40000
	SUB TTT,[440000,,1]
	POPJ P,
>;ROUTE
>;MPC
