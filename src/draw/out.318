;<DRAW>OUT.FAI.70, 15-NOV-75 18:07:14, EDIT BY HELLIWELL
VERSION(OUT,8)
SUBTTL 'DRW'	'PC'

EWRITE:	MOVE T,AUTOWM
	MOVEM T,AUTOWN		;RESET COUNT SO WE GET HERE AGAIN AFTER ERROR
	MOVEI T,1
	LSH T,@MODE
	TDNE T,[MD,<ALLEDM!>ANYALT]
	JRST [	TLNN M,DSKACT!MACACT
		OUTSTR [ASCIZ/EWRITE WHILE IN WRONG MODE.
/]
		SKIPE AUTOWM
		OUTSTR [ASCIZ/AUTO EWRITE COUNTER RESET.
/]
		POPJ P,]
	HLLZ TT,LSTEXT
	CAMN TT,[EXTFIL,,]
	JRST DOEWRT
	TLNE M,DSKACT!MACACT
	JRST DOEWR1
	OUTCHR ["'"]
	MOVE TTT,[POINT 7,NAMBUF]
	PUSHJ P,SIXOUT
	SETZ T,
	IDPB T,TTT
	OUTSTR NAMBUF
	OUTSTR [ASCIZ /' WAS THE OLD EXTENSION OF THIS DRAWING FILE.
IT IS NOT THE STANDARD EXTENSION FOR A DRAWING FILE.
TYPE "Y" TO PROCEED USING THE ABOVE EXTENSION.
TYPE <ALTMODE> TO ABORT OUTPUT.
TYPE ANYTHING ELSE TO USE STANDARD EXTENSION.
/]
DOEWR1:	PUSHJ P,YORN
	 POPJ P,
	 JRST DOEWRT
	SKIPA T,LSTEXT
DOEWRT:	MOVSI T,EXTFIL
	PUSHJ P,SETLST		;ANY REMEMBERED NAME?
	 JRST DWRITE
	MOVE T,LSTPPN		;EWRITE GOES BACK TO ORIGINAL PPN
	MOVEM T,FILPPN
	SETZM SETFLG
	JRST WRITEE		;WILL CHECK FOR EXT DIFF, AND DO OVERWRITE CHECK

DWRITE:	SETZM SETFLG
DWRITS:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[MD,<ALLEDM!>ANYALT]
	JRST PERRET
WRTAGN:	MOVSI T,EXTFIL
	PUSHJ P,SETNAM	;READ FILENAME AND STORE IN FILNAM
	POPJ P,		;NONE, LET HIM OUT.
	HLLZ T,FILEXT
	XOR T,LSTEXT
	SKIPE LSTNAM
	TLNN T,-1
	JRST WRITEE
	OUTSTR [ASCIZ /WRITING DRAWING FILE WITH EXTENSION '/]
	MOVE TTT,[POINT 7,NAMBUF]
	HLLZ TT,FILEXT
	PUSHJ P,SIXOUT
	SETZ T,
	IDPB T,TTT
	OUTSTR NAMBUF
	OUTSTR [ASCIZ /'.
ORIGINAL EXTENSION OF THIS DRAWING FILE WAS '/]
	MOVE TTT,[POINT 7,NAMBUF]
	HLLZ TT,LSTEXT
	PUSHJ P,SIXOUT
	SETZ T,
	IDPB T,TTT
	OUTSTR NAMBUF
	OUTSTR [ASCIZ /'.
TYPE "Y" TO PROCEED.
TYPE <ALTMODE> TO ABORT THIS OUTPUT.
TYPE ANYTHING ELSE TO GET FILENAME PROMPT AGAIN.
/]
	PUSHJ P,YORN
	 POPJ P,
	 JRST WRTAGN
WRITEE:	MOVE T,FILEXT
	XOR T,LSTEXT
	TLNE T,-1
	SETZM THEREXISTS	;DO ALREADY EXISTS CHECK IF CHANGING EXT
	ENTPPN
	MOVEM P,PERRSAV		;USE THIS TO GET OUT FROM LOWER LEVELS.
	INIT DAT,10
	'DSK   '
	XWD IOHD,0
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF	;USE THIS BUFFER SO WE DON'T WASTE SPACE
	EXCH T,.JBFF
	OUTBUF DAT,2
	MOVEM T,.JBFF	;PUT .JBFF BACK
MD,<	MOVE B,FILNAM
	HLLZ C,FILEXT
	SKIPN D,FILPPN
	DSKPPN D,
	PUSHJ P,LNAMCK	;CHECK NAME
	JRST LIBUSE
>;MD
	PUSHJ P,EXIST	;DOES IT EXIST?
	POPJ P,		;HE DOESN'T WANT TO OVERWRITE
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<
	SKIPN	THEREXISTS
	JRST	NOBAK
	PJOB	T,		;GET JOB #
	IDIVI	T,=100		;MAKE TMP FILE NAME
	IDIVI	TT,=10
	LSH	T,6
	ADD	T,TT
	LSH	T,6
	ADD	T,TTT
	ADD	T,['DRW000']
	MOVSM	T,TMPNAM
	MOVSI	T,'TMP'
	MOVEM	T,TMPEXT
	MOVSI	T,100000		;MIN PROT.
	MOVEM	T,TMPEXT+1
	MOVE	T,FILPPN
	MOVEM	T,TMPPPN
	ENTER	DAT,TMPNAM
	SKIPA
	JRST	WRITEG		;ALL SET
	CLOSE	DAT,		;ENTER FAILED, TRY WITHOUT BAK
	OUTSTR	[ASCIZ /, /]
	MOVEI	A,TMPNAM
	JSR	FPRINT
	OUTSTR	[ASCIZ / ENTER FAILED.
GO ON WITHOUT BACKUP FILE?/]
	SETZM	THEREXISTS
	CLRBFI
	INCHRW C
	CAIN C,15
	INCHRW C
	OUTSTR	[ASCIZ /
/]
	CAIE	C,"Y"
	CAIN	C,"y"
	JRST	NOBAK
	RELEASE	DAT,
	POPJ	P,
NOBAK:
>;DEC
	MOVE T,FILPPN
	ENTER DAT,FILNAM	;MAKE A FILE
	JRST [	RELEASE DAT,
		OUTSTR [ASCIZ/, ENTER FAILED.
/]
		POPJ P,]
WRITEG:	OUTSTR[ASCIZ/
/]
	MOVEM T,FILPPN
	SKIPE SETFLG			;IF WRITING SET ONLY,
	JRST NLSTUP			;DON'T UPDATE LAST NAME
	MOVEM T,LSTPPN
	HLLZ T,FILEXT
	MOVEM T,LSTEXT
	MOVE T,FILNAM
	MOVEM T,LSTNAM
	PUSHJ P,FILEUP		;UPDATE DISPLAY
MD,<	DATE T,
	HRLZM T,DRWDAT
	MSTIME T,
	IDIVI T,=1000*=60	;TO MINUTES
	HRRM T,DRWDAT
	MOVE T,FILNAM
	MOVEM T,DRWNAM
	MOVE T,FILEXT
	HLLZM T,DRWEXT
	MOVE T,FILPPN
	MOVEM T,DRWPPN
>;MD
NLSTUP:
MPC,<	SETZM MXPADN		;CLEAR MAX PAD # SEEN
	TLNE SID,FRONT		;ALREADY ON FRONT SIDE?
	JRST DOWRT		;YES, GO ON
	SWITCH			;GET THERE
	PUSHJ P,DOWRT		;WRITE FILE
	SWITCH			;BACK WHERE WE WERE
	POPJ P,

DOWRT:
>;MPC
	MOVEI TTT,IOVER		;IOVERSION #
	PUSHJ P,WORDOUT
	PUSHJ P,WRTNOM
MD,<	PUSHJ P,WRTBRD
	SKIPN LIBLST		;EASY IF NO LIBRARIES
	 JRST PUTLB0
;Mark and output all types actually used in drawing
	PUSHJ P,CDFMRK		;CLEAR DEFINITION MARK BITS
	SKIPN A,DBODPN		;NOW LOOK AT BODIES
	JRST PUTLB0
	MOVSI TT,DTMP1		;THIS IS TEMP MARK BIT
UTYP1:	SKIPN SETFLG		;WRITING SET ONLY?
	 JRST UTYP4		;NO
	FETCHL(TTT,A,BBIT)
	TLNN TTT,BTMP1		;IS IT IN THE SET?
	 JRST UTYP5		;NO
UTYP4:	FETCH(T,A,BTYP)
	IORM TT,ADDR(T,TBIT)	;TURN ON MARK BIT
UTYP5:	HRRZ A,(A)
	JUMPN A,UTYP1
	MOVE A,BODPNT
UTYP2:	FETCH(T,A,TLIB)
	JUMPE T,UTYP3		;ONLY LIBRARY BODIES
	FETCH(T,A,TYP1)
	JUMPE T,UTYP3		;ONLY ONES ALREADY IN
	FETCH(T,A,TBIT)
	TRNN T,DTMP1		;BODY USED?
	 JRST UTYP3		;NO
	FETCH(TT,A,TNAM)
	PUSHJ P,WSTR
UTYP3:	FETCH(A,A,TNXT)
	JUMPN A,UTYP2
PUTLB0:	PUSHJ P,WRTZERO		;END OF USED TYPE NAMES
;Output all libraries
	SKIPN A,LIBLST		;ANY LIBRARIES?
	JRST ENDLIB
PUTLIB:	HLRZ T,(A)
	HRRZ TT,(T)
	TRNN TT,TOPLVL		;ONLY WRITE OUT TOP LEVEL POINTERS
	JRST PUTLB1
	MOVE TTT,1(A)
	PUSHJ P,WORDOUT
	MOVE TTT,(T)
	PUSHJ P,WORDOUT
	MOVE TTT,1(T)
	PUSHJ P,WORDOUT
PUTLB1:	HRRZ A,(A)
	JUMPN A,PUTLIB
ENDLIB:	PUSHJ P,WRTZERO		;MARK END OF LIBRARIES
;TYPES
	HRRZ T,BODPNT		;POINTER TO TYPES
	JUMPE T,TYPDON
WRTTYP:	FETCH(TT,T,TLIB)
	JUMPN TT,SKPTYP		;SKIP THIS TYPE IF FROM LIBRARY
	FETCH(TT,T,TNAM)
	PUSHJ P,WSTR
	FETCH(TT,T,TPAK)
	JUMPE TT,[PUSHJ P,WRTZERO
		JRST WRTTY1]
	HRRZ TT,PACKNM(TT)
	PUSHJ P,WASCIZ
WRTTY1:	FETCHL(TTT,T,TBIT)
	TDZ TTT,[DTMP1!FOUNDL,,-1]	;DON'T WRITE TEMP BITS INTO FILE
	PUSHJ P,WORDOUT			;RIGHT HALF IS UNUSED AS YET
	FETCH(TTT,T,TXY)	;DEF LOC OFFSET
	PUSHJ P,WORDOUT
	FETCH(TTT,T,TYP3)	;ANY CHAR OFFSET?
	SKIPN TTT
	 SKIPA TTT,[400000]	;NO
	FETCH(TTT,T,TOXY)
	PUSHJ P,WORDOUT
	FETCH(TT,T,TPIN)	;PINS?
	JUMPE TT,PNDON		;NONE MAYBE.
TYPPIN:	FETCH(TTT,TT,TPXY)
	PUSHJ P,WORDOUT
	MOVE TTT,ADDR(TT,TPID)	;GET BITS,,PIN ID
	PUSHJ P,WORDOUT
	MOVE TTT,ADDR(TT,TPNAM)	;NOW PIN POS,,PIN NAME
	PUSHJ P,WORDOUT
	FETCH(TT,TT,TPNX)
	JUMPN TT,TYPPIN
PNDON:	PUSHJ P,WRTMARK		;MARK END OF PINS
	FETCH(TT,T,TLIN)
	JUMPE TT,LINDON		;NO LINES MAYBE
TYPLIN:	FETCH(TTT,TT,QXY)
	PUSHJ P,WORDOUT		;WRITE IT
	FETCH(TT,TT,QNXT)
	JUMPN TT,TYPLIN		;ENDS WITH 0
LINDON:	PUSHJ P,WRTMARK		;MARK END OF LINES
	FETCH(A,T,TPROP)
	PUSHJ P,WRTPRP
SKPTYP:	FETCH(T,T,TNXT)
	JUMPN T,WRTTYP
TYPDON:	PUSHJ P,WRTZERO		;MARK END OF TYPES
>;MD
	PUSHJ P,MACOUT		;OUTPUT SPECIAL MACROES TO FILE
;		BODIES, CALL POINT SUBR (D,PC)
	SKIPN T,DBODPN		;POINTER TO BODIES IN DRAWING?
	 JRST BODDON		;NONE
WRTBOD:	SKIPN SETFLG		;WRITING SET ONLY?
	 JRST WRTBD1		;NO
	FETCHL(TTT,T,BBIT)
	TLNN TTT,BTMP1		;IN OUR SET?
	 JRST WRTBD2
WRTBD1:	FETCH(TTT,T,BXY)	;LOC OF BODY
	PUSHJ P,WORDOUT
MPC,<	FETCH(TT,T,BNAM)
	PUSHJ P,TWSTR
>;MPC
	FETCH(TTT,T,BORI)
	ANDI TTT,7
MD,<
	FETCH(TT,T,BLOC)
	JUMPE TT,NLCYET
	TRO TTT,400000		;MARK AS HAVING DIP NUMBER
	PUSHJ P,WORDOUT
	FETCH(TTT,T,BRSLOC)
	PUSHJ P,WORDOUT
	FETCH(TTT,T,BLXY)
	PUSHJ P,WORDOUT
	FETCH(TTT,T,BLO)
NLCYET:	PUSHJ P,WORDOUT
	FETCHL(TTT,T,BBIT)
	FETCH(TT,T,BID)
	HRR TTT,TT
	TLZ TTT,FOUNDB!BTMP1
	PUSHJ P,WORDOUT		;WRITE BITS AND BID
	FETCH(TT,T,BTYP)
	FETCH(TT,TT,TNAM)
	PUSHJ P,WSTR		;WRITE IT (PHEW!)
	FETCH(A,T,BTXT)
	PUSHJ P,WRTPRP
>;MD
MPC,<	FETCH(TT,T,BLN)
	HRL TTT,TT		;NUMBER LETTER
	PUSHJ P,WORDOUT
	FETCHL(TTT,T,BBIT)
	FETCH(TT,T,BID)
	HRR TTT,TT		;BITS,,ID
	PUSHJ P,WORDOUT		;OUTPUT BODY ID
	FETCH(A,T,BTYP)
	FETCH(TTT,A,TNAM)
	CAIE TTT,2		;2 PIN DIP?
	 JRST ISN2PN
	FETCH(TT,A,TPIN)
	FETCH(TT,TT,TPY)	;GET PIN SEPERATION (/2)
	HRL TTT,TT		;DIP-SPACING,,DIP# PINS
ISN2PN:	PUSHJ P,WORDOUT		;WRITE IT
>;MPC
WRTBD2:	HRRZ T,(T)		;NEXT BODY
	JUMPN T,WRTBOD		;ENDS WITH 0
BODDON:	PUSHJ P,WRPNTS
MPC,<
	SWITCH
	PUSHJ P,WRPNTS
	SWITCH
>;MPC
	JRST PNTDON
;		POINT SUBR (D,PC)
WRPNTS:	PUSHJ P,WRTMARK		;MARK END OF BODIES
	SKIPN T,PONPNT
	POPJ P,
WRTPNT:	MOVEI TTT,(T)		;POINTER TO POINT IN TTT
	PUSHJ P,SCHKID		;CHECK IF POINT SHOULD GO OUT
	 JRST WRTPN1		;NOT IN OUR SET
	FETCH(TTT,T,PXY)	;LOC OF POINT
	PUSHJ P,WORDOUT
	MOVEI TTT,(T)
	PUSHJ P,PUTID		;PUT OUT POINT ID
MD,<
	FETCH(TTT,T,PND)
	PUSHJ P,SPUTID
	FETCH(TTT,T,PNU)
	PUSHJ P,SPUTID
	FETCH(TTT,T,PNL)
	PUSHJ P,SPUTID
	FETCH(TTT,T,PNR)
	PUSHJ P,SPUTID
>;MD
MPC,<	FETCH(A,T,PNEB)		;POINTER TO NEIGHBOR BLOCK
	JUMPE A,WRTNE4		;NO NEIGHBORS
WRTNE1:	MOVEI B,2
WRTNE2:	XCT (B)[HLRZ TTT,(A)
		HRRZ TTT,1(A)
		HLRZ TTT,1(A)]
	JUMPE TTT,WRTNE3
	PUSHJ P,SPUTID
WRTNE3:	SOJGE B,WRTNE2
	HRRZ A,(A)
	JUMPN A,WRTNE1
WRTNE4:	PUSHJ P,WRTZERO
>;MPC
	MOVE TTT,ADDR(T,PBIT)	;BITS,,PAD/PIN #
MPC,<	AND TTT,[XWD FRONT!FEEDTH!PLANES!ISPIN!CPIN,-1]		>
MD,<	AND TTT,[XWD FIXTXT!FIXCON!FIXRHT!ISPIN!CPIN!CPNBTS,-1]	>
	PUSHJ P,WORDOUT		;WRITE THEM
MPC,<	HRRZ TTT,TTT
	CAMLE TTT,MXPADN
	MOVEM TTT,MXPADN
>;MPC
	FETCH(TT,T,PTXT)
	JUMPE TT,[PUSHJ P,WRTZERO
		JRST NOTEXT]
	FETCH(TTT,TT,TCSTR)
	FETCH(TTT,TTT,TSSIZ)	;SIZE OF TEXT
	PUSHJ P,WORDOUT
	FETCH(TTT,TT,TCXY)
	PUSHJ P,WORDOUT		;CONSTANT OFFSET
	FETCH(TT,TT,TCSTR)	;TEXT STRING
	PUSHJ P,WSTR
NOTEXT:
MD,<	FETCH(TT,T,PBIT)
	TRNN TT,CPIN		;CONNECTOR PIN?
	 JRST NOCPIN
	FETCH(TT,T,PLOC)	;CPIN BLOCK POINTER
	MOVE TTT,(TT)		;NLNLLN
	PUSHJ P,WORDOUT
	MOVE TTT,1(TT)		;X,Y CONSTANT OFFSET
	PUSHJ P,WORDOUT
NOCPIN:
>;MD
MPC,<	FETCH(TTT,T,PFEED)
	FETCH(B,T,PBIT)
	TRNN B,FEEDTH
	 MOVEI TTT,0
	PUSHJ P,SPUTID		>
WRTPN1:	FETCH(T,T,PNXT)		;NEXT POINT
	JUMPN T,WRTPNT		;ENDS WITH 0
	POPJ P,

SPUTID:	PUSHJ P,SCHKID		;CHECK IF IN OUR SET (OR WRITING WHOLE DRAWING)
	JRST WRTZERO
PUTID:	JUMPE TTT,WORDOUT
	PUSHJ P,GETID
	JRST WORDOUT

;GETID
;CALL WITH:
;	TTT	POINTER TO POINT
;RETURNS WITH
;	TTT	POINT ID
GETID:	PUSH P,TT
	FETCH(TT,TTT,PBIT)
	TRNE TT,ISPIN
	 JRST PINID		;PINS ARE HARDER
	POP P,TT
	FETCH(TTT,TTT,PID)
	POPJ P,

PINID:	FETCH(TT,TTT,BBODY)	;BODY OF PIN
	FETCH(TT,TT,BID)
	FETCH(TTT,TTT,BPLOC)
	FETCH(TTT,TTT,TPID)	;PIN ID FROM TYPE
	HRL TTT,TT		;BID,,TPID
	MOVSS TTT		;TPID,,BID
	POP P,TT
	POPJ P,

;SCHKID - CHECK ID
;TTT = POINT
;SKIPS
;RETURNS TTT = FLAGS,,POINT

SCHKID:	JUMPE TTT,CPOPJ1
	SKIPN SETFLG
	 JRST CPOPJ1		;WRITING WHOLE DRAWING
	PUSH P,T		;GET A REGISTER
	FETCH(T,TTT,PBIT)
	HRL TTT,T		;PUT FLAGS IN LH
	TLNE TTT,ISPIN		;PIN OR POINT
	JRST SCHKI1
	POP P,T
	TLNE TTT,1
	AOS (P)			;IN OUR SET, SKIP
	POPJ P,

SCHKI1:	FETCH(T,TTT,BBODY)
	FETCH(T,T,BBIT)
	HRL TTT,T
	POP P,T
	TLNE TTT,BTMP1		;IS IT IN OUR SET?
	AOS (P)			;YES, SKIP
	POPJ P,
;		SETS, END STUFF (D,PC)
PNTDON:	PUSHJ P,WRTMARK		;MARK END OF POINTS
	SKIPN A,SETPNT		;POINTER TO SETS
	JRST NOSETS		;NONE
WRTSET:	SKIPE SETFLG		;WRITING ALL SETS, OR
	CAMN A,SETFLG		;OR IS THIS THE SET WE WANT?
	CAIA			;YES
	JRST WASNUL
	HLRZ B,(A)		;POINTER TO SET
NULCHK:	SKIPE 1(B)		;ANYTHING HERE?
	JRST ISNNUL
	HRRZ B,(B)
	JUMPN B,NULCHK
	JRST WASNUL

ISNNUL:	MOVE TTT,1(A)		;CENTER OF SET
	PUSHJ P,WORDOUT
SETBOD:	HLRZ TTT,1(B)		;POINTER TO BODY
	JUMPE TTT,.+2
	PUSHJ P,BODID		;WRITE BODY ID
	HRRZ B,(B)		;NEXT
	JUMPN B,SETBOD
	PUSHJ P,WRTZERO		;MARK END OF BODIES
	HLRZ B,(A)		;POINTER TO SET
STPNT:	HRRZ TTT,1(B)		;POINTER TO POINT
	JUMPE TTT,NOSPNT	;NONE?
	PUSHJ P,PUTID
NOSPNT:	HRRZ B,(B)		;NEXT
	JUMPN B,STPNT
	PUSHJ P,WRTZERO		;MARK END OF POINTS
WASNUL:	HRRZ A,(A)		;NEXT SET
	JUMPN A,WRTSET		;LOOP

NOSETS:
MD,<
	PUSHJ P,WRTMARK		;END OF SETS
FOR I IN(TAUTHOR,TIT1,TIT2)
<	MOVE TT,I
	PUSHJ P,TWSTR
>
	MOVE TTT,CRDLOC
	PUSHJ P,WORDOUT		;WRITE PERM CARD LOC!
FOR I IN(TREV,TMODULE,TVARIABLE,TPREFIX,TPROJ,TPAGE,TOF,TDCODE,SITE1,SITE2)
<	MOVE TT,I
	PUSHJ P,TWSTR
>
DEC,<
	MOVE TT,TNXTHI
	PUSHJ P,TWSTR
FOR @$ I IN(DRN,CHK,ENG)
<	SKIPN TTT,I$NAM
	JRST NOW$I
	PUSHJ P,WORDOUT
	MOVE TTT,I$NAM+1
	PUSHJ P,WORDOUT
	MOVE TTT,I$NAM+3
NOW$I:	PUSHJ P,WORDOUT
>
>;DEC

NODEC,<	MOVEI TT,4
	PUSHJ P,WRTZERO		;0 NEXTHI, AND 3 SIGS
	SOJG TT,.-1
>;NODEC
>;MD
MPC,<	MOVEI TTT,400001	;END OF SETS (NEW TYPE OF END MARKER)
	PUSHJ P,WORDOUT
	MOVE TTT,CRDLOC		;LOCATION OF CARD
	PUSHJ P,WORDOUT
	MOVE TTT,CRDNAM
	PUSHJ P,WORDOUT
	HLLZ TTT,CRDEXT
	PUSHJ P,WORDOUT
	MOVE TTT,CRDPPN
	PUSHJ P,WORDOUT
	PUSHJ P,MXPADP		;PRINT MAX PAD TYPE
>;MPC
	MOVEI T,20
	PUSHJ P,WRTZERO
	SOJG T,.-1
DEC,<	SKIPN	THEREXISTS		;WRITING TMP FILE?
	JRST BAKXIT
	CLOSE	DAT,		;YES, DO SOME RENAMING
	MOVE	A,FILNAM
	MOVSI	B,'BAK'
	SETZ	C,
	MOVE	D,FILPPN
	LOOKUP	DAT,A
	JRST	BAKDON		;NO BAK FILE TO DELETE
	PUSHJ	P,CHKPPN
	JRST	BAKDON
	SETZ	A,
	RENAME	DAT,A		;DELETE OLD BAK FILE
	OUTSTR	[ASCIZ /CAN'T DELETE BAK FILE!
/]
BAKDON:	CLOSE	DAT,
	MOVE	A,FILNAM
	HLLZ	B,FILEXT
	SETZ	C,
	MOVE	D,FILPPN
	LOOKUP	DAT,A
	JRST	BAKOK		;NO DRW FILE TO RENAME TO BAK
	PUSHJ	P,CHKPPN
	JRST	BAKOK
	AND	C,[77000,,0]	;UNPROTECT THE BAK FILE
	MOVSI	B,'BAK'
	MOVE	D,FILPPN
	RENAME	DAT,A
MD,<	OUTSTR	[ASCIZ /CAN'T RENAME DRW TO BAK!
/]
>;MD
MPC,<	OUTSTR	[ASCIZ /CAN'T RENAME PC TO BAK!
/]
>;MPC
BAKOK:	CLOSE	DAT,
	MOVE	A,TMPNAM
	HLLZ	B,TMPEXT
	SETZ	C,
	MOVE	D,FILPPN
	LOOKUP	DAT,A
	JRST	[OUTSTR [ASCIZ /CAN'T FIND THE TMP FILE!
/]
		JRST .+1]
	RENAME	DAT,FILNAM
	OUTSTR	[ASCIZ /CAN'T RENAME TMP TO DRW!
/]
BAKXIT:
>;DEC
	RELEASE DAT,
	POPJ P,

DEC,<
CHKPPN:	MOVE	TTT,[3,,T]
	MOVEI	T,DAT
	PATH TTT,
	JRST CPOPJ1		;IF NO PATHS, MUST HAVE RIGHT FILE
	CAMN	TTT,FILPPN
	AOS	(P)
	POPJ	P,
>;DEC

MD,<
WRTBRD:	SKIPGE TT,WWTYP		;HERE TO WRITE OUT BOARD TYPE
	JRST WRTZERO		;NO BOARD SPECIFIED, WRITE A ZERO
	HRRZ TT,WNAMES(TT)
	JRST WASCIZ
>;MD

WRTNOM:	SKIPGE TT,NOMTYP
	JRST WRTZERO
	HRRZ TT,LNAMES(TT)
WASCIZ:	MOVE TTT,(TT)		;HERE WRITE OUT ASCIZ STRING
	PUSHJ P,WORDOUT
	TRNN TTT,376
	POPJ P,
	AOJA TT,WASCIZ

WSTR1:	TRNN TTT,377
	JRST FUCKUP		;CALL FUCKUP, AND DON'T RETURN HERE!
WSTR:	MOVE TTT,1(TT)
	PUSHJ P,WORDOUT
	HRRZ TT,(TT)
	JUMPN TT,WSTR1
	TRNE TTT,377
	PUSHJ P,WRTZERO
	POPJ P,

TWSTR:	JUMPN TT,WSTR		;WRITE STRING
WRTZERO:TDZA TTT,TTT
WRTMARK:MOVEI TTT,400000
WORDOUT:SOSG IOHD+2
	OUT DAT,
	CAIA
	JRST OUTERR
	IDPB TTT,IOHD+1
	POPJ P,

BODID:	FETCH(TTT,TTT,BID)
	JRST WORDOUT

OUTERR:	OUTSTR [ASCIZ/OUTPUT ERROR.
SHALL I CLOSE THE FILE (Y OR N)?/]
	INCHRW T
	CAIE T,"Y"
	CAIN T,"y"
	RELEASE DAT,
	RELEASE DAT,3
	MOVE P,PERRSAV		;GET BACK GOOD POINTER
NODEC,<	HALT CPOPJ	>
DEC,<	JRST TODDT	>


;WRTPRP - WRITE BODY OR BODY DEF PROPERTIES/TEXT
;CALL WITH BODY OR BODY DEF PROPERTY/TEXT LIST IN A

WPROP1:	FETCH(B,A,TXBIT)
	TRNE B,TXBIND
	JRST WPROP2
	FETCH(TT,A,TXVAL)
	SKIPN 1(TT)		;BUG TRAP, DON'T WRITE NULL STRINGS
	JRST WPROP2
	PUSHJ P,WSTR
	FETCH(TT,A,TXNAM)
	PUSHJ P,TWSTR
	FETCH(TTT,A,TXVAL)
	HLRZ TTT,(TTT)
	PUSHJ P,WORDOUT
	FETCH(TTT,A,TXXY)
	PUSHJ P,WORDOUT
	FETCH(TTT,A,TXOFF)
	PUSHJ P,WORDOUT
WPROP2:	HRRZ A,(A)
WRTPRP:	JUMPN A,WPROP1
	JRST WRTZERO
SUBTTL 'WD'	'WPC'
XLBITS__3		;3 BITS OF SIGNIFICANCE IN X
YLBITS__2		;2 IN Y
			;TO WIRE LISTER TO LOCATE BODY

EWLIST:	MOVSI T,EXTWIR
	PUSHJ P,SETLST		;WILL SKIP IF REMEMBERED NAME
WIRE:	 SETZM FILNAM
	MOVEM P,PERRSAV
	SKIPE FILNAM
	 JRST GOTWNM
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/WIRE LIST /]
	MOVSI T,EXTWIR
	PUSHJ P,SETNAM		;SET WIRE LIST FILENAME
	POPJ P,			;LET HIM OUT
GOTWNM:	ENTPPN
	INIT DAT,10
	'DSK   '
	XWD IOHD,0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	OUTBUF DAT,2
	MOVEM T,.JBFF
	PUSHJ P,EXIST		;DOES IT EXIST?
	POPJ P,			;DOESN'T WANT TO OVERWRITE IT
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
	ENTER DAT,FILNAM
	JRST [	RELEASE DAT,
		OUTSTR[ASCIZ/, ENTER FAILED.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
MD,<	MOVEI TTT,WDVER	>
MPC,<	MOVEI TTT,WPCVER>
	PUSHJ P,WORDOUT		;WRITE WIRE LIST FILE VERSION #
	HLLZ TTT,CRDLOC
	PUSHJ P,WORDOUT
MD,<
DEC,<	PUSHJ P,POLCHK		;CALCULATE AND PRINT POLARITY ERRORS
	HRRZ TTT,FNDNUM		;NUMBER OF ERRORS STORED HERE
	PUSHJ P,WORDOUT		;PUT INTO FILE (LH 0)
>;DEC
NODEC,<	PUSHJ P,WRTZERO	>	;MAKE FILE FORMATS THE SAME
	MOVE TTT,DRWDAT
	PUSHJ P,WORDOUT
	SKIPN TTT,DRWNAM
	MOVE TTT,FILNAM
	PUSHJ P,WORDOUT
	MOVE TTT,DRWEXT
	PUSHJ P,WORDOUT
	MOVE TTT,DRWPPN
	PUSHJ P,WORDOUT
FOR I IN(TREV,TMODULE,TVARIABLE,TPREFIX,TAUTHOR,TIT1,TIT2,TPROJ,TPAGE,TOF)
<	MOVE TT,I
	PUSHJ P,TWSTR
>
DEC,<	MOVE TT,TNXTHI
	PUSHJ P,TWSTR
>;DEC
NODEC,<	PUSHJ P,WRTZERO	>
	PUSHJ P,WRTNOM
	PUSHJ P,WRTBRD		;WRITE THE BOARD TYPE
	PUSHJ P,ITSET		;CALC SIZE OF DRAWING
NODEC,<	MOVE T,MAXX
	SUB T,MINX
	LSH T,-XLBITS		;MAKE 8 SECTIONS EACH WAY
	ADDI T,1
	MOVEM T,MAXX
	MOVE T,MINY
	SUB T,MAXY
	ASH T,-YLBITS
	SUBI T,1
	MOVEM T,MINY
>;NODEC
DEC,<
	MOVN T,WTAB+DINDEX	;WIDTH OF D-SIZE DWG
	ASH T,-XLBITS-2		;DIVIDE BY 4, MAKE XLBITS ^^2 SECTIONS
	SUBI T,1
	EXCH T,MAXX
	ADD T,MINX
	MOVE TT,WTAB+DINDEX
	ASH TT,-2
	ADD T,TT
	ASH T,-1
	ADDI T,1
	MOVEM T,MINX		;DEC COORD 0,0 IN LOWER RT
	MOVE T,HTAB+DINDEX
	ASH T,-YLBITS-2
	ADDI T,1
	EXCH T,MINY
	ADD T,MAXY
	MOVE TT,HTAB+DINDEX
	ASH TT,-2
	SUB T,TT
	ASH T,-1
	ADDI T,1
	MOVEM T,MAXY
>;DEC
>;MD
MPC,<	PUSHJ P,WRTNOM	>
;WRITE BODIES
	SKIPN A,DBODPN
	 JRST NOBODS
WBODLP:
MPC,<
	FETCH(TTT,A,BTYP)
	FETCHL(TTT,TTT,TNAM)
	FETCH(TT,A,BID)
	HRR TTT,TT
	PUSHJ P,WORDOUT		;# OF PINS,,BID
	FETCHL(TTT,A,BBIT)
	FETCH(TT,A,BLN)
	HRR TTT,TT
	PUSHJ P,WORDOUT		;BODY BITS,,LOC
	FETCH(TT,A,BNAM)
	PUSHJ P,TWSTR
>;MPC
MD,<
	FETCH(T,A,BTYP)
	FETCH(T,T,TNAM)
	FETCH(TT,T,TSASC)
	CAMN TT,[ASCIZ/GND/]	;GROUND BODIES ARE IGNORED
	 JRST FLUBDY
	HRRZS A			;THIS IS FIND ON BODY
	PUSHJ P,FNDDIP		;FIND DIP TYPE
	 JRST NOFLUB		;NONE
	FETCH(T,T,TXVAL)
	FETCH(T,T,TSASC)	;FIRST WORD OF DIP NAME
	CAME T,[NULNAM]		;EITHER KIND OF IGNORED BODY?
	CAMN T,[CABNAM]		;THIS TOO
	 JRST FLUBDY
NOFLUB:	PUSHJ P,APPXY		;CALC APPROX X AND Y
	FETCH(TT,A,BID)
	HRR TTT,TT
	PUSHJ P,WORDOUT		;APPROX LOC AND BID
	FETCH(TTT,A,BLOC)
	JUMPE TTT,WDNBLC	;ANY LOCN SET?
	FETCH(TTT,A,BRSLOC)
WDNBLC:	PUSHJ P,WORDOUT
	FETCHL(TTT,A,BBIT)
	TRZ TTT,-1
	PUSHJ P,WORDOUT
	FETCH(TT,A,BTYP)
	FETCH(TT,TT,TNAM)
	PUSHJ P,WSTR		;NAME OF TYPE
	FETPAK(TT,A)
	JUMPE TT,[PUSHJ P,WRTZERO
		JRST WLNLPK]
	HRRZ TT,PACKNM(TT)
	PUSHJ P,WASCIZ		;OUR IDEA OF PACKAGE NAME USED
WLNLPK:	FETCH(B,A,BTXT)		;ANY LOCAL PROPERTIES?
	JUMPN B,WLPRP1
	FETCH(B,A,BTYP)		;MAYBE ON TYPE THEN
	FETCH(B,B,TPROP)
	JUMPE B,NWLPRP
WLPRP1:	FETCH(C,B,TXBIT)	;WRITE ALL PROPS
	TRNN C,TXBIND		;INDIRECT TO TYPE?
	 SKIPA C,B
	 FETCH(C,B,TXIND)
	FETCH(TT,C,TXNAM)
	JUMPE TT,WLPRP2		;NO PROP NAME, JUST TEXT
	PUSHJ P,WSTR
	FETCH(TT,C,TXVAL)
	PUSHJ P,WSTR
WLPRP2:	FETCH(B,B,TXNXT)
	JUMPN B,WLPRP1
NWLPRP:	PUSHJ P,WRTZERO
FLUBDY:
>;MD
	FETCH(A,A,BNXT)
	JUMPN A,WBODLP
NOBODS:	PUSHJ P,WRTZERO
	SETZM WDOLST		;CLEAR DO LIST
	MOVSI C,3		;DONE BITS
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;CLEAR THE DONE BIT
MPC,<
	SKIPE A,PONPN2
	PUSHJ P,CLRBTS
	SKIPE A,PONPN2
	PUSHJ P,DOWIRE
>;MPC
	SKIPE A,PONPNT
	PUSHJ P,DOWIRE
	PUSHJ P,WRTZERO		;FLAG END WITH NULL WIRE
	PUSHJ P,WRTZERO		;AND NO PINS
	RELEASE DAT,
	POPJ P,

CLRBTS:	ANDCAM C,ADDR(A,PBIT)	;TURN OFF BIT
	FETCH(A,A,PNXT)
	JUMPN A,CLRBTS
	POPJ P,

APPXY:	HLRE T,1(A)		;X PART
	SUB T,MINX
	IDIV T,MAXX
	SKIPN MAXX
	MOVEI T,1(XLBITS-1)-1
	SKIPGE T
	SETZ T,
	CAIL T,1XLBITS
	MOVEI T,1XLBITS-1
	HRRE TT,1(A)		;Y PART
	SUB TT,MAXY
	IDIV TT,MINY
	SKIPN MINY
	MOVEI TT,1(YLBITS-1)-1
	SKIPGE TT
	SETZ TT,
	CAIL TT,1YLBITS
	MOVEI TT,1YLBITS-1
	ADDI TT,1
	DPB TT,[POINT 9,TTT,8]	;Y PART IS LETTER(ROW)
	ADDI T,1
	DPB T,[POINT 9,TTT,17]	;X PART IS NUMBER(COLUMN)
	POPJ P,

;		WIRES, WRITE SIGNAL NAME AND PIN INFO
DOWIRE:	HRLM A,(P)
	SETZM RUNBIT		;CLEAR RUN BITS
	TLZ WFLAG
	MOVE H,[1,,WDOSTR]	;OUTPUT ALL SIGNAL NAMES ON THIS WIRE
	MOVE T,A
	PUSHJ P,RECUR1		;TEST AND PUT IN LIST
	PUSHJ P,RECCHK		;CHECK FOR RECUR
	TLNE WFLAG		;WRITE 0 IF ANY SIGNALS OUT NOW
	 PUSHJ P,WRTZERO
	MOVE H,[2,,WDOPNT]	;OUTPUT ALL PINS ON WIRE
	HLRZ T,(P)
	PUSHJ P,RECUR1		;TEST AND PUT IN LIST
	PUSHJ P,RECCHK		;CHECK FOR RECUR
	TLNN WFLAG		;IF NOTHING PUT OUT
	 JRST NOWRUN		;THEN NO BITS OR END MARK
	PUSHJ P,WRTZERO		;MARK END OF WIRE
	MOVE TTT,RUNBIT		;GET RUN BITS
	PUSHJ P,WORDOUT		;WRITE THEM
NOWRUN:	HLRZ A,(P)
	FETCH(A,A,PNXT)
	JUMPN A,DOWIRE
	POPJ P,

;Check points for signal name
WDOSTR:	JFCL			;ALWAYS DO THIS PART
	FETCHL(D,A,PBIT)
MPC,<	LDB TT,[%%PLANES,,D]
	JUMPE TT,WRECUR		;IF NO PLANE CONNEX, JUST RECUR
	MOVE TTT,(TT)[	0
			ASCIZ/GND/
			ASCIZ/VCC/
			ASCIZ/VCC2/
			ASCIZ/VCC3/
			ASCIZ/PLN4/
			ASCIZ/PLN5/
			ASCIZ/PLN6/]
	PUSHJ P,WORDOUT
	TLO WFLAG		;NOTE SOMETHING PUT OUT
	JRST WRECUR
>;MPC
MD,<	TLNN D,ISPIN		;IS THIS ON A BODY?
	 JRST NGBODY
	FETCH(TT,A,BBODY)	;CHECK FOR GND BODY
	FETCH(TTT,TT,BTYP)
	FETCH(TTT,TTT,TNAM)
	FETCH(TTT,TTT,TSASC)
	CAMN TTT,[ASCIZ/GND/]	;BODIES NAMED GND GENERATE SIGNAL NAME GND
	 JRST [	TLO WFLAG
		PUSHJ P,WORDOUT
		JRST NGBODY]
	PUSH P,A
	HRRZ A,TT
	PUSHJ P,FNDDIP
	 JRST [	POP P,A
		JRST NGBODY]
	POP P,A
	FETCH(TTT,T,TXVAL)	;DIPTYPE "CABLE" CAUSES RUNS \C\
	FETCH(TTT,TTT,TSASC)
	CAME TTT,[CABNAM]
	 JRST NGBODY
	MOVEI TTT,CABBDY
	IORM TTT,RUNBIT		;TURN ON CABBDY IN RUNBITS
NGBODY:	FETCH(TT,A,PTXT)
	JUMPE TT,WRECUR		;ANY TEXT?
	FETCH(TT,TT,TCSTR)	;SKIP OVER OFFSET
	SKIPN TTT,ADDR(TT,TSASC)	;REALLY SOMETHING THERE? *** BUG TRAP
	 JRST WRECUR		;NO
	AND TTT,[774000,,0]
	CAMN TTT,[ASCIZ/;/]
	 JRST WRECUR		;FLUSH SIGNALS THAT ARE JUST COMMENTS
	PUSHJ P,WSTR		;WRITE SIGNAL NAME
	TLO WFLAG
	JRST WRECUR
>;MD

;Now output all pins on wire, ignoring duplicate, bussed thru pins
WDOPNT:	 JRST WRECUR		;THIS IS AN "OTHER" PIN, JUST RECUR ON IT
	FETCHL(D,A,PBIT)
	TLNN D,ISPIN
	 JRST WCPIN
MD,<	FETCH(TT,A,BBODY)	;IS PIN ON "GND" BODY
	FETCH(TTT,TT,BTYP)
	FETCH(TTT,TTT,TNAM)
	FETCH(TTT,TTT,TSASC)
	CAMN TTT,[ASCIZ/GND/]
	 JRST WRECUR		;YES, IGNORE
	PUSH P,A
	HRRZ A,TT
	PUSHJ P,FNDDIP
	 JRST [	POP P,A
		JRST NCNBDY]
	POP P,A
	FETCH(T,T,TXVAL)
	FETCH(TT,T,TSASC)
	CAME TT,[CABNAM]	;BODIES NAMED CABLE DO THIS
	CAMN TT,[NULNAM]	;IGNORE APPEARANCE BODIES
	 JRST WRECUR		;WAS A PIN, BUT WE ARE IGNORING IT
NCNBDY:
>;MD
	TLON WFLAG
	 PUSHJ P,WRTZERO	;FINISH SIGNAL NAMES
	FETCH(TTT,A,BBODY)
	FETCH(TTT,TTT,BID)
	PUSHJ P,WORDOUT		;WRITE BODY ID
	FETCH(TT,A,BPLOC)
MD,<	FETCH(TTT,A,BPPN)
	SKIPN TTT		;DO WE HAVE PIN NAME EXPLICITLY?
	 FETCH(TTT,TT,TPNAM)	;NO, USE DEFAULT
	FETCH(TT,TT,TPID)
	HRL TTT,TT
	PUSHJ P,WORDOUT		;WRITE PIN ID,,PIN NAME
	FETCHL(TTT,A,BPBIT)
	FETCH(TT,A,BPPN)
	SKIPE TT		;ANY EXPLICIT PIN?
	 TLZA TTT,DEFPIN	;YES, MAKE SURE DEFPIN OFF
	 TLO TTT,DEFPIN		;NO, SET DEFAULTED BIT
	PUSHJ P,WORDOUT		;BITS,,0
>;MD
MPC,<	FETCH(TTT,TT,TPID)
	HRL TTT,TTT
	PUSHJ P,WORDOUT		;PIN ID,,PIN NAME
>;MPC
	JRST WRECUR

WCPIN:	TLNN D,CPIN
	 JRST WRECUR		;NOTHING TO PUT OUT, JUST RECUR
	TLON WFLAG
	 PUSHJ P,WRTZERO
	FETCH(C,A,PLOC)
MD,<	MOVS TTT,(C)	>	;CPIN-LOC,,B-R-S
MPC,<	HRLZ TTT,(C)	>	;CPIN-LOC,,
	PUSHJ P,WORDOUT
MD,<	PUSHJ P,APPXY		;CALC APPROX X AND Y FOR CONNECTOR PIN
	FETCH(TT,A,PID)
	HRR TTT,TT		;PID
>;MD
MPC,<	FETCH(TTT,A,PID)  >
	PUSHJ P,WORDOUT
MD,<	FETCHL(TTT,A,PBIT)
	PUSHJ P,WORDOUT		;WRITE BITS,,0
>;MD
	JRST WRECUR

;		WIRES, RECUR
;TRACE ALL OF A WIRE
WRECUR:
MD,<	FETCH(T,A,PND)
	JUMPE T,.+2
	PUSHJ P,RECUR1
	FETCH(T,A,PNU)
	JUMPE T,.+2
	PUSHJ P,RECUR1
	FETCH(T,A,PNL)
	JUMPE T,.+2
	PUSHJ P,RECUR1
	FETCH(T,A,PNR)
	JUMPE T,.+2
	PUSHJ P,RECUR1
	FETCHL(D,A,PBIT)
	TLNN D,ISPIN		;PIN?
	 JRST RECCHK		;NO, DONE
;Look for bussed thru versions of this pin
	FETCH(C,A,BPLOC)
	FETCH(T,C,TPID)
	FETCH(TT,C,TPNAM)
	HRL T,TT		;TPNAM,,TPID
	FETCH(A,A,BBODY)
	FETCH(A,A,BLNK)
	JUMPE A,RECCHK
WIRPIN:	FETCH(B,A,BPLOC)
	FETCH(TT,B,TPID)
	FETCH(C,B,TPNAM)
	HRL TT,C		;TPNAM,,TPID
	XOR TT,T
	JUMPE TT,WIRPN1		;DON'T DO US
	TLNN TT,-1		;SAME PIN NAME?
	 JRST WPINFN		;YES
WIRPN1:	FETCH(A,A,BPLNK)
	JUMPN A,WIRPIN
	JRST RECCHK

WPINFN:	MOVE T,A
	PUSHJ P,RECUR0
>;MD
MPC,<	FETCHL(D,A,PBIT)
	TLNN D,ISPIN
	 JRST TSTFED
	FETCH(TTT,A,BPLOC)
	FETCH(T,A,BBODY)
	FETCH(T,T,BLNK)
	JUMPE T,WIRPN2
WIRPIN:	CAMN T,A
	 JRST WIRPN1
	FETCH(TT,T,BPLOC)
	CAMN TT,TTT
	 JRST WPINFN
WIRPN1:	FETCH(T,T,BPLNK)
	JUMPN T,WIRPIN
WIRPN2:	OUTSTR[ASCIZ/CAN'T FIND PIN ON OTHER SIDE.
/]
	PUSHJ P,FUCKUP
	JRST NOFED

WPINFN:	PUSHJ P,RECUR0
	JRST NOFED

TSTFED:	FETCH(T,A,PFEED)
	TLNE D,FEEDTH
	PUSHJ P,RECUR1
NOFED:	FETCH(B,A,PNEB)
	JUMPE B,RECCHK		;ANY NEIGHBORS?
WIRNE1:	MOVEI C,2
WIRNE2:	XCT(C)[HLRZ T,(B)
		HLRZ T,1(B)
		HRRZ T,1(B)]
	JUMPE T,.+2
	PUSHJ P,RECUR1
	SOJGE C,WIRNE2
	HRRZ B,(B)
	JUMPN B,WIRNE1
>;MPC
RECCHK:	SKIPN T,WDOLST		;ANYTHING LEFT TO DO?
	POPJ P,			;NO
	SKIPN A,1(T)		;IS IT A 1 OR 0 ?
	JRST DORCR0		;0
	HRRZ TT,(T)
	MOVEM TT,WDOLST
	FSTRET(T)
	JRST 1(H)

DORCR0:	HLRZ A,(T)
	HRRZ TT,(T)
	MOVEM TT,WDOLST
	FSTRET(T)
	JRST (H)

RECUR0:	PUSHJ P,RECURB
	HRLM T,(TT)
	POPJ P,

;RECURSE DOWN WIRE (T) - USE WDOLST FOR STACK
RECUR1:	PUSHJ P,RECURB
	MOVEM T,1(TT)
	POPJ P,

RECURB:	FETCHL(TTT,T,PBIT)
	TDOE TTT,H		;TEST AND SET BIT FROM LH OF H
	 JRST CPOPJ1
	STOREL(TTT,T,PBIT)
	GETFS(TT)		;SAVE CONTINUATION POINT
	SETZM 1(TT)
	EXCH TT,WDOLST
	HRRZM TT,@WDOLST
	MOVE TT,WDOLST
	POPJ P,
;'DAT'		WRITE FILE FOR INPUT TO WAGNER'S ROUTER SYSTEM
;X VALUE GREATER THAN 256 INDICATES SOLDER SIDE INSTEAD OF COMPONENT SIDE
MPC,<
WAG,<
UML,<
WRTRTE:	RELEASE DAT,
WROUTE:	SKIPN WIRLST
	JRST [	OUTSTR[ASCIZ/NO WIRES FOUND!
/]
		POPJ P,]
WRTRT1:	OUTSTR [ASCIZ /This code is broken, I didn't think anyone used it anymore..
/]
	PUSHJ P,FUCKUP
	POPJ P,

NIL,<	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ROUTER OUTPUT (DAT) /]
	MOVE H,[DATNAM]
	EXCH H,LSTNAM			;TEMPORARILY MAKE THIS  AND SAVE OLD
	MOVSI T,EXTROU
	PUSHJ P,SETNAM
	JRST [	MOVEM H,LSTNAM
		POPJ P,]
	ENTPPN
	MOVEM H,LSTNAM			;RESTORE REAL LSTNAM
	INIT DAT,0
	'DSK   '
	XWD IOHD,0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		JRST WRTRT1]
	PUSHJ P,EXIST			;CHECK IT
	JRST WRTRTE
	OUTSTR[ASCIZ/WRITING /]
	MOVEI A,FILNAM
	JSR FPRINT
	ENTER DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED!
/]
		JRST WRTRTE]
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	OUTBUF DAT,2
	MOVEM T,.JBFF
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PASS EXISITING WIRES/]
	PUSHJ P,YORN
	JFCL
	TLZA WFLAG
	TLO WFLAG
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PASS CONNECTOR PINS/]
	PUSHJ P,YORN
	JFCL
	TLZA ASK
	TLO ASK
	MOVEI T,ROUYMM*ROUSCL
	MOVEM T,MINY
	MOVEI T,ROUXMM*ROUSCL
	MOVEM T,MINX
	MOVSI C,1		;BIT TO CLEAR
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;CLEAR ON ONE SIDE
	SKIPE A,PONPN2
	PUSHJ P,CLRBTS		;AND OTHER
	MOVE C,WIRLST
	MOVEI G,1		;START WITH SIGNAL NUMBER OF 1
WRTRT2:	HRRZ D,1(C)
WRTTX1:	MOVEI E,NPASLN		;NUMBER OF ENTRIES IN TABLE
WRTTX4:	HLRZ A,1(D)
	JUMPE A,WRTTX3
	ADD A,[POINT 7,1]
	MOVE B,NOPASS(E)
	PUSHJ P,SIGMAT		;IS ONE OF THEM?
	JRST WRTTX5
	JFCL			;EQUIVALENT IS CLOSE ENOUGH
	OUTSTR @NOPASS(E)
	OUTSTR[ASCIZ/ RUN NOT PASSED!
/]
	JRST WRTTX2

WRTTX5:	SOJGE E,WRTTX4
WRTTX3:	HRRZ D,(D)
	JUMPN D,WRTTX1
	HRRZ B,1(C)
WRTRT3:	HRRZ A,1(B)		;GET CON HACK STUFF
	JUMPE A,WRTNOC		;IS THERE ONE?
	LDB T,[POINT 6,A,23]
	CAILE T,4		;FOONLY BOARDS HAVE 4 PADDLES!
	SKIPA T,[ROUXMB]
	MOVEI T,ROUXMT
	TRNE A,76
	ADDI T,SIDDIF
	PUSHJ P,WRTDEC		;WRITE WHICH EDGE NUMBER!
	MOVEI T,ROUANY		;CODE FOR "ANY" CONNECTOR PIN
	PUSHJ P,WRTDEC
	MOVE T,G		;SIGNAL NUMBER
	PUSHJ P,WRTDEC
	PUSHJ P,WCRLF
WRTNOC:	HLRZ A,(B)
	JUMPE A,.+2		;IS THERE ONE?
	PUSHJ P,WRTXY		;POOT IT OUT
	HRRZ B,(B)
	JUMPN B,WRTRT3
	ADDI G,1		;ANOTHER SIGNAL
WRTTX2:	HRRZ C,(C)
	JUMPN C,WRTRT2
	TLNN ASK
	JRST PREPS3		;IF NO CONNEX, NOTHING TO DO HERE
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PASS PREDETERMINED POWER AND GROUND CONNECTOR PINS/]
	PUSHJ P,YORN
	JRST PREPS2
	JRST PREPS2		;NO
	MOVSI C,-PRECLN
	SETZM NUMBER
	MOVEI G,NEVERC		;SIGNAL # FOR NEVER CONNECT HERE
PREPAS:	MOVE T,PRECON(C)
	MOVEM T,LETTER
	PUSHJ P,LOOK		;FIND CONNECTOR PIN
	JRST PREPS1
	MOVE A,T
	PUSHJ P,WRTXY
PREPS1:	AOBJN C,PREPAS
PREPS2:	TLNN WFLAG		;PASSING EXISTING WIRES?
	JRST PREPS3		;NO
	SKIPE A,PONPNT
	PUSHJ P,WRTUCN
	SKIPE A,PONPN2
	PUSHJ P,WRTUCN
PREPS3:	SETZ G,			;NO SIGNALS ON THESE
	JUMPGE SID,UNUSE1	;OTHER SIDE?
	SKIPE A,PONPNT		;NO, THIS IS THE SIDE THE SIGNALS POINT TO
	PUSHJ P,WRTRT4
	SKIPE A,PONPN2
	PUSHJ P,WRTBCN		;WRITE UNUSED BACK SIDE CONNECTORS
	JRST UNUSE2

UNUSE1:	SKIPE A,PONPN2
	PUSHJ P,WRTRT4
	SKIPE A,PONPNT
	PUSHJ P,WRTBCN
UNUSE2:	SETZ T,
	PUSHJ P,WRTDEC
	PUSHJ P,WRTDEC
	PUSHJ P,WRTDEC		;3 0'S TO END PINS
	PUSHJ P,WCRLF
	TLNN WFLAG		;ARE WE PASSING EXISTING WIRES?
	JRST NOWIRF
	OUTSTR[ASCIZ/PASSING EXISTING WIRES!
/]
	SKIPE A,PONPNT
	PUSHJ P,WRTWRF
	SKIPE A,PONPN2
	PUSHJ P,WRTWIR
NOWIRF:	SETZ T,
	PUSHJ P,WRTDEC		;END WITH 4 ZEROES
	PUSHJ P,WRTDEC
	PUSHJ P,WRTDEC
	PUSHJ P,WRTDEC
	PUSHJ P,WCRLF		;END ALL WIRES
	RELEASE DAT,		;CLOSE OUTPUT
	POPJ P,
;		ROUTER OUTPUT SUBRS
WRTUCN:	HLRZ TT,(A)
	HRRZ T,1(TT)
	MOVE T,1(T)
	TLNN T,CPIN		;CONNECTOR PIN?
	JRST WRTUCM
	HLRZ TT,1(TT)		;SEE IF ANY CONNECTIONS
	JUMPE TT,WRTUCM
WRTUCO:	SKIPE 1(TT)
	JRST WRTUCP
	SKIPN TT,(TT)
	JRST WRTUCM
	TLNN TT,-1
	JRST WRTUCO
WRTUCP:	PUSHJ P,WRTXY		;WRITE IT
WRTUCM:	HRRZ A,(A)
	JUMPN A,WRTUCN
	POPJ P,

WRTRT4:	PUSHJ P,WRTXY
	HRRZ A,(A)
	JUMPN A,WRTRT4
	POPJ P,

WRTDEC:	MOVEI TTT,4
WRTDC1:	IDIVI T,=10
	HRLM TT,(P)
	SOJLE TTT,.+2
	PUSHJ P,WRTDC1
	HLRZ TTT,(P)
	ADDI TTT,60
	JRST WORDOUT

WRTBCN:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLON TT,1
	TLNN TT,CPIN			;CONNECTOR PINS ONLY ON THIS SIDE
	JRST WRBCNN
	MOVEM TT,1(T)
	PUSHJ P,GOCON
WRBCNN:	HRRZ A,(A)
	JUMPN A,WRTBCN
	POPJ P,

WRTXY:	HLRZ T,(A)
	HRRZ T,1(T)
	MOVE TT,1(T)
	TLOE TT,1
	POPJ P,				;ALREADY DONE!
	MOVEM TT,1(T)
	TLNN TT,ISPIN			;ONLY PINS FOR NOW
	JRST GOCON
	HLRE T,1(A)
	ADD T,MINX			;ADD OFFSET
	CAIG T,ROUXMB*ROUSCL		;DON'T PASS AS CONNECTOR
	PUSHJ P,UNDERX
	CAIL T,ROUXMT*ROUSCL
	PUSHJ P,OVERX
	IDIVI T,ROUSCL			;SCALE IT!
	TRZN T,1			;MAKE IT ON EVEN LOC
	SKIPE TT
	OUTSTR[ASCIZ/PIN ON ODD X LOC, I MOVED IT LEFT!
/]
	PUSHJ P,WRTDEC
	HRRE T,1(A)
	ADD T,MINY
	IDIVI T,ROUSCL
	TRZN T,1
	SKIPE TT
	OUTSTR[ASCIZ/PIN ON ODD Y LOC, I MOVED IT DOWN!
/]
WCONP:	CAIGE T,ROUYMB
	PUSHJ P,UNDERY
	CAILE T,ROUYMT
	PUSHJ P,OVERY
	PUSHJ P,WRTDEC
	MOVE T,G			;GET WIRE NUMBER
	PUSHJ P,WRTDEC
WCRLF:	MOVE TTT,IOHD+2
	CAIG TTT,2			;TWO OR MORE?
	SETZM IOHD+2			;NO, FORCE OUTPUT
	MOVEI TTT,15			;STUFF A CRLF ON THE END
	PUSHJ P,WORDOUT
	MOVEI TTT,12
	JRST WORDOUT

GOCON:	TLNE ASK
	TLNN TT,CPIN
	POPJ P,				;RANDOM POINT OR NOT DOING CPINS
	HLRE T,1(A)
	SKIPL T				;JUST WANT TO KNOW WHICH END
	SKIPA T,[ROUXMT*ROUSCL]
	MOVEI T,ROUXMB*ROUSCL
	EQV TT,SID
	JUMPL TT,.+2
	ADDI T,SIDDIF*ROUSCL		;OTHER SIDE
	IDIVI T,ROUSCL
;	SKIPE TT
;	OUTSTR[ASCIZ/CONNECTOR PIN ON ODD X LOC, I MOVED IT LEFT.
;/]
	PUSHJ P,WRTDEC
	HRRE T,1(A)
	ADD T,MINY
	IDIVI T,ROUSCL
;	SKIPE TT
;	OUTSTR[ASCIZ/CONNECTOR PIN ON ODD Y LOC, I MOVED IT DOWN!
;/]
	JRST WCONP

OVERX:	MOVEI T,(ROUXMT-1)*ROUSCL
	OUTSTR[ASCIZ/X VALUE OVERFLOW!
/]
	POPJ P,

UNDERX:	MOVEI T,(ROUXMB+1)*ROUSCL
	OUTSTR[ASCIZ/X VALUE UNDERFLOW!
/]
	POPJ P,

OVERY:	MOVEI T,ROUYMT
	OUTSTR[ASCIZ/Y VALUE OVERFLOW!
/]
	POPJ P,

UNDERY:	MOVEI T,ROUYMB
	OUTSTR[ASCIZ/Y VALUE UNDERFLOW!
/]
	POPJ P,

WRTXYC:	HLRE T,1(A)
	ADD T,MINX			;ADD OFFSET
	CAIG T,ROUXMB*ROUSCL
	PUSHJ P,UNDERX
	CAIL T,ROUXMT*ROUSCL		;TOO BIG?
	PUSHJ P,OVERX
	HLRZ TT,(A)
	HRRZ TT,1(TT)
	MOVE TT,1(TT)
	EQV TT,SID
	JUMPL TT,WRTXYZ
	ADDI T,ROUSCL*SIDDIF
WRTXYZ:	IDIVI T,ROUSCL			;SCALE IT!
	SKIPE TT
	OUTSTR[ASCIZ/SEGMENT ON ODD X LOC, I MOVED IT LEFT!
/]
	PUSHJ P,WRTDEC
	HRRE T,1(A)
	ADD T,MINY
	IDIVI T,ROUSCL
	SKIPE TT
	OUTSTR[ASCIZ/SEGMENT ON ODD Y LOC, I MOVED IT DOWN!
/]
	CAIGE T,ROUYMB
	PUSHJ P,UNDERY
	CAILE T,ROUYMT
	PUSHJ P,OVERY
	JRST WRTDEC

WRTWRF:	HLRZ B,(A)
	HRRZ T,1(B)
	MOVE T,1(T)
	TLNN T,FEEDTH			;PASS FEED THROUGH?
	JRST WRTWIF
	PUSHJ P,WRTXYC			;X,Y ON COMPONENT SIDE
	PUSH P,A
	HLRZ A,(A)
	HLRZ A,(A)
	PUSHJ P,WRTXYC			;X,Y ON SOLDER SIDE
	POP P,A
	PUSHJ P,WCRLF
WRTWIF:	PUSHJ P,WRTWI0
	HRRZ A,(A)
	JUMPN A,WRTWRF
	POPJ P,

WRTWIR:	HLRZ B,(A)
	PUSHJ P,WRTWI0
	HRRZ A,(A)
	JUMPN A,WRTWIR
	POPJ P,

WRTWI0:	HLRZ B,1(B)
	JUMPE B,CPOPJ
WRTWI3:	MOVEI C,2
WRTWI1:	XCT (C)[HLRZ D,(B)
		HLRZ D,1(B)
		HRRZ D,1(B)]
	JUMPE D,WRTWI2
	MOVE T,1(A)
	CAML T,1(D)			;ONLY DO EACH SEGMENT ONCE
	JRST WRTWI2			;WRONG WAY
	MOVE TT,T			;GET COPY OF X,Y
	ADJUST(SUB,TT,<1(D)>)		;GET DELTAS
	TLNE TT,-1			;EITHER DELTA 0?
	TRNN TT,-1
	JRST NDELTA			;YES, THAT'S OK
	HRRE TTT,TT
	HLRE TT,TT
	CAMN TT,TTT			;SAME?
	JRST NDELTA
	MOVN TT,TT
	CAMN TT,TTT			;HOW ABOUT NOW?
	JRST NDELTA
	OUTSTR[ASCIZ/SORRY, LOSING WAGNER GETS ILL MEM REF'S
IF YOU PASS HIM AN EXISTING DIAGONAL ROUTE THAT
IS NOT A 45 DEGREE ANGLE!
/]
	JRST WRTWI2

NDELTA:	PUSHJ P,WRTXYC			;WRITE X,Y OF A
	PUSH P,A
	MOVE A,D
	PUSHJ P,WRTXYC			;NOW OTHER END
	POP P,A
	PUSHJ P,WCRLF
WRTWI2:	SOJGE C,WRTWI1
	HRRZ B,(B)
	JUMPN B,WRTWI3
	POPJ P,
;		TABLES FOR ROUTER OUTPUT
;TABLE OF PRESET POWER AND GROUND CONNECTOR PINS
DEFINE PCON(A,B,C)
<
XX1__IFL "A"-"G"<"A";>IFL "A"-"I"<"A"-1;>IFL "A"-"O"<"A"-2;>IFL "A"-"Q"<"A"-3;>"A"-4
XX1__XX1-100
XX2__IFL "B"-"G"<"B";>IFL "B"-"I"<"B"-1;>IFL "B"-"O"<"B"-2;>IFL "B"-"Q"<"B"-3;>"B"-4
XX2__XX2-100

	BYTE(6)0,0,0,XX1-100,XX2-100,C
>

PRECON:	PCON	A,B,1
	PCON	A,F,1
	PCON	A,L,1
	PCON	A,R,1
	PCON	A,U,1
	PCON	A,U,2
	PCON	A,V,1
	PCON	A,V,2
	PCON	B,A,1
	PCON	B,A,2
	PCON	B,B,1
	PCON	B,B,2
	PCON	B,F,1
	PCON	B,L,1
	PCON	B,R,1
	PCON	B,U,1
	PCON	C,B,1
	PCON	C,F,1
	PCON	C,L,1
	PCON	C,R,1
	PCON	C,U,1
	PCON	C,U,2
	PCON	C,V,1
	PCON	C,V,2
	PCON	D,A,1
	PCON	D,A,2
	PCON	D,B,1
	PCON	D,B,2
	PCON	D,F,1
	PCON	D,L,1
	PCON	D,R,1
	PCON	D,U,1
PRECLN__.-PRECON

;TABLE OF SIGNALS NOT TO PASS TO THE ROUTER
NOPASS:	[<ASCII/VCC/>
		ASCIZ/VCC/]
	[<ASCII/GND/>
		ASCIZ/GND/]
	[<ASCII/HI/>
		ASCIZ/HI/]
NPASLN__.-NOPASS-1

>;NIL
>;UML
>;WAG
>;MPC
