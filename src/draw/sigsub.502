;<WIRELIST>SIGSUB.FAI.116,  6-NOV-75 19:24:28, EDIT BY HELLIWELL
SUBTTL	SIGNAL NAME PROCESSOR
MDPC,<VERSION(SIGSUB,1)>
BEGIN SIGSUB

MD,<DEFINE MDWL <IFE 0>>
MPC,<DEFINE MDWL <IFN 0>>
MWL,<DEFINE MDWL <IFE 0>>

MDPC,<
OPDEF PUTSTR[OUTSTR]
OPDEF PUTSIG[OUTSTR]
OPDEF PUTBYT[OUTCHR]
>;MDPC

;ITS and III want's to do polarity stuff also
DEFINE POL <IFN DECSW!ITSSW!IIISW>
DEFINE NOPOL <IFE DECSW!ITSSW!IIISW>

COMMENT  CALLING SEQUENCE

PUSHJ P,SIGSUB
<ERROR IN SOME EXPRESSION>
<EXPRESSIONS PARSED OK>

CLOBBERS T, TT, TTT


EXTERNAL SUBRS

PUSHJ P,SIGGET
<CHAR IN TTT, 0 IF END OF STRING>

PUSHJ P,GETVAR
<NO SUCH VARIABLE>
<VALUE OF VARIABLE FROM TTT IN TT>

EXTERNAL VARIABLES
UPPER	UPPER BOUND ON RESULTANT EXPRESSIONS (INCLUSIVE)
LOWER	LOWER BOUND ON RESULTANT EXPRESSIONS (INCLUSIVE)
MXSTLN	MAX STRING LENGTH (FOR SIGBUF)


;DATA AREA

MDPC,<STORAGE(IMPURE)>

TNDIG:		0
SELCHR:		0
ERRORP:		0
^SIGEND:	0
^SIGBUF:	BLOCK MXSTLN
MDWL,<
^^DOVARS:	-1			;expand vars in expressions
>;MDWL

MDPC,<STORAGE(PURE)>
;TOP LEVEL CONTROL OF EXPRESSION EVALUATION
; byte pointer to string in A
; returns string in SIGBUF, SIGEND points to last word
; may expand variables if DOVARS set
; skips if no error in signal

^SIGSUB:
MDWL,<	SETZM EXPER2  >		;NO VARIABLE ERRORS YET
	SETZM SELCHR		;NOT IN SELECT TO START WITH
	MOVE T,[POINT 7,SIGBUF]
	MOVEM P,ERRORP		;FOR ERROR RETURN
	PUSHJ P,SIGS		;START AS NORMAL SIGNAL
	AOS (P)
SIGE1:	SETZ TTT,
	IDPB TTT,T		;DON'T CALL SPUTIT,
	TLNE T,760000		;WE ARE ONLY FILLING OUT WORD
	JRST .-2		;FILL OUT LAST WORD
	HRRZM T,SIGEND		;STORE END FOR LOSER
	POPJ P,

SIGE:	MOVE P,ERRORP
	JRST SIGE1

SIG0:	PUSHJ P,SPUTIT
SIGS:
SIG1:	PUSHJ P,SIGONE		;GET A CHAR
	POPJ P,			;FINI
SIG2:	CAMN TTT,SELCHR		;END OF SELECTOR?
	JRST SIGSEL		;YES
	CAIN TTT,";"		;IF COMMENT
	JRST SIGC		;JUST COPY REST
	CAIN TTT,"]"		;END OF BRACKET GROUP?
	JRST SIGECK		;YES, EITHER END OF "," GROUP OR ERROR
	CAIE TTT,"["
	JRST SIG0
	PUSHJ P,BRACKET		;BRACKET SCANNER
	JRST SIG1

SIGC:	PUSHJ P,SPUTIT
	PUSHJ P,SIGONE
	POPJ P,
	JRST SIGC

;SKIP TO ] (END OF SELECTOR EXPRESSION)
SIGSEL:	SETZ TT,
SIGSL1:	PUSHJ P,SIGONE
	JRST SIGE
	CAIN TTT,"["
	AOJA TT,SIGSL1
	CAIN TTT,"]"
	SOJL TT,CPOPJ
	JRST SIGSL1

SIGECK:	EXCH TTT,SELCHR		;SAVE US AND GET SELCHR
	CAIE TTT,","		;ARE WE IN "," GROUP?
	JRST SIGE		;NO, ERROR
	EXCH TTT,SELCHR		;YES, RESTORE CHARS
	POPJ P,			;AND RETURN TO BRACKET ROUTINE

;BRACKET AND CONDITIONAL INTERPRETER
comment 
Format of Bracketed expression:
[...]			expression with value
[...{<text>}...]	select expression if value is non-zero
[<select#>,case1,case2,...,casen]	case expression

;BRACKET - Parse expression constructs

BRACKET:SETZM NDIG		;NO WIDTH FROM VARS YET
	PUSHJ P,EXPR
	CAIE TTT,"]"		;IS IT NORMAL EXPRESSION?
	JRST SELCHK		;NO, CHECK FOR SELECTOR
MDWL,<	SKIPN DOVARS
	JRST SIGN0
	CAMG TT,UPPER
	JRST SIGN1
	SUB TT,UPPER
	SUBI TT,1
	IDIV TT,WIDTH
	MOVE TT,TTT
	ADD TT,LOWER
	JRST SIGN0

SIGN1:	CAML TT,LOWER
	JRST SIGN0
	SUB TT,LOWER
	ADDI TT,1
	IDIV TT,WIDTH
	MOVE TT,TTT
	ADD TT,UPPER
SIGN0:
>;MDWL
	MOVEI TTT,"-"
	SKIPGE TT
	PUSHJ P,SPUTIT
	MOVM TT,TT
	PUSHJ P,PUTNUM
	POPJ P,			;ALL DONE

PUTNUM:	MOVE TTT,NDIG
	MOVEM TTT,TNDIG		;THIS IS HOW MANY DIGITS TO PRINT, MIN.
PUTNM1:	IDIVI TT,=10
	HRLM TTT,(P)
	SOSG TNDIG		;ENOUGH DIGITS YET?
	JUMPE TT,.+2
	PUSHJ P,PUTNM1
	HLRZ TTT,(P)
	ADDI TTT,60
SPUTIT:	CAMN T,[POINT 7,SIGBUF+MXSTLN-1,27]
	JRST [	PUTSTR[ASCIZ/EXPRESSION BUFFER OVERFLOW - SIGNAL IS:
/]
		SETZ TTT,
		IDPB TTT,T
		TLZ T,7700	;STOP DEPOSITING BYTES AND SUPPRESS ERROR
		PUTSTR SIGBUF
		JRST SIGE]
	IDPB TTT,T
	POPJ P,

;SELECTOR CHECK
SELCHK:	CAIE TTT,173		;STANDARD CASE (=0)?
	JRST COMCHK		;CHECK FOR "," CONSTRUCT
	JUMPE TT,SELNOK		;NOT THIS ONE IF NOT TRUE (0)
	PUSH P,SELCHR		;SAVE OLD SELECT END
	MOVEI TTT,176		;THIS IS NEW ONE
SELDO:	MOVEM TTT,SELCHR
	PUSHJ P,SIGS
	POP P,SELCHR		;RESTORE  OLD SELCHR
	CAIE TTT,"]"
	JRST SIGE
	POPJ P,

SELNOK:	SETZ TT,
SELNK1:	PUSHJ P,SIGONE
	JRST SIGE
	CAIN TTT,173
	AOJA TT,SELNK1
	CAIN TTT,176
	SOJL TT,BRACKET		;BACK TO BRACKET ROUTINE IF AT RIGHT LEVEL
	JRST SELNK1

COMCHK:	CAIE TTT,","		;CASE EXPR?
	JRST SIGE		;NO, LOSE
	JUMPLE TT,SIGSEL	;- IS AUTO NOTHING
	PUSH P,[0]		;MAKE A MATCHING [] COUNT
	JRST COMCK2		;SEEN ONE ","

COMCK1:	PUSHJ P,SIGONE
	JRST SIGE
	CAIN TTT,"["
	AOS (P)
	CAIN TTT,"]"
	SOS (P)
	SKIPGE (P)		;END OF SELECTOR GROUP?
	JRST [	POP P,(P)	;YES
		POPJ P,]
	SKIPG (P)		;ARE WE AT RIGHT LEVEL TO CHECK ","?
	CAIE TTT,","		;YES
	JRST COMCK1		;NO COMMA, OR NO CHECK
COMCK2:	SOJG TT,COMCK1		;THERE YET?
	POP P,(P)		;LOSE COUNT
	PUSH P,SELCHR		;YES, SAVE OLD SELCHR
	MOVEI TTT,","		;THIS IS NEW ONE
	JRST SELDO		;REST IS SAME AS  OTHER GUY
;EXPRESSION SUBRS - SCAN WITHIN "[...]" IN SIGNAL

;CURRENT PRECEDENCE ORDER FOR EXPRESSIONS (HIGHEST TO LOWEST BINDING POWER)
comment 
Format of bracket expression

()	arithmetic grouping
[]	imbedded brackets construct

Unary operators
	Boolean not
-	arithmetic negation
+	ignored
"	value of ascii A-Z
<var>	variable name (only WL)		;only if DOVARS set
<number>

Binary operators
&	logical AND
!	logical OR
/	divide
*	multiply
'	mod (A'B= A mod B)
+	add
-	sub
=	boolean equal
	boolean not eq
<	boolean valued less
>	boolean valued greater
	less equal
	geater equal
	and
	or
;comment



;EXPR - scan arithmetic/logical expression
;return value in TT, termination char in TTT
EXPR:
LANDOR:	PUSHJ P,BOOL
LNDOR1:	CAIN TTT,""
	JRST EXPLAND
	CAIN TTT,13		;sail  char
	JRST EXPLOR
	POPJ P,

EXPLAND:PUSH P,TT
	PUSHJ P,BOOL
	SKIPE TT
	SETO TT,
	ANDM TT,(P)
	POP P,TT
	JUMPE TT,LNDOR1
	SETO TT,
	JRST LNDOR1

EXPLOR:	PUSH P,TT
	PUSHJ P,BOOL
	IORM TT,(P)
	POP P,TT
	JUMPE TT,LNDOR1
	SETO TT,
	JRST LNDOR1

BOOL:	PUSHJ P,ADDSUB
BOOL1:	CAIN TTT,"="
	JRST BOOLE
	CAIN TTT,""
	JRST BOOLN
	CAIN TTT,74
	JRST BOOLL
	CAIN TTT,76
	JRST BOOLG
	CAIN TTT,""
	JRST BOOLLE
	CAIN TTT,""
	JRST BOOLGE
	POPJ  P,

FOR @$ I IN(E,N,L,G,LE,GE)
<BOOL$I:PUSH P,TT
	PUSHJ P,ADDSUB
	MOVEM TT,1(P)
	POP P,TT
	CAM$I TT,2(P)
	TDZA TT,TT
	SETO TT,
	JRST BOOL1
>

ADDSUB:	PUSHJ P,DIVMUL		;FIRST OPERAND (WILL RETURN IF NOT */&!)
ADSUB1:	CAIN TTT,"+"
	JRST EXPADD
	CAIN TTT,"-"
	JRST EXPSUB
	POPJ P,			;NOT + OR - OR HIGHER OP, RETURN UP LEVEL

EXPADD:	PUSH P,TT		;SAVE SUM
	PUSHJ P,DIVMUL		;CHECK FOR HIGHER PRECEDENCE OP
	ADD TT,(P)
	POP P,(P)
	JRST ADSUB1

EXPSUB:	PUSH P,TT
	PUSHJ P,DIVMUL
	EXCH TT,(P)
	SUB TT,(P)
	POP P,(P)
	JRST ADSUB1

DIVMUL:	PUSHJ P,ANDOR		;WILL RETURN WHEN NO &! SEEN
DVML1:	CAIN TTT,"/"
	JRST EXPDIV
	CAIN TTT,"*"
	JRST EXPMUL
	CAIN TTT,"'"
	JRST EXPMOD
	POPJ P,			;NOT / OR * OR ' RETURN UPLEVEL

EXPDIV:	PUSH P,TT
	PUSHJ P,ANDOR
	JUMPE TT,SIGE		;DIVIDE CHECK
	EXCH TT,(P)
	IDIVM TT,(P)
	POP P,TT
	JRST DVML1

EXPMUL:	PUSH P,TT
	PUSHJ P,ANDOR
	IMULM TT,(P)
	POP P,TT
	JRST DVML1

EXPMOD:	PUSH P,TT		;SAVE EXP1
	PUSHJ P,ANDOR
	EXCH TTT,(P)		;GET EXP1 -> TTT
	EXCH TT,TTT
	IDIV TT,TTT		;EXP1 mod EXP2
	MOVE TT,TTT
	POP P,TTT
	JRST DVML1

ANDOR:	PUSHJ P,PRIMRY
ANDOR1:	CAIN TTT,"&"
	JRST EXPAND
	CAIN TTT,"!"
	JRST EXPOR
	POPJ P,

EXPAND:	PUSH P,TT
	PUSHJ P,PRIMRY
	ANDM TT,(P)
	POP P,TT
	JRST ANDOR1

EXPOR:	PUSH P,TT
	PUSHJ P,PRIMRY
	IORM TT,(P)
	POP P,TT
	JRST ANDOR1

PRIMRY:	PUSHJ P,SIGONE
	JRST SIGE		;LEAVE ON EOF
	CAIE TTT," "
	CAIN TTT,""
	JRST PRIMRY		;IGNORE THESE
	CAIE TTT,"("
	JRST NOPARN
	PUSHJ P,EXPR
	CAIN TTT,")"
	PUSHJ P,SIGONE
	JRST SIGE
	POPJ P,

NOPARN:	CAIE TTT,"["		;START OF ANOTHER BRACKETS CONSTRUCT?
	JRST NOBRAK		;NO
	PUSH P,T		;SAVE CURRENT DEPOSIT POINTER
	PUSHJ P,BRACKET
	SETZ TTT,
	PUSHJ P,SPUTIT
	MOVE T,(P)		;GET TO FRONT OF IT
	ILDB TTT,T
	JUMPE TTT,SIGE
BRKEXP:	CAIL TTT,"0"
	CAILE TTT,"9"
	JRST SIGE
	IMULI TT,=10
	ADDI TT,-60(TTT)
	ILDB TTT,T
	JUMPN TTT,BRKEXP
	POP P,T			;NOW BACK TO ORIGNINAL DEPOSIT POINTER
	PUSHJ P,SIGONE		;GOBBLE CHAR AFTER []
	JRST SIGE
	POPJ P,

NOBRAK:	CAIE TTT,""
	JRST NONOT
	PUSHJ P,EXPR		;THIS GIVES  LOWEST PRECEDENCE
	SKIPE TT		;DO LOGICAL INVERSION
	TDZA TT,TT
	SETO TT,
	POPJ P,

NONOT:	CAIE TTT,"-"
	JRST NMINUS
	PUSHJ P,PRIMRY
	MOVN TT,TT
	POPJ P,

NMINUS:	CAIN TTT,"+"
	JRST PRIMRY
	CAIE TTT,'"'+40
	JRST NQUOTE
	PUSHJ P,SIGONE
	JRST SIGE
	CAIL TTT,"A"+40
	CAILE TTT,"Z"+40
	CAIA
	JRST ISQUOT
	CAIL TTT,"A"
	CAILE TTT,"Z"
	JRST SIGE
ISQUOT:	MOVE TT,TTT
	PUSHJ P,SIGONE
	JRST SIGE
	POPJ P,

NQUOTE:
MDWL,<	CAIL TTT,"A"
	CAILE TTT,"Z"
	CAIA
	JRST GVAR		;LOOKUP VARIABLE
>;MDWL
	SETZ TT,
	CAIL TTT,"0"
	CAILE TTT,"9"
	JRST SIGE		;DOESN'T EVEN START WITH A DIGIT
PRIM1:	IMULI TT,=10
	ADDI TT,-60(TTT)
	PUSHJ P,SIGONE
	JRST SIGE
	CAIL TTT,"0"
	CAILE TTT,"9"
	POPJ P,
	JRST PRIM1

MDWL,<
GVAR:	SKIPE DOVARS
	PUSHJ P,GETVAR
	JRST SIGE		;UNKNOWN VARIABLE
	PUSHJ P,SIGONE
	JRST SIGE
	POPJ P,
>;MDWL
SUBTTL	PERMUT STORAGE

COMMENT 
CALLING SEQUENCE

	<INITIAL BYTE POINTER USED BY SIGONE IN A>
	PUSHJ P,PERMUT
	<PERMUTED STRING RETURNED IN CMPWRD+PERMTB>

CLOBBERS T, TT, TTT, A, B, C, D

;GLOBAL AND ONLY GLOBAL CHARACTER
^GLBCHR__"^"

;FLAG REGISTER, USE H FROM BOTH D AND WL
SFLAG_H

;CONTROL FLAGS FOR PERMUT (RH OF SFLAG)
MDPC,<
EXTRA1__1		;EXTRACT CONSTANT LEADER
EXTRA2__2		;EXTRACT CONSTANT TRAILER
EXTRAS__4		;EXTRACT NON-CONSTANT SIGNAL NAME
SAW01__10		;SAW A (0) OR (1) CONSTRUCT
LEADN__20		;LEADING NOT SEEN
>;MDPC

NOCAN__40000		;SPWR ISN'T CANONICAL
BSSEEN__100000		;SEEN DIFFERENCES IN BS CONSTRUCT
TBSGTR__200000		;BS IN T IS GREATER
PRMTMP__400000		;TEMP FLAG

;FLAGS USED BY PERMUT (LH OF SFLAG)
GLB1SN__1
GLB2SN__2
EXPERR__4
WHERR__10
NFLAG1__100000
NFLAG2__200000
POL,<POLFLG__400000>

;EXTERNAL SYMBOLS NEEDED
;ALL THESE ARE RIGHT HALF BITS STORED IN SAVBIT
	;GLB1	COPIED FROM GLB1SN
	;GLB2	COPIED FROM GLB2SN
	;SGND	SPECIAL SIGNAL BIT
	;SPWR		"
	;SHI		"
	;SNC		"
	;SCANON	IF SPWR, THIS IS THE CANONICAL FORM (+5.00V)
;SIGGET		ROUTINE TO GET CHAR INTO TTT
;MXSTLN		MAX STRING LENGTH (FOR PERMTB)
;EXPER2		ZEROED BY PERMUT AND SIGSUB,
;		SHOULD BE SET TO 0,,-1 FOR VAR NOT FOUND

;MAX EXTRACTED SIGNAL LENGTH
ESGTLN__MXSTLN	;SAME AS MAX SIGNAL NAME FOR NOW

MDPC,<STORAGE(IMPURE)>
^SAVBIT:	0
^WQNWRD:	0
WQNTMP:		0
WQNTM1:		0
^VOLTAGE:	0			;voltage if signal looks like +5.0V

^CMPWRD:	0
^PERMTB:	BLOCK MXSTLN		;EXPANDED SIGNAL
MDPC,<
^SIGTAB:	0
^SIGSTR:	BLOCK MXSTLN
ESGPTR:		0
ESGSAV:		0
^ESGTAB:	BLOCK ESGTLN		;EXTRACTED SIGNAL
>;MDPC
GETSIG:		HALT			;GET A CHARACTER
SIGPTR:		0			;SAVED POINTER TO BEGINNING OF STRING
FLGSAV:		0			;SAVE SFLAG HERE
MDPC,<
^POLAR:		0			;POLARITY INDICATOR
^OPOLAR:	0			;OLD POLAR FOR PERMES
>;MDPC
IFN PERMTB-CMPWRD-1,<PRINTS /CMPWRD DOES NOT IMMEDIATELY PRECEED PERMTB.
/>
MDPC,<STORAGE(PURE)>
SUBTTL	PERMUT
;SIGMAA - Setup SIGTAB with canonicalized version of signal name in
;	preparation for calling SIGMAT
MDPC,<
^SIGMAA:SETZM VARLST		;NO VARS HERE
	PUSH P,C
	PUSH P,D
	PUSHJ P,PERMUT
	MOVE T,[CMPWRD,,SIGTAB]
	BLT T,SIGSTR+MXSTLN-1
	POP P,D
	POP P,C
	POPJ P,

^PERME1:MOVEM SFLAG,FLGSAV		;EXTRACT CONSTANT LEADER
	MOVEI SFLAG,EXTRA1
	JRST PERMEA

^PERME2:MOVEM SFLAG,FLGSAV		;EXTRACT CONSTANT TRAILER
	MOVEI SFLAG,EXTRA2
	JRST PERMEA

^PERMES:MOVEM SFLAG,FLGSAV		;EXTRACT NON-CONSTANT PART OF SIGNAL NAME
	MOVEI SFLAG,EXTRAS
PERMEA:	MOVE T,[POINT 7,ESGTAB]
	MOVEM T,ESGPTR
	SETZM VARLST
	JRST PERMT1
>;MDPC

;SOME HANDY MACROS FOR EXTRACTING

DEFINE EPUT1<
MDPC,<TRNE SFLAG,EXTRA1
	PUSHJ P,EPUTIT
>;MDPC
>

DEFINE EPUT2<
MDPC,<TRNE SFLAG,EXTRA2
	PUSHJ P,EPUTIT
>;MDPC
>

DEFINE EPUTS<
MDPC,<TRNE SFLAG,EXTRAS
	PUSHJ P,EPUTIT
>;MDPC
>
;PERMUT - SCAN SIGNAL AND CANONICALIZE, EXTRACT
; A is byte pointer to string
; Expands string into SIGBUF (interpretting bracketed expressions)
; Copies string into PERMTB possibly modified to eliminate extra nots, etc.
; Extracts leading or trailing constant part into ESGTAB
; Checks for BS construct, \letter#number\, accumulates in WQNWRD
; Checks for trailing assertion/polarity indicators. (0,1) H,L,!
; Generates CMPWRD from PERMTB, possibly flushing leading "-"
; Checks signal for special cases (GND,VCC,+5.0V, etc.) and sets flags, VOLTAGE
; Returns flags in T, SAVBIT - (SGND, SPWR, SHI, SNC, )

comment 
Some parts of string are extracted, and remember depending on EXTRA1, EXTRA2
String is parsed to consist of:
 leading spaces			;class 1
 ^,^^	global signal flag	;class 1
 more spaces			;class 1
 -,~,-~,~-, (and spaces)	;class 1 or 2
 text				;class 1 or 2 and main string
 \...\	BS construct		;class 2
 trailing spaces		;flushed
POL,<
 (0,1)				;class 2
  H,L,!   trailing polarity signals
>;POL
 ;	  comment		;class 2 and main string

note: BS construct - qualifier letters and wire rule numbers
	are returned in WQNWRD = <qualifier code>,, BBBBNN
	Rule #'s seem to be BBBBNN where NN is rule number of which
	 there must be only one on a run.  BBBB are "bits" which are
	 IORed for all rule specs on run. ??


^PERMUT:
	MOVEM SFLAG,FLGSAV
	SETZ SFLAG,			;CLEAR ALL FLAGS
PERMT1:	MOVEM A,SIGPTR			;SAVE POINTER TO FRONT OF STRING
	SETZM EXPER2
	SETZM VOLTAGE
MDPC,<	SETZM WQNWRD			;CLEAR HERE FOR DWG PROG
POL,<	SETZM POLAR	>
>;MDPC
MWL,<	TRNE ISBACK			;CAUSE FIRST ^ TO TURN ON GLB2
	TLO SFLAG,GLB1SN
>;MWL
	SKIPN VARLST			;ANY VARS?
	 JRST PERM0			;NO, SKIP THIS
   ; If there are variables, and the signal evaluates without error,
   ; replace the orginal string with the variable expansion.
	SETO TTT,			;FLAG NO EOS YET
	PUSHJ P,SIGSUB			;MUNG STRING
	TLO SFLAG,EXPERR		;ERROR, COPY ORIGINAL
	SKIPN EXPER2			;VARIABLE ERROR?
	 TLNE SFLAG,EXPERR		;IF ANY ERROR, DON'T USE RESULT
	  JRST PERM0			;YES, COPY ORIGINAL STRING
	MOVE A,[POINT 7,SIGBUF]
	MOVE T,[PUSHJ P,[ILDB TTT,A
			JUMPN TTT,CPOPJ1
			POPJ P,]]
	JRST PERM0A

; Now extract assorted special fields in signal name
PERM0:	MOVE A,SIGPTR			; Maybe error in variable expansion,
	MOVE T,[PUSHJ P,SIGONE]		; use original string
PERM0A:	MOVEM T,GETSIG
	MOVE B,[POINT 7,PERMTB]
	JRST PERMS0

;Extract leading spaces, "global" signal,... 
PERMSP:	EPUT1				;EXTRACT LEADER?
PERMS0:	XCT GETSIG
	 JRST LEAVED
	CAIN TTT," "
	 JRST PERMSP
	CAIE TTT,GLBCHR		;GLOBAL CHAR?
	 JRST NOGLOB
	TLOE SFLAG,GLB1SN	;TURN ON AND CHECK GLB1SN
	TLOA SFLAG,GLB2SN	;WE GET BOTH
	 JRST PERMSP		;TRY FOR ANOTHER
GGLOB2:	EPUT1
	XCT GETSIG
	 JRST LEAVED
	CAIN TTT," "
	JRST GGLOB2
;Now try to straighten out -,, and ~
NOGLOB:
NOIII,<
NOITS,<
NODEC,<
;Foonly style, can have tilde or not
	CAIE TTT,NOTCHR
	 JRST PERMNT
PRMSP1:	EPUTS
	XCT GETSIG
	JRST [	MOVEI TTT,NOTCHR	;Signal is just "-"
		PUSHJ P,PUTIT
		JRST LEAVED]
	CAIN TTT," "
	 JRST PRMSP1
	CAIE TTT,NOTCHR		;CATCH CASE OF DOUBLE NOT
	CAIN TTT,32
	 JRST PERM2		;TILDA AND NOT, FLUSH
	JRST PRMNT1

PERMNT:	CAIE TTT,32
	 JRST PERM1		;STARTUP HERE
PRMSP2:	EPUTS
	XCT GETSIG
	JRST [	MOVEI TTT,32
		PUSHJ P,PUTIT
		JRST LEAVED]
	CAIN TTT," "
	JRST PRMSP2
	CAIN TTT,NOTCHR
	 JRST PERM2
PRMNT1:	MOVE T,TTT		;Found single Tilde or Not
	MOVEI TTT,NOTCHR
	PUSHJ P,PUTIT
	MOVE TTT,T
	JRST PERM1
>;NODEC
>;NOITS
>;NOIII

;DEC, III and ITS, only look for not-character (-)
IFN DECSW!ITSSW!IIISW,<
	CAIE TTT,NOTCHR		;REMEMBER IF WE SAW A -
	 JRST PERM1
	EPUTS
MDPC,<	TRO SFLAG,LEADN	>	;SAW LEADING NOT
	XCT GETSIG		;GET NEXT CHAR ALSO
	 JRST [	MOVEI TTT,NOTCHR
		PUSHJ P,PUTIT
		JRST LEAVED]
	CAIN TTT,NOTCHR		;DOUBLE - ?
	 JRST PERM2		;YES, THEY CANCEL
	TLO SFLAG,NFLAG1	;NO, REMEBER INITIAL ONE
	MOVE T,TTT
	MOVEI TTT,NOTCHR
	PUSHJ P,PUTIT
	MOVE TTT,T
	JRST PERM1
>;DECSW!ITSSW!IIISW
;Parsed over leading spaces, inversion chars, global chars
; Now read main part of signal name
PERM2:	EPUTS
	XCT GETSIG
	 JRST BACKSP
PERM1:				;PARSED OVER LEADING -,SPACES ETC.
MWL,<	TRNE ISBACK	>	;DON'T EXTRACT QN IN WL UNLESS BP
	CAIE TTT,"\"		;QN ESCAPE?
	 JRST NOQN
	PUSHJ P,GETQN		;YES
	 JRST BACKSP
NOQN:	CAIN TTT,";"		;; IS SPECIAL
	 JRST BACKSP
	PUSHJ P,PUTIT
	JRST PERM2

;Done with signal, backspace over any trailing spaces, polarity or 0,1 assertions
BACKSP:	MOVE C,B
	LDB D,C			;GET LAST CHAR STORED
BACKS1:	MOVE B,C		;SKIP SPACES SO FAR
	CAIE D," "		;BACK UP OVER SPACES
	 JRST STRTHL
	PUSHJ P,GETREV
	 JRST NBACK
	JRST BACKS1

; Look for H,L or assertion (0,1) at end of signal name
STRTHL:
POL,<	MOVEI T," "		;THIS IS DEFAULT ASSERTION
	TLZ SFLAG,NFLAG2
	MOVE C,B		;GET COPY OF DEPOSIT POINTER
	LDB D,C			;GET LAST CHAR DEPOSITED
	CAIN D,"L"
	 TLOA SFLAG,NFLAG2!POLFLG
	  CAIN D,"H"
	   JRST DOHL
	PUSHJ P,CHK01		;(0 or 1)?
	 JRST NOHL
	JRST END01A

;Saw trailing H or L, check for <space> or 0,1
DOHL:	PUSHJ P,GETREV
	 JRST NBACK
	CAIE D," "
	 JRST DOHL1		;maybe "... 0H"?
DOHL0:	PUSHJ P,GETREV
	 JRST NBACK
	CAIN D," "
	 JRST DOHL0		;skip spaces
	MOVE B,C
	PUSHJ P,CHK01		;maybe "...(0)   H"?
	 JRST ENDHL		; No, just "... H"
END01A:	MOVE B,C		;DELETE THE 01 HL STUFF TEMPORARILY
MDPC,<	TRO SFLAG,SAW01	>
	TLNN SFLAG,NFLAG2!NFLAG1	;Both NOTCHR and Polarity off?
	 JRST ENDHL			;YES, NO CHANGE
	TLC SFLAG,NFLAG2!NFLAG1
	TLCN SFLAG,NFLAG2!NFLAG1	;OR BOTH ON?
	 JRST ENDHL			;YES, STILL NO CHANGE
	TLC SFLAG,NFLAG2		;INVERT SENSE OF -
	TRC T,1				;AND 0 OR 1
ENDHL:	TLNN SFLAG,NFLAG2		;ARE WE CHANGING SENSE OF MINUS?
	 JRST ENDHLA			;NO, GO ON
;Standardizing to polarity "H" causes the NOTCHR at head of signal to change
	SETZ TTT,			;TERMINATE STRING SO WE CAN SHIFT IT
	PUSHJ P,PUTIT
	MOVE B,[POINT 7,PERMTB]
	TLCN SFLAG,NFLAG1		;YES, INVERT SENSE OF MINUS
					;AND SEE IF WE MUST INSERT OR REMOVE IT
	JRST [	MOVEI TT,NOTCHR		;MUST INSERT ONE
		MOVE C,[POINT 7,PERMTB]	;GET STRING FROM HERE
		JRST ENDHLB]
	MOVE C,[POINT 7,PERMTB,6]	;MUST REMOVE -, START HERE
	ILDB TT,C			;START WITH THIS CHAR
	JUMPE TT,ENDHLA			;UNLIKELY, BUT CAN HAPPEN
ENDHLB:	ILDB TTT,C			;MAKE SURE WE STAY AHEAD OF IT
	EXCH TT,TTT
	PUSHJ P,PUTIT
	JUMPN TT,ENDHLB
ENDHLA:	MOVEI TTT,11			;If there is H,L , put tab in front
	PUSHJ P,PUTIT
	MOVE TTT,T			;" ", "0", OR "1"
	PUSHJ P,PUTIT
	MOVEI TTT,"H"
	PUSHJ P,PUTIT
MDPC,<	MOVEI TTT,"H"
	TLNE SFLAG,POLFLG
	 MOVEI TTT,"L"
	HRROM TTT,POLAR
>;MDPC
	JRST NBACK

;Have seen trailing H,L, check for assertion 0,1
DOHL1:	CAIE D,"0"		;H OR L PRECEEDED BY 0?
	CAIN D,"1"		;OR 1?
	JRST [	MOVE TTT,D	;REMEMBER 0 OR 1
		PUSHJ P,CHK01S	;ANY SPACE IN FRONT OF 01?
		 JRST NBACK	;NO SPACE(S)
		MOVE T,TTT	;Remember assertion was 0 or 1
		JRST END01A]	;OK
	PUSHJ P,CHK01		;NO, CHECK () VERSION
	 JRST NBACK
	JRST END01A

;Check for (0,1) at end of name
;Skips if succesful
;returns:
;T = "0" or "1"
CHK01:	CAIE D,")"
	 POPJ P,
	PUSHJ P,GETREV
	 POPJ P,
	MOVE TTT,D		;ASSERTION 0,1?
	TRZ D,1
	CAIE D,"0"
	 POPJ P,
	PUSHJ P,GETREV		;YES
	 POPJ P,
	CAIE D,"("
	 POPJ P,
	PUSHJ P,CHK01S		;EAT ANY EXTRA SPACES
	 JFCL
	MOVE T,TTT		;REMEMBER ASSERTION AS 0,1
	JRST CPOPJ1
	
;CHK01S - TEST FOR ANY LEADING SPACES (SKIPS IF THERE ARE ANY)
CHK01S:	PUSHJ P,GETREV
	 POPJ P,
	CAIE D," "
	 POPJ P,		;NO SPACE
CHK012:	PUSHJ P,GETREV
	 JRST CPOPJ1
	CAIN D," "
	 JRST CHK012
	JRST CPOPJ1

MDPC,<
GETRVS:	CAME C,[POINT 7,ESGTAB]
	CAMN C,[POINT 7,ESGTAB,6]		;CAN WE BACKUP?
	POPJ P,					;NO
	ADD C,[70000,,0]
	JUMPGE C,.+2
	SUB C,[430000,,1]
	LDB D,C
	JRST CPOPJ1
>;MDPC

;No H,L at end, maybe " !" which means don't insist on H,L on signal (DEC)
NOHL:
MDPC,<
DEC,<	CAIN D,"!"
	PUSHJ P,GETREV
	 JRST NBACK
	CAIN D," "
	 AOS POLAR	;INDICATE " !" AT END OF STR
>;DEC
>;MDPC
>;POL
;Finish up - Copy last part of signal name (comment, etc.)
NBACK:	MOVE TTT,SIGCHR		;GET LAST CHAR
	JUMPE TTT,LEAVED	;END IF EOL
STOCOM:	PUSHJ P,PUTIT
	EPUT2
	XCT GETSIG
	 JRST LEAVED
	JRST STOCOM


GETREV:	CAMN C,[POINT 7,PERMTB,6]	;CAN WE BACKUP?
	 POPJ P,			;NO
	ADD C,[70000,,0]
	JUMPGE C,.+2
	SUB C,[430000,,1]
	LDB D,C
	JRST CPOPJ1

;Finish up with nulls, and generate CMPWRD
LEAVED:	SETZ TTT,			;YES, FINISH OUT WORD
PERM8:	IDPB TTT,B			;CAN'T OVERFLOW TABLE
	TLNE B,760000
	 JRST PERM8
MDPC,<	TRNN SFLAG,EXTRA1!EXTRA2!EXTRAS
	 JRST PERMEC
	MOVE B,ESGPTR
PERMEB:	IDPB TTT,B
	TLNE B,760000
	 JRST PERMEB
	MOVEM B,ESGPTR
POL,<	JRST PERMDC  >
PERMEC:
>;MDPC
;Generate CMPWRD from signal, used for hash matching
	SETZM CMPWRD
	MOVE A,[POINT 7,CMPWRD]
	MOVE B,[POINT 7,PERMTB]
	TLZ SFLAG,NFLAG1
	PUSHJ P,ENDGET
	 JRST CKERR
	CAIN T,NOTCHR
	TLOA SFLAG,NFLAG1
	 JRST PRM10A
PERM10:	PUSHJ P,ENDGET
	 JRST CKERR		;EOL OR ";"
PRM10A:	IDPB T,A
	TLNE A,760000		;ENOUGH FOR CMPWRD?
	JRST PERM10
CKERR:	TLNN SFLAG,WHERR	;WAS THERE AN ERROR?
	 JRST CKERR0
	PUTSTR[ASCIZ/CAUSED BY SIGNAL - /]
	PUTSIG PERMTB
	PUTSTR[ASCIZ/
/]
CKERR0:	TLNN SFLAG,EXPERR		;WAS THERE AN ERROR?
	 JRST CKSIG
	PUTSTR[ASCIZ/ERROR IN EXPRESSION(S) - /]
	PUTSIG PERMTB
	PUTSTR[ASCIZ/
/]
	JRST CKSIG
;Screw around with negation, assertion and polarity to
;make it agree with old signal name that is being replaced
MDPC,<
POL,<
PERMDC:	TRNN SFLAG,EXTRAS
	 JRST PERMEC
	SKIPGE TTT,POLAR
	CAMN TTT,OPOLAR
	 JRST PERMEC			;NEW HAS NO POLARITY OR IS SAME AS OLD
	SKIPL OPOLAR			;DID OLD HAVE POLARITY?
	 JRST PERMEC			;NO
	MOVE C,ESGPTR			;GET EXTRACT POINTER
PERMED:	PUSHJ P,GETRVS
	 JRST PERMEC
	CAIE D,"L"
	CAIN D,"H"
	CAIA
	 JRST PERMED
	CAIE D,"L"
	SKIPA D,["L"]
	MOVEI D,"H"
	DPB D,C			;CHANGE SENSE OF POLARITY
	TRNE SFLAG,LEADN	;LEADING NOT?
	 JRST PERMEE		;YES, DELETE IT
	TRNN SFLAG,SAW01	;DID WE PASS OVER A 0 OR 1?
	 JRST PERMEF		;NO, INSERT NOT
PERMEG:	PUSHJ P,GETRVS
	JRST [	PUTSTR[ASCIZ/ERROR IN PERMES, 0 OR 1 NOT FOUND IN SIGNAL:
/]
		PUTSTR ESGTAB
		PUTSTR[ASCIZ/
/]
		JRST PERMEF]
	CAIE D,"0"
	CAIN D,"1"
	TRCA D,1		;FOUND 0 OR 1, COMPLEMENT AND SKIP
	 JRST PERMEG
	DPB D,C			;STORE BACK
	JRST PERMEC

;Delete NOTCHR at start of signal
PERMEE:	MOVE A,[POINT 7,ESGTAB]
PERMEH:	ILDB TTT,A
	CAIE TTT,NOTCHR
	JUMPN TTT,PERMEH
	JUMPE TTT,[PUTSTR[ASCIZ/ERROR IN PERMES, "-" NOT FOUND IN SIGNAL:
/]
		PUTSTR ESGTAB
		PUTSTR[ASCIZ/
/]
		JRST PERMEC]
	MOVE B,A
	ILDB TTT,A
	DPB TTT,B
PERMEI:	ILDB TTT,A
	IDPB TTT,B
	JUMPN TTT,PERMEI
	JRST PERMEC

;Insert NOTCHR at beginning of ESGTAB table 
PERMEF:	MOVE A,[POINT 7,ESGTAB]
	MOVE B,A
	MOVEI TTT,NOTCHR
PERMEJ:	ILDB TT,A
	IDPB TTT,B
	SKIPE TTT,TT
	JRST PERMEJ
PERMEK:	IDPB TTT,B
	TLNE B,760000
	JRST PERMEK
>;POL
>;MDPC
;CKSIG - CHECK SIGNAL IN PERMTB FOR SPECIAL CASES
; returns flags in T,SAVBIT
; checks for signals of the form +5.0V, returns VOLTAGE and SPWR bit
; checks for known signals like HI, NC, VCC, GND, +3, HIGH, etc.

CKSIG:	MOVE B,[POINT 7,PERMTB]		;PREPARE TO SCAN SIGNAL
	PUSHJ P,ENDGET			;SIGNAL NAME TERMINATED?
	JRST NCKPWR			;YES, SEE IF IT LOOKS LIKE SPECIAL SIGNAL NAME

;Check for signal of the form +5V, +5.0V, etc.
	TRZ SFLAG,NOCAN		;ASSUME IT IS FULL, CANONICAL
	CAIN T,"-"
	 JRST [	TRO SFLAG,PRMTMP
		JRST CKPWR1]
	CAIE T,"+"
	 JRST NCKPWR
	TRZ SFLAG,PRMTMP
CKPWR1:	SETZ A,				;CLEAR NUMBER ACCUMULATOR
CKPWR2:	PUSHJ P,ENDGET
	 JRST NCKPWR
	CAIL T,"0"
	CAILE T,"9"
	 JRST CKPWR3
	IMULI A,=10			;ACCUMULATE LEADING DIGITS "+5???"
	ADDI A,-"0"(T)
	JRST CKPWR2

CKPWR3:	IMULI A,=100			;WILL ADD UP TO 2 MORE DIGITS
	CAIE T,"."			;"+5.???"
	 JRST CKPWR5
	PUSHJ P,ENDGET
	 JRST NCKPWR
	CAIL T,"0"
	CAILE T,"9"
	 JRST CKPWR5			;FIRST MUST BE DIGIT
	SUBI T,"0"			;"+5.0???"
	IMULI T,=10
	ADDI A,(T)
	PUSHJ P,ENDGET
	 JRST NCKPWR
	CAIL T,"0"
	CAILE T,"9"
	 JRST CKPWR4			;"+5.00???"
	ADDI A,-"0"(T)
	PUSHJ P,ENDGET
	 JRST NCKPWR
	CAIA
CKPWR5:	 TRO SFLAG,NOCAN
CKPWR4:	CAIE T,"V"			;"+5.00V?"
	 JRST NCKPWR
	TRNE SFLAG,PRMTMP
	MOVN A,A
	PUSHJ P,CKSIGE
	 JRST NCKPWR
	MOVEM A,VOLTAGE			;RETURN MARKED AS PWR SIGNAL
	MOVEI T,SPWR
	TRNN SFLAG,NOCAN
	 TRO T,SCANON		;IS CANONICAL FORM
	JRST CKSIG5

;CHECK FOR SPECIAL SIGNALS - GND, VCC, ETC.
NCKPWR:	MOVSI C,-SPLEN
CKSIG1:	MOVE A,SPTAB(C)
	HRLI A,(<POINT 7,0>)
	MOVE B,[POINT 7,PERMTB]
CKSIG2:	ILDB TT,A
	JUMPE TT,CKSIG3
	PUSHJ P,ENDGET
	 JRST CKSIG4
	CAMN TT,T
	 JRST CKSIG2
CKSIG4:	AOBJN C,CKSIG1
	SETZ T,
CKSIG5:	TLNE SFLAG,GLB1SN
	TRO T,GLB1
	TLNE SFLAG,GLB2SN
	TRO T,GLB2
	MOVEM T,SAVBIT		;RETURN BITS HERE
	MOVE SFLAG,FLGSAV
	POPJ P,

CKSIG3:	PUSHJ P,CKSIGE
	 JRST CKSIG4
	HLRZ T,SPTAB(C)			;GET FLAGS TO MARK AS SPWR,SNC,SHI,SGND,..
	MOVEI TT,=500		;+5.00V
	TRNE T,SPWR		;Signal VCC
	 MOVEM TT,VOLTAGE
	JRST CKSIG5

CKSIGE:	PUSHJ P,ENDGET
	JRST CPOPJ1
	CAIN T,40
	AOS (P)
	POPJ P,

;ENDGET - check termination of string in B
; skips over spaces (if not significant) and BS constructs
; skips if ended with other than space,tab,";", or end of string
; returns terminating char in T
ENDGET:	ILDB T,B
PERM13:	JUMPE T,CPOPJ		;END OF STRING
	CAIE T,"\"		;MAY BE BS CONSTRUCT - "\<letter>#<number>\"
	 JRST PERM12
	PUSH P,TT		;DON'T CLOBBER TT
	MOVEI TTT,B		;GET POINTER TO BYTE POINTER
	PUSHJ P,SKIPBS		;SKIP BS STUFF
	SKIPA T,TT		;NO SKIP IF NOTHING THERE
	JRST [	MOVE T,TT	;CHAR AFTER TERMINATING "\"
		POP P,TT
		JRST PERM13]	;WAS BS, LOOP BACK FOR CHECK
	POP P,TT
PERM12:	CAIE T," "
	 JRST PERM11
MWL,<	TRNN PETIT	>
MDPC,<	TRNN M,SPACES	>
	 JRST ENDGET
PERM11:	CAIN T,11
	 POPJ P,
	CAIE T,";"
	 AOS (P)
	POPJ P,
;HANDLE QUALIFIER LETTERS AND WIRE RULE NUMBERS
GETQN:
MDPC,<	MOVE C,ESGPTR
	MOVEM C,ESGSAV
	EPUT2
>;MDPC
	SETZM WQNTMP		;CLEAR TMP CELLS
	MOVE C,A		;SAVE CURRENT GET POINTER IN CASE OF ERROR
	XCT GETSIG
	JRST QNERR
	EPUT2
	CAIN TTT,"#"
	JRST DON
	SKIPN TTT,QL2N(TTT)	;GET CODE FOR LETTER
	JRST QNERR		;NO CODE
	HRLM TTT,WQNTMP		;STORE CHARACTER CODE
	XCT GETSIG
	JRST QNERR
	EPUT2
	CAIE TTT,"#"
	JRST DONE
DON:	SETZ T,
DON1:	XCT GETSIG
	JRST QNERR
	EPUT2
	CAIL TTT,"0"
	CAILE TTT,"9"
	JRST DOQ
	IMULI T,=10
	ADDI T,-60(TTT)
	CAILE T,777777		;FIT IN HALFWORD?
	JRST QNERR
	JRST DON1

DOQ:	HRRM T,WQNTMP
DONE:	CAIE TTT,"\"
	JRST QNERR
	HRRZ T,WQNTMP
	HRRZ TT,WQNWRD
	PUSHJ P,WHCHRN
	TLO SFLAG,WHERR
	HRRM T,WQNWRD
	HLRZ T,WQNWRD
	HLRZ TT,WQNTMP
	PUSHJ P,WHCHQ
	TLO SFLAG,WHERR		;GET SIGNAL PRINTED
	HRLM T,WQNWRD
	JRST SIGONE

QNERR:	MOVE A,C
MDPC,<	MOVE C,ESGSAV
	MOVEM C,ESGPTR
>;MDPC
	PUSH P,TTT
	MOVEI TTT,"\"
	EPUTS
	PUSHJ P,PUTIT
	POP P,TTT
	JRST CPOPJ1

;WHCHQ - CHECK QUALIFIER LETTERS IN T,TT
;SKIPS IF OK, T = NEW (TT) UNLESS NULL
^WHCHQ:	JUMPE TT,CPOPJ1
	EXCH T,TT
	JUMPE TT,CPOPJ1
	CAMN T,TT
	JRST CPOPJ1
	HRL T,TTT
	PUSH P,T
	PUTSTR[ASCIZ/MULTIPLE QUALIFIER LETTERS "/]
	PUTBYT @QN2L(T)
	PUTSTR[ASCIZ/" AND "/]
	PUTBYT @QN2L(TT)
	PUTSTR[ASCIZ/"
/]
	POP P,T
	HLRZ TTT,T
	POPJ P,

;WHCHRN - CHECKS RULE NUMBERS IN T,TT FOR COMPATIBILITY
;RETURNS (SKIP IF OK) T = COMBINED RULES
;Rule #'s seem to be BBBBNN where NN is rule number of which
; there must be only one on a run.  BBBB are "bits" which are
; IORed for all rule specs on run. ??

^WHCHRN:JUMPE TT,CPOPJ1
	EXCH T,TT
	JUMPE TT,CPOPJ1
	CAMN T,TT
	JRST CPOPJ1
	PUSH P,TTT
	IDIVI TT,=100		;SEPERATE NUMBER PART FROM BIT PART
	MOVEM TT,1(P)		;SAVE BIT PART
	IDIVI T,=100		;SEPERATE OTHER ONE
	IOR T,1(P)		;OR BITWISE STUFF TOGETHER
	IMULI T,=100		;PREPARE TO ADD NUMBER PART BACK
	JUMPE TTT,WHRNOK	;IF EITHER NUMBER PART 0, THEN OK
	EXCH TT,TTT
	JUMPE TTT,WHRNOK
	CAMN TT,TTT		;NUMBER PARTS THE SAME?
	JRST WHRNOK		;YES, THEN ON ERROR MESS
	CAMG TT,TTT		;USE LARGER OF NUMBER PARTS
	EXCH TT,TTT
	ADD T,TT
	HRL T,(P)		;SAVE OLD TTT IN T
	MOVEM T,(P)		;THEN BOTH ON STACK
	PUTSTR[ASCIZ/MULTIPLE WIRE RULE NUMBERS /]
	PUSH P,TT
	MOVE T,TTT
	PUSHJ P,DECOUT
	PUTSTR[ASCIZ/ AND /]
	POP P,T
	PUSHJ P,DECOUT
	PUTSTR[ASCIZ/
/]
	POP P,T
	HLRZ TTT,T
	POPJ P,

WHRNOK:	ADD T,TT
	POP P,TTT
	JRST CPOPJ1

;LETTER/CODE CONVERION TABLES FOR QUALIFIER LETTERS
;WHEN THESE TABLES ARE CHANGED, BACVER MUST BE INCREMENTED.
;ALSO IF MORE THAN 37 (OCTAL) CHARS ARE IMPLEMENTED, QBITS MUST BE INCREASED
^QL2N:
FOR I_0,"+"-1
<	0
>
	"Z"-"A"+1+1		;USE CODE AFTER Z FOR +
FOR I_"+"+1,"A"-1
<	0
>
FOR I_"A","Z"
<	I-"A"+1
>
FOR I_"Z"+1,"A"+40-1
<	0
>
FOR I_"A"+40,"Z"+40
<	I-40-"A"+1
>
FOR I_"Z"+40+1,177
<	0
>
IFN .-QL2N-200,<PRINTS /QL2N TABLE SCREWED UP.
/>

^QN2L:	"?"
FOR I_"A","Z"
<	I
>
	"+"
REPEAT 40+QN2L-.,<	"?"	>
MWL,<
IFN QBITS-37,<PRINTS/QBITS NOT EQUAL TO 37
/>
>;MWL
;SIGONE, PUTIT, EPUTIT, AND SPTAB
SIGONE:	PUSHJ P,SIGGET
	MOVEM TTT,SIGCHR
	JUMPE TTT,CPOPJ
	CAIE TTT,11
	CAIN TTT,""
	MOVEI TTT,40
	JRST CPOPJ1

PUTIT:	CAMN B,[POINT 7,PERMTB+MXSTLN-1,27]
	JRST [	PUTSTR[ASCIZ/EXPANDED STRING TOO LONG, TRUNCATED TO:
/]
		HRLZ TTT,TTT
		IDPB TTT,B
		TLZ B,7700
		HLRZ TTT,TTT
		PUTSTR PERMTB
		PUTSTR[ASCIZ/
/]
		POPJ P,]
	CAIL TTT,"a"
	CAILE TTT,"z"
	CAIA
	SUBI TTT,40			;CONVERT LOWER CASE TO UPPER CASE
	IDPB TTT,B
	POPJ P,

MDPC,<
EPUTIT:	EXCH TTT,ESGPTR
	CAMN TTT,[POINT 7,ESGTAB+ESGTLN-1,34]
	JRST [	EXCH TTT,ESGPTR
		PUTSTR[ASCIZ/EXTRACTED STRING TOO LONG, TRUNCATED TO:
/]
		HRLZ TTT,TTT
		IDPB TTT,ESGPTR
		HLRZ TTT,TTT
		EXCH TTT,ESGPTR
		TLZ TTT,7700
		EXCH TTT,ESGPTR
		PUTSTR ESGTAB
		PUTSTR[ASCIZ/
/]
		POPJ P,]
	EXCH TTT,ESGPTR
	IDPB TTT,ESGPTR
	POPJ P,
>;MDPC

SPTAB:	SGND!SCANON,,[ASCIZ/GND/]
	SNC,,[ASCIZ/NC/]
DEC,<	SHI,,[ASCIZ/+3/]	>
NODEC,<
	SPWR,,[ASCIZ/VCC/]
	SHI,,[ASCIZ/HI/]
	SHI,,[ASCIZ/HIGH/]
>;NODEC
SPLEN__.-SPTAB
SUBTTL	ALPHA
;COMPARE ASCIZ SIGNAL NAMES T,TT
;RETURNS:
;	T .LT. TT
;	T .GT. TT
;	Equivalent, but T .LT. TT
;	Equivalent, but T .GT. TT
;	Exactly equal

; Skips over leading NOTCHR, flags as NFLAG1 (T), NFLAG2 (TT)

^ALPHA:	MOVEM SFLAG,FLGSAV
	SETZ SFLAG,			;INITIALIZE FLAGS
	MOVE TTT,(T)			;COMPARE WORD
	CAME TTT,(TT)			;EQUAL?
	 JRST [	LSH TTT,-1		;NO, THIS IS EASY
		MOVE TT,(TT)
		LSH TT,-1
		CAML TTT,TT
		 JRST FLAGJ1		;UNEQUAL TT LESS THAN T
		JRST FLAGJ]		;UNEQUAL T LESS THAN TT
	ADD T,[POINT 7,1,6]
	ADD TT,[POINT 7,1,6]
	MOVEM T,TPTRP
	MOVEM TT,TTPTRP
	LDB T,TPTRP
	LDB TT,TTPTRP
	TLO SFLAG,NFLAG1!NFLAG2			;ASSUME BOTH NOT'S
	CAIE T,NOTCHR
	 TLZA SFLAG,NFLAG1
	  ILDB T,TPTRP
	CAIE TT,NOTCHR
	 TLZA SFLAG,NFLAG2
	  ILDB TT,TTPTRP
	JRST BEGCOM			;GO CHECK FOR SPACES FIRST

ALPHA2:	CAIN T,";"			;CONVERT THESE
	 SETZ T,			;TO END OF STRING SO WE WILL GET TO OTHER LOOP
	CAIN TT,";"
	 SETZ TT,
	CAME T,TT
	 JRST ALPHAN
	JUMPE T,CHKEND
	ILDB TT,TTPTRP
	ILDB T,TPTRP
BEGCOM:	CAIN T," "		;STRIP LEADING SPACES FROM T, IF NOT SIGNIFICANT
MWL,<	TRNE PETIT	>
MDPC,<	TRNE M,SPACES	>
	 JRST SKIPM1
	ILDB T,TPTRP
	JRST BEGCOM

SKIPM1:	CAIN TT," "		;STRIP LEADING SPACES FROM TT, IF NOT SIGNIFICANT
MWL,<	TRNE PETIT	>
MDPC,<	TRNE M,SPACES	>
	 JRST SKIPM2		;GO LOOK FOR BS
	ILDB TT,TTPTRP
	JRST SKIPM1

;CHECK FOR BS \...\
SKIPM2:	EXCH T,TT
	MOVEI TTT,TPTRP
	CAIN TT,"\"
	PUSHJ P,SKIPBS		;LOOK FOR BS \...\ IN T
	 JRST SKIPM4
	JRST SKIPM3

SKIPM4:	EXCH T,TT
	MOVEI TTT,TTPTRP
	CAIN TT,"\"
	PUSHJ P,SKIPBS
	 JRST ALPHS1		;CHECK FOR 0,1 H,L
	TRO SFLAG,BSSEEN	;FLAG BS ERR DIFF, SEEN ON TT, NOT T
	JRST BEGCOM		;(IF FIRST TIME, TBSGTR WILL BE OFF)

; First string had BS \...\ construct
SKIPM3:	MOVE TTT,WQNTMP		;SAVE THIS
	MOVEM TTT,WQNTM1
	EXCH T,TT
	MOVEI TTT,TTPTRP
	CAIN TT,"\"
	PUSHJ P,SKIPBS
	JRST [	TRNE SFLAG,BSSEEN	;SEEN BS DIF ALREADY?
		 JRST BEGCOM
		JRST SKIPM5]	;NO, NO BS SET TBSGTR
	MOVE TTT,WQNTMP		;GET TT BS
	TRNN SFLAG,BSSEEN	;SEEN BS DIF ALREADY?
	CAMN TTT,WQNTM1		;NO, DIFFERENT?
	JRST BEGCOM		;NO, GO CHECK SPACES AGAIN
	CAMG TTT,WQNTM1		;COMPARE TO T BS
SKIPM5:	TRO SFLAG,TBSGTR	;T BS .GT. TT BS
	TRO SFLAG,BSSEEN	;FLAG DIFFERENCE SEEN
	JRST BEGCOM		;GO CHECK SPACES AGAIN

;Check for (0,1) or H,L equivalences.

ALPHS1:
NOPOL,<	JRST ALPHA2  >
POL,<	MOVEI TTT,TPTRP
	CAIN T,11
	 PUSHJ P,ALPHL		;Assertion, polarity?
	 CAIA
	  TLC SFLAG,NFLAG1	;Yes, and changes signal
	EXCH T,TT
	MOVEI TTT,TTPTRP
	CAIN T,11
	 PUSHJ P,ALPHL
	 CAIA
	  TLC SFLAG,NFLAG2
	EXCH T,TT
	JRST ALPHA2

;Check for <tab> 0,1 H,L - SKIP IF PRESENT AND CHANGES POLARITY
ALPHL:	TLZ SFLAG,POLFLG
	HRLM T,(P)		;SAVE ORIG CHAR (TAB ALWAYS?)
	PUSH P,(TTT)		;SAVE ORIGINAL POINTER
	PUSHJ P,ALPHSP		;GET NON-SPACE
	CAIN T,"0"
	 TLOA SFLAG,POLFLG
	CAIN T,"1"
	 PUSHJ P,ALPHSP
	CAIN T,"L"
	 TLCA SFLAG,POLFLG
	CAIN T,"H"
	 JRST [	SUB P,[1,,1]
		TLNE SFLAG,POLFLG	;INVERTS SENSE?
		 AOS (P)		; YES
		JRST ALPHSP]
	POP P,(TTT)		;NOT REALLY H,L ETC., RESTORE POINTER
	HLRZ T,(P)		;RESTORE CHAR
	POPJ P,

ALPHSP:	LDB T,(TTT)
	JUMPE T,CPOPJ
	ILDB T,(TTT)
	CAIN T,40
	 JRST ALPHSP
	POPJ P,
>;POL
;END OF STRINGS, CHECK
CHKEND:	TLNN SFLAG,NFLAG1
	 JRST CHKEN1
	TLNN SFLAG,NFLAG2
	 JRST FLAGJ1		;TT LESS THAN T
	JRST CHKEN2

CHKEN1:	TLNE SFLAG,NFLAG2
	 JRST FLAGJ		;T LESS THAN TT
CHKEN2:	MOVEI T,2		;AT LEAST EQUIVALENT
	ADDM T,(P)
	TRNE SFLAG,BSSEEN	;DIFFERNCE IN BS?
	 JRST [	TRNE SFLAG,TBSGTR	;T BS GREATER THAN TT BS?
		 JRST FLAGJ1		;YES, SKIP
		JRST FLAGJ]		;NO, NO SKIP
	LDB T,TPTRP
	LDB TT,TTPTRP		;GET REAL CHARS BACK
SEMCHK:	CAME T,TT
	 JRST ALPHAN
	JUMPE T,FLAGJ2		;EXACTLY EQUAL
	ILDB T,TPTRP
	CAIN T," "
	 JRST .-2		;ALWAYS IGNORE SPACES IN COMMENTS
	ILDB TT,TTPTRP
	CAIN TT," "
	 JRST .-2
	JRST SEMCHK

FLAGJ2:	AOSA (P)
ALPHAN:	CAML T,TT
FLAGJ1:	AOS (P)
FLAGJ:	MOVE SFLAG,FLGSAV
	POPJ P,

;SKIPBS - SKIP BS CONSTRUCT
; TTT points to byte pointer within string after "\"
; looks for	"\X\"		single letter
;		"\#123\"	number
;		"\X#123\"	letter, number
; returns in WQNTMP	letter-code,,number
; skips if found legal construct
; if fails, resets byte pointer

SKIPBS:	SETZM WQNTMP
	PUSH P,(TTT)			;SAVE BYTE POINTER
	ILDB TT,(TTT)
	CAIN TT,"#"			;NUMBER ONLY?
	JRST SKPBS3
	SKIPN TT,QL2N(TT)		;LEGAL LETTER?
	JRST SKPBSE			;NO
	HRLM TT,WQNTMP			;STORE HERE FOR COMPARE
	ILDB TT,(TTT)			;YES, NEXT CHAR
	CAIE TT,"#"			;NOW NUMBER?
	JRST SKPBS4
SKPBS3:	PUSH P,T
	SETZ T,
SKPBS6:	ILDB TT,(TTT)
	CAIL TT,"0"
	CAILE TT,"9"
	JRST SKPBS5
	IMULI T,=10
	ADDI T,-"0"(TT)
	CAIG T,777777
	JRST SKPBS6
	POP P,T
SKPBSE:	POP P,(TTT)
	LDB TT,(TTT)
	POPJ P,

SKPBS5:	HRRM T,WQNTMP
	POP P,T			;LEGAL NUMBER
SKPBS4:	CAIE TT,"\"		;END WITH \ ?
	JRST SKPBSE		;NO
	ILDB TT,(TTT)		;GET FOLLOWING CHAR
	POP P,(P)		;LOSE SAVED POINTER
	JRST CPOPJ1		;NON-SKIP RETURN TO INDICATE BS CONSTRUCT

BEND SIGSUB
