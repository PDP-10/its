TITLE PLTSCN
;CONVERT PLT FILES TO XGP SCAN FILES.

.MLLIT==1

GOULDP==0		;ASSEMBLY SWITCH FOR THE GOULD 5200 PRINTER

DEFINE CONC A,B
A!B!TERMIN

ZR==0
A=1
B=2
C=3
D=4
X1=5
Y1=6
X2=7
Y2=10
DX=11
DY=12
T=13			;GETS CLOBBERED BY IDIVI DY,
TT=14
W=15

P=17

INCH==1			;INPUT CHNL
OUTCH==2		;OUTPUT CHNL
FNTICH==3		;FONT INPUT CHNL

;PLOT FILE FORMAT AND VERSION NUMBERS

%VERL==13			;LOWEST VERSION KNOW ABOUT

%VERH==15			;HIGHEST IO VERSION THIS KNOW ABOUT


IFN 0,[
'PLT'	'PCP'	FILE FORMAT

LOW ORDER BIT OFF ALWAYS STARTS NEW COMMAND!

VERSION#			;PLTVER=15
LINES:
--------
!	XWD X*2,Y*2	LOW ORDER BIT OF LEFT HALF OFF MEANS
!	XWD X*2,Y*2+1	THIS COMMAND IS A BUNCH OF POINTS
!	XWD X*2,Y*2+1	JOINED BY VECTORS. ENDS WITH START OF
!	      .		NEW COMMAND (LOW ORDER BIT OFF AGAIN)
!	      .
!	      .
!	XWD X*2,Y*2+1
--------

TEXT:
--------
!	XWD X*2+1,Y*2		ONE IN LEFT HALF MEANS TEXT
!	XWD 0,ROTATION+SIZE*2+1	ZERO IN LH MEANS TEXT, NOT DIAMOND OR DRILL HOLE
!	ASCII/5 CHARS OF TEXT/+1
--------

;PLTVER(15) SIZE IS WIDTH OF CHAR ON PTS
;ROTATION = 0		NORMAL UPRIGHT CHARS
;ROTATION = 400000	ROTATED 90 DEGREES CCW

SMALL DIAMOND TO INDICATE JUNCTION OF 3 OR 4 LINES (PLT)
	OR
DRILL HOLE (PCP):
--------
!	XWD X*2+1,Y*2
!	XWD 2,1		2 IN LEFT HALF MEANS DIAMOND (OR DRILL HOLE)
--------

MPC,<
--------
!	XWD X*2+1,Y*2
!	XWD 4,<PAD TYPE>*2+1
--------
THE PLOT PROGRAM KNOWS ABOUT THE VARIOUS PAD TYPES
>;MPC

******** THE PRECEEDING FORMATS MAY BE MIXED IN ANY ORDER UNTIL
	A WORD WITH LEFT HALF = 400001 IS SEEN. THEN THE
	FILE ENDS WITH THE FOLLOWING:

MPC,<	400001,,0	+400000 IF FRONT SIDE
			+200000	IF INNER PLANE
	BITS		BIT 35 = FLIPPED PLOT

	CARD FILENAME:	--------!
		CRDNAM		!
		CRDEXT		!---- OR 0 IF NONE
		CRDPPN		!
			--------!
>;MPC
MD,<	400001,,<BOX SIZE>*2	0=NONE
				1=A
				2=B  ETC.

	ASCIZ/STRING TO GO IN BOX MARKED "DRAWN BY"/

	ASCIZ/FIRST LINE TO GO IN TITLE BOX/

	ASCIZ/SECOND LINE TO GO IN TITLE BOX/
	'DRW'	FILE DATE AND TIME LAST WRITTEN
	'DRW'	FILE NAME
	'DRW'	FILE EXTENSION,,0
	'DRW'	FILE PPN
	CARD LOCATION

	ASCIZ/REVISION STRING/

	ASCIZ/drawing number STRING/	;MODULE-VARIABLE-PREFIX

	ASCIZ/PROJECT STRING/

	ASCIZ/PAGE STRING/

	ASCIZ/OF STRING/

	ASCIZ/DCODE STRING/

	ASCIZ/SITE LINE 1 STRING/

	ASCIZ/SITE LINE 2 STRING/

DEC,<

	ASCIZ/NEXT HIGHER ASSEMBLY NUMBER STRING/

	0	OR	DRNNAM
			DRNEXT,,DRNDAT
			DRNPPN

	0	OR	CHKNAM
			CHKEXT,,CHKDAT
			CHKPPN

	0	OR	ENGNAM
			ENGEXT,,ENGDAT
			ENGPPN

>;DEC
>;MD
];IFN 0
;RASTER DEFINITIONS

RASGRP==100.		;RASTER LINES IN A RASTER GROUP.  IE 
			;LENGTH OF RASTAB = 
			;	<TOTAL VERTICAL RASTER LINES IN PAGE> / RASGRP
IFE GOULDP,[
PAGLIN==110.		;PAGE LENGTH IN TENTHS OF AN INCH
PAGWID==85.		;PAGE WIDTH IN TENTHS OF AN INCH
]
.ELSE [
PAGLIN==150.
PAGWID==110.
]
PAGRES==200.		;RESOLUTION IN POINTS PER INCH
LRASTB==<PAGLIN*PAGRES/10.>/RASGRP

DEFINE BBX X,Y,OP
	<<<X>*PAGRES/100.>&77777>_25+<<<Y>*PAGRES/100.>&77777>_6+OP
TERMIN

IFE GOULDP,[
XGPLAB==30.		;LABELING BOX HEIGHT IN HUNDREDTHS OF AN INCH
BXTXOF==11.		;LABELLING TEXT OFFSET (HUNDREDTHS)
BXLLX==15.		;BOX LOWER LEFT X COORD IN HUNDREDTHS OF AN INCH
BXLLY==10.		;BOX LOWER LEFT Y COORD
BXURX==820.		;BOX UPPER RIGHT X COORD
BXURY==1055.		;BOX UPPER RIGHT Y COORD
BFNLN==200.		;LENGTH OF FILE NAME BOX
BDALN==200.		;LENGTH OF DATE BOX
]
.ELSE [
XGPLAB==40.		;LABELING BOX HEIGHT IN HUNDREDTHS OF AN INCH
BXTXOF==0		;LABELLING TEXT OFFSET
BXLLX==20.		;BOX LOWER LEFT X COORD IN HUNDREDTHS OF AN INCH
BXLLY==	50.		;BOX LOWER LEFT Y COORD
BXURX==1000.		;BOX UPPER RIGHT X COORD
BXURY==1450.		;BOX UPPER RIGHT Y COORD
BFNLN==265.		;LENGTH OF FILE NAME BOX
BDALN==265.		;LENGTH OF DATE BOX
]
BDTLN==<BXURY-BXLLY>-BFNLN-BDALN	;LENGTH OF BOX FOR TITLES 1 AND 2

IFE GOULDP,[
LSCNBF==55.		;ENUF FOR ONE XGP RASTER LINE
BYTMAX==52.*4		;MAX ALLOWABLE BYTES IN DATA OUTPUT
]
.ELSE [
LSCNBF==65.
BYTMAX==65.*4
]
FSL==100000
INBFSZ==100		;SIZE OF INPUT BUFFER
LPDL==100
RDFBFL==100		;LENGTH OF READ FONT BUFFER
LASCZB==40		;SIZE OF ASCIZ STRING BUFFER (FOR BOX TITLES, ETC)

;THIS PROGRAM BASICALLY KNOWS ABOUT TWO SORTS OF THINGS, CHARACTER STRINGS
; AND VECTORS.  THE PROGRAM OPERATES BY READING THE ENTIRE PLT FILE INTO
; CORE, IN THE PROCESS ENTERING EACH STRING OR VECTOR IN THE APPROPRIATE
; PLACE IN THE RASTAB WHICH IS ORDERED BY SCAN LINE GROUP.  IT THEN ENTERS THE
; OUTPUT PHASE, MUNGING OVER THE RASTAB AND WRITING THE PLT FILE.  TO GENERATE
; EACH OUTPUT SCAN LINE, THE PROGRAM MUST GRUBBLE DOWN THE ENTIRE LIST
; STORED IN THE RASTAB OF WHICH THE GIVEN OUTPUT LINE IS A MEMBER.  AS WELL
; AS INTERSECTING THIS SCAN LINE WITH EACH ELEMENT OF THAT LIST, IF THIS
; SCAN LINE IS THE LAST ONE OF ITS RASTER GROUP AND IF THE ELEMENT IS ALSO
; GOING TO NEED TO BE DISPLAYED ON THE NEXT SCAN LINE, THE OUTPUT PROGRAM
; MUST DETACH IT FROM THIS RASTAB LIST AND ADD IT TO THE NEXT ONE.

;RASTAB FORMATS:
; HORIZONAL LINES IN THE PAGE IMAGE ARE DIVIDED INTO "GROUPS" WITH
; <RASGRP> NUMBER OF CONSECUTIVE LINES PER GROUP.
; EACH GROUP HAS A ONE WORD ENTRY IN THE RASTAB WHICH POINTS  TO A LINKED
; LIST OF ALL ITEMS STARTING IN THAT GROUP OF LINES.  THIS LINKED LIST
; IS TERMINATED BY A 0 LINK.  ELEMENTS OF THE LIST CAN BE EITHER CHARACTERS
; STRINGS OR VECTORS.
; WD0 4.9-4.4-> OBJECT TYPE
;		;0 ERR
  %EVEC==10000	;1 VECTOR,
  %ECHAR==20000	;2 CHARACTER STRING,
  %EDIA==30000	;3 DIAMOND,
  %EHVEC==40000	;4 HORIZONAL VECTOR (DELTA Y = 0)
  %EVVEC==50000	;5 VERTICAL VECTOR (DELTA X = 0)
 MXITEM==6	; ITEM FIELD HAD BETTER BE LESS THAN THIS

;     4.3 - 3.1 AVAIABLE FOR CHARACTER FONT, ROTATION, ETC. NOT USED NOW.
;     RH -- LINK OUT
; IF VECTOR:
;  WD1:  Y1,,<LOW ORDER BITS>
;  WD2:  X1,,<LOW ORDER BITS>
;  WD3:  DY (PER STEP) * 2**18 (MUST BE POSITIVE)
;  WD4:  DX (PER STEP) * 2**18 (MAY BE POSITIVE OR NEGATIVE)
;  WD5:  NUMBER OF STEPS LEFT

; IF HORIZONAL VECTOR:
;  WD1: X,,Y	(OF LEFT HAND POINT)
;  WD2: DELTA X (MUST BE POSITIVE)

; IF VERTICAL VECTOR:
;  WD1: X,,Y	(OF TOP POINT)
;  WD2: DELTA Y (MUST BE POSITIVE)

; IF CHARACTER STRING: NOTE: A CHARACTER STRING MUST BE PRINTED ENTIRELY
;	ON THE SAME HORIZONAL LINE AND MUST BE ALL IN THE SAME FONT.
;	IF THE CHARACTER IS "ROTATED 90 DEGREES CCW", THE CHARACTER
;	STRING MUST BE EXACTLY ONE CHARACTER LONG.  "SOMEBODY" MUST
;	SPLIT UP INPUT CHARACTER STRING TO CONFORM TO THESE RESTRICTIONS
;	IF IT DOESNT ALREADY.
;  WD1:  X,,Y
;  WD2:  FONT NUMBER (RH)
;  WD3-N:  ASCII STRING TERMINATED BY 0 CHARACTER

; IF DIAMOND:
;  WD1: X,,Y

;INTERNAL COORDINATES:
;   Y COORDINATE IS SCAN LINE NUMBER, 0 FOR TOP OF PAGE, ETC
;   X COORDINATE IS BIT NUMBER IN SCAN LINE, 0 AT LEFT EDGE OF PAGE.
; THESE X ES AND Y ES ARE SWAPPED FROM THOSE REFER ED TO IN THE PLT
;  FILE SINCE THE LONG AXIS OF THE PAGE RUNS VERTICALLY ON THE XGP
;  BUT IS THE X AXIS IN THE PLT FILE
;   ALSO, SINCE THE DRAWING SYSTEM USES 0,0 AS THE CENTER OF THE PICTURE,
;  APPROPRIATE OFFSETS MUST BE APPLIED.  
	YCOFF==10200.	;   ORIGINAL X DIRECTION (Y AFTER SWAPPING)
	XCOFF==870.	;   ORIGINAL Y DIRECTION (X AFTER SWAPPING)
	ISCALE==.25_35.	;   INITIAL SCALE 4 TO 1

;FONT STORAGE
NFONTS==5		;NUMBER FONTS
;  FNTPTR IS A TABLE INDEX OF FONT NUMBER WHICH POINTS AT N TH FONT TABLE.
; IF FNTPTR IS 0, FONT IS NOT LOADED.  OTHERWISE LH CONTAINS FONT INFO
; AND RH POINTS TO BASE OF CHARACTER TABLE FOR FONT.
;  EA CHARACTER TABLE ENTRY IS 0 IF CHAR UNDEFINED IN FONT.
;  IF NON-ZERO, THE RH POINTS AT THE CHAR BIT RASTER AND THE LH CONTAIN
;  INFO ABOUT THE CHARACTER.  THE BIT RASTER IS STORED "PDP-10" STYLE
;  36 BITS PER WORD.  HOWEVER, IT IS STORED ROTATED 90 CCW TO THE
;  USUAL ORIENTATION.  THIS IS DONE BECAUSE MOST NORMAL TEXT IN DRAWINGS
;  WINDS UP COMING OUT VERTICALLY ON THE XGP SINCE THE X AND Y AXES ARE SWAPPED.
;  THUS ONLY ONE WORD VECTOR WILL BE REQUIRED PER UNIT OF CHARACTER WIDTH 
;  UNLESS THE FONT IS MORE THAN 36 HIGH (IN WHICH CASE 2 UP TO 72 WIDE, ETC).
;  THERE ARE AS MANY OF THESE ENTIRES AS THE CHARACTER IN QUESTION IS WIDE
;  ALSO, SINCE X RASTER ADDRESSES ASCEND TO THE RIGHT, THE BITS MUST BE
;  INVERTED WORDWISE.  IE THE HIGH ORDER BIT OF THE FIRST WORD IS THE LOWER
;  LEFT BIT OF THE CHARACTER RASTER, ETC

; NOW FOR THE DETAILS:
; PER FONT:
;  FONTHT(FONT)  HAS FONT HEIGHT IN RASTER UNITS
;  FONTHW(FONT)  HAS FONT NUMBER OF WORDS PER UNIT WIDTH (IE <FONTHT+35./36.>.
;  FONTBS(FONT)  HAS FONT BASE LINE
;  FONTMW(FONT)  HAS MAX WIDTH OF ANY CHAR IN FONT
; PER CHARACTER:
  %CHWD==360600	 ; CHARACTER WIDTH
  %CHRWD==300600 ; RASTER WIDTH
  %CHRLC==220600 ; LEFT KERN (A 2 S COMP NUMBER)

;INTERNAL DISPLAY LIST FORMAT:
;  INTERNAL DISPLAY LISTS ARE USED AS A CONVIENT METHOD OF REPRESENTING
;SETS OF VECTORS AND/OR CHARACTERS FOR "INTERNAL PURPOSES" (FOR NOW).
;(FOR EXAMPLE, DRAWING THE "BOX", ETC).  THE FORMAT HAS SOME SIMILARITY
;TO VARIOUS DISPLAY PROCESSORS, VARIOUS SUBPARTS OF DPLT FILES, ETC.
;  EACH 36 BIT WORD REPRESENTS AN "INSTRUCTION".
;	IF THE LOW ORDER BIT IS OFF, THE HIGH 35 BITS ARE 5 ASCII CHARACTERS.
;	OTHERWISE THE HIGH 1.4-1.6 ARE AN "OP CODE". (1.2 AND 1.3 ARE 
;		"MODIFIER BITS", NOT IMMEDIATELY DECODED.)
;	IF A PARTICULAR INSTRUCTION SPECIFIES AN X AND Y COORDINATE,
;		THESE ARE 15 BITS EACH AND STORED X IN 4.9-3.4 AND Y IN 3.3-1.7
;	IF A PARTICULAR INSTRUCTION SPECIFIES AN ADDRESS,
;		 THIS IS FOUND IN THE LEFT HALF.

;THE FOLLOWING OP CODES ARE DEFINED SO AS TO ADD DIRECTLY IN WITHOUT SHIFTING
;THEY INCLUDE THE LOW BIT SET TO "AVOID" CHARACTER MODE.
DHALT==01	;OP CODE 0 IS OPERATE, ALL ZERO IS HALT
DFNTSL==03	; FONT SELECT (FONT NUMBER IN LH)
VEC== 11	;VISIBLE VECTOR FROM "CURRENT POINT" TO CURRENT POINT +DX,DY
IVEC==15	;"INVISIBLE" VECTOR (SETS CURRENT POINT)
AVEC==21	;ABSOLUE VISIBLE VECTOR (FROM CURRENT POINT TO X,Y)
AIVEC==25	;"INVISIBLE" ABSOLUTE VECTOR
MXVOP==2	;HIGHEST OP USED

GO:	MOVE P,[-LPDL,,PDL-1]
	.OPEN INCH,INO
	JRST [	.VALUE [ASCIZ /: NO PLT FILES 
/]
		JRST GO]
	MOVEI A,FS
	MOVEM A,FSP		;FREE STORAGE POINTER.
	MOVE A,FONTN
	PUSHJ P,RDFONT		;READ DRAWING FONT
	MOVE A,LAFONT
	CAME A,FONTN
	PUSHJ P,RDFONT		;READ LABELLING FONT
	MOVE A,FSP
	MOVEM A,SFSP
	MOVE A,[FNTPTR,,SFNTP]
	BLT A,SFNTP+NFONTS-1
RCYCLE:	CLEARM IDCX
	CLEARM IDCY
	CLEARM ITMLST
	CLEARM RASTAB
	MOVE A,[RASTAB,,RASTAB+1]
	BLT A,RASTAB+LRASTB-1	;CLEAR OUT RASTER TABLE
	MOVEI A,INBUF+INBFSZ
	MOVEM A,INBUFP
	MOVSI A,200000
	MOVEM A,MINYC		;OBTAIN MIN AND MAX X AND Y IN ENTIRE PICTURE
	MOVEM A,MINXC		;SO AS TO BE ABLE TO CENTER IT.
	MOVNM A,MAXYC
	MOVNM A,MAXXC
	PUSHJ P,INWD		;READ IO VERSION #
	MOVEM A,PLTVER
	CAIL A,%VERL
	 CAILE A,%VERH
	  .VALUE [ASCIZ/: IO VERSION WRONG, $P TO TRY TO WIN ANYWAY î/]
CMDL:	PUSHJ P,INWD		;RETN WD IN A
CMDL1:	TRNE A,1
	 .VALUE			;LOW BIT SHOULD BE OFF FOR START OF COMMAND
	HLRZ B,A
	CAIN B,400001
	JRST INFN		;READ TRAILING STUFF OF FILE
	TLNN A,1
	JRST PNTLST		;READ LIST OF POINTS
	JRST CHARS		;GOBBLE TEXT BLOCK (OR MAYBE DIAMOND ...)


CAXY1U:	HRRE X1,A		;SWAPPED  LEAVE RESULT IN X1,Y1
	ASH X1,-1		;FLUSH BIT USED FOR COMMAND DECODE
	MUL X1,SCALE
	ADDI X1,XCOFF		;OFFSET SINCE DRAWING PRGM 0 0 IS AT CENTER
	HLRE Y1,A
	ASH Y1,-1
	MUL Y1,SCALE		;CLOBBERS X2
	ADDI Y1,YCOFF
	POPJ P,

CAXY1:	PUSHJ P,CAXY1U
MXMNU1:	CAMLE X1,MAXXC		;SAVE IF THIS MIN OR MAX COORD EVER SEEN
	MOVEM X1,MAXXC
	CAMGE X1,MINXC
	MOVEM X1,MINXC
	CAMLE Y1,MAXYC
	MOVEM Y1,MAXYC
	CAMGE Y1,MINYC
	MOVEM Y1,MINYC
	POPJ P,

CAXY2:	HRRE X2,A		;LEAVE RESULT IN X2,Y2
	ASH X2,-1
	MUL X2,SCALE
	ADDI X2,XCOFF
	HLRE Y2,A
	ASH Y2,-1
	MUL Y2,SCALE		;CLOBBERS DX
	ADDI Y2,YCOFF
	CAMLE X2,MAXXC
	MOVEM X2,MAXXC
	CAMGE X2,MINXC
	MOVEM X2,MINXC
	CAMLE Y2,MAXYC
	MOVEM Y2,MAXYC
	CAMGE Y2,MINYC
	MOVEM Y2,MINYC
	POPJ P,

PNTLST:	PUSHJ P,CAXY1U		;CONVERT DRAWING PROG COORDINATES IN A AND 
	PUSHJ P,INWD		;LEAVE THEM IN X1 AND Y1
	TRNN A,1
	JRST CMDL1		;THAT REALLY STARTED "NEW COMMAND"
	PUSHJ P,MXMNU1		;REALLY GOING TO USE THEM, SO UPDATE MAX, MIN
	PUSHJ P,CAXY2		;CONVERT COORDS IN A AND LEAVE THEM IN X2,Y2
	PUSHJ P,VECTAD		;INSERT VECTOR FROM X1,Y1 TO X2,Y2 INTO ITMLST
	JRST PNTLST

VECTAD:	CAMLE Y1,Y2		;ASSURE Y1 LESS OR EQUAL TO Y2
	EXCH X1,X2
	CAMLE Y1,Y2
	EXCH Y1,Y2
	MOVE DY,Y2
	SUB DY,Y1		;MUST BE POSITIVE
	MOVE DX,X2
	SUB DX,X1		;CAN BE POSITIVE OR NEGATIVE
	MOVE C,FSP
	HRRZ D,ITMLST
	JUMPE DX,SVVEC		;STORE VERTICAL VECTOR
	JUMPE DY,SHVEC		;STORE HORIZONAL VECTOR
	TLO D,%EVEC
	MOVEM D,(C)
	HRRZM C,ITMLST

	HRLZM Y1,1(C)
	HRLZM X1,2(C)

	MOVM B,DX
	CAMGE B,DY
	MOVE B,DY
	MOVEM B,5(C)		;GREATER DY OR <MAG DX> = NUMBER STEPS
	AOS 5(C)		;TAKE ONE EXTRA STEP TO HIT BOTH ENDPOINTS
	ASH DY,18.
	ASH DX,18.
	IDIV DY,B
	ADDI DY,400		;MAKE SURE DONT LOSE DUE TO TRUNCATION
	MOVEM DY,3(C)
	IDIV DX,B
	ADDI DX,400
	MOVEM DX,4(C)

	ADDI C,6
SVVECX:
SHVECX:	MOVEM C,FSP
	CAIL C,FS+FSL
	.VALUE
CPOPJ:	POPJ P,			;LOOP AROUND FOR NEXT VECTOR, REPROCESSING
				;FIRST POINT WHICH IS STILL IN A
CHARS:	PUSHJ P,CAXY1
	PUSHJ P,INWD
	MOVE C,FSP
	HRRZ D,ITMLST
	HLRZ ZR,A
	JUMPE ZR,CHARS1		;REAL CHAR STRING
	CAIN ZR,2
	JRST DIAM		;CONNECTION DIAMOND
	.VALUE			;FORMAT ERROR

SVVEC:	JUMPE DY,CPOPJ		;0 LENGTH VECTOR, FLUSH
	TLO D,%EVVEC
	MOVEM D,(C)
	HRRZM C,ITMLST
	HRLM X1,1(C)
	HRRM Y1,1(C)
	AOS DY			;EXTRA STEP TO HIT BOTH ENDPOINTS
	MOVEM DY,2(C)
	ADDI C,3
	JRST SVVECX

SHVEC:	TLO D,%EHVEC
	MOVEM D,(C)
	HRRZM C,ITMLST
	JUMPGE DX,SHVEC1
	MOVE X1,X2
	MOVNS DX
SHVEC1:	HRLM X1,1(C)
	HRRM Y1,1(C)
	AOS DX			;EXTRA STEP TO HIT BOTH ENDPOINTS
	MOVEM DX,2(C)
	ADDI C,3
	JRST SHVECX

;CHAR WIDTH IN A, FIND FONT #, RETURN IN X2
INTERP:	MOVE X2,A
	ANDI X2,377777		;FLUSH VERT BIT
	LSH X2,-1		;GET CHAR WIDTH WANTED (IS *8)
	PUSH P,B
	PUSH P,C
	PUSH P,D
	MOVSI D,-NFONTS
	MOVSI C,377777
INTERL:	HRRZ B,FONTOP(D)
	HRRZ B,-1(B)		;CLAIMED RASTER WIDTH FOR THIS FONT
	LSH B,3			;CHAR SCALE IS REPRESENTED *8
	SUBI B,(X2)
	MOVMS B
	CAMGE B,C		;BEST SO FAR?
	 JRST [	MOVE C,B
		HRL X2,D	;FONT #
		JRST .+1]
	AOBJN D,INTERL
	HLRZS X2
	POP P,D
	POP P,C
	POP P,B
	JRST INTERD

CHARS1:	MOVE X2,PLTVER
	CAIL X2,15		;VERSION WITH NEW CHAR STUFF
	 JRST INTERP		;INTERPOLATE CHAR WIDTH TO SELECT FONT
	MOVE X2,A
	LSH X2,-4
	SOS X2			;THIS SEEMS TO GIVE CHRS ABOUT RIGHT SIZE..
	ANDI X2,3
INTERD:	SKIPN FNTPTR(X2)
	 JRST 	[	MOVEM 16,ACSAV+16	;FONT NOT IN READ IN FONT NOW
			MOVEI 16,ACSAV
			BLT 16,ACSAV+15
			MOVE A,X2
			PUSHJ P,RDFONT
			MOVSI 16,ACSAV
			BLT 16,16
			MOVE C,FSP
			JRST .+1]
	TLO D,%ECHAR
	MOVEM D,(C)
	HRRZM C,ITMLST
	HRLM X1,1(C)
	HRRM Y1,1(C)
;	MOVE X2,FONTN		;FONT NUMBER
	MOVEM X2,2(C)
	ADD X1,FONTHT(X2)	;GET MAX X COORD
	ADDI C,3
CHARS3:	PUSHJ P,INWD
	TRNN A,1
	JRST CHARS2
	MOVE Y2,[440700,,A]
CHRSL1:	ILDB T,Y2		;FIGURE OUT MAX Y COORD
	JUMPE T,CHRSL2
;CHARACTER TRANSLATION TO ACCOMODATE DRAWING PROGRAM.
;INTERCHANGE UPARROW AND CIRCUMFLEX, LEFTARROW AND UNDERSCORE.
	CAIE T,13
	 CAIN T,136
	  XORI T,13#136
	CAIE T,30
	 CAIN T,137
	  XORI T,30#137
	DPB T,Y2
;END OF CHARACTER TRANSLATION
	ADD T,FNTPTR(X2)
	LDB ZR,[%CHWD,,(T)]
	ADD Y1,ZR
	TLNE Y2,760000
	JRST CHRSL1
CHRSL2:	MOVEM A,(C)
	AOBJP C,CHARS3

CHARS2:	PUSHJ P,MXMNU1		;UPDATE MAX, MIN X,Y FROM X1,Y1
	TLNN C,-1
	JRST CHARS5		;NULL STRING
	MOVE ZR,-1(C)		;LAST WD STORED
	TRNN ZR,377
	JRST CHARS4		;OK IT ENDED IN A 0
CHARS5:	CLEARM (C)
	AOS C
CHARS4:	HRRZM C,FSP
	HRRZS C
	CAIL C,FS+FSL
	.VALUE
	JRST CMDL1

DIAM:	TLO D,%EDIA
	MOVEM D,(C)
	HRRZM C,ITMLST
	HRLM X1,1(C)
	HRRM Y1,1(C)
	ADDI C,2
	CAIL C,FS+FSL
	.VALUE
	MOVEM C,FSP
	JRST CMDL

DTXINI:
DSXINI:
RASCZI:	MOVE A,[440700,,ASCZBF]
	MOVEM A,ASCBFP
	CLEARM ASCZBF		;CLEAR OUT ASCZBF TO ASSURE LOW BIT CLEAR
	MOVE A,[ASCZBF,,ASCZBF+1]
	BLT A,ASCZBF+LASCZB-1
	CLEARM ASCCNT
	POPJ P,

DSIX:	MOVE B,[440600,,A]
DSIXL:	ILDB C,B
	JUMPE C,CPOPJ
	PUSHJ P,DSIXCH
	TLNE B,770000
	JRST DSIXL
	POPJ P,

DSIXCH:	ADDI C,40
DTXCHR:	IDPB C,ASCBFP
	AOS ASCCNT
	POPJ P,

DTXP2:	IDIVI A,10.
	MOVEI C,"0(A)
	PUSHJ P,DTXCHR
	MOVEI C,"0(B)
	PUSHJ P,DTXCHR
	POPJ P,

DTXWD:	MOVE B,[440700,,A]
DTXW1:	ILDB C,B
	JUMPE C,CPOPJ
	PUSHJ P,DTXCHR
	TLNE B,760000
	JRST DTXW1
	POPJ P,

RASCZ:	PUSHJ P,RASCZI
RASCZ1:	PUSHJ P,INWD		;READ IN ASCIZ STRING FROM INPUT. LEAVE IT STARTING AT
	MOVE B,[440700,,A]
RASCZ2:	ILDB C,B
	JUMPE C,RASCZ3		;HIT TERMINATOR IN INPUT
	AOS ASCCNT
	IDPB C,ASCBFP
	TLNE B,760000
	JRST RASCZ2
	JRST RASCZ1

RASCZ3:	MOVEI C,DHALT
	AOS ASCBFP
	MOVEM C,@ASCBFP		;ASSURE STOP AT END OF DISPLAY
	POPJ P,

DTXCA:
DSXTC:	PUSHJ P,RASCZ3		;ACTIVATE STORED SIXBIT TEXT	
DTEXTC:	MOVE D,FONTMW(A)	;DISPLAY TEXT IN ASCZBF CENTERED AT
				;X AND Y COORDINATES IN B (IN INTERNAL DISPLAY
				;PROCESSOR FORM, 15 BITS EA, LEFT ADJUSTED)
	IMUL D,ASCCNT		;USING FONT NUMBER IN A
	LSH D,-1		;GET 1/2 LENGTH OF TEXT
	LSH D,6			;MOVE INTO W COORD POS
	SUB B,D
DTEXT:	HRLM A,ASCBFT
	TRO B,AIVEC
	MOVEM B,ASCB0
	MOVEI W,ASCB0
	PUSHJ P,IDLST
	POPJ P,
	
DBOX:	MOVEI W,BOXTAB
	PUSHJ P,IDLST		;INTERPRET DISPLAY LIST
	POPJ P,
	
IDLST:	MOVE A,(W)		;INTERPRET DISPLAY LIST, PC IN W
	TRNN A,1
	JRST IDLCH		;IN LINE CHARACTERS
	LDB B,[30300,,A]
	CAILE B,MXVOP
	.VALUE
	JRST @IDLDT(B)

IDLDT:	IDOPR
	IDVEC
	IDAVEC

IDLCH:	MOVE X1,IDCX
	MOVE Y1,IDCY
	SUB X1,XCENOF		;COMPENSATE FOR ADDS THAT WILL HAPPEN LATER
	SUB Y1,YCENOF
	MOVE C,FSP
	HRRZ D,ITMLST
	TLO D,%ECHAR
	MOVEM D,(C)
	HRRZM C,ITMLST
	HRLM X1,1(C)
	HRRM Y1,1(C)
	MOVE X2,IDFNTN
	MOVEM X2,2(C)
	ADD X1,FONTHT(X2)	;MAX X COORD
	ADDI C,3
IDLCH1:	MOVE A,(W)
	TRNE A,1
	JRST IDLCH4
	MOVE Y2,[440700,,A]
IDLCH3:	ILDB T,Y2
	JUMPE T,IDLCH2
	ADD T,FNTPTR(X2)
	LDB ZR,[%CHWD,,(T)]
	ADD Y1,ZR
	TLNE Y2,760000
	JRST IDLCH3
IDLCH2:	MOVEM A,(C)
	AOS W
	AOBJP C,IDLCH1

IDLCH4:	CLEARM (C)
	TLNN C,-1
	JRST IDLCH5		;NULL STRING MUST BE TERMINATED
	MOVE Y2,-1(C)
	TRNE Y2,177*2
IDLCH5:	AOS C			;ASSURE STRING TERMINATED BY 0 (LEAVE EXTRA WORD IF NEC)
	HRRZM C,FSP
	HRRZS C
	CAIL C,FS+FSL
	.VALUE
	MOVEM C,FSP
	JRST IDLST

IDOPR:	CAIN A,1
	POPJ P,			;END OF LIST
	LDB B,[10200,,A]
	CAIN B,1
	 JRST [	HLRZM A,IDFNTN	;STORE FONT NUMBER TO USE
		AOJA W,IDLST]
	.VALUE

IDVEC:	.VALUE

IDAVEC:	TRNE A,4
	JRST IDVEC1		;INVISIBLE, JUST DO SET POINT
	MOVE X2,IDCX
	MOVE Y2,IDCY
	LDB X1,[251700,,A]
	TRNE X1,40000
	ORCMI X1,37777
	LDB Y1,[61700,,A]
	TRNE Y1,40000
	ORCMI Y1,37777
	MOVEM X1,IDCX		;THESE BECOME CURRENT POINT
	MOVEM Y1,IDCY
	SUB X1,XCENOF		;COMPENSATE FOR ADD S THAT WILL HAPPEN LATER
	SUB X2,XCENOF
	SUB Y1,YCENOF
	SUB Y2,YCENOF
	PUSHJ P,VECTAD
	AOJA W,IDLST

IDVEC1:	LDB X1,[251700,,A]
	TRNE X1,40000
	ORCMI X1,37777
	LDB Y1,[61700,,A]
	TRNE Y1,40000
	ORCMI Y1,37777
	MOVEM X1,IDCX
	MOVEM Y1,IDCY
	AOJA W,IDLST

DBUCKS:	MOVE A,ITMLST		;RELOCATE EVERYTHING BY XCENOF AND YCENOF AND
DBUCKL:	JUMPE A,CPOPJ		;PUT THINGS IN THEIR APPROPRIATE BUCKET
	LDB C,[360600,,(A)]	;ITEM TYPE
	CAIN C,%EVEC_-12.
	JRST DBUCKV		;GENERAL VECTOR ONLY ONE THAT DOESNT HAVE X,Y IN WD1
	HLRE X1,1(A)
	HRRE Y1,1(A)
	ADD X1,XCENOF
	ADD Y1,YCENOF
	HRLM X1,1(A)
	HRRM Y1,1(A)
DBUCV1:	CAIN C,%EDIA_-12.
	 SUBI Y1,DIAMSZ		;DIAMONDS SORTED BY POS OF TOP NOT CENTER
	SKIPG Y1
	TDZA Y1,Y1
	IDIVI Y1,RASGRP
	MOVE C,A
	HRRZ A,(A)
	CAIL Y1,LRASTB
	JRST DBUCKL	;STARTS OFF Y RASTER, FLUSH
	MOVE B,RASTAB(Y1)
	HRRM B,(C)
	HRRZM C,RASTAB(Y1)
	JRST DBUCKL

DBUCKV:	HLRE X1,2(A)
	HLRE Y1,1(A)
	ADD X1,XCENOF
	ADD Y1,YCENOF
	HRLM X1,2(A)
	HRLM Y1,1(A)
	JRST DBUCV1

INFN:	MOVE A,MAXXC
	ADD A,MINXC		;X CENTER OF PICT AS IS IN RASTER POINTS
	ASH A,-1
	MOVEI B,<BXURX+<BXLLX+XGPLAB>>*<PAGRES/100.>/2	;X CENTER OF BOX
	SUB B,A
	MOVEM B,XCENOF		;X OFFSET TO CENTER PICTURE
	MOVE A,MAXYC
	ADD A,MINYC
	ASH A,-1
	MOVEI B,<BXURY+BXLLY>*<PAGRES/100.>/2
	SUB B,A
	MOVEM B,YCENOF		;Y OFFSET TO CENTER PICTURE
	PUSHJ P,DBOX		;PUT IN BOX AND STUFF.  DONT COUNT THEM IN
				; MINXC, ETC.
	PUSHJ P,RASCZ		;DRAWN BY
;	MOVE A,LAFONT		;LABELLING FONT NUMBER
;	MOVE B,DWBXY		;X Y POSITION OF CENTER OF DRAWN BY TEXT
;	PUSHJ P,DTEXTC
	PUSHJ P,RASCZ		;FIRST TITLE LINE
	MOVE A,LAFONT
	MOVE B,1TTLXY
	PUSHJ P,DTEXTC
	PUSHJ P,RASCZ		;SECOND TITLE LINE
	MOVE A,LAFONT
	MOVE B,2TTLXY
	PUSHJ P,DTEXTC
	PUSHJ P,INWD		;READ DATE WORD
	PUSHJ P,INWD		;FILE NAME
	MOVEM A,FILENA
	MOVE A,PLTVER
	CAIGE A,14
	 JRST INFN1
	PUSHJ P,INWD		;FILE EXT
INFN1:	PUSHJ P,INWD		;FILE PPN
	MOVEM A,FILEPP
	PUSHJ P,DSXINI		;INITIALIZE 6 BIT TEXT DISPLAYER
	MOVE A,FILEPP
	PUSHJ P,DSIX
	MOVEI C,';
	PUSHJ P,DSIXCH
	MOVEI C,0
	PUSHJ P,DSIXCH
	MOVE A,FILENA
	PUSHJ P,DSIX
	MOVE B,FILNXY
	MOVE A,LAFONT
	PUSHJ P,DSXTC
	.CALL [	SETZ		;ATTEMPT TO GET CREATION DATE OF DRAW FILE
		SIXBIT /OPEN/
		5000,,0
		1000,,0		;CHNL 0
		[SIXBIT /DSK/]
		FILENA
		[SIXBIT /DRW/]
		SETZ FILEPP]
	JRST DFDAT1
	.CALL [	SETZ
		SIXBIT /RFDATE/
		1000,,0
		402000,,FILEDA]
	JRST DFDAT2
	PUSHJ P,DTXINI
	LDB A,[220500,,FILEDA]
	PUSHJ P,DTXP2		;2 DIGIT DECIMAL PRINT
	MOVEI C,"-
	PUSHJ P,DTXCHR
	LDB A,[270400,,FILEDA]
	MOVE A,MONTHS-1(A)
	PUSHJ P,DTXWD
	MOVEI C,"-
	PUSHJ P,DTXCHR
	LDB A,[331000,,FILEDA]
	PUSHJ P,DTXP2
	MOVEI C,40
	PUSHJ P,DTXCHR
	HRRZ A,FILEDA
	IDIVI A,120.		;CONVERT 1/2 SECONDS INTO MINUTES
	IDIVI A,60.
	PUSH P,B
	PUSHJ P,DTXP2
	MOVEI C,":
	PUSHJ P,DTXCHR
	POP P,A
	PUSHJ P,DTXP2
	MOVE B,DATEXY
	MOVE A,LAFONT
	PUSHJ P,DTXCA
DFDAT2:	.CLOSE 0,
DFDAT1:	PUSHJ P,DBUCKS		;PUT EVERYTHING IN ITS BUCKET ..
	.OPEN OUTCH,OUTO	;OUTPUT PHASE
	 .LOSE %LSFIL
	MOVEI A,0
SCNG:	CAIL A,LRASTB
	JRST FIN
	MOVE B,A
	IMULI B,RASGRP		;GET SCAN LINE NUMBER THAT IS BASE OF GROUP
	CLEARM SCNBUF
	MOVE C,[SCNBUF,,SCNBUF+1]
	BLT C,ESCNBF-1
	HRRZ D,RASTAB(A)
	JUMPE D,ESCNG		;THAT GROUP NULL
	MOVEI T,RASTAB(A)	;WHERE D CAME FROM
	MOVEI ZR,1		;FOR DPB ING
ITML:	LDB C,[360600,,(D)]	;GET ITEM TYPE
	CAIL C,MXITEM
	.VALUE
	JRST @ITMDIS(C)		;POINTER TO ITEM IN D, GROUP BASE LINE IN B
				;GROUP INDEX IN A
FLSITM:	HRRZ D,(D)		;FLUSH ITEM (IE DELINK IT FROM LIST)
	HRRM D,(T)		;SMASH WHAT THIS ONE POINTS TO IN PLACE
	JRST NXITM1		;THAT POINTED TO THIS ONE

NXITM:	MOVE Y1,RASTAB+1(A)	;SHIFT THIS GUY INTO NEXT GROUP
	HRRZM D,RASTAB+1(A)
	MOVE DX,D
	HRRZ D,(D)
	HRRM D,(T)		;PATCH OUT
	HRRM Y1,(DX)		;PATCH IN
NXITM1:	JUMPN D,ITML
ESCNG:	PUSHJ P,WRTGRP		;OUTPUT STUFF
	AOJA A,SCNG


ITMDIS:	[.VALUE]
	ITMVEC
	ITMCHR
	ITMDIA
	ITMHV
	ITMVV

ITMVEC:	HLRE Y1,1(D)
	JUMPL Y1,[	SOSGE 5(D)	;IGNORE NEGATIVE PART OF VECTOR
			JRST FLSITM
			JRST ITMVE1]
	CAIL Y1,RASGRP(B)
	JRST NXITM		;HAVE DONE ALL OF THIS LINE THAT BELONGS IN THIS
	SOSGE 5(D)		;RASTER GROUP
	JRST FLSITM		;THAT ONE THRU WITH
	HLRZ DX,2(D)		;X POSITION
	IDIVI DX,32.
	CAIL DX,LSCNBF
	JRST ITMVE1		;X POSITION OUT OF RANGE
	SUB Y1,B
	IMULI Y1,LSCNBF
	ADD DX,Y1		;DISPLACE FOR SCAN LINE WITHIN GROUP
	DPB ZR,SCNPTR(DY)
ITMVE1:	MOVE DX,3(D)
	ADDM DX,1(D)
	MOVE DX,4(D)
	ADDM DX,2(D)
	JRST ITMVEC

ITMVV:	HRRE Y1,1(D)		;DRAW PART OF VERTICAL VECTOR THAT IS PART
				;OF CURRENT GROUP
	JUMPL Y1,[	ADDB Y1,2(D)	;REDUCE DY BY AMT Y IS NEG
			JUMPL Y1,FLSITM	;IT LOSES
			HLLZS 1(D)	;NOW Y = 0
			MOVEI Y1,0
			JRST .+1]
	SUB Y1,B
	CAIL Y1,RASGRP	;Y1 NOW HAS NUMBER LINES IN THIS GROUP THAT ARE NOT
			;PART OF LINE
	.VALUE		;THAT SHOULDNT HAPPEN
	HLRZ DX,1(D)	;PICK UP X
	IDIVI DX,32.	;GET WORD, BIT ADR
	CAIL DX,LSCNBF
	JRST FLSITM
	MOVE X1,BITTAB(DY)
	HRRZ Y2,Y1
	ADD Y2,2(D)
	CAIGE Y2,RASGRP
	JRST ITMVV1	;VECTOR DOES NOT EXTEND THRU REST OF GROUP ONCE IT STARTS
	JRST ITMVVT(Y1)
ITMVVT:	REPEAT RASGRP, IORM X1,SCNBUF+<LSCNBF*.RPCNT>(DX)
	SUBI Y1,RASGRP	;GET - # POINTS TURNED ON
	ADDB Y1,2(D)	;DECREMENT DY
	JUMPLE Y1,FLSITM
	MOVEI Y1,RASGRP(B)
	HRRM Y1,1(D)	;UPDATE Y TO START ON NEXT GROUP
	JRST NXITM
	
ITMVV1:	IMULI Y1,LSCNBF
	ADD Y1,DX
ITMVV2:	SOSGE 2(D)
	JRST FLSITM
	IORM X1,SCNBUF(Y1)
	ADDI Y1,LSCNBF
	JRST ITMVV2

ITMHV:	HRRE Y1,1(D)		;DRAW HORIZONAL VECTOR
	JUMPL Y1,FLSITM
	SUB Y1,B		;GET LINE NUMBER WITHIN GROUP
	HLRE DX,1(D)
	JUMPL DX,[	ADDB DX,2(D)	;REDUCE DX BY AMOUNT X IS NEG
			JUMPL DX,FLSITM
			HRRZS 1(D)
			MOVEI DX,0
			JRST .+1]
	MOVE X1,DX
	ADD X1,2(D)	;ENDING X
	SUBI X1,LSCNBF*32.	;SUBTRACT MAX ALLOWABLE
	MOVNS X1
	SKIPGE X1
	ADDM X1,2(D)	;REDUCE DX BY ENUF TO STAY IN BOUNDS
	SKIPG 2(D)
	JRST FLSITM
	IDIVI DX,32.	;DY GETS # POINTS AT LEFT EDGE OF WORD THAT ARE NOT
	CAIL DX,LSCNBF	; PART OF THIS VECTOR
	JRST FLSITM	; STARTING X OFF TO HIGH SIDE
	HRRZ Y2,DY	;BIT OFFSET OF START OF VECTOR
	ADD Y2,2(D)	;LENGTH OF VECTOR
	LSH Y2,-5	;GET WORD VECTOR ENDS IN (RELATIVE TO ITS START)
	IMULI Y1,LSCNBF
	ADD Y1,DX	;NOTE: STORING ROUTE MUST ASSURE DX DOESNT TAKE US
			;OUT OF RANGE  Y1 NOW HAS START SCNBUF WORD INDEX
	JUMPE Y2,ITMHV1	;SAME AS IT STARTS? JUMP ON YES DO IT THE SLOW WAY
	MOVE X1,RTBTTB(DY)	;GET RIGHT BIT MASK
	IORM X1,SCNBUF(Y1)
	SUBI DY,32.
ITMHV3:	AOS Y1
	ADDB DY,2(D)	;DECREMENT DX FOR BITS DRAWN SO FAR
	CAIGE DY,32.
	JRST ITMHV2	;LESS THAN A WORD FULL OF BITS LEFT
	MOVNI X1,20
	MOVEM X1,SCNBUF(Y1)
	MOVNI DY,32.
	JRST ITMHV3

ITMHV2:	MOVE X1,LFBTTB(DY)
	IORM X1,SCNBUF(Y1)
	JRST FLSITM

ITMHV1:	MOVE X1,BITTAB(DY)
	IORM X1,SCNBUF(Y1)
	SOSG 2(D)
	JRST FLSITM
	AOJA DY,ITMHV1

INWD:	HRRZ A,INBUFP
	CAIL A,INBUF+INBFSZ
	JRST INWD1
	MOVE A,(A)
	AOS INBUFP
	POPJ P,

ITMCHR:	HLRE X1,1(D)		;PLOT CHR STRING
	HRRE Y1,1(D)		;THIS X,Y ARE COORDINATES OF LOWER LEFT CORNER OF
				;RASTER OF FIRST CHARACTER
	HRRZ X2,2(D)		;FONT NUMBER
	MOVEI C,3(D)
	HRLI C,440700		;BYTE POINTER TO CHAR STRING
	MOVEM C,CSBYP
	CLEARM KPSTF		;SET THIS IF WANT TO "KEEP" STRING
	MOVE Y2,X1		; IE IF IT EXTENDS BEYOND CURRENT RASTER GROUP
	JUMPL Y2,FLSITM		;OUT OF RANGE
	ADD Y2,FONTHT(X2)
	CAIL Y2,LSCNBF*32.
	JRST FLSITM		;OUT OF RANGE
	MOVE DX,X1
	IDIVI DX,32.
	MOVEM DX,CSXWDO		;X WORD OFFSET
	MOVEM DY,CSXBTO		;X BIT OFFSET IE FIRST BIT OF RASTER SHOULD BE
	MOVNS DY		;SHIFTED RIGHT THIS MUCH
	HRRZM DY,CSXSFT		;NEGATIVE NUMBER SUITABLE FOR LSHC @
ICHLP:	ILDB Y2,CSBYP		;PICK UP CHAR
	JUMPE Y2,ICHLPX		;THRU
	SKIPN C,FNTPTR(X2)
	 .VALUE			;FONT NOT LOADED?
	ADD Y2,C
	SKIPN TT,(Y2)		;CHAR DEFINED IN THAT FONT?
	 MOVE TT,"?(C)
	JUMPL Y1,ICHLP1		;IS THIS CHAR COMPLETELY OFF RASTER?
	LDB W,[%CHWD,,TT]	;WIDTH OF CHARACTER
	MOVE DX,W
	ADD DX,Y1		;Y COORD OF END OF CHAR
	CAIGE DX,(B)
	JRST ICHLP1		;ENDS BELOW CURRENT RASTER GROUP
	CAIL Y1,RASGRP(B)
	JRST NXITM		;STARTS ABOVE CURRENT RASTER GROUP
				; (SO REST OF STRING WILL BE IN NEXT GROUP)
	LDB DY,[%CHRLC,,TT]	;GET LEFT KERN
	TRNE DY,40
	ORCMI DY,77
	SUB Y1,DY
ICHLP9:	LDB DX,[%CHRWD,,TT]	;GET RASTER WIDTH
	SUBM W,DX		;ANY RIGHT SIDE NULLNESS?
	ADD DX,DY
	MOVEM DX,ICHRNL		;# RIGHT SIDE BLANK LINES
	LDB W,[%CHRWD,,TT]	;REAL RASTER WIDTH
ICHLP2:	CAIGE Y1,(B)		;ACTUAL LOOP TO PUT CHAR IN. LOOP ONCE FOR EACH
	JRST ICHLP4		;UNIT CHAR WIDTH (SPACE OVER RASTER WD WOULD HAVE USED)
	CAIL Y1,RASGRP(B)
	JRST [	SETOM KPSTF	;WANT TO SET BITS IN NEXT RASTER GROUP
		JRST ICHLPX]
	MOVE DX,(TT)		;GET BITS
	AOS TT			;MOVE TO NEXT WD OF CHAR
	MOVEI DY,0
	LSHC DX,@CSXSFT		;SHIFT THEM RIGHT
	LSHC DX,-4		;CREATE "HOLE" IN RIGHT PLACE
	LSH DX,4
	MOVE C,Y1
	SUB C,B			;SCAN LINE WITHIN GROUP
	CAIL C,RASGRP
	.VALUE
	IMULI C,LSCNBF
	ADD C,CSXWDO
	IORM DX,SCNBUF(C)
	IORM DY,SCNBUF+1(C)
ICHLP3:	AOS Y1
	SOJG W,ICHLP2
ICHLPB:	SKIPLE ICHRNL
	ADD Y1,ICHRNL
	JRST ICHLP

ICHLP4:	HRRZ DX,B		;SPACE PAST PART OF CHAR NOT IN CURRENT RASTER
	SUB DX,Y1		;GROUP
	CAMLE DX,W
	MOVE DX,W
	ADD TT,DX
	ADD Y1,DX
	SUB W,DX
	JUMPG W,ICHLP2
	JRST ICHLPB

ICHLP1:	ADD Y1,W		;SPACE PAST CHAR WITHOUT TRYING TO PUT IT IN
	JRST ICHLP

ICHLPX:	SKIPE KPSTF
	JRST NXITM		;REENTER STRING IN NEXT GROUP
	JRST FLSITM		;FLUSH STRING

DIAMSZ==4	;RADIUS OF A DIAMOND
ITMDIA:	HLRE X1,1(D)		;GET CENTER COORDS OF DIAMOND
	HRRE Y1,1(D)
	MOVE Y2,B		;FIRST SCAN LINE THIS RASTER GROUP
DIAMO1:	MOVE DX,Y1
	SUB DX,Y2		;NUMBER OF LINES ABOVE CENTER
	JUMPL DX,DIAMO2		;BELOW CENTER
	SUBI DX,DIAMSZ		;- NUMBER OF LINES BELOW TOP (= HALF WIDTH)
	JUMPGE DX,DIAMO9	;ABOVE TOP, NO INK
	MOVE X2,DX
DIAMO3:	LSH X2,1		;- # POINTS IN THIS RASTER LINE
	ADD DX,X1		;FIRST POINT
	IDIVI DX,32.		;DX WD NO, DY BIT NO
	MOVE W,Y2
	SUB W,B
	IMULI W,LSCNBF		;ORIGIN THIS SCAN LINE
	ADDI DX,SCNBUF(W)	;ABSOLUTE WORD NO
	SETO TT,
	SETZ W,
	LSHC TT,(X2)		;W GETS LEFT-ADJUSTED BIT MASK
	MOVE TT,W
	SETZ W,
	MOVNS DY
	LSHC TT,(DY)		;ALIGN MASK
	MOVE DY,TT		;FIRST WORD
	TRZ DY,17
	LSHC TT,-4		;TT GETS SECOND WORD
	IORM DY,(DX)		;STORE
	IORM W,1(DX)		;..
DIAMO9:	CAIGE Y2,RASGRP-1(B)
	 AOJA Y2,DIAMO1		;NEXT RASTER LINE WITHIN GROUP
	MOVEI TT,DIAMSZ(Y1)	;LAST LINE THIS DIAMOND WRITES ON
	SUBI TT,RASGRP(B)	;NUMBER OF LINES OF NEXT GROUP NEEDED
	JUMPL TT,FLSITM		;DONE
	JRST NXITM		;NEED TO DO MORE ON THIS ONE NEXT GROUP

DIAMO2:	ADDI DX,DIAMSZ		;NUMBER OF LINES ABOVE BOTTOM (= HALF WIDTH)
	JUMPLE DX,DIAMO9	;BELOW BOTTOM, NO INK
	MOVNS X2,DX		;REFLECT ABOUT EQUATOR
	JRST DIAMO3		;REJOIN UPPER CASE

FIN:	HRROI A,[2_<16.+4>+<100000+<<PAGLIN-6>*PAGRES>/10.>_4]	;CAUSE XGP PAPER CUT
	.IOT OUTCH,A
	.CLOSE OUTCH,
	SKIPL DELSW
	.VALUE
	MOVE A,[INCH,,B]
	.RCHST A,
	HRLZS B			;LEFT ADJUST DEVICE NAME
	.CALL [	SETZ
		SIXBIT /DELETE/
		B
		C
		D
		SETZ X1]
	JFCL
RINI:	MOVE A,SFSP
	MOVEM A,FSP
	MOVE A,[SFNTP,,FNTPTR]
	BLT A,FNTPTR+NFONTS-1		;RESTORE STATE OF FONTS IN WHEN RESETTING
					;FREE STORAGE
	.OPEN INCH,INO
	JRST [	.VALUE [ASCIZ /: SCNV FINISHED 
/]
		JRST .-1]
	JRST RCYCLE

INWD1:	MOVE A,[-INBFSZ,,INBUF]
	.IOT INCH,A
	MOVEI A,INBUF
	MOVEM A,INBUFP
	JRST INWD

RDFONT:	CAIL A,NFONTS
	.VALUE
	MOVE B,FONTOP(A)
	.CALL FNOPEN			;READ IN FONT INDEX IN A
	 .LOSE %LSFIL
	CLEARM RDFWC
	PUSHJ P,RDFW			;READ FONT WD, RETN IN C
	MOVEM C,FONTID(A)
	PUSHJ P,RDFW
	HRRZM C,FONTHT(A)		;FONT HEIGHT
	LDB ZR,[221100,,C]
	MOVEM ZR,FONTBS(A)		;BASE LINE
	LDB ZR,[331100,,C]
	MOVEM ZR,FNTCPA(A)		;COLUMN POSITION ADJUSTMENT
	MOVEI X2,35.(C)
	IDIVI X2,36.
	MOVEM X2,FONTHW(A)		;# WDS REQD PER UNIT OF CHAR WIDTH
	CLEARM FONTMW(A)
	MOVEI D,36.			;COMPUTE SHIFT FOR FIRST ROW
	SUBI D,(C)			;SUCH THAT LAST ROW COMES OUT IN HIGH
	HRRZM D,RDFSH1			;ORDER BIT POSITION
	MOVE D,FSP
	MOVEI X1,200(D)
	CAIL X1,FS+FSL
	.VALUE
	MOVEM X1,FSP
	MOVEM D,FNTPTR(A)
	HRLI ZR,(D)
	HRRI ZR,1(D)
	CLEARM (D)
	BLT ZR,177(D)			;CLEAR FONT TABLE
RDFCH:	PUSHJ P,RDFW
	CAIE C,1
	JRST RDFCH1
	PUSHJ P,RDFW
	HRRZ X1,C			;CHAR CODE
	HLRE ZR,C			;LEFT KERN
	ADD ZR,FNTCPA(A)		;COLUMN POSITION ADJUSTMENT
	PUSH P,ZR
	ADD X1,FNTPTR(A)		;GET INDEX IN FONT TABLE
	PUSHJ P,RDFW
	HLRZ Y1,C			;RASTER WIDTH
	MOVE T,FSP
	DPB Y1,[%CHRWD,,T]		;WIDTH OF RASTER
	DPB C,[%CHWD,,T]		;WIDTH OF CHAR
	POP P,ZR
	DPB ZR,[%CHRLC,,T]		;LEFT KERN OF CHAR
	CAMLE Y1,FONTMW(A)
	MOVEM Y1,FONTMW(A)		;THIS WIDEST CHAR SO FAR
	MOVE X2,Y1
	IMUL X2,FONTHW(A)		;# WDS PER UNIT OF CHAR WIDTH
	MOVE C,X2
	ADDI C,(T)
	CAIL C,FS+FSL
	.VALUE
	HRRZM C,FSP
	HRLI ZR,(T)
	HRRI ZR,1(T)
	CLEARM (T)
	BLT ZR,-1(C)			;CLEAR OUT STG TO BE USED FOR CHAR
	MOVEM T,(X1)			;STORE POINTER IN CHAR TABLE
	CLEARM RDFRWC			;ROW COORDINATE
	CLEARM RDFBYC			;BYTES LEFT IN CURRENT WORD
RDFWL1:	CLEARM RDFWDC			;WIDTH COORDINATE
	CLEARM RDFBTC			;BITS LEFT IN CURRENT BYTE
RDFWL:	PUSHJ P,RDFGBT			;GET BIT, RETURN IN C
	LSH C,@RDFSH1			;SHIFT INTO POSITION FOR FIRST ROW
	LSH C,@RDFRWC			;NOW SHIFT FOR WHAT ROW THIS IS
	HRRZ Y2,T
	ADD Y2,RDFWDC
	IORM C,(Y2)
	AOS Y2,RDFWDC
	CAMGE Y2,Y1
	JRST RDFWL
	AOS Y2,RDFRWC
	CAMGE Y2,FONTHT(A)
	JRST RDFWL1
	JRST RDFCH			;THRU WITH CHAR
	
RDFCH1:	.CLOSE FNTICH,
	POPJ P,	

RDFGBT:	MOVE C,RDFBTC
	TLNN C,770000
	JRST RFGBT1			;GOBBLE NEW BYTE
	ILDB C,RDFBTC			;RETURN BIT
	POPJ P,

RFGBT1:	MOVE C,RDFBYC
	TLNN C,700000
	JRST RFGBT2			;NO MORE BYTES THIS WD
	ILDB D,RDFBYC
	MOVEI C,0
	CIRC C,8			;REVERSE BITS IN BYTE
	MOVEM C,RDFBYT
	MOVE C,[100100,,RDFBYT]
	MOVEM C,RDFBTC
	JRST RDFGBT

RFGBT2:	PUSHJ P,RDFW
	MOVEM C,RDFWDT
	MOVE C,[441000,,RDFWDT]
	MOVEM C,RDFBYC
	JRST RFGBT1

RDFW:	SOSGE RDFWC
	JRST RDFW1
	AOS C,RDFP
	MOVE C,-1(C)
	POPJ P,

RDFW1:	MOVE C,[-RDFBFL,,RDFBF]
	HRRZM C,RDFP
	.IOT FNTICH,C
	SUBI C,RDFBF
	HRRZM C,RDFWC
	SKIPE RDFWC
	JRST RDFW
	.VALUE

WRTGRP:	MOVEM A,WRTGPN	;WRITE SCAN GROUP IN A.
	CLEARM WRTLIG	;LINE WITHIN GROUP
WRTGL:	MOVE A,WRTLIG
	IMULI A,LSCNBF	;GET AOBJN POINTER TO ORIGIN OF SCAN LINE WE WANT TO WRITE
	HRLI A,-LSCNBF
	ADDI A,SCNBUF
IFE GOULDP,[
	PUSHJ P,CNVRT	;CONVERT THOSE BIT FOR XGP (EITHER RUN LENGTH OR IMAGE,
			; WHICHEVER IS SHORTER. STORE CONVERTED BYTE STRING
			; IN BYTBF.  RETURN LENGTH OF STRING (IN PDP-10 WDS)
			; IN B (0 -> NULL RASTER LINE)
	JUMPE B,WRTGL1
	MOVE D,B
	ADDI D,1	;FOR THE EXTRA POSITION/LENGTH WORD
	LSH D,1+16.+4	;CONVERT TO PDP11 WDS (AND MOVE INTO HIGH PDP11 WD POSITION)
	MOVE ZR,WRTGPN
	IMULI ZR,RASGRP
	ADD ZR,WRTLIG	;COMPUTE RASTER LINE NUMBER
	AOS ZR		;ALWAYS ADD 1 TO AVOID A SPEC OF 0 WHICH WOULD BE EOF
	DPB ZR,[042000,,D]
	HRROI C,D
	.IOT OUTCH,C
	MOVNS B
	HRLZS B
	HRRI B,BYTBF
]
.ELSE	MOVE B,A	;DO SOME COMPRESSION HERE SOMEDAY
	.IOT OUTCH,B	;OUTPUT CONVERTED SCAN LINE
WRTGL1:	AOS B,WRTLIG
	CAIGE B,RASGRP
	JRST WRTGL
	MOVE A,WRTGPN
	POPJ P,

WRTGPN:	0		;GROUP NUMBER
WRTLIG:	0		;LINE IN GROUP

CNVRT:	MOVEM A,CVSCP
	SETZM LSTBB'	;AOBJN POINTER IN A TO SCAN LINE TO BE CONVERTED
	SETZM BYTCNT'
	SETZB TT,D	;BIT COUNT, LAST DIFFERENT BIT COUNT
	MOVEI C,0
	JSP T,DEP
	JFCL
	MOVEI C,0
	JSP T,DEP
	JFCL
W1:	MOVE B,(A)
W2:	JFFO B,DOW	;FOUND A BLACK BIT
W3:	ADDI D,32.	;ALL BITS OF THIS WORD WHITE
	AOBJN A,W1
	MOVE C,LSTBB
	MOVEM C,BYTCNT	;BACKUP BYTE BUFFER TO LAST BLACK BITS
REPEAT 3,[	MOVEI C,0	;ESCAPE CODE
	JSP T,DEP
	JRST IMSL
]
	MOVEI C,1
	JSP T,DEP
	JRST IMSL
	JRST ESL

B1:	SETCM B,(A)
B2:	JFFO B,DOB	;FOUND A WHITE BIT
B3:	ADDI D,32.
	AOBJN A,B1
	MOVEI C,0
	JRST DOB	;PRETEND WE JUST GOT A WHITE BIT

DOW:	ANDCA B,MTB(C)
	CAIL C,40
	JRST W3
	ADD C,D		;BIT POSITION OF THIS BIT
	EXCH C,TT	;LAST CHANGE UPDATE
	SUBM TT,C	;DIFFERENCE IN C
DOW2:	CAILE C,377
	JRST DOW1
	JSP T,DEP
	JRST IMSL
	JRST B2

DOW1:	MOVEM C,TEMP'
	MOVEI C,377
	SUBM C,TEMP
	JSP T,DEP
	JRST IMSL
	JSP T,DEP
	JRST IMSL
	MOVN C,TEMP
	JRST DOW2

DOB:	ANDCA B,MTB(C)
	CAIL C,40
	JRST B3
	ADD C,D
	EXCH TT,C
	SUBM TT,C
DOB2:	CAILE C,377
	JRST DOB1
	JSP T,DEP
	JRST IMSL
	MOVE C,BYTCNT
	MOVEM C,LSTBB	;SAVE LAST BYTE USED FOR BLACKNESS
	JRST W2

DOB1:	MOVEM C,TEMP
	MOVEI C,377
	SUBM C,TEMP
	JSP T,DEP
	JRST IMSL
	JSP T,DEP
	JRST IMSL
	MOVN C,TEMP
	JRST DOB2

MTB:	REPEAT 36.,[
	<-1>_<-.RPCNT>
]

DEP:	MOVE X1,BYTCNT
	CAIL X1,BYTMAX	;CAN WE DO BETTER IN IMAGE MODE?
	JRST (T)	;YES
	MOVE Y1,X1
	ANDI Y1,3
	LSH X1,-2
	DPB C,BYTAB(Y1)	;DEPOSIT IN THE KLUDGY FORMAT WANTED BY THE XGP
	MOVEI C,0
	AOS BYTCNT
	JRST 1(T)

BYTAB:	241000,,BYTBF(X1)
	341000,,BYTBF(X1)
	041000,,BYTBF(X1)
	141000,,BYTBF(X1)

BYTBF:	BLOCK LSCNBF

;GET HERE WHEN THE RUN LENGTH ENCODED VERSION IS LONGER THAN AN IMAGE SCAN LINE,
;AND WE WANT TO CONVERT THE BIT MAP INTO AN IMAGE SCAN LINE.

IMSL:	MOVE A,CVSCP	;POINTER TO SCAN LINE
	SETOM LSTBB	;WE HAVE BLACKNESS IN THIS LINE
	SETZM BYTCNT	;START AT BEG OF THE BYTCOUNT
	MOVEI C,0	;ESC
	JSP T,DEP
	JFCL
	MOVEI C,2	;ENTER IMAGE MODE
	JSP T,DEP
	JFCL
IMSL1:	MOVE C,(A)	;PICKUP WORD FROM BIT MAP
	CIRC C,44	;REVERSE BIT ORDER
	MOVE C,D	;PICKUP FIRST 8 BITS
	JSP T,DEP
	JFCL
	LSH D,-8	;NEXT 8, ETC.
	MOVE C,D
	JSP T,DEP
	JFCL
	LSH D,-8
	MOVE C,D
	JSP T,DEP
	JFCL
	LSH D,-8
	MOVE C,D
	JSP T,DEP
	JFCL
	AOBJN A,IMSL1	;BACK FOR THE NEXT BIT MAP WORD
ESL:	MOVE B,BYTCNT
	ADDI B,3	;ROUND OFF TO NEXT HIGHER WORD
	LSH B,-2	;FOUR BYTES/WORD
	SKIPN LSTBB
	MOVEI B,	;RETURN ZERO IF THIS LINE IS NULL
	POPJ P,

CVSCP:	0		;AOBJN POINTER TO SCAN LINE CONVERTING


	
FILENA:	0		;DRW FILE NAME  (SIXBIT)
FILEPP:	0		;DRW FILE PPN   (SIXBIT) 
FILEDA:	0		;DRW FILE TIME OF CREATION (OBTAINED BY OPENING IT, ETC)
ASCBFP:	0		;POINTER TO ASCIZ STRING BUFFER
ASCCNT:	0		;# NON ZERO CHARS IN BUFFER

LAFONT:	3		;FONT TO DO LABELLING IN

PLTVER:	0			;IO VERSION OF 'PLT' FILE

1TTLXY:	BBX BXLLX+BXTXOF,BXLLY+BDTLN/4
2TTLXY:	BBX BXLLX+BXTXOF,BXLLY+3*BDTLN/4
FILNXY:	BBX BXLLX+BXTXOF,BXURY-BFNLN/2
DATEXY:	BBX BXLLX+BXTXOF,BXURY-BFNLN-BDALN/2

ASCB0:	0		;STORE INVISIBLE POINT TO LOCATE STRING HERE
ASCBFT:	0,,DFNTSL	;SELECT APPROPRIATE FONT
ASCZBF:	BLOCK LASCZB	;ASCIZ STRING BUFFER

SCALE:	ISCALE		;RATIO OF PLOTTER STEPS TO XGP STEPS. FRACTION
			;WITH BINARY POINT AT 4.8. INITIALLY .25_35.
		
KPSTF:	0		;-1 IF TRIED TO SET RASTER BITS IN NEXT RASTER GROUP
			; IE RESCHEDULE THIS STRING IN NEXT GROUP AFTER FINISH
			; WITH IT IN THIS GROUP
CSXWDO:	0		;X WORD OFFSET FOR STRING
CSXBTO:	0		;X BIT OFFSET FOR STRING
CSXSFT:	0		;AMT TO LSHC (,-CSXBTO)
CSBYP:	0		;BYTE POINTER TO STRING
ICHRNL:	0		;# BLANK LINES TO RIGHT OF CHR

FONTN:	0		;FONT NUMBER TO REALLY USE FOR NOW

MINXC:	0		;MINIMUM X COORD IN ENTIRE PICTURE
MAXXC:	0		;MAX    -- NOTE THESE ARE AFTER AXIS SWAPPING AND INITIAL
MINYC:	0		;MIN Y  -- SCALING AND OFFSETTING.
MAXYC:	0		;MAX Y

XCENOF:	0		;AMOUNT TO ADD TO ALL X COORDINATES TO CENTER PICT
YCENOF:	0		;AMOUNT TO ADD TO ALL Y "

ITMLST:	0		;INITIAL LIST OF ALL ITEMS. HOLD THEM HERE UNTIL KNOW
			;XCENOF AND YCENOF AND CAN PUT THEM IN RASTAB LISTS.

IDCX:	0		;CURRENT X IN INTERNAL DISPLAY PROC
IDCY:	0		;CURRENT Y
IDFNTN:	0		;FONT NUMBER TO USE FOR DISPLAY PROCESSOR CHARS

MONTHS:	ASCIZ /JAN/
	ASCIZ /FEB/
	ASCIZ /MAR/
	ASCIZ /APR/
	ASCIZ /MAY/
	ASCIZ /JUN/
	ASCIZ /JUL/
	ASCIZ /AUG/
	ASCIZ /SEP/
	ASCIZ /OCT/
	ASCIZ /NOV/
	ASCIZ /DEC/

FNTPTR:	BLOCK NFONTS
FONTHT:	BLOCK NFONTS
FONTHW:	BLOCK NFONTS
FONTBS:	BLOCK NFONTS
FONTMW:	BLOCK NFONTS		;MAX RASTER WIDTH OF ALL CHARS
FONTID:	BLOCK NFONTS
FNTCPA:	BLOCK NFONTS	;COLUMN POSITION ADJUSTMENT

RDFRWC:	0		;ROW COORDINATE
RDFBYC:	0		;BYTE POINTER TO PENDING WORD
RDFWDC:	0		;WIDTH COORDINATE
RDFBTC:	0		;BYTE POINTER TO PENDING BYTE
RDFBYT:	0		;PENDING BYTE
RDFWDT:	0		;PENDING WORD
RDFSH1:	0		;SHIFT FOR FIRST ROW OF FONT SUCH THAT LAST ROW COMES
			;OUT IN HIGH ORDER BIT POSITION
RDFWC:	0		;WDS LEFT IN RDFBF
RDFP:	0		;POINTER TO RDFBF
RDFBF:	BLOCK RDFBFL

FONTOP:	REPEAT NFONTS,CONC FNTO,\.RPCNT,

FNOPEN:	SETZ
	SIXBIT /OPEN/
	5000,,6
	1000,,FNTICH
	[SIXBIT /DSK/]
	(B)
	1(B)
	SETZ 2(B)

	9.
FNTO0:	SIXBIT /13FG/
	SIXBIT /KST/
	SIXBIT /FONTS/

	12.
FNTO1:	SIXBIT /20FG/
	SIXBIT /KST/
	SIXBIT /FONTS/

	16.
FNTO2:	SIXBIT /25FG/
	SIXBIT /KST/
	SIXBIT /FONTS/

	23.
FNTO3:	SIXBIT /33FR/
	SIXBIT /KST/
	SIXBIT /FONTS/

	30.
FNTO4:	SIXBIT /40VSHD/
	SIXBIT /KST/
	SIXBIT /FONTS/


INO:	6,,(SIXBIT /DSK/)
	SIXBIT />/
	SIXBIT /PLT/
	0

OUTO:	7,,(SIXBIT /DSK/)
	SIXBIT />/
	SIXBIT /SCN/
	0

BOXTAB:	BBX BXLLX,BXLLY,AIVEC		;XGP BOX
	BBX BXLLX,BXURY,AVEC
	BBX BXURX,BXURY,AVEC
	BBX BXURX,BXLLY,AVEC
	BBX BXLLX,BXLLY,AVEC
	BBX BXLLX+XGPLAB,BXLLY,AIVEC
	BBX BXLLX+XGPLAB,BXURY-BFNLN-BDALN,AVEC
	BBX BXLLX,BXURY-BFNLN-BDALN,AVEC
	BBX BXLLX+XGPLAB,BXURY-BFNLN-BDALN,AIVEC
	BBX BXLLX+XGPLAB,BXURY-BFNLN,AVEC
	BBX BXLLX,BXURY-BFNLN,AVEC
	BBX BXLLX+XGPLAB,BXURY-BFNLN,AIVEC
	BBX BXLLX+XGPLAB,BXURY,AVEC
	BBX 0,0,DHALT

BITTAB:	REPEAT 32.,SETZ_-.RPCNT
RTBTTB:	REPEAT 32.,<<-1>_-.RPCNT>&-20
LFBTTB:	REPEAT 32.,<-20_<32.-.RPCNT>>

INBUFP:	0
DELSW:	-1			;IF -1, DELETE INPUT AND RECYCLE
FSP:	FS
SFSP:	0			;FSP AFTER READING IN FONTS
ACSAV:	BLOCK 17		;SAVE AC S WHEN READING FONT IN MIDDLE OF PLT INPUT
SFNTP:	BLOCK NFONTS		;SAVED STATE OF FNTPTR AFTER INITIAL FONT READIN
				;RESET WHEN RESETTING FSP
SCANLN:	0			;SCAN LINE NUMBER
LINGRP:	0			;IF -1, THIS SCAN LINE IS LAST IN ITS GROUP, AND ANY ITEMS
				;REMAINING ACTIVE MUST BE MOVED INTO LIST OF NEXT GROUP.

SCNPTR:	REPEAT 32., <43-.RPCNT>_12.+100,,SCNBUF(DX)

CONSTANTS
VARIABLES

PATCH: PAT:	BLOCK 100

PDL:	BLOCK LPDL

INBUF:	BLOCK INBFSZ

SCNBUF:	BLOCK LSCNBF*RASGRP	;BUFFERS A GROUP WORTH OF SCAN LINES
ESCNBF:

RASTAB:	BLOCK LRASTB
	0		;GARBAGE WORD, MUST FOLLOW RASTAB

FS:	BLOCK FSL

	105
END GO

