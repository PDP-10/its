;; SECOND.FAI

;Definitions and variables for Drawing prgm

;Linkage for board files
NOLAY,<				;Suppressed because two versions of BOARDS need to exist
EXTERNAL MAPCON,MAPGND,MAPPWR,CRDPIN,MAPSOC,%%PINN,$$PINN
EXTERNAL LCINIT,GETSLT,SLTOUT,GTSLTL,GTCONP,LOCFUK,PRNLOC,PRNPIN
EXTERNAL MAPOST,CPNMER,CPNSEP,CPNMAP,QUPIN,PINCUE,SLTCUE,BODCUE,CPCUE,PROTOB
EXTERNAL BPINPN,PINPLS,RPNAM,CSLTLP,SLTLPN,LOCOUT
EXTERNAL MATPAK,CMPPAK, CLRPAK, APACK
EXTERNAL FNDWW,FNDNOM,GETBRD,GETNOM,CLRNOM,SETNOM,AVAIL
EXTERNAL WWTYP,DEFNOM,SETWW,PACKNM,LOCTVV,NOMTYP
EXTERNAL N2L,L2N,WNAMES,DEFWW,CLRWW,LNAMES,PUTDEC,MAXN2L

INTERNAL CPOPJ,CPOPJ1,CPOPJ2,CPOPJ3,POPAJ
INTERNAL TREADU,PUTFS,GTCHRX,LETTER, FORSOC, FUCKUP,NDIG
ITS,< INTERNAL .TVOFF,TVMORE >
>;NOLAY

;Linkage for ONE segment layout version
ONE,<
PASS1,<EXTERNAL LAY2S
INTERNAL LAYSYM,.STRT,.STRTL,SCRSET,.CONT,.BLCHK,.NOFST,.NOBLK,REENTER,.LERRET,.UUOCON
INTERNAL LAYVEC,LAYBEG
>;PASS1
PASS2,<INTERNAL LAY2S
EXTERNAL LAYSYM,.STRT,.STRTL,SCRSET,.CONT,.BLCHK,.NOFST,.NOBLK,REENTER,.LERRET,.UUOCON
EXTERNAL LAYVEC,LAYBEG
>;PASS2
>;ONE

;Linkage for Leahy display - in CNVERT
III,<
EXTERNAL LHYRST,LHYADD,LHYIOT,LHYOUT,UPLHY
INTERNAL LHYWRD
>

;IO CHANNEL NUMBERS
DAT__0		;DATA IN AND OUT
IDSK__1	;DISK INPUT
ODSK__2	;DISK OUTPUT
IOLAY__3	;LAYOUT I/O
ICARD__4	;CARD DEF INPUT CHANNEL
DEC,<	DISCHN__5	;VB10C CHANNEL
	PGPCHN__10	;PGP I/O CHANNEL
>;DEC
CMU,<	ATYO__5	;GDP2 OUTPUT CHANNEL
	ATYI__6	;GDP2 INPUT CHANNEL
>;CMU

;DEFAULT PROTECTION FOR OUTPUT FILES
DEFPRO__000
III,<DEFPRO__155>
DEC,<DEFPRO__005>	;NOT HERE!!!!!!!
CMU,<DEFPRO__155>


;NUMBER OF CHARS NECESSARY TO PRINT FILENAME INFO
NOSTAN,<NOITS,<NNCHRS__6+4+6+6+3>>	;FFFFFF.EEE[PPPPPP,NNNNNN]
STANFO,<NNCHRS__6+4+6+4>		;FFFFFF.EEE[PPP,NNN]
ITS,<NNCHRS__6+4+6+1>		;UUUUUU;FFFFFF EEE

;NUMBER OF WORDS NECESSARY TO SHOW DEFAULT FILENAME
NOLAY,<NFWRDS__(NNCHRS+4)/5	>;FFFFFF[PPP,NNN]
LAY,<NFWRDS__(NNCHRS*2+1+4)/5	>;FFFFFF[PPP,NNN]&FFFFFF[PPP,NNN]

;NUMBER OF WORDS NECESSARY FOR NAMBUF PRINTOUT BUFFER
NNWRDS__(NNCHRS+4)/5		;FFFFFF.EEE[PPP,NNN]

;SPECIAL CHARACTERS, DEFINE AS YOU WISH
NOSKEY,<
CTRL__""	;CHARACTER INTERPRETED AS CONTROL BIT
META__3		;		"	  META BIT
CTLMTA__""	;		"	  CTRL META BITS
TTYCM__"'"	;HACK FOR TTY'S AT STANFORD, INC'S CTRL BITS
>;NOSKEY
LAMBDA__""	;FOR DISK IO START, STOP
CRCHR__24	;CR FOR DISKIN AND MACRO ALTER MODE
AMCTL__13	;ALTER MODE <CTRL> CHAR (1 ALT)
AMMTA__14	;ALTER MODE <META> CHAR (2 ALT)
NOSKEY,<TEXIST__"">	;THERE EXISTS, FOR FILENAME
SKEY,<TEXIST__"">
BIGCHR__""	;GET BIGGER
DBLARR__""	;CRLF IN TEXT
NOSKEY,<ALTCHR__"">	;ALTMODE FOR MACRO ALTER MODE
SKEY,<	ALTCHR__7>	;BELL FOR DEC
NOCMU,<ACLOSE__176>	;CLOSING CHARACTER IN ";A"
CMU,<ACLOSE__175>
VRTBAR__"|"	;VERTICAL BAR
STANFO,<ALTMOD__175>	;ALTMODE CHAR
NOSTANFO,<ALTMOD__33>
NOT__""	;CHAR LIKE "-", BUT DIF.
NOTCHR__"-"	;FOR PERMUT AND ALPHA
TILDA__32	;LOW TRUE FOR SIGNAL NAME
GENCHR__"%"	;GENERATED SIGNAL NAME CHAR.
RHG,<GENCHR__"!">

;SPECIAL CHARS FOR SEARCH STUFF IN ALTER MODE AND F
QUOCHR__""	;QUOTE CHAR IN SEARCH STRINGS
BELCHR__"|"	;BEGINNING OR END OF LINE
NOSKEY,<ANYCHR__24>	;ANY CHAR IN SEARCH STRING
SKEY,<ANYCHR__"?">	;	"
NFCHR__""	;NOT NEXT THING
DEC,<	NFCHR__""	>
III,<	NFCHR__""	>
INFCHR__""	;ANY # OF FOLLOWING
LETCHR__"$"		;MATCH ANY LETTER
DIGCHR__"%"		;MATCH ANY DIGIT
ALFCHR__""		;MATCH ANY ALPHANUMERIC

;SCREEN DEMENSIONS - - LEAVE TOP 3 LINES
NODEC,<
%TOP__700
NOIII,<
%BOTTOM__-1000
%LEFT__-1000
%RIGHT__1000
>;NOIII
III,<
%BOTTOM__-776
%LEFT__-776
%RIGHT__776
>;III
NOSTAN,<SCRTOP__1000>
STAN,<SCRTOP__1000-2*CHGHT>
TITBRT__2
TITBIG__2
>;NODEC
DEC,<
VB10,<
%TOP__700
%BOTTOM__-770
%LEFT__-770
%RIGHT__766
SCRTOP__1000-10
>;VB10
GT,<
;HALF PHYSICAL HEIGHT AND WIDTH OF GT40 SCREEN
GTX__1000
IFN GTSMAL,<GTY__600>
IFE GTSMAL,<GTY__1000>
%TOP__GTY-10
%BOTTOM__-GTY+1
%LEFT__-GTX+1
%RIGHT__GTX-1
SCRTOP__GTY
>;GT
PGP,<
%TOP__700
%BOTTOM__-1000
%LEFT__-1000
%RIGHT__1000
SCRTOP__1000
>;PGP
TITBRT__5
TITBIG__2
>;DEC

;ALTER TEXT MODE DISPLAY PARAMETERS
AXPOS__%LEFT+200
AYPOS__%TOP-200
ACHRSZ__2			;CHAR SIZE
ITS,<ACHRSZ__3  >		;CHAR SIZE
				;MUST BE CHARACTER SIZE THAT CORRESPONDS
				;EXACTLY TO LEGAL HARDWARE SIZE
NODEC,<	MAXLIN__=30		;MAX CHARS PER LINE
	MAXPAG__=20
>;NODEC
DEC,<	MAXLIN__=60
NOGT,<	MAXPAG__=40 >
GT,<	MAXPAG__=32 >
>;DEC

GT,<	DPYLEN__1400	>
NOGT,<	DPYLEN__6000	>


ORG	137
	<BYTE (3) VGROUP (9) VMAJOR (6) VMINOR>
ORG

;CTRL C INTERCEPT BLOCK
DEC,<
STORAGE(LOW)
INTBLK:	XWD	4,CTRLCI
	2		;CTRL C INTERCEPT
	0
	0
>;DEC
;SOME MACROES FOR THE GT-40 VERSION
IFN GT40SW,<					;;JB  DEFINE MACROS NOW.

DEFINE	STOPIC(PICNUM)		;;JB DEFINE STOP PICUTRE MACRO.
<	PUSH	P,16			;;JB SAVE DATA REGISTER.
	MOVEI	16,PICNUM		;;JB GET THE PICTURE NUMBERNOW.
	PUSHJ	P,STPSHW		;;JB STOP SHOWING THE PICUTRE NOW.
	POP	P,16			;;JB RESTORE DAMAGED REGISTER NOW.
>

DEFINE	STAPIC(PICNUM)		;;JB OPPOSITE OF THE ABOVE.
<	PUSH	P,16			;;JB SAVE REGISTER NOW.
	MOVEI	16,PICNUM		;;JB  GET THE PICUTRE NUMBER NOW.
	PUSHJ	P,SRTSHW		;;JB START SHOWING IT NOW.
	POP	P,16			;;JB RESTORE REGISTER NOW.
>

DEFINE	BMODS(PIC,OFF,NUM)	;;JB DEFINE PICTURE MODIFICATION MACRO.
<	PUSH	P,13			;;JB SAVE A BUNCH OF REGISTERS NOW.
	PUSH	P,14
	PUSH	P,15
	PUSH	P,16
	MOVEM	P,STCHPS		;;JB SAVE THE STACK NOW.
	PUSH	P,[PIC]			;;JB PLACE PIC NUMON STACK.
	MOVE	16,P			;;JB MOVE OVER POINTER TO START OF MODIFIFIER.
	PUSH	P,[OFF]			;;JB PUSH THE OFFSET NOW.
	PUSH	P,[NUM]			;;JB AND FINALLY PUSHTHE NUMBER.
>

DEFINE	BMODF			;;JB DEFINE CALLING AND POPPING MACRO.
<	PUSHJ	P,BMODDO		;;JB SEND IT OUT NOW.
	MOVE	P,STCHPS		;;JB RESET STACK TO A GOOD ONE.
	POP	P,16			;;JB RESTORE REGISTERS NOW.
	POP	P,15			;;JB
	POP	P,14			;;JB
	POP	P,13			;;JB
>

DEFINE	INCHRW(ARG)		;;JB DEFINE WAIT FOR CHAR AS MACRO
<					;;JB WHICH IS REALLY A PUSHJ TO
	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 0,ARG
			POPJ P,]
		PUSHJ P,GTCHRW	;;JB A PUSHJ WITH THE ARGUMENT AFTER
		POP P,ARG]		;;JB THE SECOND PUSHJ.
>

DEFINE	INCHRS(ARG)		;;JB LIKEWISE DO THE SAME FOR THE FOLLOWING.
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 2,ARG
			POPJ P,
			JRST CPOPJ1]
		PUSHJ P,GTCHRS	;;JB
		POP P,ARG]		;;JB
>

DEFINE	INCHWL(ARG)		;;JB DEFINE THE GET A CHAR (LINE MODE) [WAIT].
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 4,ARG
			POPJ P,]
		PUSHJ P,GTCHWL	;;JB CAL THE CORRECT ROUTINE NOW.
		POP P,ARG]		;;JB GIVE HIM BACK THE ANSWER NOW.
>

DEFINE	INCHSL(ARG)		;;JB AND THE GET CHAR(LINE MODE).
<	PUSHJ	P,[
	DLX,<	SKIPN DLXFLG	>
		SKIPN ISDPY
		JRST [	TTYUUO 5,ARG
			POPJ P,
			JRST CPOPJ1]
		PUSHJ P,GTCHSL	;;JB
		POP P,ARG]		;;JB
>

DEFINE	GTMIX(C1,C2)		;;JB DEFINE A MACRO TO PUT THE CHARACTERS IN OK.
<	BYTE	(4) 0 (8) 0,0,C2,C1	;;JB
>

RDYCJ__25			;;JB DEFINE THE "READY" CONTROL CHARACTER
					;;JB AS BEING A ^U, WHICH IS NOT NORMALLY SENT.
NRDYCJ__17			;;JB LIKEWISE DEFINE THE NOT READY CHARACTER AS ^O.

>;GT					;;JB  END THE CONDITIONAL ASSEMBLY.

;SOME DEFINITIONS FOR THE PGP VERSION
PGP,<
$S__0		;BLISS STACK PTR
$V__3		;BLISS VALUE RETURN REG

DEFINE	RTNCAL	(NAME,A) <
EXTERN	NAME
	MOVE	$S,P
CNT$__0
IFIDN <A><><	FLG$__0	;>	FLG$__1
IFN FLG$,<
	FOR	I IN (A) <
	PUSH	$S,I
CNT$__CNT$+1
>;FOR
>;IFN FLG$
	PUSHJ	$S,NAME
IFN CNT$,<
	SUB	$S,[XWD CNT$,CNT$]
>
	SKIPLE	$V
	MOVEM	$V,$VAL
	MOVE	P,$S
>;RTNCAL
>;PGP

;PG0 -- INFO LINE, CURSOR

NOCMU,<

STORAGE(DPY)	;KEEP ALL DISPLAY STUFF IN LOWER SEG

DEFINE RPNT(X,Y),<
	BYTE(11)<X>,<Y>(3)0,0(2)0,1(4)6
REPEAT 0,<	BYTE(11)0,0(3)0,0(2)0,1(4)6>
	BYTE(8)0,0,200(12)32
	BYTE(8)100,0,100(12)12
	XWD .+3,20
	XWD SAVWRD,64
	BYTE(8)200,0,0(12)12
>

DEFINE LIVW(X,Y,S)
<	BYTE (11)<X>,<Y>(3)3,S(2)1,2(4)6	>

DEFINE RDV(X,Y)
<	BYTE (7)<X>,<Y>(2)0(7)<X>,<Y>(2)2(4)2	>

DEC,<
VB10,<					;;JB ASSEMBLE IN THIS.
FBUF:	0				;BUFFER HEADER
	0
	XWD	030130+TITBRT,221000+SCRTOP-TITBIG*CHGHT-20	;LITE PEN OFF, SCALE-2 BRITE-7, Y
REDWRD:	BYTE (18) 061000+%RIGHT-30 (6) 35,"*",37	;RIGHT 1/2 VARIES
	BYTE (18) 020000,221000+SCRTOP-TITBIG*CHGHT
	BYTE(18) 061000+%LEFT (6) 35,"M","O"	;X,<SHIFT IN>"MO"
MODWRD:	BYTE(6) "D","E","=",35,35,35	;"DE=" RIGHT 1/2 VARIES
	BYTE (6) 35," ","S","C","L","="	;"SCL="
SCLWRD:	BYTE (6) 35,35,35,35," ","L"	;LEFT 1/2 VARIES
LVLWRD:	BYTE (6) "V","L","=",35,35,35	;"LVL=" RIGHT 1/2 VARIES
	BYTE (6) 35," ",37 (18) 100000	;ENTER VECTOR MODE
	XWD 200005,203000		;EXISTS IN VECTORS
	XWD 200204,101404
	XWD 200203,501405
	BYTE (18) 060000 (6) "=",35,35	;"="
FILWRD:
	REPEAT	NFWRDS-1,<
	BYTE (6) 35,35,35,35,35,35
>
	BYTE (6) 35,35,35,35,35,37
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
FVECT1:	0
	0
	0
	0
	0
	XWD 160000,400000
	XWD SAVWR1,0		;JSR SAVWR1
FVECT2:	0
	0
	0
	0
	0
FBRT:	XWD 0,160015		;0;BRITE 5
LOCAT:	XWD 0,%NLOC	;JMP %NLOC (OR JSR LOCATS)
	XWD 600100,160000	;RIGHT
	XWD 400000,LOCATS
	XWD 600300,160000	;LEFT
	XWD 400000,LOCATS
	XWD 640000,160000	;UP
	XWD 400000,LOCATS
	XWD 740000,0		;DOWN,0
%NLOC:	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 160000,0		;JMP ONOFF-1(OR JMP .+1)
%CLOC:	XWD ONOFF-1,0
	XWD 120160,600100	;SCALE-8,RIGHT
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,600300	;LEFT
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,640000	;UP
	XWD 160000,400000	;JSR SAVWR1
	XWD SAVWR1,0
	XWD 120000,740000	;DOWN
	XWD 160120,400000	;SCALE-1,JSR SAVWR1
	XWD SAVWR1,0
	XWD	0,160000	;JSR CROSS(OR JUMP .+1)
ONOFF:	XWD 400000,CROSS
	XWD 160000,0		;JMP VBBUF
ENDPG1:	XWD	FBUF,0

CROSS:	0
	XWD 100137,002004	;INVIS NE
	XWD 304210,004000	;VISIB SW,INVIS N
	XWD 704010,160000	;VISIB SE, JMP @CROSS
	XWD 200000,CROSS
LOCATS:	0
	XWD 0,20000
LOCATW:	XWD 220000,160000
	XWD 320000,LOCATS	;JMP @LOCATS (INTO VEC CONT MODE)

SAVWR1:	0
	XWD 0,20000
SAVWRD:	XWD 221000,161000
	XWD 200000,SAVWR1
NULLO:	0			;NULL SUBROUTINE
	XWD	160000,200000
	XWD	NULLO,0

>;VB10					;;JB

GT,<					;;JB MY CRAP....

JBREDY:	0				;;JB REMEMBERS READY-NOT READY STATE.



	DISTOP__173400			;;JB DEFINE THE DISTOP INSTRUCTION.


PIC3:	117124				;;POSITION TO TOP LEFT OF SCREEN.
	0
	GTY+SCRTOP-CHGHT*2
	100000				;;GET INTO CHARACTER MODE.
	GTMIX	"M","O"			;;JB STICK IN THE CORRECT HEADING
	GTMIX	"D","E"			;;JB  USING 8 BIT GT40 CHARACTERS.
	GTMIX	"=",0			;;JB
GTMODE:	GTMIX	"J","B"			;;JB CHANGABLE MODE LETERS HERE.
	GTMIX	" ","S"			;;JB
	GTMIX	"C","L"			;;JB
	GTMIX	"=",0			;;JB
GTSWRD:	GTMIX	"0",0			;;JB CURRENT SCALING LEVEL.
	GTMIX	" ","L"			;;JB THE LEVEL NOW.
	GTMIX	"V","L"			;;JB
	GTMIX	"=",0			;;JB
GTLWRD:	GTMIX	"0",0			;;JB CURRENT LEVEL VALUE.
	GTMIX	" ",135			;;JB THE 'THERE EXISTS' SIGN.
	GTMIX	10,"-"			;;JB DONE BY SUPERIMPOSING.
	GTMIX	"=",0			;;JB
GTFNAM:	0				;;JB LEAVE ROOM FOR 25 CHARACTERS FOR
	0				;;JB  THE FILE NAME (13 WORDS).
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	0				;;JB ALL THE WAY DOWN.
	DISTOP				;;JB END OF THE LIST NOW.
	0

PIC3Z__.-PIC3				;;JB SIZE OF THE LIST.
	XWD	3,1			;;JB DEFINE AS SUBPICTURE 3, REMEMBER CHANGES.

>;GT					;;JB END OF MYCRAP.

PGP,<
TSXDAT:	0
TSYDAT:	0
FILWRD:	BLOCK	NFWRDS
	0
MODWRD:	0
SCLWRD:	0
LOCAT:	0
LVLWRD:	0
	1
NULARG:	0
NILEV:	0
SEGN:	0
PSEGN:	0
$VAL:	0
FVECT1:	0
FVECT2:	0
BLNKIT:	0
PGBITS:	0
FBUF:	0			;DUMMY
SAVWRD:	0
>;PGP

>;DEC
;CURSOR AND STATUS DISPLAY LISTS
;CHARACTER SIZES
;These are only used for assembled in III words, the size mentioned
;should correspond to the DPYPTX entry for STDBIG.
;There may be some discrepancies that haven't been caught yet.

NODEC,<
NOIII,<
CWIDTH__10
CHGHT__20
>;NOIII
III,<
CWIDTH__4
CHGHT__10
>;III
>;NODEC
DEC,<
CWIDTH__6
CHGHT__12
>;DEC


NODEC,<
NOIII,<
FBUF:	.+2
	FEND-.-1
	0
>;NOIII
III,<
FBUF:	FEND-FBUF1,,FBUF1
FBUF1:
>;III
	LIVW(%RIGHT-CWIDTH*4,SCRTOP-CHGHT*4,6)
REDWRD:	ASCID/*/
	LIVW(%LEFT,SCRTOP-CHGHT*2,4)
NOIII,<	ASCID/MODE=/   >
III,<	LHYWRD:	ASCID/0000 /  >		;# wds of buffer used
MODWRD:	1
	ASCID/   SCL=/
SCLWRD:	1
	ASCID/   LVL=/
LVLWRD:	1
NOIII,<	ASCID/   =/	>
III,<	ASCID/  FILE=/	>
FILWRD:REPEAT NFWRDS,<1>
III,<SAVWR1:	LIVW(0,0,0)	>
NOIII,<	XWD SAVWRD,54	>
FVECT1:	12
III,<SAVWR2:	LIVW(0,0,0)	>
NOIII,<	XWD SAVWRD,54	>
FVECT2:	12
III,<SAVWR3:	LIVW(0,0,0)	>
NOIII,<	XWD SAVWRD,54	>
FBRT:	BYTE(11)0,0(3)2,0(2)0,2(4)6	;USE CURBRT ON THE REST OF THIS
LOCAT:
NOIII,<	XWD %NLOC,20		;NORMALLY JUMP TO %NLOC
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(20,0)		;GO RIGHT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(-20,0)		;GO LEFT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,20)		;GO UP
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD LOCAT,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,-20)		;GO DOWN
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
>;NOIII
%NLOC:
III,<SAVWR4:	LIVW(0,0,0)	>
NOIII,<	XWD SAVWRD,54	>
%CLOC:
NOIII,<	XWD ONOFF,20		;NORMALLY JUMP TO ONOFF
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(10,0)		;GO RIGHT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(-10,0)		;GO LEFT
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,10)		;GO UP
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
	<BYTE(8)40>+12		;CLEAR EDGE FLAG
	RDV(0,-10)		;GO DOWN
	<BYTE(8)0,0,40>+12	;EDGE YET?
	XWD .-2,20		;LOOP BACK
	XWD SAVWRD,54
>;NOIII
ONOFF:
III,<SAVWR5:	LIVW(0,0,0)	>
NOIII,<	XWD CROSS,20		;INITIALLY USE CROSS
	BYTE(8)167,200,0(12)12
	RPNT 0,0
	RPNT 0,0
;INNER RING
	RPNT -4,0
	RPNT 4,-4
	RPNT 4,4
	RPNT -4,4
;START FIRST RING
	RPNT -10,-4
	RPNT 10,-10
	RPNT 10,10
	RPNT -10,10
;START SECOND RING
	RPNT -14,0
	RPNT 0,-20
	RPNT 14,-10
	RPNT 14,10
	RPNT 0,20
	RPNT -14,10
;START THIRD RING
	BYTE(8)0,0,200(12)12	;DON'T DRAW IF WE SAW LIGHT PEN.
	0
	RPNT -14,4
	RPNT -10,-10
	RPNT -4,-14
	RPNT 4,-14
	RPNT 10,-10
	RPNT 14,-4
	RPNT 14,4
	RPNT 10,10
	RPNT 4,14
	RPNT -4,14
	RPNT -10,10
	RPNT -14,4
;START FOURTH RING
	RPNT -16,6
	RPNT -12,-6
	RPNT -6,-12
	RPNT -2,-16
	RPNT 2,-16
	RPNT 6,-12
	RPNT 12,-6
	RPNT 16,-2
	RPNT 16,2
	RPNT 12,6
	RPNT 6,12
	RPNT 2,16
	RPNT -2,16
	RPNT -6,12
	RPNT -12,6
	RPNT -16,2
	0
	0
	0
>;NOIII
CROSS:	BYTE(11)10,10(3)0,0(2)0,2(4)6
	BYTE(11)<-20>,<-20>(3)0,0(2)0,0(4)6
	BYTE(11)0,<20>(3)0,0(2)0,2(4)6
	BYTE(11)<20>,<-20>(3)0,0(2)0,0(4)6
NOIII,<	0
	0
SAVWRD:	1
	0
	0
	0
>;NOIII
FEND__.
>;NODEC

NODEC,<
NOIII,<
BLDPY:	DPYOUT BLINK		;PG # WILL BE FIXED UP
>;NOIII
>;NODEC

STORAGE(IMPURE)			;IMPURE, BUT CAN GO IN UPPER
DPYDPY:	DPYOUT HEAD		;	"
HYDDPY:	DPYOUT [DPYBUF
	NOIII,<	0>	]	;	"

HEAD:	DPYBUF
NOIII,<	0	>

NODEC,<
NOIII,<
BLINK:
NOITS,<	BLINKB	>
ITS,<	SETZ BLINKB	>	;SIGN BIT ON SAYS BLINK THIS PG
	0			;WORD COUNT

BLINKB:	1			;NO-OP IN CASE IT GETS EXECUTED(WHICH I DON'T THINK IT DOES!)
ITS,<	XWD DPYBUF+1,20  >	;SKIP OVER THIS BLINKING STUFF
	XWD BPOS,74		;WHERE WE WERE LAST TIME!
	<BYTE(8)0,0,200>+12
	BYTE(11)400,0(3)0,0(2)0,2(4)6	;20 TO RIGHT OF THERE
	BYTE(11)40,0(3)0,0(2)0,2(4)6	;20 TO RIGHT OF THERE
	<BYTE(8)0,0,40>+12		;EDGE OVERFLOW?
	XWD BLEAV,20			;NO
	BYTE(11)0,0(3)0,0(2)1,2(4)6	;RESET TO CENTER
	<BYTE(8)240,200,0>+12		;CLEAR EO AND SET CONTROL BIT!
BLEAV:	XWD BPOS,64			;SAVE WHERE WE ARE NOW
	<BYTE(8)0,0,200>+12		;CONTROL BIT ON?
	0				;NO, STOP HERE
	XWD DPYBUF+1,20			;TRANSFER TO DPYBUF!
BPOS:	201				;THE 200 WONT HURT US, BUT ITS LIKES IT
BLINKL__.-BLINK
>;NOIII
>;NODEC
>;NOCMU

DPYBUF:	BLOCK DPYLEN+200

	DATPPN_'DATDRW'
CMU,<	DATPPN_<10053,,473002>>	;E130RG02
DEC,<
NOVIROS,<PGP,<	DATPPN__<362,,5010>	;>	DATPPN__0	>
VIROS,<	DATPPN_<4,,253>	>
>;DEC
III,<	DATPPN__<10,,76>>

LIBPPN:	DATPPN

NOCORE:	0
	OUTSTR[ASCIZ/YOU ARE SUFFERING FROM THE UNFORTUNATE FACT THAT
YOUR OVERBLOATED PROGRAM WILL NO LONGER FIT IN OUR
PUNY CORE!!!!!!!
/]
NODEC,<	HALT @NOCORE	>
DEC,<	PUSHJ	P,TODDT	;GO TRY DDT
	JRST	@NOCORE
>;DEC

;CHARACTER SCALE STUFF
;MAX LEGAL SOFTWARE CHARACTER SIZE
CSIZES__7

;The available character scales are defined to be:
;User code	Ratio to min size
;0		1		;SAME AS STDBIG
;1		1
;2		1.5
;3		2
;4		3
;5		4
;6		6
;7		8

;Some sites have drawing that used more kludegy size specs...

DEC,<
	DEFINE MAPSIZ(A)
<	HRRZ A,(A)[11357777]
>
>;DEC

STAN,<
	DEFINE MAPSIZ(A)
<	HRRZ A,(A)[11345555]
>
>;STAN

CMU,<
	DEFINE MAPSIZ(A)
<	HRRZ A,(A)[11345555]
>
>;CMU

IFNDEF MAPSIZ,<DEFINE MAPSIZ(A)<>>

DEFINE FOO(A,B,C,D,E,F,G,H)
<	=A  =B  =C  =D  =E  =F  =G  =H
>

STORAGE(IMPURE)
STDBIG:	DEC,<2;>1		;MAIN TEXT CHARACTER SIZE (MAPPED)

;INTERNAL CHARACTER OFFSETS ARE IN TERMS OF A VIRTUAL CHARACTER SET,
; WHICH IS FIXED FROM SITE TO SITE. IT GIVES CHARACTER OFFSETS
;IN TERMS OF FRACTIONAL CHARACTER UNITS.

;These are the spacings for the virtual character set - don't change!!

VIRPTX:	FOO(8,8,12,16,24,32,48,64)	;Width in Points PER CHAR
VIRPTY:	FOO(16,16,24,32,48,64,96,128)	;Height in points

;DISPLAYS POSSIBLY HAVE DIFFERENT RASTER SPACING THAN VIRTUAL
; AND ALSO DIFF AT SITES
;This compensates for the different display hardware
;Adjust these params to make character spacing right on screen


ITS,<
DPYPTX:	FOO(12,12,12,16,24,32,48,64)
DPYPTY:	FOO(16,16,24,32,48,64,96,128)
>;ITS

III,<	;III has only char sizes 1,1,3,5,7,7,7,7
DPYPTX:	FOO(8,8,16,24,32,48,64,128)
DPYPTY:	FOO(16,16,24,30,42,42,42,42)
>;III

IFNDEF DPYPTX,<
DPYPTX:	FOO(8,8,12,16,24,32,48,64)
DPYPTY:	FOO(16,16,24,30,42,64,96,128)
>;IFNDEF

;PLOTTING MAY BE DIFFERENT

ITS,<
PLTPTX:	FOO(9,9,12,16,23,32,48,64)
PLTPTY:	FOO(16,16,24,30,42,64,96,128)
>;ITS

III,<
PLTPTX:	FOO(8,8,12,16,24,32,48,64)
PLTPTY:	FOO(12,12,20,30,42,64,96,128)
>;III

IFNDEF PLTPTX,<
PLTPTX:	FOO(8,8,12,16,24,32,48,64)
PLTPTY:	FOO(16,16,24,32,48,64,96,128)
>;IFNDEF

;CONVERT SOFTWARE CHARACTER SIZE TO HARDWARE CHARACTER SIZE
;Note: software size 0 must be same as size 1

S2H:
III,<	FOO(1,1,3,5,7,7,7,7) >
DEC,<	FOO(1,1,2,2,3,3,4,4) >
STAN,<	FOO(1,1,3,4,5,6,7,7) >
CMU,<	FOO(1,1,4,4,5,6,6,6) >
ITS,<	FOO(1,1,3,4,5,6,7,7) >

;XTEXTF AND YTEXTF TABLES ARE USED TO OFFSET THE CURSOR FOR TEXT SUCH THAT
;A BOX CHGHT BY CWIDTH (IN WHICH THE CHARACTER IS ASSUMED TO BE CENTERED)
;HAS ITS LOWER LEFT CORNER AT THE CURRENT POSITION.
;THIS COMPENSATES FOR OFFSET IN THE HARDWARE DISPLAY BETWEEN CHARACTER AND
;POINTS. IT IS IN III DISPLAY UNITS.
;TABLES ARE INDEXED BY "HARDWARE" CHARACTER SIZE

DEFINE FOO(A,B,C,D,E,F,G,H)
<	A  B  C  D  E  F  G  H
>

DEC,<
 GT,<
XTEXTF:	FOO(-4,-10,-12,-22)
YTEXTF:	FOO(-1,-4,-4,-10)
 >;GT
 NOGT,<
XTEXTF:	FOO(-4,-6,-12,-22)
YTEXTF:	FOO(-1,-2,-4,-10)
 >;NOGT
>;DEC

STAN,<
XTEXTF:	FOO(-2,0,0,1,4,10,0)
YTEXTF:	FOO(1,0,0,6,14,20,0)
>;STAN

CMU,<
XTEXTF:	FOR I IN (10,14,16,20,30,40,60)
	<I*(CWIDTH/2-3)/10  >
YTEXTF:	FOR I IN(10,14,16,20,30,40,60)
	<I*(CHGHT/2-5)/10  >
>;CMU

ITS,<
XTEXTF:	FOO(0,0,0,0,0,0,0,0)	;TV'S ARE PERFECT!
YTEXTF:	FOO(0,0,0,0,0,0,0,0)
>;ITS

III,<
XTEXTF:	FOO(0,0,0,0,0,0,0,0)	;LEAHY'S NOT SO PERFECT
YTEXTF:	FOO(4,0,6,0,2,0,4,0)
>;ITS

STORAGE(PURE)
;; Constant data locs for layout

NOONE,<
DEFINE CDATA(LABEL,SIZE,SEG)
<
IFIDN<SEG><LOW><STORAGE(LOW);>STORAGE(IMPURE)
LABEL:
IFIDN<SIZE><><0>
IFDIF<SIZE><><BLOCK SIZE>
>
>;NOONE

;In ONE segment layout, the common variables live in the D side.
ONE,<
DEFINE CDATA(LABEL,SIZE,SEG)
<
MD,<IFIDN<SEG><LOW><STORAGE(LOW);>STORAGE(IMPURE)
LABEL:
INTERNAL LABEL
IFIDN<SIZE><><0>
IFDIF<SIZE><><BLOCK SIZE>
>;MD
MPC,<EXTERNAL LABEL>
>
>;ONE
STORAGE(LOW)

LAY,<
RDOFF:	'GODMOD'
	20
OFFSET:	0
REALLN:	0

WRTOFF:	'GODMOD'
	21
NEWOFF:	0
>;LAY


CDATA		PATCH0,40,LOW
NODEC,<
NOIII,<
CDATA		SSSNAM
CDATA		SSSEXT
CDATA		SSSDAT
CDATA		SSSPPN
>;NOIII
>;NODEC

;ZERO AREA FOR LAYOUT "CONSTANTS"
ZLOWBEGIN:
LAY,<
TPDLLN__40	;TEMP PDL LENGTH

CDATA		TPDL,TPDLLN		;TEMP PDL FOR SAVE/GET ROUTINES

CDATA		IWD
CDATA		LAYPDL
CDATA		LAYBIT
CDATA		LAYM
CDATA		ODISP
TWO,<
CDATA		DNUM
CDATA		PCNUM
>;TWO
CDATA		DPCPNT			;POINT PASS LIST POINTER
CDATA		DOPASS
CDATA		LAYLET
CDATA		LAYNUM
CDATA		SWHICH		;0 D currently in, -1 PC currently in
CDATA		SWHCHA
CDATA		SWHCHS		;temp
LAY,<
BLLEN__=400	;ENOUGH FOR 200 LOCATIONS TO BE PASSED
CDATA		BLDATA,BLLEN		;POINT PASS LIST SPACE (LIB)
>;LAY
LIB,<
;THE FOLLOWING MUST BE IN ORDER
CDATA		DBAND,4
CDATA		D2BAND,4
CDATA		PCBAND,4
CDATA		PC2BAND,4
;INDICIES INTO BAND STUFF
BAND__0
DLOC__1
LENGTH__2
SEC__3
BAND2__4

>;LIB
CDATA		SAVNAM
CDATA		SAVEXT
CDATA		SAVPPN
CDATA		LAYLOC
>;LAY
DEC,<
CDATA		RTIME
CDATA		QTIME
CDATA		DTIME
GT,<
CDATA		NBYTES
>;GT
VIROS,<
CDATA		TYPFLG
CDATA		VSTBUF,10
VSTEND__<POINT 7,VSTBUF+7,27>
DLX,<
CDATA	DLDVDS
CDATA	DLXBUF,8
>;DLX
>;VIROS
GT,<
CDATA	OPTFLG
DLX,<
CDATA	DLXFLG
>;DLX
>;GT
>;DEC
nodec,<
NOIII,<
CDATA		DPCNAM
CDATA		DPCEXT
CDATA		DPCDAT
CDATA		DPCPPN
CDATA		STRTLC
CDATA	AUTOSM
CDATA	AUTOSN
>;NOIII
CDATA		SSSP
>;NODEC
CDATA		TJOBDA,200		;TEMP JOB DATA AREA
CDATA	RSAVET,,LOW
NODEC,<
CDATA	NAMBUF,NNWRDS
>;NODEC
DEC,<
CDATA	SPPDL2,SPD2SZ,LOW
CDATA	GOING
VB10,<
CDATA	PGTBL,4
>;VB10
CDATA	NAMBUF,6
>;DEC
CDATA	SPPDL,SPPDSZ,LOW
CMU,<	CDATA PPNBUF,3 >
CDATA	IOHD,3,LOW
CDATA	IOBUF,406,LOW
CDATA	TTBUF,2,LOW
CDATA	CINST
CDATA	CHARP
CMU,<	CDATA	CHKSVC
	CDATA	PSVCNT
PSVLEN__100
	CDATA	PDLSAV,PSVLEN
>;CMU
CDATA	BSOR
CDATA	ISDPY
CDATA	DONTDPY
CDATA	TVISOFF
CDATA	POSS1
CDATA	CURCUR
CDATA	PAGACT
CDATA	REALACT
CDATA	SQRFLG
CDATA	FORSOC
CDATA	FILNAM,,LOW
CDATA	FILEXT,,LOW
CDATA	FILDAT,,LOW
CDATA	FILPPN,,LOW
DEC,<
CDATA	TMPNAM,,LOW
CDATA	TMPEXT,2,LOW
CDATA	TMPPPN,,LOW
>;DEC
CDATA	DSKOPN
CDATA	DSKOHD,3,LOW
CDATA	DSKOBF,210,LOW
CDATA	BRKCHR
CDATA	DSKHD,3,LOW
CDATA	DSKBUF,210,LOW
ZLOWEND__.-1

;For the @ Listing program
;PATCH0#,SSSNAM#,SSSEXT#,SSSDAT#,SSSPPN#,TPDL#,IWD#,LAYPDL#,LAYBIT#
;LAYM#,ODISP#,DNUM#,PCNUM#,DPCPNT#,DOPASS#,LAYLET#,LAYNUM#,SWHICH#
;SWHCHA#,SWHCHS#,BLDATA#,DBAND#,D2BAND#,PCBAND#,PC2BAND#,SAVNAM#,SAVEXT#
;SAVPPN#,LAYLOC#,RTIME#,QTIME#,DTIME#,NBYTES#,TYPFLG#,VSTBUF#,DLDVDS#,DLXBUF#
;OPTFLG#,DLXFLG#,DPCNAM#,DPCEXT#,DPCDAT#,DPCPPN#,STRTLC#,AUTOSM#,AUTOSN#,SSSP#
;TJOBDA#,RSAVET#,NAMBUF#,SPPDL2#,GOING#,PGTBL#,NAMBUF#,SPPDL#,PPNBUF#,IOHD#
;IOBUF#,TTBUF#,CINST#,CHARP#,CHKSVC#,PSVCNT#,PDLSAV#,BSOR#,ISDPY#,DONTDPY#
;TVISOFF#,POSS1#,CURCUR#,PAGACT#,REALACT#,SQRFLG#,FORSOC#,FILNAM#,FILEXT#,FILDAT#
;FILPPN#,TMPNAM#,TMPEXT#,TMPPPN#,DSKOPN#,DSKOHD#,DSKOBF#,BRKCHR#,DSKHD#,DSKBUF#
;LOW CORE LOCNS
ORG 40
UUO:	0
IFN 0,<	JSR UUOCON>
	PUSHJ P,.UUOCON
ORG

NODEC,<
STORAGE(IMPURE)
UUOSAV:	0
>;NODEC

ORG 124
REENTER
ORG

NOFST:	0
	JRST .NOFST
NOBLK:	0
	JRST .NOBLK

LCFLAG:	-1		;ALWAYS START WITH LOWER CASE ENABLED
BOOPCN:	0		;START WITH NO BOOPING
BOOPLR:	0

VIROS,<
NOGT,<
VBCJFN:	-1
>;NOGT
DLX,<
DLXJFN:	-1
>;DLX

STPPN:	3		;FUNCTION CODE FOR PPN TO/FROM DIRECTORY STRING
USRPPN:	0		;PPN RETURNED HERE
STPTR:	0		;POINT TO DIRECTORY STRING
>;VIROS

STORAGE(LOW)	;MAKE AVAILABLE TO TWO SEGMENT PROGRAMS
POPBAJ:	POP P,B
POPAJ:		POP P,A
		POPJ P,
POPBJ:		POP P,B
		POPJ P,
CPOPJ3:	AOS (P)
CPOPJ2:	AOS (P)
CPOPJ1:	AOS (P)
CPOPJ:		POPJ P,
;LAYOUT INITIALIZATION CODE
NODEC,<
NOIII,<
CMU,<	.JBSAV_73  .JBS41_122 >
NOCMU,<	EXTERNAL .JBSAV,.JBS41 >
EXTERNAL .JB41,.JBCOR
LAY,<
STORAGE(LOW)
SAVE:
ONE,<	JRST ERRET>
NOONE,<
	SETZB 0,M
	JSR LINIT
	MOVE P,[IOWD TPDLLN,TPDL]	;TEMP STACK SETUP
	OUTSTR[ASCIZ/BE CAREFUL, WILL NOT CHECK IF ALREADY EXISTS!
/]
	PUSHJ P,DMPNAM
	JRST [	MOVE T,[%PNAME]
		MOVEM T,FILNAM
		MOVE T,['  1  3']
		MOVEM T,FILPPN
		JRST .+1]
	ENTPPN
	MOVE T,[FILNAM,,DPCNAM]
	BLT T,DPCPPN
	MOVEI T,.STRTN
	MOVEM T,STRTLC
LIB,<	SKIPE T,.JBSYM
	SUBI T,LAY2S-LAY1S+LAYBEG-LAY1S
	MOVEM T,LAYSYM-LAYBEG+LAY2S
>;LIB
	JSR ISAVE		;save 2nd half
	 JRST [	OUTSTR[ASCIZ/SAVE OF FIRST PART FAILED!
/]
		EXIT]
LIB,<	SKIPN T,.JBSYM
	JRST [	MOVEI T,LAY1E-1
		SETZ TT,
		JRST CORDWN]
	HLRE TT,T
	MOVN TT,TT
	HRLZ T,T
	HRRI T,LAY1E
	BLT T,LAY1E-1(TT)		;MOVE SYMBOLS DOWN
	MOVEI T,LAY1E-1(TT)		;THIS IS TOP+1
	MOVE TT,.JBSYM
	HRRI TT,LAYBEG+LAY1E-LAY1S
	MOVEM TT,.JBSYM
CORDWN:	MOVEM TT,LAYSYM-LAYBEG+LAY1S
	CORE T,
	JFCL
	MOVEI T,-1
	HRLM T,.JBSA			;.JBFF IS ALWAYS WRONG, MAKE IT VERY WRONG
>;LIB
TWO,<	MOVE T,[LAY1S,,400000]
	BLT T,400000+LAY1E-LAY1S-1
	MOVEI T,LAY1E-1
	CORE2 T,
	 JRST [	OUTSTR[ASCIZ/CORE2 FAILED FOR SECOND PART!
/]
		EXIT]
	SETZM .JBSYM
	MOVEI T,0
	SETDDT T,
	MOVEI T,LOWEND
	HRRZM T,.JBFF
	HRLM T,.JBSA
IFN 0,<;REMOVED BY JBR
	MOVE T,[LAY1S,,LAYBEG]
	BLT T,LAYBEG+LAY1E-LAY1S-1
	SKIPN T,.JBSYM
	JRST [	MOVEI T,LAY1S
		MOVEM T,.JBFF
		HRLM T,.JBSA
		SOJA T,CORDWN]
	HLRE TT,T
	MOVN TT,TT
	HRLZ T,T
	HRRI T,LAY1S
	BLT T,LAY1S-1(TT)
	MOVEI T,LAY1S(TT)
	MOVEM T,.JBFF
	HRLM T,.JBSA
	MOVEI TT,LAY1S
	HRRM TT,.JBSYM
>;IFN 0
	SUBI T,1
CORDWN:	CORE T,
	JFCL
>;TWO
	SETZM SWHCHS			;D IS AT END
	JSR SVREST
	OUTSTR[ASCIZ/SAVE OF SECOND PART FAILED!/]
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	OUTSTR[ASCIZ/
/]
	HLLZS .JBSA			;DISABLE RESTART!!!!!!
	EXIT

DOSAVD:	0
	JSR SAVSPC
	JRST @DOSAVD
	JSR SVFRST
	JRST [	JSR SAVSD
		JRST @DOSAVD
		JRST @DOSAVD]
	JSR SAVSD
	JRST @DOSAVD
	SETZM SWHCHS			;PC IS AT END
	JSR SVREST
	JRST @DOSAVD
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	AOS DOSAVD
	JRST @DOSAVD

DOSAVP:	0
	JSR SAVSD
	JRST @DOSAVP
	JSR SVFRST
	JRST [	JSR SAVSPC
		JRST @DOSAVP
		JRST @DOSAVP]
	JSR SAVSPC
	JRST @DOSAVP
	SETOM SWHCHS			;D IS AT END
	JSR SVREST
	JRST @DOSAVP
	MOVE T,[DPCNAM,,SSSNAM]
	BLT T,SSSPPN
	AOS DOSAVP
	JRST @DOSAVP
>;NOONE

.STRTN:	JSR UPNAME
	JRST .STRT

CONTLC:	JSR UPNAME
	JSR LINIT
	JRST .CONT			;OTHER HALF WILL COME IN WHEN NEEDED

UPNAME:	0
	MOVEM 0,SSSNAM			;FILENAME HERE FROM RUN COMMAND
	HLLZM 1,SSSEXT
	MOVEM 4,SSSPPN
	MOVEI T,.STRT
	HRRM T,.JBSA			;NOW START HERE
	JRST @UPNAME

;LAYOUT INITIALIZATION CODE
LINIT:	0
LIB,<	MOVEI T,LAYBEG
	MOVEM T,DBAND+DLOC
	MOVEM T,PCBAND+DLOC
	ADDI T,=76*2000
	MOVEM T,D2BAND+DLOC
	MOVEM T,PC2BAND+DLOC
	MOVEI T,4
	MOVEI TT,PC2BAND
LIBLOP:	MOVNM T,BAND(TT)
	SUBI TT,BAND2
	SOJG T,LIBLOP
	UFBCLR			;RELEASE ALL BANDS
>;LIB
TWO,<	SETZM DNUM
	SETZM PCNUM
	SETZ T,
	SETUWP T,		;MAKE SURE CURRENT ONE ISN'T WRITE PROTECTED
	JFCL
>;TWO
ONE,<
MD,<
	MOVE A,[LAY1S,,LAYVEC]	;Save dispatch for D side
	BLT A,LAYVEC+LLAYVEC-1
	SETZM SWHICH
>;MD
>;ONE
	JRST @LINIT
;GETD, GETPC
ONE,<
GETD:	SKIPN SWHICH
	 POPJ P,		;ALREADY IN D
	MOVE A,[LAYVEC,,LAYBEG]	;No, restore its xfer vector
	BLT A,LAYBEG+LLAYVEC-1
	SETZM SWHICH
DPCRET:	EXCH P,LAYPDL
	EXCH 0,LAYBIT
	EXCH M,LAYM
	JUMPE P,.STRTL
	PUSHJ P,SCRSET		;display update
	JRST .BLCHK

GETPC:	SKIPE SWHICH
	 POPJ P,
	MOVE A,[LAY2S,,LAYBEG]
	BLT A,LAYBEG+LLAYVEC-1
	SETOM SWHICH
	JRST DPCRET

DOSAVD:
DOSAVP:	0
	JRST ERRET

>;ONE

NOONE,<
GETD:	JSR SAVSD
	 POPJ P,		;Already in D
	JRST DPCRET

GETPC:	JSR SAVSPC
	 POPJ P,
DPCRET:	EXCH P,LAYPDL
	EXCH 0,LAYBIT
	EXCH M,LAYM
	JUMPE P,.STRTL
	PUSHJ P,SCRSET		;display update
	JRST .BLCHK

SAVSD:	0
	JSR RELPC
	JSR %GETD
	CAIA
	JRST [	AOS SAVSD
		JRST @SAVSD]
	OUTSTR[ASCIZ/CAN'T GET D PART, WILL TRY PC PART!
/]
	JSR %GETPC
	CAIA
	JRST @SAVSD
	OUTSTR[ASCIZ/CAN'T GET EITHER, I DIE NOW
/]
	HALT SAVSD+1

SAVSPC:	0
	JSR RELD		;Release D half
	JSR %GETPC		;Get PC half
	CAIA
	 JRST [	AOS SAVSPC
		JRST @SAVSPC]
	OUTSTR[ASCIZ/CAN'T GET PC PART, WILL TRY D PART!
/]
	JSR %GETD
	CAIA
	 JRST @SAVSPC
	OUTSTR[ASCIZ/CAN'T GET EITHER, I DIE NOW
/]
	HALT SAVSPC+1


;;Release D half
RELD:	0
LIB,<	MOVEI TT,DBAND		;START HERE
	JSR %PUTLIB
>;LIB
TWO,<	SETZ T,
	SEGNUM T,
	MOVEM T,DNUM
	DETSEG
>;TWO
	JRST @RELD

;;Release PC half
RELPC:	0
LIB,<	MOVEI TT,PCBAND
	JSR %PUTLIB
>;LIB
TWO,<	SETZ T,
	SEGNUM T,
	MOVEM T,PCNUM
	DETSEG
>;TWO
	JRST @RELPC

;;Get D half
%GETD:	0
LIB,<	MOVEI TT,DBAND
	JSR %GETLIB
	JRST GETD1		;NOT IN YET
	JRST GETDX		;WAS IN, BUT LOST
>;LIB
TWO,<	SKIPN T,DNUM
	JRST GETD1
	ATTSEG T,
	JRST GETDX
>;TWO
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	AOS %GETD
	JRST @%GETD

GETDX:	OUTSTR[ASCIZ/REINITIALIZING "D" PART FROM DMP FILE!
/]
LIB,<	MOVM T,DBAND
	MOVNM T,DBAND
	MOVM T,D2BAND
	MOVNM T,D2BAND
>;LIB
TWO,<	SETZM DNUM
>;TWO
	SETZM LAYPDL
GETD1:	SETZ T,			;TELL HIM WE WANT D PART
	JSR GETDPC
	CAIA
	AOS %GETD
	JRST @%GETD

%GETPC:	0
LIB,<	MOVEI TT,PCBAND
	JSR %GETLIB
	JRST GETPC1
	JRST GETPCX
>;LIB
TWO,<	SKIPN T,PCNUM
	JRST GETPC1
	ATTSEG T,
	JRST GETPCX
>;TWO
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	AOS %GETPC
	JRST @%GETPC

GETPCX:	OUTSTR[ASCIZ/REINITIALIZING "PC" PART FROM DMP FILE!
/]
LIB,<	MOVM T,PCBAND
	MOVNM T,PCBAND
	MOVM T,PC2BAND
	MOVNM T,PC2BAND
>;LIB
TWO,<	SETZM PCNUM
>;TWO
	SETZM LAYPDL
GETPC1:	SETO T,				;TELL HIM WE WANT PC PART
	JSR GETDPC
	CAIA
	AOS %GETPC
	JRST @%GETPC
>;NOONE
;SUBRS FOR LIBRASCOPE GETD, GETPC
LIB,<
%PUTLIB:0
	MOVE T,.JBREL
	SUBI T,LAYBEG-1
	CAILE T,=76*2000
	MOVEI T,=76*2000
	JSR ONEBND
	MOVE T,.JBREL
	SUBI T,LAYBEG-1+=76*2000
	JUMPLE T,@%PUTLIB
	ADDI TT,BAND2
	JSR ONEBND
	JRST @%PUTLIB

ONEBND:	0
	MOVEM T,LENGTH(TT)
	SKIPL T,BAND(TT)
	JRST GOTDBN
NODBN:	MOVM T,BAND(TT)
	UFBGIV T,
	MOVM T,BAND(TT)
	UFBGET T,
	JSR NOBAND
	MOVMS T,BAND(TT)
GOTDBN:	FBWRT T,DLOC(TT)
	JRST NODBN
	FBWAIT
	UFBERR
	JRST NODBN
	JRST @ONEBND		;DONE!

NOBAND:	0
	OUTSTR[ASCIZ/NO FAST BANDS, CONTINUE TO TRY AGAIN
/]
	SOS NOBAND
	SOS NOBAND
	HALT @NOBAND

%GETLIB:0
	SKIPGE T,BAND(TT)
	JRST @%GETLIB
	AOS %GETLIB
	JSR GETBND
	JRST @%GETLIB
	SKIPG LENGTH+BAND2(TT)
	JRST GETLDN
	ADDI TT,BAND2
	MOVE T,BAND(TT)
	JSR GETBND
	JRST @%GETLIB
GETLDN:	AOS %GETLIB
	JRST @%GETLIB

GETBND:	0
%GETL1:	MOVE TTT,LENGTH(TT)
	ADD TTT,DLOC(TT)
	SUBI TTT,1
	CORE TTT,
	JRST [	JSR NOCORE
		JRST %GETL1]
	FBREAD T,DLOC(TT)
	JRST [	OUTSTR[ASCIZ/FAST-BAND READ ERROR!
/]
		JRST @GETBND]
	FBWAIT
	UFBERR
	JRST @GETBND
	AOS GETBND
	JRST @GETBND
>;LIB
;GET OTHER PART FROM FILE
NOONE,<
GETDPC:	0
	CAME T,SWHICH			;DO WE WANT THE ONE AT THE END?
	TDZA T,T			;NO, GET FRONT ONE
	SETO T,				;YES, GET END ONE
	MOVEM T,SWHCHA
	MOVE T,[SSSNAM,,FILNAM]
	BLT T,FILPPN
	INIT IOLAY,17
	'DSK   '
	0
	JRST NOFIL
PGFIL:	OUTSTR[ASCIZ/GETTING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP IOLAY,FILNAM
	JRST [	OUTSTR[ASCIZ/, LOOKUP FAILED, ANOTHER /]
		MOVEM P,TPDL
		MOVE P,[IOWD TPDLLN,TPDL]
		PUSH P,(P)
		PUSHJ P,PUSHIT	;SAVE EVERYONE
		PUSHJ P,DMPNAM
		SETZM FILNAM
		PUSHJ P,POPIT
		POP P,P
		SKIPN FILNAM
		JRST NOFIL
		JRST PGFIL]
DEC,<	JSR IOLAY,LOOKCK	>;DETERMINE REAL PPN
	SKIPE SWHCHA		;WHICH PART DO WE WANT
	JRST ENDP
	MTAPE IOLAY,RDOFF	;GET OFFSET
	MOVN T,OFFSET		;BACKWARD USET
	USETI IOLAY,1(T)
	MOVE T,OFFSET
	LSH T,7
LIB,<	MOVEI TT,LAY1S
	ANDI TT,177
>;LIB
TWO,<	SETZ TT,	>
	JRST FRONTP

ENDP:
TWO,<	MOVE T,[-200,,TJOBDA-1]
	MOVEI TT,0
	INPUT IOLAY,T
	MOVE T,TJOBDA-.JBSAV-1+HILOC	;GET STARTING FILE ADDRESS OF UPPER
	MOVE TT,T
	LSH T,-7
	USETI IOLAY,1(T)
>;TWO
LIB,<	MOVEI T,LAY1S-.JBSAV-1+200
	LSH T,-7		;MAKE RECORD NUMBER
	USETI IOLAY,(T)
>;LIB
	HLRO T,FILPPN
	MOVN T,T		;POS LENGTH OF FILE
LIB,<	MOVEI T,LAY1S-.JBSAV-1+200	>
	ANDCMI TT,177		;GET FIRST WORD WE WILL READ
FRONTP:	SUBB T,TT		;NUMBER OF WORDS TO READ!
LIB,<	ADDI TT,LAYBEG-1		;THIS IS HOW MUCH ROOM WE NEED
	CORE TT,
>;LIB
TWO,<	ADDI TT,400000-1
	CORE2 TT,
>;TWO
	JRST NOFIL
	MOVN T,T
	MOVS T,T
LIB,<	HRRI T,LAYBEG-1	>
TWO,<	HRRI T,400000-1	>
	SETZ TT,
	IN IOLAY,T
	CAIA
	JRST NOFIL
LIB,<	SKIPN SWHCHA
	JRST GOTDPC
	MOVEI T,LAYBEG-74
	ANDI T,177		;HOW MUCH TO BLT DOWN
	JUMPE T,GOTDPC
	MOVE TT,.JBREL
	SUB TT,T
	MOVS T,T
	ADD T,[LAYBEG,,LAYBEG]
	BLT T,(TT)
>;LIB
GOTDPC:	AOS GETDPC
	OUTSTR[ASCIZ/
/]
LIB,<	MOVE T,LAYSYM
	MOVEM T,.JBSYM
>;LIB
	RELEASE IOLAY,
	JRST @GETDPC

NOFIL:	OUTSTR[ASCIZ/COULDN'T GET DISK FILE!
/]
	RELEASE IOLAY,
	JRST @GETDPC
>;NOONE
;SUBRS TO SAVE LAYOUT VERSIONS!

NOONE,<
;;Save 2nd half of layout program in file leader
ISAVE:	0
	MOVE T,ISAVE
	MOVEM T,SVFRST
LIB,<	MOVEI T,LAY2S-1		;save second half
	MOVEM T,IWD
	SKIPN T,.JBSYM
	JRST [	MOVNI TT,LAY2E
		JRST NOSYMS]
	HLRE TT,T
	SUBI TT,(T)
NOSYMS:	TRZ TT,177		;ROUND UP TO MULTIPLE OF 200 WORDS SO GET WON'T LOSE
	ADDI TT,LAY2S
	HRLM TT,IWD
>;LIB
TWO,<	MOVE TT,[LAY2S-LAY2E,,LAY2S-1]
	MOVEM TT,IWD
>;TWO
	JRST ISAVE1

;;Save 1st half of layout prgm in file leader
SVFRST:	0
	MOVEI T,LAYBEG-1
	MOVEM T,IWD
LIB,<	MOVN T,.JBREL	>
TWO,<	HRRZ T,.JBHRL
	MOVN T,T
>;TWO
	ADDI T,LAYBEG-1
	HRLM T,IWD
ISAVE1:	OUTSTR[ASCIZ/SAVING /]
	MOVEI A,DPCNAM
	JSR FPRINT
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/, CAN'T GET DISK!
/]
		HALT SVFRST+1]
	MOVE T,[DPCNAM,,FILNAM]
	BLT T,FILPPN
	ENTER DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED, YOU LOSE!
/]
		JRST SVQTF]
	MOVE T,IWD
	SETZ TT,
	OUT DAT,T		;POOT OUT FIRST PART
	JRST OUTOK
	OUTSTR[ASCIZ/, OUTPUT ERROR!
/]
SVQTF:	RELEASE DAT,3
	JRST @SVFRST

OUTOK:	UGETF DAT,NEWOFF	;GET EOF+1
	MTAPE DAT,WRTOFF	;SET IT IN FILE
	JRST [	OUTSTR[ASCIZ/, MTAPE TO SET RECORD OFFSET FAILED!
/]
		JRST SVQTF]
	USETO DAT,1		;GET TO NEW END(BEGINNING)
	AOS SVFRST
	JRST @SVFRST		;SO FAR SO GOOD
>;LAY
>;NOONE
HINAME__134			;UPPER SEGMENT NAME
HILOC__135			;LOC OF UPPER SEGMENT AFTER INPUT FROM DMP FILE

;;Create TOPS-10 format SAVE file of core image (other half
;; may be in leader part of file)

SVREST:	0
NOLAY,<
	OUTSTR[ASCIZ/SAVING /]
	MOVEI A,DPCNAM
	JSR FPRINT
	INIT DAT,17
	'DSK   '
	0
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		HALT SVREST+1]
	MOVE T,[DPCNAM,,FILNAM]
	BLT T,FILPPN
	ENTER DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/, ENTER FAILED, YOU LOSE!
/]
		JRST SVQUIT]
>;NOLAY
LAY,<	MOVE T,SWHCHS
	EXCH T,SWHICH
	MOVEM T,SWHCHS
>;LAY
	MOVE T,[.JBSAV+1,,TJOBDA]
	BLT T,TJOBDA+177	;SETUP A PSUEDO JOB DATA AREA
	MOVE T,STRTLC
	HRRM T,TJOBDA-.JBSAV-1+.JBSA	;STORE PLACE FOR IT TO START
	MOVE T,.JB41
	MOVEM T,TJOBDA-.JBSAV-1+.JBS41
	SETZM TJOBDA-.JBSAV-1+.JBCOR	;ALWAYS USE SIZE OF FILE
	SETZM TJOBDA-.JBSAV-1+HINAME	;ALWAYS 0 HINAME (EVEN FOR SEGMENTS)
NOTWO,<	SETZM TJOBDA-.JBSAV-1+HILOC
>;NOTWO
TWO,<	MOVE T,.JBREL
	SUBI T,.JBSAV+1
	IORI T,177
	ADDI T,.JBSAV+2		;THIS IS WHAT GET WANTS TO SEE
	MOVEM T,TJOBDA-.JBSAV-1+HILOC	;NO PROT OF ANY KIND
>;TWO
	MOVE T,[IOWD 200,TJOBDA]
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR FOR JOB DATA AREA!
/]
		JRST SVQUIT]
	MOVEI T,.JBSAV+1+200-1		;START OUTPUT HERE
	MOVN TT,.JBREL
	ADD TT,T
	HRL T,TT
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR ON LOW CORE WRITE!
/]
		JRST SVQUIT]
TWO,<	HRRZ TT,.JBHRL
	MOVN TT,TT
	MOVEI T,400000-1
	ADD TT,T
	HRL T,TT
	SETZ TT,
	OUT DAT,T
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR ON HIGH CORE WRITE!
/]
		JRST SVQUIT]
>;TWO
	RELEASE DAT,
	AOS SVREST
	JRST @SVREST

SVQUIT:	RELEASE DAT,3			;FLUSH FILE
LAY,<	MOVE T,SWHCHS
	MOVEM T,SWHICH
>;LAY
	JRST @SVREST
;DMP FILENAME SCANNER
LAY,<
DMPNAM:	MOVSI T,'DMP'
	MOVEM T,FILEXT
	SETZB T,FILEXT+1	;CLEAR THIS WORD
	DSKPPN T,		;HIS OWN PPN
	MOVEM T,FILPPN
	OUTSTR [ASCIZ/DMP FILENAME?/]
NOITS,<	PUSHJ P,GETWRD	>	;SCAN FILENAME
ITS,<	PUSHJ P,QETNAM	>	;SCAN FILENAME
	CAIN C,12
	JUMPE T,CPOPJ		;LET HIM OUT IF HE TYPES NOTHING
NOITS,<
	MOVEM T,FILNAM		;SAVE FILENAME
	CAIN C,"["		;ANY EXTENSION?
	JRST NOEXT		;NO
	CAIN C,12
	JRST NOEXT		;NO
	CAIE C,"."
	JRST [	ILGLNM:	OUTSTR[ASCIZ/INPUT ERROR!
/]
			CLRBFI
			JRST DMPNAM]
	PUSHJ P,GETWRD		;SCAN EXTENSION
	HLLZM T,FILEXT		;SAVE IT.
NOEXT:	CAIN C,12		;HERE TO SCAN PPN
	JRST CPOPJ1		;LEAVE NOW
	CAIE C,"["
	JRST ILGLNM		;MUST BE [
	PUSHJ P,GETWRD		;SCAN P.
	JUMPE T,ILGLNM
	PUSHJ P,RJUST
	HRLZM T,FILPPN		;AND SAVE
	CAIE C,","		;BETTER BE COMMA
	JRST NOPRG
	PUSHJ P,GETWRD		;SCAN PN.
	JUMPE T,ILGLNM
	PUSHJ P,RJUST
	HRRM T,FILPPN		;AND SAVE
NOPRG:	SETZ T,
	CAIN C,"]"		;BETTER END WITH THIS
	PUSHJ P,GETWRD		;MAKE SURE HE DIDN'T TYPE TO MUCH
	JUMPN T,ILGLNM		;LOSE IF HE DID
	CAIE C,12
	JRST ILGLNM		;DIDN'T END WITH LF
	JRST CPOPJ1
>;NOITS
ITS,<
	CAIE C,";"
	JRST QOLST1
	MOVEM T,FILPPN
	PUSHJ P,QETNAM
	JUMPE T,CPOPJ	;STILL NOT REASONABLE
QOLST1:	CAIE C,40
	CAIN C,12
	SKIPA
	JRST [	ILGLNM:	OUTSTR[ASCIZ/INPUT ERROR!
/]
			CLRBFI
			JRST DMPNAM]
	MOVEM T,FILNAM
	CAIN C,12
	JRST CPOPJ1	;DONE
	PUSHJ P,QETNAM	;GET SECOND FILE NAME
	CAIE C,12
	JRST ILGLNM	;EXTRA GARBAGE AT END
	JUMPE T,ILGLNM
	MOVEM T,FILEXT
	JRST CPOPJ1
>;ITS

RJUST:	TRZ T,-1		;THREE LETTERS ONLY
	CAIA
	LSH T,-6
	TRNN T,77		;RIGHT JUSTIFIED YET?
	JRST .-2		;NO
	POPJ P,
	
NOITS,<
GETWRD:	SETZ T,			;WORD WILL ACCUMULATE HERE
	MOVE A,[POINT 6,T]	;BYTE POINTER TO DEPOSIT CHARACTERS
CHRGET:	PUSHJ P,TTYIN		;READ A CHAR
ISCHRX:	CAIE C,15		;IGNORE LF'S
	CAIN C,40		;AND SPACES
	JRST CHRGET
	CAIL C,"0"		;NUMBERS ARE LEGAL
	CAILE C,"9"
	CAIA
	JRST CHROK
	CAILE C,"z"
	POPJ P,			;BREAK CHAR.
	CAIL C,"a"
	SUBI C,40		;CHANGE LOWER CASE TO UPPER
	CAIL C,"A"		;NOW ONLY UPPER CASE LETTERS ARE LEGAL
	CAILE C,"Z"
	POPJ P,			;BREAK
CHROK:	SUBI C,40		;NO, MAKE IT SIXBIT
	TLNE A,770000		;END OF WORD?
	IDPB C,A		;STORE
	JRST CHRGET
>;NOITS

;ITS NAME SCANNER
ITS,<
QETNAM:	SETZ T,			;WORD WILL ACCUMULATE HERE
	MOVE A,[POINT 6,T]	;BYTE POINTER TO DEPOSIT CHARACTERS
QETNM1:	PUSHJ P,TTYIN		;READ A CHAR
	CAIE C,15		;IGNORE LF'S
	CAIN C,40		;AND SPACES
	JRST QETNM1
	SKIPA
QETNM2:	PUSHJ P,TTYIN
	CAIN C,15
	JRST QETNM2
	CAIL C,"a"
	CAILE C,"z"
	CAIA
	SUBI C,40		;LOWERCASE
	CAILE C,40		;BREAK ON SPACE
	CAILE C,"_"
	POPJ P,			;NOT SIXBIT CHARACTER
	CAIE C,";"
	CAIN C,":"
	POPJ P,
	SUBI C,40		;NO, MAKE IT SIXBIT
	TLNE A,770000		;END OF WORD?
	IDPB C,A		;STORE
	JRST QETNM2
>;ITS

TTYIN:	INCHWL C
	ANDI C,177
	CAIN C,15
	JRST TTYIN
	POPJ P,
>;LAY
>;NOIII
>;NODEC
;PUSHIT, POPIT
STORAGE(IMPURE)
FPRINT:	0
ITS,<	MOVE TTT,3(A)
	JSP T,.SIXP
	OUTCHR[";"]
>;ITS
	MOVE TTT,(A)
	JSP T,.SIXP
NOITS,<	OUTCHR["."]	>
ITS,<	OUTCHR[" "]	>
	HLLZ TTT,1(A)
	JSP T,.SIXP
NOITS,<
DEC,<	SKIPN 3(A)
	JRST @FPRINT
FPPPN:
>;DEC
	OUTCHR["["]
NOCMU,<
	HLLZ TTT,3(A)
	JSP T,.SIXPL
	OUTCHR[","]
	HRLZ TTT,3(A)
	JSP T,.SIXPL
>;NOCMU
CMU,<
	SKIPN TTT,3(A)
	DSKPPN TTT,
	MOVE T,[TTT,,PPNBUF]
	DECCMU T,
	JRST [	JSP T,.SIXPL	;IF DECCMU BLETCHES, SIXPRINT IT
		JRST PPNDON ]
	OUTSTR PPNBUF
PPNDON:
>;CMU
	OUTCHR ["]"]
>;NOITS
	JRST @FPRINT

LOOKRR:	RELEASE DAT,
LOOKER:	HRRZ T,1(A)
	OUTSTR[ASCIZ/, /]
	CAIL T,LOKLEN
	MOVEI T,ULSERR
	OUTSTR @LOKETB(T)
	OUTSTR[ASCIZ/.
/]
NOLAY,<	JRST LERRET	>
LAY,<	JRST .LERRET	>

LOKETB:	[ASCIZ/FILE NOT FOUND/]
	[ASCIZ/ILLEGAL PPN/]
	[ASCIZ/PROTECTION FAILURE/]
	[ASCIZ/FILE IN USE/]
ULSERR__.-LOKETB
	[ASCIZ/UNKNOWN LOOKUP STATUS/]
	[ASCIZ/DATA TRANSMISSION ERROR/]
LOKLEN__.-LOKETB

DEC,<
LOOKCK:	0
	JUMPE T,ANYPPN
	MOVEM T,3(A)		;SAVE AWAY HERE FOR NOW
	MOVE TTT,[3,,T]
	MOVE T,LOOKCK
	LDB T,[POINT 4,-1(T),12]	;GET CHANNEL #
	PATH TTT,
	DSKPPN TTT,		;PATH LOSES, GET USER PPN
	CAMN TTT,3(A)		;IS THIS FILE'S ORIGIN DIFFERENT THAN REQUESTED?
	JRST @LOOKCK		;NO, WIN
	SOS LOOKCK
	SOS LOOKCK
	HLLZS 1(A)		;MAKE IT FILE NOT FOUND
	JRST @LOOKCK		;THIS HAD BETTER RETURN TO LOOKUP ERROR FOR LOOKUP UUO

ANYPPN:	MOVE TTT,[3,,T]
	MOVE T,LOOKCK
	LDB T,[POINT 4,-1(T),12]	;GET CHANNEL #
	PATH TTT,
	DSKPPN TTT,		;PATH LOSES, GET USER PPN
	MOVEM TTT,3(A)		;AND STORE
	MOVE T,LOOKCK
	MOVEM T,FPRINT		;TELL HIM WHERE TO GO
	JRST FPPPN		;NOW PRINT PPN AND RETURN
>;DEC

.SIXPL:
NODEC,<
NOIII,<
	TLNN TTT,777700
	LSH TTT,14
	TLNN TTT,770000
	LSH TTT,6
>;NOIII
>;NODEC
IFN DECSW!IIISW,<
	MOVE	TT,TTT
	JUMPE	TT,(T)
	TRO	TT,400000
	ROT	TT,3
	TRNN	TT,7
	JRST	.-2
.SIXP2:	TRZ	TT,777770
	ADDI	TT,"0"
	OUTCHR TT
	ROT	TT,3
	TLNE	TT,-1
	JRST	.SIXP2
	JRST	(T)
>;IFN DECSW!IIISW

.SIXP:	JUMPE TTT,(T)
	SETZ TT,
	LSHC TT,6
	ADDI TT,40
	OUTCHR TT
	JRST .SIXP

PGP,<
POPALL:	SKIPE	$VAL	;ANY ERROR OCCURED?
	PUSHJ	P,PGPERR;YES, PRINT MESSAGE
	POP	P,0	;GET RETURN ADR
	EXCH	0,-17(P);RESTORE 0, SAVE RETURN ADR
	PUSHJ	P,POPIT	;RESTORE ACS 2-17
	MOVEI	1,INTBLK;ENABLE CTRL C INTERCEPT
	MOVEM	1,.JBINT
	POP	P,1	;RESTORE 1
	POPJ	P,

PUSHAL:	SETZM	.JBINT	;DISABLE CTRL C INTERCEPT DURING PGP CODE
	SETZM	$VAL	;CLEAR ERROR ACCUMULATION
	EXCH	0,(P)	;SAVE 0 AND GET RETURN
	PUSH	P,1	;SAVE 1
	PUSH	P,0	;SAVE RETURN ADR
	MOVE	0,-2(P)	;RESTORE 0
>;PGP
;ONLY SAVE AC'S 2-17
PUSHIT:EXCH 2,(P)	;SAVE 2 AND GET RETURN.
	MOVEM 2,16(P)	;GEE, THIS WAY WE RETURN WITH A POPJ
	MOVEI 2,1(P)
	HRLI 2,3
	BLT 2,15(P)
	MOVE 2,(P)	;RESTORE 2
	ADD P,[XWD 16,16]
	POPJ P,		;RETURN TO SENDER

;ONLY RESTORES AC'S 2-17
POPIT:	MOVSI 17,-15(P)
	HRRI 17,3
	BLT 17,17		;FIXES P
	MOVE 2,16(P)
	EXCH 2,(P)
	POPJ P,
STORAGE(IMPURE)
XLIST
VAR
TWO,<STORAGE(LOW)>
NOTWO,<STORAGE(PURE)>
LIT
LIST
