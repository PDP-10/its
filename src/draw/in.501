;<DRAW>IN.FAI.130, 20-NOV-75 14:34:13, EDIT BY HELLIWELL
VERSION(IN,16)

COMMENT 

The drawing file has roughly this structure:
	-version #, nomenclature, board type
	-names of types needed from libraries in this drawing
	-names of library files
	-definitions of local types
	-definitions of macros
	-body instances
	-points
	-sets
	-random info

An outline of reading a .DRW file:

DREAD:	open file, initialize ID's, etc.
	call RDFILE
	make set ?
	call INIT macro
	end;

RDFILE:	start as toplevel file (not a library)
	call TYPIN
	read body's
	read points
	read sets
	read ...
	end;

LIBRED:		print "LIBRARY <file-name>"
		open file
		add name to list of libraries read in
TYPIN:		get version #, nomen, board type
 (DOLBTY:)	if toplevel, read list of used types
		  else, skip them (not used from library)
 (GETLIB:)	read list of libraries used, possibly
			mapping the names
 (RDTYP:)	read local types (maybe do replacement)
		if any libraries,
		   save current file name, aos depth
		   for each library used,
			check if library is already in (rare?)
			check if is in, but we need more bodies
			call LIBRED
		   restore file name, sos depth, reread to macro defs
		get macros
		end;



;INIT DISK, SET FLAGS, CHECK FOR VIRGIN, ETC.
MD,<
DREADR:	TLO M,TYPNLY!TYPREP	;TYPES ONLY AND ALWAYS REPLACE (SILENTLY)!
	JRST DREAD1
>;MD
DREADT:	TLOA M,TYPNLY	;TYPES ONLY
DREAD:	TLZ M,TYPNLY
	TLZ M,TYPREP		;DON'T REPLACE AUTOMATICALLY!
DREAD1:	MOVEM P,PERRSAV		;FOR ERROR RETURNS
	MOVSI T,EXTFIL
	PUSHJ P,SETNAM
	 POPJ P,		;LET HIM OUT THIS WAY
	SETZM WIRDAT		;MAKE SURE WE READ FILE
WIRENT:	INIT DAT,10
	 'DSK   '
	 IOHD
	 JRST [	RELEASE DAT,
		OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF		;USE COMPILED IN BUFFER
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
	MOVE T,FILPPN
	LOOKUP DAT,FILNAM
	 JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
NODEC,<	MOVEM T,FILPPN	>
	LDB T,[POINT 11,FILDAT,23]
	HRL T,FILDAT
	LDB TT,[POINT 3,FILEXT,20]
	DPB TT,[POINT 6,T,5]
	CAMGE T,WIRDAT
	JRST [	OUTSTR[ASCIZ/, OLDER THAN WIRE LIST FILE.
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
;PATCH TO FIX OLD TEXT OFFSETS WHICH ARE WRONG
	SKIPN LSTNAM		;SKIP ALL THIS IF ALREADY HAVE DEFAULT NAME
	TLNE M,TYPNLY		;IF TYPES ONLY, DON'T UPDATE NAMES
	 JRST XNAME
	MOVE T,FILNAM
	MOVEM T,LSTNAM		;REMEMBER LAST NAME
MD,<	MOVEM T,DRWNAM	>	;REMEMBER FOR PLOTS ALSO
	HLLZ T,FILEXT
	MOVEM T,LSTEXT
MD,<	MOVEM T,DRWEXT	>
	MOVE D,FILPPN
	MOVEM D,LSTPPN
MD,<	MOVEM D,DRWPPN
	LDB T,[POINT 11,FILDAT,23]
	HRL T,FILDAT
	LDB TT,[POINT 3,FILEXT,20]
	DPB TT,[POINT 6,T,5]
	MOVEM T,DRWDAT		;REMEMBER DATE LAST WRITTEN OF DRW FILE
>;MD
	PUSHJ P,FILEUP		;AND UPDATE DISPLAY
XNAME:	SETZM NEWBOD		;LIST OF NEW BODY POINTERS.
	SETZM HASHP
MPC,<	SETZM MXPADN		;CLEAR MAXIMUM PAD # SEEN	>
	MOVE A,[HASHP,,HASHP+1]	;CLEAR OUT HASH TABLES
	BLT A,HASHB+LHASHB
	MOVE A,[HASHP(TT)]
	MOVEM A,PHASHP
MPC,<	MOVE A,[HASHP2(TT)]
	MOVEM A,PHASH2
>;MPC
	MOVE T,BID
	MOVEM T,OLDBID
	MOVEM T,MAXBID
	MOVE T,PID
	MOVEM T,OLDPID
	MOVEM T,MAXPID
	TRO VIRGIN		;ASSUME VIRGIN
MPC,<	SKIPN PONPN2	>;MPC
	SKIPE PONPNT
	TRZ VIRGIN		;NOT VIRGIN
	SKIPE DBODPN
	TRZ VIRGIN
	TRO MAKSET
MD,<
	TLNN M,TYPNLY		;NOW, IF TYPNLY OR
>;MD
	TRNE VIRGIN		;A VIRGIN
	JRST [	TRZ MAKSET	;NO SET GETS MADE
		JRST NOVSET]
	SETZM LSTNAM		;FORGET NAME IF NOT VIRGIN!
MD,<	DATE T,			;SET DATE AND TIME TO CURRENT
	HRLZM T,DRWDAT
	MSTIME T,
	IDIVI T,=1000*=60	;TO MINUTES
	HRRM T,DRWDAT
	SETZB T,DRWNAM
	MOVSI T,EXTFIL
	MOVEM T,DRWEXT
	SETZ T,
NODEC,<	DSKPPN T,	>
DEC,<	GETPPN T,	>
	MOVEM T,DRWPPN		;INIT PPN
>;MD
LAY,<	SETZM SAVNAM	>
	PUSHJ P,FILEUP		;AND UPDATE THAT
	TRNN MAKSET		;SHALL WE MAKE A SET?
	 JRST NOVSET		;NO, NO SET
	SETZM DX1
	SETZM DY1
	SETZM DX3
	SETZM DY3
NOVSET:	PUSH P,CURSE
	PUSH P,MODE
MPC,<
	PUSH P,SID
	TLNE SID,FRONT		;LET'S START ON FRONT
	JRST ISFRNT
	FSWITCH
ISFRNT:
>;MPC
	PUSHJ P,RDFILE		;READ FILE!
	SKIPE B,NEWBOD		;RETURN FREE STORAGE FROM NEWBOD LIST(IF ANY)
	 PUSHJ P,PUTFS
	SETZM NEWBOD
MPC,<
	POP P,T
	EQV T,SID
	JUMPL T,ISRITE		;ARE WE ON RIGHT SIDE?
	FSWITCH
ISRITE:
>;MPC
;READ CARD, FIX SET, FIX ID'S, FINISH UP
	TRO MCHG!NEEDCL
	TRZ INLIN!INMOV!STBOX	;MAKE SURE THESE ARE OFF
	POP P,MODE
	POP P,CURSE		;PUT CURSOR BACK WHERE IT WAS
	TRNE MAKSET		;DID WE TRY TO MAKE A SET?
	SKIPN DY3		;YES, IS THERE ONE?
	 JRST NOVST1
	GETFS(T)
	HRL TT,DY3
	HRR TT,SETPNT
	MOVEM TT,(T)
	HRRZM T,SETPNT
	MOVE TT,DX1
	IDIV TT,DX3
MPC,<	ASH TT,-1
	IDIV TT,STPSIZ
	IMUL TT,STPSIZ
	ASH TT,1
>;MPC
MD,<	TRZ TT,1	>
	HRLM TT,1(T)
	MOVE TT,DY1
	IDIV TT,DX3
MPC,<	ASH TT,-1
	IDIV TT,STPSIZ
	IMUL TT,STPSIZ
	ASH TT,1
>;MPC
MD,<	TRZ TT,1	>
	HRRM TT,1(T)
	PUSH P,T
	MOVEI T,SETM
	PUSHJ P,CHNGMD		;GO TO SET MOVING MODE
	POP P,T
	PUSHJ P,SCLOSP		;FIND LAST POINTER, SET CLOSES, MOVE TO CENTER
	PUSHJ P,DOSMOV
	OUTSTR[ASCIZ/YOUR NEW FILE IS NOW A SET
AND YOU ARE MOVING IT!
/]
NOVST1:
MD,<	SKIPE B,UTLIST
	PUSHJ P,RELUTL		;RELEASE TYPE USE LIST
>;MD
	SKIPN RDVER		;**RDVER
	 JRST ERCHK		;DO END CHECK
	MOVSI T,-LHASHP
NOVST3:	SKIPN A,HASHP(T)
	 JRST NOVST2
	HLRZ B,A
	HLLI A,
	EXCH A,PONPNT
	HRRM A,(B)
NOVST2:	AOBJN T,NOVST3
MPC,<	MOVSI T,-LHASHP
NOVST5:	SKIPN A,HASHP2(T)
	 JRST NOVST4
	HLRZ B,A
	HLLI A,
	EXCH A,PONPN2
	HRRM A,(B)
NOVST4:	AOBJN T,NOVST5
>;MPC
	TRNN VIRGIN		;IS THIS A VIRGIN
	 JRST NDOVIR		;NO, FIX NEWEST PIN ID'S
	MOVE T,MAXBID		;YES, SET MAX AS LAST ASSIGNED
	MOVEM T,BID
	MOVE T,MAXPID
	MOVEM T,PID
	JRST ERCHK

NDOVIR:	MOVE T,OLDBID
	MOVEM T,BID
	MOVE T,OLDPID
	MOVEM T,PID
	PUSHJ P,REEID		;REASSIGN ID'S
ERCHK:
MPC,<	PUSHJ P,CARDIO		;CHECK AND MAYBE READ CARD
	SKIPE CRDNAM		;DID WE GET A CARD?
	TLO M,CRDISP		;YES, DISPLAY IT!
	PUSHJ P,MXPADP		;PRINT MAX PAD # IF BIG ENOUGH
>;MPC
	RELEASE DAT,		;DONE WITH INPUT FILE
DEC,<	MOVE T,RDVER	;**RDVER
	TLNN M,TYPNLY		;SKIP IF ONLY READ TYPES
	CAIL T,14
	 JRST OFFOK
	TLNN M,DSKACT!MACACT
	 OUTSTR[ASCIZ/YOU SHOULD PROBABLY DO AN OFFALL!
/]
OFFOK:
>;DEC
	TRNN VIRGIN
	 POPJ P,
	TLNE NOINIT		;SUPPRESS CALL OF INIT MACRO?
	 JRST ERCHK		;YES
	TRO TFLG		;FLAG TO CALL ONLY IF JUST READ IN
	PUSHJ P,MACCAL		;NOTE WE ONLY INIT A VIRGIN
	ASCIZ/INIT/		;SETUP INIT MACRO FOR EXECUTION
	POPJ P,

MD,<
RELUTL:	HLRZ A,(B)
	PUSHJ P,PUTFS
	SKIPE B,A
	JRST RELUTL
	SETZM UTLIST
	POPJ P,
>;MD

;REEID - RE-ASSIGN ID'S

REEID:	SKIPE A,PONPNT
	PUSHJ P,REEPNT
MPC,<	SKIPE A,PONPN2
	PUSHJ P,REEPNT
>;
	SKIPN A,DBODPN
	POPJ P,
REEBOD:	FETCH(TT,A,BID)
	CAMG TT,OLDBID		;WAS THIS A NEW ONE?
	JRST NOREEB
	AOS TT,BID		;YES, ASSIGN NEW ID
	STORE(TT,A,BID)
NOREEB:	FETCH(A,A,BNXT)
	JUMPN A,REEBOD
	POPJ P,

REEPNT:	FETCH(TT,A,PBIT)	;MIGHT BE BPBIT
	TRNE TT,ISPIN		;PINS USE BODY, DON'T DO THEM HERE
	 JRST NOREEP
	FETCH(TT,A,PID)		;GET POINT ID
	CAMG TT,OLDPID		;NEW POINT?
	JRST NOREEP
	AOS TT,PID		;YES, GET NEW ID
	STORE(TT,A,PID)
NOREEP:	FETCH(A,A,PNXT)
	JUMPN A,REEPNT
	POPJ P,

MPC,<
MXPADQ:	MOVE T,MXPADN
	JRST MXPADR

MXPADP:	MOVE T,MXPADN
	CAIG T,STDMAX		;BIGGER THAN STANDARD MAX?
	POPJ P,			;NO
MXPADR:	OUTSTR[ASCIZ/MAXIMUM PAD TYPE IS /]
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,
>;MPC
;READ VERSION NUMBER, LIBRARY SUBRS
GETVER:	PUSHJ P,REDVER		;READ IO VERSION #
	CAIN TTT,IOVER		;SAME AS CURRENT
	POPJ P,
	OUTSTR[ASCIZ/READING OLD IO VERSION # /]
	MOVE T,TTT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,

REDVER:	PUSHJ P,WORDIN		;GET FIRST WORD OF FILE
	TLNN TTT,-1
	JUMPN TTT,[CAIG TTT,IOVER	;DO WE KNOW ABOUT IT?
		JRST NEWVER
		OUTSTR[ASCIZ/I DON'T KNOW ABOUT THIS IO VERSION #!
/]
		CAIL TTT,IOVER+10	;REASONABLE TO TRY OUR HIGHEST?
		JRST .+1		;NO
		MOVEI TTT,IOVER
		JRST NEWVER]
	AOS IOHD+2
	SOS IOHD+1		;OLD BACKUP TO THIS WORD
	SETZ TTT,		;AND USE IOVER=0
NEWVER:	MOVEM TTT,RDVER
MD,<	CAIN TTT,BRDIOV		;**RDVER
	POPJ P,
>;MD
	PUSHJ P,RDNOM
MD,<	PUSHJ P,RDBRD	>
	MOVE TTT,RDVER
	POPJ P,

SUBTTL READ LOCAL TYPES AND LIBRARY TYPES
;READ USED TYPE LIST, LIBRARY, AND LOCAL TYPES

TYPIN:	PUSHJ P,GETVER
MD,<	PUSHJ P,DOLBTY		;READ LIBRARY AND LOCAL TYPES
	TRNN FSTLIB		;At top level (reading drawing, not library)?
	 TDZA C,C		;NO, DON'T TURN ON MACRO BITS
>;MD				;ALWAYS SAVE IN PC
	 MOVSI C,MSAVE		;YES, PUT SAVE BIT ON SO IT WILL GO BACK OUT
	TLO C,MACTMP		;MARK AS JUST READ IN
	MOVE T,RDVER		;**RDVER
	CAILE T,13		;THESE DON'T HAVE MACROES IN THEM
	 JRST MACIN		;GET THEM
	POPJ P,

; POSSIBLY READ LIST OF USED TYPES

MD,<
DOLBTY:	MOVE T,RDVER		;**RDVER
	CAIGE T,3
	 JRST RDTYP		;VERSIONS 3 AND HIGHER HAVE LIBRARIES
	CAIGE T,13		;DO WE HAVE LIST OF LIB TYPE USED?
	 JRST FRCLIB		;NO, FORCE MERGING IF ALREADY USED
;The drawing file has a list of bodies actually needed from libraries.
	TRNE FSTLIB		;ARE WE AT TOP LEVEL (I.E. drawing)?
	 JRST RDLTYP		;YES, READ NAMES OF USED TYPES
	PUSHJ P,SKPSTR		;NO, JUST SKIP THEM
	 JRST GETLIB
	JRST .-2

;Read list of used types (that will actually appear in drawing)

RDLTYP:	SKIPE B,UTLIST
	PUSHJ P,RELUTL
	SETOM USEFLG		;FLAG USE LIST ACTIVE
RDLTY1:	PUSHJ P,RSTRZ
	 JRST GETLIB
	EXCH T,UTLIST
	HRLM T,@UTLIST
;Now check if that type is already in some library we previously read,
; but maybe didn't get in completely
	SKIPN C,BODPNT
	 JRST RDLTY1
RDLTY2:	FETCH(A,C,TNAM)
	MOVE B,UTLIST		;NAME WE JUST READ
	PUSHJ P,TXTMAT
	 JRST [	FETCH(C,C,TNXT)
		JUMPN C,RDLTY2
		JRST RDLTY1]
	FETCH(T,C,TYP1)		;All the way in?
	JUMPN T,RDLTY1		;Yes, don't need to go back to library then.
	FETCH(A,C,TLIB)		;A type from a library?
	JUMPE A,RDLTY1		;No, there will be a replacement then.
	HLRZ A,(A)		;SECOND WORD OF LIBRARY NAME BLOCK
	MOVEI T,NEEDMR
	IORM T,(A)		;TURN ON BIT SAYING WE NEED TO READ THIS LIBRARY AGAIN
	JRST RDLTY1

;READ LIBRARY(S)

;We aren't sure which types we'll need, so read all extant libraries in completely.

FRCLIB:	SKIPN C,LIBLST
	 JRST GETLIB
FRCLB1:	HLRZ A,(C)
	MOVEI T,NEEDMR
	IORM T,(A)		;FORCE MERGING OF ANY LIBRARIES USED IN THIS DWG
	HRRZ C,(C)
	JUMPN C,FRCLB1

;Read names of libraries for this drawing
GETLIB:	PUSHJ P,WORDIN		;LIBRARY FILENAME
	JUMPE TTT,RDTYP		;No more
	GETFS (T)		;LIST OF LIBRARIES
	MOVEM TTT,1(T)
	MOVE B,TTT
	GETFS (TT)
	HRLZM TT,(T)
	PUSHJ P,WORDIN		;EXT,,BITS
	TRZ TTT,NEEDMR!TOPLVL
	TRNE FSTLIB		;TOP LEVEL LIBRARY?
	 TRO TTT,TOPLVL		;YES
	MOVEM TTT,(TT)
	HLLZ C,TTT
	PUSHJ P,WORDIN		;PPN
	MOVEM TTT,1(TT)
	MOVE D,TTT
	EXCH T,LIBTMP		;LINK ON FRONT OF LIST
	HRRM T,@LIBTMP
	PUSHJ P,MAPLIB		;Map this library?
	 JRST GETLIB		;No, simple
;Map library, new name is in A
	MOVE TT,LIBTMP		;THIS IS THE ENTRY WE JUST MADE
	HLRZ A,(A)
	HRRZ A,(A)
	MOVE TTT,1(A)		;GET NEW NAME
	MOVEM TTT,1(TT)
	HLRZ TT,(TT)
	HLRZ A,(A)
	HLLZ TTT,(A)		;EXT
	HLLM TTT,(TT)
	MOVE TTT,1(A)		;PPN
	MOVEM TTT,1(TT)
	JRST GETLIB

;READ TYPES

RDTYP:	PUSHJ P,RDTYPX
	 JRST GOTYPS		;END OF TYPES
	PUSHJ P,RDTYPY		;JUST READ TYPE, MAYBE NEED TO REPLACE?
	JRST RDTYP

GOTYPS:	SKIPN E,LIBTMP
	 POPJ P,		;NO LIBRARIES TO DO OR WILL BE DONE HIGHER UP

;Got local types, but also need library's types

	SETZM LIBTMP		;clear library-pending list for guys down under
	PUSH P,FILNAM		;Save current file-specs
	PUSH P,FILEXT
	PUSH P,FILPPN
LIBIT:	HRRZ T,(E)
	PUSH P,T		;SAVE LINK TO NEXT LIB, IF ANY
	MOVE B,1(E)
	MOVEM B,FILNAM
	HLRZ TT,(E)
	HLLZ C,(TT)
	MOVEM C,FILEXT
	MOVE D,1(TT)
	MOVEM D,FILPPN
;Do we already have the library in for some reason (at a higher level?)
LIBIT1:	PUSHJ P,LNAMCK		;DO WE ALREADY HAVE THIS LIBRARY?
	 JRST [	HLRZ TT,(E)
		FSTRET(E)
		FSTRET(TT)
		HRRZ TT,(T)		;GET FLAG BITS FROM FOUND LIBRARY
	;	TRZN TT,NEEDMR		;NEED MERGE?
		TRZA TT,NEEDMR		;****** TEMPORARY BUG FIX, ALWAYS RE-READ LIBRARY
;Problem probably is that the "needed" test fails if is needed at lower level
; but when the library gets in at the upper level, the usedlist for the lower call is gone
; The ALLFLG shouldn't really mean all.
		 JRST LIBIT2		;NO, SKIP IT
		HRRM TT,(T)		;MAKE SURE WE ONLY MERGE ONCE
		MOVEM A,LIBNAM		;YES, STORE LIBRARY POINTER THAT'S ALREADY IN
		PUSH P,ALLFLG		;YES, SAVE ALLFLG
		SETOM ALLFLG		;We need more of this library, get all of types
		JRST LIBIT3]
	MOVEM E,LIBNAM		;POINTER TO LIBRARY DESCRIPTOR
	PUSH P,ALLFLG		;SAVE STATE OF FLAG SAYING WE ARE JUST
				; GETTING THE REST OF SOME DEF'S
LIBIT3:	PUSH P,0		;SAVE CURRENT STATE OF FSTLIB
	TRZ FSTLIB		;Any other libraries will no longer be first
	AOS DEPTH
	PUSHJ P,LIBRED		;Read type defs (may also recursively call libraries)
	 JRST LIBFAI
	SOS DEPTH
	POP P,T			;GET OLD STATE OF FSTLIB
	TRNE T,FSTLIB
	 TRO FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES
	POP P,ALLFLG
LIBIT2:	POP P,E
	JUMPN E,LIBIT

;Pop back to previous file, re-read past type definitions, to setup
; for bodies, points, sets.

	TRNE FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES?
	 SETZM LIBNAM		;YES, BODIES HERE DON'T GET LIBRARY POINTER
	POP P,FILPPN
	POP P,FILEXT
	POP P,FILNAM
	PUSH P,FILPPN
	LOOKUP DAT,FILNAM
	 JRST [	OUTSTR[ASCIZ/FILE I WAS READING WENT AWAY!
/]
		PUSHJ P,FUCKUP
		MOVE P,PERRSAV
		POPJ P,]	;LOSE BIG
	POP P,FILPPN		;RESTORE, LOOKUP CLOBBERS IT
	PUSHJ P,REDVER		;AVOID TYPEOUT
	MOVE T,RDVER		;**RDVER
	CAIGE T,13
	 JRST SKPTY1
	PUSHJ P,SKPSTR		;SKIP LIB TYPE NAMES AT FRONT
	 JRST SKPTY1
	JRST .-2

LIBFAI:	SOS DEPTH
	POP P,T			;GET OLD STATE OF FSTLIB
	TRNE T,FSTLIB
	 TRO FSTLIB		;BACK AT TOP LEVEL OF LIBRARIES
	POP P,ALLFLG
	OUTSTR[ASCIZ/LIKE TO TRY ANOTHER LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	 JRST [	MOVE E,LIBNAM	;HE GAVE UP
		HLRZ TT,(E)
		FSTRET(E)
		FSTRET(TT)
		JRST LIBIT2]	;SKIP THIS LIBRARY
	MOVE E,LIBNAM		;UPDATE SAVED NAME
	HLRZ TT,(E)
	MOVE B,FILNAM
	MOVEM B,1(E)
	HLLZ C,FILEXT
	HLLM C,(TT)
	MOVE D,FILPPN
	MOVEM D,1(TT)
	JRST LIBIT1		;TRY LIBRARY AGAIN

;SKIP OVER LOCAL TYPES TO MACRO DEFS IN .DRW FILE

SKPTY1:	PUSHJ P,WORDIN		;SKIP LIBRARY FILENAMES
	JUMPE TTT,SKPTY2
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST SKPTY1

SKPTY2:	PUSHJ P,SKPSTR		;SKIP BODY NAME
	 POPJ P,		;END OF BODY DEFS
	MOVE T,RDVER
	CAIGE T,10		;**RDVER
	 JRST SKPTY3		;NO DIP TYPE NAMES!
	CAIGE T,23		;NOT HERE FOR .GE.23
	PUSHJ P,SKPSTR		;SKIP DIP TYPE NAME
	JFCL
	CAIL T,27		;**RDVER
	 PUSHJ P,SKPSTR		;SKIP PACKAGE NAME
	 JFCL
	CAIL T,13		;**RDVER DO WE HAVE BITS,,UNUSED?
	PUSHJ P,WORDIN		;YES, SKIP IT
	CAIGE T,12		;**RDVER DO WE HAVE DEF OFFSET
	 JRST SKPTY3		;NO
	PUSHJ P,WORDIN		;YES, GET IT
	CAILE T,23		;**RDVER
	PUSHJ P,WORDIN		;SKIP CHAR OFFSET IF THERE
SKPTY3:	PUSHJ P,WORDIN
	CAIN TTT,400000
	 JRST SKPTY4
	PUSHJ P,WORDIN
	CAIL T,17
	PUSHJ P,WORDIN		;SKIP NEW WORD
	JRST SKPTY3

SKPTY4:	PUSHJ P,WORDIN
	CAIE TTT,400000
	JRST SKPTY4
	MOVE C,RDVER
	CAIL C,23
	 JRST SKPTY6		;**RDVER
SKPTY5:	PUSHJ P,WORDIN
	CAIN TTT,400000
	 JRST SKPTY2
	CAIGE C,2		;**RDVER
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	CAILE C,3		;**RDVER
	PUSHJ P,WORDIN
	PUSHJ P,SKPSTR
	 JFCL
	JRST SKPTY5

SKPTY6:	PUSHJ P,SKPPRP
	JRST SKPTY2

SKPPRP:	PUSHJ P,SKPSTR
	POPJ P,
	PUSHJ P,SKPSTR
	JFCL
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST SKPPRP
;LIBRARY SUBRS
SETMAP:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/OLD LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	POPJ P,
	ENTPPN
	MOVE B,FILNAM
	HLLZ C,FILEXT
	MOVE D,FILPPN
	PUSHJ P,MAPLIB			;TRY TO FIND IT
	CAIA
	JRST GOTMAP
	GETFS(A)		;LIB MAP LIST ??
	GETFS(T)
	HRL T,MAPLST
	MOVSM T,(A)
	MOVEM A,MAPLST
	MOVEM B,1(A)
	HLLZM C,(T)
	MOVEM D,1(T)
GOTMAP:	HRLM A,(P)
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/NEW LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	JRST MAPKIL
	ENTPPN
	HLRZ A,(P)
	HLRZ T,(A)
	HRRZ TT,(T)
	JUMPE TT,NOMAPD
	HLRZ TTT,(TT)
	FSTRET(TTT)
	FSTRET(TT)
NOMAPD:	GETFS(TT)
	HRRM TT,(T)
	GETFS(TTT)
	HRLZM TTT,(TT)
	MOVE T,FILNAM
	MOVEM T,1(TT)
	HLLZ T,FILEXT
	MOVEM T,(TTT)
	MOVE T,FILPPN
	MOVEM T,1(TTT)
	POPJ P,

MAPKIL:	HLRZ A,(P)
	MOVEI T,MAPLST
	JRST MAPKL1

MAPKL2:	CAIN T,(A)
	JRST MAPKL3
MAPKL1:	MOVE TT,T
	HRRZ T,(T)
	JUMPN T,MAPKL2
	PUSHJ P,FUCKUP
	POPJ P,

MAPKL3:	HRRZ T,(A)
	HRRM T,(TT)
MAPKL0:	HLRZ T,(A)
	HRRZ TT,(T)
	FSTRET(T)
	FSTRET(A)
	JUMPE TT,CPOPJ
	HLRZ TTT,(TT)
	FSTRET(TT)
	FSTRET(TTT)
	POPJ P,

CLRMAP:	SKIPN B,MAPLST
	POPJ P,
CLRMP1:	MOVE A,B
	HRRZ B,(B)
	PUSHJ P,MAPKL0
	JUMPN B,CLRMP1
	SETZM MAPLST
	POPJ P,

MAPLIB:	SKIPN A,MAPLST
	 POPJ P,
MAPLB1:	CAME B,1(A)
	 JRST MAPLB2
	HLRZ T,(A)
	CAME D,1(T)
	 JRST MAPLB2
	HLLZ TT,(T)
	CAMN TT,C
	 JRST CPOPJ1
MAPLB2:	HRRZ A,(A)
	JUMPN A,MAPLB1
	POPJ P,

;LNAMCK - Check if library (A) is already around (skips if not)

LNAMCK:	SKIPN A,LIBLST
	 JRST CPOPJ1
NXTLB1:	CAME B,1(A)
	 JRST NXTLIB
	HLRZ T,(A)
	HLLZ TT,(T)
	CAMN C,TT
	CAME D,1(T)
	 JRST NXTLIB
	POPJ P,

NXTLIB:	HRRZ A,(A)
	JUMPN A,NXTLB1
	JRST CPOPJ1

LIBUSE:	OUTSTR[ASCIZ/LIBRARY NAME CONFLICT, CHOOSE ANOTHER!
/]
	POPJ P,

;HERE IS WHERE WE READ A NEW LIBRARY IN!
DOLIB:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LIBRARY /]
	MOVSI T,EXTLIB
	PUSHJ P,SETNAM
	POPJ P,			;LET HIM OUT THIS WAY
	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
DEC,<
	SKIPN D,FILPPN		;0 WILL CONFUSE US
	PUSHJ P,[LOOKUP DAT,FILNAM
		JRST NOLUCK
		MOVE A,[3,,B]
		MOVEI B,DAT
		PATH A,		;PATH UUO TO GET REAL PPN
	NOLUCK:	DSKPPN D,	;PATH UUO FAILED, GET OUR PPN
		SETZM FILNAM+2
		CLOSE DAT,
		MOVEM D,FILPPN
		POPJ P,]
>;DEC
NODEC,<	MOVE D,FILPPN	>
	MOVE B,FILNAM
	HLLZ C,FILEXT
	CAMN B,LSTNAM
	CAME C,[EXTFIL,,0]
	JRST NAMOK
	CAME D,LSTPPN
NAMOK:	PUSHJ P,LNAMCK
	 JRST LIBUSE
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	GETFS(A)
	MOVEM A,LIBNAM		;CURRENT LIBRARY NAME
	MOVE T,FILNAM
	MOVEM T,1(A)
	GETFS(T)
	HRLZM T,(A)
	HLLZ TT,FILEXT
	HRRI TT,TOPLVL		;SET AS TOP LEVEL LIBRARY
	MOVEM TT,(T)
	MOVE TT,FILPPN
	MOVEM TT,1(T)
	TLO M,TYPREP!TYPNLY	;REPLACE AUTOMATICALLY AND TYPES ONLY
	TRZ FSTLIB		;inside library, not drawing
	SETOM USEFLG		;ENABLE NON-READIN STUFF
	SETZM ALLFLG		;READING LIBRARY AFRESH
	SETZM LIBTMP		;CLEAR THIS FOR LIBRARY READING
	SKIPE B,UTLIST
	 PUSHJ P,RELUTL		;RELEASE ALL USE NAMES (WILL BE CAUGHT AT RDTYPY)
	PUSHJ P,CLBMRK		;CLEAR NEEDMR IN LIBLST
	SETZM DEPTH
	AOS DEPTH
	PUSHJ P,LIBRED
	 CAIA
	 JRST DOLIB1
	MOVE A,LIBNAM
	HLRZ T,(A)
	FSTRET(A)
	FSTRET(T)
DOLIB1:	RELEASE DAT,
	POPJ P,

;LIBRED
;SKIP IF SUCCESSFUL

LIBRED:	MOVE T,DEPTH
	OUTSTR[ASCIZ/  /]
	SOJG T,.-1
	OUTSTR[ASCIZ/LIBRARY /]
	MOVEI A,FILNAM
	JSR FPRINT			;PRINT LIBRARY NAME
	MOVE T,FILPPN
	LOOKUP DAT,FILNAM		;GET LIBRARY FILE
	 JRST LOOKER
DEC,<	JSR DAT,LOOKCK	>
NODEC,<	MOVEM T,FILPPN	>
	OUTSTR[ASCIZ/
/]
	AOS (P)			;SUCCESSFUL LOOKUP
;If new library we haven't heard of yet, add to library-in-list
	SKIPE ALLFLG
	 JRST TYPIN		;If just re-reading, already have this on library-in-list
	MOVE T,LIBNAM		;New library
DEC,<	HLRZ TT,(T)
	MOVE TTT,FILPPN
	MOVEM TTT,1(TT)			;STORE REAL PPN
>;DEC
	EXCH T,LIBLST
	HRRM T,@LIBLST
	JRST TYPIN

SUBTTL EXTRACT TYPE FROM FILE

;GET A TYPE FROM LIBRARY
;A = POINTER TO HEADER BLOCK OF TYPE, PREVIOUS IN LEFT HALF
BDYGET:	FETCH(T,A,TLIB)		;LIBRARY BLOCK POINTER
	JUMPE T,[OUTSTR[ASCIZ/NON-LIBRARY BODY NOT FULLY READ IN!
/]
		JRST FUCKUP]
	MOVE TTT,1(T)
	MOVEM TTT,FILNAM
	HLRZ T,(T)
	MOVE TTT,(T)
	HLLZM TTT,FILEXT
	MOVE TTT,1(T)
	MOVEM TTT,FILPPN
	FETCH(T,A,TNXT)
	HLRZ TT,A
	STORE(T,TT,TNXT)	;TEMPORARILY LINK THIS ONE OUT
	FETCH(T,A,TNAM)
	MOVEM T,LIBTMP		;STORE BODY NAME HERE
	PUSHJ P,PUSHIT		;MAKE THE WORLD SAFE FOR HIGHER UPS
	PUSHJ P,DORBDY
	 JRST GTBDYE
	PUSHJ P,POPIT
	MOVE C,A		;OLD BODY BLOCK
	MOVE A,BODPNT		;NEW BODY IS HERE (I HOPE).
	FETCH(T,C,TLIB)		;LIBRARY POINTER
	STORE(T,A,TLIB)		;STORE INTO BODY JUST READ
	MOVE B,C
	PUSHJ P,PUTFS		;NOW GIVE BACK HEADER BLOCK, AND NAME
	JRST CPOPJ1		;GIVE SUCCESS RETURN

GTBDYE:	PUSHJ P,POPIT
	HLRZ TT,A
	STORE(A,TT,TNXT)	;LINK BACK IN
	OUTSTR[ASCIZ/SORRY,/]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ NO LONGER IN LIBRARY!
/]
	POPJ P,

;RDBODY - XGETBODY

RDBODY:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ALLEDM!1EDTAM]		;CANNOT BE IN EDIT MODE!!!
	JRST PERRET
	TRZ INMOV
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/TYPE BODY NAME
/]
	PUSHJ P,TREADU
	POPJ P,			;ALTMODE
	POPJ P,			;NULL
	MOVEM B,LIBTMP		;SAVE HERE TEMPORARILY
	MOVSI T,EXTFIL
	PUSHJ P,SETNAM		;READ FROM DRAW FILE
	JRST RDLEAV		;LET HIM OUT
	PUSHJ P,DORBDY
	JRST RDLEV1
	JRST RDLEV2

RDLEV1:	OUTSTR[ASCIZ/SORRY,/]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ NOT FOUND!
/]
RDLEV2:	RELEASE DAT,
RDLEAV:	MOVE B,LIBTMP
	JRST PUTFS

;DORBDY - READ BODY FROM FILE

DORBDY:	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR [ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	OUTSTR[ASCIZ/SEARCHING FOR /]
	MOVE T,LIBTMP
	PUSHJ P,OUTTXT
	OUTSTR[ASCIZ/ IN /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	SETZM USEFLG		;MAKE SURE IT IS READ IN
	SETZM ALLFLG
	SETZM LIBNAM		;CLEAR LIBRARY NAME
	TLZ M,TYPREP		;DON'T REPLACE AUTOMATICALLY
	TRZ FSTLIB
	MOVEM P,PERRSAV		;RETURN UP FROM HERE
	PUSHJ P,GETVER
	MOVE T,RDVER
	CAIGE T,3		;**RDVER
	JRST RDTYPZ		;VERSIONS 3 AND ABOVE HAVE LIBRARIES
	CAIGE T,13		;**RDVER
	JRST RDTYPC		;NO LIST OF LIB TYPES TO SKIP
	PUSHJ P,SKPSTR
	JRST RDTYPC
	JRST .-2

RDTYPC:	PUSHJ P,WORDIN
	JUMPE TTT,RDTYPZ	;SKIP OVER LIBRARY NAMES
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST RDTYPC

RDTYPZ:	PUSHJ P,RDTYPX
	POPJ P,
	MOVE A,LIBTMP
	MOVE B,STRING
	PUSHJ P,TXTMAT		;COMPARE NAME HE TYPED WITH BODY NAME
	JRST [	PUSHJ P,RELTYP	;NO, RELEASE TYPE
		JRST RDTYPZ]	;TRY ANOTHER
	PUSHJ P,RDTYPY		;TRY TO GET TYPE INTO STRUCTURE
	TRO MCHG!NEEDCL	;FOUND, COULD BE REPLACING OLD VERSION, SO UPDATE SCREEN
	JRST CPOPJ1

CLBMRK:	SKIPN T,LIBLST
	POPJ P,
	MOVEI TT,NEEDMR
CLBMR1:	HLRZ TTT,(T)
	ANDCAM TT,(TTT)
	HRRZ T,(T)
	JUMPN T,CLBMR1
	POPJ P,
SUBTTL READ TYPES

RDTYPX:	PUSHJ P,RSTRZ		;READ TYPE NAME
	 POPJ P,		;DONE WITH TYPES!
	MOVEM T,STRING		;SAVE NAME HERE
	SETZM DEFOFF		;CLEAR DIP TYPE POINTER, DEF OFFSET
	SETZM ODIPTYP
	SETZM DEFBTS		;AND BITS,,UNUSED
	MOVE TT,RDVER		;**RDVER
	CAIGE TT,10		;DOES THIS FILE HAVE DIP TYPE?
	 JRST NODTYP
	CAIL TT,23
	 JRST ISTYPN		;**RDVER
	PUSHJ P,RSTRZ		;READ DIP TYPE
	SETZ T,			;NULL
	MOVEM T,ODIPTYP
ISTYPN:	SETZ TTT,		;CLEAR DEF OFFSET
	SETZM PACK
	MOVE TT,RDVER
	CAIGE TT,12		;**RDVER
	 JRST NODTYP
	CAIGE TT,13		;**RDVER
	 JRST NODBTS
	CAIGE TT,27		;**RDVER
	 JRST NOPAK
	PUSHJ P,RSTRZ
	 SETZ T,
	MOVEM T,PACK
NOPAK:	PUSHJ P,WORDIN		;READ BITS,,UNUSED
	TLZ TTT,FOUNDL!DTMP1	;CLEAR MARK BITS ON INPUT
	MOVEM TTT,DEFBTS
NODBTS:	PUSHJ P,WORDIN		;READ DEFAULT OFFSET
	MOVEM TTT,DEFOFF
	MOVEI TTT,400000
	MOVE T,RDVER
	CAILE T,23		;**RDVER
	PUSHJ P,WORDIN
	MOVEM TTT,DEFOF1

SUBTTL  READIN PINS
;FALLS THRU

NODTYP:	SETZM PINS		;INITIALIZE PIN LIST.
	MOVEI T,PINS		;DUMP IN HERE FIRST
RDPIN2:	PUSHJ P,WORDIN		;GET A PIN LOC
RDPINS:	CAIN TTT,400000		;END OF PINS?
	 JRST RPINDN		;YES
	MOVE A,RDVER
	CAIG A,10		;**RDVER
	JRST [	ADD TTT,[PXOFF,,PYOFF]
		AND TTT,[PXMASK,,PYMASK]
		JRST .+1]
	PUSHJ P,MAKTPN		;GET BLOCK FOR TYPE PIN IN TT
	STORE(TT,T,TPNX)	;LINK AT END OF LIST
	MOVE T,TT		;NEW END OF LIST
	CAIL A,17
	 JRST NWPND1		;**RDVER THIS IS SIMPLE
	PUSH P,TTT		; (OLD VERSION STUFF)
	PXY(TTT)
	STORE(TTT,T,TPXY)
DEC,<	LDB TTT,[POINT 2,(P),5]	;OLD PIN TYPE BITS 
	CAIN TTT,1
	TLO TTT,ASSH
	CAIN TTT,2
	TLO TTT,ASSL
	HLRZS TTT
	STORE(TTT,T,TPBIT)	;SET H,L BITS FOR DEC
>;DEC
	POP P,TTT
	NXY(TTT)
	LSH TTT,=17
	TRZE TTT,400000
	PUSHJ P,NIPCOP
	HLRZS TTT
	STORE(TTT,T,TPPOS)	;PIN POSITION
	PUSHJ P,WORDIN
	STORE(TTT,T,TPID)	;PIN ID
	TRZE TTT,700000
	TRZ TTT,77000		;MAKE (.GE.64) NOT BUSSED THROUGH
	PUSH P,TTT
	ANDI TTT,777
	STORE(TTT,T,TPNAM)	;PIN NAME
	HRRZ TTT,(P)
	TRNN TTT,777000
	TDZA TTT,TTT
	MOVEI TTT,BUSSED
	SETBIT(<(TTT)>,TT,T,TPBIT)
	POP P,TTT
	MOVE TT,RDVER
DEC,<	TLNE TTT,1		;MARKER BIT ON?
	CAIG TT,10		;**RDVER
	CAIA
	HLLM TTT,PINS		;FLAG DIP OFFSET IS FIRST PIN
>;DEC
	CAILE TT,2		;**RDVER
	JRST RDPIN2
RDPIN1:	PUSHJ P,WORDIN
	HLRZ TT,TTT
	CAIE TT,400000
	JRST RDPINS
	JRST RDPIN1

;OLD FORMAT NIPPLE

NIPCOP:	MOVS TTT,TTT		;GET IN RH FOR INDEX
	TRZ TTT,777770		;AVOID CONFUSING GARBAGE
	MOVE A,NXYTAB(TTT)	;GET OFFSET FOR NIPPLE BIT
	DPB A,[POINT YOFFW,TTT,YOFFB]
	HLRZ A,A
	DPB A,[POINT XOFFW,TTT,XOFFB]
	MOVS TTT,TTT
	POPJ P,

DEC,<NIPOFF__1>
NODEC,<NIPOFF__2>

NXYTAB:	0,,NIPOFF
	0,,NIPOFF
	-NIPOFF,,0
	-NIPOFF,,0
	0,,-NIPOFF
	0,,-NIPOFF
	NIPOFF,,0
	NIPOFF,,0

NWPND1:	STORE(TTT,T,TPXY)
	PUSHJ P,WORDIN
	STORE(TTT,T,TPID)	;PINID
	TLZ TTT,FOUNDD			;CLEAR MARK BIT
	HLRZS TTT
	STORE(TTT,T,TPBIT)	;BITS
	PUSHJ P,WORDIN
	CAIGE A,20			;NEW PIN POS?
	TLZN TTT,400000			;NO, CLEAR NIPPLE BIT
	CAIA
	PUSHJ P,NIPCOP
	STORE(TTT,T,TPNAM)
	HLRZS TTT
	STORE(TTT,T,TPPOS)
	JRST RDPIN2

SUBTTL READ DISPLAY LINES FOR TYPE

RPINDN:	SETZM LINES		;INITIALIZE LINES
	MOVEI T,LINES		;DUMP HERE FIRST
RDLINS:	PUSHJ P,WORDIN		;GET A POINT
	CAIN TTT,400000		;DONE?
	JRST RLINDN		;YES
	GETFS(TT)		;GET A BLOCK FOR HIM
	MOVEM TTT,1(TT)		;STORE LOC
	SETZM (TT)		;CLEAR LINK WORD
	MOVEM TT,(T)		;LINK ON END OF LIST
	MOVE T,TT		;NEW END
	JRST RDLINS		;GET SOME MORE

SUBTTL READ BODY TEXT - OLD IOVER FORMAT

RLINDN:	SETZM BTEXT		;INITIALIZE BODY TEXT LIST
	MOVE C,RDVER		;GET IOVERSION #
	CAIL C,23		;**RDVER
	JRST RBTXTN
	MOVEI T,BTEXT		;DUMP FIRST POINTER HERE
RBTEXT:	PUSHJ P,WORDIN		;GET LOC OF TEXT
	CAIN TTT,400000		;DONE?
	JRST BTXTDN		;YES
	PUSHJ P,MAKTXT		;MAKE TEXT BLOCK
	TLZ TTT,1		;CLEAR MARK BIT
	TRO TTT,1		;SET AUTO OFFSET BIT FOR OLD FORMAT
	STORE(TTT,TT,TXXY)	;SAVE LOC
	STORE(TT,T,TXNXT)	;LINK ONTO LIST
	MOVEM T,LOSEPT		;SAVE OLD END IN CASE THIS STRING LOSES
	CAIGE C,2		;**RDVER
	PUSHJ P,WORDIN		;SKIP REL VECT FROM OLD VERSIONS
	PUSHJ P,WORDIN		;GET LINES, CHARS, AND SIZE
	CAIGE C,4		;**RDVER
	TRZN TTT,10		;OLD VERSIONS INDICATE VERT HERE
	CAIA
	TRO TTT,400000		;MARK VERT FOR OLD VERSIONS
	HRRZ A,TTT
	HRRZ B,A
	ANDI B,377777
	CAILE B,CSIZES		;LEGAL CHAR SIZE?
	JRST [	OUTSTR[ASCIZ/ILLEGAL CHARACTER SIZE READ FOR BODY TEXT.
WILL USE STANDARD TEXT SIZE INSTEAD.
/]
		TRZ A,377777
		TRO A,@STDBIG
		JRST .+1]
	CAILE C,3		;**RDVER
	JRST GETCON
	LDB B,[POINT 9,TTT,8]	;GET # OF CHARS
	LDB D,[POINT 9,TTT,17]	;GET # OF LINES-1
	SUBI D,1
	ANDI TTT,377777
	LSH TTT,2		;MAKE IT SCREEN OFFSET
	IMUL B,TTT
	LSH TTT,1		;TIMES 2
	IMUL TTT,D
	MOVNS B
	HRL TTT,B
	TRNN A,400000		;WAS IT VERT?
	JRST GOTCON
	PUSH P,F
	EXCH T,TTT
	MOVEI F,1
	PUSHJ P,ORIENT
	POP P,F
	EXCH T,TTT
	JRST GOTCON
GETCON:	PUSHJ P,WORDIN		;READ CONSTANT OFFSET
GOTCON:	STORE(TTT,TT,TXOFF)	;STORE REL VECT
	HRLM A,(P)		;TEXT SIZE
	PUSHJ P,RSTRZ		;READ TEXT
	JRST [	RETBLK(TT,TEXT)
		MOVE T,LOSEPT
		CLEAR(T,TXNXT)
		JRST RBTEXT]
	HLRZ A,(P)
	HRLM A,(T)		;SAVE SIZE IN FIRST WORD OF STRING
	STORE(T,TT,TXVAL)	;SAVE TEXT
	MOVE T,TT		;GET END OF LIST INTO T
	JRST RBTEXT		;ANOTHER ONE

SUBTTL READ BODY'S PROPERTIES - NEW IOVER FORMAT

RBTXTN:	PUSHJ P,PROPIN
	JRST BTXTDN

PROPIN:	PUSHJ P,RSTRZ		;TEXT VALUE
	POPJ P,
	PUSHJ P,MAKTXT		;CONS BLOCK
	STORE(T,TT,TXVAL)
	EXCH TT,BTEXT		;ADD TO HEAD OF LIST
	HRRM TT,@BTEXT
	PUSHJ P,RSTRZ		;PROPERTY NAME (OR 0)
	 SETZ T,		; NO ASCIZ, NULL PROPERTY IS JUST TEXT
	MOVE TT,BTEXT		;GET TEXT BLOCK
	STORE(T,TT,TXNAM)
	PUSHJ P,WORDIN		;TEXT SIZE
	FETCH(T,TT,TXVAL)
	HRLM TTT,(T)
	PUSHJ P,WORDIN
	TLZ TTT,1		;CLEAR MARK BIT ON INPUT
	STORE(TTT,TT,TXXY)	;X,Y LOCATION
	PUSHJ P,WORDIN
	STORE(TTT,TT,TXOFF)
	JRST PROPIN
SUBTTL
;PATCHUP OLD RDVER DIPTYPE FORMAT

BTXTDN:	SKIPN T,ODIPTYP		;ANY OLD FORMAT DIPTYPE?
	 JRST NODPTY		;NO
	PUSHJ P,MAKTXT
	MOVEI TTT,1
	STORE(TTT,TT,TXXY)	;INITIALIZE TO AUTO OFFSET
	STORE(T,TT,TXVAL)
	EXCH TT,BTEXT
	HRRM TT,@BTEXT
	MOVEI TT,[ASCIZ/DIPTYPE/]
	PUSHJ P,ASCCOP
	MOVE A,BTEXT
	STORE(T,A,TXNAM)
	PUSHJ P,EDTTZA		;DO TEXT OFFSETTING

;BUILD TYPE DEFINITION

NODPTY:	PUSHJ P,MAKTYP		;GET NEW TYPE PTR IN T
	MOVE T,TT
	MOVEM TT,TYPE

DEC,<	SKIPE TT,PINS
	TLNN TT,1		;DIP OFFSET SEEN?
	JRST GOTCO1		;NO
	MOVE TTT,1(TT)		;GET OFFSET
	MOVEM TTT,DEFOFF	;AND STO IT HERE
	HRRZ TTT,(TT)
	MOVEM TTT,PINS
	FSTRET(TT)
GOTCO1:
>;DEC
	MOVE TTT,DEFOFF		;DEF LOC OFFSET
	STORE (TTT,T,TXY)
	MOVE TTT,DEFBTS		;BITS,,UNUSED
	STORE (TTT,T,TBIT)
	MOVE TTT,DEFOF1
	CAIN TTT,400000
	JRST NDLCOF
	MOVEI TTT,-1+ADDR(T,TOXY)
	STORE (TTT,T,TYP3)	;SETUP DUMMY PTR IF DEFAULT CHAR OFFSET
	MOVE TT,DEFOF1
	STORE (TT,T,TOXY)
NDLCOF:	MOVE TT,PINS
	STORE (TT,T,TPIN)	;LINK IN PINS
	MOVE TT,LINES
	STORE (TT,T,TLIN)	;LINK IN LINES
	MOVE TT,BTEXT
	STORE (TT,T,TPROP)	;LINK IN BTEXT
	HRRZ TT,STRING		;TYPE NAME
	STORE (TT,T,TNAM)
	MOVE TT,LIBNAM		;YES, GET POINTER TO NAME BLOCK
	STORE (TT,T,TLIB)
	MOVE T,PACK
	JUMPE T,NPKCOD
	PUSHJ P,MATPAK
	 JRST [	MOVE T,STRING
		PUSHJ P,OUTTXT
		OUTSTR [ASCIZ / HAS BAD PACKAGE /]
		MOVE T,PACK
		PUSHJ P,OUTTCR
		SETZ A,
		JRST .+1]
	MOVE T,TYPE
	STORE(A,T,TPAK)
	MOVE B,PACK
	PUSHJ P,PUTFS
NPKCOD:	MOVE A,TYPE
	PUSHJ P,CMPTYP		;COMPILE ANY SPECIAL PROPS IN TYPE
	JRST CPOPJ1		;SUCCESS RETURN

SUBTTL CHECK IF TYPE EXISTS, REPLACE MAYBE
RDTYPY:	MOVE T,STRING		;ARG IN T
	PUSHJ P,TNAME		;DOES NAME ALREADY EXIST?
	 JRST TYPEXI		;YES
	MOVE T,TYPE		;NO, NEW TYPE TO ENTER
	MOVE TT,BODPNT
	STORE(TT,T,TNXT)	;LINK TYPE LIST TO THIS TYPE
	MOVEM T,BODPNT		;MAKE THIS TYPE THE FIRST

;CHECK IF THIS BODY IS USED,
; IF NOT, RELEASE MOST OF THE STORAGE TO SAVE SPACE
; IF USED TYP1 CONTAINS DUMMY POINTER, AND THIS IS COMPLETE BLOCK
; IF NOT USED, TYP1 IS 0, AND THIS IS GETFS BLOCK, ONLY TNAM,TLIB,TNXT

CKUBDY:	SKIPN USEFLG		;DO WE HAVE THE USE FEATURE
	 POPJ P,		;NO, KEEP ENTIRE DEFINITION
	MOVE T,TYPE
	FETCH (TT,T,TLIB)
	JUMPE TT,CPOPJ		;IF NOT LIBRARY BODY, KEEP IT ALL IN
	MOVE C,STRING
	PUSHJ P,USETYP		;WILL WE USE TYPE?
	 POPJ P,		;YES
	MOVE C,TYPE
	GETBLK(T,STYP)		;SHORT TYPE ABBREVIATED BLOCK
	CLEAR(T,SYP1)		;MARK AS SUCH
	FETCH(TT,C,TLIB)	;COPY LIB
	STORE(TT,T,SLIB)
	FETCH(TT,C,TNAM)	;COPY TYPE NAME
	STORE(TT,T,SNAM)
	CLEAR(C,TNAM)		;CLEAR OLD PTR, SO WON'T RECLAIM AT TYPREL
;Patch out old type block
	MOVEI TT,BODPNT-V.TNXT
CKUBD1:	FETCH(TTT,TT,TNXT)	;get previous pointer
	CAME TTT,C		;PREV  C ?
	 JRST [	SKIPE TT,TTT
		 JRST CKUBD1
		PUSHJ P,FUCKUP
		MOVE TT,BODPNT
		STORE(TT,T,TNXT)
		MOVEM T,BODPNT
		MOVEM T,TYPE
		POPJ P,]
	STORE(T,TT,TNXT)	;PREV  T
	FETCH(TTT,C,TNXT)	;T  next
	STORE(TTT,T,SNXT)
	MOVEM T,TYPE
	MOVE A,C
	JRST TYPREL		;GIVE BACK OLD TYPE

USETYP:	SKIPN D,UTLIST		;ANY USE LIST?
	 JRST CPOPJ1		;NOT USED
USETY1:	MOVE A,D
	MOVE B,C
	PUSHJ P,TXTMAT
	CAIA
	 POPJ P,		;MATCH, WILL BE USED
	HLRZ D,(D)
	JUMPN D,USETY1
	JRST CPOPJ1		;NOT USED AT ALL

;TYPE EXISTS, MAYBE REPLACE WITH DEF JUST READ IN

TYPEXI:	MOVEM C,OLDTYP		;SAVE THIS IN CASE WE WILL REPLACE
	MOVE A,TYPE
	MOVEM A,NEWTYP
	SKIPN ALLFLG		;Re-reading, trying to get all of def?
	 JRST TYPEXJ		;NO, DO REG. THING
	FETCH(T,C,TYP1)		;DATA POINTER FOR TYPE - ALL IN?
	JUMPN T,RELTYP		;YES, SKIP IT COMPLETELY
	JRST NOREPB		;IF NOT ALL IN, REPLACE WITH FULL DEF

TYPEXJ:	TLNE M,TYPREP
	 JRST AUTORP
	TLNE M,DSKACT!MACACT
	 JRST NOASKM
	OUTSTR[ASCIZ/SHALL I REPLACE /]
	MOVE B,OLDTYP
	PUSHJ P,OUTIT
	OUTSTR[ASCIZ/ WITH /]
	MOVE B,NEWTYP
	PUSHJ P,OUTIT
NOASKM:	PUSHJ P,YORN
	 JRST RELTYP
	 JRST RELTYP
	JRST GETMOD

RELTYP:	MOVE A,TYPE
	JRST TYPREL		;RELEASE FREE STORAGE FOR THIS TYPE

;GET REPLACEMENT MODE

GETMOD:	MOVE T,OLDTYP
	FETCH(T,T,TYP1)
	JUMPE T,NOREPB		;DON'T HAVE TO REPLACE IF NOT USED (NOT IN)
	PUSHJ P,REPST1		;SETUP CORRESPONDENCE
	 JRST RELTYP		;GIVE UP!
DOREP:	PUSHJ P,REPLOP

;DELETE OLD TYPE BLOCK FROM LIST, ADDING NEW

NOREPB:	MOVEI A,BODPNT-V.TNXT
	 JRST FNDTP1
FNDTYP:	CAMN A,OLDTYP		;HERE'S WHERE OLD ONE IS
	 JRST FOUND
FNDTP1:	MOVE B,A
	FETCH(A,A,TNXT)
	JUMPN A,FNDTYP
	PUSHJ P,FUCKUP
	POPJ P,

FOUND:	MOVE C,TYPE
	STORE (C,B,TNXT)	;PREV  NEW
	FETCH (B,A,TNXT)	;OLD TNXT
	STORE (B,C,TNXT)	;    NEW TNXT
	FETCH(T,A,TYP1)		;WAS USED?
	JUMPN T,TYPREL		;YES, JUST RELEASE STG FROM OLD
	PUSHJ P,TYPREL
	JRST CKUBDY		;IF WASN'T USED, CHECK IF NEW TYPE IS USED

AUTORP:	MOVE B,OLDTYP
	PUSHJ P,OUTIT
	OUTSTR[ASCIZ/ BEING REPLACED BY /]
	MOVE B,NEWTYP
	PUSHJ P,OUTIT
	MOVE T,OLDTYP
	HLRZ T,1(T)
	JUMPE T,[OUTSTR[ASCIZ/
/]
		JRST NOREPB]	;NO REPLACE IF BODY NOT USED(NOT IN)
	PUSHJ P,REPCL1		;TRY DEFAULT AUTO REPLACE MODE
	 JRST RELTYP		;GIVE UP
	OUTSTR[ASCIZ/
/]
	JRST DOREP
>;MD
;MAKTYP, MAKTPN, - CREATE TYPE BLOCK, CREATE TPIN BLOCK
;RETURNS PTR IN TT

MAKTYP:	PUSH P,A
	GETBLK(TT,TYPE)
	BCLEAR(A,TT,TYPE)
MD,<
	MOVEI A,ADDR(TT,TPIN)	;SETUP DUMMY POINTERS
	STORE (A,TT,TYP1)
	MOVEI A,ADDR(TT,TBIT)
	STORE (A,TT,TYP2)
>;MD
	POP P,A
	POPJ P,

;MAKE TYPE PIN - POINTER RETURNED IN TT

MAKTPN:	PUSH P,A
	GETBLK(TT,TYPIN)
	BCLEAR(A,TT,TYPIN)
MD,<	MOVEI A,2(TT)
	STORE(A,TT,TP1)		;SETUP OLD STYLE POINTERS
>;MD
	JRST POPAJ
SUBTTL MAKPNT, MAKPIN - MAKE POINT BLOCK, BODY PIN

;MAKE POINT BLOCK, POINTER RETURNED IN TT
MAKPNT:	PUSH P,A
	GETBLK(TT,POINT)
	BCLEAR(A,TT,POINT)
	MOVEI A,2(TT)
	STORE(A,TT,P1)
	MOVEI A,4(TT)
	STORE(A,TT,P3)
MD,<	MOVEI A,6(TT)
	STORE(A,TT,PNEB)	;NEIGHBOR BLOCK
>
	JRST POPAJ

;MAKE BODYPIN BLOCK, POINTER RETURNED IN TT
MAKPIN:	PUSH P,A
	GETBLK(TT,BPOINT)
	BCLEAR(A,TT,BPOINT)
	MOVEI A,2(TT)
	STORE(A,TT,BP1)
MD,<	MOVEI A,6(TT)
	STORE(A,TT,BPNEB)	;BUILT IN NEIGHBOR BLOCK
>;MD
	MOVEI A,4(TT)
	STORE(A,TT,BP3)
	JRST POPAJ

SUBTTL READ .DRW FILE

;CALL TYPE READING SUBR, READ INSTANCES OF TYPES

;Procedure for reading .DRaWing files
;1)	read list of types used in this drawing
;2)	read list of libraries used (into LIBTMP)
;3)	read local type definitions
;4)	  recurse here to read type definitions from libraries (do 2,3,4)
;5)	re-open file and skip past type defintions
;6)	read body, point, set instances from rest of file

;LIBLST - list of libraries read into drawing

RDFILE:	MOVEM P,PERRSAV		;RETURN ONE UP FROM HERE ON INPUT ERRORS
MD,<	SETZM LIBNAM		;NO LIBRARY NAME YET
	SETZM LIBTMP
	SETZM DEPTH
	SETZM USEFLG		;ASSUME USE LIST NOT ACTIVE
	SETZM ALLFLG		;And not trying to force all of library in
	TRO FSTLIB		;FIRST LIBRARY LEVEL
	PUSHJ P,CLBMRK		;CLEAR LIBRARY NEEDMR BITS
>;MD
	PUSHJ P,MACCLR		;CLEAR TMP BIT IN MACROS
	PUSHJ P,TYPIN		;GET TYPES IN (MAY RECUR!!!)
	MOVEI F,NEWBOD		;PUT FIRST POINTER HERE
MD,<	TLNE M,TYPNLY		;ONLY TYPES?
	 POPJ P,		;GO DIRECTLY TO END DO NOT PASS SETS DO NOT SCREW UP
>;MD

;All libraries and TYPEs are in, read bodies, points, sets

	MOVEI T,[ASCIZ/BODY/]
	MOVEM T,TYPLOC
RDBOD:	PUSHJ P,WORDIN		;LOC OF BODY
	CAIN TTT,400000		;DONE?
MD,<	JRST RDPNT		>
MPC,<	JRST DOPNTX		;YES>
	PUSHJ P,CHKLOC
	MOVEM TTT,CURSE		;SAVE LOC
MPC,<	MOVE TTT,RDVER		;**RDVER
	CAIGE TTT,10		;HAVE DIP TYPE?
	JRST NODTYP
	PUSHJ P,RSTRZ		;DIP TYPE NAME
	SETZ T,			;NULL
	MOVEM T,STRING
NODTYP:
>;MPC
	PUSHJ P,WORDIN		;GET ORIENTATION
	MOVE TT,TTT
MPC,<	ANDI TTT,3	>
MD,<
	MOVE A,RDVER
	XCT %IV6(A)		;**RDVER
>;MD
	MOVEM TTT,CURORT
	SETZM LETTER
	SETZM NUMBER		;NONE SO FAR
	SETZM NUMBR1
MD,<	TRNN TT,400000		;ANY LOCATION?
	JRST NNFORM		;NO
	MOVE A,RDVER
	XCT %IV7(A)		;**RDVER
	SETZ TTT,		;(NUMBER  L,N)
	MOVE A,RDVER
	CAILE A,23		;**RDVER
	PUSHJ P,WORDIN
	MOVEM TTT,NUMBR1
>;MD
MPC,<	MOVE A,RDVER
	XCT %IV8(A)		;**RDVER
>;MPC
	MOVE A,RDVER
MD,<	CAILE A,14	>	;**RDVER
MPC,<	CAILE A,15	>	;**RDVER
	JRST NNFORM
	HRRZ A,LETTER		;MAKE SWAPPED 6 BIT BYTES
	DPB A,[POINT 6,A,23]
	LSH A,-6
	DPB A,[POINT 12,LETTER,35];INTO ONE 12 BIT BYTE
NNFORM:	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER
	JRST OLDVR1
	TLZ TTT,FOUNDB!BTMP1
	PUSH P,TTT		;SAVE BODY ID AND BITS
	JRST OLDVR2
OLDVR1:	GETFS (TT)
	MOVEM TT,(F)
	MOVE F,TT
	SETZM (F)
	HRLZM TTT,1(F)		;UNIQUE EXTERNAL NAME FOR BODY INTO NEWBOD LIST
	PUSH P,F		;SAVE NEWBOD LIST POINTER
OLDVR2:
MD,<
	PUSHJ P,RSTR		;NAME OF TYPE
	MOVEM T,STRING		;SAVE FOR GARBAGE COLLECT
	PUSHJ P,TNAME		;FIND LOCATION OF THAT TYPE (POINTER TO STRING IN )
	CAIA			;FOUND (POINTER TO TYPE IN C)
	JRST [	PUSHJ P,OUTTXT
		OUTSTR[ASCIZ/ TYPE NOT FOUND!
BODY WILL BE RELEASED!
/]
		MOVE B,STRING
		PUSHJ P,PUTFS
		POP P,F		;RESTORE NEWBOD LIST POINTER
		MOVE T,RDVER
		CAIL T,23	;**RDVER
		PUSHJ P,SKPPRP	;SKIP OVER PROPERTIESIF NOT PLACING BODY
		JRST RDBOD]	;TRY TO GO ON.
	MOVEM C,CURBOD		;SAVE TYPE POINTER
	MOVE B,STRING
	PUSHJ P,PUTFS
	SETZM BTEXT
	MOVE TT,RDVER
	CAIL TT,23		;**RDVER
	PUSHJ P,PROPIN
>;MD
MPC,<
	PUSHJ P,WORDIN		;NUMBER OF PINS
	HRRZ A,TTT
	CAIG A,2
	JRST [	MOVE T,RDVER
		CAIGE T,10	;**RDVER
		JRST [	CAIN A,1
			MOVEI T,=400/5
			CAIN A,2
			MOVEI T,=200/5
			JRST IS2PNO]
		HLRZ T,TTT
	IS2PNO:	PUSHJ P,G2PIN	;FIND OR MAKE THIS 2 PIN DIP!
		JRST FNDTYP]
FNDT12:	MOVE A,BODPNT
FNDT1:	FETCH(B,A,TNAM)		;PC TYPE "NAME" IS NUMBER OF PINS
	CAIN B,(TTT)
	JRST FNDTYP
	FETCH(A,A,TNXT)
	JUMPN A,FNDT1
	OUTSTR[ASCIZ/TYPE NOT FOUND!
BODY WILL BE RELEASED!
/]
	POP P,F		;RESTORE NEWBOD LIST POINTER
	JRST RDBOD	;TRY TO GO ON.
;PLACE INSTANCES OF TYPES
FNDTYP:	MOVEM A,CURBOD		;SAVE TYPE POINTER
>;MPC
	PUSHJ P,BPYESF		;PLACE BODY(X,Y IN CURSE;TYPE IN CURBOD;ORIENTATION IN CURORT)
	HRRZ T,LSTBOD		;NEWEST BODY
	POP P,F
	SKIPN RDVER		;**RDVER
	HRRM T,1(F)		;STORE INTERNAL POINTER IN NEWBOD LIST
	TRNN MAKSET		;MAKING SET?
	JRST NOBVIR		;NO
	GETFS(TT)		;*SET* BLOCK
	HRLZM T,1(TT)
	EXCH TT,DY3
	HRRZM TT,@DY3
	HLRE TTT,1(T)
	ADDM TTT,DX1
	HRRE TTT,1(T)
	ADDM TTT,DY1
	AOS DX3
NOBVIR:	MOVE A,LSTBOD
	SKIPN RDVER		;**RDVER
	 JRST OLDVR0
	ADD F,OLDBID
	STORE(F,A,BID)
	HLRZ T,F		;BODY BITS
	STORE(T,A,BBIT)
	HRRZ F,F
	CAMLE F,MAXBID
	MOVEM F,MAXBID
	ANDI F,LHASHB-1
	HRRZ TT,LSTBOD
	SKIPE TTT,HASHB(F)	;IS THIS BUCKET EMPTY?
	JRST BODLNK
	MOVEM TT,HASHB(F)	;YES MAKE THIS ENTRY
	MOVEI TTT,DBODPN
BODLNK:	HRRZ D,(TTT)		;ADD AFTER FIRST ENTRY IN BUCKET
	HRRM D,(TT)
	HRRM TT,(TTT)
OLDVR0:
MPC,<
	MOVE TT,LETTER
	STORE(TT,A,BLN)
	MOVE TT,STRING
	STORE(TT,A,BNAM)
	JRST RDBOD
>;MPC
MD,<	SKIPN BTEXT		;ANY BODY TEXT?
	 JRST NXBTXT
	HRRZ A,LSTBOD		;YES, FIRST COPY TYPES PROP
	PUSHJ P,COPLTP		;COPY TYPE PROP ONTO INDIRECT LIST
	MOVE B,BTEXT
	PUSHJ P,MERGEP
NXBTXT:	HRRZ A,LSTBOD
	PUSHJ P,CMPBDY		;COMPILE ANY PROPS OF BODY
	HRRZ A,LSTBOD
	SKIPN LETTER		;ANY LOC THERE?
	 JRST RDBOD		;NO, LOOP NOW
	MOVEI T,-1+ADDR(A,BLXY)	;SETUP AS FLAG
	STORE(T,A,BLOC)		;DUMMY POINTER MEANS LOC SET
GTLCBK:
DEC,<	MOVE T,RDVER		;**RDVER
	CAILE T,14		;OLD LOSING DEC VERSION?
	 JRST NLCFUD		;NO, NO FUDGE
;THIS LOOKS PRETTY RANDOM....
	SETZM CHRCNT
	MOVE A,LETTER
	PUSH P,PUTCHR
	MOVE T,[AOS CHRCNT]
	MOVEM T,PUTCHR
	PUSHJ P,SLTLPN
	POP P,PUTCHR
	MOVE T,CHRCNT
	MOVE TT,STDBIG
	IMUL T,VIRPTX(TT)
	ASH T,-1
	HRLZ T,T
	MOVE TT,VIRPTY(TT)
	ASH TT,-1
	HRR T,TT
	ADJUST(ADD,T,NUMBER)
	MOVEM T,NUMBER
NLCFUD:
>;DEC
	MOVE A,LSTBOD
	MOVE T,NUMBER		;LOC OFFSET
	STORE(T,A,BLXY)
	HRRZ T,LETTER
	MOVE TT,RDVER		;**RDVER
	PUSHJ P,LOCFUK		;MIGHT BE WRONG FORMAT BODY LOCN
	STORE(T,A,BSOC)
	HLRZ T,LETTER
	STORE(T,A,BBRS)
	MOVE T,NUMBR1		;CHAR OFFSET
	STORE(T,A,BLO)
	MOVE T,RDVER
	CAIL T,DEC,<24;>27	;**RDVER
	 JRST NLCOFF
	MOVE A,LSTBOD
	SETBIT(FIXBLO,T,A,BBIT)	;MAKE BODY LOCN'S CENTER THEMSELVES
	PUSH P,TT
	MOVE T,LSTBOD
	PUSHJ P,OFFBLO		;ADJUST BODY TEXT OFFSET
	POP P,TT
NLCOFF:	MOVE T,RDVER		;**RDVER
	CAIGE T,12		;COMING FROM VERSION WITH NO DEF OFFSET?
	 JRST RDBOD		;YES, SKIP IT
	HRRZ A,LSTBOD		;LAST BODY MADE (US)
	FETCH(TTT,A,BBIT)
	TRNN TTT,FIXLOC		;UPDATE LOC FROM TYPE?
	 JRST RDBOD		; NO, JUST OFFSET
	MOVE B,CURBOD		;TYPE
	FETCH(T,B,TXY)		;DEFAULT LOCATION OFFSET FROM TYPE
	FETCH(F,A,BORI)		;ORIENTATION
	PUSHJ P,ORIENT		;ROTATE IT
	STORE(T,A,BLXY)		;SET OFFSET TO DEF FROM TYPE FOR OLD VERSIONS
	TRNN TTT,FIXBLO		;ALSO WANT TEXT OFFSETING?
	 JRST RDBOD
	FETCH(T,B,TYP3)		;NON-ZERO IF TYPE HAS DEFAULT CHAR OFFSET
	JUMPE T,RDBOD
	FETCH(T,B,TOXY)		;DEFAULT CHAR OFFSET FROM TYPE
	STORE(T,A,BLO)
	JRST RDBOD		;GET ANOTHER ONE
>;MD
;READ POINT, FIND POINT, D PROG
MD,<
RDPNT:	PUSHJ P,WORDIN		;GET LOC OF POINT
	CAIN TTT,400000		;DONE?
	JRST RPNTDN		;YES
	MOVEI T,[ASCIZ/POINT/]
	MOVEM T,TYPLOC
	MOVEM TTT,THSLOC
	PUSHJ P,CHKLOC
	SKIPN RDVER		;**RDVER
	 JRST OLDVR3		;FIND POINT BY X,Y
	PUSH P,TTT		;SAVE LOCATION
	PUSHJ P,WORDIN		;GET PID
	TLNN TTT,-1
	 JRST PPIDF		;JUST POINT
	PUSHJ P,FFNDID
	 JRST NOBPFN		;BODY PIN NOT FOUND
	POP P,(P)
	JRST OLDVR4

NOBPFN:	JUMPE D,[OUTSTR[ASCIZ/BODY NOT FOUND/]
		JRST PFLSH]
	FETCH(D,D,BTYP)		;TYPE DEFINITION
	MOVEM D,OLDTYP
	OUTSTR[ASCIZ/PIN NOT FOUND ON /]  
	MOVE B,OLDTYP
	PUSHJ P,OUTIT
PFLSH:	OUTSTR[ASCIZ/, PIN WILL BE DELETED!
/]
	POP P,(P)		;LOSE POINT LOC
	MOVEI T,5		;SKIP NEIGHBORS AND END WITH BITS
	PUSHJ P,WORDIN
	SOJG T,.-1
	SKIPN RDVER		;**RDVER ONLY VERY OLD STUFF
	TRNN TTT,400000		;NEW FORMAT?
	 JRST NPFLSH		;NO
	PUSHJ P,WORDIN		;SKIP NUMBER WORD
	PUSHJ P,WORDIN		;READ REAL BITS (I HOPE)
NPFLSH:	TLZ TTT,FOUNDP
	MOVE A,TTT		;SAVE BITS
	MOVE T,RDVER		;**RDVER
	CAIL T,3		;THESE HAVE TEXT SIZE IN TTT
	 PUSHJ P,WORDIN		;THESE HAVE IT IN NEXT WORD
	TRNN TTT,-1
	 JRST NTFLSH
	CAILE T,4		;**RDVER THESE HAVE NO OFFSET
	 PUSHJ P,WORDIN		;THESE HAVE
	PUSHJ P,SKPSTR		;SKIP TEXT
	 JFCL
NTFLSH:	TLNN A,CPIN		;CONNECTOR PIN?
	 JRST RDPNT
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
	JRST RDPNT

PPIDF:	EXCH TTT,(P)
	MOVE T,TTT
	PUSHJ P,HSHPUT			;ADD POINT TO HASH LIST
	POP P,TTT
	ADD TTT,OLDPID
	STORE(TTT,D,PID)
	CAMLE TTT,MAXPID	;LARGEST YET?
	 MOVEM TTT,MAXPID	;NO, REMEMBER
	MOVE TT,TTT
	ANDI TT,LHASHP-1	;FORM HASH CODE FROM LOW BITS OF PIN ID
	HRRZ TTT,@PHASHP
	HRRM D,@PHASHP
	STORE(TTT,D,PNXT)
	SKIPN TTT
	 HRLM D,@PHASHP		;NEW END OF BUCKET
	JRST OLDVR4
;MORE READ POINT, LINES, D PROG
OLDVR3:	PUSHJ P,FIND.P		;FIND THE POINT (OR MAKE ONE)
OLDVR4:	MOVE E,D		;CURRENT POINT
	MOVE G,RDVER		;FOR INDEXING
;Read DOWN-neighbor
	PUSHJ P,WORDIN		;DOWN
	FETCH(T,E,PND)
	SKIPN T
	 XCT %IV10(G)		;**RDVER
	 JRST NNDOWN
	CAMN TTT,THSLOC		;XCT USUALLY JUMPS AROUND THIS STUFF
	 JRST NNDOWN
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P		;FIND HIM(OR MAKE HIM)
OLDVRD:	CAMN E,D
	 JRST NNDOWN		;NOT TO OURSELVES
	STORE(D,E,PND)
	STORE(E,D,PNU)
;Read UP-neighbor
NNDOWN:	PUSHJ P,WORDIN
	FETCH(T,E,PNU)
	SKIPN T
	 XCT %IV11(G)		;**RDVER
	 JRST NNUP
	CAMN TTT,THSLOC
	 JRST NNUP
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P		;FIND UP (OLDVER)
OLDVRU:	CAMN E,D		;NOT TO OURSELF??
	 JRST NNUP
	STORE(D,E,PNU)
	STORE(E,D,PND)
;Read LEFT-neighbor
NNUP:	PUSHJ P,WORDIN
	FETCH(T,E,PNL)
	SKIPN T
	 XCT %IV12(G)		;**RDVER
	 JRST NNLEFT
	CAMN TTT,THSLOC
	 JRST NNLEFT
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P
OLDVRL:	CAMN E,D
	 JRST NNLEFT
	STORE(D,E,PNL)
	STORE(E,D,PNR)
;Read RIGHT-neighbor
NNLEFT:	PUSHJ P,WORDIN
	FETCH(T,E,PNR)
	SKIPN T
	 XCT %IV13(G)		;**RDVER
	 JRST NNRIGHT
	CAMN TTT,THSLOC
	 JRST NNRIGHT
	PUSHJ P,CHKLOC
	MOVE T,TTT
	PUSHJ P,FIND.P
OLDVRR:	CAMN E,D
	 JRST NNRIGHT
	STORE(D,E,PNR)
	STORE(E,D,PNL)
NNRIGHT:MOVE D,E		;POINT IN D
>;MD
;READ POINT, FIND, MAKE LINES, PC PROG
MPC<
DOPNTX:	MOVEI T,[ASCIZ/POINT/]
	MOVEM T,TYPLOC
	PUSHJ P,RDPNT
	FSWITCH
	PUSHJ P,RDPNT
	FSWITCH
	JRST RPNTDN

RDPNT:	PUSHJ P,WORDIN		;GET X,Y OF POINT
	CAIN TTT,400000		;DONE?
	 POPJ P,		;YES
	PUSHJ P,CHKLOC		;LEGAL X,Y?
	SKIPN RDVER		;**RDVER
	 JRST OLDVR5
	PUSH P,TTT
	PUSHJ P,WORDIN
	TLNN TTT,-1
	 JRST RDPOK
	PUSHJ P,FFNDID		;BODY PIN
	 JRST RPLOSE
	POP P,(P)
	JRST OLDVR6

RDPOK:	EXCH TTT,(P)
	MOVE T,TTT
	PUSHJ P,HSHPUT
	POP P,TTT
	ADD TTT,OLDPID
	STORE(TTT,D,PID)
	CAMLE TTT,MAXPID	;LARGEST YET?
	 MOVEM TTT,MAXPID	;NO, REMEMBER
	MOVE TT,TTT
	ANDI TT,LHASHP-1	;FORM HASH CODE FROM LOW BITS OF PIN ID
	HRRZ TTT,@PHASHP
	HRRM D,@PHASHP
	STORE(TTT,D,PNXT)
	SKIPN TTT
	 HRLM D,@PHASHP		;NEW END OF BUCKET
	JRST OLDVR6
OLDVR5:	PUSHJ P,FIND.P		;FIND THE POINT ( D) (OR MAKE ONE) 
OLDVR6:	MOVE H,D		;P1
	PUSH P,D		;SAVE POINT ON STACK
RDSEG:	PUSHJ P,WORDIN		;GET P2
	SKIPE RDVER		;**RDVER
	JRST [	JUMPN TTT,OLDVR7
		JRST RDSEGN]
	CAIN TTT,400000
	JRST RDSEGN
	PUSHJ P,CHKLOC
OLDVR7:	SKIPE RDVER		;**RDVER
	JRST [	PUSHJ P,FFNDID
		JRST RDSEG		;NOT IN YET
		JRST .+2]
	PUSHJ P,FIND.P
	CAMN D,H		;P2 NEQ P1 ?
	 JRST RDSEG		;NOT TO OURSELVES
	FETCH(B,D,PNEB)		;P2'S NEIGHBORS
	MOVE A,H
	PUSHJ P,FNDLNK		;ALREADY A LINE?
	 CAIA			;NO, MAKE ONE
	 JRST RDSEG		;YES, NOT AGAIN
	MOVE T,H
	PUSHJ P,FRLINK
	XCT (T)PUTAB		;P1 to P2
	MOVE T,D
	PUSHJ P,FRLINK
	MOVE D,H
	XCT (T)PUTAB		;P2 to P1
	JRST RDSEG

RPLOSE:	OUTSTR[ASCIZ/PIN OR BODY NOT FOUND!
/]
	PUSHJ P,FUCKUP
	PUSHJ P,WORDIN		;SKIP NEIGHBORS
	JUMPN TTT,.-1
	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER
	TRNN TTT,400000
	JRST NPFLSH
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
NPFLSH:	MOVE T,RDVER
	CAIL T,6		;**RDVER
	PUSHJ P,WORDIN		;TEXT SIZE HERE FOR LATER VERSIONS
	TRNN TTT,-1		;ANY TEXT?
	JRST NTFLSH		;NO
	CAILE T,4		;**RDVER ANY OFFSET?
	PUSHJ P,WORDIN		;YES, SKIP IT
	PUSHJ P,SKPSTR		;SKIP TEXT
	JFCL
NTFLSH:	PUSHJ P,WORDIN		;SKIP FEEDTHROUGH
	JRST RDPNT

RDSEGN:	POP P,D			;POINT
	;FALL INTO CODE ON NEXT PAGE
>;MPC
;READ REST OF POINT INFO
;D = POINT
	PUSHJ P,WORDIN
	SKIPN RDVER		;**RDVER ONLY VERY OLD STUFF
	TRNN TTT,400000		;NEW FORMAT?
	JRST NPFORM		;NO
	PUSHJ P,WORDIN		;SKIP NUMBER WORD
	PUSHJ P,WORDIN		;READ REAL BITS (I HOPE)
NPFORM:				;TTT = BITS,,PAD#
	HLRZ TT,TTT
MPC,<	ANDI TT,PLANES		;JUST THESE	>
MD,<	ANDI TT,CPIN!CPNBTS!FIXTXT!FIXRHT!FIXCON		;JUST THESE
	MOVE T,RDVER
	CAIGE T,12		;**RDVER THESE GUYS HAVE IT
	TRZ TT,FIXTXT!FIXRHT!FIXCON	;THESE DON'T
>;MD
	FETCH(T,D,PBIT)
	IOR TT,T
	STORE(TT,D,PBIT)	;OR IN POWER AND GROUND BITS.
	TRNE MAKSET		;MAKING SET?
	TRNE TT,MPC,<CPIN!>ISPIN	;YES, PUT THIS ONE IN IT?
	CAIA			;NO
	PUSHJ P,VIRSET		;D = POINT
	MOVE T,RDVER
	XCT %IV14(T)		;**RDVER READ PAD OR PIN #, ETC.
				;MAYBE READ NEXT WORDIN
	TRNN TTT,-1		;SIZE OF TEXT
	JRST [	SETZ T,
		JRST RNOTXT]
	MOVE T,RDVER
	CAIGE T,4		;**RDVER
	TRZN TTT,10
	CAIA
	TRO TTT,400000
	HRRZ TT,TTT
	ANDI TTT,377777		;MASK JUST SIZE
	CAILE TTT,CSIZES	;LEGAL?
	JRST [	OUTSTR[ASCIZ/ILLEGAL SIZE IN POINT TEXT.
WILL CHANGE TO STANDARD SIZE.
/]
		TRZ TT,377777
		TRO TT,@STDBIG
		JRST .+1]
	CAIG T,4		;**RDVER
	TDZA TTT,TTT
	PUSHJ P,WORDIN
	GETBLK(T,TEXCOF)
	STORE(TTT,T,TCXY)
	PUSH P,T
	PUSHJ P,RSTRZ
	JRST [	POP P,T		;NO TEXT
		RETBLK(T,TEXCOF)
		SETZ T,
		JRST RNOTXT]
	STORE(TT,T,TSSIZ)
	HRRZM T,@(P)		;LINK INTO TEXCOF HEADER
	POP P,T
RNOTXT:	STORE(T,D,PTXT)
MD,<	FETCH(TTT,D,PBIT)
	TRNN TTT,CPIN		;DO WE HAVE TO READ CONNECTOR PIN LOC?
	 JRST NRCPIN		;NO
	GETFS (T)		;PLOC *BLOCK*
	STORE(T,D,PLOC)		;LINK IN NEW BLOCK
	PUSHJ P,WORDIN
	MOVE A,RDVER
	XCT %IV17(A)		;**RDVER
	MOVE A,RDVER
	CAILE A,24		;**RDVER
	JRST NRCPIN
	CLRBIT(CPNBTS,TTT,D,PBIT)	;CLEAR BITS IN OLD VERSIONS
	MOVE A,D		;POINT IN A
	MOVE T,(T)
	PUSHJ P,CPNBCK		;CHECK FOR U PIN
	FETCH(T,A,PIN)		;BACKUP PIN (?)
	PUSHJ P,CPNBCK		;CHECK THIS ALSO
NRCPIN:
>;MD
	;READ FEEDTHRU (IF ANY)
MPC,<	PUSHJ P,WORDIN
	CAIN TTT,400000
	JRST RDPNT
	SKIPE RDVER		;**RDVER
	JRST OLDVR8
	PUSHJ P,CHKLOC		;REASONABLE X,Y ?
	MOVE G,D
	PUSHJ P,RDFEED		;CREATE FEEDTHRU ON OTHER SIDE
	JFCL			;LOSERS LOSE
	JRST RDPNT

OLDVR8:	MOVE H,D		;H = FIRST POINT
	FSWITCH			;GOT ID OF OTHER POINT
	PUSHJ P,FFNDID
	 JRST NOOLDV
	FETCH(TT,D,PBIT)
	TRNE TT,ISPIN!FEEDTH!CPIN
	 JRST NOOLDV		;OOPS, ALREADY FEEDTHRU?
	TRO TT,FEEDTH
	STORE(TT,D,PBIT)
	FETCH(TTT,D,PIN)
	TLNE M,TYPNLY
	SKIPE TTT
	CAIA
	MOVEI TTT,1
	STORE(TTT,D,PIN)	;DEFAULT FEEDTHRU PAD IS 1
	STORE(H,D,PFEED)
	STORE(D,H,PFEED)
	SETBIT(FEEDTH,TTT,H,PBIT)
	FETCH(TTT,H,PIN)	;PAD#
	TLNE M,TYPNLY
	TRNE TTT,-1
	CAIA
	HRRI TTT,1
	STORE(TTT,H,PIN)
NOOLDV:	FSWITCH
>;MPC
	JRST RDPNT

;VIRSET - ENTER ITEM ONTO VIRTUAL SET
;D = ITEM

VIRSET:	SKIPN T,DY3
	JRST VIRST1		;FIRST POINT IN SET
	HRRZ TT,1(T)
	JUMPE TT,VIRST2		;SEARCH FOR EMPTY ENTRY(?)
	HRRZ T,(T)
	JUMPN T,.-3
VIRST1:	GETFS(T)		;*SET* BLOCK
	SETZM 1(T)
	MOVE TT,DY3
	HRRZM TT,(T)
	HRRZM T,DY3
VIRST2:	HRRM D,1(T)
	HLRE T,ADDR(D,QX)
	ADDM T,DX1
	HRRE T,ADDR(D,QY)
	ADDM T,DY1
	AOS DX3
	POPJ P,
;READ SETS
RPNTDN:	PUSHJ P,WORDIN
	CAIE TTT,400000
	CAIN TTT,400001
	JRST SETDON
	MOVEI G,NEWSET
	SETZM NEWSET
	PUSH P,TTT
RDSBOD:	PUSHJ P,WORDIN
	JUMPE TTT,SBODN		;END OF BODIES IN THIS SET
	SKIPE RDVER		;**RDVER
	JRST [	PUSHJ P,FNDBID
		JRST RDSBOD
		JRST OLDV10]
	MOVE T,TTT
	PUSHJ P,FIND.B
	JRST RDSBOD		;COULDN'T FIND, GO TO NEXT
OLDV10:	GETFS(A)		;GET BLOCK FOR IT
	HRLZM B,1(A)		;SAVE POINTER
	SETZM (A)		;CLEAR LINK
	MOVEM A,(G)		;LINK ON END OF SET
	MOVE G,A		;NEW END
	JRST RDSBOD		;NEXT
SBODN:	MOVEI G,NEWSET
	MOVE H,RDVER
RDSPNT:	PUSHJ P,WORDIN		;READ POINT LOC
	XCT %IV18(H)		;**RDVER
	JRST SPNTDN		;YES
MD,<	PUSHJ P,FIND.P		;FIND POINT>
MPC,<
	SKIPE D,PONPNT
	PUSHJ P,FP1
	CAIA
	JRST [	CHKOTH:	SKIPN A,NEWSET
			JRST THISOK
		CHKLOP:	HRRZ T,1(A)
			CAIN T,(D)
			JRST .+1
			HRRZ A,(A)
			JUMPN A,CHKLOP
			JRST THISOK]
	SKIPE D,PONPN2
	 PUSHJ P,FP1
	 CAIA
	 JRST THISOK
	MOVE T,TTT
	PUSHJ P,PNTPUT
THISOK:	>;MPC

;SET IN, PUT IN STRUCTURE, OR FLUSH -- READ SPECIAL STRINGS -- CARD SUBR
OLDV11:
	HRRZ A,(G)
	JUMPN A,GOTIT		;WE HAVE A NEXT BLOCK
	GETFS(A)
	SETZM (A)		;CLEAR LINK
	SETZM 1(A)		;CLEAR DATA
	MOVEM A,(G)
GOTIT:	MOVE G,A
	HRRM D,1(G)		;SAVE POINT POINTER IN SET
	JRST RDSPNT
SPNTDN:	SKIPN NEWSET
	JRST [	OUTSTR[ASCIZ/FLUSHING NULL SET!
/]
		POP P,(P)	;POP OFF SET CENTER
		JRST RPNTDN]
	GETFS(A)
	POP P,1(A)		;SAVE CENTER OF SET
	HRLZ B,NEWSET
	HRR B,SETPNT
	MOVEM B,(A)		;LINK IN SET
	MOVEM A,SETPNT
	JRST RPNTDN		;READ ANOTHER
SETDON:

;READ AUTHOR, TITLE, ETC. STRINGS

MD,<	MOVE T,RDVER		;**RDVER
	CAIGE T,4
	JRST NOTIT
FOR I IN(TAUTHOR,TIT1,TIT2)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
	MOVE T,RDVER		;**RDVER
	CAIGE T,10
	JRST NOTIT
	PUSHJ P,WORDIN
	CAMN TTT,CRDLOC
	JRST REVMOD
	JUMPE TTT,REVMOD
	EXCH TTT,CRDLOC		;CARD LOC FOR WHOLE CARD!
	JUMPE TTT,REVMOD
	OUTSTR[ASCIZ/NEW CRDLOC DIFFERENT FROM OLD ONE, WILL USE NEW ONE!
/]
REVMOD:	MOVE T,RDVER		;**RDVER
	CAIGE T,15
	JRST NOTIT
	MOVEI TT,TREV
	PUSHJ P,GSTR
	MOVE T,RDVER
	CAIL T,MODIOV		;**RDVER
	JRST HASMVP		;HAS MODULE, VARIABLE, PREFIX
	PUSHJ P,RSTRZ		;READ OLD MODULE STRING
	JRST NOTMVP		;NONE IS EASY
	PUSH P,T		;SAVE POINTER FOR RETURN
	ADD T,[POINT 7,1]
	PUSHJ P,SETTT7
	MOVEM A,TMODULE
TMODLP:	PUSHJ P,GETTT
	JRST MODEOF
	CAIN C,"-"
	JRST TMODDN
	PUTBYT (C)
	JRST TMODLP

TMODDN:	PUSHJ P,SETTT7
	MOVEM A,TVARIABLE
TVARLP:	PUSHJ P,GETTT
	JRST MODEOF
	CAIN C,"-"
	JRST TVARDN
	PUTBYT (C)
	JRST TVARLP

TVARDN:	PUSHJ P,SETTT7
	MOVEM A,TPREFIX
TPRFLP:	PUSHJ P,GETTT
	JRST MODEOF
	PUTBYT (C)
	JRST TPRFLP

MODEOF:	POP P,B
	PUSHJ P,PUTFS
	JRST NOTMVP

HASMVP:	FOR I IN(TMODULE,TVARIABLE,TPREFIX)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
NOTMVP:	MOVE T,RDVER		;**RDVER
	CAIGE T,16		;NEWEST STRINGS?
	JRST NOTIT		;NO
FOR I IN(TPROJ,TPAGE,TOF,TDCODE,SITE1,SITE2)
<	MOVEI TT,I
	PUSHJ P,GSTR
>
DEC,<	MOVE T,RDVER
	CAIGE T,20
	JRST NOTIT
	MOVEI TT,TNXTHI
	PUSHJ P,GSTR
FOR @$I IN(DRN,CHK,ENG)
<	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM
	JUMPE TTT,NOR$I
	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM+1
	PUSHJ P,WORDIN
	MOVEM TTT,I$NAM+3
NOR$I:
>
;BEGIN BUG FIX  ***********
	SETZM CHKNAM		;FLUSH CHECKED SIGNATURE
;END BUG FIX **************
>;DEC
NODEC,<	MOVE T,RDVER
	CAIGE T,26
	JRST NOTIT
	PUSHJ P,RSTRZ
	JRST NNXTHI
	MOVE B,T
	PUSHJ P,PUTFS
NNXTHI:
FOR @$I IN(DRN,CHK,ENG)
<	PUSHJ P,WORDIN
	JUMPE TTT,NOR$I
	PUSHJ P,WORDIN
	PUSHJ P,WORDIN
NOR$I:
   >
>;NODEC
NOTIT:	MOVE T,RDVER
	CAIN T,BRDIOV		;**RDVER
	PUSHJ P,RDNOM
	POPJ P,
>;MD
MPC,<	CAIE TTT,400001
	POPJ P,
	PUSHJ P,WORDIN
	MOVE T,RDVER
	XCT %IV20(T)		;**RDVER
	POPJ P,

;CARDIO
;SEPERATE CALL ON THIS GUY TO AVOID ASSIGNING OLD POINT ID'S AND SCREWING SETS

CARDIO:	MOVE TTT,RDVER		;**RDVER
	CAIGE TTT,17
	JRST OLDCRD
	TRNN VIRGIN
	SKIPN CRDNAM
	CAIA
	JRST NOTNEW		;SKIP CARD IF ALREADY ONE AND NOT VIRGIN
	PUSHJ P,CRDREL
	PUSHJ P,WORDIN
	MOVEM TTT,CRDNAM
	PUSHJ P,WORDIN
	MOVEM TTT,CRDEXT
	PUSHJ P,WORDIN
	MOVEM TTT,CRDPPN
	SKIPN CRDNAM
	POPJ P,
	PUSHJ P,GETCRD
	JRST [	OUTSTR[ASCIZ/ERROR WHILE READING CARD!
/]
		JRST CRDREL]
	POPJ P,

NOTNEW:	PUSHJ P,WORDIN		;SKIP CARD NAME IF WE AREN'T GOING TO USE IT
	PUSHJ P,WORDIN
	JRST WORDIN

OLDCRD:	PUSHJ P,WORDIN
	JUMPE TTT,CPOPJ		;RETURN IF NO OLD CARD #
	OUTSTR[ASCIZ/OLD VERION USED CARD # /]
	MOVE T,TTT
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
BUT NOW I NEED A FILENAME.
/]
	JRST DOCARD
>;MPC


;HERE TO READ AND DECODE BOARD TYPE

MD,<
RDBRD:	MOVE T,RDVER
	CAIGE T,NOMVER		;**RDVER
	POPJ P,			;NOTHING HERE YET
	PUSHJ P,RSTRZ		;READ BOARD TYPE, ASCIZ STRING
	POPJ P,			;NO BOARD SPECIFIED
	MOVE B,T		;THE NAME WE JUST READ
RDBRD0:
MD,<	TRNN FSTLIB		;ONLY CHECK BOARD TYPE FOR TOP LEVEL LIBRARY
	POPJ P,
>;MD
	PUSHJ P,FNDWW
	JRST [	MOVE T,RDVER
		CAIGE T,NOMVER	;ARE WE DEFAULTING?
		JRST PUTFS	;YES, IGNORE FAILURE
		OUTSTR [ASCIZ /UNKNOWN BOARD TYPE: /]
		MOVE T,B
		PUSHJ P,OUTTXT
		OUTSTR[ASCIZ/
/]
		JRST PUTFS]
	MOVEI C,-WNAMES(C)
	PUSHJ P,PUTFS		;PUT THE NAME BACK IN FREE STORAGE
RDBRD1:
MD,<	TRNN FSTLIB		;ONLY FOR TOP LEVEL LIBRARY
	POPJ P,
>;MD
	SKIPGE WWTYP		;IF NO BOARD TYPE YET,
	JRST RDBRD2
	CAMN C,WWTYP		;DO BOARD TYPES AGREE?
	POPJ P,			;YES, ALL IS WELL
	OUTSTR [ASCIZ /BOARD TYPES OF FILE AND PROGRAM DISAGREE,
BOARD TYPE OF PROGRAM = /]
	MOVE T,WWTYP
	OUTSTR @WNAMES(T)
	OUTSTR [ASCIZ /
BOARD TYPE FROM FILE = /]
	OUTSTR @WNAMES(C)
	OUTSTR [ASCIZ /
/]
	TRNE VIRGIN
	JRST RDBRD3
	OUTSTR [ASCIZ /DRAWING ALREADY EXISTS, WILL RETAIN PROGRAM BOARD TYPE.
/]
	POPJ P,

RDBRD3:	OUTSTR [ASCIZ /NO DRAWING YET, WILL USE BOARD TYPE FROM FILE.
/]
RDBRD2:	MOVEM C,WWTYP
	JRST SETWW
>;MD


;READ NOMENCLATURE

RDNOM:	MOVE T,RDVER
	CAIGE T,BRDIOV		;**RDVER
	JRST [
MD,<		MOVEI C,DEFWW
		PUSHJ P,RDBRD1	;SET BOARD TYPE
>;MD
		MOVEI C,DEFNOM
		JRST RDNOM1]	;NOW NOMENCLATURE
	PUSHJ P,RSTRZ		;READ NOMENCLATURE TYPE, ASCIZ STRING
	POPJ P,			;NO NOMENCLATURE SPECIFIED
	MOVE B,T		;THE NAME WE JUST READ
	PUSHJ P,FNDNOM
	JRST [	OUTSTR [ASCIZ /UNKNOWN NOMENCLATURE TYPE: /]
		MOVE T,B
		PUSHJ P,OUTTXT
		OUTSTR[ASCIZ/
/]
		JRST PUTFS]
	MOVEI C,-LNAMES(C)
MD,<	MOVE T,RDVER
	CAIGE T,NOMVER		;**RDVER DO WE HAVE BOARD TYPE SEPERATELY?
	JRST RDNOM0		;NO, SPECIAL HANDLING
>;MD
	PUSHJ P,PUTFS		;PUT THE NAME BACK IN FREE STORAGE
RDNOM1:	SKIPGE NOMTYP		;IF NO BOARD TYPE YET,
	JRST RDNOM4		;THEN SET THIS
	CAMN C,NOMTYP		;DO BOARD TYPES AGREE?
	POPJ P,			;YES, ALL IS WELL
	MOVE T,NOMTYP
	MOVE T,LOCTVV(T)	;GET NOMENCLATURE TABLE POINTER
	CAMN T,LOCTVV(C)	;SAME NOMENCLATURE?
	POPJ P,			;YES
	OUTSTR [ASCIZ /NOMENCLATURE TYPES OF FILE AND PROGRAM DISAGREE,
NOMENCLATURE TYPE OF PROGRAM = /]
	MOVE T,NOMTYP
	OUTSTR @LNAMES(T)
	OUTSTR [ASCIZ /
NOMENCLATURE TYPE FROM FILE = /]
	OUTSTR @LNAMES(C)
	OUTSTR [ASCIZ /
/]
MD,<	TRNN FSTLIB		;IF TOP LEVEL, ONE MESSAGE
	JRST RDNOM2		;ELSE ANOTHER
>;MD
	TRNN VIRGIN
	JRST RDNOM3
	OUTSTR [ASCIZ /NO DRAWING YET, WILL USE NOMENCLATURE TYPE FROM FILE.
/]
RDNOM4:	MOVEM C,NOMTYP
	JRST SETNOM

RDNOM3:	OUTSTR [ASCIZ /DRAWING ALREADY EXISTS, WILL RETAIN PROGRAM NOMENCLATURE TYPE.
/]
	POPJ P,

MD,<
RDNOM0:	PUSH P,B
	PUSHJ P,RDNOM1		;SET NOMENCLATURE
	POP P,B
	JRST RDBRD0		;NOW TRY FOR BOARD TYPE

RDNOM2:
NOITS,<	OUTSTR[ASCIZ/FILE IS ONLY LIBRARY, WILL RETAIN PROGRAM NOMENCLATURE TYPE.
/]
>;NOITS
	POPJ P,
>;MD
SUBTTL	'DAT'		READ WAGNER'S ROUTER FILES
MPC,<
DREADR:
NOWAG,<	JRST PERRET	>
WAG,<
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/ROUTER INPUT (DAT) /]
	MOVEI H,' ! '
	ADD H,LASTWR			;LAST WIRE FILE READ!
	EXCH H,LSTNAM			;TEMPORARILY MAKE THIS 
	MOVSI T,EXTROU
	PUSHJ P,SETNAM
	JRST [	MOVEM H,LSTNAM
		POPJ P,]
	MOVEM H,LSTNAM
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEM P,PERRSAV
	MOVE T,FILNAM
	MOVEM T,LASTWR			;SAVE LAST NAME READ SUCCESSFULLY
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	MOVEI T,ROUXMM*ROUSCL
	MOVEM T,MINX
	MOVEI T,ROUYMM*ROUSCL
	MOVEM T,MINY
	MOVEM SID,SIDSAV		;REMEMBER WHICH SIDE WE STARTED ON
ROULP1:	PUSHJ P,GETXY
	JRST ROUDN			;END ON 0,0
	EQV B,SID
	JUMPL B,ROULP3
	SWITCH				;START ON PROPER SIDE
ROULP3:	PUSHJ P,FIND.P			;FIND OR MAKE THIS POINT
	HRL D,TTT
	MOVEM D,MAXY
ROULP2:	PUSHJ P,ATWIRE			;TRY TO ATTACH POINT IN MAXY TO ANY LINE
	PUSHJ P,GETXY
	JRST ROULP1			;END OF THIS WIRE, LOOP
	MOVE D,MAXY
	MOVEM D,MAXX			;BACKUP POINTS
	EQV B,SID			;RIGHT SIDE?
	JUMPGE B,ROUFED			;FEED THROUGH MAYBE?
	CAMN TTT,1(D)			;NULL SEGMENT?
	JRST ROULP2			;YES, LOOP BACK FOR ANOTHER (WAGNER IS A CROCK!!)
	PUSHJ P,FIND.P			;FIND NEXT POINT
	MOVEM D,MAXY
	HRRZ T,MAXX
	PUSHJ P,FRLINK
	XCT PUTAB(T)
	HRRZ T,MAXY
	PUSHJ P,FRLINK
	HRRZ D,MAXX
	XCT PUTAB(T)
	JRST ROULP2

ROUFED:	PUSH P,TTT
;	PUSHJ P,ATWIRE			;TRY TO ATTACH THIS SIDE
	POP P,TTT
	HRRZ G,MAXX
	CAMN TTT,ADDR(G,PXY)		;SHOULD BE AT THE SAME PLACE!
	PUSHJ P,RDFEED			;TRY TO FEED THROUGH
	JRST [	OUTSTR[ASCIZ/COULDN'T FEED THROUGH AT /]
		FETCH(TTT,G,PXY)
		PUSHJ P,CNTFED
		SWITCH
		PUSHJ P,FIND.P
		HRL D,TTT
		MOVEM D,MAXY
		JRST ROULP2]		;TRY TO GO ON
	HRL D,TTT
	MOVEM D,MAXY
	SWITCH
;	PUSHJ P,ATWIRE			;NOW THIS SIDE
	JRST ROULP2

;ATTACH TO WIRE

ATWIRE:	PUSH P,CURSE
	HRRZ D,MAXY
	FETCH(T,D,PXY)
	MOVEM T,CURSE
	PUSHJ P,CLSLIN			;SEE IF THERE IS A CLOSEST LINE
	POP P,CURSE
	JUMPE A,CPOPJ			;NO
	MOVE T,DIFSOF
	CAIL T,=10*=10*4/=25		;LESS TEN MILS?
	POPJ P,				;NO
	HRRZ T,A
	HLRZ TT,A
	HRRZ D,MAXY			;THIS WAS CLOBBERED BY CLSLIN
	CAIE T,(D)			;MAKE SURE WE AREN'T EITHER ENDPOINT
	CAIN TT,(D)
	POPJ P,
	PUSH P,A			;SAVE CLOSESTS
	FETCH(B,A,PNEB)
	HLRZ A,(P)
	PUSHJ P,FNDLNK			;FIND THE POINTER
	 JRST ROFERR
	HRRZ D,MAXY
	XCT PUTAB(T)			;STORE POINTER TO D INSTEAD
	HRRZ T,MAXY			;DATA BLOCK POINTER
	PUSHJ P,FRLINK
	HRRZ D,(P)
	XCT PUTAB(T)
	HLRZ B,(P)
	FETCH(B,B,PNEB)
	HRRZ A,(P)
	PUSHJ P,FNDLNK
	 JRST ROFERR
	HRRZ D,MAXY
	XCT PUTAB(T)
	HRRZ T,MAXY
	PUSHJ P,FRLINK
	HLRZ D,(P)
	XCT PUTAB(T)
NOCLN1:	POP P,(P)
	POPJ P,

ROFERR:	OUTSTR[ASCIZ/MISSING LINE POINTER AT ATWIRE!
/]
	PUSHJ P,FUCKUP
	JRST NOCLN1

ROUDN:	RELEASE DAT,
	TRO MCHG!NEEDCL
	MOVE T,SIDSAV			;GET SIDE WE STARTED ON
	EQV T,SID
	JUMPL T,CPOPJ			;ALREADY ON RIGHT SIDE?
	SWITCH				;NO, CHANGE
	POPJ P,

;GETXY

GETXY:	PUSHJ P,GETN
	JUMPE T,GETZ			;SHOULD BE END
	CAIL T,SIDDIF*ROUSCL
	TLZA B,FRONT			;ON BACK
	TLOA B,FRONT			;ON FRONT
	SUBI T,SIDDIF*ROUSCL		;SUBTRACT SIDE DIF
	CAIL T,SIDDIF*ROUSCL
	PUSHJ P,EVALUE			;TOO LARGE
	CAIN T,ROUXMB*ROUSCL
	MOVEI T,LCEDGE*ROUSCL		;LEFT CONNECTOR EDGE
	CAIN T,ROUXMT*ROUSCL
	MOVEI T,RCEDGE*ROUSCL		;RIGHT	"
	SUB T,MINX
	HRLM T,(P)
	PUSHJ P,GETN
	SKIPE T
	CAIL T,ROUYMT*ROUSCL
	PUSHJ P,EVALUE
	SUB T,MINY
	HLL T,(P)
	MOVE TTT,T
	JRST CPOPJ1

EVALUE:	OUTSTR[ASCIZ/ILLEGAL VALUE AT GETXY.
WILL SUBSTITUTE 1.
/]
	MOVEI T,1
	POPJ P,

GETZ:	PUSHJ P,GETN
	JUMPE T,CPOPJ
	PUSHJ P,FUCKUP
	SETZ T,
	POPJ P,

GETN:	SETZ T,
	MOVEI TT,4
GETN1:	SOSG IOHD+2
	IN DAT,
	CAIA
	JRST [	OUTSTR[ASCIZ/UNEXPECTED EOF!
/]
		MOVEI TTT,"0"
		JRST .+2]
	ILDB TTT,IOHD+1
	JUMPE TTT,GETN1
	CAIE TTT,15
	CAIN TTT,12
	JRST GETN1
	ANDI TTT,17		;MAKE A NUMBER OUT OF IT
	IMULI T,=10
	ADD T,TTT
	SOJG TT,GETN1
	IMULI T,ROUSCL		;MAKE INTO INTERNAL FORMAT
	POPJ P,
>;WAG
>;MPC
SUBTTL 'WDR'	'LES'	READ LOGIC WIRE LIST AND MAKE INTERNAL POINTERS
UML,<
MD,<
IERRS:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LOGIC ERROR SUMMARY (LES) /]
	MOVSI T,EXTLES
	PUSHJ P,SETNAM
	POPJ P,
	TLO WFLAG
	JRST READWA
>;MD

READW:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/LOGIC WIRE LIST (FROM WL PROG) (WDR) /]
	MOVSI T,EXTWDR
	PUSHJ P,SETNAM
	POPJ P,				;LET HIM OUT
	TLZ WFLAG
READWA:	INIT DAT,10
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	PUSHJ P,WORDIN
MD,<	TLNN WFLAG
	SKIPA TT,[WDRVER]
	MOVEI TT,LESVER
	CAME TTT,TT			;RIGHT VERSION?
>;MD
MPC,<	CAIE TTT,WDRVER	>
	JRST [	OUTSTR[ASCIZ/, VERSION # MISMATCH!
/]
		RELEASE DAT,
		POPJ P,]
	OUTSTR[ASCIZ/
/]
MD,<	TLNN WFLAG
	JRST GWVER
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/FILENAME OTHER THAN CURRENT DEFAULT?/]
	PUSHJ P,GETWRD
	CAIE C,12
	JRST INNERR			;LOSE
	JUMPN T,.+3
	SKIPN T,LSTNAM			;PICKUP DEFAULT
	JRST [	OUTSTR[ASCIZ/NO DEFAULT NAME!
/]
		RELEASE DAT,
		POPJ P,]
	MOVEM T,PARNAM
GWVER:
>;MD
	PUSHJ P,RELWIR
	SETZM COUNT			;CLEAR UNASSIGNED BODY LOC COUNTER
MPC,<	JRST RWWIR	>
MD,<	SETZM %LAST			;INIT SIGNAL COUNTER
	TLNN WFLAG			;LES FILE?
	JRST RWWIR
TRYCAT:	PUSHJ P,WORDIN
	JUMPE TTT,RWDONE		;THAT'S ALL IF ZERO ERROR CODE
	MOVEM TTT,ERCODE
	PUSHJ P,RSTR
	MOVE B,T
	TLNN M,DSKACT!MACACT
	PUSHJ P,OUTTXT
	PUSHJ P,PUTFS
	PUSHJ P,YORN
	JRST RWDONE			;ALTMODE
	CAIA				;NO, SKIP THIS CATEGORY
	JRST RWWIR			;YES, READ THIS CATEGORY
SKPCAT:	PUSHJ P,SKPSTR
	JRST TRYCAT
SKPCT1:	PUSHJ P,SKPSTR
	JRST SKPCT2
	JRST SKPCT1

SKPCT2:	PUSHJ P,WORDIN
	JUMPE TTT,SKPCAT
	PUSHJ P,WORDIN
	JRST SKPCT2
>;MD

RWWIRX:	JUMPE H,RWWIR
MD,<	TLNE WFLAG			;IERRORS
	SKIPE DX1			;AND NO PINS READ?
	JRST IERSOM			;NOT IERRORS, OR FOUND SOME
	MOVE A,H			;FLUSH WIRES WITH NO PINS
NILERR:	HLRZ B,1(A)
	SKIPE B
	PUSHJ P,PUTFS
	HRRZ A,(A)
	JUMPN A,NILERR
	MOVE B,H
	PUSHJ P,PUTFS
	JRST RWWIR

IERSOM:
>;MD
	GETFS(T)
	HLL H,(P)			;GET ACCUMULATED TYPE BITS
	MOVEM H,1(T)
	EXCH T,WIRLST
	HRRZM T,@WIRLST
RWWIR:	SETZ H,
	HRRZS (P)			;CLEAR ACCUMULATED BITS
RWWIRS:	PUSHJ P,RSTRZ
	JRST [	MOVE G,H
		JUMPN H,RWWIRG
		JRST RWDONE]
	GETFS(TT)
	HRLZM T,1(TT)
	HRRZM H,(TT)
	MOVE H,TT
MD,<	SETZM DX1			;NO PINS FOUND YET>
	JRST RWWIRS

MD,<
RWWIRG:	AOSA %LAST			;INC COUNT OF SIGNALS
>;MD
RWWIR0:	AOS COUNT
MPC,<RWWIRG:>
RWWIR1:	PUSHJ P,WORDIN
	JUMPE TTT,RWWIRX
MD,<	TLNN WFLAG
	JRST RWWIRZ
	MOVE T,TTT
	PUSHJ P,WORDIN
	CAME TTT,PARNAM
	JRST RWWIR1			;NOT THIS FILE, SKIP IT
	MOVE TTT,T
	PUSHJ P,FNDID			;FIND BY PID
	JRST RWWIR0			;LOSE
	AOS DX1				;COUNT A PIN READ
	MOVE T,D
	JRST GWPNT

RWWIRZ:
>;MD
	TLNE TTT,-1
	JRST [	MOVSM TTT,LETTER
MPC,<		HLRZ A,TTT		;ONLY TREAT AZ1,EZ1 SPECIAL IN PC
		PUSHJ P,QUPIN
		CAIA			;NOT WILD
		JRST SAVRND		;SAVE RANDOM CON SPEC
>;MPC
		SETZM NUMBER
		JRST LOKCON]
	PUSHJ P,WORDIN
	HRRZM TTT,NUMBER
	HRRI TTT,
	IORM TTT,(P)			;STO BITS ON STACK
	PUSHJ P,WORDIN
	MOVEM TTT,LETTER
LOKCON:	SKIPN LETTER
	JRST RWWIR0
	PUSHJ P,LOOK			;LOOK FOR IT
	JRST RWNFND
GWPNT:	JUMPN G,RWGFST
	GETFS (G)
	SETZM (G)
	SETZM 1(G)
	MOVE H,G
RWGFST:	HLRZ TT,(G)
	JUMPE TT,RWGFS1
	HRRZ TT,(G)
	JUMPE TT,RWGFS2
	MOVE G,TT
	JRST RWGFST

RWGFS2:	GETFS (TT)
	HRRM TT,(G)
	MOVE G,TT
	SETZM (G)
	SETZM 1(G)
RWGFS1:	HRLM T,(G)
	JRST RWWIR1

MPC,<
SAVRND:	JUMPN G,RWGFXT
	GETFS (G)
	SETZM (G)
	SETZM 1(G)
	MOVE H,G
RWGFXT:	AOS 1(G)
	JRST RWWIR1
>;MPC

RWNFND:	PUSH P,PUTCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	MOVE A,LETTER
	SKIPN NUMBER 			;CON PIN?
	 JRST RWNFNC			;YES
	PUSHJ P,SLTLPN
	MOVE A,NUMBER
	OUTCHR ["("]
	PUSHJ P,BPINPN
	OUTCHR [")"]
RWNFN1:	POP P,PUTCHR
	OUTSTR[ASCIZ/ NOT FOUND.
/]
	JRST RWWIR1

RWNFNC:	PUSHJ P,CSLTLP
	JRST RWNFN1

RWDONE:	RELEASE DAT,			;RELEASE INPUT FILE
	SKIPN T,COUNT
	POPJ P,
	PUSHJ P,DECOUT
MD,<	TLNE WFLAG
	OUTSTR[ASCIZ/ PINS OR CPINS NOT FOUND BY FNDID!
/]
	TLNN WFLAG
>;MD
	OUTSTR[ASCIZ/ PINS ON BODIES WITH NO ASSIGNED LOCATIONS!
/]
	POPJ P,

RELWIR:	SKIPN A,WIRLST
	POPJ P,
RELWR1:	HRRZ C,1(A)
RELWR2:	HLRZ B,1(C)
	PUSHJ P,PUTFS
	HRRZ C,(C)
	JUMPN C,RELWR2
	HRRZ B,1(A)
	PUSHJ P,PUTFS
	HRRZ A,(A)
	JUMPN A,RELWR1
	MOVE B,WIRLST
	SETZM WIRLST
	JRST PUTFS
>;UML
SUBTTL	'DAT'		PARTITION FILE
PART,<
INPINS:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/PARTITION INPUT (DAT) /]
	MOVE H,[IPNNAM]
	EXCH H,LSTNAM
	MOVSI T,EXTPAR
	PUSHJ P,SETNAM
	JRST [	MOVEM H,LSTNAM
		POPJ P,]
	MOVEM H,LSTNAM
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/FILENAME OTHER THAN CURRENT DEFAULT?/]
	PUSHJ P,GETWRD
	CAIE C,12
	JRST INNERR			;LOSE
	JUMPN T,.+3
	SKIPN T,LSTNAM			;PICKUP DEFAULT
	JRST [	OUTSTR[ASCIZ/NO DEFAULT NAME!
/]
		RELEASE DAT,
		POPJ P,]
	MOVEM T,PARNAM			;SAVE HERE FOR TESTS LATER
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SKIP CONNECTOR PINS/]
	PUSHJ P,YORN
	JRST [	RELEASE DAT,
		POPJ P,]
	TLZA WFLAG
	TLO WFLAG
	TRO MCHG
DPART1:	PUSHJ P,I5IN
	JRST PARLOS
	JUMPE T,[PUSHJ P,SKPLIN
		JRST PARLOS
		TLNE WFLAG		;SKIPPING CONNECTORS?
		JRST PARDON		;YES
		JRST CPART]
	MOVEM T,DX1			;X POS
	PUSHJ P,I5IN
	JRST PARLOS
	MOVEM T,DY1			;Y POS
	PUSHJ P,SKPLIN			;SKIP TO EOL
	JRST PARLOS
DPART2:	PUSHJ P,O6IN			;READ SLICE #
	JRST PARLOS
	MOVE B,T			;DO NOTHING WITH IT FOR NOW
	PUSHJ P,O6IN			;READ BODY ID
	JRST PARLOS
	JUMPE T,[JUMPN B,.+1
		PUSHJ P,SKPLIN
		JRST PARLOS
		JRST DPART1]		;END OF THIS DIP
	MOVE B,T			;SAVE BID
	PUSHJ P,FILCHK			;CHECK IF THIS FILE?
	JRST PARLOS
	JRST BSKIP			;NO, SKIP THIS BODY
	MOVE TTT,B
	PUSHJ P,FNDBID
	JRST BSKIPE
;********* OLD STUFF, FIX SOME DAY IF USE PART *********
	PUSHJ P,FUCKUP

	HLRZ T,(B)
	HLRZ T,1(T)
	HRRZ TT,(T)
	JUMPN TT,DPARTL
	GETFS(TT)
	GETFS(F)
	HRLZM F,(TT)
	SETZM 1(F)
	HRRM TT,(T)
	MOVSI F,FIXLOC!FIXBLO
	IORM F,1(T)			;CONTINUE FIXING LOC
	HLRZ T,(B)
	HLRZ F,(T)			;SAVE ORIENTATION
	HRRZ T,1(T)			;TYPE POINTER
	HLRZ T,1(T)
	HLRZ T,(T)
	MOVE T,1(T)			;INITIAL LOC OFFSET FROM TYPE
	PUSHJ P,ORIENT			;ORIENT IT
	MOVEM T,1(TT)			;INTIALIZE OFFSET
DPARTL:	HLRZ TT,(TT)
	SETZM (TT)			;CLEAR OUT ANY OLD CRUFT THERE
	MOVE T,DX1
	DPB T,[POINT 12,(TT),35]	;THIS IS NUMBER PART
	MOVE T,DY1
	DPB T,[POINT 6,(TT),23]		;THIS IS LETTER PART
	PUSH P,B
	MOVE T,B
	PUSHJ P,OFFBLO
	POP P,B
	PUSHJ P,SKPLIN
	JRST PARLOS
	SETZ G,
	MOVEI F,G
DPARTN:	PUSHJ P,I5INC
	JRST DPARTI
	JRST [
	GIVLOS:	MOVE B,G
		PUSHJ P,PUTFS
		JRST PARLOS]
	GETFS(TT)
	HRRM TT,(F)
	MOVE F,TT
	HRLZM T,(F)
	SETZM 1(F)
	JRST DPARTN



DPARTI:	JUMPE G,DPART2			;NO PINS? GET ANOTHER BODY
	MOVE F,G
DPARTJ:	PUSHJ P,O6INC
	JRST [	OUTSTR[ASCIZ/TOO LITTLE DATA ON PIN ID LINE!
/]
		JRST DPART6]
	JRST GIVLOS
	MOVEM T,1(F)
	HRRZ F,(F)
	JUMPN F,DPARTJ
	PUSHJ P,F4CIN
	JRST GIVLOS
	CAIN TTT,12
	JRST DPART6
	OUTSTR[ASCIZ/EXTRA DATA ON PIN ID LINE!
/]
	PUSHJ P,SKPLIN
	JRST GIVLOS

DPART6:	SKIPN T,1(G)
	JRST DPART7
	MOVEM T,DX3
	HLRZ A,(G)
	HLRZ T,(B)
	TRZ TFLG			;FLAG NONE FOUND YET
	JRST DPART4			;NOW FIND PIN ID

DPART5:	HLRZ T,(T)
	HRRZ TT,1(T)
	HRRZ TTT,(TT)
	HLRZ TTT,(TTT)
	HRRZ TTT,1(TTT)			;PIN NAME FOR THIS
	CAME TTT,DX3			;SAME PIN?
	JRST DPART4
	HRRM A,1(TT)			;STO PIN #
	TRO TFLG			;FLAG THAT WE FOUND ONE
DPART4:	HRRZ T,(T)
	JUMPN T,DPART5
	TRNN TFLG
	OUTSTR[ASCIZ/PIN ID NOT FOUND AT DPART5!
/]
DPART7:	MOVE T,G
	HRRZ G,(G)
	FSTRET(T)
	JUMPN G,DPART6
	JRST DPART2

BSKIPE:	OUTSTR[ASCIZ/BODY NOT FOUND AT DPART2!
/]
BSKIP:	PUSHJ P,SKPLIN			;SKIP REST OF BODY LINE
	JRST PARLOS
	PUSHJ P,SKPLIN			;SKIP PIN # LINE
	JRST PARLOS
	PUSHJ P,SKPLIN			;SKIP PIN ID LINE
	JRST PARLOS
	JRST DPART2			;TRY ANOTHER



CPART0:	PUSHJ P,SKPLIN			;SKIP TO NEXT LINE
	JRST PARLOS
CPART:	PUSHJ P,O6IN
	JRST PARDON			;DO THIS FOR NOW, WAGNER DOESN'T END WITH A 0
	JUMPE T,PARDON			;DONE ON 0
	MOVE B,T			;SAVE POINT ID
	PUSHJ P,FILCHK
	JRST PARLOS
	JRST CPART0
	SKIPN T,PONPNT
	JRST CPARTL
	MOVSI A,ISPIN			;FOR TEST
CPART1:	HLRZ TT,(T)
	HRRZ TTT,1(TT)
	TDNE A,1(TTT)
	JRST CPART2
	HRRZ TT,(TT)
	CAMN TT,B
	JRST CPART3			;SAME ID, THIS IS IT
CPART2:	HRRZ T,(T)
	JUMPN T,CPART1
CPARTL:	OUTSTR[ASCIZ/CONNECTOR PIN NOT FOUND AT CPART1!
/]
	JRST CPART0

CPART3:	HRLM T,(P)			;SAVE POINT POINTER HERE
	MOVE T,1(TTT)
	TLNN T,CPIN
	JRST [	OUTSTR[ASCIZ/FOUND POINT AT CPART1, BUT IT ISN'T A CONNECTOR PIN ANY MORE!
/]
		JRST CPART0]
	MOVE A,TTT
	SETZM LETTER
	PUSHJ P,F4CIN			;GET PADDLE DIGIT
	JRST PARLOS
	ANDI TTT,17
	DPB TTT,[POINT 6,LETTER,23]
	PUSHJ P,F4CIN
	JRST PARLOS
	MOVE B,TTT
	ANDI B,17
	PUSHJ P,F4CIN
	JRST PARLOS
	ANDI TTT,17
	IMULI B,=10
	ADD B,TTT
	AOS LETTER			;AT LEAST 1
	TRNN B,1
	AOS LETTER			;ANOTHER ONE
	ADDI B,1
	LSH B,-1
	DPB B,[POINT 6,LETTER,29]
	PUSH P,C
	PUSH P,D
	MOVE D,A
	MOVE C,A
	HRRZ A,(A)
	MOVE B,A
NIL,<	POINT IN A??>
	PUSHJ P,UBACK			;CHECK FOR UPIN BACKUP
	POP P,D
	MOVE B,LETTER
	MOVEM B,(A)
	MOVE T,B
NIL,<	POINT IN A??>
	PUSHJ P,CPNBCK
	POP P,C
	JRST CPART0

PARLOS:	OUTSTR[ASCIZ/UNEXPECTED END OF FILE, I QUIT!
/]
PARDON:	RELEASE DAT,
	POPJ P,



FILCHK:	PUSHJ P,O12IN
	POPJ P,
	AOS (P)
	CAMN T,PARNAM
	AOS (P)			;RIGHT FILENAME, SKIP
	POPJ P,

SKPLIN:	PUSHJ P,F4CIN
	POPJ P,
	CAIE TTT,12
	JRST SKPLIN
	JRST CPOPJ1

O12IN:	PUSHJ P,O6IN
	POPJ P,
	HRLM T,(P)
	PUSHJ P,O6IN
	POPJ P,
	HLL T,(P)
	JRST CPOPJ1

I5INC:	PUSHJ P,F4CIN
	JRST CPOPJ1
	CAIN TTT,12
	POPJ P,
	MOVEI TT,5
	PUSH P,[=10]
	SETZ T,
	AOS -1(P)
	JRST GETN2

I5IN:	MOVEI TT,5
	PUSH P,[=10]
	JRST DIN

O6INC:	PUSHJ P,F4CIN
	JRST CPOPJ1
	CAIN TTT,12
	POPJ P,
	MOVEI TT,6
	PUSH P,[10]
	SETZ T,
	AOS -1(P)
	JRST GETN2

O6IN:	MOVEI TT,6
OIN:	PUSH P,[10]
DIN:	SETZ T,
GETN1:	PUSHJ P,F4CIN		;READ A CHARACTER
	JRST [	POP P,(P)
		POPJ P,]
GETN2:	CAIN TTT,40
	TDZA TTT,TTT		;SPACES ARE ZEROES
	SUBI TTT,60
	JUMPL TTT,F4LOSE
	CAML TTT,(P)		;LESS THAN RADIX?
	JRST F4LOSE
	IMUL T,(P)
	ADD T,TTT
	SOJG TT,GETN1
	POP P,(P)
	JRST CPOPJ1

F4LOSE:	OUTSTR[ASCIZ/INPUT LOSSAGE AT GETN2, NON-DIGIT SEEN!
/]
	MOVSI TTT,70000		;BACK UP SO WILL GET IT AGAIN
	ADDM TTT,IOHD+1
	AOS IOHD+2
	POP P,(P)
	SETZ T,
	JRST CPOPJ1		;TRY TO HOBBLE ON!

F4CIN:	SOSG IOHD+2
	IN DAT,
	CAIA
	POPJ P,
	ILDB TTT,IOHD+1
	JUMPE TTT,F4CIN
	CAIE TTT,14
	CAIN TTT,15
	JRST F4CIN
	JRST CPOPJ1
>;PART
;WORDIN, CHKLOC
WORDIN:	SOSG IOHD+2
	IN DAT,
	CAIA
	JRST INERR
	ILDB TTT,IOHD+1
	POPJ P,

INERR:	OUTSTR [ASCIZ/INPUT ERROR.
SHALL I CLOSE THE FILE AND RETURN(Y OR NO)?/]
	INCHRW TTT
	CAIE TTT,"Y"
	CAIN TTT,"y"
	CAIA
NODEC,<	HALT .+1	>
DEC,<	PUSHJ P,TODDT	>
	RELEASE DAT,
	MOVE P,PERRSAV
	POPJ P,


CHKLOC:	HLRE T,TTT
	MOVMS T
MPC,<	CAILE T,20000	>	;+ OR - 50 INCHES?
MD,<	CAILE T,20000	>	;+ OR - ???
	JRST WAYOFF
	HRRE T,TTT
	MOVMS T
MPC,<	CAIG T,20000	>	;+ OR - 50 INCHES?
MD,<	CAIG T,20000	>	;+ OR - ???
	POPJ P,			;OK
WAYOFF:	OUTSTR @TYPLOC		;WHAT IS IT
	OUTSTR[ASCIZ/, WAY OFF SCREEN AT /]
CNTFED:	HLRE T,TTT
	JUMPGE T,.+2
	OUTCHR["-"]
	MOVMS T
MPC,<	IMULI T,5	>
	ASH T,-1
	PUSHJ P,DECOUT
	OUTCHR[","]
	HRRE T,TTT
	JUMPGE T,.+2
	OUTCHR["-"]
	MOVMS T
MPC,<	IMULI T,5	>
	ASH T,-1
	PUSHJ P,DECOUT
	OUTSTR[ASCIZ/
/]
	POPJ P,
;GSTR, RSTR, FIND.P
MD,<
GSTR:	PUSHJ P,RSTRZ
	POPJ P,
	EXCH T,(TT)
	JUMPE T,CPOPJ
	MOVE B,T
	JRST PUTFS
>;MD

RSTRZ:	PUSHJ P,WORDIN
	JUMPE TTT,CPOPJ
	AOSA (P)		;SKIP WORDIN AND SKIP RETURN
RSTR:	PUSHJ P,WORDIN		;GET SOME OF THE STRING
	GETBLK(B,TEXSTR)	;NO, NEED ANOTHER BLOCK
	MOVE T,B
	JRST RS2

RS1:	GETBLK(B,TEXSTR)	;NO, NEED ANOTHER BLOCK
	STORE(B,A,TSNXT)	;LINK IN
RS2:	MOVE A,B		;POINT TO IT
	STORE(TTT,A,TSASC)
	CLEAR(A,TSNXT)
	TRNN TTT,377		;DONE?
	POPJ P,			;YES
	PUSHJ P,WORDIN		;ANOTHER PIECE
	JUMPN TTT,RS1		;DONE?
	POPJ P,

SKPSTR:	PUSHJ P,WORDIN
	JUMPN TTT,SKPST1
	POPJ P,

SKPST2:	PUSHJ P,WORDIN
SKPST1:	TRNE TTT,376
	JRST SKPST2
	JRST CPOPJ1

;FIND.P	- FIND A POINT (IF NONE FOUND MAKE ONE)
;CALL WITH:
;	TTT	X,Y OF DESIRED POINT
;RETURNS WITH:
;	D	POINTER TO POINT

FIND.P:	SKIPE D,PONPNT
	PUSHJ P,FP1		;SEARCH ON SCREEN POINTS
	 JRST [	MOVE T,TTT
		JRST PNTPUT]	;MAKE A POINT
	POPJ P,

FP1:	CAMN TTT,ADDR(D,PXY)	;IS THIS THE ONE?
	 JRST CPOPJ1		;YES
	FETCH(D,D,PNXT)
	JUMPN D,FP1
	POPJ P,


NIL,<
;THIS SHOULDN'T BE NECESSARY ANY MORE??
FP2:	FETCH(TTT,D,BP1)
	FETCH(T,D,BP3)		;POINTER TO DATA BLOCK
	FETCH(E,D,BPNEB)	;POINTER TO ^_
	POPJ P,
>;NIL
SUBTTL	'UML'		READ REDAC PIN ASSIGMENTS
MD,<
INUML:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/UML INPUT /]
	MOVSI T,EXTUML
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
ASKCRD:	SETZM PARNAM			;IF GLOBAL CARD LOC, ZERO FOR MATCH
	SKIPE T,CRDLOC
	JRST ASKCR1
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/CARD LOCATION (<CR> IF ONLY ONE IN DRAWING).
^/]
	MOVE T,[PUSHJ P,GETLCH]
	MOVEM T,GTCHRX
	PUSHJ P,GETSLT
	CAIA
	CAIE C,12
	JRST [	PUSHJ P,INNERR
		JRST ASKCRD]
	MOVE T,LETTER
	HLLZM T,PARNAM		;USE THIS CELL
ASKCR1:	MOVEM P,ERRP
	MOVE D,[ANDCAM C,1(T)]	;CLEAR BITS
	PUSHJ P,STBITA		;IN BODIES AND POINTS
	SETZ D,			;D=0:NOTHING YES, D=1 PINS, D=2 BODIES
INUML1:	PUSHJ P,UMLIN
	MOVE T,1(B)
	CAMN T,[ASCIZ/END/]
	JRST INUML2
	CAMN T,[ASCII/BODIE/]
	JRST INUML3
	CAMN T,[ASCIZ/PINS/]
	JRST INUML4
INUML6:	HRRZ A,B
	ADD A,[POINT 7,1]
	MOVE T,[PUSHJ P,UREAD]
	MOVEM T,GTCHRX
	XCT URDTAB(D)
	JRST INUML5		;ERROR
	JRST INUML5		;CRLF ONLY (BLANK)
MD,<	CAIA			;LOC OK
	JRST INUML5		;BRS SEEN, LOSE
>;MD
	CAIE C,11
	JRST INUML5
	MOVE T,LETTER
	MOVEM T,NUMBER
	XCT URDTAB(D)
	JRST INUML5
	JRST INUML5
MD,<	CAIA
	JRST INUML5
>;MD
	JUMPN C,INUML5
	PUSH P,B
	XCT URDFND(D)
	POP P,B
	PUSHJ P,PUTFS
	JRST INUML1

INUML3:	HRRZ T,(B)
	JUMPE T,INUML6
	MOVE T,1(T)
	CAME T,[ASCIZ/S/]
	JRST INUML6
	PUSHJ P,PUTFS
	MOVEI D,2
	JRST INUML1

INUML4:	PUSHJ P,PUTFS
	MOVEI D,1
	JRST INUML1

;FIND PIN OR BODY AND SET NEW LOC
URDFND:	JFCL		;OH WELL, JUST IN CASE
	PUSHJ P,UFNPIN
	PUSHJ P,UFNBOD

UFNPIN:	SKIPN A,PONPNT
	POPJ P,
UFNPN1:	FETCH(T,A,PBIT)
	TRNE T,CPIN
	TRNE T,1		;NOT SEEN YET
	 JRST UFNPN2
	FETCH(B,A,PLOC)
	MOVE TT,(B)
	XOR TT,PARNAM
	CAME TT,NUMBER
	JRST UFNPN2
	PUSH P,B
	PUSHJ P,UBACK		;CHECK FOR WILD PIN BACKUP
	POP P,B
	MOVE TT,LETTER
	HRRM TT,(B)
	SETBIT(1,T,A,PBIT)
	PUSHJ P,FIXEM		;FIX OFFSET IF NEEDED
UFNPN2:	FETCH(A,A,PNXT)
	JUMPN A,UFNPN1
	POPJ P,

UFNBOD:	SKIPN A,DBODPN
	POPJ P,
UFNBD1:	HLRZ C,(A)
	HLRZ C,1(C)
	MOVE T,1(C)
	TLNE T,BTMP1
	JRST UFNBD2
	HRRZ B,(C)
	JUMPE B,UFNBD2
	HLRZ B,(B)
	MOVE TT,(B)
	XOR TT,PARNAM
	CAME TT,NUMBER
	JRST UFNBD2
	MOVE TT,LETTER
	HRRM TT,(B)
	TLO T,BTMP1
	MOVEM T,1(C)
UFNBD2:	HRRZ A,(A)
	JUMPN A,UFNBD1
	POPJ P,
;		SUBRS FOR READING UML FILE
INUML5:	OUTSTR[ASCIZ/FORMAT ERROR, /]
	OUTSTR @(D)[[ASCIZ/PINS OR BODIES NOT SELECTED /]
		[ASCIZ/PIN LOC /]
		[ASCIZ/BODY LOC /]]
	OUTSTR[ASCIZ/IN LINE:
/]
	SETZ TT,
	SKIPN TTT,B
	JRST INUMLY
INUMLZ:	MOVE T,1(TTT)
	OUTSTR T
	HRRZ TTT,(TTT)
	JUMPN TTT,INUMLZ
INUMLY:	OUTSTR[ASCIZ/
/]
	PUSHJ P,PUTFS
	JRST INUML1

UMLIN:	GETFS (B)
	SETZM (B)
	SETZM 1(B)
	MOVE T,B
	ADD T,[POINT 7,1]
UMLIN1:	PUSHJ P,UWDIN
	CAIE C,15
	CAIN C,14
	JRST UMLIN1
	CAIN C,12
	JRST UMLIN4
	CAIL C,"a"
	CAILE C,"z"
	SKIPA
	SUBI C,40
	CAIE C,11	;MAKE ANY CONTIGUOUS BLANK CHARS,
	CAIN C,40	;LOOK LIKE A SINGLE TAB
	JRST [	MOVEI C,11
		LDB TT,T
		CAIE TT,11
		JUMPN TT,.+1
		JRST UMLIN1]
	TLNN T,760000
	JRST UMLIN2
UMLIN3:	IDPB C,T
	JRST UMLIN1

UMLIN2:	GETFS (TT)
	SETZM (TT)
	SETZM 1(TT)
	HRRM TT,-1(T)
	HRR T,TT
	JRST UMLIN3

UMLIN4:	SKIPN 1(B)
	JRST UMLIN1
	SETZ C,
	LDB TT,T
	CAIN TT,11		;IF END OF LINE IS BLANK CHAR,
	DPB C,T			;THEN MAKE IT NULL
	POPJ P,

UWDIN:	SOSG IOHD+2
	IN DAT,
	JRST UWDIN1
	GETSTS DAT,C
	TLNE C,740000
	OUTSTR[ASCIZ/DISK ERROR
/]
	TLNE C,20000
	OUTSTR[ASCIZ/PREMATURE END OF FILE
/]
	MOVE P,ERRP
INUML2:	RELEASE DAT,
	TRO MCHG
	JRST PUTFS

UWDIN1:	ILDB C,IOHD+1
	JUMPE C,UWDIN
	POPJ P,
;		READ LOCATION FROM STRING
URDTAB:	JFCL
	PUSHJ P,GTCONP
	PUSHJ P,GTSLTL

UREAD:	TLNN A,760000
	JRST [	TRNE A,-1
		HRR A,-1(A)
		TRNE A,-1
		JRST .+1
		SETZ C,
		POPJ P,]
	ILDB C,A
	POPJ P,
SUBTTL	INPUT SIGNAL NAME CHANGE FILE
ISIGCH:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SIGNAL NAME CHANGE (CHG) INPUT /]
	MOVSI T,EXTCHG
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	SKIPE E,PONPNT
	PUSHJ P,ACLRP
	SETZM FIND
	MOVSI C,17
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS
ISIGC1:	PUSHJ P,RSTRC
	JRST ISIGCF		;OK EOF, DONE
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGLE		;NULL, SKIP LINE
	CAIE TTT,11
	JRST ISIGLF
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;MAKE COMPARE STRING
	POP P,B
	PUSHJ P,PUTFS
	PUSHJ P,RSTRC
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGCE		;NOT OK EOF
	JRST ISIGLE		;NULL SIGNAL, LINE ERROR
	CAIE TTT,12
	JRST ISIGLF		;NOT EOL, LINE ERROR
	MOVEM B,DX1
	SKIPE H,PONPNT
	PUSHJ P,SIGCDO
	MOVE B,DX1
	PUSHJ P,PUTFS
	JRST ISIGC1

ISIGLF:	PUSHJ P,PUTFS
ISIGLE:	PUSHJ P,CHGSKP
	JRST ISIGCE
	OUTSTR[ASCIZ/ERROR IN INPUT LINE, SKIPPING LINE.
/]
	JRST ISIGC1

ISIGCE:	OUTSTR[ASCIZ/EOF WHERE NOT EXPECTED.
/]
ISIGCF:	RELEASE DAT,
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,.+2
	SETOM FIND
	SKIPN T,FNDNUM
	JRST [	OUTSTR[ASCIZ/NO/]
		JRST ISIGC2]
	PUSHJ P,DECOUT
ISIGC2:	OUTSTR[ASCIZ/ SIGNAL NAME/]
	MOVE T,FNDNUM
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/ CHANGED.
/]
	POPJ P,
;CHANGE FILE INPUT SUBRS
CHGSKP:	CAIN TTT,12
	JRST CPOPJ1
	PUSHJ P,ICHG
	POPJ P,
	JRST CHGSKP

ICHG:	SOSG IOHD+2
	IN DAT,
	JRST ICHG1
	GETSTS DAT,TTT
	TRNE TTT,740000
	OUTSTR[ASCIZ/INPUT IO ERROR.
/]
	POPJ P,			;ALWAYS GIVE EOF RETURN

ICHG1:	ILDB TTT,IOHD+1
	CAIN TTT,15
	JRST ICHG
	JUMPN TTT,CPOPJ1
	JRST ICHG

RSTRC:	PUSHJ P,ICHG
	POPJ P,
	CAIN TTT,11
	JRST RSTRC		;SKIP OVER TABS
	AOS (P)			;DIRECT RETURN IS FOR IMMEDIATE EOF
	CAIN TTT,12
	JRST CPOPJ1		;INDICATE NULL STRING
	GETFS(B)
	PUSH P,B
	ADD B,[POINT 7,0,34]
RSTRC1:	SETZM (B)
	SETZM 1(B)
RSTRC2:	IDPB TTT,B
	PUSHJ P,ICHG
	JRST RSTRCE
	CAIE TTT,11
	CAIN TTT,12
	JRST RSTRCF
	TLNE B,760000
	JRST RSTRC2
	PUSH P,TTT
	GETFS(TTT)
	HRRM TTT,-1(B)
	HRR B,TTT
	POP P,TTT
	JRST RSTRC1

RSTRCF:	POP P,B
	JRST CPOPJ2

RSTRCE:	POP P,B
	JRST PUTFS		;RETURN STRING AND INDICATE EOF
;INPUT SIGNAL NAME CHANGE FILE
ICPNCH:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/CONNECTOR PIN (CPN) INPUT /]
	MOVSI T,EXTCPN
	PUSHJ P,SETNAM
	POPJ P,
	INIT DAT,0
	'DSK   '
	IOHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		POPJ P,]
	OUTSTR[ASCIZ/READING /]
	MOVEI A,FILNAM
	JSR FPRINT
DEC,<	MOVE T,FILPPN	>
	LOOKUP DAT,FILNAM
	JRST LOOKRR
DEC,<	JSR DAT,LOOKCK	>
	OUTSTR[ASCIZ/
/]
	MOVEI T,IOBUF
	EXCH T,.JBFF
	INBUF DAT,2
	MOVEM T,.JBFF
	SKIPE E,PONPNT
	PUSHJ P,ACLRP
	SETZM FIND
	MOVSI C,1		;MARK BIT
	SKIPE A,PONPNT
	PUSHJ P,CLRBTS		;CLEAR IT
ICPNC1:	PUSHJ P,RSTRC
	JRST ICPNCF		;OK EOF, DONE
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNLE		;NULL, SKIP LINE
	CAIE TTT,11
	JRST ICPNLF
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	MOVE T,[PUSHJ P,UREAD]
	MOVEM T,GTCHRX
	PUSHJ P,GTCONP
	JRST ICPNLF
	JRST ICPNLF
	CAIA			;LOC OK
	JRST INUML5		;BRS SEEN, LOSE
	JUMPN C,ICPNLF		;ERROR IF NOT EOS
	POP P,B
	PUSHJ P,PUTFS		;RETURN STRING
	PUSHJ P,RSTRC		;NOW GET SIGNAL NAME
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNCE		;NOT OK EOF
	JRST ICPNLE		;NULL SIGNAL, LINE ERROR
	CAIE TTT,12
	JRST ICPNLF		;NOT EOL, LINE ERROR
	PUSH P,B
	MOVE A,B
	ADD A,[POINT 7,1]
	PUSHJ P,SIGMAA		;MAKE COMPARE STRING
	POP P,B
	PUSHJ P,PUTFS
	SKIPE H,PONPNT
	PUSHJ P,CPNDO		;DO THIS LINE
	JRST ICPNC1

ICPNLF:	PUSHJ P,PUTFS
ICPNLE:	PUSHJ P,CHGSKP
	JRST ICPNCE
	OUTSTR[ASCIZ/ERROR IN INPUT LINE, SKIPPING LINE.
/]
	JRST ICPNC1

ICPNCE:	OUTSTR[ASCIZ/EOF WHERE NOT EXPECTED.
/]
ICPNCF:	RELEASE DAT,
	MOVE T,FIND
	MOVEM T,FNDNUM		;STORE FOR MACRO CALL AT ;R
	JUMPE T,.+2
	SETOM FIND
	SKIPN T,FNDNUM
	JRST [	OUTSTR[ASCIZ/NO/]
		JRST ICPNC2]
	PUSHJ P,DECOUT
ICPNC2:	OUTSTR[ASCIZ/ CONNECTOR PIN/]
	MOVE T,FNDNUM
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/ SET.
/]
	POPJ P,
;IMPLEMENT ONE CHANGE LINE
CPNDO:	FETCHL(T,H,PBIT)
	TLNE T,CPIN!1		;DON'T DO IF ALREADY CONNECTOR PIN, OR PEVIOUSLY LOOKED AT
	 JRST CPNDO1
	FETCH(A,H,PTXT)
	JUMPE A,CPNDO1		;ALSO IF NO TEXT
	FETCH(A,A,TCSTR)
	ADD A,[POINT 7,1]
	MOVEI B,SIGTAB
	PUSHJ P,SIGMAT		;COMPARE TO PREVIOUSLY READ STRING
	 JRST CPNDO1		;NO MATCH
	 JFCL			;EQUIVALENT IS CLOSE ENOUGH
	MOVE T,H		;GET PIN
	PUSH P,H
	MOVE H,[1,,CPNCHK]	;NOW SEE IF CPIN ALREADY EXISTS ON WIRE
	PUSHJ P,RECUR1		;SETUP WDOLST
	SKIPN WDOLST		;ANYTHING IN LIST
	 JRST CPNDO2
	TLZ WFLAG
	PUSHJ P,RECCHK
	TLNE WFLAG
	 JRST CPNDO2		;CPIN ALREADY ON WIRE (CPNCHK RETURN)
	MOVE A,(P)
	PUSHJ P,SETLET		;PUT CONNECTOR PIN HERE
	MOVE H,(P)
	SETBIT(FOUNDP,TT,H,PBIT)
	AOS FIND
CPNDO2:	POP P,H
CPNDO1:	HRRZ H,(H)
	JUMPN H,CPNDO
	POPJ P,

CPNCHK:	JFCL
	FETCHL(T,A,PBIT)
	TLNN T,CPIN
	 JRST WRECUR
	TLO WFLAG
	SKIPE B,WDOLST
	PUSHJ P,PUTFS
	SETZM WDOLST
	POPJ P,
>;MD
SUBTTL RDVER TABLES!
MD,<
%IV6:	ANDI TTT,3
	ANDI TTT,3
	ANDI TTT,3
REPEAT IOVER-2,<ANDI TTT,7>
;**RDVER

%IV7:	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNNEW0
	PUSHJ P,LNNEW
REPEAT IOVER-6,<PUSHJ P,LNNEWS>
;**RDVER

LNOLD:	LDB A,[POINT 6,TT,8]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 12,LETTER,11]
	HLRZ A,TT
	DPB A,[POINT 6,LETTER,23]
	PUSHJ P,WORDIN
	DPB TTT,[POINT 6,LETTER,29]
	HLRZ TTT,TTT
	DPB TTT,[POINT 6,LETTER,17]
	JRST LNNEWB

LNNEW0:	PUSHJ P,WORDIN
	LDB TT,[POINT 6,TTT,5]
	DPB TT,[POINT 4,TTT,3]
	LDB TT,[POINT 6,TTT,11]
	LSH TT,3
	SKIPE TT
	TRO TT,3
	DPB TT,[POINT 8,TTT,11]
	PUSHJ P,LNNEWT
	JRST LNNEWB

LNNEW:	PUSHJ P,LNNEWS
	JRST LNNEWB

LNNEWS:	PUSHJ P,WORDIN
LNNEWT:	MOVEM TTT,LETTER
	PUSHJ P,WORDIN
	MOVEM TTT,NUMBER
	POPJ P,
>;MD

LNNEWB:
MD,<	LDB TT,[POINT 5,LETTER,8]
	MOVE TT,L2N+100(TT)
	DPB TT,[POINT 5,LETTER,8]
>;MD
	LDB TT,[POINT 6,LETTER,23]
	MOVE TT,L2N+100(TT)
	DPB TT,[POINT 6,LETTER,23]
	POPJ P,

;%IV8,%IV10,%IV11,%IV12,%IV13
MPC,<
%IV8:	PUSHJ P,LNOLD0
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNOLD
	PUSHJ P,LNNEW
	PUSHJ P,LNNEW
	PUSHJ P,LNNEWS
REPEAT IOVER-7,<HLRZM TT,LETTER		;STORE LOC, NO MORE OFFSET>
;**RDVER

LNOLD0:	TRNN TT,400000		;VERY OLD VERSION?
	JRST LNOLD		;NO, GO TO LNOLD
	HLRZ TT,TT
	DPB TT,[POINT 6,LETTER,23]
	PUSHJ P,WORDIN
	DPB TT,[POINT 6,LETTER,29]
	JRST LNNEWB

LNOLD:	LSH TT,-9
	DPB TT,[POINT 6,LETTER,23]
	LSH TT,-9
	DPB TT,[POINT 6,LETTER,29]
	JRST LNNEWB

LNNEW:	PUSHJ P,LNNEWS
	JRST LNNEWB

LNNEWS:	HLRZM TT,LETTER
	PUSHJ P,WORDIN		;GET X,Y OFFSET
	MOVEM TTT,NUMBER
	POPJ P,
>;MPC

MD,<
%IV10:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3D>
;**RDVER

RDV3D:	PUSHJ P,FFNDID
	JRST NNDOWN
	JRST OLDVRD

%IV11:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3U>
;**RDVER

RDV3U:	PUSHJ P,FFNDID
	JRST NNUP
	JRST OLDVRU

%IV12:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3L>
;**RDVER

RDV3L:	PUSHJ P,FFNDID
	JRST NNLEFT
	JRST OLDVRL

%IV13:	CAIN TTT,400000
REPEAT IOVER,<JUMPN TTT,RDV3R>
;**RDVER

RDV3R:	PUSHJ P,FFNDID
	JRST NNRIGHT
	JRST OLDVRR
>;MD

;%IV14
%IV14:		JFCL		;DON'T CHANGE OLD PIN #'S
		JFCL
		JFCL
MPC,<		PUSHJ P,PADPIN
		PUSHJ P,PADPIN
		PUSHJ P,PADPIN
>;MPC
REPEAT IOVER-2,<	PUSHJ P,GPADPN	>
;**RDVER

MPC,<
PADPIN:	FETCH(TT,D,PBIT)
	TRNE TT,FEEDTH		;PINS WERE DEFAULTED BY BPYES
	AOS ADDR(D,PIN)		;TYPE 1 PAD FOR FEEDTHROUGHS
	TRNE TT,2000		;OLD UNPADDED FEEDTHROUGH BIT!
	CLEAR(D,PIN)		;IN WHICH CASE 0
	POPJ P,
>;MPC

GPADPN:
MPC,<	FETCH(TT,D,PBIT)
	TLNE TT,ISPIN		;IS IT A HOLE?
	TLNN M,TYPNLY		;AND SPECIAL INPUT MODE
	 JRST NPDCNG		;NO
	TRNN TTT,-1		;PAD TYPE ALREADY?
	MOVEI TTT,1		;NO PAD IT
NPDCNG:	HRRZS TTT
	CAMLE TTT,MXPADN
	MOVEM TTT,MXPADN
>;MPC
	STORE(TTT,D,PIN)	;STO PIN OR PAD NUMBER
	JRST WORDIN

;%IV17
MD,<
%IV17:	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD1
	PUSHJ P,LNOLD0
	PUSHJ P,LNNEW1
REPEAT IOVER-6,<PUSHJ P,LNNWS1>
;**RDVER

LNOLD1:	DPB TTT,[POINT 6,(T),23]
	LDB A,[POINT 6,TTT,26]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 12,(T),11]
	HLRZ TTT,TTT
	ROT TTT,-1
	ADDI TTT,1
	DPB TTT,[POINT 6,(T),35]	;USE THIS AS NUM
	ROT TTT,1
	ANDI TTT,1
	ADDI TTT,1
	DPB TTT,[POINT 6,(T),29]	;AND THIS AS LET
	PUSHJ P,WORDIN
	HLRZ TTT,TTT
	DPB TTT,[POINT 6,(T),17]
	SETZM 1(T)
	JRST LNNEWC

LNOLD0:	LDB A,[POINT 6,TTT,5]
	DPB A,[POINT 4,TTT,3]
	LDB A,[POINT 6,TTT,11]
	LDB TT,[POINT 6,TTT,23]		;THIS IS TO CATCH POOR LOSERS
	JUMPE TT,[DPB A,[POINT 24,TTT,23]
		JRST LNNEW1]
	LSH A,3
	SKIPE A
	TRO A,3
	DPB A,[POINT 8,TTT,11]
LNNEW1:	PUSHJ P,LNNWS1
	JRST LNNEWC

LNNWS1:	MOVEM TTT,(T)
	PUSHJ P,WORDIN
	MOVEM TTT,1(T)
	POPJ P,
>;MD
LNNEWC:	LDB TT,[POINT 6,(T),29]
	MOVE TT,L2N+100(TT)
	DPB TT,[POINT 6,(T),29]
MD,<	LDB TT,[POINT 5,(T),8]
	MOVE TT,L2N+100(TT)
	DPB TT,[POINT 5,(T),8]
>;MD
	LDB TT,[POINT 6,(T),23]
	MOVE TT,L2N+100(TT)
	DPB TT,[POINT 6,(T),23]
	POPJ P,

;%IV18
%IV18:	CAIN TTT,400000		;DONE?
REPEAT IOVER,<JUMPN TTT,RDV3S>
;**RDVER

RDV3S:
MPC,<	PUSHJ P,FFNDID
	CAIA
	JRST OLDV11		;FOUND IT
	FSWITCH
>;MPC
	PUSHJ P,FFNDID		;TRY THIS SIDE!
	JRST RDSPNT		;LOSE
	JRST OLDV11

MPC,<
%IV20:	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO
	PUSHJ P,CLOCO0
	PUSHJ P,CLOCOS
REPEAT IOVER-6,<MOVEM TTT,CRDLOC>
;**RDVER

CLOCO:	DPB TTT,[POINT 6,CRDLOC,17]	;NUMBER
	HLRZ TTT,TTT
	ANDI TTT,77
	LSH TTT,3
	SKIPE TTT
	TRO TTT,3
	DPB TTT,[POINT 12,CRDLOC,11]
	JRST CLOCOT

CLOCO0:	MOVEM TTT,CRDLOC
	LDB TTT,[POINT 6,CRDLOC,5]
	DPB TTT,[POINT 4,CRDLOC,3]
	LDB TTT,[POINT 6,CRDLOC,11]
	LSH TTT,3
	SKIPE TTT
	TRO TTT,3
	DPB TTT,[POINT 8,CRDLOC,11]
	JRST CLOCOT

CLOCOS:	MOVEM TTT,CRDLOC
CLOCOT:	LDB TTT,[POINT 5,CRDLOC,8]
	MOVE TTT,L2N+100(TTT)
	DPB TTT,[POINT 5,CRDLOC,8]
	POPJ P,
>;MPC
