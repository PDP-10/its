VERSION(ALT,3)
;ENTER ALTER MODE -- POINT, EDIT, MACRO
MD,<
BTALTR:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEM A,REMMAC
	MOVE T,CLAST
	HRLM T,REMMAC	;SAVE LAST ALSO
	FETCH(A,A,TXVAL)	;TEXT STRING
	MOVEI T,BTALTM
	JRST EALT0

EALTER:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEM A,REMMAC		;REMEMBER THE ONE WE ARE WORKING ON
	FETCH(A,A,TXVAL)	;TEXT STRING
	MOVEI T,EDTAM		;ENTER THIS MODE SO WE LEAVE PROPERLY
	JRST EALT0
>;MD

ALTER:	PUSHJ P,GETCLS
	JRST PERRET
	MOVEM A,ALTPNT		;FOR PTKIL1
	MOVE B,A
	FETCH(A,B,PTXT)
	JUMPN A,EALT1		;ANY TEXT ON POINT?
	GETBLK(A,TEXCOF)	;NO, GIVE HIM SOMETHING TO EDIT ANYWAY
	CLEAR(A,TCXY)		;IT SHOULD NEVER GET SEEN IF IT STAYS NULL
	STORE(A,B,PTXT)		; OFFSET HEADER,...
	GETBLK(C,TEXSTR)
	STORE(C,A,TCSTR)	; ...,TEXT STRING
	CLEAR(C,TSNXT)
	CLEAR(C,TSASC)
	MOVE T,STDBIG
	STORE(T,C,TSSIZ)
EALT1:	MOVEI T,ALTM
	FETCH(A,A,TCSTR)	;STRIP OFF OFFSET HEADER
EALT0:	MOVEM A,TXTPNT
	SETZM ALTLIN
	MOVE TT,MODE
	MOVEM TT,MODALT
	PUSHJ P,CHNGMD
	TRO MCHG
	SETOM LPNTR
	JRST TXTSET		;INITIALIZE POINTERS!

;MACRO ALTER

MALTER:	MOVEI T,1
	LSH T,@MODE
	TDNE T,[ANYALT]
	JRST PERRET
	PUSHJ P,ITGET		;GET MACRO
	JRST NXMAC		;NONE
	MOVEM E,REMMAC
	MOVE T,MODE
	MOVEM T,MODALT
	SETZM ALTLIN
	MOVEI T,CRCHR
	MOVEM T,EOLCHR
	MOVEI T,MALTM
	PUSHJ P,CHNGMD
	TRO MCHG
	SETOM LPNTR
	MOVE T,B		;SAVE BYTE POINTER
	PUSHJ P,SETTT7		;SETUP FOR TEXT STRING
	MOVEM A,TXTPNT
MALT1:	PUSHJ P,GETTT
	JRST TXTSET
	TRZE C,200
	PUTBYT AMCTL
	TRZE C,400
	PUTBYT AMMTA
IFN ALTCHR-ALTMOD,<
	CAIN C,ALTMOD
	MOVEI C,ALTCHR
>;IFN ALTCHR-ALTMOD
	CAIN C,12
	MOVEI C,CRCHR		;USE THIS AS LF FOR NOW
	PUTBYT (C)
	JRST MALT1
;LEAVE ALTER MODE
MD,<
BTXALT:	PUSHJ P,EBTALT
	 CAIA
	 JRST BTXDL1		;A SETUP WITH LAST,,CLOSEST
	MOVE B,A
	MOVE A,BTBODY
	JRST CMPBDT		;RECOMPILE NEW PROP

ELTALT:	PUSHJ P,EBTALT
	 CAIA
	JRST EDTDL1
	MOVE B,A
	MOVE A,CURBOD		;TYPE
	JRST CMPTYT		;RECOMPILE NEW PROP

;EBTALT - END OF EDIT BODY TEXT
;(SKIPS IF TEXT WENT AWAY)
EBTALT:	MOVE T,MODALT
	PUSHJ P,CHNGMD
	TRO MCHG
	SETOM LPNTR
	MOVE B,TXTPNT
	MOVE A,REMMAC		;GET THE ONE WE WERE WORKING ON
	SKIPN ADDR(B,TSASC)	;DID TEXT GO AWAY?
	 JRST CPOPJ1		;YES, TELL HIGHER UPS TO KILL IT
	PUSHJ P,EALT2
	FETCH(T,A,TXXY)
	TRNN T,1		;AUTO OFFSET?
	POPJ P,			;NO
	JRST EDTTZA		;YES, RECALCULATE OFFSET
>;MD

MALTALT:MOVE B,REMMAC
	HLRZ B,1(B)
	PUSHJ P,PUTFS		;GIVE OLD COPY OF MACRO BACK
	MOVE T,TXTPNT
	ADD T,[POINT 7,1]
	PUSHJ P,SETTT
	SETZ D,
MALTC1:	PUSHJ P,GETTT
	JRST MALTC2
	CAIN C,AMMTA
	JRST [	TRO D,400
		JRST MALTC1]
	CAIN C,AMCTL
	JRST [	TRO D,200
		JRST MALTC1]
	CAIN C,CRCHR
	JRST [	MOVEI C,12
		JRST ISLF]	;DON'T ALLOW CTRLMETA ON LF
IFN ALTCHR-ALTMOD,<
	CAIN C,ALTCHR
	MOVEI C,ALTMOD
>;IFN ALTCHR-ALTMOD
	TRO C,(D)
ISLF:	PUTBYT (C)
	SETZ D,
	JRST MALTC1

MALTC2:	MOVE E,REMMAC
	MOVE A,SETSTR
	HRLM A,1(E)
	HRROS (A)		;MARK AS PERMANENT
MQUIT1:	MOVE B,TXTPNT
	PUSHJ P,PUTFS
	TRO MCHG
	MOVEI T,DBLARR
	MOVEM T,EOLCHR		;RESTORE END OF LINE CHARACTER
	MOVE T,MODALT
	JRST CHNGMD

MQUIT:	MOVE T,MODE
	CAIN T,MALTM		;CAN'T IF NOT DOING ANYTHING
	JRST MQUIT1
	JRST PERRET

ALTALT:	MOVE T,MODALT		;GET BACK OLD MODE
	PUSHJ P,CHNGMD
	TRO MCHG
	MOVE B,TXTPNT		;GET TEXT POINTER
	MOVE A,ALTPNT
	SKIPN ADDR(B,TSASC)	;DID IT GET CLEARED ENTIRELY?
	JRST PTKIL1		;KILL IT THE USUAL WAY
MD,<	PUSHJ P,FIXEM		;FIX TEXT AND CON OFFSET (IF BITS ON)>
EALT2:	MOVE B,TXTPNT
EALT3:	MOVE T,B
	FETCH(B,B,TSNXT)
	JUMPE B,CPOPJ
	SKIPE ADDR(B,TSASC)	;NULLS?
	JRST EALT3
	CLEAR(T,TSNXT)
	JRST PUTFS		;FLUSH THEM

SETSIZ:	TRZE TYPNEG
	JRST MSORRY
	PUSHJ P,READSZ		;READ SIZE ARG (RETURNS IN T)
	JRST INNERR		;IF ERROR, JUST SAY SO
	PUSHJ P,GETLIN		;GET LF
	CAIE C,12
	JRST INNERR
MPC,<	JUMPE T,INNERR	>
MD,<	JUMPN T,NOZERO
	MOVEI TT,1
	LSH TT,@MODE
	TDNN TT,[1EDTAM!1BTALTM]
	JRST INNERR
	MOVE TT,REMMAC
	FETCH(TT,TT,TXNAM)	;TEXT HAS PROPERTY NAME?
	JUMPE TT,INNERR		;ZERO SIZE NOT ALLOWED UNLESS PROPERTY
NOZERO:
>;MD
	MOVE TT,TXTPNT
	STORE(T,TT,TSSIZ)	;STORE IN TEXT HEADER
	JRST COMCLR

ALTMNS:	SKIPE NOARG		;HAS HE ALREADY STARTED A NUMBER?
	TROE TYPNEG		;NO, ARE WE ALREADY - ?
	JRST PERRET		;YES, ERROR
	POPJ P,

ALTNUM:	SETZM NOARG		;INDICATE ARG SPECIFIED
	MOVE T,COMREP
	IMULI T,=10
	ADDI T,-60(C)
	MOVEM T,COMREP
	POPJ P,

TXTSET:	MOVE T,TXTPNT
	ADD T,[<POINT 7,1,6>]
	MOVEM T,TXTBYT		;INITIALIZE BYTE POINTER TO FIRST CHAR
	MOVEI T,1
	MOVEM T,TXTCNT		;AND FIRST CHAR OF TEXT
	TRO ATFP
	TRZ ATLP		;ASSUME NOT AT LAST POINT YET
	LDB T,TXTBYT
	JUMPN T,COMCLR		;WE WERE RIGHT
	TRO ATLP		;FLAG AT LAST POINT
COMCLR:	SETZM COMREP		;CLEAR REPEAT COUNT
	SETOM NOARG		;FLAG NO ARGUMENT YET
	TRZ TYPNEG		;NOT - YET
	SETZM AEOL
	SETZM ABOL
	TRNE ATLP
	SETOM AEOL
	TRNE ATFP
	SETOM ABOL
	POPJ P,

MSORRY:	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/SORRY, MINUS NOT IMPLEMENTED FOR THIS COMMAND.
/]
	JRST COMCLR
;GETONE, FORWRD, BAKWRD
GETONE:	TRNE ATLP
	 POPJ P,		;DIRECT RETURN IF AT LAST POINT ALREADY
	TRZ ATFP		;GUESS WE'RE NOT AT THE FIRST POINT ANY MORE
	AOS TXTCNT		;MOVING FORWARD AT LEAST ONE
	MOVE T,TXTBYT
	TLNE T,760000		;END OF WORD YET?
	 JRST SAMWRD		;YES
	HRR T,-1(T)
	TRNE T,-1		;END OF STRING?
	JRST SAMWRD
	GETBLK(TT,TEXSTR)	;YES, CONS UP ADDITIONAL SPACE
	CLEAR(TT,TSASC)
	CLEAR(TT,TSNXT)
	MOVE T,TXTBYT
	HRRM TT,-1(T)
	HRR T,TT
SAMWRD:	ILDB C,T		;GET CHAR (MAY BE 0)
	MOVEM T,TXTBYT
	JUMPN C,CPOPJ1		;SKIP RETURN IF AT END NOW
	TRO ATLP		;NOT REALLY AT LAST POINT
	POPJ P,

FORWRD:	TRZE TYPNEG
	JRST BAKWRD
	TRNE ATLP		;AT LAST CHR
	JRST COMCLR		;YES, LEAVE
	SKIPN COMREP		;ANY ARGUMENT?
	AOS COMREP		;NO, USE ONE
FORLOP:	SOSL COMREP
	PUSHJ P,GETONE		;GET NEXT CHAR
	JRST COMCLR
	JRST FORLOP

BAKONE:	PUSH P,COMREP
	SETZM COMREP
	PUSHJ P,BAKWRD
	POP P,COMREP
	POPJ P,

BAKWRD:	TRZE TYPNEG
	JRST FORWRD
	TRNE ATFP		;AT FIRST POINT?
	JRST COMCLR		;YES, LEAVE
	SKIPN T,COMREP
	MOVEI T,1
	SUB T,TXTCNT		;WHERE TO BACK UP TO, COUNTING FROM FRONT
	PUSH P,T
	PUSHJ P,TXTSET		;GET BACK TO FRONT
	POP P,T
	ADDI T,1		;ACCOUNT FOR BEING AT FIRST ONE ALREADY
	MOVNM T,COMREP
	JRST FORLOP		;FORLOP WILL QUIT IF AT FRONT ALREADY


;SEARCH
SEARCH:	TRZE TYPNEG
	JRST NSEARC
	PUSHJ P,SEARC0
	JRST COMCLR
	PUSHJ P,GETONE
	JRST COMCLR
	JRST COMCLR

SEARC0:	SKIPN COMREP
	AOS COMREP
	PUSHJ P,GETCHR
SEARCL:	SETZM AFIND
	PUSH P,C		;SAVE CHAR TO SEARCH FOR
	LDB C,TXTBYT	;START WITH CURRENT CHAR
	JRST SEARC5

SEARC1:	SOSG COMREP
	JRST SEARC3
SEARC2:	PUSHJ P,GETONE
	JRST SEARC4		;AT END, LEAVE
SEARC5:	CAME C,(P)		;IS THIS ONE?
	JRST SEARC2		;GET ANOTHER
	JRST SEARC1		;LOOP FOR COUNT

SEARC3:	AOS -1(P)
	SETOM AFIND
SEARC4:	POP P,(P)
	POPJ P,

NSEARC:	PUSHJ P,NSEAR0
	JRST COMCLR
	JRST COMCLR


NSEAR0:	SKIPN COMREP
	AOS COMREP
	PUSHJ P,GETCHR
NSEARL:	SETZM AFIND
	PUSH P,C		;SAVE CHAR TO SEARCH FOR
NSEAR1:	SOSGE COMREP
	JRST SEARC3
NSEAR2:	TRNE ATFP		;DONE IF AT FIRST POINT
	JRST SEARC4
	PUSHJ P,BAKONE
	LDB C,TXTBYT
	CAME C,(P)
	JRST NSEAR2
	JRST NSEAR1
;END OF LINE SEARCHES
ELINE:	TRO TFLG
	TRNN TYPNEG
	AOS COMREP		;FOR FORWARD, ADD 1
	JRST SLINE1

MSLINE:	TRC TYPNEG
SLINE:	TRZ TFLG
	TRNE TYPNEG		;IF - SEARCH
	JRST [	SKIPE NOARG	;IF NO ARG,
		AOS COMREP	;THEN - = -1
		AOS COMREP	;THEN ADD 1 TO COUNT
		JRST SLINE1]	;AND PROCESS
	SKIPN NOARG		;IF ARG,
	SKIPE COMREP		;AND IT IS 0
	JRST SLINE1
	TRO TYPNEG		;THEN BACKWARDS 1 EOL
SLINE1:	SKIPN COMREP
	AOS COMREP
	MOVE C,EOLCHR		;THIS IS ALWAYS THE SEARCH CHARACTER
	TRZE TYPNEG
	JRST NSLINE
	PUSHJ P,SEARCL
	JRST COMCLR
NSLIN1:	TRNN TFLG		;IF "E", LEAVE BEFORE CHAR
	PUSHJ P,GETONE
	JRST COMCLR
	JRST COMCLR

NSLINE:	PUSHJ P,NSEARL
	JRST COMCLR
	JRST NSLIN1

;ALTER MODE DELETE
;COMREP = DELETE COUNT, (TYPNEG MEANS -D)
;TXTBYT = BYTE POINTER TO ASCII (TSASC)
;TXTCNT = CHARACTER POSITION IN STRING

DELETE:	TRZN TYPNEG
	 JRST DELET0
	TRNE ATFP
	 JRST COMCLR
	SKIPN T,COMREP
	 MOVEI T,1
	ADDI T,1
	CAMLE T,TXTCNT		;IS THERE ENOUGH THERE TO DELETE?
	MOVE T,TXTCNT		;NO, DELETE JUST WHATS THERE
	SUBI T,1
	MOVEM T,COMREP
	PUSH P,COMREP
	PUSHJ P,BAKWRD
	POP P,COMREP
DELET0:	TRNE ATLP
	 JRST COMCLR
	SKIPN COMREP
	 AOS COMREP
	PUSH P,TXTCNT
	PUSH P,TXTBYT
	MOVE A,TXTBYT
	ADD A,[070000,,0]
	SOS COMREP		;GET WILL DO ONE
	PUSHJ P,FORLOP		;SKIP OVER CHARS WE WANT TO DELETE
DELET1:	PUSHJ P,GETONE
	JFCL
	TLNN A,760000		;END OF WORD?
	 HRR A,-1(A)		;YES, FOLLOW LINK (CAN'T LOSE).
	IDPB C,A		;DEPOSIT CHAR
	JUMPN C,DELET1		;LOOP IF NOT AT END (C=0)
	TRO MCHG
	SETOM LPNTR
	POP P,TXTBYT
	POP P,TXTCNT
	SOSN 1(P)		;TEST TXTCNT FOR 1
	 TRO ATFP		;AND SET ATFP IF ON
	CAME A,TXTBYT		;DID WE PUT A 0 IN THE CURRENT BYTE?
	TRZ ATLP		;NO, FLUSH ATLP
	TLNE A,760000		;END OF WORD?
	 IDPB C,A		;ANOTHER 0
	TLNE A,760000		;END OF WORD YET?
	 JRST .-2
	HRRZ B,-1(A)		;GET FORWARD LINK
	HLLZS -1(A)
	JRST PUTFS		;AND RETURN THE REST

KILL:	TRZE TYPNEG
	JRST NKILL
	PUSH P,0		;SAVE FIRST-LAST BITS
	PUSH P,TXTCNT
	PUSH P,TXTBYT
	PUSHJ P,SEARC0		;FIND CHAR IN QUESTION
	JRST [	SUB P,[3,,3]
		JRST COMCLR]
	POP P,TXTBYT
	POP P,T			;GET BACK ORIGINAL COUNT
	EXCH T,TXTCNT		;PUT THIS BACK NOW IN CASE AT END
	POP P,TT		;GET BACK BITS
	TRZ ATLP!ATFP		;CLEAR THESE
	ANDI TT,ATLP!ATFP
	TRO (TT)
	SUB T,TXTCNT
	ADDI T,1		;KILL THROUGH CHARACTER WE FOUND.
	MOVEM T,COMREP		;THIS IS HOW MANY TO DELETE
	JRST DELETE

NKILL:	PUSH P,TXTCNT
	PUSHJ P,NSEAR0		;FIND CHAR IN QUESTION
	JRST [	POP P,(P)
		JRST COMCLR]
	POP P,T
	SUB T,TXTCNT
	MOVEM T,COMREP		;THIS IS HOW MANY TO DELETE
	JRST DELETE

ALTC:	TRZE TYPNEG
	TROA TFLG
	TRZ TFLG
	SKIPN COMREP
	AOS COMREP
ALTC1:	PUSHJ P,GETCHR		;GET REPLACEMENT CHAR
	CAIE C,12
	CAIN C,ALTMOD		;DIS-ALLOW STUPIDNESS
	JRST ALTC3
	TRNN TFLG
	JRST ALTC4
	TRNE ATFP
	JRST ALTC2
	PUSH P,C
	PUSHJ P,BAKONE
	POP P,C
	JRST ALTC5

ALTC4:	TRNE ATLP
	JRST ALTC2
ALTC5:	DPB C,TXTBYT
	TRO MCHG
	SETOM LPNTR
ALTC3:	TRNN TFLG
	PUSHJ P,GETONE		;MOVE FORWARD ONE
	JFCL			;IF AT END, JUST GOBBLE REST OF CHARS
ALTC2:	SOSLE COMREP
	JRST ALTC1
	JRST COMCLR
ALTN:	PUSHJ P,ALTNS
	JRST COMCLR
	TRNE TFLG
	POPJ P,			;ALREADY AT FRONT IF -N
ALTNA:	PUSHJ P,GETONE
	JRST COMCLR
	CAIL C,"0"
	CAILE C,"9"
	JRST COMCLR
	JRST ALTNA

SPALTN:	PUSHJ P,ALTNS
	JRST COMCLR		;DIDN'T FIND IT
	PUSHJ P,COMCLR
	PUSHJ P,SETTT		;SETUP OUTPUT STRING
SPALT1:	PUTBYT (C)
	PUSHJ P,GETONE
	JRST SPALT2
	CAIL C,"0"
	CAILE C,"9"
	CAIA
	JRST SPALT1
SPALT2:	TRNE TFLG
	PUSHJ P,BAKDIG		;BACK UP TO FRONT IF -#
	JRST ITSTUF

ALTPLS:	PUSHJ P,SREADN
	CAIE C,12
	JRST INNERR
	MOVE D,T
	PUSHJ P,ALTNS
	JRST COMCLR
	SETZ B,
ALTPL1:	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"
	JRST ALTPL2
	IMULI B,=10
	ADDI B,-"0"(C)
	PUSH P,B
	PUSHJ P,DELETE
	POP P,B
	JRST ALTPL1

ALTPL2:	ADD B,D			;NOW ADD ARGUMENT
	PUSHJ P,SETTT7		;PREPARE TO MAKE STRING
	PUSHJ P,PUTTTN		;MAKE NUMBER BACK INTO STRING
	MOVE B,A		;PUT WHERE INSERT WILL FIND IT
	PUSHJ P,ALTPL3		;AND INSERT NEW DIGIT STRING
	TRNE TFLG
	PUSHJ P,BAKDIG
	JRST COMCLR

ALTU:	PUSHJ P,ALTNS
	JRST COMCLR
ALTU1:	PUSHJ P,DELETE
	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"		;ALL DIGITS DELETED?
	POPJ P,			;YES
	JRST ALTU1

ALTNS:	SETZM AFIND
	SKIPN COMREP
	AOS COMREP
	TRZE TYPNEG
	JRST NALTNS
	TRZ TFLG
	TRNE ATLP
	POPJ P,
	LDB C,TXTBYT		;IN CASE AT FRONT
	TRNE ATFP
	JRST ALTN2		;YES, ASSUME CAN BE START OF DIGIT STRING
	PUSHJ P,BAKONE		;BACK UP ONE
	LDB C,TXTBYT		;GET CHAR WE NOW POINT AT
ALTN1:	CAIL C,"0"
	CAILE C,"9"
	JRST ALTN3		;FOUND NON-DIGIT
ALTN4:	PUSHJ P,GETONE
	POPJ P,
	JRST ALTN1

ALTN3:	PUSHJ P,GETONE		;GET ANOTHER
	POPJ P,
ALTN2:	CAIL C,"0"
	CAILE C,"9"		;GET TO DIGIT YET?
	JRST ALTN3		;NO
	SOSLE COMREP		;YES, HAVE WE FOUND ENOUGH?
	JRST ALTN4		;NO
	SETOM AFIND
	JRST CPOPJ1		;YES

NALTNS:	TRO TFLG
	TRNE ATLP
	JRST NALTN1		;CAN BE START OF DIGIT STRING IF END
	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"
	JRST NALTN1		;IF THIS CHAR NOT DIGIT, CAN ALSO BE START
	PUSHJ P,BAKDIG
NALTN1:	TRNE ATFP
	POPJ P,			;NOT FOUND
	PUSHJ P,BAKONE
	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"
	JRST NALTN1
	PUSHJ P,BAKDIG		;BACKUP OVER DIGIT STRING
	SOSLE COMREP
	JRST NALTN1		;NOT ENOUGH YET, LOOP BACK
	SETOM AFIND
	JRST CPOPJ1		;FOUND IT

BAKDIG:	TRNE ATFP
	POPJ P,			;IF AT FRONT, THEN DONE
	PUSHJ P,BAKONE
	LDB C,TXTBYT
	CAIL C,"0"
	CAILE C,"9"
	CAIA
	JRST BAKDIG		;KEEP GOING
	PUSHJ P,GETONE		;POINT BACK AT FIRST DIGIT
	JFCL			;CAN'T HAPPEN
	POPJ P,
REPLAC:	PUSHJ P,DELETE		;<->nD, THEN INSERT
INSERT:	TRZE TYPNEG
	JRST MSORRY
	TLNN M,DSKACT!MACACT
	OUTSTR[ASCIZ/INSERT TEXT_/]
	PUSHJ P,TREADC
	 POPJ P,
	 POPJ P,
ALTPL3:	TRO MCHG
	SETOM LPNTR
;Painfully splice new string into old
;TXTBYT:  ASCII WD1 (BLANK OUT WITH RUBOUTS)  NEW STRING ...
;TT:	COPY WD1  OLD STRING'S TAIL ...
	TRZ ATLP		;THERE IS AT LEAST ONE MORE CHAR COMING!
	MOVE T,TXTBYT		;BYE PTR TO ASCII WD1
	GETBLK(TT,TEXSTR)
	MOVE TTT,(T)
	STORE(TTT,TT,TSASC)	;COPY ASCII-WD1 INTO NEW BLOCK
	HRRZ TTT,-1(T)		;GET OLD TAIL
	HRRM B,-1(T)		;INSERT NEW STRING
	STORE(TTT,TT,TSNXT)	;OLD TAIL AFTER NEW BLOCK
	PUSH P,TT		;SAVE END PIECE
;Delete trailing characters in ASCII WD1
	MOVEI TT,1		;FILL OUT 
	MOVEI C,177		;(CAN'T BE 0'S)
	ADD T,[070000,,0]
	IDPB C,T
	TLNE T,760000
	 AOJA TT,.-2
	MOVEM TT,COMREP		;SET AS DELETE COUNT
	PUSH P,TT
	PUSHJ P,DELETE
INS2:	PUSHJ P,GETONE		;SKIP TO END OF SPLICED ON STRING
	 CAIA
	JRST INS2		;LOOP UNTIL END OF TEXT
	TRZ ATLP
	POP P,T
	EXCH T,(P)		;EXCHANGE COUNT FOR REST OF TEXT
	MOVE TT,TXTBYT
	HRRM T,-1(TT)		;NCONC TRAILER JUST AFTER NEW STUFF
;Delete nulls at end of inserted string, and also leading characters
; in ascii word that was copied from insertion point
	MOVNI T,1
	MOVEI C,177
	ADD TT,[070000,,0]
	IDPB C,TT
	TLNE TT,760000
	 SOJA T,.-2
INS3:	SUBI T,5		;-5-#NULLS
	POP P,TT		;# CHARS AFTER POINT IN WD1
	ADD T,TT		;-#NULLS -#CHARS BEFORE POINT IN WD1
	MOVNM T,COMREP		;# TO DELETE
	JRST DELETE
;HERE WE SEARCH FOR A SUBSTRING OF THE CURRENT STRING
ALTZAP:	SETOM CHRALT		;FLAG DELETE
	CAIA
ALTFND:	SETZM CHRALT		;FLAG NO DELETE
	TRZE TYPNEG
	JRST MSORRY
	TLNN M,DSKACT!MACACT
	SKIPN A			;WANT PROMPT?
	CAIA
	OUTSTR[ASCIZ/TYPE SEARCH STRING.
/]
	PUSHJ P,TREADC
	JRST COMCLR		;ALTMODE
	JRST [
MD,<
		SKIPE B,FPTSTR	;YES, USE TEXT SEARCH STRING
		JRST .+1
>;MD
		JRST PERRET]	;NO STRINGS AT ALL, ERROR
	MOVEM B,ALTSTR	;SAVE POINTER HERE
	PUSHJ P,ADZERO	;MAKE SURE THERE IS A ZERO ON THE END
	SKIPN COMREP
	AOS COMREP
	SETZM AFIND		;NOTHING FOUND YET
	TRNE ATLP	;AT END?
	JRST ALTFN2
	MOVE A,TXTBYT	;BACK UP ONE INITIALLY
	ADD A,[160000,,0]
	SETOM BEGLIN	;START AT FRONT
	TRNN ATFP	;IS IT TRUE?
	SETZM BEGLIN	;NOT AT FIRST CHAR
	SETOM FSTART
ALTFN1:	PUSHJ P,MATCH	;TRY TO MATCH THEM
	JRST ALTFN2	;NO MATCH
	SOSLE COMREP	;DONE?
	JRST ALTFN1	;NO, TRY AGAIN
ALTFN2:	MOVE T,FSTART	;COUNT TO START
	MOVEM T,COMREP
	JUMPE T,.+2	;MAY ALREADY BE THERE
	PUSHJ P,FORWRD	;MOVE TO THERE
	MOVE B,ALTSTR
MD,<	CAME B,FPTSTR	;WAS THIS THE TEXT SEARCH STRING?	>
	PUSHJ P,PUTFS	;NO, GIVE BACK FREE STORAGE
	SKIPE T,FLEN		;NON-ZERO STRING FOUND?
	TRNE ATLP		;YES, AT END?
	JRST COMCLR		;LOSE
	MOVEM T,COMREP		;THIS IS HOW MANY TO DO
	SETOM AFIND		;FLAG SOMETHING FOUND
	SKIPN CHRALT		;NON-ZERO MEANS DELETE
	JRST FORWRD		;ELSE JUST MOVE TO END
	JRST DELETE

ADZERO:	MOVE T,B
	HRRZ B,(B)
	JUMPN B,.-2
	MOVE TT,1(T)
	TRNN TT,376
	POPJ P,
	GETFS (TT)
	SETZM 1(TT)
	SETZM (TT)
	HRRM TT,(T)
	POPJ P,
