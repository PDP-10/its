;<DRAW>CLOSE.FAI.58, 15-NOV-75 18:03:22, EDIT BY HELLIWELL
VERSION(CLOSE,2)
GETCLS:	TRNE STBOX
	 POPJ P,
	MOVE A,CURSE
	EXCH A,LSTCUR		;SET CURRENT CURSOR POS AS LAST FOUND!
	TRZN NEEDCL
	CAME A,CURSE		;MOVED SINCE LAST FIND?
	 JRST GETCL1
	JRST GETCL2		;NO
GETCL1:	PUSHJ P,PUSHIT
	PUSHJ P,FNDCLS
	PUSHJ P,POPIT
	SETOM CLOSUP
GETCL2:	SKIPN A,CLOSES
	POPJ P,
	JRST CPOPJ1

SCLOSP:	PUSHJ P,SCLOSL
	MOVE T,1(T)
	TDZ T,[1,,1]		;CLEAR THESE BITS
MD,<	MOVE TTT,MODE
	CAIE TTT,BTXTM
	 JRST SCLSP1
	MOVE TTT,BTBODY
	PUSH P,F
	FETCH(F,TTT,BORI)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<ADDR(TTT,BXY)>)
SCLSP1:
>;MD
	MOVEM T,LSTCUR		;THIS IS NOW CURSOR POS OF LAST CLOSEST
	JRST CHKON

SCLOSL:	PUSH P,TT
	MOVE TT,MODE
	XCT CLOSLT(TT)
SCLOS1:	HRL T,TT
	HRRZ TT,(TT)
	CAIN TT,(T)
	JRST SCLOSX
	JUMPN TT,SCLOS1
	POP P,TT
	PUSHJ P,FUCKUP
	POPJ P,

CLOSLT:	MOVEI TT,SETPNT	;S
	MOVEI TT,DBODPN	;B
MD,<	MOVEI TT,PONPNT	>	;P
MPC,<	PUSHJ P,PONSID	>	;P
	PUSHJ P,FUCKUP	;L
MD,<	MOVEI TT,PONPNT	>	;T
MPC,<	PUSHJ P,PONSID	>	;T
	PUSHJ P,FUCKUP	;A
	PUSHJ P,FUCKUP	;MA
	PUSHJ P,FUCKUP	;SP
MD,<	PUSHJ P,BTLAST	;BT
	PUSHJ P,FUCKUP	;BTA
	PUSHJ P,FUCKUP	;E
	PUSHJ P,FUCKUP	;EI
	JRST SCLOSX	;ET  DOESN'T USE CLAST
	JRST SCLOSX	;EP	"
	PUSHJ P,FUCKUP	;EG
	PUSHJ P,FUCKUP	;EA
>;MD
REPEAT NUMODES-<.-CLOSLT>,<PUSHJ P,FUCKUP>

MD,<
BTLAST:	MOVE TT,BTBODY
	MOVEI TT,ADDR(TT,BTXT)
	POPJ P,			;RETURN POINTER TO LIST HEAD
>;MD

MPC,<
PONSID:	FETCHL(TT,T,PBIT)
	EQV TT,SID
	SKIPL TT		;ON CURRENT SIDE?
	 SKIPA TT,[PONPN2]	;NO
	 MOVEI TT,PONPNT	;YES
	POPJ P,
>;MPC

SCLOSX:	POP P,TT
SCLOSE:	HRRZM T,CLOSES
	HLRZM T,CLAST
	PUSH P,T
	MOVE T,CURSE
	MOVEM T,LSTCUR			;NOTE LAST PLACE WE SET CLOSEST
	POP P,T
	SETOM CLOSUP
	TRZ NEEDCL			;IF SETTING CLOSEST, DON'T NEED NEW ONE
	POPJ P,

FNDCLS:	TRNE INMOV
	POPJ P,			;DON'T GAFROTZ CLOSES
	MOVE T,MODE
	JRST @FNDTAB(T)

FNDTAB:	FNDSET		;S
	FNDBOD		;B
	FNDPNT		;P
	FNDLIN		;L
	FNDPNT		;T
	NOFNDS		;A
	NOFNDS		;MA
	CPOPJ		;SP
MD,<	BTXFND		;BT
	NOFNDS		;BTA
	EDIFND		;E
	NOFNDS		;EI
	EDTFND		;ET
	EDPFND		;EP
>
REPEAT NUMODES+<FNDTAB-.>,<NOFNDS
>

NOFNDS:	SETZM CLOSES	;NO CLOSEST ANYTHING
	POPJ P,
FNDLIN:	SETZM CLOSES	;CLEAR CLOSEST POINTER
	PUSHJ P,CLSLIN	;FIND CLOSEST LINE
	MOVEM A,CLOSES	;SAVE AS CLOSEST LINE (DON'T USE CLAST HERE)
	POPJ P,

CLSLIN:	SETZ A,		;NO CLOSEST YET
	SKIPN B,PONPNT	;NO POINTS?
	 POPJ P,
	MOVSI T,177777	;FAR ENOUGH
	MOVEM T,DIFSOF
FLLOP:
MD,<
	FETCH(E,B,PND)
	JUMPE E,.+2	;NONE?
	PUSHJ P,ISCLLN	;SEE IF CLOSER
	FETCH(E,B,PNR)
	JUMPE E,.+2	;NONE?
	PUSHJ P,ISCLLN	;SEE IF CLOSER
>;MD
MPC,<	FETCH(D,B,PNEB)
	JUMPE D,FLLOP2
FLLOP1:	HLRZ E,(D)
	JUMPE E,.+2
	PUSHJ P,ISCLLN
	HRRZ E,1(D)
	JUMPE E,.+2
	PUSHJ P,ISCLLN
	HLRZ E,1(D)
	JUMPE E,.+2
	PUSHJ P,ISCLLN
	HRRZ D,(D)
	JUMPN D,FLLOP1
FLLOP2:
>;MPC
	FETCH(B,B,PNXT)
	JUMPN B,FLLOP
	POPJ P,

ISCLLN:	FETCH(C,B,PXY)	;GET X,Y OF FIRST POINT
MPC,<	CAMGE C,ADDR(E,PXY)	;DO SEGMENT ONCE ONLY
	 POPJ P,
>;MPC
	FETCH(F,E,PXY)	;GET X,Y OF SECOND POINT
	MOVE TTT,CURSE	;GET CURSOR X,Y
	MOVE T,F
	XOR T,C		;GET DIFFERENCE
	TLNN T,-1	;LEFT HALF ZERO?
	JRST [TRNN T,-1	;YES, RIGHT HALF ZERO TOO?
		POPJ P,	;YES
		MOVEI TT,1 ;NO, LEFT HALF ONLY, ZERO. VERT. LINE
		HRRZM TTT,TPOINT
		HLLM F,TPOINT
		JRST LRTCON]
	TRNE T,-1	;RIGHT HALF ZERO?
	JRST LRSLAN	;NO, SLANTY LINE
	MOVEI TT,2	;YES, HORIZ. LINE
	HLLZM TTT,TPOINT
	HRRM F,TPOINT
	MOVSS F
	MOVSS C		;SWAP HALVES
	MOVSS TTT
LRTCON:	HLRE T,C	;GET THE PART THAT'S THE SAME (X OR Y)
	HRRES F
	HRRES C
	HRRE G,TTT
MD,<	CAME F,G	;WELL IF PHIL SAYS SO!
	CAMN C,G	;EITHER END SAME AS CURSOR?
	POPJ P,		;YES, CAN'T BE CLOSE
>;MD
	CAML F,G	;GREATER THAN ONE BUT LESS THAN THE OTHER?
	JRST [CAMG C,G
		JRST ISPOSS
		POPJ P,];NO, NOT CLOSE
	CAMG C,G
	POPJ P,		;NO, NOT CLOSE
ISPOSS:	HLRES TTT	;GET OTHER THING
	SUB TTT,T	;GET DIFFERENCE
	IMUL TTT,TTT	;SQUARE IT
	CAML TTT,DIFSOF	;DISTANCE SMALLER?
	POPJ P,		;NO
ITCLSS:	TLNE M,XWINDOW!MACACT!DSKACT
	JRST ITCLSX
	MOVE T,TPOINT	;TAKE INTERSECTION POINT
	PUSH P,TTT
	PUSHJ P,ONSCR
	JRST [	POP P,(P)
		POPJ P,]	;NOT ON
	POP P,TTT
ITCLSX:	MOVEM TTT,DIFSOF;YES, DEPOSIT NEW DISTANCE
	MOVE A,B	;GET POINTERS
	HRL A,E
	MOVE T,TPOINT
	TDZ T,[1,,1]
	MOVEM T,IPOINT
	POPJ P,
LRSLAN:	HLRE T,CURSE
	MOVEM T,DX1		;STORE HERE TERMPORARILY
	HRRE T,CURSE
	PUSHJ P,CALINE		;RETURN LENGTH IN TTT
	POPJ P,			;OFF ONE END OR OTHER
	DIV TT,L2		;DO FINAL CALC
	MOVM TTT,TT
	CAML TTT,DIFSOF
	POPJ P,
	CAML T,L2
	JRST [	FETCH(T,E,PXY)
		MOVEM T,TPOINT
		JRST ITCLSS]
	PUSH P,TTT
	DIV T,L2		;CALC SCALE
	FETCH(TTT,B,PY)
	FETCH(TT,E,PY)
	SUB TT,TTT
	MULM T,TT
	ADD TT,TTT
	MOVEM TT,TPOINT
	HLRE TTT,1(B)
	HLRE TT,1(E)
	SUB TT,TTT
	MULM T,TT
	ADD TT,TTT
	HRLM TT,TPOINT
	POP P,TTT
	JRST ITCLSS

CALINE:	FETCH(TT,B,PY)
	SUB T,TT
	MOVEM T,DY1
	FETCH(T,E,PY)
	SUB T,TT
	MOVEM T,DY3
	FETCH(TT,B,PX)
	MOVE T,DX1
	SUB T,TT
	MOVEM T,DX1
	FETCH(T,E,PX)
	SUB T,TT
	MOVEM T,DX3
	MOVE T,DX3
	IMUL T,DX3
	MOVE TT,DY3
	IMUL TT,DY3
	ADD T,TT
	MOVEM T,L2
	MOVE T,DX1
	IMUL T,DX3
	MOVE TT,DY1
	IMUL TT,DY3
	ADD T,TT
	JUMPLE T,CPOPJ		;NEGATIVE MEANS OFF ONE END
	MOVMS T
	CAML T,L2
	POPJ P,
	MOVE TT,DX1		;INSIDE LINE, CALC LENGTH
	IMUL TT,DY3
	MOVE TTT,DX3
	IMUL TTT,DY1
	SUB TT,TTT
	MUL TT,TT		;PRODUCE DOUBLE LENGTH RESULT
	JRST CPOPJ1
;SQRT:	FINDS THE SQUARE ROOT OF THE INTEGER IN T.  USES TT AND TTT
SQRT:	JFFO T,.+2	;FIND THE HIGH ORDER BIT
	POPJ P,		;ZERO?
	SUBI TT,=37
	MOVNS TT
	LSH TT,-1
	MOVEI TTT,1
	LSH TTT,-1(TT)	;MAKE WORD WITH HALF AS MANY LOW ORDER BITS
	SETOM SQRFLG	;TURN ON TEMP (COUNT) FLAG
SLOP1:	MOVE TT,TTT	;GET APROXIMATE SQRT
	IDIVM T,TT	;DIVIDE IT INTO THE SQUARE
	ADD TT,TTT	;ADD APROX.
	ASH TT,-1	;DIVIDE BY 2. THIS IS THE NEW APPROX.
	MOVE TTT,TT	;GET APPROX.
	IDIVM T,TTT	;DIVIDE IT INTO THE SQUARE
	ADD TTT,TT	;ADD APPROX.
	ASH TTT,-1	;DIVIDE BY 2. THIS IS THE NEW APPROX.
	AOSG SQRFLG	;GONE THROUGH TWICE?
	JRST SLOP1	;NO
	MOVE T,TTT
	POPJ P,
;FNDSET, FNDBOD, FNDPNT, EDTFND, EDPFND, EDIFND
FNDSET:	MOVEI F,SETPNT	;GET SET POINTER
	JRST CLFNDA	;FIND CLOSEST SET.

FNDBOD:	MOVEI F,DBODPN	;GET POINTER TO LIST OF BODIES
	JRST CLFNDA	;FIND BODY WHICH IS CLOSEST TO CURSOR

FNDPNT:	MOVEI F,PONPNT	;GET POINTER TO POINTS WHICH ARE ON THE SCREEN
	JRST CLFNDA	;FIND POINT WHICH IS CLOSEST OT CURSOR

MD,<
BTXFND:	MOVE F,BTBODY
	MOVEI F,RADDR(F,BTXT,QNXT)
	JRST CLFNDA

EDTFND:	MOVE A,CURBOD	;GET POINTER TO CURRENT BODY (TYPE) DEFINITION
	FETCH(B,A,TPROP)	;last won't be right if first prop!!
	JRST CLFND	;FIND PIECE OF TEXT CLOSEST TO CURSOR

EDIFND:	MOVE A,CURBOD
	MOVEI F,RADDR(A,TLIN,QNXT)
	JRST CLFNDA	;FIND CLOSEST POINT IN LINES

EDPFND:	MOVE A,CURBOD	;GET POINTER TO CURRENTLY-BEING-EDITED TYPE DEF.
	MOVEI F,RADDR(A,TPIN,QNXT)
	JRST CLFNDA
>;MD
;CLFNDA - FIND GEOMETRICALLY CLOSEST
;F = Pointer before list of POINTS, BODIES, SET, DISPLAY LIST, ...
;Returns closest item in A and CLOSES
;CLOSES =	ITEM
;CLAST =	PREVIOUS ITEM
; (Note: if Closest to TYPE property, CLAST may not have the right
;	thing if that is the first prop on list. The pointer
;	to the prop list is in the LH for a type! Crock)

CLFNDA:	FETCH(B,F,QNXT)		;NEXT ITEM OF POINT (OR BODY OR SET)
CLFND:	HRLOI TT,177777		;MAKE A LARGE NUMBER(LARGE ENOUGH)
	MOVE E,TT
	SETZB A,CLOSES		;CLEAR CLOSEST POINTERS
	JUMPE B,CPOPJ
CLOP1:	FETCH(T,B,QXY)		;GET X,Y WORD
	TDZ T,[1,,1]
	TRNE INLIN		;DRAWING A LINE?
	CAME B,LINING		;YES, IS THIS THE POINT FROM WHICH WE ARE DRAWING?
	CAIA
	JRST CLOP2		;YES, IGNORE IT
	MOVE D,MODE
	CAIE D,TXTM
	JRST NOTXTM		;NOT TEXT MODE
	FETCH(D,B,PTXT)		;ANY TEXT ON THIS POINT?
	JUMPE D,CLOP2
NOTXTM:
MD,<	MOVEI D,1
	LSH D,@MODE
	TDNN D,[1EDTTM!1BTXTM]
	JRST NOETXM
	TDNN D,[1BTXTM]
	JRST NADJBT
	MOVE TTT,BTBODY		;BODY WE'RE EDITING
	PUSH P,F
	FETCH(F,TTT,BORI)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TTT)>)	;CALC SCREEN POS OF TEXT
NADJBT:	FETCH(D,B,TXBIT)
	TRNE D,TXBIND
	 JRST CLOP2		;DON'T FIND INDIRECT POINTERS
	FETCH(D,B,TXVAL)
	FETCH(D,D,TSSIZ)	;0 SIZE MEANS INVISIBLE PROPERTY
	TLNN M,%IDENT
	JUMPE D,CLOP2
NOETXM:
>;MD
	MOVEM T,CLXY		;SAVE X,Y HERE
	SUB T,CURSE		;SUBTRACT CURSOR POSITION
	MOVMS T			;GET ABS OF DIFFERENCE
	CAMLE T,TT		;THIS ONE SMALLER X DISTANCE?
	JRST CLOP2		;YES, THINK ABOUT IT MORE 
TRYIT:	FETCH(T,B,QXY)
	CAMN T,ADDR(A,QXY)
	JUMPN A,CKCOIN		;IF ALREADY HAVE CLOSEST AT SAME PLACE, CHECK
	TLNE M,DSKACT!MACACT!XWINDOW	;WINDOWING?
	JRST WINX		;NO TEST IF NO WINDOW
	MOVE T,CLXY		;YES, SEE IF ONSCREEN
	PUSHJ P,ONSCR
	JRST CLOP2
;FALLS THRU
WINX:	HLRE T,CLXY		;GET X OF POINT
	HLRE D,CURSE		;GET X OF CURSOR
	SUB T,D			;GET DIFF.
	MOVMS T			;ABS VAL.
	HRRE D,CLXY		;GET Y OF POINT
	SUB D,CURSE		;SUBTRACT CURSOR (Y IN RIGHT HALF)
	HRRES D			;GET Y PART
	MOVMS D			;ABS. VAL.
	IMUL D,D		;Y^2
	IMUL T,T		;X^2
	ADD T,D			;X^2+Y^2
	CAMLE T,E		;SMALLER OR EQUAL DISTANCE?
	JRST CLOP2		;NO
	MOVE A,B		;YES, SHORTEST SO FAR. HOLD POINTER TO IT
	HRL A,F			;ALSO LAST POINTER
	MOVE E,T		;REPLACE COMPARE WITH NEW ONE
	PUSHJ P,SQRT		;GET SQRT OF DISTANCE
	ADDI T,20		;SAFETY FACTOR
	MOVS TT,T		;REPLACE THE X-PART COMPARE WITH THE DISTANCE
CLOP2:	MOVE F,B		;LAST POINTER
	FETCH(B,B,QNXT)		;NO, GO TO NEXT
	JUMPN B,CLOP1		;LOOP IF MORE TO LOOK AT
	HRRZM A,CLOSES		;DEPOSIT POINTER TO CLOSEST
	HLRZM A,CLAST		;ALSO LAST
	POPJ P,

CKCOIN:	MOVEI TTT,1
	LSH TTT,@MODE
	TDNN TTT,[1PNTM!1TXTM]
	JRST WINX		;ONLY CHECK POINTS
	FETCH(TTT,A,PBIT)
	TRNE TTT,MPC,<CPIN!>ISPIN	;DON'T FIND PIN IF COINCEDENT
	JRST WINX			;CONTINUE CHECK
	JRST CLOP2			;LOSE IMMEDIATELY
;UPCLOS
UPCLOS:	TLNE DSPACT	;DISPLAYING AT ALL?
	TRNE INMOV!STBOX;DOING ANYTHING OBVIOUSLY WRONG?
	POPJ P,		;YES, DON'T INDICATE CLOSEST
	SKIPN CLOSUP		;NEED TO UPDATE CLOSES DISPLAY?
	POPJ P,			;NO
	SETZM CLOSUP
	MOVE T,MODE
	SKIPE A,CLOSES
	JRST @UPTAB(T)
UPNONE:	MOVEI T,BIGPG
	JRST HYDPOG

UPTAB:	.UPSET		;S
	.UPBOD		;B
	.UPPNT		;P
	.UPLIN		;L
	.UPPNT		;T
	UPNONE		;A
	UPNONE		;MA
	UPNONE		;SP
MD,<	.UPBTX		;BT
	UPNONE		;BTA
	.UPED		;E
	UPNONE		;EI
	.UPED		;ET
	.UPEDP		;EP
>
REPEAT NUMODES+<UPTAB-.>,<UPNONE
>

SPSETUP:
	SKIPA T,[ANGLPG]
.SETUP:	MOVEI T,BIGPG
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	JRST SETBRT

.UPVCT:	MOVE T,1(A)	;X,Y OF THING
.UPT:	TDZ T,[1,,1]
	PUSHJ P,ONSCR	;ON SCREEN?
	 POPJ P,
	PUSHJ P,VHLINE	;MAKE CROSS HAIRS (MAYBE)
	PUSHJ P,BIGAIV	;PUT IN VECTOR TO THERE
	JRST CPOPJ1

MD,<
.UPEDP:	PUSHJ P,.SETUP
	MOVE T,1(A)
	PUSHJ P,.UPT
	JRST UPNONE
	MOVEI T,"*"+"*"+1
	PUSHJ P,TXTDPB
	JRST BLINKO

.UPBTX:	PUSHJ P,.SETUP
	MOVE T,1(A)
	PUSH P,F
	MOVE TT,BTBODY
	FETCH(F,TT,BORI)
	PUSHJ P,ORIENT
	POP P,F
	ADJUST(ADD,T,<1(TT)>)
	PUSHJ P,.UPT
	JRST UPNONE
	FETCH(T,A,TXNAM)
	SKIPE T			;SKIP IF NOT PROPERTY
	 SKIPA T,[ASCID/BTP/]
	 MOVE T,[ASCID/BT/]
	PUSHJ P,TXTDPB
	JRST BLINKO
>;MD

MD,<
.UPED:	SKIPA T,[ASCID/*/]
>;MD
.UPBOD:	MOVEI T,"B"+"B"+1
	PUSH P,T
	PUSHJ P,.SETUP
	PUSHJ P,.UPVCT
	JRST [	POP P,(P)
		JRST UPNONE]
	POP P,T
	PUSHJ P,TXTDPB
	JRST BLINKO	;OUTPUT IT

SETBRT:
MPC,<	TRNE BTHSDS
	SKIPA T,BTHBRT	;ALWAYS USE 7 IF BOTH SIDES ARE ON
>;MPC
	MOVE T,DEFBRT	;GET CURRENT BRIGHTNESS
	ADDI T,1
	JRST DPYBRT
;.UPPNT
.UPPNT:	PUSHJ P,.SETUP
	PUSHJ P,.UPVCT
	JRST UPNONE
	MOVSI T,(<ASCII/*/>)
	TRNE INLIN		;DRAWING A LINE?
	JRST GTPNTC		;YES, JUST STAR
	MOVSI T,(<ASCII/P/>)
	FETCH(TT,A,PTXT)
	JUMPE TT,NOTEX		;ANY TEXT?
	MOVSI T,(<ASCII/T/>)
	FETCH(TT,TT,TCSTR)
	FETCH(TTT,TT,TSSIZ)
	TRNE TTT,400000
	 TLO T,(<BYTE(7),"V">)
NOTEX:	FETCHL(TT,A,PBIT)
	TLNE TT,ISPIN		;IS THIS POINT A PIN
	 TRO T,"A"+"A"		;YES, TACK ON AN A
	TLNE TT,CPIN		;CONNECTOR PIN?
	 TRO T,"C"+"C"		;TACK ON A "C"
MD,<	SKIPN ADDR(A,PND)
	SKIPE ADDR(A,PNL)	;ANY LINES ATTACHED HERE?
	 TRO T,"L"10
>;MD
MPC,<	FETCH(TTT,A,PNEB)
	JUMPE TTT,UPPNTA
UPPNTB:	SKIPE 1(TTT)
	JRST UPPNTC
	SKIPN TTT,(TTT)
	JRST UPPNTA
	TLNN TTT,-1
	JRST UPPNTB
UPPNTC:	TRO T,"L"10
UPPNTA:	LDB TTT,[POINT 3,TT,6]
	IOR T,(TTT)[	0
			"G"17
			"1"17
			"2"17
			"3"17
			0
			0
			0	]
>;MPC
GTPNTC:	TRO T,1		;MAKE IT ASCID
	PUSHJ P,TXTDPB
	JRST BLINKO	;OUTPUT THE THING
;.UPSET
.UPSET:	PUSHJ P,.SETUP
	PUSHJ P,.UPVCT
	SKIPA T,[1]		;FLASH THE ONES ON SCREEN ANY WAY
	MOVEI T,"S"+"S"+1	;ASCID S
	PUSHJ P,DCLSET
	JRST BLINKO		;AND BLINK IT

DCLSET:	PUSHJ P,TXTDPB
	HLRZ A,(A)	;POINTER TO THIS SET
STPNTR:	HRRZ TT,1(A)	;POINTER TO FIRST POINT IN SET
	JUMPE TT,SNOPNT	;NO POINT?
	MOVE T,1(TT)
	PUSHJ P,ONSCR
	JRST SNOPNT
MPC,<	FETCHL(T,TT,PBIT)
	EQV T,SID	;ON THIS SIDE?
	TLNN T,FRONT
	 TRNE BTHSDS	;OR BOTH SIDES ON?
	 CAIA
	 JRST SNOPNT	;NO
>;MPC
	FETCH(T,TT,PXY)
	PUSHJ P,BIGAIV
	MOVEI T,"P"+"P"+1	;ASCID P
	PUSHJ P,TXTDPB
SNOPNT:	HLRZ T,1(A)		;POINTER TO FIRST BODY IN SET
	JUMPE T,SNOBOD		;NO BODY?
	MOVE T,1(T)		;X,Y
	PUSHJ P,BIGAIV
	MOVEI T,"B"+"B"+1	;ASCID B
	PUSHJ P,TXTDPB
SNOBOD:	HRRZ A,(A)		;NEXT WORD OF SET
	JUMPN A,STPNTR
	POPJ P,
;.UPLIN
.UPLIN:	PUSHJ P,.SETUP
	MOVE T,IPOINT
	PUSHJ P,ONSCR
	JRST [	MOVEI T,BIGPG
		JRST HYDPOG]
	PUSHJ P,VHLINE	;MAKE CROSS HAIRS (MAYBE)
	PUSHJ P,BIGAIV 	;PUT IN VECTOR TO THERE
	MOVEI T,"L"1+1	;ASCID L
	PUSHJ P,TXTDPB
	JRST BLINKO
;LINES, BOXES, BODY
DOSLPB:	MOVE T,MODE
	JRST @SLPBTB(T)

SLPBTB:	DRWBOX		;S
	NOSLPB		;B
	DOANGL		;P
	NOSLPB		;L
	DOANGL		;T
	ARROW		;A
	ARROW		;MA
	DOSPM		;SP
MD,<
	NOSLPB		;BT
	ARROW		;BTA
	NOSLPB		;E
	NOSLPB		;EI
	NOSLPB		;ET
	NOSLPB		;EP
	NOSLPB		;EG
	ARROW		;EA
>;MD
REPEAT NUMODES+<SLPBTB-.>,<NOSLPB
>

NOSLPB:	MOVEI T,ANGLPG
	JRST HYDPOG

DOSPM:	JRST @SPDISP

UPSTAL:	PUSHJ P,SPSETUP
	TRNE INLIN
	 PUSHJ P,DOANGS		;OUTPUT ANGLE HERE
	JRST UPSTA1

UPSTAR:	PUSHJ P,SPSETUP		;SETUP TO ANGLE PG
UPSTA1:	MOVE T,STARLOC
	PUSHJ P,.UPT		;ONSCREEN? GO THERE
	 JRST UPNONE
	MOVEI T,"*"+"*"+1
	PUSHJ P,TXTDPB
	JRST BLINKO

;UPREP
UPREP:	TRZ MCHG		;NOOP THE MAIN DISPLAY
	MOVEI T,CPOPJ
	MOVEM T,DSPDSP
	PUSHJ P,NOSLPB
	MOVEI T,MAINPG
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	PUSHJ P,SETBRT
	SETZ F,
	MOVE A,OLDTYP
	MOVEI D,0
	UNSCAL(D)
	ADD D,YOFF
	MOVE T,[(3*%LEFT+%RIGHT)/4]
	UNSCAL(T)
	ADD T,XOFF
	HRL D,T
	PUSHJ P,PUTBDL
	MOVE T,[(3*%RIGHT+%LEFT)/4]
	UNSCAL(T)
	ADD T,XOFF
	HRL D,T
	MOVE A,NEWTYP
	PUSHJ P,PUTBDL
	JRST MAINOU
;ANGLE (LINE OR SETBOX)
DOANGL:	TRNE INLIN	;ARE WE IN A LINE?
	SKIPN LINING	;REALLY????
	JRST NOSLPB	;NO
	MOVEI T,ANGLPG
	MOVEM T,PGLASS	;YES, USE PIECE OF GLASS 1
	PUSHJ P,DPYSET	;SET UP BUFFER
	PUSHJ P,SETBRT
	PUSHJ P,DOANGS
	JRST BLINKO	;OUTPUT IT

DOANGS:	MOVE A,LINING	;GET POINTER TO CURRENT POINT WE ARE DRAWING FROM
	MOVE T,1(A)	;GET X,Y
	PUSHJ P,AIVECT	;DRAW INVIS. TO IT
MD,<	MOVE T,CURSE	;GET CURSOR POSITION
	TRNN ZIGZAG	;OTHER WAY?
	MOVE T,1(A)	;YES, GET POINT
	HLL T,CURSE	;GET CURSOR X
	TRNE ZIGZAG	;OTHER WAY?
	HLL T,1(A)	;NO, GET POINT X
	PUSHJ P,AVECT	;DRAW LINE TO IT
>;MD
	MOVE T,CURSE	;GET CURSOR POSITION
	JRST AVECT	;DRAW LINE TO IT
;SETBOX
DRWBOX:	TRNN STBOX
	JRST NOSLPB
	MOVEI T,ANGLPG
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	MOVE A,SETBOX
	MOVE T,1(A)
	PUSHJ P,AIVECT
	JRST NXTDRW
NXTDR1:	MOVE T,1(A)
	PUSHJ P,AVECT
NXTDRW:	HRRZ A,(A)
	JUMPN A,NXTDR1
	MOVE A,ENDBOX
	MOVE T,CURSE	;GET CURSOR POSITION
	TRNN ZIGZAG	;OTHER WAY?
	MOVE T,1(A)	;YES, GET POINT
	HLL T,CURSE	;GET CURSOR X
	TRNE ZIGZAG	;OTHER WAY?
	HLL T,1(A)	;NO, GET POINT X
	PUSHJ P,AVECT	;DRAW LINE TO IT
	MOVE T,CURSE	;GET CURSOR POSITION
	PUSHJ P,AVECT	;DRAW LINE TO IT
	JRST BLINKO
;ARROW
ARROW:	MOVE T,TXTCNT
	CAMN T,LPNTR
	POPJ P,
	MOVEM T,LPNTR
	MOVN T,ALTLIN
	MOVEM T,LINCNT		;INITIALIZE TO - NUMBER OF LINES WE HAVE MOVED UP
	SETZM CHRCNT
	MOVE T,TXTPNT
	ADD T,[POINT 7,1]
	MOVE TTT,TXTCNT
	MOVEM TTT,TOTCNT
ARROW1:	TLNN T,760000
	JRST [	HRR T,-1(T)
		TRNE T,-1
		JRST .+1
		JRST ARROW2]
	ILDB TT,T
	JUMPE TT,ARROW1
	SOSG TOTCNT
	JRST ARROW2
	AOS TTT,CHRCNT
	CAIL TTT,MAXLIN			;FORCED CRLF?
	JRST ARROW3			;YES
	CAMN TT,EOLCHR			;END OF LINE CHARACTER?
	JRST ARROW3
	JRST ARROW1

ARROW3:	SETZM CHRCNT
	AOS LINCNT
	JRST ARROW1

ARROW2:	MOVEI T,ANGLPG
	SKIPL TT,LINCNT		;IS TEXT ON SCREEN?
	CAILE TT,MAXPAG		;CHECK TOP ALSO
	JRST HYDPOG		;NO, HIDE CURSOR
	MOVEM T,PGLASS
	PUSHJ P,DPYSET
	MOVEI TT,106
	TDO TT,BSOR
	MOVN T,LINCNT
	IMUL T,DPYPTY+ACHRSZ
IFN AYPOS,<	ADD T,[AYPOS]	>
	DPB T,[POINT 11,TT,21]		;Y PART
	MOVN T,DPYPTX+ACHRSZ
IFN AXPOS,<ADD T,[AXPOS]>
	DPB T,[POINT 11,TT,10]	;X PART
	PUSH P,TT
	TRO TT,40
	PUSHJ P,INSOU2			;DEPOSIT
	MOVE TT,CHRCNT
	IMUL TT,DPYPTX+ACHRSZ
IFN AXPOS,<ADD TT,[AXPOS]>
	SUBI TT,2		;JUST BEFORE CHAR
	DPB TT,[POINT 11,(P),10]
	MOVE TT,(P)
	PUSHJ P,INSOUT			;STUFF IT
	POP P,TT
	LDB T,[POINT 11,TT,21]
	MOVE TTT,DPYPTY+ACHRSZ
	ASH TTT,-2
	ADD T,TTT
	DPB T,[POINT 11,TT,21]
	PUSHJ P,INSOUT
	JRST OUTDPY
