;Definitions common to D,PC, and WL

IFN TWOSW!LIBSW,<
PASS1,<PCSW__0>
PASS2,<PCSW__1>
>;IFN TWOSW!LIBSW

ONE,<
MD,<PASSNM__-1>
MPC,<PASSNM__0>
>;ONE

;OPDEFS

ITS,<
OPDEF CALL	[ 40B8]
OPDEF INIT	[ 41B8]
OPDEF CALLI	[ 47B8]
OPDEF OPEN	[ 50B8]
OPDEF TTYUUO	[ 51B8]
OPDEF RENAME	[ 55B8]
OPDEF IN	[ 56B8]
OPDEF OUT	[ 57B8]
OPDEF SETSTS	[ 60B8]
OPDEF STATO	[ 61B8]
OPDEF GETSTS	[ 62B8]
OPDEF STATZ	[ 63B8]
OPDEF INBUF	[ 64B8]
OPDEF OUTBUF	[ 65B8]
OPDEF INPUT	[ 66B8]
OPDEF OUTPUT	[ 67B8]
OPDEF CLOSE	[ 70B8]
OPDEF RELEASE	[ 71B8]
OPDEF MTAPE	[ 72B8]
OPDEF UGETF	[ 73B8]
OPDEF USETI	[ 74B8]
OPDEF USETO	[ 75B8]
OPDEF LOOKUP	[ 76B8]
OPDEF ENTER	[ 77B8]
OPDEF UJEN	[100B8]
OPDEF DPYCLR	[701B8]
OPDEF PPIOT	[702B8]
OPDEF UPGIOT	[703B8]
OPDEF UINBF	[704B8]
OPDEF UOUTBF	[705B8]
OPDEF FBREAD	[706B8]
OPDEF FBWRT	[707B8]
OPDEF MAIL	[710B8]
OPDEF PTYUUO	[711B8]
OPDEF POINTS	[712B8]
OPDEF UPGMVE	[713B8]
OPDEF UPGMVM	[714B8]
OPDEF PGIOT	[715B8]

OPDEF TTCALL	[TTYUUO]
OPDEF INCHRW	[TTYUUO 0,]
OPDEF OUTCHR	[TTYUUO 1,]
OPDEF INCHRS	[TTYUUO 2,]
OPDEF OUTSTR	[TTYUUO 3,]
OPDEF INCHWL	[TTYUUO 4,]
OPDEF INCHSL	[TTYUUO 5,]
OPDEF GETLIN	[TTYUUO 6,]
OPDEF SETLIN	[TTYUUO 7,]
OPDEF RESCAN	[TTYUUO 10,]
OPDEF CLRBFI	[TTYUUO 11,]
OPDEF CLRBFO	[TTYUUO 12,]
OPDEF INSKIP	[TTYUUO 13,]
OPDEF INWAIT	[TTYUUO 14,]

OPDEF PTWR1S	[PTYUUO 7,]
OPDEF PTWRS9	[PTYUUO 12,]

OPDEF PPSEL [PPIOT 0,]
OPDEF PPACT [PPIOT 1,]
OPDEF DPYPOS [PPIOT 2,]
OPDEF DPYSIZ [PPIOT 3,]
OPDEF PPREL [PPIOT 4,]
OPDEF PGSEL [PGIOT 0,]
OPDEF PGACT [PGIOT 1,]
OPDEF PGCLR [PGIOT 2,]
OPDEF DPYOUT [UPGIOT]

OPDEF SETDDT [CALLI 2]
OPDEF SWAP [CALLI 400004]
OPDEF CORE2 [CALLI 400015]
OPDEF ATTSEG [CALLI 400016]
OPDEF DETSEG [CALLI 400017]
OPDEF SEGNUM [CALLI 400021]
OPDEF DSKPPN [CALLI 400071]

>;ITS

;Local UUO's - must stay in same order, see %UUOCON in [SUB]

OPDEF PUTBYT[1B8]
OPDEF PUTSTR[2B8]
DBG,<
OPDEF .FETCH[3B8]
OPDEF .FETL[4B8]
OPDEF .STORE[5B8]
OPDEF .STORL[6B8]
OPDEF .CLEAR[7B8]
OPDEF .RETBL[10B8]
>;DBG
III,<
;UUO's for Leahy display - these link to CNVERT
OPDEF DPYADD [11B8]
OPDEF DPYIOT [12B8]
 OPDEF DPYCLR [DPYIOT 0,]
 OPDEF DPYSIZ [DPYIOT 7,]
 OPDEF DPYPOS [DPYIOT 6,]
OPDEF DPYOUT [13B8]
>;III

;Old UUO's for 1060 type display
;III,<
;OPDEF DPYADD[45B8]
;OPDEF DPYIOT[42B8]
;OPDEF DPYCLR[DPYIOT 0,]
;OPDEF DPYSIZ[DPYIOT 7,]
;OPDEF DPYPOS[DPYIOT 6,]
;OPDEF DPYOUT[44B8]
;>;III

DEC,<
	OPDEF	DSKPPN	[10B8]
	OPDEF	TTYUUO	[51B8]
	OPDEF	DPYOUT	[3B8]
	OPDEF	DPYCLR	[4B8]
GT,<	OPDEF	IONEOU	[TTYUUO	15,]	;;JB DEFINE THE IMAGE OUT UUO.>
PGP,<	OPDEF	PLIT	[POINT 36,0,35]	>
>;DEC

NOSTANFO,<
OPDEF APRENB [CALLI 16]
OPDEF SETNAM [CALLI 43]
OPDEF UNLOK. [CALLI 120]
OPDEF LOCK [CALLI 60]
OPDEF GETTAB [CALLI 41]
OPDEF DEVNAM [CALLI 64]
OPDEF PATH [CALLI 110]
VIROS,<
OPDEF COMPT. [CALLI 147]
OPDEF ERJMP [JUMP 16,]
OPDEF ERCAL [JUMP 17,]
OPDEF JSYS [104B8]
OPDEF STDIR [JSYS 40]
OPDEF GTSTS [JSYS 24]
OPDEF DVCHR [JSYS 117]
OPDEF STDEV [JSYS 120]
OPDEF GTJFN [JSYS 20]
OPDEF OPENF [JSYS 21]
OPDEF MTOPR [JSYS 77]
OPDEF ERSTR [JSYS 11]
OPDEF CLOSF [JSYS 22]
OPDEF PMAP [JSYS 56]
OPDEF DEVST [JSYS 121]
	VBLOCK__30	;LOCK CODE
	VBSTRT__31	;START CODE
	VBSTOP__32	;STOP CODE
	VBSTAT__33	;STATUS CODE
>;VIROS

OPDEF EXIT [CALLI 12]
OPDEF RESET [CALLI]
OPDEF SETUWP [CALLI 36]
OPDEF DATE [CALLI 14]
OPDEF TIMER [CALLI 22]
OPDEF MSTIME [CALLI 23]
OPDEF GETPPN [CALLI 24]
OPDEF CORE [CALLI 11]
OPDEF SLEEP [CALLI 31]
OPDEF HIBER [CALLI 72]
OPDEF PJOB [CALLI 30]

OPDEF INCHRW [TTYUUO 0,]
OPDEF OUTCHR [TTYUUO 1,]
OPDEF INCHRS [TTYUUO 2,]
OPDEF OUTSTR [TTYUUO 3,]
OPDEF INCHWL [TTYUUO 4,]
OPDEF INCHSL [TTYUUO 5,]
OPDEF GETLIN [TTYUUO 6,]
OPDEF SETLIN [TTYUUO 7,]
OPDEF RESCAN [TTYUUO 10,]
OPDEF CLRBFI [TTYUUO 11,]
OPDEF CLRBFO [TTYUUO 12,]
OPDEF INSKIP [TTYUUO 13,]
>;NOSTANFO

DEFINE ENTPPN<>

IFN DECSW!CMUSW!IIISW,<
NODEC,<	OPDEF DSKPPN [GETPPN] >
DEFINE ENTPPN
<	SKIPN T,FILPPN
	DSKPPN T,
	MOVEM T,FILPPN
>
>;IFN DECSW!CMUSW!IIISW

EXTERNAL .JBOPC,.JBREN,.JBDDT,.JBFF,.JBSYM,.JBHRL,.JBSA,.JBREL
DEC,<
EXTERNAL	.JB41,.JBUUO,.JBTPC,.JBAPR,.JBCNI,.JBINT
GT,<
EXTERN	SAVER,RESTRE,GTINIT,TRANS8,CLEARS,GTRESET
EXTERNAL GTCHRW,GTCHRS,GTCHSL,GTCHWL	;;JB
EXTERN	SENDHD,STPSHW,SRTSHW,BMODDO,BREADM,STLPXY	;;JB
DLX,<INTERNAL DLXJFN,DLXFLG>
INTERNAL NBYTES,OPTFLG,GTX,GTY
>;GT
PGP,<	EXTERN	CHRTAB	>

;SPECIAL PUSHDOWN LIST FOR PDL OVFL HANDLER
SPD2SZ__200
>;DEC
SPPDSZ__10

;MEMORY ORGANIZATION


IFN DECSW!TWOSW,<
SET LOWER,.
TWOSEG
RELOC 400000
SET UPPER,.

VB10,<
NOVIROS,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE UPPER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;NOVIROS
VIROS,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE UPPER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;VIROS
>;VB10

NOVB10,<
DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE LOWER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;NOVB10
>;IFN DECSW!TWOSW


IFE DECSW!TWOSW,<
DEFINE STORAGE(A)
<>
>;IFE DECSW!TWOSW


ITS,<
NOLAY,<
SET LOWER,.
TWOSEG
RELOC 400000
SET UPPER,.

DEFINE STORAGE(A)
<	IFIDN<A><PURE><USE UPPER>
	IFIDN<A><IMPURE><USE LOWER>
	IFIDN<A><LOW><USE LOWER>
	IFIDN<A><DPY><USE LOWER>
>
>;NOLAY
LAY,<
DEFINE STORAGE(A)
<>
>;LAY
>;ITS

;;Allocation in upper segment if Two-Seg-Layout
;; else from lower segment
	DEFINE GETREL (A)
<NOTWO,<
NODEC,<	HRRZ A,.JBREL		>
DEC,<

VB10,<		HRRZ	A,.JBHRL	>
NOVB10,<	HRRZ	A,.JBREL	>
>;DEC
>;NOTWO
TWO,<	HRRZ A,.JBHRL	>
>
;AC'S - SPECIAL CHAR DEFS - OTHER DEFS

;0			;TEMPORARY FLAGS
M_1			;SEMI-PERMANENT FLAG REG
A_2
B_3
C_4
D_5
E_6
F_7
G_10
H_11
T_14
TT_T+1
TTT_TT+1
P_17

SUBTTL AC 0 FLAG BITS

;RIGHT HALF:::

ATFP__1		;EDIT INSERT IS AT THE FIRST POINT
ATLP__2		; "	"     "	 "  "  LAST POINT
TYPNEG__4	; - TYPED LAST IN EDIT INSERT
TFLG__10	;TEMPORARY FLAG
MCHG__20	;MAIN PICTURE CHANGED -- REDISPLAY IT
INLIN__40	;POINT MODE IS MAKING LINES
ZIGZAG__100	;WHICH WAY THE LINES GO FOLLOWING THE CURSOR
INMOV__200	;WE ARE MOVING SOMETHING (A POINT OR A BODY)
STBOX__400	;WE ARE DRAWING A SETBOX(NO OTHER SET COMMANDS ARE LEGAL)
MAKSET__1000		;USED IN DREAD TO MAKE SET OF APPENDED PIC
VIRGIN__2000		;USED IN DREAD TO INDICATE FIRST PIC
NEEDCL__4000		;NEED TO FIND CLOSEST AGAIN REGARDLESS OF LSTCUR
TMOVE__10000		;SPECIAL, MOVING TEXT OFFSET

MPC,<
BTHSDS__400000		;DISPLAYING BOTH SIDES OF PC CARD
>;MPC
MD,<
LMOVE__200000		;SPECIAL, MOVING LOCATION OFFSET
FSTLIB__400000		;TOP LEVEL LIBRARY, NAME WILL BE PUT ON LIST
>;MD

;LEFT HALF
ASK__1		;TEMP FLAG IN VARIOUS ROUTINES
WFLAG__2	;		"
NOINIT__4	;SUPPRESS CALLING OF INIT MACRO ON READIN
IGNORE__10	;DOING DEFINITION OR FALSE PART OF ;F
LOCATE__20	;PUT LOCATOR LINES FROM BIG CHAR
DSPOFF__40	;DISPLAY PACKAGE IS CURRENTLY OFF SCREEN
DSPACT__100	;WE ARE CURRENTLY DISPLAYING (COMBINATION OF FLAGS)
SUBTTL AC M FLAG BITS

;RIGHT HALF

MD,<
NBTEXT__1		;NO BODY TEXT PLEASE
NOCBOX__2		;NO BOX AROUND CONNECTOR PINS, PLEASE
>;MD
MPC,<
NDIPS__1		;USE BOX, INSTEAD OF PADS
FLIP__2			;INVERTING X
XFEED__4		;SUPPRESS DISPLAYING OF FEEDTHROUGHS
XFINGER__10		;SUPPRESS DISPLAYING OF FINGERS
>;MPC

SEXACT__10000		;EXACT MATCH IN SEARCHES
IFN LAYSW!UMLSW,<
ERRORD__20000		;SUPPRESS DISPLAY OF O_??
>;LAYSW!UMLSW
SPACES__40000		;SPACES ARE SIGNIFICANT
NLINES__100000		;NO LINES
CURSOR__200000		;USING BULLSEYE CURSOR
NPTEXT__400000		;NO POINT TEXT PLEASE


;LEFT HALF

PLOCS__1		;DISPLAY PIN NUMBERS
CLOCS__2		;DIPLAY CONNECTOR PIN LOCS!
BLOCS__4		;DISPLAY BODY LOCATIONS!
MD,<UNHIDE__10	>	;MAKE VISIBLE HIDDEN LOCS/PIN #'S, ETC.
XWINDOW__20		;NOT LIMITED TO SCREEN
MD,<RPINID__40	>	;DISPLAY REAL PINIDS (NUMBERS)
TYPREP__100
TYPNLY__200
LWINDOW__400		;WINDOW LINE SEGMENTS!
DSKFLG__1000		;USING DISK INPUT
DSKACT__2000		;DISK INPUT ACTIVE
MACACT__4000		;MACRO INPUT ACTIVE
%IDENT__10000		;PLOT BODYNAMES AND DIPNAMES ON BODIES
MD,<
PINIDS__40000		;DISPLAY DEFAULT PIN NAMES
JUNC3__100000		;DIAMONDS AT JUNCTION OF 3 LINES
DIAMONDS__200000	;PLOT DIAMONDS
>;MD
MPC,<
ROUTE,<
%ROUTE__40000
RDISP__100000		;DISPLAY BIT ARRAY!
>;ROUTE
CRDISP__200000		;DISPLAY CARD
>;MPC
LCENTER__400000		;CENTER ALL THE BLINKING STUFF

SUBTTL PIN, BODY, LIBRARY, DEF AND NAMED MACRO BITS


;POINT TYPE BITS
;PBIT,BPBIT

MPC,<FRONT__400000	;PIN ON FRONT SIDE.>
ISPIN__200000		;THIS IS A PIN
MD,<FIXTXT__40000	;FIXING TEXT OFFSET
FIXRHT__20000		;WHEN FIXING MOVE LINE RIGHT
FIXCON__10000		;FIX CONNECTOR TO TEXT
DEFPIN__4000		;RESERVED FOR WD OUTPUT TO INDICATE DEFAULTED PIN NAME (BODY PINS ONLY)
CPNBTS__6000		;BITS FOR TERMINATOR RULES (CPINS ONLY)
	CPNBPS__7+=18	;LOW ORDER BIT POS
	CPNBSZ__2	;# OF BITS
>;MD
MPC,<FEEDTH__40000	;FEED THROUGH
PLANES__34000		;PLANE CONNECTIONS
%%PLANES__(<POINT 3,0,6>)
>;MPC
CPIN__1000		;THIS POINT IS ALSO A CONNECTOR PIN
FOUNDP__20		;BIT FOR FIND
;BITS 14-17 ARE USED AS MARK BITS HERE AND THERE


;BODY BITS
;BBIT

MD,<
;L1416__1		;LEFT JUSTIFIED 14 PIN DIP IN 16 PIN SOCKET
;R1416__2		;RIGHT	  "	 "  "	"   "  "  "	"
FIXLOC__4		;ALWAYS SET BODY LOC OFFSET FROM DEFINITION
FIXBLO__10		;FIX LOC CHAR OFFSET WHEN LOC CHANGES
>;MD
FOUNDB__200000		;BIT FOR FIND
BTMP1__400000		;HIGH ORDER BIT IS MARK BIT FOR SET HACKS


;BODY DEF PIN BITS
;TPBIT

MD,<
BUSSED__400000	;THIS IS A BUSSED THROUGH PIN, DON'T SHOW PIN #
;200000 AVAILABLE
FOUNDD__100000	;MARK BIT FOR FLPIN COMMAND
DPTMP1__40000	;TEMP MARK BIT
DPTMP2__20000	;ANOTHER
DEC,<
ASSL__2		;ASSERTION LOW
ASSH__1		;ASSERTION HIGH
>;DEC
DEC,<	BASSLH__BUSSED!ASSL!ASSH>
NODEC,<	BASSLH__BUSSED>
>;MD


;PIN POS FIELD DEFINITIONS
XOFFB__7+=18		;LOW ORDER BIT OF X OFFSET
XOFFW__8		;WIDTH OF X FIELD
YOFFB__=14+=18		;LOW ORDER BIT OF Y OFFSET
YOFFW__7		;WIDTH OF Y FIELD
POSB__=17+=18		;LOW ORDER BIT OF POSITION NUMBER
POSW__3			;WIDTH OF POSITION FIELD


;LIBRARY NAME BLOCK BITS (RT HALF OF FIRST WORD OF SECOND BLOCK)
NEEDMR__400000		;NEED TO READ THIS LIRBARY AGAIN TO GET ALL OF DEFINITIONS
TOPLVL__200000		;THIS MARKS A LIBRARY BLOCK READ AT TOP LEVEL


;TYPE DEFINITION BITS
;TBIT

DTMP1__400000		;TEMPORARY MARK BIT
FOUNDL__200000		;THIS BODY HAS BEEN FOUND BY "FLNAME" OR "FLDIP"
XDISLOC__100000		;DON'T DISPLAY BODY LOC IF TRACKING DEFINITION


;MACRO BITS IN LEFT HALF OF NAMED MACRO HEADER BLOCK FIRST WORD
MSAVE__400000		;SAVE THIS MACRO IN DRW OR PC FILE
MACTMP__1		;TEMPORARY MARK BIT


;BITS IN RUNBIT WRITTEN INTO 'WD' FILE.
CABBDY__1		;"CABLE" BODY SEEN ON RUN. (MUST BE SAME AS BIT IN WL)

;BITS IN TXBIT - TEXT OR PROPERTY
TXBIND__400000		;THIS IS INDIRECT FROM BODY TO TYPE
TXBDIP__200000		;THIS PROP IS FROM DIP DEFINITION

SUBTTL COMMON MACROS
;CONCATINATION
	DEFINE CAT $ (A,B)
<	A$B
>

;CHANGE SCREEN FOR TEXT OUTPUT
DEFINE	TVOFF
<ITS,<	PUSHJ P,.TVOFF >
>

DEFINE	TVON
<ITS,<	PUSHJ P,TVMORE >
>

SUBTTL	STRUCTURE MACROS
;THE FOLLOWING NAMES ARE USED IN STRUCTURE POINTER DEFINITIONS
;F.XXX		INSTRUCTION TO FETCH VALUE
;L.XXX		INSTRUCTION TO FETCH VALUE INTO LEFT HALF
;S.XXX			"	STORE   "
;T.XXX			"	  "	"  FROM LEFT HALF
;V.XXX		VALUE OF INDEX INTO BLOCK
;		OR LENGTH OF A BLOCK
;C.XXX		INSTRUCTION TO CLEAR CELL
;N.XXX		SIXBIT NAME OF BLOCK
;U.XXX		INDEX INTO DBG UUOTABLE FOR THIS STRUCTURE ELEMENT

DEFINE .ADD(MACRO,STUFF)<.ADD1(MACRO,\MACRO,<STUFF>)>

DEFINE .ADD1(MACRO,DUMMY,BODY,STUFF)
<	DEFINE MACRO
<DUMMY,<BODY
	STUFF>>;MACRO
>;.ADD1

DEFINE .DONE(MACRO)<.DONE1(MACRO,\MACRO)>

DEFINE .DONE1(MACRO,DUMMY,BODY)
<	DEFINE MACRO
<BODY
>;MACRO
>;DONE1

DEFINE CAT $ (A,B,C,D,E,F)<A$B$C$D$E$F>

;FETCH, STORE MACROS


NODBG,<
DEFINE FETCH $ (AC1,AC2,INDEX)
<	F.$INDEX	AC1,V.$INDEX(AC2)
>

;FETCH INTO LEFT HALF (either HLLZ or HRLZ)
DEFINE FETCHL $ (AC1,AC2,INDEX)
<	L.$INDEX	AC1,V.$INDEX(AC2)
>

DEFINE STORE $ (AC1,AC2,INDEX)
<	S.$INDEX	AC1,V.$INDEX(AC2)
>

;STORE FROM LEFT HALF (HLLM OR HLRM)
DEFINE STOREL $ (AC1,AC2,INDEX)
<	T.$INDEX	AC1,V.$INDEX(AC2)
>

DEFINE CLEAR $ (AC1,INDEX)
<	C.$INDEX	V.$INDEX(AC1)
>

>;NODBG

DBG,<

DEFINE	FETCH $ (AC,XR,INDEX)
<	.FETCH AC,<XR=12>+U.$INDEX
>

DEFINE	FETCHL $ (AC,XR,INDEX)
<	.FETL AC,<XR=12>+U.$INDEX
>

DEFINE	STORE $ (AC,XR,INDEX)
<	.STORE AC,<XR=12>+U.$INDEX
>

DEFINE	STOREL $ (AC,XR,INDEX)
<	.STORL AC,<XR=12>+U.$INDEX
>

DEFINE	CLEAR $ (XR,INDEX)
<	.CLEAR <XR=12>+U.$INDEX
>
>;DBG

DEFINE SBLOCK $ (NAME)
<	INDEX__0
N.$NAME__<SIXBIT'NAME'>
..BLK__N.$NAME			;BLOCK WE ARE IN
DBG,< .ADDB(NAME,INDEX) >
>

DEFINE EBLOCK $ (NAME)
<CHECK(NAME)
V.$NAME__INDEX
IFG INDEX-FSTLEN<FSTLEN__INDEX>
>

DEFINE ADDR $ (AC1,INDEX)<V.$INDEX(AC1)>

DEFINE RADDR $ (AC1,INDEX1,INDEX2)<V.$INDEX1-V.$INDEX2(AC1)>

DEFINE SETBIT $ (BIT,AC1,AC2,INDEX)
<	FETCH(AC1,AC2,INDEX)
	TRO AC1,BIT
	STORE(AC1,AC2,INDEX)
>

DEFINE CLRBIT $ (BIT,AC1,AC2,INDEX)
<	FETCH(AC1,AC2,INDEX)
	TRZ AC1,BIT
	STORE(AC1,AC2,INDEX)
>

DEFINE BCLEAR $ (AC1,AC2,INDEX)
<	SETZM (AC2)
IFG <V.$INDEX-1>,<
	MOVSI AC1,(AC2)
	HRRI AC1,1(AC2)
	BLT AC1,V.$INDEX-1(AC2)
    >
>

DBG,<
DEFINE .ADDF $ (NAME,WHERE)
<	.ADDF1 (\..BLK,NAME,WHERE)
>

DEFINE	.ADDF1 (BLOCK,NAME,WHERE)
<	.ADD(STRUCTURES,<STRUC1(BLOCK,NAME,WHERE)>)
>

DEFINE	STRUCTURES <0,>		;# IS SO THAT \ IN MACRO IS LEGAL (CROCK)

DEFINE	.ADDB (NAME)
<	.ADD(BLOCKS,<BLOCK1(NAME)>)
>
DEFINE	BLOCKS <0,>
>;DBG

DEFINE CHECK $ (INDEX)
<IFE TWOSW!LIBSW,<IFDEF V.$INDEX,<PRINTS \MULTIPLE STRUCTURE IN$DEX - INDEX
\>>
IFN TWOSW!LIBSW,<PASS1,<IFDEF V.$INDEX,<PRINTS \MULTIPLE STRUCTURE IN$DEX - INDEX
\>>>
>

;HWDS, FWD

DEFINE HWDS $ (LEFT,RIGHT,SLE,SRE)
<
IFDIF<LEFT><><
IFDIF<SLE><E><DEFINE F.$LEFT <HLRZ >
	DBG,< .ADDF(LEFT,L)  >
>
IFIDN<SLE><E><DEFINE F.$LEFT <HLRE >
	DBG,< .ADDF(LEFT,LE) >
>
DEFINE L.$LEFT <HLLZ >
DEFINE S.$LEFT <HRLM >
DEFINE T.$LEFT <HLLM >
DEFINE C.$LEFT <HRRZS >
CHECK(LEFT)
V.$LEFT__INDEX
>
IFDIF<RIGHT><><
IFDIF<SRE><E><DEFINE F.$RIGHT <HRRZ >
	DBG,< .ADDF(RIGHT,R) >
>
IFIDN<SRE><E><DEFINE F.$RIGHT <HRRE >
	DBG,< .ADDF(RIGHT,RE) >
 >
DEFINE L.$RIGHT <HRLZ >
DEFINE S.$RIGHT <HRRM >
DEFINE T.$RIGHT <HLRM >
DEFINE C.$RIGHT <HLLZS >
CHECK(RIGHT)
V.$RIGHT__INDEX
>
INDEX__INDEX+1
>

DEFINE FWD $ (WORD)
<
IFDIF<WORD><><
DBG,< .ADDF(WORD,FWD) >
DEFINE F.$WORD <MOVE >
DEFINE S.$WORD <MOVEM >
DEFINE C.$WORD <SETZM >
CHECK(WORD)
V.$WORD__INDEX
>
INDEX__INDEX+1
>
;GETBLK, RETBLK, 

NODBG,<
	DEFINE GETBLK $ (A,BLOCK)
<%%BLK__IFDIF<BLOCK><><V.$BLOCK;>2
	SKIPN A,@BLKPNT+%%BLK
	 JSR NOBLK
	EXCH A,BLKPNT+%%BLK
>

	DEFINE RETBLK $ (A,BLOCK)
<%%BLK__IFDIF<BLOCK><><V.$BLOCK;>2
	TLZ A,-1
	EXCH A,BLKPNT+%%BLK
	HRRZM A,@BLKPNT+%%BLK
>
>;NODBG

DBG,<
	DEFINE GETBLK $ (A,BLOCK)
<%%BLK__V.$BLOCK
	SKIPN A,@BLKPNT+%%BLK+1
	 JSR NOBLK
	EXCH A,BLKPNT+%%BLK+1
	PUSH P,A
	MOVE A,[SIXBIT'BLOCK']
	MOVEM A,@(P)
	POP P,A
	AOS A
>

	DEFINE RETBLK $ (A,BLOCK)
<%%BLK__V.$BLOCK
	.RETBL A,U.$BLOCK
>
>;DBG

;OLD GET FREE STORAGE

	DEFINE GETFS (A)
<	GETBLK (A,QOMMON)
>

;RETURN FREE STORAGE
	DEFINE FSTRET (A)
<	RETBLK (A,QOMMON)
>

SUBTTL	DATA STRUCTURES

;********** STRUCTURE DEFINTIONS **********

FSTLEN__2			;THIS WILL ACCUMULATE LONGEST BLOCK

COMMENT 
Normally, items must have the same format for the first two words:
This is depended on in many routines (like FNDCLS)

SBLOCK	QOMMON
HWDS	(QLH,QNXT)		;...			NEXT POINTER
HWDS	(QX,QY,E,E)		INDEX__INDEX-1
  FWD	  (QXY)			INDEX__INDEX-1
  HWDS	  (Q2LH,Q2RH)
EBLOCK	QOMMON
NIL,<QOMMON#,QLH#,QNXT#,QX#,QY#,QXY#,Q2LH#,Q2RH#>

;ARGUMENT LIST FOR DIPRED, LIST OF BODIES, AND DIPTYPES TO GET
; FROM DIPS.DIP FILE

SBLOCK	GETDIP
HWDS	(GDIP,GNXT)		;PTR TO DIPNAME		NEXT
HWDS	(GFLAG,GBDY)		;FLAG			BODY OR TYPE
 	 INDEX__INDEX-1
 FWD	 (GFBDY)
EBLOCK	GETDIP

	;FLAG is -1 if diptype came from type

;TYPE - BODY DEFINITIONS
MD,<
;*****************************
;*** TYPE DEFINITION BLOCK ***
;*****************************

SBLOCK	TYPE
HWDS	(TLIB,TNAM)		;LIBRARY POINTER	NAME (LH 1ST WD IS DIP TYPE NAME PTR)??
HWDS	(TYP1,TNXT)		;*+1, OR 0		NEXT TYPE
HWDS	(TYP2,TPIN)		;*+2			PINLOC LIST
HWDS	(TPROP,TLIN)		;PROPERTY LIST		DISPLAY DEFINITION
HWDS	(TBIT,TYP3)		;TYPE BITS		*+2 (0 IF USING DEFAULT CHAR OFFSET)
HWDS	(TX,TY,E,E)			;DEFAULT LOC OFFSET (X,Y)
	 INDEX__INDEX-1
 FWD	 (TXY)			; FOR SIMUL ACCESS
HWDS	(TPAK,TDEF)		;PACKAGE CODE		DIP DEF LIST (0 IF NOT IN)
HWDS	(TOX,TOY,E,E)		;DEFAULT CHAR OFFSET (X,Y)
	 INDEX__INDEX-1
 FWD	 (TOXY)
EBLOCK	TYPE
NIL,<TLIB#,TNAM#,TYP1#,TNXT#,TYP2#,TPIN#,TPROP#,TLIN#,TBIT#,TYP3#,TX#,TY#,TXY#
TOX#,TOY#,TOXY#,TDEF#,TPAK#,TYPE#>	;FOR @CREF LISTING

	;IF TYP1 IS 0, THEN ONLY FIRST 2 WDS ARE PRESENT, TYPES ARE ABBREVIATED IF
	;PRESENT IN LIBRARY BUT NOT USED IN DRAWING

SBLOCK	STYP
HWDS	(SLIB,SNAM)
HWDS	(SYP1,SNXT)
EBLOCK	STYP

	;DISPLAY DEFINITION
	;	--,,	next
	;	X,,	Y
	; low order bit
	; 0 = invisible
	; 1 = visible

;*****************************
;***     TPIN BLOCK (D)    ***
;*****************************

SBLOCK	TYPIN
HWDS	(TP1,TPNX)		;*+2			NEXT
HWDS	(TPX,TPY,E,E)		; LOCATION OF PIN ON BODY
	 INDEX__INDEX-1
 FWD	 (TPXY)			;FOR FULL REFERENCE
HWDS	(TPBIT,TPID)		;PIN BITS		PIN ID
HWDS	(TPPOS,TPNAM)		;PIN POS		PIN NAME
EBLOCK	TYPIN
NIL,<TP1#,TPNX#,TPX#,TPY#,TPXY#,TPBIT#,TPID#,TPPOS#,TPNAM#,TYPIN#,>
	;TPNX MUST BE IN 1ST WORD

	;PIN POS:
	;	BYTE (7)X(7)Y(4) 8 POSITION CODE
	;	 X,Y ARE 2'S COMPL


;********************************************************
;*** TYPE DIP DEF LIST - DIP DEFINITION FROM DIPS.DIP ***
;********************************************************
SBLOCK	DDEF
HWDS	(DDNPN,DDNXT)		;# PINS DEFINED		DIPDEF LIST
HWDS	(,DDMAX)		;			MAX SEC #
EBLOCK	DDEF
NIL,<DDMAX#,DDNXT#,DDNPN#,DDEF#>

SBLOCK	DIPDEF
HWDS	(DPNM,DPNXT)		;PIN NAME		NEXT
HWDS	(DPSEC,DPPIN)		;SECTION BITS		SECTION PIN #
EBLOCK	DIPDEF
NIL,<DPNM#,DPNXT#,DPSEC#,DPPIN#,DIPDEF#,>
>;MD

;TYPE DEFINITIONS (PC)

MPC,<
;********************************************************
;*** TYPE DEFINITION (PC) ***
;********************************************************

SBLOCK	TYPE
HWDS	(TNAM,TNXT)		;NAME (=# PINS USUALLY)	NEXT POINTER
HWDS	(TDPY,TPIN)		;APPROX BOX		TPIN LIST
EBLOCK	TYPE
NIL,<TNAM#,TNXT#,TDPY#,TPIN#,TYPE#>

;********************************************************
;***************    TPIN BLOCK (PC)    ******************
;********************************************************

SBLOCK	TYPIN
HWDS	(TPID,TPNX)		;PIN ID			NEXT PTR
HWDS	(TPX,TPY,E,E)		;PIN OFFSET
	 INDEX__INDEX-1
 FWD	 (TPXY)			;FOR FULL REFERENCE
EBLOCK	TYPIN
NIL,<TPID#,TPNX#,TPX#,TPY#,TPXY#,TYPIN#,>
>;MPC

;POINTS

;BPBIT and PBIT are assumed to be in LH in many places

;********************************************************
;***************     BODY POINT     *********************
;********************************************************

SBLOCK	BPOINT
HWDS	(BP1,BPNXT)		;*+2			NEXT
HWDS	(BPX,BPY,E,E)		;POINT LOC X,Y
	 INDEX__INDEX-1
 FWD	 (BPXY)
HWDS	(BBODY,BPLNK)		;BODY			PIN LINK
HWDS	(BPNEB,BP3)		;NEIGHBORS		*+1
HWDS	(BPTXT,BPLOC)		;POINT TEXT		PINLOC BLOCK IN TYPE
HWDS	(BPBIT,BPPN)		;BITS			PIN# OR PAD#
MD,<				;NEIGHBOR BLOCK ONLY FOR D
				;PC HAS LIST OF POSSIBLY MORE THAN 4 NEIGHBORS
HWDS	(BPND,BPNU)		;NEIGHBORS
HWDS	(BPNL,BPNR)
>;MD
EBLOCK	BPOINT
NIL,<BP1#,BPNXT#,BPX#,BPY#,BPXY#,BBODY#,BPLNK#,BPNEB#,BP3#,BPTXT#,BPLOC#,BPBIT#,
BPPN#,BPNL#,BPNR#,BPNU#,BPND#,BPOINT#,>

	;IF PC, PAD# IS 1 OR 3
	;IF PC, BPNEB IS LIST OF FORM:
	; NEIGHBOR1,,	NEXT
	; NEIGHBOR3,,	NEIGHBOR2

;********************************************************
;*** POINT OR CPIN *** - MUST BE CONGRUENT WITH BPOINT
;********************************************************

SBLOCK	POINT
HWDS	(P1,PNXT)		;*+2			NEXT
HWDS	(PX,PY,E,E)			;POINT LOCN X,Y
	 INDEX__INDEX-1
 FWD	 (PXY)
HWDS	(PFEED,PID)		;0 OR FEEDTHRU		POINT ID
HWDS	(PNEB,P3)		;NIGHBORS		*+1
HWDS	(PTXT,PLOC)		;TEXT			LOCATION
HWDS	(PBIT,PIN)		;POINT BITS		PIN # OR PAD #
MD,<
HWDS	(PND,PNU)		;NEIGHBORS L,R
HWDS	(PNL,PNR)		;NEIGHBORS UP,DOWN ?
>;MD
EBLOCK	POINT
NIL,<P1#,PNXT#,PX#,PY#,PXY#,PFEED#,PID#,PNEB#,P3#,PTXT#,PLOC#,PBIT#,PIN#,
PNL#,PNR#,PNU#,PND#,POINT#,>

;PLOC IS 0 UNLESS CPIN ON IN PBIT
;FORMAT OF LOCN BLOCK IN D
;	B-R-S,,	CPIN-LOC/PIN# (18 PIN FORMAT)
;	CONSTANT OFFSET X,Y
;FORMAT OF LOCN BLOCK IN PC
;	0,,	SOCKET# ???
;	CONSTANT OFFSET X,Y



;TEXT STRINGS AND PROPERTY BLOCKS

;********************************************************
;*************** TYPE TEXT/PROPERTY BLOCK ***************
;********************************************************

SBLOCK	TEXT
HWDS	(TXBIT,TXNXT)		;BITS			NEXT
HWDS	(T.X,T.Y,E,E)		;TEXT LOC X		TEXT LOC Y
	 INDEX__INDEX-1
 FWD	 (TXXY)
	 INDEX__INDEX-1
 HWDS	 (,TXIND)		; --			INDIRECT POINTER
HWDS	(TXNAM,TXVAL)		;PROPERTY NAME (0 IF NONE)	PROPERTY VALUE
HWDS	(TXOX,TXOY,E,E)		;CONSTANT OFFSET X,Y
	 INDEX__INDEX-1
 FWD	 (TXOFF)
EBLOCK	TEXT
NIL,<TXBIT#,TXNXT#,T.X#,T.Y#,TXXY#,TXIND#,TXNAM#,TXVAL#,TXOX#,TXOY#,TXOFF#,TEXT#,>

	;If TXBIND is on in TXBIT, then is indirect. TXIND points to TEXT block in type. 
	;low bit of TXXY is used to mean auto-offset
	;1,, bit of TXXY is sometimes used for flag

	;"0" size text not displayed unless IDENTS is on.

COMMENT 
STANDARD TEXT FORMAT:

------------	!	    ----!------	!  CHAR	    ----!--- NEXT 5
		!		!		!  SIZE		!    CHARS
		!-------!-------!		!-------!-------!
		!CONSTANT OFFSET!		!		!
		!   X	    Y	!		!     5 CHARS	!
		!-------!-------!		!---------------!
OFFSET IS SCALED WITH TEXT SIZE, NOT DRAWING SCALE.


SBLOCK	TEXCOF
HWDS	(,TCSTR)		;...			BARE TEXT STRING
HWDS	(TCX,TCY,E,E)		;CONSTANT OFF. X	Y
	INDEX__INDEX-1
  FWD	  (TCXY)
EBLOCK	TEXCOF

SBLOCK	TEXSTR
HWDS	(TSSIZ,TSNXT)		;CHAR-SIZE		NEXT
FWD	(TSASC)			;         ASCII CHARS
EBLOCK	TEXSTR

;BODY INSTANCE

;**************************************************
;***************    BODY INSTANCE      ************
;**************************************************

SBLOCK	BODY
HWDS	(BOD1,BNXT)		;*+2			NEXT
HWDS	(BX,BY,E,E)		;BODY LOCN X,Y
	INDEX__INDEX-1
FWD	(BXY)			; FOR REFERENCE TOGETHER
HWDS	(BORI,BLNK)		;ORIENTATION		PIN LINK - THRU ALL PINS ON BODY
HWDS	(BOD2,BTYP)		;*+1			TYPE
MPC,<
HWDS	(BID,BLN)		;BODY ID		BYTE (6)L(12)N
HWDS	(BBIT,BNAM)		;BODY BITS		DIP TYPE NAME STRING
>;MPC
MD,<
HWDS	(BID,BLOC)		;BODY ID		*+2 (0 IF NO LOC SET)
HWDS	(BBIT,BTXT)		;BODY BITS		BODY TEXT/PROPERTY LIST (MUST BE RH)
HWDS	(BOD3,)			;*+2			UNUSED
HWDS	(BLX,BLY,E,E)		;BODY LOCN CONSTANT OFFSET X,Y
	  INDEX__INDEX-1
 FWD	 (BLXY)
HWDS	(BBRS,BSOC)		;LOC BAY-RACK-SLOT	SOCKET #
	  INDEX__INDEX-1
 FWD	 (BRSLOC)		;B-R-S,,BODY-LOC
HWDS	(BLOX,BLOY,E,E)		;BODY LOCN CHAR OFFSET X,Y
	  INDEX__INDEX-1
 FWD	 (BLO)
HWDS	(BPAK,BDEF)		;PACKAGE CODE		DIP DEF LIST (IF BODY HAS DIPTYPE)
>;MD
EBLOCK	BODY
NIL,<BOD1#,BNXT#,B.X#,B.Y#,BXY#,BORI#,BLNK#,BOD2#,BTYP#,BID#,BLN#,BBIT#,BNAM#,
BID#,BLOC#,BBIT#,BTXT#,BOD3#,BLX#,BLY#,BLXY#,BBRS#,BSOC#,BLOX#,BLOY#,BLO#,BPAK#,BDEF#,
BRSLOC#,>

;If TXBIND is set in TXBIT, then this is indirect pointer to text/prop block
;in type. TXIND is pointer.
;If a BODY has any props at all, then it contains also indirect pointers
;to all props that were in its type. All or none.

DEFINE	FETPAK (A,B)
<IFDIF<A><B><	FETCH(A,B,BPAK)
		JUMPN A,.+3
		 FETCH(A,B,BTYP)
		 FETCH(A,A,TPAK)
>
IFIDN <A><B><	PUSH P,A
		FETCH(A,A,BPAK)
		JUMPE A,[POP P,A
			FETCH(A,A,BTYP)
			FETCH(A,A,TPAK)
			JRST .+2]
		SUB P,[1,,1]
>
>

;Define index values of elements for debug

DBG,<
	..ELEM__0
DEFINE STRUC1 $ (BLOCK,NAME,WHERE)
<U.$NAME__..ELEM
..ELEM__..ELEM+1
>
	STRUCTURES
MAXELM__..ELEM
>;DBG
