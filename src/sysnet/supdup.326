;-*- Mode: MIDAS-*-

;Things to be done *******
; Rearrange storage for purity?

TITLE SUPER-DUPER IMAGE TELNET (TCP and NCP and CHAOS)
; IMPLEMENTING NEW SUPDUP PROTOCOL
; THIS IS A PRIVATE TELNET-TYPE PROTOCOL USEFUL FOR COMMUNICATION
; BETWEEN ITS SYSTEMS.

A=1
B=2
C=3
D=4
E=5
T=6
TT=7
H=10
I=11
J=12
M=13
N=14
Q=15
R=16
P=17

ICPSOC:	137		;ICP SOCKET FOR NEW SUPDUP
DEBUG:	0		;NON-ZERO INHIBITS TIMEOUTS, AND ATTY INTERRUPTS,
			;SO THAT THEY DON'T KEEP GETTING SENT EVERY TIME
			;YOU INTERACT WITH DDT.

ICPCH==0	;ICP PIN
NETICH==2	;INPUT PIN
NETOCH==3	;OUTPUT PIN

TTYOCH==10	;TTY OUTPUT CH 
TTYICH==11	;TTY INPUT CH
TYAOCH==12	;TTY OUTPUT CHANNEL, ASCII MODE
FILECH==13	;CHANNEL FOR OPENING DISK FILES
USROCH==14	;CHANNEL FOR OUTPUT TO INFERIOR USER
USRICH==15	;CHANNEL FOR INPUT FROM INFERIOR USER

NETI=<.IOT NETICH,>	;DEFINE I/O INSTRUCTIONS
NETO=<.IOT NETOCH,>
TYI=<.IOT TTYICH,>
TYO=<.IOT TTYOCH,>
TYAO=<.IOT TYAOCH,>

BUFSIZ==200	;SIZE OF BUFFER

CHAOSP:	0	;NON-ZERO IF CONNECTED THROUGH CHAOS NET
USENCP: 0	;NON-ZERO IF SHOULD USE NCP
USETCP: -1	;NON-ZERO IF SHOULD USE TCP

SUBTTL UTILITY PROCEDURES

IF1,[
DEFINE INFORM A,B
PRINTX\A B
\
TERMIN

DEFINE INSIRP INSAC,OPS
    IRPS OP,,OPS
	INSAC,OP
    TERMIN
TERMIN

DEFINE SYSCAL NAME,ARGS
	.CALL [SETZ ? SIXBIT /NAME/ ? ARGS ((SETZ))]
TERMIN

DEFINE SOUT CHNL,MSG
	MOVE T,[440700,,[ASCII /MSG/]]
	MOVEI TT,.LENGTH /MSG/
	.CALL [ SETZ
		SIXBIT /SIOT/
		MOVEI CHNL
		T
		SETZ TT]
	 .LOSE 1000
	TERMIN

DEFINE CKHPOS
	MOVE TT,TCMXH
	CAMGE TT,HPOS
	 MOVEM TT,HPOS
TERMIN

;;; System-Call Macro. (from CALRET)

.INSRT SYSENG;$CALL MACRO
];END MOBY IF1
ERROR:	0		;STANDARD ERROR CODE FOR NETWRK

	;DECREMENT AN 8 BIT BYTE POINTER

DEFINE DBP8 AC
	ADD AC,[080000,,0]
	TLNE AC,400000
	 SUB AC,[400000,,1]
TERMIN

;THE NEXT FEW ROUTINES ARE CALLED BY THE NETWRK PACKAGE

PUTCHR:	TYAO T
	POPJ P,

;HOME DOWN CURSOR ON DISPLAYS
HOMEDN:	MOVEI TT,[ASCIZ /ZL/]
	SKIPN PRINTP		;DO NOTHING ON PRINTING TERMINALS
	 PUSHJ P,OUTSTR
	POPJ P,

;PUT CURSOR BACK WHERE IT BELONGS (AFTER TYPING CRUD AT SCREEN BOTTOM).
UNHMDN:	CKHPOS
	SKIPE PRINTP
	 JRST UNHMD1
	MOVEI TT,[ASCIZ/ZL/]
	PUSHJ P,OUTSTR		;ERASE THE PROMPT
	TYO [%TDMV0]		;RESTORE CURSOR POSITION
	TYO VPOS
	TYO HPOS
	$CALL SCPOS,[#TTYOCH,VPOS,HPOS]
	 .LOSE %LSSYS
	POPJ P,

UNHMD1:	MOVEI TT,[ASCIZ /A/]
	PUSHJ P,OUTSTR		;On printing tty, first make sure we're on a clean line.
	$CALL SCPOS,[#TTYOCH,VPOS,#0]	;Then say it's at the VPOS we are supposed to be at.
	 .LOSE %LSSYS
	TYO [%TDMV0]		;Then move to the HPOS we are supposed to be at
	TYO VPOS
	TYO HPOS
	$CALL SCPOS,[#TTYOCH,VPOS,HPOS]	;and tell thesystem's cursor pos about that motion.
	 .LOSE %LSSYS
	POPJ P,
	
;TYPE OUT ASCIZ STRING POINTED TO BY TT, CLOBBER T.
OUTSTR:	HRLI TT,440700
OUTST1:	ILDB T,TT
	JUMPE T,CPOPJ
	TYAO T
	JRST OUTST1

;TYPE OUT SIXBIT FROM TT, CLOBBER T
OUTSIX:	MOVEI T,0
	LSHC T,6
	ADDI T,40
	TYAO T
	JUMPN TT,OUTSIX
	POPJ P,

SUBTTL VARIABLES

CNSBLK:			;CNSGET INFO FOR TO SEND TO SERVER
	-CNSBLL+1,,0	;AOBJN POINTER TO FOLLOWING WORDS
TCTYP:	0		;TCTYP SERVER SHOULD USE (NOT LOCAL TCTYP)
TTYOPT:	0		;TTYOPT SERVER SHOULD USE (NOT LOCAL)
TCMXV:	0		;TTY PAGE LENGTH.
TCMXH:	0		;TTY WIDTH.
TTYROL:	0		;TTYROL VARIABLE, TO SEND TO SERVER.
SMARTS:	0		;GRAPHICS SMARTS
ISPEED:	0		;INPUT SPEED
OSPEED:	0		;OUTPUT LINE SPEED
FUNAME:	0		;MY XUNAME HERE
CNSBLL==.-CNSBLK
TTYTYP:	0		;%TT/%TY INFO ON LOCAL TTY
TTYCOM: 0
TTYBLK:	BLOCK 3		;TTYGET INFO ON OUR LOCAL CONSOLE
BP:	0		;BYTE POINTER
FRNHST:	0		;NUMBER OF FORIGN HOST
NETNUM:	0		;NUMBER OF NETWORK WE ARE USING TO TALK TO IT.
PRINTP:	0		;-1 => WE ARE ON A PRINTING TTY.
GSTOPP:	0		;-1 => ^G ^S FEATURE ENABLED
BTOGGP:	0		;-1 => Case toggling feature enabled 
VPOS:	0		;VERTICAL POSITION
HPOS:	0		;HORIZONTAL POSITION
ESCCHR:	%TXCTL+"^	;SUPDUP ESCAPE CHARACTER
PIATYF:	0		;-1 => EXPECTING PIATY INT. AFTER RETURNING TO SUPERIOR.
INTCNT:	0		;IF POSITIVE, NUMBER OF EXCESS INTERRUPTS RECEIVED
			;IF NEGATIVE, NUMBER OF EXCESS %TDORS RECEIVED
BUFFER:	BLOCK BUFSIZ	;NETWORK INPUT BUFFER
JCLBUF:	BLOCK 10	;JCL OR JNAME BUFFER
JCLP:	440700,,JCLBUF	;BYTE POINTER TO JCLBUF
JNAME:	0		;JNAME, IF NO JCL GIVEN
SUPRES:	0		;IF -1, SUPPRESS TYPEOUT FROM NETWORK DUE TO INTERRUPT.
SUPRCG:	0		;-1 => SUPPRESS TYPEOUT FROM NET DUE TO ^G OR ^S TYPED IN.
KLUDGE:	0		;NUMBER OF CHARS KLUDGED BETWEEN BUFFERS.
IPNTR:	0		;-> NEXT CHAR AFTER KLUDGE CHAR (INPUT PNTR FROM NET)
ICNTR:	0		;COUNT OF BYTES TO INPUT FROM NET
NBYTES:	0		;NUMBER OF BYTES STILL TO BE HANDLED
OPNTR:	0		;OUTPUT POINTER  (FOR THE SIOT TO THE TTY)
OCNTR:	0		;OUTPUT COUNTER  (DITTO)
KPNTR:	0		;POINTER TO KLUDGEY CHARS WHICH MUST GET COPIED TO FRONT OF BUF
GOAWAY:	0		;-1 => GO AWAY AFTER PROCESSING BUFFERED INPUT

PDL:	-160,,.
	BLOCK 160

SUBTTL INITIALIZATION, ICP, ETC.

SUPDUP:	MOVE P,PDL
	$CALL OPEN,[#TYAOCH,[SIXBIT /TTY/]],[#%TJDIS+%TJMOR+.UAO]
	 .LOSE %LSFIL

	$CALL OPEN,[#TTYICH,[SIXBIT /TTY/]],[#%TIFUL+%TIINT+%TINWT+.UII]
	 .LOSE %LSFIL

	pushj p,lsrchk		;see if they're a loser
	 pushj p,lsrwrn		;yep; warn them off
	tyao [^P] ? tyao ["A]	;get a fresh line.

	$CALL CNSGET,[#TYAOCH][TCMXV,TCMXH,TCTYP,TTYCOM,TTYOPT,TTYTYP]
	 .LOSE %LSSYS

;If this was invoked by the SAIL command, but SAIL is going to refuse
;to let us in because we don't satisfy its idea of a display, use TELNET
;instead.
	.SUSET [.RXJNAME,,A]
	CAME A,[SIXBIT/SAIL/]
	 JRST SUPDOK
	MOVE A,TTYOPT
	TLC A,%TOERS+%TOMVU+%TOMVB+%TOLID+%TOCID+%TOFCI
	TLNE A,%TOERS+%TOMVU+%TOMVB+%TOLID+%TOCID+%TOFCI
	 JRST USETLN
	MOVE A,TCMXH
	CAIL A,80.-1
	 JRST SUPDOK
USETLN:	$CALL OPEN,[[.UII,,FILECH],[SIXBIT/DSK/],[SIXBIT/TELNET/],[SIXBIT/BIN/],[SIXBIT/SYSBIN/]]
	 .LOSE %LSFIL
	MOVSI 17,LODTLN
	BLT 17,10
	JRST 0

LODTLN:	OFFSET -.
	.CALL 5			;0
	 .LOSE %LSSYS		;1
	.IOT FILECH,1		;2
	.CLOSE FILECH,		;3
	JRST (1)		;4
	SETZ			;5
	SIXBIT/LOAD/		;6
	MOVEI %JSELF		;7
	SETZI FILECH		;10
	OFFSET 0

SUPDOK:	.SUSET [.ROPTION,,TT]
	TLNN TT,OPTCMD
	 JRST SUPDU2
	.BREAK 12,[..RJCL,,JCLBUF]	;ELSE USE THE JCL
	MOVE A,[440700,,JCLBUF]
	MOVE B,A
SUPDU3:	ILDB T,A		;REMOVE ALL SPACES FROM THE JCL.  ALSO REMOVE ANY CTL CHARS
	CAILE T,40		;(WE EXPECT TO HAVE A ^M, ^C or ^_ AT THE END)
	 IDPB T,B
	JUMPN T,SUPDU3
	IDPB T,B		;MAKE THE JCL ASCIZ AGAIN.
	CAME T,[350700,,JCLBUF]	;IF WE GOT RID OF THE WHOLE THING (WAS JUST SPACES)
	 JRST SUPDU1
SUPDU2:	.SUSET [.RXJNAME,,TT]	;OR IF THERE IS NO JCL, USE XJNAME INSTEAD.
	MOVE B,[440700,,JCLBUF]
	SETZM JCLBUF
	SETZM JCLBUF+1
SUPDU0:	SETZ T,			;CONVERT XJNAME TO ASCIZ IN JCLBUF.
	LSHC T,6
	ADDI T,40
	IDPB T,B
	JUMPN TT,SUPDU0
SUPDU1:	MOVEI A,HSTPAG
	MOVEI B,FILECH
	PUSHJ P,NETWRK"HSTMAP	;LOAD IN THE HOSTS3 DATA BASE.
	 .VALUE
	MOVEI A,JCLBUF
	PUSHJ P,NETWRK"HSTLOOK	;GET HOST NUMBER INTO A, NETWORK NUMBER INTO TT
	 JRST [	MOVEI TT,[ASCIZ /Unrecognized host name./]
		PUSHJ P,OUTSTR
		JRST DIEDIE]	;LOST
	MOVEM A,FRNHST		;STASH HOST NUMBER
	MOVEM TT,NETNUM		;STASH NET NUMBER.
	.SUSET [.RUNAME,,D]
	HLLO D,D
	AOJE D,[SOUT TYAOCH,[Login please]
		.LOGOUT 1,]
SUPDU9:	.SUSET [.SDF1,,[%PIRLT+%PIATY]]	;DON'T TAKE THESE INTS UNTIL CONNECTION OPEN
	.SUSET [.SDF2,,[-1]]
	.SUSET [.SMASK,,[%PIRLT+%PIATY+%PIPDL+%PIIOC]]	;PDLOV IS NOT HANDLED, JUST PASSED UP
	.SUSET [.SMSK2,,[-1,,1_TTYICH+1_NETICH]]
	.SUSET [.ROPTION,,TT]	;TURN ON NEW-STYLE INTERRUPT HANDLER
	TLO TT,OPTINT
	.SUSET [.SOPTION,,TT]
	MOVE TT,NETNUM
	;;;CAMN TT,[NETWRK"NW%ARP]
	CAME TT,[NETWRK"NW%CHS]
	 JRST USEARP
USECHS:	SETOM CHAOSP
	MOVEI A,NETICH
	MOVE B,FRNHST
	MOVEI C,[ASCIZ/SUPDUP/]
	MOVEI D,5
	PUSHJ P,NETWRK"CHACON	;OPEN CONNECTION
	 JRST NETLUZ
	JRST SUPDU4
USEARP:	SKIPE USENCP
	 JRST [	MOVEI A,ICPCH		;FIRST OF 4 PINS (CHANNELS) TO ICP WITH
		MOVE B,FRNHST		;HOST TO ICP TO
		MOVE C,ICPSOC		;CONTACT SOCKET
		MOVE D,[40+.UAI,,40+.UAO] ;MODES (8 BIT)
		PUSHJ P,NETWRK"ARPICP	;Perform ICP.
		 JRST NETLUZ
		JRST SUPDU4 ]
	SKIPE USETCP
	 JRST [	MOVEI A,NETICH		;Net input channel
		MOVE B,FRNHST		;Host to ICP to
		MOVE C,ICPSOC		;Contact port
		PUSHJ P,NETWRK"TCPCON	;Open TCP channel.
		 JRST NETLUZ
		JRST SUPDU4 ]
	  .VALUE [ASCIZ /:Neither TCP or NCP specified for ARPANET./]
SUPDU4:	MOVE A,FRNHST
	PUSHJ P,NETWRK"HSTSIX	;Get short name of host
	 .VALUE
	MOVEM A,HSTSIX'		;Save for command prompt
	PUSHJ P,NETWRK"HSTUNM	;We don't need HOSTS3 any more
	 .LOSE %LSSYS		; Eh?
	PUSHJ P,WHOLIN		;PUT NAME OF HOST, NETWORK ON WHOLINE
	JRST SUPINI		;WON

WHOLIN:	.SUSET [.SWHO2,,HSTSIX]	;PUT SIXBIT HOSTNAME IN FIRST PART OF WHOLINE.
	SKIPE CHAOSP
	 JRST WHOCHA		;CHAOS NET
	SKIPE USENCP
	  .SUSET [.SWHO3,,[SIXBIT /(ARPA)/]]	;ARPANET
	SKIPE USETCP
	  .SUSET [.SWHO3,,[SIXBIT /(TCP)/]]	;TCP
	.SUSET [.SWHO1,,[354001,,660000]]	;WHOLINE CONTROL, 2 SIXBIT WORDS.
	POPJ P,

WHOCHA:	.SUSET [.SWHO3,,[SIXBIT /(CHOS)/]]	;CHAOS NET.  "A" IS IN .WHO1.
	.SUSET [.SWHO1,,[354001,,662020]]	;WHOLINE CONTROL, 2 SIXBIT WORDS PLUS "A".
	POPJ P,


;SUPDUP INITIAL NEGOTIATION. SEND SOME 36-BIT WORDS ENCODED AS
;6 6-BIT BYTES FROM THE LEFT.  FIRST WORD IS TCTYP, SECOND IS TTYOPT,
;THIRD IS TCMXV, FOURTH IS TCMXH, FIFTH IS TTYROL.  PREFIX WITH AOBJN POINTER.
;%TPCBS MUST BE ON.
;WE WILL DO ALL OUTPUT-RESET HACKING AND META-CONTROL-BITS
;USING THE INTELLIGENT TERMINAL PROTOCOL.

SUPINI:	MOVE D,TCTYP
	MOVE E,TTYOPT
	MOVE TT,[-10,,[ 'TTYROL ? MOVEM TTYROL ? 'TTYSMT ? MOVEM SMARTS
			'ISPEED ? MOVEM ISPEED ? 'OSPEED ? MOVEM OSPEED ]]
	$CALL TTYVAR,[#TYAOCH,TT]
	 .LOSE %LSSYS
	TLNE E,%TOFCI		;ARE WE ON A TERMINAL WITH FULL KEYBOARD?
	 JRST [	MOVEI TT,%TXTOP+"B	;YES, USE THE BREAK KEY AS COMMAND ESCAPE
		MOVEM TT,ESCCHR
		JRST .+1]
	TLNN E,%TOMVU		;IS THIS A PRINTING TTY?
	 SETOM PRINTP		;   YES, SET FLAG
	MOVEI TT,%TPCBS+%TPORS	;ENABLE INTELLIGENT TERM. PROTOCOL
	IORM TT,TTYOPT		;ALSO ENABLE OUTPUT RESET HANDLING
	MOVEI TT,%TPTEL
	ANDCAM TT,TTYOPT	;SUPDUP SERVER SHOULD NOT CONVERT CRLF TO CR ON INPUT.
	MOVEI TT,%TNSFW		;MAKE IT A SOFTWARE TTY
	MOVEM TT,TCTYP
	.SUSET [.RXUNA,,FUNAME]	;MY XUNAME
	MOVE TT,[440600,,CNSBLK]	;SET UP BYTE POINTER
	MOVEM TT,BP
	MOVEI T,6*CNSBLL	;SIX BYTES EACH WORD
SUPIN1:	ILDB TT,BP		;AND CHUG OUT THE BYTES
	NETO TT
	SOJG T,SUPIN1
	.NETS NETOCH,				
SUPIN2:	NETI TT			;SERVER SENDS ASCII TO THE USER TO
	JUMPL TT,DIEDIE
	CAIE TT,%TDNOP
	 JRST [	TYAO TT		;  BE OUTPUT IN ASCII MODE, ENDING
		JRST SUPIN2 ]	;  WITH A %TDNOP

;SERVER WILL NOW LOG IN AS <N>TLNT, AND SEND A ^Z DOWN THE STY.
;NOW WE GO INTO SUPER-DUPER-IMAGE MODE.
; NOTE: THE %TIINT IS A CROCK TO FIX AN ITS BUG.

	$CALL OPEN,[#TTYOCH,[SIXBIT /TTY/]],[#%TJSIO+%TJMOR+.UIO]	;SUPER-IMAGE
	 .LOSE %LSFIL
	$CALL TTYGET,[#TTYOCH][TTYBLK,TTYBLK+1,TTYBLK+2]
	 .LOSE %LSSYS
	HRLI TT,%TSSII		;SUPER-IMAGE INPUT
	IORM TT,TTYBLK+2
	$CALL TTYSET,[#TTYOCH,TTYBLK,TTYBLK+1,TTYBLK+2]
	 .LOSE %LSSYS

;HERE WE TELL TELSER OUR TERMINAL ID
;FIRST WE GOTTA FIGURE OUT WHAT IT IS
;WHICH IS DONE VIA A SPECIAL ENTRY TO THE NAME PROGRAM

	$CALL OPEN,[[.UII,,FILECH],[SIXBIT/SYS/],[SIXBIT/TS/],[SIXBIT/NAME/]]
	 .LOSE %LSFIL
	.SUSET [.RJNAME,,A]
	HRRI A,'NAM
	$CALL OPEN,[[.UIO,,USROCH],[SIXBIT/USR/],#0,A]
	 .LOSE %LSFIL
	$CALL OPEN,[[.UII,,USRICH],[SIXBIT/USR/],#0,A]
	 .LOSE %LSFIL
	$CALL LOAD,[#USROCH,#FILECH]
	 .LOSE %LSSYS
	.IOT FILECH,A
	HRRZS A			;START ADDRESS
	.USET USROCH,[.SUPC,,A]
	.USET USROCH,[.SXJNAME,,['SUPNAM]]
	.USET USROCH,[.SUSTP,,[0]]	;IT WILL INTERRUPT BACK WHEN IT'S READY
	.CLOSE FILECH,
	JRST SUPGO

;HERE WHEN USR INTERRUPTS
;SHOULD DO A .BREAK 16,105 WITH 'TERMID IN 0 AND BYTE POINTER TO ASCIZ IN 1

INFINT:	INSIRP PUSH P,A B T TT
	.USET USROCH,[.RSV40,,A]
	CAME A,[.BREAK 16,105]
	 JRST INFLUZ
	.ACCESS USRICH,[0]
	.IOT USRICH,A
	CAME A,['TERMID]
	 JRST INFLUZ
	.IOT USRICH,B
	HRRZ A,B
	.ACCESS USRICH,A
	HRRI B,T
	NETO [300]
	NETO [302]
	TDZA TT,TT		;SO ILDB GETS ZERO
INFIN1:	 MOVE B,[440700,,T]
	.IOT USRICH,T
INFIN2:	ILDB A,B
	JUMPE A,INFIN3
	NETO A
	JRST INFIN2

INFIN3:	CAMN B,[350700,,TT]
	 JRST INFIN1
	NETO A
	.NETS NETOCH,
	SKIPA
INFLUZ:	 JFCL
	.UCLOSE USROCH,		;FLUSH HIM
	INSIRP POP P,TT T B A
	$CALL DISMIS,[P]
	 .LOSE %LSSYS	

;NOW ENABLE INTERRUPTS, AND GO TO MAIN ROUTINE.

SUPGO:	MOVE TT,[440800,,BUFFER]	;IF WE HAVE TO KLUDGE, THESE WILL BE RESET.
	MOVEM TT,IPNTR
	SETZM KLUDGE
	.SUSET [.SDF1,,[0]]
	.SUSET [.SDF2,,[0]]
	.SUSET [.SIIFPIR,,[1_TTYICH]]	;SHOULDN'T BE NECESSARY BUT MAY FIX A BUG
	JFCL
	.HANG	;ANYONE HAVE ANY IDEAS WHAT TO DO AT MAIN PROGRAM LEVEL?

;INTERRUPT TABLE

INTTAB:	LOC 42
	-LINTTB,,INTTAB
	LOC INTTAB

	P

	%PIIOC ? 0		;IOC ERROR
	-1 ? -1
	IOC

	%PIATY ? 0		;TTY GIVEN BACK
	%PIATY ? -1
	PIATY

	0 ? 1_TTYICH		;USER TYPE IN
	%PIATY ? -1
	TTYINT

	%PIRLT ? 0		;REAL TIME CLOCK
	%PIATY+%PIRLT ? -1
	RLTINT

	0 ? 1_NETICH		;NET TYPEOUT
	0 ? -1,,1_NETICH
	NETINT

	0 ? -1,,		;INFERIOR
	%PIATY ? -1
	INFINT
LINTTB==.-INTTAB	;NOTE NETINT TEMPORARY DEFERS TTYINT DURING THE SIOT, SINCE TTYINT
			;COULD SIOT ALSO.  THIS IS DONE MANUALLY VIA .SUSET

SUBTTL	TTY INPUT INTERRUPT HANDLER

TTYINT:	INSIRP PUSH P,A B C D E T TT
NXTCHR:	TYI A
	JUMPL A,TTYINX		;NO MORE CHARS, LEAVE THE INTERRUPT
	SETZM SUPRCG		;TYPING A CHAR UNDOES OUTPUT SUPPRESSION CAUSED BY ^G, ^S.
	PUSHJ P,NORMLZ		;"NORMALIZE" CHAR AS A COMMAND.
	CAME B,ESCCHR
	 JRST SENDCH
	CKHPOS
	$CALL SCPOS,[#TTYICH,VPOS,HPOS]	;MAKE SURE CURSOR IS IN RIGHT PLACE
	 .LOSE %LSSYS
	PUSHJ P,HOMEDN
	PUSHJ P,CMDENT		;ENTER COMMAND MODE
TRYAGN:	$CALL IOT,[#TTYICH,A],[#%TINWT]	;DO WAIT.
	 .LOSE %LSSYS		;PC POINTS AT TRYAGN WHILE AWAITING INPUT, SEE RLTINT
	MOVSI B,(SETZ)
	.REALT B,
	PUSHJ P,NORMLZ
	CAMN B,ESCCHR		;QUOTED ESCAPE CHAR?
	 JRST [	PUSHJ P,UNHMDN	;PUT CURSOR BACK AT RIGHT PLACE
		JRST SENDCH]	;AND SEND THE ESCAPE THROUGH.
	CAIN B,%TXTOP+"H
	 MOVEI B,"?		;MAKE TOP-H WORK DESPITE THE NEXT FEW INSNS.
	TRNE A,%TXCTL
	 ANDI A,37
	ANDI A,177
	CAIL A,"a
	CAILE A,"z
	 CAIA
	  SUBI A,<"a>-<"A>
	MOVE T,[-COMLEN,,COMTAB]
CMDSRC:	HLRZ TT,(T)
	HRRZ B,(T)
	CAIE A,(TT)
	 AOBJN T,CMDSRC
	JUMPGE T,CMDNF
	PUSHJ P,(B)		;EXECUTE COMMAND ROUTINE.  MAY SKIP.
	 CAIA
	  JRST TTYINX		;IF SKIPS, DON'T UNHMDN AND DON'T USE TTY UNTIL FORCED TO.
CMDNF1: PUSHJ P,UNHMDN
	JRST NXTCHR

CMDNF:	TYO [%TDBEL]		;UNKNOWN COMMAND, GIVE HIM A BELL AND ESCAPE TO REGULAR LOOP.
	JRST CMDNF1

;ENTER COMMAND MODE.  PROMPT, START REAL TIME CLOCK FOR TIME-OUT.
CMDENT:	MOVEI TT,[ASCIZ\CMND (\]
	PUSHJ P,OUTSTR
	$CALL SSTATU,,[TT,TT,TT,TT,TT,TT]	;GET SYSTEM NAME
	 .LOSE %LSSYS
	PUSHJ P,OUTSIX
	MOVEI TT,[ASCIZ/ to /]
	PUSHJ P,OUTSTR
	MOVE TT,HSTSIX
	PUSHJ P,OUTSIX
	MOVEI TT,[ASCIZ\) -->\]
	PUSHJ P,OUTSTR
	.LISTEN TT,
	MOVE TT,[600000,,[60.*10.]]	;10 SECONDS BEFORE GIVING UP.
	.REALT TT,
	POPJ P,

;HERE IF USER DOESN'T TYPE ANYTHING FOR 10 SECONDS WHILE IN COMMAND MODE.
;GIVE UP BY FORCING INPUT OF A RUBOUT.  THUS, IF USER LOOKS AWAY FROM HIS
;SCREEN AND FORGETS THAT HE IS IN COMMAND MODE, HE DOESN'T GET SCREWED.
RLTINT:	PUSH P,TT
	HRRZ TT,-1(P)		;CHECK OUT PC INTERRUPTED OUT OF
	CAIE TT,TRYAGN		;TO SEE IF READING TTY INPUT
	 JRST RLTIN1
	MOVEI TT,2		;YES, FAKE INPUT OF A RUBOUT
	ADDM TT,-1(P)
	MOVEI A,177
RLTINX:	POP P,TT
	$CALL DISMIS,[P]
	 .LOSE %LSSYS

RLTIN1:	MOVE TT,[600000,,[60.]]	;WRONG PC, TRY AGAIN EVERY SECOND
	.REALT TT,
	JRST RLTINX

;HERE FOR A NON-CONTROL CHARACTER.

SENDCH:	MOVE B,A
	LSH B,-7
	JUMPE B,SENDC2
	IORI B,100		;SEND BUCKY BITS VIA SPECIAL ESCAPE
	NETO [^\]
	NETO B
	MOVE B,A
	ANDI B,177
	NETO B
	JRST SENDC3

SENDC2:	NETO A
	CAIN A,^\		;MUST SEND TWO BECAUSE OF INT. TRM. PROTOCOL
	 NETO A
SENDC3:	SKIPN GSTOPP
	 JRST NXTCHR
	TRZ A,40
	CAIE A,^S
	CAIN A,^G
	 JRST CTLGS
	CAIE A,%TXCTL+"S
	CAIN A,%TXCTL+"G
	 JRST CTLGS
	  JRST NXTCHR

;HERE IF ^G OR ^S TYPED WHILE SPECIAL FEATURE IS ENABLED.
;  PROGRAM SHOULD STOP ALL TYPEOUT TO THE USER UNTIL HE
;  TYPES IN HIS NEXT CHARACTER.

CTLGS:	SETOM SUPRCG
	JRST NXTCHR

;HERE TO DISMISS TTY INTERRUPT

TTYINX:	.NETS NETOCH,		;PROBABLY NET OUTPUT WAS GENERATED, FIRE IT OFF
	INSIRP POP P,TT T E D C B A
	$CALL DISMIS,[P]
	 .LOSE %LSSYS

SUBTTL COMMAND HANDLING ROUTINES

;COMMAND DISPATCH TABLE

COMTAB:	<%TXCTL+"Z>,,CNTLZ
	^Z,,CNTLZ
	<%TXCTL+"_>,,CNTLBK
	^_,,CNTLBK
	"C,,NEWESC
	"D,,CNTLZ
	"P,,PROCED
	"G,,GSTOP
	"A,,BTOGG
	"Q,,QCMND
	"L,,LOGOUT
	"?,,HELP
	177,,CPOPJ	;RUBOUT JUST FLUSHES
COMLEN==.-COMTAB

; Given typed in character in A, return character to be transmitted in A
; and character for looking up in command table in B.
NORMLZ:	ANDI A,%TXCTL\%TXMTA\%TXSUP\%TXTOP\%TXASC
	MOVEI B,(A)
	TRZE B,%TXCTL\%TXMTA\%TXSUP
	 SKIPN BTOGGP
	  JRST NRMLZ1
	TRC A,40		; Guess that you will be toggling case
	CAIL B,"A
	 CAILE B,"Z
	  JRST NRMLZ2
	MOVEI B,-40(A)		; Was upper case, A has lower, B gets upper
	POPJ P,

NRMLZ2:	CAIL B,"a
	 CAILE B,"z
	  TRC A,40		; Was non-letter, undo guess
	MOVEI B,(A)		; Was lower case, A and B the same
	POPJ P,

NRMLZ1:	CAIL B,"a
	 CAILE B,"z		;IF CHARACTER IS LOWER CASE,
	  SKIPA B,A
	   MOVEI B,-40(A)	;WE WANT TO SUBTRACT 40 FROM IT.
	CAIGE B,40
	 IORI B,%TXCTL+100	;TRANSFORM ASCII CONTROLS INTO 9-BIT CONTROLS.
	POPJ P,

;SIMULATE THE USER'S HAVING TYPED A "CALL"
CNTLZ:	SETOM PIATYF
	.SUSET [.SAIFPIR,,[1_TTYICH]]	;CLEAR THE INTERRUPT CAUSED BY THE ^Z OR D
	.SUSET [.SIPIRQC,,[%PIC.Z]]	;SO WE WON'T COME TO NXTCHR AND NEED THE TTY.
	JRST POPJ1		;DON'T UNHMDN NOW, BUT WHEN WE GET THE TTY BACK.

;SIMULATE THE USER'S HAVING TYPED A "BACK-NEXT" OR ^_.
CNTLBK:	PUSHJ P,UNHMDN		;IT'S A SHAME TO ECHO THIS AT THE CURSOR,
	MOVEI TT,[ASCIZ /^_/]	;BUT IF WE DON'T, OUTPUT FROM OTHER HOST
	PUSHJ P,OUTSTR		;WILL COME OUT AT THE WRONG PLACE.
	$CALL TTYESC,[#TTYICH]
	 JFCL
	JRST POPJ1

;<BREAK>P - DO A :PROCED
PROCED:	SETOM PIATYF
	.SUSET [.SAIFPIR,,[1_TTYICH]]
	.VALUE [ASCIZ/:PROCEED 1J/]
	JRST POPJ1

LOGOUT:	PUSHJ P,UNSUPR
	NETO [300]		;SEND THE TELSER A SIGNAL NOT TO DETACH THE TREE.
	NETO [301]
QCMND:	PUSHJ P,UNSUPR
	$CALL FINISH,[#NETOCH]	;FIRE IT OFF, AWAIT ARRIVAL AT OTHER END
	 JFCL			;WE TRIED
	.LOGOUT 1,		;NORMAL TERMINATION

DIEDIE:	.LOGOUT
	.BREAK 16,040000	;ABNORMAL TERMINATION.  DISCARD TTY INPUT.
				;WILL SEND A CLS (TRY TO IF CHAOS NET)
	JRST DIEDIEDIE		;KEEP STABBING UNTIL THE BLOOD FLOWS

;Get rid of super-image mode so can quit out
UNSUPR:	$CALL TTYGET,[#TTYOCH][TTYBLK,TTYBLK+1,TTYBLK+2]
	 .LOSE %LSSYS
	HRLI TT,%TSSII		;SUPER-IMAGE INPUT
	ANDCAM TT,TTYBLK+2
	$CALL TTYSET,[#TTYOCH,TTYBLK,TTYBLK+1,TTYBLK+2]
	 .LOSE %LSSYS
	POPJ P,

;CHANGE THE SUPDUP ESCAPE CHARACTER

NEWESC:	PUSHJ P,HOMEDN
	MOVEI TT,[ASCIZ /Change escape character to -->/]
	PUSHJ P,OUTSTR
	$CALL IOT,[#TTYICH,A],[#%TINWT]	;DO WAIT
	 .LOSE %LSSYS
	PUSHJ P,NORMLZ
	MOVEM B,ESCCHR
	POPJ P,

;ENABLE FEATURE WHICH MAKES ^G OR ^S STOP TTY OUTPUT
;   UNTIL USER TYPES NEXT CHARACTER

GSTOP:	SETCMM GSTOPP	;TOGGLE FLAG
	POPJ P,

;Enable feature where characters typed while holding down
; Control/Meta/Super have their case toggled.
BTOGG:	SETCMM BTOGGP		; Toggle case toggling flag
	POPJ P,

;HELP FEATURE.

HELPMS:	ASCIZ 
SUPDUP help message:

These commands are accepted after typing the SUPDUP escape character,
which is initially Break on TV's and Control-^ otherwise:

^Z - do a local control-Z - return to DDT.
^_ - do a local control-_ - begin terminal escape command.
D  - same as ^Z.
P  - return to DDT, :PROCEED the SUPDUP (run it without the TTY).
G  - toggle mode in which ^G and ^S are transmitted but also
	cause typeout to stop until the next character typed.
A  - toggle mode in which characters typed with Control/Meta/Super
	have their case toggled.
Q  - closes the connection and kills the SUPDUP.  Log out first!
	Otherwise you will leave a detached tree at the other end.
L  - closes the connection, directing the other end to log out
	instead of detaching.
?  - types this help message.
C  - changes the SUPDUP escape character.  Follow by new escape char.
<SUPDUP Escape Character>  - sends the character through.


HELP:	MOVEI TT,HELPMS
	PUSHJ P,OUTSTR
	SKIPE PRINTP
	 POPJ P,
	$CALL IOT,[#TTYICH,A],[#%TINWT#%TIPEK]	;Wait for character, and don't gobble it.
	 .LOSE %LSSYS
	MOVEI TT,[ASCIZ /C/]	;He no longer needs message, so clear it out.
	JRST OUTSTR

SUBTTL NETWORK INPUT INTERRUPT HANDLER

NETINT:	INSIRP PUSH P,A B C D E T TT
	$CALL WHYINT,[#NETICH][TT,A,B]	;A SOCKET STATE, B NUMBER OF BYTES OF INPUT
	 .LOSE %LSSYS		; ON ARPANET, RECEIVE,,TRANSMIT PACKET COUNT ON CHAOS NET
				; NOTHING ON INTERNET AT THIS TIME
	SKIPE CHAOSP
	 JRST [	CAIE TT,%WYCHA
		 .LOSE
		HLRZS B		;GET INPUT PACKET COUNT
		CAIE A,%CSCLS
		 CAIN A,%CSLOS
		  JRST [ SOJLE B,NETLZI	;ONLY INPUT IS A LOS OR A CLS
			 SETOM GOAWAY
			 JRST INPUT ]	;OTHER INPUT EXISTS, TYPE IT OUT FIRST
		CAIE A,%CSOPN
		 JRST NETLZI	;CONNECTION NOT OPEN, GO ANALYZE
		JUMPG B,INPUT	;PROCESS INPUT, IF ANY
		JRST NETINX ]	;NO INPUT, RETURN
	SKIPE USETCP
	 CAIN TT,%WYTCP
	  SKIPA
	   .LOSE
	SKIPE USENCP
	 CAIN TT,%WYNET
	  SKIPA
	   .LOSE
	JUMPGE A,NETIN1		;SIGN OF A IS NETWORK-INTERRUPT FLAG
	TLZ A,400000		;CLEAR FLAG IN SUPDUP
	.RESET NETICH,		;AND IN SYSTEM
	AOSLE INTCNT
	 JRST [	.RESET TTYOCH,	;IF %TDORS HASN'T ARRIVED YET, DO OUTPUT RESET
		SETOM SUPRES	;AND AWAIT THE OUTPUT RESET
		JRST .+1 ]
NETIN1:	CAIE A,%NSRCL
	 CAIN A,%NSCLS
	  JRST NETLZI		;LOST, TELL LOSER
	CAIN A,%NSOPN		;NO INPUT?
	 JRST NETINX		;DAMNED TIMING ERRORS...
	CAIE A,%NSCLI		;CLS RECEIVED, DATA AVAILABLE FOR INPUT
	CAIN A,%NSINP		;INPUT AVAILABLE
	 JRST INPUT
	  .VALUE [ASCIZ /YCRASH;SUPDUP >
:NETIN1 - Unknown error.  Crash dump taken.
Please do a :BUG SUPDUP.KILL
/]

NETLZI:	MOVEI A,NETICH
	JRST NETLUZ

;HERE WHEN INPUT IS ACTUALLY AVAILABLE.  COUNT OF BYTES IN B.
;IPNTR POINTS AT THE PLACE IN THE BUFFER TO START READING INPUT INTO.
;IT MAY NOT BE THE BEGINNING OF THE BUFFER, IF THERE ARE "KLUDGE" CHARACTERS
;LEFT OVER FROM THE LAST BUFFERFUL, WHICH COULD NOT BE PROCESSED THEN.
;IN THAT CASE, THE KLUDGE CHARACTERS ARE AT THE BEGINNING OF THE BUFFER,
;IPNTR POINTS AFTER THEM, AND KLUDGE CONTAINS THE NUMBER OF THEM.

INPUT:	SKIPE CHAOSP
	 SKIPA B,[BUFSIZ*4+1]	;ASSUME MAXIMUM AMOUNT AVAILABLE, THEN USE DON'T-HANG
	  JRST [		;EITHER NCP OR TCP
	    SKIPE USETCP
	      JRST .-1		;TCP, ACT LIKE CHAOS
	    JUMPLE B,NETINX	;NO INPUT, RETURN
	    JRST .+1]
	MOVEM B,ICNTR		;INITIALLY, TRY TO PROCESS IT ALL
	MOVEI T,BUFSIZ*4	;NUMBER OF BYTES THE BUFFER CAN HOLD
	SUB T,KLUDGE		;ALLOW ROOM FOR KLUDGE BYTES AT THE BEGINNING
	CAMGE T,ICNTR		;CAN WE DO IT ALL AT ONCE?
	 JRST [	SUB B,T		;NO, B GETS NUMBER LEFT OVER
		MOVEM T,ICNTR	;ICNTR GETS NUMBER TO DO THIS TIME AROUND
		JRST .+2 ]
	  MOVEI B,0		;CAN DO IT ALL AT ONCE, NONE LEFT OVER
	MOVEM B,NBYTES		;SAVE NUMBER STILL TO DO
	MOVE E,ICNTR
	$CALL SIOT,[#NETICH,IPNTR,ICNTR][][#10]	;FINALLY, GET SUITABLE CHARACTERS
	 .LOSE %LSFIL
	SUB E,ICNTR		;MAY NOT HAVE TRANSFERRED FULL LENGTH
	JUMPE E,NETINX		;NOTHING TO DO, DISMISS
	ADD E,KLUDGE		;CHECK ALL CHARS INCLUDING THE KLUDGES.
	MOVEM E,OCNTR		;NUMBER OF CHARS TO PROCESS
	MOVE D,[440800,,BUFFER]	;WE ALWAYS FOLLOW THE CURSOR POSITION
				;  FROM THE BEGINNING
	MOVEM D,OPNTR		;WE ALWAYS OUTPUT FROM THE BEGINNING

	MOVE TT,[440800,,BUFFER]	;IF WE HAVE TO KLUDGE, THESE WILL BE RESET.
	MOVEM TT,IPNTR
	SETZM KLUDGE			;IF WE DON'T, THESE ARE WHAT THEY SHOULD BE.

; NOW WE MUST GO OVER EVERY CHAR, AND RECORD ITS EFFECT ON THE 
;   CURSOR POSITION, SINCE WE ARE IN SUPER-IMAGE-OUTPUT

FOO0:	SKIPN SUPRES		;IN MIDDLE OF OUTPUT RESET, DON'T HACK TYPEOUT
	 SKIPE SUPRCG		;SAME AFTER USER TYPES ^G OR ^S.
	  CAIA
	   JRST FOO4
	ILDB TT,D		;BUT DO CHECK FOR %TDORS'S
	CAIN TT,%TDORS
	 PUSHJ P,XTDORS
	SOJG E,FOO0
	JRST IN1

FOO4:	ILDB TT,D		;IGNORE ANY LEADING %TDNOP'S IN THE MESSAGE.
	CAIN TT,%TDNOP
	 SOJG E,[ MOVEM D,OPNTR
		  JRST FOO4]
	JUMPE E,IN1		;IF THERE WAS NOTHING BUT %TDNOP'S, DON'T USE TTY AT ALL.
	CAIA			;IF WE FOUND A NON-%TDNOP, SCAN IT
FOO1:	 ILDB TT,D		; AND THE REMAINING CHARACTERS FOR CURSOR MOTION.
	CAIL TT,200
	 JRST [	CAIGE TT,TDLEN+200	;SPECIAL CONTROL CHARACTER
		 XCT TDTAB-200(TT)	;GETS ACCOUNTED FOR SPECIALLY
		JRST FOO2 ]
	AOS HPOS		;PRINTING CHAR ADVANCES CURSOR
FOO2:	SOJG E,FOO1
	.SUSET [.SIDF2,,[1_TTYOCH]]	;TEMPORARILY DEFER
	$CALL SIOT,[#TTYOCH,OPNTR,OCNTR]	;PRINT OUT THE CHARACTERS
	 .LOSE %LSSYS
	CKHPOS
	$CALL SCPOS,[#TTYOCH,VPOS,HPOS]	;KEEP THE SYSTEM'S CURSOR POS UP TO DATE
	 .LOSE %LSSYS
	.SUSET [.SADF2,,[1_TTYOCH]]	;UNDEFER
;PERFORM ANY NECESSARY KLUDGES
	SKIPN E,KLUDGE
	 JRST IN1
	MOVE TT,[440800,,BUFFER]
FOO3:	ILDB T,KPNTR		;MOVE EACH BYTE LEFT IN THE BUFFER FROM THE END
	IDPB T,TT		;TO THE BEGINNING
	SOJG E,FOO3
	MOVEM TT,IPNTR		;NEXT BYTE WILL BE FIRST IN FROM NET
IN1:	SKIPE B,NBYTES
	 JRST INPUT		;MORE PROCESSING TO BE DONE
NETINX:	SKIPE GOAWAY
	 JRST NETLZI
	INSIRP POP P,TT T E D C B A
	$CALL DISMIS,[P]
	 .LOSE %LSSYS

	subttl LSRCHK and LSRWRN -- see if user is loser

;;; This checks to see if the loser is an AI or LCS member or on a
;;; winners list.  If not, a warning net-hopping message is printed
;;; and the program offers to kill itself off.

;;; The winner-p check has been extracted so that if at some point in
;;; the future this program is modified to check if it's running from
;;; a CRTSTY, those people may not be warned.

;;; If you mung this you might wish to mung CHTN similarly.

;;; skips unless the luser should be warned.
lsrchk:	pushj p,winchk		;are they a winner?
	 skipa			;nope
	  jrst popj1		;yea; so skip
	;; check to see if they're in loser table
	move t,[-loslen,,lostab]
	;; winchk left xuname in tt
lsloop:	camn tt,(t)
	 popj p,		;loser -> don't skip
	aobjn t,lsloop
	;; check inquir entry
	movei a,filech
	move b,[-lsrpgs,,hstpag];map lsr where host table will be
	pushj p,lsrtns"lsrmap
	 jrst lsrlos		;something wrong; print loser message
	.suset [.rxuname,,b]	;xuname into b
	pushj p,lsrtns"lsrunm	;find our entry in database
	 jrst lsrlos		;no inquir entry; must be loser
	.close filech,		;close lsr file
	movei a,lsrtns"i$grp	;we want to check group
	pushj p,lsrtns"lsritm
	 popj p,		;none means guest
	ildb a,a		;get field
	caie a,"A		; AI lab
	 cain a,"L		; LCS
	  jrst lsloo1
	caie a,"V		; NIL group
	 cain a,"Z		; Clinical Decision Making
	  jrst lsloo1
	caie a,"C		; Theory of Computation
	 popj p,		;they're not a lab member
lsloo1:	movei a,lsrtns"i$rel	;Check relationship
	pushj p,lsrtns"lsritm
	 popj p,		;none means loser
	ildb a,a		;get field
	caie a,"X		;some losers put AX when they mean XA
	;; These names are for NETWRK
popj1:   aos (p)		;otherwise skip
cpopj:	popj p,			;when returning

lsrlos:	.close filech,		;close lsr file
	popj p,			;don't skip

;;; Skip means these people know what they're doing; don't hassle them
winchk:	.suset [.rxuname,,tt]
	move t,[-winlen,,wintab]
wnloop:	camn tt,(t)
	 jrst popj1		;winner; skip
	aobjn t,wnloop
	popj p,

;;; these people aren't hassled
wintab:	irp x,,[gumby,alan,cstacy,cent,devon,dph,oaf,mly,jtw,jnc,klotz,cbf,sra,ed,swa,map,jbvb]
	sixbit/x/
termin
winlen==.-wintab

;;; These people are always hassled
lostab: irp x,,[tk,hewitt,rms]
	sixbit/x/
termin
loslen==.-lostab

;;; warn loser that net-hopping is a waste of the machine
lsrwrn:	movei tt,[asciz/
Using this machine to access another will needlessly
drain resources, slowing the system both for you and other users.
You'll probably get better response by connecting directly.

You should not do this unless you have a good reason to do so.  If
you have any questions, typing :LUSER to DDT will request a system
programmer to assist you.

Are you sure you want to net-hop?/]
	pushj p,outstr
	$call iot,[#ttyich,a],[#%tinwt]	;Wait for character
	 .lose %lssys	
	caie a,"y
	 cain a,"Y
	  popj p,		;it was a Y
	cain a,%txsft+"Y
	 popj p,
	caie a,40		;maybe it was a space?
	 .logout 1,
	popj p,

TDTAB:	PUSHJ P,XTDMOV	;%TDMOV OLD-STYLE CURSOR MOTION
	PUSHJ P,XTDMV0	;%TDMV1 IS SAME AS %TDMV0 (SHOULD NEVER BE RECEIVED ANYWAY)
	JFCL		;%TDEOF
	JFCL		;%TDEOL
	JFCL		;%TDDLF
	JFCL		;%TDMTF
	JFCL		;%TDMTN
	PUSHJ P,XTDCRL	;%TDCRL
	JFCL		;%TDNOP
	SOS HPOS	;%TDBS
	PUSHJ P,XTDLF	;%TDLF
	SETZM HPOS	;%TDRCR
	PUSHJ P,XTDORS	;%TDORS
	JFCL		;%TDQOT
	AOS HPOS	;%TDFS
	PUSHJ P,XTDMV0	;%TDMV0
	PUSHJ P,XTDCLR	;%TDCLR
	JFCL		;%TDBEL
	JFCL		;%TDINI

TDLEN=.-TDTAB

XTDMOV:	CAIGE E,5
	 JRST KLOSE
	SUBI E,2
	IBP D
	IBP D
XTDMV0: CAIGE E,3
	 JRST KLOSE
	SUBI E,2
	ILDB TT,D
	MOVEM TT,VPOS
	ILDB TT,D
	MOVEM TT,HPOS
CKVPOS:	MOVE TT,VPOS		;BARF IF VPOS VALUE IS ILLEGAL NOW.
	CAIG TT,118.
	 CAML TT,TCMXV
	  .VALUE
	POPJ P,

;HERE WHEN MULTI-CHAR COMMAND BROKEN IN THE MIDDLE
KLOSE:	MOVEM E,KLUDGE		;NUMBER OF BYTES WHICH MUST BE KLUDGED
	SUBM E,OCNTR		;DO NOT OUTPUT THE KLUDGES AT THE END
	MOVNS OCNTR
	MOVE TT,D		;POINTER TO THE REMAINING BYTES, EXCEPT IT NOW
				;   POINTS PAST THE %TDMOV, SO WE MUST
	DBP8 TT			;   DECREMENT THE BYTE POINTER
	MOVEM TT,KPNTR		;SAVE POINTER TO STUFF THAT HAS TO GET KLUDGED
	SETZM E			;FAKE OUT ROUTINE RETURNED TO:
				;   IT SHOULDN'T KEEP LOOKING FOR CURSOR MOVEMENTS.
	POPJ P,

;%TDCRL - OUTPUT A CRLF.
XTDCRL:	SETZM HPOS

;%TDLF - OUTPUT A LF (RAW MODE TERMINALS).
XTDLF:	AOS TT,VPOS		;NORMALLY JUST INCREMENT VPOS,
	CAIG TT,118.		;BUT AT "END OF SCREEN" SCROLL OR WRAP AROUND.
	 CAML TT,TCMXV
	  CAIA
	   POPJ P,
	SKIPN TT,TTYROL		;TTYROL IS # OF LINES THIS TTY SCROLLS BY.
	 MOVE TT,VPOS		;0 => USE ENTIRE VPOS (IE, WRAP AROUND TO VPOS = 0).
	MOVNS TT
	ADDM TT,VPOS
	POPJ P,

;OUTPUT RESET
XTDORS:	.RESET TTYOCH,
	SOSG INTCNT		;COUNT IT
	 SETZM SUPRES		;RESET THE FLAG THAT THE NET INTERRUPT SET
	SETZM SUPRCG		;UNDO SUPPRESSION DUE TO ^G, ^S (ASSUMING THAT THEY
				;CAUSE OUTPUT RESETS).
	MOVEM D,OPNTR		;DON'T OUTPUT STUFF BEFORE THE OUTPUT RESET
	MOVEM E,OCNTR
	SOS OCNTR		;AND DON'T OUTPUT THE %TDORS ITSELF
	$CALL RCPOS,[#TTYOCH][TT]	;RESET THE CURSOR POSITION INFORMATION
	 .LOSE %LSSYS
	HLRZM TT,VPOS
	HRRZM TT,HPOS
	PUSHJ P,CKVPOS		;BARF IF RCPOS GAVE US A BAD VPOS VALUE.
	NETO [^\]		;TRANSMIT CURSOR POS TO REMOTE HOST,
	NETO [^P]		;TELLING IT IT CAN START SENDING TO US AGAIN.
	NETO VPOS
	NETO HPOS
	.NETS NETOCH,
	POPJ P,

XTDCLR:	SETZM VPOS		;CLEAR SCREEN AND HOME UP
	SETZM HPOS
	POPJ P,

;TTY MESSED OVER INTERRUPT
PIATY:	AOSN PIATYF		;IF EXPECTING PIATY AFTER RETURN TO DDT,
	 PUSHJ P,PIATY2		;REPOSITION THE CURSOR.
	SKIPE PIATYF
	 SKIPN PRINTP
	  JRST PIATY1
	$CALL SCPOS,[#TTYOCH,VPOS,#0]	;PREVENT INFINITE LINEFEEDS ON PRINTING TTY
	 .LOSE %LSSYS
PIATY1:	PUSHJ P,PIATY0
	$CALL DISMIS,[P]
	 .LOSE %LSSYS

PIATY2:	PUSHJ P,UNHMDN		;MOVE CURSOR TO CORRECT PLACE.  THEN CLEAR TO EOL,
	SKIPE PRINTP		;ON DISPLAYS,
	 POPJ P,
	TYAO [^P]		;SO WE DON'T OVERPRINT ANYTHING FROM LOCAL MACHINE.
	TYAO ["L]
	POPJ P,

PIATY0:	SKIPE DEBUG
	 POPJ P,
	NETO [^\]		;TELL THE SERVER TO TELL REMOTE PROGRAM SCREEN HAS BEEN MESSED.
	NETO [^C]
	.NETS NETOCH,
	POPJ P,

;IOCERR INTERRUPT
IOC:	PUSH P,A
	.SUSET [.RBCHN,,A]
	CAIE A,USROCH
	 CAIN A,USRICH
	  .LOSE			;IOC ERROR ON NAME INFERIOR?
NETLUZ:	TYAO [^P]		;IOC ERROR ON NET.  GO TO FRESH LINE
	TYAO ["A]
	PUSHJ P,NETWRK"ANALYZE	;AND TYPE THE ERROR MESSAGE.
	 .VALUE
	MOVE A,FRNHST		;IF WE KNOW ANYTHING ABOUT THAT HOST, SAY SO.
	PUSHJ P,NETWRK"HSTSIX
	 JFCL
	SYSCAL OPEN,[[.UAI,,FILECH] ? [SIXBIT/DSK/] ? [SIXBIT/STATUS/]
		A ? [SIXBIT/SYS/]]	;OPEN SYS:STATUS MC, ETC.
	 JRST DIEDIEDIE
	TYAO [^M]
	TYAO [^J]
NETLU1:	.IOT FILECH,A		;PRINT OUT THE CONTENTS.
	JUMPL A,DIEDIEDIE
	TYAO A
	JRST NETLU1


$$HST3==1
$$ARPA==1	;Support both Arpa and Chaos nets
$$CHAOS==1
$$TCP==1	;Include whatever support there is for TCP
$$HOSTNM==1
$$SYMLOOK==1
$$ICP==1
$$HSTSIX==1
$$ANALYZE==1

.INSRT SYSTEM;CHSDEF >
.INSRT SYSENG;NETWRK >

;;; Inquir database hackery
;;; don't assemble useless gubbage
$$ulnm==0	;don't care about last name
$$ulnp==0	;even if abbreviated
$$unam==0	;no never!
lsrpgs==20			;number of pages for lsrtab

.insrt syseng;lsrtns >

PAT": PATCH":	BLOCK	50

VARIABLES
CONSTANTS

IF1,	INFORM HIGHEST USED = ,\.

HSTPAG==<.+1777>/2000		;PLACE TO MAP IN THE HOSTS1 FILE.

END SUPDUP
