;-*-MIDAS-*-
TITLE Carpet and Hali

Ifndef Halip, Halip==0	;Hali is Carpet over a TTY line.
Define Haly
ifn Halip,termin
Define Haln
ife Halip,termin

IFNDEF 45P,45P==0	;1 FOR 11-45 MAP SIMULATION.
DEFINE 45Y
IFN 45P,TERMIN
DEFINE 45N
IFE 45P,TERMIN

;DEFINE  ACCUMULATORS

A=1
B=2
C=3
D=4
SF=5
DO=6		;IF POSITIVE, VIRT. ADDRESS OF OPEN LOC.
DL=7		;HOLDS %Q OR ARG.
T0=10		;HOLDS LAST CHAR, EXCEPT IN INSN PRINTING.
T1=11		;TEMP FOR INST HANDLERS
T2=12		;USED BY ADDRESS COMPUTATION RTNS.
T3=13
DLEN=14		;HOLDS LENGTH OF %Q OR ARG IN WORDS.
T5=15		;EXTREMELY TEMPORARY.
T6=16		;  "    "    "    " .
P=17

.XCREF A,B,C,P	;While hacking Hali, want full cref.

45Y	45STTM==144000	;MASK OF MODE AND REG SET.
45Y	45CMOD==160200	;BP TO CURRENT MODE
45Y	45MODM==140000	;MASK OF CURRENT MODE
45Y	45PMOD==140200	;BP TO PREVIOUS MODE.
45Y	45REGB==4000	;REGISTER SET SPECIFIER BIT
	PRI==50300	;PRIORITY (BYTE POINTER)
	TF==20
	NF==10
	ZF==4
	VF==2
	CF==1

;I/O CHANNELS

TYIC==1
TYOC==2
LOADCH==3
LPTC==4
UTIC==5
DMPCH==6
Haly Httyoc==7		;Channels for communicating with Hali 11
Haly Httyic==10
ERRC==11

IF1 EXPUNGE %GO			;BIT TYPEOUT MASK FOR GRAPHICS OPS!  WE DON'T NEED IT.

;MISCELLANEOUS CONSTANTS

MAPMSK==574377776000	;$<MAPMSK>T; IN DDT TYPES OUT 10-11 INTERFACE MAP ENTRY
Haln DFLT11==1		;DEFAULT PDP-11
NBPTS==7		;NUMBER OF BREAK POINTS
SNB==400000		;SIGN BIT
Haly Haltty==44		;Default Hali TTY

if1 .kill %pc 		;I hate to do this... ? suffers.
if1 .bind %pc		;Will this work?
;UUO DEFINITIONS

SYMTYP=1000,,
ADRTYP=2000,,
OPENL=3000,,
6TYPE=4000,,
BLKFLS=5000,,
TTOI=6000,,
TTOA=7000,,		;ASCIZ STRING TYPEOUT
ERROR=10000,,
11PUT=11000,,0
11GET=12000,,0
11send=13000,,
11receive=14000,,
UUOMAX==14

;SOME DEFINITIONS TO MAKE THE CODE OBSCURE

ARGERR=ERROR [ASCIZ/ARG/]
CALL=PUSHJ P,
RETURN==POPJ P,
RET=RETURN
SAVE=PUSH P,
REST=POP P,
CRF=TTOA [ASCIZ /
/]

.XCREF CALL,RET,RETURN

TRPPTL==100	;-1)*4=MAX TRAP FOR TRAP PRINT VECTOR
PDLSIZ==200	;PDL SIZE

45Y	SEGBP==140300	;BP TO SEGMENT # FIELD IN WORD #.

IF1 EXPUNGE APR

;MEMORY ALLOCATION

;0	START OF SIMULATOR, ENDS WITH SYM TAB THAT EXPANDS UPWARD
Haln PDP11=300000	;SIMULATED PDP11 MEMORY 1 WORD/WORD

45N	MAXK==28.
45N	MAXCOR==100000
45N	MAXBYT==200000
45Y	MAXK==124.
45Y	MAXCOR==400000
45Y	MAXBYT==1,,

;SYMBOL CONVENTIONS

;C!COM:		ROUTINE FOR : COMMAND COM
;CS!COM:	ROUTINE FOR ; COMMAND COM
;5/29/73 PROGRAMMING THE PDP-10 TO PDP-11 INTERFACE

COMMENT $

THE INTERFACE LETS THE PDP-10 PROGRAMMER DIRECTLY ACCESS THE MEMORIES
OF UP TO EIGHT PDP-11'S.  PDP-10 PAGES ARE MAPPED INTO SEGMENTS OF
VARIABLE SIZE IN THE PDP-11'S MEMORY.  THE PDP-10 PAGE MAP IS ALSO
DIRECTLY ADDRESSABLE IN MEMORY (IT CURRENTLY LIVES IN LOCATIONS
776000-776377)**.  THERE IS ONE ENTRY IN THE MAP FOR EACH PDP-10 PAGE.
** SEE ALSO BELOW

PAGE TABLE ENTRY:
	4.9	VALID
	4.8	WRITE ENABLE
	4.3-4.7	(5 BITS) NOT USED (0)
	3.9-4.2	(3 BITS) PDP-11 NUMBER
	2.2-3.8	(16 BITS) RELOCATION
		ORIGIN OF SEGMENT OF IN PDP-11 ADDRESS SPACE
		PDP-11 ADDRESS=4*RELOCATION
	1.1-2.1	(10 BITS) PROTECTION (PDP-11 PROTECTION=4*PROTECTION
		IF PROTECTION=0 THEN ONLY ONE 16 BIT WORD IS ACCESSIBLE)

				    |
|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|
0 1 2	      7	    10				    26			|
|1|1|    5    |  3  |              16               |        10         |
|_|_|_________|_____|_______________________________|___________________|
 | |	 |	 |		    |			      |
 | |	 |	 |		    |			      |----------->protection
 | |	 |	 |		    |
 | |	 |	 |		    |------------------------------------->relocation
 | |	 |	 |
 | |	 |	 |-------------------------------------------------------->PDP-11 #
 | |	 |
 | |	 |---------------------------------------------------------------->not used
 | |
 | |---------------------------------------------------------------------->write enable
 |
 |------------------------------------------------------------------------>entry valid
;	PDP-10/PDP-11 INTERFACE CONTINUED

WRITE REFERENCE FORMAT:
	3.3-4.9	(16 BITS) WORD 0, LOW ORDER WORD
	1.5-3.2	(16 BITS) WORD 1, HIGH ORDER WORD
	1.4	DON'T WRITE WORD 0
	1.3	DON'T WRITE WORD 1
	1.1-1.2	(2 BITS) NOT USED

				    |
|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|
0				16				323334  |
|              16               |              16               |1|1| 2 |
|_______________________________|_______________________________|_|_|___|
		|				|		 | |  |
		|				|		 | |  |--->not used
		|				|		 | |
		|				|		 | |------>inhibit odd
		|				|		 |
		|				|		 |-------->inhibit even
		|				|
		|				|------------------------->odd word
		|
		|--------------------------------------------------------->even word

READ REFERENCE FORMAT:
	3.3-4.9	(16 BITS) WORD 0, LOW ORDER WORD
	1.5-3.2	(16 BITS) WORD 1, HIGH ORDER WORD
	1.1-1.4	(4 BITS) 0

				    |
|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|
0				16				32	|
|              16               |              16               |   4   |
|_______________________________|_______________________________|_______|
		|				|		    |
		|				|		    |----->0
		|				|
		|				|------------------------->odd word
		|
		|--------------------------------------------------------->even word

NOTE	 -- SPLIT CYCLES WILL DO THE RIGHT THING; HENCE, ILDB AND IDPB WORK.
CAUTION	 -- WHEN USING BYTE INSTRUCTIONS, A 16 BIT BYTE SIZE IS
RECCOMMENDED.  SUCCESSIVE INCREMENTS OF BYTE POINTERS WITH AN 8 BIT BYTE
SIZE DO NOT ADDRESS CONSECUTIVE BYTES IN THE PDP-11!

ITS SYSTEM CALL TO PUT 11 MAP ENTRY IN YOUR 10 MAP:
	.CALL	[SETZ
		 SIXBIT /T11MP/
		 10PGNO			;PTR TO 10 PG NO
		 SETZ PGENT]		;PTR TO ENTRY (FORMAT ABOVE)
10PGNO:	PDP-10 PAGE #
PGENT:	<<ACCESS>_34.>+<<PDP-11 #>_26.>+<<PDP-11 ADDRESS/4>_10.>+<<SEGMENT SIZE (BYTES>/4>
	FOR ABOVE 10 ADDRESSES 6000-7777 ARE MAPPED INTO
	11 ADDRESSES 10000-17776. BOTH READ AND WRITE ARE ENABLED.
$

COMMENT $

		How Hali works.

The PDP-11 is connected to the PDP-10 by a TTY line.  On this TTY line, Hali
reads and writes using the formats described below.  The TTY line is assumed
dedicated to operating Hali: in Building 38, we have a multiplexed TTY arrangement,
so this does not mean running many lines to the 11.  Since the TTY is
dedicated, no escape sequence is defined.  If it is desired to run Hali
on a non-dedicated TTY line, insert code (conditionalized) at ????.

A full word on the 11 is 16 bits.  The 10 can send 8-bit chunks, but
can only receive 7 bits at a time.  This is a pain.  In any case,
words are send as two 8-bit bytes, low byte first, but must be
received as three bytes, the first five bits, the second five bits,
and the last six bits (is this random enough?).


Commands to 11: (* means not implemented on 11 or Hali end)

Read
Send:	1 address
Reply:	c(address)

Write
Send:	2 address <what to write>
Reply:	<old contents>

Ifset*					;Useful?
Send:	3 address <what to write>
		<what was expected to be there before writing>
Reply:	<0 if not executed; 1 if executed> <old contents>

Stop*
Send:	4
Reply:	<PC stopped at>
Effect: listens only to this line; turns off interrupts

Continue*
Send:	5
Effect: undoes Stop

Single step*
Send:	6
Effect: ^N

Dump registers (i.e. get from 11)*
Send:	7
Reply:	<c(reg) for each register, including %ps, i.e. 0,...7,%ps>

Load registers (i.e. send to 11)*
Send:	10 then c(reg) for each register, as above.  PC, SP, and PS are saved.
Effect:	Tells 11 what registers should be when it continues or one-proceeds.
$
define Byteo
.iot Httyoc,[%tdqot]	;Quote possible 200-characters
.iot Httyoc,termin

define Bytei
.iot Httyic,termin

hl.read==201
hl.write==202
hl.ifset==203
hl.stop==204
hl.continue==205
hl.sstep==206
hl.dmpreg==207
hl.ldreg==210

Comment $
		11 to Hali

The 11 may say to Hali:

I hit a breakpoint

Some sort of error happened

$

ABEG:	LOC 41
	JSR UUOH
	JSR TSINT

DEFINE CONC A,B
A!B!TERMIN

DEFINE TSOPEN A,B
	.OPEN A,B
	OPENL B
	TERMIN

DEFINE SYSCAL A,B
	.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
	.VALUE
TERMIN

DEFINE SYSCL A,B
	.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
TERMIN

DEFINE INSIRP A,B
IRPS INSIR1,,[B]
A,INSIR1
TERMIN TERMIN

IOCNUM==0	;GET CONTROL ON IOC ERRORS
DEFINE IOCGET X
	IF2 [IOCLOC==.
LOC IOCTAB+IOCNUM
	IOCLOC
	X
LOC IOCLOC]
	IOCNUM==IOCNUM+2
	TERMIN

DEFINE	CSLWRD	A
	JSP D,	CSLR!A
TERMIN			;LOAD 1 WORD FROM LOADCH INTO A (T2, T3, T5).

Define Upper x
	cain x,177	;Don't want to affect rubout
	jrst .+3
	trne x,100	;Change character to upper case
	trz x,40
termin

LOC ABEG

BEG:	SETZM DDTPDP	;DDTPDP=0 MEANS NORMAL NOT IN DDT
			;DDTPDP>0 NOT IN DDT BUT FAKE OUT MTRAP ETC.
			;DDTPDP<0 IN DDT (SAVE PDL PNT HAS NEG COUNT IN LH)
	SETOM DINITF	;WILL BE 1ST CALL TO DDT SOON.
	MOVE P,[-PDLSIZ,,PDL]
	SKIPN XUNAME
	.SUSET [.Rxuname,,XUNAME]
	SETZM LPTFLG
	PUSHJ P,MERRV
	.OPEN TYOC,TYOF
	.VALUE		;IF NO TYPEOUT.
	MOVE A, [-BSUSL,,BSUST]
	.SUSET A	;SET UP INTERRUPTS
	.OPEN TYIC,TYIF
	TTOA [ASCIZ /
TYPE IN FAILS/]
	.STATUS TYIC,A
	ANDI A,77
	CAIN A,2
	SETOM GETTY		;SET GETTY TO -1 IF GRAPHICS TTY.
	.CALL TTYGT
	.VALUE
	TLZ A,2000
	MOVEM A,TTYM1A		;SET UP ORDINARY TTYSET,
	TLO A,2000
	MOVEM A,TTYMAA		;ACTIVATE-ON-NEXT-CHAR TTYSET.
Haln	6TYPE [.FNAM1/]
Haly	6type [sixbit /hali/]
	TTOA [ASCIZ / /]
	6TYPE [.FNAM2]
Haln	MOVEI A,DFLT11		;# OF DEFAULT PDP11
Haln	PUSHJ P,GET11P		;GET 11 PAGES INTO MAP
Haly	movei a,Haltty
Haly	pushj p,Httyopen	;Open Hali TTY
45Y	CALL AI45
	CRF
	.OPEN UTIC,INITFI	;Init file on default directory?
	CAIA
	JRST DOINIT
	.CALL [	SETZ		;How about on Xuname directory?
		SIXBIT /OPEN/
		1000,,UTIC
		[SIXBIT /DSK/]
		XUNAME
		Haln [SIXBIT /.CARP./]
		Haly [sixbit /.HALI./]		;Who knows?  Maybe someone wants both.
		SETZ [SIXBIT /(INIT)/]]
	JRST BEG2
DOINIT:	TTOA [ASCIZ /INIT
!/]
	SETOM FILINF
	JRST DDT

BEG2:	TTOI "!
	JRST DDT

INITFI:	Haln SIXBIT /   DSK.CARP.(INIT)/
	Haly Sixbit /   dsk.hali.(init)/
FILINF:	0

Haln[	;non-Hali only.

;GETS 11 PAGES INTO MAP
;CALL WITH # OF PDP11 IN A

GET11P:	MOVEM	A,CUR11		;SAVE 11#
	LSH	A,26.		;MOVE # TO CORRECT FIELD
	MOVE	C,A
	PUSH	P,A
	MOVEI A,<PDP11_-10.>	;PAGE # OF ORIGIN OF PDP-11 MEMORY
	MOVEI B,16		;# PAGES TO 28K PDP-11 WORDS
	MOVEM B,KCOUNT
	ADD C,[<3_34.>\1777]
	PUSHJ P,G11P1
	MOVEI A,<<760000_-2>+PDP11>_-10.
	MOVEI B,2		;GET 4K PDP-11 WORDS FOR IO REGISTERS
	POP	P,C		;111 #
	ADD C,[<3_34.>\<<760000_-2>_10.>\1777]
G11P1:	.CALL [	SETZ
		SIXBIT /T11MP/
		A
		SETZ C]
	.VALUE
	ADD C,[2000_10.]
	ADDI A,1
	SOJG B,G11P1
	POPJ P,
]	;end Haln

CUR11:	0			;# OF CURRENT PDP11

Haly[	;for Hali

;; Opens Hali TTY

Httyopen: movem a,cur11		;Which TTY?
	skipe debugp
	jrst dbgtty
	idivi a,8.		;Convert to Sixbit
	addi a,'0
	lsh a,6
	addi a,(b)'0		;Now have Sixbit in A
	addi a,<'T>_12.		;Txx
	hrli a,.uii		;image input
	.open Httyic,a
	.value [asciz /:Can't open Hali TTY for input./]
	hrli a,%tjsio+.uio	;Now for output TTY, also superimage
	.open Httyoc,a
	.value [asciz /:Can't open Hali TTY for output./]
	popj p,

dbgtty:	.open Httyic,[ .uii,,'clo ? 'debugg ? 'haliii]
	.value
	.open Httyoc,[ .uio,,'clo ? 'debugg ? 'halioo]
	.value
	popj p,

]  ;end of Haly

CPPRI:	TLNN SF,NUMFND		;SELECT PROCESSOR LEVEL USED BY BPT S, ETC
	JRST CPPRI1		;TYPE CURRENT
	MOVEM T5,BPTLVL
	POPJ P,

CPPRI1:	MOVE B,BPTLVL
	PUSHJ P,OCTP
	JRST CPPRI2

;DDT ROUTINE TO SELECT 11 # or TTY # for Hali
; arg:SELECT selects 11 #arg
CSELEC:	TLNN	SF,NUMFND
	JRST	CSELE1		;NO ARGUMENT
	MOVE	A,T5		;ARGUMENT
Haln	PUSHJ	P,GET11P
Haly	pushj p,Httyopen
	RETURN
;if no arg, type currently selected 11
CSELE1:	Haln TTOA [ASCIZ /Using 11 #/]
	Haly ttoa [asciz /Using as Hali TTY  T/]
	MOVE T5,CUR11		;PICK UP 11 #
	TLO SF,DNUMM	;MAKE SURE TO PRINT AS #
	SYMTYP	T5
CPPRI2:	CRF
	RETURN


;HERE TO SET SIZE OF PDP-11 MEMORY, TAKES # 1K BLOCKS IN DECIMAL

CCORE:	TLNN SF,NUMFND		;ARGUMENT?
	JRST CCORE1		;NOPE
	MOVE D,T5		;# PDP-11 WORDS IN K
	CAILE D,124.		;MAKE SURE ITS LEGAL
	ERROR [ASCIZ /CORE -- ILLEGAL ARGUMENT/]
	LSH D,10.		;FUDGE, FUDGE
	PUSH P,T1
	JRST SETSZ3

CCORE1:	HRRZ T5,%CORE
	LSH T5,-11.
	TLO SF,DNUMM+DDECM
	SYMTYP T5
	TTOA [ASCIZ /K CORE/]
	CRF
	POPJ P,

;ROUTINE TO FIND SIZE OF PDP-11 MEMORY

SETSIZ:	PUSH P,D
	PUSH P,T1
	HRRZ D,%CORE			;HAS CORE SIZE BEEN SPECIFIED BEFORE?
	JUMPN D,[	LSH D,-1	;YES
			JRST SETSZ3]
Haln[	MOVEI T5,177777
	PUSH P,NOMINS
	MOVSI T1,(JFCL)
	MOVEM T1,NOMINS
	ADDI D,1		;TEST 2ND WORD OF PAGE, NOT 1ST,
SETSZ1:	11GET T1,(D)		;BECAUSE PEOPLE LIKE TO PUT 11 IN LOOP IN LOCATION 0.
	11PUT T5,(D)
	11GET T6,(D)
	11PUT T1,(D)
	CAIGE D,<160000>_-1
	CAME T5,T6
	JRST SETSZ2		;THAT'S THE SIZE
	ADDI D,10000		;PDP-11 MEMORY COMES IN 4K WORD CHUNKS
	JRST SETSZ1

SETSZ2:	POP P,NOMINS
	TRZ D,7777
]
Haly	Error [asciz /I can't guess the core size.  Please specify it./]
SETSZ3:	MOVEM D,MEMSIZ
	LSH D,1
	HRRM D,%CORE		;# BYTES IN CORE
	LSH D,-12.		;PDP-10 CORE BLOCKS
	MOVEM D,KCOUNT
	POP P,T1
	POP P,D
	POPJ P,

;INTERRUPT HANDLER

TSINT:	0
	0
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,40
	PUSH P,UUOH
	SETZM INTINS
	SKIPGE DEBUGP
	.SUSET [.RJPC,,INTJPC]
	SKIPL A,TSINT
	JRST OTHERI	;FIRST WORD INT
Haly[
	trnn a,1_Httyic
	jrst tsint1
	.value		;11 wants to signal some condition.
;;; ?????	
]
tsint1:	TRNN A,1_TYIC
	JRST BADINT	;SECOND WORD BUT NOT VALID CHANNEL
	MOVEI A,TYIC
	.ITYIC A,
	JRST TSINTX
	AOSN ICTLQF
	JRST TSINT2
	CAIN A,^Q
	JRST TSINTQ
	CAIE A,^W
	CAIN A,^S
	JRST TSILNT
	CAIN A,^V
	SETOM TYOFLG
	CAIN A,^B
	JRST TSINTB
	CAIN A,^E
	JRST TSINTE
	CAIN A,^G
	JRST TSQUIT
TSINT2:	SKIPGE DDTPDP
	JRST TSINTX
	CALL TSINNS	;STOP SLEEPING, PC INTO A.
	JRST TSINTX

TSINNS:	HRRZ A,TSINT+1
.VALUE;	CAIN A,IWAITS	;DON'T RETURN TO .SLEEP .
	AOS TSINT+1
	RETURN

TSQUIT:	SKIPGE DDTPDP		;IF INSIDE DDT,
	.DISMI [DERR]		;RETURN TO MAIN LOOP RIGHT AWAY.
	AOS A,QUITF
	CAIL A,2
	.DISMI [QUIT]		;3 ^G'S - STOP IMMEDIATELY.
	TTOA [ASCIZ/
^G   /]
	CAIE A,1
	JRST TSINTX
TSILNT:	SETZM TYOFLG
	PUSHJ P,TRESET
	JRST TSINTX

TSINTQ:	SETOM ICTLQF
	JRST TSINTX

TRESET:	.RESET TYOC,
	SKIPE LPTFLG
	.RESET LPTC,
	RETURN

QUIT:	SAVE TSINT+1		;DDT WILL RETURN TO INTERRUPTED SIMULATION.
	SAVE [DDT]		;RSTALL WILL RETURN TO DDT.
	PUSHJ P,MERRV
	TTOA [ASCIZ/
^GSUPER-QUIT!   /]
	POPJ P,

QUITF:	-1
ICTLQF:	0

OTHERI:	TRNE A,200000
	TTOA [ASCIZ /
PDL OVERFLOW/]
	TRNE A,400
	JRST OTHIOC	;IOC INT
	TRNN A,20000
	JRST BADINT
	MOVSI A,600000	;NON-EX MEM
	MOVEM A,NXMCLB
	HRRZ A,TSINT+1
	CAIL A,SYMTAB
	TTOA [ASCIZ/
NXM OUTSIDE PROGRAM AREA/]
	SKIPA A,-1(A)
NXMX2:	MOVE A,(A)
	HRRI A,@A
;	TRNN A,400000	;THIS TEST FOULS UP ON BYTE INSNS.
;	TRNN A,300000
;	TTOA [ASCIZ/
;NXM OUTSIDE VIRT. MEM/]
	AND A,[777740,,-1]
	TLC A,(XCT)
	TLNN A,777000
	JRST NXMX2	;XCT, GO DOWN CHAIN
	TLC A,(XCT)
	HRRI A,NXMCLB
	JRST NXMXIT

OTHIO4:	MOVE A,1(A)
NXMXIT:	MOVEM A,INTINS
TSINTX:	POP P,UUOH
	POP P,40
	POP P,C
	POP P,B
	POP P,A
	SKIPN INTINS
	.DISMI TSINT+1
	AOS TSINT+1		;TAKE CARE OF SKIPPING INSNS.
	XCT INTINS
	SOS TSINT+1
	.DISMI TSINT+1

OTHIOC:	HRRZ C,TSINT+1
	MOVEI A,IOCTAB
OTHIO2:	CAMN C,(A)
	JRST OTHIO4
	ADDI A,2
	CAIE A,IOCEND
	JRST OTHIO2
	TTOA [ASCIZ /
IOC ERROR IN /]
	SOS TSINT+1		;RETURN TO THE .IOT .
	JRST BADINU

NXMCLB:	0	;MAY BE CLOBBERED
INTJPC:	0
INTINS:	0

BSUST:	.SMASK,,[220400]
	.SPICL,,[-1]
	.SMSK2,,[1_TYIC]
BSUSL==3

TYIF:	4,,SIXBIT /   TTY/
TYOF:	21,,SIXBIT /   TTY/
XUNAME:	0

BADINT:	PUSHJ P,MERRV
	TTOA [ASCIZ /
BAD INTERRUPT IN 
INT:   /]
	MOVE B,TSINT
	PUSHJ P,FOCTP
BADINU:	REST UUOH		;RESTORE EVERYTHING SAVED.
	REST 40
	REST C
	REST B
	REST A
	.VALUE [ASCIZ*INTJPC/        *]
	.DISMI TSINT+1		;STOP BEFORE NEXT INSN.

LPTFIL:	1,,SIXBIT /   LPT/
	SIXBIT /WALL  PAPER/

;UUO HANDLER
UUOH:	0
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,40	;4O MUST BE NEXT TO LAST PUSHED
	PUSH P,UUOH	;UUOH MUST BE LAST PUSHED
	HRRZ A,40
	LDB C,[331100,,40]
	SKIPE C		;JUMP WILL CLOBBER JPC
	CAILE C,UUOMAX
	SKIPA
	JRST @UUODIS-1(C)
	.SUSET [.RJPC,,20]	;What the hell?  20??
	.suset [.rjpc,,uuojpc']
	PUSHJ P,MERRV
	TTOA [ASCIZ /
ILLEGAL UUO IN 
.JPC/]
	REST UUOH
	REST 40
	REST C
	REST B
	REST A
	SOS UUOH		;POINT TO UUO.
	.VALUE [ASCIZ*20/*]
	JRST @UUOH		;STOP BEFORE THE UUO.

UUODIS:	XSYMTY
	XADRTY
	UOPENL
	U6TYPE
	UBLKFL
	UTTOI
	UTTOA
	UERROR
	U11PUT
	U11GET
haly	u11send
haly	u11receive
;11 MEMORY ACCESS ROUTINES
Haln[
;RESTORES REGISTERS FOR EXIT ROUTINE

PUTREG:	PUSH P,A
	11GET T5,BPTVEC/2
	JUMPE T5,POPAJ
	LSH T5,-1
	11GET T6,-3(T5)
	JUMPE T6,POPAJ
	LSH T6,-1
	MOVEI A,10
	ADD T6,A
PUTR1:	MOVE T5,R0(A)
	11PUT T5,(T6)
	SUBI T6,1
	SOJGE A,PUTR1
	JRST POPAJ

;GETS REGISTERS INTO PDP-10 MEMORY

GETREG:	PUSH P,A
	SETOM R0
	MOVE A,[R0,,R1]
	BLT A,R7
	11GET T5,BPTVEC/2	;PDP11 BPT VECTOR
	JUMPE T5,POPAJ
	LSH T5,-1		;WORD ADDRESS
	11GET T6,-3(T5)		;POINTS TO ACS
	JUMPE T6,POPAJ
	LSH T6,-1
	MOVEM T6,11REGS		;LEAVE AN EASY HANDLE
	MOVEI A,10		;GET ALL REGISTERS AND PS
	ADD T6,A
GETR1:	11GET T5,(T6)
	MOVEM T5,R0(A)
	SUBI T6,1
	SOJGE A,GETR1
POPAJ:	POP P,A
	POPJ P,
]	;end Haln

Haly[
Putreg:	push p,a
	push p,b
	Byteo [hl.dmpreg]
	move t5,[-10,,r0]	;Note that PS follows regs.
putrg1:	move a,(t5)
	pushj p,send
	aobjn t5,putrg1
popabj:	pop p,b
popaj:	pop p,a
	popj p,

getreg:	push p,a
	push p,b
	byteo [hl.ldreg]
	move t5,[-10,,r0]
getrg1:	pushj p,receive
	movem a,(t5)
	aobjn t5,getrg1
	jrst popabj
] ;end Haly


Haln[		;; Specific to Carpet

;UUO ACTION ROUTINES

U11PGC:	MOVE A,NOMINS		;SETUP ROUTINE FOR U11GET AND U11PUT
	MOVEM A,NOMAT		;ASSUME CHECK READ WILL REVEAL SAME DATA AS WRITE
	MOVEI A,50.
	MOVEM A,NOMTRY		;TRIES ON THIS DEPOSIT
	LDB A,[270400,,40]	;AC FIELD OF UUO
	MOVEI B,@40		;EFFECTIVE ADDRESS
	CAIG A,C		;DOESNT WORK FOR AC S A B AND C
	.VALUE
	LDB C,[000100,,B]	;BYTE TO PICK IN WORD
	LSH B,-1		;TEN WORD ADDRESS
	TRC B,160000_-2		;LOOK FOR DEVICE REGISTERS
	TRCN B,160000_-2
	PUSHJ P,[	TRO B,760000_-2	;ADDRESS IS IN IO AREA
			PUSH P,[JFCL]
			POP P,NOMAT	;READ AFTER WRITE NOT NECESSARILY YIELD SAME
			POPJ P,]
	MOVEM B,11ADR'
	MOVEI B,PDP11(B)
	EXCH B,11ADR
	POPJ P,

U11GET:	PUSHJ P,U11PGC
	LDB C,U11PGB(C)
	MOVEM C,(A)
	JRST UUOXIT

U11PUT:	PUSHJ P,U11PGC
	MOVE A,(A)
NOMAT2:	PUSH P,A
	LSH A,4		;LOW 4 BITS NOT USED
	SKIPN C
	LSH A,16.
	TRO A,10		;SELECT 11 WORD TO NOT WRITE
	SKIPN C
	TRC A,14
	MOVEM A,PDP11(B)	;DONT USE DPB SINCE THAT DOES READ PAUSE WRITE
	POP P,A			;WHICH MIGHT AFFECT OTHER WORD IF ITS AN IO REG
	PUSH P,B
	LDB B,U11PGB(C)
	ANDI A,177777
	CAIE B,(A)
	XCT NOMAT
	POP P,B
	JRST UUOXIT

NOMAT:	.VALUE		;XCT THIS INSTRUCTION WHEN 11 INTERFACE LOSES
NOMINS:	JRST NOMAT1	; OR .VALUE OR JFCL

NOMAT1:	SOSGE NOMTRY
	.VALUE		;50 TRIES DIDNT WIN EITHER
	POP P,B
	PUSH P,A
	MOVEI A,2
	.SLEEP A,	;LET 10-11 INTERFACE "REST"
	POP P,A
	AOS NOMATC
	JRST NOMAT2

NOMTRY:	0		;COUNT OF TRIES REMAINING ON THIS DEPOSIT
NOMATC:	0		;COUNT OF TIMES 10-11 INTERFACE LOST

U11PGB:	242000,,PDP11(B)
	042000,,PDP11(B)

]	;End of non-Hali

Haly[	;;	Hali-only stuff


byte0==001000	;11
byte1==101000	;11
part1==130500	;The three bytes received from the 11.
part2==060500	; See the description of the Hali format.
part3==000600

acfield==270400	;on 10

Define 11go
	byteo [hl.continue]
termin

adrsnd:	movei a,@40	;Get address wanted
;drop through to--	
send:	ldb b,[byte0,,a]
	Byteo b
	ldb b,[byte1,,a]
	Byteo b
	popj p,

receive: setz a,
	Bytei b
	dpb b,[part1,,a]
	Bytei b
	dpb b,[part2,,a]
	Bytei b
	dpb b,[part3,,a]
	popj p,

u11get:	Byteo [hl.read]	;Go through read sequence
	pushj p,adrsnd
	pushj p,receive
	ldb b,[acfield,,40]	;Where to put result
	caig b,3	;Can't be a, b, or c.
	.value [asciz /:U11get loses on ac a, b, or c.
/]
	movem a,(b)	;Store
	jrst uuoxit


u11put:	Byteo [hl.write]
	pushj p,adrsnd	;Address to write to
	ldb b,[acfield,,40]
	move a,(b)	;What to write
	pushj p,send
	pushj p,receive	;ignore result
	jrst uuoxit

]	;end Haly

UTTOA:	LDB B,[270400,,40]	;SKIP BY C(AC FIELD)
	ADDM B,(P)
	HRLI A,440700
	SAVE MCTLVF
MES2:	ILDB B,A
	CAIG B,^F
	XCT MESTAB(B)
	CAIN B,^K
	JRST MCTLK	;DECP
	CAIN B,^V
	JRST MCTLV
	TTOI (B)
	JRST MES2

MCTLV:	SETOM MCTLVF
	JRST MES2

MESTAB:	JRST MESXIT	;^@
	JRST MFOCTP	;^A
	JRST OPPNT	;^B
	JFCL		;^C
	JRST MCTLD	;SYMTYP
	JRST MCTLE
	JRST MCTLF	;ADRTYP

MERRV:	SETOM TYOFLG
	RETURN

MCTLVF:	0	;FORCE TTY OUTPUT FOR ERROR MESSAGES

MESXIT:	REST MCTLVF
	JRST UUOXIT

MFOCTP:	PUSHJ P,UGQUAN
	PUSHJ P,FOCTP
	JRST MES2

FOCTP:	LSHC B,-43	;FULL WORD OCTAL PRINT
	LSH C,-1
	DIVI B,8
	HRLM C,(P)
	SKIPE B
	PUSHJ P,FOCTP
	HLRZ C,(P)
	TTOI "0(C)
	RETURN

UGQUAN:	ILDB B,A	;GET QUANTITY
	CAIL B,"8
	JRST UGQUA2
	HRRZ B,R0-"0(B)
	RETURN

UGQUA2:	CAIE B,"A
	SKIPA B,QT
	MOVE B,QA
	RETURN

OPPNT:	PUSH P,[MES2]
	SKIPL DDTPDP
	AOS DDTPDP
	SKIPL DDTPDP
	HRLZ SF,%TMODE
	SKIPGE DL,OPC
	JRST OPPNT1
	LSH DL,1
	PUSHJ P,DPINSN
	SKIPA
OPPNT1:	TTOA [ASCIZ/--DDT--/]
	SKIPL DDTPDP
	SOS DDTPDP
	POPJ P,

MCTLF:	SKIPA C,[ADRTYP QD]
MCTLD:	MOVE C,[SYMTYP QD]
	PUSHJ P,UGQUAN
	MOVEM B,QD
	PUSH P,[MES2]
	SKIPL DDTPDP
	HRLZ SF,%TMODE
	XCT C
	POPJ P,

MCTLE:	.VALUE		;FATAL ERROR
	SKIPGE DDTPDP
	.DISMI [DERR]
	.DISMI [BEG]

MCTLK:	PUSHJ P,UGQUAN
	PUSHJ P,DECP
	JRST MES2

OCTP:	SKIPA C,[8]
DECP:	MOVEI C,10.
	HRRM C,ANYP
ANYP:	IDIVI B,.
	HRLM C,(P)
	SKIPE B
	PUSHJ P,ANYP
	HLRZ B,(P)
	TTOI "0(B)
CPOPJ:	RETURN

UBLKFL:	HRRZ B,(P)	;FLUSH QUEUE BLOCKS
	ADD B,[<222200,,>-1]
UBLKF2:	ILDB A,B
	TLNE B,770000
	AOS (P)
	JUMPE A,UUOXIT
	JRST UBLKF2

UTTOI:	SKIPE MCTLVF
	JRST UTTOI1
	SKIPE TYOFLG
UTTOI1:	.IOT TYOC,A	;THE ONLY TYPE OUT IOT
	SKIPE LPTFLG
	.IOT LPTC,A
UUOXIT:	POP P,UUOH
	POP P,40
	POP P,C
	POP P,B
	POP P,A
	JRST 2,@UUOH

U6TYPE:	MOVE B,@40
	MOVE A,[440600,,B]
U6TYP2:	ILDB C,A
	JUMPE C,UUOXIT
	TTOI 40(C)
	JRST U6TYP2

UOPENL:	.SUSET [.RBCHN,,C]	;OPENL UUO, GET # OF CHANNEL.
	CAIE C,LPTC
	JRST UOPNL1
	SETZM LPTCNT
	SETZM LPTFLG
UOPNL1:	DPB C,[270400,,OPNLX1]
	DPB C,[270400,,OPNLX2]
OPNLX1:	.STATUS .,OPLERR
	HLR C,(A)
	CAIE C,4^5	;NEW SYSTEM CALL OPEN, DON'T GET DEV NAME.
	TRNE C,1
	JRST UOPNL3	;OUTPUT LOST
	.SUSET [.RSNAME,,LSNAME]
	.SUSET [.SSNAME,,[SIXBIT /PDP11/]]
OPNLX2:	.OPEN .,(A)
	JRST UOPNL2
	.SUSET [.SSNAME,,LSNAME]
	JRST UUOXIT

UOPNL2:	.SUSET [.SSNAME,,LSNAME]
UOPNL3:	.OPEN ERRC,ERRFIL
	JRST .-1
	PUSHJ P,MERRV
UOPNL4:	.IOT ERRC,B
	CAIE B,14
	CAIN B,3
	JRST UOPNL6
	TTOI (B)
	JRST UOPNL4

UOPNL6:	CAIN C,4^5
	 JRST DERR
	HRLZ B,(A)
	6TYPE B
	JRST DERR

ERRFIL:	(SIXBIT /ERR/)
	3
OPLERR:	.

LSNAME:	0	;LAST SYSTEM NAME

;IN DDT,  PRINTS MESSAGE & CAUSES ERROR, DOESN'T RETURN.
;OUTSIDE DDT, PRINTS MESSAGE, CAUSES DDT TO BE CALLED, RETURNS.
UERROR:	PUSHJ P,MERRV	;TURN ON TTY FOR ERROR MSG.
	SKIPN DEBUGP
	JRST UERRO1
	TTOA [ASCIZ/
10PC: /]
	MOVE B,(P)	;IF DEBUGGING,
	PUSHJ P,FOCTP	;PRINT ADDR AFTER ERROR UUO.
	CRF
UERRO1:	SKIPGE DDTPDP
	TTOA [ASCIZ/   /]
	TTOA (A)
	SKIPL DDTPDP
	.VALUE
	JRST DERR
IFN 0,[
	LDB B,[270400+P,,-1]
	JUMPE B,UUOXIT		;AC FIELD 0 - NO POPJS.
	MOVNI B,-POP14J(B)
	HRRM B,(P)		;EXIT TO RTN TO POPJ SEVERAL TIMES.
	JRST UUOXIT

REPEAT 14.,REST POP14J
	RETURN
POP14J:	0		;EXCESS WDS ON PDL THROWN AWAY HERE.
]

TYI1:	.IOT TYIC,T0
	Upper t0
	CAIN T0,^Q
	JRST TYI4
	CAIE T0,177
	CAIGE T0,140
	SKIPA
	SUBI T0,40
	CAIE T0,^E
	CAIN T0,^V
	JRST TYI1
	CAIE T0,^B
	CAIN T0,^W
	JRST TYI1
	CAIE T0,^S
	RETURN
	SETOM TYOFLG
	JRST TYI1

TYI4:	.IOT TYIC,T0
	Upper t0
	RETURN

TSINTB:	SAVE [TSINTX]
DGLNCB:	SKIPN LPTFLG
	PUSHJ P,OPNLPT
	SETOM LPTFLG
	RETURN

TSINTE:	SAVE [TSINTX]
DGLNCE:	SKIPN LPTFLG
	RETURN
	SETZM LPTFLG
	SOSGE LPTCNT
	.CLOSE LPTC,
	RETURN

CWALLP:	MOVEI A,LPTFIL	;^B TO FILE
	PUSHJ P,DGFIL
	PUSHJ P,OPNLPU
	SKIPE LPTFLG
	RETURN
	SETOM LPTFLG
	AOS LPTCNT
	RETURN

OPNLPT:	AOS C,LPTCNT
	SOJN C,CPOPJ
OPNLPU:	.OPEN LPTC,LPTFIL
	JRST .+2
	RETURN
	TSOPEN LPTC,TPLFIL
	TTOA [ASCIZ /USING TPL/]
	RETURN

TPLFIL:	SIXBIT /  !TPLWALL  PAPER/
BLKGET:	PUSH P,T1	;GET CORE BLOCK
	PUSH P,T0
	MOVE T1,@-2(P)
	MOVEI T1,@T1
	LSH T1,-1
	TRZ T1,777
	IOR T1,[4000,,400000]
	MOVEM T1,QA
	.CBLK T1,
	TTOA [ASCIZ /
BLKGET CBLK FAILED
A/]
	HLLZ T0,@-2(P)
	JUMPGE T0,POT0A1	;ALLOW NEG FROBS TO SET TO NXM
	LSH T1,1
	MOVEM T0,(T1)
	HRLS T1
	AOS T1
	HLRZ T0,T1
	BLT T1,1777(T0)
POT0A1:	POP P,T0
POT1J1:	POP P,T1
	AOS (P)
	RETURN

BLKZAP:	PUSH P,T1	;FLUSH CORE BLOCK
	MOVE T1,@-1(P)
	MOVEI T1,@T1
	LSH T1,-1
	ANDI T1,377000
	MOVEM T1,QA
	.CBLK T1,
	TTOA [ASCIZ /
BLKZAP CBLK FAILED
A/]
	JRST POT1J1
;FLAGS IN SFLAGS, LEFT HAND SIDE

DBYTM==200000	;REGISTER OPEN IN BYTE MODE.
DEXCM==100000	;IN DON'T PRINT CONTENTS MODE.
DINSM==40000	;PRINT AS INSTRUCTION.
DSYMM==20000	;PRINT NUMBERS, ADDRESSES SYMBOLICALLY.
DASCM==10000	;PRINT NUMBERS AS ASCII.
DNUMM==4000	;PRINT NUMBERS NUMERICALLY. ABOVE DSYMM.
DDECM==2000	;WHEN PRINTING NUMERICALLY, USE BASE 10. .
DREGM==1000	;PRINT REGISTER NUMS NUMERICALLY.
DDSKM==400	;OPEN NEXT LOC AS DISK ADDR.
NUMFND==200	;SET AT ENTRY TO COMMAND IF HAS ARG.
DSEMFL==100	;IF SET, RUBBING-OUT SHOULD BE STOPPED BY NON-DIGITS.
CSSFLG==40	;SET DURING ;S -- CAUSES INPUT FROM LOADCH.
D1CHAR==20	;RE-READ THE CHAR IN T0, IN NEXT GETCHR.
BYTOPN==10	;CURRENTLY OPEN LOC. IS BYTE.
DSKOPN==4	;CURRENTLY OPEN LOC. IS IN DISK.

DMODES==DBYTM+DEXCM+DINSM+DSYMM+DASCM+DNUMM+DDECM+DREGM+DDSKM

	JRSTF==JRST	2,0
	IF2 CDDT==CALL DDT	;USED FROM HACTRN WITH $X.
	IF2 GETCHR==CALL DGCHR	;NEXT INPUT CHAR, IN DDT.

;FLAG IN AC CONTAINING ADDRESS (IN DDT)
REGBIT==1	;INDICATES ADDR. IS REGISTER NUM.
.5KBIT==400000	;INDICATES .5KILLED SYMBOL .
XREGTY:	TLNE	SF,DREGM
	JRST	XREGT1
	SKIPN	XSYMTA
	TLNN	SF,DNUMM
	TLNN	SF,DSYMM
	JRST	XREGT1		;IF SHOULDN'T PRINT SYMBOL.
	HRLI	B,1		;TYPE-CODE FOR REG. SYM.
	HRRZ	A,SYMEND
XREGT0:	CAME	B,1(A)		;IF THIS STE'S VALUE IS REG. TO TYPE,
	JRST	XREGT5
	6TYPE	(A)		;PRINT NAME OF SYMBOL.
	JRST	UUOXIT
XREGT5:	SUBI	A,2
	CAIE	A,SYMDRG	;NO NEED TO CHECK INSNS AND %1...%7 .
	JRST	XREGT0
XREGT1:	SKIPN	XREGTF		;NO SYMBOL, PRINT NUMERICALLY.
	TTOI	"%		;INDICATE IS REG. UNLESS TOLD NO NEED TO.

XNUMTY:	ANDI	B,-1
	MOVEI	C,DECP
	TLNN	SF,DDECM	;IF DECIMAL, CALL DECP,
	MOVEI	C,OCTP
	PUSHJ	P,(C)		;CALL PRINT RTN.
	TLNE	SF,DDECM	;IN DECIMAL MODE, PRINT ".".
	TTOI	".
	JRST	UUOXIT

XASCTY:	CAILE	B,377		;1 CHAR?
	JRST	XASCT1		;NO, 2.
	TTOI	"'		;1.
	TTOI	(B)		;PRINT IT.
	JRST	UUOXIT
XASCT1:	TTOI	""		;2 CHARS.
	TTOI	(B)		;PRINT 1ST (LOW) CHAR.
	LSH	B,-10
	JRST	XASCT1-2

XREGTF:	0		;IF #0, OK TO OMIT % WHEN PRINTING REG. VAL.
XSYMTA:	0
;PRINT AN ADDRESS SYMBOLICALLY:
XADRTY:	SETOM	XSYMTA		;INDICATE ADRTYP.
	JRST	.+2

;PRINT NUMBER IN CURRENT MODE.
XSYMTY:	SETZM	XSYMTA
	MOVE	B,(A)		;WORD TO PRINT.
45N	TRZ	B,600000
	TLNE	B,REGBIT	;IF REGISTER NUM, SPECIAL HANDLING
	JRST	XREGTY
	SKIPE	XSYMTA		;IF NOT PRINTING ADDRESS TO OPEN,
	JRST	XSYMT3
	TLNE	SF,DNUMM	;CHECK FOR NUMERIC AND ASCII MODES.
	JRST	XNUMTY
	TLNE	SF,DASCM
	JRST	XASCTY
XSYMT3:	TLNN	SF,DSYMM	;IF NOT IN SYMBOLIC MODE,
	JRST	XNUMTY		;PRINT NUMERICALLY.
	ANDI	B,-1
	PUSH	P,DO
	PUSH	P,D		;NAME OF BEST SYMBOL SO FAR.
	PUSH	P,SF		;VALUE OF BEST SYMBOL SO FAR.
	SETZ	D,		;NO SYMBOL FOUND.
	SETO	SF,		;BEST SYMBOL'S VALUE IS -1.
	HRRZ	C,SYMEND
XSYMT0:	SKIPL	DO,1(C)		;ONLY NON-.5KILLED NORMAL SYMBOLS O.K.
	TLNE	DO,-1
	JRST	XSYMT1
	CAIG	DO,(B)		;ACCEPTABLE ONLY IF <= NUM. TO BE PRINTED.
	CAIL	SF,(DO)		;CLOSER THAN BEST SO FAR?
	JRST	XSYMT1
	MOVE	D,(C)		;YES, REPLACE BEST SO FAR'S NAME, VALUE.
	MOVEI	SF,(DO)
XSYMT1:	SUBI	C,2		;SEARCH TABLE BACKWARDS TO GET USER
	CAIL	C,SYMDRG	;SYMBOLS BEFORE PREDEFINED ONES.
	JRST	XSYMT0
	JUMPE	D,XSYMT2	;IF NO SUITABLE SYMBOL, PRINT NUMERICALLY.
	SUBM	B,SF		;SF HAS OFFSET OF VALUE FROM SYMBOL.
	CAIL	SF,200		;TOO FAR AWAY => PRINT NUMERICALLY.
	 JRST	XSYMT2
	MOVEI	B,(SF)		;ELSE THE # TO PRINT IS THE OFFSET.
	6TYPE	D
	JUMPE	B,XSYMT4	;IFF OFFSET, --
	TTOI	"+
XSYMT2:	TLO	B,200000	;NO SYMBOL- MAKE SURE TYPE ADDR. EVEN IF 0.
XSYMT4:	POP	P,SF
	POP	P,D
	POP	P,DO
	JUMPE	B,UUOXIT
	JRST	XNUMTY		;PRINT OFFSET IF ANY.

;GET NEXT INPUT CHAR. OUT OF LINE BUFER.
;IF BUFFER EMPTY, READ+ECHO UNTIL BREAK CHAR.
DGCHR1:	PUSHJ	P,DGLIN		;READ & ECHO LINE.
DGCHR:	TLZE	SF,D1CHAR	;IF SET, REREAD CHAR. IN T0.
	RETURN
	SETZM	DGLCQF
DGCHR0:	SKIPE	FILINF		;IF :XFILING,
	JRST	DGCHRF		;READ FROM UTIC.
	SOSGE	DGLCNT		;COUNT CHARS. IN BUFFER.
	JRST	DGCHR1		;IF NONE LEFT, GET NEW LINE.
	ILDB	T0,DGLPTR	;GET NEXT CHAR.
DGCHR2:	CAIN	T0,^Q		;IF CHAR IS ^Q,
	SKIPE	DGLCQF		;NOTQQUOTED BY PREV. ^Q,
	RETURN
	SETOM	DGLCQF		;INDICATE NEXT CHAR IS QUOTED,
	JRST	DGCHR0		;READ IT.

DGCHCS:
DGCHRF:	.IOT	UTIC,T0
	MOVEI	T0,(T0)
	CAIN T0,^L
	JRST	DGCHRF		;IGNORE FORM FEEDS
	CAIN	T0,^C		;IF EOF, GO BACK TO TTY.
	JRST	DGCHCC
	TTOI	(T0)		;ECHO.
	CAIE	T0,^J
	JRST	.+3
	SKIPE	DGCHRC		;FLUSH LF'S AFTER CR'S IN FILES.
	JRST	DGCHRF
	SETZM	DGCHRC
	CAIN	T0,^M
	SETOM	DGCHRC		;INDICATE HAD CR AS LAST CHAR.
	SKIPE	DGLCQF		;IF CHAR NOT ^Q-QUOTED,
	JRST	DGCHR2
IRPC CHAR,,BEWVS
	CAIN	T0,^CHAR	;CHECK FOR IO CTL CHARS
	JRST	DGCHC!CHAR
TERMIN
	JRST	DGCHR2

DGCHCB:	CALL	DGLNCB		;OPEN LPT.
	JRST	DGCHCS
DGCHCE:	CALL	DGLNCE		;END OUTPUT TO LPT.
	JRST	DGCHCS
DGCHCV:	SETOM	TYOFLG		;TURN ON TTY OUTPUT.
	JRST	DGCHCS
DGCHCW:	SETZM	TYOFLG		;TURN IT OFF.
	CALL	TRESET
	JRST	DGCHCS
DGCHCC:	.CLOSE	UTIC,		;ON EOF, CLOSE FILE,
	SETZM	FILINF
	JRST	DGCHR		;AND GO BACK TO TTY.

ETODON:
POP1J:	SUB	P,[1,,1]
	RETURN
;READ FROM TTY UP TILL ACTIVATION NECESSARY,
;PROCESSING RUBOUTS UNTIL THEN.
;WHEN DONE, RETURN WITH DGLCNT=NUM CHARS,
;DGLPTR=B.P. TO CHARS.
DGLIN:	PUSH	P,T1
	SETZM	DGLRCT
	MOVE	T1,[440700,,DGLBUF]	;INITIAL B.P.
	MOVEM	T1,DGLPTR	;USED TO STORE CHARS.
	MOVE	T1,DGLINF
	MOVEM	T1,DGLINS
DGLRB0:	SETZM	DGLCNT		;RE-INIT. AFTER RUBOUT, THEN RE-READ.
	SETZM	DGLNQC
	SETZM	DGLCQF		;1ST CHAR NOT ^Q'D.
	TLZ	SF,DSEMFL
	SETZM	DGLALF
	.CALL	TTYM1
	.VALUE

DGLIN1:	SETZM	DGLCQF		;NORMALLY, CHAR NOT ^Q-QUOTED.
DGLIN0:	SKIPN	DGLRCT		;IF CHARS LEFT BEFORE RUBOUT,
	JRST	DGLIN2
	ILDB	T0,DGLRBP	;RE-READ THEM.
	SOSG	DGLRCT		;IF THE LAST CHAR LEFT
	SKIPE	DGLCQF		;IS AN UN-^Q-QUOTED ^Q,
	JRST	DGLIN3
	CAIE	T0,^Q		;IT HAD QUOTED THE CHAR RUBBED OUT,
	JRST	DGLIN3
	TTOI	^Q		;SO RUB OUT THE ^Q, TOO.

DGLIN2:	TLNE	SF,DSEMFL	;IF AFTER A ';',
	.CALL	TTYMA		;ACTIVATE ON EACH CHARACTER.
	JFCL
	.IOT	TYIC,T0		;ELSE, READ NEW CHAR.
	Upper t0

;NOW DECIDE WHAT TO DO WITH THE CHAR. JUST READ.
DGLIN3:	SKIPE	DGLCQF		;UNLESS CHAR WAS ^Q-QUOTED,
	JRST	DGLIT5
	CAIN	T0,^Q		;PROCESS ^Q,
	JRST	DGLCTQ
	CAIN	T0,177		;RUBOUT SPECIALLY.
	JRST	DGLRUB
DGLIT5:	SKIPE	DGLNQC		;NEXT THREE TESTED EVEN IF ^Q-QUOTED:
	JRST	DGLQTD		;IF QUOTED BY ' OR ".
	SKIPE	DGLALF
	JRST	DGLAL1		;IF AFFECTED BY PREV. ALTMODE.
	TLNE	SF,DSEMFL
	JRST	DGLSM1		;IF AFTER UNQUOTED ";".
	CAILE	T0,"Z
	JRST	DGLIT6
	SKIPN	DGLCQF
	CAIL	T0,"A		;ELSE DON'T BOTHER TESTING
	JRST	DGLREG		;ALPHABETIC CHARS, ^Q-QUOTED CHARS.
DGLIT6:	SKIPE	DGLINF
	JRST	DGLIT2		;IN LINE MODE ^M IS ONLY BREAK CHAR.
;NORMAL BREAK CHARS:
	CAIE	T0,"[
	CAIN	T0,"]
	JRST	DGLBK
	CAIN	T0,^]
	JRST	DGLBK
IRP C1,,[^L,^N,"/,"=,"_]C2,,[^\,^P,^I,^J,"^]
	CAIE	T0,C1
	CAIN	T0,C2
	JRST	DGLBK
TERMIN
	CAIN	T0,"'
	JRST	DGLQUO		;QUOTES NEXT CHAR.
	CAIN	T0,""
	JRST	DGL2Q		;QUOTES 2 CHARS.
	CAIN	T0,":
	JRST	DGLCOL		;ENTERS LINE MODE TO READ COMMAND.
	CAMN	T0,SEMICL
	JRST	DGLSEM		;READS NUMBER, THEN LETTER.
	CAMN	T0,ALTMOD
	JRST	DGLALT		;QUOTES ALL CHARS EXCEPT ALTMODE.
DGLIT2:	CAIN	T0,^M
	JRST	DGLBK

;THESE CHARS ARE TESTED FOR IN ALL STATES
;EXCEPT WHEN ^Q-QUOTED.
DGLIT3:	SKIPN	DGLCQF
	JRST	DGLIT4		;IGNORE IF ^Q QUOTED.
	CAIN	T0,^S
	JRST	DGLCTS		;^S TURNS OUTPUT BACK ON WHEN READ.
	CAIE	T0,^B
	CAIN	T0,^E
	JRST	DGLIN1		;^B, ^E, ^W, ^V SIGNIF. ONLY AT
	CAIE	T0,^V		;INTERRUPT LEVEL,
	CAIN	T0,^W		;IGNORED HERE.
	JRST	DGLIN1
DGLIT4:	TLNE	SF,DSEMFL	;AFTER A ";", ALL NORMAL CHARS
	JRST	DGLBK		;ARE BREAK CHARS.
	SETZM	DGLALF
	JRST	DGLREG
;ROUTINES TO HANDLE VARIOUS TYPES OF CHARS.

DGL2Q:	AOS	DGLNQC		;INSERT, QUOTE NEXT 2 CHARS.
DGLQUO:	AOSA	DGLNQC		;QUOTE ONLY 1 CHAR.
DGLQTD:	SOS	DGLNQC		;THIS CHAR IS QUOTED.
DGLREG:	SETZM	DGLCQF		;TURN OFF AFTER OTHER THAN ^Q.
	SKIPA
DGLCTQ:	SETOM	DGLCQF		;^Q - INDICATE NEXT CHAR ^Q-QUOTED.
	AOS	DGLCNT
	IDPB	T0,DGLPTR
	JRST	DGLIN0

; ^S - TURN ON TYPOUT, PASS IT BY.
DGLCTS:	SETOM	TYOFLG
	JRST	DGLIN1

;BREAK CHAR - INSERT AND EXIT.
DGLBK:	AOS	DGLCNT
	IDPB	T0,DGLPTR
	MOVE	T1,[440700,,DGLBUF]
	MOVEM	T1,DGLPTR	;SET UP PTR FOR UNPACKING.
	SETZM	DGLINF
DGLINX:	POP	P,T1
	RETURN

; ";" - ALL EXCEPT DIGITS, " ", "." ARE BREAK CHARS.
DGLSEM:	TLO	SF,DSEMFL
	JRST	DGLREG		;INSERT THE ";".


DGLSM1:	CAIN	T0,"-
	JRST	DGLREG
	CAIE	T0," 
	CAIN	T0,".
	JRST	DGLREG
	CAIL	T0,"0
	CAILE	T0,"9
	JRST	DGLIT3	;NON-DIGIT, IGNORE OR BREAK.
	JRST	DGLREG

DGLCOL:	SETOM	DGLINF		;":" - READ UNTIL CR.
	JRST	DGLREG
;COME HERE IF CHAR AFFECTED BY PREVIOUS ALTMODE.
DGLAL1:	CAIN	T0,"-
	JRST	DGLALT		;- SIGN DOESN'T END TYPEOUT MODE CMD.
	CAME	T0,ALTMOD
	JRST	DGLIT3
DGLALT:	SETOM	DGLALF
	JRST	DGLREG

;COME HERE TO HANDLE RUBOUT.
DGLRUB:	SOSGE	T1,DGLCNT	;NUM. CHARS NOT RUBBED.
	JRST	DERR		;IF NO CHAR TO RUB.
	MOVEM	T1,DGLRCT	;RE-READ THOSE CHARS.
	LDB	T0,DGLPTR
;	TTOI	(T0)		;ECHO RUBBED CHAR.	;? Works without.
	MOVE	T1,[440700,,DGLBUF]
	MOVEM	T1,DGLRBP	;PTR FOR RE-READING.
	MOVEM	T1,DGLPTR
	MOVE	T1,DGLINS	;RESTORE INITIAL DGLINF.
	MOVEM	T1,DGLINF
	JRST	DGLRB0

DGLNQC:	0		;NUM. OF NEXT CHARS TO QUOTE.
DGLRBP:	0		;B.P. FOR RE-READING AFTER RUBOUT.
DGLRCT:	0		;NUM. CHARS TO RE-READ.
DGLCNT:	0		;NUM. CHARS READ.
DGLPTR:	0		;B.P. FOR STORING CHARS READ.
DGLINF:	0		;IF SET, READ UNTIL CR.
DGLINS:	0		;SAVES INITIAL VALUE OF DGLINF.
DGLALF:	0		;SET AFTER ALTMODE.
DGCHRC:	0		;NONZERO IF FILINF AND LAST CHAR WAS CR.
DGLCQF:	0		;CONTROL Q FLAG

DGLBUF:	BLOCK	60	;RUBOUT PROCESSING AND I-O BUFFER.
;DDT ENTRY

DEFINE $NB N
	SIXBIT /$!N!B>>/
TERMIN

DDT:	SETZM	DDONXT		; ;N STOPS AFTER THIS INSN.
	PUSHJ	P,MERRV		;TURN ON TTY OUTPUT.
	MOVEM	P,DDTPDP	;SAVE P FOR RESTORATION ON ERROR.
	PUSHJ P,GETREG
	MOVE DL,R7
	HRRM DL,%PC
	HRRZ	DL,OPC
	LSH	DL,1
	SKIPL	DL
	HRRM	DL,%OPC		;SET UNLESS HAVE JUST LEFT DDT.
	HRLZ	SF,%TMODE
	SKIPE	DINITF
	JRST	DDT3		;DON'T PRINT INSN ON STARTING PDP11.
	HRRZ	DL,R7
	MOVEI T5,TF		;CHECK FOR TRACE TRAP
	TDNE T5,PS
	JRST [	ttoa [asciz /Trace>> /]
		ANDCAM T5,PS	;CLEAR TRACE FLAG
		JRST DDT1A]
	MOVEI T1,-2(DL)		;TYPE OUT BREAK POINT NAME
	MOVE DL,T1		;BACKUP, POINTS TO BREAK POINT
	MOVEM DL,R7
	HRRM DL,%PC
	LSH T1,-1
	JSP D,SRCBPT		;SEARCH FOR THAT BREAK POINT
	6TYPE [	SIXBIT /BPT>>/
		REPEAT NBPTS,$NB \.RPCNT+1
	      ](T3)
DDT1A:	TLO	SF,NUMFND	;CAUSE . TO BE SET BY DARG.
	CALL	DPINSN		;PRINT DL AND INSN THERE.
	HRRM	DLEN,%IL	;SAVE LENGTH, FOR ;N'S SAKE.
	HRROI	DO,(DO)		;DON'T ALLOW ACCIDENTAL CHANGES.
	TTOA	SPACES
DDT2:	SETZM	FILINF
	.CLOSE	UTIC,
DDT3:	SETZM	DINITF		;THAT FLAG SET 1ST TIME ONLY.
	.RESET	TYIC,
	SETOM	DGVLVL
	SETOM	QUITF
	JRST	DLOOP

;PASS SPACES.

GPASST:	GETCHR
PASSPS:	CAIN	T0," 
	JRST	GPASST
	RETURN

SPACES:	ASCIZ/   /
;COME HERE FOR NEXT COMMAND.
DLOOP:
Haln[	SKIPE NOMATC
	JRST [	TTOA [ASCIZ /10-11 LOSSES /]
		MOVE B,NOMATC
		PUSHJ P,FOCTP
		CLEARM NOMATC
		JRST .+1]
] ;end Haln
	TLZ	SF,DMODES	;RESTORE TEMPORARY MODES.
	TLO	SF,@%TMODE
DLOOP1:	MOVE	T6,DL
	TLO	T6,.5KBIT
	MOVEM	T6,%Q		;SET %Q FROM DL, .5KILLED.
	HRRM	DLEN,%L		;SAVE LENGTH IN CASE ERROR.
DLOOP2:	CALL	DGVAL		;TRY TO GET A NUMERIC VALUE.
	SKIPN	DGVALP		;IF HAD ARG,
	JRST	DLOOP3
	SETZM	S%OLFL		;STOP UPDATING LENGTH OF WHAT'S OPEN
	TLO	SF,NUMFND	;TELL COMMAND ABOUT ARG
	SKIPA	DL,T2		;SET %Q TO ARG.
DLOOP3:	HRRZ	DLEN,%L		;ELSE RESTORE LENGTH.
	JSP	T1,DDECOD	;JUMP ACCORDING TO FIRST CHAR. AFTER NUM.
	"/,,CSLASH
	"[,,CLB
	"],,CRB
	^I,,CTAB
	^J,,CLF
	^K,,CCTLK
	^M,,CCR
	"^,,CUPAR
	"=,,CEQ
	";,,CSEM
	",,CALT
	"_,,CBACK
	">,,CGT
	":,,CCOL
	^N,,CCN
	^P,,CSP
	^L,,CFORMF
	" ,,DLOOP1
	DERR		;IF NOT FOUND.

;LOOK IN TABLE AT (T1) FOR ENTRY WITH LH=(T0),
;THEN JRST TO @RH OF ENTRY.
DDECOD:	HLRZ	T5,(T1)		;LH, FOR COMPARISON.
	HRRZ	T6,(T1)		;RH FOR JUMP.
	CAIN	T0,(T5)		;FOUND ENTRY?
	JRST	(T6)		;YES, GO THERE.
	JUMPE	T5,(T6)		;IF LH IS 0, GO THERE ANYWAY(END OF TABLE).
	AOJA	T1,DDECOD	;TRY NEXT ENTRY.
;READ A CHAR, PASS SPACES, READ A VALUE.
DGVGCH:	GETCHR

;PASS SPACES AND READ IN A VALUE.
DGVPSP:	PUSHJ	P,PASSPS

;READ IN A VALUE WHOSE 1ST CHAR HAS BEEN READ ALREADY.
DGV1CH:	TLO	SF,D1CHAR

;GET A VALUE, AND PUT IT IN T2. SET NUMFND IF VALUE AVAILABLE.
;T0 CONTAINS CHAR. FOLLOWING VALUE, OR 1ST CHAR, AT EXIT.
;SETS T1 .
DGVAL:	SETZ	T1,		;START ON LEVEL 0.
	AOSE	DGVLVL		;IF OUTERMOST CALL TO DGVAL,
	JRST	.+4
	MOVE	T5,[004400,,DRNEXT]
	MOVEM	T5,DRNEXT	;SET UP B.P. FOR EXTRA WDS,
	MOVEI	DLEN,2		;INITIALIZE LENGTH.

	PUSH	P,DGVRGP	
	SETZM	DGVRGP		;AS YET, THIS VALUE ISN'T A REGISTER NUM.
	PUSH	P,[DGVXIT]
DGVAL0:	HLRZ	T1,T1		;PUT LEVEL IN RH.
	SETZM	DGVALP
	PUSHJ	P,DGVCAL	;TRY TO GET VALUE ON NEXT LEVEL.
	SKIPN	DGVALP		;IF CAN'T, RETURN NO VALUE.
	RETURN
DGVAL1:	HRRZ	T5,DGVT2(T1)	;ADDR. OF OP TABLE FOR THIS LEVEL.
	HRRZ	T6,(T5)		;SEARCH FOR ENTRY WITH RH=NEXT CHAR.
	CAIN	T0,(T6)
	JRST	DGVAL2		;FOUND.
	SKIPE	(T5)		;0 MARKS END OF TABLE.
	AOJA	T5,.-4		;TRY NEXT ENTRY.
	RETURN

DGVAL2:	HLL	T2,(T5)		;SAVE OPERATION TYPE NO.
	PUSH	P,T2		;AND LAST VALUE.
	PUSHJ	P,DGVCAL	;TRY TO GET VALUE ON NEXT LEVEL.
	REST	T5		;GET 1ST ARG, OP. NUM.
	HLRZ	T6,T5		;GET OP. NUM.
	SKIPE	DGVALP		;IF NO 2ND ARG,
	JRST	DGVAL3
	JUMPG	T6,DERR		;ERROR UNLESS OP. IS " ",
	HRRZ	T2,T5		;IN WHICH CASE RETURN 1ST ARG.
	RETURN
DGVAL3:	HRREI	T2,(T2)		;GOT 2ND ARG - EXTEND SIGNS OF ARGS,
	HRREI	T5,(T5)
	XCT	DGVT3(T6)	;PERFORM OPERATION.
	JRST	DGVAL1		;LOOK FOR ANOTHER OP.

DGVCAL:	PUSH	P,T1		;SAVE LEVEL NO.
	MOVE	T1,DGVT1(T1)	;GET NEXT LEVEL NO., ADDR. TO CALL.
	PUSHJ	P,(T1)		;GET VALUE ON NEXT LEVEL.
	POP	P,T1		;RESTORE LEVEL NO.
	RETURN
DGVT1:	1,,DGVAL0	;FROM LEVEL 0, CALL SELF ON LEVEL 1.
	2,,DGVAL0
	3,,DGVAL0
	4,,DGTRM
	DGVAL		;DGTRM CALLS BACK ON LEVEL 3.

DGVT2:	DGVL0T		;LEVEL 0 OP. TABLE.
	DGVL1T		;LEVEL 1 OP. TABLE.
	DGVL2T
	DGVL3T
	DGVL4T

DGVL0T:	0,," 	;SPACE - LOW PRIOR. ADDITION.
	0
DGVL1T:	5,,"&	;LOGICAL OPS. LOWEST IN PRIOR.
	6,,"\
	8,,"#
	0
DGVL2T:	3,,"+
	4,,"-
	0
DGVL3T:	1,,"*	;MULT., DIV. SEPARATE TERMS.
	2,,"!
	0
DGVL4T:	7,,",	;ANGLE-BRACKETS CONTAIN ORDINARY EXPRESSIONS
	0	;SEPARATED BY COMMAS.

DGVT3:	ADDM	T5,T2		;SPACE - MUST HAVE CODE 0.
	IMULI	T2,(T5)		;1ST INSNS OF OPERATIONS.
	IDIVM	T5,T2
	ADD	T2,T5
	SUBM	T5,T2
	ANDM	T5,T2
	IORM	T5,T2
	PUSHJ	P,DGVCOM
	XORM	T5,T2

DGVCOM:	SKIPE	DGVLVL		;IF WITHIN INNER BRACKETS,
	JRST	DGVCO2		;THROW AWAY EXTRA WORD.
	CAILE	DLEN,10.	;CAN'T HAVE MORE THAN 5 EXTRA WDS.
	ERROR	[ASCIZ/> 6 WORDS/]
	IDPB	T2,DRNEXT	;2ND VALUE IS EXTRA WORD.
	MOVE	T2,T5
	AOJ	DLEN,
	AOJA	DLEN,CPOPJ

DGVCO2:	MOVE	T2,T5
	RETURN

DGVXIT:	SOS	DGVLVL
	HRLI	T2,.5KBIT	;SINCE MUST .5KILL %P.
	SKIPE	DGVRGP		;IF THIS IS TO BE A REGISTER NUM.,
	TLO	T2,REGBIT	;SAY SO IN THE VALUE.
	MOVEM	T2,%P
	POP	P,DGVRGP
	POPJ	P,		;NOT AN OP. FOR THIS LEVEL, RETURN.
;GET A TERM, INTO T2. CLEAR NUMFND IF CAN'T GET ONE, SET IF CAN.
DGTRM:	PUSHJ	P,DGNUM		;TRY TO GET NUMBER.
	SKIPE	DGVALP		;IF FOUND, RETURN IT.
	RETURN
	PUSHJ	P,DGSYM		;OTHERWISE, TRY TO GET SYMBOL.
	JUMPE	T2,DGTRM1	;IF NO SYMBOL, TRY OTHER THINGS.
	PUSHJ	P,DLKSYM	;LOOK UP SYMBOL.
	JUMPE	T5,[ERROR [ASCIZ/U/]]	;UNDEFINED.
	LDB	T2,[220400+T5,,1]
	JRST	@.+1(T2)	;INDEX ON SYMBOL TYPE.

	DGTRM2		;ORDINARY SYMBOL.
	DGVREG		;REGISTER SYMBOL.
	DR2AR		;2-OP INSN.
	DR2AR		;1-OP INSN.
	DRJSR		;JSR.
	DRJSR		;RTS.
	DRDBR		;BRANCH INSN.
	DREMT
	DRSFL
	DGTSER
	[ERROR [ASCIZ/U/]]
	DRSPEC		;SOB, MARK, SPL.
	DRASH		;MUL, DIV, ASH, ASHC.
	REPEAT 3,DGTSER

;JRST THRU STE TO HERE TO GET VALUE OF REGISTER SYMBOL.
DGVREG:	SETOM	DGVRGP

;JRST HERE FOR NORMMAL SYMBOL.
DGTRM2:	AOS	DGVALP
	HRRE	T2,1(T5)
	RETURN

DGTSER:	CRF
	6TYPE	(T5)
	MOVE	T5,1(T5)
	MOVEM	T5,QA
	ERROR	[ASCIZ/ HAS IMPOSSIBLE STE! - A/]
;COME HERE TO CHECK FOR UNARY +,-.
DGTRM1:	CAIE	T0,"-		;FOR MINUS SIGN,
	JRST	DGTRM3
	PUSHJ	P,DGTRM		;GET A TERM AND NEGATE IT.
	MOVN	T2,T2
	RETURN
DGTRM3:	CAIN	T0,"+		;FOR + SIGN, START OVER.
	JRST	DGTRM
	CAIE	T0,"'		;'''' MEANS ASCII CHAR INPUT.
	JRST	DGTRM4
	GETCHR
	MOVEI	T2,(T0)
DGTRM6:	GETCHR			;GET CHAR AFTER TERM.
DGVRET:	AOS	DGVALP
	RETURN

DGTRM4:	CAIE	T0,""		;2 ASCII CHARS INPUT.
	JRST	DGTRM5
	GETCHR
	MOVEI	T2,(T0)
	GETCHR
	LSH	T0,10		;2ND CCHAR INTO HIGH BYTE
	ADD	T2,T0
	JRST	DGTRM6
DGTRM5:	CAIE	T0,"<		;OPEN BRACKET?
	POPJ	P,		;NO, R ETURN NO TERM.
	PUSHJ	P,DGVAL0	;TRY TO GET VALUE.
	CAIE	T0,">		;IF NOT CLOSED BY >, ERROR.
	ERROR	[ASCIZ/UNBAL/]
	GETCHR			;PASS BY >.
	RETURN

;CONVERT ARG TO RANGE OF ADDRS AND NUMBER.
;DEFAULTS ARE RANGE (AOBJN PTR IN T0): 0 - %CORE, NUMBER (IN T2): 0.
;IF 1 WD. IN ARG, IT SPECIFIES NUMBER.
;IF 2, THEY ARE RANGE,
;IF 3, 1ST 2 ARE RANGE, 3RD IS NUMBER.
DGRAN:	SETZB	T0,T2		;PUT IN DEFAULTS.
	PUSHJ	P,SETSIZ
	HRRZ	T1,%CORE
	MOVEI	T1,-2*<BPTASZ+1>(T1)	;DON'T CLOBBER BREAK POINT AREA
	TLNN	SF,NUMFND
	JRST	DGRAN1		;USE THEM IF NO ARG.
	CAIN	DLEN,2
	JRST	DGRAN2		;1 ARG ==> SET LOCATIONS TO IT.
	MOVEI	T0,(DL)		;>= 2 ARGS ==> FIRST 2 ARE RANGE.
	HRRZ	T1,DRNEXT+1
	CAIN	DLEN,6		;3RD ARG IS NUMBER TO STORE, IF PRESENT.
	HRRZ	T2,DRNEXT+2
	JRST	DGRAN1

DGRAN2:	MOVEI	T2,(DL)
DGRAN1:	ANDI	T0,MAXBYT-1
	LSH	T0,-1		;CHANGE ADDRS TO WORD NOS.
	LSH	T1,-1
	SUBM	T0,T1
	HRLI	T0,-1(T1)	;AOBJN PTR -> BLOCK TO STORE IN.
	TLO	T0,-MAXCOR
	ANDI	T2,177777
	RETURN

;READ A NUMBER INTO T2, PUT NEXT CHAR INTO T0.
;AT EXIT, NUMFND INDICATES NUMBER WAS THERE.
DGNUM:	SETZB	T2,DGVALP
	SETZ	T3,		;T2 ACCUMULATES OCTAL; T3, DECIMAL.
DGNUM1:	GETCHR
	SKIPN	DGLCQF		;^Q-QTD CHARS NOT DIGITS.
	CAIGE	T0,"0		;A DIGIT?
	JRST	DGNUM2		;IF NOT, CHECK FOR ".".
	CAILE	T0,"9
	JRST	DGNUM2
	AOS	DGVALP		;FOUND A NUMBER.
	LSH	T2,3		;PUT THIS DIGIT IN.
	ADDI	T2,-"0(T0)
	IMULI	T3,10.		;PUT IT IN DECIMAL NUM, TOO.
	ADDI	T3,-"0(T0)
	JRST	DGNUM1		;TRY FOR ANOTHER DIGIT.

DGNUM2:	SKIPE	DGVALP		;IF HAD A NUMBER,
	CAIE	T0,".		;FOLLOWED BY ".",
	JRST	DGNUM3
	MOVEI	T2,(T3)		;USE DEC NUM, NOT OCT NUM.
	GETCHR
DGNUM3:	HRREI	T2,(T2)
	RETURN

;OPEN REGISTER WHOSE ADDR. IS IN DL.
DARG:	MOVE	DO,DL
	TLZ	DO,.5KBIT	;INSURE DO POSITIVE SINCE HAVE OPEN LOC.
	MOVE	T6,DO
	TLO	T6,.5KBIT
	MOVEM	T6,DOPEN	;SET SYMBOL %.  .
	TLZE	SF,NUMFND	;IF ADDR WAS ARG,
	MOVEM	T6,DPNT		;ALSO SET SYMBOL .  .
IFN 0,[
	TLNE	SF,DDSKM
	JRST	DARGD		;LOCATION IS IN DISK
]
	PUSHJ	P,DCLOS0	;T3 _ CORE ADDR OF LOC., -PDP11.
	MOVEI	DLEN,2		;LENGTH OF OBJECT TENTATIVELY 2.
	TLNE DO,REGBIT
	JRST [	MOVEI T5,(T3)
		CAILE T5,10	;CHECK BOUND
		ERROR [ASCIZ /???/]
		MOVE DL,R0(T3)
		POPJ P,]
	11GET DL,(T3)		;GET WORD FROM OPEN REG
	TLZ	SF,BYTOPN+DSKOPN
	TRNN	DO,1		;IF ADDR ODD,
	TLNE	SF,DBYTM	;OR IN BYTE MODE,
	TLOA	SF,BYTOPN	;OPEN AS A BYTE,
	RETURN
	TRNE	DO,1
	LSH	DL,-10
	ANDI	DL,377		;RETURN ONLY THE DESIRED BYTE.
	RETURN

;COME HERE ON ERROR.
DERR:	CALL OSNAMR	;RESTORE OLD SNAME IF DESIRED.
	SETOM	DGVLVL		;IN CASE ERRED WITHIN DGVAL.
	CALL	MERRV		;TURN ON TTY OUTPUT.
	.CLOSE	UTIC,
	SETZM	FILINF
	.CLOSE	LOADCH,
	TTOA	[ASCIZ/ ?  /]
	MOVE	P,DDTPDP	;RESET STACK.
	.RESET	TYIC,
	SETZM	XREGTF
	SETZM	DGLINF
	SETZM	DGLCNT
	HRRZ	DL,%Q		;DON'T CLOBBER DL WITH ERROR.
	HRRZ	DLEN,%L
	TLZ	SF,D1CHAR+NUMFND+CSSFLG+DSEMFL
	JRST	DLOOP1
;READ A FILESPEC, PUT NAMES IN OPEN BLOCK <- A.
DGFIL:	SETZM	FILFLG
	SETZ	T3,
	SETOM	DGLINF		;INDICATE READING FILENAME.
DGFIL0:	SETZ	T2,
	MOVE	D,[440600,,T2]
DGFIL1:	GETCHR
	SKIPE	DGLCQF		;^Q-QUOTED CHARS TREATED AS ORDINARY.
	JRST	DGFIL2
	JSP	T1,DDECOD
	";,,DGFILS
	":,,DGFILC
	" ,,DGFILN
	^M,,DGFILN
	",,,DGFILN
	  ,,DGFIL2		;ORDINARY CHAR.

DGFIL2:	MOVEI	T0,-40(T0)	;CONV. TO SIXBIT.
	TRNN	D,1		;UNLESS HAVE OVERFLOWED INTO T3,
	IDPB	T0,D		;STORE NEXT CHAR.
	JRST	DGFIL1

;COME HERE WHEN SPACE OR CR TERMINATES NAME.
DGFILN:	JUMPE	T2,DGFILM	;DO NOTHING IF NO NAME.
	XCT	DGFILT(T3)	;STORE NAME PROPERLY.
	AOJ	T3,		;SUCCESSIVE NAMES ARE FN1, FN2, DEV, SNAME.
DGFILX:	SETOM	FILFLG
DGFILM:	CAIE	T0,^M
	CAIN	T0,",		;^M AND ", TERMINATE FILSPC.
	SKIPA
	JRST	DGFIL0		;AFTER SPACE, TRY AGAIN.
	SETZM	DGLINF
OSNAMR:	.SUSET [.RSNAM,,NSNAM] ;SAVE DEFAULT SNAME OR SPEC'D.
	.SUSET [.SSNAM,,OSNAM] ;IF NOT SPEC'D, RESTORE CURRENT.
	SETZM OSNAM	;NO LONGER NEED TO RESTORE.
	RET

DGFILT:	MOVEM	T2,1(A)		;STORE FN1.
	MOVEM	T2,2(A)		;FN2.
	HLRM	T2,(A)		;STORE DEV.
DGFILS:	CALL [	.SUSET	[.SSNAM,,T2]	;STORE SNAME.(DOES NOTHING IF T2 ZERO)
		SETZM OSNAM	;DON'T RESTORE SNAME LATER.
		RET]
	JRST	DGFILX

DGFILC:	JUMPE	T2,DGFILX
	HLRM	T2,(A)		;COLON: ALWAYS STORE AS DEVICE.
	JRST	DGFILX

FILFLG:	0	;SETOM'ED IF A "FILSPEC" ACTUALLY TYPED
	;(DESIGNED SO CAN BE FAKED OUT BY : OR ; WITHOUT NAME)
OSNAM:	0	;NONZERO => RESTORE SNAME ON ERROR OR RETURN FROM DGFIL.
NSNAM:	0	;SNAME BEFORE RETURN FROM DGFIL AND RESTORE OSNAM.
;READ IN A SYMBOL, IF POSSIBLE.
;T2 GETS NAME IN SIXBIT IF SYMBOL, 0 OTHERWISE.
;ASSUMES 1ST CHAR IN T0. LEAVES FOLLOWING CHAR THERE.
DGSYM:	TDZA	T2,T2		;NO CHARS YET. DON'T READ 1ST CHAR.
	GETCHR
	SKIPE	DGLCQF		;IF ^Q-QUOTED,
	MOVEI	T5,-40(T0)	;ALWAYS USE IT.
	SKIPN	DGLCQF		;ELSE USE ONLY SQUOZE CHARS.
	CALL	D7TO6
DGSYM1:	TLNE	T2,770000	;IF NOT FULL,
	JRST	DGSYM2
	LSH	T2,6		;PUT IN THIS CHAR(OR BLANK).
	ADDI	T2,(T5)
	JUMPE	T2,CPOPJ	;IF NO SYMBOL, RETURN.
	JUMPE	T5,DGSYM1	;IF NOT SYMBOL CHAR, LEFT-JUSTIFY.
DGSYM2:	JUMPN	T5,DGSYM+1	;KEEP READING CHARS PAST END OF SYMBOL.
	RETURN

;LOOK UP THE SYMBOL WHOSE SIXBIT IS IN T2.
;RETURNS IN T5 PTR TO STE (0 IF NONE).
DLKSYM:	MOVE	T6,SYMEND
	MOVNI	T5,2-SYMTAB(T6)	;2*NUMBER OF SYMBOLS.
DLKSY0:	LSH	T5,17.		;LH_ - NUM.SYMS.
	HRRI	T5,3(T6)	;RH _ LAST SYM + 3.
	MOVNI	C,1
	AOBJN	C,.+1
	JUMPE	C,DLKSKL	;JUMP IF THIS IS A KL-10.
	MOVSI	C,DLKSY1
	BLT	C,C		;PUT LOOP IN ACS 0-3.
	JRST	0		;NOW GO CALL THE LOOP IN THE ACS.  IT EXITS TO DLKSY2.

DLKSY1:	SUBI	T5,3		;MOVE TO PREV. STE.
	CAME	T2,(T5)		;IF NOT FOUND & MORE STE'S
	 AOBJN	T5,		;GO LOOK AT THEM.
	JRST	DLKSY2

DLKSKL:	subi t5,3		;On the KL, it is significantly faster (> 20%)
	came t2,(t5)		; -not- to do the search in the accumulators.
	 aobjn t5,dlkskl

DLKSY2:	CAME	T2,(T5)		;IF NOT FOUND, RETURN 0.
	 SETZ	T5,
	RETURN

;CONVERT AN ASCII CHAR TO SIXBIT, IF IT CAN GO IN A SYMBOL.
;IF IT CAN'T GO IN ONE, RETURN 0 (IN T5). ARG IN T0.
D7TO6:	SETZ	T5,
	CAILE	T0,"Z
	RETURN
	CAIL	T0,"A
	JRST	D7TO6X		;ALPHABETIC CHARS O.K.
	CAILE	T0,"9
	RETURN
	CAIGE	T0,"0
	CAIN	T0,".		;DIGITS AND ".", TOO.
	JRST	D7TO6X
	CAIL	T0,"&
	RETURN
	CAIL	T0,"$		;ALSO "%", "$".
D7TO6X:	MOVEI	T5,-40(T0)
	RETURN
;DEFINE THE FOLLOWING SYMBOL
CGT:	TLZ	SF,NUMFND
	CALL	GPASST
	PUSHJ	P,DGSYM		;TRY GETTING SYMBOL, ERROR IF NONE.
	JUMPE	T2,DERR
	MOVEI	T6,SYMDMP
	MOVNI	T5,2-SYMTAB(T6)	;SEARCH UNSETTABLES, SYMTAB THRU SYMDMP-2 .
	CALL	DLKSY0
	SKIPE	T5
	ERROR	[ASCIZ/UNSETTABLE SYMBOL/]	;IF FOUND THERE.
	CALL	DEFSYM		;GET OLD STE OR MAKE NEW ONE.
	CALL	PASSPS		;GET 1ST NONBLANK CHAR.
	TLZ	DL,.5KBIT
	CAIE	T0,^K
	TLOA	SF,D1CHAR	;IF NOT ^K, REREAD IT.
	TLO	DL,.5KBIT	;IF ^K, .5KILL THE SYMBOL.
	MOVEM	DL,1(T5)	;STORE VALUE, FLAGS.
	JRST	DLOOP

; ^K COMMAND - COMPLEMENT .5KILL BIT FOR FOLLOWING SYMBOL.
CCTLK:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM
	JUMPE	T2,DNOARG
	PUSHJ	P,DLKSYM
	JUMPE	T5,DLOOP	;IF UNDEFINED, NO-OP.
	MOVSI	T6,400000	;COMPLEMENT HALF-KILL FLAG.
	XORM	T6,1(T5)
	TLZ	SF,NUMFND
	TLO	SF,D1CHAR
	JRST	DLOOP

;COME HERE TO LOOK FOR OLD STE, MAKE NEW ONE & STORE NAME IF NOT FOUND.
;NAME TAKEN IN T2, STE ADDR RET. IN T5.
DEFSYM:	MOVE	T6,SYMEND	;SEARCH SETTABLE SYMBOLS,
	MOVNI	T5,2-SYMDMP(T6)	;SYMDMP AND UPWARD.
	CALL	DLKSY0
	JUMPN	T5,CPOPJ	;IF DEFINED, RETURN OLD STE.

;COME HERE IF UNDEFINED.
DEFSY0:	HRRZ	T5,SYMEND
	MOVEI	T5,2(T5)	;ADDR OF NEXT STE,
	TRNE	T5,1777		;IF OVERFLOW TO NEW PAGE
	JRST	DEFSY1
	PUSHJ	P,BLKGET	;ADD A PAGE
	(T5)
DEFSY1:	HRRZM	T5,SYMEND	;IT'S NOW LAST STE.
	MOVEM	T2,(T5)		;PUT IN NAME.
	RETURN

SYMNSP==6	;# PREDEF SETTABLE SYMS.
;DEFINE SYMBOL DURING LOADING.
DEFSY2:	SKIPN	CSLFLG		;IF NOT DOING ;L,
	JRST	DEFSYM		;MAYBE WAS DEFINED BEFORE THIS CMD.
REPEAT SYMNSP,[
	CAMN	T2,SYMDMP+2*.RPCNT
	JSP	T5,DEFSY3	;TEST FOR PREDEFINED SETTABLE SYM.
]	JRST	DEFSY0		;NOT PREDEF, MUST BE UNDEF.

DEFSY3:	MOVEI	T5,SYMDMP-DEFSY2-4(T5)
	RETURN			;T5 HAS ADDR OF PREDEF STE.
;READ IN A GENERALIZED OPERAND ADDRESS.
;PUT 6-BIT ADDRESS MODE IN T2.
;RETURN NEW VALUE OF %S OR %D IN T3 .
;IF INDEXED, RELATIVE OR IMMEDIATE, UPDATE DLEN, STORE EXTRA WORD.
DRADDR:	PUSHJ	P,PASSPS
	PUSH	P,DRINDP
	SETZM	DRINDP
	CAIE	T0,"@		;INDIRECT MODE?
	JRST	.+3
	AOS	DRINDP		;YES, REMEMBER IT AND PASS @ SIGN.
	GETCHR
	JSP	T1,DDECOD	;DECODE 1ST CHAR.
	"#,,DRIMM		;IMMEDIATE MODE.
	"-,,DRDEC		;AUTODECREMENT OR UNARY -.
	"(,,DRPAR		;REGISTER INDIRECT OR AUTOINCREMENT.
	DRADD			;REGISTER, RELATIVE OR INDEXED.

DRADD:	PUSHJ	P,DGV1CH	;GET ADDRESS, 1ST CHAR READ ALREADY.
	SKIPN	DGVALP		;IF NONE, BAD FORMAT
	JRST	DERR
DRADD0:	MOVE	T3,T2
	CAIN	T0,"(		;INDEXED?
	JRST	DRNDX		;YES.
	TLZE	T2,REGBIT	;ADDR. IS A REGISTER?
	JRST	DRREG		;YES.
	SUBI	T2,(DO)		;CALCULATE DISPLACEMENT.
	SUBI	T2,2(DLEN)
	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	MOVEI	T2,67		;RELATIVE ADDRESS, MODE 67.
DRXIT:	SKIPE	DRINDP		;IF READ "@",
	IORI	T2,10		;CHANGE MODE TO INDIRECT.
	TLO	T3,.5KBIT	;%S, %D SHOULD ALWAYS BE .5KILLED.
	POP	P,DRINDP
	RETURN

DRNDX:	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	PUSH	P,T3		;SET %D TO DISPL., NOT REG.
	PUSHJ	P,DRPAR1	;GET REGISTER NO.
	POP	P,T3
	ADDI	T2,60		;MODE 6N, N=REGISTER NUM.
	JRST	DRXIT

DRREG:	ANDI	T2,7		;REGISTER ADDRESS, MODE 0N, N=REGISTER NO.
	JRST	DRXIT
;IMMEDIATE MODE - COME HERE IF FIND #.
DRIMM:	PUSHJ	P,DGVGCH	;GET IMMED. OPERAND.
	SKIPN	DGVALP		;MUST BE ONE.
	JRST	DERR
	MOVEI	T3,(T2)
	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	MOVEI	T2,27		;RETURN (PC)+ MODE.
	JRST	DRXIT

;COME HERE IF READ ( - MUST BE (REG) OR (REG)+.
DRPAR:	PUSHJ	P,DRPAR1	;GET REG. NO.
	CAIE	T0,"+		;CLOSE-PAR. FOLLOWED BY +?
	JRST	DRPAR2		;NO, (R) OR @(R) .
	GETCHR			;YES, SKIP PAST +.
	ADDI	T2,20		;AUTOINCREMENT IS MODE 2.
	JRST	DRXIT

;COME HERE IF (R) OR @(R), AFTER READING ALL.
DRPAR2:	ADDI	T2,10		;SET UP IN CASE MODE 1.
	SKIPN	DRINDP
	JRST	DRXIT		;IF MODE 1.
	MOVEI	T5,60(T2)	;ELSE MODE 7,
	SETZ	T2,
	PUSHJ	P,DGVCOM	;STORE ZERO AS EXTRA WD.
	JRST	DRXIT		;DGVCOM DID T2_T5.

;AFTER READING A (, READ IN REGISTER NO., CHECK VALIDITY,
;CHECK FOR ), AND SKIP OVER IT.
DRPAR1:	PUSHJ	P,DGVGCH	;READ THE NO.
	CAIN	T0,")		;IF NOT FOLLOWED BY ), ERROR.
	SKIPN	DGVALP		;IF NO NUMBER, ERROR.
	JRST	DERR
	MOVEI	T3,(T2)
	TLO	T3,REGBIT
	MOVEI	T2,(T2)		;REMOVE REGISTER VS. CORE INDICATOR.
	CAILE	T2,7		;IF NOT <= 7,
	JRST	DERR		;NOT REGISTER NUMBER, ERROR.
	GETCHR			;READ PAST ).
	RETURN

;COME HERE AFTER READING - SIGN -- MIGHT BE AUTODECREMENT,
;MIGHT BE UNARY MINUS ON ADDRESS.
DRDEC:	TLO	SF,D1CHAR	;TELL DGVAL 1ST CHAR ALREADY READ.
	PUSHJ	P,DGVAL		;IT WILL USE THE - AS A UNARY, IF IT CAN.
	SKIPE	DGVALP		;IF IT CAN'T,
	JRST	DRADD0		;TREAT AS IF GOT ADDR RIGHT AWAY.
	CAIE	T0,"(		;OTHERWISE, SEE IF VALID AUTODECREMENT.
	JRST	DERR		;IF NO (.
	PUSHJ	P,DRPAR1	;GET REGISTER NO.
	ADDI	T2,40		;MODE 4.
	JRST	DRXIT

DRNEXT:	0?0?0?0?0?0
DRINDP:	0		;IF NONZERO, THIS ADDR WAS PRECEDED BY "@".
;READ IN A STANDARD 1 OR 2 OPERAND INSN.
;COME HERE WITH T5-> STE, WHOSE 2ND WORD HAS OP CODE.
;BIT 17 OF 1(T5) IS ZERO IF 2-OPERAND INSN, 1 IF 1 OPERAND.
DR2AR:	PUSHJ	P,DRINSP
	PUSHJ	P,DRADDR	;GET 1ST ADDRESS.
DR2AR0:	LSH	D,6		;PUT IN WITH OP CODE.
DR2AR2:	JUMPL	D,DR2AR1	;IF 1 OPERAND INSN.
	MOVEM	T3,%S		;SINCE MUST BE 2-OP, SET %S.
	ADDI	D,(T2)
	CAIN	T0,",		;SKIP OVER A COMMA.
	GETCHR
	PUSHJ	P,DRADDR	;GET DESTINATION ADDRESS.
	LSH	D,6		;PUT IN INSN.
DR2AR1:	MOVEM	T3,%D
	ADDI	T2,(D)
	POP	P,D
	AOS	DGVALP
	JRST	DGNUM3		;EXTEND SIGN.

;READ IN THE ADDR OF A BRANCH, MAKE THE INSN.
DRDBR:	PUSHJ	P,DRINSP	;SAVE REGS, ETC.
	SETOM	DRDBRF		;INDICATE BRANCH INSN. RATHER THAN SOB .
DRDBR1:	PUSHJ	P,DGVPSP	;PASS SPACES, READ IN NUMBER.
	MOVEI	T3,(T2)		;PREPARE TO SET %D .
	SKIPN	DGVALP
	ERROR	[ASCIZ/WHITHER/]	;IF NO ADDR.
	TLNE	T2,REGBIT	;CAN'T BRANCH INTO REGISTER.
	ERROR	[ASCIZ/TO ACCUM./]
	TRNE	T2,1		;ERROR IF ODD ADDR.
	ERROR	[ASCIZ/ODD ADDR/]
	SUBI	T2,2(DO)	;COMPUTE OFFSET.
	LSH	T2,-1		;AS NUMBER OF WORDS.
	SKIPN	DRDBRF		;ONLY 6 BITS FOR SOB.
	 JRST	DRSOB1
	TRCN	T2,377600	;SEE IF IN RANGE.
	JRST	DRDBR9
	TRNE	T2,377600
DRSOB2:	ERROR	[ASCIZ/ADDR. OUT OF RANGE/]
DRDBR9:	XORI	T2,377600	;SET TOP BITS TO WHAT THEY WERE.
DRDBR2:	ANDI	T2,377		;GET LOW BYTE.
DREMT2:	TLO	T3,.5KBIT
	JRST	DR2AR1

DRSOB1:	MOVNS	T2	;IN SOB, OFFSET IS SUBTRACTED (ADDED FOR BRANCHES)
	TRNE	T2,777700
	 JRST	DRSOB2	;TOO LARGE OR FORWARD.
	JRST	DREMT2
;HANDLE JSR, RTS.
DRJSR:	PUSHJ	P,DRINSP
	PUSHJ	P,DRJSR1	;READ REG. NUM.
	JRST	DR2AR2

DRJSR1:	PUSHJ	P,DGVPSP	;GET REGISTER NO.
	MOVEI	T2,(T2)
	SKIPE	DGVALP		;IF NO NUMBER,
	CAILE	T2,7		;OR OUT OF RANGE,
	JRST	DERR		;(>7), ERROR.
	LSH	D,3		;MAKE ROOM FOR REG. NUM.
	MOVEI	T3,(T2)		;PREPARE TO SET %S OR %D
	TLO	T3,REGBIT+.5KBIT	;TO A REG. NUM.
	RETURN

DRASH:	CALL	DRINSP
	CALL	DRADDR		;READ SRC (GOES IN LOW 6 BITS)
	MOVEM	T3,%S
	LSH	D,11		;MAKE ROOM FOR LOW 6 BITS.
	ADDI	D,(T2)
	CAIN	T0,",
	 GETCHR			;PASS COMMA.
	CALL	DRJSR1		;READ DEST (REGISTER #)
	LSH	D,-3		;UNDO SHIFT DONE BY DRJSR.
	LSH	T2,6		;REG # READ GOES BEFORE SRC.
	JRST	DR2AR1

DRSPEC:	PUSHJ	P,DRINSP
	JRST	@.+1(D)	;OP-CODE SAYS TYPE OF INSN.
	DRSOB
	DRMARK
	DRSPL

DRSOB:	PUSHJ	P,DRJSR1	;READ REG. NUM.
	MOVEI	D,770(T2)	;SET UP OP-CODE FOR FUNNY BRANCH.
	LSH	D,6
	CAIN	T0,",
	GETCHR
	SETZM	DRDBRF		;INDICATE ONLY 6 BITS FOR OFFSET.
	JRST	DRDBR1

DRMARK:	MOVEI	D,6400
	PUSHJ	P,DGVPSP
	CAIL	T2,100
	JRST	DERR		;WON'T FIT IN 6 BITS.
	JRST	DREMT1

DRSPL:	PUSHJ	P,DGVPSP
	MOVEI	D,230		;OP-CODE.
	CAILE	T2,7
	JRST	DERR		;IF NOT NUM. OF REG.
	TLZ	T2,REGBIT
	JRST	DREMT1
;READ IN THE CODE FOR EMT OR TRAP, MAKE INSN.
DREMT:	PUSHJ	P,DRINSP
	PUSHJ	P,DGVPSP	;GET EMT OR TRAP CODE.
DREMT1:	TLNN	T2,REGBIT	;IF REGISTER NO.,
	SKIPN	DGVALP		;OR NO NO.,
	JRST	DERR		;ERROR.
	CAILE	T2,400		;MUST FIT IN BYTE.
	JRST	DERR
	JRST	DREMT2

;READ IN A CFL OR SFL INSN.
DRSFL:	PUSHJ	P,DRINSP
	PUSHJ	P,DGVPSP	;TRY TO GET NUMBER.
	SKIPN	DGVALP
	JRST	DRSFL1		;IF CAN'T, MIGHT BE SPECIAL FMT.
	TLNN	T2,REGBIT	;IF REGISTER NO.,
	CAILE	T2,17		;OR OUT OF RANGE, ERROR.
	JRST	DERR
	JRST	DR2AR1		;COMBINE NO. AND OP-CODE.
DRSFL1:	CAIE	T0,"@		;SPECIAL FMT. STARTED BY @.
	JRST	DERR
	SETZ	T2,		;INITIALLY, NO FLAGS TO BE SET OR CLEARED.
DRSFL0:	GETCHR
	SETZ	T6,
IRPC X,,ZNVC
	CAIN	T0,"X
	MOVEI	T6,X!F
TERMIN
	JUMPE	T6,DR2AR1	;IF NOT PART OF INSN, FINISH.
	IORI	T2,(T6)		;INSN WILL SET SPECIFIED FLAG.
	JRST	DRSFL0

;INITIALIZATION FOR INSN READIN RTNS.
DRINSP:	EXCH	D,(P)
	PUSH	P,D
	MOVE	D,1(T5)
	TLO	D,777776	;MAKE LH. SAME AS BIT 17.
	TLNN	D,1
	TLZ	D,-1
	RETURN
;CLOSE THE OPEN REGISTER, IF ANY, STORING CHANGES, IF ANY.
DCLOSE:	JUMPL	DO,CPOPJ	;NOTHING OPEN.
	TLZN	SF,NUMFND	;CHANGES MADE?
	RETURN
	HRRM	DLEN,%OL	;LENGTH OF OPENED STUFF_LENGTH OF NEW STUFF.
	SETZM	S%OLFL
IFN 0,[
	TLNE	SF,DSKOPN
	JRST	DCLOD
]
	PUSHJ	P,DCLOS0	;T3_CORE ADDR. OF LOC., -PDP11 .
	TLNE DO,REGBIT
	JRST [	MOVEI T5,(T3)
		CAILE T5,10
		ERROR [ASCIZ /???/]
		MOVEM DL,R0(T3)
		POPJ P,]
	TLNE	SF,BYTOPN	;IF WAS OPENED AS BYTE,
	JRST	DCLOS1		;STORE A BYTE.
	11PUT DL,(T3)		;OTHERWISE STORE WORD.
	HRRZ	T6,DLEN
	LSH	T6,-1
	MOVE	T1,[004400,,DRNEXT]	;BP TO EXTRA WORDS.
DCLOSA:	SOJLE	T6,DCLOST	;IF NO MORE.
	ILDB	T5,T1		;GET NEXT WORD.
	AOJ	T3,
	CAIN	T3,MAXCOR	;WRAP AROUND IN MEMORY.
	SETZ	T3,		;(NOT IN ACCUMS).
	ANDI	T5,177777
	11PUT T5,(T3)
	JRST	DCLOSA

;COME HERE TO STORE CHANGES IN A BYTE.
DCLOS1:	11GET D,(T3)
	TRNN	DO,1
	DPB	DL,[001000,,D]	;IF EVEN BYTE.
	TRNE	DO,1
	DPB	DL,[101000,,D]	;IF ODD BYTE.
	11PUT D,(T3)
DCLOST:	RETURN

DCLOS0:	LDB	T3,[12100,,DO]	;GET ADDR, SHIFT RIGHT 1.
45N	ANDI	T3,MAXCOR-1
	TLNE	DO,REGBIT	;BUT IF ACCUM, SPECIAL.
	MOVEI	T3,(DO)		;REGISTER #
	RETURN
;LEFT BRACKET - PRINT AS NUMBER (POSSIBLY SYMBOLIC, ETC.)
CLB:	TLZ	SF,DEXCM+DINSM	;PRINT AS SYMBOL.
	JRST	CSLASH

;BACKARROW - REOPEN IN CURRENT MODE.
CBACK:	TLZ	SF,NUMFND
	MOVE	DL,DO

;SLASH
CSLASH:	CALL	DPRINT
	JRST	DLOOPT

;SUBROUTINE TO PRINT AS INSN.
DPINSN:	ADRTYP	DL		;PRINT ADDR BEING OPENED,
	TTOI	"/
	TLO	SF,DINSM
	TLZ	SF,DEXCM+DBYTM+DDSKM

;SUBROUTINE, OPEN DL AND PRINT IN CURRENT MODE.
DPRINT:	CALL	DARG		;OPEN LOC ADDRESSED BY DL. SET UP NEW DL, T3.
	HRRM	DLEN,%OL	;INIT LENGTH OF OPENED STUFF.
	SETOM	S%OLFL
	TLNE	SF,DEXCM
	RETURN			;DON'T PRINT IF ! MODE.
	TTOA	[ASCIZ/  /]
	TLNN	DO,REGBIT	;CONTENTS OF REGISTER NOT AN INSN.
	TLNE	SF,BYTOPN+DSKOPN	;CAN'T CONSIDER A BYTE AN INSN.
	JRST	DLB1
DLB0:	TLNE	SF,DINSM
	JRST	DRB		;IF I MODE, PRINT AS INSN.
DLB1:	SYMTYP	DL		;ELSE PRINT CONTENTS AS QTY.
	RETURN

DRB:	11GET T1,(T3)		;1ST WORD OF INSN.
	SETZ	T2,
	LSHC	T1,-14		;PREPARE TO DECODE.
	SKIPL	DRB2T(T1)	;IF >0, JRST TO THAT ADDR. (NOT 2-OP. INSN)
	JRST	@DRB2T(T1)
	TTOA	DRB2T(T1)	;IF 2-OP, TYPE ITS NAME.
	TTOI	" 
	PUSHJ	P,DPADDR	;DECODE AND PRINT SOURCE ADDR.
DPDEST:	MOVE	T6,%D		;WE SHOULD HAVE DEFINED %S FOR SOURCE.
	MOVEM	T6,%S
	TTOI	",
	JRST	DPADDR		;  "     "    "   DEST. ADDR.
DRB2T:	DRB00
	ASCIZ/MOV/
	ASCIZ/CMP/
	ASCIZ/BIT/
	ASCIZ/BIC/
	ASCIZ/BIS/
	ASCIZ/ADD/
	DRB07
	DRB10
	ASCIZ/MOVB/
	ASCIZ/CMPB/
	ASCIZ/BITB/
	ASCIZ/BICB/
	ASCIZ/BISB/
	ASCIZ/SUB/
	DLB1

;INSNS STARTING WITH 0000.
DRB00:	JUMPL	T2,DRB1	;1-OPER. WORD INSN.
	LSHC	T1,4
	JUMPE	T1,DRBS		;NOT A BRANCH.
	TTOA	DRB00T-1(T1)
DRBBR:	TTOI	" 
DRBBR1:	HLRE	T6,T2		;GET OFFSET.
	ASH	T6,-9		;AS NO. OF WORDS.
	ANDCMI	T6,1
	ADDI	T6,2(DO)	;DESTINATION ADDR OF BRANCH.
	ADRTYP	T6
	HRLI	T6,.5KBIT
	MOVEM	T6,%D
	RETURN

DRB00T:	ASCIZ/BR/
	ASCIZ/BNE/
	ASCIZ/BEQ/
	ASCIZ/BGE/
	ASCIZ/BLT/
	ASCIZ/BGT/
	ASCIZ/BLE/

DRB10:	JUMPL	T2,DRB1B
	LSHC	T1,4
	TTOA	DRB10T-200(T1)	;PRINT NAME OF BRANCH.
	JRST	DRBBR

DRB10T:	ASCIZ/BPL/
	ASCIZ/BMI/
	ASCIZ/BHI/
	ASCIZ/BLOS/
	ASCIZ/BVC/
	ASCIZ/BVS/
	ASCIZ/BHIS/
	ASCIZ/BLO/
DRB07:	SKIPN	WI45		;DON'T PRINT 11-45 INSNS
	JRST	DLB1		;UNLESS THEY'RE ATTACHED.
	LSHC	T1,3
	SKIPN	DRB07T-70(T1)
	 JRST	DLB1		;CHECK FOR UNUSED OPCODES.
	TTOA	DRB07T-70(T1)	;AN INSN, TYPE ITS NAME.
	TTOI	40
	LDB	T5,[410300,,T2]	;REG. NUM. FROM INSN.
	LSH	T2,3
	CAIGE	T1,74
	 JRST	DRB07A		;MUL, DIV, ETC.
	PUSHJ	P,REGTYP	;PRINT REGISTER NUMBER, % NOT NEEDED.
	TTOI	",
	MOVE	T5,%D		;WE SHOULD HAVE DEFINED %S FOR SOURCE.
	MOVEM	T5,%S
	CAIE	T1,77
	JRST	DPADDR		;PRINT DEST ADDR FOR ALL BUT SOB.
	LSH	T2,-2		;PRETEND SOB'S 6-BIT OFFSET WAS 8-BITS.
	MOVNS	T2		;FOR SOB, OFFSET IS SUBTRACTED.
	JRST	DRBBR1

DRB07A:	SAVE	T5		;REG IS DEST IN THESE INSNS (MUL, ETC)
	CALL	DPADDR		;PRINT ADDR IN DEST-POSITION (REALLY SRC)
	TTOI	",
	MOVE	T6,%D		;DPADDR ALWAYS SETS %D.
	MOVEM	T6,%S
	REST	T5
	JRST	REGTYP		;NOW TYPE THE REGISTER #.

DRB07T:	ASCIZ/MUL/
	ASCIZ/DIV/
	ASCIZ/ASH/
	ASCIZ/ASHC/
	ASCIZ/XOR/
	0
	0
	ASCIZ/SOB/	;77.
DRB1:	LSHC	T1,6
	CAIGE	T1,50		;JSR?
	JRST	DRBJSR		;YES.
	SKIPN	WI45		;DON'T PRINT 11-45 INSNS
	CAIGE	T1,64		;UNLESS THEY'RE ENABLED.
	CAIL	T1,70
	JRST	DLB1		;NOT INSN.
	SKIPN	DRB1T-50(T1)	;NO OPCODE IN TABLE => NOT INSN.
	 JRST	DLB1
	TTOA	DRB1T-50(T1)	;PRINT OP-CODE.
	CAIN	T1,64
	JRST	DRBMRK		;MARK INSN SPECIAL.
DRB1X:	TTOI	" 
	JRST	DPADDR		;DEST. ADDRESS.

DRB1T:	ASCIZ/CLR/
	ASCIZ/COM/
	ASCIZ/INC/
	ASCIZ/DEC/
	ASCIZ/NEG/
	ASCIZ/ADC/
	ASCIZ/SBC/
	ASCIZ/TST/
	ASCIZ/ROR/
	ASCIZ/ROL/
	ASCIZ/ASR/
	ASCIZ/ASL/
	ASCIZ/MARK/
	ASCIZ/MFPI/
	ASCIZ/MTPI/
	ASCIZ/SXT/

DRB1B:	LSHC	T1,6
	CAIGE	T1,1050	;TRAP? EMT?
	JRST	DRBTE		;YES.
	CAIL	T1,1064
	JRST	DRB1C		;NOT INSN.
	TTOA	DRB1T-1050(T1)
	TTOI	"B
	JRST	DRB1X

DRB1C:	CAIE	T1,1065	;CHECK FOR MFPD, MTPD
	CAIN	T1,1066
	 TTOA	1,[ASCIZ/MFPD/ ? ASCII/MTPD/]-1065(T1)
	 JRST	DLB1
	JRST	DRB1X

;INSNS WITH 1ST 10 BITS =0.
DRBS:	LSHC	T1,2		;DECODE NEXT 2 BITS.
	JUMPG	T1,DRBS1
	LSHC	T1,6		;ALL BUT LAST 2 OCTITS =0. DECODE THEM.
	SKIPN	WI45
	CAIE	T1,6		;RTT IS AN 11-45 INSN.
	CAILE	T1,6
	JRST	DLB1		;NOT INSN.
	6TYPE	DRBST1(T1)	;PRINT OP-CODE
	RETURN

DRBST1:	SIXBIT /HALT/
	SIXBIT /WAIT/
	SIXBIT /RTI/
	SIXBIT /BPT/
	SIXBIT /IOT/
	SIXBIT /RESET/
	SIXBIT /RTT/
DRBS1:	CAIN	T1,2
	JRST	DCORTS		;CONDITION CODE OP OR RTS.
	LSH	T1,-1		;WAS 1 OR 3, NOW IS 0 OR 1.
	TTOA	DRBS1T(T1)	;OP CODE.
	JRST	DRB1X

DRBS1T:	ASCIZ/JMP/
	ASCIZ/SWAB/

DCORTS:	LSHC	T1,6		;LAST 2 OCTITS.
	CAIL	T1,240		;RTS?
	JRST	DCCOP
	CAIL	T1,230
	JRST	DRBSPL
	CAIL	T1,210
	JRST	DLB1
	TTOA	[ASCIZ/RTS /]	;YES.
	MOVEI	T5,-200(T1)	;REG. NUM.
	JRST	REGTYP	;PRINT WITHOUT "%".

DRBSPL:	SKIPN	WI45
	JRST	DLB1
	TTOA	[ASCIZ/SPL /]
	TTOI	60-230(T1)	;PRIORITY VALUE.
	RETURN

DCCOP:	TRNE	T1,20		;SET OR CLEAR?
	TTOI	"S		;SET.
	TRNN	T1,20
	TTOI	"C		;CLEAR
	TTOA	[ASCIZ/FL @/]
IRPC X,,NZVC
	TRNE	T1,X!F
	TTOI	"X
TERMIN
	RETURN

DRBJSR:	TTOA	[ASCIZ/JSR /]
	MOVEI	T5,-40(T1)	;NUMBER OF REGISTER.
	PUSHJ	P,REGTYP
	JRST	DPDEST		;PRINT DEST. ADDR.

DRBTE:	TRNE	T1,4		;EMT OR TRAP?
	TTOA	[ASCIZ/TRAP /]
	TRZN	T1,4
	TTOA	[ASCIZ/EMT /]
DRBTE1:	LSHC	T1,6
	LDB	T5,[1000,,T1]	;GET 8 LOW BITS.
	JRST	DPADX2		;GO SYMTYP, SET %D.

DRBMRK:	TTOI	40
	SETZ	T1,		;CODE IS ONLY 6 BITS.
	JRST	DRBTE1
;DECODE AND PRINT ADDRESS.
DPADDR:	SETZ	T1,
	LSHC	T1,2
	LDB	T5,[400300,,T2]	;GET REGISTER NUMBER.
	ROT	T2,4		;SHIFT NEXT ADDR TO TOP.
	TRNN	T2,10		;IF THIS ONE'S INDIRECT, PRINT @.
	JRST	@DPATAB(T1)
	JUMPE	T1,DPADD1	;REGISTER INDIRECT MODE IS SPECIAL.
	TTOI	"@		;OTHER INDIRECT MODE.
	JRST	@DPATAB(T1)	;BRANCH ON MODE.

DPATAB:	DPAREG
	DPADIM
	DPADDM
	DPADXM

DPADIM:	CAIN	T5,7		;IMMEDIATE?
	JRST	DPADI1		;YES.
	PUSHJ	P,DPADD1	;PRINT "("!!REGNO!!")".
	TTOI	"+
	RETURN
DPADI1:	PUSHJ	P,DPADT0	;INCR. FETCHING LOC.
	TTOI	"#
DPADI2:	11GET T5,(T3)
	JRST	DPADX2

DPADDM:	CAIN	T5,7		;DECREMENT ON PC???
	MOVEI	T3,-1(T3)
	CAIN	T5,7
	MOVEI	DLEN,-2(DLEN)	;INSN 1 WORD SHORTER.
	TTOI	"-		;NO, '-(R)'.
	ANDI	T3,77777
DPADD1:	TTOI	"(
	PUSHJ	P,REGTYP	;PRINT REG SYM, OR NUM. WITHOUT "%".
	TTOI	")
	RETURN
DPADXM:	PUSHJ	P,DPADT0
	CAIN	T5,7		;RELATIVE ADDRESSING?
	JRST	DPADX1		;YES.
	PUSH	P,T5
	PUSHJ	P,DPADI2	;TYPE DISPLACEMENT.
	POP	P,T5
	JRST	DPADD1		;PRINT '(R)'.

DPADX1:	MOVEI	T5,1(T3)	;TURN T3 BACK INTO PDP11 WORD.
	ROT	T5,1
	11GET D,(T3)
	ADD T5,D		;COMBINE WITH DISPLACEMENT.
DPADX2:	ANDI	T5,177777
	SYMTYP	T5
	HRLI	T5,.5KBIT
	MOVEM	T5,%D
	RETURN

DPADT0:	MOVEI	T3,1(T3)	;SET UP TO GET NEXT WD OF INSN.
	MOVEI	DLEN,2(DLEN)
	HRRM	DLEN,%OL
	ANDI	T3,MAXCOR-1
	RETURN

;PRINT THE REGISTER NUMBER IN T5, EITHER SYMBOLICALLY OR NUMERICALLY,
;ACCORDING TO CURRENT MODE.
;IF NUMERICALLY, DON'T PRINT "%".
;SAVE REGISTER NUM. AS VALUE OF %D .
REGTYP:	SETOM	XREGTF		;INDICATE "%" NOT NEEDED.

;COME HERE INSTEAD IF "%" IS NEEDED.
DPAREG:	HRLI	T5,REGBIT
	ADRTYP	T5
	SETZM	XREGTF
	TLO	T5,.5KBIT
	MOVEM	T5,%D		;STORE REG. NUM. AS DEST ADDR, .5KILLED.
	RETURN
CTAB:	PUSHJ	P,DCLOSE	;STORE CHANGES.
CTAB1:	TLO	SF,NUMFND	;CHANGE . .
	TTOA	[ASCIZ/
/]
	TLNE	SF,DDSKM	;IF WILL OPEN DISK, PRINT "$Q "
	TTOI	@ALTMOD
	TLNE	SF,DDSKM
	TTOA	[ASCIZ /Q /]
	ADRTYP	DL		;PRINT LOCATION OPENED.
	TTOI	"/
	JRST	CSLASH

CUPAR:	PUSHJ	P,DCLOSE
	MOVE	DL,DPNT		;DL _ VAL(.).
	HRRI	DL,-1(DL)
	TLNE	SF,BYTOPN	;IF BYTE, OPEN NEXT AS BYTE.
	JRST	CLF2
	TLNE	SF,DSKOPN
	JRST	CLF3
	TLNN	DL,REGBIT	;UNLESS REGISTER NUM,
	HRRI	DL,-1(DL)	;MOVE BACK 1 WORD.
	JRST	CTAB1

CCRLF:	CRF
CCR:	PUSHJ	P,DCLOSE	;MAKE CHANGES.
	MOVE	T5,%PMODE	;RESET TEMPORARY MODES.
	MOVEM	T5,%TMODE	;TO PERMANENT ONES.
	SETO	DO,		;NO LOCATION OPEN.
	TTOI	"!
	JRST	DLOOP

CLF:	PUSHJ	P,DCLOSE
	MOVE	DL,DPNT		;DL _ VAL(.).
	HRRI	DL,1(DL)
	TLNN	DL,REGBIT	;IF NOT REGISTER OR BYTE,
	TLNE	SF,BYTOPN
	JRST	CLF2
	TLNE	SF,DSKOPN
	JRST	CLF3
	ADDI	DL,@%OL		;MOVE DOWN BY LENGTH OF QTY.
	MOVEI	DL,-1(DL)
	JRST	CTAB1
CLF2:	TLO	SF,DBYTM	;OPEN NEXT LOC. AS BYTE, TOO.
	JRST	CTAB1

CLF3:	TLO	SF,DDSKM
	JRST	CTAB1

; = - RETYPE AS NUMBER.
CEQ:	TLO	SF,DNUMM

; ]  - TYPE IN CURRENT MODE.
CRB:	TLZ	SF,NUMFND	;ELIMINATE ARG.
	SYMTYP	DL
	MOVEI	DLEN,2		;NOW A 1-WORD OBJECT, IF NOT BYTE.
	SKIPE	S%OLFL		;IF RETYPING WHAT WAS OPENED,
	HRRM	DLEN,%OL	;UPDATE LENGTH OF WHAT'S OPENED.
DLOOPT:	TTOA	[ASCIZ/    /]
	JRST	DLOOP
;ACTUAL CHARACTER ALTMODE.
CALT:	SKIPE	CALTSF		;IF $ AND ; WERE SWITCHED,
	JRST	CSEM0		;TREAT $ AS ; .
CALT0:	SETZB	T2,T3
CALT1:	GETCHR			;DECODE NEXT CHAR.
	CAMN	T0,ALTMOD
	AOJA	T2,CALT1	;COUNT ALTMODES.
	CAIN	T0,"-
	JRST	CALTM		;INDICATE GOT '-'.
	CAIN	T0,"I
	MOVEI	T3,DINSM
	CAIN	T0,"S
	MOVEI	T3,DSYMM
	CAIN	T0,"D
	MOVEI	T3,DDECM
	CAIN	T0,"!
	MOVEI	T3,DEXCM
	CAIN	T0,"B
	MOVEI	T3,DBYTM
	CAIN	T0,"'
	MOVEI	T3,DBYTM+DASCM
	CAIN	T0,""
	MOVEI	T3,DASCM
	CAIN	T0,"N
	MOVEI	T3,DNUMM
IFN 0,[	CAIN	T0,"Q
	MOVEI	T3,DDSKM]
	CAIN	T0,"R
	MOVEI	T3,DREGM
	JUMPE	T3,[ERROR [ASCIZ/MODE/]]

CALTX:	TLZ	SF,(T3)		;CLEAR FLAG FOR 1 TIME.
	JUMPL	T2,.+2		;IF NO - SIGN,
	TLO	SF,(T3)		;SET AGAIN.
	MOVEI	T1,%TMODE	;IF >1 ALTMODE, CHANGE TEMP. MODE SAME WAY.
	PUSHJ	P,CALTX2
	MOVEI	T1,%PMODE	;IF >2 ALTMODES, CHANGE PERM. MODE.
	PUSHJ	P,CALTX2
	JRST	DLOOP1		;EXIT WITHOUT CLOBBERING TEMPORARY MODES.

CALTX2:	TRNE	T2,-1		;IF ENOUGH ALTMODES, CONTINUE.
	JRST	CALTX3
	POP	P,T5		;SCRATCH RETURN ADDR.
	JRST	DLOOP1		;FINISH.
CALTX3:	MOVE	T5,(T1)		;GET WORD TO BE CHANGED.
	ANDCMI	T5,(T3)		;INITIALLY TURN OFF.
	JUMPL	T2,.+2		;IF SETTING, TURN BACK ON.
	IORI	T5,(T3)
	MOVEM	T5,(T1)		;STORE BACK.
	SOJA	T2,CPOPJ	;1 ALTMODE HANDLED.

CALTM:	TLC	T2,-1		;COMPLEMENT MINUS INDICATOR.
	JRST	CALT1
; COLON - DECODE FOLLOWING SYMBOL AS SPECIAL COMMAND.
CCOL:	MOVE	T1,[-NUMCOM,,COMTAB]
	JSP	T3,CCOL1	;SEARCH COMTAB
	JRST	(T2)		;CCOL1 PUSHJ'S BACK

COMTAB:
IRP CMD,,[LCOMS,ADUMP,ALTSEM,BOOT,CDMP,CORE,DEBUG,DMP,DMPCOR
DMPSYM,DMPTPV,FLSYMS,LOAD,LODCOR,LODPTR,LOOKUP,LBRKS,LSYMS
ODMP,PPRI,SELECT,WALLP,XFILE]
	SIXBIT/CMD/
	C!CMD
TERMIN
NUMCOM==<.-COMTAB>/2
	ASCIZ/CMD/		;MESSAGE IF NOT FOUND.

; :LSYMS  - LIST DEFINITIONS OF ALL NON-SPECIAL SYMBOLS.
CLSYMS:	MOVEI	T5,SYMLST
	PUSH	P,SF
	TLO	SF,DNUMM	;DON'T WANT "XXXY=XXXY" TO PRINT.
CLSYM0:	6TYPE	(T5)		;PRINT SYMBOL NAME.
	SKIPGE	T6,1(T5)
	TTOI	"=		;INDICATE IF .5KILLED.
	TTOI	"=
	SYMTYP	T6		;PRINT VALUE.
	CRF
CLSYM1:	ADDI	T5,2
	CAMG	T5,SYMEND
	JRST	CLSYM0
	POP	P,SF
	RETURN

; :FLSYMS -- FLUSH USER SYMBOLS.
CFLSYM:	SETZM	LASTST+2
	MOVE	T5,[LASTST+2,,LASTST+3]
	MOVE	T6,SYMEND	;ZERO ALL USER SYMBOLS' STES.
	BLT	T5,1(T6)
	MOVEI	T5,LASTST
	MOVEM	T5,SYMEND
	RETURN
;SEMICOLON - READ IN NUMBER (NOT EXPRESSION), AND LETTER.
CSEM:	SKIPE	CALTSF		;IF $ AND ; WERE SWITCHED,
	JRST	CALT0		;TREAT ; AS $.
CSEM0:	PUSHJ	P,GPASST	;SKIP SPACES,
	TLO	SF,D1CHAR	;RE-READ 1ST NON-SPACE.
	PUSHJ	P,DGNUM
	PUSHJ	P,PASSPS
CSEM2:	JSP	T1,DDECOD
IRPC CMD,,BFGLNPRSUWYZX
	"CMD,,CS!CMD
TERMIN
	"-,,CSEM1
	[ERROR [ASCIZ/COMMAND/]]

CSEM1:	HRROS	T2		;INDICATE GOT - .
	PUSHJ	P,GPASST	;SKIP TO NEXT NONBLANK.
	JRST	CSEM2		;DECODE IT AS COMMAND.

;PROCEED ARG (OR 1) INSNS.
CCN:	MOVEI T0,1		;ASSUME ONLY SINGLE PROCEED
	TLNE SF,NUMFND
	MOVEI T0,(DL)		;MULTIPLE PROCEED
	MOVEI T5,TF
	IORM T5,PS		;TURN ONE TRACE FLAG SO THAT MAIN LOOP KNOWS
	PUSHJ P,ONEPRO		;SIGH
	PUSHJ P,ONEPRO
	SOJG T0,.-1
	CRF
	JRST DDT

; ;Z -- READS STANDARD RANGE & NUMBER, SETS EACH WORD IN RANGE TO NUMBER.
CSZ:	PUSHJ	P,DGRAN
	11PUT T2,(T0)
	AOBJN	T0,.-1
	JRST	CCRLF
;PDP-11 BREAK POINT TRAP VECTOR

BPTVEC==14
JMPINS==137		;PDP-11 JMP @#
BPTINS==3
BPTASZ==100		;BREAK POINT AREA SIZE IN WORDS

;ASSUMED FORMAT OF PDP-11 BREAK ROUTINE

;BPTVEC HAS POINTER TO BREAK POINT ROUTINE (BPTBRK)

BPTRTN:				;SOURCE OF BREAK POINT ROUTINE

000000	;BPTFLG:0		;0=>PDP-11 NOT IN BREAK POINT
	;			;NON-ZERO=>POINTER TO AC'S
000000	;	0		;SO THAT PDP-10 CAN TEST WHOLE WORD AS FLAG
000036	;	BPTBR1		;PDP-10 HACKS IN JMP INSTRUCTION
010646	;BPTBRK:MOV	%6,-(%6)
010546	;	MOV	%5,-(%6)
010446	;	MOV	%4,-(%6)
010346	;	MOV	%3,-(%6)
010246	;	MOV	%2,-(%6)
010146	;	MOV	%1,-(%6)
010046	;	MOV	%0,-(%6)
010667
177750	;	MOV	%6,BPTFLG
005767
177744	;	TST	BPTFLG		;THE PDP-10 MUST CLEAR THIS FLAG
001375	;	BNE	.-4
012600	;BPTBR1:MOV	(%6)+,%0	;NEXT TWO WORDS HACKED BY PDP-10 FOR $G
012601	;	MOV	(%6)+,%1
012602	;	MOV	(%6)+,%2
012603	;	MOV	(%6)+,%3
012604	;	MOV	(%6)+,%4
012605	;	MOV	(%6)+,%5
005726	;	TST	(%6)+
000002	;	RTI

BPTRSZ==.-BPTRTN

;BREAK INTIALIZATION ROUTINE GOES AT VERY TOP OF PDP-11 CORE
;THIS IS PC INSENSITIVE

BPINIT:

010706	;	MOV	%7,%6
005746	;	TST	-(%6)
012737

BPTADR:

000000	;CLOBBERED BY CARPET TO POINT TO BPTBRK
000014	;	MOV	#BPTBRK,@#14
012737
BPTLVL:	000340		;SELECT BPT LEVEL BY CHANGING THIS
000016	;	MOV	#340,@#16
000003	;	BPT
000766	;	BR	BPINIT

BPTISZ==.-BPINIT

; ;B -- SET BREAK POINT <ADR>;<BPT>B AS IN ITS DDT
; SETS BREAK POINT <BPT> AT LOCATION <ADDR>
;	IF <ADR> IS 0 THEN BREAK POINT IS REMOVED

CSB:	TLZN SF,NUMFND
	ERROR [ASCIZ /ARG???/]
	SKIPN DGVALP
	JSP D,FNDBPT	;IF NO SECOND ARG, FIND FREE BREAK POINT SLOT
	MOVEI T2,(T2)
	SKIPE T2
	CAILE T2,NBPTS
	ERROR [ASCIZ /???/]
	SUBI T2,1
	IMULI T2,BPTLEN		;SIZE OF BREAK POINT INFO BLOCK
	SKIPGE $1B(T2)
	JSP D,CLRBPT		;CLEAR OUT THAT BREAK POINT SLOT
	MOVEI T1,(DL)		;ADDTRESS TO SET BREAK POINT
	JUMPE T1,DLOOPT		;HE JUST WANTED TO CLEAR BREAK POINT
	TLNE DL,REGBIT
	ERROR [ASCIZ /BKPT ON ACCUM./]
	LSH T1,-1		;WORD ADDRESS
	CAML T1,MEMSIZ
	ERROR [ASCIZ /NXM/]
	PUSH P,T2
	JSP D,SRCBPT		;MAKE SURE THIS A UNIQUE BREAK POINT
	SKIPE T3
	JSP D,CLRBPT
	POP P,T2
	TLO T1,SNB		;MARKS BREAK POINT
	MOVEM T1,$1B(T2)	;ADDRESS OF BERAK POINT
	SETZM $1B+1(T2)		;INSTRUCTION
	SETZM $1B+2(T2)		;PROCEED COUNT
	JRST DLOOPT

;FNDBPT FINDS FREE BREAK POINT SLOT

FNDBPT:	MOVEI T2,1
	MOVEI T5,0
FNDBP1:	SKIPL $1B(T5)
	JRST (D)		;FREE SLOT
	CAIL T2,NBPTS
	AOJA T2,(D)		;NO FREE SLOTS (RETURN) ILLEGAL SLOT #
	ADDI T5,BPTLEN
	AOJA T2,FNDBP1

;SRCBPT SEARCHS BREAK FOR BREAK POINT AT ADDR IN T1

SRCBPT:	MOVEI T2,BPTLEN*<NBPTS-1>
	MOVEI T3,NBPTS
SRCBP1:	SKIPL T5,$1B(T2)
	JRST SRCBP2
	HRRZS T5
	CAIN T5,(T1)
	JRST (D)		;FOUND ONE
SRCBP2:	SUBI T2,BPTLEN
	SOJG T3,SRCBP1
	JRST (D)		;NOT FOUND

;CLRBPT CLEARS BREAK POINT

CLRBPT:	SETZM $1B(T2)		;ADDRESS OF BREAK POINT
	SETZM $1B+1(T2)		;INSTRUCTION
	SETZM $1B+2(T2)		;PROCEED COUNT
	JRST (D)

;SETBPT  SET BREAK POINTS IN PDP-11

SETBPT:	PUSH P,T1
	PUSH P,T2
	MOVEI T2,0
	MOVEI T5,NBPTS
SETBP1:	SKIPL T1,$1B(T2)
	JRST SETBP2		;BREAK POINT NOT USED
	11GET T6,(T1)
	MOVEM T6,$1B+1(T2)
	MOVEI T6,BPTINS
	11PUT T6,(T1)
SETBP2:	ADDI T2,BPTLEN
	SOJG T5,SETBP1		;JUMP IF ALL DONE
SETBP3:	POP P,T2
	POP P,T1
	POPJ P,

;HERE TO REMOVE PBREAK POINTS FROM PDP-11

REMBPT:	PUSH P,T1
	PUSH P,T2
	MOVEI T2,0
	MOVEI T5,NBPTS
REMBP1:	SKIPL T1,$1B(T2)
	JRST REMBP2
	11GET T6,(T1)
	CAIE T6,BPTINS
	TTOA [ASCIZ /BKPT CLOBBERED/]
	MOVE T6,$1B+1(T2)
	11PUT T6,(T1)
REMBP2:	ADDI T2,BPTLEN
	SOJG T5,REMBP1
	POP P,T2
	POP P,T1
	POPJ P,

;LODBPT  LOAD BREAK POINT ROUTINE INTO PDP-11

CBOOT:	SKIPN MEMSIZ
	PUSHJ P,SETSIZ		;DETERMINE MEMSIZE
	PUSHJ P,LODBPT
	TTOA [ASCIZ /BOOT LOADED, HIT START AT /]
	MOVE B,MEMSIZ		;MEMORY SIZE IN PDP11 WDS
	SUBI B,BPTASZ-3		;START AFTER SWITCH LOCN
	MOVE T5,B
	LSH T5,-1		;CONVERT TO PDP-10 WD ADR
Haln	CLEARM PDP11-1(T5)	;CLEAR OUT 11 RUNNING FLAG
	LSH B,1			;CONVERT TO BYTE ADR
	PUSHJ P,OCTP
	.IOT TYIC,A		;WAIT FOR CHAR TO BE TYPED
Haln	SKIPE PDP11-1(T5)
	JRST CBOOTX
	TTOA [ASCIZ /?/]
	POPJ P,

LODBPT:	MOVE T5,BPTLVL		;MAKE SURE BPT RUNS ON CORRECT LEVEL
	11PUT T5,<BPTVEC+2>/2
;	11GET T5,BPTVEC/2
;	JUMPN T5,CPOPJ		;DON'T CLOBBER
	SKIPN T5,MEMSIZ
	POPJ P,			;MEMORY SIZE NOT KNOWN
	PUSH P,T1
	SUBI T5,BPTASZ		;100 WORDS - 200 BYTES
	MOVEI T1,1(T5)		;DON'T CLOBBER FLAG
	LSH T5,1		;BYTE ADDRESS
	ADDI T5,6		;ADDRESS OF ROUTINE
	MOVEM T5,BPTADR
	11PUT T5,BPTVEC/2	;MAKES ;G HAPPY
	MOVE T5,[-BPTRSZ+1,,BPTRTN+1] ;DON'T CLOBBER FLAG PDP-11 IS TESTING
	PUSHJ P,LBPBLK		;LOAD BREAK POINT SERVICE ROUTINE
	MOVE T1,MEMSIZ
	SUBI T1,BPTISZ
	MOVE T5,[-BPTISZ,,BPINIT]
	PUSHJ P,LBPBLK		;LOAD INITIALIZATION ROUTINE (GOES AT VERY TOP)
	MOVEI T1,JMPINS		;PLANT JMP TO INITILIZATION IN 0
	11PUT T1,0
	MOVE T1,MEMSIZ
	SUBI T1,1
	LSH T1,1
	11PUT T1,1
	POP P,T1
	POPJ P,

LBPBLK:	MOVE T6,(T5)
	11PUT T6,(T1)
	ADDI T1,1
	AOBJN T5,LBPBLK
	POPJ P,


;BREAK POINT INFO TABLE

DEFINE $NB N
$!N!B:	BLOCK BPTLEN
TERMIN

;FORMAT OF BREAK TABLE ENTRY
;SNB,,ADDR	;SNB ON IF BREAK POINT ON
;INS		;HOLDS WORD CLOBERED BY BPTINS
;COUNT		;PROCEED COUNT

BPTLEN==3

REPEAT NBPTS,$NB \.RPCNT+1
CSF:
CSX:
CSW:
CSR:	ERROR [ASCIZ /NOT IMPLEMENTED/]

; :LBRKS - PRINT A SEQUENCE OF ;B COMMANDS THAT WOULD CREATE THE
;BREAKPOINTS THAT NOW EXIST.

CLBRKS:	MOVEI T2,0
	MOVE T3,[DDECM,,1]	;CAUSE BREAK POINT # TO PRINTED IN OCTAL
CLBRK1:	SKIPL T1,$1B(T2)
	JRST CLBRK2
	LSH T1,1		;BYTE ADDRESS
	ADRTYP T1
	TTOI ";
	ADRTYP T3
	TTOA [ASCIZ /B
/]
CLBRK2:	CAML T3,[DDECM,,NBPTS]
	RETURN
	ADDI T2,BPTLEN
	AOJA T3,CLBRK1

; ;U DELETE ALL BREAK POINTS

CSU:	TTOA SPACES
	MOVEI T1,NBPTS
	MOVEI T2,0
CSU1:	JSP D,CLRBPT
	ADDI T2,BPTLEN
	SOJG T1,CSU1
	JRST DLOOPT
CDEBUG:	SETCMB A,DEBUGP
	SKIPL A
	TTOA 1,[ASCIZ/OFF
/]
	TTOA [ASCIZ/ON
/]
	RETURN

CCOL1:	PUSH P,[CCR]
CCOL2:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM		;GET DEV. NAME.
	SETZM	DGLINF
	TLNN	SF,NUMFND
	TDZA	T5,T5
	MOVEI	T5,(DL)		;T5_ARG OR 0 IF NONE.
	JUMPE	T2,CSA2
CSA0:	CAME	T2,(T1)
	AOJA	T1,CSA1
	MOVE	T2,1(T1)	;FOUND - GET DISPATCH WORD
	TLO	SF,D1CHAR	;RE-READ CHAR FOLLOWING DEV. NAME.
	PUSHJ	P,(T3)		;CALL OUR CALLER BACK
CSA4:	TLZ	SF,NUMFND+D1CHAR	;SO CCR WON'T STORE CHANGES.
	SETZM	DGLCNT
	POPJ	P,

CSA1:	AOBJN	T1,CSA0
	ERROR	(T1)	;PRINT MESSAGE AFTER PARTICULAR TABLE

CSA2:	PUSH	P,[CSA4]
	ADD	T1,[1,,2]
CLCOMS:	6TYPE	(T1)
	CRF
	AOBJP	T1,CPOPJ
	AOJA	T1,CLCOMS

CSAF:	0

; ;L COMMAND - LOAD FROM FILE, ZEROING CORE AND SYMBOLS.
CSL:	SETOM	CSLFLG		;INDICATE ;L VERSUS :LOAD.
	PUSH	P,[CCR]
	TTOI	" 
	MOVEI	T0," 		;DON'T REREAD THE "L".
	MOVEI	T5,CSLTAB
	JRST	CLOAD1

; :LOAD COMMAND.
CLOAD:	SETZM	CSLFLG
	MOVEI	T5,CSLTAB	;NORMAL LOAD-TABLE.
CLOAD1:	HRRM	T5,CLOADT
	PUSHJ	P,LODFL.
	SETOM	CSLBFL		;USING BLOCK-MODE.
	SETZM	CSLBCT		;NO WORDS IN BUFFER YET.
	TLZ	SF,NUMFND
	TSOPEN	LOADCH,DSLDEV
	PUSHJ	P,SETSIZ
	SKIPN	CSLFLG		;IF WAS ;L (OR ;S), ZERO (CORE AND) SYMBOLS.
	 JRST	CSL1
	PUSHJ	P,CFLSYM	;FLUSH SYMBOLS
	HRRZ	T5,CLOADT
	CAIN	T5,CLODST
	 JRST	CSL1
	MOVE	T5,[.5KBIT,,1]
	MOVEM	T5,%PATCH	;ELIMINATE PATCH AREA ADDR.
Haln[	HRRZ	T5,KCOUNT
	LSH	T5,10.		;NUM. WDS. CORE.
	MOVE	T6,[PDP11,,PDP11+1]
	SETZM	PDP11
	SKIPE	KCOUNT
	BLT	T6,PDP11-42(T5)	;ZERO ALL BUT BREAK POINT ROUTINE
] ;end Haln

CSL1:	CSLWRD	T3		;READ 1 WD. =BLOCK TYPE.
	JUMPL	T3,DSLDEE
	CAIL	T3,CSLMAX	;IF BAD FORMAT,
	 ERROR	[ASCIZ/BINARY FILE/]
	PUSHJ	P,@CLOADT
	JRST	CSL1

CSL2:	.CLOSE	LOADCH,
	RETURN

CSLTAB:	OFFSET	-.
	CPOPJ			;0 DOESN'T START A BLOCK.
LDABS::	DSLABS			;ABSOLUTE LOADER BLOCK.
LDSYMS::DSLASY			;ENTIRE SYMBOL-TABLE.
LDCOR::	DSLCOR			;LOAD BLOCK OF CORE.
LDDSK::	CSKIPC			;USED TO LOAD BLOCK OF DISK (OBSOLETE)
LDSTE::	DSLSYM			;DEFINE SYMBOL.
LDEND::	POPJ1			;NO MORE BLOCKS.
LDCORZ::DSLZER			;BLOCK OF ZEROS.
LDTRK::	DSLABB			;USED TO MAKE SURE DISK BLOCK EXISTS (OBSOLETE)
LDAK::	DSLABB			;INSURE MINIMUM AMOUNT OF CORE.  (N.A. IN CARPET).
LDTPV::	CSKIPT			;LOAD TRAP-ACTION-TABLE.
LDDSKZ::DSLABB			;USED TO ZERO SOME DSK (OBSOLETE)
	OFFSET	0
CSLMAX==.-CSLTAB

; :LODPTR - READ FROM PTR IN 8-BIT MODE.
CLODPT:	SETZM	CSLBFL		;USE UNIT MODE.
	MOVEI	T5,CSLTAB
	HRRM	T5,CLOADT
	TLZ	SF,NUMFND
	TSOPEN	LOADCH,[[10,,(SIXBIT/PTR/)]]
	JRST	CSL1

; :LODCOR -- LOAD, BUT IGNORE NON-CORE ITEMS.
CLODCO:	SETZM	CSLFLG
	JSP	T5,CLOAD1	;SPECIAL TABLE TO LOAD CORE ONLY.
	CPOPJ?DSLABS?DSLASY?DSLCOR?CSKIPC?DSLABW?POPJ1
	DSLZER?DSLABB?DSLABB?CSKIPT?DSLABB

; ;S COMMAND - LOAD SYMBOLS FROM FILE, FLUSHING EXISTING ONES.
CSS:	SETOM	CSLFLG		;INDICATE ;S VERSUS :LODSYM.
	PUSH	P,[CCR]
	TTOI	" 
	MOVEI	T0," 		;DON'T REREAD THE "L".
	MOVEI	T5,CLODST
	JRST	CLOAD1

;:LODSYM COMMAND - LOAD SYMBOLS ONLY.
CLODSY:	SETZM	CSLFLG		;DON'T CLEAR CORE.
	JSP	T5,CLOAD1
CLODST:	CPOPJ?CLODS1?DSLASY?CSKIPC?CSKIPC?DSLSYM?POPJ1
	DSLABB?DSLABB?DSLABB?CSKIPT?DSLABB

CLODS1:	CSLWRD	T5		;SKIP AN ABS LDR BLOCK.
	CALL	DSLABW		;READ BLOCK LENGTH
	MOVNI	T3,-3(T1)	;PREPARE TO SKIP THE REST.
	HRLZI	T3,(T3)		;T3 HAS -<# WDS LEFT, INCL CKSUM>,,
	CAIE	T1,6		;IF NOT A JUMP BLOCK, SKIP IT.
	 JRST	CLODS2
	JRST	CLODS3		;A JUMP-BLOCK: PROCESS IT AND FOLLOWING SYMTAB.

IRPS X,,CSLRT2:CSLRT3:CSLRT5:,Y,,T2 T3 T5
X:	SOSGE	CSLBCT
	CALL	CSLRBF
	ILDB	Y,CSLBBP
	JRST	(D)
TERMIN

;REFILL THE :LOAD BUFFER FROM THE FILE.
CSLRBF:	SKIPN	CSLBFL
	 JRST	CSLRD1
	MOVE	T5,[-100,,CSLBUF]	;AOBJN PTR->BUFFER.
	.IOT	LOADCH,T5
	CAMN	T5,[-100,,CSLBUF]	;ERROR IF EOF.
	ERROR	[ASCIZ/BINARY FILE/]
	HLRZ	T5,T5
	MOVEI	T5,77(T5)		;NUM. WDS. READ.
	MOVEM	T5,CSLBCT
CSLRD2:	MOVE	T5,[444400,,CSLBUF]
	MOVEM	T5,CSLBBP
	RETURN

;HERE IF USING UNIT MODE - JUST READ THIS WORD
;AND RETURN IT.
CSLRD1:	SETZM	CSLBCT
	.IOT	LOADCH,CSLBUF
	IOCGET	SKIPA
	JRST	CSLRD2
	ERROR	[ASCIZ/BINARY FILE/]

CADMPB:	1?0?0?0?0?0
CSLBUF:	BLOCK	100
CSLBCT:	0
CSLBBP:	0
CSLBFL:	0		;NONZERO IF BLOCK MODE.
CLOADT:	@(T3)		;R.H. WILL HAVE ADDR. OF CMD TABLE.

CSKIPT:	SKIPA	T3,[-TRPPTL,,]	;SKIP TPV BLOCK.

CSKIPC:	CSLWRD	T3		;SKIP CORE-BLOCK.
CLODS2:	CSLWRD	T2
	AOBJN	T3,.-1
	RETURN

DSLDEE:	CSLWRD	T2		;EACH WD FILLS 2 PDP11 WDS.
	HLRZ	T5,T2
HALY	.VALUE			;NOT WRITTEN YET.
	11PUT	T5,(T3)
	AOBJP	T3,.+3
	11PUT	T2,(T3)
	AOBJN	T3,DSLDEE
	CSLWRD	T3		;NEXT BLOCK.
	JUMPL	T3,DSLDEE
	JRST	CSL2		;POSITIVE MEANS DONE.

DSLABS:	CSLWRD	T5		;FLUSH 1 WD.
	PUSHJ	P,DSLABW	;READ BLOCK LENGTH.
CLODS3:	MOVEI	T6,-6(T1)	;GET DATA LENGTH.
	PUSHJ	P,DSLABW	;READ ORIGIN.
	MOVEI	T5,(T1)
	ADDI	T5,3777(T6)	;LAST ADDR TO LOAD INTO +1K.
	ROT	T1,-1		;INDEXING POSITION.
	JUMPE	T6,DSLABJ	;IF JUMP-BLOCK (NO DATA).
	LSH	T5,-11.		;MIN. K NEEDED.
DSLAB1:	CSLWRD	T2		;NEXT WORD (=NEXT DATA BYTE).
	11GET D,(T1)
	JUMPGE	T1,.+3		;IF STORING INTO LOW BYTE.
	DPB	T2,[101000,,D]	;STORE INTO HIGH BYTE,
	CAIA			;GO TO NEXT WORD.
	DPB	T2,[001000,,D]	;STORE INTO LOW BYTE.
	11PUT D,(T1)
	TLCE	T1,400000	;COMPLEMENT ADDRESS LOW BIT.
	ADDI T1,1
DSLAB2:	SOJG	T6,DSLAB1	;LOOP COUNTER FOR DATA WORDS.
	CSLWRD	T5		;READ & THROW AWAY CHECKSUM.
	RETURN

DSLABJ:	JUMPL	T1,.+3		;IF ADDRESS EVEN,
	ROT	T1,1		;PUT IN 11-WORD FMT,
	HRRM	T1,%GO		;SET STARTING ADDRESS.
	CSLWRD	T5		;THROW AWAY CHECKSUM.
	CSLWRD	T5		;GET SYM. TAB. TYPE
	CAIE	T5,2
	JRST	POPJ1		;2 IS ONLY TYPE NOW.
	AOS	(P)		;EXIT AFTER READING SYMBOLS.
DSLASY:	CSLWRD	T2		;GET NEXT SYMBOL'S NAME.
	JUMPE	T2,CPOPJ	;BLOCK TERMINATED BY 0.
	CSLWRD	T3		;VALUE, FLAGS.
	TLNE	T3,10000
	JRST	DSLASY		;SKIP SYMBOL IF UNDEF.
	TLZ	T3,353760	;CONVERT PALX11 TYPE BITS TO 11SIM'S.
	TLZE	T3,4000
	TLOA	T3,1		;MOVE REGISTER FLAG. ELSE,
	TRNE	T3,-1		;IF VALUE IS 0, .5KILL .
	TLZE	T3,20000
	TLO	T3,400000	;MOVE .5KILL FLAG.
	PUSHJ	P,DEFSY2
	MOVEM	T3,1(T5)
	JRST	DSLASY

DSLABW:	CSLWRD	T2		;READ 2 BYTES,
	MOVE	T1,T2
DSLABB:	CSLWRD	T2	
	LSH	T2,10		;COMBINE INTO WORD.
	ADDI	T1,(T2)
	RETURN

DSLCOR:	CSLWRD	T3		;AOBJN PTR->BLOCK.
	HRRI	T3,1(T3)	;VIRT. ADDR. TO LOAD 1ST WORD.
	CSLWRD	T5
	11PUT	T5,(T3)		;READ IN NEXT WD.
	AOBJN	T3,.-2
	RETURN

DSLZER:	CSLWRD	T3		;AOBJN PTR ->BLOCK TO BE ZEROED.
	HRRI	T3,1(T3)	;VIRT. ADDR. OF 1ST WD. TO ZERO.
	SETZ	T2,
	11PUT	T2,(T3)
	AOBJN	T3,.-1
	RETURN

DSLSYM:	CSLWRD	T2		;READ SYMBOL NAME.
	PUSHJ	P,DEFSY2	;DEFINE IT, GET STE.
	MOVEI	T3,(T5)
	CSLWRD	T2
	MOVEM	T2,1(T3)	;READ SYMBOL TYPE, VALUE INTO STE.
	RETURN

; :XFILE COMMAND -- EXECUTE COMMAND FILE.
CXFILE:	MOVEI	A,CXFILN
	TLO	SF,D1CHAR	;IN CASE CMD WAS FOLLOWED BY CR.
	PUSHJ	P,DGFIL
	TSOPEN	UTIC,CXFILN
	SETOM	FILINF
	RETURN

CXFILN:	SIXBIT/   DSK      XCT/

; ^L ROUTINE.
CFORMF:	SKIPE	GETTY
	TTOA	[ASCIZ/C/]	;CLEAR SCREEN.
	JRST	DLOOP1

; :LOOKUP -- FIND ADDR OF STE OF FOLLOWING SYMBOL.
CLOOKU:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM
	JUMPE	T2,DERR
	PUSHJ	P,DLKSYM	;SEARCH FOR STE.
	MOVEI	DL,(T5)
	.VALUE	[ASCIZ \T5/	'\]
	RETURN
DCKSUM:	0

CADUMP:	PUSHJ P,DMPFL.	;GET THE DUMP FILE NAME
	TSOPEN DMPCH,DSLDEV
	PUSHJ P,DGRAN	;GET ARG TO COMMAND
	MOVN A,T1	;LAST ADDRESS TO DUMP
	ANDI T0,77777
	MOVE T1,T0	;FIRST ADDRESS TO DUMP
	ADD A,T0
	LSH T1,1	;T0 IS A POINTER INTO CORE, T1 IS THE ASSOCIATED PDP11 ADDRESS
	LSH A,1	;MAKE INTO PDP11 ADDRESS
	MOVEI T2,177777	;16 BITS
CADMP1:	SETZM DCKSUM
	MOVNI T3,2	;RELATIVE ADDRESS OF START ADDRESS IN BUFFER
	11GET D,(T0)
	TDNE T2,D	;SEARCH FOR A NON-ZERO WORD
	JRST CADMP2	;FOUND ONE
	ADDI T1,2	;NEXT PDP11 ADDRESS
	CAMGE T1,A	;ARE WE OVER THE TOP OF WHAT WE SHOULD DUMP?
	AOJA T0,CADMP1	;NO, INCREMENT PDP10 ADDRESS AND CONTINUE LOOKING
	JRST CADMP3	;CORE IS ALL ZERO, GO DUMP SYMBOLS
CADMP2:	MOVE T6,T1	;OUTPUT START ADDRESS
	PUSHJ P,CADOUT
CADMP4:	11GET T6,(T0)	;GET A WORD TO DUMP
	PUSHJ P,CADOUT	;DUMP THE WORD
	ADDI T1,2	;NEXT PDP11 ADDRESS
	CAIGE T3,70	;IS THE BUFFER FULL?
	CAML T1,A	;OR ARE WE AT THE TOP OF THE SPACE TO BE DUMPED?
	JRST CADMP5	;YES, DUMP THE BLOCK
	MOVEI T6,10(T1)
	CAML T6,A	;ARE WE NEAR THE TOP OF THE SPACE TO BE DUMPED?
	AOJA T0,CADMP4	;YES, INC PDP10 ADDRESS AND DUMP RIGHT UP TO THE TOP
	11GET D,1(T0)
	TDNE T2,D	;IF THERE ARE NOT 3 CONSECUTIVE ZEROS
	AOJA T0,CADMP4	;INC THE PDP10 ADDRESS AND KEEP DUMPING
	11GET D,2(T0)
	TDNE T2,D
	AOJA T0,CADMP4
	11GET D,3(T0)
	TDNE T2,D
	AOJA T0,CADMP4
CADMP5:	MOVEI T6,6(T3)	;DUMP THE CURRENT BLOCK
	MOVNI T3,4	;PLACE TO PUT THE BYTE COUNT
	PUSHJ P,CADOUT	;OUTPUT THE COUNT
	MOVN T3,DCKSUM	;GET CHECKSUM
	SUBI T3,1	;THE 1 AT THE BEGINING OF THE BLOCK WAS NOT ADDED BEFORE
	ANDI T3,377	;MASK TO 8 BITS
	MOVEM T3,CADMPB(T6)	;STORE CHECKSUM
	MOVNI T6,1(T6)	;NEGATIVE COUNT OF BYTES (1 ADDED TO COUNT CHECKSUM)
	HRLZS T6	;MAKE AOBJN POINTER
	HRRI T6,CADMPB
	.IOT DMPCH,T6	;OUTPUT BLOCK TO DISK
	AOJA T0,CADMP1	;INC PDP10 ADDRESS AND SEARCH FOR NON-ZERO CORE

CADMP3:	MOVEI T0,6	;GET READY TO OUTPUT START (JUMP) BLOCK
	MOVEM T0,DCKSUM	;INIT CHECKSUM
	MOVEM T0,CADMPB+2	;SET BYTE COUNT
	MOVNI T3,2	;PLACE FOR ADDRESS
	MOVE T6,%GO	;STARTING ADDRESS
	PUSHJ P,CADOUT	;OUTPUT TO BUFFER
	MOVN T0,DCKSUM	;GET CHECKSUM
	SUBI T0,1	;CORRECT IT
	ANDI T0,377	;MASK TO 8 BITS
	MOVEM T0,CSLBUF	;THIS IS WHERE IT BLONGS
	MOVE T0,[-7,,CADMPB]	;JUMP BLOCK IS ALWAYS THIS LONG
	.IOT DMPCH,T0
	HRROI T0,[LDSYMS]	;START OF SYMBOLS
	.IOT DMPCH,T0
	;THE FOLLOWING CHANGES 11SIM TYPE FLAGS TO PALX11 TYPE FLAGS
	MOVEI T0,SYMDMP+1
	MOVSI T1,1
	MOVSI T2,4000
	MOVSI T3,20000
	MOVSI T5,24000
CADMP6:	TDZ T5,(T0)
	TDNE T1,(T0)
	TDO T2,(T0)
	SKIPGE (T0)
	TDO T3,(T0)
	ADDI T0,2
	CAMG T0,SYMEND
	JRST CADMP6
	MOVEI T0,SYMDMP	;NOW MAKE UP AN AOBJN POINTER
	SUB T0,SYMEND	;WHICH WE CAN USE
	HRLZS T0	;TO OUTPUT THE SYMBOL TABLE
	HRRI T0,SYMDMP
	.IOT DMPCH,T0	;ALL AT ONCE
	MOVE T0,[-1,,[0]]
	.IOT DMPCH,T0	;OUTPUT A ZERO FOR THE END TEST
	.CLOSE DMPCH,
	RETURN

CADOUT:	PUSH P,T6	;BREAK A PDP11 WORD INTO BYTES AND OUTPUT IT TO THE BUFFER
	ANDI T6,377
	MOVEM T6,CSLBUF(T3)
	ADDM T6,DCKSUM
	AOS T3
	MOVE T6,(P)
	LSH T6,-10
	ANDI T6,377
	MOVEM T6,CSLBUF(T3)
	ADDM T6,DCKSUM
	AOS T3
	POP P,T6
	RETURN
DEFINE	DMPOW	A
	HRROI	T6,A
	.IOT	DMPCH,T6
TERMIN

;OPEN A TEMPORARY DUMP FILE FOR CURRENT COMMAND ONLY.
CODMP1:	SKIPE	DDUMPF
	POPJ	P,		;IF PERMANENT DUMP FILE, USE IT.
	JRST	CODMP2		;ELSE, OPEN A FILE.

; :ODMP -- OPEN A FILE FOR SEVERAL DUMP COMMANDS.
CODMP:	SKIPE	DDUMPF
	ERROR	[ASCIZ/WITHOUT CLOSING THE OTHER ONE/]
	PUSHJ	P,CODMP2	;OPEN PERM. FILE.
	SETOM	DDUMPF		;IF SUCCEED, INDICATE ONE IS OPEN.
	RETURN

CODMP2:	PUSHJ	P,DMPFL.
	TSOPEN	DMPCH,DSLDEV
	RETURN

; ;Y -- ALMOST SAME AS :DMP
CSY:	PUSH	P,[CCR]
	SKIPE	DDUMPF
	CRF			;IF PERM FILE, NEED NO ARG.
	SKIPN	DDUMPF
	TTOI	" 
	MOVEI	T0," 		;DON'T REREAD "Y".

; :DMP -- DUMP RANGE OF CORE, AND SYMBOLS.
CDMP:	PUSHJ	P,CODMP1	;OPEN TEMP. FILE IF NECESSARY.
	PUSHJ	P,CSD0		;DUMP RANGE OF CORE.
CDMP2:	PUSHJ	P,DMPSYM	;DUMP SYMBOLS.
	JRST	CDUMPX		;CLOSE FILE IF TEMPORARY.

; :DMPCOR -- DUMP SPECIFIED RANGE OF CORE, ONLY.
CDMPCO:	PUSHJ	P,CODMP1
	PUSHJ	P,CSD0
CDUMPX:	SKIPE	DDUMPF		;IF DUMP FILE TEMPORARY, CLOSE IT.
	RETURN
	DMPOW	[[LDEND]]	;OUTPUT AN END BLOCK,
	.CLOSE	DMPCH,
	RETURN

; :DMPSYM -- DUMP SYMBOLS ONLY.
CDMPSY:	PUSHJ	P,CODMP1
	JRST	CDMP2

;READ A FILENAME INTO DSLDEV FOR LOADING, DUMPING RESP.
LODFL.:	SKIPA	A,[6,,]
DMPFL.:	MOVSI	A,7
	HLLM	A,DSLDEV
	MOVEI	A,DSLDEV
	TLO	SF,D1CHAR
	JRST	DGFIL

; :DMPTPV - DUMP TRAP-ACTION-CODES.
CDMPTP:	PUSHJ	P,CODMP1
	JRST	CDUMPX

; :CDMP -- CLOSE PERMANENT DUMP FILE.
CCDMP:	SETZM	DDUMPF
	JRST	CDUMPX

DMPSYM:	DMPOW	[[LDSYMS]]
	MOVN	T6,SYMEND
	HRLZI	T6,SYMDMP-2(T6)
	HRRI	T6,SYMDMP
	.IOT	DMPCH,T6
	DMPOW	[[0]]
	RETURN

DSLDEV:	SIXBIT/   DSK      BIN/
;INTERPRET ARG AS RANGE OF CORE TO DUMP.
CSD0:	PUSHJ	P,DGRAN
	MOVE	T5,T0

;DUMP OUT ALL CORE, AS BLOCK TYPES COR AND ZER.
DSD1:	DMPOW	[[LDAK]]	;BLOCK TO INSURE ENOUGH CORE
	HLRO	T2,T5
	MOVN	T2,T2		;NUM. WDS. BEING DUMPED.
	ADDI	T2,1777(T5)
	LSH	T2,-10.	;NUM. OF THE K CONTAINING LAST WD DUMPED.
	DMPOW	T2
	11GET D,(T5)
	SKIPE	D		;WHICH TYPE BLOCK FIRST?
	 JRST	CSDCOR		;IF NONZERO, COR BLOCK FIRST.
CSDZER:	MOVEI	T2,-1(T5)	;WD BEFORE 1ST IN BLOCK.
CSDZE0:	11GET D,(T5)
	SKIPN	D
	AOBJN	T5,CSDZE0	;MOVE TILL NONZERO WD OR END OF RANGE.
	MOVEI	T1,1(T2)
	SUBI	T1,(T5)
	HRLI	T2,(T1)		;IOWD LENGTH, ADDR  .
	MOVEI	T1,LDCORZ
	MOVE	T6,[-2,,T1]
	.IOT	DMPCH,T6
	JUMPGE	T5,CPOPJ	;IF EXHAUSTED RANGE TO DUMP.

CSDCOR:	MOVEI	T2,-1(T5)	;WD BEFORE 1ST IN BLOCK.
CSDCO1:	11GET D,(T5)
	11GET T1,1(T5)
	SKIPN	D
	SKIPE	T1
	AOBJN	T5,CSDCO1	;ADVANCE TILL END, OR 2 ZEROS.
	MOVEI	T1,1(T2)
	SUBI	T1,(T5)
	HRLI	T2,(T1)		;IOWD LENGTH, ADDR  .
	MOVEI	T1,LDCOR
	MOVE	T6,[-2,,T1]
	.IOT	DMPCH,T6
HALN[	HRREI	T1,1(T2)	;SET UP B.P. TO ILDB 1ST 11-WORD TO BE DUMPED,
	LSH	T1,-1		;WHICH IS TO LDB THE WORD T1 INDEXES.
	HRLI	T1,442000
	TRNN	T2,1
	 IBP	T1
	ADDI	T1,PDP11
	HLRES	T2
	MOVNS	T2		;NUMBER OF 11-WORDS TO DUMP.
	PUSH	P,T5
CSDCO4:	MOVE	T6,[-100,,CSLBUF]	;COPY 11-WORDS INTO CSLBUF,
CSDCO2:	ILDB	T5,T1		;ONE 11-WORD PER 10-WORD.
	MOVEM	T5,(T6)
	SOJE	T2,CSDCO3
	AOBJN	T6,CSDCO2
	MOVE	T6,[-100,,CSLBUF]
	.IOT	DMPCH,T6	;WHEN BUFFER IS FULL, WRITE IT AND START AGAIN.
	JRST	CSDCO4

CSDCO3:	MOVSI	T6,1-CSLBUF(T6)	;LH(T6) GETS # WORDS FILLED IN BUFFER.
	MOVNS	T6
	HRRI	T6,CSLBUF	;OUTPUT THE LAST FEW WORDS.
	.IOT	DMPCH,T6
	POP	P,T5
];HALN
Haly[	hrri t2,1(t2)
csdco2:	movei t1,(t2)	;Probably not the best way.
	11get t1,t1		;If it matters, it can be fixed.
	.iot dmpch,[-1,,t1]
	aobjn t2,csdco2
]
	JUMPL	T5,CSDZER	;IF NOT AT END.
	RETURN
IFN 0,[
; ;X - EXECUTE THE FOLLOWING INSN.
CSX:	TTOI	" 
	SETOM	CSXR1
	MOVE	T5,R1
	ANDI	DL,177777
	TLNE	SF,NUMFND	;IF HAD ARG,
	HRRZM	T5,CSXR1	;SAVE R1,
	TLZE	SF,NUMFND
	HRRM	DL,R1		;PUT ARG II IT.
	ANDCMI	DO,1
	SETOM	DGVLVL
	TLZ	SF,DBYTM
	PUSHJ	P,DGVAL		;READ THE INSN.
	TLO	SF,NUMFND
	MOVEI	DL,(T2)
	SKIPE	DGVALP		;IF GOT ONE, STORE IT.
	PUSHJ	P,DCLOSE
	HRRO	T5,R7
	MOVEM	T5,CSXPC	;SAVE PC WHILE SIMULATING INSN.
	MOVE	T5,PC-SAVLNG(P)	;GET SAVED OLD PC.
	MOVEM	T5,CSXSPC	;REMEMBER IT.
	ANDI	DO,177777
	HRRM	DO,R7
	MOVE	T5,DDONXT
	MOVEM	T5,CSXDNX
	MOVE	T5,%IL
	MOVEM	T5,CSXIL	;SAVE LENGTH OF NEXT INSN.
	MOVE	T5,%CSN
	MOVEM	T5,CSXCSN	;SAVE ;N MODE, LEAVE IT.
	HLLOS	%CSN
	MOVE	T5,-17(P)	;SAVE DDT'S CURRENT RETADDR.
	MOVEM	T5,CSXRET
	JRST	CSP

CSXPC:	0
CSXR1:	0
CSXDNX:	0
CSXRET:	0
CSXSPC:	0
CSXIL:	0
CSXCSN:	0
]

; :ALTSEM -- EXCHANGE FUNCTIONS OF ; AND $ IN COMMANDS.
CALTSE:	SETCMM	CALTSF
	MOVEI	T5,"
	MOVEI	T6,";
	SKIPN	CALTSF		;IF NOW SWITCHED STATE,
	JRST	CALTS0
	MOVEM	T5,SEMICL	;$ TREATED AS ;,
	MOVEM	T6,ALTMOD	;; TREATED AS $.
	TTOA	[ASCIZ/SWITCHED
/]
	RETURN

CALTS0:	MOVEM	T5,ALTMOD	;NORMAL STATE, $ TREATED AS $,
	MOVEM	T6,SEMICL	;; TREATED AS ;.
	TTOA	[ASCIZ/NORMAL
/]
	RETURN

; ;N - LIKE $$^N IN 10-DDT.
CSN:	TLNE	SF,NUMFND	;IF NO ARG,
	JRST	CSN1
	HRRZ	DL,%PC		;USE ADDR AFTER END OF NEXT INSN.
	ADDI	DL,@%IL
CSN1:	MOVEI T5,TF
	IORM T5,PS
CSN2:	PUSHJ P,ONEPRO
	HRRZ T5,R7
	CAME T5,DL
	JRST CSN2
	CRF
	JRST DDT

;ONE PROCEED WITHOUT FRILLS

Haln[
ONEPRO:	SKIPGE T5,PS
	SETZB T5,PS
	ANDI T5,TF		;SAVE STATE OF TRACE FLAG
	PUSH P,T5
	MOVEI T5,TF		;SET THE TRACE FLAG FOR ONE PROCEED
	IORM T5,PS
	PUSHJ P,PUTREG		;SET REGISTERS IN PDP-11
	MOVEI T5,0
	11PUT T5,-3(T1)		;SET THE PDP-11 RUNNING
	SKIPN @11ADR
	.HANG
	PUSHJ P,GETBPT
	ERROR [ASCIZ /PDP-11 STOPPED?/]
	PUSHJ P,GETREG
	MOVEI T5,TF
	ANDCAM T5,PS		;RESTORE STATE OF TRACE FLAG
	POP P,T5
	IORB T5,PS
	MOVE T6,11REGS
	11PUT T5,10(T6)
	11GET T5,7(T6)	;GET THE PC
	MOVEM T5,R7
	POPJ P,
] ;end Haln

Haly[
Onepro:	pushj p,putreg
	Byteo [hl.sstep]
	jrst getreg
]
;GO TO ADDRESS ARG.  REALLY CLOBBERS THE WORLD

CSG:	CRF
	TLNN	SF,NUMFND
	HRRZ	DL,%GO		;IF NO ARG, USE STARTING ADDR.
	ANDI	DL,177777
	HRRM	DL,R7		;IF HAD ARG, GO TO THAT ADDR.
	MOVE T1,BPTLVL		;FORCE PROCESSOR TO RUN ON CORRECT LEVEL
	MOVEM T1,PS
	PUSHJ P,GETBPT
	ERROR NOPROG
	PUSHJ P,PUTREG
	PUSHJ P,SETBPT
Haln[	MOVEI T3,0
	11PUT T3,-2(T1)
	11PUT T3,-3(T1)		;LET HER RIP
]
Haly	Byteo [hl.continue]
	JRST DDTHNG

;DDTXIT LEAVE DDT GRACEFULLY

CSP:
DDTXIT:	CRF
	PUSHJ P,GETBPT
	ERROR NOPROG
	PUSHJ P,ONEPRO		;ONE PROCEED PAST BREAK POINT
	PUSHJ P,SETBPT		;PUT BREAK POINTS IN PDP-11
	MOVEI T5,0
Haly	Byteo [hl.continue]
Haln	11PUT T5,-3(T1)		;LET THE PDP-11 GO
DDTHNG:
Haln[	MOVE T5,11ADR
	MOVEM T5,HNGLOC'
	SKIPN @HNGLOC
HNGINS:	.HANG
]
Haly[	jfcl
	.hang
]
CBOOTX:	MOVE P,[-PDLSIZ,,PDL]	;EXIT FROM BOOT COMMAND
	PUSHJ P,REMBPT
	JRST DDT

NOPROG:	ASCIZ /PROGRAM LOADED?/

GETBPT:	11GET T1,BPTVEC/2
	JUMPE T1,CPOPJ
	LSH T1,-1
	11GET T2,-1(T1)
	LSH T2,-1
POPJ1:	AOS (P)
	POPJ P,

DDTXTP:	0
	-1
	SETZM	DDONXT
TTYGT:	SETZ
	SIXBIT/TTYGET/
	[TYIC]
	2000,,T0
	2000,,T0
	402000,,A

;NORMAL DDT TTYSET.
TTYM1:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[232420,,222222]
	[230222,,222222]
	400000,,TTYM1A

;NORMAL SIMULATOR TTYSET.
TTYM2:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[131313,,131313]
	[131313,,131313]
	400000,,TTYM1A

;DDT TTYSET TO ACTIVATE ON NEXT CHAR.
TTYMA:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[232420,,222222]
	[230222,,222222]
	400000,,TTYMAA

TTYM1A:	0		;SET UP AFTER TTYGT AFTER $G'D.
TTYMAA:	0
IOCTAB:	BLOCK IOCNUM
IOCEND:

ALTMOD:	"	;CHAR TREATED AS $ (EITHER $ OR ;).
SEMICL:	";	;CHAR TREATED AS ; (EITHER $ OR ;, NOT=ALTMOD).
CALTSF:	0	;NOT 0 IFF $ AND ; ARE SWITCHED.
OPC:	0	;ADDR OF CURRENT OR PREVIOUS INSN.
GETTY:	0	;SET IFF GRAPHICS TTY.
INSCNT:	0	;NUM. INSNS TO EXECUTE IN SNGL-STEP MD.
CPATTY:	0	;LOCAL TO CPAT, CCRB, CCBSL.
RSTPC:	0
DDTPDP:	0
DDONXT:	0
CSLFLG:	0
DRDBRF:	0
DINITF:	0
DGVLVL:	-1		;LEVEL OF RECURSION AT DGVAL.
DGVRGP:	0		;NONZERO IF THIS VALUE IS REGISTER NUM.
DGVALP:	0		;NONZERO IF DGVAL, DGNUM ETC. FINDS A VALUE.
S%OLFL:	0	;SET WHILE %Q REMAINS WHAT WAS OPENED.
DDUMPF:	0	;SET IF PERMANENT DUMP FILE OPEN.
LPTFLG:	0
TYOFLG:	-1
KCOUNT:	0	;# PDP-10 BLOCKS CORE USED FOR PDP-11 MEMORY
MEMSIZ:	0	;NUMBER OF LIVE PDP-11 WORDS
DEBUGP:	0
QA:	0
QD:	0
QT:	0
LPTCNT:	0
WI45:	0	;Nonzero => OK to read and print 11/45 insns.

DNOARG:	ERROR	[ASCIZ/ARG/]

11REGS:	0	;POINTS TO REGISTERS IN PDP-11

IRP REGNUM,,[R0,R1,R2,R3,R4,R5,R6,R7,PS]	;LEAVE CONTIGOUS AND IN THIS ORDER
REGNUM:	0
TERMIN			;PDP11 REGISTERS HERE.

PDL:	BLOCK PDLSIZ
PATCH:	BLOCK 40
PATCHE:	-1

VARIABLES
CONSTANTS	;DON'T WANT CONSTANTS AT END SO SYM TAB CAN VARY IN LENGTH
SYMEND:	LASTST		;ALWAYS -> LAST STE IN USE.

;INITIAL SYMBOL TABLE

;FORMAT OF STE:
;	WORD 1:	NAME OF SYMBOL, IN SIXBIT.
;	WORD 2:	SIGN BIT: IF SET, SYMBOL IS HALF-KILLED.
;		REST OF LH: SYMBOL TYPE.
;		RH:  VALUE.

	DEFINE	.5KILL	A,B,C
	SIXBIT/A/
	IFSN C,,C:
	IFSE C,,A:
	.5KBIT,,IFSN B,,B
	TERMIN

	.=.+<.&1>		;GO TO EVEN ADDR.
SYMTAB:	REPEAT	10,[
	<'%_36>+<<'0+.RPCNT>_30>
	1,,.RPCNT
	]		;DEFINE %0 ... %7 .

;INSN. SPECIAL SYMBOLS.

	INSNUM==0
IRP INSN,,[MOV,CMP,BIT,BIC,BIS]
	INSNUM==INSNUM+1
	SIXBIT/INSN/
	2,,INSNUM
	SIXBIT/INSN!B/	;BYTE INSN DEF.
	2,,10+INSNUM
TERMIN
	SIXBIT/ADD/	;2 EXCEPTIONS.
	2,,6
	SIXBIT/SUB/
	2,,16

;SINGLE OPERAND INSN SYMBOLS.
	INSNUM==0
IRP INSN,,[CLR,COM,INC,DEC,NEG,ADC,SBC,TST,ROR,ROL,ASR,ASL]
	SIXBIT/INSN/
	3,,INSNUM+50	;WORD INSN.
	SIXBIT/INSN!B/
	3,,INSNUM+1050	;BYTE INSN.
	INSNUM==INSNUM+1
TERMIN

IRPS INSN,,[JMP 1,SWAB 3,SXT 67,MFPI 65,MTPI 66,MFPD 1065,MTPD 1066]
IFE 1&.IRPCN,SIXBIT/INSN/
.ELSE	3,,INSN
TERMIN
;BRANCH INSN SYMBOLS:
	INSNUM==0
IRP INSN,,[BR,BNE,BEQ,BGE,BLT,BGT,BLE]
	INSNUM==INSNUM+1
	SIXBIT/INSN/
	6,,INSNUM*400
TERMIN

	INSNUM==100000
IRP INSN,,[BPL,BMI,BHI,BLOS,BVC,BVS,BCC,BCS]
	SIXBIT/INSN/
	6,,INSNUM
	INSNUM==INSNUM+400
TERMIN

	SIXBIT/BHIS/
	6,,103000
	SIXBIT/BLO/
	6,,103400

	SIXBIT/JSR/
	4,,4
	SIXBIT/XOR/
	4,,74
	SIXBIT/RTS/
	5,,20

	SIXBIT/TRAP/
	7,,104400
	SIXBIT/EMT/
	7,,104000

	SIXBIT/SFL/
	10,,260
	SIXBIT/CFL/
	10,,240

	SIXBIT/SOB/
	13,,0
	SIXBIT/MARK/
	13,,1
	SIXBIT/SPL/
	13,,2

	INSNUM==70
IRP INSN,,[MUL,DIV,ASH,ASHC]
	SIXBIT/INSN/
	14,,INSNUM
	INSNUM==INSNUM+1
TERMIN

	INSNUM==0
IRP INSN,,[HALT,WAIT,RTI,BPT,IOT,RESET,RTT]
	SIXBIT/INSN/
	INSNUM
	INSNUM==INSNUM+1
TERMIN
SYMDRG:
IRPS AA,,[
%TKS 177560,%TKB 177562,%TKV 60
%TPS 177564,%TPB 177566,%TPV 64
%PKC 172544,%PKCSB 172542,%PKCSR 172540,%PKV 104
%PPS 177554,%PPB 177556,%PPV 74
%PRS 177550,%PRB 177552,%PRV 70
%RKDS 177400,%RKER 177402,%RKCS 177404,%RKWC 177406
%RKBA 177410,%RKDA 177412,%RKV 220
%LKS 177546,%LKV 100
%LPS 177514,%LPB 177516,%LPV 200
%NGCSR 164040,%NGREL 164042
%ERRV 4,%BPTV 14,%IOTV 20,%PWRV 24,%EMTV 30,%TRPV 34
%DIV 177300,%AC 177302,%MQ 177304,%MUL 177306
%SR 177310,%SC 177311,%NOR 177312,%LGS 177314,%ARS 177316
%PS 177776,%SWR 177570,%PIR 177772,%PIRV 240
%CSR 175000,%BAR 175002,%BCR 175004,%TBR 175006
%RCSR 174000,%RBUF 174002,%TSCR 174004,%TBUF 174006,%DCRV 300,%DCTV 304
%DCS 177460,%DWC 177462,%DCA 177464,%DAR 177466
%DAE 177470,%DBR 177472,%DSA 177476,%DV 204
%WC 177462,%CMA 177464,%ADS 177476
%TCST 177340,%TCCM 177342,%TCWC 177344,%TCBA 177346
%TCDT 177350,%TCV 214
%SLR 177774,%PAGV 250,%SSR0 177572,%SSR1 177574,%SSR2 177576,%SSR3 172516
%SARU0 177640,%SDRU0 177600,%SARS0 172240,%SDRS0 172200,%SARK0 172340,%SDRK0 172300
]
	IFE 1&.IRPCN,	SIXBIT/AA/
	.ELSE		IFL AA-400,[SETZ] AA+.ELSE 45Y 600000
TERMIN


SYMLST:	.5KILL	.,0,DPNT,	;SYMBOL . .
	.5KILL	%Q,0		;LAST QTY IN OR OUT.
	.5KILL	%P,0		;LAST PART OF MULTI-WORD EXP.
	.5KILL	%D,0		;LAST DEST. ADDR.
	.5KILL	%S,0		;LAST SRC. ADDR.
	.5KILL	%L,0		;LENGTH OF LAST QTY IN OR OUT.
	.5KILL	%OL,0		;LENGTH OF WHAT WAS LAST OPENED.
	.5KILL	%IL,0		;LENGTH OF INSN %PC POINTS TO.
	.5KILL	%CSN,-1		;RH IS -1 OR HALF PC TO STOP AT (;N).
	.5KILL	%.,0,DOPEN,	;LOCATION OPEN.
	.5KILL	%OPC,0		;PC OF CURRENT OR LAST INS.
	.5KILL	%B,0		;ADDR OF LAST BREAKPOINT.
	.5KILL	%CORE,0		;NUM. BYTES CORE.
	.5KILL	%,0,%PC,	;PC AT ENTRY TO DDT.
	.5KILL	%PATR,0		;ADDR AFTER PLACE PATCH WAS PUT.
	OMODE==DINSM+DSYMM
SYMDMP:	.5KILL	PATCH,1,%PATCH,	;PATCH AREA FOR ^\, ^].
	.5KILL	%PMODE,OMODE	;PERMANENT MODE.
	.5KILL	%TMODE,OMODE	;TEMPORARY MODE.
	.5KILL	%GO,0		;STARTING ADDRESS FOR ;G.
	.5KILL	%DMRV,310	;DM DEVICE RECEIVE TRAP VECTOR
	.5KILL	%DMTV,314	;DM TRANSMIT TRAP VECTOR.
IFN .-SYMDMP-SYMNSP*2,.ERR EDIT AT DEFSY2
LASTST=.-2
	END	BEG
