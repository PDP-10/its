;RIM10
TITLE PAGE TEST
;TEST WORD
;4.9 LOOP ON ERROR
;4.8 SUPPRESS TYPEOUT
;4.7 HOLD IN LOOP

QT==0	;QUANTUM TIMER TEST CODE SWITCH


A=1
B=2
C=3
D=4
E=5
F=6
FF=7
LC=11
T=12
U1=13
U2=14
U3=15
U4=16
P=17

HIGHEST==3777777		;TOP ABSOLUTE ADDRESS

DDT=774000
;THIS PROGRAM DOESN'T TRY TO WIN FOR DDT > 400000
X=PUSHJ P,
R=POPJ P,
J=JRST
M=MOVE
MI=MOVEI
MM=MOVEM


XCTR=103000,,	;XCT RELOCATED
LPM=102000,,
LPMR=LPM 2,	;CLEAR ASSOC MEM
LPMRI=LPM 6,	;LOAD, CLEAR ASSOC, AND GENERATE INTERRUPT
SPM=LPM 1,	;STORE STATE VECTOR
APRCHN==1
ACTCHN==2	;RANDOM CHNL TO ACTIVATE

CLKON==2200+200_<-APRCHN>
CLKOFF==1000+200_<-APRCHN>
LSRMOD==10000
IOTLSR==4000
PURE==2000
ONEPR==400
BIS==20000
PCBITS==776540

TPG=20000	;START OF MEM PAGE TO USE FOR ASSOC MEM TST
TPG1=22000	;OTHER PAGE
TPG2=24000	;YET ANOTHER PAGE
IF2,[IFGE NEXPAG-TPG,[PRINTX /TPG TOO LOW-TRY AGAIN
/]]

EXR==4	;EXEC RELOCATE ABOVE 400000

RW==600000	;READ WRITE PAGE
RWF==400000	;READ WRITE FIRST
RO==200000	;READ ONLY

ERR==40000,,
ERRP==41000,,	;ERR PNT CAME OR CAMN MUST IMMED PRECEEDî
%TAG==42000,,	;STORE ASCII POINTER FOR ROUTINE NAME
BRANCH==43000,,	;GIVE ADDRESS TO TRANSFER TO ON INTERRUPT
TYPE==44000,,	;TYPE STRING POINTED TO BY ADDRESS

XW==2	;XCT RELOCATED WRITE
XR==1	;READ
XRW==3	;READ/WRITE
XRI==5	;READ/INHIBIT INTERRUPTS
XWI==6
XRWI==7

BAC==270400	;AC FIELD

DEFINE OUTSTR A
TYPE [.ASCII \A\]
TERMIN

DEFINE ERRLUP A
TERMIN


DEFINE .ERR A/
ERR [.ASCII ?A?]
TERMIN

DEFINE TAG A/
%TAG [ASCIZ ?A?]
TERMIN

DEFINE INTCHECK
.ERR INTERRUPT DIDNT OCCUR
TERMIN

DEFINE NEXT
JSR NEXTR
TERMIN

ZZ=.

LOC 41
	JSR UUOH
LOC 40+2*APRCHN
	JSR APRBRK
LOC 40+2*ACTCHN
	JSR 62
LOC 63
	JRST 2,@62
LOC 61
	JSR UUOH
LOC 77
PASSS:	0	;PASS COUNTER

LOC ZZ


BEG:	CONO 0
	MOVE A,[JSR UUOH]
	MOVEM A,41
	CONO PI,10000
	CONO 637550
	LPMR NULPSW
	SETZM INTLOC
	MOVEI A,0
BEGL1:	ADDI A,40000
	CAM (A)
	CONSO 10000
	CAIL A,-1
	SOJA A,.+2
	J BEGL1
	CONO 10000
	MOVEM A,MEMSIZ
	MOVEI P,PDL-1
	SETZM DDTLOC'
	MOVEI F,DDT
GOTDDT:	SKIPN A,-1(F)
	JRST GETDDT
	CAIE A,-2(F)
	JRST GETDDT
	MOVEM F,DDTLOC
NODDT:

BEGLUP:	NEXT
;TEST BITS FOR LOADING AND STORING
	CONO PI,16200+200_<-ACTCHN>
	SETOM LMOD
	MOVNI A,2
	MM A,XCTEM
ATL2E:	PUSHJ P,LPSET	;SET UP ITERATION COUNTER
ATL2:	CLEARM ERRF
	MOVSI B,-8
ATL2A:	SKIPGE LMOD
	PUSHJ P,RAND	;2ND PASS USE RANDOM CONTENTS	
	SKIPL LMOD
	M A,XCTEM	;1ST PASS USE ISOLATED "0" BIT
	MOVEM A,LP1(B)
	AOBJN B,ATL2A
	MOVSI B,-8
	MOVSI A,1
	IORM A,LP1+3	;DONT LET Q.C. CHANGE
ATL2D:	LPMR LP1
	SPM SP1
ATL2B:	MOVE A,LP1(B)
	XOR A,SP1(B)
	AND A,MSK1(B)
	JUMPE A,ATL2C
	MOVE C,LP1(B)
	MOVE D,SP1(B)
	HRRZ E,B
	ERR [.ASCII ?LOADED *!C STORED *!D ERR *!A  WD #!E 
?]
	OUTSTR [CONTINUE? ]
BADBIT:	LPMR LP1
	SPM SP1
	MOVE A,SP1(B)
	XOR A,LP1(B)
	AND A,MSK1(B)
	SKIPE A
	AOS ERRCNT'
	DATAO PI,ERRCNT
	CONSO TTY,40
	JRST BADBIT
	X TYI
	CAIE A,"Y
	JRST GIVEUP
	X CRR
ATL2C:	AOBJN B,ATL2D
	DATAI A
	SKIPGE ERRF
	JUMPL A,ATL2D	;LOOP ON ERR
	M A,XCTEM
	ROT A,1
	MM A,XCTEM
	SOJG LC,ATL2
	AOSG LMOD
	J ATL2E


NEXT
TAG TESTING ADDRESS DATAPATH_

;SEE IF SIMPLE REFERENCES TO MAPPED ADDRESSES WORK
	CONO PI,CLKOFF
	MOVE A,[376,,MAP]
	MOVEM A,DBR3
	MOVSI A,EXR+1
	MOVEM A,PSW+3
	MOVE A,[RO+TPG_-10.,,RO+TPG_-10.]
	MOVEM A,MAP
	MOVE A,[MAP,,MAP+1]
	BLT A,MAP+NPAGES/2-1
	MOVE A,[-2000,,400000]
	MOVEM A,TPG-400000(A)
	AOBJN A,.-1
	LPMR PSW
	MOVE A,400000
	JRST DATP2

DATPS1:	REPEAT 10,JSP F,SKIP1	;INCASE OF FAULT SKIPPING

DATP2:	CONSZ 60000
	JRST DATPR
	CAMN A,[-2000,,400000]
	JRST DATP1
	FOO==[-2000,,400000]
	.ERR WRONG DATA REFERENCING 400000, C(ERR)=*!A _,C(400000)=*!FOO _
	JRST DATPR4
DATP1:	MOVE A,401777
	JRST DATP3

DATPS2:	REPEAT 10,JSP F,SKIP2

DATP3:	CONSZ 60000
	JRST DATPR
	CAMN A,[-1,,401777]
	JRST DATPE
	FOO==[-1,,401777]
	.ERR WRONG DATA REFERENCING 401777, C(ERR)=*!A _,C(401777)=*!FOO _
	JRST DATPR4
DATPE:	JRST AMEM

DATPR:	SPM SP1
	MOVEI F,0
	JRST DATPR1

SKIP2:	SUBI F,DATPS2
	CAIA
SKIP1:	SUBI F,DATPS1
	HRRZS F
	SPM SP1
DATPR1:	ERR [.ASCII \FIRST PAGED REFERENCE FAULTED_BITS=\]
	HLLZ C,SP1+3
	X TYPFLT
	X CRR
	SKIPE F
	OUTSTR [PC SKIPPED #!F TIMES ]
	OUTSTR [CONTINUE? ]
DATPR4:	LPMR PSW
	MOVE 400000
	JRST DATPR3
	REPEAT 10,JFCL
	AOS ERRCNT
	DATAO PI,ERRCNT
DATPR3:	CONSO TTY,40
	JRST DATPR4
	X TYI
	CAIE A,"Y
	JRST GIVEUP
	JRST AMEM

;TEST ASSOCIATIVE PART OF A MEMORY
PSW:	0	;(5-7)AGE	(9-17)FAULT PAGE		(18-35)JPC
	0	;(5-17)OPC FLAGS				(18-35)OPC
	0	;(11-14)RING BUFFER COUNTER	(15-17)MAR CONDITION	(18-35)MAR
	1,,0	;(7-17)FAULT STATUS				(18-35)QUANTUM COUNTER
DBR1:	0	;(5-10)OUTPUT PN 21-25	(11-16)DBR LENGTH	(17-35)DBR USER 0
DBR2:	0	;(5-10)OUTPUT PN 16-20	(11-17)DBR LENGTH	(17-35)DBR USER 1
DBR3:	0	;			(11-17)DBR LENGTH	(17-35)EXEC 400000
ACP:	0	;(7-11)B KEY[18-22]	(12-16)C KEY		(17-35)AC POINTER

BRINGBF==250400,,2
BFAULT==221300,,3
B.AGE==340300
B.AGE1==120300
BCKEY:	300500,,PTS1+7
	230500,,PTS1+7

FONPR==2000
FFAULT==1000	;IF ANY PAGE FAULT OCCURS
FNXM==400
FDBL==200
FRDO==100	;WRITE INTO READ ONLY
FRWF==40	;WRITE INTO READ WRITE FIRST
FPURE==20	;PURE PC FETCH FROM 10 OR 11 PAGE
FNACC==10
FMAR==2

NPAGES==256.
MAP:	BLOCK NPAGES/2
TEMPSW:	BLOCK 10
FILLTB:	BLOCK 21	;SUPPOSED CONTENTS OF ASSOCIATIVE REGISTERS

AMEM:
NEXT
;This tests each associative register part of AMEM for matching the input
	;virtual address. It does this by noticing whether the correct
	; number of AR's have been loaded at each step.
;First it fills all AR's before the one under test with references to a series
	; of dummy pages.
;Then it makes a reference to the test page and checks that the AR under test was
	; filled.
;Then it references a "confusion" address that is different in one bit, and makes
	; sure that another AR was loaded.

TAG TEST ASSOCIATIVE PART OF A MEMORY_
	MOVEI LC,0
	CONO PI,CLKOFF
	MOVE A,[400000,,200]
	MOVEM A,PN'	;EXEC 400000
	MOVE A,[525252,,525252]
	MOVEM A,TPG+20
	MOVE A,[376,,MAP]
	MOVEM A,DBR1
	MOVEM A,DBR2
	MOVEM A,DBR3
	MOVE A,[RO+TPG_-10.,,RO+TPG_-10.]
	MOVEM A,MAP
	MOVE A,[MAP,,MAP+1]
	BLT A,MAP+NPAGES/2-1
	MOVEI A,EXR+1
	HRLZM A,PSW+3
PAGLUP:	SETZM RN'
REGLUP:	MOVEI A,400000
	SKIPGE PN
	LSH A,-1	;DON'T TEST HIGH ORDER BIT FOR EXEC
	MOVEM A,BIT'
BITLUP:	LPMR PSW		;CLEAR OUT AR'S
	SETZM N'
	SETOM FILLCT'
FILLUP:	MOVE A,RN
	CAMN A,N		; FILLED ALL AR'S PREVIOUS TO ONE UNDER TEST?
	JRST TESTN	;YES, TEST NTH ASSOC REGISTER
	SKIPL PN
	JRST FILLEX	;FILL UP WITH EXEC PAGES TYPES SO WON'T ASSOC WITH TEST PAGE
	MOVE B,N
	ADD B,PN
	MOVEM B,TSTPAG'
	LSH B,10.
	XCTR XR,[MOVE A,20(B)]
	JRST FILLED

FILLEX:	MOVE B,N
	ADD B,PN
	CAIL B,NPAGES
	SUBI B,NPAGES/2
	CAIGE B,NPAGES/2
	ADDI B,NPAGES/2
	MOVEM B,TSTPAG'
	LSH B,10.
	MOVE A,20(B)
FILLED:	MOVE B,TSTPAG
	HLL B,PN
	TLC B,400000	;FILLED WITH OPPOSITE SENSE OF USER BIT AS TEST PAGE
	AOS A,FILLCT
	MOVEM B,FILLTB(A)
	SPM TEMPSW
	LDB A,[BRINGBF+TEMPSW]
	AOS B,N
	CAMN A,B
	JRST FILLUP
	MOVE B,TSTPAG
	TLC B,400000
	MOVE C,N	;CORRECT STATE OF RING BUFFER PNTR
FILLERR:	.ERR REFERENCE TO 
	SKIPL B
	OUTSTR [USER PAGE NO #!B _]
	SKIPGE B
	OUTSTR [EXEC PAGE NO #!B _]
	LDB D,[BRINGBF+TEMPSW]
	OUTSTR [FILLED ASSOC RING BUFFER PNTR TO #!D INSTEAD OF #!C _]
FILLPNT:	SKIPGE FILLCT
	JRST AMERR
	OUTSTR [ASSOC REG       INTENDED CONTENTS_]
	SETZB A,TEM'
FILLP1:	OUTSTR [#!A       ]
	MOVE B,FILLTB(A)
	SKIPGE B
	OUTSTR [EXEC PAGE #!B _]
	SKIPL B
	OUTSTR [USER PAGE #!B _]
	CAMGE A,FILLCT
	AOJA A,FILLP1
	JRST AMERR

TESTN:	MOVE B,PN
	LSH B,10.
	SKIPL PN
	XCTR XR,[MOVE A,20(B)]
	SKIPGE PN
	MOVE A,20(B)
	SPM TEMPSW
	MOVE E,RN
	AOS E
	ANDI E,17
	AOS A,FILLCT
	MOVE C,PN
	MOVEM C,FILLTB(A)
	LDB D,[BRINGBF+TEMPSW]
	CAMN D,E	;DID TEST REGISTER LOAD?
	JRST TESTN1	;YES, SEE IF ASSOCIATED CORRECTLY
		MOVE B,PN
		MOVE C,E
		JRST FILLER
TESTN1:	XOR B,BIT
	SKIPL PN
	XCTR XR,[MOVE A,20(B)]
	SKIPGE PN
	MOVE A,20(B)
	SPM TEMPSW
	LDB D,[BRINGBF+TEMPSW]
	LSH B,-10.
	HLL B,PN
	AOS A,FILLCT
	MOVEM B,FILLTB(A)
	MOVE C,RN
	ADDI C,2
	ANDI C,17
	CAME D,C
	JRST FILLER
NEXBIT:	MOVE A,BIT
	LSH A,-1
	MOVEM A,BIT
	TRNN A,1000
	JRST BITLUP
	AOS A,RN
	CAIGE A,20
	JRST REGLUP
	AOS A,PN
	HRRZS A
	MOVE B,LC
	DATAI C
	ANDI C,7
	LSH B,(C)
	CAIGE B,400
	CAIL A,NPAGES
	JRST .+2
	AOJA LC,PAGLUP
	SKIPL PN
	JRST ATEST
	MOVEI A,0
	MOVEM A,PN
	JRST PAGLUP

AMERR:	OUTSTR [CONTINUE? ]
AMER1:	LPMR PSW
	MOVEI A,0
AMER3:	CAMG A,FILLCT
	JRST AMER2
	CONSO TTY,40
	JRST AMER1
	X TYI
	CAIE A,"Y
	JRST GIVEUP
	JRST NEXBIT

AMER2:	MOVE B,FILLTB(A)
	HRRZ C,B
	LSH C,10.
	SKIPL B
	XCTR XR,[MOVE D,20(C)]
	SKIPGE B
	MOVE D,20(C)
	AOJA A,AMER3

;Fills AR with pointers to TPG
;Checks to see that the mapped area of memory can be referenced without refill.
;Checks that refill is needed for other areas of virtual memory.

ATEST:	NEXT
	MOVEI A,0
	DPB A,[231200,,PTS1+7]	;CLEAR OUT B,C KEYS
	MOVE A,[105105,,105105]
	MOVEM A,TPG+20	;SET UP 3 PGS WITH DIFFERENT QUANS
TESTW1==TPG+20
TESTW2==TPG1+20
TESTW3==TPG2+20
	EQVI A,0
	MOVEM A,TPG1+20
	MOVE A,[6969.6969]
	MOVEM A,TPG2+20
	CLEARM LMOD
	MOVEI A,400000+20	;START TESTING EXEC ADDRESS 400000+
	MOVEM A,TADR
	MOVE A,[376,,PTSPT1+100]
	MOVEM A,PTS1+6	;SET UP EXEC DBR
	MOVSI A,EXR
	IORM A,PTS1+3
	CLEARM PTS1+5	;CLEAR OUT USER DBR
	CLEARM PTS1+4
	MOVE A,[XCT D]	;NON RELOCATED XCT
ATLU1:	MOVEM A,TINS
	JRST ATL1BG

CLRPGT:	CLEARM PTSPT1
	MOVE A,[PTSPT1,,PTSPT1+1]
	BLT A,PTSPT1+177	;CLEAR OUT PG TBL
	CLEARM OPPNR
	POPJ P,

ATL1BG:	PUSHJ P,LPSET	;GET INTERATION COUNT
ATL1:	CLEARM ERRF
	X CLRPGT
	LPMR PTS1	;LD PAGE STATE VECTOR AND RESET ASSOC REG
	MOVSI B,-16.	;TEST 16 ASSOC REGISTERS
	SETZM REGNUM'
	HRR B,TADR
	MOVE D,[MOVE A,(B)]	;INST TO REF PAGED MEM
	MOVEI U3,RO+TPG_-10.	;SET UP PAGE TBL TO PNT TO FIRST PG
	PUSHJ P,PGCSET
ATL1A:	XCT TINS
	CAMN A,TPG+20	;FIRST REF SHOULD FETCH PG ENTRY
	JRST ATL1AA
	.ERR REFERENCE TO 
	SKIPE LMOD
	OUTSTR [USER ]
	SKIPN LMOD
	OUTSTR [EXEC ]
	OUTSTR [ #!B THROUGH ASSOC REGISTER NO #!REGNUM FAILED_]
	OUTSTR [ERROR=*!A , CORRECT=*!TESTW1 _]
	SETOM ERRF
	JRST ATLERR

ATL1AA:	ADDI B,1777
	AOS REGNUM
	AOBJN B,ATL1A

;TRY ADDRESSES THAT SHOULDN'T REFILL ASSSOC REGISTERS

	MOVSI B,-16.
	HRR B,TADR
	SETZM REGNUM
	MOVE D,[MOVE A,(B)]
	MOVEI U3,RO+TPG1_-10.	;CHNG PG TBL TO POINT TO NEW PG SHOULD CHNG ASSOC REG
	PUSHJ P,PGCSET
ATL1B:	XCT TINS
	CAMN A,TPG+20
	JRST ATL1C
	.ERR ASSOC REGISTER NO #!REGNUM FAILED TO KEEP OLD ASSOCIATION ON REFERENCE TO 
	SKIPE LMOD
	OUTSTR [USER ]
	SKIPN LMOD
	OUTSTR [EXEC ]
	OUTSTR [#!B _]
	OUTSTR [C(ERR)=*!A _]
	OUTSTR [C(OLD MAP)=*!TESTW1 _]
	OUTSTR [C(NEW MAP)=*!TESTW2 _]
	SETOM ERRF
	JRST ATLERR

ATL1C:	ADDI B,1777
	AOS REGNUM
	AOBJN B,ATL1B

;TRY ADDRESSES THAT SHOULD REFILL
	MOVE B,TADR
	ADDI B,2000*16.
	ANDI B,-1
	CAIL B,-40000
	SUBI B,100000
	SKIPE LMOD
	JRST ATL1J
	CAIGE B,400000
	ADDI B,400000
	HRRZM B,NEWTADR'
ATL1J:	HRLI B,-16.
	SETZM REGNUM
	MOVE D,[MOVE A,(B)]
	MOVEI U3,RO+TPG2_-10.
	PUSHJ P,PGCSET
ATL1E:	XCT TINS
	CAMN A,TPG2+20
	JRST ATL1EA
	HRRZ F,B
	SUB F,NEWTADR
	ADD F,TADR
	.ERR ASSOC REGISTER NO #!REGNUM FAILED TO REFILL_
	OUTSTR [C(ERR)=*!A _]
	OUTSTR [C(OLD ADDRESS=#!F )=*!TESTW1 _]
	OUTSTR [C(NEW ADDRESS=#!B )=*!TESTW2 _]
	SETOM ERRF
	JRST ATLERR

ATL1EA:	ADDI B,1777
	AOS REGNUM
	AOBJN B,ATL1E

;TRY ADDRESSES THAT SHOULD REFILL

	MOVSI B,-16.
	HRR B,TADR
	SETZM REGNUM
	MOVE D,[MOVE A,(B)]
	MOVEI U3,RO+TPG1_-10.
	PUSHJ P,PGCSET
ATL1G:	XCT TINS
	CAMN A,TPG1+20
	JRST ATL1L
	HRRZ F,B
	SUB F,TADR
	ADD F,NEWTADR
	.ERR ASSOC REGISTER NO #!REGNUM FAILED TO REFILL _]
	OUTSTR [C(ERR)=*!A _]
	OUTSTR [C(OLD ADDRESS=#!F )=*!TESTW2 _]
	OUTSTR [C(NEW ADDRESS=#!B )=*!TESTW1 _]
	SETOM ERRF
	JRST ATLERR

ATL1L:	ADDI B,1777
	AOS REGNUM
	AOBJN B,ATL1G
ATLERR:	DATAI A
	TLNE A,100000
	JRST ATL1	;HOLD LOOP ERR OR NO
	SKIPGE ERRF
	JUMPL A,ATL1
	MOVEI A,2000
	ADD A,TADR
	ANDI A,-1
	CAIGE A,-40000
	JRST ATL1K
	MOVEI A,20
	SKIPN LMOD
	MOVEI A,400020
ATL1K:	MOVEM A,TADR
	SOJG LC,ATL1
	SKIPGE LMOD
	JRST ATLUX
	SETOM LMOD
	MOVEI A,20
	MOVEM A,TADR
	CLEARM PTS1+6
	MOVSI A,EXR
	ANDCAM A,PTS1+3
	MOVE A,[376,,PTSPT1]
	MOVEM A,PTS1+4
	ADDI A,100
	MOVEM A,PTS1+5
	MOVE A,[XCTR 1,D]
	JRST ATLU1

;Test address part of A, B, C memories

ATLUX:	NEXT
	CONO PI,CLKOFF
	X LPSET
CON1C:	TAG TESTING CONTENTS OF A MEMORY_
	SETOM LMOD
CON2A:	MOVSI B,-20
	MI U3,0	;NO ACCESS FOR 20 PAGES
	X PGSET
	M A,[20,,PTSPT1]
	MM A,PTS1+4
	SETOM XCTEM
CON2L:	LPMR PTS1
	MI A,100
CON1L:	M B,A
	LSH B,-10.
	IDIVI B,2
	LDB B,BPGWD(C)
	XCTR XRI,[M (A)]
	JRST .+2
	JRST CON1M

	LDB C,[121000,,A]
	.ERR XCTR DIDNT FAULT,AR NO #!C, ADR =#!A, PAGE WORD=#!B _
	JRST CONERR

CON1M:	SPM SP1
	HLLZ C,SP1+3
	TLNE C,FNACC
	JRST CON3L
	.ERR WRONG FAULT, SHOULD BE NO ACCESS, IS 
	X TYPFLT
	X CRR
	JRST CONERR

CON3L:	TLNN C,FONPR+FNXM+FDBL+FRDO+FRWF+FPURE+FMAR
	JRST CON4L
	.ERR EXTRA FAULT, SHOULD BE ONLY NACC, IS 
	X TYPFLT
	X CRR
	JRST CONERR

CON4L:	X GETMA	;BITS STORED FROM OUTPUT OF ASSOC REGISTER
	LDB C,[121000,,A]
	CAMN B,U3
	JRST CON5L
	.ERR WRONG CONTENTS OF AR #!C, OUTPUT =#!B, SHOULD BE #!U3 _
	JRST CONERR

CON5L:	ADDI A,2000
	CAIGE A,40000
	J CON1L
	AOSE XCTEM
	J CON1A
	MOVSI B,-20
	MI U3,HIGHEST_-10.		; All ones in Map output
	X PGCSET
	J CON2L

CON1A:	AOS A,LMOD
	CAILE A,1
	J CON1B
	MI B,20
	CLEARM PTS1+7
	DPB B,BCKEY(A)
	%TAG @CONTAG(A)
	J CON2A

CONERR:	OUTSTR [CONTINUE? ]
CONER3:	MOVEI B,100
	LPMR PTS1
CONER2:	XCTR XRI,[MOVE (B)]
	JFCL
	CAML B,A
	JRST CONER1
	ADDI B,2000
	JRST CONER2

CONER1:	CONSO TTY,40
	JRST CONER3
	X TYI
	CAIE A,"Y
	JRST GIVEUP
	JRST CONEXT

BPGWD:	222200,,PTSPT1(B)
	2200,,PTSPT1(B)

GETMA:	LDB C,[320500,,SP1+5]
	LDB B,[320500,,SP1+4]
	LSH C,5
	IOR B,C
	R

CONTAG:	[ASCIZ ?TESTING CONTENTS OF B MEMORY_?]
	[ASCIZ ?TESTING CONTENTS OF C MEMORY_?]

CON1B:	CLEARM PTS1+7
	SOJGE LC,CON1C

CONEXT:	NEXT
	TAG TESTING XCTR FETCHING USER AC'S FROM AC POINTER_
	PUSHJ P,LPSET
	LSH LC,3
XR2L:	MOVE A,LC
	DPB A,BCKEY
	LSH A,-5
	DPB A,BCKEY+1
	MOVSI B,-1
	MOVEI U3,RW+TPG_-10.
	PUSHJ P,PGCSET
	MOVE A,[2,,PTSPT1]
	MOVEM A,PTS1+4
	CLEARM PTS1+5
	CLEARM PTS1+6
	MI A,TACS
	DPB A,[2300,,PTS1+7]
	LPMR PTS1
	MI A,17
	MM A,TACS(A)
	SOJGE A,.-1
XR2:	MOVEI B,17
XR2A:	PUSHJ P,RAND
IFN A-1,	MOVE 1,A
	MOVEM A,XRAND
XR3:	XCTR XR,[MOVE C,(B)]
	SKIPA	;SHOULDNT SKIP IF NO FAULT
	JRST XR1
	CAME 1,XRAND
	ERRP [.ASCII /XCTR CLOBBERED C(AC), AC=*!A /]
	CAME C,TACS(B)
	ERRP [.ASCII /XCTR DIDN'T REFERENCE THROUGH AC POINTER CORRECTLY ADR= #!B /]
XR4:	SOJGE B,XR3
TAG XCTR C(FM)=>C(CORE)_
XCTR1I:	MOVSI 16,-15
	MOVEM 16,(16)
	SETOM TPG+100(16)
	MOVNM 16,TACS(16)	;SOMETUHING OTHER THAN CORRECT DATA
	AOBJN 16,.-3
	CLEARB 16,XCTEM
XCTR1L:	DPB 16,[400,,XCT1CM]
	DPB 16,[BAC,,XCT1CM]
	HRLS 16
	ADDI 16,100
	XCTR XW,[BLT 16,0]
	SKIPA
	ERR @ERTB
	XCT XCT1CM	;AC STORED OK?
	JRST XCT1E
	MI 16,1
	ADDB 16,XCTEM
	CAIGE 16,16
	J XCTR1L
XCTR2I:	TAG XCTR C(CORE)=>C(FM)_
	MI 0,0
	MI 16,1
	BLT 16,15	;CLEAR OUT ACS
	CLEARB 16,XCTEM
XCTR2L:	DPB 16,[400,,XCT1CM]
	DPB 16,[BAC,,XCT1CM]
	HRLI 16,100(16)	;USER ADDRESS
	XCTR XR,[BLT 16,0]
	SKIPA
	ERR @ERTB
	XCT XCT1CM
	J XCT2E
	MI 16,1
	ADDB 16,XCTEM
	CAIGE 16,16
	J XCTR2L
XCTR3I:	TAG XCTR C(CORE)=>C(CORE)_
	MI 16,TPG+100
	MM 16,(16)
	SETOM 100(16)
	CAIGE 16,TPG+177
	AOJA 16,.-3
	CLEARB 16,XCTEM
XCTR3L:	HRLI 15,100(16)
	HRRI 15,200(16)
	XCTR XRW,[BLT 15,0]
	SKIPA
	ERR @ERTB
	M A,TPG+100(16)
	M B,TPG+200(16)
	CAME A,B
	J XCTR3E
	MI 16,1
	ADDB 16,XCTEM
	CAIGE 16,100
	J XCTR3L
XCTR4I:	SETOM LMOD
XCTR4A:	MOVE A,LMOD
	%TAG @TAGTB+1(A)
	M A,[2,,[RW+TPG1_-10.,,0]]
	MM A,PTS1+6	;EXEC POINTER
	MOVSI A,4
	IORM A,PTS1+3
	LPMR PTS1
	MI 16,TPG+100
	MM 16,(16)
	SETOM TPG1-TPG(16)
	CAIGE 16,TPG+177
	AOJA 16,.-3
	MOVE A,[TPG+100,,400100]
	SKIPL LMOD
	JRST XCTR4B
	XCTR 0,[BLT A,400177]
	SKIPA
	ERR @ERTB
XCTR4C:	MOVEI 16,100
XCTR4L:	M A,TPG(16)
	M B,TPG1(16)
	CAME A,B
	JRST XCTR4E
	CAIGE 16,177
	AOJA 16,XCTR4L
	AOSG LMOD
	JRST XCTR4A
	CLEARM PTS1+6
	MOVSI A,4
	ANDCAM A,PTS1+3
	LPMR PTS1
XCTR5I:	TAG XCTR INDIRECT INDEXED MOVE_
	M A,[XCT5TC,,TACS]	;PUT POINTERS IN TACS TO CATCH REFERENCES
	BLT A,TACS+4
	PUSHJ P,RAND
	MM A,TPG+100
	MM A,XCTEM
	MOVSI 16,XCT5AC
	BLT 16,4
	XCTR XR,[MOVE 16,@(1)]
	SKIPA
	ERR @ERTB
	M 15,XCTEM
	CAME 16,15
.ERR C(C(C(1)=#1 )=#2 )=*15 => C(16)=*16
TAG XCTR OF READ/PAUSE/WRITE_
	SETOM 37
	PUSHJ P,RAND
	MOVEM A,XCTEM
	MM A,TPG+37
	MI A,0
	XCTR XRW,[ADDB A,37]
	SKIPA
	ERR @ERTB
	CAME A,XCTEM
XCTR6A:	.ERR C(AC)=*!A ,C(USER 37)=*!XCTEM _
;	PUSHJ P,RAND
;	MM A,TPG+37
;	MM A,XCTEM
;	MI A,0
;	XCTR XW,[ADDB A,37]
;	SKIPA
;	ERR @ERTB
;	CAME A,XCTEM
;	ERR @XCTR6A
TAG XCTR OF LDB_
	CLEARM 37
	M A,[112200,,100]
	MM A,TPG+37
	X RAND
	MM A,TPG+100
	LDB B,[112200,,A]
	XCTR XR,[LDB A,37]
	SKIPA
	ERR @ERTB
	CAME A,B
	.ERR LDB [112200,,100] C(100)=*!<TPG+100> C(AC)=*!A _
;TAG XCTR XW, DPB_
;	SETCM A,TPG+100
;	M B,TPG+100
;	DPB A,[2200,,B]
;	XCTR XW,[DPB A,[2200,,100]]
;	SKIPA
;	ERR @ERTB
;	M A,TPG+100
;	CAME A,B
;	.ERR DPB [2200,,100] C(100)=*!A ,SHOULD BE *!B _
TAG USER =>EXEC 400000_
	M A,[2,,[RW+TPG1_-10.,,0]]
	MM A,PTS1+6
	M A,[2,,[RW+TPG_-10.,,0]]
	MM A,PTS1+4
	MOVSI A,EXR
	IORM A,PTS1+3
	LPMR PTS1
	M A,[-100,,100]
	MM A,TPG(A)
	SETOM TPG1(A)
	AOBJN A,.-2
	M A,[100,,400100]
	XCTR XR,[BLT A,400177]
	SKIPA
	ERR @ERTB
	M A,[-100,,100]
XCTR7L:	M B,TPG(A)
	M C,TPG1(A)
	MI D,400000(A)
	CAME B,C
	.ERR C(USER #!A )=*!B =>C(EXEC #!D )=*!C _
	AOBJN A,XCTR7L
	M A,[-100,,200]
	MM A,TPG1(A)
	SETOM TPG(A)
	AOBJN A,.-2
	M A,[400200,,200]
	XCTR XW,[BLT A,277]
	SKIPA
	ERR @ERTB
	M A,[-100,,200]
XCTR8L:	M B,TPG1(A)
	M C,TPG(A)
	MI D,400000(A)
	CAME B,C
	.ERR C(EXEC #!D )=*!B => C(USER #!A )=*!C _
	AOBJN A,XCTR8L
	SOJG LC,XR2L

NEXT

BCTEST:	PUSHJ P,LPSET
	LSH LC,-3	;COMPENSATE FOR RUNNING TIME
	MOVEI U3,RO+TPG_-10.
	MOVSI B,-400
	PUSHJ P,PGCSET	;FILL ALL VIRTUAL MEMORY
BCT5A:	MOVEI T,0
BCT5:	SETOM LMOD	;LOSER MODE MEMORY FIRST
	MOVE A,[376,,PTSPT1]
	MOVEM A,PTS1+4	;LOW DBR
	ADDI A,100
	MOVEM A,PTS1+5	;HIGH DBR
	CLEARM PTS1+6
BCT1:	CLEARM BCPGNO	;PAGE NO OF KEY
	PUSHJ P,RAND
	MOVEM A,XRAND
	MOVEM A,TPG+105
BCT2:	MOVSI A,EXR
	SKIPN LMOD
	IORM A,PTS1+3
	SKIPE LMOD
	ANDCAM A,PTS1+3
	MOVE A,BCPGNO
	SKIPE LMOD
	TRO A,20
	DPB A,BCKEY(T)
	LSH A,14.	;FORM ADDRESS QUANITY
	HRLI A,-20	;CHECK 16. PAGES IN BC MEMORY
BCT4:	LPMR PTS1
	SKIPE LMOD
	XCTR XR,[MOVE B,105(A)]
	SKIPL LMOD
	MOVE B,105(A)
	CAME B,TPG+105
	ERRP [.ASCII /BCKEY, ADR=#!A /]
	SPM SP1
	LDB B,[250400,,SP1+2]	;RING BUFFER COUNTER
	JUMPE B,BCT3
	MOVE C,BCPGNO
	ERR @BCTBL(T)
BCT3:	ADDI A,1777
	AOBJN A,BCT4
	AOS A,BCPGNO
	CAIGE A,20
	JRST BCT2
	AOSE LMOD
	JRST BCT6
	CLEARM PTS1+4
	CLEARM PTS1+5
	MOVE A,[376,,PTSPT1]
	MOVEM A,PTS1+6
	MOVEI A,10
	MOVEM A,BCPGNO	;DO ONLY HIGH MEMORY FOR EXEC
	JRST BCT2

BCT6:	CAIGE T,1
	AOJA T,BCT5
	SOJGE LC,BCT5A
NEXT


	X LPSET
	LSH LC,3
FLT1I:	TAG LPMRI TEST FOR INTERRUPT_
	M A,LC
	DPB A,BCKEY
	LSH A,-5
	DPB A,BCKEY+1
	CLEARM LP1
	M A,[LP1,,LP1+1]
	BLT A,LP1+7
	MOVSI A,1
	MM A,LP1+3
	BRANCH .+3
	LPMRI LP1
	INTCHECK

	MOVSI A,1
	ANDCAM A,APRBP+3
	MOVSI A,-10
FLT1L:	M B,APRBP(A)
	M C,B
	AND B,MSK1(A)
	SKIPE B
	.ERR LPMRI WD #!A =0,STORED AS *!C _
	AOBJN A,FLT1L
	JSR INTFLS
TAG NACC FAULT TST_
	CLEARM PTS1+5
	CLEARM PTS1+6
	MOVSI A,4
	ANDCAM A,PTS1+3
	CLEARM PTSPT1
	M A,[PTSPT1,,PTSPT1+1]
	BLT A,PTSPT1+177
	M A,[376,,PTSPT1]
	MM A,PTS1+4
	LPMR PTS1
	MOVEI A,20
FLT2L:	BRANCH .+3
	XCTR XR,[CAM (A)]
	INTCHECK

	HLRZ B,APRBP+3
	TRZ B,5
	LDB C,[250400,,APRBP+2]
	HLRZ D,APRBP+3
	CAIE B,1010	;NACC
	.ERR WRONG FAULT, ADR=#!A ,STATUS=#!D , RBC=#!C _
	LDB E,[221100,,APRBP]
	LDB C,[121000,,A]
	TRO C,400	;USER
	CAME E,C
	.ERR WRONG FAULT PAGE NO., ADR=#!A ,PAGE NO. =#!E _
	MOVSI B,1010
	ANDCAM B,APRBP+3
	LPM APRBP
	JSR INTFLS
	ADDI A,2000	;TRY NEXT ASSOC REGISTER
	CAIGE A,2000*16.+20
	JRST FLT2L

TAG DBRL FAULT TEST_
	BRANCH .+3
	XCTR XR,[CAM -1]
	INTCHECK

	HLRZ B,APRBP+3
	M D,B
	TRZ B,5
	CAIE B,1200
FLT2P:	.ERR WRONG FAULT, STATUS=#!D _
	LDB E,[221100,,APRBP]
	CAIE E,777
	.ERR WRONG FAULT PAGE NO. ADR=777777 PAGE NO.=#!E _
	MOVSI B,1200
	ANDCAM B,APRBP+3
	LPM APRBP
	JSR INTFLS
TAG READ ONLY FAULT TEST_
	MOVSI B,-1
	MI U3,RO+TPG_-10.
	X PGCSET
	LPMR PTS1
	BRANCH FLT3A
	XCTR XW,[MM 20]
	INTCHECK

FLT3A:	HLRZ A,APRBP+3
	M D,A
	TRZ A,5
	CAIE A,1100
	ERR @FLT2P
	MOVSI B,1100
	ANDCAM B,APRBP+3
	LPM APRBP
	JSR INTFLS
TAG READ WRITE FIRST FAULT TEST_
	MOVSI B,-1
	MI U3,RWF+TPG_-10.
	X PGCSET
	LPMR PTS1
	BRANCH FLT4A
	XCTR XW,[MM 20]
	INTCHECK

FLT4A:	HLRZ A,APRBP+3
	M D,A
	TRZ A,5
	CAIE A,1040
	ERR @FLT2P
	MOVSI B,1040
	ANDCAM B,APRBP+3
	LPM APRBP
	JSR INTFLS

TAG PAGE ILM TEST_
	HRRO A,MEMSIZ
	AOJE A,FLT5I		;Not enough ILM available
	HRLI A,2
	MM A,PTS1+5
	LPMR PTS1
	BRANCH .+3
	XCTR XR,[CAM 400000]
	INTCHECK

	HLRZ A,APRBP+3
	M D,A
	TRZ A,5
	CAIE A,400
	ERR @FLT2P
	CONSO 10000
	.ERR PAGE TABLE ILM DIDNT SET PROCESSOR NXM FLAG_
	CONO 10000+APRCHN
	JSR INTFLS
	CLEARM PTS1+5
	CLEARM PTS1+6
	MOVSI A,4
	ANDCAM A,PTS1+3
	LPMR PTS1
	HRRO A,MEMSIZ
	AOJE A,FLT5I
	BRANCH .+3
	SPM (A)
	INTCHECK

	HLRZ A,APRBP+3
	M D,A
	TRZ A,5
	CAIE A,400
	ERR @FLT2P
	JSR INTFLS

FLT5I:	TAG PURE CODE TEST_
	LPMR PTS1
	JRST 2,@[PURE,,.+1]
	JSP A,.+1
	TLNN A,PURE
	.ERR PURE BIT DIDN'T SET IN PC =*!A _
	MOVE A,[JSR PURET]
	MOVEM A,46
	CONO PI,6220
	JRST 4,.

PURET:	0
	JRST 10,.+1
	CONO PI,1020
	MOVE A,PURET
	TLNN A,PURE
	.ERR PURE BIT WASN'T STORED BY INTERRUPT, PC=*!A _
	JSP A,.+1
	TLNE A,PURE
	.ERR PURE BIT DIDN'T CLEAR IN PC =*!A _
	CLEARM PTS1+5
	M A,[2,,[RO+TPG_-10.,,0]]
	MM A,PTS1+4
	M A,[SOJGE A,100]
	MM A,TPG+100
	M A,[M 400000]
	MM A,TPG+101
	M A,[ERR [.ASCII /FAULT FROM USER MODE FAILED_/]]
	MM A,TPG+102
	MM A,TPG+103
	LPMR PTS1
	MI A,100.
	BRANCH .+2
	JRST 2,@[LSRMOD+PURE,,100]

	HLRZ B,APRBP+3
	TRZ B,5
	CAIE B,1200
	ERR @FLT2P
	HRRZ B,APRBP+1
	CAIE B,101
FLT5P:	.ERR WRONG INSTRUCTION FAULTED, OPC=#!B _
	JSR INTFLS
	M A,[2,,[RWF+TPG_-10.,,0]]
	MM A,PTS1+4
	LPMR PTS1
	MI A,100.
	BRANCH .+2
	JRST 2,@[LSRMOD+PURE,,100]

	HLRZ B,APRBP+3
	TRZ B,5
	CAIE B,1020
	ERR @FLT2P
	HRRZ B,APRBP+1
	CAIE B,100
	ERR @FLT5P
	JSR INTFLS
	M A,[2,,[RW+TPG_-10.,,0]]
	MM A,PTS1+4
	LPMR PTS1
	MI A,10000.
	BRANCH .+2
	JRST 2,@[LSRMOD+PURE,,100]

	HLRZ B,APRBP+3
	TRZ B,5
	CAIE B,1020
	ERR @FLT2P
	HRRZ B,APRBP+1
	CAIE B,100
	ERR @FLT5P
	JSR INTFLS
	SOJGE LC,FLT5I


NEXT
	X LPSET
	LSH LC,-6
OPC1I:	MOVEM LC,LCM'
	M A,[376,,PTSPT1]
	MM A,PTS1+4
	M A,[376,,PTSPT1+100]
	MM A,PTS1+5
	CLEARM PTS1+6
	MOVSI A,EXR
	ANDCAM A,PTS1+3
	CLEARM PTSPT1
	M A,[PTSPT1,,PTSPT1+1]
	BLT A,PTSPT1+177
	LPMR PTS1
	TAG TESTING OPC _
	MI A,37
OPC1A:	M B,A
	HRLI B,LSRMOD
	BRANCH .+2
	JRST 2,@B
	HRRZ B,APRBP+1
	CAME B,A
	.ERR OPC INCORRECT, OPC=#!B, SHOULD BE #!A _
	JSR INTFLS
	LSH A,1
	TRO A,1
	TLNN A,1
	JRST OPC1A
	TAG TESTING OPC FLAGS _
	MI A,40	;FIRST FLAG
OPC2A:	HRL B,A
	HRRI B,100
	TLO B,LSRMOD
	BRANCH .+2
	JRST 2,@B

	HLRZ B,APRBP+1
	LSH B,5
	ANDI B,PCBITS
	M C,A
	ANDI C,PCBITS	;BITS THAT ARE USED
	TRO C,LSRMOD
	CAME B,C
	.ERR PC LEFT HALF =#!B, SHOULD BE #!C _
	JSR INTFLS
	LSH A,1
	TLNN A,1
	JRST OPC2A

TAG TESTING BIS FLAG _
BIS1I:	MI U3,RW+TPG_-10.
	MOVSI B,-1
	X PGCSET
	LPMR PTS1
	M A,[IDPB 110]
	MM A,TPG+100
	M A,[M 400000]
	MM A,TPG+101
	MI A,400000
	MM A,TPG+110
	BRANCH .+2
	JRST 1,100
	HRRZ A,APRBP+1
	CAIE A,100
	.ERR IDPB W/BYTE PNTR ILLEGAL WRONG PC,=#!A _
	HLRZ A,APRBP+1
	LSH A,5
	TRNN A,BIS
	.ERR BIS FLAG NOT SET IN OPC _
	JSR INTFLS
	M A,[IDPB 400000]
	MM A,TPG+100
	BRANCH .+2
	JRST 1,100

	HRRZ A,APRBP+1
	CAIE A,100
	.ERR IDPB W/ILL ADR WRONG PC =#!A _
	HLRZ A,APRBP+1
	LSH A,5
	TRNE A,BIS
	.ERR BIS FLAG SET IN OPC BEFORE IBP _
	JSR INTFLS

TAG TESTING PUSH INSTRUCTIONS _
PSH1I:	M A,[PUSH 16,]
	MM A,TPG+100
	MI 16,2000-1
	BRANCH .+2
	JRST 1,100

	HRRZ A,APRBP+1
	CAIE A,100
	.ERR PUSH HAD WRONG OPC =#!A _
	CAIE 16,2000-1
	.ERR PUSH CLOBBERED AC =#16 SHOULD BE 1777_
	JSR INTFLS
	M A,[POP 16,400000]
	MM A,TPG+100
	M 16,[-1,,200]
	BRANCH .+2
	JRST 1,100

	HRRZ A,APRBP+1
	CAIE A,100
	.ERR POP WITH WRONG OPC =#!A _
	CAME 16,[-1,,200]
	.ERR POP CLOBBERED AC =#16, SHOULD BE -1,,200 _
	JSR INTFLS
	M A,[PUSHJ 16,400]
	MM A,TPG+100
	MI 16,2000-1
	BRANCH .+2
	JRST 1,100

	HRRZ A,APRBP+1
	CAIE A,100
	.ERR PUSHJ W/WRONG OPC =#!A _
	CAIE 16,2000-1
	.ERR PUSHJ CLOBBER PC=#16, SHOULD BE 1777 _
	JSR INTFLS

TAG TESTING BLT _
BLT1I:	M A,[BLT 16,377]
	MM A,TPG+100
	M 16,[2000-100,,200]
	BRANCH .+2
	JRST 1,100

	HRRZ A,APRBP+1
	CAIE A,100
BLT1P:	.ERR WRONG PC=#!A SHOULD BE 100_
	CAME 16,[2000,,300]
	.ERR BLT AC STORED INCORRECT =#16, SHOULD BE 2000,,300 _
	JSR INTFLS
	M A,[BLT 16,2077]
	MM A,TPG+100
	M 16,[200,,2000-100]
	BRANCH .+2
	JRST 1,100

	HRRZ A,APRBP+1
	CAIE A,100
	ERR @BLT1P
	CAME 16,[300,,2000]
	.ERR BLT AC STORED INCORRECT =#16, SHOULD BE 300,,2000 _
	JSR INTFLS

TAG TESTING PI TRAP _
	M A,[MM 400000]
	MM A,TPG+1775
	M A,[ERR [.ASCII /FAULTED INS DIDNT SKIP _/]]
	MM A,TPG+1776
	M A,[CONO PI,6220]
	MM A,TPG+1777
	MI U3,RO
	DPB U3,[222200,,PTSPT1+100]
	LPMR PTS1
	CONO	;DISABLE TRAPS TO PROCESSOR
	M A,[JSR PIT1A]
	MM A,46
	JRST 2,@[LSRMOD+IOTLSR,,1775]

PIT1A:	0
	SPM APRBP
	HRRZ A,APRBP+1
	CAIE A,1777
	ERR @BLT1P
	HLRZ A,APRBP+3
	TRNE A,10
PIT2P:	.ERR PI DIDNT TRAP BEFORE NEXT INSTRUCTION _
	MOVSI A,1110
	ANDCAM A,APRBP+3
	LPM APRBP
	JRST 10,.+1
	MI A,PIT2A
	HRRM A,46
	JRST 12,@[LSRMOD+IOTLSR,,1777]

PIT2A:	0
	SPM APRBP
	HRRZ A,APRBP+1
	CAIE A,1777
	ERR @BLT1P
	HRRZ A,PIT2A
	CAIE A,2000
	.ERR INTERRUPT FROM #!A, SHOULD BE 2000_
	HLRZ A,APRBP+3
	TRNE A,1110
	ERR @PIT2P
	MOVSI A,1110
	ANDCAM A,APRBP+3
	LPM APRBP
	JRST 10,.+1
	MI A,PIT3A
	HRRM A,46
	CONO 20000
	JRST 2,@[LSRMOD+IOTLSR,,1777]

PIT3A:	0
	HRRZ A,PIT3A
	CAIE A,2002
	.ERR INTERRUPTED FROM #!A, SHOULD BE 2002_
	CONSO 20000
	.ERR MEM PROT FLAG DIDNT GET SET _
	CONO 20000+APRCHN
	JRST 10,.+1

	CLEARM PTS1+6
	MOVSI A,EXR
	IORM A,PTS1+3
	LPMR PTS1
	BRANCH .+3
	M 400000
	INTCHECK

	LDB A,[221100,,APRBP]
	CAIE A,200
	.ERR FAULT PAGE NO =#!A, SHOULD BE 200 _
	JSR INTFLS
	BRANCH .+3
	M -1
	INTCHECK

	LDB A,[221100,,APRBP]
	CAIE A,377
	.ERR FAULT PAGE NO. =#!A, SHOULD BE 377 _
	JSR INTFLS

	MOVSI A,EXR
	ANDCAM A,PTS1+3
	LPMR PTS1
TAG TESTING AGE REGISTER _
	MOVSI B,-2
	MI U3,RW+TPG_-10.
	X PGCSET
	MI A,7
	DPB A,[B.AGE,,PTS1]
	LPMR PTS1
	XCTR XR,[M 100]
	SKIPA
	ERR @ERTB
	M A,PTSPT1
	M B,[RW+TPG_-10.,,RW+TPG_-10.]
	MM B,XCTEM
	MOVEI C,17
	DPB C,[B.AGE,,B]
	CAME A,B
AGE1P:	.ERR AGE STORED INCORRECT =*!A,SHOULD BE *!B _
	LPMR PTS1
	MI A,0
	DPB A,[B.AGE,,PTSPT1]
	XCTR XR,[M 2100]
	SKIPA
	ERR @ERTB
	M B,XCTEM
	MOVEI C,17
	DPB C,[B.AGE1,,B]
	M A,PTSPT1
	CAME A,B
	ERR @AGE1P
	MM B,PTSPT1
	MI A,0
	DPB A,[B.AGE,,PTS1]
	LPMR PTS1
	XCTR XR,[M 100]
	SKIPA
	ERR @ERTB
	M B,XCTEM
	MI C,17
	DPB C,[B.AGE1,,B]
	M A,PTSPT1
	CAME A,B
	ERR @AGE1P
	LPMR PTS1
	XCTR XR,[M 2100]
	SKIPA
	ERR @ERTB
	M B,XCTEM
	M A,PTSPT1
	CAME A,B
	ERR @AGE1P

TAG TESTING JPC _
	MI B,4
	MI U3,RW
	M U2,[442200,,PTSPT1]
	IDPB U3,U2
	AOS U3
	SOJG B,.-2	;MAP BOTTOM 4K TO SELF
	CLEARM PTSPT1+2
	M A,[PTSPT1+2,,PTSPT1+3]
	BLT A,PTSPT1+177
	MOVNI A,1
	HRRM A,PTS1
	LPMR PTS1
	BRANCH JPC1A
	JRST 1,.+1
	M 400000
JPC1P:	.ERR MPV DIDNT FAULT _

JPC1A:	HRRZ A,APRBP
	CAIE A,-1
	.ERR JPC CHANGED, WAS -1 NOW #!A _
	JSR INTFLS
	BRANCH JPC2A
	JRST 1,.+1
JPC1IN:	JRST .+1
	M 400000
	ERR @JPC1P

JPC2A:	HRRZ A,APRBP
	CAIE A,JPC1IN
	.ERR JPC WRONG, SHOULD BE !JPC1IN, IS #!A _
	JSR INTFLS
	BRANCH JPC3A
	MI A,DMYUUO
	HRRM A,41
	JRST 1,JPC2IN
DMYUUO:	0
	JRST 2,@DMYUUO
JPC2IN:	JRST .+1
	47000,,0
	M 400000
	MOVEI A,UUOH
	HRRM A,41
	ERR @JPC1P
JPC3A:	MOVEI A,UUOH
	HRRM A,41
	HRRZ A,APRBP
	CAIE A,JPC2IN
	.ERR JPC SHOULD BE !JPC2IN, IS #!A _
	JSR INTFLS
	M A,[JRST B]
	M B,[M 400000]
	BRANCH .+2
	JRST 1,A

	HRRZ A,APRBP
	CAIE A,A
	.ERR JPC SHOULD BE !A, IS #!A _
	JSR INTFLS
JPC3B:	IFGE .-10000,[PRINTX /PRGM GREW TO BIG AT JPC3B
/]	;ONLY BOTTOM 4K MAPPED TO SELF

TAG TESTING MAR _
	MI A,400
	MI U3,RW+TPG_-10.
	M B,[442200,,PTSPT1]
	IDPB U3,B
	SOJG A,.-1
	CLEARM OPPNR
	MI A,4
	MI U3,RO
	M B,[442200,,PTSPT1]
	IDPB U3,B
	AOS U3
	SOJG A,.-2
	M A,[4,,100]	;USER, NEVER CONDITION
	MM A,PTS1+2
	LPMR PTS1
	M 100	;TEST
	BRANCH MAR1A
	JRST 1,.+1
	M 100
	M U1,RAND1
	M U2,RAND2
	MI U3,100.
	FMP U1,U2
	M (U1)
	SOJG U3,.-2
	MM 77
	ERR @JPC1P

MAR1A:	HLRZ A,APRBP+3
	TRNE A,2
	.ERR MAR INT C(MAR)=*!<APRBP+2> -ADR =#!U1 _
	JSR INTFLS
	M A,[6,,TPG+77]	;USER, WRITE
	MM A,PTS1+2
	LPMR PTS1
	MM TPG+77
	M TPG+77
	BRANCH MAR2A
	JRST 1,.+1
	M TPG+77
MAR1IN:	MM TPG+77
	JFCL
MAR1P:	.ERR MAR DIDNT INTERRUPT

MAR2A:	HRRZ A,APRBP+1
	M B,APRBP+2
	CAIE A,MAR1IN
	.ERR MAR INT AT WRONG TIME, OPC=#!A MAR=*!B _
	HLRZ A,APRBP+3
	M B,A
	TRZ A,5
	CAIE A,2
	.ERR WRONG FAULT, STATUS =#!B _
	JSR INTFLS
	BRANCH MAR3A
	M A,[5,,MARFOO]	;USER, INSTRUCTION FETCH
	MM A,PTS1+2
	LPMR PTS1
	M A,[MARLUP,,B]
	BLT A,MAREND
	JRST 1,B
MARLUP:	OFFSET B-.
	M MARFOO
	MM MARFOO
MARFOO:	JFCL
MAREND:	ERR @MAR1P
	OFFSET 0
MARFOO==MARFOO
MAREND==MAREND

MAR3A:	HRRZ A,APRBP+1
	M B,APRBP+2
	CAIE A,MARFOO
MAR3P:	.ERR WRONG OPC FOR MAR,OPC=#!A, MAR=#!B _
	JSR INTFLS
	M A,[7,,TPG+100]	;USER, ANY REFERENCE
	MM A,PTS1+2
	LPMR PTS1
	BRANCH MAR4A
	XCTR XW,[M TPG+100]
	XCTR XR,[MM TPG+100]
MAR4IN:	XCTR XR,[M TPG+100]
	ERR @MAR1P

MAR4A:	HRRZ A,APRBP+1
	M B,APRBP+2
	CAIE A,MAR4IN
	ERR @MAR3P
	JSR INTFLS
	MI A,100
	MM A,XCTEM
MAR4B:	X RAND
	ANDI A,-1
	CAIGE A,MAR5C
	CAIGE A,MAR4D
	CAIG A,B
	JRST MAR4B	;AVOID LOCN REFERENCED BY TEST PRGM
	MM A,XRAND
	HRLI A,7
	MM A,PTS1+2
	LPMR PTS1
	M B,A
	AND B,MEMSIZ
	M (B)
	BRANCH MAR5A
	JRST 1,.+1
MAR4D:	MI B,1
MAR4L:	XOR A,B
MAR4C:	M (A)
	XOR A,B
	LSH B,1
	TLNN B,1
	JRST MAR4L
MAR5M:	M (A)
	ERR @MAR1P

MAR5C:	HRRZ D,XRAND
	.ERR MAR SET TO #!D, INT ON #!A _
	J MAR5D

MAR5A:	HLRZ C,APRBP+3
	TRZ C,5
	CAIN C,2
	JRST MAR5AA
	.ERR RANDOM FAULT, STATUS=
	HLLZ C,APRBP+3
	X TYPFLT
	X CRR
MAR5AA:	HRRZ C,APRBP+1
	CAIN C,MAR4C
	JRST MAR5C
	M B,APRBP+2
	CAIE C,MAR5M
	ERR @MAR3P
MAR5D:	JSR INTFLS
	SOSLE XCTEM
	J MAR4B
	M A,[3,,100]
	MM A,PTS1+2
	LPMR PTS1
	MI B,1
	BRANCH MAR6A
MAR5B:	XOR A,B
	M (A)
	XOR A,B
	LSH B,1
	CAMGE B,MEMSIZ
	TLNE B,1
	SKIPA
	JRST MAR5B
	XCTR XR,[M (A)]
MAR5IN:	M (A)
	ERR @MAR1P

MAR6A:	HRRZ A,APRBP+1
	M B,APRBP+2
	CAIE A,MAR5IN
	ERR @MAR3P
	JSR INTFLS
	CLEARM PTS1+2
	MOVSI A,EXR+1
	MOVEM A,PTS1+3
	LPMR PTS1

IFN QT,[
	DATAI A
	ANDI A,7
	AND A,PASSS
	JUMPN A,QUANX
	SKIPE LCM	;ONLY ON LAST TIME THROUGH
	JRST QUANX
TAG TESTING QUANTUM TIMER _
	HRLOI A,1
	ANDCAM A,PTS1+3
	BRANCH QUAN1A
	CLEARM XCTEM
	CONO 1000+APRCHN
	CONSO 1000
	JRST .-1
	CONO 1000+APRCHN
	LPMR PTS1
	CONSO 1000
	JRST .-1
QUAN2B:	SPM SP1	;SHOULD GET HRE BEFORE INTERRUPT
	SETOM XCTEM
	MOVEI A,400000
	SOJG A,.
	.ERR QUANTUM TIMER DIDNT INTERRUPT_
	JRST QUANX
QUAN2C:	MOVSI A,1+EXR
	MM A,PTS1+3
	LPMR PTS1
	JSR INTFLS
	HRRZ A,SP1+3
	MM A,QTIME
	M B,A
	SUBI A,16666.
	MOVMS A
	CAIL A,16666./50.	;2%
	J QUAN3A
	M A,[JSR QUAN2A]
	MM A,46
	HRLOI A,1
	ANDCAM A,PTS1+3
	LPMR PTS1
	CONO PI,6220
	JRST 4,.

QUAN1A:	AOSN XCTEM
	JRST QUAN2C
	HLRZ A,APRBP+3
	TRNE A,1
	.ERR QUANT INTERRUPT BEFORE 16 MS._
	TRNE A,-1#EXR#1
	.ERR RANDOM FAULT, STATUS =
	HLLZ C,APRBP+3
	X TYPFLT
	X CRR
	JSR INTFLS
	J QUAN2B

QUAN3A:	.ERR QUANTUM TIMER OFF, !16666. =#!B LOCN OF TIME =!QTIME _
	CLEARM PTS1+3
QUAN3B:	CONO 1000
	CONSO 1000
	JRST .-1
	LPMR PTS1
	CONO 1000
	CONSO 1000
	JRST .-1
	SPM SP1
	M A,SP1 3
	HRRM A,QTIME
	J QUAN3B

QUAN2A:	0
	SPM SP1
	HRRZ A,SP1+3
	CAILE A,10.
	.ERR QUAN DIDNT STOP SOON ENUF =#!A _
	MI B,100.
	SOJG B,.
	SPM SP1
	HRRZ B,SP1+3
	CAME A,B
	.ERR QUAN COUNTING PI IN PROGRESS #!A, TO #!B _
]
;ONE PROCEED

QUANX:	CONO 40000+APRCHN
	MOVSI A,1
	IORM A,PTS1+3
	LPMR PTS1
	JRST 10,.+1
TAG TESTING ONE PROCEED_
	CONO PI,CLKOFF
	MOVE A,[JSR ONEPIH]
	MOVEM A,50
	CONO PI,6210
	JRST 4,.
ONEPIH:	0
	MOVEI A,ONPRET
	HRRM A,50
	CONO PTR,14
	JRST 12,@[ONEPR,,.+1]
	JRST 4,.

ONPRET:	0
	JSP B,.+1
	MOVE A,ONPRET
	TLNN A,ONEPR
	.ERR ONEPROCEED NOT STORED BY INTERRUPT, PC=*!A _
	TLNE B,ONEPR
	.ERR ONEPROCEED NOT CLEARED BY TRAP, PC=*!B _
	SPM SP1
	HLLZ C,SP1+3
	TLNE C,FONPR
	.ERR ONE PROCEED TRAP FOLLOWED INTERUPT, SHOULD HAVE BEEN CLEAR_
	CONO 20000+APRCHN
	CONO PTR,0
	CONO PI,1010
	MI A,-6
	DPB A,[2300,,PTS1+3]
	LPMR PTS1
	MI A,DMYUUO
	HRRM A,41
	MI A,ONP1L
	MM A,XCTEM
	MOVEI A,ONP1A
	MOVEM A,INTLOC
	CONO PI,CLKON
	JRST 12,@[ONEPR,,ONP1L]

ONP1L:	MI 1,40
ONP2L:	M
	MM
	47000,,0
	MOVEI
	BLT 16
	MI 16,10
	PUSHJ 16,.+1
	JRST .+1
	MI 11,.+2
	POPJ 16,
ONP3L:	SOJG 1,ONP2L
ONP3B:	JFCL
	CONO PI,CLKOFF
	CLEARM INTLOC
	MI A,UUOH
	HRRM A,41
	.ERR NO ONE PROCEED INTERRUPT_

ONP3A:	MOVSI A,1
	DPB A,[2300,,PTS1+3]
	LPMR PTS1
	JSR INTFLS
	MI A,UUOH
	HRRM A,41
	MOVE LC,LCM'
	SOJGE LC,OPC1I
	AOS PASSS
	JRST BEGLUP


ONP1A:	MI A,UUOH
	HRRM A,41
	HLRZ A,APRBP+3
	TRNN A,FFAULT
	JRST ONP1B
	.ERR RANDOM FAULT, STATUS=
	HLLZ C,APRBP+3
	X TYPFLT
	X CRR
ONP1B:	TRNN A,FONPR
	JRST ONP2A
	HLRZ C,APRBRK
	TRNE C,ONEPR
	.ERR ONE PROCEED BIT STILL SET IN PC_
	HRRZ A,APRBRK
	CAIN A,ONP3B+1
	JRST ONP3A
	M B,XCTEM
	AOS B
	CAIN A,DMYUUO+1
	J ONP4A
	CAME A,B
	CAIN B,ONP3L+1
	JRST ONP2B
	.ERR PC SHOULD BE #!B, IS #!A _
ONP2B:	HRRZM A,XCTEM
	MOVSI A,ONEPR
	IORM A,APRBRK
ONP2C:	MOVSI A,2000
	ANDCAM A,APRBP+3
	LPMR APRBP
ONP2A:	MI C,DMYUUOH
	HRRM C,41
	HLRZ A,APRBP+3
	TRNN A,1
	JRST APRBK2
	CONO 40000+APRCHN
	MI A,-6
	DPB A,[2300,,APRBP+3]
	LPMR APRBP
	JRST APRBK2

ONP4A:	HRRZ A,DMYUUO
	CAME A,B
	.ERR UUO FROM WRONG LOC =#!A, SHOULD BE #!B _
	HRRZM A,XCTEM
	HLRZ C,DMYUUO
	TRNE C,ONEPR
	.ERR UUO LEFT ONE-PROCCED BIT, LH PC=#!C _
	MOVSI C,ONEPR
	IORM C,DMYUUO
	J ONP2C

BCTBL:	[.ASCII /B KEY FAILED TP MATCH
ADR= #!A , B KEY=#!C , RBC=#!B /]
	[.ASCII /C KEY FAILED TP MATCH
ADR= #!A , C KEY=#!C , RBC=#!B /]

TAGADR:	0	;ADDRESS OF ASCII AT LAST TAG UUO
TAGPC:	0	;PC OF LAST TAG UUO
XCTEM:	0
XCT1CM:	CAME 0,TPG+100

XCT1E:	MOVSS 16
XCT2E:	M A,(16)
	MOVSS 16
	M B,TPG(16)
	HLRZ C,16	;AC ADR
	HRRZ D,16	;CORE ADDRESS
	MOVEI E,TPG(D)
ERR [.ASCII ?C(AC #!C )=*!A ,VIRTUAL E=#!D, REAL E=#!E,
C(E)=*!B_?]
	ERRLUP XCTR1I
	J XCTR3I

XCTR3E:	MI C,100(16)
	MI D,200(16)
.ERR C(E=*!C )=#!A STORED IN C(E=*!D )=#!B _
	J XCTR4I

XCTR4B:	BLT A,400177
	SKIPA
	.ERR BLT TO EXEC 400000 SKIPPED
	J XCTR4C

XCT5TC:	-1
	3
	4
	4
	-1

XCT5AC:	-1
	2
	100
	4
	-1

ERTB:	[ASCIZ /XCTR SKIPPED WITHIUT FAULT_/]
TAGTB:	[ASCIZ ?BLT C(EXEC) => C(REL EXEC)_?]
	[ASCIZ ?XCTR 0,BLT C(EXEC)=> C(REL EXEC)_?]
XCTR4E:	MI C,TPG(16)
	MI D,400000(16)
.ERR C(#!C )=*!A => C(#!D )=*!B _
	J XCTR5I

XR1:	ERR [ASCIZ /XCTR FAULTED WITHOUT INTERRUPT /]
	SPM SP1
	MOVEI A,XR1A
	MOVEM A,SP1+1	;OPC SET TO FAULT
XR1A:	LPMRI SP1
	JRST XR4

NEXTR:	0
	SETZM PTS1
	MOVE A,[PTS1,,PTS1+1]
	BLT A,PTS1+7
	SETZM PSW
	MOVE A,[PSW,,PSW+1]
	BLT A,PSW+7
	MOVSI A,1
	MOVEM A,PTS1+3
	LPMR PTS1
	CONO 675550+APRCHN
	SETZM ERRCNT'
	MI P,PDL-1
	CLEARM TAGADR
	CONO PI,10000+CLKON
	CLEARM INTLOC
	MI A,UUOH
	HRRM A,41
	CLEARM PTS1
	M A,[PTS1,,PTS1+1]
	BLT A,PTS1+7
	MOVSI A,1
	MM A,PTS1+3
	LPMR PTS1
	DATAI C
	LSH C,-3
	ANDI C,77
	JUMPE C,@NEXTR
	MI A,100
	MI D,0
NXTL1:	M B,(A)
	CAIL A,NEXTR
	J NXTL2
	CAME B,[JSR NEXTR]
	AOJA A,NXTL1
	M E,A
	AOS D
	CAMN C,D
	JRST 1(A)
	AOJA A,NXTL1

NXTL2:	SKIPN D
	JRST 4,.
	JRST 1(E)

GETDDT:	OUTSTR [TYPE DDT LOCATION OR CR ]
GETDD1:	MOVEI F,0
GETDDL:	X TYI
	CAIN A,15
	JUMPE F,NODDT
	CAIN A,15
	JRST GOTDDT
	CAIG A,"7
	CAIGE A,"0
	JRST DDTERR
	IMULI F,10
	ADDI F,-"0(A)
	JRST GETDDL

DDTERR:	OUTSTR [? ]
	JRST GETDD1

;U3 HAS PAGE BITS WANTED
;B HAS -# OF PAGES,,FIRST ADDRESS
PGCSET:	SKIPL E,OPPNR
	JRST PGSET
	MOVEI U2,0
	PUSHJ P,PGST1
PGSET:	MOVEM B,OPPNR
	MOVE E,B
	MOVE U2,U3
PGST1:	HRRZ U1,E
	LSH U1,-11.
	HRLI U1,442200
	TRNE E,2000
	HRLI U1,222200
	ADDI U1,PTSPT1
	IDPB U2,U1
	AOBJN E,.-1
	POPJ P,

UMAPS:	CLEARM UMAP	;CLEAR PREV MAP
	MOVE U1,[UMAP,,UMAP+1]	;SET UP USER MAP
	BLT U1,UMAP+200-1	;CLEAR OUT PREV MAP
UMAPM:	MOVEI U1,RW	;MERGE
	MOVEI LC,16.
	MOVE U2,[442200,,UMAP]
	IDPB U1,U2
	AOS U1
	SOJG LC,.-2	;MAP BOTTOM 16K TO ITSELF
;FROM MEM ADR IN LH A, TO MEM ADR IN RH A MAP B CONSEC PAGES
	LSH A,-10.	;CONVERT MEM ADRS TO PG NOS
	HLRZ C,A
	LSHC C,-1
	HRLI C,222200
	SKIPL D
	HRLI C,442200
	ADDI C,UMAP
UMAPAC:	TRO A,RW	;ACCESS CONTROL
	IDPB A,C
	AOS A
	SOJG B,.-2
	LPMR UMPP
	POPJ P,


ATL1H:	CAME A,TPG+20
	JRST ATL1H1
	ERRP [.ASCII ? GOT OLD DATA ADR #!B ?]
	JRST ATL1L

ATL1H1:	ERR [.ASCII ? G *!A ADR #!B 
?]
	SETOM ERRF
	JRST ATL1L

UMPP:	0
	0
	0
	EXR+1,,
	376,,UMAP
	376,,UMAP+100
	376,,UMAP+100
	TACS

TACS:	REPEAT 16.,.RPCNT+1


UMAP:	BLOCK 200

UTEST:	CONO PI,12200+200_<-APRCHN>
	CONO 635550+APRCHN
	MOVEI P,PDL
	LPMR UPG
	XCTR 3,UINS
	SKIPE DDTLOC
	JRST @DDTLOC
	JRST 4,UTEST

UINS:	JFCL
MBYDDT:	MOVEI P,PDL
	MOVE A,[770000,,30000]
	MOVEI B,4
	PUSHJ P,UMAPS
	JRST 2,@[14000,,774000]

RAND:	MOVE U1,RAND1
	FMPRM U1,RAND2
	MOVE A,RAND2
	FMPRB U1,RAND2
	HRL A,U1
	POPJ P,

RAND1:	SIXBIT /FOOBAR/
RAND2:	(105*105)105+105+1

LPSET:	MOVEI LC,100
	DATAI A
	ANDI A,7
	MOVNS A
	LSH LC,7(A)
	POPJ P,


UUOH:	0
	CONI PI,PISAV'
	CONO PI,CLKOFF
	MOVEM 17,UACS+17
	LDB 17,[331100,,40]
	CAIN 17,%TAG_-27.
	JRST ATAG
	CAIN 17,BRANCH_-27.
	JRST ABRANCH
	MOVEI 17,UACS
	BLT 17,UACS+16
	SPM UUOHM
	SPM UUOHM1
	MOVSI 17,EXR+1
	ANDCAM 17,UUOHM1+3	;TURN OFF EXEC PAGING IF ON
	LPM UUOHM1
	MOVEI P,UPDL-1
	HRRZ U2,40
	HRLI U2,440700
	LDB A,[331100,,40]
	CAIN A,TYPE_-27.
	JRST UUOH1	;PRINT STRING
	SKIPE U2,TAGADR
	PUSHJ P,SPNT
	CLEARM TAGADR
	HRRZ A,UUOH
	SOS A
	X SYMLOK
	JRST NOSYM
	PUSH P,A
	M U1,B
	X RAD50
	MI A,"+
	SKIPE (P)
	X TYO
	POP P,A
	SKIPE A
NOSYM:	X LZOPT
	MI A,"/
	X TYO
	X CRR
	HRRZ U2,40
	HRLI U2,440700
	LDB U1,[331100,,40]
	CAIN U1,ERR_-27.
	JRST UUOH1
	CAIN U1,ERRP_-27.
	JRST UUOH2
	MOVE U2,[440700,,[ASCIZ /ILL UUO, OPCODE= /]]
	PUSHJ P,SPNT
	MOVE U3,[140300,,U1]
	PUSHJ P,OCTP
	X CRR
GIVEUP:
UUOEX1:	SKIPE DDTLOC
	JRST @DDTLOC
	JRST 4,BEGLUP


UUOHM:	BLOCK 8
UUOHM1:	BLOCK 8

ATAG:	HRRZ 17,40
	HRLI 17,440700
	MOVEM 17,TAGADR
	HRRZ 17,UUOH
	MOVEM 17,TAGPC
ARET:	MOVE 17,PISAV
	ANDI 17,377
	CONO PI,2000(17)
	MOVE 17,UACS+17
	JRST 2,@UUOH

ABRANCH:	HRRZ 17,40
	MOVEM 17,INTLOC
	JRST ARET


SPNT:	ILDB A,U2
SPNTR:	JUMPE A,CPOPJ
	CAIE A,"#
	CAIN A,"*
	JRST SPNT1
	CAIN A,"_
	JRST SPNTCR
	CAIN A,"&
	JRST SPNT1
	PUSHJ P,TYO
	JRST SPNT

SPNT1:	MOVE U3,A
	MOVEI U1,0
SPNT2:	ILDB A,U2
	CAIL A,"0
	CAILE A,"9
	JRST SPNT3
	LSH U1,3
	ADDI U1,-"0(A)
	JRST SPNT2

SPNT3:	PUSH P,A
	CAIGE U1,20
	SKIPA U1,UACS(U1)
	MOVE U1,(U1)
	CAIN U3,"#
	JRST SPNT4
	CAIN U3,"&
	JRST ASQOZ
	MOVE U3,[440300,,U1]
	PUSHJ P,OCTP
SPNT5:	POP P,A
	JRST SPNTR

SPNT4:	HRRZ A,U1
	M U3,U2
	ILDB U3,U3
	MI B,10
	CAIN U3,".
	MI B,10.
	PUSHJ P,LZOPT2
	JRST SPNT5

ASQOZ:	PUSH P,U2
	X RAD50
	POP P,U2
	J SPNT5

RAD50:	TLZ U1,740000
ASQZ1:	IDIV U1,[50*50*50*50*50]
	PUSHJ P,ASQZ2
	MOVE U1,U2
	IMULI U1,50
	JUMPN U1,ASQZ1
	R

ASQZ2:	ADDI U1,"0-1
	CAILE U1,"9
	ADDI U1,"A-"9-1
	CAILE U1,"Z
	SUBI U1,"Z+2-"$
	CAIN U1,"#
	MOVEI U1,".
	M A,U1
	J TYO

LZOPT:	MI B,10
LZOPT2:	HRRM B,LZOPT1
LZOPT1:	IDIVI A,10
	HRLM B,(P)
	SKIPE A
	PUSHJ P,LZOPT1
	HLRZ A,(P)
	ADDI A,"0
	JRST TYO


SPNTCR:	MI A,15
	X TYO
	MI A,12
	X TYO
	J SPNT

OCTP:	ILDB A,U3
	ADDI A,"0
	PUSHJ P,TYO
	TLNE U3,770000
	JRST OCTP
	POPJ P,

TYOS:	MOVEI A,40
TYO:	DATAI
	TLNE 200000
	POPJ P,
XTYO:	CONSZ TTY,20
	JRST .-1
	DATAO TTY,A
CPOPJ:	POPJ P,

TYI:	CONSO TTY,40
	JRST .-1
	DATAI TTY,A
	ANDI A,177
	JRST XTYO

UUOH2:	PUSHJ P,CRR
	PUSH P,U2
	HRRZ U2,UUOH
	LDB U1,[410300,,-2(U2)]
	CAIGE U1,3
	SOJG U2,.-2	;SCAN BACK FOR LAST 3XX OR GREATER
	LDB U1,[270400,,-2(U2)]
	MOVE U4,UACS(U1)
	MOVEM U4,FOO1
	MOVE U4,@-2(U2)
	MOVEM U4,FOO2
	MOVE U2,[440700,,[.ASCII ? AC *!FOO1 MEM *!FOO2 ?]]
	PUSHJ P,SPNT
	POP P,U2
	SETOM ERRF
UUOH1:	PUSHJ P,SPNT
	LPM UUOHM
UUOEX:	MOVE A,UUOH
	TLNE A,LSRMOD
	JRST UUOEX1
	MOVE A,PISAV
	ANDI A,377
	CONO PI,2000(A)
	MOVSI 17,UACS
	BLT 17,17
	JRST 2,@UUOH

FOO1:	0
FOO2:	0
UACS:	BLOCK 20
UPDL:	BLOCK 40


SYMLOK:	MI C,0
	SKIPN E,DDTLOC
	R
	SKIPN E,-2(E)
	R
	MI B,0
SYMLUP:	M D,1(E)
	CAMG D,A
	CAMG D,B
	JRST SYML1
	SKIPGE (E)	;FLUSH HALF KILLED SYMBOLS
	JRST SYML1
	M B,1(E)
	M C,(E)
SYML1:	ADD E,[1,,1]
	AOBJN E,SYMLUP
	SUB A,B
	M B,C
POPJ1:	AOS (P)
	R


APRBRK:	0
	MOVEM 17,APRBAC+17
	MOVEI 17,APRBAC
	BLT 17,APRBAC+16
	MI P,APRPDL-1
	SPM APRBP	;REAL THING STORE AWAY
	PUSH P,40
	PUSH P,UUOH
	CONSO 60000
	JRST APRET
	SKIPE INTLOC
	JRST @INTLOC
APRET:	PUSHJ P,CRR
APRT1:	SKIPE U2,TAGADR
	X SPNT
	SETZM TAGADR
	CONSZ 20000
	OUTSTR [ UNEXPECTED MEMPROTECT INTERRUPT ]
	CONSZ 10000
	OUTSTR [ UNEXPECTED NXM ]
	CONSZ 40000
	OUTSTR [ UNEXPECTED QUANTUM OVERFLOW ]
	MOVE A,APRBRK
	TLNE A,LSRMOD
	JRST APRT2
	HRRZS A
	PUSHJ P,SYMLOK
	JRST APRT2
	OUTSTR [AT &!B +#!A _]
APRT2:	HRRZ A,APRBRK
	HRRZ B,APRBP+1
	OUTSTR [INTERRUPT PC= #!A, OPC= #!B _]
	MOVE A,APRBP+1
	AOS A
	HRRZM A,APRBRK
	LDB A,[221500,,A]
	DPB A,[271500,,APRBRK]
	HLLZ C,APRBP+3
	X TYPFLT
	TLZ C,4
	CONSZ 20000
	ANDCAM C,APRBP+3
	CONSZ 200000
	OUTSTR [PDL OV ]
	CONSZ PI,200000
	OUTSTR [PARITY ERROR ]
	CONO 470000+APRCHN
	CONO PI,200000
	X CRR
	OUTSTR [_CONTINUE? ]
	X TYI
	CAIE A,"Y
	JRST GIVEUP
	POP P,UUOH
	POP P,40
	LPM APRBP

APRBK2:	CONO 470000+APRCHN	;RETURN FROM ONEPROCEED TEST
	CONO PI,200000
	MOVSI 17,APRBAC
	BLT 17,17
	JRST 12,@APRBRK


INTFLS:	0
	CLEARM INTLOC
	POP P,UUOH
	POP P,40
	CONO 60000+APRCHN
	MOVSI 17,APRBAC
	BLT 17,17
	JRST 12,@INTFLS

APRBP:	BLOCK 10
APRBP1:	BLOCK 10
APRBAC:	BLOCK 20
APRPDL:	BLOCK 10

CRR:	MOVEI A,15
	PUSHJ P,TYO
	MOVEI A,12
	JRST TYO

TYPFLT:	TLNE C,FMAR
	OUTSTR [MAR,]
	TLNE C,FNACC
	OUTSTR [NO ACCESS,]
	TLNE C,FPURE
	OUTSTR [PURE,]
	TLNE C,FRWF
	OUTSTR [W IN RWF,]
	TLNE C,FRDO
	OUTSTR [W IN RD ONLY,]
	TLNE C,FDBL
	OUTSTR [DBL,]
	TLNE C,FNXM
	OUTSTR [PG FETCH ILM,]
	TLNE C,FONPR
	OUTSTR [ONE PROCEED,]
	TLNE C,FNXM+FDBL+FRDO+FRWF+FPURE+FNACC+FMAR
	POPJ P,
	TLNN C,FFAULT
	OUTSTR [NO FAULT]
	TLNE C,FFAULT
	OUTSTR [FAULT BUT NO ERROR BITS]
	POPJ P,

LP1:	BLOCK 8
SP1:	BLOCK 8
MSK1:	17777,,-1
	17777,,-1
	7,,-1
	1777,,-1
	377,,-1
	377,,-1
	377,,-1
	3777,,-1

QTIME:	0
MEMSIZ:	0	;HIGHEST LOCATION EXISTANT
INTLOC:	0	;IF NON ZERO, LOCATION OF ROUTINE TO HANDLE INTERRUPT
TADR:	0
TINS:	0
LMOD:	0
OPPNR:	0
XRAND:	0	;TEMP RANDOM # FOR XCTR TEST
BCPGNO:	0	;PAGE NO._-4 FOR B,C TESTS

PTS1:	0
	0
	0
	EXR+1,,0
	0
	0
	0
	TACS


NULPSW:	0?0?0
	1,,
	0?0?0?0

UPG:	0
	0
	0
	1,,
	2,,[RW+TPG_-10.,,]
	0
	0
	TACS

ERRF:	0

PTSPT1:	BLOCK 200

PAT:
PATCH:	BLOCK 100
PDL:	BLOCK 100
CONSTA
VARIAB
NEXPAG=<.+1777>&-2000


END BEG
