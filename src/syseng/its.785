
TITLE ITS
.SYMTAB 10000.
IF1 [ PRINTX \AI = \
.TTYMAC A
AI==A+IFB A,1	;1 FOR AI, 0 FOR MATHLAB
IFB A,[PRINTX \AI = 1
\]
TERMIN  ]

OQDTSW==1	;NON ZERO => STORE OLD STYLE DATE ON DSK (EVENTUALLY FLUSH)
EXPGNG==4	;4 TO TURN ON EXEC PAGING
PCLSW==1	;1 ASSEMBLE PCLSR TEST FEATURE
.MLLIT==1	;MULTI-LINE LITERAL MODE

;AC DEFS

A=1
B=2
C=3
D=4
E=5
TT=6
I=7
Q=10
J=11
R=12
W=13
H=14
P=15	;DO NOT CHANGE!	;PDL POINTER
T=16	;"
U=17	;"		;USER INDEX

.XCREF A,B,C,D,E,TT,I,Q,J,R,W,H,P,T,U
YEAR==73.	;BASE YEAR LOW BIT ONLY STORED IN FILE
YEARPH==-1	;1 OR -1 AS FOLLOWS
;IF LBT (YEAR) .NE. LBT (STORED YEAR) THEN COMPLETE STORED YEAR = YEAR+YEARPH

IF1 EXPUNGE APR,OCT,DEC	;FOR NEW CALENDAR HACK

NULBLK==4	;NUMBER OF LOCKED SWITCH BLKS IN USR VARIABLES
		;USES 2 WDS OF USER VAR PER

MAXJ==50.	;MAX JOBS ALLOWABLE
IF2 LIOBLK==1+<USRSTG+LUBLK*MAXJ>_-10.	;LOWEST BLOCK NEVER TO BE SHUFFLED
			;ALSO MAX # OF BLOCKS SYS JOB MAY HAVE

;INTERRUPT BITS IN PIRQC
TTYIF==1	;CONSOLE INPUT INTERRUPT BUF NOT EMPTY
BCNTRZI==2	;^Z TYPED
BPIPI==4	;BAD LOC 42
AROIF==10	;AROV
BDISP==20	;DISPLAY MEMORY PROTECT
BILLOP==40	;ILLEGAL INSTRUCTION
BSYSDN==100	;SYSTEM GOING DOWN  OR REVIVED
VALRTF==200	;VALUE RETURN
BIOCER==400	;CHANNEL ERROR
ILLUAD==1000	;USER DOES NOT HAVE THAT MUCH CORE
BRKF==2000	;BREAKPOINT FLAG
BPROC==4000	;SINGLE INSTRUCTION PROCEED
BSCLK==10000	;CLOCK INT
BIOADC==20000	;MEMORY PROTECTION VIOLATION
BMARI==40000	;MAR INTERRUPT
BLTP==100000	;LIGHT PEN
;200000	PDL OV
BCLI==400000	;CLI DEVICE INTERRUPT
BRESTR==1,,	;RESTRICTION VIOLATION
BDBGI==2,,	;SYS BEING DEBUGGED
	ATPSFT==20.	;SHIFT TO TAKE LOW ORDER BIT TIPBK1
ARMTP1==4,,	;ARM TIP BREAK 1 (THESE MUST BE CONSECUTIVE BITS)
ARMTP2==10,,	;ARM TIP BREAK 2
ARMTP3==20,,	;ARM TIP BREAK 3
BUTRAP==40,,	;SYS UUO TO USER TRAP
BPURE==100,,	;PURE TRAP
BWIRO==200,,	;ATTEMPTED WRITE INTO RD ONLY
ARFOIF==400,,	;ARITHMETIC FLOATING OVERFLOW
BRTIME==100000,,	;RUN TIME INT.
NCLOKB==200000,,	;SEE AREALT

;IN BADBTS => CLASS 2 OR 1 INTERRUPT   ;IN VBDBTS=> CLASS 1 INTERRUPT
VBDBTS==BPIPI+VALRTF+BRKF+BCNTRZI+BPROC
BADBTS==VBDBTS+BIOADC+BIOCER+BILLOP+BMARI+BDISP+ILLUAD+BRESTR+BUTRAP+BPURE+BWIRO

LPM=102000,,	;LOAD PG MEM STATE VECTOR DONT CLR ASSOC MEM
LPMR= LPM 2,	;CLEAR ASSOC MEM AND LOAD
SPM= LPM 1,	;STORE PG MEM STATE VECTOR
LPMRI=LPM 6,	;LOAD PM, CLEAR ASSOC REG, AND CAUSE INTERRUPT
XCTR=103000,,	;VIOLATION CAUSES USER MEM PROTECT INTERRUPT UNLESS INHIBITED
		;VIOLATION ALSO SKIPS BUT THIS IS OF NO CONSEQUENCE UNLESS
		;INTERRUPT IS INHIBITED SINCE PC WILL BE RESET FROM OPC

XR==1	;MAP READ ALLOW USER MEM PROTECT INTERRUPTS
XW==2	;MAP WRITE
XRW==3	;MAP BOTH
XI==4	;MAP NONE BUT INHIBIT INTERRUPTS IF PG FAULT
XRI==5	;MAP READ AND INHIBIT USER MEM PROTECT ETC
XWI==6	;MAP WRITE AND INHIBIT
XRWI==7	;MAP BOTH AND INHIBIT

USPM=107000,,	;SOFTWARE "USER" SPM

IOTFLG==4000	;IOT USER FLAG IN PC WORD
BADPC==5037	;PC BITS NOT PERMITTED FOR USER TO CONTROL (SPECIAL AND IOT USER)
LSRMOD==10000	;USER MODE BIT IN PC WORD
BPCROC==400	;ONE PROCEED BIT IN PC

UUOMIN==40000,,	;SMALLEST NUM THAT COULD BE A SYSTEM CALL
UUOMAX==50000,,	;ONE GREATER THAN LARGEST NUM "
AUUO=UUOMAX	;USE TO SAVE CONDS ON ILLOP
UTRAP=AUUO+1_27.	;USE FOR USER SYS UUO TRAP
UIOT=AUUO+2_27.	;USE FOR USER I/O INST TRAP
ITSVRS==.FNAM2
IF1,[ASMDAT==.OP <.OPER@> 0,.RDATE
ASMTIM==.OP <.OPER@> 0,.RTIME
]

	;MAX DYN ALLOC ALLOC IO BUFFERS
MXIOB==370	;MAX POSSIBLE

SIOMT==30	;MAX SIZE TRANSLATION TABLE

LUPDL==50	;LENGTH USER PDL MUST BE >= 40 FOR 2311 GC
LUIOP==20	;LENGTH OF USER IO PDL
CPDLL==20	;LENGTH CLOCK CHANNEL PDL
LUTCP==20	;LENGTH UTC PDL
LSYSP==40	;SYSTEM JOB PDL

DMNSZ==5	;# ENTRIES IN DEMON BUFFER (DMNBF)

MXCZS==5	;MAX NUMBER ^Z'S PER CLOCK BREAK

SCLKI==30.	;60'THS PER SLOW CLOCK
VSCLKI==2*60.*60.	;60'THS PER VERY SLOW CLOCK TICK
MXOPT==8.	;SLOW CLOCK  MAX UT OP CAN TAKE
NINFP==8.	;MAX. NO. OF INF. PROCED. / PROCED.

;"INSTALLATION" RELATED SWITCHES

IFN AI,[
340P==1		; HAS 40
TABP==1		; HAS SYLVANIA TABLET
DSDP==1		; HAS DESELECTION DEVICE
NEWDTP==0	;1 HAS NEW DECTAP CONTROL (DC-10)
DECDKC==0	;1 HAS DEC DISK CONTROL
NUNITS==4	;NUMBER UTAPE UNITS
NMTCS==1	;NUMBER MAG TAPE UNITS
OLPTP==1	; HAS OLPT
NLPTP==1	;HAS NEW LPT
PLTP==1		;HAS PLOTTER
ARMP==1		;HAS ARM (AMF MOSTLY)
OMXP==1		;HAS OMX
IMXP==1		;HAS IMX
VIDP==1		;HAS VIDI
TK10P==1	;HAS TK10 TTY SCANNER
MTYP==0		;1 HAS MORTON MULTIPLEX BOX
CODP==1		;CODE OUTPUT DEVICE
PDP6P==1	;PDP6 FEATURES
HCLKP==1	;HOLLOWAY CLOCK
PDCLKP==1	;"DECORIOLIS" CLOCK
RBTCP==1	;ROBOT CONSOLE
DPKPP==1	;DATA POINT KLUDGE
NETP==1		;ARPA NET CONNECTION
CCLKP==0	;CHESS TOURN CLOCK STUFF
TPLP==1		;PSEUDO LPT
C1MXP==1	;CHNL 1 MPX FEATURE
NDAP==1		;NEW D/A CONVERTERS
NNVTTS==0	;# NOVA TTYS
NNTYS==16.	;# TTYS ON KNIGHT KLUDGE
NDPTYS==16.	;# TTYS ON DATAPOINT KLUDGE
NMTYS==0	;# TTYS ON MORTON BOX
NQS==3		;# 2314 UNITS
SYSCON==5	;SYSTEM JOB CONSOLE
APL==10		;AP TTY #
STKP==1		;HAS STANFORD KEYBOARD
TSYSM==256.+16.	;TOTAL PDP10 1K MEM BLOCKS
DDTPGS==16.	;PGS TO LEAVE FOR DDT (AT HIGH END OF LOW MOBY)
]

IFE AI,[
340P==0
TABP==0
DSDP==0
NEWDTP==1
DECDKC==1
NMTCS==1
OLPTP==0
NLPTP==0
PLTP==0
ARMP==0
OMXP==0
IMXP==0
VIDP==0
PDP6P==0
HCLKP==0
PDCLKP==1
RBTCP==0
DPKPP==0
NUNITS==4
CODP==0
TK10P==0
MTYP==1
NETP==1
CCLKP==0
TPLP==0
C1MXP==1
NDAP==0
NNVTTS==0
NNTYS==0
NDPTYS==0
NMTYS==21
NQS==2
SYSCON==4
APL==0		;NO AP LINE
STKP==0
TSYSM==256.+64.	;512 SOON?
DDTPGS==16.
]

LPTP==OLPTP+NLPTP
IFN TABP,	TABCLK==0	;1=>PUT TABLET ON CLOCK CHNL

;PRIORITY INTERRUPT CHANNEL ASSIGNMENTS
	DCCHN==1	;DC CHANNEL
	DCLOC=40+2*DCCHN	;DC INTERRUPT LOCATION

IFN NETP,[
	IMPCHN==1	;IMP STUFF
	NETCHN==2	;SOFTWARE ACTIVATED...
]
	UTCCHN==2	;UTC CHANNEL
	DSKCHN==UTCCHN	;2314 CHANNEL
IFN NMTCS,	MTCCHN==UTCCHN	;MAG TAPE CONTROL CHANNEL
IFN LPTP,	LPTCHN==4	;LINE PRINTER CHANNEL
		TTYCHN==3	;TTY CHANNEL
IFN PLTP,	PLTCHN==4	;PLOTTER CHANNEL
		PCHCHN==4	;PTP CHANNEL
		PTRCHN==4	;PAPER TAPE READER CHANNEL
IFN 340P,	SDCHN==4	;DISPLAY SPECIAL CHANNEL
IFN DSDP,	DSDCHN==4	;INTERRUPT FROM OTHER PROCESSOR
IFN ARMP,	TIPBCH==5	;ARM TIP BREAK CHNL
IFN OMXP,	OMPCHN==5	;OUTPUT MULTIPLEXOR
IFN VIDP,	NVDCHN==5	;NEW VIDI
IFN TABP,	IFE TABCLK,	TABCHN==5	;TABLET
IFN 340P,	DISCHN==6	;DISPLAY DATA CHNL
IFN TABP,	IFN TABCLK,	TABCHN==7	;TABLET
		APRCHN==7	;DO NOT CHANGE

		PICOFF==1200	;TURN OFF PI CHANNEL
		PICON==2200	;TURN ON PI CHANNEL
		PICIRQ==4200	;REQUEST INTERRUPT ON PI CHANNEL

		CLKON==2201	;ABSOLUTE
		CLKOFF==1201
IFN OMXP,	OMXON==CLKON\<400_-OMPCHN-1>
IFN OMXP,	OMXOFF==CLKOFF\<400_-OMPCHN-1>
IFN LPTP,	LPTON==CLKON\<400_-LPTCHN-1>
IFN LPTP,	LPTOFF=CLKOFF\<400_-LPTCHN-1>
		PTPON==CLKON\<400_-PCHCHN-1>
		PTROFF==CLKOFF\<400_-PCHCHN-1>
		PTRON==CLKON\<400_-PTRCHN-1>
		PTROFF==CLKOFF\<400_-PTRCHN-1>
		TTYON==CLKON\<400_-TTYCHN-1>
		TTYOFF==CLKOFF\<400_-TTYCHN-1>
		UTCON==CLKON\<400_-UTCCHN-1>
		UTCOFF==CLKOFF\<400_-UTCCHN-1>
IFN NETP,[
		NETON==UTCON
		NETOFF==UTCOFF
]
IFN TABP,[

IFN TABCLK,[
TABON==CLKON
TABOFF==CLKOFF
]
IFE TABCLK,[
TABON==CLKON\<400_-TABCHN-1>
TABOFF==CLKOFF\<400_-TABCHN-1>
]
]

IFE NEWDTP,	CUINT==5000+UTCCHN	;CONO TO UTC TO ACTIVATE UTAPE INTERRUPT

IFN PDP6P,	PDP6BM==1,,40000	;BASE ADR OF FIRST 16K PDP-6 MEM AS SEEN BY 10

;DEVICE CODES
IFN STKP,	STK==70		;STANFORD KEYBOARD
IFN OLPTP,	OLPT==124	;LINE PRINTER
IFN NLPTP,	NLPT==464
IFN NMTCS,	MTC==340	;MAG TAPE CONTROL
IFN NMTCS,	MTS==344	;MAG TAPE STATUS
IFN VIDP,	NVDX==620	;NEW VIDI X
IFN VIDP,	NVDY==624	;NEW VIDI Y
IFN VIDP,	NVDT==630	;NEW VIDI T (DEFLECTION DELAY)
IFN PLTP,	PLT==654	;CAL COMP PLOTTER
IFN HCLKP,	CLK1==710	;HOLLOWAY CLOCK
IFN HCLKP,	CLK2==714	; "
IFN IMXP,	MPX==574	;INPUT MULTIPLEXOR
IFN OMXP,	OMPX==570	;OUTPUT MULTIPLEXOR
IFN TK10P,	NTY==600	;KNIGHT TTY KLUDGE
IFN MTYP,	MTY==400
IFN PDCLKP,	PDCLK==500	;DE-CORIOLIS CLOCK
IFN DSDP,	DSDEV==20	;DE SELECTION AND INTER COM DEVICE
IFN DSDP,	DSDEVN==24	;DE SELECTION DEV (FOR DEVICES YOU DATAO DEV CODE TO DSDEVN)
IFN ARMP,	TIPDEV==504	;TIP BREAK DEVICE
IFN RBTCP,	RBTCON==514	;ROBOT CONSOLE
IFN DPKPP,	DPK==604	;DATA POINT KLUDGE
IFE DECDKC,	DC0==610	;2314 DISK CONTROL
IFE DECDKC,	DC1==614	;2314 DISK CONTROL
IFN NETP,	IMP==460	;NET INTERFACE
IFN NEWDTP,[
		DTC==320
		DTS==324
]
IFN DECDKC,	DPC==250
IFN NETP,[
	IFN AI,IMPUS==206	;AI NETWORK HOST NUMBER
	IFE AI,IMPUS==306
]

IFN DSDP,	IFN VIDP,	DSNVID==200000,,	;DEASSIGN BIT FOR NVD
IFN DSDP,	IFN 340P,	DSNDIS==4000,,	;DEASSIGN BIT FOR DIS
IFN DSDP,	IFN NMTCS,	DSMTC==1,,	;DEASSIGN BIT FOR MAG TAPE

IFN RBTCP,	RLTSWC==17	;ROBOT CONSOLE SELECT FOR LIGHTS AND SWITCHES
IFN RBTCP,	IFN TABP,	RTABC==16	;ROBOT CONSOLE SELECT FOR TABLET

IFN IMXP,	LCHN==177	;MULTIPLEXOR LIMIT ON READ IN

		NUTIC==8	;NUMBER UT IN CHNLS
		NUTOC==8	;NUMBER UT OUT CHNLS
		NFCLC==NUTIC+NUTOC+1	;# OF FIRST CORE LINK CHNL
		NCLCH==14	;NUMBER CORE LINK CHNLS
		NFNETC==NFCLC+NCLCH	;# OF FIRST NET CHNL
IFN NETP,	NNETCH==20.		;# NET CHNLS
IFE NETP,	NNETCH==0	;SO WILL BE DEFINED
		NUDCH==14	;NUMBER DIRECTORY CHNLS
IFN IMXP,	NPOTCH==20.	;NUMBER POT CHANNELS
		NQCHN==30.	;NUMBER 2314 CHNLS

IFN CODP,	CODBFL==5	;CODE BUFFER
		PUNSIZ==20	;PTP BUF SIZ
		REDSIZ==200	;PTR BUF SIZ
IFN PLTP,	LPLBUF==200	;PLT BUF SIZ
IFN LPTP,	LPTBSZ==1000	;LPT BUF SIZ
IFN VIDP,	NVDLNG==340	;NVD BUF SIZE
IFN TPLP,	TPLBSZ==100	;TPL BUFFER SIZE IN SYS JOB
IFN TABP,	LTABBF==100	;TABLET BUFFER

EOFCH==3	;SYSTEM END OF FILE CHR
EOFWRD=REPEAT 5,[EOFCH_<.RPCNT*7+1>\]0	;WORD OF EOFCH'S

IFN 340P,	DVEF==4000	;DISPLAY VERTICAL EDGE FLAG
IFN 340P,	DHEF==1000	;DISPLAY HOR EDGE FLAG

IFN 340P,	EWRT==400./12.	;EQIV "COST" IN DISPLAY WRDS FOR TRIP THRU RECYC
IFN 340P,	MDISWD=70000	;MAX # WDS SENT TO SCOPE IN 1/2 SEC

NXLBYT==2	;# OF EXTRA CHRS IN LOAD ADR IN FILE DESC
		;MUST BE AT FRONT OF FILE
NSWPV==340P+VIDP+IMXP	;# OF DEVICES THAT CAN SWAPIN PAGES

IFN C1MXP,[
IFN NMTCS,	MAGLOC==76	;INTERRUPT LOCS FOR MAGTAPE
		DCMLOC==74	;"      "    FOR DC
		IMXLC==66	;"     "   IMX
IFN NETP,[
		IMPILC==70	;INPUT FROM IMP
		IMPOLC==72	;OUTPUT TO IMP
]
]

IFE C1MXP,[
IFN NMTCS,	MAGLOC==42
		DCMLOC==42
]
IFN PLTP,[
;PLOTTER CONTROL BITS
SD==4000
PD==10000
PUP==200
PDN==400
SDC==20000
PDC==40000
SDS==1000
PDS==2000
]

;SYS PERIPHERAL DEVICE CODES

;1.6 INDICATES DIRECTORY DEVICE
;1.5 INDICATES NON PHYSICAL DEVICE

SNTTY==1
SNTDS==2	;TERMINAL DISPLAY
SNLPD==3	;DATA PRODUCTS LPT
SNVID==4
SNBAT==5
SNPLT==6
SNPTP==7
SNIMPX==10
SNOMPX==11
SNPTR==12
SN340==13	;340 AS ASCII DEVICE
SN340I==14	;INTERPRETED DISPLAY ON 340
SNMTC==15	;MAGTAPE
SNCOD==16	;CODE DEVICE
SNTAB==17
SNNUL==21
SNJOB==22
SNBOJ==23
SNSPY==24
SNSTY==25
SNNET==26	;NETWORK
SNLPV==27	;VOGUE LPT
SNSTK==30	;STANFORD KEYBOARD
SNUTC==41
SN2311==43
SNFUSR==60
SNUSR==61
SNCLK==62	;CLO, CLU, & CLI
SNDIR==63
SNPDP==64	;PDP6

EYEAR==YEAR
IFN YEAR&1,EYEAR==YEAR+YEARPH
LEYRP==0
IFE EYEAR-<EYEAR/4*4>,LEYRP==1	;ONE IF EVEN REPRESENTED YEAR A LEAP YEAR

LWYR==YEAR
IFL YEARPH,LWYR==YEAR+YEARPH
LWYLP==0
IFE LWYR-<LWYR/4*4>,LWYLP==1	;LOW YEAR A LEAP YEAR

SPD==60.*60.*24.	;# SECS IN A DAY (FITS IN A HALFWORD)
	PDUPS==60.	;# PDCLK INCREMENTS/SEC

OPNCOM==410300	;COMMAND FIELD IN LH OF FIRST OPEN WORD

;SYS IOC STATUS WORD FORMAT

;RIGHT HALF WORD DEVICE STATUS
;1.1-1.6 SYS PHYSICAL DEVICE CODE
;1.7-1.9 OPEN MODE
;2.1 SYS BUFF CAP FULL
;2.2 "   "    "  EMPTY
;2.9-2.3 DEVICE DEPENDANT

;LEFT HALF WORD CHANNEL STATUS 
;3.6-3.1 SET BY OPENS THAT DONT SKIP
;1= NO SUCH DEVICE
;2= WRONG DIRECTION
;3= TOO MANY TRANSLATIONS
;4= FILE NOT FOUND
;5= DIRECTORY FULL
;6= DEVICE FULL
;7= DEVICE NOT IN READY STATUS
;10= DEVICE NOT AVAILABLE
;11= ILLEGAL FILE NAME
;12= MODE NOT AVAILABLE
;13= FILE ALREADY EXISTS (RENAME)
;14= BAD CHANNEL NUMBER
;15= TOO MANY ARGUMENTS (CALL)
;16= PACK NOT MOUNTED
;17= DIRECTORY NOT AVAIL NOW (ALL DIREC CHNLS IN USE)
;20= USER DOESN'T EXIST
;21= LOCAL DEVICE ONLY
;22= SELF CONTRADICTORY OPEN COMMAND
;23= ATT MODIFY WRITE ON FILE OPEN FOR READ
;24= MFD FULL
;25= DEVICE NOT ASSIGNABLE TO THIS PROCESSOR
;26= DEVICE WRITE-LOCKED
;27= LINK DEPTH EXCEEDED
;30= TOO FEW ARGUMENTS (CALL)
;31= CAN'T MODIFY JOB.
;32= CAN'T GET ACCESS TO PAGE.
;33= SELF-CONTRADICTORY ARGS (CALL)
;34= WRONG TYPE DEVICE.
;35= NO JOB WITH THAT NUMBER.
;36= VALID CLEAR OR STORED SET (JOBRET, JOBGET)
;37= NO CORE AVAILABLE.
;40= NOT TOP LEVEL

NOPNLS==40	;NUMBER OF CHNL STATUS LOSES USED
NDOPL==7	;NUM OF DIS OPNL

;4.5-3.7 SET BY IOC ERRORS AT IOT OR OPER TIME

;3.9-3.7 SET BY 340 ROUTINES
;1 ILLEGAL SCOPE MODE
;2 SCOPE HUNG
;3 MORE THAN 1K SYS SCOPE BUF
;4 MEMORY PROTECT
;5 ILLEGAL SCOPE OP
;6 MEMORY PROTECT ON PDL POINTER
;7 ILLEGAL PARAMETER SET

;4.5-4.1
;11 ILLEGAL CHR AFTER ^P ON TTY DISPLAY
;10 CHNL IN ILLEGAL MODE WHEN .IOT ATTEMPTED
;9 DEVICE FULL
;8 CHANNEL NOT OPEN
;7 CHANNEL DOES NOT HAVE A USER OPEN ON IT
;6 ATTEMPT TO OVER IOPUSH
;5 ATTEMPT TO OVER IOPOP
;4 NON-EXISTANT SUB DEVICE
;3 NON-RECOVERABLE DATA ERROR ;NON-EX-MEM ON PDP10 REF
;2 ATT TO RANDOM ACCESS BEYOND END OF FILE
;1 ILLEGAL HARDWARE OPERATION ATTEMPTED OR DEVICE HUNG

MIOTER==1	;LOWEST IOCERR CODE USED
NIOTER==13	;NUMBER "  "

;4.9-4.5 ALWAYS ZERO (USED BY IOPUSH FOR CHNL NUM)

;EXECUTIVE PAGE

EXPGN==0
DEFINE EXECPG A
A==EXPGN
EXPGN==EXPGN+1
ZZQ==<A+1>&1
ZZQQ==A_-1
.!A==220000*ZZQ+2200,,ZZQQ
TERMIN


FNM==.FNAM2	;SRI GETS VERSION NUMBER
		;WORKS FOR DECIMAL IGNORES LOW ORDER NON-NUMERIC CHRS
DEFINE VNAM
.TAG FOO
	ZZZQ==FNM&77
	IFGE ZZZQ-'0,IFLE ZZZQ-'9,.GO BAR
	FNM==FNM_-6
	.GO FOO
.TAG BAR
	ZZZQ==1
	SRI==0
.TAG MUM
	IFE FNM,.GO END
	ZCHR==FNM&77-'0
	IFL ZCHR,.GO END
	IFG ZCHR-9,.GO END
	SRI==SRI+ZZZQ*ZCHR
	ZZZQ==ZZZQ*10.
	FNM==FNM_-6
	.GO MUM
.TAG END
	TERMIN

IF1 VNAM

DEFINE SRITYP A
ZZZ==10	;SAVE OLD RADIX
RADIX 10.
IFN AI,[
	MOVEI I,[.ASCII ?
AI ITS !SRI A?]
]
IFE AI,[
	MOVEI I,[.ASCII ?
ML ITS !SRI A?]
]
RADIX ZZZ
	TERMIN

		;"MONTHS OF THE YEAR" MACRO

DEFINE MNIRP A
IRPS M,,[JAN FEB MAR APR
MAY JUN JUL AUG
SEP OCT NOV DEC]L,,[31. 29. 31. 30.
31. 30. 31. 31.
30. 31. 30. 31.]
A
TERMIN
TERMIN

FOO==-1	;ACCUMULATED VALUE FOR FOLLOWING DEFINITION:

MNIRP [M==FOO
FOO==FOO+L]	;JAN=-1, FEB=30., MAR=59., ETC.

DEFINE CONC A,B
A!B!TERMIN

DEFINE	BUG RECOV,A/
	JRST 4,RECOV
TERMIN

DEFINE INFORM A,B
IF1,[PRINTX \A = B
\]TERMIN

ZZZ==10
RADIX 10.
INFORM VERSION,\SRI
INFORM AI,\AI
RADIX ZZZ

SSYS==0	;LENGTH OF SYS CODE

DEFINE EBLK
CONC CK,\CKNUM,==CKZZ-.,,CKZZ
CKNUM==CKNUM+1
SSYS==SSYS+.-CKZZ
IFN CKPAR,A:	INFORM LOSS AT EBLK,\.
CKPAR==1
TERMIN

DEFINE BBLK
CKZZ==.
IFE CKPAR,A:	INFORM LOSS AT BBLK,\.
CKPAR==0
TERMIN

CKPAR==1
CKNUM==0


;INSERT CALL TO THIS MACRO AT ANY PLACE IT IS POSSIBLE TO PCLSR
;(IF IT IS DESIRED FOR PCLSR TEST FEATURE TO TEST THAT SECTION)

DEFINE PCLT
IFN PCLSW,[
	SKIPE PCLDBM
	PUSHJ P,PCLTST
]
TERMIN

DEFINE	PCLTH A
IFN PCLSW,[
	SKIPN PCLDBM
	JRST .+3
	PUSHJ P,PCLTSH
	A
]
TERMIN

PATB:
LOC 20
	BBLK

IFN DECDKC,[
IF2,[
	LOC ICWA		;34
	EBLK
	LOC ICWA+2
	BBLK
]
IF1,[
	EBLK
	BBLK
]
]

LOC 37
	EBLK
LOC 41
	JSR UUOH	;UUO TRAP

	REPEAT 2,	JSR RINT1
	REPEAT 6*2,	JSR RINT	;INITIALIZE ANY UNUSED PI LOCNS

LOC 61
	JSR 60H		;60 TRAP
IFN C1MXP,	REPEAT 16.,	JSR RINT1	;INITIALIZE C1MPX LOCNS

LOC 40+2*APRCHN
	JSR CLKBRK	;PROCESSOR OR CLOCK INTERRUPT
	JRST 4,.

LOC 40+2*PCHCHN
	JSR LPTBRK	;LPT,DISPLAY,PTP,PTR,OTHER PROCESSOR
IFN 340P,	JSR DRECYC	;HACK HACK

LOC 40+2*TTYCHN
	JSR TTYBRK	;TTY,DATAPOINT KLUDGE
	JRST 4,.

LOC 40+2*UTCCHN
	JSR UTCBRK	;MICRO TAPE OR DISK (S)
	JRST 4,.

IFN 340P,[
LOC 40+2*DISCHN
	BLKO DIS,DBLKOP	;340 DISPLAY BLKO
	CONO PI,4000+200_<-SDCHN>	;HACK HACK
]

IFN VIDP,[
LOC 40+2*OMPCHN
	JSR OMPXBK	;OUTPUT MPXR, NVID, ETC.
	JRST 4,.
]
IFN NETP,[
LOC 40+2*IMPCHN
	JSR IMPBRK
LOC IMPILC
	JSR IMPIBK
	0
LOC IMPOLC
	JSR IMPOBK
	0
]

LOC PATB

DEFINE	PI2SAF
	CONSO PI,20000
	CONSO PI,40
	JRST .+2
	JRST 4,.	;PI 2 NOT OFF OR NOT IN PROGRESS
TERMIN

	NMMP==3	;# EXEC PAGES FOR MMP TABLE
IFN 340P,	N340PB==10.	;# EXEC PGS USED FOR 340 DATA MUST BE EVEN
	NUVPG==256.	;SIZE USR PRGM THAT PAGE TABLE VARS CAN BE
			;ACCOMODATED IN USR VARIABLES
;CIRCULAR PAGE LINK FORM
;2.9=0
;1.1-1.8 PAGE #
;2.8-1.9 USER #
;2.9=1
;2.8=0 2.7-1.1 LINK TO MMP TABLE
;2.8=1 2.7-1.1 LINK TO MEM PNT TABLE
;EXCEPT 2.9-1.1=777777 => ABSOLUTE PAGE, NOT LINKED

SYSUSM==TSYSM-DDTPGS	;LEFT AFTER ROOM FOR DDT
;EXEC MAP ASSIGNMENTS
IFN 340P,[
EXECPG 340P1,	;USED TO FETCH + TRACE 340 PNTRS
EXECPG 340P2,
REPEAT N340PB,CONC [EXECPG DPG]\.RPCNT,;	;DATA AREA PNTRS FOR 340 DATA
]
EXECPG CORJF,	;CORE JOB FROM PAGE
EXECPG CORJT,	;CORE JOB TO PAGE
IFN VIDP,[
EXECPG VSB1,	;.VSCAN B1
EXECPG VSB2,	;.VSCAN B2
]
REPEAT NMMP,CONC [EXECPG MMP]\.RPCNT,;	;MMP TABLE
EXECPG PAREP,	;USED BY SYSTEM IN ITS DILIGENT EFFORTS TO FIX PARITY ERRORS

NEXPGS==EXPGN	;# EXEC PGS USED
	;FOR VARIABLES (MONITORABLE WITH KEYS)
NSKED:	0	;# TIMES SCHED RUN
NUINT:	0	;# TIMES USER GIVEN INTERRUPT
NAUINT:	0	;# ATTEMPTED USER INT (POSSIBLY UNSUCCESSFUL DUE TO PG FAULT)
NPCLSR:	0	;# ATT TO PCLSR
NSOUSR:	0	;# ATT TO SWAP OUT USR
NSOPGS:	0	;# TIMES THRU LOOP LOOKING FOR PG TO SWAP OUT
NPGSO:	0	;# TIMES AT SWOPG
NPGFLT:	0	;# PAGE FAULT (ALL CAUSES)
NCLKI:	0	;# CHNL 7 INTS (ALL CAUSES)
NPGLD:	0	;# TIMES AT PGLDU
NUFLS:	0	;# TIMES AT UFLS
NTUSB:	0	;# TIMES USER SWAP BLOCKED
NTSBUP:	0	;# TIMES SWAP BLOCKED USER TOOK PAGE FAULT AND LET IN
NTSBUB:	0	;# TIMES SWAP BLOCKED USER TOOK PAGE FAULT AND BLOCKED
NTSBUU:	0	;# TIMES SWAP BLOCKED USER UNBLOCKED BEFORE TIME (MEM APPARENTLY AVAIL)

;THE FOLLOWING FOUR MUST BE CONSECUTIVE
NRPI:	0	;# REFS TO PAGE IN (BUT MAP WAS NOT SET UP, ETC)
NRPCI:	0	;# PAGE FAULTS REFS TO PAGE COMMING IN
NRPO:	0	;# REFS TO PAGE OUT
NRPGO:	0	;# TO PAGES GOING OUT

PAT:
LOC PATB+40

BBLK

PATCH:	BLOCK 140	;PATCH SPACE CODE AND CONSTANTS

EBLK

VPATCH:
VPAT:
BLOCK 40	;PATCH SPACE VARIABLES

;
; PROCESSOR BREAK ROUTINES
;
CLKBRK:	0	
;
INFORM CLKBRK+1,\.
;
BBLK
;
	SKIPE SYSDBG
	JRST CLKBR1
CLKBR2:	AOS NCLKI
	XCT CLUSAV	;STORE U IN AC17S FOR CURRENT USER (UNLESS NULL JOB)
	SKIPGE U,USER	;PICK UP INDEX OF CURRENT USER, SKIP UNLESS NULL JOB
	JRST CLKBKR	;JUMP IF NULL JOB WAS RUNNING
	SPM UPGML(U)	;STORE PAGE MAP AWAY
	AOSN UFLSF	;SKIP UNLESS GOT HERE FROM UFL6
	JRST CLUFLS
	MOVEM T,AC16S(U)	;STORE AWAY T
	MOVEI T,AC0S(U)
	BLT T,AC15S(U)	;STORE REST OF ACS
CLKBKR:	MOVE P,CPDLP	;SET UP CLOCK LEVEL PDL
	CONSZ 270220	;CHECK PDL OV, MEM PROTECT, NXM, FOV, AR OV
	JRST CLKB1	;JUMP ON LOSSAGE
CLKB1D:	CONSO 1000	;SKIP ON CLOCK BREAK
	JRST CLKB1E	;JUMP ON PARITY ERROR OR SPURIOUS INT
;IFN 340P,	DATAI CLK1,LQTIM
	SOSG @CLROOT	;COUNT DOWN, SKIP IF NOT TO NEXT REQUEST
	JRST CLQBRK	;SERVICE CLOCK QUEUE REQUEST
CLQBRT:	CONO 1000+APRCHN	;RESET CLOCK INTERRUPT
IFN 340P,[
	AOSGE T,DTIME
	JRST DSTPD	;WAIT IF DTIME CLOBERED DUE TO RATE EXCEEDED
	CAILE T,2
	MOVEI T,2
	MOVEM T,DTIME
	SKIPL CDISOF
	SKIPGE DISOFF
	JRST DSTPD
	AOSG DISON
	CONO DIS,1100\SDCHN_3\DISCHN	;RESTART DISPLAY
DSTPD:
]	SKIPGE 27FCLK
	PUSHJ P,TYP27S
	SETCMM CLKFL1
	SKIPL CLKFL1
	AOS TIME	;GET HERE EVERY THIRTIETH OF A SECOND
	AOSG SCHFLG
	JRST CLKB5	;TIME NOT UP
	JRST SCHED	;SCHEDULE

CLUFLS:	CONO PI,CLKON	;FROM UFLS
	MOVE P,CPDLP
	MOVE T,UPC(U)
	MOVEM T,CLKBRK
	AOS NUFLS
	JRST SCHED2

CLKBR1:	DATAI GODDT
	SKIPGE GODDT
	JRST DDT
	JRST CLKBR2

	;CLOCK QUEUE SERVICE
CLQBRK:	SKIPG U,CLROOT	;GET POINTER TO CURRENT BLOCK
	BUG .,CLK QUEUE SCREWED
	SKIPG T,1(U)	;GET POINTER TO NEXT BLOCK
	BUG .,CLK QUEUE SCREWED
	SETOM 1(U)	;INDICATE CURRENT BLOCK IDLE
	MOVEM T,CLROOT	;SET UP POINTER FOR NEXT BLOCK
	XCT 2(U)	;EXECUTE REQUEST (PROBABLY A JRST)
		;FALL THROUGH IF SINGLE INST RQ
CLQRET:		;RETURN FROM REQUEST
	SKIPN @CLROOT	;SKIP IF TIME TILL NEXT RQ NONZERO
	JRST CLQBRK	;ZERO TIME DELTA, DO NEXT RQ
	JRST CLQBRT	;RETURN TO CLOCK ROUTINE

CLQTTR:	JUMPE TT,CLQRET	;COMMON RETURN FOR TT IDLE FLAG
CLQREE:	MOVEI E,CLQRET	;RE ENTER RQ

;CLOCK OFF OR IN PROGRESS LEVEL ADD TO CLOCK QUEUE, CALL BY JSP E,
	; T HAS TIME TILL RQ IN 60'THS
	; C POINTS TO THREE WORD BLOCK, RQ'ED INST IS IN THIRD
CLQPUT:	MOVEI B,CLROOT-1
CLQPU2:	MOVE A,B	;REPLACE POINTER TO PREV BLOCK WITH CURRENT
	SKIPG B,1(B)	;GET LINK TO NEXT BLOCK
	JRST 4,.
	SUB T,(B)	;SUBTRACT TIME DELTA FOR NEXT BLOCK
	JUMPG T,CLQPU2	;JUMP IF RQ LATER THAN CURRENT BLOCK
	JUMPE T,CLQPU6	;JUMP IF RQ SAME AS " " (COULD USE PU2 BUT THIS FASTER)
	ADD T,(B)	;RQ EARLIER, ADD BACK
	MOVEM T,(C)	;SET DELTA OF BLOCK BEING ADDED
	SUB T,(B)	;COMPUTE NEG OF DELTA FOR NEXT BLOCK
	MOVNM T,(B)	;SET TIME DELTA FOR NEXT BLOCK
	MOVEM B,1(C)	;SET LINK OF NEW BLOCK TO NEXT
	MOVEM C,1(A)	;SET LINK OF PREV BLOCK TO NEW
	JRST (E)

CLQPU6:	SETZM (C)	;SET TIME DELTA OF NEW BLOCK TO ZERO
	MOVE A,1(B)	;GET POINTER TO NEXT BLOCK
	MOVEM A,1(C)	;SET POINTER OF NEW TO NEXT BLOCK
	MOVEM C,1(B)	;SET POINT OF CURRENT TO NEW BLOCK
	JRST (E)

;MAIN PROG LEVEL ADD TO CLOCK QUEUE
;CALL BY PUSHJ P,CLQADD
;WITH POINTER TO BLOCK IN NEXT WORD AND TIME TILL RQ IN T IN 60'THS
;POINTER TO BLOCK SHOULD NOT BE INDEXED BY C

CLQAD1:	MOVEI T,1	;RQ IN ONE TICK
CLQADD:	PUSH P,C
	MOVE C,@-1(P)	;GET BLOCK POINTER
	MOVEI C,@C
	SKIPL 1(C)	;SKIP IF IDLE
	JRST POPCJ1	;IGNORE THIS RQ, BLOCK ALREADY ACTIVE
	PUSH P,A
	PUSH P,B
	PUSH P,E
	SKIPN (C)	;DELTA WORD OF IDLE BLOCK SHOULD BE ZERO
	SKIPG T		;TIME SHOULD BE NON-ZERO
	JRST 4,.
	CONO PI,CLKOFF
	JSP E,CLQPUT	;ADD RQ
CLQDE4:	CONO PI,CLKON
	POP P,E
	POP P,B
	POP P,A
	JRST POPCJ1

;DELETE CLOCK QUEUE ENTRY
;CALL BY PUSHJ P,CLQDEL WITH POINTER TO BLOCK IN NEXT WORD
CLQDEL:	PUSH P,C
	MOVE C,@-1(P)	;GET BLOCK POINTER
	MOVEI C,@C
	CONO PI,CLKOFF
	SKIPGE 1(C)	;IGNORE RQ TO DELETE  IF IDLE
	JRST CKOCJ1
	PUSH P,A
	PUSH P,B
	PUSH P,E
	JSP E,CLQCLR
	JRST CLQDE4

CLQCLR:	MOVEI B,CLROOT-1	;CLOCK OFF OR IN PROGRESS VERSION
CLQDE2:	MOVE A,B
	SKIPG B,1(B)	;GET POINTER TO NEXT BLOCK
	BUG .,CLK QUEUE SCREWED
	CAME B,C	;SKIP IF FOUND BLOCK TO DELETE
	JRST CLQDE2
	SKIPG B,1(B)	;GET POINTER TO BLOCK AFTER ONE TO DELETE
	BUG .,CLK QUEUE SCREWED
	MOVEM B,1(A)	;PATCH AROUND DELETED BLOCK
	MOVE A,(C)
	ADDM A,(B)	;ADD DELTA OF DELETED BLOCK TO NEXT
	SETZM (C)	;CLEAR DEL
	SETOM 1(C)	;MARK IDLE
	JRST (E)

CLKB1:	MOVE T,CLKBRK
	CONSZ 200
	JRST CLKFO1	;FLOATING OVERFLOW ENABLED
CLKFO2:	CONSZ 20	;SKIP IF AR OV INT NOT ENABLED
	CONSO 10	;OV ENABLED, SKIP IF OV
	CONSZ 270000	;NOT OV, CHECK PDL OV, MEM PROTECT, NXM
	JRST CLKB1C	;PDL OV, NXM, ETC
	JRST CLKB1D	;ONLY CLOCK BREAK, AR OV JUST ENABLED
CLKFO1:	CONSO 100	;SKIP ON FLOATING OVERFLOW
	JRST CLKFO2	;NOT REALLY FLOATING OVERFLOW
CLKB1C:	JUMPL U,CNLJL	;NULL JOB LOST
	MOVEI A,0	;SET UP INTERRUPT BITS FOR USER
	CONSZ 20	;SKIP IF OV NOT ENABLED
	CONSO 10	;OV ENABLED, SKIP ON OV
	JRST CLB1A	;NOT AROV
	PUSHJ P,AROV
CLB1A:	CONSZ 200	;SKIP IF FL OV NOT ENABLED
	CONSO 100	;FL OV ENABLED, SKIP ON FL OV
	JRST CLB1B	;NOT FLOATING OVERFLOW
	PUSHJ P,ARFOV
CLB1B:	CONSO 270000	;SKIP IF PDL OV, NXM, OR MEM PROTECT
	JRST CLB1X
	CONSZ 10000	;NON EX MEM
	PUSHJ P,MEMHNG
	CONSO 200000
	JRST CLKB1H
	TRO A,200000	;PDL OVFLO
	TLNN T,LSRMOD	;SKIP IF IN USER MODE
	BUG .,PDL OV IN EXEC MODE
CLKB1H:	CONSO 20000	;MEM PROTECT
	JRST CLKB1G
	HLLZ D,UPGML+3(U)	;PICK UP FAULT BITS
	TLNE D,1000
	TLNN D,770	;ALL CONDITIONS WHICH ABORT INSTRUCTION
	JRST CLKB1J	;(PLUS PAGE NXM FOR RANDOMNESS)
	HLLZ T,UPGML+1(U)
	LSH T,5
	HRR T,UPGML+1(U)	;FIX UP OPC
	MOVEM T,CLKBRK	;RESET PC FROM OPC
	AOS NPGFLT
	HLRZ E,UPGML(U)
	TRNN E,400
	BUG CFHFPF,EXEC PG FAULT

	ANDI E,377	;FLUSH AGE, ETC.
	MOVE TT,LUMPS
	HRRZ W,USER
	TLNE D,100	;ATTEMPTED WRITE INTO READ ONLY PAGE
	JRST CFH4
CFHSW1:	HRRZM E,CFHUVP	;USER'S VIRTUAL PAGE NUMBER
	TLNE D,200
	JRST CFH4	;DBL
	TRZE E,200	;W 4.9 SET IF ENTERED FROM SWPPIN
	JRST CFH1	;VIRTUAL ADDRESS IN USER'S HIGH SEG
	MOVE C,UCPB1(W)
	TLNN TT,200000
	JRST CFH2	;MY LOWER DBR NOT HACKED
CFH3:	MOVE C,UCPB1(TT)
	TLNN TT,40000
	MOVE C,UCPB2(TT)
CFH2:	ROT E,-1
	ADD C,E
	HRLI C,222200
	SKIPGE E
	HRLI C,2200
	LDB E,C		;CIRC MEM USE POINTER FOR PAGE FAULT ADDRESS IS IN
	JUMPE E,CFH4	;REAL ILM
	CAIN E,-1
	JRST CFH4	;ON REFERENCE TO ABS PAGE ALSO ILM
	SKIPGE RPCL(W)
	JUMPGE W,CFF1	;BEING RPCLSRED?
	MOVEM A,CFHAS
	TLNE D,40
	JRST CFHRWF
CFHRW1:	AOSE CIRPSW
	JRST CFH5	;NOT AVAILABLE
	TRZE E,400000
	TRNE E,200000
	JRST CFHSW3
	CAML E,MMPMX
	JRST 4,.	;MMP OUT OF RANGE
	MOVE C,E	;CIRC PNTR ALREADY POINTS TO MMP
	ADD C,MMPEAD
CFHSW4:	LDB D,[410200,,(C)]	;TWO BITS OF MMP ENTRY GIVES DISPOSITION OF PAGE
	AOS NRPI(D)
	JRST @CFHDT(D)

CFHSW3:	PUSHJ P,UCPRL	;FIND MMP
	200000,,.+2
	JRST 4,.	;NONE?
	SUB P,[4,,4]
	JRST CFHSW4

CFH1:	MOVE C,UCPB2(W)
	TLNN TT,100000
	JRST CFH2
	JRST CFH3

CFHRWF:	TLNE D,10
	JRST CFHRW1	;SOMETIMES NO ACCESS SEEMS TO BE ON TOO
	HLRZ E,UPGML(W)	;ATTEMPTED WRITE IN READ/WRITE/FIRST MODE
	ANDI E,377
	HRRZ C,UPGML+4(W)
	TRZE E,200
	HRRZ C,UPGML+5(W)
	ROT E,-1
	ADD C,E
	HRLI C,420200
	SKIPGE E
	HRLI C,200200
	LDB E,C		;PAGE ENTRY PROTECTION BITS
	CAIE E,2
	JRST 4,.
	MOVEI E,3	;READ/WRITE
	DPB E,C
	JRST CFHX1

CFHDT:	CFHPI	;IN
	CFHPCI	;COMING IN
	CFHPO	;OUT
	CFHPGO	;GOING OUT

CFHPI:	HRLI C,2200
	PUSHJ P,UCPRL	;PAGE REALLY IN.  JUST SET UP MAP
	100000,,.+2	;RETURN ON MEMPNT
	JRST 4,.
	SUB P,[4,,4]	;FIND MEMBLT INDEX
	MOVE E,T
	HLLZS MMSWP(E)	;CLEAR LENGTH OF CIRC LIST (BUT NOT EXEC PGS COUNT)
	PUSHJ P,UCPRL	;STORE IN ALL MAPS LINKED
	400000,,QSWI1	;INSERT INTO MAPS AND COUNT OF USERS IN CP LIST
	JUMPL W,SCRPSJ	;DONT HACK FLSINS
	MOVEI C,0
	MOVNI A,1
CFHX:	SETOM CIRPSW
	TLNN W,200000
	JUMPL W,CPOPJ
CFH5A:	MOVSI D,200000
	SKIPN FLSINS(W)
	IORM D,USWST(W)	;WAITING FOR PAGE
	SKIPN FLSINS(W)
	MOVEM C,FLSINS(W)
	SKIPE FLSINS(W)
	CLEARM DLSRCH
	JUMPL W,CPOPJ
CFHX1:	MOVE A,CFHAS
	MOVSI D,1770	;CLEAR FAULT STATUS BITS
	MOVE U,USER
	JRST CFH6

CFH5:	JUMPL W,CPOPJ
	MOVE C,[SKIPL CIRPSW]
	JRST CFH5A

SCRPSJ:	SETOM CIRPSW
	POPJ P,

CFHPCI:
CFHPGO:
CFHPO2:	MOVSI D,100000	;BIT ON IF PAGE "IN TRANSIT"
	MOVNI A,1	;SIGNAL "SUCCESS"
	TLNN W,200000
	JUMPL W,SCRPSJ
	SKIPN FLSINS(W)
	MOVEM D,EPDL2(W)	;HANG USER UNTIL PAGE GETS WHERE IT'S GOING
	HRLI C,(TDNE T,)	;COMBINE WITH ADDRESS OF MMP
	JRST CFHX

CFHPO:	SKIPGE USWSCD(W)
	JRST CFBO1	;GUY LOCKED OUT
CFBO2:	MOVSI E,20000	;PAGE OUT, SWAP IN
	AND E,(C)
	CONO PI,UTCOFF
	JUMPN E,CFHPO5	;INITIAL SWAPIN
CFHPO7:	PUSHJ P,HMRQC
	JRST CFHPO1	;MEM NOT AVAILABLE
	MOVEI B,1
	DPB B,[410200,,(C)]	;INDICATE COMING IN
	HRRZ B,(C)	;OLD CP OF MMP
	HLL B,1(C)	;DISK ADDRESS
	MOVEM B,MEMPNT(A)
	JUMPN E,CFHPO8	;INITIAL SWAPIN
CFHPO9:	CAIGE A,TSYSM
	CAIGE A,SYSB
	JRST 4,.	;SHOULDN'T HAVE TO SWAP IN THE SYSTEM
	CONO PI,UTCON
	SOS NPGSWO
	AOS TSIPRQ	;TOTAL SWAP IN REQUESTS
	MOVEI B,MU23B
	DPB B,[MUR,,MEMBLT(A)]
	MOVEI B,NQCHN+1	;SWAPPING DISK CHANNEL
	DPB B,[M2311C,,MEMBLT(A)]
	MOVEI B,600000(A)
	HRRM B,(C)	;MAKE CP OF MMP POINT TO MEMPNT
	HRRM C,MEMBLT(A)	;STORE MMP ADDRESS IN RH OF MEMBLT
	CONO PI,UTCOFF
	HRLZM C,MMSWP(A)	;MMP ADDRESS
	MOVEI D,MMSWP(A)
	MOVE B,SILEND
	MOVEM D,SILEND
	HRRM D,(B)	;ADD TO END OF LIST
	AOS SILNG
	CONO PI,UTCON
	PUSHJ P,QSTRTR
	MOVSI D,100000
	TLNE W,-1
	ANDCAM D,USWST(W)	;SWAPPING IN A PAGE FOR THIS GUY SO CLEAR BEST EFORT MADE TO SWAP OUT BIT
	TLNN W,200000
	JUMPL W,CFHPO2
	AOS USIPRQ(W)
	JRST CFHPO2	;HANG USER UNTIL PAGE IN

CFHPO5:	LDB I,[DADDNL+1(C)]	;GET DSK #
	CAIL I,NQS
	JRST 4,.
	SKIPL QTUTO(I)
	JRST CFHPO7	;DISK TUT AVAIL
	CONO PI,UTCON
	MOVEI A,0	; LOCKED
	TLNN W,200000	;SCHEDULER
	JUMPL W,SCRPSJ
	MOVE C,[SKIPGE QTUTO]
	ADD C,I
	JRST CFHX

CFHPO8:	ANDCAM E,(C)	;CLEAR INITIAL SWAPIN BIT
	LDB D,[DADTNL+1(C)]	;GET TRK #
	IDIVI D,TUTEPW
	ADD D,QTUTO(I)
	HLL D,TBTBL(E)
	LDB E,D
	CAIGE E,TUTMNY
	SOS E
	DPB E,D
	HRRZS 1(C)	;CLEAR ASSIGNED TRACK NUMBER SO NEW SPACE ASSIGNED ON SWAPOUT
	JRST CFHPO9

CFHPO1:	CONO PI,UTCON	;NO MEM AVAILABLE TO SWAP INTO
	MOVEI A,0	;INDICATE NO PROGRESS POSSIBLE
	TLNN W,200000	;SCHEDULER
	JUMPL W,SCRPSJ
	SKIPGE MEMFRZ
	JRST CFHPO4
	MOVE C,[SKIPL MEMFRZ]
	JRST CFHX

CFHPO4:	MOVE C,[PUSHJ P,CFHPO3]
	MOVN D,SOLNG
	SUB D,SWPOPR	;- # PGS GOING OUT
	ADDI D,10.	;MAKE SURE AT LEAST 10. GOING OUT
	JUMPLE D,.+2
	ADDM D,SWPOPR
	MOVEI D,1
	SKIPN FLSINS(W)
	MOVEM D,EPDL2(W)
	JRST CFHX

CFHPO3:	PUSH P,A	;FLSINS ROUTINE (NEEDED MEM)
	MOVE A,MEMFR
	SUB A,NCBCOM
	CAIL A,5(T)
	JRST POPAJ1	;NEEDED MEM AVAILABLE
	ADD A,SOLNG
	ADD A,SWPOPR
	SUBI A,10.(T)
	JUMPGE A,POPAJ	;WILL EVENTUALLY WIN
	MOVNS A
	ADDM A,SWPOPR	;LOSING - SWAP SOME MORE STUFF OUT
	JRST POPAJ

CFF1:	MOVE C,CLKBRK
	TLNE C,LSRMOD
	BUG .,BEING RPCLSRED IN USER MODE
	MOVSI D,1770
	ANDCAM D,UPGML+3(W)
	LPMR UPGML(W)
	CONO 470000+APRCHN
	MOVE T,[BADBTS]
	IOR T,MSKST(W)
	AND T,A
	IORM T,PIRQC(W)
	CONO PI,CLKOFF
	JRST 10,UFL1

CFBO1:	MOVE E,MEMFR	;GUY SWAPPED BLOCKED
	SUB E,NCBCOM
	SUB E,AUSOPG
	SUB E,SILNG
	ADD E,SOLNG
	JUMPGE E,CFBO3	;SEEMS TO BE ROOM SO LET IT COME IN
	AOS NTSBUB
	MOVEI A,0	;HANG GUY UNTIL SWAP BLOCK GOES AWAY
	MOVE C,[SKIPGE USWSCD]
	ADDI C,(W)
	JRST CFHX

CFBO3:	AOS NTSBUP
	JRST CFBO2

CFH4:	JUMPL W,SWIILM
	AOS T,CLKBRK
	TLNE T,LSRMOD
	JRST CLKB1J
	MOVEI C,IOADCR	;FROM EXEC MODE SO RESET PC TO IOADCR
	EXCH C,CLKBRK
	MOVEM C,LEXFDR(U)	;AND SAVE FAULT EXEC ADR FOR DEBUGGING
	CLEARM DLSRCH	;IN CASE IT WAS SET
	CLEARM UMAPS(U)	;RESTORE NORMAL MAP IN CASE RANDOM ONE WAS IN USE
CLKB1J:	MOVEM D,LPFBTS(U)	;SAVE FOR DEBUGGING PURPOSES
	TLZE D,210	;NO ACCESS OR DBL
	TRO A,BIOADC	;ILM
	TLZE D,20	;PURE
	TLO A,(BPURE)
	TLZE D,100	;W IN RD ONLY
	TLO A,(BWIRO)
	TDNE A,[BIOADC\BWIRO]
	PUSHJ P,MPVMAS	;???
;NO ABORT-TYPE FAULTS, CHECK OTHERS
	TLZE D,2
	PUSHJ P,PCMARB
	TLZE D,2000
	PUSHJ P,CPROC1	;ONE PROCEED
	TLZ D,1	;IGNORE Q.T. INT (ONLY USED FOR RUNTIME)
	ANDCA D,UPGML+3(U)	;GET BITS FLUSHED BY TLZE'S
	TLZ D,4	;DONT CLEAR EXEC PG
CFH6:	ANDCAM D,UPGML+3(U)
CLKB1K:	LPMR UPGML(U)
CLKB1G:	CONO 470000+APRCHN	;RESET
CLB1X:	MOVE T,[BADBTS]
	IOR T,MSKST(U)	;GET OR OF ENABLED AND BAD BITS
	AND T,A		;GET AND WITH BITS ACTUALLY ON
	JUMPE T,CLB1XA	;NOT BAD OR ENABLED, FORGET ABOUT IT
	IORM T,PIRQC(U)	;BLAME IT ON THE USER
	JRST SCHED

CLB1XA:	SKIPE FLSINS(U)
	JRST SCHED
	JRST CLKB1D

CNLJL:	CONSZ 230220	;SKIP ON JUST "ADDR BREAK" (QUANTUM OVERFLOW)
	JRST 4,.+1	;NULL JOB LOST
	CONO 470000+APRCHN
	JRST SCHED

CFHFPF:	MOVSI D,1770	;FALSE PAGE FAULT
	MOVEI A,0
	JRST CFH6

EBLK
RINT:	0
BBLK
	BUG .+1,RANDOM INT
	JRST 12,@RINT

EBLK
R1NTAC:	BLOCK 20
RINT1:	0
BBLK
	MOVEM 17,R1NTAC+17
	MOVEI 17,R1NTAC
	BLT 17,R1NTAC+16
	MOVEI J,1
	JSP E,SPUR
	MOVSI 17,R1NTAC
	BLT 17,17
	JRST 12,@RINT1

PCMARB:	MOVE B,CLKBRK
	MOVEM B,UMARPC(U)
	TRO A,BMARI
	MOVEI B,0
	DPB B,[220300,,UPGML+2(U)]	;DISABLE MAR
	POPJ P,

CPROC1:	MOVE T,CLKBRK
	TLNN T,LSRMOD	;SKIP IF FROM USER MODE
	JRST CPRUUO
	TRO A,BPROC	;GIVE USER INTERRUPT
	POPJ P,

CPRUUO:	MOVE T,[JRST ONEPROC]	;ONE PROCEED INT. FROM EXEC. MODE
	MOVEM T,UEXIT	;CLOBBER EXIT TO RUN SYS CALL TO COMPLETION
	POPJ P,

AROV:	TLZE T,400000
	TLNN T,LSRMOD
	JRST AROV2	;NOT REALLY SET OR SET BY SYS
	MOVEM T,CLKBRK
	SKIPE PICLR(U)	;SKIP IF INTERRUPTS TO USER NOT ENABLED
	TRO A,AROIF	;GIVE USER INTERRUPT
	POPJ P,

AROV2:	MOVEM T,CLKBRK
	POPJ P,

ARFOV:	TLZE T,40000
	TLNN T,LSRMOD
	JRST AROV2
	MOVEM T,CLKBRK
	SKIPE PICLR(U)
	TLO A,(ARFOIF)
	POPJ P,

CLKB1E:	SETZM PARDIE
	CONSO PI,200000	;GET HERE FOR MEMORY PARITY ERROR
	JRST CLK1F	;SPURIOUS INT
	CONO PI,400	;TURN OFF WORLD
	CONO PI,240000	;RESET
	MOVSI B,1
	TDNE B,SUPCOR
	JRST 4,.	;MAKING ERRORS IN REAL TIME
	IORM B,SUPCOR
	AOS PARERR
	MOVE T,CLKBRK
	MOVEM T,PARPC
	MOVE T,USER
	MOVEM T,PARUSR
	SPM PARPG
	MOVEI TT,TSYSM-1+IFN PDP6P,16.
	MOVEI D,0	;POINTER TO ERROR BUFFER
PARFX3:	CAIL TT,TSYSM
	JRST PARFX7
	LDB T,[MUR,,MEMBLT(TT)]
	CAIN T,MUHOLE
	JRST PARFX8	;HOLE THERE
PARFX7:	MOVEI T,600000(TT)
	DPB T,[.PAREP+EXEUMP]
	LPMR PARPG	;SET UP TO CHECK PAGE # IN TT
PARFX1:	CONO PI,200000	;CLEAR PAR ERR
	MOVEI B,0	;ADDRESS WITHIN PAGE
PARFX5:	MOVE C,400000+PAREP*2000(B)	;REFERENCE EVERY MEMORY LOCATION
	CONSZ PI,200000	;PARITY ERR?
	JRST PARFX4	;YES
	CAIGE B,1777	;SKIP ON FINISHED WITH BLOCK
	AOJA B,PARFX5
PARFX8:	SOJGE TT,PARFX3	;CHECK NEXT PAGE
	JRST PARFX2	;DONE

PARFX4:	MOVE E,TT
	LSH E,10.
	IOR E,B	;MAKE MEM ADR
	MOVE A,USRHI
	CAIGE E,USRSTG(A)
	SETOM PARDIE	;PARITY ERROR IN EXEC CORE
	CAIL TT,TSYSM
	JRST PARFX6
	LDB T,[MUR,,MEMBLT(TT)]
	CAIE T,MUFR
	CAIN T,MUINP
	JRST PARFX6
	CAIE T,MUDISB
	CAIN T,MUFRT
	JRST PARFX6
	CAIN T,MUDDT
	JRST PARFX6
	SOJE T,PARFX6	;USER
	SETOM PARDIE	;ERR IN CRITICAL MEMORY (DISK DIR, ETC)
PARFX6:	MOVEM C,400000+PAREP*2000(B)	;FIX UP MEMORY AS BEST WE CAN
	MOVEM C,PARCON(D)	;SAVE LOSING CONTENTS
	MOVEM E,PARADR(D)	;SAVE LOSING ADDRESS
	CAIGE D,MXPARS-1	;OVERFLOWING BUFFER?
	AOJA D,PARFX1	;NO
	JRST 4,PARFIN	;YES, WE ARE LOSING WITH INFINTE PARITY ERRORS

PARFX2:
PARFIN:	MOVEI A,0
	DPB A,[.PAREP+EXEUMP]
	LPMR PARPG	;SET UP MAP
	MOVEM D,PARCNT	;SAVE AWAY COUNT OF ERRORS IN BUFFER
	SKIPE PARDIE
	JRST 4,.	;FATAL ERROR (DONT ALLOW CONTINUE SINCE ERR IS KNOW TO BE A LOSER)
	CONO PI,200	;TURN WORLD BACK ON
	JRST SCHED


CLK1F:;	MOVEI J,APRCHN	;DO NOT TAKE THESE OUT WITHOUT SEEING RG!!!!
;	JSP E,SPUR
	JRST SCHED


MEMHNG:
IFN PDP6P,[
	LDB B,[221100,,UPGML(U)]	;FAULT ADDR
	TRZE B,400
	JRST MEMHN1
	HRRZ C,UDBR1(U)
	TRZE B,200
	HRRZ C,UDBR2(U)
	ROT B,-1
	ADDI C,(B)
	HRLI C,221100
	SKIPGE B
	HRLI C,1100
	LDB C,B
	CAIGE C,PDP6BM_-10.
	JRST MEMHN1
	MOVE B,CLKBRK
	TLNE B,LSRMOD
	JRST MEMHN3	;USER MODE PDP6 NXM
	MOVEI B,IOCER3	;PDP6 MEM
	HRRM B,CLKBRK
	JRST MEMHN2
]

MEMHN1:	BUG .+1,NXM
MEMHN2:	CONO 10000+APRCHN	;CLEAR NON EX MEM AFTER HALT TO RESET MEMORY
	MOVSI B,4
	IORM B,SUPCOR
	MOVE T,CLKBRK
	MOVEM T,NXMPC
	MOVE T,USER
	MOVEM T,NXMUSR
	AOS NXMERR
	POPJ P,

IFN PDP6P,[
MEMHN3:	MOVSI B,BIOADC	;GIVE MPV INTERRUPT
	IORM B,PIRQC(U)
	JRST MEMHN2
]
;
; SLOW CLOCK SERVICE ROUTINE
;
SSLCK:
IFN DPKPP,[
	CONSO DPK,7
	CONO DPK,TTYCHN	;CROCK
]
	MOVE A,UTTBF
	CAIGE A,30
	JRST SSLCK2
	SETOM UTBFLF	;SIGNAL CORE JOB TO FLUSH UTAPE BUFFERS
	AOS NCORRQ
SSLCK2:	SKIPE UTTYCT	;SKIP IF NO NEW USERS
	PUSHJ P,USTART	;NEW USER TO START
IFN 340P,[
	SKIPL T,DWDS
	MOVEI T,0
	ADDI T,MDISWD
	MOVEM T,DWDS	;RESET DISPLAY RATE COUNTER
]
IFE NEWDTP,[
	MOVE T,TIME
	AOSN UIDLE	;SKIP IF DEC TAPE NOT IDLE
	JRST SSLCK4	;DEC TAPE IDLE
	SUB T,LUTOTM	;SUBTRACT LAST UTC OPERATION TIME
	CONSO UTC,4000
	CAIGE T,MXOPT*SCLKI	;SKIP IF DEC TAPE HUNG TOO LONG ON ONE OPERATION
	JRST SSLCK3	;OK
	SETOM UTHERR	;SET UTC HUNG ERR FLAG
SSLCK1:	CONO UTC,CUINT	;CAUSE DEC TAPE INTERRUPT ROUTINE TO RUN
SSLCK3:
]
	CONO PI,UTCOFF
IFN NEWDTP,[
	MOVE T,TIME
	AOSN UIDLE
	JRST SSLCK4
	SUB T,LUTOTM
	CAIGE T,MXOPT*SCLKI
	JRST SSLCK3
	SETOM UTHERR
SSLCK1:	SETOM CUINT
	CONO PI,4000+1_<7-UTCCHN>
SSLCK3:
]
IFN DECDKC,[
	SETOM QGTBZY
	CONO PI,4000+1_<7-DSKCHN>
]
IFE DECDKC,	CONO DC0,DCSET+DCIENB+DSKCHN	;ACTIVATE IDLE
IFN NMTCS,	PUSHJ P,MSMAGC
	CONO PI,UTCON
	AOS QACTTM
SSKQ1:	SKIPE SWPOPR
	JRST SSKQ2
	MOVN A,LMEMFR
	ADDI A,10.
	SKIPLE A
	ADDM A,SWPOPR	;INADEQUATE SPACE IN LOW HALF, SWAP OUT TO MAKE ROOM
SSKQ2:
IFN 340P,[
	SKIPL DISUSR
	PUSHJ P,DISCHK	;CHECK FOR 340 DEATH
]
	PUSHJ P,PDCCHK	;CHECK ON REAL-TIME HACKS
	PUSHJ P,PTRCHK	;CHECK ON PAPER TAPE READER
	PUSHJ P,PTPCHK	;CHECK ON PAPER TAPE PUNCH
	SKIPN CCSDEV
	JRST SCDCK3
	SETZM CCSDEV
	MOVSI I,-128.
SCDCK1:	SKIPGE A,DCHNTC(I)
	TLNE A,300000
	JRST SCDCK2
	AOS CCSDEV
	SUB A,[1,,]
	TLNN A,777
	TLZ A,400000
	MOVEM A,DCHNTC(I)
SCDCK2:	AOBJN I,SCDCK1
SCDCK3:;	JSP E,CHECK	;CHECK FOR CLOBBERED DEVICES
IFN PDP6P,[
	SKIPL PDPISR
	CONO DSDEV,DSDCHN	;ENABLE INTERRUPTS FROM 6
]
IFN NETP,[
	CONI IMP,IMPCNI	;KEEPS HOST READY ON
	PUSHJ P,IMPOST	;START UP OUTPUT
	SKIPLE IMNCS
	PUSHJ P,IMPCCL	;CLOSE NETWORK CHANNELS
]
	MOVE E,[ALCR1,,A]
	BLT E,E
	MOVSI U,-NCT
	JRST A
ALCR1:	MOVN T,USRRCE(U)	;A
	ASH T,-4		;B
	ADDM T,USRRCE(U)	;C
	AOBJN U,A		;D
	JRST .+1		;E
	MOVN T,USRRCE+NCT
	ASH T,-4-2	;DISOWNED JOBS
	ADDM T,USRRCE+NCT
	MOVN T,USRRCE+NCT+1
	ASH T,-4+1	;SYS AND CORE JOBS
	ADDM T,USRRCE+NCT+1
	MOVEI T,0
	MOVE W,[ALCR4,,A]
	BLT W,W
	JRST A
ALCR4:	MOVN H,JTMU(T)	;A
	ASH H,-4
	ADDM H,JTMU(T)
	MOVE H,MSKST(T)
	ANDI H,BSCLK	;E
	SKIPE UNAME(T)	;TT
	IORM H,PIRQC(T)	;I
	ADDI T,LUBLK	;Q
	CAMGE T,USRHI	;J
	JRST A	;R
	JRST .+1	;W

	SKIPGE 37	;CHECK FOR PLANNED SYSTEM DEATH
	PUSHJ P,DEATH	;ABOUT TO START DYING
	JFCL
	MOVEI T,SCLKI
	MOVEI C,SSLCKB
	JRST CLQREE	;RE-ENTER RQ FOR SLOW CLOCK BREAK

VSSLCK:	MOVSI T,100
	IORM T,SUPCOR	;CAUSE VERY SLOW CLOCK TO RUN
	MOVEI T,VSCLKI
	MOVEI C,VSLCKB
	JRST CLQREE

IFN CCLKP,[
RCCLK:	DATAI 374,T	;HACK CHESS CLOCK
	TRNE T,4000
	AOSA CCLK1
	AOS CCLK2
	MOVEI T,6
	MOVEI C,CCLKB
	JRST CLQREE
]
SSLCK4:	MOVEM T,LUTOTM
	JRST SSLCK1
IFN 340P,[

DISCHK:	SKIPGE DISOFF
	POPJ P,
	AOSLE DISDIE
	SKIPGE CDISOFF
	POPJ P,
	MOVEI T,1
	MOVEM T,DTIME
DISZAP:	MOVEI T,DIS300-1	;CAUSE 340 TO STOP AND INTERRUPT SOON
	MOVEM T,DBLKOP
	CLEARM DISOFF
	CONO DIS,5100+SDCHN_3+DISCHN
	POPJ P,
]

DEATH:	SKIPL SHUTLK
	POPJ P,
	SETZM 37	;CLEAR START DYING FLAG
	MOVEI T,60.*5.*60.	;5 MIN
	MOVEM T,DEDTIM
	LSH T,-1
	ADD T,TIME
	MOVEM T,SHUTDN
	PUSHJ P,CLQDEL
	 DEDBLK
DEATHX:	SKIPN T,DEDTIM
	POPJ P,
	AOS (P)
	MOVEI TT,0
	CAIGE T,40.*60.
	JRST DEATHY
	MOVE TT,T
	LSH TT,-2
DEATHY:	MOVEM TT,DEDTIM
	SUB T,TT
	PUSHJ P,CLQADD
	 DEDBLK
DEATHM:	MOVEI A,BSYSDN
	PUSHJ P,INTALL	;TELL THE WORLD
	MOVSI T,200000	;CAUSE TYPE OUT ON UNLOGGED-IN CONSOLES
SUPSET:	IORM T,SUPCOR
	POPJ P,

;15 SECOND CLOCK
15SCLK:
IFN NETP,	PUSHJ P,IMRSTO	;RESET CONTROL LINK RFNM WAIT FOR LOSING IMP.
	MOVSI B,100000	;SET UP TO CLEAR "BEST EFFORT TO SWAP OUT BIT"
	CLEARB T,NUSWB	;# USERS LOCKED OUT
	SETOM BUSR	;SMALLEST SWAPPED BLOCKED USER
	SETZM BUSIZ	;SIZE OF SMALLEST SWAPPED BLOCKED USER
	CLEARM ASBUM	;REAL MEM OCC BY ACTIVE SWAPPED BLOCKED LOSERS
	MOVSI D,400000	;TO CLEAR SWAPPED BLOCKED BIT
15S1:	CAML T,USRHI
	JRST 15S2
	SKIPN UNAME(T)
	JRST 15S3
	MOVN C,USWPRI(T)
	ASH C,-2
	ADDM C,USWPRI(T)	;DECAY JOB SWAP PRI'S
	MOVE C,NMPGS(T)
	SUBI C,1	;COMPENSATE FOR PAGE ZERO ALWAYS IN
	CAMLE C,NSWPGS(T)	;SKIP ON NOT COMPLETELY OUT
	ANDCAM B,USWST(T)
	SKIPGE USWSCD(T)
	JRST 15S4	;CLEAR SWAPPED BLOCK BIT AND MAYBE ADD TO AUSOPG AND TRUMM (IF HE WAS HUNG ON IT)
15S3:	ADDI T,LUBLK
	JRST 15S1

15S2:	PUSHJ P,SWSCD	;SWAP BLOCK LOSERS IF NECESSARY
	MOVSI T,-NCT-2
15S5:	MOVN C,SWRCE(T)	;DECAY TREE SWAP PRI'S
	ASH C,-2
	ADDM C,SWRCE(T)
	AOBJN T,15S5
	MOVEI T,15.*60.
	MOVEI C,15SCLB
	JRST CLQREE

15S4:	ANDCAM D,USWSCD(T)	;CLEAR SWAP BLOCK BIT
	SKIPN TT,FLSINS(T)	;WAS HE HUNG TESTING IT
	JRST 15S3
	SUBI TT,(T)
	CAME TT,[SKIPGE USWSCD]
	JRST 15S3	;HE WASN'T HUNG ON THIS
	CLEARM FLSINS(T)	;HE WAS SO NOW HES ACTIVE
	MOVE TT,NMPGS(T)
	ADDM TT,TRUMM	;GUY IS NOW RUNNABLE
	SUB TT,NSWPGS(T)	;ANY PAGES HE MAY HAVE IN MEM NO LONGER BELONG TO A BLOCKED USER
	MOVNS TT
	ADDB TT,BUMPGS
	SKIPGE TT
	CLEARB TT,BUMPGS
	MOVE TT,NSWPGS(T)	;ANY SWAPPED OUT PAGES BELONG TO AN ACTIVE USER
	ADDM TT,AUSOPG
	JRST 15S3
SWSCD:	MOVE E,TRUMM	;SEE IF NECESSARY TO SWAP BLOCK SOMEONE
	CAIGE E,SYSUSM-SYSB-40
	POPJ P,	;NO SHOULD FIT
	MOVE E,MEMFR
	SUB E,NCBCOM
	ADD E,SOLNG
	SUB E,SILNG
	SUB E,AUSOPG
	ADD E,BUMPGS	;WILL SWAP OUT BLOCKED USERS FIRST
	ADD E,ASBUM
	SUBI E,20	;SLOP
	JUMPGE E,CPOPJ	;SHOULD HAVE ROOM FOR EVERYBODY
	MOVMM E,SWSCT1	;SAVE # PGS REQ
	MOVNI E,1	;NEED TO GRONK USER (MAYBE)
	CLEARB T,TT	;TT SWP PRI OF PROCESS
	MOVEI R,0	;R SWP PRI OF TREE
SWSCP1:	CAML T,USRHI
	JRST SWSCP2
	SKIPE UNAME(T)
	SKIPE USTP(T)
	JRST SWSCP7
	SKIPGE USWSCD(T)
	JRST SWSCP7	;GUY ALREADY LOCKED OUT
	SKIPE FLSINS(T)
	JRST SWSCP4	;SEE IF REALLY BLOCKED OR JUST PAGE WAIT
SWSCP5:	MOVE B,UTMPTR(T)
	CAML R,SWRCE-USRRCE(B)
	CAMG TT,USWPRI(T)
	JRST SWSCP6	;THIS GUY A BIGGER LOSER THAT PREV BIGGEST
SWSCP7:	ADDI T,LUBLK
	JRST SWSCP1

SWSCP6:	MOVE E,T
	MOVE R,SWRCE-USRRCE(B)
	MOVE TT,USWPRI(T)
	JRST SWSCP7	;GUY REALLY BLOCKED

SWSCP4:	MOVE B,USWST(T)
	TLNE B,200000
	JRST SWSCP5
	JRST SWSCP7


SWSCP2:	JUMPL E,CPOPJ	;NO VICTIM
	MOVE B,NMPGS(E)
	CAIGE B,SYSUSM-SYSB-30
	JRST SWSCP9	;"SMALL LOSER"
	SUB B,NSWPGS(E)
	CAMLE B,SWSCT1	;SKIP ON WILL STILL NEED TO BLOCK MORE LOSERS
	POPJ P,
SWSCP9:	MOVSI B,400000
	IORM B,USWSCD(E)	;SWAP BLOCK LOSER
	AOS NUSWB
	AOS NTUSB
	MOVE TT,NMPGS(E)
	CAMLE TT,BUSIZ
	JRST SWSCP8
	MOVEM TT,BUSIZ
	MOVEM E,BUSR
SWSCP8:	SUB TT,NSWPGS(E)
	SOSGE TT
	MOVEI TT,0
	ADDM TT,ASBUM	;THIS GUY SWAPPED BLOCKED
	MOVN TT,NMPGS(E)
	ADDM TT,TRUMM	;DOESNT COUNT ANY MORE
	SKIPGE TRUMM
	CLEARM TRUMM
	MOVN TT,NSWPGS(E)
	ADDM TT,AUSOPG	;NOT REALLY ACTIVE ANY MORE
	JRST SWSCD	;SEE IF THATS ENUF
;
; USER SCHEDULER
;
SCHED:	SKIPGE U,USER
	JRST SEARL0	;NULL JOB
	MOVE T,CLKBRK
	MOVEM T,UPC(U)
SCHED2:	AOS NSKED
	MOVSI T,UEXIT	;GET HERE FROM CLUFLS
	HRRI T,UUO(U)
	BLT T,UUO+UUOH-UEXIT(U)
	LDB A,[2300,,UPGML+3(U)]
	LSH A,-2	;CONVERT TO 4 USEC INTERVAL
	ADDM A,UTRNTM(U)	;INCREASE RUN TIME
	ADDI A,250.	;ACCOUNT FOR OVERHEAD IN STARTING UP
	ADDM A,JTMU(U)	;DECREASE PROCEDURE PRIORITY
	ADDM A,@UTMPTR(U)	;DECREASE PROCEDURE TREE PRIORITY
	MOVE T,NMPGS(U)
	SUB T,NSWPGS(U)
	IMUL T,A
	MOVE Q,UTMPTR(U)
	ADDM T,USWPRI(U)	;CHARGE AGAINST SWAPPINNG PRI
	ADDM T,SWRCE-USRRCE(Q)	;AND FOR TREE
	SKIPL Q,RTIMER(U)	;SKIP UNLESS RUNTIME INT ACTIVE
	JRST SEARRT
SCHED3:	SKIPGE DLSRCH
	JRST SEAREP	;DELETE SEARCH, EXIT
SEARL0:	CLEARM TRUMM	;TOTAL RUNNABLE USER MEM
	CLEARM AUSOPG	;ACTIVE USER SWAPPED OUT PAGES
	CLEARM BUMPGS	;PAGES IN REAL CORE BELONGING TO BLOCKED USERS
	CLEARM ASBUM	;PGS IN REAL MEM OCC BY SWAPPED BLOCKED LOSERS
	SKIPL A,SWOUPG
	PUSHJ P,SWPUP
	SKIPN SWPOPB
	SKIPE SWPOPR
	PUSHJ P,SWPON	;SWAP OUT STUFF
IFN NSWPV,[
	SKIPGE CIRPSW
	PUSHJ P,SWPPIN	;SERVICE SWAPPING VARIABLES
]
	SETZB U,J	;JOB BEING SCHEDULED
	SETOM I		;BEST USER SO FAR
	SETZM RNABLU	;NUM RUNABLE USERS
	JRST SEARL1

SEARRT:	SUB Q,A
	MOVEM Q,RTIMER(U)
	JUMPGE Q,SCHED3
	MOVSI T,(BRTIME)	;GIVE RUNTIME INTERRUPT
	IORM T,PIRQC(U)
	JRST SCHED3

;MAIN SEARCH LOOP, RETURN HERE TO EXAMINE NEXT PROCEDURE
SEARL:	MOVEI U,LUBLK	;LENGTH OF USER VAR BLOCK
	ADDB U,J	;STEP TO NEXT USER
	CAML U,USRHI	;SKIP IF EXISTS
	JRST SEAREN	;ALL PROCEDURES HAVE BEEN EXAMINED
SEARL1:	SKIPE T,USTP(U)
	JRST SEARS1	;EMPTY OR STOPPED JOB SLOT
	SKIPE A,PIRQC(U)
	JRST SEAR2A	;FIRST WORD INTERRUPT PENDING
SEARL2:	SKIPE T,IFPIR(U)
	JRST SEAR2B	;SECOND WORD INTERRUPT PENDING
SEARL3:	SKIPN FLSINS(U)
	JRST SEARC	;NOT BLOCKED
SEARL4:	MOVE T,EPDL2(U)
	XCT FLSINS(U)	;TEST BLOCKING CONDITION (MAY SKIP ONCE OR TWICE)
	JRST SEARLB	;UNRUNABLE
	JRST SEARC	;LOW PRIORITY UNBLOCK
	SKIPA Q,[-1]	;HIGH PRIORITY UNBLOCK
	MOVEI Q,3	;EXTRA LOW PRIORITY
	JRST SEARC2

SEARC:	SETZM Q		;SET TO NORMAL PRIORITY
	PUSHJ P,UPRIVL
	SOJA Q,SEARC2
	JRST SEARC2
	SKIPGE APRC(U)
	ADDI Q,2	;DISOWNED
SEARC2:	AOS RNABLU	;ANOTHER RUNABLE USER
	MOVE T,TIME
	MOVEM T,LUBTM(U)	;RECORD LAST TIME UNBLOCKED
	SKIPGE USWSCD(U)
	JRST SEARC7	;HE'S SWAPPED BLOCKED SO HE DOESNT COUNT
	MOVSI T,400000
	ANDCAM T,USWST(U)	;RUNNABLE SO NOT DESIRED OUT
	MOVE T,NMPGS(U)
	ADDM T,TRUMM	;TOTAL RUNNABLE USER MEM
	MOVE T,NSWPGS(U)
	ADDM T,AUSOPG	;TOTAL PAGES OF RUNNABLE USERS SWAPPED OUT
SEARC4:	CAMN U,UREALT
	JRST SEARP2	;JUMP IF SCHEDULING REAL TIME USER IN HIGH PRIORITY PHASE
	JUMPL I,SEARC5
	CAMN I,UREALT
	JRST SEARL	;JUMP IF REAL TIME USER SCHEDULED
SEARC5:	SKIPLE T,URTIME(U)	;NON SKIP IF POSSIBLE REAL TIME BLOCK
	TLNN T,1	;SKIP IF REAL TIME BLOCK UNLESS PI IN PROGRESS
	JRST SEARC6
	SKIPGE PICLR(U)	;SKIP IF PI IN PROGRESS
	JRST SEARL	;REAL TIME BLOCKED
SEARC6:	MOVE T,@UTMPTR(U)	;GET AMOUNT OF MACHINE TIME USED RECENTLY BY TREE PROCEDURE IS IN
	ASH T,(Q)	;LARGER C(T)= LOWER PRIORITY; INCREASE PRIORITY IF Q INDICATES
	JUMPL I,SEARP1	;FIRST NON-NULL JOB
	CAMG T,U0P
	JRST SEARP3	;JUMP IF USER BEING CONSIDERED HAS LOWER USRRCE (HIGHER PRIORITY)
	MOVE A,JTMU(U)	;USER HAS LESS PRIORITY, BUT MAY RUN ANYWAY IF JTMU'S DIFFER BY ENUF
	ASH A,3(Q)	;MULTIPLY BY 8+Q
	CAML A,U0PP	;DOES JOB HAVE LESS THAN 1/8 OF BEST SO FAR MACHINE TIME?
	JRST SEARL	;DOESNT MAKE IT
SEARP5:	MOVE A,JTMU(U)
	ASH A,(Q)
	MOVEM T,U0P	;STORE TIME USED RECENTLY BY TREE
	MOVEM A,U0PP	; " BY PROCEDURE
SEARP2:	MOVEM U,I	;NEW BEST USER SO FAR
	JRST SEARL	;TRY NEXT

SEARC7:	MOVE T,NMPGS(U)	;RUNNABLE AND SWAPPED BLOCKED
	SUB T,NSWPGS(U)
	SOSGE T
	MOVEI T,0
	ADDM T,ASBUM
	JRST SEARC4

SEARLB:	JUMPE U,SEARL	;DON'T FIGURE SYSTEM JOB
	MOVE T,USWST(U)
	SKIPL USWSCD(U)	;IF LOCKED OUT, DONT COUNT
	TLNN T,200000
	JRST SEARB1	;NOT WAITING FOR PAGE
	MOVE T,NMPGS(U)	;USER IS WAITING FOR PAGE SO COUNT FOR ACTIVE
	ADDM T,TRUMM
	MOVE T,NSWPGS(U)
	ADDM T,AUSOPG
	JRST SEARL

SEARB1:	TLNE T,100000
	JRST SEARL	;HAVE MADE BEST SWAPOUT EFFORT
	MOVE T,NMPGS(U)
	SUB T,NSWPGS(U)
	SOSGE T
	MOVEI T,0
	ADDM T,BUMPGS	;REAL MEM PGS BELONGING TO BLOCKED USERS
	JRST SEARL

SEARS1:	SKIPN UNAME(U)
	JRST SEARL
	MOVE T,USWST(U)	;GUY STOPPED, DOES HE HAVE PAGES IN REAL MEM?
	TLNE T,100000
	JRST SEARL	;HAVE TRIED BEST EFFORT TO SWAP OUT
	MOVE T,NMPGS(U)
	SUB T,NSWPGS(U)
	ADDM T,BUMPGS
	JRST SEARL

;SWAP OUT N PAGES (IN SWPOPR)
SWPON:	MOVE C,SOLNG
	SKIPGE CIRPSW	;CAN'T DO ANYTHING WITHOUT CIRPSW
	CAIL C,3
	POPJ P,	;ALREADY STUFF ON WAY OUT
	MOVE C,PSWCLS
	SKIPL U,PSWOUS
	CAML U,USRHI
	JRST SWPON1
	SKIPE UNAME(U)	;SKIP ON USER KILLED
	SKIPL USWST(U)
SWPON1:	PUSHJ P,SWPON2	;FIND NEW USER TO FLUSH
	JUMPL U,SWUP8
	MOVSI A,(SETZ)
	IORM A,USWST(U)
	MOVEM C,PSWCLS
	MOVEM U,PSWOUS
	MOVE T,UPC(U)
	TLNE T,LSRMOD
	JRST SWPU1	;OK TO SWAP USER
	SKIPE FLSINS(U)
	JRST SWPU1A
	PUSHJ P,PCLSR
	POPJ P,
;		DROPS THROUGH

SWPU1:	AOS NSOUSR
	TLO A,40000
	CAILE C,1	;CLASS
	IORM A,USWST(U)	;INDICATE USER WAS RUNNABLE AT TIME OF SWAP OUT
	MOVE B,PSWLC
	AOSE PSWSFL
	JRST SWPU3A	;PICK UP FROM WHERE LEFT OFF
	MOVE C,UDBR1(U)	;ADDRESS OF PAGE MAP (START FROM PG 0)
	LDB B,[2300,,HUSRAD(U)]	;CAN BE GREATER THAN RANGE OF DBR1 BUT WILL BE LIMITED BY DBL
	MOVE J,UCPB1(U)
	SETOM SWPP0F
SWPU7C:	ASH B,-10.	;SAVE SIGN BIT
	LDB T,[230700,,C]	;GET DBL
	LSH T,1	;2 PGS / WD
	CAIGE T,(B)
	HRR B,T	;MIN HUSRAD/2000, 2*DBL
	TRNN B,-1
	JRST SWPU7B	;NO PGS THIS DBR
	HRLI J,442200
	HRLI C,442200	;CNVRT TO BYTE PNTR TO MAP
	MOVEM C,SWPMBP
	MOVEM J,SWPCBP
SWPU2:	ILDB D,SWPCBP	;CIRC PNTR ENTRY
	ILDB A,SWPMBP	;PAGE MAP ENTRY
	AOS NSOPGS
	MOVEM B,PSWLC
	JUMPE D,SWPU3A	;DOESN'T HAVE PAGE
	AOSN SWPP0F
	SKIPE USTP(U)	;DON'T SWAP OUT PAGE 0 IF NOT STOPPED
	CAIN D,-1
	JRST SWPU3A	;PAGE IS ABSOLUTE
	TRNN A,600000
	JRST SWPU3A	;NO ACCESS
	ANDI A,777	;PAGE NUMBER
	HRRZ D,MMSWP(A)	;NUMBER OF USERS WHO HAVE THIS PAGE
	SOJN D,SWPU4	;PAGE IS SHARED
SWPU6:	MOVE C,PSWOUS
	PUSHJ P,SWPOPG
	JRST SWPU3
	MOVE C,SOLNG
	CAIGE C,20.	;ENOUGH FOR NOW
	SOSG SWPOPR
	POPJ P,
SWPU3:	MOVE B,PSWLC
	MOVE U,PSWOUS
SWPU3A:	TRNE B,-2	;IN PAIRS SO DON'T TEST LOW BIT
	SOJA B,SWPU2
SWPU7B:	TLON B,400000
	JRST SWPU7	;DO UDBR2
SWPU7A:	SETOM PSWOUS
	MOVSI B,100000
	IORM B,USWST(U)	;SET BEST EFFORT BIT
	JRST SWPON

SWPU7:	LDB C,[2300,,HUSRAD(U)]
	SUBI C,400000
	JUMPLE C,SWPU7A
	HRR B,C
	MOVE C,UDBR2(U)
	MOVE J,UCPB2(U)
	JRST SWPU7C

SWPU1A:	MOVSI T,20000	;SWAPPING OUT PAGES OF PROCEDURE BLOCKED IN EXEC MODE
	IORM T,USWST(U)
	JRST SWPU1

SWPU4:	AOSE CIRPSW	;PAGE IS SHARED
	BUG .,CIRPSW LOCKED IN SWAP OUT CODE
	MOVE C,[2200,,MEMPNT(A)]
	MOVEM A,SWOBK
	PUSHJ P,UCPRL
	400000,,SWPU5
	SETOM CIRPSW
	MOVE A,SWOBK
	JRST SWPU6

SWPU5:	SKIPGE USWST(U)
	POPJ P,	;THIS USER WANTED OUT
	SUB P,[4,,4]
	SETOM CIRPSW	;SHARED W/USER WHO IS WANTED IN CORE
	JRST SWPU3

SWUP8:	SETZM SWPOPR
	SETOM PSWOUS
	POPJ P,

SWPUP:	SKIPL CIRPSW
	POPJ P,
	HLRZ U,A	;U HAS INDEX
	HRRZS A	;A HAS VIRTUAL PAGE #
	PUSHJ P,UPLC	;RETURN POINTERS IN T AND Q
	LDB A,T	;GET MAP ENTRY
	TRNE A,600000
	JRST SWPUP2	;SWAP IT OUT
SWPUP1:	SETOM SWOUPG
	POPJ P,

SWPUP2:	ANDI A,777
	MOVNI C,1
	PUSHJ P,SWPOPG
	POPJ P,
	JRST SWPUP1

SWPON2:	SETOM PSWSFL	;START FROM BEG OF USER
	MOVNI U,1	;BEST LOSER SO FAR
	MOVNI T,30.*60.
	ADD T,TIME	;A MINUTE AGO
	MOVEI J,2*LUBLK
	MOVEI C,NSSCDC	;# SWAP OUT CLASSES
SWPON4:	CAML J,USRHI	;C HAS INDEX OF MAX CLASS INTERESTED IN
	JRST SWPONX
	SKIPN LSWPR(J)	;??
	SKIPN UNAME(J)
	JRST SWPON3	;HAS SWITCHES LOCKED OR NOT FOR REAL
	MOVE B,USWST(J)
	SKIPE NMPGS(J)
	TLNE B,100000
	JRST SWPON3	;NO MEM OR HAVE TRIED TO FLUSH
	MOVEI I,1
	TLNE B,200000
	JRST SWPON5	;FLSINS IS WAITING FOR A PAGE (NOT REALLY BLOCKED)
	CAML T,LUBTM(J)
	SOJA I,SWPTK	;BLOCKED FOR A LONG TIME (CLASS 0)
	SKIPN FLSINS(J)
SWPON5:	SKIPE USTP(J)
	JRST SWPTK	;CLASS 1 (BLOCKED)
	JUMPL B,[AOJA I,SWPTK]	;DESIRED OUT (CLASS 2)
	MOVEI I,4
	SKIPGE APRC(J)
	SOJA I,SWPTK	;DISOWNED (CLASS 3)
	SKIPGE USWSCD(J)
	JRST SWPTK	;SWAP BLOCKED (CLASS 4)
	SKIPGE TTYTBL(J)
	AOJA I,SWPTK	;DOESNT HAVE TTY (CLASS 5)
	MOVEI I,6	;OTHERWISE....

SWPTK:	CAMGE C,I
	JRST SWPON3	;THIS GUY IN MORE WINNING CLASS
	CAME C,I
	JRST SWPTK2
	XCT SWPTT(C)
	JRST SWPON3
SWPTK2:	MOVE E,@SWPTT(I)	;MAKE THIS GUY BEST VICTIM
	MOVE C,I
	MOVE U,J
SWPON3:	ADDI J,LUBLK
	JRST SWPON4

SWPONX:	JUMPL U,CPOPJ	;NO SWAP OUTTABLE LOSER
	SKIPGE USWSCD(U)
	POPJ P,	;HE'C ALREADY SWAPPED BLOCKED
	MOVE B,USWST(U)	;IS HE RUNNABLE?
	TLNN B,200000
	SKIPN FLSINS(U)
	SKIPE USTP(U)
	POPJ P,
	MOVE B,NMPGS(U)	;HE'S RUNNABLE
	CAIGE B,SYSUSM-SYSB-30
	JRST SWPNX1	;SMALL, NO THRASH
	SUB B,NSWPGS(U)
	ADD B,MEMFR
	SUB B,NCBCOM
	ADD B,SOLNG
	SUB B,SILNG
	SUB B,AUSOPG
	JUMPG B,CPOPJ	;LET THIS GUY THRASH
SWPNX1:	MOVSI B,(SETZ)	;SWAP BLOCK THIS LOSER
	IORM B,USWSCD(U)
	AOS NUSWB
	MOVE B,NMPGS(U)	;SMALLEST SWAP BLOCKED LOSER?
	CAML B,BUSIZ
	POPJ P,
	MOVEM U,BUSR	;YES
	MOVEM B,BUSIZ
	POPJ P,

;SKIP IF THIS GUY (J) IS BETTER LOSER TO FLUSH THAT PREV BEST (IN E)
SWPTT:	CAMG E,LUBTM(J)	;BLOCKED FOR A LONG TIME (0)
	CAMG E,LUBTM(J)	;BLOCKED (1)
	CAML E,NMPGS(J)	;DESIRED OUT (2)
	CAML E,NMPGS(J)	;DISOWNED (3)
	CAML E,NMPGS(J)	;RUNNABLE, SWAP BLOCK SET (4)
	CAML E,USWPRI(J)	;RUNNABLE, W/O TTY (5)
	CAML E,USWPRI(J)	;OTHERWISE (6)
NSSCDC==.-SWPTT

;AC: A.9 =>1  SWAP OUT USER
;4.8 => 1 ALL PAGES
;4.7=1 => LOOP FOR A WHILE
;3.6-3.1 USER # SELF IF 0
;RH => USER VIRTUAL PG # 
;OR 4.9=0, 4.8=0, 4.7=0 SWAP OUT RH # OF PAGES
;IF 4.9=0, 4.8=1 AND 4.7=0, HACK PCLSR TEST FEATURE ON CURRENT USER
;RH =0 LEAVE PCLSR TEST MODE =1 ENTER IN ADVANCE MODE =-1 ENTER IN HOLD MODE
;   =2 ENTER IN ADVANCE BUT DON'T ^Z

ASWAP:	SKIPN SYSDBG
	JRST ILUUO
	XCTR XR,[MOVE A,(J)]
	TLNE A,100000
	JRST ASWAP3
	JUMPL A,ASWAP1
	TLNE A,200000
	JRST ASWPCL	;PC LSR TEST MODE.
	HRRZM A,SWPOPR	;CLOBBER CLOBBER
	POPJ P,

ASWAP1:	HLRZ B,A
	ANDI B,77
	IMULI B,LUBLK
	SKIPE B
	MOVE U,B
	TLNN A,200000
	JRST ASWAP2
	MOVE D,NMPGS(U)
	SUB D,NSWPGS(U)
	JUMPL D,[JRST 4,.]
	JUMPE D,CPOPJ
	CONO PI,CLKOFF
	MOVEM U,PSWOUS
	SETOM PSWSFL
	ADDM D,SWPOPR
	MOVSI D,(SETZ)
	IORM D,USWST(U)
	CONO PI,CLKON
	POPJ P,

ASWAP2:	HRL A,U
	PUSHJ P,CWAIT
	SKIPL SWOUPG
	MOVEM A,SWOUPG
	JRST CLKONJ

ASWAP3:	MOVE B,[1250000.]
	SOJG B,.
	XCTR XR,[MOVE A,2000]
	JRST .-3

ASWPCL:	MOVEM U,PCLUSR
	CLEARM PCLL
	CLEARM PCLHSH
	SETOM PCLNXT
	HRRES A
	MOVEM A,PCLDBM
	POPJ P,

SWOMNP:	800.	;MAXIMUM NUMBER OF SWAPPED OUT PAGES (0 FOR NO SWAPPING)
SWMDSK:	NQS-1	;UNIT WHICH HAS SWAP OUT AREAS ALLOCATED

EBLK

;SWAP IN RQ BLOCKS
SWIRQB:
IFN 340P,	DISSWI:	-1	;USER
IFN VIDP,	VIDSWI:	-1
IFN IMXP,	POTSWI:	-1
IFN NSWPV-.+SWIRQB, PRINTX /NSWPV ERR/

SWIVPN:
IFN 340P,	DISSPG:	0	;VIRTUAL PAGE NUMBER
IFN VIDP,	VIDSPG:	0
IFN IMXP,	POTSPG:	0

SWPNTB:		;SIGNAL BITS IN LH OF W TO CFHSW1
IFN 340P,	400000	;DISPLAY
IFN VIDP,	400000	;VID
IFN IMXP,	400000	;POTS

SWILMT:		;PIRQC BIT TO SET ON ILM
IFN 340P,	BDISP
IFN VIDP,	BIOADC
IFN IMXP,	BIOADC

NPGSWO:	0	;NUMBER OF CURRENTLY SWAPPED OUT PAGES
PSWOUS:	-1	;INDEX OF PARTIALLY SWAPPED OUT USER
PSWCLS:	0	;CLASS OF PARTIALLY SWAPPED OUT USER
PSWSFL:	0	;-1 START FROM BEG OF USER, ELSE PICK UP WHERE LEFT OFF
SWPMBP:	0	;PNTR TO MAP
SWPCBP:	0	;PNTR TO CIRC DESC SPACE
PSWLC:	0	;LOOP COUNT
SWPP0F:	-1	;-1 IF CONSIDERING PAGE 0
SWPOPR:	0	;NUMBER OF PAGES DESIRED TO BE SWAPPED OUT
SWPOPB:	0	;SWAP OUT REQUEST BUT ONLY SWAP OUT NON-RUNNING USERS TO MEET
SILNG:	0	;LENGTH OF SWAP IN LIST
SOLNG:	0	;LENGTH OF SWAP OUT LIST
SILEND:	SINLST	;POINTER TO LAST ON SINLST
SOLEND:	SOUTLS	;POINTER TO LAST ON SOUTLS
SINLST:	0	;SWAP IN LIST (TO MMSWP OF ASSOC BLOCKS)
SOUTLS:	0	;SWAP OUT LIST
SWODSK:	NQS-1	;UNIT TO SWAP OUT ON
SWOTRK:	NUDSL	;SWAP OUT TRACK
SWOBK:	0	;MEMBLT BEING SWAPPED OUT
SWOMMP:	0	;MMP INDEX
SPGNMF:	0	;-1 => PAGE NOT MODIFIED
SWOUPG:	-1	;REQUEST TO SWAP OUT PAGE RH OR USER LH
CFHAS:	0	;TEMP FOR A AT CFH
SWPIQS:	0	;SAVE Q AT SWPPIN,ETC
CFHUVP:	0	;USER'S VIRTUAL PAGE NUMBER TOOK FAULT ON
LUMPS:	0	;UMAPS USED FOR CURRENT USER, MAY DIFFER FROM
		;UMAPS(U) IF TOOK FAULT TRYING TO CAUSE INTERRUPT
TRUMM:	0	;TOTAL USER MEM ACTIVE USERS
AUSOPG:	0	;ACTIVE USER SWAPPED OUT PAGES
BUMPGS:	0	;REAL CORE PAGES OCC BY BLOCKED + STOPPED LOSERS
NUSWB:	0	;# LOSERS SWAP BLOCKED
BUSR:	0	;INDEX OF SMALLEST SWAP BLOCKED LOSER
BUSIZ:	0	;SIZE OF ABOVE LOSER
ASBUM:	0	;REAL MEM OCC BY ACTIVE "SWAPPED BLOCKED" LOSERS
SWSCT1:	0	;TEM AT SWSCD
SWPOPU:	0	;USER PG "BELONGS" TO (IE NOT NECC TO PCLSR THIS GUY,
			;BUT PCLSR ANYONE ELSE LINKED TO PG.

BBLK


SWPOPG:	MOVEM C,SWPOPU
	MOVEM A,SWOBK	;SWAP OUT PAGE WHOSE MEMBLT INDEX IS IN A
	CAIGE A,TSYSM
	CAIGE A,SYSB
	JRST 4,.	;DON'T SWAP OUT PART OF SYSTEM
	AOSE CIRPSW	;SKIP IF SUCCESSFUL
	POPJ P,
	HRRZ C,MEMBLT(A)
	HRRZM C,SWOMMP	;STORE ADDRESS OF FIRST WORD OF MMP ENTRY
	SETOM CIRPSW	;RELEASE SWITCH
	HLRZ B,1(C)
	JUMPN B,SWOP1	;JUMP IF DISK SPACE ALREADY ASSIGNED
SWODF3:	MOVE I,SWODSK
	CONO PI,UTCOFF
	SKIPGE TT,QTUTO(I)
	JRST UTCONJ	;TUT LOCKED
	MOVE E,SWOTRK
	MOVEI W,QSFT(I)	;TRACK IS IN NON SWAPPING AREA
	CAMGE E,QSWAPA(TT)
	MOVEI W,QSFTS(I)	;TRACK IS IN SWAPPING AREA
	SKIPL QACT(I)
	SKIPG (W)
	JRST SWODF	;DISK FULL IN DESIRED AREA
	MOVSI A,(SETZ)
	IORM A,QTUTO(I)
	CONO PI,UTCON
	MOVEI A,SWOTRK-QMFTP	;EXPECTS CHNL #
	PUSHJ P,QGTK4	;RETURN TRACK IN D
	SOS (W)	;DECREMENT SPACE IN AREA OF TRACK
	MOVSI A,(SETZ)
	ANDCAM A,QTUTO(I)
	MOVE A,SWOMMP
	DPB I,[DADDNR+D]	;GET DISK NUMBER AND TRACK NUMBER TOGETHER
	HRLM D,1(A)	;STORE IN MMP ENTRY
SWOP1:	AOSE CIRPSW
	POPJ P,
	AOS NPGSO
	CONO PI,UTCOFF
	MOVE A,SWOBK
	HLRZ C,MMSWP(A)	;NUMBER OF EXEC PAGES POINTING TO THIS PAGE
	JUMPN C,SWOP5	;POINTED TO BY EXEC PAGE
IFN 340P,[
	MOVSI C,-N340PB-2
SWOPT2:	LDB I,DPEP(C)
	TRZN I,600000
	JRST SWOPT1
	ANDI I,777
	CAIN I,(A)
	BUG .,DISPLAY STILL SET UP TO PAGE BEING SWAPPED OUT
SWOPT1:	AOBJN C,SWOPT2
]
	MOVSI C,(SETZ)
	IORM C,MEMBLT(A)	;PREVENT NEW EXEC PAGES FROM BEING SET UP POINTING HERE
	CONO PI,UTCON
	MOVE C,[2200,,MEMPNT]
	ADD C,SWOBK
	LDB I,C
	PUSH P,I	;NOTE: CAN BACK OUT OF THIS PUSH AT SWOP2B
	SETOM SPGNMF	;INITIALIZE PAGE NOT MODIFIED
	PUSHJ P,UCPRL
	400000,,SWOP2	;RETURN ON USERS (CAN BACK OUT AT SWOP2B)
	POP P,I
	DPB I,C		;DELINK MEMPNT
	MOVEI I,3
	DPB I,[410200,,@SWOMMP]	;INDICATE ON THE WAY OUT
	CONO PI,UTCOFF
	MOVE A,SWOBK
	MOVSI B,(SETZ)
	ANDCAM B,MEMBLT(A)
	MOVE C,@SWOMMP
	SKIPGE SPGNMF	;SKIP IF PAGE MODIFIED
	TLNN C,40000
	JRST SWOP3	;HASN'T BEEN WRITTEN
	MOVEI I,2	;INDICATE OUT
	DPB I,[410200,,@SWOMMP]	;NOT NECESSARY TO WRITE
	AOS NPGSWO	;PAGE NOW CONSIDERED SWAPPED OUT
	PUSHJ P,IMEMR	;FLUSH
	JRST SWOP4

SWOP5:	SETOM CIRPSW
	JRST UTCONJ

SWOP3:	CAIGE A,TSYSM
	CAIGE A,SYSB
	JRST 4,.
	HRRZ B,SWOMMP
	MOVSM B,MMSWP(A)	;NEW END OF SWAP OUT LIST
	MOVEI C,MMSWP(A)
	MOVE I,SOLEND
	MOVEM C,SOLEND
	HRRM C,(I)
	AOS SOLNG
	AOS NPGSWO
	HLRZ C,1(B)
	HRLM C,MEMPNT(A)	;STORE DISK ADDRESS
	LSH C,-15.
	CAIL C,NQS
	JRST 4,.	;DISK NUMBER NOT LEGITIMATE
	MOVEI B,MU23B
	DPB B,[MUR,,MEMBLT(A)]
	MOVEI B,NQCHN+1
	DPB B,[M2311C,,MEMBLT(A)]
	PUSHJ P,QSTRTR
SWOP4:	SETOM CIRPSW
	JRST UTCOJ1

SWOP2:	CAIG U,LUBLK
	JRST 4,.	;SYS JOB OR CORE JOB?
	PUSH P,I
	CAMN U,SWPOPU
	JRST SWOP2A
	MOVE T,UPC(U)
	TLNE T,LSRMOD
	JRST SWOP2A
	SKIPN FLSINS(U)
	JRST SWOP2D
	MOVSI T,20000	;DONT PCLSR NOW, BUT WHEN UNBLOCKS
	IORM T,USWST(U)
	JRST SWOP2A

SWOP2D:	PUSHJ P,PCLSR
	JRST SWOP2B
SWOP2A:	MOVE C,UDBR1(U)
	TRZE I,200
	MOVE C,UDBR2(U)
	ROT I,-1
	ADDI C,(I)
	HRLI C,222200
	SKIPGE I
	HRLI C,2200
	LDB I,C
	JUMPE I,[JRST 4,.]	;NO ACCESS?
	TRNN I,600000
	JRST SWOP2C	;NOT SET UP SINCE PREV SWAPPED OUT
	LSH I,-16.
	CAILE I,2	;SKIP ON READ ONLY OR READ/WRITE/FIRST
	CLEARM SPGNMF	;PAGE HAS BEEN MODIFIED
	CAIN I,2	;FLUSH R.W.F.
	MOVEI I,3
	DPB I,C		;STORE PROTECTION BITS BACK IN LOWER TWO BITS OF ENTRY
	AOS NSWPGS(U)	;INCR COUNT OF SWAPPED OUT PGS OF USER
SWOP2C:	POP P,I
	POPJ P,

SWODF:	CONO PI,UTCON
	MOVNI D,1
	MOVE I,SWMDSK
	SKIPGE QACT(I)
	JRST SWODF5
	SKIPE QSFTS(I)
	JRST SWODF1
SWODF5:	MOVNI I,1
	MOVSI E,-NQS
SWODF2:	SKIPGE QACT(E)
	JRST SWODF4
	CAMGE D,QSFT(E)
	HRRZ I,E
	CAMGE D,QSFT(E)
	MOVE D,QSFT(E)
SWODF4:	AOBJN E,SWODF2
	JUMPL I,[JRST 4,.]	;NO DISKS ALIVE
SWODF1:	HRRZM I,SWODSK
	JUMPLE D,CPOPJ	;NO ROOM ANYWHERE
	MOVEI E,NBLKS/2	;IN NON-SWAPPING AREA
	SKIPE QSFTS(I)
	MOVEI E,NUDSL	;IN SWAPPING AREA
	MOVEM E,SWOTRK
	JRST SWODF3

SWOP2B:	SUB P,[6,,6]	;2 PUSHES OF I AND 4 FOR UCPRL
	MOVE A,SWOBK
	MOVSI I,(SETZ)
	ANDCAM I,MEMBLT(A)
	SETOM CIRPSW
	POPJ P,


IFN NSWPV,[
SWPPIN:	MOVSI Q,-NSWPV
SWPPI4:	SKIPGE W,SWIRQB(Q)	;USER INDEX
	JRST SWPPI6
	MOVE E,SWIVPN(Q)	;VIRTUAL PAGE NUMBER
	HRL W,SWPNTB(Q)
	CLEARB TT,D
	MOVEM Q,SWPIQS
	PUSHJ P,CFHSW1
	MOVE Q,SWPIQS
	SETOM SWIRQB(Q)
SWPPI6:	AOBJN Q,SWPPI4
	POPJ P,
]

SWIILM:	MOVE Q,SWPIQS
	JUMPE Q,[JRST 4,.]	;ON SWAP IN USER OPERATION
	MOVE E,SWILMT(Q)
	JUMPL E,[JRST 4,.]
	IORM E,PIRQC(W)
	MOVEI A,0
	POPJ P,

SWIUSR:	MOVE W,U	;SWAP IN ALL PGS USER IN U SKIP IF ENUF ROOM ,ETC
	SETZM SWPIQS	;FLAG FOR SWILM, ETC
	MOVE B,HUSRAD(W)
	MOVE C,UDBR1(W)
	MOVE D,UCPB1(W)
	MOVEI E,0	;PAGE #
SWIUS1:	LSH B,-10.
	LDB T,[230700,,C]	;GET DBL
	LSH T,1
	CAIGE T,(B)
	HRRZ B,T
	TRNN B,-1
	JRST SWIUS2
	HRLI C,442200
	HRLI D,442200
SWIUS3:	ILDB A,C
	ILDB J,D
	TRNE A,600000
	JRST SWIUS4	;SOME ACCESS, THEREFORE NOT SWAPPED OUT
	JUMPE J,SWIUS4
	CAIN J,-1
	JRST SWIUS4
	PUSH P,E
	PUSH P,C
	PUSH P,D
	PUSH P,B
	HRLI W,(SETZ)
	CLEARB TT,D
	PUSHJ P,CFHSW1
	POP P,B
	POP P,D
	POP P,C
	POP P,E
	JUMPE A,CPOPJ	;FAILED
SWIUS4:	AOS E
	SOJG B,SWIUS3
SWIUS2:	CAILE E,200
	JRST POPJ1	;ALREADY IN HI HALF, THRU
	MOVE B,HUSRAD(W)
	SUBI B,400000
	JUMPLE B,POPJ1
	MOVEI E,200
	MOVE C,UDBR2(W)
	MOVE D,UCPB2(W)
	JRST SWIUS1

.ALSKF==0
DEFINE ALTSKP A
IFE .ALSKF,[
	DEFINE .ALSKS
A TERMIN
]
IFN .ALSKF,[
	CAME U,.ALSKS
	CAMN U,A
	POPJ P,
]
.ALSKF==.ALSKF#1
TERMIN

;DETERMINES USER PRIVILEGE LEVEL FOR SCHEDULING AND SWAPPING
UPRIVL:	SKIPN RPCL(U)	;BEING RPCLAR'ED?
	CAMN U,UMASTER	;MASTER?
	POPJ P,		;HIGHLY PRIVILEGED
	AOS (P)		;SKIP AT LEAST ONCE
IFN 340P,	ALTSKP DISUSR
IFN VIDP,	ALTSKP NVDUSR
IFN TABP,	ALTSKP TABUSR
IFN ARMP,	ALTSKP ARMUSR
IFN LPTP,	ALTSKP LPTUSR
IFG LPTP-1,	ALTSKP OLPUSR
IFN PLTP,	ALTSKP PLTUSR
IFN .ALSKF,[
	CAMN U,.ALSKS
	POPJ P,
]
	MOVE T,UPC(U)
	TLNE T,LSRMOD
	AOS (P)		;SKIP TWICE
	POPJ P,

;ROUTINE TO HANDLE FIRST WORD (PIRQC) INTS
SEAR2A:	MOVE T,[BADBTS]	;INTERRUPT USER IF REQUESTED
	SKIPE PICLR(U)	;SKIP IF PICLR DISABELING ALL INTS
	IOR T,MSKST(U)	;OR IN ENABLE MASK
	MOVE Q,IDF1(U)	;DEFERRED INTS.
	ANDCM Q,[BADBTS]	;DEFERRED CLASS 3 INTS.
	ANDCM A,Q	;IGNORE THEM.
	AND T,A		;AND WITH PENDING INTS
	JUMPE T,SEARL2	;NOT ENABLED & NOT BAD
	JSP T,SBPGI	;ASSURE JOB NOT ALREADY WAITING FOR PAGE ZERO
	PUSHJ P,PCLSR
	JRST SEARC	;CAN'T INTERRUPT NOW
	MOVE Q,IDF1(U)
	ORCM Q,MSKST(U)	;DEFERRED OR DISABLED INT BITS.
	AND A,Q
	AND A,[BADBTS]	;LOOK AT CLASS 2 & 3 INTERUPTS
	SKIPE PICLR(U)	;SKIP IF INTERRUPTS DISABLED
	JUMPE A,SBRK69	;INTERRUPT USER IF NO CLASS 3 OR MASKED OFF CLASS 2 INTS
;INTERRUPT SUPERIOR
INTSUP:	MOVSI T,BUSRC
	IORM T,USTP(U)	;STOP INFERIOR
	MOVE Q,U	;SAVE USER INTERRUPTING
	SKIPGE U,SUPPRO(U)	;SKIP UNLESS TOP LEVEL
	JRST INTTOP	;REALLY TOP LEVEL
	HLLZ T,U	;GET INT BIT
	IORM T,IFPIR(U)	;TURN ON INTERRUPT BIT IN SUPERIOR
	HRRZS U		;CLEAR LEFT HALF OF U
	CAIL J,(U)	;SKIP IF SUPERIOR HAS NOT YET BEEN SCHEDULED
	JRST SEARL1	;RESCHEDULE SUPERIOR
	JRST SEARL	;HAVEN'T GOT TO HIM YET SO CONTINUE

INTTOP:	SKIPGE APRC(Q)	;SKIP IF NOT DISOWNED JOB
	JRST SEARL	;DISOWNED, LEAVE STOPPED
	MOVE T,OPTION(Q)
	TLNE T,OPTDET	;MAYBE IT WANTS TO BE DETACHED
	JRST INTTO1
	MOVE U,Q	;RELOAD
	PUSHJ P,USRST2	;RESET USER VARS
	MOVEI T,USTCDR
	MOVEM T,UPC(U)
	MOVSI T,BUSRC
	ANDCAM T,USTP(U)	;START UP
	SETZM @UTMPTR(U)	;GIVE TEMPORARY HIGH PRIORITY
	JRST SEARC	;RESCHEDULE THIS JOB

INTTO1:	MOVEI T,20000
	IORM T,SUPCOR	;SAY SOMEONE WNATS TO BE DETACHED
	JRST SEARL	;LEAVE STOPPED, SYS JOB WILL DETACH SOMEDAY.

;SEARCH END (EXIT)
SEAREN:	SKIPE NUSWB
	JRST SSWC1	;SEE IF ENUF CORE TO UNBLOCK A SWAPPED BLOCKED LOSER
SSWC2:	SKIPGE U,I	;SKIP IF NON-NULL JOB BEST
	JRST SCHED1
SCHED6:	SKIPE FLSINS(U)
	JRST SCHED5
SCHED1:	EXCH U,USER
	JUMPL U,SCHDN	;JUMP IF SWITCHING FROM NULL JOB
	CAMN U,USER	;SKIP UNLESS RUNNING SAME JOB AGAIN
	JRST SEAREP	;JUMP ON SAME JOB
	MOVE T,40
	MOVEM T,SV40(U)	;SAVE LAST UUO EXECUTED FOR THIS USER
	MOVE T,60
	MOVEM T,SV60(U)
	MOVE T,60H
	MOVEM T,S60H(U)
SCHDN:	SKIPGE U,USER
	JRST SCHDN2	;JUMP IF SWITCHING TO NULL JOB
	MOVE T,SV40(U)	;LOAD NEW KRUFT
	MOVEM T,40
	MOVE T,SV60(U)
	MOVEM T,60
	MOVE T,S60H(U)
	MOVEM T,60H
SEAREP:	HRLOI T,1
	ANDCAM T,UPGML+3(U)	;RESET QUANTUM TIMER
	PUSHJ P,PGLDU
	MOVE T,UPC(U)	;USER'S PC WORD
	MOVEM T,CLKBRK
	MOVSI T,UUO(U)
	HRRI T,UEXIT
	BLT T,UUOH	;BLT IN UEXIT BLOCK
	MOVNI T,7
	MOVEM T,SCHFLG	;DONT SCHED FOR 1/7.5 SEC
CLKB5:	MOVE U,USER
	MOVSI U,AC0S(U)
	BLT U,U
	JRST 12,@CLKBRK

SCHED5:	MOVSI T,20000
	TDNE T,USWST(U)
	JRST SCHED7	;PAGES HAVE BEEN SWAPPED OUT WHILE BLOCKED
	MOVSI T,250000	;NOT WAITING FOR PAGE,NOT UNBLOCKED SWAPOUT,
	ANDCAM T,USWST(U)	;NOT WAITING FOR INTERRUPT PAGE
	SETZM FLSINS(U)
	JRST SCHED1

SCHED7:	PUSHJ P,PCLSR	;PAGES WERE SWAPPED OUT WHILE BLOCKED IN EXEC MODE
	JFCL	;COULD NOT SKIP IF GUY HAS UFINAL SET
	JRST SCHED1

; SWITCHING TO NULL JOB
SCHDN2:	DATAO PI,[0]	;LOAD  MI WITH JOB RUNNING
	MOVSI T,(JFCL)
	MOVEM T,CLUSAV	;AVOID LOSSAGE AT CLKBRK+1 NEXT CLOCK INT
	HRLOI T,1
	ANDCAM T,UPGML+3
	CLEARM SCHFLG	;RESCHEDULE ON NEXT INT
	LPMR UPGML
	JRST 12,@[NULJOB]	;DISMISS INT AND GO TO NULL JOB

NULJOB:	AOS NULTIM	;INCREMENT COUNT OF NULL QUANTA
	MOVSI (JRST 4,)
	MOVEI 17,1
	BLT 17,16	;SET ACS 0 TO 16 TO JRST 4, TO CATCH SPURIOUS TRANSERS TO ACS
	MOVE 17,[AOJA 17]
	JRST 1,17	;START UP IN USER MODE, RUNS IN AC TO FREE MEMORY FOR OTHER PROCESSORS

SSWC1:	SKIPGE U,BUSR
	JRST SSWC2
	MOVN T,NSWPGS(U)
	ADD T,MEMFR
	SUB T,NCBCOM
	ADD T,SOLNG
	SUB T,SILNG
	SUB T,AUSOPG
	ADD T,ASBUM
	ADD T,BUMPGS
	CAIGE T,20
	JRST SSWC2	;NOT ROOM
	MOVSI T,400000
	ANDCAM T,USWSCD(U)	;CLEAR SWAP BLOCKED
	SETOM BUSR
	SETZM BUSIZ
	AOS NTSBUU
	SOSN NUSWB
	JRST SSWSC3
	MOVEI U,0
	MOVNI R,1
	MOVSI T,200000
SSWSC4:	CAML U,USRHI
	JRST SSWSC6
	SKIPGE USWSCD(U)
	SKIPN UNAME(U)
	JRST SSWSC5
	CAMGE T,NMPGS(U)
	JRST SSWSC5
	MOVE R,U
	MOVE T,NMPGS(U)
SSWSC5:	ADDI U,LUBLK
	JRST SSWSC4

SSWSC6:	MOVEM R,BUSR	;STORE NEW SMALLEST SWAPPED BLOCKED LOSER
	SKIPGE R
	MOVEI T,0
	MOVEM T,BUSIZ
SSWSC3:	JUMPL I,SEARL0	;MAYBE CAN RUN THIS GUY NOW
	JRST SSWC2


PGLDU:	MOVE R,UMAPS(U)
PGLD:	MOVEM R,LUMPS	;LAST UMAPS ACTUALLY USED
	PUSH P,A	;R HAS UMAPS CODE
	PUSH P,B
	PUSH P,C
	JUMPE U,PGLDR1	;SYS JOB
	HRRZ C,U
	TLNN R,200000
	JRST PGLD3A	;USE NORMAL LOW SEG
IFN PDP6P,[
	TRNE R,400000
	JRST PGLD3B	;USE PNTR TO PDP6
]
	HRRZ C,R
	TLNE R,20000	;SKIP ON USE HIS LOWER
	JRST PGLD3D	;USE HIS UPPER
PGLD3A:	MOVE B,UDBR1(C)
	TLNE R,4000
	JRST PGLD3G	;MAKE AC'S POINT AT SWAP OUT AC'S
	MOVEI A,UUOACS(C)
PGLD3F:	DPB A,[2300,,UPGML+7(U)]	;STORE AC PNTR
	MOVEM B,UPGML+4(U)
	MOVE B,UDBR2(U)
	TLNN R,100000
	JRST PGLD6	;USE NORMAL UPPER SEG
IFN PDP6P,[
	MOVE B,PDP6MP
	TRNE R,400000
	JRST PGLD6	;USE PNTR TO PDP6
]
	MOVE B,UDBR2(R)
	TLNN R,20000
	MOVE B,UDBR1(R)	;PNTR TO HIS LOWER
PGLD6:	TLNE R,10000
	MOVE B,UDBR2(R)
	MOVEM B,UPGML+5(U)
PGLDR1:	LPMR UPGML(U)
	LDB A,[300,,APRC(U)]
	CAIE A,APRCHN
	JRST 4,.
	CONO @APRC(U)
	MOVN A,U
	IDIVI A,LUBLK
	MOVSI B,(SETZ)
	LSH B,(A)
	DATAO PI,B
	POP P,C
	POP P,B
	POP P,A
	POPJ P,

IFN PDP6P,	PGLD3B:	SKIPA B,PDP6MP
PGLD3D:	MOVE B,UDBR2(R)
	MOVEI A,GACS
	JRST PGLD3F

PGLD3G:	MOVEI A,AC0S(C)
	JRST PGLD3F

GACS:	BLOCK 20	;GARBAGE AC'S POINTED TO BY ACPNTR WHEN ITS REALLY POINTING
		;AT UPPER PAGES OR PDP6  SHOULD HOPEFULLY NEVER GET REFERENCED

;ROUTINE TO HANDLE SECOND WORD (IFPIR) INTS
SEAR2B:	SKIPN PICLR(U)
	JRST SEARL3	;INTERRUPTS INHIBITED
	ANDCM T,IDF2(U)	;IGNORE DEFERRED CLASS 3 INTS.
	AND T,MSKST2(U)
	JUMPE T,SEARL3	;INTERRUPTS MASKED OFF
	JSP T,SBPGI	;ASSURE JOB NOT ALREADY WAITING FOR PAGE ZERO
	PUSHJ P,PCLSR
	JRST SEARC	;CAN'T INTERRUPT NOW
	MOVEI T,0
	EXCH T,IFPIR(U)	;PICK UP IFPIR & ZERO IT
	MOVE Q,T
	AND Q,IDF2(U)
	IORM Q,IFPIR(U)	;DON'T FLUSH DEFERRED INTS SINCE NOT GIVING THEM.
	ANDCM T,IDF2(U)
	TLO T,400000	;SET BIT INDICATING 2ND WORD INTERRUPT
	JRST SEAR2C

SBPGI:	MOVSI E,200000
	SKIPE FLSINS(U)
	TDNN E,USWST(U)
	JRST (T)	;JOB NOT WAITING FOR PAGE
	MOVSI E,10000
	TDNN E,USWST(U)
	JRST (T)	;NOT WAITING FOR INTERRUPT PAGE
	MOVE E,T
	MOVE T,EPDL2(U)
	XCT FLSINS(U)
	JRST SEARL	;PAGE NOT IN
	JRST (E)	;PAGE IN
	JRST 4,.
	JRST 4,.

SBRK69:	MOVEI T,0	;INTERRUPT LOSER
	EXCH T,PIRQC(U)	;PICK UP PIRQC & ZERO IT(MUST BE ONE INST TO AVOID TIMING ERR)
	MOVE Q,IDF1(U)
	AND Q,T		;TURN DEFERRED INTS BACK ON.
	IORM Q,PIRQC(U)
	ANDCM T,Q	;DON'T GIVE THEM THIS TIME.
SEAR2C:	SKIPGE UTRAPM(U)	;IF SPECIAL TRAP MODE
	JRST SERR2	;INT SUP INSTEAD
	AOS NAUINT	;# ATTEMPTED USER INT
	MOVEI R,0	;LOAD STRAIGHT MAP FOR USER
	PUSHJ P,PGLD
	HRRZ A,40ADDR(U)
	XCTR XRW,[HRRZ A,2(A)]
	SKIPA Q,UPC(U)	;PICK UP UPC
	JRST SERR	;GOT TRAP TRYING TO REF 42
	JUMPE A,SERR2	;42 HOLDS 0 => BADPI INT.
	SKIPGE IOTLSR(U)
	TLO A,IOTFLG	;IF CALLED FOR, TURN ON IOTLSR BIT IN PC "
	XCTR XW,[MOVEM T,(A)]	;STORE INTERRUPT RQ
	TLOA A,LSRMOD
	JRST SERR	;BAD LOCN 42
	XCTR XW,[MOVEM Q,1(A)]
	JRST .+2
	JRST SERR
	SETZM PICLR(U)	;SET PI IN PROGRESS
	ADDI A,2
	MOVEM A,UPC(U)	;SET PC TO INTERRUPT ROUTINE
	SPM UPGML(U)
	AOS NUINT
	JRST SEARC	;SCHEDULE

SERRRS:	TLZE T,400000	;UNDO ATTEMPT TO INTERRUPT
	JRST SERR4
	IORM T,PIRQC(U)
	POPJ P,

SERR4:	IORM T,IFPIR(U)
	POPJ P,

SERR:	SPM UPGML(U)	;STORE MAP IN INTERRUPTING STATE
	PUSHJ P,SERRRS
	LDB T,[221000,,UPGML(U)]	;FAULT ADDRESS
	ROT T,-1
	TRZE T,100
	SKIPA A,UCPB2(U)
	MOVE A,UCPB1(U)
	HRLI A,222200
	SKIPGE T
	HRLI A,2200
	LDB E,A
	JUMPE E,INTSUP	;DON'T HAVE PAGE
	HLLZ T,UPGML+3(C)
	TLNE T,100
	JRST SERR2B	;WRITE IN RD ONLY
SERR2C:	HLLZ T,UPC(U)	;SIMULATE SETUP OF OPC
	LSH T,-5
	HRR T,UPC(U)
	MOVEM T,UPGML+1(U)	;FAULT STATUS
	MOVSI T,1000
	IORM T,UPGML+3(U)	;BIT NOT SET BY XCTR ...I,
	MOVSI T,10000
	IORM T,USWST(U)	;PAGE FAULT RESULT OF INTERRUPT ATT
	JRST SCHED6	;"RUN" USER, TAKING PAGE FAULT IMMEDIATELY

SERR2B:	TLNE D,50	;NO ACCESS OR W IN RWF
	JRST SERR2C	;PAGING BOX BUG? IGNORE RD ONLY
	JRST SERR2A

SERR2:	PUSHJ P,SERRRS
SERR2A:	MOVEI A,BPIPI	;TURN ON BAD PI LOC INT BIT
	IORB A,PIRQC(U)	;GIVE USER INTERRUPT(MUST IORM TO AVOID TIMING ERR)
	JRST SEAR2A	;RE-PERFORM ACTIONS FOR NON-ZERO PIRQC
		;WILL CAUSE AN INTERRUPT TO SUPERIOR

SEARP1:	MOVEM T,U0P	;SET UP TREE MACHINE TIME USED RECENTLY
	MOVE T,JTMU(U)	;GET PROCEDURE TIME USED RECENTLY FOR BEST SO FAR
	ASH T,(Q)	;INCREASE PRIORITY IF INDICATED
	MOVEM T,U0PP	;STORE FOR FUTURE COMPARISIONS
	MOVEM U,I	;SET BEST SO FAR TO CURRENT PROCEDURE
	JRST SEARL

SEARP3:	CAMN T,U0P
	JRST SEARP6	;JUMP IF EQUAL TO BEST SO FAR
	MOVE A,JTMU(U)	;NEW USER HAS HIGHER TREE PRIORITY
			;SO MACHINE TIME CAN BE 8X AS GREAT
	ASH A,-3(Q)	;DIVIDE JTMU BY 8+Q
SEARP4:	CAML A,U0PP	;COMPARE TO BEST SO FAR
	JRST SEARL	;CURRENT PROC. LOSES, HAS USED MUCH MORE TIME THAN BEST SO FAR
	JRST SEARP5	; " WINS, HAS NOT USED MUCH MORE

SEARP6:	MOVE A,JTMU(U)	;PICK UP TIME USED RECENTLY
	ASH A,(Q)	;INCREASE PRIORITY AS INDICATED BY Q
	JRST SEARP4

SEARD:	MOVEI T,SEARC	;"JUMPA SEARD" IS FLSINS SET UP BY UDELAY
	HRRM T,FLSINS(U)	;MODIFY FLSINS TO SIMULATE UNBLOCKING
	JRST SEARL


;INTERRUPT ALL USERS THAT WANT IT
;  C(A) IS BIT IN PIRQC TO TURN ON
DBGINT:	MOVSI A,(BDBGI)	;"SYS BEING DEBUGGED" INT
INTALL:	MOVEI U,0	;ENTRY INITIALIZE
INTA2:	ADDI U,LUBLK	;ADVANCE TO NEXT BLOCK OF USER VARIABLES
	CAML U,USRHI	;SKIP UNLESS AT END
	POPJ P,		;THROUGH, RETURN
	SKIPN UNAME(U)	;SKIP IF BLOCK IN USE
	JRST INTA2	;IDLE, IGNORE
	LDB T,[410100,,USTP(U)]	;GET BUCSTP OF USERS STOP WORD
	JUMPN T,INTA2	;IF USER CONTROL STOPPED, JUMP TO IGNORE
	MOVE B,MSKST(U)	;PICK UP INTERRUPT MASK
	AND B,A		;MASK C(B) TO APPROPRIATE BIT
	IORM B,PIRQC(U)	;GIVE INT TO USER
	JRST INTA2	;LOOP
MPLDZ:	TDZA J,J
MP6LD:	MOVE J,[100000,,-1]	;LOAD UPPER DBR TO PNT TO 6
MPLD1:	MOVEM J,UMAPS(U)	;SET UMAPS
MPLD:	CONO PI,CLKOFF
	PUSHJ P,PLD
	JRST CLKONJ

PLDZ:	TDZA J,J
PLD6:	MOVE J,[100000,,-1]
PLD1:	MOVEM J,UMAPS(U)
PLD:	SPM UPGML(U)	;IF ANY INHIBITED FAULT PRESENT, CAUSE IT TO GET STORED AWAY
	PUSH P,R
	PUSHJ P,PGLDU	;CAUSE ACTUAL PG LOAD TO HAPPEN
	POP P,R
	POPJ P,
;
; PUT PC OF USER WHOSE INDEX IS IN U IN USER MODE
;  (CALL ONLY WITH CLOCK OFF OR CLOCK BREAK IN PROGRESS)
;SKIPS IF SUCCESSFUL, FAILS IF USER RUNNING IN EXEC CODE OR HAS TO BE FINALIZED
;
PCLSR:	AOS NPCLSR
	JUMPLE U,[JRST 4,.]	;SHOULD NOT HAPPEN TO SYS OR NULL JOB
	MOVEI T,L
	IDIVM U,T
	IMULI T,L
	CAMN T,U	;IS U REALLY A MULTIPLE OF LUBLK?
	SKIPN UNAME(U)	;SHOULD NOT HAPPEN TO NONEXTANT JOB
	JRST 4,.
	MOVE T,APRC(U)
	TLNE T,BULGO
	JRST 4,.	;NOT SUPPOSED TO PCLSR AFTER HAVING LOGGED OUT THIS FAR
	SKIPE USTP(U)
	JRST POPJ1	;USER STOPPED (MUST ALREADY BE IN USER MODE)
	SKIPLE T,RPCL(U)
	JRST PCLSR2	;LOSER IS RPCLSR'ING SOMEONE
PCLSR3:	MOVE T,SUEXIT(U)
	CAME T,[JRST 2,@UUOH]
	JRST PCLSR5	;EXIT ALREADY CLOBBERED
	MOVE T,UPC(U)	;PICK UP PROGRAM COUNTER (FLAGS IN L.H.)
	TLNN T,LSRMOD	;SKIP IF USER MODE ON
	JRST PCLSR8	;JOB CURRENTLY IN EXEC MODE
	CLEARM FLSINS(U)	;IN CASE HE WAS WAITING FOR A PAGE OR CIRPSW
	MOVSI T,250000
	ANDCAM T,USWST(U)
	AOS (P)
	POPJ P,

PCLSR8:	SKIPE FLSINS(U)	;SKIP IF UNBLOCKED
	JRST PCLSR1	;HUNG, TRY TO BACK UP TO UUO
PCLSR4:	MOVE T,[JRST ONEFLS]
	MOVEM T,SUEXIT(U)	;MUNG EXIT OF UUO, COME BACK LATER
	POPJ P,

PCLSR2:	SETZM RPCL(U)	;CLEAR OUT POINTERS IN BOTH DIRECTIONS
	SETZM RPCL(T)
	JRST PCLSR3

PCLSR5:	SKIPN FLSINS(U)
	POPJ P,		;NOT HUNG, LET RUN TO COMPLETION
	CAME T,[JRST ONEPROC]	;SKIP IF ONE PROCEEDING A SYS CALL
	JRST PCLSR6
	MOVSI T,BPCROC
	IORM T,SUUOH(U)	;RESET SINGLE INSTRUCTION PROCEED
PCLSR6:	MOVE T,UPC(U)
	TLNE T,LSRMOD
	JRST 4,.
	MOVE T,[JRST 2,@UUOH]
	MOVEM T,SUEXIT(U)	;UNCLOBBER EXIT
PCLSR1:	MOVE T,UPC(U)
	MOVEM T,LSPCL(U)	;SAVE FOR DEBUGGING
	SOS T,SUUOH(U)	;GET USER LOCATION OF HIS CURRENT UUO
UFL5:	MOVEM T,UPC(U)	;SET USERS PROGRAM COUNTER
	CLEARM UMAPS(U)	;RESTORE TO NORMAL MAP
	SETZM FLSINS(U)	;CLEAR OUT ANY BLOCKING CONDITION
	MOVSI T,270000	;NOT BLOCKED ON PAGE, NOT UNBLOCKED SWAPOUT, NOT INTERRUPT PAGE
	ANDCAM T,USWST(U)	;CLEAR FLAG PGS SWAPPED OUT WHILE BLOCKED
	SKIPE T,LSWPR(U)
	JRST LSWZAP	;REQUIRED TO UNLOCK SWITCHES
PCLSR7:	MOVEI T,AC0S(U)
	HRLI T,UUOACS(U)
	BLT T,AC17S(U)
	JRST POPJ1	;EXIT AFTER BACKING UP TO UUO
;
; AOS USTP OF USER IN A
;
NJRPCL:	CAIE A,-1	;ENTRY TO IGNORE IF NULL JOB
RPCLSR:	CAMN A,USER	;NORMAL ENTRY
	POPJ P,		;TRYING TO RPCLSR SELF OR NULL JOB
	PCLT
	PUSH P,U	;SAVE U
	MOVE U,A	;GET INDEX OF RPCLSRED JOB IN U
	MOVE A,USER	;GET RPCLSRING USER INDEX IN A
	CONO PI,CLKOFF	;TURN OFF CLOCK BREAKS
	PUSHJ P,PCLSR	;PUT USER IN USER MODE
	JRST RPCLOS	;JUMP IF CAN'T DO IT RIGHT NOW
	AOS USTP(U)	;WIN,STOP USER
	CONO PI,CLKON	;RE-ENABLE CLOCK BREAKS
RPCLS1:	MOVE A,U	;RESTORE A
	POP P,U		;RESTORE U
	POPJ P,
;
RPCLOS:	SKIPE RPCL(U)	;SKIP IF ZERO RPCL FOR USER BEING RPCLSRED
	JRST RPCLS2	;SOMEONE GOT THERE FIRST
	SKIPE RPCL(A)	;SKIP IF ZERO RPCL FOR RPCSRING USER
	JRST UDELAY	;YOU ARE BEING RPCLSR'ED, SURRENDER
	HRROM A,RPCL(U)	;SET UP RPCL IN VARS OF RPCLSRED USER
	HRRM U,RPCL(A)	;" OF RPCLSRING USER
	PCLT
	SKIPE RPCL(A)	;WILL NOT SKIP AT FIRST
	PUSHJ P,UFLS	;WAIT FOR PERSON BEING RPCLSRED TO GET TO ONEFL2
	JRST RPCLS1
;
RPCLS2:	MOVE A,U	;RESTORE A AND U
	POP P,U
	PCLT
	SKIPE RPCL(A)	;WAIT FOR OTHER GUY TO WIN
	PUSHJ P,UFLS
	JRST RPCLSR	;THEN TRY AGAIN

;
; UNDO AN RPCLSR
;
NJUPCL:	CAIE A,-1	;ENTRY TO IGNORE IF NULL JOB
UPCLSR:	CAMN A,USER	;REGULAR ENTRY
	POPJ P,		;TRYING TO UPCLSR SELF OR NULL JOB
	SOS USTP(A)
	POPJ P,

;
; RETURN FROM SYSTEM CALL IN ONE PROCEED MODE
;
ONEPROC:	CONO PI,CLKOFF	;TURN OFF CLOCK BREAKS
	MOVE U,USER	;BE SURE U HAS RUNNING USER INDEX IN IT
	MOVEI T,BPROC
	IORM T,PIRQC(U)	;GIVE USER INTERRUPT
	JRST ONEPR2
;
; USER START ROUTINES
; CALLED EVERY SLOW CLOCK TICK WHEN TTY WANTING TOP PROCEDURE LOADED
;
USTART:	PUSH P,U
USTRT1:	SKIPGE T,@UTTYO	;GET TTY TO BE STARTED
	MOVSI T,600000	;NOT A REAL TTY, INITIALIZE TTYTBL
	PUSHJ P,USTRA	;CREATE NEW USER SLOT ENTRY
	JRST USTSC1	;LOSE, HAVE TO WAIT
	SKIPGE T,@UTTYO	;SKIP IF REALLY A TTY
	JRST USTRTS	;DONT LOAD A HACTRN
	MOVE T,[SIXBIT /HACTRN/]	;LOAD HACKTRN
USTRT2:	MOVEM T,JNAME(U)	;SET JOB NAME
	HRLZI T,LSRMOD
	HRRI T,1
	MOVEM T,UPC(U)
	MOVEI T,AC0S(U)
	HRLI T,NUSTCD
	BLT T,AC17S(U)
	MOVE T,JNAME(U)
	MOVEM T,AC0S+11(U)
	SETZM @UTMPTR(U)	;GIVE TEMPORARY HIGH PRIORITY
	SETZM USTP(U)	;START UP
	AOS T,UTTYO	;AOS RING BUFF
	CAIL T,UTTYS+MXCZS
	MOVEI T,UTTYS
	MOVEM T,UTTYO
	SOSE UTTYCT
	JRST USTRT1	;MORE JOBS TO SET UP
USTSC1:	POP P,U
	POPJ P,

USTRTS:	MOVEM U,1(T)	;STORE USER'S INDEX IN SECOND WORD
	MOVE T,(T)	;GET JNAME FROM FIRST WORD (POINTED TO BY RH OF @UTTYO)
	JRST USTRT2

;GOBBLE NEW USER SLOT, RESET VARIABLES (SKIPS IF IT WINS)
USTRA:	MOVEI U,0	;-1(P) MUST BE U
USTR3:	CAML U,USRHI
	JRST USTR1	;ASSIGN MORE CORE TO USER STORAGE
	SKIPN UNAME(U)
	JRST USTR2	;HAVE FOUND FREE USER SLOT (IN U)
	ADDI U,LUBLK
	JRST USTR3

USTR1:	SKIPGE SJCFF
	POPJ P,	;SYSTEM JOB FLUSHING CORE, WAIT UNTIL IT STABILIZES
	MOVEI U,LUBLK	;MOVE UP USRHI IF SYS HAS ENOUGH CORE
	ADD U,USRHI
	PUSH P,T
	MOVE T,HUSRAD	;LENGTH OF SYS
	CAIG T,USRSTG(U)
	JRST MORCOR	;SYS NEEDS MORE CORE FOR USER VARIABLES
	POP P,T
USSINI:	SETOM USTP-LUBLK(U)	;SYS INITIALIZATION ENTRY
	EXCH U,USRHI
USTR2:	PUSHJ P,USTR4	;RESET USER VARIABLES
	MOVEI T,SIOCHN-1(U)
	MOVEM T,SIOCP(U)
	CLEARM IOCHNM(U)
	HRLI T,IOCHNM(U)
	HRRI T,IOCHNM+1(U)
	BLT T,IOCHNM+17(U)	;CLEAR ALL I/O CHANNELS
USRST4:	HRLI T,AC0S(U)
	HRRI T,AC0S+1(U)
	SETZM AC0S(U)
	BLT T,AC17S(U)	;CLEAR AC'S & RETURN HAPPY
	JRST POPJ1

MORCOR:	MOVE U,-2(P)
	SUB P,[1,,1]
	MOVSI T,200
	ANDCAM T,SUPCOR	;CLEAR ANY SYS CORE DECREASE REQ
	MOVSI T,400000
	JRST SUPSET	;REQUEST MORE CORE FROM SYS JOB

;
; INITIALIZE USER VARIABLES, T HAS TTY # OR -1 IF NONE
;
USTR4:			;TTY NO IN T
	SETOM UNAME (U)	;T=-1 => RANDOM USRO
	MOVEM T,TTYTBL(U)
	JUMPL T,USTR4B
	PUSH P,U
	MOVEI U,400001	;NOT OPEN AND CONSOLE
	HRLM U,TTYSTS(T)
	MOVSI U,400000
	ANDCAM U,TTYSTA(T)	;WILL NEED CONSOLE FREE MESSAGE
	POP P,U
	ADDI T,USRRCE
USTR4A:	MOVEM T,UTMPTR(U)
	SETZM USWST(U)
	SETZM LUBTM(U)
	SETZM NSWPGS(U)
	SETZM NMPGS(U)
	SETOM TRNLST(U)	;INIT TRANSL LISTS TO NIL.
	SETOM TRNLS1(U)
	SETZM HUSRAD(U)
	MOVEI T,UPGCP(U)
	MOVEM T,UCPB1(U)
	ADDI T,NUVPG/4
	MOVEM T,UCPB2(U)
	MOVEI T,UPGMP(U)
	HRLI T,<NUVPG/4>_1
	MOVEM T,UDBR1(U)
	ADDI T,NUVPG/4
	MOVEM T,UDBR2(U)
	CLEARM UPGMP(U)
	MOVSI T,UPGMP(U)
	HRRI T,UPGMP+1(U)
	BLT T,UPGCP+NUVPG/2-1(U)
	MOVSI T,(MOVEM U,)
	HRRI T,AC17S(U)
	MOVEM T,SCLUSV(U)
	MOVSI T,BUSRC
	MOVEM T,USTP(U)
	SETOM SUPPRO(U)
	SETZM UCLBLK(U)
	SETOM UCLBLK+1(U)
	MOVE T,[JRST UREALB]
	MOVEM T,UCLBLK+2(U)
	CLEARM UPGML(U)	;CLEAR USER PG MAP VARIABS
	MOVEI T,UPGML+1(U)
	HRLI T,-1(T)
	BLT T,UPGML+7(U)
	MOVSI T,1+EXPGNG	;DONT ENABLE QUAN COUNTER FOR NOW (BUT SET EXEC PAGING)
	MOVEM T,UPGML+3(U)
	MOVE T,EXECMP
	MOVEM T,UPGML+6(U)	;SET UP EXEC DBR
	MOVSI T,1040
	MOVEM T,UPGML+7(U)	;SET UP B+C MEMORY PTRS
USRST2:	MOVE T,UNAME(U)	;USER RESET ETC ENTERS HERE
	MOVEM T,USYSNM(U)
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,E
	MOVEI C,UCLBLK(U)
	SKIPL 1(C)
	JSP E,CLQCLR
	POP P,E
	POP P,C
	POP P,B
	POP P,A
	SETZM URTIME(U)
	SETZM UTIME(U)
	SETOM RTIMER(U)
	MOVSI T,LSRMOD
	MOVEM T,UPC(U)
	HRLI T,-LUPDL
	HRRI T,UPDL-1(U)
	MOVEM T,USRPDL(U)
	SETZM MSKST(U)
	SETZM MSKST2(U)
	MOVEI T,40
	MOVEM T,40ADDR(U)
	MOVE T,[JRST 2,@UUOH]
	MOVEM T,SUEXIT(U)
	MOVEI T,APRCHN+440
	MOVEM T,APRC(U)
	HRRZS UTRAPM(U)
	SETOM JBI(U)
	SETZM PIRQC(U)
	SETZM IFPIR(U)
	SETOM PICLR(U)
	SETZM FLSINS(U)
	SETZM UTRNTM(U)
	SETZM USIPRQ(U)
	SETZM IOTLSR(U)
	SETZM OPTION(U)
	SETOM CORRQ(U)
	POPJ P,

USTR4B:	MOVEI T,USRRCE+NCT
	JRST USTR4A

;	USER START CODE

NUSTCD:	JFCL		;0
	.OPEN 1,7
	JRST 0	;2
	.CALL 12
	.LOGOUT
	.IOT 1,2
	JRST (2)
	4,,(SIXBIT/SYS/)	;7
	SIXBIT /ATSIGN/
	SIXBIT /HACTRN/
	SETZ		;12
	SIXBIT /LOAD/
	16
	SETZ 17
	-1
	1

USTCDR:	MOVE U,USER
	MOVEI A,USTCDR+1
	MOVEM A,UUOH
	MOVE P,USRPDL(U)
	MOVEI B,0
	PUSHJ P,UBLAM
	MOVE U,USER
	MOVSI T,NUSTCD
	HRRI T,UUOACS(U)
	BLT T,UUOACS+17(U)
	MOVE T,JNAME(U)
	MOVEM T,UUOACS+11(U)
	MOVE T,[LSRMOD,,1]
	MOVEM T,UUOH
	MOVSI T,BUSRK
	ANDCAM T,APRC(U)
	JRST URET
;
; CLOSE ALL DEVICES AND INFERIOR PROCEDURES OF A JOB (INDEX IN U)
;
IODCL:	MOVNI I,1	;SET TO STOP
	PUSHJ P,IODCL3	;STOP ALL INFERIOR JOBS (RECURSIVE)
IODCLA:
IFN 340P,	PUSHJ P,ADCLOSE	;FLUSH DISPLAY
IFN IMXP,	PUSHJ P,POTCLS	;DISCONNECT HIS POTS
IFN VIDP,[
	CAMN U,SCNUSR
	PUSHJ P,SCNSTP	;KILL SCANNER IF HIS
]
IFN ARMP,	PUSHJ P,AARMOFF	;FLUSH ARM
	PUSHJ P,CLQDEL	;RELEASE AND STOP CLOCK QUEUE BLOCK
	UCLBLK(U)
	HRRZ A,UREALT
	CAMN A,U
	SETOM UREALT	;UN REAL TIME
	CAMN U,UMASTER	;UNMASTER
	SETOM UMASTER
	PUSHJ P,AIOPDL	;POP UP ALL OF IO PDL (CLOSING CHNLS POPPED INTO)
	MOVEI R,IOCHNM(U)
IODCL1:	PUSHJ P,ACLOSE	;CLOSE ALL CHANNELS
	CAIGE R,IOCHNM+17(U)
	AOJA R,IODCL1
	MOVEI I,0	;SET TO KILL
IODCL3:	PUSH P,I	;I=0 KILL I=-1 STOP
	HRRM U,(P)
	MOVEI A,0
IODCL4:	HRRZ E,SUPPRO(A)
	SKIPE UNAME(A)	;SKIP IF VARIABLES BLOCK IDLE
	CAIE E,(U)	;SKIP ONLY IF IT IS A DIRECT INF.
	JRST IODCL5	;TRY NEXT SET OF VARS
	PUSH P,A
	MOVE U,A
	PUSHJ P,1USTOP	;STOP (WITH BUCSTP BIT)
	MOVE R,P
	MOVE P,USRPDL(U)
	PUSH P,R
	SKIPGE -1(R)
	JRST IODCL8	;STOP
	PUSHJ P,IODCLA	;KILL, RECURSE
IODCL9:	MOVE P,(P)
	SKIPGE -1(P)
	JRST IODCL7
	MOVEI B,0
	PUSHJ P,UBLST2	;FLUSH CORE
	MOVE TT,UTRNTM(U)
	MOVE B,UTMPTR(U)
	ADDM TT,NCTIM-USRRCE(B)
	MOVE TT,USIPRQ(U)	;GET NUMBER OF SWAP IN REQUESTS
	ADDM TT,NSIPRQ-USRRCE(B)
	PUSHJ P,ZUSER	;FLUSH LAST VESTIGES
	CONO PI,CLKON
IODCL7:	POP P,A
	HRRZ U,(P)
IODCL5:	ADDI A,LUBLK
	CAMGE A,USRHI
	JRST IODCL4	;LOOP FOR ALL SETS OF USER VARIABLES
	HRRZ U,(P)
	SUB P,[1,,1]
	POPJ P,

IODCL8:	PUSHJ P,IODCL3
	JRST IODCL9
;
; FLUSH LAST VESTIGES OF USER
;  ELIMINATES ALL POINTERS TO USER & FREES USER VARIABLES (CLOBBERS U TO "USER")
;
ZUSER:	MOVEI A,(U)	;CLEAR BOTH TRANSLATION LISTS
	HRLI A,300000	;FOR THIS JOB.
	PUSHJ P, NTRNC
	JFCL
	MOVEI T,1	;RETURN WITH CLOCK OFF
	DPB T,[420100,,APRC(U)]	;STOP MORE FOREIGN USER OPENS
	MOVEI A,0
ZUSER2:	SKIPE UNAME(A)
	PUSHJ P,ZUSES	;SEE IF THIS USER HAS ANY POINTERS TO BE FLUSHED
	ADDI A,LUBLK
	CAMGE A,USRHI
	JRST ZUSER2	;LOOP FOR ALL SETS OF USER VARIABLES
	CONO PI,CLKOFF
	SKIPE NMPGS(U)	;USER SHOULD HAVE NO MEMORY BY NOW
	JRST 4,.
	SKIPL T,JBI(U)
	JRST ZUSBJ	;THIS A CREATED JOB GOING AWAY
ZUSBJX:	SETZM UNAME(U)	;ONLY PLACE THAT UNAME IS ZEROED
	SETOM USTP(U)	;SET USTP TO SPEED SEARCH
	MOVE A,U	;USER FLUSHED
	MOVE U,USER
	MOVSI T,200
	IORM T,SUPCOR	;CAUSE USER VARIABLE BLOCKS DECREASE PROGRAM TO RUN
	POPJ P,	;RETURN WITH CLOCK OFF


ZUSES:	PUSH P,B	;CALLED BY ADISOWN
	PUSH P,R
	SETZM B		;CLEAR STOPPED PROC FLAG
	PUSHJ P,CHSCAA	;EXECUTE FOLLOWING INST FOR EACH CHANNEL AND I/O PDL SLOT
	PUSHJ P,ZACHEK
	POP P,R
	SKIPE B		;SKIP UNLESSS YOU STOPPED THE PROC
	PUSHJ P,UPCLSR	;RESTART USER
	JRST POPBJ

ZACHEK:	HLRZ T,(R)	;CHECK FOR CHANNEL TO ZAP
	CAME T,U
	JRST ZACHK3
	HRRZ T,(R)
	HLRZ T,CLSTB(T)
	TRNN T,401000	;IS IT EITHER TYPE OF USER CHANNEL?
	POPJ P,
	TRON B,-1	;SET FLAG
	PUSHJ P,RPCLSR	;STOP USER
	HRRZ T,(R)	;CLEAR OUT IOCHNM OR I/O PDL SLOT
	SKIPGE CLSTB(T)
	JRST ZACHK2	;FOUND SUPERIOR
	JUMPG R,ZACHK1	;IOPDL CHANNEL
	HRRZ T,R	;NORMAL CHANNEL
	SUBI T,IOCHNM(A)
	MOVE T,CHNBIT(T)
	IORM T,IFPIR(A)
ZACHK2:	SETZM (R)
	POPJ P,

ZACHK1:	MOVEI T,IIOPOP
	MOVEM T,(R)
	POPJ P,

ZACHK3:	SKIPGE JBI(U)
	POPJ P,	;JOB BEING KILLED ISN'T A CREATED JOB
	CAME T,JBI(U)
	POPJ P,
	HRRZ T,(R)
	HLRZ T,CLSTB(T)
	TRNE T,100040	;SKIP IF NOT JOB CHNL
	SETZM (R)
	POPJ P,

ZUSBJ:	SETOM JBCJUI(T)	;BOJ GUY GOING AWAY
	SKIPGE JBCG(T)	;SKIP IF CREATOR STILL HAS CHNL OPEN
	SETOM JBCUI(T)	;FLUSH JOB CHNL
	JRST ZUSBJX
;
; USER UUO WAIT (HANG UP) ROUTINE
;  DOES NOT WORK FOR XCT T OR FOR X (U) IF U .NE. USER
;
UFLS:	CONO PI,CLKOFF	;DOES NOT ALLOW CLOCK INTS
	XCT CLUSAV
	SKIPGE U,USER	;GET INDEX OF USER BEING BLOCKED
	JRST 4,.	;NULL JOB SHOULD NOT GET BLOCKED
	MOVEM T,EPDL2(U)	;SAVE C(T) FOR FLSINS AT PCLSR
	MOVEM T,AC16S(U)	;SAVE IN SWAP OUT AC ALSO
	POP P,UPC(U)		;WORK FOR INST INDEX OF P
	MOVEI T,AC0S(U)
	BLT T,AC15S(U)	;STORE REST OF ACS
	MOVE T,UPC(U)	;GET PC AT  CALL (=CALL+1 ; =SKIP +2)
	SKIPA T,-2(T)	;GET POINTER TO SKIP
UFL3:	MOVE T,(T)	;GET CONTENTS OF E (WAS AN XCT)
	HRRI T,@T	;CALCULATE E
	TLZ T,37	;CLEAR OUT @ AND INDEX BITS
	MOVEM T,FLSINS(U)	;STORE AS BLOCKING CONDITION
	TLC T,(XCT)
	TLNN T,777740
	JRST UFL3	;JUMP IF INSTRUCTION WAS XCT
	MOVSI T,210000
	ANDCAM T,USWST(U)	;CLEAR WAITING FOR PAGE (ZERO) TYPE FLSINS
	SKIPGE RPCL(U)	;SKIP IF NOT BEING RPCLSRED
	JRST UFL1	;LOSER IS BEING RPCLSRED
UFL6:	MOVE U,AC17S(U)
	SETOM UFLSF
	CONO PI,4000+200_<-APRCHN>	;CAUSE INTERRUPT TRANSFERING TO CLOCK ROUTINE PI IN PROGRESS
	JRST 4,.

UFL1:	MOVE T,UEXIT	;PICK UP EXIT INSTR
	CAME T,[JRST ONEPROC]	;SKIP IF WAS TRYING TO ONE PROCEED THE UUO THAT HUNG
	JRST UFL1A	;NOT ONE PROCEEDING
	MOVSI T,BPCROC	;GET ONE PROCEED BIT
	IORM T,UUOH	;TURN IT ON IN PC
UFL1A:	SOS T,UUOH	;UUOH HAS REAL PC IF UFL5 SKIPS. WILL GET SET BY UUOE1
	PUSHJ P,UFL5	;BACK UP TO UUO
	JRST UFL6	;FINALIZATION REQUIRED
	MOVE T,RPCL(U)
	JRST ONEFL2	;WIN

;
; VARIOUS WAIT ROUTINES:
;
;WAIT FOR INSTRUCTION AFTER CALL TO SKIP WITH UTCCHN OFF
LWAIT1:	CONO PI,UTCON	;TURN INTERRUPTS ON
LWAIT:	PCLT
	XCT @(P)	;ENTRY, EXECUTE INSTRUCTION
	PUSHJ P,UFLS	;HANG TILL INSTRUCTION SKIPS
	CONO PI,UTCOFF	;TURN INTERRUPTS OFF
	XCT @(P)	;TRY AGAIN
	JRST LWAIT1	;LOSE
	JRST POPJ1	;WIN, RETURN SKIPPING OVER ARG
;
;WAIT FOR LOCK VAR (@ NEXT LOC) TO BE -1 AND SEIZE IT
;
SWTL:	PCLT
	MOVEI T,(@)	;ENTRY
	HRLM T,(P)	;MAKE PC STORED ON PDL INDIRECT
	MOVEI T,@(P)	;ADDRESS OF SWITCH
	SKIPGE @(P)	;SKIP IF ALREADY LOCKED
	JRST SWTL1	;NOT LOCKED SO TRY TO GRAB IT
	HLRZ T,1(T)	;USER THAT HAS SWITCH
	ANDI T,77
	IMULI T,LUBLK
	CAMN T,USER	;SKIP IF THIS USER DOESN'T HAVE IT
	JRST 4,.	;THIS USER ALREADY HAS THAT SWITCH
SWTL1:	SKIPL @(P)	;(DO NOT CHANGE TO AOSE)
	PUSHJ P,UFLS	;HANG TILL NEGATIVE
	CONO PI,CLKOFF
	AOSE @(P)
	JRST SWTL1
SWTL2:	MOVEI T,@(P)
SWTL3:	PUSH P,U
	PUSH P,T
	MOVE T,USER
	IDIVI T,LUBLK
	ADDI T,600000
	MOVE U,USER
	HRL T,LSWPR(U)
	POP P,U
	MOVSM T,1(U)
	MOVE T,USER
	HRRZM U,LSWPR(T)
	POP P,U
	JRST CLKOJ1
;
;IF LOCK ALREADY SEIZED, JUST SET UP POINTERS
SWTLZ:	MOVEI T,(@)
	HRLM T,(P)
	JRST SWTL2
;
;WAIT FOR INSTRUCTION AFTER CALL TO SKIP WITH CLKCHN OFF
CWAIT1:	CONO PI,CLKON	;TURN CLOCK ON
CWAIT:	PCLT
	XCT @(P)	;ENTRY, EXECUTE INSTRUCTION
	PUSHJ P,UFLS	;HANG TILL INSTRUCTION SKIPS
	CONO PI,CLKOFF	;TURN CLOCK OFF
	XCT @(P)	;TRY AGAIN
	JRST CWAIT1	;LOSE
	JRST POPJ1	;WIN, RETURN SKIPPING OVER ARG
;
;WAIT FOR LOCK VAR (@ NEXT LOC) TO BE NON-NEGATIVE AND SEIZE IT
LSWTL:	PCLT
	MOVEI T,(@)	;IF 4.9 OF NEXT LOCN =1, RETURN WITH UTCOFF
	HRLM T,(P)
	MOVSI T,400000
	PUSHJ P,LWAIT
	SKIPGE @-1(P)
	IORM T,@(P)
	MOVE T,(P)
	SKIPL (T)
	CONO PI,UTCON
	MOVEI T,@(P)
LSWTL2:	PUSH P,TT
	MOVEI TT,600100
	PUSHJ P,LSWSET
	POP P,TT
	JRST POPJ1

;SWITCH LIST LOCK, DOES NOT WORK FOR SWITCHES POINTED TO INDEX OF A, B, OR D
;FOLLOW BY LIST OF SWITCHES
;4.9-4.1=0 3.9-3.6 0 AOSE SWITCH 1 SIGN SWITCH
SLUGH:	PCLT
	PUSH P,A
	PUSH P,B
	PUSH P,D
	MOVEI T,AC0S(U)
	BLT T,AC0S+17(U)	;FOR SLWAIT FIRST TIME
SLUGH1:	HRRZ T,-3(P)	;POINTER TO SWITCH LIST
	PUSHJ P,SLWAIT
	PUSHJ P,UFLS
	HRRZ T,-3(P)
SLUGH2:	MOVE A,(T)	;TRY TO LOCK LIST
	TLNE A,777000
	JRST SLUWIN	;REACHED END OF LIST
	LDB B,[220400,,A]	;INDEX
	LDB D,[300300,,A]
	SKIPE B
	ADD A,(B)
	HRRZS A
	CAIL D,2
	JRST 4,.
	XCT SLLOCK(D)
	JRST SLULOS
	AOBJP T,SLUGH2	;LH COUNTS SWITCHES SUCCESSFULLY SEIZED

SLWAIT:	MOVE A,(T)
	TLNE A,777000
	JRST POPJ1	;WIN
	LDB B,[220400,,A]	;INDEX
	LDB D,[300300,,A]	;TYPE CODE
	JUMPE B,SLWT1
	ADD B,U
	ADD A,AC0S(B)
SLWT1:	CAIL D,2
	JRST 4,.
	XCT SLWATT(D)
	POPJ P,	;LOSE
	AOJA T,SLWAIT	;THAT SWITCH OK, TRY OTHERS

SLWATT:	SKIPL (A)	;WAIT FOR NEG (AOSE SW)
	SKIPGE (A)	;WAIT FOR POS (SIGN SW)

SLUWIN:	POP P,D
	POP P,B
	POP P,A
	SUB P,[1,,1]	;"RETURN" BUT NOT INCREMENTED
	JRST (T)

SLLOCK:	PUSHJ P,SWTLX
	PUSHJ P,LSWTLX

SLULOS:	HLRZ A,T
SLULO2:	JUMPE A,SLUGH1	;NONE SEIZED TRY AGAIN
	PUSHJ P,LSWPOP	;RELEASE THOSE SEIZED
	SOJA A,SLULO2

SWTLX:	AOSE (A)
	POPJ P,
	EXCH A,T
	PUSHJ P,SWTL3
	JRST 4,.
SWTLX1:	EXCH A,T
	JRST POPJ1

LSWTLX:	CONO PI,UTCOFF
	SKIPGE (A)
	JRST UTCONJ
	MOVSI B,400000
	IORM B,(A)
	CONO PI,UTCON
	EXCH A,T
	PUSH P,TT
	MOVEI TT,600100
	PUSHJ P,LSWSET
	POP P,TT
	JRST SWTLX1

;SET UP ROUTINE TO SETOM VARIABLE UPON UNLOCKING SWITCH
STMSET:	PUSH P,TT
	MOVEI TT,600600
	JRST COMSET

;SET UP ROUTINE TO BE CALLED ON PCLSR'ING OUT
FINSET:	MOVE T,@(P)
	HRLI T,-1(P)
	PUSH P,TT
	MOVEI TT,400200
	PUSHJ P,LSWSET
	POP P,TT
	JRST POPJ1

;SET UP ROUTINE TO AOS VARIABLE UPON UNLOCKING SWITCH
AOSSET:	PUSH P,TT
	MOVEI TT,600500
	JRST COMSET

;SET UP ROUTINE TO SOS VARIABLE UPON UNLOCKING SWITCH
SOSSET:	PUSH P,TT
	MOVEI TT,600300
	JRST COMSET

;SET UP ROUTINE TO SOS LH UPON UNLOCKING SWITCH
SOLSET:	PUSH P,TT
	MOVEI TT,600700
	JRST COMSET

;SET UP ROUTINE TO BE CALLED UPON UNLOCKING SWITCH
LOSSET:	MOVE T,@(P)
	HRLI T,-1(P)
	PUSH P,TT
	MOVEI TT,600200
	PUSHJ P,LSWSET
	POP P,TT
	JRST POPJ1

;ROUTINE TO ADD THIS PROCEDURE TO A LIST POINTED TO
;BY THE WORD AFTER THE CALL.  UNLOCKING REMOVES IT FROM THE LIST
LSTSET:	PUSH P,TT	;LEAVES CLKON
	MOVEI TT,600400
	PUSHJ P,LSTST3
	POP P,TT
	JRST POPJ1

LSTST3:	PUSH P,U
	PUSH P,Q
	MOVEI Q,LSWB0(U)
REPEAT NULBLK,[
IFN .RPCNT,ADDI Q,2
	SKIPN 1(Q)
	JRST LSTST2
]
	JRST 4,.	;NOT ENOUGH BLOCKS
LSTST2:	MOVE T,@-4(P)	;ADDRESS OF HEAD OF LIST
	CONO PI,CLKOFF
	PUSH P,(T)	;PUSH HEAD OF LIST
	POP P,(Q)	;POP INTO LSWB BLOCK
	MOVEM Q,(T)
	HRLM T,(Q)
	MOVE T,(Q)
	TRNE T,-1
	HRLM Q,(T)
	CONO PI,CLKON
	JRST LSWSE3

;SET UP ROUTINE TO SETOM VARIABLE UPON UNLOCKING OF SWITCH
;BY OTHER THAN PCLSRING OUT
STMNPS:	PUSH P,TT
	MOVEI TT,200600
	JRST COMSET

;SET UP ROUTINE TO CLEAR SIGN BIT OF VARIABLE UPON UNLOCKING SWITCH
SGNSET:	PUSH P,TT
	MOVEI TT,600100
	JRST COMSET

;SET UP ROUTINE TO DO NOTHING UPON UNLOCKING SWITCH
NULSET:	PUSH P,TT
	MOVEI TT,0
	PUSHJ P,LSWSET
	POP P,TT
	POPJ P,

;SET UP ROUTINE TO BE CALLED UPON UNLOCKING OF SWITCH
;BY OTHER THAN PCLSRING OUT
LNPSET:	PUSH P,TT
	MOVEI TT,200200
	JRST COMSET

COMSET:	EXCH TT,(P)
	MOVE T,@-1(P)
	MOVEI T,@T
	EXCH TT,(P)
	PUSHJ P,LSWSET
	POP P,TT
	JRST POPJ1

;SET USER LOCK SWITCH BLOCK,  WD1 IN T,  MODE IN TT
LSWSET:	PUSH P,U
	MOVE U,USER
	PUSH P,Q
	MOVEI Q,LSWB0(U)
REPEAT NULBLK,[IFN .RPCNT,ADDI Q,2
	SKIPN 1(Q)
	JRST LSWSE2
]
	JRST 4,.	;NOT ENOUGH BLOCKS

LSWSE2:	MOVEM T,(Q)
LSWSE3:	MOVE T,U
	IDIVI T,LUBLK
	MOVE U,USER
	HRL T,LSWPR(U)
	IOR T,TT	;GET TYPE
	MOVSM T,1(Q)
	HRRZM Q,LSWPR(U)
	JRST POPQUJ

;UNLOCK ALL SWITCHES, CALLED BY OPENL, ADISOWN, IOADCR
LSWCLR:	PUSH P,T
LSWCL1:	SKIPN T,LSWPR(U)	;MUST HAVE USER IN U
	JRST POPTJ
	PUSHJ P,LSWPOP
	JRST LSWCL1

LSWPJ1:	AOS (P)
LSWPOP:	PUSH P,U
	MOVE U,USER
	TLO U,400000	;SIGNAL NOT PCLSR
	SKIPN T,LSWPR(U)
	JRST 4,.
	PUSHJ P,LSWPPP
	JRST POPUJ

LSWPPP:	PUSH P,T
	MOVE T,1(T)
	HRRZM T,LSWPR(U)
	PUSHJ P,LSWDIS
	POP P,T
	CAILE T,USRSTG
	SETZM 1(T)	;FREE LSWB(N) BLOCK
	POPJ P,

;4.9=1 => PERFORM FUNCTION ON PCLSR
;4.8=1 => PERFORM FUNCTION ON ANY LSWPOP OTHER THAN PCLSR
;3.7-3.9 => FUNCTION

LSWDIS:	PUSH P,A
	MOVE A,T
	LDB T,[300300,,T]	;FUNCTION
	TLNE A,400000	;SKIP IF NOT FOR PCLSR
	JUMPGE U,LSWDS1	;PCLSRED AND 4.9=1
	TLNN A,200000	;NOT FOR PCLSR OR FOR PCLSR BUT NOT PCLSRED
	JRST POPAJ	;NOT FOR EITHER LSWPOP
	JUMPGE U,POPAJ	;FOR OTHER LSWPOP BUT PCLSRED
LSWDS1:	POP P,A
	JRST LSWTAB(T)

LSWTAB:	JRST UNSWTL	;0 (AOSE) ALSO USED FOR QUSR
	JRST UNLSWT	;1 (SIGN)
	JRST ULROUT	;2 (GO TO ROUTINE)
	JRST ULAOS	;3 (AOS, SOS)
	JRST UNLST	;4 (UNLOCK FROM LIST)
	JRST ULSOS	;5 (SOS, AOS)
	JRST ULSTM	;6  (SETOM)
	JRST ULAOSL	;7 (AOS,SOS LEFT HALF)

UNSWTL:	MOVE T,-1(P)
	SETOM (T)
	POPJ P,

ULSTM:	MOVE T,@-1(P)
	SETOM (T)
	POPJ P,

UNLSWT:	MOVE T,@-1(P)
	PUSH P,A
	MOVSI A,400000
	ANDCAM A,(T)
	JRST POPAJ

ULAOSL:	MOVE T,@-1(P)
	PUSH P,A
	MOVSI A,-1
	ADDM A,(T)
	JRST POPAJ

ULAOS:	MOVE T,@-1(P)
	SOS (T)
	POPJ P,

UNLST:	SETOM DLSRCH
	MOVS T,@-1(P)
	HLRM T,(T)
	MOVSS T
	TRNE T,-1
	HLLM T,(T)
	SETZM DLSRCH
	POPJ P,

ULSOS:	MOVE T,@-1(P)
	AOS (T)
	POPJ P,

ULROUT:	MOVE T,-1(P)
	MOVE T,(T)
	JUMPGE U,ULPCLZ	;JUMP IF PCLSR
	JRST (T)

ULPCLZ:	HRRZM T,UPC(U)
	TLNE T,-1
	HLRM T,AC15S(U)
	TLOE U,200000	;SIGNAL PC CLOBBERED
	JRST 4,.	;PC TRIED TO BE CLOBBERED TWICE
	POPJ P,


LSWZAP:	PUSH P,U
LSWZP1:	PUSH P,T	;FROM PCLSR
	MOVE T,1(T)
	HRRZM T,LSWPR(U)
	PUSHJ P,LSWDIS
	POP P,T
	HRR U,(P)
	CAILE T,USRSTG
	SETZM 1(T)
	SKIPE T,LSWPR(U)
	JRST LSWZP1
	SUB P,[1,,1]
	TLZN U,200000	;HAS PC BEEN CLOBBERED?
	JRST PCLSR7	;NO
	SKIPLE PCLDBM
	SETZM LSUUO(U)	;INDICATE OCCURRENCE OF FINSET (WILL MEAN WE HAVEN'T MISSED MARK)
	JRST PCLSR4	;REQUIRED TO START UP ROUTINE

;FIND SWITCH POINTED TO BY WORD AFTER
;PUSHJ P,LSWREM AND UNLOCK IT
LSWREM:	PUSH P,T
	PUSH P,U
	PUSH P,Q
	MOVE U,USER
	SKIPN U,LSWPR(U)
	JRST 4,.
	HRRZ Q,@-3(P)
	MOVEI T,1
LSWRM1:	CAMN U,Q
	JRST LSWRM2
	HRRZ U,1(U)
	JUMPE U,[JRST 4,.]
	AOJA T,LSWRM1
LSWRM2:	POP P,Q
	POP P,U
	PUSHJ P,LSWPON
	AOS -1(P)
	JRST POPTJ

LSWDEL:	PUSH P,U	;REMOVE SWITCH FROM HEAD OF LIST
	MOVE U,USER	;DO NOT ATTEMPT TO UNLOCK IT
	PUSH P,T
	SKIPN T,LSWPR(U)
	JRST 4,.
	PUSHJ P,LSWDDD
	JRST POPTUJ

LSWDDD:	PUSH P,Q
	HRRZ Q,1(T)
	HRRZM Q,LSWPR(U)
	CAILE T,USRSTG
	SETZM 1(T)
	POP P,Q
	POPJ P,

;POP C(T)'TH FROB BACK
LSWPON:	PUSHJ P,LSWBAK
	PUSHJ P,LSWPPP
	POPJ P,

;DELETE C(T)'TH FROB BACK
LSWDLN:	PUSHJ P,LSWBAK
	PUSHJ P,LSWDDD
	POPJ P,

LSWBAK:	PUSH P,U
	MOVE U,USER
	TLO U,400000	;SIGNAL NOT PCLSR IN CASE OF LSWPPP
	PUSH P,Q
	MOVE Q,T
	MOVEI T,LSWPR-1(U)
	SOJE Q,LSWBA3	;UNLOCKING FIRST FROB
	MOVE T,1(T)
	SOJG Q,.-1
LSWBA2:	MOVE Q,T
	HRRZ T,1(T)
	PUSH P,LSWPR(U)	;DON'T WORRY, YOU CAN'T GET PCLSR'ED JUST BELOW
	XCT @-3(P)
	HRRZ T,LSWPR(U)
	HRRM T,1(Q)
	POP P,LSWPR(U)
	JRST POPQU1

LSWBA3:	MOVE T,LSWPR(U)
	XCT @-2(P)
	JRST POPQU1
;VARIOUS RETURNS
PPBAJ1:	POP P,B
POPAJ1:	AOSA -1(P)
POPBAJ:	POP P,B
POPAJ:	POP P,A
CPOPJ:	POPJ P,

POPBJ:	POP P,B
	POPJ P,

POPJ3:	AOS (P)
POPJ2:	AOSA (P)
POPCJ1:	POP P,C
POPJ1:	AOS (P)
	POPJ P,

POPJJ1:	AOS -1(P)
POPJJ:	POP P,J
	POPJ P,

POPUJ1:	AOSA -1(P)
POPTUJ:	POP P,T
POPUJ:	POP P,U
	POPJ P,

POPTJ:	POP P,T
	POPJ P,

CKOCJ1:	CONO PI,CLKON
	JRST POPCJ1

CLKOJ1:	AOS (P)
CLKONJ:	CONO PI,CLKON
	POPJ P,

CKOPJ1:	AOS (P)
CLKOPJ:	CONO PI,CLKON
	JRST LSWPOP

IFN OMXP,[
OMXONJ:	CONO PI,OMXON
	POPJ P,
]

TTYOJ1:	AOS (P)
TTYONJ:	CONO PI,TTYON
	POPJ P,

IFN LPTP,	LPTONJ:
PTRONJ:
PTPONJ:	CONO PI,PTRON
	POPJ P,

UTCOJ1:	AOS (P)
NETONJ:
UTCONJ:	CONO PI,UTCON
	POPJ P,

POPQU1:	AOS -2(P)
POPQUJ:	POP P,Q
	POP P,U
	POPJ P,

POP1J1:	AOS -1(P)
POP1J:	SUB P,[1,,1]
	POPJ P,

POP2J:	SUB P,[2,,2]
	POPJ P,

POP3J:	SUB P,[3,,3]
	POPJ P,

POP4J:	SUB P,[4,,4]
	POPJ P,

;UUO PROCESSOR

.IOT=UUOMIN
.OPEN=UUOMIN+1_27.
.OPER=UUOMIN+2_27.
.CALL=UUOMIN+3_27.
.USET=UUOMIN+4_27.
.BREAK=UUOMIN+5_27.
.STATUS=UUOMIN+6_27.
.ACCESS=UUOMIN+7_27.

DEFINE GLOSYM X
	IRP Y,,[X]
	SQUOZE 4,.!Y
	.!Y
	TERMIN
	TERMIN

;SYMBOLS SHOULD BE LEFT IN CURRENT ORDER OR DDT WILL LOSE
	DEFINE USTIRP A
	IRPS X,,[UPC VAL TTY FLS UNAME JNAME MASK USTP
PIRQC INTB MEMT SV40 IPIRQ APIRQ SNAM PICLR
MARA MARPC UUOH UIND RUNT MSK2 IFPIR APRC
SV60 UTRP IIFPI AIFPI IMASK AMASK IMSK2 AMSK2
JPC OPC RTMR 60H BCHN MPVA IDF1 ADF1
IDF2 ADF2 DF1 DF2 OPTION 40ADDR]
A
TERMIN
TERMIN

SYSYMB:	USTIRP [SQUOZE 44,.R!X
	.IRPCNT]
	SQUOZE 44,.RIOC
	100
	SQUOZE 44,.RIOS
	120
	SQUOZE 44,.RIOP
	140
	SQUOZE 44,.RPMAP
	200
	USTIRP [SQUOZE 44,.S!X
	400000+.IRPCNT]

	GLOSYM [IOT,OPEN,OPER]

;NOTE:  OPER'S BELOW ARE 8 PER LINE
;    USE UP ILUUO'S BEFORE ADDING TO END
; THE FOLLOWING SHOULD GO AWAY EVENTUALLY
;	ITYI (=ITYIC)
;	SETMSK (=SUSET)
;	WSNAME (=SUSET)
;	UPISET (=SUSET)
;	RDSW (=DATAI)
;	EOFC (OBSOLETE)
DEFINE OPRIRP A
	IRPS X,,[ITYI LISTEN SLEEP SETMSK SETM2 ILUUO CLOSE
UCLOSE ATTY DTTY IOPUSH IOPOP DCLOSE DSTOP RDTIME
RDSW GUN UDISMT GETSYS IPDP GETLOC SETLOC DISOWN
MSPACE ILUUO GENSYM LOGOUT REALT WSNAME UPISET RESET
ARMOVE ILUUO CBLK ASSIGN DESIGN RTIME RDATE HANG
EOFC IOTLSR RSYSI SUPSET PDTIME ARMRS UBLAT IOPDL
ITYIC MASTER VSTST NETAC NETS REVIVE DIETIM SHUTDN
ARMOFF NDIS FEED EVAL REDEF IFSET UTNAM UINIT
RYEAR RLPDTM RDATIM RCHST RBTC DMPCH SWAP]
	A
	TERMIN
	TERMIN

	ZZ=1
	OPRIRP [IFSN X,ILUUO,[.!X=.OPER ZZ
	SQUOZE 4,.!X
	.!X]
	ZZ==ZZ+1]

MXOPR==ZZ

	SQUOZE 4,.CALL
	.CALL

	ZZ=1
	IRPS X,,[DISMIS UNUSD TRANAD VALUE UTRAN CORE TRAND
DSTART FDELE DSTRTL SUSET LTPEN VSCAN POTSET]
IFSN X,UNUSD,[
	.!X=.CALL ZZ,
	SQUOZE 4,.!X
	.!X
]
	ZZ==ZZ+1
	TERMIN

	GLOSYM [USET,BREAK,STATUS,ACCESS]
SYSYME==.-1

		;BEGINNING FOR .GETSYS (USYMS)
SYSUSB:	USTIRP [SQUOZE 4,.!X
	.IRPCNT]
	SQUOZE 4,.IOC
	100
	SQUOZE 4,.IOS
	120
	SQUOZE 4,.IOP
	140
	SQUOZE 4,.PMAP
	200
SYSUSE==.-1	;END FOR .GETSYS (USYMS)
;
; UUO AND ILLOP TRAP HANDLER
;
;EITHER DISPATCHES TO APPROPRIATE UUO ROUTINE,
;   RETURNS CONTROL TO USERS UUO ROUTINE, GOES TO ILLOP, USRTRP, OR USRIOT.
;CODE ON THIS PAGE IS INTERRUPTABLE AT ANY POINT

USRUUO:	CAIG U,LUBLK
	JRST 4,.
	MOVE P,USRPDL(U)	;IN CASE WE TAKE A PAGE FAULT
	HRRZ A,40ADDR(U)
	XCTR XW,[MOVEM T,(A)]	;PLANT UUO INTO USERS 40
	MOVE T,UUOH	;PICK UP FLAGS
	TLNN T,LSRMOD	;SKIP IF INTERRUPT FROM USER MODE
	JRST 4,.	;GET HERE FOR NON-SYS-CALL UUO IN EXECUTIVE MODE
	XCTR XRW,[HRRZ T,1(A)]	;PICK UP USERS 41, SHOULD POINT TO HIS UUO HANDLER
	XCTR XR,[MOVE A,A]
USRUU1:	JUMPE T,ILLOP	;BAD USER 41
	HRLI U,1(T)
	HRLI T,UUOH	;SAVE ADR TO TRANSFER TO
	XCTR XW,[BLT T,0]		;SIMULATE A JSR AT USERS 41
	HLRM U,UUOH	;SET TO RETURN TO USER AT FIRST INSTRUCTION OF UUO HANDLER
FEXIT:	XCTR XR,[MOVE P,15]
	XCTR XR,[MOVE T,16]	;RESTORE USER 16
	XCTR XR,[MOVE U,17]	;RESTORE USER 17

EBLK

;THE FOLLOWING BLOCK OF THREE LOCATION IS SWITCHED WITH USERS
UEXIT:	JRST 2,@UUOH	;EXIT FROM UUO
CLUSAV:	MOVEM U,AC17S	;CLOCK SAVE OF U
UUOH:	0		;UUO AND ILLOP TRAP GETS HERE

BBLK
	CONSZ PI,77400
	JRST 4,.	;PI IN PROGRESS??
	XCTR XW,[MOVEM U,17]	;SAVE 17
	SKIPGE U,USER	;LOAD CURRENT USERS INDEX, SKIP IF NULL JOB
	JRST 4,.	;UUO WAS EXECTUED BY THE NULL OR AN APPARENTLY SWAPPED OUT JOB
	XCTR XW,[MOVEM T,16]	;SAVE LOC 16 FOR USER
	MOVEI T,0	;HA HA
	XCTR XW,[BLT T,15]	;SAVE REST OF ACS IN USERS SHADOW 0-15
	SKIPGE UTRAPM(U)	;IF IN USER TRAP MODE
	JRST USRTRP		;GIVE TRAP TO SUPERIOR
	SKIPGE T,40	;PICK UP THE UUO OR ILLOP
	JRST USRIOT
	CAML T,[100000,,]	;SKIP IF NOT ILLEGAL JRST
	JRST ILLOP	;ILLEGAL
	CAML T,[UUOMIN]
	CAML T,[UUOMAX]
	JRST USRUUO	;NOT A SYSTEM CALL, GIVE TO USER
ILLOP1:	JUMPN U,UUOH1
	MOVEI Q,0	;SAVE SYS JOB EXEC MODE LSWPR PNTR
	EXCH Q,LSWPR
	MOVEM Q,SLSWPR
UUOH1:
	MOVEM T,LSUUO(U)	;SAVE UUO FOR DEBUGGING PURPOSES
	LSH T,-27.	;RIGHT JUSTIFY OP CODE
UUOTR2:	MOVE P,USRPDL(U)	;SET UP USER PDL
	HRRZ C,40	;PICK UP EFFECTIVE ADDRESS OF UUO
	LDB R,[270400,,40]	;PICK UP AC FIELD OF UUO
	MOVEM R,UUAC(U)	;SAVE AC FLD
	PUSHJ P,@UUODSP-UUOMIN_-27.(T)	;DISPATCH ON UUO TYPE
	JRST URET	;NORMAL RETURN (NON SKIP)
URETJ1:	AOS UUOH	;UUO ROUTINE SKIPPED, AOS USER RETURN POINT
URET:	MOVE U,USER
	SKIPE UMAPS(U)
	PUSHJ P,MPLDZ
	CAMN U,PCLUSR
	SKIPG PCLDBM
	JRST URET2
	SKIPL PCLNXT
	JRST URPCL1
URET2:	SKIPE LSWPR(U)
	JRST 4,.
	JUMPN U,URETC
	MOVEI T,0	;RESTORE SYS JOB EXEC LSWPR
	EXCH T,SLSWPR
	MOVEM T,LSWPR
URET1:	CONSO PI,1
	JRST 4,.	;RETURNING TO USER MODE WITH CLOCK OFF
	MOVEI U,0
	XCTR XR,[BLT U,U]		;RESTORE USERS ACS FROM USERS SHADOW 0-17
	JRST UEXIT

URETC:	REPEAT NULBLK/2,[
	SKIPN CONC LSWB,\<2*.RPCNT>,+1(U)
	SKIPE CONC LSWB,\<2*.RPCNT+1>,+1(U)
	JRST 4,.
]
	REPEAT NULBLK&1,[
	SKIPE CONC LSWB,\<NULBLK-1>,+1(U)
	JRST 4,.
]
	JRST URET1

URPCL1:	SKIPN LSUUO(U)
	JRST URET2	;DIDN'T REALLY MISS MARK (DUE TO FINSET)
	SETOM PCLNXT	;MISSED MARK, REINITIALIZE
	SETZM PCLL
	SETZM PCLHSH
	JRST URET2

TPFTRO:	PUSHJ P,TPFLT
UUOTRO:	LDB T,[331100,,40]
	JRST UUOTR2

USRTRP:	SKIPA T,[UTRAP]	;USER IN TRAP MODE, GENERATE PSEUDO UUO TO DISPATCH ON
USRIOT:	MOVSI T,(UIOT)
	JRST ILLOP1

ILLOP:	MOVE T,UUOH	;GET PC WRD (FLAGS IN LH)
	TLNN T,LSRMOD	;SKIP IF IN USER MODE
	JRST 4,.	;SHOULD NOT GET ILLOP TRAPS FROM EXEC MODE
	MOVSI T,(AUUO)	;GENERATE PSEUDO UUO TO DISPATCH ON
	JRST ILLOP1

60H:	0	;TRAPS FROM 60
	CONSZ PI,77400
	JRST 4,.	;PI IN PROGRESS??
	XCTR XW,[MOVEM U,17]
	SKIPGE U,USER
	JRST 4,.
	XCTR XW,[MOVEM T,16]
	MOVEI T,0
	XCTR XW,[BLT T,15]
	SKIPGE UTRAPM(U)
	JRST USRTRP
	MOVE T,60
	XCTR XW,[MOVEM T,60]
	MOVE P,60H
	MOVEM P,UUOH
	TLNN P,LSRMOD
	JRST 4,.
	LSH T,-27.
	CAIN T,107
	JRST AUSPM
	XCTR XRW,[HRRZ T,61]
	JRST USRUU1

AUSPM:	SPM UPGML(U)
	MOVSI P,UPGML(U)
	HRR P,60
	HRRZ U,P
	XCTR XW,[BLT P,7(U)]
	JRST FEXIT

;WHEN YOU GET HERE, ALL ACS IN MACHINE ALSO IN UUO ACS
ONEFLS:	CONO PI,CLKOFF	;TURN OFF CLOCK BREAKS
	MOVE U,USER	;GET INDEX OF CURRENT USER
ONEPR2:	SKIPE T,RPCL(U)	;SKIP IF NO RPCLSRING OCCURING
	JRST ONEFL2	;RPCLSRING GOING ON
ONEPR1:
UUOE1:	MOVE U,USER	;GET INDEX OF CURRENT USER
	CONO PI,CLKOFF	;TURN OFF CLOCK BREAKS
	SKIPE LSWPR(U)
	JRST 4,.
	MOVEI T,AC0S(U)
	HRLI T,UUOACS(U)
	BLT T,AC17S(U)	;LOAD SWAP OUT AC'S FROM UUO ACS
	MOVE T,UUOH
	MOVEM T,UPC(U)	;SIMULATE JRST 2,@UUOH
	MOVE T,[JRST 2,@UUOH]
	MOVEM T,UEXIT	;RESTORE UEXIT
	JRST UFL6	;RESCHEDULE, ETC

ONEFL2:	JUMPG T,[JRST 4,.]	;LOSEY LOSEY (SHOULD NOT TRY TO EXIT WHILE TRYING TO RPCLSR SOMEONE)
	MOVE A,FLSINS(T)	;GET FLSINS OF USER SUPPOSEDLY RPCLSRING YOU
	SUBI A,RPCL(T)	;HIS FLSINS SHOULD BE A SKIPE OF HIS RPCL
	CAME A,[SKIPE]	;SKIP IF HE HAS THE RIGHT FLSINS
	JRST 4,.	;LOSEY LOSEY
	CLEARM FLSINS(T)	;ASSURE NO INTERRUPT
	SETZM RPCL(U)	;ACS IN UUO ACS CLOCK OFF
	AOS USTP(U)	;STOP SELF
	SETZM RPCL(T)	;UNHANG LOSER RPCLSR'ING YOU
	JRST ONEPR1

AILUUO:
ILUUO:	PUSHJ P,LSWCLR
	SKIPA T,[BILLOP]	;ILLEGAL SYSTEM UUO
AUTRAP:	MOVSI T,(BUTRAP)	;GET UUO TRAP INT BIT

UUOERR:	IORM T,PIRQC(U)	;GIVE USER INT BIT
UUOE2:	MOVE U,USER
	SKIPE UMAPS(U)
	PUSHJ P,MPLDZ
	SKIPGE UTRAPM(U)
	JRST UUOE1
	MOVE T,40	;PICK UP BAD UUO
	XCTR XWI,[MOVEM T,40]	;PUT IN USERS LOC 40
	JRST UUOE1
	MOVE T,UPGCP(U)
	TLNE T,-1
	PUSHJ P,TPFLT
	JRST UUOE1	;FORGET IT IF NO PAGE 0

IOADCR:	MOVE U,USER
	PUSHJ P,LSWCLR	;PC GETS SET HERE BY CLOCK ROUTINE
	JRST UUOE2	;ON EXEC PG FAULT

IOADC:	MOVEI T,BIOADC	;I/O UUO MEMORY PROTECT VIOLATION
	JRST UUOERR

	RADIX 10.
IOCERF:	;ADDRESS OF FIRST IO CHANNEL ERROR
ZZ==NIOTER
IFG ZZ-9,ZZ==9
REPEAT ZZ,CONC IOCER,\.RPCNT+MIOTER,:	JSP T,IOCERX
IFG NIOTER-9,[REPEAT NIOTER-9,CONC IOCR,\.RPCNT+MIOTER+9,:	JSP T,IOCERX
]
	RADIX 8
IOCERX:	SUBI T,IOCER9-9+1
	MOVE TT,UUAC(U)
	MOVE U,USER
	DPB TT,[BCHPTR]
	ADD TT,U
	DPB T,[330600,,IOCHST(TT)]
	PUSHJ P,LSWCLR
IOCERR:	MOVEI T,BIOCERR
	JRST UUOERR

ILEXPF:	CONO PI,CLKOFF	;GET HERE AFTER EXEC PAGE FAULT TAKEN ON XI
	SPM UPGML(U)
	MOVSI A,1770	;CLEAR FAULT REASON BITS
	ANDCAM A,UPGML+3(U)
	LPMR UPGML(U)
	JRST ILUUO

;UUO DISPATCH

;AT DISPATCH TIME, P HAS UPDL C HAS RH OF 40
	;R HAS AC FLD OF UUO U HAS USER INDEX

UUODSP:	AIOT
	AOPEN
	AOPER
	ACALL
	AUSET
	ABREAK
	ASTATUS	
	AACCESS
	ILUUO	;INSERT ADDED UUO'S HERE ^
	AUTRAP
	AUIOT
IF2,[IFN <UIOT-UUOMIN>_-27.+UUODSP-.+1,[PRINTX /LOSE AT UUODSP
/]]

ABREAK:	MOVEI T,BRKF	;INTERRUPT TO SUPERIOR
ILLOP4:	IORM T,PIRQC(U)
	JRST UUOE1

;IOT DISPATCH

NIOT:	MOVE R,A
	CAIL R,20
	JRST OPNL14
	MOVEM R,UUAC(U)
	AOS (P)
	HRRZ C,B
	JRST AIOT1

AIOT:	MOVE A,OPTION(U)
	TLNE A,OPTDEC
	JRST USRUUO
AIOT1:	MOVE A,U
	IDIVI A,LUBLK
	JUMPN B,[JRST 4,.]
	ADDI R,IOCHNM(U)	;MAKE "R" A POINTER TO IOCHNM WORD
	HLRZ A,(R)	;PICK UP LEFT HALF (DEVICE DEPENDENT)
	HRRZ B,(R)	;PICK UP RIGHT HALF (INDEX INTO IOTTB, ETC.)
	JRST @IOTTB(B)	;GO TO ROUTINE FOR PARTICULAR DEV AND MODE

;RANDOM ACCESS

AACCES:	MOVE B,OPTION(U)
	TLNE B,OPTDEC
	JRST USRUUO
	HRRZ B,40
	MOVE A,UUAC(U)
	XCTR XR,[MOVE B,(B)]
	SOS (P)		;DON'T SKIP
NACCES:	CAIL A,20
	JRST OPNL14
	ADDI A,IOCHNM(U)
	HLRZ I,(A)
	HRRZ J,(A)
	JUMPE J,IOCER8	;JUMP IF CHANNEL NOT OPEN
	HRRM B,IOCHST-IOCHNM(A)	;STORE USR .ACCESS POINTER
	MOVE D,CLSTB(J)
	TLNN D,200
	JRST POPJ1		;NOT 2311 DEVICE
	MOVEM B,QRADAD(I)	;STORE ACCESS POINTER FOR DSK
	MOVSI D,100
	IORM D,QSRAC(I)	;SET ADR HAS BEEN HACKED FLAG
	JRST POPJ1

;
; ROUTINES TO SIMULATE SOME I/O INSTRUCTIONS WHEN EXECUTED BY USER
;
AUIOT:	MOVE I,40	;GET I/O INST
AUIOT2:	ANDI R,7	;GET IOT TYPE FIELD
	LDB J,[320700,,40]
	LDB D,[420200,,IOTTYP(R)]
	JRST @IOTTYP(R)	;DISPATCH ON TYPE

IOTTYP:	IOTTY3		;BLKI
	IOTTY2		;DATAI
	200000,,IOTTY3		;BLKO
	200000,,IOTTY2		;DATAO
	300000,,IOTTY2		;CONO
	400000,,IOTTY2		;CONI
	400000,,IOTTY1		;CONSZ
	400000,,IOTTY1		;CONSO

IOTTY1:	CAIN J,177	;IF EQ INST WAS 7777XX,,XXXXXX
	JRST ILUUO	;USER HAS EXECUTED A SMALL NEGATIVE NUMBER
	JRST IOTTY2

IOTTY3:	TLO I,40	;BLOCK TYPE, TURN ON BIT TO CONVERT TO UNIT
	XCTR XR,[MOVE C,(I)]	;GET BLOCK POINTER
	ADD C,[1,,1]	;ADVANCE
	TLNE C,-1	;SKIP IF OVERFLOW
	AOS (P)		;CAUSE RETURN TO SKIP
	XCTR XW,[MOVEM C,(I)]	;STORE BACK
	HRR I,C		;MODIFY INST ADR TO RH OF BLOCK POINTER
IOTTY2:	SKIPL C,DCHNTB(J)
	JRST IOTTYA
	LSH C,19.(D)
	SKIPL C
	JRST ILUUO
IOTTYB:	XCTR XRW,I		;DO IOT
	POPJ P,		;NORMAL RETURN
	JRST POPJ1	;IOT SKIPPED RETURN

IOTTYA:	SKIPGE DCHNTC(J)
	JRST ILUUO
	JRST IOTTYB
;
;	.SUSET [N,,LOC]	;SAME AS .USET (SEE BELOW) BUT REFERS TO SELF
;
ASUSET:	MOVE C,B	;TEMP
	MOVE A,U	;MAKE SELF-REFERENT
	MOVEI I,1	;INDICATE SUSET
	MOVEI B,UWIDN	;MAKE LOOK LIKE A USER CHANNEL
	JRST ASUS2
;			;IF N&200000=1, BLOCK MODE
;	.USET CH,[N,,LOC]	;IF N&400000=0, READS USER VAR SPECIFIED BY REST OF N
				;	FOR INFERIOR OR FOREIGN USER OPEN ON CHANNEL CH
				;	INTO USER LOCATION LOC
				;IF N&400000.NE.0, SETS USER VAR SPECIFIED BY REST OF N
				;	FOR DIRECTLY INFERIOR USER OPEN ON CHANNEL CH
				;	FROM USER LOCATION LOC
AUSET:	PUSHJ P,STDUUO	;SET UP AC'S
	MOVEI I,0	;INDICATE A USET
ASUS2:	XCTR XRW,[HRRZ J,(C)]	;GET LOC READING INTO OR SETTING FROM
	XCTR XRW,[HLRZ Q,(C)]	;GET VARIABLE AND DIRECTION INFO
	HLRZ H,CLSTB(B)	;GET CLSTB BITS
	TRNE Q,200000
	JRST ABUSET
	TRNE H,100	;SKIP UNLESS PDP-10 DEVICE
	JRST PDPPMT	;PDP-10 DEV.
	TRZE Q,400000	;SKIP IF READING
	TRO I,2		;INDICATE SETTING
	TRNE I,2	;SKIP IF READING
	TRNE H,500000	;SKIP IF NOT INFERIOR OPEN ON CH OR JOB DEVICE
	TRNN H,501000	;SKIP IF INFERIOR OR FOREIGN USER OPEN OR JOB DEVICE
	JRST IOCER7	;NO USER OPEN IF READING OR NOT INFERIOR IF SETTING
	TRNE H,100000
	MOVE A,JBCJUI(A)	;CREATED PROCEDURE'S INDEX IF JOB DEVICE
	CAIL Q,MXVAL	;SKIP IF IN USETL TABLE
	JRST AUSET2	;ABOVE USETL TABLE, MUST BE IOC, IOS, IOP, OR ILLEGAL
	LDB D,USETBT(I)	;GET METHOD BITS
	SOJL D,ILUUO	;JUMP IF ILLEGAL
	SOJL D,AUSVAR	;JUMP IF SIMPLE VARIABLE READ/SET
	LDB C,USETRL(D)	;GER ADDRESS OF ROUTINE
	XCTR XR,[MOVE D,(J)]	;GET CONTENTS OF USERS LOC (USEFUL IF SETTING VAR)
	JRST (C)	;TRANSFER TO ROUTINE

AUSVAR:	LDB C,USETRL+1	;GET ADDRESS OF VARIBLE
	ADD C,[USRSTG(A)]		;INDEX BY AC WITH USER INDEX
	XCTR XR,[MOVE B,(J)]	;GET USERS LOC
	TRNN I,2	;SKIP IF SETTING
	MOVE B,@C	;GET VAR
	TRNE I,2	;SKIP IF READING (FLUSHING THIS INST. CAUSES TIMING ERRS)
	MOVEM B,@C	;SET VAR
	TRNN I,2	;ALLOW READING FROM PURE PAGE
	XCTR XW,[MOVEM B,(J)]	;SET USERS LOC
	POPJ P,

PDPPMT:	CAIE Q,12	;SKIP IF READING MEM BOUND
	POPJ P,	;IGNORE OTHERWISE
	MOVEI A,40000	;FIXED MEM BOUND FOR PDP-10
	JRST APTUAJ

AUSET2:	TRNE I,2
	JRST ILUUO	;JUMP IF TRYING TO WRITE
	SUBI Q,100
	JUMPL Q,ILUUO	;ERROR IF MXVAL<Q<100
	CAIL Q,40
	JRST AUSET4	;>140=>.RIOP+M
	TRZE Q,20
	JRST AUSET3	;117<Q<140=>.RIOS+M
	ADDI Q,IOCHNM(A)	;77<Q<120=>.RIOC+M
AUSETX:	MOVE A,(Q)	;GET VAR
APTUAJ:	XCTR XW,[MOVEM A,(J)]	;GIVE TO USER
	POPJ P,

AUSET3:	MOVE R,A	;INFERIOR USER INDEX
	ADDI R,IOCHNM(Q)	;GET CHANNEL POINTER
	MOVE C,J	;CAUSE STATUS TO BE READ INTO (J)
	HRRZ B,(R)	;GET INDEX IN CH WHOSE STATUS IS BEING EXAMINED
	JRST ASTAT1	;DO A .STATUS

AUSET4:	CAIL Q,40+LUIOP	;COMPARE AGAINST LAST IO PDL LOC
	JRST AUSET5	;READ MAP ENTRY
	ADDI Q,SIOCHN-40(A)	;MAKE UP POINTER TO VAR
	JRST AUSETX

STDUUO:	HRRZ C,40	;TEMP	;CALLED BY AUSET,ASTATUS,AACCESS
	ADDI R,IOCHNM(U)	;R POINTS TO IO CHANNEL WORD REFERENCED BY UUO'S AC FIELD
	HLRZ A,(R)	;A IS THE LEFT HALF OF IOC WORD
	HRRZ B,(R)	;B IS RIGHT HALF AND INDEX INTO IOTTB, ETC.
	POPJ P,		;C IS ABSOLUTE EQUIVALENT OF UUO'S EFFECTIVE ADDRESS

ABUSET:	TRNE Q,400000
	TLOE I,1	;SET BLOCK BIT
	JRST ILUUO	;BLOCK IN BLOCK LOSES
	XCTR XR,[MOVE Q,(C)]	;GET AOBJN PTR AGAIN
ABUST2:	XCTR XW,[MOVEM Q,(C)]	;STORE AWAY UPDATED POINTER
	PUSH P,B
	PUSH P,C
	PUSH P,A
	PUSH P,I
	MOVE C,Q
	PUSHJ P,ASUS2
	POP P,I
	POP P,A
	POP P,C
	POP P,B
	XCTR XR,[MOVE Q,(C)]
	AOBJN Q,ABUST2
	POPJ P,
;USET VARIABLE 200+N  --  READ MAP VARIABLE FOR PAGE N.
; (0 <= N < 400)

;VALUE OF MAP WORD READ:

;4.9  -  PAGE WRITEABLE.
;4.8  -  PAGE EXISTS (IF THIS OFF, WHOLE WORD IS 0)
;4.7  -  PAGE IS IN CORE.
;4.6  -  PAGE IS PUBLIC (ANYONE CAN WRITE IT)

;3.1 - 3.9  -  # TIMES PAGE SHARED (LIKE CORTYP'S 4TH VALUE'S RH)
;2.1 - 2.9  -  ABS PAGE # OR PAGE # IN NEXT SHARER
;		(LIKE CORTYP'S 3RD VALUE)
;1.1 - 1.9  -  0 => ABS PAGE  (OR NO PAGE, OF COURSE)
;		-1 => UNSHARED PAGE,
;		ELSE USR NUM. OF NEXT SHARER.

AUSET5:	CAIG Q,600-100
	CAIGE Q,200-100
	JRST ILUUO	;PAGE NUM. OUT OF RANGE.
	PUSHJ P,SWTL
	CIRPSW		;DON'T LET PAGE TABLES CHANGE.
	PUSH P,J
	MOVEI J,(A)	;USER IDX OF JOB TO EXAMINE.
	MOVEI A,-100(Q)	;PAGE NUMBER IN JOB.
	PUSHJ P,NCORT0	;PUT CORTYP'S VALUES IN A THRU D.
	PUSHJ P,LSWPOP	;FREE CIRPSW.
	ANDI B,777	;CORTYP'S 2ND VALUE IN 1.1 - 1.9
	DPB C,[111100,,B]	;3RD VALUE IN 2.1 - 2.9
	TLO B,(D)	;VTH VALUE RH INTO 3.1-3.9
	LSH D,-20.
	TLO B,(D)	;4TH VAL BITS 4.8-4.9 INTO 4.6-4.7
	IOR A,B		;TOGETHER WITH 1ST VALUE'S 4.8, 4.9.
	POP P,J
	JRST APTUAJ
USETBT:	420200,,USETL(Q)	;BYTE POINTER TO UENTRY FIELD A
	400200,,USETL(Q)	; " B
	200200,,USETL(Q)	; " C
	160200,,USETL(Q)	; " D

USETRL:	221600,,USETL(Q)	;BYTE POINTER TO UENTRY FIELD E
	001600,,USETL(Q)	; " F

;IN EACH UENTRY ENTRY:	A IS THE METHOD FOR USET READ
;			B IS THE METHOD FOR SUSET READ
;			C IS THE METHOD FOR USET SET
;			D IS THE METHOD FOR SUSET SET
;			E & F ARE USED BY THE METHODS AS LISTED BELOW
;METHOD 0 = ILLEGAL MODE
;METHOD 1 = USE F AS RELATIVE LOC OF VAR
;METHOD 2 = USE E AS ROUTINE TO TRANSFER TO
;METHOD 3 = USE F AS ROUTINE TO TRANSFER TO

DEFINE UENTRY A,B,C,D,E,F
	A_20+B_16+E,,C_20+D_16+F
	IF2 [
	IFN 777774&<A\B\C\D>,[PRINTX /UENTRY A,B,C,D TOO BIG
/]	IFN 740000&<E\F>,[PRINTX /UENTRY E,F TOO BIG
/]	IFSE [E!F],[PRINTX /UENTRY E,F NULL
/]	]
	TERMIN

USETL:	UENTRY 1,1,2,0,UPCSET,UPC-USRSTG
	UENTRY 1,1,1,1,,VALUE-USRSTG
	UENTRY 1,1,0,0,,TTYTBL-USRSTG
	UENTRY 1,0,0,0,,FLSINS-USRSTG
	UENTRY 1,1,0,0,,UNAME-USRSTG
	UENTRY 1,1,2,0,UJNAME,JNAME-USRSTG
	UENTRY 1,1,2,2,USTMS,MSKST-USRSTG
	UENTRY 1,0,2,0,USTOP,USTP-USRSTG

	UENTRY 1,1,1,1,,PIRQC-USRSTG
	UENTRY 2,2,0,0,UGSUPR,
	UENTRY 1,1,2,2,URMEMT,HUSRAD-USRSTG
	UENTRY 1,1,0,0,,SV40-USRSTG
REPEAT 2,UENTRY 1,1,2,2,IAPIRQ,PIRQC-USRSTG
	UENTRY 1,1,2,2,USYNST,USYSNM-USRSTG
	UENTRY 1,1,2,2,UPISET,PICLR-USRSTG

	UENTRY 2,2,3,3,URMAR,USMAR
	UENTRY 1,1,1,1,,UMARPC-USRSTG
	UENTRY 1,1,0,0,,SUUOH-USRSTG
	UENTRY 2,2,0,0,UINDEX,
	UENTRY 1,2,0,0,UTRNTR,UTRNTM-USRSTG
	UENTRY 1,1,1,1,,MSKST2-USRSTG
	UENTRY 1,1,1,1,,IFPIR-USRSTG
	UENTRY 1,1,0,0,,APRC-USRSTG

	UENTRY 1,1,0,0,,SV60-USRSTG
	UENTRY 2,0,3,0,RUTRAP,SUTRAP
REPEAT 2,UENTRY 1,1,2,2,IAIFPI,IFPIR-USRSTG
REPEAT 2,UENTRY 1,1,2,2,IAMASK,MSKST-USRSTG
REPEAT 2,UENTRY 1,1,2,2,IAMSK2,MSKST2-USRSTG

	UENTRY 1,1,2,2,UJPCS,UPGML-USRSTG,	;JPC
	UENTRY 2,2,0,0,UROPC,	;OPC
	UENTRY 1,1,1,1,,RTIMER-USRSTG
	UENTRY 1,1,1,1,,S60H-USRSTG
	UENTRY 2,2,3,3,RUBCHN,SUBCHN,	;BCHN
	UENTRY 2,2,0,0,MPVARD	;MPVA
REPEAT 2,UENTRY 1,1,2,2,IIDF1,IDF1-USRSTG	;.IDF1, .ADF1

REPEAT 2,UENTRY 1,1,2,2,IIDF2,IDF2-USRSTG	;.IDF2, .ADF2
	UENTRY 1,1,2,2,USIDF1,IDF1-USRSTG	;.DF1
	UENTRY 1,1,2,2,USIDF2,IDF2-USRSTG	;.DF2
	UENTRY 1,1,1,1,,OPTION-USRSTG	;.OPTION
	UENTRY 1,1,1,1,,40ADDR-USRSTG	;.40ADDR

MXVAL==.-USETL

USTOP:	JUMPN D,1USTOP	;FOR ANY NONZERO VALUE
	SKIPN NMPGS(A)
	POPJ P,
	JRST 1USTRT
1USTOP:	MOVNI D,1	;SET TO STOP
1USTRT:	PUSHJ P,RPCLSR	;STOP USER IN A
	DPB D,[410100,,USTP(A)]	;BUSRC
	JRST UPCLSR

;SET INFERIOR'S PC
UPCSET:	PUSHJ P,RPCLSR	;STOP USER IN USER MODE
	TLO D,LSRMOD	;BE SURE USER MODE IS ON IN NEW PC
	TLZ D,BADPC	;BE SURE PRIVILEGED BITS ARE OFF
	SKIPGE IOTLSR(A)	;SKIP UNLESS USER IS SUPPOSED TO BE IN IOT-USER MODE
	TLO D,IOTFLG	;TURN ON IOT-USER MODE
	MOVEM D,UPC(A)	;SET PC
	JRST UPCLSR	;RESTART

;READ MAR
URMAR:	MOVE D,UPGML+2(A)
	TLZ D,777770
DPUTDJ:	XCTR XW,[MOVEM D,(J)]	;GIVE TO USER
	POPJ P,

;SET MAR
USMAR:	CONO PI,CLKOFF	;TURN OFF CLOCK INTERRUPTS
	CAMN A,USER
	SPM UPGML(A)	;STORE PG VARIABLES IF HACKING CURRENT USER
	TLZ D,777770
	TLO D,4	;SET USER MODE
	MOVEM D,UPGML+2(A)
	CAMN A,USER
	LPM UPGML(A)
	JRST CLKONJ

UJPCS:	HRRM D,UPGML(A)
	POPJ P,

UROPC:	HLLZ D,UPGML+1(A)
	LSH D,5
	HRR D,UPGML+1(A)
	JRST DPUTDJ

UINDEX:	IDIVI A,LUBLK	;GET INDEX NUMBER
	JRST APTUAJ	;GIVE TO USER

;READ OWN RUN TIME
UTRNTR:	CONO PI,CLKOFF
	SPM UPGML(U)
	LDB D,[2300,,UPGML+3(U)]
	LSH D,-2
	ADD D,UTRNTM(A)
	CONO PI,CLKON
	JRST DPUTDJ

UJNAME:	JUMPE D,ILUUO	;SET INFERIOR'S JNAME
	PUSHJ P,RPCLSR
	PUSHJ P,UJNAMU	;IS NEW JNAME UNIQUE?
	JRST UJNAMG	;NO
	MOVEM D,JNAME(A)	;YES
	CONO PI,CLKON
	JRST UPCLSR

UJNAMU:	MOVE B,UNAME(A)
	MOVEI E,0
	CONO PI,CLKOFF
UJNAM1:	CAME B,UNAME(E)
	JRST UJNAMF
	CAMN D,JNAME(E)
	POPJ P,
UJNAMF:	ADDI E,LUBLK
	CAMGE E,USRHI
	JRST UJNAM1
	JRST POPJ1

UJNAMG:	PUSHJ P,UPCLSR
	CAME A,E
	JRST ILUUO
	JRST CLKONJ

RUTRAP:	LDB D,[430100,,UTRAPM(A)]	;GET SPECIAL TRAP MODE INDICATOR
	JRST DPUTDJ

SUTRAP:	DPB D,[430100,,UTRAPM(A)]	;SET    "     "    "       "
	POPJ P,

;SET MEMORY BOUND
URMEMT:	CAMN U,A
	JRST URMEM2
	PUSHJ P,RPCLSR
	MOVSI B,BSSTP
	IORM B,USTP(A)
	PUSHJ P,UPCLSR
URMEM2:	ADDI D,1777
	LSH D,-10.
	MOVE B,D
	PUSH P,A
	PUSHJ P,FINSET
	UXRSTR
	EXCH U,A
	PUSHJ P,ACORE
	JFCL
	PUSHJ P,LSWDEL
	SUB P,[1,,1]
	EXCH U,A
URMEM1:	CAMN U,A
	POPJ P,
	MOVSI TT,BSSTP
	ANDCAM TT,USTP(A)
	POPJ P,

UXRSTR:	POP P,A
	MOVE U,USER
	JRST URMEM1

;SET SYSTEM NAME (ZERO IGNORED)
USYNST:	SKIPE D
	MOVEM D,USYSNM(A)
	POPJ P,

;SET INFERIOR'S INTERRUPT MASK
USTMS:	TRZ D,VBDBTS	;TURN OFF BITS WHOSE ENABLEMENT IS PROHIBITED
	MOVEM D,MSKST(A)	;SET MASK
USTMS2:	MOVEI B,440+APRCHN
	TRNE D,AROIF
	TRC B,60
	TLNE D,(ARFOIF)
	TRC B,600
	HRRM B,APRC(A)
	TRNE I,1
	CONO @APRC(A)
	POPJ P,

USTMS1:	POP P,A
	MOVE D,MSKST(A)
	JRST USTMS2

;SET INFERIOR'S PI IN PROGRESS FLAG
UPISET:	ASH D,-35.	;SHIFT SIGN BIT TO BOTTOM BIT
	MOVEM D,PICLR(A)	;SET VARIABLE
	SKIPE D	;SKIP IF INTS DISABLED
IIDFA:	TRNN I,1	;SKIP IF AN SUSET
	POPJ P,
	JRST APISE1	;SEE IF SHOULD REINTERRUPT

;SET .DF1
USIDF1:	SKIPA Q,[2]	;2 FOR SETTING,
IIDF1:	ANDI Q,1	;0 FOR IORM, 1 FOR ANDCAM.
	MOVEI B,IDF1(A)	;ADDR OF VARIABLE.
IIDF2A:	XCT (Q)[IORM D,(B)
		ANDCAM D,(B)
		MOVEM D,(B)]	;CHANGE THE VARIABLE.
	SKIPE PICLR(A)
	JRST IIDFA	;CHECK FOR NO-LONGER-DEFERRED INTS.
	POPJ P,

;SET .DF2 VARIABLE.
USIDF2:	SKIPA Q,[2]
IIDF2:	ANDI Q,1
	MOVEI B,IDF2(A)
	JRST IIDF2A	;JUST AS FOR IDF1.

;GET INT BIT
UGSUPR:	HLLZ D,SUPPRO(A)
	JRST DPUTDJ

IAMASK:	TRZ D,VBDBTS	;DON'T SET MASK BITS FOR CLASS 1
	PUSH P,A
	PUSH P,[USTMS1]	;MAKE SURE UPDATE APRL AFTERWARD
	ADDI A,MSKST-MSKST2	;ADJUST VAR PNTR
IAMSK2:	ADDI A,MSKST2-PIRQC	;"
IAPIRQ:	ADDI A,PIRQC-IFPIR	;"
IAIFPI:	ANDI Q,1	;GET USET PARITY (0=IORM, 1=ANDCAM)
	XCT IAINS(Q)	;DO APPRO OP
	POPJ P,

IAINS:	IORB D,IFPIR(A)	;SET BITS
	ANDCAB D,IFPIR(A)	;FLUSH BITS

;.RBCHN, .SBCHN  READ/SET NUMBER OF LAST CHANNEL ON WHICH ERROR OCCURRED
RUBCHN:	EXCH A,U	;CROCK
	LDB D,[BCHPTR]	;READ CHNL NUMBER
	EXCH A,U
	JRST DPUTDJ

SUBCHN:	EXCH A,U
	DPB D,[BCHPTR]	;SET CHNL NUMBER
	EXCH A,U
	POPJ P,

;MA (HIGH BITS) ON LAST MPV OR WIRO
;SET UP, CALLED FROM CLKBRK, DONT CLOBBER A OR D

MPVMAS:	HLRZ T,UPGML(U)
	LSH T,10.
	HRRM T,IOTLSR(U)
	POPJ P,

;.RMPVA READ VIRTURAL PAGE # (8 BITS) OF LAST MPV OR WIRO

MPVARD:	HRRZ D,IOTLSR(A)
	JRST DPUTDJ

;USER INSTRUCTION HANG ROUTINE
;DOESN'T WORK FOR SWAPPED OUT USER MEMORY, BUT LEAVE IN FOR DEMON
	;TO HANG ON EXEC CORE NEVER SWAPPED OUT

AHANG:	MOVE A,UUOH
	XCTR XR,[MOVE A,-2(A)]	;GET USER'S FLUSH INSTRUCTION
AHANG7:	LDB C,[360600,,A]	;PICK UP FIRST TWO DIGITS OF OP CODE
	CAIE C,CAM_-36	;CHECK FOR CAMX INSTRUCTIONS
	CAIN C,TDN_-36	;CHECK FOR TDNX AND TSNX INSTRUCTIONS
	JRST AHANG6	;CAMX, TDNX, OR TSNX, SET UP AC
	CAIE C,SKIP_-36	;NOW CHECK FOR SKIPX (BUT NOT AOS OR SOS, THOSE ILLEGAL)
	JRST AHANG2	;NONE OF THESE, MAYBE XCT OR CONSX
	LDB C,[331100,,A]
	CAIN C,SKIP_-33
	JRST AHANG8	;SKIP ... LONG HANG
	TLNE A,740
	JRST ILUUO	;SKIP INSTRUCTION, BUT WITH NON-ZERO AC FIELD, ILLEGAL
AHANG1:	MOVE R,A
	PUSHJ P,ASCIND	;PERFORM ADDRESS CALC
	MOVEM R,EPDL(U)
	TLC R,(XCT)
	TLNN R,777000
	JRST AHANG5	;XCT
	PCLT
	JRST .+2
	PUSHJ P,UHANG
	PUSHJ P,UFLS
	POPJ P,

AHANG8:	MOVSI A,(SETZ)
	IORM A,USWST(U)	;DESIRED OUT
	JFCL
	PUSHJ P,UFLS	;LONG LONG HANG
	JRST 4,.

AHANG2:	LDB B,[331100,,A]	;PICK UP OP CODE
	CAIN B,XCT_-33
	JRST AHANG1	;XCT
	CAIN B,JFCL_-33
	JRST AHANG8	;JFCL ... LONG HANG
	HLRZ C,A
	TRZ C,077477
	CAIE C,(CONSZ\CONSO)
	JRST ILUUO
	JRST AHANG1

AHANG5:	PUSHJ P,OPBRK	;EFFECTIVE ADDRESS CALCULATED, BUT INSTR IS XCT
	XCTR XR,[MOVE A,(R)]
	JRST AHANG7

AHANG6:	LDB B,[270400,,A]	;LEGITIMATE MEMORY REFERENCE INSTR WANTS AC SET UP
	XCTR XR,[MOVE T,(B)]	;GET CONTENTS OF AC FROM USER
	TLZ A,(0 17,)	;CLEAR OUT AC FIELD IN INSTR
	TLO A,(0 T,)	;REPLACE AC FIELD IN INSTR WITH T
	JRST AHANG1

	;.HANG FLUSH INSTRUCTION ROUTINE, CALLED WITH PUSHJ ONLY ON CLOCK LEVEL

UHANG:	LPMR UPGML(U)
	MOVE TT,EPDL(U)
	XCTR XRWI,[SKIP (TT)]	;REFERENCE LOCATION
	JRST UHANG1	;NOT SWAPPED OUT OR MISSING
	MOVNI B,2	;BACK UP TO INSTRUCTION BEFORE .HANG
	ADDM B,SUUOH(U)
	SETZM FLSINS(U)
	JRST POPJ1

UHANG1:	XCTR XRW,TT
	POPJ P,
	JRST POPJ1

;ALLOW INT IF BEING PCLSRED
OPBRK:	PUSH P,T
	MOVE T,UEXIT
	CAMN T,[JRST ONEFLS]
	PUSHJ P,UDELAY
	POP P,T
	POPJ P,
;
;.FDELE FILBLK	;DELETE OR RENAME FILE SPECIFIED AT FILBLK
;
AFDELE:	HRRZ C,40	;TEMP
	SETZM UUAC(U)
	XCTR XR,[MOVE A,(C)]	;GET DEVICE
	MOVEI W,4
	DPB W,[OPNCOM,,A]	;SET OP TO SPECIFY AN .FDELE
	JRST AFDEL1
;
;OPEN SET UP AND DISPATCH
;3.1=0 => INPUT  =1 OUTPUT
;3.2=0  => UNITS   =1  BLOCK
;3.3=0  => ASCII   =1 IMAGE
;4.9-4.7 OPERATION FIELD
;   0=> NORMAL READ OR WRITE
;   1=> WRITE OVER MODE
;   2=> MAKE LINK
;   3=> "COPY OVER" MODE
;   4=> DELETE OR RENAME (INTERNAL)
;
;.OPEN CH,FILBLK	;OPEN FILE SPECIFIED AT FILBLK ON LOGICAL CHANNEL CH
;
AOPEN:	MOVE C,OPTION(U)
	TLNE C,OPTDEC
	JRST USRUUO
	HRRZ C,40	;TEMP
		;C HAS EFF ADR OF UUO AND R ITS AC FIELD
	ADDI R,IOCHNM(U)	;MAKE R POINT TO SPECIFIED I/O CHANNEL WORD
	PUSH P,C
	PUSHJ P,ACLOSE	;CLOSE PREV
	POP P,C
	XCTR XR,[MOVE A,(C)]	;GET DEV AND MODE BITS
	LDB W,[OPNCOM,,A]
	CAIN W,4
	JRST OPNL23	;BARF IF TRY TO DELETE WITH .OPEN
AFDEL1:	MOVEI TT,SRN3(U)	;MOVE 4TH-6HT ARGS
	HRLI TT,3(C)		;TO SRN3 THRU SRN5
	MOVEI Q,3(TT)
	XCTR XR,[BLT TT,-1(Q)]
	XCTR XR,[MOVE B,1(C)]	;GET 2ND, 3RG ARGS (FILENAMES)
	XCTR XR,[MOVE C,2(C)]
	MOVE D,USYSNM(U)	;USE DEFAULT SNAME.
	HLRZ E,A		;GET MODE BITS.
	HRLZI A,(A)	;LEFT-JUSTIFY DEVICE NAME.
NOPNE:	CAIN W,4	;SKIP ON NOT .FDELE (ENTRY FOR NCALL TYPE OPEN, ETC COMMANDS)
	SKIPN SRN3(U)	;SKIP ON RENAME
	JRST AOPEN3	;JUMP IF A .OPEN OR DELETING .FDELE
	JUMPN B,AOPEN3	;JUMP UNLESS RENAME WHILE OPEN.
	MOVE TT,C	;GET CH ON WHICH FILE IS SUPPOSIDLY OPEN
	TDNE TT,[-1,,777760]	;SKIP IF CH LOGICALLY LESS THAN 20
	JRST OPNL14	;BAD CHANNEL NUM
	ADDI TT,IOCHNM(U)	;RELOCATE TO POINT TO CH WORD FOR USER
	MOVE Q,(TT)	;GET CH WORD
	HLRZ Q,CLSTB(Q)	;GET LEFT HALF OF CLOSE TABLE ENTRY FOR INDEX IN I/O CH WORD
	TRNE Q,40
	JRST JFDEL4	;JOB WRITE CHNL
	TRNN Q,202000	;SKIP IF A DIRECTORY DEVICE
	JRST POPJ1	;JUMP IF NOT DIRECTORY DEVICE
	HLRZ J,(TT)	;PICK UP DEV CHNL NO
	EXCH A,B	;PUT FN1, FN2 IN A, B.
	EXCH B,C
	TRNN Q,200000	;SKIP IF DEC TAPE
	JRST NOPNE1
	MOVEI C,(SIXBIT/UT0/)	;GET DUMMY UT DEV NAME.
	HRRZ I,UTTNO(J)	;GET POSSIBLE TAPE NUM
	DPB I,[300,,C]	;STORE IN DEV NAME
	PUSH P,[UTO]	;WILL EXIT TO UTAPE OPEN RTN.
	JRST NOPNE2
NOPNE1:	MOVEI C,(SIXBIT/DSK/)	;NOT UT, MUST BE DSK.
	PUSH P,[QSKO]	;NOBODY ELSE HANDLES RENAME WHILE OPEN.
NOPNE2:	HRLI C,(E)	;RE-INSERT MODE BITS.
	MOVEI E,1	;DIRECTORY DEVICE
	JRST OPEN2B

AOPEN3:	PUSHJ P,TRAN	;PERFORM I/O TRANSLATIONS
	JRST OPNL3	;TOO MANY TRANSLATIONS.
	MOVEM D,USYSN1(U)	;SAVE TRAN'D SNAME FOR OPEN RTN.
	HLRZS A		;DEV. INTO RH.
	HRLI A,(E)	;REINSERT MODE BITS.
	PUSH P,A	;PUT NAMES ON STACK.
	PUSH P,B
	PUSH P,C
	MOVSI B,-NDEVS	;LOAD LENGTH OF FIRST DEV NAME TABLE
	HRRZ C,DEVTAB(B)	;GET DEVNAM POINTED AT BY COUNT
	CAIE C,(A)	;SKIP IF EQUAL
	AOBJN B,.-2	;LOOP TILL FOUND OR COUNTED OUT
	JUMPG B,OPEN1	;JUMP IF NOT FOUND
OPEN2:	LDB C,[400100,,DEVTAB(B)]	;<IGNORE DELETE> BIT
	CAIN W,4
	JUMPN C,OPEN2C	;IGNORE DELETE
	MOVSI C,400000	;PICK UP INPUT BIT FOR DEVTAB
	TLNE A,1	;SKIP IF INPUT MODE SPECIFIED
	MOVSI C,200000	;PICK UP OUPUT BIT FOR DEVTAB
	TDNN C,DEVTAB(B)	;SKIP IF REQUESTED MODE IS ALLOWED
	JRST LCDIY	;IO DEVICE DOESN'T GO THAT WAY
	HLRZ C,DEVTAB(B)	;GET LEFT HALF OF DEVTAB ENTRY (POINTS TO ROUTINE)
	LDB E,[410100,,DEVTAB(B)]	;GET DIR DEV BIT
	HRRZ C,DEVADR(B)
OPEN2A:	POP P,B		;UNSAVE SECOND FILE NAME
	POP P,A		;UNSAVE FIRST FILE NAME
	EXCH C,(P)	;EXCHANGE <MODE BITS,,DEV> AND .OPEN ROUTINE POINTER
OPEN2B:	HLRZ D,C	;GET MODE BITS IN R.H. OF D
;
;AT THIS POINT:	;A & B HAVE FILE NAMES, C HAS MAPPED DEV AND MODE BITS
;W HAS OPEN COMMAND
	ROT D,-1	;ROTATE IN/OUT BIT TO SIGN
	CAIN W,4	;SKIP IF NOT A .FDELE
	TDZ D,[400000,,7]	;A .FDELE, MAKE LOOK LIKE OPEN FOR READ
	PUSHJ P,FLDRCK
	POPJ P,		;POPJ TO .OPEN ROUTINE
	JUMPN E,CPOPJ	;DIR DEVICE, POPJ TO .OPEN ROUTINE
;DIR READ BUT NOT DIR DEVICE, GIVE USER AN APPROPRIATE ASCII STRING
	SUB P,[1,,1]	;SUBTRACT OFF .OPEN ROUTINE POINTER ON PDL
DIRNDV:	TRNE D,2	;SKIP ON ASCII MODE
	JRST OPNL12	;IMAGE MODE, GIVE MODE NOT AVAILABLE ERR
	MOVEI J,1	;SET UP LISTFE ARG
	MOVE I,U	; "
	JRST LISTFE	;GO TO "FILE DIRECTORY LIST" ROUTINES

OPEN2C:	SUB P,[3,,3]	;IGNORE FDELE
	JRST POPJ1

	;CHECK FOR NUMBERED DEV
OPEN1:	MOVE B,[-NDV1,,DVT1-DEVTAB]	;LOAD AOBJN POINTER WITH COUNT FOR 2ND DEV TABLE
OPEN1A:	MOVEI I,0		;INITIALIZE NUMBERED DEV NUM TO ZERO
	MOVE D,[220600,,-2(P)]	;GET BYTE POINTER INTO DEV REQUESTED
	MOVE E,[220600,,DEVTAB(B)]	;GET BYTE POINTER INTO CURRENT TABLE ENTRY
OPENA1:	ILDB A,E	;GET CHAR FROM TABLE
	ILDB J,D	;GET CHAR FROM DEV
	JUMPE A,OPEN1B	;JUMP ON SPACE IN TABLE, "MATCHES" DIGIT IN DEV
	CAIN A,(J)	;SKIP IF CHAR DIFFER
	JRST OPEN1C	;SAME, TRY FOR NEXT CHAR
OPENZ1:	AOBJN B,OPEN1A	;LOOP TO NEXT TABLE ENTRY OR COUNT OUT
	JRST NSD	;DEV NOT IN EITHER TABLE, GIVE NO SUCH DEVICE ERR

OPEN1B:	SUBI J,'0	;CONVERT SIXBIT DIGIT TO NUMBER
	JUMPL J,OPENZ1	;JUMP IF TO SMALL, NOT A DIGIT
	CAILE J,9	;SKIP IF LESS THAN 10.
	JRST OPENZ1	;LOSE, TRY NEXT
	ASH I,3		;MULTIPLY NUM SO FAR BY 8
	ADD I,J		;ADD NEW DIGIT
OPEN1C:	TLNE D,770000	;SKIP IF ALL THREE CHAR POSITIONS COMPARED
	JRST OPENA1	;GO TO NEXT POSITION
	MOVE A,-2(P)	;RESTORE A
	JRST OPEN2

AOPEN5:	SUB P,[3,,3]	;RESTORE PDL PNTR
	POPJ P,		;RETURN
NOPEN:	HRRZ R,A	;ARGS 1 MODE (LH) CHNL (RH) 2-5 LIKE NOPEN1 1-4
	CAILE R,17
	JRST OPNL14
	ADDI R,IOCHNM(U)
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSH P,E
	PUSH P,W
	PUSHJ P,ACLOSE
	POP P,W
	SOS W	;STRIP OF FIRST ARG
	POP P,D	;B-E POPPED INTO A-D
	POP P,C
	POP P,B
	POP P,A
	POP P,R	;A POPPED INTO R
	TLC R,@CTLBTS(U)
	LDB E,[OPNCOM,,R]
	CAIE E,2
	CAIN E,4
	JRST OPNL12	;COMMAND CANT BE LINK OR FDELE FOR "NEW" CALL
NDEL1:	JSP T,NOPEN1
	CLEARM SRN3(U)
	CLEARM SRN4(U)
NRN2:	CLEARM SRN5(U)
NOPENX:	HRRZM R,UUAC(U)	;CHNL # (MAYBE ONLY FOR ERRS) IN R
	ADDI R,IOCHNM(U)
	LDB W,[OPNCOM,,R]
	JRST NOPNE

;DEFAULT THE ARGS FOR .CALL OPEN, ETC,; PUT MODE IN E.
NOPEN1:	CAIGE W,2
	MOVSI B,(SIXBIT /@/)
	CAIGE W,3
	MOVSI C,(SIXBIT /@/)
	CAIGE W,4
	MOVE D,USYSNM(U)	;SYSTEM NAME
	HLRZ E,R	;GET MODE BITS FOR TRAN.
	JRST (T)

;MAKE LINK 1-4 AS NOPEN1, 5 SNAME 2 6,7 FN1,2(2)
NMLINK:	MOVEM E,SRN3(U)
	MOVEM TT,SRN4(U)
	MOVEM I,SRN5(U)
	MOVSI R,200000
	JSP T,NOPEN1
	JRST NOPENX


NDEL:	MOVSI R,400000	;DELETE, ARGS AS NOPEN1
	JRST NDEL1

NRNAM:	MOVEM E,SRN3(U)
	MOVEM TT,SRN4(U)
	MOVSI R,400000	;RENAME 1-4 AS NOPEN1 5,6 NEW FN1,2
	JSP T,NOPEN1
	JRST NRN2

NRNWO:	MOVEM B,SRN3(U)	;PUT AWAY NEW NAMES.
	MOVEM C,SRN4(U)
	MOVEI C,(A)	;CHNL NUM IS "OLD FN2".
	SETZB A,B
	MOVEI D,0
	MOVSI R,400000	;OPNCOM IS .FDELE .
	MOVEI E,400000
	JRST NRN2

;HACKS FOR OPENS THAT LOSE
;
REPEAT NOPNLS,CONC OPNL,\.RPCNT+1,:	JSP D,OPENL
;
OPENL:	MOVE R,UUAC(U)	;GET CH NUM
	MOVE U,USER	;BE SURE U=CURRENT USER'S INDEX
	PUSHJ P,LSWCLR	;UNLOCK SWITCHES
	DPB R,[BCHPTR]	;SAVE AS MOST RECENT CHANNEL IN ERR
	ADD R,U		;RELOCATE TO POINT TO USER VARS
	SUBI D,OPNL1	;GET LOSSAGE NUM
	DPB D,[220600,,IOCHST(R)]	;STORE IN STATUS WORD
	JRST CLKONJ

NSD:	PUSHJ P,OPNL1	;SET I/O CH STATUS WORD TO INDICATE NO SUCH DEVICE
	JRST AOPEN5	;RETURN

LCDIY:	LDB E,[410100,,DEVTAB(B)]	;GET DIR BIT
	MOVEI C,OPNL2	;LOAD, AS .OPEN ROUTINE POINTER, THE ADR OF WRONG DIRECTION OPEN LOSE
	JRST OPEN2A	;WILL JUMP TO OPNL2 IF NOT READING ".FILE. (DIR)"

UNCA:	JUMPGE D,NCA
UTWNA:	SUB P,[2,,2]
NCA:	JRST OPNL10

UFILDF:	SUB P,[2,,2]
FILDF:	JRST OPNL5

S1NL14:	SUB P,[1,,1]
	JRST OPNL14

ARCHST:	XCTR XR,[MOVE J,(J)]
	HLRZ R,J	;CHNL IN LH OF AC+ IF UTAPE THEN TAPE NAME IN LH
	CAIL R,20	;SUPPLY SYM DEVICE IN AC(RH)
	JRST ILUUO
	ADDI R,IOCHNM(U)	;AC+1 GETS 0 IF NOT A FILE DEVICE
	HLRZ A,(R)	;ELSE AC+1 GETS FILE NAME 1
	HRRZ B,(R)	;AC+2 GETS FNM 2
	MOVE C,DCHSTB(B)	;AC+3 GETS SYS NAME OR 0 IF NOT APPLICABLE
	PUSH P,C	;AC+4(RH) GETS WORD ADR IN FILE OR -1 => NOT RANDOMLY ADDRESSABLE
	JRST (C)	;AC+4 (LH) GETS CHR BYTE PNTR IF IN CHR MODE

	;.RCHST USR ROUTINE
STUSR:	MOVE T,UNAME(A)	;GET UNAME
	XCTR XW,[MOVEM T,1(J)]
	MOVE T,JNAME(A)	;GET JNAME
	XCTR XW,[MOVEM T,2(J)]
	XCTR XRW,[SETZM 3(J)]	;SYSTEM NAME NOT APPLICABLE
	HRRZ T,IOCHST-IOCHNM(R)	;GET ACCESS POINTER
	XCTR XW,[MOVEM T,4(J)]
	JRST ARCHX

	;.RCHST UTAPE ROUTINE
STUTP:	HRRZ C,UTTNO(A)
	MOVEI B,(SIXBIT /UT0/)(C)
	CONO PI,CLKOFF
	MOVE T,UDIRO(C)	;GET ORIGIN OF DIRECTOR
	HRRZ T,177(T)
	CAIE T,-1
	HRL B,T	;NOT -1,GIVE HIM TAPE NAME OR 0 => NONE
	CONO PI,CLKON
	XCTR XRW,[MOVEM B,(J)]	;STORE DEVICE NAMES
	CAIGE A,NUTIC
	JRST STUTPI	;INPUT
	MOVE T,UTN1(A)	;OUTPUT, GET FN1
	XCTR XW,[MOVEM T,1(J)]
	MOVE T,UTN2(A)	;NOW FN2
	XCTR XW,[MOVEM T,2(J)]
	MOVE T,UTASS(C)	;GET ASSIGNMENT OR 0=>NONE
	XCTR XW,[MOVEM T,3(J)]	;STORE AS SYSTEM NAME OR 0=>N/A
	JRST SET4J	;INDICATE NOT RANDOM ACCESS, AND RETURN

	;UTAPE INPUT .RCHST
STUTPI:	LDB D,[220500,,UTDBC(A)]	;GET FILE NUMBER
	SUBI D,1
	LSH D,1	;TURN INTO INDEX INTO DIRECTORY
	CONO PI,CLKOFF
	ADD D,UDIRO(C)	;GET POINTER TO FILE NAMES
	MOVE T,(D)	;GET FN1
	MOVE TT,1(D)	;GET FN2
	CONO PI,CLKON
	XCTR XW,[MOVEM T,1(J)]	;STORE FN1
	XCTR XW,[MOVEM TT,2(J)]	;STORE FN2
	JRST SET34J

	;CORE LINK .RCHST ROUTINE
STCLO:	CONO PI,CLKOFF
	MOVE T,CLN1(A)	;GET FN1
	MOVE TT,CLN2(A)	;GET FN2
	MOVE D,CLSYN(A)	;GET SYSTEM NAME
	CONO PI,CLKON
	XCTR XW,[MOVEM T,1(J)]	;STORE FN1
	XCTR XW,[MOVEM TT,2(J)]	;STORE FN2
	XCTR XW,[MOVEM D,3(J)]	;STORE SYSTEM NAME
	JRST SET4J	;NOT RANDOMLY ACCESSIBLE

SNDDEV:	XCTR XW,[CLEARM 1(J)]	;NON DIRECTORY DEVICE
	XCTR XW,[CLEARM 2(J)]
SET34J:	XCTR XW,[SETZM 3(J)]
SET4J:	XCTR XW,[SETOM 4(J)]
ARCHX:	POP P,C
	XCTR XRW,[HLRZM C,(J)]
	POPJ P,

STQSK:	MOVE H,QUDPR(A)	;FILE STATUS FOR 2311 PICKUP USER DIR POINTER
	PUSHJ P,QUDLK	;LOCK DIRECTORY
	MOVE C,QSNLCN(H)	;LOCATION OF DIRECTORY
	MOVE D,2(C)	;DIR NAME
	ADD C,QUDFPR(A)	;ADD LOCN OF FILE WITHIN DIRECTORY
	MOVE Q,(C)	;GET FIRST FILE NAME
	MOVE I,1(C)	;GET SECOND FILE NAME
	MOVEI E,0	;PICK UP 0 IN CASE
	MOVSI TT,100
	TDNN TT,QSRAC(A)
	JRST STQSK3
	MOVE E,QRADAD(A)
	JRST STQSK4

STQSK3:	SKIPGE QSMDN(A)	;SKIP ON A BUFFER ACTIVE
	JRST STQSK2	;NO BUFFER ACTIVE, WILL READ FIRST WORD OF NEXT BLOCK
			;WHICH IS WHAT QFBLNO POINTS TO
	MOVE E,QAWMPB(A)	;NUMBER WDS IN CURRENT M.P. ACTIVE BUFFER
	HLLZ TT,QSMPRP(A)
	JUMPN TT,STQSK1	;JUMP ON CHR MODE
	SUB E,QSMPRC(A)	;SUBTRACT CURRENT REMAINING TO FIND NUM PASSED OVER
STQSK2:	ADD E,QFBLNO(A)	;ADD WORD ORG OF CURRENT BUFFER
STQSK4:	PUSHJ P,QUDULK
	XCTR XW,[MOVEM D,3(J)]
	XCTR XW,[MOVEM Q,1(J)]
	XCTR XW,[MOVEM I,2(J)]
	XCTR XW,[MOVEM E,4(J)]	;STORE ADDRESS IN FILE IN AC+4
	JRST ARCHX

STQSK1:	IMULI E,5	;CONVERT TO CHARACTERS ORIGINALLY IN BUFFER
	SUB E,QSMPRC(A)	;SUBTRACT CHRS LEFT GET CHARACTERS PASSED OVER
	IDIVI E,5	;GET WORD ADDRESS IN CURRENT BLOCK
	HLL E,QSMPRP(A)
	JRST STQSK2
;
;DISPATCH TABLE FOR .CLOSE UUO
;TRANSFERED THROUGH USING RIGHT HALF OF I/O CH WORD AS AN INDEX
;
CLSTB:	CPOPJ	;SYS CLOSETAB 4.9 USER DEVICE 4.8 UTAPE WRITE DEVICE
		;4.7 JOB DEVICE INPUT 4.6 UTAPE READ 4.5 TYI
		;4.4 CORLINK INPUT 4.3 BOJ DEVICE 4.2 2311 WRITE DEVICE 4.1 FOREIGN USER
		;3.9 STANDARD CLOSE 3.8 2311 DEVICE 3.7 PDP-10 DEVICE
		;3.6 JOB DEVICE OUTPUT
	REPEAT 2,20000,,TYICLS	;TYI
	REPEAT 2,TYOCLS	;TYO
	REPEAT 4,CPOPJ	;NULL
	REPEAT 4,SETZ CPOPJ	;USER
	REPEAT 2,1000,,CPOPJ	;FOREIGN USER
	40000,,UTICL	;UTAPE
	MOVE UTOCLR
	40000,,UTICL
	MOVE UTOCL
	40000,,UTICL
	MOVE UTOCL
IFN OLPTP,	REPEAT 2,LPTCLS	;LPT
IFN NLPTP,[
	NLPDCL
	NLPTCL
]
	REPEAT 4,UTDCLS	;DIRECTORY DEVICE
IFN VIDP,	REPEAT 2,NVDCLS	;NVIDI
IFN PLTP,	REPEAT 2,400,,PLTUSR	;PLOTTER
	REPEAT 5,400,,PTPUSR	;PAPER  TAPE PUNCH
IFN IMXP,	REPEAT 4,IMPXCL	;IMX
IFN OMXP,	REPEAT 4,OMPXCL	;OMX
	10000,,CLCLRU	;CORE LINK
	CLCLWU
	REPEAT 2,[10000,,CLCLRB
	CLCLWB
]	REPEAT 5,PTRCLS	;PAPER TAPE READER
IFN 340P,	REPEAT 5,ADCL1	;340
IFN CODP,	REPEAT 2,CODCLS		;CODE DEV
	200,,QICL	;2311
	2200,,QOCLR
	200,,QICL
	2200,,QOCL
	200,,QICL
	2200,,QOCL
IFN VIDP,	REPEAT 4,TVCCLS	;TVC
IFN PDP6P,	REPEAT 4,100,,PDPCLS	;USR IN PDP10 MODE
IFN TABP,	REPEAT 2,400,,TABUSR	;TABLET
IFN NMTCS,[REPEAT 3,MTICLS
	REPEAT 3,MTOCLS
]		;MAGTAPE
	REPEAT 3,[
	100000,,JOBCLS	;JOB DEVICE
	40,,JOBCLS
]
	REPEAT 6,4000,,BOJCLS	;BOJ
	[JRST 4,CPOPJ]	;INTERRUPT ON IOPOP DEVICE
	CPOPJ	;SPY
	REPEAT 2,[	;PSEUDO TTY
	STYICL
	STYOCL
]
IFN NETP,	REPEAT 4,NETCLS
IFN STKP,	STKCLS	;STANFORD KEYBOARD

IF2,[IFN .-CLSTB-LIOTTB,[PRINTX /BARF AT CLSTB
/]]

DCHSTB:	SNDDEV
	REPEAT 4,SIXBIT /TTY/+SNDDEV	;LH SIXBIT MAIN DEVICE RH ROUTINE TO GET REST OF .RCHST
	REPEAT 4,SIXBIT /NUL/+SNDDEV
	REPEAT 6,SIXBIT /USR/+STUSR	;FOREIGN USER
	REPEAT 6,SIXBIT /UT/+STUTP
IFG LPTP-1,	REPEAT 2,SIXBIT /OLP/+SNDDEV
IFN LPTP,	REPEAT 2,SIXBIT /LPT/+SNDDEV
	REPEAT 4,SIXBIT /DIR/+SNDDEV
IFN VIDP,	REPEAT 2,SIXBIT /NVD/+SNDDEV
IFN PLTP,	REPEAT 2,SIXBIT /PLT/+SNDDEV
	REPEAT 5,SIXBIT /PTP/+SNDDEV
IFN IMXP,	REPEAT 4,SIXBIT /IMX/+SNDDEV
IFN OMXP,	REPEAT 4,SIXBIT /OMX/+SNDDEV
	REPEAT 6,SIXBIT /CLI/+STCLO
	REPEAT 5,SIXBIT /PTR/+SNDDEV
IFN 340P,	REPEAT 4,SIXBIT /DIS/+SNDDEV
IFN 340P,	SIXBIT /IDS/+SNDDEV
IFN CODP,	REPEAT 2,SIXBIT /COD/+SNDDEV
	REPEAT 6,SIXBIT /DSK/+STQSK
IFN VIDP,	REPEAT 4,SIXBIT /TVC/+SNDDEV
IFN PDP6P,	REPEAT 4,SIXBIT /PDP/+STUSR
IFN TABP,	REPEAT 2,SIXBIT /TAB/+SNDDEV
IFN NMTCS,REPEAT 6,SIXBIT /MT0/+SNDMTC
	REPEAT 6,SIXBIT /JOB/+SNDDEV
	REPEAT 6,SIXBIT /BOJ/+SNDDEV
	SIXBIT /IIP/+[JRST 4,CPOPJ]	;INTERRUPT ON IOPOP DEVICE
	SIXBIT /SPY/+SNDDEV
	REPEAT 4,SIXBIT /STY/+SNDDEV
IFN NETP,	REPEAT 4,SIXBIT /NET/+NETRCH
IFN STKP,	SIXBIT /STK/+SNDDEV

IF2,[IFN .-DCHSTB-LIOTTB,[PRINTX /BARF AT DCHSTB
/]]

DCHSTE==.-1	;END FOR GETSYS (CHDEVS)

;DISPATCH TABLE FOR .IOT UUO
;TRANSFERED THROUGH USING RIGHT HALF OF I/O CHANNEL WORD AS AN INDEX
;4.9 = 1 => BLOCK  = 0 => UNIT  (CURRENTLY USED FOR PEEK ONLY)
;4.8 = 1 => OUTPUT  = 0 => INPUT     "
;(MOVE=UO  TRN=BO  SETZ=BI)

IOTTB:	IOCER8
TYIDN==.-IOTTB	;TTY ENTRIES MUST BE COMPACT
	TYI
TYIBN==.-IOTTB
	SETZ TTYBI
TYODN==.-IOTTB
	MOVE TYO
TYOBN==.-IOTTB	;LAST TTY DEVICE
	TRN TTYBO
NLIDN==.-IOTTB
	NULI
NLBIDN==.-IOTTB
	SETZ NULBI
NLODN==.-IOTTB
	MOVE CPOPJ
NLBDN==.-IOTTB
	TRN NULBOD
UWIDN==.-IOTTB
	UWI
UWODN==.-IOTTB
	MOVE UWO
UBODN==.-IOTTB
	TRN UBO
UBIDN==.-IOTTB
	SETZ UBI
FUWIDN==.-IOTTB	;FOREIGN USER, CLSTB POSITIVE
	UWI
FUBIDN==.-IOTTB
	SETZ UBI
DNUACII==.-IOTTB
	UASCII
DNUACCO==.-IOTTB
	MOVE UASCCO
DNUBKI==.-IOTTB
	SETZ UBLKI
DNUBKO==.-IOTTB
	TRN UBLKO
DNUDTI==.-IOTTB
	UDATAI
DNUDTO==.-IOTTB
	MOVE UDATAO
IFN OLPTP,[
LPTDN==.-IOTTB
	MOVE PILPT1
LPTBN==.-IOTTB
	TRN BLPTO
]
IFN NLPTP,[
NLPTDN==.-IOTTB
	MOVE NLPT1
NLPTBN==.-IOTTB
	TRN BNLPTO
]
DIRCHN==.-IOTTB
	MOVE DIRCH
DIRBN==.-IOTTB
	TRN DIRB
NDATAI==.-IOTTB
	DDATAI
NBLKI==.-IOTTB
	SETZ DBLKI
IFN VIDP,[
NVIDOP==.-IOTTB
	NVIDIT
BNVIDO==.-IOTTB
	SETZ BNVIDI
]
IFN PLTP,[
PLTDN==.-IOTTB
	MOVE PLOT
PLTBN==.-IOTTB
	TRN BPLOT
]
PTPI==.-IOTTB
	MOVE PIPUN
PTPA==.-IOTTB
	MOVE APIPUN
PTPB==.-IOTTB
	TRN BPIPUN
PTPWA==.-IOTTB
	MOVE WAPIPN
PTPWB==.-IOTTB
	TRN WBPIPN
IFN IMXP,[
IMPXDN==.-IOTTB
	IMPXS
IMXDN==.-IOTTB
	IMPXS1
BIMXDN==.-IOTTB
	SETZ BIMXS1
BIMPXD==.-IOTTB
	SETZ BIMPXS
]
IFN OMXP,[
OMPXDN==.-IOTTB
	MOVE OMPXS
OMXDN==.-IOTTB
	MOVE OMXDS
BOMXDN==.-IOTTB
	TRN BOMXDS
BOMPXD==.-IOTTB
	TRN BOMPXS
]
DCLUAI==.-IOTTB
	CLUAI
DCLUAO==.-IOTTB
	MOVE CLUAO
DCLBI==.-IOTTB
	SETZ CLBI
DCLBO==.-IOTTB
	TRN CLBO
DCLUBI==.-IOTTB
	SETZ CLUBI
DCLUBO==.-IOTTB
	TRN CLUBO
REDUAI==.-IOTTB
	PTRUAI
REDBAI==.-IOTTB
	SETZ PTRBAI
REDUII==.-IOTTB
	PTRUII
REDBII==.-IOTTB
	SETZ PTRBII
REDUTI==.-IOTTB
	PTRUTI
IFN 340P,[
DN340B==.-IOTTB	;340 ENTRIES MUST BE COMPACT
	TRN 340B	;BLOCK FIRST THEN UNIT
DN340W==.-IOTTB
	MOVE 340W
DN340C==.-IOTTB
	MOVE 340C
DN340H==.-IOTTB
	MOVE 340H
DN340I==.-IOTTB	;LAST 340 DEVICE ENTRY
	MOVE 340I
]
IFN CODP,[
CODDN==.-IOTTB
	MOVE SEND
CODBN==.-IOTTB
	TRN BSEND
]
DQUAI==.-IOTTB
	QUAI
DQUAO==.-IOTTB
	MOVE QUAO
DQBI==.-IOTTB
	SETZ QBI
DQBO==.-IOTTB
	TRN QBO
DQUII==.-IOTTB
	QUII
DQUIO==.-IOTTB
	MOVE QUIO
IFN VIDP,[
DNVDIU==.-IOTTB
	RNVDIU
DNVDIB==.-IOTTB
	SETZ RNVDIB
DNVDOU==.-IOTTB
	MOVE RNVDOU
DNVDOB==.-IOTTB
	TRN RNVDOB
]
IFN PDP6P,[
PDPUIO==.-IOTTB
	MOVE UWO	;BUT JOB WILL BE -1 TO INDICATE PDP6
PDPBIO==.-IOTTB
	TRN UBO
PDPUII==.-IOTTB
	UWI
PDPBII==.-IOTTB
	SETZ UBI
]
IFN TABP,[
DTABUI==.-IOTTB
	UTABI
DTABBI==.-IOTTB
	SETZ BTABI
]
IFN NMTCS,[IRPS MODE,,[UAI UII BI UAO UIO BO]BITS,,[0 0 SETZ MOVE MOVE TRN]
MT!MODE!X==.-IOTTB
	BITS MT!MODE
TERMIN
]		;MAGTAPE
JDUAI==.-IOTTB
	JBUAI
JDUAO==.-IOTTB
	MOVE JBUAO
JDBI==.-IOTTB
	SETZ JBBI
JDBO==.-IOTTB
	TRN JBBO
JDUII==.-IOTTB
	JBUII
JDUIO==.-IOTTB
	MOVE JBUIO
BDUAI==.-IOTTB
	BJUAI
BDUAO==.-IOTTB
	MOVE BJUAO
BDBI==.-IOTTB
	SETZ BJBI
BDBO==.-IOTTB
	TRN BJBO
BDUII==.-IOTTB
	BJUII
BDUIO==.-IOTTB
	MOVE BJUIO
IIOPOP==.-IOTTB	;INTERRUPT ON IOPOP DEVICE
	[JRST 4,CPOPJ]
ISPY==.-IOTTB
	SPYI
STYDUI==.-IOTTB	;PSEUDO TTY
	STTYI
STYDUO==.-IOTTB
	MOVE STTYW
STYDBI==.-IOTTB
	SETZ STTBI
STYDBO==.-IOTTB
	TRN STTBO
IFN NETP,[
NETDUI==.-IOTTB
	NETI
NETDUO==.-IOTTB
	TRN NETW
NETDBI==.-IOTTB
	SETZ NETBI
NETDBO==.-IOTTB
	TRN NETBO
]
IFN STKP,[
STKDP==.-IOTTB
	STKI
]

LIOTTB==.-IOTTB

;.STATUS CH,LOC	;STORE IN LOC THE STATUS OF CHANNEL CH
		;AND OF THE DEV OPEN ON IT IF ANY
;
ASTATUS:	PUSHJ P,STDUUO	;SET UP AC'S
ASTAT1:	LDB D,[300600,,STATB(B)]	;PICK UP SYS PERIPHERAL DEV NUM IF PRESENT IN STATB
	PUSHJ P,@STATB(B)	;CALL ROUTINE TO COMPUTE DEVICE STATUS
	HLL D,IOCHST-IOCHNM(R)	;PICK UP CHANNEL STATUS
	TLZ D,740000	;TURN OFF BITS USED TO STORE CH NUM INFO ON I/O PDL
	XCTR XW,[MOVEM D,(C)]	;GIVE TO USER
	POPJ P,

STATB:	CPOPJ
REPEAT 2,STATYI
REPEAT 2,STATYO
REPEAT 4,SNNUL_6,,STDSTA
REPEAT 4,SNUSR_6,,CPOPJ
REPEAT 2,SNFUSR_6,,CPOPJ
REPEAT 6,SNUTC_6,,CPOPJ
IFN OLPTP,	REPEAT 2,SNLPD_6,,STALPT
IFN NLPTP,	REPEAT 2,SNLPV_6,,STDSTA
REPEAT 4,SNDIR_6,,CPOPJ
IFN VIDP,	REPEAT 2,SNBAT_6,,CPOPJ
IFN PLTP,	REPEAT 2,SNPLT_6,,STDSTA
REPEAT 5,SNPTP_6,,STDSTA
IFN IMXP,	REPEAT 4,SNIMPX_6,,STDSTA
IFN OMXP,	REPEAT 4,SNOMPX_6,,STDSTA
REPEAT 6,SNCLK_6,,STDSTA
REPEAT 5,SNPTR_6,,STDSTA
IFN 340P,	REPEAT 4,SN340_6,,CPOPJ
IFN 340P,	SN340I_6,,CPOPJ
IFN CODP,	REPEAT 2,SNCOD_6,,STDSTA	;CODE
REPEAT 6,SN2311_6.,,CPOPJ
IFN VIDP,	REPEAT 4,SNBAT_6,,CPOPJ
IFN PDP6P,	REPEAT 4,SNPDP_6,,CPOPJ
IFN TABP,	REPEAT 2,SNTAB_6,,CPOPJ
IFN NMTCS,REPEAT 6,SNMTC_6,,STAMTC	;MAGTAPE
REPEAT 6,SNJOB_6,,CPOPJ
REPEAT 6,SNBOJ_6,,CPOPJ
[JRST 4,CPOPJ]	;INTERRUPT ON IOPOP DEVICE
SNSPY_6,,CPOPJ
REPEAT 4,SNSTY_6,,CPOPJ	;PSEUDO-TTY
IFN NETP,	REPEAT 4,SNNET_6,,CPOPJ
IFN STKP,	SNSTK_6,,CPOPJ

	IF2,[IFN LIOTTB-.+STATB,[PRINTX /
	BARF AT STATB
/]]

;.RESET CH,	;RESET BUFFERED INFO ON CHANNEL CH
		;NOT IMPLEMENTED FOR MANY DEVICES
		;HAS SPECIAL EFFECTS ON "USR" DEVICE
;
ARESET:	HRRZ A,(R)	;PICK UP INDEX FROM I/O CH WORD
	HRRZ A,RSTB(A)	;LH OF TABLE TO BE USED BY IOPUSH IOPOP HACK
	JRST (A)	;DISPATCH

RSTB:	CPOPJ
REPEAT 2,TYIIOP,,TYIRS
REPEAT 2,TYORS
REPEAT 4,CPOPJ
REPEAT 4,USRST
REPEAT 2,CPOPJ
REPEAT 6,CPOPJ	;DEC TAPE
IFN OLPTP,	REPEAT 2,LPTRS
IFN NLPTP,	REPEAT 2,NLPTRS
REPEAT 4,CPOPJ
IFN VIDP,	REPEAT 2,CPOPJ
IFN PLTP,	REPEAT 2,PLTRS
REPEAT 5,PUNCLR
IFN IMXP,	REPEAT 4,IMPXRS
IFN OMXP,	REPEAT 4,CPOPJ
REPEAT 6,CPOPJ
REPEAT 5,PTRRS
IFN 340P,	REPEAT 4,DSIZAP
IFN 340P,	CPOPJ
IFN CODP,	REPEAT 2,CODIOP,,CODRS	;CODE
REPEAT 6,CPOPJ	;2314
IFN VIDP,	REPEAT 4,CPOPJ
IFN PDP6P,	REPEAT 4,PDPIOP,,PDPRST	;PDP-6 DEVICE
IFN TABP,	REPEAT 2,TABCLR
IFN NMTCS,	REPEAT 6,MAGTRS	;MAGTAPE
REPEAT 3,[JBIRS
	JBORS
]		;JOB
REPEAT 3,[BJIRS
	BJORS
]		;BOJ
	IIOPPR,,[JRST 4,CPOPJ]	;INTERRUPT ON IOPOP DEVICE
	CPOPJ	;SPY
REPEAT 2,STYIRS	;PSEUDO-TTY
REPEAT 2,CPOPJ	;"
IFN NETP,	REPEAT 4,CPOPJ
IFN STKP,	STKRS	;STANFORD KEYBOARD

IF2,[IFN LIOTTB-.+RSTB,[PRINTX /
	BARF AT RSTB
/]]

DEFINE DVHR X,Y
X!Y!TERMIN

DEFINE DV A,B/
	B
DVHR [DEFINE DVHR X,Y
X!][A
Y!TERMIN]
TERMIN

;DEVICE TABLES FOR AOPEN
;
;IN EACH ENTRY:	;4.8 OUTPUT 4.9 INPUT 4.7 DIR DEVICE 4.6 IGNORE FDELE (SKIP)
		;RIGHT HALF, SIXBIT DEVICE NAME
DEVTAB:
IFN NLPTP,	DV NLPTO,240000,,(SIXBIT /LPT/)
IFG OLPTP-NLPTP,DV LPTO,240000,,(SIXBIT /LPT/)
IFG LPTP-1,	DV LPTO,240000,,(SIXBIT /OLP/)

	DV QSKO,700000,,(SIXBIT /DSK/)
	DV TTYO1,740000,,(SIXBIT /TTY/)
	DV NULO,640000,,(SIXBIT /NUL/)
	DV USRO,640000,,(SIXBIT /USR/)
IFN VIDP,	DV NVIDI,640000,,(SIXBIT /NVD/)
	DV SYSO,700000,,(SIXBIT /SYS/)
IFN NETP,	DV NETO,640000,,(SIXBIT /NET/)
	DV STTYO,640000,,(SIXBIT /STY/)	;PSEUDO TTY
	DV JOBO,700000,,(SIXBIT /JOB/)
	DV BOJO,640000,,(SIXBIT /BOJ/)
IFN AI,[
	DV QSKO,700000,,(SIXBIT /AI/)
	DV MLGO,700000,,(SIXBIT /ML/)
]
IFE AI,[
	DV MLGO,700000,,(SIXBIT /AI/)
	DV QSKO,700000,,(SIXBIT /ML/)
]
IFN STKP,	DV STKO,440000,,(SIXBIT /STK/)
IFN PLTP,	DV PLOTO,240000,,(SIXBIT /PLT/)
IFN PLTP,	DV IPLO,240000,,(SIXBIT /IPL/)	;INTERPRETED PLOTTER
IFN IMXP,	DV IMPXO,440000,,(SIXBIT /IMX/)
	DV PTPO,240000,,(SIXBIT /PTP/)
IFN OMXP,	DV OMPXO,240000,,(SIXBIT /OMX/)
	DV PTRO,440000,,(SIXBIT /PTR/)
IFN 340P,	DV DISO,240000,,(SIXBIT /DIS/)	;340 AS OUTPUT DEVICE
IFN 340P,	DV IDISO,240000,,(SIXBIT /IDS/)	;340 AS INTERPRETED DISPLAY
	DV CLUO,700000,,(SIXBIT /CLU/)
	DV CLOO,700000,,(SIXBIT /CLO/)
	DV CLIO,300000,,(SIXBIT /CLI/)
	DV CLAO,500000,,(SIXBIT /CLA/)
	DV COMO,700000,,(SIXBIT /COM/)
IFN CODP,	DV CODO,640000,,(SIXBIT /COD/)
IFN VIDP,	DV TVCO,640000,,(SIXBIT /TVC/)
	DV ERRO,440000,,(SIXBIT /ERR/)
IFN TPLP,	DV TPLO,700000,,(SIXBIT /TPL/)
IFN TABP,	DV TABO,440000,,(SIXBIT /TAB/)
	DV SPYO,640000,,(SIXBIT /SPY/)
	DV CORO,540000,,(SIXBIT /COR/)	;DIR=LAST LINE OF TTY^F

NDEVS==.-DEVTAB

DVT1:	DV TTYO,740000,,(SIXBIT /TY/)
	DV TTYO,740000,,(SIXBIT /T/)
	DV UTO,700000,,(SIXBIT /UT/)
	DV STTYOA,640000,,(SIXBIT /ST/)
	DV STTYOA,640000,,(SIXBIT /S/)
	DV QSKUO,700000,,(SIXBIT /DK/)	;PARTICULAR UNIT
	DV QSKPO,700000,,(SIXBIT /P/)	;PARTICULAR PACK
	DV QSKPO,700000,,(SIXBIT /PK/)
IFN NMTCS,	DV MAGTO,640000,,(SIXBIT /MT/)	;MAGTAPE

NDV1==.-DVT1
EDEVS==.-1	;END FOR GETSYS (DEVS)

DEVADR:	DVHR
IFN .-DEVADR-NDEVS-NDV1,[PRINTX /DVHR LOST/]

;OPER DISPATCH
;
AOPER:	MOVE J,R	;AC FIELD OF UUO
	ADDI R,IOCHNM(U)	;SET UP IO CHANNEL REFERENCE POINTER
	CAIL C,MXOPR	;SKIP IF UUO E FIELD IS LESS THAN MAX OPR
	JRST ILUUO	;ILLEGAL OPER
	JRST @OPRDSP(C)	;LEGAL OPER-- DISPATCH ON E FIELD OF UUO

OPRDSP:	ILUUO
	OPRIRP A!X	;AITYI,ALISTEN,ASLEEP,ETC.

;
;CALL DISPATCH
;
ACALL:	MOVE B,C	;SET UP COPY OF ERR ADR NOT TO BE RELOCATED
	JRST @CALDIS(R)	;DISPATCH INDEX OF UUO'S AC FIELD

CALDIS:	ASYSC
	ADISMIS
	ILUUO
	ATRANAD
	AVALRET	;4
	AUTRAN
	UACORE
	ATRNDL
	ADSTART	;10
	AFDELE
	ADSTL
	ASUSET
	ALTPEN	;14
	AVSCAN
	APOTSET
REPEAT 20-.+CALDIS,ILUUO

;SHUT DOWN SYSTEM
ASHUTD:	PUSHJ P,LDISOW	;ILLEGAL FOR DISOWNED PROCEDURE
	XCTR XR,[MOVE C,(J)]	;TIME TO DOWN IN THIRTIETHS
	CAIGE C,60.*5.*30.
	JRST ILUUO	;NEG OR LESS THAN 5 MIN
	ADD C,TIME	;GET TIME AT WHICH DOWN
	PUSHJ P,SWTL
	SHUTLK
	SKIPN SHUTDN	;SKIP IF ALREADY SET
	JRST ASHUT1
	CAML C,SHUTDN
	JRST LSWPOP	;ALREADY SET TO LESS
ASHUT1:	PUSHJ P,CLQDEL
	DEDBLK
	MOVEM C,SHUTDN	;SET TIME TILL DEATH
	SUB C,TIME
	LSH C,1
	MOVEM C,DEDTIM
	PUSHJ P,DEATHX
	JRST 4,.
	JRST LSWPJ1

;READ TIME TILL SYSTEM DOWN
ADIETI:	XCTR XRW,[SETOM (J)]	;READ -1 IF NOT GOING DOWN
	SKIPG A,SHUTDN
	POPJ P,		;NOT DYING
	SUB A,TIME
	JRST APTUAJ	;GIVE TO USER

;REVIVE SYS
AREVIV:	PUSHJ P,LDISOW
	PUSHJ P,SWTL
	 SHUTLK
	PUSHJ P,CLQDEL
	 DEDBLK
	SETZM SHUTDN
	SETZM DEDTIM
	PUSHJ P,DEATHM
	JRST LSWPOP

;FROM CLOCK QUEUE BLOCK
DEATHZ:	PUSHJ P,DEATHX
	SKIPA
	JRST CLQRET
	MOVSI T,100000
	PUSHJ P,SUPSET	;DIE
	SETOM DEDTIM
	JRST CLQRET

;GET VARIOUS SYS STATUS
ASSTAT:	CONO PI,CLKOFF
	SKIPLE A,SHUTDN
	SUB A,TIME
	SKIPG SHUTDN
	SUBI A,1	;TIME TILL DOWN IF > 0,  -1 IF UP,  -2 IF DOWN
	CONO PI,CLKON
	MOVE B,SYSDBG
	MOVE C,SUSRS
	MOVE D,PARERR
	ADD D,PARERR+1
	MOVE E,TIME
IFE AI,MOVE TT,[SIXBIT /ML/]
IFN AI,MOVE TT,[SIXBIT /AI/]
	JRST SYSCPS

;IN ORDER @A...Z[\]^_ !".../0...9:;,=.?
SYSCTB:	SIXBIT /ACCESS/	;IOCHNL, ADR
	SIXBIT /ATTACH/
	SIXBIT /BREAK/	;. . .
	SIXBIT /CALL/	;SIXBIT /<NEXT CALL>/
	SIXBIT /CLOSE/	;IOCHNL
	SIXBIT /CORBLK/	;HACK PAGE MAP
	SIXBIT /CORTYP/	;READ STATUS OF PAGE.
	SIXBIT /DELETE/	;FILE DELETE
	SIXBIT /DETACH/	;DISOWN ENTIRE TREE
	SIXBIT /FLAP/	;TAPE #
	SIXBIT /IOT/	;IOCHNL, QUAN OR BLK POINTER
	SIXBIT /JOBGET/	;JOB CHNL
	SIXBIT /JOBINT/	;JOB CHNL
	SIXBIT /JOBRET/	;JOB CHNL
	SIXBIT /LISTEN/	;IOCHNL, ADR
	SIXBIT /LOAD/	;USER CH, I/O CH, VARBLK
	SIXBIT /LOGIN/	;SIXBIT /<NAME>/
	SIXBIT /LOGOUT/	;. . .
	SIXBIT /MLINK/	;MAKE LINK
	IFN NMTCS,SIXBIT /MTAPE/	;IOCHNL, COMMAND, SUBCOMMAND
	SIXBIT /OPEN/	;FILE OPEN
	SIXBIT /PAGEID/	;VIRT. PAGE NO., ID, STATUS
	SIXBIT /PDUMP/	;USER CH, I/O CH, VARBLK
	SIXBIT /RANGET/	;GET RANDOM INFO (HAVE TTY BIT, USER #, CONSOLE TTY #
	SIXBIT /RCPOS/	;READ CURSOR POS
	SIXBIT /RDMPBT/	;READ FILE DUMPED BIT IOCHN, ADR
	SIXBIT /RELOAD/
	SIXBIT /RENAME/	;FILE RENAME
	SIXBIT /RENMWO/	;RENAME WHILE OPEN
	SIXBIT /RFDATE/	;READ TIME OF CREATION OF FILE IOCHN, ADR
	SIXBIT /RSSIZE/	;READ SCREEN SIZE
	SIXBIT /SCML/	;SET # COMMAND LINES
	SIXBIT /SDMPBT/	;SET FILE DUMPED BIT IOCHN, ADR
	SIXBIT /SETIOC/	;CAUSE IO CHANNEL ERROR IN JOB/BOJ CHANNEL
	SIXBIT /SFDATE/	;SET TIME OF CREATION OF FILE IOCHN, ADR
	SIXBIT /SSTATU/	;READS VARIOUS SYSTEM STATUS
	SIXBIT /TRANAD/	;CREATE TRANSLATION ENTRY
	SIXBIT /TRANCL/	;CLEAR TRANSL. LIST(S) FOR A JOB.
	SIXBIT /TRANDL/	;DELETE A TRANSL. ENTRY.
	SIXBIT /TRANEX/	;READ A JOB'S TRANSL. LIST.
	SIXBIT /TRANS/	;TRANSLATE A FILENAME.
	SIXBIT /TTYGET/	;SUPPLY TTY CH, RETURNS THREE WORDS OF TTY STATUS
	SIXBIT /TTYSET/	;SUPPLY TTY CH AND THREE WORDS OF TTY STATUS
	SIXBIT /VALUE/	;VALRET QUANTITY (SKIPS)

ZZ==.-SYSCTB-1
RADIX 2
ZZ2==CONC [.LENGTH /]\ZZ,/
RADIX 8
REPEAT 1_<ZZ2>-ZZ-1,377777,,-1
;4.X BIT IMPLIES SUPPLY ROUTINE WITH POINTER TO X'TH ARG, NOT ARG ITSELF
;3.9-3.7 = MINIMUM NUMBER OF ARGS

;# ARGS ACTUALLY SUPPLIED IN W WHEN DISPATCHING THRU SYSCTD, ARGS IN A...J
SYSCTD:	200,,NACCES
	100,,NATTAC
	ABREAK
	100,,NCALL
	100,,NCLOSE
	24300,,NCORBL
	100,,NCORTY
	300,,NDEL
	NDETAC
	100,,NFLAP
	2200,,NIOT
	100,,NJBGT
	100,,NJBINT
	100,,NJBRT
	100,,NLISTE
	200,,NLOAD
	200,,NLOGIN
	ALOGOU
	700,,NMLINK
	IFN NMTCS,100,,NMTAPE
	300,,NOPEN
	200,,APGID
	4300,,PDUMP
	ARANGT
	100,,ARCPOS
	100,,ARDMPB
	100,,NRELOA
	600,,NRNAM
	300,,NRNWO
	100,,ARFDAT
	100,,ARSSIZ
	200,,ASCML
	200,,ASDMPB
	200,,NSTIOC
	200,,ASFDAT
	ASSTAT
	300,,NTRNAD
	100,,NTRNCL
	200,,NTRNDL
	200,,NTRNEX
	100,,NTRNS
	100,,ATTYGT
	400,,ATTYST
	100,,NVALUE

REPEAT 1_<ZZ2>-ZZ-1,ILUUO

SYSCBT:	SIXBIT /ASCII/
	SIXBIT /BAI/
	SIXBIT /BAO/
	SIXBIT /BII/
	SIXBIT /BIO/
	SIXBIT /BLOCK/
	SIXBIT /IMAGE/
	SIXBIT /INPUT/
	SIXBIT /OFF/	;100
	SIXBIT /ON/	;200
	SIXBIT /OUTPUT/
	SIXBIT /READ/
	SIXBIT /UAI/
	SIXBIT /UAO/
	SIXBIT /UII/
	SIXBIT /UIO/
	SIXBIT /UNIT/
	SIXBIT /WRITE/

ZZ==.-SYSCBT-1
RADIX 2
ZZ3==CONC [.LENGTH /]\ZZ,/
RADIX 8
REPEAT 1_<ZZ2>-ZZ-1,377777,,-1

SYSCDT:	10
	34	;BAI
	25
	16
	07	;BIO
	04
	02
	10
	100
	200
	01
	10
	61	;UAI
	52
	43
	70	;UIO
	60
	01

REPEAT 1_<ZZ3>-ZZ-1,0
;.CALL ADR1  SKIPS UNLESS SOMETHING WRONG
;ADR1:	SETZ
;	SIXBIT /<CALL NAME>/
;	REPEAT #ARGS,BITS,, <ADDRESS OF ARGUMENT>
;	BITS=	4.9 => LAST ARG
;		4.3 - 4.1 0 = NORMAL ARG
;			  1 = IMMEDIATE
;			  2 = OUTPUT ARG

;			  4 = WORD OF CONTROL BITS
;			  5 = IMMEDIATE CONTROL BITS

ASYSC:	PUSHJ P,ASCGRG	;B HAS E OF UUO
	JRST OPNL15	;MORE THAN 9 ARGS
	JRST OPNL30	;TOO FEW ARGS
	HRRZ R,SYSCTD(H)
	JRST (R)

NCALL:	MOVE T,A
	MOVE R,[B,,A]
	BLT R,A+6
	SETZM A+7
	SOS W
	PUSHJ P,ASCRCH
	JRST ILUUO
	PUSH P,[ASYSC+1]
	LDB J,[331000,,SYSCTD(H)]
	JUMPE J,NCALL2
	AOS B,40
	JRST NCALL3	;HE WANTS POINTERS, WE HAVE JUST VALUES.
		;MUST GET ARGS AGAIN

ASCRCH:	MOVEI H,0
	REPEAT ZZ2,[CAML T,SYSCTB+1_<ZZ2-.RPCNT-1>(H)
	ADDI H,1_<ZZ2-.RPCNT-1>
	]
	CAMN T,SYSCTB(H)
	AOS (P)
	POPJ P,

;SYSTEM CALL GET ARGS
SCGARG:	HRRZ B,40
ASCGRG:	XCTR XR,[MOVE T,(B)]
	CAME T,[SETZ]
	JRST ILUUO
	XCTR XR,[MOVE T,1(B)]
	MOVEM T,LSCALL(U)
	PUSHJ P,ASCRCH
	JRST ILUUO	;CALL NAME NOT FOUND
	LDB J,[331000,,SYSCTD(H)]	;GET BITS CORRESP TO ARGS WHICH SAY SUPPLY PNTR TO NTH ONE
NCALL3:	MOVEI W,2(B)
	MOVE T,[-9,,A]
	SETZM CTLBTS(U)
ASYSC2:	XCTR XR,[MOVE R,(W)]
	TLNE R,2000	;IGNORE ALL OUTPUT ARGS
	JRST ASYSC4
	TLNE R,37
	PUSHJ P,ASCIND	;CALC EFFECTIVE ADDRESS
	TLNE R,4000
	JRST ASYSC5
	AOBJP T,CPOPJ
	ROT J,-1
	JUMPL J,ASYSC7	;J IF WANT ADDRESS, NOT VALUE
	TLNE R,1000
	TLZA R,-1	;IMMEDIATE, GET 0,,ADR
	XCTR XR,[MOVE R,(R)]	;ELSE GET WORD POINTED TO
ASYSC7:	MOVEM R,-1(T)	;PUT INTO AC
	JRST ASYSC4

ASYSC5:	TLNE R,1000	;CTL BITS
	TLZA R,-1	;IMMEDIATE, GET 0,,ADR
	XCTR XR,[HRRZ R,(R)]	;ELSE WORD ADDRESS
	XORM R,CTLBTS(U)	;XOR ALL THESE ARGS TOGETHER
ASYSC4:	XCTR XRW,[SKIPL (W)]	;SKIP IF TERMINATE BIT ON
	AOJA W,ASYSC2
	HLRE W,T
	ADDI W,9	;COMPUTE NUMBER OF ARGUMENTS SUPPLIED
NCALL2:	LDB T,[300300,,SYSCTD(H)]
	SUB T,W
	JUMPG T,POPJ1	;NOT ENOUGH ARGS
	JRST POPJ2	;OK

;SYSTEM CALL PUT (INTO USER MEMORY FROM AC'S)
SYSCPS:	AOS (P)
SYSCPT:	HRRZ W,40
	ADDI W,2
	MOVSI T,-8
SYSCP2:	XCTR XR,[MOVE R,(W)]
	TLNN R,1000
	TLNN R,2000
	JRST SYSCP3
	PUSHJ P,ASCIND
	MOVE J,1(T)
	XCTR XW,[MOVEM J,(R)]
	AOBJP T,CPOPJ
SYSCP3:	JUMPL R,CPOPJ
	AOJA W,SYSCP2

;PERFORM INDEXING AND INDIRECTION ON ADDRESS WORD IN R.
;DON'T CLOBBER BITS 3.6 - 4.9.  SET BITS 3.1 - 3.5 TO ZERO
;PUT ADDR IN RH.
ASCIND:	TLNN R,37
	POPJ P,
ASCIN1:	PUSH P,R
	LDB R,[220400,,R]
	CAIE R,0
	XCTR XRW,[HRRZ R,(R)]
	ADD R,(P)
	TLZ R,17
	TLZE R,(@)
	XCTR XR,[MOVE R,(R)]
	DPB R,[2700,,(P)]
	POP P,R
	TLNN R,37
	POPJ P,
	PUSHJ P,OPBRK	;ALLOW PCLSR
	JRST ASCIN1

;CALLING SEQUENCE:
;	SETZ
;	SIXBIT /PDUMP/
;	POINTER TO INFERIOR CHANNEL
;	POINTER TO DISK CHANNEL
;	POINTER TO STATE WORD

;STATE WORD:	0	(INITIALLY)
;	4.9 + N => READY TO DUMP PAGE N

PDUMP:	MOVE J,A
	JSP T,NCORUI	;DECODE JOB SPEC (1ST ARG)
	 JFCL
	MOVE A,J
	HRRZ J,SUPPRO(A)
	CAIE J,(U)	;JOB SPEC'D MUST BE OUR INFERIOR.
	 JRST OPNL31
	JSP T,PDUMDC	;DECODE 2ND ARG, B-> IOCHNM WORD.
	TRNN J,2000
	 JRST OPNL34	;NOT DISK WRITE CHANNEL.
	PCLT
	XCTR XRW,[MOVES D,(C)]
	MOVEM A,EPDL(U)	;USER INDEX
	PUSHJ P,RPCLSR
	PUSHJ P,SOSSET
	USTP(A)
	HLRZ A,(B)	;GET DISK CHANNEL
	MOVEM A,SRN3(U)	;CHANNEL
	MOVEM C,SRN4(U)	;POINTER TO STATE WORD
	MOVE T,QSRAC(A)
	TRNE T,20000
	JRST PDUMP1	;ALREADY IN PDUMP MODE
	MOVE TT,QBFP(A)
	TRNN T,4007
	CAME TT,[SETZ 377]
	JRST ILUUO
	SKIPL QSMDN(A)
	JRST PDUMP2
	PUSH P,D
	PUSHJ P,QSBWG
	JRST ILUUO
	POP P,D
	SOS QSBFS(A)
PDUMP2:	MOVEI TT,20000
	IORM TT,QSRAC(A)
PDUMP1:	PUSHJ P,SWTL
	CIRPSW
	MOVE E,QSMDN(A)
	LSH E,10.
	JUMPN D,PDUMP5
	SETZM (E)	;CLEAR FIRST WORD OF BLOCK
PDUMP4:	PUSHJ P,PUPLC	;GET BYTE POINTERS
	LDB W,Q		;CIRC POINTER ENTRY
	LDB R,T		;PAGE MAP ENTRY
	CAIN W,-1
	TLO R,(SETZ)	;ABS PAGE
	SKIPN W
	MOVEI R,0	;PAGE NON-EXISTANT
	TRNN R,600000
	LSH R,16.	;SWAPPED OUT
	MOVE W,D	;VIRTUAL PAGE NUMBER
	ADDI W,1(E)	;ADDRESS OF ENTRY IN BLOCK
	MOVEM R,(W)	;STORE ENTRY
	CAIGE D,377
	AOJA D,PDUMP4
	HRLI W,1(W)
	SETZM 1(W)
	HRRI W,2(W)
	BLT W,1777(E)

;DROPS THRU;DROPS IN

	PUSHJ P,QSBWW
	MOVSI D,(SETZ)
PDUMP5:	MOVE C,SRN4(U)
	XCTR XW,[MOVEM D,(C)]
PDUMP8:	PUSHJ P,PUPLC
	LDB W,Q
	CAIE W,-1
	SKIPN W
	AOJA D,PDUMP6	;PAGE ABSOLUTE OR NONEXISTANT
	CONO PI,CLKOFF
	LDB TT,T	;PICK UP PAGE MAP ENTRY
	TRNN TT,600000
	JRST PDUMP7	;SWAPPED OUT
	ANDI TT,777
	MOVSI Q,1
	ADDM Q,MMSWP(TT)	;AOS COUNT OF EXEC PGS POINTING TO THIS ONE
	CONO PI,CLKON
	PUSHJ P,SOLSET
	MMSWP(TT)
	MOVE Q,QDSKN(A)
	SKIPL QSMDN(A)
	JRST PDUMP3
	SOSGE QSFT(Q)
	JRST QSBWG3	;DISK FULL
PDUMP3:	MOVEM TT,QSMDN(A)	;STORE ABS PAGE NUMBER
	PUSH P,D
	PUSHJ P,QSBWW
	PUSHJ P,LSWDEL
	POP P,D
	AOS D
PDUMP6:	TRNN D,400
	JRST PDUMP5
	MOVEI W,4000
	IORM W,QSRAC(A)
	PUSHJ P,LSWPOP
	PUSHJ P,LSWPOP
	JRST POPJ1

PDUMP7:	PUSHJ P,LSWPOP	;RELEASE CIRPSW
	MOVE J,EPDL(U)
	HRLI J,240000
	TRNE D,200
	HRLI J,220000	;UPPER HALF
	PUSHJ P,MPLD1	;TURNS ON CLOCK
	MOVE J,D
	TRZ J,200
	LSH J,10.	;VIRTUAL ADDRESS OF PAGE
	PCLT
	XCTR XR,[MOVE J,20(J)]	;SWAP IN THE PAGE
	PUSHJ P,MPLDZ
	PUSHJ P,SWTL
	CIRPSW
	JRST PDUMP8

PUPLC:	PUSH P,A
	PUSH P,U
	MOVE U,EPDL(U)
	MOVE A,D
	ANDI A,377
	PUSHJ P,UPLC
	POP P,U
	JRST POPAJ

;DECODE 2ND ARG TO PDUMP & LOAD.
;B GETS IOCHNM WORD ADDR, RH OF J GETS LH OF CLSTB ENTRY.
PDUMDC:	TDNE B,[-20]
	JRST OPNL14
	ADDI B,IOCHNM(U)
	HRRZ J,(B)
	HLRZ J,CLSTB(J)
	JRST (T)

PUSH4.:	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	JRST (H)

POPP4.:	POP P,D
	POP P,C
	POP P,B
	POP P,A
	JRST (H)

;PURE LOAD
;	.CALL BLK
;BLK:	SETZ
;	SIXBIT /LOAD/
;	[<JOB-SPEC>]
;	SETZ [DSKCHN]

;PAGE WORD
;4.9=1 ABSOLUTE
;4.8=1 SHARED WITH OTHER PAGES AT LEAST ONE OF WHICH IS WRITE
;4.7=1 LINK WITH VIRT PG IN RH 1.8-1.1
;2.7=1 WORD ALREADY PROCESSED

NLBS:	PUSHJ P,LSWCLR	;CIRPSW, MAYBE UNPCLSR
	JRST ILUUO

NLOADS:	JRST ILUUO

NILUO:	MOVEI Q,140000
	ANDCAM Q,QSRAC(A)
	JRST ILUUO

NLOADB:	MOVEI Q,100000
	IORM Q,QSRAC(A)
	LSH TT,10.
	JRST NLOADC

NLOAD:	MOVE J,A
	JSP T,NCORUI	;DECODE THE JOB SPEC.
	 JRST JLOAD0	 ;JOB GUARANTEED WRITEABLE.
	JSP T,NCORWR	;ELSE CHECK IF WRITEABLE.
	CAIN J,-1	;BUT CAN WRITE PDP6.
	CAIA
	JRST OPNL31	;NOT WRITEABLE.
JLOAD0:	HRREI A,(J)	;MAKE SURE EXTEND SIGN IF PDP6.
	JSP T,PDUMDC	;DECODE 2ND ARG.
	TRNN J,2000
	TRNN J,200
	JRST OPNL34	;NOT DISK READ CHANNEL.
JLOAD:	MOVE R,B	;IOCHNM ADDRESS IN CASE WE GET TO QICL
	JUMPL A,NLOADA	;DONT STOP THE 6
	CAMN A,U
	JRST NLOADA	;DONT STOP IF LOADING INTO SELF
	PUSHJ P,RPCLSR
	PUSHJ P,SOSSET
	USTP(A)
NLOADA:	MOVEM A,SRN3(U)	;SAVE USER INDEX
	HLRZ A,(B)
	HLRZ C,QPCLSR(A)
	JUMPE C,NLOADD
	HRRZ Q,SRN3(U)
	CAIN C,(Q)
	JRST NLDSBB
	SETZM QPCLSR(A)
NLOADD:	MOVEM A,SRN4(U)	;SAVE DISK CHANNEL
	SETZM SRN5(U)	;VIRTUAL PAGE NUMBER
	CAMN U,PCLUSR
	SETZM PCLIDX
	MOVEI C,40000
	IORM C,QSRAC(A)	;BLOCK AT A TIME MODE (READ FIRST BLOCK CONTAINING MAP)
	SKIPL TT,QSMDN(A)
	JRST NLOADB
	PCLT
	SKIPG QSBFS(A)
	PUSHJ P,UFLS	;HANG UNTIL A BLOCK IS READ IN
	MOVEI Q,100000	;READ INHIBIT
	IORM Q,QSRAC(A)
	MOVSI Q,141	;RANDOM ACCESS, PAR ERR, OR UPDATE POINTERS
	TDNE Q,QSRAC(A)
	JRST NILUO
	HRRZ Q,QBFP(A)
	CAIL Q,376
	JRST NILUO
	PUSHJ P,QSBGB	;SET UP CHNL AREA. TT ADDR OF FIRST WORD OF BLOCK
	JFCL		;QSBGB SKIPS FOR NORMAL RETURN

NLOADC:	SKIPE (TT)	;SKIP IF PURE DUMPED FILE
	JRST NLDSB	;SBLK
	SKIPGE SRN3(U)
	JRST NILUO
	MOVEI R,1(TT)	;ADDRESS OF FIRST WORD OF DUMPED MAP
	MOVEM R,EPDL3(U)	;SAVE
	MOVEI Q,2000
	PUSHJ P,QFNTR	;FIND DISK ADDRESS OF SECOND BLOCK
	JRST NILUO	;OFF END OF FILE
	SOS QSBI(A)	;UNDO QFNTR HACK
	AOS QSLGL(A)
	PUSHJ P,QUDULK	;UNLOCK USER DIRECTORY
	PUSHJ P,SWTL	;LOCK CIRPSW
	CIRPSW

NLOAD0:	MOVE A,@EPDL3(U)
	TRNE A,600000	;SKIP IF NO ACCESS (IGNORE)
	TRNE A,100000
	JRST NLD14	;THIS PAGE ALREADY DONE OR NO ACCESS
	MOVE A,SRN5(U)	;VIRTUAL PAGE NUMBER
	MOVE U,SRN3(U)	;USER INDEX
	PUSHJ P,UPLC
	LDB R,Q		;LOOK IN CIRCULAR POINTER ENTRY FOR THIS PAGE
	JUMPE R,NLOAD1	;DOESN'T ALREADY HAVE THIS VIRTUAL PAGE
	PUSH P,T	;SAVE BYTE POINTER TO PAGE MAP FOR THIS VIRTUAL PAGE
	PUSH P,Q	;SAVE BYTE POINTER TO CIRCULAR POINTER ENTRY FOR THIS PAGE
	PUSHJ P,PAGERT	;FLUSH THE ALREADY EXISTING VIRTUAL PAGE
	POP P,Q
	POP P,T
NLOAD1:	MOVE U,USER
	MOVE R,@EPDL3(U)	;PICK UP DUMPED PAGE MAP WORD
	JUMPGE R,NLOAD3	;NOT ABSOLUTE PAGE
	ANDI R,777	;ABS PG #
	CAIL R,TSYSM+IFN PDP6P,16.
	JRST NLBS
	TRO R,200000	;RD ONLY
	DPB R,T		;STORE ENTRY IN PAGE MAP
	MOVEI R,-1
	DPB R,Q		;STORE -1 IN CIRCULAR POINTER
NLOAD2:	MOVE E,SRN5(U)	;VIRTUAL PAGE NUMBER
	MOVE U,SRN3(U)	;USER INDEX LOADING INTO
	PUSHJ P,GHUSRA	;RECOMPUTE HUSRAD
NLD14:	MOVE U,USER
	MOVEI R,100000
	IORB R,@EPDL3(U)	;MARK DUMPED PAGE WORD AS ALREADY DONE
	MOVE A,SRN4(U)	;DISK CHANNEL
	TLNN R,500000	;SKIP IF NO CORRESPONDING BLOCK IN FILE
	TRNN R,600000	;SKIP IF MUST ADVANCE ONE BLOCK
	JRST .+2	;DON'T ADVANCE FILE POINTER
	PUSHJ P,QFNTN	;ADVANCE TO NEXT DISK ADDRESS
	AOS R,SRN5(U)	;NEXT VIRTUAL PAGE
	CAMN U,PCLUSR
	MOVEM R,PCLIDX
	AOS EPDL3(U)	;NEXT MAP WORD
	CAIGE R,400
	JRST NLOAD0	;LOOP
	PUSHJ P,LSWPOP	;RELEASE CIRPSW
	MOVE B,SRN3(U)	;USER INDEX LOADING INTO
	CAME B,U	;SKIP IF LOADING INTO SELF
	PUSHJ P,LSWPOP	;UNSTOP USER
	MOVE B,QFBLNO(A)
	SETZM QFBLNO(A)
	MOVEM B,QRADAD(A)
	MOVSI B,100
	IORM B,QSRAC(A)
	MOVEI B,100000
	ANDCAM B,QSRAC(A)	;TURN OFF READ INHIBIT
	JRST POPJ1

NLOAD3:	TLNN R,100000	;SKIP IF LINK WITH PAGE IN RH OF R
	JRST NLOAD4
	PUSH P,T	;SAVE BYTE POINTER TO MAP ENTRY FOR THIS VIRTUAL PAGE
	PUSH P,Q	;SAVE POINTER TO CIRCULAR POINTER ENTRY FOR THIS PAGE
	LDB A,[1700,,R]	;VIRTUAL PAGE NUMBER BEING LINKED TO
	CAIL A,400
	JRST NLBS	;BAD VIRT PAGE #
	MOVE E,SRN5(U)	;VIRTUAL PAGE NUMBER OF PAGE BEING LINKED
	MOVE U,SRN3(U)	;USER INDEX LOADING INTO
	PUSHJ P,UPLC
	LDB W,Q		;CIRCULAR POINTER OF OTHER ENTRY
	JUMPE W,NLBS	;DIDN'T EXIST
	CAIN W,-1
	JRST NLBS	;POINTS TO AN ABSOLUTE PAGE
	MOVE C,U
	IDIVI C,LUBLK
	JUMPN D,[JRST 4,.]	;L DOESN'T DIVIDE U
	LSH C,10	;USER NUMBER _ 8
	TRZE C,400000
	JRST 4,.	;USER INDEX WAS TOO LARGE
	IOR C,E		;NEW CIRCULAR POINTER
	POP P,D		;NEW CIRCULAR POINTER BYTE POINTER
	DPB W,D		;STORE OTHER ENTRY AS NEW CIRCULAR POINTER ENTRY
	DPB C,Q		;MAKE OTHER CIRCULAR POINTER ENTRY POINT TO NEW ONE
	LDB E,T		;OTHER MAP ENTRY
	POP P,T		;POINTER TO NEW MAP ENTRY
	ANDI R,600000	;PROTECTION BITS
	TRZN E,600000
	JRST NLD11
	IOR E,R
	JRST NLD10
NLD11:	LSH R,-20
	DPB R,T
NLOAD9:	AOSA NSWPGS(U)	;USER LOADING INTO HAS ONE MORE SWAPPED OUT PAGE
NLD10:	DPB E,T
NLD13:	AOS NMPGS(U)	;USER HAS ONE MORE PAGE
	MOVE U,USER
	JRST NLOAD2	;RECOMPUTE HUSRAD AND LOOP

NLOAD4:	MOVE A,SRN4(U)	;DISK CHANNEL
	MOVE I,QDSKN(A)	;DISK NUMBER
	MOVE W,QSLGL(A)	;DISK TRACK
	DPB I,[DADDNR+W]	;STORE DISK NUMBER WITH TRACK
	TDNE R,[200000,,400000]	;SKIP IF PURE AND CAN BE SHARED AS READ ONLY
	JRST NLOAD5
	MOVN B,MMPNP	;NUMBER OF MMP PAGES IN USE
	LSH B,9.+18.	;1000 ENTRIES PER MMP PAGE (PUT IN LH)
	HRR B,MMPEAD	;EXEC ADDRESS OF FIRST MMP PAGE
NLOAD6:	HLRZ C,1(B)	;GET DISK ADDRESS FROM MMP ENTRY
	CAMN C,W	;COMPARE DISK ADDRESSES
	JRST NLOAD7	;FOUND PAGE ALREADY IN CORE
NLOAD8:	AOS B		;TWO WORDS PER ENTRY
	AOBJN B,NLOAD6	;LOOP

NLOAD5:	PUSH P,T	;SAVE POINTER TO PAGE MAP ENTRY
	PUSH P,R	;SAVE PROTECTION BITS
	PUSHJ P,QTLOCK	;LOCK TUT
	MOVE B,QSLGL(A)	;DISK TRACK
	IDIVI B,TUTEPW	;COMPUTE BYTE POINTER TO TUT
	ADD B,QTUTO(I)
	HLL B,TBTBL(C)
	LDB C,B		;TUT ENTRY FOR THIS TRACK
	JUMPLE C,[JRST 4,.]	;NOT PART OF ANY FILE
	CAIGE C,TUTMNY
	AOS C
	DPB C,B		;ADD ONE TO TUT ENTRY FOR THIS TRACK
	PUSHJ P,QTULK
	PUSH P,R
NLOADY:	PUSHJ P,GMMPP	;GET A NEW MMP ENTRY (R HAS ITS INDEX, TT HAS ITS ADDRESS)
	JRST NLOADZ	;NO MMP ENTRIES AVAIL OR MEM FOR NEW ONES
	MOVE D,SRN3(U)	;USER INDEX LOADING INTO
	IDIVI D,LUBLK
	JUMPN E,[JRST 4,.]	;L DOESN'T DIVIDE USER INDEX
	LSH D,10	;USER NUMBER _ 8
	TRZE D,400000
	JRST 4,.	;USER INDEX WAS TOO LARGE
	MOVE E,SRN5(U)	;VIRTUAL PAGE NUMBER
	IOR D,E		;POINTER TO CIRCULAR POINTER
	TLO D,200000	;SWAPPED OUT BIT IN MMP
	POP P,E
	TDNE E,[200000,,400000]	;SKIP IF PURE AND CAN BE SHARED READ ONLY
	TLO D,20000	;SET INITIAL SWAP IN BIT IN MMP
	MOVEM D,(TT)	;STORE IN FIRST WORD OF MMP ENTRY
	HRLZM W,1(TT)	;STORE DISK ADDRESS IN LH OF SECOND WORD
	TRO R,400000
	DPB R,Q		;STORE POINTER TO MMP IN CIRCULAR POINTER
	AOS NPGSWO	;ONE MORE PAGE SWAPPED OUT (SYSTEM WIDE)
	POP P,R		;PROTECTION BITS
	POP P,T		;BYTE POINTER TO PAGE MAP ENTRY
	LDB D,[200200,,R]	;PROT BITS
	SKIPN D
	MOVEI D,1	;FORCE AT LEAST RD ONLY ACCESS
	DPB D,T		;STORE BITS IN MAP
	MOVE U,SRN3(U)
	JRST NLOAD9	;AOS NSWPGS, NMPGS, RECOMPUTE HUSRAD AND LOOP

NLOADZ:	PUSHJ P,LSWPOP	;FREE CIRPSW
	MOVEI T,3
	CAMLE T,LMEMFR
	PUSHJ P,UFLS
	PUSHJ P,SWTL
	CIRPSW
	JRST NLOADY

NLOAD7:	MOVE C,(B)	;CHECK INITIAL SWAP IN BIT IN MMP ENTRY
	TLNE C,20000	;SKIP IF OFF IN ENTRY OF GUY WE FOUND
	JRST NLOAD8	;BIT ON, HIS COPY OF PAGE WON'T BE PURE
	MOVE D,SRN3(U)	;USER INDEX LOADING INTO
	IDIVI D,LUBLK
	JUMPN E,[JRST 4,.]	;L DOESN'T DIVIDE USER INDEX
	LSH D,10	;USER NUMBER _ 8
	TRZE D,400000
	JRST 4,.	;USER INDEX WAS TOO LARGE
	MOVE E,SRN5(U)	;VIRTUAL PAGE NUMBER
	IOR D,E		;POINTER TO CIRCULAR ENTRY
	HRRZ E,(B)	;POINTER FROM MMP
	DPB E,Q		;STORE IN CIRCULAR POINTER
	HRRM D,(B)	;MAKE MMP POINT TO CIRCULAR POINTER
	TLNN C,300000	;SKIP IF NOT IN
	JRST NLD12	;IN CORE
	MOVEI D,1
	DPB D,T		;STORE READ ONLY IN MAP
	MOVE U,SRN3(U)	;USER INDEX LOADING INTO
	JRST NLOAD9	;AOS NMPGS, NSWPGS, RECOMPUTE HUSRAD AND LOOP

NLD12:	HRLI B,2200	;B NOW A BYTE POINTER TO MMP
	MOVE C,B
	PUSH P,T	;SAVE BYTE POINTER TO MAP
	PUSHJ P,UCPRL
	100000,,.+2	;RETURN ON MEMPNT (WITH PAGE NUMBER IN T)
	JRST 4,.
	SUB P,[4,,4]
	POP P,R		;BYTE POINTER TO USER'S MAP
	TROE T,200000	;GIVE READ ONLY ACCESS
	JRST 4,.	;UCPRL BIT THE BAG
	DPB T,R		;STORE IN USER'S MAP
	ANDI T,777
	AOS MMSWP(T)	;INCR COUNT OF USERS IN LOOP
	MOVE U,USER
	MOVE U,SRN3(U)	;USER INDEX LOADING INTO
	JRST NLD13	;AOS NMPGS, RECOMPUTE HUSRAD AND LOOP

NLDSBL:	PUSHJ P,LSWDEL	;UNDO LOSSET
NLUPCL:	MOVE U,USER
	MOVSI B,BSSTP
	MOVE A,SRN3(U)
	ANDCAM B,USTP(A)
	POPJ P,

NLDSBB:	MOVSI J,254000	;LO-LO, HI-HI, ACS-SWAP OUT ACS (COMING BACK AFTER PCLSRING OUT)
	HRR J,SRN3(U)	;A HAS DSK CHNL #)
	CAIE U,(J)	;LOADING SELF?
	PUSHJ P,MPLD1	;LOAD MAP (ALSO CLOBBER UMAPS)
	SKIPL C,SRN3(U)
	CAIN U,(C)
	JRST NLDSBH
	PUSHJ P,LSWPOP
	PUSHJ P,LOSSET
	NLUPCL
	MOVSI B,BSSTP
	IORM B,USTP(C)
NLDSBH:	HRRZ B,QPCLSR(A)
	JRST (B)

NLDSB:	PUSH P,A	;A HAD DSK CHNL #
	SKIPL A,SRN3(U)	;USER INDEX OF GUY WE'RE LOADING
	CAIN U,(A)
	JRST NLDSBG	;LOADING OURSELVES
	MOVSI B,BSSTP
	IORM B,USTP(A)	;STOP GUY
	PUSHJ P,LSWPOP	;UNDO SOSSET
	POP P,A	;GET BACK DSK CHNL #
	PUSHJ P,LOSSET
	NLUPCL	;GO HERE ON PCLSRING OR LSWPOPING THIS.
	JRST NLDSBZ

NLDSBG:	POP P,A
NLDSBZ:	HRLZ B,SRN3(U)
	HRRI B,NLDSBD
	MOVEM B,QPCLSR(A)	;RESTART POINT IN CASE OF PCLSR
	MOVEI Q,140000	;READ INHIBIT, BLOCK AT A TIME
	ANDCAM Q,QSRAC(A)	;TURN OFF
	MOVEM J,QSMPRC(A)
	MOVEM TT,QSMPRP(A)
	MOVSI J,254000	;LO-LO, HI-HI, ACS-SWAP OUT ACS
	HRR J,SRN3(U)
	CAIE U,(J)
	PUSHJ P,MPLD1	;LOAD MAP (ALSO CLOBBER UMAPS)
;DROPS THRU

;DROPS IN
NLDSB1:	HRROI I,EPDL3(U)
	MOVEM I,SRN4(U)	;SET UP AOBJN PTR TO READ INTO EPDL3
NLDSBD:	MOVEI C,SRN4(U)	;SET C UP TO POINT TO AOBJN PTR
	HRLI C,(TRN)	;INDICATE EXEC MODE ADR
	PUSHJ P,QBI
	MOVE I,EPDL3(U)
	CAME I,[JRST 1]
	JRST NLDSB1	;IGNORE INITIAL STUFF UNTIL JRST 1
NLDSBK:	MOVEI B,NLDSBE
	HRRM B,QPCLSR(A)
NLDSB2:	HRROI I,EPDL3(U)
	MOVEM I,SRN4(U)
NLDSBE:	MOVEI C,SRN4(U)
	HRLI C,(TRN)
	PUSHJ P,QBI	;GET AN AOBJN POINTER
	SKIPL B,EPDL3(U)
	JRST NLDSB6	;NOT AN AOBJN POINTER
	HRRZS B
	CAIL B,20
	JRST NLDSB3	;OK IF NOT LOADING INTO ACS
	SKIPL SRN3(U)
	CAMN U,SRN3(U)
	JRST NLDSBP
	JRST NLDSB3

NLDSBP:	HLRE C,EPDL3(U)	;ATTEMPTING TO LOAD INTO OWN ACS OR 6 ACS
	SUBI B,20
	CAMLE C,B
	MOVE B,C
	MOVNS B
	LDB D,[1200,,QSMPRP(A)]
	SKIPGE QSMDN(A)
	MOVEI D,0
	ADD D,QFBLNO(A)
	ADD D,B
	MOVEM D,QRADAD(A)
	MOVSI D,100
	IORM D,QSRAC(A)
	ADD C,B
	JUMPE C,NLDSBI	;GET NEW AOBJN POINTER (FLUSH CHECKSUM)
	HRLS B
	ADDM B,EPDL3(U)	;UPDATE AOBJN POINTER

NLDSB3:	SKIPGE SRN3(U)
	JRST NLDSBQ	;LOADING PDP6
	MOVEI B,NLDSBF	;LOADING OTHER GUY,MAYBE FLUSH EXISTING MEMORY AND GET NEW
	HRRM B,QPCLSR(A)
NLDSBF:	HRRZ E,EPDL3(U)	;START ADR OF BLOCK
	HLRE C,EPDL3(U)	;-LENGTH OF BLOCK
	SUB E,C
	SUBI E,1	;GET END ADR OF BLOCK
	LSH E,-10.
	CAILE E,400
	JRST NLDSB9	;TRYING TO LOAD ABOVE TOP OF MEM
	PUSH P,E	;PAGE NO. OF LAST PAGE NEEDED
NLDSB4:	MOVE E,(P)
	CAMGE E,SRN5(U)
	JRST NLDSB5	;ALREADY HAVE NEEDED PAGES
	PUSHJ P,SWTL
	CIRPSW
	PUSH P,U
	PUSH P,A
	HRRZS A,SRN5(U)
	MOVE U,SRN3(U)
	PUSHJ P,UPLC
	LDB B,Q
	LDB E,T	;PAGE MAP ENTRY
	TRNE E,600000
	LSH E,-16.	;GET ACCESS BITS IF NOT SWAPPED OUT
	POP P,A
	POP P,U
	PUSHJ P,LSWPOP
	TRNE E,2
	JRST NLDSBM	;PAGE EXISTS AND IS WRITABLE
	PUSH P,A	;PAGE DOES NOT EXIST OR IS NOT WRITABLE FLUSH IT AND GET NEW ONE
	PUSHJ P,NLSBP
	JRST NLSBPL	;COULDNT GET PAGE
	POP P,A
NLDSBM:	AOS SRN5(U)
	JRST NLDSB4
NLDSB5:	SUB P,[1,,1]
NLDSBQ:	MOVEI B,NLDSBC
	HRRM B,QPCLSR(A)
	MOVE I,EPDL3(U)
	MOVEM I,SRN4(U)
NLDSBC:	HRRZI C,SRN4(U)
	HRLI C,(SETZ)
	PUSHJ P,QBI	;DO TRANSFER
NLDSBI:	MOVEI B,NLDSBJ
	HRRM B,QPCLSR(A)
	HRROI I,EPDL3(U)
	MOVEM I,SRN4(U)
NLDSBJ:	HRRZI C,SRN4(U)
	HRLI C,(TRN)
	PUSHJ P,QBI	;IGNORE CKSUM
	JRST NLDSBK

NLDSB6:	LDB D,[1200,,QSMPRP(A)]
	SKIPGE QSMDN(A)
	MOVEI D,0
	ADD D,QFBLNO(A)
	SUBI D,1
	MOVEM D,QRADAD(A)
	MOVSI D,100
	IORM D,QSRAC(A)
	MOVEI B,NLDSBA
	HRRM B,QPCLSR(A)
NLDSBA:
NLDSB8:	AOS (P)
NLDSB9:	PUSHJ P,MPLDZ
	SETZM QPCLSR(A)
	SKIPL SRN3(U)
	CAMN U,SRN3(U)
	POPJ P,
	JRST NLDSBL	;UNSTOP USER
NLSBP:	SKIPGE SRN3(U)
	JRST 4,.
	PUSH P,U
	PUSHJ P,SWTL
	CIRPSW
	HRRZ A,SRN5(U)	;VIRTUAL PAGE NUMBER
	MOVE U,SRN3(U)	;USER INDEX
	PUSH P,A
	PUSHJ P,PAGERT	;FREE THE PAGE
	POP P,TT
	PUSHJ P,LSWPOP
	LSH TT,9
	IOR TT,[4000,,400000]
	MOVE U,USER
	MOVE Q,SRN3(U)
	PUSHJ P,NCBLK	;GET FRESH PAGE (WILL PCLSR OUT IF SELF)
	JRST POPUJ
	JRST POPUJ1

NLSBPL:	POP P,A
	SUB P,[1,,1]	;PUSH OF E
	JRST NLDSB9

;	.CALL ADR

;ADR:	SETZ
;	SIXBIT /PAGEID/
;	ARG1
;	ARG2
;	402000,,ARG3

;ARG1:	N	;VIRTUAL PAGE NUMBER (MUST NOT BE ZERO)
;ARG2:	ID	;SIX BITS OF IDENTIFIER (1.1-1.6)
;ARG3:		;SET TO -1 IF NEW PAGE CREATED,
		;0 IF LINKED TO EXISTING PAGE

;INSERTS A PUBLIC PAGE WITH IDENTIFIER -ID- IN USERS MAP
;AS PAGE SPECIFIED BY FIRST ARGUMENT.  IF A PUBLIC PAGE
;WITH IDENTIFIER -ID- ALREADY EXISTS, THAT PAGE WIL BE
;INSERTED IN THE USERS MAP.  IN THE FIRST CASE ARG3 WILL
;BE SET TO -1, IN THE SECOND CASE IT WILL BE SET TO 0.
;SKIPS UNLESS BAD ARGUMENTS OR RANDOMNESS.

APGID:	JUMPL A,OPNL33
	CAIL A,400
	JRST OPNL33
	PUSHJ P,SWTL
	PGIDSW
	ANDI B,MEMIDM
	PUSH P,A
	PUSH P,B
	MOVNI A,1
	SKIPE C,MEMID(B)	;SKIP IF NO ENTRY FOR THIS ID
	MOVEI A,0	;ENTRY ALREADY EXISTS
	PUSHJ P,SYSCPT	;STORE INDICATION
	JUMPN C,APGID1	;LINK WITH EXISTING ENTRY
	MOVE TT,-1(P)	;VIRTUAL PAGE NUMBER
	LSH TT,11
	IOR TT,[5400,,400000]
	MOVE Q,U	;USER REQUEST IS FOR
	PUSHJ P,NCBLK
	JRST PGIDL
	PUSHJ P,SWTL
	CIRPSW
	MOVE A,-1(P)
	PUSHJ P,UPLC
	MOVE C,Q	;BYTE POINTER TO CIRCULAR POINTER ENTRY
	PUSHJ P,UCPRL
	200000,,.+2	;RETURN ON MMP
	JRST 4,.	;NO MMP ENTRY
	SUB P,[4,,4]
	MOVE U,USER
	MOVE B,(P)
	MOVEM C,MEMID(B)
	AOS MEMIDU
	PUSHJ P,LSWPOP
	SUB P,[2,,2]
	JRST LSWPJ1

APGID1:	PUSHJ P,SWTL
	CIRPSW
	PUSHJ P,UCPRL
	400000,,.+2
	JRST 4,.	;NO USERS IN LIST
	SUB P,[4,,4]
	MOVE A,U
	IDIVI A,LUBLK
	MOVE U,USER
	LSH A,22
	IOR A,[3400,,400000]
	IOR A,I
	MOVE TT,-1(P)
	LSH TT,11
	IOR TT,A
	PUSHJ P,LSWPOP
	MOVE Q,U	;USER REQUEST IS FOR
	PUSHJ P,NCBLK
	JRST PGIDL
	SUB P,[2,,2]
	JRST LSWPJ1

PGIDL:	SUB P,[2,,2]
	JRST LSWPOP

	EBLK
PGIDSW:	-1
	0
	BBLK

ASUPSET:	MOVEI C,177777	;OPER 53
	XCTR XRW,[AND C,(J)]
	MOVE D,SUPCOR	;SAVE OLD CONTENTS
	XORB C,SUPCOR
	XCTR XW,[MOVEM C,(J)]
	HRROI A,SUPCOR
	JRST ASPST2

;DESTROY PROCEDURE TREE WHOSE TOP INDEX SUPPLIED BY USER
AGUN:	PUSHJ P,LDISOW	;ILLEGAL FOR DISOWNED PROCEDURE
	XCTR XRW,[SKIPG A,(J)]
	POPJ P,		;LOSE, NEG OR SYSTEM JOB
	IMULI A,LUBLK
	CAMGE A,USRHI
	CAIG A,LUBLK
	POPJ P,		;LOSE, TOO BIG OR CORE JOB
	SKIPA T,U
AGUN1:	HRRZ T,SUPPRO(T)
	SKIPL SUPPRO(T)
	JRST AGUN1
	CAME A,DMONX	;(HA, HA, YOU CAN'T SLAY ME)
	CAIN T,(A)	;DON'T ALLOW TO GUN DOWN SELF
	POPJ P,
	CONO PI,CLKOFF	;STOP TIMING ERR DUE TO CHANGING USER VARS
	MOVE T,APRC(A)
	TLNE T,BULGO+BULGOS
	JRST CLKOJ1	;THIS GUY ALREADY GOING AWAY
	SKIPE UNAME(A)
	SKIPL SUPPRO(A)
	JRST CLKONJ	;LOSE, NONEXTANT OR NOT TOP LEVEL
	PUSHJ P,1USTOP	;STOP VICTIM
	PUSH P,U
	PUSH P,A
	MOVE U,A
	SKIPL APRC(U)
	PUSHJ P,SDTTY
	JFCL
	PUSHJ P,IODCL	;CLOSE CHNLS
	POP P,A
	POP P,U
	MOVSI T,40
	PUSHJ P,CWAIT	;WAIT TILL BIT FREE
	TDNE T,SUPCOR
	MOVEM A,USRGUN
	MOVE A,UNAME(U)	;STORE UNAME&JNAME OF GUNNER
	MOVEM A,UNGUNR
	MOVE A,JNAME(U)
	MOVEM A,JNGUNR
	IORM T,SUPCOR	;CAUSE SYSGUN ROUTINE TO RUN
	JRST CLKOJ1
;
;	REAL TIME USER FEATURE
;
;.REALT AC,	SKIPS ONLY IF REAL TIME FACILITY REQUESTED AND SEIZED
;AC=	4.9=>TURN OFF OLD CLOCK RATE, FLUSHING REAL TIME FACILITY AND
;		 REMAINDER OF CURRENT TICK AND ZEROING TICK COUNT
;	4.8=>TURN ON NEW CLOCK RATE
;	4.7=>TRY TO SEIZE REAL TIME USER FACILITY
;	4.6=>DON'T SETTLE FOR PSEUDO-REAL TIME STATUS
;	4.5 =>ONLY WANT PSEUDO
;	4.4=>PROGRAM TO BE BLOCKED EXCEPT FOR HIGH PRIORITY PHASE OR INT. LEVEL
;	4.3=>READ INTO WD3+4 AS DESCRIBED BELOW (BEFORE ANY OTHER BITS INTERPRETED)
;	3.1-4.2=RESERVED FOR EXPANSION, SHOULD BE ZERO
;	1.1-2.9=RH=POINTER TO 4 WORD BLOCK
;	WD1=FRAME TIME IN 60'THS (MUST BE <2**18.)
;	WD2=PRIORITY TIME IN 60'THS (MUST BE <7 AND <WD1/2)
;	WD3= IF 4.3 ON, SET RH TO FRAME TIME, LH TO TICKS SINCE EXAMINED
;	WD4= IF 4.3 ON, SET RH TO HIGH PRIORITY TIME, LH TO 0 IF CURRENTLY LOW
		;PRIORITY OR -1 IF CURRENTLY HIGH PRIORITY
;
AREALT:	XCTR XR,[MOVE A,(J)]
	TLNN A,4000
	JRST AREAL1
	CONO PI,CLKOFF
	MOVE T,UTIME(U)
	MOVE Q,URTIME(U)
	CONO PI,CLKON
	XCTR XW,[MOVEM T,2(A)]
	XCTR XW,[MOVEM Q,3(A)]
AREAL1:	TLNN A,700000
	POPJ P,
	HRRZ T,UREALT
	CAMN T,U
	SETOM UREALT
	SETZM URTIME(U)
	TLNN A,400000
	JRST AREAL2
	PUSHJ P,CLQDEL	;TURN OFF OLD INTS
	UCLBLK(U)
	SETZM UTIME(U)	;ZERO TICK COUNT
AREAL2:	TLNN A,200000
	JRST AREAL4
	XCTR XRW,[SKIPG T,(A)]
	JRST ILUUO
	HRRM T,UTIME(U)
AREAL4:	TLNN A,100000
	JRST AREAL6
	XCTR XRW,[SKIPLE T,1(A)]
	CAIL T,13.
	JRST ILUUO
	HRRZ B,UTIME(U)
	LSH B,-1
	CAMLE T,B
	JRST ILUUO
	HRROS T
	TLNE A,10000
	TLZ T,1
	MOVEM T,URTIME(U)
	TLNE A,20000
	JRST AREAL6
	CONO PI,CLKOFF
	SKIPGE UREALT
	JRST AREAL7
	TLNE A,40000
	SETZM URTIME(U)
	JRST AREAL5
AREAL7:	MOVEM U,UREALT
	AOS (P)
AREAL5:	CONO PI,CLKON
AREAL6:	SKIPN T,UTIME(U)
	POPJ P,
	SKIPE B,URTIME(U)
	MOVE T,B
	HRRZS T
	PUSHJ P,CLQADD
	UCLBLK(U)
	JRST UDELAY	;TRY TO STOP MONOPOLIZATION BY USER DOING MANY .REALT'S


;CLOCK LEVEL ROUTINE
UREALB:	SUBI U,UCLBLK	;SET INDEX TO QUEUE BLOCK
	SKIPE B,URTIME(U)
	JRST URLTB2
URLTB1:	MOVSI T,(NCLOKB)
	IORM T,PIRQC(U)
	MOVSI T,1
	ADDM T,UTIME(U)
	HRRZ T,UTIME(U)
	SKIPGE B
	HRRZ T,B
URLTBX:	SETZM SCHFLG	;CAUSE SCHEDULE THIS CLOCK BREAK
	MOVEI C,UCLBLK(U)
	JRST CLQREE

URLTB2:	TLC B,-1
	MOVEM B,URTIME(U)
	MOVSI T,1
	HRRZ C,UREALT
	JUMPGE B,URLTB4
	CAMN C,U
	HRRZS UREALT
	JRST URLTB1

URLTB4:	CAMN C,U
	IORM T,UREALT
	HRRZ T,UTIME(U)
	HRRZS B
	SUB T,B
	JUMPG T,URLTBX
	JRST 4,.
;
;.CLOSE CH,	;CLOSE ANY I/O TRANSACTION OPEN ON CHANNEL CH
;
NCLOSE: MOVE R,A
	CAIL R,20
	JRST OPNL14
	AOS (P)
	ADDI R,IOCHNM(U)
ACLOSE:	HLRZ A,(R)	;SET UP A WITH L.H. OF I/O CH WORD
	HRRZ B,(R)	;SET UP B WITH R.H. "
	MOVE C,CLSTB(B)	;GET CLOSE TABLE ENTRY
	TLNE C,400	;SKIP IF NOT STANDARD CLOSE
	JRST STDCLS	;JUMP TO STANDARD CLOSE
	PUSH P,R	;SAVE R
	PUSHJ P,(C)	;CALL CLOSE ROUTINE
	POP P,R		;RESTORE R
STDCLX:	SETZM (R)	;CLEAR I/O CHANNEL WORD
	SETZM IOCHST-IOCHNM(R)	;CLEAR I/O CHNL STATUS WORD
	POPJ P,

STDCLS:	CONO PI,CLKOFF	;INHIBIT CLOCK BREAKS
	SOSGE 1(C)	;DECREMENT USE COUNTER, SKIP IF STILL IN USE AT LEAST ONCE
	SETOM (C)	;NO LONGER IN USER, FREE BY SETOM'ING "XXXUSR" VARIABLE
	CONO PI,CLKON	;ENABLE CLOCK BREAKS
	JRST STDCLX

NVALUE:	AOSA (P)
AVALRET:	XCTR XR,[MOVE A,(B)]	;CALL 4,
	MOVEM A,VALUE(U)
	MOVEI T,VALRTF
	JRST ILLOP4

AUTRAN:	MOVEI A,0	;CALL 5,
	XCTR XR,[MOVE C,(B)]
	HRR C,U
UTRNL:	SKIPN UNAME(A)
	JRST UTRNA
	CAMN C,SUPPRO(A)
	JRST UTFND
UTRNA:	CAML A,USRHI
	POPJ P,
	ADDI A,LUBLK
	JRST UTRNL

UTFND:	MOVE C,UNAME(A)
	XCTR XW,[MOVEM C,1(B)]
	MOVE C,JNAME(A)
	XCTR XW,[MOVEM C,2(B)]
	JRST POPJ1


;RETURN WITH LOSER IN A IN LOSER MODE AND CLOCK OFF
;
RPCCK:	PUSHJ P,RPCLSR	;STOP USER (ALSO PUTS HIM IN USER MODE)
	CONO PI,CLKOFF	;TURN OFF CLOCK
	JRST UPCLSR	;"RESTART USER" (HE CAN'T RUN TILL CLOCK BACK ON)

AUCLOSE:
IFN PDP6P,[
	MOVE A,(R)	;OPER 10
	MOVE A,CLSTB(A)
	TLNE A,100
	JRST PDPUCL
]
	PUSHJ P,AUCL2
	EXCH U,A
	PUSH P,A
	HLLZ T,SUPPRO(U)
	PUSH P,T
	PUSH P,R
	MOVEI B,0
	PUSHJ P,UBLAST
	POP P,R
	MOVE TT,UTRNTM(U)
	MOVE D,UTMPTR(U)
	ADDM TT,NCTIM-USRRCE(D)
	MOVE TT,USIPRQ(U)
	ADDM TT,NSIPRQ-USRRCE(D)
	PUSHJ P,ZUSER
	CONO PI,CLKON
	POP P,T
	POP P,A
	EXCH U,A
	ANDCAM T,IFPIR(U)
	POPJ P,

AUCL2:	HLRZ A,(R)	;GUY BEING CLOSED
	HRRZ B,(R)
	LDB TT,[330100,,CLSTB(B)]
	JUMPN TT,URET	;NOT INFERIOR
	SKIPL CLSTB(B)
	JRST IOCER7
	CONO PI,CLKOFF
	MOVE TT,TTYTBL(U)
	JUMPGE TT,AUCL1	;HAVE TTY NOW
	CAIE A,(TT)	;SKIP IF GAVE IT TO GUY WE'RE KILLING
	JRST AUCL1
	TLNN TT,100000	;SKIP IF TAKEN AWAY
	JRST AUCL3
	MOVSI TT,10000	;MAKE IT LOOK LIKE TTY WAS
	IORM TT,TTYTBL(U)	;TAKEN FROM --ME--
	JRST AUCL1
AUCL3:	PUSHJ P,SDTTY
	JFCL
AUCL1:	CONO PI,CLKON
	HLRZ A,(R)
	JRST 1USTOP	;STOP USER & RETURN

AMASTER:	XCTR XR,[MOVE J,(J)]
	CONO PI,CLKOFF	;OPER 61
	SKIPL A,UMASTER
	JRST AMAST2
	SKIPGE J
AMAST1:	HRRZM U,UMASTER
	JRST CLKOJ1

AMAST2:	CAME U,A
	JRST AMAST3
	SKIPL J
	SETOM UMASTER
	JRST CLKOJ1

AMAST3:	JUMPGE J,CLKOJ1
	SKIPE TTYTBL(U)
	JRST CLKONJ	;LOSEY
	PUSHJ P,RPCCK
	CAME A,UMASTER
	JRST AMASTER
	JRST AMAST1

ADISMIS:	XCTR XR,[MOVE B,(B)]	;CALL 1,
	TLO B,LSRMOD
	TLZ B,BADPC
	SKIPGE IOTLSR(U)
	TLO B,IOTFLG
	MOVEM B,UUOH
APISE1:
IFN PDP6P,[
	CAMN U,PDPISR
	CONO DSDEV,DSDCHN	;ENABLE INTERRUPT FROM 10
]
	MOVSI B,-NCT	;SEE IF ANY TTY INTERRUPTS PENDING: IF SO SET PIRQC,IFPIR BITS
	MOVEI E,200000
ADISM4:	MOVE D,TTYSTS(B)
	CAIE U,(D)
	JRST ADISM5	;USER DOESN'T HAVE THIS TTY
	SKIPE TTNTO(B)
	SKIPN TINTC(B)
	JRST ADISM5	;NOT OPEN OR NO CHARACTERS AT INTERRUPT LEVEL
	TLNN D,BCNSBT
	JRST ADISM2	;NOT CONSOLE
	MOVEI C,TTYIF
	IORM C,PIRQC(U)
ADISM2:	MOVE C,TYIMSK(B)	;GET CHANNELS OPEN MASK
ADISM6:	IORM C,IFPIR(U)	;AND GENERATE INTERRUPT REQUEST
ADISM1:	AOBJN B,ADISM4
IFN STKP,[
	SKIPL C,STKUSR
	CAIE C,(U)
	JRST ADISM3
	HRRZ C,STKMSK
	AND C,MSKST2(U)
	SKIPLE STKBC
	IORM C,IFPIR(U)
]
ADISM3:	MOVEI C,AROIF
	ANDCAB C,PIRQC(U)
	SETOM PICLR(U)
	AND C,MSKST(U)
	ANDCM C,IDF1(U)
	JUMPN C,ADISM7
	MOVE C,IFPIR(U)
	AND C,MSKST2(U)
	ANDCM C,IDF2(U)
	JUMPE C,CPOPJ
ADISM7:	MOVE C,[JRST ONEFLS]
	MOVEM C,UEXIT
	POPJ P,

ADISM5:	TDNN E,TTYTYP(B)	;SKIP IF STY
	JRST ADISM1
	SKIPL D,STYSTS-NFSTTY(B)	;DON'T INT BACK IF OPEN IN "DON'T HANG" MODE
	CAIE U,(D)
	JRST ADISM1
	SKIPGE TTYOAC(B)
	JRST ADISM1
	MOVE C,STYMSK-NFSTTY(B)
	JRST ADISM6

;.SLEEP AC,	;IF C(AC) + OR ZERO:	;BECOME DORMANT FOR C(AC) 1/30'THS OF A SEC
		;IF C(AC) -:	;BECOME DORMANT TILL MAGNITUDE OF C(AC) > C(TIME)
ASLEEP:	XCTR XR,[MOVN T,(J)]	;PICK UP NEGATIVE OF C(AC)
	JUMPGE T,ASLP1	;JUMP IF C(AC) WAS NEG
	SUB T,TIME	;COMPUTE NEG OF TIME SLEEP SHOULD RUN OUT
	XCTR XW,[MOVEM T,(J)]	;STORE BACK SO YOU WILL WIN IF PCLSR'ED OUT
ASLP1:	MOVMS A,T		;MAKE POSITIVE
	SUBI A,10.*60.*30.
	MOVSI B,400000
	CAMLE A,TIME
	IORM B,USWST(U)	;PUT RIP VAN WINKLE ON  ICE
	PCLT
	JRST ASLP2	;ALWAYS GO TO UFLS AT LEAST ONCE

	CAMLE T,TIME	;HANG TILL C(T) LESS THAN C(TIME)
ASLP2:	PUSHJ P,UFLS
	XCTR XRW,[SETZM (J)]	;CLEAR OUT ARG (FOR COMPATIBILITY WITH WHEN AC WAS COUNTED OUT)
	JRST CLKONJ	;MAKE SURE CLKCHN ON IN CASE SLEEP WAS 0 & SKIPPED UFLS ENTIRELY

;RELOAD CALL - IGNORE ARGS
;MUST BE FROM TOP LEVEL NON-DISOWNED JOB
;RELOADS AND STARTS SYS: ATSIGN WHATEVER

NRELOA:	SKIPGE SUPPRO(U)
	SKIPGE APRC(U)
	POPJ P,
	CONO PI,CLKOFF
	PUSHJ P,USRST2	;RESET USER VARS
	CONO PI,CLKON
	SETZM @UTMPTR(U)
	JRST USTCDR	;LOAD FILE AND START IT

NLOGIN:	MOVE T,UNAME(U)	
	AOJN T,CPOPJ	;JUMP ON ALREADY LOGGED IN
	JUMPE A,CPOPJ
	CAMN A,[-1]
	JRST OPNL33		;BAD NAME
	MOVEI C,0
	CONO PI,CLKOFF
ALOG2:	MOVE T,JNAME(C)
	CAMN T,[SIXBIT /HACTRN/]
	CAME A,UNAME(C)
	JRST ALOG3
	SKIPL APRC(C)
	JRST CLKONJ	;CONSOLE CONTROLLED TREE ALREADY LOGGED IN THAT NAME
ALOG3:	ADDI C,LUBLK
	CAMGE C,USRHI
	JRST ALOG2	;LOOP FOR ALL SETS OF PROCEDURE VARIABLES
	MOVSI T,400
	HRRZ D,TTYTBL(U)
	PUSHJ P,CWAIT	;WAIT TILL YOU CAN CAUSE MESSAGE TO BE TYPED OUT
	TDNE T,SUPCOR
	MOVEM A,SLGIV
	MOVEM D,SLGIV+1
	MOVEM B,SLGIV+2
	IORM T,SUPCOR
	SKIPL TTYTBL(U)	;SKIP IF NOT CONSOLE CONTROLLED
	AOS SUSRS	;INCREMENT COUNT OF LOGGED IN CONSOLE CONTROLLED TREES
	MOVEM A,UNAME(U)	;SET UNAME TO WHAT LOGGED IN AS
	MOVEM A,USYSNM(U)	;SET SNAME "
	MOVEM B,TRMNAM(U)
	CONO PI,CLKON	;TURN ON CLOCK & EXIT SKIPPING (SUCCESS)
	JRST DMNPLI	;GIVE INFO TO DEMON AND SKIP

ARSYSI:	MOVE A,[.FNAM2]	;OPER 17
	JRST APTUAJ

ASETM2:	XCTR XR,[MOVE A,1(J)]	;.OPER 60
	MOVEM A,MSKST2(U)
ASETMSK:	XCTR XR,[MOVE A,(J)]	;OPER 4
	TRZ A,VBDBTS	;MAKE SURE THESE GO TO SUP. PRO.
	MOVEM A,MSKST(U)
	MOVEI B,440+APRCHN
	TRNE A,AROIF
	TRC B,60
	TLNE A,(ARFOIF)
	TRC B,600
	HRRM B,APRC(U)
	CONO @APRC(U)
	POPJ P,

ARDTIME:	SKIPA A,TIME	;OPER 17
ARDSW:	DATAI A	;OPER 20
	JRST APTUAJ

;	.CALL DET
;	ERROR RETURN
;	NORMAL RETURN

;DET:	SETZ
;	SIXBIT /DETACH/
;	SETZ [<JOB SPEC>]	;SEE NCORUI

;DISOWN JOB'S ENTIRE TREE AND FREE CONSOLE.  IF TREE HAS NO
;CONSOLE, DOES NOTHING BUT SKIPS.  NO ARG => THIS JOB'S TREE

NDETAC:	MOVEI J,(U)	;DEFAULT TO OUR TREE
	JUMPE W,NDETA0	;JUMP IF NO ARGS SUPPLIED
	MOVE J,A	;JOB SPEC
	JSP T,NCORUI	;DECODE ARG, GET USER INDEX IN J
	JFCL	;IGNORE INFO ON WRITEABILITY
NDETA0:	SKIPL T,SUPPRO(J)	;FIND TOP LEVEL JOB OF TREE (IN J)
	JRST [MOVE J,T ? JRST NDETA0]
	HRRZ A,J	;TOP OF TREE
	MOVE B,TTYTBL(A)
	TLNE B,300000	;NEVER HAD TTY OR TAKEN AWAY
	JRST POPJ1	;TREE HAS NO TTY
	MOVEI Q,NDETA8
	PUSHJ P,IFPLUP	;STOP ALL BUT THIS JOB
	MOVEI T,0	;DO TYPE CONSOLE FREE MSG
	PUSHJ P,NDETA7	;DO THE WORK
	AOS (P)
	JRST LSWCLR	;UNSTOP THE CLEAR

NDETA7:	PUSH P,T
	PUSH P,U	;US
	PUSH P,A	;TOP LEVEL
NDETA1:	MOVEI U,(A)	;GET IN U USER INDEX OF OWNER OF TTY
	SKIPGE A,TTYTBL(U)	;GET IN A TTY NUMBER
	JRST NDETA1	;GAVE TTY AWAY
	PUSH P,TTYSTS(A)	;SAVE THIS TTY INFO
	PUSH P,TTYST1(A)	;WILL PUT INTO TTY OWNER'S USER VARS
	PUSH P,TTYST2(A)	;AFTER SUCCEED IN FREEING THE TTY
	PUSH P,TCECL(A)
	MOVEI R,IOCHNM(U)	;FAKE OUT TYICLS
	AOS TTNTO(A)
	PUSHJ P,TYICL4	;FLUSH INPUT BUFFER, ETC.
	MOVEI B,200000
	TDNN B,TTYTYP(A)	;WAIT FOR OUTPUT TO FINISH UNLESS TO STY
	PUSHJ P,TYOW
	HRLOI B,(SETZ)	;DON'T SEE ^Z ON TTY FOR A WHILE
	IORB B,TTYSTS(A)
	TLZ B,BCNSBT	;FAKE OUT SYS JOB VIA TTYLO5
			;CAUSE CONSOLE FREE MSG, BUT NOT LOGOUT MSG
	SKIPN -6(P)	;DONT DO THIS IF CALLED BY NATTAC
	PUSHJ P,[	SKIPE USER
		JRST TTYLO5
		SETZB T,TTNTO(A)
		PUSHJ P,NDETA4	;IF SYS JOB, TYPE CONSOLE FREE MSG NOW
		JRST SYSDT3]		;RATHER THAN WAITING TO TELL SYS JOB VIA SUPCOR
	POP P,B		;CAN'T PCLSR AFTER THIS POINT
	DPB B,[220600,,TTYTBL(U)]
	POP P,TTSTSV+1(U)	;STORE INTO TTY'S OLD OWNER
	POP P,TTSTSV(U)	;OLD TTY VARS FROM BEFORE FREEING IT
	POP P,B
	ANDCM B,HARBTS
	MOVEM B,TTSTSV+2(U)
	MOVSI B,100000	;TTY TAKEN AWAY
	SKIPA A,(P)	;TOP LEVEL JOB
NDETAA:	HRRZ A,T
	IORM B,TTYTBL(A)	;TTY TAKEN AWAY FROM ALL JOBS IN TREE
	SKIPGE T,TTYTBL(A)	;SKIP IF HE HAS IT
	JRST NDETAA	;NOW DO GUY HE GAVE IT TO
	CAIE A,(U)
	JRST 4,.	;BUT.  BUT.  BUT.
	MOVSI B,410000	;TAKEN FROM --ME-- AND DOESN'T HAVE IT
	IORM B,TTYTBL(A)
	POP P,A	;TOP LEVEL
	POP P,U	;US
	SUB P,[1,,1]
	MOVE D,JNAME(A)	;IF TOP LEVEL JOB ...
	CAME D,[SIXBIT /HACTRN/]	;IS A HACTRN,
	JRST NDETA3
NDETA2:	AOS D		;AOS ITS NAME LEVEL UNTIL ...
	PUSHJ P,UJNAMU	;IT IS UNIQUE
	JRST NDETA2	;(UJNAMU TURNS OFF CLOCK)
	MOVEM D,JNAME(A)
	CONO PI,CLKON
NDETA3:	MOVEI Q,NDETA9	;NOW SAY ALL JOBS IN TREE
	PUSHJ P,IFPLUP	;ARE DISOWNED
	SOS SUSRS	;ONE LESS CONSOLE CONTROLLED TREE
	POPJ P,


NDETA8:	CAIE A,(U)	;IF JOB ISN'T SELF, STOP IT
	JRST IFSTOP
	POPJ P,
;	.CALL ATT
;	ERR RET
;	NORMAL RET

;ATT:	SETZ
;	SIXBIT /ATTACH/
;	400000,[<JOB SPEC>]

NATTAC:	MOVE J,A
	JSP T,NCORUI	;DECODE 1ST ARG, GET USR IDX IN J.
	 JFCL
	HRRZ A,SUPPRO(J)
	CAIE A,(U)
	 JRST OPNL31	;MUST BE OUR INFERIOR.
	SKIPL SUPPRO(U)
	 JRST OPNL40	;WE MUST BE TOP LEVEL.
	SKIPGE B,TTYTBL(U) ;ERROR IF WE HAVE TTY.
	CAIE J,(B)
	 JRST OPNL10	;ERROR UNLESS WE GAVE IT TO HIM.
	TLNE B,300000
	 JRST OPNL10	;ERROR IF WE NEVER HAD TTY OR WAS TAKEN AWAY.
	PUSH P,J
	MOVE A,U
	MOVEI Q,NDETA9
	PUSHJ P,IFPLUP	;STOP ALL OUR INFERIORS.
	MOVE B,TTYTBL(B) ;FIND THE TTY'S NUMBER.
	JUMPL B,.-1
	AOS TTNTO(B)	;KEEP DSWNTZ FROM HALTING (WILL UNDO THIS LATER)
	MOVE J,(P)
	SETOM SUPPRO(J)	;DON'T LET NEXT USE OF IFPLUP INCLUDE THAT JOB.
	PUSH P,B	;REMEMBER TTY NUMBER.
	MOVEI Q,[PUSHJ P,CHSCAA
		PUSHJ P,DSWNTZ	;FLUSH ALL TTY CHNLS.
		POPJ P,]
	PUSHJ P,IFPLUP	;SET TTNTO= # TTY CHNLS IN THAT JOB'S SUBTREE.
	POP P,B
	SOS TTNTO(B)
	POP P,A		;THAT JOB'S IDX.
	MOVE J,JNAME(U)
	MOVEM J,JNAME(A) ;GIVE IT OUR JNAME.
	PUSHJ P,NATTA1	;MAKE IT BE TOP-LEVEL.
	 JFCL
	PUSHJ P,LSWCLR	;UNSTOP ALL THOSE JOBS.
	SETOM TTYTBL(U)	;DON'T WANT ALOGOU TO TYPE LOGOUT MESSAGE.
	JRST ALOGOUT	;LOG THIS JOB OUT.

;.DISOWN CH,	;MAKES DIRECTLY INFERIOR PROCEDURE OPEN ON CHANNEL CH
		;THE TOP LEVEL JOB OF A DISOWNED JOB
ADISOWN:	PUSHJ P,LDISOW	;ILLEGAL FOR PROCEDURE IN A DISOWNED TREE
	HRRZ B,(R)	;PICK UP CH TYPE INDEX
	SKIPL CLSTB(B)	;SKIP IF AN INF. USER CHANNEL
	JRST IOCER7	;OTHER TYPE, GIVE IOC ERROR
	HLRZ A,(R)	;PICK UP INF.'S INDEX
	MOVE B,TTYTBL(A)
	TLNN B,300000	;SKIP IF NEVER HAD TTY OR TTY TAKEN AWAY
	POPJ P,
	MOVEI Q,DSWNTY
	PUSHJ P,IFPHAK	;HACK INFERIORS
	PUSHJ P,LSWCLR	;RESTART THEM
NATTA1:	EXCH U,A
	PUSHJ P,ZUSES	;FLUSH POINTERS TO INFERIOR
	EXCH U,A
	SETOM SUPPRO(A)	;MARK AS TOP LEVEL
	JRST POPJ1	;SUCCESS EXIT

DSWNTY:	MOVE B,TTYTBL(A)	;GET TTY INFO ON INF.
	TLNN B,300000	;SKIP IF NEVER HAD TTY OR TTY TAKEN AWAY
	JRST 4,.	;CHECKED AT HIGHER LEVEL, DATA INCONSISTENT
	PUSHJ P,CHSCAA	;LOOK AT ALL CNHLS
	PUSHJ P,DSWNTZ	;BLESSING CONSOLE TTY CHNLS
NDETA9:	MOVEI TT,USRRCE+NCT
	MOVEM TT,UTMPTR(A)	;SET RESOURCE POINTER TO COMMON DISOWNED JOB VALUE
	MOVSI T,400000
	IORM T,APRC(A)	;MARK AS DISOWNED
	POPJ P,

;BLESS CONSOLE TTY CHANNELS
DSWNTZ:	MOVS B,(R)	;GET IOCHNM WORD
	HLRZ J,B	;GET DEV TYPE INDEX
	CAIL J,TYIDN	;SKIP IF LESS THAN LEAST TTY INDEX
	CAILE J,TYOBN	;SKIP UNLESS .LTEQ. HIGHEST
	POPJ P,		;NOT A TTY CHANNEL
	TRZ B,377700
	TRZE B,400000	;SKIP IF NOT A CONSOLE TTY
	SOSE TTNTO(B)	;DECREMENT OPEN COUNT
	POPJ P,
	JRST 4,.	;SHOULD BE OPEN AT HIGHER LEVELS

;ROUTINE TO SCAN ALL I/O CHANNEL AND I/O PDL SLOTS OF A PROCEDURE
;R 4.9=1 => REGULAR CHANNEL  4.9=0 => IOPUSHED CHANNEL
CHSCAA:	MOVEI R,IOCHNM(A)
CHSCAN:	HRLI R,-20
CHSCA2:	XCT @(P)
	AOBJN R,CHSCA2
	HRLI R,-<LUIOP/2>+400000
CHSCA4:	XCT @(P)
	ADD R,[1,,2]
	JUMPG R,CHSCA4
	JRST POPJ1
;
;IFPHAK AND IFPLUP TAKE A USER INDEX IN A AND THE ADDRESS OF A ROUTINE
;	IN Q.  THEY CALL THE ROUTINE FOR THE PROCEDURE AND ALL OF ITS
;	INFERIORS BUT IFPHAK ALSO STOPS THE SPECIFIED PROCEDURE AND
;	ALL ITS INFERIORS STRINGING THEIR USTP'S INTO THE CURRENT USER'S
;	LSWPR.
;
IFPHAK:	PUSH P,U
	PUSH P,Q
	MOVE U,USER	;MADE SURE YOU USE THE RIGHT LSWPR
	MOVEI Q,IFSTOP	;SET UP TO STOP
	PUSHJ P,IFPLUP
	POP P,Q
	POP P,U
IFPLUP:	PUSH P,E	;SAVE E
	PUSH P,H	; " H
	SKIPA H,A
IFPLU5:	MOVE A,E	;RECURSE
	PUSH P,H
	PUSH P,Q
	PUSHJ P,(Q)	;CALL ROUTINE
	POP P,Q
	POP P,H
	MOVEI E,LUBLK*2	;INITIALIZE TO INDEX OF JOB AFTER CORE JOB
IFPLU2:	SKIPN UNAME(E)
	JRST IFPLU3
	HRRZ T,SUPPRO(E)
	CAIN T,(A)
	JRST IFPLU5
IFPLU3:	ADDI E,LUBLK	;STEP TO NEXT VAR BLOCK
	CAMGE E,USRHI	;SKIP IF ALL EXAMINED
	JRST IFPLU2	;NOT ALL, CONTINUE
	CAME H,A	;ALL, SKIP IF BACK TO TOP LEVEL
	JRST IFPLU4	;NOT AT TOP LEVEL, POP UP
	POP P,H		;RESTORE H
	POP P,E		; " E
	POPJ P,		;RETURN FROM CALL TO IFPLUP

IFPLU4:	MOVE E,A	;POP
	HRRZ A,SUPPRO(A)	;UP
	JRST IFPLU3	;AND CONTINE

IFSTOP:	PUSHJ P,RPCLSR	;STOP ROUTINE WHOSE INDEX IS IN A
	HRRZ T,USTP(A)
	SOJE T,IFSTP1
	SKIPE LSWB0+1(A)
	JRST UPCLSR	;HAVE ALREADY HACKED THIS GUY
IFSTP1:	MOVEI T,USTP(A)	;GET LOC OF USTP (WAS AOSED BY RPCLSR)
	MOVEI H,LSWB0(A)	;GET LOC OF A LOCKED SWITCH BLOCK OF PROC STOPPED
	MOVEM T,(H)	;SET WD1
	PUSH P,U
	HRRZ T,U
	IDIVI T,LUBLK
	POP P,U
	HRL T,LSWPR(U)
	IORI T,600300	;SOS WHEN UNLOCKED
	MOVSM T,1(H)
	MOVEM H,LSWPR(U)	;ADD TO LOCKED SWITCH LIST OF USER
	POPJ P,
;
; ROUTINE TO LOG OUT USER WITH TOP PROCEDURE INDEX IN U
;
ALOGO1:	MOVE U,USER
	MOVE P,USRPDL(U)
ALOGOUT:	CONO PI,CLKOFF
	SKIPL SUPPRO(U)	;SKIP IF TOP LEVEL
	JRST CLKONJ		;DO NOTHING UNLESS AT TOP LEVEL
	SETZM PICLR(U)	;INHIBIT INTERRUPTS
	MOVE A,U
	MOVEI B,ALOGO1+1
LOGOPC=ALOGO1+1	;CHECK FOR LOGOPC IN UUOH IF WANT TO KNOW IF LOGGING OUT
	;NOTE:	DOESN'T CATCH .GUN AND FRIENDS
	CAME U,USER
	JRST ALOGO6
	SKIPL RPCL(U)
	JRST ALOGO8
	PUSHJ P,UDELAY
	JRST ALOGOUT

ALOGO8:	MOVSI I,BULGOS
	IORM I,APRC(U)
	MOVEM B,UUOH	;COME BACK HERE NOT TO USER IF PCLSR
	JRST ALOGO7

ALOGO6:	PUSHJ P,1USTOP
ALOGO7:	MOVEI B,0
	PUSHJ P,UBLAM	;FLUSH USER
	MOVSI I,BULGO
	CAMN U,USER
	IORM I,APRC(U)	;INDICATE HAS DONE UBLAM
	SKIPGE APRC(U)
	JRST ALOGO5
	MOVSI I,-NUNITS	;NOT DISOWNED SO FLUSH UTAPE ASSIGNMENTS
	MOVE A,UNAME(U)
	CAMN A,UTASS+1(I)
	SETZM UTASS+1(I)
	AOBJN I,.-2
ALOGO5:	MOVE B,UNAME(U)
	MOVEM B,EPDL(U)
	SKIPGE A,TTYTBL(U)	;DON'T HAVE TTY NOW (DISOWNED)
	JRST ALOGO4
	SKIPE TTNTO(A)
	JRST 4,.	;ALL TTY OPENS SHOULD BE FLUSHED BY NOW
	MOVE B,TTYSTS(A)
	PUSHJ P,TTYLO1	;CAUSE CONSOLE FREE MESSAGE TO BE PRINTED
ALOGO4:	PUSHJ P,DMNPLO	;GIVE INFO TO DEMON TO DUMP OUT ON DISK
	MOVE T,UTRNTM(U)	;TAKE RUN TIME FOR THIS PROCEDURE
	MOVE D,UTMPTR(U)
	ADD T,NCTIM-USRRCE(D)	;ADD TIME FOR KILLED PROCEDURES OF THIS "CONSOLE"
	SETZM NCTIM-USRRCE(D)	;(CLEAR OUT FOR NEXT USER)
	ADDM T,LOUTIM	;ADD TO TIME USED BY LOGGED OUT USERS
	SETZM NSIPRQ-USRRCE(D)	;CLEAR OUT COUNT OF # SWAP IN RQ F TREE
	CAMN U,DMONX
	SETOM DMONX	;DRAGON LOGGING OUT
	PUSHJ P,ZUSER	;FLUSH LAST VESTAGES OF USER (A_U  U_USER)
	MOVE B,EPDL(A)	;RETURNS WITH CLOCK OFF
	AOJE B,ALOGO2	;JUMP IF USER NEVER LOGGED IN
	SKIPL TTYTBL(A)	;SKIP IF NOT CONSOLE CONTROLLED
	SOS SUSRS	;DECREMENT COUNT OF LOGGED IN CONSOLE CONTROLLED PROCEDURE TREES
ALOGO2:	JRST UDELAY	;THE UDELAY THAT NEVER RETURNS (SOMETIMES)

UBLAM:	PUSH P,B
	SKIPL APRC(U)	;SKIP IF DISOWNED
	PUSHJ P,SDTTY	;GET TTY UP TO THIS LEVEL
	JFCL
	JRST UBLST1

UBLAST:	PUSH P,B
UBLST1:	PUSHJ P,IODCL	;CLOSE IO DEVICES ETC
	POP P,B
UBLST2:	PUSH P,U
	MOVE Q,U
	MOVE U,USER
	PUSHJ P,ACRF1	;CORE DOWN TO NUM OF BLOCKS IN B
	JRST 4,.
	POP P,U
	POPJ P,


LDISOW:	SKIPGE APRC(U)	;GO TO ILUUO IF DISOWNED
	JRST ILUUO
	POPJ P,

AASSIGN:	PUSHJ P,LDISOW	;ASSIGN UTAPE
	XCTR XR,[MOVE I,(J)]
	CAILE I,NUNITS
	POPJ P,
	JUMPLE I,CPOPJ
	MOVE A,UNAME(U)
	CONO PI,CLKOFF
	CAMN A,UTASS(I)
	JRST CLKOJ1
	SKIPE UTASS(I)
	JRST CLKONJ
	MOVEM A,UTASS(I)
	JRST CLKOJ1

ADESIGN:	XCTR XR,[MOVE I,(J)]	;DEASSIGN UTAPE
	CAILE I,NUNITS
	POPJ P,
	JUMPLE I,CPOPJ
	SKIPN A,UTASS(I)
	JRST POPJ1
	CAME A,UNAME(U)
	POPJ P,
	SETZM UTASS(I)
	JRST POPJ1

AEOFC:	XCTR XR,[MOVE B,(J)]
	LDB B,[400,,B]	;OPER 50
	ADDI B,IOCHNM(U)
	MOVE A,(B)
	MOVE A,CLSTB(A)
	HLR A,(B)
	TLNE A,40000
	SKIPA A,UTEOF(A)
	MOVEI A,EOFCH
	JRST APTUAJ


		;.OPERS RELEVANT TO REAL TIME

		;.PDTIME AC,	;RETURNS 60.*<# SECS SINCE BEGINNING OF YEAR>

IFN PDCLKP,[
APDTIM:	DATAI PDCLK,A
	TLZ A,600000
	JUMPE A,RETM1
	SKIPN B,PDTIME
	JRST RETM1
	SUB A,B
	JRST APTUAJ
]

		;.RDATE AC,	;RETURNS SIXBIT YYMMDD IN AC

ARDATE:	PUSHJ P,GLPDTM	;GET LOCALIZED PDTIME
	JRST RETM1	;NOT AVAILABLE
	IDIVI A,SPD	;GET # DAYS SINCE BEGINNING OF YEAR
	PUSHJ P,RDATE	;GET THE ANSWER
	JRST APTUAJ	;RETURN IT

		;.RTIME AC,	;RETURNS SIXBIT HHMMSS (24 HOUR TIME) IN AC

ARTIME:	PUSHJ P,GLPDTM	;GET LOCALIZED PDTIME
	JRST RETM1	;NOT AVAILABLE
	IDIVI A,SPD	;GET # SECS SINCE MIDNIGHT IN B
	PUSHJ P,RTIME	;CONVERT TO SIXBIT HHMMSS
	JRST APTUAJ	;RETURN IT

		;.RDATIM AC,	;DOES .RTIME TO AC, .RDATE TO AC+1

ARDATI:	PUSHJ P,GLPDTM	;GET CRUD
	JRST RETM1	;NO LUCK (THIS IS GETTING BORING)
	IDIVI A,SPD	;CONVERT TO DAYS AND SECONDS
	HRLM A,(P)	;SAVE DAYS ON PDL
	PUSHJ P,RTIME	;GET TIME (HHMMSS)
	XCTR XW,[MOVEM A,(J)]	;GIVE TO USER
	HLRZ A,(P)	;GET DAYS AGAIN
	PUSHJ P,RDATE	;CONVERT TO SIXBIT
	AOJA J,APTUAJ	;GIVE TO USER AND RETURN

		;.RYEAR AC,	;PUSHJ'S TO RYEAR AND MOVEM'S E TO AC

ARYEAR:	PUSHJ P,RYEAR	;GET THE CRUFT
	XCTR XW,[MOVEM E,(J)]	;STORE YEAR AND CRUD
	POPJ P,

		;.RLPDT AC,	;DOES .RYEAR AC+1, AND ALSO MOVEM'S A TO AC

ARLPDT:	PUSHJ P,RYEAR	;GET THE CRUFT
	XCTR XW,[MOVEM E,1(J)]	;STORE YEAR AND CRUD
	JRST APTUAJ	;STORE TIME AND RETURN

		;ROUTINE TO RETURN -1 ON AN OPER

IFE PDCLKP,APDTIM:
RETM1:	XCTR XRW,[SETOM (J)]
	POPJ P,

		;GET THE CORRECTED PDUPS*<# SECS SINCE BEGINNING OF YEAR> IN A, SKIP IF OFFSET AVAILABLE AND CLOCK ON

GPDTIM:
IFN PDCLKP,[
	SKIPN A,PDTIME	;GET THE OFFSET
	JRST GPDTM2		;NOT AVAILABLE
	DATAI PDCLK,B	;GET WHAT THE CLOCK IS SAYING
	TLZ B,600000
	JUMPE B,GPDTM2	;POWER PROBABLY (BUT NOT NECESSARILY) TURNED OFF
	SUBM B,A	;DO THE CORRECTION
	JRST POPJ1	;EXIT SKIPPING (SUCCESS)
]

GPDTM2:	SKIPGE A,PDYTIM	;CLOCK NOT ON, TRY BACKUP
	POPJ P,		;SORRY, NOT AVAILABLE
	IMULI A,30.	;CONVERT TO SIXTIETHS OF A SECOND
	JRST POPJ1	;CALL IT CORRECT AND AVAILABLE

		;GET SIXBIT YYMMDD (DATE) IN A (LOCALIZED PDTIME/SPD IN A, YEAR IN RH(E))

RDATE:	PUSHJ P,RDATE1	;GET DAY IN C, MONTH IN B
	MOVE T,[1400,,A]	;SET UP BYTE POINTER FOR OUTPUT
	PUSHJ P,RDATM1	;DEPOSIT DAY
	MOVE C,B	;GET MONTH
	PUSHJ P,RDATM1	;DEPOSIT MONTH
	MOVEI B,(E)	;GET YEAR
	IDIVI B,100.	;GET LAST TWO DIGITS IN C
ARTIMX:	PUSHJ P,RDATM1	;DEPOSIT YEAR (ENTRY FROM RTIME TO DEPOSIT HOUR)
	IOR A,[SIXBIT /000000/]	;CONVERT TO REAL SIXBIT
	POPJ P,

		;GET MONTH (1 => JAN) IN B, DAY (1 => THE FIRST) IN C

RDATE1:	AOS C,A		;GET DAY OF YEAR (LOCALIZED) (1 => THE FIRST)
	MOVEI B,12.	;INITIALLY ASSUME DECEMBER FOR MONTH
	CAMG C,LMNTBL-1(B)	;IF DAY IN YEAR .LE. DAY IN YEAR AT BEGINNING OF THIS MONTH,
	SOJA B,.-1	;THEN DECREMENT TO PREVIOUS MONTH AND TRY AGAIN
	SUB C,LMNTBL-1(B)	;C(C) := DAY OF MONTH
	POPJ P,

LMNTBL:	MNIRP [<M 1>]	;TABLE OF DAYS GONE BY AT BEGINNING OF MONTH

		;GET THE SIXBIT TIME IN A (# SECS SINCE MIDNIGHT IN B)

RTIME:	MOVE T,[1400,,A]	;SET UP BYTE POINTER FOR OUTPUT
	IDIVI B,60.	;GET SECONDS IN C
	PUSHJ P,RDATM1	;DEPOSIT INTO A
	IDIVI B,60.	;GET HOURS IN B, MINUTES IN C
	PUSHJ P,RDATM1	;DEPOSIT MINUTES
	MOVE C,B	;GET HOURS IN C
	JRST ARTIMX	;DEPOSIT HOURS, CONVERT TO SIXBIT, AND RETURN

		;DEPOSIT C(C) AS TWO SIX BIT (AS OPPOSED TO SIXBIT) DECIMAL DIGITS VIA T (INTO A)
		;THEN DECREMENT T

RDATM1:	IDIVI C,10.	;SEPARATE DIGITS
	DPB C,[60600,,D]	;DEPOSIT FIRST DIGIT TO GIVE 12 BITS
	DPB D,T			;OUTPUT BYTE
	ADD T,[140000,,]	;DECREMENT BYTE POINTER
	POPJ P,		;THAT'S ALL

		;DO A PUSHJ P,GLPDTM THEN HACK AROUND
		;DO THOSE THINGS TO E COMMENTED IN GLPDTM AS BEING DONE BY RYEAR
		;TRY TO GET YEAR EVEN IF GLPDTM DOESN'T SKIP, BUT IN THAT CASE CLOBBER A TO -1

RYEAR:	PUSHJ P,GLPDTM	;GET THE CRUFT
	JRST RYEAR2	;DIDN'T SKIP, SEE WHAT CAN BE SALVAGED
RYEAR1:	PUSH P,A	;PROTECT A FROM FUTURE CLOBBERAGE
	IDIVI A,SPD	;GET LOCALIZED # DAYS SINCE BEGINNING OF YEAR
	JUMPL E,[SOJA A,.+1]	;DE-LOCALIZE
	LDB B,[270300,,E]	;DAY OF WEEK OF BEGINNING OF YEAR
	ADD A,B		;ADD IN
	IDIVI A,7	;GET TODAY'S DAY OF WEEK (0 => SUNDAY) IN B
	DPB B,[320300,,E]	;DEPOSIT IN E
	TLO E,40000	;DOCUMENT FACT THAT TIME OF YEAR KNOWN
	JRST POPAJ	;RESTORE A AND RETURN

RYEAR2:	PUSHJ P,GDWOBY	;GLPDTM DIDN'T SKIP, TRY TO SALVAGE CRUFT: FIRST DOWOBY
	MOVNI A,1	;DOCUMENT FACT THAT TIME OF YEAR NOT KNOWN
	JUMPE E,CPOPJ	;RETURN IF YEAR NOT KNOWN EITHER
	DPB B,[270300,,E]	;DAY OF WEEK OF BEGINNING OF YEAR
	JRST CMPF29	;SEE IF LEAP YEAR, AND RETURN

	;NOTE: THE SYMS JAN, FEB, MAR, ETC. ARE DEFINED AFTER (AND BY) MNIRP (A MACRO)

		;INCREMENT YEAR

NUPDT:	TLNN E,200000			;SEE IF LEAP YEAR
	SKIPA A,[<365.*SPD*PDUPS>]	;NORMAL YEAR
	MOVE A,[<366.*SPD*PDUPS>]	;LEAP YEAR
	ADDM A,PDTIME	;UPDATE PDCLK OFFSET
	IDIVI A,30.	;CONVERT TO HALF-SECONDS
	EXCH A,PDYTIM	;ALSO UPDATE BACKUP SYSTEM
	SUBM A,PDYTIM
	AOS FYEAR	;INCREMENT YEAR
		;INSERT OTHER CRUFT HERE IF DESIRED
		;DROPS THROUGH

	;CODING DROPS THROUGH FROM PREVIOUS PAGE
;GET "LOCALIZED" NUMBER OF SECONDS SINCE BEGINNING OF YEAR IN A
	;IF DIVIDED BY # SECONDS IN A DAY,
	;GIVES REMAINDER OF # SECONDS SINCE MIDNIGHT LOCAL TIME
	;QUOTIENT WHEN FED TO DATE GENERATOR ROUTINE ASSUMING LEAP YEAR GIVES CORRECT DATE
;ALSO GET YEAR AND FLAGS (AS RETURNED BY .RYEAR) IN E
	;1.1-2.9 => YEAR (E.G. 1969.)
	;3.1-3.5 ZERO
	;3.6-3.8 => DAY OF WEEK OF BEGINNING OF YEAR (0 => SUNDAY)
	;3.9-4.2 ZERO (RYEAR SETS THIS BYTE TO TODAY'S DAY OF WEEK IF TIME OF YEAR KNOWN)
	;4.6 ZERO (RYEAR SETS IT TO 1 IF TIME OF YEAR KNOWN)
	;4.7 ONE => DAYLIGHT SAVINGS TIME IN EFFECT
	;4.8 ONE => LEAP YEAR
	;4.9 ONE => 365 DAY YEAR AND AFTER FEB 28
;SKIPS IF PDCLK ON AND BOTH PDTIME AND FYEAR NON-ZERO (IN OTHER WORDS IF SUCCESSFUL)
;PREVIOUS CODING DROPS THROUGH ON YEAR INCREMENT

GLPDTM:	CONO PI,CLKOFF	;AVOID DOUBLE YEAR INCREMENT
	SKIPE E,FYEAR	;GET YEAR IN E, SKIP IF NOT AVAILABLE
	PUSHJ P,GPDTIM	;GET PDTIME, SHOULD SKIP
	JRST CLKONJ	;SOMETHING NOT AVAILABLE, DON'T SKIP
	IDIVI A,60.	;CONVERT TO SECONDS
	PUSHJ P,CMPF29	;MAYBE SET BIT 4.8 OR 4.9 OF E, IF 4.9 SET THEN ADD SPD TO A
	CAML A,[366.*SPD]	;IF MORE THAN A YEAR HAS GONE,
	JRST NUPDT	;THEN INCREMENT YEAR
	CONO PI,CLKON	;TIMIMG ERROR PROBLEM GONE
	PUSH P,A	;SAVE # SECONDS DURING NEXT CALL
	PUSHJ P,GDWOBY	;GET DAY OF WEEK OF BEGINNING OF YEAR (0 => SUNDAY)
	DPB B,[270300,,E]	;DEPOSIT IN RIGHT PLACE
	POP P,A		;RESTORE A
	AOS (P)		;CAUSE RETURN TO SKIP

		;IF DAYLIGHT SAVINGS TIME THEN ADD 3600. TO A AND SET BIT 4.7 IN E

GLPDT2:	CAML A,[<APR 24.>*SPD+7200.]	;IF BEFORE 2AM APR 24,
	CAML A,[<OCT 31.>*SPD+3600.]	;OR IF AFTER 1AM STANDARD TIME OCT 31,
	POPJ P,				;THEN OBVIOUSLY STANDARD TIME IS IN EFFECT
	CAML A,[<APR 30.>*SPD+7200.]	;IF BEFORE 2AM APRIL 30 STANDARD TIME,
	CAML A,[<OCT 25.>*SPD+3600.]	;OR IF AFTER 1AM STANDARD TIME OCTOBER 25,
	JRST GLPDT3	;THEN NOT OBVIOUS
CRDDST:	TLO E,100000	;DAYLIGHT SAVINGS TIME, SET BIT IN E
	ADDI A,3600.	;CONTINUE TO LOCALIZE THE TIME THAT WILL BE RETURNED
	POPJ P,

		;IT IS NOW SOMETIME DURING THE WEEKS IN APRIL AND OCTOBER
		;WHEN IT MAY BE EITHER STANDARD OR DAYLIGHT SAVINGS TIME

GLPDT3:	PUSH P,A	;SAVE # SECS
	CAMG A,[JUL*SPD]	;IF NOT YET JULY,
	TDZA D,D	;THEN IT MUST BE APRIL, SET INDEX
	MOVEI D,1	;OCTOBER, SET INDEX
	SUB A,CRDSB(D)	;COMPENSATE FOR 2AM OR 1AM
	IDIVI A,SPD	;FLUSH SECONDS, LEAVE ONLY DAYS (IT LOOKS LIKE A LEAP YEAR, REMEMBER)
	LDB C,[270300,,E]	;GET DAY OF WEEK OF BEGINNING OF YEAR IN C
	JUMPGE E,.+3	;IF REGULAR YEAR,
	SOJGE C,.+2	;THEN DE-LOCALIZE SO IT WILL RE-LOCALIZE LATER...
	MOVEI C,6	;MOD 7
	ADD A,C		;ADD TO NUMBER OF DAYS
	IDIVI A,7
	IMULI A,7
	SUB A,C		;C(A) := NUMBER OF DAYS IN YEAR BEFORE LAST SUNDAY (MAYBE TODAY)
		;IF LAST SUNDAY (AS DEFINED ABOVE) IS BELOW THE "REGION OF AMBIGUITY",
		;THEN IT HAS NOT YET CHANGED TO THE LATER TIME
	XCT CRDTST(D)	;SKIP IF DAYLIGHT SAVINGS TIME
	JRST POPAJ	;STANDARD TIME, NO CHANGES NECESSARY
	POP P,A		;DAYLIGHT SAVINGS TIME, RESTORE A
	JRST CRDDST	;MUNG A AND E AND RETURN

CRDSB:	7200.		;IN APRIL CHANGES AT 2AM EST
	3600.		;IN OCTOBER CHANGES AT 1AM EST

CRDTST:	CAIGE A,<APR 24.>
	CAIL A,<OCT 25.>

		;IF LEAP YEAR THEN SET BIT 4.8 OF E
		;IF NOT LEAP YEAR THEN IF AFTER FEB 28 THEN SET BIT 4.9 OF E AND ADD SPD TO A

CMPF29:	TRNN E,3	;IF LEAP YEAR, (HOPEFULLY THIS ONLY PLACE WHERE DIRECTLY CHECKED FOR LEAP YEAR)
	TLOA E,200000	;THEN SET BIT 4.8 OF E AND RETURN
	CAMGE A,[<<MAR 1>-1>*SPD]	;365 DAY YEAR, IF BEFORE MARCH FIRST,
	POPJ P,		;THEN RETURN
	TLO E,400000	;365 DAY YEAR AFTER FEB 28, SET BIT 4.9 OF E
	ADDI A,SPD	;INCREMENT A ONE DAY
	POPJ P,

		;GET DAY OF WEEK OF BEGINNING OF YEAR (IN E) (0 => SUNDAY) IN B
			;FOLLOWING ROUTINE HAS BEEN EXHAUSTIVELY CHECKED

GDWOBY:	MOVEI A,-1(E)
	IDIVI A,400.
	MOVEI A,1(B)
	IDIVI B,4
	ADD A,B
	IDIVI B,25.
	SUB A,B
	IDIVI A,7
	POPJ P,

		;SLOW CLOCK ROUTINE TO CHECK ON REAL-TIME CLOCK SYSTEM

PDCCHK:	SKIPL PDYTIM	;IF BACKUP TIME (SINCE BEGINNING OF YEAR) CALCULATED,
	AOS PDYTIM	;THEN UPDATE IT
	SKIPGE TIMOFF	;IF TIMOFF NOT CALCULATED,
	POPJ P,		;THEN RETURN
	AOS A,TIMOFF	;UPDATE TIMOFF
	CAML A,[2*SPD]	;IF IT'S INCREMENTED BEYOND THE LENGTH OF A DAY,
	SETZB A,TIMOFF	;THEN RESET, ALSO CAUSE NEXT TEST TO SUCCEED
	TRNE A,64.*2-1	;IF THIS IS NOT 64. SECOND (BASED ON TIMOFF) CLOCK BREAK,
	POPJ P,		;THEN RETURN
INITIM:
IFN PDCLKP,[
	SKIPN A,PDTIME	;MAYBE UPDATE BACKUP SYSTEM
	JRST INITM2	;PDTIME NOT AVAILABLE, DON'T
	DATAI PDCLK,B
	TLZ B,600000
	JUMPE B,INITM2	;JUMP IF CLOCK OFF
	SUBM B,A
	JUMPL A,CPOPJ
	IDIVI A,30.	;CONVERT TO HALF-SECONDS SINCE BEGINNING OF YEAR
	MOVEM A,PDYTIM	;STORE RE-CALCULATED BACKUP TIME
]
INITM2:	PUSHJ P,GLPDTM	;GET LOCALIZED PDTIME
	POPJ P,		;SOMETHING'S MISSING
	IDIVI A,SPD	;SEPARATE INTO DAYS AND SECONDS
	PUSH P,A	;SAVE NUMBER OF DAYS
	LSH B,1		;CONVERT TIME SINCE MIDNIGHT TO HALF-SECONDS
	MOVEM B,TIMOFF	;STORE RE-CALCULATED NUMBER OF HALF-SECONDS SINCE MIDNIGHT
	PUSHJ P,CLCQDT	;GET QDATE,,TIMOFF IN A
	POP P,A		;RESTORE NUMBER OF DAYS
	JUMPL E,[SOJA A,.+1]	;MAYBE DE-LOCALIZE
		;A NOW REALLY HAS NUMBER OF DAYS SINCE BEGINNING OF YEAR
	PUSHJ P,GNDS0	;GET NUMBER OF DAYS SINCE JAN 1,0000 IN A
	SUBI A,<MAR 1>	;CONVERT TO NUMBER OF DAYS SINCE MARCH 1, 0000
	MOVEM A,JDATE	;STORE AS JULIAN DATE
IFE OQDTSW,[	;EVENTUALLY FLUSH CONDITIONAL
	ANDI A,1777	;MASK TO 10 BITS
	HRLZM Q,QDATE
]
	CONO PI,UTCOFF	;INHIBIT INTERRUPTS DURING THIS RITUAL
	SKIPGE A,QMDRO	;GET ORIGIN OF MASTER DSK DIRECTORY
	JRST UTCONJ	;DIRECTORY LOCKED
	MOVE B,QACTB	;DIRECTORY CHANGED BIT FOR DSK DIRECTORY
	SKIPE T,PDTIME	;GET OFFSET FOR DECORIOLIS CLOCK
	CAMN T,MPDOFF(A)	;SEE IF IT MATCHES RELEVANT WORD IN DSKDIR
	JRST .+3	;MATCHES OR PDTIME NOT AVAILABLE
	MOVEM T,MPDOFF(A)	;NO MATCH, CORRECT THE DSKDIR ONE
	IORM B,QMDRO	;SET DIRECTORY CHANGED BIT
	SKIPE T,FYEAR	;NOW DO THE SAME FOR THE YEAR,
	CAMN T,MDYEAR(A)	;AND THE SIXTH WORD IN DSKDIR
	JRST .+3
	MOVEM T,MDYEAR(A)
	IORM B,QMDRO
	JRST UTCONJ	;THAT'S ALL

IFN OQDTSW,[	;EVENTUALLY FLUSH THIS CODING
		;CALCULATE AND STORE QDATE

CLCQDT:	PUSHJ P,RDATE1	;GET DAY OF MONTH IN C, MONTH IN B
	SETZM QDATE	;INITIALIZE FOR FOLLOWING
	DPB E,[330100,,QDATE]	;YEAR (LAST BIT THEREOF)
	DPB B,[270400,,QDATE]	;MONTH
	DPB C,[220500,,QDATE]	;DAY
	POPJ P,
]

		;A HAS NUMBER OF DAYS SINCE BEGINNING OF YEAR
		;UPDATE TO GIVE NUMBER OF DAYS SINCE JAN 1,0000

GNDS0:	MOVEI B,(E)	;GET YEAR
	IMULI B,365.	;FIRST APPROXIMATION
	ADD A,B		;ADD IN
	MOVEI B,-1(E)	;GET YEAR-1
	IDIVI B,4
	ADD A,B		;ADD NUMBER OF YEARS DIVISIBLE BY 4
	IDIVI B,25.
	SUB A,B		;SUBTRACT NUMBER OF YEARS DIVISIBLE BY 100
	IDIVI B,4
	ADDI A,1(B)		;ADD NUMBER OF YEARS DIVISIBLE BY 400
	POPJ P,

;OPER TO REQUEST OR FLUSH RUNNING IN IOT USER MODE
AIOTLS:	MOVSI A,400000
	MOVSI B,IOTFLG
	XCTR XRW,[SKIPGE (J)]
	JRST AIOTL1	;JUMP IF WANT TO ENTER IOTLSR MODE
	ANDCAM A,IOTLSR(U)
	ANDCAM B,UUOH
	POPJ P,

AIOTL1:	SKIPGE IOTLSR(U)
	POPJ P,	;ALREADY IN IOTLSR
	PUSHJ P,LDISOW
	MOVSI T,2000
	PUSHJ P,CWAIT
	TDNE T,SUPCOR
	MOVEM U,SYIOTL
	IORM T,SUPCOR
	PCLT
	TDNE T,SUPCOR
	PUSHJ P,UFLS
	IORM A,IOTLSR(U)
	IORM B,UUOH
	JRST CLKONJ

TPFLT:	CONO PI,CLKOFF	;PREVENT INTERRUPT AFTER IORM SPM ING BACK ON TOP OF 1000 BIT
	SPM UPGML(U)
	PUSH P,B
	MOVSI B,1000
	IORM B,UPGML+3(U)
	POP P,B
	LPMRI UPGML(U)	;TAKE TRAP, MAYBE DONT COME BACK
	JRST CLKONJ
;ROUTINE TO TRANSLATE A FILENAME.
;WANTS DEV, FN1, FN2, SNAME IN A, B, C, D RESP. LEFT-JUST.
;WANTS MODE IN RH OF E.
;RETURNS TRANSLATED NAMES IN SAME PLACE.
TRAN:	SKIPN D	;MAYBE DEFAULT THE SNAME.
TRAN6:	MOVE D,USYSNM(U)
	SKIPN TRNCNT	;IF NO TRANSL. ENTRIES IN USE,
	JRST POPJ1	;SHORT CUT.
	PUSHJ P,TRANRF	;GET READ ACCESS TO TRANSL LISTS.
	LDB I,[100,,E]	;GET INPUT/OUTPUT BIT.
	MOVEI H,10	;MAX. NUM. TRANSLS ALLOWED.
	MOVEM B,EPDLT1(U)
	MOVEM C,EPDLT2(U)
	MOVEM D,EPDLT3(U)
	MOVEM A,EPDLT4(U)
TRAN0:	HRROI Q,(U)	;1ST TRY THIS JOB'S TRNLST.
	MOVE J,TRNLST(U)
	JRST TRAN5
TRAN1:	SKIPGE Q,SUPPRO(Q)	;MOVE UP TREE TO TRNLS1.
	SETZ Q,		;AFTER TOP OF TREE, USE SYS.
TRAN2:	MOVE J,TRNLS1(Q)	;USE THIS GUY'S TRNLS1.
	MOVEI Q,(Q)	;INDICATE THAT FACT IN SIGN.
	JRST TRAN5
TRAN3:	CAME B,TRANI1(J)	;ENTRY'S FN1 MATCHES
	SKIPN TRANI1(J)	;OR IS NULL?
	SKIPA TT,TRANI2(J)	;YES, GET FN2.
	JRST TRAN4	;NO, TRY NEXT ENTRY.
	CAME TT,C	;FN2 MTCHES OR NULL.
	JUMPN TT,TRAN4
	CAME D,TRANIS(J)	;SNAME ?
	SKIPN TRANIS(J)
	SKIPA TT,TRANID(J)	;YES, GET DEV.
	JRST TRAN4
	CAME A,TT
	JUMPN TT,TRAN4	;TEST DEV.
	HLRZ TT,TRANLK(J)	;GET ENTRY'S MODE BITS.
	TRNN TT,1(I)	;TRANSLATE OUR MODE?
	JRST TRAN4	;NO.
	MOVEM B,EPDLT1(U)
	MOVEM C,EPDLT2(U)
	MOVEM D,EPDLT3(U)
	MOVEM A,EPDLT4(U)
IRPS X,,OD O1 O2 OS
	SKIPE TRAN!X(J)
	MOVE A+.IRPCN,TRAN!X(J)
TERMIN			;REPLACE NAMES FROM ENTRY.
	TRNE TT,400000	;ATOMIC?
	JRST TRANX3	;YES, EXIT.
	SOJG H,TRAN0	;ELSE RETRANSL.
	JRST TRANX2	;IF TOO MANY TRANSL., DON'T SKIP.

TRAN4:	HRRE J,TRANLK(J)	;CDR DOWN LIST.
TRAN5:	JUMPGE J,TRAN3	;TRY NEXT UNLESS AT END.
	JUMPL Q,TRAN2	;IF DID TRNLST, DO SAME JOB'S TRNLS1.
	JUMPN Q,TRAN1	;ELSE DO SUPPRO'S TRNLS1.
TRANX3:	AOS (P)		;EXIT IF DID SYS.
TRANX2:	SOS TRNREF	;NO LONGER USING TRANSL. LISTS.
	POPJ P,

TRANRF:	AOS TRNREF	;SAY USING TRANSL. LISTS.
	SKIPGE TRANSW
	POPJ P,		;OK IF NOT BEING CHANGED.
	SOS TRNREF	;NOT REFERENCING AFTER ALL.
	SKIPL TRANSW	;WAIT TILL FREE.
	PUSHJ P,UFLS
	JRST TRANRF	;TRY AGAIN.
;TRANS SYSTEM CALL.
NTRNS:	JSP T,DEFARG	;DEFAULT 5 ARGS TO 0.
	5
	PUSHJ P,TRAN	;TRANSLATE NAME.
	JRST OPNL3		;FAIL IF TOO MANY TRANSL.
	JRST SYSCPS	;ELSE GIVE BACK TRANSL'D NAMES.


DEFARG:	CAML W,(T)	;IF NOT ALL SPEC'D,
	JRST 1(T)
	SETZM A(W)	;DEFAULT ONE AND RETRY.
	AOJA W,DEFARG

;SET UP 1ST ARG FOR NTRNAD, NTRNDL, NTRNCL.
;RH OF A HAS JOB SPEC; CONTROL BIT ARGS XOR'D INTO LH.
;THE 4.8 BIT, IF SET, INDICATES TRNLS1 RATHER THAN TRNLST.
;OTHER LH BITS IGNORED,, NOT CHANGED BY NTRNUI.
;ON RETURN, A'S LH IS UNCHANGED, RH IS SUCH THAT
;   TRANLK(A) IS THE ADDR OF THE SPECIFIED TRNLS VAR.
NTRNUI:	TSC A,CTLBTS(U)
	MOVEI J,(A)
	JSP T,NCORUI	;DECODE THE JOB-SPEC.
	 JRST NTRNU1	;JOB GUARANTEED WRITEABLE.
	JSP T,NCORWR	;ELSE CHECK.
	 JRST OPNL31	;NOT WRITEABLE.
NTRNU1:	HRRI A,TRNLST-TRANLK(J)
	TLNE A,200000	;4.8 BIT SAYS WHICH TRNLS TO USE.
	ADDI A,TRNLS1-TRNLST
	JRST (Q)

;GET UP TO 4 ARGS INTO D ... D+3, FROM AOBJN PTR IN B.
NTRNGA:	MOVSI H,-4	;UP TO 4 ARGS.
	JUMPGE B,NTRNG3
NTRNG0:	XCTR XR,[MOVE J,(B)]
	JUMPGE W,NTRNG2	;W IS -1 FOR .TRANA, .TRAND;
	TRNN H,-1	;IN THAT CASE LEFT-JUST. DEV. (1ST ARG)
	HRLZI J,(J)
NTRNG2:	CAMN J,[SIXBIT/*/]
	MOVEI J,0	;REPLACE * BY BLANK.
	MOVEM J,D(H)	;STORE AWAY.
	AOBJP H,CPOPJ	;DONE AFTER 4TH ARG.
	AOBJN B,NTRNG0	;ELSE GET NEXT.
NTRNG3:	SETZM D(H)	;ZERO REMAINING ARGS.
	AOBJN H,NTRNG3
	POPJ P,
;TRANEX CALL  --  READ IN A JOB'S TRANSL LIST.
;1ST ARG RH - JOB SPEC. BIT 4.8 - IF SET, TRNLS1 NOT TRNLST.
;2ND ARG AOBJN -> PLACE TO STORE LIST INTO.
;UPDATED AOBJN PTR IS OUTPUT ARG.
;SKIPS IF ENTIRE LIST FIT IN BUFFER.
;EACH ENTRY TAKES 9 WDS OF SPACE: MODE,, IN 1ST,
;INPUT DEV, FN1, FN2, SNAME; THEN OUTPUT DEV, FN1, FN2, SNAME.
NTRNEX:	PUSHJ P,TRANRF	;GET READ ACCESS TO TRANSL LISTS.
	PUSHJ P,SOSSET	;RELINQUISH IF BLOCKED.
	TRNREF
	TSC A,CTLBTS(U)
	MOVEI J,(A)
	JSP T,NCORUI	;DECODE THE JOB SPEC.
	 JFCL		;NOT TRYING TO WRITE.
	HRRI A,TRNLST-TRANLK(J)
	TLNE A,200000	;MAKE TRANLK(A) BE TRNLS VAR.
	ADDI A,TRNLS1-TRNLST
	SUB B,[1,,1]	;SINCE WE AOBJ BEFORE ACTING.
NTRNE1:	HRRE T,TRANLK(A)	;AT END -> RETURN SKIPPING.
	JUMPL T,NTRNE8
	HLLZ D,TRANLK(T)	;RETURN LH ONLY OF 1ST WD.
	TLOA T,-9
NTRNE2:	MOVE D,TRANLK(T)	;ALL OF OTHER 8 WDS.
	AOBJP B,[	PUSHJ P,OPNL37
			JRST NTRNE9]
	;FAIL IF NO ROOM.
	XCTR XW,[MOVEM D,(B)]
	ADDI T,SIOMT-1
	AOBJN T,NTRNE2	;STORE ALL 9.
	MOVEI A,-9*SIOMT(T)	;GO TO NEXT.
	JRST NTRNE1

NTRNE8:	AOS (P)
	AOBJP B,.+1	;COMPENSATE FOR SUB .
	PUSHJ P,LSWPOP	;RELEASE READ ACCESS.
NTRNE9:	MOVE A,B
	JRST SYSCPT	;RETURN AOBJN PTR.
;TRANDL CALL -- DELETE ENTRY FROM TRANSL LIST.
;1ST ARG RH JOB SPEC. OF JOB WHICH IS OK TO MODIFY.
;1ST ARG LH MODE BITS AS FOR .TRANAD, ALSO 4.8 BIT SAYS TRNLS1
;	(SPEC'D JOB AND INFS, RATHER THAN JUST SPEC'D JOB)
;2ND ARG AOBJN -> INPUT DEV, FN1, FN2, SNAME. (ONLY DEV NEC.).
;SKIPS IF SOMETHING WAS DELETED.
NTRNDL:	JSP Q,NTRNUI	;PROCESS 1ST ARG.
NTRND:	PUSHJ P,SWTL	;WILL CHANGE TRANSL LISTS.
	TRANSW
	PUSHJ P,NTRNDA	;ACTUALLY DELETE.
	JRST OPNL4	;NOTHING TO DELETE => FILE NOT FOUND
	JRST LSWPJ1	;SKIP IF NTRNDA DID.

NTRNDA:	TLZ A,-1#400003
	PUSHJ P,NTRNGA	;ELSE GET INPUT NAMES.
	SKIPGE TRANLK(A)
	POPJ P,
	HRRZS (P)	;CLEAR SKIP FLAG.
	SKIPA T,A
NTRND2:	MOVEI T,(H)	;CDR DOWN BOTH PTRS.
NTRND0:	HRRE H,TRANLK(T)	;LOOK AT NEXT ENTRY.
	JUMPL H,NTRNDX	;EXIT IF END.
	CAMN D,TRANID(H)	;ALL 4 INPUT NAMES MUST MATCH.
	CAME E,TRANI1(H)
	JRST NTRND2	;ELSE NOT TO BE DELETED.
	CAMN TT,TRANI2(H)
	CAME I,TRANIS(H)
	JRST NTRND2
	HLLZ R,A	;GET MODE FROM ARG.
	TLZ R,400000	;DONT CLOBBER ATOM BIT
	ANDCA R,TRANLK(H)	;TURN OFF IN MODE FROM ENTRY.
	CAME R,TRANLK(H)	;IF DELETED ONE, CALL WILL SKIP.
	HRROS (P)
	MOVEM R,TRANLK(H)
	TLNE R,3		;IF NEITHER DIRECTION LEFT, SPLICE OUT.
	JRST NTRND2
	SKIPE TRNREF	;WAIT TILL NOONE READING TRANSL LISTS.
	PUSHJ P,UFLS
	SOS TRNCNT	;ONE LESS ENTRY IN USE.
	MOVE R,TRANFL	;MAKE LINK -> CURRENT FREE LIST.
	EXCH R,TRANLK(H)
	HRRM R,TRANLK(T)	;REST OF TRNLS INTO PREDECESSOR'S LINK.
	HRRZM H,TRANFL	;ADD THIS ONE TO FREE LIST.
	JRST NTRND0

NTRNDX:	HRRES TRANLK(A)	;IN CASE DELETED 1ST ENTRY.
	SKIPGE (P)
	AOS (P)		;SKIP IF SET FLAG.
	POPJ P,
;TRANAD CALL. -- ADD AN ENTRY TO A TRANSL LIST.
;1ST 2 ARGS AS FOR TRANDL.
;3RD ARG LIKE 2ND BUT GIVES OUTPUT NAMES.
;SKIPS UNLESS ALL ENTRIES WERE IN USE.
NTRNAD:	JSP Q,NTRNUI
NTRNA:	TLNN A,3	;IF RELLY NOTHING WOULD BE TRANSL'D,
	JRST POPJ1	;DON'T BOTHER ADDING..
	PUSHJ P,SWTL	;GET WRITE ACCESS.
	TRANSW
	PUSHJ P,NTRNDA	;DELETE ANY EXISTING TRANSL. FOR THESE INPUT NAMES.
	JFCL		;IF WERE NONE.
	SKIPGE T,TRANFL
	JRST OPNL5	;NO FREE ENTRIES - DIRECTORY FULL.
	AOS TRNCNT	;1 MORE ENTRY IN USE.
IRPS X,,ID I1 I2 IS
	MOVEM D+.IRPCN,TRAN!X(T)
TERMIN			;PUT INPUT NAMES INTO ENTRY.
	MOVE B,C
	PUSHJ P,NTRNGA	;GET OUTPUT NAMES.
IRPS X,,OD O1 O2 OS
	MOVEM D+.IRPCN,TRAN!X(T)
TERMIN			;STORE OUTPUT NAMES.
	MOVE H,TRANLK(A)	;PUT CURRENT TRNLS INTO LINK.
	EXCH H,TRANLK(T)
	MOVEM H,TRANFL	;STORE BACK REST OF FREE LIST.
	MOVEM T,TRANLK(A)	;TRNLS NOW STARTS WITH THSI ONE.
	HLLM A,TRANLK(T)	;STORE MODE BITS.
	JRST LSWPJ1
;TRANCL CALL -- RESET A ONE OR BOTH TRANSL LISTS FOR A JOB.
;1ST ARG RH HAS JOB SPEC OF MODIFYABLE JOB.
; BIT 4.8 CLEAR TRNLS1 VAR. (TRANSL FOR THIS JOB & INFS).
; BIT 4.7 CLEAR TRNLST VAR. (TRANSL FOR THIS JOB ONLY).
; ALWAYS SKIPS IF VALID.
NTRNCL:	JSP Q,NTRNUI	;RH(A) -> TRNLST OR TRNLS1 VAR.
	TLNE A,200000
	SUBI A,TRNLS1-TRNLST	;MAKE -> TRNLST VAR.
NTRNCA:	SUBI A,TRNLST-TRANLK	;MAKE HOLD USR IDX.
NTRNC:	AOS (P)
	PUSHJ P,SWTL	;GET WRITE ACCESS.
	TRANSW
	SKIPE TRNREF	;WAIT FOR READ REFS TO FINISH.
	PUSHJ P,UFLS
	TLNN A,100000	;IF 4.7, HANDLE TRNLST.
	JRST NTRNC0
	HRRE T,TRNLST(A)
	SETOM TRNLST(A)	;SET LIST TO NIL.
	JUMPGE T,NTRNC1	;IF WASN'T NIL, FREE ENTRIES ON IT.
NTRNC0:	TLZN A,200000	;MAYBE HANDLE TRNLS1.
	JRST LSWPOP
	HRRE T,TRNLS1(A)
	SETOM TRNLS1(A)
	JUMPL T,LSWPOP	;NOTHING TO DO IF ALREADY NIL.
NTRNC1:	MOVEI C,(T)	;SAVE START OF LIST.
NTRNC2:	SOS TRNCNT	;UPDATE NUM ENTRIES IN USE.
	HRRES H,TRANLK(T)
	JUMPL H,NTRNC3	;AT END, SPLICE INTO FREELIST.
	MOVEI T,(H)	;ELSE CDR DOWN.
	JRST NTRNC2
NTRNC3:	EXCH C,TRANFL
	MOVEM C,TRANLK(T)
	JRST NTRNC0	;MAYBE CONSIDER THE OTHER LIST.
;.TRANA, .TRAND CALLS.
ATRANA:	XCTR XR,[MOVE E,(B)]
	JSP T,ATRNDT	;SET UP ARGS FOR NTRNA .
	JRST NTRNA

ATRNDL:
ATRAND:	XCTR XRW,[SKIPN E,(B)]
	JRST ATRND0	;ZERO UNAME -> TRANCL .
	JSP T,ATRNDT	;SET UP ARGS.
	JRST NTRND

ATRND0:	JSP T,ATRNDT
	TLO A,300000	;SAY CLEAR BOTH LISTS.
	CAMN D,[SIXBIT/*/]
	SUBI A,TRNLS1-TRNLST	;NAKE SURE -> TRNLST VAR.
	JRST NTRNCA

ATRNDT:	CAME E,UNAME(U)	;UNAME MUST BE 0 OR THSI JOB'S.
	JUMPN E,CPOPJ	;ELSE MAKE UUO FAIL.
	MOVNI W,1	;SIGNAL TO NTRNGA.
	MOVEI C,5(B)	;SET UP 2 AOBJN PTRS
	MOVEI B,2(B)
	HRLI C,-3	;-> INPUT NAMES (B), OUTPUT NAMES (C).
	HRLI B,-3
	XCTR XRW,[HLL A,(B)]	;GET MODE BITS.
	XCTR XR,[MOVE D,-1(B)]
	JUMPE D,CPOPJ	;JNAME MUSTN'T BE 0.
	CAME D,[SIXBIT/*/]	;IF *, USE THIS JOB'S TRNLS1.
	JRST ATRND2
	HRRI A,TRNLS1-TRANLK(U)
	JRST (T)

ATRND2:	MOVEI H,0	;ELSE FIND JOB WITH THAT JNAME.
	MOVE E,UNAME(U)	;THIS JOB'S UNAME.
ATRND1:	CAMN E,UNAME(H)
	CAME D,JNAME(H)
	JRST ATRND3	;NOT THE ONE WE'RE LOOKING FOR.
	HRRE E,SUPPRO(H)
	CAIE U,(E)	;IS THIS OUR INF.
	CAIN U,(H)	;IS IT THE CURRENT JOB?
	CAIA
	POPJ P,		;NO, CAN'T SET ITS TRANSL LIST.
	HRRI A,TRNLST-TRANLK(H)
	JRST (T)	;OK, SET ITS TRNLST VAR.
ATRND3:	ADDI H,LUBLK
	CAMGE H,USRHI	;LOOK AT ALL JOBS.
	JRST ATRND1
	POPJ P,		;CAN'D TRANAD NON EX JOB.

;ML AND AI DEVICES
MLGO:	CAIN W,4
	JRST JFDEL2
	HRLZM C,EPDLT4(U)
	MOVEM A,EPDLT1(U)
	MOVEM B,EPDLT2(U)
	MOVE E,USYSN1(U)
	MOVEM E,EPDLT3(U)
	MOVSI E,(SIXBIT /SYS/)
	MOVEM E,USYSN1(U)
	MOVE A,[SIXBIT /ATSIGN/]
	MOVE B,[SIXBIT /OTHER/]
	MOVEI W,0	;FLUSH MODE
	JRST JOBO

JFDEL2:	MOVEM A,EPDLT1(U)
	MOVEM B,EPDLT2(U)
	MOVE A,SRN3(U)
	MOVEM A,EPDLT3(U)
	MOVE B,SRN4(U)
	MOVEM B,EPDLT4(U)
	MOVE A,USYSN1(U)
	MOVEM A,SRN5(U)	;SAVE
	MOVSI A,(SIXBIT /SYS/)
	MOVEM A,USYSN1(U)
	MOVE A,[SIXBIT /ATSIGN/]
	MOVE B,[SIXBIT /OTHER/]
	JRST JOBOFD

JOBOF3:	MOVEI TT,6
JFDEL5:	MOVEM TT,JBSTS(E)
	MOVE TT,SRN5(U)
	MOVEM TT,JBST2(E)
	CONO PI,CLKOFF
	PUSHJ P,JBWT
	LDB TT,[350400,,JBSTS(E)]
	JUMPN TT,POPJ1
	POPJ P,

;RENAME WHILE OPEN ON JOB WRITE CHNL
JFDEL4:	HLRZ E,(TT)	;JOB CHNL INDEX
	MOVE A,SRN3(U)
	MOVEM A,JBOSYN(E)
	MOVE A,SRN4(U)
	MOVEM A,JBODEV(E)
	MOVEI TT,7
	JRST JFDEL5

EBLK
JBMN==10	;MAXIMUM NUMBER OF JOBS ON JOB DEVICE

JBNTO:	REPEAT JBMN,0	;NUMBER TIMES JOB OPEN
BJNTO:	REPEAT JBMN,0	;NUMBER TIMES BOJ OPEN
JBCUI:	REPEAT JBMN,-1	;CREATOR'S USER INDEX
JBCG:	BLOCK JBMN	;-1 IF CREATOR GONE AWAY
JBWST:	REPEAT JBMN,0	;CREATED JOB'S WAIT STATUS
	;4.9 = 1  => CREATED JOB HAS DONE A SUCCESSFUL JOBRET
	;4.8 => DIRECTION OF CHANNEL IF ONLY OPEN ONE WAY.
	;   = 0 => READ   = 1 => WRITE.
	;4.7 = 1  => HAVE DONE INPUT JOB CLS BUT NO JOBGET YET
	;4.6 = 1  => HAVE DONE OUTPUT JOB CLS BUT NO JOBGET YET.
	;4.5 => VALID BIT
	;4.4 => STORED BIT
	;4.3 => BOJ BLK UNHANG BIT
	;4.2 => USE NEW BOJ JOB FOR OTHER DIRECTION OPEN
	;4.1 => CREATED FOR A .FDELE
	;3.9 => CREATED JOB DID AN UNSUCCESSFUL JOBGET FOR AN INITIAL OPEN

JBINCL==100000
JBOUCL==40000
JBVAL==20000
JBSTR==10000

JBFN1:	BLOCK JBMN	;FN1
JBFN2:	BLOCK JBMN	;FN2
JBSYS:	BLOCK JBMN	;SYSNAME
JBOPNM:	BLOCK JBMN	;OPEN MODE
JBCJUI:	BLOCK JBMN	;CREATED JOB'S USER INDEX -1 IF GONE
JBSTS:	BLOCK JBMN	;STATUS OF JOB-BOJ INTERACTIONS
;4.9=1 => IMAGE =0 => ASCII
;4.8=1 => BLOCK =0 => UNIT
;4.7=1 => WRITE =0 => READ
;4.6-4.3 => NUMBER OF TIMES TO SKIP
;4.2-3.6 => OPEN LOSS
;1.4-1.1 => SYSTEM CALL
	;0	OPEN
	;1	IOT
	;2	STATUS
	;3	RESET
	;4	RCHST
	;5	ACCESS
	;6	FDELE (DELETE OR RENAME)
	;7	FDELE (RENAME WHILE OPEN)

JBST2:	BLOCK JBMN	;SECOND WORD OF JOBGET INFO
JBOFN1:	BLOCK JBMN	;FN1 BEFORE LAST TRANS
JBOFN2:	BLOCK JBMN	;FN2 "" ""
JBOSYN:	BLOCK JBMN	;SYSNAM ""
JBODEV:	BLOCK JBMN	;DEV  " "

JBSW:	-1
	0

JBCH:	BLOCK JBMN	;1.1-1.4 => JOB USER INPUT CH
			;1.7-2.1 => JOB USER OUTPUT CH
			;3.1-3.4 => BOJ USER OUTPUT CH
			;3.7-4.1 => BOJ USER INPUT CH

JBIOCJ:	BLOCK JBMN	;IO CHNL ERROR WORD.  4.9 => NEXT JOB IOT
			;RH = IOCER TYPE
JBIOCB:	BLOCK JBMN	;IO CHNL ERROR WORD.  4.9 => NEXT BOJ IOT
			;RH = IOCER TYPE

BBLK

;3.4 = 1 => CAUSE CREATIONOF NEW BOJ JOB FOR OPPOSITE DIR OPEN
;3.5 = 1 => UNHANG ON BLK IOT AFTER EACH XFER OF MAXIMAL SIZE
BOJO:	JUMPN W,OPNL12	;NO SUCH MODE
	SKIPGE E,JBI(U)	;JOB CHANNEL INDEX
	JRST OPNL10
	CAIL E,JBMN
	JRST 4,.	;JOB CHANNEL INDEX TOO BIG
	HRLZ A,E
	MOVE B,UUAC(U)
	MOVE TT,[220600,,JBCH(E)]
	SKIPL D
	MOVE TT,[300600,,JBCH(E)]
	DPB B,TT	;STORE BOJ USER CH #
	ROT D,-2
	DPB D,[340200,,JBWST(E)]
	HLRZS C
	AOS BJNTO(E)
	JSP Q,OPSLC7
	BDUAI,,BDUAO
	BDBI,,BDBO
	BDUII,,BDUIO
	BDBI,,BDBO

;.OPEN CH,ADR
;ERROR RETURN
;NORMAL RETURN

;ADR:	MODE BITS,,SIXBIT /JOB/
;	FN1
;	FN2

;MODE BITS:
;3.1-3.3 => IMAGE/ASCII, BLOCK/UNIT, OUTPUT/INPUT

JOBO:	JUMPN W,OPNL12	;NO SUCH MODE
	PUSHJ P,FLDRCK
	JRST JOBO3
	JRST OPNL11	;ILLEGAL FILE NAME
JOBO3:	CAMN A,[SIXBIT /M.F.D./]
	CAME B,[SIXBIT /(FILE)/]
	JRST JOBO2
	JRST OPNL11	;ILLEGAL FILE NAME
JOBO2:	TDZA J,J
JOBOFD:	MOVNI J,1	;ENTRY FOR FDELE
	MOVNI E,1
	MOVSI Q,-JBMN
	PUSHJ P,SWTL	;LOCK JOB CHNL ASSIGN SWITCH
	JBSW
JOBO5:	SKIPGE TT,JBCUI(Q)	;SKIP IF NOT FREE
	JRST JOBO4
	CAIE TT,(U)
	JRST JOBO6
	CAMN A,JBFN1(Q)
	CAME B,JBFN2(Q)
	JRST JOBO6
	MOVE T,USYSN1(U)
	CAME T,JBSYS(Q)
	JRST JOBO6
	SKIPGE TT,JBWST(Q)	;SKIP IF HASN'T DONE JOBRET
	JRST JOBO6A
	JUMPL J,JOBOF1
	TLNE TT,400
	JRST JOBO6	;JOB WILL GO AWAY
	LSH TT,1	;READ/WRITE BIT
	EQV TT,D
	JUMPGE TT,JOBO6		;WRONG DIR
JOBOF2:	HRRZ E,Q	;FILE ALREADY ACTIVE DONT RECREATE.
	SETZM JBCG(E)
	PUSHJ P,LSWPOP	;FREE JBSW
	JRST JOBO7

JOBOF1:	TLNE TT,1000
	JRST JOBOF2	;THIS JOB IS AN FDELE
	JRST JOBO6

JOBO6A:	JUMPL J,JOBO6
	MOVE H,JBNTO(Q)
	SOJN H,JOBO6	;ALREADY OPEN IN BOTH DIRECTIONS OR OPENED AND CLOSED.
	TLNE TT,2000
	 JRST JOBO6	;CAN'T USE IT IF IT SAID NOT TO.
	MOVSI T,JBINCL
	SKIPGE D
	MOVSI T,JBOUCL
	TDNE T,JBWST(Q)	;PENDING CLOSE THIS DIRECTION =>
	 JRST JOBO6	 ;CAN'T USE THIS ONE.
	LSH TT,1
	EQV TT,D
	JUMPL TT,JOBO6	;SAME DIR.  CAN'T USE THIS JOB
	HRRZ E,Q
	MOVEM C,JBOPNM(E)
	SETZM JBCG(E)
	PUSHJ P,LSWPOP	;FREE JOBSW
	JRST JOBO7

JOBO4:	HRRZ E,Q
JOBO6:	AOBJN Q,JOBO5
	JUMPL E,OPNL6	;DEVICE FULL
	MOVEM U,JBCUI(E)	;STORE CREATOR'S USER INDEX
	PUSHJ P,LSWPOP	;FREE JOBSW
	MOVEM A,JBFN1(E)
	MOVEM B,JBFN2(E)
	MOVEM C,JBOPNM(E)
	SETZM JBCG(E)
	SETZM JBNTO(E)
	SETZM BJNTO(E)
	SETZM JBWST(E)
	SETOM JBCH(E)
	ROT D,1
	DPB D,[420100,,JBWST(E)]
	ROT D,-1
	DPB J,[340100,,JBWST(E)]	;FDELE BIT
	PUSHJ P,STMSET	;SETOM JBCUI(E) ON LOSSAGE
	JBCUI(E)
	PUSH P,R
	PUSH P,E
	PUSH P,U
	PUSH P,J
	MOVE A,UNAME(U)
	IDIVI E,10.
	MOVEI B,'0(E)
	LSH B,6
	ADDI B,'0(TT)
	HRLI B,(SIXBIT /JOB/)		;CREATE JNAME = 'JOB MN'
	MOVE C,[7,,(SIXBIT /USR/)]
	MOVE D,[SETZ 3]
	PUSHJ P,USROJ	;GENERATE USER(CAN ONLY PCLSR BEFORE CREATING INFERIOR)
	JRST POP4J	;USER OPEN FAILED, MUST HAVE GONE TO OPNL ALREADY
	PUSHJ P,LSWDEL
	POP P,J
	POP P,U
	POP P,E
	POP P,R
	SETOM SUPPRO(TT)
	HRRZM TT,JBCJUI(E)
	MOVEM E,JBI(TT)
	MOVE T,[JBSTCD,,AC0S]
	ADDI T,(TT)
	BLT T,AC17S(TT)
	HRLZI T,LSRMOD
	MOVEM T,UPC(TT)
	MOVE A,JBFN1(E)
	MOVEM A,AC0S+10(TT)
	MOVE B,JBFN2(E)
	MOVEM B,AC0S+11(TT)
	MOVE T,USYSN1(U)
	MOVEM T,USYSNM(TT)	;SET CREATED JOB'S SYS NAME TO OURS
	MOVEM T,JBSYS(E)
	CONO PI,CLKOFF
	SETZM USTP(TT)	;START HIM UP
JOBO7:	CONO PI,CLKOFF
	MOVE TT,EPDLT1(U)
	MOVEM TT,JBOFN1(E)
	MOVE TT,EPDLT2(U)
	MOVEM TT,JBOFN2(E)
	MOVE TT,EPDLT3(U)
	MOVEM TT,JBOSYN(E)
	MOVE TT,EPDLT4(U)
	MOVEM TT,JBODEV(E)
	JUMPL J,JOBOF3
	MOVE TT,UUAC(U)
	MOVE C,[000600,,JBCH(E)]
	SKIPGE D
	MOVE C,[060600,,JBCH(E)]
	DPB TT,C	;STORE USER CH #
	LDB TT,[220300,,JBOPNM(E)]
	ROT TT,-3
	MOVEM TT,JBSTS(E)
	PUSHJ P,STMSET
	JBCG(E)	;SETOM CREATOR GONE ON LOSSAGE
	PUSHJ P,JBWT	;STORE STUFF AND HANG
	PUSHJ P,LSWDEL
	LDB TT,[350400,,JBSTS(E)]
	JUMPE TT,JOBOPL	;OPEN LOST
	MOVE C,JBOPNM(E)
JOBO14:	AOS JBNTO(E)	;NUMBER OF TIMES OPEN
	SETZM IOCHST-IOCHNM(R)
	HRLZ A,E
	HLRZS C
	JSP Q,OPSLC7
	JDUAI,,JDUAO
	JDBI,,JDBO
	JDUII,,JDUIO
	JDBI,,JDBO

JOBOPL:	LDB C,[270600,,JBSTS(E)]
	CAILE C,NOPNLS
	MOVEI C,22
	MOVE A,E
	CONO PI,CLKOFF
	PUSHJ P,JOBCL1	;CAUSE CHNL TO GO AWAY WHEN BOJ GUY LOGS OUT
	JRST OPNL1-1(C)

;JOB CHNL INDEX IN E,  CLOBBERS TT,J,Q,H
;CALL WITH CLKOFF

JBINT:	MOVE TT,JBCJUI(E)
	MOVEI J,IOCHNM(TT)
	HRLI J,-20
	MOVSI H,4000
JBINT1:	MOVE Q,(J)
	TDNN H,CLSTB(Q)	;SKIP IF BOJ
JBINT2:	AOBJN J,JBINT1
	JUMPGE J,CPOPJ
	SUBI J,IOCHNM(TT)
	MOVE Q,CHNBIT(J)
	IORM Q,IFPIR(TT)
	ADDI J,IOCHNM(TT)
	JRST JBINT2


JBSTCD:	.OPEN 1,7	;0
	.LOGOUT
	.CALL 12
	.LOGOUT
	.IOT 1,2
	.CLOSE 1,
	JRST (2)
	4,,(SIXBIT /DSK/)	;7
	0	;10 FN1
	0	;11 FN2
	SETZ	;12
	SIXBIT /LOAD/
	16
	SETZ 17
	-1	;16 (LOAD INTO SELF)
	1	;17


;CALL WITH CLOCK OFF ,JOB CHNL IN E
JBWT:	MOVSI TT,JBVAL+JBSTR
	IORM TT,JBWST(E)	;TURN ON VALID AND STORED
	PUSH P,E
	PUSHJ P,FINSET
	JBPCL	;CLEAR VALID AND STORED IF PCLSR
	PUSHJ P,JBINT	;GIVE INT
	MOVE T,E	;CAUSES EPDL2 TO HAVE JOB INDEX
	PCLT
JBFLS:	SKIP JBFLS
	PUSHJ P,UFLS	;ONLY PLACE TO PCLSR AFTER SUCCESSFUL USRO
	PUSHJ P,LSWPOP
	POP P,E
	POPJ P,

JBPCL:	CONO PI,CLKOFF	;SO PC WILL BE HERE IF BITS NOT CLEARED
	POP P,E
	MOVSI TT,JBVAL+JBSTR
	ANDCAM TT,JBWST(E)
	CONO PI,CLKON
	JRST URET

JBBI:	SKIPA TT,[600000,,1]	;BLOCK IMAGE (ASCII) INPUT IOT
JBBO:	MOVE TT,[700000,,1]	;BLOCK IMAGE (ASCII) OUTPUT IOT
JBIB:	XCTR XRW,[MOVES D,(C)]	;REFERENCE POINTER
	MOVEM D,JBST2(A)
	HLRO E,D
	IORI E,700000	;FLUSH CHAR CNT
	HRRZS B,D
	SUB D,E		;LA + 1
	CAMLE D,[1,,]
	JRST IOADC
	ANDI B,776000	;FIRST WORD OF FIRST PAGE
JBBO1:	TLNE TT,100000
	XCTR XR,[SKIPA (B)]
	XCTR XRW,[MOVES (B)]	;REFERENCE ONE WORD IN EACH PAGE
	ADDI B,2000
	CAMGE B,D
	JRST JBBO1
	JRST JBIX

JBUII:	SKIPA TT,[SETZ 1]	;UNIT IMAGE INPUT IOT
JBUAI:	MOVEI TT,1	;UNIT ASCII INPUT IOT
JBIU:	XCTR XR,[SKIP (C)]
JBIX:	HRRZ E,A	;JOB CHNL INDEX
	MOVEM TT,JBSTS(E)
	MOVEM C,SRN3(U)
	SKIPGE TT,JBIOCJ(E)
	JRST JBIXER	;GET IO CHNL ERROR
	CONO PI,CLKOFF
	PUSHJ P,JBWT
	LDB TT,[350400,,JBSTS(E)]
	ADDM TT,UUOH
	POPJ P,

JBUIO:	SKIPA TT,[500000,,1]	;UNIT IMAGE OUTPUT IOT
JBUAO:	MOVE TT,[100000,,1]	;UNIT ASCII OUTPUT IOT
	JRST JBIU

JBIXER:	SETZM JBIOCJ(E)
	JRST IOCERF-MIOTER(TT)

;WAIT FOR CREATOR TO BE HUNG AT JBFLS
;4.9 OF SRN3 = 1 => WAIT FOR WRITE   0 => READ
;1.1-1.4 => CODE OF UUO TO WAIT FOR

BJWAIT:	SKIPE B,FLSINS(T)
	CAME B,JBFLS
	POPJ P,		;NOT HUNG AT JBFLS
	MOVE B,EPDL2(T)	;JOB INDEX THAT CREATOR IS HACKING
	HLRZ E,T	;JOB INDEX OF BOJ USER
	CAME B,E
	POPJ P,		;CHNLS DON'T AGREE
	PUSH P,J
	MOVE TT,JBSTS(B)
	LSH TT,2	;4.9 => READ/WRITE BIT NOW
	EQV TT,SRN3(U)	;4.9 OF SRN3 => WHAT TO LOOK FOR
	JUMPGE TT,POPJJ	;DOESN'T MATCH
	LDB TT,[000400,,JBSTS(B)]
	LDB J,[000400,,SRN3(U)]	;INSTRUCTION TO LOOK FOR
	CAMN TT,J	;SKIP IF WRONG INSTRUCTION
	AOS -1(P)		;FINALLY
	JRST POPJJ

BJIOCC:	SKIPL TT,JBIOCB(A)
	POPJ P,
	SETZM JBIOCB(A)
	SUB P,[1,,1]
	JRST IOCERF-MIOTER(TT)

BJUIO:	TDZA W,W
BJUAO:	MOVNI W,1
	PUSHJ P,BJIOCC
	XCTR XR,[MOVE H,(C)]
	MOVEI B,1	;WAIT FOR INPUT IOT
	MOVEM B,SRN3(U)
BJUO1:	HRLZ T,A	;JOB INDEX
	HRR T,JBCUI(A)	;CREATOR'S USER INDEX
	PUSHJ P,CWAIT
	PUSHJ P,BJWAIT
	HRLI T,250000	;MAKE MY MAP POINT AT CREATOR
	MOVE J,T
	PUSHJ P,PLD1	;LOAD UP NEW MAP
	MOVE TT,JBSTS(A)
	TLNE TT,200000
	JRST BJUOB	;BLOCK MODE CREATOR IOT
	MOVE D,TT
	XOR D,W
	JUMPGE D,BJUO4
	SKIPGE W	;SKIP IF BOJ IOT IS IMAGE
	ANDI H,177	;ASCII MODE
	MOVE D,SRN3(T)	;CREATOR'S USER MODE DEST ADDR
	XCTR XWI,[MOVEM H,(D)]	;TRY TO WRITE BACK
	JRST BJUO2	;SUCCESSFUL
BJUO3:	PUSHJ P,TPFLT	;TURNS CLK ON
	PUSHJ P,MPLDZ
	JRST BJUO1

BJUO2:	TDZA I,I
BJUO2B:	MOVNI I,1
	PUSHJ P,PLDZ	;IN CASE ANY XCTRS GET ADDED TO THIS CODE
	MOVSI D,(SETZ)
	IORM D,JBWST(A)	;SET SUCCESSFUL JOBRET BIT
	MOVSI D,JBVAL+JBSTR
	ANDCAM D,JBWST(A)
	MOVEI D,0
	DPB D,[350400,,JBSTS(A)]	;DON'T SKIP
	MOVE D,FLSINS(T)
	SETZM FLSINS(T)	;RESTART CREATOR
	CONSO PI,1
	CAME D,JBFLS
	JRST 4,.	;HE WASNT WHERE HE BELONGED
	JUMPE I,CLKONJ	;UNHANG IF NOT BLK
	XCTR XRI,[MOVE D,(C)]
	JRST .+2
	JRST 4,.
	JUMPGE D,CLKONJ
	MOVE D,JBWST(A)
	TLNN D,4000	;BLK UNHANG BIT
	JRST BJBO
	JRST CLKONJ

BJUO4:	PUSHJ P,MPLDZ	;TURNS CLK ON
	JRST IOCR10

BJUOB:	MOVE D,SRN3(T)	;ADDRESS OF CREATOR'S POINTER
	XCTR XRWI,[MOVES B,(D)]
	JRST .+2	;NO FAULT (INSURANCE OF WRITEABILITY)
	JRST BJUO3
	JUMPL W,BJUOBA	;BOJ ASCII IOT
	XCTR XWI,[MOVEM H,(B)]
	JRST .+2
	JRST BJUO3
	ADD B,[1,,1]
	XCTR XWI,[MOVEM B,(D)]
	JRST BJUO2
	JRST 4,.

BJUOBA:	LDB E,[410300,,B]	;CHAR COUNT
	CAIGE E,3
	JRST BJUO2
	MOVE E,BTOCHT-3(E)
	XCTR XRI,[MOVE W,(B)]
	JRST .+2
	JRST BJUO3
	IDPB H,E
	XCTR XWI,[MOVEM W,(B)]
	JRST .+2
	JRST BJUO3
	ADD B,[700000,,]
	TLNN B,500000
	ADD B,[500001,,1]
	XCTR XWI,[MOVEM B,(D)]
	JRST BJUO2
	JRST 4,.

BJBO:	PUSHJ P,BJIOCC
	MOVEI I,1
	JSP TT,BJCLST
	XCTR XRW,[MOVES D,(C)]	;D GETS IOT POINTER
	HLRO E,D
	IORI E,700000	;FLUSH CHAR CNT
	HRRZ T,D
	SUB T,E
	CAILE T,-1
	JRST IOADC
	XCTR XR,[MOVE H,(D)]	;H GETS FIRST WORD
	MOVEI B,1
	MOVEM B,SRN3(U)
	HRLZ T,A
	HRR T,JBCUI(A)
	PUSHJ P,CWAIT
	PUSHJ P,BJWAIT	;WAIT FOR JOB INPUT IOT
	JUMPGE D,BJUO2	;THROUGH
	MOVE TT,JBSTS(A)
	HRLI T,250000
	MOVE J,T
	PUSHJ P,PLD1
	TLNE TT,200000
	JRST BJBB	;CREATOR IOT IS IN BLOCK MODE
	TLNN TT,400000
	JRST BJBOA	;CREATOR IOT IS ASCII
	MOVE E,SRN3(T)
	XCTR XWI,[MOVEM H,(E)]
	JRST .+2
	JRST BJBO3
	PUSHJ P,PLDZ
	ADD D,[1,,1]
	XCTR XWI,[MOVEM D,(C)]
	JRST BJUO2B
	JRST 4,.

BJBOA:	LDB E,[410300,,D]	;CHAR CNT
	CAIGE E,3
	JRST BJUO2
	MOVE E,BTOCHT-3(E)
	MOVE W,H
	ILDB E,E
	MOVE W,SRN3(T)
	XCTR XWI,[MOVEM E,(W)]
	JRST .+2
	JRST BJBO3
	PUSHJ P,PLDZ
	ADD D,[700000,,]
	TLNN D,500000
	ADD D,[500001,,1]
	XCTR XWI,[MOVEM D,(C)]
	JRST BJUO2B
	JRST 4,.

BJBO3:	PUSHJ P,TPFLT	;TURNS CLK ON
	PUSHJ P,MPLDZ
	JRST BJBO

BJUII:	TDZA W,W
BJUAI:	MOVNI W,1
	PUSHJ P,BJIOCC
	XCTR XRW,[MOVES (C)]
	MOVE B,[SETZ 1]	;WAIT FOR OUTPUT IOT
	MOVEM B,SRN3(U)
BJUI1:	HRLZ T,A	;JOB INDEX
	HRR T,JBCUI(A)	;CREATOR'S USER INDEX
	PUSHJ P,CWAIT
	PUSHJ P,BJWAIT
	HRLI T,250000	;MAKE MY MAP POINT AT CREATOR
	MOVE J,T
	PUSHJ P,PLD1	;LOAD UP NEW MAP
	MOVE TT,JBSTS(A)
	TLNE TT,200000
	JRST BJUIB	;BLOCK MODE CREATOR IOT
	MOVE D,TT
	XOR D,W
	JUMPGE D,BJUO4
	MOVE D,SRN3(T)	;CREATOR'S USER MODE SOURCE ADDRESS
	XCTR XRI,[MOVE H,(D)]	;TRY TO FETCH JOB DATA
	JRST BJUI2	;SUCCESSFUL
BJUI3:	PUSHJ P,TPFLT	;TURNS CLK ON
	PUSHJ P,MPLDZ
	JRST BJUI1

BJUI2:	PUSHJ P,PLDZ
	SKIPGE W	;SKIP IF BOJ IOT IS IMAGE
	ANDI H,177	;ASCII MODE
	XCTR XWI,[MOVEM H,(C)]
	JRST .+2
	JRST 4,.
BJUI4:	TDZA I,I
BJUI4B:	MOVNI I,1
	MOVSI D,(SETZ)
	IORM D,JBWST(A)	;SET SUCCESSFUL JOBRET BIT
	MOVSI D,JBVAL+JBSTR
	ANDCAM D,JBWST(A)
	MOVEI D,0
	DPB D,[350400,,JBSTS(A)]	;DON'T SKIP
	MOVE D,FLSINS(T)
	SETZM FLSINS(T)	;RESTART CREATOR
	CONSO PI,1
	CAME D,JBFLS
	JRST 4,.	;HE WASN'T WHERE HE BELONGED
	JUMPE I,CLKONJ	;UNHANG IF NOT BLK
	XCTR XRI,[MOVE D,(C)]
	JRST .+2
	JRST 4,.
	JUMPGE D,CLKONJ
	MOVE D,JBWST(A)
	TLNN D,4000	;BOJ BLK UNHANG BIT
	JRST BJBI
	JRST CLKONJ

BJUIB:	MOVE D,SRN3(T)	;ADDRESS OF CREATOR'S POINTER
	XCTR XRWI,[MOVES B,(D)]
	JRST .+2	;NO FAULT
	JRST BJUI3
	JUMPL W,BJUIBA	;BOJ ASCII IOT
	XCTR XRI,[MOVE H,(B)]
	JRST .+2
	JRST BJUI3
	ADD B,[1,,1]
	XCTR XWI,[MOVEM B,(D)]
	JRST BJUI2
	JRST 4,.

BJUIBA:	LDB E,[410300,,B]	;CHAR COUNT
	MOVEI H,0
	CAIGE B,3
	JRST BJUI2
	MOVE E,BTOCHT-3(E)
	XCTR XRI,[MOVE W,(B)]
	JRST .+2
	JRST BJUI3
	ILDB H,E
	ADD B,[700000,,]
	TLNN B,500000
	ADD B,[500001,,1]
	XCTR XWI,[MOVEM B,(D)]
	JRST BJUI2
	JRST 4,.

BJBI:	PUSHJ P,BJIOCC
	MOVEI I,0
	JSP TT,BJCLST
	XCTR XRW,[MOVES D,(C)]	;D GETS IOT POINTER
	HLRO E,D
	IORI E,700000	;FLUSH CHAR CNT
	HRRZ T,D
	SUB T,E
	CAILE T,-1
	JRST IOADC
	MOVE B,[SETZ 1]
	MOVEM B,SRN3(U)
	HRLZ T,A
	HRR T,JBCUI(A)
	PUSHJ P,CWAIT
	PUSHJ P,BJWAIT	;WAIT FOR JOB OUTPUT IOT
	JUMPGE D,BJUI4	;THROUGH
	MOVE TT,JBSTS(A)
	HRLI T,250000
	MOVE J,T
	PUSHJ P,PLD1
	TLNE TT,200000
	JRST BJBB	;CREATOR IOT IS IN BLOCK MODE
	MOVE E,SRN3(T)
	XCTR XRI,[MOVE H,(E)]
	JRST .+2
	JRST BJBI3
	PUSHJ P,PLDZ
	TLNN TT,400000
	JRST BJBIA
	XCTR XWI,[MOVEM H,(D)]
	JRST .+2
	JRST 4,.
	ADD D,[1,,1]
	XCTR XWI,[MOVEM D,(C)]
	JRST BJUI4B
	JRST 4,.

BJBIA:	LDB E,[410300,,D]
	CAIGE E,3
	JRST BJUI4
	MOVE E,BTOCHT-3(E)
	XCTR XRI,[MOVE W,(D)]
	JRST .+2
	JRST BJBI3
	IDPB H,E
	XCTR XWI,[MOVEM W,(D)]
	JRST .+2
	JRST 4,.
	ADD D,[700000,,]
	TLNN D,500000
	ADD D,[500001,,1]
	XCTR XWI,[MOVEM D,(C)]
	JRST BJUI4B
	JRST 4,.

BJBI3:	PUSHJ P,TPFLT	;TURNS CLK ON
	PUSHJ P,MPLDZ
	JRST BJBI

BJCLST:	MOVSI T,100000	;INPUT JOBCLS
	SKIPN I
	MOVSI T,40000	;OUTPUT JOBCLS
	TDNE T,JBWST(A)
	POPJ P,
	JRST (TT)

BJ3T:	BJBI3
	BJBO3

BJOV:	BJBI
	BJBO

BJB2:	BJUI4B
	BJUO2B

BJBB:	MOVEM J,SRN4(U)	;UMAPS FOR PURELY CREATOR MAP
	MOVE E,SRN3(T)
	XCTR XRWI,[MOVES H,(E)]
	JRST BJBBL1
	JRST @BJ3T(I)

BJBBL:	MOVE J,SRN4(U)
	PUSHJ P,PLD1
	MOVE E,SRN3(T)
	XCTR XRWI,[MOVES H,(E)]
	JRST BJBBL1
	JRST 4,.
BJBBL1:	PUSHJ P,PLDZ
	XCTR XRWI,[MOVES D,(C)]
	JRST .+2
	JRST 4,.
	JUMPGE H,@BJB2(I)	;H HAS JOB BLOCK IOT POINTER
	JUMPGE D,CLKONJ	;D HAS BOJ BLOCK IOT POINTER
	HLRE B,H
	CAML D,H
	HLRE B,D	;CHOOSE SMALLER OF TWO BLOCK SIZES
	MOVNS B		;COUNT TO BE XFERRED
	HRLZ E,H	;JOB ADDRESS
	HRR E,D		;JOB,,BOJ  (FROM,,TO FOR BOJ INPUT)
	HLRZ Q,E	;JOB ADDRESS
	CAIGE Q,20
	JRST BJBB1	;JOB ADDR IS AN AC
	HRRZ J,T	;SET UP UMAPS (JOB USER INDEX IN RH)
	TRZE E,400000
	TLOA J,200000	;TO HI PG, HACK OUR LO PAGE
	TLO J,100000	;TO LO PG, HACK OUR HI PAGE
	TLZE E,400000
	TLOA J,20000	;TO POINT TO HIS UPPER
	TLO J,40000	;TO POINT TO HIS LOWER
	TLNN J,140000	;UPPER TO UPPER XFER
	JRST BJBB3	;YES.  MAKE SURE NOT SCREWED BY AC PNTR
BJBB3A:	PUSHJ P,PLD1
	TRZ Q,400000
	MOVNS Q		;LIMIT SIZE OF XFER TO MIN OF
	ADDI Q,400000	;DIST OF TO ADR FROM SEG BOUNDARY
	CAMLE B,Q	;AND DIST OF FROM ADR TFROM SEG BOUNDARY
	HRRZ B,Q
	MOVNI Q,(E)	; - BOJ ADDR
	ADDI Q,400000
	CAMLE B,Q
	HRRZ B,Q
	TLNN J,200000	;BUGGER ADDRESSES SO RIGHT DBRS WILL BE USED
	TLOA E,400000	;SET JOB ADDR TO HI PAGE
	TRO E,400000	;SET BOJ ADDR TO HI PAGE
	SKIPE I
	MOVSS E		;XFER OTHER DIRECTION
	MOVE Q,E	;SAVE COPY OF BLT POINTER
	ADDI B,(E)	;GET LA + 1
	XCTR XRWI,[BLT E,-1(B)]	;XFER DATA
	MOVEI E,(B)	;NO FAULT.  SIMULATE STORE BACK OF POINTER
	PUSH P,J
	PUSHJ P,PLDZ
	SUBM E,Q
	HRLS Q		;NUMBER OF WORDS ACTUALLY XFERRED
BJBB2:	XCTR XRWI,[ADDM Q,(C)]
	JRST .+2
	JRST 4,.
	MOVE J,SRN4(U)
	PUSHJ P,PLD1
	POP P,J
	MOVE W,SRN3(T)
	XCTR XRWI,[ADDM Q,(W)]
	JRST .+2
	JRST 4,.
	CAIN B,(E)
	JRST BJBBL	;NO FAULT
	PUSHJ P,PLD1	;RESTORE TO FROB AT TIME OF FAULT
BJBBF:	PUSHJ P,TPFLT	;TAKE FAULT (TURNS CLK ON)
	PUSHJ P,MPLDZ
	JRST @BJOV(I)

BJBB1:	ADDI Q,UUOACS(T)
	JUMPN I,BJBB1A
	MOVE B,(Q)	;READ JOB WORD
BJBB3C:	XCTR XWI,[MOVEM B,(E)]
	JRST .+2
	JRST BJBBF
BJBB2A:	MOVE Q,[1,,1]	;1 WORD XFERRED
	HRRZ B,E	;FAKE OUT FAULT TEST
	PUSH P,J
	JRST BJBB2

BJBB1A:	XCTR XRI,[MOVE B,(E)]
	JRST .+2
	JRST BJBBF
	MOVEM B,(Q)
	JRST BJBB2A

BJBB3:	TLNE E,777760	;SKIP OIN XFERRING FROM AC AREA, HI TO HI
	JRST BJBB3A	;NO.  OK TO DO BLT
	JUMPN I,BJBB3B
	HRLI J,120000	;HACK OUR HI TO POINT TO HIS HI
	PUSHJ P,PLD1
	XCTR XRI,[MOVE B,(Q)]
	JRST .+2
	JRST BJBBF
	PUSHJ P,PLDZ
	HRRZ E,D	;TO ADDRESS
	JRST BJBB3C

BJBB3B:	XCTR XRI,[MOVE B,(D)]
	JRST .+2
	JRST BJBBF
	HRLI J,120000
	PUSHJ P,PLD1	;HACK OUR HI TO POINT TO HIS HI
	XCTR XWI,[MOVEM B,(Q)]
	JRST .+2
	JRST BJBBF
	PUSHJ P,PLDZ
	JRST BJBB2A

NJBSET:	JUMPL A,OPNL14	;BAD CHANNEL NUM.
	CAIL A,20
	JRST OPNL14
	ADDI A,IOCHNM(U)
	HRRZ D,(A)
	MOVE C,CLSTB(D)
	TLNN C,4000	;SKIP IF BOJ
	JRST OPNL34	;WRONG TYPE DEVICE.
	HLRZ E,(A)	;JOB CHNL INDEX
	CONO PI,CLKOFF
	JRST (T)
;	.CALL ADR
;	ERROR RETURN
;	NORMAL RETURN

;ADR:	SETZ
;	SIXBIT /JOBGET/
;	[BOJCHNL]
;	2000,,WD1
;	2000,,WD2
;UP TO SIX WDS RETURNED

;WD1 BITS:
;4.9-4.7 => IMAGE/ASCII, BLOCK/UNIT, OUTPUT/INPUT
;4.6 => INPUT CLOSE
;4.5 => OUTPUT CLOSE
;1.4-1.1 => TYPE OF SYSTEM CALL
	;0	OPEN
	;1	IOT
	;2	STATUS
	;3	RESET
	;4	RCHST
	;5	ACCESS
	;6	FDELE (DELETE OR RENAME)
	;7	FDELE (RENAME WHILE OPEN)

;WD2 SET ONLY FOR BLOCK IOT POINTER, ACCESS POINTER, SYS NAME FOR FDELE
;WD3	FN1
;WD4	FN2
;WD5	SYS NAME (FN3)
;WD6	LEFT ADJUSTED DEVICE NAME (FN4)
;IGNORE ALL RETURNED INFO ON AN ERROR RETURN
;IF 4.5 OR 4.6 IS SET THEN ALL ELSE IS MEANINGLESS

NJBGT:	JSP T,NJBSET
	MOVE A,JBWST(E)
	AND A,[<JBINCL+JBOUCL>,,]
	JUMPN A,NJBGT1
	MOVE A,JBWST(E)
	TLNN A,JBVAL
	JRST NJBGTE	;FAIL IF VALID NOT SET
	TLZ A,JBSTR
	MOVEM A,JBWST(E)	;CLEAR STORED BIT
	MOVE A,JBSTS(E)
	TLZ A,60000
	MOVE B,JBST2(E)
	MOVE C,JBOFN1(E)
	MOVE D,JBOFN2(E)
	MOVE TT,JBODEV(E)
	MOVE E,JBOSYN(E)
	CONO PI,CLKON
	JRST SYSCPS

NJBGT1:	ANDCAM A,JBWST(E)
	LSH A,-1
	CONO PI,CLKON
	JRST SYSCPS

NJBGTE:	JUMPL A,NJBRTE	;NOT INITIAL OPEN
	MOVSI A,400
	IORM A,JBWST(E)	;INDICATE FAILING JOBGET ON INITIAL OPEN
	JRST NJBRTE


;	.CALL ADR
;	ERROR RETURN
;	NORMAL RETURN

;ADR:	SETZ
;	SIXBIT /JOBRET/
;	[BOJCHNL]
;	SETZ [OPEN LOSS #(IF RH = 0),,# TIMES FOR CREATING JOB TO SKIP]

NJBRT:	JSP T,NJBSET
	MOVE A,JBWST(E)
	TLNE A,JBVAL
	TLNE A,JBSTR
	JRST NJBRTE	;FAIL IF STORED IS SET OR IF VALID IS CLEARED
	HRRZ TT,JBCUI(E)
	HRRZ I,UPC(TT)
	MOVE D,FLSINS(TT)
	CAME D,JBFLS
	CAIN I,JBPCL
	JRST .+2
	JRST 4,.
	TLO A,(SETZ)
	TLZ A,JBVAL+JBSTR
	MOVEM A,JBWST(E)	;SET SUCCESSFUL JOBRET BIT
	DPB B,[350400,,JBSTS(E)]	;NUMBER OF TIMES TO SKIP
	MOVSS B
	DPB B,[270600,,JBSTS(E)]	;OPEN LOSS
	SETZM FLSINS(TT)
	JRST CLKOJ1

NJBRTE:	CONO PI,CLKON
	JRST OPNL36

JOBCLS:	MOVSI T,JBINCL	;C HAS CLSTB ENTRY
	TLNN C,100000	;SKIP IF JOB INPUT
	MOVSI T,JBOUCL
	IORM T,JBWST(A)	;TURN ON INCLS OR OUTCLS
	MOVE E,A
	CONO PI,CLKOFF
	PUSHJ P,JBINT	;GIVE INT
	SOSGE B,JBNTO(A)
	JRST 4,.
	MOVEI D,-1
	MOVE TT,[000600,,JBCH(A)]
	TLNN C,100000
	MOVE TT,[060600,,JBCH(A)]	;JOB OUTPUT
	DPB D,TT
	JUMPE B,JOBCL1
	MOVEI D,1	;BOJ JOB STILL OPEN ONCE,
	TLNN T,JBINCL
	MOVEI D,0
	DPB D,[420100,,JBWST(A)]
	JRST CLKONJ		;SET BIT FOR DIRECTION STILL OPEN.

JOBCL1:	SETOM JBCG(A)	;INDICATE CREATOR GONE AWAY
	SKIPGE JBCJUI(A)	;SKIP IF BOJ GUY STILL AROUND
	SETOM JBCUI(A)	;FLUSH CHNL
	JRST CLKONJ

BOJCLS:	SOSGE BJNTO(A)
	JRST 4,.
	MOVEI D,-1
	LDB TT,[220600,,JBCH(A)]
	CAMN TT,UUAC(U)
	DPB D,[220600,,JBCH(A)]
	LDB TT,[300600,,JBCH(A)]
	CAMN TT,UUAC(U)
	DPB D,[300600,,JBCH(A)]
	POPJ P,

JBIRS:	JRST ILUUO
JBORS:	JRST ILUUO
BJIRS:	JRST ILUUO
BJORS:	JRST ILUUO

;	.CALL ADR	;WON'T SKIP
;ADR:	SETZ
;	SIXBIT /SETIOC/
;	ARG1
;	SETZ ARG2

;ARG1:	CHANNEL JOB OR BOJ DEVICE IS OPEN ON
;ARG2:	TYPE OF IOCER TO CAUSE

;THIS CALL CAUSES THE NEXT IOT EXECUTED BY THE
;PROCEDURE ON THE OTHER END OF THE CHANNEL TO GET
;THE SPECIFIED IO CHANNEL ERROR

NSTIOC:	TDNE A,[-1,,777760]
	JRST OPNL14
	CAIL B,MIOTER
	CAILE B,NIOTER
	JRST OPNL33	;BAD ARG. (NOT LEGAL IOCER)
	TLO B,(SETZ)	;IN CASE IOCER 0 EVER EXISTS
	MOVEI R,IOCHNM(U)
	ADDI R,(A)	;IOCHNM POINTER
	HLRZ E,(R)	;JOB CHANNEL NUMBER
	HRRZ A,(R)
	HLLZ C,CLSTB(A)
	TLNN C,104040
	JRST OPNL34	;NOT JOB OR BOJ CHANNEL
	CONO PI,CLKOFF
	TLNN C,4000	;SKIP IF BOJ CHANNEL
	SKIPA A,JBCJUI(E)	;STOP CREATED JOB
	SKIPA A,JBCUI(E)	;STOP CREATING JOB
	TDZA I,I	;I=0 => JBIOCB
	MOVEI I,1	;I=1 => JBIOCJ
	SKIPGE @JBIOCT(I)
	JRST CLKONJ	;GUY WENT AWAY
	PUSHJ P,RPCLSR	;STOP
	MOVEM B,@JBIOCP(I)
	JRST UPCLSR

JBIOCP:	JBIOCB(E)
	JBIOCJ(E)

JBIOCT:	JBCJUI(E)	;-1 IF BOJ JOB GONE
	JBCG(E)	;-1 IF JOB JOB GONE

;	.CALL ADR	;SKIPS UNLESS JOB END OF CHNL NOT THERE

;ADR:	SETZ
;	SIXBIT /JOBINT/
;	401000,,BOJCH

;GIVE CREATOR A SECOND WORD INT ON CHANNEL CORRESP TO BOJCH

NJBINT:	TDNE A,[-1,,777760]
	JRST OPNL14
	MOVEI R,IOCHNM(U)
	ADDI R,(A)
	HLRZ E,(R)	;CHNL #
	HRRZ A,(R)
	HLLZ C,CLSTB(A)
	TLNN C,4000
	JRST OPNL34
	MOVE A,JBCJUI(E)
	MOVE B,[300400,,JBCH(E)]
	LDB C,B
	CAMN C,UUAC(U)
	JRST NJBIN1
	SUB B,[060000,,]
	LDB C,B
	CAME C,UUAC(U)
	JRST 4,.
NJBIN1:	SUB B,[<220000,,>-<0200,,>]	;MAKE INTO 6 BIT POINTER
	LDB C,B
	TRNE C,20
	JRST CLKONJ	;THAT END DOESN'T EXIST
	ANDI C,17
	MOVE C,CHNBIT(C)
	IORM C,IFPIR(A)
	JRST CLKOJ1

;FIRST FILE NAME MUST BE TTY NUMBER (NOT CHARACTERS)
;IGNORES MODE AND GIVES CHARACTER INPUT

SPYO:	JUMPL A,OPNL11
	CAIL A,NCT
	JRST OPNL11
	MOVE E,TIIP(A)
	MOVEM E,IOCHST-IOCHNM(R)
	MOVEI C,ISPY
	HRL C,A
	MOVEM C,(R)
	JRST POPJ1

;A HAS LH OF IOCHNM =TTY #

SPYI:	MOVE T,IOCHST-IOCHNM(R)	;POINTER TO INPUT BUFFER
	HRRZ B,TIBEP(A)
	CAIL B,(T)
	CAILE B,TIBL(T)
	JRST SPYIL
SPYILL:	CAMN T,TIIP(A)
	PUSHJ P,UFLS
	CAMN T,TIBEP(A)
	SUBI T,TIBL
	HRRM T,IOCHST-IOCHNM(R)
	ILDB B,IOCHST-IOCHNM(R)
	ANDI B,177
	XCTR XW,[MOVEM B,(C)]
	POPJ P,

SPYIL:	MOVE T,TIIP(A)
	MOVEM T,IOCHST-IOCHNM(R)
	JRST SPYILL

;	.CALL FOO
;	RETURN

;FOO:	SETZ
;	SIXBIT /RANGET/
;	402000,,BAR

;BAR:	0		;RETURNS 4.9=1 => DOES NOT HAVE TTY NOW
					;1.1-1.6 CONSOLE TTY #
					;1.7-2.3 USER #


ARANGT:	MOVE A,TTYTBL(U)
	AND A,[400000,,000077]
	MOVE B,U
	IDIVI B,LUBLK
	JUMPN C,[JRST 4,.]
	DPB B,[60600,,A]
	JRST SYSCPT


;MODE BITS (LH)
;3.1=0 => INPUT   =1 => OUTPUT  (FROM PROGRAM POINT OF VIEW)
;3.2=0 => UNIT    =1 => BLOCK
;(THERE IS NO IMAGE MODE)
;INPUT
;3.4=1 => DON'T HANG ON INPUT IOTS, INPUT -1 INSTEAD (IGNORED ON OUTPUT OPEN)

STTYO:	SKIPE I,USTYN(U)
	JRST STTYO3	;JUMP IF STY ALREADY OPEN
	PUSHJ P,SWTL	;LOCK STY OPEN SWITCH
	STYOSW
	MOVE I,[-NSTTYS,,NFSTTY]
STTYO1:	SKIPE STYSTS-NFSTTY(I)	;SKIP ON FREE SLOT
STTYO5:	AOBJN I,STTYO1
	JUMPGE I,OPNL6	;NO SLOTS.  GIVE DEVICE FULL
	SKIPGE TTYSTA(I)	;SKIP IF CONSOLE FREE MSG NOT TYPED.
	SKIPE TTNTO(I)		;SKIP IF NOT OPEN.
	JRST STTYO5
	HRRZM I,USTYN(U)	;STORE TTY NUMBER OF STY
STTYO4:	SETZM STYNTO-NFSTTY(I)
	SETZM STYMSK-NFSTTY(I)
	SETZM TCTYP(I)	;INITIALIZE TO TTY
	MOVE TT,CNSLHL
	MOVEM TT,TCMXH(I)
	MOVE TT,CNSLVL
	MOVEM TT,TCMXV(I)
	MOVEM TT,TCMXP(I)
	CLEARM TCECL(I)
	MOVSI TT,200000
	MOVEM TT,STYSTS-NFSTTY(I)	;SET IN USE BIT
	CONO PI,TTYOFF
	MOVEI TT,TOBS
	MOVEM TT,TORM(I)
	MOVE TT,TOIP(I)
	MOVEM TT,TOOP(I)
	SETOM TTYOAC(I)
	CONO PI,TTYON
	PUSHJ P,LSWPOP	;UNLOCK STY OPEN SWITCH
	HRRM U,STYSTS-NFSTTY(I)
STTYO3:	JUMPL D,STTYO2	;JUMP IF OPENING FOR OUTPUT
	MOVSI TT,(SETZ)
	TLNE C,10
	IORM TT,STYSTS-NFSTTY(I)
STTYO2:	MOVE J,R
	SUBI J,IOCHNM(U)	;CHANNEL BEING OPENED FOR INPUT ON
	MOVE J,CHNBIT(J)
	SKIPL D	;SKIP IF OUTPUT
	IORM J,STYMSK-NFSTTY(I)
	SKIPGE D	;SKIP IF INPUT
	IORM J,STYOMS-NFSTTY(I)
	AOS STYNTO-NFSTTY(I)
	HRLZ A,I	;LH OF IOCHNM GETS STY NUMBER
	MOVSS C
	JSP Q,OPSLC3
	STYDUI,,STYDUO
	STYDBI,,STYDBO

;ENTRY FOR OPEN OF PSEUDO-TTY AS SNM OR STN
STTYOA:	JUMPL I,OPNL1
	CAIL I,NSTTYS
	JRST OPNL1
	PUSHJ P,SWTL
	STYOSW
	SKIPN TT,STYSTS-NFSTTY(I)	;SKIP IF IN USE
	JRST STTYO4	;OK TO OPEN IF FREE
	CAIE U,(TT)
	JRST OPNL10	;DIFFERENT USER HAS IT OPEN
	PUSHJ P,LSWPOP
	JRST STTYO3

;PSEUDO-TTY INPUT ROUTINE.  RETURNS CHAR WITHOUT PARITY BIT
STTYI:	MOVE I,A
STTYIA:	SKIPGE TTYOAC(I)	;SKIP IF ANY CHARS AVAIL (MAYBE)
	JRST STTYI1
	SKIPL C
	XCTR XRW,[MOVES (C)]	;TAKE TRAP HERE IF GOING TO TAKE ONE
STTYI4:	PUSH P,C
	PUSH P,E
	CONO PI,TTYOFF
	PUSHJ P,TYP0B
	POP P,E
	POP P,C
	SKIPGE TTYOAC(I)
	JRST STTYI2	;REALLY NO CHARS AVAIL
	CONO PI,TTYON
	MOVE A,STYICH-NFSTTY(I)
	JUMPL A,STTYI4
	MOVE D,A
	JRST UPUTB

STTYI2:	CONO PI,TTYON
STTYI1:	SKIPGE STYSTS-NFSTTY(I)
	JRST STTYI3	;DON'T HANG
	SKIPGE TTYOAC(I)
	PUSHJ P,UFLS
	JRST STTYIA

STTYI3:	MOVNI D,1
	JRST UPUTB2

;PSEUDO-TTY OUTPUT
STTYW:	MOVE I,A
	XCTR XR,[MOVE A,(C)]
BSTTYW:	MOVEI T,TIBS
	CAMG T,TICC(I)
	PUSHJ P,UFLS	;HANG UNTIL ROOM IN INPUT BUFFER
	CONO PI,TTYOFF
	PUSHJ P,NTYI5
	MOVE U,USER
	MOVE R,UUAC(U)
	MOVE R,CHNBIT(R)
	ANDCAM R,IFPIR(U)	;FLUSH ANY OUTPUT INTERRUPT
	MOVSI R,100000
	ANDCAM R,STYSTS-NFSTTY(I)
	CONO PI,TTYON
	POPJ P,

STTBI:	JSP E,INBTCH
	JRST STTYI

STTBO:	JSP E,NBTOCH
	CAIN A,EOFCH
	POPJ P,
	HLRZ I,(R)
	PUSH P,R
	PUSH P,D
	PUSH P,TT
	PUSH P,E
	PUSH P,C
	PUSHJ P,BSTTYW
	POP P,C
	POP P,E
	POP P,TT
	POP P,D
	POP P,R
	POPJ P,
STYOCL:	SUBI R,IOCHNM(U)
	MOVE B,CHNBIT(R)
	ANDCAM B,STYOMS-NFSTTY(A)
	JRST STYCL

STYICL:	SUBI R,IOCHNM(U)
	MOVE B,CHNBIT(R)
	ANDCAM B,STYMSK-NFSTTY(A)
STYCL:	SOSE STYNTO-NFSTTY(A)
	POPJ P,
	PUSHJ P,STYOC1	;LEAVES CLOCK OFF
	HRRE C,TTYSTS(A)	;GET USER INDEX
	JUMPL C,STYOC8	;NO USER
	JUMPE C,STYOC4
	PUSH P,U
STYOC3:	HRRZ U,C
	SKIPL C,SUPPRO(U)
	JRST STYOC3	;NOT TOP LEVEL
	PUSH P,A
	AOS STYNTO-NFSTTY(A)	;IN CASE OF PCLSR
	HRRZ A,U
	PUSHJ P,1USTOP	;STOP HIM (TURNS CLOCK ON)
	MOVE T,TTYTBL(U)
	TLNE T,200000
	JRST STYOC2	;NEVER HAD TTY
	TLNE T,100000
	JRST 4,.	;TTY TAKEN AWAY FROM TOP
	PUSHJ P,SDTTY	;SHOULD NOT GET BACK TO ATTY SINCE TTY COULD NOT
	JRST 4,.	;HAVE BEEN TAKEN AWAY
	PUSHJ P,IODCL	;CAUSE HIS TREE'S RUNTIMES TO BE ADDED TO NCTIM
	MOVE T,UTMPTR(U)
	MOVE T,NCTIM-USRRCE(T)
	ADD T,UTRNTM(U)	;ADD IN TOP LEVEL'S RUNTIME
	ADDM T,TMGUND	;FOR THE TIME BEING, CHARGE TO GUNNED USERS
STYOC2:	PUSH P,UUOH
	PUSHJ P,ALOGOUT	;BYE-BYE
	POP P,UUOH
	POP P,A
	POP P,U
	SOS STYNTO-NFSTTY(A)
STYOC4:	CONO PI,TTYOFF
	HRRE TT,TTYSTS(A)
	JUMPE TT,STYOC9	;SYS JOB HAS TTY OPEN.
	SKIPN TTNTO(A)
	AOJE TT,STYOC5
	JRST 4,.	;GUY SHOULD HAVE BEEN LOGGED OUT AND CLOSED TTY
STYOC5:	MOVEI TT,TOBS
	MOVEM TT,TORM(A)
	MOVE TT,TOIP(A)
	MOVEM TT,TOOP(A)
	SETOM TTYOAC(A)
STYOC9:	SETZM STYSTS-NFSTTY(A)
	CONO PI,TTYON
	SETZM USTYN(U)
	POPJ P,

STYOC1:	CONO PI,TTYOFF
	SKIPL T,TTYCOM(A)
	JRST STYOC7
STYOC6:	HRRZ TT,T
	HRRE T,TTYCOM(TT)
	JUMPL T,STYC6A	;NOT COMMUNICATING WITH ANYONE
	CAIE T,(A)
	JRST STYOC6
	HRRZ T,TTYCOM(A)
	HRRM T,TTYCOM(TT)
	MOVEI C,-1
	MOVEM C,TTYCOM(A)
	MOVEI B,TTYI
	MOVEM B,TTYIPC(A)
	CAIE TT,(T)
	JRST STYOC7
STYC6B:	MOVEM C,TTYCOM(TT)
	MOVEM B,TTYIPC(TT)
STYOC7:	CONO PI,TTYON#<200_-APRCHN>	;LEAVE CLOCK OFF
	POPJ P,

STYC6A:	MOVEI C,-1
	MOVEI B,TTYI
	JRST STYC6B

STYOC8:	MOVSI C,1000
	TDNE C,TTYSTS(A)	;SKIP IF ^Z HASNT CAUSED LOAD YET
	JRST STYOC4
	CONO PI,CLKON
	AOS STYNTO-NFSTTY(A)
	MOVE T,A
	PUSHJ P,STYOCF
	PUSHJ P,UFLS
	JRST STYCL

STYOCF:	HRRE C,TTYSTS(T)
	AOJN C,POPJ1
	POPJ P,

STYIRS:	HLRZ I,(R)
	CONO PI,TTYOFF
	MOVEI TT,TOBS
	MOVEM TT,TORM(I)
	MOVE TT,TOIP(I)
	MOVEM TT,TOOP(I)
	SETOM TTYOAC(I)
	CONO PI,TTYON
	POPJ P,

;	.ATTY USR,		OPER 11

AATTY:	HLRZ A,(R)	;A HAS INFERIOR'S USER INDEX
	HRRZ B,(R)
	SKIPL CLSTB(B)	;SKIP IF USER OPEN ON CHANNEL
	POPJ P,
	PUSHJ P,RPCLSR
	PUSHJ P,SOSSET
	USTP(A)
	CONO PI,CLKOFF
	MOVE B,TTYTBL(U)
	JUMPL B,AATT1	;DOESNT HAVE TTY NOW
	MOVSI D,4
	TDNE D,TTYSTS(B)
	JRST AATT5	;LAST CHR WAS ^Z
	HRLI A,400000
	MOVEM A,TTYTBL(U)	;NO LONGER HAS TTY.  STORE USER INDEX GIVEN TO
	MOVE D,TTYST1(B)
	MOVEM D,TTSTSV(U)
	MOVE D,TTYST2(B)
	MOVEM D,TTSTSV+1(U)
	MOVE D,TTYSTS(B)
	ANDCM D,HARBTS	;CLEAR HARDWARE ASSOCIATED BITS
	MOVEM D,TTSTSV+2(U)	;SAVE TTY STATUS
	MOVE D,TCECL(B)
	DPB D,[220600,,TTYTBL(U)]
	PUSHJ P,AATT4
AATT7:	SETZM TYIMSK(B)
	MOVE E,TTYSTS(B)
	AND E,HARBTS	;GET HARDWARE ASSOCIATED BITS
	IOR A,E	;TOGETHER WITH SOFTWARE BITS
	MOVEM A,TTYSTS(B)	;RESTORE OLD TTY STATUS
	MOVEM TT,TTYST1(B)
	MOVEM T,TTYST2(B)
	LDB E,[220600,,TTYTBL(A)]
	MOVEM E,TCECL(B)
	SUB E,TCMXV(B)
	MOVNM E,TCMXP(B)
	MOVEM B,TTYTBL(A)
	MOVE E,B	;TTY NUMBER
	MOVEI D,IOCHNM(A)
	PUSHJ P,AATT8
	JRST CKOPJ1


AATT4:	MOVE D,TTYTBL(A)
	TLNE D,100000
	JRST AATT2	;TAKEN AWAY
	HRLI A,BCNSBT	;INITIALIZE STATUS, NEVER HAD IT
	SETZB T,TTSTSV+1(A)
	SETZB TT,TTSTSV+2(A)
	POPJ P,

AATT2:	TLNE D,10000	;SKIP IF NOT TAKEN FROM ME
	JRST AATT3	;GUY IT WAS TAKEN FROM (I.E. HE HADN'T GIVEN IT TO SOMEONE ELSE)
	TLZ D,100000	;NO LONGER TAKEN AWAY
	MOVEM D,TTYTBL(A)
	HRRZ A,TTYTBL(A)
	JRST AATT4

AATT3:	HRRZS B		;TTY NUMBER
	HLL A,TTSTSV+2(A)
	TLZ A,400004	;CLEAR TTY NOT OPEN AND ^Z BITS
	MOVE TT,TTSTSV(A)	;GET SAVED TTY STATUS
	MOVE T,TTSTSV+1(A)
	POPJ P,

AATT8:	HRLI D,A	;INDIRECTION POINTER TO INFERIOR'S IO CHANNELS
	MOVSI A,-20	;AOBJN POINTER
	MOVSI TT,20000	;TYI BIT IN CLSTB
	MOVEI C,0	;INITIALIZE MASK
AATT9:	MOVE B,@D	;GET IOCHNM IN B
	JUMPGE B,AATT10	;IF CHANNEL HAS CONSOLE BIT SET,
	TDNE TT,CLSTB(B)	;AND CHANNEL OPEN FOR TYI,
	IOR C,CHNBIT(A)	;THEN SET BIT IN MASK
AATT10:	AOBJN A,AATT9	;TRY NEXT CHANNEL OR CONTINUE IF DONE
	MOVEM C,TYIMSK(E)	;STORE MASK
	CONO PI,TTYOFF	;SINCVE TTYSET CHANGED
	JRST ATTYS1	;ALL CHRS SO FAR ARE ACTIVATION CHRS


AATT1:	TLNE B,200000
	JRST CLKOPJ	;NEVER HAD TTY
	TLZ B,10000	;SAY OUR INFERIOR HAD IT WHEN TAKEN
	HRRI B,(A)
	MOVEM B,TTYTBL(U)
	PUSHJ P,AATT4	;SET UP HIS VARS
	MOVEM A,TTSTSV(A)
	JRST CKOPJ1

AATT5:	PUSHJ P,LSWPOP
	PCLT
	MOVSI T,4
	TDNE T,TTYSTS(B)	;WAIT UNTILL LAST CHR WASNT ^Z
	PUSHJ P,UFLS
	JRST AATTY


ADTTY:	SKIPN USER
	JRST SDTTY	;AVOID BUG IF GET HERE FROM SYSGUN
	HLRZ A,(R)	;OPER 12
	HRRZ B,(R)
	SKIPL CLSTB(B)	;SKIP IF USER OPEN ON CHANNEL
	POPJ P,
SDTTY:	CONO PI,CLKOFF	;CALLED BY UBLAM,AUCL2 SYSGUN,STYOCL (DON'T CLOBBER R)
	MOVE A,TTYTBL(U)
	JUMPGE A,CLKOJ1	;ALREADY HAS IT
	TLNE A,200000
	JRST CLKONJ	;NEVER HAD IT
	TLNE A,100000
	JRST AGBLT1	;TAKEN AWAY WAIT FOR IT TO COME BACK

	;HAVE TO SEIZE IT FROM INFERIOR

AGBLT3:	MOVE E,TTYTBL(A)	;GET CURRENT PROCEDURE'S TTY
	JUMPL E,AGBLT2	;IF THIS GUY DOESN'T HAVE IT THEN TRY THE ONE HE GAVE IT TO
	HRRZS A	;A NOW HAS INDEX OF USER TO SWIPE FROM
	PUSHJ P,RPCLSR
	HRRZ A,TTYTBL(U)	;ACTUALLY GOBBLE TTY
AGBLT6:	MOVE E,TTYTBL(A)	;AND AWAY WE GO!
	JUMPL E,AGBLT5	;ITERATE ON "CURRENT PROCEDURE GAVE TTY AWAY"
	MOVE D,TTYST1(E)	;GET CURRENT TTY STATUS
	MOVEM D,TTSTSV(A)	;SAVE IN SAVE AREA OF USER WE ARE TAKING TTY FROM
	MOVE D,TTYST2(E)
	MOVEM D,TTSTSV+1(A)
	MOVE D,TTYSTS(E)
	ANDCM D,HARBTS	;TURN OFF HARDWARE ASSOCIATED BITS
	MOVEM D,TTSTSV+2(A)
	MOVSI D,510000
	MOVEM D,TTYTBL(A)	;INDICATE TAKEN AWAY FROM HIM AND THAT HE DOESN'T HAVE IT
	MOVE D,TCECL(E)
	DPB D,[220600,,TTYTBL(A)]
	MOVE D,TTSTSV(U)
	MOVEM D,TTYST1(E)
	MOVE D,TTSTSV+1(U)
	MOVEM D,TTYST2(E)
	LDB D,[220600,,TTYTBL(U)]
	MOVEM D,TCECL(E)
	SUB D,TCMXV(E)
	MOVNM D,TCMXP(E)
	MOVE D,TTSTSV+2(U)
	MOVE TT,TTYSTS(E)
	AND TT,HARBTS	;SET HARDWARE ASSOCIATED BITS
	IOR D,TT	;TOGETHER WITH SOFTWARE BITS
	MOVEM D,TTYSTS(E)	;RESTORE TTY STATUS TO MY SAVED STATUS WORDS
	HRRM U,TTYSTS(E)	;INDICATE THAT I HAVE THE TTY
	SETZM TYIMSK(E)
	HRRZM E,TTYTBL(U)
	MOVEI D,IOCHNM(U)	;PREPARE TO GENERATE CHANNELS OPEN MASK
	PUSH P,A
	PUSHJ P,AATT8	;DO SO AND SKIP RETURN
	POP P,A
	PUSHJ P,UPCLSR
	JRST CLKOJ1

AGBLT2:	HRRZ A,TTYTBL(A)
	JRST AGBLT3

AGBLT5:	MOVSI D,100000	;INDICATE TTY TAKEN AWAY
	IORM D,TTYTBL(A)
	HRRZ A,TTYTBL(A)	;GET INDEX OF PROCEDURE THIS PROCEDURE GAVE TTY TO
	JRST AGBLT6

AGBLT1:	TLO A,10000	;TTY WAS TAKEN AWAY
	MOVEM A,TTYTBL(U)	;SAY THIS JOB HAD IT WHEN TAKEN
	JRST CLKOJ1

;SETS TTYST1, TTYST2 AND TTYSTS WHEN THE USER HAS THE TTY
;HANGS UNTIL HE GETS IT
ATTYST:	PUSHJ P,ATTYCK	;TTY NUMBER NOW IN A
	CONO PI,TTYOFF
	MOVEM B,TTYST1(A)
	MOVEM C,TTYST2(A)
	HLLO B,HARBTS
	MOVE C,TTYTYP(A)
	TRNN C,4000
	TLO B,2
	TLO B,BCNSBT+4	;TURN ON CONSOLE AND ^Z BITS SO PROGRAM CAN'T SET THEM
	ANDCM D,B	;TURN THESE BITS OFF IN THE NEW WORD
	ANDM B,TTYSTS(A)
	IORM D,TTYSTS(A)
	AOS (P)	;MAKE ALL CHRS IN BUFFER ACTIVATION CHARS
ATTYS1:	LDB E,TIIP(A)	;MAKE LAST CHAR AN ACTIVATION CHAR
	TRON E,4000
	AOS TACC(A)	;IF IT WASN'T ONE, IS ONE MORE ACT CHAR NOW
	DPB E,TIIP(A)
	JRST TTYONJ

;GETS TTYST1, TTYST2 AND TTYSTS WHEN THE USER HAS THE TTY
;HANGS UNTIL HE GETS IT
ATTYGT:	PUSHJ P,ATTYCK	;TTY NUMBER NOW IN A
	MOVE B,TTYST2(A)
	MOVE C,TTYSTS(A)
	MOVE D,TTYTYP(A)
	MOVE E,TCTYP(A)
	MOVE A,TTYST1(A)
	JRST SYSCPS	;STORE RESULTS BACK IN USER MEMORY

ATTYCK:	JUMPL A,S1NL14
	CAIL A,20
	JRST S1NL14
	ADDI A,IOCHNM(U)
	HRRZ E,(A)
	JUMPLE E,URETJ1	;NOT TTY (CONSOLE OR DEVICE)
	CAILE E,4
	JRST URETJ1	;NOT TTY
	LDB TT,[430100,,(A)]	;GET DEVICE/CONSOLE BIT
	LDB A,[220600,,(A)]	;TTY NUMBER
	JUMPE TT,ATTYC1	;DEVICE
	PCLT
	SKIPGE TTYTBL(U)
	PUSHJ P,UFLS	;HANG UNTIL WE HAVE THE TTY
	HRRZ E,TTYTBL(U)
	CAME E,A
	JRST 4,.	;USER HAS TWO DIFFERENT CONSOLE TTYS
ATTYC1:	HRRZ E,TTYSTS(A)	;USER INDEX THAT HAS THIS TTY
	CAME E,U
	JRST 4,.	;USER HAS TTY BUT TTY DOESN'T HAVE THAT USER
	POPJ P,

ARCPOS:	PUSHJ P,ATTYCK
	PUSHJ P,TYOW
	HRLZ B,TCEVPO(A)
	HRR B,TCEHPO(A)
	HRLZ C,TCMVPO(A)
	HRR C,TCMHPO(A)
	MOVE A,C
	JRST SYSCPS

ASCML:	PUSHJ P,ATTYCK
	HRRZS B
	MOVE C,TCMXV(A)
	CAML B,C
	SOS B,C
	MOVEM B,TCECL(A)
	SUB B,TCMXV(A)
	MOVNM B,TCMXP(A)
	JRST POPJ1

ARSSIZ:	PUSHJ P,ATTYCK
	MOVE C,TCTYP(A)
	MOVE B,CNSLHL(C)
	MOVE A,CNSLVL(C)
	JRST SYSCPS

;LH TTY OPEN
;3.1 0 -> IN 1 -> OUT
;3.2 0 -> UNIT 1 -> BLOCK
;3.3 0 -> ASCII 1 -> IMAGE

;OUTPUT
;3.4 0 -> NORMAL 1 -> ECHO
;3.5 0 -> NORMAL 1 -> DISPLAY
;3.6 0 -> NORMAL 1 -> SUPER QUOTE MODE

;INPUT
;3.4 0 -> NORMAL 1 -> "DDT"
;3.5 0 -> NORMAL 1 -> CONVERT LOWER TO UPPER CASE
;3.6 0 -> NORMAL 1 -> ECHO AT BOTTOM OF SCREEN

;LH OF IOCHNM WD
;(SHOWS UP IN RH OF A ON .IOT, .CLOSE, ETC)

;4.9 1-> CONSOLE 0 -> DEVICE
;4.8 0 -> NORMAL 1 ECHO (ON OUTPUT) OR SUPER QUOTE (DEPENDING ON 4.5)
;4.7-4.6 -> OUTPUT CONTROL CHR ANTICIPATION STATE
	;0 NORMAL 1 EXPECTING 2 EXPECTING V POS 3 EXPECTING H POS
;4.5 IF 4.8=1, 4.5 0 -> MP ECHO OUT, 1 -> SUPER QUOTE OUT
;3.6-3.1 CONSOLE #

;TELETYPE OPEN ROUTINES

;ENTRY FOR OPEN OF "TTY" AS A CONSOLE

TTYO1:	PUSHJ P,TTYFD	;TEST FOR FILE NAME OF .FILE. (DIR)
	MOVE I,TTYTBL(U)
	JUMPGE I,TTYO2	;JUMP IF HAS TTY NOW
	TLNN I,100000	;SKIP IF TTY WAS TAKEN AWAY
	JRST OPNL10	;DOESN'T HAVE TTY NOW AND WASN'T TAKEN AWAY.  LOSE.
	PCLT
	SKIPGE TTYTBL(U)
	PUSHJ P,UFLS	;HANG UNTIL HAS TTY
	MOVE I,TTYTBL(U)
TTYO2:	HRRZS I	;TTY NUMBER
	CAIL I,NCT
	JRST 4,OPNL1	;TTY NUM TOO LARGE
	PUSHJ P,SWTL
	TTYOSW		;LOCK TTY OPEN SW
	LDB Q,[CNSBT,,TTYSTS(I)]	;GET CONSOLE BIT
	JUMPE Q,OPNL10	;JUMP IF TTY NOW OPEN AS DEVICE
	TLO A,400000	;MARK AS CONSOLE
TTYO3:	DPB I,[222100,,A]	;LH OF A WILL BE STORED IN LH OF IOCHNM WORD
IFN NNVTTS,[
	CAIGE I,NOTYS+NNTYS+NNVTTS
	CAIGE I,NOTYS+NNTYS	;SKIP ON NOVA TTY
	JRST TTYO3A
	SKIPGE NOVATT
	JRST OPNL10	;NOVA LINK NOT ACTIVE
TTYO3A:	CAMN I,NOVATT
	JRST OPNL10	;CANT OPEN TTY USED AS CNHL TO NOVA
]
	CONO PI,TTYOFF
	SKIPE TTNTO(I)
	JRST TTYO6
	SETZM TTYST1(I)
	SETZM TTYST2(I)
	SETZM TTYSTS(I)
TTYO6:	SETZM LCHTYO(I)
	SKIPL TT,D	;SKIP IF OPENING FOR OUTPUT
	JRST TTYO4	;OPEN IS FOR INPUT
	TRNE D,20
	JRST TTYO7A	;SUPER QUOTE OUT
	TRNN D,4
	JRST TTYO7	;NORMAL OUT
	TLO A,200000	;ECHO OUTPUT
	MOVEI J,3
	MOVEM J,TCECL(I)
	SUB J,TCMXV(I)
	MOVNM J,TCMXP(I)
TTYO7:	MOVEI J,0
	TRNE D,10	;DISPLAY BIT
	MOVEI J,1
	DPB J,[DISMBT,,TTYSTS(I)]	;M.P. 'S IDEA OF DISPLAY (LOOK FOR ^P?)
	MOVE J,TTYST1(I)
	TRNN D,2	;SKIP ON IMAGE MODE OUTPUT
	TDZA J,[101010,,101010]	;ASCII MODE OUTPUT
	TDO J,[101010,,101010]	;IMAGE MODE OUTPUT
	MOVEM J,TTYST1(I)	;STORE BACK
	MOVE J,TTYST2(I)
	TRNN D,2	;SKIP ON IMAGE MODE OUTPUT
	TDZA J,[101010,,101010]	;ASCII MODE OUTPUT
	TDO J,[101010,,101010]	;IMAGE MODE OUTPUT
	MOVEM J,TTYST2(I)	;STORE BACK
	JRST TTYO5

TTYO7A:	TLO A,220000	;SUPER QUOTE OUT
	SKIPN TTNTO(I)
	JRST TTYO7
	JRST TTYO5	;DONT AFFECT OTHER STATUS IF PREV OPEN

TTYO4:	MOVEI J,0	;INPUT
	TRNE D,20
	MOVEI J,3	;# COMMAND LINES
	MOVEM J,TCECL(I)
	SUB J,TCMXV(I)
	MOVNM J,TCMXP(I)	;LINES FOR M.P.
	MOVE J,TTYST1(I)
	AND J,[101010,,101010]	;SAVE IMAGE MODE OUTPUT BITS
	TRNN D,2	;SKIP ON IMAGE MODE INPUT
	IOR J,[202020,,202020]	;ASCII MODE INPUT
	TRNE D,10	;SKIP ON OLD MODE OFF
	IOR J,[000400,,0]	;OLD MODE INPUT -> CONVERT LOWER CASE TO UPPER
	IOR J,[030303,,030303]	;ENABLE INTERRUPT AND ACTIVATE ON ANY CHARACTER
	MOVEM J,TTYST1(I)	;STORE BACK
	MOVE J,TTYST2(I)
	AND J,[101010,,101010]	;SAVE IMAGE MODE OUTPUT BITS
	TRNN D,2	;SKIP ON IMAGE MODE INPUT
	IOR J,[202020,,202020]	;ASCII MODE INPUT
	TRNE D,4	;SKIP ON NOT DDT MODE
	ANDCM J,[006000,,606000]	;DDT MODE
	IOR J,[030303,,030303]	;ENABLE INTERRUPT AND ACTIVATE ON ANY CHARACTER
	MOVEM J,TTYST2(I)	;STORE BACK
	JUMPL TT,TTYO5	;JUMP ON OUTPUT
	MOVE D,R
	SUBI D,IOCHNM(U)
	MOVE D,CHNBIT(D)
	IORM D,TYIMSK(I)
TTYO5:	HRRM U,TTYSTS(I)
	LDB D,[430100,,A]
	DPB D,[CNSBT,,TTYSTS(I)]
	MOVSI D,400000
	ANDCAM D,TTYSTS(I)	;TTY NOW OPENED FOR SOMETHING
	ANDCAM D,TTYSTA(I)	;WILL NEED CONSOLE FREE MASSAGE TYPED
	AOS TTNTO(I)	;INCREMENT COUNT
	CONO PI,TTYON
	PUSHJ P,LSWPOP	;RELEASE LOCK
	MOVSS C
	JSP Q,OPSLC3	;SET UP IO CHNM WORD AND RETURN
	TYIDN,,TYODN
	TYIBN,,TYOBN


;ENTRY FOR OPEN OF TTY AS DEVICE TYN OR TNM

TTYO:	PUSHJ P,TTYFD	;TEST FOR FILE NAME OF .FILE. (DIR)
	CAIL I,NCT
	JRST OPNL1	;TTY NUM TOO LARGE
	MOVEI A,100000
	TDNE A,TTYTYP(I)
	JRST OPNL10	;TRYING TO OPEN PSEUDO TTY AS TNM DEVICE
	PUSHJ P,SWTL	;LOCK TTY OPEN SWITCH SO TWO PROCEDURES
	TTYOSW		;WON'T OPEN THE TTY AS A DEVICE AT THE SAME TIME
	MOVEI A,0	;MARK AS A DEVICE
	SKIPGE TT,TTYSTS(I)	;SKIP IF TTY OPEN
	JRST TTYO3B	;OK IF TTY NOT OPEN
	CAIE U,(TT)	;SAME USER THAT HAS IT?
	JRST OPNL10	;TTY ALREADY OPEN
	TLNE TT,1	;OPEN AS CONSOLE
	JRST OPNL10	;YES
	JRST TTYO3	;NO DEVICE

TTYO3B:	SKIPE USER
	SKIPGE TTYSTA(I)
	JRST TTYO3
	JRST OPNL10	;CONSOLE FREE MESSAGE NOT TYPED YET

TTYFD:	PUSHJ P,FLDRCK	;SKIP IF FILE DIR BEING OPENED
	JRST TTYFD1	;FILE NAMES NOT SPECIAL
	SUB P,[1,,1]
	MOVEI J,6
	JRST LISTF7	;GO GET DIRCTORY

TTYFD1:	JUMPE W,CPOPJ	;0 IS THE ONLY DEFINED MODE FOR ANY TTY OPEN
	SUB P,[1,,1]
	JRST OPNL12

FLDRCK:	CAMN A,[SIXBIT /.FILE./]
	CAME B,[SIXBIT /(DIR)/]
	POPJ P,
	JRST POPJ1

TTYRST:	HLRZ A,(R)	;ENTRY FOR .RESET
TTYIOT:	TRZN A,400000	;CLEAR AND CHECK CONSOLE/DEVICE BIT
	POPJ P,		;RETURN IF DEVICE
	PCLT
	SKIPGE TTYTBL(U)
	PUSHJ P,UFLS	;WAIT TILL HAS TTY (CANT HAVE TTY IF DISOWNED)
	ANDI A,340000	;SAVE M.P. ECHO, ^P BITS
	IOR A,TTYTBL(U)
	HRRZS A
	POPJ P,

TTYCMW:	ANDI A,77	;FLUSH ALL EXCEPT CONSOLE #
	CONO PI,UTCOFF
	SKIPL TTYCOM(A)
	POPJ P,
	SKIPN USER
	JRST TTYCW3	;SYS JOB TRYING TO HACK
	HRR T,A	;WAIT UNTIL NOT COM MODE OR IN COM MODE BUT ONE OR MORE BITS IN LH OF T
	PUSHJ P,LWAIT1	;COME ON.  WAIT UNTIL OUT OF COM MODE WITH UTCOFF
	PUSHJ P,TYTSCM
	POPJ P,

TTYCW3:	PUSH P,B
	PUSH P,C
	MOVEI C,-1
	MOVEI B,TTYI
	MOVE T,A
TTYCW4:	HRL T,TTYCOM(T)	;GUY WE'RE TALKING TO
	MOVEM C,TTYCOM(T)
	MOVEM B,TTYIPC(T)
	HLRE T,T
	JUMPL T,TTYCW5	;WASN'T COMMUNICATING WITH ANYONE
	CAIE T,(A)
	JRST TTYCW4
TTYCW5:	POP P,C
	JRST POPBJ

TYTSCM:	SKIPL TTYCOM(T)
	JRST POPJ1	;NOT COM MODE
	PUSH P,A
	HLRZ A,T
	TSNE A,TTYCOM(T)
	AOS -1(P)	;MASKED BIT(S) ON
	POP P,A
	POPJ P,


;TTY IOT ROUTINES

;R HAS THE ADDRESS OF THE IOCHNM WORD, A THE LH, B THE RH,
;C THE EFFECTIVE ADDRESS OF THE UUO

;INPUT IOT

TYI:	PUSHJ P,TTYIOT	;WAIT FOR THE TTY IF ITS A CONSOLE.  TTY NUMBER IN A
	CAIGE A,NFSTTY	;SKIP IF STY
	JRST TYI1B1
	MOVSI D,100000
	TDNE D,STYSTS-NFSTTY(A)
	JRST TYI1B1	;HAVE ALREADY GIVEN INT
	SKIPE TICC(A)
	JRST TYI1B1
	IORB D,STYSTS-NFSTTY(A)
	MOVE TT,STYOMS-NFSTTY(A)	;CHANNELS OPEN FOR OUTPUT ON
	IORM TT,IFPIR(D)	;GIVE INT
TYI1B1:	MOVSI D,2000
	TDNE D,TTYSTS(A)
	JRST TYI1B	;GOBBLE NEXT CHR REGARDLESS OF ACTIVATION
	CONO PI,CLKON
	PCLT
	SKIPG TACC(A)
	PUSHJ P,UFLS
TYI1B:	CONO PI,TTYOFF
	SKIPE PICLR(U)
	JRST TYI1BB
TYI1BA:	SKIPE T,TINTC(A)	;IF PI IS BLOCKED, MAKE SURE DO NOT HANG DUE TO .ITYIC LVL CHARS NOT PROCESSED
	CAMGE T,TICC(A)
	JRST TYI1BB
	SOS TINTC(A)	;FLUSH INT CHAR
	IBP TINTP(A)
	JRST TYI1BA

TYI1BB:	CONO PI,TTYON
	MOVE T,TINTC(A)
	PCLT
	CAML T,TICC(A)
	PUSHJ P,UFLS
	SKIPL C
	XCTR XRW,[MOVES (C)]	;TAKE TRAP HERE IF GOING TO TAKE ONE
	MOVSI D,2000
	ANDCAM D,TTYSTS(A)
	MOVE B,TIOP(A)
	CAMN B,TIBEP(A)
	SUBI B,TIBL
	HRRM B,TIOP(A)
	ILDB D,B
	TRNN D,2000
	JRST TYI1
	PUSHJ P,TYIREM	;REMOVE CHAR FROM BUFFER
	JRST TYI

TYIREM:	TRNE D,4000
	SOS TACC(A)
	SOS TICC(A)
	IBP TIOP(A)
	POPJ P,

TYI1:	TRNE D,1000
	JRST TYI2	;MAIN PROGRAM ECHO
	TRNN D,400	;SKIP IF PI LEVEL ECHO
	JRST TYI3	;NO ECHO
	MOVEI T,400	;PI LEVEL ECHO BIT
	LDB D,[360600,,B]
	LSH T,(D)
	PCLT
	TDNE T,@B
	PUSHJ P,UFLS	;HANG UNTIL PI ECHO BIT FOR THIS CHAR IS TURNED OFF
	LDB D,B		;GET CHARACTER
	JRST TYI3

TYI2:	PUSH P,A	;M.P. ECHO (IF 4.9 OF A =1, USER GEN FROM MTYOEC)
	PUSH P,C
	PUSH P,D
	MOVE A,D
	TRZ D,777577	;COM ECHO BIT
	MOVEI C,4000(D)	;MAIN PROGRAM ECHO CHARACTER
	MOVEI D,4000(D)
	PUSHJ P,TTYASC	;CONVERT CHARACTER
	MOVE I,A
	MOVE J,B
	POP P,D
	POP P,C
	POP P,A
	JUMPL I,TYI9	;MAPPED AWAY
	MOVEI Q,2	;# CHRS ROOM REQD
	SKIPGE J
	MOVEI Q,1
	MOVE T,Q
;DROPS THRU	PCLT
TYI4:	CAMLE T,TORM(A)
	PUSHJ P,TYOW1
	CONO PI,TTYOFF
	MOVSI B,OCO
	MOVSI H,LFT
	SKIPGE TTYCOM(A)
	TDNE B,TTYCOM(A)
	JRST TYI8
	TDNN H,TTYCOM(A)
	JRST TYI10	;COM AND NOT LFT AND NOT OCO
TYI8:	MOVE T,Q	;ROOM TO INSERT CHRS IN OUTPUT BUFFER?
	CAMG T,TORM(A)
	JRST TYI5
	CONO PI,TTYON
	JRST TYI4	;NO TRY AGAIN
TYI5:	MOVE B,I
	PUSHJ P,TTYOSC	;SALT CHR
	SOJE Q,TYI6	;JUMP ON ONLY ONE CHR
	MOVE B,J
	PUSHJ P,TTYOSC
TYI6:	TRC I,200
	TRC J,200
	MOVSI T,LFT
	SKIPGE B,TTYCOM(A)
	TDNN T,TTYCOM(A)
	JRST TYI12	;JUMP ON DONT SEND CHRS TO "COM ECHO OUT"
;SEND CHRS TO COM ECHO OUT
TYI12:	CONO PI,TTYON
TYI9:
IFN NNVTTS,[
	SKIPGE NVTF(A)
	JRST TYI9A	;ACTIVATE NOVA LINK
]
	AOSN TTYOAC(A)
	XCT TTYST(A)
TYI3:	JUMPL A,CPOPJ	;USER GEN FROM MTYOEC
	ANDI A,177
	CAIGE A,NFSTTY
	JRST TYI3A
	MOVSI TT,100000
	ANDCAM TT,STYSTS-NFSTTY(A)
TYI3A:	PUSHJ P,TYIREM	;REMOVE CHAR FROM BUFFER
	ANDI D,177
	CAIN D,3
	TLO E,400000
	JRST UPUTB

IFN NNVTTS,[
TYI9A:	PUSHJ P,TYO5A
	JRST TYI3
]

TYI10:	CONO PI,TTYON
	MOVSI T,LFT+OCO
	PUSHJ P,TTYCMW	;WAIT UNTIL COM GOES AWAY OR LFT OR OCO SET
	CONO PI,TTYON#77	;SAME AS UTCON THEN TTYOFF
	JRST TYI8

UPUTB:	ANDI D,177
UPUTB2:	JUMPL C,UPUTB1
	XCTR XW,[MOVEM D,(C)]
	POPJ P,
UPUTB1:	TRNE C,777760
	JRST 4,.
	MOVEM D,(C)
	POPJ P,

;OUTPUT IOT

TYO:	XCTR XR,[MOVE B,(C)]
	ANDI B,177
BTYO:	PUSHJ P,TTYIOT	;WAIT FOR THE TTY IF IT IS A CONSOLE.  TTY NUMBER IN A
	TRZE A,200000
	JRST MTYOEC
	TRNE A,140000
	JRST TYOCC	;HACK CURSOR CNTRL CHR
	SKIPE I,TCTYP(A)
	LDB I,[DISMBT,,TTYSTS(A)]
	JUMPE I,TYO6A
	CAIN B,^P
	JRST TYOCC6
TYO6A:	MOVE I,A
	MOVE A,B
	PUSHJ P,GETGRP
	TRNE B,10	;SKIP ON ASCII MODE OUTPUT
	JRST TYO3
	SETZB C,D	;IF THESE ARE CHANGED THEN THE CAIE A,15 WON'T WORK
	PUSHJ P,TTYASC
	MOVSI Q,1000
	TDNE Q,TTYTYP(I)	;SKIP ON NOT 2741
	CAIE A,15
	JRST TYO6B
	MOVNI B,1
TYO6B:	SKIPGE LCHTYO(I)
	CAIE A,12
	JRST TYO6
	SETZM LCHTYO(I)
	POPJ P,

TYO6:	CAIN A,15
	SETOM LCHTYO(I)
	JRST TYO4

TYO3:	TRO A,400	;SET IMAGE MODE OUTPUT BIT
TYO3A:	SETOM B
	SETZM LCHTYO(I)
TYO4:	JUMPL A,CPOPJ	;MAPPED TO COMPLEX PLANE
	MOVEI Q,1
	SKIPL B
	MOVEI Q,2	;CHRS BUFFER ROOM REQD
	EXCH I,A
	PCLT
TYO1:	MOVE T,Q
	CAMLE T,TORM(A)
	PUSHJ P,TYOW1	;WAIT FOR ROOM
	PUSHJ P,TTYCMW	;WAIT UNTIL TTY IS OUT OF COM MODE
	CAMG Q,TORM(A)
	JRST TYO2
	CONO PI,UTCON
	JRST TYO1	;NO ROOM, LOOP BACK

TYO2:	EXCH I,B
	PUSHJ P,TTYOSC
	SKIPL B,I
	PUSHJ P,TTYOSC	;SALT SECOND CHR (IF ANY)
	CONO PI,UTCON
IFN NNVTTS,[
	SKIPGE NVTF(A)
	JRST TYO5A	;ACTIVATE NOVA LINK
]
TYO5B:	AOSN TTYOAC(A)
	XCT TTYST(A)
	POPJ P,

IFN NNVTTS,[
TYO5A:	PUSH P,A
	SKIPL A,NOVATT
	PUSHJ P,TYO5B
	JRST POPAJ
]

TYOW1:	MOVEM A,EPDL3(U)	;MAY TRAP OUT ON SYSTEM JOB
	JUMPN U,TYOW4
	JRST TYOW5	;HANG UP SYS JOB FOR MAX OF 15 SEC

	PUSHJ P,TYOW6
TYOW5:	PUSHJ P,UFLS
	CAMG T,TORM(A)
	POPJ P,	;OK ROOM EXISTS
	SUB P,[1,,1]	;TIMED OUT
	POPJ P,

	PUSHJ P,TYOW2
TYOW4:	PUSHJ P,UFLS
	POPJ P,

TYOW6:	MOVE A,EPDL3(U)	;IF SYS JOB, FLUSH IF NO CHR PROCESSED FOR 15 SEC
	MOVE Q,TIME
	SUB Q,TTLTM(A)
	CAILE Q,15.*30.
	JRST POPJ1	;TIME OUT (FOR PSEUDO TTYS AND TTYS WITH FRIED DONE FLAGS)
TYOW2:	MOVE A,EPDL3(U)
	CAMLE T,TORM(A)
	POPJ P,	;NO ROOM
	MOVE T,TORM(A)
	CAIL T,TOBS/2
	JRST POPJ1	;LOTS OF ROOM, BETTER RUN PRGM TO GET MORE STUFF
	JRST POPJ3	;NOT MUCH ROOM, GIVE LOW PRIORITY

TTYOSC:	MOVE E,TOIP(A)	;SALT IN OUTPUT BUFFER
	CAMN E,TOBEP(A)
	SUBI E,TOBL
	HRRM E,TOIP(A)
	SOSGE TORM(A)
	JRST 4,.
	IDPB B,TOIP(A)
	POPJ P,

TYOCC:	MOVE Q,A
	ANDI A,77
	MOVEI T,2
	PUSHJ P,TYOW1
	MOVEI E,0
	PUSHJ P,TYOCC7	;CLEAR EXPECTING STATUS
	TRZE Q,100000
	JRST TYOCC1	;ACCEPT H OR V POS
	CAIN B,"V
	JRST TYOCC2
	CAIN B,"H
	JRST TYOCC3
	MOVSI E,-NCCHRS
TYOCC9:	CAMN B,CCTBC(E)
	JRST TYOCC4	;FOUND FUNCTN
	AOBJN E,TYOCC9
	JRST  IOCR11

TYOCC4:	MOVEI I,2000(E)	;FCTN CHR
TYOCC5:	EXCH I,A
	JRST TYO3A

TYOCC6:	MOVEI E,1
	JRST TYOCC7

TYOCC2:	SKIPA E,[2]	;SET UP ANTICIPATING STATE
TYOCC3:	MOVEI E,3
TYOCC7:	MOVE I,UUAC(U)
	ADDI I,IOCHNM(U)
	DPB E,[400200,,(I)]
	POPJ P,

TYOCC1:	CAIGE B,10
	JRST TYOCC7
	MOVEI I,3000-10(B)
	TRNE Q,40000
	TRO I,400
	JRST TYOCC5

MTYOEC:	TRZE A,20000
	JRST MTYOSQ	;SUPER QUOTE MODE
	MOVE D,B	;MOVE CHR TO D
	TLO A,400000
	JRST TYI2

MTYOSQ:	MOVE I,A
	MOVEI A,6000(B)	;SET SUPER QUOTE BITS
	MOVNI B,1
	JRST TYO4


;DEVICE DEP STATUS FOR TTY
;2.4 HAS "TTY"
;2.3 DDT MODE ON INPUT
;2.9-2.5 CURRENT LINE NUMBER ON GE OUTPUT (STATYO)
;(STATYI);2.5 CHRS HAVE BEEN ITYI'ED BUT NOT .IOT'ED (STATYI)
	;2.8 TELETYPE NEXT TO 340 OR 340 SLAVE
	;2.9  TELETYPE IS LOCAL, NOT DIAL IN

STATYO:	ANDI A,77
	SKIPN B,TORM(A)
	TRO D,1_9.	;BUF CAP FULL
	CAIN B,TOBS
	TRO D,1_<9.+1>	;BUFFER CAP EMPTY
STATY1:	SKIPL TTYTBL(U)
	TRO D,1_<9.+3>	;HAS TTY
	IORI D,SNTTY
	SKIPE TCTYP(A)
	TRC D,SNTTY#SNTDS
	POPJ P,

STATYI:	ANDI A,77
	SKIPN B,TICC(A)
	TRO D,1_<9.+1>	;BUF CAP E
	CAIL B,TIBS-10.
	TRO D,1_9.	;BUF CAP NEARLY FULL
	LDB B,[400400,,TTYTYP(A)]	;GET LOCAL AND 340 MDS
	DPB B,[160400,,D]	;DEPOSIT IN STATUS WORD
	CONO PI,TTYOFF
	MOVE TT,TICC(A)
	CAMLE TT,TINTC(A)
	TRO D,20000	;MORE CHRS HAVE BEEN ITYI'ED THAN .IOT'ED
	CONO PI,TTYON
	JRST STATY1


;TTY CLOSE ROUTINES

;INPUT CLOSE

TYICLS:	JSP E,TYCLOS	;IGNORE FOR DISOWNED CONSOLE
	TRZ A,377700
	TRZN A,400000
	JRST TYICL4	;DEVICE
	SKIPGE TTYTBL(U)
	JRST TYICL2	;DOESNT HAVE TTY
TYICL4:	MOVSI T,ICO+LFT
	PUSHJ P,TTYCMW
	CONO PI,TTYON#77
	MOVE B,TIIP(A)
	MOVEM B,TIOP(A)
	SETZM ECHOP(A)
	SETZM ECHOC(A)
	MOVEI C,TEBS
	MOVEM C,ECHOBR(A)
	MOVE C,ECHOIP(A)
	MOVEM C,ECHOOP(A)
TYICL1:	MOVEM B,TINTP(A)
	CLEARM TICC(A)
	CLEARM TACC(A)
	CLEARM TINTC(A)
	SUBI R,IOCHNM(U)	;MUNG R INTO "AC FIELD"
	MOVE B,CHNBIT(R)	;GET CHANNEL BIT
	ANDCAM B,TYIMSK(A)	;INDICATE CHANNEL CLOSURE
	CONO PI,TTYON
	JRST TYICL2

TYOW:	ANDI A,77
	SKIPN USER
	POPJ P,
	MOVEI T,TOBS
	PCLT
	CAME T,TORM(A)
	PUSHJ P,UFLS	;WAIT FOR TYPE OUT TO COMPLETE
	POPJ P,

TYCLOS:	LDB I,[210100,,A]
	SKIPGE APRC(U)	;SKIP UNLESS DISOWNED
	JUMPN I,CPOPJ	;JUMP IF OPEN AS DISOWNED CONSOLE, IGNORE
	JRST (E)	;RETURN

	;TELETYPE INPUT IO PUSHDOWN ROUTINES

TYIIOP:	CONO PI,CLKOFF	;TO PREVENT TELETYPE (IF CONSOLE) FROM MOVING AROUND
	JUMPGE B,TYIOP1	;JUMP IF OPEN AS DEVICE
	SKIPGE TTYTBL(U)	;IF PROCEDURE DOESN'T HAVE CONSOLE,
	JRST CLKONJ	;THEN THAT'S ALL
TYIOP1:	LDB E,[222100,,B]	;GET TTY NUMBER IN E
	SUBI R,IOCHNM(U)	;GET "AC FIELD" (IO PUSHDOWN ROUTINES RESTORE R)
	MOVE A,CHNBIT(R)	;GET RELEVANT CHANNEL INTERRUPT BIT
	XCT TYIOPT(I)	;IORM OR ANDCAM A TO TYIMSK(E)
	JRST CLKONJ	;RETURN

TYIOPT:	ANDCAM A,TYIMSK(E)	;IOPUSH (PSEUDO-CLOSE)
	IORM A,TYIMSK(E)	;IOPOP (PSEUDO-OPEN)

;OUTPUT CLOSE

TYOCLS:	JSP E,TYCLOS	;IGNORE FOR DISOWNED CONSOLE
	ANDI A,77
	MOVEI B,200000
	TDNN B,TTYTYP(A)	;DONT WAIT FOR OUTPUT ON PSEUDO TTY
	PUSHJ P,TYOW	;WAIT FOR OUTPUT TO FINISH UNLESS SYS JOB
TYICL2:	ANDI A,77
	SOSLE TTNTO(A)
	POPJ P,		;MORE OPENS ON TTY
	SKIPE TTNTO(A)
	JRST 4,.
	HRLOI B,(SETZ)	
	IORB B,TTYSTS(A)	;^Z WILL HAVE NO EFFECT UNTIL SYS JOB SETOMS TTYSTS
	TLNE B,BCNSBT
	POPJ P,	;OPEN AS CONSOLE
	AOS TTNTO(A)	;IN CASE PCLSR OUT
TTYLO1:	SKIPGE TTYSTA(A)
	JRST TTYLO2	;HAVE ALREADY TYPE CONSOLE FREE MESS
	SKIPE USER
	JRST TTYLO5	;NOT BEING GUNNED
	TLNE B,BCNSBT
	JRST TTYLO4	;CONSOLE => SYSGUN WILL TYPE MSG
TTYLO5:	MOVSI T,10000
	PUSHJ P,CWAIT
	TDNE T,SUPCOR
	MOVE TT,UNAME(U)	;CALLED BY LOGOUT
	MOVE J,UTMPTR(U)
	MOVE J,NCTIM-USRRCE(J)
	ADD J,UTRNTM(U)
	SETZM TTNTO(A)
	MOVEM A,SYSPNT
	TLNE B,BCNSBT
	HRROS SYSPNT
	MOVEM TT,SYSPN3
	MOVEM J,SYSPN4
NDETA4:	PUSH P,T
	PUSHJ P,TTYLFC
	POP P,T
	CONO PI,TTYON#<1_<7-APRCHN>>
CSPST:	IORM T,SUPCOR
	JRST CLKONJ

TTYLO2:	SKIPE USER
	JRST 4,.
	SETOM TTYSTS(A)	;ONLY SETOM OF TTYSTS
TTYLO6:	SETZM TTNTO(A)
TTYLO4:	PUSHJ P,TTYLFC
	JRST TTYONJ

TTYLFC:	CONO PI,TTYOFF
	SKIPL TTYCOM(A)
	JRST TTYLO3
	MOVE I,A
	PUSH P,U
	PUSHJ P,TYCGTM
	POP P,U
	MOVE A,I
TTYLO3:	HRLOI B,0
	MOVEM B,TTYCOM(A)
	MOVEI B,TTYI
	MOVEM B,TTYIPC(A)
	POPJ P,

;TTY RESET ROUTINES

;TTY INPUT RESET

TYIRS:	PUSHJ P,TTYRST
	MOVSI T,LFT+ICO
	PUSHJ P,TTYCMW	;DOES ANDI A,
	CONO PI,TTYON#77
	MOVE B,TIIP(A)
	MOVEM B,TIOP(A)
	MOVEM B,TINTP(A)
	SETZM ECHOP(A)
	SETZM ECHOC(A)
	MOVEI C,TEBS
	MOVEM C,ECHOBR(A)
	MOVE C,ECHOIP(A)
	MOVEM C,ECHOOP(A)
	CLEARM TICC(A)
	CLEARM TACC(A)
	CLEARM TINTC(A)
	JRST TTYONJ

;OUTPUT RESET

TYORS:	PUSHJ P,TTYRST	;HANG UNTIL HAS TTY.  TTY NUMBER IN A (DOES ANDI A,)
	MOVSI T,LFT+OCO
	PUSHJ P,TTYCMW	;HANG UNTIL OUT OF COM MODE
	MOVEI B,TOBS
	MOVEM B,TORM(A)
	MOVE B,TOIP(A)
	MOVEM B,TOOP(A)
	JRST UTCONJ

;BLOCK MODE TYPE IN AND TYPE OUT

TTYBO:	JSP E,NBTOCH
	CAIN A,EOFCH
	POPJ P,
	MOVE B,A
	HLRZ A,(R)
	PUSH P,R
	PUSH P,D
	PUSH P,TT
	PUSH P,E
	PUSH P,C
	PUSHJ P,BTYO
	POP P,C
	POP P,E
	POP P,TT
	POP P,D
	POP P,R
	POPJ P,

TTYBI:	JSP E,INBTCH
	JRST TYI

AITYIC:	XCTR XR,[MOVE A,(J)]	;OPER 60
	PUSHJ P,TTYNGT
	POPJ P,
	JRST AITYI1

AITYI:	SKIPL A,TTYTBL(U)	;OPER 1
AITYI1:	SKIPG TINTC(A)
	POPJ P,
	MOVE B,TINTP(A)
	CAMN B,TIBEP(A)
	SUBI B,TIBL
	HRRM B,TINTP(A)
	ILDB B,TINTP(A)
	ANDI B,177
	SOS TINTC(A)
AOPVS:	AOS (P)
AOPERV:	XCTR XW,[MOVEM B,(J)]
	POPJ P,

ALISTEN:	MOVE A,TTYTBL(U)	;OPER 2
	JUMPL A,ALISZ
	PUSHJ P,TYOW
	MOVE B,TICC(A)
ALIS2:	MOVE A,PIRQC(U)
	TRNE A,BCNTRZI
	JRST UDELAY
	JRST AOPERV

ALISZ:	MOVEI B,0
	JRST ALIS2

NLISTE:	PUSHJ P,TTYNGT
	POPJ P,
	PUSHJ P,TYOW
	MOVE A,TICC(A)
	JRST SYSCPS

TTYNGT:	CAIL A,0
	CAIL A,20
	POPJ P,
	ADDI A,IOCHNM(U)
	MOVE B,(A)
	MOVE C,CLSTB(B)
	TLNN C,20000
	POPJ P,
	HLRZ A,B
	TRZ A,377700
	TRZE A,400000
	SKIPL A,TTYTBL(U)
	AOS (P)
	POPJ P,

EBLK

TTYBRK:	0

BBLK

	MOVEM A,TTYA
	MOVE A,[B,,TTYACS]
	BLT A,TTYACS+17-B+1-1	;SAVE ALL ACS BUT 0
IFN TK10P,[
	CONSZ NTY,200000
	JRST NTY1	;NEW TELETYPE KLUDGE
]
IFN MTYP,[
	CONSZ MTY,50
	JRST MTY1	;MORTON BOX
]
IFN DPKPP,[
	CONSZ DPK,60
	JRST DPKPE	;PARITY ERROR OR NXM
	CONSZ DPK,10
	JRST DPTI1	;CHAR AVAIL DPK
	CONSZ DPK,400
	JRST DPTO1	;OUTPUT BUFFER FIN DPK
]
	MOVEI I,0
	CONSZ TTY,50
	JRST GOTTY
;	MOVEI J,TTYCHN	;KNIGHT TTY KLUDGE GENERATES SPUR INTS
;	JSP E,SPUR	;SPURIOUS INT
	JRST TTYRT3
TTYRET:
TTYRT1:	MOVEI A,200000
	TDNE A,TTYTYP(I)
	JRST 4,.	;NOT SUPPOSED TO RETURN HERE FOR PSEUDO-TTY
TTYRT3:	MOVS A,[B,,TTYACS]
	BLT A,17
TYBKRT:	MOVE A,TTYA
	JRST 12,@TTYBRK

IFN TK10P,[
TTYRT2:	CONO NTY,200000+TTYCHN
	JRST TTYRT1
]

IFN DPKPP,[
DPKPE:	AOS NDPKPE
	CONO DPK,60+TTYCHN	;PARITY ERROR OR NXM
	JRST TTYRT3
]
IFN DPKPP,[
DPTO1:	CONI DPK,A
	LDB I,[220400,,A]
	ADDI I,NFDPT
	SKIPL @DPKC-NFDPT(I)
	SETOM @DPKC-NFDPT(I)
	JRST TYP

DPTI1:	DATAI DPK,A
	LDB I,[220400,,A]
	ADDI I,NFDPT
	JRST NTYI1
]
IFN TK10P,[
NTY1:	CONSZ NTY,400000
	JRST TTYRT3	;SCANNER NOT STOPPED
	CONI NTY,I	;READ IN TTY #
	LDB I,[100400,,I]
	CAIL I,NNTYS
	JRST 4,.
	ADDI I,NOTYS	;CALCULATE CONSOLE #
	CONO NTY,@TTYLT(I)	;SELECT APPROPRIATE TTY
	CONSZ NTY,20
	JRST TYP	;DONE FLAG ON TYPEOUT
	CONSO NTY,40
	JRST TTYRT2	;THIS TTY NOT REALLY UNHAPPY
	DATAI NTY,A
	MOVSI B,1000
	TDNN B,TTYTYP(I)
	JRST NTYI1
	LDB B,[060200,,A]
	DPB B,[050300,,A]	;FLUSH BIT 6
	JRST NTYI1
]
IFN MTYP,[
MTY1:	CONI MTY,I
	LDB I,[140500,,I]	;GET SUBDEVICE
	CAIL I,NMTYS
	JRST MTY2	;NOT A VALID #
	ADDI I,NFMTY
	CONO MTY,@TTYLT(I)	;SELECT SUBDEVICE
	CONSZ MTY,10	;OUTPUT DONE
	JRST TYP
	CONSO MTY,40	;INPUT DONE
	JRST TTYRT1	;THIS TTY NOT REALLY UNHAPPY
	DATAI MTY,A
	JRST NTYI1

MTY2:	CONSZ MTY,10
	JRST MTY3	;OUTPUT
	CONSZ MTY,40
	DATAI MTY,A	;INPUT
	JRST TTYRT1	;AND IGNORE
MTY3:	LSH I,12.
	CONO MTY,200+TTYCHN(I)	;CLEAR OUTPUT DONE FLAG
	JRST TTYRT1
]

GOTTY:	CONSZ TTY,10
	JRST TYP	;TTO DONE
	CONSO TTY,40
	JRST TTYRET	;NONE
	DATAI TTY,A	;TTI DONE, READ CHR

;DROPS THRU
;DROPS IN

;PROCESS INPUT INTERRUPT WITH CHARACTER IN A, TTY # IN I

NTYI1:
IFN NNVTTS,[
	CAME I,NOVATT	;SKIP IF THIS TTY IS NOVA
	JRST NTYI3
	TRZE A,200	;SKIP IF DATA  AND NOT TTY #
	JRST NTYI2	;SET TTY #
	SKIPGE I,NVIPTT	;CURRENTLY SELECTED  CONSOLE ON INPUT
	JRST TTYRET	;NONE SELECTED
NTYI3:]
	MOVE P,TTYPDP
NTYI5:	ANDI A,177	;FLUSH POSSIBLE EXTRANEOUS BITS
	MOVEM I,LOCTTY	;TTY CHAR ACTUALLY TYPED ON
	MOVSI U,4
	ANDCAB U,TTYSTS(I)	;CLEAR LAST CHR ^Z BIT
	MOVE Q,TTYCOM(I)
	HRRZ W,TCTYP(I)	;4.9 USED TO SIGNAL CHR ^Z 4.8 SIGNALS INTERRUPT GIVEN
			;4.7 SIGNALS INHIBIT AOS ECHOC 4.6 INHIBIT SETTING COM ECHO BIT
			;AT TYI11
	MOVE R,TTYTYP(I)
	TLNE R,1000
	JRST CVASC	;CONVERT BCD TO ASCII
	PUSHJ P,TTYSAM
CVASC1:	PUSHJ P,@TTYIPC(I)	;GO TO INPUT ROUTINE
	MOVE I,LOCTTY
	MOVE R,TTYTYP(I)
	TRNE R,200000
	POPJ P,	;RETURN FOR PSEUDO-TTY
	JRST TTYRET

IFN NNVTTS,[
NTYI2:	JUMPE A,TTYRET
	ADDI A,NOTYS+NNTYS-1
	CAIGE A,NOTYS+NNTYS+NNVTTS
	MOVEM A,NVIPTT	;SELECT CONSOLE
	JRST TTYRET
]

TTYI:
IFG APL,[
	CAIN I,APL
	JRST TTYIS5	;STORE CHR AND EXIT FOR AP LINE
]
	CAIE A,^_	;TEST FOR TTY LEVEL HACKS
	JRST TTYI2	;NOT ^_
	HRRE B,U
	AOJE B,CPOPJ	;NO USER.  ^_ HAS NO EFFECT ON AN IDLE TTY
	TLNN U,2	;NOT SPECIAL IF SUPER IMAGE INPUT MODE
	TLNN U,BCNSBT	;SKIP IF TTY OPEN AS A CONSOLE
	JRST TTYI2	;NO SPECIAL MEANING IF TTY OPEN AS A DEVICE
	MOVEI B,TYCI
	MOVEM B,TTYIPC(I)	;PC FOR NEXT INPUT CHARACTER
TTYI13:	SKIPA B,[200]	;COM ECHO CHR
TTYI18:	MOVEI B,0	;REG ECHO CHR
	TLNE R,1000
	CAME I,LOCTTY
	SKIPA C,ECHOBR(I)
	POPJ P,
	CAIGE C,2
	JRST DING1
	MOVEI C,400(B)	;DON'T AOS TICC BIT FOR FIRST CHARACTER
	MOVEI D,400(B)	;SAME FOR SECOND CHARACTER
	TLO W,100000		;DON'T AOS ECHOC
	JRST TTYI14	;EXIT TO ECHO CHARACTER

TTYI2:	CAIN A,^Z	;TEST FOR ^Z
	PUSHJ P,ZFLAG	;^Z TYPED
TTYI2A:	HRRE B,U
	AOJE B,CPOPJ	;IGNORE CHARACTER IF NO USER
TTYI11:	MOVE E,TICC(I)
	CAIL E,TIBS	;SKIP IF ANY ROOM LEFT IN INPUT BUFFER
	JRST DING1
	PUSHJ P,GETGRP	;GET 6 BIT BYTE FOR GROUP THIS CHARACTER IS IN
	PUSHJ P,TTYTOM	;CONV LOWER TO UPPER CASE IF APPRO
	TLNN W,40000
	TRO A,200	;SET COM ECHO BIT
	JUMPGE W,TTYI15	;JUMP IF CHARACTER IS NOT A ^Z
	MOVEI B,20
	JRST TTYI8

TTYI15:	TLZE U,400	;TEST FOR INT. ON NEXT CHAR BIT
	JRST TTYI16
	TRNN B,1	;TEST INTERRUPT BIT FOR THIS GROUP
	JRST TTYI8	;OFF.  DON'T INTERRUPT
TTYI17:	HRRE D,U	;RH OF D IS USER INDEX
	JUMPL D,[JRST 4,.]	;SHOULDN'T BE NO USER
	HRL D,MSKST(D)	;LH OF D IS USER'S INTERRUPT MASK
	AOS TINTC(I)	;INCREMENT INTERRUPT CHARACTER COUNT
	TLNN D,TTYIF	;SKIP IF INTERRUPTS ON TYPE IN ENABLED
	JRST TTYI5	;DISABLED
	MOVEI H,TTYIF
	IORM H,PIRQC(D)	;GENERATE TYPE IN INTERRUPT REQUEST
	TLO W,200000		;INDICATE INTERRUPT
TTYI5:	MOVE H,TYIMSK(I)	;GET TTY CHANNELS OPEN MASK
	AND H,MSKST2(D)	;MASK OFF CHANNELS NOT ENABLED
	JUMPE H,TTYI8	;JUMP IF NO OPEN CHANNELS HAVE INTERRUPTS ENABLED
	MOVN TT,H
	AND H,TT	;ISOLATE LEAST SIGNIFICANT BIT
	IORM H,IFPIR(D)	;GENERATE SECOND WORD INTERRUPT REQUEST
	TLO W,200000		;INDICATE INTERRUPT
TTYI8:	LSHC B,-2	;GET ACTIVATE BIT IN SIGN BIT OF C
	LSH B,-2	;GET ECHO BITS
	CAIL B,3
	MOVEI B,2
TTYI6:	DPB B,[100200,,A]
	PUSHJ P,TTYISC	;STORE CHARACTER (IN INPUT BUFFER)
	TLNE W,200000
	JRST TTYI7	;JUMP IF INTERRUPTS
	SETZM TINTC(I)	;NO CHARACTERS AVAILABLE AT INTERRUPT LEVEL
	MOVE E,TIIP(I)
	MOVEM E,TINTP(I)	;UPDATE INTERRUPT POINTER INTO INPUT BUFFER
TTYI7:	TLNE R,1000	;DATEL LINE 
	JRST 27TIU
	CAIE B,1	;PI LEVEL ECHO.  DO CONVERSION NOW
	POPJ P,		;MAIN PROGRAM OR NO ECHO
	MOVEI C,200	;COM ECHO BIT
	MOVEI D,600	;COM ECHO AND DON'T AOS TICC BITS
	TLZ W,100000		;AOS ECHOC
TTYI14:	PUSHJ P,TTYASC	;CONVERT FOR OUTPUT
	LDB E,[700,,A]
	CAIN E,177
	JRST TTYI12
	JUMPL A,TTYI12	;CHARACTER MAPPED INTO COMPLEX PLANE (FOR ECHO)
	TLNE R,1000
	CAIE E,15
	JRST .+2
	MOVNI B,1	;DONT ECHO LF ON DATEL
	SKIPL B		;SKIP IF NO NEXT CHARACTER
	TRO A,1000	;INDICATE NEXT CHARACTER PART OF THIS ONE
	PUSHJ P,TTYESC	;STORE CHARACTER IN ECHO BUFFER
	JUMPL B,TTYI10	;NO SECOND CHARACTER
	MOVE A,B	;SECOND CHARACTER
	PUSHJ P,TTYESC	;STORE SECOND CHARACTER IN ECHO BUFFER
TTYI10:	TLNE W,100000
	JRST TTYI9	;JUMP ON DONT AOS ECHOC
	AOS ECHOC(I)
	MOVE E,TIIP(I)
	SKIPN ECHOP(I)
	MOVEM E,ECHOP(I)	;POINTER TO INPUT CHAR THAT IS CONVERTED IN ECHO BUFFER
TTYI9:	HRRZ A,I	;TTY # START TTY AND POPJ
	TRNE R,640000
	JRST DPTYSF	;START DPK OR PSEUDO-TTY OR MORTON TTY

IFN NNVTTS,[
	TRNE R,100000	;SKIP IF NOT NOVA TTY
	MOVE B,NOVATT
]
	AOSE TTYOAC(A)
	POPJ P,	;RETURN IF TTY ALREADY ACTIVE ON OUTPUT
	CAIL A,NOTYS	;SKIP IF ON DEVICE TTY
	JRST NTYSF	;ON DEVICE NTY
	CONO TTY,10+TTYCHN	;CAUSE AN INTERRUPT ON OUTPUT DONE
	POPJ P,

TTYI16:	MOVEM U,TTYSTS(I)
	JRST TTYI17

NTYSF:
IFN TK10P,[
	CONO NTY,@TTYLT(A)	;INSURE CORRECT TTY NUMBER SELECTED
	CONO NTY,10+TTYCHN	;CAUSE AN INTERRUPT ON OUTPUT DONE
]
	POPJ P,

DPTYSF:	AOSN TTYOAC(A)
	XCT TTYST(A)
	POPJ P,

27TIU:	ANDI A,177
	CAIL A,40	;UPDATE CHAR POS FOR PADDING
	AOS TICHRC(I)
	CAIN A,15
	SETZM TICHRC(I)
	CAIN A,11
	HLRZM P,TICHRC(I)
TTYI12:	LDB A,TIIP(I)
	TRZ A,400	;MAIN PROGRAM CAN HAVE CHARACTER NOW
	DPB A,TIIP(I)
	POPJ P,

DING2:	SUB P,[1,,1]
DING1:	TLNE R,2000	;SKIP IF WANT TO DING ON EXCESS INPUT
	POPJ P,
	SETOM DINGF(I)
	JRST TTYI9

TTYISC:	CAIE B,1	;SKIP ON PI ECHO
	JRST TTYIS2
	MOVE E,ECHOBR(I)
	CAIGE E,2	;SKIP IF AT LEAST TWO CHARACTER POSITIONS LEFT
	JRST DING2
TTYIS2:	JUMPGE C,TTYIS3	;JUMP ON NOT ACTIVATION CHR
TTYIS4:	TRO A,4000
	AOS TACC(I)
	JRST TTYIS5

TTYIS3:	MOVE E,TICC(I)
	CAIGE E,MICBAA
	JRST TTYIS5
	SKIPG TACC(I)
	JRST TTYIS4	;BUFFER FULL+ NO ACTV CHRS, GEN ONE
TTYIS5:	MOVE E,TIIP(I)
	CAMN E,TIBEP(I)	;SKIP IF NOT OFF THE END OF THE CIRCULAR BUFFER
	SUBI E,TIBL	;RESET TIIP
	HRRM E,TIIP(I)	;STORE BACK IN RH
	IDPB A,TIIP(I)	;STORE CHARACTER IN INPUT BUFFER
	AOS TICC(I)
	POPJ P,

TTYESC:	MOVE E,ECHOIP(I)
	CAMN E,ECHOEP(I)	;SKIP IF NOT OFF THE END OF THE CIRCULAR BUFFER
	SUBI E,TEBL	;RESET ECHOIP
	HRRM E,ECHOIP(I)	;STORE BACK IN RH
	IDPB A,ECHOIP(I)	;STORE CHARACTER IN ECHO BUFFER
	SOSL E,ECHOBR(I)	;ROOM FOR ONE FEWER CHARACTERS
	POPJ P,
	JRST 4,.	;SHOULD HAVE HAD ROOM BUT DIDN'T

TTYSAM:			;STANDARDIZE ALT MODE (IF APPRO)
	TLNN U,20002	;SKIP IF ALT MODE NOT TO BE STANDARDIZED
	TRNN R,2000
	POPJ P,		;DON'T STANDARDIZE ALT MODE
	CAIE A,176	;ALT MODE CAN BE 176 OR
	CAIN A,175	;175
	MOVEI A,33	;CHANGE EITHER TO 33
	POPJ P,

CVASC:	JUMPN A,CVASC8
	SKIPL 27TIME(I)
	JRST CVASC9
CVASCD:	MOVE A,TIME
	MOVEM A,27TIME(I)
	MOVEM A,27FTIM(I)
	JRST CVATT
CVASC9:	MOVE A,TIME
	SKIPL 27FTIM(I)
	JRST CVASCC
	MOVE B,A
	SUB B,27TIME(I)
	CAIL B,30.	;ONE SECOND
	JRST CVASCD
	MOVEM A,27TIME(I)
	JRST TTYRET
CVASCC:	MOVEM A,27TIME(I)
	SUB A,27FTIM(I)
	CAIGE A,900.	;HALF MINUTE
	JRST TTYRET
	SETZM 27IGE(I)	;RESET THE WORLD
	SETZM 27CTLF(I)
	SETZM 27LICR(I)
	SETOM 27LIAT(I)
	SETZM 27PMS(I)
	SETZM 27STOU(I)
	SETOM 27FTIM(I)
	JRST TTYRET
CVASC8:	SKIPGE B,27TIME(I)
	JRST CVASCA
	SUB B,TIME
	CAML B,[-7]
	JRST TTYRET
	SETOM 27TIME(I)
CVASCA:	CAIN A,27ATT
	JRST CVATT
	SKIPL 27IGE(I)
	JRST CVASC2
	SETZM 27IGE(I)
	CAIN A,27EOA
	JRST TTYRET	;IGNORE EOA
CVASC2:	CAIN A,27LWR
	JRST CVASC3
	CAIN A,27UPR
	JRST CVASC4
	SKIPGE 27LIAT(I)
	SKIPGE 27CTLF(I)
	JRST CVOBS
CVOBS1:	SETOM 27LIAT(I)
	MOVE B,27CASE(I)
	ANDI A,77
	MOVE A,ASCTBL(A)
	TRNN B,400
	MOVSS A
	ANDI A,177
	CAIE A,177
	CAIGE A,101	;@@ MEANS @ NOT ^@
	JRST CVASC5
	SKIPGE 27CTLF(I)
	TRZ A,140
CVASC5:	CAIN A,"@
	JRST CVASC6
	CAIN A,33
	SKIPL 27CTLF(I)
	JRST CVASCB
	MOVEI A,177	;@$ IS RUBOUT
CVASCB:	SETZM 27CTLF(I)
CVASC7:	SETZM 27LICR(I)
	CAIE A,15
	JRST CVASC1
	MOVNI B,2
	MOVEM B,27LICR(I)
	JRST CVASC1
CVASC6:	SETCMB B,27CTLF(I)
	JUMPGE B,CVASC7
	SETZM 27LICR(I)
	JRST TTYRET

CVASC4:	SKIPA A,[400]
CVASC3:	MOVEI A,200
	MOVEM A,27CASE(I)
	JRST TTYRET

CVATT:	MOVEI B,200
	MOVEM B,27CASE(I)
	AOSN TTYOAC(I)
	PUSHJ P,27STO
	MOVEI B,1
	MOVEM B,27PMS(I)
	SKIPL 27LICR(I)
	JRST CVATT1
	SETZM 27LICR(I)
	JRST TTYRET
CVATT1:	AOSG 27LIAT(I)
	JRST TTYRET
	MOVEI A,^Z
	JRST CVASC7

CVOBS:	AOSN TTYOAC(I)
	PUSHJ P,27STO
	JRST CVOBS1

27STO:
IFN TK10P,[
	CONO NTY,@TTYLT(I)
	CONO NTY,10+TTYCHN
]
	POPJ P,

;CHARACTER IN A.  RETURNS CONVERTED CHARACTERS IN A AND B.
;C AND D ARE ADDED TO A AND B REPECTIVELY
;A<0 => CHARACTER NOT TO BE OUTPUT.  B<0 => CONVERTED INTO ONLY ONE CHARACTER
TTYASC:	ANDI A,177
	SETOM B
	CAIN A,33
	JRST TTYAS6
	CAIE A,15
	JRST TTYAS4
	MOVEI B,12(D)
TTYAS6:	ADD A,C
	POPJ P,
TTYAS4:	CAIGE A,^K
	CAIG A,^F
	CAIL A,40
	JRST TTYAS6	;^G - ^J OR > 40
TTYAS5:	MOVEI B,100(A)	;^A - ^F OR ^K - ^_
	ADD B,D
	TRZ B,200
	MOVEI A,"^(C)
	TRZ A,200
	POPJ P,

TTYTOM:	CAILE A,140	;SKIP IF .LT. LOWER CASE A
	CAIE C,1	;SKIP IF CHARACTER IS IN GROUP 1
	POPJ P,		;NOT LOWER CASE LETTER
	TLNN Q,CLTUF
	TRNE B,4	;SKIP IF NO CONVERSION
	SUBI A,40	;CONVERT TO UPPER CASE
	POPJ P,

TYCLWR:	CAIL A,141	;CONVERT LOWER CASE LTRS TO UPPER
	CAILE A,172
	POPJ P,
	SUBI A,40
	POPJ P,

;GETS BYTE IN B, GROUP NUMBER IN C, BYTE POINTER IN D
GETGRP:	MOVE B,A
	ANDI B,177
	IDIVI B,5
	LDB C,GRPBPT(C)	;GET GROUP BITS
	MOVE TT,C
	MOVEI D,TTYST1(I)
	CAIL TT,6
	JRST GETGR2
GETGR1:	LDB E,[301400,,SBTBL(TT)]	;LOAD LH OF BYTE PTR
	DPB E,[301400,,D]	;MAKE TTYST1 OR TTYST2 APPROPRIATE BYTE POINTER
	LDB B,D
	POPJ P,

GETGR2:	SUBI TT,6
	MOVEI D,TTYST2(I)
	JRST GETGR1

DEFINE	GGRPTB A,B,C,D,E
A_29.+B_22.+C_15.+D_8+E_1
TERMIN

GRPTBL:	0
	GGRPTB 0,0,6,13,7
	GGRPTB 7,0,0,11,0
	GGRPTB 0,0,0,0,6
	0
	GGRPTB 0,0,10,0,0
	GGRPTB 0,0,13,3,3
	GGRPTB 13,13,13,13,13
	GGRPTB 5,5,4,4,3
	GGRPTB 4,3,4,2,2
	GGRPTB 2,2,2,2,2
	GGRPTB 2,2,2,3,3
	GGRPTB 5,4,5,3,3
	REPEAT 5,GGRPTB 1,1,1,1,1
	GGRPTB 1,5,3,5,4
	GGRPTB 4,3,1,1,1
	REPEAT 4,GGRPTB 1,1,1,1,1
	GGRPTB 1,1,1,5,3
	GGRPTB 10,3,12,0,0

GRPBPT:	350700,,GRPTBL(B)
	260700,,GRPTBL(B)
	170700,,GRPTBL(B)
	100700,,GRPTBL(B)
	010700,,GRPTBL(B)

ZFLAG:	TLO W,(SETZ)
	MOVEI C,2000+^Z	;IGNORE ^Z AT THE MAIN PROGRAM LEVEL
	MOVSI U,4	;EVEN IF THIS BIT IN TTYSTS IS OFF, TTY MAY BE FREE
	IORB U,TTYSTS(I)	;GET TTYSTS
	MOVE B,U
	AOJN B,ZFLAG2	;JUMP IF TTY IN USE
	MOVE A,UTTYCT	;SET UP NEW USER
	SKIPL DEDTIM	;SKIP, STOPPING MORE USERS IF SYSTEM DEAD
	CAIL A,MXCZS
	JRST POP1J	;LOSE
	JUMPE I,ZFLAG7	;TTY 0 CAN ALWAYS LOG IN
	SKIPGE SYSDBG	;IF SYS IN DEBUG MODE & USERS NOT DESIRED
	JRST ZFLAG8
ZFLAG7:	AOS UTTYCT
	HRRZM I,@UTTYI
	AOS A,UTTYI
	CAIL A,UTTYS+MXCZS
	MOVEI A,UTTYS
	MOVEM A,UTTYI
	MOVSI U,1004	;TIE UP CONSOLE UNTIL USTART WINS
	JRST ZFLAG1

ZFLAG2:	HRRE B,U
	AOJE B,CPOPJ	;RETURN IF ^Z TYPED AND TTY NOT IDLE AND NO USER
	TLNE U,2
	JRST ZFLG3A	;SUPER IMAGE INPUT MODE
	TLNE U,BCNSBT	;SKIP IF IN USE AS DEVICE
	JRST ZFLAG5	;JUMP IF IN USE AS A CONSOLE
ZFLG3A:	MOVEI C,^Z	;DEVICE SO DON'T IGNORE ^Z AT THE MAIN PROGRAM LEVEL
	TLZ W,(SETZ)
ZFLAG3:	MOVSI U,4	;GET <LAST CH WAS ^Z> BIT
ZFLAG1:	ANDCAM U,TTYSTS(I)
ZFLAG4:	MOVE U,TTYSTS(I)	;RESTORE U
	MOVE A,C	;RESTORE A
	POPJ P,

ZFLAG6:	MOVE U,SUPPRO(U)	;GET POINTER TO SUPERIOR
ZFLAG5:	MOVEI A,BCNTRZI
	SKIPG SUPPRO(U)	;SKIP IF NOT TOP LEVEL
	JRST ZFLAG3	;JUMP IF TOP LEVEL, IGNORE ^Z
	TDNE A,PIRQC(U)	;SKIP IF NOT YET INTERRUPTED
	JRST ZFLAG6	;IF BIT PREV. SET, SHOULD RUN THIS GUY
	IORM A,PIRQC(U)	;SET ^Z INTERRUPT BIT
	MOVSI A,BUSRC
	MOVE U,SUPPRO(U)	;GET POINTER TO SUPERIOR
	TDNN A,USTP(U)	;SKIP IF SUPERIOR STOPPED
	JRST ZFLAG4	;NOT STOPPED, WILL FIND OUT ABOUT ^Z, WIN
	JRST ZFLAG5	;SUPERIOR STOPPED, TRY AGAIN ONE LEVEL UP

ZFLAG8:	MOVN B,SYSDBG	;GET TTY NUMBER OF CONSOLE ALLOWED TO LOG IN
	CAME I,B	;SKIP IF THIS ONE
	JRST POP1J	;NOT THIS ONE.  LOSE
	JRST ZFLAG7	;ALLOW THIS TTY TO LOG IN

TYCI:	SETOM COMT1(I)	;CHR AFTER ^_
	TLO W,100000	;DONT AOS ECHOC FOR PRGM
	CAIE A,^_
	CAIN A,^Z
	JRST TYCI3	;GIVE EITHER CHARACTER TO MAIN PROGRAM
	CAIL A,"0
	CAILE A,"9
	JRST TYCI7	;NOT A NUMBER
	MOVNI B,2	;DIGIT COUNT
	MOVEM B,COMT2(I)	
	MOVEI B,-"0(A)
	MOVEM B,COMT1(I)	;STORE FIRST DIGIT
	MOVEI B,TYCI4
	MOVEM B,TTYIPC(I)
	JRST TTYI13	;EXIT TO ECHO NUMBER

TYCI4:	PUSHJ P,TYCI22	;READ NUM AFTER FIRST DIGIT
	JRST TYCI6	;CHARACTER IS NON-NUMERIC
	PUSHJ P,TTYI13	;ECHO NUMBER
	AOSGE COMT2(I)	;SKIP IF THIS IS THE THIRD CHARACTER
	POPJ P,		;GET NEXT CHARACTER
	MOVE A,COMT1(I)
	ANDI A,177	;CHARACTER THAT HAS OCTAL VALUE TYPED
TYCI1:	TLZ W,100000	;AOS IT AFTER ALL
TYCI3:	MOVEI B,TTYI
	MOVEM B,TTYIPC(I)	;RESTORE INPUT PC TO NORMAL TYPE IN
	JRST TTYI11

TYCI22:	CAIL A,"0
	CAILE A,"9
	POPJ P,		;RETURN WITHOUT SKIPPING IF NON-NUMERIC
	MOVE B,COMT1(I)
	LSH B,3
	ADDI B,-"0(A)
	MOVEM B,COMT1(I)	;UPDATE VALUE SO FAR
	JRST POPJ1	;SKIP RETURN
TYCI17:	MOVEI B,TYCG
	SKIPL TTYCOM(I)
	MOVEI B,TTYI
	MOVEM B,TTYIPC(I)	;RESTORE INPUT PC TO NORMAL TYPE IN
	JRST TTYI13	;ECHO CHARACTER (AS COM ECHO CHR) AND RETURN

TYCI2:	MOVEI B,TYCG
	SKIPL TTYCOM(I)
	MOVEI B,TTYI
	MOVEM B,TTYIPC(I)
	JRST TTYI18	;ECHO AS NORMAL ECHO

TYCI6:	ANDI A,177	;ORIG CHR TYPED
	EXCH A,COMT1(I)	;A NOW HAS CHAR REPRESENTED BY DIGITS
	PUSHJ P,TYCI1	;SIMULATE ITS TYPE IN
	MOVE A,COMT1(I)	;GET LAST CHARACTER TYPED
	JRST TTYI	;PROCESS IT NORMALLY

TYCI7:	PUSHJ P,TYCLWR
	MOVSI C,-NTYIQT
TYCI7C:	CAMN A,TYIQT(C)
	JRST TYCI7B
	AOBJN C,TYCI7C
TYCI7F:	MOVEI A,"?
	JRST TYCI17

TYCI7B:	XCT TYIQTI(C)
TYCI7D:	TRNN W,-1
	JRST TYCI7E
	MOVE B,TTYTYP(I)
	TLNE B,1000
	JRST TYCI7F	;DATEL
TYCI7E:	MOVEM U,TTYSTS(I)
	MOVEM Q,TTYCOM(I)
	HRRZM W,TCTYP(I)
	MOVE B,CNSLHL(W)
	MOVEM B,TCMXH(I)
	MOVE B,CNSLVL(W)
	MOVEM B,TCMXV(I)
	SUB B,TCECL(I)
	MOVEM B,TCMXP(I)
	JRST TYCI17

TYCAM:	TLZ Q,14000
	CAIN A,"A
	JRST TYCI7D
	CAIE A,"R
	TLOA Q,4000	;"Q QUESTION
	TLO Q,10000	;REFUSE
	JRST TYCI7D

TYCI19:	PUSHJ P,TTYI13	;ECHO CHARACTER
	SKIPGE TTYCOM(I)
	JRST TYCI51	;TTY ALREADY IN COM MODE
	TDO Q,[400000+COMFFL,,-1]	;INDICATE NO USER YET
	TLZ Q,LFT+RFT+OCO+ICO
	MOVEM Q,TTYCOM(I)
TYCI51:	MOVEI B,TYCI20
	MOVEM B,TTYIPC(I)	;SET PC FOR NEXT CHARACTER TYPED
	POPJ P,

TYIQT:	"H
	"T
	"I
	"O
	"A
	"Q
	"R
	"U
	"D
	"L
	"M
	"P
	"C
	"N
NTYIQT==.-TYIQT

TYIQTI:	TLC U,100000	;HALF DUPLEX
	TLC U,4000	;TAB
	TLC Q,ICO	;INPUT COM OVERRIDE
	TLC Q,OCO	;OUTPUT COM OVERRIDE
	JRST TYCAM	;HACK MESSAGES
	JRST TYCAM
	JRST TYCAM
	TLC Q,CLTUF	;CONV LOWER CASE TO UPPER
	JRST TYCT1	;DATAPOINT CONSOLE
	JRST TYCT2	;OLD (TST) DATAPOINTS
	JRST TYCT3	;IMLAC
	HRRI W,0	;PRINTING CONSOLE
	JRST TYCI19	;ENTER COM MODE
	JRST TYCN

IFN .-TYIQTI-NTYIQT, PRINTX /BARF AT TYIQTI/

TYCT1:	SKIPA B,[1]
TYCT2:	MOVEI B,2
TYCT3A:	CAIN B,(W)
	JRST TYCI7D
	HLL B,W
	EXCH W,B
	SETZM TCMVPO(I)
	SETZM TCMHPO(I)
	SETZM TCEVPO(I)
	SETZM TCEHPO(I)
	JRST TYCI7D

TYCT3:	MOVEI B,3
	JRST TYCT3A

TYCI20:	PUSHJ P,TYCLWR
	CAIN A,^_	;GET CHR AFTER ^_C
	JRST TYCI25
	CAIL A,"0
	CAILE A,"9
	JRST TYCI26	;NON-NUMERIC FOLLOWING ^_C.  MIGHT BE SPACE OR CR
	MOVEI B,-"0(A)
	MOVEM B,COMT1(I)	;STORE FIRST DIGIT
	MOVEM A,COMT3(I)	;SAVE CHR
	MOVEI B,TYCI21
	MOVEM B,TTYIPC(I)	;PC FOR NEXT CHARACTER TYPED
	JRST TTYI13	;ECHO THE NUMBER AND RETURN

TYCI21:	CAIN A,40
	JRST TYCI52
	CAIL A,40
	CAIL A,140
	JRST TYCI25
	MOVE B,COMT3(I)
	LSH B,6
	IORI B,-40(A)
	MOVEM B,COMT3(I)
	PUSHJ P,TYCI22
	JRST TYCI23	;NON-NUMERIC. SWITCH TO UNAME
	JRST TTYI13	;ECHO NUMBER
TYCI23:	MOVE B,COMT3(I)
	JRST TYCI54

TYCI25:	MOVEI A,"?	;ATTMEPT TO ESTABLISH LINK FAILS
	PUSHJ P,TTYI18	;ECHO A ?
TYCI33:	MOVEI B,TYCG	;NORMAL COM MODE PC
	MOVEM B,TTYIPC(I)
	SKIPL B,TTYCOM(I)
	JRST 4,.	;TTY NOT IN COMMUNICATION MODE
	HRRE E,B
	AOJN E,CPOPJ	;NOT LAST USER IN RING
	MOVEI A,^_	;GENERATE ^_N ON CONSOLE
	PUSHJ P,TTYI18
	MOVEI A,"N
	PUSHJ P,TTYI18
TYCI50:	MOVSI B,400000+OCO+RFT+LFT+ICO
	ANDCAM B,TTYCOM(I)	;LEAVE COMMUNICATION MODE
	MOVEI B,TTYI
	MOVEM B,TTYIPC(I)	;RESTORE INPUT PC TO NORMAL TYPE IN
	POPJ P,		;AND RETURN

TYCI52:	PUSHJ P,TTYI13
	MOVE B,COMT1(I)	;GET STORED TTY NUMBER
	CAIGE B,NCT
	JRST TYCI53	;A VALID NUMBER.
	MOVE B,COMT3(I)	;NOT A VALID TTY #
	JRST TYCI29	;MAYBE ITS A UNAME

TYCI53:	CAIE B,SYSCON
	CAMN B,I
	JRST TYCI25	;DON'T SEND MESSAGE TO SELF OR TO SYS JOB CONSOLE
	SKIPGE TTYCOM(B)
	JRST TYCI37
	HRRE C,TTYSTS(B)
	AOJN C,TYCI32	;TTY HAS A USER
	MOVEI A,"F	;TTY IS FREE
	PUSHJ P,TTYI18	;TYPE AN F
	MOVEI A,40
	PUSHJ P,TTYI18	;FOLLOWED BY A SPACE
	JRST TYCI38

TYCI26:	CAIE A,15
	CAIN A,40
	JRST TTYI13	;^_C FOLLOWED BY A SPACE OR CR.  ECHO AND IGNORE
	CAIN A,177
	JRST TYCI25	;TYPE ? AND EXIT
	MOVEI B,-40(A)	;^_C FOLLOWED BY NON-NUMERIC.  CREATE SIXBIT UNAME
TYCI54:	MOVEM B,COMT1(I)	;STORE SIXBIT OF FIRST CHARACTER
	MOVEI B,TYCI27
	MOVEM B,TTYIPC(I)	;INPUT PC FOR TYPE IN OF REMAINDER OF UNAME
	JRST TTYI13	;EXIT TO ECHO THE FIRST CHARACTER

TYCI27:	PUSHJ P,TYCLWR
	CAIN A,^_
	JRST TYCI25
	CAIE A,15
	CAIN A,40
	JRST TYCI28	;SPACE DELIMITS UNAME
	CAIN A,177	;RUBOUT
	JRST TYCI25	;TYPE ? AND EXIT
	MOVE B,COMT1(I)
	LSH B,6
	IORI B,-40(A)
	MOVEM B,COMT1(I)	;ADD NEW CHARACTER ONTO THE END OF THE NAME
	JRST TTYI13	;EXIT TO ECHO THE CHARACTER

TYCI28:	PUSHJ P,TTYI13	;ECHO THE SPACE
	MOVE B,COMT1(I)
TYCI29:	TLNE B,770000	;LEFT ADJUST THE UNAME
	JRST TYCI30
	LSH B,6
	JRST TYCI29

TYCI30:	CAMN B,[SIXBIT /SYS/]
	JRST TYCI25	;DON'T COMMUNICATE WITH SYSTEM JOB CONSOLE
	MOVEI U,LUBLK	;START LOOKING AT USER NUMBER 2
TYCI31:	ADDI U,LUBLK
	CAML U,USRHI
	JRST TYCI25	;OUT OF USERS SO GIVE ? AND RETURN
	CAMN B,UNAME(U)	;SKIP IF NO UNAME MATCHES
	SKIPGE C,TTYTBL(U)	;SKIP IF PROCEDURE HAS THE TTY
	JRST TYCI31	;TRY NEXT PROCEDURE
	HRRZ B,C	;TTY NUMBER
TYCI32:	SKIPL A,TTYCOM(B)	;SKIP IF HE IS ALREADY COMMUNICATING
	JRST TYCI34	;NOT ALREADY COMMUNICATING
TYCI37:	MOVEI A,"B	;INDICATE BUSY
TYCI35:	PUSHJ P,TTYI18
	JRST TYCI33

TYCI34:	TLNN A,10000	;SKIP IF MESSAGE RECEIPT SWITCH IS REFUSE
	JRST TYCI44	;ACCEPT OR INTERROGATE
TYCI48:	MOVEI A,"N	;INDICATE MESSAGE NOT ACCEPTED
	JRST TYCI35

TYCI38:	MOVE B,COMT1(I)	;GET HERE IF COMMUNICATING WITH FREE CONSOLE
TYCI44:	MOVSI A,400000+COMFFL	;GET HERE IF COM WITH IN USE CONSOLE
	IORM A,TTYCOM(B)	;PUT HIM IN COMMUNICATE MODE
	MOVSI A,LFT+RFT+OCO+ICO
	ANDCAM A,TTYCOM(B)
	PUSH P,I	;SAVE MY TTY NUMBER
	MOVE I,B
	PUSHJ P,TYCSET
	MOVEI T,[ASCIZ /
MESSAGE FROM /]
	PUSHJ P,TYCI40	;PRINT ON HIS TTY
	MOVE C,(P)
	HRRE C,TTYSTS(C)	;MY USER INDEX
	JUMPL C,TYCI36
	MOVE C,UNAME(C)
TYCI55:	MOVE T,[440600,,COMT1(I)]
	MOVEM C,COMT1(I)
TYCI42:	ILDB A,T
	JUMPE A,TYCI41
	ADDI A,40	;CONVERT FROM SIXBIT TO ASCII
	PUSHJ P,TTYI18	;ECHO CHARACTER ON HIS TTY
	TLNE T,770000
	JRST TYCI42
TYCI41:	MOVEI T,[ASCIZ /
/]
	PUSHJ P,TYCI40
	MOVSI A,4000
	TDNN A,TTYCOM(I)	;SKIP IF HE MUST BE ASKED
	JRST TYCI43	;ALWAYS ACCEPT
	MOVEI T,[ASCIZ /OK?/]
	PUSHJ P,TYCI40
	MOVEI A,TCIR	;INTERROGATION RESPONSE
	MOVEM A,TTYIPC(I)
	POP P,C
	MOVEM C,COMT1(I)
	MOVEM I,COMT1(C)
	MOVEI A,TCIRW
	MOVEM A,TTYIPC(C)
	MOVE I,C
	PUSHJ P,TYCSET
	MOVEI T,[ASCIZ /W /]
;DROPS IN

TYCI40:	HRLI T,440700
TYCI39:	ILDB A,T
	JUMPE A,CPOPJ
	PUSHJ P,TTYI18	;ECHO CHARACTER ON TTY
	JRST TYCI39

TYCI36:	MOVSI C,(SIXBIT /T/)
	LDB T,[030300,,(P)]
	ADDI T,20
	DPB T,[300600,,C]
	LDB T,[000300,,(P)]
	ADDI T,20
	DPB T,[220600,,C]
	JRST TYCI55

TYCSET:	MOVE R,TTYTYP(I)
	HRRZ W,TCTYP(I)
	MOVE Q,TTYCOM(I)
	MOVE U,TTYSTS(I)
	POPJ P,

TYCI43:	POP P,C		;HIS TTY NUMBER IN I, MINE IN C
TYCI47:	MOVE A,TTYCOM(C)	;SET UP LINK
	MOVE B,TTYCOM(I)	;LINK TTYCOM WORDS
	HRRE E,A
	AOJN E,TYCI45
	HRRM C,A
TYCI45:	HRRE E,B
	AOJN E,TYCI46
	HRRM I,B
TYCI46:	HRRZ D,A
	HRRZ E,B
	HRRM E,A
	HRRM D,B
	MOVEM A,TTYCOM(C)
	MOVEM B,TTYCOM(I)
	EXCH I,C
	PUSHJ P,TYCSET
	MOVEI A,TYCG
	MOVEM A,TTYIPC(I)
	MOVEM A,TTYIPC(C)
	MOVEI T,[ASCIZ /G /]
	JRST TYCI40


TYCG:	CAIN A,^_	;REC CHRS IN COM MODE
	JRST TYCGTN
TYCG21:	TLNE Q,ICO	;SKIP IF INPUT COM OVERRIDE OFF
	JRST TTYI2	;PROCESS INPUT OVERRIDE
	PUSH P,I	;SAVE MY CONSOLE NUMBER
	PUSH P,A	;SAVE THE CHARACTER
	TLNE Q,RFT	;SKIP IF RFT OFF
	JRST TYCG5	;BYPASS LOCAL ECHO
	PUSHJ P,TTYI13	;ECHO CHAR ON MY TTY
	MOVE A,(P)	;RESTORE CHARACTER
TYCG5:	HRRE B,TTYCOM(I)	;FIRST TTY IN CHAIN
	JUMPL B,[JRST 4,.]	;I'M NOT COMMUNICATING WITH ANYONE
	CAME B,-1(P)	;SKIP IF I'M COMMUNICATING WITH MYSELF
TYCG3:	SKIPL C,TTYCOM(B)	;SKIP IF HE IS IN COMMUNICATE MODE (THIS POINT IS "COM IN")
	JRST 4,.	;LOSSAGE
	MOVE I,B	;GET HIS TTY NUMBER IN I
	MOVE Q,TTYCOM(I)
	HRRZ W,TCTYP(I)
	MOVE R,TTYTYP(I)
	TLNN C,LFT	;SKIP IF HIS LFT IS SET
	JRST TYCG1
	MOVSI U,4
	ANDCAB U,TTYSTS(I)
	TLO W,40000	;DONT SET COM ECHO BIT
	PUSHJ P,TTYI2	;PUT CHARACTER W/O COM ECHO BIT IN HIS INPUT BUFFER
	JRST TYCG2	;PROCESS NEXT TTY IN CHAIN

TYCG1:	PUSHJ P,TTYI18	;OUTPUT CHAR ON HIS CONSOLE
TYCG2:	MOVE A,(P)	;RESTORE CHARACTER
	HRRE B,TTYCOM(I)	;NEXT TTY IN CHAIN
	JUMPL B,[JRST 4,.]	;CHAIN ENDS STRANGELY
	CAME B,-1(P)	;SKIP IF DONE
	JRST TYCG3	;PROCESS NEXT TTY
	SUB P,[2,,2]
	POPJ P,

TCIR:	PUSH P,A	;GET RESPONSE CHR
	PUSHJ P,TTYI13	;ECHO CHARACTER
	MOVE C,COMT1(I)	;TTY NUMBER WAITING FOR MY RESPONSE
	MOVE B,TTYIPC(C)	;HIS INPUT PC
	CAIE B,TCIRW	;SKIP IF HE IS WAITING FOR ME
	CAIN B,TCIRW2
	JRST .+2
	JRST 4,.	;HE WENT AWAY?
	POP P,A
	CAIE A,"Y	;SKIP IF MY ANSWER IS YES
	JRST TCIR2	;RESPONSE IS NO
	MOVEI B,TYCG
	MOVEM B,TTYIPC(I)	;MY PC FOR COMMUNICATING
	JRST TYCI47	;LINK COM WORDS AND GO

TCIR2:	PUSH P,C
	PUSHJ P,TYCI33	;TAKE ME OUT OF COM MODE
TCIR3:	POP P,I		;HIS TTY NUMBER
	PUSHJ P,TYCSET
	MOVEI T,[ASCIZ /N /]
	PUSHJ P,TYCI40
	JRST TYCI33	;TAKE HIM OUT OF COM MODE (MAYBE)

TCIRW:	CAIE A,^_	;WAITING FOR GUY TO RESPOND
	POPJ P,
	MOVEI B,TCIRW2
	MOVEM B,TTYIPC(I)
	JRST TTYI13	;ECHO ^_ AND RETURN

TCIRW2:	PUSHJ P,TYCLWR
	CAIN A,"N
	JRST TCIRW3
	MOVEI A,"?
	MOVEI B,TCIRW
	MOVEM B,TTYIPC(I)
	JRST TTYI18	;ECHO ? AND GO BACK TO TCIRW

TCIRW3:	PUSHJ P,TTYI18	;ECHO THE N
	PUSHJ P,TYCI33
	MOVE I,COMT1(I)	;HIS TTY NUMBER
	PUSHJ P,TYCSET
	JRST TYCI33

;GOT ^_ IN COM MODE TEST FOR ^_N OR ^_C
TYCGTN:	MOVEI B,TYCI7
	MOVEM B,TTYIPC(I)
	JRST TTYI13

TYCN:	PUSHJ P,TYCI17	;ECHO THE N (^_N IN COM MODE)
	SKIPL TTYCOM(I)
	POPJ P,
TYCGTM:	HRRE B,TTYCOM(I)	;M.P. ENTRY
	JUMPL B,[JRST 4,.]	;WASN'T COMMUNICATING WITH ANYONE
	CAMN B,I
	JRST 4,.	;COMMUNICATING WITH SELF
TYCGT3:	HRRE C,TTYCOM(B)
	JUMPL C,[JRST 4,.]	;LIST NOT CIRCULAR
	CAMN C,I
	JRST TYCGT4	;B HAS TTY NUMBER OF GUY POINTING TO ME
	MOVE B,C
	JRST TYCGT3

TYCGT4:	HRRZ C,TTYCOM(I)
	HLLOS TTYCOM(I)
	CAME C,B	;SKIP IF ONLY TWO LEFT
	JRST TYCGT5
	MOVSI D,400000+LFT+OCO+ICO+RFT
	ANDCAM D,TTYCOM(I)
	MOVEI D,TTYI
	MOVEM D,TTYIPC(I)
	MOVE I,B
	PUSHJ P,TYCSET
	HLLOS TTYCOM(I)
	JRST TYCI33	;TAKE HIM OUT OF COM MODE

TYCGT5:	HRRM C,TTYCOM(B)	;TAKE ME OUT OF THE CIRCULAR LIST
	MOVSI D,400000+LFT+OCO+ICO+RFT
	ANDCAM D,TTYCOM(I)
	MOVEI D,TTYI
	MOVEM D,TTYIPC(I)
	POPJ P,


TYP:	MOVE P,TTYPDP
	MOVE J,TIME
	MOVEM J,TTLTM(I)	;UPDATE TIME LAST OUT CHR SENT
IFN NNVTTS,[
	SKIPGE NVTF(I)
	JRST 4,.	;SHOULD NOT RECIEVE INT DIR FROM NOVA LINE
	CAMN I,NOVATT
	JRST TYP0	;NOVA LINK
]
TYP0D:
	LDB J,[220300,,TTYTYP(I)]	;OUTPUT SPEED FOR DPK
IFN DPKPP,[
	MOVEI A,400000
	TDNN A,TTYTYP(I)
	JRST TYP0F
	MOVE A,DPSPT(J)
	MOVEM A,DBBCC
	MOVE A,DBBFP-NFDPT(I)
	MOVEM A,DBBBP
	MOVSM A,@DPKP-NFDPT(I)
	JRST TYP0B
]
TYP0F:
IFN MTYP,[
	MOVEI A,40000
	TDNN A,TTYTYP(I)
	JRST TYP0B
	MOVEI A,MTYNC
	MOVEM A,MTYOCC-NFMTY(I)
	SETZM MTYOW-NFMTY(I)
	MOVEI A,440700+I
	HRLM A,MTYOBP
]
TYP0B:	MOVE R,TTYSTS(I)
	MOVE Q,TTYCOM(I)
	HRRZ W,TCTYP(I)
	MOVE T,TTYTYP(I)
	TRNE T,200000
	SETOM STYICH-NFSTTY(I)	;PSEUDO-TTY
	PUSHJ P,@TTYOPC(I)	;GO TO OUTPUT ROUTINE
	TRNE T,200000
	POPJ P,	;CALLED FROM STTYI (PSEUDO-TTY)
IFN DPKPP,[
	TRNE T,400000
	JRST DPTO
]
IFN MTYP,[
	TRNE T,40000
	JRST MTYO
]
	JRST TTYRET

IFN DPKPP,[
DPTO:	SKIPGE TTYOAC(I)
	JRST DPTOE1
TYP0E:	SKIPLE DBBCC
	JRST TYP0B	;CONTINUE MESSAGE
DPTOE:	XCT TTYST(I)	;END MESSAGE
	JRST TTYRET

DPTOE1:	SKIPL @DPKC-NFDPT(I)
	JRST DPTOE	;REALLY FROB TO SEND
	XCT DPTSTP-NFDPT(I)	;STOP LINE
	JRST TTYRET
]

IFN MTYP,[
MTYO:	SKIPGE TTYOAC(I)
	JRST MTYO1
	SKIPLE MTYOCC-NFMTY(I)	;SKIP IF OUT OF ROOM
	JRST TYP0B	;CONTINUE MESSAGE
MTYO2:	DATAO MTY,MTYOW-NFMTY(I)	;SEND CHARS
	JRST TTYRET
MTYO1:	SKIPL MTYOBP	;SKIP IF NOTHING TO SEND
	JRST MTYO2	;SEND WHAT THERE IS
	XCT TTYDFF(I)	;CLEAR OUTPUT DONE
	JRST TTYRET
]

IFN NNVTTS,[
TYP0:	AOSE NVTSIP	;CHAR PENDING?
	JRST TYP0A	;NO
	DATAO NTY,NVTSSC	;SEND CHR AFTER SELECT
	JRST TTYRET

TYP5B:	SUB P,[1,,1]
	JRST TYP0C

TYP0A:	SKIPN A,NVOPTT
	MOVEI A,NOTYS+NNTYS+NNVTTS-1
	MOVEM A,NNVSEC	;SET UP END CHECK
	SKIPN I,NVOPTT
	MOVEI I,NOTYS+NNTYS	;INITIALIZE
	SETOM NNVSFL	;SET FIRST TIME THRU FLAG
	MOVE A,NVTCC
	CAIGE A,10	;SENT TOO MANY CHRS TO THIS CONSOLE W/O LOOKING AT OTHERS?
	JRST TYP0D	;NO, LOOK AT CONSOLE
	SETZM NVOPTT
	SETZM NVTCC	;YES LOOK AT OTHERS
TYP0C:	AOS I
	CAIL I,NOTYS+NNTYS+NNVTTS
	SUBI I,NNVTTS
	AOS NNVSFL
	JRST TYP0D
]
TYP27:	AOSL 27LICR(I)
	AOSGE 27IGE(I)
	JRST TYP27W
	AOSN 27STOU(I)
	JRST TYP5C
	AOSL B,27SE(I)
	JRST TYP27C
	MOVE A,[177,,27EOA]
	JRST TYPDA6
TYP27C:	JUMPN B,TYP27D
	MOVEI B,200
	MOVE A,[177,,27LWR]
	TDNN B,27SAVC(I)
	MOVE A,[177,,27UPR]
	TDNN B,27SAVC(I)
	MOVEI B,400
	MOVEM B,27CASE(I)
	JRST TYPDA6

TYP27D:	SKIPGE 27STOU(I)
	JRST TYP27B
	SKIPGE 27LIAT(I)
	SKIPGE 27CTLF(I)
	JRST TYP27B	;BLOCKED
	SKIPGE A,27SAVC(I)
	JRST (E)
	SKIPGE 27PMS(I)
	AOS 2741E	;27SAVC(I) SHOULD BE -1 WHEN IN PROC MODE
	SETOM 27SAVC(I)
	JRST TYPDA3

TYP27B:	SKIPGE 27PMS(I)
	JRST TYP5C
	SKIPL B,27FLG(I)
	JRST TYP27E
TYP27Y:	MOVNI A,2
	MOVEM A,27STRT(I)
	SETOM 27FCLK
	SETZM 27FLG(I)
	XCT TTYDFF(I)
	POPJ P,
TYP27E:	JUMPN B,[JRST 4,.]
	SETOM 27FLG(I)
	SKIPGE A,27TIME(I)
	JRST TYP27F
	SUB A,TIME
	CAML A,[-7]
	JRST TYP27Y
	SETOM 27TIME(I)
TYP27F:	MOVE A,[177,,27EOT]
	MOVNI B,2
	MOVEM B,27IGE(I)
	SETOM 27PMS(I)
	MOVEI B,200
	MOVEM B,27CASE(I)
	JRST TYPDA6

TYP27W:	MOVNI A,16
	MOVEM A,27STRT(I)
	SETOM 27FCLK
	XCT TTYDFF(I)
	POPJ P,

TYP27S:	SETZM 27FCLK
	MOVSI A,-NCT
	MOVSI TT,1000
TYP27T:	TDNN TT,TTYTYP(A)
TYP27U:	AOBJN A,TYP27T
	JUMPGE A,CPOPJ
	AOSN 27STRT(A)
	XCT TTYST(A)
	SKIPGE 27STRT(A)
	SETOM 27FCLK
	JRST TYP27U

TYP1:	TLNE T,1000
	JSP E,TYP27
	SKIPLE SPCCC(I)
	JRST TYP1B	;TYPE RUBOUT
	SKIPE B,TTYBYP(I)
	JSP E,TYPBP
	SKIPGE SPCCC(I)
	JRST TYP1A
	MOVEI A,7
	AOSN DINGF(I)
	JRST TYPD1
	JUMPGE Q,TYP1E	;JUMP ON NOT COM
	TLNN Q,OCO+LFT
	JRST TYP4	;NOT OCO OR LFT SO M.P. OUT BLOCKED
TYP1E:	MOVE A,TORM(I)
	TLNN Q,COMFFL	;SKIP ON JUST LEAVING COM MODE SO GIVE ECHO PRIORITY
	CAIL A,TOBS
	JRST TYP4	;NO OUTPUT FROM PROG, ANY ECHO?
	MOVE A,TOOP(I)
	CAMN A,TOBEP(I)
	SUBI A,TOBL
	HRRM A,TOOP(I)
	ILDB B,A
	LDB U,[130100,,B]	;SET UP FOR ECHO OR MP
	JUMPE U,TYPE1E1	;MP
	TRNE B,2000
	JRST TYPSQ1	;SUPER QUOTE CHR
TYP1E1:	PUSHJ P,TYPCPC	;CHECK CURSOR POS
	MOVE A,TCHP(I)
	SKIPE W	;SKIP IF NOT DISPLAY TERMINAL
	MOVEM A,TICHRC(I)
	ILDB A,TOOP(I)
	AOS TORM(I)
TYP1C:	TRNN A,2000	;DISPLAY CNTRL FCTN
	TRZE A,400
	JRST TYPI	;OUTPUT CHR UNALTERED
	TRZN A,4000
	JRST TYP1D	;NOT ECHO CHR
	PUSHJ P,TYPTHT	;ECHO CHR
	JRST TYP1D
	POPJ P,

TYPSQ1:	ILDB A,TOOP(I)	;SEND SUPER QUOTE CHR
	AOS TORM(I)
	ANDI A,177
	JRST TOUT

TYP1D:	CAIN A,33
	MOVEI A,"$
	TLNE R,4000
	JRST TYPI	;HARDWARE TABS
	CAIE A,11
	JRST TYPI
	MOVEM U,TTYBSL(I)
	MOVE A,TICHRC(I)
	IDIVI A,TABSPC
	SUBI B,TABSPC
	MOVEM B,SPCCC(I)
	POPJ P,

;IF SPCCC < 0 THEN OUTPUT RUBOUTS WHEN DONE WITH TTYBYP
;IN THAT CASE WILL FIRST TYPE OUT FOUR 7 BIT BYTES
;IF SPCCC >= 0 THEN STOP ON FIRST NULL CHAR
TYPBP:	ILDB A,TTYBYP(I)
	SKIPGE SPCCC(I)
	JRST TYPBP1
	JUMPN A,TYPD1	;CHECK TO SEE IF POINTER RUN OUT
TYPBP2:	CLEARM TTYBYP(I)
	JRST (E)

TYPBP1:	MOVE B,TTYBYP(I)
	TLNE B,760000
	JRST TYPD1
	MOVNS SPCCC(I)
	SETZM TTYBYP(I)
TYP1B:	SOS SPCCC(I)
	MOVEI A,177
	JRST TYPD1

TYP1A:	AOS SPCCC(I)
	MOVEI A,40
	MOVE U,TTYBSL(I)

;DROPS THRU;DROPS IN
TYPI:	JUMPN W,TYPD		;DISPLAY TERMINAL
TYPD1:	ANDI A,177
TYPI3:
	TLNE T,1000
	JRST TYPDA	;2741
	PUSHJ P,TOUT
TYPDA5:	ANDI A,177	;REENTER FOR 2741
	TRNE T,210000
	JRST TYP3X	;DON'T PAD BIT OR PSEUDO-TTY
	JUMPN W,TYP3X	;NO PADDING TO DIS TERMINAL
TYPI3B:	CAILE A,173
	POPJ P,
	CAIL A,40
	AOS TICHRC(I)
	CAIE A,15
	JRST TYP3
	MOVE B,TICHRC(I)
	MOVE C,TTYTYP(I)
	TLNE C,4000
	JRST MEMPAD
	TLNE C,1000
	JRST 27PAD
	TLNN C,60000
	JUMPL C,TYPI1B	;DON'T INSERT IDLES ON HARD WIRED 35'S
	CAIL B,65.
	JRST TYPI2
	CAIGE B,33.
	TDZA B,B	;FROM LESS THAN 33 CHRS ACROSS CARR
	MOVEI B,1	;FROM > 33
TYPI2A:	TLNE C,60000
	AOS B	;15 OR 30 CPS LINE
	TLNE C,20000
	ADDI B,2(B)	;30 CPS
TYPI2B:	MOVEM B,SPCCC(I)
TYPI1B:	CLEARM TICHRC(I)
	POPJ P,

TYPI2:	MOVEI B,2	;FROM >65 CHRS ACROSS CARRIAGE
	JRST TYPI2A

MEMPAD:	JUMPE B,MEMPD1	;NO CHRS
	MOVNS B
	ADDI B,43.
	CAIGE B,2
MEMPD1:	MOVEI B,2
	JRST TYPI2B

TYP3:	CAIN A,11
	HLRZM P,TICHRC(I)	;HARDWARE TAB TYPED, CAUSE MAXIMAL PADDING
	MOVSI C,1000
	CAIN A,12
	TDNN C,TTYTYP(I)
	POPJ P,
	MOVEI C,1
	MOVEM C,SPCCC(I)
	POPJ P,

IFN DPKPP,[
TYPIDP:	IDPB A,DBBBP
	SOSGE DBBCC
	JRST 4,.
	AOS @DPKC-NFDPT(I)
	POPJ P,
]
TYP3X:	CAIN A,177
	POPJ P,
	CAIL A,40
	AOS TICHRC(I)
	CAIN A,15
	SETZM TICHRC(I)
	POPJ P,

IFN MTYP,[
MTYIDP:	JUMPE A,MTYID2	;IS CHAR NULL?
	IDPB A,MTYOBP
	SOSGE MTYOCC-NFMTY(I)
	JRST 4,.
MTYID3:	POPJ P,

MTYID2:	DATAO MTY,MTYOW-NFMTY(I)	;SEND CURRENT STUFF OR NULL IF NONE
	SKIPGE MTYOBP
	POPJ P,
	SETZM MTYOW-NFMTY(I)	;RESET EVERYTHING
	MOVEI A,MTYNC-1	;FIRST CHAR IS NULL
	MOVEM A,MTYOCC-NFMTY(I)
	MOVEI A,350700+I
	HRLM A,MTYOBP
	POPJ P,
]

27PAD:	IDIVI B,10.
	CAILE B,14.
	MOVEI B,14.
	AOJA B,TYPI2B

TOUT:IFN DPKPP,[
	TRNE T,400000	;SKIP IF NOT DPK
	JRST TYPIDP
]
IFN MTYP,[
	TRNE T,40000	;SKIP IF NOT MORTON TTY
	JRST MTYIDP
]
TYPI3A:	IMUL A,[2010040201]
	AND A,[21042104377]
	IDIVI A,17_7
	MOVE A,B
TYPDA1:	XCT TTYDO(I)	;DATAO XXX,A (MOVEM FOR PSEUDO TTYS)
	POPJ P,
TYPDA:	HRLZ B,A
	PUSH P,B
	LDB B,[0200,,A]
	LSH A,-2
	MOVEI C,BCDTBL(A)
	HLL C,9BPTR(B)
	LDB A,C
	TDNN A,27CASE(I)
	JRST TYPDCC	;CASE IS INCORRECT
	POP P,B
	HLL A,B
	JRST TYPDA2

TYPDCC:	POP P,27SAVC(I)
	HRRM A,27SAVC(I)
	MOVE A,[177,,27LWR]
	MOVE B,27CASE(I)
	TRNN B,400	;SKIP IF UPPER CASE
	MOVE A,[177,,27UPR]
	TRC B,600
	MOVEM B,27CASE(I)
TYPDA2:	SKIPL 27PMS(I)	;SKIP IF IN PROC MODE
	JRST TYPDA3
	SKIPGE TTYOAC(I)
	JRST 4,.
	XCT TTYDFF(I)	;CLEAR TTO FLAG
	XCT 27BRK(I)	;SEND BREAK
	MOVNI C,30
	MOVEM C,27STRT(I)
	SETOM 27FCLK
TYPDA4:	SETZM 27PMS(I)
	MOVNI C,2
	MOVEM C,27SE(I)	;EOA FLAG
	SKIPGE 27SAVC(I)
	MOVEM A,27SAVC(I)	;FIRST CHAR NOW IN 27SAVC(I)
	POPJ P,

TYPDA3:	SKIPE 27PMS(I)
	JRST TYPDA4	;OUT OF PROC MODE DUE TO ATT
	HRROI B,777177
	AND A,B
TYPDA6:	PUSHJ P,TYPDA1	;SEND CHR
	HLRZS A	;GET BACK ASCII CHR
	JRST TYPDA5

TYP4:	MOVE A,ECHOBR(I)
	CAIE A,TEBS	;SKIP IF ECHO BUFFER EMPTY
	JRST TYP4A	;ECHO BUFFER NOT EMPTY
	TLZE Q,COMFFL
	JRST TYP4B	;LEAVING COM MODE, CHECK M.P. BUFFER
TYP4B2:	TLNE T,1000
	JRST TYP27Z
	TRNE T,640000	;SKIP IF NOT DPK, NOT PSEUDO-TTY, AND NOT MORTON TTY
	JRST TYP5D
IFN NNVTTS,[
	TRNE T,100000
	JRST TYP5	;NOVA TTY
]
TYP5C:	XCT TTYDFF(I)	;STOP OUTPUT
TYP5D:	SETOM TTYOAC(I)
	POPJ P,

TYP27Z:	SKIPGE 27PMS(I)
	JRST TYP5C
	MOVNI A,2
	MOVEM A,27STOU(I)
	JRST TYP27Y

TYP4B:	JUMPGE Q,TYP4B1
	TLNN Q,OCO+LFT
	JRST TYP4B2	;M.P. STILL BLOCKED
TYP4B1:	MOVEM Q,TTYCOM(I)
	JRST TYP1E

IFN NNVTTS,[
TYP5:	CAMN I,NNVSEC	;REACHED END
	AOSG NNVSFL	;AND NOT FIRST TIME
	JRST TYP5B	;LOOK AT OTHER NOVA CONSOLES
	MOVE I,NOVATT
	JRST TYP5C
]

TYP4A:	CAIL A,TEBS
	JRST 4,.	;MORE ROOM IN ECHO BUFFER THAN POSSIBLE
	MOVEI U,1	;SIGNAL ECHO OUT
	PUSHJ P,TYPCPC	;CURSOR IN RIGHT POS?
	MOVE A,ECHOOP(I)
	CAMN A,ECHOEP(I)
	SUBI A,TEBL
	HRRM A,ECHOOP(I)
	ILDB A,ECHOOP(I)	;GET CHARACTER FROM ECHO BUFFER
	AOS ECHOBR(I)	;ROOM FOR ONE MORE CHARACTER
	PUSH P,A	;SAVE CHARACTER
	PUSHJ P,TYPTHT
	PUSHJ P,TYPI	;TYPE IT OUT
	POP P,A		;UNSAVE CHARACTER
	TRNE A,2000
	POPJ P,	;DISPLAY CNTRL FCTN
	TRNN A,1000	;SKIP IF NEXT CHARACTER GOES WITH THIS ONE
	JRST TYP8	;THIS CHARACTER ALONE
	MOVEI B,TYPA
	MOVEM B,TTYOPC(I)	;SET NEW OUTPUT PC

	MOVE C,ECHOOP(I)
	CAMN C,ECHOEP(I)
	SUBI C,TEBL
	HRRM C,ECHOOP(I)
	ILDB B,ECHOOP(I)	;GET SECOND CHARACTER
	AOS ECHOBR(I)	;ROOM FOR ANOTHER CHARACTER
	MOVEM B,TTYSC(I)	;SAVE FOR TYPING OUT NEXT
TYP8:	TRNE A,400	;SKIP IF HAVE TO TELL MAIN PROGRAM THAT CHAR IS AVAILABLE
	POPJ P,
	SKIPN ECHOP(I)
	JRST 4,.
	LDB B,ECHOP(I)
	TRZ B,400
	DPB B,ECHOP(I)	;MAIN PROGRAM CAN HAVE CHARACTER NOW
	SOSG C,ECHOC(I)	;SKIP IF MORE CHARS IN INPUT BUFFER TO BE PI ECHOED
	SETZM ECHOP(I)	;NO MORE
	JUMPL C,[JRST 4,.]
	JUMPE C,CPOPJ
TYP6:	MOVE C,ECHOP(I)
	CAMN C,TIBEP(I)
	SUBI C,TIBL
	HRRM C,ECHOP(I)
	ILDB C,ECHOP(I)
	TRNN C,400
	JRST TYP6
	POPJ P,

TYPA:	TLNE T,1000
	JSP E,TYP27
	SKIPLE SPCCC(I)
	JRST TYP1B
	SKIPE B,TTYBYP(I)
	JSP E,TYPBP
	MOVEI U,1	;SIGNAL ECHO OUT
	PUSHJ P,TYPCPC
	MOVEI B,TYP1
	MOVEM B,TTYOPC(I)	;RESTORE OUTPUT PC
	MOVE A,TTYSC(I)	;GET HERE ON OUTPUT DONE FROM FIRST CHARACTER
	PUSHJ P,TYPTHT	;MAY SKIP IF WANT TO ECHO TAB (3 SPACES)
	PUSHJ P,TYPI	;TYPE SECOND CHARACTER (DONT CHANGE TO JRST, ETC)
	POPJ P,

TYPCPC:	JUMPE W,CPOPJ
	SKIPN TCECL(I)
	MOVEI U,0	;NO ECHO LINES
	JUMPE U,TYPCP5
	MOVE B,TCEVPO(I)
	CAML B,TCMXP(I)
	JRST TYPCP5
	MOVE B,TCMXP(I)
	MOVEM B,TCEVPO(I)
	SETZM TCEHPO(I)
TYPCP5:	MOVE B,TCVP(I)	;CURRENT HARDWARE VERTICAL POSITION
	SUB B,@TYPDT1(U)	;SUBTRACT VERTICAL POSITION OF WHERE WE WANT TO BE
	MOVM C,B	;C IS HOW FAR WE HAVE TO GO UP OR DOWN
	MOVE A,TCHP(I)		;COMPUTE NET CHRS TO POSITION
	SUB A,@TYPDT2(U)
	MOVMS A		;A IS HOW FAR WE HAVE TO GO HORIZONTALLY
	CAMG A,@TYPDT2(U)	;SKIP IF SHORTER TO CR FIRST
	JRST TYPCPA	;SHORTER TO GO DIRECTLY
	MOVE A,@TYPDT2(U)	;HOW FAR WE HAVE TO GO AFTER CR
	ADDI A,1	;ADD 1 FOR CR
TYPCPA:	ADD A,C	;A NOW HAS TOTAL NUMBER OF CHARS TO SEND TO GET THERE
	JUMPE A,CPOPJ	;WE'RE THERE
	CAIN W,3
	JRST TYPABI	;ALWAYS ABS ON IMLAC
	MOVE C,@TYPDT1(U)
	ADD C,@TYPDT2(U)	;C HAS NUMBER OF CHARS IT WOULD TAKE IF WE HOMED UP FIRST
	MOVE E,TCMXV(I)
	SUBI E,1
	SUB E,@TYPDT1(U)	;E HAS NUMBER IF HOME DOWN FIRST
	ADD E,@TYPDT2(U)
	CAMGE C,A
	JRST TYPHU	;HOME UP SHORTER
	CAIN W,2
	JRST TYPCPG	;HOME DOWN DOESN'T WORK ON OLD DATAPOINTS
	CAMGE E,A
	JRST TYPHD	;HOME DOWN SHORTER
TYPCPG:	JUMPN B,TYPCP1	;V POS DIFFERS
TYPCP9:	MOVE B,TCHP(I)
	SUB B,@TYPDT2(U)
	JUMPE B,CPOPJ
	JSP E,TYDPPD
	SKIPLE SPCCC(I)
	JRST TYPPRT	;INSERT IDLES BEFORE CURSOR CNTRL
	JUMPGE B,TYPCP6	;TOO FAR OUT
	MOVE C,[AOS TCHP(I)]
	LDB A,[350700,,CCR-1(W)]
	JRST TYPCP7

TYPCP6:	CAMG B,@TYPDT2(U)
	JRST TYPCP8
	MOVEI A,15	;BETTER TO CR FIRST
	CLEARM TCHP(I)
	PUSHJ P,TYPI3
	TRNE T,200000
	POPJ P,	;PSEUDO-TTY
IFN DPKPP,[
	TRNN T,400000	;SKIP IF DPK
	JRST TYPCPE
	SKIPLE DBBCC	;SKIP IF QUOTA FULL
	JRST TYPCP9
	JRST DPTOE	;START MESSAGE
]
TYPCPE:
IFN MTYP,[
	TRNN T,40000
	JRST TTYRET
	SKIPLE MTYOCC-NFMTY(I)
	JRST TYPCP9
	JRST MTYO2
]
	JRST TTYRET

TYPCP8:	MOVE C,[SOS TCHP(I)]	
	LDB A,[350700,,CCL-1(W)]
	JRST TYPCP7

TYPCP1:	JSP E,TYDPPD
	SKIPLE SPCCC(I)
	JRST TYPPRT
	JUMPGE B,TYPCP2
	LDB A,[350700,,CCD-1(W)]
	MOVE C,[AOS TCVP(I)]
TYPCP7:
IFN DPKPP,[
	TRNN T,400000	;SKIP IF DPK
	JRST TYPCP3
	MOVMS B
TYPCP4:	XCT C
	IDPB A,DBBBP
	AOS @DPKC-NFDPT(I)
	SOSLE DBBCC
	SOJG B,TYPCP4
	JRST DPTOE	;START MESSAGE
]
TYPCP3:
IFN MTYP,[
	TRNN T,40000
	JRST TYPCPB
	MOVMS B
TYPCPD:	XCT C
	JUMPE A,[JRST 4,.]	;NULL CHAR WON'T WORK
	IDPB A,MTYOBP
	SOSLE MTYOCC-NFMTY(I)
	SOJG B,TYPCPD
	JRST MTYO2	;SEND MESSAGE
]

TYPCPB:	XCT C
	PUSHJ P,TYPI3A
	TRNN T,200000
	JRST TTYRET
	SUB P,[1,,1]	;PSEUDO TTY
	POPJ P,	;RETURN TO PUSHJ P,@TTYOPC

TYPCP2:	LDB A,[350700,,CCU-1(W)]
	MOVE C,[SOS TCVP(I)]
	JRST TYPCP7

TYPDT1:	TCMVPO(I)
	TCEVPO(I)

TYPDT2:	TCMHPO(I)
	TCEHPO(I)

TYPDT3:	TCMXP(I)
	TCMXV(I)

TYPDT4:	[0]	;START OF M.P. AREA
	TCMXP(I)	;START OF ECHO AREA

TYPDT5:	331100,,TCSCP(I)
	111100,,TCSCP(I)

TYPDT6:	221100,,TCSCP(I)
	1100,,TCSCP(I)

TYPDT7:	@TYPDT4(U)
	[0]

TYPDT8:	TCMXV(I)
	TCMXH(I)

TYPDT9:	@TYPDT1(U)
	@TYPDT2(U)

TYPABI:	MOVE A,[16_28.+200_20.+200_12.]	;FAKE OUT ZERO CHECK IN CASE OF NULL
	MOVE B,@TYPDT1(U)
	MOVEM B,TCVP(I)
	ADDI B,1
	DPB B,[140700,,A]
	MOVE B,@TYPDT2(U)
	MOVEM B,TCHP(I)
	ADDI B,1
	DPB B,[240700,,A]
	MOVEM A,TTYBT(I)
	MOVE B,[441000,,TTYBT(I)]
	MOVEM B,TTYBYP(I)
	SUB P,[2,,2]
	JRST TYP0B

TYPHU:	CAIN W,2
	JRST TYPHU1
	CAMLE C,E
	JRST TYPHD	;HOME DOWN IS BETTER
TYPHU1:	CLEARM TCVP(I)
	CLEARM TCHP(I)
	LDB A,[350700,,CCHU-1(W)]
TYPHU3:	PUSHJ P,TYPI3
	TRNE T,200000
	JRST POP1J	;PSEUDO-TTY
IFN DPKPP,[
	TRNN T,400000	;SKIP IF DPK
	JRST TYPHU2
	SKIPG DBBCC	;SKIP IF TIME FOR MORE CHARS
	JRST DPTOE
	JRST TYPPRT
]
TYPHU2:
IFN MTYP,[
	TRNN T,40000
	JRST TTYRET
	SKIPG MTYOCC-NFMTY(I)
	JRST MTYO2
	JRST TYPPRT
]
	JRST TTYRET

TYPHD:	SETZM TCHP(I)
	MOVE C,TCMXV(I)
	SUBI C,1
	MOVEM C,TCVP(I)
	MOVE A,CCHDP
	MOVEM A,TTYBYP(I)
TYPPRT:	SUB P,[2,,2]
	JRST TYP0B

TYPD:	TRZE A,2000
	JRST TYPD4	;CURSOR CNTRL CHR
	ANDI A,177
	CAIN A,15
	JRST TYPDCR
	CAIN A,12
	JRST TYPDLF
	CAIN A,10
	JRST TYPDBS
	CAIE A,177
	CAIGE A,40
	JRST TYPD1	;NON SPACING
	CLEARM TTYDLY(I)	;OUTPUTTING A SPACING FROB
	AOS B,TCHP(I)	;AOS CURSOR POS
	AOS @TYPDT2(U)	;AOS OUTPUT POS FOR APPRO BUFFER
	CAMGE B,TCMXH(I)	;MAX LIMIT HORZ
	JRST TYPD1	;NO WRAPAROUND, OUTPUT CHR
	CLEARM @TYPDT2(U)	;HORZ POS FOR BUFFER
	MOVE C,[440700,,TTYBT(I)]
	MOVEM C,TTYBYP(I)
	MOVSI C,(ASCIZ /!/)
	AOS B,TCVP(I)	;TO NEXT LINE (MAYBE)
	CAMGE B,@TYPDT3(U)	;REACHED END OF SPACE?
	JRST TYPD2	;NO
	MOVEM C,TTYBT(I)
	MOVE E,@TYPDT4(U)	;LINE # OF START OF SPACE
	MOVEM E,@TYPDT1(U)	;VERT POINTER FOR BUFFER
	CAMGE B,TCMXV(I)	;LAST LINE OF SCOPE?
	JRST TYPD3	;NOT REALLY BOTTOM OF SCOPE
	SOS TCVP(I)	;NOT REALLY GOING TO NEXT LINE
	AOS TCHP(I)	;ALLOW FOR !
	JRST TYPD5

TYPD2:	AOS @TYPDT1(U)	;ADV BUFFER TO NEXT LINE
TYPD3:	IOR C,CCNEWL-1(W)	;CR LF TO GET TO NEXT LINE
	MOVEM C,TTYBT(I)
	CLEARM TCHP(I)
TYPD5:	MOVEM U,TTYBSL(I)
	MOVEI C,TYPLF1
	MOVEM C,TTYOPC(I)
	JRST TYPD1

TYPDLF:	MOVE C,CCLFP-1(W)
	CAIE W,2
	JRST TYPDL1
	CAIL J,5
	MOVE C,CCLFP1	;PADDED
TYPDL1:	MOVEM C,TTYBYP(I)
	AOS B,TCVP(I)
	AOS @TYPDT1(U)	;ADVANCE BUFFER POINTER TO NEXT LINE
	CAMGE B,@TYPDT3(U)
	JRST TYDCX	;NOT AT END OF SPACE
	MOVE E,@TYPDT4(U)	;LINE NUMBER OF START OF SPACE
	MOVEM E,@TYPDT1(U)	;RESET BUFFER VERTICAL POINTER
	MOVEM U,TTYBSL(I)
	CLEARM TTYBYP(I)
	MOVEI C,TYPLF1
	MOVEM C,TTYOPC(I)
	SOS TCVP(I)	;NOT REALLY GOING TO NEXT LINE
	JRST TYDCX

TYPLF1:	CAIN W,3
	JRST TYPLF2
	SKIPLE SPCCC(I)
	JRST TYP1B
TYPLF2:	SKIPE TTYBYP(I)
	JSP E,TYPBP
	MOVE U,TTYBSL(I)
	PUSHJ P,TYPCPC
	MOVEI C,TYP1
	MOVEM C,TTYOPC(I)
	MOVE C,CCELP-1(W)
	CAIN W,3
	JRST TYPLF4
	CAIE W,2
	JRST TYPLF3
	CAIL J,5
	MOVE C,CCELP4
TYPLF3:	MOVEM C,TTYBYP(I)
	POPJ P,

TYPLF4:	SKIPN TCHP(I)	;DON'T CLEAR LINE IF NOT AT FRONT
	JRST TYPLF3
	POPJ P,

TYDPPD:	CAIL J,5	;WANT TO SEND CURSOR CNTRL. WAS LAST CHAR PRINTING?
	SKIPGE TTYDLY(I)
	JRST (E)	;NO PADDING REQD
	MOVEI C,4
	CAIGE J,6
	MOVEI C,3	;1200 BAUD
	MOVEM C,SPCCC(I)
	SETOM TTYDLY(I)
	JRST (E)

TYPDCR:	CLEARM TICHRC(I)
	MOVE E,@TYPDT2(U)
	CLEARM @TYPDT2(U)	;RESET BUFFER HORZ POSITION
	MOVE C,TCVP(I)
	AOS C

	CLEARM TCHP(I)
	CAIN W,3
	JRST TYDCR2
	MOVE C,CCCRP-1(W)
	MOVEM C,TTYBYP(I)
TYDCX:	CAIE W,2
	POPJ P,
	SKIPL TTYDLY(I)
	JSP E,TYDPPD
	POPJ P,

TYDCR2:	JUMPN E,TYPD1
	MOVEI A,23	;CLEAR LINE IF AT FRONT
	JRST TYPD1

TYPDBS:	SETZM TTYDLY(I)
	SOSGE TCHP(I)
	SETZM TCHP(I)
	SOSGE @TYPDT2(U)
	SETZM @TYPDT2(U)
	SOSGE TICHRC(I)
	SETZM TICHRC(I)
	JRST TYPD1

TYPD4:	TRZN A,1000
	JRST @CCTB(A)	;RANDOM CNTRL FCTN
	MOVEI C,0	;V
	TRZE A,400	;SKIP IF V
	MOVEI C,1	;H
	ANDI A,177
	ADD A,@TYPDT7(C)	;ADD ORG OF COM ECHO AREA IF  VERT ECHO
	MOVE B,@TYPDT8(C)
	CAML A,B
	SOS A,B
	MOVEM A,@TYPDT9(C)
	JUMPE C,CPOPJ	;VERT
	MOVEM A,TICHRC(I)	;HORZ POSITION
	POPJ P,

CCFS:	AOS B,@TYPDT2(U)
	AOS TICHRC(I)
	CAML B,TCMXH(I)
	CLEARM @TYPDT2(U)
	SKIPE TCECL(I)
	JUMPE U,CPOPJ
	CAML B,TCMXH(I)
	SETZM TICHRC(I)
	POPJ P,

CCBS:	SOSGE B,@TYPDT2(U)
	CLEARB B,@TYPDT2(U)
	SKIPE TCECL(I)	;SKIP ON NO ECHO AREA
	JUMPE U,CPOPJ	;MAIN PRGM AREA
	SOSGE TICHRC(I)	;ECHO AREA
	SETZM TICHRC(I)
	POPJ P,

CCLFR:	AOS B,@TYPDT1(U)
	CAMGE B,@TYPDT3(U)
	POPJ P,
	MOVE B,@TYPDT4(U)
	MOVEM B,@TYPDT1(U)
	POPJ P,

CCLS:	SOS B,@TYPDT1(U)
	CAMGE B,@TYPDT4(U)
	MOVE B,@TYPDT4(U)
	MOVEM B,@TYPDT1(U)
	POPJ P,

CCSPS:	MOVE B,TCVP(I)
	DPB B,TYPDT5(U)
	MOVE B,TCHP(I)
	DPB B,TYPDT6(U)
	POPJ P,

CCRPS:	LDB B,TYPDT5(U)
	MOVEM B,@TYPDT1(U)
	LDB B,TYPDT6(U)
	MOVEM B,@TYPDT2(U)
	POPJ P,

CCFFR:	MOVE B,CCFFP-1(W)
	MOVEM B,TTYBYP(I)
	CLEARM TCVP(I)
	CLEARM TCHP(I)
	CLEARM TCMVPO(I)
	CLEARM TCMHPO(I)
	CLEARM TCEHPO(I)
	CLEARM TICHRC(I)
	MOVE C,TCMXP(I)
	SKIPN TCECL(I)
	MOVEI C,0	;NO ECHO AREA
	MOVEM C,TCEVPO(I)
	POPJ P,

CCHUR:	MOVE B,@TYPDT4(U)
CCHU1:	CLEARM @TYPDT2(U)
	MOVEM B,@TYPDT1(U)
	SKIPE TCECL(I)
	JUMPE U,CPOPJ
	SETZM TICHRC(I)
	POPJ P,

CCHDR:	SKIPE B,@TYPDT3(U)
	SOJA B,CCHU1

CCEEOF:	CAIN W,3
	POPJ P,
	MOVE B,CCEOFP-1(W)
	MOVEM B,TTYBYP(I)
	POPJ P,

CCEEOL:	CAIE W,3
	JRST CCEE2
	SKIPE TCHP(I)
	POPJ P,
CCEE2:	MOVE B,CCELP-1(W)
	CAIN W,2
	CAIGE J,5
	JRST CCEE1
	MOVE B,CCELP4
CCEE1:	MOVEM B,TTYBYP(I)
	POPJ P,

TYPTHT:	TRNE A,2000	;SKIP IF IGNORE
	POPJ P,	;DISPLAY CNTRL CODE
	HRRE C,TTYSTS(I)
	AOJE C,TYPTH4
	TLNN R,100000	;SKIP IF IN HALF DUPLEX MODE
	JRST TYPTH4
	TRNN A,200	;SKIP IF NOT A COM ECHO CHARACTER
	POPJ P,	;ECHO
	ANDI A,177	;ECHO CR AS LF, 33 AS $, AND TAB IF NOT IN HARDWARE TAB
	CAIE A,15
	JRST TYPTH2
	MOVEI A,12
	POPJ P,
TYPTH2:	CAIE A,33
	JRST TYPTH3
	MOVEI A,"$
	POPJ P,

TYPTH3:	CAIN A,11
	TLNE R,4000	;SKIP IF NOT IN HARDWARE TAB MODE
	JRST POPJ1	;TAB ALREADY DONE LOCALLY
TYPTH5:	MOVNI B,3
	MOVEM B,SPCCC(I)	;ECHO AS THREE SPACES
	MOVEM U,TTYBSL(I)
	JRST POPJ1

TYPTH4:	ANDI A,177
	CAIN A,33
	MOVEI A,"$
	TLNE R,4000	;SKIP IF NOT IN HARDWARE TAB MODE
	POPJ P,
	CAIE A,11	;SKIP IF A TAB
	POPJ P,	;TYPE CHARACTER IF NOT A TAB
	JRST TYPTH5	;ECHO TAB AS THREE SPACES

EBLK

NOTYS==1	;NUMBER OF TTYS ON DEVICE TTY
;SET IN INITIAL PARAMS SECTION
;NNTYS==16.	;NUMBER OF TTYS ON DEVICE NTY
;NNVTTS==8	;# OF NOVA PSEUDO TTYS
;NDPTYS==16.	;# DATAPOINT PORTS
;NMTYS==0	;# MORTON TTYS
NSTTYS==6	;NUMBER OF PSEUDO TTYS
NCT==NOTYS+NNTYS+NNVTTS+NDPTYS+NMTYS+NSTTYS	;TOTAL NUMBER OF TTYS
	;TOTAL NUMBER OF CONSOLES

NFDPT==NOTYS+NNTYS+NNVTTS	;# OF FIRST DATAPOINT LINE
NFMTY==NFDPT+NDPTYS	;# OF FIRST MORTON TTY
NFSTTY==NFMTY+NMTYS	;# OF FIRST PSEUDO-TTY

LDBFF==10.	;LENGTH OF OUTPUT BUFFER^2 (PER LINE)

IFN NNVTTS,[
NOVATT:	-1	;TTY # NOVA CONNECTED TO -1 IF NONE
NVIPTT:	-1	;CURRENT NOVA PSEUDO TTY ON INPUT
NVOPTT:	0	;CURRENT NOVA PSEUDO TTY ON OUTPUT
NVTSIP:	0	;-1 IF NOVA TTY SELECT IN PROGRESS (OUTPUT)
NVTSSC:	0	;CHAR SAVED HERE DURING NVTSIP -1
NVTCC:	0	;# CHARS SENT TO CURRENT TTY SINCE RESCANING OTHER PSEUDO TTYS
NNVSEC:	0	;LAST CONSOLE TO CHECK IN TYP0 SEARCH
NNVSFL:	0	;-1 IF SERVING PREV SELECTED 
		;IE IF IT CRAPS OUT, SEARCH EVEN THO IT = NNVSEC
]

TIBL==41
TOBL==41
TEBL==41

TIBS==TIBL*3
TOBS==TOBL*3
TEBS==TEBL*3

MICBAA==60.	;MAXIMUM NUMBER OF INPUT BUFFER CHARACTERS BEFORE AUTOMATIC ACTIVATION

TIB:	BLOCK TIBL*NCT	;TTY INPUT BUFFERS (12 BITS PER CHARACTER)
TOB:	BLOCK TOBL*NCT	;TTY OUTPUT BUFFERS (12 BITS PER CHARACTER)
TEB:	BLOCK TEBL*NCT	;TTY ECHO BUFFERS

;N.12 =>
;	IN INPUT BUFFER: CHARACTER IS AN ACTIVATION CHARACTER
;	IN OUTPUT BUFFER: MAIN PROGRAM ECHO CHARACTER OR SUPER QUOTE CHAR SPEC BY N.11
;N.11 => IN INPUT BUFFER:IGNORE CHAR AT MAIN PROGRAM LEVEL
;	IN OUTPUT BUFFER IF N.12=1: 0-> MP ECHO, 1-> SUPER QUOTE CHR
;	IN ECHO OR OUTPUT BUFFER: THIS CHR CURSOR CNTRL, FCTN OBTAINED FROM CCTB
;N.10 =>
;	IN INPUT BUFFER: ECHO CHAR AT MAIN PROGRAM LEVEL
;	IN ECHO BUFFER: THIS CHARACTER AND THE NEXT GO TOGETHER
;	IN OUTPUT BUFFER  AND IF N.11 SET, ABS CURSOR POS
;N.9 =>
;	IN INPUT BUFFER: ECHO CHAR AT PI LEVEL
;	IN ECHO BUFFER: DON'T AOS TICC ON THIS CHARACTER
;	IN OUTPUT BUFFER: OUTPUT THIS CHARACTER UNALTERED
;	(IF N.11 AND N.10 BOTH SET, 0 VERT 1 HORZ)
;N.8 => COM ECHO CHAR
;N.7-N.1 => CHARACTER


TIIP:	REPEAT NCT,  (001400)TIB-1+.RPCNT*TIBL	;INPUT BUFFER INPUT POINTER
TIOP:	REPEAT NCT,  (001400)TIB-1+.RPCNT*TIBL	;INPUT BUFFER OUTPUT POINTER
TIBEP:	REPEAT NCT,  (001400)TIB-1+.RPCNT*TIBL+TIBL	;END OF INPUT BUFFER POINTER
TOIP:	REPEAT NCT,(001400)TOB-1+.RPCNT*TOBL	;OUTPUT BUFFER INPUT POINTER
TOOP:	REPEAT NCT,(001400)TOB-1+.RPCNT*TOBL	;OUTPUT BUFFER OUTPUT POINTER
TOBEP:	REPEAT NCT,(001400)TOB-1+.RPCNT*TOBL+TOBL	;END OF OUTPUT BUFFER POINTER
ECHOIP:	REPEAT NCT,(001400)TEB-1+.RPCNT*TEBL	;ECHO BUFFER INPUT POINTER
ECHOOP:	REPEAT NCT,(001400)TEB-1+.RPCNT*TEBL	;ECHO BUFFER OUTPUT POINTER
ECHOEP:	REPEAT NCT,(001400)TEB-1+.RPCNT*TEBL+TEBL	;ECHO BUFFER END POINTER
TINTP:	REPEAT NCT,  (001400)TIB-1+.RPCNT*TIBL	;INTERRUPT CHARACTER POINTER

TTYSC:	REPEAT NCT,0	;SECOND CHARACTER OF A TWO CHARACTER PAIR TO BE TYPED OUT
TYIMSK:	REPEAT NCT,0	;BIT SET FOR EACH CHANNEL A TTY IS OPEN FOR INPUT ON
ECHOBR:	REPEAT NCT,TEBS	;NUMBER OF CHARACTER POSITIONS AVAILABLE IN THE ECHO BUFFER
ECHOC:	REPEAT NCT,0	;COUNT OF ECHO BUF CHARS THAT ARE REALLY ECHO CHARS
ECHOP:	REPEAT NCT,0	;POINTER TO INPUT CHARACTER TO BE ECHOED NEXT
TINTC:	REPEAT NCT,0	;COUNT OF CHARACTERS AVAILABLE AT THE INTERRUPT LEVEL
DINGF:	REPEAT NCT,0	;-1 IF OUTPUT ROUTINES SHOULD MAKE THE TTY GO DING
TICC:	REPEAT NCT,0	;TYPE IN CHARACTER COUNT
TACC:	REPEAT NCT,0	;ACTIVATION CHARACTER COUNT
SPCCC:	REPEAT NCT,0	;>0 # RUBOUTS, <0 -# SPACES
TICHRC:	REPEAT NCT,0	;HORZ CHAR POS (USED FOR PADDING COMPUTATION ONLY)
LCHTYO:	REPEAT NCT,0	;-1 IF LAST CHAR TYPED WAS CR LF IN ASCII MODE
TTYBYP:	BLOCK NCT	;BYTE PNTR TO OUTPUT SEQ (ILDB UNTIL 0 CHR)
TTYBT:	BLOCK NCT	;RANDOM WD TTYBYP CAN BE SET UP TO
TTYDLY:	BLOCK NCT	;-1 IF LAST WAS CURSOR SPACING CHR 0 OTHERWISE
TTYBSL:	BLOCK NCT	;SPACES (IN SPCCC) FOR M.P. OR ECHO
TTLTM:	BLOCK NCT	;TIME LAST CHR WAS PROCESSED AT TYP ON OUTPUT

;DISPLAY MODE AND 2741 VARS

2741E:	0	;NUMBER OF 2741 ERRORS
TCTYP:	BLOCK NCT	;0 TTY 1 DATAPOINT 2 TELTERM
27IGE:		;2741 IGNORE EOA FLAG (-1 TO IGNORE)
TCVP:	REPEAT NCT,0	;VERT CURSOR POS (HARDWARE)
27SE:		;2741 SEND EOA FLAG (-2 TO SEND  -1 SEND COMPLETE)
TCHP:	REPEAT NCT,105	;HORZ ""
27CASE:		;400 FOR UPPER 200 FOR LOWER
TCMVPO:	REPEAT NCT,200	; VERT POS PRGM OUT PUT BUFFER OUT
27CTLF:		;-1 IF LAST CHAR IS @
TCMHPO:	REPEAT NCT,0	;HORZ
27LICR:		;-1 IF LAST CHAR IS CR
TCEVPO:	REPEAT NCT,0	;VERT POS ECHO BUFFER OUT
27LIAT:		;-1 IF LAST INPUT WAS NOT ATT
TCEHPO:	REPEAT NCT,-1	;HORZ
27PMS:		;-1 IF IN PROCEED MODE
TCSCP:	REPEAT NCT,-1	;SAVED CURSOR POS Q4 M.P.V. Q3 M.P.H Q2 ECV Q1 ECH

27FLG:	REPEAT NCT,-1	;0 IF NOT FIRST TIME THROUGH TYP27
27SAVC:	REPEAT NCT,-1	;SAVE CHAR HERE DURING CASE CHANGE AND BREAK. -1 WHEN FREE
27STRT:	REPEAT NCT,0	;WHEN 27FCLK=-1 27STRT IS AOSED EVER 60TH OF A SECOND
			;WHEN IT BECOMES 0 OUTPUT DONE IS SET
27STOU:	REPEAT NCT,0	;-1 TO STOP OUTPUT AND PUT TTY IN PROC MODE
27TIME:	REPEAT NCT,-1	;>0 IF TIME OF LAST ZERO CHAR
27FTIM:	REPEAT NCT,0	;TIME OF FIRST ZERO CHAR

;FOLLOWING 4 VARS MUST NOT BE USED FOR 2741 VARS
TCMXV:	BLOCK NCT	;MAX LINES VERT
TCMXH:	BLOCK NCT	;MAX CHR HORZ (ACTUAL -1)
TCECL:	BLOCK NCT	;LINES TO BE USED FOR ECHO (0=> ECHO WITH M.P.)
TCMXP:	BLOCK NCT	;MAX V LINE TO BE USED FOR M.P. DIS

;DATA POINT CONTROLLER LINE VARIABLES
;THIS ARRAY LOOKED AT BY HARDWARE

IFN DPKPP,[
DPKBAS:	REPEAT NDPTYS,[
	-1	;CHR CNT
	(440701,,DPKFF)	;BYTE PNTR
]
DPKFF:	35_29.+37_22.	;FF AT LEAST ON DATAPOINTS

DBBFP:	REPEAT NDPTYS,	440700,,DBBF+.RPCNT*LDBFF	;PNTRS TO OUTPUT BUFFER
DPKC:	REPEAT NDPTYS,	DPKBAS+2*.RPCNT	;PNTR TO HARDWARE COUNT WORD
DPKP:	REPEAT NDPTYS,	DPKBAS+2*.RPCNT+1	;PNTR TO BUFFER PNTR WD
DBBF:	BLOCK LDBFF*NDPTYS	;OUTPUT BUFFER
DBBCC:	0	;CHRS REMAINING IN CURRENT BLOCK (FOR DPK LINES)
			;SET FROM OUTPUT SPEED TO REPRESENT APPROX 100 MS TYPING TIME

DBBBP:	0	;BYTE PNTR TO DBBF BUFFER

DPSPT:	2	;2741
	6	;600
	1	;110
	2	;150
	3	;300
	24.	;1200
	48.	;2400
	48.	;4800

]

;MORTON BOX LINE VARIABLES
IFN MTYP,[
MTYOW:	BLOCK NMTYS	;OUTPUT WORD
MTYNC==5	;NUMBER OF CHARS PACKED IN ABOVE WORDS
MTYOCC:	BLOCK NMTYS	;# REMAINING CHAR POSITIONS
MTYOBP:	REPEAT NMTYS,440700,,MTYOW-NFMTY(I)	;BYTE POINTERS TO MTYOW
]
COMT1:	BLOCK NCT	;COM TEMPORARY STORAGE
COMT2:	BLOCK NCT
COMT3:	BLOCK NCT
CHNBIT:	REPEAT 20,1_<.RPCNT>

;XCT CNTRL FCTN CONSOLE TYPE IN B
CCTB:	JRST CCFS	;FOWARD SPACE (F)
	JRST CCBS	;BACK SPACE (B)
	JRST CCLFR	;LF (D)
	JRST CCLS	;LINE STARVE (U)
	JRST CCSPS	;STORE CURSOR POS (S)
	JRST CCRPS	;RESTORE CURSOR POS (R)
	JRST CCFFR	;CLEAR SCREEN (C)
	JRST CCHUR	;HOME UP (T)
	JRST CCHDR	;HOME DOWN (Z)
	JRST CCEEOF	;ERASE CURSOR TO EOF (E)
	JRST CCEEOL	;ERASE CURSOR TO EOL (])
;	JRST CCRLU	;ROLL UP (>)
;	JRST CCRLD	;ROLL DOWN (<)
;N.11 =1 N.10=1 N.9=1 SET HORZ POS
;N.11=1 N.10=1 N.9=0 SET VERT POS

CCTBC:	"F
	"B
	"D
	"U
	"S
	"R
	"C
	"T
	"Z
	"E
	"]
;	">
;	"<
NCCHRS==.-CCTBC

CNSLHL:	81.	;LENGTH OR HORZ LINE (TTY)
	71.	;DATAPOINT (REALLY 72 BUT ONE FOR !)
	70.	;OLD (TST) DATAPOINT (REALLY 72 BUT 1 FOR ! AND 1 FOR WRAPAROUND LOSSAGE)
	90.	;IMLAC

CNSLVL:	MOVE	;# VERT LINES
	25.	;DATAPOINT
	25.	;OLD DATAPOINTS
	39.	;IMLAC

;DATAPOINT CURSOR CONTROL CHARACTERS
;30 => FOWARD SPACE
;31 => (NON-EXISTANT)
;32 => MOVE UP
;33 => (NON-EXISTANT)
;34 => HOME DOWN (DOESN'T WORK ON OLD DATAPOINTS ABOVE 300 BAUD)
;35 => HOME UP
;36 => CLEAR EOL
;37 => CLEAR EOF

CCR:	30_29.
	30_29.

CCL:	10_29.
	10_29.

CCD:	12_29.
	12_29.

CCU:	32_29.
	32_29.

CCHU:	35_29.
	35_29.

CCHDP:	440700,,CCHD
CCHD:	34_29.+177_22.+177_15.+177_8

CCNEWL:	15_22.+12_15.
	15_22.+12_15.
	15_22.+13_15.

CCELP:	440700,,CCEOL
	440700,,CCEOL+1
	440700,,CCEOL+2

CCELP4:	440700,,CCEOL4

CCEOL:	36_29.
	36_29.
	23_29.

CCEOL4:	36_29.+36_22.+36_15.+36_8+36_1
	0

CCLFP:	440700,,CCLF
	440700,,CCLF1
	440700,,CCLF1+1

CCLFP1:	440700,,CCLF2

CCLF:	12_29.+177_22.+177_15.+177_8+36_1
	0
CCLF1:	12_29.+36_22.
	13_29.+23_22.

CCLF2:	12_29.+36_22.+36_15.+36_8+36_1
	36_29.

CCCRP:	440700,,CCCR1
	440700,,CCCR2

CCCR1:	36_29.+15_22.+177_15.
CCCR2:	36_29.+36_22.+36_15.+36_8+36_1
	15_29.

CCFFP:	440700,,CCFF
	440700,,CCFF1
	440700,,CCFF2

CCFF:	35_29.+37_22.
CCFF1:	35_29.+37_22.+37_15.+37_8+37_1
	37_29.
CCFF2:	22_29.

CCEOFP:	440700,,CCEOF
	440700,,CCEOF1

CCEOF:	37_29.
CCEOF1:	37_29.+27_22.+37_15.+37_8+37_1
	0

27ATT==174
27EOA==64
27EOT==174
27LWR==37
27UPR==34
27IDLE==75

9BPTR:	331100,,
	221100,,
	111100,,
	001100,,

BCDTBL:	675675,,675675	;^@ ^A ^B ^C
	675675,,675675	;^D ^E ^F ^G
	735657,,656675	;^H ^I ^J ^K
	675755,,675675
	675675,,675675
	675675,,675675
	675675,,675303
	675675,,675675
	700565,,464264
	365550,,303530
	544524,,404503
	366201,,267342
	324240,,220360
	210350,,330270
	204344,,410560
	420440,,470542
	202443,,423563
	413553,,533473
	407547,,541521
	461511,,451431
	571505,,445522
	462512,,452432
	572506,,446566
	467566,,566401	;\ ] ^ _
	402243,,223363
	213353,,333273
	207347,,341321
	261311,,251231
	371305,,245322
	262312,,252232
	372306,,246675
	566675,,675675

ASCTBL:	40,,40	;SPACE
	55,,137	;-,UNDERSCORE(_)
	100,,46	;@,CENT SIGN(&)
	33,,53	;&(ALT MODE),+
	70,,52	;8,*
	161,,121	;Q,Q (LOWER,,UPPER)
	171,,131	;Y,Y
	150,,110	;H,H
	64,,72	;4,:
	155,,115	;M,M
	165,,125	;U,U
	144,,104	;D,D
	177,,177	;PUNCH ON
	177,,177	;RESTORE
	177,,177	;BYPASS
	177,,177	;PUNCH OFF
	62,,74	;2,<
	153,,113	;K,K
	163,,123	;S,S
	142,,102	;B,B
	60,,51	;0,)
	177,,177
	177,,177
	177,,177
	66,,47	;6,'
	157,,117	;O,O
	167,,127	;W,W
	146,,106	;F,F
	177,,177	;UPPER CASE
	10,,10	;BACKSPACE
	177,,177	;EOB
	177,,177	;LOWER CASE
	61,,75	;1,=
	152,,112	;J,J
	57,,77	;/,?
	141,,101	;A,A
	71,,50	;9,(
	162,,122	;R,R
	172,,132	;Z,Z
	151,,111	;I,I
	65,,45	;5,%
	156,,116	;N,N
	166,,126	;V,V
	145,,105	;E,E
	177,,177	;READER STOP
	15,,15	;NEWLINE
	12,,12	;LINE FEED
	11,,11	;TAB
	63,,73	;3,;
	154,,114	;L,L
	164,,124	;T,T
	143,,103	;C,C
	43,,42	;#,"
	44,,41	;$,!
	54,,136	;COMMA,VERTICAL BAR
	56,,134	;.,NOT SIGN(\)
	67,,76	;7,>
	160,,120	;P,P
	170,,130	;X,X
	147,,107	;G,G
	177,,177	;EOT
	177,,177	;IDLE
	177,,177	;PREFIX
	177,,177	;DELETE

TTYOAC:	REPEAT NCT,-1	;-1 IF TTY OUTPUT INACTIVE 

TTYIPC:	REPEAT NCT,TTYI	;TTY INPUT PC
TTYOPC:	REPEAT NCT,TYP1	;TTY OUTPUT PC
TTYPDP:	-20,,TTYPDL-1
TTYPDL:	BLOCK 20

TORM:	REPEAT NCT,TOBS
TTYST:	CONO TTY,10+TTYCHN
	REPEAT NNTYS,PUSHJ P,NTYST
	REPEAT NNVTTS,PUSHJ P,NVTYST
	REPEAT NDPTYS,CONO DPK,.RPCNT_12.+100+TTYCHN
	REPEAT NMTYS,CONO MTY,.RPCNT_12.+10+TTYCHN
	REPEAT NSTTYS,PUSHJ P,TTYPT

27BRK:	JRST 4,.
IFN TK10P,[
	REPEAT 10,JRST 4,.	;T0-T10
	REPEAT 3,CONO NTY,100_.RPCNT+40+TTYCHN
]
	REPEAT NCT-.+27BRK,JRST 4,.

TTYLT:	500000+TTYCHN
	REPEAT NNTYS,.RPCNT_12.+400000+TTYCHN
	REPEAT NNVTTS,0
	REPEAT NDPTYS,0
	REPEAT NMTYS,.RPCNT_12.+TTYCHN

IFN TK10P,[
NTYST:	CONO PI,TTYOFF
	CONO NTY,@TTYLT(A)
	CONO NTY,10+TTYCHN
	CONO PI,TTYON
	POPJ P,
]

IFN NNVTTS,[
NVTYST:	PUSH P,A
	SKIPL A,NOVATT
	PUSHJ P,NTYST
	JRST POPAJ
]

TTYPT:	PUSH P,B
	PUSH P,C
	MOVE B,TIME
	MOVEM B,TTLTM(A)	;WASNT TRYING PREVIOUSLY
	MOVE B,STYSTS-NFSTTY(A)	;USER
	MOVE C,STYMSK-NFSTTY(A)	;CHANNELS OPEN MASK
	AND C,MSKST2(B)
	JUMPE C,TTYPT1	;JUMP IF INTS NOT ENABLED
	MOVN B,C
	AND C,B
	MOVE B,STYSTS-NFSTTY(A)
	IORM C,IFPIR(B)
TTYPT1:	POP P,C
	POP P,B
	POPJ P,

TTYDO:	REPEAT NOTYS,DATAO TTY,A
	REPEAT NNTYS,DATAO NTY,A
	REPEAT NNVTTS,PUSHJ P,TTNDO
	REPEAT NDPTYS,JRST 4,.
	REPEAT NMTYS,JRST 4,.
	REPEAT NSTTYS,MOVEM A,STYICH-NFSTTY(I)

IFN NNVTTS,[
TTNDO:	ANDI A,177
	CAME I,NVOPTT
	JRST TTNDO1
	AOS NVTCC
	DATAO NTY,A
	POPJ P,

TTNDO1:	MOVEM I,NVOPTT	;MUST SELECT NEW CONSOLE
	SETOM NVTSIP	;SIGNAL
	MOVEM A,NVTSSC	;SAVE CHR
	PUSH P,I
	SUBI I,NOTYS+NNTYS-1
	TRO I,200
	DATAO NTY,I
	CLEARM NVTCC
	POP P,I
	POPJ P,

NVTF:	REPEAT NOTYS+NNTYS,0	;SIGN SET FOR NOVA TTY
	REPEAT NNVTTS,SETZ
	REPEAT NDPTYS,0
	REPEAT NMTYS,0
	REPEAT NSTTYS,0
]

TTYDFF:	REPEAT NOTYS,CONO TTY,200+TTYCHN
	REPEAT NNTYS,CONO NTY,20+TTYCHN
	REPEAT NNVTTS,JRST 4,.
	REPEAT NDPTYS,JRST 4,.
	REPEAT NMTYS,CONO MTY,.RPCNT_12.+200+TTYCHN
	REPEAT NSTTYS,JRST 4,.

DPTSTP:	REPEAT NDPTYS,CONO DPK,.RPCNT_12.+400+TTYCHN

TABSPC==8

LOCTTY:	0	;CONSLOE INPUT CHAR READ FROM
TTYA:	0
TTYACS:	BLOCK 17-B+1

TTYOSW:	-1	;TTY OPEN SWITCH.  LOCKED BY OPEN ROUTINES
	0

STYOSW:	-1	;PSEUDO TTY OPEN SWITCH
	0

CNSBT==220100	;CONSOLE BIT
BCNSBT==1	;LEFT HALF CONSOLE BIT
DISMBT==420100	;DISPLAY MODE BIT
HARBTS:	125170,,0	;HARDWARE STATUS BITS

TTNTO:	BLOCK NCT	;NUMBER TIMES OPEN
STYNTO:	BLOCK NSTTYS	;NUMBER TIMES PSEUDO TTY OPEN
STYMSK:	REPEAT NSTTYS,0	;BIT FOR EACH CHNL STY OPEN FOR INPUT ON
STYOMS:	REPEAT NCT,0	;OUTPUT
STYSTS:	REPEAT NSTTYS,0	;STY STATUS   0 => FREE SLOT
			;4.9=1 => DON'T HANG ON INPUT IOTS
			;4.8=1 => IN USE
			;4.7 = 1 => HAVE GIVEN INT ON STY OUTPUT CHNS ALREADY
			;RH = USER INDEX THAT HAS IT OPEN
STYICH:	BLOCK NSTTYS	;TEMP STORAGE FOR PSEUDO-TTY INPUT CHAR

TTYST1:	REPEAT NCT,0	;FIRST SIX GROUPT (SIX BITS PER GROUP)
TTYST2:	REPEAT NCT,0	;SECOND SIX GROUPS (SIX BITS PER GROUP)
TTYSTS:	REPEAT NCT,-1	;MODE BITS FOR TTY

;GROUP NUMBER		   CHARACTERS
;	0		^A-^F ^K-^L ^N-^R ^T-^Z ^] ^^ ^_ ^@ ^\
;	1		A-Z   LOWER CASE A-Z
;	2		0-9
;	3		!"#$(DOLLAR)%&',.:;?@\ (ACCENT GRAVE) (VERTICAL BAR) (TILDE)
;	4		*+-/=^_
;	5		<>[]() (LEFT BRACE)
;	6		^G ^S
;	7		LF ^I(TAB)
;	10		$(ALT MODE) (RIGHT BRACE)
;	11		CR
;	12		RUBOUT
;	13		SPACE ^H(BACKSPACE)

;TTYST1 HAS GROUPS 0 THROUGH 5 FROM LEFT TO RIGHT
;TTYST2 HAS 6 THROUGH 13
;EACH GROUP HAS SIX BITS AS FOLLOWS:
;N.1 => INTERRUPT ON THIS GROUP
;N.2 => ACTIVATE ON THIS GROUP (FOR SWAPPING)
;N.3 => SPECIAL HACKS.  (THIS SET ON GROUP 1 => CONVERT LOWER CASE)
;N.4 => IMAGE MODE OUTPUT (N.4=0  => ASCII MODE)
;N.6-N.5 => ECHO MODE
;	00 => NO ECHO
;	01 => PI ECHO (ECHO CHARACTER WHEN TYPED)
;	10 => MAIN PROGRAM ECHO (ECHO WHEN MAIN PROGRAM RECEIVES CHARACTER)

;TTYSTS HAS RANDOM BITS ASSOCIATED WITH THE TELETYPE
;-1 => TTY IDLE
;4.9 => TTY NOT OPEN
;4.8 => DISPLAY MODE (LOOK FOR ^P AT M.P. LEVEL)?
;4.7 => HALF DUPLEX TERMINAL
;4.6 => RUBOUT (LINE AT A TIME) MODE
;4.5 => DON'T STANDARDIZE ALT MODE
;4.4 => STUFF MODE (ENTER CHARACTER INTO INPUT BUFFER FROM A PROGRAM)
;4.3 => HARDWARE TAB MODE
;4.2 => GOBBLE NEXT CHAR REGARDLESS OF ACTIVATION STATUS
;4.1 = 0 => ^Z HAS BEEN TYPED AND RECOGNIZED
;	(ONLY RELEVANT IF RH =-1)
;3.9 => INT ON NEXT CHAR REGARDLESS
;3.7-3.4 => PADDING MODE
;	0 => NO PADDING
;3.3 => LAST CHARACTER TYPED WAS ^Z (NOT PRECEEDED BY ^_)
;3.2 => SUPER IMAGE INPUT MODE
;3.1 => CONSOLE
;RH => USER INDEX
;	-1 => NO USER

TTYSTA:	REPEAT NCT,SETZ	;NOT SAVED AT ATTY
;4.9 = 0 => NEEDS TO HAVE CONSOLE FREE MSG EVENTUALLY TYPED
;	CLEARED BY OPEN OR USTART WHEN INITIALIZING CONSOLE PROCEDURE
;	SET BY SYS JOB AFTER TYPING CONSOLE FREE MSG

TTYCOM:	REPEAT NCT,0,,-1	;COMMUNICATE WORD
;4.9 => TTY IN COMMUNICATE MODE
;4.8 => LOCAL FEED THROUGH (SET IF MY PRGM RECIEVING HIS CHRS)
;4.7 => REMOTE FEED THROUGH (SET IF HIS PRGM RECIEVING MY CHRS)
;4.6 => INPUT COMMUNICATE OVERRIDE (SET IF MY CONSOLE FEEDING MY PRGM EVEN THO IN COMM MODE)
;4.5 => OUTPUT COMMUNICATE OVERRIDE (SET IF MY PRGM'S OUTPUT TO APPEAR ON MY CONSOLE ONLY EVEN THO IN COM MODE)
;4.4-4.3 => MESSAGE RECEIPT SWITCH
;	00 => ACCEPT
;	01 => INTERROGATE
;	10 => REFUSE
;4.2 COM FINISH SW (GIVE ECHO BUFFER PRIORITY OVER M.P. UNTIL EXHAUSTED)
;4.1  CONV LOWER CASE CHRS TO UPPER CASE (^_U)
;RH => USER INDEX COMMUNICATING WITH (-1 NONE)
LFT==200000
RFT==100000
ICO==40000
OCO==20000
COMFFL==2000
CLTUF==1000

;DISPLAY MODE HACKS
;SYSTEM'S CONSOLE IDEA 0 TTY, 1 DATAPOINT, 2 TELTERM
;PRGM'S CONSOLE IDEA TTY => TCECL=0, DIS => TCECL .NE. 0
;TO ACTIVATE DISPLAY HACK, BOTH MUST ASSERT DIS

BBLK

;3.4 => DON'T HANG ON IOT IF NO CHAR (RETURN -1 INSTEAD)
;3.5 = 1 => DON'T DO CHAR CONVERSION
;    = 0 => CONVERT ACCORDING TO OTHER BITS
;3.6 = 1 => ITS MODE (CTRL DOES CTRL AND META IS 8TH BIT)
;    = 0 => STANFORD MODE (400 = META, 200 = CTRL, AND ALL THE
;           CHARS FROM 1-177 CAN BE GENERATED WITH TOP AND SHIFT.)
;3.7 = 1 => IF 3.5 = 0, 3.6 = 1, THEN DON'T INPUT META BIT

IFN STKP,[
STKO:	TLNE C,3	;BLOCK OR OUTPUT
	JRST OPNL12	;MODE NOT AVAILABLE
	CONO PI,CLKOFF
	SKIPL STKUSR
	JRST OPNL10	;DEVICE NOT AVAILABLE
	MOVEM U,STKUSR
	AOSE STKUSE
	JRST 4,.	;CAN ONLY BE OPEN ONCE
	CONO PI,CLKON
	MOVE A,UUAC(U)
	MOVE A,CHNBIT(A)
	ROT D,-2
	DPB D,[220400,,A]
	MOVEM A,STKMSK
	MOVE A,STKBP
	MOVEM A,STKIP
	MOVEM A,STKOP
	SETZM STKBC
	DATAI STK,A	;CLEAR DONE
	CONO STK,LPTCHN
	MOVEI A,STKDP
	MOVEM A,(R)
	JRST POPJ1

STKCLS:	CONO STK,0	;CLEAR PIA
	SOSL STKUSE
	JRST 4,.	;CAN ONLY BE OPEN ONCE
	SETOM STKUSR
	POPJ P,

STKRS:	CONO PI,LPTOFF
	MOVE A,STKBP
	MOVEM A,STKIP
	MOVEM A,STKOP
	SETZM STKBC
	JRST LPTONJ

STKI:	XCTR XRW,[MOVES (C)]
	MOVE TT,STKMSK
	TLNE TT,1
	JRST STKI1
	PCLT
	SKIPG STKBC
	PUSHJ P,UFLS
STKI2:	ILDB A,STKOP
	SOS STKBC
	TLNN TT,2
	JRST STKCV	;DO CONVERSION
STKI3:	XCTR XW,[MOVEM A,(C)]
	MOVE A,STKOP
	CAMN A,STKEP
	SUBI A,STKBL
	HRRM A,STKOP
	POPJ P,

STKI1:	SKIPLE STKBC
	JRST STKI2
	JRST STTYI3

STKINT:	MOVEM B,LPTB
	DATAI STK,B
	ANDI B,1777	;CURRENTLY 10 BITS
	MOVE A,STKBC
	CAIL A,STKBS
	JRST LPTRT3	;NO ROOM.  JUST IGNORE CHAR
	IDPB B,STKIP
	AOS STKBC
	MOVE A,STKIP
	CAMN A,STKEP
	SUBI A,STKBL
	HRRM A,STKIP
	MOVE A,STKUSR
	HRRZ B,STKMSK
	AND B,MSKST2(A)
	IORM B,IFPIR(A)
	JRST LPTRT3

EBLK
STKBL==40
STKBS==STKBL*3
STKIP:	001400,,STKIB-1
STKIB:	BLOCK STKBL
STKEP:	001400,,STKIB+STKBL-1
STKBP:	001400,,STKIB-1
STKOP:	001400,,STKIB-1
STKBC:	0
STKMSK:	0	;BIT FOR CHANNEL STK OPEN ON
		;3.1 => DON'T HANG ON IOTS MODE
		;3.2 => DON'T CONVERT CHARS
		;3.3 => ITS MODE
		;3.4 => DON'T INPUT META IN ITS MODE
BBLK

STKCV:	LDB B,[000600,,A]	;LOW 6 BITS
	CAIN B,33
	JRST STKCV1	;33
	CAIL B,35
	CAILE B,47
	JRST .+2
	JRST STKCV2	;35-47
	CAIL B,74
	CAILE B,77
	JRST .+2
	JRST STKCV3	;74-77
	TRNE A,400
	JRST STKCVT	;TOP IS ON
	CAIG B,32
	JRST STKCV4	;0-32
	CAIN B,34	;SKIP IF 50-73
	JRST STKCVB	;34
STKCVX:	TLNN TT,4	;SKIP ON ITS MODE
	JRST STKCVY	;STANFORD MODE
	ANDI A,1000	;META BIT
	LSH A,-2
	TLNN TT,10	;SKIP ON DON'T INPUT META BIT
	IORI B,(A)
	MOVE A,B
	JRST STKI3

STKCVY:	LDB D,[110100,,A]	;META BIT
	LSH D,8		;IN 400 POSITION
	ANDI A,200	;CTRL BIT
	IORI A,(D)
	IORI A,(B)
	JRST STKI3

STKCV1:	MOVEI B,15
	JRST STKCVX

STKCV2:	MOVEI Q,-35(B)	;35-47 (-35)
	IDIVI Q,5
	LDB B,STKBPT(J)
	JRST STKCVX

STKCV3:	CAIE B,74
	JRST STKCV5	;75-77
	MOVEI B,177
	JRST STKCVX

STKCV5:	MOVEI B,33
	JRST STKCVX

STKCVT:	CAIG B,32	;TOP IS ON
	JRST STKCT1	;0-32
	CAIN B,34
	JRST STKCT2	;34
	MOVEI Q,-50(B)	;50-73 (-50)
	MOVE D,B
	IDIVI Q,5
	LDB B,STKBP1(J)
	TRNE A,200	;SKIP IF CTRL IS OFF
	TLNN TT,4	;SKIP IF ITS MODE
	JRST STKCVX
	CAIL D,52
	CAILE D,72
	TRZ B,100	;50,51,73
	JRST STKCVX

STKCT1:	MOVE Q,B	;0-32 TOP ON
	MOVE D,B
	IDIVI Q,5
	LDB B,STKBP2(J)
	TRNE A,200	;SKIP IF CTRL IS OFF
	TLNN TT,4	;SKIP IF ITS MODE
	JRST STKCVX
	CAIN D,12
	TRZ B,100
	JRST STKCVX

STKCT2:	MOVEI B,16
	JRST STKCVX

STKCV4:	TLNN TT,4	;SKIP IF ITS MODE
	JRST STKCV6
	TRNE A,200
	JRST STKCVX	;ITS, CTRL
STKCV6:	TRO B,100
	TRNN A,100
	TRO B,40	;SHIFT WAS OFF
	JRST STKCVX

STKCVB:	MOVEI B,134
	TRNE A,200	;SKIP IF CTRL IS OFF
	TLNN TT,4	;SKIP IF ITS MODE
	JRST STKCVX
	TRZ B,100
	JRST STKCVX

DEFINE	STKM A,B,C,D,E
	A_29.+B_22.+C_15.+D_8+E_1
TERMIN

DEFINE	STKM1 TBL
	350700,,TBL(Q)
	260700,,TBL(Q)
	170700,,TBL(Q)
	100700,,TBL(Q)
	010700,,TBL(Q)
TERMIN

STKBPT:	STKM1 STKTBL
STKTBL:	STKM 12,0,0,40,0
	STKM 33,0,0,11,14
	STKM 13,0,0,0,0

STKBP1:	STKM1 STKTB1
STKTB1:	STKM 133,135,26,174,41
	STKM 5,77,17,60,36
	STKM 22,23,20,21,44
	STKM 45,32,30,1,136

STKBP2:	STKM1 STKTB2
STKTB2:	STKM 0,34,7,6,74
	STKM 100,76,33,75,47
	STKM 137,31,27,25,24
	STKM 173,176,4,43,35
	STKM 46,140,10,37,3
	STKM 42,2,0,0,0
]

; IO CHANNEL PUSH DOWN LIST ROUTINES
;LOOK AT LH OF RESET TABLE TO SEE IF DEVICES HAVE ROUTINES (FOR INTERRUPTS ETC)
;C(I) =0 AT DSP => IOPUSH =1 => IOPOP

AIOPUSH:	MOVE T,SIOCP(U)	;PICK UP PDL POINTER
	CAML T,[LUIOP-2,,]
	JRST IOCER6	;OVER PUSH ERROR
	MOVE B,(R)
	PUSH T,B	;PUSH CURRENT IOCHNM
	PUSH T,IOCHST-IOCHNM(R)	;&IOCHST
	MOVE J,UUAC(U)
	DPB J,[400400,,(T)]	;STORE CHANNEL NUM FOR POSSIBLE USE BY AIOPDL
	MOVEM T,SIOCP(U)	;STORE BACK PDL POINTER
	HLRZ T,RSTB(B)	;GET LH OF RESET ENTRY
	JUMPE T,AIPSH2	;JUMP ON NO ROUTINE FOR THIS DEV
	MOVEI I,0	;INDICATE IOPUSH
	PUSH P,R
	PUSHJ P,(T)	;SHOULD NOT HANG
	POP P,R
AIPSH2:	SETZM (R)	;CLEAR OUT IOCHNM
	SETZM IOCHST-IOCHNM(R)	;&IOCHST
	POPJ P,

AIOPOP:	PUSHJ P,ACLOSE	;CLOSE WHATEVER MAY BE OPEN ON CHANNEL POPPING INTO
	MOVE T,SIOCP(U)	;PICK UP PDL POINTER
	TLNN T,-1
	JRST IOCER5	;OVER POP ERROR
	POP T,IOCHST-IOCHNM(R)	;POP BACK IOCHST
	POP T,B		;&IOCHNM
	MOVEM B,(R)
	SETZM 1(T)	;CLEAR OUT PDL WORD TO AVOID CONFUSION IN
			;ROUTINES THAT GROVEL OVER I/O PDL
	MOVEM T,SIOCP(U)	;STORE BACK PDL POINTER
	HLRZ T,RSTB(B)
	JUMPE T,CPOPJ
	MOVEI I,1	;INDICATE IOPOP
	JRST (T)

AIOPDL:	MOVE T,SIOCP(U)	;PICK UP PDL POINTER
	TLNN T,-1	;SKIP UNLESS IO PDL EMPTY
	POPJ P,
	LDB R,[400400,,(T)]	;FIND OUT WHAT CHNL TOP ENTRY WAS PUSHED FROM
	ADDI R,IOCHNM(U)
	PUSHJ P,AIOPOP	;POP BACK INTO CHNL PUSHED FROM
	JRST AIOPDL

IIOPPR:	JUMPE I,[JRST 4,CPOPJ]	;IOPUSH
	SETZM (R)	;CLOSE CHANNEL
	SUBI R,IOCHNM(U)	;GET CHANNEL NUMBER
	MOVE R,CHNBIT(R)	;SECOND WORD INTERRUPT BIT
	IORM R,IFPIR(U)	;GIVE TO USER
	POPJ P,

;.GETSYS AC,	;TRANSFERS SYSTEM AREA SPECIFIED BY C(AC+1)
		;TO USER AREA STARTING AT R.H. C(AC) OF LENGTH MINUS L.H. C(AC)
;
AGETSYS:	PUSHJ P,UDELAY	;CAUSE A SCHEDULE TO STOP GETSYSER FROM MONOPOLIZING SYSTEM
	MOVSI A,-<GSYS1-GSNAME>	;NEGATIVE OF TABLE LENGTH
	XCTR XR,[MOVE B,1(J)]	;LOOK AT USERS AC+1, THE 6BIT NAME
	CAME B,GSNAME(A)	;CYCLE THROUGH TABLE
	AOBJN A,.-1		;OF NAMES, POINTER IN RIGHT HALF OF A
	JUMPGE A,AGETSL	;JUMP IF NOT IN TABLE
	XCTR XR,[MOVE B,(J)]	;GET POINTER TO USERS RECEPTACLE BLOCK
	HLRZ C,GSYS1(A)	;GET LOW END OF BLOCK
	HRRZS A		;CLEAR COUNT IN L.H. OF A
	CAIGE A,NUTCFN	;SKIP IF UTC OFF NOT REQUIRD
	CONO PI,UTCOFF	;TURN OFF ALL CHANNELS BUT CH 1
	TRNE C,700000	;SKIP IF TABLE ENTRY NOT AN INSTRUCTION
	XCT GSYS1(A)	;EXECUTE THE INSTRUCTION
	HRRZ D,GSYS1(A)	;GET HIGH END OF BLOCK
;AT THIS POINT:		;B USER'S POINTER (UNRELOCATED)
			;C BEGINNING OF AREA IN SYS
			;D END OF AREA
	SUBI D,-1(C)	;BLOCK LENGTH TO BE SENT
	HLRZ E,B	;GET NEG BLK LENGTH FROM USERS PNTR
	ADDI E,-1(D)	;-1 CAUSES CARRY BIT IF .GT.
	TLNE E,-1	;CARRY INDICATES LOSS
	JRST AGETS5	;MORE THAN USER WANTS
	HRLS D		;BLOCK LENGTH IN BOTH HALVES
	HRRZ E,B	;FIRST WORD (UNRELOCATED)
	HRL E,C		;SOURCE ADDRESS FOR BLT
	HRRZ C,E	;DESTINATION INTO C
	ADD C,D		;FINAL ADDRESS +1
AGETS7:	XCTR XWI,[BLT E,-1(C)]	;BLT IT TO HIM
	AOSA (P)		;INCREMENT RETURN, INDICATE SUCCESS
	JRST AGETS6
	CONO PI,UTCON
	ADD B,D
	XCTR XW,[MOVEM B,(J)]	;TELL USER HOW MUCH HE GOT
AGETS4:	POPJ P,

AGETSL:	XCTR XW,[SETZM 1(J)]	;INDICATE BAD SIXBIT
	POPJ P,

AGETS5:	MOVNS D		;TELL USER HOW MUCH HE NEEDS
	CONO PI,UTCON	;NEGATIVE OF RIGHT BLOCK LENGTH
	XCTR XRW,[HRLM D,(J)]	;SET UP PROPER BLOCK LENGTH IN HIS AC
	JRST AGETS4

AGETS6:	CONO PI,CLKOFF
	SPM UPGML(U)
	HLRZ TT,UPGML(U)
	ANDI TT,377
	MOVE I,UPGML+3(U)
	TLNE I,100
	JRST AGTS1	;REAL ILM RETURN NOT SKIPPING
	TRZE TT,200
	SKIPA H,UCPB2(U)
	MOVE H,UCPB1(U)
	ROT TT,-1
	ADD H,TT
	HRLI H,222200
	SKIPGE TT
	HRLI H,2200
	LDB TT,H
	JUMPE TT,AGTS1
	CAIN TT,-1
	JRST AGTS1
	PUSHJ P,TPFLT
	JRST AGETS7

AGTS1:	HRLOI A,2007	;CLEAR ANY BITS THAT MAY HAVE BEEN SET ON FAULT
	ANDM A,UPGML+3(U)
	LPM UPGML(U)
	CONO PI,UTCON
	JRST AGETS4

GSNAME:	SIXBIT /MEMORY/
	SIXBIT /UTAPE/
	SIXBIT /USERS/
	SIXBIT /USER/
	SIXBIT /GETS/
	SIXBIT /DEVS/
	SIXBIT /CALLS/
IFN IMXP,	SIXBIT /IMPX/
	SIXBIT /CLINK/
	SIXBIT /DSYMS/
	SIXBIT /USYMS/	;.UPC, .VAL, .TTY, ETC.
	SIXBIT /CHDEVS/
	SIXBIT /NCALLS/

NUTCFN==2	;NUM OF GETSYS'S WITH UTCOFF

;ENTRIES ARE:   BOTTOM,,TOP  OF AREA TO BE TRANSMITTED OR INST TO EXECUTE
GSYS1:	IOBFTL,,EMEMTL	;4.9 - 4.7 NOT ZERO => XCT THIS ENTRY
	UTCHNT,,UTCHE	;UTAPE
	PUSHJ P,USRSV	;USERS
	PUSHJ P,USR1V	;USER
	GSNAME,,GSYS1-1	;GETS
	DEVTAB,,EDEVS	;DEVS
	SYSYMB,,SYSYME	;CALLS
IFN IMXP,	IMXTBB,,IMXTBE	;IMPX
	CLVBEG,,CLVEND	;CLINK
	PUSHJ P,DSYMS	;DSYMS
	SYSUSB,,SYSUSE	;USYMS
	DCHSTB,,DCHSTE	;CHDEVS
	SYSCTB,,SYSCTD-1	;NCALLS

USRSV:	MOVEI C,USRSTG-LVARS
	MOVE D,USRHI
	ADDI D,USRSTG-1
	JRST POPJ1

USR1V:	XCTR XR,[MOVE C,2(J)]
	IMULI C,LUBLK
	CAML C,USRHI
	JRST USR1VL
	ADDI C,USRSTG
	MOVE D,C
	ADDI D,LUBLK-1
	JRST POPJ1

USR1VL:	SUB P,[1,,1]
	XCTR XRW,[SETOM 2(J)]
	JRST AGETS4

DSYMS:	HRRZ C,774000-2
	HLRE D,774000-2
	SETCMM D	;OFFSET BY ONE
	ADD D,C
	JRST POPJ1

;GET AN ABSOLUTE LOCATION	;.GETSYS AC,	;C(A)=FROM(ABS),,TO(RELATIVE)
;
AGETLOC:	XCTR XR,[MOVE A,(J)]	;GET TO ADDRESS
	HLRZ B,A	;GET FROM ADDRESS
	XCTR XI,[MOVE C,(B)]
	JRST .+2
	JRST ILEXPF	;ILLEGAL EXEC PAGE FAULT
	XCTR XW,[MOVEM C,(A)]	;GIVE TO USER
	POPJ P,

;SET AN ABSOLUTE LOCATION	;.SETLOC AC,	;C(AC)=FROM(RELATIVE),,TO(ABS)
;
ASETLOC:	TDZA D,D	;CLEAR COND FLAG, SKIP

;SET AN ABSOLUTE LOCATION ONLY IF C(ABS)=C(TEST) & SKIP IF SUCCESSFUL
;.IFSET AC,	;C(AC)=<POINTER TO 2 WORD BLOCK>,,TO ADR(ABS)
;WORD 1=TEST	;WORD 2=NEW C(ABS)

AIFSET:	MOVNI D,1	;SET COND FLAG
	XCTR XRW,[HRRZ A,(J)]	;GET TO ADDRESS (ABSOLUTE)
	XCTR XRW,[HLRZ B,(J)]
	PUSHJ P,LDISOW	;ILLEGAL FOR DISOWNED JOBS
	XCTR XR,[MOVE C,(B)]	;GET WORD
	XCTR XI,[MOVES (A)]
	JRST .+2
	JRST ILEXPF
	JUMPE D,ASPST1	;NORMAL SETLOC
	XCTR XR,[MOVE D,1(B)]	;GET NEW VALUE
	CONO PI,CLKOFF	;PREVENT INTERRUPTS
	CAME C,(A)	;CHECK WORD AGAINST TEST WORD
	JRST CLKONJ	;NOT EQUAL => IGNORE
	MOVE C,D
	AOS (P)		;CAUSE RETURN TO SKIP
	CAIG A,SYSB_10.	;CHECK IF IN SYS
	JRST ASPST1	;YES SO DO REG SETLOC
	EXCH D,(A)	;NO SO DO NOW BEFORE SHUFFLE & GET OLD
ASPST2:	MOVE C,D
	HRROS A		;LET SYS JOB KNOW ALREADY DONE
ASPST1:	CAMN C,(A)	;SKIP IF DIFFERENT FROM C(TO ADR)
	JRST CLKONJ	;SAME
	MOVE D,UNAME(U)	;GET UNAME OF SETLOCER
	MOVSI T,4000
	PUSHJ P,CWAIT	;WAIT TILL VARIABLES TO COMMUNICATE WITH SYS JOB ARE FREE
	TDNE T,SUPCOR	;ARG TO CALL IN .-1
	MOVEM A,SETSLC	;REMEMBER ABS LOCATION
	MOVEM C,SETSLQ	; " NEW CONTENTS (OR OLD IF LH(SETSLC)=-1)
	MOVEM D,SETSU	; " USER
	JRST CSPST	;TELL SYS JOB TO DO IT

;LOOK UP ITS SYMBOL	;.EVAL AC,	;C(AC)=SQUOZE SYMBOL
;REPLACES SYMBOL BY VALUE & SKIPS IF SUCCESSFUL

AEVAL:	PUSHJ P,SWTL
	ARDFSW
	XCTR XR,[MOVE B,(J)]	;GET SYM
	PUSHJ P,SYMLK	;LOOK UP
	JRST LSWPOP		;NOT FOUND
	MOVE A,(C)	;GET VALUE
	PUSHJ P,LSWPOP
	AOS (P)		;CAUSE UUO TO SKIP
	JRST APTUAJ	;RETURN VALUE

;REDEFINE ITS SYMBOL	;.REDEF AC,	;C(AC)=POINTER TO 2 WORD BLOCK
;WORD 1 = SYMBOL	;WORD 2 = VALUE
;DELETE SYM IF ALL 4 FLAG BITS SET
;ADD SYM IF NOT FOUND	;FAIL ONLY IF NOT ENOUGH ROOM
;SKIPS IF SUCCESSFUL

AREDEF:	PUSHJ P,LDISOW	;ILLEGAL IF DISOWNED
	PUSHJ P,SWTL
	 ARDFSW
	XCTR XRW,[HRRZ D,(J)]	;GET POINTER FROM AC
	XCTR XR,[MOVE B,(D)]	;GET SYMBOL
	PUSHJ P,SYMLK	;LOOK UP
	JRST ARDF2	;NOT FOUND, CREATE
	XCTR XRW,[SETCM A,(D)]	;GET SYM (COMPLEMENTED)
	TLNN A,740000	;SKIP IF ANY FLAGS NOT SET
	JRST ARDF3	;ALL SET => DELETE
	XCTR XR,[MOVE A,1(D)]	;GET VALUE
	MOVEM A,(C)	;STORE IN SYMTAB
	JRST ARDF4	;SORT AND SKIP-RETURN.

ARDF2:	MOVE C,DDT-2	;GET POINTER
	SUB C,[2,,2]	;DECREMENT FOR NEW ENTRY
	MOVEI A,-1(C)	;FUDGE FOR BLOCK CALC
	LSH A,-10.	;CONVERT TO # OF BLOCKS UP TO SYMTAB -1
	XCTR XR,[MOVE B,(D)]	;GET SYM
	TLNE B,740000	;LOSE IF PROG NAME
	CAILE A,LDDTADR	;CHECK FOR LOSSAGE
	 JRST LSWPOP	;DON'T OVERWRITE TS
	EXCH B,2(C)	;STORE OVER GLOBAL BLOCK HEADER,
	MOVEM B,(C)	;MOVE THAT HEADER DOWN 2 WDS.
	XCTR XR,[MOVE A,1(D)]	;GET VALUE
	EXCH A,3(C)
	ADD A,[-2,,]	;1 MORE SYM IN GLOBAL BLOCK.
	MOVEM A,1(C)	;STORE
	MOVEM C,DDT-2	;UPDATE POINTER
	JRST ARDF4	;GO SORT AND SKIP-RETURN.

ARDF3:	MOVE B,DDT-2	;GET POINTER
	MOVE A,(B)	;MOVE THE GLOBAL HEADER
	EXCH A,2(B)	;UP OVER 1ST SYM
	MOVEM A,-1(C)	;WHICH GOES INTO FREE SLOT.
	MOVE A,1(B)
	ADD A,[2,,]	;GLOBAL BLOCK 1 SYM SHORTER.
	EXCH A,3(B)
	MOVEM A,(C)
	MOVE A,[2,,2]
	ADDM A,DDT-2	;UPDATE POINTER
ARDF4:	HRROS DDT-1
	PUSHJ P,SBUBL	;DO 1 BUBBLE-SORT UP AND 1 DOWN.
	JRST LSWPJ1	;FREE ARDFSW AND EXIT.

EBLK
ARDFSW:	-1 ? 0
BBLK

;DO ONE BUBBLE SORT PASS UP, ONE DOWN; LEAVE J <0 IFF DID AN EXCHANGE.
;CLOBBER A-E.
SBUBL:	MOVE E,DDT-2
	HLL E,1(E)
	ADD E,[2,,2]	;AOBJN -> SYMS IN GLOBAL BLOCK.
	SETZ J,
	MOVE B,[2,,2]	;INCREMENT FOR UPWARD PASS.
	MOVE C,[JUMPL A,SBUBL1]
	SUBI E,2	;(WILL INCREMENT BEFORE ACTING)
	MOVE A,E
	PUSHJ P,SBUBL2
	MOVNS B	;DECREMENT FOR DOWNWARD PASS.
	MOVE C,[CAMN A,E]
	JRST SBUBL2

SBUBL1:	MOVE D,1(A)	;CHECK NEXT PAIR OF ENTRIES.
	CAMG D,3(A)
	 JRST SBUBL2	;IN CORRECT ORDER.
	EXCH D,3(A)
	MOVEM D,1(A)	;WRONG ORDER, EXCHANGE.
	MOVE D,(A)
	EXCH D,2(A)
	MOVEM D,(A)
	SETO J,		;SAY DID AN EXCHANGE.
SBUBL2:	ADD A,B		;MOVE TO NEXT ENTRY.
	XCT C		;TEST IF FINISHED.
	 POPJ P,
	JRST SBUBL1	;(NOT FINISHED)


;LOOK UP SYMBOL IN B IN ITS SYMBOL TABLE (CLOBBERS A,B,C)
;RETURN WITH POINTER TO VALUE WORD IN C
;SKIPS IF SUCCESSFUL

SYMLK:	TLZ B,740000	;FLUSH FLAGS
	MOVE C,774000-2	;PICK UP AOBJN POINTER TO SYMTAB FROM EXEC DDT
SYMLK2:	MOVE A,(C)	;GET SYM
	AOBJP C,[JRST 4,.+1]	;INCREMENT POINTER
	TLNE C,376	;GO THROUGH HAIR EVERY 200 SYMS
	JRST SYMLK3	;NOT THIS TIME
	PUSHJ P,OPBRK
SYMLK3:	TLNN A,200000	;SKIP IF DELETE INPUT (FLAG PREVENTS MATCH)
	TLZE A,740000	;FLUSH FLAGS & CAUSE LOSS IF ALL 0 (PROG NAME)
	CAME A,B	;COMPARE
	AOBJN C,SYMLK2	;LOSS, TRY ANOTHER
	JUMPL C,POPJ1	;SKIP RETURN IF FOUND
	POPJ P,		;NOT SO IF LOSS

AWSNAME:	XCTR XRW,[SKIPE B,(J)]	;OPER 35
	MOVEM B,USYSNM(U)
	POPJ P,

AUPISET:	XCTR XR,[MOVE B,(J)]	;OPER 36
	ASH B,-35.
	EXCH B,PICLR(U)
	XCTR XW,[MOVEM B,(J)]
	SKIPN PICLR(U)
	POPJ P,
	JRST APISE1

;GENERATE A UNIQUE SYM 	;.GENSYM AC,	;LOADS AC WITH SYM
;
AGENSYM:	PUSHJ P,SWTL	;WAIT TILL INTERLOCK FREE THEN SEIZE IT
	GENSSW
	MOVEI TT,IGNSYM
	PUSHJ P,SIXAOS	;INCREMENT SYM
	MOVE A,IGNSYM	;GET SYM
	PUSHJ P,LSWPOP	;UNLOCK FOR NEXT USER
	JRST APTUAJ	;GIVE USER GENERATED SYMBOL

EBLK

GENSSW:	-1
	0
IGNSYM:	SIXBIT /SYS/

BBLK

SIXAOS:	PUSH P,I
	PUSH P,J
	AOS (TT)	;INCREMENT SYM
	MOVE I,[440600,,(TT)]	;GET POINTER TO FIRST CHAR
SIXAS2:	ILDB J,I	;GET FIRST (NEXT) CHAR
	SKIPN J		;SKIP IF NOT ZERO
	MOVEI J,1	;REPLACE EMBEDDED SPACE WITH !
	DPB J,I		;PUT BACK
	CAME I,[60600,,(TT)]	;SKIP IF FIRST FIVE CHARS HAVE BEEN EXAMINED
	JRST SIXAS2	;GO TO NEXT CHAR
	POP P,J
	POP P,I
	POPJ P,
;
; CORE ALLOCATOR
;  USER ROUTINES (TO COMMUNICATE WITH CORE JOB)
;
UACORE:	;U HAS INDEX CORE REQUEST IS FOR
ACORE:	PUSHJ P,ACRTST
	POPJ P,
	MOVE Q,U	;USER TO MAKE CORE FOR
	PUSH P,U
	MOVE U,USER
	JUMPE B,[AOJA B,ACRF2]
ACRF2:	PUSHJ P,ACRF1
	SKIPA
	AOS -1(P)
	POP P,U
	POPJ P,

;EXCESSIVE CORE REQUEST CHECK
ACRTST:	CAILE B,400
	POPJ P,
	JRST POPJ1
;CORTYP SYSTEM CALL.
;IF 2 ARGS,1ST ARG IS JOB SPEC, LIKE CORBLK'S 2ND AND 4TH ARGS.
;2ND ARG IS PAGE NUMBER IN THAT JOB.
;IF ONLY 1 ARG, IT IS THE PAGE NUMBER IN THE EXECUTING JOB.
;RETURNED VALUES:
;1ST VALUE BIT 4.9 => PAGE IS WRITEABLE, 4.8 => PAGE EXISTS.
;	FOR NON EX PAGE, ALL THE REST ARE 0.
;2ND IS 0 => PAGE IS ABSOLUTE, -1 => UNSHARED,
;	ELSE IS JOB NUMBER OF NEXT JOB IN CIRCULAR LIST.
;3RD IF ABSOLUTE PAGE, HAS PAGE NUMBER.
;	IF PAGE IS SHARED, HAS PAGE NUMBER IN THE JOB
;	WHOSE NUMBER IS THE 2ND VALUE. ELSE, 0.
;4TH BIT 4.9 => PAGE IS IN CORE.
;    BIT 4.8 => PAGE IS PUBLIC.
;    RH IS NUMBER OF TIMES PAGE IS SHARED
;	(WILL BE 0 FOR ABS PAGE OR IF NO PAGE,
;	 OTHERWISE WILL BE >= 1)

NCORTY:	PUSHJ P,SWTL	;DON'T LET PAGE MAPS CHANGE.
	CIRPSW
	SOSG W		;IF 1 ARG, USE -1 (SELF) FOR JOB SPEC.
	SKIPA B,[-1]
	EXCH A,B	;ELSE 1ST ARG IS JOB SPEC.
	MOVE J,B
	JSP T,NCORUI	;DECODE THE JOB SPEC IN J,
	 JFCL		;RETURNS USR IDX IN J.
	TDNE A,[-400]
	 JRST OPNL33	;BAD PAGE NUM.
	PUSHJ P,NCORT0	;DO THE ACTUAL WORK.
	PUSHJ P,LSWPOP	;UNLOCK CIRPSW,
	JRST SYSCPS	;GIVE VALUES TO USER, SKIP.

;CALL HERE FROM AUSET5  (ALWAYS COMEW WITH CIRPSW LOCKED)
NCORT0:	PUSH P,U
	MOVEI U,(J)	;UPLC USES USER IN U.
	PUSHJ P,UPLC	;NOTE PAGE NUM IS IN A.
	LDB J,T		;GET PAGE'S HARDWARE HALFWD,
	LDB C,Q		;GET CIRC. LIST POINTER.
	JUMPE C,NCORTE	;J IF NO PAGE THERE.
	MOVEI A,(J)
	TRNE A,600000	;GET ACCESS INTO A 1.1-1.2
	LDB A,[200200,,A]
	CAIN A,2	;CHANGE READ-WRITE-FIRST TO READ-WRITE.
	 MOVEI A,3
	ROT A,-2	;SHIFT INTO 4.8-4.9
	CAIN C,-1
	 JRST NCORTA	;J IF ABSOLUTE PAGE(CIRC PTR -1)
	PUSHJ P,CHACK	;PG MUST HAVE REAL CIRC LIST, TRACE IT.
	EXCH C,D	;D HAD MMP IDX; C HAD IN-CORE,,LIST LENGTH.
	ADD C,MMPEAD
	SKIPGE (C)	;PUBLICNESS BIT IS SIGN OF MMP ENTRY.
	 TLO D,200000	;PUT INTO 4TH ARG BIT 2.8 .
	SUBI D,1	;LIST LENGTH COUNTS THE MMP ENTRY,
	SKIPGE D
	SUBI D,1	;COUNTS THE MEMBLT ENTRY IF PAGE IN CORE.
	TRNN D,-2	;RH NOW HAS # SHARERS,
	 JRST NCORTS	;ONLY 1 => PAGE NOT SHARED.
	MOVE C,Q
	MOVE B,P
	PUSHJ P,UCPRL	;>1 SHARER => FIND NEXT SHARER,
	 400000,,.+1
	MOVE P,B	;UN-SCREW STACK (UCPRL PUSHJ'D BACK)
	LDB B,[101100,,T]
	MOVE C,I	;2ND, 3RD VALUES USR NUM & PAGE NUM
	JRST POPUJ	;OF THE NEXT SHARER.

;COME HERE IF NO PAGE WITH THAT PAGE NUM.
NCORTE:	SETZB A,B
	SETZB C,D	;RETURN ALL ZEROS.
	JRST POPUJ

;COME HERE IF ABS PAGE, ACCESS ALREADY IN A.
NCORTA:	SETZB B,D	;JOB # 0 (SYS JOB) FOR ABS PAGE.
	LDB C,[2000,,J]	;GET ABS PAGE NUM FROM HARDWARE HALFWD.
	JRST POPUJ

;COME HERE IF UNSHARED NORMAL PAGE.
;ACCESS ALREADY IN A, 4TH VALUE IN D.
NCORTS:	SETO B,		;2ND VALUE -1 FOR UNSHARED.
	SETZ C,
	JRST POPUJ

;CORBLK CALL
;1ST ARG FLAG BITS: (RH XOR'D INTO LH BEFORE DECODING)
; 4.9 GET WRITE ACCESS IF OK, DON'T FAIL IF NOT.
; 4.8 GET READ ACCESS
; 4.7 GET WRITE ACCESS, FAIL IF CAN'T.
; 4.6 MAKE PAGE PUBLIC
; 4.5 MAKE IT PRIVATE (BOTH FAIL IF COULDN'T GET WRITE ACCESS)
; 4.4 FAIL IF CAN'T GET READ ACCESS.(COPYING NONEXISTANT PAGE)
;IF ALL 0, DELETE.
;2ND ARG SPECIFIES JOB TO PUT PAGE IN
;   IS EITHER CHNL NUM, -1 FOR SELF, OR 400000+USRNUM
;JOB SPECIFIED MUST BE CURRENT JOB OR INFERIOR.
;3RD ARG RH. IS PAGE NUM. IN IT.
; LH. IF NEGATIVE, BLOCK MODE, REPEAT THAT MANY TIMES,
;   INCREMENTING BOTH PAGE NUMS EACH TIME.
;IN BLOCK MODE, REWRITES 3RD AND 5TH ARGS EACH TIME.
;4TH ARG IS SOURCE OF PAGE,
;   EITHER 0,,-1 OR -1 FOR SELF, CHNL NUM, 400000+USRNUM
;   400000 FOR ABS PAGE (SYS JOB),
;   400377 FOR SUPERIOR,
;   OR 400001 FOR FRESH PAGE (CORE JOB).
;   OR DSK CHNL GET NTH PG IN FILE
;IF NO 4TH ARG, SAME AS 2ND
;5TH ARG IS PAGE NUM IN SOURCE (IGNORED FOR FRESH PAGE)
;IF NO 5TH ARG, SAME AS 3RD.

NCORBL:	TSC A,CTLBTS(U)
	TLC A,(A)	;WIN FOR IMMEDIATE FIRST ARG
	HRRZM C,SRN3(U)	;SAVE PTRS TO 3RD, 5TH ARGS.
	TLNE C,1000
	TLZA C,-1
	XCTR XR,[MOVE C,(C)]
	SKIPGE C	;IF WILL REWRITE,CHECK FOR PURE
	XCTR XRW,[MOVES @SRN3(U)]
	HRRZM E,SRN4(U)
	CAIGE W,5	;BUT IF NO 5TH ARG, SAY SO & USE 3RD.
	JRST NCORB1	;DEFAULT E TO C,SETZM SRN4
	TLNN E,1000	;IMMEDIATE 5TH ARG LEGAL
	JRST NCORB8
	JUMPGE C,NCORB7	;ONLY IF WON'T HAVE TO REWRITE IT
	JRST OPNL33

NCORB8:	XCTR XR,[MOVE E,(E)]
	SKIPGE C
	XCTR XRW,[MOVES @SRN4(U)]
NCORB7:	ANDI E,-1
	MOVE J,B
	JSP T,NCORUI	;GET USER INDEX OF TARGET.
	JRST NCORB0	;IF DOESN'T SKIP, CAN CERTAINLY WRITE.
	CAIE J,-1	;CAN'T STICK PAGE IN 6.
	JSP T,NCORWR	;ELSE CHECK.
	 JRST OPNL31	;CANT WRITE SO CANT STICK PAGE IN
NCORB0:	MOVEI TT,(J)	;SAVE DEST. USER IDX.
	PUSH P,A
	MOVEI A,(TT)	;IF NOT ACTING ON SELF, PCLSR TARGET JOB.
	CAIN A,(U)
	JRST NCORB9
	PUSHJ P,RPCLSR
	MOVEM A,SRN5(U)
	MOVSI T,BSSTP	;BUT LEAVE BSSTP SET INSTEAD OF RH
	IORM T,USTP(A)
	SOS USTP(A)	;BECAUSE CORE JOB WANTS RH TO BE CLEAR
	PUSHJ P,LOSSET	;UNDO SETTING OF BSSTP IF WE PCLSR OR FAIL
	[PUSHJ P,NCORFS
	JRST URET]
NCORB9:	POP P,A
	PUSHJ P,SWTL
	CIRPSW
	TLNE A,100000	;FORCE WRITE => WRITE.
	TLO A,400000
	TLNE A,770000	;CHECK FOR DELETE.
	TLOA A,200000	;IF NOT DELETE, TURN ON READ.
	JRST NCORD
	CAIGE W,4	;IF HAD 4TH ARG, DECODE,
	JRST NCORB2	;ELSE USE DECODED 2ND (STILL IN J).
	MOVE J,D
	JSP T,NCORUI	;GET SOURCE USR IDX (CHANGE TO NCRUI1 WHEN GET PAGE IN FILE COMPLETE)
	JRST NCORB2
	JRST NCORC0
	MOVE R,J	;DISK CHNL
	TLO R,200000	;INDICATE DISK CHNL
	CAIGE W,5
	JRST NCORL
	LSH E,10.	;5TH ARG GIVES PAGE ADDRESS IN FILE FOR DISK CHNL
	HRRZS E
	EXCH E,QRADAD(R)
	MOVSI J,100
	CAME E,QRADAD(R)
	IORM J,QSRAC(R)
	JRST NCORL

NCORC0:	TLNN A,560000	;IF REQ ALTERATION,
	JRST NCORB2
	JSP T,NCORW1	;IF CAN'T WRITE THAT JOB,
	HRLI J,400000	;SET FLAG TO CHECK FOR PUBLIC.
NCORB2:	MOVE R,J
	CAIN R,LUBLK	;FRESH PAGE IMPLIES WRITING
	TLO A,400000

;DROPS THRU

;DROPS IN

;NOW HAVE TARGET IDX IN TT, SOURCE IN R.
;TARGET PAGNUM IN C; SOURCE IN E (MAYBE INVALID).
;R 4.9 => WRITE REQUIRES PUBLIC PAGE.
;R 4.8 R HAS DISK CHNL
;DECIDE WHAT KIND PAGE WANTED AND FIND IT.
NCORL:	MOVEI I,(R)	;I WILL HAVE USR IDX FOR ACTUAL PAGE.
	HLRS A		;RH OF A WILL GET ACCESS TO BE GRANTED.
	TRNE C,-400	;CHECK DEST PAGE NUM IN RANGE.
	JRST NCORX0
	PUSH P,U
	PUSH P,C
	TLNE R,200000
	JRST NCORQ1	;DISK FILE
IFN PDP6P,[
	CAIN R,-1
	JRST NCORE4	;-1 => PDP6 PAGE.
]
	CAIN R,LUBLK
	JRST NCORF0	;JOB 1 => FRESH PAGE.
	JUMPE I,NCORE1	;JOB 0 => WANT ABS PAGE.
	CAIL E,400
	JRST NCORE7	;ELSE SOURCE PAGNUM MUST BE < 400
	MOVEI U,(R)
NCORF2:	EXCH E,A	;GET SOURCE PAGNUM IN A
	PUSHJ P,UPLC;(A,U)	;FIND THE PAGE WANTED.
	EXCH E,A
	LDB J,Q		;UPLC RETURNS IN T,Q.
	JUMPE J,NCORE6	;FAIL OR DELETE IF HE HAS NO PAGE THERE.
	CAIN J,-1
	JRST NCORE5	;IF THAT PAGE IS ABS,CHANGE TO ABS REQ.
	PUSHJ P,CHACK	;A REAL PAGE, FIND MMP, PREV. PTR.
	ADD D,MMPEAD
	MOVE B,Q
	MOVEI I,(R)	;CHACK CLOBBERS I
	TLNN A,560000	;IF WANTED ALTERATION, CHECK LEGAL.
	JRST NCORB3
	LDB J,T		;1ST OF ALL, SOURCE MUST HAVE WRITE PERM.
	TRNN J,600000
	JRST NCORB4
	TRNN J,400000
	JRST NCORB5
	JRST NCORB6

NCORB4:	TRNN J,2
	JRST NCORB5
NCORB6:	CAIN R,LUBLK
	JRST NCORF3
NCORF4:	MOVE J,(D)	; HE HAS WRITE PERM.; GET MMP IN J.
	TLNE R,400000	; CAN'T ALTER IF NEEDED PUBLIC BUT IT ISN'T.
	JUMPGE J,NCORB5
	TLNE A,40000	;WE CAN ALTER; CHANGE PUBLIC IF REQ.
	TLO J,400000
	TLNE A,20000
	TLZ J,400000
	MOVEM J,(D)
	JRST NCORB3


NCORF0:	MOVEI U,(TT)
	MOVEI E,(C)
	JRST NCORF2

NCORF3:	CAIE C,2
	CAMN C,[SETZ 3]
	JRST .+2
	JRST NCORD0	;SHARED PAGE CAN'T SERVE AS FRESH PAGE
	MOVEI I,(TT)
	JRST NCORF4

;COME HERE IF REQ WRITE ON REAL PAGE BUT CAN'T GRANT.
NCORB5:	CAIN R,LUBLK
	JRST NCORD0
	TLNE A,160000	;IF HE INSISTED, FAIL.
	JRST NCORE0
	TRZ A,400000	;ELSE GIVE HIM ONLY READ PERM.
;COME HERE IF PAGE EXISTS TO GIVE ACCESS AS IN A 2.8,2.9
NCORB3:	HRRZ J,(P)
	CAIN TT,(I)	;ARE WE REPLACING PAGE BY ITSELF?
	CAME E,J
	JRST NCORD0	;NO, DELETE OLD, INSERT NEW.
	LDB J,T		;REPLACING PG W/ SELF, SET ACCESS & EXIT.
	TRNN J,600000
	JRST NCORI1
	TRNN J,400000	;CHANGE READ TO RWF
	TRC J,600000
	TRNE A,400000
	JRST NCORI2
	MOVSI I,40000
	TROE J,200000
	ANDCAM I,(D)
	TRZ J,400000
	JRST NCORI2

NCORI1:	MOVEI J,1
	TRNE A,400000
	TRO J,2
NCORI2:	DPB J,T
	POP P,C
	POP P,U
	JRST NCORX	;TO END OF LOOP.


NCORQ1:	JRST 4,.
;	MOVSI J,100
;	TDNN J,QSRAC(R)
;	JRST NCORQ2	;POINTING TO RIGHT BLOCK
;	PUSH P,A
;	PUSH P,TT
;	PUSH P,R
;	HRRZ A,T
;	PUSHJ P,QBRRA1
;	POP P,R
;	POP P,TT
;	POP P,A
;	MOVSI J,100
;	TDNE J,QSRAC(R)
;	JRST NCORQ2	;OFF EOF
;

NCORE6:	CAIN R,LUBLK	;COPY NONEXISTANT PAGE
	JRST NCORD0
	HRRI A,0	;CHANGE TO DELETE RQ.
	TLNN A,170000	;IF INSIST ON ACCESS, FAIL.
	JRST NCORD0
NCORE0:	PUSHJ P,OPNL32	;CAN'T GRANT ACCESS OPNL.
POPCUJ:	POP P,C		;FAIL OUT OF CALL.
	JRST POPUJ

IFN PDP6P,[
;REQ FOR PDP6 PAGE.
NCORE4:	CAIL E,16.
	JRST NCORE7	;OUT OF RANGE.
	MOVEI B,PDP6BM_<-10.>(E)
	JRST NCORE2	;CONVERT TO ABS REQ.
]

;REQ FOR ABS PAGE.
NCORE1:	MOVEI B,(E)
	CAIGE B,400
	JRST NCORE2	;CHECK IF OK TO WRITE.
NCORE7:	PUSHJ P,OPNL33	;BAD ARG OPNL.
	JRST POPCUJ

;PAGE TO COPY WAS AN ABS PAGE.
NCORE5:	CAIN R,LUBLK
	JRST NCORD0
	LDB B,T		;GET ABS PAGE NUM.
	TRZE B,400000	;IF HE HASN'T WRITE PERM.
NCORE2:	JUMPGE R,NCORE3	;OR WE CAN'T WRITE IN HIM,
	TRZ A,400000	;CAN'T GET WRITE,
	TLNN A,160000	;FAIL IF INSIST.
NCORE3:	TLNE A,60000	;OR IF TRYING TO CHANGE PUBLICNESS.
	JRST NCORE0
	MOVEI I,0		;INDICATE ABS REQ.
	JRST NCORD0

;COME HERE ON DELETE REQ.
NCORD:	PUSH P,U
	PUSH P,C
NCORD0:	PUSH P,A	;COME IN HERE ON VALID INSERT RQ.
NCORD1:	MOVE U,TT
	HRRZ A,-1(P)
	PUSH P,T
	PUSH P,B
	PUSHJ P,PAGERT
	POP P,B
	POP P,T
	POP P,A		;FLAG WORD
	POP P,C		;TARGET PAGNUM
	POP P,U
	TRNN A,600000	;IF NO ACCESS REQ, IS DELETE, THRU.
	JRST NCORX
;RH. OF A HAS ACCESS TO GRANT.
;IF I=0, ABS PAGE, NUM. IN B.
;IF I=LUBLK, FRESH PAGE.
;IF 4.8 SET, DISK PAGE POINTED TO BY CHNL IN I
;ELSE OLD PAGE, B IS BP -> CIRC LIST, T -> OLD ACCESS.
	PUSH P,C
	PUSH P,E
	PUSH P,TT
	PUSH P,A
	JUMPE I,NCORA
	CAIE I,LUBLK
	JRST NCORR	;GO INSERT REAL PAGE.
	LSH C,9		;INSERT FRESH PAGE.
	MOVEI Q,(TT)	;TARGET JOB
	IDIVI TT,LUBLK	;CLOBBERS I.
	IORI TT,400000(C)
	HRLI TT,204000
	TLNE A,40000	;MAYBE RQ PUBLIC
	TLO TT,1000
	PUSH P,R
	PUSHJ P,NACRFL
	JRST NCORF1
	POP P,R
	PUSHJ P,SWTL
	CIRPSW
	HRRZ E,-3(P)	;GET TARGET PAGE NUM
	JRST NCORR2

NCORF1:	SUB P,[5,,5]
	JRST OPNL37	;NO CORE OPNL.

NCORA:	MOVEI A,(C)
	MOVE U,TT	;INSERT ABS PAGE.
	PUSHJ P,UPLC	;FIND TARGET PAGE
	IOR B,(P)		;COMBINE ACCESS W/ PAGE NUM.
	TRZ B,177000
	LDB D,T
	JUMPN D,[JRST 4,.]	;SHOULD HAVE DELETED PAGE ALREADY
	DPB B,T
	MOVNI B,1	;CIRC. PTR. IS -1.
	DPB B,Q
	MOVEI E,(A)
	JRST NCORR2

NCORR:	MOVEI E,(C)	;TARGET PAGE #
	MOVEI U,(TT)	;TARGET JOB
	MOVSI TT,(A)
	LSH TT,-9
	PUSHJ P,NCORR1	;PUT WR RQ IN 400 BIT OF TT
NCORR2:	PUSHJ P,GHUSRA	;TARGET PAGE NUM MUST BE IN E
	POP P,A
	POP P,TT
NCORA1:	POP P,E
	POP P,C
;COME HERE AFTER HANDLING 1 PAGE.
NCORX:	MOVE U,USER
	LPMR UPGML(U)
	JUMPGE C,NCORX1	;IF RH POS, DON'T REWRITE.
	ADD C,[1,,1]
	AOJ E,
	XCTR XW,[MOVEM C,@SRN3(U)]
	SKIPL SRN4(U)	;REWRITE 5TH ARG ONLY IF WAS GIVEN.
	XCTR XW,[MOVEM E,@SRN4(U)]
	JUMPGE C,NCORX1
	TLNN A,200000
	JRST NCORD	;LOOP AROUND FOR DELETE RQ
	JRST NCORL	;FOR INSERT RQ.

NCORX1:	AOS (P)
NCORX0:	PUSHJ P,LSWPOP	;FREE CIRPSW
NCORX2:	CAIN TT,(U)	;IF NOT ACTING ON SELF,
	POPJ P,
	PUSHJ P,LSWDEL
NCORFS:	MOVE U,USER	;TURN OFF USTP BIT (FINSET PUSHJ'S HERE)
	MOVE TT,SRN5(U)
	MOVSI T,BSSTP
	ANDCAM T,USTP(TT)
	POPJ P,

NCORB1:	SETOM SRN4(U)
	MOVE E,C
	JRST NCORB7
;JSP T,NCORUI   WITH JOB-SPEC IN J,
;RETURNS USER IDX IN J (OR ,,-1 FOR PDP6)

;JOB SPECS ARE:
;  -1  OR  ,,-1    FOR SELF.
;  <CHNL-NUM>	   (MUST BE USR, JOB OR BOJ DEVICE ELSE OPNL34)
;  400000+<USR NUM>  JOB WITH THAT NUMBER (OPNL35 IF NONE)
;   (  -1,,<USR NUM>  ALSO WORKS)

;IF THIS JOB IS CERTAINLY ALLOWED TO MODIFY SPEC'D JOB,
; DOESN'T SKIP.  IF SKIPS, MUST CHECK FARTHER.
NCRUI1:	TLOA T,400000	;ENTRY FOR DISK CHNLS OK (SKIP TWICE IF SO)
NCORUI:	TLZ T,400000	;DISK CHNLS NOT OK
	TRZE J,400000
	HRLI J,-1
	JUMPL J,NCORU1
	CAIL J,20	;>0 => CHNL NUM.
	JRST OPNL14
	ADDI J,IOCHNM(U)
	MOVE H,(J)
	HLRZ J,H
	SKIPGE H,CLSTB(H)
	JRST (T)	;IF INFERIOR, CAN WRITE.
	TLNE H,4000	;OR IF BOJ DEVICE
	 JRST [HRRZ J,JBCUI(J) ? JRST (T)]
	TLNE H,100040	;OR IF JOB DEVICE.
	 JRST [HRRZ J,JBCJUI(J) ? JRST (T)]
	TLNE H,1000	;FOREIGN USR, MUST CHECK.
	JRST 1(T)
	TLNN H,100
	JRST NCRUI2	;RANDOM DEVICE. (MAYBE DISK)
IFN PDP6P,[
	MOVEI J,-1	;PDP6, MUST CHECK.
	JRST 1(T)
]
IFE PDP6P,	JRST 4,.	;THERE IS NO PDP6

NCRUI2:	TLNN H,200
	JUMPL T,2(T)	;DISK CHNL, SKIP TWICE IF THATS OK
	JRST OPNL34

NCORU1:	TRNE J,777400	;CHECK FOR -1 FOR SELF.
	JRST NCORU2
	ANDI J,377
	CAIN J,377	;CHECK FOR 377 => SUPERIOR.
	JRST NCORU3
	IMULI J,LUBLK	;ELSE WAS USRNUM,
	SKIPE UNAME(J)
	CAML J,USRHI	;CHECK FOR VALID USER
	JRST OPNL35	;IF NOT, NO SUCH JOB.
	JRST 1(T)

NCORU2:	CAME J,[-1,,377777]
	JRST OPNL33
	MOVEI J,(U)
	JRST (T)	;CAN WRITE IN SELF.

NCORU3:	SKIPGE J,SUPPRO(U)	;GET SUPERIOR,
	JRST OPNL35
	MOVEI J,(J)
	JRST 1(T)

NCORW1:	CAIE J,LUBLK	;CAN GET WRITE ACCESS TO FRESH PAGE,
	CAIN J,-1	;TO PDP6.
	JRST 1(T)
NCORWR:	CAIN J,(U)	;CAN DO THAT AND STICK PAGE IN SELF
	JRST 1(T)
	HRRZ H,SUPPRO(J)
	CAIN U,(H)	;AND OUR INFERIORS
	JRST 1(T)
	SKIPGE H,JBI(J)	;AND OUR JOB-DEVICE,
	 JRST NCORW2
	CAIN U,JBCUI(H)
	 JRST 1(T)
NCORW2:	SKIPL H,JBI(U)	;AND OUR BOJ DEVICE.
	CAIE J,JBCUI(H)
	 JRST (T)
	JRST 1(T)
;NEW .CBLK CODE, PASSES THE BUCK TO CORBLK.
;SAME AS FAR AS CALLER IS CONCERNED.

ACBLK:	MOVE TT,U	;TARGET USR IDX.
	XCTR XR,[MOVE B,(J)]
NCBLK0:	MOVEI W,5	;FAKE 5 ARGS TO NCORBL
	LDB C,[111000,,B]	;TARGET PAGNUM.
	LDB E,[1100,,B]	;SOURCE PAGNUM.
	TRNN B,400000
	 JRST NCBLKD	;LIKELY TO BE DELETE RQ.
NCBLK1:	MOVSI A,210000	;NOT DELETE => RQ READ, FAIL IF CAN'T.
	LDB D,[221000,,B]	;SOURCE USR IDX OR CHNL NUM.
	LDB H,[330300,,B]	;REQUEST TYPE-CODE.
	JRST .+1(H)

	JRST NCBLKS	;TYPE 0, SOURCE IS SELF.
	JRST NCBLKA	;TYPE 1, GET ABS PAGE.
	JRST NCBLKC	;2, USE SPEC'D CHNL NUM.
	JRST NCBLKI	;3, USE SPEC'D USR IDX.
	JRST NCBLKF	;4, FRESH PAGE.
	JRST NCBLKP	;5, FRESH PUBLIC PAGE.
	TLOA A,420000	;6, MAKE PRIVATE, SOURCE=TARGET.
	TLO A,440000	;7, MAKE PUBLIC,    "      "
	MOVE E,C	;SOURCE PAGNUM _ TARGET PAGNUM,
NCBLKS:	SETO D,		;GET PAGE FROM SELF.
;IF GET-FROM-CHANNEL, THE CHNL NUM IN D IS DESIRED JOB-SPEC.
NCBLKC:	TLNE B,400	;IF WRITE-RQ BIT ON,
	 TLO A,100000	;INSIST ON WRITE ACCESS.
NCORBX:	CAIE TT,(U)	;IF TARGET .NE. SELF,
	 PUSHJ P,NULSET	 ;FAKE OUT THOSE EXPECTING A LOSSET.
	PUSH P,A
	JRST NCORB9

NCBLKA:	SETZ D,		;GET ABS PAGE => LIKE GET FROM USR 0.
NCBLKI:	IORI D,400000	;GET FROM USR IDX, MAKE JOB SPEC.
	JRST NCBLKC

NCBLKP:	TLO A,40000	;GET FRESH PUBLIC PAGE.
NCBLKF:	MOVEI D,400001	;GET PAGEFRESH PAGE => FROM CORE JOB.
	JRST NCBLKC

NCBLKD:	TLC B,6000	;COME HERE IF BIT 2.9 IS 0
	TLCN B,6000
	 JRST NCBLK1	;(TYPES 6,7 IGNORE THAT BIT)
	SETZB A,B	;OTHERWISE IS DELETE REQUEST.
	JRST NCBLKS

NCBLK:	MOVE B,TT
	MOVE TT,Q
	JRST NCBLK0

;.CBLK AC,
	;AC 4.9 MUST BE ZERO
	;4.7 USED INTERNALLY IN CODE (W RQ ON PDP6)
	;4.3-4.1 = 0 GET PAGE FROM SELF
	;	= 1 GET ABSOLUTE PAGE
	;	= 2 GET PAGE FROM USER OPEN ON CH # 3.1-3.8
	;	= 3 GET PAGE FROM USER NUMBER 3.1-3.8
	;	= 4 GET PAGE
	;	= 5 GET PAGE (PUBLIC)
	;	= 6 MAKE PAGE PRIVATE
	;	= 7 MAKE PAGE PUBLIC
	;3.9=1 REQUEST WRITE PERMISSION (IGNORED ON FRESH PAGE, OTHERWISE VALID ONLY FOR
	;		SELF OR DIRECT INFERIOR OPEN ON CH OR PUBLIC PAGE)
	;3.1-3.8  USER NUMBER OR CH # (377 => CREATOR IF JOB DEVICE)
	;2.9=1 INSERT PAGE, 0 DELETE (IGNORES 4.3-4.1 EXCEPT FOR 6 OR 7 WHEN IT IS IGNORED)
	;2.1-2.8 VIRTUAL PAGE TO BE AFFECTED
	;1.1-1.9 BLOCK # IN ABSOLUTE OR OTHER USER (OR SELF IF 4.3-4.1 = 0)

;TO CALL NCBLK, SET UP Q WITH USER INDEX REQUEST IS FOR AND U WITH
;THE USER INDEX MAKING THE REQUEST
;THIS CODE IS NO LONGER USED

ACBLL:	MOVE Q,U
	XCTR XR,[MOVE TT,(J)]	;GET AC
NCBLL:	TLNE TT,400000	;MUST HAVE SIGN BIT OFF(ENTER HERE FROM NLOAD(NLSBP))
	JRST ILUUO
	PUSHJ P,SWTL
	CIRPSW
	TLO TT,200000	;INDICATE NEW TYPE
	TLZ TT,100000	;BIT USED FOR W RQ ON PDP6
	TLNE TT,4000
	JRST ACBLK4	;CALL OF TYPE 4,5,6,7
	TRNN TT,400000	;SKIP UNLESS NO INSERT RQ
	JRST ACBLK2	;ANY PURE DELETE
	LDB T,[330200,,TT]	;4.1-4.2
	JRST .+1(T)
	JRST ACBLKS	;SELF
	JRST ACBLK2	;ABS
	JRST ACBLKC	;CH
ACBLK0:	TLNE TT,400
	JRST ACBLKW	;WRITE MAY NOT BE ALLOWED FOR RANDOM USER INDEX, CHECK PUBLICNESS
ACBLK1:	TRNE TT,400
	JRST LSWPOP	;ONLY ABS CAN SPECIFY PAGES >377
	LDB A,[221000,,TT]	;3.1-3.8 USER INDEX
	CAIE A,377
	JRST ACBK1A
	SKIPGE A,JBI(U)	;SKIP IF JOB DEVICE
	JRST LSWPOP
	MOVE A,JBCUI(A)	;CREATOR'S INDEX
	IDIVI A,LUBLK
	DPB A,[221000,,TT]	;PUT IN USER INDEX FIELD
	JRST ACBLK2
ACBK1A:	IMULI A,LUBLK
	CAMGE A,USRHI
	SKIPN UNAME(A)
	JRST LSWPOP	;NOT A VALID USER INDEX
ACBLK2:	LDB A,[111000,,TT]	;2.1-2.8 VIRTUAL PAGE
	PUSH P,U
	PUSH P,Q
	PUSH P,A
	MOVE U,Q
	PUSHJ P,PAGERT	;FREE UP PAGE
	POP P,E
	POP P,Q
	POP P,U
	TRNN TT,400000
	JRST ACBLX	;DELET RQ ONLY, DONE
	TLNN TT,4000
	JRST ACBLK8
	MOVE B,NMPGS(Q)
	PUSHJ P,ACRTST
	JRST LSWPOP
	PUSH P,Q
	IDIVI Q,LUBLK
	DPB Q,[1100,,TT]
	POP P,Q
	JRST NACRFL

ACBLK8:	TLNN TT,2000
	TLNN TT,1000
	JRST ACBLK3
CORGAB:	MOVE A,E	;GET ABS PAGE
	MOVE U,Q
	PUSHJ P,UPLC
	LDB A,[1100,,TT]	;ABS PAGE
	TLNE TT,100000	;W RQ ON PDP6 ?
	TRO A,400000
	TRO A,200000	;PERMIT READ
	DPB A,T	;SET UP MAP
	MOVNI A,1
	DPB A,Q	;SET UP "CIRC PNTR"
ACBLK7:	PUSHJ P,GHUSRA
	JRST ACBLX

ACBLK3:	PUSH P,U
	PUSH P,Q
	LDB U,[221000,,TT]	;USER INDEX
	IMULI U,LUBLK
	LDB A,[1000,,TT]	;BLOCK NUMBER
	PUSHJ P,UPLC
	LDB J,Q
	JUMPE J,ACBLK5	;PAGE NOT THERE
	CAIN J,-1
	JRST ACBLK6	;ABS
	PUSHJ P,CHACK
	POP P,U
	POP P,Q
	PUSHJ P,NCORR1
	JRST ACBLK7

NCORR1:	LDB J,T		;ENTRY FROM NCORR
	TRNN J,600000
	JRST ACBK3A	;PAGE NON EXISTANT OR SWAPPED OUT
	TLNN TT,400	;WRITE RQ ?
	TRZ J,400000	;DOESN'T RQ MORE
	TRNN J,600000
	TRO J,200000	;IN CASE OF RWF
ACBK3B:	MOVE A,E	;TARGET PAGE #
	PUSHJ P,UPLC
	LDB C,T
	JUMPN C,[JRST 4,.]	;SHOULD HAVE DELETED PAGE BY NOW
	DPB J,T		;SET UP MAP
	TRNN J,600000
	JRST ACBK3C
	ANDI J,777
	AOS MMSWP(J)	;AOS NUMBER OF USERS IN CIRC CHAIN
ACBK3D:	LDB J,B	;POINTER TO PREVIOUS IN CHAIN
	DPB J,Q		;PATCH
	MOVE C,U
	IDIVI C,LUBLK
	DPB C,[101000,,A]
	DPB A,B		;PATCH
	AOS NMPGS(U)
	POPJ P,

ACBK3A:	TLNN TT,400
	TRZ J,2
	TRO J,1	;IN CASE OF R/W/F
	JRST ACBK3B

ACBK3C:	AOS NSWPGS(U)
	JRST ACBK3D

ACBLK4:	LDB A,[111000,,TT]	;2.1-2.8	VIRTUAL PAGE
	PUSH P,Q
	PUSH P,U
	MOVE U,Q
	PUSHJ P,UPLC
	LDB B,T
	POP P,U
	POP P,T	;OLD Q (TARGET USER)
	TLNN TT,2000	;SKIP IF CHANGE PUBLICNESS
	JRST ACBLKN	;CALL TYPES 4,5
	JUMPE B,LSWPOP
	TRNN B,600000
	JRST ACBL4A	;SWAPPED OUT
	TRNN B,400000
	JRST LSWPOP	;DON'T CURRENTLY HAVE WRITE PERMIT
ACBL4B:	MOVE C,Q
	PUSHJ P,UCPRL	;GO THROUGH ALL REFERENCES TO THIS PAGE
	200000,,CORNP2	;FIND MMP
	JRST ACBLX

CORNP2:	MOVE B,(C)	;SET UP PUBLICNESS BIT
	TLZ B,400000
	TLNE TT,1000
	TLO B,400000	;WRITE BIT - IN CASE OF PUBLICNESS
	MOVEM B,(C)
	POPJ P,

ACBL4A:	TRNN B,2
	JRST LSWPOP
	JRST ACBL4B

ACBLKS:	MOVE A,U	;RQ FOR OWN PAGES
	IDIVI A,LUBLK
	DPB A,[221000,,TT]	;DEPOSIT USER INDEX
	LDB A,[1100,,TT]	;BLOCK NUMBER
	LDB B,[111000,,TT]	;VIRTUAL PAGE
	CAMN U,Q	;IF ACTING ON INFERIOR
	CAME A,B	;OR IF PAGE NUMBERS ARE
	JRST ACBLK1	;NOT EQUAL, TREAT AS REQUEST FOR USR INDEX
	MOVE U,Q
	PUSHJ P,UPLC
	LDB E,Q
	JUMPE E,LSWPOP	;PAGE DOES NOT EXIST
	PUSHJ P,CHACK
	ADD D,MMPEAD
	MOVEI E,0	;READ ONLY
	TLNN TT,400
	JRST ACBLS1
	MOVEI E,1	;R/W
	CAME C,[SETZ 3]
	CAIN C,2
	JRST ACBLS1	;OK SINCE PG NOT SHARED
	JRST LSWPOP	;PAGE SHARED

ACBLS1:	LDB J,T
	JUMPE J,LSWPJ1	;NO ACCESS
	TRZN J,600000
	JRST ACBL1	;SWAPPED OUT
	TRO J,200000
	MOVEI B,0
	MOVSI A,40000
	JUMPN E,ACBLS3
ACBLS2:	ANDCAM A,(D)
ACBL2:	IORM B,(D)
	DPB J,T
ACBLX:	MOVE J,USER
	LPMR UPGML(J)
	JRST LSWPJ1

ACBL1:	MOVEI B,0
	MOVEI J,1
	JUMPE E,ACBL2
	MOVEI J,3
	MOVSI B,20000
	JRST ACBL2

ACBLS3:	HLRZ E,1(D)
	TRO J,400000
	JUMPE E,ACBLS2
	PUSH P,T
	PUSH P,I
	LDB I,[DADDNL+1(D)]
	PUSHJ P,QTLOCK
	LDB E,[DADTNL+1(D)]
	PUSH P,TT
	IDIVI E,TUTEPW
	ADD E,QTUTO(I)
	HLL E,TBTBL(TT)
	LDB TT,E
	CAIGE TT,TUTMNY
	SOS TT
	DPB TT,E
	HRRZS 1(D)
	POP P,TT
	PUSHJ P,QTULK
	POP P,I
	POP P,T
	JRST ACBLS2

ACBLK9:	MOVE Q,T	;GET TARGET USER BACK TO Q
	JRST ACBLK2

ACBLKN:	LDB C,Q	;CIRCULAR LIST ENTRY
	CAIN C,-1
	JRST ACBLK9	;CURRENTLY ABS PAGE
	JUMPE B,ACBLK9	;PAGE NOT EXISTANT CURRENTLY
	TRNN B,600000
	JRST ACBKNA
	TRNN B,400000
	JRST ACBLK9	;NO WRITE PERMIT
ACBKNB:	PUSHJ P,CHACK
	CAME C,[SETZ 3]
	CAIN C,2
	JRST LSWPJ1	;PRESENT PAGE NOT SHARED
	JRST ACBLK9

ACBKNA:	TRNN B,2
	JRST ACBLK9
	JRST ACBKNB

ACBLKW:	LDB A,[1000,,TT]
	PUSH P,U
	PUSH P,Q
	LDB U,[221000,,TT]
	CAIE U,377
	JRST ACBKW1
	MOVE U,-1(P)
	SKIPGE U,JBI(U)	;LOOK AT RQING JOB'S CREATOR
	JRST ACBLK5
	MOVE U,JBCUI(U)	;CREATOR'S USER INDEX
	JRST ACBKW2
ACBKW1:	IMULI U,LUBLK	;USER INDEX PAGE IN A BELONGS TO
ACBKW2:	CAIGE U,USRHI
	SKIPN UNAME(U)
	JRST ACBLK5
	PUSHJ P,UPLC
	LDB J,Q
	JUMPE J,ACBLK5
	PUSH P,T
	MOVE C,Q
	PUSHJ P,UCPRL
	200000,,ACBLKQ
	POP P,T
	POP P,Q
	POP P,U
	SKIPGE JBI(U)
	JRST ACBKW3
	LDB B,T	;PAGE MAP ENTRY
	TRNE B,400000
	JRST ACBLK1	;CREATOR HAS WRITE ACCESS
	TRZN B,600000	;SKIP IF NO WRITE ACCESS
	CAIE B,3	;SWAPPED OUT, SKIP IF WRITE ACCESS
	JRST ACBKW3
	JRST ACBLK1
ACBKW3:	TLNN W,400000	;SKIP IF PUBLIC
	JRST LSWPOP
	JRST ACBLK1	;PAGE IS PUBLIC, SO OK FOR USER TO ATTACH

ACBLKQ:	MOVE W,(C)	;GET MMP ENTRY
	POPJ P,

ACBLK5:	POP P,Q
	POP P,U
	JRST LSWPOP

ACBLK6:	LDB J,T		;COPY ABS
	MOVE A,E
	POP P,U
	POP P,Q
	PUSHJ P,UPLC
	DPB J,T
	MOVEI J,-1
	DPB J,Q
	JRST ACBLK7

ACBLKC:	LDB R,[221000,,TT]
	CAIL R,20
	JRST LSWPOP	;NOT A CH #
	ADD R,U
	HLRZ A,IOCHNM(R)	;INDEX INTOUSER
	HRRZ B,IOCHNM(R)	;INDEX INTO CLSTB
	MOVSI E,100000
	TDNN E,CLSTB(B)	;JOB DEVICE
	SKIPGE B,CLSTB(B)
	JRST ACUSF1	;USER DEVICE, NOT PDP6
	TLNE B,1000
	JRST ACBLKF	;FOREIGN USER
IFN PDP6P,	TLNN B,100
	JRST LSWPOP	;CHANNEL NOT OPEN ON DEVICE USR
IFN PDP6P,[
	MOVEI A,1	;PDP 6
	DPB A,[330200,,TT]	;MAKE LIKE ABS
	LDB A,[1100,,TT]
	CAIL A,16.
	JRST LSWPOP
	ADDI A,PDP6BM_<-10.>
	DPB A,[1100,,TT]	;PUT IN ABSOLUTE PAGE NUMBER
	TLNE TT,400	;WRITE RQ ?
	TLO TT,100000	;PDP6 W RQ BIT
	JRST ACBLK2
]

ACBLKF:	TLNE TT,400
	JRST LSWPOP	;TRYING TO WRITE, FLUSH
			;DROP THRU TO ALLOW READ
ACUSF1:	IDIVI A,LUBLK	;CONVERT TO USER INDEX
	DPB A,[221000,,TT]
	JRST ACBLK1

ACRF1:	MOVE TT,B
	MOVE W,Q	;INDEX OF USER THAT REQUEST IS FOR
	IDIVI W,LUBLK	;CLOBBERS H
	HRL TT,W
	TLNE TT,600000
	JRST 4,.
	JRST ACRFL

NACRFL:	PCLT
NACR4:	PUSHJ P,LSWPOP	;UNLOCK CASW OR CIRPSW
ACRFL:	SKIPL CORRQ(U)	;CURRENT USER IN U COR RQ FOR USER IN Q
	PUSHJ P,UFLS	;WAIT FOR MY CORE RQ TO CORE JOB TO CLEAR
	MOVSI J,BUSRCR
	MOVE T,J
	TDNE T,APRC(Q)
	PUSHJ P,UFLS	;SOMEBODY ELSE HAS RQ IN ON THIS JOB WAIT TO CLEAR
	PUSHJ P,SWTL
	CASW		;GET CORE ASSIGN SW
	TDNE J,APRC(Q)
	JRST NACR4	;CHECK FOR TIMING ERROR
	TLNN TT,200000
	JRST ACRF6	;OLD TYPE
	MOVNI J,1	;ADDING ONE BLOCK
	MOVEI B,105	;FAKE OUT CORE TO ZERO CHECK
	JRST ACRF8

ACRF6:	MOVE J,HUSRAD(Q)
	LSH J,-10.
	CAMN J,B
	JRST LSWPJ1	;SAME AMOUNT AS NOW
	LDB T,[410100,,APRC(Q)]
	SKIPE T
	JUMPN B,LSWPOP	;TRYING TO CORE NON-ZERO A JOB THAT WAS CORED ZERO
	SUB J,B		;GET AMT OF DECREASE (- => INCREASE)
	CAMGE J,[-20.]
	JRST ACRF6A	;GET 20 AT A WHACK MAX
ACRF8:	LDB I,[410100,,APRC(U)]	;MUST BE AFTER TEST FOR SAME AMOUNT AS NOW
	JUMPN I,NACR3	;RQ'ING USER HAS BEEN CORED 0
	MOVN I,J	;I GETS POSITIVE # OF PAGES ADDED
	ADD J,MEMFR
	SUB J,NCBCOM	;J GETS AMT THAT WILL BE LEFT
	CAIGE J,5
	JUMPG I,ACRF7	;NOT ENUF CORE
	MOVEI J,0	;INDICATE RQ WILL BE COMPLETELY SATISFIED
	CAIL I,20.
	MOVNI J,1	;MAKE SURE RQ IS REALLY FILLED
	SKIPL I		;SKIP ON FLUSHING CORE
	JUMPE Q,ACRF3	;SYS JOB, MAKE SURE CORE AVAIL IN LOWER HALF
ACRF5:	SKIPL I
	ADDM I,NCBCOM
	SKIPGE I
	AOS NCRQL	;# RQ'S FOR LESS
	MOVSI T,BUSRK
	SKIPN B
	IORM T,APRC(Q)	;KILLING USER (CORING ZERO)
	MOVSI T,BUSRCR
	IORM T,APRC(Q)	;CORING USER
	MOVEM TT,CORRQ(U)
	AOS NCORRQ
	PUSHJ P,LSWPOP	;UNLOCK
	PCLT
	SKIPL CORRQ(U)	;WILL NOT SKIP AT FIRST
	PUSHJ P,UFLS
	JUMPN J,ACRF1	;REALLY NEED TO TAKE ANOTHER WACK AT THIS
	JRST POPJ1

ACRF7:	ADD J,SOLNG	;ADD # ON WAY OUT
	ADD J,SWPOPR	;I=-NUMBER NEEDED TO SWAP OUT
	MOVNS J	;EXTRA WILL NEED
	MOVE T,SWOMNP
	SUB T,NPGSWO	;-NUMBER LEFT IN MAX
	CAML J,T
	JRST LSWPOP	;SWAP OUT QUOTA FULL
ACRF9A:	PUSHJ P,LSWPOP
	PCLT
	MOVE T,I
	PUSHJ P,CFHPO3
	PUSHJ P,UFLS
	TLNE TT,200000
	JRST ACRFL
	JRST ACRF1

ACRF3:	CONO PI,UTCOFF
	LDB T,[MLO,,MEMFP]
	CAIN T,377
	JRST ACRF4	;NO CORE AVAIL IN LOWER HALF
	SETOM SJBRES	;RESERVE BLOCK IN LOWER HALF FOR SYS JOB
	CONO PI,UTCON
	JRST ACRF5

ACRF4:	CONO PI,UTCON
	JRST LSWPOP	;NO CORE IN LOWER

NACR3:	PUSHJ P,LSWPOP	;UNLOCK CASW
	JFCL
	PUSHJ P,UFLS	;WAIT FOR AX TO FALL


ACRF6A:	ADDI J,20.
	ADD TT,J	;GET REDUCED RQ
	MOVNI J,20.
	JRST ACRF8
;
; CORE ALLOCATOR
;  CORE JOB ROUTINES
;
CORJI:	MOVE P,USRPDL+L	;SET UP CORE JOB PDL
	JRST CORJOB

CORJ2:	AOSN UTBFLF
	JRST UTBFF	;FLUSH UTAPE
	AOSN UFDFLF
	JRST UFDFF	;FLUSH 2314 UFDS
	SKIPE NCRQL
	JRST CORJOB	;RQ'S FOR LESS HAVE COME IN. BETTER EXECUTE THEM OR MAY NOT HAVE ENUF CORE
	SKIPL CORUPU
	JRST CORUP	;FOUND USER IN SEARCH WHO WANTS MORE GIVE IT TO HIM
	SKIPL CORSRV
	JRST CORJOB
	SKIPLE NCORRQ
	SOS NCORRQ	;CAN'T FIND ANYTHING TO DO SO DECREMENT COUNT
		;THIS CAN HAPPEN AS A RESULT OF EXCESS ATTEMPTED UTAPE FLUSHAGE
CORJOB:	PUSHJ P,ACMTC	;XFER ANY "SPECIAL FREE" MEM BLOCKS TO FREE
	SKIPN NCORRQ	;WAIT UNTIL SOMEONE RQ'S CORE
	PUSHJ P,UFLS
	SETOM CORSRV	;INITIALIZE NO RQS SERVED THIS PASS
	SETOM CORUPU
	MOVNI U,LUBLK	;SCAN FOR USER WITH HIGHEST PRIORITY
CORLUP:	ADDI U,LUBLK
	CAML U,USRHI
	JRST CORJ2	;THRU EXAMINE RESULTS OF SEARCH
	SKIPGE B,CORRQ(U)
	JRST CORLUP
	TLNE B,200000
	JRST CORNEW
	LDB Q,[221000,,B]
	IMULI Q,LUBLK
	MOVE A,HUSRAD(Q)
	LSH A,-10.	;COMPUTE # BLKS JOB HAS NOW
	CAIN A,(B)
	JRST 4,CORL1	;SAME AS NOW, CHECKED FOR AT ACORE
	CAIG A,(B)
	JRST CORLUG	;INCREASE
	MOVEM U,CORUPU	;DECREASE HAS PRIORITY
	HRRZS B
	SUB B,A
	MOVEM A,CORUPS
	MOVEM B,CORUPA	;DIFFERENCE
	MOVEM Q,CORUUC
	SOS NCRQL
	JRST CORUP

CUSTP1:	MOVSI T,BCSTOP	;STOP USER WHO IS BEING SHUFFLED, MOLESTED,ETC
	JRST .+2
CUSTOP:	MOVSI T,BUCSTP	;STOP USER WHO IS BEING CORED
	PUSH P,T
	PUSHJ P,RPCLSR	;STOP USER
	POP P,T
	IORM T,USTP(A)
	PUSHJ P,UPCLSR
	HRRZ T,USTP(A)
	JUMPE T,CPOPJ	;NO OTHER SYSTEM STOP
	MOVEI T,-1	;GET MASK FOR RH
	TDNE T,USTP(A)	;WAIT FOR RANDOM STOPS TO CLEAR
	PUSHJ P,UFLS
	POPJ P,

EBLK

CORUPU:	-1	;BEST USER SO FAR TO CHANGE CORE
		;IF SETOMED AT CORUPR, REQUEST NOT COMPLETELY FILLED
CORUPA:	0	;INCREASE AMOUNT(1 FOR .CBLK)
CORUPS:	0	;CURRENT SIZE
CORUUC:	0	;USER CORE REQ ACTUALLY FOR
CSIOT1:	0	;NUMBER UTAPE BUFFERS RESERVED
CORSRV:	-1	;0 => RQ SRVED THIS TIME THRU USER VARS
NCRQL:	0	;# RQS FOR LESS
CIRPSW:	-1	;CIRCULAR POINTER SWITCH
	0
COSJ:	0	;J AT CORS2+
COSE:	0	;E "   "
COSD:	0	;D "   "

BBLK

CORLUG:	HRRZS B	;GUY WANTS MORE GIVE GUY WHO WANTS LEAST PRIORITY
	SUB B,A
CORLUH:	MOVE A,NMPGS(Q)
	SKIPGE CORUPU
	JRST CORLG1	;FIRST
	CAMGE B,CORUPA	;IS RQ SMALLER?
	JRST CORLG1
CORLG2:	CAME B,CORUPA	;OR IF TIE GIVE IT TO GUY WHO IS SMALLER NOW
	JRST CORG1A
	CAML A,CORUPS	;IS RQ= & SIZE SMALLER?
	JRST CORG1A
CORLG1:	MOVEM U,CORUPU	;HIGHEST PRIORITY SO FAR
	MOVEM B,CORUPA
	MOVEM A,CORUPS
	MOVEM Q,CORUUC
CORG1A:	JRST CORLUP

CORNEW:	LDB Q,[1100,,B]		;.CBLK TYPE RQ
	IMULI Q,LUBLK
	MOVEI B,1
	JRST CORLUH

CORUP:		;EXECUTE REQUEST
	MOVE U,CORUUC
	MOVEM U,CUSER
	SKIPL D,CORUPU
	SKIPN UNAME(U)
	JRST 4,.
	MOVE A,CORUUC
	JUMPE A,CORUP8	;DONT USTOP SYS JOB
	PUSHJ P,CUSTOP	;STOP GUY
CORUP8:	PUSHJ P,SWTL
	CIRPSW
	MOVE TT,CORRQ(D)
	TLNE TT,200000
	JRST CORUPN	;.CBLK TYPE
	MOVE B,CORUPS
	MOVE A,B	;A HAS CURRENT SIZE
	ADD B,CORUPA	;B HAS NEW SIZE
	PUSHJ P,SWTL
	MEMFRZ
	SKIPL J,CORUPA
	JRST CORM1C	;WANTS MORE THAN NOW
CORL2:	LDB A,[121100,,HUSRAD(U)]
	CAMG A,B
	JRST CORUPR
	SOS A
	PUSH P,B
	PUSHJ P,UPGRTN	;RETURN USER PG
	POP P,B
	JRST CORL2

CORUPR:	MOVE U,CUSER	;FINISHED FOR NOW ANYWAY REVIVE USER
	SKIPN UNAME(U)
	JRST 4,.
IFN 340P,[
	CAMN U,DISUSR
	PUSHJ P,DCRRST	;DIS IS RUNNING BUT UPDATE UPR ETC
]
	MOVSI A,BUCSTP
	ANDCAM A,USTP(U)	;RESTART USER
	PUSHJ P,LSWPOP	;UNLOCK MEMORY
	PUSHJ P,LSWPOP
	PUSHJ P,ACMTC	;XFER IN PROCESS BLOCKS TO FREE
	SKIPGE U,CORUPU
	JRST CORJOB	;NOT THRU WITH THIS RQ
	MOVE A,CORUUC	;THRU WITH RQ
	SETOM CORUPU
	MOVSI TT,BUSRCR
	ANDCAM TT,APRC(A)	;CLEAR RQ PENDING THIS USER FLAG
CORL1:	SETOM CORRQ(U)
	CLEARM CORSRV
	SOSE NCORRQ
	JRST CORLUP
	JRST CORJOB

CORUPN:	LDB A,[111000,,TT]
	PUSHJ P,SWTL
	MEMFRZ
	PUSH P,A
	PUSHJ P,UPGRTN
	POP P,E
	TLNE TT,4000
	TRNN TT,400000
	JRST 4,.
	TLO E,600000	;ADD FRESH PAGE
	PUSH P,TT
	PUSHJ P,CORGP
	POP P,TT
	LDB A,[111000,,TT]
	PUSHJ P,UPLC
	LDB B,T
	TRNN B,400000
	JRST 4,.	;LOSEY
	MOVE C,Q
	PUSHJ P,UCPRL
	200000,,CORNP2	;SET TO DESIRED PUBLICNESS
	SOS NCBCOM
	JRST CORUPR

CORM1C:	MOVEM J,CORCNT
CORM1A:	JUMPE U,CORS2	;SNIFFLE
CORM1B:	MOVE U,CORUUC
	LDB E,[121100,,HUSRAD(U)]
	TLO E,600000
	PUSHJ P,CORGP
	SOS NCBCOM
	SOSLE CORCNT
	JRST CORM1A
	JRST CORUPR


CORGP:	;INSERT PG INTO USR MEM IN PLACE SPECIFIED BY E PROT BITS IN LH
	PUSHJ P,GMMPP	;RETN MMP PNTR IN R
	JRST CORGPZ
	MOVE A,SJSPG
	MOVE B,CORUPA
	SOSE B
	JUMPE U,CORGP2	;DON'T ZERO SYS ON INTIAL CALL
	JUMPE U,CORGP1	;SYS JOB, GOBBLE PAGE RESERVED
	PUSHJ P,TCALL
	JRST HMEMRQ	;GET MEM, HIGH IF POSSIBLE
	JRST 4,.
CORGP1:	PUSHJ P,CZRR
CORGP2:	AOS NMPGS(U)
	PUSH P,A	;REAL CORE BLOCK #
	HRRZ A,E	;ADDR IN USERS MAP
	PUSHJ P,UPLC
	POP P,A
	LDB B,Q
	JUMPN B,[JRST 4,.]	;ALREADY HAS PAGE
	TSO A,E	;SET PROTECTION BITS
	DPB A,T	;STORE IN USER'S MAP
	MOVE C,R	;MMP PUTC
	TRO R,400000
	DPB R,Q		;MAKE USERS CP POINT AT MMP
	ANDI A,777
	MOVEI TT,1
	MOVEM TT,MMSWP(A)
	MOVEI TT,MURUSR
	DPB TT,[MUR,,MEMBLT(A)]	;SET USER FIELD IN MEMBLT
	MOVE TT,U
	IDIVI TT,LUBLK
	LSH TT,8
	IOR TT,E	;PG # IN USER'S MAP
	HRRZM TT,MEMPNT(A)	;MAKE MEM BLOCK POINT AT USERS MAP
	ADD C,MMPEAD
	HRRM C,MEMBLT(A)	;STORE ADDR OF MMP ENTRY IN RH OF MEMBLT
	TRO A,600000
	HRRM A,(C)	;MAKE MMP POINT AT MEM BLOCK
	PUSHJ P,CHACK	;FOR CHECKING ONLY
	CAME C,[SETZ 3]	;REAL MEM, 3 ENTRIES (MMP, MEMPNT, USER)
	JRST 4,.
GHUSRA:	AOS E
	LSH E,10.	;COMP NEW HUSRAD AFTER GETTING PAGE
	TLZ E,-2	;FLUSH FROTECT BITS(LEAVE 2.1)
	CAMLE E,HUSRAD(U)
	MOVEM E,HUSRAD(U)
	POPJ P,

CORGPZ:	PUSHJ P,LSWPOP	;MEMFRZ
	PUSHJ P,LSWPOP	;CIRPSW
	MOVEI T,3
	CAMLE T,LMEMFR
	PUSHJ P,UFLS
	PUSHJ P,SWTL
	CIRPSW
	PUSHJ P,SWTL
	MEMFRZ
	JRST CORGP

UPLC:	JUMPL A,[JRST 4,.]	;BAD VIRTUAL PAGE NUMBER
	CAIL A,400
	JRST 4,.	;BAD VIRTUAL PAGE NUMBER
	PUSH P,A
	PUSH P,B
	MOVE Q,UCPB1(U)	;GET PNTR TO MAP HW IN T, TO CIR IN Q
	TRNE A,200
	MOVE Q,UCPB2(U)
	MOVE T,UDBR1(U)
	TRZE A,200
	MOVE T,UDBR2(U)
	ROT A,-1
	LDB B,[230700,,T]
	CAIGE B,(A)	;CHECK DBL
	JRST UPLC1
	ADDI T,(A)
	HRLI T,222200
	SKIPGE A
	HRLI T,2200
	ADDI Q,(A)
	HLL Q,T
	JRST POPBAJ

UPLC1:	SETZB T,Q	;DBL LOSES
	JRST POPBAJ

PAGERT:	PUSHJ P,SWTL
	MEMFRZ
	PUSHJ P,UPGRTN
	JRST LSWPOP

UPGRTN:	SKIPE NPDBLK
	PUSHJ P,UFLS	;WAIT FOR PDUMP PAGES TO CLEAR
	PUSH P,R	;RETURN VIRT PG # IN A USER IN U
	PUSH P,I
	PUSH P,TT
	PUSH P,E
	PUSHJ P,UPLC
	LDB B,Q
	CAIN B,-1
	JRST UPRABS	;ABSOLUTE PAGE
	JUMPE B,RHUSRA	;DOESNT REALLY HAVE PG
	PUSH P,T
	PUSHJ P,CHACK	
	MOVE R,MMPEAD
	ADD R,D	;R HAS MMP ADDRESS
UPGRTA:	MOVSI T,100000
	TDNE T,(R)
	PUSHJ P,UFLS
;	JRST UPGRTW	;WAIT FOR PAGE TO TRANSIT BUT UNLOCK SWITCHES
	MOVNI I,1
	HLRZ A,1(R)	;SEE IF DISK SPACE ASSIGNED
	JUMPE A,UPGRT5
	LDB I,[DADDNR+A]
	PUSHJ P,QTLOCK	;LOCK APPRO TUT
UPGRT5:	POP P,T		;POINTER TO ORIG MAP ENTRY OF USER
	LDB TT,T	;IF PROT BITS=0 PAGE IS SWAPPED OUT FOR PURPOSES OF USER'S SWAP OUT COUNT
	MOVEI E,0	;EVEN IF IN CORE
	DPB E,T	;CLEAR USER MAP ENTRY
	TRNN TT,600000
	SOS NSWPGS(U)
	TRNN TT,600000
	JRST UPGRT4	;PAGE SWAPPED OUT
	ANDI TT,777	;MASK TO MEM PAGE #
	CAIE TT,(J)
	JRST 4,.
	MOVSI E,300000
	TDNE E,(R)
	JRST 4,.	;PAGE NOT IN
	SKIPGE C
	SOS MMSWP(TT)
	HLRE E,MMSWP(TT)	;GET # EXEC PGS POINTING TO THIS
	JUMPL E,[JRST 4,.]	;<0 EXEC PAGES
	JUMPE E,UPGRT4	;NO EXEC PGS POINTING TO THIS
	PUSH P,J
	MOVSI T,-NEXPGS	;LOOK FOR EXEC PGS SET UP TO PNT
	MOVE E,[442200,,EXEUMP]	;TO USER PAGE FLUSHED
UPGRT3:	ILDB J,E
	TRZN J,600000
	JRST UPGRT2
	ANDI J,777
	CAMN TT,J
	JRST UPGRT1
UPGRT2:	AOBJN T,UPGRT3
	MOVSI T,-1
	TDNE T,MMSWP(TT)
	JRST 4,.	;EXEX PG CNT NOT 0 ALTHO ALL EXEC PGS PNTNG HERE WERE FLUSHED
	POP P,J
UPGRT4:	LDB T,Q	;DELINK CIRC PNTR
	DPB T,B
	MOVEI T,0
	DPB T,Q	;CLOBBER CIRC P
	SOS NMPGS(U)
	CAME C,[SETZ 3]
	CAIN C,2
	JRST MMPRTN	;RETURN MMP ENTRY SINCE PAGE NO LONGER IN USE
MMPRT4:	MOVE A,J
	CAMN C,[SETZ 3]
	PUSHJ P,CMEMR	;HAS REAL MEM, CIRC LENGTH =3 SO FLUSH MEM
	SKIPL I
	PUSHJ P,QTULK
RHUSRA:	POP P,E
	POP P,TT
	POP P,I
	POP P,R
RHUSR1:	LDB A,[121100,,HUSRAD(U)]	;COMP HUSRAD AFTER RETURNING PAGE
	JUMPE A,CPOPJ
	SOS A
	PUSHJ P,UPLC
	LDB B,Q
	JUMPN B,CPOPJ	;FOUND ACTIVE PAGE
	MOVNI C,2000	;KEEP LOOKING
	ADDM C,HUSRAD(U)
	JRST RHUSR1

UPRABS:	MOVEI B,0
	DPB B,Q
	DPB B,T
	JRST RHUSRA

UPGRT1:	MOVSI J,-1
	XCT EXPFT(T)	;MAYBE XFERR TO ROUTINE TO DO SOMETHING ABOUT THIS
	MOVEI J,0
	DPB J,E	;CLEAR OUT EXEC PAGE ENTRY
	MOVE J,USER
	LPMR UPGML(J)
	CONO PI,UTCON
	JRST UPGRT2

;UPGRTW:	PUSHJ P,LSWREM
;	MEMFRZ
;	PUSHJ P,LSWREM
;	CIRPSW
;	PCLT
;	TDNE T,(R)
;	PUSHJ P,UFLS	;WAIT FOR PAGE TO BE ALL IN OR OUT
;	PUSHJ P,SWTL
;	CIRPSW
;	PUSHJ P,SWTL
;	MEMFRZ
;	JRST UPGRTA

EXPFT:
IFN 340P,	REPEAT 2+N340PB,	PUSHJ P,DISACR
	REPEAT 2,JFCL
IFN VIDP,	REPEAT 2,PUSHJ P,SCNACR
	REPEAT NMMP,JRST 4,.
	JRST 4,.
IFN .-EXPFT-NEXPGS, PRINTX / LOSE AT EXPFT /

;CIRCULAR MEM LIST HACKER
;RETN BYTE PNTR IN B TO GUY WHO PNTS TO ME
			;COUNT FOR ENTRIES IN C (RH)
			;4.9 C SAYS ACTUAL MEM IN LOOP
			;RETN IN D MMP INDEX
			;RETURN MEM PAGE IF ANY IN J
CHACK:	PUSH P,A
	LDB J,Q	;PICK UP STARTING C. P.
	SETZM C
	MOVNI D,1
	MOVE B,Q
CHACK1:	JUMPE B,[JRST 4,.]
	AOS C
	CAIE J,-1	;SKIP ON ABS PAGE
	TRNE C,776000
	JRST 4,.	;CIRC CHAIN TOO LONG?
	TRZE J,400000
	JRST CHACK3	;MEMPNT OR MMP PNTR
	LDB I,[1000,,J]	;PG #
	LDB H,[101100,,J]	;USER #
	IMULI H,LUBLK
	SKIPE UNAME(H)
	CAML H,USRHI
	JRST 4,.
	MOVE W,UCPB1(H)
	TRZE I,200
	MOVE W,UCPB2(H)
	ROT I,-1
	ADDI W,(I)
	HRLI W,222200
	SKIPGE I
	HRLI W,2200
	CAMN W,Q
	JRST CHACK2	;FOUND ENTRY WHICH PNTS AT ORIGIONAL ENTRY
	LDB J,W
	MOVE B,W
	JRST CHACK1	;KEEP LOOKING

CHACK2:	MOVE J,A
	JUMPL D,[JRST 4,.]	;NO MMP ENTRY ?
	JRST POPAJ

CHACK3:	TRZE J,200000
	JRST CHACK4	;ACTUAL CORE
	CAML J,MMPMX
	JRST 4,.
	MOVSI B,2200	;MMP ENTRY
	HRR B,MMPEAD
	ADDI B,(J)
	JUMPGE D,[JRST 4,.]	;MORE THAN 1 MMP ENTRY
	MOVE D,J
	LDB J,B
	JRST CHACK1

CHACK4:	TLOE C,400000
	JRST 4,.
	MOVE A,J	;SAVE MEMBLT INDEX
	MOVSI B,2200
	HRRI B,MEMPNT
	ADDI B,(J)
	LDB J,B
	JRST CHACK1

MMPRTN:	JUMPL I,MMPRT3	;NO DISK SPACE ASSIGNED
	PUSH P,B
	ANDI A,DTMSK	;GET DISK TRACK NUMBER
	MOVE T,A
	IDIVI A,TUTEPW
	ADD A,QTUTO(I)
	HLL A,TBTBL(B)
	LDB B,A
	CAIGE B,TUTMNY
	SOS B	
	DPB B,A
	JUMPN B,MMPRT2
	MOVE A,QTUTO(I)
	CAML T,QSWAPA(A)
	AOS QSFT(I)
	CAMGE T,QSWAPA(A)
	AOS QSFTS(I)
MMPRT2:	MOVE T,DCHBT(I)
	IORM T,QTUTO(I)
	POP P,B
	JUMPL C,MMPRT3	;WAS MEM IN LOOP SO NOT SWAPPED OUT FOR SYSTEM'S COUNT
	SOS NPGSWO	;IT WAS SWAPPED OUT
MMPRT3:	PUSHJ P,MMPRT1
	JRST MMPRT4

MMPRT1:	TRNE D,774001
	JRST 4,.
	EXCH D,MMPFS	;ADD THIS ENTRY ONTO THE FRONT OF
	MOVE A,MMPFS	;THE LIST OF AVAILABLE MMP ENTRIES
	ADD A,MMPEAD
	SKIPE MEMIDU
	SKIPL (A)	;SKIP IF WAS PUBLIC
	JRST MMPRTQ
	PUSH P,B
	PUSH P,C
	MOVSI B,-MEMIDL
MMPRTU:	SKIPE C,MEMID(B)
	CAIE A,(C)
	AOBJN B,MMPRTU
	JUMPGE B,MMPRTV
	SETZM MEMID(B)
	SOS MEMIDU
MMPRTV:	POP P,C
	POP P,B
MMPRTQ:	MOVEM D,(A)
	SETZM 1(A)	;CLEAR SECOND WORD OF ENTRY
	POPJ P,

GMMPP:	HRRZ R,MMPFS	;SKIPS IF SUCCESSFUL
	TRNE R,774000	;DOESN'T SKIP IF NOW LOW CORE
	JRST 4,.	;FOR NEW MMP PAGE
	JUMPE R,GMMP1
	MOVE TT,R
	ADD TT,MMPEAD
	CLEARM 1(TT)
	HRL TT,(TT)
	CLEARM (TT)
	HLRZM TT,MMPFS
	JRST POPJ1

GMMP1:	PUSH P,A
	PUSH P,B
	PUSH P,D
	PUSHJ P,TCALL
	JRST NMMRQ
	JRST GMMP3	;NO LOW CORE AVAIL NOW
	MOVEI B,MUMMP
	DPB B,[MUR,,MEMBLT(A)]
	MOVEI B,2000
	ADDM B,MMPMX	;INCREMENT MAX ALLOWABLE ADDR OF MMP
	AOS B,MMPNP
	CAILE B,NMMP
	JRST 4,.
	MOVEM A,MMMPG-1(B)
	TRO A,600000
	DPB A,MMPPPP-1(B)
	MOVE D,USER
	LPMR UPGML(D)
	SOS B
	LSH B,10.
	HRLI B,-1000
GMMP2:	HRRZ D,B
	PUSHJ P,MMPRT1
	AOS B
	AOBJN B,GMMP2
	POP P,D
	POP P,B
	POP P,A
	JRST GMMPP

GMMP3:	POP P,D
	POP P,B
	POP P,A
	POPJ P,

CORS2D:	PUSHJ P,UDELAY
CORS2:	SKIPE NPDBLK
	PUSHJ P,UFLS	;WAIT FOR PDUMP LIST TO CLEAR
	LDB J,[121100,,HUSRAD(U)]
	LDB E,[MUR,,MEMBLT(J)]
	LDB D,[MLO,,MEMFP]
	MOVEM J,COSJ
	MOVEM E,COSE
	MOVEM D,COSD
	CAIN D,377
	JRST 4,.
	CAIGE E,MSPL	;LOWEST SPECIAL CODE
	JRST CORS4	;USER
	JRST @CORSDT-MSPL(E)	;DISPATCH TO APPROPRIATE ROUTINE

COSFR:	MOVE D,J
	PUSHJ P,MEMMF
CBMRT:	MOVEM J,SJSPG	;SAVE PAGE # RESERVED
	CLEARM SJBRES	;CLEAR PAGE RESERVED FLAG
	JRST CORM1B

CORSDT:	COS2LS	;DDT
	COS2LS	;HOLE
	COS2LS	;COPY OF 2314 USER DIR FOR LISTING
	COS2TT	;2314 TUT
	COS2MD	;2314 MASTER DIR
	COS2UD	;2314 USER DIR
	COS2B	;2314 BUFFER
	COSMRT	;MEMORY RETURNING WHEN MEM FROZE
	COSDB	;DISPLAY BUFFER
	COSMMP	;MMP TBL
	CRERR	;MAG TAPE BUFFER
	COSINP	;IN PROCESS
	COSFR	;FREE
	COSIO	;IO (UTAPE, CLINK, NETWORK)
	COSEX	;EXEC

COS2MD:	JRST 4,.
COS2TT:	JRST 4,.
COSMMP:	JRST 4,.
COSEX:	JRST 4,.
CRERR:	JRST 4,.
COS2LS:	JRST 4,.
IFE 340P,COSDB:	JRST 4,.

COSJB2:	MOVSI T,BCSTOP
	ANDCAM T,USTP(Q)
	ANDCAM T,USTP(B)
COSJB1:	CONO PI,CLKON
	JRST CORS2

UFDFF:	PUSHJ P,SWTL
	UDRSW
	MOVSI Q,-QNUD
UFDFF1:	SKIPN QSNUD(Q)
	JRST UFDFF2
	MOVE TT,QACTB
	TDNN TT,QSNLCN(Q)
	SKIPE QSNNR(Q)
	JRST UFDFF2
	PUSHJ P,LWAIT
	SKIPGE QSNLCN(Q)
	MOVSI TT,400000
	IORM TT,QSNLCN(Q)
	CONO PI,UTCON
	SKIPN QSNUD(Q)
	JRST UFDFF3
	MOVE A,QACTB
	TDNN A,QSNLCN(Q)
	SKIPE QSNNR(Q)
	JRST UFDFF3	;CANT REALLY FLUSH IT
	CLEARM QSNUD(Q)	;FLUSH DIR
	LDB A,[121000,,QSNLCN(Q)]
	PUSHJ P,CMEMR
UFDFF2:	AOBJN Q,UFDFF1
	JRST UTBFF5

UFDFF3:	ANDCAM TT,QSNLCN(Q)
	JRST UFDFF2

COS2UD:	PUSHJ P,SWTL	;2311 USER DIRECTORY
	UDRSW		;LOCK USER DIRECTORY SWITCH
	LDB E,[MUR,,MEMBLT(J)]
	CAIE E,MU23UD
	JRST COSUDD	;CHECK FOR TIMING ERR
	LDB Q,[MLO,,MEMBLT(J)]
	PUSHJ P,LWAIT	;WAIT FOR DIRECTORY TO UNLOCK
	SKIPGE QSNLCN(Q)
	MOVSI TT,400000	;THEN LOCK IT
	IORM TT,QSNLCN(Q)
	CONO PI,UTCON
	SKIPE QSNNR(Q)	;CAN WE FLUSH DIRECTORY
	JRST CO2UD1	;NO IN USE
	MOVE TT,QACTB
	TDNE TT,QSNLCN(Q)
	JRST CO2UD1	;NO CHANGED AND NOT WRITTEN
	CLEARM QSNUD(Q)	;YES FLUSH
	PUSHJ P,LSWPOP
	JRST CBMRT

COSUDD:	PUSHJ P,LSWPOP	;IT CHANGED, TRY AGAIN
	JRST CORS2

CO2UD1:	PUSHJ P,LSWPOP
	PUSHJ P,CMOVE2
	DPB D,[121000,,QSNLCN(Q)]
	MOVSI TT,-NUDCH	;CHECK DIRECTORY CHNLS THAT ARE LISTING THIS DIRECTORY
	CONO PI,CLKOFF
CO2UD2:	MOVE A,DSKLST(TT)
	SKIPL UDUSR(TT)
	CAIE A,3
	JRST CO2UD3	;FREE OR NOT 2314 UFD
	HRRZ A,UUDPP(TT)
	CAMN A,Q	;SKIP ON NOT THIS UFD
	DPB D,[121000,,DIRPT(TT)]	;RELOCATE
CO2UD3:	AOBJN TT,CO2UD2
	CONO PI,CLKON
	MOVSI TT,400000
	ANDCAM TT,QSNLCN(Q)
	JRST CBMRT

COS2B:	LDB Q,[M2311C,,MEMBLT(J)]	;2314 BUFFER LOAD CHNL NO
	CAIN Q,NQCHN+1
	JRST CORS2D	;SWAP IN OR SWAP OUT.  WAIT FOR COMPLETION
	MOVSI TT,4000
	IORM TT,QSRAC(Q)	;SET DONT RELOAD AT PI BIT
	SKIPL QSCABN(Q)	;WAIT FOR PI ACT BUFF TO COMPLETE IF NECC
	JRST COS2B1
COS2B2:	MOVSI TT,400000
	IORM TT,QSRAC(Q)	;LOCK CHNL
	SKIPGE A,QUSR(Q)
	JRST COS2B3	;CHNL CLOSED IN MEANTIME
	JUMPE A,COSSJ1	;SYSTEM JOB GET INTERLOCK SW INSTEAD
	PUSHJ P,CUSTP1	;STOP USER
COSSJ2:	LDB E,[MUR,,MEMBLT(J)]
	LDB TT,[M2311C,,MEMBLT(J)]
	CAMN TT,Q
	CAIE E,MU23B
	JRST COS2B4	;CHECK FOR VARIOUS TIMING ERRORS RECYCLE IF SO
	CAME A,QUSR(Q)
	JRST COS2B4
	PUSHJ P,MEMMF	;GOBBLE NEW BLOCK
	LDB TT,[MLO,,MEMBLT(J)]	;CHECK STATUS OF OLD BLOCK
	CAIN TT,-4&377
	JRST 4,.	;PI SHOULD HAVE CLEARED OUT
	CAIN TT,-3&377
	JRST COS2B5	;MN PRGM
	MOVEI C,QBFP-MEMBLT(Q)	;SEARCH THRU BLOCK LIST
COS2B6:	MOVE B,C
	LDB C,[MLO,,MEMBLT(B)]
	CAIL C,376
	JRST 4,.	;REACHED END AND NOW FOUND
	LDB TT,[M2311C,,MEMBLT(C)]
	CAME TT,Q
	JRST 4,.	;CHNL NOT RIGHT
	CAIE C,(J)
	JRST COS2B6
	CAIGE B,10.
	JRST 4,.	;UNREASONABLE PRECEEDING BLOCK NO
	DPB D,[MLO,,MEMBLT(B)]	;RELOCATE PNTR TO THIS BUFFER
	HLRZ TT,QBFP(Q)
	CAIN TT,(J)
	HRLM D,QBFP(Q)	;ALSO RELOCATE END PNTR IF NECESSARY
COS2B7:	PUSHJ P,CMOVE1	;MOVE DATA ETC
	MOVSI E,BCSTOP
	HRRZ A,QUSR(Q)
	MOVEI T,2
	SKIPN A
	PUSHJ P,LSWPON	;RELEASE SYSTEM JOB INTERLOCK
	ANDCAM E,USTP(A)	;RESTART USER
	MOVSI E,404000
	ANDCAM E,QSRAC(Q)	;UNLOCK CHNL
	JRST CBMRT

COSSJ1:	AOSN SJDH
	JRST COSSJ3	;INTERLOCK AVAILABLE
	SETOM CUDLF
	MOVSI E,200000
	IORM E,MEMBLT(D)	;SET ALLOC INHIBIT BIT
	ANDCAM TT,QSRAC(Q)	;UNLOCK CHNL AVOID HANG UP IF SYS JOB IN DISK ROUTINES
	PUSHJ P,LSWPOP
	PUSHJ P,SWTL
	SJDH
	IORM TT,QSRAC(Q)	;RE LOCK CHNL SYS JOB CANNOT BE IN DISK ROUTINES
	PUSHJ P,SWTL
	MEMFRZ
	ANDCAM E,MEMBLT(D)
	SKIPE QUSR(Q)
	JRST COS2B4	;CHNL HAS BEEN CLOSED IN MEANTIME
	JRST COSSJ2

COSSJ3:	PUSHJ P,SWTLZ
	SJDH
	JRST COSSJ2

COS2B1:	SETOM CUDLF	;MEM IS GOING TO BE UNLOCKED
	MOVSI E,200000
	IORM E,MEMBLT(D)	;SET ALLOC INHIBIT BIT
	PUSHJ P,LSWPOP	;RELEASE MEMFRZ TO OTHER I/O CAN PROCEED
	SKIPL QSCABN(Q)
	PUSHJ P,UFLS	;WAIT FOR ACTIVE BUFFER TO CLEAR
	PUSHJ P,SWTL
	MEMFRZ
	ANDCAM E,MEMBLT(D)
	JRST COS2B2

COS2B4:	MOVEI T,2
	SKIPN A
	PUSHJ P,LSWPON	;UNLOCK SJDH
	MOVSI E,BCSTOP
	ANDCAM E,USTP(A)
COS2B3:	MOVSI E,404000	;CLEAR BITS AND TRY AGAIN ON BLOCK
	ANDCAM E,QSRAC(Q)
	JRST CORS2

COS2B5:	HRRZ TT,QSMDN(Q)	;BUFFER ACTIVE AT MAIN PRGM
	CAIE TT,(J)
	JRST 4,.	;PNTRS FOULED UP
	HRRZM D,QSMDN(Q)
	DPB D,[121000,,QSMPRP(Q)]
	JRST COS2B7


DEVSTP:
IFN VIDP,[
	CAMN U,SCNUSR	;STOP DIRECT MEM DEVICES
	PUSHJ P,SCNSTC	;STOP DIRECT VIDI INPUT
]
IFN 340P,[
	CAMN U,DISUSR	;STOP DISPLAY IF THIS GUY HAS IT
	PUSHJ P,DCRSTP
]
	POPJ P,

DEVSTR:	LPMR UPGML+LUBLK	;CLEAR EXEC ASSOC REGS
IFN VIDP,[
	CAMN U,SCNUSR	;RESTART DIRECT MEM DEVICES
	PUSHJ P,SCNRST	;RESTART DIRECT VIDI INPUT
]
IFN 340P,[
	CAMN U,DISUSR
	PUSHJ P,DCRRST	;RESTART 340
]
	POPJ P,

	;BLOCK IS A USER BLOCK
CORS4:	SKIPGE MMSWP(J)
	JRST 4,.	;BLOCK IS ON SWAP OUT LIST
	PUSHJ P,UCPRL7	;CANT BE BEING SWAPPED OUT ETC BECAUSE SWAPOUT BLOCKS HAVE MUR= MU23B
	SETZ CORSTU	;AND CIRPSW SEIZED
	TLC C,200	;CHANGE TO 20 BIT BYTE 
	DPB D,C		;RELOCATE PTR 
	PUSHJ P,CMOVE2	;MOVE CONTENTS OF BLOCK
	MOVSI C,-NEXPGS
	MOVE T,[442200,,EXEUMP]
	PUSHJ P,CORPS1
CORS4J:	PUSHJ P,UCPRL4
	SETZ CORRST
	JRST CBMRT

CORSTU:	MOVE A,U
	PUSHJ P,CUSTP1	;STOP USER
	PUSHJ P,DEVSTP	;STOP DIRECT DEVICES
	MOVE Q,I	;COMPUTE USER'S MAP ENTRY LOCN
	MOVE C,UDBR1(U)
	TRZE Q,200
	MOVE C,UDBR2(U)
	ROT Q,-1
	ADDI C,(Q)
	HRLI C,222200
	SKIPGE Q
	HRLI C,2200
	LDB Q,C
	TRZN Q,600000
	POPJ P,	;PAGE SWAPPED OU BUT NOT YET LINKED UP
	ANDI Q,777
	CAIE Q,(J)
	JRST 4,.
	TLC C,2200#1100	;CHANGE TO 11 BIT BYTE
	DPB D,C	;RELOCATE USER'S MAP
	POPJ P,

;RUN AROUND CIRC LIST STRUCTURE
;4.9 RETURN ON USER 4.8 RET ON MMP 4.7 RET ON MEMPNT
;RETURN IN C BYTE POINTER TO PLACE THAT POINTS TO
;STARTING BYTE POINTER THAT WAS IN C
;---WARNING--- : CLOBBERS U -------

UCPRL7:	SKIPA C,[2200,,MEMPNT(J)]
UCPRL4:	MOVE C,[2200,,MEMPNT(D)]
UCPRL:	MOVE H,@(P)	;STARTING POINTER IN C
	HRRI C,@C
	TLZ C,37
	PUSH P,C
	PUSH P,C
	JRST UCPRL5

UCPRL2:	CAMN C,-1(P)
	JRST UCPRL6
	MOVEM C,(P)
UCPRL5:	LDB T,C
	JUMPE T,[JRST 4,.]
	TRZE T,400000
	JRST UCPRL1
	LDB I,[1000,,T]	;PAGE #
	LDB U,[101100,,T]	;USER #
	IMULI U,LUBLK
	CAML U,USRHI
	JRST 4,.
	SKIPGE H
	PUSHJ P,(H)
	MOVE C,UCPB1(U)
	TRZE I,200
	MOVE C,UCPB2(U)
	ROT I,-1
	ADDI C,(I)
	HRLI C,222200
	SKIPGE I
	HRLI C,2200
	JRST UCPRL2

UCPRL1:	TRZE T,200000
	JRST UCPRL3
	CAML T,MMPMX
	JRST 4,.	;MMP ADR OUT OF RANGE
	MOVSI C,2200	;MMP
	HRR C,MMPEAD
	ADDI C,(T)
	TLNE H,200000
	PUSHJ P,(H)
	JRST UCPRL2

UCPRL3:	CAIL T,TSYSM
	JRST 4,.	;MEMBLT ADR OUT OF RANGE
	TLNE H,100000	;MEMPNT
	PUSHJ P,(H)
	MOVE C,[2200,,MEMPNT]
	ADDI C,(T)
	JRST UCPRL2

UCPRL6:	MOVE C,(P)
	SUB P,[2,,2]
	JRST POPJ1

CORPS1:	MOVEI I,0
CORPS4:	ILDB Q,T	;RELOCATE ANY EXEC PGS POINTING AT THIS ONE
	ANDI Q,777
	TLC T,3300	;CHANGE SIZE FIELD TO 11
	CAME Q,J
	JRST CORPS3
	AOS I	;COUNT # OF EXEC PGS POINTING TO THIS ONE
	DPB D,T	;RELOCATE EXEC PG PNTR
CORPS3:	TLC T,3300	;CHANGE BACK TO 22
	AOBJN C,CORPS4
	HLRZ T,MMSWP(D)
	CAME T,I
	JRST 4,.	;EXEC PGS COUNT OFF
	POPJ P,

CORRST:	PUSHJ P,DEVSTR
	MOVSI Q,BCSTOP
	ANDCAM Q,USTP(U)
	POPJ P,

	PUSHJ P,COSIN2
COSIN1:	PUSHJ P,UFLS
	PUSHJ P,SWTL
	MEMFRZ
	JRST CORS2

COSINP:	PUSHJ P,LSWPOP
	HRRZ T,J
	JRST COSIN1

COSIN2:	LDB T,[MUR,,MEMBLT(T)]
	CAIE T,MUINP
	AOS (P)
	POPJ P,

UTBFF:	PUSHJ P,SWTL
	MEMFRZ
	MOVSI J,-TSYSM
UTBFF3:	LDB R,[MUR,,MEMBLT(J)]
	CAIN R,MUIOB
	JRST UTBFF2
	AOBJN J,UTBFF3
	JRST 4,.
UTBFF2:	HRRZS J
	TDZA R,R
COSIO:	MOVNI R,1
	MOVEM R,UTRMF	;UTAPE BUFFER MOVE FLG
	LDB R,[MLO,,MEMBLT(J)]
	CLEARB Q,TT
COSIO1:	MOVSI E,200000	;ALLOC INH ALL BUFFERS IN BLOCK
	IORM E,IOBFT(R)
	LDB E,[IOCH,,IOBFT(R)]
	CAIE E,77
	AOS Q	;COUNT NUMBER USED FOR SOMETHING
	LDB R,[IOLC,,IOBFT(R)]
	CAIE R,377
	AOJA TT,COSIO1
	CAIE TT,7
	JRST 4,.
	MOVNI TT,8
	ADD TT,Q	;GET - # USED
	ADD TT,UTTBF	;N OF THE FREE ONES ARE IN THIS BLOCK
	MOVN R,Q
	ADDB R,UTTBF	;RESERVE BUFFERS
	CAMGE R,[-8]	;R GETS BUFS FREE IN OTHER BLOCKS
	JRST 4,.
	MOVEM Q,CSIOT1
	CAMG Q,TT
	JRST COSIO3	;CAN RELOCATE TO FREE BUFFERS IN BLOCKS ALREADY RESERVED FOR IO
	SKIPL UTRMF
	JRST UTBFF1	;CANT FIT STUFF WITHOUT ANOTHER BLOCK, SO ABANDON IDEA OF FREEING BLOCK
	PUSHJ P,MEMMF
	PUSHJ P,TCALL
	JRST UTMGB
COSIO3:	SKIPGE UTTBF
	JRST 4,.
	LDB R,[MLO,,MEMBLT(J)]
COSIO4:	LDB Q,[IOCH,,IOBFT(R)]
	CAIN Q,77
	JRST CIUFR	;FREE
	CAIGE Q,NUTIC+NUTOC
	JRST CIUTB	;UT BUFFER
	CAIN Q,NUTIC+NUTOC
	JRST COSUTD	;UT DIR
	CAIGE Q,NFNETC
	JRST CICLB	;CORE LINK BUFFER
	CAIGE Q,NFNETC+NNETCH
	JRST CINET	;NET BUFFER
	JRST 4,.

UTBFF1:	LDB R,[MLO,,MEMBLT(J)]	;NOT 8 FREE NOW
	MOVSI E,200000
UTBFF4:	ANDCAM E,IOBFT(R)
	LDB R,[IOLC,,IOBFT(R)]
	CAIE R,377
	JRST UTBFF4
UTBFF5:	SOS NCORRQ
	PUSHJ P,LSWPOP
	JRST CORJOB

CIUTB:	MOVSI E,100000
	IORM E,UTRAC(Q)
	MOVEI T,400000
	TDNN T,UTRAC(Q)
	JRST CIUW1
CIUW2:	TLO E,400000
	IORM E,UTRAC(Q)
	LDB C,[IOLO,,IOBFT(R)]
	CAIN C,-4&377
	JRST 4,.	;SHOULD HAVE CLEARED OUT
	HLRZ A,UTUSR(Q)
	PUSHJ P,CUSTP1
	LDB T,[IOCH,,IOBFT(R)]
	CAME T,Q
	JRST CIUTB2	;CONDITIONS HAVE CHANGED
	LDB T,[IOLO,,IOBFT(R)]
	CAME T,C
	JRST CIUTB2
	PUSHJ P,COSIMG
	DPB C,[IOLO,,IOBFT(A)]
	CAIN C,-3&377
	JRST CIUBT4
	MOVEI C,UTBFP-IOBFT(Q)
CIUBT3:	MOVE B,C
	LDB C,[IOLO,,IOBFT(B)]
	CAIL C,-4&377
	JRST 4,.
	LDB TT,[IOCH,,IOBFT(C)]
	CAME TT,Q
	JRST 4,.
	CAME C,R
	JRST CIUBT3
	DPB A,[IOLO,,IOBFT(B)]
	HLRZ C,UTBFP(Q)
	CAMN C,R
	HRLM A,UTBFP(Q)
COSIO5:	HLRZ A,UTUSR(Q)
	MOVSI E,BCSTOP
	ANDCAM E,USTP(A)
	MOVSI E,500000
	ANDCAM E,UTRAC(Q)
COSIO2:	LDB R,[IOLC,,IOBFT(R)]
	CAIE R,377
	JRST COSIO4
	MOVE A,CSIOT1
	ADDM A,UTTBF	;RELEASE ANY BUFFERS THAT MAY HAVE BECOME FREE ON OWN ACCORD
	LDB A,[MLO,,MEMBLT(J)]
COSIO6:	LDB R,[IOLC,,IOBFT(A)]
	PUSHJ P,TCALL
	JRST IOBR
	MOVE A,R
	CAIE A,377
	JRST COSIO6
	MOVNI A,8
	ADDB A,UTTLB
	CAMGE A,[-NUTIC-NUTOC]
	JRST 4,.
	PUSHJ P,FSCMP
	SKIPGE UTRMF
COSIO7:	JRST CBMRT
	HRRZ A,J
	PUSHJ P,CMEMR
	JRST UTBFF5

CIUFR:	MOVEI Q,UTFS-IOBFT	;PNTR TO F.S. LIST
	CONO PI,UTCOFF
CIUFR1:	MOVE E,Q	;REMOVE IOBFT ENTRY IN R FROM F.S. LIST
	LDB Q,[IOLO,,IOBFT(Q)]
	CAIN Q,377
	JRST 4,.
	CAME Q,R
	JRST CIUFR1
	LDB Q,[IOLO,,IOBFT(R)]
	DPB Q,[IOLO,,IOBFT(E)]
	CONO PI,UTCON
	SOS UTTBF
	JRST COSIO2


COSIMG:	PUSHJ P,COSIG
COSIM:	LDB TT,[IOSA1,,IOBFT(R)]	;TRANSFER BUFFER R TO BUFFER A
	LDB T,[IOSA1,,IOBFT(A)]
	HRL T,TT
	LSH T,7
	HRRZ TT,T
	BLT T,177(TT)
	POPJ P,

CIUW1:	PUSH P,T
	PUSHJ P,LSWPOP
	POP P,T
	TDNN T,UTRAC(Q)	;WAIT FOR BUFFER TO COMPLETE
	PUSHJ P,UFLS
	PUSHJ P,SWTL
	MEMFRZ
	SETOM CUDLF
	MOVSI E,100000
	ANDCAM E,UTRAC(Q)
	JRST COSIO4

COSIG:	PUSH P,D
	MOVE D,Q
	CONO PI,UTCOFF
	SOSGE CSIOT1
	JRST 4,.
	AOS UTTBF	;HAD ALREADY RESERVED IT
	PUSHJ P,IUTCONS
	JRST 4,.
	CONO PI,UTCON
	POP P,D
	POPJ P,

COSUDC:	CONO PI,UTCON
	JRST COSUDB

CIUTB1:	ANDCAM E,UTRAC(Q)
COSUDB:	MOVE T,R
	PUSHJ P,LSWPOP
	JRST CIUBT6

	PUSHJ P,CIUBT5
CIUBT6:	PUSHJ P,UFLS
COSUD7:	SETOM CUDLF
	PUSHJ P,SWTL
	MEMFRZ
	JRST COSIO4

CIUBT5:	LDB T,[IOLO,,IOBFT(T)]
	CAIE T,-4&377
	AOS (P)
	POPJ P,

CIUTB2:	ANDCAM E,UTRAC(Q)
	HLRZ A,UTUSR(Q)
	MOVSI E,BCSTOP
	ANDCAM E,USTP(A)
	JRST COSIO4

CIUBT4:	HLRZ B,UTMBN(Q)
	CAME B,R
	JRST 4,.
	HRLM A,UTMBN(Q)
	LDB B,[IOSA1,,IOBFT(A)]
	DPB B,[71300,,MPRP(Q)]
	JRST COSIO5

CICLB:	MOVSI E,400000	;SHUFFLE CORE LINK BUFFER
	IORM E,CLRAC-SCNCLO(Q)	;LOCK BUFFER
	PUSHJ P,SWTL	;SEIZE VAR MODIFY LOCK
	CLOSW
	HRRZ A,CLUSR-SCNCLO(Q)
	PUSHJ P,NJRPCL	;STOR READING USER (IF ANY)
	HLRZ A,CLUSR-SCNCLO(Q)
	PUSHJ P,NJRPCL	;STOP WRITING USER (IF ANY)
	SKIPN CLSYN-SCNCLO(Q)
	JRST CICLB2	;BUFFER HAS BECOME FREE
	PUSHJ P,COSIMG	;MOVE BUFFER
	LDB C,[IOSA1,,IOBFT(A)]
	MOVE E,C
	LSH E,7
	IRPC X,,[1234]
	DPB C,[71300,,X(E)]	;RELOCATE POINTERS
	TERMIN
	HRRM A,CLRAC-SCNCLO(Q)	;SET CLRAC
CICLB2:	HRRZ A,CLUSR-SCNCLO(Q)
	PUSHJ P,NJUPCL	;RESTART
	HLRZ A,CLUSR-SCNCLO(Q)
	PUSHJ P,NJUPCL	;RESTART
	PUSHJ P,LSWPOP	;RELEASE
	MOVSI E,400000
	ANDCAM E,CLRAC-SCNCLO(Q)	;UNLOCK
	JRST COSIO2


CINET:
IFE NETP,JRST 4,.
IFN NETP,[
	CONO PI,CLKOFF
	HRRZ A,IMSOC1-NFNETC(Q)
	JUMPE A,CINET5	;NO USER
	PUSHJ P,CUSTP1	;STOP USER
	MOVSI T,200000	;ACTIVE AT PI LEVEL
	PUSHJ P,LWAIT
	TDNE T,IMSOC6-NFNETC(Q)
	SKIPN IMSOC6-NFNETC(Q)
	JRST CINET2	;BUFFER HAS BEEN RETURNED
	MOVSI T,400000
	IORM T,IMSOC6-NFNETC(Q)
	CONO PI,UTCON
	LDB E,[221000,,IMSOC6-NFNETC(Q)]
	CAIE E,(R)
	JRST 4,.
	PUSHJ P,COSIMG	;COPY BUFFER
	LDB E,[IOSA,,IOBFT(A)]
	LSH E,6
	MOVE T,E
	HRL E,A
	TLO E,400000
	EXCH E,IMSOC6-NFNETC(Q)
	SUBI T,(E)	;NEW-OLD=OFFSET
	MOVE E,IMSOC2-NFNETC(Q)
	TRNE E,1
	JRST CINET3
	ADDM T,IMSCIP-NFNETC(Q)	;RELOC IF RECEIVE SOCKET
	AOS IMNISH
	JRST CINET4

CINET3:	AOS IMNOSH
CINET4:	CONO PI,NETOFF
	MOVE E,IMSOC6-NFNETC(Q)
	TLNN E,100000
	JRST CINET1
	MOVE E,IMPSVI
	MOVEM E,IMPPIA
	CONO IMP,(E)
CINET1:	MOVSI E,500000
	ANDCAM E,IMSOC6-NFNETC(Q)
	CONO PI,NETON
	HRRZ T,IMSOC1-NFNETC(Q)
	MOVSI E,BCSTOP
	ANDCAM E,USTP(T)
	PUSHJ P,IMPOST	;RESTART OUTPUT
	JRST COSIO2

CINET2:	CONO PI,UTCON
	MOVSI T,BCSTOP
	ANDCAM T,USTP(A)
	JRST COSIO4

CINET5:	SKIPE IMSOC6-NFNETC(Q)
	JRST 4,.
	CONO PI,CLKON
	JRST COSIO4
]

COSUTD:	CONO PI,UTCOFF
	LDB H,[IOLO,,IOBFT(R)]	;GET DRIVE NUMBER
	CAIN H,-4&377
	JRST COSUDC
	CAILE H,NUNITS
	JRST 4,.
	SKIPGE UFLAPF(H)
	JRST COSUD1
	LDB C,[420200,,UDIRO(H)]
	JUMPN C,COSUD8
	MOVSI C,600000
	IORM C,UDIRO(H)
	CONO PI,UTCON
	PUSHJ P,COSIMG
	DPB H,[IOLO,,IOBFT(A)]
	LDB C,[IOSA1,,IOBFT(A)]
	DPB C,[71300,,UDIRO(H)]
	MOVSI T,-NUDCH
COSUD2:	SKIPE DSKLST(T)
	JRST COSUD3
	CAMN H,UDUSR(T)
	DPB C,[71300,,DIRPT(T)]
COSUD3:	AOBJN T,COSUD2
	HRRZ T,ULDCH(H)
	CAME T,R
	JRST 4,.
	HRRM A,ULDCH(H)
	HRRE T,DCHNT(H)
COSUD4:	JUMPL T,COSUD5
	DPB C,[71300,,UTDIRP(T)]
	HRRE T,UTUL(T)
	JRST COSUD4

COSUD5:	MOVSI C,600000
	ANDCAM C,UDIRO(H)
	JRST COSIO2

COSUD8:	MOVEI T,UDIRO(H)
	JRST COSUD9

COSUD1:	MOVEI T,UFLAPF(H)
COSUD9:	CONO PI,UTCON
	PUSH P,T
	PUSHJ P,LSWPOP
	POP P,T
	JRST COSUD6

	PUSHJ P,COSUDA
COSUD6:	PUSHJ P,UFLS
	JRST COSUD7

COSUDA:	LDB T,[420200,,(T)]
	SKIPN T
	AOS (P)
	POPJ P,

IFN 340P,[
DCRSTP:	SKIPE 340MD
	POPJ P,	;BUFFER NOT IN USER CORE SO NO ACTION
DCRST1:	SETOM CDISOF
	CONO DIS,0
	POPJ P,

DCRRST:	SKIPE 340MD	;DISPLAY RESTART
	POPJ P,
	SKIPL DISOFF
	CONO DIS,SDCHN_3+DISCHN
	CLEARM CDISOF
	POPJ P,

COSDB:	CONO PI,CLKOFF
	SKIPG 340BF
	JRST 4,.
	MOVE A,DISUSR
	JUMPL A,CDB1
	PUSHJ P,CUSTP1
	PUSHJ P,DCRST1
	PUSHJ P,MEMMF
	PUSHJ P,CMOVE1
	DPB D,[121000,,340BF]
	DPB D,[121000,,340BFP]
	MOVEI TT,-1(D)
	DPB TT,[121000,,IDBLKP]
	MOVE TT,IDBLKP
	MOVEM TT,DBLKOP
	CONO DIS,100+SDCHN_3+DISCHN
	CLEARM CDISOF
	MOVE A,DISUSR
	MOVSI TT,BCSTOP
	ANDCAM TT,USTP(A)
	JRST COSIO7

CDB1:	SETOM 340BF
	JRST COSIO7

]
COSMRT:	CONO PI,UTCOFF
	HRRZ A,J
	MOVEI B,IMMRT
CMR1:	CAML B,IMMRP
	JRST 4,.
	CAME A,1(B)
	AOJA B,CMR1
	SETOM 1(B)
	JRST COSIO7


ACMTC1:	CONO PI,UTCON
ACMTC:	MOVE A,IMMRP
	CAIN A,IMMRT
	POPJ P,
	CONO PI,UTCOFF
	SOS A,IMMRP
	MOVE A,1(A)
	JUMPL A,ACMTC1
	LDB B,[MUR,,MEMBLT(A)]
	CAIE B,MUFRT
	JRST 4,.
	PUSHJ P,MEMR
	JRST ACMTC



EBLK
CUDLF:	0
CDISOF:	0	;DIS OFF IN CORE ALLOC
BBLK

CMOVE2:	PUSHJ P,MEMMF
CMOVE1:	MOVE C,MEMBLT(J)
	MOVEM C,MEMBLT(D)
	MOVE C,MEMPNT(J)
	MOVEM C,MEMPNT(D)
	CLEARM MEMPNT(J)
	MOVE C,MMSWP(J)
	MOVEM C,MMSWP(D)
	HRRZ A,D
	CAIGE A,SYSB
	JRST 4,.
	TRO D,600000
	TRO J,600000
	DPB D,[.CORJT+EXEUMP]	;MOVE BLOCK IN J TO BLOCK IN D
	DPB J,[.CORJF+EXEUMP]
	TRZ D,600000
	TRZ J,600000
	LPMR UPGML+LUBLK
	MOVE A,[400000+CORJF*2000,,400000+CORJT*2000]
	BLT A,400000+CORJT*2000+1777
	MOVEI A,0
	DPB A,[.CORJT+EXEUMP]
	DPB A,[.CORJF+EXEUMP]
	POPJ P,

MEMMF:	LDB A,[MUR,,MEMBLT(D)]
	CAIE A,MUFR
	JRST 4,.
	HRRZ A,D
	CAIL A,200
	JRST 4,.	;BLOCK HAD BETTER BE IN LOW HALF OF LOW MOBY
	PUSHJ P,TCALL
	JRST MPOUT
	POPJ P,

UDELAY:	PUSH P,T
	MOVE T,TIME
	ADDI T,15.	;GIVE LOW PRIORITY FOR 1/2 SEC
	JRST UDELA1

	PUSHJ P,UDELA2
UDELA1:	PUSHJ P,UFLS
	JRST POPTJ

UDELA2:	CAMG T,TIME
	JRST POPJ1
	JRST POPJ3

CZRR:	CAIGE A,SYSB
	JRST 4,.
	TRO A,600000
	DPB A,[.CORJT+EXEUMP]
	LPMR UPGML+LUBLK
	CLEARM 400000+CORJT*2000
	PUSH P,A
	MOVE A,[400000+CORJT*2000,,400000+CORJT*2000+1]
	BLT A,400000+CORJT*2000+1777
	MOVEI A,0
	DPB A,[.CORJT+EXEUMP]
	JRST POPAJ

IOMQ:	PUSHJ P,MQTEST
	POPJ P,
	JRST IMRQ6

MQTEST:	MOVE A,MEMFR	;CALL ONLY AT UTC LEVEL OR WITH UTC OFF
	SUB A,NCBCOM
	JUMPLE A,CPOPJ
	SKIPLE MEMFR
	SKIPL MEMFRZ
	POPJ P,
	JRST POPJ1

HMRQC:	PUSHJ P,MQTEST
	POPJ P,
HMEMRQ:	PUSH P,B
	PUSH P,E
	MOVEI B,MEMHPT-MEMBLT
HMRQ3:	HRRZ A,MEMBLT(B)
	JUMPE A,HMRQ1	;HIGH HALF FULL TRY LOW
	LDB E,[420200,,MEMBLT(A)]
	JUMPN E,HMRQ2
	LDB E,[MUR,,MEMBLT(A)]
	CAIE E,MUFR
	JRST 4,.
	HRRZ E,MEMBLT(A)
	HRRM E,MEMBLT(B)
	JUMPE E,HMRQ4
	LDB E,[MUR,,MEMBLT(E)]
	CAIE E,MUFR
	JRST 4,.
HMRQ4:	AOS -2(P)
	JRST HMRQ5

HMRQ1:	POP P,E
	POP P,B
	JRST IMRQ6	;THAT DIDNT WORK, TRY LOW HALF

HMRQ2:	MOVE B,A
	JRST HMRQ3

MMBRQ:	PUSHJ P,MQTEST
	POPJ P,
NMMRQ:	PUSH P,B	;GET BLOCK THAT WONT HAVE TO BE MOVED
	PUSH P,E
	MOVE E,SJBRES
	LDB A,[MLO,,MEMFP]
MMBRQ3:	CAIN A,377
	JRST IMRQR	;NOT AVAIL
	AOJE E,MMBRQ2	;THIS ONE FOR SYS JOB?
	LDB B,[420200,,MEMBLT(A)]
	JUMPN B,MMBRQ2	;OR LOCKED?
	CAIL A,LIOBLK	;OR TOO LOW
	JRST MMBRQ1	;NO GOBBLE
MMBRQ2:	LDB A,[MLO,,MEMBLT(A)]
	JRST MMBRQ3

UIMRQ:	MOVE A,IOBFC
	CAIGE A,8
	POPJ P,	;NOT ENOUGH ROOM IM IOBFT
	MOVE A,MEMFR
	SUB A,NCBCOM
	CAIG A,3
	POPJ P,
	PUSHJ P,MQTEST
	POPJ P,
IMRQ6:	SKIPL SJBRES
	JRST IMRQ6A
	LDB A,[MLO,,MEMFP]
	CAIN A,377
	POPJ P,
	LDB A,[MLO,,MEMBLT(A)]
	CAIN A,377
	POPJ P,
IMRQ6A:	MOVEI A,0
IMRQ7:	PI2SAF
	PUSH P,B
	PUSH P,E
IMRQ2:	LDB A,[MLO,,MEMBLT(A)]
	CAIE A,377
	JRST IMRQ3
	CLEARM MEMDSP	;NO MEM. AVAILABLE IN LOSER HALF
MPOUT1:
IMRQR:	POP P,E
	JRST POPBJ

IMRQ3:	LDB B,[420200,,MEMBLT(A)]
	JUMPN B,IMRQ2
	CAIGE A,SYSB
	JRST IMRQ2	;DON'T ALLOCATE PART OF THE SYSTEM
MMBRQ1:	AOS -2(P)	;CAUSE RETURN TO SKIP
	LDB E,[MUR,,MEMBLT(A)]
	CAIN E,MUFR
	JUMPN A,IMRQ4
	JRST 4,.	;BLOCK GOT PUT ON FREE STORAGE LIST WITHOUT USAGE FIELD GETTING "FREE"

IMEMR:	PI2SAF
	CAIGE A,TSYSM
	CAIGE A,SYSB
	JRST 4,.	;DON'T RETURN PART OF SYSTEM
	SKIPL MEMFRZ	;HERE OTHERWISE
	JRST IMEMR1
CIMEMR:	PUSH P,B	;ENTER HERE IF OK TO HACK WITH MEM FROZEN
	LDB B,[MUR,,MEMBLT(A)]	;I E CALLING FROM CORE ALLOCATOR
	CAIN B,MUFR
	JRST 4,.	;ALREADY FREE, LOSSAGE
	TRNE A,600
	JRST CIMEM1	;IN HIGH HALF OR HIGH MOBY
	LDB B,[MLO,,MEMFP]	;PICK UP HEAD OF APPRO FS LIST
	DPB B,[MLO,,MEMBLT(A)]	;STORE AS LINK OUT OF CURRENT WD
	CAIE B,377	;NO BLOCK PREVOUSLY ON LIST
	DPB A,[MLU,,MEMBLT(B)]	;MAKE FORMER HEAD'S BACK PNTR POINT TO CURRENT
	MOVEI B,0	;BACK PNTR (IF IN LOW GROUP)
	DPB B,[MLU,,MEMBLT(A)]
	DPB A,[MLO,,MEMFP]
	AOS LMEMFR	;BLOCK IN LOW HALF OF LOW MOBY
CIMEM2:	MOVEI B,MUFR
	DPB B,[MUR,,MEMBLT(A)]	;STORE FREE IN USER
	CLEARM MEMPNT(A)
	AOS MEMFR
	JRST POPBJ

CIMEM1:	MOVE B,MEMHPT
	HRRM B,MEMBLT(A)
	HRRM A,MEMHPT
	JRST CIMEM2


MGMEMR:	PUSH P,B	;MAG TAPE MEMR
	LDB B,[MUR,,MEMBLT(A)]
	CAIE B,MUMGB
	JRST 4,.
	POP P,B
MEMR:	CONO PI,UTCOFF
	PUSHJ P,IMEMR
	JRST UTCONJ

CMEMR:	CONO PI,UTCOFF
	PUSHJ P,CIMEMR
	JRST UTCONJ

IMEMR1:	PUSH P,B
	AOS IMMRC
	AOS B,IMMRP
	CAIL B,IMMRT+IMMRTL
	JRST 4,.
	MOVEM A,(B)
	MOVEI B,MUFRT
	DPB B,[MUR,,MEMBLT(A)]
	JRST POPBJ

MPOUT:	PI2SAF
MPOUT2:	JUMPE A,[JRST 4,.]	;ENTER HERE FROM INITIALIZATION IF HOLE FOUND
	PUSH P,B
	PUSH P,E
IMRQ4:	LDB B,[MLU,,MEMBLT(A)]	;LINK UP
	LDB E,[MLO,,MEMBLT(A)]	;LINK OUT
	JUMPE E,[JRST 4,.]
	JUMPN B,IMRQ5
	CAIN E,377
	JRST IMRQ5	;LAST BLOCK IN LIST
	LDB B,[MUR,,MEMBLT(E)]
	CAIE B,MUFR
	JRST 4,.	;DOESNT LINK TO A FREE BLOCK
	MOVEI B,0	;PUT BACK 0
IMRQ5:	CAIE E,377
	DPB B,[MLU,,MEMBLT(E)]	;STORE LINK UP OF PATCHED OUT BLOCK IN LINK OUT BLOCK
	TRNN A,600	;SKIP ON HIGH HALF OR HIGH MOBY
	CAIN B,377
	JRST 4,.
	DPB E,[MLO,,MEMBLT(B)]
IMRQ5B:	SOS LMEMFR	;FREE BLOCKS IN LOWER HALF
HMRQ5:	SOS MEMFR
	MOVEI B,MUINP	;IN PROCESS
	DPB B,[MUR,,MEMBLT(A)]
	JRST MPOUT1

TCALL:	CONO PI,UTCOFF
	PUSHJ P,@(P)
	SKIPA
	AOS (P)
	JRST UTCOJ1

EBLK

;MEMORY ALLOCATION TABLES

IOBFTL:	MXIOB	;BEG FOR GETSYS (MEMORY)
IOBFT:	REPEAT  MXIOB-1,176000,,.RPCNT+1	;MAX DYN ALLOC IO BUFFERS
	176000,,377	;4.9 FREEZE
	;4.8 ALLOC INHIBIT
IOCH=340600	;4.7-4.2 SYS CHN NO 77 => FREE
IOLC=241000	;4.1-3.3 LINK TO NEXT SEQ BUF IN CORE (W/IN 1K BLK)
IOLO==1000	; LINK TO FOLLOWING BUFFER OR
	;SPECIAL STATES LINK OUT
	;-1	LAST BUFFER CURRENTLY FILLED
	;-2   END OF FILE
	;-3   BUFFER ACTIVE AT MAIN PROG LEVEL
	;-4   BUFFER ACTIVE AT PI LEVEL
;IF CHN IS NUTIC+NUTOC (UTAPE FILE DIR) THEN IOLO IS TAPE NO
;CHNLS NUTIC+NUTOC+1 (NFCLC)=>$Q+NCLCH-1 ARE CORE LINK DEVICE
;CHNLS NFNETC => $Q+NNETCH-1 ARE NET CHNLS
SCNCLO==NUTIC+NUTOC+1

IOSA=101400	; BUFFER SA _-6
IOSA1==111300	;ONLY RELEVANT BITS FOR 200 WD BUFFERS


IOBFP:	0	;FREE STG TO IOBFT ENT
IOBFC:	MXIOB-8	;CNT OF AVAIL
			;LEAVE 8 AVAIL SO CORE HACKER CAN NOT RUN OUT

MEMLPG==128.	;GETS EXISTANT PGS IN LOW HALF
IFL SYSUSM-128.,MEMLPG==SYSUSM
MEMHPG==TSYSM-128.	;EXISTANT PGS IN HI HALF OF LOW MOBY
IFL MEMHPG, MEMHPG==0
IFG MEMHPG-128.,MEMHPG==128.

NHMPGS==TSYSM-256.	;PAGES IN HIGH MOBY
IFL NHMPGS,NHMPGS==0


LMEMFR:	IFLE SYSUSM-128.,SYSUSM-1	;FREE PAGES IN LOWER HALF
	IFG SYSUSM-128.,127.

MEMHPT:	MEMHP-MEMBLT	;FS PNTR FOR HIGH HALF PGS AND HIGH MOBY PAGES
MEMFP:
MEMBLT:	177400,,377_8+1	;POINTER AND ALSO WD FOR BLOCK 0
	REPEAT MEMLPG-1-1,176400,,<.-MEMBLT-1>_8.+.-MEMBLT+1
	176400,,<.-MEMBLT-1>_8+377
MEMHP:	IFLE MEMHPG,0
	IFG MEMHPG,[
	REPEAT MEMHPG-DDTPGS-1,	176400,,.-MEMBLT+1
	IFN NHMPGS,176400,,400
	IFE NHMPGS,176400,,0
LDDTADR==<.-MEMBLT>*2000	;LOWEST DDT ADR
	REPEAT DDTPGS,170400,,0
IFG NHMPGS,[
	REPEAT NHMPGS-1,176400,,.-MEMBLT+1
	176400,,
]
]

IFN .-MEMBLT-TSYSM,[PRINTX /MEMBLT LOSES!!!
/]
;4.9  FREEZE
;4.8 ALLOC INHIBIT
MUR=321000
MUEX==377	;EXEC
MUIOB==376	;200 WD BUFFERS
MUFR==375	;FREE
MUINP==374	;IN PROCESS
MUMGB==373	;MAG TAPE BUFFER
MUMMP==372	;MMP TABLE
MUDISB==371			;371 340 DISPLAY BUFFER
MUFRT==370		;370 BLOCK RETURNING TO FREE WHEN MEM LOCKED
MU23B==367		;367 2314 BUF	MWC (INCL MLU)=WORD COUNT 0=> ALL
MU23UD==366		;366 2314 USER DIR MLO=QSNUD SLOT
MU23MD==365		;365 2314 MASTER DIR
MU23TT==364		;364 2314 TUT MLO=DISK NO.
MU23LS==363		;363 2314 COPY OF USER DIR FOR LISTING
MUHOLE==362	;"HOLE" IN REAL MEM
MUDDT==361	;"DDT" PAGE
;ADD NEW MUR TYPES HERE ^
;ALSO UPDATE MSPL AND CORSDT

MSPL==361	;LOWEST SPECIAL CODE
MURUSR==1	;USER BLOCK TELL BY WHICH MEMPNT, ETC.

;IF 4.9=1, DONT SET UP ANY MORE EXEC PGS POINTING TO THIS ONE
;RH => MMP ADR

MLO==1000	;LINK DOWN
;IF MUR=367 SPECIAL STATES MLO
;-1 IF LAST BUFFER CURRENTLY FILLED
;-2 IF END OF FILE
;-3 BUFFER ACTIVE AT MN PRGM LEVEL
;-4 BUFFER ACTIVE AT PI LEVEL
;IOBFT LINK FIRST BUFFER IN AREA (MUR=376)
MLU=101000	;LINK UP
MWC==101200	;USED TO STORE WD COUNT ON 2311 INSTEAD OF MLU
;IF MUR =367 MLU = ACTIVE WORD COUNT
M2311C==221000	;IF MLU =367 GIVES 2311 CHNL NUMBER

IMMRP:	IMMRT	;POINTER TO BELOW
IMMRTL==100
IMMRT:	BLOCK IMMRTL	;BUF FOR BLKS OF MEM THAT BECOME FREE WHILE MEM FROZEN
IMMRC:	0	;NUMBER OF TIMES USED

;SYS MEM ALLOC VARIABLES
MEMDSP:	0	;-1 TRY HARD TO GET MEMORY 0 LOOK AROUND
MEMFRZ:	-1	;MEMORY FROZE
	0
EMEMTL==.-1	;END FOR GETSYS (MEMORY)

MEMPNT:	BLOCK TSYSM	;RH USED FOR CIRC MEM USE PNTR IF USER MEM
		;LH FOR DISK ADDRESS CAME FROM OR GOING TO (4.9-4.7 DSK #) (4.6-3.1 TRK #)

MMSWP:	BLOCK TSYSM	;IF USER MEM:
			;RH= NUMBER OF USERS IN CP
			;LH=NUMBER OF EXEC PAGES POINTING TO THIS ONE
			;IF SWAP COMMAND:
			;LH ASSOC MMP ADDR  RH LINK OR 0

MEMIDP==6	;NUMBER OF BITS IN IDENTIFIER FOR PAGEID
MEMIDL==2_MEMIDP
MEMIDM==MEMIDL-1	;MASK
MEMID:	REPEAT MEMIDL,0	;POINTS TO MMP ENTRY FOR PAGE WITH INDEX AS ID
MEMIDU:	0	;COUNT OF MEMID ENTRIES IN USE

MMPFS:	0	;FS POINTER TO MMPFS SPACE

;MMP TABLE - TWO WDS PER ENTRY
		;WD1 4.9 INDICATES A PUBLIC PAGE IF ON (ANYONE CAN ATTACH TO WRITE)
		;WD1 LH 4.8-4.7 => 0 IN   1 ON WAY IN   2 OUT    3 ON WAY OUT
			;4.6 => THIS PAGE HAS BEEN WRITTEN ON DISK AT LEAST ONCE
			;4.5 R/W PAGE ON INITIAL SWAPIN
		;WD1 RH CIRC MEM USE PNTR
		;WD2 LH READ DISK ADR OR 0
MMPNP:	0	;#MMP PGS ACTUALLY IN USE
MMPMX:	0	;HIGHEST VALID MMP INDEX (MMPNP*2000)
MMPEAD:	REPEAT NMMP,	CONC MMP,\.RPCNT,*2000+400000	;EXEC ADR
MMPPPP:	REPEAT NMMP,	CONC .MMP,\.RPCNT,+EXEUMP	;PNTR TO EXEC PC MP
MMMPG:	BLOCK NMMP	;BLOCK NOS OF BLOCKS ACTUALLY USED

;SYS CHANNEL ASSIGN
;  77=>FREE
; 0 - NUTIC+NUTOC-1 => UTAPE CHNL
;NUTIC+NUTOC (=NFCLC-1) =>UTAPE FILE DIR
;NFCLS-NFCLC+NCLCH-1 (=NFNETC-1) => CORE LINK
;NFNETC-NNETCH => NETWORK

BBLK
IOBCNS:	MOVEI A,IOBFP-IOBFT
IOBC1:	MOVE E,A
	LDB A,[IOLO,,IOBFT(A)]
	CAIN A,377
	JRST 4,.	;IOBFT POINTERS FOULED UP

IOBC2:	LDB B,[420200,,IOBFT(A)]
	JUMPN B,IOBC1
	LDB B,[IOLO,,IOBFT(A)]
	DPB B,[IOLO,,IOBFT(E)]
	SOS IOBFC
	POPJ P,


IOBR:	MOVE B,IOBFP	;RETURN IOBFT WORD
	CLEARM IOBFT(A)
	DPB B,[IOLO,,IOBFT(A)]
	MOVEM A,IOBFP
	MOVEI B,77
	DPB B,[IOCH,,IOBFT(A)]
	AOS IOBFC
	POPJ P,
IFN ARMP,[
NARMCH==11.

AARMOVE:	XCTR XR,[MOVE A,(J)]
	JUMPGE A,CPOPJ
	CAMGE A,[-100,,]
	JRST ILUUO
	CONO PI,CLKOFF
	CAMN U,ARMUSR
	JRST AARM1A
	SKIPL ARMUSR
	JRST ILUUO
;	CONO TIPDEV,0
;	CONI TIPDEV,C
;	JUMPE C,ILUUO	;DONT ALLOW ARM TO RUN WITHOUT TIPBRK
;	DATAI TIPDEV,C
;	TRNN C,1
;	JRST ILUUO	;WRIST DETENT OFF NORMAL- BARF
;	CONO TIPDEV,TIPBCH
	MOVEM U,ARMUSR
AARM1A:	CONO PI,CLKON
	MOVSI B,-NARMCH
AARM1:	SETZM ARMDF(B)
	SKIPN ARMF
	SETOM DESTIN(B)	;NOT PREV IN USE, INITIALIZE
	AOBJN B,AARM1
	SKIPN ARMF
	SETOM OMPXIF
	SKIPN ARMF
	PUSHJ P,IMXON	;START IMX
	SETOM ARMF	;ARM NOW IN USE
	SETOM DLSRCH
ARML:	XCTR XR,[MOVE E,(A)]	;PICK UP COMM
	LDB C,[220400,,E]
	JUMPE C,ARML1	;NO INDEX
	XCTR XRW,[HRRZ Q,(C)]
	ADD E,Q
	TLZ E,17
ARML1:	TLZE E,20
	XCTR XRW,[HRR E,(E)]
	LDB D,[360600,,E]	;CHNL
	LDB C,[300600,,E]	;OP
	CAIGE D,NARMCH
	CAIL C,NARMOP
	JRST ARMLOS
	PUSHJ P,@ARMOPT(C)
	AOBJN A,ARML
ADF1:	MOVSI D,-NARMCH
ADFL:	SKIPL A,ARMDF(D)
	JRST ADF2
	TLNE A,100000
	JRST .+3
	MOVE C,RMAXV(D)
	MOVEM C,MAXV(D)
ADF2:	AOBJN D,ADFL
	SETZM DLSRCH
	JUMPL B,POPJ1
	POPJ P,

ARMLOS:	SETZM DLSRCH
	JRST ILUUO

ARMOPT:	ASDEST	;0 SET DEST
	ASVEL	;1 SET VELOC
	ATDEST	;2 COMPARE COMPUTED POSN
	ATVEL	;3 COMPARE COMPUTED VELOC
	AADST	;4 COMPARE ACTUAL POS
	ARPOST	;5 READ CURRENT POSITION
NARMOP==.-ARMOPT

ARPOST:	LDB B,IMPXPP(D)	;READ POSITION
	XCTR XW,[MOVEM B,(E)]
	POPJ P,

ASDEST:	ANDI E,7777
	CAMGE E,DESMIN(D)
	MOVE E,DESMIN(D)
	CAMLE E,DESMAX(D)
	MOVE E,DESMAX(D)
	MOVEM E,DESTIN(D)
	MOVSI E,600000
ADFSET:	IORM E,ARMDF(D)
	POPJ P,

ASVEL:	ANDI E,7777
	CAMLE E,RMAXV(D)
	MOVE E,RMAXV(D)
	MOVEM E,MAXV(D)
	MOVSI E,500000
	JRST ADFSET

AADST:	LDB C,IMPXPP(D)	;COMPARE ACTUAL POSITION
	SUB C,DESTIN(D)
	JRST ATD1

ATDEST:	SKIPA C,DESTIN(D)	;COMPARE COMPUTED POSITION
ATVEL:	SKIPA C,VELOC(D)	;COMPARE COMPUTED VELOCITY
	SUB C,POST(D)
ATD1:	MOVMS C
	CAMLE C,E
	TLO B,400000
	POPJ P,

SERVO:	MOVSI A,-NARMCH
	AOSN OMPXIF
	JRST SERVI
SERV1:	MOVE T,DESTIN(A)
	SUB T,POST(A)
	SKIPN VELOC(A)
	JUMPE T,SERVX
SERV1A:	MOVN B,MAXV(A)
	MOVE C,VELOC(A)
	SUB C,MAXA(A)
	CAMGE C,B
	MOVE C,B
	MOVE B,VELOC(A)
	ADD B,MAXA(A)
	CAMLE B,MAXV(A)
	MOVE B,MAXV(A)
	CAMG T,B
	CAMGE T,C
	JRST SERV2
	MOVM D,T
	CAMLE D,MAXA(A)
	JRST SERV2
SERV3:	MOVEM T,VELOC(A)
	ADDB T,POST(A)
	IOR T,OMPXP(A)
	DATAO OMPX,T
SERVX:	AOBJN A,SERV1
SERVR:	JRST ARMSVR

SERV2:	SKIPGE T
	SKIPA D,C
	MOVE D,B
	SUB T,VELOC(A)
	MOVM E,D
	IMUL D,E
	IDIV D,MAXA(A)
	ASH D,-1
	CAMGE D,T
	SKIPA E,B
	MOVE E,C
	MOVE C,E
	XOR C,VELOC(A)
	JUMPGE C,SERV2A
	MOVE C,E
	XOR C,T
	JUMPGE C,SERV2A
	SKIPA T,VELOC(A)
SERV2A:	MOVE T,E
	JRST SERV3

SERVI:	LDB B,IMPXPP(A)	;INITIALIZE TO CURRENT ARM STATE
	MOVEM B,POST(A)
	SETZM VELOC(A)
	SKIPGE DESTIN(A)
	MOVEM B,DESTIN(A)
	IOR B,OMPXP(A)
	DATAO OMPX,B
	AOBJN A,SERVI
	JRST SERVR

AARMOFF:	CAME U,ARMUSR
	POPJ P,
	CONO TIPDEV,0
	SETZM ARMF
	PUSHJ P,IMXCL1
	SETOM ARMUSR
	POPJ P,

AARMRS:	CAME U,ARMUSR	;RESET ARM LOCK FLAGS
	POPJ P,
	MOVSI A,-NARMCH
AARMR1:	SKIPL ARMLOK(A)
	JRST AARMR2
	CONO PI,OMXOFF
	SETOM DESTIN(A)	;RELOAD ARM COMM FROM CURRENT POS
	CLEARM ARMLOK(A)
	SETOM OMPXIF
	CONO PI,OMXON
AARMR2:	AOBJN A,AARMR1
	POPJ P,


TIPBRK:	DATAI TIPDEV,B
	TRNE B,1	;WRIST DETENT
	JRST TIPBR2
	SETOM ARMLOK+ARMVRT	;UNHAPPINESS
TIPBR2:	EXCH B,TIPBR
	XOR B,TIPBR
	SKIPGE A,ARMUSR
	JRST TIPBR1
	ANDI B,7
	LSH B,ATPSFT
	IORM B,PIRQC(A)
TIPBR1:	JRST OMXRET


EBLK

;JOINT ASSIGN
;0-10 AMF SWING VERT HORIZ YAW TILT GRIP ROTATE EXTEND ROLL
;11-12 NEW VIDI FOCUS IRIS

ARMVRT==1	;CHNL # OF ARM VERT

DESMIN:	IRPS A,,0 41 233 0 0 0 0 0 0 0 0
	A
TERMIN
DESMAX:	IRPS A,,7777 7777 7323 7777 7777 7777 7777 7777 7777 7777 7777
	A
TERMIN
DESTIN:	BLOCK NARMCH	;-1 NOT COMMANDED   + VAL OF POSITION COMMAND
POST:	BLOCK NARMCH	;POSITION OF ARM AT PI LEVEL
VELOC:	BLOCK NARMCH
MAXV:	BLOCK NARMCH
ARMDF:	BLOCK NARMCH	;4.9 VARIABLE CHANGED 4.5 POS VAR 4.7 VEL 4.6 ACC
ARMLOK:	BLOCK NARMCH	;IF -1 AXIS LOCKED DO NOT ALLOW CHNG IN COMMAND

MAXA:	REPEAT NARMCH,14
RMAXV:	REPEAT NARMCH,140

OMPXP:	IRPS A,,2 3 4 6 7 12 11 10 5 32 31
	A,,
	TERMIN

IMPXPP:	IRPS A,,102 103 104 106 107 112 111 110 105 132 131
	301400-140000*<A-A/3*3>,,MPXBUF+A/3
	TERMIN

ARMUSR:	-1	;-1 OR INDEX OF USER DOING ARMOVE
OMPXIF:	0	;-1 => INITIALIZE DESTINS'S TO CURRENT ARM POSITION
ARMF:	0	;-1 ARM IN USE, 0 NO ARMOV EXECUTED
TIPBR:	0	;TIP BREAK REG LAST TIME READ IN
BBLK
]
IFN IMXP,[
APOTSE:	CONI MPX,T
	JUMPE T,ILUUO	;MPX NOT AVAIL
	MOVE C,B
APOTS1:	XCTR XR,[MOVE A,(C)]
	ANDI A,377	;GET IMPX CHNL
	JUMPE A,CPOPJ		;CHNL 0 = END OF LIST
	IDIVI A,3		;COMPUTE MPXBUF INDEX
	ADD A,MPXPT(B)		;FORM BYTE PTR
	MOVSI B,-NPOTCH		;SET UP TN DELETE PREVIOUS POT CONN
PTS1:	CAMN A,POTBPT(B)	;IS ENTRY FOR SAME CHNL
	SKIPG POTUSR(B)	;AND ACTIVE
	JRST PTS2		;NO,KEEP LOOKING
	CAME U,POTUSR(B)	;IS THIS USER THE ONE WHO MADE ENTRY
	JRST ILUUO		;NO,ILLEGAL
	PUSHJ P,NARK		;DEACTIVATE AND FREE ENTRY

PTS2:	AOBJN B,PTS1		;TRY NEXT ENTRY
	MOVEI B,400000		;MASK FOR DELETE ONLY
	XCTR XRW,[TDNE B,(C)]		;SKIP ON NEW ENTRY WANTED
	JRST PTSR		;TRY FOR NEXT BLOCK
	MOVSI B,-NPOTCH		;SET UP TO FIND FREE ENTRY
PTS3:	SKIPL POTUSR(B)		;SKIP ON FREE
PTS4:	AOBJN B,PTS3		;TRY OTHER SLOTS
	JUMPGE B,ILUUO		;NO SLOTS AVAIL
	CONO PI,CLKOFF		;PREVENT OTHER GRABBERS
	SKIPGE POTUSR(B)	;SKIP IF JUST TAKEN
	JRST PTS5		;OKAY FOR SURE
	CONO PI,CLKON		;REENABLE
	JRST PTS4		;TRY ANOTHER

PTS5:	SETZM POTUSR(B)		;MARK TAKEN
	AOS IMXNTO
	AOS POTCON		;INCREMENT NUMBER SLOTS IN USE
	PUSHJ P,IMXON		;START IMPX
	CONO PI,CLKON		;AND ENABLE
PTS6:	MOVEM A,POTBPT(B)	;SAVE PTR TO MPXBUF FOR MPX ROUTINE
	XCTR XRW,[HRRZ A,1(C)]		;GET USER ADR
	XCTR XRWI,[MOVES (A)]
	JRST .+2
	JRST PTSL1		;NO,LOSE
	XCTR XRW,[HLL A,1(C)]		;GET BYTE FIELDS
	TLNN A,777700		;IF NONE SPECIFIED
	TLC A,4400		;ASSUME FULL WORD
	TLZ A,77		;FLUSH INDEX,INDIRECT
	MOVEM A,POTVPT(B)	;SAVE AS USER MEM PTR FOR MPX ROUTINE
PTS7:	XCTR XR,[MOVE A,(C)]
	ANDI A,3	;GET FLOAT + ABS BITS
	MOVEI D,PUFLI		;ADDR OF FLOATING INCREMENTAL UPDATE
	TRNN A,1		;SKIP ON FLOATING
	MOVEI D,PUFXI		;ADDR OF FIXED INCREMENTAL UPDATE
	TRNE A,2		;SKIP ON NOT ABSOLUTE
	SOS D			;ABS ROUTINE STARTS ONE BEFORE INCREMENTAL
	MOVEM D,POTUPD(B)	;SAVE ROUTINE ADDR FOR MPX ROUTINE
PTS8:	XCTR XRW,[MOVN D,2(C)]		;GET LOWER LIMIT
	MOVNM D,POTOFS(B)	;SAVE AS OFFSET FOR MPX ROUTINE
	TRNE A,1		;SKIP ON FIXED
	JRST PTS9		;GO SET FLOATING PARAMS
	XCTR XRW,[ADD D,3(C)]		;UL-LL
	ASH D,-2		;SCALE MULTIPLIER

PTS9R:	MOVEM D,POTSCL(B)	;STORE SCALE FACTOR FOR MPX ROUTINE
	LDB D,POTVPT(B)		;GET CURRENT VARIABLE VALUE
	TRNE A,1		;SKIP ON FIXED
	JRST PTS10		;COMPUTE FLOATING INCR VALUE
	SUB D,POTOFS(B)		;D_VAL-LL FIXED
	MOVSI E,200000		;SET TO ROUND VALUE
	ASHC D,-25.		;SCALE TO GET 12 BIT VALUE
	DIV D,POTSCL(B)		;COMPUTE INCR VAL FOR VAR
PTS10R:	HRROM D,POTVAL(B)	;STORE INCR VALUE FOR MPX ROUTINE
	MOVEM U,POTUSR(B)	;STORE USER TO ACTIVATE MPX ROUTINE
PTSR:	ADDI C,4		;ADVANCE POINTER TO NEXT 4 WORD BLOCK
	JRST APOTS1		;GO SET MORE TABLE ENTRIES

PTS9:	FADR D,3(C)		;UL-LL IN FLOATING
	FSC D,-12.		;SCALE DOWN FOR POT RANGE
	JRST PTS9R		;RETURN WITH SCALE FACTOR

PTS10:	FSBR D,POTOFS(B)	;D_VAL-LL FLOATING
	FDVR D,POTSCL(B)	;COMPUTE INCR VAL FLOATING
	MULI D,400		;FIX INCR VAL
	TSC D,D			;WORK FOR BELOW LOWER LIMIT
	ASH E,-243(D)		;VALUE IN E
	MOVE D,E		;TO D LIKE FIXED
	JRST PTS10R		;RETURN WITH INCR VALUE


PTSL1:	PUSHJ P,NARK
	PUSHJ P,TPFLT
	JRST UUOTRO

;POTS UPDATE CALLED BY MPX ROUTINE

UPOTS:	SPM UPTPGT
	MOVSI A,-NPOTCH		;SET UP TO LOOP FOR ALL POT TABLE POSITIONS
	SETZM UPUSR		;INDICATE NO USER SET UP
UPOT1:	SKIPLE U,POTUSR(A)	;SKIP ON SLOT UNUSED OR IN PROCESS
	JRST UPOT2		;GO TRY TO UPDATE VAR
UPOTR:	AOBJN A,UPOT1		;TRY NEXT POT TABLE ENTRY
	LPMR UPTPGT	;RESTORE MAP
	JRST UPOTRT		;DONE

UPOT2:	CAMN U,UPUSR		;IS THIS USER LAST UPDATED
	JRST UPOT3		;YES, RELOCATION IS SETUP
	MOVE T,USTP(U)		;TEST TO SEE IF
	SKIPN UMAPS(U)	;MAP LOADED TO POINT TO OTHER USER
	TLNE T,BUCSTP+BCSTOP	;USER BEING MOVED
	JRST UPOTR		;YES DON'T UPDATE FOR HIM
	MOVEM U,UPUSR		;SAVE AS LAST USER SET UP
	LPMR UPGML(U)	;LOAD USERS MAP
UPOT3:	LDB B,POTBPT(A)		;GET CURRENT ABS POSITION
	HLRZ C,POTVAL(A)	;GET POS LAST TIME
	TRNE C,400000		;SKIP UNLESS FIRST TIME
	JRST UPOT3A
	MOVE T,B
	SUB T,C
	MOVMS T
	CAMG T,PTNOIS
	JRST UPOTR
UPOT3B:	HRLM B,POTVAL(A)	;SAVE FOR NEXT TIME
	SUB B,C			;GET AMOUNT OF INCREMENT
	CAIL C,5252		;SKIP IF NOT IN UPPER THIRD
	JUMPG B,UPOT4		;JUMP IF IN UPPER THIRD AND GOING UP
	CAIGE C,2525		;SKIP IF NOT IN LOWER THIRD
	JUMPL B,UPOT5		;JUMP IF IN LOWER THIRD AND GOING DOWN
UPOT6:	HRRE C,POTVAL(A)	;GET PREV INCREMENTAL VALUE
	ADD C,B			;UPDATE BY POT INCR
	CAILE C,7777		;IF NEW VALUE WOULD EXCEED 7777
	MOVEI C,7777		;CLAMP IT TO 7777
	CAIGE C,0		;IF NEW VALUE WOULD BE LESS THAN 0
	MOVEI C,0		;CLAMP IT TO 0
	HRRM C,POTVAL(A)	;STORE NEW INCR VALUE
	JSP B,@POTUPD(A)	;CALL ROUTINE TO COMPUTE NEW VARIABLE VALUE
	HRRZ T,POTVPT(A)	;STORE VAR IN USER MEM
	XCTR XRI,[MOVE B,(T)]
	JRST .+2
	JRST INARK
	MOVEI D,B
	HLL D,POTVPT(A)
	DPB C,D
	XCTR XWI,[MOVEM B,(T)]	;STORE VAR IN USER MEM
	JRST UPOTR

INARK:	SETOM POTUSR(A)	;THIS POT A LOSER, FLUSH
	SOS POTCON
	SOS IMPXF
	SOSGE IMXNTO
	DATAO DSDEVN,[MPX]
	JRST UPOTR		;RETURN FOR MORE POTS

UPOT4:	HRREI C,-6(B)		;C_DELTA-6
	IMULI C,3		;C_DELTA*3-22
	CAMLE C,B		;IF POT TURNED UP FAST
	MOVEM C,B		;THEN BOOST INCREMENT
	JRST UPOT6		;RETURN TO STORE

UPOT5:	HRREI C,6(B)		;C_DELTA+6
	IMULI C,3		;C_DELTA*3+22
	CAMGE C,B		;IF POT TURNED DOWN FAST
	MOVEM C,B		;THEN DECREASE DECREMENT
	JRST UPOT6		;RETURN TO STORE

PUFXA:	HLRZ C,POTVAL(A)	;ABS ENTRY, USE DIRECT VALUE
PUFXI:	MUL C,POTSCL(A)		;INCR ENTRY, SCALE VALUE
	ASHC C,25.		;200000,,=FULL WORD
	ADD C,POTOFS(A)		;OFFSET VALUE
	JRST (B)		;RETURN WITH USER FIELD VALUE

PUFLA:	HLRZ C,POTVAL(A)	;ABS ENTRY FOR FLOAT PT
PUFLI:	TLC C,232000		;FLOAT POT VALUE
	FAD C,C			;NORMALIZE
	FMPR C,POTSCL(A)	;SCALE FLOATING VALUE
	FADR C,POTOFS(A)	;ADD OFFSET
	JRST (B)		;RETURN WITH NEW FLOATING VAR VALUE

UPOT3A:	MOVE C,B		;FIRST TIME USE CURRENT VALUE
	JRST UPOT3B


NARK:	SETOM POTUSR(B)	;TURN OFF AND FREE POT CHANNEL
	SOS POTCON	;DECREMENT # OF SLOTS IN USE
	JRST IMXCL1	;FLUSH THIS USE OF MPX AND MAYBE DEASSIGN MPXR

POTCLS:	MOVEI A,NARK	;ON CLOSE FLUSH ALL ENTRIES FOR USER
POTCLA:	MOVSI B,-NPOTCH	;SET UP TO TEST ALL ENTRIES FOR USER U
POTCL1:	CAMN U,POTUSR(B)	;SKIP IF DIFFERENT USER
	PUSHJ P,(A)	;FLUSH IT MAYBE
	AOBJN B,POTCL1	;TRY ALL SLOTS
	POPJ P,	;DONE

EBLK
POTUSR:	REPEAT NPOTCH,-1	;-1=FREE, 0=PROCESS, +=USER INDEX
POTBPT:	BLOCK NPOTCH		;BYTE PTR INTO MPXBUF
POTVPT:	BLOCK NPOTCH		;BYTE PTR INTO USER MEM INDEXED BY R
POTVAL:	BLOCK NPOTCH		;DIRECT VALUE,,INCR VALUE
POTUPD:	BLOCK NPOTCH		;ADDR OF ROUTINE TO COMPUTE NEW VALUE
POTSCL:	BLOCK NPOTCH		;SCALE FACTOR FOR VARIABLE
POTOFS:	BLOCK NPOTCH		;OFFSET FOR VARIABLE
MPXPT:	REPEAT 3,301400-140000*.RPCNT,,MPXBUF	;POINTERS FOR 12 BIT MPX BYTES
UPUSR:	0	;USER FOR WHOM RELOC SETUP AND NOT STOPPED
UPTPGT:	BLOCK 8	;SAVE MAP

POTCON:	-1	;<NUMBER OF POTS CONNECTED>-1

PTNOIS:	3	;IGNORE ANY CHANGE < OR = THIS AS POT NOISE
]
IFN 340P,[
;
; DISPLAY INTERRUPT ROUTINE
;
DRECYC:	0
;
BBLK
;
	MOVEM A,LPTA
	MOVE A,DRECYC
	MOVEM A,LPTBRK
	MOVE A,[B,,LPTB]
	BLT A,LPTB+17-B+1-1
	JRST DRECY1
SRECYC:	MOVE A,[B,,LPTB]
	BLT A,LPTB+17-B+1-1
	CONSZ DIS,2000
	JRST DSLTPB	;LIGHT PEN BREAK
	SKIPGE 340MD
	JRST SRCYRB	;RANDOM BREAK
	CONSZ DIS,5000
	JRST SRCY4
DRECY1:
;	DATAI 710,A
;	SUB A,LQTIM
;	CAIL A,32000./2
;	JRST DISF2	;MISSING CLOCK BREAK DUE TO DIS
	HLRE A,DBLKOP
	SKIPL A
	TDZA A,A
	MOVNS A
	ADDB A,DWDS	;CREDIT BACK WDS NOT USED
	JUMPL A,DISF2
	HRRZS DBLKOP
	SKIPE 340MD
	JRST SRCY3	;IDS OR DIS
SRCY1:	HRRZ A,LDISP
	JUMPE A,ENDLIS
	JSP B,DPFTCH
	JUMPL A,SRCY2A	;SINGLE BLKO PNTR
	MOVEM A,LDISP	;LIST
	HLRZS A
	JUMPE A,SRCY5	;THIS ENTRY NULL
	JSP B,DPFTCH
	SKIPGE LMODE
	JRST SRCY1A	;DSTRT
SRCY1C:	JUMPGE A,SRCY5
	MOVEM A,LUBLKP	;SAVE FOR DEBUGGING
	HLRO C,A
	MOVNS D,C	;+ COUNT
	LDB E,[1200,,A]	;WD WITHIN PG
	ADD E,D
	LSH E,-10.
	AOS E
	MOVE J,E	;SAVE # EXEC PGS REQD
	SUBI E,N340PB
	JUMPG E,SRCY2B	;CANT MAKE IT IN ONE WHACK
	MOVN Q,E	;SAVE MAX ACCEPT STARTING EXEC PG #
	HRLZS E
	HRRZ C,A
	CAIGE C,20
	JRST DISLOS
	ANDI C,776000	;USER PG #
	MOVNI R,1	;BEST STARTING PLACE SO FAR
SRCY2D:	CAMN C,340DA(E)	;LOOK FOR PG SET UP TO RIGHT USER PG
	JRST SRCY2F	;FOUND ONE
SRCY2I:	AOBJN E,SRCY2D
	HRRZ E,R
	JUMPGE R,SRCY2C	;PARTIALLY SET UP PLACE FOUND
	AOS 340DP
	CAML Q,340DP	;NONE AVAIL, IS RING PNTR IN ACCEPTABLE AREA?
	SKIPA E,340DP	;YES
	CLEARB E,340DP	;NO RESET
SRCY2C:	MOVE R,DDAD(E)
	LSH R,-10.
	DPB R,[121000,,A]	;SWITCH BLKO PNTR TO EXEC MD PG
	MOVEM A,LDBLKP
	MOVEM A,DBLKOP
	HLRES A		;FOR GROSS DISPLAY LISTS
	ADDM A,DWDS	;APPROX TO WDS TO DISPLAY
	IDIVI A,1000.
	SOS A	;QUOTIENT MAY BE ZERO
	MOVEM A,DISDIE
	MOVNI A,EWRT
	ADDM A,DWDS
	ADDI E,2	;OFFSET FOR POINTER PAGES
	MOVEI A,0
SRCY2E:	CAME C,A340P1(E)	;PG SET TO RIGHT ADR?
	JRST SRCY2J	;NO SET UP
SRCY2K:	ADDI C,2000
	AOS E
	SOJG J,SRCY2E	;SET UP ALL PGS IN BLOCK
	CONSZ DIS,5400
	CONO DIS,100\SDCHN_3\DISCHN
	JRST SRCYCX

SRCY2J:	JSP B,DDFTC
	MOVEI B,-2(E)
	MOVEM B,340DP
	JRST SRCY2K

SRCY2B:	JRST DISLOS	;TEMP

SRCY2F:	MOVE D,J	;FIRST PAGE MATCHES, DO ENOUGH ADDITIONAL PAGES MATCH?
	SOJLE D,SRCY2C	;ONLY ONE PAGE NEEDED.  WINS
	MOVEI TT,2000(C)
	MOVEI R,1(E)
SRCY2H:	CAME TT,340DA(R)
	JRST SRCY2G	;NOT SET UP FOR WHOLE BLOCK
	ADDI TT,2000
	AOS R
	SOJG D,SRCY2H
	JRST SRCY2C	;SET UP FOR WHOLE BLOCK.  WIN

SRCY2G:	HRRZ R,E	;SAVE BEST SO FAR
	JRST SRCY2I
DPFTCH:	HRRZ C,A
	CAIGE C,20
	JRST DISLOS
	TRZ C,1777
	MOVSI E,-N340PB-2
DPFTC2:	CAME C,A340P1(E)	;PG SET UP TO RIGHT ADR?
	JRST DPFTC1	;NO
	TRZ A,776000	;YES RETCH REL ADR
	XCTR XI,[MOVE A,@DPAP(E)]
	JRST (B)	;NO FAULT
	JRST 4,.	;SHOULD HAVE BEEN VERIFIED WHEN LOADED

DPFTC1:	AOBJN E,DPFTC2	;LOOP ON ALL EXEC PNTR PAGES
	MOVE E,340PP	;NONE SET UP SO SELECT ONE TO SET UP
	AOS D,340PP	;INCR IT FOR NEXT TIME
	CAILE D,1
	CLEARM 340PP	;RESET
DDFTC:	SPM DPBS	;ENTRY FOR DATA PGS STORE MAP
	SKIPGE U,DISUSR
	JRST 4,.
	SKIPL CIRPSW
	JRST DDFTC2	;MAP MIGHT CHANGE
	SKIPGE A340P1(E)
	JRST DDFTC3
	SETOM A340P1(E)	;WIPE OUT OLD ENTRY
	LDB W,DPEP(E)	;PICK UP OLD PAGE
	TRZN W,600000	;NO ACCESS
	JRST 4,.
	ANDI W,777
	MOVEI R,0
	DPB R,DPEP(E)
	SKIPGE DDEXCF+340P1(E)
	JRST DDFTC3
	LDB R,[MUR,,MEMBLT(W)]
	CAIE R,MURUSR
	JRST 4,.
	MOVSI R,-1
	ADDM R,MMSWP(W)	;REDUCE COUNT OF EXEC REFS
DDFTC3:	MOVE W,C	;SET PAGE IN E TO PNT TO ADR IN C
	LSH W,-10.	;GET USR PG #
	TRZE W,200
	SKIPA D,UDBR2(U)	;GET HIS HI DBR
	MOVE D,UDBR1(U)	;LOW DBR
	ROT W,-1	;GET WD # AND SAVE WHICH HALF IN SIGN
	LDB R,[230700,,D]	;GET DBL
	CAIG R,(W)
	JRST DISLOS	;DBL LOSES
	ADDI D,(W)
	HLRZ R,(D)
	SKIPGE W
	HRRZ R,(D)	;PICKS UP PAGE ENTRY
	TRNE C,400000
	SKIPA TT,UCPB2(U)
	MOVE TT,UCPB1(U)
	ADDI TT,(W)
	HLRZ T,(TT)
	SKIPGE W
	HRRZ T,(TT)
	TRNN R,600000
	JRST DDFTC1	;NO ACCESS OR SWAPPED OUT
	LDB Q,[1100,,R]
	CAIN T,-1
	JRST DDFTC4	;ABS PG
	CAILE Q,TSYSM
	JRST 4,.
	SKIPGE MEMBLT(Q)
	JRST DDFTC2	;CAN'T SET UP EXEC PG POINTING TO THIS ONE
	LDB TT,[MUR,,MEMBLT(Q)]
	CAIE TT,MURUSR
	JRST 4,.
	CLEARM DDEXCF+340P1(E)
	MOVSI TT,1
	ADDM TT,MMSWP(Q)	;AOS COUNT OF EXEC PGS
DDFTC5:	MOVEM C,A340P1(E)
	DPB R,DPEP(E)	;STORE USERS PG ENTRY IN EXEC MAP
	LPMR DPBS	;RESET ASSOC REG
	ANDI A,1777	;FLUSH USER ADR EXCEPT WD IN PAGE
	XCTR XI,[MOVE A,@DPAP(E)]	;REF PAGE TO MAKE SURE ITS THERE, ETC
	JRST (B)
	JRST 4,.

DDFTC4:	SETOM DDEXCF+340P1(E)	;INDICATE PAGE POINTING TO ABS PAGE
	JRST DDFTC5

DDFTC1:	JUMPE R,DISLOS	;MAP COMPLETELY 0 MUST BE ILM
	JUMPE T,DISLOS	;ILM
	MOVEM U,DISSWI
	LDB W,[121000,,C]
	MOVEM W,DISSPG	;RQ PG IN
DDFTC2:	MOVNI A,3	;HANG FOR 3 60THS
	JRST DISF2A

SRCY1A:	JUMPGE A,SRCY1B
	MOVEI A,-1(A)
SRCY1D:	JSP B,DPFTCH
	SOJA A,SRCY1C

SRCY1B:	TLNN A,777000
	JRST SRCY5
	HLRZ A,LDISP
	JRST SRCY1D

SRCY3:	SOSGE DTIME
	JRST DISF	;LIMIT REPETITION RATE
	SKIPL NDSFMS	;SKIP ON FRAME HACK NOT ACTIVE
	JSP B,ENDFM1	;MAYBE STOP DISPLAY AFTER SPEC # OF FRAMES
	MOVE A,IDBLKP
	MOVEM A,DBLKOP
	CONO DIS,100\SDCHN_3\DISCHN
	SETOM DISDIE
	JRST SRCYCX

SRCY4:	CONO DIS,200\SDCHN_3\DISCHN	;EDGE GRONK DIS AND KEEP GOING
	JRST SRCYCX

DISF2:	MOVNI A,300.
DISF2A:	MOVEM A,DTIME
	SETOM DISON
	JRST DISF3

DISF:	SETOM DISON
DISF1:	MOVEI A,1
	MOVEM A,DTIME
DISF3:	CONO DIS,100
DISF4:	MOVEI A,DIS300-1
	MOVEM A,DBLKOP
SRCYCX:	MOVE A,[JSR DBLKPB]
	MOVEM A,40+2*DISCHN
	JRST LPTRT1

DIS300:	3000
	3000

DSLTPB:	DATAI DIS,LLTPSN
	AOS LTPCNT
	HRRZ A,LLTPSN
	ADDM A,LTPCY
	HLRZ A,LLTPSN
	ADDM A,LTPCX
	SKIPGE B,DISUSR
	JRST 4,.
	MOVEI A,BLTP
	AND A,MSKST(B)
	IORM A,PIRQC(B)
	CONO DIS,@LTPDCN
	JRST SRCYCX

EBLK

DBLKP1:	0
DBLKPB:	0

BBLK
	MOVEM A,DBLKP1
	MOVE A,[BLKO DIS,DBLKOP]
	MOVEM A,40+2*DISCHN
	MOVE A,DBLKP1
	JRST 12,@DBLKPB

SRCYRB:	CONI DIS,A
	SKIPGE A
	CONO DIS,100	;WOULD ASSIGN IF IDLE
	JRST SRCYCX

ENDLIS:	SETOM DISDIE
	MOVE A,DROOT
	MOVEM A,LDISP
	SOSGE DTIME
	JRST DISF	;LIMIT REPETION RATE
	SKIPL NDSFMS
	JSP B,ENDFM1	;HACK FRAME HACK
	CONO DIS,100\SDCHN_3\DISCHN
	JRST SRCY1

ENDFM1:	SKIPE NDSFMS	;STOP DISPLAY IF SPEC # OF FRAMES UP ELSE RETURN
	SOSGE NDSFMS
	JRST ENDFM2	;STOP WORLD
	JRST (B)

ENDFM2:	SETOM DISOFF
	JRST DISF1

SRCY5:	MOVNI A,EWRT/2
	ADDB A,DWDS
	JUMPGE A,SRCY1
	JRST DISF2

DISLOS:	SKIPE 340MD
	JRST 4,.
	SKIPGE A,DISUSR
	JRST 4,DISF2A
	MOVEI B,BDISP
	IORM B,PIRQC(A)
	MOVSI A,(SETZ)
	JRST DISF2A	;DIE FOR A LONG TIME

SRCY2A:	SOSGE DTIME
	JRST DISF
	SKIPL NDSFMS
	JSP B,ENDFM1
	CONO DIS,100\SDCHN_3\DISCHN
	JRST SRCY1C


DISACR:	SKIPE 340MD	;COME HERE IF PAGE BEING FLUSHED + EXEC PAGE POINTING TO IT
	JRST 4,.	;SHOULD NOT BE SET UP TO USER PAGE
	CONO PI,UTCOFF
	SETOM A340P1-340P1(T)
	SKIPGE DDEXCF(T)
	JRST DISAC1
	ADDB J,MMSWP(TT)
	SKIPGE J
	JRST 4,.
DISAC1:	SKIPGE DISOFF
	POPJ P,
	PUSH P,T
	PUSHJ P,DISZAP
	JRST POPTJ

;ROUTINES TO START 340 DISPLAY WITH DIS BUFF IN USERS CORE
ADSTART:	TDZA E,E	;CALL 10,
ADSTL:	MOVNI E,1	;CALL 12,
	MOVEI A,0
	PUSHJ P,ADSDV
	POPJ P,
	SETOM DISOFF
	CONO DIS,0
	CLEARM 340MD
	MOVEM E,LMODE
	HRRZ C,40
	MOVEM C,DROOT
	MOVEM C,LDISP
	SETZM DISOFF
	PUSHJ P,DISZAP
	JRST CLKOJ1

ANDIS:	CAME U,DISUSR
	POPJ P,
	XCTR XR,[MOVE A,(J)]
	JUMPL A,ANDIT1	;WAIT FOR COMPLETION OF LAST NDIS
	JUMPE A,ANDIT2	;RETURN COUNT LEFT FROM LAST NDIS
	MOVEM A,NDSFMS	;DISPLAY N TIMES AND THEN STOP
	SKIPL DISOFF
	JRST POPJ1
	SETOM DISDIE
	CLEARM DISOFF
	PUSHJ P,DISZAP
	JRST POPJ1

ANDIT1:	SKIPL DISOFF
	PUSHJ P,UFLS
	POPJ P,

ANDIT2:	MOVE A,NDSFMS
	JRST APTUAJ

ADSTOP:	CAMN U,DISUSR	;OPER 16
	SKIPGE DISOFF
	POPJ P,
ADCLB:	PUSH P,B
	PUSH P,C
	MOVSI C,-1
	SETOM DISOFF
	SETZM DBLINK
	CONO DIS,0
	MOVEI A,1
	MOVEM A,DTIME
	SETZM DISON
	SETOM DISDIE
	CONO PI,UTCOFF
	MOVSI A,-N340CL
ADCLB1:	SETOM A340P1(A)
	LDB B,DPEP(A)
	ANDI B,600777
	SKIPGE DDEXCF+340P1(A)
	JRST ADCLB2	;POINTING TO EXEC PG
	TRZE B,600000
	ADDM C,MMSWP(B)
ADCLB2:	AOBJN A,ADCLB1
	CLEARM 340PP
	CLEARM 340DP
	CLEARM EXEUMP+.340P1
	REPEAT N340PB/2,CLEARM EXEUMP+.DPG0+.RPCNT
	CONO PI,UTCON
	POP P,C
	JRST POPBJ

ADCL1:	SOSE DISNTO
	POPJ P,
	JRST AIDS7

ADCLOSE:	CAME U,DISUSR	;OPER 15
	POPJ P,
	SKIPLE 340MD
	JRST AIDS8
AIDS7:	PUSHJ P,ADCLB
	PUSHJ P,ADCL2
	JFCL
AIDS9:	SETOM 340MD
	SETOM DISUSR
	DATAO DSDEV,[DSNDIS]	;DEASSIGN DIS
	POPJ P,

AIDS8:	MOVE A,U	;FLUSH CHNLS IN CASE OF .DCLOSE FROM DIS OR IDS
	PUSHJ P,CHSCAA
	PUSHJ P,ADSDV4
	JRST AIDS7

ALTPEN:	MOVE C,B
	CAME U,DISUSR	;CALL 14,
	JRST ALTPP2
	XCTR XRW,[SKIPL A,(C)]
	JRST ALTPP1
	TLNN A,377777
	JRST .+3
	SKIPN LTPCNT
	PUSHJ P,UFLS
ALTPP1:	CONO PI,LPTOFF	;INHIBITS LPEN BREAKS
	MOVE A,LDISP
	XCTR XWI,[MOVEM A,4(C)]
	SKIPA A,DBLKOP
	JRST ALTPPL
	TRZ A,400000
	LDB B,[121000,,A]
	LDB B,[121000,,A340P1-340P1(B)]
	DPB B,[121000,,A]
	XCTR XWI,[MOVEM A,5(C)]
	SKIPA B,C
	JRST ALTPPL
	HRLI B,LLTPSN
	XCTR XWI,[BLT B,3(C)]
	JRST .+2
	JRST ALTPPL
	SETZB A,LTPCNT
	MOVEM A,LTPCY
	MOVEM A,LTPCX
	JRST LPTONJ

ALTPP2:	XCTR XRW,[SETZM (C)]
	XCTR XRW,[SETZM 1(C)]
	POPJ P,

ALTPPL:	CONO PI,LPTON
	PUSHJ P,TPFLT
	JRST ALTPEN

ADSDV:		;A HAS NEW 340MD
	CONO PI,CLKOFF
	CONI DIS,T	;DIS AVAILABLE
	JUMPN T,ADSDV1	;YES
	CONO DIS,0
	CONI DIS,T
	JUMPE T,ADSDVN	;DIS NOT AVAIABLE
ADSDV1:	SKIPL T,DISUSR
	CAMN U,DISUSR
	JRST ADSDVY	;YES
	CAME U,UMASTER
	JRST ADSDVM	;MAYBE
ADSDV2:	SKIPGE A,DISUSR	;TAKE AWAY DISPLAY
	JRST ADSDV3
	PUSHJ P,RPCCK
ADSDV7:	SKIPL DISUSR
	SKIPG 340MD
	JRST ADSDV3
	PUSH P,R
	PUSHJ P,CHSCAA	;CHANGE 340 CHANNELS TO NUL DEV
	PUSHJ P,ADSDV4
	POP P,R
	SETZM DISNTO
ADSDV3:	MOVE A,340MD
ADSDVY:	SETZM DBLINK
	SETOM NDSFMS	;TURN OFF FRAMER HACK
	CAME A,340MD
	JUMPE A,ADSDV5	;SAME USER CLOBBERING HIS IDS OR DIS
ADSDV6:	PUSHJ P,ADCLB
	MOVEM U,DISUSR
ADCL2:	SKIPGE A,340BF
	JRST CLKOJ1
	LSH A,-10.
	PUSHJ P,MEMR
	SETOM 340BF
	JRST CLKOJ1

ADSDV4:	HRRZ Q,(R)
	CAIG Q,DN340I
	CAIGE Q,DN340B
	POPJ P,		;NOT A 340 CH
	CAIL Q,DN340C
	SKIPA T,[NLODN]	;UNIT MODE
	MOVEI T,NLBDN	;BLOCK MODE
	SOS DISNTO
	HRRM T,(R)
	POPJ P,

ADSDV5:	SKIPGE 340MD
	JRST ADSDV6
	MOVE A,DISUSR
	JRST ADSDV7

ADSDVM:	CAMN T,UMASTER
	JRST ADSDVN	;CURRENT USER UMASTER
	MOVE T,UTMPTR(U)
	MOVE T,TTYTYP-USRRCE(T)	;GET BITS FOR NEW GUY IN LH OF T
	HRR T,DISUSR
	HRR T,UTMPTR(T)
	HLR T,TTYTYP-USRRCE(T)
	TRNE T,100000
	JRST ADSEQ1	;CURRENT USER HAS HIGH PRIORITY
	TRNE T,200000
	JRST ADSEQ2	;CURRENT USER NEAR 340
	TLNN T,300000	;GIVE TO NEW GUY IF HE IS EITHER
	JRST ADSEQ
ADSWIN:	JRST ADSDV2

ADSEQ1:	TLNN T,100000
	JRST ADSDVN	;NO
ADSEQ:	SKIPL TTYTBL(U)	;MAYBE
	JRST ADSWIN
ADSDVN:	JRST CLKONJ

ADSEQ2:	TLNE T,100000
	JRST ADSWIN
	TLNN T,200000
	JRST ADSDVN
	JRST ADSEQ

;340 AS ASCII DEVICE

DISO:	PUSHJ P,AIDS1
	JRST OPNL10	;NOT AVAILABLE
	AOS DISNTO
	SETOM 340DMD
	LDB B,[20200,,D]
	AOS B
	LSH B,4
	MOVEM B,CSCALE
	LDB TT,[40200,,CSCALE]
	MOVNS TT
	MOVEI T,170.
	LSH T,(TT)
	TRZ T,7
	MOVEM T,DISCHS	;CHARS THAT WILL FIT THIS SIZE
	MOVEI T,88.
	LSH T,(TT)
	MOVEM T,DISLNL	;LINES THAT WILL FIT
	PUSHJ P,DSIZAP
	MOVSI T,-1777
	HRR T,340BF
	SOS T
	MOVEM T,IDBLKP
	SETZM DISOFF
	PUSHJ P,DISZAP
	SETOM 340T
	JSP Q,OPSLD3
	DN340C,,DN340B
	DN340H,,DN340W

340FF:	SKIPL 340T
	JRST 340FF1
	MOVE A,TIME
	MOVEM A,340T
340FF1:	MOVE T,340T
	ADDI T,30.*3
	CAML T,TIME
	PUSHJ P,UFLS
	SETOM 340T
	PUSHJ P,ADCLB
	PUSHJ P,DSIZAP
	JRST DISZAP

DSIZAP:	SETZM DBLOAT
	SETZM 340XMD
	SETZM DBLINK
	MOVE T,340BF
	MOVEI A,34117
	IOR A,CSCALE
	MOVEM A,(T)
	PUSH T,[221700060000]
	HRLI T,0600
	MOVEM T,340BFP
	MOVE A,[403737403737]
	MOVEI B,1(T)
	HRLS B
	AOS B
	MOVEM A,1(T)
	BLT B,1775(T)
	MOVE A,DISLNL
	MOVEM A,DISLNS
	MOVE A,DISCHS
	MOVNM A,DISCHC
	MOVEI T,(HRRZ I,(A))
	HRLM T,AIDC1
	POPJ P,


340B:	MOVEI E,340D
	JRST NBTOCH

340C:	XCTR XR,[MOVE A,(C)]
	ANDI A,177
340D:	CAIN A,^C
	POPJ P,
	CAIN A,^L
	JRST 340FF
	CAIN A,^T
	JRST DSIZAP
	SKIPE DISLNS
	SKIPGE DBLOAT
	POPJ P,
	CAIN A,^B
	JRST BLNKON
	CAIN A,^E
	JRST BLNKOF
	SKIPE 340XMD
	PUSHJ P,340D1	;ENTER CHR MOD INF NOT ALREADY
340E:	XCT AIDC1	;HRRZ\HLRZ I,DISTBL(A)
	TRNN I,-100
	JRST 340FC	;NORMAL CHR
	TRNN I,-200
	JRST 340K	;FAKE OUT 340 NON-SPACING CHRS
	PUSHJ P,(I)	;ROUTINE DISPATCH (MAY SKIP OR SKIP TWICE)
	JRST 340E	;WRONG CASE OR SOMETHING, TRY AGAIN
340F:	IDPB I,340BFP
340F2:	MOVE J,340BFP
	ANDI J,1777
	CAIL J,1776
	SETOM DBLOAT
	POPJ P,

340FC1:	SKIPL DISCHC	;DISPLAY IF COUNT NOT OUT BUT DONT INCR COUNT
340FC:	AOSG DISCHC	;INCR COUNT + DISPLAY IF NOT OUT
	JRST 340F
	JRST 340F2

340HD1:	SKIPN 340XMD	;ESCAPE TO PARAM MODE
	PUSHJ P,340H1
340D1:	MOVEI I,74117	;PARAM WD
	IOR I,CSCALE
	PUSHJ P,340F	;STORE PARAM WD
	MOVEI I,6
	DPB I,[300600,,340BFP]	;SWITCH TO CHR MODE
	SETZM 340XMD
	POPJ P,

340K:	MOVEI I,40	;SPACE TO MAKE SPACING
	PUSHJ P,340FC1
	XCT AIDC1	;GET NON-SPACING LETTER AND DISPLAY
	JRST 340FC

340W:	JSP Q,WRDBT
	XCTR XRW,[MOVSS (C)]
	PUSHJ P,340H
	XCTR XRW,[MOVSS (C)]
340H:	SKIPGE DBLOAT
	POPJ P,
	SKIPN 340XMD
	PUSHJ P,340H1	;ENTER HALF WD MODE IF NOT ALREADY
	XCTR XR,[MOVE I,(C)]	;PICK UP LOSERS HALF WD
	JRST 340F

340H1:	MOVEI I,37	;IN CHR MODE, EXCAPE
	PUSHJ P,340F
	LDB I,[360600,,340BFP]
	JUMPE I,340H2
	CAIE I,22
	JRST 340H1
340H2:	MOVEI A,22
	DPB A,[300600,,340BFP]
	SETOM 340XMD
	POPJ P,

BLNKON:	MOVE A,DBLINK
	CAIL A,DBLNKN
	POPJ P,
	PUSHJ P,340HD1
	MOVE B,340BFP
	AND B,[770060,,1777]	;ADR OF PARAM WD TO BLINK INTEN OF
	TLO B,300+B
	MOVE A,DBLINK
	MOVEM B,DBLNKB(A)
	AOS DBLINK
	MOVEI T,15.
	PUSHJ P,CLQADD
	BLINKB
	JRST 340F2

BLNKOF:	PUSHJ P,340HD1
	JRST 340F2

BLNKBR:	SKIPN A,DBLINK
	JRST CLQRET	;BLINKING TURNED OFF
	SKIPL B,340BF
	SKIPGE CDISOFF
	JRST BLNKB3
	MOVE C,DBLNKF
BLNKB2:	DPB C,DBLNKB-1(A)
	SOJG A,BLNKB2
	SETCMM DBLNKF	;COMPLEMENT FLAG
BLNKB3:	MOVEI T,15.	;1/4 SEC
	MOVEI C,BLINKB
	JRST CLQREE

;INTERPRETIVE DISPLAY COMPILER

IDISO:	PUSHJ P,AIDS1
	JRST OPNL10	;NOT AVAIL
	AOS DISNTO
	SETZM 340DMD
	SETOM AISWS
	HRLI T,442200
	MOVEM T,340BFP
	MOVEI Q,10135	;TURN OFF LP SCALE 1 INT 5
	IDPB Q,340BFP
	MOVEI T,1_4
	MOVEM T,CSCALE
	MOVEM T,VSCALE
	MOVEM T,ISCALE
	MOVSI A,(MOVE)	;DONT HACK CHR'S PER LINE
	MOVEM A,DISCHS
	MOVNM A,DISCHC
	CONO DIS,500
	MOVEI A,DN340I
	JRST OPNSLT

AIDS1:	MOVEI A,2
	PUSHJ P,ADSDV	;DETERMINE IF THIS LOSER SHOULD GET DISPLAY
	POPJ P,
AIDS3:	PUSHJ P,TCALL
	JRST IOMQ
	JRST AIDS2	;NO MEM AVAIL
	MOVEI B,MUDISB
	MOVE T,A
	LSH T,10.
	MOVEM T,340BF
	DPB B,[MUR,,MEMBLT(A)]
	MOVEI B,2
	MOVEM B,340MD
	JRST POPJ1

AIDS2:	SKIPG MEMFR
	JRST AIDS9
	PUSHJ P,FINSET
	AIDS9
	PUSHJ P,UDELAY
	PUSHJ P,LSWDEL
	JRST AIDS3

340I:	MOVEM C,AIDPCP
	XCTR XR,[MOVE C,(C)]

AIDL:	XCTR XR,[MOVE R,(C)]
AIDL2:	TRNE R,1
	JRST AIDL1	;NOT CHR MODE
	MOVEI Q,(HRRZ I,(A))
	HRLM Q,AIDC1
	MOVE Q,CSCALE
	IORI Q,60100
	PUSHJ P,AIDPY
	MOVE J,[220600,,Q]
AIDCL:	MOVE B,[440700,,R]
AIDC3:	ILDB A,B
EBLK
AIDC1:	HRRZ\HLRZ I,DISTBL(A)
BBLK
	TRNN I,-100
	JRST AIDC5
	TRNN I,-200
	JRST AIDC7
	PUSHJ P,(I)
	JRST AIDC1
AIDC5:	IDPB I,J
	TLNN J,770000
	PUSHJ P,AIDC2
	TLNE B,760000
	JRST AIDC3
	AOS C
	XCTR XR,[MOVE R,(C)]
	MOVE I,UEXIT
	CAMN I,[JRST ONEFLS]
	JRST AIDC6
	TRNN R,1
	JRST AIDCL
AIDC6:	MOVEI I,37
	IDPB I,J
	TLNE J,770000
	JRST .-2
	PUSHJ P,AIDC2

AIDL1:	MOVE B,UEXIT
	CAMN B,[JRST ONEFLS]
	JRST AIDI
	LDB B,[30300,,R]
	AOJA C,@AIDTB(B)

AIDC7:	MOVEI I,40
	PUSHJ P,AIDC4
	XCT AIDC1
	JRST AIDC5

AIDI:	MOVE R,AIDPCP
	XCTR XW,[MOVEM C,(R)]
	SOS UUOH
	JRST UUOE1

AIDTB:	AIER1
	AIPT
	AIVC
	AIINC
	AIOP
	AIVC
	REPEAT 2,AIER1

AIPT:	LDB I,[251600,,R]	;PICK UP Y
	SUB I,DWDB
	MOVEI TT,220000
	DPB I,[1200,,TT]
	LSH I,-10.
	ANDI I,17
	MOVEM I,YFLD
	LDB I,[61600,,R]	;X
	SUB I,DWDL
	MOVEI E,0
	TRNE R,2
	TRO E,2000	;INTENSIFY
	DPB I,[1200,,E]
	LSH I,-10.
	ANDI I,17
	MOVEM I,XFLD
	MOVEI Q,20000
	PUSHJ P,AIDPY
	MOVE Q,TT
	PUSHJ P,AIDPY
	MOVE Q,E
	PUSHJ P,AIDPY
	JRST AIDL

AIDC4C:	SKIPL DISCHC
	POPJ P,
	JRST AIDC4

AIDC4B:	AOSLE DISCHC
	POPJ P,
AIDC4:	SKIPGE 340DMD
	JRST AIDC4A	;DIS
	IDPB I,J
	TLNE J,770000
	POPJ P,
AIDC2:	PUSHJ P,AIDPY
	MOVEI Q,0
	MOVE J,[220600,,Q]
	POPJ P,

AIDC4A:	IDPB I,340BFP
	POPJ P,

AIDPY:	HRLS Q
	DATAI DIS,AIDPIC
	DATAO DIS,Q
AIDP1:	MOVEI H,50
AIDP1A:	CONSZ DIS,DVEF+DHEF	;EDGE FLAGS
	JRST DEGFS
	CONSO DIS,200
	SOJG H,AIDP1A
	JUMPE H,AIER2
	CONSZ DIS,DVEF+DHEF
	JRST DEGFS
	SKIPN XFLD
	SKIPE YFLD
	JRST AIDP2
DEG4B:	HRRZ H,340BFP
	SUB H,340BF
	CAIL H,1777
	JRST AIER3
	IDPB Q,340BFP
AIDP2:	MOVEI Q,0
	POPJ P,

DEGFS:	DATAI DIS,DEGVCC
	CONI DIS,H
	LSH H,-15.
	ANDI H,7
	CAIN H,4	;VECTOR
	JRST DEGVC
	SKIPN XFLD
	SKIPE YFLD
	JRST DEG5A
	MOVEI Q,400000
	CAIN H,3
	MOVEI Q,373737
	PUSH P,H
	PUSHJ P,DEG4B	;LEAVING INSERT APPROPRIATE ESCAPE INSTEAD
	POP P,H
DEG5A:	CONO DIS,200
	MOVEI TT,50.
	CONSO DIS,DVEF+DHEF+200
	SOJG TT,.-1
	JUMPE TT,AIER2
	CONSO DIS,200
	JRST DEG5A	;RIDE OUT TO FINAL EDGE
	DATAI DIS,TT
	XOR TT,AIDPIC
	TRNN TT,1000
	JRST DEG5B
	HRR TT,AIDPIC
	TRNE TT,1000
	AOS XFLD
	TRNN TT,1000
	SOS XFLD
DEG5B:	TLNN TT,1000
	JRST DEG4
	HLL TT,AIDPIC
	TLNN TT,1000
	SOS YFLD
	TLNE TT,1000
	AOS YFLD
	JRST DEG4

DEG5:	MOVE TT,DEGVCC
	CONSZ DIS,DVEF
	JRST DEG1
DEG3:	CONSO DIS,DHEF
	JRST DEG4
	TRNE TT,1000
	SOS XFLD
	TRNN TT,1000
	AOS XFLD
DEG4:	MOVEI TT,0
	DPB TT,[44000,,XFLD]
	DPB TT,[44000,,YFLD]
	CONSO DIS,200
	CONO DIS,200	;CONTINUE
	MOVEI TT,100.
	CONSO DIS,200+DVEF+DHEF
	SOJG TT,.-1
	JUMPE TT,AIER2
	SKIPN XFLD
	SKIPE YFLD
	JRST AIDP1	;NOT COMING ON
DEG4F:	DATAI DIS,TT
	CAIN H,4
	MOVE TT,DEGVCC
	PUSH P,Q	;COMING ON PRODUCE SETPOINT
	PUSH P,H
	MOVEI Q,20100
	IOR Q,@DEGSCT(H)
	PUSHJ P,DEG4B
	HLRZ Q,TT
	IORI Q,220000
	PUSHJ P,DEG4B
	HRRZ Q,TT
	CONI DIS,H
	LSH H,-15.
	DPB H,[150300,,Q]
	MOVE TT,(P)
	CAIN TT,4
	JRST DEGVC1
DEG4D:	SUB P,[2,,2]
	JRST AIDP1

DEGSCT:	[0]
	[0]
	[0]
	CSCALE
	VSCALE
	VSCALE
	ISCALE
	[0]

DEG1:	TLNE TT,1000
	SOS YFLD
	TLNN TT,1000
	AOS YFLD
	JRST DEG3

DEGVC:	SETOM DEGVCF
	SKIPN XFLD
	SKIPE YFLD
	JRST DEG5	;NOT GOING OFF
	CLEARM DEGVCF
	HRRZ A,AIDPIC
	HLRZ B,AIDPIC
	PUSHJ P,DEG4C
	CONSZ DIS,DVEF
	SUBI B,2
	CONSZ DIS,DHEF
	SUBI A,2
	SKIPGE A
	MOVEI A,0
	SKIPGE B
	MOVEI B,0
	DPB B,[100700,,Q]
	DPB A,[700,,Q]
	TRO Q,400000
	PUSHJ P,DEG4B
	JRST DEG5

DEGVC1:	SKIPN XFLD
	SKIPE YFLD
	SKIPLE DEGVCF
	JRST .+2
	JRST DEG4D	;VECTOR TOTALLY OUT OF IT
	IORI Q,100000
	PUSHJ P,DEG4B
	POP P,H
	POP P,Q
	DATAI DIS,A
	HLRZ B,A
	HRRZS A
	PUSHJ P,DEG4C
	DPB B,[100700,,Q]
	DPB A,[700,,Q]
	MOVE A,DEGVCC
	MOVEM A,AIDPIC
	JRST AIDP1

DEG4C:	HRRZ I,DEGVCC
	SUB A,I
	HLRZ I,DEGVCC
	SUB B,I
	MOVMS A
	MOVMS B
	CAIGE A,1000
	JRST .+3
	MOVNS A
	ADDI A,2000
	CAIGE B,1000
	JRST .+3
	MOVNS B
	ADDI B,2000
	LDB I,[40200,,VSCALE]
	MOVNS I
	ASH A,(I)	;GET X INC IN A
	ASH B,(I)	;Y IN B
	POPJ P,

AIINC:	MOVE Q,ISCALE
	IORI Q,140100
	PUSHJ P,AIDPY
	SETOM DDINCI
	MOVEI Q,0
	MOVE B,[200400,,Q]
AIIN1:	MOVE D,[440600,,R]
AIIN8:	ILDB T,D
	LDB E,[200,,T]	;LOAD COUNT
	JUMPE E,AIIN5	;NULL INCREMENT
AIIN7:	TRNN T,4	;SKIP ON INTENSIFY
	JRST AIIN2
	SKIPG DDINCI	;SKIP ON SET TO INTENSIFY
	JRST AIIN3

AIIN7A:	LDB H,[30300,,T]
	MOVE H,DINCT(H)
	IDPB H,B
	PUSHJ P,AIIN6	;MAYBE START NEW WORD
	SOJG E,AIIN7

AIIN5:	TLNE D,700000
	JRST AIIN8
	XCTR XR,[MOVE R,(C)]
	LDB H,[30300,,R]
	TRNE R,1
	CAIE H,3	;INC MODE
	TROA Q,400000
	AOJA C,AIIN1
	PUSHJ P,AIIN6A
	JRST AIDL2

AIIN6:	TLNE B,770000
	POPJ P,

AIIN6A:	PUSHJ P,AIDPY
	MOVEI Q,0
	SETOM DDINCI
	MOVE B,[200400,,Q]
	POPJ P,

AIIN2:	SKIPN DDINCI
	JRST AIIN7A	;INTENSITY AGREES
AIIN3:	SKIPL DDINCI
	PUSHJ P,AIIN6A
	HRRZM P,DDINCI
	TRNE T,4
	TROA Q,200000
	CLEARM DDINCI
	JRST AIIN7

AIVC:	MOVE Q,VSCALE
	IORI Q,100100
	LDB A,[251700,,R]	;DY
	LDB B,[61700,,R]	;DX
	TRNE A,40000
	ORCMI A,77777
	TRNE B,40000
	ORCMI B,77777
	MOVM E,A
	MOVM TT,B
	MOVE H,VSCALE
	LSH H,-4
	ANDI H,3
	MOVNS H
	LSH E,(H)
	LSH TT,(H)
	JUMPN E,.+2
	JUMPE TT,AIDL
	PUSHJ P,AIDPY
AIVCL:	MOVE H,E
	MOVE J,TT
AIVC3:	CAIG J,177
	CAILE H,177
	JRST AIVC2
	SUB E,H
	DPB H,[100700,,Q]
	SKIPGE A
	TRO Q,1_<8+7>
	SUB TT,J
	DPB J,[700,,Q]
	SKIPGE B
	TRO Q,1_7
	TRNE R,1_1
	TRO Q,200000
	JUMPN E,.+3
	JUMPN TT,.+2
	TRO Q,400000
	PUSH P,A
	PUSH P,B
	PUSH P,E
	PUSH P,TT
	PUSHJ P,AIDPY
	POP P,TT
	POP P,E
	POP P,B
	POP P,A
	JUMPN E,AIVCL
	JUMPN TT,AIVCL
	JRST AIDL

AIVC2:	LSH J,-1
	LSH H,-1
	JRST AIVC3

AIOP:	LDB B,[60300,,R]
	JRST @AIOPT(B)

AIOPT:	AIER5
	AIPSJ
	AIPPJ
	AIJMP
	AIPSH
	AIIPOP	;5
	AIPS
	AIER5
	AIER5

AIPSJ:	XCTR XRW,[AOS D,43]	;PICK UP PDL PNTR AND INCR
	XCTR XRW,[MOVEM C,(D)]	;STORE RETURN PC
AIJMP:	HLRZ C,R
	JRST AIDL

AIPPJ:	XCTR XR,[MOVE D,43]
	XCTR XRW,[HRRZ C,(D)]
	JUMPE C,AIEXT	;POPJ INTO 0 START SIGNAL
	XCTR XRW,[SOS 43]
	JRST AIDL

AIEXT:	SKIPL AISWS
	JRST AIDST3
AIDST:	MOVEI Q,3000
	PUSHJ P,DEG4B
	MOVE A,340BF
	ADD A,[-2000-1,,-1]
	MOVEM A,IDBLKP
	MOVEM A,DBLKOP
	MOVEI A,1
	MOVEM A,DTIME
	SETZM DISOFF
	CONO DIS,1100\DISCHN\SDCHN_3
AIDST3:	POPJ P,

AIPSH:	HLRZ TT,R
	XCTR XR,[MOVE TT,(TT)]
	XCTR XRW,[AOS D,43]
	XCTR XW,[MOVEM TT,(D)]
	JRST AIDL

AIIPOP:	HLRZ TT,R
	XCTR XRW,[SOS D,43]
	XCTR XR,[MOVE E,1(D)]
	XCTR XW,[MOVEM E,(TT)]
	JRST AIDL

AIPS:	LDB A,[140600,,R]
	HLRZ B,R
	CAIL A,AIMXP
	JRST AIER7
	ANDI B,3
	LSH B,4
	XCT AIPST(A)
	JRST AIDL

AIPST:	JRST AIER7
	HLLEM R,AISWS	;START MODE
	MOVEM B,CSCALE
	MOVEM B,ISCALE
	MOVEM B,VSCALE
	JRST AIPSA
	HLRM R,DWDL
	HLRM R,DWDB
AIMXP==.-AIPST

AIPSA:	MOVEM B,CSCALE
	MOVEM B,ISCALE
	MOVEM B,VSCALE
	JRST AIDL

EBLK
XFLD:	0	;HIGH ORDER BITS OF X COOR REG (LIGHT=0)
YFLD:	0	;  .. Y
340BF:	-1	;POINTER TO 1K BLOCK FOR 340 BF (MEM ADR)
340BFP:	0	;POINTER TO 340BF
	DBLNKN==10.
DBLINK:	0	;0=IDLE ;+N=NUM OF ENTRIES
DBLNKF:	0	;BLINK FLAG, -1 MEANS START BLINK OFF
DBLNKB:	BLOCK DBLNKN	;BYTE POINTER TO PARAMETER HW TO CHANGE
BLINKB:	0	;CLOCK QUEUE BLOCK
	-1
	JRST BLNKBR
AIDPCP:	0	;USER LOCN WHERE TO STORE BACK PC IF NECC
CSCALE:	0	;SCALE FOR CHR WRDS
ISCALE:	0	;SCALE FOR INCREMENT
VSCALE:	0	;SCALE FOR VECTOR WDS
DWDL:	0	;14 BIT COOR OF LH 340
DWDB:	0	;14 BIT COOD OF BOT 340
DEGVCF:	0	;EDGE FLAG FOR VECT -1 UNLESS GOING AWAY
DEGVCC:	0	;COORD AT EDGE
DDINCI:	0	;-1 CURRENT INTENSITY NOT COMMITED (IN INCREMENT MODE)
	;+ => 1 - => 0
AISWS:	0	;SELECT DISPLAY START MODE -1 STARTS DISPLAY AFTER IOT
AIDPIC:	0	;COORDINATES AT START OF AIDPY

LLTPSN:	0	;. TO .+3 BLTED TO USER
LTPCNT:	0
LTPCY:	0
LTPCX:	0
LTPDCN:	200\SDCHN_3\DISCHN

LDISP:	0	;DISPLAY LINK POINTER
LMODE:	0	;LISP LINK MODE FLAG
DISOFF:	-1	;-1 IF DIS NOT IN USE OR STOPPED DUE TO FRAME HACK
DTIME:	0

340MD:	-1	;MODE IN WHICH DISPLAY OPEN
		;-1 NOT DISPLAYING 0 .DSTART ETC 2 AS DIS OR IDS
340DMD:	0	;0 IDS -1 DIS
340XMD:	0	;IN DIS, 0=CH 1=IMAGE
DBLOAT:	0
340T:	0	;TIMER FOR DIS PAGE
LUBLKP:	0	;LAST USER BLKO PNTR SET UP AT IN LEVEL, FOR DEBUGGING

;START 340 EXECPG AREA

A340P1:	-1	;USER ADR THAT EXEC PG SET UP FOR
A340P2:	-1
340DA:	REPEAT N340PB,-1
N340CL==.-A340P1	;THIS BLOCK MUST BE CONSEC
340DP:	0	;0=> N30PB-1 PNTR TO DATA PGS
340PP:	0	;PNTR TO 340P1 OR P2 ALTNERATELY

DPAP:	400000+340P1*2000(A)	;EXEC ADR TO REF PAGE
	400000+340P2*2000(A)
DDAD:	REPEAT N340PB, 400000+<DPG0+.RPCNT>*2000(A)

DPEP:	.340P1+EXEUMP	;BYTE PNTR TO EXEC MAP PAGE ENTRY
	.340P2+EXEUMP
DDEP:	REPEAT N340PB, CONC .DPG,\.RPCNT,+EXEUMP

DPBS:	BLOCK 8	;SAVE PAGE BOX AT PI DIS LVL

DROOT:	0	;DIS RESTART POINTER TO LOSER CORE
DBLKOP:	0	;TEMP DIS BLKO PTR
LDBLKP:	0	;LAST
DISON:	0	;-1 IF DIS STOPPED AFTER SPECIAL INT OR BLKO OVERFLOW
		;IE RESTART AFTER PASSAGE OF TIME
DISDIE:	0	;0	;-1 IF DIS HASNT DIED
DISTPR:	0	;-1 TO TURN OFF DISPLAY
IDBLKP:	0	;BLKO PNTR IF IN INTERP DISPLAY MODE
NDSFMS:	-1	;-1 NOT HACKING FRAME HACK ELSE NUMBER OF FRAMES REMAINING
DISNTO:	0	;# TIMES DIS OR IDS OPEN
DWDS:	0	;- # WDS SENT TO DIS-EWRT PER TRIP THRU SRECYC
		;RESET TO MDISWD EVERY 1/30
		;IF <0 DISPLAY STOPS FOR 5 SEC -300.->DTIME

DISCHS:	0	;LENGTH OF LINE IN CURRENT SIZE
DISCHC:	0	;-# CHR POS REMAINING
DISLNL:	0	;# OF LINES WILL FIT CURRENT SIZE
DISLNS:	0	;# LINES REMAINING
BBLK

DEFINE LC A
A,,DISLC
TERMIN

DEFINE UC A
DISUC,,A
TERMIN

DEFINE AC A
A,,A
TERMIN



ADISCR:	MOVE I,DISCHS
	MOVNM I,DISCHC
	MOVEI I,34
	JRST POPJ1

DISALF:	SOS DISLNS
	MOVEI I,33
	JRST POPJ1

DSATB:	MOVEI I,40	;B
	PUSHJ P,AIDC4B
	LDB I,[300,,DISCHC]
	SKIPG DISCHC
	JUMPN I,DSATB
	JRST POPJ2

DISBLB:	MOVEI I,50	;DOWN ARROW
	PUSHJ P,AIDC4B
	TRO A,100	;CONVERT TO UC LETTER
DISUC:	SKIPA I,[HRRZ I,35(A)]	;SWITCH TO UC
DISLC:	MOVE I,[HLRZ I,36(A)]	;SWITCH TO LC
	PUSHJ P,AIDC4	;STORE CASE CODE
	HLLM I,AIDC1
	POPJ P,

ADISBS:	MOVEI I,72	;BACKSPACE
	SOS DISCHC
	JRST POPJ1

DISRUB:	MOVEI I,"X&77	;LC X
	PUSHJ P,AIDC4
	MOVEI I,72	;340 BACKSPACE
	PUSHJ P,AIDC4
	MOVEI A,"O	;YES, A
	POPJ P,	;LOOP BACK

DISTBL:	POPJ2,,POPJ2	;IGNORE 0
	REPEAT 6,LC DISBLB
	LC 63	;BELL
	LC ADISBS
	AC DSATB
	AC DISALF
	LC DISBLB
	LC DISBLB
	AC ADISCR
	REPEAT 33-16,LC DISBLB
	LC 47	;ALT MD (RT ARROW)
	REPEAT 4,LC DISBLB
	AC 40
	REPEAT 133-41,UC <.-DISTBL>&77
	LC 53
	LC 52	;BACKSLASH
	LC 54
	LC 100+67
	LC 60
	LC 100+66
	REPEAT 173-141,LC <.-DISTBL-140>
	LC 55
	LC 62	;VERTICAL BAR=174
	LC 56
	LC 43	;TILDE=176
	LC DISRUB
IFN .-DISTBL-200,PRINTX /DISTBL LOSS/


DINCT:	10
	2
	14
	3
	12
	16
	17
	13



REPEAT NDOPL, CONC AIER,\.RPCNT+1,:	JSP D,AIER

AIER:	MOVE R,UUAC(U)
	ADDI R,IOCHNM(U)
	MOVEI D,1+1-AIER1(D)
	LSH D,6+18.
	IORM D,IOCHST-IOCHNM(R)
	MOVE T,AIDPCP
	XCTR XW,[MOVEM C,(T)]
	JRST IOCERR
]IFN VIDP,[
;
;NEW VIDISECTOR ROUTINES
;
TVCO:	HLRZ D,C
	SKIPA Q,[TVCOBK]
NVIDI:	MOVEI Q,NVDOBK
	PUSH P,R
	PUSH P,[NVIDI2]
	JRST STDOP1

NVIDI2:	JRST POPAJ
	POP P,R
	PUSHJ P,NVDGET
	JRST NVIDI3
NVIDI1:	MOVEM A,(R)
	CAIN Q,TVCOBK
	AOS NTVCOS
	CAIN Q,TVCOBK
	TLNE C,1	;ONLY DO IF TVC OUTPUT OPEN
	PUSHJ P,TVCNOS
	JRST POPJ1

NVIDI3:	PUSHJ P,OPNL25
	JRST NVDCLS

NVDOBK:	1,,NVDUSR
	NVIDOP,,BNVIDO

BNVIDI:	JSP Q,WRDBT
NVIDIT:	SKIPGE NVDIFL
	PUSHJ P,UFLS
	XCTR XR,[MOVE B,(C)]
	MOVEM B,NVDCOR
	CONO PI,OMXOFF
	SETOM NVDIFL
	PUSHJ P,NVDVS1	;TURNS OMPCH ON
	SKIPGE NVDIFL
	PUSHJ P,UFLS
	MOVE B,NVDCOR
	XCTR XW,[MOVEM B,(C)]
	POPJ P,

RNVDIB:	JSP Q,WRDBT
RNVDIU:	SKIPN NVDCNT	;TVC INPUT
	JRST RNVDO2
	XCTR XRW,[MOVES (C)]	;MAKE SURE GOING TO WIN
	MOVE T,NVDOPT
	CAMN T,NVDVPT
	PUSHJ P,UFLS
	MOVE B,(T)
	SOS NVDCNT
	XCTR XW,[MOVEM B,(C)]
	AOS T,NVDOPT
	CAIL T,NVDBUF+NVDLNG
	MOVEI T,NVDBUF
	MOVEM T,NVDOPT
	POPJ P,

TVCOBK:	3,,NVDUSR
	DNVDIU,,DNVDOU
	DNVDIB,,DNVDOB

TVCCLS:	SOSGE NTVCOS
	PUSHJ P,TVCINI	;TRY TO AVOID GARBAGE PNT PART WAY VIDISECTED
NVDCLS:	SOSGE NVDUSE
	PUSHJ P,VIDFLS
	POPJ P,

TVCNOS:	LDB A,[251700,,C]	;TVC OPEN ROUTINE
TVCN1:	TRZ A,703000	;DONT LET LOSER FOOL AROUND
	IORI A,NVDCHN_15.
	LDB B,[20300,,A]	;DCO
	JUMPE B,TVCO3
	CAIN B,7
	JRST TVCO6	;DCO DISABLED FOR DCL=7
	IMUL B,[-100]
TVCO4:	ADDI B,1300
TVCO7:	MOVEM B,NVDDK	;DARK VALUE CORRECT FOR DCO
	MOVE TT,A
	XOR TT,TVCONO
	TRNE T,340
	JRST TVCO5	;CHANGE IN VIDI SELECTION STATUS
TVCO5A:	MOVEM A,TVCONO
	POPJ P,

TVCO3:	LDB T,[200,,A]	;CONF
	CAIN T,3
	MOVNI B,100	;IF CONF=3 & DCO=0 VALUE 100 LESS THAN PREDICTED ABOVE
	JRST TVCO4

TVCO5:	TRZ A,700000	;CLEAR CHNL OUT OF TVCONO
	CONO NVDX,(A)	;START RLYS
	MOVEI T,2
	SKIPL TVQBLK+1	;WAIT IF PREV RQ NOT SATISFIED
	PUSHJ P,UFLS
	PUSHJ P,CLQADD	;RQ LATER TRANSFER TO VIDD1
	TVQBLK
	JRST TVCO5A

TVCO6:	LDB T,[200,,A]	;CONF
	IMUL T,[-200]	;CALCULATE WHEN OVF HAPPENS
	ADDI T,2000
	JRST TVCO7

TVCINI:	CONO PI,OMXOFF
	SETZM NVDCNT
	MOVE T,NVDIPT
	MOVEM T,NVDVPT
	MOVEM T,NVDOPT
	MOVE T,NVDBKR
	CAIN T,1
	SETOM NVDBKR
	JRST OMXONJ

VIDFLS:	SKIPL NVDUSE	;SKIP IF OPENS ON NVD, .VSCAN
	POPJ P,
	DATAO DSDEV,[DSNVID]	;DEASSIGN VIDI
	SETOM NVDUSR
	POPJ P,

NVDGET:	CONO NVDX,@TVCONO	;TRY TO ASSIGN BAT
	CONI NVDX,TT
	JUMPE TT,CPOPJ
	JRST POPJ1


NVDBRK:	MOVE T,NVDBKR
	JRST NVTAB(T)	;DISPATCH ON REASON FOR BREAK

	JRST NEWORK	;STARTUP OF SOME NEW FUNCTION
NVTAB:	JRST SCNB1	;NEW VSCAN POINT
	JRST TVB1	;NEW TVC POINT
	JRST INVD1	;NEW NVD PNT
;	JRST DRET	;NEW DAEMON POINT

TVB1:	DATAI NVDX,@NVDVPT	;READ IN OF TV POINT
	CONI NVDX,T
	LSH T,-11.
	DPB T,[220200,,@NVDVPT]	;READ ALL RELAVENT INFO FROM BAT
	TRNE T,3
	JRST TVB2	;DCO OR OVFL
	MOVE T,@NVDVPT
	ANDI T,1777
	CAMLE T,NVDDK
	JRST TVB2	;DUE TO NOISE/PROB DARKER THAN DCO
TVB3:	AOS T,NVDVPT
	CAIL T,NVDBUF+NVDLNG
	MOVEI T,NVDBUF
	MOVEM T,NVDVPT	;INCREMENT TO NEXT POINT
	JRST NEWORK

TVB2:	MOVE T,NVDDK
	DPB T,[1200,,@NVDVPT]
	DPB T,[240600,,@NVDVPT]	;PUT IN FLOATING PART
	LSH T,-6
	DPB T,[330400,,@NVDVPT]
	JRST TVB3

TVNEXT:	MOVE T,NVDVPT
	CAMN T,NVDIPT
	JRST TVCFIN
	MOVEI T,1	;SET UP FOR NEXT TV POINT
	MOVEM T,NVDBKR
	MOVE T,NVDVPT
	HLRZ T,@NVDVPT
	CONO NVDX,@TVCONO
	DATAO NVDX,T
	EXCH T,VIDXOL
	SUB T,VIDXOL
	MOVMM T,VIDTEM
	HRRZ T,@NVDVPT
	DATAO NVDY,T
	EXCH T,VIDYOL
	SUB T,VIDYOL
	MOVMS T
	CAMGE T,VIDTEM
	MOVE T,VIDTEM
	CAIL T,1000
	JRST TVB5
	DATAO NVDT,[-4]
NVDBR4:	JRST OMXRET

TVB5:	TLC T,232000	;CALCULATE SETTLING TIME
	FAD T,T
	LDB T,[330400,,T]
	DATAO NVDT,SETLL-10.(T)
	JRST NVDBR4

SETLL:		;SETTLING TIME IN 10 MICROSEC
	-6	;DEFLECTING 512 - 1023 
	-10	;1024 - 2047
	-16	;2048 - 4095
	-26	;4096 - 8191
	-45	;8192 - 16383
	-70	;16384

RNVDOB:	JSP Q,WRDBT
RNVDOU:	MOVEI T,NVDLNG-1	;TO PREVENT HANGUP AT PI ON WRAPAROUND
	CAMG T,NVDCNT
	JRST RNVDO2
	XCTR XR,[MOVE B,(C)]
	MOVEM B,@NVDIPT
	AOS NVDCNT
	AOS T,NVDIPT
	CAIL T,NVDBUF+NVDLNG
	MOVEI T,NVDBUF
	MOVEM T,NVDIPT
	CONO PI,OMXOFF
	SETOM TVFLG
NVDVS1:	MOVE T,TVCONO
	SKIPGE NVDBKR
	CONO NVDX,2000(T)
	JRST OMXONJ

RNVDO2:	POP P,T	;CALLED FROM RNVDI ALSO
	ANDI T,-1
	CAIE T,WRDBRT
	JRST IOCER9
	POPJ P,

NEWORK:;	SKIPGE DAEMFL
;	JRST DNEXT
	SKIPL SCNUSR	;DEFLECT FOR NEW VSCAN POINT
	JRST SCNB2
	SKIPGE NVDIFL	;NVD
	JRST INVD2
	SKIPGE TVFLG	;DEFLECT FOR NEW TVC POINT
	JRST TVNEXT
	SETOM NVDBKR	;NO MORE CROCKS FOR VIDISECTOR TO DO
	MOVE T,TVCONO
	TRZ T,703000	;SAVE STATE OF VIDI SELECT
	CONI NVDX,A
	CONO NVDX,(T)
	SKIPN A
	DATAO DSDEV,[DSNVID]	;RE DEASSIGN VIDI IF WAS DEASSIGNED 
			;(CONO DID CLEAR PIA, DONE, AND SET MODE FLOPS THO)
	JRST OMXRET

TVCFIN:	SETZM TVFLG
	JRST NEWORK

INVD1:	DATAI NVDX,NVDCOR
	CONI NVDX,T
	LSH T,-11.
	DPB T,[220200,,NVDCOR]
	SETZM NVDIFL
	JRST NEWORK

INVD2:	MOVEI T,2
	MOVEM T,NVDBKR
	CONO NVDX,@TVCONO
	HLRZ T,NVDCOR
	DATAO NVDX,T
	HRRZ T,NVDCOR
	DATAO NVDY,T
	DATAO NVDT,[-7]
	JRST NVDBR4
AVSTST:	XCTR XR,[MOVE A,(J)]
	CAME U,NVDUSR
	JRST AVST4
	JUMPE A,AVST1	;READ CURRENT STATE
	JUMPL A,AVST2
AVST3:	SKIPL SCNUSR	;HANGUP TILL VSCAN FINISHED
	PUSHJ P,UFLS
AVST2:
SCNSTP:	CONO PI,OMXOFF	;FLUSH VSCAN ENTIRELY
	SKIPGE SCNUSR
	JRST OMXONJ	;ALREADY FINISHED
	SETOM SCNUSR
	SOSGE NVDUSE
	SETOM NVDUSR
	SKIPN NVDBKR	;IGNORE VSCAN POINT IN PROGRESS IF ANY
	SETOM NVDBKR
VSLS2:	PUSH P,A
	PUSH P,B
	PUSH P,W
	MOVSI B,-1
	MOVSI W,-2
SCNS2:	LDB A,VEXT(W)
	TRNN A,600000
	JRST SCNS4
	ANDI A,777
	ADDM B,MMSWP(A)
SCNS4:	MOVEI A,0
	DPB A,VEXT(W)
	AOBJN W,SCNS2
	MOVE A,USER
	SPM UPGML(A)
	LPMR UPGML(A)
	POP P,W
	POP P,B
	POP P,A
	PUSHJ P,VIDFLS
	JRST OMXONJ

AVST4:	JUMPE A,ILUUO
	POPJ P,

AVST1:	SKIPGE SCNUSR
	POPJ P,
	MOVE A,NVDPTR
	SUBI A,400000+VSB1*2000
	JRST APTUAJ

;CHECK TO SEE IF MEM PROTECT STILL OK
SCNACR:	JRST SCNSTP

;STOP SCAN
SCNSTC:	CONO NVDX,0
	POPJ P,

;RESTART SCAN AFTER STOP FOR SHUFFLING
SCNRST:	CONO NVDX,NVDCHN_17
	POPJ P,

AVSCAN:	XCTR XRW,[MOVES (C)]
	XCTR XRW,[MOVES 12(C)]
	SKIPL SCNUSR
	PUSHJ P,UFLS
	CONO PI,CLKOFF
	CAME U,NVDUSR
	SKIPGE NVDUSE
	AOSA NVDUSE
	JRST ILUUO
	MOVEM U,NVDUSR
	CONO PI,CLKON
	PUSHJ P,NVDGET
	JRST VSLOS
A.VS1:	SETZM BATMXA
	XCTR XRW,[HLRZ A,2(C)]
	MOVEM A,NVDCNX
	MOVEM A,NVDCN3
	XCTR XRW,[HRRZ A,2(C)]
	MOVEM A,NVDCNY
IRPS XY,,X Y P X Y P,A12,,1 1 1 2 2 2,N,,3 6 11 4 7 12,YX,,X X X Y Y Y
	XCTR XR,[MOVE A,N(C)]
	IDIV A,NVDCN!YX
	MOVEM A,BATD!XY!A12
TERMIN
IRP XY,,[P,X,Y]ADR,,[[[1,,]],5(C),10(C)]
	MOVE A,BATD!XY!1
	ADD A,BATD!XY!2
	ASH A,-1
IFE .IRPCNT,	ADD A,ADR
IFN .IRPCNT,	XCTR XRW,[ADD A,ADR]
	MOVEM A,BAT!XY!1
	MOVEM A,BAT!XY!2
	IFN .IRPCN,[IDIV A,BATP1
	MOVEM A,NVID!XY]
TERMIN
	XCTR XRW,[HRRZ B,1(C)]
	LDB A,[121000,,B]
	CAIL A,376
	JRST VSLOS
	MOVEI W,0
	PUSHJ P,VSMS1
	MOVEI W,1
	PUSHJ P,VSMS1
	LPMR UPGML(U)
	HRRZ R,B
	ANDI R,776000
	ADDI R,4000-2000
	XCTR XRW,[HLRO D,1(C)]
	MOVE A,NVDCNX
	IMUL A,NVDCNY
	JUMPLE A,VSLOS	;SIZE OF RASTOR
	MOVNS D		;PLUS COUNT
	CAMLE A,D
	JRST VSLOS	;WON'T FIT
	CAML A,R
	JRST VSLOS	;WON'T FIT IN EXEC PGS
	ADD A,B
	MOVEM A,BATMXA
	LDB A,[121000,,A]
	PUSHJ P,UPLC
	LDB A,T
	TRC A,600000
	TRCE A,600000	;SKIP ON R/W/F
	JRST VSLOS	;TOP PAGE LOSES
	ANDI B,1777
	ADDI B,400000+VSB1*2000
	MOVEM B,NVDPTR
	XCTR XRW,[HRRZ A,(C)]
	PUSHJ P,TVCN1
	MOVE A,[JRST SCNG1]
	MOVEM A,SCNB1A
	CONO PI,OMXOFF
	MOVEM U,SCNUSR
	MOVE A,TVCONO
	SKIPGE NVDBKR
	CONO NVDX,2000(A)
	CONO PI,OMXON
	XCTR XRW,[SKIPL (C)]
	POPJ P,
	JRST AVST3

VSLS3:	PUSHJ P,LSWPOP
VSLOS:	PUSHJ P,VSLS1
	JRST ILUUO


VPGLOS:	PUSHJ P,VSLS1
	PUSHJ P,TPFLT
	JRST UUOTRO

VSLS1:	SOSGE NVDUSE
	SETOM NVDUSR
	CONO PI,OMXOFF
	JRST VSLS2

VSMS1:	PUSHJ P,SWTL
	CIRPSW
	LDB A,[121000,,B]
	ADD A,W
	MOVEM A,VSMPG
	PUSHJ P,UPLC
	CONO PI,CLKOFF
	LDB A,Q
	JUMPE A,VSMS2	;NO ACCESS
	CAIN A,-1
	JRST VSLS3
	LDB A,T
	TRNN A,600000
	JRST VSMS3	;SWAPPED OUT
	TRNN A,400000
	JRST VSLS3	;RD ONLY
	TRO A,200000
VSMS2:	DPB A,T		;CHANGE R/W/F TO R/W
	LDB TT,VEXT(W)
	DPB A,VEXT(W)
	MOVSI Q,1
	ANDI A,777
	SKIPE A
	ADDM Q,MMSWP(A)
	JUMPE TT,VSLS4
	ANDI TT,777
	MOVSI Q,-1
	ADDM Q,MMSWP(TT)
VSLS4:	PUSHJ P,LSWPOP
	JRST CLKONJ

VSMS3:	PUSHJ P,LSWPOP
	MOVE A,VSMPG
	SOSGE NVDUSE
	SETOM NVDUSR
	PUSHJ P,CWAIT
	SKIPL VIDSWI
	MOVEM U,VIDSWI
	MOVEM A,VIDSPG
	SKIPL VIDSWI
	PUSHJ P,UFLS
	SUB P,[1,,1]
	JRST AVSCAN
SCNB1:	DATAI NVDX,@NVDPTR
	CONI NVDX,T
	LSH T,-11.
	DPB T,[220200,,@NVDPTR]
	TRNE T,3
	JRST SCNB1C	;OVF OR DCO?
	MOVE T,@NVDPTR
	ANDI T,1777
	CAMG T,NVDDK	;OR VALUE GREATER THAN DCO LEVEL
	JRST NEWORK
SCNB1C:	MOVE T,NVDDK
	DPB T,[1200,,@NVDPTR]
	DPB T,[240600,,@NVDPTR]	;PUT IN FLOATING PART
	LSH T,-6
	DPB T,[330400,,@NVDPTR]
	JRST NEWORK

SCNB2:	CONO NVDX,@TVCONO	;SETUP FOR NEXT VSCAN POINT
	DATAO NVDX,NVIDX
	DATAO NVDY,NVIDY
	MOVE T,NVIDX
	EXCH T,VIDXOL
	SUB T,VIDXOL
	MOVMM T,VIDTEM
	MOVE T,NVIDY
	EXCH T,VIDYOL
	SUB T,VIDYOL
	MOVMS T
	CAMGE T,VIDTEM
	MOVE T,VIDTEM
	CAIL T,1000
	JRST SCNT5
	DATAO NVDT,[-4]
SCNT4:	CLEARM NVDBKR
	EBLK
SCNB1A:	JRST SCNG1	;OR AOS (AOSA) NVDPTR
	BBLK
	JRST SCNS1	;HOMO LINEAR FROB
SCNB1B:	SOSG NVDCNX	;SIMPLE MINDED
	JRST SCNB3
IRPC X,,XY
	MOVE T,BATD!X!1
	ADDB T,BAT!X!1
	HLRZM T,NVID!X
TERMIN
SCNBX:	JRST OMXRET

SCNT5:	TLC T,232000	;CALCULATE SETTLING TIME
	FAD T,T
	LDB T,[330400,,T]
	DATAO NVDT,SETLL-10.(T)
	JRST SCNT4

SCNB3:	SOSG NVDCNY
	JRST SCNB4
IRPC X,,XY
	MOVE T,BATD!X!2
	ADDB T,BAT!X!2
	MOVEM T,BAT!X!1
	HLRZM T,NVID!X
TERMIN

	MOVE T,NVDCN3
	MOVEM T,NVDCNX
	JRST SCNBX

SCNB4:	SKIPL NVDCNY	;WAIT FOR LAST DATAO TO RETURN A POINT
	JRST SCNBX
	SETOM SCNUSR
	SOSL NVDUSE
	JRST NEWORK
	SETOM NVDUSR
	DATAO DSDEV,[DSNVID]	;DEASSIGN BAT
	MOVSI B,-1
	MOVSI W,-2
SCNB4B:	LDB A,VEXT(W)
	TRNN A,600000
	JRST SCNB4A
	ANDI A,777
	ADDM B,MMSWP(A)
SCNB4A:	MOVEI A,0
	DPB A,VEXT(W)
	AOBJN W,SCNB4B
	JRST NEWORK

SCNS1:	MOVEM U,NVDTMU
	SOSG NVDCNX
	JRST SCNS3
IRPC X,,PXY
	MOVE T,BATD!X!1
	ADDB T,BAT!X!1
	IFN .IRPCN,[IDIV T,BATP1
	MOVEM T,NVID!X]
TERMIN

SCNBX1:	MOVE U,NVDTMU
	JRST SCNBX

SCNS3:	SOSG NVDCNY
	JRST SCNB4
IRPC X,,PXY
	MOVE T,BATD!X!2
	ADDB T,BAT!X!2
	MOVEM T,BAT!X!1
	IFN .IRPCN,[IDIV T,BATP1
	MOVEM T,NVID!X]
TERMIN
	MOVE T,NVDCN3
	MOVEM T,NVDCNX
	JRST SCNBX1

SCNG1:	MOVSI T,(AOSA)
	SKIPN BATDP1
	SKIPE BATDP2
	MOVSI T,(AOS)
	HRRI T,NVDPTR
	MOVEM T,SCNB1A
	TLNN T,(AOSA-AOS)
	JRST SCNS1
	JRST SCNB1B

EBLK

NVDIPT:	NVDBUF	;POINTER TO INSERT IN BUF
NVDVPT:	NVDBUF	;POINTER TO WORD  BEING VIDISECTED
NVDOPT:	NVDBUF	;POINTER TO WITHDRAW FROM BUF
NVDCNT:	0	;NUMBER PTS IN BUF
NVDBUF:	BLOCK NVDLNG
VIDSTRT:	0
LBTCNO:	0	;LAST CONO TO BAT
NVDIFL:	0	;+=> RQ TO READ NVD PNT
NVDCOR:	0	;NVD DEV, COORDINATES TO PI, READ DATA FROM PI
NTVCOS:	-1	;# TVC OPENS

IRPC X,,XYP
	IRPC N,,12
		BAT!X!!N:	0
		BATD!X!!N:	0
	TERMIN
TERMIN

NVDCNX:	0
NVDCNY:	0
NVDCN3:	0
NVIDX:	0
NVIDY:	0
BATMXA:	0
NVDPTR:	0
NVDTMU:	0
SCNUSR:	-1	;USER IN CURRENT .VSCAN, -1 .VSCAN FREE
SCNREL:	0
TVCONO:	0	;CONO FOR TVC DEVICE AND VSCAN (NORM HAS CHNL BUT NOT IF IN VIDDLY)
NVDDK:	0	;-1=>VID VALUE CORRESP TO DCO
TVFLG:	0	;-1=>TVC WORK IN PROGRESS
NVDBKR:	-1	;REASON LAST POINT READ IN, DISPATCH ADDRESS FOR INTS
			;-1 NONE  0 VSCAN  1 TVC  2 NVD
TVQBLK:	0	;CLOCK QUEUE BLOCK
	-1
	JRST VIDD1
VIDXOL:	0	;OLD VIDI CORDS
VIDYOL:	0	;OLD VIDI CORDS
VIDTEM:	0	;LARGEST DELTA
VSMPG:	0
VEXT:	.VSB1+EXEUMP
	.VSB2+EXEUMP

BBLK

VIDD1:	MOVEI A,NVDCHN_15.
	IORB A,TVCONO	;RESTORE CHNLS TO TVCONO
	CONO NVDX,2000(A)	;CAUSE EVENTUAL VIDI INT TO SEE IF ANYTHING YO DO
	JRST CLQRET	;RETURN YO CLOCK ROUTINE
]
;
; NULL DEVICE
;  READS ZEROS ON INPUT, HAS NO EFFECT ON OUTPUT
;
NULO:	HLRS A,C		;REMEMBER MODE FOR .STATUS
	JSP Q,OPSLC3	;SET UP IOCHNM WORD AND EXIT
	NLIDN,,NLODN	;ARG
	NLBIDN,,NLBDN	;ARG

;UNIT NULL DEVICE INPUT
NULI:	XCTR XRW,[CLEARM (C)]	;"READ" ZERO
	POPJ P,

;BLOCK NULL DEVICE INPUT (READS ZEROS)
NULBI:	XCTR XRW,[HRRZ D,(C)]	;PICK UP STARTING LOC (R.H. .IOT PNTR)
	XCTR XRW,[HLRE TT,(C)]	;PICK UP NEG LENGTH
	JUMPGE TT,CPOPJ	;IGNORE IF LENGTH ZERO OR RIDICULOUS (>2**17)
	MOVNS TT	;GET POSITIVE LENGTH
	HRLS D		;PUT IN BOTH HALVES
	XCTR XRW,[SETZM (D)]	;ZERO FIRST LOC
	AOS D		;MAKE C(D) A BLT PNTR TO COPY EACH WORD INTO NEXT
	ADD TT,D	;GET LAST LOC + 2
	XCTR XRW,[BLT D,-2(TT)]	;ZERO THE BLOCK
;BLOCK NULL DEVICE OUTPUT ENTRY
;ADVANCE BLOCK MODE .IOT POINTER
NULBOD:	XCTR XRW,[HLRE A,(C)]	;GET NEG LENGTH FROM LEFT HALF
	MOVNS A		;GET POSITIVE LENGTH
	XCTR XRW,[ADD A,(C)]	;ADD STARTING LOC (R.H.)
	XCTR XRW,[HRRZM A,(C)]	;STORE BACK "COUNTED OUT" POINTER
	POPJ P,

STDSTA:	DPB A,[60300,,D]
	TRO D,1_9
	TRNE D,1_6
	TRC D,3_9
	POPJ P,

IFN NETP,.INSRT IMP > SYSENG;
;
; USER DEVICE ROUTINES
;
UBPFJ==10	;DEMAND FOREIGN JOB (BIT IN LH (DEV) FOR .OPEN (USR))

USROJ:	TDZA J,J	;ENTRY FROM JOB DEVICE DONT GET CORE.
USRO:	MOVNI J,1	;INDICATE NOT FROM JOB OPEN
	JUMPE B,OPNL11	;DON'T ALLOW 0 JNAME
	PCLT
	SKIPL CORRQ(U)
	PUSHJ P,UFLS	;PREVENT ATTEMPT TO CORE, PCLSR OUT, AND THINK YOU'VE WON AT SETBF1, ETC
	SKIPN A		;IF UNAME=0
	MOVE A,UNAME(U)	;MAKE IT THIS JOB'S UNAME
IFN PDP6P,[
	CAME A,UNAME(U)	;SKIP IF FIRST FILE NAME IS UNAME OF OPENER
	JRST USROA
	CAME B,[SIXBIT /PDP10/]	;SKIP IF SECOND FILE NAME IS "PDP10"
	CAMN B,[SIXBIT /PDP6/]	;OR PDP6
	JRST PDPO
]
USROA:	MOVEI TT,0
	CONO PI,CLKOFF
USRO3:	CAME A,UNAME(TT)
	JRST AGIN
	CAMN B,JNAME(TT)
	JRST UFN1	;FOUND UNAME JNAME PAIR
AGIN:	ADDI TT,LUBLK
	CAMGE TT,USRHI
	JRST USRO3
	PUSH P,U
	MOVEI TT,2	;COUNT OF TRIES FOR SYS JOB TO GET CORE
TCORS:	TLNE C,UBPFJ	;JOB MUST EXIST TO WIN IF UBPFJ SET
	JRST NOGO5
	CAME A,UNAME(U)	;INFERIOR PROCEDURE MUST HAVE
	JRST NOGO2
	MOVSI T,600000	;DOESN'T HAVE TTY
	PUSHJ P,USTRA	;MUST HAVE U IN -1(P)
	JRST TCORS1
	MOVEM A,UNAME(U)
	MOVEM B,JNAME(U)
	MOVEM A,USYSNM(U)
	MOVE TT,U
	POP P,U
	MOVSI A,400000
	SKIPGE APRC(U)
	IORM A,APRC(TT)	;NEW INFERIOR IS DISOWNED
	CONO PI,CLKON
	MOVE A,UTMPTR(U)
	MOVEM A,UTMPTR(TT)
	JUMPE J,POPJ1	;RETURN HERE FOR JOB DEVICE (INDEX IN TT)
	PUSHJ P,ULUP1
	JRST NOGO1
	JRST SETBIT

ULUP1:	CLEARB A,T
ULUP:	HRRZ E,SUPPRO(T)
	SKIPN UNAME(T)	;SKIP IF VARIABLE BLOCK IN USE
	JRST ULUP2
	CAIN E,(U)	;SKIP IF NOT AN INFERIOR
	IOR A,SUPPRO(T)	;IOR IN INTERRUPT BIT OF INFERIOR
ULUP2:	ADDI T,LUBLK	;ADVANCE TO NEXT BLOCK
	CAMGE T,USRHI	;SKIP IF ALL EXAMINED
	JRST ULUP	;LOOP
UFIN:	MOVEI B,1	;SELECT INT BIT
UFIN2:	TLON A,(B)
	JRST POPJ1
	LSH B,1
	CAIGE B,1_<NINFP>
	JRST UFIN2
	POPJ P,

NOGO1:	MOVE U,TT
	PUSHJ P,ZUSER
	JRST OPNL5	;DIREC FULL (TOO MANY LOSERS)

NOGO2:	SUB P,[1,,1]
	JRST OPNL20

NOGO3:	SUB P,[1,,1]
	JRST OPNL10

NOGO4:	SUB P,[1,,1]
	JRST OPNL6

NOGO5:	SUB P,[1,,1]
	JRST OPNL4	;FILE NOT FOUND

UFN1:	JUMPE J,[JRST 4,.]	;NOT SUPPOSED TO GET HERE FOR JOB DEVICE.
	CAIG TT,LUBLK
	JRST UFNDF	;SKIP SOME CHECKS ON SYS & CORE
	SKIPE NMPGS(TT)
	JRST UFN1A
	MOVSI T,BUSRCR	;CONT LET FOREIGN USERS OPEN JOB
	PCLT
	TDNE T,APRC(TT)	;UNTIL JOB HAS CORE (I.E. ORIG OPEN THAT CREATED JOB
	PUSHJ P,UFLS	;HAS COMPLETED). OTHERWISE
			;ZUSER CALLED WHEN THAT OPEN PC LSRED OUT OF COULD
			;ITSELF HANG UP TRYING TO FLUSH FOREIGN USER CHNLS
UFN1A:	TLNE C,UBPFJ
	JRST UFNDF	;USER WANTS IT AS FOREIGN JOB
	HRRZ E,SUPPRO(TT)
	CAIN E,(U)
	JRST UFN1C	;OPENING UP INFERIOR
	SKIPGE APRC(TT)
	SKIPGE APRC(U)
	JRST UFNDF	;OPENING PROCEDURE DISOWNED OR OPENED PROCEDURE NOT DISOWNED => FOREIGN USER
		;PROCEDURE BEING OPEN DISOWNED, OPENING PROCEDURE NOT DISOWNED
	SKIPL SUPPRO(TT)	;IF DISOWNED PROCEDURE NOT AT TOP LEVEL,
	JRST UFNDF	;THEN FOREIGN JOB
	JRST UFN2	;ATTACH DISOWNED TREE

UFN1C:	MOVE U,TT	;OPENING PROCEDURE IMMEDIATE SUPERIOR OF PROCEDURE BEING OPENED
	JRST UFOUND

TCORS1:	SOJLE TT,NOGO4
	PCLT
	SKIPGE SUPCOR
	PUSHJ P,UFLS
	CONO PI,CLKOFF
	JRST TCORS

;
; ATTACH A DISOWNED PROCEDURE TREE
;

UFN2:	PUSHJ P,ULUP1	;FIND AN INTERRUPT BIT
	JRST OPNL5	;ALL USED (TOO MANY INFERIORS)
	SETOM DLSRCH	;INHIBIT SCHEDULING
	CONO PI,CLKON	;TURN CLOCK BACK ON, THIS MAY TAKE A WHILE
	MOVE A,UNAME(U)	;PICK UP NEW UNAME
	PUSH P,B	;SAVE INTERRUPT BIT
	MOVE D,UTMPTR(U)	;PICK UP NEW USER RESOURCE POINTER
	MOVE J,D
	SUBI J,USRRCE	;GET NEW CONSOLE #
UFN3:	MOVEM A,UNAME(TT)	;SET TO NEW UNAME
	MOVEM D,UTMPTR(TT)	;SET TO NEW USER RESOURCE POINTER
	MOVEI R,IOCHNM(TT)
	PUSHJ P,CHSCAN
	PUSHJ P,UFN3ZZ
	MOVSI T,400000
	ANDCAM T,APRC(TT)	;MARK AS NOT DISOWNED
UFNL3:	MOVE B,JNAME(TT)	;PICK UP CURRENT JNAME
	MOVEI E,0	;LOOP ON ALL USERS
UFNL1:	SKIPN UNAME(E)	;SKIP IF VAR BLOCK IN USE
	JRST UFNL2
	CAMN A,UNAME(E)	;SKIP ON NOT SAME UNAME
	CAME B,JNAME(E)	;SKIP ON SAME UNAME-JNAME
	JRST UFNL2
	SKIPL APRC(E)	;SAME NAMES, IGNORE IF DISOWNED
	JRST UFN7	;TRUE NAME CONFLICT, RESOLVE
UFNL2:	ADDI E,LUBLK
	CAMGE E,USRHI
	JRST UFNL1
	MOVEI E,0	;INITIALIZE FOR LOOP TO LOOK FOR INFERIORS AND DUPLICATE NAMES
UFN4:	SKIPN UNAME(E)	;SKIP IF VAR BLOCK IN USE
	JRST UFN5	;TRY NEXT
	HRRZ I,SUPPRO(E)	;PICK UP SUPERIOR POINTER OF BLOCK BEING EXAMINED
	CAIN I,(TT)	;SKIP IF NOT INFERIOR
	JRST UFN6	;INFERIOR, PSEUDO-RECURSE
UFN5:	ADDI E,LUBLK	;ADVANCE TO NEXT BLOCK
	CAMGE E,USRHI	;SKIP IF ALL EXAMINED
	JRST UFN4	;LOOP
	SKIPGE SUPPRO(TT)	;SKIP IF NOT BACK TO TOP
	JRST UFNX	;BACK TO TOP LEVEL
	MOVE E,TT	;POP BACK UP
	HRRZ TT,SUPPRO(E)	;TO PREVIOUS LEVEL
	MOVE B,JNAME(TT)	;RESTORE B
	JRST UFN5	;PROCEED AT PREVIOUS LEVEL

UFNX:	POP P,B
	HRLM B,SUPPRO(TT)
	HRRM U,SUPPRO(TT)	;SET UP SUPERIOR POINTER IN TO LEVEL DISOWNED
	SETZM DLSRCH	;RE-ENABLE SCHEDULING
	MOVE U,TT
	JRST UFOUND

UFN6:	MOVE TT,E	;PSEUDO-RECURSE
	JRST UFN3	;START UP ON LOWER LEVEL

UFN7:	CAMN E,TT	;SKIP UNLESS FOUND SELF
	JRST UFNL2
	ADDI TT,JNAME	;SET UP ARG TO SIXAOS
	PUSHJ P,SIXAOS	;INCREMENT JNAME
	SUBI TT,JNAME	;RESTORE TT
	JRST UFNL3	;RESTART LOOP

	;RESUSCITATE TTY CHNLS
UFN3ZZ:	HRRZ Q,(R)
	CAIL Q,TYIDN
	CAILE Q,TYOBN
	POPJ P,		;NOT A TTY CH
	HLRZ Q,(R)
	TRNN Q,400000
	POPJ P,		;NOT CONSOLE
	AOS TTNTO(J)
	DPB J,[220700,,(R)]
	POPJ P,

SETBIT:	HRLZ B,B
	HRR B,U
	MOVEM B,SUPPRO(TT)
	MOVE U,TT
	PUSHJ P,UFOUND
	JFCL
	MOVE U,TT
	MOVEI B,1
	PUSHJ P,ACORE	;MAY PCLSR OUT
	JRST OPNL6
	JRST POPJ1

UFOUND:	HLRZS C	;U HAS INF PROC
	HRL A,U
	MOVE U,USER
	MOVE R,UUAC(U)
	ADDI R,IOCHNM(U)	;CLOBBERED BY CORE
	JSP Q,OPSLC3
	UWIDN,,UWODN
	UBIDN,,UBODN

UFNDF:	TLNE C,1
	JRST OPNL12	;ATTEMPTED OUTPUT
	LDB A,[420100,,APRC(TT)]
	JUMPN A,OPNL20	;USER GOING AWAY
	HRL A,TT
	JSP Q,OPSLD1
	FUWIDN,,FUBIDN

ULOSE:	MOVE U,USER
	MOVEI T,ILLUAD
	JRST UUOERR

USRST:	PUSHJ P,AUCL2	;.RESET SIMULATES CLOSING AND REOPENING
	EXCH U,A	;BUT WITH LESS OVERHEAD
	PUSH P,A
	SKIPE B,NMPGS(U)
	MOVEI B,1
	PUSHJ P,UBLAST
	MOVSI T,600000
	MOVEM T,TTYTBL(U)
	MOVE J,U
	EXCH U,(P)
	HRLI J,240000
	PUSHJ P,MPLD1
	XCTR XRW,[CLEARM 0]
	MOVEI T,1
	SKIPN NMPGS(J)
	JRST USRST5
	XCTR XRW,[BLT T,1777]
USRST6:	PUSHJ P,MPLDZ
	EXCH U,(P)
	PUSHJ P,USRST2
	PUSHJ P,USRST4	;SHOULD SKIP
	JRST 4,.
	MOVE T,UNAME(U)
	MOVEM T,USYSNM(U)
	POP P,A
	EXCH U,A
	POPJ P,

USRST5:	XCTR XRW,[BLT T,17]
	JRST USRST6

UBO1:	TLZ A,400000	;NEED MORE CORE
UMEMEX:	MOVSI TT,BSSTP
	CAME A,USER
	IORM TT,USTP(A)
	PUSHJ P,UPCLSR
	MOVE B,D
	ADDI B,2000-1
	LSH B,-10.
	PUSH P,A
	PUSHJ P,FINSET
	TRYOV1
	EXCH U,A
	PUSHJ P,ACORE
	JRST ULOSE1
	PUSHJ P,LSWDEL
	SUB P,[1,,1]
	EXCH U,A
	PUSHJ P,ZBSSTP
	JRST UUOTRO

ULOSE1:	PUSHJ P,LSWDEL
	MOVSI TT,BSSTP
	ANDCAM TT,USTP(U)
	JRST ULOSE

TRYOV1:	POP P,A
	MOVE U,USER
ZBSSTP:	MOVSI TT,BSSTP
	ANDCAM TT,USTP(A)
	POPJ P,

UWO:	HRRO W,40
	MOVE C,[SETZ W]

UBO:	MOVNI I,1
	JRST UBIL
;COMMENTS BELOW APPLY TO UBI IN MANY CASES.  FOR UBO, TRANSFER GOES THE
;OTHER DIRECTION

UWI:	HRRO W,40
	MOVE C,[SETZ W]	;SIGNAL NOT TO BE RELOCATED
UBI:	MOVEI I,0	;SIGNAL UBI

UBIL:	JUMPL C,UBIA
	XCTR XRW,[MOVES TT,(C)]	;MAKE SURE WRITE CYCLES WILL WIN
UBIB:	TRNE A,200000	;SKIP UNLESS 6
	MOVNI A,1	;SO CAILE BELOW WILL SKIP OVER SUSTPR AMONG OTHER REASONS
	CAILE A,LUBLK	;SKIP ON SYS JOB, CORE JOB, PDP6 OR JOB ALREADY STOPPED
	PUSHJ P,SUSTPR	;RANDOM JOB STOP
	JUMPGE TT,UBI4	;THRU
	TLO A,400000	;INDICATE ALREADY STOPPED SO WONT TRY IT AGAIN
	HLRO B,TT
	MOVNS D,B	;COUNT TO BE XFERRED
	HRLZ E,IOCHST-IOCHNM(R)	;EXAMINED USER ADDRESS
	HRR E,TT	;FROM,,TO (INFERIOR ADR,,SUPERIOR ADR)
	HLRZ Q,E
	ADD D,Q	;HIGHEST ADR +1
	CAMLE D,[1,,]
	JRST UBMCK1	;TRYING TO WRAP AROUND
	TLNE A,200000
	JRST UBI5A	;PDP6
	CAMLE D,HUSRAD(A)
	JUMPN I,UBO1	;DONT HAVE ENUF MEM ON WRITE
UBI5:	CAIGE Q,20	;INF ADR IN Q
	JRST UBI3	;READ AC
	HRRZ J,A	;SET UP UMAPS WORD
	TRZE E,400000
	TLOA J,200000	;TO HI PG, HACK OUR LOW PG
	TLO J,100000	;TO LOW PG, HACK OUR HI PG
	TLZE E,400000
	TLOA J,20000	;TO POINT TO HIS UPPER
	TLO J,40000	;TO POINT TO HIS LOWER
	TLNN J,140000	;UPPER TO UPPER XFER ?
	JRST UBI3A	;YES MAKE SURE NOT SCREWED BY AC PNTR
UBI3B:	PUSHJ P,MPLD1
	TRZ Q,400000
	MOVNS Q	;LIMIT SIZE OF XFER TO MIN OF DESIRED
	ADDI Q,400000	;DIST OF TO ADR FROM SEG BOUNDARY
	CAMLE B,Q
	HRRZ B,Q
	MOVNI Q,(E)	;AND DIST OF FROM ADR FROM SEQ BOUNDARY
	ADDI Q,400000
	CAMLE B,Q
	HRRZ B,Q
	TLNN J,200000	;BUGGER ADDRESSES SO RIGHT DBRS WILL BE USED
	TLOA E,400000	;SET FROM ADR TO HI PG
	TRO E,400000	;SET TO ADR TO HI PG
	SKIPE I	;SKIP ON UBI
	MOVSS E	;UBO, XFERR OTHER DIRECTION
	MOVE Q,E	;SAVE COPY OF BLT PNTR
	ADDI B,(E)	;GET LA +1
	TLNE B,-1
	SOJA B,UBI3F	;AVOID -1 LOSSAGE
UBI3H:	XCTR XRWI,[BLT E,-1(B)]	;XFERR DATA
UBI3K:	MOVEI E,(B)	;NO FAULT, SIMULATE STORE BACK OF BLT PNTR AFTER COMP OF BLT (RH ANYWAY)
UBI3L:	PUSH P,J
	PUSHJ P,MPLDZ	;RETURN TO NORMAL MAP TO STORE BACK USER PNTR
	POP P,J	;SAVE PREV MAP FOR EVENTUAL USE
	SUBM E,Q	;FIGURE OUT HOW MANY WDS ACTUALLY XFERRED
	HRRZS Q
UBI3E:	ADDM Q,IOCHST-IOCHNM(R)	;UPDATE INFERIOR PNTR
	HRLS Q
	JUMPL C,UBIC	;UPDATE USER PNTR
	XCTR XRWI,[ADDM Q,(C)]
	JRST .+2
	JRST 4,.	;SHOULD HAVE ALREADY CHECKED THIS
UBID:	TLZ B,-1
	CAIN B,(E)	;WAS THERE A FAULT?
	JRST UBIL	;NO LOOP
	PUSHJ P,UBI4	;TAKE FAULT
	PUSHJ P,MPLD1	;RESTORE TO FROB AT TIME OF FAULT
UBI3C:	PUSHJ P,TPFLT
	PUSHJ P,MPLDZ
	JRST UBIL

UBI3F:	CAIE B,(E)
	JRST UBI3H	;XFERR ALL BUT LAST WORD
	HLRZ TT,E
	XCTR XRI,[MOVE T,(TT)]
	JRST .+2
	AOJA B,UBI3L
	XCTR XWI,[MOVEM T,(E)]
	AOJA B,UBI3K
	AOJA B,UBI3L

UBI4:	TLNN A,200000	;SKIP ON REALLY PDP6
	TLZ A,400000	;FLUSH RANDOM BIT SO COMPARE WILL WORK
	CAILE A,LUBLK
	JRST UPCLSR
	POPJ P,

UBMCK1:	PUSHJ P,UBI4
	JRST IOADC

UBIA:	TRNE C,777760
	JRST 4,.
	MOVE TT,(C)
	JRST UBIB

UBIC:	TRNE C,777760
	JRST 4,.
	ADDM Q,(C)
	JRST UBID
UBI5A:	CAIL D,400000
	JRST UBMCK1
	JRST UBI5
UBI3A:	TLNE E,777760	;SKIP ON XFERRING FROM AC AREA, HI TO HI
	JRST UBI3B	;NO OK
	JUMPN I,UBO3A	;UBO
	HRLI J,120000	;HACK OUR HI TO PNT TO HIS
	PUSHJ P,MPLD1
	XCTR XRI,[MOVE B,(Q)]	;PICK UP WD
	JRST .+2	;OK
	JRST UBI3C	;TAKE FAULT
	PUSHJ P,MPLDZ	;BACK TO NORMAL MAP
	HRRZ E,TT	;TO ADR
	JRST UBI3D

;USR DEV IOT STOP ROUTINE
USUSTP:	SOS USTP(A)
SUSTPR:	MOVSI T,BCSTOP+BUCSTP
	TDNE T,USTP(A)	;WAIT TILL NOT BEING SHUFFLED
	PUSHJ P,UFLS
	PUSHJ P,RPCLSR	;AOS'ES USTP
	MOVSI T,BCSTOP+BUCSTP
	TDNE T,USTP(A)
	JRST USUSTP
	POPJ P,

UBI3:	ADDI Q,AC0S(A)
	JUMPN I,UBO3	;UBO
	TLNE A,200000
	TDZA B,B	;READ PDP6 AC
	MOVE B,(Q)	;READ NORMAL AC
UBI3D:	XCTR XWI,[MOVEM B,(E)]
	JRST .+2
	JRST UBI3C	;TAKE FAULT
UBI3G:	MOVEI Q,1	;1 WD XFERRED
	HRRZ B,E	;FAKE OUT FAULT TEST
	JRST UBI3E

UBO3:	TLNE A,200000
	JRST UBI3G	;TRYING TO WRITE PDP6 AC IGNORE
	XCTR XRI,[MOVE B,(E)]
	JRST .+2
	JRST UBI3C
	MOVEM B,(Q)
	JRST UBI3G


UBO3A:	XCTR XRI,[MOVE B,(TT)]
	JRST .+2
	JRST UBI3C	;TAKE FAULT
	HRLI J,120000
	PUSHJ P,MPLD1	;SWITCH OUR HI PAGE TO PNT TO HIS HI PG
	XCTR XWI,[MOVEM B,(Q)]
	JRST .+2
	JRST UBI3C
	PUSHJ P,MPLDZ	;BACK TO NORMAL
	JRST UBI3G

;LINE PRINTER ROUTINES

IFN NLPTP,[
NLPTO:	MOVE A,UTMPTR(U)
	SKIPGE NLUSR
	SKIPL TTYTYP-USRRCE(A)
	JRST TPLO
NLPTO2:	PUSH P,[NLPTO1]
	JSP Q,STDOPN
	1,,NLUSR
	NLPTDN,,NLPTBN

NLPTO1:	POPJ P,
	AOS (P)
NLPTO3:	HRROI I,NLPTCF
	HRROI C,I
	PUSHJ P,BNLPTO
	HRRZ I,NLPTBP
	SUBI I,1
	HRLI I,010700
	MOVEM I,NLPTIP
	POPJ P,

NLPTCF:	15_29.+14_22.+177_15.+177_8+177_1
]

IFN OLPTP,[

LPTLPP==60.

LPTO:	CAMN U,OLUSR
	JRST LPTO2	;ALREADY HAS IT
	MOVE A,UTMPTR(U)	;GET POINTER TO USER RESOURCE
			;(TTY DEPENDANT)
	SKIPL TTYTYP-USRRCE(A)
	JRST TPLO
LPTO2:	PUSH P,[LPTO1]
	JSP Q,STDOPN
	1,,OLUSR
	LPTDN,,LPTBN

LPTO1:	POPJ P,		;OPEN LOST
	SKIPE OLUSE	;OPEN WON
	JRST POPJ1	;NOT FIRST OPEN BY THIS USER
	AOS (P)
LPTRS2:	MOVEI A,15	;ENTRY FROM LPTRS, DUMP OUT CRUD ON THIS LINE THEN FORM FEED
	PUSHJ P,PILPT
	MOVEI A,14
	JRST PILPT

BLPTO:	MOVEI E,PILPT
	JRST NBTOCH

PILPT1:	XCTR XR,[MOVE A,(C)]
	ANDI A,177
PILPT:	CAIN A,177
	POPJ P,		;IGNORE RUBOUTS
	MOVEI T,130.	;LPTCC COMPARED WITH 132. BY SYSTEM JOB BEFORE TRY OF .OPEN
	CAMLE T,LPTCC
	JRST LPTW1	;WAIT
LPTIM:	CAIGE A,40
	JRST LPTRC
	CAIL A,140
	SUBI A,40
LPTIM2:	AOSN LPTBSF
	PUSHJ P,LPC	;PRINT PREV STUFF AND SPACE OVER
	AOS T,LINEPOS
BADCOL:	CAIN T,-1	;PATCH NUM OF BAD COL IN HERE WHEN NECESSARY
	JRST LPTBC1
	CAILE T,120.
	JRST PILPT2
LPC1:	SUBI A,40
	IDPB A,LPTIP
	HRRZ A,LPTIP
	CAIN A,LPTBE-1
	MOVEI A,LPTBO
	HRRM A,LPTIP
	SOS LPTCC
	CONSO OLPT,7
	CONO OLPT,LPTCHN
	POPJ P,

LPTBC1:	PUSH P,A
	MOVEI A,40
	PUSHJ P,LPC1
	POP P,A
	JRST LPC1

LPTRC:	CAIN A,10
	JRST LPTBS	;BACK SPACE
	CAIN A,11
	JRST LPTTAB
	CAIN A,12
	JRST LPTLF
	CAIN A,14
	JRST LPTFF
	CAIN A,EOFCH
	JRST LPTEOF
	SETOM PCL
	CAIE A,15
	JRST LPTRCH
LPT.CR:	SETZM LINEPOS
	SETZM LPTBSF
	JRST LPC1

	PUSHJ P,LPTW2
LPTW1:	PUSHJ P,UFLS
	JRST LPTIM

LPTW2:	CAMLE T,LPTCC
	POPJ P,
	MOVE T,LPTCC
	CAIL T,<LPTBE-LPTBO>*2
	JRST POPJ1
	JRST POPJ3

LPTBS:	SKIPG LINEPOS
	POPJ P,	;AT BEG OF LINE, IGNORE
	SOS LINEPOS
	SETOM LPTBSF
	POPJ P,

LPTRCH:	CAIN A,33
	JRST LPTALT
	MOVE B,A
	MOVEI A,"^
	PUSHJ P,LPTIM2
	MOVEI A,100(B)
	JRST LPTIM2

LPTALT:	MOVEI A,"$
	JRST LPTIM2

PILPT2:	SOS LINEPOS
	POPJ P,

LPTEOF:	SKIPE OLUSR
	POPJ P,
	SUB P,[1,,1]	;SYSTEM JOB HACKING  SO CLOBBER TO EOF
	XCTR XRW,[CLEARM (C)]
	POPJ P,

LPTCLS:	SKIPLE OLUSE	;LPT CLOSE, IS THIS THE ONLY CHANNEL LPT OPEN ON
	JRST LPTCL3
	SKIPN LINEPOS	;THIS IS LAST CLOSE, CHECK TO SEE IF LOSER LEFT POSITION SCREWED
	SKIPE LPTPPS
	PUSHJ P,LPTCL2	;INCREMENT TO NEXT PAGE
	MOVEI T,200000
	IORM T,SUPCOR	;LOOK FOR TPL FILES TO PRINT
	SETOM OLUSR	;DO THIS FIRST SO DONT NEED CLOCK OFF LPT HACKED BY ONE JOB AT A TIME
LPTCL3:	SOS OLUSE	;DECREMENT USE COUNT
	POPJ P,

LPTCL2:	MOVEI A,100.
	CAMLE A,LPTCC
	POPJ P,	;NO ROOM FORGET IT
	MOVEI A,15
	PUSHJ P,LPTIM
	MOVEI A,14
	JRST LPTIM
LPTTAB:	PUSHJ P,LPTS
	LDB J,[300,,LINEPOS]
	JUMPE J,CPOPJ
	JRST .-3

LPTS:	MOVEI A,40
	JRST LPTIM2

LPTLF:	AOS J,LPTPPS	;LINE FEED, INCREMENT LINE #
	CAIL J,LPTLPP	;END OF PAGE?
LPTFF:	SETZM LPTPPS	;END OF PAGE CLEAR OUT PAGE POS (ENTRY FOR FF)
	PUSHJ P,LPC
	JRST LPC1

LPC:	MOVE J,LINEPOS	;CR AND SPACE BACK OVER TO LINPOS
	MOVE B,A
	MOVEI A,15
	AOSN PCL
	SKIPE LINEPOS
	PUSHJ P,LPT.CR
	CLEARM LPTBSF	;IN CASE WAS ALREADY AT BEG OF LINE
	SOJL J,LPC2
	PUSHJ P,LPTS
	JRST .-2

LPC2:	MOVE A,B
	POPJ P,

EBLK

LPTCC:	<LPTBE-LPTBO>*5-5
LINEPOS:	0	;LINE POSITION # CHARS PRINTED THIS LINE BEFORE CURRENT
LPTPPS:	0	;PAGE POSITION (# LINES PRINTED BEFORE CURRENT)

PCL:	0	;INCREMENTED BY LF OR FF, SETOMED BY OHTER CONTROL CHARS
	;PROBABLY UNNECESSARY BUT NOT WORTH FLUSHING
LPTBSF:	0	;-1 => BACKSPACES HAVE BEEN TYPED, CR AND SPACE OVER BEFORE MAKING INK

LPTIP:	700,,LPTBO-1
LPTOP:	700,,LPTBO-1

BBLK

LPTCN:	CAIN A,<15-40>&177
	JRST LPTCR	;CRR
	CAIN A,<12-40>&177
	MOVEI A,400	;LINE FEED
	CAIN A,<14-40>&177
	MOVEI A,401	;FORM FEED
	CAIE A,177	;SKIP IF LOOKS LIKE A LEFT ARROW
	JRST LPTCN1	;GO TO PRINT
	HRRZ A,LPTOP	;LOAD OUPUT POINTER
	CAIE A,LPTBE-1	;SKIP IF CURRENT PNTR = END OF BUFFER
	JRST LPENT3	;REAL LEFT ARR
	MOVE A,[350700,,LPTBO]
	MOVEM A,LPTOP
	JRST LPENT2
]

IFN NLPTP,[
NLPT1:	XCTR XR,[MOVE A,(C)]
	MOVE B,NLPTIP
	TLNN B,760000
	JRST NLPTW	;MAY NOT BE ROOM
NLPTW1:	IDPB A,NLPTIP
	MOVE T,NLPTIP
	CAMN T,NLPTEP
	SUBI T,LPTBSZ
	HRRM T,NLPTIP
	TLNE T,760000
	POPJ P,
	SOSGE NLPTBR
	JRST 4,.
NLPTGO:	CONO PI,LPTOFF
	CONSO NLPT,7
	CONO NLPT,100+LPTCHN	;SET OUTPUT DONE
	JRST LPTONJ

NLPTW:	SKIPG NLPTBR
	PUSHJ P,UFLS
	JRST NLPTW1

EBLK

NLPTIP:	010700,,NLPTBO-1
NLPTBO:	BLOCK LPTBSZ
NLPTEP:	010700,,NLPTBO+LPTBSZ-1
NLPTPP:	NLPTBO
NLPTBR:	LPTBSZ
NLPTBP:	NLPTBO	;BLKT POINTER
NLPTBC:	LPTBSZ	;BLKT CNT = MIN(# WDS TILL END OF BUF,NLPTBR)
NLPTOP:	NLPTBO	;VALUE OF NLPTBP BEFORE BLKT CALL

BBLK

BNLPTO:	MOVE B,NLPTBP
	MOVEM B,NLPTOP
	PUSH P,[BNLPT1]
	JSP B,BLKT
	SETZ NLPTBP
	NLPTBC
	BNLPTG
	BNLPT1
	@J
	SKIPG NLPTBR

BNLPT1:	MOVE T,NLPTBP
	MOVE W,T
	CAIN T,NLPTBO+LPTBSZ
	MOVEI T,NLPTBO
	MOVEM T,NLPTBP
	EXCH T,NLPTOP
	SUB T,W	;- # WORDS WRITTEN
	ADDB T,NLPTBR	;DECREASE ROOM
	JUMPL T,[JRST 4,.]
	JRST NLPTGO

BNLPTG:	MOVE TT,NLPTBP
	MOVE J,NLPTBR
	MOVEI T,NLPTBO+LPTBSZ
	SUB T,TT	;# WORDS UNTIL END OF BUFFER
	CAMLE J,T
	MOVE J,T
	JRST POPJ1

NLPTCL:	SKIPLE NLPTBR	;ENOUGH ROOM?
	PUSHJ P,NLPTO3
	MOVEI T,200000
	IORM T,SUPCOR
	SETOM NLUSR
	SETOM NLUSE
	POPJ P,

NLPDCL:	MOVSI H,760000
	SKIPA A,[177]
NLPDC1:	PUSHJ P,NLPTW1
	TDNE H,NLPTIP
	JRST NLPDC1
	HRRZ A,NLPTIP
	ADDI A,1
	CAIN A,NLPTBO+LPTBSZ
	MOVEI A,NLPTBO
	MOVEM A,NLPTBP
	SUBI A,NLPTBO+LPTBSZ
	MOVNS A
	MOVE B,NLPTBR
	CAMLE A,B
	MOVE A,B
	MOVEM A,NLPTBC
	JRST NLPTCL
]

EBLK
LPTBRK:	0
BBLK
	MOVEM A,LPTA
IFN OLPTP,[
	CONSZ OLPT,7
	CONSZ OLPT,10
	JRST .+2
	JRST LPENT1	;LINE PRINTER
]
IFN NLPTP,[
	CONSZ NLPT,7
	CONSO NLPT,100	;DONE
	JRST .+2
	JRST NLPENT	;NEW LINE PRINTER
]
IFN 340P,[
	CONSO DIS,77
	JRST LPTBR2
	CONSZ DIS,7400
	JRST SRECYC	;SPECIAL DISPLAY CHNL
]
LPTBR2:	MOVEM B,LPTB
IFN PLTP,[
	CONSZ PLT,SDS+PDS
	JRST PLTBRK	;PLOTTER
]
	CONSZ PTR,7
	CONSO PTR,10
	JRST .+2
	JRST PTRBRK
	CONSZ PTP,10
	JRST PBRK1	;PAPER TAPE PUNCH
IFN PDP6P,[
	CONSO DSDEV,7
	JRST .+3
	CONSZ DSDEV,10
	JRST DSDBRK	;INTERRUPT FROM OTHER PROCESSOR
]
IFN STKP,[
	CONSZ STK,7
	CONSO STK,10
	JRST .+2
	JRST STKINT
]
LPBKRT:	MOVE A,LPTA
	JRST 12,@LPTBRK

LPTRT1:	MOVS A,[C,,LPTACS]
	BLT A,17
LPTRT3:	MOVE B,LPTB
	MOVE A,LPTA
	JRST 12,@LPTBRK

EBLK
LPTA:	0
LPTB:	0
LPTACS:	BLOCK 15
BBLK

IFN OLPTP,[
LPENT3:	MOVEI A,177
	JRST LPTCN1

LPTCR:	CONO OLPT,10+LPTCHN	;PRINT LINE
	AOS LPTCC
	JRST LPBKRT

LPENT1:	MOVEI A,<LPTBE-LPTBO>*5-5
	CAMG A,LPTCC
	JRST LPTSTP
LPENT2:	ILDB A,LPTOP
	TRNE A,100
	JRST LPTCN
LPTCN1:	DATAO OLPT,A	;OUTPUT CHARACTER
	AOS A,LPTCC
	CONSZ OLPT,10
	JRST LPBKRT
	CAIGE A,<LPTBE-LPTBO>*5-5
	JRST LPENT2
LPTSTP:	CONO OLPT,0	;CLEAR PIA
	JRST LPBKRT

EBLK

LPTBO:	BLOCK LPTBSZ-1
	-1
LPTBE:

BBLK

STALPT:	MOVE E,LINEPOS
	DPB E,[130700,,D]
	DPB A,[60300,,D]	;MODE
	MOVE E,LPTCC
	CAIG E,150.
	TRO D,1_9.
	CAIL E,30000
	TRO D,1_<9.+1>
	POPJ P,

LPTRS:	CONO PI,LPTOFF
	MOVEI A,5*<LPTBE-LPTBO>-5
	MOVEM A,LPTCC
	MOVE A,[700,,LPTBO-1]
	MOVEM A,LPTIP
	MOVEM A,LPTOP
	SETZM LINEPOS
	CONO PI,LPTON
	JRST LPTRS2

]

IFN NLPTP,[
NLPENT:	MOVE A,NLPTBR
	CAIN A,LPTBSZ
	JRST NLPTST
	CAIL A,LPTBSZ
	JRST 4,.
	DATAO NLPT,@NLPTPP
	AOS A,NLPTPP
	CAIN A,NLPTBO+LPTBSZ
	MOVEI A,NLPTBO
	MOVEM A,NLPTPP
	AOS NLPTBR
	JRST LPBKRT

NLPTST:	CONO NLPT,200	;CLEAR DONE AND PIA
	JRST LPBKRT

NLPTRS:	CONO PI,LPTOFF
	MOVE A,[010700,,NLPTBO-1]
	MOVEM A,NLPTIP
	MOVEI A,NLPTBO
	MOVEM A,NLPTPP
	MOVEM A,NLPTBP
	MOVEM A,NLPTOP
	MOVEI A,LPTBSZ
	MOVEM A,NLPTBR
	MOVEM A,NLPTBC
	CONO PI,LPTON
	JRST NLPTO3
]
IFN TABP,[

ITAB:	IFE TABCLK,[
	SOSLE TABRTC
	JRST ITAB6
	SKIPGE TABUSR
	JRST ITAB7
	MOVE A,TABRTE
	MOVEM A,TABRTC
	CONO RBTCON,RTABC_3+TABCHN
]	IFN TABCLK,	CONO RBTCON,RTABC_3
	ROT A,36.*2
	DATAI RBTCON,A
	JUMPL A,ITAB	;TRY AGAIN
	LDB B,[400300,,A]
	CAME B,TABLSZ
	JRST ITAB2
	CAIN B,7
	JRST ITAB3	;PEN OUT OF CONTACT
	LDB B,[221400,,A]	;X
	SUB B,TABLSX
	MOVMS B
	CAML B,TABDTA
	JRST ITAB2
	LDB B,[1400,,A]
	SUB B,TABLSY
	MOVMS B
	CAML B,TABDTA
	JRST ITAB2
ITAB3:	AOS B,TABSMC
	CAIL B,77
	JRST ITAB2
ITAB5:	IFN TABCLK,[
	MOVE T,TABRTE
	MOVEI C,TABQBK
	SKIPL TABUSR
	JRST CLQREE
	JRST CLQRET
]	IFE TABCLK,[
	JRST OMXRET

ITAB6:	DATAI RBTCON,A	;FLUSH DATA
	JRST OMXRET

ITAB7:	CONO RBTCON,0
	JRST OMXRET
]
ITAB2:	MOVE B,TABSMC
	DPB B,[140600,,TABLST]
	SETZM TABSMC
	HRRZM A,TABLSY
	LDB B,[221400,,A]
	MOVEM B,TABLSX
	LDB B,[400300,,A]
	MOVEM B,TABLSZ
	EXCH A,TABLST
	JUMPE A,ITAB5	;JUST STARTING UP
	MOVE B,TABCC
	CAIL B,LTABBF
	JRST ITAB4	;FULL
	MOVEM A,@TABIP
	AOS TABCC
	AOS B,TABIP
	CAIL B,TABBFE
	MOVEI B,TABBUF
	MOVEM B,TABIP
	JRST ITAB5

ITAB4:	MOVSI B,(SETZ)	;SET DATA LOST
	IORM B,TABLST
	JRST ITAB5

]
IFN RBTCP,[

	;ROBOT CONSOLE READ SWITCHES
ARBTC:	XCTR XR,[MOVE A,(J)]
	CONO PI,TABOFF
	CONO RBTCON,RLTSWC_3+IFE TABCLK,TABCHN
	ROT A,36.*2
	DATAO RBTCON,A
	ROT A,36.*2
	DATAI RBTCON,A
	CONO PI,TABON
	XCTR XW,[MOVEM A,(J)]
	POPJ P,

;DATA FORM
;4.9 DATA LOST BEFORE THIS
;4.8-4.6 TAB "Z"
;4.5-4.4 USUSED
;4.3-3.1 TABLET X
;2.9-2.4 REPEAT COUNT
;2.4-1.1 TABLET Y

TABO:	PUSH P,[TABO1]
	JSP Q,STDOPN
	1,,TABUSR
	DTABUI,,DTABBI

TABO1:	POPJ P,		;OPEN LOST
	SKIPE TABUSE	;OPEN WON
	JRST POPJ1	;NOT FIRST OPEN
	LDB T,[250300,,C]
	AOS T
	MOVEM T,TABRTE	;TABLET RATE (IGNORE THIS MANY BETWEEN TAKES)
	LDB T,[300600,,C]
	MOVEM T,TABDTA	;DELTA FOR COORD TO BE DIFFERENT
	PUSHJ P,TABCLR
IFE TABCLK,	CONO RBTCON,RTABC_3+TABCHN
IFN TABCLK,[	PUSHJ P,CLQAD1	;START UP CLOCK LEVEL
	TABQBK
]	JRST POPJ1

BTABI:	XCTR XR,[MOVE J,(C)]	;INITIAL AOBJN PNT
	JSP Q,WRDBT
UTABI:	SKIPG TABCC	;TABLET .IOT
	JRST TABI1	;NO DATA AVAIL, SEE IF BEING ACCUMULATED
UTABI1:	MOVE A,@TABOP
	XCTR XW,[MOVEM A,(C)]
	AOS T,TABOP
	CAIL T,TABBFE
	MOVEI T,TABBUF
	MOVEM T,TABOP
	SOS TABCC
	POPJ P,

TABI1:	HRRZ T,(P)
	CAIN T,WRDBRT
	JRST TABI2
TABI3:	SKIPG TABCC
	PUSHJ P,UFLS
	JRST UTABI1

TABI2:	XCTR XRW,[CAMN J,(H)]
	JRST TABI3	;NO WDS TRANSFERRED
	SUB P,[1,,1]	;RETURN TO USER SOME HAVE BEEN TRANSFERRED
	POPJ P,

TABCLR:	CONO PI,TABOFF
	SETZM TABCC
	MOVEI T,TABBUF
	MOVEM T,TABIP
	MOVEM T,TABOP
	SETZM TABSMC
	SETZM TABLST
	CLEARM TABLSX
	CLEARM TABLSY
	CLEARM TABLSZ
IFE TABCLK,	SETZM TABRTC
	CONO PI,TABON
	POPJ P,
EBLK

TABBUF:	BLOCK LTABBF
TABBFE:
TABOP:	TABBUF	;OUTPUT PNTR (MP)
TABIP:	TABBUF	;INPUT PNTR (PI)
TABCC:	0	;ACTIVE WDS IN TAB BUFFER
TABSMC:	0	;COUNT OF TIMES "SAME" DATA RECEIVED FOR TAB
TABLST:	0	;LAST DATA
TABLSZ:	0	;Z OF LAST DATA
TABLSX:	0	;X
TABLSY:	0	;Y
TABDTA:	0	;DELTA FOR COORD TO BE DIFFERENT
TABRTE:	0	;TABLET RATE (TAKE EVERY N'TH ONE)
IFN TABCLK,[TABQBK:	0	;CLOCK QUEUE BLOCK
	-1
	JRST ITAB
]
IFE TABCLK,[
TABRTC:	0	;COUNT WITHIN TABRTE
]
]
;DATA AREA CONTINUES FROM PREV PAGE

;CORE LINK DEVICE
IFE TABP, EBLK	;ELSE CONTINUE PREV VAR AREA

CLVBEG:	NCLCH
CLSYN:	BLOCK NCLCH	;SYSTEM NAME ;0=>VARIABLES FREE
CLN1:	BLOCK NCLCH	;FN1
CLN2:	BLOCK NCLCH	;FN2
CLUSR:	REPEAT NCLCH,-1	;LH=WRITING USER ;RH=READING USER ;-1=>NOT OPEN THAT HALF
CLRAC:	BLOCK NCLCH	;4.9=LOCKED BY CORE ALLOCATOR
		;4.8=VERY SLOW CLOCK ROUTINE CONSIDERING FLUSHING THIS BUFFER
		;RH=UT BUFFER NUMBER (IOBFT ADR)

CLOSW:	-1	;USER LOCK TO STOP MORE THAN ONE PERSON FROM SIMULTANEOUSLY MODIFYING
	0			;THE CORE LINK VARIABLES
CLVEND==.-1
BBLK

;FORMAT OF CORE LINK 200 WORD BUFFER
;
CLBVSP==8
CLBCHS==100.
CLBEOF==<CLBCHS+4>/5
IFG CLBVSP+CLBCHS+CLBEOF-128.,[PRINTX /CLBXXX LOSSAGE
/]
;
;0:   CHARACTER COUNT
;1&2: READ AND WRITE CHARACTER OR WORD POINTERS
;3&4: READ AND WRITE EOF POINTERS
;CLBVSP TO CLBVSP+CLBCHS-1: CHARACTERS OR WORDS
;CLBVSP+CLBCHS UP: EOF BITS STORED AS SEVEN FIVE BIT BYTES PER WORD,
;		EACH BIT CORRESPONDING TO A CHARACTER POSITION.

CLAO:	SKIPA J,[2]	;CLA .OPEN (TO ANSWER A CLI INTERRUPT)
CLIO:	MOVNI J,1	;CLI .OPEN (INTERRUPTS USER SPECIFIED BY FILE NAME)
	JRST CLI2

CLUO:	TDZA J,J	;CLU .OPEN
CLOO:	MOVEI J,1	;CLO .OPEN
CLI2:	JUMPL C,CLFDEL	;JUMP IF AN .FDELE
	PUSHJ P,FLDRCK
	JRST CLO1	;NOT FILE DIRECTORY
	MOVEI J,2
	JRST LISTF7


CLFDEL:	HRRZ TT,40	;GET EFFECTIVE ADDRESS OF .FDELE
	XCTR XRW,[SKIPE 3(TT)]	;SKIP IF A DELETE
	JRST POPJ1	;IGNORE RENAMES
	MOVEI J,3
;DROPS IN
CLO1:	PUSHJ P,SWTL	;SEIZE SWITCH TO STOP VARIABLES FROM CHANGING UNDER YOU
	CLOSW
	LDB H,[220100,,C]	;DIRECTION BIT
	MOVE Q,USYSN1(U)	;PICK UP SNAME
	MOVSI I,-NCLCH
	CAIN J,2	;SKIP UNLESS CLA
	JRST CLO1A	;JUMP IF CLA .OPEN
CLOL:	CAMN Q,CLSYN(I)	;LOOK FOR SNAME, FN1, & FN2
	CAME A,CLN1(I)
	JRST CLOO1
	CAME B,CLN2(I)
	JRST CLOO1
	JUMPL J,OPNL13	;CLI LOSES IF FILE EXISTS
	CAIN J,3	;SKIP UNLESS DELETE
	JRST CLO1D	;FOUND FILE TO DELETE
CLO1A6:	LDB TT,CLOOT1(H)
	CAIE TT,-1
	JRST OPNL10	;ALREADY OPEN THIS DIRECTION
	HRRZ TT,CLRAC(I)
	LDB Q,[IOSA,,IOBFT(TT)]
	LSH Q,6
CLOX:	DPB U,CLOOT1(H)	;STORE USER INDEX
	MOVSI TT,200000
	ANDCAM TT,CLRAC(I)	;CLEAR VERY SLOW CLOCK BIT
	PUSHJ P,LSWPOP	;RELEASE SWITCH
	HRL A,I
	LDB C,[220300,,C]
	MOVEI TT,44	;WORD
	TRNN C,6
	MOVEI TT,7	;UNIT ASCII
	ADD Q,H		;OFFSET FOR DIRECTION
	DPB TT,[300600,,1(Q)]	;SET UP ITEM POINTER
	MOVEI TT,5	;WORD
	TRNN C,6
	MOVEI TT,1	;UNIT ASCII
	DPB TT,[300600,,3(Q)]	;SETUP EOF POINTER
	JSP Q,OPSLC7	;SET UP IOCHNM OF USER
	DCLUAI,,DCLUAO	;UNIT ASCII INPUT ;UNIT ASCII OUTPUT
	DCLBI,,DCLBO	;BLOCK INPUT ;BLOCK OUTPUT
	DCLUBI,,DCLUBO	;UNIT BINARY INPUT ;UNIT BINARY OUTPUT
	DCLBI,,DCLBO

CLOO1:	AOBJN I,CLOL	;LOOP FOR ALL SETS OF CORE LINK VARIABLES
	JUMPE J,OPNL4	;FILE NOT FOUND & CLU .OPEN
	CAIN J,3
	JRST OPNL4	;FNF FOR DELETE
	MOVSI I,-NCLCH
CLOO3:	SKIPN CLSYN(I)	;LOOK FOR FREE VARIABLES TO CREATE FILE
	JRST CLOO2
	AOBJN I,CLOO3
	JRST OPNL5	;GIVE DIREC FULL ERROR

CLOOT1:	2200,,CLUSR(I)	;READING
	222200,,CLUSR(I)	;WRITING

CLOO2:	JUMPL J,CLOO5	;JUMP IF CLI
CLOO2A:	MOVEM A,CLN1(I)	;SET UP VARIABLES
	MOVEM B,CLN2(I)
	MOVEI D,SCNCLO(I)	;SYS CHNL NO
	PUSHJ P,TCALL	;GET 200 WORD BUFFER
	JRST IUTCONS
	JRST CLOO4	;NO MEM AVAIL
	MOVEM Q,CLSYN(I)	;DONT SET UP SYS UNTIL MEM AVAIL
	HRRM A,CLRAC(I)
	LDB Q,[IOSA,,IOBFT(A)]	;SET UP BUFFER
	LSH Q,6
	SETZM (Q)	;CHAR COUNT
	MOVE TT,Q
	ADDI TT,CLBVSP	;SET UP BUF POINTERS
	MOVEM TT,1(Q)
	MOVEM TT,2(Q)
	HRLI TT,440000
	ADDI TT,CLBCHS	;SET UP EOF POINTERS
	MOVEM TT,3(Q)
	MOVEM TT,4(Q)
	JUMPGE J,CLOX
	MOVE U,USER	;GET HERE ON CLI
	MOVE T,2(Q)
	PUSH T,UNAME(U)	;STORE U&J NAMES OF INTERRUPTING PROCEDURE AS FIRST TWO WORD OF FILE
	PUSH T,JNAME(U)
	HRRM T,2(Q)
	MOVEI T,10.
	DPB T,[300600,,4(Q)]	;INTO SIZE FIELD OF EOF PNTR
	MOVEI T,0
	IDPB T,4(Q)	;CLEAR OUT APPROPRIATE EOF BITS
	MOVEI T,10.
	MOVEM T,(Q)	;SET "CHAR COUNT" TO REFLECT DATA ENTERED
	JRST CLOX

CLOO4:	SETZM CLSYN(I)	;RELEASE VARS
	JRST OPNL10	;DEVICE NOT AVAILABLE ERROR

CLOO5:	CONO PI,CLKOFF	;TURN OFF CLOCK TO STOP U&J NAMES FROM CHANGING
	MOVEI U,2*LUBLK
CLOO5A:	CAMN A,UNAME(U)	;LOOK FOR USER WHOSE NAMES MATCH THE SPECIFIED FILE NAMES
	CAME B,JNAME(U)
	JRST CLOO6
	MOVEI T,BCLI	;IF GET TO HERE, HAVE FOUND USER WITH RIGHT NAMES
	TDNE T,MSKST(U)	;SKIP IF HE HAS CLI INT DISABLED
	TDNE T,PIRQC(U)	;SKIP IF HE IS NOT CURRENTLY PROCESSING A CLI INT
	JRST OPNL11
	IORM T,PIRQC(U)	;GIVE USER INT
	CONO PI,CLKON
	JRST CLOO2A

CLOO6:	ADDI U,LUBLK	;GO TO NEXT USER SLOT
	CAMGE U,USRHI	;SKIP IF ALL EXAMINED
	JRST CLOO5A
	JRST OPNL11

CLO1D:	MOVE T,CLUSR(I)
	AOS (P)	;DELETES FOR EXISTANT FILE ALWAYS SKIP
	AOJN T,LSWPOP
	MOVE A,I
	PUSHJ P,CLIOTB	;NO TIMING ERROR SINCE CORE JOB WILL PCLSR USR ON
		;CORE LINK BEFORE MOVING BUFFER
	JRST CLO1D2

CLO1A:	MOVE A,UNAME(U)
	MOVE B,JNAME(U)
CLO1A2:	SKIPN CLSYN(I)
	JRST CLO1A4
	CAMN A,CLN1(I)
	CAME B,CLN2(I)
CLO1A4:	AOBJN I,CLO1A2
	JUMPGE I,OPNL4
	JRST CLO1A6

;CORE LINK .IOT SET UP ROUTINE

CLIOTB:	SKIPGE CLRAC(A)	;WAIT IF BUFFER LOCKED BY CORE ALLOCATOR
	PUSHJ P,UFLS	;(DO NOT CHANGE ABOVE TO "SKIPGE TT,CLRAC(A)")
	HRRZ TT,CLRAC(A)
	LDB Q,[IOSA,,IOBFT(TT)]	;GET POINTER TO BUFFER
	LSH Q,6
	POPJ P,


;CORE LINK .IOT ROUTINE FOR UNIT ASCII INPUT

CLUAI:	PUSHJ P,CLIOTB	;SETUP
CLUAI1:	SKIPN (Q)	;WAIT TILL CHAR COUNT NON-ZERO
	PUSHJ P,UFLS
	XCTR XRW,[MOVES (C)]	;MAKE SURE WILL WIN
	MOVE J,3(Q)
	ILDB I,J	;GET EOF BIT
	ILDB B,1(Q)	;GET CHARACTER
	XCTR XW,[MOVEM B,(C)]	;GIVE TO USER
	SOS (Q)	;DECREMENT BUF COUNT
CLFAXP:	LDB TT,[700,,1(Q)]	;FIX UP POINTERS ALSO ENTRY ON UNIT ASCII OUTPUT
	CAIN TT,CLBVSP+CLBCHS-1
	PUSHJ P,CLFAX2	;MAYBE TIME TO RING BUFFER
	LDB TT,[360600,,J]
	CAIN TT,1	;SIMULATE 5 BIT BYTES (USE 35. BIT / WORD)
	IBP J
	MOVEM J,3(Q)
	JUMPE I,CPOPJ
	LDB TT,[360600,,3(Q)]	;EOF
	SOJE TT,CLUAI2	;IGNORE EOFS EXCEPT ON WORD BOUNDARY
	CAIE TT,44-1
	JRST CLUAI1
CLUAI2:	XCTR XRW,[HRROS (C)]	;RETURN EOF TO USER
	POPJ P,

CLFAX2:	LDB TT,[370500,,1(Q)]	;PICK UP TOP 5 BITS OF BYTE POSITION
	JUMPN TT,CPOPJ	;NOT QUITE YET
CLFBX2:	MOVEI TT,CLBVSP	;J HAS NEW EOF PNTR
	DPB TT,[700,,1(Q)]	;RING CHAR POINTER
	MOVEM J,3(Q)
	MOVEI J,44
	DPB J,[360600,,1(Q)]
	MOVEI TT,CLBVSP+CLBCHS
	DPB TT,[700,,3(Q)]	;RING EOF POINTER
	DPB J,[360600,,3(Q)]
	MOVE J,3(Q)
	POPJ P,

;CORE LINK .IOT ROUTINE FOR UNIT ASCII OUTPUT

CLUAO:	PUSHJ P,CLIOTB	;SETUP
	MOVEI T,CLBCHS*5-11.
	CAMGE T,(Q)	;WAIT TILL THERE IS SPACE IN BUF
	PUSHJ P,UFLS
	MOVE J,4(Q)
	XCTR XR,[MOVE B,(C)]	;GET CHAR FROM USER
	MOVEI TT,0
	IDPB TT,J	;INDICATE NOT AN EOF
	IDPB B,2(Q)	;STORE IN BUF
	MOVEI TT,1	;GET MASK FOR LOW ORDER BIT
	ANDCAM TT,@2(Q)	;FLUSH IN CURRENT WORD
CLCWU2:	AOS (Q)	;INCREMENT BUF COUNT
	MOVEI I,0	;FAKE OUT EOF TEST
	AOJA Q,CLFAXP	;FAKE OUT CLFAXP AND FIX UP POINTERS


;CORE LINK .IOT ROUTINE FOR UNIT BINARY INPUT

CLUBI:	MOVEI E,0
CLBIN:	PUSHJ P,CLIOTB	;SETUP
	MOVEI T,5
	CAMLE T,(Q)	;WAIT TILL A WORD IS AVAILABLE
	PUSHJ P,UFLS
	XCTR XRW,[MOVES (C)]	;MAKE SURE WILL WIN
	MOVE J,3(Q)
	ILDB TT,J	;GET EOF BITS
	JUMPN TT,CLUBIE	;JUMP ON EOF
	ILDB B,1(Q)	;GET WORD
	XCTR XW,[MOVEM B,(C)]	;GIVE TO USER
CLCRB2:	MOVNI T,5
	ADDM T,(Q)	;DECREMENT COUNT
CLFBXP:	LDB TT,[700,,1(Q)]	;FIX UP POINTERS
	CAIN TT,CLBVSP+CLBCHS-1
	JRST CLFBX2	;TIME TO RING BUFFER
	MOVEM J,3(Q)
	POPJ P,

CLUBIE:	TROE TT,20	;SKIP IF EOF NOT ON FIRST CHAR OF WORD
	JRST CLUBIF
	DPB TT,J	;SET EOF ON FIRST CHAR
	MOVE J,1(Q)
	ILDB B,J	;PICK UP WORD WITH EOF IN MIDDLE
	XCTR XW,[MOVEM B,(C)]	;GIVE TO USER
	POPJ P,

CLUBIF:	IBP 1(Q)
	PUSHJ P,CLCRB2	;SPACE PAST EOF WD
	JUMPE E,ACLOSE	;UNIT BINARY INPUT "PHYSICAL" END OF FILE
	SUB P,[1,,1]	;BLOCK MODE, BACK UP PDL FOR PUSHJ IN CLBI
	CAMN H,E	;SKIP IF ANY WORD(S) TRANSFERRED
	JRST ACLOSE	;NONE
	JRST CLBI3

;CORE LINK .IOT ROUTINE FOR UNIT BINARY OUTPUT

CLUBO:	PUSHJ P,CLIOTB	;SETUP
	MOVEI T,CLBCHS*5-11.
	CAMGE T,(Q)	;WAIT TILL THERE IS SPACE FOR A WORD
	PUSHJ P,UFLS
	MOVE J,4(Q)
	XCTR XR,[MOVE B,(C)]	;GET WORD FROM USER
	MOVEI TT,0
	IDPB TT,J	;INDICATE NOT AN EOF
	IDPB B,2(Q)	;STORE IN BUF
CLCWB2:	MOVEI TT,5
	ADDM TT,(Q)	;INCREMENT COUNT
	AOJA Q,CLFBXP	;FAKE OUT CLFBXP AND FIX UP POINTERS


;CORE LINK .IOT ROUTINE FOR BLOCK INPUT AND OUTPUT

CLBO:	MOVEI D,CLUBO	;OUTPUT
	JRST .+2
CLBI:	MOVEI D,CLBIN	;INPUT
	MOVE I,C	;SAVE A POINTER TO USERS BLKO POINTER
	XCTR XRW,[SKIPL H,(I)]	;PICKUP BLKO POINTER
	POPJ P,
	SKIPA E,H	;SECOND COPY, ALSO FLAG TO CLBIN
CLBI2:	XCTR XW,[MOVEM E,(I)]	;TO INFORM USER & IN CASE YOU ARE PCLSR'ED
	HRRZ C,E
	PUSHJ P,(D)	;TRANSFER ONE WORD
	AOBJN E,CLBI2	;TRY FOR NEXT
CLBI3:	XCTR XW,[MOVEM E,(I)]	;COUNT EXHAUSTED OR EOF
	POPJ P,

;CORE LINK .CLOSE ROUTINE FOR BINARY OR BLOCK OUTPUT

CLCLWB:	PUSHJ P,CLCWC	;STORE EOF BITS FOR WORD
	JRST CLCW1	;NO ROOM SO LAST MUST HAVE BEEN EOF HACK SO FLUSH
	PUSHJ P,SWTL	;WAIT FOR SWITCH TO MODIFY VARIABLES
	CLOSW
	IBP 2(Q)	;KEEP WORD POINTER IN STEP
	PUSHJ P,CLCWB2	;FIX UP COUNT AND POINTERS
CLCWU6:	MOVNI B,1
	DPB B,[222200,,CLUSR(A)]	;OBLITERATE USER INDEX
	JRST LSWPOP	;RELEASE SWITCH


CLCW1:	PUSHJ P,SWTL
	CLOSW
	JRST CLCWU6

;CORE LINK .CLOSE ROUTINE FOR UNIT ASCII OUTPUT

CLCLWU:	PUSHJ P,CLCWC	;STORE EOF BIT FOR CHAR
	JRST CLCW1
	LDB TT,[360600,,2(Q)]
	CAIN TT,8
	JRST CLCWU4	;JUMP ON END OF WORD NEXT
	MOVEI TT,EOFCH
	IDPB TT,2(Q)	;STORE AN EOF CHAR
	PUSHJ P,CLCWU2	;FIX UP COUNT AND POINTERS
	JRST CLCLWU

CLCWU4:	PUSHJ P,SWTL	;SEIZE SWITCH TO MODIFY VARIABLES
	CLOSW
	MOVEI TT,EOFCH	;(CODE MUST BE DUPLICATED DUE TO TIMING ERR IF PCLSR'ED OUT OF SWAIT)
	IDPB TT,2(Q)	;STORE AN EOF CHAR
	PUSHJ P,CLCWU2	;FIX UP COUNT AND POINTERS
	JRST CLCWU6


;COMMON SUBROUTINE FOR CORE LINK OUTPUT .CLOSE ROUTINES

CLCWC:	PUSHJ P,CLIOTB	;SETUP
	MOVEI T,CLBCHS*5-5.
	CAMGE T,(Q)	;WAIT FOR THERE TO BE ROOM
	POPJ P,
	MOVE J,4(Q)
	MOVNI TT,1
	IDPB TT,J	;SET EOF BIT(S)
	JRST POPJ1

;CORE LINK .CLOSE ROUTINE FOR INPUT

CLCLRB:
CLCLRU:	PUSHJ P,CLIOTB
	PUSHJ P,SWTL	;SEIZE SWITCH TO MODIFY VARIABLES
	CLOSW
			;(CODE MUST BE DUPLICATED DUE TO TIMING ERROR IF PCLSR'ED OUT OF SWAIT)
	HLLOS B,CLUSR(A)	;OBLITERATE USER INDEX, GET ENTIRE WORD IN B
	AOJN B,LSWPOP	;JUMP IF CORE LINK OPEN FOR WRITING
	SKIPE (Q)
	JRST LSWPOP	;JUMP IF CORE LINK NOT EMPTY
CLO1D2:	SETZM CLSYN(A)	;FREE VARIABLES
	HRRZ A,CLRAC(A)	;CORE LINK NO LONGER IN USE
	PUSHJ P,BRTN	;RETURN BUFFER TO FREE STATE
	JRST LSWPOP



;STANDARD DEVICE OPEN

STDOP1:	MOVEI R,R	;ENTRY TO NOT CLOBBER IOCHNM
STDOPN:	HLRZ A,(Q)	;LH MASK ON 4.9-3.2 OF LH OPEN WRD
	AND D,A	;RH POINTER TO ..USR,..USE PAIR
	ROT D,-1	;FOLLOWING WORDS CONTAIN LIST FOR ALL MASKED STATES
	ADDI D,(Q)	;LH MSKED STATE =0, RH =1, IOTTB ENTRY NUMBERS
	HRRZ A,1(D)
	SKIPL D
	HLRZ A,1(D)
	JUMPE A,OPNL12	;MODE NOT AVAIL
	HRRZ E,(Q)
	CONO PI,CLKOFF
	CAME U,(E)
	SKIPGE 1(E)
	AOSA 1(E)
	JRST OPNL10	;DEVICE NOT AVAIL
	MOVEM U,(E)
	HLL A,C
	JRST OPNSLT

OPSLD1:	ANDI D,1	;ENTRY TO USE BOTTOM BIT OF AC D
OPSLD3:	ANDI D,3	;ENTRY TO USE BOTTOM TWO BIT OF AC D
	MOVE C,D
OPSLC3:	ANDI C,3	;ENTRY TO USE BOTTOM TWO BITS OF AC C
OPSLC7:	ANDI C,7	;ENTRY TO USE BOTTOM THREE BITS OF AC C
	ROT C,-1
	ADDI C,(Q)
	HRR A,(C)
	SKIPL C
	HLR A,(C)
OPNSLT:	MOVEM A,(R)	;SET USERS IOCHNM
	JRST CLKOJ1

;BLOCK OUTPUT TO CHARACTER DEVICE 
;ADR OF CHR ROUTINE IN E 3.1 OF E SAYS PROCESS ONLY ONE WORD

NBTOCH:	XCTR XRW,[MOVES D,(C)]
	LDB TT,[410300,,D]	;USE HIGH 3 BITS OF USER PNTR AS CHR CNT
	CAIGE TT,3
	POPJ P,	;USER TRYING TO XFER >32K FLUSH
	SKIPA TT,BTOCHT-3(TT)
NBTO1:	XCTR XW,[MOVEM D,(C)]
	XCTR XR,[MOVE W,(D)]
	ILDB A,TT
	PUSHJ P,(E)	;MUST NOT CLOBBER C, D, E, OR TT
	ADD D,[700000,,]
	TLNE D,500000
	JRST NBTO1	;GO TO NEXT CHR
	MOVE TT,BTOCHT+4
	ADD D,[500001,,1]	;INCR TO NEXT WORD
	JUMPL D,NBTO1
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

BTOCHT:	REPEAT 5,<44-<4-.RPCNT>*7>_14+700,,W

INBTCH:	HRRZS E	;CLEAR GARBAGE IN LH SO SIGN AVAIL FOR EOF FLG
;4.8 => JUST RETURN WITHOUT ERROR IF AT BEGINNING OF WORD,
;OTHERWISE IGNORE BIT.
	XCTR XRW,[MOVES D,(C)]
	LDB TT,[410300,,D]
	CAIGE TT,3
	POPJ P,
	SKIPA TT,BTOCHT-3(TT)
INBTO1:	XCTR XW,[MOVEM D,(C)]
	XCTR XRW,[MOVES (D)]
	JUMPL E,INBTO2
	PUSH P,C
	PUSH P,D
	PUSH P,TT
	PUSH P,R
	MOVE C,[SETZ I]
	HLRZ A,(R)
	PUSHJ P,(E)	;RETN CHR IN I
	POP P,R
	POP P,TT
	POP P,D
	POP P,C
	LDB W,[410300,,D]
	CAIN W,7	;SKIP IF NOT AT 1ST CHAR.
	TLNN E,200000
	JRST INBTO3
	POPJ P,

INBTO3:	XCTR XR,[MOVE W,(D)]
	IDPB I,TT
	XCTR XW,[MOVEM W,(D)]
	ADD D,[700000,,]
	TLNE D,500000
	JRST INBTO1
	MOVE TT,BTOCHT+4
	ADD D,[500001,,1]	;INCR TO NEXT WD
	SKIPL E
	JUMPL D,INBTO1
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

INBTO2:	MOVEI I,EOFCH
	JRST INBTO3

;BLOCK IO TO WORD DEVICE

WRDBT:	MOVE H,C
	XCTR XR,[MOVE C,(H)]
	JUMPGE C,CPOPJ
	JRST WRDBT3

WRDBT2:	XCTR XW,[MOVEM C,(H)]
	PUSHJ P,OPBRK
WRDBT3:	PUSHJ P,(Q)	;MUST NOT CLOBBER Q OR H (PTR ROUTINES DO POPJ2 SOMETIMES)
WRDBRT:	XCTR XR,[MOVE C,(H)]	;WRDBRT CHECKED FOR ON PDL BY TVC ROUTINES
	AOBJN C,WRDBT2
	XCTR XW,[MOVEM C,(H)]
	POPJ P,

;PAPER TAPE PUNCH ROUTINES

PTPO:	JSP Q,STDOPN
	7,,PTPUSR
	PTPA,,PTPB
	PTPWA,,PTPWB
	PTPI,,0
	PTPI,,0

BPIPUN:	JSP E,NBTOCH
	CAIN A,EOFCH
	POPJ P,
	JRST APIPU2

APIPUN:	XCTR XR,[MOVE A,(C)]
	ANDI A,177
APIPU2:	CAIN A,14
	JRST PUNFF
	TROA A,200
PIPUN:	XCTR XR,[MOVE A,(C)]
PIPUN3:	SKIPG PUNCC
	JRST PUNW1
PIPUN2:	IDPB A,PUNIP
	HRRZ A,PUNIP
	CAIN A,PUNBE-1
	MOVEI A,PUNBO
	HRRM A,PUNIP
	SOS PUNCC
PUNST:	SKIPGE PUNNT
	POPJ P,	;PUNCH OUT OF TAPE
	CONSO PTP,7
	CONO PTP,10+PCHCHN
	POPJ P,

	PUSHJ P,PUNW2
PUNW1:	PUSHJ P,UFLS
	JRST PIPUN2

PUNW2:	SKIPG T,PUNCC
	POPJ P,
	CAIL T,PUNSIZ*2
	JRST POPJ1
	JRST POPJ3

PUNFF:	MOVEI T,55
	CAMLE T,PUNCC
	PUSHJ P,UFLS
	MOVSI B,-4
	PUSHJ P,PUNFF2
	MOVEI A,214
	PUSHJ P,PIPUN2
	MOVSI B,-50
PUNFF2:	MOVEI A,0
	PUSHJ P,PIPUN2
	AOBJN B,PUNFF2
	POPJ P,

WBPIPN:	JSP Q,WRDBT
WAPIPN:	MOVEI T,6
	CAMLE T,PUNCC
	PUSHJ P,UFLS
	XCTR XR,[MOVE B,(C)]
	MOVSI E,-6
WPIPN2:	MOVEI A,2
	LSHC A,6
	PUSHJ P,PIPUN2
	AOBJN E,WPIPN2
	POPJ P,

PBRK1:	MOVEI A,PUNSIZ*4-4
	CAMG A,PUNCC
	JRST PUNSTP
	CONSZ PTP,100	;CHECK NO TAPE FLAG
	JRST PBRK2	;PUNCH OUT OF TAPE
	ILDB A,PUNOP
	DATAO PTP,A
	HRRZ A,PUNOP
	CAIN A,PUNBE-1
	MOVEI A,PUNBO
	HRRM A,PUNOP
	AOSA PUNCC
PUNSTP:	CONO PTP,0
	JRST LPBKRT

PBRK2:	SETOM PUNNT	;PTP OUT OF TAPE
	JRST PUNSTP

;PTP SLOW CLOCK ROUTINE
PTPCHK:	SKIPGE PUNNT
	CONSZ PTP,100
	POPJ P,
	HRRZM P,PUNNT
	JRST PUNST	;PTP HAS TAPE NOW

EBLK

PUNNT:	105	;-1 => PTP OUT OF TAPE
PUNCC:	PUNSIZ*4-4
PUNIP:	(1000)PUNBO-1
PUNOP:	(1000)PUNBO-1
PUNBO:	BLOCK PUNSIZ
PUNBE:

BBLK

PUNCLR:	MOVEI A,PUNSIZ*4-4
	MOVE B,PUNIP
	MOVEM A,PUNCC
	MOVEM B,PUNOP
	POPJ P,

AFEED:	HRRZ A,(R)
	CAIL A,PTPI	;LOWEST PTP DEV #
	CAILE A,PTPWB	;HIGHEST PTP DEV #
	POPJ P,	;PTP NOT OPEN ON CHNL
	MOVEI A,0
	PUSHJ P,PIPUN3
	JRST POPJ1

		;PAPER TAPE READER ROUTINES

	PTRCHX==10	;NUMBER OF CHARACTERS IGNORED AT END OF TAPE

PTRO:	PUSH P,[PTRO1]	;SO STDOPN WILL RETURN
	JSP Q,STDOPN
	7,,PTRUSR
	REDUAI,,REDBAI	;ASCII MODE
	REDUII,,REDBII	;IMAGE MODE
	REDUTI,,0	;ALL 8 HOLES MODE
	REDUTI,,0	;" " " "

		;RETURN FROM STDOPN
PTRO1:	POPJ P,		;OPEN LOST
	AOS (P)		;OPEN WON, MAKE RETURN SKIP
	SKIPE PTRUSE
	POPJ P,		;READER ALREADY OPEN, DON'T RESET
			;READER NOT ALREADY OPEN, SO
		;RESET PTR POINTERS AND START UP READER
	CONO PI,PTROFF	;INHIBIT INTERRUPTS
	MOVEI T,20	;BUSY FLAG
	PUSHJ P,PTRST	;START UP READER IF NOT ALREADY RUNNING
		;RESET PTR BUFFER POINTERS
PTRZAP:	MOVE A,[041000,,PTRBUF-1]	;BUFFER BYTE POINTER
	MOVEM A,PTRIP	;BUFFER INPUT (INTERRUPT) POINTER
	MOVEM A,PTROP	;BUFFER OUTPUT (IOT) POINTER
	MOVEI A,PTRCHX	;REINITIALIZE CHARACTER COUNT
	MOVNM A,PTRCC	;" " "
	CONO PI,PTRON	;RE-ENABLE INTERRUPTS
	JRST PTRSIW	;RESET STATUS OF IMAGE WORD AND RETURN

		;CLOSE CHANNEL ON WHICH PTR OPEN

PTRCLS:	CONO PI,PTROFF	;INHIBIT INTERRUPTS
	SOSL PTRUSE	;DECREMENT USE COUNTER
	JRST PTRONJ	;PTR OPENED ON MORE CHANNELS
	SETOM PTRUSR	;NO MORE OPENS ON READER, INDICATE NO USER
	SETOM PTRDIE	;EVENTUALLY TURN OFF READER
	JRST PTRZAP	;RESET BUFFER STATUS

PTRRS:	CONO PI,PTROFF	;PTR .RESET ROUTINE
	JRST PTRZAP

		;UNIT ASCII INPUT

PTRUAI:	PUSHJ P,PTRCHA	;GET ASCII CHARACTER IN A
PUTACJ:	XCTR XW,[MOVEM A,(C)]	;GIVE TO USER
	POPJ P,

		;BLOCK ASCII INPUT

PTRBAI:	JSP E,INBTCH	;DO IT A CHARACTER AT A TIME
	PUSHJ P,PTRCHA	;GET ASCII CHARACTER IN A
	MOVE I,A
	JUMPGE A,CPOPJ	;RETURN UNLESS END-OF-FILE
	TLO E,(SETZ)		;EOF, MAKE THIS BE LAST WORD
	POPJ P,

		;GET AN ASCII CHARACTER IN A

PTRCHA:	PUSHJ P,PTRCH	;GET CHARACTER
	TRZ A,200	;CLEAR 200 BIT
	JUMPE A,PTRCHA	;IF RESULT ZERO THEN DON'T CALL IT ASCII
	CAIN A,177	;IF RUBOUT,
	JRST PTRCHA	;THEN IGNORE IT
	POPJ P,		;ASCII, USE IT

		;UNIT IMAGE INPUT
		;END-OF-FILE GIVES SIXBIT /######/

PTRUII:	SKIPG PTRICC
	JRST PTRUI2	;ALREADY TRIED TO GIVE WORD TO USER, BUT HIS PAGE WAS SWAPPED OUT LAST TIME
	PUSHJ P,PTRCH	;GET CHARACTER
	TRNN A,200	;CALL IT BINARY IF 200 BIT SET,
	JUMPGE A,PTRUII	;OR IF END-OF-FILE
	IDPB A,PTRIBP	;DEPOSIT IN CURRENT WORD
	SOSLE PTRICC	;IF WORD NOT FULL,
	JRST PTRUII	;THEN GO BACK FOR MORE
PTRUI2:	MOVE B,PTRIW	;WORD FULL,
	XCTR XW,[MOVEM B,(C)]	;GIVE TO USER
PTRSIW:	MOVEI B,6	;NOW REINITIALIZE POINTERS TO WORD
	MOVEM B,PTRICC	;CHARACTER COUNT OF WORD
	MOVE B,[440600,,PTRIW]	;POINTER TO WORD
	MOVEM B,PTRIBP
	POPJ P,

		;BLOCK IMAGE INPUT

PTRBII:	JSP Q,WRDBT	;CALL SYSTEM ROUTINE FOR IT
	PUSHJ P,PTRUII	;PROCESS WORD
	JUMPGE A,CPOPJ	;RETURN ON NO END-OF-FILE
	AOBJN C,POPJ2	;END-OF-FILE, PROCESS MANUALLY
	JRST POPJ2	;POINTER RAN OUT

		;ALL 8 HOLES INPUT

PTRUTI:	PUSHJ P,PTRCH	;GET CHARACTER IN A
	JRST PUTACJ	;GIVE TO USER AND RETURN

		;GET A CHARACTER IN A OR RETURN -1,,EOFCH IF NONE AVAILABLE

PTRCH:	MOVEI T,20	;BUSY FLAG
	PUSHJ P,PTRCHW	;WAIT FOR A CHARACTER
	PUSHJ P,UFLS
	SOSGE I,PTRCC	;DECREMENT CHARACTER COUNT
	JRST PTRCH1	;BUFFER EMPTY
	MOVEI T,10	;DONE FLAG
	CAIGE I,REDSIZ-PTRCHX	;IF BUFFER LESS THAN 1/4-FULL,
	PUSHJ P,PTRST	;THEN MAKE SURE READER RUNNING
	ILDB A,PTROP	;GET CHARACTER
	HRRZ B,PTROP	;RING THE BUFFER
	CAIL B,PTRBUF+REDSIZ-1
	MOVEI B,PTRBUF
	HRRM B,PTROP
	POPJ P,

		;END-OF-FILE ENCOUNTERED DURING PTRCH

PTRCH1:	AOS PTRCC	;RESTORE CHARACTER COUNT TO ITS ORIGINAL STATE
	HRROI A,EOFCH	;GENERATE -1,,EOFCH
	POPJ P,

		;SKIP IF CHARACTER IN BUFFER OR END-OF-TAPE

PTRCHW:	SKIPG PTRCC	;IF CHARACTER IN BUFFER,
	CONSO PTR,400	;OR POWER IS OFF,
	JRST POPJ1	;THEN EXIT SKIPPING
			;OTHERWISE,
		;MAKE SURE READER RUNNING

PTRST:	CONSZ PTR,7
	CONSO PTR,30	;IF RUNNING,
	JRST .+2
	POPJ P,		;THEN THAT'S ALL
	CONO PTR,PTRCHN(T)	;NOT RUNNING, RESTART WITH SELECTED FLAG
	SETOM PTRDIE	;LET SLOW CLOCK FIGURE OUT IF THERE'S TAPE
	POPJ P,

		;PTR INTERRUPT ROUTINE

PTRBRK:	AOSN PTRSTP	;IF READER SHOULD BE STOPPED THIS BREAK,
	JRST PTRFUL	;THEN STOP IT (BUFFER FULL)
	DATAI PTR,A	;GET CHARACTER
	SETOM PTRDIE	;TELL SLOW CLOCK THAT BREAK HAS HAPPENED
	IDPB A,PTRIP	;PUT IN BUFFER
	HRRZ A,PTRIP	;RING THE BUFFER
	CAIN A,PTRBUF+REDSIZ-1
	MOVEI A,PTRBUF
	HRRM A,PTRIP
	AOS A,PTRCC	;TOTAL CHARACTER COUNT-PTRCHX
	CAIGE A,REDSIZ*4-10-PTRCHX
	JRST LPBKRT
	SETOM PTRSTP	;STOP READER AT NEXT BREAK
	JRST LPBKRT

PTRFUL:	CONO PTR,PTRCHN	;BUFFER FULL, STOP READER
	MOVEI A,1	;TELL SLOW CLOCK...
	MOVEM A,PTRDIE	;NOT TO TURN IT OFF
	JRST LPBKRT

		;SLOW CLOCK ROUTINE
		;CHECKS READER EVERY HALF-SECOND

PTRCHK:	AOS A,PTRDIE
	CAIN A,1	;IF UNINTENTIONALLY STOPPED FOR OVER HALF-SECOND
	CONO PTR,400	;THEN TURN THE READER OFF
	POPJ P,

EBLK
		;PTR VARIABLES

PTRDIE:	-264		;END-OF-TAPE DETECTION
PTRSTP:	0		;-1 => STOP READER AT NEXT BREAK (SET DURING BREAK WHEN BUFFER FULL)
PTRIP:	041000,,PTRBUF-1	;BUFFER INPUT (INTERRUPT) POINTER
PTROP:	041000,,PTRBUF-1	;BUFFER OUTPUT (IOT) POINTER
PTRBUF:	BLOCK REDSIZ	;READER BUFFER
PTRCC:	-PTRCHX		;NUMBER OF CHARACTERS IN BUFFER -PTRCHX

PTRIW:	0		;CURRENT WORD FOR IMAGE MODE
PTRIBP:	440600,,PTRIW	;POINTER TO CURRENT WORD
PTRICC:	0		;CHARACTER COUNT TO CURRENT IMAGE MODE WORD

BBLK
IFN IMXP,[

;INPUT MULTIPLEXOR ROUTINES

IMPXO:	CONI MPX,T
	JUMPE T,OPNL25
	TRNN D,2
	JRST IMPXO2	;READ AT MN PRGM
	SKIPGE IMPXF	;IMAGE (READ AT PI)
	SETOM MPXWF
	PUSHJ P,IMXON
IMPXO2:	AOS IMXNTO
	HLL A,C
	JSP Q,OPSLD3
	IMXDN,,BIMXDN
	IMPXDN,,BIMPXD

IMXON:	AOSGE IMPXF
	JRST 4,.	;SHOULD NOT HAVE BEEN LESS THAN -1
	PUSHJ P,CLQAD1	;START CLOCK LEVEL
	MPXBLK
	POPJ P,

BIMPXS:	JSP Q,WRDBT
IMPXS:	SKIPGE MPXWF
	PUSHJ P,UFLS
	XCTR XR,[MOVE A,(C)]
	ANDI A,377
	CAILE A,LCHN
	JRST IMPXS1
AIMXW5:	IDIVI A,3
	LDB A,IMPXT(B)
	XCTR XW,[MOVEM A,(C)]
	POPJ P,

IMPXCL:	TRNE A,4	;SKIP ON WAS READING AT MP
IMXCL1:	SOS IMPXF	;WAS READING AT PI
	SOSGE IMXNTO
	DATAO DSDEVN,[MPX]
	POPJ P,

IMPXRS:	SETOM MPXWF
	POPJ P,

IMPXT:	301400,,MPXBUF(A)
	141400,,MPXBUF(A)
	1400,,MPXBUF(A)

BIMXS1:	JSP Q,WRDBT
IMPXS1:	XCTR XR,[MOVE A,(C)]
	TDZE A,[-400]
	JRST IOCER4
AIMXW4:	MOVE T,MPXWF
	CAILE A,LCHN
	MOVNI T,2	;CHNL NOT READ IN BY PI HACK
AIMXW2:	SKIPL IMXSW
	PUSHJ P,UFLS
	CAME T,MPXWF
	AOJGE T,AIMXW3	;PI FROB HAS CYCLED (MAYBE)
	AOSE IMXSW
	JRST AIMXW2	;READING IMX AT PI
	DATAO MPX,A	;SELECT CHNL
	CONO MPX,0	;START CONVERSION
	MOVEI B,62
	CONSO MPX,10
	SOJG B,.-1
	JUMPE B,IMPXFE
	XCTR XRW,[DATAI MPX,(C)]
IMX1:	SETOM IMXSW
	POPJ P,

AIMXW3:	SKIPGE MPXWF
	JRST AIMXW4	;IT WAS JUST SETOMMED
	JRST AIMXW5	;HAS BEEN READ IN BY PI HACK SO GOBBLE DATA

IMPXFE:	XCTR XRW,[SETOM (C)]
	JRST IMX1

IMPXSR:	AOSE IMXSW
	JRST MPXRT1	;USING IMX AT MN PRGM LVL
	MOVE T,[<-LCHN>/3-1,,MPXBUF-1]
	MOVEM T,MPXPTR	;SET UP BLKI POINTER
	MOVE T,[BLKI MPX,MPXPTR]
	MOVEM T,IMXLC	;SET UP DC INTERUPT LOCN
	MOVE T,[JSR MPXCYC]
	MOVEM T,IMXLC+1	;SET UP DC INT LOC+1
	DATAO MPX,[0]	;READ STARTING WITH CHNL 0
	CONO MPX,140+DCCHN
	MOVEI T,5	;12TH SEC
	SKIPN ARMF
	SKIPL POTCON
	MOVEI T,2	;1/30 SEC, HAIRY POTS
	JRST .+2
MPXRT1:	MOVEI T,1	;LOST RETRY IN 1/60
	MOVEI C,MPXBLK
	SKIPL IMPXF
	JRST CLQREE	;RE-ENTER RQ
	JRST CLQRET	;RETURN

EBLK

OMXNTO:	-1
IMXNTO:	-1
IMPXF:	-1	;-1 IF MPX NOT RUNNING
MPXWF:	0
MPXBLK:	0	;CLOCK QUEUE BLOCK
	-1
	JRST IMPXSR
MPXPTR:	0
IMXST:	0
IMXSW:	-1	;-1 IF IMX AVAIL
IMXTBB:	LCHN
MPXBUF:	BLOCK <LCHN>/3+1
IMXTBE==.-1

IMXACS:	BLOCK 20
MPXCYC:	0

BBLK

	CONO MPX,0
	SETOM IMXSW
	AOS MPXWF
	MOVEM T,IMXST
	MOVE T,[JSR MPXCYC]
	MOVEM T,IMXLC
	MOVE T,IMXST
;	SKIPGE POTCON
;	SKIPE ARMF
;	JRST MPXCYG
	JRST 12,@MPXCYC

MPXCYG:	MOVEM 17,IMXACS+17
	MOVEI 17,IMXACS
	BLT 17,IMXACS+16
	SKIPE ARMF
	JRST SERVO
ARMSVR:	SKIPL POTCON
	JRST UPOTS
UPOTRT:	MOVSI 17,IMXACS
	BLT 17,17
	JRST 12,@MPXCYC
]
IFN OMXP,[

;OUTPUT MULTIPLEXOR ROUTINES

OMPXO:	CONI OMPX,T
	JUMPE T,OPNL25
	AOS OMXNTO
	HLL A,C
	JSP Q,OPSLD3
	OMPXDN,,BOMPXDN
	OMXDN,,BOMXDN

BOMXDS:
BOMPXS:	JSP Q,WRDBT
OMXDS:
OMPXS:	XCTR XRW,[DATAO OMPX,(C)]	;ZAP CHNL
	POPJ P,

OMPXCL:	SOSGE OMXNTO
	DATAO DSDEVN,[OMPX]
	POPJ P,

EBLK
OMXACS:	BLOCK 20

OMPXBK:	0
BBLK
	MOVEM 17,OMXACS+17
	MOVEI 17,OMXACS
	BLT 17,OMXACS+16
IFN VIDP,[
	CONSZ NVDX,700000
	CONSO NVDX,1000
	JRST .+2
	JRST NVDBRK
]
IFN ARMP,[
	CONSZ TIPDEV,10
	JRST TIPBRK
]
IFN TABP,[
	CONSZ RBTCON,7
	CONSO RBTCON,10
	JRST .+2
	JRST ITAB
]
;	MOVEI J,OMPCHN
;	JSP E,SPUR	;SPURIOUS INT
OMXRET:	MOVSI 17,OMXACS
	BLT 17,17
	JRST 12,@OMPXBK
]
IFN CODP,[
;	CODITC==CODBFL*5-1	;WHEN TO TRY TO INTERRUPT

CLKCOD:	SETOM TT	;USED AS A FLAG
	MOVE B,CODWD
	LSH B,-1
CLKCC3:	CAIN B,1
	JRST CLKCC1
	LDB A,[100,,B]
	EXCH A,LSTBIT
	CAME A,LSTBIT
	DATAO 70,LSTBIT
	MOVEM B,CODWD
	MOVE T,CODSPD
	MOVEI C,CODTIM
	JRST CLQTTR	;RE-ENTER OR NOT DEPENDING ON TT

CLKCC1:	MOVE A,CODCC
	CAIL A,CODBFL*5
	JRST CLKCC5
CLKCC8:	AOS CODCC
	ILDB B,CODPTR
	MOVE A,CODPTR
	CAMN A,[10700,,CODBUF+CODBFL-1]
	HRRI A,CODBUF-1
	HRRM A,CODPTR
	CAIL B,140
	JRST CLKCC2
	CAIGE B,40
	JRST CLKCC1
	MOVE B,CODTBL-40(B)
	JRST CLKCC3
CLKCC6:	MOVE B,CDRUB
	JRST CLKCC3
CLKCC2:	CAIN B,177
	JRST CLKCC6
	SUBI B,137
	MOVEM B,CODSPD
	JRST CLKCC1

CLKCC5:
;	CAIN A,CODITC
;	JRST CLKCC7
	MOVEI B,2
	SETZM TT	;INDICATE IDLE
	JRST CLKCC3

;CLKCC7:	MOVE A,CODUSR	;GET INDEX OF USER
;	MOVE B,CODITB	;GET CHANNELS OPEN MASK
;	AND B,MSKST2(A)	;FIND OUT WHAT CODE CHANNELS ENABLED,
;	MOVNM B,CODITD
;	AND B,CODITD
;	IORM B,IFPIR(A)	;AND REQUEST INTERRUPT ON LOWEST NUMBERED ONE
;	JRST CLKCC8	;SEND REMAINING CHARACTER(S) IN BUFFER

	;RETURN HERE FROM STDOPN
CODO1:	POPJ P,		;NON-SKIP RETURN
	AOS (P)		;DO NOT CHANGE TO JRST POPJ1 AT END
	MOVEI I,1	;INDICATE "IOPOP"

	;CODE DEVICE IOPUSH AND IOPOP ROUTINE (SETS INTERRUPT MASK)

CODIOP:	SUBI R,IOCHNM(U)	;GET "AC FIELD" (ROUTINES THAT NEED IT RESTORE R)
	MOVE A,CHNBIT(R)	;SET UP INTERRUPT BIT
	XCT CDPTBL(I)	;IORM OR ANDCAM TO CODITB
	POPJ P,

CDPTBL:	ANDCAM A,CODITB	;IOPUSH AND CLOSE
	IORM A,CODITB	;IOPOP AND OPEN

	;COD CLOSE ROUTINE
CODCLS:	MOVEI I,0	;TO SIMULATE IOPUSH
	PUSHJ P,CODIOP	;CLEAR RELEVANT INTERRUPT BIT
	CONO PI,CLKOFF	;CLOSE, USE STANDARD SEQUENCE
	SOSGE CODUSE
	SETOM CODUSR
	JRST CLKONJ

SEND:	XCTR XRW,[SKIPA A,(C)]	;UNIT OUTPUT
BSEND:	JSP E,NBTOCH	;BLOCK OUTPUT
	ANDI A,177
	CAIN A,"S-100
	JRST CODSSS
	SKIPE CODSSF
	JRST CODSST
	SKIPG CODCC	;WAIT FOR ROOM
	PUSHJ P,UFLS
	IDPB A,CODIPT
	MOVE A,CODIPT
	CAMN A,[10700,,CODBUF+CODBFL-1]
	HRRI A,CODBUF-1
	HRRM A,CODIPT
	SOS CODCC
	MOVE T,CODSPD
	PUSHJ P,CLQADD	;START UP CLOCK LEVEL
	CODTIM
	POPJ P,

CODO:	PUSH P,[CODO1]	;CODO1 SETS UP INTERRUPT BIT
	JSP Q,STDOPN
	1,,CODUSR
	CODDN,,CODBN


CODSSS:	SETOM CODSSF
	POPJ P,

CODSST:	SETZM CODSSF
	SUBI A,137
	JUMPLE A,CPOPJ
	MOVEM A,CODSPD
	POPJ P,

CODRS:	CONO PI,CLKOFF
	MOVEI A,CODBFL*5
	MOVEM A,CODCC
	MOVE A,CODIPT
	MOVEM A,CODPTR
	JRST CLKONJ

EBLK
CODITB:	0	;MASK OF CHANNELS OPEN, 1.1=>0
CODITD:	0	;RANDOM SCRATCH LOCATION
CODWD:	2	;CURRENT WORD
CODTIM:	0	;CLOCK QUEUE BLOCK
	-1
	JRST CLKCOD
CODSPD:	3	;CODE SPEED (SET FROM CHARS >=140) WPM= 75./(CODSPD)
CODCC:	CODBFL*5
CODPTR:	440700,,CODBUF
CODIPT:	440700,,CODBUF
LSTBIT:	0	;FLUSH 60 CPS CHIRPS
CODSSF:	0

CODBUF:	BLOCK CODBFL
BBLK

DEFINE GCODE A
BIT=1
WRD=0
IRPC B,,[A]
IFSE B,-,[WRD=WRD+7*BIT
BIT=BIT_4]
IFSE B,.,[WRD=WRD+BIT
BIT=BIT_2]
IFSE B, ,[BIT=BIT_2]
TERMIN
WRD+4*BIT
TERMIN

CODTBL:	20
	GCODE -.-.-
	GCODE .-..-.
	GCODE -. .-.
	REPEAT 2,1
	GCODE . ...
	GCODE .----.
	REPEAT 2,GCODE -.--.-
	GCODE .-.-
	GCODE . ...
	GCODE --..--
	GCODE -....-
	GCODE .-.-.-
	GCODE -..-.
	IRP A,,[-----,.----,..---,...--,....-,.....,-....,--...,---..,----.]
	GCODE A
	TERMIN
	GCODE ---...
	GCODE -.-.-.
	27727	;K WITH LONG LAST DAH
	GCODE -...-
	GCODE ...-.-
	GCODE ..--..
	GCODE ...-.
	IRP A,,[.-,-...,-.-.,-..,.,..-.,--.,....,..,.---,-.-,.-..,--,-.,---,.--.,--.-
.-.,...,-,..-,...-,.--,-..-,-.--,--..]
	GCODE A
	TERMIN
	GCODE -.--.
	GCODE -.-..-..
	GCODE .-.-.
	GCODE .-...
	GCODE -.. .

CDRUB:	GCODE ........

EXPUNGE WRD,BIT

]
IFN PLTP,[

;PLOTTER ROUTINES

PLOT:	XCTR XR,[MOVE A,(C)]	
PLOT1:	SKIPE A
	CAIN A,EOFCH
	POPJ P,
	SKIPG PLBFS
	JRST PLOTW1
PLOTW2:	IDPB A,PLPTR
	MOVE  A,PLPTR
	CAMN A,[600,,PLBUF+LPLBUF-1]
	HRRI A,PLBUF-1
	HRRM A,PLPTR
	SOS PLBFS
	AOSN PLON
	CONO PLT,SDS+PLTCHN
	POPJ P,

	PUSHJ P,PLOTW3
PLOTW1:	PUSHJ P,UFLS
	JRST PLOTW2

PLOTW3:	SKIPG T,PLBFS
	POPJ P,
	CAIL T,LPLBUF*5
	JRST POPJ1
	JRST POPJ3

BPLOT:	MOVEI E,PLOT1
	JRST NBTOCH

PLOTO:	MOVEI Q,PLOTOC
	PUSHJ P,STDOPN
	POPJ P,
	MOVE A,UNAME(U)
	CAME A,[-1]
	MOVEM A,PLOTUN
	MOVEI A,40000
	IORM A,SUPCOR
	JRST POPJ1

PLOTOC:	1,,PLTUSR
	PLTDN,,PLTBN

PLTRS:	MOVEI A,LPLBUF*6
	MOVE B,PLPTR
	CONO PI,LPTOFF
	MOVEM A,PLBFS
	MOVEM B,PLIPTR
	JRST LPTONJ

PLTBRK:	MOVE A,PLBFS
	CAIN A,LPLBUF*6
	JRST PLSTP
	AOS PLBFS
	ILDB A,PLIPTR
	MOVE B,PLIPTR
	CAMN B,[600,,PLBUF+LPLBUF-1]
	HRRI B,PLBUF-1
	HRRM B,PLIPTR
	ANDI A,77
	LSH A,3
	TRO A,SDC+PDC+SD+PLTCHN
	TRNE A,PUP+PDN
	TRC A,SD#PD
	CONO PLT,(A)
	JRST LPTRT3


PLSTP:	CONO PLT,SDC+PDC
	SETOM PLON
	JRST LPTRT3

EBLK
PLBUF:	BLOCK LPLBUF
PLON:	-1
PLPTR:	440600,,PLBUF
PLIPTR:	440600,,PLBUF
PLBFS:	LPLBUF*6
IPL:	SIXBIT /IPL/	;FILE NAME 2 OF IPL JOB (USED FOR LOADING ASO JNAME OF IPL JOB)
IPLU:	0	;USER INDEX OF IPL JOB IF IT EXISTS OR -1 IF IPL BEING LOADED
PLOTUN:	0	;USER NAME OF LOSER WHO GOT PLOTTER

;INTERPRET PLOTTER OPEN ROUTINE
BBLK
IPLO:	MOVE A,UNAME(U)
	MOVEM A,PLOTUN
	CONO PI,CLKOFF
	PUSHJ P,IPLST	;INITIATE LOADING OF IPL JOB
	JRST IPLO1
	CONO PI,CLKOFF
	PUSHJ P,IPLWT	;WAIT FOR IPL JOB TO FINISH LOADING
	PUSHJ P,UFLS
	MOVE T,IPLU	;INDEX OF IPL JOB
	SKIPE IOCHNM(T)
	JRST IPLO2	;IPL JOB OPNS CLA ON CNNL 0
	MOVE T,SV40(T)
	CAME T,[.SLEEP 17,]	;IPL JOB DOES SLEEP 17, WHEN READY
IPLO2:	JRST OPNL10	;DEVICE NOT AVAILABLE
	CONO PI,CLKON
	MOVNI A,1	;SET UP CLI OPEN
	MOVSI B,(SIXBIT /IPL/)
	PUSHJ P,CLIO
	POPJ P,
	MOVE A,UTMPTR(U)
	MOVE B,IPLU
	MOVEM A,UTMPTR(B)
	JRST POPJ1

IPLO1:	PUSHJ P,UDELAY
	JRST IPLO

IPLST:	SKIPL T,IPLU	;MAKE SURE IPL JOB NOT ALREADY BEING LOADED
	PUSHJ P,IPLIN	;MAKE SURE IPL JOB NOT ALREADY IN
	JRST POPJ1	;DONT LOAD
	HRROI T,IPL
	JRST NUJBST

;ROUTINE TO SEE IF IPL JOB WINS. CLKOFF OR CLKBRK IN PROGRESS
IPLWT:	SKIPGE T,IPLU	;CHECK IPL JOB LOADING FLAG
	POPJ P,	;IPL JOB STILL LOADING WAIT
	PUSHJ P,IPLIN	;SEE IF IPL JOB IN CORE
	SKIPE IOCHNM(T)	;SEE IF IPL JOB IN USE
	JRST POPJ1	;LOSE
	MOVE T,SV40(T)	;SEE IF IPL JOB READY
	CAMN T,[.SLEEP 17,]	;IPL JOB DOES .SLEEP 17, WHEN READY
	AOS (P)	;READY WIN
	POPJ P,	;NOT READY YET, WAIT

IPLIN:	PUSH P,U	;ROUTINE TO SEE IF IPL JOB IN. C(T)=C(IPLU), CLKOFF OR CLKBRK IN PROGRESS
	CAML T,USRHI
	JRST IPLIN1	;USER VARIABLES SLOT FLUSHED
	MOVE U,UNAME(T)
	AOJN U,IPLIN1	;UNAME OF IPL JOB IS -1
	MOVSI U,(SIXBIT /IPL/)
	CAME U,JNAME(T)
IPLIN1:	AOS -1(P)	;IPL JOB NOT IN, SO SKIP
	POP P,U
	POPJ P,

]
NUJBST:	MOVEI TT,MXCZS	;ENTRY FROM ELSEWHERE TO DO SIMILAR THINGS
	CONO PI,TTYOFF
	CAMG TT,UTTYCT
	JRST TTYONJ	;RING BUFFER FULL, WAIT
	MOVEM T,@UTTYI
	AOS UTTYCT
	AOS TT,UTTYI
	CAIL TT,UTTYS+MXCZS
	MOVEI TT,UTTYS
	MOVEM TT,UTTYI
	SETOM 1(T)	;SET JOB LOADING FLAG
	JRST TTYOJ1

IFN NMTCS,[
.INSRT DSK:SYSENG;  MTAPE >
]		;ACTUAL CODING GETS INSERTED HERE ONCE DEBUGGED

;RH(C) = ADDR OF AOBJN POINTER
;4.9=1 => RH(C) IS EXEC ADDRESS
;4.8=1 => AOBJN POINTER POINTS TO EXEC ADDRESS

BLKTNB:	PUSHJ P,@3(B)	;"DISCARD" BUFFER
	SKIPE @1(B)	;CHECK AMOUNT REMAINING ONE MORE TIME
	JRST BLKT1	;IT SPRUNG BACK TO LIFE (WRITE OVER MODE LAST BLOCK OF FILE)
BLKTN1:	SKIPG 5(B)	;RELOADING ROUTINES MUST NOT CLOBBER B,E,A,C,I
	JRST BLKTW1
	XCT 5(B)	;BLOCK IO HANDLER
BLKTF:	PUSHJ P,UFLS	; CALL JSP B,BLKT	;ADR OF PTR IN C
BLKTF1:	PUSHJ P,@2(B)	; UPPA(A)	;ADR OF AC BUF PTR 4.9 OUT
	JRST BLKTN1	;UTPPC(A)	;CNT REM IN CUR BF
			;UTRBUF NO SKIP NO MEMORY SKIP 
			;OTHERWISE TT BUF ORG	;ADR TO GET NEXT BUF
	HRRM TT,@(B)	;UTRLBF	;PUT BUF ON FREE STG
	MOVEI TT,@4(B)	;BUFSIZ	;SIZE OF BUFFER
	MOVEM TT,@1(B)	;BFLIS(A)	;ADDR TO WAIT FOR BUF
BLKT1:	SKIPGE C
	SKIPA J,(C)	;GET EXEC MOCE BLOCK .IOT (AOBJN) POINTER
	XCTR XR,[MOVE J,(C)]	;GET USER MODE AOBJN POINTER
	JUMPGE J,CPOPJ
	SKIPG D,@1(B)	;AMT LEFT IN BUFFER
	JRST BLKTNB	;NEW BUFFER
BLKTN2:	HLRE TT,J
	MOVNS TT	;DESIRED SIZE OF BLOCK
	CAMLE TT,D	;AMT OF ROOM LEFT IN CURRENT BUFFER
	MOVE TT,D	;TRANSFER ONLY AMT LEFT IN BUFFER
	HRRZ D,J	;RH OF AOBJN POINTER
	HRL D,@(B)
	SKIPGE (B)
	MOVSS D		;WRITING, SWAP BLT POINTER
	MOVE J,D
	ADDI TT,(D)	;1+LAST WORD TO BLT INTO
	TLNE C,200000
	JRST BLKTN9	;EXEC AOBJN POINTER
	SKIPGE (B)
	JRST BLKTN6	;WRITING
	XCTR XWI,[BLT D,-1(TT)]
BLKTN7:	MOVEI D,(TT)	;NO FAULT
BLKTN8:	SUBM D,J
	HRRZS J	;# WDS ACTUALLY XFERRED
	ADDM J,@(B)	;INCR BUFFER PNTR
	HRLS J
	JUMPL C,BLKTN3
	XCTR XRWI,[ADDM J,(C)]
	JRST .+2
	JRST 4,.
BLKTN4:	MOVNI J,(J)
	ADDM J,@1(B)	;DECREMENT COUNT LEFT IN BUFFER
	CAIE D,(TT)
	PUSHJ P,TPFLT	;TAKE FAULT IF ANY
	SKIPN @1(B)
	PUSHJ P,@3(B)	;BUFFER EXHAUSTED, "DISCARD"
	JRST BLKT1

BLKTN3:	ADDM J,(C)
	JRST BLKTN4

BLKTW1:	PUSHJ P,UDELAY
	JRST BLKTF1

WRDKT:	HRRO I,40
	MOVE C,[SETZ I]

BLKT:	SKIPGE C
	SKIPA E,(C)
	XCTR XRW,[MOVES E,(C)]	;MAKE SURE WRITE CYCLE WILL WIN
	JRST BLKT1

BLKTN6:	XCTR XRI,[BLT D,-1(TT)]
	JRST BLKTN7
	JRST BLKTN8

BLKTN9:	BLT D,-1(TT)
	JRST BLKTN7

EBLK

;UTAPE SERVICE ROUTINE

UTBLKS==3

;UT CHANNEL STORAGE

UTCHNT:	;BEG FOR GETSYS (UTAPE)
UTBFP:	REPEAT NUTIC+NUTOC,400000,,377	;L H BUFFER LINK PTR (INPUT PI)
		;RH  "   "  OUTPUT MAIN PROG
UTUSR:		;USER OR -1 IF FREE (LH)
UTUL:	REPEAT NUTIC+NUTOC,-1	;LINK TO CHANNEL ON SAME UTAPE OR -1(RH)
UTDIRP:	BLOCK NUTIC+NUTOC	;BYTE POINTER TO UTDIR
UTDBC:	BLOCK NUTIC+NUTOC	;RH BLCK COUNT CORRESP WITH UTDIRP
		;L H 3.1 3.5 READ FILE NO  4.9  ERROR  4.5 4.8 ERROR CNT
	;3.6 =0 FORD EXT =1 BACK EXT 3.7 4.2 PUT FILE NO
	;4.4 DELETE ON READ CLOSE
UTBFS:	BLOCK NUTIC+NUTOC	;BUFFERS IN USE 
UTLSTM:	BLOCK NUTIC+NUTOC	; TIME LAST BUF TAKEN BY PROG
UTMBN:	BLOCK NUTIC+NUTOC	; MN PROG ACTIVE BFFR NO OR -1,IF NO BUFFER ACIVE (LH)  
UTRAC:	BLOCK NUTIC+NUTOC+1	;ACTIVE  BUFFER NO PI  RH
			;FLAG TO MAIN PROG TP FULL (WRITE) RH
		;SIGN SET =>CHANNEL LOCKED
		;4.8 READ EOF REACHED AT PILEVEL OR CHNL CLOSED
		;EXTRA WORD FOR FILE DIR CHNL
		;4.7 DONT RELOAD AT PI
UTN1=.-NUTIC+1	
	BLOCK NUTOC
UTN2=.-NUTIC+1
	BLOCK NUTOC	;NAME OF FILE BEING WRITTEN
UTBKNP=.-NUTIC+1
	BLOCK NUTOC
MPRP:	BLOCK NUTIC+NUTOC	;MAIN PRGM BUFFER PNTR
MPRC:	BLOCK NUTIC+NUTOC	;CNT REMAINING
UTTNO:	BLOCK NUTOC+NUTIC	;TAPE NO (RH) 
			;LH CLOSE FLAG WRITE ORG FILE NO READ
UTEOF:	BLOCK NUTIC	;END OF FILE CHR

UTLDD:	BLOCK NUTIC+NUTOC+1	;IF -1, DC IS ACTUALLY SET UP AND TRANSFER CAN
				;BE EXPECTED IN LESS TAH 100 MS.
				;IF D CHANNEL LOCKED FLAG(4.9 UTRAC) WELL BE CHECKED
				;BEFORE GOING TO THE -1 STATE
				;EXTRA WORD FOR DIR CHNL
UTDERR:	BLOCK NUTIC+NUTOC+1	;4.9 ERROR 4.8 ABORT 4.7 UTAPE FULL

UTFS:	377	;FREE STG PNTR TO 200 WD BUFFERS
UTTLB:	-NUTIC-NUTOC	;TOTAL BUFFERS ALLOCATED TO UTAPES
UTTBF:	0	;TOTAL UT BUFFERS FREE
NUTCA:	0	;NUMBER UTAPE CHANNELS ACTIVE
NUWCA:	0	;# WRITE CHNLS ACT

UPCHFS:	0	;FAIR SHARE BFS PER CHNL

LUTWBF==200		;LENGTH OF BLK # PASSING LIST
UTWBF:	REPEAT LUTWBF,.+1	;LIST FOR PASSING BLK NOS FROM M.P. TO PI ON WRITE (INIT FS)
	0		;TERMINATOR FOR FS LIST
UTWBFS:	UTWBF		;FS PNTR

;TABLE AREAS

DEFINE TAG A
IRPS B,,A
BBLK
B:	0
EBLK
TERMIN
TERMIN

UTCH:	;BEG FOR GETSYS (UTAPE)
TAG ULCTM:,	REPEAT NUNITS,-1	;LAST TIME EUPOS RECOMPUTED
	;IF DG2=0.E. 0 THEN ACT POS =EUPOS+<TIME-ULCTM>*UDIR
TAG DRTM:,	REPEAT NUNITS,177777,,-1	;177777,,-1 => NO TIMING OP
			;N => DEAD RECKON UNTIL T=N

TAG UDIR:,	BLOCK NUNITS	;0=>STOP -1=>BACK 1=>FORW
IFN NEWDTP,	TAG OUDIR:,	BLOCK NUNITS	;DIR OF LAST OP
TAG UGOAL:,	REPEAT NUNITS,-1;POSIT GOAL OR -1 IF UNIT FREE
TAG EUPOS:,	BLOCK NUNITS	;ESTIMATED UNIT POSITION
			;SEE ULCTM IF DGW .NE. 1
TAG DCHNT:,	REPEAT NUNITS,-1;HEAD CHANNEL LIST OF UT OR -1 IF NO CHN ACT
TAG UMEMAD:,	IFE NEWDTP,REPEAT NUNITS, BLKO DC,	;GOAL MEMADR-1
		IFN NEWDTP,REPEAT NUNITS,BLKO DTC,
TAG URDWR:,	BLOCK NUNITS	;0 READ -1 WRITE(LOADED OPERATION)
TAG DG2:,	REPEAT NUNITS,-1;+ => ACCURATE
			;0 => EUPOS FAIRLY ACCURATE
			;-1 => DO NOT DEAD RECKON WITHOUT UTC
TAG UTASS:,	REPEAT NUNITS,0	;0 IF NOT ASSIGNED, SYSTEM NAME IF ASSIGNED
TAG UDIRO:,	REPEAT NUNITS,-1;ORGIN OF DIRECTORY
;OR -1 DIR NOT LOADED OR 4.9 DIR LOCKED OR 4.8+4.9 DIR DOUB LOCKED
;4.7 DIR CHANGED
;IF DIR LOCKED, IT MAY BE REFERENCED BUT NOT CHANGED
;4.5=0 => DIR AT LEAST ON WAY IN
;4.4=1 => TAPE IN UBLAT MODE


TAG UFLAPF:,	BLOCK NUNITS	;4.9 FLAPPING RQSTED OR IN PROGRESS
			;4.8 RQ TO ABORT FLAPPING
			;4.7 DRIVE ACTUALLY ON THE WAY
			;4.6 (TD10 ONLY) 0 PHASE 1 STOP   1 PHASE 1 STOP DONE
			;RH TIME TO STOP AFTER FLAPPED

TAG ULDCH:,	BLOCK NUNITS	;NUMBER OF LOADED CHANNEL LH, BUFFER NO (INDEX INTO IOBFT) IN RH
			;LH 4.9 = LOW PRIORITY POSIT


TAG UDPWF:,	REPEAT NUNITS,-1	;DIRECTORY PAWED OVER FLAG

TAG UMNFB:,	BLOCK NUNITS	;MAIN PRGM FREE BLOCKS ON TAPE

TAG UTERP:,	BLOCK NUNITS	;LH ERROR CODE (CONI UTS,) RH # ERRORS

TAG UMNTR:,	BLOCK NUNITS	;UNAME OF LAST JOB TO READ IN DIRECTORY

SUNIT:	0	;SELECTED UNIT OR 0
IFE NEWDTP,	SUNITL:	0	;SAME _ 3
SMODE:	-1	;-1 POSIT 0 DATA
UIDLE:	-1	;-1 UTAPES COMPLETELY IDLE

IFN NEWDTP,	CUINT:	0	;-1 CLK HAS CAUSED BREAK
WRITE:	0	;0 READ -1 WRITE
TAPCNT:	0
TAP1:	0
TAP2:	0
TAP3:	0
UTTM1:	0	;UNIT COULD START IN SEARCH LOOP
UTTM2:	0	;MOST PRESSING UNIT SO FAR
UTTM3:	0	;TIME FOR ABOVE OR -1 IF NONE
UTTM4:	0	;TAPE TO START FLAPPING (FLAG FLAP IN PROG IF NEWDTP=1)
IFE NEWDTP,[
UTTM5:	0	;TAPE TO STOP FLAPPING
FLPUNT:	0
]
UTCPDP:	-LUTCP,,UTCP-1
UTCP:	BLOCK LUTCP

UTACS:	BLOCK 20
UTENB:	0
LUTOTM:	0	;TIME OF LAST UT OPER
UTHERR:	0	;UT HANGUP ERR
USTSW:	0	;UT START SWITCH
UDCC:	0	;-1 IF UTAPE HAVE DC FOR BLK CYCLE
UTCHE==.-1	;END FOR GETSYS (UTAPE)

BBLK

;UTAPE CONTINUOUS NON-FILE IO

AUBL2:	CONO PI,UTCON	;DIRECTORY LOCKED, MAYBE ITS BEING FLAPPED
	PUSHJ P,UDELAY
AUBLAT:	XCTR XRW,[SKIPLE I,(J)]	;GET TAPE NUM, C(AC), SKIP IF NEG OR ZERO
	CAILE I,NUNITS	;SKIP UNLESS TOO BIG
	POPJ P,		;ERR EXIT, BAD TAPE NUM
	CONO PI,UTCOFF
	MOVE B,UDIRO(I)
	AOJE B,AUBL1	;DIR NOT IN
	TLNN B,10000
	JRST UTCONJ	;NOT IN UBLAT MODE
	JUMPL B,AUBL2
AUBL1:	MOVSI B,10000
	MOVEM B,UDIRO(I)
	CONO PI,UTCON
	JRST POPJ1


;SET UTAPE NAME	;.UTNAM AC,	;LH(AC)=6BIT NAME, RH(AC)=TAPE #

AUTNAM:	XCTR XR,[MOVE Q,(J)]
	HRRZ I,Q	;GET TAPE #
	JUMPE I,CPOPJ	;TOO SMALL
	CAIG I,NUNITS	;TOO LARGE?
	PUSHJ P,UTSNMK	;ASSIGNED TO SOMEONE ELSE?
	POPJ P,		;YES, LOSE
	TLO D,1		;SET FLAG TO EXIT FROM OPEN ROUTINE
	PUSHJ P,UTO0	;GET DIR IN CORE, LOCK, ETC.
	TLNE TT,210000	;CHECK FOR DIRECTORY NOT READ IN, UBLAT MODE
	JRST LSWPOP	;JUMP ON LOSSAGE
	HLRZ A,Q	;GET TAPE NAME
	AOSN UDPWF(I)	;DIRECTORY PAWED OVER YET?
	PUSHJ P,UDPW	;NO, GO DO IT
	MOVE J,UDIRO(I)	;GET POINTER TO DIR
	XOR A,177(J)	;GET DIFF BETWEEN OLD & NEW NAMES
	TRNN A,-1	;IS THERE ANY?
	JRST AUTN2	;NO, SKIP SOME CRUFT
	TLZ A,-1	;IGNORE DIFFERENCES IN LH
	XORM A,177(J)	;MODIFY NAME TO NEW NAME
	TLO J,100000	;SET DIR CHANGED BIT
AUTN2:	MOVEM J,UDIRO(I)	;STORE MODIFIED POINTER
	JRST LSWPJ1

;INITIALIZE UTAPE DIRECTORY	;.UINIT AC,	;C(AC)=TAPE #
;TAPE MUST BE ASSIGNED

AUINIT:	XCTR XRW,[SKIPLE I,(J)]	;TAPE # TOO LOW?
	CAILE I,NUNITS	;OR HIGH?
	POPJ P,		;YES
	MOVE A,USYSNM(U)	;PICK UP LOSER'S SNAME
	SKIPE UTASS(I)	;LOSE IF TAPE NOT ASSIGNED
	CAME A,UTASS(I)	;OR IF SNAME DOESN'T MATCH
	POPJ P,		;SO DON'T SKIP
	TLO D,1		;SET EXIT FLAG FOR OPEN ROUTINE
	PUSHJ P,UTO0	;GET DIR, LOCK IT, ETC.
	TLNE TT,210000	;CHECK FOR UBLAT MODE, DIRECTORY NOT READ (TT=UDIRO(I))
	JRST LSWPOP
	SETZM (TT)	;CLEAR FIRST LOC
	HRLI A,(TT)	;SET UP LH OF BLT POINTER
	HRRI A,1(TT)	;& RH
	BLT A,177(TT)	;ZAP
	MOVE A,[757367573674]	;GET WORD OF 7 5-BIT BYTES VALUE 36
	MOVEM A,56(TT)	;INDICATE FIRST 7 BLOCKS RESERVED
	MOVSI A,660000	;ONE 5-BIT BYTE, VALUE 33
	MOVEM A,67(TT)	;MARK FILE DIRECTORY BLOCK
	HRROS 177(TT)	;MARK END OF DIR
	SETZM UDPWF(I)	;INDICATE DIR PAWED OVER
	MOVEI A,559.	;# OF FREE BLOCKS IN EMPTY TAPE
	MOVEM A,UMNFB(I)	;STORE FOR FUTURE REFERENCE
	TLO TT,100000	;INDICATE CHANGED
	MOVEM TT,UDIRO(I)	;UPDATE POINTER
	JRST LSWPJ1

;UTAPE DISMOUNT

AUDISM:	XCTR XRW,[MOVE A,(J)]	;OPER 22
NFLAP:	JUMPLE A,CPOPJ
	CAILE A,NUNITS
	POPJ P,
	MOVSI C,-NUTIC-NUTOC
	CONO PI,UTCOFF
AUTDM1:	SKIPGE UTUSR(C)
	JRST AUTDM2
	HRRZ D,UTTNO(C)
	CAMN A,D
	JRST UTCONJ	;SOME ONE USING TAPE
AUTDM2:	AOBJN C,AUTDM1
	CONO PI,UTCON
	MOVSI C,(SETZ)
	IORM C,UFLAPF(A)
	JRST POPJ1

;ATTEMPTED DIRECTORY READ GOT FLUSHED
UTOLOS:	TLNE D,1	;CHECK EXIT FLAG
	JRST NULSET	;NOT .OPEN, SEIZE NOTHING AND RETURN
	JRST OPNL7	;.OPEN, SIGNAL DEVICE NOT READY

UTOF1:	MOVSI TT,200000
	IORM TT,UFLAPF(I)	;RQEST ABORT OF FLAP
	CONO PI,UTCON
	SKIPGE UFLAPF(I)
	PUSHJ P,UFLS	;HOPE FOR BEST
UTO:	JUMPE I,OPNL1	;UTAPE OPEN
	CAILE I,NUNITS
	JRST OPNL1
UTO0:	CONO PI,UTCOFF
	SKIPGE UFLAPF(I)
	JRST UTOF1	;FLAPPING IN PROGRESS
	SKIPGE TT,UDIRO(I)
	AOSE TT
	JRST UTO4	;FILE DIR IN OR ON THE WAY
	MOVEI TT,200000
	MOVEM TT,DCHNT(I)
	MOVE TT,UNAME(U)
	MOVEM TT,UMNTR(I)	;TELL WHO FIRST CAUSED DIR TO BE READ IN
	MOVSI TT,20000
	ANDCAM TT,UDIRO(I)
UTO4:	CONO PI,UTCON
	MOVSI TT,400000
	MOVNI T,1
	PUSHJ P,LWAIT
	CAMLE T,UDIRO(I)	;WAIT FOR DIRECTORY TO COME IN OR GO OUT
	IORB TT,UDIRO(I)	;IF IN THEN LOCK IT
	CONO PI,UTCON
	CAMN TT,[-1]
	JRST UTOLOS	;DIDN'T GET READ IN
	PUSHJ P,SGNSET	;MAKE SUURE DIRECTORY GETS UNLOCKED ON PCLSR
	UDIRO(I)
	TLNE D,1	;CHECK SPECIAL EXIT FLAG
	POPJ P,		;EXIT
	TLNE TT,10000
	JRST UTOBL1	;IN UBLAT MODE
	AOSN UDPWF(I)
	PUSHJ P,UDPW
UDPW1:	TRNE D,200000
	JRST UTDEL1	;DELETE OR RENAME
	JUMPL D,UTOW1	;WRITE
	PUSHJ P,FLDRCK
	JRST UTO5B	;NORMAL FILE WANTED
	MOVEI J,0	;UTAPE DIRECTORY WANTED
	PUSHJ P,LSWPOP
LISTFE:	PUSHJ P,SWTL
	UDCSW
	MOVSI TT,-NUDCH
UD1:	SKIPGE UDUSR(TT)
	JRST UD2
	AOBJN TT,UD1
	JRST OPNL17	;DIRECTORY NOT AVAILABLE NOW

UD2:	MOVEM J,DSKLST(TT)
	MOVEM I,UDUSR(TT)
	PUSHJ P,LSWPOP
	MOVE Q,USYSN1(U)	;2314 UFD
	MOVEM Q,UDSYSN(TT)
	JUMPG J,UDIF
	CONO PI,CLKOFF
	MOVE Q,UDIRO(I)
	MOVEM Q,DIRPT(TT)
	CONO PI,CLKON
	MOVEI J,200
	TRNE D,2
	JRST UDBIN
	MOVEI Q,LISTF
UDIF1:	MOVEM Q,DIRPC(TT)
	HRL A,TT
	JSP Q,OPSLD1
	DIRCHN,,DIRBN

UDIF:	HLRZ Q,UDT-1(J)
	HRRZ T,UDT-1(J)
	JRST (T)

UQL1:	HRRZM H,UUDPP(TT)	;2314 MFD
	MOVEI J,2000
	TRNE D,2
	JRST QUDBIN
	JRST UDIF1

UQL1A:	PUSHJ P,STMSET
	UDUSR(TT)
UQL1B:	PUSHJ P,TCALL	;2314 UFD
	JRST NMMRQ	;GET LOW HALF PAGE
	JRST UQL1W	;NOT AVAIL NOW
	MOVEI T,MU23LS
	DPB T,[MUR,,MEMBLT(A)]
	LSH A,10.
	MOVEM A,DIRPT(TT)
	MOVEM A,UUDPP(TT)
	PUSH P,TT
	PUSHJ P,QUDLK
	HRL A,QSNLCN(H)
	HRRI T,2000(A)
	BLT A,-1(T)	;COPY UFD
	PUSHJ P,QUDULK
	PUSHJ P,LSWDEL
	PUSHJ P,LSWPOP	;SOS QSNNR
	POP P,TT
	MOVEI J,2000
	TRNE D,2
	JRST UDBIN
	JRST UDIF1

UQL1W:	MOVE T,TIME
	ADDI T,30.
	CAMLE T,TIME
	PUSHJ P,UFLS
	JRST UQL1B

QMLSTF:	MOVEI J,4	;ENTRY TO GET MASTER 2314 DIRECTORY
	JRST LISTF7

QLISTF:	MOVEI J,3	;ENTRY FOR 2314 USER DIRECTORY
LISTF7:	MOVEI I,0
	JRST LISTFE

UTOBL1:	CAIN W,4
	JRST OPNL4	;DELETE ILLEGAL IN UBLAT MODE
	CLEARB A,B
	JRST UTO8

;LH INITIAL PC RH DISP ADR AT OPEN TIME
UDT:	NDLF,,UDIF1	;NON DIR DEVICE
	UCL1,,UDIF1	;CORE LINK
	UQL2,,UQL1A	;2314 UFD
	QMLS1,,UQL1	;2314 MFD
	ERR1,,ERR2	;ERR DEVICE
	TTYFLD,,UDIF1	;TTY DIR
	TTYF99,,UDIF1

ERRO:	MOVEI J,5
	JRST LISTF7

ERR2:	SOJE A,ERR21	;LAST ERRONEOUS CHANNEL
	SOJE A,ERR22	;CHANNEL SPECIFIED IN B
	SOJE A,ERR23	;STATUS WORD IN B
	SETOM UDUSR(TT)
	JRST OPNL11

ERR21:	LDB B,[BCHPTR]
ERR22:	ANDI B,17
	ADDI B,IOCHST(U)
	MOVE B,(B)
ERR23:	MOVEM B,UUDPP(TT)
	JRST UDIF1

CORO:	PUSHJ P,FLDRCK
	JRST OPNL11
	MOVEI J,7
	JRST LISTF7

UTO5B:	PUSHJ P,UTLK3	;MUST NOT CLOBBER TT
	JUMPE B,OPNL4
UTOW2:UTO8:	CONO PI,UTCON
	MOVSI TT,-NUTIC
	TLNE C,1
	MOVE TT,[-NUTOC,,NUTIC]
	SKIPL UTUSR(TT)
	AOBJN TT,.-1
	JUMPG TT,UNCA	;NO CHANNEL AVAILABLE
	CONO PI,UTCOFF
	SKIPL UTUSR(TT)
	JRST UTO8
	MOVEI J,DCHNT-UTUL(I)
	JRST .+2
UTO2:	MOVE J,Q
	HRRE Q,UTUL(J)
	JUMPGE Q,UTO2	;INSERT CHNL ONTO LIST FOR TAPE
	HRLOM U,UTUSR(TT)
	HRRM TT,UTUL(J)
	HRRZM I,UTTNO(TT)
	HRRZ J,UDIRO(I)
	ADD J,A
	MOVE Q,133(J)
	MOVEI J,EOFCH
	TRNN Q,1
	MOVEI J,141
	MOVEM J,UTEOF(TT)	;STORE EOF CHR
	SETZM UTDBC(TT)
	DPB A,[300500,,UTDBC(TT)]
	JUMPL D,UTOW3	;WRITE
	DPB A,[220500,,UTDBC(TT)]
UTOW4:	HRLM A,UTTNO(TT)
	HRRZ J,UDIRO(I)
	ADD J,[500,,23.*2-1]
	MOVEM J,UTDIRP(TT)
	MOVE J,[SETZ 377]
	MOVEM J,UTBFP(TT)
	CLEARM UTBFS(TT)
	MOVE J,TIME
	MOVEM J,UTLSTM(TT)
	HRROS UTMBN(TT)
	HLLOS UTRAC(TT)
	HRRZS UTRAC(TT)
	CONO PI,UTCON
	CLEARM MPRC(TT)
	AOS NUTCA
	PUSHJ P,FSCMP
	HRRZS UTRAC(TT)
	PUSHJ P,LSWPOP	;RELEASE FILE DIR
	MOVSS C
	HRL A,TT
	JSP Q,OPSLC7
	DNUACII,,DNUACCO	;ASCII UNITS INPUT ;ASCII UNITS OUTPUT
	DNUBKI,,DNUBKO	;BLOCK INPUT ;BLOCK OUTPUT
	DNUDTI,,DNUDTO	;WORD INPUT ;WORD OUTPUT
	DNUBKI,,DNUBKO	;BLOCK INPUT ;BLOCK OUTPUT

UTOW1:	SKIPN UMNFB(I)
	JRST OPNL6	;FULL
	PUSH P,B
	PUSH P,A
	PUSHJ P,UTSNMK
	JRST UTWNA	;NOT ASSIGNED
	SETZB A,B
	PUSHJ P,UTLK3
	JUMPE B,UFILDF	;FILE DIR FULL
	JRST UTOW2

UTSNMK:	SKIPN T,UTASS(I)
	JRST POPJ1
	CAME T,UNAME(U)
	CAMN T,USYSNM(U)
	AOS (P)
	POPJ P,

UTOW3:	HRROM TT,1(B)	;RESERVE FILE NAME
	POP P,UTN1(TT)	;STORE NAMES
	POP P,UTN2(TT)
	MOVSI J,100000
	IORM J,UDIRO(I)	;SET FILE DIR MODIFYED
	MOVSI J,UTBKNP(TT)	;GET LIST PNTR PNTR
	MOVEM J,UTBKNP(TT)	;MAKE LH SELF-REFERENT SO INIT LINK WILL GO IN RH
	AOS NUWCA	;INCR # ACT UWRITE CHNLS
	JRST UTOW4

UDATAI:	HRRO I,40
	MOVE C,[SETZ I]

UBLKI:	JSP B,BLKT
	MPRP(A)
	MPRC(A)
	UTBGB	;4.9 = 0 UTAPE 1 DISK
	UTBRB
	200
	SKIPG UTBFS(A)
	CAMN D,UTEOF(A)
	JRST UTICL	;EOF IN CHAR. MODE

ERR1:	SKIPN I,UUDPP(A)
	JRST ERR3
	LDB B,[220600,,UUDPP(A)]	;OPEN LOSS FIELD
	JUMPE B,ERR1B
	CAIL B,NERMES
	MOVEI B,NERMES
	MOVE TT,ERMST1-1(B)
	JSP B,MESPNT
ERR1B:	LDB B,[300300,,UUDPP(A)]	;IDS ERROR FIELD
	JUMPE B,ERR1C
	MOVE TT,ERMST2-1(B)
	JSP B,MESPNT
ERR1C:	LDB B,[330400,,UUDPP(A)]	;IOCERR FIELD
	JUMPE B,UCL7
	CAIL B,MIOTER
	CAIL B,NERM1+MIOTER
	MOVEI B,NERM1+MIOTER
	MOVE TT,ERMST3-MIOTER(B)
	JSP B,MESPNT
	JRST UCL7

ERR3:	MOVEI TT,[ASCIZ /ISE0
/]
	JSP B,MESPNT
	JRST UCL7

ERMST1:	[ASCIZ /NO SUCH DEVICE
/]
	[ASCIZ /WRONG DIRECTION
/]
	[ASCIZ /TOO MANY TRANSLATIONS
/]
	[ASCIZ /FILE NOT FOUND
/]
	[ASCIZ /DIRECTORY FULL
/]
	[ASCIZ /DEVICE FULL
/]
	[ASCIZ /DEVICE NOT READY
/]
	[ASCIZ /DEVICE NOT AVAILABLE
/]
	[ASCIZ /ILLEGAL FILE NAME
/]
	[ASCIZ /MODE NOT AVAILABLE
/]
	[ASCIZ /FILE ALREADY EXISTS
/]
	[ASCIZ /BAD CHANNEL NUMBER
/]
	[ASCIZ /TOO MANY ARGUMENTS (CALL)
/]
	[ASCIZ /PACK NOT MOUNTED
/]
	[ASCIZ /DIRECTORY NOT AVAIL
/]
	[ASCIZ /NON-EXISTENT USER NAME
/]
	[ASCIZ /LOCAL DEVICE ONLY
/]
	[ASCIZ /SELF-CONTRADICTORY OPEN
/]
	[ASCIZ /ATTEMPT TO MODIFY WRITE FILE OPEN FOR READ
/]
	[ASCIZ /M.F.D. FULL
/]
	[ASCIZ /DEVICE NOT ASSIGNABLE TO THIS PROCESSOR
/]
	[ASCIZ /DEVICE WRITE-LOCKED
/]
	[ASCIZ /LINK DEPTH EXCEEDED
/]
	[ASCIZ /TOO FEW ARGUMENTS (CALL)
/]
	[ASCIZ /CAN'T MODIFY JOB
/]
	[ASCIZ /CAN'T GET THAT ACCESS TO PAGE
/]
	[ASCIZ /MEANINGLESS ARGS
/]
	[ASCIZ /WRONG TYPE DEVICE
/]
	[ASCIZ /NO JOB WITH THAT INDEX
/]
	[ASCIZ /VALID CLEAR OR STORED SET
/]
	[ASCIZ /NO CORE AVAILABLE
/]
	[ASCIZ /NOT TOP LEVEL
/]
;ADD NEW MESSAGES HERE

NERMES==.-ERMST1
	[ASCIZ /OPEN TYPE NOT DETERMINED
/]

ERMST2:	[ASCIZ /IDS ILLEGAL SCOPE MODE
/]
	[ASCIZ /IDS SCOPE HUNG
/]
	[ASCIZ /MORE THAN 1K SCOPE BUFFER
/]
	[ASCIZ /IDS MEM PROTECT
/]
	[ASCIZ /IDS ILLEGAL SCOPE OP
/]
	[ASCIZ /IDS MEM PROTECT ON PDL PNTR
/]
	[ASCIZ /IDS ILLEGAL PARAMETER SET
/]

ERMST3:	[ASCIZ /ILLEGAL HARDWARE OPERATION ATTEMPTED
/]
	[ASCIZ /ATTEMPTED RANDOM ACCESS TO ADDRESS BEYOND END OF FILE
/]
	[ASCIZ /NON-RECOVERABLE DATA ERROR
/]
	[ASCIZ /NON-EXISTENT SUB DEVICE
/]
	[ASCIZ /OVER IOPOP
/]
	[ASCIZ /OVER IOPUSH
/]
	[ASCIZ /USR OP CHNL DOES NOT HAVE USR OPEN
/]
	[ASCIZ /CHNL NOT OPEN
/]
	[ASCIZ /DEVICE FULL
/]
	[ASCIZ /CHNL IN ILLEGAL MODE ON IOT
/]
	[ASCIZ /ILLEGAL CHR AFTER CNTRL P ON TTY DISPLAY
/]
;INSERT NEW MESSAGES HERE
NERM1==.-ERMST3
	[ASCIZ /IOT OR OPR TYPE NOT DETERMINED
/]
QUDBIN:	CONO PI,CLKOFF
	HRRZ T,QMDRO
	MOVEM T,DIRPT(TT)
	CONO PI,CLKON
UDBIN:	MOVEM J,NUM(TT)	;DOESN'T USE DIRPC THIS PC
	MOVEM J,ENDT(TT)
	HRL A,TT
	JSP Q,OPSLD1
	NDATAI,,NBLKI

UTDCLS:	MOVE B,DSKLST(A)
	CAIN B,3
	JRST UTDCL1
UTDCLX:	SETOM UDUSR(A)
	POPJ P,

UTDCL1:	PUSH P,A
	MOVE A,UUDPP(A)
	LSH A,-10.
	PUSHJ P,MEMR
	POP P,A
	JRST UTDCLX

DIRCH:	XCTR XRW,[MOVES (C)]	;MAKE SURE WRITE WILL WIN
	PUSH P,C
	PUSHJ P,DIRCHR
	POP P,C
	XCTR XW,[MOVEM I,(C)]
	POPJ P,

DIRB:	JSP E,INBTCH	;DIRECTORY BLOCK MODE ASCII INPUT
	PUSH P,E
	PUSHJ P,DIRCHR	;RETURN TO DIRECTORY ROUTINE, GET CHAR
	POP P,E
	CAIN I,EOFCH
	TLO E,(SETZ)	;EOF, CAUSE STOP WHEN THIS WORD FILLED
	POPJ P,

DDATAI:	HRRO I,40	;IMAGE MODE DIRECTORY XFER
	MOVE C,[SETZ I]
DBLKI:	JSP B,BLKT
	DIRPT(A)
	NUM(A)
	POPAJ	;EOF.  FLUSH RETURN AND RETURN
	CPOPJ
	200
	SKIPA

UDPW:	HRRZ J,UDIRO(I)
	MOVEI TT,37
	DPB TT,[370500,,177(J)]
	ADD J,[500,,23.*2-1]
	MOVEI TT,0
UDPW2:	ILDB Q,J
	SKIPN Q
	AOS TT
	CAIE Q,37
	JRST UDPW2
	MOVEM TT,UMNFB(I)
	POPJ P,

UNAMQ:	MOVEI T,0
UNAMQ1:	SKIPN UNAME(T)
	JRST UNAMQ2
	CAME B,USYSNM(T)
	CAMN B,UNAME(T)
	POPJ P,
UNAMQ2:	CAML T,USRHI
	JRST POPJ1
	ADDI T,LUBLK
	JRST UNAMQ1

UQL3C:	SKIPA I,["*]
UQL3:	MOVEI I,"-
	PUSHJ P,OUTC
	JRST UQL3A

UQL2:	MOVEI TT,[ASCIZ /DSK /]	;GENERATE USER DIRECTORY
	JSP B,MESPNT
	MOVE I,UUDPP(A)
	MOVEI J,UDNAME(I)
	JSP B,SIXTYC	;SEND DIRECTORY NAME
	MOVEI TT,[ASCIZ /
FREE BLOCKS /]
	JSP B,MESPNT
	MOVSI E,-NQS
UQL2A:	MOVEI I,"U	;SEND UNIT #
	PUSHJ P,OUTC
	MOVEI I,"0(E)
	PUSHJ P,OUTC
	PUSHJ P,OUTCS
	SKIPGE QACT(E)
	JRST UQL3	;UNIT NOT ENGAGED
	MOVE J,QTUTO(E)
	TLNE J,40000
	JRST UQL3C	;TUT FOR UNIT NOT IN
	MOVEI I,"#
	PUSHJ P,OUTC
	MOVE TT,QPKID(E)
	JSP B,GDPT	;AND #
	PUSHJ P,OUTCS
	MOVE TT,QSFT(E)
	JSP B,GDPT	;AND # FREE TRACKS
UQL3A:	PUSHJ P,OUTCS
	AOBJN E,UQL2A
	JSP B,MESPCR
	MOVE I,UUDPP(A)
	MOVEM I,DIRPT(A)
	MOVE Q,UDNAMP(I)
UQL4:	CAIL Q,2000
	JRST UCL7
	HRLI I,440600+Q
	HLLM I,DIRPT(A)

UQLP:	ADDI Q,2	;MOVE PNTR TO 3RD WRD OF FILE DESC
	MOVE I,@DIRPT(A)
	MOVEI TT,[ASCIZ /* /]	;DELETED OR BEING WITTEN
	TLNN I,UNIGFL
	MOVEI TT,[ASCIZ /  /]
	JSP B,MESPNT
	MOVE I,@DIRPT(A)
	TLNE I,UNLINK
	JRST UQLL1	;LINK
	LDB TT,[UNPKN+@DIRPT(A)]
	JSP B,GDPT	;PRINT PACK #
	LDB TT,[UNPKN+@DIRPT(A)]
	CAIG TT,9
UQLL2:	PUSHJ P,OUTCS
	PUSHJ P,OUTCS
	SUBI Q,2	;BACK TO FIRST WD
	JSP B,SIXTYA	;SEND FIRST FILE NAME
	JSP B,SIXTYB	;AND SECOND (AOSES Q)
	PUSHJ P,OUTCS
	AOS Q	;SET Q TO POINT TO FILE DESC PNTR
	LDB E,[UNDSCP+@DIRPT(A)]	;PICK UP FILE DESC PNTR
	IDIVI E,UFDBPW
	ADDI E,UDDESC	;COMPUTE WORD ADDRESS
	MOVE I,@DIRPT(A)	;SAVE STATUS WORD
	EXCH E,Q	;MOVE INTO PNTR
	MOVE TT,QBTBLI(TT)
	TLO TT,Q
	HLLM TT,DIRPT(A)	;SET UP DIRPT TO POINT TO FILE DESC
	TLNE I,UNLINK
	JRST QLL1	;LINK
	MOVEI TT,0
UQL5:	JSP B,UQL5R	;CHECK IF ABOUT TO INCREMENT OFF WORD
	ILDB I,DIRPT(A)
	JUMPE I,UQL5A	;STOP
	CAILE I,UDTKMX
	JRST UQL5B
	ADD TT,I
	JRST UQL5

UQLL1:	MOVEI I,"L
	PUSHJ P,OUTC
	JRST UQLL2

QLL1:	CLEARM ENDT(A)	;CNTS TO 3 FOR USER NAME AND 2 FILE NAMES
QLL3:	CLEARM NUM(A)	;CHR CNTR
QLLIST:	JSP B,UQL5R
	ILDB I,DIRPT(A)
	JUMPE I,QLL4
	CAIN I,';
	JRST QLL2
	CAIN I,':
	JRST QLL5
QLL5A:	ADDI I,40
	PUSHJ P,OUTC
	AOS I,NUM(A)
	CAIGE I,6
	JRST QLLIST
QLL2:	PUSHJ P,OUTCS
	AOS I,ENDT(A)
	CAIGE I,3
	JRST QLL3
QLL4:	JSP B,MESPCR
	MOVEI Q,3(E)	;ADVANCE Q
	JRST UQL4

QLL5:	JSP B,UQL5R
	ILDB I,DIRPT(A)
	JRST QLL5A

UQL5R:	MOVE I,DIRPT(A)	;CHECK IF ABOUT TO ILDB OFF WORD
	TLNE I,770000
	JRST (B)	;NO
	MOVEI I,440600+Q	;YES INCREMENT Q INSTEAD
	HRLM I,DIRPT(A)
	AOJA Q,(B)

UQL5B:	CAIGE I,UDWPH	;PLACE HOLDER
	AOJA TT,UQL5	;SKIP AND TAKE
	CAIN I,UDWPH
	JRST UQL5	;NULL
	REPEAT NXLBYT,[JSP B,UQL5R
	IBP DIRPT(A)
]
	AOJA TT,UQL5	;SPACE OVER 2ND HALF OF LOAD ADDRESS

UQL5A:	JSP B,GDPT	;TYPE OUT # BLOCKS
	PUSHJ P,OUTCS
	MOVE Q,E	;FILE POINTER
	MOVEI I,"!
	SKIPGE @DIRPT(A)	;SKIP ON NOT DUMPED
	MOVEI I,40
	PUSHJ P,OUTC	;HAS NOT BEEN BACKED UP
	MOVEI Q,1(E)
	LDB E,[1200,,DIRPT(A)]
	JUMPN E,[JRST 4,.]
	MOVE TT,@DIRPT(A)
	AOJE TT,UQL5C	;DATE NOT KNOWN
IFN OQDTSW,[	;EVENTUALLY FLUSH CODING
	LDB TT,[UNMON+@DIRPT(A)]
	JSP B,GDPT	;TYPE MONTH
	MOVEI I,"/
	PUSHJ P,OUTC
	LDB TT,[UNDAY+@DIRPT(A)]
	JSP B,GDPT	;TYPE DAY
	MOVEI I,"/
	PUSHJ P,OUTC
	LDB I,[UNYRB+@DIRPT(A)]
	MOVEI TT,YEAR
IFE YEAR&1,	SKIPE I
IFN YEAR&1,	SKIPN I
IFG YEARPH,	AOS TT
IFL YEARPH,	SOS TT
	JSP B,GDPT	;TYPE YEAR
	PUSHJ P,OUTCS
	HRRZ TT,@DIRPT(A)
	IDIVI TT,60.*60.*2
	MOVE E,I
	JSP B,G2DPT
	MOVEI I,":
	PUSHJ P,OUTC
	MOVE TT,E
	IDIVI TT,60.*2
	MOVE E,I
	JSP B,G2DPT
	MOVEI I,":
	PUSHJ P,OUTC
	MOVE TT,E
	LSH TT,-1
	JSP B,G2DPT
]	;END OLD DATE CODING
UQL5D:	JSP B,MESPCR
	ADDI Q,2	;ADVANCE Q
	JRST UQL4

UQL5C:	MOVEI I,"-
	PUSHJ P,OUTC
	JRST UQL5D

;GENERATE MFD LISTING
QMLS1:	CONO PI,CLKOFF
	MOVE Q,QMDRO
	HRLI Q,440600+Q
	MOVEM Q,DIRPT(A)
	MOVE Q,MDNAMP(Q)
	CONO PI,CLKON
QMLS2:	CAIL Q,1777
	JRST UCL7
	SKIPN @DIRPT(A)
	JRST QMLS3
	JSP B,SIXTYA
	JSP B,MESPCR
QMLS3:	ADDI Q,LMNBLK
	JRST QMLS2

IFN OQDTSW,[	;EVENTUALLY FLUSH CODE
ZZ==0
DAYTB:	;DAYS PRECEEDING MONTH (NO LEAP YEAR)
IRPS A,,[31,28,31,30,31,30,31,31,30,31,30,31]
	ZZ
	ZZ==ZZ+A!.
TERMIN
]
LISTF:	MOVEI Q,220600+Q
	HRLM Q,DIRPT(A)
	MOVEI Q,177
	MOVE TT,@DIRPT(A)
	AOJE TT,LISTF1
	JSP B,SIXTYP
LISTF1:	MOVEI TT,[ASCIZ /
FREE FILES /]
	JSP B,MESPNT
	MOVSI Q,-23.
	MOVEI TT,0
LISTF4:	SKIPE @DIRPT(A)
	AOJA Q,LISTF8
	AOS Q
	SKIPN @DIRPT(A)
	AOS TT
LISTF8:	AOBJN Q,LISTF4
	JSP B,GDPT
	MOVEI TT,[ASCIZ /	FREE BLOCKS /]
	JSP B,MESPNT
	SETZB J,TT
	JSP B,BLKPNT
LISTD2:	JSP B,MESPCR
	MOVSI Q,-23.
LISTF2:	MOVEI I,440600+Q
	HRLM I,DIRPT(A)
	MOVE I,@DIRPT(A)
	JUMPE I,LISTF5
LISTF6:	PUSHJ P,OUTCS
	JSP B,SIXTYA
	JSP B,SIXTYB
	PUSHJ P,OUTCS
	MOVEI J,1(Q)
	JSP B,BLKPNN
LISTD4:	JSP B,MESPCR
LISTF3:	AOBJN Q,LISTF2
UCL7:	MOVEI I,14
	PUSHJ P,OUTC
	MOVEI I,EOFCH
	JRST .-2

LISTF5:	AOJA Q,LISTF3

NDLF:	MOVEI TT,[ASCIZ /
NON-DIRECTORY DEVICE/]
	JSP B,MESPNT
	JRST UCL7

UCL1:	MOVSI Q,-NCLCH
UCL6:	SKIPN CLSYN(Q)
	JRST UCL5A
	MOVEI J,CLSYN(Q)
	JSP B,SIXTYC
	MOVEI J,CLN1(Q)
	JSP B,SIXTYC
	MOVEI J,CLN2(Q)
	JSP B,SIXTYC
	HLRE B,CLUSR(Q)
	AOJE B,UCL2
	MOVEI J,UNAME-1(B)
	MOVEM B,NUM(A)
	JSP B,SIXTYC
	MOVE B,NUM(A)
	MOVEI J,JNAME-1(B)
	JSP B,SIXTYC
UCL3:	MOVEI TT,[ASCIZ /->/]
	JSP B,MESPNT
	HRRE B,CLUSR(Q)
	AOJE B,UCL4
	MOVEI J,UNAME-1(B)
	MOVEM B,NUM(A)
	JSP B,SIXTYC
	MOVE B,NUM(A)
	MOVEI J,JNAME-1(B)
	JSP B,SIXTYC
UCL5:	JSP B,MESPCR
UCL5A:	AOBJN Q,UCL6
	JRST UCL7

UCL4:	MOVEI B,UCL5
	JRST .+2
UCL2:	MOVEI B,UCL3
	MOVEI J,[SIXBIT /OPEN/]
SIXTYC:	HRLI J,440600
	MOVEM J,DIRPT(A)
	PUSHJ P,OUTCS
	JRST SIXTYP

TTYFLD:	MOVEI TT,[ASCIZ /
TTY UNAME  JNAME  CORE  TOTAL IDX
/]
	JSP B,MESPNT
	MOVSI Q,-NCT
TTYF1:	HRRE E,TTYSTS(Q)
	AOJE E,TTYF5	;JUMP IF NOT IN USE
	MOVE E,TTYSTS(Q)
	MOVEI I,"T	;TTY
	TLNN E,BCNSBT
	MOVEI I,"D	;"DEVICE"
	PUSHJ P,OUTC
	HRRZ TT,Q
	JSP B,G2OPT
	HRRZS E
TTYF11:	MOVEI J,UNAME(E)
	JSP B,SIXTYC
	MOVEI J,JNAME(E)
	JSP B,SIXTYC
	PUSHJ P,OUTCS
	MOVE TT,NMPGS(E)
	JSP B,G3DPT
	JSP B,MESP3S
	MOVEM E,DIRPT(A)
	MOVE E,UTMPTR(E)
	SETZB B,TT
TTYF3:	CAME E,UTMPTR(B)
	JRST TTYF4
	ADD TT,NMPGS(B)
	JUMPE Q,TTYF4
	SKIPGE SUPPRO(B)
	MOVE J,B
TTYF4:	ADDI B,LUBLK
	CAMGE B,USRHI
	JRST TTYF3
	SKIPE Q
	MOVEM J,DIRPT(A)
	JSP B,G3DPT
	JSP B,MESP3S
	MOVE TT,DIRPT(A)
	IDIVI TT,LUBLK
	JSP B,G2OPT
	JSP B,MESPCR
TTYF5:	JUMPE Q,TTYF99
	AOBJN Q,TTYF1
	SETZB E,TT
	SETZM I
TTYF7:	SKIPGE APRC(I)
	JRST TTYF9
TTYF13:	ADDI I,LUBLK
	CAMGE I,USRHI
	JRST TTYF7
	JUMPE E,TTYF99
	MOVEI TT,[ASCIZ /DSN/]
	JSP B,MESPNT
	SETZM Q
	JRST TTYF11

TTYF9:	CAML TT,NMPGS(I)
	JRST TTYF13
	MOVE E,I
	MOVE TT,NMPGS(E)
	JRST TTYF13

TTYF99:	MOVEI TT,[ASCIZ /FREE CORE  /]
	JSP B,MESPNT
	MOVE TT,MEMFR
	SUB TT,NCBCOM
	JSP B,G3DPT
	MOVEI TT,[ASCIZ / OUT /]
	JSP B,MESPNT
	MOVE TT,NPGSWO
	JSP B,G3DPT
	JRST UCL7

SIXTYB:	AOS Q
SIXTYA:	PUSHJ P,OUTCS
	MOVEI I,440600+Q
	HRLM I,DIRPT(A)

SIXTYP:	ILDB I,DIRPT(A)
	ADDI I,40
	PUSHJ P,OUTC
	MOVE I,DIRPT(A)
	TLNE I,770000
	JRST SIXTYP
	JRST (B)

MESP3S:	SKIPA TT,[[ASCIZ /   /]]
MESPCR:	MOVEI TT,[ASCIZ /
/]
MESPNT:	HRLI TT,440700
	MOVEM TT,NUM(A)
	ILDB I,NUM(A)
	JUMPE I,(B)
	PUSHJ P,OUTC
	JRST .-3

OUTCS:	MOVEI I,40
OUTC:	MOVEM E,SAVE(A)
	MOVEM Q,SAVQ(A)
	MOVEM B,SAVB(A)
	POP P,DIRPC(A)
	POPJ P,

G2OPT:	IDIVI TT,8
	JRST G2DPT2

G3DPT:	IDIVI TT,100.
	MOVEM I,NUM(A)
	MOVEI I,"0(TT)
	PUSHJ P,OUTC
	MOVE TT,NUM(A)
G2DPT:	IDIVI TT,10.
G2DPT2:	MOVEM I,NUM(A)
	MOVEI I,"0(TT)
	PUSHJ P,OUTC
	MOVE I,NUM(A)
	ADDI I,"0
	PUSHJ P,OUTC
	JRST (B)

GDPT:	SETZM ENDT(A)
	MOVEM TT,NUM(A)
GDPT1:	PUSH P,Q
	MOVE Q,TT
	IDIVI TT,10.
	CAME TT,ENDT(A)
	JRST .-3
	MOVEM Q,ENDT(A)
	POP P,Q
	ADDI I,"0
	PUSHJ P,OUTC
	MOVE TT,NUM(A)
	CAME TT,ENDT(A)
	JRST GDPT1
	JRST (B)

DIRCHR:	MOVE E,SAVE(A)
	MOVE B,SAVB(A)
	MOVE Q,SAVQ(A)
	JRST @DIRPC(A)

BLKPNA:	MOVEI J,1(I)
	LSH J,-1
	JRST BLKPNT+1

BLKPNN:	LSH J,-1
BLKPNT:	MOVEI TT,0
	MOVEI I,56
BLKPN2:	MOVEI E,440500+I
	HRLM E,DIRPT(A)
BLKPN1:	ILDB E,DIRPT(A)
	CAIN E,37
	JRST BLKPN3
	CAMN E,J
	AOS TT
	HLRZ E,DIRPT(A)
	TRNE E,760000
	JRST BLKPN1
	AOJA I,BLKPN2
BLKPN3:	JUMPE J,GDPT
	MOVSI I,-23.
BLKPN4:	MOVE E,@DIRPT(A)
	AOS I
	CAMN J,@DIRPT(A)
	JUMPE E,BLKPNA
	AOBJN I,BLKPN4
	JRST GDPT

EBLK

IRPS A,,UDUSR DIRPC DIRPT NUM ENDT SAVB SAVQ UDSYSN UUDPP SAVE
A:	REPEAT NUDCH,-1
	TERMIN
UDCSW:	-1
	0

DSKLST:	BLOCK NUDCH	;0 LISTING UTAPE 1 NON-DIR DEVICE
				;2 CORE LINK 3 2311

BBLK

UASCCO:	MOVEI B,UBLKO+1
	JRST CHRKT2

CHRKT:	SKIPGE (B)
	JRST CHRKT2	;WRITING
	JRST CHRKT5	;READING

UASCII:	MOVEI B,UBLKI+1
CHRKT5:	SOSGE @1(B)
	JRST CHRKT1	;GET NEW BUFFER
	SKIPGE (B)
	JRST CHRKT2
	ILDB D,@(B)
	XCT 6(B)
	JRST CHRKT3	;EOF
	XCTR XW,[MOVEM D,(C)]
	POPJ P,

CHRKT2:	SOSGE @1(B)
	JRST CHRKT1
	JUMPL C,CHRKT7	;USED WHEN FILLING OUT BLOCK AT CLOSE
	XCTR XR,[MOVE D,(C)]	;GET CHAR. FROM USER
CHRKT8:	IDPB D,@(B)	;DEPOSIT IN BUFFER
	POPJ P,

CHRKT7:	TRNE C,777760
	JRST 4,.
	MOVE D,(C)	;GET CHAR. FROM AC
	JRST CHRKT8

CHRKT1:	PUSHJ P,@3(B)	;PATCH THIS BLOCK ONTO CHNL LIST
	SKIPL E,@1(B)
	JRST CHRKT6	;COME BACK TO LIFE (LAST BLOCK OF FILE WRITE OVER)
	SKIPE 5(B)
	XCT 5(B)
	PUSHJ P,UFLS
	PUSHJ P,@2(B)	;GOBBLE NEW BLOCK
CHRKT4:	JRST .-2
	HRRM TT,@(B)
	MOVEI E,440700
	HRLM E,@(B)
	MOVEI E,@4(B)
CHRKT6:	IMULI E,5
	MOVEM E,@1(B)
	JRST CHRKT

CHRKT3:	HRROI D,EOFCH
	XCTR XW,[MOVEM D,(C)]
	JRST 7(B)	;GO TO CLOSE ROUTINE
UTOCLR:	SKIPG MPRC(A)
	PUSHJ P,UTBWW
	MOVSI Q,(SETZ)
	IORM Q,UTTNO(A)
	MOVEI I,EOFCH
	MOVE C,[SETZ I]
UTOCR2:	SKIPG MPRC(A)
	JRST UTOCR3
	PUSHJ P,UASCCO
	JRST UTOCR2

UTOCR3:	PUSHJ P,UTBWW
	JRST UTOCL2

UTBGB:	LDB Q,[IOLO,,UTBFP(A)]
	CAIN Q,377
	JRST 4,.	;PNTRS OUT OF PHASE
	CAIN Q,376
	JRST UTBG1	;END OF FILE
	CONO PI,UTCOFF
	SKIPL UTRAC(A)
	SKIPGE IOBFT(Q)
	JRST UTBGB1
	LDB J,[IOLO,,IOBFT(Q)]
	HRRM J,UTBFP(A)
	MOVEI TT,(SETZ)
	CAIL J,376
	HRLM TT,UTBFP(A)
	CONO PI,UTCON
	SOS UTBFS(A)
UTBWG4:	MOVE J,TIME
	MOVEM J,UTLSTM(A)
	MOVEI J,-3
	DPB J,[IOLO,,IOBFT(Q)]
	LDB TT,[IOSA,,IOBFT(Q)]
	LSH TT,6
	HRLM Q,UTMBN(A)
	JRST POPJ1

UTBGB1:	CONO PI,UTCON
	SKIPL IOBFT(Q)
	SKIPGE UTRAC(A)
	PUSHJ P,UFLS
	JRST UTBGB

UDATAO:	HRRO I,40
	MOVE C,[SETZ I]

UBLKO:	JSP B,BLKT
	SETZ MPRP(A)
	MPRC(A)
	UTBWG
	UTBWW
	200
	TRNA


UTBWG:	MOVE Q,UTBFS(A)	;GET # BUFS IN CHNL
	IMUL Q,NUWCA	;SCALE TO # ACT UWRITE CHNLS
	CAIL Q,LUTWBF	;IF BEING TOO GREEDY WITH BLOCK LIST SPACE
	POPJ P,		;LOSE
	PUSH P,A
	PUSH P,B
	MOVE D,A
	HRRZ Q,UTBFP(D)
	CAIL Q,376
	JRST UTBWG1	;NO BUFS NOW RELOAD
	SKIPGE UTDBC(D)
	JRST POPBAJ	;CHNL IN ERR

UTBWG2:	HRRZ J,UTBFS(D)
	CAMG J,UPCHFS
	JRST UTBWG1
	PUSHJ P,TCALL
	JRST UIMRQ
	JRST POPBAJ
	PUSHJ P,TCALL
	JRST UTMGB
	JRST UTBWG2

UTBWG1:	HRRZ Q,UTTNO(D)
	SOSGE UMNFB(Q)
	JRST UTBWG5
	PUSHJ P,AOSSET
	UMNFB(Q)
	PUSHJ P,LSWTL	;WAIT FOR
	UDIRO(Q)	;DIR TO UNLOCK
	PUSH P,E	;SAVE E
	PUSHJ P,TCALL
	JRST IUTCONS
	JRST UTBWG6
	PUSH P,A	;SAVE A
	PUSH P,B
	PUSH P,C
	MOVE C,Q
	MOVE B,UDIRO(C)
	MOVEI E,0	;INDICATE ADVANCE TO UDIRAD
	PUSHJ P,UDOUT2	;ADV DIR PNTRS (SKIP LOCK CHECK IN UDIRAD)
	JRST 4,.	;SHOULDN'T GET HERE
	JRST UTPFUL	;NO ROOM FOR EXT
	PUSHJ P,LSWPOP	;UNLOCK DIR
	PUSHJ P,LSWDEL	;UNHACK UTFAOS
	POP P,C
	POP P,B
	POP P,Q		;GET BACK BUF #
	POP P,E		;RESTORE E
	POP P,B
	POP P,A
	AOS UTBFS(A)
	JRST UTBWG4

UTBWG5:	AOS UMNFB(Q)
	JRST IOCER9

UTBWG6:	PUSHJ P,LSWCLR	;UNLOCK DIR & ADJ BLK CNT
	POP P,E
	JRST POPBAJ

UTPFUL:	SUB P,[3,,3]
	MOVE A,1(P)		;GET BACK BUF #
	PUSHJ P,BRTN	;RETURN BUF
	JRST IOCER9	;BARF ABOUT TAPE FULL

UTBWW:	HLRE Q,UTMBN(A)
	JUMPL Q,CPOPJ
	PUSHJ P,LWAIT	;WAIT FOR
	SKIPN UTWBFS	;SPACE IN BLK LIST & GET PNTR
	MOVE J,UTWBFS	;(DO NOT COMBINE WITH PRECEDING INST)
	HRRZ H,(J)	;GET PNTR TO NEXT FREE WD
	MOVEM H,UTWBFS	;UPDATE FS PNTR
	CONO PI,UTCON	;TURN ON UTC NOW TO MINIMIZE OFF TIME EVEN THOUGH OFF AGAIN LATER
	HRRZ D,UTDBC(A)	;GET NEXT BLK #
	MOVSM D,(J)	;PUT IN NEW WD
	HLRZ D,UTBKNP(A)	;GET PNTR TO LAST WD IN LIST
	HRRM J,(D)	;STORE LINK IN END OF LIST
	HRLM J,UTBKNP(A)	;UPDATE END PNTR
	MOVEI J,377
	IORM J,IOBFT(Q)
	SKIPGE UTTNO(A)
	SOS IOBFT(Q)	;CHANGE TO EOF
	CONO PI,UTCOFF
	HLRE J,UTBFP(A)
	JUMPL J,UTBWW1
	DPB Q,[IOLO,,IOBFT(J)]

UTBWW2:	HRLM Q,UTBFP(A)
	CONO PI,UTCON
	HRROS UTMBN(A)
	POPJ P,

UTBWW1:	HRRM Q,UTBFP(A)
	JRST UTBWW2

UTOCL:	SKIPG MPRC(A)
	PUSHJ P,UTBWW	;MAKE SURE BUFFER WRITTEN OUT SINCE MAYBE GOT
			;PCLSRED FROM UTBWW DURING .IOT THAT JUST FILLED BUFFER
	MOVSI Q,(SETZ)
	IORM Q,UTTNO(A)
UTOCL1:	HRROI I,0
	SKIPG MPRC(A)
	JRST UTOCL2
	PUSHJ P,UDATAO+1
	JRST UTOCL1



UTOCL2:	PUSH P,R
	MOVE D,A
	SKIPE UTBFS(D)
	PUSHJ P,UFLS
	HRRZ C,UTTNO(D)
	PUSHJ P,LSWTL
	UDIRO(C)
	HRRZ Q,UTBFP(D)
	CAIL Q,376
	JRST UTOCL4	;NORMAL CLOSE
	MOVEI Q,BIOCERR	;ABORT WORKS
	IORM Q,PIRQC(U)
	MOVEI A,0
	HRROI B,(D)
	PUSHJ P,UDELETE
UTOCL5:	PUSHJ P,LSWPOP
	POP P,R
	SOS NUWCA	;DECR # ACT UWRITE CHNLS
	JRST UTOCL3

UTOCL4:	MOVE A,UTN1(D)
	MOVE B,UTN2(D)
	PUSHJ P,UDELETE
	LDB Q,[220500,,UTTNO(D)]
	LSH Q,1
	ADD Q,UDIRO(C)
	MOVE A,UTN1(D)
	MOVE B,UTN2(D)
	MOVEM A,-2(Q)
	MOVEM B,-1(Q)
	LDB Q,[220500,,UTTNO(D)]
	ADD Q,UDIRO(C)
	MOVEI A,1
	IORM A,133(Q)
	JRST UTOCL5


UTDEL1:	MOVE C,I	;DELETE
	SKIPE SRN3(U)
	JRST UTRN1	;RENAME
	PUSHJ P,UTSNMK
	JRST NCA
	PUSHJ P,UDELETE
	JUMPE TT,OPNL4
	JRST LSWPJ1


UTRN1:	JUMPE A,UTRN3	;RENAME OF OPEN FILE
	PUSHJ P,UTSNMK	;ALLOW RENAME OF OPEN FILE
	JRST NCA
	PUSHJ P,UTLOOK
	JUMPE B,OPNL14
	PUSH P,Q
	MOVE A,SRN3(U)
	MOVE B,SRN4(U)
	PUSHJ P,UTLOOK
	POP P,Q
	JUMPN B,OPNL13
	MOVE A,SRN3(U)
	MOVE B,SRN4(U)
	MOVEM A,0(Q)
	MOVEM B,1(Q)
UTRN4:	MOVSI A,100000
	IORM A,UDIRO(C)
	JRST LSWPJ1

UTRN3:	ADDI B,IOCHNM(U)
	HLRZ TT,(B)
	MOVE A,SRN3(U)
	MOVE B,SRN4(U)
	MOVEM A,UTN1(TT)
	MOVEM B,UTN2(TT)
	JRST UTRN4

UDELETE:	MOVEI TT,0	;TT=0 IF NOTHING DELETED + OTHERWISE
UDELA:	PUSHJ P,UTLOOK
	JUMPE B,CPOPJ	;TAPE NO IN C,FILE NAME IN A,B
	MOVEI E,NUTIC-1
UDELE4:	HRRZ J,UTTNO(E)
	SKIPL UTUSR(E)
	CAME J,C
	JRST UDELE3
	HLRZ J,UTTNO(E)
	CAME J,A
	JRST UDELE3
	MOVSI J,10000
	TDNE J,UTDBC(E)
	JRST UDELE3	;THIS IS LOSER WHO IS CLOSING FILE
	IORM J,UTDBC(E)
	CLEARM (Q)
	SETOM 1(Q)
	AOJA TT,CPOPJ

UDELE3:	SOJGE E,UDELE4
UDELE1:	CLEARM (Q)
	CLEARM 1(Q)
	MOVE J,A
	ADD J,UDIRO(C)
	MOVEI B,1
	ANDCAM B,133(J)
	MOVSI J,100000
	IORM J,UDIRO(C)
UDELE6:	HRRZ B,UDIRO(C)
	ADD B,[500,,23.*2-1]
	MOVEI J,0
UDELE2:	ILDB E,B
	CAMN E,A
	AOS UMNFB(C)
	CAMN E,A
	DPB J,B
	CAIE E,37
	JRST UDELE2
	MOVE B,A
	MOVEI A,0
	AOJA TT,UDELA


UTBG1:	POP P,D	;CLOSE
	HRRZS D
	CAIN D,CHRKT4
	JRST CHRKT3	;CHAR AT A TIME
	JUMPL C,UTBG1A
	XCTR XRW,[CAME E,(C)]	;SKIP ON HAVE NOT XFERRED ANY DATA THIS CALL
	POPJ P,		;RETURN WITH AOBJN PNTR
UTBG1B:	XCT 7(B)
UTICL:	PUSH P,R
	MOVE D,A
	MOVSI C,200000
	IORM C,UTRAC(D)	;SET EOF
	MOVEI T,400000
	TDNN T,UTRAC(D)
	PUSHJ P,UFLS	;WAIT FOR ACTIVE BUFFER TO TRANSFER
	PUSHJ P,UTBRB1	;RETURN ACTIVE BUFFER MAIN PROG
	HLRZ A,UTTNO(D)
	MOVE B,UTDBC(D)
	TLNE B,10000
	PUSHJ P,UDELE5	;FINISH FILE DELETE
	POP P,R
UTOCL3:	HRRZ A,UTBFP(D)
UTICL2:	CAIL A,376
	JRST UTICL3
	LDB C,[IOLO,,IOBFT(A)]
	PUSHJ P,BRTN
	MOVE A,C
	JRST UTICL2

UTBG1A:	;ATTEMPT TO READ PAST EOF WORD AT A TIME
	PUSH P,[IOCER8]
	JRST UTBG1B

UTICL3:	PUSHJ P,UCPAT0	;UT CHANNEL PATCH OUT
	CLEARM UTDIRP(D)
	SETOM UTUSR(D)
	CLEARM (R)
	POPJ P,



UCPAT0:	HRRZ B,UTTNO(D)	;PATCH OUT CHANNEL
	MOVEI C,DCHNT-UTUL(B)
	CONO PI,UTCOFF
UCPAT2:	HRRE E,UTUL(C)
	JUMPL E,UTCOP
	CAMN E,D
	JRST UCPAT1
	MOVE C,E
	JRST UCPAT2

UCPAT1:	HRRZ E,UTUL(E)
	HRRM E,UTUL(C)
	SOS NUTCA
UTCOP:	JRST UTCONJ

UDELE5:	HRRZ C,UTTNO(D)
	PUSHJ P,LSWTL
	UDIRO(C)
	HLRZ Q,UTTNO(D)
	MOVE A,Q
	LSH Q,1
	ADD Q,UDIRO(C)
	SUBI Q,2
	PUSHJ P,UDELE1
	JRST LSWPOP

UTBRB1:	MOVE A,D
UTBRB:	PUSH P,A
	HLRE A,UTMBN(A)
	JUMPL A,POPAJ
	PUSHJ P,BRTN
	POP P,A
	HRROS UTMBN(A)
	POPJ P,

IUTCONS:		;ALLOCATE 200 WORD BUFFER
IUTCO1:	PI2SAF
	SKIPG UTTBF	;CLOBBERS A B E TT, RETURNS IOBFT INDEX IN A
	JRST IUTC1	;NO UTAPE BUFFERS FREE
	MOVEI E,UTFS-IOBFT
	MOVE A,UTFS	;CHNL NO IN D
IUTC3:	CAIN A,377
	JRST IUTC1
	LDB B,[420200,,IOBFT(A)]
	JUMPN B,IUTC2
	LDB B,[IOLO,,IOBFT(A)]
	DPB B,[IOLO,,IOBFT(E)]
	DPB D,[IOCH,,IOBFT(A)]
	SOS UTTBF
	JRST POPJ1

IUTC2:	MOVE E,A
	LDB A,[IOLO,,IOBFT(A)]
	JRST IUTC3

IUTC1:	PUSHJ P,UIMRQ
	POPJ P,
	PUSHJ P,UTMGB
	JRST IUTCO1

IBRTN:	PI2SAF
	PUSH P,B	;FREE 200 WORD BUFFER (SEE BRTN)
	MOVE B,UTFS
	DPB B,[IOLO,,IOBFT(A)]
	MOVEM A,UTFS
	MOVEI B,77
	DPB B,[IOCH,,IOBFT(A)]
	LDB B,[IOSA,,IOBFT(A)]
	SKIPN B
	JRST 4,.
	AOS UTTBF
	JRST POPBJ



UTMGB:	PUSH P,J
	PUSH P,R
	PUSH P,Q
	MOVEI B,MUIOB	;GOBBLE MEM BLK IN A FOR UTAPE BUFFER
	DPB B,[MUR,,MEMBLT(A)]
	MOVE J,A
	LSH A,10.-6.	;CONV TO BUF SA
	MOVE TT,A	;INCR TO NEXT BUF ADR
	MOVEI R,8
	ADDM R,UTTLB	;UTTBF AOSED AT IBRTN
	MOVNI Q,1
UTMG1:	PUSHJ P,IOBCNS
	DPB TT,[IOSA,,IOBFT(A)]
	JUMPL Q,UTMG2
	DPB A,[IOLC,,IOBFT(Q)]
UTMG3:	MOVE Q,A
	PUSHJ P,IBRTN
	ADDI TT,2
	SOJG R,UTMG1
	MOVEI TT,377
	DPB TT,[IOLC,,IOBFT(A)]
	POP P,Q
	POP P,R
	POP P,J
FSCMP:	MOVE A,UTTLB
	IDIV A,NUTCA
	MOVEM A,UPCHFS
	POPJ P,

BRTN:	CONO PI,UTCOFF
	PUSHJ P,IBRTN
	JRST UTCONJ

UTMG2:	DPB A,[MLO,,MEMBLT(J)]
	JRST UTMG3

UTRL1:	JUMPE B,UTRLDR
	HRRZ B,UTBFP(D)
	CAIE B,377
	JRST JDB6C
UTRLDR:	LDB R,[270100,,UTDBC(D)]
	JUMPN R,UTRLD1
	SKIPL R,UDIRO(C)	;SPECIAL KLUDGE TO RUN FAST
	TLNE R,10000	;SKIPN ON NOT IN UBLAT MODE
	JRST UTRLD1
	LDB TT,[220500,,UTDBC(D)]
	ILDB B,UTDIRP(D)
	AOS UTDBC(D)
	CAME B,TT
	JRST UTRLD2
UTRLD3:	PUSHJ P,IUTCONS	;RTN BUFFER NO IN A
	JRST UTRLR1	;MEM LOCKED (OR SOMETHING)
	CLEARM URDWR(C)
	HRRZ B,UTDBC(D)	;GET BLK # TO READ
	JRST UTRLD

UTRLD2:	CAIN B,37
	PUSHJ P,UAR

UTRLD1:	PUSHJ P,UDIRAD
	JRST JDB6C2	;DIR DOUBLE LOCKED
	JRST UTREOF
	JRST UTRLD3


JDDTA:	HLRZ D,ULDCH(C)	;FINISHED DATA TRANS TAPE IN C GET CHNL NO
	CLEARM UTLDD(D)
	SETOM SMODE
IFE NEWDTP,	CONSZ DC,7
IFN NEWDTP,	CONSO DTS,100000
	JRST UDATER	;DC STILL ENABLED => ERROR
	SETOM UGOAL(C)
	CAIL D,NUTIC
	JRST JDDT1	;WRITE OR FILE DIRECTORY
	MOVE E,UTRAC(D)
	HLLOS UTRAC(D)
	MOVEI B,377
	IORM B,IOBFT(E)
	HLRE B,UTBFP(D)
	JUMPL B,JDDT5
	DPB E,[IOLO,,IOBFT(B)]
JDDT6:	HRLM E,UTBFP(D)
	AOS UTBFS(D)


JDDT2:	PUSHJ P,JDB6W
	JRST JDDT3	;SAME TAPE CAN RELOAD, DONT CHECK OTHERS
JDDT4:	HRRZS ULDCH(C)
IFE NEWDTP,	JRST JDB4A	;UNIT NOW IDLE STOP IT
IFN NEWDTP,[
	PUSHJ P,JDSTP
	JRST JDB3
]

JDDT1:	CAIL D,NUTIC+NUTOC
	JRST UDRDD3	;FILE DIR IN OR OUT
	HRRZ A,UTRAC(D)
	PUSHJ P,IBRTN
	HLLOS UTRAC(D)
	SOS UTBFS(D)
	JRST JDDT2


JDDT5:	HRRM E,UTBFP(D)
	JRST JDDT6
UTREOF:	MOVSI E,200000
	IORM E,UTRAC(D)
	HLRE E,UTBFP(D)
	SKIPL E
	SOSA IOBFT(E)	;TURN END OF LIST TO END OF FILE
	SOS UTBFP(D)
	AOS UTBFS(D)	;TO START MAIN PROG
	JRST JDB6C

JDB6W:	HRRE D,DCHNT(C)
	JUMPL D,JDB6W1	;NO CHANNELS ACTIVE
	CAIN D,200000
	JRST UDRDD	;READ FILE DIR
JDB6C1:	SKIPL E,UTRAC(D)
	TLNE E,300000
	JRST JDB6C2	;CHANNEL LOCKED
	CAIL D,NUTIC
	JRST JDB6A	;WRITE CHANNEL
	HRRZ B,UTFS
	CAIN B,377
	JRST JDB6E	;TRY TO GET MORE MEMORY
	MOVE B,UTBFS(D)
	SOJLE B,UTRL1	;RELOAD CHANNEL WITH ONE OR NO BUFFERS
	MOVE B,UTLSTM(D)
	SUB B,TIME
	CAMG B,[-300.]
	JRST JDB6C2	;NO RELOAD
JDB6F:	HRRZ B,UTBFS(D)	;NUMBER BUFS THIS CHANNEL HAS
	CAMGE B,UPCHFS
	JRST UTRLDR
JDB6E:	PUSHJ P,UIMRQ	;TRY TO GET MORE MEMORY (IO)
	JRST JDB6C2	;NOT AVAIL
	PUSHJ P,UTMGB	;ADD TO MEM ALLOC UTAPE
	JRST JDB6F

UTRLR1:	PUSHJ P,UDIRR	;BACK UP
	JRST 4,.
	JRST 4,.	;LOSSAGE
JDB6C2:
JDB6C:	HRRE D,UTUL(D)
	JUMPGE D,JDB6C1
	JRST POPJ1

JDB6W1:	LDB D,[410300,,UDIRO(C)]
	SOJN D,POPJ1	;DIR CHANGED AND NOT LOCKED
	HRRZ D,UDIRO(C)
	LDB D,[370500,,177(D)]
	CAIE D,37
	JRST 4,.	;DIRECTORY CLOBBERED SINCE READ IN
	MOVEI D,100	;INITIATE FILE DIR WRITE
	SKIPL ULDCH(C)	;SKIPN ON ALREADY LOW PRIORITY POSIT
	PUSHJ P,ILLP	;INITIATE  LOW PRIOR POSIT
	JRST POPJ1

ULLP1:	SKIPGE UDIRO(C)
	POPJ P,
	SETOM URDWR(C)	;SET FILE DIR WRITE CYCLE FROM LOW PRIORITY CYCLE
	MOVSI D,400000	;LOCK DIR
	IORM D,UDIRO(C)
	MOVEI D,NUTIC+NUTOC
	HRRZ A,ULDCH(C)	;BUFFER NO OF DIRECTORY
	JRST JDB6W2


JDB6A:	HRRZ A,UTBFP(D)
	CAIGE A,376
	SKIPGE IOBFT(A)
	JRST JDB6C2	;LOCKED OUT SNIFFLE
	MOVE E,UTBKNP(D)	;GET BLK LIST PNTR
	MOVE J,UTWBFS
	EXCH J,(E)
	HRRZM E,UTWBFS
	HLRZ B,J	;GET BLK # FROM HEAD OF LIST
	HRR E,J		;SET LINK TO NEXT WD IN LIST
	TRNN E,-1	;IF LIST EMPTY
	MOVSI E,UTBKNP(D)	;SET END PNTR TO PNTR SO NEXT LINK WILL GO HERE
	MOVEM E,UTBKNP(D)	;UPDATE PNTR
	SETOM URDWR(C)
	HRRZ A,UTBFP(D)
	LDB E,[IOLO,,IOBFT(A)]
	HRRM E,UTBFP(D)
	MOVEI J,(SETZ)
	CAIL E,376
	HRLM J,UTBFP(D)

UTRLD:	HRRM A,UTRAC(D)
UDRR2:	MOVEM B,UGOAL(C)
	MOVEI B,-4
	DPB B,[IOLO,,IOBFT(A)]
	LDB B,[IOSA,,IOBFT(A)]
	LSH B,6
	SOS B
	HRRM B,UMEMAD(C)
	HRLM D,ULDCH(C)
	MOVE B,TIME
	MOVEM B,DRTM(C)
	POPJ P,

JDB6:	PUSHJ P,JDB6W
	JRST JDBRK7	;SUCCESFUL RELOAD
	SKIPL ULDCH(C)
IFE NEWDTP,[
	JRST JDBRK4	;CAN NOT RELOAD
	JRST JDF2A
]
IFN NEWDTP,[
	JRST JDBRK6
	JRST JDS1
]

UDRDD:	MOVE D,UDIRO(C)	;TAPE WANTS FILE DIRECTORY READ
	TLO D,20000	;OK FOR 4.5 CLEAR
	AOSE D	;REST SHOULD BE -1
	JRST 4,.	;FILE DIRECTORY READ REQUEST WHEN ALREAD IN
	MOVEI D,NUTIC+NUTOC	;GET DIRECTORY CHANNEL NUMBER IN D
	PUSHJ P,IUTCONS
	JRST UDRDD1	;NO MEM
	LDB B,[IOSA,,IOBFT(A)]	;GET ORIGIN _ -6
	LSH B,6
	TLO B,600000	;SET LOCK, DOUBLE LOCK BITS
	MOVEM B,UDIRO(C)	;STORE ORIGIN
	HLLOS DCHNT(C)	;NO CHANNEL ACTIVE THIS UNIT YET
	CLEARM URDWR(C)	;SIGNAL WANT READ
	HRRM A,ULDCH(C)	;STORE BUFFER NUMBER
JDB6W2:	MOVEI B,100	;DIRECTORY BLOCK NUMBER
	JRST UDRR2

UDRDD1:	SETOM MEMDSP	;SCROUNGE SOME MEM
	JRST POPJ1

UDRDD3:	HRRZ D,ULDCH(C)	;FILE DIR IN OR OUT
	HRRZS UDIRO(C)	;UNLOCK DIRECTORY
	DPB C,[IOLO,,IOBFT(D)]
	HRRZS ULDCH(C)
	JRST JDDT2
UDIRAD:	TDZA E,E	;ADVANCE DIR PNTRS OF CHANNEL IN D
UDIRR:	MOVEI E,1	;REV DIR PNTRS THIS WINS FOR READS ONLY HA HA
	SKIPGE B,UDIRO(C)
	JRST UDOUT3
UDOUT2:	TLNE B,10000
	JRST UDBL1	;UBLAT MODE
UDOUT7:	LDB R,[270100,,UTDBC(D)]
	XOR R,E
	MOVEI Q,0
	CAIL D,NUTIC
	MOVEI Q,UTBLKS
	LDB TT,[220500,,UTDBC(D)]

UDIR1:	PUSHJ P,UITAB(R)
	TRNE J,-1	;BLK NO RTN IN RH J
	CAIN B,37
	JRST UDOUT	;END OF EXTENSION
	CAME B,TT
	SOJA Q,UDIR1
	SOJG Q,.-1
	LDB B,[300500,,UTDBC(D)]
	DPB B,UTDIRP(D)
UDARET:	JRST POPJ2

UDBL1:	AOS A,UTDBC(D)
	CAILE A,1101
	JRST POPJ1	;EOF
	JRST POPJ2

UDOUT:	JUMPN E,UDOUT5
	CAIL D,NUTIC
	JRST UDOUT1
	MOVEI A,0	;READ
	MOVE B,TT
	PUSHJ P,UTLOOK	;TAP NO IN C NAME IN A,B
	JUMPE B,POPJ1	;EOF OR ADR OF FIRST WD
UDOUT6:	DPB A,[220500,,UTDBC(D)]	;FILE NO
UDOUT4:	DPB A,[300500,,UTDBC(D)]
	MOVSI A,1_5
	XORM A,UTDBC(D)
	JRST UDOUT7


UDOUT3:	TLNN B,200000	;DIRECTORY DOUBLE LOCKED
	CAIL D,NUTIC
	POPJ P,
	JRST UDOUT2

UDOUT1:	SETZB A,B
	PUSHJ P,UTLOOK
	JUMPE B,UDOUT8	; FILE DIR FULL
	LDB J,[300500,,UTDBC(D)]
	MOVEM J,1(B)
	JRST UDOUT4

UDOUT8:	XORI R,1	;REVERSE DIR
	AOS (P)	;SKIPN ONCE
	JRST UITAB(R)	;BACK UP PNTRS AND RETURN

UDOUT5:	LDB A,[220500,,UTDBC(D)]
	LSH A,1
	ADD A,UDIRO(C)
	SKIPE -2(A)
	JRST UDARET
	MOVE A,-1(A)
	JRST UDOUT6

UTLK3:	SKIPA Q,UDIRO(I)
UTLOOK:	MOVE Q,UDIRO(C)	;B=0 => NOT FOUND
	HRLI Q,-23.
	PUSH P,[1]
UTLK2:	CAMN A,(Q)
	CAME B,1(Q)
	AOJA Q,UTLK1
	MOVE B,Q
	JRST POPAJ

UTLK1:	AOS(P)
	AOBJN Q,UTLK2
	MOVEI B,0
	JRST POPAJ

UITAB:	AOSA J,UTDBC(D)
	JRST UAR

UAF:	ILDB B,UTDIRP(D)
	POPJ P,

UAR:	MOVSI B,50000
	ADD B,UTDIRP(D)
	SKIPGE B
	SUB B,[430000,,1]
	MOVEM B,UTDIRP(D)
	LDB B,B
	SOS J,UTDBC(D)
	POPJ P,

EBLK
IFN NEWDTP,	.INSRT DSK: MLSYS;ITSUTP >
IFE NEWDTP,[

; T S UTAPE ROUTINES PI SERV

JDENB==40000	;ENABLE JOB DONE (CONO UTC,)
20MSEN==5000	;20MS, ENABLED (")

TAPE:	0
UTP1:	0	;DATAI DC, OR JRST UTP3

BBLK

	SOS .-1
	AOSGE TAPCNT
	JRST 12,@TAPE


UTP3:	SKIPN WRITE
	CONO DC,0
	CONO DC,400000	;CLEAR PIA
	JRST 12,@TAPE

PIPOS:	CONSO DC,1000
	JRST PIPX
	SKIPN C,SUNIT
	JRST PIPOS8	;NO UNIT SELECTED?
	DATAI DC,B	;UNIT SELECTED, GET BLOCK NUMBER
	TDZE B,[1777#-1]	;CLEAR OUT GARBAGE IN BLOCK NUMBER WORD
	JRST PIPOS7	;GARBAGE THERE, BAD BLOCK NUMBER
	MOVEM B,EUPOS(C)	;STORE POSITION
	HRRZM C,DG2(C)	;SIGNAL EUPOS IS ACCURATE
	SKIPGE UGOAL(C)	;GOING SOMEWHERE?
	JRST PIPF1	;NO
	SUB B,UGOAL(C)	;GET CURRENT - DESIRED
	JUMPE B,PIPOS2	;JUMP IF THERE
	ADD B,UDIR(C)
	MOVMM B,UTENB
	SKIPGE ULDCH(C)
	JRST PIPOS3
	JUMPN B,PIPOS3
PIPOSL:	MOVE A,SUNITL	;HOLD DC
	MOVE B,UDIR(C)
	XCT UTST(B)
	CONO DC,4010+UTCCHN
PIPOS5:	JRST PIPX

PIPOS7:	AOS BDBLKC
	JRST PIPOSL

EBLK

BDBLKC:	0

BBLK

PIPOS3:	MOVE A,UDIR(C)
	LSH A,2
	SUB B,A
	XOR B,UDIR(C)
	MOVE A,SUNITL
	JUMPG B,PIPOS4	;GOING WRONG DIR
PIPF2:	TRO A,JDENB	;ENB JD SO NEXT BREAK TO UTC ON BLOCK
PIPOS6:	MOVE B,TIME
	MOVEM B,ULCTM(C)
	ADD B,UTENB
	MOVEM B,DRTM(C)
	MOVE B,UDIR(C)
	XCT  UTST(B)
PIPOS8:	CONO DC,0
	JRST PIPOS5



PIPF1:	MOVE A,SUNITL
	JRST PIPF2

PIPOS4:	CLEARM DG2(C)
	MOVNS UDIR(C)
	TRO A,6000
	JRST PIPOS6

PIPOS2:	HLRZ A,ULDCH(C)	;TAPE NOW POSITIONED
	SKIPL ULDCH(C)
	SKIPGE UTRAC(A)
	JRST PIPOS3	;CHANNEL LOCKED
	SETOM UTLDD(A)	;CHANNEL ACTUALLY LOADED TRANSFER IMMINENT
	AOS SMODE
	MOVE A,SUNITL
	MOVE B,UMEMAD(C)
	SKIPGE URDWR(C)
	TROA A,400
	TLZ B,(BLKO-BLKI)
	SKIPL UDIR(C)
	JRST TAPFOR
	TRO A,10000
	ADD B,[DATAI-BLKI 200]
	MOVEM B,UTP1
	MOVNI B,200
	MOVEM B,TAPCNT


TAP4:	CONO UTC,360300+UTCCHN(A)
	MOVE B,URDWR(C)
	MOVEM B,WRITE
	CONO DC,400000+DCCHN	;GIVE CHN FOR READ
	SKIPGE B
	CONO DC,3410+DCCHN
	JRST PIPX


TAPFOR:	HRRM B,TAPCNT
	HRRI B,TAPCNT
	MOVEM B,DCMLOC
	MOVE B,[-200,,UTP3]
	HRRM B,UTP1
	HLLM B,TAPCNT
	JRST TAP4

UTERR:	CONSZ UTC,4000	;CHECK TIME ENABLE
	CONSO UTS,20	;CHECK TIME FLAG
	JRST .+2
	JRST UTCB1	;ELIMINATE TIMING ERROR IF FLAG COMES ON
	CONI UTS,E
	SKIPL SMODE
	JRST UDATER	;DATA ERROR
	CONO DC,0
	SKIPN C,SUNIT
	JRST JDB3	;NO UNIT SELECTED, IGNORE ERROR
	SETOM DG2(C)
	SKIPL UFLAPF(C)
	JRST UTER6	;NOT FLAPPING
	CLEARM UFLAPF(C)	;ERROR WHILE FLAPPING, JUST FORGET ABOUT IT
	CLEARM EUPOS(C)
	CLEARM UDIR(C)
	JRST JDB3
UTER6:	AOS UTERP(C)	;INCREMENT ERROR COUNT
	HRLM E,UTERP(C)	;STORE UTS CONI
	MOVE B,UDIR(C)
	TRZ E,7650	;CLEAR RANDOMNESS, WRITE, PARITY ERROR
	JUMPE E,JDB3	;JUMP ON ONLY PARITY ERROR (IF ANYTHING), TRY AGAIN NOW
	TRNN E,2	;CHECK EOT FLAG
	JRST UTER1	;NOT SET
	MOVNS B,UDIR(C)	;EOT, WANT TO GO OTHER DIRECTION
	MOVEI A,0
	SKIPGE B
	MOVEI A,1103
	MOVEM A,EUPOS(C)	;STORE NEW ESTIMATED POSIION
	MOVE A,TIME
	MOVEM A,ULCTM(C)
	MOVEM A,DRTM(C)
UTER1:	JRST UTER3	;GIVE MAX DELAY

UDATER:	SETOM SMODE	;DATA ERROR, TRY REPOSITIONING
	HLRZ D,ULDCH(C)
	CLEARM UTLDD(D)
	JRST JDB3

UTCB0:	MOVE C,SUNIT
	CONSZ UTC,4000
	CONSO UTS,20
	JRST JDBRK	;NOT TIME FLAG
UTCB1:	MOVE A,SUNITL
	MOVE B,UDIR(C)
	AOSN UTHERR	;HANG UP ERROR SENT FOR SLOW CLOCK ROUTINE
	JRST UTERR
	AOSN USTSW
	JRST DCGBL1
	AOSN USTPF
	JRST JDB7D
	MOVEI C,0
	EXCH C,FLPUNT
	JUMPN C,JDF8
	EXCH C,STPUNT
	JUMPN C,JDB4B
	JRST JDB3


JDDT3:	MOVE A,EUPOS(C)
	SUB A,UGOAL(C)
	MOVMS E,A
	ADD A,TIME
	MOVEM A,DRTM(C)
	MOVE C,[-NUNITS,,1]
	MOVM B,DRTM(C)
	CAMGE B,TIME
	JRST JDB3	;SOMETHING ELSE DUE
	AOBJN C,.-3
	MOVE C,SUNIT
	MOVE B,UDIR(C)
	MOVE A,SUNITL
	SOJLE E,DCGBL1	;RELOADING FOR NEXT BLOCK
	JRST JDB3


ILLP:	MOVEM D,UGOAL(C)	;LOW PRIORITY POSIT ENTRY
	MOVSI A,(SETZ)
	IORM A,ULDCH(C)

UTDC:	SKIPGE UGOAL(C)
	POPJ P,	;UNIT IDLE
	SKIPGE DG2(C)
	JRST UTDC3
	MOVE A,EUPOS(C)	;ESTIMATE UNIT TIME AND UPDATE EUPOS
	SKIPG DG2(C)	;SKIP ON EXACT POS KNOWN
	SKIPN UDIR(C)	;SKIP ON UNIT RUNNING
	JRST UTDC4
	MOVE B,TIME
	SUBM B,ULCTM(C)
	EXCH B,ULCTM(C)
	IMUL B,UDIR(C)
	ADD A,B	;ACTUAL ESTIMATED POSITION
	MOVEM A,EUPOS(C)	;UPDATE EUPOS
UTDC4:	SUB A,UGOAL(C)
	MOVM B,A
	CAIG B,2
	JRST UTDC2
	ADD A,UDIR(C)
	MOVMS A	
	CAMLE A,B
	SETZB A,B	;GOING WRONG DIR
UTDC2:	CAILE B,200.
	MOVEI B,200.	;LIMIT LONGEST DEAD RECKON
	ADD B,TIME
	MOVEM B,DRTM(C)
	POPJ P,

UTDC3:	MOVEI B,0	;NOT KNOWN EXACT POS REQUIRES IMMEDIATE ATTENTION
	JRST UTDC2

JDBRK:	CONSZ UTS,16	;CHECK PARITY ERROR, ILLOP, EOT
	JRST UTERR
JDBK1:	CONSZ UTS,1	;SKIP ON NO JOB DONE
	CONSZ DC,7
	JRST POPRET	;NO ERRS + HAS DC CHNL, GO AWAY
	SKIPL SMODE
	JRST JDDTA	;DATA MODE
	JUMPE C,JDB3	;POSITIONING, JUMP ON NO UNIT SELECTED
	MOVE A,UDIR(C)
	ADDM A,EUPOS(C)
	MOVE A,TIME
	MOVEM A,ULCTM(C)
	PUSHJ P,UTDC	;COMPUTE DELAY

JDB3:	CONO DC,0
	HRLOI B,177777
	MOVEM B,UTTM2
	SETOM UTTM3	;UNIT MOST URGENT
	CLEARM UTTM1	;UNIT COULD START
	SETOM UTTM4	;TAPE TO START FLAPPING
	SETOM UTTM5	;TAPE TO STOP FLAPPED
	MOVE C,[-NUNITS,,1]
JDBRK7:	SKIPGE B,UFLAPF(C)
	JRST JDF1	;FLAPPING OP
JDF2:	SKIPL ULDCH(C)	;SKIP ON LOW PRIOR POSIT
	SKIPGE UGOAL(C)
	JRST JDB6	;UNIT FREE
JDF2A:	SKIPGE DG2(C)
	SKIPN UDIR(C)
	JRST JDS1
	MOVEM C,UTTM1	;UNIT IS RUNNING BLIND (OR NOT RUNNING)
	JRST JDBRK6
JDS1:	SKIPE UDIR(C)
	JRST JDBRK4
	SKIPN UTTM1
	HRRZM C,UTTM1
	JRST JDBRK6
JDBRK4:	SKIPN UDIR(C)
	JRST ULLP	;TAPE MAY NOT BE RUNNING IF IDLE
	MOVE B,DRTM(C)
	SUB B,TIME
	MOVE E,B
	SUB E,UTTM2
	JUMPL B,JDCV1	;ALREADY OVERDUE
	MOVM D,E
	CAIG B,20.	;CONFLICT MORE THAN 20 BLKS AWAY
	CAIL D,20.	;THEY ARE SEPARETED BY 20 BLKS
	JRST JDCV1
	HRRZS C	;RELIEVE CONFLICT BY STOPPING UNIT DUE LATEST
	CAMG B,UTTM2
	HRRZ C,UTTM3
JDF5:	CAME C,SUNIT
	SKIPN SUNIT
	JRST JDB4B	;STOP UNIT
	MOVEM C,STPUNT
	JRST JDB7D	;DESLECT FIRST
JDCV1:	JUMPGE E,ULLP
	MOVEM B,UTTM2
	HRRZM C,UTTM3
ULLP:	SKIPL ULDCH(C)
	JRST JDBRK6
	MOVE B,TIME
	SUB B,ULCTM(C)
	IMUL B,UDIR(C)
	SKIPE DG2(C)
	MOVEI B,0
	ADD B,EUPOS(C)
	SUB B,UGOAL(C)
	MOVMS B
	CAIGE B,10.
	PUSHJ P,ULLP1	;TERM LOW PRIORITY DIRECTORY POS (COMMIT TO ACTUAL WRITE)



JDBRK6:	AOBJN C,JDBRK7
	MOVE C,UTTM3	;MOST PRESSING RUNNING UNIT
	MOVE B,UTTM2
	CAIGE B,30.
	JRST JDB7	;STAY WITH PRESSING UNIT
	SKIPE UTTM1
	JRST JDB5	;START UNIT IF POSSIBLE
	SKIPL D,UTTM4
	JRST JDF3
JDF6A:	SKIPL D,UTTM5
	JRST JDF4
	CAMG B,[10000000.]	;SKIP ON ALL TAPES IDLE
	JRST JDB7
	SKIPE SUNIT
	JRST JDB7D
	SETOM UIDLE	;NO UNIT SELECTED
	CONO UTC,0
	JRST POPRET

JDF1:	MOVE E,UDIRO(C)
	AOJE E,JDF1A
	TLNE E,100000
	JRST JDF2	;DONT FLAP IF DIR NOT WRITTEN
JDF1A:	SKIPGE UGOAL(C)
	SKIPGE ULDCH(C)
	JRST JDF2	;FILE DIR WRITE IN PROG
	SKIPE UDIR(C)
	SKIPG DG2(C)
	JRST .+2
	JRST JDF3A	;JUST READ IN TAPE POS
	TLNN B,100000
	HRRZM C,UTTM4	;UNIT TO START FLAPPING
	LDB D,[4100,,B]
	TLNN B,100000
	JRST JDBRK6
	TLNN B,200000	;ABORT FLAPPING
	CAMG D,TIME
	HRRZM C,UTTM5	;UNIT TO STOP FLAPPING
	JRST JDBRK6


JDF3:	MOVE C,D
	MOVE A,UDIRO(C)
	AOJE A,JDF3A1
	TLNE A,10000
	JRST JDF3A2
	HRRZ A,ULDCH(C)
	LDB Q,[IOCH,,IOBFT(A)]
	CAIE Q,NUTIC+NUTOC
	JRST 4,.
	LDB Q,[IOLO,,IOBFT(A)]
	CAIE Q,(C)
	JRST 4,.
	PUSHJ P,IBRTN
JDF3A2:	SETOM UDIRO(C)
	SETZM UTASS(C)
JDF3A1:	SETOM UDPWF(C)
	SKIPGE DG2(C)
	JRST JDF6
JDF3A:	SETOM DG2(C)
	MOVE E,EUPOS(C)
	IMULI E,50.
	IDIVI E,33.
	ADDI E,30.
	ADD E,TIME
	DPB E,[4100,,UFLAPF(C)]
	MOVSI E,100000
	IORM E,UFLAPF(C)
	SKIPE SUNIT
	CAMN C,SUNIT
	JRST JDF8
	MOVEM C,FLPUNT
	JRST JDB7D

JDF8:	LSH C,3
	CONO UTC,235000+UTCCHN(C)
	JRST JDF9

JDF6:	SKIPE SUNIT
	CAMN C,SUNIT
	JRST .+2
	JRST JDB7D
	SETOB B,UDIR(C)
	MOVEM C,SUNIT
	DPB C,[30300,,SUNITL]
	JRST JDF6B

JDF4:	MOVE C,D
	CLEARM UFLAPF(C)
	CLEARM EUPOS(C)
	JRST JDF5

JDB5:	HRRZ C,UTTM1
JDB7:	EXCH C,SUNIT	;SELECT UNIT IN C
	JUMPE C,JDB7A	;NO UNIT SELECTED
	CAMN C,SUNIT
	JRST JDB7A
	PUSHJ P,URLS
	JUMPGE E,JDB7E	;OK TO LEAVE IT ALONE, CLEAR SELECTION CYCLE
	SKIPN UDIR(C)
	JRST JDB7E
JDB4B:	HRRZM C,SUNIT	;ENTER UNIT STOPPING CYCLE
	DPB C,[30300,,SUNITL]
JDB4A:	MOVE A,SUNITL
	SKIPG UDIR(C)
	TRO A,10000
	CONO UTC,205000+UTCCHN(A)	;CLEAR GO BIT
	SKIPE DG2(C)
	JRST JDB4A1
	MOVE B,TIME
	SUB B,ULCTM(C)
	IMUL B,UDIR(C)
	ADDM B,EUPOS(C)
JDB4A1:	CLEARM UDIR(C)
	HRLOI B,177777
	MOVEM B,DRTM(C)
	SETOM DG2(C)
JDF9:	SETOM USTPF	;UNIT STOPPING CYCLE
	JRST POPRET

EBLK

USTPF:	0
STPUNT:	0	;UNIT TO STOP DUE TO CONFLICT

BBLK

JDB7E:	SKIPA A,C
JDB7D:	MOVE A,SUNIT
	JUMPE A,JDB7D1
	SKIPLE DG2(A)
	CLEARM DG2(A)
JDB7D1:	CLEARM SUNIT	;DESELECT CYCLE
	CONI UTC,A
	TRZ A,200070
	TRO A,5000
	CONO UTC,(A)
	JRST POPRET


JDB7A:	MOVE C,SUNIT
	MOVE A,EUPOS(C)
	SUB A,UDIR(C)
	SUB A,UDIR(C)
	MOVEI B,1
	CAML A,UGOAL(C)
	MOVNI B,1
	DPB C,[30300,,SUNITL]
	MOVE D,UDIR(C)
	MOVEM B,UDIR(C)
	CAME D,B
	JRST JDS4	;CHANGING DIR (OR STARTING), ALLOW RELAY DLYS
JDBK3A:	MOVE E,DRTM(C)
	SUB E,TIME
JDDT8:	MOVE A,SUNITL
	SKIPL IMPXF
	SUBI E,2
	SKIPGE E
	MOVEI E,0
	SKIPL D,DG2(C)
	CAIG E,2
	JRST JDB3B
	CAIGE E,20
	JUMPE D,JDB3B	;GETTING CLOSE READ BLOCK NO
JDB3A:
DCGBL2:	TRO A,JDENB
JDB8A:	XCT UTST(B)
	JRST POPRET



JDB3B:
DCGBL1:	XCT UTST(B)
	MOVE C,[JSR TAPE]
	MOVEM C,DCMLOC
	MOVEM C,DCMLOC+1
	MOVE C,[JRST UTP1]
	MOVEM C,UTP1
	CONO DC,4010+UTCCHN
	JRST POPRET



	CONO UTC,330200+UTCCHN(A)
UTST:	CONO UTC,5000+UTCCHN(A)
	CONO UTC,320200+UTCCHN(A)


JDS4:	JUMPN D,UTER3
	MOVE D,TIME
	MOVEM D,ULCTM(C)
JDF6B:	SETOM USTSW	;STARTING OUT
UTER3:	MOVE A,SUNITL	;PICK UP UNIT SELECT FIELD OF CONO
	TRO A,6000	;SET FOR MAXIMUM DELAY
	JRST JDB8A

URLS:	SKIPE E,UDIR(C)	;SKIPN ON UNIT NOT RUNNING
	SKIPG E,DG2(C)	;RELEASE UNIT IN C E HAS PREV STATE OF DG2
	POPJ P,
	JRST UTDC
]

EBLK
UTCBRK:	0
BBLK
	MOVEM U,UTACS+U
	MOVEI U,UTACS
	BLT U,UTACS+U-1
	MOVE P,UTCPDP
IFE NEWDTP,[
	CONSZ DC,6
	JRST PIPOS	;HAS CHNL >1
PIPX:
]
IFN NEWDTP,[
	SKIPGE CUINT
	JRST UTCB0
]
IFN NETP,[
	CONI IMP,TT
	LDB A,[000300,,TT]
	CAIE A,NETCHN
	JRST UTCB2
	TRNE TT,IMPLW+IMPHER+IMPERR+IMPOD+IMPID
	JRST IMPINT
UTCB2:]
IFE DECDKC,[
	CONI DC0,TT
	TRNE TT,DPIRQC
	JRST QINT
]
IFN DECDKC,[
	CONI DPC,TT
	CONSZ DPC,7
	TDNN TT,[17,,377310]
	SKIPGE QGTBZY
	JRST QINT
]
IFN NMTCS,[MGBKCK:	MGBKCM	;MACRO TO CHECK FOR MAGTAPE BREAK
UTCBK2:	SKIPL MSCMDT	;ANY MAGTAPE ROUTINES WANT TO RUN ANYWAY?
	JRST MGSBRK	;YES
]
	JRST UTCB0


POPRET:	MOVE A,TIME
	MOVEM A,LUTOTM
DSKEX:
IFN NMTCS,[
	SKIPL MSCMDT	;ONE LAST CHECK FOR MAGTAPE WANTS TO RUN
	JRST MGSBRK
IFE C1MXP,[
MGMTCK:	SKIPGE DCFREE	;DC FREE?
	SKIPN MGDCW	;YES, MAG TAPE WANT IT?
	JRST MGEX	;NOT FREE OR NOT WANTED
	JRST MGDBRK	;WANTED AND FREE
]]
IMPEX:
MGEX:	MOVSI U,UTACS
	BLT U,U
	JRST 12,@UTCBRK


;FILE SYSTEM PARAMETERS

DADDNL==410300,,	;DISK ADDRESS DISK NUMBER FIELD BYTE ADDRESS LH
DADDNR==170300,,	;RH
DADTNL==221700,,	;TRACK NUMBER LH
DADTNR==001700,,	;RH
DTMSK==77777	;MASK FOR DISK TRACK

;PHYSICAL CHARACTERISTICS

NCYLS==200.	;# CYLINDERS NORMALLY USED
XCYLS==3	;# EXTRA CYLINDERS FOR SPARES, HACKS, ETC.
IFE DECDKC,[
NHEDS==20.	;# TRACKS/CYLINDER
NSECS==2	;# BLKS/TRK
NBLKSC==NHEDS*NSECS	;# BLKS/CYL
]

IFN DECDKC,[
	NHEDS==22.	;NOT REALLY BUT...
	NSECS==1
	NSSECS==9	;# HARDWARE SECTS /SOFTWARE BLOCK
	NHSECS==10.	;# HARDWARE SECTS /HARDWARE SURFACE
	NBLKSC==22.	;BLOCKS / CYL
]
NBLKS==NCYLS*NBLKSC	;TOTAL # REG BLKS
XBLKS==XCYLS*NBLKSC	;# XTRA BLKS

;EXTRA WORDS IN BLOCK

NXWDS==4	;# EXTRA WDS
XWBLK==1700,,	;BP TO PREV BLK # IN FILE FLD
XWAWC==171200,,	;BP TO ACTIVE WD CNT
XWSYSN==1
XWFN1==2
XWFN2==3

;MFD INFO

MFDBLK==NBLKS/2-1	;LOC ON DISK
	;RANDOM INFO
	MDNUM==0	;ASCENDING DIR NUM
	MDNAMP==1	;PNTR TO ORG OF NAME AREA
	MDYEAR==2	;CURRENT YEAR
	MPDOFF==3	;DE-CORIOLIS CLOCK OFFSET
	MPDWDK==4	;PREFERRED WRITING DISK (PHYSICAL DRIVE #)
	MDCHK==5	;THIS WORD MUST BE M.F.D. (FOR CHECKING)
	LMIBLK==6	;TOTAL STG USED BY HACKS LIKE THIS
	;USER NAME BLKS FROM C(MDNAMP) TO END
	LMNBLK==2	;# WDS/BLK
	MNUNAM==0	;6BIT USER NAME

;TUT INFO

TUTBLK==MFDBLK-1	;LOC ON DISK
TUTBYT==4	;SIZE OF BYTES
TUTBP==440400,,
TUTEPW==36./TUTBYT	;NUMBER OF ENTRIES PER WORD
TUTLN==<NBLKS-1>/TUTEPW+1	;NUMBER OF WORDS IN TUT
TUTLK==1_<TUTBYT>-1	;HIGHEST CODE MEANS LOCKED OUT
TUTMNY==TUTLK-1	;TUT MANY OR MORE REFS
QTUTP==1777	;FS POINTER TO TRACK AREA.  ADVANCE BY CYLINDERS
QPKNUM==1776	;PACK #
QPAKID==1775	;PACK ID
QSWAPA==1774	;SWAPPING AREA.  FIRST TRACK OF NON-SWAPPING AREA
LTIBLK==4	;STG FOR RANDOM INFO ^

;UFD INFO
;USER DIR IN TRACK NUMBERED SAME AS INDEX IN MFD (SEE QFL2)

NUDSL==200.	;# UFDS SPACE RESERVED
UFDBYT==6	;SIZE OF BYTES
UFDBPW==36./UFDBYT	;NUMBER OF BYTES PER WORD
	;RANDOM INFO

	UDESCP==0	;FS PNTR TO DESC AREA
	UDNAMP==1	;PNTR TO ORG OF NAME AREA
	UDNAME==2	;USER NAME (FOR CHECKING)
	UDDESC==11.	;FIRST LOC AVAIL FOR DESC

	;UFD DESCRIPTORS
	;0 => FREE  1-UDTKMX => TAKE NEXT N
	;UDTKMX+1 THRU UDWPH-1 => SKIP N-UDTKMX AND TAKE ONE
	;40 BIT SET => LOAD ADDRESS.  LOWER 5 BITS PLUS NEXT TWO CHARS (17 BITS IN ALL)

	;IF LINK DESCR
	;6 CHAR OR UNTIL ; = SYS NAME.  MUST HAVE NO CHAR = 0 IN THIS OR NEXT 2 NAMES
	;NEXT CHAR QUOTED BY : (FOR NAMES WITH : OR ;)
	;NEXT CHAR N1
	;NEXT CHAR N2
	;END BY 0

	UDTKMX==12.	;HIGHEST "TAKE N" CODE
	UDWPH==31.	;PLACE HOLDER ON WRITE (OR NULL FILE)
;	NXLBYT==2	;# ADDITIONAL BYTES FOR LOAD ADDR
			;ACTUAL PARAMETER ASSIGN MUST BE AT FRONT OF FILE

	;NAME AREA DATA

	LUNBLK==5	;WDS/NAME BLK
	UNFN1==0	;FIRST FN
	UNFN2==1	;SECOND FN
	UNRNDM==2	;ALL KINDS OF RANDOM INFO
		UNDSCP==1500,,	;PNTR TO DESC
		UNPKN==150500,,	;PACK #
		UNLINK==1	;LINK BIT
		UNLNKB==220100,,
		UNWRIT==4	;OPEN FOR WRITING
		UNMARK==10	;GC MARK BIT
		UNCDEL==20	;DEL WHEN CLOSED
		UNPDEL==40	;DEL FROM UNMOUNTED PACK
		UNDS1==100000	;HAS BEEN HALF DELETED AND HAS 1 STRIKE
		UNHD==200000	;HAS BEEN HALF DELETED
		DELBTS==UNCDEL+UNPDEL+UNHD	;DELETED -- IGNORE
		UNIGFL==DELBTS+UNWRIT	;BITS TO IGNORE FILE
		UNDBLK==301300,,	;BLK # DESC BLK (0 => NONE)
		UNDUMP==400000	;HAS BEEN DUMPED
	UNDATE==3	;DATE ETC.
		UNTIM==2200,,	;COMPACTED TIME OF CREATION
		UNYMD==221200,,	;Y,M,D OF CREATION
		UNREFT==341000,,	;DAYS AFTER CREATION LAST REFERENCED
		UNMON==270400,,	;MONTH
		UNDAY==220500,,	;DAY
		UNYRB==330100,,	;YEAR BIT

IF1 [
IFG NUDSL*LMNBLK+LMIBLK-2000,[PRINTX /MFD LOSES
/]
IFG NBLKS/<36./TUTBYT>+LTIBLK-2000,[PRINTX /TUT LOSES
/]
]
IFN DECDKC,	.INSRT DSK: MLSYS; MDSK >
IFE DECDKC,[
DC0==610	;MAIN DEVICE CODE
DC1==614	;READS ERR STATUS ETC, SETS TIMER DRIVER # ON CONO

;FIELDS IN HEADER WORD 0

DPKID==240700,,	;PACK ID FIELD
DCYL==131100,,	;CYLINDER CHECK FIELD
DSURF==60500,,	;SURFACE CHECK FIELD
DSECT==600,,	;SECTOR FIELD

;WORD 1 HEADER

DHIND==1000,,	;4.1 INDIRECT IF 1, CYL, SURF, SECTOR SAME AS ABOVE
DHSPRT==400,,	;BIT 3.9  SOFTWARE PROTECT
DHHPRT==200,,	;3.8 HARDWARE PROTECT
DHNXAD==270200,,	;3.7, 3.6 HOW TO COMPUTE NEXT DISK ADR
			;=00 ADD 1 TO SECTOR
			;01 SET SECTOR TO 0, ADD 1 TO SURF
			;10 SET SECTOR AND SURFACE TO 0, ADD 1 TO CYL
			;11 END OF DISK
DHEPB==10,,	;PARITY BIT FOR EVEN BITS OF 56 BIT HEADER
DHOPB==4,,	;PARITY BIT FOR ODD BITS OF 56 BIT HEADER
DHSLNG==1600,,	;-LENGTH OF SECTOR FIELD

;DISK ADDRESS DATA COMMANDS (OP CODES)

DRC==400000,,	;READ COMPARE
DWRITE==440000,,	;WRITE
DREAD==500000,,	;READ
DSEEK==540000,,	;SEEK
DRCC==600000,,	;READ COMPARE CONTINUOUS
DWRITC==640000,,	;WRITE CONTINUOUS
DREADC==700000,,	;READ CONTINUOUS

DUNENB==20000,,	;ENABLE LOAD UNIT FIELD
DUNFLD==330400,,	;UNIT FIELD
;PKID, CYL, SURF, AND SECTOR SAME AS ABOVE

;COPY / COMPARE / SKIP COMMAND

DCOPY==40000,,	;COPY
DCCOMP==100000,,	;COMPARE
DCSKIP==140000,,	;SKIP

DCWC==241400,,	;-WC FIELD
DCCA==2400,,	;CORE ADDRESS
DCBN==121200,,	;BLOCK NUMBER

;JUMP COMMANDS
DHLT==0	;0 IN 4.9-4.5 = JUMP AND IN 3.5,3.6 = HALT
DXCT==20,,	;XCT
DJMP==40,,	;JUMP
DJSR==60,,	;JSR

;"B" COMMAND BITS 3.3, 3.4
;0 ALWAYS
DAOJNC==4,,	;AOJN THE CONTROL COUNTER
DDOK==10,,	;ON NO DATA ERROR
DSRQF==14,,	;IF SEEK RQ FLAG ON

;STORE REGISTER COMMAND
DSREG==240400,,	;STORE REG
;USE, UNIT BITS SAME
DSREGS==240300,,	;SORCE REGISTER SELECT FIELD
DSRDB==0	;STORE DATA BUFFER
DSRDL==4,,	;STORE DISK LOCATION
DSRCC==10,,	;STORE COMMAND COUNT
DSRPC==24,,	;STORE PC (IN FORM OF JMP INST.)
DSRWC==30,,	;STORE WORD COUNT
DSRCA==34,,	;STORE CORE ADDRESS (TO XFER DATA TO OR FROM)

;ALU COMMAND
DALU==300000,,	;BASIC ALU OP CODE
DALUX==40000,,	;INDEX BIT (ADD CC TO ADR)
DALUD==40,,	;DIRECT BIT IF 1, REF MEM OT GET B OP

DASL==4000,,	;SKIP ON <0
DASE==10000,,	;SKIP ON = 0
DASLE==14000,,	;SKIP ON < OR = 0
DASA==20000,,	;ALWAYS SKIP
DASGE==24000,,	;SKIP ON > OR = 0
DASN==30000,,	;SKIP ON NOT = 0
DASG==34000,,	;SKIP ON > 0

;DESTINATION SUB OP (ALSO SPECIFIES SOURCE A)
DLDB==0	;OP A FROM DB, STORE IN DB
DLDL==4,,	;OP FROM DL, STORE IN DL
DLCC==10,,	;OP FROM CC, STORE IN CC
DLCA==14,,	;OP A =0, STORE IN CA
DLTDB==20,,	;TEST DB (OP A FROM DB, NO STORE)
DLDBPC==24,,	;OP A FROM DB, STORE IN PC
DLDBWC==30,,	;OP A FROM DB, STORE IN WC
DLDBM==34,,	;OP A FROM DB, STORE IN MEM (DIRECT MUST BE ONE TO REALLY MAKE IT)

;SOME USEFUL (?) OPS
DLADD==100,,	;A+B
DLSOS==200,,	;B-1
DLLB==300,,	;B
DLSUB==400,,	;B-A

DLAND==2300,,	;A&B
DLIOR==2500,,	;A IOR B
DLLA==3100,,	;LOAD A
DLSETO==3200,,	;-1
DLSETZ==3300,,	;0

;OPR COMMAND
DOPR==200000,,	;BASIC OPR
DOHXFR==400,,	;HALT DURING XFER (SO MB WILL BE SAFE)
DOCSRQ==200,,	;CLEAR SEEK RQ
DOSSRQ==100,,	;SET SEEK RQ
DOSCFL==40,,	;SET C FLAG

;STORE DRIVE STATUS
DSDRST==240000,,	;STORE DRIVE STATUS
;UNIT ENABLE, UNIT FIELD SAME
DSDCNT==240400,,	;COUNT-1 FIELD

;BITS IN DRIVE STATUS STORED

DDSWC==40,,	;WRITE CURRENT SENSED
DDSUNS==20,,	;DRIVE UNSAFE
DDSRDO==10,,	;READ ONLY
DDSSIC==4,,	;SEEK INCOMPLETE
DDSRDY==2,,	;DRIVE READY
DDSONL==1,,	;DRIVE ON LINE
DDSSEL==400000	;DRIVE SELECTED
DDSCYL==101000,,	;PRESENT CYLINDER
DDSLAT==1000,,	;LATENCY TIMER

;DISK ADR "SPECIAL COMMAND"

DSPC==740000,,	;BASIC OP CODE
;USE, UNIT FIELDS AS NORMAL

; E CONDITION (WAIT)
;0 NONE
DSWIDX==20,,	;WAIT UNTIL INDEX PULSE
DSWSEC==40,,	;WAIT UNTIL SECTOR PULSE
DSWINF==60,,	;NEVER (USE WITH G=3 OR 7)

; F CONDITION (OTHER WAIT)
DSWHDM==0	;WAIT FOR MATCHING HEADER
DSWAGH==4,,	;ANY GOOD HEADER
DSWAH==10,,	;ANY HEADER
DSWNUL==14,,	;NO WAIT

;G OPERATION
DSCRDC==0	;READ DATA THRU DECODERS
DSCRIM==100,,	;READ DATA IMAGE
DSCRHD==200,,	;READ HEADER WORDS
DSRCAL==300,,	;(RECALIBRATE)
DSCWDC==400,,	;WRITE THRU DECODERS
DSCWIM==500,,	;WRITE IMAGE
DSMAIT==700,,	;MAINTENANCE  (PUT CYL FIELD ON BUS LINES WITH CONTROL TAG)

;BITS IN CONI DC0,
DASSGN==400000,,	;ASSIGNED TO PROC (WITH SWITCH)
DPIRQC==400000	;PI REQ BEING GENERATED
DSSRQ==200000	;SEEK REQUEST
DSDEEB==10000	;ENABLE INTERRUPT ON DATA ERROR OR READ/ COMP ERROR
DSSERR==4000	;ERROR FLAG
DSSAEB==2000	;ATTENTION ENABLE FLAG
DSSATT==1000	;ATTENTION FLAG
DSIENB==400	;IDLE FLAG ENABLE
DSSRUN==200	;RUN
DSSACT==100	;ACTIVE
DSSCEB==40	;CHANNEL ENABLE
DSSCHF==20	;CHANNEL FLAG
DSSCFL==10	;CPU FLAG
;PIA 1.3-1.1

;DATAO DC0, SENDS COMMAND TO DISK
;  (IGNORED IF EXECUTING COMMANDS FROM MEMORY)

;CONO DC0, 
DCSET==400000	;SET SELECTED
DCCLR==200000	;CLEAR SELECTED
DCCSET==600000	;RESET CONTROLLER THEN SET SELECTED
DCDENB==10000	;DATA ERROR ENABLE
DCERR==4000	;SET ERROR FLAG OR CLEAR ALL ERRORS
DCATEB==2000	;ATTENTION ENABLE
DCCATT==1000	;CLEAR ATTENTION
DCSSRQ==1000	;SET SEEK REQUEST
DCIENB==400	;IDLE ENABLE
DCSTAR==200	;START (SET)
DCSSTP==200	;STOP (CLEAR)
DCSGL==100	;DO SINGLE COMMAND
DCCENB==40	;CHANNEL ENABLE
DCCFLG==20	;CHANNEL FLAG
DCCPUF==10	;CPU FLAG
;1.1-1.3 PIA

;CONO DC1,

;SET TIMER DRIVE # FROM 1.1-1.3

;CONI DC1,
;LH
DSATDN==360400,,	;ATTENTION DRIVE #
DSTMDN==320400,,	;TIMER DRIVE #
DSLAT==221000,,	;LATENCY TIMER FOR DRIVE ABOVE

;RH (ERROR FLAGS)
DRLNER==2000	;RECORD LENGTH
DRCER==1000	;READ COMPARE ERROR
DOVRRN==400	;OVERRUN
DCKSER==200	;CKSUM OR DECODER ERR
DWTHER==100	;WATCHDOG TIMER
DFUNSF==40	;FILE UNSAFE, SEEK INCOMPLETE OR END OR DSK
DOFFL==20	;OFF LINE OR MULT SEL
DPROT==10	;WRT KEY OR RD ONLY OR PROTECT
DDOBSY==4	;DATAO WHEN BSY
DNXM==2	;NON-EX MEM
DCPERR==1	;CORE PARITY ERR

LRIBLK==16	;CONSISTENCY CHECK DSKDMP VS MARK
]

ADMPCH:	XCTR XR,[MOVE A,(J)]	;SET OR READ STATUS OF DUMP BIT OF FILE OPEN ON CHNL IN AC(RH)
	PUSHJ P,QCHNLC
	MOVSI B,400000
	TLNE A,400000
	IORM B,UNRNDM(C)
	TLNE A,200000
	ANDCAM B,UNRNDM(C)
	MOVE D,QACTB
	TLNE A,600000
	IORM D,QSNLCN(H)
	LDB A,[430100,,UNRNDM(C)]
	PUSHJ P,QUDULK
	JRST APTUAJ

ARFDAT:	PUSHJ P,QCHNLC	;READ FILE CREATION DATE WORD
	MOVE A,UNDATE(C)
ARDM1:	PUSHJ P,QUDULK
	JRST SYSCPS	;STORE BACK IN USER MEM

QUDUL1:	AOS (P)
	JRST QUDULK

ASFDAT:	PUSHJ P,QCHNLC	;SET FILE CREATION DATE WORD
	MOVEM B,UNDATE(C)
ASDM1:	MOVE TT,QACTB
	IORM TT,QSNLCN(H)
	JRST QUDUL1

ARDMPB:	PUSHJ P,QCHNLC	;READ FILE DUMPED BIT
	LDB A,[430100,,UNRNDM(C)]
	JRST ARDM1

ASDMPB:	PUSHJ P,QCHNLC	;SET FILE DUMPED BIT
	DPB B,[430100,,UNRNDM(C)]
	JRST ASDM1

QCHNLC:	HRRZ D,A	;4.9 => SET 4.8 => CLEAR ALWAYS READ FINAL STATE INTO AC
	CAIL D,20
	JRST ILUUO
	ADDI D,IOCHNM(U)
	HRRZ R,(D)	;IOTTB INDEX
	MOVE C,CLSTB(R)
	TLNN C,200	;2311 DEVICE
	JRST ILUUO
	HLRZ R,(D)
	MOVE H,QUDPR(R)
	PUSHJ P,QUDLK
	MOVE C,QSNLCN(H)
	ADD C,QUDFPR(R)
	POPJ P,

IFN TPLP,[
TPLO:	MOVE C,[SIXBIT /.LPTR./] ;PSEUDO LINE PRINTER (DISC)
	JUMPGE D,TPLO2
	MOVE B,UNAME(U)
	AOS A,TPLFNO	;GENERATE RANDOM FILE NAME
	JRST TPLO2
]

COMO:	SKIPA C,[SIXBIT /COMMON/]	;.OPEN ENTRY FOR "COM" DEVICE
SYSO:	MOVSI C,(SIXBIT /SYS/)		; " FOR "SYS" DEVICE
TPLO2:	MOVEM C,USYSN1(U)
	MOVNI I,1
	JRST QSKO

SYSDSK:	CAIN W,0	;SKIP ON OPEN MODE OTHER THAN NORMAL
	JUMPGE D,SYSDSR	;JUMP ON READ IN NORMAL MODE
	MOVSI T,1000	;WRITING ON SYS
	PUSHJ P,CWAIT
	TDNE T,SUPCOR
	MOVE TT,UNAME(U)
	MOVEM TT,SWUNAM
	MOVE TT,JNAME(U)
	MOVEM TT,SWJNAM
	MOVEM A,SWFN1
	MOVEM B,SWFN2
	MOVEM D,SWMOD
	IORM T,SUPCOR
	CONO PI,CLKON
	JRST SYSDSR

QSKPO:	MOVSI TT,-NQS	;PACK # OPEN
	CAME I,QPKID(TT)
	AOBJN TT,.-1	;I <= PHYSICAL UNIT WITH SPECIFIED PACK
	JUMPL TT,QSKPO1
	PUSHJ P,QPKNFP
	JRST QSKPO
	CAIE W,4	;IF DEL WANT TO SET BIT
	JRST OPNL10	;SAYING PACK WASN'T MOUNTED
QSKPO1:	HRRZ I,TT
QSKUO:	CAIL I,NQS	;DISK UNIT # OPEN
	JRST OPNL10	;I <= UNIT #
	JRST QSKOB

QSKO:	MOVNI I,1	;DSK OPEN, I <= # DETERMINED BY SYS
QSKOB:	MOVEM I,EPDL(U)	;SAVE DISK #
	JUMPL I,QSKOB1
	SKIPGE QACT(I)
	JRST OPNL7
QSKOB1:	MOVE C,USYSN1(U)
	CAIN W,4
	JRST QSKOB2	;IF RENAME OF OPEN FILE TRAP OUT
QSKOB3:
QSKOA:	MOVE I,MDSK	;IS MFD IN?
	PUSHJ P,QMCH1	;READ IN MFD OF MASTER DISK
	CLEARM QLD(U)
QSKOL:	CAMN C,[SIXBIT /SYS/]
	JRST SYSDSK
SYSDSR:	PUSHJ P,MFDCK
	JRST SYSDS2
	JUMPN W,OPNL11
	JUMPL D,OPNL11	;MUST BE NORMAL READ
	JRST QMLSTF	;USER WANT TO READ THE MASTER DIRECTORY

MFDCK:	CAMN A,[SIXBIT /M.F.D./]
	CAME B,[SIXBIT /(FILE)/]
	POPJ P,
	JRST POPJ1

SYSDS2:	PUSHJ P,QFLD	;H <= PTR TO USER DIR TABLE
	PUSHJ P,QSKO1	;LOSER DIR NOT IN CORE
	PUSHJ P,QUDLK	;RETURN WITH SOS OF QSNNR ON LSWPR
	MOVSI TT,40000
	TDNE TT,QSNLCN(H)
	JRST QSKDP1	;PAW OVER USER DIRECTORY
QSKDP2:	PUSHJ P,QUDULK
	PUSHJ P,FLDRCK
	JRST QSKDP9	;NOT SPECIAL DIRECTORY FILE
	JUMPN W,QPNL11
	JUMPL D,QPNL11
	JRST QLISTF	;USER WANTS TO READ HIS USER DIRECTORY

QSKDP9:	JUMPL D,QWRO	;WRITE
	CAIN W,4
	JRST QRNAM	;RENAME/DEL
	CAIN W,2
	JRST QALINK	;MAKE LINK
	JUMPN W,QPNL22
QWROR:	JUMPE A,QPNL11	;ALSO ENTER FOR VARIOUS WRITE OVER, COPY OVER MODES
	JUMPE B,QPNL11
	PUSHJ P,QCHNF	;GET CHANNEL FOR READ
	JRST QPNL10
	PUSHJ P,STMSET
	QUSR(E)
	PUSHJ P,QUDLK	;LOCK USER DIR
	PUSHJ P,QLOOK	;LOOK UP FILE
	JRST OPNL4
	PUSHJ P,QFREF	;"REFERENCE" FILE
	MOVE C,Q
	SUB C,QSNLCN(H)
	HRRZM C,QUDFPR(E)	;SET UP PTR FROM CHNL TO FILE NAME AREA
	LDB TT,[UNDSCP+UNRNDM(Q)]	;FOUND FILE SET UP CHNL
	MOVEM TT,QDIRP(E)	;SET UP CHAR PTR TO DESC AREA
	MOVE C,UNRNDM(Q)
	TLNE C,UNLINK
	JRST QLINK	;FILE IS A LINK
	LDB J,[UNPKN+UNRNDM(Q)]	;GET PACK NUMBER FILE IS ON
	MOVSI I,-NQS
	CAME J,QPKID(I)
	AOBJN I,.-1	;TRANSLATE LOGICAL TO PHYSICAL DISK UNIT
	JUMPGE I,QPKNF	;PACK NOT ON *
	MOVEM I,QDSKN(E)	;SET CHNL DISK NUMBER
	JUMPL D,QWROR1	;REALLY WANT TO WRITE OVER, ETC
QOEX1:	PUSHJ P,QUDULK	;UNLOCK USER DIR
	PUSHJ P,LSWDEL	;QUSR ENTRY
	PUSHJ P,LSWDEL	;QSNNR ENTRY
QOEX:	MOVSI TT,200000
	ANDCAM TT,QSRAC(E)
	PUSHJ P,QSTRTR
	MOVE C,D
	ROT C,1
	HRL A,E
	JSP Q,OPSLC7	;SET UP IOCHNM AND DEPART
	DQUAI,,DQUAO
	DQBI,,DQBO
	DQUII,,DQUIO
	DQBI,,DQBO

QWROR1:	SOJN W,OPNL12	;NORMAL WRITE OVER MODE

QROR1:	HRRZS H	;CLEAR GARBAGE IN USER DIR NUM
	HRRZS E	;CLEAR GARBAGE IN CHNL NUM
	HRRZ J,QUDFPR(E)	;PICK UP LOCN OF FILE WITH U.F.D
	MOVSI I,-NQCHN	;MAKE SURE THIS FILE NOT OPEN FOR READING
QROR1A:	CAIE E,(I)	;DONT GET FAKED OUT BY OWN CHNL
	SKIPGE QUSR(I)
	JRST QROR1B
	CAMN H,QUDPR(I)
	CAME J,QUDFPR(I)
	JRST QROR1B
	JRST  OPNL23

QROR1B:	AOBJN I,QROR1A
	MOVSI TT,UNWRIT
	IORM TT,UNRNDM(Q)	;SET WRITE BIT
	MOVEI TT,1	;WRITE OVER MODE
	IORM TT,QSRAC(E)
	JRST QOEX1

QSKOB2:	JUMPN A,QSKOB3	;REG DELETE OR REG RENAME
	HRRZ A,B	;DO RENAME WHILE OPEN HERE TO AVOID
	CAIL A,20	;IN CASE SYS NAME HAS CHANGED
	JRST OPNL14
	SKIPE SRN3(U)
	SKIPN SRN4(U)
	JRST OPNL14
	ADD A,U
	HRRZ B,IOCHNM(A)
	MOVSI TT,2000
	TDNN TT,CLSTB(B)
	JRST OPNL14
	HLRZ E,IOCHNM(A)
	MOVE H,QUDPR(E)
	MOVE C,QSNUD(H)
	CAMN C,[SIXBIT /.LPTR./]
	JRST POPJ1	;FLUSH RENAME OF TPL FILES
	MOVE A,SRN3(U)
	MOVE B,SRN4(U)
	PUSHJ P,MFDCK
	JRST .+2
	JRST QPNL11
	PUSHJ P,FLDRCK
	JRST .+2
	JRST QPNL11
	PUSHJ P,QUDLK
	MOVE Q,QUDFPR(E)
	ADD Q,QSNLCN(H)
	PUSHJ P,QGRLSC	;EITHER NAME > OR <?
	JRST OPNL11	;BOTH-BARF
	PUSHJ P,QFNG	;ONE- COMPUTE EFFECTIVE FILE NAME
	PUSHJ P,QRELOC
	MOVE TT,QACTB
	IORM TT,QSNLCN(H)
	PUSHJ P,QUDULK
	JRST POPJ1

QSKDP1:	ANDCAB TT,QSNLCN(H)
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	PUSH P,I
	PUSH P,W
	MOVE C,UDNAMP(TT)
	ADDI C,(TT)	;ADDR OF BEGINNING OF NAME AREA
	MOVEI D,2000(TT)	;D => FROM POINTER
	MOVE I,D	;I => TO POINTER
	HRLOI E,377777	;PREVIOUS FN1
	MOVE W,E	;FN2
	MOVEI J,0	;0 => DON'T NEED SORT
QSKDP4:	SUBI I,LUNBLK
QSKDP5:	SUBI D,LUNBLK
	CAMLE C,D
	JRST QSKDP8	;THROUGH
	SKIPN A,UNFN1(D)
	SKIPE UNFN2(D)
	JRST QSKDP3
	HLLOS J
	JRST QSKDP5	;NAME BLOCK FREE

QSKDP3:	MOVE Q,UNRNDM(D)
	TLNN Q,UNIGFL
	JRST QSKDPR	;NOT OPEN FOR WRITE OR BEING DELETED
	HLLOS J	;NEED TO WRITE OUT DIR
	SKIPN A,UNFN1(D)
	MOVSI A,(SETZ)
	SKIPN B,UNFN2(D)
	MOVSI B,(SETZ)
QSKDP7:	PUSHJ P,QGRLSC	;DON'T CREATE ANY FILE WITH NAME OF < OR >
	AOJA A,QSKDPA	;CHANGE BOTH JUST TO BE SURE
	AOJA A,QSKDPA
	MOVE Q,QSNLCN(H)	;SEE IF THAT NAME EXISTS
	MOVEI Q,2000-LUNBLK(Q)	;THERE MAY BE DUPLICATE ENTRIES
QSKDPU:	CAMN A,UNFN1(Q)	;DURING THIS SEARCH BUT IT DOESN'T
	CAME B,UNFN2(Q)	;MATTER
	JRST QSKDPT
QSKDPA:	AOJA B,QSKDP7	;FOUND IT.  CHANGE SECOND NAME
QSKDPT:	SUBI Q,LUNBLK
	CAMG C,Q
	JRST QSKDPU
	MOVEM A,UNFN1(D)
	MOVEM B,UNFN2(D)
	MOVSI Q,UNIGFL
	ANDCAM Q,UNRNDM(D)
QSKDPR:	CAMN D,I
	JRST QSKDP6
	HRLZ Q,D	;RELOCATE FILE BLOCK
	HRR Q,I
	BLT Q,LUNBLK-1(I)
QSKDP6:	JUMPL J,QSKDP4	;ALREADY NEEDS SORT
	MOVE B,UNFN2(I)
	TLC A,(SETZ)
	TLC B,(SETZ)
	EXCH A,E
	EXCH B,W
	CAMLE A,E
	JRST QSKDP4	;ORDER OK
	CAMN A,E
	CAMGE B,W
	MOVNI J,1	;NEED SORT
	JRST QSKDP4

QSKDP8:	ADDI I,LUNBLK	;I POINTED TO EMPTY SLOT
	MOVE D,I
	SUBI D,(TT)
	EXCH D,UDNAMP(TT)
	ADDI D,(TT)
	CAML D,I
	JRST QSKDPV
	SETZM (D)	;CLEAR VACATED AREA
	HRLS D
	ADDI D,1
	BLT D,-1(I)
QSKDPV:	JUMPL J,QSKDPS	;SORT
	TRNN J,-1
	JRST QSKDPK
QSKDPX:	MOVE I,QACTB
	IORM I,QSNLCN(H)
QSKDPK:	POP P,W
	POP P,I
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	JRST QSKDP2

QSKDPS:	MOVEI T,LUNBLK
	ADD P,[3,,3]
QSKDPB:	MOVEI Q,(I)	;BEGINNING OF NAME AREA
	SKIPGE T
	MOVEI Q,2000-LUNBLK(TT)	;START AT END
	MOVEI W,2000(TT)
	SKIPGE T
	MOVEI W,-LUNBLK(I)
	SETZM (P)
	TDZA J,J	;0 => SORTED  -1 => MAKE ANOTHER PASS
QSKDPE:	ADD Q,T
	CAIE Q,(W)
	JRST QSKDPC
	JUMPE J,QSKDPW
	MOVNS T
	JRST QSKDPB
QSKDPW:	SUB P,[3,,3]
	JRST QSKDPX
QSKDPC:	SKIPN A,UNFN1(Q)
	SKIPE UNFN2(Q)
	JRST QSKDPD
	JRST 4,.

QSKDPD:	MOVE B,UNFN2(Q)
	TLC A,(SETZ)
	TLC B,(SETZ)
	SKIPE E,(P)	;FIRST ENTRY
	JRST QSKDPF
QSKDPG:	MOVEM A,-2(P)
	MOVEM B,-1(P)
QSKDPI:	MOVEM Q,(P)
	JRST QSKDPE
QSKDPF:	JUMPL T,QSKDPJ
	CAMLE A,-2(P)
	JRST QSKDPG
	CAME A,-2(P)
	JRST QSKDPH
	CAML B,-1(P)
	JRST QSKDPG
QSKDPH:	REPEAT LUNBLK,[
	EXCH A,.RPCNT(E)
	EXCH A,.RPCNT(Q)
	EXCH A,.RPCNT(E)
]
	MOVNI J,1
	JRST QSKDPI

QSKDPJ:	CAMGE A,-2(P)
	JRST QSKDPG
	CAME A,-2(P)
	JRST QSKDPH
	CAMG B,-1(P)
	JRST QSKDPG
	JRST QSKDPH

;RETURNS WITH QUSR(E) AND QSNLCN(E) ON LSWPR
QWRO2:	JUMPE A,QPNL11
	JUMPE B,QPNL11
	SKIPGE I,EPDL(U)	;PICK UP DESIRED DISK UNIT
	JRST QWRO2A	;SYSTEMS CHOICE
QWRO2B:	MOVE TT,QTUTO(I)
	SKIPL QDPWF(I)	;DISK IN BUT NOW PAWED OVER
	TLNE TT,40000
	PUSHJ P,QTCH1	;READ IN TUT OF DISK INVOLVED
	PUSHJ P,QCHNF	;GET CHANNEL
	JRST QPNL10
	PUSHJ P,STMSET
	QUSR(E)
	PUSHJ P,QUDLK	;LOCK USER DIRECTORY
	PUSHJ P,QGRLSC	;CHECK < AND >
	JRST QPNLBN	;LOSE
	PUSHJ P,QFNG	;REPLACE WITH COMPUTED EFFECTIVE NAME
	PUSHJ P,QFREEF	;FIND FREE FILE NAME AREA AND STORE IN QDIRP(E)
	JRST QFDF	;FILE DIR FULL
	MOVEM A,UNFN1(Q)	;SET FILE NAMES
	MOVEM B,UNFN2(Q)
	MOVSI TT,UNWRIT	;SET WRITE IN PROGRESS
	IORM TT,UNRNDM(Q)
	MOVE TT,QPKID(I)
	DPB TT,[UNPKN+UNRNDM(Q)]
	MOVE TT,QACTB
	IORM TT,QSNLCN(H)
	SETOM QSCRW(E)	;SET CHNL WRITE SWITCH
	POPJ P,

QWRO2A:	MOVE I,QWRU
	MOVE TT,QSFT(I)
	CAML TT,QFTTHR
	JRST QWRO2B	;ENUF ROOM ON PREFERRED UNIT
	SETOB T,I	;NOT MUCH SPACE LEFT TRY OTHER UNITS
	MOVSI E,-NQS
QWRO2C:	SKIPL QACT(E)	;SKIP ON UNIT NOT ACTIVE
	SKIPGE QTUTO(E)	;SKIP ON TUT IN NOT LOCKED ETC
	JRST QWRO2D
	CAML T,QSFT(E)
	JRST QWRO2D
	MOVE T,QSFT(E)
	HRRZ I,E
QWRO2D:	AOBJN E,QWRO2C
	MOVEM I,QWRU
	MOVE E,QACTB
	IORB E,QMDRO
	MOVEM I,MPDWDK(E)
	JRST QWRO2B

QWRO:	JUMPN W,QWROR	;REALLY WANT TO MODiFY OR OTHERWISE HACK AN EXISTING FILE
	PUSHJ P,QWRO2
	SETOM QMFTP(E)	;TRACK TO SCAN IN TUT
	SETOM QMTTR(E)
	CLEARM QMPTN(E)
	CLEARM QMPTC(E)
	JRST QOEX1	;EXIT

LDEP:	PUSH P,C
	MOVE C,[440600,,B]
LDEPLP:	ILDB D,C
	JUMPE D,LDEPF
	CAIE D,';
	CAIN D,':
	JRST LDEPS
LDEPS2:	PUSHJ P,QUDSA
	JRST LFDF
	TLNE C,770000
	JRST LDEPLP
LDEPF1:	POP P,C
	POPJ P,

LDEPF:	MOVEI D,';
	PUSHJ P,QUDSA
	JRST LFDF
	JRST LDEPF1

LDEPS:	PUSH P,D
	MOVEI D,':
	PUSHJ P,QUDSA
	JRST LFDF2
	POP P,D
	JRST LDEPS2

LFDF2:	SUB P,[1,,1]
LFDF:	SUB P,[2,,2]
QALMP:	MOVE Q,QUDFPR(A)	;ABORT DUE TO  MEM PROTECT
	ADD Q,QSNLCN(H)
	SETOM QUSR(A)
	SOS QSNNR(H)
	PUSHJ P,QDLINK
	JRST 4,.
	POPJ P,

QFREEF:	PUSH P,A	;Q_PTR TO USER DIR FREE FILE  QDIRP(E)_PTR TO FREE DESC AREA
	PUSH P,B	;GET FREE FILE AREA
	PUSH P,I
	MOVEI I,0	;SIGNAL NO GC
QFREFA:	PUSHJ P,QWRO1	;EXPAND FILE AREA
	HRRZ Q,@QSNLCN(H)	;PICK UP FS PNTR
	CAIL Q,2000*6
	JRST 4,.	;FREE DESC POINTER OUT OF RANGE
	IDIVI Q,UFDBPW
	MOVE TT,QSNLCN(H)
	MOVE C,UDNAMP(TT)
	MOVEI J,LUNBLK
	ADDM J,UDNAMP(TT)
	CAIG C,UDDESC+6(Q)
	JRST QAGARB
	PUSHJ P,QLGLK
	JRST QFREFF	;DIR WAS EMPTY
	TRNN J,1777
	JRST QFREFE	;GOES AT END OF DIR
QFREFC:	CAMN A,UNFN1(J)
	CAME B,UNFN2(J)
	JRST QFREFE
	MOVE C,UNRNDM(J)
	TLNE C,UNIGFL	;* FILES MUST COME AFTER NON * FILES
	JRST QFREFE	;OF SAME NAME
	ADDI J,LUNBLK
	CAIGE J,2000(TT)
	JRST QFREFC
QFREFE:	CAMN Q,J
	JRST QFREFF	;GOES AT BEGINNING
	PUSHJ P,QINSRT
	JRST QFREFD
QFREFF:	SUBI Q,LUNBLK
QFREFD:	MOVNI T,LUNBLK
	ADDM T,UDNAMP(TT)
	HRRZ A,@QSNLCN(H)
	DPB A,[UNDSCP+UNRNDM(Q)]	;STORE IN FILE AREA
	MOVEM A,QDIRP(E)
	MOVE B,Q
	SUB B,QSNLCN(H)
	HRRZM B,QUDFPR(E)
	SETOM UNFN1(Q)	;SO FILE WONT APPEAR FREE IN CASE OF GC
	CONO PI,CLKOFF
	SKIPL B,QDATE	;GET TIME AND DATE
	HRR B,TIMOFF
	CONO PI,CLKON
	MOVEM B,UNDATE(Q)
	IDIVI A,UFDBPW	;GET WRD AND CHAR ADRS
	HLLZ B,QBTBLI(B)
	ADDI B,UDDESC(A)
	HRRZ A,QSNLCN(H)
	ADD B,A
	ILDB A,B
	JUMPN A,[JRST 4,.]
	MOVEI A,UDWPH
	DPB A,B
	MOVEI A,3*6
	ADDM A,@QSNLCN(H)
	POP P,I
	POP P,B
	POP P,A
	JRST POPJ1

QWGARB:	POP P,I
	SUB P,[1,,1]
	JUMPGE I,QFREFB
	JRST QNOFRE

QAGARB:	JUMPL I,QNOFRE
QFREFB:	PUSHJ P,QGC
	JFCL
	MOVNI I,1	;SIGNAL GC HAS BEEN TRIED
	JRST QFREFA

;MAKE ROOM FOR FILE BEFORE J.  Q POINTS TO NEW EMPTY FILE SLOT
QINSRT:	PUSH P,A
	PUSH P,TT
	HRRZ TT,QSNLCN(H)
	HRRZ A,UDNAMP(TT)
	PUSH P,A
	ADDI A,(TT)
	HRLS A
	SUBI A,LUNBLK
	BLT A,-LUNBLK-1(J)
	SETZM -LUNBLK(J)
	HRRZI A,-LUNBLK+1(J)
	HRLI A,-LUNBLK(J)
	BLT A,-1(J)
	SUB J,QSNLCN(H)
	MOVSI A,-NQCHN
QINSR1:	HRRZ TT,QUDPR(A)
	SKIPL QUSR(A)
	CAIE TT,(H)
	JRST QINSR2
	MOVE TT,QUDFPR(A)
	CAMGE TT,(P)
	JRST QINSR2
	CAIGE TT,(J)
	SUBI TT,LUNBLK
	MOVEM TT,QUDFPR(A)
QINSR2:	AOBJN A,QINSR1
	ADD J,QSNLCN(H)
	HRRZI Q,-LUNBLK(J)
	SUB P,[1,,1]
	POP P,TT
	POP P,A
	POPJ P,

QNOFRE:	POP P,I		;NO FREE FILES AVAIL
	JRST POPBAJ

QWRO1:	PUSH P,I
	SETZM QUDFPR(E)	;CLEAR SO WILL NOT POINT TO RANDOMNESS IN CASE OF G C
	MOVE TT,@QSNLCN(H)
	IDIVI TT,UFDBPW
	MOVE C,QSNLCN(H)
	MOVE Q,UDNAMP(C)
	SUBI Q,LUNBLK
	CAIL TT,-UDDESC-6(Q)
	JRST QWGARB
	MOVEM Q,UDNAMP(C)
	ADD Q,QSNLCN(H)
	POP P,I
	POPJ P,

QSKO1:	PUSHJ P,SWTL
	QSKOSW	;PREVENT TIMING ERROR IF TWO PCS SHOULD ATTEMPT TO BRING IN SAME USER
	PUSH P,J	;BRING USER DIR INTO CORE
	PUSH P,I	;C HAS SYS NAME,RET PTR IN H
	PUSHJ P,QFL	;LOOK UP USER,RET TRACK IN J
	JRST QSKON	;NON EX USER
	PUSH P,C
	MOVEI C,0
	PUSHJ P,QFLD	;FIND FREE LOSER DIR SLOT
	JRST QPNL10
	MOVE I,MDSK
	PUSHJ P,QCHNF	;FIND FREE CHNL(TO READ IN DIR)
	JRST QPNL10
	POP P,C
	MOVEM C,QSNUD(H)	;SET USER NAME IN DIR SLOT
	MOVEM J,QSLGL(E)	;REQUEST READ IN OF USER DIR FROM TRACK IN J
	MOVSI TT,2000
	IORM TT,QSRAC(E)
QSKON1:	MOVEI T,2
	PUSHJ P,LSWPON	;RELEASE QSKOSW
	POP P,I	;GO AWAY WILL HANG UP WAITING IN QUDLK
	POP P,J
	JRST QSTRTR

QSKON:	JUMPE C,QPNL20	;DON'T ALLOW ZERO USER NAME
	PUSH P,TT
	MOVSI TT,-NSPUFD
QSKONA:	CAMN C,NUFDTB(TT)
	JRST QSKONB
	AOBJN TT,QSKONA
	POP P,TT
	JRST QPNL20
QSKONB:	POP P,TT
	SKIPG NQFUS
	JRST QPNL24	;NO MFD SLOTS AVAILABLE
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,C
	MOVEI C,0
	PUSHJ P,QFLD	;FIND FREE DIR SLOT
	JRST QPNL10
	POP P,QSNUD(H)
	PUSHJ P,TCALL
	JRST IOMQ
	JRST QSKONE
	SOS NQFUS	;NO TIMING ERR DUE TO QSKOSW
	MOVEI J,MU23UD
	DPB J,[MUR,,MEMBLT(A)]
	DPB H,[MLO,,MEMBLT(A)]
	LSH A,10.
	HRRM A,QSNLCN(H)
	SETZM (A)
	HRLS A
	AOS B,A
	BLT A,2000-2(B)
	MOVEI A,2000
	MOVEM A,UDNAMP-1(B)
	MOVSI TT,100000	;SET DIR CHANGED AND NEW USER BITS
	IOR TT,QACTB
	IORM TT,QSNLCN(H)
	MOVSI TT,600000
	ANDCAM TT,QSNLCN(H)
	POP P,C
	POP P,B
	POP P,A
	JRST QSKON1

EBLK
NUFDTB:	0
BBLK
	SIXBIT /.LPTR./
	SIXBIT /.MSGS./
NSPUFD==.-NUFDTB

QPNL24:	PUSHJ P,OPNL24
	JRST URET

QPNL20:	PUSHJ P,OPNL20
	JRST URET

QALINK:	MOVE I,MDSK	;ENTER WITH QSNNR ON LSWPR
	MOVEM I,EPDL(U)
	PUSHJ P,QWRO2	;ADDS QUSR AND QSNLCN ON LSWPR
	MOVSI A,UNLINK
	IORM A,UNRNDM(Q)	;SET LINK BIT
	MOVE A,E	;CALL RESERVED
	MOVE B,SRN5(U)
	PUSHJ P,LDEP
	MOVE B,SRN3(U)
	PUSHJ P,LDEP
	MOVE B,SRN4(U)
	PUSHJ P,LDEP
	AOS (P)		;CAUSE RETURN TO SKIP
	MOVEI T,2
	PUSHJ P,LSWDLN	;DELETE QUSR ENTRY
	MOVEI T,2
	PUSHJ P,LSWDLN
	JRST QSOCL4	;CLOSE CHNL & FILE

QLINK:	AOS E,QLD(U)
	CAIL E,100.
	JRST OPNL27	;LINK DEPTH EXCEEDED
	MOVE E,TT
	IDIVI E,UFDBPW
	ADD E,QSNLCN(H)
	ADDI E,UDDESC
	MOVE TT,QBTBLI(TT)
	HRR TT,E
	MOVE I,[440600,,A]
	SETZB A,B
	SETZB C,T
QL1:	ILDB J,TT
	JUMPE J,QL3
	CAIN J,':	;COLON
	SOJL T,QL4
	CAIN J,';	;SEMICOLON
	SOJL T,QL2
QL5:	IDPB J,I
	JRST QL1

QL2:	TLZ I,770000
	JRST QL1

QL3:	EXCH A,C
	EXCH A,B
	SKIPN C
	MOVE C,USYSN1(U)
	PUSHJ P,QUDULK	;UNLOCK DIR
	PUSHJ P,LSWPOP	;QUSR ENTRY
	PUSHJ P,LSWPOP	;QSNNR ENTRY
	PUSHJ P,OPBRK
	JRST QSKOL

QL4:	MOVEI T,1
	JRST QL1

QMCH1:	CONO PI,UTCOFF
	MOVE TT,QMDRO
	TLNE TT,40000
	AOJE TT,QMCH2	;NOT ON WAY IN
QMCH3:	CONO PI,UTCON
	SKIPGE QMDRO
	PUSHJ P,UFLS
	MOVSI E,2
	TDNN E,QMDRO
	POPJ P,	;PAWED OVER
	PUSHJ P,QMLOCK
	ANDCAM E,QMDRO
	HRRZ E,QMDRO
	MOVE TT,MDCHK(E)
	CAME TT,[SIXBIT /M.F.D./]
	JRST 4,.	;MFD CLOBBERRED
	HRRZ TT,MPDWDK(E)
	CAIGE TT,NQS
	SKIPGE QACT(TT)
	JRST .+3
	MOVEM TT,QWRU
	MOVEI E,2000-LMNBLK*NUDSL(E)
	SETZM NQFUS
QMCH1E:	LDB TT,[1200,,E]
	JUMPE TT,QMULK
	SKIPN (E)
	AOS NQFUS
	ADDI E,LMNBLK
	JRST QMCH1E

QTCH1:	CONO PI,UTCOFF
	MOVE TT,QTUTO(I)
	TLNE TT,40000	;SKIP IF IN
	AOJE TT,QTCH2	;NOT ON WAY IN
	CONO PI,UTCON
QTCH1A:	PUSHJ P,QTLOCK	;TO MAKE SURE IT'S IN
	AOSE QDPWF(I)
	JRST QTULK
	MOVE TT,QTUTO(I)
	MOVE E,QSWAPA(TT)
	IDIVI E,NHEDS
	SKIPE TT
	ADDI E,1
	IMULI E,NHEDS	;ROUND SWAPPING ALLOC TO MULTIPLE OF A DEECADE
	MOVE TT,QTUTO(I)
	MOVEM E,QSWAPA(TT)
	PUSH P,E	;FIRST TRACK OF NON-SWAPPING AREA
	MOVE E,QPKNUM(TT)
IFE DECDKC,[
	CAME E,QPKID(I)
	JRST 4,.	;PACK ID IN TUT DIFFERS FROM PACK ID IN HEADER
]
IFN DECDKC,	MOVEM E,QPKID(I)
	MOVE E,QPAKID(TT)
	MOVEM E,QPKNM(I)
	HRLI TT,(TUTBP)
	PUSH P,A
	CLEARB A,QSFTS(I)	;FREE SPACE IN SWAPPING AREA
	CLEARM QSFT(I)
	PUSH P,B
	MOVEI B,NBLKS
QTCH1D:	ILDB E,TT
	JUMPN E,QTCH1F
	CAML A,-2(P)
	AOS QSFT(I)	;BLOCK IN NON-SWAPPING AREA
	CAMGE A,-2(P)
	AOS QSFTS(I)	;BLOCK IN SWAPPING AREA
QTCH1F:	SOSLE B
	AOJA A,QTCH1D
	POP P,B
	POP P,A
	SUB P,[1,,1]
	JRST QTULK

QTCH2:	SETOM QDPWF(I)
	SOS QTUTO(I)
	CONO PI,UTCON
	PUSHJ P,QCHNF
	JRST 4,.
	HRRZM I,QDSKN(E)
	MOVEI TT,TUTBLK
	MOVEM TT,QSLGL(E)
	MOVSI TT,10000
	IORM TT,QSRAC(E)
	PUSHJ P,QSTRTR
	JRST QTCH1A

QMCH2:	SOS QMDRO	;INDICATE ON WAY IN
	CONO PI,UTCON
	PUSHJ P,QCHNF	;MUST BE IMMED AVAILABLE
	JRST 4,.
	MOVEI TT,MFDBLK	;MFD TRACK
	MOVEM TT,QSLGL(E)
	MOVSI TT,1000
	IORM TT,QSRAC(E)
	PUSHJ P,QSTRTR
	JRST QMCH3

QSTRTR:
IFE DECDKC,	CONO DC0,DCSET+DCIENB+DSKCHN
IFN DECDKC,[
	CONO PI,UTCOFF
	SETOM QGTBZY
	CONO PI,4000+1_<7-DSKCHN>
	CONO PI,UTCON
]
	POPJ P,

QFLD:	PUSHJ P,SWTL	;SEE IF USER DIR IN C IS IN
	UDRSW	;IF SO RET PNTR IN H + AOS QSNRR(H) + SKIP
QFLD1A:	MOVSI H,-QNUD	;IF NO DONT SKIP
QFLD1:	CAME C,QSNUD(H)	;IF C = 0 FIND FREE SLOT DOUBLE LOCK IT AOS QSNRR(H) + SKIP
	AOBJN H,QFLD1	;IF NO FREE AVAIL DONT SKIP
	JUMPN C,QFLD2
	JUMPGE H,QFLD3
	SKIPE QSNNR(H)	;LOCKING FOR FREE SLOT COUNT MUST BE 0
	AOBJN H,QFLD1
	JUMPGE H,QFLD3
	MOVSI TT,600000	;FOUND FREE, DOUBLE LOCK
	IORM TT,QSNLCN(H)
QFLD2:	JUMPGE H,LSWPOP
QFLD2A:	AOS QSNNR(H)	;ONLY AOS OF QSNNR
	PUSHJ P,LSWPOP
	PUSHJ P,SOSSET
	QSNNR(H)
	JRST POPJ1

QFLD3:	MOVSI H,-QNUD
QFLD4:	SKIPE QSNUD(H)
	SKIPE QSNNR(H)
QFLD4A:	AOBJN H,QFLD4
	JUMPGE H,LSWPOP
	MOVE TT,QACTB
	TLO TT,600000
	TDNE TT,QSNLCN(H)
	JRST QFLD4A
	CLEARM QSNUD(H)
	PUSH P,A
	HRRZ A,QSNLCN(H)
	LSH A,-10.
	PUSHJ P,MEMR
	POP P,A
	JRST QFLD1A

;C <=SYS NAME,   RETURNS TRACK ADDR OF DIR IN J, SKIPS IF FINDS LOSER
QFL:	PUSH P,Q
	PUSHJ P,QMLOCK
	HRRZ Q,QMDRO
	ADD Q,MDNAMP(Q)	;PTR TO USER AREA
QFL1:	LDB J,[1200,,Q]
	JUMPE J,QFL3
	CAMN C,MNUNAM(Q)
	JRST QFL2
	ADDI Q,LMNBLK
	JRST QFL1

QFL2:	SUBI J,1777-2*NUDSL	;J <= TRACK ADDR OF USER DIR
	LSH J,-1
	JRST QFL2A

QFL3:	SOS -1(P)
QFL2A:	PUSHJ P,QMULK	;UNLOCK MFD
	POP P,Q
	JRST POPJ1

QCHNF:	PUSHJ P,SWTL	;CLEAR CHNL U => QUSR I=> DSK # H =>DIR LOC IN DIR TAB
	QCHSW
	MOVSI E,-NQCHN
QCH2:	SKIPGE QSRAC(E)
	JRST QCH3
	SKIPGE QUSR(E)
	JRST QCH1
QCH3:	AOBJN E,QCH2
	JRST LSWPOP

QCH1:	HRRZM I,QDSKN(E)
	SETOM QSCABN(E)
	SETZM QSBFS(E)
	MOVE TT,[SETZ 377]
	MOVEM TT,QBFP(E)
	CLEARM QSLBLK(E)
	SETOM QSMDN(E)
	SETZM QSCRW(E)
	SETOM QSGL(E)
	SETZM QSBI(E)
	MOVSI TT,200000
	MOVEM TT,QSRAC(E)
	CLEARM QFBLNO(E)
	SETZM QSMPRC(E)
	SETZM QSMPRP(E)
	SETZM QPCLSR(E)
	HRRZM H,QUDPR(E)
	MOVEM U,QUSR(E)
	PUSHJ P,LSWPOP
	JRST POPJ1

QRNAM:	SKIPN SRN3(U)
	JRST QDEL
	PUSH P,A
	PUSH P,B
	SKIPN B,SRN4(U)
	JRST QPNL11
	MOVE A,SRN3(U)
	PUSHJ P,MFDCK
	JRST .+2
	JRST QPNL13
	PUSHJ P,FLDRCK
	JRST .+2
	JRST QPNL13
	POP P,B
	POP P,A
	MOVE TT,QSNUD(H)
	CAMN TT,[SIXBIT /.LPTR./]
	JRST QRNAM1	;FLUSH RENAME OF TPL FILES
	PUSH P,SRN3(U)
	PUSH P,SRN4(U)
	PUSHJ P,QUDLK
	PUSHJ P,QLOOK
	JRST QFNF2	;FILE NOT FOUND
	MOVE I,Q
	POP P,B
	POP P,A
	PUSHJ P,QGRLSC
	JRST QPNL13	;FILE ALREADY EXISTS
	PUSHJ P,QFNG
	PUSHJ P,QLOOK
	JRST .+2
	JRST QPNL13
	MOVE Q,I
	PUSHJ P,QRELOC	;STORE NEW NAMES IN DIR
	PUSHJ P,QFREF	;"REFERENCE" FILE
QRNAM2:	MOVE TT,QACTB
	IORM TT,QSNLCN(H)
QRNAM1:	PUSHJ P,LSWCLR
	JRST POPJ1

QGRLSC:	CAME A,[SIXBIT />/]	;SKIP NONE IF BOTH A+B ARE SPECIAL
	CAMN A,[SIXBIT /</]	;ONCE IF ONE IS
	SOS (P)
	CAME B,[SIXBIT />/]	;AND TWICE IF NEITHER
	CAMN B,[SIXBIT /</]
	SOS (P)
	AOS (P)
	JRST POPJ1

;MOVE FILE POINTED TO BY Q SO THAT NEW NAMES A AND B WILL BE IN
;ALPHABETICAL ORDER
QRELOC:	PUSH P,TT
	PUSH P,E
	PUSH P,J
	PUSH P,Q
	PUSH P,D
	PUSH P,W
	PUSH P,R
	PUSHJ P,QLGLK	;SEE WHERE FILE MUST GO
	JRST 4,.	;DIR WAS EMPTY
	HRRZ TT,QSNLCN(H)
QRLOCK:	CAIL J,2000(TT)
	JRST QRLOCJ
	CAMN A,UNFN1(J)
	CAME B,UNFN2(J)
	JRST QRLOCJ
	MOVE Q,UNRNDM(J)
	TLNE Q,UNIGFL
	JRST QRLOCJ
	ADDI J,LUNBLK
	JRST QRLOCK
QRLOCJ:	HRRZ Q,-3(P)	;WHERE FILE IS NOW
	CAIE J,LUNBLK(Q)
	CAMN J,Q
	JRST QRLOCS	;SAME PLACE
REPEAT LUNBLK,	PUSH P,.RPCNT(Q)
	CAMG Q,J
	JRST QRLOCB
	MOVEI TT,(Q)
QRLOCC:	SUBI TT,LUNBLK
	HRLZ D,TT
	HRRI D,LUNBLK(TT)
	BLT D,2*LUNBLK-1(TT)
	CAILE TT,(J)
	JRST QRLOCC
QRLOCA:
REPEAT LUNBLK,	POP P,LUNBLK-.RPCNT-1(J)
	MOVEM A,UNFN1(J)
	MOVEM B,UNFN2(J)
	HRRZ TT,QSNLCN(H)
	SUB Q,TT
	SUB J,TT
	CAML J,Q
	JRST QRLOCD
	MOVEI D,LUNBLK
	HRRZ W,J
	HRRZ R,Q
QRLOCE:	MOVSI TT,-NQCHN
QRLOCF:	HRRZ E,QUDPR(TT)
	SKIPL QUSR(TT)
	CAIE E,(H)
	JRST QRLOCG
	HRRZ E,QUDFPR(TT)
	CAIN E,(Q)
	JRST QRLOCI
	CAIL E,(W)
	CAIL E,(R)
	JRST QRLOCG
	ADD E,D
	HRRZM E,QUDFPR(TT)
QRLOCG:	AOBJN TT,QRLOCF
QRLOCH:	POP P,R
	POP P,W
	POP P,D
	POP P,Q
	POP P,J
	POP P,E
	POP P,TT
	POPJ P,

QRLOCB:	HRRZ D,Q
	HRLI D,LUNBLK(Q)
	BLT D,-1-LUNBLK(J)
	SUBI J,LUNBLK
	JRST QRLOCA

QRLOCD:	MOVNI D,LUNBLK
	HRRZI W,LUNBLK(Q)
	HRRZI R,LUNBLK(J)
	JRST QRLOCE

QRLOCI:	HRRZM J,QUDFPR(TT)
	JRST QRLOCG

QRLOCS:	MOVEM A,UNFN1(Q)
	MOVEM B,UNFN2(Q)
	JRST QRLOCH

QDEL:	PUSHJ P,QUDLK
	PUSHJ P,QLOOK
	JRST QDFNF
	MOVE TT,UNRNDM(Q)
	TLNE TT,UNLINK
	JRST QDEL5A
	LDB J,[UNPKN+UNRNDM(Q)]
QDELTA:	MOVSI I,-NQS
	CAME J,QPKID(I)
	AOBJN I,.-1
	JUMPGE I,QPKNF6	;PACK OF FILE NOT MOUNTED
QDEL5:	PUSHJ P,QUDULK
	PUSHJ P,QDELA
	JRST QDFNF	;GONE AWAY BETWEEN LOCKS
	JRST QRNAM1

QPKNF6:	CAMN J,QFLPK
	JRST QDFPK	;FILE ON DEMISED PACK
	PUSHJ P,QUDULK
	PUSHJ P,QPKNFP
	JRST QDELTA
	MOVSI D,UNPDEL
	IORM D,UNRNDM(Q)
	JRST QRNAM2

QDEL5A:	;DELETE LINK
	MOVE I,MDSK	;RANDOM EXISTANT UNIT
	JRST QDEL5

QDFPK:	LDB A,[UNDSCP+UNRNDM(Q)]	;POINTER TO DESCRIPTION AREA
	PUSHJ P,QSQSH	;REMOVE ENTRY
	IDIVI A,UFDBPW
	ADD A,QSNLCN(H)
	ADDI A,UDDESC
	HLL A,QBTBLI(B)
	MOVEI C,0
QNFDL2:	ILDB B,A
	DPB C,A
	TRNE B,40
	JRST QNFDL3
	JUMPN B,QNFDL2
	JRST QRNAM2

QNFDL3:	REPEAT NXLBYT,[IDPB C,A
]
	JRST QNFDL2

;Q=0 => LOOK UP FILE TO DELETE
;Q .NE. 0 => DELETE FILE POINTED TO BY QUDFPR OF CHNL IN D
;H MUST HAVE DIR SLOT INDEX
QDELA:	MOVEI Q,0
QDLA1:	PUSHJ P,SLUGH
	QCHSW
	100,,QSNLCN(H)
	100,,QTUTO(I)
	JUMPN Q,QDLA2
	PUSHJ P,QLOOK
	JRST QDEL4A	;FNF
QDLA3:	MOVE TT,UNRNDM(Q)
	TLNE TT,UNLINK
	JRST QDL2	;LINK
	LDB TT,[UNPKN+UNRNDM(Q)]
	CAME TT,J
	JRST QDELA1	;ON DIFFERENT DISK (DIDN'T LOCK RIGHT TUT TRY AGAIN)

	MOVSI TT,UNCDEL	;SET DELETED BIT
	IORM TT,UNRNDM(Q)
	MOVE A,Q
	SUB A,QSNLCN(H)
	MOVSI J,-NQCHN
QDEL1:	HRRZ TT,QUDPR(J)
	SKIPL QSCRW(J)	;ONLY LOOK AT READ CHNLS
	CAIE TT,(H)
	JRST QDEL2
	HRRZ TT,QUDFPR(J)
	SKIPL QUSR(J)
	CAIE TT,(A)
	JRST QDEL2
	MOVSI TT,200	;FOUND CHNL WITH THIS FILE OPEN
	TDNE TT,QSRAC(J)
	JRST QDEL2
	IORM TT,QSRAC(J)	;DELETE FILE WHEN THIS CHNL CLOSED
QDEL4:	MOVE TT,QACTB
	IORM TT,QSNLCN(H)
	IORM TT,QTUTO(I)
QDEL4B:	PUSHJ P,QTULK
	PUSHJ P,QUDULK
	PUSHJ P,LSWPOP
	JRST POPJ1

QDLA2:	MOVE Q,QUDFPR(D)	;COMPUTE FILE ADR FROM CHNL IN D
	ADD Q,QSNLCN(H)	;DIR MAY HAVE MOVED
	JRST QDLA3

QDEL4A:	SOS (P)
	JRST QDEL4B

QSICLD:	PUSHJ P,LSWPOP	;ENTRY FROM CLOSE
	MOVE H,QUDPR(D)
	MOVE I,QDSKN(D)
	PUSHJ P,QUDLK
	MOVE Q,QSNLCN(H)
	ADD Q,QUDFPR(D)
	LDB J,[UNPKN+UNRNDM(Q)]	;PACK #
	PUSHJ P,QUDULK
	PUSH P,D
	PUSHJ P,QDLA1
	JRST 4,.	;FILE ISNT THERE?
	POP P,D
	SETOM QUSR(D)
	JRST QICLX

QDELA1:	PUSHJ P,QDEL4B	;NOT OUT DISK IN J
	JFCL
	MOVE J,TT	;DISK ITS REALLY ON
QDELA2:	MOVSI I,-NQS	;TRANSLATE PACK # IN J TO DRIVE # IN I
	CAME J,QPKID(I)
	AOBJN I,.-1
	JUMPGE I,QPKNF1
	JRST QDELA

QSOCLD:	PUSH P,D	;DELETE FILE WHEN CLOSING OVER IT
	PUSH P,R
	LDB J,[UNPKN+UNRNDM(Q)]
	CAMN J,QFLPK
	JRST QPKNF5
	PUSHJ P,QUDULK
	PUSHJ P,QDELA2
	JFCL
QPKNF7:	POP P,R
	POP P,D
	POPJ P,

QPKNF1:	PUSHJ P,QUDLK
	PUSHJ P,QLOOK
	JRST QUDULK
	MOVSI TT,UNCDEL
	IORM TT,UNRNDM(Q)
	PUSHJ P,QUDULK
	JRST POPJ1

QPKNF5:	PUSH P,A
	PUSH P,B
	PUSHJ P,QDFPK
	JRST 4,.
	POP P,B
	POP P,A
	JRST QPKNF7

QDEL2:	AOBJN J,QDEL1
	LDB A,[UNDSCP+UNRNDM(Q)]
	PUSHJ P,QSQSH	;REMOVE ENTRY
	IDIVI A,UFDBPW
	ADD A,QSNLCN(H)
	ADDI A,UDDESC
	HLL A,QBTBLI(B)
	MOVE D,QTUTO(I)
	CLEARB J,TT	;TT GETS NUMERIC TRACK NUMBER
QDEL3:	ILDB B,A
	MOVEI C,0
	DPB C,A
	JUMPE B,QDEL4	;END OF FILE DESCRIPTION
	TRNE B,40
	JRST QDEL6
	CAILE B,UDTKMX
	JRST QDEL7
QDEL8:	ILDB C,J
	JUMPE C,[JRST 4,.]	;TUT SHOWS TRACK NOT USED
	CAIGE C,TUTMNY	;USED IN "MANY" FILES(1,2,...,TUTMNY,TUTLK)
	SOS C
	JUMPN C,QDEL8A	;NOT LAST USE
	CAML TT,QSWAPA(D)
	AOS QSFT(I)
	CAMGE TT,QSWAPA(D)
	AOS QSFTS(I)	;TRACK IN SWAPPING AREA
QDEL8A:	DPB C,J
	AOS TT
	SOJG B,QDEL8
	JRST QDEL3

QDEL6:	MOVEI J,0	;LOAD ADDRESS
	DPB B,[140500,,J]
	ILDB B,A
	DPB B,[060600,,J]
	DPB C,A
	ILDB B,A
	DPB B,[0600,,J]
	DPB C,A
	MOVE TT,J	;SAVE NUMERIC TRACK
	IDIVI J,TUTEPW
	HLL J,TBTBLI(R)
	ADDI J,(D)	;GET BYTE POINTER TO TUT BYTE
	JRST QDEL7A

QDEL7:	CAIN B,UDWPH
	JRST QDEL3
	SUBI B,UDTKMX
	ADD TT,B
	IBP J
	SOJG B,.-1
QDEL7A:	MOVEI B,1	;LOAD ADDRESS OR SKIP AND TAKE, SO ONLY ONE TRACK
	JRST QDEL8

QDFNF:	PUSHJ P,OPNL4
	JRST URET

QDELB:	CONO PI,UTCON
	JRST QDELA

QDL2:	PUSHJ P,QTULK	;DELETE LINK
	MOVEI T,2
	PUSHJ P,LSWPON	;UNLOCK QCHSW
QDLINK:	LDB E,[UNDSCP+UNRNDM(Q)]
	IDIVI E,UFDBPW
	ADD E,QSNLCN(H)
	ADDI E,UDDESC
	HLL E,QBTBLI(TT)
	ILDB A,E
	JUMPE E,[JRST 4,.]	;NULL LINK?
	MOVEI B,0
QDL1:	DPB B,E
	ILDB A,E
	JUMPN A,QDL1
	PUSHJ P,QSQSH	;REMOVE ENTRY
	MOVE TT,QACTB
	IORM TT,QSNLCN(H)
	PUSHJ P,QUDULK
	JRST POPJ1


;REMOVE HOLE FROM NAME AREA AT Q
QSQSH:	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,TT
	HRRZ TT,QSNLCN(H)
	MOVE A,UDNAMP(TT)
	ADDI A,(TT)
	HRRZ C,Q
QSQSH1:	SUBI C,LUNBLK
	CAMLE A,C
	JRST QSQSH2
	HRLZ B,C
	HRRI B,LUNBLK(C)
	BLT B,2*LUNBLK-1(C)
	JRST QSQSH1
QSQSH2:
REPEAT LUNBLK,SETZM .RPCNT(A)
	SUBI A,-LUNBLK(TT)
	HRRZM A,UDNAMP(TT)
	HRRZ C,Q
	SUBI C,(TT)	;INDEX OF DELETED FILE
	HRRZI TT,-LUNBLK(A)	;INDEX OF OLD BEGINNING OF NAME AREA
	MOVSI A,-NQCHN
QSQSH3:	HRRZ B,QUDPR(A)
	SKIPL QUSR(A)
	CAIE B,(H)
	JRST QSQSH4
	HRRZ B,QUDFPR(A)
	CAIGE B,(TT)
	JRST 4,.
	CAIN B,(C)
	JRST QSQSH6	;PNTR TO FLUSHED HOLE, CHECK IF READ CHNL
	CAIG B,(C)	;IF AFTER DELETED FILE DON'T RELOCATE
	ADDI B,LUNBLK
	HRRZM B,QUDFPR(A)
	SKIPL QSCRW(A)
	JRST QSQSH4	;READ CHNL
	ADD B,QSNLCN(H)
	MOVE B,UNRNDM(B)
	TLNN B,UNWRIT
	JRST 4,.	;CHNL WRITING BUT BEING WRITTEN BIT NOT SET
QSQSH4:	AOBJN A,QSQSH3
	POP P,TT
	POP P,C
	POP P,B
	POP P,A
	POPJ P,

QSQSH6:	MOVE B,QSRAC(A)	;FOUND PNTR TO DELETED FILE
	TLNE B,200	;SKIP IF NOT DELETE AFTER CLOSE
	SKIPGE QSCRW(A)	;ALSO ERROR IF NOT READ CHNL
	JRST 4,.
	JRST QSQSH4	;WAS DELETE AFTER CLOSE ON READ CHNL

QFNG:	MOVEM Q,EPDL3(U)
	SKIPA C,[SETZ]	;GENERATE FILE NAME TO REPLACE < OR > ON WRITE
QLOOK:	MOVEI C,0
	PUSH P,J	;Q_FILE #
	HRRZ J,QSNLCN(H)	;FILE NAMES IN A,B USR PNTR H USER DIR MUST BE LOCKED
	MOVEI Q,2000-LUNBLK(J)
	ADD J,UDNAMP(J)
	CAMN A,[SIXBIT />/]
	TLOA J,400000
	CAMN A,[SIXBIT /</]
	JRST QLOOKA	;4.9 BIT OF J SET IF >
	CAMN B,[SIXBIT />/]
	TLOA J,400000
	CAMN B,[SIXBIT /</]
	AOJA C,QLOOK1
	PUSHJ P,QLGLK
	JRST POPJJ	;FNF
	TRNN J,1777
	JRST POPJJ	;J IS OFF THE END OF THE BLOCK
	PUSH P,C
	EXCH Q,J
QLK1:	CAMN A,UNFN1(Q)
	CAME B,UNFN2(Q)
	JRST QLK3	;FNF
	MOVE C,UNRNDM(Q)
	TLNN C,UNIGFL	;BEING WRITTEN OR DELETED
	JRST QLK2	;FOUND IT
	SUBI Q,LUNBLK	;SEARCH THROUGH * FILES
	CAML Q,J
	JRST QLK1
QLK3:	POP P,C
	JRST POPJJ

QLK2:	AOS -2(P)
	JRST QLK3

QFNF2:	SUB P,[2,,2]
	JRST OPNL4

	;REFERENCE FILE POINTED TO BY Q
QFREF:	IFE OQDTSW,[	;EVENTUALLY FLUSH CONDITIONAL
	HLRZ T,UNDATE(Q)	;GET DATE OF CREATION + GARBAGE
	MOVE C,UDATE	;GET TODAY'S DATE
	SUB C,T	;GET DIFFERENCE (=# DAYS SINCE LAST CREATION)
	TRNE C,1400	;MANY?
	MOVNI C,1	;YES
	DPB C,[UNREFT+UNDATE(Q)]	;STORE IN DIRECTORY
]	;END CONDITIONAL
	POPJ P,

QLOOKA:	CAME B,[SIXBIT /</]
	CAMN B,[SIXBIT />/]
	JRST POPJJ	;MUST BE READ RETN FILE NOT FOUND
QLOOK1:	PUSH P,D
	PUSH P,TT
	PUSH P,I
	PUSH P,[-1]	;BEST INDEX
	PUSH P,[SETZ]	;BEST "NUMERIC" PART
	PUSH P,[SETZ]	;BEST ALPHA PART
QLOOK4:	CAIGE Q,(J)
	JRST QLOOK2
	MOVE D,UNRNDM(Q)
	TLNE D,UNIGFL
	JUMPGE C,QLOOK3	;IF CONJURING NAME FOR WRITE, CONSIDER ALL
	XCT QLKI1(C)
	JRST QLOOK3
	SKIPE TT,@QLKI1+1(C)
QLOOK6:	TRNE TT,77	;RIGHT ADJ
	JRST QLOOK5
	LSH TT,-6
	JRST QLOOK6
QLOOK5:	MOVEI I,0
QLOOK8:	LDB D,[600,,TT]
	CAIL D,'0
	CAILE D,'9
	JRST QLOOK7	;NOT A DIGIT
QLOK5B:	TRNE I,77	;RIGHT ADJ LOW NON NUM PART
	JRST QLOK5A
	LSH I,-6
	JUMPN I,QLOK5B
QLOK5A:	TLC TT,400000	;AVOID CAM LOSSAGE
	TLC I,400000
	SKIPGE -2(P)
	JRST QLOK5D	;FIRST MATCH
	JUMPGE J,QLOK5E	;GET LEAST
	CAMGE TT,-1(P)	;GET GREATEST
	JRST QLOOK3
	CAME TT,-1(P)
	JRST QLOK5D
	CAMGE I,(P)
	JRST QLOOK3	;NOT AS GOOD
QLOK5D:	HRRZM Q,-2(P)
	MOVEM TT,-1(P)
	MOVEM I,(P)
QLOOK3:	SUBI Q,LUNBLK
	JRST QLOOK4


QLOK5E:	CAMLE TT,-1(P)
	JRST QLOOK3
	CAME TT,-1(P)
	JRST QLOK5D
	CAMLE I,(P)
	JRST QLOOK3
	JRST QLOK5D

QLOOK7:	LSHC TT,-6	;LOW DIGIT NOT NUMERIC
	JUMPN TT,QLOOK8	;NO NUMERIC DIGITS AT ALL ("BIN", MAYBE?)
	JUMPL J,QLOK5B	;IF LOOKING FOR GREATEST, LET THIS BE LEAST
	MOVNI TT,1	;GREATEST IF LOOKING FOR LEAST
	JRST QLOK5B

QLOOK2:	JUMPL C,QFNG1	;REALLY WANT TO MAKE F.N.'S FOR WRITE
	SUB P,[1,,1]
	POP P,C	;BEST "NUMERIC" PART
	POP P,Q	;ADR
	POP P,I
	POP P,TT
	POP P,D
	JUMPL Q,POPJJ
	MOVE A,UNFN1(Q)	;ACTUAL MATCHED FILE NAMES
	MOVE B,UNFN2(Q)
	JRST POPJJ1


QFNG1:	SKIPGE -2(P)
	JRST QFNG2	;NOT FOUND START W/ 1
	MOVE TT,-1(P)
	TLC TT,400000
	MOVE I,[600,,TT]
QFNG3:	LDB D,I
	CAIL D,'0
	CAILE D,'9
	JRST QFNG4	;REACH END OF NUMERIC FIELD
	AOS D
	CAILE D,'9
	JRST QFNG5
	DPB D,I
QFNG5A:	TLNE TT,770000
	JRST QFNG3A
	LSH TT,6
	JRST QFNG5A

QFNG2:	MOVSI TT,(SIXBIT /1/)
QFNG3A:	MOVEM TT,A(C)	;STORE INTO A OR B AS APPRO
	SUB P,[3,,3]
	POP P,I
	POP P,TT
	POP P,D
	MOVE Q,EPDL3(U)
	JRST POPJJ


QFNG5:	MOVEI D,'0
	DPB D,I
	ADD I,[60000,,]
	JUMPL I,QFNG5A
	JRST QFNG3

QFNG4:	TLNN TT,770000	;SKIP ON ALREADY 6 CHAR NAME
	LSH TT,6
	MOVEI D,'1
	DPB D,I
	MOVEI D,'0
QFNG4B:	TLNN I,770000
	JRST QFNG5A
	IDPB D,I
	JRST QFNG4B

QLKI1:	CAME B,UNFN2(Q)
	CAME A,UNFN1(Q)
	UNFN2(Q)

QPKNF:	MOVE C,QSNUD(H)
	PUSHJ P,QUDULK	;UNLOCK DIR
	PUSHJ P,LSWPOP	;QUSR ENTRY
	PUSHJ P,LSWPOP	;QSNNR ENTRY
	PUSHJ P,QPKNFP
	JRST QSKOL
	JRST QPNL10
QPKNFP:	MOVSI I,-NQS
QPKNF3:	SKIPGE QACT(I)
	JRST QPKNF4
	MOVE TT,QTUTO(I)
	SKIPL QDPWF(I)
	TLNE TT,40000
	JRST QPKNF2	;PACK NOT IN OR NOT PAWED OVER
QPKNF4:	AOBJN I,QPKNF3
	JRST POPJ1

QPKNF2:	JRST QTCH1	;MAYBE THIS UNIT HAS GOODIES

QPNLBN:	PUSHJ P,OPNL11	;BOTH NAMES VARIABLE
	JRST URET

QFDF:	PUSHJ P,OPNL5	;FILE DIR FULL ON WRITE
	JRST URET

QPNL13:	PUSHJ P,OPNL13
	JRST URET

QPNL22:	PUSHJ P,OPNL22
	JRST URET

QPNL11:	PUSHJ P,OPNL11
	JRST URET


;ROUTINE TO FIND PLACE IN DIRECTORY WHERE A B WOULD GO
;SKIPS ONL IF DIRECTORY CONTAINS AT LEAST ONE FILE
;FOR INSERTION, FILE GOES BEFORE PNTR RETURNED IN J
;RETURNS PNTR IN Q TO BEGINNING OF NAME AREA
;(ONLY WORKS FOR LUNBLK = 5)
QLGLK:	HRRZ J,QSNLCN(H)
	HRRZ Q,UDNAMP(J)
	ADDI Q,(J)
	CAIL Q,2000(J)
	POPJ P,	;DIRECTORY EMPTY
	TLC A,(SETZ)
	TLC B,(SETZ)
	PUSH P,D
	PUSH P,E
	ADDI J,600
REPEAT 7,[
	CAMGE J,Q
	JRST .+6
	MOVE D,UNFN1(J)
	TLC D,(SETZ)
	CAMN A,D
	JSP E,QLGLE
	CAML A,D
	ADDI J,<1_<7-.RPCNT>>*LUNBLK
	SUBI J,<1_<6-.RPCNT>>*LUNBLK
]
	CAMGE J,Q
	ADDI J,LUNBLK
	CAMGE J,Q
	JRST 4,.
	MOVE D,UNFN1(J)
	TLC D,(SETZ)
	CAME A,D
	JRST QLGL1
	MOVE D,UNFN2(J)
	TLC D,(SETZ)
	CAMLE B,D
QLGL2:	ADDI J,LUNBLK
QLGL3:	TLC A,(SETZ)
	TLC B,(SETZ)
	POP P,E
	POP P,D
	JRST POPJ1

QLGL1:	CAML A,D
	JRST QLGL2
	JRST QLGL3

;CALL BY JSP E,QLGLE
QLGLE:	MOVE D,UNFN2(J)
	TLC D,(SETZ)
	CAMN B,D
	JRST QLGL3
	CAML B,D
	JRST 1(E)
	JRST 2(E)

QMLOCK:	PUSHJ P,LSWTL
	QMDRO
	POPJ P,

QMULK:	PUSH P,U
	MOVE U,USER
	MOVE TT,LSWPR(U)
	HRRZ TT,(TT)
	CAIE TT,QMDRO
	JRST 4,.
	POP P,U
	JRST LSWPOP

QTLOCK:	PUSHJ P,LSWTL
	QTUTO(I)
	POPJ P,

QTULK:	PUSH P,U
	MOVE U,USER
	MOVE TT,LSWPR(U)
	HRRZ TT,(TT)
	CAIE TT,QTUTO(I)
	JRST 4,.
	POP P,U
	JRST LSWPOP

QUDLK:	PUSHJ P,LSWTL
	QSNLCN(H)
	POPJ P,

QUDULK:	PUSH P,U
	MOVE U,USER
	MOVE TT,LSWPR(U)
	HRRZ TT,(TT)
	CAIE TT,QSNLCN(H)
	JRST 4,.
	POP P,U
	JRST LSWPOP

SBTBLI:
QBTBLI:	440600,,	;IF GOING TO ILDB
SBTBL:
QBTBL:	360600,,
	300600,,
	220600,,
	140600,,
	060600,,
	000600,,

TBTBLI:	440400,,
TBTBL:	400400,,
	340400,,
	300400,,
	240400,,
	200400,,
	140400,,
	100400,,
	040400,,
	000400,,

QSKONE:	SETZM QSNUD(H)	;FROM QSKON
QPNL10:	PUSHJ P,OPNL10	;WILL UNLOCK SWITCHES
	JRST URET

QGC:	IRPC A,,ABCDEQIJTR
	PUSH P,A
TERMIN
	MOVE A,QSNUD(H)
	MOVEM A,QGCUSR
	MOVSI A,2
	IORM A,SUPCOR	;PRINT GC MESSAGE (MUST NOT PCLSR OUT)
	MOVE A,QSNLCN(H)	;COMPACT FILE AREA
	MOVE C,UDNAME(A)
	CAME C,QSNUD(H)
	JRST 4,.
	SKIPL C,UDNAMP(A)
	CAILE C,2000
	JRST 4,.
	ADDI C,(A)	;SET UP END TEST IN C
	MOVEI A,2000(A)
	MOVE B,A	;SET UP READING PTR IN A WRITING IN B
QGCB1A:	SUBI B,LUNBLK	;DECREMENT WRITING PNTR
QGCB1:	SUBI A,LUNBLK	;DECREMENT READING PTR
QGCB6:	CAMLE C,A
	JRST QGCB3	;THRU
	SKIPN UNFN2(A)
	SKIPE UNFN1(A)	;LOOK FOR ACTIVE FILE SLOT
	JRST QGCB2	;FILE EXISTS
	JRST QGCB1	;NAME BLOCK FREE

QGCB2:	MOVSI I,-NQCHN	;FOUND FILE AND SLOT SCAN CHNLS TO SEE IF THIS FILE ACTIVE
QGCB4:	HRRZ D,QUDPR(I)	;IFSO RELOCATE
	SKIPL QUSR(I)
	CAIE D,(H)
	JRST QGCB5	;CHNL FREE OR NOT RIGHT  USR DIR
	MOVE Q,A
	MOVE J,B
	SUB Q,QSNLCN(H)
	SUB J,QSNLCN(H)
	HRRZS Q
	CAMN Q,QUDFPR(I)
	HRRZM J,QUDFPR(I)
QGCB5:	AOBJN I,QGCB4
	HRLZ D,A	;RELOCATE FILE NAMES ETC
	HRR D,B
	BLT D,LUNBLK-1(B)
	JRST QGCB1A

QGCB3:	ADDI B,LUNBLK	;B POINTED TO EMPTY SLOT
	MOVE A,QSNLCN(H)
	MOVE D,B
	SUBI D,(A)
	EXCH D,UDNAMP(A)	;STORE NEW PNTR TO NAME AREA
	ADDI D,(A)
	CAML D,B
	JRST QGCB3A
	CLEARM (D)	;CLEAR VACATED AREA
	HRLS D
	AOS D
	BLT D,-1(B)
QGCB3A:	PUSHJ P,QSETBT	;SET GC MARK BIT IN EACH FILE

	SETZB E,A	;E DEP PTR ;A FETCH PTR
QGC1:	CAMLE E,A
	JRST 4,.	;PTRS FOULED UP
	CAML A,@QSNLCN(H)
	JRST QGCEXT
QGC1A:	PUSHJ P,QBFTCH
	JUMPN D,QGC2	;FOUND FILE DESC.
	CAMGE A,@QSNLCN(H)
	AOJA A,QGC1A
QGCEXT:	MOVEM E,@QSNLCN(H)
	MOVEI D,0	;ZERO OUT GC'ED AREA
QGCEX:	CAML E,A
	JRST QGCA
	PUSHJ P,QGCDEP
	JRST QGCEX

QGCX1:	TDZA A,A
QNORUM:	MOVNI A,1
	MOVE T,QSNLCN(H)
	MOVE T,UDNAME(T)
	CAME T,QSNUD(H)
	JRST 4,.
	IRPC A,,RTJIQEDCB
	POP P,A
TERMIN
	SKIPL A
	AOS -1(P)
	POP P,A
	MOVE TT,QACTB
	IORM TT,QSNLCN(H)	;SET DIR CHANGED
	POPJ P,

QGC2:	PUSHJ P,QFFLC	;FOUND SOMETHING IN DESC. AREA
	DPB E,[UNDSCP+UNRNDM(B)]	;SETS UP R TO LINK STATUS
	HRRZ T,B
	MOVE J,A
QGC2C:	PUSHJ P,QBFTCH	;GET BYTE AGAIN POINTED TO BY A
	PUSHJ P,QGCDEP	;DEPOSIT IN BYTE POINTED TO BY E
	JUMPN R,QGC2C1	;LINK
	TRNE D,40
	AOJA A,QGC2G
QGC2C1:	JUMPE D,QGC2F
	AOJA A,QGC2C

QGC2G:	PUSHJ P,QBFTCH
	PUSHJ P,QGCDEP
	REPEAT NXLBYT-1,[
	AOS A
	PUSHJ P,QBFTCH
	PUSHJ P,QGCDEP
]
	AOJA A,QGC2C

QGC2F:	SOS E
	PUSHJ P,QGCRL
	AOS E
	AOJA A,QGC1

QGCRL:	MOVSI TT,-NQCHN	;RELOCTATE CHNL PNTRS
	HRRZ D,QSNLCN(H)
	SUB T,D
	MOVE C,E	;A OLD END J OLD START E NEW END
	SUB C,A		;NEG RELOCATION CONST
QGC2D:	HRRZ D,QUDPR(TT)
	SKIPL QUSR(TT)
	CAIE D,(H)
	JRST QGC2E
	CAME T,QUDFPR(TT)
	JRST QGC2H
	CAMG J,QDIRP(TT)
	CAMGE A,QDIRP(TT)
	JRST 4,.	;HIS QUDFPR POINTS TO THE FILE BUT QDIRP DOESN'T POINT TO DESC
	ADDM C,QDIRP(TT)
QGC2E:	AOBJN TT,QGC2D
	POPJ P,

QGC2H:	SKIPN QUDFPR(TT)
	JRST QGC2E
	CAMG J,QDIRP(TT)
	CAMGE A,QDIRP(TT)
	JRST QGC2E
	JRST 4,.	;HIS QDIRP POINTS TO DESC BUT QUDFPR DOESN'T POINT TO THE FILE

QFFLC:	PUSHJ P,QCOFL	;FIND FILE WITH CHAR ADR IN A
	JRST QFFLC1	;CLEAR EXAMINED BIT
	JRST 4,.	;NO FILE WITH THIS ADR

QFFLC1:	LDB TT,[UNDSCP+UNRNDM(B)]
	CAME A,TT
	POPJ P,
	LDB R,[UNLNKB+UNRNDM(B)]	;R .NE. 0 IF A LINK
	MOVSI TT,UNMARK
	ANDCAM TT,UNRNDM(B)
	SUB P,[2,,2]
	POPJ P,

QCFL:	MOVEI TT,0	;COUNT # OF OPEN FILES, RESULT IN TT
	PUSHJ P,QCOFL
	JRST QCFL1
	POPJ P,

QCFL1:	MOVE D,UNRNDM(B)
	TLNE D,UNWRIT
	AOS TT
	POPJ P,

QCOFL:	HRRZ B,QSNLCN(H)	;PUSHJ @(P) FOR EACH FILE. PTR TO FILE IN B
	HRRZ C,UDNAMP(B)
	ADD C,B
	MOVEI B,2000(B)
QCOF1:	SUBI B,LUNBLK
	CAMGE B,C
	JRST POPJ1
	SKIPN UNFN1(B)
	SKIPE UNFN2(B)
	PUSHJ P,@(P)
	JRST QCOF1

;C_CHAR PTR

QBFTCH:	MOVE C,A	;A HAS CHAR ADR, RET CHAR IN D, BYTE PTR IN C
	MOVE B,QSNLCN(H)
	IDIVI C,UFDBPW
	HLL C,QBTBLI(D)
	ADDI C,UDDESC(B)
	ILDB D,C
	POPJ P,

QGCA:	PUSHJ P,QCHKBT	;CHECK TO SEE THAT ALL GC MARK BITS ARE OFF
	MOVE A,@QSNLCN(H)	;SPACE DESC AREA UP FOR OPEN FILES
	MOVE E,A	;E GETS CURRENT HIGHEST USED
	PUSHJ P,QCFL	;COUNT OF FILES OPEN FOR WRITING IN TT
	IMULI TT,3*6	;ALLOW EXTRA SPACE FOR OPEN FILES
	ADD E,TT
	AOS B,E
	IDIVI B,6
	MOVE C,QSNLCN(H)
	MOVE C,UDNAMP(C)
	CAIL B,-UDDESC-1(C)
	JRST QNORUM	;NO ROOM IN UFD
	MOVEM E,@QSNLCN(H)
	SOS E
	PUSHJ P,QSETBT	;SET CHECK BITS
QGCA2:	JUMPLE A,QGCA3	;THRU
	MOVE J,A	;FIND ORG OF FILE THAT PRECEEDS A
	MOVNI Q,1
	MOVEI A,0
	PUSHJ P,QBFTCH
QGCA2B:	CAML A,J	;SCAN FOR FIRST NON-ZERO CHR
	JRST QGCA2C
	JUMPN D,QGCA2A
	ILDB D,C
	AOJA A,QGCA2B

QGCA2A:	PUSH P,D
	PUSH P,J
	PUSH P,C
	PUSHJ P,QFFLC	;SET UP R TO LINK P
	IORM TT,UNRNDM(B)	;DONT REALLY WANT TO CLEAR CHECK BIT
	POP P,C
	POP P,J
	POP P,D
	MOVE Q,A	;RECORD ADR OF FIRST CHR OF FILE
QGC3F:	JUMPE D,QGC3D	;NOW FIND END OF FILE
	TRNE D,40
	JUMPE R,QGC3E	;ONLY ON NON-LINK

QGC3G:	ILDB D,C
	AOJA A,QGC3F

QGC3E:	IBP C
	REPEAT NXLBYT-1,[
	AOS A
	IBP C
]
	AOJA A,QGC3G

QGC3D:	MOVE I,A	;SAVE LOCN OF OLD END
	JRST QGCA2B

QGCA2C:	JUMPL Q,QGCA3
	MOVE A,Q
	PUSHJ P,QFFLC
	HRRZ T,B
	MOVE B,UNRNDM(T)
	TLNE B,UNWRIT
	JRST QGCA8	;THIS FILE OPEN ALLOW EXTRA ROOM
QGCA8A:	MOVE A,I	;I HAS CHR ADR OF 0 TERM FILE
	PUSH P,E	;SAVE NEW END
QGC2I:	CAMGE A,Q
	AOJA A,QGCA2H
	PUSHJ P,QBFTCH
	PUSHJ P,QGCDEP
	SUBI E,2
	SOJA A,QGC2I
QGCA2H:	AOS E
	DPB E,[UNDSCP+UNRNDM(T)]
	MOVE J,Q	;OLD START
	EXCH A,I	;SAVE A, LOAD A WITH OLD END
	EXCH E,(P)	;SAVE E, LOAD E WITH NEW END
	PUSHJ P,QGCRL
	MOVE A,I
	POP P,E
	SOJA E,QGCA2

QGCA3:	JUMPL E,QGCA3A
	MOVEI D,0
	PUSHJ P,QGCDEP
	SUBI E,2
	JRST QGCA3
QGCA3A:	PUSHJ P,QCHKBT
	PUSHJ P,QSETBT	;PERFORM FINAL CHECK
	MOVEI A,0
QGCH1:	CAML A,@QSNLCN(H)
	JRST QGCH2
	PUSHJ P,QBFTCH
	JUMPN D,QGCH3
	AOJA A,QGCH1

QGCH3:	PUSHJ P,QFFLC	;FIND FILE
	MOVE TT,UNRNDM(B)
	HRRZ T,B
	MOVE J,A
QGCH5:	PUSHJ P,QBFTCH
	JUMPE D,QGCH4
	SKIPN R	;SKIP ON LINK
	TRNN D,40
QGCH6:	AOJA A,QGCH5
	REPEAT NXLBYT-1,[
	AOS A
]
	AOJA A,QGCH6

QGCH4:	MOVE Q,TT
	HRRZ D,QSNLCN(H)
	SUB T,D
	MOVSI C,-NQCHN	;CHECK CHNLS TO MAKE SURE THEY ARE STILL REASONABLE
QGCH4B:	HRRZ D,QUDPR(C)
	SKIPL QUSR(C)
	CAIE D,(H)
	JRST QGCH4A
	CAME T,QUDFPR(C)
	JRST QGCH4C
	CAMG J,QDIRP(C)
	CAMGE A,QDIRP(C)
	JRST 4,.
	LDB D,[000300,,QSRAC(C)]	;CHECK FOR WRITEOVER MODE
	JUMPN D,QGCH4D	;QSCRW MIGHT BE ZERO IN WRITEOVER MODE
	SKIPL QSCRW(C)
	JRST QGCH4A
QGCH4D:	TLZN TT,UNWRIT
	JRST 4,.
QGCH4A:	AOBJN C,QGCH4B
	TLNE TT,UNWRIT
	JRST 4,.
	TLNN Q,UNWRIT
	JRST QGCH1
	REPEAT NXLBYT,[
	AOS A	;FILE OPEN SO MAKE SURE AT LEAST 3 MORE CHRS ARE 0
	PUSHJ P,QBFTCH
	JUMPN D,QGCH4E
]
	AOS A
	PUSHJ P,QBFTCH
	SKIPE D
QGCH4E:	JRST 4,.
	AOJA A,QGCH1

QGCH2:	PUSHJ P,QCHKBT
	JRST QGCX1

QGCH4C:	CAMG A,QDIRP(C)
	CAMGE J,QDIRP(C)
	JRST QGCH4A
	JRST 4,.

QGCA8:	MOVE A,E
	MOVEI D,0
QGCA8B:	PUSHJ P,QGCDEP
	SUBI E,2
	CAIE E,-3*6(A)
	JRST QGCA8B
	JRST QGCA8A

QGCDEP:	MOVE B,QSNLCN(H)
	PUSH P,D
	MOVE C,E
	IDIVI C,UFDBPW
	HLL C,QBTBLI(D)
	ADDI C,UDDESC(B)
	POP P,D
	IDPB D,C
	AOJA E,CPOPJ

QSETBT:	PUSHJ P,QCOFL
	JRST QSTBT
	POPJ P,

QSTBT:	MOVSI TT,UNMARK
	IORM TT,UNRNDM(B)
	POPJ P,

QCHKBT:	PUSHJ P,QCOFL
	JRST QCHBT
	POPJ P,

QCHBT:	MOVE Q,UNRNDM(B)
	TLNE Q,UNMARK
	JRST 4,.	;DESC POINTER DOESN'T POINT TO A DESCRIPTION
	POPJ P,

QFNTR:	MOVE H,QUDPR(A)	;WD # IN Q CHNL # IN A
	PUSHJ P,QUDLK	;DONT SKIP IF OFF FILE
	MOVE T,QSNLCN(H)	;RETN BLOCK IN QSLGL(A) AND QSBI(A)  DIR PNTR IN QDIRP(A)
	ADD T,QUDFPR(A)	;FIRST ADR OF BLOCK IN QFBLNO(A)
	LDB TT,[UNDSCP+UNRNDM(T)]	;CHAR ADR OF FILE BEG
	MOVEM TT,QDIRP(A)	;SKIPS IF FINDS BLOCK AND LEAVES USER DIR LOCKED
	CLEARM QSBI(A)
	CLEARM QFBLNO(A)
	CLEARB J,QSLGL(A)	;J HAS ORG OF FIRST NON-EX-BLOCK IF OFF END OF FILE
QFNT1A:	PUSHJ P,QFNT1
	JRST QUDULK	;OFF END OF FILE RETN NOT SKIPPING
	CAMLE J,Q
	JRST QFNT7	;LOCATED BLOCK CONTAINING WORD
	MOVEM J,QFBLNO(A)
	JRST QFNT1A

QFNTN:	MOVE H,QUDPR(A)	;LIKE ABOVE BUT SCAN FORWARD ONLY FROM CURRENT SPOT
	PUSHJ P,QUDLK	;ALSO ILUUO ON EOF
	PUSHJ P,QFNT1
	JRST ILUUO
	MOVEM J,QFBLNO(A)
	JRST QUDULK

QFNT1:	SKIPE QSBI(A)	;DECODE NEXT BLOCK, CHNL IN A
	JRST QFNT2	;SKIP UNLESS EOF, BLOCK # IN QSLGL FILE ADR IN J (TAKE N PENDING)
QFNT3:	PUSHJ P,QMPDCH	;GOBBLE NEXT CHR OF DESC IN R (POINTED TO BY QDIRP) INCR QDIRP
			;ALSO RET BYTE PNTR IN TT
	CAIN R,UDWPH
	JRST QFNT3	;NULL
	JUMPN R,QFNT8	;NOT OFF END OF FILE
	SOS QDIRP(A)
	POPJ P,

QFNT8:	TRZE R,40
	JRST QFNT4
	CAILE R,UDTKMX
	JRST QFNT6	;SKIP AND TAKE
	MOVEM R,QSBI(A)
QFNT2:	SOS QSBI(A)
	AOS QSLGL(A)
QFNT5:	MOVEI J,2000	;ACTIVE WORDS IN BLOCK
	ADD J,QFBLNO(A)
	JRST POPJ1

QFNT7:	MOVSI T,2	;SET UP PROC LAST BLOCK FLG AND RETN
	ANDCAM T,QSRAC(A)	;CLEAR LAST BLOCK OF FILE BIT
	SKIPE QSBI(A)
	JRST QFNT7A	;NOT LAST BLOCK
	ILDB R,TT	;GET NEXT CHR IN DIR
	JUMPN R,QFNT7A
	IORM T,QSRAC(A)	;PROCESSING LAST BLOCK
QFNT7A:	AOS QSBI(A)	;FAKE OUT PI ROUTINE WHICH WILL TRY TO INCREMENT
	SOS QSLGL(A)
	JRST POPJ1

QFNT4:	MOVEI J,0	;LOAD ADR
	DPB R,[140500,,J]
	PUSHJ P,QMPDCH
	DPB R,[060600,,J]
	PUSHJ P,QMPDCH
	DPB R,[0600,,J]
	MOVEM J,QSLGL(A)
	JRST QFNT5

QFNT6:	MOVEI J,1-UDTKMX(R)
	ADDM J,QSLGL(A)
	JRST QFNT5
EBLK

;2314 CHANNEL DATA AREAS

QBFP:	BLOCK NQCHN	;LH INPUT POINTER (INPUT PI FOR READ) RH OUTPUT
QUSR:	REPEAT NQCHN,-1	;USER
DWUSR:	-1	;0 IF DIR WRITE ACTIVE
SWUSR:	-1	;0 IF SWAP XFER ACTIVE
QDIRP:	BLOCK NQCHN	;CHAR ADR PNTR TO DESC AREA FOR FILE
QSLBLK:	BLOCK NQCHN+2	;LAST BLOCK NUMBER OF FILE WRITTEN
QSLGL:	BLOCK NQCHN	;LAST QSGL
QSGL:	REPEAT NQCHN+2,-1	;-1 IDLE + ACTIVE TRACK
			;LAST TWO FOR FD WRITE AND SWAPPING
QSBI:	BLOCK NQCHN	; COUNT CONSECUTIVE BLOCKS
QSBFS:	BLOCK NQCHN	;NUMBER OF BUFFS THIS CHNL
QPCLSR:	BLOCK NQCHN	;PCLSR STATUS OF MAIN PROGRAM
QSMDN:	BLOCK NQCHN	;MAIN PRGM ACTIVE BUFFER NUM
QSRAC:	BLOCK NQCHN+2	;4.9 CHNL LOCKED
			;4.8 EOF REACHED READ
			;4.6 CHNL IN ERR
			;4.5 EOF WRITE
			;4.4 TUT READ
			;4.3 DONT RELOAD. CORE TRANSFER HUNG ON ACTIVE BUFFER
			;4.2 USER DIR READ,TRACK NO IN QSLGL
			;4.1 MASTER DIR READ
			;3.9 CHNL HUNG IN DIR FULL
			;3.8 DELETE WHEN CLOSED
			;3.7 FILE ADDRESS ALTERED BY .ACCESS OR OTHERWISE
			;3.6 NON RECOV PARITY ERR ON READ
			;3.3 ASSOC USER OUT DONT RELOAD
			;3.2 READ CHNL PROCESSING LAST BLOCK FLAG
			;3.1 UPDATE QSMPRP, QSMPRC ON NEXT BUFFER GOBBLE
			;2.9 FILE NOT FULLY POPULATED FLAG
			;2.8 FILLING OUT LAST BLK OF FILE IN WRITE OVER MODE PAST ORIG EOF
			;2.7 READ INHIBIT
			;2.6 BLOCK AT A TIME MODE
			;2.5 CHNL IN PDUMP MODE
			;2.4 RETURN QSCABN BLOCK WHEN FINISHED WRITING (IN PDUMP MODE)
			;2.3 SWITCH OUT OF PDUMP MODE WHEN REATCH END OF LIST
			;1.3-1.1 READ/WRITE MODE 0 NORMAL 1 WRITE OVER 2 COPY OVER WRITE
QSMPRP:	BLOCK NQCHN	;MAIN PRGM POINTER (PROTECTED BY CORE ALLOCATOR)
QSMPRC:	BLOCK NQCHN	;M.P. COUNT
QDSKN:	BLOCK NQCHN	;DISK UNIT NUMBER
DWSKN:	0	;DISK WRITING DIR ON
SWSKN:	0	;DISK SWAP XFER
QSLDD:	BLOCK NQCHN+2	;-1 TRANSFER IMMINENT AT PI LEVEL
QSCRW:	BLOCK NQCHN	;0 READ -1 WRITE
	-1	;D.W.
	0	;SWAP
QSCABN:	BLOCK NQCHN	;ACTIVE BUFFER NUMBER PI LEVEL OR -1 IF NONE
DWABN:	-1	;DISK D.W. A.B.N
SWABN:	-1	;SWAP ABN
QUDPR:	BLOCK NQCHN	;NUMBER OF ASSOCIATED USER DIR PNTR
QUDFPR:	BLOCK NQCHN	;PTR TO FILE AREA
QMPTN:	BLOCK NQCHN	;MAIN PRGM TRACK NO 4.9 SAYS BLOCK RESERVED NOT YET COMMITTED
QMPTC:	BLOCK NQCHN	;MAIN PRGM TRACK COUNT
QMTTR:	BLOCK NQCHN	;TRACK RESERVED OR -1
QMFTP:	BLOCK NQCHN+2	;TRACK NUMBER FOR SCAN FOR FREE TRACKS IN TUT ON WRITE
			;AOBJN PTR TO BLKS TO BE WRITTEN ON SWAP IN READ
QERRS:	BLOCK NQCHN+2	;NUMBER ERRORS TRYING LAST OP
QFBLNO:	BLOCK NQCHN	;WD # IN FILE OF BEG OF BLOCK BEING PROCESSES AT M.P. LEVEL
QRADAD:	BLOCK NQCHN	;DESIRED ADR (LOOKED AT IF 3.7 IN QSRAC SET)
QAWMPB:	BLOCK NQCHN	;ACTIVE WORDS IN MN PROG ACTIVE BUFFER
QSMMP:	0		;MMP ADDRESS OF BLOCK ACTIVE ON SWAPPING CHANNEL



QPKNM:	BLOCK NQS	;NAME OF PACK
QPKID:	REPEAT NQS,-1	;PACK ID OF DISK ON DRIVE
QSPPS:	REPEAT NQS,-1	;POSITIONER POSITION
QMDRO:	-1		;ORIGIN OF MASTER DIR 4.9 IF LOCKED
			;-2 ON WAY IN 
			;4.6 NOT IN
			;4.5 CHANGED + NOT WRITTEN
			;4.2=1 NOT RECONCILED (NQFUS NOT SET UP)
			;3.1-3.5 MUST BE ZERO
QTUTO:	REPEAT NQS,-1	;ORG OF TUT BLOCK
			;LH SAME AS QMDRO EXCEPT
			;CHANGED AND NOT WRITTEN ON UNIT
			;0 = 4.5  1 = 4.4  2 = 4.3  3 = 4.1
			;3.1-3.5 MUST BE ZERO
QSKT1:	REPEAT NQS,-1	;CHANNEL POSITIONER SET FOR OR -1 IF NONE
QRCAL:	REPEAT NQS,0	;-1 IF RECALIBRATING
QSFT:	BLOCK NQS	;NUMBER TRACKS FREE IN USER AREA
QSFTS:	BLOCK NQS	;NUMBER TRACKS FREE IN SWAPPING AREA
QSDWI:	BLOCK NQS	;DIRECTORY WRITE IN PROGRESS
QDPWF:	BLOCK NQS	;-1 DIR NOT RECONCILED
IFN DECDKC,[
QSEEK:	BLOCK NQS	;-1 SEEKING
QPOS:	REPEAT NQS,-1	;DISK POS (AS READ WITH DATAI DPC,)
]
QACT:	0	;ONLY USE UNITS WITH 0
	0
	0
QACTB:	0	;4.5 UNIT 0 ACT  4.4 1 ACT  4.3 2 4.1 3

;PDUMP MODE
;QBFP LINKS INSTEAD TO INDEXES IN MMPDMP

;WD0  (RH) LINK OR END (377) LH 4.9 RETURN MEM AFTER WRITE
;  USED FOR FIRST BLOCK CONTAINING PG WDS
;WD1  (LH) TRK # (RH) MEM BLOCK #

MMPDFS:	MMPDMP	;FREE STG PNTR TO MMPDMP AREA
MMPDMP:	REPEAT 20.,[	.+2
		0
]
	0
	0

NPDBLK:	0	;TOTAL NUMBER BLOCKS IN PDUMP LISTS

;DELETE CONTROL SWITCHES
DSKSS:	-1	;DISK STORAGE STATE ;-1 ADEQUATE DSK SPACE (>MDSKFR)
			;0 TRYING EXTRA RECLAIM CYCLE
			;1 HAVE TRYED EXTRA CYCLE AND LOST, REALLY DELETE DELETED FILES

DSKPDF:	-1	;-1 NORMAL 0 HAVE TRIED EXTRA RECLAIM CYCLE IN LAST 1/2 HOUR

QSDU:	-1	;UNIT TRANSFERING DATA
QSDCH:	-1	;CHNL READY TO BE TRANSFERED ON QSDU
QERS1:	-1	;ERR VERIFY SWITCH -1 NO ERR 0 EXPECTING COMPLETION OF VERIFY OP

QNUD==40.		;NUMBER USER DIRECTORIES
QSNUD:	BLOCK QNUD	;USER NAME OR 0 IF FREE
QSNLCN:	BLOCK QNUD	;4.9 LOCKED, 4.8 ALSO NOT IN CORE RH CORE ADR
			;4.7 NEWLY CREATED 4.6 =1 NOT PAWED OVER 4.5 CHNGD AND NOT WRITTEN ON UNIT 0
			; 4.4 UNIT 1 4.3 UNIT 2 4.1 UNIT 3 @ + XR BITS MUST = 0
QSNNR:	BLOCK QNUD	;NUMBER PC'S LOOKING AT THIS IE
			;+1 FOR FILE OPEN AND USER IN CORE +1 FOR DIRECTORY
			; CHNL AND USER IN CORE
QSNMI:	BLOCK QNUD	;TRACK N OF USER DIR IF NOT NEWLY CREATED
NQFUS:	0	;NUMBER FREE LOSER SLOTS IN MFD
MXLNKS==10	;MAX LINK DEPTH

QTUNT:	0	;UNIT TO TRANSFER ON
QTCHN:	0	;CHNL
QTKT2:	0	;QSKT2 OF ABOVE
QWRU:	0	;DEFAULT WRITE UNIT
MDSK:	0	;DRIVE # OF MASTER DISK
QFLPK:	-1	;PK # OF DECEASED PACK
		;SEE R.G. BEFORE ACTIVATING THIS FEATURE
UDRSW:	-1	;USER DIR AREA LOCKED
	0
QCHSW:	-1	;CHNL AREA LOCKED
	0
QSKOSW:	-1	;QSKO1 LOCKED
	0
QDWIP:	0	;NUMBER OF DIR WRITE IN PROGRESS 4.9=1=>MASTER
QACTTM:	-1	;SETOM ON READ OR WRITE DATA TRANSFERR
		;AOS AT SSLCK IF + OK TO WRITE DIRS
		;IE DON'T TIE UP DISK TO WRITE DIR UNLESS THINGS ARE QUIET
LQTM:	0	;TIME AT WHICH LAST COMMAND GIVEN TO DISK
QAMDNO:	-1	;ASCENDING MASTER DIRECTORY NUMBER -1 NOT SET UP
SWPDSK:	0	;"SWAP DISK"

QFTTHR:	600.	;IF FREE TRKS ON QWRU GOES BELOW THIS, SWITCH TO UNIT WITH MOST FREE TRACKS
DCHBT:	20000,,	;BIT SET IF DIR NOT WRITTEN OUT ON UNIT
	10000,,
	4000,,
	1000,,

IFE DECDKC,[
QRCSW:	105	;- NOR READ COMPARE 0 COMPARE WRITES + COMPARE ALL
QCST:	0	;CONI DC0, AT QINT
QERST:	0	;HAS CONI DC1, BITS WHEN AN ERROR HAPPENS
PKIDM:	0	;-1 WAITING FOR PACK ID TO BE READ
RPKID:	-1
	0	;FOR BLT INTO QXWDS
]
QXWDS:	BLOCK NXWDS

IFE DECDKC,[
QCHPRG:	0
QCHPR2:	DCOPY (-2000_2&37774)
	DCOPY (-NXWDS_2&37774)QXWDS
QCHPR4:	DHLT	;OR DRC
QCHPR3:	DCCOMP (-2000_2&37774)
	DCCOMP (-NXWDS_2&37774)QXWDS
	DHLT

GPKID:	DSPC+DSCRHD+DSWNUL+DUNENB+616300	;TUTBLK (3998.)
	DCOPY RPKID(37774)
	DHLT
QRECAL:	DSPC+DSRCAL+DUNENB

]
IFN DECDKC,[
QERST:	0	;CONI DPC, ON ERROR
QCST:	0	;CONI DPC, AT QINT
QCHPRG:	0	;SEEK COMM
QICWA:	-2000,,	;XFER DATA (HRRM ADR-1 IN RH)
	-NXWDS,,QXWDS-1
	-200+NXWDS,,0
	0

QRECAL:	700000,,
QGTBZY:	0	;FLAG FOR SOFTWARE AT INT

ICWA==34	;CROCK INITIAL CHNL BLOCK
]
BBLK
IFN DECDKC,[
QATTNS:	REPEAT NQS,500000+.RPCNT_14,,1_<10-.RPCNT>
;WORDS TO CLEAR ATTNS AND SELECT DRIVES
]


QICL:	PUSH P,R
	SKIPGE QUSR(A)
	JRST 4,.
	MOVSI Q,100
	ANDCAM Q,QSRAC(A)	;FLUSH RANDOM ACCESS HACKERY
	PUSHJ P,QICLW1	;WAIT FOR INPUT TO STOP
	PUSHJ P,SWTL
	QCHSW
	MOVE TT,QSRAC(D)
	TLNE TT,200	;DELETE?
	JRST QSICLD	;YES
	SETOM QUSR(D)
	PUSHJ P,LSWPOP
QICLX:	MOVE H,QUDPR(D)
	SOS QSNNR(H)
	POP P,R
	SETZM (R)
	POPJ P,

QICLW1:	MOVE D,A
	MOVSI C,200000
	IORM C,QSRAC(D)	;EOF
	CONO PI,UTCOFF
	SKIPGE QSGL(D)
	JRST QSICL3
	SKIPL QSCABN(D)
	JRST QSICL4
	SETOM QSGL(D)

QSICL3:	CONO PI,UTCON
QSICL5:	PUSHJ P,QSBRB1	;RETURN M.P. BUFFER IF ANY
QOCL7:	HRRZ A,QBFP(D)	;ALSO ENTER TO RETURN UNUSED READ BUFFER ON WRITE OVER MODE
QSICL2:	CAIL A,376
	JRST QSICL6
	LDB C,[MLO,,MEMBLT(A)]
	PUSHJ P,MEMR
	MOVE A,C
	SOS QSBFS(D)
	JRST QSICL2

QSICL6:	MOVE A,[SETZ 377]
	MOVEM A,QBFP(D)
	POPJ P,

QSICL4:	CONO PI,UTCON
	SKIPL QSGL(D)
	PUSHJ P,UFLS
	JRST QSICL5

QOCL:	PUSHJ P,QSOCL5	;OUTPUT CLOSE
QSOCL4:	MOVE D,A	;ENTRY FROM QA LINK
QSOCL6:	MOVE Q,QUDFPR(D)
	ADD Q,QSNLCN(H)
	MOVE A,UNFN1(Q)
	MOVE B,UNFN2(Q)
	PUSHJ P,QLOOK	;FILING OVER ANYTHING?
	JRST QSOCL3
	PUSHJ P,QSOCLD	;YES FLUSH IT
	PUSHJ P,QUDLK	;RELOCK DIR UNLOCKED BY QSOCLD ETC
	JRST QSOCL6	;MAKE SURE ONE HASN'T REAPPEARED WHILE DIR UNLOCKED

QSOCL5:	MOVE H,QSRAC(A)
	TRNE H,20000
	JRST QOCLPD	;PDUMP MODE
	LDB H,[300,,QSRAC(A)]	;RETURN WITH DIR LOCKED
	JUMPN H,QOCL6	;DONT HACK ACTIVE WD COUNT IN WRITEOVER MODE
QOCL6A:	MOVN D,QSMPRC(A)
	HLLZ Q,QSMPRP(A)
	JUMPE Q,QOCL3
	IDIVI D,5	;IN CHR MODE CONVRT TO WDS
QOCL3:	ADDB D,QAWMPB(A)	;ADJUST WD COUNT OF LAST BLOCK TO REFLECT WHATS USED
	CLEARM QSMPRC(A)	;SO WILL BE A NOOP IF PCLSR OUT AND COME BACK THRU HERE
QOCL4:	MOVSI Q,20000
	IORM Q,QSRAC(A)	;SET EOF BIT FOR QSBWW IN WRITE OVER MODE
	JUMPN H,QOCL5
	SKIPL QSMDN(A)	;NO M.P. BUFFER ANYWAY
	JUMPE D,QOCL1	;ABOUT TO WRITE NULL BLOCK, DON'T
QOCL5:	PUSHJ P,QSBWW
QOCL2:	SKIPLE QSBFS(A)	;WAIT FOR BUFFERS TO GO AWAY
	PUSHJ P,UFLS
	MOVE H,QUDPR(A)
	PUSHJ P,QUDLK
	SKIPN D,QMPTC(A)	;SKIP ON NEXT "N" STILL PENDING
	POPJ P,
	TLO D,400000
	PUSHJ P,QUDS	;STORE IT AWAY
	CLEARM QMPTC(A)
	POPJ P,

QOCLPD:	TRNN H,4000
	JRST QOCLP1	;TERMINATE PDUMP MODE
QOCLP2:	MOVEI T,20000
	TDNE T,QSRAC(A)
	PUSHJ P,UFLS	;WAIT UNTIL OUT OF PDUMP MODE
	JRST QSOCL5
QOCLP1:	SKIPL QSMDN(A)
	PUSHJ P,QSBWW	;FINISH PROCESSING THIS BUFFER
	MOVEI H,4000
	IORM H,QSRAC(A)	;INDICATE END OF WRITE LIST
	JRST QOCLP2

QOCL6:	SKIPGE QSCRW(A)
	PUSHJ P,UFLS
	SKIPL QSCABN(A)
	PUSHJ P,UFLS
	MOVE D,A
	LDB C,[0300,,QSRAC(D)]
	SOJN C,QOCL6C	;SET BLOCK AT A TIME ONLY IN WRITE OVER MODE
	MOVEI A,100000
	SKIPGE QSMDN(D)	;SET IT ONLY IF THERE IS NO MAIN PROGRAM BUFFER
	IORM A,QSRAC(D)
QOCL6C:	PUSHJ P,QOCL7
	MOVE A,D
	MOVE Q,QSRAC(A)
	MOVE B,QSBFS(A)
	JUMPE B,QOCL6B
	TLNE Q,20000
	JRST QOCL6B
	TLNE Q,200000
	SOS B,QSBFS(A)	;COMP FOR EXTRA AOS ON EOF READ
QOCL6B:	CAILE B,1
	JRST 4,.
	TRNE Q,200000
	JRST QOCL6A	;HACKING LAST BLOCK PAST EOF, UPDATE ACTIVE WD COUNT
	JRST QOCL4

QSOCL3:	MOVE Q,QUDFPR(D)
	MOVE TT,QSNLCN(H)
	ADDI Q,(TT)
	MOVSI T,UNWRIT
	ANDCAM T,UNRNDM(Q)	;CLEAR WRITE IN PROG
	MOVE T,UDNAMP(TT)	;MAKE SURE IT GOES BEFORE * FILE OF SAME NAME
	ADDI T,(TT)
	CAMN T,Q
	JRST QSOC3E	;NO PREV FILE
	MOVE J,Q
QSOC3A:	SUBI J,LUNBLK
	CAMN A,UNFN1(J)
	CAME B,UNFN2(J)
	JRST QSOC3B	;PREV FILE HAS DIFFERENT NAME
	CAILE J,(T)
	JRST QSOC3A
QSOC3C:	CAMN J,Q
	JRST QSOC3E
REPEAT LUNBLK,	PUSH P,.RPCNT(J)
	MOVE T,J
	HRL T,Q
	BLT T,LUNBLK-1(J)
REPEAT LUNBLK,	POP P,LUNBLK-.RPCNT-1(Q)
	SUB Q,J
	SUBI J,(TT)
	MOVSI T,-NQCHN
QSOC3D:	HRRZ A,QUDPR(T)
	SKIPL QUSR(T)
	CAIE A,(H)
	JRST QSOC3F
	HRRZ A,QUDFPR(T)
	CAIN A,(J)
	ADD A,Q
	MOVEM A,QUDFPR(T)
QSOC3F:	AOBJN T,QSOC3D
QSOC3E:	MOVE TT,QACTB	;DISK CHANGED WRITE U.F.D.'S
	IORM TT,QSNLCN(H)
	SETOM QUSR(D)
	MOVE T,QSNUD(H)
	MOVEI Q,200000
	CAMN T,[SIXBIT /.LPTR./]
	IORM Q,SUPCOR	;CLOSING FILE ON TPL DEVICE SO SET FLAG FOR SYS JOB
	PUSHJ P,QUDULK
	SOS QSNNR(H)
	SETZM (R)
	POPJ P,

QSOC3B:	ADDI J,LUNBLK
	JRST QSOC3C

QOCLR:	MOVE C,[SETZ I]
	MOVEI I,EOFCH
QSCLR1:	MOVE Q,QSMPRP(A)
	TLNN Q,760000	;ADJUST TO WORD BOUNDARY
	JRST QOCL
	PUSHJ P,QUAO
	JRST QSCLR1

QOCL1:	PUSHJ P,QSBRB	;DISCARD BUFFER
	SOS QSBFS(A)
	MOVE D,QDSKN(A)
	AOS QSFT(D)	;RESTORE TRACK
	JRST QOCL2
IFN DECDKC,	.INSRT MLSYS; DSK: ITSDIN >
IFE DECDKC,[

QINTE:	CONI DC1,TT
	CONO DC0,DCCLR+DCERR+DSKCHN	;CLEAR ERRORS
	MOVEM TT,QERST
	CONSZ DC0,300
	JRST .-1	;ACTIVE OR RUN?
	SKIPL QERS1
	JRST QERL1	;VERIFY ALSO LOST
	TRNE TT,400	;OVERRUN
	JRST QOVR
	TRNE TT,37
	JRST 4,.	;REALLY LOST BIG
	TRNE TT,140
	JRST QHE	;TRY TO RECALIBRATE
	SKIPGE PKIDM
	TRZ TT,2000	;IGNORE LENGTH ERROR IF READING PACK #
	TRNE TT,3600
	JRST QDE	;TRY AGAIN
	SKIPGE PKIDM
	TRNE TT,3777
	AOS NQSE	;SPURIOUS ERROR (NOT LENGTH ERROR IN PKIDM)
	JRST QINTX	;SPURIOUS ERROR

QINTAT:	CONI DC1,QERST
	CONO DC0,DCCLR+DCCATT+DSKCHN	;CLEAR ATTENTION
	LDB Q,[DSATDN+QERST]	;GET ATTENTION DRIVE NUMBER
	CAIGE Q,NQS
	SKIPL QRCAL(Q)
	JRST QINTX
	SETZM QRCAL(Q)
	CONO DC0,DCCLR+DCATEB+DSKCHN	;CLEAR ATTENTION ENABLE
	JRST QINTX

QINT:	MOVEM TT,QCST
	TRNE TT,DSSERR
	JRST QINTE
	TRNN TT,DSSAEB
	JRST QINTA	;ATENTION NOT ENABLED
	TRNE TT,DSSATT
	JRST QINTAT
QINTA:	SKIPL QERS1
	JRST QEROK	;OK ON VERIFY
	SKIPGE Q,QSDU
	JRST QINT1	;NOT EXPECTING DATA COMPLETION
	CONSZ DC0,300
	JRST DSKEX	;ACTIVE OR RUN
	AOSN PKIDM	;SKIP IF NOT FINISHED READING PACK ID
	JRST QSPKID
]
QINTA1:	MOVE C,QSDCH
QINTI:	CLEARM QSLDD(C)
	SKIPGE A,QSCABN(C)
	JRST 4,.
	SKIPGE QSCRW(C)
	JRST QINT2	;WRITE
	MOVE D,QSRAC(C)
	TLNE D,13000
	JRST QINTU2	;DIRECTORY IN OR TUT IN
	CAIN C,NQCHN+1
	JRST QSWPIF	;SWAP IN OF BLOCK COMPLETED
	MOVEI B,377
	IORM B,MEMBLT(A)
	HLRE B,QBFP(C)
	SKIPL B
	DPB A,[MLO,,MEMBLT(B)]
	SKIPGE B
	HRRM A,QBFP(C)
	HRLM A,QBFP(C)
	LDB B,[XWAWC+QXWDS]
	DPB B,[MWC,,MEMBLT(A)]	;STORE ACTIVE WORD COUNT
	AOS QSBFS(C)
	LDB B,[XWBLK QXWDS]
	MOVEM B,QSLBLK(C)
QINT1B:	SETOM QACTTM
QINT1A:	SETOM QSGL(C)
	SETOM QSKT1(Q)
	SETOM QSDU
	SETOM QSCABN(C)

QINT1:	SKIPL SWUSR
	JRST QSLSW1	;SWAPPING ALREADY ACTIVE
	MOVE A,MEMFR
	SUB A,NCBCOM
	MOVEI B,0	;CHECK FOR SWAP IN
	MOVEI C,1	;OR OUT
	CAIGE A,20.	;ACCORDING TO AVAIL MEM
	EXCH B,C
	SKIPN SINLST(B)
	MOVE B,C	;NOTHING HERE MAKE SURE TO CHECK SWAP OUT
	SKIPN C,SINLST(B)
	JRST QSLSW1	;WHAT A SHAME
	SOSGE D,SILNG(B)
	JRST 4,.
	CAMN C,SILEND(B)
	JUMPN D,[JRST 4,.]	;PNTRS OUT OF PHASE
	JUMPN D,QSWOPP
	CAME C,SILEND(B)
	JRST 4,.	;LIKEWISE
QSWOPP:	MOVEI D,SINLST(B)
	CAMN C,SILEND(B)
	MOVEM D,SILEND(B)
	SUBI C,MMSWP	;GET BLOCK #
	CAIGE C,TSYSM
	CAIGE C,SYSB
	JRST 4,.
	MOVS D,MMSWP(C)
	LDB E,[410200,,(D)]
	TRNN E,1
	JRST 4,.	;NOT IN TRANSIT?
	HLRZM D,SINLST(B)	;PATCH OUT OF LIST
	HRRZM D,QSMMP	;SAVE MMP ADDRESS
	HRRZM C,QSCABN+NQCHN+1
	CLEARM SWUSR	;CHNL ACTIVE
	LDB E,[221700,,MEMPNT(C)]
	MOVEM E,QSGL+NQCHN+1	;DISK BLOCK
	LDB E,[410300,,MEMPNT(C)]
	CAIL E,NQS
	JRST 4,.	;DISK NUMBER BAD
	MOVEM E,SWSKN	;UNIT
	CLEARM QSRAC+NQCHN+1
	MOVNM B,QSCRW+NQCHN+1	;DIRECTION
	CLEARM QERRS+NQCHN+1	;NO ERRORS (YET)
QSLSW1:	SETOM QTUNT
	MOVSI C,-NQCHN-2	;-1 FOR DIR WRITE CHNL -1 FOR SWAP CHNL
QINT2L:	SKIPL D,QSRAC(C)
	SKIPGE QUSR(C)
	JRST QINT2C
	MOVE Q,QDSKN(C)
	SKIPGE E,QSGL(C)
	JRST QINT2D	;NO BUFFER ACTIVE AT PI ACTIVATE ONE IF POSSIBLE
QINT4E:	SKIPGE QSCABN(C)
	JRST QINT5	;READ GET MEMORY
QINT4R:	SKIPGE QRCAL(Q)	;SKIP IF DRIVE NOT BEING RECALIBRATED
	JRST QINT2C
	HRRZ B,QSKT1(Q)
	CAIN B,(C)
	JRST QINT2F	;ALREADY SET FOR ME
	SKIPL QSKT1(Q)
	JRST QINT2C	;SET FOR SOME OTHER CHNL
	HRRZM C,QSKT1(Q)
	PUSHJ P,QPOSR
IFE DECDKC,[
	ADD E,[DSEEK]
	CONSZ DC0,300
	JRST 4,.-1
	DATAO DC0,E
]
IFN DECDKC,[
	TLO E,(DSEEKC)	;DSK SEEK
	CONSZ DPC,20
	JRST 4,.-1
	LDB TT,[DCYL E]
	CAME TT,QPOS(Q)
	DATAO DPC,E
	SETOM QSEEK(Q)
]
QINT2F:	SKIPL QTUNT
	JRST QINT2C
QINT2G:	HRRZM Q,QTUNT
	HRRZM C,QTCHN

QINT2C:	AOBJN C,QINT2L
	SKIPGE Q,QTUNT
	JRST QINT3	;IDLE
QDE1:
IFE DECDKC,	MOVEM Q,QSDU
	MOVE C,QTCHN
	MOVEM C,QSDCH
	MOVE R,QSCABN(C)
	SKIPGE B,QSCRW(C)	;LOAD R/W STATUS IN B
	JRST QINT6W

IFN DECDKC,[
	MOVSI T,(DREADC)
	JRST QINT6A
]
IFE DECDKC,[
	MOVSI T,(DREAD)
QINT6A:	MOVEM T,QCHPRG
	DPB Q,[DUNFLD+QCHPRG]
	DPB R,[DCBN+QCHPR2]
	DPB R,[DCBN+QCHPR3]	;FOR POSSIBLE READ COMPARE
	MOVE E,QSGL(C)
	PUSHJ P,QPOSR
	IORB E,QCHPRG
	CLEARM QCHPR4	;STORE DHALT FOR NO RCC
	CAIN C,NQCHN+1
	JRST QINT6S	;SWAPPING CHNL
	SKIPL B
	AOSA NRXFR
	AOS NWXFR
	CAIE C,NQCHN	;ALWAYS R COMPARE DIR WRITES
	SKIPLE QRCSW	;SKIP ON NOT READ COMP EVERYTHING
	JRST QINT6B	;RCC
	SKIPL QRCSW
	JUMPL B,QINT6B	;RCC WRITES
	MOVE D,QSRAC(C)
	TLNN D,13000
	JRST QINT6C	;NOT DIR READ
QINT6B:	TLZ E,340000	;CHANGE TO READ COMPARE
	MOVEM E,QCHPR4
QINT6C:	SETOM QSLDD(C)
	SETOM QERS1	;ERR VERIFY IND
QOVR:	CONSZ DC0,300
	JRST QOVR
	DATAO DC0,[DJMP QCHPRG]	;ENTRY ON OVERRUN
QERV3:	MOVE A,TIME
	MOVEM A,LQTM
QINTX:	JRST DSKEX

QINT6S:	SKIPL B
	AOSA NSRXFR
	AOS NSWXFR
	JUMPL B,QINT6B	;RCC WRITES
	JRST QINT6C	;NOT READS
]
QINT6W:	MOVE T,[QXWDS-1,,QXWDS]
	BLT T,QXWDS+3
	CAIL C,NQCHN
	JRST QNT6W2	;SWAP OR DIR WRITE
	MOVE A,QUDPR(C)
	MOVE T,QSNUD(A)
	MOVEM T,QXWDS+XWSYSN
	HRRZ A,QSNLCN(A)
	ADD A,QUDFPR(C)
	MOVE T,UNFN1(A)
	MOVEM T,QXWDS+XWFN1
	MOVE T,UNFN2(A)
	MOVEM T,QXWDS+XWFN2
	MOVE T,QSLBLK(C)
	DPB T,[XWBLK+QXWDS]
	LDB T,[MWC,,MEMBLT(R)]
	MOVE A,QSRAC(C)
	TRNE A,20000
	MOVEI T,0	;ALL BLOCKS FULL SIZE IN PDUMP MODE
	DPB T,[XWAWC+QXWDS]
QNT6W2:
IFE DECDKC,	MOVSI T,(DWRITE)
IFN DECDKC,	MOVSI T,(DWRITC)
	JRST QINT6A

QDE:
IFE DECDKC,	AOSE PKIDM
	SKIPGE Q,QSDU
	JRST 4,.
	MOVE C,QSDCH
IFE DECDKC,[
	TRNE TT,200
	JRST .+3	;GET CKS ERR
	TRNE TT,1000
	AOS NQCMPE(Q)	;# COMPARE ERRORS
]
	AOS NQDE(Q)
	SKIPL R,QSCRW(C)
	AOSA NQRDE(Q)
	AOS NQWDE(Q)
IFE DECDKC,	JUMPL R,QERV1	;DO ANOTHER RD/COMP TO SEE IF OK ON DSK (IF WRITE)
QERV2:	AOS R,QERRS(C)
	CAIG R,50.	;TRY 50 TIMES
	JRST QDE1
	CAIG R,1000
	JRST QDE2	;TRY REPOSITION
	SKIPGE QSCRW(C)
	JRST QDE1	;DON'T TRY TO DO ANYTHING ABOUT WRITE ERRORS
	MOVE R,QSRAC(C)
	TLNE R,11000
	JRST QDE1	;MASTER DIR READ OR TUT READ
	TLNE R,2000
	JRST QUDER1	;USER DIR READ
			;USER DATA
	JRST QPE2D


IFE DECDKC,[
QERV1:	SKIPN QCHPR4
	JRST QERV2	;NOT SET FOR RCC
	CLEARM QERS1
QERL2:	CONSZ DC0,300
	JRST .-1
	DATAO DC0,[DJMP QCHPR4]
	JRST QERV3

QERL1:	AOS Q,QERS1
	CAIGE Q,50.
	JRST QERL2
	AOSA NQWIRE
QEROK:	AOS NQWRE
	MOVE C,QSDCH
	MOVE Q,QSDU
	SETOM QERS1
	JRST QERV2
]
QDE2:	MOVEI R,1001
	MOVEM R,QERRS(C)	;CLOBBER QERRS
	JRST QREC	;AND TRY REPOSITIONING

QHE:	SKIPGE Q,QSDU
	JRST 4,.
	MOVE C,QSDCH
	AOS NQHE(Q)
	AOS E,QERRS(C)
	CAIL E,5.
	JRST QHE2
QREC:
IFE DECDKC,[
	CONSZ DC0,DSSAEB
	JRST 4,.	;TWO DRIVES RECALIBRATING AT ONCE
	CONO DC0,DCCLR+DCCATT+DSKCHN
	CONSZ DC0,DSSATT
	JRST .-2	;ATT SET ON OTHER DRIVE
]
	DPB Q,[DUNFLD+QRECAL]
IFE DECDKC,[
	DATAO DC0,QRECAL
	CONO DC0,DCSET+DCATEB+DSKCHN	;ENABLE ATTENTION
]
IFN DECDKC,[
	SETOM QPOS(Q)
	DATAO DPC,QRECAL
]
	CLEARM QSPPS(Q)
	SETOM QSKT1(Q)
	SETOM QRCAL(Q)	;INDICATE RECALIBRATING THIS DISK
IFE DECDKC,[
	SETOM QSDU
	JRST QINT1	;LOOK FOR SOME OTHER TRANSFER
]
IFN DECDKC,[
	MOVEM Q,QSDU
	JRST DSKEX
]

QHE2:	SKIPGE QSCRW(C)	;HANG UP OR POSITIONING ERR (AFTER 5 TRIES)
	JRST QPE2D	;WRITE
	MOVE R,QSRAC(C)
	TLNE R,11000
	JRST QREC	;MASTER DIR READ OR TUT READ
	TLNE R,2000
	JRST QUDER1	;UFD, TRY OTHER DISK
QPE2D:	MOVSI R,40
	IORM R,QSRAC(C)
	AOS QIRRCV	;IRRECOVERABLE ERR
	MOVE A,QSGL(C)
	MOVEM A,QIRCBK	;BLOCK # AT IRRCV ERR
	MOVEM C,QIRUNT	;SAVE UNIT TOO
	CAIN C,NQCHN+1
	AOS NIRSWE	;# IRRCV SWAPPING ERRS
	JRST QINTI	;IF POSITIONING ERR ON WRITE, IGNORE AFTER 5 TRIES

QINT2D:	HRRZ J,C
	CAIN J,NQCHN+1
	JRST 4,.	;NO MEMORY WAS ASSIGNED
	SETZM QERRS(C)
	TLNE D,13000
	JRST QINTU1	;READ USER OR MASTER DIRECTORY OR TUT
	MOVE J,QUDPR(C)
	SKIPGE QSNLCN(J)
	JRST QINT2C	;USER DIRECTORY OUT OR LOCKED
	SKIPGE QSCRW(C)
	JRST QINT4	;WRITE
	TDNE D,[204104,,100000]	;EOF OR DONT RELOAD OR USER OUT OR READ INHIBIT
	JRST QINT2C
	MOVE A,QSBFS(C)
	CAIL A,2
	JRST QINT2C
	TRNE D,40000
	JRST QINT2N	;BLOCK AT A TIME
	LDB D,[300,,QSRAC(C)]
	SKIPE D	;SKIP ON NORMAL READ
QINT2N:	JUMPN A,QINT2C	;ONLY ONE BUFFER ACTIVE ON WRITE OVER ETC
	SKIPE QSBI(C)
	JRST QINT4A
QINT2E:	PUSHJ P,QIDRCH	;ALSO RET BYTE PNTR IN TT
	CAIN A,UDWPH
	JRST QINT2E
	JUMPE A,QEOF
	TRZE A,40
	JRST QINT4C
	CAILE A,UDTKMX
	JRST QINT4D	;SKIP AND TAKE
	MOVEM A,QSBI(C)	;TAKE NEXT N
QINT4A:	SOS QSBI(C)
	AOS E,QSLGL(C)
QINT4G:	MOVEM E,QSGL(C)
	MOVSI B,2
	ANDCAM B,QSRAC(C)	;CLEAR PROCESSING LAST BLOCK N FILE BIT
	SKIPE QSBI(C)
	JRST QINT4E
	PUSHJ P,QIDRCH	;GET NEXT DESCR BYTE
	SOS QDIRP(C)	;CORRECT PNTR
	JUMPN A,QINT4E
	IORM B,QSRAC(C)
	JRST QINT4E

QUDER4:	SKIPGE QACT(R)
	AOJA R,QUDER2
	HRRM R,QDSKN(C)	;TRY THIS DISK
	SETZM QSLDD(C)
	SETOM QSKT1(Q)
	SETOM QSDU
	SETOM QTUNT
	MOVE E,QSGL(C)
	MOVE Q,QDSKN(C)
	SETZM QERRS(C)
	JRST QINT4R

QUDER1:	MOVEI R,1(Q)	;TRY TO READ DIR FROM OTHER DISKS
QUDER2:	CAIL R,NQS
	MOVEI R,0
	CAME R,QDSKN(C)
	JRST QUDER4
	JRST QDE1	;NO OTHER DISK AVAIL TO READ FROM

QIDRCH:	MOVE TT,QDIRP(C)	;CHNL IN C PNTR TO QSNUD IN J LOAD NEXT CHR INTO A
	AOS QDIRP(C)	;ALSO RET BYTE PNTR IN TT
	IDIVI TT,UFDBPW
	HLL TT,QBTBL(I)
	HRRZ I,QSNLCN(J)
	ADDI TT,UDDESC(I)
	LDB A,TT
	POPJ P,

QMPDCH:	MOVE TT,QDIRP(A)	;CHNL IN A PNTR TO QSNUD IN H LOADS NEXT CHR IN R
	AOS QDIRP(A)	;USED AT M.P. LEVEL
QMPDC1:	IDIVI TT,UFDBPW	;ALSO RETN BYTE PNTR IN TT
	HLL TT,QBTBL(I)
	HRRZ I,QSNLCN(H)
	ADDI TT,UDDESC(I)
	LDB R,TT
	POPJ P,

QINTU1:	MOVE E,QSLGL(C)
	MOVEM E,QSGL(C)
	JRST QINT4E

QINTU2:	MOVE R,A
	LSH R,10.
	TLNN D,2000
	JRST QINTU3
	MOVE TT,QUDPR(C)	;USER DIR IN OK
	MOVE D,UDNAME(R)
	CAME D,QSNUD(TT)	;COMPARE UNAME IN DIR WITH RQ'ED
	JRST QUDER1
	TLO R,40000	;NOT PAWED OVER
	MOVEM R,QSNLCN(TT)
	MOVE R,QSLGL(C)
	MOVEM R,QSNMI(TT)
	MOVEI R,MU23UD	;USER DIRECTORY
QINTU4:	DPB R,[MUR,,MEMBLT(A)]
	DPB TT,[MLO,,MEMBLT(A)]
	SETOM QUSR(C)
	JRST QINT1A

QINTU3:	TLNN D,1000
	JRST QINTU5	;TUT IN
	TLO R,2	;NOT RECONCILED
	MOVEM R,QMDRO	;MASTER DIRECTORY IN
	MOVE TT,(R)	;ASCENDING DIR #
	SKIPGE QAMDNO
	MOVEM TT,QAMDNO	;FIRST DISK IN STORE ASCENDING #
	MOVEI R,MU23MD	;MASTER DIRECTORY
	MOVE TT,Q	;DISK NO
	JRST QINTU4


QINTU5:	MOVEM R,QTUTO(Q)
	MOVE TT,Q	;DISK NUMBER
	MOVEI R,MU23TT	;TUT
	JRST QINTU4

QEOF:	MOVE D,QSRAC(C)
	SOS QDIRP(C)	;AVOID GC UNHAPPINESS
	MOVSI I,200000
	IORM I,QSRAC(C)
	AOS QSBFS(C)
	HLRE R,QBFP(C)
	SKIPL R
	SOSA I,MEMBLT(R)
	SOS I,QBFP(C)
	ANDI I,377
	CAIE I,376
	JRST 4,.
	JRST QINT2C

QINT4C:	MOVEI E,0
	DPB A,[140500,,E]
	PUSHJ P,QIDRCH
	DPB A,[060600,,E]
	PUSHJ P,QIDRCH
	DPB A,[0600,,E]
	MOVEM E,QSLGL(C)
	JRST QINT4G

QINT4D:	MOVEI E,1-UDTKMX(A)
	ADDB E,QSLGL(C)
	JRST QINT4G

QINT2:	MOVE TT,QSRAC(C)
	CAIN C,NQCHN
	JRST QDWF	;FINISHED DIR WRITE
	CAIN C,NQCHN+1
	JRST QSWPFN	;FINISHED SWAPPING OUT PAGE
	TRNE TT,20000
	JRST QNT2P	;IN PDUMP MODE
QNT2P1:	TLNN TT,4000
	PUSHJ P,IMEMR
	TLNE TT,4000
	PUSHJ P,CIMEMR
QNT2P2:	SOS QSBFS(C)
	MOVE TT,QSGL(C)
	MOVEM TT,QSLBLK(C)
	LDB TT,[300,,QSRAC(C)]
	SOJN TT,QINT1B	;NORMAL WRITE
	CLEARM QSCRW(C)	;WRITE OVER SWITCH TO READ MODE
	MOVE TT,QSRAC(C)
	TLZN TT,20000	;SKIP IF TRYING TO CLOSE
	JRST QINT1B
	TLO TT,200000
	MOVEM TT,QSRAC(C)
	JRST QINT1B

QNT2P:	MOVSI B,-1
	ADDM B,MMSWP(A)
	TRNE TT,10000
	JRST QNT2P1	;RETURN MEM
	JRST QNT2P2	;DONT

QDWF:	MOVSI E,(SETZ)
	SKIPGE TT,QDWIP
	JRST QDWMF
	MOVSI A,200000
	TDNE A,QDWIP
	JRST QDWFT
	ANDCAM E,QSNLCN(TT)
QDWF1:	SETOM QUSR+NQCHN
	JRST QINT1A

QDWMF:	ANDCAM E,QMDRO
	JRST QDWF1

QDWFT:	ANDCAM E,QTUTO(TT)
	JRST QDWF1

QSWPFN:	MOVSI E,40000
	IORM E,@QSMMP	;SET HAS BEEN WRITTEN ON DISK
	PUSHJ P,IMEMR
QSWPF2:	LDB D,[410200,,@QSMMP]
	SOS D
	TRNE D,1
	JRST 4,.	;NOT IN TRANSIT?
	DPB D,[410200,,@QSMMP]	;NOT ON WAY IN OR OUT
	SETOM SWUSR	;SWAPPING IDLE
	JRST QINT1B

QSWPIF:	MOVEI TT,MURUSR
	DPB TT,[MUR,,MEMBLT(A)]
	MOVE E,QSCABN+NQCHN+1
	SETZM MMSWP(E)
	SKIPL CIRPSW
	JRST QSWPF2	;CIRPSW NOT AVAILABLE, CAN'T DO ANYTHING NOW
	PUSH P,C
	PUSH P,Q
	MOVE C,[2200,,MEMPNT(A)]
	PUSHJ P,UCPRL
	400000,,QSWI1
	POP P,Q
	POP P,C
	JRST QSWPF2

QSWI1:	CAIG U,LUBLK
	JRST 4,.	;SYS JOB OR CORE JOB
	PUSH P,I	;SET UP MAP TO MEMBLT INDEX IN E
	MOVE C,UDBR1(U)
	TRZE I,200
	MOVE C,UDBR2(U)
	ROT I,-1
	ADDI C,(I)
	HRLI C,222200
	SKIPGE I
	HRLI C,2200
	LDB I,C
	JUMPE I,[JRST 4,.]	;DOESN'T REALLY EXIST?
	TRNE I,600000
	JRST QSWI2	;ALREADY IN MAP, POSSIBLE AS A RESULT OF RIDICULOUS TIMING ERROR
	CAILE I,2
	MOVEI I,2	;SET READ/WRITE TO READ/WRITE/FIRST
	SKIPN (P)
	MOVEI I,3	;VIRTUAL PAGE ZERO ALWAYS READ/WRITE
	LSH I,16.
	IOR I,E
	DPB I,C
	SOS NSWPGS(U)
QSWI2:	AOS MMSWP(E)	;INCREMENT COUNT OF USERS IN RING
	POP P,I
	POPJ P,

QINT4:	TLNE D,4000
	JRST QINT2C	;DONT RELOAD
	HRRZ I,QBFP(C)
	TRNE D,20000
	JRST QINTP1	;PDUMP MODE
	CAIL I,376
	JRST QINT2C	;END OF WRITE LIST FOR NOW
	MOVEM I,QSCABN(C)
	LDB H,[MLO,,MEMBLT(I)]
	HRRM H,QBFP(C)
	MOVEI J,(SETZ)
	CAIL H,376
	HRLM J,QBFP(C)
	MOVEI J,-4
	DPB J,[MLO,,MEMBLT(I)]
	HLRZ E,MEMPNT(I)
	MOVEM E,QSGL(C)
	JRST QINT4R


QINTP2:	TRNN D,4000
	JRST QINT2C
	MOVEI D,34000	;LEAVE PDUMP MODE
	ANDCAM D,QSRAC(C)
	JRST QINT2C

QINTP1:	CAIL I,377
	JRST QINTP2	;NONE FOR NOW
	MOVE H,MMPDMP+1(I)
	HRRZM H,QSCABN(C)
	HLRZM H,QSGL(C)
	LDB H,[430100,,MMPDMP(I)]
	DPB H,[140100,,QSRAC(C)]	;RETURN MEM BIT
	HRRZ H,MMPDMP(I)
	HRRM H,QBFP(C)	;UPDATE CHNL LIST
	MOVEI J,(SETZ)
	CAIL H,377
	HRLM J,QBFP(C)
	ADDI I,MMPDMP	;RETURN BLOCK TO FREE
	EXCH I,MMPDFS
	MOVEM I,@MMPDFS
	SOS NPDBLK
	MOVE E,QSGL(C)
	JRST QINT4R

QINT5:	MOVSI D,11000
	TDNN D,QSRAC(C)
	JRST QINT5B	;NOT MFD OR TUT READ
	PUSHJ P,MMBRQ	;GET MEM THAT WON'T BE MOVED
	JRST QINT2C
	JRST QINT5A

QINT5B:	PUSHJ P,IOMQ	;GET MEMORY FOR READ BUFFER
	JRST QINT2C
QINT5A:	MOVEM A,QSCABN(C)
	MOVEI D,MU23B
	DPB D,[MUR,,MEMBLT(A)]
	DPB C,[M2311C,,MEMBLT(A)]
	MOVEI D,-4
	DPB D,[MLO,,MEMBLT(A)]
	JRST QINT4R

QINT3:	SKIPLE QACTTM	;LAST ACTIVITY TOO RECENT
	SKIPL DWUSR
	JRST QINT3X	;DIR CHNL IN USE
	SKIPGE H,QMDRO
	JRST QTDW
	MOVE J,QACTB
	TDNN J,H
	JRST QTDW
	MOVSI Q,-NQS
QMDW:	SKIPGE QACT(Q)
	JRST QMDWA	;UNIT NOT ACTIVE
	MOVE J,DCHBT(Q)
	TDNN J,QMDRO
	JRST QMDWA
	HRLI Q,(SETZ)	;INDICATE MFD WRITE IN PROGRESS
	MOVEM Q,QDWIP
	HRRZM Q,DWSKN
	MOVSI TT,(SETZ)
	IORB TT,QMDRO
	MOVE C,MDCHK(TT)
	CAME C,[SIXBIT /M.F.D./]
	JRST 4,.	;MFD CLOBBERRED
	HRRZ C,Q
	CAMN C,MDSK
	AOSA C,QAMDNO
	MOVE C,QAMDNO
	MOVEM C,MDNUM(TT)
	SETZM QSLDD+NQCHN
	SETZM DWUSR
	MOVEI TT,MFDBLK
	MOVEM TT,QSGL+NQCHN
	HRRZ TT,QMDRO
	LSH TT,-10.
	MOVEM TT,QSCABN+NQCHN
	ANDCAM J,QMDRO
	JRST QINT1

QMDWA:	AOBJN Q,QMDW
QTDW:	MOVSI Q,-NQS
QTDW1:	SKIPGE QACT(Q)
	JRST QTDWA
	MOVE J,DCHBT(Q)
	SKIPL QTUTO(Q)
	TDNN J,QTUTO(Q)
	JRST QTDWA
	MOVSI H,40000
	TDNE H,QTUTO(Q)
	JRST QTDWA1
	HRLI Q,200000
	MOVEM Q,QDWIP
	HRRZM Q,DWSKN
	MOVSI TT,(SETZ)
	IORB TT,QTUTO(Q)
	SETZM QSLDD+NQCHN
	SETZM DWUSR
	MOVEI TT,TUTBLK
	MOVEM TT,QSGL+NQCHN
	HRRZ TT,QTUTO(Q)
	LSH TT,-10.
	MOVEM TT,QSCABN+NQCHN
	ANDCAM J,QTUTO(Q)
	JRST QINT1

QTDWA1:	ANDCAM J,QTUTO(Q)
QTDWA:	AOBJN Q,QTDW1
	SKIPGE QMDRO
	JRST QINT3X
	MOVSI C,-QNUD
QDW4A:	MOVE J,QACTB	;BITS CORRESP TO ACTIVE DISKS
QDW4:	SKIPE TT,QSNUD(C)
	SKIPGE QSNLCN(C)
	JRST QDW3	;SLOT VACANT OR LOCKED
	TDNE J,QSNLCN(C)
	JRST QUDW1	;NEEDS TO BE WRITTEN ON SOME UNIT
QDW3:	AOBJN C,QDW4A
QINT3X:
IFE DECDKC,[
	CONO DC0,DCCLR+DCIENB+DSKCHN
	JRST DSKEX
]
IFN DECDKC,[
	CONO DPC,177700
	JRST DSKEX	;STUFF NEEDS TO BE DONE BUT CANT NOW
]

QUDW1:	MOVSI Q,-NQS
QUDW4:	SKIPGE QACT(Q)
	JRST QUDW3
	MOVE J,DCHBT(Q)
	TDNE J,QSNLCN(C)
	JRST QUDW2
QUDW3:	AOBJN Q,QUDW4
	JRST QDW3

QUDW2:	MOVE I,QMDRO
	TLNE I,40000
	JRST QUDW2B	;MASTER DIR NOT IN THIS UNIT
	HRRZS Q
	MOVSI I,100000
	TDNE I,QSNLCN(C)	;WRITE USER DIR IN C ON DISK IN Q NAME IN TT 
	JRST QUDW5	;NEWLY CREATED USER
QUDW2A:	MOVSI TT,(SETZ)
	IORB TT,QSNLCN(C)	;LOCK USER DIRECTORY
	MOVE J,QSNUD(C)
	CAME J,UDNAME(TT)
	JRST 4,.	;ABOUT TO WRITE BAD DIRECTORY
	CLEARM QSLDD+NQCHN
	CLEARM DWUSR
	MOVEM Q,DWSKN
	MOVE TT,QSNMI(C)
	MOVEM TT,QSGL+NQCHN
	HRRZ TT,QSNLCN(C)
	LSH TT,-10.
	MOVEM TT,QSCABN+NQCHN
	MOVE J,DCHBT(Q)
	ANDCAM J,QSNLCN(C)
	HRRZM C,QDWIP
	CLEARM QERRS+NQCHN
	JRST QINT1

QUDW2B:	ANDCAM J,QSNLCN(C)	;CLEAR BIT + GO AWAY
	JRST QUDW3

QUDW5:	MOVNI I,1
QUDW5B:	MOVE H,QMDRO
	MOVE I,MDNAMP(H)
	ADDI I,(H)
QUDW5C:	LDB E,[1200,,I]
	JUMPE E,QUDW5F
	SKIPN (I)
	JRST QUDW5G
	ADDI I,LMNBLK
	JRST QUDW5C

QUDW5G:	SUBI I,(H)	;GET REL MFD INDEX
	JRST QUDW5D

QUDW5F:	MOVNI I,LMNBLK
	ADDB I,MDNAMP(H)
	HRREI E,-2000(I)
	CAMGE E,[-NUDSL*2]
	JRST 4,.	;TOO MANY USERS (SHOULD NOT GET HERE)
QUDW5D:	SUBI I,2000-2*NUDSL	;GET USER SLOT NO
	ADDI H,2000-2*NUDSL(I)
	MOVEM TT,(H)
	LSH I,-1
	MOVEM I,QSNMI(C)
	MOVSI I,100000
	ANDCAB I,QSNLCN(C)
	MOVEM TT,UDNAME(I)	;STORE USER NAME IN USER DIRECTORY
	MOVE TT,QACTB
	IORM TT,QMDRO
	JRST QUDW2A

IFE DECDKC,[
QPOSR:	CAIL E,NBLKS
	JRST 4,.
	IDIVI E,NSECS
	MOVSI D,(DUNENB)
	DPB TT,[DSECT+D]
	IDIVI E,NHEDS
	DPB TT,[DSURF+D]
	DPB E,[DCYL+D]
	MOVEM E,QSPPS(Q)
	MOVE E,D
	DPB Q,[DUNFLD+E]
	SKIPGE TT,QPKID(Q)
	JRST QPOSRI
	DPB TT,[DPKID+E]
	POPJ P,

QPOSRI:	DPB Q,[DUNFLD+GPKID]
	DATAO DC0,[DJMP GPKID]
	MOVEM Q,QSDU
	SETOM PKIDM
	SETOM QSKT1(Q)
	JRST QINTX

QSPKID:	CONSZ DC1,1777
	JRST 4,.	;ERRORS
	LDB TT,[DPKID+RPKID]
	MOVEM TT,QPKID(Q)
	SETOM QSDU
	JRST QINT1
]
QUIO:	HRRO I,C
	MOVE C,[SETZ I]

QBO:	MOVE T,QSRAC(A)
	TRNE T,20000
	JRST QBOPD	;IN PDUMP MODE
	TLNE T,100
	PUSHJ P,QBWRA1	;RANDOM ACCESS MODE HACK
	JSP B,BLKT
QBOV:	SETZ QSMPRP(A)
	QSMPRC(A)
	QSBWG
	SETZ QSBWW
	@J	;SIZE OF BLOCK
	TRNA

QBOPD:	TRNN T,4000
	JRST IOCR10
	MOVEI T,20000
	TDNE T,QSRAC(A)
	PUSHJ P,UFLS
	JRST QBO

QUAI:	MOVE T,QSRAC(A)
	TLNE T,100
	PUSHJ P,QBRRA1
	MOVEI B,QBIV
	JRST CHRKT5

QUAO:	MOVE T,QSRAC(A)
	TLNE T,100
	PUSHJ P,QBWRA1
	MOVEI B,QBOV
	JRST CHRKT2

QUII:	HRRO I,C
	MOVE C,[SETZ I]

QBI:	MOVE T,QSRAC(A)
	TLNE T,100
	PUSHJ P,QBRRA0	;RANDOM ACCESS HACK
	JSP B,BLKT
QBIV:	QSMPRP(A)
	QSMPRC(A)
	QSBGB
	QSBRB
	@J
	SKIPG QSBFS(A)
	CAIN D,EOFCH
	JRST QICL	;CLOSE CHARACTER INPUT

QBWRA1:	LDB T,[300,,QSRAC(A)]	;SET RANDOM ACCESS PNTRS ON WRITE
	SOJN T,QBWRA2	;IN ORDINARY WRITE MODE
	SKIPGE QSCRW(A)
	PUSHJ P,UFLS	;WAIT FOR ANY READ/WRITE OPERATIONS INTERRUPTED OUT OF TO FINISH
	SKIPL QSGL(A)
	PUSHJ P,UFLS
	SKIPGE QSMDN(A)
	JRST QBWRA2
	MOVE T,QRADAD(A)	;DESIRED ADDRESS
	SUB T,QFBLNO(A)	;ACTUAL ADDRESS OF BEG OF CURRENT BUFFER
	JUMPL T,QBWRA2
	MOVE Q,T
	SUB T,QAWMPB(A)	;# OF ACTIVE WDS IN CURRENT BUFFER
	JUMPL T,QBWRA3	;SAME BLOCK AS NOW
QBWRA2:	PUSH P,R
	PUSH P,I
	PUSH P,C
	PUSHJ P,QSOCL5	;CLEAR ANY CURRENT BUFFERS ETC
	PUSHJ P,QUDULK
	MOVE Q,QRADAD(A)
	PUSHJ P,QFNTR	;LOCKS DIR IF SKIPS
	JRST QBWRA4	;OFF END OF FILE
QBWRA5:	PUSHJ P,QUDULK
QBWRA9:	POP P,C
	POP P,I
	POP P,R
	CLEARM QSCRW(A)	;SWITCH TO WRITE OVER MODE
	MOVE Q,[1,,1]	;SET UPDATE ADR AND WRITE OVER
	IORM Q,QSRAC(A)
	CLEARM QSMPRC(A)
	MOVE Q,[220100,,100000]	;CLEAR EOF, WRITE EOF, READ INHIBIT AND ACCESS FLAGS
	ANDCAM Q,QSRAC(A)
	POPJ P,

QBWRA3:	SKIPGE TT,QSMDN(A)
	JRST 4,QBWRA2	;NO BUFFER REALLY ACTIVE AT M.P.
	MOVE J,QSRAC(A)
	TRZN J,200000
	JRST QBWRA7
	MOVEM J,QSRAC(A)
	HLLZ J,QSMPRP(A)	;WAS WRITING IN LAST BLK PAST EOF, UPDATE ACTIVE WD COUNT
	MOVN D,QSMPRC(A)
	JUMPE J,QBWRA8
	IDIVI D,5
QBWRA8:	ADDM D,QAWMPB(A)
	JRST QBWRA7

QBWRA4:	JUMPE Q,QBWRA0
	CAME J,Q	;MIGHT BE ADDING TO END OF FULL BLOCK
	JRST IOCER2
	JRST QBWRA9

QBWRA0:	PUSHJ P,QLWO	;OFF END OF FILE  AND WAS ACCESSING WD 0
	MOVSI C,100
	ANDCAM C,QSRAC(A)	;TURN OFF RANDOM ACCESS BIT
	POP P,C	;SO SWITCH TO NORMAL WRITE MODE
	POP P,I
	POP P,R
	POPJ P,

QBRRA0:	PUSHJ P,QBRRA1
	MOVE T,QSRAC(A)
	TLNE T,100
	JRST IOCER2
	POPJ P,

QBRRA1:	SKIPGE QSMDN(A)
	JRST QBRRA2	;NO MAIN PRGM BUFFER
	MOVE T,QRADAD(A)
	SUB T,QFBLNO(A)
	JUMPL T,QBRRA2
	MOVE Q,T
	SUB T,QAWMPB(A)
	JUMPL T,QBRRA3	;SAME BLOCK AS NOW
QBRRA2:	PUSH P,R
	PUSH P,I
	PUSH P,C
	PUSHJ P,QICLW1
	MOVE A,D
	CLEARM QSBFS(A)	;FLUSH POSSIBLE EXTRA AOSES WHEN PI HIT EOF
	MOVE Q,QRADAD(A)
	PUSHJ P,QFNTR
	JRST QBRRA5	;OFF END OF FILE
	POP P,C
	POP P,I
	POP P,R
	CLEARM QSMPRC(A)
	MOVSI Q,1
	IORM Q,QSRAC(A)	;SET FLAG TO SET QSMPRP AND QSMPRC ON NEXT BUFFER LOAD
QBWRA6:	MOVSI Q,200100	;CLEAR EOF AND .ACCESS FLAGS
	ANDCAM Q,QSRAC(A)
	JRST QUDULK

QBRRA5:	POP P,C	;OFF EOF
	POP P,I
	POP P,R
	JRST QUDULK	;RETURN W/O CLEARING ACCESS FLAG TO INDICAT LOSSAGE

QBRRA3:	SKIPGE TT,QSMDN(A)	;OPERATION IN SAME BLOCK AS PRESENT BUT NOTE
	JRST QBRRA2	;WILL NOT GET HERE IF OFF END OF FILE IN ANY CASE
QBWRA7:	LSH TT,10.
	ADD TT,Q
	HLLZ J,QSMPRP(A)	;SAVE FLAG WHETHER IN CHR MODE
	MOVEM TT,QSMPRP(A)
	ANDI TT,1777
	MOVNS TT
	ADD TT,QAWMPB(A)
	JUMPE J,QBRRA4
	MOVEI Q,440700
	HRLM Q,QSMPRP(A)
	IMULI TT,5
QBRRA4:	MOVEM TT,QSMPRC(A)
	MOVSI Q,100
	ANDCAM Q,QSRAC(A)
	POPJ P,

QWOG1:	SKIPGE QSCRW(A)	;FETCH BLOCK WRITEOVER MODE
	JRST QWOG2
	SKIPG QSBFS(A)
	PUSHJ P,UFLS
	POP P,A
QSBGB:	MOVSI Q,40
	TDNE Q,QSRAC(A)
	JRST QSBGB2
	CONO PI,UTCOFF
	HRRZ Q,QBFP(A)
	CAIN Q,377
	JRST 4,.	;PNTRS OUT OF PHASE
	CAIN Q,376
	JRST QSBGB5	;EOF
	LDB J,[MLO,,MEMBLT(Q)]
	HRRM J,QBFP(A)
	MOVEI TT,(SETZ)
	CAIL J,376
	HRLM TT,QBFP(A)
	CONO PI,UTCON
	LDB TT,[MWC,,MEMBLT(Q)]	;LOAD ACTIVE WORD COUNT
	SKIPN TT
	MOVEI TT,2000
	MOVEM TT,QAWMPB(A)	;STORE ACTIVE WORD COUNT
	LDB TT,[300,,QSRAC(A)]
	SKIPN TT	;DONT SOS IF IN WRITE OVER MODE
	SOS QSBFS(A)
	PUSHJ P,QSTRTR
QSBWG4:	MOVEI J,-3
	DPB J,[MLO,,MEMBLT(Q)]	;MARK ACTIVE AT M.N. PRGM
	MOVE TT,Q
	LSH TT,10.	;RETURN ADR OF BUFFER START
	MOVE J,QAWMPB(A)
	MOVEM Q,QSMDN(A)
	MOVSI Q,1
	TDNN Q,QSRAC(A)
	JRST POPJ1
	ANDCAM Q,QSRAC(A)	;DIDDLE PNTRS TO TAKE CARE OF RANDOM ACCESS WITHIN BLOCK
	MOVE Q,QRADAD(A)
	SUB Q,QFBLNO(A)	;DESIRED OFFSET WITHIN BLOCK
	SUB J,Q
	ADD TT,Q
	JUMPG J,POPJ1	;NOT REALLY WITHIN THIS BLOCK

QSBGB1:	JUMPL J,IOCER2	;OFF END OF FILE
	LDB Q,[300,,QSRAC(A)]
	SOJE Q,POPJ1	;OK IF ONLY ONE WD BEYOND IN WRITE OVER MODE
		;RETN 0 COUNT AND EVENTUALLY APPEND TO FILE
	JRST IOCER2

QSBGB5:	CONO PI,UTCON
	LDB Q,[300,,QSRAC(A)]
	SOJN Q,UTBG1	;EOF (NORMAL)
	PUSHJ P,QLWO
	JRST QSBWG

QLWO:	MOVE H,QUDPR(A)	;LEAVE WRITE OVER MODE
	PUSHJ P,QUDLK
	CONO PI,UTCOFF
	MOVE Q,[SETZ 377]	;WRITEOVER MODE EXTEND FILE (SWITCH TO NORMAL MODE)
	MOVEM Q,QBFP(A)
	CLEARM QSBFS(A)
	SETOM QSCRW(A)
	MOVE Q,QSLGL(A)
	MOVEM Q,QMPTN(A)	;STORE BASE TRACK
	MOVE Q,[200000,,7]	;CLEAR EOF AND WRITEOVER
	ANDCAM Q,QSRAC(A)
	CLEARM QMPTC(A)	;TRACK COUNT FOR TAKE N
	SETOM QMTTR(A)	;NO TRACK RESERVED
	SETOM QMFTP(A)	;GET NEW DECADE RESERVATION
	CONO PI,UTCON
	MOVE TT,QDIRP(A)	;SEE IF GARBAGE COLLECTION NEEDED
	PUSH P,R
	PUSH P,I
	PUSHJ P,QMPDC1	;CONV CHAR ADR TO BYTE PNTR (AND LDB IN R)
	POP P,I
	SKIPE R
	JRST 4,.
	MOVE R,QDIRP(A)
	ADDI R,NXLBYT+2
	CAMGE R,@QSNLCN(H)
	JRST QLWO1	;DON'T NEED TO EXPAND F.S.
	MOVEI R,LUNBLK(TT)
	MOVE Q,QSNLCN(H)
	SUBI R,(Q)
	CAML R,UDNAMP(Q)
	JRST QSBWG7	;DON'T HAVE ROOM.  GC
	MOVEI R,3*6	;HAVE ROOM
	ADDM R,(Q)
QLWO1:
REPEAT NXLBYT,[
	ILDB R,TT
	JUMPN R,QSBWG7
]
	ILDB R,TT
	JUMPE R,QSBWG8
QSBWG7:	MOVSI TT,400
	IORM TT,QSRAC(A)
QSBWG8:	POP P,R
	JRST QUDULK

QSBGB2:	ANDCAM Q,QSRAC(A)	;PARITY ERROR
	JRST IOCER3

QSBWG:	PUSH P,A
	MOVE D,A
	LDB Q,[300,,QSRAC(A)]
	JRST @QSBWGT(Q)	;DISPATCH ON MODE OF CHNL

QSBWGT:	QSBWG2	;NORMAL WRITE
	QWOG1	;WRITE OVER

QSBWG2:	HRRZ Q,QBFP(A)
	CAIL Q,376
	JRST QSBWG1
	MOVSI J,40000
	HRRZ Q,QSBFS(A)
	CAIGE Q,3
	TDNE J,QSRAC(A)
	JRST POPAJ	;CHNL ERR OR BLOATED

QSBWG1:	MOVE Q,QDSKN(A)
	SOSGE QSFT(Q)
	JRST QSBWG3	;DISK FULL
	PUSHJ P,TCALL
	JRST IOMQ
	JRST QSBWG5	;MEM FROZE OR NOT AVAILABLE
	DPB D,[M2311C,,MEMBLT(A)]
	MOVEI Q,MU23B
	DPB Q,[MUR,,MEMBLT(A)]
	MOVE Q,A
	POP P,A
	AOS QSBFS(A)
	MOVEI J,2000
	MOVEM J,QAWMPB(A)	;FRESH BLOCK SIZE 2000
	JRST QSBWG4

QSBWG3:	AOS QSFT(Q)
	JRST IOCER9

QSBWG5:	AOS QSFT(Q)
	JRST POPAJ

QWOG2:	SKIPGE QSCRW(A)	;WAIT FOR WRITE TO FINISH
	PUSHJ P,UFLS
	JRST POPAJ	;NOW RECYCLE AND WAIT FOR READ

QSBWW:	SKIPGE QSMDN(A)	;WRITE BUFFER FROM MN PROG TO CHAIN FOR PI
	POPJ P,		;NO WRITE BUFFER ACTIVE
	MOVE TT,QSRAC(A)
	TLNE TT,400
	JRST QSBWGC	;CHNL NEEDS GC
QSBWGA:	LDB TT,[300,,QSRAC(A)]
	SOJE TT,QSBWO1	;WRITE OVER MODE
	SKIPL D,QMTTR(A)
	JRST QTG1	;TRACK ALREADY RESERVED
	PUSH P,I
	MOVE I,QDSKN(A)
	PUSHJ P,QGTRK	;GET BLOCK NUM
	POP P,I
	MOVEM D,QMTTR(A)
QTG1:	MOVE H,QUDPR(A)	;TRACK IN D
	SKIPGE QMPTN(A)
	JRST QTG5	;ALREADY STORED IN DIRECTORY
	PUSHJ P,QUDLK
	AOS QMPTN(A)	;AOS # LAST TRACK
	CAMN D,QMPTN(A)
	JRST QTG2	;THIS TRACK IS CONSECUTIVE
	SKIPN QMPTC(A)	;THIS TRACK NOT CONSEC CHECK COUNT OF PREV CONSEC BLOCKS
	JRST QTG3
	PUSH P,D	;NON-ZERO SO STORE IN USER DIRECTORY
	MOVE D,QMPTC(A)
	PUSHJ P,QUDS
	CLEARM QMPTC(A)
	POP P,D
QTG3:	SUB D,QMPTN(A)	;CAN TRACK BE SKIPPED TO?
	JUMPL D,QTG4	;NO
	CAILE D,UDWPH-UDTKMX-1
	JRST QTG4	;ALSO NO
	ADDI D,UDTKMX	;NEXT BLOCK WITHIN N
	PUSHJ P,QUDS	;STORE APPROPRIATE SKIP
QTG5A:	MOVE D,QMTTR(A)
	TLO D,400000
	MOVEM D,QMPTN(A);INDICATE STORED IN DIRECTORY
	PUSHJ P,QUDULK
QTG5:	MOVE Q,QSMDN(A)
	MOVE J,QSRAC(A)
	TRNE J,20000
	JRST QTGPD1	;PDUMP MODE
	HRLM D,MEMPNT(Q)	;STORE TRACK NUM
	SETOM QMTTR(A)	;INDICATE TRACK USED
	HRRZS QMPTN(A)	;INDICATE DIRECTORY ENTRY USED
	MOVEI J,377
	IORM J,MEMBLT(Q);SET END OF LIST INDICATOR IN MEMORY BLOCK
	MOVE J,QAWMPB(A)	;LENGTH OF THIS BLOCK
	ADDM J,QFBLNO(A)	;INCR WD ADR OF START OF CURRENT BLOCK IN FILE
	DPB J,[MWC,,MEMBLT(Q)]	;STORE ACTIVE WORD COUNT
	CONO PI,UTCOFF
	HLRE J,QBFP(A)	;STORE MEMORY BLOCK IN OUTPUT LIST
	JUMPL J,QSBWW1
	DPB Q,[MLO,,MEMBLT(J)]
QSBWW2:	HRLM Q,QBFP(A)
	CONO PI,UTCON
	SETOM QSMDN(A)	;MN PROG BUFFER NOW WRITTEN
	JRST QSTRTR	;START ACTION IF 2311 IDLE AND RETURN

QTGPD2:	CONO PI,UTCON
QTGPD1:	PCLT
	SKIPN MMPDFS
	PUSHJ P,UFLS
	CONO PI,UTCOFF
	SKIPN J,MMPDFS
	JRST QTGPD2
	MOVE TT,(J)
	MOVEM TT,MMPDFS
	AOS NPDBLK
	CONO PI,UTCON
	HRRM Q,1(J)	;MEM BLK #
	HRLM D,1(J)	;TRACK #
	MOVEI D,377
	MOVEM D,(J)
	LDB TT,[MUR,,MEMBLT(Q)]
	MOVSI D,(SETZ)
	CAIN TT,MU23B
	IORM D,(J)	;SET RETURN MEM BIT
	SETOM QMTTR(A)
	HRRZS QMPTN(A)
	MOVEI Q,-MMPDMP(J)
	CONO PI,UTCOFF
	HLRE D,QBFP(A)
	JUMPL D,QTGPD3
	HRRM Q,MMPDMP(D)
QTGPD4:	HRLM Q,QBFP(A)
	CONO PI,UTCON
	AOS QSBFS(A)
	SETOM QSMDN(A)
	JRST QSTRTR

QTGPD3:	HRRM Q,QBFP(A)
	JRST QTGPD4

QSBWO1:	MOVSI D,2
	TDNN D,QSRAC(A)
	JRST QSBWO2	;NOT HACKING LAST BLOCK
	MOVSI D,20000
	TDNE D,QSRAC(A)
	JRST QSBWO2	;HACKING CLOSE
	MOVEI D,2000
	SUB D,QAWMPB(A)
	JUMPE D,QSBWO2	;BLOCK REALLY FULL
	HLLZ Q,QSMPRP(A)
	SKIPE Q
	IMULI D,5	;IN CHR
	MOVEM D,QSMPRC(A)	;LAST BLOCK NOT REALLY USED UP
	MOVEI D,2000	;EXTRA ROOM IN LAST BLOCK TO FILL UP
	MOVEM D,QAWMPB(A)
	MOVEI D,200000
	IORM D,QSRAC(A)	;FILLING LAST BLK PAST ORIG EOF
	POPJ P,	;FINISH OUT BLOCK

QSBWO2:	MOVEI D,200000
	ANDCAM D,QSRAC(A)
	MOVE D,QSLGL(A)	;WRITE TRACK BACK WHERE IT CAME FROM
	SETOM QSCRW(A)	;SWITCH TO WRITE MODE
	JRST QTG5

QTG4:	LDB D,[140500,,QMTTR(A)]	;WRITE LOAD ADDRESS
	TDO D,[400000,,40];SET SIGN BIT SO NO GC WITH INCOMPLETE LOAD ADDRESS
	PUSHJ P,QUDS
	LDB D,[060600,,QMTTR(A)]
	TLO D,400000	;SAME
	PUSHJ P,QUDS
	LDB D,[0600,,QMTTR(A)]
	PUSHJ P,QUDS
	JRST QTG5A

QGTRK:	PUSHJ P,QTLOCK	;GET TRK CHNL IN A DSK IN I RET IN TT
QGTK4:	PUSH P,R	;ENTER HERE FROM SWAP OUT WITH UTCOFF
	HRRZ R,QTUTO(I)
QGTK4A:	SKIPGE Q,QMFTP(A)
	JRST QGTK3A	;FIRST TRACK
	IDIVI Q,NHEDS
	HRREI TT,-NHEDS(J)	;COMPUTE TRACKS REMAINING IN DECADE
	MOVE Q,QMFTP(A)
	IDIVI Q,TUTEPW
	HLL Q,TBTBLI(J)
	ADDI Q,(R)
	MOVE D,QMFTP(A)
QGTK3:	CAIL D,NBLKS
	JRST 4,QGTK1
	ILDB J,Q
	JUMPE J,QGTK2
	AOJGE TT,QGTK3A	;DECADE OUT
	AOJA D,QGTK3

QGTK3A:	CAIN A,SWOTRK-QMFTP
	JRST QGTK3C
QGTK3D:	MOVEI Q,NHEDS
	ADDB Q,QTUTP(R)
QGTK3B:	MOVEM Q,QMFTP(A)
	CAIGE Q,NBLKS
	JRST QGTK4A
	MOVE Q,QSWAPA(R)	;REACHED END OF DSK, RESET TO END OF SWAPPING AREA
	IDIVI Q,NHEDS	;ROUND UP TO A MULTIPLE OF A DECADE
	SKIPE J
	ADDI Q,1
	IMULI Q,NHEDS
	MOVEM Q,QTUTP(R)
	JRST QGTK3B

QGTK2:	MOVEI J,1
	DPB J,Q
	MOVEM D,QMFTP(A)
	MOVE J,DCHBT(I)
	IORM J,QTUTO(I)
	POP P,R
	CAIN A,SWOTRK-QMFTP
	POPJ P,	;CALLED FROM SWAP OUT
	JRST QTULK

QGTK1:	CLEARM QMFTP(A)
	JRST QGTK4A

QGTK3C:	CAML D,QSWAPA(R)
	JRST QGTK3D	;IN NON-SWAP AREA
	AOS D
	CAMN D,QSWAPA(R)
	MOVEI D,NUDSL
	MOVEM D,QMFTP(A)
	JRST QGTK4A

QSBWW1:	HRRM Q,QBFP(A)
	JRST QSBWW2

QSBRB1:	MOVE A,D
QSBRB:	PUSH P,A
	SKIPGE A,QSMDN(A)
	JRST POPAJ
	PUSHJ P,MEMR
	POP P,A
	MOVE TT,QAWMPB(A)
	ADDM TT,QFBLNO(A)	;INCREMENT WD ADR IN FILE OF BEG OF NEXT BLOCK
	SETOM QSMDN(A)
	POPJ P,

QTG2:	AOS D,QMPTC(A)	;NEXT BLOCK IS CONSECUTIVE
	CAIGE D,UDTKMX
	JRST QTG5A
	PUSHJ P,QUDS
	CLEARM QMPTC(A)
	JRST QTG5A


QUDSA:	PUSH P,I	;STORE CHR IN D CHNL IN A USER DIR PNTR IN H
	PUSH P,Q	;4.9 IN D=1 => NOT LAST CHR OF BLOCK TO STORE
	MOVE I,QDIRP(A)
	CAIGE I,2000*UFDBPW
	CAML I,@QSNLCN(H)
	JRST 4,.	;WRITING ABOVE F.S. PNTR?
	AOS QDIRP(A)
	IDIVI I,UFDBPW
	MOVE Q,QBTBL(Q)
	ADD Q,I
	SKIPL I,QSNLCN(H)
	JRST 4,.	;UFD WAS NOT LOCKED
	ADDI Q,UDDESC(I)
	DPB D,Q
	ILDB I,Q
	SKIPE I
	JRST 4,.	;ABOUT TO CLOBBER SOMETHING IN UFD
	JUMPL D,QUDSX
	REPEAT NXLBYT+2,[
	ILDB I,Q
	JUMPN I,QUDS1
]
	MOVE I,QDIRP(A)
	ADDI I,NXLBYT+2
	CAMGE I,@QSNLCN(H)
	JRST QUDSX	;DESC AREA NOT COLLIDING WITH LIM OF DESC SPACE
	MOVEI Q,LUNBLK(Q)
	MOVE I,QSNLCN(H)
	SUBI Q,(I)
	CAML Q,UDNAMP(I)
	JRST QUDS1	;NO ROOM.  GC
	MOVEI Q,3*6	;EXPAND DESC AREA
	ADDM Q,(I)
	JRST QUDSX

QUDS1:	PUSHJ P,QGC
	SOS -2(P)	;GC FAILED, CAUSE RETN TO NOT SKIP
QUDSX:	MOVE Q,QACTB
	MOVE I,QUDPR(A)
	IORM Q,QSNLCN(I)	;SET DIRECTORY CHANGED
	POP P,Q
	POP P,I
	JRST POPJ1

QUDS:	PUSHJ P,QUDSA
	JRST QUDFUL
	POPJ P,

QUDFUL:	MOVSI I,400
	IORM I,QSRAC(A)	;SET CHNL LOCKED FOR DIR FULL
	PUSHJ P,QUDULK
	PUSHJ P,IOCER9
	JRST URET

QSBWGC:	MOVE H,QUDPR(A)
	PUSHJ P,QUDLK
	PUSHJ P,QGC
	JRST QSBWGB
	PUSHJ P,QUDULK
	MOVSI TT,400
	ANDCAM TT,QSRAC(A)
	JRST QSBWGA

QSBWGB:	PUSHJ P,QUDULK
	JRST IOCER9
IFN PDP6P,[
;.IPDP CH,
;INTERRUPT THE PDP10, I/O CH SHOULD HAVE PDP10 OPEN AS INFERIOR
;THIS CALL DOESNT SKIP OR INTERRUPT TO THE USER

AIPDP:	MOVSI T,100
	SKIPGE A,(R)
	TDNN T,CLSTB(A)
	POPJ P,
	CONO PI,LPTOFF
	CONI DSDEV,T
	ANDI T,7
	CONO DSDEV,20(T)
	JRST LPTONJ

;PDP-10 DEVICE
;INTERRUPT FROM PDP10, MAYBE GENERATE IO CHANNEL USER INTERRUPT

DSDBRK:	CONO DSDEV,10	;TURN OFF FLAG
			;ALSO KEEP IT FROM INTERRUPTING FOR A WHILE
		;GETS TURNED ON AT DISMISS, SETOM PICLR AND SLOW CLK
	SKIPGE A,PDPISR
	JRST LPTRT3	;NO ONE WANTS AN INT
	MOVE B,PDPMSK
	AND B,MSKST2(A)
	MOVNM B,PDPTMP
	AND B,PDPTMP
	IORM B,IFPIR(A)	;GENERATE USER INT
	JRST LPTRT3

		;PDP10 .OPEN ROUTINE (GET HERE FROM USR OPEN)

PDPO:	PUSHJ P,SWTL
	PDPOSW
	TLNN C,20
	JRST PDPO1	;DON'T TRY TO ENABLE INTERRUPTS
	TLO C,400000	;TRY TO ENABLE INTERRUPTS
	SKIPL PDPISR
	CAMN U,PDPISR
	JRST PDPO1
	JRST OPNL12

PDPO1:	PUSH P,U
	PUSHJ P,PDPO2
	JRST POPUJ
	AOS -1(P)
	POP P,U
	SKIPL (R)
	JRST .+3
	AOS PDPISE
	MOVEM U,PDPISR	;GOT IT AS INFERIOR
	PUSHJ P,LSWPOP	;RELEASE SWITCH
	MOVEI I,1	;DO "IOPOP" INTO CHNL

PDPIOP:	SKIPL (R)
	POPJ P,		;NOT OPEN TO INTERRUPT
	SUBI R,IOCHNM(U)
	MOVE A,CHNBIT(R)
	ADDI R,IOCHNM(U)	;RESTORE R
	XCT PDPIOT(I)
	POPJ P,

PDPIOT:	ANDCAM A,PDPMSK
	IORM A,PDPMSK

PDPCLS:	MOVEI I,0	;CLOSE
	PUSHJ P,PDPIOP	;=> DO "IOPUSH"
PDPCL1:	CONO PI,CLKOFF
	SOSGE PDPUSE
	SETOM PDPUSR
	SKIPL (R)
	JRST CLKONJ	;NOT INTERRUPT ENABLED THIS CHNL
	SOSGE PDPISE
	SETOM PDPISR
	JRST CLKONJ


PDPO3:	MOVEI U,(A)	;MAKE U INDEX OF SUPERIOR
PDPO2:	SKIPL A,SUPPRO(U)	;GET POINTER TO SUPERIOR, SKIP IF TOP LEVEL
	JRST PDPO3	;TRY AGAIN
	HLRZ D,C
	TLO C,200000	;SIGNAL PDP6 TO UBI ETC
	JSP Q,STDOPN
	3,,PDPUSR
	PDPUII,,PDPUIO
	PDPBII,,PDPBIO

;.UCLOSE PDP10
PDPUCL:	MOVSI C,100	;GET PDP10 CLSTB BIT
	MOVEI R,IOCHNM(U)	;GET PNTR TO USER'S IO CHNL AREA
	HRLI R,-20	;MAKE AOBJN PNTR TO ALL CHNLS
	PUSHJ P,PDPCCK	;CHECK CHNL
	PUSHJ P,PDPCZP	;CLOSE CHNL IF PDP10 OPEN ON IT
	AOBJN R,.-2	;REPEAT FOR ALL CHNLS
	HRLI R,-LUIOP/2	;MAKE AOBJN PNTR TO IO PDL (ADR ALREADY THERE)
	PUSHJ P,PDPCCK	;CHECK ENTRY FOR PDP10
	PUSHJ P,PDPPZP	;CLEAR ENTRY IF PDP10 CHNL
	AOJ R,		;INCR TO SKIP IOCHST ENTRY
	AOBJN R,.-3	;REPEAT FOR WHOLE IO PDL
	POPJ P,		;ALL PDP10 CHNLS THIS JOB SHOULD NOW BE CLOSED

PDPCCK:	HRRZ B,(R)	;GET CLSTB INDEX FROM IOCHNM
	TDNN C,CLSTB(B)	;IF NOT PDP10 CHNL
	AOS (P)		;SKIP CLOSING CHNL
	POPJ P,

;CLOSE PDP10 USER CHNL
PDPCZP:	PUSHJ P,PDPCLS	;ADJUST PDP10 VARS
	JRST STDCLX	;CLOBBER CHNL & RETURN

;CLEAR PDP10 IO PDL ENTRY
PDPPZP:	PUSHJ P,PDPCL1	;ADJUST PDP10 VARS (EXCEPT PDPMSK)
	SETZB A,(R)	;CLEAR SAVED IOCHNM
	DPB A,[4000,,1(R)]	;CLEAR SAVED IOCHST (SAVING CHNL # FOR .IOPDL)
	POPJ P,
PDPCLR:	OFFSET 20-.	;ROUTINE TO BE MOVED
	CONO PI,11577	;CLEAR PI
	CONO 655550	;CLEAR PROCESSOR
	DATAO 20,.+1	;RELEASE DEVICES
	SETZ		;CLEAR 0, ALSO BIT FOR DEASSIGNMENT (^)
	HRRZI 1,1	;BLT POINTER 0,,1
	BLT 1,41		;CLEAR AC'S, SELF, AND 41
PDPCLE==.
	OFFSET 0	;BACK TO NORMAL
EBLK

PDPTMP:	0	;TEMP FOR INT
PDPMSK:	0	;MASK OF INT BITS OF CHNLS OPEN
PDPOSW:	-1	;PDP10 .OPENS QUE UP ON THIS SW
	0	;MUST FOLLOW PDPOSW

BBLK

PDPRST:	PUSHJ P,MP6LD
	MOVE C,[400020,,400021]
	XCTR XRW,[CLEARM 400020]
	XCTR XRW,[BLT C,437777]
	MOVE C,[PDPCLR,,400020]
	XCTR XW,[BLT C,400000+PDPCLE-1]
	MOVE C,[JRST 20]
	XCTR XW,[MOVEM C,400041]
	PUSHJ P,UDELAY
	XCTR XR,[MOVE A,400041]
	JUMPE A,PDPRS2	;JUMP ON ROUTINE WON, DON'T HAVE TO CLEAR IT OUT
	XCTR XRW,[CLEARM 400020]
	MOVE C,[400020,,400021]
	XCTR XRW,[BLT C,400041]
PDPRS2:	JRST MPLDZ

;PAGE MAP FOR REFERENCING PDP6 MEM
PDP6MP:	8_1,,PDPUMP
]
EXECMP:	100_1,,EXEUMP	;EXEC DBR POINTER

EBLK
;AGES CAN GET STORED
IFN PDP6P,[
PDPUMP:	REPEAT 8.,600000+<PDP6BM_-10.>+2*.RPCNT,,600000+<PDP6BM_-10.>+2*.RPCNT+1
]
EXEUMP:	REPEAT 100-<DDTPGS+1>/2,0
	IFN DDTPGS&1,600000+200+<.-EXEUMP>*2+1
	REPEAT DDTPGS/2,600000+200+<.-EXEUMP>*2,,600000+200+<.-EXEUMP>*2+1
DDEXCF:	BLOCK NEXPGS	;-1 IF SET UP TO EXEC PAGE

BBLK

	;DEMON JOB INTERFACE ROUTINES
	;GIVE STUFF TO DEMON JOB RUNNING IN USER MODE, WHICH THEN OUTPUTS
		;STUFF IN ITS OWN FORMAT TO THE DISK
	;COMMUNICATION IS VIA DMNBUF (BUFFER) AND POINTERS,
	;DEMON JOB FINDS IT BY LOOKING UP SYSTEM SYMS

	;USAGE:
	;FIRST CALL DMNP TO SET UP D AS "PDL POINTER" INTO DMNBF
		;ALSO TURNS OFF CLOCK
	;DMNPSH ADR	;PUSH ADR INTO DMNBF (ASSEMBLES INTO A PUSH)
		;FIRST WORD PUSHED SHOULD HAVE ENTRY TYPE DESCRIPTOR IN HIGH SIX BITS

	;ENTRY TYPE DESCRIPTORS:
DMNELI==10000	;LOGIN (DMNPLI)
DMNELO==20000	;LOGOUT (DMNPLO)
	;^ ADD MORE AS NEEDED, NEED NOT BE SYMBOLIC BUT PLEASE COMMENT THEM HERE FOR XREF

	;DMNRS		;NORMALLIZE POINTER (DUE TO STANDARD LENGTH ENTRY IN TABLE)
		;ASSEMBLES INTO ONE STORAGE WORD
	;THEN CALL (PUSHJ) DMNRT WHICH STORES BACK D
	;ALL DMNPSH'S SHOULD BE ASSEMBLED BEFORE DMNRT;
	;ALL ROUTINES SHOULD BE BETWEEN THIS PAGE AND DMNBUF

;DMNSZ (# ENTRIES IN DMNBF) DEFINED EARLY IN SYSTEM ENGLISH SO CAN BE CHANGED EASILY

DMNFMT==2	;ASCENDING FORMAT NUMBER, SHOULD BE INCREMENTED EACH TIME
			;A CHANGE IS MADE REQUIRING CHANGE IN CODING EITHER OF DEMON JOB
			;OR OF PROGRAMS READING ITS OUTPUT
;DMNFNT 1 -> 2 9/71 SWAPIN RQ INCLUDED W/LOGOUT

DMNBAC==0	;DMNPSH COUNTER, AFTER FIRST TIME GETS RE-INITIALIZED TO DMNBLM

DEFINE DMNPSH ADR
	DMNBAC==DMNBAC+1
	PUSH D,ADR
TERMIN

IF1,DMNBEL==0		;BECOMES LENGTH PER ENTRY IN DMNBF

DEFINE DMNRS
	ADDI D,DMNBEL-DMNBAC
IF1,IFG DMNBAC-DMNBEL,DMNBEL==DMNBAC
DMNBAC==DMNBLM
TERMIN

		;PUSHJ P,DMNP	;SET UP D FOR DMNPSH'S INTO DMNBF

DMNP:	CONO PI,CLKOFF	;TURN OFF CLOCK, STAYS OFF UNTIL DONE WITH DMNRT
	MOVE D,DMNBFP	;GET POINTER
	CAIL D,DMNBFE-1	;AT END OF BUFFER?
	MOVEI D,DMNBF-1	;YES, RE-INITIALIZE
	AOS DMNBC	;INDICATE ENTRY ABOUT TO BE FILLED, SO DEMON KNOWS IF IT LOST
DMNP0:	;DMNP0 MAY BE CALLED IN USER MODE FROM DEMON JOB
	DMNPSH TIME	;FIRST WORD IN BUFFER ALWAYS TIME OF ENTRY
		;^ MAYBE ADD MORE STANDARD PUSHES HERE
	POPJ P,

DMNBLM==DMNBAC	;NUMBER OF INITIAL WORDS PUSHED

		;PUSHJ P,DMNRT (BUT USUALLY JRST DMNRT FOR RETURN)
			;DMNBF ENTRY COMPLETED, STORE BACK POINTERS

DMNRT:	TLZ D,-1	;CLEAR OUT LEFT HALF OF POINTER
	CAIL D,DMNBFE	;AFTER END OF BUFFER?
	JRST 4,.+1	;DMNBF POINTER INCREMENTED INCORRECTLY SOMEWHERE ALONG THE LINE
		;PROBABLY PROGRAMMER FORGOT TO DO DMNRS; CODING AFTER DMNBF MIGHT BE CLOBBERED
	AOS DMNBD	;ENTRY COMPLETE, GIVE IT TO DEMON JOB
	MOVEM D,DMNBFP
	JRST CLKONJ

		;NOW FOR INDIVIDUAL ROUTINES

		;LOGIN

DMNPLI:	PUSHJ P,DMNP	;SET UP
	HRLI U,DMNELI	;INDICATE LOGIN
		;PUT FOLLOWING INTO DMNBF:
	DMNPSH U	;INDEX OF USER BEING LOGGED IN
	TLZ U,-1
	DMNPSH UNAME(U)	;UNAME
	DMNPSH JNAME(U)	;JNAME
	DMNPSH TRMNAM(U)	;TERMINAL NAME
	DMNRS		;THAT'S ALL
	AOS (P)		;LOGIN SUCCESSFUL, CAUSE RETURN TO SKIP
	JRST DMNRT

		;LOGOUT

DMNPLO:	PUSHJ P,DMNP	;SET UP D
	PUSHJ P,DMNPL0
	JRST DMNRT
DMNPL0:		;DMNPL0 MAY BE CALLED FROM DEMON JOB IN USER MODE
	HRLI U,DMNELO	;INDICATE LOGOUT
		;PUT FOLLOWING IN DMNBF FOR DEMON JOB TO DUMP OUT ON DISK:
	DMNPSH U	;INDEX OF USER BEING LOGGED OUT
	TLZ U,-1
	DMNPSH UNAME(U)	;UNAME OF USER
	DMNPSH JNAME(U)	;JNAME
	MOVE T,UTRNTM(U)
	MOVE TT,UTMPTR(U)
	ADD T,NCTIM-USRRCE(TT)
	DMNPSH T	;TIME USED, IN 4.069 USEC UNITS
	MOVE T,USIPRQ(U)
	ADD T,NSIPRQ-USRRCE(TT)
	DMNPSH T	;# SWAPIN REQUESTS
		;^ ADD MORE HERE
	DMNRS
	POPJ P,

EBLK
		;DEMON VARIABLES, MUST FOLLOW CODING
		;USE CARE IN REDEFINING SYMBOLS ON THIS PAGE; DEMON JOB RUNNING IN USER MODE
			;LOOKS AT SOME OF THEM, EXCEPT AS INDICATED

DMNBF:	BLOCK DMNBEL*DMNSZ	;BUFFER
DMNBFE::

DMNBC:	0	;ENTRY COUNT, INCREMENTED JUST BEFORE ENTRY ADDED TO DMNBF (USED BY DEMON)
DMNBD:	0	;ENTRY COUNT, INCREMENTED JUST AFTER " " "
DMNBFP:	DMNBF-1	;POINTER INTO BUFFER, HAS ADR OF LAST WORD WRITTEN (NOT USED BY DEMON)

		;NO MORE CODING ALLOWED AFTER THIS POINT

DEFINE DMNPSH A
INFORM DMNPSH AT . = ,\.
TERMIN

DEFINE DMNRS
INFORM DMNRS AT . = ,\.
TERMIN

BBLK

;"SYSTEM" JOBS

IFN TPLP,[
TPLI==11	;PSEUDO LPT IN
PRTO==12	;REAL LPT OUT
]
STYIC==16	;INPUT CH FOR SYSJOB'S CONSOLE I/O
STYOC==17	;OUTPUT "

;CODE FROM ICLR TO IMSG-1 EXECUTED ONLY ONCE (SEE BEG)
ICLR:	MOVE A,[GO,,GO+1]	;PICK UP BLT POINTER (COPY EXCH WORD INTO NEXT)
	SETZM GO	;CLEAR FIRST WORD
	BLT A,IEND	;CLEAR OUT INITIALIZING CODE (IN AREA TO BE USER VAR BLOCKS)
	SKIPL CORRQ	;SKIP IF CORE RQ FOR SYSTEM'S SPACE PROCESSED
	PUSHJ P,UFLS	;WAIT AS NECESSARY
IFGE SYSCON,[
	.OPEN STYOC,[1,,(SIXBIT /TTY/)]
	JRST 4,.
	.OPEN STYIC,[(SIXBIT /TTY/)]
	JRST 4,.
]
IFN CCLKP,[
	JRST .+3	;JFCL FOR CHESS CLK MODE
	PUSHJ P,CLQAD1
	CCLKB
]
	MOVE I,MDSK
	PUSHJ P,QMCH1
	MOVSI I,-NQS
IDSK:	SKIPL QACT(I)
	PUSHJ P,QTCH1
	AOBJN I,IDSK
IFN NETP,[
	MOVE A,TIME
	MOVEM A,LNETIM
	PUSHJ P,IMPINI
]
IMSG:	SRITYP [IN OPERATION]
	JRST IMSGS
IMSG2:	PUSHJ P,DBGINT	;GIVE SYS DEBUG INT TO USERS
IMSGS:	SKIPE SYSDBG	;IF SYS IN DEBUG MODE
DMESSG:	SRITYP [ BEING DEBUGGED]		;SET TO APPROP MSG
	PUSHJ P,SYALCP	;PRINT ON ALL CONSOLES
	SRITYP [SYSTEM JOB USING THIS CONSOLE.
]
	PUSHJ P,SYSSP	;PRINT ON SYS JOB CONSOLE
	MOVSI I,4000
	ANDCAM I,SUPCOR	;IF GOT HERE FROM SYSDBG SET
	JRST DMLD

DMLD1:	PUSHJ P,UDELAY
DMLD:	SKIPL DMLLDF
	JRST SCOR
	CONO PI,CLKOFF
	HRROI T,DMON
	PUSHJ P,NUJBST
	JRST DMLD1
	AOS DMLLDF

		;DROPS THROUGH FROM PREVIOUS PAGE
SCOR:	MOVE P,SYSPDP
	CONO PI,CLKON
	SKIPN SUSRS
	SKIPG SHUTDN
	SKIPA A,SUPCOR
	JRST SYSOUT	;JUMP IF SYS DYING & NO ONE LOGGED IN
	SKIPN SUPCOR	;SKIP IF ANY BITS ON IN SUPCOR
	PUSHJ P,UFLS	;HANG TILL A BIT ON
	MOVE T,SUPCOR	;DON'T TRY TO COMBINE WITH SKIPN
	MOVEI Q,30.	;LOAD LENGTH FOR SLEEP IN 1/30THS OF A SEC
	TDNN T,[-1#<20000,,400003>]	;SKIP IF ANY TRANSIENT BITS ON
	.SLEEP Q,	;ONLY BITS THAT CAN BE ON SEMI-PERMANENTLY ARE ON
			;SLEEP TO AVOID RUNNING CONTINUOUSLY
	MOVSI A,(SETZ)
	MOVEI B,0
SYSDP1:	TDNE A,SUPCOR
	JRST SYSDP2
SYSDP3:	LSH A,-1
	JUMPE A,SCOR
	AOJA B,SYSDP1

SYSDP2:	SKIPGE SYSDTB(B)	;SKIP UNLESS 4.9 BIT OF ENTRY ON
	ANDCAM A,SUPCOR		;4.9 ON, CLEAR SUPCOR BIT
	LDB C,[370200,,SYSDTB(B)]
	TRNE C,2		;IF ROUTINE IS GOING TO USE TTY,
	PUSHJ P,WARMTTY	;THEN WARM IT UP FOR IT
	TRNE C,1
	PUSHJ P,DINGTTY
	LDB T,[420100,,SYSDTB(B)]	;GET 4.8 BIT
	JUMPE T,@SYSDTB(B)	;IF 4.8 BIT = 0, JUMP TO ROUTINE
	PUSH P,A	;4.8 .NE. 0, SAVE A
	PUSH P,B	;SAVE B
	PUSHJ P,@SYSDTB(B)	;CALL ROUTINE
	POP P,B		;RESTORE B
	POP P,A		;RESTORE A
	LDB T,[410100,,SYSDTB(B)]	;GET 4.7 BIT
	JUMPE T,SYSDP3	;IF ZERO RETURN TO LOOP
	ANDCAM A,SUPCOR	;NON-ZERO, CLEAR SUPCOR BIT
	JRST SYSDP3	;LOOP

;DISPATCH TABLE FOR BITS IN SUPCOR
;4.9 = 1 TO CLEAR SUPCOR BIT BEFORE DISPATCHING
;4.8 = 0, JRST TO ROUTINE ; = 1, PUSHJ
;4.7 = 1 TO CLEAR SUPCOR BIT AFTER (ONLY USEFUL IF PUSHJ)
;4.6 WARM UP TELETYPE BEFORE CALL
;4.5 DING BEFORE CALL
SYSDTB:	300000,,SYSEX	;400000,,
	340000,,SYSSHD
	400000,,SYSOUT
	660000,,SYSCK5	;40000,,
	200000,,DATIME
	340000,,SYSTNP
	340000,,SYSSET	;4000,,
	300000,,SYIOTP
	340000,,SYSWRT
	340000,,SYSLGI	;400,,
	300000,,SYSDEC
	640000,,VSCLK
	300000,,SYSGUN	;40,,
	460000,,SYSNET
	400000,,SYSDP3
	360000,,NXMTYP	;4,,
	640000,,QGCMES
	360000,,PARTYP
	200000,,TPLPRT	;400000 PRINT ON TPL
	600000,,VSCL6	;CHECK TPL 
	SYSIMP
IFE PLTP,	400000,,SYSDP3
IFN PLTP,	640000,,PLTUSW	;40000
	340000,,SYSDT
	REPEAT 11.,400000,,SYSDP3	;CAN BE SET BY USER (.SUPSET)
	300000,,TPLOFF
	200000,,SYSCKS	;1

IFN .-SYSDTB-36.,[PRINTX /SYS JOB DISPATCH TABLE LOST
/]

QGCMES:	MOVEI I,[.ASCII /GC OF USER DIR /]
	PUSHJ P,SYSSP
	MOVE A,QGCUSR
	PUSHJ P,SYSSIX
	JRST SYSTCR


VSCLK:			;VERY SLOW CLOCK ROUTINE
	SETOM UFDFLF	;CAUSE CORE JOB TO TRY TO FLUSH 2311 UFDS
	AOS NCORRQ
	MOVSI I,-NCLCH	;LOOK FOR UNOPEND CORE LINK BUFFERS THAT HAVE BEEN
	PUSHJ P,SWTL	;AROUND FOR MORE THAN 2 MINUTES
	CLOSW
VSCLCL:	SKIPE CLSYN(I)	;SKIP IF VARS UNUSED
	SKIPL A,CLUSR(I)
	JRST VSCLC2
	AOJN A,VSCLC2	;JUMP IF OPEN
	MOVE TT,CLRAC(I)
	TLOE TT,200000
	JRST VSCLCR	;BIT ALREADY ON, BUFFER OLD
	MOVEM TT,CLRAC(I)
VSCLC2:	AOBJN I,VSCLCL	;LOOP FOR ALL SETS OF VARIABLES
	PUSHJ P,LSWPOP	;RELEASE SWITCH

IFN NETP,[
	SKIPGE IMPUP	;SKIP IF IMP UP OR DOWN FOR GOOD
	PUSHJ P,SYSIMU	;TRY TO BRING IT UP
]
VSCL6:
IFE TPLP,POPJ P,
IFN TPLP,[
	MOVEI A,400000	;ALSO ENTER HERE FOR TPL CHECK
	TDNE A,SUPCOR	;SKIP IF NOT ALREADY PRINTING FILE
	POPJ P,
  IFG LPTP-1,[
	SKIPE TPLSWP
	JRST VSCL6A
	SKIPLE NLPTBR
	SKIPL LPTUSR
	POPJ P,
VSCL6B:
  ]
  IFLE LPTP-1,[
	SKIPL LPTUSR
	POPJ P,
  ]
  IFG OLPTP-NLPTP,[
	MOVEI A,132.
	CAMLE A,LPTCC
	POPJ P,
  ]
  IFG NLPTP-OLPTP,[
	SKIPG NLPTBR
	POPJ P,	;.OPEN OF LPT WOULD HANG
  ]
	MOVEI A,2
	TDNN A,SUPCOR	;BLOCKED
	AOSE SJDH	;SYSTEM JOB HACKING DISK
	POPJ P,	;SWITCH SEIZED BY CORE ALLOC
	PUSHJ P,SWTLZ
	SJDH
	.OPEN TPLI,[SIXBIT /   TPL.FILE.(DIR)/]	;MAKE SURE FILE DIR IN CORE
	JRST VSCLX1
	MOVEI B,2
VSCL2:	.IOT TPLI,A
	CAIE A,^C
	CAIN A,12
	SOJG B,VSCL2
	JUMPN B,VSCL2
	SETOB I,C
	SETZM TPLFN1
	SETZM TPLFN2
	MOVEI B,TPLFN1
	HRLI B,440600
VSCL2A:	.IOT TPLI,A
	CAIN A,"*
	JUMPL I,VSCL4
	CAIE A,^C
	CAIN A,14
	JRST VSCLX1
	CAIN A,40
	JRST VSCL2F
	JUMPG I,VSCL2E	;HAVE FLUSHED PACK #
	JUMPE I,VSCL2A	;FLUSH PACK #
	CAIN A,"L
	MOVEI C,0	;INDICATE LINK
	AOJA I,VSCL2A	;FIRST NON SPACE CRUFTY

IFG LPTP-1,[
VSCL6A:	MOVEI A,132.
	CAMG A,LPTCC
	SKIPL OLPUSR
	POPJ P,
	JRST VSCL6B
]

VSCL2E:	MOVEI TT,6
VSCL2B:	SUBI A,40
	IDPB A,B
	.IOT TPLI,A
	SOJG TT,VSCL2B
	MOVE B,[440600,,TPLFN2]
VSCL2C:	.IOT TPLI,A
	SUBI A,40
	IDPB A,B
	TLNE B,770000
	JRST VSCL2C
	.IOPUSH TPLI,
	.OPEN TPLI,TPLFN
	JRST VSCLL1	;TRY AGAIN
	.IOPOP PRTO,
	.CLOSE PRTO,
IFG LPTP-1,[
	SKIPE TPLSWP
	JRST VSCL3A
	SKIPLE NLPTBR
	.OPEN PRTO,[3,,(SIXBIT /LPT/)]
	JRST VSCLX1
VSCL3B:
]
IFG OLPTP-NLPTP,[
	MOVEI A,132.
	CAMG A,LPTCC	;SKIP IF .OPEN WOULD HANG
	.OPEN PRTO,[3,,(SIXBIT /LPT/)]
	JRST VSCLX1
]
IFG NLPTP-OLPTP,[
	SKIPLE NLPTBR
	.OPEN PRTO,[3,,(SIXBIT /LPT/)]
	JRST VSCLX1	;SOMEONE STOLE LPT
]
	MOVEI A,400000
	IORM A,SUPCOR	;PRINT THIS FILE
	JRST TPLPR2

IFG LPTP-1,[
VSCL3A:	MOVEI A,132.
	CAMG A,LPTCC
	.OPEN PRTO,[3,,(SIXBIT /OLP/)]
	JRST VSCLX1
	JRST VSCL3B
]

VSCL2F:	JUMPN I,VSCL2A
	AOJA I,VSCL2A	;SPACE AFTER PACK

VSCLL1:	.IOPOP TPLI,
	JUMPL C,VSCLX1
	MOVEI B,1	;LINK THAT DIDN'T EXIST
	JRST VSCL2

TPLPRT:	AOSE SJDH
	POPJ P,
	PUSHJ P,SWTLZ
	SJDH
TPLPR2:
IFG LPTP-1,[
	SKIPE TPLSWP
	JRST TPLPR3
	MOVEI A,TPLBSZ
	CAMLE A,NLPTBR
	JRST LSWPOP
TPLPR5:
]
IFG OLPTP-NLPTP,[
	MOVEI A,10.*TPLBSZ	;LEAVE SPACE FOR CHARS THAT TAKE MORE THAN 1 CHAR
	CAMLE A,LPTCC
	JRST LSWPOP
]
IFG NLPTP-OLPTP,[
	MOVEI A,TPLBSZ
	CAMLE A,NLPTBR
	JRST LSWPOP		;IOT WOULD HANG
]
	MOVE A,[-TPLBSZ,,TPLBUF]	;"UN-RELOCATE"
	.IOT TPLI,A
	MOVNI A,-TPLBUF(A)
	HRLZS A
	JUMPE A,TPLPR1	;JUMP ON END OF FILE
	HRRI A,TPLBUF
	.IOT PRTO,A
	JUMPE A,TPLPR1	;END OF FILE SIG FROM LPTR ROUTINE
	JRST TPLPR2

IFG LPTP-1,[
TPLPR3:	MOVEI A,10.*TPLBSZ
	CAMLE A,LPTCC
	JRST LSWPOP
	JRST TPLPR5
]

TPLPR4:	CLEARM TPLFN3
	.FDELE TPLFN	;DELETE FILE JUST PRINTED
	JFCL
	MOVEI A,400000
	ANDCAM A,SUPCOR
VSCLX1:	.CLOSE PRTO,
	.CLOSE TPLI,
	JRST LSWPOP

VSCL4:	.IOT TPLI,A
	CAIN A,14
	JRST VSCLX1
	CAIN A,12
	JRST VSCL2A
	JRST VSCL4

TPLPR1:	PUSHJ P,TPLPR4
	JRST VSCL6

TPLOFF:	MOVEI A,600000
	TDZN A,SUPCOR
	POPJ P,		;NOTHING HAPPENING
	PUSHJ P,SWTL
	SJDH
	PUSHJ P,WARMTTY
	.RESET PRTO,
	PUSHJ P,TPLPR4
	MOVE A,[SIXBIT /TPLOFF/]
	PUSHJ P,SYSIXP
	JRST SYSTCR
]

IFE TPLP,[
TPLPRT==SYSDP3
TPLOFF==SYSDP3
]

VSCLCR:	HRRZ A,TT
	PUSHJ P,BRTN	;RETURN BUFFER
	SETZM CLSYN(I)	;FREE VARIABLES
	JRST VSCLC2

SYSEX:	PUSHJ P,SCOREX
	POPJ P,
	MOVE A,TIME
	MOVEM A,SCITM
	POPJ P,

SYSDEC:	MOVE A,TIME	;TRY TO DECREASE CORE RESERVED FOR USER VARIABLES
	SUB A,SCITM
	CAIG A,50.
	POPJ P,		;TOO SOON SINCE GOT MORE CORE
	CONO PI,CLKOFF
	MOVE A,USRHI
	SUBI A,LUBLK
	SKIPN UNAME(A)
	JRST .-2
	ADDI A,LUBLK
	MOVEM A,USRHI	;USRHI=> HIGHEST USER+L
	ADDI A,USRSTG
	ADDI A,1777
	SETOM SJCFF
	CONO PI,CLKON	;OK SINCE EXPANSION HAPPENS IN SYS JOB
	MOVEI U,0	;FOR ACORE
	LSHC A,-10.-36.	;MOVE INTO B AS WELL
	PUSHJ P,ACORE
	JRST 4,.	;LOST FLUSHING CORE?
	CLEARM SJCFF
	POPJ P,

SCOREX:	LDB B,[121000,,HUSRAD]	;EXTEND CORE FOR USER VARIABLES AT TOP OF SYSTEM
	AOJA B,SCREX1
SCREX1:	CAILE B,LIOBLK
	MOVEI B,LIOBLK
	MOVEI U,0
	JRST ACORE

SYSGUN:	MOVE U,USRGUN
	MOVE T,TTYTBL(U)
	TLNN T,200000	;SKIP IF NEVER HAD TTY
	SKIPGE APRC(U)
	JRST ALOGOUT	;IF DISOWNED, JUST LOGOUT
	MOVE A,UNAME(U)
	MOVEM A,USRGUN
	PUSHJ P,SDTTY	;GET TTY UP TO TOP LEVEL
	JRST 4,.
	HRRZ T,TTYTBL(U)
	MOVEM T,TTGUND
	PUSHJ P,IODCL	;CAUSE INFERIOR'S RUN TIMES TO BE CONCENTRATED IN NCTIM
	MOVE T,UTMPTR(U)
	MOVE T,NCTIM-USRRCE(T)
	ADD T,UTRNTM(U)
	MOVEM T,TMGUND
	PUSHJ P,ALOGOUT
	MOVEI TT,USRGUN
	MOVE A,(TT)
	PUSHJ P,WARMTTY
	PUSHJ P,SYSG23	;PRINT UNAME TTY#
	MOVEI I,[ASCIZ / GUNNED DOWN BY/]
	PUSHJ P,SYSSP
	MOVE A,UNGUNR
	PUSHJ P,SYSSIX
	MOVE A,JNGUNR
	PUSHJ P,SYSSIX
	MOVE A,TMGUND
	PUSHJ P,SYSG22
	MOVE A,TTGUND
	SETOM TTGUND
	JRST SYSFRE	;OUTPUT CONSOLE FREE MESSAGE

SYSSHD:	LDB D,[221700,,SHUTLK+1]
	PUSHJ P,SWTL
	SHUTLK
	MOVEI I,SYSSHM
	TLO I,40
	PUSH P,D
	PUSHJ P,SYALCP
	POP P,D
	IMULI D,LUBLK
	SKIPE D		;SKIP IF LEFT FROM >5 MIN PRINT OUT
	SKIPN A,UNAME(D)
	JRST LSWPOP
	MOVEI I,[ASCIZ /CULPRIT = /]
	PUSHJ P,SYSSP
	PUSHJ P,SYSSIX
	MOVE A,JNAME(D)
	PUSHJ P,SYSSIX
	PUSHJ P,SYSTCR
	JRST LSWPOP

SYSOUT:	PUSHJ P,CLQDEL
	DEDBLK
	MOVEI U,L*2
SYSCK3:	SKIPGE SUPPRO(U)
	SKIPN UNAME(U)
	JRST SYSCK4
	CAMN U,DMONX
	JRST SYSCK4
	MOVE A,U
	PUSHJ P,1USTOP	;STOP USER
	PUSH P,U
	PUSHJ P,ALOGOUT	;LOG HIM OUT
	POP P,U
SYSCK4:	ADDI U,L
	CAMGE U,USRHI
	JRST SYSCK3
	SRITYP [ NOT IN OPERATION.
]
	PUSHJ P,SYALCP	;TYPE OUT
IFN TPLP,[
	MOVEI A,2	;TPLOFF
	MOVEM A,SUPCOR
]
	MOVE I,QACTB
	IORM I,QMDRO
	MOVSI A,-NQS
SYSCK7:	MOVE I,DCHBT(A)
	SKIPN QACT(A)
	IORM I,QTUTO(A)
	AOBJN A,SYSCK7
	MOVEI A,1
SYSUDM:	SKIPL UDIRO(A)
	.UDISMT A,	;DISMOUNT TAPES
	CAIGE A,NUNITS
	AOJA A,SYSUDM
	SETOM SHUTDN
	JRST SCOR

SYSCK5:	MOVSI A,-128.
SYSC51:	SKIPL B,DCHNTC(A)
SYSC5A:	AOBJN A,SYSC51
	JUMPGE A,CPOPJ
	TLNN B,300000
	JRST SYSC5A
	PUSH P,A
	TLZE B,200000
	JRST SYSC52
	PUSHJ P,SYSC5S
	JRST SYSC53
SYSC52:	PUSHJ P,SYSC5C
SYSC53:	POP P,A
	MOVSI B,300000
	ANDCAM B,DCHNTC(A)
	JRST SYSC5A

SYSC5C:	PUSHJ P,SYSC5B
	MOVEI I,[ASCIZ / CLOBBERED/]
	JRST SYSSTD

SYSC5S:	PUSHJ P,SYSC5B
	MOVEI I,[ASCIZ / SUSPECTED OF INTERRUPTING ON CHANNEL /]
	PUSHJ P,SYSSP
	LDB T,[360300,,DCHNTC(A)]
	PUSHJ P,SYSSOP
	JRST SYSTCR

SYSSOP:	PUSH P,A
	PUSH P,B
	MOVE A,T
	PUSHJ P,SYSOPT
	JRST POPBAJ

SYSC5B:	MOVEI I,[ASCIZ /DEVICE /]
	PUSHJ P,SYSSP
	HRRZ T,A
	LSH T,2
	PUSHJ P,SYSSOP
	MOVEI I,[ASCIZ / (CONI= /]
	PUSHJ P,SYSSP
	HRRZ T,DCHNTC(A)
	PUSHJ P,SYSSOP
	MOVEI I,[ASCIZ /) /]
	JRST SYSSP

SYSCKS:	MOVE A,SYSCKP
	MOVE B,(A)
	MOVEI C,(B)
	EQV C,(B)
	AOBJN B,.-1
	CAME C,CKSUMS-TSTB(A)
	JRST SYSKS2
	AOBJN A,SYSKS1
SYSKS3:	MOVE A,[-LTSTB,,TSTB]
SYSKS1:	MOVEM A,SYSCKP
	POPJ P,

SYSKS2:	EXCH C,CKSUMS-TSTB(A)
	XOR C,CKSUMS-TSTB(A)	;SAVE XOR
	PUSHJ P,DINGTTY
	MOVEI I,[ASCIZ /SYSTEM CLOBBERED BETWEEN /]
	PUSHJ P,SYSSP
	HRRZ A,(A)
	PUSHJ P,SYSOPT
	MOVEI I,[ASCIZ / AND /]
	PUSHJ P,SYSSP
	MOVE B,SYSCKP
	HLRE A,(B)
	SETCMM A	;OFFSET BY ONE
	ADD A,(B)
	HRRZS A
	PUSHJ P,SYSOPT
	MOVEI I,[ASCIZ / XOR= /]
	PUSHJ P,SYSSP
	MOVE A,C
	PUSHJ P,SYSFWP
	MOVEI I,[ASCIZ / !/]
	PUSHJ P,SYSSTD
	CLEARM TCKXOR	;TRY TO DETERMINE EXACT ADR AND PREV CONTENTS
	MOVE A,[TCKXOR,,TCKXOR+1]
	BLT A,TCKXOR+35.
	MOVE A,[-LTSTB,,TSTB]
SYSKS6:	MOVE B,(A)
SYSKS5:	MOVE C,(B)
REPEAT 36.,[IFL .RPCNT-18.,TLNE C,400000_<-.RPCNT>
IFGE .RPCNT-18.,TRNE C,400000_<18.-.RPCNT>
	XORM B,TCKXOR+.RPCNT
	]
	AOBJN B,SYSKS5
	AOBJN A,SYSKS6
	MOVSI D,-36.
SYSKS7:	MOVE A,TCKXOR(D)	;UPDATE CKXORS TBL AND FILL TCKXOR TBL WITH POSSIBLE ADRS
	EXCH A,CKXORS(D)
	XOR A,CKXORS(D)
	HRRZM A,TCKXOR(D)
	AOBJN D,SYSKS7
	PUSHJ P,STYOT	;INDENT LINE
	MOVSI D,-36.
	MOVSI E,400000	;CURRENT BIT
	CLEARB I,J	;COUNT OF #'S PRINTED, CLOBBERED WD
SYSKS8:	SKIPE A,TCKXOR(D)
	AOJA J,SYSKS9	;INCR COUNT OF ADRS PRINTED
SYSKT2:	LSH E,-1
	AOBJN D,SYSKS8
	SOJN J,SYSKT1	;MORE THAN 1 ADR CLOBBERD SO CANT PRINT PREV CONTENTS
	MOVEI T,"=
	PUSHJ P,STYO
	MOVE A,I	;PRINT CONTENTS PRIOR TO CLOBBERAGE
	XOR A,(R)	;XOR CURRENT CONTENTS
	PUSHJ P,SYSFWP
	MOVEI T,"-
	PUSHJ P,STYO
	MOVEI T,">
	PUSHJ P,STYO
	MOVE A,(R)
	PUSHJ P,SYSFWP	;CURRENT CONTENTS
SYSKT1:	PUSHJ P,SYSCRF
	JRST SYSKS3

SCKX1:	PUSH P,T	;UPDATE CKXORS TO REFLECT CHANGING WD IN T IN ADR IN Q
	MOVSI C,-36.
SCKX2:	SKIPGE T
	XORM Q,CKXORS(C)
	LSH T,1
	AOBJN C,SCKX2
	JRST POPTJ

SYSKS9:	PUSHJ P,SYSOPT
	PUSHJ P,STYOS
	MOVE R,TCKXOR(D)	;CLEAR DUP ENTRIES
	MOVE T,D
	MOVE Q,E	;ALSO LEAVE LAST ADR IN R (IN CASE ITS ONLY ADR)
SYSKT3:	CAME R,TCKXOR(T)
	JRST SYSKT4
	CLEARM TCKXOR(T)
	XORM Q,I
SYSKT4:	LSH Q,-1
	AOBJN T,SYSKT3
	JRST SYSKT2

SYSSCT:	HRRZS A
	PUSHJ P,SYSOPT
	MOVEI T,"/
	PUSHJ P,STYO
	PUSHJ P,STYOT	;TAB
	MOVE A,(D)	;GET CURRENT VALUE
	PUSHJ P,SYSFWP
	PUSHJ P,STYOT
	MOVE A,C	;GET NEW VALUE
	JRST SYSFWP

SYSSTD:	PUSHJ P,SYSSP
SYSTCR:	PUSHJ P,STYOS	;TYPE TIME AND CARRIAGE RETURN
	.RTIME B,
	JUMPLE B,SYSCRF
	PUSHJ P,SYSTCD
SYSCRF:	MOVEI T,15
	PUSHJ P,STYO
	MOVEI T,12
	JRST STYO

SYSTCD:	LDB A,[301400,,B]
	PUSHJ P,SYSTWR
	LDB A,[141400,,B]
	PUSHJ P,SYSTWR
	MOVE I,[140600,,B]
	JRST SYSIX2

WARMTTY:
IFE AI,POPJ P,
IFN AI,SKIPA T,[175]	;WARM UP TELETYPE (ONLY ON AI FOR NOW)
DINGTTY:	SKIPA T,[^G]	;DING DING
	PUSHJ P,.+1
	PUSHJ P,.+1
	JRST STYO

	;ROUTINE TO TRANSLATE A INTO 2 DIGIT OCTAL SIXBIT IN STTY

STTYST:	DPB A,[300,,STTY]	;SECOND DIGIT
	ROT A,-3
	DPB A,[60300,,STTY]	;FIRST DIGIT
	ROT A,3
	POPJ P,

		;CHECK DATE AND TIME

EBLK
DATIME:	JRST .+1	;RH MODIFIED TO REFLECT PROGRESS
BBLK		;ROUTINE CALLED BY PUSHJ, BIT NOT AUTOMATICALLY TURNED OFF (IN SUPCOR)
	MOVSI T,40000	;"MFD IN" BIT IN QMDRO
	CONO PI,UTCOFF	;DISABLE INTERRUPTS
	TDNE T,QMDRO	;SEE IF DIRECTORY IN
	JRST UTCONJ	;NOT IN
		;MFD IN, GET CRUD FROM IT
	MOVE A,QMDRO	;GET ORIGIN OF MFD
	SKIPE B,MDYEAR(A)	;YEAR
	MOVEM B,FYEAR
	SKIPE C,MPDOFF(A)	;PDTIME OFFSET
	MOVEM C,PDTIME
	CONO PI,UTCON	;RE-ENABLE INTERRUPTS
	PUSHJ P,GLPDTM	;NOW SEE IF IT'S ALL THERE
	JRST DATIM2	;NOT ALL THERE, DOCUMENT WHAT'S MISSING
	JRST DATIM6	;ALL THERE, TYPE OUT AND CLEAR SUPCOR BIT

		;NOT ALL THERE, DOCUMENT (TYPE OUT) WHAT IS MISSING
		;SHOULD NOT BE NECESSARY TO WARM UP TTY

DATIM2:
IFN PDCLKP,[
	DATAI PDCLK,A	;SEE IF CLOCK ON
	JUMPN A,DATIM3	;JUMP IF CLOCK WINNING
	MOVEI I,[ASCIZ /DECORIOLIS CLOCK LOSES AGAIN!
/]
	MOVEI T,500.
	SOJG T,.	;WAIT AND BE SURE
	DATAI PDCLK,A	;GET DATAI AGAIN
	JUMPN A,DATIM3	;JUMP IF OK NOW
]	PUSHJ P,SYSSP	;COMPLAIN
DATIM8:;	HRROI T,CCTSS	;NOW PREPARE TO LOAD CTSS CALLER FROM SYS:@ CCTSS
;	PUSHJ P,NUJBST	;DO A PSEUDO-CONTROL Z
;	JRST DATIM7
DATIM3:	MOVEI C,0	;COUNTER TO THINGS MISSING FROM MFD
	MOVEI I,[ASCIZ /YEAR, /]
	SKIPG FYEAR	;CHECK YEAR
	PUSHJ P,[AOJA C,SYSSP]	;NOT IN, COMPLAIN
IFN PDCLKP,[
	MOVEI I,[ASCIZ /PDTIME OFFSET, /]
	SKIPN PDTIME
	PUSHJ P,[AOJA C,SYSSP]	;PDTIME OFFSET NOT IN
]
	JUMPE C,DATIM4	;SKIP FOLLOWING IF EVERYTHING ON DISK
	MOVEI I,[ASCIZ /NOT ON DISK.
PLEASE SETLOC APPROPRIATELY.
/]
	PUSHJ P,SYSSP
DATIM4:	SKIPA T,[DATIM5]	;UPDATE DATIME TO WAIT FOR EVERYTHING TO BE THERE
DATIM7:	MOVEI T,DATIM8	;UPDATE DATIME TO WAIT FOR ABILITY TO DO PSEUDO-CONTROL Z FOR CTSS CALLER
	HRRM T,DATIME
	POPJ P,

;CCTSS:	SIXBIT /CCTSS/	;JOB NAME OF CTSS CALLER (ALSO FILE NAME 2 OF FILE LOADED)
;EBLK
;	0		;INDEX OF " (NOT USED BY SYSTEM JOB)
;BBLK

		;WAIT FOR EVERYTHING TO BE THERE
		;THEN TYPE OUT "IT IS NOW...", ETC.

DATIM5:	PUSHJ P,GLPDTM	;CHECK IT
	POPJ P,		;NOT ALL THERE YET
	MOVEI T,DATIME+1	;ALL THERE, RE-INITIALIZE DATIME
	HRRM T,DATIME
DATIM6:	MOVSI T,20000	;BIT IN SUPCOR,
	ANDCAM T,SUPCOR	;TURN IT OFF
	HRRZS TIMOFF	;START UP SLOW CLOCK REAL-TIME ROUTINE
	PUSHJ P,WARMTT	;WARM UP TTY
	PUSHJ P,RYEAR1	;GET DAY OF WEEK IN RELEVANT FIELD OF E
SYSNWP:	MOVEI I,[ASCIZ /IT IS NOW /]
	PUSHJ P,SYSSP	;TYPE IT OUT
	IDIVI A,SPD	;A HAS RESULT OF PUSHJ TO GLPDTM
	PUSH P,A	;SAVE DAY OF YEAR
	MOVE A,B	;GET # SECS SINCE MIDNIGHT IN A
	IDIVI A,SPD/2	;GET AM/PM BIT IN A, 12 HOUR TIME (SECS) IN B
	PUSH P,[SIXBIT / AM    PM/](A)	;REMEMBER WHAT HALF-DAY
	PUSHJ P,RTIME	;CONVERT TIME TO SIXBIT
	MOVE B,A
	TLNN B,170000	;IF LEADING DIGIT IS ZERO,
	TLZ B,770000	;THEN TURN IT INTO A BLANK
	PUSHJ P,SYSTCD	;TYPE OUT TIME
	POP P,B		;RESTORE AM OR PM WORD
	PUSHJ P,SYS6	;TYPE IT OUT
	MOVE B,[SIXBIT / EST,/]
	TLNE E,100000	;DST BIT
	HRLI B,(SIXBIT / ED/)	;DAYLIGHT SAVINGS TIME, TYPE OUT EDT INSTEAD OF EST
	PUSHJ P,SYS6	;TYPE IT OUT
	PUSHJ P,STYOS	;TYPE A SPACE
	LDB B,[320300,,E]	;GET DAY OF WEEK (0 => SUNDAY)
	MOVE B,DOWTBL(B)	;MON, TUES, WEDNES, ETC. (IN SIXBIT)
	PUSHJ P,SYS6	;TYPE IT OUT
	MOVEI I,[ASCIZ /DAY, /]	;FINISH ON DAY OF WEEK
	PUSHJ P,SYSSP	;" " "
	POP P,A		;RESTORE DAY OF YEAR
	PUSHJ P,RDATE1	;CALCULATE MONTH AND DAY
	MOVE B,NMNTBL-1(B)	;GET SIXBIT FOR MONTH
	PUSHJ P,SYS6	;TYPE OUT MONTH
	PUSHJ P,STYOS	;TYPE A SPACE
	MOVE A,C	;GET DAY OF MONTH IN A
	PUSHJ P,SYSDPT	;TYPE OUT IN DECIMAL
	MOVEI T,",
	PUSHJ P,STYO	;TYPE A COMMA
	MOVEI A,(E)	;GET YEAR
	PUSHJ P,SYSDPT	;TYPE IT OUT
	JRST SYSCRF	;END WITH CRLF

		;TABLE OF NAMES OF MONTHS (FIRST THREE LETTERS, IN SIXBIT)

NMNTBL:	MNIRP [SIXBIT /M/]

		;TABLE OF SIXBIT NAMES FOR DAYS OF THE WEEK
		;(THE "DAY" ON THE END LEFT OFF)

DOWTBL:	IRPS D,,[SUN MON TUES WEDNES THURS FRI SATUR]
	SIXBIT /D/
	TERMIN
IFN .-DOWTBL-7,[PRINTC /BARF AT DOWTBL
/]

		;TYPE OUT THE SIXBIT WORD IN B, QUIT WHEN WHAT IS LEFT IS BLANK

SYS6:	JUMPE B,CPOPJ	;RETURN WHEN NOTHING LEFT
	MOVEI A,0	;INITIALIZE FOR LSH
	LSHC A,6	;SHIFT A CHARACTER IN
	MOVEI T,40(A)	;CONVERT TO SIXBIT AND GET IN T
	PUSHJ P,STYO	;TYPE OUT THE CHARACTER
	JRST SYS6	;LOOP BACK FOR NEXT CHARACTER

SYALCP:	TLNN I,40
	HRLI I,440700	;SYSTEM ALL CONSOLES PRINT
	MOVEI A,0
	.IOPUSH STYOC,
SYALC1:	MOVE Q,TTYTYP(A)
	TLNN Q,10000
	PUSHJ P,SYSTSU
	AOJA A,SYALC3
	TLNE I,40
	JRST SYALC5
	MOVE Q,I	;SO NOT TO MUNG I UNTIL END
SYALC2:	ILDB E,Q
	JUMPE E,SYALC4	;JUMP IF DONE
	.IOT STYOC,E	;COPY CHARACTER
	JRST SYALC2	;GO GET NEXT CHARACTER

SYALC5:	PUSH P,I
	PUSH P,A
	PUSHJ P,(I)
	POP P,A
	POP P,I
SYALC4:	MOVSI E,400000
	IORM E,TTYSTA(A)	;DONT NEED CONSOLE FREE MSG ANY MORE
	.CLOSE STYOC,	;DONE WITH THIS CONSOLE
	AOS A		;INCREMENT CONSOLE NUMBER
SYALC3:	CAIG A,NCT	;IF MORE CONSOLES LEFT,
	JRST SYALC1	;THEN PRINT OUT ON NEXT ONE
	.IOPOP STYOC,
	TLNN I,40
	JRST SYSSP	;PRINT OUT ON SYSJOB CONSOLE
	JRST (I)

	;SYSTEM JOB RADIX PRINT-OUT ROUTINES
	;FULL WORD (TWO HALFWORD) OCTAL:
SYSFWP:	TLNN A,-1	;IF LH=0,
	JRST SYSOPT	;THEN PRINT ONLY RH
	LSHC A,-18.
	HLLM B,(P)
	PUSHJ P,SYSOPT
	HLRZ A,(P)
	MOVEI T,",	;",," BETWEEN HALFWORDS
	PUSHJ P,STYO
	PUSHJ P,STYO

	;OCTAL PRINTOUT, NO LEADING ZEROS, HALFWORD MAXIMUM
SYSOPT:	IDIVI A,10
	JUMPE A,SYSRP1
	HRLM B,(P)
	PUSHJ P,SYSOPT
SYSRP2:	HLRZ B,(P)	;ENTRY POINT FROM DECIMAL TYPEOUT ROUTINE
SYSRP1:	MOVEI T,"0(B)	;" " "
	JRST STYO

	;DECIMAL PRINTOUT, COMMAS EVERY 3 DIGITS, FULLWORD MAXIMUM
SYSDPC:	MOVE 0,A	;ROUTINE EXPECTS ARGUMENT IN A, CLOBBERS 0, A(=0+1), B(=A+1)
SYSDP5:	IDIVI 0,1000.	;GET LEAST SIGNIFICANT 3 DIGITS IN A
	JUMPE 0,SYSDPT	;PRINT HIGH ORDER DIGITS WITHOUT LEADING ZEROES
	HRLM A,(P)
	PUSHJ P,SYSDP5
	HLRZ A,(P)
	MOVEI T,",	;SINCE 3*N DIGITS LEFT TO BE TYPED, N>0,
	PUSHJ P,STYO	;PRINT OUT A COMMA
	MOVEI T,3	;NUMBER OF DIGITS TO PRINT OUT
	;ROUTINE TO PRINT OUT AS MANY DECIMAL DIGITS AS SPECIFIED IN T
SYSLZP:	IDIVI A,10.
	SOJLE T,SYSRP1
	HRLM B,(P)
	PUSHJ P,SYSLZP
	JRST SYSRP2
SYSDPT:	IDIVI A,10.
	JUMPE A,SYSRP1
	HRLM B,(P)
	PUSHJ P,SYSDPT
	JRST SYSRP2

SYSTNP:	HRRZ A,SYSPNT	;CONSOLE FREE, ETC
	PUSHJ P,SYSFRE
	SKIPL SYSPNT
	POPJ P,
	MOVEI I,[ASCIZ / LOGOUT /]
	PUSHJ P,SYSSP
	MOVEI TT,SYSPN3
	MOVE A,(TT)
	PUSHJ P,SYSG23
	MOVE A,SYSPN4
SYSG22:	MOVEI I,[ASCIZ / TUSED= /]	;ENTRY FROM SYSGUN
	PUSHJ P,SYSSP
	MULI A,4069.
	DIVI A,1000.
	PUSHJ P,SYSDPC
	MOVEI I,[ASCIZ / USECS/]
	JRST SYSSTD

SYSFRE:	PUSH P,A
	.IOPUSH STYOC,
	PUSHJ P,SYSTSU
	JRST 4,.
SYSDT4:	SRITYP  CONSOLE 
	PUSHJ P,SYSSP
	PUSHJ P,SYSOPT
	MOVEI I,[.ASCII / FREE./]
	PUSHJ P,SYSSTD
	XCT DMESSG
	SKIPE SYSDBG
	PUSHJ P,SYSSTD
	SKIPLE SHUTDN
	PUSHJ P,SYSSHM
	POP P,A
	MOVSI T,(SETZ)
	IORM T,TTYSTA(A)	;INDICATE MESSAGE TYPED
	.IOPOP STYOC,	;CLOSES CHNL IF NECESSARY
	POPJ P,

SYSTSU:	PUSHJ P,STTYST	;SET UP OPEN
	.OPEN STYOC,STTY
	POPJ P,
	AOS (P)
	.STATUS STYOC,B
	ANDI B,77
	CAIE B,SNTDS	;TERMINAL DISPLAY
	POPJ P,
	MOVEI T,^P
	PUSHJ P,STYO
	MOVEI T,"C
	JRST STYO

SYSSHM:	SRITYP  GOING DOWN IN 
	SKIPG SHUTDN
	SRITYP REVIVED
	PUSHJ P,SYSSP
	PUSHJ P,STYOS
	SKIPG SHUTDN
	JRST SYSSHN
	.DIETI B,
	IDIVI B,30.	;CONVERT TO SECONDS
	PUSHJ P,RTIME	;CONVERT TO SIXBIT
	MOVE B,A
	PUSHJ P,SYSTCD
SYSSHN:	MOVEI I,[.ASCII /.  /]
	JRST SYSSTD

;DETACH ANY TREES WHOSE TOP-LEVEL JOBS HAD FATAL INTS

SYSDT:	MOVEI J,0
	CONO PI,CLKOFF
	MOVSI B,BUSRC
SYSDT0:	SKIPGE SUPPRO(J)	;LOOK FOR TOP-LEVEL
	SKIPGE APRC(J)	;NON-DISOWNED JOBS
	JRST SYSDT1
	TDNE B,USTP(J)	;THAT HAS BEEN STOPPED AS BY SUPERIOR
	JRST SYSDT2
SYSDT1:	ADDI J,LUBLK
	CAMGE J,USRHI
	JRST SYSDT0
	JRST CLKONJ	;NO MORE SUCH JOBS, DONE

SYSDT2:	CONO PI,CLKON
	MOVEI U,0
	PUSHJ P,NDETA0	;FOUND SUCH A JOB, DETACH IT
	JRST 4,.
	JRST SYSDT	;TRY FOR ANOTHER

SYSDT3:	PUSH P,A	;TYPE A MODIFIED CONSOLE FREE MSG
	.IOPUSH STYOC,	;SAYING TREE WAS DETACHED. CALLED FROM NDETACH
	PUSHJ P,SYSTSU
	JRST 4,.
	MOVEI I,[ASCIZ /TOP LEVEL INTERRUPT, TREE DETACHED
/]
	PUSHJ P,SYSSP
	JRST SYSDT4

STYOQ:	MOVEI T,"?	;TYPE OUT "?"
	JRST STYO

STYOT:	SKIPA T,[11]	;TAB
STYOS:	MOVEI T,40	;TYPE OUT A SPACE
STYO:
IFL SYSCON,	SKIPE IOCHNM+STYOC	;DONT GET IOC ERROR
	.IOT STYOC,T
	POPJ P,

SYSP:	MOVE J,[440300,,I]
	MOVE I,T
SYSP1:	ILDB T,J
	ADDI T,"0
	PUSHJ P,STYO
	TLNE J,770000
	JRST SYSP1
	POPJ P,

SYSSP:	HRLI I,440700	;ENTRY TO TYPE C(I) AS A POINTER TO ASCIZ
SYSSP2:	ILDB T,I
	JUMPE T,CPOPJ
	PUSHJ P,STYO
	JRST SYSSP2

SYSTWR:	LSH A,30-18.
	ADDI A,(SIXBIT /  :/)
	MOVE I,[220600,,A]
	JRST SYSIX2
SYSSIX:	PUSHJ P,STYOS	;TYPE A SPACE AND FALL IN
SYSIXP:	MOVE I,[440600,,A]	;ENTRY TO TYPE OUT C(A) AS SIXBIT
SYSIX2:	ILDB T,I
	ADDI T,40
	PUSHJ P,STYO
	TLNN I,770000
	POPJ P,
	JRST SYSIX2

	;.SETLOC ROUTINE (DOCUMENT THEN DOES IT)

SYSSET:	MOVE A,SETSLC	;LOCATION TO BE MODIFIED
	TLNN A,-1	;SKIP IF ALREADY DONE
	SKIPA C,SETSLQ	;NEW VAL IN SETSLQ
	SKIPA C,(A)	;NEW VAL IN LOC
	SKIPA D,A	;OLD VAL IN @A
	MOVEI D,SETSLQ	;OLD VAL IN SETSLQ
	PUSHJ P,SYSSCT	;PRINT OUT DDT-TYPE SEQUENCE
	MOVE A,SETSU	;GET USET NAME
	PUSHJ P,STYOT	;TYPE OUT A TAB
	MOVEI B,0
	PUSHJ P,SYSIXP	;PRINT NAME OF GUILTY PARTY
	PUSHJ P,SYSTCR	;STANDARD SYS CARRIAGE RETURN
	SKIPGE SETSLC	;IF ALREADY MUNGED AT UUO LEVEL
	POPJ P,		;THEN EXIT NOW
	MOVE T,SETSLQ	;GET DESIRED VALUE
;	SKIPL UMBTS
;	JRST SYSSE8	;DON'T HACK METABITS
;	LMB Q,@SETSLC	;GET META BIT OF DESIRED LOCATION
;	TRNE Q,1	;IF 1 THEN HAVE TO MOMENTARILY CLEAR IT
;	JRST SYSSE5
SYSSE8:	EXCH T,@SETSLC	;META BIT=0, CHANGE LOCATION
SYSSE6:	MOVE Q,SETSLC	;GET ADR OF MUNGED LOC
	MOVE A,[-LTSTB,,TSTB]
SYSSE1:	MOVE B,(A)
	CAIGE Q,(B)
	JRST SYSSE3
	HLRE C,B
	SETCMM C
	ADD C,B
	CAILE Q,(C)
	JRST SYSSE3
	PUSHJ P,SCKX1	;UPDATE CKXORS TBL TOO
	EQV T,@SETSLC
	EQVM T,CKSUMS-TSTB(A)
	MOVE T,@SETSLC
	PUSHJ P,SCKX1	;UPDATE TO REFLECT NEW CONTENTS
SYSSE2:	CAIE Q,SYSDBG	;IF NOT DEBUG SWITCH
	POPJ P,		;EXIT
	SUB P,[1,,1]	;UNSCREW PDL TO EXIT WITH JRST
	SKIPN A,SYSDBG	;IF DEBUG FLAG JUST CLEARED
	JRST IMSG	;OUTPUT NEW MESSAGE
	JUMPL T,@1(P)	;IF OLD VAL NEG JUST EXIT
	JRST IMSG2

SYSSE3:	AOBJN A,SYSSE1
	JRST SYSSE2

		;SETLOC ROUTINE TO MODIFY LOCATION WITH META BIT = 1

;SYSSE5:	MOVEI D,0
;	SMB D,@SETSLC
;	EXCH T,@SETSLC
;	SMB Q,@SETSLC
;	JRST SYSSE6

SYSLGI:	MOVEI I,[ASCIZ / LOGIN  /]
	PUSHJ P,SYSSP
	MOVEI TT,SLGIV	;.LOGIN
	MOVE A,(TT)
	CAMN A,[-1]
	JRST 4,.
	PUSHJ P,SYSG23
	SKIPE A,SLGIV+2
	PUSHJ P,SYSSIX
	JRST SYSTCR

SYSG23:	PUSHJ P,SYSIXP
	PUSHJ P,STYOS
	HRRZ A,1(TT)	;PICK UP TTY NUM
	JRST SYSOPT

NXMTYP:	MOVEI I,[ASCIZ /NON-EX MEM ERROR #/]
	MOVEI TT,1
	JRST MEMTYP

PARTYP:	MOVEI I,[ASCIZ /PARITY ERROR #/]	;PARITY ERROR
	MOVEI TT,0
MEMTYP:	PUSHJ P,SYSSP
	MOVE A,PARERR(TT)
	PUSHJ P,SYSOPT
	MOVEI I,[ASCIZ / PC = /]
	PUSHJ P,SYSSP
	MOVE T,PARPC(TT)
	PUSHJ P,SYSP
	MOVEI I,[ASCIZ / USER = /]
	PUSHJ P,SYSSP
	MOVE D,PARUSR
	MOVE A,UNAME(D)
	PUSHJ P,SYSSIX
	PUSHJ P,STYOS
	MOVE A,JNAME(D)
	PUSHJ P,SYSSIX
	PUSHJ P,SYSTCR
	SOSGE D,PARCNT
	POPJ P,
	MOVEI I,[ASCIZ /PARITY ERRORS:
/]
	PUSHJ P,SYSSP
SYSPR1:	PUSHJ P,STYOT	;TYPE TAB
	MOVE A,PARADR(D)
	PUSHJ P,SYSFWP
	PUSHJ P,STYOT
	MOVE A,PARCON(D)
	PUSHJ P,SYSFWP
	PUSHJ P,SYSCRF
	SOJGE D,SYSPR1
	POPJ P,

SYIOTP:	MOVE C,SYIOTL	;.IOTLSR
	SKIPN A,UNAME(C)
	POPJ P,
	PUSHJ P,WARMTTY
	PUSHJ P,SYSIXP
	MOVE A,JNAME(C)
	PUSHJ P,SYSSIX
	MOVE A,[SIXBIT /IOTLSR/]
	PUSHJ P,SYSSIX
	JRST SYSTCR

SYSWRT:	MOVE A,SWUNAM	;WRITE ON SYS DEVICE
	PUSHJ P,SYSIXP
	MOVE A,SWJNAM
	PUSHJ P,SYSSIX
	MOVSI A,(SIXBIT /SYS/)
	PUSHJ P,SYSSIX
	MOVE A,SWFN1
	PUSHJ P,SYSSIX
	MOVE A,SWFN2
	PUSHJ P,SYSSIX
	MOVE B,SWMOD
	MOVE A,[SIXBIT /LINK/]
	TRNE B,100000
	JRST SYSWR3
	MOVE A,[SIXBIT /DELRNM/]
	TRNE B,200000
	JRST SYSWR3
	MOVE A,[SIXBIT /WRITE/]
SYSWR3:	PUSHJ P,SYSSIX
	JRST SYSTCR

SYSNET:
IFE NETP,JRST SCOR
IFN NETP,[
	MOVEI I,[ASCIZ /NETWORK DOWN, ALL CONNECTIONS ABORTED
/]
	PUSHJ P,SYSSP
	MOVE A,TIME
	EXCH A,LNETIM
	SUB A,LNETIM
	ADDI A,30.*30.
	PUSH P,A
	PUSHJ P,SYSNT5
	MOVE P,SYSPDP
	JRST SCOR

;IMPUP IS -1 SO NO NEW OPENS CAN HAPPEN.  STILL HAVE TO PCLSR
;THOSE USERS RUNNING IN OPEN.
SYSNT5:	PUSHJ P,LSTSTP	;PCLSR ALL USERS IN .OPEN
	NETLST
	MOVSI I,-IMPSTL
SYSNT2:	SKIPN A,IMSOC1(I)
	JRST SYSNT1
	TLNN A,200000
	JRST SYSNT4	;CHNL NOT BEING CLOSED
	CONO PI,CLKOFF
	SETZM IMSOC1(I)	;JUST FLUSH CHNL
	SOS IMNCS
	CONO PI,CLKON
	JRST SYSNT1	;AND IGNORE
SYSNT4:	HRRZS A
	PUSHJ P,IFSTOP	;STOP NETWORK USER
	PUSHJ P,CHSCAA
	PUSHJ P,SYSNT3	;HACK IOCHNM WORDS OF NET USER
SYSNT1:	AOBJN I,SYSNT2
	CONO PI,CLKOFF
	MOVNI H,1
	PUSHJ P,NTCLQD
	CONO PI,CLKON
	SKIPLE -1(P)
	JRST LSWCLR	;LAST TIME DOWN WAS < HALF MINUTE AGO
	PUSHJ P,IMPINI
	PUSHJ P,LSWCLR	;RESTART OLD NETWORK USERS
	MOVEI I,[ASCIZ /NETWORK UP AGAIN
/]
	JRST SYSSP	;PRINT AND RETURN

SYSNT3:	HRRZ C,(R)
	CAIL C,NETDUI
	CAILE C,NETDBO
	POPJ P,		;NOT A NETWORK CHANNEL
	HLRE C,(R)	;SOCKET MAP INDEX
	JUMPL C,CPOPJ
	SKIPN C,IMSOC6(C)
	JRST SYSNT6	;NO BUFFER
	PUSH P,A
	HLRZ A,C
	ANDI A,377
	PUSHJ P,BRTN
	POP P,A
SYSNT6:	HRROS (R)	;SET LH OF IOCHNM TO -1
	HRRZ C,R
	SUBI C,IOCHNM(A)
	MOVE C,CHNBIT(C)
	IORM C,IFPIR(A)	;INTERRUPT USER
	POPJ P,
]
SYSIMP:
IFE NETP,	JRST SCOR
IFN NETP,[
	PUSHJ P,SYSIMU
	JRST SCOR

SYSIMU:	PUSH P,[-1]
	SKIPE IMPUP	;WORLD IS ALREADY UP
	PUSHJ P,SYSNT5	;RESET THE WORLD
	SUB P,[1,,1]
	MOVEI I,100000
	ANDCAM I,SUPCOR
	POPJ P,
]

LSTSTP:	MOVE T,@(P)	;POINTER TO FIRST ELEMENT OF LIST
	CONO PI,CLKOFF
	MOVE T,(T)
LSTST1:	HRRZS T
	SKIPN A,T	;ADDRESS OF LSWB BLOCK
	JRST CLKOJ1
	MOVEI A,-USRSTG(A)
	IDIVI A,LUBLK
	IMULI A,LUBLK	;USER INDEX
	PUSH P,(T)
	PUSHJ P,IFSTOP	;STOP USER, ADDING HIS USTP TO OUR LSWPR
	POP P,T
	JRST LSTST1
IFN PLTP,[

PLTUSW:	MOVEI I,[ASCIZ /PLOTTER USER /]
	PUSHJ P,SYSSP
	MOVE A,PLOTUN
	PUSHJ P,SYSSIX
	JRST SYSTCR

]
;***** DCHNTB *****
;4.9 = KNOWN DEVICE
;4.8 = HAS PIA 2
;4.7-4.4 PIA 2 SHIFT
;4.3-4.1 PIA 2 ACTIVE VALUE
;3.9 = PIA 2 MAY BE ZERO
;3.8 = HAS PIA 1
;3.7-3.4 PIA 1 SHIFT
;3.3-3.1 PIA 1 ACTIVE VALUE
;2.9 = PIA 1 MAY BE ZERO
;2.8 = ALLOW USER DATAI
;2.7 DATAO
;2.6 CONI
;2.5 CONO
;1.6-1.1=N, IF NON ZERO: IGNORE DEV UNLESS CONI BIT N-1 IS ON
		;(IF DSDEV PRESENT)

;***** DHCNTC *****
;4.9 = SUSPICIOUS DEVICE
;4.8 = FOUND CLOBBERED
;4.7 = SUSPECTED OF CAUSING SPURIOUS INTS
;4.6-4.4 = CHANNEL CAUSING INTS ON
;3.9-3.1 = SUSPICION COUNT
;2.9-1.1 = CONI

DCHNTB:	400200+APRCHN,,240000	;0 APR
	SETZ	;4 PI

DEFINE DCHENT D,W
LOC DCHNTB+D_-2
	W
	TERMIN

IFN DSDP,	DCHENT DSDEV,[REPEAT 2,400200+DSDCHN,,440000]	;20,24
IFN STKP,	DCHENT STK,[400200+LPTCHN,,440000]	;70 STK
	DCHENT PTP,[400200+PCHCHN,,440000]	;100 PTP
	DCHENT PTR,[400200+PTRCHN,,440000]	;104 PTR
	DCHENT TTY,[400200+TTYCHN,,40000]	;120 TTY
IFN OLPTP,	DCHENT OLPT,[400200+LPTCHN,,440000]	;124 OLPT
IFN 340P,	DCHENT DIS,[630600+DISCHN+SDCHN_9,,440001]	;130 DIS
IFE NEWDTP,[
	DCHENT DC,[400000,,440000]	;200 DC
	DCHENT UTC,[400200+UTCCHN,,440000]	;210 UTC
	DCHENT UTS,[SETZ 40000]		;214 UTS
]
IFN DECDKC,	DCHENT DPC,[400200+DSKCHN,,440000]	;250 DPC
IFN NEWDTP,[
	DCHENT DTC,[630600+UTCCHN+DCCHN_9.,,440000]	;320
	DCHENT DTS,[SETZ 40000]	;324
]
IFN NMTCS,[
	DCHENT MTC,[400200+MTCCHN,,440001]
	DCHENT MTS,[SETZ 40001]		;344 MTS
]
IFN MTYP,	DCHENT MTY,[400200+TTYCHN,,40000]	;400 MORTON BOX
IFN NDAP,	DCHENT 454,[400200,,760000]	;454 D/A
IFN NETP,	DCHENT IMP,[400200,,400001]	;460 IMP
IFN NLPTP,	DCHENT NLPT,[400200+LPTCHN,,440000]	;464 NEW LPT
IFN ARMP,	DCHENT TIPDEV,[400200+TIPBCH,,440000]	;504 ARM TIP BREAK
	DCHENT 510,[400000,,360000]
IFN RBTCP,	DCHENT RBTCON,[400200+TABCHN,,440001]	;514 ROBOT CONSOLE
IFN ARMP,	DCHENT 564,[400200,,440000]	;564 ARM TACTILE SENSE
IFN OMXP,	DCHENT OMPX,[400200+OMPCHN,,440001]	;570 OMX
IFN IMXP,	DCHENT MPX,[SETZ 40001]		;574 IMX
IFN TK10P,	DCHENT NTY,[400200+TTYCHN,,40000]	;600 NTY
IFN DPKPP,	DCHENT DPK,[400200+TTYCHN,,40000]	;604 DATAPOINT KLUDGE (REMOVE MAY BE 0 BIT WHEN REALLY MAKES IT)
IFE DECDKC,[
	DCHENT DC0,[400200+DSKCHN,,4000]	;610 DC0
	DCHENT DC1,[400000,,]	;614 DC1
]
IFN VIDP,	DCHENT NVDX,[REPEAT 4,400200+NVDCHN,,440001]	;620-634 BAT
IFN PLTP,	DCHENT PLT,[400200+PLTCHN,,440000]	;654 PLT
	DCHENT 704,[400000,,440000]
IFN HCLKP,[
	DCHENT CLK1,[400200,,240000]	;710 CLK1
	DCHENT CLK2,[SETZ 40000]		;714 CLK2
]
LOC DCHNTB+127.
EBLK
DCHNTC:	BLOCK 128.
CHSPUR:	BLOCK 8	;NUM OF SUPRIOUS INTS PER CH (ZERO = DCHK)
DCACS:	BLOCK 20	;SAVE ACS
CCSDEV:	0	;+ => SOME SUSPICIOUS DEVICES
BBLK

DCHK:	0	;TO CALL FROM DDT
	MOVEM 17,DCACS+17
	MOVEI 17,DCACS
	BLT 17,DCACS+16
	MOVEI J,0
	JSP E,SPUR
	SKIPN W
	AOS DCHK
	MOVEI 17,DCACS
	BLT 17,17
	JRST @DCHK

;CHECK FOR CLOBBERED DEVS, CALL WITH JSP E,
CHECK:	JSP H,DCSTUP
CHECK1:	SKIPL TT,DCHNTB(I)
	JRST CHECK4
IFN DSDP,[
	TRNN TT,77
	JRST CHECK2
	ANDI TT,77
	JSP H,DCCONI
	LSH B,-1(TT)
	JUMPGE B,CHECK4
	MOVE TT,DCHNTB(I)
]
CHECK2:	JSP H,DCCONI
	TLNN TT,200	;SKIP IF PI TO TEST
	JRST CHECK4
	LDB T,[250400,,TT]	;GET SKIP
	MOVEI Q,7
	LSH Q,(T)
	AND B,Q
	LDB Q,[220300,,TT]	;GET CHANNEL
	LSH Q,(T)
	CAME B,Q
	JRST CHECK5
CHECK3:	LSH TT,-9	;SHIFT TO PIA2
	JRST CHECK2

CHECK5:	JUMPN B,CHECKL	;JUMP IF NONZERO AND WRONG
	TRNE TT,400000	;SKIP IF CAN NOT BE ZERO
	JRST CHECK3	;ZERO OK
	JRST CHECKL

CHECK4:	ADD A,[400,,]	;INCREMENT DEVICE CODE
	AOBJN I,CHECK1
SPURCX:	SKIPE C
	JRST 4,.+1	;BIT STUCK ON IN I/O BUS?
	MOVSI T,40000
	SKIPE W		;SKIP IF NO TROUBLE DETECTED
	IORM T,SUPCOR
	JRST (E)

DCSTUP:	MOVE A,[CONI B]	;SET UP
	MOVEI W,0
	MOVNI C,1
	MOVSI I,-128.
	JRST (H)

DCCONI:	XCT A
	AND C,B
	SKIPL DCHNTC(I)	;SKIP IF DEVICE ALREADY SUSPICIOUS,SAVES FIRST SUSPICIOUS
	HRRM B,DCHNTC(I)	;STORE AWAY CONI
	JRST (H)

CHECKL:	JSP H,DCSAOS
	MOVSI T,600000	;CLOB
	IORM T,DCHNTC(I)
	JRST CHECK3

DCSAOS:	MOVE D,A	;MAKE A CONO
	TDZ D,[40,,-1]
	SKIPL T,DCHNTB(I)	;SKIP IF KNOWN DEV
	JRST DCSAS2	;JUST RESET UNKNOWN TO ZERO
	TLNE T,200000	;SKIP IF NO PIA2
	TLNE T,400	;SKIP IF PIA2 CAN NOT BE ZERO
	JRST DCSAS1
	LDB TT,[330300,,T]	;GET PIA2
	LDB T,[360400,,T]	;GET PIA2 SHIFT
	LSH TT,(T)
	IOR D,TT		;ADD CORRECT CANNEL TO CONO
	MOVE T,DCHNTB(I)	;SKIP IF NO PIA1
DCSAS1:	TLNE T,200	;SKIP IF PIA1 CANNOT BE ZERO
	TRNE T,400000
	JRST DCSAS2
	LDB TT,[220300,,T]	;GET P1A 1
	LDB T,[250400,,T]	;GET PIA 1 SHIFT
	LSH TT,(T)		;OR IN PIA 1
	IOR D,TT		;ZAP
DCSAS2:	XCT D
	HLRZ T,DCHNTC(I)
	TLNN T,300000
	AOS W	;THIS MAY BE THE CAUSE OF OUR TROUBLES
	ANDI T,777
	AOS T
	AOS CCSDEV
	CAILE T,777
	SOJA T,[JRST 4,.+1]	;LOSEY LOSEY
	DPB T,[221100,,DCHNTC(I)]
	JRST (H)

;CHANNEL IN J SPURIOUS INTERRUPT ON, CALL WITH JSP E,
SPUR:	SKIPL J
	CAIL J,10
	JRST 4,SPUR1
	AOS U,CHSPUR(J)
SPUR1:	MOVE U,E
	JSP E,CHECK
	MOVE E,U
	JSP H,DCSTUP
SPUR2:	SKIPGE TT,DCHNTB(I)
	JRST SPUR4
	JSP H,DCCONI
	JUMPGE B,SPUR4
	JSP H,DCSAOS
	MOVSI T,500000
	IORM T,DCHNTC(I)
	DPB J,[360300,,DCHNTC(I)]
SPUR4:	ADD A,[400,,]
	AOBJN I,SPUR2
	JRST SPURCX;PC LSR TEST FEATURE
;CALLED BY PCLT MACRO
;WHICH ASSEMBLES

;SKIPE PCLDBM
;PUSHJ P,PCLTST

PCLTST:	PUSH P,U
	MOVE U,PCLIDX
	MOVEM U,PCLHT
	MOVE U,USER
	CAME U,PCLUSR
	JRST POPUJ
PCLX:	CAIA	;PATCH IN OTHER CHECKS (SHOULD JRST POPUJ TO IGNORE)
	MOVE U,USER	;PATCH ROUTINE MAY CLOBBER U
	AOSN PCLNXT
	JRST PCLT1	;FOUND PLACE, CAUSE PCLSR
	HRRZ U,-1(P)
	CAME U,PCLL
	JRST POPUJ	;NOT MARK (NOT AT RIGHT LOCN)
	HRRO U,USER	;4.9 U FLAG 
PCLT1:	PUSH P,A	;COMPUTE HASH ADR OF RETURNS ON PDL
	PUSH P,B
	PUSH P,C
	HRREI A,-USRSTG(P)
	JUMPL A,PCLT1A	;SYS JOB'S PDL?
	IDIVI A,LUBLK
	IMULI A,LUBLK
	MOVEI A,USRPDL(A)	;GET START OF USERS PDL IN A
PCLT3:	HRRZ B,(A)
	JUMPE B,PCLT2
	CAIL B,HSYSCD
	JRST PCLT2
	HLRZ C,-1(B)
	TRZ C,37
	CAIE C,(PUSHJ P,)
	JRST PCLT2
	XOR B,PCLHT
	ROT B,1
	MOVEM B,PCLHT
PCLT2:	CAIGE A,-2-3(P)
	AOJA A,PCLT3
	MOVE A,PCLHT	;COMPUTED HASH
	JUMPGE U,PCLT4	;GOING TO PCLSR HERE, STORE HASH AS MARK FOR NEXT TIME
	CAME A,PCLHSH
	JRST PCLT5
	SKIPGE PCLDBM
	JRST PCLT6	;IN HOLD MODE, PCLSR HERE
	SETOM PCLNXT	;FOUND MARK, PCLSR NEXT TIME
PCLT5:	POP P,C
	POP P,B
	POP P,A
	JRST POPUJ

PCLT4:	MOVEM A,PCLHSH	;STORE HASH FOR NEXT TIME
	HRRZ A,-3-1(P)
	MOVEM A,PCLL
PCLT6:	CONO PI,CLKOFF
	MOVE B,PCLDBM
	MOVEI A,BCNTRZI
	CAIN B,1	;DON'T ^Z.
	IORM A,PIRQC(U)
	POP P,C
	POP P,B
	POP P,A
	POP P,U
	JRST PCLME

	PUSHJ P,PCLME1
PCLME:	PUSHJ P,UFLS
	JRST 4,.

PCLME1:	PUSHJ P,PCLSR
	JFCL
	JRST POPJ1

PCLT1A:	TRNE U,-1
	JRST 4,.
	JRST 4,.	;TEMP MODIFY END CHECK IF WANT TO WIN FOR SYS JOB


;ILLUO NON-RELEVANT SYSTEM CALLS
IFE 340P,[
	ADSTAR==URET
	ADSTL==URET
	ALTPEN==URET
	ADCLOS==URET
	ADSTOP==URET
	ANDIS==URET
]
IFE VIDP,[
	AVSCAN==ILUUO
	AVSTST==ILUUO
]
IFE IMXP,[
	APOTSET==ILUUO
]
IFE PDP6P,[
	AIPDP==ILUUO
]
IFE NMTCS,[
	AMSPAC==ILUUO
]

IFE ARMP,[
	AARMOV==ILUUO
	AARMRS==ILUUO
	AARMOF==ILUUO
]

IFE RBTCP,[
	ARBTC==ILUUO
]
IFE NETP,[
	ANETAC==ILUUO
	ANETRE==ILUUO
	ANETS==ILUUO
]
HSYSCD:		;HIGHEST SYSTEM CODE

EBLK
;RANDOM STORAGE

;TRANSLATION ENTRY _ T
;TRANLK(T) IS  MODE,,NEXT ENTRY
;IF ENTRY IN USE,
;JUST NEXT-ENTRY IF IN FREE LIST
;NEXT-ENTRY IS -1 FOR NIL, ELSE IDX REL TRAN!X
;TRANID(T) THRU TRANIS(T) - FROM-NAMES
;TRANOD(T) THRU TRANOS(T) - TO-NAMES

TRANLK:	REPEAT SIOMT,,,.RPCNT-1	;GENERATE 1ST WDS, LINKED TOGETHER.
IRPS X,,ID I1 I2 IS OD O1 O2 OS
TRAN!X:	BLOCK SIOMT
TERMIN		;GENERATE REMAINING WDS.

TRANFL:	SIOMT-1		;TRANSL ENTRY FREE LIST.
TRNCNT:	0		;NUM ENTRIES IN USE.
TRNREF:	0		;NUM. READ-ONLY ACCESSES TO TRANSL LISTS.
TRANSW:	-1		;SWITCH FOR WRITE REF.
	0

U0P:	0	;PRIORITY OF BEST USER SO FAR
U0PP:	0	;JTMU OF ABOVE

USER:	-1	;USER # OF CURRENT LOSER
SYSL:	SYSB*2000
LITM:	0	;LAST TIME SYS INCREASED CORE
STTY:	21,,(SIXBIT /T00/)	;OPEN IN "DISPLAY MODE"

SYSPN3:	0	;SEE SYSLGP
SYSPNT:	0	;TTY TO TYPE FREE MESSAGE ON
SYSPN4:	0

SLGIV:	BLOCK 3	;LOGIN

SETSLC:	0	;SETLOC VARIABLES
SETSLQ:	0
SETSU:	-1

SWUNAM:	0	;SYS WRITE VARIABLES
SWJNAM:	0
SWFN1:	0
SWFN2:	0
SWMOD:	0

SYIOTL:	0	;USER TRYING TO BE IOTLSR
DMON:	SIXBIT /DRAGON/
DMONX:	-1	;USER INDEX OF DEMON JOB

QGCUSR:	0	;SIXBIT OF LAST PERSONS DIRECTORY TO BE GCED

DMLLDF:	-1	;UNLESS -1, DEMON LOADED

TIMOFF:	-1	;TIME SINCE MIDNIGHT IN HALF SECONDS
QDATE:	-1	;DISK FORMAT DATE (RH 0, LH BOTTOM 10. BITS OF DATE)
JDATE:	-1	;NUMBER OF DAYS ELAPSED SINCE MARCH 1,0000
		;NOTE: "JULIAN DAY NUMBER" = C(JDATE)+1721120.
PDYTIM:	-1	;TIME SINCE BEGINNING OF YEAR IN HALF-SECONDS (BACKUP TO PDCLK)
FYEAR:	0	;YEAR (E.G. 1969.)
PDTIME:	0	;NON-ZERO => OFFSET FOR PDCLK
		;WHEN SUBTRACTED FROM PDCLK DATAI GIVES # PD-UNITS SINCE BEGINNING OF YEAR
		;ONE SECOND = 60. PD-UNITS

SUPCOR:	20000,,1	;CONTROLS SYS JOB, SEE SYSDTB, SCOR, ETC

USRGUN:	0	;OR U OF USER TO KILL
TTGUND:	0	;TTY OF GUNNED
TMGUND:	0	;TIME USED OF GUNNED
UNGUNR:	0	;UNAME OF GUNNER
JNGUNR:	0	;JNAME OF GUNNER
LNETIM:	0	;TIME AT WHICH NETWORK WAS LAST BROUGHT UP
MXPARS==40
PARPG:	BLOCK 8	;STORAGE OF PAGE MAP WHILE HACKING PARITY ERROR CHECK
PARCNT:	0	;# OF PAR ERROR ENTRIES IN TABLE
PARCON:	BLOCK MXPARS	;CONTENTS OF BAD PARITY LOCATIONS
PARADR:	BLOCK MXPARS	;ADDRESSES OF BAD PARITY LOCATIONS
PARDIE:	0	;-1 => FATAL PARITY ERROR
TPLSWP:	0	;-1 => USE OLP FOR TPL
DLSRCH:	0	;DLETE SEARCH IF -1 (UNLESS TAKE PG FAULT)
CPDLP:	-CPDLL,,LCPDL-1	;CLOCK PDL POINTER
LCPDL:	BLOCK CPDLL	;CLOCK INT LEVEL PDL
CLROOT:	SSLCKB	;CLOCK QUEUE ROOT
SSLCKB:	SCLKI	;SLOW CLOCK RQ BLOCK
	15SCLB
	JRST SSLCK
15SCLB:	15.*60.-SCLKI
	VSLCKB
	JRST 15SCLK
VSLCKB:	VSCLKI-15.*60.-SCLKI	;VERY SLOW CLOCK BLOCK
	CLINFB
	JRST VSSLCK
CLINFB:	377777,,-1	;ABOUT 15 YEARS
	0
	JRST 4,.	;?
IFN CCLKP,[
CCLKB:	0	;FOR CHESS CLOCK HACK
	-1
	JRST RCCLK
CCLK1:	0
CCLK2:	0
]

GODDT:	0
UTTYS:	BLOCK MXCZS	;RING BUFFER FOR JOBS TO BE STARTED
UTTYI:	UTTYS
UTTYO:	UTTYS
UTTYCT:	0

CASW:	-1	;ALLOCATE INTERLOCK SWITCH
	0
PCLDBM:	0	;.NE. 0 ACTIVATE PC LSR DEBUG MODE
			;1 => ADVANCE PLACE WHERE PCLSR
			;2 => ADVANCE BUT DON'T ^Z.
			;- HOLD
PCLUSR:	-1	;USER PCLSR MODE ACTIVE FOR
PCLL:	0	;PLACE WHERE LAST PCLSR TESTED
PCLHSH:	0	;HASH OF RETURNS ON PDL AT LAST PLACE TRAPPED OUT OF
PCLNXT:	-1	;-1 => FROB NEXT TIME IN ADVANCE MODE
PCLHT:	0	;TEMP
PCLIDX:	0	;INITIALIZE PCLT TO THIS (SET TO LOOP COUNT IF NECESSARY)
CORRNR:	0	;LAST USER TO RUN CORE
SJSPG:	0	;PG RESERVED FOR SYS JOB
UTRMF:	0	;-1 MOVING SO BUF BLOCK 0 FLUSHING CORE
UTBFLF:	0	;-1 SIGNAL TO TRY TO FLUSH I/O BLOCKS
UFDFLF:	0	;-1 SIGNAL TO TRY TO FLUSH 2311 UFDS
CORCNT:	0
UFLSF:	0	;FLAG FROM UFLS TO CLKBRK
CLKFL1:	0	;FLAG COUNTER TO CONTROL CLOCK LEVEL 
SCHFLG:	0	;SCHEDULE TIMER (DIVIDES 60 CPS)
27FCLK:	0	;-1 IF FAST CLOCK SHOULD CALL TYP27S
SCITM:	0	;SEE SYSEX, SYSDEC
LQTIM:	0
LCLK1:	0
SYSCKP:	-LTSTB,,TSTB	;SYSTEM CHECKSUMS CHECKER POINTER
SYSPDP:	-LSYSP,,SYSPDL-1	;PDL POINTER FOR SYSTEM JOB
SYSPDL:	BLOCK LSYSP	;PDL FOR SYS JOB
IFN TPLP,[
TPLBUF:	BLOCK TPLBSZ	;PSEUDO LPT BUFFER - MUST BE ABOVE SUACS
TPLFNO:	SIXBIT /!/	;UNIQUE TPL FIRST FILE NAME
]
SJCFF:	0	;-1 WHEN SYS JOB IN PROCESS OF FLUSHING CORE
			;AVOIDS TIMING ERROR DUE TO HUSRAD NOT REALLY REFLECTING WHAT ITS GOING TO BE
SJDH:	-1	;INTERLOCK BETWEEN CORE JOB AND SYS JOB RE DISK HACKING
	0
SHUTLK:	-1	;LOCK VAR FOR SHUTDN
	0	;USED TO TELL WHO CAUSED SYS DOWN

TUSRM:	0	;TOTAL USER MEM IN 1K BLOCKS
SWUDI:	0	;-1 IF SWAP USER DIR IN AND ITS QSNNR AOSED EXTRA TIME
SYSDBG:	0	;NONZERO CAUSES "ITS ### BEING DEBUGGED" TO REPLACE IN OPERATION MSG
		;NEG CAUSES CNTRL Z TO BE ACCEPTED FROM TTY0 ONLY AND SYS DOWN
LUFNAL:	0	;LAST NON ZERO UFINAL HACKED
LUFNLU:	0	;USER LAST UFINALED
UMBTS:	0	;-1 USE META BITS, 0 DON'T
SLSWPR:	0	;STORE SYS JOB'S LSWPR WHILE HACKING UUOS

	;TTYTYP TABLE
	;BIT 4.9 ONE => LOCAL TTY
	;BIT 4.8 ONE => CONSOLE NEXT TO 340 OR A 340 SLAVE
	;BIT 4.7 HIGH PRIORITY ON 340
	;BIT 4.6 15 CPS LINE
	;BIT 4.5 30 CPS LINE
	;BIT 4.4 DON'T PRINT SYSTEM JOB MESSAGES ON THIS TTY
	;BIT 4.3 60 CPS MEMOREX TERMINAL
	;BIT 4.2 DONT DING ON EXCESS INPUT
	;BIT 4.1 DATEL LINE
	;3.9-3.7 CONSOLE TYPE (INITIAL ONLY)
	;3.6-3.4 INPUT SPEED CODE (DATAPOINT PORTS, SEE BELOW)
	;3.3-3.1 OUTPUT SPEED CODE (DATAPOINT CONTROLLER PORTS)
	;BIT 2.9 DATAPOINT KLUDGE TERMINAL
	;BIT 2.8 PSEUDO TTY
	;BIT 2.7 NOVA TTY
	;BIT 2.6 MORTON BOX
	;BIT 2.5 DIAL UP
	;BIT 2.4 DON'T PAD ON OUTPUT
	;BIT 2.3 ALLOW SUPER IMAGE INPUT MODE
	;BIT 2.2 10CPS MODEL 35

	;SPEEDS 2741:0, 600:1, 110:2, 150:3, 300:4, 1200:5, 2400:6, 4800:7

TTYTYP:	600000,,2000	;T00 MAIN CONSOLE
IFN AI,[
	400000,,20000	;T01 8-7874
	022000		;T02 258-8794 10CPS
	600000,,2000	;T03 ROBOT CONSOLE
	700000,,2000	;T04 PDP6 CONSOLE
	400000,,2000	;T05 SYSTEM JOB CONSOLE
	040000,,20000	;T06 258-8795 15CPS
	600000,,2000	;T07 MINI-ROBOT CONSOLE
	070000,,	;T10 WTBS BAUDOT LINE (FAKE OUT 175, 176 MUNGER)
	003000,,	;T11 DATEL OUTLETS IN WINOGRAD'S OFFICE AND SUPPLY RM
	003000,,	;T12 DATEL BY PLOTTER
	013000,,20000	;T13 DIAL UP 2741 LINE 8-7825
	020000,,	;T14 MINSKY'S SECTRY'S TI LINE
	020000,,	;T15 PRIVATE LINE MODEMS - 1ST FLR
	020000,,	;T16 PRIVATE LINE MODEMS - 1ST FLR
	020000,,	;T17 PRIVATE LINE MODEMS - 1ST FLR
	020000,,	;T20 PRIVATE LINE MODEMS - 1ST FLR
;PUT IN NOVA TTYS HERE (IF ANY)
	002077,,416000	;T21 PDP 11 (DONT PAD)
	404011,,400000	;T22 MEMOREX TERMINAL
	400166,,400000	;T23 NEW 2400 DATAPOINT BY CLOCK
	400166,,400000	;T24 NEW 2400 DATAPOINT BY PLOTTER
	400166,,400000	;T25 NEW 2400 DATAPOINT IN COLOR SCOPE RM
	000166,,400000	;T26 NEW 2400 DATAPOINT ON 8TH FLOOR
	404011,,400000	;T27 MEMOREX TERMINAL
	000166,,400000	;T30 NEW 2400 DATAPOINT ON 8TH FLOOR
	400166,,400000	;T31 NEW 2400 DATAPOINT BY PDP11
	020044,,420000	;T32 258-8791 30CPS
	020044,,420000	;T33 258-8792 30CPS
	020044,,420000	;T34 258-8793 30CPS
	000166,,400000	;T35 NEW 2400 DATAPOINT ON 8TH FLR
	000166,,400000	;T36 NEW 2400 DATAPOINT ON 8TH FLOOR
	000166,,400000	;T37 NEW 2400 DATAPOINT ON 8TH FLR
	000035,,400000	;T40 HIGH SPEED NOVA LINE
]
IFE AI,[
	000022,,42000	;T01 DATAPHONE 10CPS
	020044,,40000	;T02 DATAPHONE 30CPS
	020044,,40000	;T03 DATAPHONE 30CPS
	400000,,042000	;T04 SYSTEM JOB CONSOLE
	004011,,40000	;T05 MEMOREX IN MATH DEPT
	404011,,40000	;T06 MEMOREX 9TH FLR
	004011,,40000	;T07 MEMOREX ON 8TH FLR
	004011,,40000	;T10 MEMOREX ON 8TH FLR
	400211,,40000	;T11 OLD 600 DATAPOINT IN 420-A
	400266,,40000	;T12 OLD 2400 DATAPOINT ON 9TH FLR
	400266,,40000	;T13 OLD 2400 DATAPOINT ON 9TH FLR
	000166,,40000	;T14 NEW 2400 DATAPOINT ON 8TH FLR
	000166,,40000	;T15 NEW 2400 DATAPOINT ON 8TH FLR
	000166,,40000	;T16 NEW 2400 DATAPOINT ON 8TH FLR
	400357,,40000	;T17 IMLAC
	400357,,40000	;T20 IMLAC
	000166,,40000	;T21 NEW 2400 DATAPOINT ON 8TH FLR

]

REPEAT NSTTYS,	10000,,200000	;PSEUDO TTYS (NO SYS JOB MESSAGES SINCE CAN HANG ON TYO)
;ADD NTY TTYS HERE
	0		;DISOWNED JOBS CONSIDERED TO HAVE REMOTE TTYS
	400000,,	;SYSTEM JOB CONSIDERED LOCAL USER

;REMOTE TTY JOBS CANNOT GOBBLE LPT, BUT IF THEY HAVE IT WHEN THEY
;BECOME REMOTE, THEY CAN KEEP IT

IFN .-TTYTYP-NCT-2,[PRINTC /LOSSAGE AT TTYTYP TABLE.
/]
BBLK
CONSTANTS
IFN TPLP,	TPLFN:	2,,(SIXBIT /TPL/)
EBLK
IFN TPLP,[
TPLFN1:	0
TPLFN2:	0
TPLFN3:	0
]
VARIABLES


TSTB:	REPEAT CKNUM,CONC CK,\.RPCNT,
LTSTB==.-TSTB

CKSUMS:	BLOCK CKNUM
CKXORS:	BLOCK 36.	;XOR OF ALL ADRS IN PURE AREAS IN SYS WITH CORRESP
		;BIT SET (RH)
TCKXOR:	BLOCK 36.	;TEST XORS

SSYSCL==SSYS
SYSCLB==SSYSCL_-10.+IFN 1777&SSYSCL,1

ZZ==.
PVARP:	USRSTG-PVARP	;A CONSTANT TO TELL PEEK WHAT IS GOING ON
PAUSUS: NDUSUS-PVARP	; "
USRHI:	0	;HIGHEST LOC USED FOR USER STORAGE
	L	;LENGTH OF USER BLOCK (HERE FOR PEEK)
CUSER:	-1	;CORE ALLOCATOR USER
	0	;DUMMY CORE ALOC USE VAR
IFN 340P,[
DISUSR:	-1	;340 USER
	0	;DUMMY 340 USE VAR
]
IFN CODP,[
CODUSR:	-1	;CODE SENDER
CODUSE:	-1
]
IFN PLTP,[
PLTUSR:	-1	;PLOTTER USER
PLTUSE:	-1
]
IFN LPTP,[
LPTUSR:	-1	;LINE PRINTER USER
LPTUSE:	-1
]
IFG LPTP-1,[
OLPUSR:	-1
OLPUSE:	-1
]
IFN LPTP,[
  IFE LPTP-1,[
    IFN NLPTP,[
	NLUSR==LPTUSR
	NLUSE==LPTUSE
    ]
    IFN OLPTP,[
	OLUSR==LPTUSR
	OLUSE==LPTUSE
    ]
  ]
  IFG LPTP-1,[
    OLUSR==OLPUSR
    OLUSE==OLPUSE
    NLUSR==LPTUSR
    NLUSE==LPTUSE
  ]
]
PTPUSR:	-1
PTPUSE:	-1
PTRUSR:	-1
PTRUSE:	-1
IFN VIDP,[
NVDUSR:	-1
NVDUSE:	-1
]
IFN PDP6P,[
PDPUSR:	-1	;PDP-6 USER
PDPUSE:	-1
PDPISR:	-1	;PDP6 AS INFER (INTS ON IO CHANNEL)
PDPISE:	-1	;PDP6 USE VAR
]
IFN TABP,[
TABUSR:	-1	;TABLET USER
TABUSE:	-1
]
IFN STKP,[
	STKUSR:	-1
	STKUSE:	-1
]

NDUSUS:	;END OF USR,USE PAIRS, INSERT NEW PAIRS ^

MEMFR:	SYSUSM-1	;MEMORY FREE
TIME:	0	;TIME SINCE SYSTEM START IN 1/30'THS
SUSRS:	0	;NUMBER USERS ON SYS
USRRCE:	BLOCK NCT+1	;USER RESOURCE +1 FOR DISOWNED JOBS
SYSRCE:	0	;SYS JOB RESOURCE
RNABLU:	0	;RUNNABLE USERS
NCTIM:	BLOCK NCT+2	;TOTAL TIME USED BY KILLED JOBS (+ DUMMY AT END FOR SYS JOB)
LOUTIM:	0	;TOTAL TIME USED BY LOGGED OUT USERS
NSIPRQ:	BLOCK NCT+2	;# SWAP IN PG RQ BY KILLED JOBS
UMASTER:	-1	;INDEX OF MASTER USER

SWRCE:	BLOCK NCT+2	;SWAP SCHED RESOURCE
TSIPRQ:	0	;TOTAL # SWAP IN REQUESTS
SHUTDN:	0	;"TIME" SYS WILL DIE, 0 IF NOT DYING, -1 IF DEAD
DEDTIM:	0	;TIME TILL DEATH AFTER NEXT CLK QUEUE INT
		; < 0 => SYSTEM ACTUALLY DOWN
		;(CHECKED BY ^Z AND DRAGON)
DEDBLK:	0
	-1
	JRST DEATHZ

NCORRQ:	0	;NUMBER CORE RQS HERE SO TRANSFERRED TO PEEK
NCBCOM:	0	;NUMBER CORE BLOCKS COMMITTED

NQDE:	BLOCK NQS	;NUMBER OF 2314 DATA ERRORS
NQHE:	BLOCK NQS	;NUMBER OF 2314 HARDWARE ERRORS
NQSE:	BLOCK NQS	;NUMBER OF SPURIOUS 2314 ERROR INTERRUPTS
NQCMPE:	BLOCK NQS	;NUMBER OF 2314 READ/COMPARE ERRORS
NQWDE:	BLOCK NQS	;# DATA ERRS ON WRITE
NQRDE:	BLOCK NQS	;# DATA ERRS  ON READS
NIRSWE:	0	;# IRRCV ERRS ON  SWAPPING XFERS
QIRCBK:	0	;BLOCK # W/ IRRCV ERROR
QIRUNT:	0	;UNIT OF ABOVE
NQWRE:	0	;# WRITE ERRS RCC OK
NQWIRE:	0	;# WRITE ERRS RCC LOST
NWXFR:	0	;NUMBER WRITE TRANSFERS (FILE, DIR, ETC.)
NRXFR:	0	;NUMBER READ
NSWXFR:	0	;NUMBER WRITE SWAPS
NSRXFR:	0	;NUMBER READ SWAPS

PARERR:	0	;COUNT OF CORE PARITY ERRORS
NXMERR:	0	;NXM
PARPC:	0	;PC ON CORE PARITY INTERRUPT
NXMPC:	0	;NXM
PARUSR:	-1	;USER ON PAR ERR
NXMUSR:	-1	;USR ON NXM

NULTIM:	0	;TIME USED BY NULL JOB (60'THS)

UREALT:	-1	;RH=INDEX OF THE REAL TIME USER
		;LH=0=> THIS USER HAS HIGHEST PRIORITY
		;LH>0=> USER NOT IN HIGH PRIORITY PHASE
		;LH<0=> FACILITY IDLE
QIRRCV:	0	;IRRECOVERABLE DISK ERRORS
SJBRES:	0	;-1 => BLOCK IN LOWER HALF RESERVED FOR SYS JOB
IFN DPKPP,	NDPKPE:	0	;# PARITY ERRS FROM DATAPOINT KLUDGE
;INSERT NEW RANDOM VARS ACCESSABLE TO PEEK HERE ^

LVARS==.-ZZ

INFORM [HIGHEST USED]\<.-1>

;USER VARIABLES
;ONE COPY FOR EACH PROCEDURE

USRSTG==.	
IOCHNM:	REPEAT 20,0	;IO CHANNEL ASSIGNMENT
			;RH INDEX INTO IOTTB AND CLSTB
			;LH DEV CHNL AND/OR OTHER
SIOCHN:	BLOCK LUIOP	;MUST FOLLOW IOCHNM
			;I/O CHANNEL PDL
SIOCP:	SIOCHN-1	;POINTER INTO I/O CHANNEL PDL
IOCHST:	BLOCK 20	;I/O CHANNEL STATUS FOR CH'S AT IOCHNM
			;3.1-4.9 IO STATUS
			;1.1-2.9 .ACCESS POINTER

UPC:	0	;USER PC STORAGE
CORRQ:	-1	;RQ TO CORE JOB
		;4.9=1=>NO REQUEST
		;4.8=0 OLD TYPE RQ,1.1-1.9 # BLKS,3.1-3.8=USR NUMBER RQ'ED FOR
		;4.8=1 NEW TYPE
		;4.3 ADD FRESH BLOCK (IGNORE 4.2,4.1)
		;4.1=1=> ADDING ABSOLUTE BLOCK
		;3.9=1=>REQUEST WRITE ABILITY
		;2.9=1 INSERT, =0 DELETE ONLY IGNORE 4.1-4.3
		;2.1-2.8 VIRTUAL PAGE AFFECTED
		;1.1-1.9 USER RQ IS FOR

UUOACS:	BLOCK 20
AC0S:	BLOCK 15	;SWAP OUT AC S
AC15S:	0
AC16S:	0
AC17S:	0

UUO:	;THE FOLLOWING FOUR LOCATIONS ARE SWAPPED IN & OUT OF UEXIT,CLUSAV,UUOH,&AC17P WITH THE USER
SUEXIT:	JRST 2,@UUOH	;USER UUO EXIT INS
SCLUSV:	MOVEM U,AC17S	;CLOCK U SAVE
SUUOH:	0	;C(@41) (ABSOLUTE)

SV40:	0	;C(40) WHEN USER OUT (SEE SWITCH)
SV60:	0	;CONTENTS OF 60 WHEN USER OUT

JBI:	-1	;JOB DEVICE INDEX
APRC:	APRCHN	;R.H. CONO TO APR WHEN USER STARTS (HAS AR OV ENABLE, ETC.)
		;4.9=1=> PROCEDURE IS IN A DISOWNED TREE
BUSRCL==200000	;4.8 USER BEING CLOSED
BUSRK==100000	;4.7 USER HAS BEEN CORED 0
BUSRCR==40000	;4.6 CORE RQ PENDING
BULGO==20000	;USER HAS COMPLETED UBLAM AT LOGOUT AND SHOULDNT BE PCLSRED
BCHPTR==330400,,APRC(U)	;4.1-4.4 LAST CH ON WHICH AN ERR OCCURED (SEE ERR DEV)
BULGOS==400	;LOGOUT STARTED
;3.1-3.5 MUST BE ZERO

USTP:	0	;0 RUNNABLE, (IS SET NON ZERO FOR IDLE SETS OF VARS TO SPEED SEARCH)
BCSTOP==400000	;BIT IN USTP FOR CORE MOVAGE
BUCSTP==200000	;CORE STOPPING LOSER TO GIVE MORE CORE RQSTED BY ANOTHER LOSER
BUSRC==100000	;USER CONTROL BIT, SET & CLEARED BY SUPERIOR PROCEDURE
BSSTP==40000	;SET BY SUPERIOR WHEN HACKING MEM BOUND AT URMEMT OR UMEMEX
;1.1-2.9	;USED BY UBO AND FRIENDS INHIBITS RELOCATION BY CORE ALLOCATOR
		;MUST BE MODIFIED WITH CLKOFF  MUST NOT BE SET IF CSTOP IS SET
		;IS A COUNTER OF TRANSIENT REASONS FOR PROCEDURE BEING STOPPED

PIRQC:	0	;INT REQ AWAITING SERVICE (SOFTWARE INTS EFFECTED BY SEARCH)
MSKST:	0	;INT MASK REGISTER FOR BITS IN PIRQC
IFPIR:	0	;SECOND WORD OF INTERRUPT REQUESTS
		;3.8-3.1 INF PROC INT
		;2.7-1.1 IO CHANNEL INT
		;1.1= CHANNEL 0
MSKST2:	0	;INT MASK FOR IFPIR
PICLR:	0	;INT IN PROGRESS FLAG, -1=>ENABLED, 0=>IN PROGRESS

SUPPRO:	0	;-1 => TOP LEVEL PROCEDURE
		;OTHERWISE: INT BIT,,PNTR TO SUPERIOR PROCEDURE

FLSINS:	0	;USER BLOCKING INSTRUCTION;  STATE:
		; 0 => RUNABLE (UNLESS USTP .NE. 0) 
		; OTHERWISE HUNG,  IF NO SKIP SAFE TO RESTART AT UUO (UNLESS UFINAL .NE. 0)
RPCL:	0	;0,,N  RPCLSR'ING N
		;-1,,N  BEING RPCLSR'ED BY N

UNAME:	0	;USER NAME
		;THIS WORD FOR EACH PROCEDURE IS COPIED FROM THE UNAME OF THE PROCEDURE
		;THAT CREATES IT (SEE USR DEV).  FOR AN INITIAL TOP LEVEL PROCEDURE IT
		;IS INITIALLY -1 BUT IS MODIFIED BY ALOGIN.  IT IS THE SAME FOR ALL
		;PROCEDURES IN A TREE.
JNAME:	0	;JOB NAME
		;EACH LOGGED IN PROCEDURE HAS A UNIQUE UNAME, JNAME PAIR.  THE JNAME
		;OF AN INITIAL TOP LEVEL JOB IS "HACTRN".  FOR OTHER JOBS IT IS THE SECOND
		;FILE NAME SPECIFIED IN THE .OPEN ON THE USR DEVICE THAT CREATES THEM.
USYSNM:	0	;USER SYSTEM NAME
		;THIS VARIABLE IS INITIALLY SET TO THE SAME VALUE AS UNAME FOR
		;A PROCEDURE.  IT CAN BE READ OR WRITTEN BY THE PROCEDURE (ASUSET)
		;OR BY ITS SUPERIOR (AUSET).  ITS ONLY USE IS AS THE DEFAULT THIRD FILE NAME ON
		;USER SHARED DEVICES (2311'S (SEE QSKO),  AND CORE
		;LINK (SEE CLOO)).
USYSN1:	0	;3RD NAME FOR QSKO, CLOO (AFTER DEFAULTING AND TRANSLATION)

TTYTBL:	0	;TTY ASSIGNED THIS USER OR INDICATION THAT THERE IS NONE
			;4.9 DOES NOT HAVE TTY NOW
			;4.8 NEVER HAD IT
			;4.7 TAKEN AWAY
			;4.6 THIS GUY IS UNDER GUN - CNTRL Z
			;4.5 CHNL VALID
			;4.4 TTY TAKEN FROM --ME--
			;3-6-3.1 # ECHO LINES IF I DONT HAVE DISPLAY
			;RH USER NUM GAVE TTY AWAY TO OR TTY NUM IF HAS IT

TTSTSV:	BLOCK 3	;JOB'S SAVED TTYST1,TTYST2,TTYSTS
UTIME:	0	;RH=CLOCK INTERVAL IN 60'THS, LH=COUNT OF TICKS SINCE READ
UTRNTM:	0	;TOTAL RUN TIME IN 4.069 MICROSEC UNITS
USIPRQ:	0	;# SWAPIN REQUESTS
UTMPTR:	0	;POINTER TO RESOURCE WORD FOR THIS LOSER
JTMU:	0	;REDUCED BY 1/16 EVERY 1/2 SEC
			;INCREMENTED BY TIME RUN IN 4 USEC
			;MAX EQV VAL 1000000/8-1/16X=0
			;EQV VAL=2X10^6
			;AMONG JOBS WITH EQUAL RESOURSE
			;LOWEST JTMU HAS HIGHEST PRIORITY

IOTLSR:	0	;4.9 IOT USER MOD (=1 ENABLES USER TO DO DIRECT I/O INSTRUCTIONS)
		;RH VIRTUAL PAGE # OF LAST MPV OR WIRO (SHIFTED TO ADDRESS SIZE)
UMARPC:	0	;PC AT MAR INTERRUPT
VALUE:	0	;PROCEDURE "VALUE" RETURN
LSWPR:	0	;LOCKED SWITCH POINTER
UCLBLK:	0	;CLOCK QUEUE BLOCK
	-1
	JRST UREALB
URTIME:	0	;LH=0=>LOW PRIORITY PHASE 1=> LOW PRIORITY WITH BLOCKING
		;LH=-1=>HIGH PRIORITY PHASE 2=> HIGH PRIORITY WITH BLOCKING
		;RH=LENGTH OF HIGH PRIOITY IN 60'THS
RTIMER:	-1	;+=> MICROSEC RUNTIME TILL RUNTIME INT
UPGML:	0	;FA,JPC
	0	;PCF,OPC
	0,,0	;MAR (3.3=1 EXEC ADR 3.2,3.1 0 NEVER 1 PC FETCH 2 WRITE 3 ALWAYS
	EXPGNG+1,,0	;F.S. QUAN
	100_1,,UPGMP	;DBR1
	100_1,,UPGMP+100	;DBR2
	100_1,,EXEUMP	;DBR3
	1040,,UUOACS	;BK,CK,ACP


LSPCL:	0	;UPC AT LAST PCLSR
LPFBTS:	0	;FAULT BITS AT LAST PG FAULT DEBUGGING USE ONLY
LEXFDR:	0	;EXEC ADR THAT CAUSED PG FAULT THIS PC
		;FLUSHED AT CLK LVL AND CNTRL SENT TO IOADCR
		;USED FOR DEBUGGING ONLY
UTRAPM:	0	;4.9=> 1 UUO TRAP MODE
LSUUO:	0	;LAST SYS UUO (FOR DEBUGGING PURPOSE)
LSCALL:	0	;SIXBIT NAME OF LAST .CALL 0, (FOR PEEK)
CTLBTS:	0	;CTL BITS TO .CALL 0, XORED TOGETHER IN HERE
UMAPS:	0	;USER MAP STATUS (M.P.)
		;0 NORMAL MAP AS IN UPR
		;4.8=1 HACK MY LOWER DBR
		;4.7=1 HACK MY UPPER DBR
		;4.6=1 TO POINT TO HIS LOWER SEG
		;4.5=1 TO POINT TO HIS UPPER SEG
		;4.4=1 MAKE MY HIGH DBR POINT TO HIS HIGH DBR AS WELL
		;4.3=1 MAKE AC'S POINT TO SWAP OUT AC'S INSTEAD OF UUO AC'S
		;RH USER OR -1 = PDP6
UDBR1:	0	;NORMAL CONTENTS OF DBR1
UDBR2:	0	;NORMAL CONTENTS OF DBR2
UCPB1:	0	;CIRC PNTR BASE DBR1
UCPB2:	0	;CIRC PNTR BASE DBR2
UPGMP:	REPEAT 200,600000+.RPCNT*2,,600000+<.RPCNT*2+1>
;	BLOCK NUVPG/2	;PAGE MAP STORAGE (PRGMS UP TO NUVPG LONG)
UPGCP:	BLOCK NUVPG/2	;CIRC PNTR
S60H:	0	;SAVED 60H
NMPGS:	0	;NUMBER OF NON-ABSOLUTE PAGES (INCLUDES PURE)
HUSRAD:	0	;MEM ADR OF PAGE ABOVE HIGHEST THAT EXISTS (MAX 1,,0)
USWST:	0	;4.9=0 => DESIRED TO BE IN
		;   =1 => DESIRED TO BE OUT
		;4.8=1 => FLSINS IS WAITING FOR A PAGE
		;4.7=1 => USER COMPLETELY OUT OR HAVE TRIED TO FLUSH REMAINING PAGES RECENTLY
		;(I.E. DON'T TRY LOOKING AT THIS USER FOR FURTHER PAGES TO SWAP OUT)
		;4.6=1 => UNBLOCKED SWAPOUT SO CONSIDER MEM STATUS BEFORE REACTIVATION
		;4.5=1 => PAGE SWAPPED OUT WHILE BLOCKED IN EXEC MODE
		;SO WHEN FLSINS SKIPS DON'T CLEAR IT BUT PCLSR INSTEAD
		;4.4=1 => IF WAITING FOR PAGE,NEED IT TO INTERRUPT
LUBTM:	0	;TIME LAST UNBLOCKED (FOR IDENTIFYING INACTIVE JOBS)
NSWPGS:	0	;NUMBER SWAPPED OUT PAGES(AOSED FOR EACH USER OF SHARED PAGE SWAPPED OUT)
USTYN:	0	;TTY NO OF PSEUDO TTY FOR THIS USER
UUAC:	0	;AC FLD OF LAST UUO OR DESIRED CHANNEL IN CASE OF NOPEN ETC
		;SELECTS CHNL FOR ALL IOTS, OPENS ETC
TRMNAM:	0	;TERMINAL IDENTIFICATION
USWSCD:	0	;SWAP SCHEDULING WORD 4.9=1 SWAPIN INHIBITED THIS JOB
USWPRI:	0	;JOB SWAP PRIORITY
TRNLST:	0	;TRANSL LIST FOR THIS JOB. -1 => NIL, OR IDX INTO TRAN!X
TRNLS1:	0	;TRANSL LIST FOR THIS JOB & INFERS.
IDF1:	0	;DEFER BITS FOR 1ST WD INTERRUPTS.
IDF2:	0	;FOR 2ND WORD INTERRUPTS.
		;IF AN INTERRUPT IS DEFERRED, IT IS TREATED AS
		;IF THE JOB'S PICLR VAR HELD 0.
OPTION:	0	;OPTIONS WORD, SETTABLE BY USER
			;EACH BIT CONTROLS SOME SYSTEM ACTION FOR THIS JOB
	OPTDET==200000		;BIT 4.8- DETACH ON FATAL INT (ONLY IF TOP LEVEL)
	OPTDEC==100000	;BIT 4.7 UUOS 40,41 AND 47 ARE USER UUOS
40ADDR:	40	;ADDRESS OF USER'S 3WD BLOCK FOR UUO'S INTS
;INSERT NEW USER VARIABLES HERE^

USRPDL:	-LUPDL,,UPDL-1	;USER PDL
UPDL:	BLOCK LUPDL-1
EPDL2:	0	;SAVES C(T) FOR FLSINS
QLD:	0	;LINK DEPTH
SRN3:	0	;SAVED N3, N4 FOR RENAMES AT AOPEN ALSO USER INDEX AT NLOAD
		;SRN3, SRN4 USED BY CORBLK .CALL
SRN4:	0	;ALSO DEVICE CHNL IOCHNM POINTER AT NLOAD
SRN5:	0	;SAVED N5 FOR LINK ALSO VIRTUAL PAGE NUMBER AT NLOAD
EPDL3:	0	;USED BY 2311 ROUTINES (QFNG) ALSO QSMDN ADDR AT NLOAD ALSO BY TYOW2
EPDL:	0	;USED BY 2311 ROUTINES
EPDLT1:	0	;FN1 BEFORE LAST TRANSLATION
EPDLT2:	0	;FN2
EPDLT3:	0	;SYS NAME
EPDLT4:	0	;LEFT ADJ DEVICE NAME

REPEAT NULBLK,[
CONC LSWB,\.RPCNT,:	BLOCK 2
]		;SWITCH BLOCK FORMAT
		;WD1 ASSOCIATED ADDRESS OR QUANTITY
		;3.6-3.1 USER NUMBER OF SWITCH HOLDER
		;2.9-1.1 PNTR TO NEXT SWITCH ON LIST OR 0 IF NONE
		;FOR REMAINDER OF FORMAT SEE LSWDIS

LUBLK==.-USRSTG
L==LUBLK
INFORM [STORAGE PER LOSER]\LUBLK
	BLOCK LUBLK	;USER VARIABLES FOR CORE JOB
SYSB==1+._-10.
MXC==SYSUSB-SYSB	;AVAIL BLOCKS AFTER SYS+DDT

LMB=100000,,	;LOAD META BITS
SMB=101000,,	;STORE META BITS

;TSS INITIALIZATION
;(THE FOLLOWING CODE IS WIPED OUT AT ICLR)

GO:
BEG:	JFCL 17,.+1
	JRST .+1
	JFCL 1,[JRST 4,.]	;SYSTEM WONT RUN ON 6
	LPMR UPGML
	CONO 633550
	MOVE P,SYSPDP
	MOVEI A,TSYSM-1	;CHECK AVAIL MEM FOR EXISTANCE
CKML:	MOVEI TT,600000(A)
	DPB TT,[.PAREP+EXEUMP]
	LPMR UPGML
	SKIPL USEHM
	CAIGE A,256.
	JRST .+2
	JRST CKML1
	MOVE 0,400000+PAREP*2000+20	;IF THIS NXMS, MEM THE SYS THINKS IT HAS IS NON EXISTANT
				;CHECK STATE OF USEHM
	CONSZ 10000
	JRST CKML1	;THAT MEM LOSES
CKML2:	SOJGE A,CKML
	MOVEI TT,0
	DPB TT,[.PAREP+EXEUMP]
	LPMR UPGML
	CONO PI,240000+11577+IFN C1MXP,20000
	CONO TTY,TTYCHN
IFN ARMP,	DATAO 760,[0]	;RESET LITE ON ARM
IFN DSDP,	CONO DSDEV,10	;RESET INT RQ FROM PDP10
IFN RBTCP,	CONO RBTCON,0	;RESET TABLET
	JRST BEGS1

	MOVE A,DDT-2	;PUT GLOBAL BLOCK HEADER AT BEGINNING
	MOVE B,[SQUOZE 0,GLOBAL]
	CAME B,(A)	;SEARCH FOR GLOBAL BLOCKS
	AOBJN A,[	AOBJN A,.-1
			JRST BEGS1]
	MOVE C,DDT-2
	MOVEI D,(C)
	SUBI D,(A)	;GET ,,-#WDS  BEFORE GLOBAL BLOCK
	MOVSI D,(D)
	ADDM D,1(A)	;GLOBAL BLOCK NOW LARGER
	EXCH B,(C)	;EXCHANGE IT WITH FIRST SYM
	MOVEM B,(A)
	MOVE B,1(A)
	EXCH B,1(C)
	MOVEM B,1(A)
	PUSHJ P,SBUBL
	JUMPL J,.-1	;KEEP SORTING UNTIL SYMS IN ORDER
	HRROS DDT-1
BEGS1:	MOVE A,[-LTSTB,,TSTB]
BEG1:	MOVE B,(A)
	MOVEI C,(B)
	EQV C,(B)
	AOBJN B,.-1
	MOVEM C,CKSUMS-TSTB(A)
	MOVE B,(A)
CKXC2:	MOVE C,(B)
REPEAT 36.,[
	IFL .RPCNT-18.,TLNE C,400000_<-.RPCNT>
IFGE .RPCNT-18.,TRNE C,400000_<18.-.RPCNT>
	XORM B,CKXORS+.RPCNT
]
	AOBJN B,CKXC2
	AOBJN A,BEG1
	MOVE A,[-LTSTB,,TSTB]
	MOVEI E,20
	HRRZM A,37
	SKIPL UMBTS
	JRST IMBT4
	SMB A,37
	SKIPN 37	;CHECK FOR 16K MEM
	JRST 4,.	;2311 S NOT HAPPY FLIP DISABLE DEC MEM SWITCH
	MOVEI D,0
	MOVEI T,1
IMBT3:	MOVE B,(A)	;SET META BIT IN CONSTANT PARTS OF SYSTEM
IMBT2:	CAIL E,(B)	;AND CLEAR IN REST
	JRST IMBT1
	SMB D,(E)
	AOJA E,IMBT2

IMBT1:	SMB T,(B)
	AOS E
	AOBJN B,IMBT1
	AOBJN A,IMBT3
IMBT5:	CAILE E,777777
	JRST IMBT4
	SMB D,(E)
	AOJA E,IMBT5
IMBT4:	MOVEI A,0
	CLEARM QACTB
QSETUP:	MOVE B,DCHBT(A)
	SKIPN QACT(A)
	IORM B,QACTB
	CAIGE A,NQS-1
	AOJA A,QSETUP
IFE DECDKC,	CONO DC0,DCCSET+DCDENB+DSKCHN	;RESET 2314 AND SET DATA ERROR ENABL
IFN 340P,	CONO DIS,100
IFN TK10P,	CONO NTY,TTYCHN
IFN MTYP,	CONO MTY,TTYCHN
	CLEARM USRHI
	CLEARB U,USER
	MOVE P,SYSPDP
IFN DPKPP,[
	CONO DPK,400070+TTYCHN	;INITIALIZE DP KLUDGE
	DATAO DPK,[4,,DPKBAS]
	MOVE T,[-NDPTYS,,NFDPT]
	MOVEI B,0	;LINE #
DPIL:	PUSHJ P,DSPINI
	LDB A,[220300,,TTYTYP(T)]	;OUTPUT SPEED
	LSH A,9
	DPB B,[140400,,A]	;LINE #
	CONO DPK,500+TTYCHN(A)	;LOAD OUT SPEED
	LDB A,[250300,,TTYTYP(T)]	;INPUT SPEED
	LSH A,9
	DPB B,[140400,,A]
	CONO DPK,700+TTYCHN(A)	;LOAD IN SPEED
	AOS B
	AOBJN T,DPIL
]
IFN MTYP,[
	MOVE T,[-NMTYS,,NFMTY]
MTIL:	PUSHJ P,DSPINI
	AOBJN T,MTIL
]
	HRREI T,SYSCON	;PICK UP SYS JOB CONSOLE NUM
	MOVEI U,LUBLK
	PUSHJ P,USSINI	;INITIALIZE SYS JOB VARIABLES BLOCK
	JRST .-1
	AOS NMPGS
	MOVSI T,600000
	HLLM T,UPGMP	;GIVE PG 0 TO SYS JOB
	MOVEI T,2000
	MOVEM T,HUSRAD
	MOVEI T,SYSRCE	;SET SYS JOB RESOURCE POINTER
	MOVEM T,UTMPTR
	MOVSI A,(SIXBIT /SYS/)	;""" NAMES
	MOVEM A,USYSNM(U)
	MOVEM A,UNAME(U)
	MOVEM A,JNAME(U)
	SETZM USTP(U)
	MOVNI T,1
	MOVEI U,2*LUBLK
	PUSHJ P,USSINI	;SET UP CORE JOB VARIABLES BLOCK
	JRST .-1
	MOVE A,[SIXBIT /CORE/]
	MOVEM A,USYSNM(U)
	MOVEM A,UNAME(U)
	MOVSI A,(SIXBIT /JOB/)
	MOVEM A,JNAME(U)
	MOVEI T,SYSRCE
	MOVEM T,UTMPTR+LUBLK
	SETZM USTP(U)
	MOVEI A,CORJI
	MOVEM A,UPC(U)
	MOVEI A,SYSB
	MOVEM A,CORRQ
	AOS NCORRQ
	SOS A
	ADDM A,NCBCOM
;	DATAI CLK1,LCLK1
	CONO PI,100+UTCON-1	;ALL EXCEPT 7
	CONO 3000+APRCHN
	JRST ICLR

DSPINI:	LDB C,[300300,,TTYTYP(T)]	;CONSOLE TYPE
	MOVEM C,TCTYP(T)
	MOVE D,CNSLHL(C)
	MOVEM D,TCMXH(T)
	MOVE D,CNSLVL(C)
	MOVEM D,TCMXV(T)
	MOVEM D,TCMXP(T)
	SETZM TCHP(T)
	SETZM TCVP(T)
	SETZM TCMVPO(T)
	SETZM TCMHPO(T)
	SETZM TCEVPO(T)
	SETZM TCEHPO(T)
	POPJ P,

CKML1:	CONO 635550	;MEM NON-EXISTANT PATCH OUR
	LDB TT,[MUR,,MEMBLT(A)]
	CAIE TT,MUFR
	JRST 4,.	;?
	TRNE A,600
	JRST CKML3
	CAIG A,SYSB+1
	JRST 4,.	;SYS MEM NON EX?
	PUSHJ P,MPOUT2	;FLUSH THAT BLOCK
CKML5:	MOVEI TT,MUHOLE
	DPB TT,[MUR,,MEMBLT(A)]
	JRST CKML2

CKML3:	MOVEI B,MEMHPT-MEMBLT
	HRRZ C,MEMHPT
CKML3A:	CAMN C,A
	JRST CKML3B
	HRRZ B,C
	HRRZ C,MEMBLT(C)
	JUMPN C,CKML3A
	JRST 4,.	;CANT FIND IT

CKML3B:	HRRZ D,MEMBLT(C)
	HRRM D,MEMBLT(B)
	SOS MEMFR
	JRST CKML5

USEHM:	-1	;-1 USE MEM INHIGH MOBY (IF PRESET)

CONSTANTS
VARIABLES
IEND:

SALV==100*2000
DDT==774000

END	BEG
