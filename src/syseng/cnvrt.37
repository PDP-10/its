
IF1	TITLE CNVRT - KL10 MICROCODE, etc. ASCIIZER

.MLLIT==1

A=1		;ARG/TEMP
B=2		;..
C=3		;..
D=4		;..
E=5		;..
T=6		;TEMP
TT=7		;TEMP
H=10		;ARG TO ASCIIZING ROUTINE
I=11		;..
J=12		;..
Q=13		;..
IX=14		;INPUT INDEX IN MICROCODE ASCIIZER
OX=15		;OUTPUT ..
COD=16		;TYPE OF CODE BEING ASCIIZED
P=17		;PDL POINTER

TYIC==1
TYOC==2
INCH==3
OUCH==4

LBUF==200
INBUF:	BLOCK LBUF
INPNT:	0
INCNT:	0
INBS:	7

OUTBUF:	BLOCK LBUF
OUTPNT:	0
OUTCNT:	0
OUTBS:	7

LPDL==100
PDL:	-LPDL,,.
	BLOCK LPDL

RCH:	.VALUE			;INSTRUCTION TO READ CHAR INTO A

LOSE:	0			;NON-ZERO IF ERR MSGS PRINTED

DEFINE MSG A
	MOVEI TT,[ASCIZ\A\]
	PUSHJ P,MSGO
TERMIN

MSGOT:	MOVE TT,T
MSGO:	HRLI TT,440700		;IMPLEMENT MSG MACRO
MSGO1:	ILDB T,TT
	JUMPE T,CPOPJ
	.IOT TYOC,T
	JRST MSGO1

DEFINE POINT (SIZ,ADR,POS=-1
<<43'-.RADIX 10.,<POS>>_36'+<.RADIX 10.,<SIZ>>_30'+ADR>TERMIN

JCLF:	0		;-1 READING FROM JCL INSTEAD OF TTY
JCLBUF:	BLOCK 20
JCLEND==.-1

DEFINE CONC A,B
A!B!TERMIN

DEFINE SUBTTL A/
TERMIN

SUBTTL I/O ROUTINES

;JSP TT,INIT TO SET UP PDL, TYIC, TYOC

INIT:	MOVE P,PDL
	PUSH P,TT
	.OPEN TYIC,[.UAI,,'TTY]
	 .VALUE
	.OPEN TYOC,[%TJDIS+.UAO,,'TTY]
	 .VALUE
	.CALL [	SETZ
		SIXBIT /CNSGET/
		MOVEI TYOC
		REPEAT 4,MOVEM NOWHER
		SETZM TT ]
	 MOVEI TT,0
	SETZM DISTTY'
	TLNE TT,%TOERS
	 SETOM DISTTY

	SETOM JCLF
	SETZM JCLBUF
	MOVE T,[JCLBUF,,JCLBUF+1]
	BLT T,JCLEND
	.BREAK 12,[5,,JCLBUF]
	MOVE T,[440700,,JCLBUF]
	MOVEM T,JCLP'
	SKIPN JCLBUF
	 SETZM JCLF
	MOVE T,[PUSHJ P,TYIMAN]
	MOVEM T,RCH
	POPJ P,

;READ CHARACTER FROM JCL OR TTY 
;CHAR RETURNED IN T

TYIMAN:	SKIPN JCLF
	 JRST RCHTYI
	ILDB T,JCLP
	CAIE T,^M
	CAIN T,^C
	 CAIA
	  JUMPN T,CPOPJ
	MOVEI T,^M		;JCL ENDS WITH ^@, ^C, OR ^M
	SETZM JCLF
	POPJ P,

RCHTYI:	MOVE T,[.IOT TYIC,T]
	MOVEM T,RCH
	SOS (P)
	POPJ P,

;READ SIXBIT SYLLABLE INTO A, RETURN DELIMITER IN T
;DELIMITERS ARE NON-SIXBIT PLUS COLON, SEMICOLON, QUESTION, AND SPACE
;SKIP RETURN UNLESS FULLY RUBBED-OUT

GETSYL:	MOVEI A,0
	MOVE TT,[440600,,A]
GETSY0:	XCT RCH
	CAIN T,177
	 JRST GSYRUB
	CAIE T,"?
	CAIG T,40
	 JRST POPJ1
	CAIE T,":
	CAIN T,";
	 JRST POPJ1
	CAIL T,"a
	CAILE T,"z
	 SUBI T,40
	TLNE TT,770000
	 IDPB T,TT
	JRST GETSY0

GSYRUB:	MOVEI T,[ASCIZ/XXX /]
	JUMPL TT,MSGOT		;WHOLE SYLLABLE RUBBED OUT, POPJ
	LDB T,TT
	ADDI T,40
	ADD TT,[060000,,]
	SKIPN DISTTY
	 JRST [	.IOT TYOC,T
		JRST GETSY0 ]
	.IOT TYOC,[^P]
	.IOT TYOC,["X]
	JRST GETSY0


;FILE NAME READER.  STORES INTO DEVICE, FNAME1, FNAME2, SNAME
;RETURNS:  NO SKIP, FULLY RUBBED OUT.  SKIP, WON.

FNR:	MOVSI T,'DSK		;DEFAULTS
	MOVEM T,DEVICE
	.SUSET [.RSNAME,,SNAME]
FNR00:	SETZM FNAME1		;FN1 NOT TYPED YET
	SETZM FNAME2
FNR0:	PUSHJ P,GETSYL		;READ NEXT SYLLABLE
	 POPJ P,		;FULLY RUBBED OUT
	CAIN T,":
	 MOVEM A,DEVICE'
	CAIN T,";
	 MOVEM A,SNAME'
	CAIE T,":
	CAIN T,";
	 JRST FNR0
	JUMPE A,FNR3
	SKIPN FNAME1
	 JRST [	MOVEM A,FNAME1'
		JRST FNR3 ]
	MOVEM A,FNAME2'
FNR3:	CAIL T,40
	 JRST FNR0
	SKIPE TT,FNAME1		;IF FN1 GIVEN, BUT NOT FN2,
	 MOVE TT,2NDNIN(COD)	;DEFAULT FN2 APPROPRIATELY
	SKIPN FNAME2
	 MOVEM TT,FNAME2
				;RETURN WITH DELIM CHAR IN T
POPJ1:	AOS (P)
CPOPJ:	POPJ P,

2NDNIN:	SIXBIT /MCR/
	SIXBIT /BIN/
	SIXBIT /BIN/
	SIXBIT /A10/
IF2 IFN .-2NDNIN-LJNMTB, .ERR 2NDNIN TABLE LOSES

;READ CHARACTER FROM INCH, RETURN IN T.

RDCH:	SOSG INCNT
	 PUSHJ P,RDCH1
	ILDB T,INPNT
	POPJ P,

RDCH1:	PUSH P,TT		;GETSYL WANTS TT PROTECTED
	MOVEI T,36.		;BUFFER REFILL
	IDIV T,INBS
	MOVE TT,[-LBUF,,INBUF]
	.IOT INCH,TT
	MOVEI TT,-INBUF(TT)
	IMUL TT,T
	MOVEM TT,INCNT
	JUMPE TT,EOFHAN		;@EOFHAN(COD) ?
	MOVE T,INBS
	LSH T,18.+6
	TLO T,440000
	HRRI T,INBUF
	MOVEM T,INPNT
POPTTJ:	POP P,TT
	POPJ P,

EOFHAN:	MSG UNEXPECTED E-O-F
	.VALUE 

REWIND:	.ACCESS INCH,[0]
	SETZM INCNT		;CAUSE BUFFER RELOAD ON NEXT RDCH
	POPJ P,

;WRITE CHARACTER IN A ONTO OUCH, CLOBBER T,TT

WRCH:	SOSG OUTCNT
	 PUSHJ P,WRBUF
	IDPB A,OUTPNT
	POPJ P,

WRBUF:	SKIPN T,OUTPNT	;PAD TO WORD
	 JRST WRBUF1
	IBP T
	HRRZS T
	CAIE T,@OUTPNT
	 JRST WRBUF0
	MOVEI T,^C
	IDPB T,OUTPNT
	JRST WRBUF

WRBUF0:	MOVE T,OUTPNT
	HRLOI T,-OUTBUF(T)
	EQVI T,OUTBUF
	.IOT OUCH,T
WRBUF1:	MOVEI T,36.
	IDIV T,OUTBS
	IMULI T,LBUF
	MOVEM T,OUTCNT
	MOVE T,OUTBS
	LSH T,18.+6
	TLO T,440000
	HRRI T,OUTBUF
	MOVEM T,OUTPNT
	POPJ P,

;RETURN OCTAL NUMBER IN B, DELIMITER IN T, CLOBBER A,B,T,TT

GETOCT:	MOVEI B,0
GETOC1:	XCT RCH
	CAIL T,"0
	CAILE T,"7
	 POPJ P,
	IMULI B,8
	ADDI B,-"0(T)
	JRST GETOC1

SUBTTL ASCIIZING SUBROUTINES

;CALL HERE TO START PUTTING OUT AN ASCIIZED LINE
;H HAS FIRST CHARACTER, I HAS ADDRESS, J HAS COUNT
;CHECKSUM WILL BE ACCUMULATED IN Q
;CLOBBER Q,A,B,C,T,TT

11BEG:	MOVE Q,J		;INIT CHECKSUM FROM COUNT
	ADD Q,I			; AND ADDRESS
	MOVE A,H		;PUT COMMAND CHAR
	PUSHJ P,WRCH
	MOVEI A,40		;PUT SPACE
	PUSHJ P,WRCH
	MOVE B,J		;PUT WORD COUNT
	PUSHJ P,11PUT
	PUSHJ P,PUTCMA		;PUT COMMA
	LDB B,[.BP 177777,I]
	PUSHJ P,11PUT		;PUT ADDRESS
	JRST PUTCMA		;PUT COMMA AND RETURN

;CALL HERE TO PUT NEXT WORD OF ASCIIZED LINE
;B HAS WORD.  CHECKSUM IN Q.  CLOBBERS A,C,T,TT.

11WORD:	ADD Q,B			;ACCUMULATE CHECKSUM
	PUSHJ P,11PUT		;OUTPUT THE WORD
	JRST PUTCMA		;PUT COMMA AND RETURN

;CALL HERE TO END AN ASCIIZED LINE
;CLOBBERS A,B,C,T,TT

11END:	MOVN B,Q		;OUTPUT NEGATIVE CHECKSUM
	ANDI B,177777		;MASKED TO 16 BITS
	PUSHJ P,11PUT
	MOVEI A,15		;THEN CRLF
	PUSHJ P,WRCH
	MOVEI A,12
	PUSHJ P,WRCH
	POPJ P,

PUTCMA:	MOVEI A,",
	JRST WRCH

;PUT WORD IN B INTO ASCIIZED LINE, 3 CHARS LEADING ZEROS SUPPRESSED
;CLOBBER A,B,C,T,TT

11PUT:	MOVE C,[220600,,B]
	JUMPE B,CPOPJ		;SKIP LEADING ZEROS
	ILDB A,C		
	JUMPE A,.-1
11PUT0:	CAIGE A,75		;MAP INTO RANGE 75-174
	 ADDI A,100
	PUSHJ P,WRCH		;WRITE OUT CHR
	TLNN C,770000
	 POPJ P,
	ILDB A,C		;DO NEXT CHR
	JRST 11PUT0

;TYPE OUT OCTAL NUMBER IN T.  CLOBBER T,TT.

PUTOCT:	IDIVI T,8
	HRLM TT,(P)
	SKIPE T
	 PUSHJ P,PUTOCT
	HLRZ TT,(P)
	ADDI TT,"0
	.IOT TYOC,TT
	POPJ P,

;TYPE OUT SIXBIT WORD IN TT. CLOBBER T,TT.

PUTSIX:	MOVEI T,0
	LSHC T,6
	ADDI T,40
	.IOT TYOC,T
	JUMPN TT,PUTSIX
	POPJ P,

SUBTTL MAIN PROGRAM

CNVRT:	JSP TT,INIT
	MOVE TT,[.FNAM1]
	PUSHJ P,PUTSIX
	.IOT TYOC,[".]
	MOVE TT,[.FNAM2]
	PUSHJ P,PUTSIX
	.IOT TYOC,[15]
	.SUSET [.RJNAME,,TT]
	MOVSI T,-LJNMTB
	CAME TT,JNMTAB(T)
	 AOBJN T,.-1
	JUMPGE T,[MSG [JNAME NOT IN {UCNVRT,MCNVRT,PCNVRT}]
		  .BREAK 16,040000 ]
	HRRZ COD,T
	MOVE TT,GREET(COD)
	PUSHJ P,MSGO
	.IOT TYOC,[15]

RFN:	MOVEI TT,[ASCIZ/FILE: /]
	SKIPN JCLF
	 PUSHJ P,MSGO
	PUSHJ P,FNR
	 JRST RFN
	.CALL [	SETZ
		SIXBIT/OPEN/
		[.BAI,,INCH]
		DEVICE
		FNAME1
		FNAME2
		SETZ SNAME ]
	 JRST [	MSG CANNOT READ FILE
		.VALUE [ASCIZ\î:ERRî\] ]
	.CALL [	SETZ
		SIXBIT/OPEN/
		[.BAO,,OUCH]
		DEVICE
		FNAME1
		2NDNAM(COD)
		SETZ SNAME ]
	 JRST [	MSG CANNOT WRITE FILE
		.VALUE [ASCIZ\î:ERRî\] ]
	MOVE TT,[PUSHJ P,RDCH]
	MOVEM TT,RCH
	JRST @CNVRTR(COD)

;COME HERE WHEN ALL OUTPUT IS COMPLETE

DONE:	PUSHJ P,WRBUF		;WRITE OUT LAST BUFFER
	.CLOSE OUCH,
	SKIPE LOSE
	 JRST LOST
	MSG DONE
	.BREAK 16,160000

LOST:	MSG LOST
	.BREAK 16,040000

JNMTAB:	OFFSET -.
%%UCOD::SIXBIT/UCNVRT/	;ASCIIZE SOME MICROCODE
%%MID::	SIXBIT/MCNVRT/	;ASCIIZE "MIDAS" (ITS SBLK FORMAT)
%%PALX::SIXBIT/PCNVRT/	;ASCIIZE "PALX" (PDP11 ABS PAPER TAPE, 1 BYTE PER WORD)
%%ASS::	SIXBIT/ACNVRT/	;PDP10 BINARY DE-ASCIIZER
	OFFSET 0
LJNMTB==.-JNMTAB

GREET:	[ASCIZ/KL10 MICROCODE ASCIIZER/]
	[ASCIZ/PDP10 BINARY CODE ASCIIZER/]
	[ASCIZ/PDP11 BINARY CODE ASCIIZER/]
	[ASCIZ/PDP10 ASCII BINARATOR/]
IFN .-GREET-LJNMTB, .ERR GREET TABLE LOSES

2NDNAM:	SIXBIT/RAM/
	SIXBIT/A10/
	SIXBIT/A11/
	SIXBIT/BIN/
IFN .-2NDNAM-LJNMTB, .ERR 2NDNAM TABLE LOSES

CNVRTR:	UCNVRT
	MCNVRT
	PCNVRT
	ACNVRT
IFN .-CNVRTR-LJNMTB, .ERR CNVRTR TABLE LOSES

SUBTTL MICROCODE ASCIIZER

UCNVRT:	SETZM DRMCNT'
	SETZM CRMMAX'
	SETZM DRAM		;ZERO OUT BOTH RAMS
	MOVE TT,[DRAM,,DRAM+1]
	BLT TT,CRAM+CRMSIZ*CRMWDS-1

MICLP:	PUSHJ P,GETSYL		;GET COMMAND WORD
	 .VALUE
	JUMPN A,MICL1
	CAIE T,";
	 JRST MICLP		;IGNORE RANDOM BLANK LINES ETC
MICL0:	XCT RCH			;SKIP COMMENT
SKEOL:	CAIE T,12
	CAIN T,14
	 JRST MICLP
	JRST MICL0

MICL1:	CAMN A,[SIXBIT/END/]
	 JRST DCSHUF		;DONE, SHUFFLE BITS AND OUTPUT
	CAMN A,[SIXBIT/D/]
	 JRST STDRAM
	CAME A,[SIXBIT/U/]
	CAMN A,[SIXBIT/V/]
	 JRST STCRAM
	MSG RAMDOMNESS IN ALLEGED "MCR" FILE
	.VALUE

;STORE INTO C RAM

STCRAM:	PUSHJ P,GETOCT		;GET C RAM ADDRESS
	CAIL B,CRMSIZ
	 JRST [	MSG C RAM DON'T FIT
		.VALUE ]
	CAMLE B,CRMMAX
	 MOVEM B,CRMMAX		;REMEMBER MAXIMUM C RAM ADDRESS SEEN
	MOVE I,B
	IMULI I,CRMWDS
	XCT RCH			;SKIP COMMA AFTER ADDRESS
	CAIE T,40
	 JRST [	MSG C RAM SEPARATOR NOT SPACE
		.VALUE ]
	PUSHJ P,GETOCT		;GET LISTING BITS 0-11
	LSH B,24.
	MOVE Q,B
	PUSHJ P,GETOCT		;GET LISTING BITS 12-23
	LSH B,12.
	IOR Q,B
	PUSHJ P,GETOCT		;GET LISTING BITS 24-35
	IOR Q,B
	MOVEM Q,CRAM(I)		;STORE 1ST WD
	PUSHJ P,GETOCT		;GET LISTING BITS 36-47
	LSH B,24.
	MOVE Q,B
	PUSHJ P,GETOCT		;GET LISTING BITS 48-59
	LSH B,12.
	IOR Q,B
	PUSHJ P,GETOCT		;GET LISTING BITS 60-71
	IOR Q,B
	MOVEM Q,CRAM+1(I)	;STORE 2ND WD
	PUSHJ P,GETOCT		;GET LISTING BITS 72-83
	LSH B,24.
	HLLOM B,CRAM+2(I)	;STORE 3D WD, RH=-1 TO MARK WORD USED
	JRST SKEOL

DRMSIZ==512.		;SIZE OF D RAM
DRMWDS==1		;# WORDS PER FROB IN D RAM
CRMSIZ==1536.		;SIZE OF C RAM
CRMWDS==3		;# WORDS PER FROB IN C RAM

DRAM:	BLOCK DRMSIZ*DRMWDS
CRAM:	BLOCK CRMSIZ*CRMWDS
11BUF:	BLOCK 4*6		;LOAD UP TO 4 CRAM LOCS AT A TIME
NOWHER:	-1			;UNUSED BITS GO HERE

;STORE INTO D RAM

STDRAM:	PUSHJ P,GETOCT		;GET D RAM ADDRESS
	CAIL B,DRMSIZ
	 JRST [	MSG D RAM DON'T FIT
		.VALUE ]
	AOS DRMCNT		;ANOTHER D RAM ENTRY
	MOVE I,B
	IMULI I,DRMWDS
	XCT RCH			;SKIP COMMA AFTER ADDRESS
	CAIE T,40
	 JRST [	MSG D RAM SEPARATOR NOT SPACE
		.VALUE ]
	PUSHJ P,GETOCT		;GET 1ST LISTING WORD, A, B, & P
	HRLZM B,DRAM(I)
	PUSHJ P,GETOCT		;GET 2ND LISTING WORD, J FIELD
	HRRM B,DRAM(I)
	JRST SKEOL

;SHUFFLE BITS AND OUTPUT

DCSHUF:	.CLOSE INCH,
	MOVE TT,DRMCNT
	CAIE TT,DRMSIZ
	 JRST [	MSG D RAM NOT FULLY POPULATED
		JRST .+1 ]

;ZERO, SHUFFLE, AND OUTPUT C RAM

CSHUF:	MOVEI H,"Z		;ZERO ALL USED C RAM LOCATIONS
	MOVEI I,0
	MOVEI J,1
	PUSHJ P,11BEG
	MOVE B,CRMMAX
	PUSHJ P,11WORD
	PUSHJ P,11END

	SETZB I,IX		;START DUMPING C RAM AT ADDRESS 0
	SETOM CRMPRV'		;INIT PREVIOUS ADDRESS
	SETOM CRMBLK'		;INIT CURRENT BLOCK BASE ADDR
	SETZB J,OX		;INIT COUNT OF WORDS IN BLOCK, 11BUF INDEX

CSHUF1:	PUSHJ P,CWORD		;PROCESS ONE C RAM WORD
	ADDI IX,CRMWDS		;ADVANCE TO NEXT
	CAIGE I,CRMSIZ-1
	 AOJA I,CSHUF1
	PUSHJ P,CRMOUT		;OUTPUT ANY RESIDUE
	MOVEI H,"C		;END BLOCK, TYPE C, COUNT 0, ADDR 0 MEANS NO START
	SETZB I,J
	PUSHJ P,11BEG
	PUSHJ P,11END

;SHUFFLE AND OUTPUT D RAM

DSHUF:	SETZB I,IX		;START DUMPING D RAM AT ADDRESS 0
	SETZB J,OX		;INIT COUNT OF WORDS IN BLOCK, 11BUF INDEX
	SETOM DRMBLK'

DSHUF1:	PUSHJ P,DWORD		;PROCESS TWO D RAM WORDS
	ADDI IX,2*DRMWDS	;ADVANCE TO NEXT
	ADDI I,2
	CAIGE I,DRMSIZ
	 JRST DSHUF1
	PUSHJ P,DRMOUT		;OUTPUT ANY RESIDUE
	MOVEI H,"D		;END BLOCK, TYPE D, COUNT 0, ADDR 0 MEANS NO START
	SETZB I,J
	PUSHJ P,11BEG
	PUSHJ P,11END
	JRST DONE

;OUTPUT BLOCK OF C RAM INDICATED BY CRMPRV, J

CRMOUT:	JUMPE J,CRMOU2		;DON'T PUT ZERO LENGTH BLOCKS
	PUSH P,I
	SKIPGE I,CRMBLK		;GET ADDRESS OF BLOCK
	 .VALUE
	CAILE OX,4*6		;MAKE SURE 11BUF DIDN'T OVERFLOW
	 .VALUE
	MOVEI H,"C
	PUSHJ P,11BEG
	MOVNS J
	HRLZS J
CRMOU1:	MOVE B,11BUF(J)
	PUSHJ P,11WORD
	AOBJN J,CRMOU1
	PUSHJ P,11END
	SETZB J,OX
	POP P,I
CRMOU2:	MOVEM I,CRMBLK		;SET BASE ADDRESS OF NEXT BLOCK
	POPJ P,

;SHUFFLE AND OUTPUT CRAM WORD POINTED TO BY IX, ADDRESS IN I

CWORD:	SKIPN CRAM+2(IX)
	 POPJ P,		;THIS ADDRESS NOT LOADED
	AOS CRMPRV
	CAME I,CRMPRV
	 PUSHJ P,CRMOUT		;ADDRESSES NOT SEQUENTIAL, START NEW BLOCK
	TRNN I,3
	 PUSHJ P,CRMOUT		;START NEW BLOCK OF FOUR
	MOVEM I,CRMPRV		;INIT PREV ADDR TO THIS ADDR
	SETZM 11BUF(OX)		;ZERO OUT ACTUAL STORAGE
	MOVEI A,1+11BUF(OX)
	HRLI A,11BUF(OX)
	BLT A,11BUF+5(OX)
	SETZM NOWHER
	SETZB C,D		;INIT BIT COUNTER, PARITY
	MOVE B,[440100,,CRAM(IX)]	;INIT BP TO BITS
CWORD1:	ILDB A,B		;GET NEXT BIT OF LISTING FORMAT C RAM WORD
	JUMPE A,CWORD2		;FAST IF 0
	DPB A,CRAMPT(C)		;STORE THE BIT
	XORI D,1		;AND ACCUMULATE PARITY
CWORD2:	CAIGE C,84.-1		;SKIP IF ALL BITS DONE
	 AOJA C,CWORD1
	SKIPE NOWHER		;MAKE ERROR CHECKS
	 PUSHJ P,CUNUSD
	SKIPN D
	 PUSHJ P,CODDPR
	ADDI J,6		;OUTPUT 6 WORDS
	ADDI OX,6
	POPJ P,

CUNUSD:	MSG ATTEMPT TO TURN ON UNUSED BITS
	JRST CRMERR

CODDPR:	MSG EVEN PARITY
CRMERR:	MSG [ IN C RAM LOCATION ]
	SETOM LOSE
	MOVE T,I
	PUSHJ P,PUTOCT
	.IOT TYOC,[15]
	POPJ P,

;C RAM BIT MAPPING TABLE

CRAMPT:	POINT	1,NOWHERE,35		;UNUSED		0
	POINT	1,11BUF+4(OX),25	;J00
	POINT	1,11BUF+4(OX),26	;J01
	POINT	1,11BUF+4(OX),27	;J02
	POINT	1,11BUF+4(OX),28	;J03
	POINT	1,11BUF+4(OX),29	;J04
	POINT	1,11BUF+4(OX),30	;J05
	POINT	1,11BUF+4(OX),31	;J06
	POINT	1,11BUF+4(OX),32	;J07
	POINT	1,11BUF+4(OX),33	;J08
	POINT	1,11BUF+4(OX),34	;J09		10
	POINT	1,11BUF+4(OX),35	;J10
	POINT	1,11BUF+0(OX),30	;AD CRY
	POINT	1,11BUF+3(OX),28	;AD BOOLE
	POINT	1,11BUF+3(OX),24	;AD SEL 8
	POINT	1,11BUF+3(OX),25	;AD SEL 4
	POINT	1,11BUF+3(OX),26	;AD SEL 2
	POINT	1,11BUF+3(OX),27	;AD SEL 1
	POINT	1,11BUF+3(OX),29	;ADA DIS
	POINT	1,11BUF+3(OX),30	;ADA SEL 2
	POINT	1,11BUF+3(OX),31	;ADA SEL 1	20
	POINT	1,NOWHERE,34		;UNUSED
	POINT	1,11BUF+3(OX),32	;ADB SEL 2
	POINT	1,11BUF+2(OX),20	;ADB SEL 1
	POINT	1,11BUF+2(OX),33	;ARM SEL 4
	POINT	1,11BUF+0(OX),20	;ARM SEL 2
	POINT	1,11BUF+0(OX),22	;ARM SEL 1
	POINT	1,11BUF+2(OX),24	;ARXM SEL 4
	POINT	1,11BUF+0(OX),24	;ARXM SEL 2
	POINT	1,11BUF+0(OX),26	;ARXM SEL 1
	POINT	1,11BUF+1(OX),24	;BR LOAD	30
	POINT	1,11BUF+1(OX),26	;BRX LOAD
	POINT	1,11BUF+3(OX),20	;MQ SEL
	POINT	1,11BUF+1(OX),28	;FM ADR SEL 4
	POINT	1,11BUF+1(OX),29	;FM ADR SEL 2
	POINT	1,11BUF+1(OX),30	;FMADR SEL 1	35
	POINT	1,11BUF+4(OX),21	;SCAD 4		36
	POINT	1,11BUF+4(OX),22	;SCAD 2
	POINT	1,11BUF+4(OX),23	;SCAD 1
	POINT	1,11BUF+4(OX),20	;SCADA DIS
	POINT	1,11BUF+2(OX),28	;SCADA SEL 2	40
	POINT	1,11BUF+2(OX),29	;SCADA SEL 1
	POINT	1,NOWHERE,33		;UNUSED
	POINT	1,11BUF+2(OX),30	;SCADB SEL 2
	POINT	1,11BUF+1(OX),32	;SCADB SEL 1
	POINT	1,NOWHERE,32		;UNUSED
	POINT	1,11BUF+1(OX),34	;SCM SEL 2
	POINT	1,11BUF+4(OX),24	;FE LOAD
	POINT	1,NOWHERE,31		;UNUSED
	POINT	1,11BUF+2(OX),34	;ARMM SEL 2
	POINT	1,11BUF+2(OX),35	;ARMM SEL 1	50
	POINT	1,NOWHERE,30		;UNUSED
	POINT	1,11BUF+2(OX),32	;VMAM SEL 2
	POINT	1,11BUF+0(OX),28	;VMAM SEL 1
	POINT	1,11BUF+0(OX),32	;T00
	POINT	1,11BUF+0(OX),34	;T01
	POINT	1,11BUF+1(OX),20	;MEM 00
	POINT	1,11BUF+1(OX),21	;MEM 01
	POINT	1,11BUF+1(OX),22	;MEM 02
	POINT	1,11BUF+1(OX),23	;MEM 03
	POINT	1,11BUF+3(OX),21	;COND 00	60
	POINT	1,11BUF+3(OX),22	;COND 01
	POINT	1,11BUF+3(OX),23	;COND 02
	POINT	1,11BUF+1(OX),25	;COND 03
	POINT	1,11BUF+1(OX),27	;COND 04
	POINT	1,11BUF+1(OX),31	;COND 05
	POINT	1,NOWHERE,29		;UNUSED
	POINT	1,11BUF+5(OX),31	;SPEC 00
	POINT	1,11BUF+5(OX),32	;SPEC 01
	POINT	1,11BUF+5(OX),33	;SPEC 02
	POINT	1,11BUF+5(OX),34	;SPEC 03	70
	POINT	1,11BUF+5(OX),35	;SPEC 04	71
	POINT	1,NOWHERE,28		;UNUSED		72
	POINT	1,NOWHERE,27		;UNUSED
	POINT	1,11BUF+2(OX),31	;MARK
	POINT	1,11BUF+3(OX),33	;# 00
	POINT	1,11BUF+3(OX),34	;# 01
	POINT	1,11BUF+3(OX),35	;# 02
	POINT	1,11BUF+2(OX),21	;# 03
	POINT	1,11BUF+2(OX),22	;# 04
	POINT	1,11BUF+2(OX),23	;# 05		80
	POINT	1,11BUF+2(OX),25	;# 06
	POINT	1,11BUF+2(OX),26	;# 07
	POINT	1,11BUF+2(OX),27	;# 08		83

;OUTPUT BLOCK OF D RAM INDICATED BY I, J

DRMOUT:	JUMPE J,DRMOU2		;DON'T PUT ZERO LENGTH BLOCKS
	PUSH P,I
	SKIPGE I,DRMBLK
	 .VALUE
	CAILE OX,4*6		;MAKE SURE 11BUF DIDN'T OVERFLOW
	 .VALUE
	MOVEI H,"D
	PUSHJ P,11BEG
	MOVNS J
	HRLZS J
DRMOU1:	MOVE B,11BUF(J)
	PUSHJ P,11WORD
	AOBJN J,DRMOU1
	PUSHJ P,11END
	SETZB J,OX
	POP P,I
DRMOU2:	MOVEM I,DRMBLK
	POPJ P,

;OUTPUT PAIR OF DRAM WORDS AT ADDRESS I, IX -> LISTING FMT, J # WDS SO FAR, OX -> OUT BUF

DWORD:	TRNN I,7
	 PUSHJ P,DRMOUT		;START NEW BLOCK OF 8
	SETZM 11BUF(OX)		;CLEAR OUTPUT AREA
	SETZM 11BUF+1(OX)
	SETZM 11BUF+2(OX)

	LDB T,[POINT 3,DRAM(IX),8]	;DO EVEN A FIELD
	DPB T,[POINT 3,11BUF(OX),24]
	LDB T,[POINT 3,DRAM+DRMWDS(IX),8] ;DO ODD A FIELD
	DPB T,[POINT 3,11BUF+1(OX),24]

	LDB T,[POINT 3,DRAM(IX),11]	;DO EVEN B FIELD
	DPB T,[POINT 3,11BUF(OX),27]
	LDB T,[POINT 3,DRAM+DRMWDS(IX),11] ;DO ODD B FIELD
	DPB T,[POINT 3,11BUF+1(OX),27]

	LDB T,[POINT 1,DRAM(IX),17]	;DO EVEN PARITY FIELD
	DPB T,[POINT 1,11BUF(OX),30]
	LDB T,[POINT 1,DRAM+DRMWDS(IX),17] ;DO ODD PARITY FIELD
	DPB T,[POINT 1,11BUF+1(OX),30]

	LDB T,[POINT 4,DRAM(IX),35]	;DO EVEN PART OF J FIELD
	DPB T,[POINT 4,11BUF(OX),35]
	LDB T,[POINT 4,DRAM+DRMWDS(IX),35] ;DO ODD PART OF J FIELD
	DPB T,[POINT 4,11BUF+1(OX),35]
	LDB T,[POINT 6,DRAM(IX),31]	;DO COMMON PART OF J FIELD
	LDB TT,[POINT 6,DRAM+DRMWDS(IX),31]
	CAIN I,254
	 TRO T,100_-4			;JRST HACK (UGH)
	CAME T,TT
	 JRST [	MSG [EVEN AND ODD J FIELDS DON'T MATCH.  D RAM LOC ]
		SETOM LOSE
		PUSH P,T
		MOVE T,I
		PUSHJ P,PUTOCT
		.IOT TYOC,[15]
		POP P,T
		JRST .+1 ]
	TRNE T,3
	 JRST [	MSG [EVIL BITS ON IN J FIELD.  D RAM LOC ]
		SETOM LOSE
		PUSH P,T
		MOVE T,I
		PUSHJ P,PUTOCT
		.IOT TYOC,[15]
		POP P,T
		JRST .+1 ]
	MOVE TT,T
	LSH TT,-2
	DPB TT,[POINT 4,11BUF+2(OX),35]

REPEAT 0,[	;THIS WOULD BE A NEAT HACK, BUT DIVI IS REALLY SINGLE PRECISION
	MOVE TT,11BUF(OX)		;CHECK PARITY
	XOR TT,11BUF+2(OX)
	CAIN I,254
	 XORI TT,1			;THE CRUFTY JRST HACK AGAIN
	IMULI TT,100000			;2 COPIES OF 15 BITS
	MOVE T,TT			;4 COPIES
	AND TT,[2104210421]		;TAKE EVERY 4TH BIT
	AND T,[421042104]		;DITTO, ALLOWING FOR 4 BITS + SIGN OF TT BETWEEN
	DIVI T,17			;HEXADECIMALLY CAST OUT 15'S
	SKIPN TT
	 JRST [	MSG [EVEN PARITY D RAM LOC ]
		SETOM LOSE
		MOVE T,I
		PUSHJ P,PUTOCT
		.IOT TYOC,[15]
		JRST .+1 ]

	MOVE TT,11BUF+1(OX)		;CHECK PARITY OF ODD LOC
	XOR TT,11BUF+2(OX)
	IMULI TT,100000			;2 COPIES OF 15 BITS
	MOVE T,TT			;4 COPIES
	AND TT,[2104210421]		;TAKE EVERY 4TH BIT
	AND T,[421042104]		;DITTO, ALLOWING FOR 4 BITS + SIGN OF TT BETWEEN
	DIVI T,17			;HEXADECIMALLY CAST OUT 15'S
	SKIPN TT			; (CASTING A HEX?)
	 JRST [	MSG [EVEN PARITY D RAM LOC ]
		SETOM LOSE
		MOVEI T,1(I)
		PUSHJ P,PUTOCT
		.IOT TYOC,[15]
		JRST .+1 ]
]	;END OF REPEAT 0

	MOVE TT,11BUF(OX)		;CHECK PARITY
	XOR TT,11BUF+2(OX)		;THE PEDESTRIAN WAY
	CAIN I,254
	 XORI TT,1			;THE CRUFTY JRST HACK AGAIN
	MOVEI T,0
DPARL1:	TRNE TT,1
	 XORI T,1
	LSH TT,-1
	JUMPN TT,DPARL1
	SKIPN T
	 JRST [	MSG [EVEN PARITY D RAM LOC ]
		SETOM LOSE
		MOVE T,I
		PUSHJ P,PUTOCT
		.IOT TYOC,[15]
		JRST .+1 ]

	MOVE TT,11BUF+1(OX)		;CHECK PARITYOF ODD WORD
	XOR TT,11BUF+2(OX)		;THE PEDESTRIAN WAY
	MOVEI T,0
DPARL2:	TRNE TT,1
	 XORI T,1
	LSH TT,-1
	JUMPN TT,DPARL2
	SKIPN T
	 JRST [	MSG [EVEN PARITY D RAM LOC ]
		SETOM LOSE
		MOVEI T,1(I)
		PUSHJ P,PUTOCT
		.IOT TYOC,[15]
		JRST .+1 ]

	ADDI J,3			;PUT OUT 3 WORDS
	ADDI OX,3
	POPJ P,

SUBTTL PDP10 BINARY CODE ASCIIZER

MCNVRT:	MOVEI T,36.	
	MOVEM T,INBS
	SETOM H			;HIGHEST ADDRESS USED
	MOVEI J,-1		;LOWEST ADDRESS USED
MCNV1:	PUSHJ P,RDCH		;FIRST PASS JUST FINDS SIZE OF PROGRAM
	CAME T,[JRST 1]
	 JRST MCNV1
MCNV2:	PUSHJ P,RDCH		;START NEW BLOCK
	MOVE A,T		;HEADER IN A
	JUMPGE A,MCNVP2		;START ADDR, ENTER PASS 2
	HRRZ T,A		;T FIRST LOC IN BLOCK
	HLRE TT,A
	SUBM T,TT		;TT FIRST LOC ABOVE BLOCK
	CAMGE T,J
	 MOVE J,T
	CAMLE TT,H
	 MOVE H,TT
	PUSHJ P,RDCH		;GOBBLE REST OF BLOCK
	AOBJN A,.-1
	PUSHJ P,RDCH		;GOBBLE CHECKSUM
	JRST MCNV2

MCNVP2:	PUSHJ P,REWIND		;BEGIN PASS 2
	CAIGE J,1000		;IF PROGRAM LOADS INTO LOW CORE
	 MOVEI J,0		;CLEAR ALL CORE
	MOVE TT,FNAME1
	PUSHJ P,PUTSIX
	MSG [ PROGRAM LIMITS ]
	MOVE T,J
	PUSHJ P,PUTOCT
	.IOT TYOC,["-]
	MOVE T,H
	PUSHJ P,PUTOCT
	.IOT TYOC,[15]
	SUB H,J			;NUMBER OF WORDS TO ZERO
	LDB I,[.BP 177777,J]	;PUT A CORE-ZERO LINE
	LDB J,[.BP 600000,J]	;WEIRD KLUDGE FOR HIGH 2 BITS OF ADDR
	LSH J,8			;..
	MOVE T,H		;COMPUTE NUMBER OF COUNT WORDS
	IDIVI T,177777
	SKIPE TT
	 AOS T
	MOVE J,T
	PUSH P,H
	MOVEI H,"Z
	PUSHJ P,11BEG
	POP P,H
MCNV4:	MOVE B,H
	CAILE B,177777
	 MOVEI B,177777
	SUB H,B
	PUSHJ P,11WORD
	JUMPN H,MCNV4
	PUSHJ P,11END
;DROPS THROUGH

;DROPS IN

MCNV5:	PUSHJ P,RDCH
	CAME T,[JRST 1]
	 JRST MCNV5
MCNV6:	PUSHJ P,RDCH		;START BLOCK
	MOVE A,T		;BLOCK HEADER IN A
	JUMPGE A,MCNVSA
	HLRE J,A
	IMUL J,[-3]
	HRRZ I,A
MCNV7:	PUSH P,J		;START LINE
	CAILE J,24.
	 MOVEI J,24.
	SUBM J,(P)
	MOVNS (P)
	MOVEI H,"T
	LDB T,[.BP 600000,I]
	LSH T,8
	IOR J,T
	PUSHJ P,11BEG
	ANDI J,377		;PUT PIECES OF WORDS
MCNV8:	PUSHJ P,RDCH
	MOVE H,T
	LDB B,[002000,,H]
	PUSHJ P,11WORD
	LDB B,[202000,,H]
	PUSHJ P,11WORD
	LDB B,[400400,,H]
	PUSHJ P,11WORD
	SUBI J,3
	ADDI I,1
	JUMPG J,MCNV8		;MORE WORDS THIS LINE
	PUSHJ P,11END
	POP P,J
	JUMPN J,MCNV7		;MORE LINES THIS BLOCK
	PUSHJ P,RDCH		;FLUSH CHECKSUM
	JRST MCNV6		;MORE BLOCKS THIS FILE

MCNVSA:	MOVEI H,"T		;WRITE TRANSFER LINE
	HRRZ I,A
	LDB J,[.BP 600000,I]
	LSH J,8
	PUSHJ P,11BEG
	PUSHJ P,11END
	JRST DONE

SUBTTL PDP10 ASCII BINARATOR

ACNVRT:	MOVEI T,36.
	MOVEM T,OUTBS
	MOVE A,[JRST 1]
	PUSHJ P,WRCH
ACNV00:	PUSHJ P,RDCH		;FIND 'T' LINE
	CAIN T,"T
	 JRST ACNV01
ACNVNL:	PUSHJ P,RDCH		;FIND NEXT LINE
	CAIN T,12
	 JRST ACNV00
	JRST ACNVNL

ACNV01:	PUSHJ P,RDCH		;SKIP SPACE
	PUSHJ P,RDASS		;GET WORD COUNT
	LDB C,[101000,,A]	;HIGH BYTE OF WORD COUNT HAS HIGH 2 BITS OF LOAD ADDR
	ANDI A,377
	IDIVI A,3		;3 PDP11 WORDS PER PDP10 WORD
	MOVN B,A
	PUSHJ P,RDASS		;GET LOAD ADDRESS
	DPB C,[200200,,A]	;INSERT HIGH 2 BITS
	JUMPE B,ACNV69		;0 => START ADDR LINE => E.O.F.
	HRL A,B			;MAKE AOBJN POINTER
	MOVE Q,A		;INIT CHECKSUM
	MOVE H,A		;AOBJN PNTR
	PUSHJ P,WRCH
ACNV02:	PUSHJ P,RDASS		;GET LOW 16 BITS
	MOVE B,A
	PUSHJ P,RDASS		;GET MIDDLE 16 BITS
	DPB A,[202000,,B]
	PUSHJ P,RDASS		;GET HIGH 4 BITS
	DPB A,[400400,,B]
	MOVE A,B
	ROT Q,1
	ADD Q,A
	PUSHJ P,WRCH
	AOBJN H,ACNV02
	MOVE A,Q		;PUNCH CHECKSUM
	PUSHJ P,WRCH
	JRST ACNVNL		;AND GO DO NEXT LINE

ACNV69:	SKIPE A			;PUNCH START ADDR
	 HRLI A,(JUMPA)
	PUSHJ P,WRCH
	PUSHJ P,WRCH
	JRST DONE 

;SUBROUTINE TO READ AN ASCIIZED WORD AND RETURN 16 BINARY BITS IN A

RDASS:	MOVEI A,0
RDASS1:	PUSHJ P,RDCH
	CAIGE T,75
	 POPJ P,
	LSH A,6
	ANDI T,77
	ADD A,T
	JRST RDASS1

SUBTTL PALX BINARY ASCIIZER

PCNVRT:	MOVEI T,36.
	MOVEM T,INBS
PCNV1:	PUSHJ P,RDCH		;SEARCH FOR START OF BLOCK
	JUMPE T,PCNV1
	CAIE T,1
	 JRST [	MSG ALLEGED PALX BINARY FILE CONTAINS NON-ABSLDR BLOCK TYPE
		.VALUE ]
	PUSHJ P,RDCH		;SKIP RANDOM NULL BYTE
	PUSHJ P,RWORD		;GET BYTE COUNT
	TRNE A,1
	 JRST [	MSG BARF! KLDCP CAN'T LOAD ODD NUMBER OF BYTES IN A BLOCK
		.VALUE ]
	LSH A,-1		;CONVERT TO WORD COUNT
	MOVEI J,-3(A)		;DON'T COUNT BLOCK HEADER
	PUSHJ P,RWORD		;GET LOAD ADDRESS
	MOVE I,A
	JUMPE J,PCNVSA
	TRNE I,1
	 JRST [	MSG BARF! KLDCP CAN'T LOAD ON BYTE BOUNDARIES
		.VALUE ]
PCNV2:	PUSH P,J		;START NEW LINE
	CAILE J,29.
	 MOVEI J,29.
	SUBM J,(P)
	MOVNS (P)
	MOVEI H,"E
	PUSHJ P,11BEG
PCNV3:	PUSHJ P,RWORD
	MOVE B,A
	PUSHJ P,11WORD
	AOS I
	SOJG J,PCNV3		;MORE WORDS THIS LINE
	PUSHJ P,11END
	POP P,J
	JUMPN J,PCNV2		;MORE LINES THIS BLOCK
	PUSHJ P,RDCH		;GOBBLE CHECKSUM BYTE
	JRST PCNV1		;MORE BLOCKS THIS FILE

PCNVSA:	MOVEI H,"E		;WRITE TRANSFER LINE
	PUSHJ P,11BEG
	PUSHJ P,11END
	JRST DONE

RWORD:	PUSHJ P,RDCH
	MOVE A,T
	PUSHJ P,RDCH
	LSH T,8
	IOR A,T
	POPJ P,

VARIABLES
CONSTANTS

CONC PRINTX /HIGHEST USED=,\.,
/
END CNVRT
