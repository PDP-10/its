
TITLE	SERVER TELNET
;PASSWORD CRAP ADDED BY GLS 6/23/75
.MLLIT==1

IFNDEF PASSWD, PASSWD==0	;NON-ZERO => PASSWORD STUFF

A=1	;A,B,C,D,E ARE PER PROCESS.
B=2
C=3
D=4
E=5
TT=6
I=7
Q=10
J=11
R=12
W=13
H=14	;H CLOBBERED BY INTERRUPTS
P=15	;PDL MUST ALWAYS BE SET UP.
T=16	;T CLOBBERED BY INTERRUPTS.
U=17	;AFTER GOGO1, HOLDS IDX OF RUNNING PROCESS.

NTIC==1
NTOC==2
STIC==3
STOC==4
LSOC==5
DKIC==6
USIC==7

LOC	42
	JSR TSINT
LOC	100
USRMAI==10.		;SYSTEM DEEMED TOO CROWDED ABOVE THIS NUMBER
USRMML==13.	;SIMILAR, FOR ML MACHINE.

WINNRS:	237		;BOSTON AREA TIP FOR 10CPS DIALUP
	236		;BOSTON AREA TIP FOR 10CPS DIALUP
	250		;BOSTON AREA TIP FOR 10CPS DIALUP
	40		;WINNERS (?)
	106		;HOSTS ALLOWED TO LOG INTO CROUDED SYSTEM
			;DMG
	206		;AI
	306		;MATHLAB
	13		;STANFORD AI
	11		;HARVARD PDP10
	6		;MULTICS
	105		;BBN
	16
	116
	BLOCK 10
 		;ROOM FOR EXECUTION TIME AUGMENTATION
;OR DIMINISHING( 0 ENTRY MEANS END OF LIST)
LOSERS:	227	;USC-TIP
	BLOCK 10
LOSMSG:	ASCIZ /THE SYSTEM IS TOO BUSY RIGHT NOW.  SORRY ...
/		;MESSAGE PRINTED TO HOSTS BEFORE LOGGING THEM OFF
WINMSG:	ASCIZ /THE SYSTEM IS QUITE LOADED.  PLEASE MINIMIZE RESOURCE USAGE.
/		;MESSAGE PRINTED TO WINNING HOSTS WHEN SYSTEM IS CROUDED

PAT:
PATCH:	BLOCK 140

GO:	SETZM LOG
	.CLOSE 1,			;CLOSE DISK CHANNEL USED FOR LOADING
	.SUSET [.SMASK,,[200000,,400]]	;IOC AND REALT INTS.
GOL:	MOVE P,[-LPDL-1,,PDL-1]
	SETZM RTINTS			;REALT INTS NOT SET EVERY 1/4 SEC NOW.
	SETOM L				;NORMAL INTERRUPTS
	SETZM HASSLE			;ASSUME HE IS A GOOD GUY
	MOVE A,[600000,,[60.*60.]]
	.REALT A,			;(SET ONE IN 60 SEC TO GIVE UP)
	JFCL
GO1:	.OPEN LSOC,NET1
	JRST OPNFL
	MOVE A,[LSOC,,B]
	.RCHST A,
	ANDI TT,-1
	CAIE TT,2			;SKIP IF STATE IS "RFC IN TO LISTEN".
	 JRST GOODBY
	MOVEI H,0
	LDB T,[060300,,E]
	ADDI H,20(T)
	LSH H,6
	LDB T,[030300,,E]
	ADDI H,20(T)
	LSH H,6
	LDB T,[000300,,E]
	ADDI H,20(T)
	MOVSS H
	HRRI H,(SIXBIT /H00/)
	SKIPE LOG
	JRST LOGDIN
	.CALL LOGCAL
	AOJA H,.-1

;FALLS THROUGH ON SUCCESSFUL LOGIN.

;FALL THROUGH OR JRST HERE AFTER LOGGING IN.
LOGDIN:	SETOM LOG
	.OPEN STOC,[1,,(SIXBIT /STY/)]
	JSR LOGOUT
	.OPEN STIC,[12,,(SIXBIT /STY/)]
	JSR LOGOUT
	.NETAC LSOC,
	JSR LOGOUT
	.SUSET [.SMASK,,[200000,,400]]	;IOC AND REALT
	ADDI D,3	;FOR SOC + 3
	MOVEM D,NET2+2	;SET FOR SOC #
	MOVEM E,NET2+3	;SET FOR HOST #
	.OPEN NTIC,NET2
	JSR LOGOUT
	MOVE A,[NTIC,,B]
	.RCHST A,
	.IOT LSOC,C	;SEND SOC #
	ADDI C,1
	MOVEM C,NET3+1	;SET LOC SOC #
	SUBI D,1
	MOVEM D,NET3+2	;SET FOR SOC #
	MOVEM E,NET3+3	;SET FOR HOST #
	.CLOSE LSOC,
	.OPEN NTOC,NET3
	JSR LOGOUT
	SETZM LCHNTI
	SETZM SAVINT	;NO INPUT INTS RECEIVED YET.
	MOVEI T,[ACANR,,ACA]
	BLT T,ACA+1	;MAKE SURE NEITHER PROCESS STARTS OUT RUNNABLE.
	SETOM IDEFER
	.SUSET [.SDF2,,[0]]
	.SUSET [.SPICL,,[0]]

;NOW WAIT AT MOST 60. SEC FOR TELNET CONNECTIONS TO COMPLETE.
	MOVEI B,3
	MOVEM B,NTFLAG
	.SUSET [.SMSK2,,[1_NTIC+1_STIC]]
	MOVEI A,60.*30.	;MAX TOTAL TIME TO WAIT.
WAIT1:		MOVE B,[NTIC,,RCH]
	.RCHST B,
	HRRE C,RCH+4
	SKIPGE C
	JSR LOGOUT
	MOVEI B,2
	CAIE C,4
	ANDCAM B,NTFLAG
	MOVE B,[NTOC,,RCH]
	.RCHST B,
	HRRE C,RCH+4
	SKIPGE C
	JSR LOGOUT
	MOVEI B,1
	CAIE C,4
	ANDCAB B,NTFLAG
	JUMPE B,GOGO	;BOTH CONNECTIONS MADE, ALL OK.
WAIT:	.SUSET [.SPICL,,[-1]]	;LET INTS DISMISS TO WAIT1
	.SLEEP A,
	JUMPL A,WAIT1
	JSR LOGOUT

;COME WITH PI OFF WHEN TELNET CONNECTIONS COMPLETED.
GOGO:	MOVSI B,(SETZ)	;TELL INPUT INTS NOT TO GO TO STARTR.
	MOVEM B,NTFLAG
	SETZM RTINTS	;REALTIME INTS TURNED OFF
	.REALT B,	;TO PREVENT SCHEDULES FOR A WHILE.
	JFCL
	.SUSET [.SAPIR,,[200000,,]] ;AND DELETE ANY RT INT PENDING.
	.SUSET [.SDF2,,[1_NTIC+1_STIC]]
	SETZM IDEFER
	.SUSET [.SPICL,,[-1]]	;CATCH IOCERRS IN CASE USER GOES AWAY.
	.CALL SST
	JFCL
	JUMPL C,DEBM	;DECIDE WHETHER WE WANT THIS USER
	AOS D
	AOJE D,DOWN
	MOVEI A,USRMML
	CAMN B,[SIXBIT/AI/]
	 MOVEI A,USRMAI
	MOVEM A,USRMAX	;# OF USERS IT TAKES FOR CROWDED SYSTEM.
	MOVEI A,[ASCIZ /MIT MATHLAB PDP-10 /]
	CAMN B,[SIXBIT /AI/]
	MOVEI A,[ASCIZ /MIT A.I. LAB PDP-10 /]
	JSP E,TYPE
	PUSHJ P,VERTYP		;TYPE VERSION AT USER
	MOVE D,NUSERS
	CAMLE D,USRMAX
	JRST TOMANY
	MOVEI D,0
	LDB C,[1100,,NET3+3]
LOSCHK:	CAMN C,LOSERS(D)
	JRST TOMANY
	AOS D
	SKIPE LOSERS(D)
	JRST LOSCHK
GOGO3:	.OPEN DKIC,NETML	;TYPE SYS:NET MAIL AT HIM.
	JRST GOGO1
GOGO2:	MOVE C,ACANR	;READ INTO LOPB.
	.IOT DKIC,C
	SETZM (C)	;MAKE SURE NULL ENDS STRING.
	CAMN C,ACANR
	 JRST GOGO1	;NOTHING READ.
	MOVEI A,LOPB
	JSP E,TYPE
	JUMPGE C,GOGO2
	.CLOSE DKIC,
GOGO1:	.NETS NTOC,
IFE PASSWD,[
	SKIPN HASSLE	;MAKE HIM LOAD HIS OWN HACTRN
	.IOT STOC,[^Z]	;CAUSE A HACTRN TO BE LOADED.
	SETOB U,LASTRN	;SAY NO PROCESS WAS RUNNING YET.
	JRST SCHED	;SCHEDULE (TURNS OFF PI)
]		;END OF IFE PASSWD
IFN PASSWD,[
	SETOM PIPE
	SETZM LOGGED
	SETZB U,LASTRN	;SAY WE ARE NOW OUTPUT PROCESS
	JRST GOBBLE	;HACK FOR GOBBLING PASSWORDS
]		;END OF IFN PASSWD

VERTYP:	SETZM NTCBUF
	MOVE D,[NTCBUF,,NTCBUF+1]
	BLT D,NTCBUF+NTCBFL-1
	MOVE D,[440700,,NTCBUF]
	MOVE B,[.FNAM1]
	PUSHJ P,6PUT
	MOVEI A,".
	PUSHJ P,CHRPUT
	MOVE B,[.FNAM2]
	PUSHJ P,6PUT
	MOVEI A,15
	PUSHJ P,CHRPUT
	MOVEI A,12
	PUSHJ P,CHRPUT
	MOVEI A,NTCBUF
	JSP E,TYPE
	POPJ P,

6PUT:	MOVE C,[440600,,B]
6PUT1:	TLNN C,770000
	POPJ P,		;WE DID 6 OF THEM
	ILDB A,C
	JUMPE A,CPOPJ
	ADDI A,40
	PUSHJ P,CHRPUT
	JRST 6PUT1

CHRPUT:	IDPB A,D
	POPJ P,

IFN PASSWD,[
;INITIAL OUTPUT PROCESS
;GOBBLES PASSWORDS

GOBBLE:	SKIPN HASSLE		;MAYBE MAKE LOSER TYPE A ^Z FIRST
	 JRST GOBBL2
GOBBL1:	SKIPGE A,PIPE
	 JSP B,SCHEDJ
	SETOM PIPE
	CAIE A,^Z
	 JRST GOBBL1
GOBBL2:	MOVEI A,[ASCIZ \
YOUR LOGIN NAME: \]
	JSP E,TYPE
	JSP E,GOB1		;GOBBLE UNAME
	MOVEM D,UNAM
	JUMPE D,GOBBL2		;ZERO IS BAD UNAME
	HLR D,D
	AOJE D,GOBBL2		;LH -1 IS ALSO BAD
	HLLM C,UNAMBP
	SETZM UNAMSW
	CAIE A,^M
	 SETOM UNAMSW
	MOVEI A,[ASCIZ \PASSWORD: \]
	JSP E,TYPE
	JSP E,GOB0		;GOBBLE PASSWORD
;INSTALL CLEVER PASSWORD CHECKING HERE
	MOVEI A,[ASCIZ \PASSWORD ACCEPTED.  PLEASE TYPE ^Z.
\]
	JSP E,TYPE
	SETZM DDTUP
	SETOM LOGGED		;TELL INPUT PROC TO LOG LOSER IN
	JRST LOPL		;BECOME THE REAL OUTPUT PROCESS

;	JSP E,GOB1
;GOBBLES A UNAME OR PASSWORD
;RETURNS:	TERMINATING CHAR (CR OR ALTMODE) IN A
;		BYTE POINTER IN C
;		UNAME/PASSWORD IN D
;	JSP E,GOB0
;SIMILAR, BUT DOES NOT ECHO THE TYPE-IN
GOB0:	TLOA E,400000
GOB1:	TLZ E,400000
	MOVE C,[440600,,D]
	SETZ D,
GOB2:	SKIPGE A,PIPE		;GET AN INPUT CHAR
	 JSP B,SCHEDJ
	SETOM PIPE
	CAIN A,177
	 JRST GOB4		;RUBOUT
	CAIE A,33
	 CAIN A,^M
	  JRST GOB3		;CR OR ALTMODE
	CAIGE A,"!
	 JRST GOB2		;CONTROL CHAR OR SPACE - IGNORE
GOB3:	HRLI A,(A)		;SAVE COPY OF CHAR IN LH OF A
	CAMN A,[33,,33]
	 XORI A,33#^M		;ECHO ALTMODE AS CR
	LSH A,1
	MOVE B,[377777,,A]
	SKIPL E
	 .IOT NTOC,B		;ECHO CHARACTER
	LSH A,-23
	CAIE A,33
	 CAIN A,^M
	  JRST (E)		;ALTMODE OR CR TERMINATES
	CAIG A,137		;HACK LOWER CASE => UPPER CASE
	 SUBI A,40		;CONVERT TO SIXBIT
	TLNE C,770000
	 IDPB A,C
	JRST GOB2

GOB4:	JUMPL C,GOB2		;IGNORE RUBOUT IF NO CHARS
	LDB A,C			;GET LAST CHAR
	SETZ B,
	DPB B,C			;CLEAR OUT CHAR
	ADDI A,40
	LSH A,1
	MOVE C,[377777,,A]
	SKIPL E
	 .IOT NTOC,C		;ECHO RUBBED-OUT CHAR
	ADD C,[060000,,]	;BACK UP BYTE POINTER
	JRST GOB2

UNAM:	0		;UNAME FOR LOGGING IN LOSER
UNAMSW:	0		;ZERO => :LOGIN, NON-ZERO => U
UNAMBP:	440600,,UNAM	;POINTS TO LAST CHAR IN UNAM
]		;END OF IFN PASSWD

;THE OUTPUT PROCESS:
LOPL:	MOVE A,ACANR	;GET AOBJN -> BUFFER.
LOPIN:	.IOT STIC,A	.SEE PCINC
	CAMN A,ACANR
	 JSP B,SCHEDI	;BLOCK IF NOTHING TO READ, RESTART AT LOPIN ON INT.
IFN PASSWD,	SETOM DDTUP
	HRLOI B,-LOPB-1(A)
	EQVI B,LOPB	;AOBJN -> FILLED WDS OF BUFFER.
	.IOT NTOC,B	;OUTPUT THEM.
	LDB B,[410300,,A] ;HOW MANY CHARS IN UNFILLED WD?
	LDB C,LOPOT1(B)	;GET THOSE CHARS, RIGHT-JUST.
	LSH C,1	;POSITION AS IF IN ASCII PSEUDO BUT NOT 1ST CHARS IN WD
	SKIPE B,LOPOTB(B) ;THEN GET BLOCK MD PTR -> THOSE CHARS.
	 .IOT NTOC,B
	JRST LOPL

LOPOTB:	0
	0
	0
	677777,,C
	577777,,C
	477777,,C
	377777,,C
	0

LOPOT1:	0
	0
	0
	103400,,(A)
	172500,,(A)
	261600,,(A)
	350700,,(A)
	0

IFNDEF LOPBL, LOPBL==30
LOPB:	BLOCK LOPBL
	0	.SEE GOGO2


IFN PASSWD,[
SCHEDQ:	SETZ A,		;GUARANTEES PC WILL NOT BE RESET!
	JRST SCHED

SCHEDJ:	SETZ A,		;GUARANTEES PC WILL NOT BE RESET!
]		;END OF IFN PASSWD
SCHEDI:	.NETS NTOC,	;NO MORE OUTPUT FROM STY, MAKE SURE ALL
			;OUTPUT IS SENT OUT ON NET.

;JSP B,SCHED  FROM A PROCESS, TO BLOCK IT.
;IF PASSWD NON-ZERO, IS PRECEDED BY FLUSH INSTRUCTION
SCHED:	.SUSET [.SPICL,,[0]] ;NO INTS.
	MOVE T,INTBIT(U) ;THIS PROCESS SAYS IT NO LONGER
	SKIPL U
	 ANDCAM T,SAVINT ;HAS ANY INPUT TO HANDLE
	MOVE T,B	;MUSTN'T USE UNSAVED AC T TILL PI OFF.
IFN PASSWD,[
	SKIPL U
	 MOVE H,-2(T)	;FLUSH INSTR
]		;END OF IFN PASSWD

;COME FROM REAL-TIME CLOCK INT.
SCHED2:	SKIPGE LASTRN	;RUNNING NULL JOB?
	 JRST SCHED5	;YES, DON'T STORE ACS OR PC.
	MOVEM T,UPC(U)	;SAVE RUNNING PROCESS'S PC.
	ANDI T,-1
	CAMN T,PCINC(U)	;WAS PROCESS DOING INPUT IOT?
	 AOS UPC(U)	;YES, UNHANG IT.
	MOVEM A,ACA(U)	;STORE THIS PROCESS'S ACS.
	MOVEM B,ACB(U)
	MOVEM C,ACC(U)
	MOVEM D,ACD(U)
	MOVEM E,ACE(U)
IFN PASSWD,[
	JUMPE H,SCHED6
	LDB B,[270400,,H]	;SET UP FLUSH INSTR
	CAILE B,E
	 .VALUE			;BAD AC FIELD
	MOVE B,FLSACS(B)
	MOVEM B,FLSAC(U)
	MOVEI B,C
	DPB B,[270400,,H]
SCHED6:	MOVEM H,FLSINS(U)	;SAVE FLUSH INSTR (ZERO IF NONE)
]		;END OF IFN PASSWD

;NOW ALL INFO SAVED, ALL IS AS IF HAD BEEN RUNNING NULL JOB.
;ALLOW THE PENDING INPUT INTS TO HAPPEN -
SCHED5:	.SUSET [.RIFPI,,B]	;GET THE PENDING INTS,
	.SUSET [.SAIFP,,B]	;AND TURN THEM OFF.

;COME AFTER GETTING AN INT ON STIC OR NTIC. (INT BITS IN B)
INTSCH:	SKIPGE U,LASTRN	;IF HAD BEEN RUNNING NULL JOB,
	 SETZB U,LASTRN	;GIVE THE INPUT PROCESS PRIORITY.
	IORB B,SAVINT	;AND THE INTS WE GOT FOR PROCESSES THT WEREN'T RUN  WHEN WE GOT THEM
	AOSN IDEFER	;IF DEFER BITS NOT ALREADY SET, SET THEM.
	 .SUSET [.SDF2,,[1_STIC+1_NTIC]]
SCHED1:	XORI U,1	;1ST TRY THE PROCESS THAT WASN'T RUNNING.
	TDNE B,INTBIT(U) ;IF IT GOT AN INPUT INT, IT'S RUNNABLE.
	 JRST SCHEDX
IFN PASSWD,[
	SKIPN FLSINS(U)		;SKIP IF NON-ZERO FLUSH INSTR
	 JRST SCHED8
	MOVE C,@FLSAC(U)	;SET UP TO XCT THE FLSINS
	SETZ E,
	XCT FLSINS(U)
	 SETO E,
	MOVEM C,@FLSAC(U)	;SAVE THE AC BACK
	JUMPE E,SCHEDX		;SCHEDULE IFF FLSINS SKIPPED
SCHED8:
]		;END OF IFN PASSWD
	CAME U,LASTRN	;BOTH BLOCKED?
	 JRST SCHED1	;NO, TRY THE ONE THAT WAS RUNNING.
	SETOM LASTRN	;YES, RUN NULL JOB.
	SETOM IDEFER	;YES, UNDEFER INTS
	.SUSET [.SDF2,,[0]]
	MOVSI A,400000	;TURN OFF CLOCK INTS. IF THEY'RE ON.
	SKIPE RTINTS
	.REALT A,
	 JFCL
	SETZM RTINTS	;SAY THEY'RE OFF.
	.SUSET [.SPICL,,[-1]]
	MOVEI A,377777
	.SLEEP A,
	JRST .-2	;NEXT INT WILL SCEDULE AGAIN.

;COME HERE TO RUN PROCESS W/ IDX IN U.
SCHEDX:	MOVEM U,LASTRN	;SAY THIS USER WAS LAST RUN.
	MOVE B,[600000,,[15.]]
	SKIPN RTINTS	;TURN ON 1/4 SEC CLOCK IF NOT ON.
	.REALT B,
	 JFCL
	SETOM RTINTS
	MOVE A,ACA(U)
	MOVE B,ACB(U)	;RELOAD PROCESS ACS
	MOVE C,ACC(U)
	MOVE D,ACD(U)
	MOVE E,ACE(U)
	MOVE T,UPC(U)
	CAMN A,ACANR(U)	;IF NO INPUT, RESTART
	 HRR T,PCRST(U)
	.DISMI T

;OUTPUT PROCESS (STY TO NET) IS PROCESS 0,
;INPUT PROCESS (NET TO STY) IS PROCESS 1.
;THESE TABLES INDEXED BY PROCESS #.
PCINC:	LOPIN ? LIPIN	;ADDR OF INPUT IOT.
PCRST:	LOPIN ? LIPBLK	;PLACE TO RESTART PROCESS IF INT'D AND NO INPUT READ.
ACANR:	-LOPBL,,LOPB ? -1	;WHAT A HOLDS IF NO INPUT READ.
INTBIT:	1_STIC ? 1_NTIC	;INPUT INT FOR PROCESS.
ACA:	0 ? 0
ACB:	0 ? 0
ACC:	0 ? 0
ACD:	0 ? 0
ACE:	0 ? 0
UPC:	LOPL ? LIPL
IFN PASSWD,[
FLSINS:	0 ? 0		;FLUSH INSTRUCTION
FLSAC:	0 ? 0		;SOME ELEMENT OF FLSACS
]		;END OF IFN PASSWD

LASTRN:	0	;LAST PROCESS SCHEDULED.
RTINTS:	0	;-1 IFF 1/4 SEC CLOCK SET UP.

FLSACS:	0		;TABLE OF ACS POINTERS FOR AC
	ACA(U)		; REFERENCED BY FLSINS
	ACB(U)
	ACC(U)
	ACD(U)
	ACE(U)

;INPUT PROCESS:
LIPL:	SETO A,		;NO INPUT READ.
LIPIN:	.IOT NTIC,A
	JUMPL A,LIPBLK	;PC WAS INCR'D BY SCHED, NOTHING READ.
	SKIPGE LCHNTI	;IF LAST CHAR WAS CR AND THIS IS LF,
	CAIE A,^J
	 JRST LIP2
	JRST LIP3	;IGNORE IT.

LIP2:
IFN PASSWD,[
	SKIPG LOGGED	;SKIP IF LOSER LOGGED IN BY NOW
	 JRST LIP2A
LIP2X:
]		;END OF IFN PASSWD
	TRZN A,200	;OKAY TO SEND LOSER'S CHARS ON THROUGH
	 .IOT STOC,A
LIP3:	SETZM LCHNTI	;REMEMBER WHETHER THIS CHAR CR
	CAIN A,^M
	 SETOM LCHNTI
LIPBLK:	MOVE B,[NTIC,,RCH]
	.RCHST B,
	HRRE B,RCH+4
	JUMPL B,DETACH
	CAIE B,10	;PROCESS HAS INPUT?
	CAIN B,11
	 JRST LIPIN	;YES, HANDLE IT.
	CAIE B,5	;S IT STILL CONNECTED?
	 JSR LOGOUT	;NO, GIVE UP.
	SETO A,		;BECOME UNRUNNABLE AND SCHEDULE.
	JSP B,SCHED
	.VALUE		;(PC SHOULD BE RESET TO LIPBLK)

IFN PASSWD,[
LIP2A:	SKIPL LOGGED	;SKIP IF MUST NOW LOG IN LOSER
	 JRST LIP5
	.IOT STOC,[^Z]	;FEED THROUGH A ^Z TO LOAD HACTRN
	SKIPN DDTUP	;WAIT UNTIL OUTPUT PROC TELLS US
	 JSP B,SCHEDQ	; DDT HAS STARTED ITS SPIEL
	SKIPE UNAMSW	;WILL FEED THROUGH EITHER
	 JRST LIP2B	; ":LOGIN FOO<CR>" OR "1'FOOU"
	JUMPN C,LIP2B
IRPC X,,[:LOGIN ]
	.IOT STOC,["X]
TERMIN
	JRST LIP2C
LIP2B:
IRPC X,,[1']
	.IOT STOC,["X]
TERMIN
LIP2C:	MOVE D,[440600,,UNAM]
LIP2K:	ILDB B,D
	ADDI B,40
	.IOT STOC,B
	CAME D,UNAMBP
	 JRST LIP2K
	SKIPE UNAMSW
	 JRST LIP2D
	.IOT STOC,[^M]
	JRST LIP2F
LIP2D:
IRPC X,,[U]
	.IOT STOC,["X]
TERMIN
LIP2F:	HRRZS LOGGED
	JRST LIP2X

LIP5:	SKIPL PIPE		;GIVE CHAR TO OUTPUT PROC
	 JSP B,SCHEDQ		; FORUNAME OR PASSWORD
	TRZN A,200
	 HRRZM A,PIPE
	JRST LIP3

DDTUP:	0	;SET NON-ZERO BY OUTPUT PROC WHEN CHARS GOBBLED FROM STY
PIPE:	-1	;NON-NEG => CHAR PRESENT FOR OUTPUT PROC TO GOBBLE
LOGGED:	0	;ZERO => PASS CHARS TO OUTPUT PROC VIA PIPE
		;NEG => PASSWORD OKAY, LOG LOSER IN AND SET LOGGED POS
		;POS => PASS CHARS THROUGH STY - LOSER IS WINNING
]		;END OF IFN PASSWD

;ROUTINES TO DETACH

DEFINE GETLOC,SYM
	MOVSI A,@SYM
	.GETLOC A,
	TERMIN

DEFINE GETSYM,SYM
	MOVE A,[SQUOZE 0,SYM]
	JSP B,EVAL
	MOVEM A,SYM
	TERMIN

EVAL:	.EVAL A,
	JSR DETDIE
	HRLI A,U
	JRST (B)

DETACH:	MOVSI A,(SETZ)
	.REALT A,
	JFCL
	.SUSET [.SPICL,,[0]]	;NO MORE INTERRUPTS
	.CLOSE USIC,
	.CLOSE NTIC,
	.CLOSE NTOC,
	.CALL [	SETZ
		SIXBIT /TTYGET/
		1000,,STIC
		2000,,A
		2000,,B
		SETZM C]
	 JFCL
	HRRES C		;USER INDEX OF GUY
	SKIPGE C
	JSR DETDIE	;NO TTY WITH TREE

IRP SYM,,[L,SUPPRO,UNAME,JNAME]
	GETSYM SYM
	TERMIN

	HRRZS U,L
	IMUL U,C	;SYSTEM STYLE USER INDEX
FINDTP:	GETLOC SUPPRO
	JUMPL ATTOP
	MOVEM U
	JRST FINDTP

;FOUND TOP LEVEL

ATTOP:	GETLOC UNAME
	CAMN [-1]
	JSR DETDIE		;DON'T DETACH NON-LOGGED USER
	MOVEM DUNAME
	GETLOC JNAME
	MOVEM DJNAME
	.OPEN USIC,UOBLK
	JSR DETDIE
	.CALL [	SETZ
		SIXBIT /DETACH/
		SETZI USIC]
	JSR DETDIE
	.CLOSE STIC,
	.CLOSE STOC,
	.SUSET [.SMSK2,,[1_USIC]]
	.SUSET [.SPICL,,[-1]]
	MOVEI A,5*60.*30.	;SLEEP 5 MINUTES
	.SLEEP A,

;HERE TO ELIMNATE WITH EXTREME PREDJUDICE (SIC)

	MOVE A,[USIC,,RCH]
	.RCHST A,
	.OPEN USIC,RCH
	JFCL
GOODBY:	.LOGOUT
	.VALUE
	JSR DETDIE

DETDIE:	0
	JRST LOGO1
TOMANY:	MOVEI A,0		;MORE THAN JOBMAX JOBS ALREADY LOGGED IN
	LDB B,[1100,,NET3+3]		;GET FOREIGN HOST NUMBER
TOMAN1:	CAMN B,WINNRS(A)		;FIND IT IN WINNING HOST LIST
	JRST WINNER		;FOUND IT
	SKIPE WINNRS(A)
	AOJA A,TOMAN1
	MOVEI A,LOSMSG		;LOSING HOST, AND SYSTEM  TOO CROUDED..FLUSH POLITELY
	JSP E,TYPE		;TELL LOSER HE'S LEAVING
	SETOM HASSLE
	JRST GOGO3

WINNER:	MOVEI A,WINMSG		;TELL WINNER SYSTEM IS CROUDED
	JSP E,TYPE
	JRST GOGO3

;CHAR IN C
NTYO:	HRROI H,C
	LSH C,35
	IOR C,[ASCIC//_-7&<-2>]
	.IOT NTOC,H
CPOPJ:	POPJ P,

DOWN:	SKIPA A,[ASCIZ /ITS NOT IN OPERATION
/]
DEBM:	MOVEI A,[ASCIZ /ITS BEING DEBUGGED
/]
	JSP E,TYPE
	JRST GOODBY

;OUTPUT ASCIZ OR ASCIC STRING <- ADDR IN A.
TYPE:	HRLI A,440700
	MOVE H,A
	SETZ R,
TYPE1:	ILDB C,A
	JUMPE C,TYPE2
	CAIE C,^C
	AOJA R,TYPE1
TYPE2:	IDIVI R,5	;# WDS, # CHARS EXTRA.
	MOVNS R
	HRLI H,(R)	;AOBJN -> FULL WDS.
	.IOT NTOC,H
	MOVNI W,-7(W)
	LDB C,LOPOT1(W)
	LSH C,1
	SKIPE W,LOPOTB(W)
	 .IOT NTOC,W
	JRST (E)

TSINT:	0		;INT LEVEL CLOBBERS AC T.
	0
	SKIPL L
	.DISMISS [GOODBY]
	SKIPL T,TSINT
	 JRST TSFW	;FIRST WORD INT
	SKIPL NTFLAG
	 JRST STARTR	;GOGO NOT YET REACHED.
	SKIPL LASTRN
	 .VALUE		;INPUT INT. NOT IN NULL JOB?
	MOVE B,T	;NULL JOB RUNNING SO CAN CLOBBER B.
IFN PASSWD,	SETZ H,		;NULL FLSINS
	JRST INTSCH	;SCHEDULE INTERRUPTED PROCESS.

STARTR:	IORM T,SAVINT	;REMEMBER THE INTS FOR SCHEDULING.
	JRST WAIT1	;CHECK AGAIN WHETHER BOTH CONNECTIONS COMPLETE.

TSFW:	SKIPL NTFLAG	;60 SEC TIMEOUT BEFORE GOGO REACHED?
	JSR LOGOUT
	TDNE T,[#<200000,,>]
	 JSR LOGOUT	;NOT REAL TIME INT.
	MOVE T,TSINT+1	;GET PC FOR SCHED.
IFN PASSWD,	SETZ H,		;NULL FLSINS
	JRST SCHED2

LOGOUT:	0
LOGO1:	.SUSET [.SMASK,,[0]]
	.SUSET [.SMSK2,,[0]]
	MOVSI A,(SETZ)
	.REALT A,
	JFCL
	.SUSET [.SPIRQ,,[0]]
	.SUSET [.SIFPI,,[0]]
	.SUSET [.SPICL,,[-1]]
	.CLOSE LSOC,
	.CLOSE NTIC,
	.CLOSE NTOC,
	.CLOSE STIC,
	.CLOSE STOC,
	.CLOSE USIC,
	JRST GOL

OPNFL:	.STATUS LSOC,A
	LDB B,[220600,,A]
	CAIE B,13	;SKIP IF SOCKET 1 BUSY
	JRST GOODBY
	MOVEI A,30.
	.SLEEP A,
	JRST GO1

LPDL==10
PDL:	BLOCK LPDL

NET1:	40065,,(SIXBIT /NET/)
	1
	-1
	-1

NET2:	50,,(SIXBIT /NET/)
	-1
	-1
	-1

NET3:	3,,(SIXBIT /NET/)
	-1
	-1
	-1

NETML:	2,,(SIXBIT /SYS/)
	SIXBIT /NET/
	SIXBIT /MAIL/

UOBLK:	10,,(SIXBIT /USR/)
DUNAME:	0
DJNAME:	0

L:	0
SUPPRO:	0
UNAME:	0
JNAME:	0
NUSERS:	0
RCH:	BLOCK 10

LOGCAL:	SETZ
	SIXBIT /LOGIN/
	H
	SETZ [0]

SST:	SETZ
	SIXBIT /SSTATU/
	2000,,D		;> 0 => TIME TILL DOWN,  -1 => UP,  -2 => DOWN
	2000,,C		;SYSDBG
	2000,,NUSERS	;NUMBER OF USERS ON SYSTEM
	2000,,B
	2000,,B
	SETZM B		;RETURNS IN B WHICH SYSTEM WE ARE USING

SAVINT:	0	;INPUT INTS THAT WE GOT BEFORE WE COULD SCHEDULE THEM.
IDEFER:	-1	;NONNEG => STIC, NTIC INTS DEFERRED.
NTFLAG:	3	;0 => CONNECTIONS COMPLETE
LOG:	0
HASSLE:	0	;HASSLE THIS POOR LOSER ABOUT LOGGING IN
LCHNTI:	0	;-1 => LAST CHAR INPUT OVER NET WAS CR
USRMAX:	0	;MAX # USERS WANTED = USRMML OR USRMAI.

NTCBFL==10
NTCBUF:	BLOCK NTCBFL

END	GO
