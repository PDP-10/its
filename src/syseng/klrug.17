RUGLEN==10600	;ESTIMATED LENGTH OF RUG
.=100000-RUGLEN	;PUT IN HIGH CORE ON A 16K MACHINE
		;NOTE:  SOME PLACES IN RUG LOSE IF CORE > 16K.  MUMBLE GROAN.
;
;RUG SYMBOLIC DEBUGGER
;
R0=	%0	; REGISTER
R1=	%1	;  NAMING
R2=	%2	;   CONVENTIONS
R3=	%3
R4=	%4
R5=	%5
R6=	%6
R7=	%7
SP=	%6
PC=	%7
ST=	177776		;STATUS REGISTER
;
;
O.BPT=	10		;NUMBER OF BREAKPOINTS
O.BKP=	O.BPT+O.BPT-2	;NUMBER OF BREAKPOINTS-1 MULT. BY 2
O.TVEC=	14		;TRT VECTOR LOCATION
O.STM=	340		;PRIORITY MASK - STATUS REGISTER
O.TBT=	20		;T-BIT MASK - STATUS REGISTER
TRT=	000003		;TRT INSTRUCTION
;
;
O.RDB=	177562	;R DATA BUFFER
O.RCSR=	177560	;R C/SR
O.TDB=	177566	;T DATA BUFFER
O.TCSR=	177564	;T C/SR

;THE FOLLOWING IS NEEDED BECAUSE KLDCP "ASCIIZED" FORMAT
;ONLY LOADS WORDS, NOT BYTES.

.MACRO .EVEN
.IIF NE .&1, .BYTE 0
.ENDM

;
;
; INITIALIZE ODT
;  USE O.ODT FOR A NORMAL ENTRY
;  USE O.ODT+2 TO RESTART ODT - WIPING OUT ALL BREAKPOINTS
;  USE O.ODT+4 TO RE-ENTER (I.E. - FAKE A BREAKPOINT)
;
O.ODT:	BR	O.STRT		;NORMAL ENTRY
	BR	O.RST		;RESTART
O.ENTR:	MOV	ST,O.UST	;RE-ENTER -- SAVE STATUS
	MOV	O.TVEC+2,ST	;SET UP LOCAL STATUS
	MOV	PC,O.UPC	;FAKE THE PC
	MOVB	#-1,O.P		;DISALLOW PROCEED
	JMP	O.BK1
;
O.STRT:	MOV	#O.UR0,SP	;SET UP STACK
	MOV	SP,O.USP	;FAKE THE SAVED STACK
	MOV	#ADHIAD,4	;FIND HIGHEST CORE LOC
	MOV	O.STM,6
	MOV	R7,R0	;HERE IS AS GOOD A START AS ANY
	TST	(R0)+	;WILL TRAP ON ILLEGAL ADDRESS
	BR	.-2
ADHIAD:	SUB	#4,R0	;TO HERE. R0-2 IS OFFENDING ADDR
	MOV	R0,HIGHAD	;R0-4 IS LAST LEGAL (EVEN) ADDRESS
	ADD	#4,R6	;RESET STACK FROM INTRPT
	CLR	4	;ZAP TRAP SO WE DON'T SUDDENLY APPEAR HERE
	BR	O.RST1
O.RST:	JSR	0,O.SVR		;SAVE REGISTERS
	JSR	5,O.REM		;REMOVE ALL BREAKPOINTS
	MOVB	O.PRI,R4	;GET ODT PRIORITY
	RORB	R4		;SHIFT
	RORB	R4		; INTO
	RORB	R4		;  POSITION
	MOVB	R4,ST		;STORE IN STATUS
O.RST1:	MOVB	#-1,O.P		;DISALLOW PROCEED
	MOV	#O.STM,O.TVEC+2	;STATUS WORD TO TRT VECTOR+2
	MOV	#O.BRK,O.TVEC	;PC TO TRT VECTOR
	CLR	R3
	JMP	DELTB		;CLEAR BREAKPOINT TABLES
O.ERRR:	JMP	O.ERR

;
; PROCESS CARRIAGE RETURN
;
O.CRET:	JSR	PC,O.CLSE	;CLOSE LOCATION
O.DCDA:	JMP	O.DCD		;RETURN TO DECODER
;
; PROCESS <LF>, OPEN NEXT WORD
;
O.OLD:	SUB	LENTH,O.DOT	;PROCESSED A < RE-OPEN DOT
	SUB	O.BW,O.DOT
	BR	O.OLD1
O.OP1:	MOV	O.CAD,O.DOT	;SET DOT TO CAD IF <LF>
O.OLD1:	TST	O.BW	
O.ERR2:	BEQ	O.ERR		;ERROR IF NOTHING IS OPEN
	JSR	PC,O.CLSE	;CLOSE PRESENT CELL
	ADD	O.BW,O.DOT	;GENERATE NEW ADDRESS
	TST	INSTMD
	BEQ	O.OP2
	ADD	LENTH,O.DOT
O.OP2:	MOV	O.DOT,O.CAD	;RESET CAD
O.OP2A:	JSR	5,O.CRLF	;<CR><LF>
	MOV	O.CAD,R0	;NUMBER TO TYPE
	JSR	5,SYMBAD	; TYPE OUT ADDRESS
	JMP	O.WRD1		;GO PROCESS IT
;
;PROCESS : DEFINE LABEL
; NOTE THAT THIS COMMAND NOT INTERPRETED THROUGH
; THE REGULAR COMMAND SYMBOL AND JUMP TABLES, BUT BY
; A SPECIAL CHECK AT ININ2
;
O.COLO:	MOV	O.CAD,O.CVAL
	BR	O.ECL3
;
;PROCESS ! DEFINE A SYMBOL
;
O.EXCL:	JSR 5,O.GETS
O.ECL3:	TST R2
	BGE O.ERR
	JSR 5,O.SYLL
	BR O.ECL1
	BR O.ECL2
O.ECL1:	SUB #6,O.SYME	;USYMB TABLE 2WDS RAD50 PLUS ONE OF VALUE
	MOV O.SYL,(R1)
	MOV O.SYL+2,2(R1)
	MOV	O.FLGS,R4
	CMP	#1,R3	;SEE IF TIME FOR NEW FLAG WORD
	BNE	O.ECL2		;NO. 
	CLR	(R4)
	CLR	-(R4)		;YES, INITIALIZE IT
O.ECL2:	MOV	O.FLGS,R4
	MOV 	O.CVAL,4(R1)
	TSTB	.REGF		;CHECK REGISTER FLAG
	BEQ	O.ECL5
	BIS	R3,(R4)
	BR	O.ECL4
O.ECL5:	BIC	R3,(R4)
O.ECL4:	BIC	R3,-(R4)
	BR 	O.SCAN

;
; PROCESS ^, OPEN PREVIOUS WORD
;
O.BACK:	TST	O.BW		;  ^ RECEIVED
	BEQ	O.ERR2		;ERROR IF NOTHING OPEN
	JSR	PC,O.CLSE
	SUB	O.BW,O.DOT	;GENERATE NEW ADDRESS
	BR	O.OP2		;GO DO THE REST


;PROCESS FOO^K, HALF KILLING DEFINED SYMBOL

HKILL:	MOV	O.FLGS,R4
	BIS	R3,-(R4)
	BR	O.DCD

;
; COMMAND DECODER - ODT11X
;
;  ALL REGISTERS MAY BE USED (R0-R5),
;   NO REGISTERS (R0-R5) WILL BE CONSIDERED SAFE
;
O.UERR:	MOV #'U,R0
	JSR 5,O.FTYP
O.ERR:	MOV	#'?,R0		;  ? TO BE TYPED
	JSR	5,O.FTYP	; OUTPUT ?
O.DCD:	CLR	O.BW		;CLOSE ALL
	JSR	5,O.CRLS	;TYPE  <CR><LF>*
O.DCD2:	CLR	R3		;R3 IS A SAVE REGISTER FOR R2
	CLR	R5		;R5 IS A SAVE REGISTER FOR R4
O.DCD1:	CLR	O.CVAL
O.DCD3:	CLRB	O.NUMF
	CLR	ININ
	CLR	SSFLAG
	MOVB	PCONMD,CONMD	;SET TEMP CONSMODE FLAG TO PERM
O.SCAN:	JSR	5,GETS	;GET A SYLABLE
	BR	ININ1
O.CLGL:	MOVB O.NUMF,R2
	MOV O.CVAL,R4
	CLRB O.ALTF
LGL:	MOV #O.NALC,R1
O.LGL1:	CMPB	R0,O.LGCH(R1)	;DO THE CODES MATCH?
	BEQ	O.LGL2		;JUMP IF YES
	INC	R1		; SET INDEX FOR NEXT SEARCH
	CMP	R1,#O.CLGT	;IS THE SEARCH DONE?
	BHIS	O.ERR		;    OOPS!
	BR	O.LGL1		;RE-LOOP
O.LGL2:	ASL	R1		;MULTIPLY BY TWO
	JMP	@O.LGDR(R1)	;GO TO PROPER ROUTINE
O.ALT:	JSR 5,O.GET
	MOV	R2,R3
	MOV	R4,R5
	INCB O.ALTF
	CLR R1
	CLR R4
	CLR R2
	BR O.LGL1

ININ1:	JSR	5,ININST
	BR	O.CLGL
O.DCDC:	BR O.DCD	;SIGH


STICKY:	JSR	5,O.GET
	CLRB	CONMD
	CMP	#'C,R0
	BEQ	STNUMB
	CMP	#'S,R0
	BEQ	STSYMB
	CMP	#'I,R0
	BEQ	STINST
	CMP	#'A,R0
	BEQ	ABSMD
	CMP	#'R,R0
	BEQ	RELMD
ERROR:	JMP	O.ERR
STSYMB:	MOVB	#1,SYMMD
SHERE:	CLRB	INSTMD
	JMP	GOSYM
STNUMB:	CLRB	SYMMD
	CLRB	INSTMD
	JMP	GONUM
STINST:	MOVB	#1,INSTMD
	CLRB	SYMMD
	JMP	GOINST

ABSMD:	INCB	PCONMD
	BR	O.DCD
RELMD:	CLRB	PCONMD
	BR	O.DCD
TABSMD:	INCB	CONMD
	BR	JWRD6
TRELMD:	CLRB	CONMD
JWRD6:	BR	O.WRD6

O.EQUL:	TSTB	.REGF
	BEQ	O.EQU1
	MOV	#'%,R0
	JSR	5,O.FTYPE
O.EQU1:	MOV O.CVAL,R0
	JSR 5,O.CADV
	CLRB	O.NUMF
	BR O.DCD3

O.RDEQ:	MOV	#'/,R0
	JSR	R5,O.FTYP	;YOU ARE ABOUT TO SEE
	MOVB	#40,BLFLG	;THE CURRENT VALUE IN RADIX-50
	MOV	O.CVAL,AINST	;HERE'S THE LITTLE DEVIL
	JSR	R5,TYPE50
O.RDRT:	MOV	#'/,R0
	JSR	R5,O.FTYP
	BR	GOSYM1
O.ASEQ:	MOV	#'/,R0	;IF THIS LOOKS SIMILAR TO
	JSR	R5,O.FTYP	;THE ABOVE, IT'S BECAUSE IT IS,
	MOV	O.CVAL,R0	;ONLY IN ASCII
	SWAB	R0
	JSR	R5,O.FTYP
	SWAB	R0
	JSR	R5,O.FTYP
	BR	O.RDRT

;SINGLE STEP MODE PROCESSOR
SSTEP:	TST	R3
	BGT	SSTP1
	MOV	#1,R5	;ASSUME SINGLE STEP
SSTP1:	TST	R5
	BEQ	ERROR	;ZERO STEPS?
	CLR	R3
	MOVB	O.P,PP
	MOV	R5,COUNT
	MOV	#1,SSFLAG
	JMP	O.PROC


;
; SEMI-COLON PROCESSOR
;
O.SEMI:	MOV	R2,R3	;A SEMI-COLON HAS BEEN RECEIVED
	MOV	R4,R5	;NUMERIC FLAG TO R3, CONTENTS TO R5
	JMP	O.DCD1		;GO BACK FOR MORE
;
;
;
; PROCESS / AND \ - OPEN WORD OR BYTE
;
O.WRD:	CMP	#2,O.BW		;SEE IF WORD ALREADY OPEN
	BNE	O.WRD4		; NO.
	TST	R2		;USE LAST SYMBOL OUTPUTTED, IF NO USER VALUE
	BEQ	O.TCLS
O.WRD4:	MOV	#2,O.BW		;OPEN WORD
	BR	O.WB1
O.BYT1:	CLR R2
O.BYT:	MOV	#1,O.BW		;OPEN BYTE
O.WB1:	TST	R2		;GET VALUE IF R2 IS NON-ZERO
	BEQ	O.WRD1		;SKIP OTHERWISE
	TSTB	.REGF		;USER REGISTERS ARE REALLY
	BEQ	O.WRD5		;INDEX TO USER
	ASL	R4		;REGISTER SAVE STACK
	BMI	ERROR
	ADD	#O.UR0,R4	;CHECK FOR VALID REG NUM DONE IN GETS
	CMP	#O.URE,R4	;REGISTERS MUST BE ONE OF THE REGISTERS
	BLE	O.ERR1	;WHICH PUTS IT BETWEEN O.UR0 AND O.URE
O.WRD5:	MOV	R4,O.DOT	;PUT VALUE IN DOT
	MOV	R4,O.CAD	;    ALSO IN CAD
O.WRD1:	MOV	#O.ERR,4	;ILLEGAL ADDR WILL NOW TRAP TO ERR
	CMP	#1,O.BW		;CHECK BYTE MODE
	BEQ	O.WRD2		;JUMP IF BYTE
	MOV	O.CAD,R4
	ASR	R4		;MOVE ONE BIT TO CARRY
	BCS	O.BYT1		;JUMP IF ODD ADDRESS
	MOV	@O.CAD,R0	;GET CONTENTS OF WORD
	BR	O.WRD3
O.WRD2:	MOVB	@O.CAD,R0	;GET CONTENTS OF BYTE
	MOV	R0,CNTNTS
	MOV	R0,O.CVAL
	CLR	LENTH
	BR	GONUM
O.WRD3:	MOV	R0,CNTNTS
	MOV	R0,NEXTAD
	MOV	R0,O.CVAL
	CLR	4	; REMOVE ILLEGAL ADDR TRAP TO AVOID CONFUSION
O.WRD6:	TSTB	INSTMD
	BNE	GOINST
	TSTB	SYMMD
	BNE	GOSYM
GONUM:	MOV	O.CVAL,R0
	JSR	5,O.CAV1
	BR	GOSYM1
GOSYM:	MOV	O.CVAL,R0
	CLRB	CONMD
	JSR	5,SYMBOL	; PRINT AS SYMBOL EVEN IF IN $$A MODE
GOSYM1:	JMP	O.DCD3
GOINST:	MOV	O.CVAL,R0
	JSR	5,INST
	BR	GOSYM1
	BR	GONUM	;DID NOT FIND ONE


;
O.BKAR:	CMP	#2,O.BW	; OPEN "SOURCE LOCATION"
	BNE	O.ERR1	;OF (HOPEFULLY) CURRENTLY OPEN WORD
	MOV	LASTAD,NEXTAD	;FALL THROUGH TO O.TCLS

; / HANDLER WHEN WORD OPEN - OPEN LAST THING TYPED
;
O.TCLS:	JSR	PC,O.CLSE	; CLOSE CURRENT CELL
	MOV	NEXTAD,R2	; AND OPEN LAST VALUE TYPED
	ASR	R2		; FIRST CHECKING FOR ODD ADDRESS
	BCS	O.ERR1
	ASL	R2
	MOV	R2,O.CAD	; NOW MAKE IT CURRENT ADDRESS
	JMP	O.OP2A

NEXTAD:	0
LASTAD:	0

INSTMD:	.BYTE	1
SYMMD:	.BYTE	0
CONMD:	.BYTE	0
PCONMD:	.BYTE	0
BLFLG:	.BYTE	0
	.EVEN

;
; B HANDLER - SET AND REMOVE BREAKPOINTS
;
O.BKPT:	MOV	#O.TRTC,R0
	TST	R3
	BEQ	O.ERR1	;FOR NOW THAT COMMAND IS MEANINGLESS
	ASR	R5		;GET ONE BIT TO CARRY
	BCS	O.ERR1		;BADNESS IF ODD ADDRESS
	ASL	R5		;RESTORE ONE BIT
	ADD	#O.ADR1,R4
O.SET:	CMP	R0,@R4		;IS THIS CELL FREE?
	BEQ	O.SET1		;JUMP IF YES
	CMP	R4,#O.BKP+O.ADR1	;ARE WE AT THE END OF OUR ROPE
	BHIS	O.ERR1		;YES, THERE IS NOTHING FREE
	TST	(R4)+		;INCREMENT BY TWO
	BR	O.SET
O.SET1:	CMP	R4,#O.BKP+O.ADR1
	BHI	O.ERR1		;ERROR IF TOO LARGE
	MOV	R5,@R4		;SET BREAKPOINT
O.DCDB:	JMP	O.DCDC		;RETURN


; D HANDLER DELETE BKPT AT 1500 BY 1500$D,$D REMOVES ALL
DELTB:	MOV	#O.TRTC,R0
	CLR	R4
DBLOOP:	CMP	R4,#O.BKP
	BHI	O.DCDB	;DONE
	TST	R3	;IF R3 ZERO, DELETE ALL
	BEQ	NOTST
	CMP	R5,O.ADR1(R4)
	BNE	DB1	;ONLY REMOVE BKPT AT THAT ADDRESS
NOTST:	MOV	R0,O.ADR1(R4)
	MOV	#TRT,O.UIN(R4)	;RESET CONTENTS OF TABLE
	CLR	O.CT(R4)	;CLEAR COUNT
DB1:	TST	(R4)+
	BR	DBLOOP
O.ERR1:	JMP	O.ERR

;
; SEARCHES - $MSK   HAS THE MASK
;		$MSK+2 HAS THE FWA
;		$MSK+4 HAS THE LWA
;
O.EFF:	INC	R1		;SET EFFECTIVE SEARCH
	BR	O.WDS
O.WSCH:	CLR	R1		;SET WORD SEARCH
O.WDS:	TST	R3		;CHECK FOR OBJECT FOUND
	BEQ	O.ERR1		;ERROR IF NO OBJECT
	MOV	#2,O.BW		;SET WORD MODE
	MOV	O.MSK+2,R2	;SET ORIGIN
	MOV	O.MSK,R4	;SET MASK
	COM	R4
O.WDS2:	CMP	R2,O.MSK+4	; IS THE SEARCH ALL DONE?
	BHI	O.DCDB		;  YES
	MOV	@R2,R0		; GET OBJECT
	TST	R1		;NO
	BNE	O.EFF1		;BRANCH IF EFFECTIVE SEARCH
	MOV	R0,-(SP)
	MOV	R5,R3		;EXCLUSIVE OR
	BIC	R5,R0		; IS DONE
	BIC	(SP)+,R3		;  IN A VERY
	BIS	R0,R3		;    FANCY MANNER HERE
	BIC	R4,R3		;AND RESULT WITH MASK
O.WDS3:	BNE	O.WDS4		;RE-LOOP IF NO MATCH
	MOV	R4,-(SP)	;REGISTERS R2,R4, AND R5 ARE SAFE
	JSR	5,O.CRLF
	MOV	R2,R0		;GET READY TO TYPE
	MOV	R0,-(SP)
	MOV	R2,-(SP)
	JSR	5,SYMBAD	;  TYPE ADDRESS
	MOV	(SP)+,R2
	MOV	(SP)+,R0
	MOV	@R2,R0		;GET CONTENTS
	JSR	5,O.CADV	;TYPE CONTENTS
	MOV	(SP)+,R4	; RESTORE R4
O.WDS4:	TSTB	O.RCSR	;HAS THE PERSON TYPED SOMETHING,
	BMI	O.ERR1	;INDICATING SEARCH SHOULD STOP?
	TST	(R2)+		;INCREMENT TO NEXT CELL AND
	BR	O.WDS2		;    RETURN
O.EFF1:	CMP	R0,R5		; IS (X)=K?
	BEQ	O.WDS3		;TYPE IF EQUAL
	MOV	R0,R3		;(X) TO R3
	ADD	R2,R3		;(X)+X
	INC	R3
	INC	R3		;(X)+X+2
	CMP	R3,R5		;IS (X)+X+2=K?
	BEQ	O.WDS3		;BRANCH IF EQUAL
	BIC	#177400,R0	;WIPE OUT EXTRANEOUS BITS
	MOVB	R0,R0
	CCC
	ASL	R0		;MULTIPLY BY TWO
	INC	R0
	INC	R0
	ADD	R2,R0		;ADD PC
	CMP	R0,R5		;IS THE RESULT A PROPER REL. BRANCH?
	BR	O.WDS3




;
; PROCESS G - GO
;
O.GO:	TST	R3		;WAS K; TYPED?
	BEQ	O.ERR1		; TYPE ?<CR,LF> IF NOT
	MOVB	#-1,O.P		;CLEAR PROCEED
	ASR	R5		;CHECK LOW ORDER BIT
	BCS	O.ERR1		;ERROR IF ODD NUMBER
	ASL	R5		;RESTORE WORD
	MOV	R5,O.UPC	;SET UP NEW PC
	MOVB	#O.STM,ST		;SET HIGH PRIORITY
	JSR	5,O.RSTT	;RESTORE TELETYPE
O.TBIT:	TST	SSFLAG	;SINGLE STEP MODE?
	BEQ	TBIT
	DEC	COUNT
	BNE	O.PR1
	JMP	SSDN
TBIT:	CLRB	O.T		;CLEAR
	BIC	#O.TBT,O.UST	;    BOTH T-BIT FLAGS
	JSR	5,O.RSB		;RESTORE BREAKPOINTS
O.GO2:	JSR	0,O.RSR		;RESTORE REGISTERS
	MOV	O.UST,-(SP)	;    AND STATUS
	MOV	O.UPC,-(SP)	;    AND PC
	RTT			;11/40 HARDWARE MISFEATURE
;
; PROCESS P - PROCEED 
;   ONLY ALLOWED AFTER A BREAKPOINT
;
O.PROC:	MOVB	O.P,R0
	TSTB	R0		;CHECK LEGALITY OF PROCEED
	BLT	O.ERR1		;NOT LEGAL
	TST	R2		;CHECK FOR ILLEGAL COUNT
	BNE	O.ERR1		;JUMP IF ILLEGAL
	MOVB	#-1,O.P		;CLEAR PROCEED FLAG
	TST	R3		;WAS COUNT SPECIFIED?
	BEQ	O.PR1		;NO
	MOV	R5,O.CT(R0)	;YES, PUT AWAY COUNT
O.PR1:	MOVB	#O.STM,ST	;FORCE HIGH PRIORITY
	JSR	5,O.RSTT	;RESTORE TTY
O.C1:	MOVB	#O.STM,ST	;SET HIGH PRIORITY
	MOVB	#1,O.T
	BIS	#O.TBT,O.UST	;SET T-BIT
	BR	O.GO2

;
; BREAKPOINT HANDLER
; A TRT BREAKPOINT CAUSES O.BRK TO BE ENTERED,
; WHICH SAVES VARIOUS ODDS AND ENDS, FINDS OUT
; IF THE BREAKPOINT WAS LEGAL, AND GIVES CONTROL
; TO THE COMMAND DECODER.
;
O.BRK:	MOV	(SP)+,O.UPC	;PRIORITY IS 7 UPON ENTRY
	MOV	(SP)+,O.UST	;SAVE STATUS AND PC
O.BK1:	JSR	0,O.SVR		;SAVE VARIOUS REGISTERS
	TSTB	O.T		;CHECK FOR T-BIT SET
	BNE	O.TBIT		;JUMP IF SET
	JSR	5,O.REM		;REMOVE BREAKPOINTS
	TSTB	O.PRI		;CHECK IF PRIORITY
	BPL	O.BK2		; IS AS SAME AS USER PGM
	MOVB	O.UST,R5	;PICK UP USER UST IF SO
	BR	O.BK3
O.BK2:	MOVB	O.PRI,R5	;OTHERWISE PICK UP ACTUAL PRIORITY
	CCC			;CLEAR CARRY
	RORB	R5		;SHIFT LOW ORDER BITS
	RORB	R5		;  INTO
	RORB	R5		;    HIGH ORDER
	RORB	R5		;      POSITION
O.BK3:	MOVB	R5,ST		;PUT THE STATUS AWAY WHERE IT BELONGS
	MOV	O.UPC,R5	;GET PC, IT POINTS TO THE TRT
	TST	-(R5)
	MOV	R5,O.UPC
	MOV	#O.BKP,R4	;GET A COUNTER
O.B1:	CMP	R5,O.ADR1(R4)	;COMPARE WITH LIST
	BEQ	O.B2		;JUMP IF FOUND
	DEC	R4
	DEC	R4
	BGE	O.B1		;RE-LOOP UNTIL FOUND
	JSR	5,O.SVTT	;SAVE TELETYPE STATUS
	JSR	5,O.CRLF
	MOV	#O.BD,R4	;ERROR, NOTHING FOUND
	MOV	#O.BD+1,R3
	MOVB	#8,O.P		;ALLOW PROCEED FROM "BE"
BB:	JSR	5,O.TYPE	;OUTPUT "BE" FOR BAD ENTRY
	BIC	#O.TBT,O.UST	;CLEAR OUT ANY POSSIBLE FAKE T-BIT
	BR	O.B3		; OR CONTINUE
O.B2:	DEC	O.CT(R4)
	BGT	O.C1		;JUMP IF REPEAT
	MOV	#1,O.CT(R4)	;RESET COUNT TO 1
	MOVB	R4,O.P		;ALLOW PROCEED
	JSR	5,O.SVTT	;SAVE TELETYPE STATUS, R4 IS SAFE
	MOV	#'B,R0
	JSR	5,O.FTYP	;TYPE "B"
	MOVB	O.P,R0
	ADD	#140,R0		;CONVERT BREAKPOINT NUMBER TO ASCII
	ASR	R0
	JSR	5,O.FTYP
	MOV	#2,O.BW		; SET WORD MODE
	MOVB	O.P,R4
	MOV	O.ADR1(R4),R5	;GET ADDRESS OF BREAK
O.B3:	MOV	#';,R0
	JSR	5,O.FTYP	; TYPE ;
	MOV	R5,R0		;ADDRESS OF BREAK
	JSR	5,SYMBOL	;TYPE ADDRESS
	JMP	O.DCD		;GO TO DECODER
SSDN:	MOV	#BUFF,R4
	MOV	R4,R3
	MOV	#'S,(R3)+
	MOV	#'S,(R3)
	MOVB	PP,O.P
	CLR	SSFLAG
	MOV	O.UPC,%5
	BR	BB

;
; SAVE REGISTERS R0-R6
;   INTERNAL STACK
;
O.SVR:	MOV	(SP)+,O.XXX	;PICK REGISTER FROM STACK AND SAVE
	MOV	SP,O.USP	;SAVE USER STACK ADDRESS
	MOV	#O.USP,SP	;SET TO INTERNAL STACK
	MOV	R5,-(SP)	;SAVE
	MOV	R4,-(SP)	; REGISTERS
	MOV	R3,-(SP)	;1
	MOV	R2,-(SP)	; THRU
	MOV	R1,-(SP)	;     5
	MOV	O.XXX,-(SP)	;PUT SAVED REGISTER ON STACK
	TST	-(SP)
	RTS	R0
;
; RESTORE REGISTERS R0-R6
;
O.RSR:	TST	(SP)+		;POP THE EXTRA CELL
	MOV	(SP)+,O.XXX	;GET R0 FROM STACK
	MOV	(SP)+,R1	;RESTORE
	MOV	(SP)+,R2	; REGISTERS
	MOV	(SP)+,R3	;  1
	MOV	(SP)+,R4	;  THRU
	MOV	(SP)+,R5	;    5
	MOV	O.USP,SP	;RESTORE USER STACK
	MOV	O.XXX,-(SP)	;PUT R0 ON USER STACK
	RTS	R0
;
; RESTORE BREAKPOINTS 0-7
;
O.RSB:	MOV	#O.BKP,R4	;RESTORE ALL BREAKPOINTS
O.RS1:	MOV	@O.ADR1(R4),O.UIN(R4)	;SAVE CONTENTS
	MOV	O.TRTC,@O.ADR1(R4)	;REPLACE WITH TRAP
	DEC	R4
	DEC	R4
	BGE	O.RS1		;RE-LOOP UNTIL DONE
	RTS	R5		;  THEN QUIT
;
; SAVE TELETYPE STATUS
;
O.SVTT:	MOVB	O.RCSR,O.CSR1	;SAVE R C/SR
	MOVB	O.TCSR,O.CSR2	;SAVE T C/SR
	CLRB	O.RCSR		;CLEAR ENABLE AND MAINTENANCE
	CLRB	O.TCSR		;  BITS IN BOTH C/SR
	RTS	R5

;
; RESTORE TELETYPE STATUS
;
O.RSTT:	TST	SSFLAG
	BEQ	RSTT
	CMP	#1,COUNT
	BNE	RSTT1
RSTT:	JSR	5,O.CRLF
RSTT1:	TSTB	O.TCSR		;WAIT READY
	BPL	.-4		;  ON PRINTER
	BIT	#4000,O.RCSR	;CHECK BUSY FLAG
	BEQ	O.RSE1		;SKIP READY LOOP IF NOT BUSY
	TSTB	O.RCSR		;WAIT READY
	BPL	.-4		;    ON READER
O.RSE1:	MOVB	O.CSR1,O.RCSR	;RESTORE
	MOVB	O.CSR2,O.TCSR	;  THE STATUS REGISTERS
	RTS	R5
;
; REMOVE BREAKPOINTS 0-7
;   IN THE OPPOSITE ORDER OF SETTING
;
O.REM:	CLR	R4		;REMOVE ALL BREAKPOINTS
O.R1:	MOV	O.UIN(R4),@O.ADR1(R4)	;CLEAR BREAKPOINT
	INC	R4
	INC	R4
	CMP	R4,#O.BKP
	BLE	O.R1		;RE-LOOP UNTIL DONE
	RTS	R5		;THEN QUIT
;
; TYPE OUT CONTENTS OF WORD OR BYTE
; WITH ONE TRAILING AND 3 LEADING SPACES
; WORD IS IN R0
;
O.CAV1:	MOV R0,-(SP)
	JSR 5,O.TYPS	;TYPE 3 SPACES
	MOV (SP)+,R0
O.CADV:	MOV	R2,-(SP)	;SAVE R2
	MOV	#O.BUF+6,R4	;BUFFER START ADDRESS
	MOV	#'0,-(SP)		;CONSTANT ASCII 0
	CMP	#1,O.BW		;CHECK BYTE MODE
	BNE	O.SPC
	BIC	#177400,R0	;GET RID OF JUNK
O.SPC:	MOV	R0,R2		; GET
	BIC	#177770,R2	;    OCTAL CHARACTER
	ADD	@SP,R2		;CONVERT TO ASCII
	MOVB	R2,-(R4)	;STORE IN BUFFER
	ASR	R0		;SHIFT THIS MESS
	ASR	R0		; RIGHT
	ASR	R0		;   THREE WHOLE PLACES
	BIC #160000,R0
	BNE O.SPC
	TST (SP)+
O.V3:	MOV	#O.BUF+6,R3	;LWA
	JSR	5,O.TYPE	;TYPE WHOLE STRING OF CHARACTERS
	MOV	(SP)+,R2	;RESTORE R2
	RTS	R5
;SYMBOL TABLE-- ASCII, THEN VALUE
;TO CHANGE MASK AND JUMP HAVE 0 BYTE INSTD OF 1ST ASCII WRD
;FOLLOWED BY NEW MASK AND JUMP LOC
;IF FOLLOWED BY ZERO RIGHT BYTE, NEST SYMB IS 2 WDS LONG
;IN CHANGE BLOCK, RIGHT BYTE CAN BE OFFSET FOR JUMPING
;WHEN USER TYPES ASCII

INST:	CMP	#2,O.BW
	BGT	INOGO
	MOV	#INSTS,R1	;GET LOC OF START
	CLR	LENTH
	CLR	WDS2
INLOOP:	MOV	R0,R2	;TO SAVE VALUE
	TSTB	1(R1)	;IS IT A FLAG
	BNE	NOCHNG
	TSTB	(R1)	;2 WD ASCII OR CHANGE FLAG?
	BNE	CHANGE
	TST	-(R1)	;ONE LESS LOC
	MOV	#1,WDS2
	BR NEXTIN
CHANGE:	MOV	2(R1),R3	;NEW MASK
	MOV	4(R1),R4	;NEW JUMP LOC
	TST	(R1)+
	BR	NEXTIN
NOCHNG:	BIC	R3,R2	;AND IT
	CMP	2(R1),R2	;CHECK VALUE
	BEQ	JMPLOC
	TST	WDS2	;TWO WORD ASCII?
	BEQ	NEXTIN
	TST	(R1)+	;EXTRA LOC LOONG
	CLR	WDS2
NEXTIN:	ADD	#4,R1
	CMP	R1,#INSTE	;DONE?
	BLE	INLOOP
INOGO:	TST	(R5)+
	RTS	5
JMPLOC:	JMP	(R4)
;RETURNS WITH VALUE IN R4
;EXPECTS INPUT IN O.SYL AND O.SYL+2

ININST:	MOV	#INSTS,R1
	CLR	.LENTH
	CLR	WDS2
INLOP1:	TSTB	1(R1)
	BNE	NOCH1
	TSTB	(R1)	;2 WD ASCII OR CHANGE
	BNE	CHANG1
	MOV	#1,WDS2
	TST	-(%1)	;SUBTRACT 2 FROM R1
	BR	NXTIN2
CHANG1:	MOV	4(R1),R3
	ADD	(R1),R3	;RIGHT HALF OF FLAG IS OFFSET
	TST	(%1)+	;ADD 2
	BR	NXTIN1
NOCH1:	CMP	O.SYL,(R1)
	BNE	NXTIN1
	TST	WDS2
	BEQ	WDONE
	MOV	2(R1),R4
	CMP	O.SYL+2,4(R1)
	BEQ	FOUND
	BR	NXTIN1
WDONE:	MOV	2(R1),R4
	TST	O.SYL+2
	BEQ	FOUND
	CMP	O.SYL+2,#6200
	BNE	NXTIN1
	ADD	#100000,R4
	BR	FOUND
NXTIN1:	TST	WDS2
	BEQ	NXTIN2
	CLR	WDS2
	TST	(R1)+
NXTIN2:	ADD	#4,R1
	CMP	R1,#INSTE
	BLE	INLOP1
	BR	ERRR
FOUND:	JMP	(R3)
ARITH:	JSR	5,BPOSS
ARITH1:	MOV	SAVE,R0
	ROL	R0
	ROL	R0
	SWAB	R0	;GET SOURCE BITS IN RIGHT PLACE
	BIC	#177700,R0
	JSR	5,SSORDD
DEST1:	MOV	#BUFF,R4
	MOV	R4,R3
	MOV	#',,(R3)+
	MOV	#' ,(R3)
	JSR	5,O.TYPE
DEST:	MOV	SAVE,R0
	MOV	NEXTAD,LASTAD
	BIC	#177700,R0
	JSR	5,SSORDD
	JMP	BACK

ADDSUB:	JSR	5,TYPIN
	BR	ARITH1
INOP2:	MOV	R4,VAL
	JSR	5,INSSDD
	MOVB	VAL,R4
	CLRB	VAL
JSR1:	SWAB	R4
	ROR	R4
	ROR	R4
	ADD	R4,VAL
ENDIN:	JSR	5,INSSDD
BACK2:	MOV	#1,ININ
	MOV	VAL,O.CVAL
	RTS	5

SINGOP:	JSR	5,BPOSS
	BR	DEST
INOP1:	MOV	R4,VAL
	BR	ENDIN

.RTS:	JSR	5,TYPIN
	BIC	#177770,R0
	ADD	#60,R0
	JSR	5,O.FTYP
	JMP	BACK
INRTS:	MOV	R4,VAL
RTS2:	JSR	5,GETS
	BR	ERRR
	TST	R2
	BEQ	ERRR
	CMP	#7,R4
	BLT	ERRR
RTS1:	ADD	R4,VAL
BACK3:	BR	BACK2

ERRR:	MOV	#O.ERR,R5
	RTS	5
.JSR:	JSR	5,TYPIN
	ROL	R0
	ROL	R0
	SWAB	R0
	BIC	#177770,R0
	ADD	#60,R0
	JSR	5,O.FTYP
	JMP	DEST1
INJSR:	MOV	R4,VAL
JSR2:	JSR	5,GETS
	BR	ERRR
	TST	R2
	BEQ	ERRR
	CMP	#7,R4
	BLT	ERRR
	BR	JSR1

TYPIN:	CLR	AINST+2
	TST	WDS2
	BEQ	ONEWD
	CLR	WDS2
	MOV	4(R1),AINST+2
ONEWD:	MOV	(R1),AINST
	MOV	R0,SAVE
	JSR	5,TYPE50
	JSR	5,O.TYPS
	MOV	SAVE,R0
	RTS	5

.BRCHS:	JSR	5,TYPIN
	MOVB	SAVE,R0
	INC	R0
	ASL	R0
	ADD	O.CAD,R0
	JSR	5,SYMBOL
	JMP	BACK

INBRCH:	MOV	R4,-(SP)
	JSR	5,GETS
	BR	ERRR
INNUM:	SUB	O.CAD,R4
	ASR	R4
	DEC	R4
	TST	R4
	BLT	.NEG
	CMP	R4,#177
	BGT ERRR
.NEG:	CMP	#-177,R4
	BGT	ERRR	;ABSOLUTE VALUE OF DISPL < 400
	BIC	#177400,R4
	MOV	(SP)+,R3
	ADD	R3,R4
	MOV	R4,VAL
	BR	BACK3

.CNTRL:	JSR	5,TYPIN
	RTS	5

.TRAP:	BR	.CNTRL
INCNTR:	MOV	R4,VAL
BCK3:	BR	BACK3
BACK:	JSR	5,O.TYPS
	RTS	5
SAVE:	0

BPOSS:	CLR	AINST+2	;ONLY 3 CHARS LONG
	TST	R0	;BYTE COMMAND?
	BGE	NOB
	MOV	#6200,AINST+2	;.RAD50 /B  /
NOB:	MOV	(R1),AINST
	MOV	R0,SAVE
	TST	WDS2
	BEQ	BPOS1
	MOV	4(R1),AINST+2
BPOS1:	JSR	5,TYPE50
	JSR	5,O.TYPS
	RTS	5
CNDCOD:	CLR	AINST+2
	MOV	(R1),AINST
	MOV	R0,R2
	ROR	R2
	BCC	NOCCC
	ADD	#3,AINST	;.RAD50 /  C/
NOCCC:	ROR	R2
	BCC	NOCCV
	ADD	#104600,AINST+2	;.RAD50 /V  /
NOCCV:	ROR	R2
	BCC	NOCCZ
	ADD	#2020,AINST+2	;.RAD50 / Z /
NOCCZ:	ROR	R2
	BCC	NOCCN
	ADD	#16,AINST+2	;.RAD50 /  N/
NOCCN:	BR	BPOS1
AINST:	0
	0
ININ:	0	;FLAG THAT INST  TYPED

INCCDD:	MOV	R4,VAL
INCD:	JSR 5,O.GET
	MOV	#1,R2
	MOV	#TBL,R3
CDLOOP:	TSTB	(R3)	;SIGNALS END OF TABLE
	BEQ	BCK3	;DONE, GOT BREAK CHAR
	CMPB	R0,(R3)+
	BNE	CDLP1
	BIS	R2,VAL
	ASL	R2
	BR	INCD
CDLP1:	ASL	R2
	BR	CDLOOP

TBL:	.BYTE 'C
	.BYTE 'V
	.BYTE 'Z
	.BYTE 'N
WDS2:	0	;LEFT BYTE NEVER ZERO
;THIS ROUTINE CONVERTS RAD50 TO ASCII
;NUMB GIVEN AND RETURNED IN AC0

FIFASC:	TST	R0
	BNE	FIFNO
	MOVB	BLFLG,R0
	BR	NUTHNG
FIFNO:	CMP	#33,R0
	BLT	NUMB
	BEQ	DOLR
LETR:	ADD	#56,R0	;57+11+11=101
NUMB:	ADD	#11,R0	;PERIOD AND NUMBERS ARE +22
DOLR:	ADD	#11,R0
NUTHNG:	RTS	5


;THIS ROUTINE TAKES THREE CHARS IN AC1
;RETURNS 3 ASCII, FIRST 2 IN AC1 AND LAST IN AC0

UNPACK:	MOV	#3100,R3
	JSR	5,SUBLOP
	JSR	5,FIFASC
	MOV	R0,R2
	MOV	#50,R3
	JSR	5,SUBLOP
	JSR	5,FIFASC
	SWAB	R0
	ADD	R0,R2
	MOV	R1,R0
	JSR	5,FIFASC
	MOV	R2,R1
	RTS	5

SUBLOP:	MOV	#-1,R0
SUBLP1:	INC	R0
	SUB	R3,R1
	BCC	SUBLP1
	ADD	R3,R1
	RTS	5

;
; GENERAL CHARACTER INPUT ROUTINE -- ODT11X
; CHARACTER INPUT GOES TO R0
;
O.GET:	TSTB	O.RCSR		;WAIT FOR
	BPL	.-4		;  INPUT FROM KBD
	MOVB	O.RDB,R0	;GET CHARACTER - STRIP OFF PARITY
	BIC	#177600,R0
	BEQ	O.GET	;IGNORE NULLS
	CMPB #175,R0
	BNE O.GET1
	MOV #33,R0
O.GET1:	CMPB	#15,R0
	BEQ	O.GET2
	CMPB #12,R0
	BEQ O.GET2
	JSR	5,O.FTYP	;ECHO CHARACTER
O.GET2:	RTS	R5
;
; GENERAL CHARACTER OUTPUT ROUTINE - ODT11X
;  ADDRESS OF FIRST BYTE IN R4,
;  ADDRESS OF LAST BYTE IN R3, (R3)>(R4)
;
O.TYPE:	CMP	R3,R4		;CHECK FOR COMPLETION
	BLO	O.TYP1		; EXIT WHEN DONE
	MOVB	(R4)+,R0	;GET A CHARACTER
	TST	R0
	BEQ	O.TYPE	;DON'T BOTHER IF NULL CHAR
	JSR	5,O.FTYP	;TYPE ONE CHARACTER
	BR	O.TYPE		;LOOP UNTIL DONE
;TYPE 3 SPACES
O.TYPS:	MOV #40,R0
	JSR 5,O.FTYP
	JSR 5,O.FTYP
;FALL INTO O.FTYP FOR THE THIRD SPACE
;
; TYPE ONLY ONE CHARACTER (CONTAINED IN R0)
;
O.FTYP:	TSTB	O.TCSR
	BPL	.-4
	CMPB	#15,R0
	BNE	O.TYP3
	BR	O.TYP2
O.TYP3:	CMPB	#'	,R0
	BEQ	O.TYPS
	CMPB #33,R0
	BNE O.TYP5
	MOV #'$,O.TDB
	RTS R5
O.TYP5:	CMPB	#12,R0
	BEQ	O.TYP2
	CMPB	#40,R0
	BLE	O.TYP2
	MOV	#'^,O.TDB
	BIS	#100,R0
	JSR	5,O.FTYP
	BIC	#100,R0
	RTS	R5
O.TYP2:	MOV	R0,O.TDB
O.TYP1:	RTS	R5
TYPE50:	MOV	AINST,R1
	JSR	5,UNPACK
	MOV	R1,BUFF
	MOVB	R0,BUFF+2
	MOV	AINST+2,R1
	CLRB	BLFLG
	JSR	5,UNPACK
	MOVB	R1,BUFF+3
	SWAB	R1
	MOVB	R1,BUFF+4
	MOVB	R0,BUFF+5
	MOV	#BUFF,R4
	MOV	#BUFF+5,R3
	JSR	5,O.TYPE
	RTS	5
;THIS ROUTINE TAKES 6 BITS IN AC0 AND FILLS BUFF
;WITH WHAT TO TYPE AND TYPES IT

SSORDD:	MOV	R0,R2
	MOV	#BUFF,R4
	MOV	R4,R3
	BIC	#177770,R0
	SUB	R0,R2
	CMP	R0,#7
	BEQ	PCREG
REGST:	ADD	#60,R0	;NOW IT HAS THE ASCII OF WHICH REG
	MOV	R0,ATFLG
	TST	R2
	BEQ	MREG
	CMP	R2,#20
	BEQ	MAUIN
	BLT	MREGDF
	CMP	R2,#40
	BEQ	MAUDC
	BLT	MAUIND
	CMP	R2,#60
	BEQ	MINDX
	BLT	MAUDCD
MINDEF:	MOVB	#'@,R0
	JSR	5,O.FTYP
MINDX:	ADD	#2,LENTH
	MOV	O.CAD,R1
	ADD	LENTH,R1
	MOV	(R1),R0
	JSR	5,O.CADV
	MOV	#BUFF,R3
	MOV	R3,R4
MREGDF:	MOVB	#'(,(R3)+
	MOVB	#'%,(R3)+
	MOVB	ATFLG,(R3)+
	MOVB	#'),(R3)
	BR	TYPESS
MAUIN:	MOVB	#'(,(R3)+
	MOVB	#'%,(R3)+
	MOVB	ATFLG,(R3)+
	MOVB	#'),(R3)+
	MOVB	#'+,(R3)+
	BR	TYPESS
MREG:	MOVB	#'%,(R3)+
	MOVB	ATFLG,(R3)
	BR	TYPESS
MAUDC:	MOVB	#'-,(R3)+
	BR	MREGDF
MAUIND:	MOVB	#'@,(R3)+
	BR	MAUIN
MAUDCD:	MOVB	#'@,(R3)+
	BR	MAUDC

TYPESS:	JSR	5,O.TYPE
	RTS	5
BUFF:	0
	0
	0
	0
	0
PCREG:	CMP	R2,#20
	BLT	REGST
	CMP	R2,#30
	BLT	MIMMD
	BEQ	MABSL
	CMP	R2,#60
	BLT	REGST
	BEQ	MREL
MRELDF:	MOVB	#'@,R0
	JSR	5,O.FTYP
MREL:	ADD	#2,LENTH
	MOV	O.CAD,R1
	ADD	LENTH,R1
	MOV	(R1),R0
	ADD	R1,R0
	ADD	#2,R0
	JSR	5,SYMBOL
	RTS	5
MABSL:	MOVB	#'@,(R3)+
MIMMD:	MOVB	#'#,(R3)+
	CLRB	(R3)	;SO RANDOM CRUFT NOT TYPED
	JSR	5,O.TYPE
	ADD	#2,LENTH
	MOV	O.CAD,R1
	ADD	LENTH,R1
	MOV	(R1),R0
	JSR	5,SYMBOL
	RTS	5
;NEED SPACE TO TERMINATE COMMAND
;ATFLG LEFT BYTE 0 IF @ RECEIVED
;RIGHT BYTE 0 IF NO + OR - RECEIVED

ATFLG:	0
INSSDD:	JSR	5,GETS
	BR	ERR
	MOV	#400,ATFLG	;DEZERO LEFT BYTE
	CMP	#'@,R0
	BNE	NOAT
	CLR	ATFLG
	ADD	#10,VAL
	JSR	5,GETS
	BR	ERR
NOAT:	TST	R2
	BGT	NUMER
	CMP	#'#,R0
	BEQ	.NUM
	CMP	#'(,R0
	BNE	ERR
	TSTB	.NEGFL
	BEQ	NOMNUS
	ADD	#30,VAL
	INC	ATFLG
NOMNUS:	ADD	#10,VAL
NMNUS1:	JSR	5,GETS
	BR	ERR
	TST	R2
	BEQ	ERR
	CMP	#7,R4
	BLT	ERR
	ADD	R4,VAL
	CMP	#'),R0
	BNE	ERR
	JSR	5,O.GETS
	CMP	#'+,R0
	BNE	NOPLUS
	INC	ATFLG
	ADD	#10,VAL
	JSR	5,O.GETS
NOPLUS:	TST	ATFLG
	BNE	OK
	ADD	#50,VAL
	ADD	#2,.LENTH
	MOV	#VAL,%3
	ADD	.LENTH,R3
	CLR	(R3)
OK:	BR	RETRN
ERR:	MOV	#O.ERR,R5
	RTS	5

NUMER:	TSTB	.REGF
	BEQ	.NOREG
	ADD	R4,VAL
	BR	RETRN
.NOREG:	ADD	#2,.LENTH
	ADD	#60,VAL
	MOV	#VAL,R3
	ADD	.LENTH,R3
	CMP	#'(,R0
	BNE	JNUM
	MOV	R4,(R3)
	INC	ATFLG	;WON'T ADD MORE TO VAL LATER
	BR	NMNUS1
JNUM:	MOV	O.CAD,R1
	ADD	.LENTH,R1
	SUB	R1,R4
	SUB	#2,R4	;MAY BE ODD LOC SO NO TST
	MOV	R4,(R3)
	ADD	#7,VAL
	BR	RETRN
.NUM:	JSR	5,GETS
	BR	ERR
	TST	R2
	BGT	.NUM1
	CMP	#'@,R0
	BNE	ERR
	ADD	#10,VAL
	BR	.NUM
.NUM1:	ADD	#27,VAL
	MOV	#VAL,R3
	ADD	#2,.LENTH
	ADD	.LENTH,R3
	MOV	R4,(R3)
	RTS	5

VAL:	0
	0
	0
.LENTH:	0
RETRN:	RTS	5
SYMBAD:	CMP	#O.UR0,R0	;PRINT ADDRESS/ ROUTINE
	BGT	SYMBD1	; IF ADDRESS IN USER REG STACK
	CMP	#O.URE,R0	;THEN PRINT APPROPRIATE REG NAME
	BLE	SYMBD1
	SUB	#O.UR0,R0	;TRANSFORM TO REGISTER NUMBER
	ASR	R0
	INCB	.REGF	;AND FLAG. FLAG CLEARED NEXT INPUT REQEST
SYMBD1:	JSR	R5,SYMBOL
	MOV	#'\,R0	;BYTE MODE?
	CMP	#2,O.BW
	BGT	SYMBD2	;BRANCH IF BYTE MODE
	MOV	#'/,R0	;WORD MODE
SYMBD2:	JSR	R5,O.FTYP
	RTS	R5

;# IS IN R0
SYMBOL:	MOV	R0,NEXTAD
	TSTB	CONMD
	BEQ	SYMBL2
	JMP	O.CADV
SYMBL2:	CLR	AINST
	CLR	AINST+2
	CLR	R2
	MOV	O.SYMS,R1
	CLR	R3
SYMLOP:	ASL	R3
	BNE	SYMBL1
	TST	-(R1)
	MOV	R1,R4	;R4 CONTAINS ADDRSS
	TST	-(R1)
	INC	R3
SYMBL1:	SUB	#6,R1
	MOV	NEXTAD,R0	;VALUE TRYING TO PRINT TO R0
	CMP	R1,O.SYME
	BLT	SYMLPE
	SUB	4(R1),R0	;R0 := VALUE - SYMBOL
	BCS	SYMLOP		;BRANCH IF SYMBOL HIGHER THAN VALUE
	CMP	R0,#1000
	BGE	SYMLOP		;BRANCH IF VALUE GROSSLY HIGHER THAN SYMBOL
	CMP	R2,4(R1)	;FINDING LARGEST SYMBOL NOT > #
	BHI	SYMLOP
	BIT	R3,-2(R4)
	BNE	SYMLOP	;HALF KILLED
	TSTB	.REGF	;SYMBOL'S REG FLAG MUST BE SAME AS VALUE'S
	BNE	SYMBL3
	BIT	R3,(R4)
	BNE	SYMLOP
	BR	SYMBL4
SYMBL3:	BIT	R3,(R4)
	BEQ	SYMLOP
SYMBL4:	MOV	4(R1),R2	;REPLACE OLD LARGEST
	MOV	(R1),AINST
	MOV	2(R1),AINST+2
	BR	SYMLOP

SYMLPE:	SUB	R2,R0	;WANT TO TYPE FOO + NUMB
	MOV	R0,-(SP)	;SAVE R0
	TST	R2	;IF ZERO NO NO SYMBOL FOUND
	BEQ	SYMPE1
	JSR	5,TYPE50
	TST	(SP)
	BNE	SYP
	TST	(SP)+
	RTS	5
SYP:	MOV	#'+,R0
	JSR	5,O.FTYP
SYMPE1:	MOV	(SP)+,R0
	JSR	5,O.CADV
	RTS	5

;
; CLOSE WORD OR BYTE AND EXIT,
; UPON ENTERING, R2 HAS NUMERIC FLAG, R4 HAS CONTENTS
;
O.CLSE:	TST	ININ
	BNE	INCLOS
	TST	R2		;IF NO NUMBER WAS TYPED THERE IS
	BEQ	O.CLS1		;NO CHANGE TO THE OPEN CELL
	CMP	#1,O.BW
	BEQ	O.CLS2		;JUMP IF BYTE MODE
	BHI	O.CLS1		;JUMP IF ALREADY CLOSED
	MOV	R4,@O.CAD	;STORE WORD
	BR	O.CLS1
O.CLS2:	MOVB	R4,@O.CAD	;STORE BYTE
O.CLS1:	RTS	PC
;
O.CRLF:	MOV	#O.CR+1,R3	;LWA <CR,LF>
	BR	O.CRS
O.CRLS:	MOV	#O.CR+2,R3	;LWA <CR,LF>*
O.CRS:	MOV	#O.CR,R4	;FWA
	JSR	5,O.TYPE	;TYPE SOMETHING
	RTS	R5
INCLOS:	MOV	O.CAD,R2
	MOV	VAL,(R2)
	MOV	.LENTH,LENTH	;STORE NEW LENGTH AS THE LENGTH
	BEQ	O.CLS1
	MOV	VAL+2,2(R2)
	SUB	#2,.LENTH
	BEQ	O.CLS1
	MOV	VAL+4,4(R2)
	BR	O.CLS1
;SYLLABE=# OR SYMBOL

;THIS ROUTINE GETS AN ASCII CHARATCER IN R0
;AND ITS RAD50 EQUIVILANT IN R1
;IF THE CHAR IS NOT RAD50, THE ROUTINE DOES NOT SKIP RETURN
O.GET5:	JSR 5,O.GET
	CMP	#'0,R0		;COMPARE WITH ASCII 0
	BHI	O.GT51		;CHECK LEGALITY IF NON-NUMERIC
	CMP	#'9,R0		;COMPARE WITH ASCII 9
	BLT	O.GT51		;CHECK LEGALITY IF NOT NUMBER
	SUB #'0,R0
	ASL	R4		; MAKE ROOM
	ASL	R4		;  IN
	ASL	R4		;    R4
	ADD	R0,R4		;PACK THREE BITS IN R4
	MOV	R4,-(SP)	;GET VALUE AS DECIMAL NUMBER JUST IN CASE
	ASL	SAVDEC	;SAVDEC=SAVDEC*2+SAVDEC*8+DIGIT
	MOV	SAVDEC,R4
	ASL	R4
	ASL	R4
	ADD	R0,R4
	ADD	R4,SAVDEC
	MOV	(SP)+,R4
	INC	R2		;R2 HAS NUMERIC FLAG
	CMP	#7,R0	;OCTAL (0-7) OR DECIMAL (8-9)?
	BGE	O.GT55	;OCTAL
	ADD	#400,R2	;DECIMAL. SET DECIMAL FLAG IN HIGH BYTE OF R2
O.GT55:	ADD #'0,R0
O.GT51:	MOV R0,R1
	CMP #44,R1
	BEQ O.GT5$
	TSTB	STRFLG
	BEQ	O.GT52
	CMP	#40,R1
	BEQ	O.GT5B
O.GT52:	CMP #56,R1	;CONVERT TO RADIX 50
	BEQ O.GT5.
	SUB #'0,R1
	BLT O.GT5T
	CMP R0,#'9
	BGT O.GT53
	ADD #36,R1
	BR O.GT54
O.GT53:	SUB #20,R1
	BLE O.GT5T
	CMP R0,#'Z
	BGT O.GT5T
O.GT5D:	MOV #170000,R2 	;GROSSLY NEGATIVE IF R2NEG,SYMB IF POS VALUE
O.GT54:	TST	(R5)+	;ADD TWO TO R5
	RTS R5
O.GT5$:	MOV #33,R1
	BR O.GT5D
O.GT5B:	CLR	R1
	BR	O.GT54
O.GT5.:	MOV #34,R1
	TST	R2	;IF NUMERIC FLAG SET, MAKE IT DECIMAL
	BEQ	O.GT5D	;OTHERWISE IT'S A SYMBOL
	ADD	#400,R2	;SET DECIMAL FLAG
	BR O.GT54
O.GT5T:	MOV R0,R1
	RTS R5

O.GET3:	CLR O.CSYL	;GET 3 RADIX 50 CHARS
	JSR 5,O.GET5	;PCKNG ALG C1*50*50+C2*50+C3
	BR O.GT3T
O.GT31:	ADD #3100,O.CSYL
	DEC R1
	BGT O.GT31
	JSR 5,O.GET5
	BR O.GT3T
O.GT32:	ADD #50,O.CSYL
	DEC R1
	BGT O.GT32
	JSR 5,O.GET5
	BR O.GT3T
	ADD R1,O.CSYL
	TST	(R5)+
O.GT3T:	RTS R5

O.GETS:	CLR	R4
	CLR	SAVDEC
	CLR	R2
	JSR 5,O.GET3
	BR O.GTS2
	TSTB	STRFLG
	BNE	O.GTS5
	MOV O.CSYL,O.SYL
	JSR 5,O.GET3
	BR O.GTS3
	MOV O.CSYL,O.SYL+2
O.GTS1:	JSR 5,O.GET3
	BR O.GTS4	;TYPES TERM
	BR O.GTS1	;DOESN'T
O.GTS2:	TST	R2
	BNE	O.GTS5
	CMP	#'",R0
	BNE	O.GTS6
	JSR	R5,O.GET
	MOV	R0,R4
	SWAB	R4
	BR	O.GTS7
O.GTS6:	CMP	#'',R0
	BNE	O.GTS5
O.GTS7:	JSR	R5,O.GET
	ADD	R0,R4
	INC	R2	;TREAT QUOTED CHAR LIKE NUMERIC TERM
	BR	O.GTS1	;LOOK FOR TERMINATING CHAR
O.GTS5:	MOV O.CSYL,O.SYL
	CLR O.SYL+2
	RTS R5
O.GTS3:	MOV O.CSYL,O.SYL+2
O.GTS4:	RTS R5	;LOOK UP SYMBOL
O.SYLL:	MOV O.SYMS,R1
	CLR	R3
O.SLL2:	ASL	R3
	BNE	O.SLL3
	TST	-(R1)
	MOV	R1,O.FLGS
	TST	-(R1)	;SKIP OVER HALF KILLED FLAGS BY -2
	INC	R3
O.SLL3:	SUB	#6,R1
	CMP	R1,O.SYME
	BLT	O.SLL1
	CMP (R1),O.SYL
	BNE O.SLL2
	CMP 2(R1),O.SYL+2
	BNE O.SLL2
	MOV #1,R2
	MOV 4(R1),R4	;VALYE TO R4
	TST	(R5)+
O.SLL1:	RTS R5

SAVDEC:	0
O.FLGS:	0
;THIS RTINE, HOPEFULLY WILL GET AN ENTIRE SYMBOL
;WITH PLUSSES AND MINUSES, LIKE FOO+.-100
GETS:	CLR	SCRTCH
	CLR	.NEGFL	;THIS CLEARS .REGF TOO
GTS1:	JSR	5,O.GETS
	TSTB	STRFLG
	BEQ	GTS2
	CLRB	STRFLG
	MOV	O.SYL,R4
	BR	.JNUM	;THE ABOVE FEW LINES HANDLED * SYMBOLS
GTS2:	TST	R2
	BLT	LABLE
	BEQ	TERM
	SWAB	R2
	TSTB	R2		;HIGH BYTE OF NUMERIC FLAG IS DEC NUM FLAG
	BEQ	.JNUM		;OCTAL
	MOV	SAVDEC,R4	;DECIMAL. GET IT.
	BR	.JNUM
TERM:	CMP	%0,#'-
	BNE	NOTNEG
	INCB	.NEGFL
	BR	GTS1
NOTNEG:	CMP	%0,#'+
	BNE	NOTPOS
	BR	GTS1
NOTPOS:	CMP	%0,#'%
	BNE	GTS3
	INCB	.REGF	;SET REGISTER FLAG
	BR	GTS1
GTS3:	CMP	%0,#40
	BEQ	GTS1
	CMP	%0,#'	
	BEQ	GTS1
	CMP	%0,#'*
	BNE	TERMT
	INCB	STRFLG
	BR	GTS1
LABLE:	CMP	R0,#':	;HERE'S THE ONLY TIME GETS CAN HAVE
	BNE	.SYMBL	;AN UNDEFINED LABEL - THE : COMMAND
	TSTB	O.NUMF	;WHICH IS DETECTED HERE RATHER THAN IN THE
	BNE	GERR	;COMMAND TABLE OUT OF NECESSITY
	JMP	O.COLO
.SYMBL:	JSR	5,O.SYLL
	BR	GERR
	BIT	R3,@O.FLGS	;TES FOR REGISTER SYMBOL
	BEQ	.JNUM
	INCB	.REGF
.JNUM:	TSTB	.NEGFL
	BEQ	POSTV
	CLRB	.NEGFL
	NEG	R4
POSTV:	ADD	R4,SCRTCH
	MOV	SCRTCH,O.CVAL
	INCB	O.NUMF
	BR	TERM
TERMT:	MOV	SCRTCH,R4
	TST	(R5)+
GERR:	RTS	5
SCRTCH:	0
.NEGFL:	.BYTE	0
.REGF:	.BYTE	0	
STRFLG:	.BYTE	0
	.EVEN

;
O.LGDR:
;FOLLOWING COMMANDS PROCEEDED BY ALT
	O.GO	;  G  GO TO ADDRESS K
	O.WSCH	;  W  SEARCH WORD
	O.EFF	;  E  SEARCH EFFECTIVE ADDRESS
	O.BKPT	;  B  BREAKPOINTS
	O.PROC	;  P  PROCEED
	DELTB	;D  DELETE BKPT
	GONUM
	GOSYM
	GOINST
	STICKY	;CHANGE MODE
	SSTEP	;SINGLE STEP MODE
	TABSMD
	TRELMD
;FOLOWING COMMANDS DON'T NEED ALT
	O.EQUL	; = PRINTS CURRENT VALUE
	O.ALT	; ALT SIGNALS COMMAND
	O.EXCL	; ! DEFINES SYM
	O.SEMI	;  ; DILIMITS ARGS
	O.WRD	;  /    OPEN WORD
	O.BYT	;  \    OPEN BYTE
	O.CRET	;  CARRIAGE RETURN    CLOSE
	O.OP1	;  <LF>  MODIFY, CLOSE, OPEN NEXT
	O.OLD	;  <  RETURN TO OLD SEQUENCE AND OPEN
	O.BACK	;  ^  OPEN PREVIOUS
	O.RDEQ	; ] PRINT CURRENT VAL AS RAD50 CHARS
	O.ASEQ	; [ PRINT AS ASCII
	HKILL	; ^K HALF KILL
O.LGL=	.-O.LGDR	;LGL MUST EQUAL 2X CHLGT ALWAYS
;
O.LGCH:
;FOLLOWING COMMANDS PRECEEDED BY ALT
	.BYTE	'G	;  G
	.BYTE	'W	;  W
	.BYTE	'E	;  E
	.BYTE	'B	;  B
	.BYTE	'P	;  P
	.BYTE	'D	;  D
	.BYTE	'C
	.BYTE	'S
	.BYTE	'I
	.BYTE	33	;ALT MODE
	.BYTE	'N
	.BYTE	'A
	.BYTE	'R
O.NALC=.-O.LGCH
	.BYTE '=	;  =
	.BYTE 33	;  ALT
	.BYTE '!	;  !
	.BYTE	';	;  ;
	.BYTE	'/	;  /
	.BYTE	'\	;  \
	.BYTE	015	;  CARRIAGE RETURN
	.BYTE	012	;  <LF>
	.BYTE	'<	;  <
	.BYTE	'^	;  ^
	.BYTE	']	; ]
	.BYTE	'[	; [
	.BYTE	13	;^K
O.CLGT=	.-O.LGCH		;TABLE LENGTH
.EVEN

;
O.BW:	0			; =0 - ALL CLOSED,
				; =1 - BYTE OPEN,
				; =2 - WORD OPEN
O.CSYL:	0
O.SYL:	0
	0
O.VAL:	0
O.CAD:	0			; CURRENT ADDRESS
O.CVAL:		0		;CURRENT VALUE
COUNT:	0
SSFLAG:	0
LENTH:	0
CNTNTS:	0
O.XXX:	O.ODT			;TEMPORARY STORAGE, INITIALLY HAS START ADDRESS
O.SYMS:	O.BSYM
O.SYME:	O.ESYM-6
O.ALTF:O.COLM:	.BYTE	0	;OUTPUT COLUMN POINTER
	.BYTE 0	;COMMAND PROCEEDED BY ALT
O.NUMF:	.BYTE 0			;NUMBER SEEN(USED INSTEAD OF R2)
O.WDFG:	.BYTE	0		;SEARCH FLAG = 1 - EFFECTIVE
				;            = 0 - WORD
O.T:	.BYTE	0		;  T-BIT FLAG
PP:	.BYTE	0		;TEMP PROCEED FLAG SAVE WHEN SINGLE STEPPING
O.P:	.BYTE	0		;PROCEED FLAG = -2 IF MANUAL ENTRY
				;		-1 IF NO PROCEED ALLOWED
				;		0-7 IF PCEED ALLOWED
O.CSR1:	.BYTE	0		;SAVE CELL - R C/SR
O.CSR2:	.BYTE	0		;SAVE CELL - T C/SR
;
	.EVEN
O.BD:	.WORD	"BE
;
O.CR:	.BYTE	015	;  <CR>
	.BYTE	012	;  <LF>
	.BYTE	'*	;  *
;
	.EVEN
;
O.BUF:				;6 CHAR. BUFFER WITH
.=	.+6
	.BYTE	' 		;TRAILING BLANK
	.EVEN
;
O.TRTC:	TRT			;TRACE TRAP PROTOTYPE
;********************SYMBOL TABLE********************

;ARITHMETIC INSTRUCTIONS
INSTS:	INOP2-ARITH	;SIGNALS CHANGE OF JUMP MASK BLOCK
	107777	;NEW MASK
	ARITH	;NEW JUMP LOC
	.RAD50 /MOV/
	010000
	.RAD50 /CMP/
	020000
	.RAD50 /BIT/
	030000
	.RAD50 /BIC/
	040000
	.RAD50 /BIS/
	050000

;ADD&SUB DO NOT HAVE BYTE OPTION SO ARE SEPERATE
	INOP2-ADDSUB
	007777
	ADDSUB
	.RAD50 /ADD/
	060000
	.RAD50 /SUB/
	160000

;SINGLE OPERAND INSTRUCTIONS
	INOP1-SINGOP
	100077
	SINGOP
	.RAD50 /CLR/
	005000
	.RAD50 /COM/
	005100
	.RAD50 /INC/
	005200
	.RAD50 /DEC/
	005300
	.RAD50 /NEG/
	005400
	.RAD50 /ADC/
	005500
	.RAD50 /SBC/
	005600
	.RAD50 /TST/
	005700
	.RAD50 /ROR/
	006000
	.RAD50 /ROL/
	006100
	.RAD50 /ASR/
	006200
	.RAD50 /ASL/
	006300

;JMP AND SWAB
	INOP1-SINGOP
	000077
	SINGOP
	.RAD50 /JMP/
	000100
	0	;SIGNALS BLOCK OF INSTRUCTION WITH >3CHARS
	.RAD50 /SWA/
	000300
	.RAD50 /B  /

;CONDITION CODES
	INCCDD-CNDCOD
	000017
	CNDCOD
	.RAD50 /SE /
	000260
	.RAD50 /CL /
	000240

;JSR
	INJSR-.JSR
	000777
	.JSR
	.RAD50 /JSR/
	004000

;RTS
	INRTS-.RTS
	000007
	.RTS
	.RAD50 /RTS/
	000200

;CONTROL GROUP
	INCNTR-.CNTRL
	0
	.CNTRL
	0
	.RAD50 /HAL/
	0
	.RAD50 /T  /
	0
	.RAD50 /WAI/
	1
	.RAD50 /T  /
	.RAD50 /RTI/
	2
	.RAD50 /BPT/
	3
	.RAD50 /IOT/
	4
	0
	.RAD50 /RES/
	5
	.RAD50 /ET /

;TRAP AND EMT
	INCNTR-.TRAP
	377
	.TRAP
	.RAD50 /EMT/
	104000
	0
	.RAD50 /TRA/
	104400
	.RAD50 /P  /

;BRANCHES
	INBRCH-.BRCHS
	377
	.BRCHS
	.RAD50 /BR /
	000400
	.RAD50 /BNE/
	001000
	.RAD50 /BEQ/
	001400
	.RAD50 /BGE/
	002000
	.RAD50 /BLT/
	002400
	.RAD50 /BGT/
	003000
	.RAD50 /BLE/
	003400
	.RAD50 /BPL/
	100000
	.RAD50 /BMI/
	100400
	.RAD50 /BHI/
	101000
	0
	.RAD50 /BLO/
	101400
	.RAD50 /S  /
	.RAD50 /BVC/
	102000
	.RAD50 /BVS/
	102400
	.RAD50 /BCC/
	103000
	.RAD50 /BCS/
INSTE:	103400
	0		;BAG BITER GETS NXMS IF THESE AREN'T HERE
	0

.IIF NE .-100000,.ERROR RUGLEN IS WRONG

;
;THE ORDER OF THE FOLLOWING ENTRIES IS CRITICAL
;
.=	O.ODT-116	;ODT'S STACK IMMEDIATELY PRECEDES ODT

O.UR0:	0	;USER R0
	0	;     R1
	0	;     R2
	0	;     R3
	0	;     R4
	0	;     R5
O.USP:	0	;USER SP
O.UPC:	0	;USER PC
O.UST:	0	;USER ST
O.PRI:	7	;ODT PRIORITY
O.MSK:	0	;MASK
	0	;LOW LIMIT
	0	;HIGH LIMIT
;
; BREAK POINT LISTS, ADR1 = ADDRESS OF BREAKPOINT,CT = COUNT,
;   UIN = CONTENTS
;
O.ADR1:	.REPT O.BPT
	O.TRTC
	.ENDR
O.CT:	.REPT O.BPT
	0
	.ENDR
O.UIN:	.REPT O.BPT
	TRT
	.ENDR
HIGHAD:	0		; LARGEST LEGAL (EVEN) CORE LOCATION
O.URE:

.=O.ODT-200
O.BSYM=.+2
O.ESYM=.-2
.=O.ESYM-6
	.RAD50	/.  /
	0
O.DOT:	0
	1	;HALF KILLED SYMBOL FLAG
	177776
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/R0 /
	0
	0
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/R1 /
	0
	1
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/R2 /
	0
	2
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/R3 /
	0
	3
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/R4 /
	0
	4
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/R5 /
	0
	5
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/R6 /
	0
	6
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/R7 /
	0
	7
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/SP /
	0
	6
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/PC /
	0
	7
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/.P /
	0
	11
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/.M /
	0
	12
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/.S /
	0
	10
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/.B /
	0
	15

O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/.C /
	0
	15+O.BPT
O.ESYM=	O.ESYM-12
.=	O.ESYM-6
	.RAD50	/.H /
	0
	15+O.BPT+O.BPT+O.BPT

	0
	1	;NEW FLAG WORD

O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/TKS/
	0
	O.RCSR
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/TKB/
	0
	O.RDB
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/TPS/
	0
	O.TCSR
O.ESYM=	O.ESYM-6
.=	O.ESYM-6
	.RAD50	/TPB/
	0
	O.TDB

.=O.TVEC		;ASSEMBLE BREAK VECTOR
	O.BRK
	O.STM

	.END	O.XXX	;-> MAGIC FROB FOR 11BOOT
	