; -*-MIDAS-*-
.SYMTAB 6000.

TITLE 11SIM
VERSION==:.FVERS

; EXPUNGE PREDEFINED SYMBOLS WE USE FOR OTHER PURPOSES.
IF1 EXPUNGE %GO


IFNDEF TENEX,TENEX==IFE .OSMIDAS-SIXBIT/ITS/,[0] .ELSE [1]
DEFINE TXY
IFN TENEX,TERMIN
DEFINE TXN
IFE TENEX,TERMIN

TXY[
.DECSAV				; PRODUCE .SAV FILE INSTEAD OF .REL FILE
.VALUE==:HALTF
IFNDEF EOL,EOL==^J		; ASSUME 20X EOL CHARACTER (37 ON 10X)
]

IFNDEF 45P,45P==1		; 1 FOR 11-45 MAP SIMULATION.
DEFINE 45Y
IFN 45P,TERMIN
DEFINE 45N
IFE 45P,TERMIN

CPRI=0
A=1
B=2
C=3
D=4
E=5
T=6
TT=7

MB=10	;MEMORY BUFFER
MA=11	;MEMORY ADDRESS
X=12
PC=13	;PROGRAM COUNTER
PS=14	;PROCESSOR STATUS
45Y	45STTM==144000	;MASK OF MODE AND REG SET.
45Y	45CMOD==160200	;BP TO CURRENT MODE
45Y	45MODM==140000	;MASK OF CURRENT MODE
45Y	45PMOD==140200	;BP TO PREVIOUS MODE.
45Y	45REGB==4000	;REGISTER SET SPECIFIER BIT
	PRI==50300	;PRIORITY (BYTE POINTER)
	TF==20
	NF==10
	ZF==4
	VF==2
	CF==1
TIME=15	;TIME (IN TETHS OF MICROSECONDS)
I=16	;INSTRUCTION
P=17

.XCREF A,B,C,D,E,I,MA,MB,P,PC,PS,T,TIME,TT

TXN[
ETC==0
TYIC==1
TYOC==2
LOADCH==3
LPTC==4
UTIC==5
DMPCH==6
ERRC==7
DYCH==10	;FIRST DYNAMICLY ALLOCATED CHANNEL
DYCHN==10	;NUM DYNAMICLY ALLOCATED CHS
DYCMSK==377_10			;USED BY DC AND DM
]

SYMTYP=1000,,
ADRTYP=2000,,
OPENL=3000,,
6TYPE=4000,,
BLKFLS=5000,,
TTOI=6000,,
TTOA=7000,,
ERROR=10000,,
UUOMAX==10
ARGERR=ERROR [ASCIZ/ARG/]
CALL=PUSHJ P,
RETURN==POPJ P,
RET=RETURN
SAVE=PUSH P,
REST=POP P,
CRF=TTOA [ASCIZ /
/]

.XCREF CALL,RET,RETURN
IF1 EXPUNG %PC

TRPPTL==100	;-1)*4=MAX TRAP FOR TRAP PRINT VECTOR
PDLSIZ==200	;PDL SIZE

45Y	SEGBP==140300	;BP TO SEGMENT # FIELD IN WORD #.

IF1 EXPUNGE APR


;MEMORY ALLOCATION

;0	START OF SIMULATOR, ENDS WITH SYM TAB THAT EXPANDS UPWARD
;RKBUF=NGBLK-6000*RKNBUF	;RK BUFFERS, 3K PER.
NGBLK=274000	;NG DIS
PDP11=300000	;SIMULATED PDP11 MEMORY 1 WORD/WORD
.XCREF PDP11
45Y IOORG==600000	;START OF TOP 32.K OF 11 MEMORY.
45N IOORG==PDP11

45N	MAXK==28.
45N	MAXCOR==100000
45N	MAXBYT==200000
45Y	MAXK==124.
45Y	MAXCOR==400000
45Y	MAXBYT==1,,

;I-O ROUTINE SYMBOL CONVENTIONS

;A!DEV:	ATTACH ROUTINE
;D!DEV:	DETACH ROUTINE
;W!DEV:	FLAG, 0 IF DETACHED, -1 IF ATTACHED
;Z!DEV:	"RESET" ROUTINE IF DIFFERENT FROM A!DEV
;REG!(HAK,HK,K):	DEVICE REGISTER REG ROUTINE
;DEV!TIM: TIME CONSTANT FOR OPERATION OF DEVICE

;OTHER SYMBOL CONVENTIONS

;I!INSN:	ROUTINE FOR SIMULATION OF INSTRUCTION INSN
;C!COM:	ROUTINE FOR : COMMAND COM
;CS!COM:	ROUTINE FOR ; COMMAND COM

ABEG:	LOC 41
	JSR UUOH
TXN	JSR TSINT

DEFINE CONC A,B
A!B!TERMIN

DEFINE TSOPEN A,B
	.OPEN A,B
	 OPENL B
	TERMIN

DEFINE SYSCAL A,B
	.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
	 .LOSE %LSFIL
TERMIN

DEFINE SYSCL A,B
	.CALL [SETZ ? SIXBIT/A/ ? B ((SETZ))]
TERMIN

DEFINE INSIRP A,B
IRPS INSIR1,,[B]
A,INSIR1
TERMIN TERMIN

;PERFORM APPROPRIATE ADJUSTMENTS IF A
;NEW QUANTITY HAS BEEN LOADED IN PS
DEFINE NEWPS
45Y[	MOVE 0,PS
	ANDI 0,45STTM	;GET NEW MODE AND REG SET BIT
	CAME 0,45STAT	;EITHER ONE HAS CHANGED =>
	 CALL 45NMOD	;DO BOOKKEEPING.
]
45N	ANDI PS,377
	LDB CPRI,[PRI,,PS]
	MOVE A,[LDB T,[061200,,I]]
	TRNE PS,TF
	MOVE A,[JRST TTRPIB]
	MOVEM A,TRPMOD
	TERMIN

;DON'T USE XXWAIT UNLESS THE PRIORITY IS REALLY 6,,
DEFINE XXWAIT X
	JSP A,MTRNEW
	6,,
	-1
	IFNB X,PUSHJ P,X
	IFB X,PUSHJ P,.+1
	TERMIN

IOCNUM==0	;GET CONTROL ON IOC ERRORS
DEFINE IOCGET X
	IF2 [IOCLOC==.
LOC IOCTAB+IOCNUM
	IOCLOC
	X
LOC IOCLOC]
	IOCNUM==IOCNUM+2
	TERMIN

DEFINE	CSLWRD	A
	JSP D,	CSLR!A
TERMIN			;LOAD 1 WORD FROM LOADCH INTO A (T2, T3, T5).

;MAP MACROS FOR NON-MAP VERSION:
45N[

IRPS X,,IR IW DR DW
IRPS Y,,MA TT
DEFINE 45!X!!Y X2
TERMIN
TERMIN
TERMIN

DEFINE 45PCINC X1,Y1
	AOS X1,PC
	SKIPGE Y1,PDP11-1(X1)
	 JSP D,MTRAPR
TERMIN
]

;MAP MACROS FOR VERSION WITH MAP:
45Y[

IRPS X,,IR IW DR DW,XX,,0 0 1 1
IRPS Y,,MA TT,Z,,0 1
DEFINE 45!X!!Y XY
	LDB D,[SEGBP,,Y]
	XCT XX,@45!X!X1+Z
	XCT XY,@45!X!X2+Z
	 JSP A,45ASL
TERMIN
TERMIN
TERMIN

DEFINE 45PCINC X1,Y1
	MOVE X1,PC
	AOJ PC,
	45IR!X1
	SKIPGE Y1,PDP11(X1)
	 JSP D,MTRAPR
TERMIN
]

LOC ABEG

BEG:
TXY	RESET
	SETZM RUN	;RUN=0 MEANS STOP SOON (LOOKED AT BY DIRECT TO MEM DEVICES)
	SETZM DDTPDP	;DDTPDP=0 MEANS NORMAL NOT IN DDT
			;DDTPDP>0 NOT IN DDT BUT FAKE OUT MTRAP ETC.
			;DDTPDP<0 IN DDT (SAVE PDL PNT HAS NEG COUNT IN LH)
	SETOM DINITF	;WILL BE 1ST CALL TO DDT SOON.
	MOVE P,[(-PDLSIZ)PDL]
	SETZB PC,PS
	NEWPS
	SETZM LPTFLG
	PUSHJ P,MERRV
TXN[	MOVE A,[-3,,[	.RUNAME,,UNAME
			.RXUNAME,,XUNAME
			.RHSNAME,,HSNAME
			]]
	.SUSET A
	.OPEN TYOC,[%TJDIS+.UAO,,'TTY]
	 .LOSE %LSFIL		;IF NO TYPEOUT.
	MOVE A,[-BSUSL,,BSUST]
	.SUSET A		;SET UP INTERRUPTS
	.OPEN TYIC,[.UII,,'TTY]
	 TTOA [ASCIZ /
TYPE IN FAILS/]
	.STATUS TYIC,A
	ANDI A,77
	CAIN A,2
	SETOM GETTY		;SET GETTY TO -1 IF GRAPHICS TTY.
	.CALL TTYGT
	 .LOSE %LSFIL
	TLZ A,%TSACT
	MOVEM A,TTYM1A		;SET UP ORDINARY TTYSET,
	TLO A,%TSACT
	MOVEM A,TTYMAA		;ACTIVATE-ON-NEXT-CHAR TTYSET.
]
TXY[	MOVEI	A,.FHSLF	;SETUP TENEX INTERRUPT SYSTEM
	CIS
	MOVE	B,[LEVTAB,,CHNTAB]
	SIR
	EIR
	MOVE	B,CHNMSK
	AIC
	MOVE	A,[.TICCX,,0]	; ^X - CHANNEL 0
	ATI
	MOVE	A,[.TICCW,,1]	; ^W - CHANNEL 1
	ATI
	MOVE	A,[.TICCS,,2]	; ^S - CHANNEL 2
	ATI
	MOVE	A,[.TICCV,,3]	; ^V - CHANNEL 3
	ATI
	MOVE	A,[.TICCG,,4]	; ^G - CHANNEL 4
	ATI
	MOVEI	A,.PRIIN	; SET TERMINAL BREAKS
	RFMOD
	IORI	B,TT%WKF\TT%WKN\TT%WKP\TT%WKA	; TO ALL CHARACTERS
	SFMOD
]
	6TYPE [45N[SIXBIT/1120./] 45Y[SIXBIT/1145./]]
	TTOA [.RADIX 10.,.ASCII "!<VERSION> "]
	PUSHJ P,BLKGET		;GET PDP-11 I-O BLOCK
	600000,,IOORG+76000	;SET TO NXM
45Y	CALL AI45
	CALL CZTIME		;MUST FOLLOW SETUP OF NXM INTERRUPTS & LOCATIONS
	CRF
	PUSHJ P,WRDINS	;SET UP STATUS, PC, SWITCH REG
	600000+NPS,,RPS
	600000+NSWR,,RSWR
	REPEAT 3,600000+NCSX,,RCSX+.RPCNT+1
	0,,RCSX
	0
	PUSHJ P,XRESET	;INITIALIZE AND ATTACH VARIOUS DEVICES
TXN[	.CALL [	SETZ ? SIXBIT/OPEN/ ? 1000,,UTIC
		[SIXBIT/DSK/] ? XUNAME ? [SIXBIT/PDP11/] ? SETZ HSNAME ]
	 JRST BEG2
	TTOA [ASCIZ /INIT
!/]
	SETOM FILINF
	JRST DIEDIE
]
BEG2:	MOVEI T5,8
	SKIPN KCOUNT		;IF NO CORE YET,
	PUSHJ P,CCORE1		;GET 8 K.
	TTOI "!
	JRST DIEDIE
TXN[
FILINF:	0
]

;NOTE THAT IF DDTPDP IS NEG, THE SIMULATED TIME WILL BE IN RTIME NOT TIME

TXN[
;INTERRUPT HANDLER
TSINT:	0
	0
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,40
	PUSH P,UUOH
	SETZM INTINS
	SKIPGE DEBUGP
	.SUSET [.RJPC,,INTJPC]
	SKIPL A,TSINT
	JRST OTHERI	;FIRST WORD INT
	TRNN A,1_TYIC+DYCMSK
	JRST BADINT	;SECOND WORD BUT NOT VALID CHANNEL
	TRNN A,1_TYIC
	JRST DYCINT	;NOT TYI
	MOVEI A,TYIC
	.ITYIC A,
	JRST DYCINT
	AOSN ICTLQF
	JRST TSINT2
	CAIN A,^Q
	JRST TSINTQ
	CAIE A,^W
	CAIN A,^S
	JRST TSILNT
	CAIN A,^V
	SETOM TYOFLG
	CAIN A,^B
	JRST TSINTB
	CAIN A,^E
	JRST TSINTE
	CAIN A,^G
	JRST TSQUIT
TSINT2:	SKIPGE DDTPDP
	JRST DYCINT
	CALL TSINNS	;STOP SLEEPING, PC INTO A.
	SKIPN TKBUSY	;IF WON'T LOOK FOR ANOTHER CHAR,
	CALL TKB224	;LOOK FOR IT NOW.
	JRST DYCINT

TSINNS:	HRRZ A,TSINT+1
	CAIN A,IWAITS	;DON'T RETURN TO .SLEEP .
	AOS TSINT+1
	RETURN

TSQUIT:	SKIPGE DDTPDP		;IF INSIDE DDT,
	.DISMI [DERR]		;RETURN TO MAIN LOOP RIGHT AWAY.
	AOS A,QUITF
	CAIL A,2
	.DISMI [QUIT]		;3 ^G'S - STOP IMMEDIATELY.
	TTOA [ASCIZ/
^G   /]
	PUSHJ P,CLRRUN		;STOP AFTER INSN.
	CAIE A,1
	JRST DYCINT
TSILNT:	SETZM TYOFLG
	PUSHJ P,TRESET
	JRST DYCINT

TSINTQ:	SETOM ICTLQF
DYCINT:	MOVE A,TSINT
	TRNN A,DYCMSK
	JRST TSINTX
	MOVE C,[-DYCHN,,DYCH]
DYCIN2:	TDNE A,DYCBIT-DYCH(C)
	PUSHJ P,DYCINR
	AOBJN C,DYCIN2
	JRST TSINTX

DYCINR:	HRRZ B,C	;INTERRUPT ON DYNAMICALLY ALLOCATED CHANNEL
	SKIPE DYCTYP-DYCH(C)	;SKIP IF TTY
	 JRST DYCINS
	.ITYIC B,	;MUST ITYIC IF TTY
	 POPJ P,
DYCINS:	PUSH P,A
	CALL TSINNS	;STOP A WAIT INSN.
DYCILY:	MOVE A,DYCBPT-DYCH(C)
	SKIPL 1(A)	;IF MAIN PROGM NOT LOOKING AT THIS CHNL,
	JRST POPAJ
	SAVE C
	MOVE C,TIME
	SKIPGE DDTPDP
	MOVE C,RTIME
	SKIPN QFLAG
	PUSHJ P,CTRDES	;TELL IT TO LOOK SOON.
	CAMN A,QFLAG	;IF MAIN PROGM NOW QUEUEING THIS BLOCK,
	 JRST POPCAJ	;NEED NOT DO ANYTHING NOW.
	SKIPE QFLAG
	PUSHJ P,MTRDES
POPCAJ:	REST C
POPAJ:	POP P,A
	POPJ P,

TRESET:	.RESET TYOC,
	SKIPE LPTFLG
	.RESET LPTC,
	RETURN

QUIT:	SAVE TSINT+1		;DDT WILL RETURN TO INTERRUPTED SIMULATION.
	SAVE [DDT]		;RSTALL WILL RETURN TO DDT.
	PUSHJ P,SAVALL
	PUSHJ P,MERRV
	TTOA [ASCIZ/
^GSUPER-QUIT!   /]
	MOVEI A,TRUNBK
	PUSHJ P,QDEL
	JRST RSTALL		;RESTORE ACS, RETURN(TO DDT).

OTHERI:	TRNE A,200000
	TTOA [ASCIZ /
PDL OVERFLOW/]
	TRNE A,400
	JRST OTHIOC	;IOC INT
	TRNN A,20000
	JRST BADINT
	MOVSI A,600000	;NON-EX MEM
	MOVEM A,NXMCLB
	HRRZ A,TSINT+1
	CAIL A,SYMTAB
	TTOA [ASCIZ/
NXM OUTSIDE PROGRAM AREA/]
	SKIPA A,-1(A)
NXMX2:	MOVE A,(A)
	HRRI A,@A
;	TRNN A,400000	;THIS TEST FOULS UP ON BYTE INSNS.
;	TRNN A,300000
;	TTOA [ASCIZ/
;NXM OUTSIDE VIRT. MEM/]
	AND A,[777740,,-1]
	TLC A,(XCT)
	TLNN A,777000
	JRST NXMX2	;XCT, GO DOWN CHAIN
	TLC A,(XCT)
	HRRI A,NXMCLB
	JRST NXMXIT

OTHIO4:	MOVE A,1(A)
NXMXIT:	MOVEM A,INTINS
TSINTX:	POP P,UUOH
	POP P,40
	POP P,C
	POP P,B
	POP P,A
	SKIPN INTINS
	.DISMI TSINT+1
	AOS TSINT+1		;TAKE CARE OF SKIPPING INSNS.
	XCT INTINS
	SOS TSINT+1
	.DISMI TSINT+1

OTHIOC:	HRRZ C,TSINT+1
	MOVEI A,IOCTAB
OTHIO2:	CAMN C,(A)
	JRST OTHIO4
	ADDI A,2
	CAIE A,IOCEND
	JRST OTHIO2
	TTOA [ASCIZ /
IOC ERROR IN /]
	SOS TSINT+1		;RETURN TO THE .IOT .
	JRST BADINU

NXMCLB:	0	;MAY BE CLOBBERED
INTJPC:	0
INTINS:	0

BSUST:	.SMASK,,[220400]
	.SPICL,,[-1]
	.SMSK2,,[1_TYIC+DYCMSK]
BSUSL==3

UNAME:	0
XUNAME:	0
HSNAME:	0


BADINT:	PUSHJ P,MERRV
	TTOA [ASCIZ /
BAD INTERRUPT IN 
INT:   /]
	MOVE B,TSINT
	PUSHJ P,FOCTP
BADINU:	REST UUOH		;RESTORE EVERYTHING SAVED.
	REST 40
	REST C
	REST B
	REST A
	.VALUE [ASCIZ*INTJPC/        *]
	.DISMI TSINT+1		;STOP BEFORE NEXT INSN.

LPTFIL:	1,,SIXBIT /   LPT/
	SIXBIT /WALL  PAPER/
]				; END OF ITS INTERRUPT HANDLER

TXY[
;TENEX INTERRUPT HANDLER

CHNMSK:	760000,,0000		; ACTIVATE CHANNELS 0-4
LEVTAB:	0			; ONLY USE INTERRUPT LEVEL 2
	PC2
	0

PC2:	0

CHNTAB:	2,,TSINTQ		; 0 - ^X
	2,,TSILNT		; 1 - ^W
	2,,TSILNT		; 2 - ^S SAME AS ^W
	2,,TSINTV		; 3 - ^V
	2,,TSQUIT		; 4 - ^G
	REPEAT 31.,0

DEFINE SVSTAT
	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,40
	PUSH	P,UUOH
TERMIN

TSINTQ:	SVSTAT
	SETOM	ICTLQF
TSINTX:	POP	P,UUOH
	POP	P,40
	POP	P,C
	POP	P,B
	POP	P,A
	DEBRK

TSILNT:	SVSTAT			; MAKE TERMINAL SILENT
TSILNA:	SETZM	TYOFLG
	MOVEI	A,.PRIOU	; CLEAR OUTPUT BUFFER
	CFOBF
	JRST	TSINTX

TSINTV:	SVSTAT
	SETOM	TYOFLG
TSINNS:	HRRZ	A,PC2		; DON'T RETURN TO SLEEP
	CAIN	A,IWAITS
	AOS	PC2
	JRST	TSINTX

TSQUIT:	SVSTAT
	SKIPGE	DDTPDP
	JRST	[MOVEI	A,DERR
		 HRRM	A,PC2
		 JRST TSINTX]
	SETZM	QUITF
	MOVEI	A,.PRIOU
	CFOBF
	TTOA	[ASCIZ /^G
/]
	PUSHJ	P,CLRRUN
	JRST	TSINNS
]

QUITF:	-1
ICTLQF:	0
RUNTB:	0	;RUN TIME BASE

;UUO HANDLER
UUOH:	0
	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,40	;4O MUST BE NEXT TO LAST PUSHED
	PUSH P,UUOH	;UUOH MUST BE LAST PUSHED
	HRRZ A,40
	LDB C,[331100,,40]
	SKIPE C		;JUMP WILL CLOBBER JPC
	CAILE C,UUOMAX
	SKIPA
	JRST @UUODIS-1(C)
UUOHE:
TXN	.SUSET [.RJPC,,20]
	PUSHJ P,MERRV
	TTOA [ASCIZ /
ILLEGAL UUO IN 
.JPC/]
	REST UUOH
	REST 40
	REST C
	REST B
	REST A
	SOS UUOH		;POINT TO UUO.
TXN	.VALUE [ASCIZ*20/*]
TXY	.VALUE
	JRST @UUOH		;STOP BEFORE THE UUO.

UUODIS:	XSYMTY
	XADRTY
TXN	UOPENL
TXY	UUOHE		; NOT LEGAL IN TENEX VERSION
	U6TYPE
	UBLKFL
	UTTOI
	UTTOA
	UERROR

UTTOA:	LDB B,[270400,,40]	;SKIP BY C(AC FIELD)
	ADDM B,(P)
	HRLI A,440700
	SAVE MCTLVF
MES2:	ILDB B,A
	CAIG B,^F
	XCT MESTAB(B)
	CAIN B,^K
	JRST MCTLK	;DECP
	CAIN B,^V
	JRST MCTLV
	TTOI (B)
	JRST MES2

MCTLV:	SETOM MCTLVF
	JRST MES2

MESTAB:	JRST MESXIT	;^@
	JRST MFOCTP	;^A
	JRST OPPNT	;^B
	JFCL		;^C
	JRST MCTLD	;SYMTYP
	JRST MCTLE
	JRST MCTLF	;ADRTYP

MERRV:	SETOM TYOFLG
TXN	SETZM DISOUT
	RETURN

MCTLVF:	0	;FORCE TTY OUTPUT FOR ERROR MESSAGES

MESXIT:	REST MCTLVF
	JRST UUOXIT

MFOCTP:	PUSHJ P,UGQUAN
	PUSHJ P,FOCTP
	JRST MES2

FOCTP:	LSHC B,-43	;FULL WORD OCTAL PRINT
	LSH C,-1
	DIVI B,8
	HRLM C,(P)
	SKIPE B
	PUSHJ P,FOCTP
	HLRZ C,(P)
	TTOI "0(C)
	RETURN

UGQUAN:	ILDB B,A	;GET QUANTITY
	CAIL B,"8
	JRST UGQUA2
	HRRZ B,R0-"0(B)
	RETURN

UGQUA2:	CAIE B,"A
	SKIPA B,QT
	MOVE B,QA
	RETURN

OPPNT:	PUSH P,[MES2]
	PUSHJ P,SAVALL
	SKIPL DDTPDP
	AOS DDTPDP
	SKIPL DDTPDP
	HRLZ SF,%TMODE
	SKIPGE DL,OPC
	JRST OPPNT1
	LSH DL,1
	PUSHJ P,DPINSN
	SKIPA
OPPNT1:	TTOA [ASCIZ/--DDT--/]
	SKIPL DDTPDP
	SOS DDTPDP
	JRST RSTALL

MCTLF:	SKIPA C,[ADRTYP QD]
MCTLD:	MOVE C,[SYMTYP QD]
	PUSHJ P,UGQUAN
	MOVEM B,QD
	PUSH P,[MES2]
	PUSHJ P,SAVALL
	SKIPL DDTPDP
	HRLZ SF,%TMODE
	XCT C
	JRST RSTALL

TXN[
MCTLE:	.VALUE		;FATAL ERROR
	SKIPGE DDTPDP
	.DISMI [DERR]
	.DISMI [BEG]
]
TXY[
MCTLE:	.VALUE		;FATAL ERROR
	JRST	.-1
]
MCTLK:	PUSHJ P,UGQUAN
	PUSHJ P,DECP
	JRST MES2

OCTP:	SKIPA C,[8]
DECP:	MOVEI C,10.
	HRRM C,ANYP
ANYP:	IDIVI B,.
	HRLM C,(P)
	SKIPE B
	PUSHJ P,ANYP
	HLRZ B,(P)
	TTOI "0(B)
CPOPJ:	RETURN

UBLKFL:	HRRZ B,(P)	;FLUSH QUEUE BLOCKS
	ADD B,[<222200,,>-1]
UBLKF2:	ILDB A,B
	TLNE B,770000
	AOS (P)
	JUMPE A,UUOXIT
	PUSH P,B
	PUSHJ P,QDEL
	POP P,B
	JRST UBLKF2

UTTOI:	SKIPE MCTLVF
	 JRST UTTOI1
TXN[	SKIPE DISOUT
	 JRST UDISCH
]
	SKIPE TYOFLG
UTTOI1:
TXY	PBOUT
TXN[	.IOT TYOC,A	;THE ONLY TYPE OUT IOT
	SKIPE LPTFLG
	 .IOT LPTC,A
]
	JRST UUOXIT

TXN[
UDISCH:	PUSHJ P,DISCH
]
UUOXIT:	POP P,UUOH
	POP P,40
	POP P,C
	POP P,B
	POP P,A
	JRST 2,@UUOH

U6TYPE:	MOVE B,@40
	MOVE A,[440600,,B]
U6TYP2:	ILDB C,A
	JUMPE C,UUOXIT
	TTOI 40(C)
	JRST U6TYP2

TXN[
UOPENL:	.SUSET [.RBCHN,,C]	;OPENL UUO, GET # OF CHANNEL.
	CAIE C,LPTC
	 JRST UOPNL1
	SETZM LPTCNT
	SETZM LPTFLG
UOPNL1:	DPB C,[270400,,OPNLX1]
	DPB C,[270400,,OPNLX2]
OPNLX1:	.STATUS .,OPLERR
	HLR C,(A)
	CAIE C,4^5	;NEW SYSTEM CALL OPEN, DON'T GET DEV NAME.
	 TRNE C,1
	  JRST UOPNL3	;OUTPUT LOST
	.SUSET [.RSNAME,,LSNAME]
	.SUSET [.SSNAME,,[SIXBIT /PDP11/]]
OPNLX2:	.OPEN .,(A)
	 JRST UOPNL2
	.SUSET [.SSNAME,,LSNAME]
	JRST UUOXIT

UOPNL2:	.SUSET [.SSNAME,,LSNAME]
UOPNL3:	.OPEN ERRC,ERRFIL
	 JRST .-1
	PUSHJ P,MERRV
UOPNL4:	.IOT ERRC,B
	CAIE B,14
	 CAIN B,3
	  JRST UOPNL6
	TTOI (B)
	JRST UOPNL4

UOPNL6:	CAIN C,4^5
	 JRST DERR
	HRLZ B,(A)
	6TYPE B
	JRST DERR
]
ERRFIL:	(SIXBIT /ERR/)
	3
OPLERR:	.

LSNAME:	0	;LAST SYSTEM NAME

WRDINS:	PUSH P,A	;WORD INSERT
	PUSH P,B
	PUSH P,C
	MOVE A,-3(P)
WRDIN2:	SKIPN B,(A)
	JRST WRDIN4
	LDB C,[MARPOS,,(B)]
	SKIPE C
	TLO B,400000
	HLLZM B,(B)
	DPB C,[MARPOS,,(B)]
	AOS A,-3(P)
	JRST WRDIN2

WRDIN4:	POP P,C
	POP P,B
	POP P,A
	JRST POPJ1

;IN DDT,  PRINTS MESSAGE & CAUSES ERROR, DOESN'T RETURN.
;OUTSIDE DDT, PRINTS MESSAGE, CAUSES DDT TO BE CALLED, RETURNS.
UERROR:	PUSHJ P,MERRV	;TURN ON TTY FOR ERROR MSG.
	SKIPN DEBUGP
	JRST UERRO1
	TTOA [ASCIZ/
10PC: /]
	MOVE B,(P)	;IF DEBUGGING,
	PUSHJ P,FOCTP	;PRINT ADDR AFTER ERROR UUO.
	CRF
UERRO1:	SKIPGE DDTPDP
	TTOA [ASCIZ/   /]
	TTOA (A)
	SKIPGE DDTPDP
	JRST DERR
	PUSHJ P,CLRRUN
	LDB B,[270400+P,,-1]
	JUMPE B,UUOXIT		;AC FIELD 0 - NO POPJS.
TXN[	MOVNI B,-POP14J(B)]
TXY[	MOVNI	B,B
	ADDI	B,POP14J
]
	HRRM B,(P)		;EXIT TO RTN TO POPJ SEVERAL TIMES.
	JRST UUOXIT

REPEAT 14.,REST POP14J
	RETURN
POP14J:	0		;EXCESS WDS ON PDL THROWN AWAY HERE.

TYI1:
TXN	.IOT TYIC,MB
TXY	PUSHJ P,PTYIC
	CAIN MB,^Q
	 JRST TYI4
	CAIE MB,^E
	 CAIN MB,^V
	  JRST TYI1
	CAIE MB,^B
	 CAIN MB,^W
	  JRST TYI1
	CAIE MB,^S
	 RETURN
	SETOM TYOFLG
	JRST TYI1

TYI4:
TXN	.IOT TYIC,MB
TXY	PUSHJ P,PTYIC
	RETURN

TXY[
PTYIC:	PUSH	P,A	; INPUT A CHARACTER INTO MB
	PBIN
	MOVE	MB,A
	POP	P,A
	POPJ	P,
]

TXN[
TSINTB:	SAVE [DYCINT]
DGLNCB:	SKIPN LPTFLG
	PUSHJ P,OPNLPT
	SETOM LPTFLG
	RETURN

TSINTE:	SAVE [DYCINT]
DGLNCE:	SKIPN LPTFLG
	RETURN
	SETZM LPTFLG
	JRST CLSLPT

CWALLP:	MOVEI A,LPTFIL	;^B TO FILE
	PUSHJ P,DGFIL
	PUSHJ P,OPNLPU
	SKIPE LPTFLG
	RETURN
	SETOM LPTFLG
	AOS LPTCNT
	RETURN

OPNLPT:	AOS C,LPTCNT
	SOJN C,CPOPJ
OPNLPU:	.OPEN LPTC,LPTFIL
	JRST .+2
	RETURN
	TSOPEN LPTC,TPLFIL
	TTOA [ASCIZ /USING TPL/]
	RETURN

TPLFIL:	SIXBIT /  !TPLWALL  PAPER/
]

ACORE:	HRRZ A,KCOUNT	;ATTACH CORE
	SKIPN T5
	JRST ACORE4
	CAIL A,MAXK
	JRST ACORE2
	LSH A,10.
	PUSHJ P,BLKGET
	PDP11(A)
	AOS KCOUNT
	SOJA T5,ACORE

ACORE2:	TTOI "?
ACORE4:	MOVEM A,QT
	LSH A,11.
	HRRM A,%CORE
	TTOA [ASCIZ /CORE = T.K
/]
	RETURN

DCORE:	HRRZ A,KCOUNT	;DETACH CORE
	SKIPN T5
	JRST ACORE4
	JUMPE A,ACORE2
	LSH A,10.
	PUSHJ P,BLKZAP
	PDP11-2000(A)
	SOS KCOUNT
	SOJA T5,DCORE

KCOUNT:	0

BLKGET:	PUSH P,MA	;GET CORE BLOCK
	PUSH P,MB
	MOVE MA,@-2(P)
	MOVEI MA,@MA
	LSH MA,-1
	TRZ MA,777
	IOR MA,[4000,,400000]
	MOVEM MA,QA
TXN[	.CBLK MA,
	 TTOA [ASCIZ /
BLKGET CBLK FAILED
A/]
]
	HLLZ MB,@-2(P)
	JUMPGE MB,POMBA1	;ALLOW NEG FROBS TO SET TO NXM
	LSH MA,1
	MOVEM MB,(MA)
	HRLS MA
	AOS MA
	HLRZ MB,MA
	BLT MA,1777(MB)
POMBA1:	POP P,MB
POMAJ1:	POP P,MA
	AOS (P)
	RETURN

BLKZAP:	PUSH P,MA	;FLUSH CORE BLOCK
	MOVE MA,@-1(P)
	MOVEI MA,@MA
	LSH MA,-1
	ANDI MA,377000
	MOVEM MA,QA
TXN[	.CBLK MA,
	 TTOA [ASCIZ /
BLKZAP CBLK FAILED
A/]
]
	JRST POMAJ1

;
;******************************************************************
;        THE SIMULATOR
;
INEZCF:	TROA PS,ZF\CF
INENEG:	TRO PS,NF

INEND:		;INSTRUCTION END
	CAMGE CPRI,@TRINF+1	;CHECK TRAP QUEUE
	 JRST QTRZAP
	CAML TIME,@CLINF+1	;CHECK CLOCK QUEUE
	 JRST QCLZAP
INBEG:
45Y[	MOVE MA,PC
	45IRMA
	SKIPGE I,PDP11(MA)]
45N	SKIPGE I,PDP11(PC)	;FETCH INSTRUCTION WORD
	 JSP D,MTRAPI
	HRRZM PC,OPC
TRPMOD:	LDB T,[061200,,I]	;(OR JRST TTRPIB) SEE NEWPS
	AOJA PC,@I1TAB(T)

45N[
TTRPIB:	CALL TTRPBJ
	LDB T,[061200,,I]
	AOJA PC,@I1TAB(T)]

;SIGN BIT => 2-ADDRESS INSN.
;4.8 BIT => WORD INSN.
;(BOTH USED BY PAGE-FAULT ROUTINES ONLY)
I1TAB:	I0000
	IJMP
	IRTS	;+IOPR
	MOVE ISWAB
	REPEAT 4,IBR
	REPEAT 4,IBNE
	REPEAT 4,IBEQ
	REPEAT 4,IBGE
	REPEAT 4,IBLT
	REPEAT 4,IBGT
	REPEAT 4,IBLE
	REPEAT 8,IJSR
	MOVE ICLR
	MOVE ICOM
	MOVE IINC
	MOVE IDEC
	MOVE INEG
	MOVE IADC
	MOVE ISBC
	MOVE ITST
	MOVE IROR
	MOVE IROL
	MOVE IASR
	MOVE IASL
	IMARK		;I45
	MOVE IMFPI
	MOVE IMTPI
	MOVE ISXT	;I45
	REPEAT 8,I1ILL
	REPEAT 64.,TRN IMOV
	REPEAT 64.,TRN ICMP
	REPEAT 64.,TRN IBIT
	REPEAT 64.,TRN IBIC
	REPEAT 64.,TRN IBIS
	REPEAT 64.,TRN IADD
	REPEAT 8,MOVE IIMUL	;I45
	REPEAT 8,MOVE IIDIV	;I45
	REPEAT 8,MOVE IASH	;I45
	REPEAT 8,MOVE IASHC	;I45
	REPEAT 8,MOVE IXOR	;I45
	REPEAT 16.,I1ILL
	REPEAT 8,ISOB	;I45
	REPEAT 4,IBPL
	REPEAT 4,IBMI
	REPEAT 4,IBHI
	REPEAT 4,IBLOS
	REPEAT 4,IBVC
	REPEAT 4,IBVS
	REPEAT 4,IBCC
	REPEAT 4,IBCS
	REPEAT 4,IEMT
	REPEAT 4,ITRAP
	ICLRB
	ICOMB
	IINCB
	IDECB
	INEGB
	IADCB
	ISBCB
	ITSTB
	IRORB
	IROLB
	IASRB
	IASLB
	IMTPS
	MOVE IMFPD
	MOVE IMTPD
	IMFPS
	REPEAT 8,I1ILL
	REPEAT 64.,SETZ IMOVB
	REPEAT 64.,SETZ ICMPB
	REPEAT 64.,SETZ IBITB
	REPEAT 64.,SETZ IBICB
	REPEAT 64.,SETZ IBISB
	REPEAT 64.,TRN ISUB
	REPEAT 64.,I1ILL

I1ILL:	ADDI TIME,15.
	JSP A,IILL

DBNDE:	SKIPL DBNDBK+1	;DELAYED BOUND ERROR
	JRST (D)
	MOVEM D,DBNDE.
	MOVEI A,DBNDBK
	MOVSI C,5
	CALL MTRDES
	JRST (D)

DBNDBK:	0
	-1
	JRST DBNDTR
DBNDE.:	0

DBNDTR:	MOVE A,DBNDE.
	SETOM ODDPC
	JRST BOUNDE

QTRZAP:	MOVE B,TRINF+1	;DO QUEUE'ED TRAP REQUEST
	MOVE A,1(B)
	SETOM 1(B)
	MOVEM A,TRINF+1
	XCT 2(B)
	JRST INEND

QCLZAP:	MOVE B,CLINF+1	;DO QUEUE'ED CLOCK REQUEST
	MOVE A,1(B)
	SETOM 1(B)
	MOVEM A,CLINF+1
	XCT 2(B)
	JRST INEND

45N[
TTRPBJ:	JSP A,MTRNEW
TTRPBK:	4,,
	-1
	JRST TTRAP
]

CLRRUN:	SETZM RUN
	JSP A,MTRNEW
TRUNBK:	2,,
	-1
	PUSHJ P,CLRRN2

CLRRN2:	PUSH P,[DDTXIT]
	SETOM DDONXT		; ;N WILL DO NEXT INSN.
	JRST DDT1


CNTINS:	SOSG INSCNT	;IF DID THAT MANY INSNS, STOP.
	JRST CNTIN2
	CAIN PC,@%CSN	;IF RETURNED FROM ;N, STOP.
	JRST CNTIN1
45Y[	MOVE MA,PC
	JRST INBEG+1]
45N[	SKIPGE I,PDP11(PC)
	JSP D,MTRAPI
	JRST INBEG+2]

CNTIN1:	HLLOS %CSN	;LEAVE ;N MODE.
CNTIN2:	TTOA [ASCIZ/
COUNT:  /]
	CALL CLRRN2
	JRST INBEG

;OPEN CODED BRANCH
DEFINE OBRANC X
	ADDI TIME,11.
IFB X,[	ANDI I,377
	ADD PC,BRAT(I)]
IFNB X,	ADD PC,BRAT-X(I)
	ANDI PC,77777
	OBRAN1
	TERMIN

;TERMINATE AN INSN THAT SETS THE PC.
DEFINE OBRAN1
	HRRZ B,OPC	;OR JRST INEND IF TRPPNT HOLDS 0,
			;OR JRST BRPNT IF IT HOLDS 2 OR 3.
	MOVEM B,JPC
	JRST INEND
	OBRAN2	;LINK ALL OBRAN1'S TOGETHER.
OBRAN2==.-1
TERMIN

OBRAN2==0

DEFINE IZNEND
	TRZ PS,16
	TRNE MB,100000
	JRST INENEG
	TRNN MB,177777
	TRO PS,ZF
	JRST INEND
	TERMIN

DEFINE IZMEND
	TRNE MB,100000
	JRST INENEG
	TRNN MB,177777
	TRO PS,ZF
	JRST INEND
	TERMIN

IBR:	ADDI TIME,26.
	ADD PC,BRAT-400(I)
	ANDI PC,77777
	OBRAN1

BRAT:	REPEAT 200,,.RPCNT
	REPEAT 200,,.RPCNT-200

IBNE:	ADDI TIME,15.
	TRNE PS,ZF
	JRST INEND
	OBRANC 1000

IBEQ:	ADDI TIME,15.
	TRNN PS,ZF
	JRST INEND
	OBRANC 1400

IBGE:	ADDI TIME,15.
IBGT2:	TRNN PS,NF\VF
	JRST BRANCH	;BOTH OFF
	TRNE PS,NF
	TRNN PS,VF
	JRST INEND
BRANCH:	OBRANC	;BOTH ON

IBLT:	ADDI TIME,15.
IBLE2:	TRNN PS,NF
	TRNN PS,VF
	JRST IBLT2
	OBRANC

IBLT2:	TRNE PS,NF
	TRNE PS,VF
	JRST INEND
	OBRANC

IBGT:	ADDI TIME,15.
	TRNE PS,ZF
	JRST INEND
	JRST IBGT2

IBLE:	ADDI TIME,15.
	TRNN PS,ZF
	JRST IBLE2
	OBRANC

IJSR:	ADDI TIME,44.
	ANDI I,77
	XCT JD2CWT(I)
	LSH PC,1
	XCT IJSRT-40(T)
	HRRM PC,R0-40(T)
	HRRZ PC,MA
	MOVE MA,R6
	SUBI MA,2
	CAMGE MA,RSLR1
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	TRNE MA,1
	JSP A,BOUNDE
	LSH MA,-1
	45DWMA
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM MB,PDP11(MA)
	OBRAN1

IJSRT:	REPEAT 7,MOVE MB,R0+.RPCNT
	SKIPA MB,PC

I0000:	JRST @I0000T(I)

I0000T:	IHALT
	IWAIT
	IRTI
	IBPT
	IIOT
	IRESET
	IRTT	;I45
	REPEAT 64.-7,I2ILL

I2ILL:	ADDI TIME,15.
	JSP A,IILL

IJMP:	ADDI TIME,12.
	ANDI I,77
	XCT JD2CWT(I)
	MOVE PC,MA
	OBRAN1

IMARK:	SKIPL WI45
	 JSP A,IILL
	ANDI I,77
	LSH I,1
	ADD I,R6
	ANDI I,177777
	HRRM I,R6
	MOVEI I,205	;DUMMY UP AN RTS %5
IRTS:	TRNE I,70
	JRST IOPR
	ADDI TIME,35.
	HRRZ MA,R6
	TRNE MA,1
	JSP A,BOUNDE
	LSH MA,-1
	45DRMA
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	XCT IRTST-200(I)
	HRRM MB,R0-200(I)
	TRNE PC,1
	JSP A,BOUNDE
	LSH PC,-1
	MOVEI MA,2	;INCREMENT THE STACK PTR.
	ADDM MA,R6
	OBRAN1

IRTST:	REPEAT 7,HRRZ PC,R0+.RPCNT
	SKIPA PC,MB

IOPR:	ADDI TIME,15.
	XCT OPRT-200(I)
	JRST INEND

OPRT:	REPEAT 24.,JSP A,IILL
	REPEAT 8,JRST ISPL	;I45
	JRST INEND
	REPEAT 15.,TRZ PS,.RPCNT+1
	JRST INEND
	REPEAT 15.,TRO PS,.RPCNT+1

ISPL:	SKIPL WI45
	 JSP A,IILL
45Y[	SKIPE 45MODE		;IGNORE EXCEPT IN KERNEL MODE..
	 JRST INEND]
	DPB I,[PRI,,PS]
	NEWPS
	JRST INEND

ISWAB:	ADDI TIME,23.
	XCT ODACWT-300(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	LDB T,[1000,,MB]
	LSH MB,-8
45Y	TRZ PS,17
45N	TRZ PS,17-VF
	XCT BYTRPS(MB)
	DPB T,[101000,,MB]
	HRRM MB,PDP11(MA)
	JRST INEND


IHALT:
45Y[	SKIPE 45MODE	;ILLEGAL EXCEPT IN KERNEL MODE.
	 JRST IHALTL]
	ADDI TIME,18.
	TTOA [ASCIZ *
HALT:   *]
	JRST DIEDIE

WAITTS==80000.	;WAIT TOO SHORT TIME
IWAIT:	SETOM WAITFL
	ADDI TIME,18.
	AOS INSCNT		;SINCE WILL RE-EXECUTE WAIT.
IWAIT0:	CAMGE CPRI,@TRINF+1
	SOJA PC,INEND	;PENDING TRAP
	MOVE MB,@CLINF+1
	SUB MB,TIME
	CAIGE MB,WAITTS
	SOJA PC,IWAITX	;TOO SHORT
	CAILE MB,200000.
	MOVEI MB,200000.	;WAS TOO LONG
	ADD TIME,MB
TXN[	IDIVI MB,20000.
IWAITS:	.SLEEP MB,
]
TXY[	IDIVI	MB,10000.
	IMULI	MB,30.
	MOVE	A,MB
IWAITS:	DISMS
]
	JRST IWAIT0

IWAITX:	MOVE TIME,@CLINF+1
	JRST INEND

WAITFL:	0

IRESET:
45Y[	SKIPE 45MODE		;IGNORE UNLESS KERNEL MODE
	 JRST INEND]
	ADDI TIME,200000.
	PUSHJ P,XRESET
	JRST INEND

XRESET:	PUSHJ P,ZLK
TXN	PUSHJ P,ZPK
	SKIPE WTK
	 PUSHJ P,ZTK
	SKIPE WTP
	 PUSHJ P,ZTP
TXN[
	SKIPE WPR
	 PUSHJ P,ZPR
	SKIPE WPP
	 PUSHJ P,ZPP
]
	SKIPE WEAE
	 PUSHJ P,AEAE
	SKIPE WI45
	 PUSHJ P,ZI45
TXN[	SKIPE WNGDIS
	 PUSHJ P,ANGDIS
	SKIPE WET
	 PUSHJ P,ZET
	SKIPE DMCNT
	 PUSHJ P,ZDM
	SKIPE WRK
	 CALL ZRK
	JRST ZDF
]
TXY	POPJ P,

IRTT:	SKIPL WI45
	 JSP A,IILL
	TDZA MB,MB
IRTI:	SETO MB,
	ADDI TIME,48.
	HRRZ MA,R6
	TRNE MA,1
	JSP A,BOUNDE
	LSH MA,-1
45Y	MOVE TT,MA
45Y	45DRMA
	SKIPGE PC,PDP11(MA)
	JSP D,MTRAPR
	TRNE PC,1
	JSP D,DBNDE
	LSH PC,-1
45N	AOS TT,MA
45Y	AOS MA,TT
	AOJ TT,
	45DRMA
	DPB TT,[011700,,R6]
45N	SKIPGE PS,PDP11(MA)
45Y	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
;IN 11-45, PROTECT CMODE,PMODE,REG SET, PRIORITY.
45Y[	SKIPN 45MODE	;BUT NOT IN KERNEL MODE.
	 TDZA PS,PS
	ANDI PS,45MMDS+340	;IOR THE OLD MODES WITH SPEC'D MODES.
	TRNN PS,100000	;IF HAD BEEN IN USER MODE,
	 TRZA PS,340
	TRZ TT,340	;DON'T CHANGE PRIORITY.
	IORI PS,(TT)	]
	NEWPS
	JUMPL MB,IRTI1
	TRNN PS,TF	;FOR RTT, SUPRESS T TRAP.
	 JRST IRTI1
		MOVE A,[LDB T,[061200,,I]]
	MOVEM A,TRPMOD
	MOVEI A,PSTRB	;DO 1 INSN THEN REEXAMINE PS.
	MOVE C,TIME
	AOJ C,
	CALL CTRDES
IRTI1:	OBRAN1

ICLR:	ADDI TIME,23.
	XCT ODACWT-5000(I)
	TRZ PS,13
	TRO PS,ZF
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HLLZS PDP11(MA)
	JRST INEND

ICOM:	ADDI TIME,23.
	XCT ODACWT-5100(I)
	TRO PS,CF
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRC MB,177777
	HRRM MB,PDP11(MA)
	IZNEND

IINC:	ADDI TIME,23.
	XCT ODACWT-5200(I)
	TRZ PS,16
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	AOS MB
	ANDI MB,177777
	HRRM MB,PDP11(MA)
	CAIN MB,100000	;CORRECT
	JRST IINC2
	IZMEND

IINC2:	TRO PS,VF\NF
	JRST INEND

IDEC:	ADDI TIME,23.
	XCT ODACWT-5300(I)
	TRZ PS,16
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	SOS MB
	ANDI MB,177777
	HRRM MB,PDP11(MA)
	CAIN MB,77777
	JRST IDEC2
	IZMEND

IDEC2:	TRO PS,VF
	JRST INEND

INEG:	ADDI TIME,23.
	XCT ODACWT-5400(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	MOVNS MB
	ANDI MB,177777
	HRRM MB,PDP11(MA)
	TRZ PS,17
	SKIPE MB
	 TRO PS,CF
	CAIN MB,100000
	 JRST INEG2
	IZMEND

INEG2:	TRO PS,VF\NF
	JRST INEND

ITST:	ADDI TIME,23.
	XCT ODACRT-5700(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	TRZ PS,17
	IZMEND

IADC:	ADDI TIME,23.
	XCT ODACWT-5500(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRNE PS,CF
	JRST IADC2
	IZNEND

IADC2:	TRZ PS,17
	AOS MB
	TRZ MB,200000
	HRRM MB,PDP11(MA)
	JUMPE MB,INEZCF
	CAIN MB,100000
	JRST IADC5
	IZMEND

IADC5:	TRO PS,VF\NF
	JRST INEND

ISBC:	ADDI TIME,23.
	XCT ODACWT-5600(I)
	SKIPGE MB,PDP11(MA)
	 JSP D,MTRPW
	TRNE PS,CF
	 JRST ISBC2
	TRZ PS,17
	IZMEND

ISBC2:	TRZ PS,17
	SOS MB
	ANDI MB,177777
	HRRM MB,PDP11(MA)
	CAIN MB,77777
	 JRST ISBC4
	CAIN MB,177777
	 IORI PS,CF
	IZMEND

ISBC4:	TRO PS,VF
	JRST INEND

45N[
DEFINE ROTPSX
	XCT ROTPST(PS)
	JRST INEND
TERMIN

ROTPST:	REPEAT 16.,[
REPEAT 4,	JRST INEND ? TRO PS,VF
REPEAT 4,	TRO PS,VF ? JRST INEND
]
]
45Y[
DEFINE ROTPSX
	TRNN PS,NF
	 XORI PS,VF
	TRNN PS,CF
	 XORI PS,VF
	JRST INEND
TERMIN ]
IROR:	ADDI TIME,23.
	XCT ODACWT-6000(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	MOVE T,PS
	TRZ PS,17
	TRNE MB,1
	TRO PS,CF
	LSH MB,-1
	TRNE T,CF
	TRO MB,100000
	HRRM MB,PDP11(MA)
	SKIPN MB
	TRO PS,ZF
	TRNE MB,100000
	TRO PS,NF
	ROTPSX

IROL:	ADDI TIME,23.
	XCT ODACWT-6100(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	MOVE T,PS
	TRZ PS,17
	TRZE MB,100000
	TRO PS,CF
	LSH MB,1
	TRNE T,CF
	TRO MB,1
	HRRM MB,PDP11(MA)
	SKIPN MB
	TRO PS,ZF
	TRNE MB,100000
	TRO PS,NF
	ROTPSX

IASR:	ADDI TIME,23.
	XCT ODACWT-6200(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRZ PS,17
	TRNE MB,1
	TRO PS,CF
	LSH MB,-1
	TRNE MB,40000
	TRO MB,100000
	HRRM MB,PDP11(MA)
	SKIPN MB
	TRO PS,ZF
	TRNE MB,100000
	TRO PS,NF
	ROTPSX

IASL:	ADDI TIME,23.
	XCT ODACWT-6300(I)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	TRZ PS,17
	TRZE MB,100000
	TRO PS,CF
	LSH MB,1
	HRRM MB,PDP11(MA)
	SKIPN MB
	TRO PS,ZF
	TRNE MB,100000
	TRO PS,NF
	ROTPSX

ISXT:	SKIPL WI45
	 JSP A,IILL
	ADDI TIME,22.		;EST
	XCT ODACWT-6700(I)
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	TRNE PS,NF
	JRST ISXT2
	TRO PS,ZF
	HLLZS PDP11(MA)
	TRZ PS,VF
	JRST INEND

ISXT2:	TRZ PS,ZF\VF
	MOVEI MB,177777
	HRRM MB,PDP11(MA)
	JRST INEND

IMOV:	ADDI TIME,23.
	XCT OSACWT-100(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM MB,PDP11(MA)
	IZNEND

ICMP:	ADDI TIME,22.	;TIME APPROX
	XCT OSACWT-200(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	LSH MB,20.
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	LSH TT,20.
ICMPB2:	SETCMM MB
	JFCL 17,.+1
	ADD MB,TT
	SETCMM MB
	TRZ PS,17
	JFCL 10,ICMP2
	JFCL 4,ICMP4
	JUMPG MB,INEND
	JUMPL MB,INENEG
	TRO PS,ZF
	JRST INEND

ICMP2:	TROA PS,VF
ICMP4:	TROA PS,CF
	JFCL 4,.-1
	JUMPG MB,INEND
	JUMPL MB,INENEG
	TRO PS,ZF
	JRST INEND

IBIT:	ADDI TIME,28.	;TIME APPROX
	XCT OSACWT-300(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	AND MB,TT
	IZNEND

IBIC:	ADDI TIME,29.
	XCT OSACWT-400(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	ANDCA MB,TT
	HRRM MB,PDP11(MA)
	IZNEND

IXOR:	SKIPL WI45
	 JSP A,IILL
	ADDI TIME,23.	;EST
	CAIN T,747	;R7 AS SOURCE IS SPECIAL.
	SKIPA MB,PC
	SKIPA MB,R0-740(T)
	LSH MB,1	;R7 MUST BE SHIFTED, BUT NOT OTHER ACS.
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	XOR MB,TT
	HRRM MB,PDP11(MA)
	IZNEND

IIMUL:	SKIPL WI45
	 JSP A,IILL
	ADDI TIME,80.		;EST
	HRRZ MB,R0-700(T)
	TRNE MB,100000
	ORCMI MB,177777
	ANDI I,77
	XCT OD2CRT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	TRNE TT,100000
	ORCMI TT,177777
	TRZ PS,17
	IMUL MB,TT
	SKIPN MB
	TRO PS,ZF
	ROT MB,-20
	DPB MB,[2000,,R0-700(T)]
	TRO T,1
	ROT MB,20
	DPB MB,[2000,,R0-700(T)]
	JUMPE MB,INEND
	CAME MB,[-1]
	TRO PS,CF
	JRST INEND

IIDIV:	SKIPL WI45
	 JSP A,IILL
	ADDI TIME,160.		;EST
	TRZ PS,17
	ANDI I,77
	XCT OD2CRT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	TRNN T,177777
	JRST IIDIV2
	TRNE TT,100000
	ORCMI TT,177777
	HRRZ MB,R0-710(T)
	TRNE MB,100000
	ORCMI MB,177777
	MOVE D,T
	TRO T,1
	HRRZ MA,R0-710(T)
	ASH MB,20
	IOR MB,MA
	IDIV MB,TT
	CAML MB,[-1,,600000]
	CAIL MB,100000
	JRST IIDIV4
	DPB MB,[2000,,R0-710(D)]
	TRO D,1
	DPB MA,[2000,,R0-710(D)]
	IZNEND

IIDIV2:	SUBI TIME,120.	;DIVIDE BY ZERO
	TRO PS,VF\CF
	JRST INEND

IIDIV4:	SUBI TIME,80.		;OVERFLOW
	TRO PS,VF
	JRST INEND

ISOB:	SKIPL WI45
	 JSP A,IILL
	ADDI TIME,23.		;EST
	HRRZ MB,R0-770(T)
	SOJE MB,ISOB2
	HRRM MB,R0-770(T)
	ANDI I,77
	SUB PC,I
	ANDI PC,77777
	JRST INEND

ISOB2:	ANDI MB,177777
	HRRM MB,R0-770(T)
	JRST INEND

IASH:	SKIPL WI45
	 JSP A,IILL
	ADDI TIME,24.		;EST
	HRRZ MB,R0-720(T)
	LSH MB,2
	HRREI MB,(MB)
	ANDI I,77
	XCT OD2CRT(I)
	SKIPGE I,PDP11(MA)
	 JSP D,MTRAPR
	TRNE I,40
	JRST IASH2
	ANDI I,77
	HLRZ TT,MB
	ASH MB,(I)
	TRZ PS,17
	TLNE MB,1
	TRO PS,CF
	XCT (TT)[CAMGE MB,[-400000]
		CAIL MB,400000]+1
	TRO PS,VF
IASH4:	LSH MB,-2
	DPB MB,[2000,,R0-720(T)]
	IZMEND

IASH2:	TRO I,777700
	ASH MB,(I)
	TRZ PS,17
	TRNE MB,2
	TRO PS,CF
	JRST IASH4

IASHC:	SKIPL WI45
	 JSP A,IILL
	ADDI TIME,30.		;EST
	HRL TT,R0-730(T)
	SAVE T
	TRO T,1
	HRRZ MB,R0-730(T)
	ASH MB,2
	HLL MB,TT
	LSH MB,2
	ANDI I,77
	XCT OD2CRT(I)
	SKIPGE I,PDP11(MA)
	 JSP D,MTRAPR
	ANDI I,77
	TRNE I,40
	JRST IASHC2
	ASH MB,-2(I)
	TRZ PS,17
	TLNE MB,200000
	TRO PS,CF
	XOR TT,MB
	TLNE MB,100000
	TRO PS,VF
IASHC4:	SKIPN MB
	TRO PS,ZF
	REST D
	ROT MB,-22
	DPB MB,[2000,,R0-730(D)]
	ROT MB,20
	TRO D,1
	DPB MB,[2000,,R0-730(D)]
	TLNE MB,100000
	JRST INENEG
	JRST INEND

IASHC2:	TRO I,777700
	ASH MB,-2(I)
	TRZ PS,17
	TRNE MB,2
	TRO PS,CF
	JRST IASHC4

45Y[
IMFPI:	ANDI I,77
	TRNN I,70	;REGISTER DESTINATIONS SPECIAL.
	 JRST IMFPD3
	XCT JD2CWT(I)	;CALC. ADDRESS, IN CURRENT MODE.
	LDB T,[45PMOD,,PS] ;FIND WHICH MODE TO MOVE FROM.
IMFPD5:	LDB D,[SEGBP,,MA]
	XCT @IMFPI1(T)	;THESE INSNS DO 45IRMA BUT IN THAT MODE.
	XCT 45FDA,@IMFPI2(T)
	 JSP A,45ASL
IMFPD0:	SKIPGE MB,PDP11(MA)	;GET THE LOCATION MAPPED.
	 JSP D,MTRAPR
	HRRZ MA,R6
	SUBI MA,2
	ANDI MA,177777	;PREPARE TO PUSH ON STACK.
	HRRZI TT,(MA)
	LSH MA,-1
	45DWMA 45FDA
	SKIPGE PDP11(MA)
	 JSP D,MTRAPW
	HRRM MB,PDP11(MA)
	HRRM TT,R6
	IZNEND		;SET FLAGS & RETURN.

IMFPD3:	LDB T,[45PMOD,,PS]
	CAME T,45MODE
	CAIE I,6	;FOR REGISTER 6 IN SOME OTHER MODE,
	 JRST IMFPD4
	MOVEI MA,45REG6-PDP11(T)	;FIND IT IN ITS SPECIAL HOME.
	JRST IMFPD0

IMFPD4:	MOVEI T,1(I)	;ANY OTHER REGISTER DEST, PRETEND TO
	MOVEI I,26
	JRST IMOV	;BE A MOV INSN.

IMFPD:	ANDI I,77
	TRNN I,70
	 JRST IMFPD3
	XCT JD2CWT(I)
	LDB T,[45PMOD,,PS]
	MOVE D,45DSNB(T) ;IF PREV. MODE'S DATA SPACE IS DISABLED
	TDNN D,RSSR3	;REFER TO I SPACE INSTEAD.
	 JRST IMFPD5
	LDB D,[SEGBP,,MA]
	XCT 1,@IMFPD1(T)
	XCT 45FDA,@IMFPD2(T)
	 JSP A,45ASL
	JRST IMFPD0

IMFPI1:	45IRK1(D) ? 45IRS1(D) ? @45IWXX ? 45IRU1(D)
IMFPI2:	45IRK2(D) ? 45IRS2(D) ? @45IWXX ? 45IRU2(D)

IMFPD1:	45DRK1(D) ? 45DRS1(D) ? @45IWXX ? 45DRU1(D)
IMFPD2:	45DRK2(D) ? 45DRS2(D) ? @45IWXX ? 45DRU2(D)

IRPS AA,,I D
IFE .IRPCN,IMTPI:
.ELSE IMTPD:		;NOT IMTP!AA: SO THAT TECO @ WILL SEE LABEL.
	HRRZ MA,R6
	LSH MA,-1
	45DRMA		;GET THE WD ON BOTTOM OF STACK.
	SKIPGE MB,PDP11(MA)
	 JSP D,MTRAPR
	HRRZ MA,R6	;INCREMENT STACK PTR.
	ADDI MA,2
	DPB MA,[2000,,R6]
	ANDI I,77
	TRNN I,70
	 JRST IMTPI3	;SPECIAL FOR REGISTER DESTINATION.
	SETOM IMTPR6	;PAGE FAULT SHOULD KNOW R6 WAS INCR'D.
	XCT JD2CWT(I)	;NOW CALCULATE THE ADDR, IN CURRENT MODE,
	LDB T,[45PMOD,,PS]
IFN .IRPCN,[MOVE D,45DSNB(T) ;IF MTPD BUT PREVIOUS MODE'S D-SPACE DISABLED,
	TDNN D,RSSR3
	 JRST IMTPD8]	;REFER TO I-SPACE INSTEAD.
.ELSE IMTPD8:
	LDB D,[SEGBP,,MA]
	XCT .IRPCN,@IMTP!AA!1(T)
	XCT 45FDA,@IMTP!AA!2(T)	;45MTP SAYS R6 WAS INCREMENTED (IN CASE PG FLT)
	 JSP A,45ASL
	SETZM IMTPR6
IMTP!AA!7:	SKIPGE PDP11(MA)
	 JSP D,MTRAPW
	HRRM MB,PDP11(MA)
	IZNEND

IMTP!AA!1:
	45!AA!WK1(D) ? 45!AA!WS1(D) ? @45IWXX ? 45!AA!WU1(D)
IMTP!AA!2:
	45!AA!WK2(D) ? 45!AA!WS2(D) ? @45IWXX ? 45!AA!WU2(D)
TERMIN

IMTPI3:	CAIE I,6	;MTPI SAME AS MTPD FOR REGISTER.
	 JRST IMTPI4
	LDB T,[45PMOD,,PS]	;REGISTER IS R6,
	CAMN T,45MODE	;IF CURRENT MD = PREV, FIND R6 LIKE OTHER REGS.
	 JRST IMTPI5
	MOVEI MA,45REG6-PDP11(T)	;ELSE FIND IT WHERE IT'S SWAPPED OUT.
	JRST IMTPI7

IMTPI4:	CAIN I,7
	 JRST IMTPI6	;MTPI %7
IMTPI5:	MOVEI MA,R0-PDP11(I)	;DEST. IS ORDINARY REGISTER.
	JRST IMTPI7

IMTPI6:	ROT MB,-1	;MTPI %7
	HRRZ PC,MB
	JUMPGE MB,.+2
	 JSP D,DBNDE	;CAUSE ABORT BEFORE NEXT INSN FOR ODD PC.
	IZNEND

IMTPR6:	0	;-1 DURING IMTPI, IMTPD SAYING R6 WAS INCR'D
		;SO SSR1 CAN BE SET RIGHT IN CASE PAGE FAULT.
]	;END 45Y

45N IMFPI==I1ILL ? IMFPD==I1ILL ? IMTPI==I1ILL ? IMTPD==I1ILL

IADD:	ADDI TIME,23.
	XCT OSACWT-600(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	LSH MB,20.
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	LSH TT,20.
	JFCL 17,.+1
	ADD MB,TT
	LSH MB,-2
	HLRM MB,PDP11(MA)
	TRZ PS,17
	JFCL 10,IADD2
	JFCL 4,IADD4
	TLNE MB,100000	;DATA IN LEFT HALF
	JRST INENEG
	TLNN MB,177777
	TRO PS,ZF
	JRST INEND

IADD2:	TROA PS,VF
IADD4:	TROA PS,CF
	JFCL 4,.-1
	TLNE MB,100000	;DATA IN LEFT HALF
	JRST INENEG
	TLNN MB,177777
	TRO PS,ZF
	JRST INEND

ISUB:	ADDI TIME,23.
	XCT OSACWT-1600(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	LSH MB,20.
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	LSH TT,20.
	SETCMM TT
	JFCL 17,.+1
	ADD MB,TT
	SETCMM MB
	LSH MB,-2
	HLRM MB,PDP11(MA)
	TRZ PS,17
	JFCL 10,IADD2
	JFCL 4,IADD4
	TLNE MB,100000	;DATA IN LEFT HALF
	JRST INENEG
	TLNN MB,177777
	TRO PS,ZF
	JRST INEND

IBIS:	ADDI TIME,23.
	XCT OSACWT-500(T)
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	ANDI I,77
	XCT OD2CWT(I)
	SKIPGE PDP11(MA)
	JSP D,MTRPW
	IORB MB,PDP11(MA)
	IZNEND

IBPL:	ADDI TIME,15.
	TRNE PS,NF
	JRST INEND
	OBRANC 100000

IBMI:	ADDI TIME,15.
	TRNN PS,NF
	JRST INEND
	OBRANC 100400

IBHI:	ADDI TIME,15.
	TRNE PS,CF\ZF
	JRST INEND
	OBRANC 101000

IBLOS:	ADDI TIME,15.
	TRNN PS,CF\ZF
	JRST INEND
	OBRANC 101400

IBVC:	ADDI TIME,15.
	TRNE PS,VF
	JRST INEND
	OBRANC 102000

IBVS:	ADDI TIME,15.
	TRNN PS,VF
	JRST INEND
	OBRANC 102400

IBCC:	ADDI TIME,15.
	TRNE PS,CF
	JRST INEND
	OBRANC 103000

IBCS:	ADDI TIME,15.
	TRNN PS,CF
	JRST INEND
	OBRANC 103400

	TRO PS,NF	;-1
BYTEPS:	TRO PS,ZF
	REPEAT 177,JRST INEND
	REPEAT 200,TRO PS,NF
	TRO PS,ZF	;400

	TRO PS,NF
BYTVPS:	TRO PS,ZF
	REPEAT 177,JFCL
	IORI PS,NF\VF
	REPEAT 177,TRO PS,NF
	TRO PS,ZF

BYTRPS:	TRO PS,ZF
	REPEAT 177,JFCL
	REPEAT 200,TRO PS,NF

ICLRB:	ADDI TIME,23.
	XCT ODACBW-105000(I)
	MOVEI X,0
	TRZ PS,13
	TRO PS,4
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	MOVEI MB,0
	DPB MB,11BYTE(X)
	JRST INEND

ICOMB:	ADDI TIME,23.
	XCT ODACBW-105100(I)
	MOVEI X,0
	TRZ PS,16
	TRO PS,CF
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRC MB,377
	DPB MB,11BYTE(X)
	XCT BYTEPS(MB)
	JRST INEND

IINCB:	ADDI TIME,23.
	XCT ODACBW-105200(I)
	MOVEI X,0
	TRZ PS,16
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	AOS MB
	DPB MB,11BYTE(X)
	XCT BYTVPS(MB)
	JRST INEND

IDECB:	ADDI TIME,23.
	XCT ODACBW-105300(I)
	MOVEI X,0
	TRZ PS,16
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	SOS MB
	DPB MB,11BYTE(X)
	CAIN MB,177
	 TROA PS,VF
	XCT BYTEPS(MB)
	JRST INEND

INEGB:	ADDI TIME,23.
	XCT ODACBW-105400(I)
	MOVEI X,0
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	MOVNS MB
	DPB MB,11BYTE(X)
	ANDI MB,377
	TRZ PS,17
	CAIE MB,
	 TROA PS,CF
	TROA PS,ZF
ISBCB4:	XCT BYTVPS(MB)
	JRST INEND

ITSTB:	ADDI TIME,23.
	XCT ODACBR-105700(I)
	MOVEI X,0
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	XCT 11BFIX(X)
	TRZ PS,17
	XCT BYTEPS(MB)
	JRST INEND

IADCB:	ADDI TIME,23.
	XCT ODACBW-105500(I)
	MOVEI X,0
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRNE PS,CF
	JRST IADCB2
	TRZ PS,17
	XCT BYTEPS(MB)
	JRST INEND

IADCB2:	TRZ PS,17
	AOS MB
	DPB MB,11BYTE(X)
	CAIN MB,400
	 TROA PS,ZF\CF
	XCT BYTVPS(MB)
	JRST INEND

ISBCB:	ADDI TIME,23.
	XCT ODACBW-105600(I)
	MOVEI X,0
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TROE PS,CF
	JRST ISBCB2
	TRZ PS,17
	XCT BYTEPS(MB)
	JRST INEND

ISBCB2:	TRZ PS,16
	SOS MB
	DPB MB,11BYTE(X)
	JUMPN MB,ISBCB4
	XORI PS,ZF\CF
	JRST INEND

IRORB:	ADDI TIME,23.
	XCT ODACBW-106000(I)
	MOVEI X,0
	SKIPE X
	ADDI TIME,6	;1.2
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	MOVE T,PS
	TRZ PS,17
	TRNE MB,1
	TRO PS,CF
	LSH MB,-1
	TRNE T,CF
	TRO MB,200
	DPB MB,11BYTE(X)
	XCT BYTRPS(MB)
	ROTPSX

IROLB:	ADDI TIME,23.
	XCT ODACBW-106100(I)
	MOVEI X,0
	SKIPE X
	ADDI TIME,6	;1.2
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	MOVE T,PS
	TRZ PS,17
	TRZE MB,200
	TRO PS,CF
	LSH MB,1
	TRNE T,CF
	TRO MB,1
	DPB MB,11BYTE(X)
	XCT BYTRPS(MB)
	ROTPSX

IASRB:	ADDI TIME,23.
	XCT ODACBW-106200(I)
	MOVEI X,0
	SKIPE X
	ADDI TIME,6	;1.2
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRZ PS,17
	TRNE MB,1
	TRO PS,CF
	LSH MB,-1
	TRNE MB,100
	TRO MB,200
	DPB MB,11BYTE(X)
	XCT BYTRPS(MB)
	ROTPSX

IASLB:	ADDI TIME,23.
	XCT ODACBW-106300(I)
	MOVEI X,0
	SKIPE X
	ADDI TIME,6	;1.2
	SKIPGE MB,PDP11(MA)
	JSP D,MTRPW
	XCT 11BFIX(X)
	TRZ PS,17
	TRZE MB,200
	TRO PS,CF
	LSH MB,1
	DPB MB,11BYTE(X)
	XCT BYTRPS(MB)
	ROTPSX

45Y[
ROTPST:	REPEAT 16.,[REPEAT 4,[JRST INEND
	TRO PS,VF
]
	REPEAT 4,[TRO PS,VF
	JRST INEND
]]
]

DEFINE IZZBND
	TRZ PS,NF\ZF\VF
	ANDI MB,377
	XCT BYTEPS(MB)
	JRST INEND
	TERMIN

IMOVB:	ADDI TIME,23.
	XCT OSACBT-1100(T)
	ANDI I,77
	XCT OD2CBW(I)
	 JRST IMOVBR		;REGISTER DESTINATION
	SKIPGE PDP11(MA)
	 JSP D,MTRAPW
	DPB MB,11BYTE(X)
	IZZBND

IMOVBR:	ANDI MB,377
	TRNE MB,200
	TRO MB,177400
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM MB,PDP11(MA)
	IZZBND


IMFPS:	ADDI TIME,23.		; EST.
	MOVE MB,PS
	XCT OD2CBW-106700(I)
	 JRST IMOVBR		; REGISTER DESTINATION
	SKIPGE PDP11(MA)
	 JSP D,MTRAPW
	DPB MB,11BYTE(X)
	IZZBND


IMTPS:	ADDI TIME,23.		; EST.
	XCT ODACBR-106400(I)
	 MOVEI X,0
	SKIPGE MB,PDP11(MA)
	 JSP D,MTRAPR
	XCT 11BFIX(X)
	DPB MB,[1000,,PS]
	TRZ PS,NF\ZF\VF
	XCT BYTEPS(MB)
	NEWPS
	JRST INEND


ICMPB:	ADDI TIME,22.		;APPROX
	XCT OSACBT-1200(T)
	LSH MB,28.
	ANDI I,77
	XCT OD2CBR(I)
	MOVEI X,0
	SKIPGE PDP11(MA)
	JSP D,MTRAPR
	LDB TT,11BYTE(X)
	LSH TT,28.
	JRST ICMPB2

IBITB:	ADDI TIME,28.
	XCT OSACBT-1300(T)
	ANDI I,77
	XCT OD2CBR(I)
	MOVEI X,0
	SKIPGE TT,PDP11(MA)
	JSP D,MTRAPR
	SKIPE X
	LSH TT,-8
	AND MB,TT
	IZZBND

IBICB:	ADDI TIME,29.
	XCT OSACBT-1400(T)
	ANDI I,77
	XCT OD2CBW(I)
	MOVEI X,0
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	SKIPE X
	LSH TT,-8
	ANDCA MB,TT
	DPB MB,11BYTE(X)
	IZZBND

IBISB:	ADDI TIME,23.
	XCT OSACBT-1500(T)
	ANDI I,77
	XCT OD2CBW(I)
	MOVEI X,0
	SKIPGE TT,PDP11(MA)
	JSP D,MTRPW
	SKIPE X
	LSH TT,-8
	IOR MB,TT
	DPB MB,11BYTE(X)
	IZZBND

11BYTE:	1000,,PDP11(MA)
	101000,,PDP11(MA)

11BFIX:	ANDI MB,377
	LSH MB,-8

OSACBT:	REPEAT 7,HRRZ MB,R0+.RPCNT
	JSP E,SABPC
	REPEAT 7,JSP E,SABRD
	JSP E,SABRD7
	REPEAT 6,JSP E,SACBI
	JSP E,SACBI6
	JSP E,SACBI7
	REPEAT 7,JSP E,SABID
	JSP E,SABID7
	REPEAT 6,JSP E,SACBD
	JSP E,SACBD6
	JSP E,SACBD7
	REPEAT 6,JSP E,SABDD
	JSP E,SABDD6
	JSP E,SABDD7
	REPEAT 7,JSP E,SACBX
	JSP E,SACBX7
	REPEAT 7,JSP E,SABXD
	JSP E,SABXD7

DEFINE SACBXX X1
	LSHC MA,-1
	45DRMA X1
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	JUMPGE X,(E)
	ADDI TIME,6
	LSH MB,-8
	JRST (E)
	TERMIN

SABPC:	HRRZ MB,PC
	LSH MB,1
	JRST (E)

SABRD:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-10(T)
	SACBXX

SABRD7:	ADDI TIME,15.
45Y	MOVE MA,PC
45Y	45IRMA
45Y	SKIPGE MB,PDP11(MA)
45N	SKIPGE MB,PDP11(PC)
	JSP D,MTRAPR
	JRST (E)

SACBI:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-20(T)
	MOVEI TT,1(MA)
	ANDI TT,177777
	HRRM TT,R0-20(T)
	SACBXX 45FSA

SACBI6:	ADDI TIME,15.
	HRRZ MA,R6
	MOVEI TT,2(MA)
	ANDI TT,177777
	HRRM TT,R6
	SACBXX 45FSA

SACBI7:	ADDI TIME,15.
45Y[	MOVE MA,PC
	45IRMA
	SKIPGE MB,PDP11(MA)]
45N	SKIPGE MB,PDP11(PC)
	JSP D,MTRAPR
	AOJA PC,(E)

SABID:	ADDI TIME,27.
	ANDI T,77
	MOVE TT,R0-30(T)
	MOVEI MA,2(TT)
	ANDI MA,177777
	HRRM MA,R0-30(T)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FSA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX 45FSA

SABID7:	ADDI TIME,27.
	45PCINC TT,MA
	SACBXX

SACBD:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-40(T)
	SOJGE MA,.+2
	MOVEI MA,177777
	HRRM MA,R0-40(T)
	SACBXX 45FSA

SACBD6:	ADDI TIME,15.
	HRRZ MA,R6
	SUBI MA,2
	CAMGE MA,RSLR1
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	SACBXX 45FSA

SACBD7:	ADDI TIME,15.
	SOSGE MA,PC
	JRST SABD72
SABD74:	45IRMA
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	JRST(E)

SABD72:	MOVEI MA,77777
	MOVEI PC,77777
	JRST SABD74

SABDD:	ADDI TIME,27.
	ANDI T,77
	MOVE TT,R0-50(T)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(T)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
SBDD72:	45DRTT 45FSA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX 45FSA

SABDD6:	ADDI TIME,27.
	HRRZ TT,R6
	SUBI TT,2
	CAIGE TT,RSLR1
	JSP D,HPDLO1
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FSA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX 45FSA

SABDD7:	ADDI TIME,27.
	SOSL TT,PC
	JRST SBDD72
	MOVEI PC,77777
	MOVEI TT,77777
	JRST SBDD72

SACBX:	ADDI TIME,27.
	45PCINC TT,MA
	ANDI T,77
	ADD MA,R0-60(T)
	TRZ MA,200000
	SACBXX

SACBX7:	ADDI TIME,27.
	45PCINC TT,MA
	LSHC MA,-1
	ADD MA,PC
	TRZ MA,100000
	45DRMA
	SKIPGE MB,PDP11(MA)
	JSP D,MTRAPR
	JUMPGE X,(E)
	ADDI TIME,6
	LSH MB,-8
	JRST (E)

SABXD:	ADDI TIME,39.
	45PCINC MA,TT
	ANDI T,77
	ADD TT,R0-70(T)
	TRZ TT,200000
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX

SABXD7:	ADDI TIME,39.
	45PCINC MA,TT
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	45DRTT
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	SACBXX

IF1 [
;ASSEMBLE ADDRESSING ROUTINES FOR DESTINATION BYTE.
;TYPE IS R OR W FOR READ OR WRITE.
DEFINE DACBZZ TYPE

ODACB!TYPE:
	REPEAT 8,MOVEI MA,R0-PDP11+.RPCNT
	REPEAT 6,JSP E,DACB!TYPE-DACBR+DABRD
	JSP E,DACB!TYPE-DACBR+DABRD
	JSP E,DACB!TYPE-DACBR+DABRD7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+DACBI
	JSP E,DACB!TYPE-DACBR+DACBI6
	JSP E,DACB!TYPE-DACBR+DACBI7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+DABID
	JSP E,DACB!TYPE-DACBR+DABID
	JSP E,DACB!TYPE-DACBR+DABID7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+DACBD
	JSP E,DACB!TYPE-DACBR+DACBD6
	JSP E,DACB!TYPE-DACBR+DACBD7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+DABDD
	JSP E,DACB!TYPE-DACBR+DABDD6
	JSP E,DACB!TYPE-DACBR+DABDD7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+DACBX
	JSP E,DACB!TYPE-DACBR+DACBX
	JSP E,DACB!TYPE-DACBR+DACBX7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+DABXD
	JSP E,DACB!TYPE-DACBR+DABXD
	JSP E,DACB!TYPE-DACBR+DABXD7

OD2CB!TYPE:
	REPEAT 8,MOVEI MA,R0-PDP11+.RPCNT
	REPEAT 6,JSP E,DACB!TYPE-DACBR+D2BRD
	JSP E,DACB!TYPE-DACBR+D2BRD
	JSP E,DACB!TYPE-DACBR+DABRD7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+D2CBI
	JSP E,DACB!TYPE-DACBR+DACBI6
	JSP E,DACB!TYPE-DACBR+DACBI7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+D2BID
	JSP E,DACB!TYPE-DACBR+D2BID
	JSP E,DACB!TYPE-DACBR+DABID7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+D2CBD
	JSP E,DACB!TYPE-DACBR+DACBD6
	JSP E,DACB!TYPE-DACBR+DACBD7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+D2BDD
	JSP E,DACB!TYPE-DACBR+DABDD6
	JSP E,DACB!TYPE-DACBR+DABDD7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+D2CBX
	JSP E,DACB!TYPE-DACBR+D2CBX
	JSP E,DACB!TYPE-DACBR+DACBX7
	REPEAT 6,JSP E,DACB!TYPE-DACBR+D2BXD
	JSP E,DACB!TYPE-DACBR+D2BXD
	JSP E,DACB!TYPE-DACBR+DABXD7

DEFINE DACBXX X1
	IDIVI MA,2
	45D!TYPE!MA [<IFB X1,[45FDN]+X1>]
	JUMPE X,1(E)
	ADDI TIME,6
	JRST 1(E)
	TERMIN

DACB!TYPE:	OFFSET DACBR-.
;THESE LABELS ALL GET ASSEMBLED TWICE.
;THE OFFSET IS SO THEY GET THE SAME VALUE BOTH TIMES.
;THE ONLY DIFFERENCE BETWEEN THE TWO SETS OF ROUTINES
;IS THAT ONE HAS 45DRMA, ETC. AND THE OTHER HAS 45DWMA, ETC.

DABRD:	ANDI I,77
D2BRD:	ADDI TIME,14.
	MOVE MA,R0-10(I)
	DACBXX

DABRD7:	ADD TIME,14.
	HRRZ MA,PC
	45I!TYPE!MA
	JRST (E)

DACBI:	ANDI I,77
D2CBI:	ADDI TIME,14.
	MOVE MA,R0-20(I)
	MOVEI TT,1(MA)
	ANDI TT,177777
	HRRM TT,R0-20(I)
	DACBXX 45FDA

DACBI6:	ADDI TIME,14.
	HRRZ MA,R6
	MOVEI TT,2(MA)
	ANDI TT,177777
	HRRM TT,R6
	DACBXX 45FDA

DACBI7:	ADDI TIME,14.
	MOVE MA,PC
	45I!TYPE!MA
	AOJA PC,(E)

DABID:	ANDI I,77
D2BID:	ADDI TIME,26.
	MOVE TT,R0-30(I)
	MOVEI MA,2(TT)
	ANDI MA,177777
	HRRM MA,R0-30(I)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX 45FDA

DABID7:	ADDI TIME,26.
	45PCINC TT,MA
	DACBXX

DACBD:	ANDI I,77
D2CBD:	ADDI TIME,14.
	MOVE MA,R0-40(I)
	SOJGE MA,.+2
	MOVEI MA,177777
	HRRM MA,R0-40(I)
	DACBXX 45FDA

DACBD6:	ADDI TIME,14.
	HRRZ MA,R6
	SUBI MA,2
	CAMGE MA,RSLR1
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	DACBXX 45FDA

DACBD7:	ADDI TIME,14.
	SOSL MA,PC
45Y	JRST .+3
45N	JRST (E)
	MOVEI MA,77777
	MOVEI PC,77777
	45I!TYPE!MA
	JRST (E)
	
DABDD:	ANDI I,77
D2BDD:	ADDI TIME,26.
	MOVE TT,R0-50(I)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(I)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
DBDD72:	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX 45FDA

DABDD6:	ADDI TIME,26.
	HRRZ TT,R6
	SUBI TT,2
	CAMGE TT,RSLR1
	JSP D,HPDLO1
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX 45FDA

DABDD7:	ADDI TIME,26.
	SOSL TT,PC
	JRST DBDD72
	MOVEI TT,77777
	MOVEI PC,77777
	JRST DBDD72

DACBX:	ANDI I,77
D2CBX:	ADDI TIME,26.
	45PCINC TT,MA
	ADD MA,R0-60(I)
	TRZ MA,200000
	DACBXX

DACBX7:	ADDI TIME,26.
	45PCINC TT,MA
	ADD MA,PC
	ADD MA,PC
	TRZ MA,200000
	DACBXX

DABXD:	ANDI I,77
D2BXD:	ADDI TIME,38.
	45PCINC MA,TT
	ADD TT,R0-70(I)
	TRZ TT,200000
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX

DABXD7:	ADDI TIME,38.
	45PCINC MA,TT
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	45DRTT
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACBXX

	OFFSET 0
TERMIN		;END OF DACBZZ MACRO DEFINITION.
]
DACBZZ R
DACBZZ W

IF1 [
DEFINE DACWZZ TYPE

DEFINE DACWXX X1
	LSHC MA,-1
	45D!TYPE!MA X1
	JUMPGE X,(E)
	JSP A,BOUNDE
	TERMIN

ODAC!TYPE!T:
	REPEAT 8,MOVEI MA,R0-PDP11+.RPCNT
	REPEAT 7,JSP E,DAC!TYPE-DACR+DAWRD
	JSP E,DAC!TYPE-DACR+DAWRD7
	REPEAT 7,JSP E,DAC!TYPE-DACR+DACWI
	JSP E,DAC!TYPE-DACR+DACWI7
	REPEAT 7,JSP E,DAC!TYPE-DACR+DAWID
	JSP E,DAC!TYPE-DACR+DAWID7
	REPEAT 6,JSP E,DAC!TYPE-DACR+DACWD
	JSP E,DAC!TYPE-DACR+DACWD6
	JSP E,DAC!TYPE-DACR+DACWD7
	REPEAT 6,JSP E,DAC!TYPE-DACR+DAWDD
	JSP E,DAC!TYPE-DACR+DAWDD6
	JSP E,DAC!TYPE-DACR+DAWDD7
	REPEAT 7,JSP E,DAC!TYPE-DACR+DACWX
	JSP E,DAC!TYPE-DACR+DACWX7
	REPEAT 7,JSP E,DAC!TYPE-DACR+DAWXD
	JSP E,DAC!TYPE-DACR+DAWXD7

OD2C!TYPE!T:
	REPEAT 8,MOVEI MA,R0-PDP11+.RPCNT
	REPEAT 7,JSP E,DAC!TYPE-DACR+D2WRD
	JSP E,DAC!TYPE-DACR+DAWRD7
	REPEAT 7,JSP E,DAC!TYPE-DACR+D2CWI
	JSP E,DAC!TYPE-DACR+DACWI7
	REPEAT 7,JSP E,DAC!TYPE-DACR+D2WID
	JSP E,DAC!TYPE-DACR+DAWID7
	REPEAT 6,JSP E,DAC!TYPE-DACR+D2CWD
	JSP E,DAC!TYPE-DACR+DACWD6
	JSP E,DAC!TYPE-DACR+DACWD7
	REPEAT 6,JSP E,DAC!TYPE-DACR+D2WDD
	JSP E,DAC!TYPE-DACR+DAWDD6
	JSP E,DAC!TYPE-DACR+DAWDD7
	REPEAT 7,JSP E,DAC!TYPE-DACR+D2CWX
	JSP E,DAC!TYPE-DACR+DACWX7
	REPEAT 7,JSP E,DAC!TYPE-DACR+D2WXD
	JSP E,DAC!TYPE-DACR+DAWXD7

DAC!TYPE:	OFFSET DACR-.

DAWRD:	ANDI I,77
D2WRD:	ADDI TIME,14.
	MOVE MA,R0-10(I)
	DACWXX

DAWRD7:	ADDI TIME,14.
	MOVE MA,PC
	45I!TYPE!MA
	JRST (E)

DACWI:	ANDI I,77
D2CWI:	ADDI TIME,14.
	MOVE MA,R0-20(I)
	MOVEI TT,2(MA)
	ANDI TT,177777
	HRRM TT,R0-20(I)
	DACWXX 45FDA

DACWI7:	ADDI TIME,14.
	MOVE MA,PC
	45I!TYPE!MA
	AOJA PC,(E)

DAWID:	ANDI I,77
D2WID:	ADDI TIME,26.
	MOVE TT,R0-30(I)
	MOVEI MA,2(TT)
	ANDI MA,177777
	HRRM MA,R0-30(I)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX 45FDA

DAWID7:	ADDI TIME,26.
	45PCINC TT,MA
	DACWXX

DACWD:	ANDI I,77
D2CWD:	ADDI TIME,14.
	MOVE MA,R0-40(I)
	SUBI MA,2
	ANDI MA,177777
	HRRM MA,R0-40(I)
	DACWXX 45FDA

DACWD6:	ADDI TIME,14.
	HRRZ MA,R6
	SUBI MA,2
	CAMGE MA,RSLR1
	JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	DACWXX 45FDA

DACWD7:	ADDI TIME,14.
	SOSL MA,PC
45Y	JRST .+3
45N	JRST (E)
	MOVEI MA,77777
	MOVEI PC,77777
	45I!TYPE!MA
	JRST (E)

DAWDD:	ANDI I,77
D2WDD:	ADDI TIME,26.
	MOVE TT,R0-50(I)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(I)
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
DWDD72:	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX 45FDA

DAWDD6:	ADDI TIME,14.
	HRRZ TT,R6
	SUBI TT,2
	CAMGE TT,RSLR1
	JSP D,HPDLO1
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX 45FDA

DAWDD7:	ADDI TIME,26.
	SOSL TT,PC
	JRST DWDD72
	MOVEI TT,77777
	MOVEI PC,77777
	JRST DWDD72

DACWX:	ANDI I,77
D2CWX:	ADDI TIME,26.
	45PCINC TT,MA
	ADD MA,R0-60(I)
	TRZ MA,200000
	DACWXX

DACWX7:	ADDI TIME,26.
	45PCINC TT,MA
	LSHC MA,-1
	ADD MA,PC
	TRZ MA,100000
	45D!TYPE!MA
	JUMPGE X,(E)
	JSP A,BOUNDE

DAWXD:	ANDI I,77
D2WXD:	ADDI TIME,38.
	45PCINC MA,TT
	ADD TT,R0-70(I)
	TRZ TT,200000
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	45DRTT
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX

DAWXD7:	ADDI TIME,38.
	45PCINC MA,TT
	TRNE TT,1
	JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	45DRTT
	SKIPGE MA,PDP11(TT)
	JSP D,MTRAPR
	DACWXX

OFFSET 0
TERMIN	.SEE DACWZZ
]	;END IF1
DACWZZ R
DACWZZ W

DEFINE	JACWXX
	LSHC MA,-1
	JUMPGE X,(E)
	JSP A,BOUNDE
TERMIN

JD2CWT:	REPEAT 8,JSP A,ILLINS
	REPEAT 7,JSP E,JAWRD
	JSP E,JAWRD7
	REPEAT 7,JSP E,J2CWI
	JSP E,JACWI7
	REPEAT 7,JSP E,JAWID
	JSP E,JAWID7
	REPEAT 6,JSP E,JACWD
	JSP E,JACWD6
	JSP E,JACWD7
	REPEAT 6,JSP E,JAWDD
	JSP E,JAWDD6
	JSP E,JAWDD7
	REPEAT 7,JSP E,JACWX
	JSP E,JACWX7
	REPEAT 7,JSP E,JAWXD
	JSP E,JAWXD7

J2CWI:	ADDI TIME,14.
	MOVE MA,R0-20(I)
45N[	ADDI MA,2
	TRZ MA,200000
	HRRM MA,R0-20(I)
]
45Y[	MOVEI TT,2(MA)
	ANDI TT,177777
	HRRM TT,R0-20(I)
]
	JACWXX

JACWI7:	ADDI TIME,14.
45N[	AOS MA,PC
	JRST (E)]
45Y[	MOVEI MA,(PC)
	AOJA PC,(E)
]

JAWRD:	ADDI TIME,14.
	MOVE MA,R0-10(I)
	JACWXX

JAWRD7:	ADDI TIME,14.
	MOVE MA,PC
	JRST (E)

JAWID:	ADDI TIME,26.
	MOVE TT,R0-30(I)
	MOVEI MA,2(TT)
	ANDI MA,177777
	HRRM MA,R0-30(I)
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	JACWXX

JAWID7:	ADDI TIME,26.
	45PCINC TT,MA
	JACWXX

JACWD:	ADDI TIME,14.
	MOVE MA,R0-40(I)
	SUBI MA,2
	ANDI MA,177777
	HRRM MA,R0-40(I)
	JACWXX

JACWD6:	ADDI TIME,14.
	HRRZ MA,R6
	SUBI MA,2
	CAMGE MA,RSLR1
	 JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	JACWXX

JACWD7:	ADDI TIME,14.
	SOSL MA,PC
	 JRST (E)
	MOVEI MA,77777
	MOVEI PC,77777
	JRST (E)

JAWDD:	ADDI TIME,26.
	MOVE TT,R0-50(I)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(I)
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
JWDD72:	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	JACWXX

JAWDD6:	ADDI TIME,14.
	HRRZ TT,R6
	SUBI TT,2
	CAMGE TT,RSLR1
	 JSP D,HPDLO1
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FDA
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	JACWXX

JAWDD7:	ADDI TIME,26.
	SOSL TT,PC
	 JRST JWDD72
	MOVEI TT,77777
	MOVEI PC,77777
	JRST JWDD72

JACWX:	ADDI TIME,26.
	45PCINC TT,MA
	ADD MA,R0-60(I)
	TRZ MA,200000
	JACWXX

JACWX7:	ADDI TIME,26.
	45PCINC TT,MA
	LSHC MA,-1
	ADD MA,PC
	TRZ MA,100000
	JUMPGE X,(E)
	JSP A,BOUNDE

JAWXD:	ADDI TIME,38.
	45PCINC MA,TT
	ADD TT,R0-70(I)
	TRZ TT,200000
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
	45DRTT
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	JACWXX

JAWXD7:	ADDI TIME,38.
	45PCINC MA,TT
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	45DRTT
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	JACWXX

DEFINE SACWXX X1
	LSHC MA,-1
	45DRMA X1
	JUMPGE X,(E)
	JSP A,BOUNDE
	TERMIN

OSACWT:	REPEAT 7,MOVEI MA,R0-PDP11+.RPCNT
	JSP E,SAWPC
	REPEAT 7,JSP E,SAWRD
	JSP E,SAWRD7
	REPEAT 7,JSP E,SACWI
	JSP E,SACWI7
	REPEAT 7,JSP E,SAWID
	JSP E,SAWID7
	REPEAT 6,JSP E,SACWD
	JSP E,SACWD6
	JSP E,SACWD7
	REPEAT 6,JSP E,SAWDD
	JSP E,SAWDD6
	JSP E,SAWDD7
	REPEAT 7,JSP E,SACWX
	JSP E,SACWX7
	REPEAT 7,JSP E,SAWXD
	JSP E,SAWXD7

SAWPC:	HRRZ MB,PC
	LSH MB,1
	JRST 2(E)

SAWRD:	ANDI T,77
	ADDI TIME,15.
	MOVE MA,R0-10(T)
	SACWXX

SAWRD7:	ADDI TIME,15.
	MOVE MA,PC
	45IRMA
	JRST (E)

SACWI:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-20(T)
	MOVEI TT,2(MA)
	ANDI TT,177777
	HRRM TT,R0-20(T)
	SACWXX 45FSA

SACWI7:	ADDI TIME,15.
45Y[	MOVE MA,PC
	45IRMA
	SKIPGE MB,PDP11(MA)]
45N	SKIPGE MB,PDP11(PC)
	 JSP D,MTRAPR
	AOJA PC,2(E)

SAWID:	ADDI TIME,27.
	ANDI T,77
	MOVE TT,R0-30(T)
	MOVEI MA,2(TT)
	ANDI MA,177777
	TRZ MA,200000
	HRRM MA,R0-30(T)
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FSA
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	SACWXX 45FSA

SAWID7:	ADDI TIME,27.
	45PCINC TT,MA
	SACWXX

SACWD:	ADDI TIME,15.
	ANDI T,77
	MOVE MA,R0-40(T)
	SUBI MA,2
	ANDI MA,177777
	HRRM MA,R0-40(T)
	SACWXX 45FSA

SACWD6:	ADDI TIME,15.
	HRRZ MA,R6
	SUBI MA,2
	CAMGE MA,RSLR1
	 JSP D,HPDLOV
	ANDI MA,177777
	HRRM MA,R6
	SACWXX 45FSA

SACWD7:	ADDI TIME,15.
	SOSL MA,PC
45Y	 JRST .+3
45N	 JRST (E)
	MOVEI MA,77777
	MOVEI PC,77777
	45IRMA
	JRST (E)

SAWDD:	ADDI TIME,27.
	ANDI T,77
	MOVE TT,R0-50(T)
	SUBI TT,2
	ANDI TT,177777
	HRRM TT,R0-50(T)
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
SWDD72:	45DRTT 45FSA
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	SACWXX 45FSA

SAWDD6:	ADDI TIME,27.
	HRRZ TT,R6
	SUBI TT,2
	CAMGE TT,RSLR1
	 JSP D,HPDLO1
	ANDI TT,177777
	HRRM TT,R6
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
	45DRTT 45FSA
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	SACWXX 45FSA

SAWDD7:	ADDI TIME,27.
	SOSL TT,PC
	 JRST SWDD72
	MOVEI TT,77777
	MOVEI PC,77777
	JRST SWDD72

SACWX:	ADDI TIME,27.
	45PCINC TT,MA
	ANDI T,77
	ADD MA,R0-60(T)
	TRZ MA,200000
	SACWXX

SACWX7:	ADDI TIME,27.
	45PCINC TT,MA
	LSHC MA,-1
	ADD MA,PC
	TRZ MA,100000
	45DRMA
	JUMPGE X,(E)
	JSP A,BOUNDE

SAWXD:	ADDI TIME,39.
	45PCINC MA,TT
	ANDI T,77
	ADD TT,R0-70(T)
	TRZ TT,200000
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
	45DRTT
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	SACWXX

SAWXD7:	ADDI TIME,39.
	45PCINC MA,TT
	TRNE TT,1
	 JSP A,BOUNDE
	LSH TT,-1
	ADD TT,PC
	TRZ TT,100000
	45DRTT
	SKIPGE MA,PDP11(TT)
	 JSP D,MTRAPR
	SACWXX

IIOT:	ADDI TIME,21.
	MOVEI T,4
	JSP A,TRPINS

IBPT:	ADDI TIME,21.
	MOVEI T,3
	JSP A,TRPINS

IEMT:	ADDI TIME,21.
	MOVEI T,6
	JSP A,TRPINS

ITRAP:	ADDI TIME,21.
	MOVEI T,7
	JSP A,TRPINS

45Y	TTRPIB:
TTRAP:	MOVEI T,3	;TRACE TRAP
	JSP A,TVTRAP

LBUSER:	MOVE MA,[LBUSET-4,,LBUSET-8]
	BLT MA,LBUSET-1
	MOVE MA,OPC
	MOVEM MA,LBUSEP
	MOVE MA,@(P)
	MOVEM MA,LBUSEM
	MOVEM TIME,LBUSET
	MOVEM A,LBUSES
	JRST POPJ1

	BLOCK 8	;PREVIOUS ERRORS
LBUSET:	BLOCK 1
LBUSEP:	BLOCK 1
LBUSES:	BLOCK 1
LBUSEM:	BLOCK 1	;CLEARED AT CZTIME

CBUSS:	PUSH P,PC
	PUSH P,OPC
	MOVEI T,0
	PUSHJ P,CBUSSP
	JRST CBUNOE
	TTOA [ASCIZ /LAST/]
	MOVEI T,-4
	PUSHJ P,CBUSSP
	JRST CBUSSX
	TTOA [ASCIZ /PREVIOUS/]
	MOVEI T,-8
	PUSHJ P,CBUSSP
	JRST CBUSSX
	TTOA [ASCIZ /EARLIER/]
CBUSSX:	POP P,OPC
	TTOA [ASCIZ /CURRENT TIME: /]
	PUSHJ P,CTIME
	POP P,PC
	RETURN

CBUSSP:	SKIPN LBUSEM(T)
	RETURN
	AOS (P)
	XCT @(P)
	AOS (P)
	MOVE T2,LBUSEP(T)
	MOVEM T2,OPC
	TTOA [ASCIZ / BUSS ERR AT 
/]
	SKIPN DEBUGP
	JRST CBUSP2
	MOVE T2,LBUSES(T)
	MOVEM T2,QA
	TTOA [ASCIZ /SIM. PC. = A
/]
CBUSP2:	TTOA @LBUSEM(T)
	TTOA [ASCIZ /   TIME: /]
	MOVE T2,LBUSET(T)
	JRST CBUSS2

CBUNOE:	TTOA [ASCIZ /NO BUSS ERRORS
/]
	JRST CBUSSX

NXMNXM:	SUB P,[1,,1]		;NXM - THROW AWAY RET ADDR IN MTRAP.
	PUSHJ P,LBUSER
	[ASCIZ /TIME OUT/]
	JRST BUSSE

45N[
ILLINS:	PUSHJ P,LBUSER
	[ASCIZ /ILLEGAL INSTRUCTION/]
	JRST BUSSE	;ILLEGAL INSTRUCTION (JMP (JSR) %X)
]
45Y[
IHALTL:	CALL LBUSER
	[ASCIZ/HALT/]
	JRST BUSSE
]

BOUNDE:	PUSHJ P,LBUSER
	[ASCIZ /BOUNDARY ERROR/]
BUSSE:	SKIPE INVTRP
	JRST TRPBDE
	SKIPA T,[600000,,1]	;BUS ERROR (SETZ FOR HPDLOV TEST)
45Y ILLINS:
IILL:	MOVEI T,2	;RESERVED INSTRUCTION
TRPINS:	PUSHJ P,TTPDFL
	JRST VTRAP

TVTRAP:	PUSHJ P,PDLFLS

;COME HERE TO PERFORM A VIRTUAL TRAP. <TRAP VECTOR ADDR>/4 IN T.
.SEE HPDLOV	;(IF CALLED FROM VTRAP, LOOKS AT T TO CHECK FOR BUSS ERROR TRAPS)
VTRAP:	SKIPE WAITFL
	AOJA PC,VTRAPW	;FINSH A WAIT INSN.
VTRAP0:	SKIPE B,TRPPNT(T)
	PUSHJ P,VTRPPT
	SETOM INVTRP
	LSH T,1
	MOVE MA,T	;MA HAS WORD # OF TRAP VECTOR.
45Y[	SKIPL 45SGON	;NO PAGING => USE UNMAPPED ADDR.
	 JRST VTRAP5
	XCT 45IRK1	;ELSE MAP ADDR - WE KNOW IT'S IN
	XCT 45IRK2	;KERNEL I SPACE SEGMT 0.
	 JSP A,45ASL
VTRAP5:]
	SKIPGE PDP11(MA)	;FETCH THE WORDS IN THE TRAP VECTOR.
	 JSP D,MTRAPR
	MOVE TT,PDP11(MA)
	AOS MA,T	;MUST RE-MAP THE ADDR OF THE 2ND WD.
45Y[	SKIPL 45SGON
	 JRST VTRAP6
	XCT 45IRK1
	XCT 45IRK2
	 JSP A,45ASL
VTRAP6:]
	MOVEM PS,VTRAPS'
	SKIPGE PDP11(MA)
	 JSP D,MTRAPR
	MOVE PS,PDP11(MA) ;MUST SET PS FROM VECTOR BEFORE PUSHING
	NEWPS		;SO THAT THE RIGHT R6 WILL BE USED.
45Y[	LDB D,[45CMOD,,VTRAPS]	;PUT OLD CURRENT PROCESSOR MODE
	DPB D,[45PMOD,,PS]] ;INTO PREVIOUS MODE OF CURRENT PS.
	ADDI TIME,72.
	HRRZ MA,R6
	SUBI MA,2
	CAMGE MA,RSLR1
	JSP D,HPDLOV
	ANDI MA,177777
	LSHC MA,-1
	JUMPL X,BOUNDE
	45DWMA
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	MOVE MB,VTRAPS
	HRRM MB,PDP11(MA) ;PUSH THE OLD PS.
	HRRZ MA,R6	;MUST RE-MAP FOR THE SECOND PUSH.
	SUBI MA,4
	CAMGE MA,RSLR1
	 JSP D,HPDLOV
	ANDI MA,177777
	MOVEI MB,(MA)
	LSH MA,-1
	45DWMA
	SKIPGE PDP11(MA)
	JSP D,MTRAPW
	HRRM MB,R6	;CAN UPDATE R6 NOW THAT CAN'T TAKE PAGE FAULT.
	HRRM PC,PDP11(MA)
	ADDM PC,PDP11(MA)
	AOSN ODDPC
	AOS PDP11(MA)
	HRRZ PC,TT	;NOW SET PC TO WHAT WE FETCHED AT THE BEGINNING.
	TRNE PC,1
	JSP D,DBNDE
	LSH PC,-1
	SETZM INVTRP
	SETZM DDONXT	;STOP IGNORING MTRAPI.
	SETZM PDLFT	;NO LONGER DOING FATAL STACK OV TRAP.
	SETZM PDLNFT
45N[
VTRAP4:	MOVSI T,1
	CAML T,@TRINF+1
	JRST INBEG	;ALWAYS EXECUTE FIRST INST OF TRAP ROUTINE
	MOVE B,TRINF+1
	MOVE A,1(B)
	SETOM 1(B)
	MOVEM A,TRINF+1
	XCT 2(B)
	JRST VTRAP4
]
45Y	JRST INEND

VTRAPW:	SETZM WAITFL
	SOS INSCNT
	JRST VTRAP0

VTRPPT:	SOJE B,VTRPP3
	CRF
VTRPP1:	HRRZM A,QT
	LSH T,2
	MOVEM T,QA
	LSH T,-2
	AOS OPC
	TTOA [ASCIZ /TRAP THROUGH A FROM 
/]
	SOS OPC
	SKIPE DEBUGP
	TTOA [ASCIZ/SIM. PC. =T
/]
VTRPP2:	CAIL B,2
	JRST CLRRUN
	RETURN

BRPNT:	MOVE B,TRPPNT	;(JUMP HERE FROM END OF BRANCH, JMP, ETC)
	MOVEM PC,QA
	ADDM PC,QA
	TTOA [ASCIZ /
BRANCH:   -->  A
/]
	CAIL B,3
	 CALL CLRRUN
	JRST INEND

VTRPP3:	MOVE B,OPC		;MODE 1 -- JUST SAVE ADDR OF TRAP.
	MOVEM B,JPC
	RETURN

CDEBUG:	SETCMB A,DEBUGP
	SKIPL A
	TTOA 1,[ASCIZ/OFF
/]
	TTOA [ASCIZ/ON
/]
	RETURN

DEBUGP:	0

;BUS ERROR IN PROCESSING TRAP
TRPBDE:	TTOA	[ASCIZ/
BUSS ERROR IN /]
	MOVEI B,2
	PUSHJ P,VTRPP1
	SETZM INVTRP
	PUSHJ P,TTPDFL
DIEDIE:	PUSHJ P,CLRRUN
	JRST INEND

;JSP D,HERE WHEN DETECT R6 < RSLR1, AND TT HOLDS NEW CONTENTS OF R6.
HPDLO1:
45Y[	SKIPL PDLFT	;PDL ALWAYS SEEMS OVERFLOWED DURING FATAL OV TRAP.
	SKIPE 45MODE	;NO PDL OV CHECKING EXCEPT IN KERNEL MODE.
	 JRST (D)
	MOVEI A,20(TT)
	JRST HPDLO2]

;JSP D,HERE INSTEAD OF HPDLO1 IF NEW R6 IS IN MA.
HPDLOV:
45Y[	SKIPL PDLFT
	SKIPE 45MODE
	 JRST (D)
	MOVEI A,20(MA)
HPDLO2:	CAMGE A,RSLR1	;BELOW FATAL LIMIT?
	 JRST PDLTR1	;YES - IF K MODE, FATAL TRAP.
	MOVEI A,-14(A)
	CAMGE A,RSLR1
	 JRST (D)	;ELSE, IF WE'RE EXACTLY AT THE SOFT LIMIT, DO A SOFT TRAP.
]
	SKIPL PDLNFT	;PDL OV TRAP'S PUSHES SHOULDN7T CAUSE ANOTHER.
	SKIPL PDLTRB+1
	JRST (D)	;ALREADY SPRUNG
45N[	SKIPE INVTRP
	CAIE T,3
	JRST .+2
	JRST (D)	;ALREADY TRAPPED
]
	MOVEM D,PDLOV.
	MOVEI A,PDLTRB
	CALL MTRNEW
	JRST (D)

PDLTRB:	3,,
	-1
	JRST PDLTR2

45Y[
PDLTR1:	MOVEI A,4
	HRRM A,R6	;CLOBBER SATACK PTR T0 4, TRAP IMMEDIATELY.
	SETOM PDLFT	;R6 HOLDS 4 SO VTRAP WOULD DETECT PDL OV UNLESS TOLD NOT TO.
	SKIPA A,D
]
PDLTR2:	MOVE A,PDLOV.
	SETOM PDLNFT
	PUSHJ P,LBUSER
	[ASCIZ /STACK OVERFLOW/]
	MOVEI A,PDLTRB
	CALL QDEL
	MOVEI T,1
	JRST VTRAP

PDLNFT:	0	;-1 DURING NONFATAL PDL OV TRAP.
PDLFT:	0	;-1 DURING FATAL STACK OVFLO TRAP.
RSLR1:	400
PDLOV.:	0
ODDPC:	0
	
TTPDFL:
45N[	SKIPL TTRPBK+1	;FLUSH TRACE TRAP IF PENDING
	JRST TTPD2
]
PDLFLS:	SKIPL PDLTRB+1	;FLUSH PDL OV IF PENDING
	JRST PDLFL2
	RETURN

45N[
TTPD2:	BLKFLS TTRPBK
	PDLTRB,,0
	RETURN
]

PDLFL2:	BLKFLS PDLTRB
	0
	RETURN

;WORD IN MEM
;4.9=0 => NO HACKS
;4.9=1
 ;4.8=0 BREAK ONLY
 ;4.7=0,1 DO, DON'T  STOP AFTER MESS
  ;4.1=1 TRAP ON FETCH & TURN THIS BIT OFF.
  ;4.2=1 TRAP ON DIRECT TO MEM DEV WRITE
  ;4.3=1 TRAP ON DIRECT TO MEM DEV READ
  ;4.4=1 TRAP ON INST REF
  ;4.5=1 TRAP ON WRITE
  ;4.6=1 TRAP ON READ (BUT NOT INST)
 ;4.8=1 I/O DEV + POSSIBLE BREAK
;3.1-3.9 DEVICE INDEX

DEVPOS=221100
MARPOS=340600

MTRAPI:	HRLZI B,11000	;INSTRUCTION
	JRST MTRAP

MTRPW:	HRLZI B,60000	;READ-PAUSE-WRITE
	JRST MTRAP

MTDMRW:	SKIPA	B,[6000,,1]
NGMTRW:	MOVE	B,[6000,,2]
	JRST	MTRAP

MTRDFR:	SKIPA B,[4000,,3]
MTRDFW:	MOVE B,[2000,,3]
	JRST MTRAP

MTRRKR:	SKIPA B,[4000,,5]
MTRRKW:	MOVE B,[2000,,5]
	JRST MTRAP

MTDMRD:	SKIPA	B,[4000,,1]
MTDMWR:	MOVE	B,[2000,,1]
	JRST	MTRAP

TXN[
MTETRD:	SKIPA	B,[4000,,4]
MTETWR:	MOVE	B,[2000,,4]
	PUSH	P,D		;RSTALL WILL POPJ THIS.
	CALL	SAVALL
	MOVE	A,ETDRIV	;SAVE B'S REAL CONTENTS
	MOVEM	A,B-SAVLNG(P)
	JSP	D,MTRAP
	JRST	RSTALL		;MTRAP WILL COME BACK HERE.
]
MTRDVT:
TXN[	SIXBIT/DM/
	SIXBIT/NGDIS/
	SIXBIT/DF/
	SIXBIT/DT/
	SIXBIT /RK/
]
MTDVTL==.-MTRDVT

MTRAPW:	SKIPA B,[20000,,]	;WRITE
MTRAPR:	 HRLZI B,40000		;READ
MTRAP:	MOVE A,@-2(D)
	TLNE A,200000
	 JRST MTRDEV
MTRAP1:	SKIPN DDTPDP
	 TLNN A,77000
	  JRST MTRAPX
	HLR A,A			;SEE IF THIS REFERENCE SHOULD BREAK.
	TLNN B,(A)
	 JRST MTRAPX		;IF NOT.
	TLNE B,1000		;IF TRIPPING AN AUTOFLUSH, STOP BEFORE INSN.
	 JRST MTRIPT
	TLNE A,100000		;IF STOPPING BREAKPOINT,
	 JRST MTRAP6
	TLNE B,10000		;IF INSN FETCH, STOP BEFORE INSN.
	 JRST MTRIPT
MTRAP2:	PUSHJ P,CLRRUN		;ELSE STOP AFTER INSN.
MTRAP6:	SKIPE TYOFLG		;DON'T TAKE LOTS OF TIME IF TYPEOUT OFF.
	 PUSHJ P,MTRPNT		;TYPE BREAKPOINT MESSAGE.
MTRAPX:	MOVE A,@-2(D)
	LDB B,[270400,,-2(D)]
	SKIPE B
	 HRRZM A,(B)
	JRST (D)

MTRIPT:	SKIPN WAITFL
	 SKIPE DDONXT		;DO NOTHING IF JUST LEFT DDT.
	  JRST MTRAPX
	TLNN B,10000		;IF ONLY WAS AUTOFLUSH,
	 TTOA 1,[ASCIZ/
BREAK(F):  /]			;SAY BREAK IS REMOVED.
	  TTOA [ASCIZ/
BREAK:  /]			;ELSE NORMAL MSG.
	TLZ A,1000		;CLEAR ANY AUTOFLUSH BREAK.
	TLNN A,377000		;IF THAT WAS ONLY HACK,
	TLZ A,400000		;INDICATE NO HACKS.
	HLLM A,@-2(D)
	MOVEI A,(PC)
	LSH A,1
	HRRM A,%B
	PUSHJ P,CLRRN2		;CALL DDT RIGHT AWAY,
	JRST INBEG		;START INSN OVER.

MTRDEV:	LDB C,[DEVPOS,,A]	;DEVICE
	CAIL C,MAXDEV
	 .VALUE			;?
	PUSHJ P,@MDEVTB(C)	;CALL DEVICE
	MOVE A,@-2(D)
	JRST MTRAP1

NXMHAK:	TRNE B,-1
	JRST NXMTKD	;SOME DIRECT TO MEM DEVICE
	SKIPN DDTPDP
	JSP A,NXMNXM
	TLNN B,20000	;DON'T TYPE ON WRITING.
	TTOA [ASCIZ /NXM? /]
	RETURN

NXMTKD:	XCT NXMDVT-1(B)
	JRST MTRAP1

NXMDVT:
TXN[	JRST NXMDML	;DM
	JRST NGRNXM	;NGDIS
	JRST DFNXM0	;DSK NXM
	JRST ETNXM0
	JRST RKNXM0
]
IFN .-NXMDVT-MTDVTL,[PRINTX /NXMDVT .NE. MTRDVT
/]

MTRPNT:	TTOA	[ASCIZ /
BREAK: /]
	PUSHJ	P,SAVALL
	SKIPL	DDTPDP
	AOS	DDTPDP
	HRLZ	SF,%TMODE
	MOVE	B,B-SAVLNG(P)
	MOVEI	DO,@-2(D)	;ADDR. OF BREAKPOINT.
	TRNE	B,-1		;IF REFERENCE WAS BY A DEVICE,
	6TYPE	MTRDVT-1(B)	;PRINT ITS NAME.
	TRNE	B,-1
	TTOI	" 
MTRPN3:	TLNE	B,10000
	JRST	MTRPN4		;SPECIAL ACTION FOR FETCH BREAK.
	TLNE	B,44000
	TTOI	"R
	TLNE	B,22000
	TTOI	"W
	TTOA	[ASCIZ /  /]
	MOVEI	DL,-PDP11(DO)
	LSH	DL,1		;VIRT. ADDR. OF BREAKPOINT.
	ADRTYP	DL
	HRRM	DL,%B		;STORE AS ADDR OF LAST BREAKPOINT.
	TTOA	[ASCIZ ./ .]
	HRRZ	DL,(DO)		;GET WORD'S CONTENTS, CLEAR FLAGS.
	SYMTYP	DL		;PRINT CONTENTS OF WORD WITH BKPT.
	TTOA	[ASCIZ/
FROM: 
/]
MTRPN2:	SKIPL	DDTPDP
	SOS	DDTPDP
	JRST	RSTALL

MTRPN4:	TTOA	[ASCIZ/I  %OPC]
FROM: /]
	MOVEI	DL,(PC)
	LSH	DL,1		;ADDR. OF BREAKPOINT.
	HRRM	DL,%B
	CALL	DPINSN		;PRINT BREAKING INSN.
	CRF
	JRST	MTRPN2

MDEVTB:	OFFSET -.
	IRP X,,[NXM,CSX,CPAT]	;THE POSITION OF THESE ENTRIES
	N!X::
	X!HAK
TERMIN		;MUST NOT BE CHANGED, SINCE THEY ARE IN DUMP FILES.

TXN[
IRP X,,[PS,PC,SWR,PIR,LKS,TKS,TKB,TPS,TPB
PRS,PRB,PPS,PPB,DIV,MQ,MUL,NOR,LGS,ARS
DCS,CMA,DAE,ADS,PKC,CSR,BAR,BCR,TBR,LPS,LPB]
	N!X::
	X!HAK
TERMIN
]
TXY[
IRP X,,[PS,PC,SWR,PIR,LKS,TKS,TKB,TPS,TPB
DIV,MQ,MUL,NOR,LGS,ARS,PKC]
	N!X::
	X!HAK
TERMIN
]
TXN[
IRP X,,[SCSR,RCSR,RBUF,TSCR,TBUF,TCCM,TCST
RKDS,RKER,RKCS,RKBA]
	N!X::
	X!HK
TERMIN
IRP X,,[PKCSR,PKCSB,NGCSR]
	N!X::
	X!K
TERMIN
]
TXY[
NSCSR::	SCSRHK
IRP X,,[PKCSR,PKCSB]
	N!X::
	X!K
TERMIN
]

45Y[
NSAR::	SARHAK
NSDR::	SDRHAK
NSLR::	SLRHAK

IRP X,,[SARU,SDRU,SSR0,SSR2,SSR3]
N!X::	X!HK
TERMIN	]

OFFSET 0

MAXDEV==.-MDEVTB

;PROCESSOR STATUS REGISTER
PSHAK:	SKIPE DDTPDP
	 JRST PSHAK1
	ANDI PC,77777
	HRRM PS,RPS
PSHAK1:	TLNN B,20000
	RETURN
	JSP A,MTRNEW
PSTRB:	10,,
	-1
	PUSHJ P,PSHTRP

MTRNEW:	SKIPL 1(A)
	RETURN
	PUSH P,T
	PUSH P,B
	PUSHJ P,TRQQA
	POP P,B
	POP P,T
	RETURN

MTRDES:	PUSH P,T
	PUSH P,B
	PUSHJ P,TRQADD
	POP P,B
	POP P,T
	RETURN

PSHTRP:	SKIPE DDTPDP
	 SAVE PS
45N	HRRZ PS,RPS
45Y[	SKIPE DDTPDP
	 SETZ PS,	;THIS STUFF PREVENTS CLOBBERAGE OF T BIT
	HRRZ A,RPS	;EXCEPT FROM DDT.
	ANDCMI A,TF
	ANDI PS,TF
	IORI PS,(A)
	HRRM PS,RPS	]
	NEWPS
	SKIPE DDTPDP
	 REST PS
	RETURN

;PROGRAM COUNTER REGISTER
PCHAK:	SKIPE DDTPDP
	RETURN
	TLNN  B,50000
	JRST PCHAKW
	HRRM PC,R7
	ADDM PC,R7
PCHAKW:	TLNN B,20000
	RETURN
	JSP A,MTRNEW
	7,,
	-1
	JRST PCTRP

PCTRP:	HRRZ PC,R7
	TRNE PC,1
	JSP D,DBNDE
	LSH PC,-1
	OBRAN1

;LINE FREQUENCY CLOCK
LKSHAK:	TLNN B,54000
	RETURN
	ANDI A,100
	AOSN CLOCK
	TRO A,200
	HRRM A,RLKS
	RETURN

CLOCK:	0
WLK:	-1
LKTIM:	166667.

CLKSBK:	0
	-1
	PUSHJ P,.+1
TXN	.SUSET [.RRUNT,,A]
TXY[	MOVEI	A,400000
	RUNTM
	IMULI	A,250.
]
	SUB A,RUNTB
	MOVE B,TIME
	IDIVI B,40.
	IDIV A,B
	HRRM A,RATE
	JRST CLKTR2

ALK:	JUMPE T5,ZLK2	;ATTACH LINE CLOCK
	MOVE A,[10000000.]	;ARG=CYCLES/SEC
	IDIV A,T5
	MOVEM A,LKTIM
ZLK2:	SKIPE WLK
	PUSHJ P,DLK
	PUSHJ P,WRDINS
	600000+NLKS,,RLKS
	0
	SETOM WLK
	SKIPA C,TIME
CLKTR2:	MOVE C,CLKSBK
	ADD C,LKTIM
	MOVEI A,CLKSBK
	PUSHJ P,CTRDES
	SETOM CLOCK
	LDB A,[60100,,RLKS]
	JUMPE A,CPOPJ
	JSP A,MTRNEW
LKSBK2:	6
	-1
	JRST .+1
	MOVEI T,20
	JSP A,VTRAP

DLK:	BLKFLS CLKSBK	;DETACH LINE CLOCK
	LKSBK2,,0
	SETZM WLK
	PUSHJ P,WRDZAP
	RLKS,,RLKS
	RETURN

ZLK:	SKIPN WLK
	RETURN
	JRST ZLK2

ATK:	JUMPE T5,ZTK	;ATTACH TELETYPE KEYBOARD
	MOVE A,[1000000.]
	IDIV A,T5
	MOVEM A,TKTIM
ZTK:	SKIPE WTK
	PUSHJ P,DTK
	PUSHJ P,WRDINS
	600000+NTKS,,RTKS
	600000+NTKB,,RTKB
	0
	SETOM WTK
	SETZM TKDONE
	SETZM TKBUSY
	RETURN

DTK:	BLKFLS CTKSBK	;DETACH TELETYPE KEYBOARD
	TKSBK2,,0
	SETZM WTK
	PUSHJ P,WRDZAP
	RTKS,,RTKB
	RETURN

TKSHAK:	TLNN B,54000
	JRST TKSWRT
	ANDI A,100
	SKIPE TKDONE
	IORI A,200
TKSHA4:	SKIPE TKBUSY
	TRO A,4000
	HRRM A,RTKS
TKSWRT:	TLNN B,22000
	RETURN
	 XXWAIT TKSINT

TKBHAK:	SKIPE TKDONE
	TLNN B,54000
	RETURN
	SETZM TKDONE
	RETURN

TKB224:	SETOM TKBUSY
	MOVEI A,CTKSBK
	MOVE C,TIME
	ADD C,TKTIM
	MOVEM C,CTKSBK
	SKIPN QFLAG
	JRST CTRDES
	 XXWAIT TKB224
	;FROM INTERRUPT OUT OF HACKING CLOCK QUEQUE

CTKTRP:	SETZM TKBUSY
TXN[	.STATUS TYIC,A		;REALLY HAVE A CHAR?
	TRNE A,2000
]
TXY[	MOVEI	A,.PRIIN
	SIBE
	SKIPA
]
	 JRST TKSINT
	PUSH P,MB
	PUSHJ P,TYI1	;YES, READ IT.
	HRRM MB,RTKB
	POP P,MB
	SETOM TKDONE
	PUSHJ P,TKB224	;CHECK FOR ANOTHER.
TKSINT:	MOVEI A,TKSBK2
	SKIPN TKDONE
	JRST QDEL
	LDB B,[60100,,RTKS]
	JUMPE B,QDEL
	JRST MTRNEW

TKSBK2:	4
	-1
	JRST .+1
	MOVEI T,14
	JSP A,VTRAP

TKTIM:	1000.
TKDONE:	0
TKBUSY:	0
WTK:	-1

CTKSBK:	0
	-1
	PUSHJ P,CTKTRP

ATP:	JUMPE T5,ZTP	;ATTACH TELETYPE PRINTER
	MOVE A,[1000000.]
	IDIV A,T5
	MOVEM A,TPTIM
ZTP:	SKIPE WTP
	PUSHJ P,DTP
	PUSHJ P,WRDINS
	600000+NTPS,,RTPS
	600000+NTPB,,RTPB
	0
	SETOM WTP
	SETOM TPREDY
	RETURN

DTP:	BLKFLS CTPBBK	;DETACH TELETYPE PRINTER
	TPSBK2,,0
	SETZM WTP
	PUSHJ P,WRDZAP
	RTPS,,RTPB
	RETURN

TPSHAK:	TLNN B,54000
	JRST TPSHK2
	ANDI A,104
	SKIPE TPREDY
	TRO A,200
	HRRM A,RTPS
TPSHK2:	TLNN B,22000
	RETURN
	 XXWAIT
CTPTR2:	MOVEI A,TPSBK2
	SKIPN TPREDY
	 JRST QDEL
	LDB C,[60100,,RTPS]
	JUMPE C,QDEL
	JRST MTRNEW

TPSBK2:	4
	-1
	JRST .+1
	MOVEI T,15
	JSP A,VTRAP

TPBHAK:	HLLZS RTPB
	TLNN B,22000
	RETURN
	 XXWAIT
	SKIPN TPREDY
	RETURN			;DATA LOST
	SETZM TPREDY
TXN[	HRRZ C,RTPB
	SYSCAL IOT,[1000,,TYOC ? 5000,,%TJSIO ? C]
]
TXY[	HRRZ	A,RTPB
	PBOUT
]
	MOVE C,TIME
	ADD C,TPTIM
	MOVEI A,CTPBBK
CTRDES:	PUSH P,T
	PUSH P,B
	PUSHJ P,CLQADD
	POP P,B
	POP P,T
	RETURN

CTPBBK:	0
	-1
	PUSHJ P,CTPTRP

CTPTRP:	SETOM TPREDY
	JRST CTPTR2

TPTIM:	900.
TPREDY:	-1
WTP:	-1

TXN[
APRA:	TDZA T5,T5
APRI:	MOVEI T5,4
	HRLM T5,PTRFIL
	MOVEI A,PTRFIL	;ATTACH PAPER TAPE READER
	PUSHJ P,DGFIL
	SKIPE WPR
	PUSHJ P,DPR
	MOVEI A,PTRFIL
APR1:	CALL GETCHP	;GET CHANNEL & OPEN.
	HRRZM C,PRCHAN	;REMEMBER WHAT CHANNEL.
ZPR:	PUSHJ P,WRDINS
	600000+NPRS,,RPRS
	600000+NPRB,,RPRB
	0
	BLKFLS PRCQB
	PRSBK2,,
	SETZM PRDONE
	SETZM PRERR
	SETZM PRBUSY
	SETZM PRCHAR
	SETOM WPR
	RETURN

PTRFIL:	SIXBIT/   DSKPTR   INPUT/

APR:	SKIPE WPR
	PUSHJ P,DPR
	MOVEI A,[SIXBIT/  (PTRPTR   INPUT/]
	JRST APR1

DPRI:DPRA:
DPR:	BLKFLS PRCQB	;DETACH PAPER TAPE READER
	PRSBK2,,0
	PUSHJ P,WRDZAP
	RPRS,,RPRB
	SETZM WPR
DPR1:	SKIPGE C,PRCHAN
	 RET		;CHANNEL ALREADY FREED.
	SETOM PRCHAN
	JRST CLOSEC	;ELSE FREE IT.

PRSHAK:	TLNN B,54000
	JRST PRSWRT
	ANDI A,100
	SKIPE PRDONE
	TRO A,200
	SKIPE PRBUSY
	TRO A,4000
	SKIPE PRERR
	TRO A,100000
	HRRM A,RPRS
PRSWRT:	TLNN B,22000
	RETURN
	XXWAIT
	SKIPE PRERR
	JRST 
	LDB C,[100,,RPRS]
	JUMPE C,PRTRAP
	SETZM PRCHAR
	SETOM PRBUSY
	MOVEI A,PRCQB
	MOVE C,TIME
	ADD C,PRTIM
	PUSHJ P,CTRDES
PRTRAP:	MOVEI A,PRSBK2
	SKIPN PRERR
	SKIPE PRDONE
	SKIPA
	JRST QDEL
	LDB C,[60100,,RPRS]
	JUMPE C,QDEL
	JRST MTRNEW
PRSBK2:	4
	-1
	JRST .+1
	MOVEI T,16
	JSP A,VTRAP

PRBHAK:	MOVE A,PRCHAR
	HRRM A,RPRB
	TLNE B,54000
	SETZM PRDONE
	RETURN

PRCQB::	0
	-1
	PUSHJ P,PRCTRP

PRCTRP:	SETZM PRBUSY
	SETOM PRDONE
	SYSCL IOT,[PRCHAN ? C]
	IOCGET JFCL
	 CAIA
	JUMPGE C,PRCTR1
	CALL DPR1	;DON'T REALLY NEED CHANNEL ANY MORE.
	SETOM PRERR	;END OF TAPE
PRCTR1:	HRRM C,PRCHAR
	JRST PRTRAP

WPR:	0
PRDONE:	0
PRBUSY:	0
PRERR:	0
PRCHAR:	0
PRCHAN:	-1	;PR CHANNEL OR -1 IF NONE ALLOC'D.
PRTIM:	60.

APP:	SKIPE WPP	;DETACH FIRST IF ALREADY ATTACHED.
	CALL DPP
	MOVEI A,[SIXBIT/  )PTPPTP   OUTPUT/]
	JRST APP1

APPA:	SKIPA T5,[1]	;ASCII TAPE PUNCH, MODE 1.
APPI:	MOVEI T5,5	;IMAGE TAPE PUNCH, MODE 5.
	HRLM T5,PTPFIL
	MOVEI A,PTPFIL	;ATTACH PAPTER TAPE PUNCH
	PUSHJ P,DGFIL
	SKIPE WPP
	PUSHJ P,DPP
	MOVEI A,PTPFIL
APP1:	CALL GETCHP	;GET CHANNEL & OPEN ON IT.
	HRRZM C,PPCHAN
ZPP:	PUSHJ P,WRDINS
	600000+NPPS,,RPPS
	600000+NPPB,,RPPB
	0
	BLKFLS PPCQB
	PPSBK2,,0
	SETOM PPDONE
	SETZM PPERR
	SETOM WPP
	RETURN

PTPFIL:	SIXBIT /   DSK/
	SIXBIT/PTP   OUTPUT/

DPPA:DPPI:
DPP:	BLKFLS PPCQB	;DETACH PAPER TAPE PUNCH
	PPSBK2,,0
	PUSHJ P,WRDZAP
	RPPS,,RPPB
	SETZM WPP
	SKIPGE C,PPCHAN
	 RET		;NO CHANNEL ALLOCATED.
	SETOM PPCHAN	;ELSE FREE IT.
	JRST CLOSEC

PPSHAK:	TLNN B,54000
	JRST PPSWRT
	ANDI A,100
	SKIPE PPDONE
	TRO A,200
	SKIPE PPERR
	TRO A,100000
	HRRM A,RPPS
PPSWRT:	TLNN B,22000
	RETURN
	 XXWAIT PPSTRP

WPP:	0
PPDONE:	0
PPERR:	0
PPTIM:	300.
PPCHAN:	-1	;-1, OR CHANNEL BEING USED BY PP.

PPCTRP:	SETOM PPDONE
PPSTRP:	MOVEI A,PPSBK2
	SKIPN PPDONE
	SKIPE PPERR
	JRST .+2
	JRST QDEL
	LDB C,[60100,,RPPS]
	JUMPE C,QDEL
	JRST MTRNEW
PPSBK2:	4
	-1
	JRST .+1
	MOVEI T,17
	JSP A,VTRAP

PPBHAK:	HLLZS RPPB
	TLNN B,22000
	RETURN
	 XXWAIT
	SETZM PPDONE
	PUSHJ P,PPSTRP
	SYSCL IOT,[PPCHAN ? RPPB]
	 IOCGET JFCL
	 SETOM PPERR
	ADD C,PPTIM
	JSP A,CTRDES
PPCQB:	0
	-1
	PUSHJ P,PPCTRP

ZLP:	SKIPN WLP
	POPJ P,
ALP:	SKIPE WLP	;ATTACH LINE PRINTER
	PUSHJ P,DLP
	MOVEI A,LPTFIL
	PUSHJ P,DGFIL
	PUSHJ P,OPNLPT
	PUSHJ P,WRDINS
	600000+NLPS,,RLPS
	600000+NLPB,,RLPB
	0
	SETOM WLP
	SETOM LPDONE
	SETZM LPERR
	RETURN

DLP:	PUSHJ P,WRDZAP	;DETACH LINE PRINTER
	RLPS,,RLPB
	BLKFLS LPBTIM
	LPSBRK,,0
	SETZM WLP
CLSLPT:	SOSG LPTCNT
	.CLOSE LPTC,
	RETURN

LPBHAK:	HLLZS RLPB
	TLNN B,22000
	RETURN
	 XXWAIT
	SKIPN LPDONE
	RETURN
	SETZM LPDONE
	PUSHJ P,LPSINT
	HRRZ A,RLPB
	.IOT LPTC,A
	 IOCGET SETOM LPERR
	MOVE C,TIME
	ADD C,LPTIM
	JSP A,CTRDES
LPBTIM:	.
	-1
	PUSHJ P,.+1
	SETOM LPDONE
	JRST LPSINT

LPSHAK:	TLNN B,54000
	JRST LPSWRT
	ADDI A,100
	SKIPE LPDONE
	TRO A,200
	SKIPE A,LPERR
	TRO A,100000
	HRRM A,RLPS
	TLNN B,22000
	RETURN
LPSWRT:	 XXWAIT
LPSINT:	MOVEI A,LPSBRK
	SKIPN LPDONE
	JRST QDEL
	LDB B,[60100,,RLPS]
	JUMPE B,QDEL
	JRST MTRNEW

LPSBRK:	4
	-1
	JRST .+1
	MOVEI T,40
	JSP A,VTRAP

WLP:	0
LPDONE:	0
LPERR:	0
LPTIM:	60.
]

;CONSOLE DATA SWITCHES REGISTER
SWRHAK:	SKIPN DDTPDP
	TLNN B,20000
	RETURN
	MOVE A,RSWR
	MOVEM A,SWR
	 XXWAIT
	MOVE A,SWR
	HRRM A,RSWR
	RETURN

SWR:	0

;SOME PDP11/45 FEATURES
WI45:	0

;CODES IN AC FLD OF 2ND XCT OF A 45IRMA, ETC.
45FSN==0	;NO REGS MIGHT HAVE BEEN ALTERED.
45FSA==1	;REGS IN THE SRC ADDRESS MIGHT HAVE BEEN ALTERED.
45FDN==1
45FDA==3	;REGS IN SRC AND DEST ADDRS MAY HAVE BEEN ALTERED.
45FMTP==4	;SAYS R6 WAS INCR'D, AND CHECK DEST REGS.

DI45:	BLKFLS PIRBLK
	45Y[45TRAB],,0
	PUSHJ P,WRDZAP
	RPIR,,RPIR
45Y[	CALL WRDZAP
	RSSR0,,RSSR2
	CALL WRDZAP
	RSSR3,,RSSR3
	CALL WRDZAP
	RSDR0+40,,RSDR0+137
	CALL WRDZAP
	RUSDR0,,RUSDR0+37	] ;END 45Y
	SETZM WI45
	JRST DPKBLK	;I45 NO LONGER NEEDS PAGE IT SHARES WITH DEVICE PK.

ZI45:	BLKFLS PIRBLK
	45Y[45TRAB],,0
	SKIPN WI45
	 RET
	JRST ZI45A

AI45:	SKIPE WI45
	 CALL DI45
	CALL APKBLK	;GET THE PAGE THAT RSDR0 IS IN.
ZI45A:	PUSHJ P,WRDINS
	600000+NPIR,,RPIR
45Y[
IRP C0,,[U,S,K]C1,,[RUSDR0-RSDR0,40,100]C2,,U
IRPS A0,,I D,A1,,0 10
IRPS B0,,D A,B1,,0 20
REPEAT 8,600000+NS!B0!R!C2,,RSDR0+A1+B1+C1+.RPCNT
TERMIN TERMIN TERMIN
	600000+NSSR0,,RSSR0
	RSSR1
	600000+NSSR2,,RSSR2
	600000+NSSR3,,RSSR3
	600000+NSLR,,RSLR
]
	0
45Y[	MOVE A,[JSP A,45TRAP]
	MOVEM A,45IRU1	;INIT. ALL SEGT TABLES TO REFLECT
	MOVE A,[45IRU1,,45IRU1+1] ;INITIAL SETTING OF SDRS.
	BLT A,45IRU5-1
	MOVSI A,(JFCL)	;BUT 45IRU5 AND 45IRU7 VARS ARE ASSUMED
	MOVEM A,45IRU5	;NEVER TO JUMP AWAY.
	MOVE A,[45IRU5,,45IRU5+1]
	BLT A,45IRUE-1
	CALL SSR0H2	;INIT. X TABLES FOR NO PAGING.
]
	SETOM WI45
	RETURN

45Y[
;11-45 MAP CONSTANTS.

;BITS IN SSR0: (ALL KEPT IN RSSR0)
45BANR==100000	;ABORT-NON-RESEIDENT.
45BASL==40000	;ABORT-SEGMENT-LENGTH
45BARO==20000	;ABORT-READ-ONLY.
45BMMT==10000	;MEMORY MANAGEMENT TRAP.
45BPAT==4000	;PROGRAMMER'S AID SYSTEM TRAP (NOT IMPLEMENTED)
45MR0U==2400	;(UNUSED BIT AND UNIMPLEMENTED MAINT BIT)
45BTPE==1000	;MEM MGMT TRAP ENABLE.
45PTPE==110100
45BIC==200	;INSTRUCTION COMPLETED
45PSGN==10600	;BP TO SEG #, MODE # AND I/D FIELDS.
45BSGE==1	;ENABLE PAGING.

;BITS IN SDR.
45MSDU==100000	;UNUSED BITS IN SDR.
45PSLF==100700	;BP TO SEG LENGTH FLD.
45BACC==200	;"A" BIT - SEG MET CONDITION FOR MEM MGMT TRAP.
45BWRT==100	;"W" BIT - PAGE WAS WRITTEN IN.
45BED==10	;EXPANSION DIRECTION (1 => DOWN)
45PACF==300	;BP TO ACCESS CTL FIELD.

;IN SAR.
45MSAF==7777	;MASK OF SEGMT ADDR FIELD.
45PSAF==1400	;BP TO IT.

;IN PS REGISTER.
45MMDS==174000	;CURRENT MODE, PREVIOUS MODE AND REGISTER SET.

;11-45 MAP VARIABLES:

;X TABLES: ONE FOR EACH SPACE AND TYPE OF ACCESS.
;THESE TABLES ARE XCT'D BY THE 45!<I OR D>!<R OR W>!<MA OR TT> MACROS.
;THE 1ST ENTRY OF EACH IS FOR MA, THE SECOND FOR TT.
;THE X1 TABLES HOLD THE 1ST INSN TO XCT; THE X2'S, THE 2ND.
;IF PAGING IS OFF, THE X TABLES CONTAIN A COPY OF 45IWXI, ETC.
;IF PAGING ON, CONTENTS DEPEND ON PROCESSOR'S CURRENT MODE,
;AND WILL BE A COPY OF 45IWXK, 45IWXS OR 45IWXU; OR, IF THE
;MODE IS 2 (ILLEGAL), EVERY WD WILL CONTAIN A COPY OF 45IWXX.
;IF THE D-SPACE IS DISABLED IN THE CURRENT MODE, 45DWX1 AND ON
;WILL CONTAIN THE SAME THINGS AS 45IWX1 THRU 45DWX1-1.

45IWXX:	[JSP A,45TRA4]	;(THIS WD ISN'T REALLY PART OF THE X TABLES)

45IWX1:	45IWK1(D)	;D IS EXPECTED TO HOLD SEGMENT #.
	45IWK3(D)
45IWX2:	45IWK2(D)
	45IWK4(D)

45IRX1:	45IRK1(D)
	45IRK3(D)
45IRX2:	45IRK2(D)
	45IRK4(D)

45DWX1:	45DWK1(D)
	45DWK3(D)
45DWX2:	45DWK2(D)
	45DWK4(D)

45DRX1:	45DRK1(D)
	45DRK3(D)
45DRX2:	45DRK2(D)
	45DRK4(D)
45IWXE==.-1	;END OF X TABLES.

;THESE WDS HOLD WHAT IS TO BE COPIED INTO THE X TABLES
;WHEN THE PROCESSOR SWITCHES MODE. THERE IS ONE SET FOR EACH MODE.
;THESE TABLES ARE CONSTANT.

IFN 0,[ 45IWXK: 45IWXS: 45IWXU: ]	;THESE ARE THE LABELS DEFINED BY THE IRPC.

IRPC CC,,KSU
45IWX!CC:
IRPS AA,,IW IR DW DR
IRPC BB,,1324
	45!AA!!CC!!BB(D)
TERMIN TERMIN TERMIN

;CONTENTS OF X TABLES WHEN PAGING IS DISABLED.
;EVERY X1 ENTRY IS A JFCL, EVERY X2 A CAIA.
45IWXI: REPEAT 4,[ 45IWI1(D) ? 45IWI3(D) ? [CAIA] ? [CAIA] ? ]

45IWI1:	REPEAT 7,JFCL
	MOVEI MA,300000(MA)	;RELOC ADDRS IN TOP 4 K TO IO REG AREA.

45IWI3:	REPEAT 7,JFCL
	MOVEI TT,300000(TT)

;THE ACTUAL PAGE TABLES: ONE SET FOR EACH SEGMENT.
;A SEGMENT IS IDENTIFIED BY ITS POSITION IN THE MAP (0 - 8),
;ITS MODE (U, S OR K) AND ITS SPACE (I OR D).
;A SEG'T'S IDX IS THE DISPLACEMENT OF ITS SDR FROM RSDR0.
;NOTE THAT USER MODE SDRS AND SARS, THOUGH ADDRESSED BY THE 11
;STARTING AT RUSDR0, ARE REALLY STORED STARTING AT RSDR0,
;JUST BEFORE THE S-MODE SDRS AND SARS. THE WDS AT RUSDR0 ARE HACKED
;UP TO REFER INDIRECTLY TO THOSE AT RSDR0 (VIA MTRAP).
;U-MODE SDRS HAVE INDICES FROM 0 TO 37;
;S-MODE, FROM 40 TO 77; K-MODE, FROM 100 TO 137.
;THE ENTRIES FOR ANY ONE SEGMENT DEPEND ONLY ON WHAT IS IN
;THE SDR AND SAR OF THAT SEGMENT.
;THE 10. WDS FOR ANY ONE SEGMENT CAN BE OBTAINED BY INDEXING
;ONE OF THE FOLLOWING SYMBOLS BY THE SEGMENT'S IDX:
;45IRU1, 45IRU2, 45IRU3, 45IRU4
;	(INSN TO RELOC ADDR IN MA, OR JSP A,45TRAP FOR SPECIAL HACKS,
;	 INSN TO SKIP IF ADDR VALID (NOT BEYOND BNDRY),
;	 2 SIMILAR INSNS FOR ADDR IN TT)
;45IWU1, 45IWU2, 45IWU3, 45IWU4
;	(LIKE THE 1ST 4 BUT FOR WRITING)
;45IRU5, 45IRU7 (THOSE HOLD WHAT 45IRU1, 45IRU3 WOULD HOLD
; IF THERE WERE NO NEED TO TRAP FOR THIS SEGMENT.
; WHEN AN INTERNAL TRAP IS DONE TO SET THE W OR A BIT,
;   45IRU1, 45IRU3, 45IWU1, 45IWU3 FOR THE SEGT MAY BE RESTORED
;   FROM THEM)

IRPS A1,,R W R W R,B1,,12 12 34 34 57
IRPC CC,,UUSSKK,BB,,B1!B1!B1
IRPS A0,,I D
45!A0!!A1!!CC!!BB: REPEAT 8,JSP A,45TRAP
TERMIN TERMIN TERMIN
45IRUE:		;1 + END OF SEGMT TABLES.

;THE MULTIPLE GENERAL REGISTER SETS:
;THE CONTENTS OF THE REG SET IN USE ARE KEPT IN R0...R5,
;WHILE THOSE OF THE SET NOT IN USE ARE KEPT IN THE SET ITSELF
;(45REG0 OR 45REG1)

45REGY:	R0,,45REG0	;R0,,<REG SET NOW IN USE>
45REGN:	R0,,45REG1	;R0,,<REG SET NOT NOW IN USE>

45REG0:	BLOCK 6		;THE 2 REGISTER SETS.
45REG1:	BLOCK 6

45REG6:	BLOCK 4		;THE 4 REGISTER 6'S.
	;AGAIN, THE REAL CONTENTS OF THE R6 THAT'S IN USE
	;ARE NOT HERE, BUT IN R6.


;RANDOM VARIABLES:
45MODE:	0		;CURRENT PROCESSOR MODE
			;(0=KERNEL, 1=SUP, 2 UNUSED, 3=USER)

45STAT:	0		;CURRENT STATE (MODE AND REGISTER SET BIT)
45SGON:	0		;-1 => SEGMENTATION ENABLED.
RSSR2A:	0		;REAL CONTENTS OF SSR2 KEPT HERE.
ROSSR0:	0	;RSSR0'S ERROR FLAGS SAVED HERE AT 45TRAP
		;IF ROSSR0 ISN'T 0, RSSR0 ISN'T ALTERED.

;ROUTINE CALLED FROM NEWPS MACRO IF EITHER THE MODE OR THE REGISTER SET
;HAS CHANGED (THAT IS, IF THE CURRENT STATE HAS CHANGED)
45NMOD:	EXCH 0,45STAT
	XORI 0,(PS)	;IS THE OLD STATE SAME AS NEW?
	TRNN 0,45MODM
	 JRST 45NMO2	;THE MODE IS THE SAME, SIMPLE.
	LDB A,[45CMOD,,PS] ;MODE HAS BEEN CHANGED
	SAVE B		;SET UP THE R6 FOR THE NEW MODE.
	MOVE B,45REG6(A)	;GET IT FROM ITS RESTING PLACE,
	EXCH B,R6		;PUT IT WHERE INSNS CAN USE IT,
	EXCH A,45MODE
	MOVEM B,45REG6(A)	;PUT OLD MODE'S R6 BACK IN HANGER.
	SKIPE 45SGON	;IF PAGING IS ENABLED, UPDATE X-TABLES
	 CALL SSR0H4	;TO POINT TO SEGMENTS OF THE NEW CURRENT MODE.
	REST B
45NMO2:	TRNN 0,45REGB	;HAS THE REGISTER SET CHANGED?
	 RET
	MOVE A,45REGN	;YES, SWITCH THE ONE IN USE
	EXCH A,45REGY	;WITH THE ONE NOW NOT IN USE.
	MOVEM A,45REGN
	MOVE 0,A	;COPY CONTENTS OF THAT NO LONGER IN USE
	BLT 0,5(A)	;INTO THEIR RESTING PLACE (45REG0 OR 45REG1)
	MOVS 0,45REGY	;MOVE CONTENTS OF THOSE NOW IN USE
	BLT 0,R5	;TO WHERE INSNS WILL BE ABLE TO FIND THEM.
	RET

45NMO3:	45IWXK,,45IWX1	;BLT PTR FOR LOADING X TABLES FOR KERNEL MODE.
	45IWXS,,45IWX1
	45IWXX,,45IWX1	;BLT PTR TO PROPAGATE [JSP A,45TRA4] THRU X TABLES.
	45IWXU,,45IWX1	;BLT PTR FOR LOADING X TABLES FOR USER MODE.

45DSNB:	4	;INDEX THIS TABLE BY THE MODE NUMBER,
	2	;TO GET THE BIT IN RSSR3 WHICH, IF ON,
	0	;ENABLES THE D-SPACE OF THE MODE.
	1

;ROUTINE FOR THE STACK LIMIT REGISTER.
;THE VALUE IS REALLY KEPT IN RSLR BUT A SLIGHTLY MODIFIED VALUE
;IS KEPT IN 45SLR FOR FASTER CHECKING FOR PDL OV.
SLRHAK:	TLNN B,220000	;WHEN RSLR IS MODIFIED,
	 RET
	XXWAIT		;MUST UPDATE RSLR1 TO REFLECT IT.
	HRROI B,177400	;FLUSH LOW BYTE.
	ANDB B,RSLR
	ADDI B,400	;GET ADDR OF WARNING STACK BNDRY.
	HRRZM B,RSLR1
	RET

SSR3HK:	TLNN B,220000
	 RET
	XXWAIT
	SKIPE 45SGON	;SSR3 ALTERED - MAYBE THE D-SPACE OF THE CURRENT
	 CALL SSR0H4	;MODE WAS ENABLED OR DISABLED.
	RET		;REINIT THE X-TABLES JUST IN CASE.

SSR2HK:	MOVE A,RSSR2A	;SSR2 IS READ-ONLY - PUT THE REAL VALUE
	HRRM A,RSSR2	;WHERE THE SIMULATED INSN CAN FIND IT.
	RET

;DEVICE REG RTN FOR A U-MODE SAR - REFER INDIRECTLY TO WHERE
;INFO IS REALLY STORED (NEAR RSAR0)
SARUHK:	MOVEI A,@-2(D)	;GET ADDR OF THE SAR,
	MOVE C,RSDR0-RUSDR0(A)	;GET VALUE FROM WHERE SAR REALLY KEPT,
	HRRM C,(A)	;PUT IT WHERE PRGM WILL SEE IT.

;ROUTINE FOR ORDINARY SARS, KEPT WHERE THEY'RE USED.
SARHAK:	TLNN B,220000	;NOTHING TO DO IF NOT WRITING.
	 RET
	MOVEI A,@-2(D)	;ALL THE SARS SHARE THIS CODE, FIND OUT WHICH THIS IS.
	MOVEM A,45DWRT
	XXWAIT
	MOVE A,45DWRT
	HRROI B,45MSAF
	ANDM B,(A)	;FLUSH ALL BUT THE SEGT LENGTH FIELD.
	SUBI A,RSAR0	;GET # OF SAR REL TO 1ST.
	CAIGE A,140	;IF THIS IS U-MODE SAR, RELOC ADDR TO GET IDX.
	 JRST 45DHA1	;RECOMPUTE SEGMT TAB WDS FOR THIS SEGT
	MOVE B,RSAR0(A)
	SUBI A,RUSDR0-RSDR0
	HRRM B,RSAR0(A)	;PUT WHAT USER WROTE IN PLACE
	JRST 45DHA1	;THAT IT IS NORMALLY STORED.

;ROUTINE FOR U-MODE SDRS.
SDRUHK:	MOVEI A,@-2(D)
	MOVE C,RSDR0-RUSDR0(A)
	HRRM C,(A)

;ROUTINE FOR ORDINARY SDRS.
SDRHAK:	TLNN B,220000
	 RET
	MOVEI A,@-2(D)
	MOVEM A,45DWRT
	XXWAIT
	MOVE A,45DWRT
	MOVEI B,100300	;TURN OFF IN THE SDR WHAT USER
	ANDCAB B,(A)	;ISN'T SUPPOSED TO SET.
	SUBI A,RSDR0
	CAIGE A,140	;IF THIS IS U-MODE SDR,
	 JRST 45DHA1
	SUBI A,RUSDR0-RSDR0	;GET OFFSET OF REAL SDR INSTEAD PHONY.
	HRRM B,RSDR0(A)
;DROPS THROUGH.

;DROPS THROUGH.
;RECOMPUTE THE SEGMT TAB WDS FOR ONE SEGT WHOSE SAR OR SDR WAS CHANGED.
;A HAS OFFSET OF THE SEGT'S ASR FROM THE 1ST ASR.
45DHA1:	MOVE B,RSDR0(A)	;GET SEGT'S SDR,
	LDB C,[45PSLF,,B]	;CALCULATE AMOUNT TO RELOCATE AN ADDR BY.
	LSH C,5
	LDB D,[45PSAF,,RSAR0(A)]
	LSH D,5
	ADD C,D
	TRNN B,45BED
	 ADDI C,40	;IF EXPAND UP, THAT'S 1ST WD OF LAST BLOCK
	HRLI C,(CAIL MA,)
	TRNE B,45BED
	 TLC C,(CAIGE#CAIL)	;IF DOWN, IT'S 1ST WD OF 1ST BLOCK.
	MOVEM C,45IRU2(A)	;INSN TO CHECK THAT ADDR IN MA
	MOVEM C,45IWU2(A)	;IS IN RANGE.
	TLC C,(<0 MA,>#<0 TT,>)
	MOVEM C,45IRU4(A)	;INSN TO CHECK ADDR IN TT.
	MOVEM C,45IWU4(A)
	LDB C,[300,,A]
	LSH C,14
	SUB D,C
	HRLI D,(MOVEI MA,(MA))	;INSN TO RELOCATE ADDR THE RIGHT AMOUNT.
	MOVEM D,45IRU1(A)
	MOVEM D,45IWU1(A)
	MOVEM D,45IRU5(A)
	HRLI D,(MOVEI TT,(TT))
	MOVEM D,45IRU3(A)	;SIMILAR BUT FOR ADDR IN TT.
	MOVEM D,45IWU3(A)
	MOVEM D,45IRU7(A)
	MOVE D,[JSP A,45TRAP]	;BUT PERHAPS WE SHOULD TRAP INSTEAD.
	LDB C,[45PACF,,B]
	JRST @.+1(C)
	45DHA2
	45DHA2
	45DHA3
	45DHA2
	45DHA2
	45DHA3
	45DHA4
	45DHA2

45DHA2:	MOVEM D,45IRU1(A)	;CATCH READS AND WRITES IN THIS SEG.
	MOVEM D,45IRU3(A)
45DHA3:	MOVEM D,45IWU1(A)	;CATCH ONLY WRITES.
	MOVEM D,45IWU3(A)
	RET

45DHA4:	TRNN B,45BWRT
	 JRST 45DHA3	;READ WRITE BUT NOT WRITTEN IN YET =>
			;MUST CATCH WRITES TO SET WRITTEN BIT.
	RET

45DWRT:	0
45ASLP:	0	;WHILE IN 45TRAP, -1 IFF SEGMENT LENGTH VIOLATION.

;COME HERE WHEN TRY TO DO ACCESS IN MODE 2 (WHICH IS ILLEGAL)
45TRA4:	JSR 45TRAI	;PUSHES A, SETS ROSSR0 FROM RSSR0
	SAVE B
	SAVE C
	SAVE D
	LDB C,[270400,,-1(A)]	;GET AC FLD OF 1ST XCT, WHICH SAYS
	DPB C,[30100,,D]	;0 FOR I SPACE, 1 FOR D SPACE.
	ADDI D,40	;PUT 2 IN AS MODE; D HAS SEG # FOR SSR0.
	SKIPN ROSSR0	;DON'T CHANGE SSR0 IF ERROR FLAGS SET.
	 DPB D,[45PSGN,,RSSR0]
	JRST 45TRAA

;45IRMA, ETC. MACROS DO JSP A,45ASL
;WHEN THERE IS AN ABORT-SEGMENT-LENGTH CONDITION.
45ASL:	SUBI A,2	;MAKE A -> THE 2ND XCT OF THE 45IRMA.
	JSR 45TRAI	;PUSHES A, SETS ROSSR0.
	MOVEI A,45BASL	;INDICATE THIS IS SEGT LENGTH FAILURE.
	SKIPN ROSSR0
	 IORM A,RSSR0
	SETOM 45ASLP	;TELL 45TRAP THIS IS SEG'T LENGTH FAILURE, NOT ACCESS CODE LOSSAGE.
	SKIPA A,(P)

;1ST INSN XCT'D DOES JSP A,45TRAP IF REFS TO THAT SEGT MUST BE CAUGHT.
45TRAP:	JSR 45TRAI	;IN THIS CASE, A ALREADY -> 2ND XCT.
	SAVE B
	SAVE C
	SAVE D
	MOVEI B,@-1(A)	;GET ADDR THAT 1ST XCT XCTED.
			;(THIS WILL BE AN ENTRY IN 45IRU1 OR 45IRU3)
	CAIL B,45IRU3	;IF IN 45IRU3, MAKE -> CORRESP ENTRY IN 45IRU1
	 SUBI B,45IRU3-45IRU1 ;(ALSO 45IWU3 BECOMES 45IWU1)
	CAIL B,45IWU1	;IF WERE WRITING, REMEMBER THAT FACT IN SIGN(D)
	 HRLI D,4^5
	CAIL B,45IWU1	;NOW GET ADDR OF SEGT'S 45IRU1 ENTRY.
	 SUBI B,45IWU1-45IRU1
	SUBI B,45IRU1	;NOW B HAS SEGMENTS IDX.
	CAIGE B,140
	JUMPGE B,.+2
	 .VALUE		;RIDICULOUS SEGT IDX.
	HRRI D,(B)
	LDB A,[50200,,D] ;LOW 4 BITS OF D HAVE SEGT # AND I VS D.
	ANDCMI D,-20
	ADD D,[3_4 ? 1_4 ? 0](A) ;NOW NEXT 2 BITS HAVE SEGT'S MODE.
	SKIPN ROSSR0
	 DPB D,[45PSGN,,RSSR0] ;STORE THAT INFO FOR PRGM.
	MOVE C,RSDR0(B)	;GET SDR FOR THIS SEG.
	LDB A,[45PACF,,C]
	MOVE A,45TRA2(A) ;NOW DISPATCH ON ACCESS ALLWED FOR SEG
	JUMPGE D,(A)	;AND DIRECTION OF ACCESS.
	IORI C,45BWRT	;IF WERE WRITING, SET "WRITTEN" BIT FOR SEG.
	HRRM C,RSDR0(B)
	HLRZ A,A
	JRST (A)

;FOR EACH ACCESS TYPE, 2 LETTERS (GIVING 2 HALFWDS)
;A FOR ABORT, W FOR ABORT-READ-ONLY, M FOR MEM MGMT TRAP,
;N FOR DO NOTHING (IF WRITE), E FOR DO NOTHING (IF READ)
45TRA2:	.BYTE 18.
IRPS AA,,AA WM WE AA MM ME NE AA
IRPC BB,,AA
	45TRA!BB
TERMIN TERMIN
	.BYTE

;COME HERE TO GIVE READ-ONLY ABORT.
45TRAW:	SKIPA D,[45BARO]	;SET APPRO BIT IN RSSR0.

;COME HERE FOR NOT-RESIDENT ABORT.
45TRAA:	SKIPE DDTPDP
	 ERROR [ASCIZ/NONRES/]
	MOVEI D,45BANR
	IORM D,RSSR0
45TRAL:	MOVEI D,45BIC	;INSN NOT COMPLETED - WE ABORTED.
	ANDCAM D,RSSR0
	HRRZ D,OPC	;GIVE PRGM ADDR OF START OF INSN.
	LSH D,1
	HRRM D,RSSR2A
;NOW FIGURE OUT WHICH REGISTERS WERE AUTOINCREMENTED
;OR DECREMENTED, AND PUT THE INFO IN SSR1.
	HLLZS RSSR1
	LDB A,[270400,,@-3(P)] ;AC FLD OF 2ND XCT.
	AOSN IMTPR6	;IF TRAPPED OUT OF MTPI,
	 JRST [MOVEI MA,26	;SAY WD WAS POPPED OFF R6.
		HRRM MA,RSSR1
		JRST .+1]
	JUMPE A,45FALX	;THIS 45IRMA SAID NO REGS COULD HAVE CHANGED.
		;(TAKES CARE OF FUNNY CASES SUCH AS FAULT
		;DURING INSN FETCH OR VTRAP)
	SAVE MA		;ELSE GROVEL AROUND.
	HRRZ MA,OPC	;RE-FETCH THE INSN BEING EXECUTED.
	LDB D,[SEGBP,,MA]
	XCT 45IRU5(D)	;(DON'T USE 45IRU1 SINCE MIGHT JSP TO 45TRAP)
	MOVE B,PDP11(MA) ;DON'T CALL MTRAPR A SECOND TIME.
	LDB MA,[061200,,B]	;GET IDX INTO I1TAB.
	SKIPL I1TAB(MA)	;THIS INSN NOT 2 ADDRESS INSN =>
	 ANDCMI A,1	;DON'T WORRY ABOUT SRC ADDRESS.
	JUMPE A,45FALZ
	HLL A,I1TAB(MA)	;BIT 4.8 SAYS WHETHER WD INSN OR BYTE.
	TRZN A,1	;LOOK AT SRC ADDR IF NEC.
	 JRST 45FAL1
45FAL0:	LDB MA,[110300,,B]	;GET ADDRESS MODE OF THIS ADDR.
	CAILE MA,1	;IS IT AUTOINC OR AUTODEC?
	CAIL MA,6
	 JRST 45FAL1	;NO.
	LDB D,[060300,,B]
	CAIN D,7	;R7 TAKEN CARE OF BY SSR2, IGNORE IT HERE.
	 JRST 45FAL1
	ROT MA,-1	;(INDIRECT BIT IN SIGN)
	CAIN D,6	;R6 MOVES EVEN # ALWAYS, SO PRETEND
	 TLO MA,400000	;THIS WAS A WORD INSN.
	ADD D,45FAL3-1(MA)	;SAY THIS REG CHANGED BY 1.
	SKIPL MA	;BUT IF INDIRECT ADDR OR WD INSN
	TLNE A,200000
	 ADD D,45FAL3-1(MA) ;IT WAS CHANGED BY 2.
	LDB MA,[1000,,RSSR1]
	DPB MA,[101000,,RSSR1]
	DPB D,[1000,,RSSR1]	;PUT THIS INFO IN SSR1.
45FAL1:	LSH B,8		;MOVE DEST ADDR WHERE SRC ADDR SHOULD BE,
	TRZE A,2	;LOOK AT DEST ADDR IF NEC.
	 JRST 45FAL0
45FALZ:	REST MA
45FALX:	JRST 45TRA3

45FAL3:	10		;AUTOINCR MOVES UP 1,
	-10		;AUTODECR MOVES DOWN.

;COME IF READING AND NO SPECIAL HACK REQUIRED BY ACCESS CODE.
45TRAE:	SKIPE 45ASLP	;THE ONLY THING THAT COULD GET HERE IS
	 JRST 45TRAL	;A SEGMENT LENGTH ABORT.
	.VALUE

;COME HERE TO GIVE MEM MGMT TRAP AND SET A-BIT IN SDR.
45TRAM:	SKIPE DDTPDP
	 JRST 45TRAX	;NO MEM MGMT TRAPS FROM DDT REFERENCES.
	IORI C,45BACC	;SET THE A-BIT.
	HRRM C,RSDR0(B)
	SKIPE 45ASLP	;IF GOT HERE FROM 45ASL, LET
	 JRST 45TRAL	;ABORT TAKE PRECEDENCE OVER TRAP.
	MOVE A,45IRU5(B) ;NOW THAT A-BIT SET, NO NEED
	MOVEM A,45IRU1(B) ;FOR FUTURE REFS TO SEGT TO SET IT.
	TRNE C,45BWRT
	 MOVEM A,45IWU1(B)
	MOVE A,45IRU7(B)
	MOVEM A,45IRU3(B)
	TRNE C,45BWRT
	 MOVEM A,45IWU3(B)
	LDB A,[45PTPE,,RSSR0]
	JUMPE A,45TRAX	;IF INT NOT ENABLED, NO TRAP.
	MOVEI C,45BMMT+45BIC	;ELSE SAY TRAPPING AND INSN COMPLETED.
	IORM C,RSSR0
	MOVEI A,45TRAB
	CALL MTRNEW
45TRAX:	REST D
	REST C
	REST B
	REST A
	JRST -1(A)	;RETRY THE RELOCATION PROCESS
			;(CAN'T GET HERE FROM 45ASL)

45TRAB:	4,,500000
	-1
	JRST .+1
	MOVEI T,250/4
	JRST VTRAP	;TAKE MEM MGMT TRAP.

45TRAN:	SKIPE 45ASLP	;WRITING BUT NOTHING SPECIAL TO DO:
	 JRST 45TRAL	;CAME FROM 45ASL => DO THE ABORT.
	MOVE A,45IRU1(B) ;ELSE WE ALREADY SET THE WRITTEN BIT, SO
	MOVEM A,45IWU1(B) ;FUTURE WRITES NEEDN'T BE CAUGHT.
	MOVE A,45IRU3(B)
	MOVEM A,45IWU3(B)
	JRST 45TRAX

45TRA3:	SUB P,[4,,4]	;FLUSH THE PUSHED ACS.
	MOVEI T,250/4	;ABORT DUE TO PAGE FAULT.
	JRST TRPINS

;INITIALIZE AT ENTRY TO PAGE TRAP RTNS.
;SAVE A, AND COPY THE ERROR FLAGS FROM RSSR0P0 TO ROSSR0.
;PAGE TRAP RTNS SHOULD NOT ALTER RSSR0 IF ROSSR0 IS NONZERO.
45TRAI:	0	;CALL WITH JSR.
	SETZM 45ASLP	;THIS ISN'T A SEG'T LENGTH PROBLEM.
	SAVE A
	MOVE A,RSSR0
	ANDI A,45BANR+45BASL+45BARO+45BMMT+45BPAT
	SKIPE DDTPDP	;IN DDT, PREVENT MODIFICATION OF RSSR0
	 SETO A,
	MOVEM A,ROSSR0	;REMEMBER WHAT THE ERROR FLAGS ARE.
	MOVE A,(P)
	JRST @45TRAI

;ROUTINE FOR REFERENCE TO SSR0.
SSR0HK:	TLNN B,220000	;IF NOT WRITIG, NOTHING SPECIAL.
	 RET
	XXWAIT
	MOVEI B,45MR0U	;USER HAS WRITTEN: CLEAR THE UNUSED BITS.
	ANDCAB B,RSSR0
	MOVEI A,45TRAB	;IF MEM MGMT TRAP PENDING BUT USER
	TRNN B,45BTPE	;HAS JUST DISABLED THEM, FLUSH IT.
	 CALL QDEL
	TRNN B,45BSGE	;SEE IF USER HAS TURNED PAGING ON OR OFF.
	 JRST SSR0H1
	SKIPE 45SGON	;NOW ON: WAS IT OFF?
	 RET
	SETOM 45SGON	;YES, SAY NOW ON,
SSR0H4:	MOVE A,45MODE	;NOW LOAD THE APPROPRIATE STUFF
	MOVE B,45DSNB(A)
	MOVE A,45NMO3(A) ;INTO THE X TABLES.
	TDNE B,RSSR3	;CURRENT MODE'S D-SPACE ENABLED =>
	 JRST [BLT A,45IWXE ;2ND HALF OF X-TABLES PTS TO D-SPACE SEGS.
		RET]
	BLT A,45DWX1-1	;ELSE MAKE I-SPACE PART NORMAL
	MOVE A,[45IWX1,,45DWX1]
	BLT A,45IWXE	;THEN MAKE 2ND HALF PT TO I-SPACE, TOO.
	RET

SSR0H1:	SKIPL 45SGON	;NOW OFF: WAS IT ON?
	 RET
SSR0H2:	SETZM 45SGON	;YES, SAY NOW OFF,
	MOVE B,[45IWXI,,45IWX1]
	BLT B,45IWXE	;FILL X TABLES WITH THEIR NON-PAGING VALUES.
	RET
]	;END 45Y

PIRHAK:	TLNN B,22000	;PROGRAMMED INTERRUPT
	RETURN
	 XXWAIT
	MOVEI A,PIRBLK
	PUSHJ P,QDEL
	HRRZ B,RPIR
	TRZ B,777
	HRRM B,RPIR
	JFFO B,.+2
	RETURN
	SUBI C,27.	;GET NEG OF PRIORITY
	MOVNS C
	DPB C,[10300,,RPIR]
	DPB C,[50300,,RPIR]
	JSP A,MTRDES
PIRBLK:	0
	-1
	JRST .+1
	MOVEI A,PIRBLK
	PUSHJ P,MTRNEW
	MOVEI T,240/4
	JSP A,VTRAP

;   THE EAE
AEAE:	PUSHJ P,WRDINS
	IRPS X,,[DIV,MQ,MUL,SCSR,NOR,LGS,ARS]
	600000+N!X,,R!X
	TERMIN
	0,,RAC
	0
	SETOM WEAE
	RETURN

DEAE:	PUSHJ P,WRDZAP
	RDIV,,RARS
	SETZM WEAE
	RETURN

;SET WORD IN RANGE TO NXM
;	PUSHJ P,WRDZAP
;	FROM,,TO	;INCLUSIVE
;
WRDZAP:	HLRZ A,@(P)	;SET WORDS TO NXM
	HRRZ B,@(P)
	SUBM A,B
	SOS B
	HRL A,B
	MOVSI B,600000
WRDZP2:	LDB C,[MARPOS,,(A)]
	MOVEM B,(A)
	DPB C,[MARPOS,,(A)]
	AOBJN A,WRDZP2
POPJ1:	AOS (P)
	RETURN

DIVHAK:	HLLZS RDIV
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ A,RMQ
	LSH A,2
	HRL A,RAC
	TLNE A,100000
	TLO A,600000
	HRRZ C,RDIV
	LSH C,2
	TRNE C,400000
	TLO C,-1
	JFCL 17,.+1
	IDIV A,C
	ASH B,-2
	MOVEI C,3
	SKIPL A
	MOVEI C,0
	DPB C,[160200,,SCSR]
	DPB A,[2000,,RMQ]
	DPB B,[2000,,RAC]
	JFCL 10,DIVOVF
	MOVMS A
	CAIGE A,20000
	RETURN
DIVOVF:	TRC C,2
	DPB C,[160200,,SCSR]
	RETURN

MQHAK:	TLNN B,22000
	RETURN
	 XXWAIT
	MOVE A,RMQ	;EXTEND SIGN INTO AC
	TRNN A,100000
	JRST MQTRP2
	MOVEI A,177777
	HRRM A,RAC
	RETURN

MQTRP2:	HLLZS RAC
	RETURN

MULHAK:	HLLZS RMUL
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ A,RMQ
	LSH A,2
	TRNE A,400000
	TLO A,-1
	HRRZ C,RMUL
	LSH C,2
	TRNE C,400000
	TLO C,-1
	IMUL A,C
	MOVEI C,3
	SKIPL A
	MOVEI C,0
	DPB C,[160200,,SCSR]
	LSH A,-2
	HLRM A,RAC
	LSH A,-2
	DPB A,[2000,,RMQ]
	RETURN

SCSRHK:	TLNN B,54000
	JRST SCSRH2
	HRRZ C,SCSR
	TRZ C,37000
	HRRZ A,RMQ
	TRNN A,177777
	TRO C,6000	;MQ=0 (ALSO SET AC=MQ=0)
	HRRZ B,RAC
	TRCN B,177777
	TRO C,10000	;AC=0
	TRNN B,177777
	TRO C,20000	;AC=-1
	TRNN C,10000
	TRZ C,2000	;TURN OFF AC=MQ=0
	TRNN A,100000
	TRNN C,10000
	SKIPA
	TRO C,1000	;SINGLE PRECISION
	TRNE A,100000
	TRNN C,20000
	SKIPA
	TRO C,1000	;"
	HRRM C,RSCSR
SCSRH2:	TLNN B,22000
	RETURN
	 XXWAIT
	MOVE A,RSCSR
	ANDI A,140477
	HRRM A,SCSR
	RETURN

SCSR:	0
WEAE:	-1

LGSHAK:	HLLZS RLGS
	TLNN B,22000
	RETURN
	 XXWAIT LGSTRP

ARSHAK:	HLLZS RARS
	TLNN B,22000
	RETURN
	 XXWAIT
	SKIPA C,RARS
LGSTRP:	HRRZ C,RLGS
	TRNE C,100000
	TRO C,600000
	HRRZ B,RMQ
	LSH B,2
	HRL B,RAC
	LSH B,2
	AND C,[400000,,77]
	TRNE C,40
	TRO C,777700
	SKIPGE C
	SKIPL B
	TDZA A,A
	MOVNI A,1
	JFCL 17,.+1
	SKIPL C
	LSHC A,(C)
	SKIPGE C
	ASHC A,(C)
	TRNE C,400000
	LDB A,[30100,,B]
	TRNN C,400000
	ANDI A,1
	DPB A,[80100,,SCSR]	;LAST BIT SHIFTED OUT
	MOVEI A,1
	SKIPL B
	SOJA A,ARLGPS
	DPB A,[160100,,SCSR]
	JFCL 10,[SOJA A,.+1]
	DPB A,[170100,,SCSR]
ARLGPT:	LSH B,-2
	HLRM B,RAC
	LSH B,-2
	DPB B,[2000,,RMQ]
	MOVE A,SCSR
	TRZ A,77
	HRRM A,SCSR
	RETURN

ARLGPS:	DPB A,[160100,,SCSR]
	JFCL 10,[AOJA A,.+1]
	DPB A,[170100,,SCSR]
	JRST ARLGPT

NORHAK:	MOVE A,SCSR
	ANDI A,77
	HRRM A,RNOR
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ B,RMQ
	LSH B,2
	HRL B,RAC
	LSH B,2
	JUMPE B,NORZRO
	CAMN B,[-1,,777760]
	JRST NORMON
	CAMN B,[777774,,]
	JRST NORHLF
	TDZA C,C
NORLUP:	LSHC A,1
	TLNN B,400000
	JRST NORTR2
	TLNE B,200000
	AOJA C,NORLUP
NORTR4:	MOVE I,SCSR
	TRZ I,77
	TRO I,(C)
	HRRM I,SCSR
	ANDI A,1
	DPB A,[80100,,SCSR]
	MOVEI A,3
	SKIPL B
	MOVEI A,0
	DPB A,[160200,,SCSR]
	LSH B,-2
	HLRM B,RAC
	LSH B,-2
	DPB B,[2000,,RMQ]
	RETURN

NORTR2:	TLNN B,200000
	AOJA C,NORLUP
	JRST NORTR4

NORZRO:	MOVEI C,31.
	MOVEI A,0
	JRST NORTR4

NORMON:	SKIPA C,[30.]
NORHLF:	MOVEI C,30.-16.
	MOVSI A,600000
	JRST NORTR4

TXN[
ANULDI:	PUSHJ P,DNGDIS
	PUSHJ P,BLKGET
	600000,,RNGCSR
	PUSHJ P,WRDINS
	0,,RNGCSR
	0,,RNGREL
	0
	POPJ P,

DNULDI:	PUSHJ P,BLKZAP
	RNGCSR
	POPJ P,


;NG DISPLAY

ANGDIS:	SKIPE WNGDIS
	PUSHJ P,DNGDIS
	.DSTART NULDIS
	JRST DISLOS
	PUSHJ P,BLKGET
	600000,,RNGCSR
	PUSHJ P,BLKGET
	NGBLK
	PUSHJ P,BLKGET
	NGBLK+2000
	PUSHJ P,WRDINS
	600000+NNGCSR,,RNGCSR
	0,,RNGREL
	0
	SETOM WNGDIS
	SETZM NGSTOP
	SETZM NGLNXM
	MOVE A,[-5,,NGDATA]
	HRRM A,NGMBE-NGDATA(A)
	SETZM (A)
	AOBJN A,.-2
	MOVE B,[20154,,221000]
	MOVEM B,(A)
	MOVE B,[120000,,600001]
	MOVEM B,1(A)
	MOVE B,[20000,,220000]
	MOVEM B,2(A)
	MOVE B,[121000,,600400]
	MOVEM B,3(A)
	MOVEI B,3000
	MOVEM B,4(A)
	MOVEM B,5(A)
	ADDI A,6
	MOVEM A,NGMBE+5
	JRST NGSIMD

NGDMOD==136
WNGDIS:	0
DISOUT:	0
NGCURC:	-1	;CURRENT "CONSOLE" #

NGMBE=NGBLK
NGSTOP=NGMBE+6	;-1=CONSOLE STROP INTERRUPT REQ
NGLNXM=NGSTOP+1
NGCURP=NGLNXM+1	;CURRENT CONSOLE POINTER
NGPCPC=NGCURP+1	;CURRENT CONSOLE #
NGXCO=NGPCPC+3
NGYCO=NGXCO+3
NGDATA=NGYCO+3

DNGDIS:	.DCLOSE
	PUSHJ P,BLKZAP
	RNGCSR
	PUSHJ P,BLKZAP
	NGBLK
	BLKFLS NGSIMB
	NGINTB,,NGCNS0
	NGCNS1,,NGCNS2
	0
	SETZM WNGDIS
	SETZM DISOUT
	RETURN

NGSIMD:	SKIPL NGCURC
	RETURN
	MOVEM TIME,RTIME
	MOVEI I,3
	PUSHJ P,NGOPEN
	MOVEI X,1
	PUSHJ P,NGSMOD
	MOVEI X,220777
	PUSHJ P,DISINS
	MOVEI X,1000
	PUSHJ P,DISINS
	SETZM NGCMOD
	SETOM DISOUT
	PUSHJ P,CREGS
	PUSHJ P,CBUSS
	SETZM DISOUT
	PUSHJ P,NGSTRT
	MOVE C,TIME
	ADDI C,2*WAITTS
	JSP A,CTRDES
NGSIMB:	0
	-1
	PUSHJ P,NGSIMD

NGFRZ:	BLKFLS NGCNS0
	NGCNS1,,NGCNS2
	0
NGCINT:	JSP A,MTRDES
NGINTB:	5
	-1
	JRST .+1
	SETZM NGSTOP
	MOVEI T,56
	JSP A,VTRAP


NGCSRK:	TLNN B,54000
	JRST NGCSRW
	ANDI A,170407
	IOR A,NGLNXM
	HRRM A,RNGCSR
	TLNN B,22000
	RETURN
NGCSRW:	 XXWAIT
	HRRZ B,RNGCSR
	MOVEI I,0
	PUSHJ P,NGGOGO
	MOVEI I,1
	PUSHJ P,NGGOGO
	MOVEI I,2
	PUSHJ P,NGGOGO
	TRNE B,60000
	TROA B,100000	;NXM FROM EXTENSION BITS
	TRNE B,100000
	TRNN B,10000
	SKIPA
	JRST NGFRZ
	TRNE B,400
	AOSE NGSTOP
	RETURN
	JRST NGCINT

NGINFO:	1,,NGCNS0
	2,,NGCNS1
	4,,NGCNS2

IRPC X,,[012]
NGCNS!X:	6,,
	-1
	PUSHJ P,NGCNR!X
	TERMIN

NGGOGO:	HRRZ A,NGINFO(I)
	HLRZ C,NGINFO(I)
	TRNN B,(C)
	JRST QDEL
	SKIPL 1(A)
	RETURN
	PUSHJ P,MTRNEW
	MOVE A,I
	MOVEM A,NGPCPC(I)
	SETZM NGXCO(I)
	SETZM NGYCO(I)
	RETURN

NGCNR0:	TDZA I,I
NGCNR1:	MOVEI I,1
	SKIPA
NGCNR2:	MOVEI I,2
	PUSHJ P,NGOPEN
	MOVEI X,1
	PUSHJ P,NGSMOD
	MOVEI X,220000
	ADD X,NGYOF(I)
	ADDI X,400
	PUSHJ P,DISINR
	MOVEI X,0
	ADD X,NGXOF(I)
	ADDI X,400
	PUSHJ P,DISINR
	SETZM NGCMOD
	MOVE MA,NGPCPC(I)
NGMLUP:	ANDI MA,77777
	MOVE TT,MA
	PUSHJ P,NGGETL
	MOVE MB,T
	TRNN MB,140000
	AOJA MA,NGMLUP
	TRNN MB,100000
	JRST NGMLP0
	TRNN MB,40000
	JRST NGMLPJ
	TRNE MB,20000
	AOJA MA,NGMLUP
	TRNN MB,14000
	JRST NGMLCN
	TRNN MB,10000	;POINT MODE
	JRST NGMXYY
	LDB X,[800,,MB]
	ADDB X,NGXCO(I)
	ADDI X,200
	ANDI X,377
	LSH X,1
	ADD X,NGXOF(I)
	PUSHJ P,NGXYIN
NGMXYY:	TRNN MB,4000
	AOJA MA,NGMLUP
	LDB X,[800,,MB]
	ADDB X,NGYCO(I)
	ADDI X,200
	ANDI X,377
	LSH X,1
	ADD X,NGYOF(I)
	TRO X,200000
	PUSHJ P,NGXYIN
	AOJA MA,NGMLUP

NGXOF:	0
	1000
	0
NGYOF:	1000
	1000
	0

NGPOP:	MOVEI TT,8(I)
	PUSHJ P,NGGETL
	ADDI T,2
	ANDI T,177777
	HRRM T,PDP11(TT)
	LSH T,-1
	SOS TT,T
	ANDI TT,77777
NGGETL:	MOVE T,RNGREL
	LSH T,-1
	ADD TT,T
	TRNE TT,700000
	JRST NGTNXM
	SKIPGE T,PDP11(TT)
	JSP D,NGMTRW
	RETURN

NGRNXM:	SUB P,[1,,1]
NGTNXM:	SUB P,[1,,1]
	.VALUE

NGXYIN:	TRNE MB,2000
	TRO X,2000	;INTENSIFY
	PUSH P,X
	MOVEI X,1
	PUSHJ P,NGSMOD
	POP P,X
	SETZM NGCMOD
DISINR:	HRRZ T,NGCURP
	ADDI T,2
	CAML T,NGMBE+1(I)
	JRST DISERR
	IDPB X,NGCURP
	RETURN

DISERR:	HRRZM I,QT
	TTOA [ASCIZ /
OVERFLOW DIS CONSOLE T/]
	SUB P,[1,,1]
	JRST NGMSTP

NGMLPJ:	EXCH MA,MB	;PUSHJ
	AOS MB
	ANDI MB,77777
	LSH MB,1
	MOVEI TT,8(I)
	PUSHJ P,NGGETL
	SUBI T,2
	ANDI T,177777
	HRRM T,PDP11(TT)
	MOVE TT,T
	LSH TT,-1
	PUSHJ P,NGGETL
	HRRM MB,PDP11(TT)
	JRST NGMLUP

NGMLP0:	MOVEI X,6	;INCREMENT
	PUSHJ P,NGSMOD
	LDB E,[130300,,MB]	;DIRECTION
	LDB TT,[100300,,MB]	;COUNT
	SKIPN TT
	MOVEI TT,8
	MOVNM TT,NGTEM
	MOVE T,[100,,MB]
	DPB TT,[360600,,T]
	MOVE TT,T
NGMLPZ:	ILDB T,TT
	LDB T,NGLDB(E)
	XCT NGXINC(T)
	XCT NGYINC(T)
	LSH T,@NGCMD2
	LDB X,NGCURP
	IOR X,T
	DPB X,NGCURP
	MOVNI X,4
	ADDB X,NGCMD2
	SKIPGE X
	PUSHJ P,NGSTIN
	AOSGE NGTEM
	JRST NGMLPZ
	AOJA MA,NGMLUP

NGTEM:	0
NGLDB:	REPEAT 8,40000*.RPCNT+400,,NGLDC(T)
NGLDC:	05460634202
	35677735652

NGXINC:	REPEAT 8,JFCL
	REPEAT 4,AOS NGXCO(I)
	REPEAT 4,SOS NGXCO(I)
NGYINC:	REPEAT 4,[JFCL
	JFCL
	AOS NGYCO(I)
	SOS NGYCO(I)
]

NGMLCN:	TRNE MB,2000	;CONTROL COMMAND
	SETZM NGXCO(I)	;RESET X
	TRNE MB,1000
	SETZM NGYCO(I)	;RESET Y
	TRNE MB,200
	PUSHJ P,NGPOP
	TRNE MB,400
	JRST NGMSTP
	TRNN MB,100
	AOJA MA,NGMLUP
	PUSHJ P,NGPOP
	LSH T,-1
	HRRZ MA,T
	JRST NGMLUP

NGMSTP:	HLRZ A,NGINFO(I)
	ANDCAM A,RNGCSR
	SETOM NGSTOP
	JRST NGSTRT

;OPEN SPACE TO PUT IN DISPLAY COMMANDS
NGOPEN:	SKIPL NGCURC
NGOPNF:	TTOA [ASCIZ /
DISPLAY PHASE ERROR/]
	MOVEM I,NGCURC
	.DSTOP
	MOVE MA,NGMBE+5
	CAILE MA,NGBLK+4000
NGOPNE:	TTOA [ASCIZ /
DISPLAY POINTERS ERROR/]
	CAIL MA,NGBLK+4000
	JRST NGOPE4
	MOVEI MB,NGBLK+4000
	MOVEM MB,NGMBE+5
	MOVEI X,4
NGOPE2:	SOS MA
	SOS MB
	MOVE T,(MA)
	MOVEM T,(MB)
	CAMLE MA,NGMBE(X)
	JRST NGOPE2
	CAME MA,NGMBE(X)
	JRST NGOPNE
	HRRM MB,NGMBE(X)
	CAIGE I,-1(X)
	SOJA X,NGOPE2
	CAIE I,-1(X)
	JRST NGOPNE
NGOPE4:	MOVE X,NGMBE(I)
	TLO X,442200
	MOVEM X,NGCURP
	MOVEI X,NGDMOD
	IDPB X,NGCURP
	SETZM NGCMOD
	RETURN
]
;LIST PROCESS GENERAL REGISTERS AND CONTENTS
CREGS:	MOVSI T6,REGBIT
	PUSH P,SF
	SKIPL DDTPDP		;IF NOT IN DDT,
	HRLZ SF,%TMODE		;GET TEMP. MODES.
CREGS2:	MOVE T,R0(T6)
	MOVEM T,QT
	CRF
	ADRTYP T6
	TTOA [ASCIZ &/   T&]
	AOS T6
	TRNN T6,10
	JRST CREGS2
	POP P,SF
CRPOPJ:	CRF
	RETURN


TXN[
DISINS:	HRRZ T,NGCURP	;DISPLAY INSERT
	CAMGE T,NGMBE+1(I)
	IDPB X,NGCURP
	RETURN

DISIN0:	PUSH P,X
	MOVEI X,0
	PUSHJ P,DISINS
	POP P,X
	RETURN

NGSMOD:	CAMN X,NGCMOD	;SET MODE
	RETURN
	HRRZ T,NGCMOD
	JRST .+1(T)
	JRST NGSTRM
	JRST NGSTRM
	.VALUE
	JRST NGCHEX
	JRST NGVIEX
	JRST NGVIEX
	JRST NGVIEX
	.VALUE

NGSTRM:	LDB T,NGCURP
	DPB X,[150300,,T]
	DPB T,NGCURP
	MOVEM X,NGCMOD
	JRST .+1(X)
	RETURN
	RETURN
	.VALUE
	JRST NGSTCH
	RETURN
	RETURN
	JRST NGSTIN
	.VALUE

NGCHEX:	PUSH P,[NGVIEY]
	PUSH P,I
	PUSH P,X
	PUSH P,T
	PUSH P,A
	MOVEI A,37
	JRST DISCHH

NGVIEX:	LDB T,NGCURP
	TRO T,400000
	DPB T,NGCURP
NGVIEY:	SETZM NGCMOD
	PUSHJ P,DISIN0
	JRST NGSMOD

NGSTCH:	PUSHJ P,DISIN0
NGST14:	MOVEI T,14
	MOVEM T,NGCMD2
	RETURN

NGSTIN:	PUSH P,X
	MOVEI X,200000
	PUSHJ P,DISINS
	POP P,X
	JRST NGST14

NGCMOD:	0	;CURRENT HWD MODE
NGCMD2:	0	;IF CUR MODE IS CHAR OR INC, HAS P OF NEXT FREE FIELD


DISCH:	PUSH P,I
	MOVEI I,3
	PUSH P,X
	PUSH P,T
	PUSH P,A
	MOVEI X,3
	PUSHJ P,NGSMOD
	ANDI A,177
	CAIN A,12
	JRST DISLF
	CAIN A,15
	JRST DISCR
	CAIL A,140
	SUBI A,40
	SUBI A,40
	SKIPGE A
	TTOA [ASCIZ /
BAD DISPLAY CHAR/]
	XORI A,40
	ANDI A,77
DISCHH:	LSH A,@NGCMD2
	LDB X,NGCURP
	IOR X,A
	DPB X,NGCURP
	MOVNI X,6
	ADDB X,NGCMD2
	SKIPGE X
	PUSHJ P,NGSTCH
DCHRET:	POP P,A
	POP P,T
	POP P,X
	POP P,I
	RETURN

DISLF:	MOVEI A,33
	JRST DISCHH

DISCR:	MOVEI X,1
	PUSHJ P,NGSMOD
	MOVEI X,1016
	PUSHJ P,DISINS
	MOVEI X,3
	PUSHJ P,NGSMOD
	JRST DCHRET

;CLOSE UP DISPLAY LIST AND START
NGSTRT:	SKIPGE I,NGCURC
	JRST NGOPNF
	MOVEI X,0
	PUSHJ P,NGSMOD
	MOVE MA,NGCURP
	TLNE MA,770000
	PUSHJ P,DISIN0
	MOVEI MA,1(MA)
	CAMLE MA,NGMBE+1(I)
	JRST NGOPNE
	CAML MA,NGMBE+1(I)
	JRST NGSTR4
	MOVE X,NGMBE+1(I)
	HRL MB,X
	HRR MB,MA
	SUBB MA,X
	ADD MA,NGMBE+5
	BLT MB,-1(MA)
NGSTR2:	ADDM X,NGMBE+1(I)
	AOS I
	CAIGE I,5
	JRST NGSTR2
NGSTR4:	SETOM NGCURC
	.DSTART [-4000+NGDATA-NGBLK,,NGDATA-1]
	JRST DISLOS
	RETURN

AMASTE:	TLOA A,-1
DMASTE:	TLZ A,-1
	.MASTER A,
	JRST MSTLOS
	RETURN

MSTLOS:	TTOA 1,[ASCIZ /
MASTER MODE/]
DISLOS:	TTOA [ASCIZ /
DISPLAY/]
	TTOA [ASCIZ / NOT AVAILABLE/]
	RETURN

NULDIS:	-3,,.	;NULL DISPLAY LIST
	3000
	3000

;THE RK11 DISK

;FUNCTIONS: RKF!FNC
IRPS Y,,CRS WRT RED WCH SEK RCH DRS WLK
RKF!Y==.IRPCN
TERMIN

;BITS IN RKDS REGISTER
;KEPT IN RKDDSR WORDS UNLESS SAYS OTHERWISE IN PARENS.

RKBSOK==400	;SECTOR COUNT VALID (COMPUTED FROM TIME WHEN RKDS READ)
RKBDRY==200	;DRIVE READY (IE ATTACHED)
RKBARDY==100	;ACCESS READY, NOT DOING A SEEK.
RKBWPS==40	;WRITE-LOCKED.
RKBSCA==20	;SELECTED SECTOR UNDER HEADS NOW (COMPUTED FROM TIME)

;BITS IN RKER REGISTER (ALL ACTUALLY KEPT IN RRKER1)
RKBDRE==100000	;RKBDRY WASN'T ON WHEN USED DRIVE.
RKBOVR==40000	;OVERFLOWED OUT OF LAST CYL.
RKBWLO==20000	;WROTE ON WRITE LOCKED PACK.
RKBSKE==10000	;SEEK ERROR.
RKBPGE==4000	;"PROGRAMMING ERROR"
RKBNXM==2000	;RK REFERENCED NON EX MEM.
RKBDLT==1000	;ACCOMPANIES RKBNXM, "DATA LATE".
RKBNXD==200	;TRIED TO USE NON EX DRIVE.
RKBNXC==100	;NON EX CYL.
RKBNXS==40	;NON EX SECTOR (>12.)
RKBWCE==1	;WRITE-CHECK ERROR (SOFT ERROR)

;BITS IN RKCS REGISTER (KEPT THERE UNLESS SAYS NOT)

RKBERR==100000	;ERROR (READ AS 1 IF RRKER1 NOT 0)
RKBHE== 40000	;HARD ERROR (READ AS 1 IF RRKER1 NOT 0 OR 1)
RKBSCP==20000	;SEARCH COMPLETE
RKBINH==10000	;INHIBIT MA INCR.
RKBFMT==4000	;"FORMAT" (IGNORED)
RKBRWA==2000	;READ-WRITE ALL (IGNORED)
RKBSSE==400	;STOP ON SOFT ERROR.
RKBRDY==200	;CONTROL READY (READ AS 1 IF RKRDY NOT 0)
RKBIDE==100	;INTERRUPT ENABLE.
RKPXM==040200	;BP TO MA EXTENSION BITS.
RKBGO== 1	;GO.

RKNSEC==12.	;# SECTORS/TRACK.
RKNCYL==313	;# CYLS/DRIVE.

IFNDEF RKNDRV,RKNDRV==2	;2 DRIVES.
IFNDEF RKNBUF,RKNBUF==8	;8 BUFFERS.
IFNDEF DFNDRV,DFNDRV==2	;2 RF-11 DISKS.

RKBUF=NGBLK-6000*RKNBUF	;START OF 1ST BUFFER.

RKDRIV:	0	;RKDTAB IDX OF CURRENTLY SELECTED DRIVE.

;THIS TABLE HAS 1 ENTRY FOR EACH RK OR DF DRIVE.
RKDTAB:
REPEAT RKNDRV+DFNDRV,[
	0 ? -1
	CALL RKDWA1	;CLOCK QUEUE BLOCK FOR DRIVE.
	0		;PC TO RESTART AT CLOCK QUEUE.
	.RPCNT_15+RKBSOK ;DSR FOR DRIVE (DRIVE NUM. IN ID FIELD)
	0		;SELECTED CYL AND SECTOR NUM.
	'DSK		;FILENAME BLOCK.
IFL .RPCNT-RKNDRV,	'RK11_14
.ELSE			'DF11_14
	'DRIVE0+.RPCNT
	0		;SNAME.
	'DSK,,		;LEFT-JUST DEV NAME FOR .CALL OPEN.
	0		;CURRENT FUNCTION, -1 => WANTS SEARCH COMPLETE INT.
	RKDIR+.RPCNT*RKNCYL*2(D)	;-> ROOM IN RKDIR OR DFDIR FOR
		;THIS DRIVE'S DIRECTORY. INDEX OF D FOR INDIRECTION.
]
RKDTBL==<.-RKDTAB>/<RKNDRV+DFNDRV>	;LENGTH OF ENTRY.
DFDRVI==RKDTBL*RKNDRV	;IDX OF 1ST RF-11 DRIVE.

IF1 [
IRPS YY,,QBL UNUS UNUS PC DSR ADR FIL FN1 FN2 SNM DEV FNC DIR
RKD!YY=.IRPCNT+RKDTAB
DEFINE RKC!YY
RKD!YY(B)TERMIN
TERMIN
] ;END IF1.


RKDIR:	REPEAT RKNDRV,BLOCK 2*RKNCYL	;ONE DIRECTORY PER DRIVE.
DFDIR:	REPEAT DFNDRV,BLOCK 2*RKNCYL
;EACH DRIVE'S DIRECTORY HAS 2 HALVES, EACH 1 WORD PER CYL.
;1ST HALF: 1 WD FOR EACH CYL OF ADDRESS SPACE IN THE DISK.
;0 => NO SPACE ALLOCATED, >0 => POSITION IN FILE OF SPACE
	;(1 MEANS STARTS AT 1K, 2 MEANS 4K, 3 MEANS 7K, ETC)
;<0 => IN CORE, LH IS 1'S COMP. OF BUFFER #,
	;RH 1'S COMP. OF POSITION IN FILE OF SPACE TO SWAP OUT INTO.
;2ND HALF: 1 WD FOR EACH 3K OF SPACE IN FILE:
;0 => SPACE IS UNUSED. >0 => 1'S COMP. OF # OF CYL ALLOCATED TO

;BUFFER TABLES, INDEX BY BUFFER NUM.
RKBFT0:	REPEAT RKNBUF,0	;POSITIVE => BUFFER HAS BEEN WRITTEN IN.
RKBFT1:	REPEAT RKNBUF,-1	;-1 IF FREE, ELSE DRIVE IDX,,ADDR OF RKDIR ENTRY FOR CYL.
RKBFT2:	REPEAT RKNBUF,-1	;-1 IF FREE, ELSE NUMBER OF LAST TRANSACTION.
RKBFT3:	REPEAT RKNBUF, -6000,,RKBUF+6000*.RPCNT	;AOBJN -> BUFFER.

RKCNT:	0	;INCREMENTED FOR EACH TRANSACTION, PUT IN RKBFT2 ENTRY
		 ;(FOR SWAPPING OUT LEAST RECENTLY USED)

RKCHAN:	-1	;CHANNEL NUMBER ALLOCATED TO RK11 AND RF11, OR -1 IF NONE.

RKDOPN:	0	;NONNEG => RKDTAB IDX OF DRIVE OPEN FOR INPUT ON RKCHAN,
		; NEG => 1'S COMPLEMENT OF IDX OF DRIVE OPEN FOR WRITING.

WRK:	0	;-1 IFF RK ATTACHED.
RKDCNT:	0	;# DRIVES ATTACHED.
RKRDY:	-1	;READY
RRKER1:	0	;ERROR BITS KEPT HERE.
RKSERC:	0	;-1 IFF SOME DRIVE(S) WAITING FOR SEARCH-COMPLETE INT.
RKINSD:	0	;# OF DRIVE THAT HAS BEEN ALLOWED TO INT SEARCH-COMPLETE.
RKLOCP:	0	;BP. IN BUFFER, FOR TRANSFERS.
RKSCWC:	0	;# WDS LEFT THIS SECTOR.
RKWIOR:	0	;ON WRITE, IOR OF ALL WORDS WRITTEN.
RKTIM:	32500.	;SECTOR ROTATION TIME
RKCTIM:	3350.	;EXTRA SEEK TIME PER CYL
RKXTIM:	100000.	;BASIC SEEK TIME.

RKCSHK:	MOVE A,RRKCS	;GET ACTUAL VALUE,
	MOVEM A,RRKOCS'	;SAVE OLD VALUE BEFORE PROGRAM WROTE IT.
	TLNN B,54000	;CTRL, STATUS REG.
	JRST RKCSWR
	ANDCMI A,RKBRDY+RKBERR+RKBHE+RKBGO	;BITS NOT REALLY KEPT THERE.
	SKIPE RKRDY
	 IORI A,RKBRDY	;TURN ON READY BIT IF NEC.,
	SKIPE C,RRKER1
	 IORI A,RKBERR	;ERROR BIT IF ERROR REG NONXERO,
	TRNE C,177774
	 IORI A,RKBHE	;HARD ERROR IF NEC.
	HRRM A,RRKCS
	TLNN B,22000
	POPJ P,
RKCSWR:	XXWAIT
	MOVE A,RRKCS	;GET VALUE WRITTEN,
	ANDCMI A,RKBRDY+RKBERR+RKBHE+RKBGO	;FLUSH BITS KEPT ELSEWHERE.
	EXCH A,RRKCS	;GET BACK THE RKBGO THAT WAS WRITTEN.
	TRNN A,RKBGO
	 JRST [ANDCM A,RRKOCS	;IF GO WASN'T SET,
		SKIPE RKRDY	;AND WE'RE READY,
		TRNN A,RKBIDE	;AND IDE HAS JUST BEEN SET,
		 RET
		JRST RKINTR]	;GIVE INTERRUPT.
	MOVEI A,RKBWCE
	ANDCAM A,RRKER1	;NEW FUNCTION, CLEAR SOFT ERRORS.
	LDB A,[010300,,RRKCS]
	JUMPE A,RKGOCR	;CONTROL RESET DOESN'T SELECT A DRIVE.
	LDB B,[150300,,RRKDA]
	MOVEI C,RKBNXD
	CAIL B,RKNDRV
	 JRST RKERR	;ELSE ERROR IF DRIVE NUM. TOO LARGE.
	IMULI B,RKDTBL	;COMPUTE RKDTAB IDX OF DRIVE.
	MOVEM B,RKDRIV	;THIS DRIVE NOW SELECTED.
	MOVEI C,RKBDRE
	MOVE T,RKCDSR	;GET DRIVE'S STATUS,
	TRNN T,RKBDRY
	 JRST RKERR	;NOT ATTACHED => DRIVE ERROR.
	JRST @.(A)	;ELSE DISPATCH TO FUNCTION.
	REPEAT 5,RKGOSK	;SEEK AND ALL TRANSFER OPERATIONS.
	RKGODR
	RKGOWL

;SEEK, READ, WRITE ETC. COME HERE TO ACCESS.
RKGOSK:	MOVEI C,RKBSKE	;SEEK ERROR IF HEADS MOVING.
	TRNN T,RKBARDY
	 JRST RKERR
	TRNE T,RKBWPS
	CAIE A,RKFWRT	;WRITING AND WRITE LOCKED => ERROR.
	 JRST RKGOS0
	MOVEI C,RKBWLO
	JRST RKERR

RKGOS0:	SETZB C,RKRDY
	LDB T,[400,,RRKDA]
	CAIL T,RKNSEC
	 IORI C,RKBNXS	;SECTOR NUM. TOO LARGE.
	LDB T,[051000,,RRKDA]
	CAIL T,RKNCYL
	 IORI C,RKBNXC	;CYL NUM. TOO LARGE.
	JUMPN C,RKERR	;ANY OF THOSE ERRORS => SAY SO.
	MOVEM A,RKCFNC	;ELSE REMEMBER WHAT FUNCTION THIS DRIVE DOING,
	CAIN A,RKFSEK
	 CALL RKINTR	;IF SEEK, CONTROLLER READY NOW, MAYBE INTERRUPT.
	MOVEI C,RKBARDY
	ANDCAM C,RKCDSR	;THIS DRIVE'S HEADS NOW MOVING.
	LDB C,[1500,,RRKDA]
	EXCH C,RKCADR	;REMEMBER WHAT CYL AND SECT SELECTED.
	LDB C,[051000,,C]
	SUB C,T		;# CYLS MUST MOVE THE HEADS.
	MOVMS C
	JUMPE C,RKGOS3	;TAKES NO TIME IF SAME CYL.
	IMUL C,RKCTIM
	ADD C,RKXTIM	;TIME SEEKING WILL TAKE.
	JSP A,RKDWAT	;QUEUE UP DRIVE TAT LONG FROM NOW, RETURN.
RKGOS3:	MOVEI C,RKBARDY
	IORM C,RKCDSR	;REACHED CYL, SAY HEADS NO LONGER MOVING.
	MOVE A,RKCFNC
	CAIE A,RKFSEK
	 JRST RKGOS2	;NOT SEEK => FIND THE RIGHT SECTOR.
	SETOM RKCFNC	;SAY WANT A SEARCH-COMPLETE INTERRUPT.
	SETOM RKSERC	;SAY THAT SOME DRIVE WANTS ONE.
	JRST RKINSC	;TRY TO TAKE INT NOW; RETURN.

;COME FOR READ, WRITE, ETC AFTER REACHED SELECTED CYL.
;REACHED FROM CLOCK QUEUE.
RKGOS2:	CALL RKSECT	;PUT CURRENT SECTOR NUM. IN A.
	LDB C,[400,,RKCADR]
	SUB C,A		;SELECTED-CURRENT.
	CAIGE C,
	 ADDI C,RKNSEC	;SUBTRACT MOD 12.
	IMUL C,RKTIM
	JSP A,RKDWAT	;WAIT TILL SHOULD START TRANSFER.
	MOVEI C,RKWCHK	;GET ADDR. OF RTN FOR THIS OPERATION.
	CAIN A,RKFWRT
	MOVEI C,RKWRIT
	CAIN A,RKFRED
	MOVEI C,RKREAD
	CAIN A,RKFRCH
	MOVEI C,RKRCHK
	LDB A,[130100,,RRKCS]
	HRLI C,(JRST)	;INH BAR INC
	SKIPN A
	HRLI C,(AOJA MA,)
	MOVEM C,RKLOOP	;SAVE INSN TO INCR MA (MAYBE) AND DO NEXT WD.
	LDB D,[051000,,RRKDA]
	CALL RKSETU	;SWAP IN THE CYL, RETURN BP IN C.
	 JRST [ MOVEI D,RKWRTN	;WRITING IN CYL WITH NO SPACE ALLOC'D,
		HRRM D,RKLOOP	;SEE IF WRITING ANY NONZEROS BEFORE
		JRST .+1]	;TRYING TO ALLOCATE SPACE.
	MOVEM C,RKLOCP
	LDB D,[0500,,RRKDA] ;GET SECTOR NUM,
	TRZE D,20
	ADDI D,14	;CHANGE TO # OF SECTOR WITHIN CYL,
	MOVEI C,(D)
	IMULI C,200	;FIND THAT SECTOR'S OFFSET IN BUFFER,
	ADDM C,RKLOCP	;MAKE BP -> THAT SECTOR.
	SETZM RKWIOR	;(INIT. SO CAN TELL IF WROTE A NONZERO WORD)
RKGOT6:	MOVE C,RKTIM	;COMEE HERE TO HANDLE NEXT SECTOR IN CYL.
	JSP A,RKDWAT	;WAIT TILL TRANSFER SHOULD BE OVER BEFORE DOING IT.
	LDB D,[0500,,RRKDA]
	TRZE D,20
	 ADDI D,14	;CALC. SECTOR NUMBER AGAIN.
	LDB MA,[011700,,RRKBA]
	LDB C,[RKPXM,,RRKCS]
	DPB C,[170200,,MA] ;PUT TOP 2 BITS INTO ADDRESS.
	MOVEI C,400
	MOVEM C,RKSCWC	;INIT. COUNT OF WDS IN SECTOR.
	ADDI D,1	;INCREMENT SECTOR ADDR,
	CAIG D,13
	 JRST RKGOT3
	SUBI D,14	;SECOND SURFACE MAYBE (IE CHANGE TO SURFACE NUM AND SECT NUM)
	TRO D,20
	CAIN D,34	;MAYBE OVERFLOWED TO NEXT CYL.
	 MOVEI D,40
RKGOT3:	DPB D,[0500,,RRKDA]
	ANDI D,40
	ADDM D,RRKDA	;HANDLE OVERFLOW TO NEXT CYL.
	JRST @RKLOOP	;HANDLE 1ST WORD.

RKGET:	MOVSI TT,-RKNBUF	;NO, FIND BUFFER TO READ INTO.
	MOVSI C,200000	;LARGE POS. NUM FOR HOW-GOOD-IS-BEST-SO-FAR.
RKGET2:	CAMG C,RKBFT2(TT)
	 JRST RKGET3	;THIS BUFFER NOT BETTER.
	MOVE C,RKBFT2(TT)	;IT IS BETTER, REPLACE BEST SO FAR.
	MOVEI T,(TT)
RKGET3:	AOBJN TT,RKGET2
	JUMPL C,CPOPJ	;DONE IF BUFFER FREE.
	SKIPG RKBFT0(T)	;NO, WRITTEN IN?
	 JRST [HRRZ C,RKBFT1(T)	;WASN'T WRITTEN, JUST SAY THAT TRACK
		HRRZS (C)	;IS NO LONGER IN CORE.
		RET]
	SAVE B		;WAS WRITTEN IN, MUST SWAP OUT.
	HLRZ B,RKBFT1(T)	;WHICH DRIVE'S IS IT?
	CALL RKOUTO	;OPEN THAT DRIVE FOR OUTPUT.
	REST B
RKGET6:	HRRZ C,RKBFT1(T) ;GET ADDR OF RKDIR ENTRY,
	HRRZS C,(C)	;GET BLOCK NUM IN FILE, ALSO SAY CYL NOT IN CORE.
	JRST RKXFER	;WRITE THE BUFFER OUT.

RKSETU:	SKIPN A,@RKCDIR	;A_RKDIR ENTRY FOR THIS CYL.
	 JRST [MOVE A,RKCFNC	;CYL NOT IN FILE,
		CAIN A,RKFWRT
		 JRST RKNEW1	;WRITING, SEE IF WRITING ZEROS.
		JRST RKGOT4]	;NOT WRITING, FAKE BP TO READ 0'S.
	JUMPL A,RKGOT2	;ALREADY IN CORE?
	CALL RKGET	;OBTAIN BUFFER TO READ INTO, IDX IN T.
	CALL RKINO	;OPEN DRIVE FOR INPUT.
RKGET5:	HRRZ C,@RKCDIR
	CALL RKXFER	;READ CYL FROM FILE INTO BUFFER.
RKNEW4:	SETCM C,T
	HRLM C,@RKCDIR	;PUT -1#<BUFFER NUM> INTO LH OF RKDIR ENTRY.
	SETZM RKBFT0(T)	;BUFFER NOT WRITTEN IN YET.
	MOVEI C,@RKCDIR
	HRLI C,(B)	;REMEMBER DRIVE,,RKDIR-ADDR FOR BUFFER.
	MOVEM C,RKBFT1(T)
	JRST RKGOT1

RKGOT2:	HLRO T,A	;CYL ALREADY IN CORE,
	SETCA T,	;GET BUFFER NUMBER.
RKGOT1:	AOS C,RKCNT	;GET NUMBER OF THIS TRANSFER,
	MOVEM C,RKBFT2(T) ;REMEMBER SO CAN SWAP OUT LEAST RECENTLY USED.
	HRRZ C,RKCFNC
	CAIN C,RKFWRT	;WRITING => SAY THIS BUFFER MODIFIED.
	 AOS RKBFT0(T)
	HRRZ C,RKBFT3(T) ;GET ADDR BEG OF BUFFER,
	HRLI C,442200	;RETURN BP TO ILDB FROM BUFFER.
	JRST POPJ1

RKNEW1:	MOVSI C,442200	;CYL NOT ALLOC'D => NEED LH OF BP FOR IBP'S.
	RET		;NO SKIP => CYL NOT ALLOC'D AND WRITING.

RKGOT4:	SETZ C,		;READING EMPTY CYL => FETCH ZERO-BYTES.
	JRST POPJ1

RKWRTN:	SKIPGE MB,PDP11(MA)	;WRITE IN CYL WHICH IS EMPTY.
	 JSP D,MTRRKR
	JUMPE MB,[IBP RKLOCP ? JRST RKINCR]
	LDB D,[051000,,RRKDA]
	MOVE B,RKDRIV
	CALL RKNEW5	;CREATE THE CYL.
	 JFCL
	ANDI C,-1
	ADDM C,RKLOCP	;UPDATE BP SO POINTS TO BUFFER.
	MOVEI C,RKWRIT
	HRRM C,RKLOOP
	JRST (C)

RKNEW5:	CALL RKGET	;GET BUFFER (IDX IN T)
	MOVE C,RKBFT3(T)	;CREATING A CYL, GOT THE BUFFER..
	SETZM (C)
	AOBJN C,.-1	;CLEAR IT OUT.
	SAVE D		;REMEMBER CYL NUM.
	MOVEI D,RKNCYL	;LOOK FOR FREE SLOT IN FILE.
	SKIPE @RKCDIR
	 AOJA D,.-1
	REST C
	SETCAM C,@RKCDIR ;SAY THIS CYL USING THE SLOT.
	EXCH C,D
	SUBI C,RKNCYL-1	;GET # OF SLOT, (1ST SLOT # 1)
	MOVEM C,@RKCDIR	;SAY THIS CYL HAS IT.
	JRST RKNEW4

RKWRIT:	SKIPGE MB,PDP11(MA)
	JSP D,MTRRKR
	IDPB MB,RKLOCP
	IORM MB,RKWIOR
	JRST RKINCR

RKREAD:	SKIPGE PDP11(MA)
	JSP D,MTRRKW
	ILDB MB,RKLOCP
	HRRM MB,PDP11(MA)
	JRST RKINCR

RKWCHK:	SKIPGE MB,PDP11(MA)
	JSP D,MTRRKR
	ILDB TT,RKLOCP
	CAIN TT,(MB)
	JRST RKINCR
	MOVEI C,RKBWCE	;WRITE-CHECK ERROR.
	IORM C,RRKER1
	AOS T,RRKWC	;BUT UPDATE RKWC, RKBA.
	JRST RKINC1

RKRCHK:	IBP RKLOCP
RKINCR:	AOS T,RRKWC	;INCR. WORD COUNT.
	TRNN T,177777
	 JRST RKINC1	;XFER COMPLETE.
	SOSLE RKSCWC	;STILL SAME SECTOR =>
RKLOOP:	0		;INCR. MA AND DO NEXT WD.
RKINC1:	DPB T,[2000,,RRKWC] ;DON'T LET RRKWC GET TO BE 200000 .
	HLRZ D,RKLOOP	;INCR. MA OVER LAST WD XFERED IF NEC.
	CAIN D,(AOJA MA,)
	 AOJ MA,
	DPB MA,[011700,,RRKBA] ;PRETEND HAD BEEN INCR'ING THIS INSTEAD MA.
	LSH MA,-17	;GET UPDATED TOP 2 BITS OF ADDRESS
	DPB MA,[RKPXM,,RRKCS] ;STORE WHERE THEY'RE REALLY KEPT.
	TRNN T,177777
	 JRST [HRRZ A,RKLOOP	;TRANSFER FINISHED -
	 	CAIE A,RKWRIT
		 JRST RKINTR
		JRST RKWRT0]	;WRITING, ZERO REST OF SECTOR.
	MOVE B,RKDRIV	;MTRRKR AND MTRRKW CLOBBER B.
	LDB D,[0500,,RRKDA]
	TRNE D,37
	 JRST RKGOT6	;SAME CYL, JUST REINIT RKSCWC AND INCR SECTOR NUM.
	LDB D,[051000,,RRKDA] ;CYL. NUM.
	MOVEI C,RKBOVR
	CAIL D,RKNCYL
	 JRST RKERR	;PAST END OF DISK, ERROR.
	MOVE A,RKCFNC
	JRST RKGOS0	;SEEK TO THAT CYL AND KEEP GOING.

RKWRT0:	SETZ A,
RKWRT1:	SOSG RKSCWC	;COUNT WDS LEFT IN SECTOR,
	 JRST RKINTR
	IDPB A,RKLOCP	;STORE 0 IN EACH.
	JRST RKWRT1

RKNXM0:	DPB MA,[011700,,RRKBA] ;SAVE THE UPDATED VALUE.
	SUB P,[1,,1]	;FLUSH RET ADDR IN MTRAP.
	MOVEI C,RKBNXM

;CALL HERE TO RECORD AN ERROR (BIT IN C) AND MAYBE INTERRUPT.
RKERR:	IORB C,RRKER1
	TRNE C,177774
	 JRST RKINTR	;HARD ERROR, TRY TO INTERRUPT.
	MOVE C,RRKCS	;IT'S SOFT,
	TRNN C,RKBSSE	;MAYBE INTERRUPT.
	 RET
RKINTR:	SETOM RKRDY	;CONTROLLER READY, MAYBE INTERRUPT.
	MOVE C,RRKCS
	TRNN C,RKBIDE
	 JRST RKINSC	;NOT ENABLED, GO FLUSH RQS FOR SEARCH-COMPLETE INT.
	JSP A,MTRNEW	;ENABLED, INTERRUPT.
RKINTB:	5
	-1
	JRST .+1
	MOVEI A,RKBSCP
	ANDCAM A,RRKCS
	JRST RKINT1

;CHECK FOR ANY DRIVES THAT WANT SEARCH-COMPLETE INTS.
;IF INTS DISABLED, FLUSH RQS.
;IF ENABLED, PICK ONE AND ARRANGE FOR IT TO INTERRUPT.
RKINSC:	SKIPE RKRDY	;CONTROLLER NOT READY OR NOONE WANTS ONE => DONE.
	SKIPL RKSERC
	 RET
	SKIPL RKINTB+1	;CAN'T GIVE 2 INTS AT ONCE.
	 RET
	MOVSI B,-RKNDRV	;ELSE CHECK EACH DRIVE.
RKINS1:	SKIPL RKCFNC
	 JRST RKINS2	;THIS DRIVE DOESN'T WANT ONE.
	MOVE A,RRKCS
	TRNN A,RKBIDE
	 JRST RKINS4	;INTS NOT ENABLED - FLUSH THE RQ.
	MOVEM B,RKINSD	;ELSE LET THIS DRIVE INT.
	JSP A,MTRNEW
RKINSB:	5
	-1
	JRST RKINS3

RKINS4:	SETZM RKCFNC	;THIS DRIVE NO LONGER WANTS ONE.
RKINS2:	ADDI B,RKDTBL-1
	AOBJN B,RKINS1
	SETZM RKSERC	;NO DRIVE WANTS ONE NOW.
	RET

RKINS3:	MOVE B,RKINSD	;TAKE A SEARCH-COMPLETE INT. HERE.
	SETZM RKCFNC	;THIS DRIVE GOT ONE, SO DOESN'T WANT ONE.
	MOVEM B,RKDRIV	;IT IS NOW SELECTED SO ITS DSR IS IN RKDS.
	MOVEI B,RKBSCP
	IORM B,RRKCS	;SAY THIS IS SEARCH-COMPLETE INT.
RKINT1:	CALL RKINSC	;MAYBE ANOTHER DRIVE WANTS ONE TOO.
	MOVEI T,44
	JRST VTRAP	;TRAP THRU VECTOR 220.

;ACCESS 6000-WORD BLOCK WHOSE NUMBER IS IN C.
RKACC:	IMULI C,6000
	SUBI C,4000	;GET ADDR IN FILE.
RKACC1:	.CALL [SETZ ? 'ACCESS ? RKCHAN ? SETZ C]
	 .LOSE %LSFIL
	RET

;TRANSFER BLOCK W/ NUM IN C INTO BUFFER (NUM. IN T)
RKXFER:	CALL RKACC
	MOVE C,RKBFT3(T)	;GET AOBJN -> BUFFER,
RKIOT:	.CALL [SETZ ? 'IOT,,? RKCHAN ? SETZ C]
	 .LOSE %LSFIL
	JUMPL C,.-1
	RET

RKOPNB:	SETZ
	SIXBIT/OPEN/
	RKCHAN
	RKCDEV
	RKCFN1
	RKCFN2
	RKCSNM
	404000,,C	;OPEN-MODE IN C.

RKSECT:	SAVE B
	MOVE A,TIME	;COMPUTE CURRENT SECTOR NUM, LEAVE IN A.
	IDIV A,RKTIM	;A HAS # SECTORS TOTAL.
	IDIVI A,12.	;B HAS SECTOR NOW AT.
	MOVE A,B
POPBJ:	REST B
	RET

;JSP A, WITH C=TIME TO WAIT, B=DRIVE.
;USE THE CLOCK QUEUE BLOCK IN RKDTAB ENTRY.
RKDWAT:	MOVEM A,RKCPC
	MOVEI A,RKCQBL
	ADD C,TIME
	JRST CLQADD

;CLOCK QUEUE CALLS HERE WHEN TIME COMES.
RKDWA1:	SUBI B,RKDTAB	;SET UP DRIVE IDX.
	MOVE A,RKCFNC	;LEAVE FUNCTION CODE IN A.
	JRST @RKCPC	;RESTART AFTER JSP TO RKDWAT.

RKERHK:	TLNN B,54000	;ERROR REGISTER.
	POPJ P,		;WRITE
	MOVE A,RRKER1	;GET REAL ERROR REGISTER,
	MOVEM A,RRKER	;SUPPLY TO USER.
	RET

RKBAHK:	TRZ A,1	;RKBA - DON'T LET LOW BIT BE READ AS 1.
	HRRM A,RRKBA
	RET

RKDSHK:	TLNN B,54000	;RKDS - READ ONLY REGISTER.
	 RET		;NOT READING, DO NOTHING.
	MOVE B,RKDRIV	;GET SELECTED DRIVE'S IDX,
	CALL RKSECT	;PUT CURRENT SECTOR  NUM. IN A,
	IOR A,RKCDSR	;MERGE WITH SELECTED DRIVE'S STATUS,
	HRRM A,RRKDS	;LEAVE THAT TO BE READ.
	RET

;WRITE-LOCK FUNCTION.
RKGOWL:	MOVEI A,RKBWPS
	IORM A,RKCDSR	;SET DRIVE'S WRITE-LOCKED BIT.
	JRST RKINTR

;DRIVE RESET FUNCTION.
RKGODR:	MOVEI A,(B)
	CALL QDEL	;STOP THE DRIVE FROM ACTING.
	MOVE B,RKDRIV
	SETOM RKCFNC	;DRIVE WANTS SEARCH-COMPLETE INT.
	SETOM RKSERC
	MOVEI A,RKBWPS
	ANDCAM A,RKCDSR	;DRIVE NOT WRITE-LOCKED,
	MOVEI A,RKBARDY
	IORM A,RKCDSR	;HEADS NOT MOVING.
	JRST RKINTR	;GIVE THE 1ST INT - SUCCESSFULLY INITTED.

;ATTACH RK-11 DRIVE.
ARK:	SKIPN WRK
	 CALL ARK0	;CREATE REGS, BUFFERS, ETC. IF NONEXISTENT.
	TLNN SF,NUMFND
	 RET		;NO DRIVE NUM. GIVEN => THAT'S ALL.
	CALL ARKGDN	;GET DRIVE IDX IN B.
ADF1:	MOVE C,RKCDSR
	TRNE C,RKBDRY
	 CALL RKSWP	;ALREADY ATTACHED => WRITE OUT PAGES AND DIR.
	.SUSET [.RSNAM,,OSNAM] ;ARRANGE TO RESTORE SNAME ON ERROR.
	MOVE A,RKCSNM
	.SUSET [.SSNAM,,A]
	MOVEI A,RKCFIL
	CALL DGFIL	;READ NEW FILE NAMES TO USE.
	CALL OSNAMR	;RESTORE SNAME UNLESS SPEC'D, GET NEW IN A.
	MOVE A,NSNAM	;GET DEFAULT OR SPEC'D SNAME.
	MOVEM A,RKCSNM	;SAVE SNAME OF FILE FOR DRIVE.
	HRRZ A,RKCFIL
	HRLZM A,RKCDEV	;SAVE LEFT-JUST DEV FOR .CALL OPEN.
	MOVE C,RKCDSR
	TRO C,RKBARDY	;HEADS NOT MOVING.
	TRON C,RKBDRY	;IF HADN'T BEEN ATTACHED,
	 AOS RKDCNT	 ;1 MORE DRIVE ATTACHED NOW.
	MOVEM C,RKCDSR
ARK1:	MOVEI C,6	;TRY TO OPEN FOR READING.
	.CALL RKOPNB
	 JRST ARKCR	;FAIL => NEW FILE.
	CALL RKDXFR	;READ IN THE DIRECTORY.
	MOVEM B,RKDOPN	;THIS DRIVE OPEN FOR READING.
	RET

ARKCR:	MOVSI C,-RKNCYL*2
	HRR C,RKCDIR
	MOVE A,C
	SETZM (C)	;NEW FILE, ZERO THE DIRECTORY,
	AOBJN C,.-1
	HRROS RKDOPN	;NO DRIVE OPEN.
	MOVEI C,7	;CREATE THE FILE.
	.CALL RKOPNB
	 OPENL RKOPNB
	SETCAM B,RKDOPN	;THIS DRIVE NOW OPEN FOR WRITING.
	MOVE C,A
REPEAT 1000/RKNCYL,[	;MAKE SURE WRITE OUT 1 WHOLE K.
	CALL RKIOT
	MOVE C,A]	;WRITE OUT ALMOST 1K, IN RKNCYL-SIZED CHUNKS,
	HRLI C,1000/RKNCYL*RKNCYL*2-2000
	JRST RKIOT	;WRITE OUT THE REMAINDER.

ARKGDN:	MOVEI B,(DL)	;COPY ARG SUPPLIED,
	CAIL B,RKNDRV	;ERROR UNLESS VALID # OF DRIVE.
	 ERROR [ASCIZ/DRIVE/]
	IMULI B,RKDTBL	;CONVERT TO DRIVE #.
	RET

;CREATE THE RK11 CONTROLLER.
ARK0:	CALL WRDINS	;CREATE THE REGISTERS.
IRPS X,,RKDS RKER RKCS RKBA
	TRN (N!X)R!X
TERMIN
	RRKWC ? RRKDA ? 0
	CALL ARKBUF	;ALLOCATE CHANNEL AND BUFFERS IF NEC.
	SETOM WRK
ZRK:	MOVSI B,-RKNDRV	;SWAP OUT EVERYTHING.
ZRK0:	CALL RKSWP	;SWAP OUT ONE DRIVE.
	ADDI B,RKDTBL-1
	AOBJN B,ZRK0
RKGOCR:	SETZM RRKDA
	SETOM RKRDY
	SETZM RRKER1	;CLEAR ERROR BITS.
ARK3:	BLKFLS RKINTB
	.BYTE 18.
REPEAT RKNDRV,RKDTAB+.RPCNT*RKDTBL
	RKINSB ? 0
	.BYTE
	RET

ARKBUF:	SKIPL RKCHAN
	 RET		;CHNL AND BUFS ALREADY EXIST.
	MOVEI A,['NUL]	;ALLOCATE A CHANNEL,
	CALL GETCHP	;USE NUL: SO OPEN CAN'T FAIL.
	HRRZM C,RKCHAN
	MOVSI T,-3*RKNBUF
ARK2:	CALL BLKGET	;GET CORE FOR BUFFERS.
	 RKBUF(T)
	ADDI T,1777
	AOBJN T,ARK2
	RET

;OPEN DRIVE <- B FOR OUTPUT UNLESS ALREADY OPEN.
RKOUTO:	SETCM C,B
	CAMN C,RKDOPN
	 RET		;ALREADY OPEN.
RKOUTP:	SETCAM B,RKDOPN	;WILL BE OPEN NOW.
	MOVEI C,100007
	.CALL RKOPNB
	 .LOSE %LSFIL
	RET

RKINO:	CAMN B,RKDOPN
	 RET		;ALREADY OPEN.
	MOVEM B,RKDOPN
	MOVEI C,6
	.CALL RKOPNB
	 .LOSE %LSFIL
	RET

;DETACH THE RK OR 1 DRIVE.
DRK:	SKIPN WRK
	 RET		;NOT ATTACHED.
	TLNE SF, NUMFND
	 JRST DRK1	;DETACH 1 DRIVE.
	SETZ B,		;DETACH ALL DRIVES.
DRK0:	CALL DRK2	;DETACH THE NEXT DRIVE,
	ADDI B,RKDTBL
	CAIGE B,RKDTBL*RKNDRV
	 JRST DRK0	;DO THAT TO EACH DRIVE.
	CALL ZRK	;GET RID OF QUEUE BLOCKS.
	CALL WRDZAP	;GET RID OF DEVICE REGS.
	RRKDS,,RRKBA
	SETZM WRK
	SKIPE WDF	;IF NEITHER DF NOR RK ATTACHED,
	 RET
DRK4:	MOVSI T,-3*RKNBUF
DRK3:	CALL BLKZAP	;FREE BUFFER PAGES.
	 RKBUF(T)
	ADDI T,1777
	AOBJN T,DRK3
	MOVE C,RKCHAN
	SETOM RKCHAN
	JRST CLOSEC	;FREE THE CHANNEL.

DRK1:	CALL ARKGDN	;PUT IDX OF SPEC'D DRIVE IN B.
DRK2:	MOVE C,RKCDSR
	TRNN C,RKBDRY	;NOT ATTACHED => DONE.
	 RET
	CALL RKSWP	;WRITE OUT DIR AND BUFFERS.
	SYSCAL CLOSE,RKCHAN
	HRROS RKDOPN	;SAY NOTHING OPEN IN EITHER DIRECTION.
	MOVEI A,RKBDRY+RKBWPS
	ANDCAM A,RKCDSR
	SOS RKDCNT	;1 LESS DRIVE IN USE.
	RET

RKSWP:	MOVE C,RKCDSR
	TRNN C,RKBDRY
	 RET		;DO NOTHING IF THIS DRIVE NOT ATTACHED.
	CALL RKOUTO	;OPEN THIS DRIVE FOR OUTPUT.
	MOVSI T,-RKNBUF	;LOOK AT ALL BUFFERS.
RKSWP0:	HLRZ A,RKBFT1(T) ;WHICH DRIVE THIS BUFFER?
	CAIE A,(B)
	 JRST RKSWP1	;SOME OTHER DRIVE.
	HRRZ A,RKBFT1(T)
	HRRZS C,(A)	;THIS DRIVE, SAY CYL NOT IN CORE,
	CALL RKXFER	;WRITE IT OUT.
	SETOM RKBFT1(T)	;BUFFER FREE.
	SETZM RKBFT0(T)
	SETOM RKBFT2(T)
RKSWP1:	AOBJN T,RKSWP0
RKDXFR:	SETZ C,		;TRANSFER THE DIRECTORY.
	CALL RKACC1
	HRRZ C,RKCDIR
	HRLI C,-2*RKNCYL
	JRST RKIOT

;RF-11 DISK (DEVICE DF) PARAMETERS:

;BITS AND FIELDS IN DCS REGISTER:
;(1ST 7 KEPT IN DFERR1, REST IN RDCS)
DFBERR==100000	;ERROR (IOR OF NEXT 6 BITS)
DFBFRZ==40000	;FREEZE (IOR OF HIGH BITS OF RDAE1)
DFBWCE==20000	;WRITE-CHECK ERROR (DIDN'T MATCH)
DFBDPE==10000	;DISK PARITY ERROR.
DFBNED==4000	;NON-EX DISK (BAD DISK ADDR)
DFBWLO==2000	;WRITE-LOCKED AREA OF DISK WRITTEN IN.
DFBMXF==1000
DFBCLR==400	;CLEAR. SETTING THIS RESETS CONTROLLER.
DFBRDY==200	;READY (READ AS 1 IF DFRDY NONZERO)
DFBENB==100	;INT ENABLE.
DFPXM==040200	;BP TO CMA EXTENSION BITS
DFBMA==10	;MAINTENANCE BIT (DOES NOTHING)
DFPFNC==010200	;BP TO FUNCTION FIELD.
DFBGO==1	;SETTING THIS CAUSES FUNCTION TO BE PERFORMED.

DFBERS=177000	;BITS WHICH CORRESPOND TO ERRORS.

;BITS IN DAE REGISTER: (KEPT IN RDAE, OR RDAE1 IF READ-ONLY)
DFBNEM==2000	;NON EX MEM REFERENCED BY DISK CTLR. (IN RDAE1)
DFBINH==400	;INHIBIT CMA INCR.
DFBDRL==200
DFBDAO==40	;DISK ADDR OVFLO (IN RDAE1)
DFPDAE==500	;BP TO ADDRESS EXTENSION BITS.

DFRDY:	-1	;READY
RDAE1:	0	;READ-ONLY BITS OF RDAE KEPT HERE.
DFDRIV:	0	;IDX (IN RKDTAB) OF SELECTED DF-11 DRIVE.
DFDELA:	0	;# WDS WORTH OF XFER TIME MUST WAIT BEFORE SET READY.
DFLOCP:	0	;BP INTO BUFFER FOR TRANSFER.
DFSCWC:	0	;# WDS LEFT IN BUFFER (OR IN DISK)
DFERR1:	0	;READ-ONLY BITS OF DCS KEPT HERE.
DFOWC:	0	;WHAT RWC HELD AT START OF TRANSFER.
WDF:	0
DFTIM:	165.	;BASIC DSK TIME QUANTUM.

;THE RF11/RS11 DSK
ADF:	SKIPN WDF
	PUSHJ P,ADF2
	CALL ADFGDN	;GET IDX OF DF AS DRIVE OF RK11
	JRST ADF1

ADF2:	PUSHJ P,WRDINS
	IRPS X,,[DCS,CMA,DAE,ADS]
	600000+N!X,,R!X
	TERMIN
	0,,RWC
	0,,RDAR
	0
	CALL ARKBUF	;ALLOCATE DF AND RK CHANNEL AND BUFFERS IF NEC.
	SETOM WDF
	JRST ZDF

ADFGDN:	MOVEI B,RKNDRV(T5)
	CAIL B,RKNDRV+DFNDRV
	 ERROR [ASCIZ/DRIVE/]
	IMULI B,RKDTBL
	RET

DDF:	SKIPN WDF	;DETACH DISK
	 RET
	TLNN SF,NUMFND	;NUMERIC ARG =>
	 JRST DDF1
	CALL ADFGDN	;DETACH SPEC'D DRIVE ONLY.
	JRST DRK2

DDF1:	MOVEI B,DFDRVI	;NO NUMERIC ARG => DETACH EVERY DRIVE
DDF2:	CALL DRK2
	ADDI B,RKDTBL
	CAIE B,RKDTBL*<RKNDRV+DFNDRV>
	 JRST DDF2
	PUSHJ P,ZDF	;THEN FLUSH DEVICE REGS & QUEUE BLOCKS.
	SETZM WDF
	PUSHJ P,WRDZAP
	RDCS,,RADS
	SKIPE WRK	;IF NEITHER DF NOR RK ATTACHED,
	 RET
	JRST DRK4	;FREE CHANNEL AND BUFFERS.

ZDF:	SKIPN WDF
	POPJ P,
	SETOM DFRDY
	SETZM RDAE1
	SETZM DFERR1
	HLLZS RDAE
	HLLZS RWC
	HLLZS RDAR
	HLLZS RCMA
	HLLZS RDCS
	BLKFLS RKDTAB+DFDRVI
	0
DKINTF:	MOVEI A,DSKINT
	JRST QDEL

DCSHAK:	TLNN B,54000
	JRST DCSWRT
	PUSHJ P,DCSCMP	;READ CYCLE
	HRRM A,RDCS
	TLNN B,22000
	POPJ P,
DCSWRT:	 XXWAIT
	MOVE T,RDCS
	TRNE T,400
	JRST ZDF	;POWER CLEAR BIT ON, DO NOTHING ELSE
	TRNN T,1	;GO
	JRST DSKINQ
	HRRZ A,RDCS
	TRNE A,DFBFRZ
	JRST DCSTR2
	TRZ A,DFBERS
	MOVEI D,DFBDAO
	ANDCAM D,RDAE1
	HRRM A,RDCS
DCSTR2:	TRNN A,6
	RETURN		;NO OP
	SETZM DFRDY	;ABOUT TO START FUNCTION: NOT READY
;COME BACK HERE ON TRANSFERING PAST BOUNDARY OF 3K BLOCK OR
;BOUNDARY OF A DISK DRIVE.
DFRSTR:	LDB A,[DFPDAE,,RDAE]
	HRRZ D,RDAR	;A HAS HIGH BITS OF DISK ADDR, D LOW BITS.
	DPB A,[200200,,D]
	LSH A,-2	;D HAS ADDR IN DRIVE, A HAS DRIVE #.
	MOVEI C,DFBNED
	CAIL A,DFNDRV	;DOES THAT DRIVE EXIST?
	 JRST DFERR
	IMULI A,RKDTBL
	ADDI A,DFDRVI	;GET RKDTAB IDX OF THAT DRIVE.
	MOVEM A,DFDRIV
	MOVEI B,(A)
	MOVEM D,RKCADR	;REMEMBER ADDR WITHIN DRIVE.
	MOVE D,TIME	;COMPUTE ROTATIONAL LATENCY AS # WDS
	IDIV D,DFTIM	;DISK MUST ROTATE THROUGH.
	LDB D,[1200,,RDAR] ;E HAS CURRENT WD, D HAS DESIRED.
	SUB D,E
	SKIPGE D	;MUST BE GE SO SPIRAL XFER WON'T WAIT TOO LONG.
	 ADDI D,2000
	MOVEM D,DFDELA	.SEE DFDONE
	LDB A,[DFPFNC,,RDCS]
	MOVEM A,RKCFNC	;REMEMBER FUNCTION TO PERFORM.
	MOVE C,DFFTAB(A) ;ADDR TO LOOP THRU FOR THAT FUNC. (DFREAD, ETC)
	MOVE T,RDAE
	TRNE T,DFBINH	;LH(C) HAS AOJA MA, UNLESS
	 HRLI C,(JRST)	;MA INC INH SET, IN WHICH CASE JRST.
	MOVEM C,DFLOOP
	MOVE D,RKCADR
	IDIVI D,6000*2	;GET # OF 3K BLOCK XFER STARTS IN.
	CALL RKSETU	;SWAP THAT BLOCK IN.
	 JRST [MOVEI D,DFWRTN	;WRITING IN UNALLOCATED BLOCK,
		HRRM D,DFLOOP	;SEE IF WRITING ANY NONZERO
		JRST .+1]	;BEFORE TRYING TO ALLOCATE.
	MOVEM C,DFLOCP	;C HAS BP TO BUFFER SWAPPED INTO.
	MOVE D,RWC	;REMEMBER RWC AT START OF XFER. USED TO FIND
	MOVEM D,DFOWC	.SEE DFNXM1	;HOW MANY WDS WERE XFERED.
	SETZ D,
	ROTC D,-1
	ADDM E,DFLOCP	;MAKE POINT WITHIN BUFFER TO PLACE XFER STARTS.
	MOVEI E,22	;IF STARTING ON ODD NUMBERED WORD,
	SKIPGE D
	 DPB E,[360600,,DFLOCP] ;IT IS IN THE RH OF A BUFFER WORD.
	MOVE D,RKCADR
	IDIVI D,6000*2
	SUBI E,6000*2	;-<# WDS LEFT IN 3K BLOCK AFTER WHERE STARTING>
	MOVE D,RKCADR
	SUB D,[1,,]	;-<# WDS LEFT THIS DRIVE>
	CAMG D,E	;GET WHICHEVER IS SMALLER (THAT IS,
	 MOVE D,E	;-<# WDS TO XFER BEFORE GO TO DFRSTR>)
	MOVNM D,DFSCWC
	LDB MA,[011700,,RCMA] ;GET LOW 17 BITS OF WORD ADDRESS,
	LDB D,[DFPXM,,RDCS] ;MERGE IN TOP 2 BITS OF ADDRESS.
	DPB D,[170200,,MA]
	JRST @DFLOOP

DFWRTN:	SKIPGE MB,PDP11(MA)	;LOOP RTN FOR WRITING IN UNALLOCATED BLOCK.
	 JSP D,MTRDFR
	JUMPE MB,[IBP DFLOCP ? JRST DFINCR]
	MOVE B,DFDRIV
	MOVE D,RKCADR	;TRYING TO WRITE SOMEHING NONZERO -
	IDIVI D,6000*2	;MUST ALLOCATE SPACE FOR BLOCK.
	CALL RKNEW5	;DO SO, RET. ADDR OF BFR IN RH(C)
	 JFCL
	ANDI C,-1
	ADDM C,DFLOCP	;(PTS TO CORRECT WD DUE TO IBP 6 LINES AGO)
	MOVEI C,DFWRIT
	HRRM C,DFLOOP	;CHANGE TO ORDINARY WRITE.
DFWRIT:	SKIPGE MB,PDP11(MA) ;LOOP ROUTINE FOR WRITING.
	 JSP D,MTRDFR
	IDPB MB,DFLOCP
	JRST DFINCR

DFREAD:	SKIPGE PDP11(MA)
	 JSP D,MTRDFW
	ILDB MB,DFLOCP
	HRRM MB,PDP11(MA)
	JRST DFINCR

DFWCHK:	SKIPGE MB,PDP11(MA)
	 JSP D,MTRDFR
	ILDB TT,DFLOCP
	CAIN TT,(MB)
	 JRST DFINCR
	MOVEI C,DFBWCE
	IORM C,DFERR1
	AOS T,RWC
	JRST DFINC1

;COMMON END FOR ALL FUNCTION LOOPS.
;INCREMENT VARIOUS VARIABLES AND MAYBE BRANCH BACK.
DFINCR:	AOS T,RWC
	TRNN T,177777
	 JRST DFINC1	;TRANSFER DONE.
	SOSLE DFSCWC	;MORE WDS LEFT IN CURRENT BUFFER?
DFLOOP:	0		;AOJA MA, OR JRST TO DFWRIT, DFREAD, DFWRTN, OR DFWCHK
DFINC1:	HLRZ D,DFLOOP	;CAN'T JUST KEEP ON GOING.
	CAIN D,(AOJA MA,)
	 AOJ MA,
DFNXM1:	DPB MA,[011700,,RCMA]	;STORE UPDATED VALUES IN ACTUAL REGISTERS.
	LSH MA,-17
	DPB MA,[DFPXM,,RDCS]
	ANDI T,177777
	HRRM T,RWC
	MOVE B,DFDRIV	;MRTDFR CLOBBERS B.
	SUB T,DFOWC	;GET # WDS TRANSFERED SO FAR.
	ANDI T,177777
	ADDM T,DFDELA	;MUST WAIT THAT MUCH LONGER BEFORE OFFICIALLY DONE.
	ADD T,RKCADR	;INCREM. DISK ADDR BY THAT MUCH.
	LDB A,[20300,,RDAE]
	LSH A,22
	ADD T,A		;ADD IN THE DRIVE NUMBER IN CASE CARRY.
	DPB T,[2000,,RDAR]
	LSH T,-20
	DPB T,[DFPDAE,,RDAE]
	MOVE C,DFDELA	;WAIT THE AMOUNT OF TIME XFER
	IMUL C,DFTIM
	JSP A,RKDWAT	;SUPPOSEDLY TOOK.
	HRRZ T,RWC
	JUMPE T,DFINTR	;TRANSFER DONE, DECIDE WHETHER TO INTERRUPT.
	SKIPE DFERR1
	 JRST DFINTR	;STOP IF ERROR.
	MOVE A,RKCFNC	;ELSE START OVER, SWAPPING IN ANOTHER BUFFER.
	JRST DFRSTR

DFFTAB:	.VALUE		;NO FUNCTION LOOP FOR NOOP.
	AOJA MA,DFWRIT
	AOJA MA,DFREAD
	AOJA MA,DFWCHK

DFNXM0:	MOVEI C,DFBNEM	;COME HERE FOR NXM ON MEM REF BY DF
	IORM C,RDAE1
	MOVEI C,DFBFRZ	;SET AN ERROR BIT SO XFER WILL STOP.
	IORM C,DFERR1
	SUB P,[1,,1]	;FLUSH THE RET ADDR IN MTRAP.
	JRST DFNXM1	;GO UPDATE DEVICE REGS AND STOP.

DCSCMP:	MOVE A,RDCS	;DCS COMPUTE
	ANDI A,166
	SKIPE DFRDY
	TRO A,DFBRDY
	IOR A,DFERR1	;INCLUDE READ-ONLY BITS.
	TRNE A,DFBERS
	TRO A,DFBERR
	RETURN

DFERR:	IORM C,DFERR1
DFINTR:	SETOM DFRDY
DSKINQ:	MOVE T,RDCS
	MOVEI A,DSKINT
	TRNN T,100
	JRST QDEL
	SKIPE DFRDY
	JRST MTRNEW
	PUSHJ P,DCSCMP
	TRNN A,100000
	JRST DKINTF
	JSP A,MTRNEW
DSKINT:	5	;TRAP PRIORITY 5 TO LOCATION 204
	-1
	JRST .+1
	MOVEI T,41
	JSP A,VTRAP

DAEHAK:	TLNN B,54000	;DAE
	 RET
	ANDI A,637
	IOR A,RDAE1
	HRRM A,RDAE
	RETURN

CMAHAK:	TRZ A,1
	HRRM A,RCMA
	POPJ P,

ADSHAK:	MOVE A,TIME	;COMPUTE "POSITION" OF DISK
	IDIV A,DFTIM
	ANDI A,3777
	HRRM A,RADS
	POPJ P,
]

;THE KW11-P PROGRAMMABLE CLOCK
APK:	JUMPE T5,ZPK2
	MOVE A,[10000000.]	;ARG=CYCLES/SEC
	IDIV A,T5
	MOVEM A,PKTIM
ZPK2:	SKIPE WPK
	PUSHJ P,DPK
	CALL APKBLK	;CREATE THE PAGE THE PK'S REGS GO IN, IF NEC.
	PUSHJ P,WRDINS
	600000+NPKCSR,,RPKCSR	;CONTROL & STATUS REGISTER
	600000+NPKCSB,,RPKCSB	;COUNTER SET BUFFER
	600000+NPKC,,RPKC	;COUNTER
	0
	SETOM WPK
	SETOM PKERR
	SETZM PKCBUF
	SETZM PKCNT
	MOVEM TIME,ORGTIM
	RETURN

DPK:	BLKFLS PKINTB	;DETACH PROGRAMMABLE CLOCK
	PKCLKB,,0
	SETZM WPK
DPKBLK:	SOSL WPKBLK	;ONE LESS DEVICE USING PK'S PAGE.
	 RET
	PUSHJ P,BLKZAP	;NO LONGER IN USE, FREE IT.
	RPKCSR
	RETURN

ZPK:	SKIPE WPK
	JRST ZPK2
	RETURN

PKCHAK:	TLNN B,54000
	RETURN
UPDATE:	MOVE C,RPKCSR
	TRNN C,1
	JRST UPDAT2	;RUN OFF
	SKIPL PKERR
	TRNE C,10	;MODE BIT
	JRST .+2
	JRST UPDAT2	;STOPPED BY OVERFLOW
	LSH C,-1
	ANDI C,3
	MOVE A,TIME
	SUB A,ORGTIM
	XCT TIMTAB(C)
UPDAT4:	ADDB A,PKCNT
	HRRM A,RPKC
	SUBM TIME,B
	MOVEM B,ORGTIM
	RETURN

PKCNT:	0
PKERR:	-1	;O="DONE"	;+="DONE" & ERR
PKCBUF:	0
ORGTIM:	0
WPK:	0
WPKBLK:	-1	;-1+<USAGE COUNT OF PK'S PAGE>
PKTIM:	166667.

APKBLK:	AOSE WPKBLK	;PAGE IN USE ONCE MORE.
	 RET
	CALL BLKGET	;CREATE IT IF IT DOESN'T EXIST.
	600000,,RPKCSR
	RET

TIMTAB:	IDIVI A,100.
	IDIVI A,1000.
	IDIV A,PKTIM
UPDAT2:	SETZB A,B
	JRST UPDAT4

PKCSRK:	TLNN B,54000
	JRST PKCSRW
	ANDI A,177
	SKIPL PKERR
	TRO A,200
	SKIPLE PKERR
	TRO A,10000
	HRRM A,RPKCSR
	TLNN B,22000
	RETURN
PKCSRW:	PUSHJ P,UPDATE
	 XXWAIT
	MOVE A,RPKCSR
	TRNN A,200
	SETOM PKERR
	TRNN A,40	;FIX
	JRST PKCSR2
	TRNN A,20	;UP/DN
	JRST PKCSR4
	AOS C,PKCNT
	ANDI C,177777
	MOVEM C,PKCNT
PKCSR2:	PUSHJ P,PKINTQ
	JRST PKSTUP

PKCSR4:	SOSL C,PKCNT
	JRST PKCSR2
	TRNN A,10
	SETZM PKCBUF
	MOVE C,PKCBUF
	MOVEM C,PKCNT
	AOS PKERR
	JRST PKCSR2

PKINTQ:	MOVEI A,PKINTB
	SKIPGE PKERR
	JRST QDEL
	LDB B,[60100,,RPKCSR]
	JUMPE B,QDEL
	JRST MTRNEW

PKINTB:	6
	-1
	JRST .+1
	SETOM PKERR
	MOVEI T,21
	JSP A,VTRAP

PKCSBK:	HLLZS RPKCSB
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ A,RPKCSB
	HRRM A,PKCNT
	HRRM A,PKCBUF
PKSTUP:	PUSHJ P,PKCLKF
	HRRZ B,RPKCSR
	TRNE B,1
	TRNE B,20	;UP/DN
	RETURN
	HRRZ C,PKCNT
	LSH B,-1
	ANDI B,3
	XCT TABTIM(B)
	ADD C,TIME
	MOVEI A,PKCLKB
	JRST CTRDES

TABTIM:	IMULI C,100.
	IMULI C,1000.
	IMUL C,PKTIM
	RETURN

PKCLKF:	JSP A,QDEL
PKCLKB:	0
	-1
	PUSHJ P,.+1
	AOS PKERR
	PUSHJ P,PKINTQ
	MOVE A,RPKCSR
	HRRZ B,PKCBUF
	TRNN A,10
	MOVEI B,0
	HRRM B,PKCBUF
	HRRM B,PKCNT
	TRNN A,10
	RETURN
	JRST PKSTUP

;DC ASYNCHRONOUS LINE INTERFACE

TXN[
ADC:	PUSHJ P,ADCR	;ATTACH SAME FILE DC TRANSMIT & RECEIVE
	TLO SF,D1CHAR
ADCT:	SKIPE WDCT	;ATTACH DC TRANSMIT
	PUSHJ P,DDCT
	MOVEI A,DCFIL
	PUSHJ P,DGFIL
	MOVEI T6,1
	HRLM T6,DCFIL
	PUSHJ P,GETCHO
	DPB C,[270400,,DCTCX1]
	HRRM C,DCTCX2
	DPB C,[270400,,DCTCX3]
	SETOM WDCT
	SETOM DCREDY
	SKIPE WDCR
	RETURN
DCINS:	PUSHJ P,WRDINS
	600000+NTSCR,,RTSCR	;TRANSMITTER STATUS REGISTER
	600000+NTBUF,,RTBUF	;TRANMSITTER BUFFER
	600000+NRCSR,,RRCSR	;R STATUS
	600000+NRBUF,,RRBUF	;R BUFFER
	0
	RETURN

DDC:	PUSHJ P,DDCR
DDCT:	SKIPN WDCT
	RETURN
DCTCX2:	MOVEI C,.
	PUSHJ P,CLOSEC	;DETACH DC TRANSMIT
	SETZM DCREDY
	SETZM WDCT
	BLKFLS TSCRB2
	TBUFB1,,0
	SKIPE WDCR
	RETURN
DCZAP:	PUSHJ P,WRDZAP
	RRCSR,,RTBUF
	RETURN

ADCR:	SKIPE WDCR	;ATTACH DC RECEIVE
	PUSHJ P,DDCR
	MOVEI A,DCFIL
	PUSHJ P,DGFIL
	HRRZS DCFIL
	PUSHJ P,GETCHO
	MOVEI B,RBUFBI
	MOVEM B,DYCBPT-DYCH(C)
	HRRZM C,DCRCH.
	DPB C,[270400,,DCRCX2]
	DPB C,[270400,,DCRCX4]	;PUT CHNL NUM IN .OPER'S.
	SKIPE DYCTYP-DYCH(C)
	JRST ADCR2
ADCRTT:	.CALL ADMRTS		;IF TTY, INT. ON ALL CHARS.
	 .LOSE %LSFIL
ADCR2:	SKIPGE DYCTYP-DYCH(C)	;IF NOT INT. DEV.,
	 CALL RBUFB2		;ALREADY GOT 1 CHAR.
	SETOM DCCRTR
	SETOM WDCR
	SKIPN WDCT
	JRST DCINS
	RETURN

DDCR:	SKIPN WDCR
	RETURN
	MOVE C,DCRCH.	;DETACH DC RECEIVE
	PUSHJ P,CLOSEC
	SETZM DCDONE
	SETZM WDCR
	SETOM DCCRTR
	BLKFLS RCSRB2
	RBUFB1,,0
	SKIPN WDCT
	JRST DCZAP
	RETURN

DCFIL:	BLOCK 3

WDCR:	0
WDCT:	0
DCDONE:	0
DCREDY:	0
DCCRTR:	0	;CARRIER TRANSITION
DCRCH.:	0
DCRTIM:	0	;TIMING, OR 0 => READ CHARS WHEN RQ'D.
DCTTIM:	500.

RBUFBI:	0	;INT. ON CHAR RECEIVED QUEUES THIS BLOCK.
	-1
	CALL RBUFB3

RCSRHK:	TLNN B,54000
	JRST RCSRWR
	ANDI A,3533
	SKIPE DCDONE
	TRO A,200
	SKIPE WDCR
	TRO A,4
	SKIPE DCCRTR
	TRO A,140000
	SETZM DCCRTR
	HRRM A,RRCSR
	TLNN B,22000
	RETURN
RCSRWR:	 XXWAIT
	HRRZ A,RRCSR
	TRNE A,2
DCTCX1:	.IOT .,[0]	;"BREAK"
	 IOCGET [CALL DDCT]
	POPJ P,

RCSRI:	MOVEI A,RCSRB2
	SKIPN DCDONE
	JRST QDEL
	LDB B,[60100,,RRCSR]
	JUMPE B,QDEL
	JRST MTRNEW

RCSRB2:	5
	-1
	JRST .+1
	MOVEI T,60
	JSP A,VTRAP

TSCRHK:	TLNN B,54000
	POPJ P,
	ANDI A,531
	SKIPE DCREDY
	TRO A,200
	SKIPE WDCT
	TRO A,2
	HRRM A,RTSCR
	RETURN

TSCRI:	MOVEI A,TSCRB2
	SKIPN DCREDY
	JRST QDEL
	LDB B,[60100,,RTSCR]
	JUMPE B,QDEL
	JRST MTRNEW

TSCRB2:	5
	-1
	JRST .+1
	MOVEI T,61
	JSP A,VTRAP

TBUFHK:	HLLZS RTBUF
	SKIPE DCREDY
	TLNN B,22000
	RETURN
	 XXWAIT
	SETZM DCREDY
DCTCX3:	.IOT .,RTBUF
	 IOCGET [CALL DDCT]
	PUSHJ P,TSCRI
	MOVE C,TIME
	ADD C,DCTTIM
	JSP A,CTRDES
TBUFB1:	0
	-1
	PUSHJ P,.+1
	SETOM DCREDY
	JRST TSCRI

RBUFHK:	TLNE B,54000
	SKIPN DCDONE
	RETURN
	SETZM DCDONE
	SKIPGE RBUFB1+1	;IF NOT GOING TO READ ANOTYER CHAR,
	SKIPE DCRTIM	;AND TIMING IS 0,
	CAIA
	 CALL RBUFB2	;READ ANOTHER SINCE WE'RE THRU WITH LAST ONE.
	JRST RCSRI	;MAYBE STOP VTRAP RQ.

RBUFB2:	MOVE C,TIME	;EVERY 100 VUSEC LOOK FOR NEXT CHAR.
	ADD C,DCRTIM
	JSP A,CTRDES
RBUFB1:	0
	-1
	PUSHJ P,.+1
RBUFB3:	SKIPN DCRTIM	;IN READ-WHEN-REQUESTED MODE,
	SKIPN DCDONE
	CAIA
	 RET		;DON'T READ ANOTHER TILL USE PREVIOUS.
	MOVE C,DCRCH.	;DCR CHNLNUM.
	SKIPE DYCTYP-DYCH(C)
	JRST DCRCX2
DCRCX4:	.STATUS .,A	;IF A TTY, SEE IF ANYTHING IN BUFFER.
	TRNE A,2000
	JRST RCSRI	;NOTHING, STOP CLOCK-TRAPPING.
DCRCX2:	.IOT .,A
	 IOCGET [CALL DDCR]
	JUMPL A,CPOPJ	;IF STY HAS NO CHARS
	HRRM A,RRBUF
	SETOM DCDONE
	CALL RCSRI	;MAYBE REQUEST INTERRUPT.
	JRST RBUFB2

;DYNAMICLY ALLOCATED I-O CHANNEL ROUTINES

;CALL WITH C(A) POINTING TO FILE BLOCK
;IF SUCCESSFUL RETURNS WITH CHANNEL NUMBER AS C(C)
GETCHO:	MOVSI C,10
	ANDCAM C,(A)	;WANT 10 BIT FOR STY'S ONLY.
GETCHP:	HRRZ C,(A)
	CAIN C,(SIXBIT /TTY/)
	 JRST GCHTTY
	CAIN C,(SIXBIT /LPT/)
	 JRST GCHLPT
	MOVE C,[-DYCHN,,DYCH]
	SKIPL DYCTAB(C)
	 AOBJN C,.-1
	JUMPGE C,[ERROR [ASCIZ /
NO I-O CHANNELS LEFT/]]
	HRRZS C
	DPB C,[270400,,GETCH1]
	DPB C,[270400,,GETCH1+1]
GETCH1:	TSOPEN .,(A)		;BOTH INSNS ARE IMPURE.
	AOS DYCTAB(C)		;INDICATE CHANNEL IN USE.
	PUSH P,A
	DPB C,[270400,,.+1]
	.STATUS .,A
	ANDI A,77
	CAIE A,1
	CAIN A,2
	SETZM DYCTYP-DYCH(C)	;A TTY - SAY SO.
	HRLI A,1
	CAME A,[1,,25]
	JRST POPAJ
	HLRZM A,DYCTYP-DYCH(C)	;A STY - SAY SO,
	REST A
	SAVE C
	MOVSI C,10
	IORM C,(A)
	REST C
	XCT GETCH1	;REOPEN WITH BIT 10 SET.
	XCT GETCH1+1
	RETURN

DYCTAB==.-DYCH
	REPEAT DYCHN,-1
DYCBPT:	BLOCK DYCHN	;RECEIVE INT BLOCK POINTERS
DYCBIT:	REPEAT DYCHN,1_<DYCH+.RPCNT>
DYCTYP:	REPEAT DYCHN,-1	;-1 FOR FILE, 0 FOR TTY, +1 FOR PSEDO-TTY

GCHTTY:	HLRZ C,(A)
	TRNN C,1
	SKIPA C,[TYIC]
	 MOVEI C,TYOC
GCHLPU:	SETOM DYCTYP-DYCH(C)	;DON'T SCREW UP CONSOLE TTY
	RETURN

GCHLPT:	HLRZ C,(A)
	TLNN C,1
	ERROR [ASCIZ /INPUT FROM LPT/]
	PUSHJ P,OPNLPT
	MOVEI C,LPTC
	JRST GCHLPU

CLOSEC:	HRRZS C
	CAIN C,LPTC
	 JRST CLSLPT		;MAYBE CLOSE LPTC
	CAIL C,DYCH
	 CAIL C,DYCH+DYCHN
	  RETURN		;IGNORE TYIC, TYOC
	SYSCAL CLOSE,[C]
	SETOM DYCTAB(C)
	SETZM DYCBPT-DYCH(C)
	SETOM DYCTYP-DYCH(C)
	POPJ P,

;DM ASYNCHRONOUS 16-LINE SINGLE SPEED INTERFACE

ADM:		;ATTACH
	PUSHJ P,ADMT
	TLO SF,D1CHAR
ADMR:	TDZA B,B	;ATTACH RECEIVE ONLY
ADMT:	MOVEI B,1	;ATTACH TRANSMIT ONLY
	TLNN SF,NUMFND
	JRST DMSTAT
	CAIL DL,16.
DMTSLN:	ERROR [ASCIZ/NON-EX. LINE/]
	MOVEI A,DMFIL
	PUSHJ P,DGFIL
	HRRZ C,DMFIL
	HRLM B,DMFIL
	PUSHJ P,GETCHO
	PUSH P,C
	JUMPE B,ADM2
	SKIPN C,DMTTAB(DL)
	AOSA A,DMOCNT
	PUSHJ P,CLOSEC
	POP P,DMTTAB(DL)
	JRST ADM3

ADM2:	SKIPGE DYCTYP-DYCH(C)
	JRST ADMR2
	HRROS (P)
	.CALL ADMRTS
	 .LOSE %LSFIL
	MOVE A,DL
	IMULI A,DMRLNG
	ADDI A,DMRBLK
	HRRM A,DYCBPT-DYCH(C)
ADMR2:	SKIPN C,DMRTAB(DL)
	AOSA A,DMOCNT
	PUSHJ P,CLOSEC
	POP P,DMRTAB(DL)
	SKIPGE DMRTAB(DL)
	JRST ADM3	;JUMP IF TTY OR STY
	MOVE T5,DL
	IMULI T5,DMRLNG
	MOVEI A,DMRBLK(T5)
	LDB B,[100,,RCSR]
	SKIPE B
	PUSHJ P,CTR100
ADM3:	EXCH A,DMCNT
	JUMPN A,CPOPJ
ADM4:	PUSHJ P,WRDINS	;FIRST ATTACH
	600000+NCSR,,RCSR
	600000+NBAR,,RBAR
	600000+NBCR,,RBCR
	600000+NTBR,,RTBR
	0
	SETZM DMNXM
	SETZM DCRFLG
	SETZM DCRTTP
	SETZM DMRFLG
	RETURN

ADMRTS:	SETZ
	SIXBIT /TTYSET/
	C
	[131313,,131313]
	[131313,,131313]
	SETZ [0]

ZDM:	PUSH P,RTBR
	PUSHJ P,ADM4
	POP P,RTBR
	BLKFLS DCRBLK
	REPEAT 16.,DMRBLK+DMRLNG*.RPCNT,,DMTBLK+DMTLNG*.RPCNT
	DCTBLK,,
	POPJ P,

DDM:		;DETACH
	PUSHJ P,DDMT
	TLO SF,D1CHAR
DDMR:	TDZA B,B	;DETACH RECEIVE ONLY
DDMT:	MOVEI B,1	;DETACH TRANSMIT ONLY
	TLNN SF,NUMFND
	JRST DMSTAT
	CAIL DL,16.
	JRST DMTSLN
	MOVE A,DL
	JUMPE B,DDM2
	SKIPN C,DMTTAB(DL)
	JRST DMTLNA
	SETZM DMTTAB(DL)
BCRDDM:	IMULI A,DMTLNG
	ADDI A,DMTBLK
	JRST DDM3

DDM2:	SKIPN C,DMRTAB(DL)
	JRST DMTLNA
	SETZM DMRTAB(DL)
DMRDDM:	IMULI A,DMRLNG
	ADDI A,DMRBLK
DDM3:	PUSHJ P,QDEL
	PUSHJ P,CLOSEC
	SOS A,DMOCNT
	MOVEM A,DMCNT
	JUMPN A,CPOPJ
	PUSHJ P,WRDZAP	;LAST DETACH
	RCSR,,RTBR
	RETURN

NXMDML:	SUB P,[1,,1]	;NON-EX MEMORY REFERENCE
	SETOM DMNXM
	JRST CSRINT

DMTLNA:	TTOA [ASCIZ /UNATTACHED LINE
/]
DMSTAT:	JUMPN B,DMSTA2	;IF DMT, PRINT TRANSMIT LINES.
	TTOA [ASCIZ /RECEIVE LINES ACTIVE: /]	;IF DMR,...
	MOVE E,[-16.,,]
	SKIPN DMRTAB(E)
DMSTA1:	AOBJN E,.-1
	JUMPGE E,CRPOPJ
	HRRZM E,QT
	TTOA [ASCIZ / T./]
	JRST DMSTA1

;PRINT TRANSMIT LINE STATUS.
DMSTA2:	TTOA [ASCIZ /TRANSMIT LINES ACTIVE:/]
	MOVE E,[-16.,,]
	SKIPN DMTTAB(E)
DMSTA3:	AOBJN E,.-1
	JUMPGE E,CRPOPJ
	HRRZM E,QT
	TTOA [ASCIZ / T./]
	JRST DMSTA3

DMTTAB:	BLOCK 16.	;TRANSMIT LINE CHNL NUM. OR 0 IF UNATTACHED.
DMRTAB:	BLOCK 16.	;RECEIVE LINE CHNL NUM., OR 0. (LH=-1 IF TTY)
DMOCNT:	0
DMCNT:	0		;COUNT OF ACTIVE LINES
DMFIL:	BLOCK 3
DMNXM:	0
DCRFLG:	0	;CHAR RECEIVED & NOT YET RECEIVE INTERRUPT
DCRTTP:	-1	;TUMBLE TABLE POINTER
DMRFLG:	0	;PREVIOUS RECEIVER ENABLE FLAG
DMTIM:	30000.

TBRHAK:	ANDI A,177400	;TABLE BASE REGISTER
	HRRM A,RTBR
	TLNN B,22000
	RETURN
	 XXWAIT
	HRRZ A,RTBR
	ANDI A,177400
	HRRM A,RTBR
	RETURN

BCRHAK:	TLNN B,22000	;BREAK CONTROL REGISTER
	RETURN
	 XXWAIT
	HRLZ A,RBCR
	MOVSI E,-16.
	LSH A,-1
	TRNN A,400000
BCRHK2:	AOBJN E,.-2
	JUMPGE E,CPOPJ
	SKIPN C,DMTTAB(E)
	JRST BCRHK2
	DPB C,[270400,,.+1]
	.IOT .,[0]	;"BREAK"
	 IOCGET [CALL BCRLOS]
	JRST BCRHK2

BCRLOS:	MOVE A,E
	JRST BCRDDM

CSRHAK:	TLNN B,54000	;CONTROL AND STATUS REGISTER
	JRST CSRWRT
	ANDI A,110363
	SKIPE DMNXM
	TRO A,40000
	HRRM A,RCSR
	TLNN B,22000
	RETURN
CSRWRT:	 XXWAIT
	LDB B,[100,,RCSR]
	EXCH B,DMRFLG
	XOR B,DMRFLG
	SKIPE B
	JRST CSRREN
CSRINT:	HRRZ B,RCSR
	PUSHJ P,DCRINT
DCTINT:	MOVEI A,DCTBLK
	TRNN B,10000
	JRST QDEL
	SKIPE DMNXM
	JRST MTRNEW
	TRNN B,100000
	JRST QDEL
	JRST MTRNEW

DCRINT:	MOVEI A,DCRBLK
	TRNE B,100
	SKIPN DCRFLG
	JRST QDEL
	JRST MTRNEW

DCRBLK:	5	;RECEIVE INTERRUPT
	-1
	JRST .+1
	SETZM DCRFLG
	HRRZ T,%DMRV
	LSH T,-2
	JSP A,VTRAP

DCTBLK:	5	;TRANSMIT INTERRUPT
	-1
	JRST .+1
	HRRZ T,%DMTV
	LSH T,-2
	JSP A,VTRAP

CSRREN:	SETOM DCRTTP
	MOVSI E,-16.	;CHANGE IN STATE OF RECEIVE ENABLE (CSR)
	SKIPA A,[DMRBLK]
CSRREM:	ADDI A,DMRLNG
	SKIPN C,DMRTAB(E)
	JRST CSRREL
	SKIPN DMRFLG
	PUSHJ P,QDEL
	SKIPL DYCTYP-DYCH(C)
	JRST CSRREL
	SKIPE DMRFLG
	PUSHJ P,CTR100
CSRREL:	AOBJN E,CSRREM
	JRST CSRINT

DMRBLK:	REPEAT 16.,[0
	-1
	PUSHJ P,.+1
	MOVEI I,.RPCNT
	JRST DMRBRK
]	DMRLNG==5

DMTBLK:	REPEAT 16.,[0
	-1
	PUSHJ P,.+1
	MOVEI I,.RPCNT
	JRST DMTBRK
]	DMTLNG==5

BARHAK:	TLNN B,22000	;BUFFER ACTIVE REGISTER
	RETURN
	 XXWAIT
	MOVSI E,-16.
	HRRZ B,RBAR
	MOVEI A,DMTBLK
BARHK2:	SKIPN DMTTAB(E)
	JRST BARHK4
	TRNE B,1
	PUSHJ P,CTR0
	TRNN B,1
BARHK4:	PUSHJ P,QDEL
	ADDI A,DMTLNG
	LSH B,-1
	AOBJN E,BARHK2
	RETURN

DMTBRK:	SKIPN DMTTAB(I)
	JRST BARFLB
	HRRZ MB,RTBR
	LSH MB,-1
	DPB I,[400,,MB]
	SKIPGE T,PDP11+20(MB)
	JSP D,MTDMRW
	AOS T
	ANDI T,177777
	HRRM T,PDP11+20(MB)
	MOVE A,I
	JUMPE T,DMTBR2
	IMULI A,DMTLNG
	ADDI A,DMTBLK
	PUSHJ P,CTR100
	SKIPGE T,PDP11(MB)
	JSP D,MTDMRW
	AOS T
	ANDI T,177777
	HRRM T,PDP11(MB)
	SOS T
	ANDI T,177777
DMTBR4:	ROT T,-1
	SKIPGE TT,PDP11(T)
	JSP D,MTDMRD
	SKIPGE T
	LSH TT,-8
	ANDI TT,177
	MOVE C,DMTTAB(I)
	DPB C,[270400,,.+1]
	.IOT .,TT
	 IOCGET SKIPA
	RETURN
	SETZM DMTTAB(I)
	MOVE A,I
	JRST BCRDDM

DMTBR2:	PUSHJ P,BARFLB
	SKIPGE T,PDP11(MB)
	JSP D,MTDMRW
	JRST DMTBR4	;DON'T INCREMENT LAST TIME

BARFLB:	MOVEI C,1	;TRANSMIT COMPLETE
	LSH C,(I)
	ANDCAM C,RBAR	;FLUSH BIT IN BAR
	MOVEI C,1
	DPB C,[170100,,RCSR]
	JRST CSRINT

DMRBRK:	LDB T,[100,,RCSR]
	JUMPE T,CPOPJ	;RECEIVER NOT ENABLED
	SKIPN C,DMRTAB(I)
	POPJ P,
	SKIPN DYCTYP-DYCH(C)	;IF TTY, GO SEE IF ANY CHARS.
	JRST DMRTRK
DMRTR0:	DPB C,[270400,,.+1]
	.IOT .,MB
	 IOCGET SKIPA	;DO NOT CHANGE TO JRST
	CAIA
	JRST DMRLOS
	JUMPL MB,CPOPJ	;GIVE UP IF STY HAS NO CHARS.
DMRTRL:	AOS MA,DCRTTP
	ANDI MA,77
	HRRM MA,DCRTTP
	MOVE T,RTBR
	LSH T,-8
	DPB T,[70800,,MA]
	SKIPGE PDP11+100(MA)
	JSP D,MTDMWR
	TRO MB,120000	;ODD PARITY CHAR
	DPB I,[90400,,MB]	;CONSOLE #
	HRRM MB,PDP11+100(MA)
	SKIPGE DMRTAB(I)
	JRST DMRBRL
	MOVE A,I
	IMULI A,DMRLNG
	ADDI A,DMRBLK
	PUSHJ P,CTR100
DMRBRL:	AOS DCRFLG
	JRST CSRINT

CTR100:	MOVE C,TIME
	ADD C,DMTIM
	MOVEM C,(A)
	JRST CTRDES

DMRLOS:	SETZM DMRTAB(I)
	MOVE A,I
	JRST DMRDDM

CTR0:	MOVE C,TIME
	ADDI C,300.
	JRST CTRDES

DMRTRK:	DPB C,[270400,,.+1]
	.STATUS .,A
	TRNE A,2000
	RET		;IF BUFFER EMPTY.
	JRST DMRTR0	;ELSE GO READ CHAR.

;ET ERROR BITS:

ETENDZ==100000	;SEL. DRIVE IN END ZONE.
ETILO==10000	;ILL. OPERATION.
ETSELE==4000	;FAILED TO SELECT UNIQUE DRIVE.
ETBLKM==2000	;WAITED TOO LONG AFTER READING BLOCK NUMBER.
ETNEX==400	;ET GOT A NXM.

;GENERAL ET STATUS:

ETNFIN:	0	;SET IF DT COMMANDS WERE GIVEN BUT NOT FINALIZED.
WET:	0	;SET IF DT IS ATTACHED.
ETUNIT:	-1	;NUMBER OF SELECTED ET UNIT, OR -1 IF NONE.
ETDRIV:	0	;PTR TO INFO ON CURRENTLY SELECTED DRIVE, OR <= 0 IF NONE.
ETDOPN:	0	;-> DRIVE WHOSE FILE IS OPEN, OR 0.
ETDDIC:	0	;-> DRIVE WHOSE DIR IS IN ETBTAB, OR 0.
ETERRO:	0	;ERROR BITS IN TCST.
ETREDY:	0	;ET IS READY IF THIS # 0.

ETBTIM=20000.		;TIME TO READ BLOCK.
ETSTIM=100000.		;TIME TO STOP OR START.

;DRIVE-SPECIFIC INFO:
ETNDRV==10		;NUMBER OF DECTAPE DRIVES.
ETDTAB:
REPEAT ETNDRV,[
	0		;TIME TO REACH NEXT BLOCK.
	-1
	CALL	ETTRP	;ET MOTION RTN.
	-1		;ETDUNI -- UNIT SWITCHES.
	0		;ETDUPS -- -1 IF UP TO SPEED.
	0		;ETDPOS -- CURRENT BLOCK NUM.
	0		;ETDDIR -- DIRECTION (1 - FWD, -1 - BACK).
	0?0?0		;ETDFIL -- FILENAME.
	0		;ETDSNM -- SNAME.
	0		;ETDENA -- NOT 0 IFF DRIVE WRITE-ENABLED.
	0		;ETDIOP -- NOT 0 IFF RDATA, WDATA OK.
]

ETCLEN==3
IRP A,,[UNI,UPS,POS,DIR,FIL,JUNK,JUNK,SNM,ENA,IOP]
ETD!A==ETCLEN
DEFINE ETC!A
ETD!A(B)!TERMIN
ETCLEN==ETCLEN+1
TERMIN

;UNIT-SPECIFIC INFO - -1 IF NO CORRESPONDING DRIVE,
;			0 IF >1 DRIVE,
;			--> ENTRY IN ETDTAB FOR DRIVE IF EXACTLY 1.
ETUTAB:	REPEAT	10,-1		;INITIALLY NO UNIT HAS DRIVE.

ETBTAB:	BLOCK	578.	;ADDR IN FILE OF VIRT BLOCK.
	BLOCK	578.	;VIRT. NUM. OF REAL BLOCK, OR 0.

;ET MOTION TRAPS CALL HERE TO MOVE TAPE 1 POSITION,
;ALSO, FOR SELECTED DRIVE, PROCESS COMMANDS.
ETTRP:	HRRE	A,ETCDIR	;GET CURRENT DIR.
	CAME	A,ETCDIR	;IF LH. WAS CHANGED,
	JRST	ETREV		;MUST REVERSE TAPE.
	MOVEM	A,ETCUPS	;INDICATE UP TO SPEED.
	ADDB	A,ETCPOS	;INDICATE TAPE'S MOVED 1 BLOCK.
	CAML	A,[-20.]
	CAIL	A,600.		;IF POS. OUT OF RANGE,
	JRST	ETREW		;TAPE'S RUN OFF REEL.
	CAMN	B,ETDRIV
	JRST	ETSEL		;SPECIAL PROCESSING FOR SELECTED UNIT.
ETTRPX:	SETZM	ETCIOP		;RDATA NOT OK (BLOCK MISSED)
ETTRPY:	MOVEI	C,ETBTIM	;TIME TO MOVE 1 BLK.
ETREV1:	ADD	C,(B)		;TRAP AGAIN WHEN GET TO NEXT BLOCK.
	MOVEI	A,(B)
	CALL	CTRDES
	JRST	ETINT		;DECIDE WHETHER WANT VIRT TRAP.

ETREV:	MOVNM	A,ETCDIR	;CHANGE DIRECTION.
	SETZM	ETCUPS		;NO LONGER UP TO SPEED.
	MOVEI	C,2*ETSTIM	;TIME TO STOP, START.
	JRST	ETREV1

ETREW:	SETZM	ETCDIR		;STOP TAPE.
	SETZM	ETCUPS
	MOVEI	T,-ETDTAB(B)
	IDIVI	T,ETCLEN	;COMPUTE NUMBER OF DRIVE.
	MOVEM	T,QT
	TTOA	[ASCIZ/
DT DRIVE T RAN OFF /]
	SKIPL	A
	TTOA	1,[ASCIZ/LEFT/]
	TTOA	[ASCIZ/RIGHT/]
	ERROR	[ASCIZ/ REEL
/]
	JRST	ETINT

;COME HERE WITH ERROR BIT IN A.
ETERR:	IORM	A,ETERRO	;INDICATE THE ERROR.

;DECIDE WHETHER VIRT TRAP DESIRED.
;ALL RTNS WHICH CHANGE ETERRO, ETREDY OR INT-ENB MUST COME HERE.
ETINT:	MOVEI	A,ETINTB
	SKIPE	ETERRO		;IF ERROR THEN SET READY.
	SETOM	ETREDY
	MOVE	B,RTCCM
	TRNE	B,100		;IF READY&INT-ENB THEN INTERRUPT
	SKIPN	ETREDY
	JRST	QDEL		;ELSE WITHDRAW REQUEST.
	JRST	MTRNEW

ETINTB:	6			;PRIORITY.
	-1
	JRST	.+1
	MOVEI	T,214/4		;ADDR OF VECTOR.
	JRST	VTRAP		;CAUSE TRAP.

;COME HERE WHEN SELECTED DRIVE MOVES 1 BLK.
ETSEL:	CAIL	A,579.
	SKIPG	ETCDIR		;IF GOING FWD PAST END,
	JRST	.+2
	JRST	ETEND		;SET ENDZ ERROR.
	CAMG	A,[-2]
	SKIPL	ETCDIR		;ALSO IF GOING BACK PAST BEGINNING.
	JRST	.+2
	JRST	ETEND

	SKIPE	ETREDY		;IF READY SET,
	JRST	ETTRPX		;NO COMMAND TO PROCESS.

	LDB	T,[010300,,RTCCM]
	XCT	ETCMDT(T)	;PROCESS THE FUNCTION SPECIFIED.

ETCMDT:	.VALUE		;SAT FN SHOULDN'T COME HERE.
	JRST	ETRNUM
	JRST	ETRDAT
	JRST	ETRALL
	JRST	ETSST		;STOP SELECTED TAPE.
	JRST	ETWRTM		;WRTM FN ALWAYS ILLEGAL.
	JRST	ETWDAT		;WDATA FN.
	JRST	ETWALL		;WALL FN.

;READ BLOCK NUMBER FN. - (PUT IT IN TCDT).
ETRNUM:	JUMPL	A,ETTRPX	;IF POS. OUT OF RANGE,
	CAILE	A,577.
	JRST	ETTRPX		;WE'RE NOT COMING TO A BLOCK.
	HRRM	A,RTCDT		;STORE BLK. NUM.
	SETOM	ETREDY		;FN IS COMPLETED.
	SETOM	ETCIOP		;RDATA NOW OK.
	JRST	ETTRPY

;END ZONE - INDICATE ERROR AND STOP TAPE.
ETEND:	MOVEI	A,ETENDZ
	IORM	A,ETERRO

;STOP SELECTED TAPE FN.
ETSST:	SETZM	ETCUPS
	SETZM	ETCDIR
	SETOM	ETREDY
	JRST	ETINT

;ILLEGAL FNS COME HERE TO CAUSE ILO ERROR.
ETWRTM:		;WILL ALWAYS BE ILLEGAL.
ETWALL:		;MAY SOMEDAY BE LEGAL.
ETRALL:		;DITTO.
ETWDAT:		;SOON BE LEGAL.
	MOVEI	A,ETILO
	JRST	ETERR

ETRDAT:	SKIPN	ETCIOP		;IF NOT AFTER RDATA OR RNUM,
	JRST	ETBLM		;BLKM ERROR.
	CAME	B,ETDDIC	;IF THIS DRIVE'S DIR NOT IN BTAB,
	CALL	ETGBTB		;READ IT IN.
	MOVE	A,ETCFIL
	TLZN	A,1		;MAKE SURE THIS DRV READING ON ETC.
	CAME	B,ETDOPN
	CALL	ETOPEN
	MOVE	A,ETCPOS	;FIND ADDR. OF CURRENT BLOCK.
	SKIPE	A,ETBTAB(A)
	.ACCES	ETC,A		;IF REAL, -> IT.
	HRRZ	MA,RTCBA	;PDP11 ADDR TO STORE INTO.
	MOVNI	X,400		;DON'T READ >1 BLOCK.
	HRRZ	TT,RTCWC	;OR MORE THAN WANTED.
	ORCMI	TT,-200000
ETRDA0:	SKIPE	E,A		;USE REAL CONTENTS OR 0.
	.IOT	ETC,E
	SKIPGE	PDP11(MA)
	JSP	D,MTETWR	;MAYBE TRAP STORING.
	HRRM	E,PDP11(MA)
	ADDI	MA,2		;ADVANCE 1 WD.
	DPB	MA,[2000,,RTCBA]
	AOJ	TT,
	DPB	TT,[2000,,RTCWC]
	JUMPGE	TT,ETRDA1	;IF DID ALL REQUESTED, STOP.
	AOJL	X,ETRDA0	;AFTER WHOLE BLK, STOP.
ETRDA1:	SKIPL	TT
	SETOM	ETREDY		;UNLESS MORE BLKS TO GO.
	JRST	ETTRPY		;KEEP MOVING.

;READ IN DIR. OF CURRENT DRIVE.
ETGBTB:	MOVE	A,ETCFIL
	TLZN	A,1		;GET DRIVE OPEN FOR READING.
	CAME	B,ETDOPN
	CALL	ETOPEN
	.ACCES	ETC,[0]		;DIR. AT FRONT OF FILE.
	MOVSI	A,-2*578.
	.IOT	ETC,ETBTAB(A)
	AOBJN	A,.-1		;READ IN THE DIR.
	MOVEM	B,ETDDIC	;SAY HAVE THIS DRIVE'S DIR.
	RETURN

;OPEN CURRENT DRIVE, DIRECTION IN A.
ETOPEN:	MOVEM	A,ETCFIL
ETOPE1:	MOVE	A,ETCSNM
	.SUSET	[.SSNAM,,A]
	.OPEN	ETC,ETCFIL
	JRST	ETOPNL
	MOVEM	B,ETDOPN	;SAY THIS DRIVE IS OPEN.
	RETURN

ETOPNL:	TTOA	[ASCIZ/
DT FILE NOT FOUND, SUPERQUIT
SET FILE AND PROCEDE /]
	CALL	DDT
	JRST	ETOPE1

ETBLM::	;PREVENT ASSEMBLY ERROR.

;DECTAPE COMMAND REGISTER.
TCCMHK:	TLNN	B,54000
	JRST	TCCMWR
	CALL	ETCCM		;IF READING, COMPUTE TCCM.
TCCMWR:	TLNN	B,22000
	RETURN
	XXWAIT
	HRRZ	A,RTCCM		;IF WRITING, SEE NEW VALUE.
	SKIPE	ETERRO
	TRNE	A,100000	;IF ERROR BIT WAS LOADED W/ 0,
	JRST	TCCM1
	MOVEI	T,ETENDZ+ETNEX+ETBLKM
	ANDCAM	T,ETERRO	;CLEAR SOME ERRORS.

TCCM1:	TRNN	A,1		;IF DO WASN'T SET, EXIT.
	JRST	ETINT
	MOVEI	T,ETSELE+ETILO
	ANDCAM	T,ETERRO	;CLEAR SOME ERRORS SINCE NEW FN.
	SETZM	ETREDY
	TRNN	A,16		;IF FN IS 0,
	JRST	ETSAT		;STOP ALL TAPES RIGHT NOW.
	LDB	B,[100300,,A]	;GET SELECTED UNIT'S NUM.
	MOVEM	B,ETUNIT	;STORE NUM. OF SELECTED UNIT.
	MOVE	B,ETUTAB(B)	;GET PTR--> INFO ON COR. DRIVE.
	MOVEM	B,ETDRIV	;SAY IT'S SELECTED DRIVE.
	JUMPLE	B,ETESEL	;IF DIDN'T SELECT UNIQUE DRIVE, SELE ERROR.
	SKIPN	ETCDIR		;IF DRIVE MOVING,
	JRST	ETSTRT
	HRRZS	ETCDIR		;SET L.H. TO NEW DIRECTION.
	TRNE	A,4000		;(TAPE WILL REVERSE ITSELF IF NEC.).
	HRROS	ETCDIR
	JRST	ETINT

;COME HERE IF TAPE NOT MOVING.
ETSTRT:	TRNN	A,4000
	AOSA	C,ETCDIR	;DIR _ IF FWD THEN 1 ELSE -1.
	SOS	C,ETCDIR
	ADDM	C,ETCPOS	;STARTING TAKES 2 BLKS.
	SETZM	ETCIOP		;RDATA NOT OK.
	MOVEI	A,(B)
	MOVE	C,TIME
	ADDI	C,ETSTIM	;GIVES TIME ET'LL HAVE STARTED.
	CALL	CTRDES
	JRST	ETINT

;COMPUTE TCCM.
ETCCM:	HRRZ	A,RTCCM		;INT-ENB KEPT IN RTCCM.
	ANDCMI	A,160201
	SKIPE	ETERRO
	IORI	A,100000	;GET ERROR BIT.
	SKIPE	ETREDY
	IORI	A,200		;GET READY BIT.
	HRRM	A,RTCCM
	RETURN

;DECTAPE STATUS REGISTER.
TCSTHK:	TLNN	B,54000
	RETURN			;WRITING HAS NO EFFECT.
	HRRZ	A,RTCST
	ANDI	A,3		;DATA EXTENSION BITS KEPT IN RTCST.
	IOR	A,ETERRO	;GET ERROR BITS.
	MOVE	B,ETDRIV
	JUMPLE	B,TCST0		;IF NO SELECTED DRIVE.
	SKIPE	ETCUPS
	IORI	A,200		;INDICATE IF SEL. DRIVE UP TO SPEED.
TCST0:	HRRM	A,RTCST
	RETURN

;RESET DECTAPE.
ZET:	SKIPN	WET
	RETURN			;...IF NOT ATTACHED.
	HLLZS	RTCWC		;ZERO THE REGS.
	HLLZS	RTCBA
	HLLZS	RTCDT
	HLLZS	RTCST
	HLLZS	RTCCM
	SETZM	ETERRO

;STOP ALL TAPES.
ETSAT:	MOVE	B,[-10,,ETDTAB]
ETSAT1:	HRRE	A,ETCDIR
	ADDM	A,ETCPOS	;STOPPING TAKES 1 BLK.
	SETZM	ETCDIR
	SETZM	ETCUPS
	SAVE	B
	MOVEI	A,(B)
	CALL	QDEL		;STOP THE CLOCK TRAPS FOR MOTION.
	REST	B
	ADDI	B,ETCLEN-1
	AOBJN	B,ETSAT1
	SETOM	ETREDY
	JRST	ETINT

;DETACH.
DET:	CALL	ZET
	SETZM	WET
	CALL	WRDZAP		;FLUSH THE REGS TO NXM.
	RTCST,,RTCDT
	RETURN

ETNXM0:	MOVEI	D,.+3		;RETURN AFTER JRST.
	MOVEM	D,-SAVLNG(P)
	JRST	RSTALL
	MOVEI	A,ETNEX
	IORM	A,ETERRO	;SET NXM ERROR.
	JRST	ETTRPX


;ATTACH DECTAPE.
CDT:
AET:	SKIPE	WET		;IF REGS NOT SET UP,
	JRST	AET0
	CALL	WRDINS		;SET THEM UP.
	RTCCM	(NTCCM+600000)
	RTCST	(NTCST+600000)
	RTCWC
	RTCBA
	RTCDT
	0
	SETOM	WET		;INDICATE THEY'RE SET UP.
	CALL	ZET		;INITIALIZE THEM.
AET0:	MOVEI	T3,(DL)		;IF WAS ARG, SELECT THAT DRIVE.
	TLNN	SF,NUMFND
	SETO	T3,		;ELSE NO DRIVE SELECTED.
	SETZM	AETCRP
	SETZM	AETLFL
	CALL	GPASST		;IF NO CMDS ON THIS LINE
	CAIE	T0,^M
	JRST	AET2
	SETOM	AETLFL		;READ SEVERAL.
AET1:	CALL	GPASST
	CAIE	T0,^M
	SETZM	AETCRP		;CLEAR AFTER NON-CR.
	CAIN	T0,^M
	JRST	AETCR
AET2:	CAIN	T0,",
	JRST	AET1		;IGNORE SPACE, COMMA, CR.
	CALL	DGSYM		;READ NAME OF OPTION.
	HLLZS	T2		;TRUNCATE TO 3 CHARS.
	JUMPE	T2,ETOERR	;ERROR IF NO SYMBOL.
	MOVSI	T5,-ETONUM	;AOBJN PTR -> OPTION.
	AOJ	T5,
	CAME	T2,ETOTAB-1(T5)
	AOBJN	T5,.-2		;SEARCH TABLE FOR SYMBOL READ.
	JUMPGE	T5,ETOERR	;ERROR IF CAN'T FIND SYMBOL.
	CALL	@ETOTAB(T5)	;CALL RTN FOR OPTION.
	CALL	ETOFIN		;RECOMPUTE DRIVE ASSIGNMENTS.
	TLO	SF,D1CHAR	;WILL MAKE GPASST ACT LIKE PASSPS.
	JRST	AET1

ETOTAB:		;LIST OF DT OPTIONS.
IRP X,,[BLOCK,DONE,DRIVE,DSTAT,ENABLE,FILE,LIST,LOCK
NEW,OFF,RESET,RO,STATUS,STOP,SUNIT,UNIT,WE,WL]
	(SIXBIT/   X/)	;USE 1ST 3 CHARS ONLY.
	ETO!X
TERMIN
ETONUM=<.-ETOTAB>/2

ETOERR:	ERROR	[ASCIZ/BAD OPTION/]

AETCR:	SKIPN	AETLFL		;IF END OF 1ST LINE,
	SKIPE	AETCRP		;OR 2ND CR IN ROW,
	RETURN
	SETOM	AETCRP		;ELSE GOT 1ST CR.
	JRST	AET1

AETLFL:	0
AETCRP:	0

; STATUS OPTION -- GIVES STATUS OF ALL DRIVES.
ETOSTA:	CRF
	TTOA	ETSMSG
	SAVE	T3
	SETZ	T3,
	CALL	ETODS1		;PRINT STATUS OF EACH DRIVE
	CAIGE	T3,ETNDRV-1
	AOJA	T3,.-2		;UNTIL ALL DONE.
	REST	T3
	CRF
	RETURN

; DSTAT OPTION -- STATUS OF CHOSEN DRIVE. FINISHES.
ETODST:	TTOA	ETSMSG
ETODS1:	CALL	ETOGDV		;SET UP FOR SELECTED DRIVE.
	SAVE	SF
	TLO	SF,DNUMM
	TTOA	[ASCIZ/  /]
	SYMTYP	T3		;PRINT DRIVE NUM.
	TTOI	^I
	SKIPGE	T5,ETCUNI	;PRINT CORR. UNIT NUM.
	TTOA	2,[ASCIZ/ OFF/]
	TTOA	[ASCIZ/  /]
	SYMTYP	T5
	CAMN	B,ETDRIV
	TTOA	[ASCIZ/ */]	;IF SELECTED, SAY SO.
	TTOI	^I
	HRRZ	T5,ETCPOS	;PRINT TAPE POSITION.
	TTOA	[ASCIZ/  /]
	SYMTYP	T5
	TTOI	^I
	SKIPN	ETCENA		;SAY WHETHER WRITE-ENABLED.
	TTOA	1,[ASCIZ/WL /]
	TTOA	[ASCIZ/WE /]
	SKIPN	ETCDIR
	TTOA	3,[ASCIZ/STOP	/]	;IF DRIVE NOT MOVING.
	SKIPL	ETCDIR
	TTOA	1,[ASCIZ/FWD	/]	;IF FORWARD.
	TTOA	[ASCIZ/BACK	/]	;IF BACKWARD.
	HRLZ	T5,ETCFIL	;GET DEV. NAME.
	6TYPE	T5		;PRINT DEV. NAME,
	TTOI	":
	6TYPE	ETCSNM		;SNAME.
	SKIPE	ETCSNM
	TTOI	";
	6TYPE	1+ETCFIL	;FILENAMES.
	TTOI	" 
	6TYPE	2+ETCFIL
	CRF
POPSFJ:	REST	SF
	RETURN

ETSMSG:	ASCIZ/DRIVE	UNIT	POS.	W? DIR	FILE
/

; BLOCK OPTION - MOVE DECTAPE TO SPECIFIED POSITION.
ETOBLO:	CALL	ETOARG
	-20.,,600.		;LIMITS ON RANGE OF VALID ARGS.
	CALL	ETOGDV		;MAKE SURE DRIVE CHOSEN.
	MOVEM	T2,ETCPOS	;SET THAT DRIVE'S POSITION.
	SETZM	ETCDIR
	JRST	ETOST1		;STOP THE DRIVE (WAS PUT ON LOCAL).

; DRIVE OPTION -- CHOSE A SPECIFIC DRIVE.
ETODRI:	CALL	ETOARG		;READ ARG.
	0,,ETNDRV
	MOVEI	T3,(T2)		;SET DRIVE NUM.
	RETURN

; ENABLE OPTION (ALSO WE) -- ENABLE WRITING.
ETOENA:
ETOWE:	CALL	ETOGDV
	SETOM	ETCENA		;WRITE-ENABLE.
	RETURN

; LOCK OPTION (ALSO RO, WL) -- LOCK OUT WRITING.
ETOLOC:
ETORO:
ETOWL:	CALL	ETOGDV
	SETZM	ETCENA
	RETURN

; FILE OPTION -- SET FILE ASSOCIATED WITH DRIVE. STOPS DRIVE.
ETOFIL:	CALL	ETOGDV
	MOVEI	A,ETCFIL
	SAVE	B
	SAVE	T3
	CALL	DGFIL		;READ FILE NAME.
	REST	T3
	REST	B
	.SUSET	[.RSNAM,,A]
	MOVEM	A,ETCSNM	;SET SNAME TOO.
	CAMN	B,ETDDIC	;IF THIS DRIVE'S DIR WAS IN,
	SETZM	ETDDIC		;NO LONGER.
	CAME	B,ETDOPN
	RETURN
	SETZM	ETDOPN
	.CLOSE	ETC,
	RETURN

; OFF OPTION -- SET OFFLINE (NOT ASSIGNED TO ANY UNIT).
ETOOFF:	CALL	ETOGDV
	SETOM	ETCUNI
	SETOM	ETNFIN		;HAVE CHANGED UNIT ASSIGNMENTS.
	RETURN

; STOP OPTION -- STOP DRIVE.
ETOSTO:	CALL	ETOGDV
ETOST1:	HRRE	A,ETCDIR	;STOPPING TAKES 1 BLOCK.
	ADDM	A,ETCPOS
	SETOM	ETNFIN		;INDICATE FINISHING NEEDED.
	SETZM	ETCDIR		;SAY ISN'T MOVING.
	SETZM	ETCUPS
	MOVEI	A,(B)
	JRST	QDEL		;STOP TRAPS FOR ITS MOTION.

; SUNIT OPTION -- SET UNIT ASSIGNMENT.
ETOSUN:	CALL	ETOARG
	0,,7
	CALL	ETOGDV		;SET UP CHOSEN DRIVE.
	HRRZM	T2,ETCUNI	;SET UNIT NUM. WORD.
	SETOM	ETNFIN		;MUST RECOMPUTE UNIT-ASSIGNMENTS.
	RETURN

; UNIT OPTION -- CHOSE DRIVE WITH SPECIFIED UNIT NUM. MUST FINISH.
ETOUNI:	CALL	ETOFIN		;SO CAN KNOW WHICH DRIVE GOES WITH UNIT.
	CALL	ETOARG
	0,,7
	SKIPN	T2,ETUTAB(T2)	;GET -> INFO FOR CORRSP. DRIVE.
	ERROR	[ASCIZ/DRIVE NOT UNIQUE/]
	SKIPG	T2
	ERROR	[ASCIZ/UNIT HAS NO DRIVE/]
	SUBI	T2,ETDTAB	;COMPUTE DRIVE NUM. FROM PTR.
	IDIVI	T2,ETCLEN
	MOVEI	T3,(T2)
	RETURN

; RESET OPTION -- STOP ALL TAPES, ETC.
ETORES==ZET

; LIST OPTION -- LIST NAMES OF OPTIONS.
ETOLIS:	MOVE	T1,[-ETONUM,,ETOTAB]
	JRST	CLCOMS

; NEW OPTION -- UN-CHOSE THE CHOSEN DRIVE, CAUSE NEW DRIVE
;  TO BE CHOSEN NEXT TIME ONE'S NEEDED.
ETONEW:	SETO	T3,
	RETURN

;READ IN AN ARG, SAVING T3. ERROR IF NO ARG OR REGISTER.
;	CALL	ETOARG
;	LOW,,	HIGH		;RANGE OF ADMISSIBLE VALUES.
ETOARG:	SAVE	T3
	CALL	DGVPSP		;TRY READING VALUE.
	REST	T3
	SKIPN	DGVALP
	ERROR	[ASCIZ/NO ARG/]
	TLNE	T2,REGBIT
	ERROR	[ASCIZ/ACCUM./]
	HRREI	T2,(T2)		;EXTEND ARG TO FULL WORD.
	HLRE	T5,@(P)		;LOW END OF RANGE,
	HRRE	T6,@(P)		;HIGH END.
	CAML	T2,T5
	CAILE	T2,(T6)
	ERROR	[ASCIZ/ARG OUT OF RANGE/]
	AOS	(P)
	RETURN

; FINISH OPTION -- RECOMPUTE CORRESPONDENCE BETWEEN DRIVES AND UNITS.
;IF THE SELECTED DRIVE'S UNIT HAS CHANGED, OR IT HAS BEEN STOPPED,
;AND READY IS OFF, A SELECTION ERROR IS CAUSED.
;EXITS TO ETINT ALWAYS SINCE MIGHT HAVE CHANGED READY OR ERROR.
ETOFIN:	SKIPN	ETNFIN
	RETURN			;IF NOTHING TO DO. ELSE,
	SETZM	ETNFIN		;INDICATE HAVE FINISHED.
	MOVSI	T5,-10
	SETOM	ETUTAB(T5)	;SO FAR, EACH UNIT HAS NO DRIVES.
	AOBJN	T5,.-1
	MOVE	B,[-ETNDRV,,ETDTAB]
ETOX0:	SKIPGE	T5,ETCUNI	;IF DRIVE OFFLINE, SKIP IT.
	JRST	ETOX1
	SKIPL	ETUTAB(T5)	;IF ITS UNIT HAS A DRIVE ALREADY,
	SETZM	ETUTAB(T5)	;IT NOW HAS >1, NOT SELECTABLE.
	SKIPGE	ETUTAB(T5)	;OTHERWISE IT HAS 1 DRIVE (THIS ONE).
	HRRZM	B,ETUTAB(T5)
ETOX1:	ADDI	B,ETCLEN-1
	AOBJN	B,ETOX0
	SKIPGE	T5,ETUNIT	;IF A UNIT IS SELECTED,
	JRST	ETINT
	MOVE	B,ETUTAB(T5)
	EXCH	B,ETDRIV	;UPDATE SELECTED DRIVE.
	CAMN	B,ETDRIV	;IF IT HAS CHANGED,
	JRST	ETOX2
ETOX3:	SKIPE	ETREDY		;IF WERE IN MIDDLE OF DT OPERATION,
	JRST	ETINT
	SETOM	ETUNIT		;INDICVATE NONE SELECTED,
	SETOM	ETDRIV
	TTOA	[ASCIZ/CAUSED SELE ERROR
/]
ETESEL:	MOVEI	A,ETSELE	;CAUSE ERROR.
	JRST	ETERR

ETOX2:	SKIPE	ETCDIR		;IF DRIVE STILL SAME, BUT HAS BEEN STOPPED,
	JRST	ETINT
	JRST	ETOX3		;MAY ALSO CAUSE SELE ERROR.

;MAKE SURE A DRIVE HAS BEEN CHOSEN. IF NOT, CHOSE AN OFFLINE DRIVE.
;SET B UP -> INFO ON DRIVE.
ETOGDV:	JUMPGE	T3,ETOGD2	;IF DRIVE ALREADY CHOSEN.
	MOVSI	T3,-ETNDRV
	MOVEI	B,ETDTAB	;ELSE SEARCH THRU ETDTAB
ETOGD0:	SKIPGE	ETCUNI		;FOR A DRIVE THAT'S OFFLINE.
	JRST	ETOGD1		;IF FOUND.
	ADDI	B,ETCLEN	;ELSE TRY NEXT ONE.
	AOBJN	T3,ETOGD0
	ERROR	[ASCIZ/WHAT DRIVE/]	;IF ALL ONLINE.

ETOGD1:	MOVEI	T3,(T3)		;T3, B BOTH SET UP NOW.
	RETURN

ETOGD2:	MOVEI	B,(T3)		;COMPUTE B FROM T3.
	IMULI	B,ETCLEN
	ADDI	B,ETDTAB
	RETURN
]

;BLOCK FORMAT
;WD1 TIME OR PRIORITY
;WD2 -1=IDLE, ELSE LINK
;WD3 INST TO XCT

;10 PS
;7 PC
;6 XXWAIT
;5  DEFERRED BNDRY ERROR (PC SET TO ODD ADDR)
;4,,500000	MEMORY MANAGEMENT TRAP.
;4 TT
;3 PDLOV
;2 STOP
TRQADD:	SKIPL 1(A)	;TRAP QUEUE ADD
	RETURN	;ALREADY IN QUEQUE
	MOVEM C,(A)
TRQQA:	MOVEI B,TRINF
	TLZ A,-1
QADD:	MOVE C,B
	MOVE B,1(C)
	MOVE T,(B)
	CAML T,(A)
	JRST QADD
	MOVEM A,1(C)
	MOVEM B,1(A)
	RETURN

CLQADD:	SKIPL 1(A)	;CLOCK QUEUE ADD
	RETURN	;ALREADY IN QUEQUE
	MOVEI B,CLINF
	MOVEM C,(A)
	TLZ A,-1
QADD2:	MOVEM A,QFLAG	;SAY THIS BLOCK BEING QUEUED AT MAIN PROG LVL.
	MOVE C,B
	MOVE B,1(C)
	MOVE T,(B)
	CAMGE T,(A)
	JRST QADD2
	MOVEM A,1(C)	;MAKE PREV POINT TO NEW
	MOVEM B,1(A)	;MAKE NEW POINT TO NEXT
	SETZM QFLAG
	RETURN

QDEL:	SKIPGE 1(A)	;QUEUE ITEM DELETE
	RETURN	;ALREADY IDLE
	MOVE B,A
QDEL2:	MOVE C,B
	MOVE B,1(C)
	CAIN B,CLINF
	MOVEM A,QFLAG
	CAME B,A
	JRST QDEL2
	MOVE B,1(A)
	SETOM 1(A)
	MOVEM B,1(C)
	SETZM QFLAG
	RETURN

TRINF:	-1	;ROOT OF TRAP QUEUE
	TRINF
	.VALUE

CLINF:	377777,,	;ROOT OF CLOCK QUEUE
	CLINF
	TTOA [ASCIZ /
THIS PROGRAM HAS REACHED THE AGE OF MANDATORY RETIRMENT/]

PDL:	BLOCK PDLSIZ
	BLOCK 20	;SO PDL OVERFLOW DOESN'T CLOBBER THINGS
PAT:
PATCH:	BLOCK 100

TYOFLG:	-1	;OUTPUT TO TTY
LPTFLG:	0	;OUTPUT TO LPT
LPTCNT:	0	;NUM TIMES LPT OPEN
QFLAG:	0	;IN CLQADD OR QDEL FOR CLQUEUE
RUN:	0
TRPPNT:	1	;TPV
	BLOCK TRPPTL-1
INVTRP:	0	;IN VTRAP
QA:	0
QD:	0
QT:	0
RTIME:	0

CONSTANTS

RNGCSR=IOORG+72020	;NG DIS
RNGREL=IOORG+72021

45Y[
RSDR0=IOORG+172100/2
RSAR0=IOORG+172140/2
RSSR3=IOORG+172516/2
]
RPKCSR=IOORG+75260	;KW11 PROGRAMMABLE CLOCK
RPKCSB=IOORG+75261
RPKC=IOORG+75262

RRCSR=IOORG+76000	;DC11 ASYNCHRONOUS LINE INTERFACE
RRBUF=IOORG+76001
RTSCR=IOORG+76002
RTBUF=IOORG+76003

RCSR=IOORG+76400	;DM11 ASYNCHRONOUS 16-LINE SINGLE SPEED INTERFACE
RBAR=IOORG+76401
RBCR=IOORG+76402
RTBR=IOORG+76403

RDIV=IOORG+77540	;EAE
RAC=IOORG+77541
RMQ=IOORG+77542
RMUL=IOORG+77543
RSCSR=IOORG+77544
RNOR=IOORG+77545
RLGS=IOORG+77546
RARS=IOORG+77547

RTCST=IOORG+77560	;777340		DECTAPE
RTCCM=IOORG+77561	;777342
RTCWC=IOORG+77562	;777344
RTCBA=IOORG+77563	;777346
RTCDT=IOORG+77564	;777350

RRKDS=IOORG+77600	;RK11 DSK
RRKER=IOORG+77601
RRKCS=IOORG+77602
RRKWC=IOORG+77603
RRKBA=IOORG+77604
RRKDA=IOORG+77605
RRKMR=IOORG+77606
RRKDB=IOORG+77607

RDCS=IOORG+77630	;RF11/RS11 DSK
RWC=IOORG+77631
RCMA=IOORG+77632
RDAR=IOORG+77633
RDAE=IOORG+77634
RDBR=IOORG+77635
RMA=IOORG+77636
RADS=IOORG+77637

RLPS=IOORG+77646
RLPB=IOORG+77647
RLKS=IOORG+77663
RPRS=IOORG+77664
RPRB=IOORG+77665
RPPS=IOORG+77666
RPPB=IOORG+77667
RTKS=IOORG+77670
RTKB=IOORG+77671
RTPS=IOORG+77672
RTPB=IOORG+77673
RSWR=IOORG+77674

45Y[
RSSR0=IOORG+177572/2
RSSR1=IOORG+177574/2
RSSR2=IOORG+177576/2
RUSDR0=IOORG+177600/2
]

RCSX=IOORG+77750	;& NEXT TWO WORDS

RATE=IOORG+77774
RPIR=IOORG+77775	;11/45
45Y	RSLR==IOORG+177774/2	;STACK LIMIT REGISTER.
RPS=IOORG+77777

;DEFINE  ACCUMULATORS
	I1=4
	SF=5
	DO=6		;IF POSITIVE, VIRT. ADDRESS OF OPEN LOC.
	DL=7		;HOLDS %Q OR ARG.
	T0=10		;HOLDS LAST CHAR, EXCEPT IN INSN PRINTING.
	T1=11		;TEMP FOR INST HANDLERS
	T2=12		;USED BY ADDRESS COMPUTATION RTNS.
	T3=13
	DLEN=14		;HOLDS LENGTH OF %Q OR ARG IN WORDS.
	T5=15		;EXTREMELY TEMPORARY.
	T6=16		;  "    "    "    " .

.XCREF SF,DL,T0,T1,T2,T3,T5,T6

;FLAGS IN SFLAGS, LEFT HAND SIDE

DBYTM==200000	;REGISTER OPEN IN BYTE MODE.
DEXCM==100000	;IN DON'T PRINT CONTENTS MODE.
DINSM==40000	;PRINT AS INSTRUCTION.
DSYMM==20000	;PRINT NUMBERS, ADDRESSES SYMBOLICALLY.
DASCM==10000	;PRINT NUMBERS AS ASCII.
DNUMM==4000	;PRINT NUMBERS NUMERICALLY. ABOVE DSYMM.
DDECM==2000	;WHEN PRINTING NUMERICALLY, USE BASE 10. .
DREGM==1000	;PRINT REGISTER NUMS NUMERICALLY.
NUMFND==200	;SET AT ENTRY TO COMMAND IF HAS ARG.
DSEMFL==100	;IF SET, RUBBING-OUT SHOULD BE STOPPED BY NON-DIGITS.
CSSFLG==40	;SET DURING ;S -- CAUSES INPUT FROM LOADCH.
D1CHAR==20	;RE-READ THE CHAR IN T0, IN NEXT GETCHR.
BYTOPN==10	;CURRENTLY OPEN LOC. IS BYTE.

DMODES==DBYTM+DEXCM+DINSM+DSYMM+DASCM+DNUMM+DDECM+DREGM

	JRSTF==JRST	2,0
	IF2 CDDT==CALL DDT	;USED FROM HACTRN WITH $X.
	IF2 GETCHR==CALL DGCHR	;NEXT INPUT CHAR, IN DDT.

;FLAG IN AC CONTAINING ADDRESS (IN DDT)
REGBIT==1	;INDICATES ADDR. IS REGISTER NUM.
.5KBIT==400000	;INDICATES .5KILLED SYMBOL .

XREGTY:	TLNE	SF,DREGM
	JRST	XREGT1
	SKIPN	XSYMTA
	TLNN	SF,DNUMM
	TLNN	SF,DSYMM
	JRST	XREGT1		;IF SHOULDN'T PRINT SYMBOL.
	HRLI	B,1		;TYPE-CODE FOR REG. SYM.
	HRRZ	A,SYMEND
XREGT0:	CAME	B,1(A)		;IF THIS STE'S VALUE IS REG. TO TYPE,
	JRST	XREGT5
	6TYPE	(A)		;PRINT NAME OF SYMBOL.
	JRST	UUOXIT
XREGT5:	SUBI	A,2
	CAIE	A,SYMDRG	;NO NEED TO CHECK INSNS AND %1...%7 .
	JRST	XREGT0
XREGT1:	SKIPN	XREGTF		;NO SYMBOL, PRINT NUMERICALLY.
	TTOI	"%		;INDICATE IS REG. UNLESS TOLD NO NEED TO.

XNUMTY:	ANDI	B,-1
	MOVEI	C,DECP
	TLNN	SF,DDECM	;IF DECIMAL, CALL DECP,
	MOVEI	C,OCTP
	PUSHJ	P,(C)		;CALL PRINT RTN.
	TLNE	SF,DDECM	;IN DECIMAL MODE, PRINT ".".
	TTOI	".
	JRST	UUOXIT

XASCTY:	CAILE	B,377		;1 CHAR?
	JRST	XASCT1		;NO, 2.
	TTOI	"'		;1.
	TTOI	(B)		;PRINT IT.
	JRST	UUOXIT
XASCT1:	TTOI	""		;2 CHARS.
	TTOI	(B)		;PRINT 1ST (LOW) CHAR.
	LSH	B,-10
	JRST	XASCT1-2

XREGTF:	0		;IF #0, OK TO OMIT % WHEN PRINTING REG. VAL.
XSYMTA:	0

;PRINT AN ADDRESS SYMBOLICALLY:
XADRTY:	SETOM	XSYMTA		;INDICATE ADRTYP.
	JRST	.+2

;PRINT NUMBER IN CURRENT MODE.
XSYMTY:	SETZM	XSYMTA
	MOVE	B,(A)		;WORD TO PRINT.
	TLNE	B,REGBIT	;IF REGISTER NUM, SPECIAL HANDLING
	JRST	XREGTY
	SKIPE	XSYMTA		;IF NOT PRINTING ADDRESS TO OPEN,
	JRST	XSYMT3
	TLNE	SF,DNUMM	;CHECK FOR NUMERIC AND ASCII MODES.
	JRST	XNUMTY
	TLNE	SF,DASCM
	JRST	XASCTY
XSYMT3:	TLNN	SF,DSYMM	;IF NOT IN SYMBOLIC MODE,
	JRST	XNUMTY		;PRINT NUMERICALLY.
	TRZ	B,600000
	PUSH	P,T
	PUSH	P,D		;NAME OF BEST SYMBOL SO FAR.
	PUSH	P,E		;VALUE OF BEST SYMBOL SO FAR.
	SETZ	D,		;NO SYMBOL FOUND.
	SETO	E,		;BEST SYMBOL'S VALUE IS -1.
	HRRZ	C,SYMEND
XSYMT0:	SKIPL	T,1(C)		;ONLY NON-.5KILLED NORMAL SYMBOLS O.K.
	TLNE	T,-1
	JRST	XSYMT1
	CAIG	T,(B)		;ACCEPTABLE ONLY IF <= NUM. TO BE PRINTED.
	CAIL	E,(T)		;CLOSER THAN BEST SO FAR?
	JRST	XSYMT1
	MOVE	D,(C)		;YES, REPLACE BEST SO FAR'S NAME, VALUE.
	MOVEI	E,(T)
XSYMT1:	SUBI	C,2		;SEARCH TABLE BACKWARDS TO GET USER
	CAIL	C,SYMDRG	;SYMBOLS BEFORE PREDEFINED ONES.
	JRST	XSYMT0
	JUMPE	D,XSYMT2	;IF NO SUITABLE SYMBOL, PRINT NUMERICALLY.
	SUBM	B,E		;E HAS OFFSET OF VALUE FROM SYMBOL.
	CAIL	E,200		;TOO FAR AWAY => PRINT NUMERICALLY.
	 JRST	XSYMT2
	MOVEI	B,(E)		;ELSE THE # TO PRINT IS THE OFFSET.
	6TYPE	D
	JUMPE	B,XSYMT4	;IFF OFFSET, --
	TTOI	"+
XSYMT2:	TLO	B,200000	;NO SYMBOL- MAKE SURE TYPE ADDR. EVEN IF 0.
XSYMT4:	POP	P,E
	POP	P,D
	POP	P,T
	JUMPE	B,UUOXIT
	JRST	XNUMTY		;PRINT OFFSET IF ANY.


;GET NEXT INPUT CHAR. OUT OF LINE BUFER.
;IF BUFFER EMPTY, READ+ECHO UNTIL BREAK CHAR.
DGCHR1:	PUSHJ	P,DGLIN		;READ & ECHO LINE.
DGCHR:	TLZE	SF,D1CHAR	;IF SET, REREAD CHAR. IN T0.
	RETURN
	SETZM	DGLCQF
DGCHR0:
TXN[	SKIPE	FILINF		;IF :XFILING,
	JRST	DGCHRF		;READ FROM UTIC.
]
	SOSGE	DGLCNT		;COUNT CHARS. IN BUFFER.
	JRST	DGCHR1		;IF NONE LEFT, GET NEW LINE.
	ILDB	T0,DGLPTR	;GET NEXT CHAR.
DGCHR2:	CAIN	T0,^Q		;IF CHAR IS ^Q,
	SKIPE	DGLCQF		;NOTQQUOTED BY PREV. ^Q,
	RETURN
	SETOM	DGLCQF		;INDICATE NEXT CHAR IS QUOTED,
	JRST	DGCHR0		;READ IT.

DGCHCS:
DGCHRF:
TXN[	.IOT	UTIC,T0
	MOVEI	T0,(T0)
	TTOI	(T0)		;ECHO.
	CAIE	T0,^J
	 JRST	.+3
	SKIPE	DGCHRC		;FLUSH LF'S AFTER CR'S IN FILES.
	 JRST	DGCHRF
	SETZM	DGCHRC
	CAIN	T0,^M
	 SETOM	DGCHRC		;INDICATE HAD CR AS LAST CHAR.
	CAIN	T0,^C		;IF EOF, GO BACK TO TTY.
	 JRST	DGCHCC
	SKIPE	DGLCQF		;IF CHAR NOT ^Q-QUOTED,
	 JRST	DGCHR2
IRPC CHAR,,BEWVS
	CAIN	T0,^CHAR	;CHECK FOR IO CTL CHARS
	 JRST	DGCHC!CHAR
TERMIN
	JRST	DGCHR2

DGCHCB:	CALL	DGLNCB		;OPEN LPT.
	JRST	DGCHCS
DGCHCE:	CALL	DGLNCE		;END OUTPUT TO LPT.
	JRST	DGCHCS
DGCHCV:	SETOM	TYOFLG		;TURN ON TTY OUTPUT.
	JRST	DGCHCS
DGCHCW:	SETZM	TYOFLG		;TURN IT OFF.
	CALL	TRESET
	JRST	DGCHCS
DGCHCC:	.CLOSE	UTIC,		;ON EOF, CLOSE FILE,
	SETZM	FILINF
	JRST	DGCHR		;AND GO BACK TO TTY.
]
ETODON:
POP1J:	SUB	P,[1,,1]
	RETURN

;READ FROM TTY UP TILL ACTIVATION NECESSARY,
;PROCESSING RUBOUTS UNTIL THEN.
;WHEN DONE, RETURN WITH DGLCNT=NUM CHARS,
;DGLPTR=B.P. TO CHARS.
DGLIN:	PUSH	P,T1
	SETZM	DGLRCT
	MOVE	T1,[440700,,DGLBUF]	;INITIAL B.P.
	MOVEM	T1,DGLPTR	;USED TO STORE CHARS.
	MOVE	T1,DGLINF
	MOVEM	T1,DGLINS
DGLRB0:	SETZM	DGLCNT		;RE-INIT. AFTER RUBOUT, THEN RE-READ.
	SETZM	DGLNQC
	SETZM	DGLCQF		;1ST CHAR NOT ^Q'D.
	TLZ	SF,DSEMFL
	SETZM	DGLALF
TXN[	.CALL	TTYM1
	 .LOSE	%LSFIL
]
DGLIN1:	SETZM	DGLCQF		;NORMALLY, CHAR NOT ^Q-QUOTED.
DGLIN0:	SKIPN	DGLRCT		;IF CHARS LEFT BEFORE RUBOUT,
	JRST	DGLIN2
	ILDB	T0,DGLRBP	;RE-READ THEM.
	SOSG	DGLRCT		;IF THE LAST CHAR LEFT
	SKIPE	DGLCQF		;IS AN UN-^Q-QUOTED ^Q,
	JRST	DGLIN3
	CAIE	T0,^Q		;IT HAD QUOTED THE CHAR RUBBED OUT,
	JRST	DGLIN3
	TTOI	^Q		;SO RUB OUT THE ^Q, TOO.

DGLIN2:
TXN[	TLNE	SF,DSEMFL	;IF AFTER A ';',
	.CALL	TTYMA		;ACTIVATE ON EACH CHARACTER.
	 JFCL
	.IOT	TYIC,T0		;ELSE, READ NEW CHAR.
]
TXY[	PUSH	P,A
	PBIN
	MOVE	T0,A
	CAIN	T0,^M
	 PBIN
	CAIN	T0,37
	 MOVEI	T0,^M
	POP	P,A
]

;NOW DECIDE WHAT TO DO WITH THE CHAR. JUST READ.
DGLIN3:	SKIPE	DGLCQF		;UNLESS CHAR WAS ^Q-QUOTED,
	JRST	DGLIT5
	CAIN	T0,^Q		;PROCESS ^Q,
	JRST	DGLCTQ
	CAIN	T0,177		;RUBOUT SPECIALLY.
	JRST	DGLRUB
DGLIT5:	SKIPE	DGLNQC		;NEXT THREE TESTED EVEN IF ^Q-QUOTED:
	JRST	DGLQTD		;IF QUOTED BY ' OR ".
	SKIPE	DGLALF
	JRST	DGLAL1		;IF AFFECTED BY PREV. ALTMODE.
	TLNE	SF,DSEMFL
	JRST	DGLSM1		;IF AFTER UNQUOTED ";".
	CAILE	T0,"Z
	JRST	DGLIT6
	SKIPN	DGLCQF
	CAIL	T0,"A		;ELSE DON'T BOTHER TESTING
	JRST	DGLREG		;ALPHABETIC CHARS, ^Q-QUOTED CHARS.
DGLIT6:	SKIPE	DGLINF
	JRST	DGLIT2		;IN LINE MODE ^M IS ONLY BREAK CHAR.

;NORMAL BREAK CHARS:
	CAIE	T0,"[
	CAIN	T0,"]
	JRST	DGLBK
	CAIN	T0,^]
	JRST	DGLBK
IRP C1,,[^L,^N,"/,"=,"_]C2,,[^\,^P,^I,^J,"^]
	CAIE	T0,C1
	CAIN	T0,C2
	JRST	DGLBK
TERMIN
	CAIN	T0,"'
	JRST	DGLQUO		;QUOTES NEXT CHAR.
	CAIN	T0,""
	JRST	DGL2Q		;QUOTES 2 CHARS.
	CAIN	T0,":
	JRST	DGLCOL		;ENTERS LINE MODE TO READ COMMAND.
	CAMN	T0,SEMICL
	JRST	DGLSEM		;READS NUMBER, THEN LETTER.
	CAMN	T0,ALTMOD
	JRST	DGLALT		;QUOTES ALL CHARS EXCEPT ALTMODE.
DGLIT2:	CAIN	T0,^M
	JRST	DGLBK

;THESE CHARS ARE TESTED FOR IN ALL STATES
;EXCEPT WHEN ^Q-QUOTED.
DGLIT3:	SKIPN	DGLCQF
	JRST	DGLIT4		;IGNORE IF ^Q QUOTED.
	CAIN	T0,^S
	JRST	DGLCTS		;^S TURNS OUTPUT BACK ON WHEN READ.
	CAIE	T0,^B
	CAIN	T0,^E
	JRST	DGLIN1		;^B, ^E, ^W, ^V SIGNIF. ONLY AT
	CAIE	T0,^V		;INTERRUPT LEVEL,
	CAIN	T0,^W		;IGNORED HERE.
	JRST	DGLIN1
DGLIT4:	TLNE	SF,DSEMFL	;AFTER A ";", ALL NORMAL CHARS
	JRST	DGLBK		;ARE BREAK CHARS.
	SETZM	DGLALF
	JRST	DGLREG

;ROUTINES TO HANDLE VARIOUS TYPES OF CHARS.

DGL2Q:	AOS	DGLNQC		;INSERT, QUOTE NEXT 2 CHARS.
DGLQUO:	AOSA	DGLNQC		;QUOTE ONLY 1 CHAR.
DGLQTD:	SOS	DGLNQC		;THIS CHAR IS QUOTED.
DGLREG:	SETZM	DGLCQF		;TURN OFF AFTER OTHER THAN ^Q.
	SKIPA
DGLCTQ:	SETOM	DGLCQF		;^Q - INDICATE NEXT CHAR ^Q-QUOTED.
	AOS	DGLCNT
	IDPB	T0,DGLPTR
	JRST	DGLIN0

; ^S - TURN ON TYPOUT, PASS IT BY.
DGLCTS:	SETOM	TYOFLG
	JRST	DGLIN1

;BREAK CHAR - INSERT AND EXIT.
DGLBK:	AOS	DGLCNT
	IDPB	T0,DGLPTR
	MOVE	T1,[440700,,DGLBUF]
	MOVEM	T1,DGLPTR	;SET UP PTR FOR UNPACKING.
	SETZM	DGLINF
DGLINX:	POP	P,T1
	RETURN

; ";" - ALL EXCEPT DIGITS, " ", "." ARE BREAK CHARS.
DGLSEM:	TLO	SF,DSEMFL
	JRST	DGLREG		;INSERT THE ";".


DGLSM1:	CAIN	T0,"-
	JRST	DGLREG
	CAIE	T0," 
	CAIN	T0,".
	JRST	DGLREG
	CAIL	T0,"0
	CAILE	T0,"9
	JRST	DGLIT3	;NON-DIGIT, IGNORE OR BREAK.
	JRST	DGLREG

DGLCOL:	SETOM	DGLINF		;":" - READ UNTIL CR.
	JRST	DGLREG

;COME HERE IF CHAR AFFECTED BY PREVIOUS ALTMODE.
DGLAL1:	CAIN	T0,"-
	JRST	DGLALT		;- SIGN DOESN'T END TYPEOUT MODE CMD.
	CAME	T0,ALTMOD
	JRST	DGLIT3
DGLALT:	SETOM	DGLALF
	JRST	DGLREG

;COME HERE TO HANDLE RUBOUT.
DGLRUB:	SOSGE	T1,DGLCNT	;NUM. CHARS NOT RUBBED.
	JRST	DERR		;IF NO CHAR TO RUB.
	MOVEM	T1,DGLRCT	;RE-READ THOSE CHARS.
	LDB	T0,DGLPTR
	TTOI	(T0)		;ECHO RUBBED CHAR.
	MOVE	T1,[440700,,DGLBUF]
	MOVEM	T1,DGLRBP	;PTR FOR RE-READING.
	MOVEM	T1,DGLPTR
	MOVE	T1,DGLINS	;RESTORE INITIAL DGLINF.
	MOVEM	T1,DGLINF
	JRST	DGLRB0

DGLNQC:	0		;NUM. OF NEXT CHARS TO QUOTE.
DGLRBP:	0		;B.P. FOR RE-READING AFTER RUBOUT.
DGLRCT:	0		;NUM. CHARS TO RE-READ.
DGLCNT:	0		;NUM. CHARS READ.
DGLPTR:	0		;B.P. FOR STORING CHARS READ.
DGLINF:	0		;IF SET, READ UNTIL CR.
DGLINS:	0		;SAVES INITIAL VALUE OF DGLINF.
DGLALF:	0		;SET AFTER ALTMODE.
DGCHRC:	0		;NONZERO IF FILINF AND LAST CHAR WAS CR.
DGLCQF:	0		;CONTROL Q FLAG

DGLBUF:	BLOCK	60	;RUBOUT PROCESSING AND I-O BUFFER.

;DDT ENTRY-SAVES ACS 1-16.
DDT:	POP	P,QA
	PUSH	P,QA
TXN[	SKIPE	DEBUGP
	 .VALUE	[ASCIZ*:SIM. PC.
QA/	       :VP *]
]
	PUSH	P,[DDTXIT]	;RTN TO CHANGE ACS AFTER RESTORATION.
	SETZM	DDONXT		; ;N STOPS AFTER THIS INSN.
DDT1:
TXN[	SKIPE	WNGDIS
	 PUSHJ	P,NGSIMD
]
	PUSHJ	P,MERRV		;TURN ON TTY OUTPUT.
	PUSHJ	P,SAVALL
	SETZM	RUN
	MOVEM	P,DDTPDP	;SAVE P FOR RESTORATION ON ERROR.
	LSH	PC,1
	HRRM	PC,R7
	HRRM	PC,%PC
	HRRZ	DL,OPC
	LSH	DL,1
	SKIPL	DL
	HRRM	DL,%OPC		;SET UNLESS HAVE JUST LEFT DDT.
	HRRZ	DL,JPC
	LSH	DL,1
	HRRM	DL,%JPC
	HRRM	PS,RPS
45Y[	MOVE	T5,45REGY	;STORE AWAY CURRENT REGISTER SET, SO BOTH SETS'
	MOVE	T6,T5		;VALUES LIVE IN THEIR BACKUP HOMES.
	BLT	T5,5(T6)
	LDB	T5,[45CMOD,,PS]	;GET CURRENT PROCESSOR MODE.
	MOVE	T6,R6
	HRRM	T6,45REG6(T5)	;STORE SELECTED R6 IN ITS BACKUP HOME.
	MOVEI	T5,4(T5)	;SET MODE OF OPENING IN DDT TO CURRENT PROCESSOR MODE.
	MOVE	T6,RSSR0	;PAGING OFF => SET UNMAPPED MODE.
	TRNN	T6,45BSGE
	 MOVEI	T5,6
	MOVEM	T5,OPNMD1
]
	MOVEM	TIME,RTIME
	HRLZ	SF,%TMODE
	SKIPE	DINITF
	JRST	DDT3		;DON'T PRINT INSN ON STARTING PDP11.
	HRRZ	DL,R7
	TLO	SF,NUMFND	;CAUSE . TO BE SET BY DARG.
45Y[	TTOI	@ALTMOD		;PRINT THE ADDRESS MODE THE NEXT INSTRUCTION IS IN
	MOVE	T5,OPNMD1
	TTOA	CTABTB(T5)
]
	CALL	DPINSN		;AND THEN PRINT THE PC AND THAT INSTRUCTION.
	HRRM	DLEN,%IL	;SAVE LENGTH, FOR ;N'S SAKE.
	HRROI	DO,(DO)		;DON'T ALLOW ACCIDENTAL CHANGES.
	TTOA	[ASCIZ/   /]
DDT2:
TXN[	SETZM	FILINF
	.CLOSE	UTIC,
	.RESET	TYIC,
]
DDT3:	SETZM	DINITF		;THAT FLAG SET 1ST TIME ONLY.
	SETOM	DGVLVL
	SETOM	QUITF
	JRST	DLOOP

;PUSHJ HERE, AND IT RETURNS WITH ACS 1-16 SAVED.
SAVLNG==16	;NUM LOCATIONS PUSHED
SAVALL:	EXCH	A,(P)		;SAVE REG. 1.
	PUSH	P,B
	MOVEI	B,1(P)		;SET UP BLT POINTER.
	HRLI	B,C
	ADD	P,[14,,14]	;POINT TO LAST PLACE TO PUSH TO.
	BLT	B,(P)
	JRST	(A)

;PASS SPACES.
GPASST:	GETCHR
PASSPS:	CAIN	T0," 
	JRST	GPASST
	RETURN

;COME HERE FOR NEXT COMMAND.
DLOOP:	TLZ	SF,DMODES	;RESTORE TEMPORARY MODES.
	TLO	SF,@%TMODE
	MOVE	T6,OPNMDT
	MOVEM	T6,OPNMD1
DLOOP1:	MOVE	T6,DL
	TLO	T6,.5KBIT
	MOVEM	T6,%Q		;SET %Q FROM DL, .5KILLED.
	HRRM	DLEN,%L		;SAVE LENGTH IN CASE ERROR.
DLOOP2:	CALL	DGVAL		;TRY TO GET A NUMERIC VALUE.
	SKIPN	DGVALP		;IF HAD ARG,
	JRST	DLOOP3
	SETZM	S%OLFL		;STOP UPDATING LENGTH OF WHAT'S OPEN
	TLO	SF,NUMFND	;TELL COMMAND ABOUT ARG
	SKIPA	DL,T2		;SET %Q TO ARG.
DLOOP3:	HRRZ	DLEN,%L		;ELSE RESTORE LENGTH.
	JSP	T1,DDECOD	;JUMP ACCORDING TO FIRST CHAR. AFTER NUM.
	"/,,CSLASH
	"[,,CLB
	"],,CRB
	^I,,CTAB
	^J,,CLF
	^K,,CCTLK
	^M,,CCR
	"^,,CUPAR
	"=,,CEQ
	";,,CSEM
	",,CALT
	"_,,CBACK
	">,,CGT
	":,,CCOL
	^N,,CCN
	^P,,CSP
	^L,,CFORMF
	^\,,CCBSL
	^],,CCRB
	" ,,DLOOP1
	DERR		;IF NOT FOUND.

;LOOK IN TABLE AT (T1) FOR ENTRY WITH LH=(T0),
;THEN JRST TO @RH OF ENTRY.
DDECOD:	CAIL	T0,"A+40	;CONVERT LOWER CASE TO UPPER CASE.
	 CAILE	T0,"Z+40
	  CAIA
	   SUBI	T0,40
DDECO1:	HLRZ	T5,(T1)		;LH, FOR COMPARISON.
	HRRZ	T6,(T1)		;RH FOR JUMP.
	CAIN	T0,(T5)		;FOUND ENTRY?
	JRST	(T6)		;YES, GO THERE.
	JUMPE	T5,(T6)		;IF LH IS 0, GO THERE ANYWAY(END OF TABLE).
	AOJA	T1,DDECO1	;TRY NEXT ENTRY.

;READ A CHAR, PASS SPACES, READ A VALUE.
DGVGCH:	GETCHR

;PASS SPACES AND READ IN A VALUE.
DGVPSP:	PUSHJ	P,PASSPS

;READ IN A VALUE WHOSE 1ST CHAR HAS BEEN READ ALREADY.
DGV1CH:	TLO	SF,D1CHAR

;GET A VALUE, AND PUT IT IN T2. SET NUMFND IF VALUE AVAILABLE.
;T0 CONTAINS CHAR. FOLLOWING VALUE, OR 1ST CHAR, AT EXIT.
;SETS T1 .
DGVAL:	SETZ	T1,		;START ON LEVEL 0.
	AOSE	DGVLVL		;IF OUTERMOST CALL TO DGVAL,
	JRST	.+4
	MOVE	T5,[004400,,DRNEXT]
	MOVEM	T5,DRNEXT	;SET UP B.P. FOR EXTRA WDS,
	MOVEI	DLEN,2		;INITIALIZE LENGTH.

	PUSH	P,DGVRGP	
	SETZM	DGVRGP		;AS YET, THIS VALUE ISN'T A REGISTER NUM.
	PUSH	P,[DGVXIT]
DGVAL0:	HLRZ	T1,T1		;PUT LEVEL IN RH.
	SETZM	DGVALP
	PUSHJ	P,DGVCAL	;TRY TO GET VALUE ON NEXT LEVEL.
	SKIPN	DGVALP		;IF CAN'T, RETURN NO VALUE.
	RETURN
DGVAL1:	HRRZ	T5,DGVT2(T1)	;ADDR. OF OP TABLE FOR THIS LEVEL.
	HRRZ	T6,(T5)		;SEARCH FOR ENTRY WITH RH=NEXT CHAR.
	CAIN	T0,(T6)
	JRST	DGVAL2		;FOUND.
	SKIPE	(T5)		;0 MARKS END OF TABLE.
	AOJA	T5,.-4		;TRY NEXT ENTRY.
	RETURN

DGVAL2:	HLL	T2,(T5)		;SAVE OPERATION TYPE NO.
	PUSH	P,T2		;AND LAST VALUE.
	CAIE	T0,"@		;"@" DOESN'T EVAL THE 2ND ARG.
	 PUSHJ	P,DGVCAL	;TRY TO GET VALUE ON NEXT LEVEL.
	REST	T5		;GET 1ST ARG, OP. NUM.
	HLRZ	T6,T5		;GET OP. NUM.
	SKIPE	DGVALP		;IF NO 2ND ARG,
	JRST	DGVAL3
	JUMPG	T6,DERR		;ERROR UNLESS OP. IS " ",
	HRRZ	T2,T5		;IN WHICH CASE RETURN 1ST ARG.
	RETURN
DGVAL3:	HRREI	T2,(T2)		;GOT 2ND ARG - EXTEND SIGNS OF ARGS,
	HRREI	T5,(T5)
	XCT	DGVT3(T6)	;PERFORM OPERATION.
	JRST	DGVAL1		;LOOK FOR ANOTHER OP.

DGVCAL:	PUSH	P,T1		;SAVE LEVEL NO.
	MOVE	T1,DGVT1(T1)	;GET NEXT LEVEL NO., ADDR. TO CALL.
	PUSHJ	P,(T1)		;GET VALUE ON NEXT LEVEL.
	POP	P,T1		;RESTORE LEVEL NO.
	RETURN

DGVT1:	1,,DGVAL0	;FROM LEVEL 0, CALL SELF ON LEVEL 1.
	2,,DGVAL0
	3,,DGVAL0
	4,,DGVAL0
	5,,DGTRM
	DGVAL		;DGTRM CALLS BACK ON LEVEL 3.

DGVT2:	DGVL0T		;LEVEL 0 OP. TABLE.
	DGVL1T		;LEVEL 1 OP. TABLE.
	DGVL2T
	DGVL3T
	DGVL4T
	DGVL5T

DGVL0T:	0,," 	;SPACE - LOW PRIOR. ADDITION.
	0
DGVL1T:	5,,"&	;LOGICAL OPS. LOWEST IN PRIOR.
	6,,"\
	8,,"#
	0
DGVL2T:	3,,"+
	4,,"-
	0
DGVL3T:	1,,"*	;MULT., DIV. SEPARATE TERMS.
	2,,"!
	0
DGVL4T:	9,,"@
	0
DGVL5T:	7,,",	;ANGLE-BRACKETS CONTAIN ORDINARY EXPRESSIONS
	0	;SEPARATED BY COMMAS.

DGVT3:	ADDM	T5,T2		;SPACE - MUST HAVE CODE 0.
	IMULI	T2,(T5)		;1ST INSNS OF OPERATIONS.
	IDIVM	T5,T2
	ADD	T2,T5
	SUBM	T5,T2
	ANDM	T5,T2
	IORM	T5,T2
	PUSHJ	P,DGVCOM
	XORM	T5,T2
	CALL	DGVMAP

DGVMAP:	SKIPE	DGVRGP
	 ERROR	[ASCIZ /REGISTER AS 1ST ARG OF @/]
	SETZ	T2,
	GETCHR
	SAVE	T5
	CALL	CALT3		;READ AND DECODE THE CHAR AFTER THE @.
	REST	T5
	LDB	T3,[12100,,T5]
	CALL	DCLOS3		;MAP THE ADDR.
	DPB	T3,[12100,,T5]
	MOVE	T2,T5
	SETZM	OPNMD1
	JRST	DGCHR

DGVCOM:	SKIPE	DGVLVL		;IF WITHIN INNER BRACKETS,
	JRST	DGVCO2		;THROW AWAY EXTRA WORD.
	CAILE	DLEN,10.	;CAN'T HAVE MORE THAN 5 EXTRA WDS.
	ERROR	[ASCIZ/> 6 WORDS/]
	IDPB	T2,DRNEXT	;2ND VALUE IS EXTRA WORD.
	MOVE	T2,T5
	AOJ	DLEN,
	AOJA	DLEN,CPOPJ

DGVCO2:	MOVE	T2,T5
	RETURN

DGVXIT:	SOS	DGVLVL
	HRLI	T2,.5KBIT	;SINCE MUST .5KILL %P.
	SKIPE	DGVRGP		;IF THIS IS TO BE A REGISTER NUM.,
	TLO	T2,REGBIT	;SAY SO IN THE VALUE.
	MOVEM	T2,%P
	POP	P,DGVRGP
	POPJ	P,		;NOT AN OP. FOR THIS LEVEL, RETURN.

;GET A TERM, INTO T2. CLEAR NUMFND IF CAN'T GET ONE, SET IF CAN.
DGTRM:	PUSHJ	P,DGNUM		;TRY TO GET NUMBER.
	SKIPE	DGVALP		;IF FOUND, RETURN IT.
	RETURN
	PUSHJ	P,DGSYM		;OTHERWISE, TRY TO GET SYMBOL.
	JUMPE	T2,DGTRM1	;IF NO SYMBOL, TRY OTHER THINGS.
	PUSHJ	P,DLKSYM	;LOOK UP SYMBOL.
	JUMPE	T5,[ERROR [ASCIZ/U/]]	;UNDEFINED.
	LDB	T2,[220400+T5,,1]
	JRST	@.+1(T2)	;INDEX ON SYMBOL TYPE.

	DGTRM2		;ORDINARY SYMBOL.
	DGVREG		;REGISTER SYMBOL.
	DR2AR		;2-OP INSN.
	DR2AR		;1-OP INSN.
	DRJSR		;JSR.
	DRJSR		;RTS.
	DRDBR		;BRANCH INSN.
	DREMT
	DRSFL
	DGTSER
	[ERROR [ASCIZ/U/]]
	DRSPEC		;SOB, MARK, SPL.
	DRASH		;MUL, DIV, ASH, ASHC.
	REPEAT 3,DGTSER

;JRST THRU STE TO HERE TO GET VALUE OF REGISTER SYMBOL.
DGVREG:	SETOM	DGVRGP

;JRST HERE FOR NORMMAL SYMBOL.
DGTRM2:	AOS	DGVALP
	HRRE	T2,1(T5)
	RETURN

DGTSER:	CRF
	6TYPE	(T5)
	MOVE	T5,1(T5)
	MOVEM	T5,QA
	ERROR	[ASCIZ/ HAS IMPOSSIBLE STE! - A/]

;COME HERE TO CHECK FOR UNARY +,-.
DGTRM1:	CAIE	T0,"-		;FOR MINUS SIGN,
	JRST	DGTRM3
	PUSHJ	P,DGTRM		;GET A TERM AND NEGATE IT.
	MOVN	T2,T2
	RETURN
DGTRM3:	CAIN	T0,"+		;FOR + SIGN, START OVER.
	JRST	DGTRM
	CAIE	T0,"'		;'''' MEANS ASCII CHAR INPUT.
	JRST	DGTRM4
	GETCHR
	MOVEI	T2,(T0)
DGTRM6:	GETCHR			;GET CHAR AFTER TERM.
DGVRET:	AOS	DGVALP
	RETURN

DGTRM4:	CAIE	T0,""		;2 ASCII CHARS INPUT.
	JRST	DGTRM5
	GETCHR
	MOVEI	T2,(T0)
	GETCHR
	LSH	T0,10		;2ND CCHAR INTO HIGH BYTE
	ADD	T2,T0
	JRST	DGTRM6
DGTRM5:	CAIE	T0,"<		;OPEN BRACKET?
	POPJ	P,		;NO, RETURN NO TERM.
	PUSHJ	P,DGVAL0	;TRY TO GET VALUE.
	CAIE	T0,">		;IF NOT CLOSED BY >, ERROR.
	ERROR	[ASCIZ/UNBAL/]
	GETCHR			;PASS BY >.
	RETURN

;CONVERT ARG TO RANGE OF ADDRS AND NUMBER.
;DEFAULTS ARE RANGE (AOBJN PTR IN T0): 0 - %CORE, NUMBER (IN T2): 0.
;IF 1 WD. IN ARG, IT SPECIFIES NUMBER.
;IF 2, THEY ARE RANGE,
;IF 3, 1ST 2 ARE RANGE, 3RD IS NUMBER.
DGRAN:	SETZB	T0,T2		;PUT IN DEFAULTS.
	HRRZ	T1,%CORE
	MOVEI	T1,-2(T1)
	TLNN	SF,NUMFND
	JRST	DGRAN1		;USE THEM IF NO ARG.
	CAIN	DLEN,2
	JRST	DGRAN2		;1 ARG ==> SET LOCATIONS TO IT.
	MOVEI	T0,(DL)		;>= 2 ARGS ==> FIRST 2 ARE RANGE.
	HRRZ	T1,DRNEXT+1
	CAIN	DLEN,6		;3RD ARG IS NUMBER TO STORE, IF PRESENT.
	HRRZ	T2,DRNEXT+2
	JRST	DGRAN1

DGRAN2:	MOVEI	T2,(DL)
DGRAN1:	ANDI	T0,MAXBYT-1
	LSH	T0,-1		;CHANGE ADDRS TO WORD NOS.
	LSH	T1,-1
	SUBM	T0,T1
	HRLI	T0,-1(T1)	;AOBJN PTR -> BLOCK TO STORE IN.
	TLO	T0,-MAXCOR
	ANDI	T2,177777
	RETURN

;READ A NUMBER INTO T2, PUT NEXT CHAR INTO T0.
;AT EXIT, NUMFND INDICATES NUMBER WAS THERE.
DGNUM:	SETZB	T2,DGVALP
	SETZ	T3,		;T2 ACCUMULATES OCTAL; T3, DECIMAL.
DGNUM1:	GETCHR
	SKIPN	DGLCQF		;^Q-QTD CHARS NOT DIGITS.
	CAIGE	T0,"0		;A DIGIT?
	JRST	DGNUM2		;IF NOT, CHECK FOR ".".
	CAILE	T0,"9
	JRST	DGNUM2
	AOS	DGVALP		;FOUND A NUMBER.
	LSH	T2,3		;PUT THIS DIGIT IN.
	ADDI	T2,-"0(T0)
	IMULI	T3,10.		;PUT IT IN DECIMAL NUM, TOO.
	ADDI	T3,-"0(T0)
	JRST	DGNUM1		;TRY FOR ANOTHER DIGIT.

DGNUM2:	SKIPE	DGVALP		;IF HAD A NUMBER,
	CAIE	T0,".		;FOLLOWED BY ".",
	JRST	DGNUM3
	MOVEI	T2,(T3)		;USE DEC NUM, NOT OCT NUM.
	GETCHR
DGNUM3:	HRREI	T2,(T2)
	RETURN

;OPEN REGISTER WHOSE ADDR. IS IN DL.
DARG:	MOVE	DO,DL
	TLZ	DO,.5KBIT	;INSURE DO POSITIVE SINCE HAVE OPEN LOC.
	MOVE	T6,DO
	TLO	T6,.5KBIT
	MOVEM	T6,DOPEN	;SET SYMBOL %.  .
	TLZE	SF,NUMFND	;IF ADDR WAS ARG,
	MOVEM	T6,DPNT		;ALSO SET SYMBOL .  .
	MOVE	T6,OPNMD1
	MOVEM	T6,OPNMDL
	MOVEI	DLEN,2		;ASSUME LENGTH IS 2 UNLESS PROVED LONGER.
	HRRM	DLEN,%OL
	PUSHJ	P,DCLOS0	;T3 _ CORE ADDR OF LOC., -PDP11.
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPR
	HRRZ	DL,PDP11(T3)	;GET WORD FROM OPEN REG.
	TLZ	SF,BYTOPN
	TLNE	DO,REGBIT	;REGISTERS NEVER BYTES.
	RETURN
	TRNN	DO,1		;IF ADDR ODD,
	TLNE	SF,DBYTM	;OR IN BYTE MODE,
	TLOA	SF,BYTOPN	;OPEN AS A BYTE,
	RETURN
	TRNE	DO,1
	LSH	DL,-10
	ANDI	DL,377		;RETURN ONLY THE DESIRED BYTE.
	RETURN

;COME HERE ON ERROR.
DERR:
TXN	CALL OSNAMR		;RESTORE OLD SNAME IF DESIRED.
	SETOM	DGVLVL		;IN CASE ERRED WITHIN DGVAL.
	CALL	MERRV		;TURN ON TTY OUTPUT.
TXN[	.CLOSE	UTIC,
	SETZM	FILINF
	.CLOSE	LOADCH,
]
	TTOA	[ASCIZ/ ?  /]
	MOVE	P,DDTPDP	;RESET STACK.
TXN	.RESET	TYIC,
TXY[	PUSH	P,A
	MOVEI	A,.PRIIN
	CFIBF
	POP	P,A]
	SETZM	XREGTF
	SETZM	DGLINF
	SETZM	DGLCNT
	HRRZ	DL,%Q		;DON'T CLOBBER DL WITH ERROR.
	HRRZ	DLEN,%L
	TLZ	SF,D1CHAR+NUMFND+CSSFLG+DSEMFL
	JRST	DLOOP1

TXN[
;READ A FILESPEC, PUT NAMES IN OPEN BLOCK <- A.
DGFIL:	SETZM	FILFLG
	SETZ	T3,
	SETOM	DGLINF		;INDICATE READING FILENAME.
DGFIL0:	SETZ	T2,
	MOVE	D,[440600,,T2]
DGFIL1:	GETCHR
	SKIPE	DGLCQF		;^Q-QUOTED CHARS TREATED AS ORDINARY.
	JRST	DGFIL2
	JSP	T1,DDECOD
	";,,DGFILS
	":,,DGFILC
	" ,,DGFILN
	^M,,DGFILN
	",,,DGFILN
	  ,,DGFIL2		;ORDINARY CHAR.

DGFIL2:	MOVEI	T0,-40(T0)	;CONV. TO SIXBIT.
	TRNN	D,1		;UNLESS HAVE OVERFLOWED INTO T3,
	IDPB	T0,D		;STORE NEXT CHAR.
	JRST	DGFIL1

;COME HERE WHEN SPACE OR CR TERMINATES NAME.
DGFILN:	JUMPE	T2,DGFILM	;DO NOTHING IF NO NAME.
	XCT	DGFILT(T3)	;STORE NAME PROPERLY.
	AOJ	T3,		;SUCCESSIVE NAMES ARE FN1, FN2, DEV, SNAME.
DGFILX:	SETOM	FILFLG
DGFILM:	CAIE	T0,^M
	CAIN	T0,",		;^M AND ", TERMINATE FILSPC.
	SKIPA
	JRST	DGFIL0		;AFTER SPACE, TRY AGAIN.
	SETZM	DGLINF
OSNAMR:	.SUSET [.RSNAM,,NSNAM] ;SAVE DEFAULT SNAME OR SPEC'D.
	.SUSET [.SSNAM,,OSNAM] ;IF NOT SPEC'D, RESTORE CURRENT.
	SETZM OSNAM	;NO LONGER NEED TO RESTORE.
	RET

DGFILT:	MOVEM	T2,1(A)		;STORE FN1.
	MOVEM	T2,2(A)		;FN2.
	HLRM	T2,(A)		;STORE DEV.
DGFILS:	CALL [	.SUSET	[.SSNAM,,T2]	;STORE SNAME.(DOES NOTHING IF T2 ZERO)
		SETZM OSNAM	;DON'T RESTORE SNAME LATER.
		RET]
	JRST	DGFILX

DGFILC:	JUMPE	T2,DGFILX
	HLRM	T2,(A)		;COLON: ALWAYS STORE AS DEVICE.
	JRST	DGFILX

FILFLG:	0	;SETOM'ED IF A "FILSPEC" ACTUALLY TYPED
	;(DESIGNED SO CAN BE FAKED OUT BY : OR ; WITHOUT NAME)
OSNAM:	0	;NONZERO => RESTORE SNAME ON ERROR OR RETURN FROM DGFIL.
NSNAM:	0	;SNAME BEFORE RETURN FROM DGFIL AND RESTORE OSNAM.
]

;READ IN A SYMBOL, IF POSSIBLE.
;T2 GETS NAME IN SIXBIT IF SYMBOL, 0 OTHERWISE.
;ASSUMES 1ST CHAR IN T0. LEAVES FOLLOWING CHAR THERE.
DGSYM:	TDZA	T2,T2		;NO CHARS YET. DON'T READ 1ST CHAR.
	GETCHR
	SKIPE	DGLCQF		;IF ^Q-QUOTED,
	MOVEI	T5,-40(T0)	;ALWAYS USE IT.
	SKIPN	DGLCQF		;ELSE USE ONLY SQUOZE CHARS.
	CALL	D7TO6
DGSYM1:	TLNE	T2,770000	;IF NOT FULL,
	JRST	DGSYM2
	LSH	T2,6		;PUT IN THIS CHAR(OR BLANK).
	ADDI	T2,(T5)
	JUMPE	T2,CPOPJ	;IF NO SYMBOL, RETURN.
	JUMPE	T5,DGSYM1	;IF NOT SYMBOL CHAR, LEFT-JUSTIFY.
DGSYM2:	JUMPN	T5,DGSYM+1	;KEEP READING CHARS PAST END OF SYMBOL.
	RETURN

;LOOK UP THE SYMBOL WHOSE SIXBIT IS IN T2.
;RETURNS IN T5 PTR TO STE (0 IF NONE).
DLKSYM:	MOVE	T6,SYMEND
TXN	MOVNI	T5,2-SYMTAB(T6)	;2*NUMBER OF SYMBOLS.
TXY[	MOVEI	T5,SYMTAB
	SUBI	T5,2(T6)
]
DLKSY0:	LSH	T5,17.		;LH_ - NUM.SYMS.
	HRRI	T5,3(T6)	;RH _ LAST SYM + 3.
	MOVSI	C,DLKSY1
	BLT	C,C		;PUT LOOP IN ACS 0-3.
	CALL
	CAME	T2,(T5)		;IF NOT FOUND, RETURN 0.
	SETZ	T5,
	RETURN

DLKSY1:	SUBI	T5,3		;MOVE TO PREV. STE.
	CAME	T2,(T5)		;IF NOT FOUND & MORE STE'S
	AOBJN	T5,		;GO LOOK AT THEM.
	RETURN

;CONVERT AN ASCII CHAR TO SIXBIT, IF IT CAN GO IN A SYMBOL.
;IF IT CAN'T GO IN ONE, RETURN 0 (IN T5). ARG IN T0.
D7TO6:	SETZ	T5,
	CAIL	T0,"A+40
	 CAILE	T0,"Z+40	;LOWER CASE LETTERS OK
	  CAIA
	   JRST [MOVEI T5,-100(T0)
		 RETURN]
	CAILE	T0,"Z
	RETURN
	CAIL	T0,"A
	JRST	D7TO6X		;ALPHABETIC CHARS O.K.
	CAILE	T0,"9
	RETURN
	CAIGE	T0,"0
	CAIN	T0,".		;DIGITS AND ".", TOO.
	JRST	D7TO6X
	CAIL	T0,"&
	RETURN
	CAIL	T0,"$		;ALSO "%", "$".
D7TO6X:	MOVEI	T5,-40(T0)
	RETURN

;DEFINE THE FOLLOWING SYMBOL
CGT:	TLZ	SF,NUMFND
	CALL	GPASST
	PUSHJ	P,DGSYM		;TRY GETTING SYMBOL, ERROR IF NONE.
	JUMPE	T2,DERR
	MOVEI	T6,SYMDMP
TXN	MOVNI	T5,2-SYMTAB(T6)	;SEARCH UNSETTABLES, SYMTAB THRU SYMDMP-2 .
TXY[	MOVEI	T5,SYMTAB
	SUBI	T5,(T6)
]
	CALL	DLKSY0
	SKIPE	T5
	ERROR	[ASCIZ/UNSETTABLE SYMBOL/]	;IF FOUND THERE.
	CALL	DEFSYM		;GET OLD STE OR MAKE NEW ONE.
	CALL	PASSPS		;GET 1ST NONBLANK CHAR.
	TLZ	DL,.5KBIT
	CAIE	T0,^K
	TLOA	SF,D1CHAR	;IF NOT ^K, REREAD IT.
	TLO	DL,.5KBIT	;IF ^K, .5KILL THE SYMBOL.
	MOVEM	DL,1(T5)	;STORE VALUE, FLAGS.
	JRST	DLOOP

; ^K COMMAND - COMPLEMENT .5KILL BIT FOR FOLLOWING SYMBOL.
CCTLK:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM
	JUMPE	T2,DNOARG
	PUSHJ	P,DLKSYM
	JUMPE	T5,DLOOP	;IF UNDEFINED, NO-OP.
	MOVSI	T6,400000	;COMPLEMENT HALF-KILL FLAG.
	XORM	T6,1(T5)
	TLZ	SF,NUMFND
	TLO	SF,D1CHAR
	JRST	DLOOP

;COME HERE TO LOOK FOR OLD STE, MAKE NEW ONE & STORE NAME IF NOT FOUND.
;NAME TAKEN IN T2, STE ADDR RET. IN T5.
DEFSYM:	MOVE	T6,SYMEND	;SEARCH SETTABLE SYMBOLS,
TXN	MOVNI	T5,2-SYMDMP(T6)	;SYMDMP AND UPWARD.
TXY[	MOVEI	T5,SYMTAB
	SUBI	T5,2(T6)
]
	CALL	DLKSY0
	JUMPN	T5,CPOPJ	;IF DEFINED, RETURN OLD STE.

;COME HERE IF UNDEFINED.
DEFSY0:	HRRZ	T5,SYMEND
	MOVEI	T5,2(T5)	;ADDR OF NEXT STE,
	TRNE	T5,1777		;IF OVERFLOW TO NEW PAGE
	JRST	DEFSY1
	PUSHJ	P,BLKGET	;ADD A PAGE
	(T5)
DEFSY1:	HRRZM	T5,SYMEND	;IT'S NOW LAST STE.
	MOVEM	T2,(T5)		;PUT IN NAME.
	RETURN

SYMNSP==7	;# PREDEF SETTABLE SYMS.
;DEFINE SYMBOL DURING LOADING.
DEFSY2:	SKIPN	CSLFLG		;IF NOT DOING ;L,
	JRST	DEFSYM		;MAYBE WAS DEFINED BEFORE THIS CMD.
REPEAT SYMNSP,[
	CAMN	T2,SYMDMP+2*.RPCNT
	JSP	T5,DEFSY3	;TEST FOR PREDEFINED SETTABLE SYM.
]	JRST	DEFSY0		;NOT PREDEF, MUST BE UNDEF.

DEFSY3:	MOVEI	T5,SYMDMP-DEFSY2-4(T5)
	RETURN			;T5 HAS ADDR OF PREDEF STE.

;READ IN A GENERALIZED OPERAND ADDRESS.
;PUT 6-BIT ADDRESS MODE IN T2.
;RETURN NEW VALUE OF %S OR %D IN T3 .
;IF INDEXED, RELATIVE OR IMMEDIATE, UPDATE DLEN, STORE EXTRA WORD.
DRADDR:	PUSHJ	P,PASSPS
	PUSH	P,DRINDP
	SETZM	DRINDP
	CAIE	T0,"@		;INDIRECT MODE?
	JRST	.+3
	AOS	DRINDP		;YES, REMEMBER IT AND PASS @ SIGN.
	GETCHR
	JSP	T1,DDECOD	;DECODE 1ST CHAR.
	"#,,DRIMM		;IMMEDIATE MODE.
	"-,,DRDEC		;AUTODECREMENT OR UNARY -.
	"(,,DRPAR		;REGISTER INDIRECT OR AUTOINCREMENT.
	DRADD			;REGISTER, RELATIVE OR INDEXED.

DRADD:	PUSHJ	P,DGV1CH	;GET ADDRESS, 1ST CHAR READ ALREADY.
	SKIPN	DGVALP		;IF NONE, BAD FORMAT
	JRST	DERR
DRADD0:	MOVE	T3,T2
	CAIN	T0,"(		;INDEXED?
	JRST	DRNDX		;YES.
	TLZE	T2,REGBIT	;ADDR. IS A REGISTER?
	JRST	DRREG		;YES.
	SUBI	T2,(DO)		;CALCULATE DISPLACEMENT.
	SUBI	T2,2(DLEN)
	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	MOVEI	T2,67		;RELATIVE ADDRESS, MODE 67.
DRXIT:	SKIPE	DRINDP		;IF READ "@",
	IORI	T2,10		;CHANGE MODE TO INDIRECT.
	TLO	T3,.5KBIT	;%S, %D SHOULD ALWAYS BE .5KILLED.
	POP	P,DRINDP
	RETURN

DRNDX:	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	PUSH	P,T3		;SET %D TO DISPL., NOT REG.
	PUSHJ	P,DRPAR1	;GET REGISTER NO.
	POP	P,T3
	ADDI	T2,60		;MODE 6N, N=REGISTER NUM.
	JRST	DRXIT

DRREG:	ANDI	T2,7		;REGISTER ADDRESS, MODE 0N, N=REGISTER NO.
	JRST	DRXIT

;IMMEDIATE MODE - COME HERE IF FIND #.
DRIMM:	PUSHJ	P,DGVGCH	;GET IMMED. OPERAND.
	SKIPN	DGVALP		;MUST BE ONE.
	JRST	DERR
	MOVEI	T3,(T2)
	PUSHJ	P,DGVCOM	;STORE EXTRA WORD.
	MOVEI	T2,27		;RETURN (PC)+ MODE.
	JRST	DRXIT

;COME HERE IF READ ( - MUST BE (REG) OR (REG)+.
DRPAR:	PUSHJ	P,DRPAR1	;GET REG. NO.
	CAIE	T0,"+		;CLOSE-PAR. FOLLOWED BY +?
	JRST	DRPAR2		;NO, (R) OR @(R) .
	GETCHR			;YES, SKIP PAST +.
	ADDI	T2,20		;AUTOINCREMENT IS MODE 2.
	JRST	DRXIT

;COME HERE IF (R) OR @(R), AFTER READING ALL.
DRPAR2:	ADDI	T2,10		;SET UP IN CASE MODE 1.
	SKIPN	DRINDP
	JRST	DRXIT		;IF MODE 1.
	MOVEI	T5,60(T2)	;ELSE MODE 7,
	SETZ	T2,
	PUSHJ	P,DGVCOM	;STORE ZERO AS EXTRA WD.
	JRST	DRXIT		;DGVCOM DID T2_T5.

;AFTER READING A (, READ IN REGISTER NO., CHECK VALIDITY,
;CHECK FOR ), AND SKIP OVER IT.
DRPAR1:	PUSHJ	P,DGVGCH	;READ THE NO.
	CAIN	T0,")		;IF NOT FOLLOWED BY ), ERROR.
	SKIPN	DGVALP		;IF NO NUMBER, ERROR.
	JRST	DERR
	MOVEI	T3,(T2)
	TLO	T3,REGBIT
	MOVEI	T2,(T2)		;REMOVE REGISTER VS. CORE INDICATOR.
	CAILE	T2,7		;IF NOT <= 7,
	JRST	DERR		;NOT REGISTER NUMBER, ERROR.
	GETCHR			;READ PAST ).
	RETURN

;COME HERE AFTER READING - SIGN -- MIGHT BE AUTODECREMENT,
;MIGHT BE UNARY MINUS ON ADDRESS.
DRDEC:	TLO	SF,D1CHAR	;TELL DGVAL 1ST CHAR ALREADY READ.
	PUSHJ	P,DGVAL		;IT WILL USE THE - AS A UNARY, IF IT CAN.
	SKIPE	DGVALP		;IF IT CAN'T,
	JRST	DRADD0		;TREAT AS IF GOT ADDR RIGHT AWAY.
	CAIE	T0,"(		;OTHERWISE, SEE IF VALID AUTODECREMENT.
	JRST	DERR		;IF NO (.
	PUSHJ	P,DRPAR1	;GET REGISTER NO.
	ADDI	T2,40		;MODE 4.
	JRST	DRXIT

DRNEXT:	0?0?0?0?0?0
DRINDP:	0		;IF NONZERO, THIS ADDR WAS PRECEDED BY "@".

;READ IN A STANDARD 1 OR 2 OPERAND INSN.
;COME HERE WITH T5-> STE, WHOSE 2ND WORD HAS OP CODE.
;BIT 17 OF 1(T5) IS ZERO IF 2-OPERAND INSN, 1 IF 1 OPERAND.
DR2AR:	PUSHJ	P,DRINSP
	PUSHJ	P,DRADDR	;GET 1ST ADDRESS.
DR2AR0:	LSH	I1,6		;PUT IN WITH OP CODE.
DR2AR2:	JUMPL	I1,DR2AR1	;IF 1 OPERAND INSN.
	MOVEM	T3,%S		;SINCE MUST BE 2-OP, SET %S.
	ADDI	I1,(T2)
	CAIN	T0,",		;SKIP OVER A COMMA.
	GETCHR
	PUSHJ	P,DRADDR	;GET DESTINATION ADDRESS.
	LSH	I1,6		;PUT IN INSN.
DR2AR1:	MOVEM	T3,%D
	ADDI	T2,(I1)
	POP	P,I1
	AOS	DGVALP
	JRST	DGNUM3		;EXTEND SIGN.

;READ IN THE ADDR OF A BRANCH, MAKE THE INSN.
DRDBR:	PUSHJ	P,DRINSP	;SAVE REGS, ETC.
	SETOM	DRDBRF		;INDICATE BRANCH INSN. RATHER THAN SOB .
DRDBR1:	PUSHJ	P,DGVPSP	;PASS SPACES, READ IN NUMBER.
	MOVEI	T3,(T2)		;PREPARE TO SET %D .
	SKIPN	DGVALP
	ERROR	[ASCIZ/WHITHER/]	;IF NO ADDR.
	TLNE	T2,REGBIT	;CAN'T BRANCH INTO REGISTER.
	ERROR	[ASCIZ/TO ACCUM./]
	TRNE	T2,1		;ERROR IF ODD ADDR.
	ERROR	[ASCIZ/ODD ADDR/]
	SUBI	T2,2(DO)	;COMPUTE OFFSET.
	LSH	T2,-1		;AS NUMBER OF WORDS.
	SKIPN	DRDBRF		;ONLY 6 BITS FOR SOB.
	 JRST	DRSOB1
	TRCN	T2,377600	;SEE IF IN RANGE.
	JRST	DRDBR9
	TRNE	T2,377600
DRSOB2:	ERROR	[ASCIZ/ADDR. OUT OF RANGE/]
DRDBR9:	XORI	T2,377600	;SET TOP BITS TO WHAT THEY WERE.
DRDBR2:	ANDI	T2,377		;GET LOW BYTE.
DREMT2:	TLO	T3,.5KBIT
	JRST	DR2AR1

DRSOB1:	MOVNS	T2	;IN SOB, OFFSET IS SUBTRACTED (ADDED FOR BRANCHES)
	TRNE	T2,777700
	 JRST	DRSOB2	;TOO LARGE OR FORWARD.
	JRST	DREMT2

;HANDLE JSR, RTS.
DRJSR:	PUSHJ	P,DRINSP
	PUSHJ	P,DRJSR1	;READ REG. NUM.
	JRST	DR2AR2

DRJSR1:	PUSHJ	P,DGVPSP	;GET REGISTER NO.
	MOVEI	T2,(T2)
	SKIPE	DGVALP		;IF NO NUMBER,
	CAILE	T2,7		;OR OUT OF RANGE,
	JRST	DERR		;(>7), ERROR.
	LSH	I1,3		;MAKE ROOM FOR REG. NUM.
	MOVEI	T3,(T2)		;PREPARE TO SET %S OR %D
	TLO	T3,REGBIT+.5KBIT	;TO A REG. NUM.
	RETURN

DRASH:	CALL	DRINSP
	CALL	DRADDR		;READ SRC (GOES IN LOW 6 BITS)
	MOVEM	T3,%S
	LSH	I1,11		;MAKE ROOM FOR LOW 6 BITS.
	ADDI	I1,(T2)
	CAIN	T0,",
	 GETCHR			;PASS COMMA.
	CALL	DRJSR1		;READ DEST (REGISTER #)
	LSH	I1,-3		;UNDO SHIFT DONE BY DRJSR.
	LSH	T2,6		;REG # READ GOES BEFORE SRC.
	JRST	DR2AR1

DRSPEC:	PUSHJ	P,DRINSP
	JRST	@.+1(I1)	;OP-CODE SAYS TYPE OF INSN.
	DRSOB
	DRMARK
	DRSPL

DRSOB:	PUSHJ	P,DRJSR1	;READ REG. NUM.
	MOVEI	I1,770(T2)	;SET UP OP-CODE FOR FUNNY BRANCH.
	LSH	I1,6
	CAIN	T0,",
	GETCHR
	SETZM	DRDBRF		;INDICATE ONLY 6 BITS FOR OFFSET.
	JRST	DRDBR1

DRMARK:	MOVEI	I1,6400
	PUSHJ	P,DGVPSP
	CAIL	T2,100
	JRST	DERR		;WON'T FIT IN 6 BITS.
	JRST	DREMT1

DRSPL:	PUSHJ	P,DGVPSP
	MOVEI	I1,230		;OP-CODE.
	CAILE	T2,7
	JRST	DERR		;IF NOT NUM. OF REG.
	TLZ	T2,REGBIT
	JRST	DREMT1

;READ IN THE CODE FOR EMT OR TRAP, MAKE INSN.
DREMT:	PUSHJ	P,DRINSP
	PUSHJ	P,DGVPSP	;GET EMT OR TRAP CODE.
DREMT1:	TLNN	T2,REGBIT	;IF REGISTER NO.,
	SKIPN	DGVALP		;OR NO NO.,
	JRST	DERR		;ERROR.
	CAILE	T2,400		;MUST FIT IN BYTE.
	JRST	DERR
	JRST	DREMT2

;READ IN A CFL OR SFL INSN.
DRSFL:	PUSHJ	P,DRINSP
	PUSHJ	P,DGVPSP	;TRY TO GET NUMBER.
	SKIPN	DGVALP
	JRST	DRSFL1		;IF CAN'T, MIGHT BE SPECIAL FMT.
	TLNN	T2,REGBIT	;IF REGISTER NO.,
	CAILE	T2,17		;OR OUT OF RANGE, ERROR.
	JRST	DERR
	JRST	DR2AR1		;COMBINE NO. AND OP-CODE.
DRSFL1:	CAIE	T0,"@		;SPECIAL FMT. STARTED BY @.
	JRST	DERR
	SETZ	T2,		;INITIALLY, NO FLAGS TO BE SET OR CLEARED.
DRSFL0:	GETCHR
	SETZ	T6,
IRPC X,,ZNVC
	CAIN	T0,"X
	MOVEI	T6,X!F
TERMIN
	JUMPE	T6,DR2AR1	;IF NOT PART OF INSN, FINISH.
	IORI	T2,(T6)		;INSN WILL SET SPECIFIED FLAG.
	JRST	DRSFL0

;INITIALIZATION FOR INSN READIN RTNS.
DRINSP:	EXCH	I1,(P)
	PUSH	P,I1
	MOVE	I1,1(T5)
	TLO	I1,777776	;MAKE LH. SAME AS BIT 17.
	TLNN	I1,1
	TLZ	I1,-1
	RETURN

;CLOSE THE OPEN REGISTER, IF ANY, STORING CHANGES, IF ANY.
DCLOSE:	MOVE	T5,OPNMDL	;MUST STORE  CHANGES
	MOVEM	T5,OPNMD1	;IN SAME SPACE  LOC. WAS OPENED IN.
DCLOSB:	JUMPL	DO,CPOPJ	;NOTHING OPEN.
	TLZN	SF,NUMFND	;CHANGES MADE?
	RETURN
	HRRM	DLEN,%OL	;LENGTH OF OPENED STUFF_LENGTH OF NEW STUFF.
	SETZM	S%OLFL
	PUSHJ	P,DCLOS0	;T3_CORE ADDR. OF LOC., -PDP11 .
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPW
	TLNE	SF,BYTOPN	;IF WAS OPENED AS BYTE,
	JRST	DCLOS1		;STORE A BYTE.
	DPB	DL,[2000+T3,,PDP11]	;OTHERWISE STORE WORD.
	MOVN	T1,DLEN
	LSH	T1,17.
	HRRI	T1,DRNEXT	;AOBJN -> WORDS TO STORE.
DCLOSA:	AOBJP	T1,DCLOST	;ANY MORE TO BE STORED?
	LDB	T3,[12100,,DO]
TXN	ADDI	T3,-DRNEXT(T1)	;YES, GET ADDR TO STORE IT IN,
TXY[	SUBI	T3,DRNEXT
	ADDI	T3,(T1)
]
	CALL	DCLOS3		;MAP IT,
	MOVE	T5,(T1)		;GET THE WD TO BE STORED.
	ANDI	T5,177777
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPW
	HRRM	T5,PDP11(T3)
	JRST	DCLOSA

;COME HERE TO STORE CHANGES IN A BYTE.
DCLOS1:	TRNN	DO,1
	DPB	DL,[001000+T3,,PDP11]	;IF EVEN BYTE.
	TRNE	DO,1
	DPB	DL,[101000+T3,,PDP11]	;IF ODD BYTE.
DCLOST:	MOVSI	A,6		;IN CASE WE DEPOSITED IN A DEVICE REGISTER,
	CAMLE	A,@TRINF+1
	 RET
	MOVE	B,TRINF+1	;PROCEDE THE DEV REG RTN FROM ANY XXWAIT.
	MOVE	A,1(B)
	SETOM	1(B)
	MOVEM	A,TRINF+1
	SAVE	SF
	SAVE	DO
	SAVE	DL
	SAVE	DLEN
	XCT	2(B)
	REST	DLEN
	REST	DL
	REST	DO
	REST	SF
	JRST	DCLOST

;MAPPING MEANS FINDING THE ADDR (RELATIVE TO PDP11) IN MEMORY
;OF THE WORD CORRESPONDING TO A SPEC'D ADDRESS.
;THE MAPPING PROCESS DEPENDS ON THE MODE IN USE -
; $0, $2, $4, $6, $KI, $SI, $A, $UI, $KD, $SD, <MISSING>, $UD
;ARE THE MODES, IN ORDER. THE MODE TO BE USED IS IN OPNMD1.

;MAP UNSHIFTED ADDR IN DO. IT MAY BE AN ACCUMULATOR.
DCLOS0:	TLNE	DO,REGBIT
	 JRST DCLREG
	LDB	T3,[12100,,DO]	;GET ADDR, SHIFT RIGHT 1.

;MAP THE SHIFTED ADDR IN T3, KNOWN NOT TO BE AN ACCUMULATOR.
DCLOS3:	45N	ANDI	T3,MAXCOR-1
	MOVE	T6,OPNMD1
	XCT	DCLOS2(T6)	;MAP THE ADDR IF DESIRED.
	RETURN

DCLOS2:	JFCL		;MODE 0 - NO CHANGE
	ADDI	T3,100000	;MODES 1,2,3 SELECT THAT 1/4 OF CORE.
	ADDI	T3,200000
	ADDI	T3,300000
	CALL	DCLOM		;MODE 4 - KERNEL I-SPACE MAPPING.
	CALL	DCLOM		;MODE 5 - SUPERV. I-SPACE MAPPING.
	CALL [	ANDI T3,77777
		45Y[ CAIL T3,70000	;MODE 6 - MAP AS IF PAGING IS OFF.
		 ADDI T3,300000]
		RET]
	CALL	DCLOM		;MODE 7 - USER I-SPACE MAPPING.
	CALL	DCLOM		;MODE 10 - KERNEL D-SPACE.
	CALL	DCLOM		;MODE 11 - SUPERV. D-SPACE.
	.VALUE
	CALL	DCLOM		;MODE 13 - USER D-SPACE.

DCLOM:	;MAP ADDR IN T3 USING PROCESSOR MODE IN T6.
45Y[	SAVE	D
	SAVE	MA
	MOVE	MA,T3
	ANDI	MA,77777
;THE NEXT 3 INSNS ARE A 45IRMA OR A 45DRMA, IN WHICHEVER MODE.
	LDB	D,[SEGBP,,MA]
	XCT	@(T6)[	45IRK1(D)
			45IRS1(D)
			[.VALUE]
			45IRU1(D)
			45DRK1(D)
			45DRS1(D)
			[.VALUE]
			45DRU1(D)]-4
	XCT	@(T6)[	45IRK2(D)
			45IRS2(D)
			[.VALUE]
			45IRU2(D)
			45DRK2(D)
			45DRS2(D)
			[.VALUE]
			45DRU2(D)]-4
	 ERROR	[ASCIZ/SEGLEN/]
	MOVE	T3,MA
	REST	MA
	REST	D
]
	RET

;HERE TO MAP THE ADDRESS OF AN ACCUMULATOR.
DCLREG:	MOVEI T3,(DO)
45N[	MOVEI T3,R0-PDP11(T3)
	RET
]
45Y[
	MOVEI T0,(T3)
	CAIN T0,7	;REGISTER 7 IS ALWAYS IN R7
	 JRST [	MOVEI T3,R7-PDP11
		RET]
	CAIE T0,6	;REGISTER 6 DEPENDS ON PROCESSOR MODE.
	 JRST DCLR0
	MOVE T6,45MODE	;SO GET CURRENT PROCESSOR MODE, PERHAPS OVERRIDEN
	MOVE T0,OPNMD1	;BY CURRENT OPEN MODE.
	XCT (T0)[	REPEAT 4,JFCL	;UNMAPPED MODES
		REPEAT 2,[
			MOVEI T6,0	;KI AND KD MODES
			MOVEI T6,1	;SI AND SD MODES
			MOVEI T6,0	;A MODE AND IMPOSSIBLE MODE
			MOVEI T6,3	;UI AND UD MODES
		]]
	MOVEI T3,45REG6-PDP11(T6)
	RET		;RETURN THE ADDRESS (REL PDP11) OF THAT COPY OF R6.

DCLR0:	HRRZ T3,45REGY	;R0 THRU R5.  NORMALLY, USE THE SELECTED REGISTER SET,
	MOVE T6,OPNMD1	;BUT IN OPEN MODE $3,
	CAIN T6,3
	 HRRZ T3,45REGN	;USE THE OTHER REGISTER SET
	ADD T3,T0
	MOVEI T3,-PDP11(T3)
	RET
]

;LEFT BRACKET - PRINT AS NUMBER (POSSIBLY SYMBOLIC, ETC.)
CLB:	TLZ	SF,DEXCM+DINSM	;PRINT AS SYMBOL.
	JRST	CSLASH

;BACKARROW - REOPEN IN CURRENT MODE.
CBACK:	TLZ	SF,NUMFND
	MOVE	DL,DO

;SLASH
CSLASH:	CALL	DPRINT
	JRST	DLOOPT

;SUBROUTINE TO PRINT AS INSN.
DPINSN:	ADRTYP	DL		;PRINT ADDR BEING OPENED,
	TTOI	"/
	TLO	SF,DINSM
	TLZ	SF,DEXCM+DBYTM

;SUBROUTINE, OPEN DL AND PRINT IN CURRENT MODE.
DPRINT:	CALL	DARG		;OPEN LOC ADDRESSED BY DL. SET UP NEW DL, T3.
	SETOM	S%OLFL
	TLNE	SF,DEXCM
	RETURN			;DON'T PRINT IF ! MODE.
	TTOA	[ASCIZ/  /]
	TLNN	DO,REGBIT	;CONTENTS OF REGISTER NOT AN INSN.
	TLNE	SF,BYTOPN	;CAN'T CONSIDER A BYTE AN INSN.
	JRST	DLB1
	MOVE	I1,OPNMDL
	CAIL	I1,10		;OPENING A DATA SPACE =>
	 JRST	DLB1		;DON'T PRINT AS INSN.
	LDB	I1,[221100+T3,,PDP11]
	CAIE	I1,NCPAT		;IF LOC. IS A PATCH DEVICE,
	JRST	DLB0
	ADRTYP	DL		;PRINT DEST. OF PATCH.
	HRLI	DL,.5KBIT
	MOVEM	DL,%D		;SET %D.
	RETURN

DLB0:	TLNE	SF,DINSM
	JRST	DRB		;IF I MODE, PRINT AS INSN.
DLB1:	SYMTYP	DL		;ELSE PRINT CONTENTS AS QTY.
	RETURN

DRB:	HRRZ	T1,PDP11(T3)	;1ST WORD OF INSN.
	SETZ	T2,
	LSHC	T1,-14		;PREPARE TO DECODE.
	SKIPL	DRB2T(T1)	;IF >0, JRST TO THAT ADDR. (NOT 2-OP. INSN)
	 JRST	@DRB2T(T1)
	TTOA	DRB2T(T1)	;IF 2-OP, TYPE ITS NAME.
	TTOI	" 
	PUSHJ	P,DPADDR	;DECODE AND PRINT SOURCE ADDR.
DPDEST:	MOVE	T6,%D		;WE SHOULD HAVE DEFINED %S FOR SOURCE.
	MOVEM	T6,%S
	TTOI	",
	JRST	DPADDR		;  "     "    "   DEST. ADDR.

DRB2T:	DRB00
	ASCIZ/MOV/
	ASCIZ/CMP/
	ASCIZ/BIT/
	ASCIZ/BIC/
	ASCIZ/BIS/
	ASCIZ/ADD/
	DRB07
	DRB10
	ASCIZ/MOVB/
	ASCIZ/CMPB/
	ASCIZ/BITB/
	ASCIZ/BICB/
	ASCIZ/BISB/
	ASCIZ/SUB/
	DRB17

;INSNS STARTING WITH 0000.
DRB00:	JUMPL	T2,DRB1	;1-OPER. WORD INSN.
	LSHC	T1,4
	JUMPE	T1,DRBS		;NOT A BRANCH.
	TTOA	DRB00T-1(T1)
DRBBR:	TTOI	" 
DRBBR1:	HLRE	T6,T2		;GET OFFSET.
	ASH	T6,-9		;AS NO. OF WORDS.
	ANDCMI	T6,1
	ADDI	T6,2(DO)	;DESTINATION ADDR OF BRANCH.
	ADRTYP	T6
	HRLI	T6,.5KBIT
	MOVEM	T6,%D
	RETURN

DRB00T:	ASCIZ/BR/
	ASCIZ/BNE/
	ASCIZ/BEQ/
	ASCIZ/BGE/
	ASCIZ/BLT/
	ASCIZ/BGT/
	ASCIZ/BLE/

; INSTRUCTIONS OF FORM 17XXXX.
DRB17:	LSHC	T1,4
	CAIGE	T1,362
	 JRST	DRB170
	SKIPL	T6,DRB17T-362(T1)
	 JRST	DRB17A
	LDB	T3,[420200,,T2]
	SAVE	T3
	LSHC	T1,2
	6TYPE	T6
	TTOI	" 
	CALL	DPADDR
	MOVE	T5,%D
	MOVEM	T5,%S
	TTOI	",
	REST	T5
	JRST	DPAREG
DRB17A:	MOVNS	T6
	6TYPE	T6
	TTOI	" 
	LDB	T5,[420200,,T2]
	CALL	DPAREG
	MOVE	T5,%D
	MOVEM	T5,%S
	TTOI	",
	LSHC	T1,2
	JRST	DPADDR

DRB17T:	SIXBIT/MULF/
	SIXBIT/MODF/
	SIXBIT/ADDF/
	SIXBIT/LDF/
	SIXBIT/SUBF/
	SIXBIT/CMPF/
	-SIXBIT/STF/	;NEGATED MEANS MEMORY OPERAND LAST
	SIXBIT/DIVF/
	-SIXBIT/STEXP/
	-SIXBIT/STCFI/
	-SIXBIT/STCFF/
	SIXBIT/LDEXP/
	SIXBIT/LDCIF/
	SIXBIT/LDCFF/

DRB170:	LSHC	T1,2
	CAIGE	T1,1701
	 JRST	DR1700
	6TYPE	DR170T-1701(T1)
	TTOI	" 
	JRST	DPADDR

DR170T:	SIXBIT/LDFPS/
	SIXBIT/STFPS/
	SIXBIT/STST/
	SIXBIT/CLRF/
	SIXBIT/TSTF/
	SIXBIT/ABSF/
	SIXBIT/NEGF/

DR1700:	LSHC T1,6
	CAIL T1,170013
	 JRST DLB1
	SKIPN D1700T-170000(T1)
	 JRST DLB1
	6TYPE D1700T-170000(T1)
	RETURN

D1700T:	SIXBIT/CFCC/
	SIXBIT/SETF/
	SIXBIT/SETI/
	0
	0
	0
	0
	0
	0
	SIXBIT/SETD/
	SIXBIT/SETL/

; INSTRUCTIONS OF FORM 10XXXX.
DRB10:	JUMPL	T2,DRB1B
	LSHC	T1,4
	TTOA	DRB10T-200(T1)	;PRINT NAME OF BRANCH.
	JRST	DRBBR

DRB10T:	ASCIZ/BPL/
	ASCIZ/BMI/
	ASCIZ/BHI/
	ASCIZ/BLOS/
	ASCIZ/BVC/
	ASCIZ/BVS/
	ASCIZ/BHIS/
	ASCIZ/BLO/

DRB07:	SKIPN	WI45		;DON'T PRINT 11-45 INSNS
	 JRST	DLB1		;UNLESS THEY'RE ATTACHED.
	LSHC	T1,3
	SKIPN	DRB07T-70(T1)
	 JRST	DLB1		;CHECK FOR UNUSED OPCODES.
	TTOA	DRB07T-70(T1)	;AN INSN, TYPE ITS NAME.
	TTOI	40
	LDB	T5,[410300,,T2]	;REG. NUM. FROM INSN.
	LSH	T2,3
	CAIGE	T1,74
	 JRST	DRB07A		;MUL, DIV, ETC.
	PUSHJ	P,REGTYP	;PRINT REGISTER NUMBER, % NOT NEEDED.
	TTOI	",
	MOVE	T5,%D		;WE SHOULD HAVE DEFINED %S FOR SOURCE.
	MOVEM	T5,%S
	CAIE	T1,77
	JRST	DPADDR		;PRINT DEST ADDR FOR ALL BUT SOB.
	LSH	T2,-2		;PRETEND SOB'S 6-BIT OFFSET WAS 8-BITS.
	MOVNS	T2		;FOR SOB, OFFSET IS SUBTRACTED.
	JRST	DRBBR1

DRB07A:	SAVE	T5		;REG IS DEST IN THESE INSNS (MUL, ETC)
	CALL	DPADDR		;PRINT ADDR IN DEST-POSITION (REALLY SRC)
	TTOI	",
	MOVE	T6,%D		;DPADDR ALWAYS SETS %D.
	MOVEM	T6,%S
	REST	T5
	JRST	REGTYP		;NOW TYPE THE REGISTER #.

DRB07T:	ASCIZ/MUL/
	ASCIZ/DIV/
	ASCIZ/ASH/
	ASCIZ/ASHC/
	ASCIZ/XOR/
	0
	0
	ASCIZ/SOB/	;77.

DRB1:	LSHC	T1,6
	CAIGE	T1,50		;JSR?
	JRST	DRBJSR		;YES.
	SKIPN	WI45		;DON'T PRINT 11-45 INSNS
	 CAIGE	T1,64		;UNLESS THEY'RE ENABLED.
	  CAIL	T1,70
	   JRST	DLB1		;NOT INSN.
	SKIPN	DRB1T-50(T1)	;NO OPCODE IN TABLE => NOT INSN.
	 JRST	DLB1
	TTOA	DRB1T-50(T1)	;PRINT OP-CODE.
	CAIN	T1,64
	 JRST	DRBMRK		;MARK INSN SPECIAL.
DRB1X:	TTOI	<" >
	JRST	DPADDR		;DEST. ADDRESS.

DRB1T:	ASCIZ/CLR/
	ASCIZ/COM/
	ASCIZ/INC/
	ASCIZ/DEC/
	ASCIZ/NEG/
	ASCIZ/ADC/
	ASCIZ/SBC/
	ASCIZ/TST/
	ASCIZ/ROR/
	ASCIZ/ROL/
	ASCIZ/ASR/
	ASCIZ/ASL/
	ASCIZ/MARK/
	ASCIZ/MFPI/
	ASCIZ/MTPI/
	ASCIZ/SXT/

DRB1B:	LSHC	T1,6
	CAIGE	T1,1050		;TRAP? EMT?
	 JRST	DRBTE		;YES.
	CAIL	T1,1064
	 JRST	DRB1C		;NOT INSN.
	TTOA	DRB1T-1050(T1)
	TTOI	"B
	JRST	DRB1X

DRB1C:	CAILE T1,1067
	 JRST DLB1
	TTOA [ASCIZ/MTPS/ ? ASCIZ/MFPD/ ? ASCIZ/MTPD/ ? ASCIZ/MFPS/]-1064(T1)
	JRST DRB1X

;INSNS WITH 1ST 10 BITS =0.
DRBS:	LSHC	T1,2		;DECODE NEXT 2 BITS.
	JUMPG	T1,DRBS1
	LSHC	T1,6		;ALL BUT LAST 2 OCTITS =0. DECODE THEM.
	SKIPN	WI45
	 CAIE	T1,6		;RTT IS AN 11-45 INSN.
	  CAILE	T1,6
	   JRST	DLB1		;NOT INSN.
	6TYPE	DRBST1(T1)	;PRINT OP-CODE
	RETURN

DRBST1:	SIXBIT /HALT/
	SIXBIT /WAIT/
	SIXBIT /RTI/
	SIXBIT /BPT/
	SIXBIT /IOT/
	SIXBIT /RESET/
	SIXBIT /RTT/

DRBS1:	CAIN	T1,2
	JRST	DCORTS		;CONDITION CODE OP OR RTS.
	LSH	T1,-1		;WAS 1 OR 3, NOW IS 0 OR 1.
	TTOA	DRBS1T(T1)	;OP CODE.
	JRST	DRB1X

DRBS1T:	ASCIZ/JMP/
	ASCIZ/SWAB/

DCORTS:	LSHC	T1,6		;LAST 2 OCTITS.
	CAIL	T1,240		;RTS?
	JRST	DCCOP
	CAIL	T1,230
	JRST	DRBSPL
	CAIL	T1,210
	JRST	DLB1
	TTOA	[ASCIZ/RTS /]	;YES.
	MOVEI	T5,-200(T1)	;REG. NUM.
	JRST	REGTYP	;PRINT WITHOUT "%".

DRBSPL:	SKIPN	WI45
	 JRST	DLB1
	TTOA	[ASCIZ/SPL /]
	TTOI	60-230(T1)	;PRIORITY VALUE.
	RETURN

DCCOP:	TRNE	T1,20		;SET OR CLEAR?
	TTOI	"S		;SET.
	TRNN	T1,20
	TTOI	"C		;CLEAR
	TTOA	[ASCIZ/FL @/]
IRPC X,,NZVC
	TRNE	T1,X!F
	TTOI	"X
TERMIN
	RETURN

DRBJSR:	TTOA	[ASCIZ/JSR /]
	MOVEI	T5,-40(T1)	;NUMBER OF REGISTER.
	PUSHJ	P,REGTYP
	JRST	DPDEST		;PRINT DEST. ADDR.

DRBTE:	TRNE	T1,4		;EMT OR TRAP?
	TTOA	[ASCIZ/TRAP /]
	TRZN	T1,4
	TTOA	[ASCIZ/EMT /]
DRBTE1:	LSHC	T1,6
	LDB	T5,[1000,,T1]	;GET 8 LOW BITS.
	JRST	DPADX2		;GO SYMTYP, SET %D.

DRBMRK:	TTOI	40
	SETZ	T1,		;CODE IS ONLY 6 BITS.
	JRST	DRBTE1

;DECODE AND PRINT ADDRESS.
DPADDR:	SETZ	T1,
	LSHC	T1,2
	LDB	T5,[400300,,T2]	;GET REGISTER NUMBER.
	ROT	T2,4		;SHIFT NEXT ADDR TO TOP.
	TRNN	T2,10		;IF THIS ONE'S INDIRECT, PRINT @.
	JRST	@DPATAB(T1)
	JUMPE	T1,DPADD1	;REGISTER INDIRECT MODE IS SPECIAL.
	TTOI	"@		;OTHER INDIRECT MODE.
	JRST	@DPATAB(T1)	;BRANCH ON MODE.

DPATAB:	DPAREG
	DPADIM
	DPADDM
	DPADXM

DPADIM:	CAIN	T5,7		;IMMEDIATE?
	JRST	DPADI1		;YES.
	PUSHJ	P,DPADD1	;PRINT "("!!REGNO!!")".
	TTOI	"+
	RETURN
DPADI1:	PUSHJ	P,DPADT0	;INCR. FETCHING LOC.
	TTOI	"#
DPADI2:	MOVEI	T5,(T1)
	JRST	DPADX2

DPADDM:	CAIN	T5,7		;DECREMENT OF PC??
	MOVEI	DLEN,-2(DLEN)	;INSN 1 WORD SHORTER.
	TTOI	"-		;NO, '-(R)'.
DPADD1:	TTOI	"(
	PUSHJ	P,REGTYP	;PRINT REG SYM, OR NUM. WITHOUT "%".
	TTOI	")
	RETURN

DPADXM:	PUSHJ	P,DPADT0
	CAIN	T5,7		;RELATIVE ADDRESSING?
	JRST	DPADX1		;YES.
	PUSH	P,T5
	PUSHJ	P,DPADI2	;TYPE DISPLACEMENT.
	POP	P,T5
	JRST	DPADD1		;PRINT '(R)'.

DPADX1:	MOVEI	T5,(T1)
	ADDI	T5,(DO)
	ADDI	T5,(DLEN)
DPADX2:	ANDI	T5,177777
	SYMTYP	T5
	HRLI	T5,.5KBIT
	MOVEM	T5,%D
	RETURN

DPADT0:	MOVEI	DLEN,2(DLEN)	;SET UP TO GET NEXT WD OF INSN.
	HRRM	DLEN,%OL
	MOVEI	T3,-2(DLEN)
	ADDI	T3,(DO)
	LSH	T3,-1
	CALL	DCLOS3
	SKIPGE	T1,PDP11(T3)
	 JSP	D,MTRAPR
	RETURN

;PRINT THE REGISTER NUMBER IN T5, EITHER SYMBOLICALLY OR NUMERICALLY,
;ACCORDING TO CURRENT MODE.
;IF NUMERICALLY, DON'T PRINT "%".
;SAVE REGISTER NUM. AS VALUE OF %D .
REGTYP:	SETOM	XREGTF		;INDICATE "%" NOT NEEDED.

;COME HERE INSTEAD IF "%" IS NEEDED.
DPAREG:	HRLI	T5,REGBIT
	ADRTYP	T5
	SETZM	XREGTF
	TLO	T5,.5KBIT
	MOVEM	T5,%D		;STORE REG. NUM. AS DEST ADDR, .5KILLED.
	RETURN

CTAB:	PUSHJ	P,DCLOSE	;STORE CHANGES.
CTAB1:	TLO	SF,NUMFND	;CHANGE . .
	TTOA	[ASCIZ/
/]
	MOVE	T5,OPNMD1
	CAMN	T5,OPNMDP
	 JRST	CTAB2		;IF NOT OPENING IN NORMAL MAPPING MODE,
	TTOI	@ALTMOD		;SAY WHICH MODE OPENING IN.
	TTOA	CTABTB(T5)
CTAB2:	ADRTYP	DL		;PRINT LOCATION OPENED.
	TTOI	"/
	JRST	CSLASH

CTABTB:	IRPC XX,,0246
	ASCIZ/XX /
	TERMIN
	ASCII /KI /
	ASCII /SI /
	ASCII /A /
	ASCII /UI /
	ASCII /KD /
	ASCII /SD /
	0
	ASCII /UD /

CUPAR:	PUSHJ	P,DCLOSE
	MOVE	DL,DPNT		;DL _ VAL(.).
	HRRI	DL,-1(DL)
	TLNE	SF,BYTOPN	;IF BYTE, OPEN NEXT AS BYTE.
	JRST	CLF2
	TLNN	DL,REGBIT	;UNLESS REGISTER NUM,
	HRRI	DL,-1(DL)	;MOVE BACK 1 WORD.
	JRST	CTAB1

CCR:	PUSHJ	P,DCLOSE	;MAKE CHANGES.
	MOVE	T5,%PMODE	;RESET TEMPORARY MODES.
	MOVEM	T5,%TMODE	;TO PERMANENT ONES.
	MOVE	T5,OPNMDP
	MOVEM	T5,OPNMDT
	SETO	DO,		;NO LOCATION OPEN.
	TTOI	"!
	JRST	DLOOP

CLF:	PUSHJ	P,DCLOSE
	MOVE	DL,DPNT		;DL _ VAL(.).
	HRRI	DL,1(DL)
	TLNN	DL,REGBIT	;IF NOT REGISTER OR BYTE,
	TLNE	SF,BYTOPN
	JRST	CLF2
	ADDI	DL,@%OL		;MOVE DOWN BY LENGTH OF QTY.
	MOVEI	DL,-1(DL)
	JRST	CTAB1
CLF2:	TLO	SF,DBYTM	;OPEN NEXT LOC. AS BYTE, TOO.
	JRST	CTAB1

; = - RETYPE AS NUMBER.
CEQ:	TLO	SF,DNUMM

; ]  - TYPE IN CURRENT MODE.
CRB:	TLZ	SF,NUMFND	;ELIMINATE ARG.
	SYMTYP	DL
	MOVEI	DLEN,2		;NOW A 1-WORD OBJECT, IF NOT BYTE.
	SKIPE	S%OLFL		;IF RETYPING WHAT WAS OPENED,
	HRRM	DLEN,%OL	;UPDATE LENGTH OF WHAT'S OPENED.
DLOOPT:	TTOA	[ASCIZ/    /]
	JRST	DLOOP

;ACTUAL CHARACTER ALTMODE.
CALT:	SKIPE	CALTSF		;IF $ AND ; WERE SWITCHED,
	JRST	CSEM0		;TREAT $ AS ; .
CALT0:	SETZB	T2,T3
	PUSH	P,[DLOOP1]
CALT1:	GETCHR			;DECODE NEXT CHAR.
	CAIL	T0,"A+40
	 CAILE	T0,"Z+40
	  CAIA
	   SUBI	T0,40
	CAMN	T0,ALTMOD
	AOJA	T2,CALT1	;COUNT ALTMODES.
	CAIN	T0,"-
	JRST	CALTM		;INDICATE GOT '-'.
	CAIN	T0,"I
	MOVEI	T3,DINSM
	CAIN	T0,"D
	MOVEI	T3,DDECM
	CAIN	T0,"!
	MOVEI	T3,DEXCM
	CAIN	T0,"B
	MOVEI	T3,DBYTM
	CAIN	T0,"'
	MOVEI	T3,DBYTM+DASCM
	CAIN	T0,""
	MOVEI	T3,DASCM
	CAIN	T0,"N
	MOVEI	T3,DNUMM
	CAIN	T0,"R
	MOVEI	T3,DREGM
	JUMPE	T3,CALT3

CALTX:	TLZ	SF,(T3)		;CLEAR FLAG FOR 1 TIME.
	JUMPL	T2,.+2		;IF NO - SIGN,
	TLO	SF,(T3)		;SET AGAIN.
	MOVEI	T1,%TMODE	;IF >1 ALTMODE, CHANGE TEMP. MODE SAME WAY.
	PUSHJ	P,CALTX2
	MOVEI	T1,%PMODE	;IF >2 ALTMODES, CHANGE PERM. MODE.
	CALL	CALTX2
	POPJ P,

CALTX2:	TRNE	T2,-1		;IF ENOUGH ALTMODES, CONTINUE.
	JRST	CALTX3
	POP	P,T5		;SCRATCH RETURN ADDR.
	POPJ P,

CALTX3:	MOVE	T5,(T1)		;GET WORD TO BE CHANGED.
	ANDCMI	T5,(T3)		;INITIALLY TURN OFF.
	JUMPL	T2,.+2		;IF SETTING, TURN BACK ON.
	IORI	T5,(T3)
	MOVEM	T5,(T1)		;STORE BACK.
	SOJA	T2,CPOPJ	;1 ALTMODE HANDLED.

CALTM:	TLC	T2,-1		;COMPLEMENT MINUS INDICATOR.
	JRST	CALT1

CALT3:	45N	ERROR [ASCIZ/MODE/]

45Y[	ANDI	T2,-1		;DECODE MAPPING MODES.
	JSP	T1,DDECOD
CALT3A:	"0,,CALT4
	"2,,CALT4
	"4,,CALT4
	"6,,CALT4
	"K,,CALT5
	"S,,CALT5
	"A,,CALT4
	"U,,CALT5
	[ERROR [ASCIZ/MODE/]]

CALT5:	GETCHR			;AFTER "K", "S" AND "U",
	CAIL	T0,140
	 SUBI	T0,40
	CAIN	T0,"I		;LOOK FOR "I" OR "D".
	 JRST	CALT4
	CAIE	T0,"D
	 ERROR	[ASCIZ/MODE/]
	ADDI	T1,4
CALT4:	SUBI	T1,CALT3A	;T1 HAS IDX OF CHAR IN THE ABOVE TABLE.
	HRRZM	T1,OPNMD1	;SET 1-SHOT, TEMP AND PERM
	SOJL	T2,CPOPJ
	HRRZM	T1,OPNMDT	;ACC. TO # OF ALTMODES.
	SOJL	T2,CPOPJ
	HRRZM	T1,OPNMDP
	RET
]

; COLON - DECODE FOLLOWING SYMBOL AS SPECIAL COMMAND.
CCOL:	MOVE	T1,[-NUMCOM,,COMTAB]
	JSP	T3,CCOL1	;SEARCH COMTAB
	JRST	(T2)		;CCOL1 PUSHJ'S BACK

COMTAB:
TXN[
IRP CMD,,[LCOMS,ADUMP,ALTSEM,BUSS,CDMP,CORE,DEBUG,DEVTIM,DMP,DMPCOR
DMPSYM,DMPTPV,DT,FLSYMS,LOAD,LOD,LODCOR,LODPTR,LODSYM,LOOKUP,LBRKS
LSYMS,ODMP,PAT,REGS,RESET,S%CSX,TIME,WALLP,XFILE,ZTIME]
	SIXBIT/CMD/
	C!CMD
TERMIN
]
TXY[
IRP CMD,,[LCOMS,ALTSEM,BUSS,CORE,DEBUG,DEVTIM,FLSYMS,LBRKS
LSYMS,PAT,REGS,RESET,S%CSX,TIME,ZTIME]
	SIXBIT/CMD/
	C!CMD
TERMIN
]
NUMCOM==<.-COMTAB>/2
	ASCIZ/CMD/		;MESSAGE IF NOT FOUND.

; :LSYMS  - LIST DEFINITIONS OF ALL NON-SPECIAL SYMBOLS.
CLSYMS:	MOVEI	T5,SYMLST
	PUSH	P,SF
	TLO	SF,DNUMM	;DON'T WANT "XXXY=XXXY" TO PRINT.
CLSYM0:	6TYPE	(T5)		;PRINT SYMBOL NAME.
	SKIPGE	T6,1(T5)
	TTOI	"=		;INDICATE IF .5KILLED.
	TTOI	"=
	SYMTYP	T6		;PRINT VALUE.
	CRF
CLSYM1:	ADDI	T5,2
	CAMG	T5,SYMEND
	JRST	CLSYM0
	POP	P,SF
	RETURN

; :FLSYMS -- FLUSH USER SYMBOLS.
CFLSYM:	SETZM	LASTST+2
	MOVE	T5,[LASTST+2,,LASTST+3]
	MOVE	T6,SYMEND	;ZERO ALL USER SYMBOLS' STES.
	BLT	T5,1(T6)
	MOVEI	T5,LASTST
	MOVEM	T5,SYMEND
	RETURN

; :TIME - PRINTS SIMULATED RUN TIME.
CTIME:	MOVE	T2,RTIME
CBUSS2:	JUMPGE	T2,CTIME1
	TTOI	"-
	MOVM	T2,T2		;IF TIME IS <0.
CTIME1:	IDIVI	T2,10.
	MOVEM	T2,QA
	MOVEM	T3,QT
	TTOA	[ASCIZ/A.T
/]
	RETURN

;SEMICOLON - READ IN NUMBER (NOT EXPRESSION), AND LETTER.
CSEM:	SKIPE	CALTSF		;IF $ AND ; WERE SWITCHED,
	JRST	CALT0		;TREAT ; AS $.
CSEM0:	PUSHJ	P,GPASST	;SKIP SPACES,
	TLO	SF,D1CHAR	;RE-READ 1ST NON-SPACE.
	PUSHJ	P,DGNUM
	PUSHJ	P,PASSPS
CSEM2:	JSP	T1,DDECOD
TXN[
IRPC CMD,,ABDFGILNPQRTUWYZX
	"CMD,,CS!CMD
TERMIN
]
TXY[
IRPC CMD,,ABDFGILNPRTUWZX
	"CMD,,CS!CMD
TERMIN
]
	"-,,CSEM1
	[ERROR [ASCIZ/COMMAND/]]

CSEM1:	HRROS	T2		;INDICATE GOT - .
	PUSHJ	P,GPASST	;SKIP TO NEXT NONBLANK.
	JRST	CSEM2		;DECODE IT AS COMMAND.

TXN[
; QUIT -- EXIT COMMAND
CSQ:	movei	a,300000
	.BREAK	12,a
	JRST	CCRLF
]

;PROCEED ARG (OR 1) INSNS.
CCN:	HLLOS	%CSN		;LEAVE ;N MODE.
	MOVEI	T0,1
	TLNE	SF,NUMFND	;IF NO ARG, DO 1 INSN.
	MOVEI	T0,(DL)
	SUB	T0,DDONXT
	MOVEM	T0,INSCNT
	JRST	CSN1		;SET UP SINGLE-STEP AND PROCEED.

; ;Z -- READS STANDARD RANGE & NUMBER, SETS EACH WORD IN RANGE TO NUMBER.
CSZ:	PUSHJ	P,DGRAN
	SKIPGE	PDP11(T0)
	JSP	D,MTRAPW
	HRRM	T2,PDP11(T0)
	AOBJN	T0,.-3
	JRST	CCRLF

; ;I -- RESET DEVICES, PS, TIME.
CSI:	PUSHJ	P,XRESET
	PUSHJ	P,CZTIME
	HLLZS	RPS
	SETOM	PC-SAVLNG(P)	;WILL ALWAYS SEEM PC WAS CHANGED.
	SETZM	LBUSEM		;FORGET OLD BUSS ERRORS.
CCRLF:	CRF
	JRST	CCR

; ;T -- TURN TRAP PRINTING ON OR OFF.
CST:	SAVE	[DLOOPT]
	TLZN	SF,NUMFND	;IF ARG,
	JRST	CST1
	MOVEI	T1,(DL)		;SET PRINTING FOR THAT TRAP.
	LSH	T1,-2
	CAIL	T1,TRPPTL
	ERROR	[ASCIZ/TRAP THROUGH THERE/]
	MOVEM	T2,TRPPNT(T1)
	JRST	CSLTP1

CST1:	MOVEM	T2,TRPPNT+1	;NO ARG - SET FOR ALL TRAPS.
	MOVE	T2,[TRPPNT+1,,TRPPNT+2]
	BLT	T2,TRPPNT+TRPPTL-1
	JRST	CSLTP1

; ;U  --  SAME AS ;B, BUT IF NO 2ND ARG, REMOVE A BREAKPOINT.
CSU:	AOS	DGVALP		;PRETEND 0 IN T2 IS 2ND ARG.

; ;B -- SET BREAKPOINT OF TYPE (2ND ARG) AT LOCATION (1ST ARG).
;IF SECOND ARG MISSING, USE 7 (ALWAYS BREAK AND STOP).
;IF 1ST ARG HAS 2 WORDS, IT IS RANGE OF LOCATIONS TO PUT BREAKPOINTS AT.
;IF 1ST ARG MISSING, PUT BREAKPOINTS AT ALL LOCATIONS.
CSB:	SKIPN	DGVALP		;IF NO 2ND ARG, REPLACE BY 7.
	MOVEI	T2,7
CSB0:	LSH	T2,35		;POSITION FOR STORAGE.
	TLZE	T2,400000	;TOP BIT -> 4.1 (AUTOFLUSH)
	TLO	T2,400
	TLOE	T2,200000	;NEXT 2 BITS GO TO 4.3, 4.2 .
	TLO	T2,2000
	TLZE	T2,100000
	TLO	T2,1000
	LSH	T2,1		;FINISH POSITIONING.
	TLNN	SF,NUMFND	;IF NO 1ST ARG,,
	JRST	CSB1		;GO MAKE AOBJN PTR->ALL LOCS.
	MOVEI	T1,(DL)
	TLNE	DL,REGBIT	;CAN'T PUT BREAKPOINTS IN REGISTERS.
	ERROR	[ASCIZ/BKPT ON ACCUM./]
	LSH	T1,-1		;GET WORD NUM.
	CAIN	DLEN,2		;IF 2ND WORD,
	JRST	CSB5
	HRRZ	T3,DRNEXT+1	;SET LH OF AOBJN PTR.
	LSH	T3,-1
	SUBM	T1,T3		;TO NUM. WORDS IN RANGE.
	HRLI	T1,-1(T3)
	TLO	T1,700000	
	TLZ	SF,NUMFND	;INDICATE SETTING AT MANY PLACES.
	JRST	CSB2

CSB5:	MOVE	T3,T1		;ONE ARG TO ;B => MAP IT.
	CALL	DCLOS3
	MOVE	T1,T3
	JRST	CSB2

CSB1:	MOVN	T1,KCOUNT	;GET NUM. LOCATIONS EXISTING.
	LSH	T1,28.
CSB2:	MOVE	T3,PDP11(T1)
	TLZ	T3,177000	;TURN OFF BREAKPOINT BITS.
	IOR	T3,T2		;SET THEM.
	TLNN	T3,377000	;IF THIS LOC. NOW NORMAL MEM.,
	MOVEI	T3,(T3)		;TURN OFF SIGN.
	MOVEM	T3,PDP11(T1)
CSB4:	AOBJN	T1,CSB2
	TLZ	SF,NUMFND
	JRST	DLOOPT

; ;F - IF NO NUMBER, ASSUME 1.
CSF:	SKIPN	DGVALP
	MOVEI	T2,1
	JRST	CSB0

; ;W, ;R -- LIKE ;F, BUT ASSUME 2, 4.
CSW:	SKIPN	DGVALP
	MOVEI	T2,2
	JRST	CSB0

CSR:	SKIPN	DGVALP
	MOVEI	T2,4
	JRST	CSB0

; :LBRKS - PRINT A SEQUENCE OF ;B COMMANDS THAT WOULD CREATE THE
;BREAKPOINTS THAT NOW EXIST.
CLBRKS:	PUSHJ	P,DGRAN
	MOVSI	T2,177000
CLBRK0:	JUMPGE	T0,CPOPJ
	TDNN	T2,PDP11(T0)
	AOBJN	T0,.-1
	JUMPGE	T0,CPOPJ
	MOVEI	T3,(T0)
	LSH	T3,1
	HLLZ	T1,PDP11(T0)
	AND	T1,T2
CLBRK1:	MOVE	T5,PDP11(T0)
	AND	T5,T2
	CAMN	T1,T5
	AOBJN	T0,CLBRK1
	MOVEI	T5,-1(T0)
	LSH	T5,1
	CAIE	T5,(T3)
	JRST	CLBRK2
	ADRTYP	T5
	JRST	CLBRK3

CLBRK2:	TTOA	[ASCIZ /< /]
	ADRTYP	T3
	TTOA	[ASCIZ /, /]
	ADRTYP	T5
	TTOA	[ASCIZ / >/]
CLBRK3:	TTOA	[ASCIZ / $ /]
	TLZE	T1,1000
	IORI	T1,1
	TLZE	T1,2000
	TLO	T1,200000
	TLZE	T1,4000
	TLO	T1,400000
	ROT	T1,6
	TLO	SF,DNUMM
	SYMTYP	T1
	TTOA	[ASCIZ / B
/]
	JRST	CLBRK0

IFN 0,[
; ;S COMMAND -- LOAD SYMBOLS FROM PALX11 LISTING.
CSS:	TTOI	" 
	MOVEI	A,CSSDEV
	PUSHJ	P,DGFIL
	TSOPEN	LOADCH,CSSDEV	;OPEN LISTING FILE.
	TLO	SF,CSSFLG	;INPUT COMES FROM IT.
CSSFF:	GETCHR			;NEW PAGE ... SKIP 2 LINES.
	CAIE	T0,^J
	JRST	CSSFF
CSSNXT:	GETCHR			;GO TO END OF LINE.
	CAIE	T0,^J
	JRST	CSSNXT
CSSLI1:	GETCHR
	CAIN	T0,^L
	JRST	CSSFF
	CAIE	T0,^I		;ELIM. SPECIAL MESSAGES.
	JRST	CSSNXT
CSSLIN:	GETCHR			;SKIP FORMAT CHARS.
	CAIE	T0,^I
	CAIN	T0," 
	JRST	CSSLIN
	CAIE	T0,^J
	CAIN	T0,^M
	JRST	CSSNXT

	CAIL	T0,"0		;DON'T LET SYMBOLS START WITH DIGITS.
	CAILE	T0,"9
	JRST	.+2
	JRST	CSSNXT
	PUSHJ	P,DGSYM		;READ IN THE SYMBOL.
	JUMPE	T2,CSSNXT	;IF LINE DOESN'T START WITH SYMBOL, SKIP IT.
	MOVEM	T2,CSSA		;SAVE NAME.
	PUSHJ	P,DGNUM		;READ ITS VALUE.
	EXCH	T2,CSSA
	PUSHJ	P,DEFSYM	;DEFINE THE SYMBOL,
	HRRZ	T2,CSSA
	JUMPN	T2,.+2
	MOVSI	T2,400000	;IF VALUE IS 0, HALF-KILL.
	CAIE	T0,"R		;IF REG. SYM.,
	JRST	.+3
	HRLI	T2,400001	;ADJUST DEF,
	GETCHR			;PASS THE "R".
	CAIE	T0,"H		;HALF-KILL IF SPECIFIED.
	JRST	.+3
	GETCHR
	TLO	T2,400000
	MOVEM	T2,1(T5)	;AND STORE THE VALUE.
	JRST	CSSLI1		;LOOK FOR ANOTHER SYMBOL ON THIS LINE.

CSSA:	0
CSSDEV:	2,,(SIXBIT/DSK/)
	0?SIXBIT/BIN/
]	;END IFN 0.

; ;A -- ATTACH DEV.
CSA:	SETOM	CSAF
	JRST	.+2

; ;D -- DETACH DEV.
CSD:	SETZM	CSAF
	MOVE	T1,[-NUMDEV,,DEVTAB]
	TTOI	" 
	SETOM	DGLINF
	JSP	T3,CCOL1	;FIND DEVICE
	SKIPE	CSAF	;CCOL1 PUSHJ'S HERE
	 HLRZS	T2	;LH FOR ;A RH FOR ;D
	JRST	(T2)

CCOL1:	PUSH	P,[CCR]
CCOL2:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM		;GET DEV. NAME.
	SETZM	DGLINF
	TLNN	SF,NUMFND
	 TDZA	T5,T5
	  MOVEI	T5,(DL)		;T5_ARG OR 0 IF NONE.
	JUMPE	T2,CSA2
CSA0:	CAME	T2,(T1)
	 AOJA	T1,CSA1
	MOVE	T2,1(T1)	;FOUND - GET DISPATCH WORD
	TLO	SF,D1CHAR	;RE-READ CHAR FOLLOWING DEV. NAME.
	PUSHJ	P,(T3)		;CALL OUR CALLER BACK
CSA4:	TLZ	SF,NUMFND+D1CHAR	;SO CCR WON'T STORE CHANGES.
	SETZM	DGLCNT
	POPJ	P,

CSA1:	AOBJN	T1,CSA0
	ERROR	(T1)	;PRINT MESSAGE AFTER PARTICULAR TABLE

TXN[
DEVTAB:IRPS X,,[MASTER,CORE,DC,DCR,DCT,DF,DM,DMR,DMT,EAE
I45,LK,LP,NGDIS,NULDIS,PK,PP,PPA,PPI,PR,PRA,PRI,RK,TK,TP]
	SIXBIT/X/
	A!X,,D!X
TERMIN
	SIXBIT/DT/
	AET,,DET
]
TXY[
DEVTAB:IRPS X,,[CORE,EAE,I45,LK,TK,TP]
	SIXBIT/X/
	A!X,,D!X
TERMIN
]
NUMDEV==<.-DEVTAB>/2
	ASCIZ/DEVICE/

CSA2:	PUSH	P,[CSA4]
	ADD	T1,[1,,2]
CLCOMS:	6TYPE	(T1)
	CRF
	AOBJP	T1,CPOPJ
	AOJA	T1,CLCOMS

CSAF:	0

;SET A DEVICE'S BASIC TIME UNIT. ARG IN VIRT. 10^-7 SEC.
CDEVTI:	MOVE	T1,[-CRESTL,,CRESTB]
	JSP	T3,CCOL2	;WILL PUSHJ TO .+1 .
	TLNE	SF,NUMFND
	MOVEM	T5,(T2)
	MOVE	T2,(T2)
	JRST	CBUSS2

;RESET A DEVICE.
CRESET:	MOVE T1,[-CRESTL,,CRESTB]
	JSP T3,CCOL2
	HLRZS T2
	JRST (T2)

I45TIM:	0		;DUMMY TO MAKE :DEVTIM I45 DO NOTHING.

CRESTB:	0?0
TXN[	IRPS X,,DCR DCT DF DM I45 LK LP PK PP PR RK RKC RKX TK TP
	IF2 IFNDEF Z!X,Z!X==CRESE1
	SIXBIT /X/
	Z!X,,X!TIM
	TERMIN
]
TXY[	IRPS X,,I45 LK TK TP
	IF2 IFNDEF Z!X,Z!X==CRESE1
	SIXBIT/X/
	Z!X,,X!TIM
	TERMIN
]
CRESTL==<.-CRESTB>/2
	ASCIZ /DEVICE/
CRESE1:	ERROR [ASCIZ /NO RESET ROUTINE/]

; ;L COMMAND - LOAD FROM FILE, ZEROING CORE AND SYMBOLS.
TXN[
CSL:	SETOM	CSLFLG		;INDICATE ;L VERSUS :LOAD.
	PUSH	P,[CCR]
	TTOI	" 
	SKIPA	T0,[" ]		;DON'T REREAD THE "L".

CLOD:	; :LOAD AND :LOD COMMANDS.
CLOAD:	SETZM	CSLFLG
	MOVEI	T5,CSLTAB	;NORMAL LOAD-TABLE.
CLOAD1:	HRRM	T5,CLOADT
	PUSHJ	P,LODFL.
	SETOM	CSLBFL		;USING BLOCK-MODE.
	SETZM	CSLBCT		;NO WORDS IN BUFFER YET.
	TLZ	SF,NUMFND
	TSOPEN	LOADCH,DSLDEV
	MOVE	A,[-1,,B]	; READ ONE WORD INTO A
	.IOT	LOADCH,A	; 
	.ACCESS	LOADCH,[0]	; reset input pointer
	CAIE	B,1		; NORMAL LOAD FILE START WITH A 1
	 JRST	NEWBIN		; IF NOT, TRY NEWBIN FORMAT
	SKIPN	CSLFLG		;IF WAS ;L, ZERO CORE AND SYMBOLS.
	JRST	CSL0
	SETZM	LBUSEM		;FORGET OLD BUSS ERRORS.
	SETOM	PC-SAVLNG(P)	;WILL ALWAYS SEEM PC WAS CHANGED IN DDT.
	PUSHJ	P,XRESET
	PUSHJ	P,CZTIME
	PUSHJ	P,CS%CSX	;RESET %CSX ADDR.
	HLLZS	RPS
	PUSHJ	P,CFLSYM
	MOVE	T5,[.5KBIT,,1]
	MOVEM	T5,%PATCH	;ELIMINATE PATCH AREA ADDR.
	HRRZ	T5,KCOUNT
	LSH	T5,10.		;NUM. WDS. CORE.
	MOVE	T6,[PDP11,,PDP11+1]
	SETZM	PDP11
	SKIPE	KCOUNT
	BLT	T6,PDP11-1(T5)	;ZERO ALL CORE.

CSL0:	PUSH	P,%CSX
CSL1:	CSLWRD	T3		;READ 1 WD. =BLOCK TYPE.
	JUMPL	T3,DSLDEE
	CAIL	T3,CSLMAX	;IF BAD FORMAT,
	ERROR	[ASCIZ/BINARY FILE/]
	PUSHJ	P,@CLOADT
	JRST	CSL1
CSL2:	.CLOSE	LOADCH,
	POP	P,T2	;IF %CSX WAS LOADED, MOVE CSX DEVS
	EXCH	T2,%CSX
	JRST	CS%CS0

CSLTAB:	OFFSET	-.
	CPOPJ			;0 DOESN'T START A BLOCK.
LDABS::	DSLABS			;ABSOLUTE LOADER BLOCK.
LDSYMS::DSLASY			;ENTIRE SYMBOL-TABLE.
LDCOR::	DSLCOR			;LOAD BLOCK OF CORE.
LDDSK::	CSKIPC			;USED TO LOAD BLOCK OF DISK (OBSOLETE)
LDSTE::	DSLSYM			;DEFINE SYMBOL.
LDEND::	POPJ1			;NO MORE BLOCKS.
LDCORZ::DSLZER			;BLOCK OF ZEROS.
LDTRK::	DSLABB			;USED TO MAKE SURE DISK BLOCK EXISTS (OBSOLETE)
LDAK::	CSLAK			;INSURE MINIMUM AMOUNT OF CORE.
LDTPV::	CSLTPV			;LOAD TRAP-ACTION-TABLE.
LDDSKZ::DSLABB			;USED TO ZERO SOME DSK (OBSOLETE)
	OFFSET	0
CSLMAX==.-CSLTAB

; :LODPTR - READ FROM PTR IN 8-BIT MODE.
CLODPT:	SETZM	CSLBFL		;USE UNIT MODE.
	MOVEI	T5,CSLTAB
	HRRM	T5,CLOADT
	TLZ	SF,NUMFND
	TSOPEN	LOADCH,[[10,,(SIXBIT/PTR/)]]
	JRST	CSL0

; :LODCOR -- LOAD, BUT IGNORE NON-CORE ITEMS.
CLODCO:	SETZM	CSLFLG
	JSP	T5,CLOAD1	;SPECIAL TABLE TO LOAD CORE ONLY.
	CPOPJ?DSLABS?DSLASY?DSLCOR?CSKIPC?DSLABW?POPJ1
	DSLZER?DSLABB?CSLAK?CSKIPT?DSLABB

;:LODSYM COMMAND - LOAD SYMBOLS ONLY.
CLODSY:	SETZM	CSLFLG		;DON'T CLEAR CORE.
	JSP	T5,CLOAD1
	CPOPJ?CLODS1?DSLASY?CSKIPC?CSKIPC?DSLSYM?POPJ1
	DSLABB?DSLABB?DSLABB?CSKIPT?DSLABB

CLODS1:	CSLWRD	T5		;SKIP AN ABS LDR BLOCK.
	CALL	DSLABW		;READ BLOCK LENGTH
	MOVNI	T3,-3(T1)	;PREPARE TO SKIP THE REST.
	HRLZI	T3,(T3)		;T3 HAS -<# WDS LEFT, INCL CKSUM>,,
	CAIE	T1,6		;IF NOT A JUMP BLOCK, SKIP IT.
	 JRST	CLODS2
	JRST	CLODS3		;A JUMP-BLOCK: PROCESS IT AND FOLLOWING SYMTAB.

IRPC X,,235
CSLRT!X:	SOSGE	CSLBCT
	CALL	CSLRBF
	ILDB	T!X,CSLBBP
	JRST	(D)
TERMIN

CSLRBF:	SKIPN	CSLBFL
	JRST	CSLRD1
	MOVE	T5,[-100,,CSLBUF]	;AOBJN PTR->BUFFER.
	.IOT	LOADCH,T5
	CAMN	T5,[-100,,CSLBUF]	;ERROR IF EOF.
	ERROR	[ASCIZ/BINARY FILE/]
	HLRZ	T5,T5
	MOVEI	T5,77(T5)		;NUM. WDS. READ.
	MOVEM	T5,CSLBCT
CSLRD2:	MOVE	T5,[444400,,CSLBUF]
	MOVEM	T5,CSLBBP
	RETURN

CSLRD1:	SETZM	CSLBCT
	.IOT	LOADCH,CSLBUF	;IF USING UNIT MODE.
	IOCGET	SKIPA
	JRST	CSLRD2
	ERROR	[ASCIZ/BINARY FILE/]

CADMPB:	1?0?0?0?0?0
CSLBUF:	BLOCK	100
CSLBCT:	0
CSLBBP:	0
CSLBFL:	0		;NONZERO IF BLOCK MODE.
CLOADT:	@(T3)		;R.H. WILL HAVE ADDR. OF CMD TABLE.

CSKIPT:	SKIPA	T3,[-TRPPTL,,]	;SKIP TPV BLOCK.

CSKIPC:	CSLWRD	T3		;SKIP CORE-BLOCK.
CLODS2:	CSLWRD	T2
	AOBJN	T3,.-1
	RETURN

DSLDEE:	CSLWRD	T2		;EACH WD FILLS 2 PDP11 WDS.
	HLRM	T2,PDP11(T3)
	AOBJP	T3,.+3
	HRRM	T2,PDP11(T3)
	AOBJN	T3,DSLDEE
	CSLWRD	T3		;NEXT BLOCK.
	JUMPL	T3,DSLDEE
	JRST	CSL2		;POSITIVE MEANS DONE.

DSLABS:	CSLWRD	T5		;FLUSH 1 WD.
	PUSHJ	P,DSLABW	;READ BLOCK LENGTH.
CLODS3:	MOVEI	T6,-6(T1)	;GET DATA LENGTH.
	PUSHJ	P,DSLABW	;READ ORIGIN.
	MOVEI	T5,(T1)
	ADDI	T5,3777(T6)	;LAST ADDR TO LOAD INTO +1K.
	ROT	T1,-1		;INDEXING POSITION.
	JUMPE	T6,DSLABJ	;IF JUMP-BLOCK (NO DATA).
	LSH	T5,-11.		;MIN. K NEEDED.
	TLC	T1,700000	
	TLCE	T1,700000	;UNLESS LOADING INTO DEVICE REGS,
	PUSHJ	P,CSLAK1	;INSURE THAT MUCH.
DSLAB1:	CSLWRD	T2		;NEXT WORD (=NEXT DATA BYTE).
	JUMPGE	T1,.+3		;IF STORING INTO LOW BYTE.
	DPB	T2,[101000+T1,,PDP11]	;STORE INTO HIGH BYTE,
	AOJA	T1,.+2		;GO TO NEXT WORD.
	DPB	T2,[001000+T1,,PDP11]	;STORE INTO LOW BYTE.
	TLC	T1,400000	;COMPLEMENT ADDRESS LOW BIT.
	SOJG	T6,DSLAB1	;LOOP COUNTER FOR DATA WORDS.
	CSLWRD	T5		;READ & THROW AWAY CHECKSUM.
	RETURN

DSLABJ:	JUMPL	T1,.+3		;IF ADDRESS EVEN,
	ROT	T1,1		;PUT IN 11-WORD FMT,
	HRRM	T1,%GO		;SET STARTING ADDRESS.
	CSLWRD	T5		;THROW AWAY CHECKSUM.
	CSLWRD	T5		;GET SYM. TAB. TYPE
	CAIE	T5,2
	JRST	POPJ1		;2 IS ONLY TYPE NOW.
	AOS	(P)		;EXIT AFTER READING SYMBOLS.
DSLASY:	CSLWRD	T2		;GET NEXT SYMBOL'S NAME.
	JUMPE	T2,CPOPJ	;BLOCK TERMINATED BY 0.
	CSLWRD	T3		;VALUE, FLAGS.
	TLNE	T3,10000
	JRST	DSLASY		;SKIP SYMBOL IF UNDEF.
	TLZ	T3,353760	;CONVERT PALX11 TYPE BITS TO 11SIM'S.
	TLZE	T3,4000
	TLOA	T3,1		;MOVE REGISTER FLAG. ELSE,
	TRNE	T3,-1		;IF VALUE IS 0, .5KILL .
	TLZE	T3,20000
	TLO	T3,400000	;MOVE .5KILL FLAG.
	PUSHJ	P,DEFSY2
	MOVEM	T3,1(T5)
	JRST	DSLASY

DSLABW:	CSLWRD	T2		;READ 2 BYTES,
	MOVE	T1,T2
DSLABB:	CSLWRD	T2	
	LSH	T2,10		;COMBINE INTO WORD.
	ADDI	T1,(T2)
	RETURN

DSLCOR:	CSLWRD	T3		;AOBJN PTR->BLOCK.
	HRRI	T3,1(T3)	;VIRT. ADDR. TO LOAD 1ST WORD.
	CSLWRD	T5
	MOVEM	T5,PDP11(T3)	;READ IN NEXT WD.
	AOBJN	T3,.-2
	RETURN

DSLZER:	CSLWRD	T3		;AOBJN PTR ->BLOCK TO BE ZEROED.
	HRRI	T3,1(T3)	;VIRT. ADDR. OF 1ST WD. TO ZERO.
	SETZM 	PDP11(T3)
	AOBJN	T3,.-1
	RETURN

DSLSYM:	CSLWRD	T2		;READ SYMBOL NAME.
	PUSHJ	P,DEFSY2	;DEFINE IT, GET STE.
	MOVEI	T3,(T5)
	CSLWRD	T2
	MOVEM	T2,1(T3)	;READ SYMBOL TYPE, VALUE INTO STE.
	RETURN

CSLAK:	CSLWRD	T5		;CORE MINIMUM.
CSLAK1:	SUB	T5,KCOUNT
	JUMPLE	T5,CPOPJ		;IF ALREADY ENOUGH.
	JRST	ACORE

CSLTPV:	MOVSI	T3,-TRPPTL
	CSLWRD	T5
	MOVEM	T5,TRPPNT(T3)
	AOBJN	T3,.-2
]

; ;L <FILENAME> COMMAND FOR TOPS20/TENEX

TXY[
CSL:	TTOI	<" >		; SPACE BEFORE FILE NAME
	MOVSI	A,(GJ%OLD\GJ%FNS\GJ%SHT)
	MOVE	B,[.PRIIN,,.PRIOU]
	GTJFN			; GET FILE NAME FROM TERMINAL
	 ERROR	[ASCIZ /NO SUCH FILE/]
	MOVEM	A,LODJFN	; SAVE FILE DESCRIPTOR
	MOVE	B,[8._30.\OF%RD\1]	; 1?
	OPENF
	 ERROR	[ASCIZ /CAN'T OPEN FILE/]
]

TXN[
NEWBIN:
	;; SUBSTITUTE FOR TWNX BIN JSYS..
	move	a,[041000,,ldword-1]
	movem	a,ldptr
define	bin
	pushj	p,itsbin
termin
]
	SETZM	LBUSEM		; FORGET OLD BUS ERRORS
	PUSHJ	P,XRESET
	PUSHJ	P,CZTIME
	PUSHJ	P,CS%CSX
	HLLZS	RPS
	PUSHJ	P,CFLSYM
	MOVE	T5,[.5KBIT,,1]	; ELIMINATE PATCH AREA
	MOVEM	T5,%PATCH
	HRRZ	T5,KCOUNT
	LSH	T5,10.		; ZERO MEMORY
	MOVE	T6,[PDP11,,PDP11+1]
	SETZM	PDP11
	SKIPE	KCOUNT
	MOVE	T6,[PDP11,,PDP11+1]
	SETZM	PDP11
	SKIPE	KCOUNT
	BLT	T6,PDP11-1(T5)

CSNL1:	MOVE	A,LODJFN	; READ THE LEADER
	BIN
	JUMPE	B,CSNL1
	CAIE	B,1		; MUST FOLLOW WITH A 1
CSLERR:	 ERROR	[ASCIZ /ILLEGAL LDA FILE/]
	BIN			; THEN A 0
	JUMPN	B,CSLERR
	PUSHJ	P,CSWRD		; GET BYTE COUNT
	MOVEI	T6,-6(B)	; STORE IT IN T6
	PUSHJ	P,CSWRD		; GET ADDRESS
	MOVE	T5,B		; CALCULATE HOW MUCH MEMORY NEEDED
	ADDI	T5,3777(T6)
	LSH	T5,-11.
	MOVE	T1,B		; GENERATE POINTER TO WORD
	ROT	T1,-1		; TURN INTO WORD POINTER
	JUMPE	T6,CSLEND	; JUMP BLOCK?
	TLC	T1,700000	; EXTEND DEVICE ADDRESSES TO 18 BITS
	TLCE	T1,700000
	SUB	T5,KCOUNT
	SKIPLE	T5
	PUSHJ	P,ACORE

CSNL2:	MOVE	A,LODJFN	; GET A BYTE TO STORE
	BIN
	JUMPGE	T1,.+3
	DPB	B,[101000+T1,,PDP11]
	AOJA	T1,.+2
	DPB	B,[001000+T1,,PDP11]
	TLC	T1,400000
	SOJG	T6,CSNL2
	MOVE	A,LODJFN	; SKIP THE CHECKSUM
	BIN
	JRST	CSNL1		; END OF BLOCK

CSLEND:	JUMPL	T1,.+3
	 ROT	T1,1
	 HRRM	T1,%GO
	MOVE	A,LODJFN
	BIN			; IGNORE THE CHECKSUM

;;; READ SYMBOL TABLE.
	BIN
	CAIE B,2		; SYMBOLS?
	 JRST CSSEND		; NO, DONE
CSSL1:	CALL CSWRD
	JUMPE B,CSSEND		; 0 MARKS END OF SYMBOLS
	CALL CSUNPK
	MOVE T1,B
	CALL CSWRD
	CALL CSUNPK
	HRLZ T2,T1		;DEFSY2 ARG: T2 = SIXBIT SYMBOL NAME
	HRR T2,B		; ...
	PUSH P,T2
	CALL CSWRD		;GET PALX FLAGS
	HRLZ T3,B
	CALL CSWRD		;GET VALUE
	HRR T3,B
	POP P,T2
	TLNE T3,10000
	 JRST CSSL1		;SKIP SYMBOL IF UNDEF.
	TLZ T3,353760		;CONVERT PALX11 TYPE BITS TO 11SIM'S.
	TLZE T3,4000
	 TLOA T3,1		;MOVE REGISTER FLAG. ELSE,
	  TRNE T3,-1		;IF VALUE IS 0, .5KILL .
	   TLZE T3,20000
	    TLO T3,400000	;MOVE .5KILL FLAG.
	PUSHJ P,DEFSY2		;DEFINE IT, GET STE.
	MOVEM T3,1(T5)
	JRST CSSL1

CSSEND:	MOVE	A,LODJFN
  TXY[	CLOSF
  	 TDN   ]
  TXN[	.CLOSE LOADCH,]
	JRST	CCR

CSWRD:	MOVE	A,LODJFN	; READ LOW ORDER BYTE
	BIN
	MOVE	T2,B
	BIN
	LSH	B,8.
	IOR	B,T2
	RETURN

CSUNPK:	IDIVI B,50*50
	IDIVI C,50
	MOVE B,R50SIX(B)
	LSH B,6
	IOR B,R50SIX(C)
	LSH B,6
	IOR B,R50SIX(D)
	RETURN

R50SIX:		' 
REPEAT 26.,	.RPCNT+'A
		'$
		'.
		'%
REPEAT 10.,	.RPCNT+'0

LODJFN:	-1

TXN[
itsbin:	push	p,d		; save d
	move	a,ldptr		; get byte pointer
	move	d,[-1,,ldword]
	tlnn	a,700000	; byte pointer at end of word?
	 .iot	loadch,d	; no, read a word
	tlnn	a,700000	; byte pointer at end of word?
	 hrri	a,ldword-1	; reset word part
	ildb	b,a		; load a byte into B
	movem	a,ldptr
	pop	p,d
	popj	p,		; return
]


;UPDATE ALL OBRAN1 MACROS WHEN TRPPNT MIGHT HAVE CHANGED.
;OBRAN1 IS USED TO EXIT FROM A BRANCH INSN, TO EXECUTE
;THE ACTIONS NECESSARY FOR TRPPNT VALUES 0 AND 1 AS FAST AS POSSIBLE.
CSLTP1:	MOVE T3,TRPPNT
	MOVE T3,[JRST INEND	;IF TRPPNT 0, NO DEBUGGING ACTION.
		 MOVE B,OPC	;1, MOVE OPC INTO JPC.
		 JRST BRPNT	;2, GO TO PRINT RTN.
		 JRST BRPNT](T3);3, DITTO.
	MOVEI T5,CSLTP3	;GET ADDR OF OBRAN1 LIST HEADERR.
CSLTP2:	SKIPN T5,(T5)	;T5 -> NEXT OBRAN1'S LAST WD.
	 RET		;ALL HANDLED.
	MOVEM T3,-3(T5)	;CLOBBER 1ST WD OF THE OBRAN1.
	JRST CSLTP2

TXN[
; :XFILE COMMAND -- EXECUTE COMMAND FILE.
CXFILE:	MOVEI	A,CXFILN
	TLO	SF,D1CHAR	;IN CASE CMD WAS FOLLOWED BY CR.
	PUSHJ	P,DGFIL
	TSOPEN	UTIC,CXFILN
	SETOM	FILINF
	RETURN

CXFILN:	SIXBIT/   DSK      XCT/
]
; :CORE COMMAND -- SET TOTAL AMOUNT OF CORE TO ARG.
CCORE:	TLNN	SF,NUMFND
	SKIPA	T5,KCOUNT	;IF NO ARG, JUST PRINT NUM. K.
	MOVEI	T5,(DL)
CCORE1:	SUB	T5,KCOUNT	;AMOUNT OF K TO GO OR COME.
	JUMPGE	T5,ACORE	;IF >0, ATTACH. IF=0, JUST PRINT NUM. K.
	MOVM	T5,T5
	JRST	DCORE		;ELSE GO DETACH.

; ^L ROUTINE.
CFORMF:	SKIPE	GETTY
	TTOA	[ASCIZ/C/]	;CLEAR SCREEN.
	JRST	DLOOP1

TXN[
; :LOOKUP -- FIND ADDR OF STE OF FOLLOWING SYMBOL.
CLOOKU:	PUSHJ	P,GPASST
	PUSHJ	P,DGSYM
	JUMPE	T2,DERR
	PUSHJ	P,DLKSYM	;SEARCH FOR STE.
	MOVEI	DL,(T5)
	.VALUE	[ASCIZ \T5/	'\]
	RETURN
]
; :ZTIME -- SET CUMULATIVE RUN TIME TO 0.
CZTIME:	MOVN	B,RTIME		;-THE TIME.
	MOVEI	A,CLINF		;WILL SHIFT ALL REMEMBERED TIMES SAME AMOUNT.
CZTIM0:	MOVE	A,1(A)		;ADDR OF NEXT BLOCK.
	CAIN	A,CLINF
	JRST	CZTIM1		;ALL DONE WHEN GET BACK TO CLINF.
	ADDM	B,(A)		;ELSE ADJUST THE TIME,
	JRST	CZTIM0		;DO NEXT BLOCK.
CZTIM1:	ADDM	B,ORGTIM	;ADJUST PK'S BASE TIME.
	ADDM	B,LBUSET	;ADJUST REMEMBERED TIMES OF BUSS ERRORS.
	ADDM	B,LBUSET-4
	ADDM	B,LBUSET-8
	SETZM	RTIME		;FINALLY ZERO TIME.
	HLLZS	RATE
TXN	.SUSET	[.RRUNT,,RUNTB]
TXY[	MOVEI	A,400000
	RUNTM
	IMULI	A,250.
	MOVEM	A,RUNTB
]
	RETURN

TXN[
DCKSUM:	0

CADUMP:	PUSHJ P,DMPFL.	;GET THE DUMP FILE NAME
	TSOPEN DMPCH,DSLDEV
	PUSHJ P,DGRAN	;GET ARG TO COMMAND
	MOVN A,T1	;LAST ADDRESS TO DUMP
	ANDI T0,77777
	MOVE T1,T0	;FIRST ADDRESS TO DUMP
	ADD A,T0
	LSH T1,1	;T0 IS A POINTER INTO CORE, T1 IS THE ASSOCIATED PDP11 ADDRESS
	LSH A,1	;MAKE INTO PDP11 ADDRESS
	MOVEI T2,177777	;16 BITS
CADMP1:	SETZM DCKSUM
	MOVNI T3,2	;RELATIVE ADDRESS OF START ADDRESS IN BUFFER
	TDNE T2,PDP11(T0)	;SEARCH FOR A NON-ZERO WORD
	JRST CADMP2	;FOUND ONE
	ADDI T1,2	;NEXT PDP11 ADDRESS
	CAMGE T1,A	;ARE WE OVER THE TOP OF WHAT WE SHOULD DUMP?
	AOJA T0,CADMP1	;NO, INCREMENT PDP10 ADDRESS AND CONTINUE LOOKING
	JRST CADMP3	;CORE IS ALL ZERO, GO DUMP SYMBOLS
CADMP2:	MOVE T6,T1	;OUTPUT START ADDRESS
	PUSHJ P,CADOUT
CADMP4:	MOVE T6,PDP11(T0)	;GET A WORD TO DUMP
	PUSHJ P,CADOUT	;DUMP THE WORD
	ADDI T1,2	;NEXT PDP11 ADDRESS
	CAIGE T3,70	;IS THE BUFFER FULL?
	CAML T1,A	;OR ARE WE AT THE TOP OF THE SPACE TO BE DUMPED?
	JRST CADMP5	;YES, DUMP THE BLOCK
	MOVEI T6,10(T1)
	CAML T6,A	;ARE WE NEAR THE TOP OF THE SPACE TO BE DUMPED?
	AOJA T0,CADMP4	;YES, INC PDP10 ADDRESS AND DUMP RIGHT UP TO THE TOP
	TDNE T2,PDP11+1(T0)	;IF THERE ARE NOT 3 CONSECUTIVE ZEROS
	AOJA T0,CADMP4	;INC THE PDP10 ADDRESS AND KEEP DUMPING
	TDNE T2,PDP11+2(T0)
	AOJA T0,CADMP4
	TDNE T2,PDP11+3(T0)
	AOJA T0,CADMP4
CADMP5:	MOVEI T6,6(T3)	;DUMP THE CURRENT BLOCK
	MOVNI T3,4	;PLACE TO PUT THE BYTE COUNT
	PUSHJ P,CADOUT	;OUTPUT THE COUNT
	MOVN T3,DCKSUM	;GET CHECKSUM
	SUBI T3,1	;THE 1 AT THE BEGINING OF THE BLOCK WAS NOT ADDED BEFORE
	ANDI T3,377	;MASK TO 8 BITS
	MOVEM T3,CADMPB(T6)	;STORE CHECKSUM
	MOVNI T6,1(T6)	;NEGATIVE COUNT OF BYTES (1 ADDED TO COUNT CHECKSUM)
	HRLZS T6	;MAKE AOBJN POINTER
	HRRI T6,CADMPB
	.IOT DMPCH,T6	;OUTPUT BLOCK TO DISK
	AOJA T0,CADMP1	;INC PDP10 ADDRESS AND SEARCH FOR NON-ZERO CORE

CADMP3:	MOVEI T0,6	;GET READY TO OUTPUT START (JUMP) BLOCK
	MOVEM T0,DCKSUM	;INIT CHECKSUM
	MOVEM T0,CADMPB+2	;SET BYTE COUNT
	MOVNI T3,2	;PLACE FOR ADDRESS
	MOVE T6,%GO	;STARTING ADDRESS
	PUSHJ P,CADOUT	;OUTPUT TO BUFFER
	MOVN T0,DCKSUM	;GET CHECKSUM
	SUBI T0,1	;CORRECT IT
	ANDI T0,377	;MASK TO 8 BITS
	MOVEM T0,CSLBUF	;THIS IS WHERE IT BLONGS
	MOVE T0,[-7,,CADMPB]	;JUMP BLOCK IS ALWAYS THIS LONG
	.IOT DMPCH,T0
	HRROI T0,[LDSYMS]	;START OF SYMBOLS
	.IOT DMPCH,T0
	;THE FOLLOWING CHANGES 11SIM TYPE FLAGS TO PALX11 TYPE FLAGS
	MOVEI T0,SYMDMP+1
	MOVSI T1,1
	MOVSI T2,4000
	MOVSI T3,20000
	MOVSI T5,24000
CADMP6:	TDZ T5,(T0)
	TDNE T1,(T0)
	TDO T2,(T0)
	SKIPGE (T0)
	TDO T3,(T0)
	ADDI T0,2
	CAMG T0,SYMEND
	JRST CADMP6
	MOVEI T0,SYMDMP	;NOW MAKE UP AN AOBJN POINTER
	SUB T0,SYMEND	;WHICH WE CAN USE
	HRLZS T0	;TO OUTPUT THE SYMBOL TABLE
	HRRI T0,SYMDMP
	.IOT DMPCH,T0	;ALL AT ONCE
	MOVE T0,[-1,,[0]]
	.IOT DMPCH,T0	;OUTPUT A ZERO FOR THE END TEST
	.CLOSE DMPCH,
	RETURN

CADOUT:	PUSH P,T6	;BREAK A PDP11 WORD INTO BYTES AND OUTPUT IT TO THE BUFFER
	ANDI T6,377
	MOVEM T6,CSLBUF(T3)
	ADDM T6,DCKSUM
	AOS T3
	MOVE T6,(P)
	LSH T6,-10
	ANDI T6,377
	MOVEM T6,CSLBUF(T3)
	ADDM T6,DCKSUM
	AOS T3
	POP P,T6
	RETURN
DEFINE	DMPOW	A
	HRROI	T6,A
	.IOT	DMPCH,T6
TERMIN

;OPEN A TEMPORARY DUMP FILE FOR CURRENT COMMAND ONLY.
CODMP1:	SKIPE	DDUMPF
	POPJ	P,		;IF PERMANENT DUMP FILE, USE IT.
	JRST	CODMP2		;ELSE, OPEN A FILE.

; :ODMP -- OPEN A FILE FOR SEVERAL DUMP COMMANDS.
CODMP:	SKIPE	DDUMPF
	ERROR	[ASCIZ/WITHOUT CLOSING THE OTHER ONE/]
	PUSHJ	P,CODMP2	;OPEN PERM. FILE.
	SETOM	DDUMPF		;IF SUCCEED, INDICATE ONE IS OPEN.
	RETURN

CODMP2:	PUSHJ	P,DMPFL.
	TSOPEN	DMPCH,DSLDEV
	RETURN

; ;Y -- ALMOST SAME AS :DMP
CSY:	PUSH	P,[CCR]
	SKIPE	DDUMPF
	CRF			;IF PERM FILE, NEED NO ARG.
	SKIPN	DDUMPF
	TTOI	" 
	MOVEI	T0," 		;DON'T REREAD "Y".

; :DMP -- DUMP RANGE OF CORE, AND SYMBOLS.
CDMP:	PUSHJ	P,CODMP1	;OPEN TEMP. FILE IF NECESSARY.
	PUSHJ	P,CSD0		;DUMP RANGE OF CORE.
	PUSHJ	P,DMPTPV	;DUMP TRAP ACTION CODES.
CDMP2:	PUSHJ	P,DMPSYM	;DUMP SYMBOLS.
	JRST	CDUMPX		;CLOSE FILE IF TEMPORARY.

; :DMPCOR -- DUMP SPECIFIED RANGE OF CORE, ONLY.
CDMPCO:	PUSHJ	P,CODMP1
	PUSHJ	P,CSD0
CDUMPX:	SKIPE	DDUMPF		;IF DUMP FILE TEMPORARY, CLOSE IT.
	RETURN
	DMPOW	[[LDEND]]	;OUTPUT AN END BLOCK,
	.CLOSE	DMPCH,
	RETURN

; :DMPSYM -- DUMP SYMBOLS ONLY.
CDMPSY:	PUSHJ	P,CODMP1
	JRST	CDMP2

;READ A FILENAME INTO DSLDEV FOR LOADING, DUMPING RESP.
LODFL.:	SKIPA	A,[6,,]
DMPFL.:	MOVSI	A,7
	HLLM	A,DSLDEV
	MOVEI	A,DSLDEV
	TLO	SF,D1CHAR
	JRST	DGFIL

; :DMPTPV - DUMP TRAP-ACTION-CODES.
CDMPTP:	PUSHJ	P,CODMP1
	PUSHJ	P,DMPTPV
	JRST	CDUMPX

DMPTPV:	DMPOW	[[LDTPV]]
	MOVE	T6,[-TRPPTL,,TRPPNT]
	.IOT	DMPCH,T6
	RETURN

; :CDMP -- CLOSE PERMANENT DUMP FILE.
CCDMP:	SETZM	DDUMPF
	JRST	CDUMPX

DMPSYM:	DMPOW	[[LDSYMS]]
	MOVN	T6,SYMEND
	HRLZI	T6,SYMDMP-2(T6)
	HRRI	T6,SYMDMP
	.IOT	DMPCH,T6
	DMPOW	[[0]]
	RETURN

DSLDEV:	SIXBIT/   DSK      BIN/

;INTERPRET ARG AS RANGE OF CORE TO DUMP.
CSD0:	PUSHJ	P,DGRAN
	MOVE	T5,T0

;DUMP OUT ALL CORE, AS BLOCK TYPES COR AND ZER.
DSD1:	DMPOW	[[LDAK]]	;BLOCK TO INSURE ENOUGH CORE
	HLRO	T2,T5
	MOVN	T2,T2		;NUM. WDS. BEING DUMPED.
	ADDI	T2,1777(T5)
	LSH	T2,-10.	;NUM. OF THE K CONTAINING LAST WD DUMPED.
	DMPOW	T2
	SKIPE	PDP11(T5)	;WHICH TYPE BLOCK FIRST?
	JRST	CSDCOR		;IF NONZERO, COR BLOCK FIRST.
CSDZER:	MOVEI	T2,-1(T5)	;WD BEFORE 1ST IN BLOCK.
CSDZE0:	SKIPN	PDP11(T5)
	AOBJN	T5,CSDZE0	;MOVE TILL NONZERO WD OR END OF RANGE.
	MOVEI	T1,1(T2)
	SUBI	T1,(T5)
	HRLI	T2,(T1)		;IOWD LENGTH, ADDR  .
	MOVEI	T1,LDCORZ
	MOVE	T6,[-2,,T1]
	.IOT	DMPCH,T6
	JUMPGE	T5,CPOPJ	;IF EXHAUSTED RANGE TO DUMP.

CSDCOR:	MOVEI	T2,-1(T5)	;WD BEFORE 1ST IN BLOCK.
CSDCO1:	SKIPN	PDP11(T5)
	SKIPE	PDP11+1(T5)
	AOBJN	T5,CSDCO1	;ADVANCE TILL END, OR 2 ZEROS.
	MOVEI	T1,1(T2)
	SUBI	T1,(T5)
	HRLI	T2,(T1)		;IOWD LENGTH, ADDR  .
	MOVEI	T1,LDCOR
	MOVE	T6,[-2,,T1]
	.IOT	DMPCH,T6
	HRRI	T2,1+PDP11(T2)	;AOBJN PTR FROM IOWD.
	.IOT	DMPCH,T2
	JUMPL	T5,CSDZER	;IF NOT AT END.
	RETURN
]

; ;X - EXECUTE THE FOLLOWING INSN.
CSX:	TTOI	" 
	SETOM	CSXR1
	MOVE	T5,R1
	ANDI	DL,177777
	TLNE	SF,NUMFND	;IF HAD ARG,
	HRRZM	T5,CSXR1	;SAVE R1,
	TLZE	SF,NUMFND
	HRRM	DL,R1		;PUT ARG II IT.
	HRRZ	DO,%CSX		;ADDR. TO STORE INSN IN.
	ANDCMI	DO,1
	SETOM	DGVLVL
	TLZ	SF,DBYTM
	PUSHJ	P,DGVAL		;READ THE INSN.
	TLO	SF,NUMFND
	MOVE	T5,OPNMDP	;STORE INSN IN I-SPACEE OF CURRENT
	MOVEM	T5,OPNMD1	;PROCESSOR MODE.
	MOVEI	DL,(T2)
	SKIPE	DGVALP		;IF GOT ONE, STORE IT.
	PUSHJ	P,DCLOSB
	HRRO	T5,R7
	MOVEM	T5,CSXPC	;SAVE PC WHILE SIMULATING INSN.
	MOVE	T5,PC-SAVLNG(P)	;GET SAVED OLD PC.
	MOVEM	T5,CSXSPC	;REMEMBER IT.
	ANDI	DO,177777
	HRRM	DO,R7
	MOVE	T5,DDONXT
	MOVEM	T5,CSXDNX
	MOVE	T5,%IL
	MOVEM	T5,CSXIL	;SAVE LENGTH OF NEXT INSN.
	MOVE	T5,%CSN
	MOVEM	T5,CSXCSN	;SAVE ;N MODE, LEAVE IT.
	HLLOS	%CSN
	MOVE	T5,-17(P)	;SAVE DDT'S CURRENT RETADDR.
	MOVEM	T5,CSXRET
	JRST	CSP

CSXPC:	0
CSXR1:	0
CSXDNX:	0
CSXRET:	0
CSXSPC:	0
CSXIL:	0
CSXCSN:	0

CSXHAK:	SKIPL	DDTPDP
	TLNN	B,10000		;ATTEMPTED TO FETCH INSN AFTER
	RETURN			; ;X'ED INSN:
	SKIPN	CSXPC		;RETURN TO DDT.
	RETURN
	REST	B
	HRRZ	PC,CSXPC
	HRRM	PC,R7
	HRRM	PC,%PC
	MOVE	PC,CSXSPC	;RESTORE SAVED ENTRY PC.
	SAVE	CSXRET		;  RETURN ADDR,
	SAVE	[DDTXIT]
	SETZM	CSXPC
	CALL	SAVALL
	SETZM	RUN
	MOVEM	P,DDTPDP	;ENTER DDT WITHOUT PRINTING INSN.
	MOVEM	TIME,RTIME
	HRRM	PS,RPS
	MOVE	T5,CSXDNX
	MOVEM	T5,DDONXT
	MOVE	T5,CSXCSN
	MOVEM	T5,%CSN
	MOVE	T5,CSXIL
	MOVEM	T5,%IL
	SKIPL	T5,CSXR1	;RESTORE R1 IF WAS SAVED.
	HRRM	T5,R1
	PUSHJ	P,MERRV		;TURN ON TTY.
45Y[	MOVE	T5,45REGY	;STORE AWAY CURRENT REGISTER SET, SO BOTH SETS'
	MOVE	T6,T5		;VALUES LIVE IN THEIR BACKUP HOMES.
	BLT	T5,5(T6)
	LDB	T5,[45CMOD,,PS]	;GET CURRENT PROCESSOR MODE.
	MOVE	T6,R6
	HRRM	T6,45REG6(T5)	;STORE SELECTED R6 IN ITS BACKUP HOME.
]
	HRLZ	SF,%TMODE
	TTOI	"!
	JRST	DDT2

; :S%CSX - SET %CSX AND STORE CSX DEVICES.
CS%CSX:	MOVEI	T2,45Y[600000+]177720	;NORMAL VAL. OF %CSX IS DEFAULT.
	TLNE	SF,NUMFND
	MOVE	T2,DL
CS%CS0:	TLNE	T2,REGBIT
	ERROR	[ASCIZ/TO ACCUM./]
	TRNE	T2,1
	ERROR	[ASCIZ/ODD ADDRESS/]
	HRRZ	T5,%CSX		;OLD ADDR.
	LSH	T5,-1
	HRLI	T5,-3		;REMOVE THE 3 OLD CSX DEVICES:
CS%CS2:	MOVE	T6,PDP11+1(T5)
	TLZ	T6,777		;REMOVE THE DEVICE CODE.
	TLNN	T6,177000	;UNLESS BKPT THERE,
	TLZ	T6,400000	;TURN OFF SPECIAL BIT.
	MOVEM	T6,PDP11+1(T5)
	AOBJN	T5,CS%CS2
	HRRM	T2,%CSX		;STORE NEW ADDR.
	ROT	T2,-1
	ANDI	T2,77777
	HRLI	T2,-3
CS%CS1:	MOVE	T5,PDP11+1(T2)	;STORE CSX DEVS THERE+1 THRU THERE+3 .
	TLZ	T5,777
	TLO	T5,600000+NCSX
	MOVEM	T5,PDP11+1(T2)
	AOBJN	T2,CS%CS1
	RET

; ^\ COMMAND - ALMOST AS IN HACTRN.
CCBSL:	MOVE	DL,%PATCH	;PATCH WILL -> PATCH AREA.
	PUSHJ	P,CPAT0		;STORE THE PATCH.
	JRST	CTAB		;OPEN LOC. ADDRESSED BY PATCH.

; ^] COMMAND
CCRB:	JUMPL	DO,CPATNO	;IF NO LOC. OPEN.
	TLNN	SF,NUMFND	;IF HAVE ARG,
	JRST	CCRB1
	CALL	DCLOSE		;STORE IT,
	ADDI	DO,(DLEN)	;PATCH AFTER IT.
CCRB1:	HRRZ	DL,%PATR	;PATCH BACK INTO SEQUENCE.
	SETOM	CPATTY
	CALL	CPAT3		;STORE THE PATCH.
	ADDI	DO,2
	HRRM	DO,%PATCH	;UPDATE PATCH AREA ADDR.
	HRRM	DL,DPNT		;SET . TO PLACE PATCH WAS FROM (%PATR).
	JRST	CCRLF

; :PAT - PUT IN THE OPEN LOC., A PATCH DEVICE -> ARG.
CPAT:	CALL	DGVPSP		;READ ADDR. OF PATCH.
	MOVE	DL,T2
	SKIPE	DGVALP		;REQUIRES AN ARG.
	CAIE	DLEN,2		;MUST HAVE ARG OF LENGTH 2.
	ERROR	[ASCIZ/WHITHER/]
CPAT0:	JUMPL	DO,CPATNO	;IF NO LOC. OPEN.
	SETZM	CPATTY
CPAT3:	TLNE	SF,BYTOPN
	ERROR	[ASCIZ/PATCH BYTE/]
	TLNE	DO,REGBIT
	ERROR	[ASCIZ/PATCH ACCUM./]
	TLNE	DL,REGBIT
	ERROR	[ASCIZ/TO ACCUM./]
	TRNE	DL,1
	ERROR	[ASCIZ/TO ODD ADDRESS/]
	TLZ	SF,NUMFND	;ENSURE ADDR. IS STORED.
	MOVE	T5,OPNMDL
	MOVEM	T5,OPNMD1
	PUSHJ	P,DCLOS0	;SET UP ADDR IN T3.
	SKIPGE	PDP11(T3)
	JSP	D,MTRAPW
	DPB	DL,[2000+T3,,PDP11]
	MOVEI	T5,600000+NCPAT
	HRLM	T5,PDP11(T3)	;TURN LOC. INTO A PATCH.
	SKIPE	CPATTY		;IF NOT ^],
	RET
	ADDI	DO,@%OL		;FIND END OF INSN REPLACED,
	HRRM	DO,%PATR	;^] WILL PATCH BACK THERE.
	RET

;COME HERE ON ACCESSING A PATCH-DEVICE.
CPATHA:	SKIPE	DDTPDP
	JRST	CPAT1
	POP	P,(P)		;DELETE RET. ADDR. IN MTRAP.
	TLNE	B,66000
	JRST	MTRAP2		;IF RRAD OR WROTE, TREAT AS BKPT.

CPAT2:	MOVEI	PC,(A)		;IF FETCHING, 
	LSH	PC,-1		;BRANCH TO ADDRESSED LOC.
	OBRAN1

;COME HERE IF ACCESSED BY DDT.
CPAT1:	TLNE	B,20000
	SETZM	@-2(D)		;IF WRITING, FLUSH THE PATCH.
	TLNN	B,20000		;IF READING,
	TLNE	SF,DEXCM	;IF NOT ! MODE,
	RETURN
	TTOA	[ASCIZ/  :PAT/]	;ANNOUNCE THE PATCH.
	RETURN

CPATNO:	ERROR	[ASCIZ/WHENCE/]

; :ALTSEM -- EXCHANGE FUNCTIONS OF ; AND $ IN COMMANDS.
CALTSE:	SETCMM	CALTSF
	MOVEI	T5,"
	MOVEI	T6,";
	SKIPN	CALTSF		;IF NOW SWITCHED STATE,
	JRST	CALTS0
	MOVEM	T5,SEMICL	;$ TREATED AS ;,
	MOVEM	T6,ALTMOD	;; TREATED AS $.
	TTOA	[ASCIZ/SWITCHED
/]
	RETURN

CALTS0:	MOVEM	T5,ALTMOD	;NORMAL STATE, $ TREATED AS $,
	MOVEM	T6,SEMICL	;; TREATED AS ;.
	TTOA	[ASCIZ/NORMAL
/]
	RETURN

; ;N - LIKE $$^N IN 10-DDT.
CSN:	TLNE	SF,NUMFND	;IF NO ARG,
	JRST	CSN2
	HRRZ	DL,%PC		;USE ADDR AFTER END OF NEXT INSN.
	ADDI	DL,@%IL
CSN2:	LSH	DL,-1		;WILL COMPARE WITH PC.
	ANDI	DL,77777
	HRRM	DL,%CSN		;RUN TILL GET THERE.
	HRLOI	T5,277777
	MOVEM	T5,INSCNT
	JRST	CSN1

;GO TO ADDRESS ARG.
CSG:	TLNN	SF,NUMFND
	HRRZ	DL,%GO		;IF NO ARG, USE STARTING ADDR.
	ANDI	DL,177777
	HRRM	DL,R7		;IF HAD ARG, GO TO THAT ADDR.
	SETOM	PC-SAVLNG(P)	;INDICATE TERMINATE INSN.
	AOJ	T2,
	MOVEM	T2,INSCNT	; ;G WITH INNER ARG MEANS STEP
	SKIPE	DGVALP		;THAT MANY INSNS.
	JRST	CSN1
CSP:	MOVE	T5,%CSN		;IF IN ;N MODE
	CAME	T5,[.5KBIT,,-1]
CSN1:	SKIPA	T2,[JRST CNTINS]
45N	MOVE	T2,[SKIPGE I,PDP11(PC)]
45Y	MOVE	T2,[MOVE MA,PC]
CSP1:	MOVEM	T2,INBEG
TXN[	SKIPE	ETNFIN		;IF DT WAS CHANGED, NOT FINISHED,
	CALL	ETOFIN		;FINISH IT NOW.
]
	HRRZ	T5,R7
	TRNE	T5,1		;TRAP IF NEW PC ODD.
	JSP	D,DBNDE
	MOVE	C,RTIME		;TURN OFF DDONXT AFTER 1 INSN AT MOST.
	AOS	C
	MOVEI	A,DDTXTP
	PUSHJ	P,CLQADD
RSTALL:	HRLZI	T6,-SAVLNG+1(P)	;SET UP BLT POINTER.
	HRRI	T6,A
	BLT	T6,T6
	SUB	P,[SAVLNG,,SAVLNG]	;POINT TO BEFORE SAVED REGS.
	POP	P,RSTPC		;RESTORE FLAGS.
	JRSTF	@RSTPC

DDTXIT:	HRRZ	TIME,R7
	ROT	TIME,-1
	CAMN	TIME,PC		;IF PC CHANGED,
	JRST	DDTXI1
INSIRP	SETZM	0,DDONXT WAITFL PDLFT PDLNFT
45Y	SETZM	IMTPR6
	SETZM	(P)		;START AT BEGINNING OF INSN.
	MOVEI	PC,(TIME)
DDTXI1:	MOVE	TIME,RTIME
TXN	.RESET	TYIC,
	CRF
TXN[	.CALL	TTYM2
	 .LOSE	%LSFIL
]
	SETZM	DDTPDP
	SETOM	RUN
45Y[
	MOVS	A,45REGY	;COPY THE RIGHT SET OF REGISTERS INTO R0-R5
	BLT	A,R5
	MOVE	A,45MODE
	MOVE	A,45REG6(A)
	HRRM	A,R6		;SELECT THE RIGHT COPY OF R6.
]
	HRRZ	PS,RPS		;NOW RESELECT THE RIGHT PROCESSOR MODE
	NEWPS			;IN CASE USER DEPOSITED IN %PS.
	SETOM	OPC		;INDICATE JUST LEFT DDT.
	POP	P,RSTPC
	SKIPE	RSTPC
	JRSTF	@RSTPC
	MOVE	P,[-PDLSIZ,,PDL]
	JRST	INEND		;RET. ADDR. 0 MEANS RESTART.

DDTXTP:	0
	-1
	SETZM	DDONXT

TXN[
TTYGT:	SETZ
	SIXBIT/TTYGET/
	[TYIC]
	2000,,T0
	2000,,T0
	402000,,A

;NORMAL DDT TTYSET.
TTYM1:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[232420,,222222]
	[230222,,220222]
	400000,,TTYM1A

;NORMAL SIMULATOR TTYSET.
TTYM2:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[131313,,131313]
	[131313,,131313]
	400000,,TTYM1A

;DDT TTYSET TO ACTIVATE ON NEXT CHAR.
TTYMA:	SETZ
	SIXBIT/TTYSET/
	[TYIC]
	[232420,,222222]
	[230222,,220222]
	400000,,TTYMAA
]
TTYM1A:	0		;SET UP AFTER TTYGT AFTER $G'D.
TTYMAA:	0

IOCTAB:	BLOCK IOCNUM
IOCEND:

ALTMOD:	"	;CHAR TREATED AS $ (EITHER $ OR ;).
SEMICL:	";	;CHAR TREATED AS ; (EITHER $ OR ;, NOT=ALTMOD).
CALTSF:	0	;NOT 0 IFF $ AND ; ARE SWITCHED.
OPC:	0	;ADDR OF CURRENT OR PREVIOUS INSN.
JPC:	0	;ADDR OF LAST INSN THAT CHANGED THE PC, OR TRAPPED.
		;PROVIDED FEATURE ENABLED FOR THAT TYPE OF TRAP.
		;SEE ;T COMMAND. AND TRPPNT VECTOR.
GETTY:	0	;SET IFF GRAPHICS TTY.
INSCNT:	0	;NUM. INSNS TO EXECUTE IN SNGL-STEP MD.
CPATTY:	0	;LOCAL TO CPAT, CCRB, CCBSL.
RSTPC:	0
DDTPDP:	0
DDONXT:	0
CSLFLG:	0
DRDBRF:	0
DINITF:	0
DGVLVL:	-1		;LEVEL OF RECURSION AT DGVAL.
DGVRGP:	0		;NONZERO IF THIS VALUE IS REGISTER NUM.
DGVALP:	0		;NONZERO IF DGVAL, DGNUM ETC. FINDS A VALUE.
S%OLFL:	0	;SET WHILE %Q REMAINS WHAT WAS OPENED.
DDUMPF:	0	;SET IF PERMANENT DUMP FILE OPEN.

OPNMD1:	0	;1-SHOT MAPPING MODE FOR OPENING LOCATIONS.
OPNMDT:	0	;TEMP "
OPNMDP:	0	;PERM "
OPNMDL:	0	;MAPPING MODE USED TO OPEN CURREENTLY OPEN LOC.
LDPTR:	0	; stores byte pointer used in newbin loading
LDWORD:	0	; word for above

DNOARG:	ERROR	[ASCIZ/ARG/]

EXPUNG OBRAN1
CSLTP3:	OBRAN2	;HEAD OF CHAIN THAT RUNS THRU ALL OBRAN1'S.


IRP REGNUM,,[0,1,2,3,4,5,6]
R!REGNUM:	0
TERMIN			;PDP11 REGISTERS HERE.
R7:	600000+NPC,,0

VARIABLES
CONSTANTS	;DON'T WANT CONSTANTS AT END SO SYM TAB CAN VARY IN LENGTH

SYMEND:	LASTST		;ALWAYS -> LAST STE IN USE.

;INITIAL SYMBOL TABLE

;FORMAT OF STE:
;	WORD 1:	NAME OF SYMBOL, IN SIXBIT.
;	WORD 2:	SIGN BIT: IF SET, SYMBOL IS HALF-KILLED.
;		REST OF LH: SYMBOL TYPE.
;		RH:  VALUE.

	DEFINE	.5KILL	A,B,C
	SIXBIT/A/
	IFSN C,,C:
	IFSE C,,A:
	.5KBIT,,IFSN B,,B
	TERMIN

TXY[.=<<.+1>/2>*2]		;GO TO EVEN ADDR.
TXN[	.=.+<.&1>]		;GO TO EVEN ADDR.
SYMTAB:	REPEAT	10,[
	<'%_36>+<<'0+.RPCNT>_30>
	1,,.RPCNT
	]		;DEFINE %0 ... %7 .

;INSN. SPECIAL SYMBOLS.

	INSNUM==0
IRP INSN,,[MOV,CMP,BIT,BIC,BIS]
	INSNUM==INSNUM+1
	SIXBIT/INSN/
	2,,INSNUM
	SIXBIT/INSN!B/	;BYTE INSN DEF.
	2,,10+INSNUM
TERMIN
	SIXBIT/ADD/	;2 EXCEPTIONS.
	2,,6
	SIXBIT/SUB/
	2,,16

;SINGLE OPERAND INSN SYMBOLS.
	INSNUM==0
IRP INSN,,[CLR,COM,INC,DEC,NEG,ADC,SBC,TST,ROR,ROL,ASR,ASL]
	SIXBIT/INSN/
	3,,INSNUM+50	;WORD INSN.
	SIXBIT/INSN!B/
	3,,INSNUM+1050	;BYTE INSN.
	INSNUM==INSNUM+1
TERMIN

IRPS INSN,,[JMP 1,SWAB 3,SXT 67,MFPI 65,MTPI 66,MTPS 1064,MFPD 1065,MTPD 1066,MFPS 1067]
IFE 1&.IRPCN,SIXBIT/INSN/
.ELSE	3,,INSN
TERMIN

;BRANCH INSN SYMBOLS:
	INSNUM==0
IRP INSN,,[BR,BNE,BEQ,BGE,BLT,BGT,BLE]
	INSNUM==INSNUM+1
	SIXBIT/INSN/
	6,,INSNUM*400
TERMIN

	INSNUM==100000
IRP INSN,,[BPL,BMI,BHI,BLOS,BVC,BVS,BCC,BCS]
	SIXBIT/INSN/
	6,,INSNUM
	INSNUM==INSNUM+400
TERMIN

	SIXBIT/BHIS/
	6,,103000
	SIXBIT/BLO/
	6,,103400

	SIXBIT/JSR/
	4,,4
	SIXBIT/XOR/
	4,,74
	SIXBIT/RTS/
	5,,20

	SIXBIT/TRAP/
	7,,104400
	SIXBIT/EMT/
	7,,104000

	SIXBIT/SFL/
	10,,260
	SIXBIT/CFL/
	10,,240

	SIXBIT/SOB/
	13,,0
	SIXBIT/MARK/
	13,,1
	SIXBIT/SPL/
	13,,2

	INSNUM==70
IRP INSN,,[MUL,DIV,ASH,ASHC]
	SIXBIT/INSN/
	14,,INSNUM
	INSNUM==INSNUM+1
TERMIN

	INSNUM==0
IRP INSN,,[HALT,WAIT,RTI,BPT,IOT,RESET,RTT]
	SIXBIT/INSN/
	INSNUM
	INSNUM==INSNUM+1
TERMIN

SYMDRG:
IRPS AA,,[
%TKS 177560,%TKB 177562,%TKV 60
%TPS 177564,%TPB 177566,%TPV 64
%PKC 172544,%PKCSB 172542,%PKCSR 172540,%PKV 104
%PPS 177554,%PPB 177556,%PPV 74
%PRS 177550,%PRB 177552,%PRV 70
%RKDS 177400,%RKER 177402,%RKCS 177404,%RKWC 177406
%RKBA 177410,%RKDA 177412,%RKV 220
%LKS 177546,%LKV 100
%LPS 177514,%LPB 177516,%LPV 200
%NGCSR 164040,%NGREL 164042
%ERRV 4,%BPTV 14,%IOTV 20,%PWRV 24,%EMTV 30,%TRPV 34
%DIV 177300,%AC 177302,%MQ 177304,%MUL 177306
%SR 177310,%SC 177311,%NOR 177312,%LGS 177314,%ARS 177316
%PS 177776,%SWR 177570,%PIR 177772,%PIRV 240
%CSR 175000,%BAR 175002,%BCR 175004,%TBR 175006
%RCSR 174000,%RBUF 174002,%TSCR 174004,%TBUF 174006,%DCRV 300,%DCTV 304
%DCS 177460,%DWC 177462,%DCA 177464,%DAR 177466
%DAE 177470,%DBR 177472,%DSA 177476,%DV 204
%WC 177462,%CMA 177464,%ADS 177476
%TCST 177340,%TCCM 177342,%TCWC 177344,%TCBA 177346
%TCDT 177350,%TCV 214
%SLR 177774,%PAGV 250,%SSR0 177572,%SSR1 177574,%SSR2 177576,%SSR3 172516
%SARU0 177640,%SDRU0 177600,%SARS0 172240,%SDRS0 172200,%SARK0 172340,%SDRK0 172300
]
	IFE 1&.IRPCN,	SIXBIT/AA/
	.ELSE		IFL AA-400,[SETZ] AA
TERMIN


SYMLST:	.5KILL	.,0,DPNT,	;SYMBOL . .
	.5KILL	%Q,0		;LAST QTY IN OR OUT.
	.5KILL	%P,0		;LAST PART OF MULTI-WORD EXP.
	.5KILL	%D,0		;LAST DEST. ADDR.
	.5KILL	%S,0		;LAST SRC. ADDR.
	.5KILL	%L,0		;LENGTH OF LAST QTY IN OR OUT.
	.5KILL	%OL,0		;LENGTH OF WHAT WAS LAST OPENED.
	.5KILL	%IL,0		;LENGTH OF INSN %PC POINTS TO.
	.5KILL	%CSN,-1		;RH IS -1 OR HALF PC TO STOP AT (;N).
	.5KILL	%.,0,DOPEN,	;LOCATION OPEN.
	.5KILL	%OPC,0		;PC OF CURRENT OR LAST INS.
	.5KILL	%B,0		;ADDR OF LAST BREAKPOINT.
	.5KILL	%CORE,0		;NUM. BYTES CORE.
	.5KILL	%,0,%PC,	;PC AT ENTRY TO DDT.
	.5KILL	%JPC,0		;SOMETIMES, ADDR OF LAST PC CHANGE.
	.5KILL	%PATR,0		;ADDR AFTER PLACE PATCH WAS PUT.
	OMODE==DINSM+DSYMM
SYMDMP:	.5KILL	%CSX,2*<RCSX-PDP11>	;ADDR FOR ;X .
	.5KILL	PATCH,1,%PATCH,	;PATCH AREA FOR ^\, ^].
	.5KILL	%PMODE,OMODE	;PERMANENT MODE.
	.5KILL	%TMODE,OMODE	;TEMPORARY MODE.
	.5KILL	%GO,0		;STARTING ADDRESS FOR ;G.
	.5KILL	%DMRV,310	;DM DEVICE RECEIVE TRAP VECTOR
	.5KILL	%DMTV,314	;DM TRANSMIT TRAP VECTOR.
IFN .-SYMDMP-SYMNSP*2,.ERR EDIT AT DEFSY2
LASTST=.-2

	END	BEG
