;;;;;;;;;;;;;;;;;;; -*- Mode: Lisp; Package: Macsyma -*- ;;;;;;;;;;;;;;;;;;;
;;;     (c) Copyright 1980 Massachusetts Institute of Technology         ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(macsyma-module sprdet)

;; THIS IS THE NEW DETERMINANT PACKAGE

(DECLARE (SPECIAL X $SPARSE $RATMX ML* *DETSIGN* RZL*) (GENPREFIX ND))

(DEFUN SPRDET(AX N)
  (DECLARE(FIXNUM N I J DM R))
  (PROG (J RODR CODR BL DET DM R I)
       (SETQ DET 1.)
       (*ARRAY 'PTR T  (1+ N))
       (*ARRAY 'PTC T  (1+ N))
       (SETQ BL (TMLATTICE AX 'PTR 'PTC N))
       (COND ((NULL BL)(RETURN 0)))
       (SETQ RODR(APPLY(FUNCTION APPEND) BL))
       (SETQ CODR(MAPCAR (FUNCTION CADR) RODR))
       (SETQ RODR(MAPCAR (FUNCTION CAR) RODR))
       (SETQ DET(*(PRMUSIGN RODR)(PRMUSIGN CODR)))
       (SETQ BL (MAPCAR (FUNCTION LENGTH) BL ))
       (SETQ R 0)
 LOOP1 (COND ((NULL BL) (RETURN DET)))
       (SETQ I (CAR BL) )(SETQ DM I)
       (*ARRAY 'BLK T (1+ DM)(1+ DM))
       (COND ((= DM 1.)
	      (SETQ DET (GPTIMES DET (CAR(FUNCALL AX (PTR (1+ R))(PTC(1+ R))))))
	      (GO NEXT))
	    ((= DM 2.)
	     (SETQ DET (GPTIMES DET
				(GPDIFFERENCE
				 (GPTIMES (CAR (FUNCALL AX (PTR (1+ R))(PTC (1+ R))))
					  (CAR (FUNCALL AX (PTR (+ 2. R))(PTC (+ 2. R)))))
				 (GPTIMES (CAR (FUNCALL AX (PTR (1+ R))(PTC (+ 2. R))))
					  (CAR (FUNCALL AX (PTR (+ 2. R))(PTC (1+  R))))))))
	     (GO NEXT)))
       LOOP2 (COND ((= I 0)(GO CMP)))
       (SETQ J DM)
       LOOP3 (COND ((= J 0) (SETQ I (1- I)) (GO LOOP2)))
       (STORE (BLK I J)(CAR  (FUNCALL AX  (PTR (+ R I))  (PTC(+ R J)))))
       (SETQ J (1- J)) (GO LOOP3)
       CMP
       (SETQ DET (GPTIMES DET (TDBU 'BLK DM)))
       NEXT   
       (SETQ R(+ R DM))
       (SETQ BL (CDR BL))
       (GO LOOP1)
       ))

(DEFUN MINORL (X N L NZ)
  (DECLARE(FIXNUM N2 N COL ))
  (PROG (ANS S RZL* COL N2 D DL Z A ELM RULE)
       (SETQ N2 (// N 2.))
       (SETQ N2(1- N2))
       (SETQ COL 1.)
       (SETQ DL L L NIL NZ (CONS NIL NZ))
       L1(COND((NULL NZ)(RETURN ANS)))
       L3(SETQ Z (CAR NZ))
       (COND ((NULL L) (COND (DL (SETQ ANS (CONS DL ANS)))
			     (T (RETURN NIL)))
		       (SETQ NZ (CDR NZ) COL (1+ COL) L DL DL NIL)
		       (GO L1)))
       (SETQ A (CAAR L) )
       L2(COND((NULL Z)
	       (COND (RULE (RPLACA (CAR L) (LIST A RULE))
			   (SETQ RULE NIL) (SETQ L (CDR L)))
		     ((NULL (CDR L))
		      (RPLACA (CAR L) (LIST A 0))
		      (SETQ L (CDR L)))
		     (T (RPLACA L (CADR L))
			(RPLACD L (CDDR L))))
	       (GO L3)))
       (SETQ ELM (CAR Z) Z (CDR Z))
       (SETQ S(SIGNNP ELM A))
       (COND(S(SETQ D (DELETE ELM (COPY1 A)))
	      (COND((MEMBERCAR D DL) (GO ON))
		   (T
		    (COND((OR(< COL N2)(NOT(SINGP X D COL N)))(SETQ DL (CONS (CONS D 1) DL))(GO ON)))
		    ))))
       (GO L2)
       ON(SETQ RULE(CONS (LIST D S ELM (1- COL)) RULE))
       (GO L2)))

(DECLARE (SPECIAL J))

(DEFUN SINGP (X ML COL N)
  #+Multics (DECLARE (FIXNUM COL N I))
  #-Multics (DECLARE (FIXNUM COL N I J))
  (PROG (I J L) 
	(SETQ J COL L ML)
	(COND((NULL ML)(GO LOOP))
	     (T (SETQ I (CAR ML) ML (CDR ML))))
	(COND((MEMBER I RZL*)(RETURN T))
	     ((ZROW X I COL N)(RETURN (SETQ RZL*(CONS I RZL*)))))
	LOOP(COND((> J N)(RETURN NIL))
		 ((ANDMAPC (FUNCTION(LAMBDA(I)(EQUAL (FUNCALL X I J) 0)))L)(RETURN T)))
	(SETQ J(1+ J))(GO LOOP)
	))

(DECLARE (UNSPECIAL J))

(DEFUN TDBU (X N)
  (DECLARE(FIXNUM N))
  (PROG(A ML* NL NML DD)
       (SETQ *DETSIGN* 1)
       (DETPIVOT X N)
       (SETQ X 'X*)
       (SETQ NL (NZL X N))
       (COND ((MEMQ NIL NL)(RETURN 0)))
       (SETQ A (MINORL X N (LIST (CONS (NREVERSE(INDEX* N)) 1)) NL))
       (SETQ NL NIL)
       (COND ((NULL A)(RETURN 0)))
       (TB2 X  (CAR A)N)
       TAG2
       (SETQ ML*(CONS (CONS NIL NIL)(CAR A)))
       (SETQ A (CDR A))
       (COND ((NULL A) (RETURN (COND ((= *DETSIGN* 1) (CADADR ML*))
				     (T (GPCTIMES -1  (CADADR ML*)))))))
       (SETQ NML (CAR A))
       TAG1(COND((NULL NML)(GO TAG2)))
       (SETQ DD  (CAR NML))
       (SETQ NML (CDR NML))
       (NBN DD)
       (GO TAG1)
       ))

(DEFUN NBN (RULE)
  (PROG (ANS R A)
       (SETQ ANS 0 R (CADAR RULE))
       (COND ((EQUAL R 0) (RETURN 0)))
       (RPLACA RULE (CAAR RULE))
       LOOP(COND((NULL R) (RETURN(RPLACD RULE(CONS ANS (CDR RULE))))))
       (SETQ A (CAR R) R(CDR R))
       (SETQ ANS(GPPLUS ANS
			(GPTIMES
			 (COND ((= (CADR A) 1)
				(FUNCALL X (CADDR A) (CADDDR A)))
			       (T (GPCTIMES (CADR A) (FUNCALL X (CADDR A) (CADDDR A)))))
			 (GETMINOR (CAR A)))))
       (GO LOOP)))

(DEFUN GETMINOR (INDEX)
       (COND((NULL(SETQ INDEX(ASSOC INDEX ML*)))0)
	    (T(RPLACD (CDR INDEX)(1- (CDDR INDEX)))
	      (COND((= (CDDR INDEX )0)
		    (DELETE INDEX ML*)))
	      (CADR INDEX)))
       )

(DEFUN TB2 (X L N)
  (DECLARE(FIXNUM N N-1))
  (PROG(N-1 B A)
       (SETQ N-1(1- N))
       LOOP(COND((NULL L) (RETURN NIL)))
       (SETQ A (CAR L) L (CDR L)B (CAR A))
       (RPLACD A (CONS (GPDIFFERENCE(GPTIMES (FUNCALL X (CAR B) N-1) (FUNCALL X (CADR B) N))
				    (GPTIMES (FUNCALL X (CAR B) N) (FUNCALL X (CADR B) N-1)))
		       (CDR A)))
       (GO LOOP)
       ))

(DEFUN ZROW (X I COL N)
       (DECLARE(FIXNUM I COL N J))
       (PROG(J)(SETQ J COL)
	    LOOP(COND((> J N)(RETURN T))
		     ((EQUAL (FUNCALL X I J) 0)(SETQ J(1+ J))(GO LOOP)))
	    ))

(DEFUN NZL (A N)
       (DECLARE(FIXNUM N I J))
       (PROG(I J D L)
	    (SETQ J (- N 2)) 
	    LOOP0(COND((= J 0) (RETURN L)))
	    (SETQ I N)
	    LOOP1(COND((= I 0) (SETQ L (CONS D L)) (SETQ D NIL)(SETQ J (1- J))(GO LOOP0)))
	    (COND((NOT(EQUAL (FUNCALL A I J) 0))(SETQ D (CONS I D))))
	    (SETQ I (1- I))(GO LOOP1)
	    ))

(DEFUN SIGNNP (E L)
       (PROG(I)
	    (SETQ I 1)
	    LOOP (COND ((NULL L)(RETURN NIL))
		       ((EQUAL E (CAR L)) (RETURN I)))
	    (SETQ L(CDR L) I (- I))
	    (GO LOOP)
	    ))

(DEFUN MEMBERCAR (E L)
       (PROG()
	    LOOP(COND((NULL L)(RETURN NIL))
		     ((EQUAL E (CAAR L))(RETURN(RPLACD (CAR L) (1+ (CDAR L))))))
	    (SETQ L (CDR L))(GO LOOP)
	    ))

(DECLARE (UNSPECIAL X ML* RZL*))

(DEFUN ATRANSPOSE (A N)
       (PROG(I J D) (SETQ I 0)
	    LOOP1(SETQ I (1+ I) J I)
	    (COND ((> I N) (RETURN NIL)))
	    LOOP2 (SETQ J (1+ J))
	    (COND ((> J N) (GO LOOP1)))
	    (SETQ D (FUNCALL A I J))
	    (STORE (FUNCALL A I J) (FUNCALL A J I))
	    (STORE (FUNCALL A J I) D)
	    (GO LOOP2)
	    ))

(DEFUN MXCOMP (L1 L2)
       (PROG()
	    LOOP(COND((NULL L1)(RETURN T))
		     ((CAR> (CAR L1) (CAR L2))(RETURN T))
		     ((CAR> (CAR L2) (CAR L1))(RETURN NIL)))
	    (SETQ L1 (CDR L1) L2 (CDR L2))(GO LOOP)
	    ))

(DEFUN PRMUSIGN (L)
       (DECLARE(FIXNUM B))
       (PROG(B A D)
	    (SETQ B 0)
	    LOOP (COND((NULL L)(RETURN (COND((EVEN B) 1)(T -1)))))
	    (SETQ A (CAR L) L (CDR L) D L )
	    LOOP1 (COND ((NULL D) (GO LOOP))
			((> A (CAR D)) (SETQ B (1+ B))))
	    (SETQ D (CDR D))(GO LOOP1)
	    ))

(DEFUN DETPIVOT (X N)
       (PROG(R0 C0)
	    (SETQ C0 (COLROW0 X N NIL) R0(COLROW0 X N T))
	    (SETQ C0 (NREVERSE(BBSORT C0 (FUNCTION CAR>))))
	    (SETQ  R0 (NREVERSE(BBSORT R0 (FUNCTION CAR>))))
	    (COND ((NOT(MXCOMP C0 R0))(ATRANSPOSE X N)(SETQ C0 R0)))
	    (SETQ *DETSIGN* (PRMUSIGN (MAPCAR (FUNCTION CAR) C0)))
	    (NEWMAT 'X* X N C0)
	    (*REARRAY X)))

(DEFUN NEWMAT(X Y N L)
  (PROG (I J JL)
	(*ARRAY X T (1+ N) (1+ N))
	(SETQ J 0.)
   LOOP (SETQ I 0 J (1+ J))
	(COND ((NULL L) (RETURN NIL)))
	(SETQ JL (CDAR L) L (CDR L))
    TAG (SETQ I (1+ I))
	(COND ((> I N)(GO LOOP)))
	(STORE (FUNCALL X I J) (FUNCALL Y I JL))
	(GO TAG)))

(DEFUN CAR> (A B) (> (CAR A) (CAR B)))

(COMMENT IND=T FOR ROW ORTHERWISE COL)

(DEFUN COLROW0 (A N IND)
  (DECLARE(FIXNUM N C I J))
  (PROG (I J L C)
        (SETQ J N C 0) 
  LOOP0 (COND((= J 0) (RETURN L)))
        (SETQ I N)
  LOOP1 (COND ((= I 0)
	       (SETQ L (CONS (CONS C J) L))
	       (SETQ C 0.)
	       (SETQ J (1- J))
	       (GO LOOP0)))
        (COND ((EQUAL (COND (IND (FUNCALL A J I))
			    (T (FUNCALL A I J))) 0)
	       (SETQ C (1+ C))))
       (SETQ I (1- I))(GO LOOP1)
       ))

(DEFUN GPDIFFERENCE (A B)
       (COND ($RATMX (PDIFFERENCE A B))
	     (T (SIMPLUS(LIST '(MPLUS) A (LIST '(MTIMES) -1 B)) 1 NIL))))

(DEFUN GPCTIMES(A B) (COND ($RATMX (PCTIMES A B)) (T (SIMPTIMES(LIST '(MTIMES) A B) 1 NIL))))

(DEFUN GPTIMES(A B) (COND ($RATMX (PTIMES A B)) (T(SIMPTIMES (LIST '(MTIMES) A B) 1 NIL))))

(DEFUN GPPLUS(A B) (COND ($RATMX (PPLUS A B)) (T (SIMPLUS(LIST '(MPLUS) A B) 1 NIL))))

