;;;;;;;;;;;;;;;;;;; -*- Mode: Lisp; Package: Macsyma -*- ;;;;;;;;;;;;;;;;;;;
;;;     (c) Copyright 1980 Massachusetts Institute of Technology         ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(macsyma-module newfac)
(load-macsyma-macros ratmac)
;; This is NEWFAC >.  Please do not make changes without consulting PAULW.

(EVAL-WHEN (EVAL COMPILE)
	   (SETQ OLD-IBASE IBASE OLD-BASE BASE)
	   (SETQ IBASE 10. BASE 10.))

(DECLARE (*LEXPR $FACTOR)
	 (SPECIAL $REC *OD* OVL VL *REIMPOSE $NOC *NOC* 
		  *DL  LCFV* V/# *VBV* FL1 GV* BLIST* VECL
		  BIGPRIMES *VBV* BLIST* *FL1 *PL1 POLY FACFUD* $PAL $PAQ
		  BLIST* *BOUND *ABL*  *INI1* *ABLN* *FMSQ* *WIN* *MIN*
		  *MX* *EXTRA *PL1 *FL1 *ODR* SMALLPRIMES MP* *OLDL NL*
		  POLY UPOLY FACFUD* NPOLY*  POL* LCV*  LC LCD* LCF* *AB
		  *PRODL *FACTL DFL *FPT  LOW* MXD* *STOP* THR* TRA* TRL*
		  *XN $FACTORFLAG  /#CONT SUBVAR1 
		  SUBVAL1 TELLRATLIST GAUSS VAR MPLC* MCFLAG
		   MONIC* ALGFAC* INTBS* ADN* MM* MINPOLY* ALPHA
		  $FACTORFLAG *PRIME *G*  ADEG* MODULU* FEEDBACK NEGFLAG PQ PLIM
		  LISTELM $EZGCDSWITCH MANY* *INL3 LIMK SPLIT* ALC
		  MPRIME *MOSESFLAG ALFLAG IND ERRRJFFLAG MODULUS
		  HMODULUS VARLIST GENVAR $ALGEBRAIC TH L DOSIMP *ALPHA)
	 ;; (ARRAY* (FIXNUM AFIXN 2 FCTCFIXN 1 INVCFIXN 1))
	 (FIXNUM ADEG*)
	 (GENPREFIX FCT) (FIXNUM (LOG2))) 

(DECLARE (SPECIAL CNT))
(DEFMACRO CNT (IND) `(ARRAYCALL FIXNUM CNT ,IND))

(SETQ $REC T *FMSQ* NIL GAUSS NIL *F* NIL G%I NIL M%I NIL MINPOLY* NIL MPLC* NIL) 
(DECLARE (SPECIAL MODULUS HMODULUS MPRIME *I* MCFLAG NN*-1 ELM NE RES FACT1
		  FACT2 SUBVAR SUBVAL OVARLIST VALIST VARLIST DLP NN* ZL
		  GENVAR DBL))

(DECLARE (SPECIAL *BCOEF *PRIME NN* DN* FCS* MODULU* NEGFLAG OVARLIST VALIST
		  DLP ERRRJFFLAG MPRIME MANY* UU* LIMK MODULUS HMODULUS VAR XX
		  VARLIST GENVAR MCFLAG PLIM)
	 (GENPREFIX NFA)) 

(SETQ $PAQ T $PAL NIL)

(DEFUN MULTDERIV(P VEC GV*)
       (SETQ GV* (REVERSE GV*))
       (MDRV P (RTZ VEC) 1))

(DEFUN RTZ (L)
       (PROG ()
	     (SETQ L (REVERSE L))
        LOOP (COND((= (CAR L)0)(SETQ L (CDR L)))
		  (T (RETURN (NREVERSE L))))
             (GO LOOP)))

(DEFUN MDRV(P VEC I)
(COND ((NULL VEC) P)
((EQUAL (CAR VEC) 0) (MDRV2 P (CDR VEC)(1+ I)))
((PCOEFP P) 0)
((EQ (CAR P)(NTH (1- I)GV*))(MDRV1 P VEC I))
(T 0)))



(DEFUN MDRV1 (P VEC I)
(PROG(D ANS DV V)
(SETQ D (CAR VEC) VEC (CDR VEC) I (1+ I))
(SETQ V (CAR P)  P (CDR P))
LOOP (COND ((OR (NULL P )(> D (CAR P))) (RETURN (PSIMP V (NREVERSE ANS)))))
(SETQ DV (MDRV(CADR P) VEC I))
(COND ((EQUAL DV 0) (GO ON)))
(SETQ ANS (CONS (PCTIMES (MFC (CAR P) D) DV)(CONS (- (CAR P) D) ANS)))
ON (SETQ P (CDDR P))(GO LOOP)
))


(DEFUN MDRV2 (P VEC I)
(PROG(ANS V D)
(COND ((NULL VEC)(RETURN P))
((PCOEFP P)(RETURN 0))
((NOT (EQ (CAR P) (NTH (1- (1- I))GV*)))(RETURN(MDRV P VEC I))))
(SETQ V (CAR P) P (CDR P))
LOOP (COND ((NULL P)(RETURN (PSIMP V (NREVERSE ANS)))))(SETQ D (MDRV (CADR P) VEC I))
(COND ((EQUAL D 0) (GO ON)))
(SETQ ANS (CONS D (CONS (CAR P) ANS)))
ON(SETQ P (CDDR P)) (GO LOOP)))


(DEFUN MFC (A B)
(COND ((= B 1 )A)(T(CTIMES A(MFC(1- A)(1- B))))))



(DEFUN FORMPROD(V B)
(PROG (ANS)
(SETQ ANS 1)
LOOP(COND ((NULL V)(RETURN ANS))
((NOT (= (CAR V)0))
(SETQ ANS (PTIMES ANS (PEXPT (CAR B) (CAR V))))))
(SETQ V (CDR V) B (CDR B))(GO LOOP)))



(DEFUN TERMCOEF(U VEC)
((LAMBDA(MODULUS)
(SETQ U (MULTDERIV U VEC GENVAR))
(SETQ U (PCSUBSTY VALIST OVARLIST U))
(COND ((EQUAL U 0) U)
(T (SETQ VEC  (CTIMESL(MAPCAR (FUNCTION FACTORIAL) VEC)))
(PQUOTIENT U VEC))))NIL))

(DEFUN FACTMOD(N)
(COND((= N 0)1)(T(CTIMES N(FACTMOD (1- N))))))

(DEFUN CTIMESL(L)
(COND(L (CTIMES (CAR L)(CTIMESL (CDR L))))
(T 1)))

(DEFUN VECGOR= (A B) 
       (PROG NIL 
	LOOP (COND ((NULL A) (RETURN T))
		   ((OR (> (CAR A) (CAR B)) (= (CAR A) (CAR B)))
		    (SETQ A (CDR A))
		    (SETQ B (CDR B))
		    (GO LOOP))))) 

(DEFUN VECCHECK (DVL V) 
       (PROG NIL 
	LOOP (COND ((NULL DVL) (RETURN NIL)) ((VECGOR= (CAR DVL) V) (RETURN T)))
	     (SETQ DVL (CDR DVL))
	     (GO LOOP)))


(DEFUN VLESS(V1 V2)
(PROG ()
LOOP (COND ((NULL V1) (RETURN NIL))
((< (CAR V1) (CAR V2))(RETURN T))
((>(CAR V1) (CAR V2))(RETURN NIL))
((EQUAL V1 V2) (RETURN NIL)))
(SETQ V1 (CDR V1) V2 (CDR V2))
(GO LOOP)))

(DEFUN ADONEHK(V1 V2)
(PROG(ANS D V)
(SETQ V V1)
LOOP (COND ((NULL (CDR V)) (RETURN (NREVERSE ANS))))
(SETQ D (CDR V))
(RPLACD V (CONS (1+ (CAR D)) (CDDR V)))
(COND ((VLESS V1 V2)(SETQ V2 (COPY1 V1)))(T (GO ON)))
(COND ((VECCHECK VECL V2)(SETQ ANS (CONS V2 ANS))))
ON(RPLACD V D)
(SETQ V (CDR V))(GO LOOP)))

(DEFUN NEXTDEG(VECN)
(PROG(ANS)
(SETQ ANS (CONS (CONS (1+ (CAAR VECN))(CDAR VECN)) ANS))
LOOP
(COND((NULL VECN)(RETURN ANS)))
(SETQ ANS (NCONC ANS (ADONEHK (CAR VECN) (CAR (LAST ANS)))))
(SETQ VECN (CDR VECN))(GO LOOP)))


(DEFUN PRDHK(L)
(PROG(ANS)
(SETQ L (REVERSE (CDR L)))
(SETQ ANS (CONS (CAR L) ANS) L (CDR L))
LOOP(COND ((NULL L) (RETURN ANS)))
(SETQ ANS (CONS (PTIMES (CAR L)(CAR ANS))ANS))
(SETQ L (CDR L))(GO LOOP)))

(DEFUN CCONTENT (P) (*CATCH 'CNT (CGCDLIST (CONSTACL P))))

(DEFUN CPPART(P)  (PCQUOTIENT P (CCONTENT P)))

(SETQ SMALLPRIMES'(3 5 7 11 13 17 19 23 29 31 37
                     41 43 47 53 59 61))


(DEFUN NINCREASELIST(L N)
(PROG()
LOOP(SETQ L (NINCREASELIST0 L N))
(COND ((MEMBER L *OLDL) (GO LOOP))
(T(SETQ *OLDL (CONS L *OLDL))(RETURN L)))))

(DEFUN NINCREASELIST0 (L N) 
       (COND (*INL3 (SETQ L (INLIST3 L))))
       (COND (*INL3 L)
	     (T (COND ((EQUAL ELM 2.)(COND (MODULU* (merror "NOT ENOUGH CHOICES FOR SUBSTITUTION"))(T (RANDCK N MP*))))
		      ((EQUAL NE N)
		       (SETQ ELM (1+ ELM))
		       (SETQ NE 1.)
		       (COMPLETEVECTOR (BASELIST NE) NE N LISTELM))
		      (T (COND ((EQUAL *I* N)
				(SETQ NE (1+ NE))
				(COMPLETEVECTOR (BASELIST NE) NE N LISTELM))
			       (T (SETQ *I* (1+ *I*))
				  (REVERSE (CDR (REVERSE (CONS LISTELM
							       L)))))))))))




(DEFUN NEXTSP(P)
(PROG(L)
(SETQ L SMALLPRIMES)
LOOP(COND ((= P (CAR L))(RETURN (CADR L))))
(SETQ L (CDR L))(GO LOOP)
))

(DEFUN RRPP(L)
(COND((NULL L) L)
 ((OR (MEMBER (CAR L)(CDR L))(MEMBER (- (CAR L)) (CDR L))) T)
(T (RRPP (CDR L)))))

(DEFUN RANDCK(N P)
(PROG(D C)
LOOP1(SETQ C (-(* N P)2))
LOOP(SETQ D (RAND N P))
(COND ((OR(MEMBER D *OLDL)(AND(> P 7.)(RRPP D)))
(COND ((>(LENGTH *OLDL) C)(SETQ MP* (SETQ P (NEXTSP P)))(GO LOOP1)))
  (GO LOOP)))
(RETURN D)
))

(DEFUN UZINIT(FL &OPTIONAL PL)
(PROG(D C)
(OR PL (SETQ PL (PRDHK FL)))
(SETQ C 1)
LOOP(COND ((NULL PL)(RETURN(SETQ *AB(NREVERSE(CONS C *AB))))))
  (SETQ D (OBTAINAB0 (CAR FL)(CAR PL)C))
	     (SETQ *AB(CONS (CADR D) *AB))
(SETQ C (CAR D))
(SETQ PL (CDR PL) FL (CDR FL))(GO LOOP)))


; THE FOLLOWING FN ALSO IN NUNI
(DEFUN UCRTS(CP AB FL1)
(MAPCAR (FUNCTION (LAMBDA(X Y) (PMODREM(PTIMES (PMODREM CP Y) X)Y))) AB FL1))



;THE FOLLOWING FN ALSO IN NUNI

(DEFUN OBTAINAB0(FACT1 FACT2 C)
((LAMBDA(*AB *FL1)(UCRTS C *AB *FL1))
(COND (MANY*
((LAMBDA(MODULUS )(FACT20 FACT1 FACT2 LIMK))*PRIME))
(T  (PPPROG FACT1 FACT2))) (LIST FACT2 FACT1))
)


(DEFUN NMULTFACT (POLY) 
       (PROG (MONIC* *P0 *MIN* *MX* *ODR* NL* LCD* LCF* LCV* MXD* LOW* *PRIME /#CONT UFAC *INL3 *I* NN* LC LIMK ELM LISTELM PLIM ORIGENVAR NE VAR VALIST VAL1
	      OVARLIST POL* SUBVAR SUBVAL DLP) 
	     (SETQ VAR (CAR POLY) ELM (LISTOVARS POLY) 
		   ORIGENVAR GENVAR 
		   GENVAR (INTERSECT GENVAR (COND (ALGFAC* (DELETE (CAR ALPHA) ELM))(T ELM))) 
		   OVARLIST (REVERSE (CDR (REVERSE GENVAR))) 
		   NN* (1+ (LENGTH OVARLIST)))
	     (SETQ LISTELM 0.)
	     (SETQ LC (CADDR POLY))
	     (COND ((EQUAL LC 1.) (SETQ MONIC* T))
(T (SETQ LCF*(PFACTOR LC)  LCD* (ODDELM (CDR LCF*)) LCF* (ODDELM LCF*))))

(COND((NUMBERP (CAR LCF*))(SETQ NL*(CAR LCF*) LCF* (CDR LCF*) LCD* (CDR LCD*)))
(T (SETQ NL* 1)))

(SETQ LCF*(SORT LCF* (FUNCTION (LAMBDA(X Y)(< (LENGTH X)(LENGTH Y))))))
	     (SETQ ELM 1. *I* 1. NE 1.)
	     (SETQ *ODR*(PUTODR (REVERSE OVARLIST)))

	     (SETQ POL* POLY)

(SETQ SUBVAR OVARLIST)

	     (SETQ SUBVAL
(COND(*FMSQ* (SQFRSUBST (COMPLETEVECTOR NIL 0. (LENGTH SUBVAR) 1.) SUBVAR LCF*))(T		   (NPOLYSUBST (COMPLETEVECTOR NIL 0. (LENGTH SUBVAR) 1.)
			      SUBVAR LCF*))))
SK
(COND ((NULL SUBVAL) (SETQ GENVAR ORIGENVAR)(RETURN (LIST POLY))))
(SETQ /#CONT (CADR SUBVAL) UFAC (CADDR SUBVAL)SUBVAL (CAR SUBVAL))
	TAG  
	     (FIXVL0 SUBVAR SUBVAL (REVERSE OVARLIST))
(COND(ALGFAC*(SETQ GENVAR (CONS (CAR ALPHA)  GENVAR))))
(COND (LCF*(LCSP /#CONT (SETQ VAL1(MAPCAR (FUNCTION CADDR) UFAC)))
(SETQ LCV*(MAPCAR (FUNCTION(LAMBDA(X)(PCSUBSTY VALIST OVARLIST X))) LCF*))
(SETQ VAL1(MAPCAR(FUNCTION CQUOTIENT) LCV* VAL1))
(SETQ UFAC(MAPCAR(FUNCTION PCTIMES) VAL1 UFAC))))
(SETQ LCV* NIL VAL1 NIL)
	     (SETQ POLY(COND (*FMSQ*(FMSQ POLY *P0 UFAC /#CONT))(T (NCPBER3 POLY UFAC /#CONT LC))))
	     (SETQ GENVAR ORIGENVAR)
	     (RETURN POLY)))


(DEFUN NPOLYSUBST (A B LCF) 
       (PROG (NM LC OLDU MP* *OLDL LCV UFAC POSS CONT *INL3 U M N MODULUS) 
(SETQ MP*  3.)
(COND (MODULU* (SETQ MODULUS MODULU*)))
(SETQ VAR (CAR POL*) LC (CADDR POL*) NM(1+ (CADR POL*)))
	     (SETQ *INL3 T N (LENGTH A))
	LOOP (SETQ U (PCSUBSTY A B LC))
	     (COND ((EQUAL 0. U) (GO INL))
                   ((OR MONIC*(NULL LCF)) (GO ON))
                   ((SETQ LCV (LCCHECK A B LCF))NIL)(T (GO INL)))
ON	     ((LAMBDA (MODULUS) (SETQ U (PCSUBSTY A B POL*))) NIL)
(COND (MONIC* (SETQ /#CONT 1))((ONEVARP U)
	     (SETQ U (OLDCONTENT U))
	     (SETQ /#CONT (CAR U) U (CADR U))))
(COND ((AND LCF(NOT(CNTCHK (TIMES /#CONT NL*) LCV)))(GO INL)))
	     (COND ((SQFRP (PMOD U) VAR) 
(COND ((ONEVARP U)(GO UNI))
((NUMBERP(CAR (FASTCONT U)))(SETQ POL* U) (RETURN A)))))
	INL  (SETQ A (NINCREASELIST A N))
	     (GO LOOP)
UNI
(COND ((MEMBER U OLDU)(GO INL)))
(SETQ OLDU (CONS U OLDU))
             (SETQ UFAC(FACT5 U))
(COND (*STOP* (RETURN (LIST A /#CONT UFAC)))
((NULL (CDR UFAC))(RETURN NIL)))
	     (COND ((NUMBERP (CAR UFAC))
		    (SETQ /#CONT (PTIMES /#CONT (CAR UFAC)) UFAC (CDR UFAC))))
(COND ((GREATERP 0 /#CONT)
(SETQ /#CONT (CTIMES -1 /#CONT) UFAC (CONS (PMINUS (CAR UFAC))(CDR UFAC)))))
(SETQ M(LENGTH UFAC))
(COND((AND (NOT MONIC*)(= M 2))(SETQ LCV* LCV)(RETURN(LIST A /#CONT UFAC)))
 ((< M NM)(SETQ NM M POSS (LIST (LIST LIMK *PRIME PLIM LCV) A /#CONT UFAC) CONT 1))
((= M NM)(SETQ CONT (1+ CONT))
(COND ((GREATERP (CADDR POSS) /#CONT)(SETQ POSS(LIST (LIST LIMK *PRIME PLIM LCV) A /#CONT UFAC))))
(COND ((= CONT 3) (SETQ POL* NIL U(CAR POSS)LIMK (CAR U) *PRIME (CADR U) PLIM (CADDR U) LCV* (CADDDR U))(RETURN (CDR POSS))))))
(GO INL)))





(DEFUN LCSP(C NLC)
(PROG(LCF LCV ANS N D XC A)
(SETQ LCF*(NREVERSE LCF*)LCV* (NREVERSE LCV*))
LOOP(SETQ LCF LCF* LCV LCV*)
(COND ((NULL NLC)(SETQ LCV* NIL LCD* NIL)(SETQ /#CONT C)(RETURN (SETQ LCF* (NREVERSE ANS)))))
(SETQ N (CAR NLC)  XC 0 A 1 N (CTIMES C N))
LOOP2 (COND ((OR(NULL LCV)(EQUAL N 1)(EQUAL N -1))(GO ON)))
(SETQ D (CAR LCV))
BK(COND((EQUAL (REMAINDER N D) 0) (SETQ XC(PLUS 1 XC) N (QUOTIENT N D)) (GO BK))

((EQUAL XC 0) (GO NEXTD)))
(SETQ A (PTIMES (PEXPT (CAR LCF) XC ) A) XC 0)
NEXTD(SETQ LCV (CDR LCV) LCF (CDR LCF))
(GO LOOP2)
ON
(COMMENT THE FOLLOWING TRIES TO PUT IN THE CORRECT VALUE INCLUDING SIGN OF THE NUMERICAL COEF BASED ON THE ASSUMPTION THAT THE NUMERICAL COEFS OF THE UNIFACTORS ARE CORRECT)
(COND ((EQUAL C 1) (SETQ ANS (CONS(PCTIMES N A) ANS)) (GO OUT)))
(SETQ N (PCSUBSTY VALIST OVARLIST A))
(SETQ XC (GCD (CAR NLC ) N) N (QUOTIENT N XC))
(SETQ C (QUOTIENT C (ABS N)))
(SETQ XC (QUOTIENT (CAR NLC) XC))
(SETQ XC (CTIMES (COND((GREATERP N 0) 1)(T -1)) XC))
(SETQ ANS (CONS (PCTIMES XC A ) ANS))
OUT (SETQ NLC (CDR NLC))(GO LOOP)))

(DEFUN LCCHECK(V B FL)
(PROG()
(SETQ V (MAPCAR (FUNCTION (LAMBDA(X)
(PCSUBSTY V B X)))FL))
(RETURN(COND ((RELPRIMEP V)V)))))




(DEFUN RELPRIMEP(V)
(PROG(NFL N L)
(COND ((OR(MEMBER 1 V)(MEMBER -1 V))(RETURN NIL)))
(SETQ L (COND ((EQUAL NL* 1)V)(T (CONS NL* V))))
LOOP
(COND ((NULL V)(RETURN L))
((EQUAL (SETQ N(NONDIVISOR NFL (CAR V)))1.) (RETURN NIL))
(T(SETQ NFL (CONS N NFL) V (CDR V))))
(GO LOOP)))

(DEFUN NONDIVISOR2(A B)
(PROG(R)
LOOP(SETQ R (CGCD A B))
(COND ((EQUAL R 1.) (RETURN (ABS B))))
(SETQ A R B (QUOTIENT B R))
(GO LOOP)))


(DEFUN NONDIVISOR (L B)
(PROG()
LOOP
(COND((NULL L)(RETURN B)))
(SETQ B(NONDIVISOR2 (CAR L) B))
(COND ((EQUAL B 1.) (RETURN B)))
(SETQ L (CDR L))
(GO LOOP)))



(DEFUN CNTCHK(C L)
(NOT(MEMBER 0 (MAPCAR (FUNCTION (LAMBDA(X) (REMAINDER C X)))L))))


;(DEFUN LCIN(A B)
;(COND ((NULL A) B)
;(T(MAPCAR (FUNCTION (LAMBDA(X Y)
;(CIMP X(COPY1 Y))))A B))))


;(DEFUN CIMP(P Q)
;(PROG(D)
;(SETQ D (CDR Q))
;LOOP (SETQ P (CDDR P))
;(COND((NULL (CDR P)) 
;(COND((NUMBERP (CAR P)) NIL)(T(RPLACD D P)))(RETURN Q))
;((NUMBERP (CAR P)) NIL)
;(T (RPLACD D(CONS (CAR P)(CDDR D)))))
;(SETQ D (CDDR D))(GO LOOP)))




(COMMENT THIS IS VBV)




(DEFUN REINIT(A B)
(PROG()
(COND((NULL *INI1*) (SETQ *ABLN* *ABL* *INI1* T)))
(COND ((NULL (CDDR DFL)) (RETURN FACFUD*)))
(SETQ *FACTL (CDR B) *FL1 (CDR A))
(SETQ *PRODL (PRDHK *FACTL) *PL1 (PRDHK *FL1))
 (SETQ *AB NIL *ABL* NIL)(UZINIT *FL1)(SETQ *ABL* (LIST (CONS 0 *AB)) *ABLN* NIL)

(RETURN FACFUD*)))


(DEFUN NCRTS(CP)
(PROG (ANS A B D M)
(SETQ ANS (NZEROS (1+ (LENGTH *PL1)) NIL))
(COND ((PCOEFP CP)(SETQ CP (LIST 0 CP)))(T (SETQ CP (CDR CP))))
LOOP(COND ((NULL CP) (RETURN ANS)))
(SETQ M (CAR CP))
	(SETQ D
	     (COND ((SETQ A (CDR (ASSOC M *ABL*))) A)
          (T   (SETQ A (UCRTS (LIST VAR M 1.) *AB *FL1))
	     (SETQ *ABL* (CONS (CONS M A) *ABL*))
	     A)))
(SETQ B (CADR CP))
(SETQ ANS (MAPCAR (FUNCTION (LAMBDA(X Y)  (PPLUS(PCTIMES B X) Y))) D ANS))
(SETQ CP (CDDR CP))
(GO LOOP)))




(DEFUN SUMHK(AL FL PL)
(COND (PL(PPLUS (PTIMES (CAR AL) (CAR PL)) 
   (PTIMES (SUMHK (CDR AL) (CDR FL) (CDR PL)) (CAR FL))))
(T(CAR AL))))


(DEFUN MCRTS (H)
       ((LAMBDA(GENVAR OVARLIST VALIST BLIST*)
	       (HNSLABALL H))
	(CDR GENVAR) (CDR OVARLIST) (CDR VALIST)
	(REVERSE(CDR (REVERSE BLIST*)))))




(DECLARE (SPECIAL OV VL))
(DEFUN HNSLABALL(H)
 (COND ($REC (RH H OVARLIST VALIST (DEGBOUND H) (SUB1 *VBV*)))
(T (HNSLABALL0 H))))


(DEFUN RH(C OV VL DBL VBV)
(DECLARE(FIXNUM VBV I))
(PROG(TERM TM I AL FL PL DD D)
(COND ((OR (ATOM C) (AND (ONEVARP C)(EQ (CAR C) VAR)))
(RETURN (NCRTS C))))
(SETQ TM (LISTOVARS C))
AG (COND((NOT (MEMQ (CAR OV) TM))
  (SETQ OV (CDR OV) DBL (CDR DBL) VL (CDR VL) VBV (SUB1 VBV))(GO AG)))
(SETQ TM 1)
(SETQ TERM (PDIFFERENCE (LIST (CAR OV) 1 1) (CAR VL)))
(SETQ AL(PCSUBSTY (LIST (CAR VL) )(LIST (CAR OV)) C))
(SETQ AL (RH AL (CDR OV) (CDR VL) (CDR DBL) (SUB1 VBV)))

(SETQ I 0)
(SETQ FL (MAPCAR (FUNCTION EVSUB) *FACTL))
(SETQ PL (MAPCAR (FUNCTION EVSUB) *PRODL))
(SETQ D (PDIFFERENCE C (SUMHK AL *FACTL *PRODL)))
(SETQ C(NZEROS VBV NIL))
LOOP(COND ((EQUAL D 0) (RETURN AL)))
LOOP1 (SETQ I (1+ I) )
(COND ((> I (CAR DBL)) (RETURN AL)))
  (SETQ TM (PTIMES TM TERM))
(SETQ DD  (TERMCOEF D (APPEND C (LIST I))))
(COND ((EQUAL DD 0)(GO LOOP1)))
(SETQ DD ((LAMBDA(*FACTL *PRODL)
(RH DD (CDR OV) (CDR VL) (CDR DBL) (SUB1 VBV))) FL PL))
(SETQ AL (MAPCAR (FUNCTION (LAMBDA(X Y)
(COND ((EQUAL X 0) Y)
(T (PPLUS (PTIMES X TM) Y))))) DD AL))
(SETQ D (PDIFFERENCE D (PTIMES TM (SUMHK DD *FACTL *PRODL))))
 (GO LOOP)
))



(DEFUN EVSUB(C)
(PCSUBSTY (LIST (CAR VL)) (LIST (CAR OV)) C))
(DECLARE (UNSPECIAL OV))



(DEFUN HNSLABALL0(H)
       (PROG (NN* AL RES VECN VECN1 VECL VEC HSTEPS STEPS D STEP) 
(SETQ AL (PCSUBSTY VALIST OVARLIST H))
(SETQ AL (NCRTS AL))
(COND ((= *VBV* 1)(RETURN AL)))
(SETQ VECL (DEGBOUND H))
	     (SETQ STEPS (APPLY (FUNCTION +) VECL) HSTEPS (1+(// STEPS 2.)))
(SETQ NN* (LENGTH GENVAR))
(SETQ VECL(LIST VECL))
	     (SETQ STEP 0.)
(SETQ VECN(LIST(NZEROS (LENGTH OVARLIST) NIL)))
	NEXTSTEP 
(SETQ RES (PDIFFERENCE H (SUMHK AL *FACTL *PRODL)))
                 (COND((EQUAL RES 0.) (GO OUT)))
	BK   (SETQ STEP (1+ STEP))
	     (COND ((> STEP STEPS) (GO OUT)))
(SETQ VECN(NEXTDEG VECN))
(SETQ VECN1 VECN)
(COND ((NULL VECN1)(GO BK)))
	NEXTV(COND ((NULL VECN1)(GO NEXTSTEP)))
(SETQ VEC (CAR VECN1) VECN1 (CDR VECN1))
(SETQ D(PMOD(TERMCOEF RES (CONS 0 VEC))))
(COND ((EQUAL D 0)(GO NEXTV)))(SETQ D(NCRTS D))
 (SETQ VEC(FORMPROD VEC BLIST*))
(SETQ AL (MAPCAR
(FUNCTION (LAMBDA(X Y) (COND ((EQUAL X 0) Y)(T (PPLUS (PTIMES X VEC) Y)))))
D AL))
	     (GO NEXTV)
	OUT
 (RETURN AL)))



(COMMENT BOUND LIST IS IN THE SAME ORDER AS BLIST* WHICH IS
THE REVERSE ORDER OF OVARLIST WHICH  IS IN THE SAME ORDER AS GENVAR)

(COMMENT PDEGREEVECTOR GIVES DEGREES IN THE SAME ORDER AS GENVAR)

(DEFUN DEGBOUND(H)
(PROG(L M ANS D DL N)
(SETQ M (CDR(NREVERSE (PDEGREEVECTOR H))))
(SETQ L (MAPCAR (FUNCTION(LAMBDA(X)(NREVERSE(PDEGREEVECTOR X)))) *FACTL))
(SETQ N(LENGTH (CAR L)))
LOOP
(SETQ N(1- N))
(COND ((= N 0) (RETURN(NREVERSE ANS))))
(SETQ L (MAPCAR (FUNCTION CDR) L))
(SETQ DL (MAPCAR (FUNCTION CAR) L))
(SETQ D(MAX 0 (- (CAR M)(APPLY (FUNCTION +) DL))))
(SETQ M (CDR M))
(SETQ ANS (CONS (+ D (APPLY (FUNCTION MAX) DL))ANS))
(GO LOOP)
))

(DEFUN PTIMESALL(L)
(PROG(ANS)
(SETQ ANS (CAR L) L (CDR L))
LOOP(COND ((NULL L)(RETURN ANS)))
(SETQ ANS (PTIMES (CAR L) ANS) L (CDR L))(GO LOOP)))






; CAR OF *FACTL IS A LIST OF FACTORS TO BE LIFTED AND CADR OF *FACTL 
;IS THE SAME LIST WITH IMPOSED COEFFS FOUND BY CSLV
; A= CURRENT OVARLIST AND B= CURRENT SUBVAL

(DEFUN NZ1(POLY *FACTL TERM A B)
(DECLARE(FIXNUM STEPS STEP ASTEP HSTEPS))
       (PROG (RES *INI1*  FACFUD* TM ASTEP *PRODL HSTEPS STEPS ABL D DFL STEP) 
(SETQ DFL (CADR *FACTL) *FACTL (CAR *FACTL))
	     (SETQ TM 1 STEPS (CAR TERM) TERM (CDR TERM) HSTEPS (1+(QUOTIENT STEPS 2.)) ASTEP (1-(1- (QUOTIENT STEPS (LENGTH *FACTL)))))
(SETQ *PRODL(PRDHK *FACTL))
(SETQ DFL(CONS NIL(MAPCAR (FUNCTION (LAMBDA(X Y)(CONS X Y)))
(NREVERSE (INDEX* (LENGTH *FACTL)))DFL)))
	     (SETQ STEP 0.)
	NEXTSTEP
(COND ((NULL(CDDR DFL))(RETURN(MERGEL  FACFUD* (LIST (CONS (CAADR DFL)POLY))))))
(SETQ RES (PDIFFERENCE (PTIMESALL (MAPCAR (FUNCTION CDR)(CDR DFL))) POLY))
                 (COND((EQUAL RES 0.) (GO OUT)))
	BK   (SETQ STEP (1+ STEP))
	     (COND ((GREATERP STEP STEPS) (GO OUT)))
 (SETQ TM(PTIMES TM TERM))
((LAMBDA(OVARLIST VALIST)(SETQ D
(PMOD(TERMCOEF RES(NCONC (NZEROS *VBV* NIL)  (LIST STEP))))))A B)
(COND ((EQUAL D 0)(GO NEXTSTEP)))(SETQ D (MCRTS D))
(SETQ ABL (MAPCAR (FUNCTION (LAMBDA(X) 
(COND ((EQUAL X 0) 0)(T(PTIMES X TM)))))D))
(NZ2 ABL STEP ASTEP)(SETQ ABL NIL)
(GO NEXTSTEP)
	OUT
(COND ((NULL FACFUD*)(SETQ *ABLN* *ABL*)(RETURN (MAPCAR (FUNCTION CDR)(CDR DFL)))))
 (RETURN(MERGEL FACFUD*(CDR DFL)))))



(DEFUN MERGEL(A B)
(PROG(I J)
(SETQ B (NCONC A B) A NIL)
(SETQ I 0 J (LENGTH B))
LOOP (COND((= I J)(RETURN (NREVERSE A))))
(SETQ I (1+ I))
(SETQ A (CONS (CDR (ASSOC I B)) A))(GO LOOP))) 


(DEFUN NZ2 (ABL STEP ASTEP) 
(PROG(L Q IND FL1 FL A B)
(SETQ L DFL FL1 (CONS NIL *FL1) FL (CONS NIL *FACTL) A FL1 B FL)
LOOP(COND ((NULL ABL) (RETURN (COND (IND(REINIT A B)))))
((EQUAL (CAR ABL) 0)
(COND ((AND(OR *FMSQ* (> STEP ASTEP))(SETQ Q (TESTDIVIDEZ POLY (CDADR L))))
(SETQ POLY Q IND T FACFUD* (CONS (CADR L) FACFUD*) )
 (RPLACD L (CDDR L))
(RPLACD FL1(CDDR FL1))
(RPLACD FL(CDDR FL))(SETQ ABL (CDR ABL))(GO LOOP))
(T(GO ON)))))
(RPLACD L (CONS(CONS (CAADR L) (PDIFFERENCE (CDADR L) (CAR ABL)))(CDDR L)))
ON(SETQ L (CDR L) ABL (CDR ABL)FL1 (CDR FL1) FL (CDR FL))
(GO LOOP)))	(DEFUN TESTDIVIDEZ(A B)
((LAMBDA(MODULUS) (TESTDIVIDE A B))MODULU*))

(DEFUN NCPBER3 (V FACTZ /#CONT LC) 
       (PROG (U LCFV* *EXTRA VFACT V/# CNT) 

; THIS IS THE BARRY TRICK FOR THE BAD CASE IN ALGFAC
(SETQ V/# 1.)
(COND (*STOP*(SETQ *STOP* PLIM) (RETURN(CONS (CAR SUBVAL)  FACTZ))))
	     (COND ((NULL (CDR FACTZ)) (RETURN (LIST V)))
((AND ALGFAC*(NOT (EQUAL ADN* 1))) (SETQ V (PCTIMES ADN* V)LC (PCTIMES ADN* LC))))
(COMMENT TAKE OUT	     (INCRLIMK V))
	     (SETQ MODULUS PLIM)
	     (SETQ U V)
	     (COND ((NOT (EQUAL /#CONT 1.))
		    (SETQ FACTZ(MAPCAR (FUNCTION (LAMBDA(X)(PCTIMES /#CONT X)))FACTZ))
(COND (LCF* (SETQ LCF*(MAPCAR(FUNCTION (LAMBDA(X)(PCTIMES /#CONT X)))LCF*))))
(SETQ V(PCTIMES (EXPT /#CONT (1-(LENGTH FACTZ)))V))))

(COND ((NULL LCF*)(SETQ LCF* (MAPCAR (FUNCTION CADDR) FACTZ))))
(SETQ LCFV* (MAPCAR (FUNCTION (LAMBDA(X) (LIST (LIST (CADR X)))))FACTZ))

(SETQ CNT (*ARRAY NIL 'FIXNUM (1+(LENGTH FACTZ))))
  (SETQ VFACT (ZFACTALL V FACTZ (MAPCAR (FUNCTION LIST) LCF*) LCFV* GENVAR))

ON
(COND ((EQUAL /#CONT 1)	     (SETQ FACTZ VFACT ))
(T(SETQ FACTZ(MAPCAR(FUNCTION CPPART) VFACT))))
(SETQ VFACT NIL)
(COND
 ((AND ALGFAC*(NOT (EQUAL ADN* 1)))(SETQ V (PCTIMES (CRECIP ADN*) V))(SETQ ADN* 1)))
	     (RETURN FACTZ)
))


; UPDATES *DL
;LIST OF LISTS OF EXPONENT VECTORS OF DETERMINED TEERMS IN V/# VARIABLES


(DEFUN DUPDT(D V)
(PROG(ANS)
(MAPC (FUNCTION(LAMBDA(X)(COND( (MEMBER (CDR X) D)
 (SETQ ANS (CONS X ANS))))))V)
(RETURN ANS)
))

;COMMENT REPLACE COEFFICIENT WITH DETERMINED COEF IN P



(DEFUN CRPL0 (EL CL DL P)
(PROG(*REIMPOSE)
(SETQ *REIMPOSE T EL (CONS NIL EL) CL (CONS NIL CL))
LOOP
(COND ((NULL (CDR EL)) (RETURN NIL))
((CRPL (CADR EL) (CADR CL) P)NIL)
(T(REMVEC DL (CADR EL)) (RPLACD EL (CDDR EL)) (RPLACD CL (CDDR CL))))
(SETQ EL (CDR EL) CL (CDR CL) ) (GO LOOP)))

(DEFUN REMVEC (L V)
(PROG(I)
(SETQ I(1+ (- (LENGTH (CAR L)) (LENGTH V))))
LOOP(COND ((NULL (CDR L)) (RETURN NIL))   ;LEADING COEF ALWAYS CORRECT
((EQUAL (NCDR (CAR L) I) V)(RPLACA L (CADR L)) (RPLACD L (CDDR L)))
(T (SETQ L (CDR L))))
(GO LOOP)))



(DEFUN CRPL(E C P)
(PROG()
(COND((NUMBERP C) (RETURN C))
 ((NULL E )(RETURN NIL)))
(SETQ E(REVERSE E))(GO LOOP1)
LOOP(COND ((OR(NULL E)(ATOM (CADR  P)))(RETURN (CRPL2 (CDR P) C)))
((NULL (CDR E)) (RETURN (CRPL1 (CAR E) C (CDR (CADR P)))))
(T (SETQ P (CDADR P))))
LOOP1(COND ((= (CAR P) (CAR E))(SETQ E (CDR E))(GO LOOP)))
(SETQ P(CDDR P))
(GO LOOP1)))

(DEFUN CRPL1(E C P)
(COND ((OR (NUMBERP C)(NULL P)) NIL)
((= (CAR P ) E)(CRPL2(CDR P)C))
(T(CRPL1 E C (CDDR P)))))


(DEFUN CRPL2(P C)
(COND ((OR (NULL *REIMPOSE) (CONSISTENTP (CAR P) C))
(RPLACA P C))))

(DEFUN CONSISTENTP(C1 C2)
(EQUAL C1 (PCSUBSTY (REVERSE VL) (REVERSE OVL) C2)))


;COMMENT COEFFICIENT OF TERM WITH GIVEN EXP-VEC
(DEFUN TCOEF(P EV)
(PROG(A G)
(SETQ EV (REVERSE EV) G (REVERSE GENVAR))
LOOP(COND ((OR(NULL EV)(ATOM P))(RETURN P))
((AND (= (CAR EV) 0.) (NOT (EQ (CAR P) (CAR G)))) 
(RETURN P)))
(SETQ P (PTERM (CDR P) (CAR EV)))
(SETQ EV (CDR EV) G (CDR G))
(GO LOOP)))

;FL IS THE LIST OF FACTORS TO BE LIFTED WITH UNREDUCED COEFFICIENTS IMPOSED


;*OD* KEEPS TRACK OF ODER OF FACTORS

;*NOC* STOPS COEFSOLVING IF NO COEF IS DETERMINED FOR V/# = 1 AND 2.

;$NOC IS THE GLOBAL FLAG FOR COEF SOLVE, IF T NO COEF SOLVE TAKES PLACE

(SETQ $NOC NIL)
(DEFUN ZFACTALL (U FL LCF* LCFV* GENVAR)
   (PROG (*PRODL FLL *NOC* *OD* FL1 ORIGENVAR AB FACFND* *ABL* *ABLN* PL1 *AB
		 *FL1 *DL *PL1 DL HVL TERM BLIST* *VBV* A B U1 OVL VL LCL)
	 (SETQ *NOC* $NOC)
	 (SETQ ORIGENVAR GENVAR FL1 (COPY1 FL) *DL(COPY LCFV*))
(COMMENT
         (SETQ MODULUS(CAR (LAST BIGPRIMES)) *PRIME MODULUS PLIM MODULUS LIMK -1))
         (SETQ DL (NREVERSE (PDEGREEVECTOR U))
	       *OD* (CONS NIL (NREVERSE (INDEX* (LENGTH FL))))
	       GENVAR (LIST VAR) *VBV* 0
	       OVL(REVERSE OVARLIST) VL (REVERSE VALIST))
TAG
(SETQ FL ((LAMBDA(GENVAR)(COEFSOLVE U FL (MAPCAR (FUNCTION (LAMBDA(X Y DL Z)
(SETQ Z (COPY Z))(CRPL0 X Y DL (CDR Z)) Z)) LCFV* LCF* *DL FL)))ORIGENVAR))
;LCF* IS A LIST OF LISTS OF CORRECT LEADING COEFFICIENTS
;WHICH HAS TO BE UPDATED TOO
(COND ((CADR FL)
(SETQ U (CAR FL) FACFND* (APPEND FACFND* (CADR FL))FLL (CADDR FL)FL (CADDDR FL))
(COND ((EQUAL U 1.) (RETURN(MERGEL FACFND* NIL)))(T (GO BEGIN)))))
(SETQ FLL (CADDR FL) FL (CADDDR FL))
(COND ((= *VBV* 0.) NIL) (T (GO LOOP)))
BEGIN
     (SETQ  *PL1(PRDHK FL1)PL1 *PL1)
(UZINIT FL1)(SETQ  AB *AB *ABLN* (LIST (CONS 0 AB)) *AB NIL)

LOOP(COND ((NULL OVL)(RETURN(MERGEL FACFND*(MAPCAR (FUNCTION CONS) (CDR *OD*)  FL)))))
(SETQ A(LIST (CAR OVL)) OVL (CDR OVL) B (LIST(CAR VL)) VL (CDR VL))
(SETQ HVL (APPEND B HVL))
(SETQ GENVAR (APPEND A GENVAR))
(SETQ  *VBV* (1+ *VBV*)  DL (CDR DL))
(SETQ TERM(PDIFFERENCE (LIST (CAR A) 1 1) (CAR B)))
(SETQ U1 (PCSUBSTY (REVERSE VL)(REVERSE OVL) U))
(SETQ FL (MAPCAR (FUNCTION (LAMBDA(X) (PCSUBSTY (REVERSE VL)(REVERSE OVL) X)))FL))
(SETQ VALIST HVL OVARLIST (REVERSE (CDR (REVERSE GENVAR))))
(SETQ BLIST*(NREVERSE(MAPCAR (FUNCTION (LAMBDA(X Y) (PDIFFERENCE (LIST X 1 1) Y))) OVARLIST VALIST)))
((LAMBDA(*FL1 *PL1 *AB *ABL*)(SETQ FL(NZ1 U1 (LIST FLL FL) (CONS (CAR DL)TERM) A B))) (COPY1 FL1)(COPY1 PL1) AB *ABLN*)
(SETQ V/# (1+ V/#))
(COND ((NULL OVL)(RETURN(MERGEL FACFND*(MAPCAR (FUNCTION CONS)(CDR *OD*)  FL)))))
(GO TAG)))








; *DL LIST OF LISTS OF EXPONENT VECTORS OF TERMS IN THE FACTORS WITH DETERMINED COEFFS 

(DEFUN COEFSOLVE(U FL FLC)
(DECLARE (FIXNUM R TFS))
(PROG(DD VL EN *REIMPOSE J POSS POSL DPOSL NEW TFS TFJ R)
(COND(*NOC* (RETURN (LIST U NIL FL FLC))))
(SETQ R (LENGTH FL))
 ((LAMBDA(NN* *ODR*)(SETQ VL(MAPCAR (FUNCTION (LAMBDA(X)  (DEGVECTOR NIL 1. X)))FL)))(1+ V/#)(PUTODR (REVERSE GENVAR)))
(SETQ TFS 0.)
(COND ((= (LENGTH (CAAR *DL)) (LENGTH (CAAR VL))) NIL)
(T(SETQ *DL(MAPCAR (FUNCTION DUPDT) *DL VL))))
(SETQ DPOSL (SMLTL VL))
(FIXCNT *DL VL)
BK
(SETQ POSL DPOSL NEW NIL)
NEXTPOSS
(COND((= R (1+ TFS))(GO OUT))
((NULL POSL)(COND (NEW (GO BK))(T(GO OUT)))))
(SETQ POSS (CAR POSL) POSL (CDR POSL))
(COND ((SETQ J (REALPOS (CDR POSS) *DL))
(SETQ DPOSL(DELETE POSS DPOSL))
(COND((EQ J T) (GO NEXTPOSS))
 ((DIVIDEP (TCOEF U (CAR POSS)) (CDR POSS) J FLC)
(SETQ NEW T EN T)
(COND ((=  (STORE (CNT J) (1- (CNT J))) 0.)
(SETQ TFS (1+ TFS) TFJ (CONS J TFJ))))
(RPLACA (NCDR *DL J) (CONS (NTH (1- J)(CDR POSS)) (CAR (NCDR *DL J))))
))))

(GO NEXTPOSS)

OUT
(COND ((AND(= V/# 2.)(NULL EN))(SETQ *NOC* T)))
(RETURN (TCFACTORS U FLC FL TFS TFJ)) 
))


(DEFUN TCFACTORS(U FLC FL TFS TFJ)
(PROG(L TF ANS OD F1 DU I)
(COND ((= TFS 0.) (RETURN(LIST U NIL FL FLC))))
(SETQ I 0. OD *OD*)
LOOP(SETQ I (1+ I))
; U- REDUCED ORIGINAL POLY, TF TRUE FACTORS FOUND, L BASE POLYS FOR LIFTING, 
;ANS BASE POLYS WITH DETERMINED COEFFS.
(COND((NULL FL)
(COND ((NULL (CDR ANS))
(RETURN (LIST 1 (NREVERSE (CONS (CONS (CADR *OD*) U) TF)) NIL NIL))) 
(T(SETQ FL1 (NREVERSE F1))
(RETURN(LIST U (NREVERSE TF) (NREVERSE L)(NREVERSE ANS))))))
 ((MEMBER I TFJ) 
(COND ((SETQ DU (TESTDIVIDEZ U (CAR FLC)))
(SETQ TF (CONS (CONS (CADR OD)(CAR FLC)) TF))(SETQ U DU DU NIL)(RPLACD OD (CDDR OD))(GO B))
;(T (RMCS I) )
)))
(SETQ ANS (CONS (CAR FLC) ANS) L (CONS (CAR FL ) L)
F1 (CONS (CAR FL1) F1))
(SETQ OD (CDR OD))
B
(SETQ FL1 (CDR FL1) FLC (CDR FLC) FL (CDR FL))
(GO LOOP)))

;(DEFUN RMCS(I)
;(PROG(A B C)
;(SETQ A (NTH (1- I)LCF*) B (NTH (1- I) LCFV*) C (NCDR *DL I))
;BK
;(COND ((= (LENGTH (CADR B)) V/#)
;(SETQ I (CDR B)) (GO ON)) (T (SETQ A (CDR A) B (CDR B)) (GO BK)))
;ON
;(RPLACD B NIL) (RPLACD A NIL)
;(RPLACA C (CDR (NCDR (CAR C) (LENGTH I))))))


(DEFUN DIVIDEP(C VL J FACS)
(DECLARE (FIXNUM I J))
(PROG(DV V DF FAC I CF CFV LCF LCFV)
(SETQ I 0. LCF LCF* LCFV LCFV*)
LOOP (SETQ I (1+ I))
(COND ((NULL VL)
(NCONC CF (LIST C)) (NCONC CFV (LIST DV))
(CRPL DV C (CDR DF))(RETURN C)))
(SETQ V (CAR VL) FAC (CAR FACS) FACS (CDR FACS) VL (CDR VL))
(COND((= I J)(SETQ DV V DF FAC CF (CAR LCF) CFV (CAR LCFV)) (GO LOOP)))
(SETQ  LCF (CDR LCF) LCFV (CDR LCFV))
(COND ((SETQ C (TESTDIVIDEZ C (TCOEF FAC V)))NIL)(T(RETURN NIL))) 
(GO LOOP)))
(DEFUN FIXCNT(A B)
(DECLARE (FIXNUM I))
(PROG(I)
(SETQ I 0.)
LOOP(SETQ I (1+ I))
(COND ((NULL A) (RETURN NIL)))
(STORE (CNT I) (- (LENGTH (CAR B)) (LENGTH (CAR A))))
(SETQ  A (CDR A) B (CDR B))
(GO LOOP)))

;THIS FUNCTION GIVES THE NUMERICAL POSITION OF THE  EXPONENT (VECTOR)
; IF DETERMINANTION IS POSSIBLE 
;GIVES THE ATOM T IF  ALL TERMS IN A ARE ALREADY DETERMINED,
;GIVES NIL OTHERWISE.
; THE SECOND ARG IS A LIST OF EXPONENT (VECTOR) OF KNOWN COEFFS.


(DEFUN REALPOS(U V)
(PROG(I ANS)
(SETQ I 0.)
LOOP (COND ((NULL U) (RETURN(COND ((NULL ANS) T)(T ANS)))))
(SETQ I (1+ I))
(COND ((MEMBER (CAR U) (CAR V)) NIL)
(ANS (RETURN NIL))
(T (SETQ ANS I)))
(SETQ U (CDR U) V (CDR V))
(GO LOOP)))

(DEFUN SMLT(V1 V2)
(PROG(ANS DP S2 DV2 S D EL1 EL2)
(SETQ DV2 V2)
LOOP (COND ((NULL V1) (RETURN ANS)))
(SETQ EL1 (CAR V1) V1 (CDR V1) V2 DV2)
AG (COND ((NULL V2)(GO LOOP)))
 (SETQ EL2 (CAR V2)S2 (CAR EL2) EL2 (CDR EL2) V2 (CDR V2))
(SETQ S (MAPCAR  (FUNCTION +)EL1 S2))
(COND ((MEMBER S DP)(GO AG))
((SETQ D (CDR (ASSOC S ANS))) (SETQ DP (CONS S DP) )
(COND ((NOT (MEMBER NIL D))
(SETQ ANS
 (SUBST(CONS S (APPEND D (LIST NIL)))(CONS S D) ANS)))))
	;  Is this SUBST correct?  It is searching for a CONS!? - JPG
(T (SETQ ANS (CONS (CONS S(CONS EL1 EL2)) ANS))))
(GO AG)
))


; L IS A LIST OF LISTS OF EXPONENT VECTORS OF THE FACTORS IN
; ONE OR MORE VARIABLES
; IF THERE ARE THREE FACTORS AND TWO VARIABLES L MAY LOOK
; LIKE (((7 5) (7 3) (6 2) (1 0)) (( 5 4) (5 6) (2 3) (0 1)(0 0)) ((3 3) (3 2) (2 2) (1 0) (0 1)))

(DEFUN SMLTL(L)
(PROG(ANS)
(SETQ L (REVERSE L))
(SETQ ANS (MAPCAR (FUNCTION (LAMBDA(X) (LIST X X))) (CAR L)))
(SETQ L (CDR L))
LOOP(COND ((NULL L) (RETURN(DELETE NIL (MAPCAR (FUNCTION (LAMBDA(X) (COND ((MEMBER NIL X) NIL)(T X)))) ANS)))))
(SETQ ANS (SMLT (CAR L) ANS))
(SETQ L (CDR L))
(GO LOOP)))

(EVAL-WHEN (EVAL COMPILE)
	   (SETQ BASE OLD-BASE IBASE OLD-IBASE))
