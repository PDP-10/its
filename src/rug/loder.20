.MLLIT=1
TITLE	LOADER
;REVISED 1/2/74 FOR RUG'S WCNSL/ XSTBLK INSTEAD OF XHERE1

	BUFST=200/4	;PDP11 MAGIC CONSTANT START OF 10-11 BUFFER
	BUFSZ=500	;SIZE OF BUFFER OF RUG
	CHK=16
	ERP=15
	PPTR=14
	C=4
	D=11
	CKSM=12
	REG=13
	F=7
	S=10
	SPNTR=10
	P=6
	PNTR=1
	A=2
	B=3
	CMPTR=4
	BCOUNT=5

	O.SYMS=-100.	;GETS ADDED TO IN DEBUGGER

RCH:	MOVE	PNTR,[10700,,BUFF-1]	;INITL BYTE PNTR TO BUFF
	MOVEM	PNTR,CMPTR
GCHR:	PUSHJ	P,TYI	;GET CHAR
	CAIN	A,177	;RUBOUT?
	JRST	RUBOT
	IDPB	A,PNTR
	CAIE	A,15	;CR?
	JRST	GCHR
	MOVEI	A,0	;IT WAS CR
	IDPB	A,PNTR	;MARK END OF STRNG
CPOPJ:	POPJ	P,

RUBOT:	CAMN	PNTR,[10700,,BUFF-1]	;RUBOUT AT BEG OF BUFFER?
	JRST	BRUB
	LDB	A,PNTR	;GET LAST CHAR TYPED
	PUSHJ	P,TYO	;ECHO IT
	ADD	PNTR,[70000,,]	;DECREMENT POINTER
	JUMPGE	PNTR,GCHR	;JUMP IF VALID
	SUB	PNTR,[430000,,1]	;WAS 440700,,SOMETHING, BACK IT UP
	JRST	GCHR

BRUB:	PUSHJ	P,CRR	;TYPE CR LF
	JRST	GCHR
TYI:	.IOT	TTI,A
	JUMPE	A,TYI
	CAIE	A,15
	POPJ	P,
	PUSHJ	P,CRR	;ECHO CR
	MOVEI	A,15
	POPJ	P,
TYO:	.IOT	TTO,A
	POPJ	P,

SCRS:	MOVEI	A,2
	PUSHJ	P,TYO
CRS:	MOVEI	A,"*
	PUSHJ	P,TYO
CRR:	MOVEI	A,15
	PUSHJ	P,TYO
	MOVEI	A,12
	JRST	TYO

	LINE==1
	TTO==1
	TTI==2
	DSK==3
	ERRC==4

TEN11S:	0	;IF NON ZERO LOAD THROUGHT THE 10-11 INTERFACE
NCHAR:	0	;NUMBER OF CHARACTERS PLACED INTO CORE
11BYT0:	241000,,0
11BYT1:	341000,,0
11BYT2:	041000,,0
11BYT3:	141000,,0

BEGIN:	MOVE	P,[-100,,PLD]
	.OPEN	TTO,STTO
	.VALUE	0
	.OPEN	TTI,STTI
	.VALUE	0
	JRST	BCMD
STTO:	45,,(SIXBIT /TTY/)
STTI:	20,,(SIXBIT /TTY/)
STTI1:	4,,(SIXBIT /TTY/)
IDIOTB:	ASCIZ \YOU ARE AN IDIOT! TURN THE SWITCH TO R/W AND TYPE CR!!\
PLD:	BLOCK	100
BCMD:	PUSHJ	P,SCRS
	PUSHJ	P,RCH	;GET TYPED IN COMMANND
	MOVE	PNTR,IP
	SETZB	F,S
COMND:	ILDB	A,CMPTR
	CAIN	A,^Q
	JRST	CMDQ
	CAIN	A,15
	JRST	CMDE
	CAIN	A,^G
	JRST	BCMD
	CAIN	A,":
	JRST	CMDCOL
	CAIN	A,";
	JRST	CMDSC
	CAIG	A,40
	JRST	CMDS
SXBT:	SUBI	A,40
	TLNE	PNTR,770000	;STOP AFTER POSITIN=0
	IDPB	A,PNTR
	JRST	COMND
CMDS:	MOVE	F,S
CMD1:	MOVE	PNTR,IP
	MOVEI	S,0
	JRST	COMND
CMDSC:	MOVEM	S,SNR
	JRST	CMD1
CMDCOL:	JRST	CMD1	;FOR NOW IGNORE IT

IP:	440600,,S

CMDE:	.SUSET	[.SSNAM,,SNR]
	JUMPE	F,FZ
	JUMPN	S,SNZ
FZ:	LSHC	F,36.	;MOVE S TO F AND ZERO S
SZ:	JUMPE	F,BCMD	;TAKE IN NEW NAME
	MOVE	S,BIN
SNZ:	MOVEM	F,ADR+1
	MOVEM	S,ADR+2
	.OPEN	DSK,ADR
	JRST	ERROR
	.SUSET	[.RJNAM,,A]	;GET THE J NAME
	LSH	A,-44+6		;SHIFT IT DOWN
	CAIE	A,'M		;IS IT MLOADER?
	JRST	LOAD		;LOAD THE STUFF
	SETOM	TEN11S		;SET THE SWITCH
	.CALL	[SETZ
		SIXBIT /T11MP/
		[11BUF/2000]	;CLOBBER EBUF
		SETZ [<<600000,,0>+<4_26.>+<BUFST_10.>+1777>]]
	.VALUE 0
TRYAGN:	SETZM	RUGCHR
	SETZM	RUGWC
	HRREI	A,-20		;SET IT TO ALL ONES
	MOVEM	A,RUGBUF	;SET IT TO ALL ONES
	CAME	A,RUGBUF	;SUCCEED IN WRITING IT?
	JRST	IDIOT
	SETZM	RUGBUF
	SKIPE	RUGBUF
	JRST	IDIOT
LOAD:	.OPEN	TTI,STTI1	;SWITCH INTO IMAGE MODE
	.VALUE 0
	MOVEI	A,15
	.SLEEP	A,
	MOVEI	PNTR,0
	.RESET 	TTI,
	.IOT	LINE,[1]
	MOVE	ERP,EBUFP
	.OPEN	LINE,BTTO
	.VALUE	0
	SKIPN	TEN11S		;SKIP IF NOT 10-11 LOAD
	PUSHJ	P,BUFINT
	JRST	STBLK		;START THE BLOCK
IDIOT:	MOVE	B,[440700,,IDIOTB]
IDIOT1:	ILDB	A,B
	JUMPE	A,WAITSW	;WAIT FOR THE SWITCH
	PUSHJ	P,TYO
	JRST	IDIOT1
WAITSW:	PUSHJ	P,TYI		;GET A CHARACTER
	CAIE	A,15		;CR?
	JRST	WAITSW		;WAIT FOR IT
	JRST	TRYAGN
ERROR:	.OPEN	ERRC,ERR0
	.VALUE	0
ERR1:	.IOT	ERRC,A
	CAIN	A,3
	JRST	BCMD
	JUMPL	A,BCMD
	PUSHJ	P,TYO
	JRST	ERR1
ERR0:	SIXBIT /   ERR/
	1
	0

SNR:	0
ADR:	2,,(SIXBIT /DSK/)
	0
	0
BIN:	SIXBIT /BIN   /
CMDQ:	ILDB	A,CMPTR
	JRST	SXBT

BTTO:	47,,(SIXBIT /TTY/)
;PNTR HAS MINUS # LEFT SO ADRS(PNTR) GIVES NEXT WORD
;WHEN IT EQUALS 0, GET NEW BLOCK. IF RETURN WITH NEG
;POINTER, WRITE NEG 1 AS EOF CHAR

GETDSK:	JUMPE	PNTR,RELOD	;NEED NEW BLOCK
	MOVE	A,ADRS(PNTR)
	ADD	CHK,A
	AOJA	PNTR,CPOPJ	;ADD ONE AND RET URN
RELOD:	MOVE	PNTR,DBUFP
	.IOT	DSK,PNTR
	JUMPL	PNTR,ENFIL
NPNTR:	HLRE	PNTR,DBUFP	;GET MIN WRD COUNT IN PNTR
	JRST	GETDSK
ENFIL:	HRRZS	PNTR	;ZERO LEFT HALF TO GET NEXT ADRESS
	SETOM	(PNTR)	;WRITE EOF CHAR
	JRST	NPNTR

DBUFP:	-2000,,BUFR
BUFR:	BLOCK	2000
	ADRS=.
STBLK3:	TRNE	CHK,377
	.VALUE 0
	SETOM	A
	PUSHJ	P,SEND	;SIGNAL TO REALLY IOT CRUFT
STBLK:	MOVEI	CHK,0
	SKIPN	TEN11S		;SHOULD BE ALREADY RESET
	MOVE	ERP,EBUFP
STBLK2:	PUSHJ	P,GETDSK
	MOVEI	BCOUNT,15	;RANDOM NUMBER
	JUMPL	A,DONE
	PUSHJ	P,SEND
	CAIE	A,41
	JRST	STBLK2	;SEARCH FOR BEGINNING OF BLOCK
	PUSHJ	P,GETDSK	;SHOULD BE ZERO
	PUSHJ	P,SEND
	PUSHJ	P,GSWRD
	SUBI	B,3	;GET CORRECT BYTE COUNT
	MOVEM	B,BCOUNT
	PUSHJ	P,GSWRD
DATA:	PUSHJ	P,GSWRD
	JUMPL	BCOUNT,DONE	;WAS A JUMP BLOCK
LOOP:	JUMPLE	BCOUNT,STBLK3
	PUSHJ	P,GSWRD
	JRST	LOOP

DONE:	SKIPE TEN11S
	AOS NCHAR
	TRNE	CHK,377
	.VALUE 0
	SETOM	A
	PUSHJ	P,SEND
	JRST	SYMBS

BUFF:	BLOCK	10


EBUFP:	10700,,EBUFF-1
GSWRD:	PUSHJ	P,GETDSK
	ANDI	A,377
	LSHC	A,-36.	;MOVE A TO B AND ZERO A
	SOSLE	BCOUNT	;IF CHECKSUM DON'T GET EXTRA BLOCK YET
	PUSHJ	P,GETDSK
	SOS	BCOUNT
	AOSE	A	;WAS IT A NEG 1?
	SOS	A	;IF NOT RESTORE, ELSE SEND ZERO
	LSH	A,8.
	ADDB	A,B
SWORD:	ANDI	A,77
	PUSHJ	P,SEND
	MOVE	A,B
	LSH	A,-6
	ANDI	A,17
	PUSHJ	P,SEND
	MOVE	A,B
	LSH	A,-10.
	ANDI	A,77
SEND:	SKIPE	TEN11S	;LOAD THROUGH THE TTY
	JRST	SEND1	;SEND FOR THE TEN-11 INTERFACE.
	JUMPL	A,FSEND	;ACTUALLY IOT THIS CRUFT
	ADDI	A,40
	IDPB	A,ERP
	POPJ	P,
FSEND:	MOVEI	F,5
	MOVEI	A,40
FSNDL:	IDPB	A,ERP
	SOSLE	F
	JRST	FSNDL
	HRRZM	ERP,SPNTR
	SUBI	SPNTR,EBUFF
	MOVNS	SPNTR
	HRLZS	SPNTR
	HRRI	SPNTR,EBUFF
	MOVEM	SPNTR,SPSAV
RESEND:	.IOT	LINE,SPNTR
	.IOT	TTI,A
	ANDI	A,177
	CAIN	A,4
	POPJ	P,
	MOVE	SPNTR,SPSAV
	JRST	RESEND

SPSAV:	0

SEND1:	JUMPL	A,FSEND1	;ACTUALLY SEND THIS STUFF
	ADDI	A,40		;NO CONTROL CHAR?
	HLRZ	F,ERP		;GET WHICH POINTER TO USE
	HRRM	ERP,11BYT0(F)	;DEPOSIT THE CORRECT ADDRESS TO USE
	DPB	A,11BYT0(F)	;PUT THE BYTE INTO THE MEMORY
	CAIE	F,3		;DOES IT POINT TO THE END
	JRST	[ADD ERP,[1,,0] ? JRST SENDCK ]
	ADD	ERP,[-3,,1]	;INCREMENT 10 WORD
SENDCK:	SOSE	NCHAR		;TRANSMIT UP TO MAX NO. OF CHARACTERS
	POPJ	P,		;STILL ROOOM LEFT
	PUSHJ	P,SEND11	;SEND BLOCK TO 11
BUFINT:	MOVEI	ERP,BUFSZ
	MOVEM	ERP,NCHAR	;RESET NUMBER OF BYTES
	MOVEI	ERP,RUGBUF	;RESET POINTER TO START OF BUFFER
	POPJ	P,		;DONE

FSEND1:	SKIPE	RUGCHR		;SHOULD BE EMPTY
	.VALUE
	PUSHJ	P,SEND11	;SEND THE BLOCK TO THE 11
	SKIPN	RUGCHR		;SKIP ONLY WHEN 11 ACKNOWLEDGES
	.HANG			;WAIT A LONG TIME
	MOVE	F,RUGCHR	;BETTER BE NON ZERO
	SKIPN	F
	.VALUE
	LSH	F,-24		;GET IT INTO THE LOW BYTES
	ANDI	F,177		;TO GET THE CHARACTER
	CAIE	F,4		;BETTER BE ACKNOWLEDGE
	.VALUE			;WHOULD NEVER BE ANY ERRORS HERE.
	SETZM	RUGCHR		;MAKE IT ZERO NOW
	JRST	BUFINT		;INIT THE BUFFER

SEND11:	MOVEI	F,BUFSZ
	SUB	F,NCHAR		;CALCULATE THE NUMBER OF CHARACTERS IN THE BUFFER
	LSH	F,24		;INTO THE FIRST WORD
	MOVEM	F,RUGWC		;SET IN THE WORD COUNT
	SKIPE	RUGWC		;SET UP AND WAIT FOR BUFFER TO EMPTY
	.HANG
	POPJ	P,

ONE:	1_29.
SYMBS:	SKIPE	TEN11S	;SKIP IF LOADING THROUGH TTY
	JRST SYMBS1	;LOAD THROUGH 10-11 INTERFACE
	.IOT	TTI,A
	CAIN	A,47	;^G;I.E.DON'T SEND SYMBOLS
	JRST	GBYE
	CAIE	A,5
	JRST	SYMBS	;THAT SIGNALS 11 READY FOR SYMBOLS
	MOVE A,[-1,,ONE]
	.IOT LINE,A
SYM1:	PUSHJ	P,GETDSK
	CAIE	A,2
	JRST	SYM1
	SETZM FINFLG
;	PUSHJ	P,SETUP1
;	SKIPN	FINFLG
	PUSHJ	P,SETUPU
;	MOVEI	C,BUFF1
;	PUSHJ	P,SNDB
	MOVEI	C,FBUFF
	PUSHJ	P,SNDB
GBYE:	SKIPE	TEN11S
	JRST	[HRLZI A,400000 ? MOVEM A,RUGCHR ? JRST .+1]
	.VALUE	[ASCIZ /:LOGOUT
/]

SYMBS1:	SKIPN	RUGCHR
	.HANG
	MOVE	A,RUGCHR	
	LSH	A,-24		;GET THE FIRST WORD
	CAIN	A,47
	JRST	GBYE
	SETZM	RUGCHR		;ZERO IT
	MOVE	A,[1_24]	;WRITE ONE INTO THE BUFFER
	MOVEM	A,RUGBUF	;SEND IT
	MOVEM	A,RUGWC		;ALSO THE BYTE COUNT IS 1
	SKIPE	RUGWC
	.HANG
	PUSHJ P,BUFINT		;INIT THE BUFFER.
	JRST SYM1		;GET THE SYMS AND SEND THEM

SETUP1:	SETZM	FINFLG
	MOVEI	REG,R1
	MOVEI	C,7.
	MOVEI	B,BF1ST
	PUSHJ	P,SETUP
	JUMPE	C,CPOPJ
	MOVNS	C
	ADDI	C,17.	;SEE HOW MUCH LEFT
	IMULI	C,6
	ADD	C,LDAD
	MOVEM	C,..B
	SETOM	FINFLG
	POPJ	P,
SETUPU:	MOVEI	REG,RFLGS
	SETZM	(REG)
	SETZM	-1(REG)
	MOVNI	A,100.
	ADDM	A,LDAD
	MOVEI	C,1
	MOVEI	B,BUFFST
	PUSHJ	P,SETUP
	MOVE	A,LDAD
	MOVEM	A,..B
	JUMPE	C,SAME
	MOVNS	C
	ADDI	C,17.
	IMULI	C,6
	ADDM	C,..B
	SETOM	FINFLG
SAME:	MOVEI	C,BUFF2
	PUSHJ	P,SNDB
	SKIPN	FINFLG
	JRST	SETUPU
	POPJ	P,
SNDB:	SKIPN	TEN11S
	MOVE	ERP,EBUFP
	MOVE	BCOUNT,1(C)
	SUBI	BCOUNT,2
	MOVEI	CKSM,1
STPN:	MOVEI	A,1
	PUSHJ	P,SEND
	MOVEI	A,0
	PUSHJ	P,SEND
SNDLP:	MOVE	A,1(C)
	ADDM	A,CKSM
	MOVEM	A,B
	LSH	A,-8.
	ADDM	A,CKSM
	SUBI	BCOUNT,2
	MOVE	A,B
	PUSHJ	P,SWORD
	AOS	C
	JUMPN	BCOUNT,SNDLP
	MOVN	A,CKSM
	ANDI	A,377
	MOVE	B,A
	PUSHJ	P,SWORD
	SETOM	A
	PUSHJ	P,SEND	;.IOT THE BLOCK
	POPJ	P,


FINFLG:	0
SBTB:	440600,,A	;SIXBIT BYTE POINTER TO A

RAD50:	MOVE	PPTR,SBTB
	PUSHJ	P,LOOP50
	HRRZM	F,-2(B)
	PUSHJ	P,LOOP50
	MOVEM	F,-1(B)
	POPJ	P,
LOOP50:	MOVEI	F,0
	MOVEI	BCOUNT,3
LOP50:	ILDB	S,PPTR
	PUSHJ	P,CNVT
	IMULI	F,50
	ADD	F,S
	SOJG	BCOUNT,LOP50
	POPJ	P,

CNVT:	CAIGE	S,41
	JRST	NOTLET
	CAILE	S,72
	JRST	NOTLET
	SUBI	S,40
	POPJ	P,
NOTLET:	CAIN	S,4
	JRST	DOLR
	CAIN	S,16
	JRST	PERD
	CAILE	S,31
	JRST	NOTNUM
	CAIGE	S,20
	JRST	NOTNUM
	ADDI	S,16
	POPJ	P,
NOTNUM:	MOVEI	S,0
	POPJ	P,
DOLR:	MOVEI	S,33
	POPJ	P,
PERD:	MOVEI	S,34
	POPJ	P,
SETUP:	PUSHJ	P,GETDSK
	JUMPE	A,CPOPJ
	AOJE	A,CPOPJ
	SOS	A
	PUSHJ	P,RAD50		;DEPOSITS INTO MEMORY
	PUSHJ	P,GETDSK	;VALUE THIS TIME
	HRRZM	A,(B)
	MOVEI	D,1
	LSH	D,-1(C)	;SO CAN POINT TO RIGHT BIT IN FLAG
	MOVE	S,(REG)
	TLNE	A,4000
	TDO	S,D
	MOVEM	S,(REG)
	MOVE	S,-1(REG)
	TLNE	A,20000
	TDO	S,D
	MOVEM	S,-1(REG)
	SUBI	B,3
	AOS	C
	CAIG	C,16.
	JRST	SETUP
	MOVEI	C,0
	POPJ	P,
BUFF1:	1
	106.
	O.SYMS
	BLOCK	29.
BF1ST:	0
	127570	;/.C /
	0
	24
	130600	;/.P /
	0
	10
	130410	;/.M /
	0
	11
	127520	;/.B /
	0
	14
	131542	;/..B/
	0
..B:	0
	127400	;/.  /
	0
	0
HK1:	1
R1:	74
BUFF2:	1
	106.
LDAD:	0
	BLOCK	47.
BUFFST:	0
	0
RFLGS:	0

FBUFF:	1
	6
	0

	CONSTANTS
	VARIABLES
.=<.&<776000>>+2000	;ROUND IT
EBUFF:	BLOCK	10000-1
	-1	;TO FAKE OUT DDT'S LOADER INTO CAUSING ENOUGH MEMORY
11BUF=.
RUGWC=11BUF
RUGCHR=RUGWC+1
RUGBUF=RUGCHR+1
	END	BEGIN
