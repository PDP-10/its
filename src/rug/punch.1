	TITLE	PUNCH
	O.SYMS=-100.
	EOT=66
	CSIZE=17
	F=7
	S=10
	P=6
	PNTR=1
	A=2
	B=3
	CMPTR=4
	BCOUNT=5

RCH:	MOVE	PNTR,[10700,,BUFF-1]	;INITL BYTE PNTR TO BUFF
	MOVEM	PNTR,CMPTR
GCHR:	PUSHJ	P,TYI	;GET CHAR
	CAIN	A,177	;RUBOUT?
	JRST	RUBOT
	IDPB	A,PNTR
	CAIE	A,15	;CR?
	JRST	GCHR
	MOVEI	A,0	;IT WAS CR
	IDPB	A,PNTR	;MARK END OF STRNG
CPOPJ:	POPJ	P,

RUBOT:	CAMN	PNTR,[10700,,BUFF-1]	;RUBOUT AT BEG OF BUFFER?
	JRST	BRUB
	LDB	A,PNTR	;GET LAST CHAR TYPED
	PUSHJ	P,TYO	;ECHO IT
	ADD	PNTR,[70000,,]	;DECREMENT POINTER
	JUMPGE	PNTR,GCHR	;JUMP IF VALID
	SUB	PNTR,[430000,,1]	;WAS 440700,,SOMETHING, BACK IT UP
	JRST	GCHR

BRUB:	PUSHJ	P,CRR	;TYPE CR LF
	JRST	GCHR
TYI:	.IOT	TTI,A
	JUMPE	A,TYI
	CAIE	A,15
	POPJ	P,
	PUSHJ	P,CRR	;ECHO CR
	MOVEI	A,15
	POPJ	P,
TYO:	.IOT	TTO,A
	POPJ	P,

CRS:	MOVEI	A,"*
	PUSHJ	P,TYO
CRR:	MOVEI	A,15
	PUSHJ	P,TYO
	MOVEI	A,12
	JRST	TYO

	LINE==1
	TTO==1
	TTI==2
	DSK==3
	ERRC==4
	PTPC==5


BEGIN:	MOVE	P,[-100,,PLD]
	.OPEN	TTO,STTO
	.VALUE	0
	.OPEN	TTI,STTI
	.VALUE	0
	.OPEN	PTPC,[11,,(SIXBIT /PTP/)]
	.VALUE	0
	JRST	BCMD
STTO:	5,,(SIXBIT /TTY/)
STTI:	0,,(SIXBIT /TTY/)

PLD:	BLOCK	100
BCMD:	PUSHJ	P,CRS
	PUSHJ	P,RCH	;GET TYPED IN COMMANND
	MOVE	PNTR,IP
	SETZB	F,S
COMND:	ILDB	A,CMPTR
	CAIN	A,^Q
	JRST	CMDQ
	CAIN	A,15
	JRST	CMDE
	CAIN	A,^G
	JRST	BCMD
	CAIN	A,":
	JRST	CMDCOL
	CAIN	A,";
	JRST	CMDSC
	CAIG	A,40
	JRST	CMDS
SXBT:	SUBI	A,40
	TLNE	PNTR,770000	;STOP AFTER POSITIN=0
	IDPB	A,PNTR
	JRST	COMND
CMDS:	MOVE	F,S
CMD1:	MOVE	PNTR,IP
	MOVEI	S,0
	JRST	COMND
CMDSC:	MOVEM	S,SNR
	JRST	CMD1
CMDCOL:	JRST	CMD1	;FOR NOW IGNORE IT

IP:	440600,,S

CMDE:	.SUSET	[.SSNAM,,SNR]
	JUMPE	F,FZ
	JUMPN	S,SNZ
FZ:	LSHC	F,36.	;MOVE S TO F AND ZERO S
SZ:	JUMPE	F,BCMD	;TAKE IN NEW NAME
	MOVE	S,BIN
SNZ:	MOVEM	F,ADR+1
	MOVEM	S,ADR+2
	.OPEN	DSK,ADR
	JRST	ERROR
	SETZB	PNTR,PBDON
	MOVE	CSIZE,SIZE
	JRST	STBLK
ERROR:	.OPEN	ERRC,ERR0
	.VALUE	0
ERR1:	.IOT	ERRC,A
	CAIN	A,3
	JRST	BCMD
	JUMPL	A,BCMD
	PUSHJ	P,TYO
	JRST	ERR1
ERR0:	SIXBIT /   ERR/
	1
	0

SNR:	0
ADR:	2,,(SIXBIT /DSK/)
	0
	0
BIN:	SIXBIT /BIN   /
 CMDQ:	ILDB	A,CMPTR
	JRST	SXBT
;PNTR HAS MINUS # LEFT SO ADRS(PNTR) GIVES NEXT WORD
;WHEN IT EQUALS 0, GET NEW BLOCK. IF RETURN WITH NEG
;POINTER, WRITE NEG 1 AS EOF CHAR

GETDSK:	JUMPE	PNTR,RELOD	;NEED NEW BLOCK
	MOVE	A,ADRS(PNTR)
	AOJA	PNTR,CPOPJ	;ADD ONE AND RET URN
RELOD:	MOVE	PNTR,DBUFP
	.IOT	DSK,PNTR
	JUMPL	PNTR,ENFIL
NPNTR:	HLRE	PNTR,DBUFP	;GET MIN WRD COUNT IN PNTR
	JRST	GETDSK
ENFIL:	HRRZS	PNTR	;ZERO LEFT HALF TO GET NEXT ADRESS
	SETOM	(PNTR)	;WRITE EOF CHAR
	JRST	NPNTR

DBUFP:	-50,,BUFR
BUFR:	BLOCK	50
	ADRS=.
STBLK:	SKIPE	PBDON
	PUSHJ	P,NEWBLK
	PUSHJ	P,GETDSK
	JUMPL	A,EDONE
	CAIE	A,1
	JRST	STBLK	;SEARCH FOR BEGINNING OF BLOCK
	MOVEI	B,5
	PUSHJ	P,LEADR
	MOVEI	A,1
	PUSHJ	P,SEND
	PUSHJ	P,GETDSK	;SHOULD BE ZERO
	PUSHJ	P,SEND
	PUSHJ	P,GSWRD
	SUBI	B,3	;GET CORRECT BYTE COUNT
	CAIN	B,3
	JRST	JBLOCK
	MOVEM	B,BCOUNT
LOOP:	PUSHJ	P,GSEND
	JUMPG	BCOUNT,LOOP
	JRST	STBLK

DONE:	MOVEI	B,100.
	PUSHJ	P,LEADR
	JRST	SYM1

BUFF:	BLOCK	10

GSEND:	PUSHJ	P,GETDSK
	SOS	BCOUNT
SEND:	.IOT	PTPC,A
	SOSGE	CSIZE
	SETOM	PBDON
	POPJ	P,

JBLOCK:	PUSHJ	P,GSWRD
	PUSHJ	P,GSEND
	JRST	DONE

PBDON:	0
SIZE:	20000
GSWRD:	PUSHJ	P,GSEND
	MOVE	B,A
	PUSHJ	P,GSEND
	LSH	A,8.
	ADDB	A,B
	POPJ	P,


NEWBLK:	MOVEI	A,EOT
	PUSHJ	P,SEND
	MOVEI	B,80.
	PUSHJ	P,LEADR
	.VALUE	0
	MOVEI	B,100.
	PUSHJ	P,LEADR
	SETZM	PBDON
	MOVE	CSIZE,SIZE
	POPJ	P,
	TITLE	LOADER
	CHK=16
	ERP=15
	PPTR=14
	C=4
	D=11
	CKSM=12
	REG=13

SYM1:	PUSHJ	P,GETDSK
	CAIE	A,2
	JRST	SYM1
	PUSHJ	P,SETUP1
	SKIPN	FINFLG
	PUSHJ	P,SETUPU
	MOVEI	C,BUFF1
	PUSHJ	P,SNDB
	MOVEI	C,FBUFF
	PUSHJ	P,SNDB
EDONE:	.VALUE	0

SETUP1:	SETZM	FINFLG
	MOVEI	REG,R1
	MOVEI	C,8.
	MOVEI	B,BF1ST
	PUSHJ	P,SETUP
	JUMPE	C,CPOPJ
	MOVNS	C
	ADDI	C,16.	;SEE HOW MUCH LEFT
	IMULI	C,6
	ADD	C,LDAD
	MOVEM	C,..B
	SETOM	FINFLG
	POPJ	P,
SETUPU:	MOVEI	REG,RFLGS
	SETZM	(REG)
	SETZM	-1(REG)
	MOVNI	A,100.
	ADDM	A,LDAD
	MOVEI	C,1
	MOVEI	B,BUFFST
	PUSHJ	P,SETUP
	MOVE	A,LDAD
	MOVEM	A,..B
	JUMPE	C,SAME
	MOVNS	C
	ADDI	C,16.
	IMULI	C,6
	ADDM	C,..B
	SETOM	FINFLG
SAME:	MOVEI	C,BUFF2
	PUSHJ	P,SNDB
	SKIPN	FINFLG
	JRST	SETUPU
	POPJ	P,

FINFLG:	0
SNDB:	SKIPE	PBDON
	PUSHJ	P,NEWBLK
	MOVEI	ERP,EBUFF
	MOVE	BCOUNT,1(C)
	MOVEI	CKSM,0
SNDLP:	MOVE	A,(C)
	ADDM	A,CKSM
	PUSHJ	P,SEND
	LSH	A,-8.
	ADDM	A,CKSM
	PUSHJ	P,SEND
	SUBI	BCOUNT,2
	AOS	C
	JUMPN	BCOUNT,SNDLP
	MOVN	A,CKSM
	ANDI	A,377
	PUSHJ	P,SEND
	MOVEI	B,10.
	PUSHJ	P,LEADR
	POPJ	P,

LEADR:	MOVEI	A,0
LEDR:	PUSHJ	P,SEND
	SOJGE	B,LEDR
	POPJ	P,
SBTB:	440600,,A	;SIXBIT BYTE POINTER TO A

RAD50:	MOVE	PPTR,SBTB
	PUSHJ	P,LOOP50
	HRRZM	F,-2(B)
	PUSHJ	P,LOOP50
	MOVEM	F,-1(B)
	POPJ	P,
LOOP50:	MOVEI	F,0
	MOVEI	BCOUNT,3
LOP50:	ILDB	S,PPTR
	PUSHJ	P,CNVT
	IMULI	F,50
	ADD	F,S
	SOJG	BCOUNT,LOP50
	POPJ	P,

CNVT:	CAIGE	S,41
	JRST	NOTLET
	CAILE	S,72
	JRST	NOTLET
	SUBI	S,40
	POPJ	P,
NOTLET:	CAIN	S,4
	JRST	DOLR
	CAIN	S,16
	JRST	PERD
	CAILE	S,31
	JRST	NOTNUM
	CAIGE	S,20
	JRST	NOTNUM
	ADDI	S,16
	POPJ	P,
NOTNUM:	MOVEI	S,0
	POPJ	P,
DOLR:	MOVEI	S,33
	POPJ	P,
PERD:	MOVEI	S,34
	POPJ	P,
SETUP:	PUSHJ	P,GETDSK
	JUMPE	A,CPOPJ
	AOJE	A,CPOPJ
	SOS	A
	PUSHJ	P,RAD50		;DEPOSITS INTO MEMORY
	PUSHJ	P,GETDSK	;VALUE THIS TIME
	HRRZM	A,(B)
	MOVEI	D,1
	LSH	D,-1(C)	;SO CAN POINT TO RIGHT BIT IN FLAG
	MOVE	S,(REG)
	TLNE	A,4000
	TDO	S,D
	MOVEM	S,(REG)
	MOVE	S,-1(REG)
	TLNE	A,20000
	TDO	S,D
	MOVEM	S,-1(REG)
	SUBI	B,3
	AOS	C
	CAIG	C,16.
	JRST	SETUP
	MOVEI	C,0
	POPJ	P,
BUFF1:	1
	106.
	O.SYMS
	BLOCK	26.
BF1ST:	0
	127570	;/.C /
	0
	25
	130600	;/.P /
	0
	11
	130410	;/.M /
	0
	12
	130770	;/.S /
	0
	10
	127520	;/.B /
	0
	15
	131542	;/..B/
	0
..B:	0
	127400	;/.  /
	0
	0
HK1:	1
R1:	174
BUFF2:	1
	106.
LDAD:	O.SYMS
	BLOCK	47.
BUFFST:	0
	0
RFLGS:	0

FBUFF:	1
	6
	100000	;JUMPT TO DEBUGGER

	CONSTANTS
	VARIABLES
EBUFF:	BLOCK	10000
	-1	;TO FAKE OUT DDT'S LOADER INTO CAUSING ENOUGH MEMORY
	END	BEGIN
