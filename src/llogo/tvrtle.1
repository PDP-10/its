;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;            		Lisp Logo TV Turtle				      ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;

;;; 
;;TV'S HAVE 455.  VERTICAL LINES OF 576.  DOTS EACH (262080.  BITS OUT 'O 262144). 
;;MEMORY IS ORGANIZED AS 9 64.-BIT WORDS (EQUIV TO 18.  32.-BIT WORDS) PER LINE. 
;;THE PDP10 ACCESSES HALF OF SUCH A WORD (OR TWO 16.-BIT CHUNKS) AT ONCE.  THESE 32. 
;;BITS ARE PACKED LEFT JUSTIFIED INTO THE 36.  BITS.  TVEND (OR THE LAST WORD OF THE
;;TV-MEMORY) HAS TWO FUNCTIONS: BIT 200000 WHEN ON, COMPLEMENTS THE BLACK/WHITE
;;OUTPUT.  BITS 177760 ARE A WORD-COUNTER FOR WHICH 64.-BIT WORD THE FRAME IS TO
;;START ON.  FOR WINNAGE THE NUMBER OUGHT TO BE A MULTIPLE OF 9.  CHARACTERS ARE 10. 
;;LINES HIGH AND 5 POINTS WIDE (RIGHT AND TOP JUSTIFIED).  LINE-PITCH IS 12. 
;;TV-LINES, CHARACTER-PITCH IS 6 TV-POINTS.  THATS 96.  CHRS/LINE EXACTLY AND 37. 
;;AND 11./12.  LINES (3552.  CHRS).

(DECLARE (EVAL (READ)) (EVAL (READ)))

(OR (STATUS FEATURE DEFINE) (FASLOAD DEFINE FASL AI LLOGO))

(COND ((BOUNDP 'COLOR) (SETQ BW (NOT COLOR)))
      ;;READ-TIME SWITCHES FOR COLOR OR BLACK AND WHITE SYSTEM.
      ;;TO SET SWITCHES, DO E.G., &(SETQ COLOR T) IN CONTROL-G'ED NCOMPLR.
      ((BOUNDP 'BW) (SETQ COLOR (NOT BW)))
      ((SETQ COLOR NIL BW T)))


(SSTATUS FEATURE TVRTLE) 

[COLOR (SSTATUS FEATURE COLOR)
       (SETQ COLOR T BW NIL)]

[BW (SETQ BW T COLOR NIL)]

[COLOR (DEFUN NOT-IMPLEMENTED-IN-COLOR (LOSING-FORM)
              (PRINC '/;)
              (AND LOSING-FORM (PRINC LOSING-FORM))
              (PRINC '" NOT IMPLEMENTED IN COLOR TURTLE")
              (TERPRI)
              NO-VALUE)]

[BW (DEFUN NOT-IMPLEMENTED-IN-BW (LOSING-FORM)
           (PRINC '/;)
           (AND LOSING-FORM (PRINC LOSING-FORM))
           (PRINC '" IMPLEMENTED IN COLOR TURTLE ONLY")
           (TERPRI)
           NO-VALUE)]

(DECLARE (GENPREFIX TVRTLE-)) 

(AND (STATUS FEATURE BIBOP) (ALLOC '(FLONUM (3000. 4000. NIL) FLPDL 2000.))) 

(COND
 ((STATUS FEATURE LLOGO)
  ;;PUT GLOBAL VARIABLES ON LOGO OBARRAY.
  (READ-ONLY :XCOR :YCOR :HEADING :PENSTATE :ERASERSTATE :SEETURTLE :ECHOLINES 
             :TVECHOLINES :PI :POLYGON :WRAP  :CLIP :DRAWMODE :XORSTATE :TURTLE 
             :PATTERNS :TURTLES :WINDOWS :DRAWTURTLE :ERASETURTLE :BRUSH 
             :PENCOLOR :ERASERCOLOR :PENNUMBER :ERASERNUMBER :COLORS)
  (SYSTEM-VARIABLE :OUTLINE :WINDOWOUTLINE :COLORTICK :NCOLORS)
  (MAPC '(LAMBDA (LOGO-ATOM) (OBTERN LOGO-ATOM LOGO-OBARRAY))
	'(TV IOR ANDC SETZ COMP XOR EQV SAME LOGOTURTLE 
          COLOR BLACK PALETTE WHITE RED GREEN BLUE YELLOW PURPLE MAGENTA CYAN 
          ORANGE GOLD PINK GRAY LIGHTGRAY DARKGRAY TURTLE)))
 ((DEFUN HOMCHECK (USELESS) USELESS)
  (DEFUN OBTERN (IGNORE THIS) IGNORE)
  (DEFUN SYMBOLP (MAYBE-SYMBOL) 
	 (AND MAYBE-SYMBOL (EQ (TYPEP MAYBE-SYMBOL) 'SYMBOL)))
  ;;DEFINE FUNCTIONS CALLED FROM TVRTLE, NORMALLY IN LLOGO.
  (DEFUN FILESPEC (X) 
	 (OR (APPLY 'AND (MAPCAR 'ATOM X))
	     (SETQ X
		   (ERRBREAK 'FILESPEC
			     (LIST X
				   '"IS NOT A FILE NAME"))))
	 (COND ((NULL X) (APPEND (STATUS CRFILE) (CRUNIT)))
	       ((NOT (CDR X)) (APPEND X '(>) (CRUNIT)))
	       ((NOT (CDDR X)) (APPEND X (CRUNIT)))
	       ((NOT (CDDDR X))
		(APPEND (LIST (CAR X) (CADR X)) '(DSK) (CDDR X)))
	       (X)))
  (DEFUN FUNCTION-PROP (F) 
	 (GETL F '(EXPR FEXPR MACRO SUBR LSUBR FSUBR ARRAY AUTOLOAD)))
  (SETQ LISP-OBARRAY OBARRAY LISP-READTABLE READTABLE)
  ;;SAVE/GETWINDOW REQUIRES FILESPEC.
  (DEFUN TYPE ARGS (DO ((I 1. (1+ I))) ((> I ARGS) (ARG (1- I))) (PRINC (ARG I))))
  ;;TYPE USED BY MARK, HOMCHECK, OBTERN OUTPUT BY DEFINE.
  (DEFUN ERRBREAK ARGS (PRINC (ARG 1.)) (APPLY 'BREAK (LIST (ARG 2.) T)))
  (SETQ NO-VALUE '?))) 

;;SYMBOLS MUST BE LOADED TO CALL GETCOR, SACONS.

(VALRET '" :SYMLOD
:VP
") 

;;*PAGE

;;;

(COMMENT LAP ROUTINES) 

;;;
;;THE FOLLOWING ROUTINE GETS A 10K BLOCK OF CORE RESERVED FROM LISP FOR THE TV ARRAY
;;VIA GETCOR, AND SETS UP THE ARRAY HEADER TO POINT TO IT CORRECTLY. 
;;AN ORDINARY LISP ARRAY CANNOT BE USED SINCE IT MUST BE PROTECTED FROM NORMAL ARRAY
;;RELOCATION DURING GARBAGE COLLECTION, ETC.
;;;

;;;			FORMAT OF LISP ARRAYS.
;;;
;;A LISP ARRAY HAS A TWO WORD HEADER ["SAR"], CREATED BY CALLING THE INTERNAL LISP
;;ROUTINE SACONS.  THE FIRST WORD IS CALLED THE "ASAR", SECOND THE "TTSAR". THE
;;OCTAL NUMBER PRINTED OUT IN ARRAY POINTERS IS THE ASAR, ASSEMBLING (ARRAY FOO) IN
;;LAP YIELDS POINTER TO THE TTSAR. FOR A TWO DIMENSIONAL FIXNUM ARRAY THEY ARE AS
;;FOLLOWS:
;;;
;;; ASAR: 	200 [TYPE CODE FOR FIXNUM] 
;;;             ,, <POINTER TO START OF INSTRUCTION-BLOCK>
;;; TTSAR:	100107 [WHERE 1 IS THE NUMBER OF DIMENSIONS, 
;;;		       107 IS (TT) [INDEXED BY TT]] 
;;;             ,, <POINTER TO START OF ARRAY-DATA>
;;;
;;THE BLOCK OF DATA FOR THE ARRAY IS AS FOLLOWS:
;;;
;;;		-1 [MINUS NUMBER OF DIMENSIONS] ,, <POINTER TO START OF ARRAY-DATA>
;;; INSTRUCTION-BLOCK:
;;;		PUSHJ P, CFIX1 [FOR FIXNUMS]
;;;		JSP TT, 1DIMF  [FOR 1 DIMENSIONAL ARRAYS]
;;;		<POINTER BACK TO ASAR>
;;;		<1ST DIMENSION>
;;; ARRAY-DATA: .....DATA HERE.....
;;;


(LAP SETUP-TV-ARRAY SUBR)
(ARGS SETUP-TV-ARRAY (NIL . 0))
(DEFSYM TTSAR-DATA 100107)
(DEFSYM FIXNUM-ARRAY 200)
(DEFSYM IMMEDIATE 1000)
(DEFSYM READ-WRITE-ACCESS 600000)
	(HLLOS 0 NOQUIT)
	(PUSH FXP D)
	(PUSH FXP F)
	(PUSH FXP TT)
	(MOVEI TT 12)
	(PUSHJ P GETCOR)
	(SKIPN 0 TT)
	(*VALUE)
	(ADDI TT 2000)
	(MOVEI F -5 TT)
	(HRLI F TV-ARRAY-HEADER)
	(BLT F -1 TT)
	(HRRM TT -5 TT)
	(PUSH FXP TT)
	(JSP T SACONS)
	(POP FXP TT)
	(MOVEM A -2 TT)
	(HRLI F FIXNUM-ARRAY)
	(HLLM F 0 A)
	(MOVEI F -4 TT)
	(HRRM F 0 A)
	(HRLI F TTSAR-DATA)
	(HLLM F 1 A)
	(HRRM TT 1 A)
	(MOVEM A (SPECIAL TV))
	(POP FXP TT)
	(POP FXP F)
	(POP FXP D)
	(HLLZS 0 NOQUIT)
	(PUSHJ P CHECKI)
	(POPJ P)
TV-ARRAY-HEADER
	(0 0 0 -1)
	(PUSH P CFIX1)
	(JSP TT 1DIMF)
ASAR-ADDRESS
	(0)
	(22000)
NIL 
 
(DECLARE (ARRAY* (FIXNUM (TV 9216.))))

(PUTPROP 'TV (SETUP-TV-ARRAY) 'ARRAY) 

(DECLARE (FIXNUM (READ-TV FIXNUM FIXNUM) (TV-ADDRESS FIXNUM FIXNUM))
         (NOTYPE (WRITE-TV FIXNUM FIXNUM FIXNUM)))

(DEFUN READ-TV (TV-Y TV-X) (TV (+ (* TV-Y 18.) TV-X)))

(DEFUN WRITE-TV (TV-Y TV-X NEW-CONTENTS) 
       (STORE (TV (+ (* TV-Y 18.) TV-X)) NEW-CONTENTS)
       T)

(DEFUN TV-ADDRESS (TV-Y TV-X) (+ (* TV-Y 18.) TV-X))
       

;;THE FOLLOWING LAP ROUTINE PERFORMS THE SYSTEM CALL TO MAP THE 11'S MEMORY INTO THE
;;ADDRESS SPACE OF THE TEN.  THE ADDRESS FOR THE START OF THE TV MEMORY IS THAT OF
;;THE DATA FOR THE TV ARRAY.

[BW 

(DECLARE (*EXPR TVINIT)) 


(LAP TVINIT SUBR)
(ARGS TVINIT (NIL . 0))
(DEFSYM IMMEDIATE 1000)
(DEFSYM READ-WRITE-ACCESS 600000)
	(HLLOS 0 NOQUIT)
	(PUSH FXP TT)
	(PUSH FXP D)
	(HRRZ TT (ARRAY TV))
	(LSH TT -12)
	(HRLI TT -11)
	(SETZ D)
	(*CALL 0 MAP-11-MEMORY-TO-10-ADDRESS-SPACE)
	(*VALUE)
	(MOVEI A 'TV-INITIALIZED)
	(POP FXP D)
	(POP FXP TT)
	(HLLZS 0 NOQUIT)
	(PUSHJ P CHECKI)
	(POPJ P)
MAP-11-MEMORY-TO-10-ADDRESS-SPACE
	(SETZ)
	(SIXBIT CORBLK)
	(0 0 READ-WRITE-ACCESS IMMEDIATE)
	(0 0 -1 IMMEDIATE)
	(TT)
	(0 0 -2 IMMEDIATE)
	(SETZ 0 D)
NIL 
 
;;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.

]


;;THE TV ARRAY IS REALLY YOUR TV BUFFER! DOING (STORE (TV <WORD>) <BITS>)
;;ACTUALLY CAUSES THE BITS TO APPEAR ON YOUR SCREEN.  THINGS TO REMEMBER: KEEP THE
;;LAST 4 LOW ORDER BITS CLEAR, AND COORDINATES RUN TOP TO BOTTOM, LEFT TO RIGHT.


;;*PAGE

(COMMENT SPLIT SCREENERY)

;;THE FOLLOWING LAP ROUTINE CAUSES ALL LISP TTY I/O TO TAKE PLACE IN AN AREA AT THE
;;BOTTOM OF THE SCREEN.  THIS PERMITS DISPLAY HACKS TO OCCUR IN THE UPPER HALF.  IT
;;TAKES ONE ARGUMENT, THE NUMBER OF LINES TO CONSTITUTE THE DISPLAY AREA.  AN
;;ARGUMENT OF ZERO OR NIL RESTORES THE FULL SCREEN FOR OUTPUT.  THE GLOBAL VARIABLE
;;:ECHOLINES KEEPS THE LAST ARG TO ECHO-LINES, NUMBER OF LINES IN ECHO AREA, OR NIL
;;IF NONE EXISTS.

[BW (DECLARE (*EXPR CREATE-ECHO-AREA OUTPUT-TO-MAIN-SCREEN OUTPUT-TO-ECHO-AREA)
	 (SPECIAL :ECHOLINES)
	 (FIXNUM ECHO-LINES :ECHOLINES BOTTOM-LINES)
	 (*LEXPR SYSCALL)) 

(DEFUN CREATE-ECHO-AREA (ECHO-LINES) 
       (SYSCALL 0. 'SCML 1. (SETQ :ECHOLINES ECHO-LINES))
       ;;0=NO VALUES RETURNED, SCML="SET COMMAND LINES" SYSTEM CALL, 1=TTY INPUT
       ;;CHANNEL
       :ECHOLINES) 


(LAP OUTPUT-TO-ECHO-AREA SUBR)
(ARGS OUTPUT-TO-ECHO-AREA (NIL . 0))
(DEFSYM TYOC 2)
(DEFSYM IMMEDIATE 1000)
	(HLLOS 0 NOQUIT)
	(*OPEN TYOC REOPEN-OUTPUT)
	(*VALUE)
	(MOVEI A 'OUTPUT-NOW-IN-ECHO-AREA)
	(HLLZS 0 NOQUIT)
	(PUSHJ P CHECKI)
	(POPJ P)
REOPEN-OUTPUT
	(0 0 (SIXBIT / / / TTY) 31)
	(SIXBIT /.LISP/.)
	(SIXBIT OUTPUT)
NIL 
 


(LAP OUTPUT-TO-MAIN-SCREEN SUBR)
(ARGS OUTPUT-TO-MAIN-SCREEN (NIL . 0))
(DEFSYM TYOC 2)
(DEFSYM IMMEDIATE 1000)
	(HLLOS 0 NOQUIT)
	(*OPEN TYOC REOPEN-OUTPUT)
	(*VALUE)
	(MOVEI A 'OUTPUT-NOW-IN-MAIN-SCREEN)
	(HLLZS 0 NOQUIT)
	(PUSHJ P CHECKI)
	(POPJ P)
REOPEN-OUTPUT
	(0 0 (SIXBIT / / / TTY) 21)
	(SIXBIT /.LISP/.)
	(SIXBIT OUTPUT)
NIL 
 

(DEFINE ECHOLINES (BOTTOM-LINES) (CREATE-ECHO-AREA BOTTOM-LINES)
				 (OUTPUT-TO-ECHO-AREA)
				 (CURSORPOS 'C)
				 NO-VALUE) 

;;THE STANDARD LISP CURSORPOS FUNCTION WON'T DO FOR SPLIT-SCREEN HACKERY.  THE
;;SYSTEM MAINTAINS TWO CURSORS, AND LISP IGNORES THE ECHO OUTPUT CURSOR.  SINCE LISP
;;CURSORPOS GETS INCREDIBLY CONFUSED, THE LISP RUBOUT HANDLER IS SOMETIMES LESS THAN
;;OPTIMAL, AND PAGEPAUSE MODE LOSES, SO TURN IT OFF UPON ENTRY. 

(SSTATUS PAGEPAUSE NIL) 

(DECLARE (*EXPR ECHO-CURSORPOS) (FIXNUM RCPOS)) 

;;; (DEFUN ECHO-CURSORPOS NIL 
;;;        (LET ((RCPOS (CADR (SYSCALL 2. 'RCPOS 0. 1.))))
;;;		(CONS (LSH RCPOS -18.) (BITWISE-AND RCPOS 262143.))))
;;;


(LAP ECHO-CURSORPOS SUBR)
(ARGS ECHO-CURSORPOS (NIL . 0))
(DEFSYM TYIC 1)
(DEFSYM IMMEDIATE 1000)
(DEFSYM RESULT 2000)
	(*CALL 0 READ-CURSOR-POSITION)
	(*VALUE)
	(HLLOS 0 NOQUIT)
	(PUSH FXP TT)
	(PUSH FXP D)
	(PUSH FXP F)
	(HRRZ TT F)
	(JSP T FXCONS)
	(MOVE B A)
	(HLRZ TT F)
	(JSP T FXCONS)
	(CALL 2 (FUNCTION CONS))
	(POP FXP F)
	(POP FXP D)
	(POP FXP TT)
	(HLLZS 0 NOQUIT)
	(PUSHJ P CHECKI)
	(POPJ P)
READ-CURSOR-POSITION
	(SETZ)
	(SIXBIT RCPOS/ )
	(0 0 1 IMMEDIATE)
	(0 0 D RESULT)
	(SETZ 0 F RESULT)
NIL 
 

;;*PAGE

;;;

(COMMENT DRAWMODE) 

;;;
;;THE 11 HAS A FEATURE WHEREBY ONE OF THE SIXTEEN BOOLEAN FUNCTIONS OF TWO ARGUMENTS
;;MAY BE SPECIFIED, AND ANY ATTEMPT TO WRITE INTO THE 11'S MEMORY WILL ACTUALLY
;;RESULT IN THE FUNCTION SPECIFIED OF THE WORD BEING DEPOSITED AND THE WORD ALREADY
;;THERE IN THE LOCATION.  THIS IS DONE BY PUTTING A NUMBER TO INDICATE THE DESIRED
;;FUNCTION IN THE "ALU REGISTER"; THE FIRST WORD AFTER THE 8 PAGES OF TV MEMORY. 
;;THE NUMBER IS IN THE HIGH ORDER 8 BITS OF THE WORD.

(DECLARE (SPECIAL :DRAWMODE ANDC SETZ COMP EQV SAME XOR AND SETO IOR SET)
	 (FIXNUM (DRAWMODE FIXNUM) (FLIPCOLORS FIXNUM))
	 (FIXNUM :DRAWMODE OLD-DRAWMODE ANDC SETZ COMP EQV SAME XOR AND SETO IOR
		 SET)) 

(DEFINE DRAWMODE (MODE) 
	(COND ((= :DRAWMODE MODE) MODE)
	      ((PROG1 :DRAWMODE
		      (SETQ :DRAWMODE MODE)
		      (STORE (TV 8192.)
			     (BITWISE-OR :DRAWMODE
					 (BOOLE 2. -268435456. (TV 8192.)))))))) 

;;DRAWMODE RETURNS PREVIOUS STATE FOR EASY LAMBDA-BINDING.

(SETQ ANDC 536870912. 
      SETZ 805306368. 
      COMP 1342177280. 
      XOR 1610612736. 
      EQV 2415919104. 
      SAME 2684354560. 
      AND 2952790016. 
      SETO 3221225472. 
      IOR 3758096384. 
      SET 4026531840. 
      :DRAWMODE IOR) 

(DEFUN U (X) 
       (STORE (TV 8192.)
	      (BITWISE-OR (LSH X 20.) (BOOLE 2. 32505856. (TV 8192.))))) 

;;A BIT IN THE LAST WORD OF THE TV MEMORY CONTROLS WHETHER THE SCREEN IS IN
;;DARK-ON-LIGHT MODE OR LIGHT-ON-DARK MODE.  CONTROLLABLE FROM KEYBOARD BY TYPING
;;<ESC> C, THESE FUNCTIONS ALLOW IT TO BE PROGRAM CONTROLLED.

(DEFUN FLIPCOLORS (MODE) 
       (LET ((OLD-DRAWMODE (DRAWMODE MODE)))
	    (STORE (TV 8191.) 65536.)
	    (DRAWMODE OLD-DRAWMODE))) 

(DEFINE COLORNEGATIVE (ABB CLN) NIL (FLIPCOLORS ANDC) NO-VALUE) 

(DEFINE COLORPOSITIVE (ABB CLP) NIL (FLIPCOLORS IOR) NO-VALUE) 

(DEFINE COLORSWITCH (ABB CLSW) NIL (FLIPCOLORS XOR) NO-VALUE) 

(DEFINE COLORSTATE (ABB CLST) NIL (NOT (ZEROP (BITWISE-AND (TV 8191.) 65536.))))

;;END OF BLACK AND WHITE CONDITIONAL SECTION.
]

;;*PAGE


[COLOR


(LAP TV-PAGE SUBR)
	(PUSH FXP TT)
	(HRRZ TT (ARRAY TV))
	(LSH TT -12)
	(JSP T FXCONS)
	(POP FXP TT)
	(POPJ P)
NIL 
 

;;*PAGE


(COMMENT COLOR GLOBAL INITIALIZATIONS) 

;;READ THE FOLLOWING SECTION IN OCTAL.

(DECLARE (EVAL (READ))) 

(SETQ OIBASE IBASE IBASE 8.) 

;;* (SETQ OIBASE IBASE IBASE 8. OBASE BASE BASE 8.) 
;;ABOVE LINE FOR GRIND PACKAGE...
;;;Constants for video control registers. [see BEE;CLRTST >].

(DECLARE (SPECIAL COLORD-ADDRESS VIDSW-ADDRESS COLORA-ADDRESS TVINCR-ADDRESS
		  TVINC-MASK TVRSET-MASK TVCLRW-MASK TVSEL-ADDRESS TVRCNS-MASK
		  TVRWMD-MASK TVNSH TVINOR TVXOR TVMOV :DRAWMODE IOR XOR SET MOV
		  TVRADR-ADDRESS TVWC-ADDRESS TVSHR-ADDRESS TVSHCN-ADDRESS
		  TVSHCN-MASK WORDS-PER-LINE BYTES-PER-LINE COLORA-RED-MASK TVMAP
		  TVAMAP TVMSK-ADDRESS TVRWIN-ADDRESS TVCNSL-ADDRESS TVCLR-MASK
		  ROTATE-MAGIC-CONSTANT COLORA-GREEN-MASK COLORA-BLUE-MASK
		  VIDEO-SWITCH-MAGIC-1 VIDEO-SWITCH-MAGIC-2 VIDEO-SWITCH-MAGIC-3
		  VIDEO-SWITCH-MAGIC-4 CONSOLE-MAGIC-1 CONSOLE-MAGIC-2
		  CONSOLE-MAGIC-3 CONSOLE-MAGIC-4 ELEVEN-TV-BUFFER-ORIGIN
		  TVOFLO-MASK ELEVEN-CONTROL-REGISTER-ORIGIN CONTROL-Y
		  RIGHT-HALFWORD TVWC-MASK :COLORWRITE)
	 (FIXNUM COLORD-ADDRESS VIDSW-ADDRESS COLORA-ADDRESS TVINCR-ADDRESS
		 TVINC-MASK TVRSET-MASK TVCLRW-MASK TVSEL-ADDRESS TVRCNS-MASK
		 TVRWMD-MASK TVNSH TVINOR TVXOR TVMOV :DRAWMODE IOR XOR SET MOV
		 TVRADR-ADDRESS TVWC-ADDRESS TVSHR-ADDRESS TVSHCN-ADDRESS
		 TVSHCN-MASK WORDS-PER-LINE BYTES-PER-LINE COLORA-RED-MASK TVMAP
		 TVAMAP TVMSK-ADDRESS TVRWIN-ADDRESS TVCNSL-ADDRESS TVCLR-MASK
		 ROTATE-MAGIC-CONSTANT COLORA-GREEN-MASK COLORA-BLUE-MASK
		 VIDEO-SWITCH-MAGIC-1 VIDEO-SWITCH-MAGIC-2 VIDEO-SWITCH-MAGIC-3
		 VIDEO-SWITCH-MAGIC-4 CONSOLE-MAGIC-1 CONSOLE-MAGIC-2
		 CONSOLE-MAGIC-3 CONSOLE-MAGIC-4 ELEVEN-TV-BUFFER-ORIGIN
		 TVOFLO-MASK ELEVEN-CONTROL-REGISTER-ORIGIN CONTROL-Y
		 RIGHT-HALFWORD TVWC-MASK)) 

(DEFUN INITIALIZE-COLOR-TURTLE NIL 
       (SETQ 
	     ;;Color data.
	     COLORD-ADDRESS 764102 
	     ;;Video switch.
	     VIDSW-ADDRESS 764104 
	     ;;Color address.
	     COLORA-ADDRESS 764106 
	     ;;The increment register for the tv's.
	     TVINCR-ADDRESS 764140 
	     ;;The mask for the increment. 
	     TVINC-MASK 77 
	     ;;Mask to handle overflow correctly in increment register.
	     TVOFLO-MASK 1000 
	     ;;The reset bit mask. 
	     TVRSET-MASK 100000 
	     ;;The color write bit mask.
	     TVCLRW-MASK 400 
	     ;;The console select register. 
	     TVSEL-ADDRESS 764142 
	     ;;The console number mask. 
	     TVRCNS-MASK 77 
	     ;;The regular write mode mask.
	     TVRWMD-MASK 300 
	     ;;No shift write mode. 
	     TVNSH 0 
	     ;;The inclusive or mode. 
	     TVINOR 100 
	     IOR 100 
	     ;;The xor mode. 
	     TVXOR 200 
	     XOR 200 
	     ;;The move function. 
	     TVMOV 300 
	     SET 300 
	     ;;The regular address register. 
	     :DRAWMODE SET 
	     TVRADR-ADDRESS 764144 
	     ;;The word count for the block write. 
	     TVWC-ADDRESS 764146 
	     ;;Mask for word count.
	     TVWC-MASK 777 
	     ;;The shift register.
	     TVSHR-ADDRESS 764152 
	     ;;The shift count mask. 
	     TVSHCN-MASK 17 
	     ;;The start of the 16k page (in 4k blocks). 
	     TVMAP 17400 
	     ;;The activate tvmap bit.
	     TVAMAP 20000 
	     ;;The mask register. 
	     TVMSK-ADDRESS 764154 
	     ;;The window for regular transfers. 
	     TVRWIN-ADDRESS 764160 
	     ;;The console register for the memory. 
	     TVCNSL-ADDRESS 764162 
	     ;;The color number mask.
	     TVCLR-MASK 160000 
	     RIGHT-HALFWORD 777777)
       (SETQ WORDS-PER-LINE 44 BYTES-PER-LINE 110)
       ;;More magic constants.....
       (SETQ ROTATE-MAGIC-CONSTANT 35400 
	     ;;In rotate register TVSHR indicates no rotation.
	     COLORA-RED-MASK 300 
	     COLORA-GREEN-MASK 500 
	     ;;IOR these with color map address into COLORA register to set red,
	     ;;green, blue intensities respectively.  Low order 6 bits are color
	     ;;address, next 3 are red, green, blue, where 0 indicates write.
	     COLORA-BLUE-MASK 600 
	     VIDEO-SWITCH-MAGIC-1 (+ (LSH 30 10) 0) 
	     ;;Magic constants for video switch and console register
	     ;;initializations.
	     VIDEO-SWITCH-MAGIC-2 (+ (LSH 31 10) 1) 
	     VIDEO-SWITCH-MAGIC-3 (+ (LSH 32 10) 2) 
	     VIDEO-SWITCH-MAGIC-4 (+ (LSH 33 10) 3) 
	     CONSOLE-MAGIC-1 (LSH 1 15) 
	     CONSOLE-MAGIC-2 (LSH 2 15) 
	     CONSOLE-MAGIC-3 (LSH 3 15) 
	     CONSOLE-MAGIC-4 (LSH 4 15) 
	     ;;Start of TV buffer in 11's memory in byte address.
	     ELEVEN-TV-BUFFER-ORIGIN 660000 
	     ;;Start of control registers in 11's memory in byte address.
	     ELEVEN-CONTROL-REGISTER-ORIGIN 760000)) 

;;*PAGE


(COMMENT LOW LEVEL COLOR PRIMITIVES) 

(DECLARE (FIXNUM (READ-CONTROL-REGISTER FIXNUM) CONTROL-ADDRESS BYTE-OFFSET
		 ELEVEN-WORD-OFFSET TEN-WORD-OFFSET TV-WORD)) 

(DEFUN READ-CONTROL-REGISTER (CONTROL-ADDRESS) 
       (LET ((BYTE-OFFSET (- CONTROL-ADDRESS ELEVEN-TV-BUFFER-ORIGIN)))
	    ;;Distance from TV buffer origin to target address in bytes.
	    (LET ((ELEVEN-WORD-OFFSET (LSH BYTE-OFFSET -1))
		  ;;and in 16 and 32 bit words.
		  (TEN-WORD-OFFSET (LSH BYTE-OFFSET -2)))
		 (LET ((TV-WORD (TV TEN-WORD-OFFSET)))
		      ;;16 bit word comes back embedded in 36 bit word.
		      (COND ((ODDP ELEVEN-WORD-OFFSET)
			     (BITWISE-AND RIGHT-HALFWORD (LSH TV-WORD -4)))
			    ;;Extract out the interesting piece.
			    ((LSH TV-WORD -24))))))) 

(DECLARE (NOTYPE (WRITE-CONTROL-REGISTER FIXNUM FIXNUM))
	 (FIXNUM INHIBIT WORD-SHIFT NEW-CONTENTS)) 

(DEFUN WRITE-CONTROL-REGISTER (CONTROL-ADDRESS NEW-CONTENTS) 
       (LET ((BYTE-OFFSET (- CONTROL-ADDRESS ELEVEN-TV-BUFFER-ORIGIN)))
	    ;;Distance from TV buffer origin to target address in bytes.
	    (LET ((ELEVEN-WORD-OFFSET (LSH BYTE-OFFSET -1))
		  ;;and in 16 and 32 bit words.
		  (TEN-WORD-OFFSET (LSH BYTE-OFFSET -2)))
		 (LET ((INHIBIT (COND ((ODDP ELEVEN-WORD-OFFSET) 10) (4)))
		       ;;Shift the 16 bit word to place in 36 bit word, inhibit
		       ;;writing of irrelevant word.
		       (WORD-SHIFT (COND ((ODDP ELEVEN-WORD-OFFSET) 4) (24))))
		      (STORE (TV TEN-WORD-OFFSET)
			     (BITWISE-OR (LSH NEW-CONTENTS WORD-SHIFT) INHIBIT)))))
       T) 

(DECLARE (NOTYPE WRITE-CONTROL-FIELD FIXNUM FIXNUM FIXNUM)) 

(DEFUN WRITE-CONTROL-FIELD (CONTROL-ADDRESS CONTROL-DATA CONTROL-MASK) 
       ;;Like WRITE-CONTROL-REGISTER, but only writes the field specified by the
       ;;mask, leaving the rest of the word undisturbed.
       (WRITE-CONTROL-REGISTER
	CONTROL-ADDRESS
	(BITWISE-OR (BITWISE-AND CONTROL-MASK CONTROL-DATA)
		    (BITWISE-ANDC CONTROL-MASK
				  (READ-CONTROL-REGISTER CONTROL-ADDRESS))))) 

(DEFUN CORBLK NIL 
       (SYSCALL 0 'CORBLK 0 -1 (BITWISE-OR (LSH -11 22) (TV-PAGE)))) 

(DECLARE (FIXNUM PAGE-NUMBER TV-PAGE MAGIC-CONSTANT)) 

(DEFUN MAP-TV-BUFFER NIL 
       ;;Map the 11's memory into ten's address space.  8 pages of buffer + 1 page
       ;;of control registers = 9 pages. 
       (CORBLK)
       (DO ((PAGE-NUMBER 0 (1+ PAGE-NUMBER))
	    (TV-PAGE (TV-PAGE))
	    ;;Magic constant 2nd arg to T11MP -- see ITS .CALLS....
	    (MAGIC-CONSTANT (+ (LSH 602330 22) 1777)))
	   ((= PAGE-NUMBER 11))
	   (SYSCALL 0
		    'T11MP
		    (+ TV-PAGE PAGE-NUMBER)
		    (+ MAGIC-CONSTANT (LSH (* PAGE-NUMBER 4) 22))))) 

(DECLARE (EVAL (READ))) 

(SETQ IBASE OIBASE) 

;;* (SETQ IBASE OIBASE BASE OBASE)
;;END OF OCTAL SECTION.

(DECLARE (FIXNUM (DRAWMODE FIXNUM))) 

(DEFUN TVINIT NIL 
       (INITIALIZE-COLOR-TURTLE)
       ;;Map 11's tv buffer memory and control registers into 10's address space.
       (MAP-TV-BUFFER)
       ;;Reset bit in increment register starts things out.
       (WRITE-CONTROL-REGISTER TVINCR-ADDRESS TVRSET-MASK)
       (RESET)
       (INITIALIZE-PALETTE)) 

(DEFINE RESET NIL (INITIALIZE-VIDEO-SWITCH)
		  (INITIALIZE-CONSOLE-REGISTER)
		  ;;Increment register magic bit to handle overflow correctly.
		  ;;Normally assume always no rotation.
		  (WRITE-CONTROL-REGISTER TVSHR-ADDRESS ROTATE-MAGIC-CONSTANT)
		  (WRITE-CONTROL-FIELD TVINCR-ADDRESS -1. TVOFLO-MASK)
		  ;;Choose SET draw mode.
		  (WRITE-CONTROL-FIELD TVSEL-ADDRESS SET TVRWMD-MASK)
		  (COLOR-WRITE)) 

;;CONTROL-BACKSLASH INTERRUPT CHARACTER PERFORMS RESET.  USEFUL TO RECOVER FROM
;;RESET OF 11, SYMPTOM IS SCREEN BLANKING IN ONE COLOR FOR NO APPARENT REASON.

(SSTATUS INTERRUPT 14. '(LAMBDA (USELESS) (RESET) '?)) 

(DEFUN COLOR-WRITE NIL 
       ;;Set color write mode.
       (SETQ :COLORWRITE T)
       (WRITE-CONTROL-FIELD TVINCR-ADDRESS -1. TVCLRW-MASK)
       (RESELECT-COLOR)) 

(DEFUN NO-COLOR-WRITE NIL 
       (SETQ :COLORWRITE NIL)
       (WRITE-CONTROL-FIELD TVINCR-ADDRESS 0. TVCLRW-MASK)) 

(DECLARE (SPECIAL :ERASERSTATE :PENNUMBER :ERASERNUMBER :ECHOLINES)
	 (FIXNUM :PENNUMBER :ERASERNUMBER :ECHOLINES)) 

(DEFUN RESELECT-COLOR NIL 
       (SELECT-COLOR (COND (:ERASERSTATE :ERASERNUMBER) (:PENNUMBER))))

(DEFUN INITIALIZE-VIDEO-SWITCH NIL 
       ;;Video switch initialization [see BEE;CLRTST >].
       (WRITE-CONTROL-REGISTER VIDSW-ADDRESS VIDEO-SWITCH-MAGIC-1)
       (WRITE-CONTROL-REGISTER VIDSW-ADDRESS VIDEO-SWITCH-MAGIC-2)
       (WRITE-CONTROL-REGISTER VIDSW-ADDRESS VIDEO-SWITCH-MAGIC-3)
       (WRITE-CONTROL-REGISTER VIDSW-ADDRESS VIDEO-SWITCH-MAGIC-4)) 

(DEFUN INITIALIZE-CONSOLE-REGISTER NIL 
       ;;Console register initialization [see BEE;CLRTST >].
       (WRITE-CONTROL-REGISTER TVSEL-ADDRESS 0.)
       (WRITE-CONTROL-REGISTER TVCNSL-ADDRESS CONSOLE-MAGIC-1)
       (WRITE-CONTROL-REGISTER TVSEL-ADDRESS 1.)
       (WRITE-CONTROL-REGISTER TVCNSL-ADDRESS CONSOLE-MAGIC-2)
       (WRITE-CONTROL-REGISTER TVSEL-ADDRESS 2.)
       (WRITE-CONTROL-REGISTER TVCNSL-ADDRESS CONSOLE-MAGIC-3)
       (WRITE-CONTROL-REGISTER TVSEL-ADDRESS 3.)
       (WRITE-CONTROL-REGISTER TVCNSL-ADDRESS CONSOLE-MAGIC-4)) 

(DECLARE (NOTYPE (WRITE-TV-ADDRESS FIXNUM FIXNUM))) 

(DEFUN WRITE-TV-ADDRESS (TV-ADDRESS-CONTENTS) 
       ;;Store into TV address register "TVRADR".  Sets up the address to be written
       ;;when something is stored in data register or word count register.  ADDRESS
       ;;IS IN PDP11 BYTES, NOT WORDS!
       (WRITE-CONTROL-REGISTER TVRADR-ADDRESS TV-ADDRESS-CONTENTS)
       T) 

(DECLARE (NOTYPE (WRITE-TV-DATA FIXNUM))) 

(DEFUN WRITE-TV-DATA (TV-DATA) 
       ;;Store in TV buffer memory data register "TVRWIN".  Writing of TV memory
       ;;actually occurs when this register is written.
       (WRITE-CONTROL-REGISTER TVRWIN-ADDRESS TV-DATA)
       T) 

(DECLARE (FIXNUM READ-TV-DATA)) 

(DEFUN READ-TV-DATA NIL 
       ;;Reads contents of TV buffer memory at location specified by TV address
       ;;register.
       (READ-CONTROL-REGISTER TVRWIN-ADDRESS)) 

(DECLARE (NOTYPE (WRITE-TV-WORD FIXNUM FIXNUM))) 

(DEFUN WRITE-TV-WORD (TV-ADDRESS TV-DATA) 
       ;;Writes the data at the specified address.
       (WRITE-TV-ADDRESS TV-ADDRESS)
       (WRITE-TV-DATA TV-DATA)) 

;;Rotate & mask registers provide a means of writing into arbitrary part of word.
;;Word in memory data register is rotated, and only bits not on in the mask register
;;are actually written into the word.

(DECLARE (NOTYPE (WRITE-TV-ROTATE FIXNUM))) 

(DEFUN WRITE-TV-ROTATE (ROTATE-PLACES) 
       (WRITE-CONTROL-FIELD TVSHR-ADDRESS ROTATE-PLACES TVSHCN-MASK)
       T) 

;;The convention observed by routines which write into the TV memory will be to
;;assume the rotate register zero, restore it if changed, but set up contents of
;;mask, address, and data registers before each write.

(DECLARE (NOTYPE (WRITE-TV-MASK FIXNUM))) 

(DEFUN WRITE-TV-MASK (TV-MASK) (WRITE-CONTROL-REGISTER TVMSK-ADDRESS TV-MASK) T) 

;;Write of multiple words at once.

(DECLARE (NOTYPE (WRITE-TV-WORD-COUNT FIXNUM))) 

(DEFUN WRITE-TV-WORD-COUNT (WORD-COUNT) 
       ;;When this register is written, data transfers repeatedly occur, number of
       ;;times specified by minus word count.
       (WRITE-CONTROL-REGISTER TVWC-ADDRESS WORD-COUNT)
       T) 

(DECLARE (FIXNUM (READ-TV-WORD-COUNT))) 

(DEFUN READ-TV-WORD-COUNT NIL 
       ;;Needed for checking when block word transfer is done.
       (BITWISE-AND (READ-CONTROL-REGISTER TVWC-ADDRESS) TVWC-MASK)) 

(DECLARE (NOTYPE (WRITE-TV-INCREMENT FIXNUM))) 

(DEFUN WRITE-TV-INCREMENT (INCREMENT) 
       ;;Contents added to TV address register after each write performed.  In
       ;;conjunction with word count, performs automatically loops of writing into
       ;;TV memory.
       (WRITE-CONTROL-FIELD TVINCR-ADDRESS INCREMENT TVINC-MASK)
       T) 

(DECLARE (NOTYPE (WRITE-TV-BLOCK FIXNUM FIXNUM FIXNUM FIXNUM))) 

(DEFUN WRITE-TV-BLOCK (ADDRESS CONTENTS ITERATIONS STEP) 
       ;;Writes a whole block of words in one swell foop.
       (COND ((ZEROP ITERATIONS))
	     (T (WRITE-CONTROL-FIELD TVINCR-ADDRESS STEP TVINC-MASK)
		(WRITE-TV-WORD ADDRESS CONTENTS)
		;;One word written when contents written.
		(COND ((ZEROP (DECREMENT ITERATIONS)))
		      ;;Decrease iterations by 1, if finished stop, else write rest
		      ;;in block.
		      ((WRITE-TV-WORD-COUNT (- ITERATIONS))
		       ;;Wait must be programmed in to check if block write is done. 
		       ;;Word count register goes to zero then.
		       (DO NIL ((ZEROP (READ-TV-WORD-COUNT))))))
		(WRITE-CONTROL-FIELD TVINCR-ADDRESS 0. TVINC-MASK)))) 

;;;;;;;;;;;;;;;;;;;;;;
;;;Temporarily leave this out, always be in set mode.
;;;(DEFUN DRAWMODE (MODE) 
;;;       ;;Specifies how word is actually to be written as function of word 
;;;       ;;in memory data & word previously there. Choose from:
;;;       ;;;	SET, IOR, XOR, SET-IGNORE-ROTATE-MASK
;;;       ;;Unfortunately, can't use IOR & XOR as for ordinary TVRTLE when in color
;;mode
;; ;;Have to use SET mode.
;;;       (COND ((= :DRAWMODE MODE) MODE)
;;;             ((PROG1 :DRAWMODE
;;;                     (SETQ :DRAWMODE MODE)
;;;                     (WRITE-CONTROL-FIELD TVSEL-ADDRESS MODE TVRWMD-MASK)))))
;;;
;;;;;;;;;;;;;;;;;;;;;;;;

(DEFUN DRAWMODE (MODE) 0.) 

(DECLARE (NOTYPE (WRITE-COLOR-MAP FIXNUM FIXNUM FIXNUM FIXNUM))) 

(DEFUN WRITE-COLOR-MAP (COLOR-MAP-SLOT RED GREEN BLUE) 
       ;;Defines the color in a map slot by specifying intesities for red, green and
       ;;blue components.
       (WRITE-CONTROL-REGISTER COLORD-ADDRESS RED)
       ;;Write data before address, actual write commences upon writing of address,
       ;;not data register, in opposite order from buffer transactions.
       (WRITE-CONTROL-REGISTER COLORA-ADDRESS
			       (BITWISE-OR COLORA-RED-MASK COLOR-MAP-SLOT))
       (WRITE-CONTROL-REGISTER COLORD-ADDRESS GREEN)
       (WRITE-CONTROL-REGISTER COLORA-ADDRESS
			       (BITWISE-OR COLORA-GREEN-MASK COLOR-MAP-SLOT))
       (WRITE-CONTROL-REGISTER COLORD-ADDRESS BLUE)
       (WRITE-CONTROL-REGISTER COLORA-ADDRESS
			       (BITWISE-OR COLORA-BLUE-MASK COLOR-MAP-SLOT))
       T) 

(DECLARE (NOTYPE (SELECT-COLOR FIXNUM))) 

(DEFUN SELECT-COLOR (COLOR-NUMBER) 
       ;;Makes COLOR-NUMBER of the color map the current color.
       (WRITE-CONTROL-FIELD TVSEL-ADDRESS COLOR-NUMBER TVRCNS-MASK)
       T) 

(DECLARE (NOTYPE (SELECT-TV-BUFFER FIXNUM))) 

(DEFUN SELECT-TV-BUFFER (TV-BUFFER) 
       ;;BOTH READS & WRITES APPLY TO JUST THE SELECTED TV BUFFER. [ONE BIT OUT OF
       ;;THE FOUR].  COLOR WRITE MODE MUST BE TURNED OFF, SO IT MUST EVENTUALLY BE
       ;;RESTORED TO COLOR WRITE MODE IF THIS IS USED.
       (WRITE-CONTROL-FIELD TVSEL-ADDRESS TV-BUFFER TVRCNS-MASK)
       T) 

(DECLARE (FIXNUM (ELEVEN-TV-ADDRESS FIXNUM FIXNUM) WORDS-PER-LINE BYTES-PER-LINE)
	 (SPECIAL WORDS-PER-LINE BYTES-PER-LINE)) 

(DEFUN ELEVEN-TV-ADDRESS (ADDRESS-Y ADDRESS-X) 
       ;;CONVERTS TV Y ADDRESS [VERTICAL] AND 16 BIT WORD NUMBER [HORIZONTAL] TO
       ;;PDP11 BYTE ADDRESS.
       (+ (* ADDRESS-Y BYTES-PER-LINE) (LSH ADDRESS-X 1.))) 

;;*PAGE

;;;DUMMY DEFINITIONS FOR SPLIT SCREEN HACKERY.

(DECLARE (FIXNUM (CREATE-ECHO-AREA FIXNUM)) (NOTYPE (ECHOLINES FIXNUM))) 

(DEFUN CREATE-ECHO-AREA (ECHO-LINES) 0.) 

(DEFUN OUTPUT-TO-ECHO-AREA NIL T) 

(DEFUN OUTPUT-TO-MAIN-SCREEN NIL T) 

(DEFINE ECHOLINES (BOTTOM-LINES) NO-VALUE) 

;;THE STANDARD LISP CURSORPOS FUNCTION WON'T DO FOR SPLIT-SCREEN HACKERY.  THE
;;SYSTEM MAINTAINS TWO CURSORS, AND LISP IGNORES THE ECHO OUTPUT CURSOR.  SINCE LISP
;;CURSORPOS GETS INCREDIBLY CONFUSED, THE LISP RUBOUT HANDLER IS SOMETIMES LESS THAN
;;OPTIMAL, AND PAGEPAUSE MODE LOSES, SO TURN IT OFF UPON ENTRY. 

(SSTATUS PAGEPAUSE NIL) 

(DECLARE (*EXPR ECHO-CURSORPOS) (FIXNUM RCPOS)) 

(DEFUN ECHO-CURSORPOS NIL T) 

;;;

(DECLARE (SPECIAL :DRAWMODE ANDC SETZ COMP EQV SAME XOR AND SETO IOR SET)
	 (FIXNUM (DRAWMODE FIXNUM) (FLIPCOLORS FIXNUM))
	 (FIXNUM :DRAWMODE OLD-DRAWMODE ANDC SETZ COMP EQV SAME XOR AND SETO IOR
		 SET)) 

;;END OF COLOR CONDITIONAL SECTION.
]


;;*PAGE

;;;

(COMMENT CREATING AND SELECTING COLORS) 

;;;
;;Color represented as an atom.  Has RED, GREEN & BLUE properties for intensities of
;;respective colors, and PALETTE property which is its number in the color map, if
;;any. PALETTE contains the atoms representing the colors currently in the color
;;map.

(DECLARE (SPECIAL COLOR-BITS COLOR-MAX INTENSITY-MAX :COLORS :PENCOLOR :PENNUMBER
		  :ERASERCOLOR :ERASERNUMBER)
	 (FIXNUM COLOR-BITS COLOR-MAX :PENNUMBER :ERASERNUMBER)
	 (ARRAY* (NOTYPE (PALETTE 16.)))
	 (FLONUM INTENSITY-MAX)) 

(DECLARE (SPECIAL :COLORTICK :NCOLORS :NSLOTS)
	 (FIXNUM RANDOM-COLOR RANDOM-SLOT USELESS :NCOLORS :NSLOTS)
	 (FLONUM :COLORTICK)) 

(DEFUN INITIALIZE-PALETTE NIL 
       (SETQ COLOR-BITS 4. 
	     ;;Number of bits of color per point available.
	     COLOR-MAX (LSH 1. COLOR-BITS) 
	     ;;Number of distinct colors available.
	     INTENSITY-MAX 511.0 
	     ;;Red, green, blue colors described on a scale to this number.
	     :COLORS NIL 
	     ;;Global list of colors.
             :NCOLORS 0.
             ;;Number of colors.
	     :PENCOLOR 'WHITE
	     ;;Current color.
	     :PENNUMBER 15. 
	     ;;Current color for eraser, clearscreen.
	     :ERASERCOLOR 'BLACK 
	     :ERASERNUMBER 15.
             :COLORTICK 0.1)
       (ARRAY PALETTE T COLOR-MAX)
       (MAKECOLOR 'BLACK 0.0 0.0 0.0)
       (ERASERCOLOR 'BLACK)
       (MAKECOLOR 'WHITE 1.0 1.0 1.0)
       (MAKECOLOR 'RED 1.0 0.0 0.0)
       (MAKECOLOR 'GREEN 0.0 1.0 0.0)
       (PENCOLOR 'WHITE)
       (MAKECOLOR 'BLUE 0.0 0.0 1.0)
       (MAKECOLOR 'YELLOW 1.0 1.0 0.0)
       (MAKECOLOR 'MAGENTA 1.0 0.0 1.0)
       (MAKECOLOR 'CYAN 0.0 1.0 1.0)
       (MAKECOLOR 'PURPLE 0.5 0.0 1.0)
       (MAKECOLOR 'ORANGE 1.0 0.5 0.0)
       (MAKECOLOR 'GRAY .5 .5 .5)
       (MAKECOLOR 'DARKGRAY .25 .25 .25)
       (MAKECOLOR 'LIGHTGRAY .75 .75 .75)
       (MAKECOLOR 'GOLD  1.0 .75 0.0)
       (MAKECOLOR 'BROWN 0.3 0.2 0.0)
       (MAKECOLOR 'PINK 1.0 0.5 0.5)) 

(DEFINE MAKECOLOR (ABB MC) (COLOR-NAME RED GREEN BLUE) 
	;;Arguments are atom naming the color, and red, green, and blue intensities,
	;;as fractions between 0.0 and 1.0.
	(PUTPROP COLOR-NAME (ROUND (*$ (FLOAT RED) INTENSITY-MAX)) 'RED)
	(PUTPROP COLOR-NAME (ROUND (*$ (FLOAT GREEN) INTENSITY-MAX)) 'GREEN)
	(PUTPROP COLOR-NAME (ROUND (*$ (FLOAT BLUE) INTENSITY-MAX)) 'BLUE)
	(COND ((MEMQ COLOR-NAME :COLORS))
              (T (PUSH COLOR-NAME :COLORS) (INCREMENT :NCOLORS)))
	COLOR-NAME) 

(DEFINE ERASECOLOR (COLOR-NAME)
        (OR (GET COLOR-NAME 'RED) 
            (ERRBREAK 'ERASECOLOR (LIST COLOR-NAME '"IS NOT A COLOR")))
        (DO I 0 (1+ I) (= I 15.) 
            (AND (EQ (PALETTE I) COLOR-NAME) 
                 (ERRBREAK 'ERASECOLOR '"DON'T ERASE A COLOR ON THE PALETTE")))
        (MAPC '(LAMBDA (PROPERTY) (REMPROP COLOR-NAME PROPERTY)) 
              '(RED BLUE GREEN PALETTE))
        (DECREMENT :NCOLORS)
        (SETQ :COLORS (DELQ COLOR-NAME :COLORS))
        (LIST '/; COLOR-NAME '" ERASED")))



(DEFINE REDPART (COLOR) 
	(LET ((RED-PROP (GET COLOR 'RED)))
	     (COND (RED-PROP (//$ (FLOAT RED-PROP) INTENSITY-MAX))
		   ((ERRBREAK 'REDPART
			      (LIST COLOR
				    '"IS NOT A COLOR")))))) 

(DEFINE GREENPART (COLOR) 
	(LET ((GREEN-PROP (GET COLOR 'GREEN)))
	     (COND (GREEN-PROP (//$ (FLOAT GREEN-PROP) INTENSITY-MAX))
		   ((ERRBREAK 'GREENPART
			      (LIST COLOR
				    '"IS NOT A COLOR")))))) 

(DEFINE BLUEPART (COLOR) 
	(LET ((BLUE-PROP (GET COLOR 'BLUE)))
	     (COND (BLUE-PROP (//$ (FLOAT BLUE-PROP) INTENSITY-MAX))
		   ((ERRBREAK 'BLUEPART
			      (LIST COLOR
				    '"IS NOT A COLOR")))))) 

(DECLARE (FIXNUM COLOR-INDEX)) 

(DEFINE PENCOLOR (ABB PC COLOR) (COLOR-NAME) 
 ;;Selects a default color for the turtle to write in, etc.
 (ERASE-TURTLE)
 (COND
  ((NUMBERP COLOR-NAME)
   ;;Selected by color map number.
   (LET ((PALETTE-NAME (PALETTE COLOR-NAME)))
	(COND ((NULL PALETTE-NAME)
	       (ERRBREAK 'PENCOLOR
			 (LIST COLOR-NAME
			       '"IS NOT A COLOR NUMBER")))
	      ((SETQ :PENNUMBER COLOR-NAME :PENCOLOR PALETTE-NAME)))))
  ((GET COLOR-NAME 'RED)
   (SETQ :PENCOLOR COLOR-NAME)
   (LET ((COLOR-INDEX (INTERN-COLOR COLOR-NAME)))
	;;INTERN-COLOR returns index into color map, placing it there if not
	;;present.
	(COND ((MINUSP COLOR-INDEX)
	       ;;Color not present in color map, and more places to put it.
	       (ERRBREAK 'PENCOLOR
			 '"TOO MANY COLORS"))
	      ((SETQ :PENNUMBER COLOR-INDEX)))))
  ((ERRBREAK 'PENCOLOR
	     (LIST COLOR-NAME '"IS NOT A COLOR"))))
 [COLOR (COND (:ERASERSTATE) ((SELECT-COLOR :PENNUMBER)))]
 (DRAW-TURTLE)
 COLOR-NAME) 

(DECLARE (NOTYPE (MAKEPALETTE FIXNUM)) (FIXNUM LAST-PEN-COLOR)) 

(DEFINE PUSHPROP (ATOM PROPERTY INDICATOR) 
	;;Like PUTPROP, but previous property, if any will be restored if
	;;REMPROP'ed.
	(SETPLIST ATOM (CONS INDICATOR (CONS PROPERTY (PLIST ATOM))))) 

(DEFINE MAKEPALETTE (COLOR-INDEX COLOR-NAME) 
        (COND ((= COLOR-INDEX :PENNUMBER) (SETQ :PENCOLOR COLOR-NAME))
              ;;If the color to be changed is that of the pen or eraser,
              ;;update the global variables appropriately.
              ((= COLOR-INDEX :ERASERNUMBER) (SETQ :ERASERCOLOR COLOR-NAME)))
	(REMPROP (PALETTE COLOR-INDEX) 'PALETTE)
	;;Remove previous color number property, write into color map & palette.
	[COLOR (WRITE-COLOR-MAP COLOR-INDEX
    			        (GET COLOR-NAME 'RED)
			        (GET COLOR-NAME 'GREEN)
			        (GET COLOR-NAME 'BLUE))]
	(PUSHPROP COLOR-NAME COLOR-INDEX 'PALETTE)
	(STORE (PALETTE COLOR-INDEX) COLOR-NAME)) 

(DEFUN INTERN-COLOR (COLOR-NAME) 
       ;;Finds first position in palette with specified color. If not in the color
       ;;map, it is inserted, and the index returned. Returns -1 if color map is
       ;;full.
       (COND ((EQ COLOR-NAME :ERASERCOLOR) (1- COLOR-MAX))
	     ;;ERASERCOLOR is always the last color.
	     ((DO ((COLOR-INDEX 0. (1+ COLOR-INDEX)) (LAST-PEN-COLOR (1- COLOR-MAX)))
		  ;;Already checked eraser color, stop at last pen color.
		  ((= COLOR-INDEX LAST-PEN-COLOR) -1.)
		  (COND 
			;;Exhausted palette, couldn't insert it.
			((EQ (PALETTE COLOR-INDEX) COLOR-NAME) (RETURN COLOR-INDEX))
			;;It was already there, return index.
			((NULL (PALETTE COLOR-INDEX))
			 ;;Found a free place.
			 (MAKEPALETTE COLOR-INDEX COLOR-NAME)
			 (RETURN COLOR-INDEX))))))) 

;;There are two global default colors which the system keeps track of.  One is the
;;default color for drawing with the turtle, kept as the value of :PENCOLOR. The
;;other is a "background" color, :ERASERCOLOR.  CLEARSCREEN results in filling the
;;screen in the current background color.  The TV system also fills edges of the
;;picture with the background color.  It may also be used for eraser mode, drawing
;;in the same color as the background being supposed to erase whatever it writes
;;over.

(DEFINE ERASERCOLOR (ABB ERC ERASECOLOR) (COLOR-NAME) 
	;;Sets the background color, for CLEARSCREEN, eraser mode to the designated
	;;color.  It replaces the current background color.
	(MAKEPALETTE :ERASERNUMBER COLOR-NAME)
	COLOR-NAME) 

(DEFINE DELETECOLOR (ABB DC) (COLOR-NAME) 
 (LET
  ((PALETTE (GET COLOR-NAME 'PALETTE)))
  (COND ((EQ COLOR-NAME :PENCOLOR)
	 (ERRBREAK 'DELETECOLOR
		   '"CAN'T ERASE CURRENT PEN COLOR"))
	((EQ COLOR-NAME :ERASERCOLOR)
	 (ERRBREAK 'DELETECOLOR
		   '"CAN'T ERASE CURRENT ERASER COLOR"))
	((NULL PALETTE)
	 (ERRBREAK 'ERASECOLOR
		   (LIST COLOR-NAME
			 '"IS NOT A COLOR ON THE PALETTE")))
	(T (REMPROP COLOR-NAME 'PALETTE)
	   ;;Remove color, and mark place in palette as empty.
	   (STORE (PALETTE PALETTE) NIL)
	   ;;Store background color into color map, thereby [probably] causing stuff
	   ;;on screen in deleted color to disappear.
	   [COLOR (WRITE-COLOR-MAP PALETTE
			           (GET :ERASERCOLOR 'RED)
			           (GET :ERASERCOLOR 'GREEN)
			           (GET :ERASERCOLOR 'BLUE))])))) 

(DEFINE REPLACECOLOR (ABB RC) (OLD-COLOR NEW-COLOR) 
 ;;Changes the color map, replacing old color with new color.
 (LET
  ((PALETTE-PROPS (GETL OLD-COLOR '(PALETTE))))
  (OR
   PALETTE-PROPS
   (SETQ 
    PALETTE-PROPS
    (ERRBREAK 'REPLACECOLOR
	      (LIST OLD-COLOR
		    '"IS NOT A COLOR ON THE PALETTE"))))
  (DO ((COLOR-INDEX (CADR PALETTE-PROPS) (CADR PALETTE-PROPS)))
      ((NULL PALETTE-PROPS))
      (MAKEPALETTE COLOR-INDEX NEW-COLOR)
      (SETQ PALETTE-PROPS (GETL (CDR PALETTE-PROPS) '(PALETTE)))))
 NEW-COLOR) 

;;*PAGE



(DEFINE TWIDDLECOLOR (ABB COLORTWIDDLE) NIL 
	;;Changes colors randomly in the color map every :COLORTICK seconds by
	;;replacing a random slot with a color chosen randomly from :COLORS.
	(TWIDDLEINIT)
	(DO NIL (NIL) (TWIDDLEONCE) (SLEEP :COLORTICK))) 

;;RJL suggests this generate colors with random intensities as well.

(DEFINE RANDOMCOLOR NIL (NTH (1+ (RANDOM :NCOLORS)) :COLORS))

(DEFUN TWIDDLEINIT NIL 
       (SETQ :NSLOTS (- (LENGTH (DELQ NIL (LISTARRAY 'PALETTE))) 1.))) 

(DEFUN NTH (POSITION LIST) 
       (DO NIL ((ZEROP (DECREMENT POSITION)) (CAR LIST)) (POP LIST))) 

(DEFUN TWIDDLEONCE NIL (MAKEPALETTE (RANDOM :NSLOTS) (RANDOMCOLOR))) 

;;;
;;;(DEFUN TWIDDLEONCE NIL
;;;       (LET ((RANDOM-RED (RANDOM-BETWEEN 0. 511.))
;;;             (RANDOM-GREEN (RANDOM-BETWEEN 0. 511.))
;;;             (RANDOM-BLUE (RANDOM-BETWEEN 0. 511.))
;;;             (RANDOM-SLOT (RANDOM-BETWEEN 0 :NSLOTS)))
;;;            ;;THIS MESSES UP COLOR MAP, BUT....
;;;            (WRITE-COLOR-MAP RANDOM-SLOT RANDOM-RED RANDOM-GREEN RANDOM-BLUE)))
;;;

(DEFINE TWIDDLEREPEAT (TIMES) 
	(TWIDDLEINIT)
	(DO USELESS 0. (1+ USELESS) (= USELESS TIMES) (TWIDDLEONCE))) 


;;*PAGE

;;;

(COMMENT GLOBAL INITIALIZATIONS) 

;;;
;;;
;;;GLOBAL VARIABLES FOR DIMENSIONS OF SCREEN [ENTIRE TV TUBE],
;;AND PICTURE AREA.
;;;
;;;TV-PICTURE-TOP, TV-PICTURE-BOTTOM, TV-PICTURE-LEFT, TV-PICTURE-RIGHT
;;;  TV COORDINATES OF EDGES OF PICTURE AREA.
;;;TV-PICTURE-CENTER-X, TV-PICTURE-CENTER-Y 
;;; TV COORDINATES OF ORIGIN OF TURTLE.
;;;TV-PICTURE-SIZE-X, TV-PICTURE-SIZE-Y
;;; DIMENSIONS OF PICTURE AREA IN TV COORDINATES.
;;;TV-PICTURE-HALF-X, TV-PICTURE-HALF-Y
;;; HALF OF TV-PICTURE-SIZE-X, TV-PICTURE-SIZE-Y
;;;TURTLE-PICTURE-LEFT, TURTLE-PICTURE-RIGHT, TURTLE-PICTURE-BOTTOM,
;;TURTLE-PICTURE-TOP
;;; TURTLE COORDINATES OF EDGES OF PICTURE AREA. 
;;;TURTLE-PICTURE-SIZE-X, TURTLE-PICTURE-SIZE-Y
;;; DIMENSIONS OF PICTURE AREA IN TURTLE COORDINATES.
;;;TV-SHIFT-X, TV-SHIFT-Y
;;; DISTANCE FROM TV PICTURE CENTER TO LEFT AND BOTTOM EDGES.
;;;TV-SCREEN-CENTER-X, TV-SCREEN-CENTER-Y
;;; TV COORDINATES OF CENTER OF SCREEN.
;;;TV-SCREEN-RIGHT, TV-SCREEN-BOTTOM
;;; TV COORDINATES OF CORRESPONDING EDGES OF SCREEN. LEFT=TOP=0
;;;:TVSTEP
;;; CONVERSION FACTOR BETWEEN TURTLE AND TV COORDINATES.

(DECLARE (SPECIAL TV-SCREEN-CENTER-X TV-PICTURE-CENTER-X TURTLE-PICTURE-LEFT
		  TV-SCREEN-CENTER-Y PI-OVER-180 TV-PICTURE-HALF-X
		  TV-PICTURE-HALF-Y TURTLE-PICTURE-TOP TV-PICTURE-TOP
		  TV-PICTURE-CENTER-Y TV-PICTURE-BOTTOM :TVECHOLINES TV-SHIFT-Y
                  FLOAT-TV-SHIFT-Y TV-PICTURE-RIGHT FLOAT-TV-PICTURE-BOTTOM
                  TV-PICTURE-LEFT FLOAT-TV-PICTURE-LEFT TV-PICTURE-LEFT-FIX FIX-BITS
                  TV-PICTURE-BOTTOM-FIX TV-SHIFT-X FLOAT-TV-SHIFT-X :TVSTEP TWICE-TVSTEP
		  TURTLE-PICTURE-RIGHT TURTLE-PICTURE-BOTTOM SINE-120 COSINE-120
		  SINE-240 COSINE-240 TURTLE-RADIUS TURTLE-FRONT-X TURTLE-FRONT-Y
		  TURTLE-RIGHT-X TURTLE-RIGHT-Y TURTLE-LEFT-X TURTLE-LEFT-Y
		  :SEETURTLE TURTLE-FRONT-RADIUS-X TURTLE-FRONT-RADIUS-Y
		  TURTLE-LEFT-RADIUS-X TURTLE-LEFT-RADIUS-Y TURTLE-RIGHT-RADIUS-X
		  TURTLE-RIGHT-RADIUS-Y TV-PEN-RADIUS TV-TURTLE-FRONT-RADIUS
		  TV-TURTLE-SIDE-RADIUS TV-PICTURE-SIZE-X TV-PICTURE-SIZE-Y
                  FLOAT-TV-PICTURE-SIZE-X FLOAT-TV-PICTURE-SIZE-Y
		  TV-SCREEN-BOTTOM TV-SCREEN-RIGHT :TURTLES :TURTLE :WINDOWS 
                  TURTLE-PROPERTIES HATCH-PROPERTIES :XCOR :YCOR :HEADING)
	 (FLONUM PI-OVER-180 TURTLE-PICTURE-RIGHT TURTLE-PICTURE-TOP SINE-120
		 COSINE-120 SINE-240 COSINE-240 TURTLE-RADIUS TURTLE-FRONT-X
		 TURTLE-FRONT-Y TURTLE-LEFT-X TURTLE-LEFT-Y TURTLE-RIGHT-X
		 TURTLE-RIGHT-Y TURTLE-FRONT-RADIUS-X TURTLE-FRONT-RADIUS-Y
		 TURTLE-RIGHT-RADIUS-X TURTLE-RIGHT-RADIUS-Y TURTLE-LEFT-RADIUS-X
		 TURTLE-LEFT-RADIUS-Y TV-PEN-RADIUS TV-TURTLE-FRONT-RADIUS
		 TV-TURTLE-SIDE-RADIUS TURTLE-PICTURE-TOP TURTLE-PICTURE-RIGHT
		 TURTLE-PICTURE-LEFT TURTLE-PICTURE-BOTTOM :XCOR :YCOR :HEADING
                 FLOAT-TV-SHIFT-Y FLOAT-TV-SHIFT-X FLOAT-TV-PICTURE-LEFT
                 FLOAT-TV-PICTURE-BOTTOM FLOAT-TV-PICTURE-SIZE-X FLOAT-TV-PICTURE-SIZE-Y)
	 (FIXNUM TV-PICTURE-CENTER-X TV-SCREEN-CENTER-X TV-SCREEN-CENTER-Y
		 TV-PICTURE-TOP TV-PICTURE-HALF-X TV-PICTURE-HALF-Y TV-SHIFT-X
		 TV-SHIFT-Y TV-PICTURE-RIGHT TV-PICTURE-CENTER-Y TV-PICTURE-BOTTOM
                 TV-PICTURE-LEFT-FIX TV-PICTURE-BOTTOM-FIX FIX-BITS TV-SCREEN-RIGHT
		 :TVECHOLINES TV-PICTURE-RIGHT TV-PICTURE-LEFT TV-PICTURE-TOP
                 TV-PICTURE-SIZE-X TV-PICTURE-SIZE-Y TV-SCREEN-BOTTOM XGP-MAX))
     

(DECLARE (SPECIAL FIX-BITS MINUS-FIX-BITS UNIT-BIT FLOAT-UNIT UNIT-MASK HALF-UNIT)
         (FIXNUM FIX-BITS MINUS-FIX-BITS UNIT-BIT UNIT-MASK HALF-UNIT)
         (FLONUM FLOAT-UNIT))

(SETQ TV-SCREEN-CENTER-X 288. 
      TV-SCREEN-BOTTOM 455. 
      TV-SCREEN-RIGHT 575.
      TV-SCREEN-CENTER-Y (// TV-SCREEN-BOTTOM 2.) 
      FLOATING-POINT-TOLERANCE 1.0E-3 
      TWICE-FLOATING-POINT-TOLERANCE (*$ 2.0 FLOATING-POINT-TOLERANCE) 
      :PI 3.1415926 
      PI-OVER-180 (//$ :PI 180.0) 
      :POLYGON 30.0 
      :ECHOLINES NIL 
      SINE-120 (SIN (*$ 120.0 PI-OVER-180)) 
      COSINE-120 (COS (*$ 120.0 PI-OVER-180)) 
      SINE-240 (SIN (*$ 240.0 PI-OVER-180)) 
      COSINE-240 (COS (*$ 240.0 PI-OVER-180)) 
      TV-PEN-RADIUS 3.0 
      TV-TURTLE-FRONT-RADIUS 15.0 
      TV-TURTLE-SIDE-RADIUS 10.0 
      LESS-SUBR (GET '< 'SUBR) 
      GREATER-SUBR (GET '> 'SUBR) 
      WINDOWFRAME-BOUNDS NIL 
      VISIBLE-NUMBER 8. 
      TURTLE-PROPERTIES 23.
      ;;Changing TURTLE-PROPERTIES also requires changing declaration 
      ;;for HATCH-PROPERTY, TURTLE-PROPERTY above. 
      XGP-MAX 300.
      :WINDOWS NIL
      TV-SIZE-X-MAX 573.
      TV-SIZE-Y-MAX [COLOR 449.] [BW 415.]
      FIX-BITS 22.
      ;;Number of bits in fractional part.
      MINUS-FIX-BITS (- FIX-BITS)
      ;;Shift count for converting to ordinary integer.
      ;;One in fixed & float, mask for fractional part.
      UNIT-BIT (LSH 1. FIX-BITS)
      HALF-UNIT (LSH UNIT-BIT -1.)
      FLOAT-UNIT (FLOAT UNIT-BIT)
      UNIT-MASK (1- UNIT-BIT)
      :PENNUMBER 15. :ERASERNUMBER 15.)

(DECLARE (FLONUM CONVERSION-FACTOR TV-FACTOR-X TV-FACTOR-Y TURTLE-PICTURE-MIN
		 NEW-TURTLE-SIZE)
	 (SPECIAL TV-FACTOR-X TV-FACTOR-Y TURTLE-PICTURE-MIN TV-PICTURE-MIN)
	 (FIXNUM NEW-TV-SIZE-X NEW-TV-SIZE-Y TV-PICTURE-MIN)) 

(DECLARE (SPECIAL FLOATING-POINT-TOLERANCE TWICE-FLOATING-POINT-TOLERANCE LESS-SUBR
		  GREATER-SUBR)
	 (FLONUM FLOATING-POINT-TOLERANCE TWICE-FLOATING-POINT-TOLERANCE)
	 (SPECIAL PEN-RADIUS TURTLE-FRONT-RADIUS TURTLE-SIDE-RADIUS
		  TURTLE-PICTURE-SIZE-X TURTLE-PICTURE-SIZE-Y)
	 (FLONUM PEN-RADIUS TURTLE-FRONT-RADIUS TURTLE-SIDE-RADIUS
		 TURTLE-PICTURE-SIZE-X TURTLE-PICTURE-SIZE-Y NEW-TURTLE-SIZE-X
		 NEW-TURTLE-SIZE-Y)) 

(DECLARE (FIXNUM NEW-HOME-X NEW-HOME-Y (TV-X FLONUM) (TV-Y FLONUM))
	 (FLONUM :XCOR :YCOR TURTLE-SHIFT-X TURTLE-SHIFT-Y)
	 (SPECIAL :XCOR :YCOR)
	 (NOTYPE (SETXY$ FLONUM FLONUM))) 

(DECLARE (SPECIAL :PENSTATE :ERASERSTATE :XORSTATE :DRAWSTATE)) 

(DECLARE (SPECIAL TV-PICTURE-MIN SINE-HEADING COSINE-HEADING :DRAWTURTLE
		  :ERASETURTLE XGP-MAX HORIZONTAL VERTICAL :OUTLINE :WINDOWOUTLINE
                  :BRUSH BRUSH-INFO BRUSH-PICTURE :CLIP :PATTERNS
                  :PENCOLOR :PENNUMBER :ERASERNUMBER :ERASERCOLOR)
	 (FIXNUM TV-PICTURE-MIN XGP-MAX FROM-INDEX TO-INDEX POINT-INDEX
                 :PENNUMBER :ERASERNUMBER)
	 (FLONUM SINE-HEADING COSINE-HEADING :TVSTEP TWICE-TVSTEP)) 

(DECLARE (ARRAY* (FIXNUM (FROM-MASK 32.) (TO-MASK 32.) (POINT-MASK 32.)
                 [COLOR (ELEVEN-FROM-MASK 16.) (ELEVEN-TO-MASK 16.) 
                        (ELEVEN-POINT-MASK 16.) (ELEVEN-NOT-POINT-MASK 16.)])))

(DECLARE (ARRAY* (NOTYPE (HATCH-PROPERTY 23.) 
                         (TURTLE-PROPERTY 23.))))

(DEFUN INITIALIZE-TVRTLE-VARIABLES NIL 
       (SETQ TV-PICTURE-TOP [COLOR 2.] [BW 1.]
	     TV-PICTURE-BOTTOM 301.
             TV-PICTURE-BOTTOM-FIX (LSH TV-PICTURE-BOTTOM FIX-BITS)
             FLOAT-TV-PICTURE-BOTTOM (FLOAT TV-PICTURE-BOTTOM)
	     TV-PICTURE-LEFT 138. 
             TV-PICTURE-LEFT-FIX (LSH TV-PICTURE-LEFT FIX-BITS)
             FLOAT-TV-PICTURE-LEFT (FLOAT TV-PICTURE-LEFT)
	     TV-PICTURE-RIGHT 438. 
	     TV-PICTURE-CENTER-X 288. 
	     TV-PICTURE-CENTER-Y 151.
	     TV-SHIFT-X (- TV-PICTURE-CENTER-X TV-PICTURE-LEFT) 
             FLOAT-TV-SHIFT-X (+$ (FLOAT TV-SHIFT-X) 0.5)
	     TV-SHIFT-Y (- TV-PICTURE-BOTTOM TV-PICTURE-CENTER-Y) 
             FLOAT-TV-SHIFT-Y (+$ (FLOAT TV-SHIFT-Y) 0.5)
	     TV-PICTURE-HALF-X 150. 
	     TV-PICTURE-HALF-Y 150. 
	     TV-PICTURE-SIZE-X 301. 
             FLOAT-TV-PICTURE-SIZE-X 300.0
	     TV-PICTURE-SIZE-Y 301. 
             FLOAT-TV-PICTURE-SIZE-Y 300.0
	     TV-PICTURE-MIN 301. 
	     TV-FACTOR-X 1.0 
	     TV-FACTOR-Y 1.0 
	     TURTLE-PICTURE-MIN 1000.0 
	     :TVSTEP (//$ TURTLE-PICTURE-MIN
				(-$ (FLOAT TV-PICTURE-MIN)
				    TWICE-FLOATING-POINT-TOLERANCE))
             TWICE-TVSTEP (*$ 2.0 :TVSTEP) 
	     TURTLE-FRONT-RADIUS (*$ TV-TURTLE-FRONT-RADIUS :TVSTEP) 
	     TURTLE-SIDE-RADIUS (*$ TV-TURTLE-SIDE-RADIUS :TVSTEP) 
	     TURTLE-PICTURE-SIZE-X 1000.0 
	     TURTLE-PICTURE-SIZE-Y 1000.0 
	     TURTLE-PICTURE-TOP 500.0 
	     TURTLE-PICTURE-BOTTOM -500.0 
	     TURTLE-PICTURE-LEFT -500.0 
	     TURTLE-PICTURE-RIGHT 500.0 
	     :XCOR 0.0 
	     :YCOR 0.0 
	     :HEADING 0.0 
	     SINE-HEADING 0.0 
	     COSINE-HEADING 1.0 
	     :PENSTATE T 
	     :ERASERSTATE NIL 
	     :XORSTATE NIL 
             :DRAWSTATE T
	     :WRAP NIL 
             :CLIP NIL
	     :SEETURTLE NIL 
	     :DRAWTURTLE NIL 
	     :ERASETURTLE NIL 
	     :TURTLES '(LOGOTURTLE)
	     :TURTLE 'LOGOTURTLE 
	     :TVECHOLINES 10.
             :BRUSH NIL
             BRUSH-INFO NIL
             BRUSH-PICTURE NIL 
             :PATTERNS '(SOLID GRID CHECKER HORIZLINES VERTLINES DARKTEXTURE
                         LIGHTTEXTURE TEXTURE)
             HORIZONTAL (EXPR-FUNCTION HORIZONTAL-LINE)
             VERTICAL (EXPR-FUNCTION VERTICAL-LINE)
             :WINDOWOUTLINE [COLOR NIL] [BW T]
             :OUTLINE T)
       (FILLARRAY (ARRAY TURTLE-PROPERTY T TURTLE-PROPERTIES)
		  '(TV-PICTURE-CENTER-X TV-PICTURE-CENTER-Y :XCOR :YCOR :HEADING 
                    SINE-HEADING COSINE-HEADING :PENSTATE :ERASERSTATE 
                    :XORSTATE :DRAWSTATE :WRAP :CLIP :SEETURTLE 
                    :DRAWTURTLE :ERASETURTLE :PENCOLOR :PENNUMBER
                    :BRUSH BRUSH-INFO BRUSH-PICTURE HORIZONTAL VERTICAL))
       (FILLARRAY (ARRAY HATCH-PROPERTY T TURTLE-PROPERTIES)
		  (APPEND '(288. 152. 0.0 0.0 0.0 0.0 1.0 T NIL NIL T NIL NIL NIL NIL 
                            NIL WHITE 0. NIL NIL NIL)
                          (LIST (EXPR-FUNCTION HORIZONTAL-LINE)
                                (EXPR-FUNCTION VERTICAL-LINE))))
       (PUTPROP 'LOGOTURTLE (*ARRAY NIL T TURTLE-PROPERTIES) 'TURTLE)
       (ARRAY FROM-MASK FIXNUM 32.)
       (ARRAY TO-MASK FIXNUM 32.)
       (ARRAY POINT-MASK FIXNUM 32.)
       [COLOR (ARRAY ELEVEN-FROM-MASK FIXNUM 16.)
              (ARRAY ELEVEN-TO-MASK FIXNUM 16.)
              (ARRAY ELEVEN-POINT-MASK FIXNUM 16.)
              (ARRAY ELEVEN-NOT-POINT-MASK FIXNUM 16.)]
       (DO FROM-INDEX 0. (1+ FROM-INDEX) (= FROM-INDEX 32.)
           (STORE (FROM-MASK FROM-INDEX) (BITWISE-AND -16. (LSH -1. (- FROM-INDEX)))))
       (DO TO-INDEX 0. (1+ TO-INDEX) (= TO-INDEX 32.)
           (STORE (TO-MASK TO-INDEX) (LSH -1. (- 35. TO-INDEX))))
       (DO POINT-INDEX 0. (1+ POINT-INDEX) (= POINT-INDEX 32.)
           (STORE (POINT-MASK POINT-INDEX) (LSH 1. (- 35. POINT-INDEX))))
       [COLOR (DO FROM-INDEX 0. (1+ FROM-INDEX) (= FROM-INDEX 16.)
                 (STORE (ELEVEN-FROM-MASK FROM-INDEX) (LSH -1. (- 16. FROM-INDEX))))
              (DO TO-INDEX 0. (1+ TO-INDEX) (= TO-INDEX 16.)
                  (STORE (ELEVEN-TO-MASK TO-INDEX)  (1- (LSH 1. (- 15. TO-INDEX)))))
              (DO POINT-INDEX 0. (1+ POINT-INDEX) (= POINT-INDEX 16.)
                  (STORE (ELEVEN-POINT-MASK POINT-INDEX) (LSH 1. (- 15. POINT-INDEX)))
                  (STORE (ELEVEN-NOT-POINT-MASK POINT-INDEX) 
                         (BITWISE-NOT (ELEVEN-POINT-MASK POINT-INDEX))))]) 

;;*PAGE

;;;

(COMMENT SCALING FUNCTIONS) 

;;;

(DEFUN TURTLE-SIZE-X (NEW-TURTLE-SIZE-X) 
       (LET ((CONVERSION-FACTOR (//$ NEW-TURTLE-SIZE-X TURTLE-PICTURE-SIZE-X)))
	    (SETQ TURTLE-PICTURE-SIZE-X NEW-TURTLE-SIZE-X 
		  TURTLE-PICTURE-LEFT (*$ TURTLE-PICTURE-LEFT CONVERSION-FACTOR) 
		  TURTLE-PICTURE-RIGHT (*$ TURTLE-PICTURE-RIGHT CONVERSION-FACTOR)))) 

(DEFUN TURTLE-SIZE-Y (NEW-TURTLE-SIZE-Y) 
       (LET ((CONVERSION-FACTOR (//$ NEW-TURTLE-SIZE-Y TURTLE-PICTURE-SIZE-Y)))
	    (SETQ TURTLE-PICTURE-SIZE-Y NEW-TURTLE-SIZE-Y 
		  TURTLE-PICTURE-TOP (*$ TURTLE-PICTURE-TOP CONVERSION-FACTOR) 
		  TURTLE-PICTURE-BOTTOM (*$ TURTLE-PICTURE-BOTTOM
					    CONVERSION-FACTOR)))) 

(DEFINE TURTLESIZE ARGS 
	(COND ((ZEROP ARGS))
	      ((= ARGS 1.)
               (ERASE-TURTLE)
	       (SETQ TURTLE-PICTURE-MIN (FLOAT (ARG 1.)) 
		     :TVSTEP (//$ TURTLE-PICTURE-MIN
					(-$ (FLOAT TV-PICTURE-MIN)
					    TWICE-FLOATING-POINT-TOLERANCE)) 
                     TWICE-TVSTEP (*$ 2.0 :TVSTEP)
		     TURTLE-FRONT-RADIUS (*$ TV-TURTLE-FRONT-RADIUS :TVSTEP) 
		     TURTLE-SIDE-RADIUS (*$ TV-TURTLE-SIDE-RADIUS :TVSTEP))
	       (TURTLE-SIZE-X (*$ TURTLE-PICTURE-MIN TV-FACTOR-X))
	       (TURTLE-SIZE-Y (*$ TURTLE-PICTURE-MIN TV-FACTOR-Y))
               (DRAW-TURTLE)))
	(LIST TURTLE-PICTURE-SIZE-X TURTLE-PICTURE-SIZE-Y)) 

(ARGS 'TURTLESIZE '(0. . 1.)) 

(DEFUN TV-SETHOME (NEW-HOME-X NEW-HOME-Y) 
       (LET ((TURTLE-SHIFT-X (*$ (FLOAT (- NEW-HOME-X TV-PICTURE-CENTER-X))
				 :TVSTEP))
	     (TURTLE-SHIFT-Y (*$ (FLOAT (- TV-PICTURE-CENTER-Y NEW-HOME-Y))
				 :TVSTEP)))
	    (SETQ TV-PICTURE-CENTER-X NEW-HOME-X 
		  TV-PICTURE-CENTER-Y NEW-HOME-Y 
		  TV-SHIFT-X (- TV-PICTURE-CENTER-X TV-PICTURE-LEFT) 
                  FLOAT-TV-SHIFT-X (+$ (FLOAT TV-SHIFT-X) 0.5)
		  TV-SHIFT-Y (- TV-PICTURE-BOTTOM TV-PICTURE-CENTER-Y) 
                  FLOAT-TV-SHIFT-Y  (+$ (FLOAT TV-SHIFT-Y) 0.5)
		  TURTLE-PICTURE-RIGHT (-$ TURTLE-PICTURE-RIGHT TURTLE-SHIFT-X) 
		  TURTLE-PICTURE-LEFT (-$ TURTLE-PICTURE-LEFT TURTLE-SHIFT-X) 
		  TURTLE-PICTURE-TOP (-$ TURTLE-PICTURE-TOP TURTLE-SHIFT-Y) 
		  TURTLE-PICTURE-BOTTOM (-$ TURTLE-PICTURE-BOTTOM TURTLE-SHIFT-Y)))) 

(DEFINE SETHOME (ABB TURTLEHOME TH) ARGS 
	(ERASE-TURTLE)
	(LET ((NEW-HOME-X (COND ((ZEROP ARGS) (TV-X :XCOR))
				((= ARGS 1.) (TV-X (FLOAT (CAR (ARG 1.)))))
				((TV-X (FLOAT (ARG 1.))))))
	      (NEW-HOME-Y (COND ((ZEROP ARGS) (TV-Y :YCOR))
				((= ARGS 1.) (TV-Y (FLOAT (CAR (ARG 1.)))))
				((TV-Y (FLOAT (ARG 2.))))))
	      (:SEETURTLE NIL)
              (:DRAWSTATE NIL))
	     (TV-SETHOME NEW-HOME-X NEW-HOME-Y)
	     (SETXY$ 0.0 0.0))
	(DRAW-TURTLE)
	NO-VALUE) 

;;*PAGE


(DEFUN INTERNAL-TV-SIZE (NEW-TV-SIZE-X NEW-TV-SIZE-Y) 
       (COND ((> NEW-TV-SIZE-X NEW-TV-SIZE-Y)
	      (SETQ TV-PICTURE-MIN (1+ NEW-TV-SIZE-Y) 
		    TV-FACTOR-Y 1.0 
		    TV-FACTOR-X (//$ (FLOAT NEW-TV-SIZE-X) (FLOAT NEW-TV-SIZE-Y))))
	     ((SETQ TV-PICTURE-MIN (1+ NEW-TV-SIZE-X) 
		    TV-FACTOR-X 1.0 
		    TV-FACTOR-Y (//$ (FLOAT NEW-TV-SIZE-Y) (FLOAT NEW-TV-SIZE-X)))))
      (LET ((TV-CONVERSION-X (//$ (FLOAT NEW-TV-SIZE-X) FLOAT-TV-PICTURE-SIZE-X))
            (TV-CONVERSION-Y (//$ (FLOAT NEW-TV-SIZE-Y) FLOAT-TV-PICTURE-SIZE-Y)))
           ;;Conversion factors between old & new TV sizes for X and Y.
       (SETQ TV-PICTURE-HALF-X (LSH NEW-TV-SIZE-X -1.) 
	     TV-SHIFT-X (ROUND (*$ (FLOAT TV-SHIFT-X) TV-CONVERSION-X)) 
             FLOAT-TV-SHIFT-X (+$ (FLOAT TV-SHIFT-X) 0.5)
	     TV-PICTURE-SIZE-X (1+ NEW-TV-SIZE-X) 
             FLOAT-TV-PICTURE-SIZE-X (FLOAT NEW-TV-SIZE-X)
	     TV-PICTURE-LEFT (- TV-SCREEN-CENTER-X TV-PICTURE-HALF-X) 
             FLOAT-TV-PICTURE-LEFT (FLOAT TV-PICTURE-LEFT)
             TV-PICTURE-LEFT-FIX (LSH TV-PICTURE-LEFT FIX-BITS)
	     TV-PICTURE-RIGHT (+ TV-SCREEN-CENTER-X TV-PICTURE-HALF-X) 
	     TV-PICTURE-CENTER-X (+ TV-PICTURE-LEFT TV-SHIFT-X) 
	     TV-PICTURE-HALF-Y (LSH NEW-TV-SIZE-Y -1.) 
	     TV-SHIFT-Y (ROUND (*$ (FLOAT TV-SHIFT-Y) TV-CONVERSION-Y)) 
             FLOAT-TV-SHIFT-Y (+$ (FLOAT TV-SHIFT-Y) 0.5)
	     TV-PICTURE-SIZE-Y (1+ NEW-TV-SIZE-Y) 
             FLOAT-TV-PICTURE-SIZE-Y (FLOAT NEW-TV-SIZE-Y)
	     TV-PICTURE-BOTTOM (+ TV-PICTURE-TOP (LSH TV-PICTURE-HALF-Y 1.)) 
             TV-PICTURE-BOTTOM-FIX (LSH TV-PICTURE-BOTTOM FIX-BITS)
             FLOAT-TV-PICTURE-BOTTOM (FLOAT TV-PICTURE-BOTTOM)
	     TV-PICTURE-CENTER-Y (- TV-PICTURE-BOTTOM TV-SHIFT-Y) 
	     :TVECHOLINES (// (- TV-SCREEN-BOTTOM TV-PICTURE-BOTTOM 24.) 12.))
       ;;Update the homes of the turtles.
       (MAPC '(LAMBDA (TURTLE)
                      (COND ((EQ TURTLE :TURTLE))
                            ;;:TURTLE'S homes are spread in variables which
                            ;;have already been updated.
                            ((SETQ TURTLE (GET TURTLE 'TURTLE))
                             (STORE (ARRAYCALL T TURTLE 0.)
                                    (+ TV-SCREEN-CENTER-X
                                       (ROUND (*$ TV-CONVERSION-X 
                                                  (FLOAT (- (ARRAYCALL T TURTLE 0.)
                                                            TV-SCREEN-CENTER-X))))))
                             (STORE (ARRAYCALL T TURTLE 1.)
                                    (+ TV-PICTURE-TOP 
                                       (ROUND (*$ TV-CONVERSION-Y
                                                  (FLOAT (- (ARRAYCALL T TURTLE 1.)
                                                            TV-PICTURE-TOP)))))))))
             :TURTLES))
       (STORE (HATCH-PROPERTY 1.) (+ TV-PICTURE-TOP TV-PICTURE-HALF-Y))
       (CREATE-ECHO-AREA :TVECHOLINES))

 

(DECLARE (SPECIAL TV-SIZE-X-MAX TV-SIZE-Y-MAX) (FIXNUM TV-SIZE-X-MAX TV-SIZE-Y-MAX))

(DEFINE TVSIZE ARGS 
 (COND
  ((ZEROP ARGS))
  ((LET
    ((TV-SIZE-X (OR (ARG 1.) (1- TV-PICTURE-SIZE-X)))
     (TV-SIZE-Y (COND ((= ARGS 2.) (OR (ARG 2.) (1- TV-PICTURE-SIZE-Y)))
		      ((ARG 1.)))))
    (COND
     ((NOT (FIXP TV-SIZE-X))
      (SETQ TV-SIZE-X
	    (ERRBREAK 'TVSIZE
		      '"WRONG TYPE INPUT FOR X SIZE")))
     ((< TV-SIZE-X 30.)
      (SETQ TV-SIZE-X
	    (ERRBREAK 'TVSIZE
		      '"HORIZONTAL SIZE TOO SMALL")))
     ((> TV-SIZE-X TV-SIZE-X-MAX)
      (SETQ TV-SIZE-X
	    (ERRBREAK 'TVSIZE
		      '"HORIZONTAL SIZE TOO BIG"))))
    (COND ((NOT (FIXP TV-SIZE-Y))
	   (SETQ TV-SIZE-Y
		 (ERRBREAK 'TVSIZE
			   '"WRONG TYPE INPUT FOR Y SIZE")))
	  ((< TV-SIZE-Y 30.)
	   (SETQ TV-SIZE-Y
		 (ERRBREAK 'TVSIZE
			   '"VERTICAL SIZE TOO SMALL")))
	  ((> TV-SIZE-Y TV-SIZE-Y-MAX)
	   (SETQ TV-SIZE-Y
		 (ERRBREAK 'TVSIZE
			   '"VERTICAL SIZE TOO BIG"))))
    (INTERNAL-TV-SIZE TV-SIZE-X TV-SIZE-Y))
   (TURTLESIZE TURTLE-PICTURE-MIN)
   (CLEARSCREEN)))
 (LIST (1- TV-PICTURE-SIZE-X) (1- TV-PICTURE-SIZE-Y))) 

(ARGS 'TVSIZE '(0. . 2.))

(DECLARE (FLONUM FLOAT-SCALE-FACTOR))

(DEFINE SCALE (SCALE-FACTOR)
        ;;Changes the turtlesize without moving the turtle's place on
        ;;the screen. SCALE 2 doubles the size of subsequent drawings, etc.
        (LET ((:DRAWSTATE NIL) 
              ;;Don't draw turtle or lines during TURTLESIZE, SETXY operations.
              (:SEETURTLE NIL)
              (FLOAT-SCALE-FACTOR (FLOAT SCALE-FACTOR)))
             (TURTLESIZE (//$ TURTLE-PICTURE-MIN FLOAT-SCALE-FACTOR))
             ;;Change the turtlesize appropriately and move the turtle so its
             ;;place on the visual screen doesn't change.
             (SETXY$ (//$ :XCOR FLOAT-SCALE-FACTOR)
                     (//$ :YCOR FLOAT-SCALE-FACTOR)))) 

;;*PAGE

;;ARITHMETIC.

(DECLARE (FLONUM (\$ FLONUM FLONUM) (SINE) (COSINE) (ARCTAN) PI-OVER-180)
	 (SPECIAL PI-OVER-180) (FIXNUM FIX-MOD)) 

(DEFUN \$ (MODULAND MODULUS) 
       (LET ((FIX-MOD (FIX (//$ MODULAND MODULUS)))) 
            (-$ MODULAND (*$ MODULUS (FLOAT FIX-MOD)))))

(DEFINE SINE (DEGREES) (SIN (*$ (FLOAT DEGREES) PI-OVER-180))) 

(DEFINE COSINE (DEGREES) (COS (*$ (FLOAT DEGREES) PI-OVER-180))) 

(DEFINE ARCTAN (OPPOSITE ADJACENT) 
	(//$ (ATAN (FLOAT OPPOSITE) (FLOAT ADJACENT)) PI-OVER-180)) 

;;FUNCTIONS FOR CONVERTING BACK AND FORTH FROM TURTLE COORDINATES TO ABSOLUTE TV
;;COORDINATES.

(DECLARE (FLONUM (TURTLE-X FIXNUM)) (FIXNUM TV-XCOR)) 

(DEFUN TURTLE-X (TV-XCOR) (*$ (FLOAT (- TV-XCOR TV-PICTURE-CENTER-X)) :TVSTEP)) 

(DECLARE (FLONUM (TURTLE-Y FIXNUM)) (FIXNUM TV-YCOR)) 

(DEFUN TURTLE-Y (TV-YCOR) (*$ :TVSTEP (FLOAT (- TV-PICTURE-CENTER-Y TV-YCOR)))) 

(DECLARE (FIXNUM TV-PICTURE-SIZE-X TV-PICTURE-LEFT TV-SHIFT-X)
	 (SPECIAL TV-PICTURE-SIZE-X TV-PICTURE-LEFT TV-SHIFT-X)) 

(DECLARE (FIXNUM TV-PICTURE-SIZE-Y TV-SHIFT-Y TV-PICTURE-BOTTOM)
	 (SPECIAL TV-PICTURE-SIZE-Y TV-PICTURE-BOTTOM TV-SHIFT-Y)) 

(DECLARE (FIXNUM (TV-X FLONUM) RAW-X (TV-Y FLONUM) RAW-Y)) 

(DEFUN TV-X (TURTLE-X) 
       (LET ((RAW-X (+ (ROUND (//$ TURTLE-X :TVSTEP)) TV-SHIFT-X)))
	    ;;SCALE TO TV SIZED STEPS.
            (COND (:WRAP 
                   (COND ((MINUSP (SETQ RAW-X (\ RAW-X TV-PICTURE-SIZE-X)))
                          (INCREMENT RAW-X TV-PICTURE-SIZE-X)))))
	    ;;MOVE ZERO TO LEFT EDGE AND WRAP.
	    (+ RAW-X TV-PICTURE-LEFT))) 

(DEFUN TV-Y (TURTLE-Y) 
       (LET ((RAW-Y (+ (ROUND (//$ TURTLE-Y :TVSTEP)) TV-SHIFT-Y)))
	    ;;SCALE TO TV SIZED STEPS.
            (COND (:WRAP 
                   (COND ((MINUSP (SETQ RAW-Y (\ RAW-Y TV-PICTURE-SIZE-Y)))
                          (INCREMENT RAW-Y TV-PICTURE-SIZE-Y)))))
	    ;;MOVE ZERO TO BOTTOM. Y COORDINATES GO IN OTHER DIRECTION.
	    (- TV-PICTURE-BOTTOM RAW-Y))) 

;;*PAGE

;;;

(COMMENT SCREEN CLEARING)   

;;;

(DECLARE (SPECIAL :XCOR :YCOR :HEADING SINE-HEADING COSINE-HEADING :PENSTATE
		  :ERASERSTATE :XORSTATE TURTLE-PICTURE-RIGHT TURTLE-PICTURE-TOP
		  :TVSTEP :WRAP :SEETURTLE)
	 (FLONUM :XCOR :YCOR :HEADING SINE-HEADING COSINE-HEADING
		 TURTLE-PICTURE-RIGHT TURTLE-PICTURE-TOP :TVSTEP)) 

(DECLARE (FIXNUM I STOP J)) 

[BW 
(DEFUN TV-CLEARSCREEN NIL 
       (DO ((I 0. (1+ I))
	    (STOP (* 18. (- TV-SCREEN-BOTTOM (* :ECHOLINES 12.) 12.)))
	    (OLD-DRAWMODE (DRAWMODE SET)))
	   ((> I STOP) (DRAWMODE OLD-DRAWMODE))
           (STORE (TV I) 0.))
       (OUTPUT-TO-ECHO-AREA)
       (OUTLINE)) 

;;STARTDISPLAY IS A LEXPR FOR COMPATIBILITY WITH 340/GT40 TURTLE.

(DEFINE STARTDISPLAY (ABB SD) ARGS (TVINIT)
				   (INITIALIZE-TVRTLE-VARIABLES)
                                   (INITIALIZE-PALETTE)
				   (CURSORPOS (- (CAR (STATUS TTYSIZE)) 2.) 0.)
				   (CREATE-ECHO-AREA :TVECHOLINES)
				   (TV-CLEARSCREEN)
                                   (CURSORPOS 'C)
				   (HATCH 'LOGOTURTLE)
				   NO-VALUE) ]

(ARGS 'STARTDISPLAY '(0. . 0.)) 

(DEFINE NODISPLAY (ABB ND) NIL [BW (CREATE-ECHO-AREA 0.)] (CURSORPOS 'C) NO-VALUE) 

(DECLARE (*LEXPR HIDEWINDOW)) 

(DEFINE WIPE ARGS 
	(COND ((ZEROP ARGS) (WIPECLEAN))
	      ;;NO ARGS, CLEARS SCREEN, BUT DOESN'T MOVE TURTLE, [AS LLOGO 340 WIPE,
	      ;;11LOGO'S WIPECLEAN].  ONE ARG A WINDOW, HIDES IT AT CURRENT LOCATION
	      ;;[AS 11LOGO'S WIPE].
	      ((HIDEWINDOW (ARG 1.) :XCOR :YCOR)))
	NO-VALUE) 

[COLOR 

(DEFUN TV-CLEARSCREEN NIL 
       (WRITE-TV-MASK 0.) 
       ;;Use of block mode for CLEARSCREEN is currently
       ;;unreliable due to hardware flakiness.
       ;;;(WRITE-TV-BLOCK 0. -1. 16344. 1.)
       (DO ((I 0 (1+ I))) 
           ((= I 8192.))
           (STORE (TV I) -16.))) 

;;STARTDISPLAY IS A LEXPR FOR COMPATIBILITY WITH 340/GT40 TURTLE.

(DEFINE STARTDISPLAY (ABB SD) ARGS (INITIALIZE-TVRTLE-VARIABLES)
				   (TVINIT)
				   ;;; (CURSORPOS (- (CAR (STATUS TTYSIZE)) 2.) 0.)
				   ;;; (CREATE-ECHO-AREA :TVECHOLINES)
				   (SETQ :ECHOLINES 0.)
				   (INTERNAL-TV-SIZE TV-SIZE-X-MAX TV-SIZE-Y-MAX)
				   (TURTLESIZE TURTLE-PICTURE-MIN)
				   (SELECT-COLOR :ERASERNUMBER)
				   (TV-CLEARSCREEN)
				   (SELECT-COLOR :PENNUMBER)
				   (OUTLINE)
				   (HATCH 'LOGOTURTLE)
				   (SHOWTURTLE)
				   NO-VALUE) 

]

[BW

(DEFINE WIPECLEAN NIL
       (COND (:ECHOLINES
              (AND (ZEROP :ECHOLINES) (CREATE-ECHO-AREA :TVECHOLINES))
              (TV-CLEARSCREEN)
              (DRAW-TURTLES)))
       NO-VALUE)

(DEFINE CLEARSCREEN (ABB CS) NIL 
	(COND (:ECHOLINES (CLEAR-PALETTE) 
                          (LET ((:SEETURTLE NIL) (:DRAWSTATE NIL)) 
                               (PENCOLOR :PENCOLOR)
                               (HOME))
                          (WIPECLEAN)
			  NO-VALUE)
	      ;;FOLLOWING FOR LOSER WHO FORGOT STARTDISPLAY.
	      ((STARTDISPLAY)))) 

(DECLARE (*LEXPR MAKEWINDOW SHOWWINDOW)) 

(DEFINE SAVEDISPLAY (ABB SVD) NIL 
 ;;SINCE EXITING LISP AND GOING TO DDT RUINS, SCREEN, THIS EXITS GRACEFULLY, SAVING
 ;;AND RESTORING PICTURE.
 (MAKEWINDOW 'WHOLESCREEN)
 (VALRET '":CLEAR
: ----- YOU'RE IN DDT ------ 
")
 (TV-CLEARSCREEN)
 (SHOWWINDOW 'WHOLESCREEN)
 (ERASEWINDOW 'WHOLESCREEN)
 NO-VALUE)

;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
]

[COLOR 


(DEFINE SAVEDISPLAY  (ABB SVD) NIL (NOT-IMPLEMENTED-IN-COLOR '(SAVEDISPLAY)))

(DECLARE (*LEXPR HIDEWINDOW)) 

(DEFUN WIPECLEAN NIL 
       (SELECT-COLOR :ERASERNUMBER)
       (TV-CLEARSCREEN)
       (SELECT-COLOR :PENNUMBER)
       (OUTLINE)
       (CLEAR-PALETTE)                         
       (DRAW-TURTLES)
       (RESELECT-COLOR))
       NO-VALUE) 

;;NO ECHOLINES IN COLOR TURTLE

(DEFINE CLEARSCREEN (ABB CS) NIL 
	(COND (:ECHOLINES (RESET)
                          (WIPECLEAN)
			  ;;Whatever else to clear screen......
			  (LET ((:DRAWSTATE NIL) (:SEETURTLE NIL))
			       (PENCOLOR :PENCOLOR)
			       (HOME))
			  (RESELECT-COLOR)
			  NO-VALUE)
	      ;;FOLLOWING FOR LOSER WHO FORGOT STARTDISPLAY.
	      ((STARTDISPLAY)))) 

;;END OF COLOR CONDITIONAL SECTION.
]

(DEFUN CLEAR-PALETTE NIL
			  ;;REMOVE THE COLOR NUMBER PROPERTIES FROM COLORS BEING
			  ;;FLUSHED.
			  (DO COLOR-INDEX
			      0.
			      (1+ COLOR-INDEX)
			      (= COLOR-INDEX COLOR-MAX)
			      (AND (PALETTE COLOR-INDEX)
                                   (REMPROP (PALETTE COLOR-INDEX) 'PALETTE)))
			  ;;Now we know that nothing is on the screen in any color
			  ;;except the background, so we can mark all the slots in
			  ;;the palette as empty.
			  (FILLARRAY 'PALETTE '(NIL))
			  (ERASERCOLOR :ERASERCOLOR))


;;*PAGE

;;;

(COMMENT LINE DRAWING PROCEDURES) 

;;;

[BW

(DECLARE (NOTYPE (VERTICAL-LINE FIXNUM FIXNUM FIXNUM))	 
         (SPECIAL TV-PICTURE-TOP)
	 (FIXNUM TV-PICTURE-TOP MASK TV-ADDRESS STOP-ADDRESS)) 

;;VERTICAL-LINE EXPECTS ITS INPUT IN TV COORDINATES, LEAST Y TO GREATEST Y
;;[TOP TO BOTTOM].
;;IT TAKES ADVANTAGE OF THE KNOWLEDGE THAT IT IS TO DRAW A VERTICAL LINE, AND
;;RECYCLES THE MASK USED TO PICK OUT THE APPROPRIATE BIT.

(DEFUN VERTICAL-LINE (FROM-X FROM-Y TO-Y) 
       (DO ((MASK (POINT-MASK (BITWISE-AND FROM-X 31.)))
            (TV-ADDRESS (+ (* 18. FROM-Y) (SETQ FROM-X (LSH FROM-X -5.)))
                        (+ TV-ADDRESS 18.))
            (STOP-ADDRESS (+ (* 18. TO-Y) FROM-X)))
           ((> TV-ADDRESS STOP-ADDRESS))
	   (STORE (TV TV-ADDRESS) MASK))) 

;;;HORIZONTAL-LINE EXPECTS INPUT IN TV COORDINATES,
;;;FROM LEAST X TO GREATEST X [LEFT TO RIGHT].
;;IT TAKES ADVANTAGE OF THE SPECIAL CASE TO RAPIDLY DRAW A LINE SETTING UP TO 32
;;BITS IN PARALLEL WITH ONE STORE.

(DECLARE (NOTYPE (HORIZONTAL-LINE FIXNUM FIXNUM FIXNUM)) 
         (FIXNUM MASK STOP-MASK STOP-X)) 

(DEFUN HORIZONTAL-LINE (FROM-X FROM-Y TO-X) 
       (LET ((MASK (FROM-MASK (BITWISE-AND (PROG1 FROM-X (SETQ FROM-X (LSH FROM-X -5.)))
                                           31.)))
             (TV-ADDRESS (+ (SETQ FROM-Y (* 18. FROM-Y)) FROM-X) (1+ TV-ADDRESS))
	     (STOP-ADDRESS (+ FROM-Y (LSH TO-X -5.)))
             (STOP-MASK (TO-MASK (BITWISE-AND TO-X 31.))))
            (COND ((= TV-ADDRESS STOP-ADDRESS)
                   (STORE (TV STOP-ADDRESS) (BITWISE-AND MASK STOP-MASK)))
                  (T (STORE (TV TV-ADDRESS) MASK)
                     (DO NIL 
                         ((= (INCREMENT TV-ADDRESS) STOP-ADDRESS)
                          (STORE (TV STOP-ADDRESS) STOP-MASK))
                         (STORE (TV TV-ADDRESS) -16.)))))
       T)

(DEFINE OUTLINE NIL
        (AND :OUTLINE (LET ((OLD-DRAWMODE (DRAWMODE IOR)))
			 (TV-BOX TV-PICTURE-LEFT
				 TV-PICTURE-RIGHT
				 TV-PICTURE-BOTTOM
				 TV-PICTURE-TOP)
			 (DRAWMODE OLD-DRAWMODE)))
        NO-VALUE) 

(DECLARE (FIXNUM (TV-BOX FIXNUM FIXNUM FIXNUM FIXNUM))) 

(DEFUN TV-BOX (LEFT RIGHT BOTTOM TOP) 
       (SETQ LEFT (1- LEFT) RIGHT (1+ RIGHT))
       (HORIZONTAL-LINE LEFT (1- TOP) RIGHT)
       (HORIZONTAL-LINE LEFT (1+ BOTTOM) RIGHT)
       (VERTICAL-LINE LEFT TOP BOTTOM)
       (VERTICAL-LINE RIGHT TOP BOTTOM))

;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
] 


[COLOR 
;;;
;;These versions of horizontal and vertical line drawing procedures use the block
;;transfer mode feature of the 11logo TV system.  How much effeciency is gained by
;;doing so over repeated single writes of the memory, or use of directly writing the
;;mapped-in memory is not clear, especially in the case of horizontal lines.

(DECLARE (NOTYPE (VERTICAL-LINE FIXNUM FIXNUM)) (FIXNUM BIT-MASK BIT-X WORD-X)) 

(DEFUN VERTICAL-LINE (FROM-X FROM-Y TO-Y) 
       (LET ((WORD-X (LSH FROM-X -4.)) (BIT-X (BITWISE-AND FROM-X 15.)))
	    (LET ((BIT-MASK (ELEVEN-POINT-MASK BIT-X)))
		 (WRITE-TV-MASK (BITWISE-NOT BIT-MASK))
		 ;;Write into successive vertical words 1.  rotated to the right
		 ;;place.
		 (WRITE-TV-BLOCK (ELEVEN-TV-ADDRESS FROM-Y WORD-X)
				 BIT-MASK
				 (1+ (- TO-Y FROM-Y))
				 WORDS-PER-LINE)))) 

(DECLARE (NOTYPE (HORIZONTAL-LINE FIXNUM FIXNUM FIXNUM))
	 (FIXNUM START-WORD START-BIT STOP-WORD STOP-BIT START-MASK START-ADDRESS
		 WORD-COUNT STOP-MASK)) 

(DEFUN HORIZONTAL-LINE (FROM-X FROM-Y TO-X) 
       (LET ((START-WORD (LSH FROM-X -4.))
	     (START-BIT (BITWISE-AND FROM-X 15.))
	     (STOP-WORD (LSH TO-X -4.))
	     (STOP-BIT (BITWISE-AND TO-X 15.)))
	    (LET ((START-MASK (ELEVEN-FROM-MASK START-BIT))
		  (STOP-MASK (ELEVEN-TO-MASK STOP-BIT))
		  (WORD-COUNT (- STOP-WORD START-WORD))
		  (START-ADDRESS (ELEVEN-TV-ADDRESS FROM-Y START-WORD)))
		 (COND ((ZEROP WORD-COUNT)
			;;Entire line within one word.
			(WRITE-TV-MASK (BITWISE-OR START-MASK STOP-MASK))
			(WRITE-TV-WORD START-ADDRESS -1.))
		       ((WRITE-TV-MASK START-MASK)
			;;Write the first [partial] word.
			(WRITE-TV-WORD START-ADDRESS -1.)
			(WRITE-TV-MASK 0.)
			;;Block write all full words in between.
			(WRITE-TV-BLOCK (+ START-ADDRESS 2.) -1. (1- WORD-COUNT) 1.)
			(WRITE-TV-MASK STOP-MASK)
			;;Finish the last partial word.
			(WRITE-TV-WORD (+ START-ADDRESS (LSH WORD-COUNT 1.))
				       -1.)))))) 

(DECLARE (NOTYPE (STORE-TV-FIELD FIXNUM FIXNUM FIXNUM FIXNUM))) 

(DEFUN STORE-TV-FIELD (TV-ADDRESS WORD-DATA START-BIT STOP-BIT) 
       (COND ((< START-BIT 16.)
	      ;;WRITE THE LOW ORDER WORD.
	      (LET ((START-MASK (ELEVEN-FROM-MASK START-BIT)))
		   ;;CREATE MASK WITH ZEROS IN AREA TO BE SET.
		   (COND ((< STOP-BIT 16.)
			  ;;IF FIELD STOPS BEFORE END OF FIRST WORD.
			  (SETQ START-MASK
				(BITWISE-OR START-MASK (ELEVEN-TO-MASK STOP-BIT)))))
		   (WRITE-TV-MASK START-MASK)
		   ;;INHIBIT HIGH ORDER WORD.
		   (STORE (TV TV-ADDRESS) (BITWISE-OR WORD-DATA 4.)))))
       (COND ((> STOP-BIT 15.)
	      ;;WRITE HIGH ORDER WORD.
	      (LET ((STOP-MASK (ELEVEN-TO-MASK (- STOP-BIT 16.))))
		   (COND ((> START-BIT 15.)
			  (SETQ STOP-MASK
				(BITWISE-OR STOP-MASK 
                                            (ELEVEN-FROM-MASK (- START-BIT 16.))))))
		   (WRITE-TV-MASK STOP-MASK)
		   ;;INHIBIT LOWER ORDER WORD.
		   (STORE (TV TV-ADDRESS) (BITWISE-OR WORD-DATA 8.)))))
       T) 


(DEFINE OUTLINE NIL 
        (AND :OUTLINE 
             (TV-BOX TV-PICTURE-LEFT TV-PICTURE-RIGHT TV-PICTURE-BOTTOM TV-PICTURE-TOP))
        NO-VALUE) 

(DECLARE (FIXNUM (TV-BOX FIXNUM FIXNUM FIXNUM FIXNUM))) 

(DEFUN TV-BOX (LEFT RIGHT BOTTOM TOP) 
       (SETQ LEFT (1- LEFT) RIGHT (1+ RIGHT))
       (HORIZONTAL-LINE LEFT (1- TOP) RIGHT)
       (HORIZONTAL-LINE LEFT (- TOP 2.) RIGHT)
       ;;HORIZONTAL LINES LOOK LOTS BETTER IF THERE ARE TWO OF THEM BECAUSE OF
       ;;INTERLACE.
       (HORIZONTAL-LINE LEFT (+ BOTTOM 2.) RIGHT)
       (HORIZONTAL-LINE LEFT (1+ BOTTOM) RIGHT)
       (VERTICAL-LINE LEFT TOP BOTTOM)
       (VERTICAL-LINE RIGHT TOP BOTTOM)) 

;;END OF COLOR CONDITIONAL SECTION.
]



;;*PAGE
;;;
(COMMENT Vector drawing within display area)
;;;

(DECLARE (NOTYPE (BOUNDED-VECTOR FLONUM FLONUM FLONUM FLONUM))
	 (FLONUM CHANGE-X CHANGE-Y STEP-X STEP-Y TAN-HEADING SIGN-X$ SIGN-Y$
		 STANDARD-STEP-X STANDARD-STEP-Y)
	 (FIXNUM SIGN-X SIGN-Y TRAVEL-X TRAVEL-Y STOP-X STOP-Y)) 

(DECLARE (NOTYPE (BOUNDED-TURTLE-VECTOR FLONUM FLONUM FLONUM FLONUM)
                 (WRAP-TURTLE-VECTOR FLONUM FLONUM FLONUM FLONUM)
                 (CLIP-TURTLE-VECTOR FLONUM FLONUM FLONUM FLONUM)))


 
;;To minimize floating point computation in the inner loop of vector
;;drawing, normally floating point coordinates are converted to fixed point
;;numbers shifted so that they have a fixed size fractional part.

(DECLARE (FIXNUM (FIXIFY FLONUM) (TV-FIX-X FLONUM) (TV-FIX-Y FLONUM)))

;;Converts from float to fixed.

(DEFUN FIXIFY (FLONUM) (ROUND (*$ FLONUM FLOAT-UNIT)))

(DEFUN TV-FIX-X (TURTLE-X)
       ;;Turtle coordiates in fixed point. See code for TV-X, TV-Y.
       (FIXIFY (+$ (+$ (//$ TURTLE-X :TVSTEP) FLOAT-TV-SHIFT-X) FLOAT-TV-PICTURE-LEFT)))

(DEFUN TV-FIX-Y (TURTLE-Y)
       (FIXIFY (-$ FLOAT-TV-PICTURE-BOTTOM 
                   (+$ (//$ TURTLE-Y :TVSTEP) FLOAT-TV-SHIFT-Y))))


(DECLARE (NOTYPE (BOUNDED-VECTOR FLONUM FLONUM FLONUM FLONUM) 
                 (TVECTOR FIXNUM FIXNUM FIXNUM FIXNUM)))

(DEFUN BOUNDED-VECTOR (FROM-X FROM-Y TO-X TO-Y)
       ;;Floating point coordinates, i.e. turtle coordinates.
       (BOUNDED-VECTOR-FIX (TV-FIX-X FROM-X) 
                           (TV-FIX-Y FROM-Y) 
                           (TV-FIX-X TO-X) 
                           (TV-FIX-Y TO-Y)))

(DEFUN TVECTOR (FROM-X FROM-Y TO-X TO-Y)
       ;;Arguments in fixed point TV coordinates instead.
       (BOUNDED-VECTOR-FIX (LSH FROM-X FIX-BITS) 
                           (LSH FROM-Y FIX-BITS)
                           (LSH TO-X FIX-BITS)
                           (LSH TO-Y FIX-BITS)))

(DECLARE (NOTYPE (BOUNDED-VECTOR-FIX FIXNUM FIXNUM FIXNUM FIXNUM))
         (FIXNUM CHANGE-X-FIX CHANGE-Y-FIX ABS-CHANGE-X ABS-CHANGE-Y
                 FROM-X-FRAC FROM-Y-FRAC))

(DECLARE (NOTYPE (NEARLY-HORIZONTAL-VECTOR FIXNUM FIXNUM FIXNUM FIXNUM FLONUM FIXNUM)
                 (NEARLY-VERTICAL-VECTOR FIXNUM FIXNUM FIXNUM FIXNUM FLONUM FIXNUM)))


(DEFUN BOUNDED-VECTOR-FIX (FROM-X-FIX FROM-Y-FIX TO-X-FIX TO-Y-FIX)
       ;;Takes arguments as shifted fixed point numbers.
 (LET ((CHANGE-X-FIX (- TO-X-FIX FROM-X-FIX)) (CHANGE-Y-FIX (- TO-Y-FIX FROM-Y-FIX)))
      (LET ((ABS-CHANGE-X (ABS CHANGE-X-FIX)) (ABS-CHANGE-Y (ABS CHANGE-Y-FIX)))
           (COND ((> ABS-CHANGE-X ABS-CHANGE-Y)
                  ;;Split up cases according to whether greatest change is in
                  ;;X or Y direction. If in X, we step along Y values, drawing
                  ;;a horizontal line for each Y value.
                  (COND ((> FROM-X-FIX TO-X-FIX) 
                         ;;Exchange points to assure positive step along X. This
                         ;;means vector is drawn in same order regardless of which
                         ;;endpoint is the starting point. This aspect of it is
                         ;;mildly undesirable when system slow, may fix eventually.
                         (SETQ FROM-X-FIX (PROG1 TO-X-FIX (SETQ TO-X-FIX FROM-X-FIX))
                               FROM-Y-FIX (PROG1 TO-Y-FIX (SETQ TO-Y-FIX FROM-Y-FIX))
                               CHANGE-X-FIX (- CHANGE-X-FIX)
                               CHANGE-Y-FIX (- CHANGE-Y-FIX))))
                  (COND ((= (BITWISE-ANDC UNIT-MASK FROM-Y-FIX)
                            (BITWISE-ANDC UNIT-MASK TO-Y-FIX))
                         ;;If Y coordinates are same for both start & end point,
                         ;;The vector can be approximated as a horizontal line.
                         (EXPR-CALL HORIZONTAL (LSH FROM-X-FIX MINUS-FIX-BITS)
                                               (LSH FROM-Y-FIX MINUS-FIX-BITS)
                                               (LSH TO-X-FIX MINUS-FIX-BITS)))
                        ;;Otherwise off to general line drawer.
                        ((NEARLY-HORIZONTAL-VECTOR
                          FROM-X-FIX FROM-Y-FIX TO-X-FIX TO-Y-FIX
                          (//$ (FLOAT ABS-CHANGE-X) (FLOAT ABS-CHANGE-Y))
                          (COND ((MINUSP CHANGE-Y-FIX) -1.) (1.))))))
                 (T 
                  ;;Y case is similar....
                  (COND ((> FROM-Y-FIX TO-Y-FIX)
                         (SETQ FROM-Y-FIX (PROG1 TO-Y-FIX (SETQ TO-Y-FIX FROM-Y-FIX))
                               FROM-X-FIX (PROG1 TO-X-FIX (SETQ TO-X-FIX FROM-X-FIX))
                               CHANGE-X-FIX (- CHANGE-X-FIX)
                               CHANGE-Y-FIX (- CHANGE-Y-FIX))))
                  (COND ((= (BITWISE-ANDC UNIT-MASK FROM-X-FIX) 
                            (BITWISE-ANDC UNIT-MASK TO-X-FIX))
                         (EXPR-CALL VERTICAL (LSH FROM-X-FIX MINUS-FIX-BITS)
                                             (LSH FROM-Y-FIX MINUS-FIX-BITS)
                                             (LSH TO-Y-FIX MINUS-FIX-BITS)))
                        ((NEARLY-VERTICAL-VECTOR
                          FROM-X-FIX FROM-Y-FIX TO-X-FIX TO-Y-FIX
                          (//$ (FLOAT ABS-CHANGE-Y) (FLOAT ABS-CHANGE-X)) 
                          (COND ((MINUSP CHANGE-X-FIX) -1.) (1.))))))))))

(DEFUN NEARLY-HORIZONTAL-VECTOR (FROM-X-FIX FROM-Y-FIX TO-X-FIX TO-Y-FIX SLOPE SIGN-Y)
       ;;Vectors which are approximately horizontal [X change exceeds Y change].
       (LET ((FROM-X (LSH FROM-X-FIX MINUS-FIX-BITS))
             (FROM-Y (LSH FROM-Y-FIX MINUS-FIX-BITS))
             (TO-X (LSH TO-X-FIX MINUS-FIX-BITS))
             (TO-Y (LSH TO-Y-FIX MINUS-FIX-BITS))
             (FROM-Y-FRAC (BITWISE-AND UNIT-MASK FROM-Y-FIX)))
            ;;These four variables are TV coordinates of the endpoints.
            (LET ((PARTIAL-STEP
                   (FIXIFY (*$ SLOPE 
                               (//$ (FLOAT (COND ((MINUSP SIGN-Y) FROM-Y-FRAC)
                                                 ((- UNIT-BIT FROM-Y-FRAC))))
                                    FLOAT-UNIT)))))
                 ;;First and last steps computed separately, since involve
                 ;;fractional Y stepping.
                 (LET ((NEW-FROM-X (LSH (INCREMENT FROM-X-FIX PARTIAL-STEP)
                                        MINUS-FIX-BITS)))
                      ;;Don't go beyond bound of vector.
                      (COND ((> NEW-FROM-X TO-X) (SETQ NEW-FROM-X TO-X)))
                      ;;Draw the horizontal line.
                      (EXPR-CALL HORIZONTAL FROM-X FROM-Y NEW-FROM-X)
                      (SETQ FROM-X NEW-FROM-X)))
            (DO ((TRAVEL-Y (+ FROM-Y SIGN-Y) (+ TRAVEL-Y SIGN-Y)) 
                 (SLOPE-FIX (FIXIFY SLOPE))
                 (NEW-FROM-X))
                ;;Loop for successive additions of 1 Y step. When finished,
                ;;draw line to TO-X.
                ((= TRAVEL-Y TO-Y) (EXPR-CALL HORIZONTAL FROM-X TRAVEL-Y TO-X))
                (COND ((> (SETQ NEW-FROM-X (LSH (INCREMENT FROM-X-FIX SLOPE-FIX)
                                                MINUS-FIX-BITS))
                          TO-X)
                       (SETQ NEW-FROM-X TO-X)))
                (EXPR-CALL HORIZONTAL FROM-X TRAVEL-Y NEW-FROM-X)
                (SETQ FROM-X NEW-FROM-X))))

(DEFUN NEARLY-VERTICAL-VECTOR (FROM-X-FIX FROM-Y-FIX TO-X-FIX TO-Y-FIX SLOPE SIGN-X)
       ;;...As for NEARLY-HORIZONTAL-VECTOR.
       (LET ((FROM-X (LSH FROM-X-FIX MINUS-FIX-BITS))
             (FROM-Y (LSH FROM-Y-FIX MINUS-FIX-BITS))
             (TO-X (LSH TO-X-FIX MINUS-FIX-BITS))
             (TO-Y (LSH TO-Y-FIX MINUS-FIX-BITS))
             (FROM-X-FRAC (BITWISE-AND UNIT-MASK FROM-X-FIX)))
            (LET ((PARTIAL-STEP
                   (FIXIFY (*$ SLOPE 
                               (//$ (FLOAT (COND ((MINUSP SIGN-X) FROM-X-FRAC)
                                                 ((- UNIT-BIT FROM-X-FRAC))))
                                    FLOAT-UNIT)))))
                 (LET ((NEW-FROM-Y 
                        (LSH (INCREMENT FROM-Y-FIX PARTIAL-STEP) MINUS-FIX-BITS)))
                      (COND ((> NEW-FROM-Y TO-Y) (SETQ NEW-FROM-Y TO-Y)))
                      (EXPR-CALL VERTICAL FROM-X FROM-Y NEW-FROM-Y)
                      (SETQ FROM-Y NEW-FROM-Y)))
            (DO ((TRAVEL-X (+ FROM-X SIGN-X) (+ TRAVEL-X SIGN-X)) 
                 (SLOPE-FIX (FIXIFY SLOPE))
                 (NEW-FROM-Y))
                ((= TRAVEL-X TO-X) (EXPR-CALL VERTICAL TRAVEL-X FROM-Y TO-Y))
                (COND ((> (SETQ NEW-FROM-Y 
                                (LSH (INCREMENT FROM-Y-FIX SLOPE-FIX) MINUS-FIX-BITS))
                          TO-Y)
                       (SETQ NEW-FROM-Y TO-Y)))
                (EXPR-CALL VERTICAL TRAVEL-X FROM-Y NEW-FROM-Y)
                (SETQ FROM-Y NEW-FROM-Y))))


(DECLARE (NOTYPE OUT-OF-BOUNDS-CHECK FLONUM FLONUM))

(DEFUN OUT-OF-BOUNDS-CHECK (NEW-X$ NEW-Y$)
	 (COND
	  ((> (-$ NEW-X$ TURTLE-PICTURE-RIGHT) FLOATING-POINT-TOLERANCE)
	   (ERRBREAK
             'SETXY$
             '"TURTLE MOVED OFF THE RIGHT SIDE OF THE SCREEN")
           T)
	  ((> (-$ TURTLE-PICTURE-LEFT NEW-X$) FLOATING-POINT-TOLERANCE)
	    (ERRBREAK
	     'SETXY$
	     '"TURTLE MOVED OFF THE LEFT SIDE OF THE SCREEN")
            T)
	  ((> (-$ NEW-Y$ TURTLE-PICTURE-TOP) FLOATING-POINT-TOLERANCE)
	    (ERRBREAK
	     'SETXY$
	     '"TURTLE MOVED OFF THE TOP OF THE SCREEN")
            T)
	  ((> (-$ TURTLE-PICTURE-BOTTOM NEW-Y$) FLOATING-POINT-TOLERANCE)
	    (ERRBREAK
	     'SETXY$
	     '"TURTLE MOVED OFF THE BOTTOM OF THE SCREEN")
            T)))

(DEFUN BOUNDED-TURTLE-VECTOR (FROM-X FROM-Y TO-X TO-Y)
       ;;Called to draw a vector with turtle in NOWRAP, NOCLIP mode.
       (COND ((OUT-OF-BOUNDS-CHECK TO-X TO-Y))
             ;;If turtle tries to move out of bounds, error. Else erase turtle cursor
             ;;at old position, draw vector if necessary, show turtle.
             (T (ERASE-TURTLES) 
                (AND :DRAWSTATE (BOUNDED-VECTOR FROM-X FROM-Y TO-X TO-Y))
                (SETQ :XCOR TO-X :YCOR TO-Y)
                (DRAW-TURTLES))))

;;*PAGE

(COMMENT Wrap mode)

(DECLARE (FIXNUM (SCREEN-X FLONUM) (SCREEN-Y FLONUM) (FIXIFY-SCREEN-FRACTION-X FLONUM)
                 (FIXIFY-SCREEN-FRACTION-Y FLONUM) (FIXIFY FLONUM))
         (FLONUM (SCREEN-FRACTION-X FIXNUM FLONUM) (SCREEN-FRACTION-Y FIXNUM FLONUM)))

;;Following functions divide a floating point coordinate position into a
;;"screen" [integer multiple of screen size] and fraction of screen from the left
;;or bottom edge.

(DEFUN SCREEN-X (WRAP-X)
       ;;Translate to left edge, divide by picture area size in turtle coordinates.
       (FIX (//$ (-$ WRAP-X TURTLE-PICTURE-LEFT) TURTLE-PICTURE-SIZE-X)))

(DEFUN SCREEN-Y (WRAP-Y)
       (FIX (//$ (-$ WRAP-Y TURTLE-PICTURE-BOTTOM) TURTLE-PICTURE-SIZE-Y)))

(DEFUN SCREEN-FRACTION-X (SCREEN-X WRAP-X)
       ;;Arguments are screen, produced by SCREEN-X, and full wrap coordinate.
       (//$ (-$ (-$ WRAP-X TURTLE-PICTURE-LEFT) 
                (*$ (FLOAT SCREEN-X) TURTLE-PICTURE-SIZE-X))
            TURTLE-PICTURE-SIZE-X))

(DEFUN SCREEN-FRACTION-Y (SCREEN-Y WRAP-Y)
       (//$ (-$ (-$ WRAP-Y TURTLE-PICTURE-BOTTOM) 
                (*$ (FLOAT SCREEN-Y) TURTLE-PICTURE-SIZE-Y))
            TURTLE-PICTURE-SIZE-Y))

;;These take screen fraction, and convert into shifted fixnum TV coordinate suitable
;;for use by BOUNDED-VECTOR-FIX.

(DEFUN FIXIFY-SCREEN-FRACTION-X (SCREEN-FRACTION-X)
       (+ TV-PICTURE-LEFT-FIX (FIXIFY (*$ SCREEN-FRACTION-X FLOAT-TV-PICTURE-SIZE-X))))

(DEFUN FIXIFY-SCREEN-FRACTION-Y (SCREEN-FRACTION-Y)
       (- TV-PICTURE-BOTTOM-FIX (FIXIFY (*$ SCREEN-FRACTION-Y FLOAT-TV-PICTURE-SIZE-Y))))

;;*PAGE


(DECLARE (NOTYPE (WRAP-VECTOR FLONUM FLONUM FLONUM FLONUM)
                 (WRAP-SCREEN-VECTOR FIXNUM FLONUM FIXNUM FLONUM 
                                     FIXNUM FLONUM FIXNUM FLONUM)
                 (BOUNDED-VECTOR-FIX FIXNUM FIXNUM FIXNUM FIXNUM)
                 (BOUNDED-VECTOR-FIX-ROUND FIXNUM FIXNUM FIXNUM FIXNUM))
         (FIXNUM FROM-SCREEN-X FROM-SCREEN-Y TO-SCREEN-X TO-SCREEN-Y SIGN-Y
                 EDGE-SCREEN-X EDGE-SCREEN-Y FIX-EDGE-FRACTION)
         (FLONUM FROM-FRACTION-X FROM-FRACTION-Y TO-FRACTION-X TO-FRACTION-Y
                 EDGE-FRACTION-X EDGE-FRACTION-Y CHANGE-X CHANGE-Y FROM-EDGE-FRACTION
                 TO-EDGE-FRACTION TO-EDGE-X TO-EDGE-Y))

(DEFUN WRAP-VECTOR (FROM-X FROM-Y TO-X TO-Y)
       ;;Draws vector allowing wraparound. Argument in turtle coordnates.
       (LET ((FROM-SCREEN-X (SCREEN-X FROM-X))
	     (FROM-SCREEN-Y (SCREEN-Y FROM-Y))
	     (TO-SCREEN-X (SCREEN-X TO-X))
	     (TO-SCREEN-Y (SCREEN-Y TO-Y)))
	    (LET ((FROM-FRACTION-X (SCREEN-FRACTION-X FROM-SCREEN-X FROM-X))
		  (FROM-FRACTION-Y (SCREEN-FRACTION-Y FROM-SCREEN-Y FROM-Y))
		  (TO-FRACTION-X (SCREEN-FRACTION-X TO-SCREEN-X TO-X))
		  (TO-FRACTION-Y (SCREEN-FRACTION-Y TO-SCREEN-Y TO-Y)))
                 ;;Split up into screens and fractions of screens, then hand off
                 ;;to WRAP-SCREEN-VECTOR.
		 (WRAP-SCREEN-VECTOR FROM-SCREEN-X FROM-FRACTION-X
				     FROM-SCREEN-Y FROM-FRACTION-Y
				     TO-SCREEN-X TO-FRACTION-X
				     TO-SCREEN-Y TO-FRACTION-Y))))

(DEFUN WRAP-SCREEN-VECTOR
       (FROM-SCREEN-X FROM-FRACTION-X FROM-SCREEN-Y FROM-FRACTION-Y
        TO-SCREEN-X TO-FRACTION-X TO-SCREEN-Y TO-FRACTION-Y)
       (COND ((NOT (= FROM-SCREEN-X TO-SCREEN-X))
              ;;Vector crosses an X screen edge.
              (LET ((CHANGE-X (+$ (FLOAT (- TO-SCREEN-X FROM-SCREEN-X)) 
                                  (-$ TO-FRACTION-X FROM-FRACTION-X)))
                    (CHANGE-Y (+$ (FLOAT (- TO-SCREEN-Y FROM-SCREEN-Y))
                                  (-$ TO-FRACTION-Y FROM-FRACTION-Y))))
                   ;;[This can be done more efficiently.]
                   (LET ((TO-EDGE-X (-$ FROM-FRACTION-X))
                         (FROM-EDGE-FRACTION 0.0)
                         (TO-EDGE-FRACTION 1.0)
                         (SIGN-X -1.))
                        (AND (PLUSP CHANGE-X)
                             (SETQ SIGN-X 1.
                                   TO-EDGE-X (-$ 1.0 FROM-FRACTION-X)
                                   FROM-EDGE-FRACTION 1.0
                                   TO-EDGE-FRACTION 0.0))
                        ;;Compute X and Y coordinates to split the vector
                        ;;at the X edge.
                        (LET ((EDGE-FRACTION-Y 
                               (+$ FROM-FRACTION-Y 
                                   (*$ TO-EDGE-X (//$ CHANGE-Y CHANGE-X))))
                              (EDGE-SCREEN-Y FROM-SCREEN-Y))
                             (LET ((FIX-EDGE-FRACTION (FIX EDGE-FRACTION-Y)))
                                  (INCREMENT EDGE-SCREEN-Y FIX-EDGE-FRACTION)
                                  (SETQ EDGE-FRACTION-Y 
                                        (-$ EDGE-FRACTION-Y (FLOAT FIX-EDGE-FRACTION)))
                                  (WRAP-SCREEN-VECTOR FROM-SCREEN-X FROM-FRACTION-X 
                                                      FROM-SCREEN-Y FROM-FRACTION-Y
                                                      FROM-SCREEN-X FROM-EDGE-FRACTION
                                                      EDGE-SCREEN-Y EDGE-FRACTION-Y)
                                  ;;Draw a vector on this screen from FROM point to the 
                                  ;;edge, then continue from the edge to TO point.
                                  (WRAP-SCREEN-VECTOR (+ FROM-SCREEN-X SIGN-X) 
                                                      TO-EDGE-FRACTION 
                                                      EDGE-SCREEN-Y EDGE-FRACTION-Y 
                                                      TO-SCREEN-X TO-FRACTION-X 
                                                      TO-SCREEN-Y TO-FRACTION-Y))))))
             ((NOT (= FROM-SCREEN-Y TO-SCREEN-Y))
              (LET ((CHANGE-X (+$ (FLOAT (- TO-SCREEN-X FROM-SCREEN-X)) 
                                  (-$ TO-FRACTION-X FROM-FRACTION-X)))
                    (CHANGE-Y (+$ (FLOAT (- TO-SCREEN-Y FROM-SCREEN-Y))
                                  (-$ TO-FRACTION-Y FROM-FRACTION-Y))))
                   (LET ((TO-EDGE-Y (-$ FROM-FRACTION-Y))
                         (FROM-EDGE-FRACTION 0.0)
                         (TO-EDGE-FRACTION 1.0)
                         (SIGN-Y -1.))
                        (AND (PLUSP CHANGE-Y)
                             (SETQ SIGN-Y 1.
                                   TO-EDGE-Y (-$ 1.0 FROM-FRACTION-Y)
                                   FROM-EDGE-FRACTION 1.0
                                   TO-EDGE-FRACTION 0.0))
                        (LET ((EDGE-FRACTION-X
                               (+$ FROM-FRACTION-X
                                   (*$ TO-EDGE-Y (//$ CHANGE-X CHANGE-Y))))
                              (EDGE-SCREEN-X FROM-SCREEN-X))
                             (LET ((FIX-EDGE-FRACTION (FIX EDGE-FRACTION-X)))
                                  (INCREMENT EDGE-SCREEN-X FIX-EDGE-FRACTION)
                                  (SETQ EDGE-FRACTION-X 
                                        (-$ EDGE-FRACTION-X (FLOAT FIX-EDGE-FRACTION)))
                                  (WRAP-SCREEN-VECTOR FROM-SCREEN-X FROM-FRACTION-X 
                                                      FROM-SCREEN-Y FROM-FRACTION-Y
                                                      EDGE-SCREEN-X EDGE-FRACTION-X
                                                      FROM-SCREEN-Y FROM-EDGE-FRACTION)
                                  (WRAP-SCREEN-VECTOR EDGE-SCREEN-X EDGE-FRACTION-X
                                                      (+ FROM-SCREEN-Y SIGN-Y) 
                                                      TO-EDGE-FRACTION
                                                      TO-SCREEN-X TO-FRACTION-X 
                                                      TO-SCREEN-Y TO-FRACTION-Y))))))
             ((BOUNDED-VECTOR-FIX-ROUND (FIXIFY-SCREEN-FRACTION-X FROM-FRACTION-X)
                                        (FIXIFY-SCREEN-FRACTION-Y FROM-FRACTION-Y)
                                        (FIXIFY-SCREEN-FRACTION-X TO-FRACTION-X)
                                        (FIXIFY-SCREEN-FRACTION-Y TO-FRACTION-Y)))))

(DEFUN BOUNDED-VECTOR-FIX-ROUND (FROM-X-FIX FROM-Y-FIX TO-X-FIX TO-Y-FIX)
       ;;Increment coordinates by 1/2 so that truncation will round.
       (BOUNDED-VECTOR-FIX (+ FROM-X-FIX HALF-UNIT)
                           (+ FROM-Y-FIX HALF-UNIT)
                           (+ TO-X-FIX HALF-UNIT)
                           (+ TO-Y-FIX HALF-UNIT)))

(DEFUN WRAP-TURTLE-VECTOR (FROM-X FROM-Y TO-X TO-Y)
       (ERASE-TURTLES)
       (AND :DRAWSTATE (WRAP-VECTOR FROM-X FROM-Y TO-X TO-Y))
       (SETQ :XCOR TO-X :YCOR TO-Y)
       (DRAW-TURTLES))


(DECLARE (FIXNUM (CLIP-VISIBILITY FLONUM FLONUM)))

(DEFUN NOWRAP-NOCLIP-HERE NIL
       ;;Smashes down turtle location to fit within the boundaries of the
       ;;display area. Used in leaving WRAP and CLIP modes where HERE may
       ;;exceed legal screen boundaries.
       (ERASE-TURTLE)
       ;;Changing turtle coordinates may result in slightly moving the turtle.
       (AND (PLUSP (CLIP-VISIBILITY :XCOR :YCOR))
            (SETQ :XCOR (TURTLE-X (TV-X :XCOR)) :YCOR (TURTLE-Y (TV-Y :YCOR))))
       (DRAW-TURTLE))

(DEFINE WRAP NIL (SETQ :WRAP T :CLIP NIL) NO-VALUE) 

(DEFINE NOWRAP NIL (NOWRAP-NOCLIP-HERE) (SETQ :WRAP NIL) NO-VALUE)


;;*PAGE

;;;
(COMMENT Clip mode)
;;;
 
;;;In clip mode, display past boundaries of the screen is simply ignored.

(DECLARE (FIXNUM (CLIP-VISIBILITY FLONUM FLONUM) VISIBILITY FROM-VISIBILITY 
                 TO-VISIBILITY)
         (NOTYPE (CLIP-VECTOR FLONUM FLONUM FLONUM FLONUM)
                 (CLIP-VECTOR-VISIBILITY FLONUM FLONUM FLONUM FLONUM FIXNUM FIXNUM)
                 (CLIP-TURTLE-VECTOR FLONUM FLONUM FLONUM FLONUM)))

(DEFUN CLIP-VISIBILITY (POINT-X POINT-Y)
       (LET ((VISIBILITY 0.))
            (COND ((< POINT-X TURTLE-PICTURE-LEFT) (INCREMENT VISIBILITY 1.))
                  ((> POINT-X TURTLE-PICTURE-RIGHT) (INCREMENT VISIBILITY 2.)))
            (COND ((< POINT-Y TURTLE-PICTURE-BOTTOM) (+ VISIBILITY 4.))
                  ((> POINT-Y TURTLE-PICTURE-TOP) (+ VISIBILITY 8.))
                  (VISIBILITY))))

(DEFUN CLIP-VECTOR (FROM-X FROM-Y TO-X TO-Y)
       (CLIP-VECTOR-VISIBILITY FROM-X FROM-Y TO-X TO-Y 
                               (CLIP-VISIBILITY FROM-X FROM-Y)
                               (CLIP-VISIBILITY TO-X TO-Y)))

(DEFUN CLIP-VECTOR-VISIBILITY (FROM-X FROM-Y TO-X TO-Y FROM-VISIBILITY TO-VISIBILITY)
       (DO NIL
           ((AND (ZEROP FROM-VISIBILITY) (ZEROP TO-VISIBILITY))
            ;;Both points visible, draw line.
            (BOUNDED-VECTOR FROM-X FROM-Y TO-X TO-Y))
           (COND ((ZEROP (BITWISE-AND FROM-VISIBILITY TO-VISIBILITY)))
                 ;;Both points beyond visible bounds, reject entire line.
                 ((RETURN T)))
           (COND ((ZEROP FROM-VISIBILITY)
                  ;;Exchange points so that TO point is visible.
                  (SETQ FROM-X (PROG1 TO-X (SETQ TO-X FROM-X))
                        FROM-Y (PROG1 TO-Y (SETQ TO-Y FROM-Y))
                        FROM-VISIBILITY (PROG1 TO-VISIBILITY 
                                               (SETQ TO-VISIBILITY FROM-VISIBILITY)))))
           (COND ((ZEROP (BITWISE-AND FROM-VISIBILITY 1.)))
                 ;;Push toward left edge.
                 ((SETQ FROM-Y (+$ FROM-Y
                                   (*$ (//$ (-$ TO-Y FROM-Y) (-$ TO-X FROM-X))
                                       (-$ TURTLE-PICTURE-LEFT FROM-X)))
                        FROM-X TURTLE-PICTURE-LEFT)))
           (COND ((ZEROP (BITWISE-AND FROM-VISIBILITY 2.)))
                 ;;Push toward right edge.
                 ((SETQ FROM-Y (+$ FROM-Y
                                   (*$ (//$ (-$ TO-Y FROM-Y) (-$ TO-X FROM-X))
                                       (-$ TURTLE-PICTURE-RIGHT FROM-X)))
                        FROM-X TURTLE-PICTURE-RIGHT)))
           (COND ((ZEROP (BITWISE-AND FROM-VISIBILITY 4.)))
                 ;;Push toward top.
                 ((SETQ FROM-X (+$ FROM-X
                                   (*$ (//$ (-$ TO-X FROM-X) (-$ TO-Y FROM-Y))
                                       (-$ TURTLE-PICTURE-BOTTOM FROM-Y)))
                        FROM-Y TURTLE-PICTURE-BOTTOM)))
           (COND ((ZEROP (BITWISE-AND FROM-VISIBILITY 8.)))
                 ;;Push toward bottom.
                 ((SETQ FROM-X (+$ FROM-X
                                   (*$ (//$ (-$ TO-X FROM-X) (-$ TO-Y FROM-Y))
                                       (-$ TURTLE-PICTURE-TOP FROM-Y)))
                        FROM-Y TURTLE-PICTURE-TOP)))
           (SETQ FROM-VISIBILITY (CLIP-VISIBILITY FROM-X FROM-Y))))

(DEFUN CLIP-TURTLE-VECTOR (FROM-X FROM-Y TO-X TO-Y)
       (ERASE-TURTLES)
       (AND :DRAWSTATE (CLIP-VECTOR FROM-X FROM-Y TO-X TO-Y))
       (SETQ :XCOR TO-X :YCOR TO-Y)
       (DRAW-TURTLES))


(DEFINE CLIP NIL (SETQ :CLIP T :WRAP NIL) NO-VALUE)

(DEFINE NOCLIP NIL (NOWRAP-NOCLIP-HERE) (SETQ :CLIP NIL) NO-VALUE)
           
;;*PAGE

;;;

(COMMENT TRIANGLE TURTLE CURSOR) 

;;;
;;;
;;;
;;THE TURTLE IS DRAWN IN "XOR" MODE -- THAT IS, TRIANGLE TURTLE LINES ARE XORED IN
;;WITH PICTURE.  THIS ALLOWS ONE PROCEDURE TO CAUSE TURTLE TO APPEAR AND DISAPPEAR,
;;WITHOUT DISRUPTING PICTURE.  THE TURTLE IS THEREFORE ALWAYS VISIBLE EVEN ON
;;FILLED-IN OR SHADED BACKGROUND.  THE PEN, ERASER, AND XOR MARKERS ARE WINDOWS
;;WHICH ARE XORED IN WHEN NEEDED.

(DECLARE (SPECIAL PEN-WINDOW ERASER-WINDOW XOR-WINDOW PEN-INFO)) 

(FILLARRAY (SET (ARRAY PEN-WINDOW FIXNUM 7.) (GET 'PEN-WINDOW 'ARRAY))
	   '(-536870912. -536870912. -536870912. -536870912. -536870912. -536870912. 
             -536870912.)) 

(FILLARRAY (SET (ARRAY ERASER-WINDOW FIXNUM 7.) (GET 'ERASER-WINDOW 'ARRAY))
	   '(-536870912. -33822867456. -33822867456. -33822867456. -33822867456. 
             -33822867456. -536870912.)) 

(FILLARRAY (SET (ARRAY XOR-WINDOW FIXNUM 7.) (GET 'XOR-WINDOW 'ARRAY))
	   '(-16642998272. 27380416512. 16106127360. 6442450944. 16106127360. 
             27380416512. -16642998272. )) 

(FILLARRAY (SET (ARRAY PEN-INFO FIXNUM 8.) (GET 'PEN-INFO 'ARRAY))
           '(1. 7. 288. 151. -3. 3. -3. 3.))

(DECLARE (SPECIAL :DRAWTURTLE :ERASETURTLE)) 

;;THESE VARIABLES ALLOW USER TO SUBSTITUTE PROCEDURES FOR DRAWING AND ERASING THE
;;TURTLE MARKER.  NIL MEANS USE STANDARD SYSTEM ONES.

(DEFINE TRIANGLETURTLE NIL
        (LET ([BW (OLD-DRAWMODE (DRAWMODE XOR))])
             (STANDARD-TRIANGLE)
             (STANDARD-PEN)
             [BW (DRAWMODE OLD-DRAWMODE)]))


(DEFUN DRAW-PEN NIL 
       (COND ((NOT :SEETURTLE))
             ((AND :CLIP (PLUSP (CLIP-VISIBILITY :XCOR :YCOR))))
             (:DRAWTURTLE (INVOKE-USER-DRAW-TURTLE))
	     ((LET ([BW (OLD-DRAWMODE (DRAWMODE XOR))])
                   [COLOR (SELECT-COLOR :PENNUMBER)]
		   (STANDARD-PEN)
                   [COLOR (RESELECT-COLOR)]
		   [BW (DRAWMODE OLD-DRAWMODE)])))) 

(DEFUN ERASE-PEN NIL 
       (COND ((NOT :SEETURTLE))
             ((AND :CLIP (PLUSP (CLIP-VISIBILITY :XCOR :YCOR))))
             (:ERASETURTLE (INVOKE-USER-ERASE-TURTLE))
	     ((LET ([BW (OLD-DRAWMODE (DRAWMODE XOR))])
                   [COLOR (SELECT-COLOR :ERASERNUMBER)]
		   (STANDARD-PEN)
                   [COLOR (RESELECT-COLOR)]
		   [BW (DRAWMODE OLD-DRAWMODE)])))) 

(DEFUN STANDARD-PEN NIL 
       (COND (:PENSTATE (TURTLE-WINDOW PEN-WINDOW))
	     (:ERASERSTATE (TURTLE-WINDOW ERASER-WINDOW))
	     (:XORSTATE (TURTLE-WINDOW XOR-WINDOW)))) 

(DECLARE (FIXNUM TV-XCOR TV-YCOR)
	 (NOTYPE (DISPLAYWINDOW-STORE NOTYPE NOTYPE FIXNUM FIXNUM FIXNUM FIXNUM))) 

(DEFUN TURTLE-WINDOW (MARKER-WINDOW) 
       (LET ((TV-XCOR (TV-X :XCOR)) (TV-YCOR (TV-Y :YCOR)))
	    (DISPLAYWINDOW-STORE PEN-INFO
                                 MARKER-WINDOW
				 (- TV-YCOR 3.)
				 (+ TV-YCOR 3.)
				 (- TV-XCOR 3.)
				 (+ TV-XCOR 3.)))) 

(DEFUN INVOKE-USER-DRAW-TURTLE NIL 
       (LET ((:XCOR :XCOR)
	     (:YCOR :YCOR)
	     (:HEADING :HEADING)
	     (SINE-HEADING SINE-HEADING)
	     (COSINE-HEADING COSINE-HEADING)
	     (:SEETURTLE NIL)
	     (:PENSTATE :PENSTATE)
	     (:ERASERSTATE :ERASERSTATE)
	     (:XORSTATE :XORSTATE)
             (:DRAWSTATE :DRAWSTATE))
	    (EVAL :DRAWTURTLE))
       ;;User function may screw up drawmode, color.
       [COLOR (RESELECT-COLOR)]
       [BW (DRAWMODE (COND (:ERASERSTATE ANDC) (:XORSTATE XOR) (IOR)))]) 

(DEFUN INVOKE-USER-ERASE-TURTLE NIL 
       (LET ((:XCOR :XCOR)
	     (:YCOR :YCOR)
	     (:HEADING :HEADING)
	     (SINE-HEADING SINE-HEADING)
	     (COSINE-HEADING COSINE-HEADING)
	     (:SEETURTLE NIL)
	     (:PENSTATE :PENSTATE)
	     (:ERASERSTATE :ERASERSTATE)
	     (:XORSTATE :XORSTATE)
             (:DRAWSTATE :DRAWSTATE))
	    (EVAL :ERASETURTLE))
       [COLOR (RESELECT-COLOR)]
       [BW (DRAWMODE (COND (:ERASERSTATE ANDC) (:XORSTATE XOR) (IOR)))]) 

(DEFUN DRAW-TRIANGLE NIL 
       (COND ((NOT :SEETURTLE))
             ((AND :CLIP (PLUSP (CLIP-VISIBILITY :XCOR :YCOR))))
             (:DRAWTURTLE (INVOKE-USER-DRAW-TURTLE))
	     ((LET ([BW (OLD-DRAWMODE (DRAWMODE XOR))])
                   [COLOR (SELECT-COLOR :PENNUMBER)]
		   (STANDARD-TRIANGLE)
                   [COLOR (RESELECT-COLOR)]
		   [BW (DRAWMODE OLD-DRAWMODE)])))) 

(DEFUN ERASE-TRIANGLE NIL 
       (COND ((NOT :SEETURTLE))
             ((AND :CLIP (PLUSP (CLIP-VISIBILITY :XCOR :YCOR))))
             (:ERASETURTLE (INVOKE-USER-ERASE-TURTLE))
	     ((LET ([BW (OLD-DRAWMODE (DRAWMODE XOR))])
                   [COLOR (SELECT-COLOR :ERASERNUMBER)]
		   (STANDARD-TRIANGLE)
                   [COLOR (RESELECT-COLOR)]
		   [BW (DRAWMODE OLD-DRAWMODE)])))) 

(DEFUN STANDARD-TRIANGLE NIL 
       (LET ((TURTLE-FRONT-RADIUS-X (*$ TURTLE-FRONT-RADIUS SINE-HEADING))
	     (TURTLE-FRONT-RADIUS-Y (*$ TURTLE-FRONT-RADIUS COSINE-HEADING))
	     (TURTLE-RIGHT-RADIUS-X (*$ TURTLE-SIDE-RADIUS
					(+$ (*$ SINE-HEADING COSINE-120)
					    (*$ SINE-120 COSINE-HEADING))))
	     (TURTLE-RIGHT-RADIUS-Y (*$ TURTLE-SIDE-RADIUS
					(-$ (*$ COSINE-HEADING COSINE-120)
					    (*$ SINE-HEADING SINE-120))))
	     (TURTLE-LEFT-RADIUS-X (*$ TURTLE-SIDE-RADIUS
				       (+$ (*$ SINE-HEADING COSINE-240)
					   (*$ SINE-240 COSINE-HEADING))))
	     (TURTLE-LEFT-RADIUS-Y (*$ TURTLE-SIDE-RADIUS
				       (-$ (*$ COSINE-HEADING COSINE-240)
					   (*$ SINE-HEADING SINE-240))))
             (HORIZONTAL (EXPR-FUNCTION HORIZONTAL-LINE))
             (VERTICAL (EXPR-FUNCTION VERTICAL-LINE)))
	    (LET ((TURTLE-FRONT-X (+$ :XCOR TURTLE-FRONT-RADIUS-X))
		  (TURTLE-FRONT-Y (+$ :YCOR TURTLE-FRONT-RADIUS-Y))
		  (TURTLE-LEFT-X (+$ :XCOR TURTLE-LEFT-RADIUS-X))
		  (TURTLE-LEFT-Y (+$ :YCOR TURTLE-LEFT-RADIUS-Y))
		  (TURTLE-RIGHT-X (+$ :XCOR TURTLE-RIGHT-RADIUS-X))
		  (TURTLE-RIGHT-Y (+$ :YCOR TURTLE-RIGHT-RADIUS-Y))
                  (:WRAP T))
		 (WRAP-VECTOR :XCOR :YCOR TURTLE-FRONT-X TURTLE-FRONT-Y)
		 (WRAP-VECTOR TURTLE-FRONT-X
			      TURTLE-FRONT-Y
			      TURTLE-LEFT-X
			      TURTLE-LEFT-Y)
		 (WRAP-VECTOR TURTLE-LEFT-X
			      TURTLE-LEFT-Y
			      TURTLE-RIGHT-X
			      TURTLE-RIGHT-Y)
		 (WRAP-VECTOR TURTLE-RIGHT-X
			      TURTLE-RIGHT-Y
			      TURTLE-FRONT-X
			      TURTLE-FRONT-Y)))) 




(DEFUN DRAW-TURTLE NIL
       (COND ((NOT :SEETURTLE))
             ;;Turtle not visible, or clipped out of boundary, return.
             ((AND :CLIP (PLUSP (CLIP-VISIBILITY :XCOR :YCOR))))
             ;;If user set up a turtle display form, use it, else default.
             (:DRAWTURTLE (INVOKE-USER-DRAW-TURTLE))
             (T [COLOR (SELECT-COLOR :PENNUMBER)]
                (TRIANGLETURTLE)
                [COLOR (RESELECT-COLOR)])))

(DEFUN ERASE-TURTLE NIL
       (COND ((NOT :SEETURTLE))
             ;;Turtle not visible, or clipped out of boundary, return.
             ((AND :CLIP (PLUSP (CLIP-VISIBILITY :XCOR :YCOR))))
             ;;If user set up a turtle display form, use it, else default.
             (:ERASETURTLE (INVOKE-USER-ERASE-TURTLE))
             (T [COLOR (SELECT-COLOR :ERASERNUMBER)]
                (TRIANGLETURTLE)
                [COLOR (RESELECT-COLOR)])))



(DECLARE (SPECIAL :DRAWTURTLE :ERASETURTLE)) 

(DEFINE SHOWTURTLE (ABB ST) NIL 
	(COND (:SEETURTLE) ((SETQ :SEETURTLE T) (DRAW-TURTLE)))
	NO-VALUE) 

(DEFINE HIDETURTLE (ABB HT) NIL (COND (:SEETURTLE (ERASE-TURTLE)))
				(SETQ :SEETURTLE NIL)
				NO-VALUE) 

(DEFUN DRAW-TURTLES NIL 
       (DRAW-TURTLE)
       (LET ((OLD-TURTLE :TURTLE))
            (MAPC '(LAMBDA (OTHER-TURTLE)
                           (COND ((EQ OTHER-TURTLE OLD-TURTLE))
                                 (T (USETURTLE OTHER-TURTLE) (DRAW-TURTLE))))
                  :TURTLES)
            (COND ((EQ :TURTLE OLD-TURTLE))
                  ((USETURTLE OLD-TURTLE)))))

(DEFUN ERASE-TURTLES NIL 
       (ERASE-TURTLE)
       (LET ((OLD-TURTLE :TURTLE))
            (MAPC '(LAMBDA (OTHER-TURTLE)
                           (COND ((EQ OTHER-TURTLE OLD-TURTLE))
                                 (T (USETURTLE OTHER-TURTLE) (ERASE-TURTLE))))
                  :TURTLES)
            (COND ((EQ :TURTLE OLD-TURTLE))
                  ((USETURTLE OLD-TURTLE)))))

(DEFINE MAKETURTLE (PARSE 2.) FEXPR (MAKETURTLE-ARGS)
 (LET ((DRAW-FORM (CAR MAKETURTLE-ARGS)) (ERASE-FORM (CADR MAKETURTLE-ARGS)))
      (ERASE-TURTLE)
      (SETQ :DRAWTURTLE DRAW-FORM :ERASETURTLE ERASE-FORM)
      (DRAW-TURTLE))
 NO-VALUE) 

;;*PAGE

;;;

(COMMENT MULTIPLE TURTLES) 

;;;

(DECLARE (SPECIAL :TURTLE :TURTLES TURTLE-PROPERTIES)
	 (FIXNUM TURTLE-PROPERTIES PROPERTY-INDEX)) 

;;SWITCHES BACK AND FORTH BETWEEN MULTIPLE TURTLES.  SETS GLOBAL VARIABLES ACCORDING
;;TO SAVED PROPERTIES ON NEW TURTLE,

(DEFINE USETURTLE (ABB UT) (TURTLE-NAME) 
	(OR (GET TURTLE-NAME 'TURTLE)
	    (SETQ TURTLE-NAME 
                  (ERRBREAK 'USETURTLE (LIST TURTLE-NAME '"IS NOT A TURTLE"))))
	(DO ((PROPERTY-INDEX 0. (1+ PROPERTY-INDEX))
	     (OLD-TURTLE (GET :TURTLE 'TURTLE))
	     (NEW-TURTLE (GET TURTLE-NAME 'TURTLE)))
	    ((= PROPERTY-INDEX TURTLE-PROPERTIES)
	     [BW (DRAWMODE (COND (:ERASERSTATE ANDC) (:XORSTATE XOR) (IOR)))]
             [COLOR (RESELECT-COLOR)]
	     (TV-SETHOME (ARRAYCALL NIL NEW-TURTLE 0.)
			 (ARRAYCALL NIL NEW-TURTLE 1.)))
	    (STORE (ARRAYCALL T OLD-TURTLE PROPERTY-INDEX)
		   (SYMEVAL (TURTLE-PROPERTY PROPERTY-INDEX)))
	    (SET (TURTLE-PROPERTY PROPERTY-INDEX)
		 (ARRAYCALL T NEW-TURTLE PROPERTY-INDEX)))
	(SETQ :TURTLE TURTLE-NAME)) 

;;HATCH CREATES A NEW TURTLE WITH THE SPECIFIED NAME.  ALL PROPERTIES OF THAT
;;PARTICULAR TURTLE ARE AS INITIALLY WHEN A STARTDISPLAY IS DONE.

(DEFINE HATCH (TURTLE-NAME) 
	(PUTPROP TURTLE-NAME
                 (FILLARRAY (*ARRAY NIL T TURTLE-PROPERTIES) 'HATCH-PROPERTY)
                 'TURTLE)
	(OR (MEMQ TURTLE-NAME :TURTLES) (PUSH TURTLE-NAME :TURTLES))
	(USETURTLE TURTLE-NAME)
	(SHOWTURTLE)
	TURTLE-NAME)

(DEFINE ERASETURTLE (TURTLE-NAME)
       (OR (GET TURTLE-NAME 'TURTLE)
           (ERRBREAK 'ERASETURTLE (LIST TURTLE-NAME '"IS NOT A TURTLE")))
       (AND (EQ :TURTLE TURTLE-NAME)
            (ERRBREAK 'ERASETURTLE '"DON'T ERASE THE CURRENT TURTLE!"))
       (SETQ :TURTLES (DELQ TURTLE-NAME :TURTLES))
       (LET ((OLD-TURTLE :TURTLE)) 
            (USETURTLE TURTLE-NAME) 
            (ERASE-TURTLE) 
            (USETURTLE OLD-TURTLE))
       (*REARRAY (GET TURTLE-NAME 'TURTLE))
       (REMPROP TURTLE-NAME 'TURTLE)
       TURTLE-NAME) 

;;*PAGE

;;;

(COMMENT BASIC TURTLE COMMANDS) 

;;;
;;;
;;THE BASIC TURTLE COMMANDS.  MANY COMMANDS WILL COME IN TWO FLAVORS.  FOR THE USER,
;;A KIND WHICH WILL ACCEPT FIXNUMS OR FLONUMS, PROVIDE ARGUMENT TYPE CHECKING, ETC.,
;;AND A SECOND INTERNAL VERSION EXPECTING FLONUMS ONLY OPTIMIZED FOR NCOMPL'ED
;;EFFICIENCY.  SUCH FLONUM-ONLY FUNCTIONS WILL HAVE THEIR NAMES SUFFIXED BY "$"	,
;;FOLLOWING THE LISP CONVENTION.

(DECLARE (FLONUM NEW-X$ NEW-Y$) (NOTYPE (SETXY$ FLONUM FLONUM))) 

(DEFUN SETXY$ (NEW-X$ NEW-Y$) 
       (COND (:WRAP (WRAP-TURTLE-VECTOR :XCOR :YCOR NEW-X$ NEW-Y$))
             (:CLIP (CLIP-TURTLE-VECTOR :XCOR :YCOR NEW-X$ NEW-Y$))
             ((BOUNDED-TURTLE-VECTOR :XCOR :YCOR NEW-X$ NEW-Y$)))) 

(DEFINE SETXY (NEW-X NEW-Y) (SETXY$ (FLOAT NEW-X) (FLOAT NEW-Y)) NO-VALUE) 

(DECLARE (FLONUM (FORWARD$ FLONUM) STEPS$)) 

(DEFUN FORWARD$ (STEPS$) 
       (SETXY$ (+$ :XCOR (*$ STEPS$ SINE-HEADING))
	       (+$ :YCOR (*$ STEPS$ COSINE-HEADING)))) 

(DEFINE FORWARD (ABB FD) (STEPS) (FORWARD$ (FLOAT STEPS)) NO-VALUE) 

(DEFINE BACK (ABB BK) (STEPS) (FORWARD$ (-$ (FLOAT STEPS))) NO-VALUE) 

(DECLARE (FLONUM NEW-HEADING$ NEW-HEADING-RADIANS) (NOTYPE (SETHEAD$ FLONUM))) 

(DEFUN SETHEAD$ (NEW-HEADING$) 
       (ERASE-TRIANGLE)
       (LET ((NEW-HEADING-RADIANS (*$ NEW-HEADING$ PI-OVER-180)))
	    (SETQ :HEADING NEW-HEADING$ 
		  SINE-HEADING (SIN NEW-HEADING-RADIANS) 
		  COSINE-HEADING (COS NEW-HEADING-RADIANS))
	    (DRAW-TRIANGLE))) 

(DEFINE SETHEAD (ABB SH SETHEADING) (NEW-HEADING) (SETHEAD$ (FLOAT NEW-HEADING))
						  NO-VALUE) 

(DECLARE (FLONUM (RIGHT$ FLONUM) TURNS$)) 

(DEFUN RIGHT$ (TURNS$) (SETHEAD$ (+$ :HEADING TURNS$))) 

(DEFINE RIGHT (ABB RT) (TURNS) (RIGHT$ (FLOAT TURNS)) NO-VALUE) 

(DEFINE LEFT (ABB LT) (TURNS) (RIGHT$ (-$ (FLOAT TURNS))) NO-VALUE) 

(DEFINE PENUP (ABB PU) NIL (AND :PENSTATE (ERASE-PEN))
			   (SETQ :PENSTATE NIL :DRAWSTATE NIL)
			   (AND :DRAWTURTLE (DRAW-TURTLE))
			   NO-VALUE) 

(DEFINE PENDOWN (ABB PD) NIL (ERASE-PEN)
			     [BW (DRAWMODE IOR)]
                             [COLOR (SELECT-COLOR :PENNUMBER)]
			     (SETQ :PENSTATE T 
                                   :ERASERSTATE NIL 
                                   :XORSTATE NIL 
                                   :DRAWSTATE 'PEN)
			     (DRAW-PEN)
			     NO-VALUE) 

;;PENP FOR COMPATIBLILITY WITH 340/GT40 TURTLE.

(DEFINE PENP NIL :PENSTATE) 

(DEFINE ERASERUP (ABB ERU) NIL (AND :ERASERSTATE (ERASE-PEN))
			       (SETQ :ERASERSTATE NIL :DRAWSTATE NIL)
                               (AND :DRAWTURTLE (DRAW-TURTLE))
                               (DRAWMODE IOR)
			       NO-VALUE) 

(DEFINE ERASERDOWN (ABB ERD) NIL (ERASE-PEN)
				 [BW (DRAWMODE ANDC)]
                                 [COLOR (SELECT-COLOR :ERASERNUMBER)]
				 (SETQ :ERASERSTATE T 
                                       :PENSTATE NIL 
                                       :XORSTATE NIL
                                       :DRAWSTATE 'ERASER)
				 (DRAW-PEN)
				 NO-VALUE) 

;;THE USER HAS THE OPTION OF USING XOR MODE IN A MANNER SIMILAR TO THE "PEN" AND THE
;;"ERASER".

[BW
(DEFINE XORDOWN (ABB XD) NIL (ERASE-PEN)
			     (DRAWMODE XOR)
			     (SETQ :XORSTATE T 
                                   :PENSTATE NIL 
                                   :ERASERSTATE NIL 
                                   :DRAWSTATE 'XOR)
			     (DRAW-PEN)
			     NO-VALUE) 

(DEFINE XORUP (ABB XU) NIL (AND :XORSTATE (ERASE-PEN))
			   (SETQ :XORSTATE NIL :DRAWSTATE NIL)
			   (AND :DRAWTURTLE (DRAW-TURTLE))
                           (DRAWMODE IOR)
			   NO-VALUE)
]


[COLOR (DEFINE XORUP NIL (NOT-IMPLEMENTED-IN-COLOR '(XORUP)))
       (DEFINE XORDOWN NIL (NOT-IMPLEMENTED-IN-COLOR '(XORDOWN)))] 

(DEFINE HOME (ABB H) NIL (ERASE-TURTLES)
			 ;;SEETURTLE HACKING HANDLED EXPLICITY SO THAT TURTLE
			 ;;APPEARANCE AND DISAPPEARANCE DOES NOT OCCUR TWICE, ONCE
			 ;;WITH SETXY, ONCE WITH SETHEAD.
			 (LET ((:SEETURTLE NIL)) (SETXY$ 0.0 0.0) (SETHEAD$ 0.0))
			 (DRAW-TURTLES)
			 NO-VALUE) 

(DEFINE SETTURTLE (ABB SETT) (P) 
				 ;;(SETTURTLE '(100 100 90)) SETS THE STATE OF THE
				 ;;TURTLE TO THE POSITION '(100 100) AND HEADING 90. 
				 ;;THE HEADING IS OPTIONAL.  (SETTURTLE (HERE)) IS A
				 ;;NO-OP.
				 (SETXY$ (FLOAT (CAR P)) (FLOAT (CADR P)))
				 (AND (CDDR P) (SETHEAD$ (FLOAT (CADDR P))))
				 NO-VALUE) 

(DEFINE SETX (X) (SETXY$ (FLOAT X) :YCOR) NO-VALUE) 

(DEFINE SETY (Y) (SETXY$ :XCOR (FLOAT Y)) NO-VALUE) 

(DECLARE (FIXNUM (XCOR) (YCOR) (HEADING) SMASHED-HEADING))

(DEFINE XCOR NIL
        (ROUND (COND ((OR :WRAP :CLIP) (TURTLE-X (TV-X :XCOR))) (:XCOR))))

(DEFINE YCOR NIL
        (ROUND (COND ((OR :WRAP :CLIP) (TURTLE-Y (TV-Y :YCOR))) (:YCOR))))

(DEFINE HEADING NIL 
	(LET ((SMASHED-HEADING (\ (ROUND :HEADING) 360.))) 
             (OR (AND (MINUSP SMASHED-HEADING) (+ 360. SMASHED-HEADING)) 
                 SMASHED-HEADING)))

(DEFINE HERE NIL (LIST (XCOR) (YCOR) (HEADING))) 

(DEFINE DELX (X) (SETXY$ (+$ (FLOAT X) :XCOR) :YCOR) NO-VALUE) 

(DEFINE DELY (Y) (SETXY$ :XCOR (+$ :YCOR (FLOAT Y))) NO-VALUE) 

(DEFINE DELXY (X Y) (SETXY$ (+$ :XCOR (FLOAT X)) (+$ :YCOR (FLOAT Y))) NO-VALUE) 

;;MARK NEEDS A CONVENIENT WAY TO ERASE TEXT FROM SCREEN.  PRINTING OF TEXT DOESN'T
;;SEEM TO BE AFFECTED BY DRAWMODE.

[BW
(DEFINE MARK (TEXT) (LET ((WHERE-I-WAS (ECHO-CURSORPOS))
                          ;;(STATUS TERPRI) MUST BE T FOR THIS TO WORK CORRECTLY.
                          ;;SO NO STRAY CR'S IN TEXT PRINTING.
                          (STATUS-TERPRI (STATUS TERPRI)))
                         (OR STATUS-TERPRI (SSTATUS TERPRI T))
			 (ERASE-TURTLES)
			 (OUTPUT-TO-MAIN-SCREEN)
			 (CURSORPOS (// (TV-Y :YCOR) 12.) (// (TV-X :XCOR) 6.))
			 ;;CLOSEST CURSOR POSITION TO TURTLE'S LOCATION ON THE
			 ;;SCREEN.
			 (TYPE TEXT)
			 (OUTPUT-TO-ECHO-AREA)
			 (CURSORPOS (CAR WHERE-I-WAS) (CDR WHERE-I-WAS))
			 (DRAW-TURTLES)
                         (OR STATUS-TERPRI (SSTATUS TERPRI NIL))
		    TEXT))]


[COLOR (DEFINE MARK (TEXT) (NOT-IMPLEMENTED-IN-COLOR (LIST 'MARK TEXT)))] 

;;*PAGE

;;;

(COMMENT POINTS AND CIRCLES) 

[BW
;;;
;;SET OR READ ANY POINT IN TV BUFFER.

(DECLARE (NOTYPE (WRITE-TV-POINT FIXNUM FIXNUM))) 

(DEFUN WRITE-TV-POINT (POINT-X POINT-Y) 
       (STORE (TV (+ (* 18. POINT-Y) (LSH POINT-X -5.))) 
              (POINT-MASK (BITWISE-AND POINT-X 31.)))
       T) 

(DECLARE (NOTYPE (READ-TV-POINT FIXNUM FIXNUM))) 

(DEFUN READ-TV-POINT (POINT-X POINT-Y) 
       (NOT (ZEROP (BITWISE-AND (POINT-MASK (BITWISE-AND POINT-X 31.)) 
                                (TV (+ (* 18. POINT-Y) (LSH POINT-X -5.)))))))

;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
] 


[COLOR

(DECLARE (FIXNUM (READ-TV-POINT-NUMBER FIXNUM FIXNUM) TV-BUFFER-INDEX
		 SIGNIFICANT-BIT POINT-TOTAL ELEVEN-WORD-X ELEVEN-MASK WRITE-WORD)
	 (NOTYPE (READ-TV-POINT FIXNUM FIXNUM)
		 (READ-TV-POINT-SINGLE FIXNUM FIXNUM)
		 (WRITE-TV-POINT FIXNUM FIXNUM))) 

;;Note: COLOR WRITE MODE must be turned OFF to read.

(DEFUN READ-TV-POINT (POINT-X POINT-Y) 
       ;;Returns atom describing color of point.  READ-TV-POINT-NUMBER returns the
       ;;bit combination corresponding to the point, indexes into palette.
       (PALETTE (READ-TV-POINT-NUMBER POINT-X POINT-Y))) 

(DEFUN READ-TV-POINT-NUMBER (POINT-X POINT-Y) 
       (DO ((TV-BUFFER-INDEX 0. (1+ TV-BUFFER-INDEX))
	    (SIGNIFICANT-BIT 1. (LSH SIGNIFICANT-BIT 1.))
	    (POINT-TOTAL 0.))
	   ((= TV-BUFFER-INDEX COLOR-BITS) POINT-TOTAL)
	   (SELECT-TV-BUFFER TV-BUFFER-INDEX)
	   (OR (READ-TV-POINT-SINGLE POINT-X POINT-Y)
               ;;Bits are inverted in TV buffer!
	       (INCREMENT POINT-TOTAL SIGNIFICANT-BIT)))) 

(DEFUN READ-TV-POINT-SINGLE (POINT-X POINT-Y) 
       ;;Ordinary point read function on a single TV buffer.
       (NOT (ZEROP (BITWISE-AND (POINT-MASK (BITWISE-AND POINT-X 31.)) 
                                (TV (+ (* 18. POINT-Y) (LSH POINT-X -5.))))))) 

(DEFUN WRITE-TV-POINT (POINT-X POINT-Y) 
       (LET ((ELEVEN-WORD-X (LSH POINT-X -4.))
	     ;;ELEVEN-WORD-X address in 16.  bit words.  Into MASK register is
	     ;;written word with only the relevant bit off.
	     (ELEVEN-MASK (ELEVEN-NOT-POINT-MASK (BITWISE-AND POINT-X 15.))))
	    (WRITE-TV-MASK ELEVEN-MASK)
	    ;;If eleven address is odd, inhibit writing of low order word. If eleven
	    ;;address even, inhibit high order word.  This conveyed by third and
	    ;;fourth bits from right in word written across ten to eleven interface.
	    (LET ((WRITE-WORD (COND ((ODDP ELEVEN-WORD-X) -8.) (-12.))))
		 ;;32 bit words twice as big as 16 bit words.
		 (STORE (TV (+ (* POINT-Y 18.) (LSH ELEVEN-WORD-X -1.))) WRITE-WORD)))
       T) 

;;Versions which use memory address & data registers to read & write points.
;;Probably losing from an efficiency standpoint.
;;; (DECLARE (FIXNUM (READ-TV-POINT-REGISTERS FIXNUM FIXNUM))
;;;          (NOTYPE (WRITE-TV-POINT-REGISTERS FIXNUM FIXNUM)))
;;; 
;;; (DEFUN READ-TV-POINT-REGISTERS (POINT-X POINT-Y)
;;;        (WRITE-TV-ADDRESS (TV-ADDRESS POINT-Y (// POINT-X 16.)))
;;;        (DO ((TV-BUFFER-INDEX 0 (1+ TV-BUFFER-INDEX))
;;;             (SIGNIFICANT-BIT 1. (LSH SIGNIFICANT-BIT 1.))
;;;             (POINT-TOTAL 0.)
;;;             (POINT-BIT-MASK (LSH 1. (- 15. (\ POINT-X 16.)))))
;;;            ((= TV-BUFFER-INDEX COLOR-BITS) 
;;;             ;;Sigh, number coming back here must be complemented because Ron
;;;             ;;decided to save a few inverters....
;;;             (BITWISE-AND 15. (BITWISE-NOT POINT-TOTAL)))
;;;            (SELECT-TV-BUFFER TV-BUFFER-INDEX)
;;;            (OR (ZEROP (BITWISE-AND (READ-TV-DATA) POINT-BIT-MASK)) 
;;;                (INCREMENT POINT-TOTAL SIGNIFICANT-BIT))))
;;; 
;;; (DEFUN WRITE-TV-POINT-REGISTERS (POINT-X POINT-Y)
;;;        (LET ((WORD-X (// POINT-X 16.)) (BIT-X (\ POINT-X 16.)))
;;;             (LET ((BIT-MASK (LSH 1. (- 15. BIT-X))))
;;;                  (WRITE-TV-MASK (BITWISE-NOT BIT-MASK))
;;;                  (WRITE-TV-WORD (TV-ADDRESS POINT-Y WORD-X) BIT-MASK)))
;;;        T)
;;;

;;;END OF COLOR CONDITIONAL SECTION.
]


;;POINT FUNCTION SLIGHTLY DIFFERENT THAN FOR 340/GT40 TURTLE PACKAGE. 
;;;
;;; ?POINT -- [NO ARGS] TURNS THE CURRENT TURTLE LOCATION ON.
;;; ?POINT <T OR NIL> -- TURNS THE CURRENT LOCATION OF THE TURTLE ON OR OFF.
;;; ?POINT <X> <Y> -- TURNS THE POINT AT (<X>, <Y>) ON
;;; ?POINT <X> <Y> <T OR NIL> -- TURNS THE POINT SPECIFIED ON OR OFF.
;;;

(DECLARE (FLONUM X-COR Y-COR)) 

[BW

(DEFINE POINT (PARSE L) ARGS 
	(LET ((X-COR :XCOR) (Y-COR :YCOR) (DARK-OR-LIGHT :DRAWMODE))
	     (COND ((ZEROP ARGS))
		   ((= ARGS 1.) (SETQ DARK-OR-LIGHT (COND ((ARG 1.) IOR) (ANDC))))
		   ((= ARGS 2.)
		    (SETQ X-COR (FLOAT (ARG 1.)) 
			  Y-COR (FLOAT (ARG 2.))))
		   ((= ARGS 3.)
		    (SETQ X-COR (FLOAT (ARG 1.)) 
			  Y-COR (FLOAT (ARG 2.)) 
			  DARK-OR-LIGHT (COND ((ARG 3.) IOR) (ANDC)))))
             (ERASE-TURTLES)
	     (LET ((OLD-DRAWMODE (DRAWMODE DARK-OR-LIGHT)))
		  (WRITE-TV-POINT (TV-X X-COR) (TV-Y Y-COR))
		  (DRAWMODE OLD-DRAWMODE))
             (DRAW-TURTLES))
	NO-VALUE) 

(DEFINE POINTSTATE (ABB PS)  ARGS 
	(LET ((X-COR :XCOR) (Y-COR :YCOR))
	     (ERASE-TURTLES)
	     (COND ((ZEROP ARGS))
		   ((= ARGS 1.)
		    (SETQ X-COR (FLOAT (CAR (ARG 1.))) 
			  Y-COR (FLOAT (CADR (ARG 1.)))))
		   ((= ARGS 2.)
		    (SETQ X-COR (FLOAT (ARG 1.)) Y-COR (FLOAT (ARG 2.)))))
	     (PROG1 (READ-TV-POINT (TV-X X-COR) (TV-Y Y-COR))
		    (DRAW-TURTLES))))

;;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
] 


[COLOR 

(DEFINE POINT (PARSE L) ARGS 
	(LET ((X-COR :XCOR) (Y-COR :YCOR))
             (ERASE-TURTLES)
	     (COND ((ZEROP ARGS))
		   ((= ARGS 1.)
		    (SELECT-COLOR (COND ((ARG 1.) :PENNUMBER) (:ERASERNUMBER))))
		   ((= ARGS 2.) (SETQ X-COR (FLOAT (ARG 1.)) Y-COR (FLOAT (ARG 2.))))
		   ((= ARGS 3.)
		    (SETQ X-COR (FLOAT (ARG 1.)) Y-COR (FLOAT (ARG 2.)))
		    (SELECT-COLOR (COND ((ARG 1.) :PENNUMBER) (:ERASERNUMBER)))))
	     (WRITE-TV-POINT (TV-X X-COR) (TV-Y Y-COR))
             (RESELECT-COLOR)
             (DRAW-TURTLES))
	NO-VALUE) 

(DEFINE POINTSTATE (ABB PS) ARGS 
	(LET ((X-COR :XCOR) (Y-COR :YCOR))
	     (ERASE-TURTLES)
	     (COND ((ZEROP ARGS))
		   ((= ARGS 1.)
		    (SETQ X-COR (FLOAT (CAR (ARG 1.))) 
			  Y-COR (FLOAT (CADR (ARG 1.)))))
		   ((= ARGS 2.)
		    (SETQ X-COR (FLOAT (ARG 1.)) Y-COR (FLOAT (ARG 2.)))))
	     (NO-COLOR-WRITE)
	     (PROG1 (READ-TV-POINT (TV-X X-COR) (TV-Y Y-COR))
		    (COLOR-WRITE)
		    (DRAW-TURTLES))))

;;;END OF COLOR CONDITIONAL SECTION.
]


 

(DECLARE (SPECIAL :POLYGON :PI)
	 (NOTYPE (ARC$ FLONUM FLONUM))
	 (FLONUM :POLYGON UNIT-CIRCLE-SIDE HALF-TURN SIDES SIDE RADIUS$ DEGREES$
		 OLD-XCOR OLD-YCOR OLD-HEADING)) 

(DEFUN ARC$ (RADIUS$ DEGREES$) 
       ;;ONE OF THESE DAYS, INCLUDE A MORE EFFICIENT ARC DRAWING PROCEDURE.
       (ERASE-TURTLES)
       ;;Turtle hidden during execution of ARC.
       (LET ((UNIT-CIRCLE-SIDE (*$ 2.0 (SIN (//$ :PI :POLYGON))))
	     (HALF-TURN (//$ 360.0 :POLYGON 2.0)))
	    (LET ((SIDE (*$ RADIUS$ UNIT-CIRCLE-SIDE))
		  (OLD-XCOR :XCOR)
		  (OLD-YCOR :YCOR)
		  (OLD-HEADING :HEADING)
		  (SINE-HEADING SINE-HEADING)
		  (COSINE-HEADING COSINE-HEADING)
		  (:DRAWSTATE NIL)
		  (:SEETURTLE NIL))
		 (FORWARD$ RADIUS$)
		 (RIGHT$ 90.0)
		 (DO ((SIDES (//$ DEGREES$ HALF-TURN 2.0) (1-$ SIDES)) 
                      (:DRAWSTATE T))
		     ((< SIDES 1.0) (RIGHT$ HALF-TURN) (FORWARD$ (*$ SIDES SIDE)))
		     (RIGHT$ HALF-TURN)
		     (FORWARD$ SIDE)
		     (RIGHT$ HALF-TURN))
		 (SETXY$ OLD-XCOR OLD-YCOR)
		 (SETHEAD$ OLD-HEADING)))
       (DRAW-TURTLES))) 

(DEFINE ARC (RADIUS DEGREES) (ARC$ (FLOAT RADIUS) (FLOAT DEGREES)) NO-VALUE) 

(DEFINE CIRCLE (RADIUS) (ARC$ (FLOAT RADIUS) 360.0) NO-VALUE) 

;;*PAGE

;;;

(COMMENT GLOBAL NAVIGATION) 

;;;

(DECLARE (*LEXPR BEARING TOWARDS RANGE)
	 (*EXPR \$)
	 (FLONUM X-COR Y-COR DELTA-X DELTA-Y ALLEGED-BEARING ALLEGED-TOWARDS
		 ALLEGED-RANGE (\$ FLONUM FLONUM))) 

(DEFINE BEARING ARGS 
	(LET ((X-COR 0.0)
	      (Y-COR 0.0)
	      (DELTA-X 0.0)
	      (DELTA-Y 0.0)
	      (ALLEGED-BEARING 0.0)
	      (RETURN-FIXNUM))
	     (COND ((= ARGS 1.)
		    (SETQ X-COR (FLOAT (CAR (ARG 1.))) 
			  Y-COR (FLOAT (CADR (ARG 1.))) 
			  RETURN-FIXNUM (AND (FIXP (CAR (ARG 1.)))
					     (FIXP (CADR (ARG 1.))))))
		   ((= ARGS 2.)
		    (SETQ X-COR (FLOAT (ARG 1.)) 
			  Y-COR (FLOAT (ARG 2.)) 
			  RETURN-FIXNUM (AND (FIXP (ARG 1.)) (FIXP (ARG 2.)))))
		   ((ERRBREAK 'BEARING
			      '"WRONG NUMBER OF INPUTS")))
	     (SETQ DELTA-X (-$ X-COR :XCOR) DELTA-Y (-$ Y-COR :YCOR))
	     (COND ((AND (< (ABS DELTA-X) FLOATING-POINT-TOLERANCE)
			 (< (ABS DELTA-Y) FLOATING-POINT-TOLERANCE)))
		   ((MINUSP (SETQ ALLEGED-BEARING
				  (QUOTIENT (ATAN DELTA-X DELTA-Y) PI-OVER-180)))
		    (SETQ ALLEGED-BEARING (-$ 360.0 ALLEGED-BEARING))))
	     (COND (RETURN-FIXNUM (\ (ROUND ALLEGED-BEARING) 360.))
		   ((\$ ALLEGED-BEARING 360.0))))) 

(DEFINE TOWARDS ARGS 
	;;DIRECTION OF A POINT RELATIVE TO TURTLE HEADING.  +0-360 DEGREES.  POINT =
	;;(X Y).
	(LET ((X-COR 0.0) (Y-COR 0.0) (RETURN-FIXNUM))
	     (COND ((= ARGS 1.)
		    (SETQ X-COR (FLOAT (CAR (ARG 1.))) 
			  Y-COR (FLOAT (CADR (ARG 1.))) 
			  RETURN-FIXNUM (AND (FIXP (CAR (ARG 1.)))
					     (FIXP (CADR (ARG 1.))))))
		   ((= ARGS 2.)
		    (SETQ X-COR (FLOAT (ARG 1.)) 
			  Y-COR (FLOAT (ARG 2.)) 
			  RETURN-FIXNUM (AND (FIXP (ARG 1.)) (FIXP (ARG 2.)))))
		   ((ERRBREAK 'TOWARDS
			      '"WRONG NUMBER OF INPUTS")))
	     (LET ((ALLEGED-TOWARDS (-$ (BEARING X-COR Y-COR) :HEADING)))
		  (COND ((MINUSP ALLEGED-TOWARDS)
			 (SETQ ALLEGED-TOWARDS (+$ 360.0 ALLEGED-TOWARDS))))
		  (COND (RETURN-FIXNUM (\ (ROUND ALLEGED-TOWARDS) 360.))
			((\$ ALLEGED-TOWARDS 360.0)))))) 

(DEFINE RANGE ARGS 
	(LET ((X-COR 0.0)
	      (Y-COR 0.0)
	      (ALLEGED-RANGE 0.0)
	      (DELTA-X 0.0)
	      (DELTA-Y 0.0)
	      (RETURN-FIXNUM))
	     (COND ((= ARGS 1.)
		    (SETQ X-COR (FLOAT (CAR (ARG 1.))) 
			  Y-COR (FLOAT (CADR (ARG 1.))) 
			  RETURN-FIXNUM (AND (FIXP (CAR (ARG 1.)))
					     (FIXP (CADR (ARG 1.))))))
		   ((= ARGS 2.)
		    (SETQ X-COR (FLOAT (ARG 1.)) 
			  Y-COR (FLOAT (ARG 2.)) 
			  RETURN-FIXNUM (AND (FIXP (ARG 1.)) (FIXP (ARG 2.)))))
		   ((ERRBREAK 'RANGE
			      '"WRONG NUMBER OF INPUTS")))
	     (SETQ DELTA-X (-$ X-COR :XCOR) 
		   DELTA-Y (-$ Y-COR :YCOR) 
		   ALLEGED-RANGE (SQRT (+$ (*$ DELTA-X DELTA-X)
					   (*$ DELTA-Y DELTA-Y))))
	     (COND (RETURN-FIXNUM (ROUND ALLEGED-RANGE)) (ALLEGED-RANGE)))) 

;;*PAGE

;;;


(COMMENT WINDOW COMMANDS) 

;;;
;;;
;;THE FOLLOWING FUNCTIONS ALLOW THE USER TO SAVE RECTANGULAR AREAS OF THE SCREEN IN
;;BIT-IMAGE ARRAYS, AND REDISPLAY SUCH ARRAYS ANYWHERE ON THE SCREEN.  ALTHOUGH
;;SOMEWHAT SPACE CONSUMING, IT ALLOWS SUPERQUICK REDISPLAY, MINIMIZING RECOMPUTATION
;;OF POINTS.  THIS MAKES IT IDEAL FOR PROGRAMS WHICH WANT TO MAKE ONLY LOCAL CHANGES
;;TO A PICTURE, BUT NEED SPEED FOR DYNAMIC UPDATING.  EXAMPLES: SHIPS IN SPACE WAR,
;;BOUNCING BALL TYPE PROGRAMS, CELLS IN LIFE GAME. 
;;;
;;NOTE THAT THESE "WINDOW"S ARE DIFFERENT FROM LLOGO'S SNAPS: WHAT YOU SEE IS
;;EXACTLY WHAT YOU GET!

(DECLARE (FIXNUM CENTER-X CENTER-Y RADIUS-X RADIUS-Y LEFT-X RIGHT-X TOP-Y BOTTOM-Y)) 

(DEFUN RECTANGLE-SPEC (CHECKER SPEC-LIST) 
       ;;HANDLES DEFAULTS FOR SPECIFYING A RECTANGULAR AREA OF THE SCREEN FOR USE
       ;;WITH THE WINDOW AND XGP COMMANDS.
       (LET ((LEFT-X TV-PICTURE-LEFT)
	     (RIGHT-X TV-PICTURE-RIGHT)
	     (TOP-Y TV-PICTURE-TOP)
	     (BOTTOM-Y TV-PICTURE-BOTTOM)
	     (CENTER-X (TV-X :XCOR))
	     (CENTER-Y (TV-Y :YCOR))
	     (RADIUS-X TV-PICTURE-HALF-X)
	     (RADIUS-Y TV-PICTURE-HALF-Y))
	    (COND ((NULL SPEC-LIST)
		   (SETQ CENTER-X (+ TV-PICTURE-LEFT TV-PICTURE-HALF-X) 
			 CENTER-Y (+ TV-PICTURE-TOP TV-PICTURE-HALF-Y)))
		  (T (COND ((CDDR SPEC-LIST)
			    (SETQ CENTER-X (TV-X (FLOAT (CAR SPEC-LIST))) 
				  CENTER-Y (TV-Y (FLOAT (CADR SPEC-LIST))) 
				  SPEC-LIST (CDDR SPEC-LIST))))
		     (SETQ RADIUS-X (ROUND (//$ (FLOAT (CAR SPEC-LIST))
						:TVSTEP)) 
			   RADIUS-Y (COND ((CDR SPEC-LIST)
					   (ROUND (//$ (FLOAT (CADR SPEC-LIST))
						       :TVSTEP)))
					  (RADIUS-X)) 
			   LEFT-X (- CENTER-X RADIUS-X) 
			   RIGHT-X (+ CENTER-X RADIUS-X) 
			   TOP-Y (- CENTER-Y RADIUS-Y) 
			   BOTTOM-Y (+ CENTER-Y RADIUS-Y))
		     (AND (OR (> RADIUS-X TV-PICTURE-HALF-X)
			      (> RADIUS-Y TV-PICTURE-HALF-Y))
			  (ERRBREAK CHECKER
				    '"AREA TOO LARGE"))))
	    ;;THE RECTANGULAR AREA SPECIFIED BY THE NUMBERS BELOW INCLUDES THE TOP,
	    ;;BOTTOM, LEFT & RIGHT MOST POINTS.
	    (LIST TOP-Y BOTTOM-Y LEFT-X RIGHT-X CENTER-X CENTER-Y))) 

;;THE DIMENSIONS ARE STORED IN THE ARRAY SO THAT GETWINDOWS CAN RECREATE A
;;TWO-DIMESIONAL ARRAY FROM THE ONE DIMENSIONAL ARRAY RETURNED BY LOADARRAYS.

(DECLARE (SPECIAL WINDOW-INFO-DIMENSION WINDOW-INFO-TAIL WINDOW-PICTURE-TAIL)
	 (FIXNUM HOME-X HOME-Y WINDOW-PICTURE-SIZE-X WINDOW-PICTURE-SIZE-Y)
	 (NOTYPE (MAKEWINDOW-STORE NOTYPE FIXNUM FIXNUM FIXNUM FIXNUM)
		 (MAKEWINDOW-ARRAY NOTYPE
				   FIXNUM
				   FIXNUM
				   FIXNUM
				   FIXNUM
				   FIXNUM
				   FIXNUM))) 



(SETQ WINDOW-INFO-TAIL '(- W I N D O W - I N F O) 
      WINDOW-PICTURE-TAIL '(- W I N D O W - P I C T U R E) 
      [COLOR WINDOW-PALETTE-TAIL '(- W I N D O W - P A L E T T E)
             RUN-COLOR-SHIFT 18.
             MINUS-RUN-COLOR-SHIFT (- RUN-COLOR-SHIFT)
             RUN-COUNTER-MASK (1- (LSH 1. RUN-COLOR-SHIFT))]
      WINDOW-INFO-DIMENSION 8.) 

(COND ((STATUS FEATURE LLOGO)
       (MAPC '(LAMBDA (ATOM) (OBTERN ATOM LOGO-OBARRAY)) 
             (APPEND WINDOW-INFO-TAIL 
                     WINDOW-PICTURE-TAIL 
                     [COLOR WINDOW-PALETTE-TAIL]))))

(DECLARE (FIXNUM LEFT-X RIGHT-X TOP-Y BOTTOM-Y TV-CENTER-X TV-CENTER-Y TV-RADIUS-X
		 TV-RADIUS-Y WINDOW-X WINDOW-Y DOWN ACROSS STOP-X START-BIT
		 STOP-BIT STOP-MASK WINDOW-BIT SOURCE BITS-WANTED START-MASK
                 START-ADDRESS STOP-ADDRESS STOP-ACROSS TV-DELTA-X TV-DELTA-Y
                 WINDOW-ADDRESS))


[COLOR 

(DECLARE (FIXNUM WINDOW-RUN-ENCODE FIXNUM FIXNUM)
         (SPECIAL RUN-COLOR-SHIFT RUN-COUNTER-MASK MINUS-RUN-COLOR-SHIFT)
         (FIXNUM RUN-COLOR-SHIFT RUN-COUNTER-MASK MINUS-RUN-COLOR-SHIFT))

(DEFUN WINDOW-RUN-ENCODE (RUN-COLOR RUN-COUNTER)
       (BITWISE-OR (LSH RUN-COLOR RUN-COLOR-SHIFT) RUN-COUNTER))]

;;*PAGE


;;;Improvements:
;;Eliminate list for temporarily holding run length codes. Instead,
;;estimate size of window picture array and store run lengths directly
;;into array. Readjust dimensions as needed, and when actual size known at end.
;;;
;;Store run lengths two to a word [4 bits color, 14 bits counter]
;;;

[COLOR

(DECLARE (NOTYPE (MAKEWINDOW-STORE-COLOR NOTYPE FIXNUM FIXNUM FIXNUM FIXNUM))
         (FIXNUM RUN-Y RUN-INDEX ONE-PLUS-RIGHT-X RUN-START NEXT-RUN-START
                 RUN-COLOR RUN-COUNTER LAST-RUN-COLOR LAST-RUN-COUNTER))

(DEFUN MAKEWINDOW-STORE-COLOR (WINDOW-PICTURE TOP-Y BOTTOM-Y LEFT-X RIGHT-X)
       (DO ((RUN-Y TOP-Y (1+ RUN-Y))
            (RUN-LIST)
            ;;List of run length codes, index is number of codes so far.
            (RUN-INDEX 0.)
            (ONE-PLUS-RIGHT-X (1+ RIGHT-X))
            (LAST-RUN-COLOR -1.)
            (LAST-RUN-COUNTER -1.))
           ((> RUN-Y BOTTOM-Y)
            (FILLARRAY (*ARRAY WINDOW-PICTURE 'FIXNUM (1+ RUN-INDEX)) 
                       (NREVERSE RUN-LIST)))
           (DO ((RUN-START LEFT-X NEXT-RUN-START)
                (NEXT-RUN-START)
                (RUN-COLOR)
                (RUN-COUNTER))
               ((> RUN-START RIGHT-X) 
                ;;Last color & counter on line remembered to merge if possible
                ;;with first on next line.
                (SETQ LAST-RUN-COLOR RUN-COLOR LAST-RUN-COUNTER RUN-COUNTER))
               (SETQ NEXT-RUN-START
                     ;;NEXT-RUN-START is first point after current run.
                     (+ RUN-START
                        (SETQ RUN-COUNTER
                              ;;Number of points in the current run.
                              (RUNAWAY-FORWARD RUN-START
                                               RUN-Y
                                               ;;Color of point starting run.
                                               (SETQ RUN-COLOR
                                                     (READ-TV-POINT-NUMBER
                                                      RUN-START
                                                      RUN-Y))))))
               (COND ((> NEXT-RUN-START ONE-PLUS-RIGHT-X)
                      ;;Run extends past the right boundary of the area.
                      (SETQ RUN-COUNTER (- ONE-PLUS-RIGHT-X RUN-START))))
               (COND ((MINUSP LAST-RUN-COLOR)
                      ;;No previous run to worry about.
                      (PUSH (WINDOW-RUN-ENCODE RUN-COLOR RUN-COUNTER) RUN-LIST)
                      (INCREMENT RUN-INDEX))
                     ((= LAST-RUN-COLOR RUN-COLOR)
                      ;;Consolidate two runs on successive lines.
                      (RPLACA RUN-LIST 
                              (WINDOW-RUN-ENCODE RUN-COLOR 
                                                 (+ RUN-COUNTER LAST-RUN-COUNTER)))
                      (SETQ LAST-RUN-COLOR -1.))
                     (T (SETQ LAST-RUN-COLOR -1.)
                        (PUSH (WINDOW-RUN-ENCODE RUN-COLOR RUN-COUNTER) RUN-LIST)
                        (INCREMENT RUN-INDEX))))))]


 

;;*PAGE



[BW 

(DEFUN MAKEWINDOW-STORE (WINDOW-ARRAY TOP-Y BOTTOM-Y LEFT-X RIGHT-X) 
       (LET ((START-BIT (PROG1 (BITWISE-AND LEFT-X 31.) (SETQ LEFT-X (LSH LEFT-X -5.))))
	     (STOP-BIT (PROG1 (BITWISE-AND RIGHT-X 31.) 
                              (SETQ RIGHT-X (LSH RIGHT-X -5.))))
             (START-ADDRESS (TV-ADDRESS TOP-Y LEFT-X))
             (TV-DELTA-Y (- BOTTOM-Y TOP-Y))
             (TV-DELTA-X (- RIGHT-X LEFT-X)))
	    (DO ((DOWN START-ADDRESS (+ DOWN 18.))
                 (STOP-ADDRESS (+ START-ADDRESS (* TV-DELTA-Y 18.)))
		 (WINDOW-ADDRESS 0. (1+ WINDOW-ADDRESS))
		 (STOP-MASK (TO-MASK STOP-BIT)))
		((> DOWN STOP-ADDRESS))
		(DO ((BITS-WANTED (- 32. START-BIT) 32.)
		     ;;BITS REMAINING IN TV WORD.
		     (WINDOW-BIT 0.)
		     ;;WORD AND BIT INDEX INTO WINDOW ARRAY.
		     (ACROSS DOWN)
                     (STOP-ACROSS (+ DOWN TV-DELTA-X))
		     ;;DAMNED PARALLEL ASSIGNMENT!
		     (SOURCE (LSH (TV DOWN) START-BIT)))
	            ((> ACROSS STOP-ACROSS))
		    ;;FOR LAST WORD, MASK OUT BITS PAST RIGHT EDGE, REVISE ESTIMATE
		    ;;OF NEEDED BITS.
		    (AND (= ACROSS STOP-ACROSS)
			 (SETQ SOURCE (BITWISE-AND SOURCE STOP-MASK) 
			       BITS-WANTED (- BITS-WANTED (- 32. STOP-BIT))))
		    ;;STASH THE TV BITS IN THE WINDOW ARRAY.
		    (STORE (ARRAYCALL FIXNUM WINDOW-ARRAY WINDOW-ADDRESS)
			   (BITWISE-OR (ARRAYCALL FIXNUM WINDOW-ARRAY WINDOW-ADDRESS)
				       (LSH SOURCE (- WINDOW-BIT))))
		    (INCREMENT WINDOW-BIT BITS-WANTED)
		    ;;TOO MANY TO FIT IN THAT WORD? USE THE NEXT ONE, TOO.
		    (COND ((> WINDOW-BIT 35.)
                           (DECREMENT WINDOW-BIT 36.)
			   (STORE (ARRAYCALL FIXNUM 
                                             WINDOW-ARRAY 
                                             (INCREMENT WINDOW-ADDRESS))
				  (LSH SOURCE (- BITS-WANTED WINDOW-BIT)))))
                    (SETQ ACROSS (1+ ACROSS) SOURCE (TV ACROSS))))))]


;;*PAGE



[COLOR (DECLARE (SPECIAL WINDOW-PALETTE-TAIL))]

(DEFUN MAKEWINDOW-ARRAY (WINDOW-NAME HOME-X HOME-Y TOP-Y BOTTOM-Y LEFT-X RIGHT-X) 
       (LET ((WINDOW-INFO (MAKNAM (NCONC (EXPLODEC WINDOW-NAME) WINDOW-INFO-TAIL)))
	     (WINDOW-PICTURE (MAKNAM (NCONC (EXPLODEC WINDOW-NAME) WINDOW-PICTURE-TAIL)))
             [COLOR 
              (WINDOW-PALETTE (MAKNAM (NCONC (EXPLODEC WINDOW-NAME) WINDOW-PALETTE-TAIL)))])
	    (COND ((MINUSP TOP-Y)
		   ;;EMPTY WINDOWS ARE MARKED BY HAVING THE FIRST WORD OF INFO ARRAY
		   ;;0.
		   (*ARRAY WINDOW-INFO 'FIXNUM 1.)
		   (*ARRAY WINDOW-PICTURE 'FIXNUM 1.)
                   [COLOR (*ARRAY WINDOW-PALETTE 'FIXNUM 1.)])
		  ((LET ((WINDOW-PICTURE-SIZE-X (1+ (// (- RIGHT-X LEFT-X) 36.)))
			 (WINDOW-PICTURE-SIZE-Y (1+ (- BOTTOM-Y TOP-Y))))
			(*ARRAY WINDOW-INFO 'FIXNUM WINDOW-INFO-DIMENSION)
			[BW (*ARRAY WINDOW-PICTURE
				'FIXNUM
                                (* WINDOW-PICTURE-SIZE-Y WINDOW-PICTURE-SIZE-X))]
			;;LEFT, RIGHT, TOP AND BOTTOM RELATIVE TO HOME, SO THAT EASY
			;;TO COMPUTE NEW ONES WHEN MOVED TO NEW HOME.
                        [COLOR 
                        (FILLARRAY (*ARRAY WINDOW-PALETTE T 16.)
                                   'PALETTE)]
			(FILLARRAY WINDOW-INFO
				   (LIST WINDOW-PICTURE-SIZE-X
					 WINDOW-PICTURE-SIZE-Y
					 HOME-X
					 HOME-Y
					 (- TOP-Y HOME-Y)
					 (- BOTTOM-Y HOME-Y)
					 (- LEFT-X HOME-X)
					 (- RIGHT-X HOME-X)))
			[BW (MAKEWINDOW-STORE (GET WINDOW-PICTURE 'ARRAY)
					  TOP-Y
					  BOTTOM-Y
					  LEFT-X
					  RIGHT-X)]
                        [COLOR 
                         (MAKEWINDOW-STORE-COLOR WINDOW-PICTURE
                                                 TOP-Y
                                                 BOTTOM-Y
                                                 LEFT-X
                                                 RIGHT-X)])))
	    ;;THE WINDOW PROPERTY OF ATOM IS LIST OF THE TWO ARRAYS.
	    (PUTPROP WINDOW-NAME 
                     (LIST WINDOW-INFO WINDOW-PICTURE [COLOR WINDOW-PALETTE]) 
                     'WINDOW)))


(DECLARE (FIXNUM (RUNAWAY-FORWARD FIXNUM FIXNUM FIXNUM)
		 (RUNAWAY-BACKWARD FIXNUM FIXNUM FIXNUM)
		 (MAKEWINDOW-VISIBLE NOTYPE
				     FIXNUM
				     FIXNUM
				     FIXNUM
				     FIXNUM
				     FIXNUM
				     FIXNUM)
		 VISIBLE-TOP VISIBLE-BOTTOM VISIBLE-RIGHT VISIBLE-LEFT
		 FIRST-VISIBLE LAST-VISIBLE)) 

;;*PAGE


(DEFUN MAKEWINDOW-VISIBLE (WINDOW-NAME TV-TOP TV-BOTTOM TV-LEFT TV-RIGHT
			   TV-CENTER-X TV-CENTER-Y) 
       ;;TAKING THE HOME AND BOUNDARIES IN TV COORDINATES, THIS COMPUTES THE EXTREMES OF
       ;;THE AREA IN WHICH CRUD IS ACTUALLY VISIBLE ON THE SCREEN, AND SAVES THE
       ;;STUFF IN THAT AREA.
       (DO ((TRAVEL-Y TV-TOP (1+ TRAVEL-Y))
	    ;;"VISIBLE" VARIABLES MARK EXTREMES OF VISIBLE AREA.  TOP, BOTTOM
	    ;;INITIALIZED TO IMPOSSIBLE VALUE, LEFT & RIGHT INITIALIZED TO EACH
	    ;;OTHER.
	    (VISIBLE-TOP -1.)
	    (VISIBLE-BOTTOM -1.)
	    (VISIBLE-RIGHT TV-LEFT)
	    (VISIBLE-LEFT TV-RIGHT)
	    (FIRST-VISIBLE)
	    ;;FIRST AND LAST VISIBLE POINTS IN A GIVEN LINE.
	    (LAST-VISIBLE))
	   ((> TRAVEL-Y TV-BOTTOM)
	    (MAKEWINDOW-ARRAY WINDOW-NAME
			      TV-CENTER-X
			      TV-CENTER-Y
			      VISIBLE-TOP
			      VISIBLE-BOTTOM
			      VISIBLE-LEFT
			      VISIBLE-RIGHT))
	   (COND ((> (SETQ FIRST-VISIBLE
			   (+ TV-LEFT (RUNAWAY-FORWARD TV-LEFT 
                                                       TRAVEL-Y 
                                                       [BW 0.] 
                                                       [COLOR :ERASERNUMBER])))
		     ;;IS WHOLE LINE CLEAR IN AREA WITHIN WINDOW BOUNDS?
		     TV-RIGHT))
		 ((SETQ VISIBLE-BOTTOM TRAVEL-Y)
		  ;;IF NOT, THIS IS THE LOWEST LINE SO FAR WITH ANYTHING ON IT.
		  (COND ((MINUSP VISIBLE-TOP)
			 ;;IF WE HAVEN'T HIT ANYTHING SO FAR IN DOWNWARD SCAN.
			 (SETQ VISIBLE-TOP TRAVEL-Y)))
		  (COND ((< FIRST-VISIBLE VISIBLE-LEFT)
			 ;;IF TO LEFT OF LEFTMOST POINT SO FAR. 
			 (SETQ VISIBLE-LEFT FIRST-VISIBLE)))
		  (COND ((> (SETQ LAST-VISIBLE
				  (- TV-RIGHT
				     (RUNAWAY-BACKWARD TV-RIGHT 
                                                       TRAVEL-Y 
                                                       [BW 0.]
                                                       [COLOR :ERASERNUMBER])))
			    VISIBLE-RIGHT)
			 (SETQ VISIBLE-RIGHT LAST-VISIBLE))))))) 


;;*PAGE



(DEFINE MAKEWINDOW (ABB MW) ARGS 
	(OR (SYMBOLP (ARG 1.))
	    (SETARG 1.
		    (ERRBREAK 'MAKEWINDOW
			      (LIST (ARG 1.)
				    '"IS NOT A VALID NAME"))))
	(INTERNAL-WINDOW (ARG 1.)
			 (RECTANGLE-SPEC 'MAKEWINDOW (LISTIFY (- 1. ARGS))))) 

(DEFUN INTERNAL-WINDOW (WINDOW-NAME RECTANGLE) 
       (COND (:WINDOWOUTLINE 
              [COLOR (SELECT-COLOR :PENNUMBER)]
              (INTERNAL-WINDOWFRAME RECTANGLE)
              [COLOR (RESELECT-COLOR)]))
       [COLOR (NO-COLOR-WRITE)]
       (APPLY 'MAKEWINDOW-VISIBLE (CONS WINDOW-NAME RECTANGLE))
       ;;ADD TO LIST OF USER NAMED WINDOWS.
       (OR (MEMQ WINDOW-NAME :WINDOWS) (PUSH WINDOW-NAME :WINDOWS))
       [COLOR (COLOR-WRITE)]
       (COND (:WINDOWOUTLINE 
              [COLOR (SELECT-COLOR :ERASERNUMBER)] 
              (INTERNAL-WINDOWFRAME RECTANGLE)
              [COLOR (RESELECT-COLOR)]))
       WINDOW-NAME) 

(ARGS 'MAKEWINDOW '(1. . 5.)) 

(DECLARE (FLONUM NEW-WINDOW-HOME-X NEW-WINDOW-HOME-Y)) 

(DEFINE WINDOWHOME (ABB WH) ARGS 
 ;;CHANGES THE CENTER LOCATION ASSOCIATED WITH A WINDOW.
 (LET
  ((WINDOW-ARRAY (COND ((MEMQ (ARG 1.) :WINDOWS)
			(GET (CAR (GET (ARG 1.) 'WINDOW)) 'ARRAY))
		       ((ERRBREAK 'WINDOWHOME
				  (LIST (ARG 1.)
					'"IS NOT A WINDOW")))))
   (NEW-WINDOW-HOME-X :XCOR)
   (NEW-WINDOW-HOME-Y :YCOR))
  (COND ((= ARGS 1.))
	((= ARGS 2.)
	 (SETQ NEW-WINDOW-HOME-X (FLOAT (CAR (ARG 2.))) 
	       NEW-WINDOW-HOME-Y (FLOAT (CADR (ARG 2.)))))
	((= ARGS 3.)
	 (SETQ NEW-WINDOW-HOME-X (FLOAT (ARG 2.)) 
	       NEW-WINDOW-HOME-Y (FLOAT (ARG 3.)))))
  (STORE (ARRAYCALL FIXNUM WINDOW-ARRAY 2.) (TV-X NEW-WINDOW-HOME-X))
  (STORE (ARRAYCALL FIXNUM WINDOW-ARRAY 3.) (TV-Y NEW-WINDOW-HOME-Y)))) 

(ARGS 'WINDOWHOME '(1. . 3.)) 

[COLOR

(DECLARE (NOTYPE (DISPLAYWINDOW-STORE NOTYPE NOTYPE FIXNUM FIXNUM FIXNUM FIXNUM)
		 (DISPLAYWINDOW-TV NOTYPE NOTYPE FIXNUM FIXNUM))
	 (FIXNUM WINDOW-START-X WINDOW-START-Y WINDOW-START-BIT START-MASK
		 INITIAL-BITS-WANTED TV-START-BIT)) 

(DECLARE (NOTYPE (STORE-IOR-TV FIXNUM FIXNUM FIXNUM))) 

(DEFUN STORE-IOR-TV (TV-ADDRESS NEW-CONTENTS) 
       (WRITE-TV-MASK (BITWISE-NOT (LSH NEW-CONTENTS -20.)))
       (STORE (TV TV-ADDRESS) -12.)
       (WRITE-TV-MASK (BITWISE-NOT (BITWISE-AND RIGHT-HALFWORD (LSH NEW-CONTENTS -4.))))
       (STORE (TV TV-ADDRESS) -8.)
       T) 

;;;END OF COLOR CONDITIONAL SECTION.
]

;;*PAGE


(DECLARE (NOTYPE (DISPLAYWINDOW-WORD FIXNUM FIXNUM FIXNUM FIXNUM FIXNUM))
         (SPECIAL DISPLAYWINDOW-TOP DISPLAYWINDOW-BOTTOM DISPLAYWINDOW-LEFT 
                  DISPLAYWINDOW-RIGHT DISPLAYWINDOW-ARRAY DISPLAYWINDOW-INCREMENT
                  DISPLAYWINDOW-LINES DISPLAYWINDOW-ADDRESS)
         (FIXNUM DISPLAYWINDOW-TOP DISPLAYWINDOW-BOTTOM DISPLAYWINDOW-LEFT 
                 DISPLAYWINDOW-RIGHT DISPLAYWINDOW-X DISPLAYWINDOW-Y DOWN 
                 WINDOW-SHIFT WINDOW-ADDRESS NEW-WINDOW-ADDRESS NEW-WINDOW-SHIFT
                 DISPLAYWINDOW-LINES DISPLAYWINDOW-INCREMENT DISPLAYWINDOW-ADDRESS))

(DEFUN DISPLAYWINDOW-WORD (WINDOW-BIT NEW-WINDOW-BIT ACROSS START-BIT MASK)
       ;;Stores a column of the TV array one word wide with picture from window.
       (COND ((< NEW-WINDOW-BIT 36.)
              ;;There are two cases. One, the TV word can come entirely from one
              ;;word of the window array.
              (DO ((DOWN ACROSS (+ DOWN 18.)) 
                   (WINDOW-ADDRESS DISPLAYWINDOW-ADDRESS 
                                   (+ WINDOW-ADDRESS DISPLAYWINDOW-INCREMENT))
                   (WINDOW-SHIFT (- WINDOW-BIT START-BIT))
                   (STOP-ADDRESS (+ ACROSS DISPLAYWINDOW-LINES)))
                  ((> DOWN STOP-ADDRESS))
                  ;;As much as possible computed outside of this inner loop
                  ;;for efficiency.
                  [BW (STORE (TV DOWN)
                         (BITWISE-AND 
                          (LSH (ARRAYCALL FIXNUM DISPLAYWINDOW-ARRAY WINDOW-ADDRESS)
                                WINDOW-SHIFT)
                          MASK))]
                  [COLOR 
                   (STORE-IOR-TV 
                    DOWN 
                    (BITWISE-AND 
                     (LSH (ARRAYCALL FIXNUM DISPLAYWINDOW-ARRAY WINDOW-ADDRESS)
                          WINDOW-SHIFT)
                     MASK))]))
             ((DO ((DOWN ACROSS (+ DOWN 18.)) 
                   (WINDOW-ADDRESS DISPLAYWINDOW-ADDRESS 
                                   (+ WINDOW-ADDRESS DISPLAYWINDOW-INCREMENT))
                   (NEW-WINDOW-ADDRESS (1+ DISPLAYWINDOW-ADDRESS)
                                 (+ NEW-WINDOW-ADDRESS DISPLAYWINDOW-INCREMENT))
                   (WINDOW-SHIFT (- WINDOW-BIT START-BIT))
                   (NEW-WINDOW-SHIFT (- WINDOW-BIT START-BIT 36.))
                   (STOP-ADDRESS (+ ACROSS DISPLAYWINDOW-LINES)))
                  ;;Here, the TV word breaks over two words of the window array.
                  ((> DOWN STOP-ADDRESS))
                  ([COLOR STORE-IOR-TV DOWN]
                   [BW STORE (TV DOWN)]
                   (BITWISE-AND 
                    (BITWISE-OR 
                     (LSH (ARRAYCALL FIXNUM DISPLAYWINDOW-ARRAY WINDOW-ADDRESS) 
                          WINDOW-SHIFT)
                     (LSH (ARRAYCALL FIXNUM DISPLAYWINDOW-ARRAY NEW-WINDOW-ADDRESS)
                          NEW-WINDOW-SHIFT))
                    MASK)))))
       T)


;;*PAGE



(DECLARE (NOTYPE (DISPLAYWINDOW-STORE NOTYPE NOTYPE FIXNUM FIXNUM FIXNUM FIXNUM))
         (FIXNUM WINDOW-START-Y WINDOW-START-X WINDOW-START-BIT START-MASK STOP-MASK
                 INITIAL-BITS-WANTED ACROSS WINDOW-X WINDOW-BIT))

(DEFUN DISPLAYWINDOW-STORE 
       (DISPLAYWINDOW-INFO DISPLAYWINDOW-ARRAY DISPLAYWINDOW-TOP DISPLAYWINDOW-BOTTOM 
        DISPLAYWINDOW-LEFT DISPLAYWINDOW-RIGHT) 
       (LET
	((DISPLAYWINDOW-Y 0.)
	 (DISPLAYWINDOW-X 0.)
	 ;;FIRST WORD AND BIT TO START IN WINDOW ARRAY.
	 (WINDOW-START-BIT 0.))
	;;IF BEYOND BOUNDS OF DISPLAY AREA, CUT OFF AT BOUNDARY.
	(AND (> DISPLAYWINDOW-BOTTOM TV-PICTURE-BOTTOM) 
             (SETQ DISPLAYWINDOW-BOTTOM TV-PICTURE-BOTTOM))
	(AND (> DISPLAYWINDOW-RIGHT TV-PICTURE-RIGHT) 
             (SETQ DISPLAYWINDOW-RIGHT TV-PICTURE-RIGHT))
	;;IF GREATER THAN MAX TV COORDINATE, JUST STOP WHEN YOU GET TO EDGE.
	(AND (< DISPLAYWINDOW-TOP TV-PICTURE-TOP)
	     (INCREMENT DISPLAYWINDOW-Y (- TV-PICTURE-TOP DISPLAYWINDOW-TOP))
             (SETQ DISPLAYWINDOW-TOP TV-PICTURE-TOP))
	;;IF LESS THAN MIN, YOU'VE GOT TO START IN THE MIDDLE OF THE WINDOW ARRAY.
	(AND (< DISPLAYWINDOW-LEFT TV-PICTURE-LEFT)
	     (SETQ DISPLAYWINDOW-X (- TV-PICTURE-LEFT DISPLAYWINDOW-LEFT) 
		   WINDOW-START-BIT (\ DISPLAYWINDOW-X 36.) 
		   DISPLAYWINDOW-X (// DISPLAYWINDOW-X 36.) 
		   DISPLAYWINDOW-LEFT TV-PICTURE-LEFT))
	(LET
	 ((DISPLAYWINDOW-INCREMENT (ARRAYCALL FIXNUM DISPLAYWINDOW-INFO 0.))
          (START-BIT (BITWISE-AND (PROG1 DISPLAYWINDOW-LEFT 
                                         (SETQ DISPLAYWINDOW-LEFT 
                                               (LSH DISPLAYWINDOW-LEFT -5.))) 31.))
	  (STOP-BIT (BITWISE-AND (PROG1 DISPLAYWINDOW-RIGHT 
                                        (SETQ DISPLAYWINDOW-RIGHT 
                                              (LSH DISPLAYWINDOW-RIGHT -5.))) 31.)))
	 (LET
	  ((START-MASK (FROM-MASK START-BIT))
	   (INITIAL-BITS-WANTED (- 32. START-BIT))
	   (STOP-MASK (TO-MASK STOP-BIT))
           (START-ADDRESS (+ (* DISPLAYWINDOW-TOP 18.) DISPLAYWINDOW-LEFT))
           (DISPLAYWINDOW-LINES (* (- DISPLAYWINDOW-BOTTOM DISPLAYWINDOW-TOP) 18.))
           (DISPLAYWINDOW-ADDRESS (+ (* DISPLAYWINDOW-Y DISPLAYWINDOW-INCREMENT)
                                     DISPLAYWINDOW-X)))
          (COND ((= DISPLAYWINDOW-LEFT DISPLAYWINDOW-RIGHT)
                 ;;Window fits entirely inside one TV word.
                 (DISPLAYWINDOW-WORD WINDOW-START-BIT 
                                     (+ WINDOW-START-BIT (- STOP-BIT START-BIT))
                                     START-ADDRESS
                                     START-BIT
                                     (BITWISE-AND START-MASK STOP-MASK)))
                ((DISPLAYWINDOW-WORD WINDOW-START-BIT
                                     (INCREMENT WINDOW-START-BIT INITIAL-BITS-WANTED)
                                     START-ADDRESS
                                     START-BIT 
                                     START-MASK)
                 ;;Do first partial word, then loop for each successive word.
                 (DO ((ACROSS (1+ START-ADDRESS) (1+ ACROSS))
                      (WINDOW-BIT WINDOW-START-BIT)
                      (STOP-ADDRESS (+ START-ADDRESS 
                                       (- DISPLAYWINDOW-RIGHT DISPLAYWINDOW-LEFT))))
                     ((= ACROSS STOP-ADDRESS)
                      (AND (> WINDOW-BIT 36.) 
                           (INCREMENT DISPLAYWINDOW-ADDRESS) 
                           (DECREMENT WINDOW-BIT 36.))
                      ;;Finally, fill the last partial word.
                      (DISPLAYWINDOW-WORD WINDOW-BIT 
                                          (+ WINDOW-BIT STOP-BIT)
                                          STOP-ADDRESS
                                          0. 
                                          STOP-MASK))
                     (COND ((> WINDOW-BIT 36.)
                            (INCREMENT DISPLAYWINDOW-ADDRESS)
                            (DECREMENT WINDOW-BIT 36.)))
                     (DISPLAYWINDOW-WORD WINDOW-BIT
                                         (INCREMENT WINDOW-BIT 32.) 
                                         ACROSS 
                                         0. 
                                         -16.))))))))
                      
 

[BW 

(DEFINE DISPLAYWINDOW (ABB DW) ARGS 
 (LET
  ((WINDOW-PROP (GET (ARG 1.) 'WINDOW)))
  (COND ((NULL WINDOW-PROP)
	 (SETQ WINDOW-PROP
	       (ERRBREAK 'DISPLAYWINDOW
			 (LIST (ARG 1.)
			       '"IS NOT A WINDOW")))))
  (LET
   ((WINDOW-INFO (GET (CAR WINDOW-PROP) 'ARRAY))
    (WINDOW-PICTURE (GET (CADR WINDOW-PROP) 'ARRAY))
    (HOME-X 0.) (HOME-Y 0.))
   (COND
    ((ZEROP (ARRAYCALL FIXNUM WINDOW-INFO 0.)))
    ;;IS WINDOW EMPTY?
    (T (COND ((= ARGS 1.)
              (SETQ HOME-X (ARRAYCALL FIXNUM WINDOW-INFO 2.)
                    HOME-Y (ARRAYCALL FIXNUM WINDOW-INFO 3.)))
             ((= ARGS 3.)
              (SETQ HOME-X (TV-X (FLOAT (ARG 2.)))
                    HOME-Y (TV-Y (FLOAT (ARG 3.)))))
             ((ERRBREAK 'DISPLAYWINDOW '"WRONG NUMBER OF ARGS TO WINDOW FUNCTION")))
       (ERASE-TURTLES)
       ;;Turtle hidden during execution of window commands.
       (DISPLAYWINDOW-TV WINDOW-INFO WINDOW-PICTURE HOME-X HOME-Y)
       (DRAW-TURTLES)))))) 

;;END OF BLACK AND WHITE CONDITIONAL SECTION.
] 

(DEFUN DISPLAYWINDOW-TV (WINDOW-INFO WINDOW-PICTURE HOME-X HOME-Y) 
       (DISPLAYWINDOW-STORE WINDOW-INFO 
                            WINDOW-PICTURE
			    (+ HOME-Y (ARRAYCALL FIXNUM WINDOW-INFO 4.))
			    (+ HOME-Y (ARRAYCALL FIXNUM WINDOW-INFO 5.))
			    (+ HOME-X (ARRAYCALL FIXNUM WINDOW-INFO 6.))
			    (+ HOME-X (ARRAYCALL FIXNUM WINDOW-INFO 7.))))



;;*PAGE



[COLOR


(DECLARE (NOTYPE (DISPLAYWINDOW-TV-COLOR NOTYPE NOTYPE NOTYPE NOTYPE FIXNUM FIXNUM)))

(DEFUN DISPLAYWINDOW-COLOR ARGS 
 (LET
  ((WINDOW-PROP (GET (ARG 2.) 'WINDOW)))
  (COND ((NULL WINDOW-PROP)
	 (SETQ WINDOW-PROP
	       (ERRBREAK 'DISPLAYWINDOW-COLOR
			 (LIST (ARG 2.)
			       '"IS NOT A WINDOW")))))
  (LET
   ((WINDOW-INFO (GET (CAR WINDOW-PROP) 'ARRAY))
    (WINDOW-PICTURE (GET (CADR WINDOW-PROP) 'ARRAY))
    (WINDOW-PALETTE (GET (CADDR WINDOW-PROP) 'ARRAY))
    (HOME-X 0.) (HOME-Y 0.))
   (COND
    ((ZEROP (ARRAYCALL FIXNUM WINDOW-INFO 0.)))
    ;;IS WINDOW EMPTY?
    (T (COND ((= ARGS 2.)
              (SETQ HOME-X (ARRAYCALL FIXNUM WINDOW-INFO 2.)
                    HOME-Y (ARRAYCALL FIXNUM WINDOW-INFO 3.)))
             ((= ARGS 4.)
              (SETQ HOME-X (TV-X (FLOAT (ARG 3.)))
                    HOME-Y (TV-Y (FLOAT (ARG 4.)))))
             ((ERRBREAK 'DISPLAYWINDOW-COLOR
                        '"WRONG NUMBER OF ARGS TO WINDOW FUNCTION")))
       (ERASE-TURTLES)
       ;;Hide the turtle during execution of window display command.
       (COND (WINDOW-PALETTE (DISPLAYWINDOW-TV-COLOR (ARG 1.) 
                                                     WINDOW-INFO
                                                     WINDOW-PICTURE 
                                                     WINDOW-PALETTE 
                                                     HOME-X 
                                                     HOME-Y))
             ;;If there is a palette, its a color window, else a black and white window.
             ((DISPLAYWINDOW-TV WINDOW-INFO WINDOW-PICTURE HOME-X HOME-Y)))
       (DRAW-TURTLES)))))) 

(DECLARE (NOTYPE (DISPLAYWINDOW-STORE-COLOR NOTYPE NOTYPE NOTYPE FIXNUM FIXNUM FIXNUM FIXNUM)))

(DEFUN DISPLAYWINDOW-TV-COLOR 
       (SHOW? WINDOW-INFO WINDOW-PICTURE WINDOW-PALETTE HOME-X HOME-Y)
       (DISPLAYWINDOW-STORE-COLOR SHOW?  
                                  WINDOW-PICTURE
                                  WINDOW-PALETTE
    			          (+ HOME-Y (ARRAYCALL FIXNUM WINDOW-INFO 4.))
			          (+ HOME-Y (ARRAYCALL FIXNUM WINDOW-INFO 5.))
			          (+ HOME-X (ARRAYCALL FIXNUM WINDOW-INFO 6.))
			          (+ HOME-X (ARRAYCALL FIXNUM WINDOW-INFO 7.))))

;;;END OF COLOR CONDITIONAL SECTION.
]


;;*PAGE


;;Should points in the current :ERASERCOLOR be saved in windows and restored
;;when redisplayed? For consistency with operation of the black and 
;;white system, and with treatment of eraser color as background, currently will
;;not redisplay points in eraser color.
;;Should HIDEWINDOW be treated as displaying all points not in the eraser color in 
;;the window in the current eraser color?


[COLOR

(DECLARE (FIXNUM (DECODE-RUN-COLOR FIXNUM) (DECODE-RUN-COUNTER FIXNUM) 
                 RUN-INDEX RUN-STOP THIS-RUN RUN-END))

(DEFUN DECODE-RUN-COLOR (THIS-RUN) (LSH THIS-RUN MINUS-RUN-COLOR-SHIFT))

(DEFUN DECODE-RUN-COUNTER (THIS-RUN) (BITWISE-AND THIS-RUN RUN-COUNTER-MASK))

(DEFUN DISPLAYWINDOW-STORE-COLOR 
       (SHOW? WINDOW-PICTURE WINDOW-PALETTE TOP-Y BOTTOM-Y LEFT-X RIGHT-X)
       ;;For SHOWWINDOW, palette from saved window. For HIDEWINDOW, :ERASERCOLOR's.
       (AND (OR (< TOP-Y TV-PICTURE-TOP)
                (> BOTTOM-Y TV-PICTURE-BOTTOM)
                (< LEFT-X TV-PICTURE-LEFT)
                (> RIGHT-X TV-PICTURE-RIGHT))
            ;;Someday handle this correctly, for now just error.
            (ERRBREAK 'DISPLAYWINDOW-STORE-COLOR 
                      '"WINDOW OUT OF BOUNDS"))
       (DO ((RUN-INDEX 0. (1+ RUN-INDEX))
            (RUN-START LEFT-X NEXT-RUN-START)
            (RUN-END)
            (NEXT-RUN-START)
            (RUN-Y TOP-Y)
            (RUN-STOP (CADR (ARRAYDIMS WINDOW-PICTURE)))
            (THIS-RUN)
            (RUN-COLOR)
            (RUN-COUNTER))
           ((= RUN-INDEX RUN-STOP))
           (SETQ THIS-RUN (ARRAYCALL FIXNUM WINDOW-PICTURE RUN-INDEX)
                 RUN-COLOR (DECODE-RUN-COLOR THIS-RUN)
                 RUN-COUNTER (DECODE-RUN-COUNTER THIS-RUN)
                 NEXT-RUN-START (+ RUN-START RUN-COUNTER)
                 RUN-END (1- NEXT-RUN-START))
           (DO NIL
               ((NOT (> NEXT-RUN-START RIGHT-X)))
               ;;Runs extending past the end of the line.
               (COND ((= RUN-COLOR :ERASERNUMBER))
                     (T (COND (SHOW? 
                               (PENCOLOR (ARRAYCALL NIL WINDOW-PALETTE RUN-COLOR))))
                        (HORIZONTAL-LINE RUN-START RUN-Y RIGHT-X)))
               (SETQ RUN-COUNTER (- RUN-COUNTER (1+ (- RIGHT-X RUN-START)))
                     RUN-START LEFT-X
                     RUN-Y (1+ RUN-Y)
                     NEXT-RUN-START (+ RUN-START RUN-COUNTER)
                     RUN-END (1- NEXT-RUN-START)))
           (COND ((ZEROP RUN-COUNTER))
                 ((= RUN-COLOR :ERASERNUMBER))
                 ;;Don't bother displaying points in current :ERASERCOLOR.
                 (T (COND (SHOW? (PENCOLOR (ARRAYCALL NIL WINDOW-PALETTE RUN-COLOR))))
                    (HORIZONTAL-LINE RUN-START RUN-Y RUN-END)))))]

 
(DECLARE (SPECIAL WINDOWFRAME-BOUNDS)) 

(DEFINE WINDOWFRAME (ABB WF) ARGS 
	;;DRAWS A BOX TO SHOW EXTENT OF RECTANGULAR AREA FOR WINDOW, XGP COMMANDS.
	(OR (AND (ZEROP ARGS) WINDOWFRAME-BOUNDS)
	    (SETQ WINDOWFRAME-BOUNDS (RECTANGLE-SPEC 'WINDOWFRAME
						     (LISTIFY ARGS))))
	(INTERNAL-WINDOWFRAME WINDOWFRAME-BOUNDS)) 

(DEFUN INTERNAL-WINDOWFRAME (RECTANGLE-SPEC) 
       (LET ((TOP-Y (CAR RECTANGLE-SPEC))
	     (BOTTOM-Y (CADR RECTANGLE-SPEC))
	     (LEFT-X (CADDR RECTANGLE-SPEC))
	     (RIGHT-X (CADDDR RECTANGLE-SPEC))
             [BW (OLD-DRAWMODE (DRAWMODE XOR))])
	    (AND (OR (< LEFT-X TV-PICTURE-LEFT)
		     (> RIGHT-X TV-PICTURE-RIGHT)
		     (< TOP-Y TV-PICTURE-TOP)
		     (> BOTTOM-Y TV-PICTURE-BOTTOM))
		 (ERRBREAK 'WINDOWFRAME
			   '"WINDOW FRAME OUT OF BOUNDS"))
	    (OR (= TOP-Y TV-PICTURE-TOP)
		(HORIZONTAL-LINE (1- LEFT-X) (1- TOP-Y) (1+ RIGHT-X)))
	    (OR (= BOTTOM-Y TV-PICTURE-BOTTOM)
		(HORIZONTAL-LINE (1- LEFT-X) (1+ BOTTOM-Y) (1+ RIGHT-X)))
	    (OR (= LEFT-X TV-PICTURE-LEFT)
		(VERTICAL-LINE (1- LEFT-X) TOP-Y BOTTOM-Y))
	    (OR (= RIGHT-X TV-PICTURE-RIGHT)
		(VERTICAL-LINE (1+ RIGHT-X) TOP-Y BOTTOM-Y))
	    [BW (DRAWMODE OLD-DRAWMODE)])
       NO-VALUE) 

(ARGS 'WINDOWFRAME '(0. . 4.)) 

;;WINDOWS CAN BE SHOWN IN VARIOUS MODES.

[BW

(DEFINE SHOWWINDOW (ABB SW) ARGS (LET ((OLD-DRAWMODE (DRAWMODE IOR)))
				      (APPLY 'DISPLAYWINDOW (LISTIFY ARGS))
				      (DRAWMODE OLD-DRAWMODE))
				 NO-VALUE) 

(DEFINE HIDEWINDOW (ABB HW) ARGS (LET ((OLD-DRAWMODE (DRAWMODE ANDC)))
				      (APPLY 'DISPLAYWINDOW (LISTIFY ARGS))
				      (DRAWMODE OLD-DRAWMODE))
				 NO-VALUE) 

(DEFINE XORWINDOW (ABB XW) ARGS (LET ((OLD-DRAWMODE (DRAWMODE XOR)))
				     (APPLY 'DISPLAYWINDOW (LISTIFY ARGS))
				     (DRAWMODE OLD-DRAWMODE))
				NO-VALUE)

;;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
] 

[COLOR

(DEFINE SHOWWINDOW (ABB SW) ARGS
        (LET ((OLD-PENCOLOR :PENCOLOR))
             (SELECT-COLOR :PENNUMBER)
             (APPLY 'DISPLAYWINDOW-COLOR (CONS T (LISTIFY ARGS)))
             (RESELECT-COLOR)
             (PENCOLOR OLD-PENCOLOR))
        NO-VALUE)

(DEFINE HIDEWINDOW (ABB HW) ARGS
        (SELECT-COLOR :ERASERNUMBER)
        (APPLY 'DISPLAYWINDOW-COLOR (CONS NIL (LISTIFY ARGS)))
        (RESELECT-COLOR)
        NO-VALUE)

(DEFINE XORWINDOW (ABB XW) ARGS 
        (NOT-IMPLEMENTED-IN-COLOR (CONS 'XORWINDOW (LISTIFY ARGS))))

(DEFINE DISPLAYWINDOW (ABB DW) ARGS 
        (APPLY (COND (:ERASERSTATE (FUNCTION HIDEWINDOW)) ((FUNCTION SHOWWINDOW)))
               (LISTIFY ARGS)))

;;;END OF COLOR CONDITIONAL SECTION.
]
 
(ARGS 'SHOWWINDOW '(1. . 4.))
(ARGS 'HIDEWINDOW '(1. . 4.))
(ARGS 'XORWINDOW '(1. . 4.)) 

(DEFINE ERASEWINDOW (ABB EW) (WINDOW-NAME) 
	(OR (MEMQ WINDOW-NAME :WINDOWS)
	    (ERRBREAK 'ERASEWINDOW
		      (LIST WINDOW-NAME
			    '"IS NOT A WINDOW")))
	(MAPC '*REARRAY (CAR (REMPROP WINDOW-NAME 'WINDOW)))
	(SETQ :WINDOWS (DELQ WINDOW-NAME :WINDOWS))
	(LIST '/; WINDOW-NAME 'ERASED))

(DEFINE FILLWINDOW (ABB FW) ARGS
        (ERASE-TURTLES)
        (LET ((RECTANGLE-SPEC (RECTANGLE-SPEC 'FILLWINDOW (LISTIFY ARGS))))
             (LET ((TOP-Y (CAR RECTANGLE-SPEC))
                   (BOTTOM-Y (CADR RECTANGLE-SPEC))
                   (LEFT-X (CADDR RECTANGLE-SPEC))
                   (RIGHT-X (CADDDR RECTANGLE-SPEC)))
                  (LET ((MASK (FROM-MASK (BITWISE-AND (PROG1 LEFT-X 
                                                             (SETQ LEFT-X 
                                                                   (LSH LEFT-X -5.)))
                                           31.)))
                        (START-X (+ (SETQ TOP-Y (* 18. TOP-Y)) LEFT-X) (1+ START-X))
                        (STOP-X (+ TOP-Y (LSH RIGHT-X -5.)))
                        (STOP-Y (+ (* 18. BOTTOM-Y) 17.))
                        (STOP-MASK (TO-MASK (BITWISE-AND RIGHT-X 31.))))
                       (COND ((= START-X STOP-X)
                              (SETQ MASK (BITWISE-AND MASK STOP-MASK))
                              (DO ((TV-ADDRESS START-X (+ TV-ADDRESS 18.)))
                                  ((> TV-ADDRESS STOP-Y))
                                  ([BW STORE (TV TV-ADDRESS)]
                                   [COLOR STORE-IOR-TV TV-ADDRESS]
                                   MASK)))
                             (T (DO ((TV-ADDRESS START-X (+ TV-ADDRESS 18.)))
                                    ((> TV-ADDRESS STOP-Y))
                                    ([BW STORE (TV TV-ADDRESS)] 
                                     [COLOR STORE-IOR-TV TV-ADDRESS]
                                     MASK))
                                (DO NIL
                                    ((= (INCREMENT START-X) STOP-X))
                                    (DO ((TV-ADDRESS START-X (+ TV-ADDRESS 18.)))
                                        ((> TV-ADDRESS STOP-Y))
                                        ([BW STORE (TV TV-ADDRESS)]
                                         [COLOR STORE-IOR-TV TV-ADDRESS]
                                         -16.)))
                                (DO ((TV-ADDRESS STOP-X (+ TV-ADDRESS 18.)))
                                    ((> TV-ADDRESS STOP-Y))
                                    ([BW STORE (TV TV-ADDRESS)]
                                     [COLOR STORE-IOR-TV TV-ADDRESS]
                                     STOP-MASK)))))))
        (DRAW-TURTLES)
        NO-VALUE)

(ARGS 'FILLWINDOW '(0. . 4))

(DEFINE ERASEWINDOWS (ABB EWS) NIL 
	(MAPC '(LAMBDA (WINDOW) 
		       (MAPC '*REARRAY (CAR (REMPROP WINDOW 'WINDOW))))
	      :WINDOWS)
	(SETQ :WINDOWS NIL)
	'";ALL WINDOWS ERASED") 

;;PRIMITIVES ACTING MORE OR LESS AS IN 11LOGO.

(DECLARE (SETPLIST 'DISPLAY NIL)
	 ;;COMPILER NEEDS TO DISABLE LISP'S STANDARD DISPLAY FUNCTION.
	 (ARGS 'DISPLAY '(NIL . 1.))) 

;;PUTS THE WINDOW AT THE CURRENT TURTLE LOCATION.

(DEFINE DISPLAY (WINDOW) (SHOWWINDOW WINDOW :XCOR :YCOR)) 

(DEFINE SNAP NIL (MAKEWINDOW (GENSYM))) 

;;*PAGE

;;;		SAVING WINDOWS ON DISK FILES
;;;

(DEFINE SAVEWINDOWS (ABB SWS) FEXPR (FILENAME) 
	(DUMPARRAYS (MAPCAN 
		     '(LAMBDA (WINDOW) (APPEND (GET WINDOW 'WINDOW) NIL))
		     :WINDOWS)
		    ;;DEFAULT SECOND FILE NAME FOR WINDOW FILES IS "WINDOW".
		    (FILESPEC (COND ((CDR FILENAME) FILENAME)
				    ((LIST (CAR FILENAME) 'WINDOW)))))
	:WINDOWS) 

;;SAVEWINDOWS AND GETWINDOWS ALLOW WINDOWS TO BE SAVED ON THE DSK IN BINARY FORMAT,
;;RELOADED. 

(DEFINE GETWINDOWS (ABB GW) FEXPR (FILENAME) 
 ;;LOADARRAYS RETURNS A LIST OF 3-LISTS, CONTAINING: GENSYMED ATOM WITH ARRAY
 ;;PROPERTY, OLD NAME OF ARRAY, SIZE.  DUMPING AND LOADING SQUASHES TWO-DIMENSIONAL
 ;;ARRAYS TO ONE DIMENSION -- TWO DIMENSIONS KEPT IN FIRST TWO ELEMENTS OF THE
 ;;ARRAY.
 (LET
  ((LOADARRAY-LIST (LOADARRAYS (FILESPEC (COND ((CDR FILENAME) FILENAME)
					       ((LIST (CAR FILENAME)
						      'WINDOW)))))))
  (COND ((SAME-SUFFIX (CADAR LOADARRAY-LIST) '-WINDOW-INFO) 
         ;;Old or new format window? 
         (GETWINDOWS-RECREATE-ARRAYS LOADARRAY-LIST))
        ((ERRBREAK 'GETWINDOWS '"OLD FORMAT WINDOW -- PLEASE RECREATE WINDOW FILE")))
  :WINDOWS))

;;Currently has feature which converts old window files to new window format.
;;Should be flushed after a while.


(DECLARE (FIXNUM SYMBOL-INDEX SUFFIX-INDEX))

(DEFUN SAME-SUFFIX (SYMBOL SUFFIX)
       (DO ((SYMBOL-INDEX (FLATC SYMBOL) (1- SYMBOL-INDEX))
            (SUFFIX-INDEX (FLATC SUFFIX) (1- SUFFIX-INDEX)))
           ((ZEROP SUFFIX-INDEX) T)
           (OR (= (GETCHARN SYMBOL SYMBOL-INDEX) (GETCHARN SUFFIX SUFFIX-INDEX))
               (RETURN NIL))))


(DEFUN GETWINDOWS-RECREATE-ARRAYS (LOADARRAY-LIST)
  (DO ((GENSYM-PICTURE) (ARRAY-PICTURE) (OLD-NAME-PICTURE) (OLD-WINDOW) (OLD-NAME-INFO)
        (ARRAY-INFO) (GENSYM-INFO) 
        [COLOR (GENSYM-PALETTE) (ARRAY-PALETTE) (OLD-NAME-PALETTE)])
      ((NULL LOADARRAY-LIST) :WINDOWS)
      (SETQ GENSYM-INFO (CAAR LOADARRAY-LIST)
            OLD-NAME-INFO (COPYSYMBOL (CADAR LOADARRAY-LIST) NIL)
            ARRAY-INFO (GET GENSYM-INFO 'ARRAY)
            GENSYM-PICTURE (CAADR LOADARRAY-LIST)
            ARRAY-PICTURE (GET GENSYM-PICTURE 'ARRAY)
            OLD-NAME-PICTURE (COPYSYMBOL (CADADR LOADARRAY-LIST) NIL))
      (SETQ 
       OLD-WINDOW
       (IMPLODE 
        (NREVERSE (CDR (MEMQ '- (CDR (MEMQ '- (NREVERSE (EXPLODEC OLD-NAME-INFO)))))))))
      (PUTPROP OLD-NAME-INFO ARRAY-INFO 'ARRAY)
      (PUTPROP OLD-NAME-PICTURE ARRAY-PICTURE 'ARRAY)
      [BW (PUTPROP OLD-WINDOW (LIST OLD-NAME-INFO OLD-NAME-PICTURE) 'WINDOW)
          (SETQ LOADARRAY-LIST (CDDR LOADARRAY-LIST))]
      [COLOR 
       (COND ((SAME-SUFFIX (SETQ OLD-NAME-PALETTE (CADR (CADDR LOADARRAY-LIST)))
                           '-WINDOW-PALETTE)
              (SETQ GENSYM-PALETTE (CAADDR LOADARRAY-LIST)
                    ARRAY-PALETTE (GET GENSYM-PALETTE 'ARRAY)
                    OLD-NAME-PALETTE (COPYSYMBOL OLD-NAME-PALETTE NIL))
              (PUTPROP OLD-NAME-PALETTE ARRAY-PALETTE 'ARRAY)
              (PUTPROP OLD-WINDOW 
                       (LIST OLD-NAME-INFO OLD-NAME-PICTURE OLD-NAME-PALETTE)
                       'WINDOW)
              (SETQ LOADARRAY-LIST (CDDDR LOADARRAY-LIST)))
             (T (PUTPROP OLD-WINDOW (LIST OLD-NAME-INFO OLD-NAME-PICTURE) 'WINDOW)
                (SETQ LOADARRAY-LIST (CDDR LOADARRAY-LIST))))]
      (OR (MEMQ OLD-WINDOW :WINDOWS) (PUSH OLD-WINDOW :WINDOWS))))



;;*PAGE

;;;

[BW

(COMMENT INVISIBLE MODE) 

;;;

(DECLARE (ARRAY* (NOTYPE VISIBLE-FUNCTIONS 1.)) (SPECIAL VISIBLE-NUMBER)) 


(FILLARRAY (ARRAY VISIBLE-FUNCTIONS T VISIBLE-NUMBER)
	   '(WRITE-TV-POINT VECTOR HORIZONTAL-LINE VERTICAL-LINE DISPLAYWINDOW 
             TV-CLEARSCREEN SHADE STARTDISPLAY)) 

(DEFINE DO-NOTHING ARGS T) 

(DEFINE INVISIBLE NIL 
	(COND ((AND (GET 'INVISIBLE 'SUBR) (NOT NOUUO))
	       ;;CAN'T REALLY WIN IN NOUUO=NIL MODE.
	       (SETQ IOR SAME XOR SAME ANDC SAME)
	       (DRAWMODE SAME))
	      ((DO ((I 0. (1+ I)))
		   ((= I VISIBLE-NUMBER) NO-VALUE)
		   (RPLACD (VISIBLE-FUNCTIONS I)
			   (CONS 'EXPR
				 (CONS 'DO-NOTHING
				       (CDR (VISIBLE-FUNCTIONS I))))))))) 

(DEFINE VISIBLE NIL 
	(COND ((= IOR SAME) (SETQ IOR 3758096384. ANDC 536870912. XOR 1610612736.))
	      ((DO ((I 0. (1+ I)))
		   ((= I VISIBLE-NUMBER))
		   (AND (EQ (GET (VISIBLE-FUNCTIONS I) 'EXPR)
			    'DO-NOTHING)
			(REMPROP (VISIBLE-FUNCTIONS I) 'EXPR)))))
	(CLEARSCREEN)
	NO-VALUE) 

;;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
] 


;;*PAGE

;;;

(COMMENT RUN LENGTH ENCODING) 

;;;

(DECLARE (FIXNUM (RUN-WORD-FORWARD FIXNUM FIXNUM FIXNUM)
		 (RUN-WORD-BACKWARD FIXNUM FIXNUM FIXNUM)
		 (RUNAWAY-FORWARD FIXNUM FIXNUM FIXNUM)
		 (RUNAWAY-BACKWARD FIXNUM FIXNUM FIXNUM))
	 (NOTYPE (NO-RUN FIXNUM FIXNUM))
	 (FIXNUM PARTIAL-WORD RUN-TYPE START-BIT STOP-BIT RUN-COUNTER START-X
		 START-Y TV-WORD FULL-WORD-RUN START-WORD DIRECTION BITS-WANTED
		 AT-MOST)) 

(DEFUN NO-RUN (PARTIAL-WORD RUN-TYPE) 
       ;;SPECIAL CASE CHECK FOR RUN LENGTH OF ZERO.  HIGH ORDER BIT OF PARTIAL-WORD
       ;;DISAGREES WITH THAT OF RUN TYPE.
       (ZEROP (BITWISE-AND -34359738368. (BOOLE 9. RUN-TYPE PARTIAL-WORD)))) 

;;RUN-WORD-FORWARD AND -BACKWARD PROCESS RUNLENGTHS IN A SINGLE WORD, FORWARD OR
;;BACKWARD STARTING AT A BIT PASSED AS ARGUMENT.  RUNAWAY-FORWARD AND -BACKWARD HAND
;;OFF THE FIRST WORD TO THE PARTIAL WORD SPECIALISTS, ZIP ALONG A WORD AT A TIME
;;UNTIL THE RUN CHANGES, THEN USE THE PARTIAL WORD HACKERS FOR THE LAST WORD.

(DEFUN RUN-WORD-FORWARD (PARTIAL-WORD START-BIT RUN-TYPE) 
       ;;RUN LENGTHS IN PART OF WORD FROM START-BIT RIGHTWARD TO LOW ORDER BIT.
       (COND ((NO-RUN (SETQ PARTIAL-WORD (LSH PARTIAL-WORD START-BIT)) RUN-TYPE) 0.)
	     ;;BOOLE 6 WITH RUN-TYPE FORCES HIGH ORDER RUN TO ZEROS.  HAULONG
	     ;;RETURNS NUMBER OF SIGNIFICANT BITS IN ARG.  AT MOST 32.  BITS OF RUN
	     ;;TO A WORD.
	     ((LET ((BITS-WANTED (- 36. (HAULONG (BOOLE 6. PARTIAL-WORD RUN-TYPE))))
		    (AT-MOST (- 32. START-BIT)))
		   (COND ((< BITS-WANTED AT-MOST) BITS-WANTED) (AT-MOST)))))) 

(DEFUN RUN-WORD-BACKWARD (PARTIAL-WORD STOP-BIT RUN-TYPE) 
       ;;RUN LENGTHS IN PART OF WORD FROM HIGH ORDER BIT RIGHTWARD TO STOP-BIT.  CAN
       ;;THIS BE DONE MORE EFFICIENTLY?
       (SETQ RUN-TYPE (BITWISE-AND RUN-TYPE -34359738368.))
       (DO ((RUN-COUNTER 0. (1+ RUN-COUNTER)))
	   ((OR (MINUSP STOP-BIT)
		;;FINISHED WORD, OR HIGH ORDER BIT CHANGES SIGNALS END OF RUN.
		(MINUSP (BOOLE 6.
			       RUN-TYPE
			       (BITWISE-AND -34359738368.
					    (LSH PARTIAL-WORD STOP-BIT)))))
	    RUN-COUNTER)
	   (DECREMENT STOP-BIT)))

[BW 

(DEFUN RUNAWAY-FORWARD (START-X START-Y RUN-TYPE) 
       (LET ((START-WORD (LSH START-X -5.)) (START-BIT (BITWISE-AND START-X 31.)))
        (LET ((TV-ADDRESS (+ (* START-Y 18.) START-WORD)))
	    (LET ((RUN-COUNTER 
                   (RUN-WORD-FORWARD (TV TV-ADDRESS) START-BIT RUN-TYPE)))
		 (COND ((< RUN-COUNTER (- 32. START-BIT)) RUN-COUNTER)
		       ;;RUN DOESN'T FILL OUT A WHOLE WORD?
		       ((= START-WORD 17.) RUN-COUNTER)
		       ;;END OF SCREEN?
		       ((DO ((FULL-WORD-RUN (COND ((ZEROP RUN-TYPE) 0.) (-16.)))
			     (TV-WORD (TV (INCREMENT TV-ADDRESS)) (TV TV-ADDRESS))
                             ;;STOP-ADDRESS IS FIRST WORD OF NEXT LINE.
                             (STOP-ADDRESS (* (1+ START-Y) 18.)))
			    ;;INCREMENT THE RUN LENGTH A WORD AT A TIME.
			    ((NOT (= TV-WORD FULL-WORD-RUN))
			     ;;ADD IN THE REMAINING PIECE OF THE LAST WORD.
			     (+ RUN-COUNTER (RUN-WORD-FORWARD TV-WORD 0. RUN-TYPE)))
                            (INCREMENT RUN-COUNTER 32.)
			    ;;REACHED THE RIGHT END OF THE SCREEN? IF SO, FINISHED.
			    (AND (= (INCREMENT TV-ADDRESS) STOP-ADDRESS) 
                                 (RETURN RUN-COUNTER))))))))) 

(DEFUN RUNAWAY-BACKWARD (START-X START-Y RUN-TYPE) 
       (LET ((START-WORD (LSH START-X -5.)) 
             (START-BIT (BITWISE-AND START-X 31.))
             (STOP-ADDRESS (* 18. START-Y)))
         (LET ((TV-ADDRESS (+ STOP-ADDRESS START-WORD)))
	    (LET ((RUN-COUNTER 
                   (RUN-WORD-BACKWARD (TV TV-ADDRESS) START-BIT RUN-TYPE)))
		 (COND ((NOT (> RUN-COUNTER START-BIT)) RUN-COUNTER)
		       ((ZEROP START-WORD) RUN-COUNTER)
		       ((DO ((FULL-WORD-RUN (COND ((ZEROP RUN-TYPE) 0.) (-16.)))
			     (TV-WORD (TV (DECREMENT TV-ADDRESS)) (TV TV-ADDRESS)))
			    ((NOT (= TV-WORD FULL-WORD-RUN))
			     (+ RUN-COUNTER
				(RUN-WORD-BACKWARD TV-WORD 31. RUN-TYPE)))
		            (INCREMENT RUN-COUNTER 32.)
			    (AND (< (DECREMENT TV-ADDRESS) STOP-ADDRESS) 
                                 (RETURN RUN-COUNTER)))))))))

 
(DECLARE (FIXNUM (FIND-RIGHT-BOUNDARY FIXNUM FIXNUM) 
                 (FIND-LEFT-BOUNDARY FIXNUM FIXNUM)))

(DEFUN FIND-RIGHT-BOUNDARY (START-X START-Y) 
       (SETQ START-X (+ START-X (RUNAWAY-FORWARD START-X START-Y 0.)))
       ;;RIGHTWARDS RUN UNTIL BOUNDARY REACHED, THEN BACK OFF.
       (COND ((> START-X TV-SCREEN-RIGHT) TV-SCREEN-RIGHT)
             ;;IF PAST THE RIGHT EDGE OF TV SCREEN.
             ((- START-X (RUNAWAY-BACKWARD START-X START-Y -1.)))))

(DEFUN FIND-LEFT-BOUNDARY (START-X START-Y) 
       (SETQ START-X (- START-X (RUNAWAY-BACKWARD START-X START-Y 0.)))
       ;;LEFTWARDS RUN UNTIL BOUNDARY, BACK OFF TO INTERIOR POINT.
       (COND ((MINUSP START-X) 0.)
             ((+ START-X (RUNAWAY-FORWARD START-X START-Y -1.)))))

;;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
] 



[COLOR 

(DECLARE (FIXNUM (RUN-WORD-FORWARD FIXNUM FIXNUM FIXNUM)
		 (RUN-WORD-BACKWARD FIXNUM FIXNUM FIXNUM)
		 (RUNAWAY-FORWARD FIXNUM FIXNUM FIXNUM)
		 (RUNAWAY-BACKWARD FIXNUM FIXNUM FIXNUM)
		 (FIND-RIGHT-BOUNDARY FIXNUM FIXNUM FIXNUM)
		 (FIND-LEFT-BOUNDARY FIXNUM FIXNUM FIXNUM)
		 (RUN-WORD-FORWARD-COLOR FIXNUM FIXNUM FIXNUM FIXNUM)
		 (RUN-WORD-BACKWARD-COLOR FIXNUM FIXNUM FIXNUM FIXNUM))
	 (NOTYPE (NO-RUN FIXNUM FIXNUM) (FULL-WORD-RUN FIXNUM FIXNUM FIXNUM))
	 (FIXNUM PARTIAL-WORD RUN-TYPE START-BIT STOP-BIT RUN-COUNTER START-X
		 WORD-X START-Y TV-WORD FULL-WORD-RUN START-WORD DIRECTION
		 BITS-WANTED AT-MOST MIN-RUN THIS-RUN GOOD-BIT COLOR-BIT
		 COLOR-BITS))

(DEFUN RUNAWAY-FORWARD (START-X START-Y RUN-COLOR) 
       ;;Color version thereof.
       (LET ((START-WORD (LSH START-X -5.)) (START-BIT (\ START-X 32.)))
	    (LET ((RUN-COUNTER (RUN-WORD-FORWARD-COLOR START-Y
						       START-WORD
						       START-BIT
						       RUN-COLOR)))
		 (COND ((< RUN-COUNTER (- 32. START-BIT)) RUN-COUNTER)
		       ;;RUN DOESN'T FILL OUT A WHOLE WORD?
		       ((= START-WORD 17.) RUN-COUNTER)
		       ;;END OF SCREEN?
		       ((DO ((WORD-X (1+ START-WORD)))
			    ((NOT (FULL-WORD-RUN START-Y WORD-X RUN-COLOR))
			     ;;Mildly inefficient as last word processed twice.
			     (+ RUN-COUNTER
				(RUN-WORD-FORWARD-COLOR START-Y
							WORD-X
							0.
							RUN-COLOR)))
			    (SETQ WORD-X (1+ WORD-X) RUN-COUNTER (+ RUN-COUNTER 32.))
			    ;;REACHED THE RIGHT END OF THE SCREEN? IF SO, FINISHED.
			    (AND (> WORD-X 17.) (RETURN RUN-COUNTER)))))))) 

(DEFUN RUNAWAY-BACKWARD (START-X START-Y RUN-COLOR) 
       (LET ((START-WORD (LSH START-X -5.)) (START-BIT (\ START-X 32.)))
	    (LET ((RUN-COUNTER (RUN-WORD-BACKWARD-COLOR START-Y
							START-WORD
							START-BIT
							RUN-COLOR)))
		 (COND ((< RUN-COUNTER (1+ START-BIT)) RUN-COUNTER)
		       ((ZEROP START-WORD) RUN-COUNTER)
		       ((DO ((WORD-X (1- START-WORD)))
			    ((NOT (FULL-WORD-RUN START-Y WORD-X RUN-COLOR))
			     (+ RUN-COUNTER
				(RUN-WORD-BACKWARD-COLOR START-Y
							 WORD-X
							 31.
							 RUN-COLOR)))
			    (SETQ WORD-X (1- WORD-X) RUN-COUNTER (+ RUN-COUNTER 32.))
			    (AND (MINUSP WORD-X) (RETURN RUN-COUNTER)))))))) 

(DECLARE (FIXNUM (RUNAWAY-FORWARD-BOUNDARY FIXNUM FIXNUM)
		 (RUNAWAY-BACKWARD-BOUNDARY FIXNUM FIXNUM))) 

(DEFUN RUNAWAY-FORWARD-BOUNDARY (START-X START-Y) 
       (RUNAWAY-FORWARD START-X START-Y (READ-TV-POINT-NUMBER START-X START-Y))) 

(DEFUN RUNAWAY-BACKWARD-BOUNDARY (START-X START-Y) 
       (RUNAWAY-BACKWARD START-X START-Y (READ-TV-POINT-NUMBER START-X START-Y))) 

(DEFUN FIND-RIGHT-BOUNDARY (START-X START-Y RUN-COLOR) 
       (SETQ START-X (+ START-X (RUNAWAY-FORWARD START-X START-Y RUN-COLOR)))
       ;;RIGHTWARDS RUN UNTIL BOUNDARY REACHED, THEN BACK OFF.
       (COND ((> START-X TV-SCREEN-RIGHT) TV-SCREEN-RIGHT)
             ((- START-X (RUNAWAY-BACKWARD-BOUNDARY START-X START-Y)))))

(DEFUN FIND-LEFT-BOUNDARY (START-X START-Y RUN-COLOR) 
       (SETQ START-X (- START-X (RUNAWAY-BACKWARD START-X START-Y RUN-COLOR)))
       ;;LEFTWARDS RUN UNTIL BOUNDARY, BACK OFF TO INTERIOR POINT.
       (COND ((MINUSP START-X) 0.)
             ((+ START-X (RUNAWAY-FORWARD-BOUNDARY START-X START-Y))))) 

(DEFUN FULL-WORD-RUN (START-Y START-X RUN-COLOR) 
       ;;Returns T if whole word at location is the right color.
       (DO ((COLOR-BIT 0. (1+ COLOR-BIT)) (TV-WORD) (GOOD-BIT))
	   ((= COLOR-BIT COLOR-BITS) T)
	   (SELECT-TV-BUFFER COLOR-BIT)
	   (SETQ TV-WORD (READ-TV START-Y START-X))
	   (COND ((ZEROP (SETQ GOOD-BIT
			       (BITWISE-AND 1. (LSH RUN-COLOR (- COLOR-BIT)))))
		  ;;If selected bit is zero, word should be -1 [remember, memory in
		  ;;complemented state], or vice versa.
		  (COND ((= TV-WORD -16.)) ((RETURN NIL))))
		 ((ZEROP TV-WORD))
		 ((RETURN NIL))))) 

(DEFUN RUN-WORD-FORWARD-COLOR (START-Y START-WORD START-BIT RUN-COLOR) 
       ;;Color version essentially takes minimum run on each of the bits.
       (DO ((MIN-RUN 32.) (THIS-RUN) (COLOR-BIT 0. (1+ COLOR-BIT)))
	   ((= COLOR-BIT COLOR-BITS) MIN-RUN)
	   (SELECT-TV-BUFFER COLOR-BIT)
	   (SETQ THIS-RUN
		 ;;Call ordinary single word run length hacker.
		 (RUN-WORD-FORWARD (BITWISE-NOT (READ-TV START-Y START-WORD))
				   ;;Remember, memory complemented!!!
				   START-BIT
				   (- (BITWISE-AND 1.
						   (LSH RUN-COLOR (- COLOR-BIT))))))
	   (COND ((< THIS-RUN MIN-RUN) (SETQ MIN-RUN THIS-RUN))))) 

(DEFUN RUN-WORD-BACKWARD-COLOR (START-Y START-WORD START-BIT RUN-COLOR) 
       ;;Color version essentially takes minimum run on each of the bits.
       (DO ((MIN-RUN 32.) (THIS-RUN) (COLOR-BIT 0. (1+ COLOR-BIT)))
	   ((= COLOR-BIT COLOR-BITS) MIN-RUN)
	   (SELECT-TV-BUFFER COLOR-BIT)
	   (SETQ THIS-RUN
		 ;;Call ordinary single word run length hacker.
		 (RUN-WORD-BACKWARD (BITWISE-NOT (READ-TV START-Y START-WORD))
				    START-BIT
				    (- (BITWISE-AND 1.
						    (LSH RUN-COLOR (- COLOR-BIT))))))
	   (COND ((< THIS-RUN MIN-RUN) (SETQ MIN-RUN THIS-RUN)))))

;;;END OF COLOR CONDITIONAL SECTION.
]
 
;;*PAGE

;;;

(COMMENT SHADING) 

;;;
;;THE SHADE PRIMITIVE SHADES IN AN AREA ENCLOSING THE TURTLE'S CURRENT LOCATION,
;;SPEICFYING A PATTERN AND OPTIONALY BOUNDARIES.  THE AREA IS BOUNDED BY PRESUMABLY
;;A CLOSED CURVE DRAWN BY THE TURTLE IN PENDOWN MODE.  A PATTERN IS SPECIFIED BY A
;;FUNCTION, WHICH GIVEN THE LOCATION TO BE SHADED, TELLS HOW TO SHADE THAT LOCATION. 
;;THE FUNCTION SHOULD ACCEPT TWO INTEGER ARGUMENTS, X [WORD] AND Y [BIT] SPECIFYING
;;A WORD IN THE TV MEMORY, AND RETURN A FIXNUM INDICATING THE STATE OF THE 32 BITS,
;;LEFT JUSTIFIED.
;;;
;;STARTING AT THE TURTLE'S LOCATION, SUCCESSIVE HORIZONTAL LINES ARE SHADED, UPWARDS
;;AND DOWNWARD, UNTIL THE ENTIRE FIGURE IS SHADED.  SINCE 32 BITS CAN BE SET AT ONCE
;;BY A SINGLE MEMORY WRITE, A HORIZONTAL SCANNING PROCESS RESULTS IN THE FASTEST
;;POSSIBLE SHADING.  SHADE-VERTICALLY INITIATES THE VERTICAL SCAN.  FOR EACH
;;HORIZONTAL LINE, STARTING AT A POINT KNOWN TO BE IN THE INTERIOR OF THE FIGURE, WE
;;SEARCH LEFT AND RIGHT UNTIL WE HIT THE BOUNDARY OF THE FIGURE.  LEFT-X AND RIGHT-X
;;ARE LAST INTERIOR POINTS BEFORE LEFT AND RIGHT BOUNDARY, RESPECTIVELY.  THE
;;PREVIOUS VALUES OF LEFT-X AND RIGHT-X FOR THE IMMEDIATELY LAST LINE SHADED ARE
;;ALWAYS KEPT AS SHADED-LEFT-X AND SHADED-RIGHT-X.  WHEN LEFT-X EXCEEDS THE LAST
;;VALUE OF SHADED-RIGHT-X, WE'VE HIT THE TOP OR BOTTOM BOUNDARY OF THE FIGURE, AND
;;VERTICAL SHADING IS TERMINATED.  THE NEXT HORIZONTAL LINE IS SHADED STARTING FROM
;;THE POINT IN THE COLUMN OF PREVIOUS LEFT-X.
;;;
;;THE SUBTLETLY IN THE PROGRAM CONSISTS OF TWO REFINEMENTS TO THE ABOVE NAIVE
;;PROCEDURE.  FIRST, WE HAVE TO BE ABLE TO SHADE "AROUND CORNERS".  THERE ARE 3
;;TYPES OF CORNERS THAT CAN OCCUR: [ASSUME SHADING IS PROCEDING UPWARD, POINTS ON
;;MARKED WITH "|".]
;;;
;;;         ||LEFT-X                RIGHT-X|||| NEW SCAN [UP]   ||
;;;         ||							||
;;;         ||SHADED-LEFT-X   ..INTERIOR...       SHADED-RIGHT-X||
;;;
;;;--------------------------------------------------------------------------------
;;ABOVE IS "S-TURN" -- NEW SCAN PROCEEDS IN SAME DIRECTION AS OLD.  BELOW ARE
;;"U-TURNS" SHADING PROCEEDS IN OPPOSITE DIRECTION.
;;;
;;;         ||LEFT-X                                         RIGHT-X||
;;;	    ||							    ||
;;;         ||SHADED-LEFT-X    SHADED-RIGHT-X||||| NEW SCAN [DOWN]  ||
;;;
;;;--------------------------------------------------------------------------------
;;;
;;;         ||LEFT-X  ..INTERIOR...                              RIGHT-X||
;;;	    ||                                                          ||
;;;         ||    NEW SCAN [DOWN]   ||||||SHADED-LEFT-X   SHADED-RIGHT-X||
;;;
;;;--------------------------------------------------------------------------------
;;;
;;EACH NEW SCAN CAUSED BY TURNING A CORNER CAUSES A RECURSIVE CALL TO
;;SHADE-VERTICALLY.  IT IS NOT NECESSARY TO DETECT THE FOURTH CASE, WHERE LEFT-X
;;INCREASES, SINCE THE SCAN IN THE NEXT LINE IS STARTED FROM LEFT-X. 
;;;
;;THE SHADING PROCESS MUST ALSO KEEP SOME INFORMATION ABOUT WHERE IT HAS BEEN.  IT
;;MUST KEEP TRACK OF WHAT AREAS HAVE ALREADY BEEN SHADED, SO THAT THE PROCESS CAN BE
;;TERMINATED WHEN SHADING AN AREA WITH HOLES, PREVENTING THE SCAN FROM CIRCLING THE
;;HOLE FOREVER.  SINCE AN ARBITRARY SHADING PATTERN MAY BE USED, NO INFORMATION ON
;;THE SCREEN CAN BE USED TO DETECT WHEN SCAN REACHES A PREVIOUSLY SHADED REGION. 
;;THE PROGRAM KEEPS TWO LISTS OF "OPEN" EDGES, WHICH MIGHT BE REACHED BY A VERTICAL
;;SCAN.  INITIALLY, AND WHEN A RECURSIVE CALL TO SHADE-VERTICALLY IS MADE, THE LAST
;;SHADED EDGE IS PUT ON THE LIST OF OPEN EDGES IN THE DIRECTION OF VERTICAL SHADING. 
;;EDGES ARE REMOVED WHEN SAFE, I.E.  WHEN THE CALL RETURNS.  THE LISTS ARE ORDERED
;;VERTICALLY, AND THE CLOSEST EDGE IS COMPUTED INITIALLY, TO SAVE SEARCHING THE
;;LIST.  AS THE VERTICAL SHADING PROCEEDS, IT IS CHECKED AGAINST THE OPPOSITE
;;DIRECTION OPEN EDGE, AND SHADING STOPS IF IT HITS. 
;;;

(DECLARE (NOTYPE (INTERNAL-SHADE NOTYPE FIXNUM FIXNUM)
		 (SHADE-HORIZONTAL-LINE FIXNUM FIXNUM FIXNUM))) 

(DECLARE (FIXNUM START-X START-Y TRAVEL-X TRAVEL-Y HORIZONTAL-DIRECTION
		 VERTICAL-DIRECTION INITIAL-LEFT-BOUNDARY INITIAL-RIGHT-BOUNDARY
		 RETURN-LEFT RETURN-RIGHT SHADED-LEFT-X SHADED-RIGHT-X MASK STOP-X
		 LEFT-X RIGHT-X SHADED-Y CLOSEST-OPEN)
	 (SPECIAL SHADING-PATTERN)) 

(DECLARE (SPECIAL PATTERN-WINDOW PATTERN-INFO 
                  PATTERN-WINDOW-SIZE-X PATTERN-WINDOW-SIZE-Y)
	 (FIXNUM (INVOKE-WINDOW-PATTERN FIXNUM FIXNUM) PATTERN-WINDOW-SIZE-X
		 PATTERN-WINDOW-SIZE-Y)
         (NOTYPE (SHADE-FUNCTION-PATTERN NOTYPE FIXNUM FIXNUM)
                 (SHADE-WINDOW-PATTERN NOTYPE FIXNUM FIXNUM)))

(DEFINE SHADE ARGS 
	(LET ([BW (OLD-DRAWMODE (DRAWMODE IOR))]
	      (TV-XCOR (TV-X :XCOR))
	      (TV-YCOR (TV-Y :YCOR))
              (PATTERN))
	     ;;TURTLE HIDDEN DURING SHADING SO AS NOT TO MESS UP SEARCH FOR
	     ;;BOUNDARIES.  WILL REAPPEAR AFTER SHADING.
	     (ERASE-TURTLES)
             [COLOR (NO-COLOR-WRITE)]
	     ;;DEFAULT SHADING PATTERN IS SOLID.
	     (COND ((ZEROP ARGS) (INTERNAL-SHADE (EXPR-FUNCTION SOLID) TV-XCOR TV-YCOR))
                   ((SETQ PATTERN (GET (ARG 1.) 'WINDOW))
		    (SHADE-WINDOW-PATTERN PATTERN TV-XCOR TV-YCOR))
                   ((SETQ PATTERN (FUNCTION-PROP (ARG 1.)))
                    (COND ((EQ (CAR PATTERN) 'SUBR) 
                           (INTERNAL-SHADE (CADR PATTERN) TV-XCOR TV-YCOR))
                          ((SHADE-FUNCTION-PATTERN (ARG 1.) TV-XCOR TV-YCOR))))
                   ((ERRBREAK 'SHADE (LIST (ARG 1.) '"IS NOT A SHADING PATTERN"))))
             [COLOR (COLOR-WRITE)]
	     (DRAW-TURTLES)
	     [BW (DRAWMODE OLD-DRAWMODE)]
	     NO-VALUE)) 

(DEFUN SHADE-WINDOW-PATTERN (WINDOW-PROP TV-XCOR TV-YCOR) 
       (LET ((PATTERN-WINDOW (GET (CADR WINDOW-PROP) 'ARRAY)))
	    (LET ((PATTERN-INFO (GET (CAR WINDOW-PROP) 'ARRAY)))
		 (LET ((PATTERN-WINDOW-SIZE-X (1+ (- (ARRAYCALL FIXNUM
								PATTERN-INFO
								7.)
						     (ARRAYCALL FIXNUM
								PATTERN-INFO
								6.))))
		       (PATTERN-WINDOW-SIZE-Y (1+ (- (ARRAYCALL FIXNUM
								PATTERN-INFO
								5.)
						     (ARRAYCALL FIXNUM
								PATTERN-INFO
								4.)))))
		      (INTERNAL-SHADE (EXPR-FUNCTION INVOKE-WINDOW-PATTERN) 
                                      TV-XCOR 
                                      TV-YCOR)))))

(DECLARE (SPECIAL FUNCTION-PATTERN) (FIXNUM (INVOKE-FUNCTION-PATTERN FIXNUM FIXNUM)))

(DEFUN SHADE-FUNCTION-PATTERN (FUNCTION-PATTERN TV-XCOR TV-YCOR)
       (INTERNAL-SHADE (EXPR-FUNCTION INVOKE-FUNCTION-PATTERN) TV-XCOR TV-YCOR))

(DEFUN INVOKE-FUNCTION-PATTERN (START-X START-Y) 
       (FUNCALL FUNCTION-PATTERN START-X START-Y))

(DECLARE (FIXNUM NEW-EDGE-Y)) 



[BW  

(DEFUN SHADE-HORIZONTAL-LINE (FROM-X FROM-Y TO-X) 
       ;;THIS IS BASICALLY THE SAME CODE AS HORIZONTAL-LINE.  I DIDN'T MERGE THEM
       ;;BECAUSE DRAWING LINES NEEDS TO HAPPEN ABSOLUTELY AS FAST AS POSSIBLE.
       (DO ((MASK (BITWISE-AND (FROM-MASK (BITWISE-AND (PROG1 FROM-X 
                                                    (SETQ FROM-X (LSH FROM-X -5.)))
					      31.))
			       (EXPR-CALL-FIXNUM SHADING-PATTERN FROM-X FROM-Y))
		  (EXPR-CALL-FIXNUM SHADING-PATTERN (INCREMENT FROM-X) FROM-Y))
            (TV-ADDRESS (+ (* 18. FROM-Y) FROM-X) (1+ TV-ADDRESS))
	    (STOP-ADDRESS (+ (* 18. FROM-Y) (LSH TO-X -5.))))
           ((= TV-ADDRESS STOP-ADDRESS)
            (STORE (TV STOP-ADDRESS) 
                   (BITWISE-AND MASK (TO-MASK (BITWISE-AND TO-X 31.))))
            T)
	   (STORE (TV TV-ADDRESS) MASK)))


(DEFUN RUNAWAY-FORWARD-BOUNDARY (START-X START-Y) (RUNAWAY-FORWARD START-X START-Y -1.))

(DEFUN RUNAWAY-BACKWARD-BOUNDARY (START-X START-Y) (RUNAWAY-BACKWARD START-X START-Y -1.))

;;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
] 


[COLOR


(DEFUN SHADE-HORIZONTAL-LINE (FROM-X FROM-Y TO-X) 
       (COLOR-WRITE)
       (LET ((START-WORD (LSH FROM-X -5.))
	     (START-BIT (BITWISE-AND FROM-X 31.))
	     (STOP-WORD (LSH TO-X -5.))
	     (STOP-BIT (BITWISE-AND TO-X 31.)))
	    (COND ((= START-WORD STOP-WORD)
		   (STORE-TV-FIELD (+ (* 18. FROM-Y) START-WORD)
				   (EXPR-CALL-FIXNUM SHADING-PATTERN
						     START-WORD
						     FROM-Y)
				   START-BIT
				   STOP-BIT))
		  (T (STORE-TV-FIELD (+ (* FROM-Y 18.) START-WORD)
				     (EXPR-CALL-FIXNUM SHADING-PATTERN
						       START-WORD
						       FROM-Y)
				     START-BIT
				     31.)
		     (WRITE-TV-MASK 0.)
		     (DO ((TV-ADDRESS (* 18. FROM-Y))
                          (WORD-X (1+ START-WORD) (1+ WORD-X)))
			 ((= WORD-X STOP-WORD)
                          (STORE-TV-FIELD 
                           (+ TV-ADDRESS STOP-WORD)
                           (EXPR-CALL-FIXNUM SHADING-PATTERN STOP-WORD FROM-Y)
                           0.
                           STOP-BIT))
			 (STORE (TV (+ TV-ADDRESS WORD-X))
				(EXPR-CALL-FIXNUM SHADING-PATTERN WORD-X FROM-Y))))))
       (NO-COLOR-WRITE))

;;;END OF COLOR CONDITIONAL SECTION.
]




(DECLARE (NOTYPE (INTERNAL-SHADE NOTYPE FIXNUM FIXNUM)
                 (SHADE-VERTICALLY FIXNUM FIXNUM FIXNUM FIXNUM NOTYPE NOTYPE 
                                   [COLOR FIXNUM])
                 (SHADE-HORIZONTAL-LINE FIXNUM FIXNUM FIXNUM))
         (FIXNUM (RUNAWAY-FORWARD-INTERIOR FIXNUM FIXNUM)
                 (RUNAWAY-BACKWARD-INTERIOR FIXNUM FIXNUM))
         (FIXNUM INITIAL-LEFT INITIAL-RIGHT VERTICAL-DIRECTION TRAVEL-Y LEFT-X RIGHT-X
                 OPEN-Y OPEN-LEFT OPEN-RIGHT INTERIOR-RIGHT INTERIOR-LEFT INTERIOR-X))

(DECLARE (EVAL (READ)))

;;Conditional switch for debugging showing visual progress of shading scans,
;;by blacking out open edges.

(OR (BOUNDP 'DEBUG-SHADE) (SETQ DEBUG-SHADE NIL))

(DEFUN INTERNAL-SHADE (SHADING-PATTERN START-X START-Y) 
       [BW (AND (READ-TV-POINT START-X START-Y)
                (ERRBREAK 'SHADE '"SHADING MUST START INSIDE A CLOSED CURVE"))]
       ;;Shade up and down from starting point. Initial point must be off.
      (LET ([COLOR (AREA-COLOR (READ-TV-POINT-NUMBER START-X START-Y))])
       (LET ((INITIAL-LEFT (FIND-LEFT-BOUNDARY START-X START-Y [COLOR AREA-COLOR]))
             ;;Boundaries from starting point.
	     (INITIAL-RIGHT (FIND-RIGHT-BOUNDARY START-X START-Y [COLOR AREA-COLOR])))
            ;;Shade the first line found.
            (SHADE-HORIZONTAL-LINE INITIAL-LEFT START-Y INITIAL-RIGHT)
            (LET ((INITIAL-EDGE (LIST START-Y INITIAL-LEFT INITIAL-RIGHT)))
                 (DO ((OPEN-SAME (LIST 'OPEN-POSITIVE INITIAL-EDGE))
                      ;;Lists of vertical scans yet to be performed, one
                      ;;of scans in the same direction as VERTICAL-DIRECTION,
                      ;;one opposite. The upward scans are ordered from top to
                      ;;bottom, the downward scans bottom to top.
                      (OPEN-OPPOSITE (LIST 'OPEN-NEGATIVE INITIAL-EDGE))
                      ;;Initial scan is in downward direction.
                      (VERTICAL-DIRECTION 1.)
                      (COMPARE-Y GREATER-SUBR)
                      (SCAN-EDGE))
                     ((COND ((NULL (CDR OPEN-SAME))
                             ;;No more scans to be done in this direction. If none
                             ;;in the other direction as well, stop. Else reverse
                             ;;directions.
                             (COND ((NULL (CDR OPEN-OPPOSITE)))
                                   (T (SETQ OPEN-OPPOSITE 
                                            (PROG1 OPEN-SAME 
                                                   (SETQ OPEN-SAME OPEN-OPPOSITE))
                                            VERTICAL-DIRECTION (- VERTICAL-DIRECTION)
                                            COMPARE-Y (COND ((EQ COMPARE-Y GREATER-SUBR)
                                                             LESS-SUBR)
                                                            (GREATER-SUBR)))
                                      NIL)))))
                     ;;Remove the edge to be scanned from the OPEN-SAME list,
                     ;;and send it off to start a vertical shading scan.
                     (SHADE-VERTICALLY (CADR (SETQ SCAN-EDGE (CADR OPEN-SAME))) 
                                       (CAR SCAN-EDGE) 
                                       (CADDR SCAN-EDGE)
                                       VERTICAL-DIRECTION  
                                       (RPLACD OPEN-SAME (CDDR OPEN-SAME))
                                       ;;Only pass along the part of the list
                                       ;;which will be past the start of the scan.
                                       (DO ((REST-OPEN OPEN-OPPOSITE (CDR REST-OPEN)))
                                           ((OR (NULL (CDR REST-OPEN))
                                                (SUBRCALL NIL COMPARE-Y 
                                                         (CAADR REST-OPEN)
                                                         (CAR SCAN-EDGE)))
                                            REST-OPEN))
                                       [COLOR AREA-COLOR]))))))


;;*PAGE


(DEFUN OPEN-INCLUDE (OPEN-EDGE OPEN-LIST)
       [DEBUG-SHADE 
        (HORIZONTAL-LINE (CADR OPEN-EDGE) (CAR OPEN-EDGE) (CADDR OPEN-EDGE))]
       (RPLACD OPEN-LIST (CONS OPEN-EDGE (CDR OPEN-LIST))))

[DEBUG-SHADE (DEFUN SHADE-OPEN (LEFT Y RIGHT)
                    (DRAWMODE ANDC)
                    (HORIZONTAL-LINE LEFT Y RIGHT)
                    (DRAWMODE IOR)
                    (SHADE-HORIZONTAL-LINE LEFT Y RIGHT))]

;;These two functions start on a point assumed to be neighboring the border, 
;;return the next point in that direction which could be in the interior of a region.

[BW (DECLARE (FIXNUM (FIND-INTERIOR-FORWARD FIXNUM FIXNUM)
                     (FIND-INTERIOR-BACKWARD FIXNUM FIXNUM)))

    (DEFUN FIND-INTERIOR-FORWARD (INTERIOR-X INTERIOR-Y)
           ;;Increment the point to get onto the border, compute run from there.
           (+ (INCREMENT INTERIOR-X) (RUNAWAY-FORWARD INTERIOR-X INTERIOR-Y -1.)))

    (DEFUN FIND-INTERIOR-BACKWARD (INTERIOR-X INTERIOR-Y)
           (- (DECREMENT INTERIOR-X) (RUNAWAY-BACKWARD INTERIOR-X INTERIOR-Y -1.)))]

[COLOR (DECLARE (FIXNUM (FIND-INTERIOR-FORWARD FIXNUM FIXNUM FIXNUM)
                        (FIND-INTERIOR-BACKWARD FIXNUM FIXNUM)
                        BORDER-COLOR))

       (DEFUN FIND-INTERIOR-FORWARD (INTERIOR-X INTERIOR-Y INTERIOR-COLOR)
              (DO ((BORDER-COLOR 
                    (READ-TV-POINT-NUMBER (INCREMENT INTERIOR-X) INTERIOR-Y)
                    ;;The color of the next border region.
                    (READ-TV-POINT-NUMBER INTERIOR-X INTERIOR-Y)))
                  ((= BORDER-COLOR INTERIOR-COLOR) INTERIOR-X)
                  ;;Stop when the color is the same as the interior.
                  (SETQ INTERIOR-X 
                        (+ INTERIOR-X (RUNAWAY-FORWARD INTERIOR-X 
                                                       INTERIOR-Y 
                                                       BORDER-COLOR)))
                  (AND (> INTERIOR-X TV-PICTURE-RIGHT) (RETURN INTERIOR-X))))

       (DEFUN FIND-INTERIOR-BACKWARD (INTERIOR-X INTERIOR-Y INTERIOR-COLOR)
              (DO ((BORDER-COLOR 
                    (READ-TV-POINT-NUMBER (DECREMENT INTERIOR-X) INTERIOR-Y)
                    (READ-TV-POINT-NUMBER INTERIOR-X INTERIOR-Y)))
                  ((= BORDER-COLOR INTERIOR-COLOR) INTERIOR-X)
                  (SETQ INTERIOR-X 
                        (- INTERIOR-X (RUNAWAY-BACKWARD INTERIOR-X 
                                                        INTERIOR-Y 
                                                        BORDER-COLOR)))
                  (AND (< INTERIOR-X TV-PICTURE-LEFT) (RETURN INTERIOR-X))))]




;;*PAGE


(DEFUN SHADE-VERTICALLY (SHADED-LEFT SHADED-Y SHADED-RIGHT VERTICAL-DIRECTION
                         OPEN-SAME OPEN-OPPOSITE [COLOR AREA-COLOR])
       ;;This function performs the vertical shading scan. The first 3 args
       ;;are a previously shaded edge from which to start. VERTICAL-DIRECTION is +1 
       ;;or -1. The OPEN variables are lists of pending vertical scans.
       [DEBUG-SHADE (SHADE-OPEN SHADED-LEFT SHADED-Y SHADED-RIGHT)]
       (DO ((TRAVEL-Y (+ SHADED-Y VERTICAL-DIRECTION))
            (STOP-Y (COND ((MINUSP VERTICAL-DIRECTION) TV-PICTURE-TOP)
                          (TV-PICTURE-BOTTOM)))
            (LEFT-X) 
            (RIGHT-X) 
            (NONE-OPEN (NULL (CDR OPEN-OPPOSITE)))
            (OPEN-Y (CAADR OPEN-OPPOSITE))
            (OPEN-LEFT (CADADR OPEN-OPPOSITE))
            (OPEN-RIGHT (CADDR (CADR OPEN-OPPOSITE)))
            (MEET-OPEN NIL)
            (INTERIOR-X))
           ;;End the scan after meeting an open edge.
           (MEET-OPEN)
           (AND (= TRAVEL-Y STOP-Y) (RETURN T))
           ;;Stop if past legal display area.
           (DO NIL
               ;;This loop checks to see if scan meets the closest open edge.
               ((COND (NONE-OPEN)
                      ;;If none exist, or haven't yet reached closest Y value, 
                      ;;answer is NO.
                      ((NOT (= TRAVEL-Y OPEN-Y)))
                      ((AND (NOT (< SHADED-LEFT OPEN-LEFT))
                            (NOT (> SHADED-LEFT OPEN-RIGHT)))
                       ;;If within X values for open edge, answer is YES.
                       (SETQ MEET-OPEN T))))
               ;;Otherwise, we met an edge to the left or right of current scan
               ;;starting point. Pop it off and run the next one around the loop.
               (COND ((SETQ NONE-OPEN (NULL (CDR (POP OPEN-OPPOSITE)))))
                     ((SETQ OPEN-Y (CAADR OPEN-OPPOSITE)
                            OPEN-LEFT (CADADR OPEN-OPPOSITE)
                            OPEN-RIGHT (CADDR (CADR OPEN-OPPOSITE))))))
           (COND (MEET-OPEN
                  ;;If we met an open edge, make the current edge the piece of
                  ;;the open edge from the start point of the scan.
                  (SETQ LEFT-X SHADED-LEFT RIGHT-X OPEN-RIGHT)
                  (COND ((> SHADED-LEFT OPEN-LEFT)
                         ;;If there's any piece of the open edge that still needs
                         ;;to be done, alter its RIGHT X component.
                         [DEBUG-SHADE
                          (SHADE-OPEN OPEN-LEFT OPEN-Y OPEN-RIGHT)
                          (HORIZONTAL-LINE OPEN-LEFT OPEN-Y (1- SHADED-LEFT))]
                         (RPLACA (CDDADR OPEN-OPPOSITE) (1- SHADED-LEFT)))
                        ;;Otherwise, just remove the whole thing.
                        (T [DEBUG-SHADE 
                            (SHADE-OPEN (CADADR OPEN-OPPOSITE)
                                        (CAADR OPEN-OPPOSITE)
                                        (CADDR (CADR OPEN-OPPOSITE)))]
                           (RPLACD OPEN-OPPOSITE (CDDR OPEN-OPPOSITE)))))
                 (T (AND (> (SETQ LEFT-X 
                                  (FIND-LEFT-BOUNDARY SHADED-LEFT 
                                                      TRAVEL-Y 
                                                      [COLOR AREA-COLOR]))
                         ;;If scan for left boundary takes you past previous right
                         ;;boundary, you've hit the top or bottom boundary, stop.
                         SHADED-RIGHT)
                        (RETURN T))
                    ;;SEARCH FOR RIGHTMOST BOUNDARY OF FIGURE.  START FROM LEFT
          	    ;;BOUNDARY, OR IF PREVOUS LEFT BOUND WAS GREATER, START FROM THAT
                    ;;SINCE AREA BETWEEN THEM HAS BEEN SEARCHED BY FIND-LEFT-BOUNDARY.
                    (SETQ RIGHT-X
         		(FIND-RIGHT-BOUNDARY (COND ((> LEFT-X SHADED-LEFT) LEFT-X)
                                                   (SHADED-LEFT))
    				             TRAVEL-Y
        				     [COLOR AREA-COLOR]))
                    ;;DO THE ACTUAL SHADING.
	            (SHADE-HORIZONTAL-LINE LEFT-X TRAVEL-Y RIGHT-X)))
                  
          ;;Check for shading around turning corners.
          (COND ((< LEFT-X SHADED-LEFT)
                 ;;Shade LEFT U-turn.
                 (COND ((< (SETQ INTERIOR-X
                                 (FIND-INTERIOR-BACKWARD SHADED-LEFT 
                                                         SHADED-Y 
                                                         [COLOR AREA-COLOR])) 
                           LEFT-X))
                       ;;If the next candidate for interior point is within
                       ;;the region, add a new open edge to scan the missing piece.
                       (T (OPEN-INCLUDE (LIST TRAVEL-Y LEFT-X INTERIOR-X) 
                                        OPEN-OPPOSITE)
                          ;;Since we added an edge, have to pop to keep in
                          ;;the same place.
                          (POP OPEN-OPPOSITE)))))
          ;;We need not check the s-turn case for left side, since the vertical
          ;;scan always crawls along the left side of the figure.
          (COND ((> RIGHT-X SHADED-RIGHT)
                 (COND ((> (SETQ INTERIOR-X 
                                 (FIND-INTERIOR-FORWARD SHADED-RIGHT 
                                                        SHADED-Y 
                                                        [COLOR AREA-COLOR]))
                           RIGHT-X))
                       (T (OPEN-INCLUDE (LIST TRAVEL-Y INTERIOR-X RIGHT-X) 
                                        OPEN-OPPOSITE)
                          (POP OPEN-OPPOSITE))))
                ((> SHADED-RIGHT RIGHT-X)
                 (COND ((> (SETQ INTERIOR-X 
                                 (FIND-INTERIOR-FORWARD RIGHT-X 
                                                        TRAVEL-Y
                                                        [COLOR AREA-COLOR]))
                           SHADED-RIGHT))
                       ((OPEN-INCLUDE (LIST SHADED-Y INTERIOR-X SHADED-RIGHT) 
                                      OPEN-SAME)))))
          (SETQ SHADED-LEFT LEFT-X 
		SHADED-RIGHT RIGHT-X 
                SHADED-Y TRAVEL-Y
		TRAVEL-Y (+ TRAVEL-Y VERTICAL-DIRECTION))))


;;*PAGE

;;;
;;;			SHADING PATTERNS
;;;
;;PREDEFINED SHADING PATTERNS.  THE USER CAN ALSO SUPPLY NEW ONES.

(DECLARE (FIXNUM (CHECKER FIXNUM FIXNUM)
		 (GRID FIXNUM FIXNUM)
		 (LIGHTGRID FIXNUM FIXNUM)
		 (HORIZLINES FIXNUM FIXNUM)
		 (VERTLINES FIXNUM FIXNUM)
		 (SOLID FIXNUM FIXNUM)
		 (TEXTURE FIXNUM FIXNUM)
		 (LIGHTTEXTURE FIXNUM FIXNUM)
		 (DARKTEXTURE FIXNUM FIXNUM))) 


(DEFINE SOLID (X Y) -16.) 

(DEFINE CHECKER (X Y) (COND ((ODDP Y) -22906492256.) (22906492240.))) 

(DEFINE GRID (X Y) (COND ((ODDP Y) -16.) (-22906492256.))) 

(DEFINE HORIZLINES (X Y) (COND ((ODDP Y) -16.) (0.))) 

(DEFINE VERTLINES (X Y) -22906492256.) 

(DEFINE TEXTURE (X Y) (BITWISE-AND -16. (RANDOM))) 

(DEFINE DARKTEXTURE (X Y) (BITWISE-AND -16. (BITWISE-OR (RANDOM) (RANDOM)))) 

(DEFINE LIGHTTEXTURE (X Y) (BITWISE-AND -16. (RANDOM) (RANDOM))) 

(DECLARE (NOTYPE (VERTICAL-SCAN NOTYPE FIXNUM FIXNUM FIXNUM))) 

(DECLARE (FIXNUM WINDOW-INDEX-X WINDOW-INDEX-Y WINDOW-LEFT-X WINDOW-TOP-Y
		 PATTERN-WINDOW-SIZE-X PATTERN-WINDOW-SIZE-Y PATTERN-WORD
		 WINDOW-INDEX-BIT WINDOW-INDEX-START-Y WINDOW-INDEX-WORD
		 BITS-RECEIVED BITS-NEEDED TO-WINDOW-SIZE-X TO-WORD-BOUNDARY)
         (FIXNUM INVOKE-WINDOW-PATTERN FIXNUM FIXNUM)) 

(DEFUN INVOKE-WINDOW-PATTERN (PATTERN-X PATTERN-Y) 
       ;;ACCESSES THE WINDOW ARRAY OF A USER SHADING PATTERN CORRECTLY SO AS TO
       ;;RETURN THE STATE OF THE 32 BITS OF THE TV WORD ACCESSED BY PATTERN-X AND
       ;;PATTERN-Y.  THE OTHER PARAMETERS ARE PECULIAR TO EACH WINDOW ARRAY, AND ARE
       ;;BOUND BY SHADE, ACCESSED GLOBALLY HERE.
       (LET ((WINDOW-INDEX-Y (\ PATTERN-Y PATTERN-WINDOW-SIZE-Y))
	     ;;CHANGE X WORD NUMBER TO BIT NUMBER.  SMASH X AND Y DOWN INTO THE
	     ;;RANGE OF THE WINDOW.
	     (WINDOW-INDEX-X (\ (LSH PATTERN-X 5.) PATTERN-WINDOW-SIZE-X)))
	    (LET ((WINDOW-INDEX-BIT (\ WINDOW-INDEX-X 36.))
		  ;;CONVERT WINDOW X TO BIT AND WORD INDICES.
		  (WINDOW-INDEX-WORD (// WINDOW-INDEX-X 36.))
		  ;;DISTANCE FROM CURRENT PLACE IN WINDOW TO RIGHT EDGE OF WINDOW.
		  (TO-WINDOW-SIZE-X (- PATTERN-WINDOW-SIZE-X WINDOW-INDEX-X)))
              (LET ((WINDOW-START (* WINDOW-INDEX-Y 
                                     (ARRAYCALL FIXNUM PATTERN-INFO 0.))))
                 (INCREMENT WINDOW-INDEX-WORD WINDOW-START)
		 (DO ((PATTERN-WORD 
                       (LSH (ARRAYCALL FIXNUM PATTERN-WINDOW WINDOW-INDEX-WORD)
                            WINDOW-INDEX-BIT)
                       ;;BUILD UP THE TV WORD BY INCLUSIVE ORING PIECES
                       ;;FROM SEVERAL WINDOW ARRAY WORDS, IF NEED BE.
                       (BITWISE-OR PATTERN-WORD
                                   (LSH 
                                    (ARRAYCALL FIXNUM PATTERN-WINDOW WINDOW-INDEX-WORD)
                                    (- BITS-RECEIVED))))
		      (BITS-RECEIVED (MIN TO-WINDOW-SIZE-X
					  (- 36. WINDOW-INDEX-BIT))
				     (+ BITS-RECEIVED WINDOW-INDEX-BIT))
		      ;;HOW MANY BITS OBTAINED SO FAR, HOW MANY MORE DESIRED, UP TO
		      ;;32.  EACH TIME WE ADD AMOUNT OF THE NEW WINDOW INDEX BIT --
		      ;;SINCE WE ALWAYS OR IN INITIAL SEGMENT OF ANOTHER WORD.
		      (BITS-NEEDED 0.)
		      ;;NUMBER OF BITS REMAINING IN THE CURRENT WORD.
		      (TO-WORD-BOUNDARY (- 36. WINDOW-INDEX-BIT)
					(- 36. WINDOW-INDEX-BIT)))
		     ((> BITS-RECEIVED 31.) (BITWISE-AND PATTERN-WORD -16.))
		     (SETQ BITS-NEEDED (- 32. BITS-RECEIVED))
		     (COND ((< TO-WINDOW-SIZE-X TO-WORD-BOUNDARY)
			    ;;REACHED RIGHT EDGE OF WINDOW IN THE CURRENT WORD,
			    ;;"WRAP AROUND" TO THE FIRST WORD IN THE WINDOW.
			    (SETQ WINDOW-INDEX-WORD WINDOW-START)
			    (COND ((< BITS-NEEDED PATTERN-WINDOW-SIZE-X)
				   ;;WILL THERE BE ENOUGH BITS IN THAT WORD TO
				   ;;SATISFY US?
				   (SETQ WINDOW-INDEX-BIT
					 BITS-NEEDED
					 TO-WINDOW-SIZE-X
					 (- PATTERN-WINDOW-SIZE-X WINDOW-INDEX-BIT)))
				  ((SETQ WINDOW-INDEX-BIT PATTERN-WINDOW-SIZE-X 
					 TO-WINDOW-SIZE-X 0.))))
			   ;;CROSS BOUNDARY OF WORD.
			   ((INCREMENT WINDOW-INDEX-WORD)
			    (SETQ WINDOW-INDEX-BIT (MIN (- TO-WINDOW-SIZE-X
							   TO-WORD-BOUNDARY)
							BITS-NEEDED) 
				  TO-WINDOW-SIZE-X (- TO-WINDOW-SIZE-X
						      WINDOW-INDEX-BIT
						      TO-WORD-BOUNDARY))))))))) 

;;*PAGE

;;;

(COMMENT XGP HARD COPY) 

;;;
;;;
;;WRITE A FILE OF CHARACTERS WHICH CAN BE PRINTED ON XGP USING SPECIAL FONTS
;;DESIGNED FOR THE PURPOSE.
;;;
;;PROBLEM: WHEN LISP TYO'S A CARRIAGE RETURN TO A FILE, IT ALSO SUPPLIES A LINE
;;FEED, WHICH CAUSES THE LINE TO END.  THIS NEEDS TO BE CORRECTED BY A LAP SUBR TO
;;OUTPUT JUST A CR.
;;;

[BW 

(DECLARE (*EXPR OUTPUT-RAW-CR-TO-DISK)) 


(LAP OUTPUT-RAW-CR-TO-DISK SUBR)
	(HLLOS 0 NOQUIT)
	(MOVEI A 15)
	(PUSHJ P UTTYO)
	(MOVEI A '15)
	(HLLZS 0 NOQUIT)
	(PUSHJ P CHECKI)
	(POPJ P)
NIL 
 

;;THE WIDTH OF THE PICTURE PRINTED IS LIMITED TO ABOUT HALF THE WITDTH OF THE
;;SCREEN, SINCE CHARACTERS CANNOT BE OUTPUT TO THE XGP FAST ENOUGH TO INSURE THAT
;;THEY ALL GET PRINTED IN TIME BEFORE THE NEXT LINE.
;;;
;; ONE WAY TO POSSIBLY GET AROUND THIS IS TO USE MULTIPLE FONTS, PERHAPS A FONT WITH
;;RUN LENGTH ENCODING.

(DECLARE (NOTYPE (INTERNAL-XGP NOTYPE NOTYPE FIXNUM NOTYPE))
	 (FIXNUM START-WORD STOP-WORD TRAVEL-X TRAVEL-Y STOP-BIT START-BIT ENV
		 LFTMAR THIS-WORD XGP-CHAR TRAVEL-WORD)
	 (SPECIAL ^R ^W *NOPOINT)) 

(DEFINE XGP FEXPR (ARGLIST ENV) 
	(XGP-DECODE-ARGS '"LLOGO;TVRTLE KST"
			 300.
			 ARGLIST
			 ENV)
	NO-VALUE) 

;;PROVIDE DEFAULTS, VARIOUS MEANS OF SPECIFYING ARGS.

(DEFUN XGP-DECODE-ARGS (FONT LFTMAR XGP-ARGLIST ENV) 
       (LET ((FILE))
	    (COND ((ATOM (CAR XGP-ARGLIST))
		   (SETQ FILE (FILESPEC (DO NIL
					    ((OR (NULL XGP-ARGLIST)
						 (NUMBERP (CAR XGP-ARGLIST)))
					     (NREVERSE FILE))
					    (PUSH (CAR XGP-ARGLIST) FILE)
					    (POP XGP-ARGLIST)))))
		  ((SETQ FILE (FILESPEC (EVAL (CAR XGP-ARGLIST) ENV)) 
			 XGP-ARGLIST (CDR XGP-ARGLIST))))
	    (INTERNAL-XGP FILE
			  FONT
			  LFTMAR
			  (RECTANGLE-SPEC 'XGP
					  (MAPCAR '(LAMBDA (RECTANGLE-ARG) 
							   (EVAL RECTANGLE-ARG ENV))
						  XGP-ARGLIST))))) 

(DECLARE (NOTYPE (XGP-TYO FIXNUM))
	 (NOTYPE (PRINT-XGP-CHARACTERS FIXNUM FIXNUM FIXNUM FIXNUM))) 

(DEFUN INTERNAL-XGP (FILE FONT LFTMAR RECTANGLE) 
       (APPLY 'UWRITE (LIST (CADDR FILE) (CADDDR FILE)))
       ;;WRITE FIRST PAGE OF XGP HEADER INFORMATION.
       (LET ((^R T)
	     (^W T)
	     (TOP-Y (CAR RECTANGLE))
	     (BOTTOM-Y (CADR RECTANGLE))
	     (LEFT-X (CADDR RECTANGLE))
	     (RIGHT-X (CADDDR RECTANGLE))
	     (*NOPOINT T))
	    (PRINC '"
;RESET
;SKIP 1
;VSP 0
;KSET ")    (PRINC FONT)
	    (PRINC '"
;LFTMAR ")  (PRINC LFTMAR)
	    (TERPRI)
	    (TYO 12.)
	    (PRINT-XGP-CHARACTERS LEFT-X RIGHT-X TOP-Y BOTTOM-Y))
       (APPLY 'UFILE FILE)) 

;;XGP printout uses a run length encoded font.  Outputs ascii characters which are
;;printed in a font consisting of runs of from 1 to 64 zeros, and 1 to 64 ones.

(SETQ RUN-MAX 64. 
      ;;Maximum run length, bit specifying type of run.
      RUN-TYPE-SHIFT 6.) 

(DECLARE (SPECIAL RUN-MAX RUN-TYPE-SHIFT)
	 (FIXNUM TRAVEL-X TRAVEL-Y NEW-TRAVEL-X RUN-TYPE RUN-LENGTH
		 RUN-LENGTH-REMAINING LINE-Y RUN-MAX RUN-TYPE-SHIFT THIS-RUN)
	 (NOTYPE (PRINT-XGP-CHARACTERS FIXNUM FIXNUM FIXNUM FIXNUM)
		 (PRINT-XGP-LINE FIXNUM FIXNUM FIXNUM)
		 (RUN-OUT FIXNUM FIXNUM)
		 (RUN-TYO FIXNUM FIXNUM))) 

(DEFUN PRINT-XGP-CHARACTERS (LEFT-X RIGHT-X TOP-Y BOTTOM-Y) 
       (DO ((TRAVEL-Y TOP-Y (1+ TRAVEL-Y)))
	   ((> TRAVEL-Y BOTTOM-Y))
	   ;;Print a line of characters, then carriage return.
	   (PRINT-XGP-LINE LEFT-X TRAVEL-Y RIGHT-X)
	   (TERPRI))) 

(DEFUN PRINT-XGP-LINE (START-X LINE-Y STOP-X) 
       ;;Prints one line of XGP characters.
       (DO ((RUN-TYPE -1. (- -1. RUN-TYPE))
	    ;;Alternate between runs of zeros & ones.
	    (THIS-RUN)
	    (TRAVEL-X START-X NEW-TRAVEL-X)
	    ;;Is this off by 1?
	    (NEW-TRAVEL-X))
	   ((> (SETQ THIS-RUN (RUNAWAY-FORWARD TRAVEL-X LINE-Y RUN-TYPE) 
		     ;;Compute run length, and end of run.
		     NEW-TRAVEL-X (+ TRAVEL-X THIS-RUN))
	       ;;Is end of run past right edge of area to print?
	       STOP-X)
	    (COND ((ZEROP RUN-TYPE))
		  ;;Output remaining run, but don't bother if zeros.
		  ((RUN-OUT RUN-TYPE (- STOP-X TRAVEL-X -1.)))))
	   ;;Output the current run.
	   (RUN-OUT RUN-TYPE THIS-RUN))) 

(DEFUN RUN-OUT (RUN-TYPE RUN-LENGTH) 
       ;;Output RUN-LENGTH bits in the specified type.  Chunks of maximum run length
       ;;successively output until exhausted.
       (DO ((RUN-LENGTH-REMAINING RUN-LENGTH (- RUN-LENGTH-REMAINING RUN-MAX)))
	   ((< RUN-LENGTH-REMAINING RUN-MAX)
	    (OR (ZEROP RUN-LENGTH-REMAINING) (RUN-TYO RUN-TYPE RUN-LENGTH-REMAINING))
	    T)
	   (RUN-TYO RUN-TYPE RUN-MAX))) 

(DEFUN RUN-TYO (RUN-TYPE RUN-LENGTH) 
       (XGP-TYO (BITWISE-OR (LSH (- RUN-TYPE) RUN-TYPE-SHIFT)
			    ;;High order bit is type of run length, lower order bits
			    ;;are run count [off by 1 from ascii value]. 
			    (1- RUN-LENGTH)))
       T) 

(DEFUN XGP-TYO (XGP-CHAR) 
       ;;WEIRD CHARACTERS MUST BE PRECEDED BY RUBOUT IN ORDER TO PRINT THE FONT'S
       ;;DEFINITION OF THE CHARACTER.  CR HANDLED SPECIALLY TO AVOID INSERTION OF
       ;;LINEFEED.
       (COND ((= XGP-CHAR 13.) (TYO 127.) (OUTPUT-RAW-CR-TO-DISK))
	     ((MEMBER XGP-CHAR '(0. 8. 9. 10. 12. 127.))
	      (TYO 127.)
	      (TYO XGP-CHAR))
	     ((TYO XGP-CHAR)))
       T) 


;;;END OF BLACK-AND-WHITE CONDITIONAL SECTION.
] 
 

;;*PAGE

;;;

(COMMENT SKETCHING) 

;;;

(DEFUN READ-EOF (EOF-VALUE)
       (LET ((READ-RESULT (READ EOF-VALUE))) 
            (COND ((NULL ^Q) EOF-VALUE) (READ-RESULT))))


(DECLARE (FLONUM SKETCH-FROM-X SKETCH-FROM-Y SKETCH-TO-X SKETCH-TO-Y END-OF-FILE))

(DEFINE READSKETCH FEXPR (SKETCH-FILE) 
	;;SLURPS SKETCH MADE ON DM'S TABLET USING PROGRAM ON HENRY;SKETCH >.
	(CLEARSCREEN)
	(HIDETURTLE)
	(PENDOWN)
	(APPLY 'UREAD SKETCH-FILE)
	(DO ((SKETCH-FROM-X) (SKETCH-FROM-Y) (SKETCH-TO-X) (SKETCH-TO-Y)
             (OBARRAY LISP-OBARRAY) (READTABLE LISP-READTABLE) (^Q T)
             (END-OF-FILE -99999.0)
             (HORIZONTAL (EXPR-FUNCTION HORIZONTAL-LINE)) 
             (VERTICAL (EXPR-FUNCTION VERTICAL-LINE)))
	    ((OR (= (SETQ SKETCH-FROM-X (READ-EOF END-OF-FILE)) END-OF-FILE)
                 (= (SETQ SKETCH-FROM-Y (READ-EOF END-OF-FILE)) END-OF-FILE)
                 (= (SETQ SKETCH-TO-X (READ-EOF END-OF-FILE)) END-OF-FILE)
                 (= (SETQ SKETCH-TO-Y (READ-EOF END-OF-FILE)) END-OF-FILE))
	     (SETQ ^Q NIL))
	    ;;SLURP FOUR POINTS AND DRAW VECTOR.
	    (BOUNDED-VECTOR SKETCH-FROM-X SKETCH-FROM-Y SKETCH-TO-X SKETCH-TO-Y))
	NO-VALUE) 

;;*PAGE


(DECLARE (SPECIAL :BRUSH BRUSH-INFO BRUSH-PICTURE)
         (FIXNUM BRUSH-X BRUSH-Y)
         (NOTYPE (HORIZONTAL-BRUSHSTROKE FIXNUM FIXNUM FIXNUM)
                 (VERTICAL-BRUSHSTROKE FIXNUM FIXNUM FIXNUM)
                 (DISPLAYWINDOW-TV NOTYPE NOTYPE FIXNUM FIXNUM)))

(DEFUN HORIZONTAL-BRUSHSTROKE (FROM-X FROM-Y TO-X)
       (DO ((BRUSH-X FROM-X (1+ BRUSH-X)))
           ((> BRUSH-X TO-X))
           (DISPLAYWINDOW-TV BRUSH-INFO BRUSH-PICTURE BRUSH-X FROM-Y)))
                             
(DEFUN VERTICAL-BRUSHSTROKE (FROM-X FROM-Y TO-Y)
       (DO ((BRUSH-Y FROM-Y (1+ BRUSH-Y)))
           ((> BRUSH-Y TO-Y))
           (DISPLAYWINDOW-TV BRUSH-INFO BRUSH-PICTURE FROM-X BRUSH-Y)))

(DEFINE BRUSH (BRUSH)
       (LET ((BRUSH-WINDOW-PROP (GET BRUSH 'WINDOW)))
            (COND (BRUSH-WINDOW-PROP
                   (SETQ :BRUSH BRUSH
                         BRUSH-INFO (GET (CAR BRUSH-WINDOW-PROP) 'ARRAY)
                         BRUSH-PICTURE (GET (CADR BRUSH-WINDOW-PROP) 'ARRAY) 
                         HORIZONTAL (EXPR-FUNCTION HORIZONTAL-BRUSHSTROKE)
                         VERTICAL (EXPR-FUNCTION VERTICAL-BRUSHSTROKE)))
                  ((ERRBREAK 'BRUSHDOWN (LIST BRUSH '"IS NOT A WINDOW")))))
       NO-VALUE)


(DEFINE NOBRUSH NIL 
       (SETQ :BRUSH NIL
             BRUSH-INFO NIL
             BRUSH-PICTURE NIL
             HORIZONTAL (EXPR-FUNCTION HORIZONTAL-LINE)
             VERTICAL (EXPR-FUNCTION VERTICAL-LINE))
       NO-VALUE)






