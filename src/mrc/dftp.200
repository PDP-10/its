TITLE DFTP  Datacomputer File Transfer Program
SUBTTL Switches, definitions, etc.

IFNDEF F.PCAP,<F.PCAP==0>	; 0 IF PRIVILEGED CAPABILITIES UNRESTRICTED

IF1,<PRINTX DFTP...
IFN F.PCAP,<PRINTX Privileged capabilities restricted>
IFE F.PCAP,<PRINTX Privileged capabilities unrestricted>
>
IF2,<PRINTX ...is halfway...>

; REGISTER DEFINITIONS

	R1==1
	R2==2
	R3==3
	R4==4
	R5==5
	R6==6
	R7==7
	R10==10
	R11==11
	R12==12
	R13==13
	R14==14
	R15==15
	R16==16
	R17==17

;	(SCRATCH REGISTERS)
	X1==1
	X2==2
	X3==3
	X4==4

;	(COMMONLY USED REGISTERS)
	IO==R5
	BP==R6
	FLAG==R15
	UTIL==R16
	STAK==R17

;	(TERMINAL COMMAND INPUT (RECOGNIZER) REGISTERS)
	TCIO==R2		; IO(REGISTER)
	TCIBP==R3		; B(YTE)P(OINTER)
	TCIACB==R4		; A(DDRESSOF)C(ONTROL)B(LOCK)
	TCITLP==R5		; T(RACE)L(IST)P(OINTER)
	TCITCC==R6		; T(RACE)C(OMMAND)C(OUNTER)
	TCIPBP==R7		; P(ARALLEL)B(YTE)P(OINTER)
	TCIPCC==R10		; P(ARALLEL)C(HARACTER)C(OUNTER)
	TCISBP==R11		; S(ERIAL)B(YTE)P(OINTER)
	TCISCC==R12		; S(ERIAL)C(HARACTER)C(OUNTER)
	TCIMAC==R13		; MA(TCHES--)C(OMMANDS)
	TCIMAN==R14		; MA(TCHES--)N(ULLCHARACTER)

IFN 0,<	;.XCREF is for the "@" listing program and should be ignored by MACRO-10
	.XCREF R1,R2,R3,R4,R5,R6,R7,R10,R11,R12,R13,R14,R15,R16,R17
	.XCREF X1,X2,X3,X4,IO,BP,FLAG,UTIL,STAK
>;IFN 0
	SUBTTL Definitions

	DCHOST==37
	DCSOKT==203

	DEFALO==12

	SIZBLK==200
	SIZPAG==1000

	LBSIZE==100
	SBSIZE==20
	SUBTTL Macro Definitions for "Routines"

	SALL

DEFINE	BEGINR(SAVLST,%RETN)
<	..SAVL==0
	..SAVC==0
	IFIDN <SAVLST><ALL>,<..SAVL==77777>
	IFDIF <SAVLST><ALL>,<
		IRP SAVLST,<
			IFG <SAVLST>-20,<!!
				PRINTX SAVLST NOT A REGISTER>
			IFLE <SAVLST>-20,<
				IFN ..SAVL&1_SAVLST,<!!
					PRINTX SAVLST SAVED TWICE>
				..SAVL==..SAVL!1_SAVLST
				..SAVC==..SAVC+1>>>
	IFN ..SAVL,<
		..REG==17
		REPEAT 20,<
			IFN ..SAVL&1_..REG,<PUSH STAK,..REG>
			..REG==..REG-1>>
	DEFINE	.%RETN <%RETN>	; UNIQUE LOCATION FOR RETURN AND ENDR
	DEFINE	.%RETL <%RETN':!>
	..SFLG==0		; LARGEST SKIP RETURN
>

; IF RETURN CAN'T BE POPJ, THEN IT ASSEMBLES AS JRST TO ENDR CODE
;   JRST TO .%RETN FOR NOSKIP RETURN, .%RETN-N FOR SKIP RETURN
;   ..SFLG SIGNALS THAT SKIP CODE MUST BE ASSEMBLED IN ENDR
DEFINE	RETURN(SK,N)
<<IFB <SK>,<<IFE ..SAVC,<POPJ STAK,.%RETN>>+<IFN ..SAVC,<JRST .%RETN>>>>+<IFIDN <SK><SKIP>,<<IFG N-..SFLG,<..SFLG==N>>*0+<JRST .%RETN-N>>>>

; RETURN FOR USE WITH CONDITIONAL JUMPS
DEFINE	RETN(N)
<<IFB <N>,<<IFE ..SAVC,<.%RETN>>+<IFN ..SAVC,<.%RETN>>>>+<IFNB <N>,<<IFG N-..SFLG,<..SFLG==N>>*0+<.%RETN-N>>>>

; ENDR DECRIMENTS STAK, RESTORES REGS, RETURNS (POSSIBLY SKIPPING)
DEFINE	ENDR(SK,N)
<	IFB <SK>,<..N==0>
	IFIDN <SK><SKIP>,<..N==N
		IFG <..N-..SFLG>,<..SFLG==..N>>
	IFN <..SFLG>,<IFN <..N-..SFLG>,<JRST .%RETN-..N>
		REPEAT ..SFLG,<
			AOS -..SAVC(STAK)>>
	.%RETL
	..REG==0
	REPEAT 20,<
		IFN ..SAVL&1_..REG,<POP STAK,..REG
			..SAVL==..SAVL-1_..REG>
		..REG==..REG+1>
	POPJ STAK,>

DEFINE	CALLR(ROUTIN)
<	PUSHJ	STAK,ROUTIN>
	SUBTTL Other Macro definitions

DEFINE	TAIN(MSG)
<	HRRZI	X1,MSG
	CALLR	$TAIN$>

DEFINE	TCIN(CLIST,RSTR)
<	MOVE	TCIO,[RSTR,,CLIST]
	CALLR	$TCIN$>

DEFINE	TSIN(BUFFER,BUFS,MSG,NOECHO)
<	MOVE	IO,[BUFFER,,<5*BUFS>-1]
	IFB <NOECHO>,< HRRZI	UTIL,MSG>
	IFNB <NOECHO>,< HRROI	UTIL,MSG>
	CALLR	$TSIN$>

DEFINE	TNIN(MSG,RADIX)
<	IFB <RADIX>,< MOVE	IO,[MSG,,^D10]>
	IFNB <RADIX>,< MOVE	IO,[MSG,,RADIX]>
	CALLR	$TNIN$>

DEFINE	TNOUT(REG,RADIX)
<	IFN <X1-REG>,< MOVE	X1,REG>
	IFB <RADIX>,< HRRZI	X2,^D10>
	IFNB <RADIX>,< HRRZI	X2,RADIX>
	CALLR	$NOUT$>

DEFINE	DCNOUT(REG,RADIX)
<	IFN <X1-REG>,< MOVE	X1,REG>
	IFB <RADIX>,< HRROI	X2,^D10>
	IFNB <RADIX>,< HRROI	X2,RADIX>
	CALLR	$NOUT$>

DEFINE	PATH(STRING,FLAGS)
<	IFB <FLAGS>,< HRRZI	FLAG,STRING>
	IFNB <FLAGS>,<
		HRRI	FLAG,STRING
		HRLI	FLAG,FLAGS>
	CALLR	$PATH$>

DEFINE	SCOPY(SOURCE,DESTIN)
<	CAIA
	 IDPB	0,DESTIN
	ILDB	0,SOURCE
	JUMPN	0,.-2
	MOVE	SOURCE,DESTIN
	IDPB	0,SOURCE
>;SCOPY
DEFINE	XTCIL <		;(e)X(pand) T(erminal) C(ommand) I(nput) L(ist)
	..CMCH==0
	..CMWD==0
	..CNUM==0
	DEFINE TCIE (NAME, ROUTINE)
	<	..CNUM==..CNUM+1
		..IDX==0
		IRPC NAME<..IDX==..IDX+1>
		IFG <..IDX-..CMCH>,<..CMCH==..IDX>
	>;TCIE
	TCIL
	..CMWD==<<<..CMCH-1>/5>+1>

	.+4+..CNUM
	..CNUM
	..CMCH
	..CMWD

	DEFINE TCIE (NAME,ROUTINE)
	<	ROUTINE
	>;TCIE
	TCIL

	DEFINE TCIE (NAME,ROUTINE)
	<	ASCII	/NAME/
		..IDX==0
		IRPC NAME<..IDX==..IDX+1>
		..IDX==<..CMWD-<<<..IDX-1>/5>+1>>
		IFG ..IDX,<REPEAT ..IDX, <0>>
	>;TCIE
	TCIL
>;XTCIL
	SUBTTL System Dependent Definitions for ITS

	SEARCH SITS
	LOC 150

	OPDEF THUD [.LOSE 1000]

;  Initialization routine, since have to load with DEC LOADER/LINK-10
; under DECUUO.  First load using DEC loader, flush DECUUO with 45$G
; and then D system command, then do INIT$G(or 150$G if no symbols).

INIT:	MOVSI (JUMPA)
	HRR .JBSA##
	.BREAK 12,[400001,,]		;set start address
	SETZ 1,
	MOVE [1,,2]
	BLT 150
	.VALUE
	JRST DFTP

; I/O Channels

	TTI==1		; TTY I/O
	TTO==2
	DCI==3		; Datalanguage I/O
	DCO==4
	ICP==5		; ICP channel
	DDI==6		; Data I/O
	DDO==7
	LCI==10		; Local input
	LCO==11		; Local output
 
; ITS network definitions

%NSCLS==0
%NSLSN==1
%NSRFC==2
%NSRCL==3
%NSRFS==4
%NSOPN==5
%NSRFN==6
%NSCLW==7
%NSCLI==10
%NSINP==11

DEFINE TBIN(REG)
<	.IOT TTI,REG
	CAIN REG,15
	 MOVEI REG,12
	CAIG REG,"z"
	 CAIGE REG,"a"
	  CAIA
	   TRZ REG," "
>;TBIN

OPDEF TBOUT [.IOT TTO,]


DEFINE TSOUT(STRING)
<	IRP STRING
<	MOVEI X1,STRING
	CALLR $STRIN
>>

;  Routine to output an ASCIZ string under ITS because cretinous MACRO cannot
; return a character count for SIOT.

$STRIN:	BEGINR
	HRLI X1,(POINT 7,)		; build a byte pointer
$STRI1:	ILDB X1				; get a character from string
	JUMPE RETN(0)			; quit when done
	.IOT TTO,			; output the character
	JRST $STRI1
	ENDR

DEFINE DCBIN(REG)
<	.IOT DCI,REG
	JUMPLE REG,QUIT2
	SKIPE FLAGDD
	 .IOT TTO,REG
>

OPDEF DCBOUT [.IOT DCO,]

DEFINE DCSOUT(STRING)
<	IRP STRING
<	MOVEI X1,STRING
	CALLR $DSTRI
>>

;  Routine to output an ASCIZ string under ITS because cretinous MACRO cannot
; return a character count for SIOT.

$DSTRI:	BEGINR
	HRLI X1,440700			; build a byte pointer
$DSTR1:	ILDB X1				; get a character from string
	JUMPE RETN(0)			; quit when done
	.IOT DCO,			; output the character
	SKIPE FLAGDD			; show DATALANGUAGE?
	 .IOT TTO,
	JRST $DSTR1			; and loop for more
	ENDR
	SUBTTL Main Program

DFTP:	MOVE STAK,[IOWD STSIZ,STBEG]	; load PDP
	CALLR S$INIT			; do system-dependant init
	CALLR D$INIT			; do DC init

; (((PCAP UNRESTRICTED)))
IFE F.PCAP,<
	MOVEI UTIL,CMDM3
	.OPEN ['DSK'
	       SIXBIT/_DFTP_/
	       SIXBIT/ENABLE/]
	 MOVEI UTIL,CMDM2	; CAN ENABLE LATER ON
>
; (((^^^)))
; (((PCAP RESTRICTED))))
IFN F.PCAP,<
	MOVEI UTIL,CMDM2
	.SUSET [.RXUNAME,,X1]
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVEI
		[('DSK')]
		['.FILE.']
		['(DIR) ']
		SETZ X1]
	MOVEI UTIL,CMDM1	; NO ITS DIRECTORY
>
; (((^^^)))
	.CLOSE
	MOVEM	UTIL,CMDMOD
	JRST	CMDCMD
RENTER:	MOVE	STAK,[IOWD STSIZ,STBEG]
CMDNEW:	TSOUT	<CRLF>
CMDCMD:	JRST	@CMDMOD
CMDM1:	TSOUT	<[ASCIZ/*/]>
	TCIN	(CMDMC1,[ASCIZ/*/])
	 JRST	CMDCMD
	 JRST	CMDNEW
	JRST	(FLAG)
CMDM2:	TSOUT	<[ASCIZ/*/]>
	TCIN	(CMDMC2,[ASCIZ/*/])
	 JRST	CMDCMD
	 JRST	CMDNEW
	JRST	(FLAG)
CMDM3:	TSOUT	<[ASCIZ/!/]>
	TCIN	(CMDMC3,[ASCIZ/!/])
	 JRST	CMDCMD
	 JRST	CMDNEW
	JRST	(FLAG)
	SUBTTL Terminal Input Dispatch Tables

DEFINE TCIL <
IFG ..MODE-2,<	TCIE ALLOCATE,CALO >
		TCIE ATTACH,CATT
		TCIE BIG,CBIG
IFG ..MODE-2,<	TCIE CHANGE,CCHA >
		TCIE CONNECT,CCON
IFG ..MODE-2,<	TCIE CREATE,CCRE >
		TCIE DELETE,CDEL
		TCIE DIRECTORY,CDIR
IFG ..MODE-2,<	TCIE DISABLE,CDIS >
IFE ..MODE-2,<	TCIE ENABLE,CENA >
		TCIE EXAMINE,CEXA
		TCIE EXPUNGE,CEXP
		TCIE GET,CGET
IFG ..MODE-2,<	TCIE LINK,CLIN >
		TCIE LIST,CLIS
		TCIE LOCAL-CONNECT,CLOC
		TCIE NO-DATALANGUAGE,CNOD
		TCIE PUT,CPUT
		TCIE QUIT,CQUI
		TCIE REMOVE,CREM
		TCIE RENUMBER,CREN
		TCIE RETRIEVE,CRET
		TCIE SHOW-DATALANGUAGE,CSOD
		TCIE STORE,CSTO
		TCIE TERSE,CTER
		TCIE TIME-TRANSFERS,CTTR
IFG ..MODE-2,<	TCIE TOP-LEVEL,CTOP >
		TCIE UNDELETE,CUND
		TCIE UNTIME-TRANSFERS,CUTR
		TCIE VERBOSE,CVER
>;TCIL

CMDMC1:	..MODE==1
	XTCIL
CMDMC2:	..MODE==2
	XTCIL
CMDMC3:	..MODE==3
	XTCIL
	SUBTTL Top level commands

CALO:	PATH	([ASCIZ/ ALLOCATE /],PATHNR!PATHCA)
	 JRST	CMDCMD
	TSOUT	<[ASCIZ/ Megabits: /]>
CALO1:	TNIN	([ASCIZ/ Megabits: /])
	 JRST	CMDCMD
	JUMPN	IO,CALO2
	MOVEI	IO,"G"-100
	TBOUT	<IO>
	JRST	CALO1
CALO2:	MOVEM	IO,ABUF
	TSOUT	<CRLF>
	CALLR	DALO
	JRST	CMDCMD

CATT:	PATH	([ASCIZ/ ATTACH /],PATHNR!PATHCT)
	 JRST	CMDCMD
	CALLR	DATT
	JRST	CMDCMD

CBIG:	PATH	([ASCIZ/ BIG /],PATHNR!PATHCA)
	 JRST	CMDCMD
	CALLR	DBIG
	JRST	CMDCMD

CCHA:	PATH	([ASCIZ/ CHANGE /],PATHNR!PATHCC!PATHAD!PATHAC)
	 JRST	CMDCMD
	CALLR	DCHA
	JRST	CMDCMD

CCON:	PATH	([ASCIZ/ CONNECT /],PATHNR!PATHCA!PATHAD)
	 JRST	CMDCMD
	CALLR	DCON
	JRST	CMDCMD

CCRE:	PATH	([ASCIZ/ CREATE /],PATHNR!PATHCA)
	 JRST	CMDCMD
	CALLR	DCRE
	JRST	CMDCMD

CDEL:	PATH	([ASCIZ/ DELETE /],PATHNP!PATHFR!PATHAS!PATHAC!PATHAV)
	 JRST	CMDCMD
	CALLR	DDEL
	JRST	CMDCMD

CDIR:	PATH	([ASCIZ/ DIRECTORY /],PATHNP!PATHFR!PATHAS!PATHAV)
	 JRST	CMDCMD
	MOVE	IO,CMDMOD
	CAIN	IO,CMDM3
	 JRST	CDIR1
	TSOUT	<[ASCIZ/**/]>
	TCIN	(CDIRC,[ASCIZ/**/])
	 JRST	CMDCMD
	 JRST	CDIR2
	JRST	CDIR3
CDIR1:	TSOUT	<[ASCIZ/!!/]>
	TCIN	(CDIRC,[ASCIZ/!!/])
	 JRST	CMDCMD
	 JRST	CDIR2
	JRST	CDIR3
CDIR2:	MOVEI	FLAG,DD$T
	TSOUT	<[ASCIZ/TERSE/]>
CDIR3:	TSOUT	<CRLF>
	CALLR	DDIR
	JRST	CMDCMD

CDIRC:
DEFINE TCIL <
	TCIE DELETED,DD$D
	TCIE TERSE,DD$T
	TCIE VERBOSE,DD$V
>;TCIL
	XTCIL

CDIS:	TSOUT	<CRLF>
	MOVEI	UTIL,CMDM2
	MOVEM	UTIL,CMDMOD
	JRST	CMDCMD

CENA:	TSOUT	<CRLF>
	MOVEI	UTIL,CMDM3
	MOVEM	UTIL,CMDMOD
	JRST	CMDCMD

CEXA:	PATH	([ASCIZ/ EXAMINE /],PATHNP!PATHFR!PATHAV!PATHAS)
	 JRST	CMDCMD
	TSOUT	<[ASCIZ/ Lines per page: /]>
	TNIN	([ASCIZ/ Lines per page: /])
	 JRST	CMDCMD
	JUMPN	IO,CEXA0
	SKIPN	IO,DEXA$P
	 MOVEI	IO,^D20
	TNOUT	<IO>
CEXA0:	MOVEM	IO,DEXA$P
	TSOUT	<CRLF>
	MOVE	UTIL,VBUF
	LDB	IO,[350700,,FBUF]
	CAIN	IO,"*"
	 SETO	UTIL,
	LDB	IO,[350700,,EBUF]
	CAIN	IO,"*"
	 SETO	UTIL,
	MOVEM	UTIL,DEXA$S
	CALLR	DEXA
	 JRST	CMDCMD
	JRST	CMDCMD

CEXP:	PATH	([ASCIZ/ EXPUNGE /],PATHNR!PATHCC!PATHAD!PATHAC)
	 JRST	CMDCMD
	CALLR	DEXP
	JRST	CMDCMD

CGET:	PATH	([ASCIZ/ GET /],PATHNP!PATHFR!PATHRL!PATHAV!PATHAS)
	 JRST	CMDCMD
	CALLR	DGET
	 JRST	CMDCMD
	JRST	CMDCMD

CLIN:	TSOUT	<CRLF>
	CALLR	DLIN
	JRST	CMDCMD

CLIS:	PATH	([ASCIZ/ LIST /],PATHNR!PATHCC!PATHAS)
	 JRST	CMDCMD
	MOVE	IO,CMDMOD
	CAIN	IO,CMDM3
	 JRST	CLIS1
	TSOUT	<[ASCIZ/**/]>
	TCIN	(CLISC1,[ASCIZ/**/])
	 JRST	CMDCMD
	 JRST	CLIS2
	JRST	CLIS3
CLIS1:	TSOUT	<[ASCIZ/!!/]>
	TCIN	(CLISC2,[ASCIZ/!!/])
	 JRST	CMDCMD
	 JRST	CLIS2
	JRST	CLIS3
CLIS2:	MOVEI	FLAG,DL$T
	TSOUT	<[ASCIZ/TERSE/]>
CLIS3:	TSOUT	<CRLF>
	CALLR	DLIS
	JRST	CMDCMD

CLISC1:
DEFINE TCIL <
	TCIE TERSE,DL$T
	TCIE VERBOSE,DL$V
>;TCIL
	XTCIL
CLISC2:
DEFINE TCIL <
	TCIE PROTECTION,DL$P
	TCIE TERSE,DL$T
	TCIE VERBOSE,DL$V
>;TCIL
	XTCIL
CLOC:	TBOUT [" "]
	MOVE IO,[ABUF,,6]
	HRRZI UTIL,[ASCIZ/ LOCAL-CONNECT /]
	CALLR $TSIN$
	 JRST CMDCMD
	JUMPE UTIL,[	.SUSET [.RSNAME,,LCLSNM]
			TSOUT <[ASCIZ/(default)/],CRLF>
			JRST CMDCMD]
	TSOUT <CRLF>
	SETZM LCLSNM
	MOVE X1,[440600,,LCLSNM]
	MOVE X2,[440700,,ABUF]
CLOCLP:	ILDB X2
	SUBI " "
	IDPB X1
	SOJG UTIL,CLOCLP
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVEI
		[('DSK')]
		['.FILE.']
		['(DIR) ']
		SETZ LCLSNM]
	 JRST [	TSOUT <[ASCIZ/ (No such directory)/],CRLF,[ASCIZ/ LOCAL-CONNECT/]>
		JRST CLOC]
	.CLOSE
	JRST CMDCMD
CNOD:	SETZM	FLAGDD
	JRST	CMDNEW

CPUT:	PATH	([ASCIZ/ PUT /],PATHNP!PATHFR!PATHLR!PATHAS)
	 JRST	CMDCMD
	CALLR	DPUT
	 JRST	CMDCMD
	JRST	CMDCMD

CQUI:	TAIN	<[ASCIZ/ [Confirm]/]>
	 JRST	CMDCMD
	 JRST	CMDCMD
	JRST	QUIT

CREM:	PATH	([ASCIZ/ REMOVE /],PATHNR!PATHCC!PATHAS!PATHAC)
	 JRST	CMDCMD
	CALLR	DREM
	JRST	CMDCMD

CREN:	PATH	([ASCIZ/ RENUMBER /],PATHNP!PATHFR!PATHAS!PATHAV)
	 JRST	CMDCMD
	SKIPLE	X1,VBUF
	 JRST	CREN2
	JUMPL	X1,CREN1
	LDB	UTIL,[350700,,FBUF]
	CAIN	UTIL,"*"
	 JRST	CREN1
	LDB	UTIL,[350700,,EBUF]
	CAIE	UTIL,"*"
	 JRST	CREN2
CREN1:	TSOUT	<[ASCIZ/ (A version number is required if *'s are used.)/],CRLF>
	JRST	CMDCMD
CREN2:	TSOUT	<[ASCIZ/ New version number: /]>
	TNIN	([ASCIZ/ New version number: /])
	 JRST	CMDCMD
	JUMPN	IO,CREN3
	MOVEI	IO,"1"
	TBOUT	<IO>
	MOVEI	IO,1
CREN3:	MOVEM	IO,ABUF
	TSOUT	<CRLF>
	CALLR	DREN
	JRST	CMDCMD

CRET:	PATH	([ASCIZ/ RETRIEVE /],PATHNP!PATHFR!PATHRL!PATHAV!PATHAS)
	 JRST	CMDCMD
	CALLR	DGET
	 JRST	CMDCMD
	JRST	CMDCMD
CSOD:	SETOM	FLAGDD
	JRST	CMDNEW

CSTO:	PATH	([ASCIZ/ STORE /],PATHNP!PATHFR!PATHLR!PATHAS)
	 JRST	CMDCMD
	CALLR	DPUT
	 JRST	CMDCMD
	JRST	CMDCMD

CTER:	SETOM FLAGNN
	SETZM FLAGDD
	SETZM FLAGTT
	JRST CMDNEW

CTTR:	SETOM	FLAGTT
	JRST	CMDNEW

CTOP:	TAIN <[ASCIZ/ [Confirm]/]>
	 JRST CMDCMD
	 JRST CMDCMD
	MOVE X1,[ASCII/%TOP./]
	MOVEM X1,NBUF
	MOVE X1,[ASCII/DFTP./]
	MOVEM X1,NBUF+1
	MOVE X1,[ASCII/ITS('/]
	MOVEM X1,NBUF+2
	MOVE X1,[ASCII/CONS'/]
	MOVEM X1,NBUF+3
	MOVE X1,[ASCII/)/]
	MOVEM X1,NBUF+4
	CALLR DATT
	JRST CMDCMD

CUND:	PATH	([ASCIZ/ UNDELETE /],PATHNP!PATHFR!PATHAS!PATHAV)
	 JRST	CMDCMD
	CALLR	DUND
	JRST	CMDCMD

CUTR:	SETZM	FLAGTT
	JRST	CMDNEW

CVER:	SETZM FLAGNN
	JRST CMDNEW
	SUBTTL Path input and translation
PRINTX (path input routines)

; FLAG DEFINITIONS
	PATHNR==400000		; NODE REQUIRED
	PATHNP==200000		; NODE POSSIBLE
	PATHNF==100000		; NODE FOUND
	PATHFR==040000		; FILE REQUIRED
	PATHFF==020000		; FILE FOUND
	PATHCT==004000		; CONTEXT TOP
	PATHCA==002000		; CONTEXT ATTACH
	PATHCC==001000		; CONTEXT CONNECT
	PATHLR==000400		; LOCAL TO REMOTE
	PATHRL==000200		; REMOTE TO LOCAL
	PATHAS==000040		; ALLOW SETS
	PATHAD==000020		; ALLOW (NON-SET) DEFAULT
	PATHAV==000010		; ALLOW VERSIONS
	PATHAC==000004		; ACKNOWLEDGE [CONFIRM]

; PATH INPUT CONTROL
;   IN: TCIO -- LAST CHARACTER INPUT (TCIN)
;	FLAG -- FLAGS,,COMMAND STRING POINTER
;
$PATH$:	BEGINR	<IO,UTIL>
	MOVEI	IO," "
	TBOUT	<IO>
	MOVE	IO,[GBUF1,,5*LBSIZE]
	SETZ	UTIL,
	CALLR	P$IN
	 RETURN
	PUSH	STAK,IO
	MOVE	IO,[GBUF1,,NBUF]
	MOVE	UTIL,[FBUF,,EBUF]
	CALLR	P$PP
	POP	STAK,IO
	MOVEM	UTIL,VBUF
	TLNN	FLAG,PATHAC
	 JRST	PAT$10
	TAIN	<[ASCIZ/ [Confirm]/]>
	 RETURN
	 RETURN
	RETURN	SKIP,1
PAT$10:	TLNE	FLAG,PATHRL!PATHLR
	 JRST	PAT$11
	TSOUT	<CRLF>
	RETURN	SKIP,1
PAT$11:	PUSH	STAK,IO
	MOVE	IO,[FBUF,,EBUF]
	CALLR	P$LF
	POP	STAK,IO
	CAIE	IO,33
	 CAIN	IO," "
	  JRST	PAT$20
PAT$12:	TSOUT <CRLF>
	RETURN	SKIP,1
PAT$20:	TLNE	FLAG,PATHLR
	 JRST	PAT$21
	TLNE	FLAG,PATHRL
	 JRST	PAT$22
	JRST	PAT$23
PAT$21:	TLNE	FLAG,PATHNF
	 JRST	PAT$12
	JRST	PAT$23
PAT$22:
	TLZ	FLAG,PATHNR!PATHNP!PATHAV
PAT$23:	TSOUT	<[ASCIZ/ [As] /]>
	MOVE	IO,[GBUF2,,5*LBSIZE]
	MOVE	UTIL,[GBUF1,,[ASCIZ/ [As] /]]
	CALLR	P$IN
	 RETURN
	TLNE	FLAG,PATHLR
	 JRST	PAT$24
	TLNE	FLAG,PATHRL
	 JRST	PAT$25
	RETURN
PAT$24:	MOVE	IO,[GBUF2,,NBUF]
	MOVE	UTIL,[FBUF,,EBUF]
	CALLR	P$PP
	MOVEM	UTIL,VBUF
	TSOUT	<CRLF>
	RETURN	SKIP,1
PAT$25:	MOVE	IO,[GBUF2,,GBUF1]
	MOVE	UTIL,[FSBUF,,ESBUF]
	CALLR	P$PP
	MOVE	IO,[FSBUF,,ESBUF]
	CALLR	P$LF
	TSOUT <CRLF>
	ENDR	SKIP,1
; PATH INPUT
;   IN: IO -- POINTER TO PATH BUFFER,,SIZE OF PATH BUFFER
;       UTIL -- FIRST PATH,,TIE MSG (OR ZERO)
;       FLAG -- (SAME AS $PATH$)
;   OUT: IO -- LAST CHARACTER INPUT
;        UTIL -- COUNT OF CHARACTERS
;   FLAGS:
	P$I$AE==400000		; ANCHOR ENCOUNTERED (<)
	P$I$DE==200000		; DESCENDER ENCOUNTERED (>,.)
	P$I$SE==100000		; SET ENCOUNTERED (*)
	P$I$TE==040000		; TRAILING NODE SET ENCOUNTERED (**)
	P$I$PW==010000		; INPUT PASSWORD
	P$I$CC==004000		; <
	P$I$CA==002000		; <<
	P$I$CT==001000		; <<<
	P$I$EP==000400		; EXTENSION BEING PROCESSED
	P$I$VP==000200		; VERSION BEING PROCESSED
;
P$IN:	BEGINR	<BP,R10,R11,R12,R13>
	SETZ	R10,
	MOVE	R11,IO
	MOVE	R12,UTIL
	HLR	BP,IO
	HRLI	BP,440700
	SETZ	UTIL,
P$ICHR:	TBIN	<IO>
	CAIN	IO,"R"-100
	 JRST	P$IREP
	CAIE	IO,177
	 CAIN	IO,"A"-100
	  JRST	P$IDEL
	CAIE	IO,"U"-100
	 CAIN	IO,"X"-100
	  JRST	P$IENR
	CAIN	IO,15
	 JRST	P$ICHR
	CAIE	IO,12
	 CAIN	IO,33
	  JRST	P$IEND
	CAIN	IO,37
	 JRST	P$IEND
	CAIL	IO," "
	 CAIN	IO,42
	  JRST	P$IBAD
	CAIE	IO,47
	 TRNE	R10,P$I$TE
	  JRST	P$IBAD
	CAIL	UTIL,(R11)
	 JRST	P$IBAD
	TRNE	R10,P$I$PW
	 JRST	P$ICHP
	CAIN	IO," "
	 JRST	P$IEND
	CAIN	IO,"?"
	 JRST	P$IBAD
	CAIN	IO,"*"
	 JRST	P$ISS
	TRNE	R10,P$I$VP
	 JRST	P$ISVN
	CAIN	IO,";"
	 JRST	P$ISVS
	CAIN	IO,":"
	 JRST	P$IPON
	CAIN	IO,"<"
	 JRST	P$ISA
	CAIN	IO,">"
	 JRST	P$ISD1
	CAIN	IO,"."
	 JRST	P$ISD2
	TRNE	R10,P$I$SE
	 JRST	P$IBAD
	TRZ	R10,P$I$AE!P$I$DE
P$ICHE:	IDPB	IO,BP
	TBOUT	<IO>
	AOJA	UTIL,P$ICHR
P$ICHP:	CAIN	IO,">"
	 JRST	P$IPOF
	CAIN	IO,"'"
	 JRST	P$IBAD
	IDPB	IO,BP
	AOJA	UTIL,P$ICHR
P$ISA:	TLNN	FLAG,PATHNR!PATHNP
	 JRST	P$IBAD
	TRNN	R10,P$I$CC
	 JRST	P$ISA1
	TRNN	R10,P$I$CA
	 JRST	P$ISA2
	TRNN	R10,P$I$CT
	 JRST	P$ISA3
	JRST	P$IBAD
P$ISA1:	JUMPN	UTIL,P$IBAD
	TRO	R10,P$I$AE!P$I$CC
	JRST	P$ICHE
P$ISA2:	CAIE	UTIL,1
	 JRST	P$IBAD
	TRO	R10,P$I$AE!P$I$CA
	JRST	P$ICHE
P$ISA3:	CAIE	UTIL,2
	 JRST	P$IBAD
	TRO	R10,P$I$AE!P$I$CT
	JRST	P$ICHE
P$ISD1:	TLNE	FLAG,PATHNR!PATHNP
	 TRNE	R10,P$I$AE!P$I$EP
	  JRST	P$IBAD
	JUMPE	UTIL,P$IBAD
	TLNE	FLAG,PATHFR
	 TRNN	R10,P$I$SE
	  TROE	R10,P$I$DE
	   JRST	P$IBAD
	JRST	P$ISD9
P$ISD2:	TLNE	FLAG,PATHFR
	 TRNE	R10,P$I$AE!P$I$DE!P$I$EP
	  JRST	P$IBAD
	JUMPE	UTIL,P$IBAD
	TRO	R10,P$I$DE!P$I$EP
P$ISD9:	TRZ	R10,P$I$SE
	JRST	P$ICHE
P$ISVS:	TLNE	FLAG,PATHAV
	 TLNN	FLAG,PATHFR
	  JRST	P$IBAD
	JUMPE	UTIL,P$IBAD
	TRNE	R10,P$I$DE
	 TRNE	R10,P$I$EP
	  TRNE	R10,P$I$AE!P$I$VP
	   JRST	P$IBAD
	TRZ	R10,P$I$SE!P$I$EP
	TRO	R10,P$I$VP!P$I$DE
	JRST	P$ICHE
P$ISVN:	CAIL	IO,"0"
	 CAILE	IO,"9"
	  JRST	P$IBAD
	TRNE	R10,P$I$SE
	 JRST	P$IBAD
	TRZ	R10,P$I$DE
	JRST	P$ICHE
P$ISS:	TLNN	FLAG,PATHAS
	 JRST	P$IBAD
	TRNE	R10,P$I$SE
	 JRST	P$IST
	TRZN	R10,P$I$AE!P$I$DE
	 JUMPN	UTIL,P$IBAD
	TRO	R10,P$I$SE
	JRST	P$ICHE
P$IST:	TLNN	FLAG,PATHFR
	 TRNN	R10,P$I$EP!P$I$VP
	  JRST	P$IBAD
	TRO	R10,P$I$TE
	JRST	P$ICHE
P$IPON:	TLNE	FLAG,PATHNR!PATHNP
	 TRNE	R10,P$I$AE!P$I$DE!P$I$SE
	  JRST	P$IBAD
	CAIL	UTIL,-1(R11)
	 JRST	P$IBAD
	IDPB	IO,BP
	TBOUT	<IO>
	MOVEI	X1,"P"-100
	IDPB	X1,BP
	ADDI	UTIL,2
	TRO	R10,P$I$PW
	JRST	P$ICHR
P$IPOF:	CAIL	UTIL,-1(R11)
	 JRST	P$IBAD
	MOVEI	X1,"P"-100
	IDPB	X1,BP
	IDPB	IO,BP
	TBOUT	<IO>
	ADDI	UTIL,2
	TRZ	R10,P$I$PW
	TRO	R10,P$I$DE
	JRST	P$ICHR
P$IBAD:	MOVEI	IO,"G"-100
	TBOUT	<IO>
	JRST	P$ICHR
P$IREP:	TSOUT	<CRLF>
	TSOUT	<(FLAG)>
	JUMPE	R12,P$IR04
	HLR	R13,R12
	HRLI	R13,440700
	TRZ	R10,P$I$PW
P$IR01:	ILDB	IO,R13
	JUMPE	IO,P$IR03
	CAIN	IO,"P"-100
	 JRST	P$IR02
	TRNE	R10,P$I$PW
	 JRST	P$IR01
	TBOUT	<IO>
	JRST	P$IR01
P$IR02:	TRC	R10,P$I$PW
	JRST	P$IR01
P$IR03:	TSOUT	<(R12)>
P$IR04:	HRRZI	IO,(BP)
	HLR	R13,R11
	CAIGE	IO,(R13)
	 JRST	P$ICHR
	HRLI	R13,440700
	TRZ	R10,P$I$PW
P$IR05:	CAMN	R13,BP
	 JRST	P$ICHR
	ILDB	IO,R13
	CAIN	IO,"P"-100
	 JRST	P$IR06
	TRNE	R10,P$I$PW
	 JRST	P$IR05
	TBOUT	<IO>
	JRST	P$IR05
P$IR06:	TRC	R10,P$I$PW
	JRST	P$IR05
P$IDEL:	JUMPE	UTIL,P$IENR
	MOVEI	IO,"\"
	TBOUT	<IO>
	LDB	IO,BP
	ADD BP,[70000,,0]
	TLNE BP,400000
	 SUB BP,[430000,,1]
	CAIN	IO,"P"-100
	 JRST	P$ID01
	LDB	X1,BP
	CAIN	X1,"P"-100
	 JRST	P$ID02
	TRNE	R10,P$I$PW
	 SOJA	UTIL,P$ICHR
	TBOUT	<IO>
	TRZ	R10,P$I$AE!P$I$DE!P$I$SE!P$I$TE
	CAIN	IO,"."
	 TRZ	R10,P$I$EP
	CAIN	IO,";"
	 TRZ	R10,P$I$VP
	CAIE	IO,"<"
	 JRST	P$ID00
	TRZE	R10,P$I$CT
	 JRST	P$ID00
	TRZE	R10,P$I$CA
	 JRST	P$ID00
	TRZ	R10,P$I$CC
P$ID00:	SOJE	UTIL,P$ICHR
	LDB	X1,BP
	CAIN	X1,"<"
	 TRO	R10,P$I$AE
	CAIE	X1,">"
	 CAIN	X1,"."
	  TRO	R10,P$I$DE
	CAIN	X1,";"
	 TRO	R10,P$I$DE
	CAIN	X1,"*"
	 TRO	R10,P$I$SE
	JRST	P$ICHR
P$ID01:	TRZ	R10,P$I$PW
	LDB	IO,BP
	JRST	P$ID03
P$ID02:	TROE	R10,P$I$PW
	 SOJA	UTIL,P$ICHR
	TRZ	R10,P$I$DE
P$ID03:	ADD BP,[70000,,0]
	TLNE BP,400000
	 SUB BP,[430000,,1]
	TBOUT	<IO>
	SUBI	UTIL,2
	JRST	P$ICHR
P$IENR:	TSOUT	<[ASCIZ/XXX/],CRLF>
	SETO	IO,
	SETZ	UTIL,
	RETURN
P$IEND:	CAIE	IO,12
	 CAIN	IO,37
	  JRST	P$IENL
	TLNN	FLAG,PATHAS
	 JRST	P$IENV
	JUMPE	UTIL,P$IENV
	LDB	R13,BP
	CAIN	R13,">"
	 JRST	P$IENT
	TLNE	FLAG,PATHFR
	 TLNE	FLAG,PATHAS
	  JRST	P$IENV
	CAIA
P$IENL:	 TLNE	FLAG,PATHFR
	  TRNN	R10,P$I$AE
	   JRST P$IENV
	JRST	P$IBAD
P$IENV:	TRNE	R10,P$I$DE
	 TRNE	R10,P$I$EP
	  CAIA
	  JRST	P$IBAD
	JUMPN	UTIL,P$IENN
	TLNN	FLAG,PATHAS
	 JRST	P$IENC
	MOVE	R12,[440700,,[ASCIZ/**/]]
	TLNN	FLAG,PATHFR
	 JRST	P$IENS
	HRRI	R12,[ASCIZ/*.*/]
	TLNE	FLAG,PATHAV
	 HRRI	R12,[ASCIZ/*.*;*/]
	JRST	P$IENS
P$IENC:	TLNN	FLAG,PATHAD
	 JRST	P$IBAD
	MOVE	R12,[440700,,[ASCIZ/<</]]
	TLNE	FLAG,PATHCC
	 HRRI	R12,[ASCIZ/</]
	JRST	P$IENS
P$IENN:	TLNE	FLAG,PATHAS
	 TRNE	R10,P$I$EP!P$I$VP
	  JRST	P$IENZ
	TLNE	FLAG,PATHFR
	 TRNE	R10,P$I$AE!P$I$DE
	  CAIN	IO,12
	   JRST	P$IENZ
	CAIN	IO,37
	 JRST	P$IENZ
	LDB	R13,BP
	CAIN	R13,"<"
	 JRST	P$IENT
	MOVEI	R13,">"
	IDPB	R13,BP
	TBOUT	<R13>
	ADDI	UTIL,1
P$IENT:	MOVE	R12,[440700,,[ASCIZ/**/]]
	TLNN	FLAG,PATHFR
	 JRST	P$IENS
	HRRI	R12,[ASCIZ/*.*/]
	TLNE	FLAG,PATHAV
	 HRRI	R12,[ASCIZ/*.*;*/]
P$IENS:	ILDB	R13,R12
	IDPB	R13,BP
	JUMPE	R13,RETN(1)
	TBOUT	<R13>
	AOJA	UTIL,P$IENS
P$IENZ:	SETZ	R13,
	IDPB	R13,BP
	ENDR	SKIP,1
; P$PP -- PROCESS PATH (NODES AND FILES)
;   IN: IO -- SOURCE,,NODE DESTINATION
;	UTIL -- FILE DESTINATION,,EXTENSION DESTINATION
;	FLAG -- PATH CONTEXT FLAGS
;   OUT: FLAG -- FOUND FLAGS
;	 UTIL -- VERSION NUMBER (-1 *) (0 NONE)
;
P$PP:	BEGINR	<BP>
	TLNE	FLAG,PATHNR
	 JRST	P$PN
	HLR	BP,IO
	HRLI	BP,440700
	TLNN	FLAG,PATHNP
	 JRST	P$PF0
	SETZM	(IO)
	MOVE	X1,BP
P$PS2:	MOVE	X2,BP
P$PS1:	ILDB	X3,BP
	CAIE	X3,"<"
	 CAIN	X3,">"
	  JRST	P$PS2
	CAIE	X3,"."
	 CAIN	X3,";"
	  JRST	P$PS3
	JUMPE	X3,P$PS3
	JRST	P$PS1
P$PS3:	MOVE	BP,X2
	CAMN	BP,X1
	 JRST	P$PF
	TLO	FLAG,PATHNF
	MOVE	X1,BP
	LDB	X2,X1
	CAIN	X2,"<"
	 ILDB	X2,X1
	SETZ	X3,
	DPB	X3,X1
	PUSH	STAK,X1
	PUSH	STAK,X2
	CALLR	P$CP
	POP	STAK,X2
	POP	STAK,X1
	DPB	X2,X1
	JRST	P$PF
P$PN:	TLO	FLAG,PATHNF
	CALLR	P$CP
	RETURN
P$PF:	SKIPE	(IO)
	 JRST	P$PF0
	MOVE	X1,[440700,,CONTEX]
	MOVE	X2,[440700,,NBUF]
	SCOPY	(X1,X2)
P$PF0:	TLO	FLAG,PATHFF
	SETZM	(UTIL)
	HLRZ	X1,UTIL
	HRLI	X1,440700
P$PF1:	ILDB	X2,BP
	IDPB	X2,X1
	JUMPE	X2,P$PF3
	CAIN	X2,";"
	 JRST	P$PF4
	CAIE	X2,"."
	 JRST	P$PF1
	SETZ	X2,
	DPB	X2,X1
	HRRZI	X1,(UTIL)
	HRLI	X1,440700
P$PF2:	ILDB	X2,BP
	IDPB	X2,X1
	CAIN	X2,";"
	 JRST	P$PF4
	JUMPN	X2,P$PF2
P$PF3:	SETZ	UTIL,
	RETURN
P$PF4:	SETZ	X2,
	DPB	X2,X1
	ILDB	X2,BP
	CAIE	X2,"*"
	 JRST	P$PF5
	SETO	UTIL,
	RETURN
P$PF5:	SETZ	UTIL,
P$PF6:	SUBI	X2,"0"
	IMULI	UTIL,^D10
	ADDI	UTIL,(X2)
	ILDB	X2,BP
	JUMPN	X2,P$PF6
	ENDR
; CONVERT PATH FROM DFTP FORM TO DATACOMPUTER FORM
;   IN: IO -- SOURCE,,DESTINATION
; 	FLAG -- PATH CONTEXT FLAGS
;
P$CP:	BEGINR	<IO,FLAG>
	MOVEI	X1,<<LBSIZE*5>-1>
	HLRZ	X2,IO
	HRLI	X2,350700
	HRRI	X3,(IO)
	HRLI	X3,440700
	LDB	IO,X2
	CAIN	IO,"<"
	 JRST	P$CPCX
	TLNE	FLAG,PATHCT
	 JRST	P$CPCT
	TLNE	FLAG,PATHCA
	 JRST	P$CPCA
	JRST	P$CPCC
P$CPCX:	ILDB	IO,X2
	CAIE	IO,"<"
	 JRST	P$CPCC
	ILDB	IO,X2
	CAIE	IO,"<"
	 JRST	P$CPCA
	ILDB	IO,X2
P$CPCT:	MOVE	X4,[440700,,[ASCIZ/%TOP./]]
	SCOPY	(X4,X3)
	MOVE	X4,[440700,,ANCHOR]
	SCOPY	(X4,X3)
	SUBI	X1,11
	JRST	P$CPCE
P$CPCA:	MOVE	X4,[440700,,[ASCIZ/%LOGIN/]]
	SCOPY	(X4,X3)
	SUBI	X1,6
	JRST	P$CPCE
P$CPCC:	MOVE	X4,[440700,,CONTEX]
	ILDB	0,X4
	JUMPE	0,.+4
	SOJL	X1,P$CPE
	IDPB	0,X3
	JRST	.-4
	MOVE	X4,X3
	IDPB	0,X4
P$CPCE:	JUMPE	IO,P$CPZ0
	MOVEI	X4,"."
	IDPB	X4,X3
	MOVEI	X4,42
	SETZ	FLAG,
	SOJA	X1,P$CPI0
P$CPI:	ILDB	IO,X2
P$CPI0:	CAIN	IO,"P"-100
	 JRST	P$CPI
	CAIN	IO,">"
	 JRST	P$CPS
	JUMPE	IO,P$CPZ
	JUMPN	FLAG,P$CPO
	CAIN	IO,":"
	 JRST	P$CPP
	CAIN	IO,"*"
	 JRST	P$CPO
	CAIL	IO,"A"
	 CAILE	IO,"Z"
	  JRST	P$CPQ
P$CPO:	SOJL	X1,P$CPE
	IDPB	IO,X3
	JRST	P$CPI
P$CPQ:	SOJL	X1,P$CPE
	IDPB	X4,X3
	JRST	P$CPO
P$CPS:	JUMPE	FLAG,.+6
	MOVEI	IO,"'"
	IDPB	IO,X3
	MOVEI	IO,")"
	IDPB	IO,R3
	SETZ	FLAG,
	MOVEI	IO,"."
	JRST	P$CPO
P$CPP:	SUBI	X1,4
	JUMPL	X1,P$CPE
	MOVEI	IO,"("
	IDPB	IO,R3
	MOVEI	IO,"'"
	IDPB	IO,R3
	SETO	FLAG,
	JRST	P$CPI
P$CPE:	TSOUT	<[ASCIZ/ (Pathname too long)/],CRLF>
	MOVE	STAK,[IOWD STSIZ,STBEG]
	JRST	CMDCMD
P$CPZ:	JUMPE	FLAG,P$CPZ0
	MOVEI	X1,"'"
	IDPB	X1,X3
	MOVEI	X1,")"
	IDPB	X1,X3
P$CPZ0:	IDPB	IO,X3
	ENDR
; LOCAL FILE NAME PREPARATION
;   IN: IO -- FILE LOCATION,,EXTENSION LOCATION
;
P$LF:	BEGINR	<IO>
	HLL	X1,IO
	HRRI	X1,FSBUF
	BLT	X1,<FSBUF+SBSIZE-1>
	LDB	X1,[350700,,FSBUF]
	CAIN	X1,"*"
	 SETOM	FSBUF
	HRLZI	X1,(IO)
	HRRI	X1,ESBUF
	BLT	X1,<ESBUF+SBSIZE-1>
	LDB	X1,[350700,,ESBUF]
	CAIN	X1,"*"
	 SETOM	ESBUF
	CAIN	X1,0
	 SETZM	ESBUF
	HLR	X1,IO
	HRLI	X1,440700
	MOVE	X2,[440700,,ABUF]
P$LF1:	ILDB	X3,X1
	IDPB	X3,X2
	JUMPN	X3,P$LF1
	SKIPN	(IO)
	 JRST	P$LF2
	MOVEI	X3,"."
	DPB	X3,X2
	HRRZI	X1,(IO)
	HRLI	X1,440700
P$LF3:	ILDB	X3,X1
	IDPB	X3,X2
	JUMPN	X3,P$LF3
P$LF2:
	HRRZI	IO,ABUF
	CALLR	LUTFN
	ENDR
	SUBTTL Datacomputer interface routines
PRINTX (Datacomputer interface routines)

; DALO -- ALLOCATE SPACE
;
DALO:	BEGINR
	DCSOUT	<[ASCIZ/MODIFY /],NBUF,<[ASCIZ/,M=/]>>
	MOVE	IO,ABUF
	DCNOUT	<IO>
	DCSOUT	<SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	ENDR

; DATT -- LOGIN TO NODE
;
DATT:	BEGINR
	DCSOUT	<[ASCIZ/LOGIN /],NBUF,SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	SETZM	LOGIN%
	MOVE	X1,[ASCII/%LOGI/]
	MOVEM	X1,CONTEX
	MOVE	X1,[ASCII/N/]
	MOVEM	X1,<CONTEX+1>
	SKIPN	OPENED
	 RETURN
	SETZM	OPENED
	DCSOUT	<[ASCIZ/CLOSE "<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 RETURN
	ENDR
; DBIG -- CREATE A <BIG> FILE
;
DBIG:	BEGINR	<IO>
	DCSOUT	<[ASCIZ/LIST /],NBUF,SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JRST	DBIG1
	TSOUT	<[ASCIZ/ [Old Node]/],CRLF>
	JRST	DBIG2
DBIG1:	TSOUT	<[ASCIZ/ [New Node]/],CRLF>
	DCSOUT	<[ASCIZ/CREATE /],NBUF,SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
DBIG2:	SKIPN	OPENED
	 JRST	DBIG3
	DCSOUT	<[ASCIZ/CLOSE "<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
	SETZM	OPENED
DBIG3:	DCSOUT	<[ASCIZ/CREATE /],NBUF,[ASCIZ/."<FILES"> LIKE %TOP.DFTP."<BIG">/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	MOVE	X1,[440700,,NBUF]
	MOVE	X2,[440700,,OPENED]
	SCOPY	(X1,X2)
	SETZM	OPENEM
	DCSOUT	<[ASCIZ/"<FILES">="<TERSE">/],SEMI>
	MOVE	IO,[ASCII/.I231/]
	CALLR	RENFIP
	 RETURN
	MOVEI	IO,"Z"-100
	DCBOUT	<IO>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	MOVE	X1,[440700,,NBUF]
	MOVE	X2,[440700,,CONTEX]
	SCOPY	(X1,X2)
	ENDR
; DCHA -- CHANGE PRIVILEGES (DELETE AND ADD)
;
DCHA:	BEGINR	<IO,UTIL>
	DCSOUT	<[ASCIZ/LIST /],NBUF,[ASCIZ/ %PRIV/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
DCHAD:	DCSOUT	<[ASCIZ/DELETEP /],NBUF,<[ASCIZ/,N=1/]>,SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 CAIA
	  JRST	DCHAD
	TSOUT	<[ASCIZ/ [Ok]/],CRLF>
DCHAI:	TAIN	<[ASCIZ/ Add a new privilege? /]>
	 RETURN
	 RETURN
	SETZM	ABUF		; WRITE FLAG
	SETZM	<ABUF+1>	; HOST
	SETZM	<ABUF+2>	; SOCKET
	SETOM	<ABUF+3>	; PASSWORD
	TAIN	<[ASCIZ/  Allow control? /]>
	 JRST	DCHAI
	 SETOM	ABUF
	TAIN <[ASCIZ/  Restrict via network? /]>
	 JRST DCHAI
	 JRST DCHAI5
	TAIN <[ASCIZ/   Restrict via local host? /]>
	 JRST DCHAI
	 JRST DCHAI1
	MOVE IO,LHOST
	JRST DCHAI2
DCHAI1:	TSOUT <[ASCIZ/    Host number (octal): /]>
	TNIN ([ASCIZ/    Host number (octal): /],10)
	 JRST DCHAI
	JUMPN IO,DCHA1A
	MOVE IO,LHOST
	TNOUT (IO,10)
DCHA1A:	TSOUT <CRLF>
DCHAI2:	MOVEM IO,<ABUF+1>
	TAIN <[ASCIZ/   Restrict via user? /]>
	 JRST DCHAI
	 JRST DCHAI5
	MOVE IO,ABUF+1
	CAMN IO,ABUF
	 JRST DCHAI3
	TSOUT <[ASCIZ/    Socket number (octal): /]>
	TNIN ([ASCIZ/    Socket number (octal): /],10)
	 JRST DCHAI
	JRST DCHAI4
DCHAI3:	TSOUT <[ASCIZ/    User: ANY/]>
	SETZ IO,
DCHAI4:	MOVEM IO,<ABUF+2>
	TSOUT <CRLF>
DCHAI5:	TAIN	<[ASCIZ/  Restrict via password? /]>
	 JRST	DCHAI
	 JRST	DCHAC
	TSOUT	<[ASCIZ/   Password: /]>
	TSIN	(<ABUF+3>,<SBSIZE-3>,[ASCIZ/   Password: /])
	 JRST	DCHAI
	TSOUT	<CRLF>
DCHAC:	DCSOUT	<[ASCIZ/CREATEP /],NBUF,<[ASCIZ/,U=**,G=LR/]>>
	SKIPE	ABUF
	 JRST	DCHAC1
	DCSOUT	<[ASCIZ/CWA/]>
DCHAC1:	SKIPN	<ABUF+1>
	 JRST	DCHAC3
	DCSOUT	<<[ASCIZ/,H=/]>>
	MOVE	IO,<ABUF+1>
	DCNOUT	<IO>
	DCSOUT	<<[ASCIZ/,S=/]>>
	MOVE	IO,<ABUF+2>
	JUMPE	IO,DCHAC2
	DCNOUT	<IO>
	JRST	DCHAC3
DCHAC2:	DCSOUT	<[ASCIZ/ANY/]>
DCHAC3:	SETO	IO,
	CAMN	IO,<ABUF+3>
	 JRST	DCHAC4
	DCSOUT	<<[ASCIZ/,P='/]>,<ABUF+3>,[ASCIZ/'/]>
DCHAC4:	DCSOUT	<SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	TSOUT	<[ASCIZ/  [Ok]/],CRLF>
	JRST	DCHAI
DCHAI8:	TSOUT <[ASCIZ/ (User not found)/],CRLF>
	JRST DCHAI
	ENDR
; DCON -- CONNECT (VERIFY CONTEXT)
;
DCON:	BEGINR
	DCSOUT	<[ASCIZ/LIST /],NBUF,SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JRST	DCON1
	TSOUT	<[ASCIZ/ [Old Node]/],CRLF>
	JRST	DCON2
DCON1:	TAIN	<[ASCIZ/ [New Node][Confirm]/]>
	 RETURN
	 RETURN
	DCSOUT	<[ASCIZ/CREATE /],NBUF,SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
DCON2:	MOVE	X1,[440700,,NBUF]
	MOVE	X2,[440700,,CONTEX]
	SCOPY	(X1,X2)
	ENDR

; DCRE -- CREATE NEW NODE
;
DCRE:	BEGINR
	DCSOUT	<[ASCIZ/CREATE /],NBUF,<[ASCIZ/,M=/]>>
	MOVEI	IO,DEFALO
	DCNOUT	<IO>
	DCSOUT	<SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	CALLR	DCHA
	ENDR
; DDEL -- DELETE FILES
;
DDEL:	BEGINR	<IO>
	SETZ	IO,
	CALLR	D$OPEN
	 RETURN
	SETO	IO,
	CALLR	D$VER
	 RETURN
	SETOM	FLAGDE
	DCSOUT	<[ASCIZ/BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	DECLARE DELETED INTEGER
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	DELETED=0
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	UPDATE FILES IN "<FILES">/]>
	HRRZI	IO,[ASCIZ/ STATUS EQ ' '/]
	CALLR	D$WITH
	DCSOUT <[ASCIZ/
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		STATUS='D'
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		DELETED=DELETED+1
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		COMMENT FILES.FILE.HEADER.FILENAME
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		  ! '.' ! FILES.FILE.HEADER.EXTENSION
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		    ! ';' ! FILES.FILE.HEADER.VERSION
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	END
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	IF DELETED EQ 0 THEN ERROR 'NO SUCH FILE'
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/END;
/]>
	CALLR	RENDER
	 RETURN
	ENDR
; DDIR -- FILE DIRECTORY
;   IN:  FLAG -- ADDRESS OF ARGUMENT PROCESSING ROUTINE
;
DDIR:	BEGINR	<IO,UTIL>
	SETO	IO,
	CALLR	D$OPEN
	 RETURN
	SKIPN	VBUF
	 SETOM	VBUF
	SETZ	UTIL,
	CAIN	FLAG,DD$D
	 JRST	DDIRO1
	CAIN	FLAG,DD$T
	 JRST	DDIRO2
	CAIN	FLAG,DD$V
	 JRST	DDIRO3
	RETURN
DDIRO1:	DCSOUT	<[ASCIZ/"<TERSE">="<FILES">/]>
	HRRZI	IO,[ASCIZ/ STATUS EQ 'D'/]
	JRST	DDIRO4
DDIRO2:	DCSOUT	<[ASCIZ/"<TERSE">="<FILES">/]>
	HRRZI	IO,[ASCIZ/ STATUS EQ ' '/]
	JRST	DDIRO4
DDIRO3:	DCSOUT	<[ASCIZ/"<VERBOSE">="<FILES">/]>
	SETZ	IO,
DDIRO4:	CALLR	D$WITH
	DCSOUT	<SEMI>
	MOVE	IO,[ASCII/.I241/]
	CALLR	RENFIP
	 RETURN
	CALLR	RENLIN
DDIRF:	CALLR	RENPRE
	CAMN	IO,[ASCII/     /]
	 JRST	DDIRF1
	CAMN	IO,[ASCII/.I261/]
	 JRST	DDIRF3
	LDB	IO,[350700,,IO]
	CAIN	IO,";"
	 JRST	DDIRF2
	CALLR	RENLIP
	SETZM	FLAGDE
	CALLR	RENDER
	 RETURN
	RETURN
DDIRF1:	CALLR	<(FLAG)>
	AOJA	UTIL,DDIRF
DDIRF2:	CALLR	RENLIN
	JRST	DDIRF
DDIRF3:	CALLR	RENLIN
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	JUMPN	UTIL,RETN(0)
	TSOUT	<[ASCIZ/ [No Files]/],CRLF>
	ENDR
; DD$D -- DELETED FILES
;
DD$D:	BEGINR
	CALLR	DD$T
	ENDR

; DD$T -- TERSE FILES
;
DD$T:	BEGINR	<IO>
	SKIPE	FLAGDD
	 JRST	DD$T1
	MOVEI	IO,11
	TBOUT	<IO>
DD$T1:	DCBIN	<IO>
	SKIPE	FLAGDD
	 JRST	DD$T2
	TBOUT	<IO>
DD$T2:	CAIE	IO,12
	 JRST	DD$T1
	ENDR

; DD$V -- VERBOSE FILES
;
DD$V:	BEGINR	<IO>
	SKIPE	FLAGDD
	 JRST	DD$V1
	MOVEI	IO,11
	TBOUT	<IO>
DD$V1:	DCBIN	<IO>
	SKIPE	FLAGDD
	 JRST	DD$V3
	CAIN	IO,11
	 JRST	DD$V2
	TBOUT	<IO>
	JRST	DD$V3
DD$V2:	TSOUT	<CRLF>
	TBOUT	<IO>
	TBOUT	<IO>
	JRST	DD$V1
DD$V3:	CAIE	IO,12
	 JRST	DD$V1
	ENDR
; DEXA -- EXAMINE (LIST FILES TO TERMINAL)
;
DEXA:	BEGINR	<IO,FLAG>
	SETZ	FLAG,
	SETO	IO,
	CALLR	D$OPEN
	 RETURN
	SKIPLE	VBUF
	 JRST	DEXA1
	MOVEI	IO," "
	CALLR	D$VER
	 RETURN
	JRST	DEXA2
DEXA1:	CALLR	D$VEX
	 RETURN
DEXA2:	DCSOUT	<[ASCIZ/"<GET">="<FILES">/]>
	HRRZI	IO,[ASCIZ/ STATUS EQ ' '/]
	CALLR	D$WITH
	DCSOUT	<SEMI>
	CALLR	NETOI
	 THUD
	MOVE	IO,[ASCII/;I249/]
	CALLR	RENFIP
	 RETURN
	CALLR	RENLIN
	SETZM	NSUM
	SETZM FLAGSM
DEXA3:	SETZM	DEXA$L
	CALLR	EXAFIL
	 JRST	DEXA4		; EXIT RETRIEVAL LOOP ON NETWORK EOF
	MOVNI	IO,10
	CAMN	IO,DEXA$L
	 AOJA	FLAG,DEXA4
	SKIPE	FLAGTT
	 CALLR	NETRAT
	AOJA	FLAG,DEXA3
DEXA4:	CALLR	NETC
	MOVE	IO,[ASCII/;I269/]
	CALLR	RENFIP
	 JRST	DEXAE
	CALLR	RENLIN
	CALLR	NETSUM
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	JUMPN	FLAG,RETN(1)
	TSOUT	<[ASCIZ/ (No Such File)/],CRLF>
	RETURN	SKIP,1
DEXAE:	CALLR	D$CON
	ENDR
; EXAMINE -- TERMINAL OUTPUT
;   IN: IO -- COUNT OF CHARACTERS IN BUFFER
;	BP -- BYTE POINTER INTO BUFFER
DEXA$:	BEGINR	<UTIL,FLAG>
	SKIPGE	DEXA$L
	 RETURN
	SETZ	FLAG,
DEXA$1:	SKIPG	IO
	 RETURN
	ILDB	UTIL,BP
	CAIGE	UTIL," "
	 JRST	DEXA$3
DEXA$2:	TBOUT	<UTIL>
	SOJA	IO,DEXA$1
DEXA$3:	CAIE	UTIL,15
	 CAIN	UTIL,11
	  JRST	DEXA$2
	CAIE	UTIL,12
	 CAIN	UTIL,37
	  JRST	DEXA$4
	CAIG	IO,5
	 JUMPE	UTIL,RETN(0)
	PUSH	STAK,UTIL
	MOVEI	UTIL,"^"
	TBOUT	<UTIL>
	POP	STAK,UTIL
	ADDI	UTIL,100
	TBOUT	<UTIL>
	ADDI	FLAG,1
	CAIE	FLAG,20
	 SOJA	IO,DEXA$1
	JRST	DEXA$5
DEXA$4:	AOS	X1,DEXA$L
	CAML	X1,DEXA$P
	 CAIG	IO,5
	  JRST	DEXA$2
	SUBI	IO,1
	SETZM	DEXA$L
DEXA$5:	SETZ	FLAG,
	TSOUT	<CRLF,[ASCIZ/ More? /]>
DEXA$6:	TBIN	<UTIL>
	CAIN	UTIL,15
	 JRST	DEXA$6
	CAIE	UTIL,"Y"
	 CAIN	UTIL,12
	  JRST	DEXA$7
	CAIE	UTIL,33
	 CAIN	UTIL,37
	  JRST	DEXA$7
	CAIN	UTIL," "
	 JRST	DEXA$7
	CAIE	UTIL,"A"
	 CAIN	UTIL,177
	  JRST	DEXA$8
	JRST	DEXA$9
DEXA$7:	TSOUT	<[ASCIZ/Yes/],CRLF>
	JRST	DEXA$1
DEXA$8:	TSOUT	<[ASCIZ/Abort/],CRLF>
	MOVNI	X1,10
	MOVEM	X1,DEXA$L
	RETURN
DEXA$9:	TSOUT	<[ASCIZ/No/],CRLF>
	SETOM	DEXA$L
	ENDR
; DEXP -- EXPUNGE
;
DEXP:	BEGINR	<IO>
	SKIPN	OPENED
	 JRST	DEXP1
	SETZM	OPENED
	DCSOUT	<[ASCIZ/CLOSE "<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
DEXP1:	DCSOUT	<[ASCIZ/LIST /],NBUF,[ASCIZ/."<FILES"> %INFORMATION/],SEMI>
	CALLR	RENPRE
	CALLR	RENLIN
	CAMN	IO,[ASCII/.I280/]
	 JRST	DEXP2
	TSOUT	<[ASCIZ/ (There are no <FILES>)/],CRLF>
	RETURN
DEXP2:	DCBIN	<IO>
	CAIN	IO," "
	 JRST	DEXP3
	CAIE	IO,12
	 JRST	DEXP2
	DCBIN	<IO>
	CAIN	IO," "
	 JRST	DEXP3
	CALLR	RENLIN
	RETURN
DEXP3:	DCBIN	<IO>
	CAIE	IO,"R"
	 JRST	DEXP2
	DCBIN	<IO>
	CAIE	IO,"E"
	 JRST	DEXP2
	DCBIN	<IO>
	CAIE	IO,"C"
	 JRST	DEXP2
	DCBIN	<IO>
	CAIE	IO,"S"
	 JRST	DEXP2
	DCBIN	<IO>
	CAIE	IO,"="
	 JRST	DEXP2
	CALLR	DCNIN
	CALLR	RENLIN
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
	JUMPN	IO,DEXP4
	DCSOUT	<[ASCIZ/DELETE /],NBUF,[ASCIZ/."<FILES">/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	RETURN
DEXP4:	SETZ	IO,
	CALLR	D$OPEN
	 RETURN
	DCSOUT	<[ASCIZ/OPEN /],NBUF,<[ASCIZ/."<FILES">,SYN="<">/]>,SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/"<FILES">="<"> WITH STATUS EQ ' '/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JFCL
	DCSOUT	<[ASCIZ/CLOSE "<">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
	DCSOUT	<[ASCIZ/CLOSE "<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
	SETZM	OPENED
	ENDR
; DGET -- GET-RETRIEVE
;
DGET:	BEGINR	<IO,FLAG>
	SETZ	FLAG,
	SETO	IO,
	CALLR	D$OPEN
	 RETURN
	SKIPLE	VBUF
	 JRST	DGET1
	MOVEI	IO," "
	CALLR	D$VER
	 RETURN
	JRST	DGET2
DGET1:	CALLR	D$VEX
	 RETURN
DGET2:	DCSOUT	<[ASCIZ/"<GET">="<FILES">/]>
	HRRZI	IO,[ASCIZ/ STATUS EQ ' '/]
	CALLR	D$WITH
	DCSOUT	<SEMI>
	CALLR	NETOI
	 THUD
	MOVE	IO,[ASCII/;I249/]
	CALLR	RENFIP
	 RETURN
	CALLR	RENLIN
	SKIPE	FLAGNN
	 JRST	DGET$
	TSOUT	<[ASCIZ/ [Ok]/],CRLF>
DGET$:	SETZM	NSUM
	SETZM FLAGSM
DGET3:	CALLR	GETFIL
	 JRST	DGET4		; EXIT RETRIEVAL LOOP ON NETWORK EOF
	CALLR	LOCNFO
	SETZM	FLAGFE
	CALLR	LOCOO
	 SETOM	FLAGFE
	CALLR	GETDAT
	CALLR	LOCC
	SKIPE	FLAGTT
	 CALLR	NETRAT
	AOJA	FLAG,DGET3
DGET4:	CALLR	NETC
	MOVE	IO,[ASCII/;I269/]
	CALLR	RENFIP
	 JRST	DGETE
	CALLR	RENLIN
	CALLR	NETSUM
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	JUMPN	FLAG,RETN(1)
	TSOUT	<[ASCIZ/ (No Such File)/],CRLF>
	RETURN	SKIP,1
DGETE:	CALLR	D$CON
	ENDR
; FIELD LENGTHS IN WORDS FROM <GET>
	GET$F==SBSIZE		; FILENAME
	GET$E==SBSIZE		; EXTENSION
	GET$D==4		; DATE
; DLIN -- DATACOMPUTER LINK
;
DLIN:	BEGINR	<IO,UTIL,FLAG>
	MOVE	FLAG,FLAGDD
DLINI:	TSOUT	(<[BYTE (7)76,0,0,0,0]>)
	TSIN	(ABUF,SBSIZE,<[BYTE (7)76,0,0,0,0]>)
	 JRST	DLINI
	JUMPE	UTIL,DLINE
	TSOUT	<CRLF>
	SETZM	FLAGDD
	DCSOUT	<ABUF,CRLF>
	SETOM	FLAGDD
	CALLR	RENDER
	 JRST	DLINI
	JRST	DLINI
DLINE:	TSOUT	<[ASCIZ/[Returning]/],CRLF>
	MOVEM	FLAG,FLAGDD
	ENDR

; DLIS -- NODE DIRECTORY
;   IN:  FLAG -- ADDRESS OF ARGUMENT PROCESSING ROUTINE
;
DLIS:	BEGINR	<IO,BP,UTIL>
	CALLR	D$HEAD
	CAIN	FLAG,DL$T
	 JRST	DLISO1
	CAIN	FLAG,DL$V
	 JRST	DLISO2
	CAIN	FLAG,DL$P
	 JRST	DLISO3
	RETURN
DLISO1:	DCSOUT	<[ASCIZ/LIST /],NBUF,[ASCIZ/ %NAME/],SEMI>
	JRST	DLISI
DLISO2:	DCSOUT	<[ASCIZ/LIST /],NBUF,[ASCIZ/ %INFORMATION/],SEMI>
	JRST	DLISI
DLISO3:	DCSOUT	<[ASCIZ/LIST /],NBUF,[ASCIZ/ %PRIVILEGE/],SEMI>
DLISI:	SETZ	UTIL,
	SETZM	GBUF1
	MOVE	X1,[GBUF1,,GBUF1+1]
	BLT	X1,<GBUF1+LBSIZE-1>
	MOVEI	X1,<GBUF2+1>
	MOVEM	X1,GBUF2
	CALLR	RENPRE
	CAMN	IO,[ASCII/.I280/]
	 JRST	DLISD
	CALLR	RENLIP
	SETZM	FLAGDE
	CALLR	RENDER
	 RETURN
	RETURN
DLISN:	DCBIN	<IO>
	CAIE	IO," "
	 JRST	DLISE
	SETO	UTIL,
	SKIPE	FLAGDD
	 JRST	DLISD
	CALLR	<(FLAG)>
	JRST	DLISN
DLISD:	CALLR	RENLIN
	CAIE	FLAG,DL$V
	 JRST	DLISN
	CALLR	DL$V
DLISE:	CAIN	IO,"?"
	 JRST	DEATH
	CALLR	RENLIN
	SETZM	FLAGDE
	CALLR	RENDER
	 JRST	.+1
	JUMPN	UTIL,RETN(0)
	TSOUT	<[ASCIZ/  [No Nodes]/],CRLF>
	ENDR

; DL$T -- TERSE NODES
;
DL$T:	BEGINR
	CALLR	DL$NAM
	 JRST	DL$T0
	TSOUT	CRLF
DL$T0:	CALLR	RENLIN
	ENDR

; DL$V -- VERBOSE NODES
;
DL$V:	BEGINR
DL$VL:	DCBIN	<IO>
	CAIE	IO," "
	 RETURN
	SETO	UTIL,
	SKIPN	FLAGDD
	 JRST	DL$VN
	CALLR	RENLIN
	JRST	DL$VL
DL$VN:	CALLR	RENPRE
	CAME	IO,[ASCII/NAME=/]
	 JRST	DL$VT
	CALLR	DL$NAM
	 JRST	DL$VE
	TSOUT	CRLF
	MOVEI	FLAG,GBUF1
	SKIPE	(FLAG)
	 AOJA	FLAG,.-1
	SUBI	FLAG,GBUF1
	CALLR	RENLIN
	JRST	DL$VL
DL$VT:	MOVEM	IO,UBUF1
	SETZM	<UBUF1+1>
	MOVEI	IO,(FLAG)
DL$VT1:	TSOUT	<[ASCIZ/    /]>
	SOJGE	IO,DL$VT1
	MOVEI	IO,"]"
	TBOUT	<IO>
	TSOUT	<UBUF1>
DL$VT2:	DCBIN	<IO>
	TBOUT	<IO>
	CAIE	IO,12
	 JRST	DL$VT2
	JRST	DL$VL
DL$VE:	CALLR	RENLIN
	ENDR

; DL$P -- PROTECTION
;
DL$P:	BEGINR	<IO,BP>
	CALLR	DL$NAM
	 JRST	DL$P1
	TSOUT	CRLF
	CALLR	RENLIN
	RETURN
DL$P1:	MOVEI	IO,GBUF1
DL$P2:	SKIPE	(IO)
	 AOJA	IO,DL$P2
	SUBI	IO,GBUF1
DL$P3:	TSOUT	<[ASCIZ/    /]>
	SOJGE	IO,DL$P3
	MOVEI	IO,"]"
	TBOUT	<IO>
DL$P4:	DCBIN	<IO>
	TBOUT	<IO>
	CAIE	IO,12
	 JRST	DL$P4
	ENDR

; DL$NAM -- DIRECTORY: NAME OUTPUT
;   OUT: IO -- LAST CHARACTER INPUT
;
DL$NAM:	BEGINR	<BP,UTIL,FLAG,R10>
	SETZ	R10,
	SETZ	FLAG,
	MOVE	BP,[440700,,ABUF]
	MOVEI	UTIL,<SBSIZE*5>
	DCBIN	<IO>
	CAILE	IO," "
	 JRST	DL$NA1
	RETURN
DL$NAN:	DCBIN	<IO>
DL$NA1:	CAIN	IO,"."
	 JRST	DL$NIN
	CAIG	IO," "
	 JRST	DL$NA3
	CAIE	IO,42
	 JRST	DL$NA2
	DCBIN	<IO>
DL$NA2:	IDPB	IO,BP
	SOJG	UTIL,DL$NAN
	JRST	DL$NER
DL$NA3:	SETZ	X1,
	IDPB	X1,BP
	TSOUT	<[ASCIZ/  /],ABUF>
	RETURN	SKIP,1
DL$NIN:	MOVE	BP,[440700,,ABUF]
	MOVEI	UTIL,<SBSIZE*5>
DL$NI1:	DCBIN	<IO>
	CAIN	IO,"."
	 JRST	DL$NCN
	CAIG	IO," "
	 JRST	DL$NCN
DL$NI2:	CAIE	IO,42
	 JRST	DL$NI3
	DCBIN	<IO>
DL$NI3:	IDPB	IO,BP
	SOJG	UTIL,DL$NI1
	JRST	DL$NER
DL$NCN:	SETZ	X1,
	IDPB	X1,BP
	SKIPN	X2,GBUF1(FLAG)
	 JRST	DL$NON
	HRLI	X2,440700
	MOVE	X1,[440700,,ABUF]
DL$NC1:	ILDB	X3,X1
	ILDB	X4,X2
	CAIE	X3,(X4)
	 JRST	DL$NON
	JUMPN	X3,DL$NC1
	CAIG	IO," "
	 RETURN	SKIP,1
	AOJA	FLAG,DL$NIN
DL$NON:	CAIL	FLAG,LBSIZE-2
	 JRST	DL$NER
	SETZM	GBUF1+1(FLAG)
	HRL	X1,GBUF1+1(FLAG)
	HRR	X1,GBUF1+2(FLAG)
	BLT	X1,<GBUF1+LBSIZE-1>
	MOVE	X1,[440700,,ABUF]
	SKIPN	X2,GBUF1(FLAG)
	 HRR	X2,GBUF2
	HRLI	X2,440700
	HRRZI	BP,(BP)
	SUBI	BP,<ABUF-1>
	ADDI	BP,(X2)
	CAIL	BP,<GBUF2+LBSIZE>
	 JRST	DL$NER
	HRRZM	X2,GBUF1(FLAG)
DL$NO1:	ILDB	X3,X1
	IDPB	X3,X2
	JUMPN	X3,DL$NO1
	HRRZI	X2,1(X2)
	MOVEM	X2,GBUF2
	MOVEI	UTIL,(FLAG)
	JUMPE	R10,DL$NO2
	TSOUT	CRLF
DL$NO2:	TSOUT	<[ASCIZ/    /]>
	SOJGE	UTIL,DL$NO2
	TSOUT	<ABUF>
	SETO	R10,
	CAIG	IO," "
	 RETURN	SKIP,1
	AOJA	FLAG,DL$NIN
DL$NER:	TSOUT	<[ASCIZ/ (Pathname too long.)/],CRLF>
	ENDR
; DPUT -- PUT-STORE
;
DPUT:	BEGINR	<IO>
	CALLR	LOCFFI
	 RETURN
	SKIPN	OPENED
	 JRST	DPUT3
	MOVE	X1,[440700,,OPENED]
	MOVE	X2,[440700,,NBUF]
DPUT1:	ILDB	X3,X1
	ILDB	X4,X2
	CAIE	X3,(X4)
	 JRST	DPUT2
	JUMPN	X3,DPUT1
	MOVEI	X1,1
	CAMN	X1,OPENEM
	 JRST	DPUT5
	DCSOUT	<[ASCIZ/MODE "<FILES"> APPEND/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	MOVEI	X1,1
	MOVEM	X1,OPENEM
	JRST	DPUT5
DPUT2:	SETZM	OPENED
	DCSOUT	<[ASCIZ/CLOSE "<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
DPUT3:	DCSOUT	<[ASCIZ/LIST /],NBUF,[ASCIZ/."<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JRST	DPUT4
	DCSOUT	<[ASCIZ/OPEN /],NBUF,[ASCIZ/."<FILES"> APPEND/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	MOVE	X1,[440700,,NBUF]
	MOVE	X2,[440700,,OPENED]
	SCOPY	(X1,X2)
	MOVEI	X1,1
	MOVEM	X1,OPENEM
	JRST	DPUT5
DPUT4:	DCSOUT	<[ASCIZ/CREATE /],NBUF,[ASCIZ/."<FILES"> LIKE %TOP.DFTP."<FILE">/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	SKIPE	FLAGNN
	 JRST	DPUT$1
	TSOUT	<[ASCIZ/ [New <FILES>]/],CRLF>
DPUT$1:	MOVE	X1,[440700,,NBUF]
	MOVE	X2,[440700,,OPENED]
	SCOPY	(X1,X2)
	SETZM	OPENEM
	DCSOUT	<[ASCIZ/"<FILES">="<TERSE">/],SEMI>
	MOVE	IO,[ASCII/.I231/]
	CALLR	RENFIP
	 RETURN
	MOVEI	IO,"Z"-100
	DCBOUT	<IO>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/MODE "<FILES"> APPEND/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	MOVEI	X1,1
	MOVEM	X1,OPENEM
	SETZM	VBUF
	JRST	DPUT6
DPUT5:	SETZB	IO,VBUF
	CALLR	D$VER
	 RETURN
DPUT6:	AOS	VBUF
	DCSOUT	<[ASCIZ/"<FILES">="<PUT">/],SEMI>
	CALLR	NETOO
	 THUD
	MOVE	IO,[ASCII/;I239/]
	CALLR	RENFIP
	 RETURN
	CALLR	RENLIN
	SKIPE	FLAGNN
	 JRST	DPUT$2
	TSOUT	<[ASCIZ/ [Ok]/],CRLF>
DPUT$2:	SETZM	NSUM
	SETZM FLAGSM
	CALLR	LOCOI
	 THUD
	CALLR	NETFFI
DPUT7:	CALLR	PUTFIL
	CALLR	PUTDAT
	SKIPE	FLAGTT
	 CALLR	NETRAT
	CALLR	LOCNFI
	 JRST	DPUT7
	CALLR	NETC
	MOVE	IO,[ASCII/;I259/]
	CALLR	RENFIP
	 JRST	DPUTE
	CALLR	RENLIN
	CALLR	NETSUM
	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	RETURN	SKIP,1
DPUTE:	CALLR	D$CON
	ENDR
; DREM -- DELETE NODES
;
DREM:	BEGINR
	SKIPN	OPENED
	 JRST	DREM0
	DCSOUT	<[ASCIZ/CLOSE "<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
	SETZM	OPENED
DREM0:	DCSOUT	<[ASCIZ/DELETE /],NBUF,SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JFCL
	DCSOUT	<[ASCIZ/LIST /],CONTEX,SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 CAIA
	  RETURN
	TSOUT	<[ASCIZ/ [Connected To Attached Node]/],CRLF>
	MOVE	X1,[ASCII/%LOGI/]
	MOVEM	X1,CONTEX
	MOVE	X1,[ASCII/N/]
	MOVEM	X1,<CONTEX+1>
	ENDR
; DREN -- RENUMBER FILES
;
DREN:	BEGINR	<IO,UTIL>
	SETZ	IO,
	CALLR	D$OPEN
	 RETURN
	SETO	IO,
	CALLR	D$VER
	 RETURN
	MOVE	UTIL,VBUF
	MOVE	IO,ABUF
	MOVEM	IO,VBUF
	SETOM	FLAGDE
	DCSOUT	<[ASCIZ/BEGIN/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ DECLARE SAMEVERSION INTEGER/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ SAMEVERSION=0/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ FOR FILES IN "<FILES">/]>
	SETZ	IO,
	CALLR	D$WITH
	DCSOUT	<CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/  SAMEVERSION=SAMEVERSION+1/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ IF SAMEVERSION NE 0 THEN ERROR 'VERSION ALREADY EXISTS'/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/END/],SEMI>
	CALLR	RENDER
	 RETURN
	MOVEM	UTIL,VBUF
	DCSOUT	<[ASCIZ/BEGIN/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ DECLARE RENUMBERED INTEGER/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ RENUMBERED=0/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ UPDATE FILES IN "<FILES">/]>
	HRRZI	IO,[ASCIZ/ STATUS EQ ' '/]
	CALLR	D$WITH
	DCSOUT	<CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ BEGIN/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/  COMMENT FILES.FILE.HEADER.FILENAME/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/   ! '.' ! FILES.FILE.HEADER.EXTENSION/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/    ! ';' ! FILES.FILE.HEADER.VERSION/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/  VERSION=/]>
	MOVE	IO,ABUF
	DCNOUT	<IO>
	DCSOUT	<CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/  RENUMBERED=RENUMBERED+1/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ END/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/ IF RENUMBERED EQ 0 THEN ERROR 'NO SUCH FILE'/],CRLF>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/END/],SEMI>
	CALLR	RENDER
	 RETURN
	ENDR
; DUND -- UNDELETE
;
DUND:	BEGINR	<IO>
	SETZ	IO,
	CALLR	D$OPEN
	 RETURN
	MOVEI	IO,"D"
	CALLR	D$VER
	 RETURN
	SETOM	FLAGDE
	DCSOUT	<[ASCIZ/BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	DECLARE UNDELETED INTEGER
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	UNDELETED=0
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	UPDATE FILES IN "<FILES">/]>
	HRRZI	IO,[ASCIZ/ STATUS EQ 'D'/]
	CALLR	D$WITH
	DCSOUT <[ASCIZ/
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		STATUS=' '
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		UNDELETED=UNDELETED+1
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		COMMENT FILES.FILE.HEADER.FILENAME
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		  ! '.' ! FILES.FILE.HEADER.EXTENSION
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		    ! ';' ! FILES.FILE.HEADER.VERSION
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	END
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	IF UNDELETED EQ 0 THEN ERROR 'NO SUCH FILE'
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/END;
/]>
	CALLR	RENDER
	 RETURN
	ENDR
; D$INIT -- INITIALIZE DATACOMPUTER SESSION
;
D$INIT:	BEGINR	<IO,BP,UTIL,FLAG>
	SETZM	FLAGDE
	SETZM	LOGIN%
	CALLR	RENDER
	 CAIA
	  JRST	D$IN0
	TSOUT	<[ASCIZ/ ?? Datacomputer initialization failure ??/],CRLF>
	JRST	QUIT
D$IN0:	TSOUT	<[ASCIZ/ [Attaching]/],CRLF>
	MOVE	IO,[440700,,[ASCIZ/%TOP.DFTP.ITS/]]
	MOVE	BP,[440700,,ABUF]
	SCOPY	(IO,BP)
	HRRZ	IO,(UTIL)
	HRLI	IO,440700
	SCOPY	(IO,BP)
	MOVEI	IO,"."
	IDPB	IO,BP
	.SUSET [.RXUNAME,,UBUF1]
	SETZM UBUF1+1
	MOVE	X1,[440600,,UBUF1]
	MOVEI	X2,42
D$IN3:	ILDB	X3,X1
	JUMPE	X3,D$IN4
	ADDI	X3,40
	CAIL	X3,"A"
	 CAILE	X3,"Z"
	  IDPB	X2,BP
	IDPB	X3,BP
	JRST	D$IN3
D$IN4:	MOVE	X1,BP
	IDPB	X3,X1
	DCSOUT	<[ASCIZ/LOGIN /],ABUF,SEMI>
	CALLR	RENPRE
	CALLR	RENLIN
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
	CAMN	IO,[ASCII/;O032/]
	 JRST	D$INP
	CAME	IO,[ASCII/+U107/]
	 JRST	D$IND
	MOVEI	FLAG,3
D$IN2:	TSOUT	<[ASCIZ/  [Password:/]>
	TSIN	(UBUF1,LBSIZE,<[ASCIZ/  [Password:/]>,NOECHO)
	 JRST	D$IN2
	TSOUT	<[ASCIZ/]/],CRLF>
	MOVE	X2,BP
	MOVEI	X1,"("
	IDPB	X1,X2
	MOVEI	X1,"'"
	IDPB	X1,X2
	MOVE	X1,[440700,,UBUF1]
	SCOPY	(X1,X2)
	MOVEI	X1,"'"
	IDPB	X1,X2
	MOVEI	X1,")"
	IDPB	X1,X2
	SETZ	X1,
	IDPB	X1,X2
	DCSOUT	<[ASCIZ/LOGIN /],ABUF,SEMI>
	CALLR	RENDER
	 CAIA
	  JRST	D$INP
	TSOUT	<[ASCIZ/   (Incorrect password)/],CRLF>
	SOJG	FLAG,D$IN2
	TSOUT	<[ASCIZ/ [Attaching]/],CRLF>
D$IND:	MOVE	X1,[440700,,[ASCIZ/%TOP.DFTP.DFTP.GUEST/]]
	MOVE	X2,[440700,,ABUF]
	SCOPY	(X1,X2)
	DCSOUT	<[ASCIZ/LOGIN %TOP.DFTP.DFTP.GUEST/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JRST	QUIT
	TSOUT	<[ASCIZ/  (as DFTP.GUEST)/],CRLF>
D$INP:	DCSOUT	<[ASCIZ/OPEN %TOP.DFTP."<GET"> READ/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JRST	QUIT
	DCSOUT	<[ASCIZ/OPEN %TOP.DFTP."<PUT"> WRITE/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JRST	QUIT
	DCSOUT	<[ASCIZ/OPEN %TOP.DFTP."<TERSE"> READ/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JRST	QUIT
	DCSOUT	<[ASCIZ/OPEN %TOP.DFTP."<VERBOSE"> READ/],SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JRST	QUIT
	SETZM	LOGIN%
	MOVE	UTIL,[ASCII/%LOGI/]
	MOVEM	UTIL,CONTEX
	MOVE	UTIL,[ASCII/N/]
	MOVEM	UTIL,<CONTEX+1>
	SETZM	OPENED
	CALLR	D$CON
	ENDR
; D$CON -- CONNECT
;
D$CON:	BEGINR	<UTIL>
	CALLR	NETDSI
	DCSOUT	<[ASCIZ/CONNECT "<GET"> /]>
	DCNOUT	<UTIL>
	DCSOUT	<SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JRST	QUIT
	CALLR	NETDSO
	DCSOUT	<[ASCIZ/CONNECT "<PUT"> /]>
	DCNOUT	<UTIL>
	DCSOUT	<SEMI>
	SETOM	FLAGDE
	CALLR	RENDER
	 JRST	QUIT
	ENDR
; D$HEAD -- PRINT HEADER FOR DDIR AND DLIS
;   IN: FLAG -- DIRECTORY DISPATCH ROUTINE
;
D$HEAD:	BEGINR	<IO,BP,UTIL>
	MOVE	IO,NBUF
	CAMN	IO,[ASCII/%TOP./]
	 JRST	D$HET1
	CAMN	IO,[ASCII/%LOGI/]
	 JRST	D$HEL1
	RETURN
D$HET1:	SKIPE	FLAGDD
	 RETURN
	TSOUT	[ASCIZ/ <<</]
	MOVE	BP,[440700,,NBUF+1]
D$HET2:	ILDB	IO,BP
	JUMPE	IO,D$HEF1
	CAIE	IO,"."
	 JRST	D$HET2
D$HET3:	ILDB	IO,BP
	JUMPE	IO,D$HEF1
	CAIN	IO,42
	 JRST	D$HET3
	CAIN	IO,"("		; ( -- PASSWORD
	 JRST	D$HET4
	CAIN	IO,"."
	 MOVEI	IO,">"
	TBOUT	<IO>
	JRST	D$HET3
D$HET4:	IBP	BP		; '
D$HET5:	ILDB	IO,BP
	JUMPE	IO,D$HEF1
	CAIN	IO,42
	 JRST	D$HET5
	CAIE	IO,"'"		; '
	 JRST	D$HET5
	IBP	BP		; )
	JRST	D$HET3
D$HEL1:	SKIPE	LOGIN%
	 JRST	D$HEL5
	DCSOUT	<[ASCIZ/LIST %LOGIN %NAME/],SEMI>
	CALLR	RENPRE
	CALLR	RENLIN
	CAMN	IO,[ASCII/.I280/]
	 JRST	D$HEL2
	SETZM	FLAGDE
	CALLR	RENDER
	 RETURN
	RETURN
D$HEL2:	DCBIN	<IO>
	CAIN	IO,15
	 JRST	D$HEL4
	CAIE	IO,"."
	 JRST	D$HEL2
	MOVE	BP,[440700,,LOGIN%]
D$HEL3:	DCBIN	<IO>
	CAIN	IO,15
	 JRST	D$HEL4
	CAIN	IO," "
	 JRST	D$HEL4
	CAIN	IO,42
	 JRST	D$HEL3
	CAIN	IO,"."
	 MOVEI	IO,">"
	IDPB	IO,BP
	JRST	D$HEL3
D$HEL4:	SETZ	IO,
	IDPB	IO,BP
	CALLR	RENLIN
	SETZM	FLAGDE
	CALLR	RENDER
	 JRST	.+1
D$HEL5:	SKIPE	FLAGDD
	 RETURN
	TSOUT	[ASCIZ/ <<</]
	TSOUT	LOGIN%
	MOVE	BP,[260700,,NBUF+1]
	LDB	IO,BP
	JUMPE	IO,D$HEF1
	MOVEI	IO,">"
	TBOUT	<IO>
D$HEL6:	ILDB	IO,BP
	JUMPE	IO,D$HEF1
	CAIN	IO,42
	 JRST	D$HEL6
	CAIN	IO,"("		; ( -- PASSWORD
	 JRST	D$HEL7
	CAIN	IO,"."
	 MOVEI	IO,">"
	TBOUT	<IO>
	JRST	D$HEL6
D$HEL7:	IBP	BP		; '
D$HEL8:	ILDB	IO,BP
	JUMPE	IO,D$HEF1
	CAIN	IO,42
	 JRST	D$HEL8
	CAIE	IO,"'"		; '
	 JRST	D$HEL8
	IBP	BP		; )
	JRST	D$HEL6
D$HEF1:	CAIN	FLAG,DD$D
	 JRST	D$HEF2
	CAIN	FLAG,DD$T
	 JRST	D$HEF2
	CAIN	FLAG,DD$V
	 JRST	D$HEF2
	JRST	D$HED1
D$HEF2:	MOVEI	IO,">"
	TBOUT	<IO>
	TSOUT	<FBUF>
	MOVEI	IO,"."
	TBOUT	<IO>
	TSOUT	<EBUF>
	SKIPN	VBUF
	 JRST	D$HEF4
	MOVEI	IO,";"
	TBOUT	<IO>
	SKIPG	IO,VBUF
	 JRST	D$HEF3
	TNOUT	<IO>
	JRST	D$HEF4
D$HEF3:	MOVEI	IO,"*"
	TBOUT	<IO>
D$HEF4:	CAIE	FLAG,DD$D
	 JRST	D$HED1
	TSOUT	<[ASCIZ/[Deleted]/]>
D$HED1:	TSOUT	<[ASCIZ/    /]>
	.CALL [	SETZ
		SIXBIT/RQDATE/
		SETZM UTIL]
	 MOVSI UTIL,124201
	MOVE	BP,[440700,,UBUF2]
	CALLR	LUTTNS
	TSOUT	<UBUF2,CRLF>
	ENDR
; D$OPEN -- OPEN PROPER <FILES> IN PROPER MODE
;   IN: IO -- MODE FLAG
;			READ IF < 0
;			WRITE IF = 0
;			APPEND IF > 0
;
D$OPEN:	BEGINR
	SKIPN	OPENED
	 JRST	D$OP05
	MOVE	X1,[440700,,OPENED]
	MOVE	X2,[440700,,NBUF]
D$OP01:	ILDB	X3,X1
	ILDB	X4,X2
	CAIE	X3,(X4)
	 JRST	D$OP05
	JUMPN	X3,D$OP01
	CAMN	IO,OPENEM
	 RETURN	SKIP,1
	JUMPE	IO,D$OP02
	JUMPG	IO,D$OP03
	DCSOUT	<[ASCIZ/MODE "<FILES"> READ/],SEMI>
	JRST	D$OP04
D$OP02:	DCSOUT	<[ASCIZ/MODE "<FILES"> WRITE/],SEMI>
	JRST	D$OP04
D$OP03:	DCSOUT	<[ASCIZ/MODE "<FILES"> APPEND/],SEMI>
D$OP04:	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	MOVEM	IO,OPENEM
	RETURN	SKIP,1
D$OP05:	DCSOUT	<[ASCIZ/LIST /],NBUF,[ASCIZ/."<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 CAIA
	  JRST	D$OP06
	TSOUT	<[ASCIZ/ (There are no <FILES>)/],CRLF>
	RETURN
D$OP06:	SKIPN	OPENED
	 JRST	D$OP07
	DCSOUT	<[ASCIZ/CLOSE "<FILES">/],SEMI>
	SETZM	FLAGDE
	CALLR	RENDER
	 JFCL
	SETZM	OPENED
D$OP07:	JUMPE	IO,D$OP08
	JUMPG	IO,D$OP09
	DCSOUT	<[ASCIZ/OPEN /],NBUF,[ASCIZ/."<FILES"> READ/],SEMI>
	JRST	D$OP10
D$OP08:	DCSOUT	<[ASCIZ/OPEN /],NBUF,[ASCIZ/."<FILES"> WRITE/],SEMI>
	JRST	D$OP10
D$OP09:	DCSOUT	<[ASCIZ/OPEN /],NBUF,[ASCIZ/."<FILES"> APPEND/],SEMI>
D$OP10:	SETOM	FLAGDE
	CALLR	RENDER
	 RETURN
	MOVE	X1,[440700,,NBUF]
	MOVE	X2,[440700,,OPENED]
	SCOPY	(X1,X2)
	MOVEM	IO,OPENEM
	ENDR	SKIP,1
; D$VER -- PRODUCE PROPER VERSION NUMBER
;   IN: IO -- DEFAULT FLAG
;			SMALLEST UNDELETED VERSION IF < 0
;			LARGEST VERSION IF = 0
;			LARGEST DELETED VERSION IF = "D"
;			LARGEST UNDELETED VERSION IF = " "
;   OUT: IO -- VERSION (IF DEFAULT)
;
D$VER:	BEGINR	<UTIL>
	SKIPE	VBUF
	 RETURN	SKIP,1
	JUMPE	IO,D$VER1
	LDB	UTIL,[350700,,FBUF]
	CAIN	UTIL,"*"
	 SETOM	VBUF
	LDB	UTIL,[350700,,EBUF]
	CAIN	UTIL,"*"
	 SETOM	VBUF
	SKIPE	VBUF
	 RETURN	SKIP,1
	JUMPG	IO,D$VER2
	SETOM	FLAGDE
	DCSOUT	<[ASCIZ/BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	DECLARE LEAST INT
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	LEAST=-1
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	FOR "<FILES">
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	  WITH (FILENAME EQ '/],FBUF,[ASCIZ/')
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	    AND (EXTENSION EQ '/],EBUF,[ASCIZ/')
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	      AND (STATUS EQ ' ')/],[ASCIZ/
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		IF LEAST EQ -1 THEN LEAST=VERSION ELSE
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/			IF LEAST GT VERSION THEN LEAST=VERSION
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	END
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	IF LEAST EQ -1 THEN ERROR 'NO SUCH FILE' ELSE
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		COMMENT '~' ! LEAST
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/END/],SEMI>
	JRST	D$VERE
D$VER1:	SETOM	FLAGDE
	DCSOUT	<[ASCIZ/BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	DECLARE GREATEST INT
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	GREATEST=0
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	FOR "<FILES">/]>
	CALLR	D$WITH
	DCSOUT	<[ASCIZ/
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		IF GREATEST LT VERSION THEN GREATEST=VERSION
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	END
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	COMMENT '~' ! GREATEST
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/END/],SEMI>
	JRST	D$VERE
D$VER2:	SETOM	FLAGDE
	DCSOUT	<[ASCIZ/BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	DECLARE GREATEST INT
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	GREATEST=-1
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	FOR "<FILES">
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	  WITH (FILENAME EQ '/],FBUF,[ASCIZ/')
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	    AND (EXTENSION EQ '/],EBUF,[ASCIZ/')
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	      AND (STATUS EQ '/]>
	DCBOUT	<IO>
	SKIPN	FLAGDD
	 JRST	D$VER$
	TBOUT	<IO>
D$VER$:	DCSOUT	<[ASCIZ/')
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		IF GREATEST LT VERSION THEN GREATEST=VERSION
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	END
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	IF GREATEST EQ -1 THEN ERROR 'NO SUCH FILE' ELSE
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		COMMENT '~' ! GREATEST
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/END/],SEMI>
D$VERE:	MOVE	IO,[ASCII/;A282/]
	CALLR	RENFIP
	 RETURN
D$VERN:	DCBIN	<IO>
	CAIE	IO,"~"
	 JRST	D$VERN
	CALLR	DCNIN
	MOVEM	IO,VBUF
	CALLR	RENLIN
	CALLR	RENDER
	 RETURN
	ENDR	SKIP,1
; D$VEX -- VERIFY THAT VERSION EXISTS
;
D$VEX:	BEGINR	<IO>
	SETOM	FLAGDE
	DCSOUT	<[ASCIZ/BEGIN
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	DECLARE EXTANT INT
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	EXTANT=0
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	FOR "<FILES">
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	  WITH (FILENAME EQ '/],FBUF,[ASCIZ/')
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	    AND (EXTENSION EQ '/],EBUF,[ASCIZ/')
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	      AND (VERSION EQ /]>
	MOVE	IO,VBUF
	DCNOUT	<IO>
	DCSOUT	<RPAREN>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/		AND (STATUS EQ ' ')
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/			EXTANT=EXTANT+1
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/	IF EXTANT NE 1 THEN ERROR 'NO SUCH FILE'
/]>
	CALLR	RENDER
	 RETURN
	DCSOUT	<[ASCIZ/END/],SEMI>
	CALLR	RENDER
	 RETURN
	ENDR	SKIP,1
; D$WITH -- GENERATE A QUALIFIED WITH CLAUSE (CONSIDER *'S)
;   IN: IO -- POINTER TO FIXED QUALIFIER (OR 0)
;   FLAGS:
	D$W$F==400000
	D$W$E==200000
	D$W$V==100000
	D$W$Q==010000
;
D$WITH:	BEGINR	<UTIL,FLAG>
	SETZ	FLAG,
	LDB	UTIL,[350700,,FBUF]
	CAIE	UTIL,"*"
	 TRO	FLAG,D$W$F
	LDB	UTIL,[350700,,EBUF]
	CAIE	UTIL,"*"
	 TRO	FLAG,D$W$E
	SKIPLE	VBUF
	 TRO	FLAG,D$W$V
	SKIPE	IO
	 TRO	FLAG,D$W$Q
	JUMPE	FLAG,RETN(0)
	DCSOUT	<[ASCIZ/ WITH/]>
	TRNN	FLAG,D$W$F
	 JRST	D$WIT1
	DCSOUT	<[ASCIZ/ FILENAME EQ '/],FBUF,[ASCIZ/'/]>
	TRNN	FLAG,D$W$E!D$W$V!D$W$Q
	 RETURN
	DCSOUT	<[ASCIZ/ AND/]>
D$WIT1:	TRNN	FLAG,D$W$E
	 JRST	D$WIT2
	DCSOUT	<[ASCIZ/ EXTENSION EQ '/],EBUF,[ASCIZ/'/]>
	TRNN	FLAG,D$W$V!D$W$Q
	 RETURN
	DCSOUT	<[ASCIZ/ AND/]>
D$WIT2:	TRNN	FLAG,D$W$V
	 JRST	D$WIT3
	DCSOUT	<[ASCIZ/ VERSION EQ /]>
	MOVE	UTIL,VBUF
	DCNOUT	<UTIL>
	TRNN	FLAG,D$W$Q
	 RETURN
	DCSOUT	<[ASCIZ/ AND/]>
D$WIT3:	TRNN	FLAG,D$W$Q
	 RETURN
	DCSOUT	<(IO)>
	ENDR
; NETSUM -- NETWORK CHECKSUM VERIFICATION
;
NETSUM:	BEGINR	<IO,FLAG>
	CALLR	RENPRE
	CAME	IO,[ASCII/;I275/]
	 JRST	NETS2
	SETZ	FLAG,
NETS1:	DCBIN	<IO>
	CAIE	IO,"="
	 JRST	NETS1
	SKIPN	FLAG
	 SOJA	FLAG,NETS1
	CALLR	DCNIN
	CAME	IO,NSUM
	 JRST	NETS3
	CALLR	RENLIN
	RETURN
NETS2:	CALLR	RENLIP
	RETURN
NETS3:	CALLR	RENLIN
	TSOUT	<[ASCIZ/ (Network Checksum Error)/],CRLF>
	ENDR

; NETRAT -- CALCULATE AND PRINT RATE
;
NETRAT:	BEGINR	<IO,<IO+1>>
	TSOUT	<[ASCIZ/ (/]>
	MOVEI	IO,^D36
	IMULB	IO,NSIZE
	IDIV	IO,NTIME
	TNOUT	<IO>
	TSOUT	<[ASCIZ/ Baud (/]>
	MOVE	IO,NSIZE
	TNOUT	<IO>
	TSOUT	<[ASCIZ/ bits in /]>
	SKIPN	IO,NTIME
	 MOVEI	IO,1
	TNOUT	<IO>
	HRRZI	<IO+1>,[ASCIZ/ seconds))/]
	CAIN	IO,1
	 HRRZI	<IO+1>,[ASCIZ/ second))/]
	TSOUT	<(IO+1),CRLF>
	ENDR
; RENDER -- REQUEST ENDER (ASSUMES INITIAL RENLIN)
;
RENDER:	BEGINR	<IO,UTIL,FLAG>
	SETZ	FLAG,
RENDSL:	CALLR	RENPRE
	CAMN	IO,[ASCII/.I220/]
	 JRST	RENDES
	CAMN	IO,[ASCII/.I210/]
	 JRST	RENDRR
	CAME	IO,[ASCII/;A282/]
	 CAMN	IO,[ASCII/.J151/]
	  JRST	RENDPM
	LDB	UTIL,[350700,,IO]
	CAIE	UTIL,"+"
	 CAIN	UTIL,"-"
	  CAIA
	   JRST	RENDFL
	SETO	FLAG,
	SKIPN	FLAGDE
	 JRST	RENDFL
	SETZM	FLAGDE
RENDPM:	CALLR	RENLIP
	JRST	RENDSL
RENDFL:	CALLR	RENLIN
	JRST	RENDSL
RENDES:	CALLR	RENLIN
	MOVEI	IO,"L"-100
	DCBOUT	<IO>
	SETO	FLAG,
	JRST	RENDSL
RENDRR:	CALLR	RENLIN
	JUMPN	FLAG,RETN(0)
	ENDR	SKIP,1

; RENFIP -- FIND PREFIX (ASSUMES INITIAL RENLIN)
;   IN: IO -- PREFIX
;
RENFIP:	BEGINR	<BP,UTIL,FLAG>
	MOVE	FLAG,IO
	SETZ	UTIL,
RENFIL:	CALLR	RENPRE
	CAMN	IO,FLAG
	 RETURN	SKIP,1
	LDB	BP,[350700,,IO]
	CAIE	BP,";"
	 CAIN	BP,"."
	  JRST	RENFIN
	SKIPN	UTIL
	 CALLR	RENLIP
	SKIPE	UTIL
	 CALLR	RENLIN
	AOJA	UTIL,RENFIL
RENFIN:	CALLR	RENLIN
	CAMN	IO,[ASCII/.I220/]
	 JRST	RENFIS
	CAMN	IO,[ASCII/.I210/]
	 RETURN
	JRST	RENFIL
RENFIS:	MOVEI	IO,"L"-100
	DCBOUT	<IO>
	SETZM	FLAGDE
	CALLR	RENDER
	 RETURN
	ENDR

; RENLIN -- REQUEST END: PROCEED TO NEW LINE
;
RENLIN:	BEGINR	<IO>
RENLNL:	DCBIN	<IO>
	CAIE	IO,12
	 JRST	RENLNL
	ENDR

; RENLIP -- REQUEST END: PROCEED TO NEW LINE, PRINT MESSAGE
;
RENLIP:	BEGINR	<IO>
	SKIPN	FLAGDD
	 JRST	RENLPF
RENLPL:	DCBIN	<IO>
	CAIE	IO,12
	 JRST	RENLPL
	RETURN
RENLPF:	DCBIN	<IO>
	CAIN	IO,12
	 RETURN
	CAIE	IO,11
	 JRST	RENLPF
	MOVEI	IO," "
	TBOUT	<IO>
	MOVEI	IO,"("
RENLPP:	TBOUT	<IO>
RENLPQ:	DCBIN	<IO>
	CAIN	IO,42
	 JRST	RENLPQ
	CAIE	IO,15
	 JRST	RENLPP
	DCBIN	<IO>
	MOVEI	IO,")"
	TBOUT	<IO>
	TSOUT	<CRLF>
	ENDR

; RENPRE -- REQUEST END: RETURN ERROR PREFIX (ASSUMES RENLIN)
;   OUT: IO -- ASCII PREFIX (5 BYTES)
;
RENPRE:	BEGINR	<BP,UTIL,FLAG>
RENPRP:	SETZ	IO,
	MOVE	BP,[440700,,IO]
	MOVEI	FLAG,5
RENPRL:	DCBIN	<UTIL>
	CAIE	UTIL,15
	 CAIN	UTIL,12
	  JRST	RENPRL
	IDPB	UTIL,BP
	SOJG	FLAG,RENPRL
	LDB	UTIL,[350700,,IO]
	CAIN	UTIL,"?"
	 JRST	DEATH
	CAIE	UTIL,"!"
	 RETURN
	SKIPN	FLAGNN
	 CALLR	RENLIP
	JRST	RENPRP
	ENDR
; DEATH -- FATAL DATACOMPUTER ERROR (? MESSAGE)
;
DEATH:	CALLR	RENLIP
	TSOUT	<[ASCIZ/ ?? Fatal Datacomputer Error ??/],CRLF>
	.VALUE
	.LOGOUT 1,
	SUBTTL I/O Routines
PRINTX (I/O routines)

; TAIN -- TERMINAL AUTHORIZATION INPUT
;   IN: X1 -- POINTER TO CONFIRMATION MESSAGE
;
$TAIN$:	BEGINR	<IO>
TAIN1:	MOVEI	IO,(X1)
	TSOUT	<(IO)>
TAIN5:	TBIN	<IO>
	CAIN	IO,15
	 JRST	TAIN5
	CAIN	IO,"R"-100
	 JRST	TAIN1
	CAIN	IO,"N"
	 JRST	TAIN2
	CAIN	IO,"Y"
	 JRST	TAIN3
	CAIE	IO,12
	 CAIN	IO,33
	  JRST	TAIN4
	CAIE	IO,37
	 CAIN	IO," "
	  JRST	TAIN4
	TSOUT	<[ASCIZ/XXX/],CRLF>
	RETURN
TAIN2:	TSOUT	<[ASCIZ/No/],CRLF>
	RETURN	SKIP,1
TAIN3:	TSOUT	<[ASCIZ/Yes/]>
TAIN4:	TSOUT	<CRLF>
	ENDR	SKIP,2
; TERMINAL COMMAND INPUT ROUTINE
;
;   WHEN ENOUGH OF A COMMAND IS RECEIVED TO UNIQUELY IDENTIFY IT,
;     INPUT NOT CONFORMING TO THE REST OF THE COMMAND IS NOT ACCEPTED.
;   IF THE COMMAND IS UNIQUELY IDENTIFIED, AN ALTMODE, CARRIAGE RETURN,
;     LINE FEED, EOL, OR SPACE WILL FINISH IT.
;     IF NOT, SUCH CHARACTERS WILL BE REJECTED.
;   ^A AND RUBOUT DELETE THE LAST CHARACTER, ^R RETYPES THE INPUT LINE,
;     ^X AND ^U DELETE THE LINE (RETURN TCIO=-1).
;
;	IN: TCIO -- POINTER TO ^R TEXT,,POINTER TO CONTROL BLOCK
;			POINTER TO COMMAND STRING LIST
;			NUMBER OF COMMANDS
;			NUMBER OF CHARACTERS IN LARGEST COMMAND STRING
;			NUMBER OF WORDS IN LARGEST COMMAND STRING
;			<VALUE LIST>
;			<COMMAND STRING LIST>
;	OUT: TCIO -- LAST CHAR INPUT
;	     FLAG -- COMMAND VALUE
;	RETURNS: SKIP,0 -- DELETE LINE
;		 SKIP,1 -- NULL COMMAND
;		 SKIP,2 -- COMMAND RECOGNIZED
;
$TCIN$:	BEGINR	<TCIBP,TCIACB,TCITLP,TCITCC,TCIPBP,TCIPCC,TCISBP,TCISCC,TCIMAC,TCIMAN,UTIL>
	MOVE	TCIACB,TCIO
	SETZ	UTIL,
TCII01:	MOVEM	UTIL,TCIPCL(UTIL)
	ADDI	UTIL,1
	CAME	UTIL,1(TCIACB)
	 JRST	TCII01
	ADDI	UTIL,TCIPCL
	MOVEM	UTIL,TCIPNF
	HRRI	UTIL,TCIPCL
	HRL	UTIL,1(TCIACB)
	MOVEM	UTIL,TCIPLP
	MOVE	TCIBP,[440700,,ABUF]
	HRLI	TCISBP,350700
	HRR	TCISBP,(TCIACB)
	SETZ	TCISCC,
TCICHR:	TBIN	<TCIO>
	CAIN	TCIO,"R"-100
	 JRST	TCIREP
	CAIN	TCIO,"?"
	 JRST	TCIQUA
	CAIE	TCIO,177
	 CAIN	TCIO,"A"-100
	  JRST	TCIDEL
	CAIE	TCIO,"U"-100
	 CAIN	TCIO,"X"-100
	  JRST	TCIENR
	CAIN	TCIO,15
	 JRST	TCICHR
	CAIE	TCIO,12
	 CAIN	TCIO,37
	  JRST	TCIC01
	CAIE	TCIO," "
	 CAIN	TCIO,33
	  JRST	TCIC01
	CAIG	TCIO," "
	 JRST	TCIBAD
	JRST	TCIC02
TCIC01:	JUMPE	TCISCC,TCIENN
	HLRZ	UTIL,TCIPLP(TCISCC)
	CAIN	UTIL,1		; OK IF JUST ONE POSSIBILITY
	 JRST	TCIEND
TCIC02:	SETZ	TCIPCC,
	MOVE	TCIPBP,TCISBP
	MOVE	UTIL,TCIPNF
	MOVEM	UTIL,<TCIPLP+1>(TCISCC)
	SETZ	TCIMAC,
	HRRZI	TCIMAN,-1
TCIC03:	LDB	UTIL,TCIPBP
	JUMPE	UTIL,TCIC04
	CAIE	UTIL,(TCIO)
	 JRST	TCIC08
TCIC04:	HLRZ	TCITCC,TCIPLP(TCISCC)
	HRRZ	TCITLP,TCIPLP(TCISCC)
TCIC05:	MOVE	UTIL,(TCITLP)
	CAIN	UTIL,(TCIPCC)
	 JRST	TCIC06
	AOJ	TCITLP,
	SOJG	TCITCC,TCIC05
	JRST	TCIC08
TCIC06:	LDB	UTIL,TCIPBP
	JUMPE	UTIL,TCIC07
	MOVEM	TCIPCC,@TCIPNF
	AOS	TCIPNF
	AOJA	TCIMAC,TCIC08
TCIC07:	CAIN	TCIMAN,-1
	 SETO	TCIMAN,
	CAIE	TCIMAN,-1
	 HRRZI	TCIMAN,(TCIPCC)
TCIC08:	ADD	TCIPBP,3(TCIACB)
	AOJ	TCIPCC,
	CAME	TCIPCC,1(TCIACB)
	 JRST	TCIC03
	CAIE	TCIO,12
	 CAIN	TCIO,37
	  JRST	TCIC09
	CAIN	TCIO," "
	 JRST	TCIC09
	CAIE	TCIO,33
	 JRST	TCIC10
TCIC09:	JUMPL	TCIMAN,TCIBAD
	CAIN	TCIMAN,-1
	 JRST	TCIBAD
	JRST	TCIEND
TCIC10:	JUMPE	TCIMAC,TCIBAD
	AOJ	TCISCC,
	HRLM	TCIMAC,TCIPLP(TCISCC)
	IBP	TCISBP
	IDPB	TCIO,TCIBP
	TBOUT	<TCIO>		; ECHO
	JRST	TCICHR
TCIBAD:	MOVEI	TCIO,"G"-100
	TBOUT	<TCIO>
	JRST	TCICHR
TCIREP:	TSOUT	<CRLF>
	HLRZ	UTIL,TCIACB
	TSOUT	<(UTIL)>
	HRRZI	TCIPCC,(TCISCC)	; OUTPUT LOOP CONTROL = CHARS SO FAR
	MOVE	TCIPBP,[440700,,ABUF]
TCIR01:	SOJL	TCIPCC,TCICHR
	ILDB	TCIO,TCIPBP
	TBOUT	<TCIO>
	JRST	TCIR01
TCIQUA:	TBOUT	<TCIO>		; PRINT "?"
	HLRZ	TCIPCC,TCIPLP(TCISCC) ; PRINT THE POSSIBLE COMMAND LIST
	HRRZ	TCIPBP,TCIPLP(TCISCC)
TCIQ01:	TSOUT	<CRLF>
	MOVEI	TCIO,11
	TBOUT	<TCIO>
	MOVE	TCITCC,2(TCIACB)
	MOVE	TCITLP,(TCIPBP)
	IMUL	TCITLP,3(TCIACB)
	ADD	TCITLP,(TCIACB)
	HRLI	TCITLP,440700
TCIQ02:	ILDB	TCIO,TCITLP
	JUMPE	TCIO,TCIQ03
	TBOUT	<TCIO>
	SOJG	TCITCC,TCIQ02
TCIQ03:	AOJ	TCIPBP,
	SOJG	TCIPCC,TCIQ01
	JRST	TCIREP
TCIDEL:	JUMPLE	TCISCC,TCIENR	; THERE'S NO CHARACTER TO DELETE
	MOVEI	TCIO,"\"
	TBOUT	<TCIO>
	LDB	TCIO,TCIBP
	TBOUT	<TCIO>
	ADD TCIBP,[070000,,0]		; BACK UP LINE BYTE PTR
	TLNE TCIBP,400000
	 SUB TCIBP,[430000,,1]
	HRRZ	UTIL,TCIPLP(TCISCC) ; RESET TCIPNF
	MOVEM	UTIL,TCIPNF
	ADD TCISBP,[070000,,0]		; BACK UP SCAN BYTE PTR
	TLNE TCISBP,400000
	 SUB TCISBP,[430000,,1]
	SOJA	TCISCC,TCICHR
TCIENR:	TSOUT	<[ASCIZ/XXX/],CRLF>
	SETZ	FLAG,
	RETURN
TCIENN:	SETZ	FLAG,
	RETURN	SKIP,1
TCIEND:	MOVE	TCITLP,TCIPLP(TCISCC) ; COMMAND NUMBER
	MOVE	TCITLP,(TCITLP)
	IMUL	TCITLP,3(TCIACB)
	ADD	TCITLP,(TCIACB)
	HRLI	TCITLP,440700
	SETZ	TCITCC,
TCIE01:	IBP	TCITLP
	AOJ	TCITCC,
	CAIE	TCITCC,(TCISCC)
	 JRST	TCIE01
TCIE02:	AOJ	TCITCC,
	CAMLE	TCITCC,2(TCIACB)
	 JRST	TCIE03
	ILDB	TCIMAC,TCITLP
	JUMPE	TCIMAC,TCIE03
	TBOUT	<TCIMAC>
	JRST	TCIE02
TCIE03:	MOVE	TCITLP,TCIPLP(TCISCC)
	MOVE	FLAG,(TCITLP)
	ADDI	FLAG,4(TCIACB)
	MOVE	FLAG,(FLAG)
	ENDR	SKIP,2
; TERMINAL STRING INPUT
;   IN: IO -- POINTER TO BUFFER,,SIZE OF BUFFER
;	UTIL -- ECHO FLAG (0 IF ECHO),,POINTER TO ^R TEXT
;   OUT: IO -- LAST CHARACTER INPUT (-1 IF DELETE LINE)
;        UTIL -- COUNT OF CHARACTERS
;
$TSIN$:	BEGINR	<BP,R10,R11,R12>
	MOVE	R10,IO
	MOVE	R11,UTIL
	HLRZ	BP,IO
	HRLI	BP,440700
	SETZ	UTIL,
TSICHR:	TBIN	<IO>
	CAIN	IO,"R"-100
	 JRST	TSIREP
	CAIE	IO,177
	 CAIN	IO,"A"-100
	  JRST	TSIDEL
	CAIE	IO,"U"-100
	 CAIN	IO,"X"-100
	  JRST	TSIENR
	CAIN	IO,15
	 JRST	TSICHR
	CAIE	IO,12
	 CAIN	IO,33
	  JRST	TSIEND
	CAIN	IO,37
	 JRST	TSIEND
	CAIL	IO," "
	 CAIL	UTIL,(R10)
	  JRST	TSIBAD
	IDPB	IO,BP
	ADDI	UTIL,1
	JUMPL	R11,TSICHR
	TBOUT	<IO>
	JRST	TSICHR
TSIBAD:	MOVEI	IO,"G"-100
	TBOUT	<IO>
	JRST	TSICHR
TSIREP:	TSOUT	<CRLF>
	TSOUT	<(R11)>
	JUMPL	R11,TSICHR
	HRRZI	IO,(BP)
	HLR	R12,R10
	CAIGE	IO,(R12)
	 JRST	TSICHR
	HRLI	R12,440700
TSIR01:	CAMN	R12,BP
	 JRST	TSICHR
	ILDB	IO,R12
	TBOUT	<IO>
	JRST	TSIR01
TSIDEL:	JUMPE	UTIL,TSIENR
	MOVEI	IO,"\"
	TBOUT	<IO>
	LDB	IO,BP
	ADD BP,[70000,,0]
	TLNE BP,400000
	 SUB BP,[430000,,1]
	SUBI	UTIL,1
	JUMPL	R11,TSICHR
	TBOUT	<IO>
	JRST	TSICHR
TSIENR:	TSOUT	<[ASCIZ/XXX/],CRLF>
	SETO	IO,
	SETZ	UTIL,
	RETURN
TSIEND:	SETZ	R12,
	IDPB	R12,BP
	ENDR	SKIP,1
; TERMINAL NUMBER INPUT
;   IN: IO -- POINTER TO ^R TEXT,,RADIX
;   OUT: IO -- NUMBER
;
$TNIN$:	BEGINR	<BP,UTIL,FLAG>
	MOVE	UTIL,IO
	MOVE	BP,[440700,,UBUF1]
	SETZ	FLAG,
TNICHR:	TBIN	<IO>
	CAIN	IO,"R"-100
	 JRST	TNIREP
	CAIE	IO,177
	 CAIN	IO,"A"-100
	  JRST	TNIDEL
	CAIE	IO,"U"-100
	 CAIN	IO,"X"-100
	  JRST	TNIENR
	CAIN	IO,15
	 JRST	TNICHR
	CAIE	IO,12
	 CAIN	IO,33
	  JRST	TNIEND
	CAIE	IO,37
	 CAIN	IO," "
	  JRST	TNIEND
	CAIL	IO,"0"
	 CAIL	IO,"0"(UTIL)
	  JRST	TNIBAD
	CAILE	FLAG,12		; MAXIMUM # OF DIGITS WITHOUT OVERFLOW
	 JRST	TNIBAD
	IDPB	IO,BP
	TBOUT	<IO>
	AOJA	FLAG,TNICHR
TNIBAD:	MOVEI	IO,"G"-100
	TBOUT	<IO>
	JRST	TNICHR
TNIREP:	TSOUT	<CRLF>
	HLRZ	IO,UTIL
	TSOUT	<(IO)>
	HRRZI	IO,(BP)
	CAIGE	IO,UBUF1
	 JRST	TNICHR
	MOVE	IO,[440700,,UBUF1]
TNIR01:	CAMN	IO,BP
	 JRST	TNICHR
	ILDB	X1,IO
	TBOUT	<X1>
	JRST	TNIR01
TNIDEL:	JUMPE	FLAG,TNIENR
	MOVEI	IO,"\"
	TBOUT	<IO>
	LDB	IO,BP
	ADD BP,[70000,,0]
	TLNE BP,400000
	 SUB BP,[430000,,1]
	TBOUT	<IO>
	SOJA	FLAG,TNICHR
TNIENR:	TSOUT	<[ASCIZ/XXX/],CRLF>
	SETZ	IO,
	RETURN
TNIEND:	SETZ	IO,
	IDPB	IO,BP
	MOVE	BP,[440700,,UBUF1]
	MOVEI	FLAG,(UTIL)
TNICAL:	ILDB	UTIL,BP
	JUMPE	UTIL,RETN(1)
	IMULI	IO,(FLAG)
	SUBI	UTIL,"0"
	ADDI	IO,(UTIL)
	JRST	TNICAL
	ENDR
; DCNIN -- DATACOMPUTER NUMBER INPUT
;   OUT: IO -- 36-BIT MAGNITUDE INTEGER
;
DCNIN:	BEGINR	<<IO+1>,UTIL>
	SETZ	IO,
DCNIN1:	DCBIN	<UTIL>
	CAIL	UTIL,"0"
	 CAILE	UTIL,"9"
	  RETURN
	JUMPL	IO,DCNIN2
	MULI	IO,^D10
	CAILE	IO,1
	 JRST	DCNIN2
	CAIN	IO,1
	 TLO	<IO+1>,400000
	MOVE	IO,<IO+1>
	ADDI	IO,-"0"(UTIL)
	JRST	DCNIN1
DCNIN2:	SETO	IO,
	JRST	DCNIN1
	ENDR
; $NOUT$ -- INTEGER OUTPUT
;   IN: X1 -- INTEGER
;       X2 -- T-DC FLAG (0=T,-1=DC),,RADIX
;
$NOUT$:	BEGINR	<FLAG>
	MOVE	FLAG,X2
	MOVE	X3,[440700,,UBUF1]
	MOVEI	X4,1
	JUMPGE	X1,NOUT1
	LSHC	X1,-^D35
	LSH	X2,-1
	DIVI	X1,(FLAG)
	CAIA
NOUT1:	 IDIVI	X1,(FLAG)
	ADDI	X2,"0"
	IDPB	X2,X3
	SKIPE	X1
	 AOJA	X4,NOUT1
	SKIPA	X1,[440700,,UBUF2]
NOUT2:	ADD	X3,[070000,,0]
	TLNE	X3,400000
	 SUB	X3,[430000,,1]
	LDB	X2,X3
	IDPB	X2,X1
	SOJG	X4,NOUT2
	IDPB	X4,X1
	SKIPL	FLAG
	 JRST	NOUT3
	DCSOUT	<UBUF2>
	RETURN
NOUT3:	TSOUT	<UBUF2>
	ENDR
	SUBTTL System Dependent Routines for ITS
PRINTX (system-dependent routines)

; SYSTEM INITIALIZATION
;
S$INIT:	BEGINR
	.OPEN TTI,[.UAI,,'TTY']		; TTY input
	 THUD
	.OPEN TTO,[.UAO,,'TTY']		; TTY output
	 THUD
	TSOUT <[ASCIZ/Welcome to the wonderful world of DFTP./],CRLF>
	.SUSET [.RSNAME,,LCLSNM]
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVEI
		[('DSK')]
		['.FILE.']
		['(DIR) ']
		SETZ LCLSNM]
	 JRST [	TSOUT <[ASCIZ/Non-existant local directory./]>
		.LOGOUT 1,]
	.CLOSE
	.CALL [	SETZ
		SIXBIT/TTYSET/
		MOVEI TTI
		MOVE [030303,,030303]
		SETZ [030303,,030303]]
	 JRST [	TSOUT <[ASCIZ/Warning -- Device TTY is not a console!/],CRLF>
		JRST .+1]
	.CALL [	SETZ			; host number
		SIXBIT/NETHST/
		MOVEI -1
		MOVEM
		SETZM LHOST]
	 THUD
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI .UII!40050	; OPEN on gensymmed socket, 32 bits
		MOVEI ICP
		[('NET')]		; network device
		[-1]			; initial local socket is gensymmed
		MOVEI DCSOKT		; initial foreign socket(DATACOMPUTER)
		SETZI DCHOST]		; foreign host(CCA)
	 JRST ICPCLS
	.CALL [	SETZ
		SIXBIT/NETBLK/
		MOVEI ICP
		MOVEI %NSRFS
		SETZM X1]		; wait for connection
	 THUD
	MOVE X1,[ICP,,RCHBLK]
	.RCHST X1,			; get status of network channel
	HRRE X1,RCHBLK+4		; get status of network
	JUMPL X1,NETDED			; network dead if .LE. 0
	CAIN X1,%NSCLI			; CLS w/ input?
	 JRST ICPWIN
	CAIE X1,%NSINP			; input available?
	 CAIN X1,%NSOPN			; connection open?
	  JRST ICPWIN
	JUMPN X1,[THUD]			; any other condition is lossage
ICPCLS:	TSOUT <[ASCIZ/Cannot establish network connection/]>
	.LOGOUT 1,
NETDED:	TSOUT <[ASCIZ/ARPAnet is down/]>
	.LOGOUT 1,
ICPWIN:	MOVE X1,RCHBLK+1		; get gensymmed local socket
	ADDI X1,2			; receive
	MOVEM X1,LCLRCV
	ADDI X1,1			; transmit
	MOVEM X1,LCLTRN
	.IOT ICP,X1			; get foreign place's socket
	.CLOSE ICP,			; free up ICP socket right away
	MOVEM X1,FORRCV			; receive
	ADDI X1,1			; socket to me!
	MOVEM X1,FORTRN
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI 40!.UAI
		MOVEI DCI		; DATACOMPUTER input
		[('NET')]
		LCLRCV
		FORTRN
		SETZI DCHOST]
	 JRST ICPCLS
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI 40!.UAO
		MOVEI DCO		; DATACOMPUTER output
		[('NET')]
		LCLTRN
		FORRCV
		SETZI DCHOST]
	 JRST ICPCLS
	.CALL [	SETZ
		SIXBIT/NETBLK/
		MOVEI DCI
		MOVEI %NSRFS
		SETZM X1]		; wait for connection
	 THUD
	JUMPE X1,ICPCLS
	.CALL [	SETZ
		SIXBIT/NETBLK/
		MOVEI DCO
		MOVEI %NSRFS
		SETZM X1]		; wait for connection
	 THUD
	JUMPE X1,ICPCLS
	MOVEI X1,2			; offset for data sockets
	ADDM X1,LCLRCV
	ADDM X1,LCLTRN
	ADDM X1,FORRCV
	ADDM X1,FORTRN
	ENDR
; NETWORK QUIT -- BREAK DATACOMPUTER CONNECTIONS
;
QUIT:	.IOT DCO,["Z"-100]		; SEND QUIT
QUIT1:	DCBIN <IO>
	JRST QUIT1
QUIT2:	.CLOSE DCI,
	.CLOSE DCO,
	.LOGOUT 1,

; NETOI -- NETWORK OPEN INPUT (DATA)
;
NETOI:	BEGINR
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI .BII
		MOVEI DDI		; DATACOMPUTER data input
		[('NET')]
		LCLRCV
		FORTRN
		SETZI DCHOST]
	 THUD
	.CALL [	SETZ
		SIXBIT/NETBLK/
		MOVEI DDI
		MOVEI %NSRFS
		SETZM X1]		; wait for connection
	 THUD
	JUMPE X1,ICPCLS
	RETURN SKIP,1
	ENDR

; NETOO -- NETWORK OPEN OUTPUT (DATA)
;
NETOO:	BEGINR
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI .BIO
		MOVEI DDO		; DATACOMPUTER data output
		[('NET')]
		LCLTRN
		FORRCV
		SETZI DCHOST]
	 THUD
	.CALL [	SETZ
		SIXBIT/NETBLK/
		MOVEI DDO
		MOVEI %NSRFS
		SETZM X1]		; wait for connection
	 THUD
	JUMPE X1,ICPCLS
	RETURN SKIP,1
	ENDR

; NETC -- NETWORK CLOSE (DATA)
;
NETC:	BEGINR
	.CLOSE DDI,
	.CLOSE DDO,
	ENDR

; NETDSI -- NETWORK: NUMBER OF DATA SOCKET FOR INPUT
;
NETDSI:	BEGINR
	MOVE UTIL,LCLRCV
	ENDR

; NETDSO -- NETWORK: NUMBER OF DATA SOCKET FOR OUTPUT
;
NETDSO:	BEGINR
	MOVE UTIL,LCLTRN
	ENDR
; LOCOI -- LOCAL OPEN INPUT (FILE)
;
LOCOI:	BEGINR
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI .BII
		MOVEI LCI
		[('DSK')]
		LCLFN1
		LCLFN2
		SETZ LCLSNM]
	 JRST LOCOI1
	RETURN SKIP,1
LOCOI1:	TSOUT <[ASCIZ/ (Local file not found)/],CRLF>
	ENDR

;LOCOO -- LOCAL OPEN OUTPUT (FILE)
;
LOCOO:	BEGINR
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI .BIO
		MOVEI LCO
		[('DSK')]
		LCLFN1
		LCLFN2
		SETZ LCLSNM]
	 THUD
	.CALL [	SETZ
		SIXBIT/SFDATE/
		MOVEI LCO
		SETZ LCLDAT]
	 THUD
	RETURN SKIP,1
	ENDR

; LOCC -- LOCAL CLOSE (FILE)
;
LOCC:	BEGINR
	.CLOSE LCI,
	.CLOSE LCO,
	ENDR

; LOCS -- LOCAL FILE (SIZE)
;
LOCS:	BEGINR
	.CALL [	SETZ
		SIXBIT/FILLEN/
		MOVEI LCI
		SETZM IO]
	 SETZ IO,			; it should not crap out
	ENDR
; LUTTSN -- LOCAL UTILITY: TIME STRING TO NUMBER
;   IN: IO -- ADDRESS OF TIME STRING
;  OUT:	UTIL -- ITS DISK FORMAT DATE/TIME
;
LUTTSN:	BEGINR <BP>
	SETZ UTIL,
	ILDB X1,IO
	CAIL X1,"0"
	 CAILE X1,"9"
	  RETURN
	SUBI X1,"0"
	IMULI X1,^D10
	ILDB X2,IO
	CAIL X2,"0"
	 CAILE X2,"9"
	  RETURN
	ADDI X1,-"0"(X2)
	ILDB X2,IO
	CAIE X2,"-"
	 RETURN
	MOVE X2,[440700,,X3]
	SETZ X3,
REPEAT 3,<
	ILDB X4,IO
	IDPB X4,X2
>
	MOVEI X2,^D12
	IOR X3,[1004,,0]	; CANONICALIZE CASES
	CAME X3,LUTTM-1(X2)
	 SOJG X2,.-1
	JUMPL X2,RETN(0)
	ILDB X3,IO
	CAIE X3,"-"
	 RETURN
	ILDB X3,IO
	CAIL X3,"0"
	 CAILE X3,"9"
	  RETURN
	SUBI X3,"0"
	IMULI X3,^D10
	ILDB X4,IO
	CAIL X4,"0"
	 CAILE X4,"9"
	  RETURN
	ADDI X3,-"0"(X4)
	DPB X3,[330700,,UTIL]
	DPB X2,[270400,,UTIL]
	DPB X1,[220500,,UTIL]
	ILDB X1,IO
	CAIE X1," "
	 RETURN
	ILDB X1,IO
	SUBI X1,"0"
	IMULI X1,^D10
	ILDB X2,IO
	ADDI X1,-"0"(X2)
	IMULI X1,6
	ILDB X2,IO
	CAIE X2,":"
	 RETURN
	ILDB X2,IO
	ADDI X1,-"0"(X2)
	IMULI X1,^D10
	ILDB X2,IO
	ADDI X1,-"0"(X2)
	IMULI X1,6
	ILDB X2,IO
	CAIE X2,":"
	 JRST [	IMULI X1,^D20
		JRST LUTSN1]
	ILDB X2,IO
	ADDI X1,-"0"(X2)
	IMULI X1,^D10
	ILDB X2,IO
	ADDI X1,-"0"(X2)
	LSH X1,1
LUTSN1:	ADDI UTIL,(X1)
	ENDR
; LUTTNS -- LOCAL UTILITY: TIME NUMBER TO STRING
;   IN:	UTIL -- ITS DISK FORMAT DATE/TIME
;	BP -- BYTE POINTER TO DESTINATION STRING
;  OUT:	BP -- UPDATED BYTE POINTER
;
LUTTNS:	BEGINR
	LDB X3,[220500,,UTIL]	; DAY
	IDIVI X3,^D10
	ADDI X3,"0"
	ADDI X4,"0"
	IDPB X3,BP
	IDPB X4,BP
	MOVEI X3,"-"
	IDPB X3,BP
	LDB X3,[270400,,UTIL]	; MONTH
	HRRI X3,LUTTM-1(X3)
	HRLI X3,440700
	SCOPY (X3,BP)
	MOVEI X3,"-"
	IDPB X3,BP
	LDB X3,[330700,,UTIL]	; YEAR
	IDIVI X3,^D10
	ADDI X3,"0"
	ADDI X4,"0"
	IDPB X3,BP
	IDPB X4,BP
	MOVEI X3," "
	IDPB X3,BP
	HRRZ X2,UTIL		; TIME IN SECONDS
	LSH X2,-1
	IDIVI X2,^D3600
	MOVEI X4,(X3)
	IDIVI X2,^D10
	ADDI X2,"0"
	ADDI X3,"0"
	IDPB X2,BP
	IDPB X3,BP
	MOVEI X2,":"
	IDPB X2,BP
	MOVEI X2,(X4)
	IDIVI X2,^D60
	MOVEI X4,(X3)
	IDIVI X2,^D10
	ADDI X2,"0"
	ADDI X3,"0"
	IDPB X2,BP
	IDPB X3,BP
	MOVEI X2,":"
	IDPB X2,BP
	MOVEI X2,(X4)
	IDIVI X2,^D10
	ADDI X2,"0"
	ADDI X3,"0"
	IDPB X2,BP
	IDPB X3,BP
	SETZ X2,
	IDPB X2,BP
	ENDR				; return

; MONTH TABLE FOR LOCAL DATE CONVERSION
;
LUTTM:	ASCII/Jan/
	ASCII/Feb/
	ASCII/Mar/
	ASCII/Apr/
	ASCII/May/
	ASCII/Jun/
	ASCII/Jul/
	ASCII/Aug/
	ASCII/Sep/
	ASCII/Oct/
	ASCII/Nov/
	ASCII/Dec/
; LUTFN -- LOCAL UTILITY: ASCII TO SIXBIT FILE NAME CONVERSION
; IN: IO -- POINTER TO ASCIZ STRING
;
LUTFN:	BEGINR <IO>
	SETZM LCLFN1			; < prevent assembly error
	MOVSI X1,'>  '
	MOVEM X1,LCLFN2
	HRLI IO,440700
LUTFN1:	CALLR LUTWRD			; get a SIXBIT word
	MOVEM X1,LCLFN1
	JUMPE X2,RETN(0)
	CAIE X2,"."
	 JRST LUTFN1
	CALLR LUTWRD
	CAIE X1,
	 MOVEM X1,LCLFN2		; use FN2 if specified
	ENDR

; LUTWRD -- LOCAL UTILITY: GET A SIXBIT WORD IN X1, DELIMITER IN X2
;
LUTWRD:	BEGINR <BP>
	SETZ X1,			; initialize word, word pointer
	MOVE BP,[440600,,X1]
LUTWR1:	ILDB X2,IO			; get a character from buffer
	CAIN X2,"."
	 JRST RETN(0)
	JUMPE X2,RETN(0)
	SUBI X2," "			; SIXBITify from ASCII
	TRNN X1,77			; and save in word until word filled
	 IDPB X2,BP
	JRST LUTWR1
	ENDR
; NETFFI -- NETWORK FIX FIRST FILE FOR INPUT
;
NETFFI:	BEGINR
	SETZM FFITYP
	SETO X1,
	CAME X1,FSBUF
	 CAMN X1,ESBUF
	  CAIA
	   JRST NETFI1
	.IOT TTO,[" "]
	.IOT TTO,["("]
	SETOM FFITYP
NETFI1:	MOVE X1,[440600,,LCLFN1]
	MOVEI X2,6
	MOVE X3,[440700,,FBUF]
NETFI4:	ILDB X4,X1
	JUMPE X4,NETFI5
	ADDI X4," "
	SKIPE FFITYP
	 .IOT TTO,X4
NETFI5:	SKIPE GBUF1
	 IDPB X4,X3
	SOJG X2,NETFI4
NETFI2:	SKIPE FFITYP
	 .IOT TTO,["."]
	MOVE X1,[440600,,LCLFN2]
	MOVEI X2,6
	MOVE X3,[440700,,EBUF]
NETFI6:	ILDB X4,X1
	JUMPE X4,NETFI7
	ADDI X4," "
	SKIPE FFITYP
	 .IOT TTO,X4
NETFI7:	SKIPE GBUF2
	 IDPB X4,X3
	SOJG X2,NETFI6
NETFI3:	SKIPN FFITYP
	 RETURN
	.IOT TTO,[")"]
	.IOT TTO,[15]
	.IOT TTO,[12]
	ENDR
; PUTFIL -- PUT-STORE FILE INFORMATION
;
PUTFIL:	BEGINR <IO,BP,UTIL>
	SETZM IOBUFR
	MOVE X1,[IOBUFR,,IOBUFR+1]
	BLT X1,IOBUFR+1777
	.RDTIM X1,
	IDIVI X1,^D30
	MOVEM X1,NTIME
	MOVE BP,[440700,,IOBUFR]
	MOVE UTIL,[440700,,FBUF]
	SCOPY (UTIL,BP)
	MOVE BP,UTIL
	MOVE UTIL,[440700,,EBUF]
	SCOPY (UTIL,BP)
	MOVE BP,UTIL
	.CALL [	SETZ
		SIXBIT/RFDATE/
		MOVEI LCI
		SETZM UTIL]
	 MOVSI UTIL,124201
	CALLR LUTTNS
	.CALL [	SETZ
		SIXBIT/RQDATE/
		SETZM UTIL]
	 MOVSI UTIL,124201
	CALLR LUTTNS
	HRLI BP,004400
	MOVE UTIL,VBUF
	IDPB UTIL,BP
	CALLR LOCS
	IDPB IO,BP
	MOVNI UTIL,17
	IDPB UTIL,BP
	SUBI BP,IOBUFR-1
	HRRZM BP,NSIZE
	HRLOI BP,-1(BP)
	EQVI BP,IOBUFR
	MOVEM BP,X1SAVE#
	SETZ UTIL,
	ADD UTIL,(BP)
	AOBJN BP,.-1
	ADDM UTIL,NSUM
	CALLR NETMSG
	 JRST DEATH
	MOVE X1,X1SAVE#
	.IOT DDO,X1
	ENDR
; PUTDAT -- MOVE DATA: LOCAL TO NETWORK (PUT)
;
PUTDAT:	BEGINR <UTIL,IO>
	CALLR LOCS			; get length of file
	AOS NSIZE
	ADDM IO,NSUM
	ADDM IO,NSIZE
	CALLR NETMSG
	 JRST PUTD4
	HRROI X1,IO
	.IOT DDO,X1
	SETZ UTIL,
PUTD1:	MOVE X1,[-2000,,IOBUFR]
	.IOT LCI,X1			; read 1K from local file
	JUMPL X1,PUTD2			; hit EOF here
	CALLR NETMSG
	 JRST PUTD4
	MOVE X1,[-2000,,IOBUFR]
	.IOT DDO,X1
	MOVSI X1,-2000			; compute checksum
	ADD UTIL,IOBUFR(X1)
	AOBJN X1,.-1
	JRST PUTD1
PUTD2:	MOVEM X1,X1SAVE#
	CALLR NETMSG
	 JRST PUTD4
	MOVE X1,X1SAVE#
	MOVNI X1,-IOBUFR(X1)		; get -# of words transferred
	JUMPE X1,PUTD3
	HRLZS X1
	MOVEM X1,X1SAVE#
	CALLR NETMSG
	 JRST PUTD4
	MOVE X1,X1SAVE#
	HRRI X1,IOBUFR
	.IOT DDO,X1
	MOVE X1,X1SAVE#
	ADD UTIL,IOBUFR(X1)
	AOBJN X1,.-1
PUTD3:	ADDM UTIL,NSUM
	ADDM UTIL,NSUM
	CALLR NETMSG
	 JRST PUTD4
	HRROI X1,UTIL
	.IOT DDO,X1
PUTD4:	.RDTIM X1,
	IDIVI X1,^D30
	SUBM X1,NTIME
	ENDR
; EXAFIL -- EXAMINE FILE... READ AND LIST TO TERMINAL
;
EXAFIL:	BEGINR <IO,BP,FLAG,UTIL>
	.RDTIM X1,
	IDIVI X1,^D30
	MOVEM X1,NTIME
	MOVE IO,[-GET$F,,FBUF]
	.IOT DDI,IO
	JUMPL IO,RETN(0)
	MOVEI IO,GET$F
	MOVEM IO,NSIZE
	SETZ UTIL,
	ADD UTIL,<FBUF-1>(IO)
	SOJG IO,.-1
	ADDM UTIL,NSUM
	MOVE IO,[-GET$E,,EBUF]
	.IOT DDI,IO
	MOVEI IO,GET$E
	ADDM IO,NSIZE
	SETZ UTIL,
	ADD UTIL,<EBUF-1>(IO)
	SOJG IO,.-1
	ADDM UTIL,NSUM
	MOVE IO,[-GET$D,,ABUF]
	.IOT DDI,IO
	MOVEI IO,GET$D
	ADDM IO,NSIZE
	SETZ UTIL,
	ADD UTIL,<ABUF-1>(IO)
	SOJG IO,.-1
	ADDM UTIL,NSUM
	HRROI IO,ABUF
	.IOT DDI,IO
	MOVE IO,ABUF			; ITS crock
	AOS NSIZE
	ADDM IO,NSUM
	HRROI IO,ABUF
	.IOT DDI,IO
	MOVE IO,ABUF
	AOS NSIZE
	ADDM IO,NSUM
	HRROI IO,FLAG
	.IOT DDI,IO
	JUMPE FLAG,EXAF2
	ADDM FLAG,NSUM
	AOS NSIZE
	ADDM FLAG,NSIZE
	SKIPL DEXA$S
	 JRST EXAF0
	MOVE X2,[440700,,FBUF]
	ILDB X1,X2
	CAILE X1," "
	 JRST .-2
	SETZ X1,
	DPB X1,X2
	MOVE X2,[440700,,EBUF]
	ILDB X1,X2
	CAILE X1," "
	 JRST .-2
	SETZ X1,
	DPB X1,X2
	TSOUT <[ASCIZ/ [/],FBUF,[ASCIZ/./],EBUF,[ASCIZ/]/],CRLF>
EXAF0:	SETZ UTIL,
EXAF1:	MOVEI IO,(FLAG)
	CAILE IO,2000
	 MOVEI IO,2000
	SUBI FLAG,(IO)
	HRLOI X1,-1(IO)
	EQVI X1,IOBUFR
	MOVEM X1,X1SAVE#
	.IOT DDI,X1
	IMULI IO,5
	MOVE BP,[440700,,IOBUFR]
	CALLR DEXA$
	MOVE X1,X1SAVE#
	ADD UTIL,(X1)
	AOBJN X1,.-1
	JUMPG FLAG,EXAF1
EXAF2:	ADDM UTIL,NSUM
	HRROI IO,ABUF
	.IOT DDI,IO
	MOVE IO,ABUF
	ADDM IO,NSUM
	AOS NSIZE
	HRROI IO,ABUF
	.IOT DDI,IO
	MOVE IO,ABUF
	ADDM IO,NSUM
	AOS NSIZE
	CAMN IO,UTIL
	 JRST EXAF3
	TSOUT <[ASCIZ/ (File Checksum Error)/],CRLF>
EXAF3:	.RDTIM X1,
	IDIVI X1,^D30
	SUBM X1,NTIME
	ENDR SKIP,1
; GETFIL -- GET-RETRIEVE FILE INFORMATION
;
GETFIL:	BEGINR <IO,UTIL>
	.RDTIM X1,
	IDIVI X1,^D30
	MOVEM X1,NTIME
	MOVE IO,[-GET$F,,FBUF]
	.IOT DDI,IO
	JUMPL IO,RETN(0)
	MOVEI IO,GET$F
	MOVEM IO,NSIZE
	SETZ UTIL,
	ADD UTIL,<FBUF-1>(IO)
	SOJG IO,.-1
	ADDM UTIL,NSUM
	MOVE IO,[-GET$E,,EBUF]
	.IOT DDI,IO
	MOVEI IO,GET$E
	ADDM IO,NSIZE
	SETZ UTIL,
	ADD UTIL,<EBUF-1>(IO)
	SOJG IO,.-1
	ADDM UTIL,NSUM
	MOVE IO,[-GET$D,,ABUF]
	.IOT DDI,IO
	MOVEI IO,GET$D
	ADDM IO,NSIZE
	SETZ UTIL,
	ADD UTIL,<ABUF-1>(IO)
	SOJG IO,.-1
	ADDM UTIL,NSUM
	MOVE IO,[440700,,ABUF]
	CALLR LUTTSN
	MOVEM UTIL,LCLDAT
	HRROI IO,ABUF
	.IOT DDI,IO
	AOS NSIZE
	MOVE X1,ABUF
	ADDM X1,NSUM
	HRROI IO,ABUF
	.IOT DDI,IO
	AOS NSIZE
	MOVE X1,ABUF
	ADDM X1,NSUM
	ENDR SKIP,1
; GETDAT -- GET-RETRIEVE FILE DATA
;
GETDAT:	BEGINR <IO,UTIL,FLAG>
	HRROI IO,FLAG
	.IOT DDI,IO
	JUMPE FLAG,GETD3
	ADDM FLAG,NSUM
	AOS NSIZE
	ADDM FLAG,NSIZE
	SETZ UTIL,
GETD1:	CAIGE FLAG,2000
	 JRST GETD2
	SUBI FLAG,2000
	MOVE X1,[-2000,,IOBUFR]
	.IOT DDI,X1			; read 1K from DATACOMPUTER
	MOVE X1,[-2000,,IOBUFR]
	.IOT LCO,X1
	MOVSI X1,-2000			; compute checksum
	ADD UTIL,IOBUFR(X1)
	AOBJN X1,.-1
	JRST GETD1
GETD2:	JUMPE FLAG,GETD3
	HRLOI X1,-1(FLAG)
	EQVI X1,IOBUFR
	MOVEM X1,X1SAVE#
	.IOT DDI,X1
	MOVE X1,X1SAVE#
	.IOT LCO,X1
	MOVE X1,X1SAVE#
	ADD UTIL,(X1)
	AOBJN X1,.-1
GETD3:	ADDM UTIL,NSUM
	HRROI IO,ABUF
	.IOT DDI,IO
	MOVE IO,ABUF
	ADDM IO,NSUM
	AOS NSIZE
	HRROI IO,ABUF
	.IOT DDI,IO
	MOVE IO,ABUF
	ADDM IO,NSUM
	AOS NSIZE
	CAMN IO,UTIL
	 JRST GETD4
	TSOUT <[ASCIZ/ (File Checksum Error)/],CRLF>
GETD4:	.RDTIM X1,
	IDIVI X1,^D30
	SUBM X1,NTIME
	ENDR
; NETMSG -- HANDLE PENDING MESSAGES
;
NETMSG:	BEGINR <IO>
	SKIPE FLAGSM		; Is NETMSG allowed to eat datalanguage?
	 RETURN SKIP,1		; no!!
NETMS1:	.CALL [	SETZ
		SIXBIT/WHYINT/
		MOVEI DCI
		MOVEM IO
		MOVEM IO
		SETZM IO]
	 THUD
	JUMPE IO,RETN(1)
	DCBIN <IO>
	CAIN IO,"?"
	 JRST DEATH
	CAIN IO,"!"
	 JRST NETMS2
	CAIE IO,"+"
	 CAIN IO,"-"
	  JRST NETMS3
	CAIN IO,"."
	 JRST NETMS4
	CALLR RENLIN
	JRST NETMS1
NETMS2:	CALLR RENLIP
	JRST NETMS1
NETMS3:	CALLR RENLIP
	RETURN
NETMS4:	SETOM FLAGSM		; forbid any more gobbling
	CALLR RENLIN
	ENDR SKIP,1
; LOCFFI -- LOCAL FIRST FILE FOR INPUT
;
LOCFFI:	BEGINR <IO>
	SETZM GBUF1
	LDB X1,[350700,,FBUF]
	CAIN X1,"*"
	 SETOM GBUF1
	SETZM GBUF2
	LDB X1,[350700,,EBUF]
	CAIN X1,"*"
	 SETOM GBUF2
	SETO X1,
	CAME X1,FSBUF
	 CAMN X1,ESBUF
	  CAIA
	   JRST	LOCFI5
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI .BII
		MOVEI
		[('DSK')]
		['.FILE.']
		['(DIR) ']
		SETZ LCLSNM]
	 JRST LOCFNF
	MOVE X1,[-2000,,DIRBLK]
	.IOT X1
	.CLOSE
LOCFI1:	MOVE IO,DIRBLK+1		; POINTER TO NAME AREA
	ADDI IO,DIRBLK
	CAIN IO,DIRBLK+2000		; END OF DIRECTORY?
	 JRST LOCFNF
	MOVEI X1,5
	ADDM X1,DIRBLK+1
	SETO X1,
	CAME X1,FSBUF
	 JRST LOCFI2
	CAME X1,ESBUF
	 JRST LOCFI3
	JRST LOCFI4
LOCFI2:	MOVE X1,[440700,,FSBUF]
	MOVE X2,[440600,,X4]
	MOVEI X3,6
	SETZ X4,
	ILDB X1
	CAIN "."
	 JRST .+5
	JUMPE .+4
	SUBI " "
	IDPB X2
	SOJG X3,.-6
	CAMN X4,(IO)
	 JRST LOCFI4
	JRST LOCFI1
LOCFNF:	TSOUT <[ASCIZ/ (No Such File)/],CRLF>
	RETURN

LOCFI3:	MOVE X1,[440700,,ESBUF]
	MOVE X2,[440600,,X4]
	SETZ X4,
	MOVEI X3,6
LOCFI6:	ILDB X1
	CAIN "."
	 JRST LOCFI7
	JUMPE LOCFI7
	SUBI " "
	IDPB X2
	SOJG X3,LOCFI6
LOCFI7:	CAME X4,1(IO)
	 JRST LOCFI1
LOCFI4:	MOVE X1,(IO)
	MOVEM X1,LCLFN1
	MOVE X1,1(IO)
	MOVEM X1,LCLFN2
LOCFI5:	CALLR LOCOI
	 RETURN
	.CLOSE
	ENDR SKIP,1
; LOCNFI -- LOCAL NEXT FILE FOR INPUT
;
LOCNFI:	BEGINR <IO>
	CALLR LOCC
	SETO X1,
	CAME X1,FSBUF
	 CAMN X1,ESBUF
	  JRST LOCNI0
	RETURN SKIP,1
LOCNI0:	MOVE IO,DIRBLK+1
	ADDI IO,DIRBLK
	CAIN IO,DIRBLK+2000
	 RETURN SKIP,1
	MOVEI X1,5
	ADDM X1,DIRBLK+1
	SETO X1,
	CAME X1,FSBUF
	 JRST LOCNI1
	CAME X1,ESBUF
	 JRST LOCNI2
	JRST LOCNI3
LOCNI1:	MOVE X1,[440700,,FSBUF]
	MOVE X2,[440600,,X4]
	MOVEI X3,6
	SETZ X4,
LOCNI6:	ILDB X1
	CAIN "."
	 JRST LOCNI7
	JUMPE LOCNI7
	SUBI " "
	IDPB X2
	SOJG X3,LOCNI6
LOCNI7:	CAMN X4,(IO)
	 JRST LOCNI3
	JRST LOCNI0
LOCNI2:	MOVE X1,[440700,,ESBUF]
	MOVE X2,[440600,,X4]
	MOVEI X3,6
	SETZ X4,
LOCNI8:	ILDB X1
	CAIN "."
	 JRST LOCNI9
	JUMPE LOCNI9
	SUBI " "
	IDPB X2
	SOJG X3,LOCNI8
LOCNI9:	CAME X4,1(IO)
	 JRST LOCNI0
LOCNI3:	MOVE X1,(IO)
	MOVEM X1,LCLFN1
	MOVE X1,1(IO)
	MOVEM X1,LCLFN2
	.CALL [	SETZ
		SIXBIT/OPEN/
		MOVSI .BII
		MOVEI LCI
		[('DSK')]
		LCLFN1
		LCLFN2
		SETZ LCLSNM]
	 JRST LOCNI0
	SKIPN GBUF1
	 JRST LOCNI4
	MOVE X1,[440600,,LCLFN1]
	MOVEI X2,6
	MOVE X3,[440700,,FBUF]
LCNI10:	ILDB X4,X1
	SKIPE X4
	 ADDI X4,40
	IDPB X4,X3
	SOJG X2,LCNI10
LOCNI4:	SKIPN GBUF2
	 JRST LOCNI5
	MOVE X1,[440600,,LCLFN2]
	MOVEI X2,6
	MOVE X3,[440700,,EBUF]
LCNI11:	ILDB X4,X1
	SKIPE X4
	 ADDI X4,40
	IDPB X4,X3
	SOJG X2,LCNI11
LOCNI5:	.IOT TTO,[" "]
	.IOT TTO,["("]
	TSOUT <FBUF>
	.IOT TTO,["."]
	TSOUT <EBUF>
	.IOT TTO,[")"]
	.IOT TTO,[15]
	.IOT TTO,[12]
	ENDR
; LOCNFO -- LOCAL NEXT FILE FOR OUTPUT
;
LOCNFO:	BEGINR <IO>
	SETZ X1,
	SETO X2,
	CAMN X2,FSBUF
	 TRO X1,400000
	CAMN X2,ESBUF
	 TRO X1,200000
	JUMPE X1,RETN(0)
	MOVE X2,[440700,,ABUF]
	MOVE X3,[440700,,FSBUF]
	TRNE X1,400000
	 HRRI X3,FBUF
LOCNF1:	ILDB X4,X3
	CAIN X4," "
	 SETZ X4,
	IDPB X4,X2
	JUMPN X4,LOCNF1
	SKIPN ESBUF
	 JRST LOCNOO
	MOVEI X4,"."
	DPB X4,X2
	MOVE X3,[440700,,ESBUF]
	TRNE X1,200000
	 HRRI X3,EBUF
LOCNF2:	ILDB X4,X3
	CAIN X4," "
	 SETZ X4,
	IDPB X4,X2
	JUMPN X4,LOCNF2
LOCNOO:	MOVEI IO,ABUF
	CALLR LUTFN
	.IOT TTO,[" "]
	.IOT TTO,["("]
	TSOUT ABUF
	.IOT TTO,[")"]
	.IOT TTO,[15]
	.IOT TTO,[12]
	ENDR
	SUBTTL Data

CRLF:	BYTE	(7)15,12,0,0,0
RPAREN:	BYTE	(7)")",15,12,0,0
SEMI:	BYTE	(7)";",15,12,0,0

	LIT			; LITERALS GO HERE

IOBUFR:	BLOCK 2000
LCLDEV:	BLOCK 1			; local device
LCLFN1:	BLOCK 1
LCLFN2:	BLOCK 1
LCLSNM:	BLOCK 1			; SNAME
RCHBLK:	BLOCK 10		; network status goes here
LCLRCV:	BLOCK 1
LCLTRN:	BLOCK 1
FORRCV:	BLOCK 1
FORTRN:	BLOCK 1
FFITYP:	BLOCK 1
LCLDAT:	BLOCK 1
DIRBLK:	BLOCK 2000

; * VARIABLES

CMDMOD:	0

LHOST:	0

ANCHOR:	ASCIZ	/DFTP/
	BLOCK	<SBSIZE-2>
LOGIN%:	BLOCK	LBSIZE
CONTEX:	BLOCK	LBSIZE
OPENED:	BLOCK	LBSIZE
OPENEM:	0

FLAGDD:	0
FLAGDE:	0
FLAGFE:	0
FLAGNN:	0
FLAGTT:	0
FLAGSM:	0
DEXA$L:	0
DEXA$P:	0
DEXA$S:	0

; * BLOCKS

NBUF:	BLOCK	LBSIZE
FBUF:	BLOCK	SBSIZE
EBUF:	BLOCK	SBSIZE
VBUF:	0
FSBUF:	BLOCK	SBSIZE
ESBUF:	BLOCK	SBSIZE

ABUF:	BLOCK	SBSIZE
UBUF1:	BLOCK	LBSIZE
UBUF2:	BLOCK	SBSIZE
GBUF1:	BLOCK	LBSIZE
GBUF2:	BLOCK	LBSIZE

NTIME:	0
NSIZE:	0
NSUM:	0

TCIPCL:	BLOCK	100		; P(OSSIBLE)C(OMMAND)L(IST) [INIT ALL]
TCIPLP:	0			; TCIPCL PTRS (# POSSIBLITIES,,LIST ADR)
	BLOCK	37		;   (SIZE = # CHARS IN LARGEST CMD)
TCIPNF:	0			; P(OSSIBLE)N(EXT)F(REE)

	STSIZ==100
STBEG:	BLOCK	STSIZ

	VAR

	-1			; CRETINOUS LINK-10 BUG

END DFTP
