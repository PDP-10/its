;-*-MIDAS-*-

TITLE FED FONT EDITOR

;BY PITTS JARVIS--1973
;ADDITIONS BY JOE COHEN -- 1973,1974,1975

;AC'S

A=1		;USED FOR PASSING ARGUMENTS BACK AND FORTH
B=2		;MOSTLY SCRATCH
C=3
D=4
E=5
T=6
TT=7
U=10
V=11
X=12		;ACTUAL BEAM LOCATION
Y=13
PX=14		;PSEUDO BEAM LOCATION
PY=15
CODE=16
P=17

;IO CHANNELS

TTYICH==0	;TTY INPUT CHANNEL
TTYOCH==1	;TTY OUTPUT CHANNEL
FONTCH==2	;FONT I/O CHANNEL
USRCH==3	;PDP6 CHANNEL
ERRICH==4	;CHANNEL FOR ERROR DEVICE

.MLLIT==1
.XCREF A,B,C,D,E,T,TT,U,V,CODE,P

DPYBFL==24000	;DPY BUFFER LENGTH
PDL==40		;PUSH DOWN LENGTH
PATL==100	;PATCH AREA SIZE
MSETSZ==400	;MAXIMUM SIZE OF CHAR SET

;340 MODES

340PAR==0		;PARAMETER MODE
340PNT==1		;POINT MODE
340CHR==3		;CHARACTER MODE
340VEC==4		;VECTOR MODE
340VC==5		;VECTOR CONTINUE MODE
340INC==6		;INCREMENT MODE

;SOME DISPLAY MACROS

DEFINE DSTOP
	.DSTOP
	SETZM DPYBLK
	TERMIN

;TV GEOMETRY

BITPL==576.		;BITS PER LINE
NLINS==454.		;# LINES
%TY11T==10000		;KNIGHT TV BIT IN TTYTYP

;TABLE LENGTH CHECKER

DEFINE CHECK TAG,LENGTH
IF2,[IFN .-TAG-LENGTH,[ PRINTC /TAG LOSES
/]]TERMIN

DEFINE CIRCI REG,TIMES
IFSN REG,T,.ERR CIRCI ACCUMULATOR MUST BE T.
	PUSHJ P,XCIRC
	    TIMES
TERMIN

;HERE WHEN A CIRC MUST BE DONE.  ASSUME ACCUMULATOR IS T.
;COUNT IS IN WORD FOLLOWING THE PUSHJ TO XCIRC.
XCIRC:	PUSH P,A
	MOVE A,@-1(P)
	SKIPN CIRCP
	 JRST XCIRC1
	CIRC T,(A)		;IF CIRC WORKS ON THIS MACHINE, GET COUNT AND DO IT.
	JRST XCIRCX

;SIMULATE CIRC, ONE BIT AT A TIME.
XCIRC1:	JUMPE A,XCIRCX
	JUMPL A,XCIRC2	
XCIRC3:	ROT TT,-1
	ROTC T,1
	ROT TT,-1
	SOJG A,XCIRC3
	JRST XCIRCX

XCIRC2:	ROT TT,1
	ROTC T,-1
	ROT TT,1
	AOJL A,XCIRC2
XCIRCX:	POP P,A
	AOS (P)
	POPJ P,

GO:	MOVE P,PDP
	SETZM CIRCP		;SET CIRCP NONZERO IF CIRC WORKS.
	MOVE TT,[012345,,012345]
	CIRC T,36.
	CAMN T,[516240,,516240]
	 SETOM CIRCP
	.OPEN TTYOCH,[SIXBIT /  1TTY/]	;DISPLAY OUTPUT
	.VALUE
	.OPEN TTYICH,[SIXBIT /   TTY/]
	.VALUE
	.CALL [SETZ
		SIXBIT /CNSGET/
		1000,,TTYOCH
		2000,,TCMXV
		2000,,TCMXH
		2000,,TCTYP
		2000,,TTYCOM
		2000,,TTYOPT
		402000,,TTYTYP]
	 .VALUE
	MOVEI A,44		;SET BITS PER BYTE ON IMAGE INPUT
	MOVEM A,BITPB
	MOVE A,TTYTYP
	TRNE A,%TY11T
	SETOM	TVDPY		;KNIGHT DISPLAY
	SETZM 340DPY		;NEAR A 340?
	.STATUS TTYICH,A
	TRNE A,200000
	SETOM 340DPY
	SKIPN OFFSNM
	.SUSET [.RSNAM,,OFFSNM]	;DON'T DEFAULT TO KST
	SETOM TTYFLG		;IO GOES TO TTY
	MOVE B,[440600,,VER1]
	PUSHJ P,SIXO
	MOVEI A,".
	PUSHJ P,TYO
	MOVE B,[440600,,VER2]
	PUSHJ P,SIXO
	PUSHJ P,CRLF
REGO:	MOVEI A,10.
	MOVEM A,RADEX
	PUSHJ P,SETIN

	MOVEI A,ICORE
	SKIPE PDP6
	JRST GO1
	.CORE (A)		;REDUCE TO INITIAL CORE ALLOCATION
	.VALUE
GO1:	MOVEM A,CORSIZ
	SETZM FREE
	LSH A,12
	MOVEM A,FSP
	MOVE A,[400,,400000+ICORE_11]
	MOVEM A,CBLK

GETKST:	.SUSET [.SSNAM,,IFFSNM]
	MOVEI A,IFDEV
	.OPEN FONTCH,IFDEV		;READ IN FONT
	JRST [	PUSHJ P,FNF		;CAN'T OPEN INPUT, TRY AGAIN
		JRST REGO]
	SKIPL	TVDPY
	JRST	.+3
	MOVEI	A,[ASCIZ /CV/]	;IF USING TV
	PUSHJ	P,OUTSTR		;CLEAR SCREEN, MOVE 30 LINES FROM TOP
	MOVEI A,[ASCIZ /READING:  /]
	PUSHJ P,OUTSTR
	MOVEI A,FONTCH
	PUSHJ P,PFNAM
	PUSHJ P,CRLF
	SETZM CHARD		;ZERO CHARACTER DISPATCH TABLE
	MOVE A,[CHARD,,CHARD+1]
	BLT A,CHARD+<MSETSZ-1>
	SETZM IOCNT		;FORCE READ ON CALL TO WORDIN
	MOVE A,ITYPE		;TYPE OF FONT WE ARE READING
	SETZM ERRFLG
	PUSHJ P,@READF(A)
	MOVEM A,CHREAD'		;# OF CHARS READ
	SKIPE ERRFLG		;IF ERRORS, ON TV LET USER SEE THEM BEFORE DISPLAYING.
	 SKIPN TVDPY
	  JRST GETKS1
	MOVEI A,[ASCIZ/TYPE A CHARACTER TO IGNORE THE ERRORS./]
	PUSHJ P,TYICR
GETKS1:
DEFINE GROUP FIRST,LAST
	MOVEI A,FIRST
	IDPB A,B
	CAIGE A,LAST
	AOJA A,.-2
	TERMIN

	MOVE B,[440700,,LINE4]	;CONTROL CHARACTERS
	GROUP 1,37

	MOVE B,[440700,,LINE3]
	GROUP 72,100
	GROUP 133,140
	GROUP 173,177

	MOVE B,[440700,,LINE2]	;#'S AND SPECIALS
	GROUP 40,71

	MOVE B,[440700,,LINE1]	;LOWER CASE
	GROUP 141,172

	MOVE B,[440700,,LINE0]	;UPPER CASE
	GROUP 101,132

	SKIPE TVDPY
	JRST TVGO		;DON'T TRY 6 IF TV DPY
	SKIPN 340DPY
	JRST DONE
	SKIPN PDP6		;JUST 6GO IF ALREADY OPEN
	JRST OPEN6
	MOVEI A,6GO
	SKIPG 6TASK
	.HANG
	MOVEM A,6DISP
	SETOM 6TASK
	JRST DPYGO
OPEN6:	SKIPE PDP6
	JRST DPYGO
	SETOB A,PDP6
	.SUSET [.RUNAM,,UNAME]
	.OPEN USRCH,USRO
	SETZB A,PDP6
	JUMPE A,DPYGO
	.RESET USRCH,			;CLEAR PDP-6'S CORE
	.ACCES USRCH,[2000]		;LOAD THE 6'S MEMORY
	MOVE A,[2000-6LAST-1,,2000]
	.IOT USRCH,A
	MOVEI A,ICORE-1
	MOVE B,[2400+USRCH,,401001]	;.CBLK WORD
	.CBLK B,
	.VALUE				;OH YEAH
	ADDI B,1001
	SOJG A,.-3
	.ACCES USRCH,[41]
	MOVE A,[-1,,[JRST 6GO]]
	.IOT USRCH,A

DPYGO:	SKIPE TVDPY
	JRST TVGO
340GO:	PUSHJ P,DRESET		;RESET DISPLAY

DEFINE SHOW N
SHOW!N:	MOVEI X,0
	MOVN Y,HEIGHT
	IMULI Y,N
	ADDI Y,1777
	PUSHJ P,BEAMXY
	MOVE B,[440700,,LINE!N]
	MOVEM B,CHARBP
	PUSHJ P,LINE
	TERMIN

IRPC N,,[01234]
	SHOW N
	TERMIN

DPYDPY:	MOVE A,DBYTE
	ADDI A,1
	ASH A,-1		;WORDS IN DISPLAY LIST
	MOVNS A
	MOVSS A
	HRRI A,DPYBUF-1		;BLKO POINTER
	MOVEM A,DPYBLK
	SKIPE PDP6
	JRST DONE
	.DSTART DPYBLK
	.VALUE [ASCIZ /: CAN'T .DSTART 
/]
DONE:
DEFINE CRINFO,X
	PUSHJ	P,CRLF
	MOVEI	A,[ASCIZ /X/]
	PUSHJ	P,OUTSTR
TERMIN
PINFO:	CRINFO	[FILE:  ]
	PUSHJ	P,RPFNAM	;PRINT FONT WE JUST READ
	CRINFO	[KSTID:  ]
	MOVE	A,KSTID
	PUSHJ	P,DECPNT
	CRINFO	[CHARACTERS READ:  ]
	MOVE	A,CHREAD
	PUSHJ	P,DECPNT
	CRINFO	[HEIGHT:  ]
	MOVE	A,HEIGHT
	PUSHJ	P,DECPNT
	CRINFO	[WIDTH:  ]
	SETZ	D,
	SKIPE	A,CHARD+40
	HRRE	D,(A)		;WIDTH OF SPACE
	MOVEI	B,MSETSZ-1
WCALC:	SKIPN	C,CHARD(B)
	JRST	WCALC1		;CHAR NOT DEFINED
	HRRE	C,(C)		;WIDTH OF THIS CHAR
	CAME	D,C
	JRST	.+3
WCALC1:	SOJGE	B,WCALC
	SKIPA	A,[[ASCIZ /(Fixed)/]]
	MOVEI	A,[ASCIZ /(Variable)/]
	PUSHJ	P,OUTSTR
	MOVE	A,D
	PUSHJ	P,DECPNT
	PUSHJ	P,CRLF

	MOVEI	A,[ASCIZ /Write? (Y or N)/]
	PUSHJ	P,TYICR
	CAIN A,"X
	.BREAK 16,40000		;KILL THYSELF
	CAIN A,"Q		;ADDED TO BE COMPATIBLE WITH OTHER THINGS.
	 .BREAK 16,40000	;KILL THYSELF
	CAIN A,"N
	JRST GO
	CAIE A,"Y
	JRST DONE
	PUSHJ P,SETOUT
	JRST REGO

;Print string pointed to by A, then read one char into A & type CRLF
TYICR:	PUSHJ	P,OUTSTR
	.RESET	TTYICH,
	PUSHJ	P,TYI
	CAILE	A,"a
	SUBI	A,40
	PUSH	P,A
	PUSHJ	P,CRLF
	JRST	POPAJ;INITIALZE THE TV

TVGO:	PUSHJ P,GET11		;SET UP PAGE MAP FOR DISPLAY MEMORY
	PUSHJ P,TVFWTI		;INTIALIZE TV WRITE ROUTINE

DEFINE TVSHOW N
TVSHW!N:	SETZB X,PX
	MOVN Y,HEIGHT
	IMULI Y,N
	ADDI Y,NLINS-1
	MOVE PY,Y
	MOVE B,[440700,,LINE!N]
	MOVEM B,CHARBP
	PUSHJ P,LINE
	TERMIN

IRPC N,,[01234]
	TVSHOW N
	TERMIN

	PUSHJ P,6TVFIN	;START BLINKING
	JRST DONE
;THIS THE FILE NAME READER

.INSRT AI:SYSENG;FNR >

;READ INPUT FILE NAME

GETINM:	SETZM IFFILE
	SETZM IFFNM2
	MOVEI A,[ASCIZ /INPUT: /]
	PUSHJ P,OUTSTR
	PUSHJ P,TTYLIN
	MOVE A,COMPNT
	ILDB A,A
	CAIN A,15
	.BREAK 16,40000		;KILL THYSELF
	MOVE B,[PUSHJ P,COMGET]
	MOVEI C,0
	JSR FNR"GETFIL
	JRST GETIN1		;IGNORE REST OF LINE
	SKIPE D
	HLRM D,IFDEV
	SKIPE E
	MOVEM E,IFFILE
	SKIPN T
	MOVSI T,'KST
	MOVEM T,IFFNM2
	SKIPE TT
	MOVEM TT,IFFSNM
GETIN1:	CAIN A,15
	PUSHJ P,COMGET	;IGNORE CR
	CAIN A,12
	POPJ P,			;MEEKLY GO AWAY
HUH:	PUSH	P,A
	MOVEI	A,[ASCIZ /FORMAT: /]
	PUSHJ	P,OUTSTR
	PUSHJ	P,TTYLIN
	MOVE	B,[PUSHJ P,COMGET]
	SETZ	C,
	JSR	FNR"NAME	;GET ONE FILE NAME
	MOVEI	C,TYPTBL-1
	CAME	FNR"AC,TYPTAB(C)
	SOJGE	C,.-1
	JUMPL	C,HUH		;NO SUCH STYLE, TRY AGAIN
	MOVE	B,C
	MOVEM	B,ITYPE
	POP	P,A
	CAIN	A,12
	POPJ	P,
	PUSHJ	P,COMGET
	JRST	.-3
	POPJ	P,

;SET INPUT

SETIN:	PUSHJ P,GETINM
	MOVEI C,TYPTBL-1
	MOVE B,IFFNM2
	CAMN B,[SIXBIT />/]
	 MOVSI B,'AST
	CAME B,TYPTAB(C)
	SOJGE C,.-1
	MOVEM C,ITYPE
	JUMPGE C,.+2
	PUSHJ	P,HUH	;TYPE NOT DEFINED ASK HIM WHAT IT IS
	POPJ P,

;THE TYPES OF FONTS WE GRONK

TYPTAB:	SIXBIT /KST/	;AI COMPILED
	SIXBIT /FNT/	;SAIL
	SIXBIT /AST/	;ASCII
	SIXBIT /XH/	;XEROX
	SIXBIT /CMU/	;CMU NEW FORMAT
	SIXBIT /CU/	;NEWER CMU FORMAT?
TYPTBL==.-TYPTAB

READF:	KSTRED
	FNTRED
	ASTRED
	XHRED
	CMURED
	CURED
CHECK READF,TYPTBL

WRITEF:	KSTWRT
	CNTWRT		;CAN'T WRITE 'FNT' STYLE FILES
	ASTWRT
	CNTWRT		;CAN'T WRITE XH STYLE
	CNTWRT
	CNTWRT
CHECK WRITEF,TYPTBL

CNTWRT:	.CLOSE	FONTCH,
	MOVEI	A,[ASCIZ /I CAN'T WRITE THAT STYLE.
/]
	PUSHJ	P,OUTSTR
	POPJ	P,
;COMMAND BUFFER FILLING AND GETTING

TTYLIN:	MOVE B,[010700,,COMBUF-1]
	SETZM COMCNT
TTYL1:	PUSHJ P,TYI
	JUMPE A,TTYL1
	CAIN A,177
	JRST RUBOUT
	CAIN A,15
	JRST TTYCR
	CAIN A,14
	JRST TTYL1	;IGNORE FORM FEEDS
	CAIN A,12
	JRST TTYLF
	PUSHJ P,COMPUT
	JRST TTYL1

RUBOUT:	SOSGE COMCNT
	JRST [	PUSHJ P,CRLF
		JRST TTYLIN]
	LDB A,B
	PUSH P,B
	SKIPN TVDPY
	PUSHJ P,TYO
	SKIPE TVDPY
	PUSHJ P,[	MOVEI A,[ASCIZ /X/]
			JRST OUTSTR]
	POP P,B
	PUSHJ P,DECBP	;DECREMENT BYTE POINTER
	JRST TTYL1

DECBP:	ADD B,[070000,,0]
	JUMPGE B,CPOPJ
	SUB B,[430000,,1]
	POPJ P,

TTYLF:	MOVEI A,15
	PUSHJ P,TYO
TTYCR:	PUSHJ P,COMPUT
	MOVEI A,12
	PUSHJ P,COMPUT
	MOVE B,[010700,,COMBUF-1]
	MOVEM B,COMPNT
	POPJ P,

COMPUT:	IDPB A,B
	AOS COMCNT
	POPJ P,

COMGET:	SOSGE COMCNT
	.VALUE
	ILDB A,COMPNT
	POPJ P,
TYI:	.IOT TTYICH,A
	POPJ P,
;TTY OUTPUT ROUTINES

OCTPNT:	PUSH P,RADEX
	PUSH P,[10]
	POP P,RADEX
	PUSHJ P,DECPNT
OCT1:	POP P,RADEX
	POPJ P,

DECPNT:	JUMPGE	A,DECPNP	;PRINT DECIMAL # IN A
	PUSH	P,A	;A IS NEGATIVE
	MOVEI	A,"-	
	PUSHJ	P,TYO	;PRINT MINUS SIGN
	POP	P,A
	MOVNS	A	;MAKE A POSITIVE
DECPNP:	IDIV A,RADEX	;PRINT POSITIVE DECIMAL #
	HRLM B,(P)
	SKIPE A
	PUSHJ P,DECPNT
	HLRZ A,(P)
	ADDI A,"0
TYO:	SKIPN TTYFLG
	JRST PUTCHR
	.IOT TTYOCH,A
	POPJ P,

OUTSTR:	MOVE B,A
	HRLI B,440700
OUTS1:	ILDB A,B
	JUMPE A,CPOPJ
	PUSHJ P,TYO
	JRST OUTS1

TERPRI:	PUSHJ P,OUTSTR
CRLF:	MOVEI A,15
	PUSHJ P,TYO
	SKIPA A,[12]
TYOSPC:	MOVEI A,40
	JRST TYO

IFPNT:	MOVEI A,IFDEV			;PRINTS INPUT FILE NAME
OPNPNT:	MOVSS A
	HRRI A,FCHST
	BLT A,FCHST+FCHSTL-1
	JRST RPFNAM

FNF:	PUSHJ P,OPNPNT			;PRINT OPEN BLOCK AS FILE NAME
	MOVEI A,[ASCIZ /  /]
	PUSHJ P,OUTSTR
	.OPEN ERRICH,ERROPN
	.VALUE				;LOSSAGE
FNF1:	.IOT ERRICH,A
	CAIGE A,40
	JRST [	.CLOSE ERRICH,
		JRST CRLF]		;FOUND CONTROL CHARACTER, END OF MESSAGE
	PUSHJ P,TYO
	JRST FNF1

PFNAM:	HRLI A,FCHST
	MOVSS A
	.RCHST A,
RPFNAM:	MOVE B,[220600,,FCHST]
	PUSHJ P,SIXO
	MOVEI A,":
	PUSHJ P,TYO
	MOVE B,[440600,,FCHST+3]
	PUSHJ P,SIXO
	MOVEI A,";
	PUSHJ P,TYO
	MOVE B,[440600,,FCHST+1]
	PUSHJ P,SIXO
	PUSHJ P,TYOSPC
	MOVE B,[440600,,FCHST+2]
SIXO:	TLNN B,770000
	POPJ P,
	ILDB A,B
	JUMPE A,CPOPJ
	ADDI A,40
	PUSHJ P,TYO
	JRST SIXO

;LOW LEVEL ROUTINES TO SUPPORT WRITE

OCTIN:	PUSH P,RADEX
	MOVEI A,10
	MOVEM A,RADEX
	PUSHJ P,DECIN
	JRST OCT1

DECIN:	SETZM	C		;RETURNS DECIMAL # IN C
	PUSHJ	P,JUSTCH
	CAIN	A,"-
	JRST	DECIM	;NEGATIVE #
DECL:	MOVEI B,-"0(A)
	SKIPL B
	CAILE	B,9
	POPJ	P,		;RETURN WITH FIRST NON DIGIT
	IMUL	C,RADEX
	ADD	C,B
	PUSHJ	P,GETCHR
	JRST	DECL

DECIM:	PUSHJ	P,GETCHR
	PUSHJ	P,DECL	;READ A POSITIVE #
	MOVNS	C	;NEGATE IT
	POPJ	P,

JUSTCH:	PUSHJ	P,GETCHR	;INPUT UNTIL NON SPACE OR CR
	CAIN	A,15
	POPJ	P,
	CAIE	A,11
	CAIN	A,40
	JRST	JUSTCH
	POPJ	P,

DECINL:	PUSHJ P,DECIN
	JUMPL A,CPOPJ
GETL:	PUSHJ	P,GETCHR	;INPUT UNTIL LF OR EOF
	JUMPL A,CPOPJ
	CAIE	A,12
	JRST	GETL
	POPJ	P,

DECNL1:	PUSHJ	P,DECINL	;LIKE DECINL, BUT POP EXTRA LEVEL IF EOF
	JUMPGE	A,.+2
	SUB	P,[1,,1]
	POPJ	P,

SPAGE:	PUSHJ	P,GETCHR	;INPUT UNTIL EOF OR PAGE
	JUMPL A,CPOPJ
	CAIE	A,^L
	JRST	SPAGE
	POPJ	P,
WBUFIO:	MOVE A,[-BUFSIZ,,BUF]
WBFIO1:	.IOT FONTCH,A
WBFIO2:	MOVE A,[440000,,BUF]
	MOVEM A,IOPTR
	MOVE A,BITPB		;BITS PER BYTE
	DPB A,[300600,,IOPTR]
	PUSH P,A
	PUSH P,B
	MOVEI A,44
	IDIV A,-1(P)
	IMULI A,BUFSIZ
	POP P,B
	SUB P,[1,,1]
	SKIPN A
	.VALUE			;BYTE SIZE TOO BIG
BUFIO1:	MOVEM A,IOCNT
	POPJ P,

CBUFIO:	MOVE A,[-BUFSIZ,,BUF]
	.IOT FONTCH,A
CBFIO2:	MOVE A,[440700,,BUF]
	MOVEM A,IOPTR
	MOVEI A,BUFSIZ*5
	JRST BUFIO1

ZAPBUF:	MOVE A,[<<<<3_7\3>_7\3>_7\3>_7\3>_1]	;CLEAR LOW ORDER BIT MAKES PUB HAPPY
	MOVEM A,BUF
	MOVE A,[BUF,,BUF+1]
	BLT A,BUF+BUFSIZ-1
	POPJ P,

WIBUF:	PUSHJ P,ZAPBUF
	PUSHJ P,WBUFIO
WORDIN:	SOSGE IOCNT
	JRST WIBUF
	ILDB A,IOPTR
	POPJ P,

CIBUF:	PUSHJ P,ZAPBUF
	PUSHJ P,CBUFIO
GETCHR:	SOSGE IOCNT
	JRST CIBUF
	ILDB A,IOPTR
	CAIN A,^C
	HRROS A
	POPJ P,

WOBUF:	PUSH P,A
	PUSHJ P,WBUFIO
	PUSHJ P,ZAPBUF
	POP P,A
WRDOUT:	SOSGE IOCNT
	JRST WOBUF
	IDPB A,IOPTR
	POPJ P,

COBUF:	PUSH P,A
	PUSHJ P,CBUFIO
	PUSHJ P,ZAPBUF
	POP P,A
PUTCHR:	SOSGE IOCNT
	JRST COBUF
	IDPB A,IOPTR
	POPJ P,
;GET NEXT WORD OF FREE STORAGE

CONS:	SOSL FREE
	JRST CONS1
	AOS A,CORSIZ		;INCREASE CORE ALLOCATION
	.CORE (A)
	.VALUE
	MOVEI A,2000
	ADDM A,FREE
CONS1:	MOVE A,FSP
	AOS FSP
	SETZM (A)
	POPJ P,

;GET WORD OF FREE STORAGE AND READ NEXT WORD INTO IT, RETURN POINTER

CONSIN:	PUSHJ P,CONS
	PUSH P,A
	PUSHJ P,WORDIN
	MOVEM A,@(P)
	JRST POPAJ
;RESET THE DISPLAY

DRESET:	DSTOP
	SETZM DPYBUF
	MOVE A,[DPYBUF,,DPYBUF+1]
	BLT A,DPYBUF+DPYBFL-1
	SETZM DBYTE
	MOVE A,[442200,,DPYBUF]
	MOVEM A,DBYTEP
	MOVEI A,DPYBFL*2
	MOVEM A,DBYTEF
	SETZM DSIZE
	MOVEI A,7
	MOVEM A,DBRITE
	MOVEI X,0
	MOVEI Y,1777-24
	MOVEI A,340CHR		;FAKE OUT MODESW
	MOVEM A,DMODE
BEAMXY:	MOVEI A,340PNT		;POSITION BEAM AT X-Y, SET PX AND PY
	CAME A,DMODE
	PUSHJ P,MODESW
	MOVE A,Y		;Y FIRST
	PUSHJ P,BEAM1
	TRO A,200000		;ITS Y
	PUSHJ P,DPYPUT
	MOVE A,X		;NOW X
	PUSHJ P,BEAM1
	MOVE PX,X
	MOVE PY,Y
DPYPUT:	SOSGE DBYTEF		;PUT HALF-WORD INTO DISPLAY LIST
	.VALUE
	IDPB A,DBYTEP
	AOS DBYTE
	POPJ P,

;CHECKS FOR BEAM ON SCREEN,  MAKES POINT MODE INSTRUCTION

BEAM1:	SKIPL A
	CAILE A,1777
	.VALUE			;OFF SCREEN
	TRO A,20000		;STAY IN POINT MODE
	POPJ P,

;SPECIAL HACK TO ENTER INCREMENT MODE

VBEAMX:	MOVEI A,340PNT		;FIRST GET INTO POINT MODE
	CAME A,DMODE
	PUSHJ P,MODESW
	MOVE A,X
	PUSHJ P,BEAM1
	TRZ A,20000		;GO INTO INCREMENT MODE
	TRO A,142000		;AND MAKE VISIBLE
	PUSHJ P,DPYPUT
	MOVEI A,340INC
	MOVEM A,DMODE
	SETZM IBYTEF
	POPJ P,
;PLOT INCREMENT IN A

INCREM:	MOVEI B,340INC
	CAMN B,DMODE
	JRST INCR1		;ALREADY IN INCREMENT MODE
	PUSH P,A
	MOVEI A,340INC		;GET INTO INCREMENT MODE
	PUSHJ P,MODESW
INCR0:	MOVE B,DBYTEP		;BYTE POINTER TO WORD GOING IN
	MOVEM B,IBYTEP
	MOVEI A,200000		;INTENSIFY BEAM
	PUSHJ P,DPYPUT
	POP P,A
	MOVEI B,4		;4 INCREMENTS/DISPLAY INSTRUCTION
	MOVEM B,IBYTEF
	MOVEI B,2		;2 BIT BYTE SIZE
	DPB B,[300600,,IBYTEP]
	IBP IBYTEP		;SKIP OVER INTENSIFY AND ESCAPE BITS
	MOVEI B,4		;4 BIT BYTE SIZE
	DPB B,[300600,,IBYTEP]
INCR1:	SOSL IBYTEF
	JRST INCR2		;ROOM FOR THIS INCREMENT
	PUSH P,A		;PUT NEXT DISPLAY WORD IN
	JRST INCR0
INCR2:	IDPB A,IBYTEP
	POPJ P,
;DRAWS VECTOR,  DELTA-X AND DELTA-Y IN PX AND PY

IVECT:	SKIPA B,[0]
VECT:	MOVEI B,200000		;FOR VISIBLE VECTOR
	MOVE A,PX
	PUSHJ P,SGNMAG		;CONVERT TO SIGN MAGNITUDE
	JRST [	JUMPE B,BEAMXY	;DO SET POINT FOR INVISIBLE
		.VALUE]
	IOR B,A
	MOVE A,PY
	PUSHJ P,SGNMAG
	JRST [	TRNN B,200000	;SET POINT FOR INVISIBLE
		JRST BEAMXY
		.VALUE]
	LSH A,10
	IOR A,B			;VECTOR WORD
	PUSH P,A
	MOVEI A,340VEC
	CAME A,DMODE
	PUSHJ P,MODESW		;GET INTO VECTOR MODE
	POP P,A
	JRST DPYPUT		;INTO DISPLAY LIST

;CHECKS FOR LEGAL VECTOR LENGTH AND CONVERTS TO SIGN MAGNITUDE

SGNMAG:	CAML A,[-177]
	CAMLE A,[177]
	POPJ P,		;CAN'T HACK IT
	JUMPGE A,POPJ1
	MOVNS A		;CONVERT TO SIGN MAGNITUDE
	TRO A,200
	JRST POPJ1
;GET INTO PARAMETER MODE AND SWITCH TO MODE IN A

MODESW:	SKIPL B,DMODE
	CAILE B,7
	.VALUE			;ILLEGAL MODE
	PUSHJ P,@MODESD(B)	;GET INTO PARAMETER MODE
	TDNE A,[-1,,777770]
	.VALUE			;ILLEGAL MODE
	MOVEM A,DMODE
	LSH A,15		;MODE IN DISPLAY INSTUCTION
	IORI A,110		;RESET INTENSITY AND SCALE
	SKIPL B,DBRITE
	CAILE B,7
	.VALUE			;ILLEGAL INTENSITY
	IOR A,B
	SKIPL B,DSIZE
	CAILE B,3
	.VALUE			;ILLEGAL SIZE
	LSH B,4
	IOR A,B
	JRST DPYPUT		;INTO DISPLAY LIST

;DISPATCH TABLE FOR ESCAPE TO PARAMETER MODE

MODESD:	CPOPJ		;0 PARAMETER
	ESCPNT		;1 POINT
	[.VALUE]	;2 ILLEGAL
	CPOPJ		;3 CHARACTER
	ESCIV		;4 VECTOR
	CPOPJ		;5 VECTOR CONTINUE
	ESCIV		;6 INCREMENT
	[.VALUE]	;7 ILLEGAL

;ESCAPE FROM POINT MODE

ESCPNT:	PUSH P,A
	LDB A,DBYTEP
	MOVEI B,340PAR
	DPB B,[150300,,A]
	DPB A,DBYTEP
POPAJ:	POP P,A
	POPJ P,

;ESCAPE FROM VECTOR OR INCREMENT MODE

ESCIV:	LDB B,DBYTEP
	TRO B,400000
	DPB B,DBYTEP
	POPJ P,
;DISPLAYS ONE CHARACTER LINE

LINE:	MOVE C,HEIGHT
LIN0:	PUSH P,CHARBP
LIN1:	ILDB CODE,CHARBP
	JUMPE CODE,LIN2		;END OF LINE
	SKIPN E,CHARD(CODE)	;POINTS INTO FONT DESCRIPTION
	JRST	LIN1		;NOT DEFINED
	HLRE	T,(E)		;Left Kern
	ADD	T,CPA
	SKIPE	TVDPY
	SUB	X,T
	SUB	PX,T
	PUSHJ P,CHRROW
	MOVE	E,CHARD(CODE)	;Account for CW-RW & Kern
	HRRZ	D,(E)		;Character Width
	HRRZ	A,1(E)		;Raster width
	SUB	D,A
	HLRE	A,(E)		;Left Kern
	ADD	A,CPA
	ADD	D,A
	SKIPE	TVDPY
	ADD	X,D
	ADD	PX,D
	JRST LIN1

;HERE FOR END OF RASTER LINE

LIN2:	SKIPE	TVDPY
COMMENT $			;Old routine doesn't work for kerning
	SKIPN TVDPY
	JRST LIN3
	MOVEI TT,0
	MOVEI U,44
	PUSHJ P,TVFWT		;FILL OUT REST OF 11AC
	JFCL			;POINT OFF SCREEN
$	PUSHJ P,TVFWTI		;AND THEN RESET
LIN3:	POP P,CHARBP
	MOVEI X,0
	SUBI Y,1
	MOVE PX,X
	MOVE PY,Y
	SKIPN TVDPY
	PUSHJ P,BEAMXY
	SOJG C,LIN0
	POPJ P,			;CHARACTER COMPLETE
;ROUTINES TO DISPLAY RASTER LINE ON 340

;ACCUMULATOR USAGE

;	C  HEIGHT COUNTER
;	D  WIDTH COUNTER
;	E  POINTS TO CURRENT ROW WORD
;	T  SCRATCH AC
;	TT ROW MASK
;	U  BIT COUNTER (# BITS LEFT IN TT)


;GENERATE DISPLAY FOR ONE RASTER LINE OF ONE CHARACTER

CHRROW:	MOVEI E,1(E)
	HRRZ D,(E)		;WIDTH
	MOVE A,HEIGHT		;HEIGHT
	SUB A,C			;ROWS PROCESSED
	HLRZ T,(E)		;WORDS/ROW
	IMUL A,T
	ADD E,A			;POINTS TO LAST WORD PROCESSED

	SKIPE TVDPY
	JRST TVCHR
CHROW1:	PUSHJ P,ROWSH1		;GET FRESH ROW WORD
CHROW2:	JUMPE TT,CHRAZ		;ALL ZEROS LEFT IN ROW WORD
	PUSHJ P,RWSHFT		;SHIFT OVER MASK
	JUMPE T,[AOJA PX,.-1]	;UPDATE PSEUDO X IF NO POINT HERE
	ADDI PX,1

;FOUND A POINT TO PLOT -- ENTER INCREMENT MODE

	SUB PX,X		;FIND DELTA-X TO MOVE BEAM
	SUB PY,Y
	CAIE PY,
	.VALUE			;SHOULD BE NO DELTA-Y
	ADD X,PX		;NEW BEAM LOCATION
	ADD Y,PY
	PUSHJ P,VBEAMX		;MOVE BEAM, DISPLAY POINT, ENTER INCREMENT
	PUSHJ P,RWSHFT
	JUMPN T,CHROW3
	ADDI X,1
	LDB A,DBYTEP		;OOPS, ONLY 1 POINT TO PLOT
	TRZ A,140000		;GET OUT OF INCREMENT MODE
	TRO A,20000		;AND GET INTO POINT MODE
	DPB A,DBYTEP
	MOVEI A,340PNT
	MOVEM A,DMODE
	MOVE PX,X
	MOVE PY,Y
	JRST CHROW2

;INCREMENT MODE LOOP

CHROW3:	MOVEI A,10		;MOVE X RIGHT
	PUSHJ P,INCREM
	ADDI X,1
	PUSHJ P,RWSHFT
	JUMPN T,CHROW3		;JUMP FOR ANOTHER POINT
	MOVE PX,X		;ACTUAL BEAM LOCATION AND PSEUDO THE SAME
	MOVE PY,Y
	AOJA PX,CHROW2

;ROUTINE TO SHIFT IN THE NEXT BIT

RWSHFT:	MOVEI T,0
	LSHC T,1
	SUBI U,1
	SOJLE D,CPOPJ		;EXIT ROUTINE
	JUMPG U,CPOPJ
ROWSH1:	ADDI E,1		;RESET POINTER FOR FRESH WORD
	MOVE TT,(E)
	MOVEI U,44		;36. FRESH BITS
	POPJ P,

;HERE FOR ALL ZERO'S LEFT IN ROW WORD

CHRAZ:	JUMPLE D,CHRAZ1		;LEAVE CHRROW, WIDTH COUNTED OUT
	ADD PX,U		;MOVE PSEUDO BEAM
	SUB D,U			;UPDATE WIDTH
	JUMPG D,CHROW1		;MORE TO GO
	ADD PX,D		;CORRECT BEAM LOCATION
	POPJ P,			;EXIT CHRROW

CHRAZ1:	ADD PX,D
	POPJ P,
;WRITE 1 LINE OF FONT INTO TV MEMORY

TVCHR:	JUMPLE D,CPOPJ
	PUSHJ P,ROWSH1		;GET FRESH WORD
	SUB D,U
	SKIPGE D
	ADD U,D			;# VALID BITS IN TT
	PUSH P,U
	PUSHJ	P,TVFWT		;Write bits into 11
	JFCL			;POINT OFF SCREEN
	POP P,U
	ADD X,U
	MOVE PX,X
	JRST TVCHR

COMMENT $			;Old routine, losses for kerning etc.
;UPDATE 11AC WRITE IF OVERFLOW

TVFWT:	MOVN B,11BITS		;FREE BITS IN 11AC IN SAVE PLACE
	ADDM U,11BITS
	SKIPGE 11BITS
	JRST TVFWT1		;JUST SHIFT AND GET OUT
	MOVE U,11BITS		;OVERFLOW, # BITS LEFT IN TT
	MOVNI A,40
	ADDM A,11BITS
	MOVEI T,0
	EXCH T,11AC
	LSHC T,(B)
	LSH T,4			;32 BIT PLUS 4 BITS OF 0
	MOVEM T,11WRD
	PUSHJ P,TVXY		;CALULATE ADDRESS OF THIS WORD
	JRST TVFWTI		;POINT OFF SCREEN
	MOVEM A,11ADR
	MOVE A,[CSET]
	MOVEM A,TVALUM
	PUSHJ P,6TVWRT
	SKIPL 11BITS
	JRST TVFWT2		;NEED TO WRITE ANOTHER WORD INTO 11 MEMORY
TVFWT1:	MOVE T,11AC
	LSHC T,(U)
	MOVEM T,11AC
	JRST POPJ1

TVFWT2:	PUSH P,X		;SCREW CASE, WRITE TWICE
	ADDI X,40		;FORCE WRITE INTO NEXT TEN WORD
	PUSHJ P,TVXY
	JRST POPXJ1		;POINT OFF SCREEN
	MOVEM A,11ADR
	LSHC T,40
	LSH T,4
	MOVEM T,11WRD
	PUSHJ P,6TVWRT
	MOVNI A,40
	ADDM A,11BITS
	MOVEI T,0
	LSHC T,-40(U)
	MOVEM T,11AC
POPXJ1:	POP P,X
	JRST POPJ1
$

;INITIALIZE 11AC AND BIT COUNT
TVFWTI:	MOVNI B,40		;32 BITS AT A TIME
	MOVEM B,11BITS
	SETZM 11AC
	POPJ P,

;Write 36 bits in TT into X,Y
;(In worst case this can mean writing 3 32. bit double PDP11 words)
TVFWT:	PUSH	P,X
	MOVE	A,X
	IDIVI	A,32.
	MOVN	B,B		;# of bits from left of 32. bit word that 36. bits start
TVFWT1:	MOVE	T,TT
	SETZ	TT,
	LSHC	T,-4(B)		;shift bits into correct position in TT
	LSH	T,4		;Shift bits back in T
	PUSHJ	P,TVXY
	JRST	POPXJ		;give up if off screen
	JUMPE	T,TVFWT2
	MOVEM	A,11ADR
	MOVEM	T,11WRD
	PUSHJ	P,6TVWRT
TVFWT2:	ADDI	X,32.
	SETZ	B,
	JUMPN	TT,TVFWT1
POPXJ:	POP	P,X
	POPJ	P,

;CALCULATE 11ADR GIVEN X,Y
TVXY:	SKIPL X
	CAIL X,BITPL
	POPJ P,			;NON-SKIP RETURN FOR POINT OFF SCREEN
	SKIPL Y
	CAIL Y,NLINS
	POPJ P,
	MOVN A,Y		;X-Y -> 11 BIT ADDRESS
	IMULI A,BITPL/10	;BYTE ADDRESS OF BEGINNING OF LINE
	ADDI A,11TVHI+2-BITPL/10
	PUSH P,A
	MOVE A,X
	LSH A,-3		;BYTE WITHIN LINE
	ADDM A,(P)
POPAJ1:	AOS -1(P)		;SKIP RETURN
	JRST POPAJ
;READS IN 'KST' SYTLE SET

KSTRED:	PUSHJ P,WORDIN		;READ FONT DESCRIPTION
	MOVEM A,KSTID
	PUSHJ P,WORDIN
	HRRZM A,HEIGHT
	PUSH P,A
	LDB A,[221100,,(P)]	;BASE LINE
	MOVEM A,BASE
	LDB A,[331100,,(P)]	;COLUMN POSITION ADJUSTMENT
	MOVEM A,CPA
	SUB P,[1,,1]
	MOVEI A,MSETSZ		;SKIP NULL, TAB, CR, VT, LF
	MOVEM A,CHRCNT
	PUSHJ P,KSTIN
	JRST .+3		;END OF FILE
	SOSLE CHRCNT
	JRST .-3
	.CLOSE FONTCH,
	MOVEI A,MSETSZ
	SUB A,CHRCNT
	POPJ P,

;READS IN 'FNT' STYLE SET

FNTRED:	PUSH P,[0]		;COUNT OF CHARACTERS
	MOVEI B,MSETSZ		;MAX CHARS IN SET
	MOVEI CODE,0

FNTR1:	PUSHJ P,WORDIN
	JUMPE A,FNTR1A
	AOS (P)			;ANOTHER WINNER
	HLRZS A			;WIDTH
	MOVNM A,CHARD(CODE)
FNTR1A:	ADDI CODE,1
	SOJG B,FNTR1

	PUSHJ P,WORDIN		;KSTID
	MOVEM A,KSTID
	PUSHJ P,WORDIN		;HEIGHT
	MOVEM A,HEIGHT
	PUSHJ P,WORDIN		;MAX WIDTH
	PUSHJ P,WORDIN
	MOVEM A,BASE		;BASE LINE
	PUSHJ P,WORDIN
	MOVEM A,CPA		;COLUMN POSITION ADJUSTMENT
	.ACCES FONTCH,[400]
	SETZM IOCNT		;FORCE BUFFER INPUT ON NEXT WORDIN
	PUSH P,(P)		;COUNTER
FNTR2:	SOSGE (P)
	JRST FNTR3		;FINISH UP AND RETURN
	PUSHJ P,FNTIN		;READ CHARACTER DEF
	.VALUE			;HUH
	JRST FNTR2
FNTR3:	SUB P,[1,,1]
	MOVEI CODE,MSETSZ-1	;CLEAN UP THE WORLD
	SKIPGE CHARD(CODE)
	.VALUE
	SOJGE CODE,.-2

;PERFORM CHARACTER TRANSLATIONS

;UNDER SCORE AND LEFT ARROW

IRP CODE,,[30,137,30]
	EXCH A,CHARD+CODE
TERMIN

;CLOSE BRACE, ALTMODE, NOT EQUALS, TILDE

IRP CODE,,[176,175,33,32,176]
	EXCH A,CHARD+CODE
TERMIN

;CARROT, UP ARROW, INTEGRAL SIGN

IRP CODE,,[177,136,13,177]
	EXCH A,CHARD+CODE
TERMIN

FNTR4:	.CLOSE FONTCH,
	JRST POPAJ

;'CU' FORMAT, YET ANOTHER CMU STYLE FORMAT

CURED:	PUSH P,[CUEXIT]	;EXIT ROUTINE TO RESET BYTE SIZE
	MOVEI A,20
	MOVEM A,BITPB	;FILE IS SERIES OF 16 BIT BYTES
	SETOM CULCOD	;LAST CHARCTER WE LOST ON
	PUSHJ P,WORDIN	;HEIGHT
	SETZM BASE
	SETZM CPA
	MOVEM A,HEIGHT
	PUSHJ P,WORDIN	;MAXIMUM WIDTH IN 16 BIT BYTES
	PUSH P,A	;BYTES/ROW
	SETZM CHRCNT
CUCHR:	PUSHJ P,WORDIN	;ASCII CODE
	CAILE A,MSETSZ-1
	JRST POPAJ	;ILLEGAL CODE, RETURN
	MOVE CODE,A
	PUSHJ P,WORDIN	;BIT WIDTH OF THIS CHARACTER
	JUMPL A,POPAJ
	MOVE D,A
	ADDI A,17	;WORDS PER ROW FOR THIS CHARACTER
	IDIVI A,20
;	JUMPE A,POPAJ
	CAMLE A,(P)	;IS DATA SELF CONSISTANT
	JRST POPAJ	;    NO, GET OUT NOW
	MOVE B,A	;SIGNIFICANT BYTES/ROW
	SUB A,(P)
	MOVN C,A	;EXTRA BYTES/ROW
	PUSHJ P,CONS	;GET WORD OF STORAGE
	SKIPE CHARD(CODE)
	PUSHJ P,DUPCHR	;DUPLICATE CHARACTER
	MOVEM A,CHARD(CODE)
	MOVEM D,(A)	;0 (LEFT KERN),,SPACING WIDTH
	ADDI D,43
	IDIVI D,44	;WORDS/LINE
	HRL D,@CHARD(CODE)
	PUSHJ P,CONS
	MOVSM D,(A)	;WORD/LINE,,RASTER WIDTH	
	SKIPG E,HEIGHT
	JRST POPAJ	;ILLEGAL HEIGHT
CUROW:	MOVEI V,CUPUT	;CO-ROUTINE LINKAGE THROUGH V
	MOVE T,B	;SIGNIFICANT BYTES/ROW
	jumple t,curfix
CUWORD:	PUSHJ P,WORDIN
	cain code,101	;krokishly extract basline info from A
	 jrst [	came t,b
		jrst .+1
		jumpe a,.+1
		push p,a
		move a,height
		sub a,t
		camle a,base
		movem a,base
		pop p,a
		jrst .+1]
	JSP V,(V)
	SOJG T,CUWORD
curfix:	SKIPG T,C	;EXTRA BYTES/ROW
	JRST CUROW1
CUROW0:	PUSHJ P,WORDIN
	SKIPE A
	PUSHJ P,CULOST	;LOST SIGNIFCANCE
	SOJG T,CUROW0
CUROW1:	SOJG E,CUROW
	AOS CHRCNT
	JRST CUCHR

CUEXIT:	MOVEI A,44
	MOVEM A,BITPB
	POPJ P,

;CO-ROUTINE HACKAGE FOR STORING BIT MATRIX

CUPUT:	MOVE U,A	;16 BITS
	MOVEI D,44	;BITS/WORD
	PUSHJ P,CONS
	EXCH A,U
	JRST CUPUT0

;HERE FOR WORD OVERLAP

CUPUT1:	EXCH A,U	;A GETS ADDRESS TO WRITE, U GETS BITS
	EXCH TT,U	;BITS GO IN TT
	MOVEI U,0
	LSHC TT,(D)
	IORM TT,(A)
	PUSHJ P,CONS
	EXCH A,U
	ADDI D,44	;44 FRESH BITS
	IORM A,(U)
	JSP V,(V)
CUPUT0:	SUBI D,20
	JUMPL D,CUPUT1
	LSH A,(D)
CUPUT2:	IORM A,(U)
	JSP V,(V)	;CO-ROUTINE RETURN
	JRST CUPUT0

CULOST:	CAMN CODE,CULCOD
	POPJ P,
	MOVEM CODE,CULCOD
	PUSH P,A
	PUSH P,B
	MOVEI A,[ASCIZ /LOST BITS TO RIGHT OF CHARACTER /]
	PUSHJ P,OUTSTR
	MOVE A,CODE
	PUSHJ P,OCTPNT
	PUSHJ P,CRLF
	JRST ERRXIT

;DUPLICATE CHARACTER

DUPCHR:	PUSH P,A
	PUSH P,B
	MOVEI A,[ASCIZ /DUPLICATE CHARACTER - CODE /]
	PUSHJ P,OUTSTR
	MOVE A,CODE
	PUSHJ P,OCTPNT
	PUSHJ P,CRLF
ERRXIT:	SETOM ERRFLG
POPBAJ:	POP P,B
	JRST POPAJ
;'CMU' FORMAT
CMURED:	PUSHJ P,WORDIN
	SETZM KSTID	;CRUFTY KSTID!
	PUSHJ P,WORDIN
	HRRZM A,HEIGHT	;HEIGHT
	PUSHJ P,WORDIN	;"FORMAT NUMBER"
	PUSHJ P,WORDIN
	HRRZM A,BASE	;BASELINE
	PUSHJ P,WORDIN
	HRRZM A,CPA	;COLUMN BASE ADJUST
	MOVEI D,200+5	;FIVE SPARE, PLUS ONE WORD/CHAR
	PUSHJ P,WORDIN
	SOJG D,.-1
	SETZM CHRCNT
CMULP:	PUSHJ P,CMUIN
	JRST CMUDN
	AOS CHRCNT
	JRST CMULP

CMUDN:	.CLOSE FONTCH,
	MOVE A,CHRCNT
	POPJ P,

CMUIN:	PUSHJ P,WORDIN
	AOJN A,CPOPJ	;LOSER, SHOULD BE -1
	PUSHJ P,WORDIN
	HRRZ CODE,A	;CHAR CODE
	CAILE CODE,MSETSZ-1
	POPJ P,		;ILLEGAL CHARACTER CODE, GOOD BYE
	SKIPE CHARD(CODE)
	PUSHJ P,DUPCHR
	PUSHJ P,CONS
	MOVEM A,CHARD(CODE)
	PUSHJ P,WORDIN
	HLRZM A,@CHARD(CODE)
	HRRZ D,A
	PUSHJ P,CONS
	HRRM D,(A)
	ADDI D,35.
	IDIVI D,36.
	HRLM D,(A)
	HRRZM D,WDSPR'
	HRRZ D,(A)	;WIDTH IN BITS
	ADDI D,7
	IDIVI D,10
	HRRZM D,BYTPR'	;BYTES PER ROW
	PUSHJ P,WORDIN
	HLRZM A,TOPBL'
	HRRZM A,BOTBL'
	MOVE C,WDSPR
	IMUL C,TOPBL
	SOJL C,TOPDN
	PUSHJ P,CONS
	JRST .-2

TOPDN:	MOVE C,HEIGHT
	SUB C,TOPBL
	SUB C,BOTBL
	PUSH P,WDSPR
	PUSH P,BYTPR
	MOVEI V,0
	SOJL C,MDDN
	PUSHJ P,FONTI
	JRST .-2

MDDN:	SUB P,[2,,2]
	MOVE C,BOTBL
	IMUL C,WDSPR
	SOJL C,POPJ1
	PUSHJ P,CONS
	JRST .-2

COMMENT $ MIT FONT FORMAT

WORDS 0-1
	KSTID
	BYTE (9) COLUMN_POSITION_ADJUSTMENT,BASE_LINE (18) HEIGHT
			;base line # rasters from top of character matrix
REMAINDER OF FILE:  ONE BLOCK OF DATA FOR EACH CHARACTER
	USER_ID
			;NOT USED 4/10/74 but LOW ORDER BIT MUST BE 1
	LEFT_KERN,,CODE
			;Left Kern = amount to move left from the
			;Logical left end of the character to the left edge
			;of the raster.  + means move left, - move right.
			;left kern always 0 for CMU
	RASTER_WIDTH,,CHARACTER_WIDTH
			;raster width always 0 for CMU
			;Character Wdith = amount that the line bit position
			;is increased by printing the character.
	CHARACTER_MATRIX
			;the matrix is stored 4 8-bit bytes per word so that
			;ILDB with 8-bit byte size gets successive bytes.
			;The bits are bit reversed in each byte (high order
			;bit of character in low order bit of byte).
			;the matrix is stored row by row.
$


COMMENT $ FED INTERNAL FORMAT

	CHARD(CODE)	;points to character description

FORMAT OF CHARACTER DESCRIPTION
	LEFT_KERN,,CHARACTER_WIDTH
			;used to be CHARIACTER ID
	WORDS_PER_RASTER_LINE,,RASTER_WIDTH
	CHARACTER_MATRIX
			;the matix is stored one row per word left justified
			;if the character width is more that 36 bits then
			;the row is continued in the next words

$
;ROUTINE TO READ IN ONE CHARACTER FROM 'KST' FILE

;ACCUMULATOR USAGE FOR THIS ROUTINE

;	A  POINTS INTO FONT DESCRIPTION
;	B  CHUNK COUNTER
;	C  ROW COUNTER
;	D  # BITS LEFT TO PROCESS FOR THIS ROW
;	E  BIT COUNTER (TT)
;	T  CHUNK
;	TT ROW BITS (36/WORD)
;	U  WORD FROM FONT FILE
;	V  BYTE POINTER INTO U

KSTIN:	PUSHJ P,CONSIN		;USER ID
	PUSH P,A
	PUSHJ P,WORDIN
	HRRZ CODE,A		;ASCII CODE
	HLLM A,@(P)		;LEFT KERN
	POP P,A
	CAILE CODE,MSETSZ-1
	POPJ P,			;ILLEGAL CODE
	SKIPE CHARD(CODE)
	PUSHJ P,DUPCHR		;CHARACTER PREVIOUSLY DEFINED
	MOVEM A,CHARD(CODE)	;POINT INTO FONT
	PUSHJ P,CONSIN		;RASTER WIDTH,,CHARACTER WIDTH
	HRRZ D,(A)		;CHARACTER WIDTH
	HRRM D,@CHARD(CODE)
	HLRZ D,(A)		;RASTER WIDTH
	CAIE D,0		;DEFAULT TO CHARACTER WIDTH?
	MOVSS (A)
	HRRZ D,(A)		;RASTER WIDTH
	ADDI D,35.
	IDIVI D,36.		;# 36 BIT WORDS TO STORE ROW OF FONT
	HRLM D,(A)		;SAVE WITH DEFINITION
	HRRZ D,(A)		;WIDTH AGAIN
	PUSH P,D
	ADDI D,7
	IDIVI D,10		;# 8 BIT BYTES IN A ROW
	MOVE C,HEIGHT		;SET UP ROW COUNTER
	MOVEI V,0
	PUSH P,D
KSTLP:	PUSHJ P,FONTI		;Read in one row
	SOJG C,KSTLP
	SUB P,[2,,2]
POPJ1:	AOS (P)
CPOPJ:	POPJ P,

;MAIN LOOP

FONTI:	MOVE B,-1(P)		;# CHUNKS PER ROW
	MOVE D,-2(P)		;WIDTH OF CHARCTER
FONTI0:	SETZB T,TT
	MOVEI E,44
FONTI1:	SOJL B,FONTI4
	TLNN V,700000
	PUSHJ P,[	PUSHJ P,WORDIN
			MOVE U,A
			MOVE V,[441000,,U]
			TRNE U,1
			.VALUE		;START NEXT CHARACTER DESCRIPTION
			POPJ P,]
	ILDB T,V
	SUBI E,10
	JUMPLE E,FONTI2
	CIRCI T,-10
	JRST FONTI1		;MORE TO GO

FONTI2:	JUMPE E,[	CIRCI T,-10
			JRST FONTI3]
	CAME E,[-4]
	.VALUE			;SHOULD BE ONLY 4 BITS LEFT
	CIRCI T,-4		;FILL THE REST OF THE WORD
FONTI3:	PUSHJ P,CONS		;STORE AWAY 36 BITS
	MOVEM TT,(A)
	SUBI D,44
	JUMPE E,[	JUMPG B,FONTI0	;BACK FOR MORE IF NO BITS LEFT IN T
			JRST FONTI5]	;FINISHED READING THIS ROW
	MOVEI TT,0
	CIRCI T,-4		;T IS NOW CLEAR
	MOVEI E,40		;AND THERE ARE 4 BITS IN TT
	JUMPG B,FONTI1
	JUMPLE D,FONTI5

;FINISHED READING ONE ROW

FONTI4:	CAIL E,44
	JRST FONTI5
	LSH TT,(E)		;LEFT JUSTIFY
	PUSHJ P,CONS
	MOVEM TT,(A)
FONTI5:	POPJ P,

COMMENT $ STANFORD FONT FORMAT:

WORDS 0-177:
	XWD CHARACTER_WIDTH,CHARACTER_ADDRESS
					;Character address is the word number
					;in the file where the character
					;definition begins.
					;(unused by FC)
 
WORDS 200-237:
200	CHARACTER_SET_NUMBER		;(unused by FC)
201	HEIGHT	  			;(in scan lines)
202	MAX_WIDTH 			;(in bits)(unused by FC)
203	BASE LINE 			;(# of scan lines from top of character)
204	COLUMN POSITION ADJUSTMENT	;#of columns to shift left when selecting
					;this font, right when delselecting,
					;left at all explicit column selects.
					;used for fonts with left kerns.
205	Font Characteristics Word	;Reserved for future use. Will contain
					;Bits characterizing the font

WORDS 240-377:
	ASCIZ/FONT DESCRIPTION/

REMAINDER OF FILE:
	;(consists of "character definitions", packed sequentially into
	;the file).

    EACH CHARACTER DEFINITION:
	BYTE(9)RASTER_WIDTH,CHARACTER_CODE(18)WORD_COUNT+2	
					;(wc+2 is total space devoted
					;to this definition).
					;if raster width=0 then use character width
	BYTE(9)LEFT_KERN,ROWS_FROM_TOP(18)DATA_ROW_COUNT
					;Count of blank rows from the
					;top. Count of non-blank data
					;rows.  (pad with blank rows
					;at the bottom)
					;size of column adjustment for left kern
			;Left Kern = amount to move left from the
			;Logical left end of the character to the left edge
			;of the raster.  + means move left, - move right.
	BLOCK WORD_COUNT		;Data packed into words such that
					;an ILDB gets the next scan line
					;unless character width > 36
					;where next scan line starts
					;at first available word boundary.

Raster width is the size of the definition of the character.  Character
width is the amount the column counter is advanced bu printing this
character.   This allows characters to space less than their actual
width.  Caution: use of this feature will lead to more complex
lines than would otherwise result.  Some space and time problems may arise.

$
;READS IN ONE 'FNT' STYLE FONT

FNTIN:	PUSHJ P,CONSIN	;"USER" ID, BYTE (9) WIDTH, CODE (18) WORD COUNT
	LDB CODE,[221100,,(A)]
	TRNE CODE,600
	.VALUE
	LDB B,[331100,,(A)]	;RASTER WIDTH
	PUSH P,B
	MOVNS B			;MAKE IT NEGATIVE
	CAIN B,0
	MOVE B,CHARD(CODE)	;USED CHARACTER WIDTH ON LINE
	JUMPE B,[	SETZM CHARD(CODE)	;IGNORE THIS CHARACTER
			JRST POPAJ1]
	SKIPL B
	.VALUE
	EXCH A,CHARD(CODE)	;WIDTH AND POINTER TO CHARACTER DESCRIPTION
	MOVNM A,(P)		;MAKE CHARACTER WIDTH EXPLICIT
	PUSHJ P,CONS
	MOVNM B,(A)		;RASTER WIDTH (MIGHT BE DIFFERENT THAT CHARACTER WIDTH)
	MOVNS B
	ADDI B,43
	IDIVI B,44		;WORDS/ROW
	HRLM B,(A)
	PUSHJ P,WORDIN		;BYTE (9) LEFT_KERN,ROWS_FROM_TOP (18) ROW_COUNT
	LDB C,[331100,,A]	;LEFT KERN
	TRNE	C,400
	TRO	C,-400		;EXTEND SIGN IF NEGATIVE
	HRLM C,(P)		;LEFT KERN,,CHARACTER WIDTH
	LDB C,[221100,,A]
	PUSH P,A
	JUMPE C,FNTIN1		;NO BLANK ROWS ON TOP
	IMUL C,B		;# WORDS OF ZEROES
	PUSHJ P,CONS
	SOJG C,.-1
FNTIN1:	HRRZ E,@CHARD(CODE)	;DATA WORD COUNT
	SUBI E,2		;WE'VE ALREADY READ 2
	JUMPLE E,FNTIN2		;NO NON-BLANK ROWS
	MOVE A,CHARD(CODE)
	HRRZ A,1(A)		;PICKUP RASTER WIDTH
	CAIGE A,23
	JRST FNTI1A		;MORE THAN 1 SCAN LINE/WORD
	MOVNS A
	MOVNI C,1
	LSH C,(A)
	PUSHJ P,CONSIN
	ANDCAM C,(A)
	SOJG E,.-2
FNTIN2:	POP P,A
	LDB D,[221100,,A]	;BLANK ROWS AT TOP
	HRRZ C,A		;NON-BLANK ROW COUNT
	ADD C,D
	SUB C,HEIGHT		;BLANK ROWS AND END
	JUMPE C,FNTIN3
	IMUL C,B		;CONVERT TO WORD COUNT
	SKIPL C
	.VALUE
	PUSHJ P,CONS
	AOJL C,.-1
FNTIN3:	POP P,@CHARD(CODE)	;LEFT KERN,,CHARACTER WIDTH
	JRST POPJ1
;HERE TO PROCESS FONT WITH MULTIPLE SCAN LINES PER WORD

FNTI1A:	PUSH P,(P)
	HRRZS (P)		;ROW COUNT
	PUSH P,A		;WILL BE AMOUNT TO SHIFT
	PUSH P,[440000,,T]	;ALMOST A BYTE POINTER
	DPB A,[300600,,(P)]	;WIDTH FIELD
	MOVEI C,44
	IDIV C,A		;SCAN LINES/WORD
	PUSH P,C
	MOVEI C,44
	SUBM C,-2(P)
FNTI1B:	PUSHJ P,WORDIN
	MOVE T,A
	MOVE TT,(P)
	MOVE D,-1(P)
FNTI1C:	ILDB C,D
	PUSHJ P,CONS
	LSH C,@-2(P)
	MOVEM C,(A)
	SOSLE -3(P)		;ROW COUNT
	SOJG TT,FNTI1C
	SOJG E,FNTI1B
	SKIPE -3(P)
	JFCL	;ROW COUNT AND WORD COUNT DISAGREE (ROW COUNT IS REAL THING)
	SUB P,[4,,4]
	JRST FNTIN2
;READS IN ONE 'XH' STYLE FONT
;FORMAT IS 2 16 BIT NOVA WORDS PER PDP10 WORD,
;NOVA WORD 0/ K NUMBER OF HCARS IN FONT
;1/ N NUMBER OF WORDS OF BIT DATA
;2/ H HEIGHT OF FONT IN BITS
;3/ W MAXIMUM WIDTH, IN WORDS, OF ANY CHAR'S DATA
;4/ SELF RELATIVE PNTRS TO DATA FOR CHAR
;4+K/ WIDTH IN BITS FOR CHAR
;4+2K/ BIT DATA FOR EACH CHAR

XHRED:	SETZB	V,KSTID
	PUSHJ	P,XHWDIN	;READ A 16 BIT WORD
	MOVE	D,A		;CHAR SET SIZE
	PUSHJ	P,XHWDIN	;IGNORE MAX WIDTH
	PUSHJ	P,XHWDIN
	MOVEM	A,HEIGHT
	PUSHJ	P,XHWDIN
	MOVE	TT,A		;MAX CHAR WIDTH (IN 16. BIT WORDS)

;READ IN SELF RELATIVE PNTRS INTO CHARD TABLE
	SETZ	CODE,
XHPNRD:	PUSHJ	P,XHWDIN	;GET RELATIVE PNTR
	CAIGE	CODE,MSETSZ
	MOVEM	A,CHARD(CODE)
	AOJ	CODE,
	SOJG	D,XHPNRD	;JUMP IF MORE PNTRS TO READ

;NOW READ WIDTHS INTO FREE STORAGE
	CAILE	CODE,MSETSZ
	MOVEI	CODE,MSETSZ	;DON'T DO MORE THAN MSETSZ CHARS
	MOVEM	CODE,XHSTSZ'
	MOVE	E,FSP		;WHERE WIDTHS BEGIN
	PUSHJ	P,XCONS1	;READ NEXT 16. BIT WD INTO NEXT WD OF FS.
	SOJG	CODE,.-1

;NOW READ DATA FOR EACH CHARACTER
	SETZB	CODE,CHRCNT
XHCHRD:	CAML	CODE,XHSTSZ
	JRST	XHDONE		;DONE WITH WHOLE SET
	SKIPN	C,(E)		;WIDTH (IN BITS)
	AOJA	CODE,XHCHR1	;CHAR NOT DEFINED
	MOVE	D,CHARD(CODE)	;SELF RELATIVE PNTR
	PUSHJ	P,CONS
	MOVEM	A,CHARD(CODE)	;REPLACE WITH POINTER TO FED DATA
	SETZM	(A)		;CHAR ID
	PUSHJ	P,CONS
	MOVEM	C,(A)		;WIDTH IN BITS
	PUSHJ	P,XHIN		;READ THE DATA BITS FOR ONE CHAR
	AOS	CHRCNT
	AOJ	CODE,
	AOJA	E,XHCHRD	;INC PNTR TO WIDTH

XHCHR1:	SETZM	CHARD-1(CODE)
	AOJA	E,XHCHRD

XHDONE:	MOVE	A,CHRCNT
	SETZM	CHRCNT
	POPJ	P,

;RETURN NEXT NOVA WORD RIGHT JUSTIFIED IN A
;IF V=0 READ HIGH ORDER WORD
XHWDIN:	SOJE	V,.+4
	PUSHJ	P,WORDIN	;HIGH ORDER
	MOVEM	A,XHWD'
	MOVMS	V
	XCT	[LDB A,[ 42000,,XHWD]
		 LDB A,[242000,,XHWD]](V)	;GET APPROPRIATE BITS OF A
	POPJ	P,

;PUT NEXT 16. BIT WORD INTO NEXT 36. FS WORD
XCONS1:	PUSHJ	P,XHWDIN
	PUSH	P,A
	PUSHJ	P,CONS
	POP	P,(A)
	POPJ	P,

;READ DATA FOR CHAR IN CODES
;WIDTH IS IN C
;SELF RELATIVE POINTER IN D
;   EACH CHAR HAS BLOCKS OF H WORDS, WITH
;   EACH BLOCK DEFINING 12. HORIZONTAL BIT POSITIONS
;   HIGH 12. BITS ARE DATA, LOW 4 CONTAIN # OF VALID BITS.
XHIN:	MOVE	T,C
	IDIVI	T,36.
	JUMPE	TT,.+2
	AOJ	T,
	HRLM	T,(A)		;WIDTH IN 36. BIT WDS
	MOVE	TT,C
	IDIVI	TT,12.
	JUMPE	U,.+2
	AOJ	TT,		;WIDTH IN NOVA WORDS
	ADDI	D,4(CODE)	;MAKE REL PNTR ABSOLUTE NOVA PNTR
	MOVE	C,D
	ASH	C,-1		;ABSOLUTE PDP10 PNTR
	.ACCESS	FONTCH,C
	SETZB	V,IOCNT		;RESET NOVA BYTE, AND IO WD COUNTERS
	TRNE	D,1		;IF ODD NOVA ADDR
	PUSHJ	P,XHWDIN	;IGNORE EVEN NOVA WD
	MOVE	C,FSP		;BEGINNING OF BIT DATA FOR THIS WORD
	MOVE	B,T		;WIDTH IN 36.BIT WDS
	IMUL	B,HEIGHT
	PUSHJ	P,CONS		;GET ALL THE CORE WE NEED FOR THIS CHAR
	SOJG	B,.-1
	SETZ	B,		;12. BIT COLUMN MOD 3 WHICH W ARE CURRENTLY WORKING ON

;DO THIS LOOP ONCE FOR EACH 12. BIT COLUMN
XHIN1:	MOVE	D,C		;BEGINNING OF DATA FOR THIS 12 BIT COLUMN
	MOVE	U,HEIGHT

;DO THIS LOOP ONCE FOR EACH ROW
XHIN2:	PUSHJ	P,XHWDIN
	ASH	A,-4		;IGNORE VALID BITS FIELD
	XCT	[DPB A,[301400,,(D)]
		 DPB A,[141400,,(D)]
		 DPB A,[  1400,,(D)]](B)	;PUT DATA IN RIGHT FIELD OF 10 WORD
	ADD	D,T
	SOJG	U,XHIN2	;# OF ROWS FOR THIS COLUMN

	SOJLE	TT,XHIN3	;# OF COLUMNS LEFT
	AOJ	B,		;COLUMN #
	CAIG	B,2		;MOD 3
	JRST	XHIN1
	SETZ	B,
	AOJA	C,XHIN1	;INC START OF DATA FOR THIS COLUMN

XHIN3:	POPJ P,
;WRITE ONE 'AST' FONT

ASTOUT:	MOVE TT,CHARD(CODE)
	HRRZ	A,CODE		;CODE
	PUSHJ	P,OCTPNT
	MOVEI A,[ASCIZ / CHARACTER CODE /]
	PUSHJ P,OUTSTR
	PUSHJ P,IFPNT
	PUSHJ P,CRLF
	HRRZ	A,1(TT)		;RASTER WIDTH
	PUSHJ	P,DECPNT
	MOVEI A,[ASCIZ / RASTER WIDTH/]
	PUSHJ P,TERPRI
	HRRZ A,(TT)		;CHARACTER WIDTH
	PUSHJ P,DECPNT
	MOVEI A,[ASCIZ / CHARACTER WIDTH/]
	PUSHJ P,TERPRI
	HLRE	A,(TT)		;LEFT KERN
	PUSHJ P,DECPNT
	MOVEI A,[ASCIZ / LEFT KERN/]
	PUSHJ P,TERPRI
	HLRZ	A,1(TT)		;# WORDS/LINE
	MOVNM	A,WPERL
	MOVE	Y,HEIGHT
	ADDI	TT,2		;TT -> CHAR START
	SETZM	E		;COUNTS # PENDING CRLF'S
RLINE:	HRL	TT,WPERL
	SETZM	D		;COUNTS # PENDING BLANKS
RWORD:	MOVE	B,(TT)
	MOVEI	X,36.
RBIT:	SETZM	A
	LSHC	A,1
	JUMPN	A,AST		;COUNT " " OR PRINT "*"
	AOJA D,RNEXTB

AST:	JUMPE	E,ASTB
	PUSHJ	P,CRLF
	SOJG	E,.-1
ASTB:	JUMPE	D,ASTP
	MOVEI	A," 
	PUSHJ	P,PUTCHR
	SOJG	D,.-1
ASTP:	MOVEI	A,"*
	PUSHJ	P,PUTCHR
RNEXTB:	SOJG	X,RBIT		;ANOTHER BIT?
	AOBJN	TT,RWORD	;ANOTHER WORD?
	AOS	E
	SOJG	Y,RLINE		;ANOTHER LINE?
	SKIPE	E		;END WITH CRLF IF ANY ARE PENDING
	PUSHJ	P,CRLF
	POPJ	P,

;WRITES OUT A WHOLE AST SET

ASTWRT:	PUSH P,TTYFLG
	SETZM TTYFLG
	PUSHJ P,ZAPBUF
	PUSHJ P,CBFIO2
	MOVE A,KSTID
	PUSHJ P,DECPNT
	MOVEI A,[ASCIZ / KSTID /]
	PUSHJ P,OUTSTR
	PUSHJ P,IFPNT			;PRINT THE SOURCE FILE NAME
	PUSHJ P,CRLF
	MOVE A,HEIGHT
	PUSHJ P,DECPNT
	MOVEI A,[ASCIZ / HEIGHT/]
	PUSHJ P,TERPRI
	MOVE A,BASE
	PUSHJ P,DECPNT
	MOVEI A,[ASCIZ / BASE LINE/]
	PUSHJ P,TERPRI
	MOVE A,CPA
	PUSHJ P,DECPNT
	MOVEI A,[ASCIZ / COLUMN POSITION ADJUSTMENT/]
	PUSHJ P,TERPRI
	MOVEI A,^L
	PUSHJ P,PUTCHR
	PUSH P,[MSETSZ]
	MOVEI CODE,0
ASTO2A:	SKIPE CHARD(CODE)
	PUSHJ P,[	PUSHJ P,ASTOUT
			MOVEI A,^L
			JRST PUTCHR]
	SOSLE (P)
	AOJA CODE,ASTO2A
	POP P,(P)
	PUSHJ P,CBUFIO
	POP P,TTYFLG
	JRST	POPJ1

;READS IN 'AST' STYLE CHARACTER SET

ASTRED:	PUSH P,[0]		;CHARACTERS READ
IRP VAR,REST,[KSTID,HEIGHT,BASE,CPA]
	PUSHJ P,DECINL
	JUMPL A,FNTR4
	MOVEM C,VAR
IFSN [REST],[CAIE A,12
	.VALUE
]
IFSE [REST],CAIE A,14
TERMIN
	PUSHJ P,SPAGE
	JUMPL A,FNTR4
	SETZM CULCOD	;NO TOO-LONG LINES SEEN YET IN THIS FONT.
ASTR1:	PUSHJ P,ASTIN
	JRST FNTR4
	AOS (P)
	JRST ASTR1

;ROUTINE TO READ IN ONE 'AST' FONT CHARACTER.
ASTIN:	PUSHJ	P,OCTIN		;GET CODE
	JUMPL A,CPOPJ
	MOVE	CODE,C
	SKIPL	CODE
	CAILE	CODE,MSETSZ-1
	POPJ	P,		;ILLEGAL CODE - EOF
	SKIPE	CHARD(CODE)
	JRST	WSKCH		;CHAR PREVIOUSLY DEFINED
	PUSHJ	P,GETL		;IGNORE REST OF LINE
	JUMPL A,CPOPJ
	PUSHJ	P,DECNL1	;POPS EXTRA LEVEL ON EOF
	JUMPL	C,[.VALUE]	;NEGATIVE RASTER WIDTH ILLEGAL
	HRLZ	X,C		;SAVE RASTER WIDTH
	PUSHJ	P,DECNL1	;CHARACTER WIDTH
	JUMPL	C,[.VALUE]
	HRR	X,C
	PUSHJ	P,DECNL1	;LEFT KERN
	PUSH	P,X		;RASTER WIDTH,,CHARACTER WIDTH
	PUSH	P,C
	PUSHJ P,CONS		;WILL BE LEFT KERN,,CHARACTER WIDTH
	MOVEM A,CHARD(CODE)
	POP P,C			;LEFT KERN
	HRLZM	C,(A)
	HRRZ	C,(P)
	HRRM	C,(A)		;CHARACTER WIDTH
	PUSHJ	P,CONS
	POP	P,C
	HLRZS	C
	MOVEM	C,(A)		;RASTER WIDTH
	ADDI	C,35.
	IDIVI	C,36.		;# WORDS/LINE
	HRLM	C,(A)
	MOVE C,(A)		;C HAS # BITS/LINE,,# WDS/LINE
	SKIPA Y,HEIGHT		;# LINES/CHAR
WLINE:	 PUSHJ P,GETL
	HLRZ X,C		;# WORDS/LINE
	HRRZ D,C		;# BITS/LINE (RASTER WIDTH)
	HRRZ T,FSP
	SOS T
	HRLI T,000100		;B.P. TO IDPB NEXT BIT OF LINE.
WBIT:	PUSHJ P,GETCHR
	JUMPL A,WENDC
	CAIN A,^L
	 JRST WENDC		;EOC
	CAIN A,15
	 JRST WENDL		;EOL
	SOJL D,ASTXTR		;THERE'S ANOTHER BIT TO STORE.  LINE TOO LONG?
	PUSH P,A
	TLNN T,770000		;NO, IF ABOUT TO STORE INTO A NEW WORD, ALLOCATE THE CORE.
	 PUSHJ P,[SOJA X,CONS]	 ;X IS # OF WORDS, OF MAX, THAT WE DIDN'T MAKE.
	POP P,A
	CAIN A,40		;NEXT BIT IS 1 IFF CHAR NOT SPACE.
	 TDZA A,A
	  MOVEI A,1
	IDPB A,T
	JRST WBIT

ASTXTR:	PUSHJ P,CULOST		;REPORT THIS LINE TOO LONG.
	JRST WNEXTL

WENDL:	PUSHJ P,WLFILL
WNEXTL:	SOJG	Y,WLINE		;ANOTHER LINE ?
ENDCH:	PUSHJ	P,SPAGE
	JRST	POPJ1

WSKCH:	AOS	CHRCNT		;SKIP CHAR
	PUSHJ P,DUPCHR		;FOUND DUPLICATE CHARACTER
	JRST	ENDCH

WENDC:	PUSHJ	P,WLFILL	;AFTER ^L, END CHAR WITH ZEROES (THIS LINE AND REMAINING ONES)
WENDC1:	HLRZ	X,C
	SOJLE	Y,POPJ1		;CHAR IS FINISHED
	PUSHJ	P,WLFIL1
	JRST	WENDC1

WLFILL:	JUMPE	X,CPOPJ
WLFIL1:	PUSHJ	P,CONS		;PAD LINE WITH ZEROS TO DESIRED # WORDS.
	SOJG	X,WLFIL1	;ANY MORE WORDS ?
	POPJ P,

;ROUTINE TO WRITE ONE 'KST' FONT CHARACTER.

KSTOUT:	MOVE B,CHARD(CODE)
	HRRZ A,1(B)		;RASTER WIDTH
	JUMPE A,CPOPJ		;DON'T ATTEMPT ZERO WIDTH CHARACTERS
	MOVEI A,1		;MAKES PUB HAPPY
	PUSHJ	P,WRDOUT	;USRID
	HRRZ	A,CODE
	HLL A,(B)
	PUSHJ	P,WRDOUT	;LEFT KERN,,CODE
	MOVE A,(B)
	HRL A,1(B)
	PUSHJ	P,WRDOUT	;RASTER WIDTH,,CHARACTER WIDTH
	HLRZ	C,A		;USE RASTER WIDTH
	ADDI	C,3
	LSH	C,-2		;# 4 BIT BYTES/LINE
	ADDI	B,2
	HRLI	B,440400	;B <- 4 BIT BYTE PTR
	MOVE	Y,HEIGHT	;# LINES/CHAR
	SETZM	TT
	MOVEI D,4		;4 8 BIT BYTES/WORD
OFLINE:	MOVE X,C
OFBYTE:	ILDB	E,B		;GET 8 REVERSED BITS INTO TT
	MOVEI T,0
	SOSLE X
	ILDB	T,B
	CIRCI	T,-4
	MOVE	T,E
	CIRCI	T,-4
	SOJG D,OFBYT1
	MOVEI D,4		;RESET THAT DUDE
	PUSHJ P,NOFL1
	SETZM TT
OFBYT1:	SOJG	X,OFBYTE	;ANOTHER BYTE IN LINE ?
OFLEND:	HRLI	B,440400
	ADDI	B,1
NOFLIN:	SOJG Y,OFLINE
	CAIN D,4
	POPJ P,			;NOTHING IN TT, GO AWAY
	LSH TT,10
	SOJG D,.-1
NOFL1:	LSH TT,4
	MOVE	A,TT
	JRST WRDOUT

SETOUT:	PUSHJ P,OPNOUT
	JRST [	MOVEI A,OFDEV	;.OPEN FAILED
		PUSHJ P,FNF
		JRST SETOUT]
	PUSHJ	P,CMPACT	;Possibly compact raster
	MOVE	B,ITYPE		;GET TYPE
	PUSHJ	P,@WRITEF(B)
	POPJ	P,		;CNTWRT doesn't skip
	.FDELE	RNBLK		;Now rename file to what he really wants
	.VALUE
	.CLOSE	FONTCH,
	POPJ	P,

;WRITES OUT THE WHOLE SET IN 'KST' FORMAT

KSTWRT:	PUSHJ P,ZAPBUF
	PUSHJ P,WBFIO2		;SET POINTERS
	MOVE A,KSTID
	PUSHJ P,WRDOUT
	PUSH P,HEIGHT
	MOVE A,CPA
	DPB A,[331100,,(P)]
	MOVE A,BASE
	DPB A,[221100,,(P)]
	POP P,A
	PUSHJ P,WRDOUT
	MOVEI CODE,MSETSZ-1
	SKIPE CHARD(CODE)
	PUSHJ P,KSTOUT
	SOJGE CODE,.-2
	MOVNI A,1
	PUSHJ P,WRDOUT
	PUSHJ P,WRDOUT
LSTBUF:	MOVEI A,BUFSIZ
	SUB A,IOCNT
	JUMPE A,LSTBF1
	MOVNS A
	HRLI A,BUF
	MOVSS A
	PUSHJ P,WBFIO1
LSTBF1:	JRST	POPJ1

;READ OUTPUT FILE NAME AND OPEN

OPNOUT:	MOVE A,IFFILE
	MOVEM A,OFFILE
	MOVSI A,'KST
	MOVEM A,OFFNM2
	MOVEI A,[ASCIZ /FILE:  /]
	PUSHJ P,OUTSTR
	PUSHJ P,TTYLIN		;GET LINE FROM TTY
	MOVE B,[PUSHJ P,COMGET]
	MOVEI C,0
	JSR FNR"GETFIL
	JRST OPNIT		;DEFAULT
	SKIPE D
	HLRM D,OFDEV
	SKIPE E
	MOVEM E,OFFILE
	SKIPE T
	MOVEM T,OFFNM2
	SKIPE TT
	MOVEM TT,OFFSNM
OPNIT:	MOVEI C,TYPTBL-1
	MOVE B,OFFNM2		;Look at FN2 to see if it says what type of file.
	CAMN B,[SIXBIT />/]
	 MOVSI B,'AST		;">" means user wants to edit it, so it must be type AST.
	CAME B,TYPTAB(C)
	 SOJGE C,.-1
	MOVEM C,ITYPE
	SKIPGE C
	 PUSHJ P,HUH		;If it doesn't say, ask the user.
	HRRZS	OFDEV
	.SUSET [.SSNAM,,OFFSNM]
	MOVSI C,(SIXBIT/>/)
	CAME C,OFDEV+1		;Don't check for clobberage if a filename of >,
	 CAMN C,OFDEV+2		;since that always writes a new file.
	  JRST OPNIT1
	.OPEN	FONTCH,OFDEV	;See if file already exists by opening for reading
	 JRST 	OPNIT1		;No
	PUSH	P,A
	MOVEI	A,[ASCIZ /File already exists. Clobber? (Y or N)/]
	PUSHJ	P,TYICR
	MOVE	C,A
	POP	P,A
	CAIE	C,"Y
	 JRST	OPNOUT		;Don't write
OPNIT1:	PUSH P,A
	MOVEI	A,[ASCIZ /Writing:  /]
	PUSHJ	P,OUTSTR
	MOVE	A,[OFDEV,,FCHST]
	BLT	A,FCHST+3	;Fake a .RCHST
	PUSHJ	P,RPFNAM
	PUSHJ	P,CRLF
	POP	P,A
	MOVE	C,[OFFILE,,RFNAM1]
	BLT	C,RFNAM2	;Save user's file name
	MOVE	C,[[SIXBIT /FED/
			'OUTPUT],,OFFILE]
	BLT	C,OFFNM2	;Open as FED OUTPUT
	MOVEI	C,7
	HRLM	C,OFDEV		;Replace mode bits (image block out)
	.OPEN FONTCH,OFDEV
	POPJ P,			;OPEN FAILS, TAKE DIRECT RETURN
	AOS (P)
	JRST GETIN1

;CMPACT compacts the raster by eliminating leading and trailing blank columns
CMPACT:	MOVEI	A,[ASCIZ /Compact raster?  (Y or N)/]
	PUSHJ	P,TYICR
	CAIN	A,"N
	POPJ	P,
	CAIE	A,"Y
	JRST	CMPACT
	SETZM	LSPACE
	SETZM	RSPACE
	SETZM	SVWDS
	HRLZI	CODE,-MSETSZ
	SKIPE	B,CHARD(CODE)	;Skip if char not defined
	PUSHJ	P,CMPCHR	;Try to compact it
	AOBJN	CODE,.-2	;Look at next char
	MOVE	A,SVWDS
	IMUL	A,HEIGHT
	PUSHJ	P,OCTPNT
	MOVEI	A,[ASCIZ / (octal) PDP11 words saved/]
	PUSHJ	P,TERPRI
	POPJ	P,

CMPCHR:	HLRZ	D,1(B)		;Width in words
	HRRZ	U,1(B)		;Width in bits
	PUSHJ	P,LSCNT		;Count leading left blank columns
	CAMG	U,LSPACE
	 JRST	CM0WID		;Zero raster width
	PUSHJ	P,RSCNT		;Count trailing right blank columns
	ADD	A,LSPACE	;Total # columns to flush
	MOVE	B,CHARD(CODE)
	PUSH	P,X
	PUSH	P,Y
	MOVE	X,U
	SUBB	X,A		;New width in bits
	JUMPLE	A,CMPE
	ADDI	X,35.
	IDIVI	X,36.		;New width in words
	MOVEI	E,36.
	SUBI	E,1(Y)		;# of non-raster bits in last word of row
	MOVE	Y,A		;New width in bits
	ADDI	B,2		;Where to get old words from
	MOVE	C,B		;Where to move compacted words to
	MOVE	V,HEIGHT
;FALLS THROUGH

;FALLS IN
CMPCH1:	PUSH	P,B
	PUSH	P,C
	PUSH	P,V
	PUSHJ	P,SHROW		;shift row
	POP	P,V
	POP	P,C
	POP	P,B
	ADD	B,D
	ADD	C,X
	SOJG	V,CMPCH1
	MOVE	B,CHARD(CODE)	;Now modify character definition
	HLRE	A,(B)		;Old left Kern
	SUB	A,LSPACE
	HRLM	A,(B)	
	HRLM	X,1(B)		;New width in words
	HRRM	Y,1(B)		;in bits
	ADDI	U,15.
	MOVEI	X,15.(Y)
	IDIVI	U,16.		;Old width, 16. bit words
	IDIVI	X,16.		;New width
	SUB	U,X
	ADDM	U,SVWDS
CMPRET:	POP	P,Y
	POP	P,X
	POPJ	P,

CMPE:	.VALUE			;Trying to flush too many columns
	JRST	CMPRET

CM0WID:	MOVE	B,CHARD(CODE)	;Here for 0 width character
	HRRZS	(B)		;0 left kern
;following is hack to make raster width 1, so as not to confuse some programs
;This is due to difference between CMU and KST formats
;CMU does not use raster width, which is always 0.  (IE, CW=RW)
;AI XGP11 program is smart enough to not use any space for a blank character
	MOVE	A,[1,,1]
	MOVEM	A,1(B)
	MOVEI	B,2(B)
	SETZM	(B)		;Zero out Height words
	MOVEI	A,-1(B)
	ADD	A,HEIGHT
	HRL	B,B
	AOJ	B,
	BLT	B,(A)
	POPJ	P,

;SHROW compacts one Row of character in CODE
;B where to get old row from
;C where to put compacted row
;E # of bits which will be left over in last word of row
;X # of words in new (compacted) row
SHROW:	MOVE	T,LSPACE	;Total # of bits to shift left
	IDIVI	T,36.
	ADD	B,T		;# of words to shift left
	MOVE	A,TT		;# of bits to LSHC
	MOVE	V,X		;# of wds in new row
SHROW1:	MOVE	T,(B)		;get old bits
	CAIG	V,1		;get 2nd word of old bits, unless there really
	 CAML	A,E		;are no old bits of value in that word,
	  MOVE	TT,1(B)		;in which case we must not fetch to avoid risking an MPV.
	LSHC	T,(A)
	MOVEM	T,(C)
	AOJ	B,
	AOJ	C,
	SOJG	V,SHROW1
	MOVN	TT,E
	LSH	T,(TT)		;Fix last word of row
	LSH	T,(E)		;by shifting 0s into non-matrix bits
	MOVEM	T,-1(C)
	POPJ	P,

;LSCNT counts leading blank columns in LSPACE and A
;D width in words
;U width in bits
LSCNT:	SETZB	A,T		;Total # of leading blanks
LSCNT1:	MOVEI	C,2(B)
	MOVE	V,HEIGHT	;# of rows
	IOR	T,(C)		;ior 36. columns for all rows
	ADD	C,D
	SOJG	V,.-2
	JFFO	T,LSCNT2	;Count 0s in TT
	ADDI	A,36.		;44 bits of leading 0's
	CAMGE	A,U
	AOJA	B,LSCNT1	;More columns to look at
	JRST	LSCNT3
LSCNT2:	ADD	A,TT		;Total leading spaces
LSCNT3:	CAML	A,U		;Shouldn't be larger than raster width
	MOVE	A,U
	MOVEM	A,LSPACE
	POPJ	P,

;RSCNT counts trailing blank columns in RSPACE and A
RSCNT:	MOVE	B,CHARD(CODE)
	MOVE	T,U
	IDIVI	T,36.
	SKIPE	E,TT
	MOVEI	E,36.
	SUB	E,TT		;# of non-raster bits in last word
	SETZB	A,TT
	ADDI	B,1(D)		;Points at last columns of first row
RSCNT1:	MOVE	C,B
	MOVE	V,HEIGHT
	IOR	TT,(C)
	ADD	C,D
	SOJG	V,.-2
	CIRCI	T,36.		;Reverses TT into T
	JFFO	T,RSCNT2
	ADDI	A,36.		;whole word of trailing 0s
	CAMGE	A,U
	SOJA	B,RSCNT1	;Look at previous 36 columns
	JRST	RSCNT3
RSCNT2:	ADD	A,TT		;Total trailing 0s
	SUB	A,E		;minus non raster trailing 0s
	JUMPL	A,.+2
	CAML	A,U
RSCNT3:	.VALUE			;0 raster dots, should have been caught by LSCNT
	MOVEM	A,RSPACE
	POPJ	P,
;5/29/73 PROGRAMMING THE PDP-6 TO PDP-11 INTERFACE

;THE INTERFACE LETS THE PDP-6 PROGRAMMER DIRECTLY ACCESS THE MEMORIES
;OF UP TO EIGHT PDP-11'S.  PDP-6 PAGES ARE MAPPED INTO SEGMENTS OF
;VARIABLE SIZE IN THE PDP-11'S MEMORY.  THE PDP-6 PAGE MAP IS ALSO
;DIRECTLY ADDRESSABLE IN MEMORY (IT CURRENTLY LIVES IN LOCATIONS
;776000-776777).  THERE IS ONE ENTRY IN THE MAP FOR EACH PDP-6 PAGE.

;PAGE TABLE ENTRY:
;	4.9	VALID
;	4.8	WRITE ENABLE
;	4.3-4.7	(5 BITS) NOT USED (0)
;	3.9-4.2	(3 BITS) PDP-11 NUMBER
;	2.2-3.8	(16 BITS) RELOCATION
;		ORIGIN OF SEGMENT OF IN PDP-11 ADDRESS SPACE
;		PDP-11 ADDRESS=4*RELOCATION
;	1.1-2.1	(10 BITS) PROTECTION (PDP-11 PROTECTION=4*PROTECTION
;		IF PROTECTION=0 THEN ONLY ONE 16 BIT WORD IS ACCESSIBLE)

;WRITE REFERENCE FORMAT
;	3.3-4.9	(16 BITS) WORD 0, LOW ORDER WORD
;	1.5-3.2	(16 BITS) WORD 1, HIGH ORDER WORD
;	1.4	DON'T WRITE WORD 0
;	1.3	DON'T WRITE WORD 1
;	1.1-1.2	(2 BITS) NOT USED

;READ REFERENCE FORMAT
;	3.3-4.9	(16 BITS) WORD 0, LOW ORDER WORD
;	1.5-3.2	(16 BITS) WORD 1, HIGH ORDER WORD
;	1.1-1.4	(4 BITS) 0

;NOTE -- SPLIT CYCLES WILL DO THE RIGHT THING; HENCE, ILDB AND IDPB WORK.

;CAUTION -- WHEN USING BYTE INSTRUCTIONS, A 16 BIT BYTE SIZE IS
;RECCOMMENDED.  SUCCESSIVE INCREMENTS OF BYTE POINTERS WITH AN 8 BIT BYTE
;SIZE DO NOT ADDRESS CONSECUTIVE BYTES IN THE PDP-11!
;PDP-6 ROUTINES

IFL .-2000,LOC 2000
6FIRST==.

;PDP-11 ADDRESSES

11CREG==764044		;CONSOLE REGISTER
11CSA==157776		;CONSOLE STARTING ADDRESS REGISTER
11TVLO==60000		;ORIGIN OF DISPLAY MEMORY
11TVHI==157656		;LAST VISIBLE WORD IN DISPLAY MEMORY
11LKS==40		;PSEUDO 11 LINE CLOCK STATUS REG.

;CONSOLE REGISTER ALU FUNCTIONS

CANDC==2
CSETZ==3
CCOMP==5
CXOR==6
CEQV==11
CSAME==12
CAND==13
CSETO==14
CIOR==16
CSET==17

;INITIAL 11 MAP

;I11MAP:	REPEAT 10,[
;	<600000,,1777>+<60000+<.RPCNT*10000>>_10]	;DISPLAY MEMORY
;	<600000,,1>+<11CREG>_10				;CONSOLE REGISTER
;	<600000,,1>+<11LKS>_10				;PDP11 CLOCK
;	0						;END OF MAP

;11PGS==.-I11MAP-1	;# PAGES IN PDP11 MEMORY
11PGS==11		;VIDEO BUFFER FOLLOWED BY CONSOLE REG
;PDP-6 ADDRESSES

P6TVLO==400-11PGS	;PAGE # OF FIRST PAGE IN DISPLAY MEMORY
6TVLO=P6TVLO_12		;ORIGIN OF DISPLAY MEMORY
6TVHI=6TVLO+17777	;LAST WORD OF DISPLAY MEMORY
6CREG=6TVHI+1		;CONSOLE REGISTER
;6LKS=6CREG+2000		;LINE CLOCK STATUS REGISTER
;PDP-6 ACTION ROUTINES

;HERE TO PUT DISPLAY MEMORY IN MAP

GET11:	MOVEI B,0	;VIDEO BUFFER PAGE
	MOVE A,[-11,,P6TVLO]	;MAP PAGE
	.CALL [SETZ
		SIXBIT /CORBLK/
		1000,,600000
		1000,,-1	;TARGET USER (US)
		A
		1000,,-2	;VIDEO MAP
		SETZ B]
	.VALUE
	JRST TVCLR

IFN 0,[
	MOVEI A,I11MAP
	MOVEI B,P6TVLO
GET11L:	SKIPN (A)
	JRST TVCLR		;CLEAR SCREEN WHEN DONE
	.CALL [	SETZ
		SIXBIT /T11MP/
		B		;PAGE
		SETZ (A)]	;MAP ENTRY
	.VALUE
	AOJ A,
	AOJA B,GET11L
]
;WRITE WORD INTO DISPLAY MEMORY

6TVWRT:	MOVEI A,CIOR
	DPB A,[341000,,6CREG]
	MOVE A,11ADR
	CAIL A,11TVLO
	CAILE A,11CSA
	JRST 4,.	;WE WERE PASSED ILLEGAL ADDRESS
	SUBI A,11TVLO
	ASH A,-2
	MOVE B,11WRD
	MOVEM B,6TVLO(A)
	POPJ P,

;CLEAR TV SCREEN

TVCLR:
;	MOVEI A,4	;TURN OFF CLOCK
;	MOVEM A,6LKS
	MOVEI A,CSET
	DPB A,[341000,,6CREG]
	MOVE A,[6TVLO-6TVHI,,6TVLO]
TVCLR1:	SETZM (A)
	AOBJN A,TVCLR1
	POPJ P,

6TVFIN:
;	MOVE A,[100_2,,4]	;CLOCK BACK ON
;	MOVEM A,6LKS
	POPJ P,
6GO:	MOVE P,[-100,,77]
6WAIT:	SKIPE B,DPYBLK
	PUSHJ P,6GO340
	AOSE 6TASK
	JRST 6WAIT
	SKIPN A,6DISP
	JRST 4,.
	SETZM 6DISP
	PUSHJ P,(A)
	JRST 6WAIT

;PDP6 340 DISPLAY DRIVER

DIS==130

6GO340:	CONO DIS,100	;GRAB THE 340
WAIT:	MOVEI A,0
	JUMPL B,LOOP1
	MOVE A,B
LOOP:	JUMPE A,CPOPJ	;BLKO POINTER
	CONO DIS,100	;RESET 340
	HLRZ B,A	;POINTS TO BLKO POINTER
	HRRZS A
	SKIPE A
	MOVE A,(A)
	JUMPE B,LOOP	;POINTS AT NOTHING
	SKIPL B,(B)	;THE BLKO POINTER
	JRST LOOP	;NOT REALLY BLKO POINTER

LOOP1:	MOVEI C,100	;TIME OUT IN CASE DISPLAY HANGS
	CONSO DIS,200	;WAIT FOR DONE
	SOJG C,.-1
	JUMPE C,ERR
LOOP2:	SKIPN DPYBLK
	POPJ P,		;DISPLAY STOPPED BY PDP10
	BLKO DIS,B
	JRST .+2	;BLKO COUNTED OUT
	JRST LOOP1	;MORE TO GO
	MOVEI C,200
	CONSO DIS,100	;WAIT FOR DONE
	SOJG C,.-1
	JRST LOOP

ERR:	CONSO DIS,5000
	JRST LOOP
	CONO DIS,200	;EDGE PROTECTION VIOLATION
	JRST LOOP1
VER1:	.FNAM1		;SOURCE FILE
VER2:	.FNAM2

LIT:	CONSTANTS
VAR::	VARIABLES

;PUSH DOWN LIST AND PATCH AREA

PAT:
PATCH:	BLOCK PATL	;PATCH AREA
PDP:	-PDL,,PDB-1
PDB:	BLOCK PDL

;OPEN BLOCK FOR ERR DEVICE

ERROPN:	SIXBIT /   ERR/
	1		;LAST CHANNEL WITH ERR

;I/O BUFFERS

BUFSIZ==200
TTYFLG:	0		;-1 SENDS IO TO TTY, 0 TO FONTCH
BITPB:	0		;BITS PER BYTE (USUALLY 44 BUT CAN BE 20)
IOPTR:	0		;BYTE POINTER INTO BUFFER
IOCNT:	0		;CHARACTER COUNTER
CULCOD:	0		;HOLDS CODE OF LAST CHARACTER WE LOST ON
ERRFLG:	0		;SETOM'D IF ERROR FOUND IN FILE BEING READ.
BUF:	BLOCK BUFSIZ

COMBFL==100
COMPNT:	0
COMCNT:	0
COMBUF:	BLOCK COMBFL
;DPYNUM:	DFTDPY

;FONT VARIABLES

OFDEV:	7,,'DSK
OFFILE:	SIXBIT /CYR25/
OFFNM2:	SIXBIT /KST/
OFFSNM:	0
RNBLK:	0		;File names moved here for rename
	0
	FONTCH
RFNAM1:	0
RFNAM2:	0

IFDEV:	6,,(SIXBIT /DSK/)	;FONT INPUT FILE
IFFILE:	SIXBIT /CTL25/	;FONT INPUT FILE CHANNEL STATUS
IFFNM2:	SIXBIT /KST/
IFFSNM:	SIXBIT /FONTS/
FCHST:	FCHSTL==10 ? BLOCK FCHSTL
ITYPE:	0		;TYPE OF FONT WE'RE READING IN
KSTID:	0		;CHARACTER SET ID
HEIGHT:	0		;FONT HEIGHT
CPA:	0		;COLUMN POSITION ADJUSTMENT
BASE:	0		;CHARACTER SET BASE LINE
WPERL:	0
CHARD:	BLOCK MSETSZ	;POINTERS TO FONT DESCRIPTORS
CHRCNT:	0		;CHARACTER COUNTER
CHARBP:	0		;BYTE POINTER TO TEXT LINE
DPYBLK:	0		;BLKO POINTER TO DISPLAY LIST
LINE0:	BLOCK 6		;UPPER CASE CHARACTER CODES
LINE1:	BLOCK 6		;LOWER CASE
LINE2:	BLOCK 7		;SPECIAL CHARACTERS AND NUMBERS
LINE3:	BLOCK 7
LINE4:	BLOCK 7		;CONTROL CHARACTERS
RADEX:	0
LSPACE:	0		;# of leading blank columns for CMPACT
RSPACE:	0		;# of trailing blank columns
SVWDS:	0		;# PDP11 wds saved by raster compaction
;10-6 COMMUNICATION AREA

340DPY:	0		;-1=>WE ARE NEAR 340
PDP6:	0		;-1=> WE HAVE PDP-6
TVDPY:	0		;-1=>USE THE TV FOR DISPLAY
TCMXV:	0		;TTY VERT SIZE
TCMXH:	0		;TTY HORZ SIZ
TCTYP:	0
TTYCOM:	0
TTYOPT:	0
TTYTYP:	0

USRO:	3,,(SIXBIT /USR/)	;USER OPEN BLOCK FOR PDP-6
UNAME:	0		;OUR UNAME
	SIXBIT /PDP6/
11ADR:	0		;PDP11 ADDRESS TO WRITE
TVALUM:	0		;ALU MODE FOR CONSOLE REGISTER
11WRD:	0		;WORD TO WRITE INTO 11 MEMORY
6TASK:	0		;-1=>10 WANTS 6 TO DO SOMETHIN
			;0=>6 BUSY
			;>0=>6 IDLE
6DISP:	0		;ADDRESS OF ROUTINE 6 IS TO EXECUTE
11AC:	0		;ACCUMULATOR
11BITS:	0		;COUNTER FOR 11AC (STARTS AT -40)

;DISPLAY LIST VARIABLES

DMODE:	0		;DISPLAY MODE
DBYTE:	0		;HALF-WORDS IN DISPLAY LIST
DBYTEP:	0		;BYTE POINTER TO LAST HALF-WORD PLACED IN DISPLAY LIST
DBYTEF:	0		;FREE HALF-WORDS IN DISPLAY BUFFER
DSIZE:	0		;SIZE
DBRITE:	0		;BRIGHTNESS

;INCREMENT MODE VARIABLES

IBYTEP:	0		;BYTE POINTER INTO INCREMENT WORD
IBYTEF:	0		;FREE BYTES IN INCREMENT WORD

;CHARACTER MODE VARIABLES

CBYTEP:	0		;BYTE POINTER INTO CHARACTER WORD
CBYTEF:	0		;FREE BYTES IN CHARACTER WORD
CSHIFT:	0		;-1=> SHIFT IN

CIRCP:	0		;NONZERO IF THE CIRC INSTRUCTION WORKS ON THIS MACHINE.

;DISPLAY BUFFER

DPYBUF:	BLOCK DPYBFL

;FREE STORAGE

FREE:	0		;FREE WORDS IN FREE STORAGE
CBLK:	0		;.CBLK WORD OF LAST BLOCK
CORSIZ:	0		;BLOCKS WE HAVE GOT
FSP:	0		;POINTS TO FIRST FREE WORD
FS:	0		;FREE STORAGE STARTS HERE

6LAST==.
ICORE==<FS+1777>_<-12>

END GO
