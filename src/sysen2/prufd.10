TITLE PRUFD
.INSRT SYSENG;DSK:JSF MACROS
.INSRT SYSENG; DSK: FSDEFS >

PROG==0
;0 => PRUFD
;1 => LIST FILES ON PACK

A=1
AA=2
B=3
C=4
D=5
E=6	;POINTER INTO MFD (DON'T CLOBBER)
F=7	;POINTER INTO UFD (DON'T CLOBBER)
T=10
TT=11
P=17

;IO CHANNEL ASSIGNMENTS
LPTC==5
FDRC==6

LPDL==100.	;EXTRA LONG FOR SORT
WPS==LMNBLK		;FOR SORT

BEG:	MOVE P,[-LPDL,,PDL]
	PUSHJ P,PRINI
	.OPEN FDRC,[6,,SIXBIT /   DSKM.F.D.(FILE)/]	;OPEN MFD
	.VALUE
	MOVE A,[-2000,,MFD]
	.IOT FDRC,A
	MOVE A,MFD+MDNAMP	;USER NAME AREA POINTER
	ADDI A,MFD	;RELOCATE TO POINT TO MFD
	MOVEI AA,MFD+2000	;END OF USER NAME AREA IN MFD
	MOVSI B,(SETZ)	;ABOUT TO SORT ON ENTIRE FIELD
	PUSHJ P,SORT	;SORT USER NAMES
	MOVE E,MFD+MDNAMP	;USER NAME AREA POINTER
LUP:	SKIPE A,MFD(E)	;IF USER SLOT NOT EMPTY,
	PUSHJ P,USRHAK	;THEN HACK THIS DIRECTORY
	ADDI E,LMNBLK	;INCREMENT TO NEXT USER
	CAIG E,1776
	JRST LUP
	.CLOSE FDRC,
	PUSHJ P,PRDUN	;DONE
	.VALUE [ASCIZ /./]
	JRST BEG

USRHAK:	.SUSET [.SSNAM,,A]	;SET SYSTEM NAME
	.OPEN FDRC,[6,,SIXBIT /   DSK.FILE.(DIR)/]
	.VALUE
	MOVE A,[-2000,,UFD]
	.IOT FDRC,A
	JRST UDIRHK

MFD:	BLOCK 2000

UFD:	BLOCK 2000

PDL:	BLOCK LPDL+1
IFE PROG,[

		;INITIALIZE

PRINI:	.OPEN LPTC,[1,,SIXBIT /   LPTPRUFD WPAPER/]
	.VALUE		;LPT NOT AVAILABLE
	IRPS NAME,,[USER BLOCKS LINKS]
	MOVE AA,[SIXBIT /NAME/]
	PUSHJ P,SXTYOT
	TERMIN
	REPEAT 2,PUSHJ P,CRLF
	SETZM NFBLKS	;CLEAR TOTAL NUMBER OF BLOCKS
	SETZM TNLKS	;CLEAR TOTAL NUMBER OF LINKS
	POPJ P,
]

	;HACK WITH A USER DIRECTORY
		;WITHIN THIS ROUTINE, F IS A POINTER TO FILE AREA
		;C HAS # BLOCKS THIS USER SO FAR

UDIRHK:	PUSHJ P,UFDINI	;INITIALIZE FOR THIS UFD
	MOVE F,UFD+UDNAMP	;GET NAME AREA POINTER
	ADDI F,UFD	;RELOCATE TO POINT TO ACTUAL ADDRESS
UDHL:	SKIPN (F)	;CHECK THIS ENTRY
	SKIPE 1(F)
	PUSHJ P,HAKFIL	;NON-NULL FILE, HACK IT
	ADDI F,LUNBLK	;INCREMENT TO NEXT NAME BLOCK
	CAIGE F,2000+UFD	;DONE?
	JRST UDHL	;NO, GET NEXT FILE
IFN PROG,JRST UDIRDN	;DONE WITH THIS DIRECTORY
IFE PROG,[
	MOVE T,C	;SAVE TO CHECK FOR "EXCESSIVE " AMOUNT OF DISK SPACE
	MOVE A,C	;GET NUMBER OF BLOCKS THIS USER DIRECTORY
	ADDM A,NFBLKS'	;ADD TO TOTAL BLOCKS
	MOVEI C,3	;NUMBER OF DIGITS
	PUSHJ P,NDTYO	;TYPE OUT NUMBER OF BLOCKS THIS USER
	PUSHJ P,TAB	;TYPE A TAB TO SEPARATE FROM FOLLOWING
	SKIPN A,NLINKS	;GET NUMBER OF LINKS
	JRST .+3
	ADDM A,TNLKS'	;MORE TOTAL LINKS
	PUSHJ P,DECTYO	;TYPE OUT NUMBER OF LINKS
	MOVE A,T
	CAIG A,250.	;DOES THIS GUY HAVE AN "EXCESSIVE" NUMBER OF TRACKS?
	JRST CRLF	;NO
	PUSHJ P,TAB	;YES
	MOVE AA,[SIXBIT /??????/]	;FLAG HIM
	PUSHJ P,SXTYOT	;AS A LOSER!
	JRST CRLF	;END WITH CRLF

UFDINI:	MOVE AA,MFD(E)	;GET SYSTEM NAME AGAIN
	PUSHJ P,SXTYOT	;TYPE IT OUT
	SETZB C,NLINKS	;CLEAR BLOCK COUNT AND LINK COUNT
	POPJ P,
;STILL IN ASSEMBLY CONDITIONAL

		;F POINTS TO FILE, HACK WITH IT

HAKFIL:	MOVE A,UNRNDM(F)	;GET THE "IMPORTANT" WORD DESCRIBING FILE
	TLNN A,UNLINK	;LINK?
	JRST HF2	;NO
	AOS NLINKS'	;YES, ANOTHER LINK
	POPJ P,

		;F POINTS TO REAL FILE (AS OPPOSED TO LINK)

HF2:	ANDI A,17777	;MASK TO CHARACTER ADDRESS OF DESCRIPTION
	IDIVI A,6	;NOW CALCULATE BYTE POINTER
	ADD A,HFBPT(AA)	;GET BYTE POINTER IN A
	ILDB T,A	;GET CHARACTER
	XCT HF2TB(T)	;DO SOMETHING
	TRNE T,40
	IBP A
	AOJA C,.-4	;INCREMENT BLOCK COUNT AND LOOP

		;TABLE OF THINGS TO DO WITH CHARACTERS

HF2TB:	POPJ P,				;0 => DONE
	REPEAT 12.,ADDI C,.RPCNT	;1 - 12. => TAKE THAT MANY (N-1 NOW, 1 LATER)
	REPEAT 30.-13.+1,JFCL		;13. - 30. => TAKE 1
	POPJ P,				;31. => DONE
	REPEAT 40,IBP A			;32. - 63., READ NEXT CHAR. AND TAKE A BLOCK

		;TABLE OF BYTE POINTERS (FOR ILDB'ING) TO DESCRIPTOR AREA

HFBPT:	POINTI 6,UFD+UDDESC

		;DONE

PRDUN:	PUSHJ P,CRLF	;SEPARATE THIS CRUFT FROM PREV. WITH CRLF
	IRPS TYP,,[BLOCKS LINKS]LOC,,[NFBLKS TNLKS]
	MOVE AA,[SIXBIT /TYP/]
	PUSHJ P,SXTYOT
	MOVE A,LOC
	PUSHJ P,DECTYO
	PUSHJ P,CRLF
	TERMIN
	MOVEI A,14
	PUSHJ P,TYO
	.CLOSE LPTC,
	POPJ P,

]	;END IFE PROG, CONDITIONAL

IFE PROG-1,[	;LIST ALL FILES ON PACK

PACK:	-1		;INSERT PACK NUMBER HERE FROM DDT

;ROUTINES:
	;PRINI	;INITIALIZE
	;UFDINI	;INITIALIZE FOR THIS USER DIRECTORY
	;HAKFIL	;PROCESS FILE
	;UDIRDN	;DONE WITH THIS USER DIRECTORY
	;PRDUN	;DONE

PRINI:	SKIPGE PACK	;CHECK PACK NUMBER FOR VALIDITY
NOPACK:	.VALUE		;NO PACK NUMBER SPECIFIED
	.OPEN LPTC,[1,,SIXBIT /   LPTPRUFD WPAPER/]
	.VALUE
	INSIRP PUSHJ P,[PAKTYP TIMTYP PAKTYP]
	JRST CRLF

PAKTYP:	MOVE AA,[SIXBIT /PACK/]
	PUSHJ P,SXTYOT
	MOVE A,PACK
	JRST DECTYO

UFDINI:	SETOM FILCT'	;INITIALIZE FOR USER DIRECTORY: SET SWITCH (MAYBE DON'T PRINT ANYTHING FOR THIS USER)
	POPJ P,

HAKFIL:	LDB T,[UNPKN,,UNRNDM(F)]	;GET PACK NUMBER
	CAME T,PACK	;SKIP IF ON PACK BEING CHECKED
UDIRDN:	POPJ P,		;NOT ON THIS PACK (ALSO ROUTINE FOR DONE WITH THIS DIRECTORY)
	AOSN FILCT
	PUSHJ P,HAKFII	;THIS FIRST RELEVANT FILE THIS DIRECTORY
	MOVE A,UNRNDM(F)
	TLNN A,UNIGFL	;CHECK TO SEE IF FILE REALLY THERE
	SKIPA A,SPACE	;YES
	MOVEI A,"*	;NO
	PUSHJ P,TYO
	MOVE AA,(F)	;FN1
	PUSHJ P,SXTYOT
	MOVE AA,1(F)	;FN2
	PUSHJ P,SXTYOT
	JRST CRLF

HAKFII:	PUSHJ P,CRLF	;EXTRA CRLF TO SEPARATE FROM PREV
	MOVE B,MFD(E)	;SYSTEM NAME THIS USER
	MOVEI C,6	;COUNT
	MOVE AA,B	;GET SYSTEM NAME SO IT CAN BE TYPED OUT
	PUSHJ P,SXTYOT
	SOJG C,.-2
	JRST CRLF

PRDUN:	MOVEI A,14
	PUSHJ P,TYO
	.CLOSE LPTC,
	POPJ P,
]

SXTYOT:	JUMPE AA,TAB
	MOVEI A,0
	LSHC A,6
	ADDI A,40
	PUSHJ P,TYO
	JRST SXTYOT

SPACE:	MOVEI A,40
	JRST TYO

TAB:	MOVEI A,11
	JRST TYO

CRLF:	MOVEI A,15
	PUSHJ P,TYO
	MOVEI A,12
TYO:	.IOT LPTC,A
CPOPJ:	POPJ P,

DECTYO:	MOVEI C,0	;NO MINIMUM NUMBER OF DIGITS
NDTYO:	IDIVI A,10.	;ENTRY TO TYPE LEADING SPACES IF NECESSARY TO FILL TO C(C) CHARACTERS
	JUMPE A,DCTYO3
	HRLM AA,(P)
	PUSHJ P,[SOJA C,NDTYO]
	HLRZ AA,(P)
DCTYO2:	MOVEI A,"0(AA)
	JRST TYO

DCTYO3:	SOJLE C,DCTYO2
	PUSHJ P,SPACE
	JRST DCTYO3

TIMTYP:	PUSHJ P,TAB	;TYPE TIME: BEGIN WITH TAB
	MOVE AA,[SIXBIT /PRUFD./]	;BUT FIRST TYPE VERSION DESCRIPTION
	PUSHJ P,SXTYOT
	MOVE AA,[.FNAM2]	;VERSION #
	PUSHJ P,SXTYOT
	.RDATIM A,	;GET TIME IN A, DATE IN AA
	JUMPL A,CPOPJ	;JUMP IF NOT KNOWN
	PUSH P,A	;SAVE TIME
	PUSHJ P,SXTYOT	;TYPE DATE
	POP P,AA
	JRST SXTYOT	;TYPE TIME AND RETURN

		;SORT THE SYMBOL TABLE
		;A POINTS TO FIRST ENTRY
		;AA POINTS TO LAST ENTRY + 1
		;B HAS ONE BIT SET, THAT BIT MOST SIGNIFICANT BIT TO SORT ON


SORT:
SORT1:	HRLM AA,(P)	;SAVE UPPER BOUND
	CAIL A,-WPS(AA)
	JRST SORT7	;ONE OR ZERO ENTRIES
	PUSH P,A	;SAVE LOWER BOUND
SORT3:	TDNN B,(A)	;BIT SET IN LOWER ENTRY?
	JRST SORT4	;NO, INCREMENT TO NEXT AND MAYBE TRY AGAIN
	SUBI AA,WPS	;YES, NOW BACK UP UPPER POINT	
	TDNE B,(AA)	;BIT CLEAR IN UPPER ENTRY?
	JRST SORT2	;NO, CHECK FOR END, DECREMENT AA, AND TRY AGAIN
REPEAT WPS,[		;BIT SET IN LOWER ENTRY AND CLEAR IN UPPER => EXCHANGE ENTRIES
	MOVE T,.RPCNT(A)
	EXCH T,.RPCNT(AA)
	MOVEM T,.RPCNT(A)
]
SORT4:	ADDI A,WPS	;INCREMENT LOWER BOUND POINTER TO NEXT ENTRY
SORT2:	CAME A,AA	;ANY MORE ENTRIES LEFT?
	JRST SORT3	;YES, GO PROCESS THEM
		;A AND AA NOW BOTH POINT TO FIRST ENTRY WITH BIT SET
	ROT B,-1	;ROTATE BIT INDICATOR TO NEXT (LESS SIGNIFICANT) BIT
	POP P,A		;RESTORE LOWER BOUND OF ENTIRE SORT
	JUMPL B,SORT6	;JUMP IF NO MORE KEY TO SORT ON
	PUSHJ P,SORT1	;SORT BOTTOM PART OF TABLE
	HLRZ AA,(P)	;RESTORE UPPER BOUND (SORT1 CLOBBERED A TO MIDDLE)
	PUSHJ P,SORT1	;SORT TOP PART OF TABLE
SORT6:	ROT B,1		;BACK UP KEY AGAIN SO AS TOO "NOT CLOBBER B"
SORT7:	HLRZ A,(P)	;MAKE A POINT ABOVE TABLE ENTRIES SORTED
	POPJ P,

PATCH:
PAT:	BLOCK 40
PATCHE=.-1

END BEG
