

<PACKAGE "DFL">

"Fast FLOADer for people who use TECO to debug MUDDLE"

<ENTRY DFL RDFL FLO DFL-RETRY UN-DFL>

"Package containing UNLINK, UNPURIFY, PURE?"
<USE "UNLINK">

"Contains READST"
<FLOAD "MUDBUG;DFL CRUFT">

<SETG DFL-BUFLEN 600>

<SETG FILPTR-SAVE 1>
<SETG FILNAM-SAVE 2>
<SETG OBLIST-SAVE 3>

<MANIFEST DFL-BUFLEN FILPTR-SAVE FILNAM-SAVE OBLIST-SAVE>

<SETG 6STRING <ISTRING 6>>

<SETG DFL-BUF <REST <SETG TDFL-BUF <ISTRING <+ ,DFL-BUFLEN 50> !\ >> 50>>

<SETG DFL-ZERO-STR <REST <SETG DFL-FILNAM <ISTRING 40 !\ >> 40>>

<SETG DFL-STRUC <REST <SETG DFL-NAM-SCRATCH <IVECTOR 10 "">> 9>>

<GDECL (TDFL-BUF DFL-BUF DFL-ZERO-STR)
       STRING
       (DFL-FILNAM)
       <OR ATOM STRING>
       (DFL-FUNC-NAM)
       <OR STRUCTURED ATOM>
       (DFL-STRUC)
       <VECTOR [REST <OR STRING FALSE>]>>

<DEFINE DFL ("OPTIONAL" (FUNC-NAME ,DFL-FUNC-NAM) (FILNAM ,DFL-FILNAM)
			(HAIR <>))
	#DECL ((FUNC-NAME) <OR STRUCTURED ATOM> (FILNAM) <OR ATOM STRING>)
	<FDFL .FUNC-NAME .FILNAM .HAIR '["<DEF" ["INE " "MAC "]] <>>>

<DEFINE RDFL ("OPTIONAL" (FUNC-NAME ,DFL-FUNC-NAM) (FILNAM ,DFL-FILNAM)
			 (HAIR <>) (READ2? <AND <ASSIGNED? GLUE> .GLUE>))
	#DECL ((FUNC-NAME) <OR STRUCTURED ATOM> (FILNAM) <OR ATOM STRING>
	       (READ2?) <OR ATOM FALSE>)
	<FDFL .FUNC-NAME .FILNAM .HAIR "<SETG " .READ2?>>

<DEFINE FDFL (FUNC-NAME FILNAM HAIR STR READ2?)
	#DECL ((FUNC-NAME) <OR STRUCTURED ATOM> (FILNAM) <OR ATOM STRING>)
	<COND (<TYPE? .FILNAM ATOM> <SET FILNAM <SPNAME .FILNAM>>)>
	<SETG DFL-FUNC-NAM .FUNC-NAME>
	<SETG DFL-FILNAM .FILNAM>
	<DO-DFL <DFL-SETUP .FUNC-NAME> .FILNAM .STR .HAIR .READ2?>>

<DEFINE DFL-SETUP (FUNC-NAME
		   "AUX" (DFL-STRUC ,DFL-STRUC) (DFL-SCRATCH ,DFL-NAM-SCRATCH)
			 (TL <LENGTH .DFL-SCRATCH>))
   #DECL ((FUNC-NAME) <OR ATOM STRUCTURED> (TL) FIX
	  (DFL-SCRATCH DFL-STRUC) VECTOR)
   <COND
    (<TYPE? .FUNC-NAME ATOM> <PUT .DFL-STRUC 1 <SPNAME .FUNC-NAME>>)
    (<TYPE? .FUNC-NAME STRING> <PUT .DFL-STRUC 1 .FUNC-NAME>)
    (T
     <COND (<G? <LENGTH .FUNC-NAME> .TL>
	    <SET DFL-SCRATCH
		 <SETG DFL-NAM-SCRATCH
		       <IVECTOR <SET TL <+ <LENGTH .FUNC-NAME> 5>> "">>>
	    <SETG DFL-STRUC <REST .DFL-SCRATCH <- .TL 1>>>)>
     <SET DFL-SCRATCH <REST .DFL-SCRATCH <- .TL <LENGTH .FUNC-NAME>>>>
     <MAPR <>
	   <FUNCTION (X Y "AUX" (FOO <1 .Y>)) 
		   #DECL ((X) VECTOR (Y) <STRUCTURED [REST <OR ATOM STRING>]>)
		   <COND (<TYPE? .FOO STRING> <PUT .X 1 .FOO>)
			 (<PUT .X 1 <SPNAME .FOO>>)>>
	   .DFL-SCRATCH
	   .FUNC-NAME>
     .DFL-SCRATCH)>>

<DEFINE DO-DFL (FUNC-NAME FILNAM MEMSTR HAIR READ2?
		"AUX" (CHN <OPEN "READ" .FILNAM>) FUNC-NAMLEN
		      (CHRCNT <- ,DFL-BUFLEN>) TSTR STR (PACKAGE-FLAG <>) FNV
		      (DFL-BUF ,DFL-BUF) (6STR ,6STRING) ATM FORM RFILNAM BEGACC
		      (UNLINK <OR .HAIR <RSUBR-LINK>>))
   #DECL ((FUNC-NAME) <VECTOR [REST <OR FALSE STRING>]> (6STR FILNAM) STRING
	  (CHN) <OR CHANNEL FALSE> (FNV) <OR VECTOR FALSE> (TSTR) STRING
	  (FUNC-NAMLEN CHRCNT) FIX (MEMSTR) <OR STRING VECTOR>
	  (PACKAGE-FLAG) <OR FALSE STRING FIX> (STR) <OR FALSE STRING>
	  (DFL-BUF) STRING (ATM) ATOM (FORM) FORM (READ2? HAIR UNLINK) <OR ATOM FALSE>
	  (RFILNAM) <VECTOR [4 STRING]> (BEGACC) FIX)
   <UNWIND
    <AND
     .CHN
     <SET RFILNAM <VECTOR <7 .CHN> <8 .CHN> <9 .CHN> <10 .CHN>>>
     <REPEAT REPNAM ((ANS ()) (ANS1 ()) CHARS-READ)
       #DECL ((ANS ANS1) <LIST [REST ATOM]> (CHARS-READ) FIX)
       <SET CHRCNT <+ .CHRCNT ,DFL-BUFLEN>>
       <SET TSTR ,TDFL-BUF>
       <SUBSTRUC <REST .DFL-BUF <- ,DFL-BUFLEN 50>> 0 50 .TSTR>
       <SET CHARS-READ <READST .DFL-BUF .CHN>>
       <COND (<NOT .PACKAGE-FLAG>
	      <COND (<AND <SET PACKAGE-FLAG <MEMBER "PACKA" .TSTR>>
			  <SET PACKAGE-FLAG <BACK .PACKAGE-FLAG>>
			  <COND (<==? <1 .PACKAGE-FLAG> !\R>
				 <SET PACKAGE-FLAG <BACK .PACKAGE-FLAG>>)
				(T)>
			  <COND (<N==? <1 .PACKAGE-FLAG> !\<>
				 <SET PACKAGE-FLAG <>>)
				(T)>
			  <NOT <MEMQ <1 <BACK .PACKAGE-FLAG>> ";'">>>
		     <ACCESS .CHN <- ,DFL-BUFLEN <LENGTH .PACKAGE-FLAG>>>
		     <EVAL <READ .CHN>>
		     <PROG ()
			   <SET CHARS-READ <READST .DFL-BUF .CHN>>
			   <COND (<SET PACKAGE-FLAG <MEMBER "ENTRY" .DFL-BUF>>
				  <SET PACKAGE-FLAG <BACK .PACKAGE-FLAG>>
				  <COND (<==? <1 .PACKAGE-FLAG> !\R>
					 <SET PACKAGE-FLAG <BACK .PACKAGE-FLAG>>)>
				  <COND (<OR <N==? <1 .PACKAGE-FLAG> !\<>
					     <MEMQ <1 .PACKAGE-FLAG> ";'">>
					 <RETURN>)>
				  <ACCESS .CHN <+ <- <17 .CHN> .CHARS-READ>
						  <- ,DFL-BUFLEN
						     <LENGTH .PACKAGE-FLAG>>>>
				  <READ .CHN>
				  <AGAIN>)>>
		     <PROG ()
			   <COND (<AND <SET PACKAGE-FLAG
					    <MEMBER "<USE" <REST .DFL-BUF>>>
				       <OR <==? <5 .PACKAGE-FLAG> !\ >
					   <MEMBER <SUBSTRUC .PACKAGE-FLAG 4 6 .6STR>
						   '["-TOTAL" "-DEFER"]>>>
				  <ACCESS .CHN <+ <- <17 .CHN> .CHARS-READ>
						  <- ,DFL-BUFLEN
						     <LENGTH .PACKAGE-FLAG>>>>
				  <EVAL <READ .CHN>>
				  <SET CHARS-READ <READST .DFL-BUF .CHN>>
				  <AGAIN>)>
			   <SET PACKAGE-FLAG "">>)
		    (<SET PACKAGE-FLAG 0>)>)>
       <PROG ()
	 <AND
	  <COND (<OR <AND <NOT <SET STR <SUBSTRING-SEARCH .MEMSTR .TSTR>>>
			  <L? .CHARS-READ ,DFL-BUFLEN>>
		     <AND .STR <L? <LENGTH .STR> <- ,DFL-BUFLEN .CHARS-READ>>>>
		 <PROG ()
		       <CLOSE .CHN>
		       <AND <TYPE? .PACKAGE-FLAG STRING> <ENDPACKAGE>>
		       <AND .UNLINK <NOT <EMPTY? .ANS1>> <UNLINK .ANS1 .HAIR>>
		       <RETURN <CHTYPE (EOF-FOUND-BEFORE-THESE
					!<MAPF ,LIST
					       <FUNCTION (X) <OR .X <MAPRET>>>
					       .FUNC-NAME>)
				       FALSE>
			       .REPNAM>>)
		(T)>
	  .STR
	  <NOT <LENGTH? .STR 40>>
	  <SET FUNC-NAMLEN <- <LENGTH .STR>
			      <REPEAT ((S .STR))
			        <COND (<MEMQ <1 .S> %<STRING <ASCII 32> ;"Char Space"
							     <ASCII 9> ;"Char Tab"
							     <ASCII 13> ;"Char C.R.">>
				       <RETURN <LENGTH .S>>)>
				<COND (<EMPTY? <SET S <REST .S>>>
				       <RETURN 0>)>>>>
	  <COND
	   (<AND <SET FNV
		      <MEMBER <SUBSTRUC .STR
					0
					.FUNC-NAMLEN
					<BACK ,DFL-ZERO-STR .FUNC-NAMLEN>>
			      .FUNC-NAME>>
		 <NOT <MEMQ <1 <BACK .STR 9>> ";'">>>
	    <ACCESS .CHN
		    <SET BEGACC <+ .CHRCNT <- ,DFL-BUFLEN <LENGTH .STR> 8>>>>
	    <SET ATM <2 <SET FORM <READ .CHN>>>>
	    <COND (<AND .UNLINK
			<GASSIGNED? .ATM>
			<TYPE? ,.ATM RSUBR RSUBR-ENTRY>>
		   <SET ANS1 (.ATM !.ANS1)>)
		  (<SET ANS (.ATM !.ANS)>)>
	    <EVAL .FORM>
	    <PUTPROP .ATM
		     DFL
		     <VECTOR <PUTBITS <17 .CHN> <BITS 18 18> .BEGACC> .RFILNAM .OBLIST>>
	    <PUT .FNV 1 <>>
	    <COND (<AND .READ2?
			<TYPE? ,.ATM RSUBR>>
		   <EVAL <READ .CHN>>)>
	    <COND (<OR? !.FUNC-NAME>
		   <ACCESS .CHN <+ .CHRCNT ,DFL-BUFLEN>>
		   <AGAIN>)
		  (T
		   <AND <TYPE? .PACKAGE-FLAG STRING> <ENDPACKAGE>>
		   <CLOSE .CHN>
		   <AND .UNLINK <NOT <EMPTY? .ANS1>> <UNLINK .ANS1 .HAIR>>
		   <COND (<NOT <EMPTY? .ANS1>>
			  <PUTREST <REST .ANS1 <- <LENGTH .ANS1> 1>> .ANS>
			  <SET ANS .ANS1>)>
		   <RETURN .ANS .REPNAM>)>)
	   (<SET TSTR .STR> <AGAIN>)>>>>>
    <CLOSE .CHN>>>

<DEFINE SUBSTRING-SEARCH SS (MEMSTR STR "AUX" TSTR TARG)
  #DECL ((TSTR) <OR FALSE STRING> (TARG) STRING
	 (STR) STRING (MEMSTR) <OR STRING <VECTOR STRING VECTOR>>)
  <COND (<TYPE? .MEMSTR STRING>
	 <COND (<SET TSTR <MEMBER .MEMSTR .STR>>
		<REST .TSTR <LENGTH .MEMSTR>>)>)
	(<SET TSTR <MEMBER <SET TARG <1 .MEMSTR>> .STR>>
	 <SET TSTR <REST .TSTR <LENGTH .TARG>>>
	 <MAPF <>
	   <FUNCTION (SECOND "AUX" TEMP (RT .TSTR))
	     #DECL ((RT SECOND) STRING)
	     <REPEAT ()
	       <COND (<==? <1 .SECOND> <1 .RT>>
		      <SET RT <REST .RT>>
		      <COND (<EMPTY? <SET SECOND <REST .SECOND>>>
			     <RETURN .RT .SS>)>)
		     (<RETURN>)>>>
	   <2 .MEMSTR>>
	 <>)>>

<SETG BEGPTR 1>

<SETG ENDPTR 2>

<SETG NAMPTR 3>

<SETG FILPTR 4>

<SETG ASSOCI 5>

<SETG OBLPTR 6>

<SETG SLEN 6>

<MANIFEST BEGPTR ENDPTR NAMPTR FILPTR ASSOCI OBLPTR SLEN>

<SETG TV <IVECTOR ,SLEN>>

<PUT UNTUPL
     DECL
     '<TUPLE [REST FIX FIX ATOM <VECTOR [4 STRING]> <VECTOR FIX VECTOR>
	      <OR OBLIST <LIST [REST OBLIST]>>]>>

<DEFINE UN-DFL UNACT (ATMS
		      "OPTIONAL" (FILNAM <>) (FORCE <>)
		      "AUX" (FOOTOP
			     <ITUPLE <COND (<TYPE? .ATMS ATOM> ,SLEN)
					   (T <* <LENGTH .ATMS> ,SLEN>)>>)
			    (FOOBOT <REST .FOOTOP <LENGTH .FOOTOP>>) FOO FOOSAV
			    FILP OCH ICH NEWFIL (LOSERS ()) NM1 NM2 SNM DEV)
	#DECL ((ATMS) <OR ATOM <LIST [REST ATOM]>>
	       (NEWFIL FILP) <VECTOR [4 STRING]>
	       (FILNAM) <OR FALSE STRING <VECTOR [REST STRING]>>
	       (LOSERS) <LIST [REST ATOM]> (FOO FOOSAV) UNTUPL (FOOTOP) TUPLE
	       (OCH ICH) <OR FALSE CHANNEL> (FORCE) <OR ATOM FALSE>
	       (FOOBOT) <OR TUPLE FALSE> (NM1 NM2 SNM DEV) <SPECIAL STRING>)
	<COND (<TYPE? .ATMS ATOM>
	       <COND (<SET FOOBOT <UNSET .ATMS .FOOBOT>> <SET FOO .FOOBOT>)
		     (<RETURN <CHTYPE ("Not DFLed?" .ATMS) FALSE> .UNACT>)>)
	      (T
	       <MAPF <>
		     <FUNCTION (X "AUX" TEMP) 
			     #DECL ((X) ATOM (TEMP) <OR FALSE UNTUPL>)
			     <COND (<SET TEMP <UNSET .X .FOOBOT>>
				    <SET FOO .TEMP>)
				   (T <SET LOSERS (.X !.LOSERS)>)>>
		     .ATMS>
	       <COND (<G? <LENGTH .ATMS> 1> <DO-SORT .FOO>)>)>
	<SET FOOSAV .FOO>
	<SET FILP <FILPTR .FOO>>
	<SET SNM <4 .FILP>>
	<SET DEV "DSK">
	<SET FN1 <1 .FILP>>
	<SET FN2 <2 .FILP>>
	<OR .FILNAM <SET FILNAM .FILP>>
	<COND (<TYPE? .FILNAM STRING>
	       <COND (<SET OCH <OPEN "READ" .FILNAM>>
		      <CLOSE .OCH>
		      <SET DEV <9 .OCH>>
		      <SET SNM <10 .OCH>>)>)
	      (T
	       <AND <SET OCH
			 <OPEN "READ" <1 .FILNAM> ">" <3 .FILNAM> <4 .FILNAM>>>
		    <CLOSE .OCH>>)>
	<COND (<SET ICH <OPEN "READ" !<FILPTR .FOO!>>>
	       <COND (<OR .FORCE
			  <NOT .OCH>
			  <N=? <9 .ICH> <9 .OCH>>
			  <N=? <10 .ICH> <10 .OCH>>
			  <N=? <7 .ICH> <7 .OCH>>
			  <=? <8 .ICH> <8 .OCH>>>)
		     (<RETURN <CHTYPE ("Would destroy later version!"
				       <STRING <9 .ICH>
					       !\:
					       <10 .ICH>
					       !\;
					       <7 .ICH>
					       !\ 
					       <8 .ICH>>
				       <STRING <9 .OCH>
					       !\:
					       <10 .OCH>
					       !\;
					       <7 .OCH>
					       !\ 
					       <8 .OCH>>)
				      FALSE>
			      .UNACT>)>
	       <SET OCH <OPEN "PRINT" "_DFL >">>
	       <REPEAT (NEWBEG ATM VAL (OUTCHAN .OCH) OBLIST)
		       #DECL ((OUTCHAN) <SPECIAL CHANNEL>
			      (OBLIST) <SPECIAL ANY>)
		       <COND (<EMPTY? .FOO>
			      <COPY-TO-CHR .ICH .OCH <FILE-LENGTH .ICH>>
			      <CLOSE .ICH>
			      <COND (<TYPE? .FILNAM STRING>
				     <RENAME .OCH .FILNAM>)
				    (<RENAME .OCH
					     <1 .FILNAM>
					     ">"
					     <3 .FILNAM>
					     <4 .FILNAM>>)>
			      <SET NEWFIL
				   <VECTOR <7 .OCH>
					   <8 .OCH>
					   <9 .OCH>
					   <10 .OCH>>>
			      <CLOSE .OCH>
			      <RETURN>)>
		       <SET OBLIST <OBLPTR .FOO>>
		       <COPY-TO-CHR .ICH .OCH <BEGPTR .FOO>>
		       <SET NEWBEG <17 .OCH>>
		       <EPRIN1 <COND (<TYPE? <SET VAL ,<SET ATM <NAMPTR .FOO>>>
					     FUNCTION>
				      <CHTYPE (DEFINE .ATM !.VAL) FORM>)
				     (<FORM SETG .ATM .VAL>)>>
		       <CRLF .OCH>
		       <CRLF .OCH>
		       <ACCESS .ICH <ENDPTR .FOO>>
		       <PUT <ASSOCI .FOO>
			    1
			    <CHTYPE <PUTBITS <17 .OCH> <BITS 18 18> .NEWBEG>
				    FIX>>
		       <SET FOO <REST .FOO ,SLEN>>>
	       <REPEAT ((FOO .FOOSAV))
		       #DECL ((FOO) UNTUPL)
		       <COND (<EMPTY? .FOO> <RETURN>)
			     (<PUT <ASSOCI .FOO> 2 .NEWFIL>
			      <SET FOO <REST .FOO ,SLEN>>)>>
	       <COND (<NOT <EMPTY? .LOSERS>>
		      <CHTYPE ("Not DFLed?" !.LOSERS) FALSE>)
		     (.ATMS)>)>>

<DEFINE UNSET (ATM TUP "AUX" (AS <GETPROP .ATM DFL>)) 
	#DECL ((ATM) ATOM (TUP) TUPLE (AS) <OR FALSE <VECTOR FIX VECTOR>>
	       (VALUE) <OR FALSE UNTUPL>)
	<COND (.AS
	       <PUT <SET TUP <BACK .TUP ,SLEN>> ,NAMPTR .ATM>
	       <PUT .TUP ,ASSOCI .AS>
	       <PUT .TUP ,BEGPTR <CHTYPE <GETBITS <FILPTR-SAVE .AS> <BITS 18 18>> FIX>>
	       <PUT .TUP ,ENDPTR <CHTYPE <GETBITS <FILPTR-SAVE .AS> <BITS 18 0>> FIX>>
	       <PUT .TUP ,FILPTR <FILNAM-SAVE .AS>>
	       <PUT .TUP ,OBLPTR <OBLIST-SAVE .AS>>)>>

<DEFINE COPY-TO-CHR (ICH OCH CT "AUX" (BUF ,DFL-BUF) (INC <- .CT <17 .ICH>>) TINC) 
	#DECL ((ICH OCH) CHANNEL (TINC INC CT) FIX (BUF) STRING)
	<REPEAT ()
		<SET TINC <READSTRING .BUF .ICH <MIN .INC ,DFL-BUFLEN>>>
		<PRINTSTRING .BUF .OCH .TINC>
		<COND (<L=? <SET INC <- .INC ,DFL-BUFLEN>> 0> <RETURN>)>>>

<DEFINE DO-SORT (TUP "AUX" (TV ,TV)) 
	#DECL ((TUP) UNTUPL)
	<REPEAT ((X .TUP) (Y <REST .TUP ,SLEN>) (NEWL <>))
		<COND (<G? <BEGPTR .X> <BEGPTR .Y>>
		       <SUBSTRUC .X 0 ,SLEN .TV>
		       <SUBSTRUC .Y 0 ,SLEN .X>
		       <SUBSTRUC .TV 0 ,SLEN .Y>
		       <SET NEWL T>)>
		<COND (<EMPTY? <SET Y <REST .Y ,SLEN>>>
		       <COND (.NEWL
			      <SET X .TUP>
			      <SET Y <REST .TUP ,SLEN>>
			      <SET NEWL <>>)
			     (<RETURN>)>)
		      (T <SET X <REST .X ,SLEN>>)>>>

<ENDPACKAGE>
