
<PACKAGE "UNASSM">

<ENTRY UNASSEMBLE GROUP-CONVERT CONVERT-RSUBR DUMP-U>

<BLOCK (<ROOT>)>

<SET GLUE T>

MUDREF 

<ENDBLOCK>

<SETG RWH <BITS 18>>

<SETG LHW <BITS 18 18>>

<SETG TYPBYT <CHTYPE <BITS 13 18> FIX>>

<NEWTYPE MUDREF WORD>

<NEWTYPE SPEC-LABEL WORD>

<FLOAD "MUDDLE;MUDHAK >">

<BEGIN-MHACK>

<FLOAD "BTB;NEW VECS">

<SETG NDO <BITS 1 0>>

<SETG JMP <BITS 1 1>>

<SETG IMM <BITS 1 2>>

<SETG JSR-LCKINT <CHTYPE <ORB #WORD *264000000000* <SQUOTA |LCKINT >> FIX>>

<SETG SKIPGE-INTFLG <CHTYPE <ORB #WORD *335000000000* <SQUOTA |INTFLG >> FIX>>

<GDECL (INSTRUCTION-VEC) VECTOR>

<GDECL (BITS-VEC ACS ADDR-ACS) UVECTOR>

<GDECL (JSR-LCKINT SKIPGE-INTFLG) FIX>

<SETG SPEC-ATOM 10485759>

<MANIFEST NDO JMP IMM SPEC-ATOM>

<USE "SQUOZE" "SORTX">

<SETG $TLOSE <SQUOTA <SQUOZE "$TLOSE">>>

<SETG $TLOSEHI <+ ,$TLOSE <LENGTH <ALLTYPES>>>>

<PRINTTYPE MUDREF ,OUTPUT-MUDREF>

<SETG UUOTOP 64>

<SETG 9BIT <BITS 9 27>>

<SETG ACF <BITS 4 23>>

<SETG @BIT <BITS 1 22>>

<SETG IDF <BITS 4 18>>

<SETG RHW <BITS 18 0>>

<MANIFEST UUOTOP 9BIT ACF @BIT IDF RHW LHW TYPBYT>

<GDECL ($TLOSE $TLOSEHI) FIX>

\ 

"HERE TO ESTABLISH THE ACS"

<PROG ((CNT 0))
      <MAPF <>
	    <FUNCTION (AC) <SETG .AC .CNT> <SET CNT <+ .CNT 1>>>
	    '![AC-O AC-A AC-B AC-C AC-D AC-E AC-PVP AC-TVP AC-SP AC-AB AC-TB
	       AC-TP AC-FRM AC-M AC-R AC-P!]>>

<MANIFEST AC-O
	  AC-A
	  AC-B
	  AC-C
	  AC-D
	  AC-E
	  AC-PVP
	  AC-TVP
	  AC-FRM
	  AC-AB
	  AC-TB
	  AC-TP
	  AC-SP
	  AC-M
	  AC-R
	  AC-P>

<SETG ADDR-ACS ![O A B C D E PVP TVP SP AB TB TP FRM M R P!]>

<SETG ACS ![O* A* B* C* D* E* PVP* TVP* SP* AB* TB* TP* FRM* M* R* P*!]>

<SETG SPEC-HACKERS
      '(|CIVEC 
	|CIUVEC 
	|CTYPEQ 
	|CSBSTR 
	|CISTNG 
	|CMIN 
	|CMAX 
	|IILIST 
	|IIFORM 
	|CMINUS 
	|CDIVID 
	|CPLUS 
	|CTIMES )>

<GDECL (SPEC-HACKERS) LIST>

\ 

<DEFINE PRINT-INST (INST "AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((INST) STRING (OUTCHAN) CHANNEL)
	<PRINC .INST>
	<PRINC !\	>>

<DEFINE FIN-INST (FLG CNT "AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((FLG) ANY (CNT) FIX (OUTCHAN) CHANNEL)
	<PRINC ">">
	<COND (.FLG <COMMENT-START> <PRIN1 .CNT>)>>

<DEFINE M? (WD) #DECL ((WD) <PRIMTYPE WORD>) <==? <CHTYPE .WD FIX> ,AC-M>>

<DEFINE R? (WD) #DECL ((WD) <PRIMTYPE WORD>) <==? <CHTYPE .WD FIX> ,AC-R>>

<DEFINE JUMP? (WD "AUX" XX) 
	#DECL ((WD) <PRIMTYPE WORD>)
	<SET XX <CHTYPE .WD FIX>>
	<AND <NOT <0? .XX>>
	     <1? <CHTYPE <GETBITS <NTH ,BITS-VEC .XX> ,JMP> FIX>>>>

<DEFINE UUO? (WD "AUX" XX) 
	#DECL ((WD) <PRIMTYPE WORD>)
	<SET XX <CHTYPE .WD FIX>>
	<AND <NOT <0? .WD>> <L? .XX ,UUOTOP>>>

<DEFINE INSTRUCTION? (WD "AUX" XX) 
	#DECL ((WD) <PRIMTYPE WORD>)
	<SET XX <CHTYPE .WD FIX>>
	<AND <NOT <0? .XX>> <NTH ,INSTRUCTION-VEC .XX>>>

<DEFINE PASS-1 (MVEC "AUX" (LST ())) 
	#DECL ((MVEC) <PRIMTYPE UVECTOR>)
	<MAPF <>
	      <FUNCTION (INST
			 "AUX" (INWD <CHTYPE <GETBITS .INST ,9BIT> FIX>)
			       (INDX <CHTYPE <GETBITS .INST ,IDF> FIX>)
			       (INDEX <CHTYPE <GETBITS .INST ,RHW> FIX>))
		      #DECL ((INWD INDX INDEX) <PRIMTYPE WORD>)
		      <COND (<AND <M? .INDX>
				  <OR <JUMP? .INWD>
				      <NOT <INSTRUCTION? .INWD>>
				      <IMMEDIATE? .INWD>>>
			     <COND (<NOT <MEMQ .INDEX .LST>>
				    <SET LST
					 (<MAKE-LABEL>
					  <CHTYPE .INDEX FIX>
					  <>
					  !.LST)>)>)>>
	      .MVEC>
	<SORT <> [!.LST] 3 1>>

<DEFINE INIT-INST (CNT LABELS "AUX" RPTR) 
	#DECL ((CNT) FIX (LABELS) VECTOR (STACK-SIZE) FIX)
	<TERPRI>
	<COND (<SET RPTR <SPEC-MEMQ .CNT .LABELS>>
	       <PRINC <1 .RPTR>>
	       <COND (<3 .RPTR> <SET STACK-SIZE <3 .RPTR>>)>)>
	<PRINC "	<">
	.RPTR>

<DEFINE PRINT-ACF (AC INST) 
	#DECL ((INST AC) <PRIMTYPE WORD>)
	<COND (<OR <NOT <0? <CHTYPE .AC FIX>>> <NOT <NDV? .INST>>>
	       <PRINC <NTH ,ACS <+ <CHTYPE .AC FIX> 1>>>
	       <PRINC " ">)>>

<DEFINE PRINT-INDEX-AC (AC) 
	#DECL ((AC) <PRIMTYPE WORD>)
	<AND <NOT <0? <CHTYPE .AC FIX>>>
	     <PRINC "(">
	     <PRINC <NTH ,ADDR-ACS <+ <CHTYPE .AC FIX> 1>>>
	     <PRINC ") ">>>

<DEFINE ADDR-AC (AC) 
	#DECL ((AC) <PRIMTYPE WORD>)
	<PRINC <NTH ,ADDR-ACS <+ <CHTYPE .AC FIX> 1>>>>

<DEFINE PRINT-NUMB (NUM) 
	#DECL ((NUM) <PRIMTYPE WORD>)
	<OR <SUBR-PRINT .NUM>
	    <PROG ()
		  <OCTAL-PRINT <CHTYPE .NUM FIX>>
		  <PRINC " ">>>>

<DEFINE PRINT-MVAL (MVEC INDEX LABLS INST
		    "AUX" NAME (XX <CHTYPE <NTH .MVEC <+ .INDEX 1>> FIX>) LH)
	#DECL ((MVEC) <PRIMTYPE UVECTOR> (INDEX INST) <PRIMTYPE WORD>
	       (LABLS) VECTOR)
	<COND (<AND <IMMEDIATE? .INST> <SET NAME <SPEC-MEMQ1 .INDEX .LABLS>>>
	       <PRINC .NAME>)
	      (ELSE
	       <PRINC "[">
	       <COND (<==? .XX ,SPEC-ATOM> <PRINC "<(%<TYPE-CODE ATOM>) -1>">)
		     (<AND <L? .XX 262144>
			   <OR <0? <SET LH <CHTYPE <GETBITS .XX ,LHW> FIX>>>
			       <==? .LH 262143>>>
		      <OCTAL-PRINT .XX>)
		     (<PRINC "<"> <NUMBER-PRINT .XX> <PRINC ">">)>
	       <PRINC "]">)>>

<DEFINE PRINT-R (RVEC INDEX FLAG "AUX" ITEM (OUTCHAN .OUTCHAN)) 
	#DECL ((RVEC) <PRIMTYPE VECTOR> (INDEX) <PRIMTYPE WORD>
	       (OUTCHAN) CHANNEL (FLAG) <OR FALSE ATOM>)
	<COND (.FLAG
	       <PRINC "<MQUOTE ">
	       <PRIN1 <NTH .RVEC <+ </ .INDEX 2> 1>>>
	       <PRINC ">">
	       <COND (<0? <CHTYPE <ANDB .INDEX 1> FIX>> <PRINC " -1">)>)
	      (<SET ITEM <NTH .RVEC <+ </ .INDEX 2> 1>>>
	       <COND (<TYPE? .ITEM RSUBR RSUBR-ENTRY> <PRINC <2 .ITEM>>)
		     (<PRINC .ITEM>)>)>>

<DEFINE NUMBER-PRINT (NUMBER "AUX" X1 X2 (OUTCHAN .OUTCHAN)) 
	#DECL ((NUMBER X1 X2) <PRIMTYPE WORD> (OUTCHAN) CHANNEL)
	<SET X1 <CHTYPE <GETBITS .NUMBER ,LHW> FIX>>
	<SET X2 <CHTYPE <GETBITS .NUMBER <BITS 18 0>> FIX>>
	<COND (<AND <==? .X1 262143> <G? .NUMBER -200000>> <PRIN1 .NUMBER>)
	      (ELSE
	       <COND (<NOT <0? .X1>>
		      <PRINC "(">
		      <OCTAL-PRINT .X1 <==? .X1 .X2>>
		      <PRINC ") ">)>
	       <OCTAL-PRINT .X2 <==? .X1 .X2>>)>>

<DEFINE STANDARD-PRINT (AC ATSIGN NAME INST
			"OPTIONAL" (INDX-AC 0)
			"AUX" (OUTCHAN .OUTCHAN))
	#DECL ((OUTCHAN) CHANNEL (AC INST) <PRIMTYPE WORD> (NAME) ANY)
	<PRINT-ACF .AC .INST>
	<COND (.ATSIGN <PRINC "@ ">)>
	<PRINT-INDEX-AC .INDX-AC>
	<PRINC .NAME>>

<DEFINE MAKE-LABEL ("AUX" XX) <CHTYPE <SET LABNUM <+ .LABNUM 1>> SPEC-LABEL>>

<DEFINE PRINT-LABEL (N "AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((N) <PRIMTYPE WORD>)
	<PRINC "TAG">
	<PRIN1 <CHTYPE .N FIX>>>

<PRINTTYPE SPEC-LABEL ,PRINT-LABEL>

<DEFINE GET-SUBR (ADDR "OPTIONAL" (MCL? <>) "AUX" NITEM) 
	#DECL ((ADDR) FIX)
	<AND <NOT <0? .ADDR>>
	     <COND (<SET NITEM <MUDOBJ .ADDR>>
		    <COND (.MCL? <GET-MUDDLE-SUBR .ADDR>)
			  (<CHTYPE .NITEM MUDREF>)>)
		   (<SET NITEM <MUDOBJ <- .ADDR 1>>>
		    <CHTYPE (<CHTYPE .NITEM MUDREF> 1) SPEC-SUBR>)>>>

<DEFINE ATSIGN? (WD) 
	#DECL ((WD) <PRIMTYPE WORD>)
	<1? <CHTYPE <GETBITS .WD ,@BIT> FIX>>>

<DEFINE SPEC-MEMQ (CNT LABELS) 
	#DECL ((CNT) FIX (LABELS) VECTOR)
	<REPEAT (IT)
		<COND (<EMPTY? .LABELS> <RETURN <>>)>
		<SET IT <2 .LABELS>>
		<COND (<==? .IT .CNT> <RETURN .LABELS>)
		      (<G? .IT .CNT> <RETURN <>>)
		      (<SET LABELS <REST .LABELS 3>>)>>>

<DEFINE SPEC-MEMQ1 (CNT LABELS "AUX" LAB) 
	#DECL ((CNT) FIX (LABELS) VECTOR)
	<COND (<SET LAB <SPEC-MEMQ .CNT .LABELS>> <1 .LAB>)>>

<DEFINE OCTAL-PRINT (NUM
		     "OPTIONAL" (DEC <>)
		     "AUX" (BYTNO 15) (OUTCHAN .OUTCHAN))
   #DECL ((NUM BYTNO) <PRIMTYPE WORD> (OUTCHAN) CHANNEL (DEC) <OR ATOM FALSE>)
   <COND (<SUBR-PRINT .NUM>)
	 (<L? .NUM 8> <PRIN1 .NUM>)
	 (<G? .NUM 261632> <PRIN1 <CHTYPE <PUTBITS .NUM <BITS 18 18> -1> FIX>>)
	 (<COND
	   (.DEC <PRIN1 .NUM>)
	   (ELSE
	    <PRINC !\*>
	    <REPEAT ()
		    <COND (<0? <CHTYPE <GETBITS .NUM <BITS 3 .BYTNO>> FIX>>
			   <SET BYTNO <- .BYTNO 3>>
			   <COND (<L? .BYTNO 0> <PRINC !\0> <RETURN>)>)
			  (<RETURN>)>>
	    <REPEAT ()
		    <COND (<L? .BYTNO 0> <RETURN>)>
		    <PRIN1 <CHTYPE <GETBITS .NUM <BITS 3 .BYTNO>> FIX>>
		    <SET BYTNO <- .BYTNO 3>>>
	    <PRINC !\*>)>)>>

<DEFINE PRINT-ATSIGN (FLG) 
	#DECL ((FLAG) <OR FALSE ATOM>)
	<COND (.FLG <PRINC "@ ">)>>

<DEFINE IMMEDIATE? (WRD) 
	#DECL ((WRD) FIX)
	<AND <NOT <0? .WRD>>
	     <1? <CHTYPE <GETBITS <NTH ,BITS-VEC .WRD> ,IMM> FIX>>>>

<DEFINE NDV? (WRD) 
	#DECL ((WRD) FIX)
	<AND <NOT <0? .WRD>>
	     <1? <CHTYPE <GETBITS <NTH ,BITS-VEC .WRD> ,NDO> FIX>>>>

<DEFINE SUBR-PRINT (NUM "AUX" NAME) 
	#DECL ((NUM) <PRIMTYPE WORD>)
	<COND (<AND <G? .NUM 128000>
		    <L? .NUM 261632>
		    <SET NAME <GET-SUBR .NUM>>>
	       <PRINC .NAME>)>>

<NEWTYPE SPEC-SUBR LIST>

<DEFINE SPEC-SUBR-PRINT (LST "AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((LST) SPEC-SUBR)
	<PRINC <1 .LST>>
	<PRINC <2 .LST>>>

<PRINTTYPE SPEC-SUBR ,SPEC-SUBR-PRINT>

<SETG TABS		   ;"The n'th element is a string of n-1 tab characters"
      <PROG ((I -1))
	    <IVECTOR 15 '<ISTRING <SET I <+ .I 1>> !\	>>>>

<SETG SPACES		 ;"The n'th element is a string of n-1 space characters"
      <PROG ((I -1))
	    <IVECTOR 8 '<ISTRING <SET I <+ .I 1>> !\ >>>>

<MANIFEST TABS SPACES>

<DEFINE INDENT-TO (N "OPTIONAL" (OUTC .OUTCHAN) "EXTRA" (NOW <LINPOS .OUTC>))
				   ;"Print tabs and spaces to get to column -n-"
	#DECL ((N NOW) FIX (OUTC) <CHANNEL [12 ANY] [4 FIX]>)
	<COND (<G? .N .NOW>
	       <PRINC <NTH ,TABS <MIN 15 <- </ .N 8> </ .NOW 8> -1>>>
		      .OUTC>
	       <PRINC <NTH ,SPACES <- .N <LINPOS .OUTC> -1>> .OUTC>)>>


\ 

"VARIOUS SPECIAL VARIABLES USED FOR STACK HACKERS."

"STACK-SIZE == CURRENT STACK SIZE"

"LAST-A == LAST X IN <MOVEI A* X>"

"LAST-0 == LAST X IN <MOVEI O* X>"

"LAST-P == LAST X IN <PUSH P* [X]>"

"STARTING-INSTRUCTION == WHERE TO START HACKING"

<DEFINE STACK-HANDLER EXIT (INSTRUCTION AC MVEC RVEC INDEX INDEX-AC CNT
			    "AUX" ITMS (OUTCHAN .OUTCHAN) MUDRF)
	#DECL ((INSTRUCTION) STRING (MVEC PTR) <PRIMTYPE UVECTOR>
	       (INDEX STARTING-INSTRUCTION STACK-SIZE INDEX-AC AC CNT) FIX
	       (OUTCHAN) CHANNEL)
	<COND (<L? .CNT .STARTING-INSTRUCTION> <RETURN T .EXIT>)>
	<COND (<==? .INDEX-AC ,AC-TP>
	       <COMMENT-START>
	       <PRINC "(">
	       <PRIN1 <+ .STACK-SIZE <HRRE .INDEX> -1>>
	       <PRINC ")">)
	      (<OR <==? .INDEX-AC ,AC-TB> <==? .INDEX-AC ,AC-FRM>>
	       <COMMENT-START>
	       <PRINC "(">
	       <OCTAL-PRINT .INDEX T>
	       <PRINC ")">)>
	<COND
	 (<=? .INSTRUCTION "MOVEI">
	  <COND (<==? .AC ,AC-A> <SET LAST-A .INDEX>)
		(<==? .AC ,AC-O> <SET LAST-O .INDEX>)>)
	 (<AND <=? .INSTRUCTION "SUB"> <=? .AC ,AC-TP> <==? .INDEX-AC ,AC-M>>
	  <SET STACK-SIZE
	       <- .STACK-SIZE
		  <CHTYPE <GETBITS <NTH .MVEC <+ .INDEX 1>> ,RHW> FIX>>>)
	 (<=? .INSTRUCTION "PUSH">
	  <COND (<==? .AC ,AC-TP>
		 <SET STACK-SIZE <+ .STACK-SIZE 1>>
		 <COMMENT-START>
		 <PRINC "[">
		 <PRIN1 <- .STACK-SIZE 1>>
		 <PRINC "]">)
		(<AND <==? .AC ,AC-P> <==? .INDEX-AC ,AC-M>>
		 <SET LAST-P <NTH .MVEC <+ .INDEX 1>>>)>)
	 (<=? .INSTRUCTION "MCALL"> <SET STACK-SIZE <- .STACK-SIZE <* .AC 2>>>)
	 (<=? .INSTRUCTION "PUSHJ">
	  <COND (<==? .INDEX-AC 0>
		 <COND (<MEMQ <SET MUDRF <GET-SUBR .INDEX>> ,SPEC-HACKERS>
			<SET STACK-SIZE <- .STACK-SIZE <* .LAST-A 2>>>)
		       (<OR <==? .MUDRF |MAKTUP > <==? .MUDRF |MAKTU2 >>
			<SET STACK-SIZE <+ .STACK-SIZE 2>>)
		       (<==? .MUDRF |NTPALO >
			<SET STACK-SIZE <+ .STACK-SIZE .LAST-O>>)
		       (<==? .MUDRF |CIPUT > <SET STACK-SIZE <- .STACK-SIZE 2>>)
		       (<==? .MUDRF |IUNWIN >
			<SET STACK-SIZE <+ .STACK-SIZE 10>>)
		       (<AND <==? .MUDRF |RCALL >
			     <OR <==? <SET MUDRF <GET-SUBR .LAST-O>> |SEGLST >
				 <==? .MUDRF |SEGMNT >>>
			<SET STACK-SIZE <- .STACK-SIZE <* .LAST-P 2>>>
			<SET LAST-A 0>)>)
		(<AND <==? .INDEX-AC ,AC-M> <SET ITMS <LOOK-ITEM .INDEX>>>
		 <SET STACK-SIZE <- .STACK-SIZE <* .ITMS 2>>>)>)>>

<DEFINE COMMENT-START ("AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((OUTCHAN) CHANNEL)
	<COND (<NOT .COM-FLG> <INDENT-TO 60> <PRINC ";"> <SET COM-FLG T>)>
	<PRINC " ">>

<DEFINE HACK-GLUE-BITS (RSUBR "AUX" (MVEC <1 .RSUBR>) GBITS LEN (MIN-INST 0)) 
	#DECL ((RSUBR) RSUBR (MVEC GBITS) <PRIMTYPE UVECTOR>
	       (LEN MIN-INST STARTING-INSTRUCTION) FIX)
	<SET GBITS <GET .RSUBR GLUE>>
	<SET LEN
	     </ <+ <- <SET LEN <LENGTH .MVEC>>
		      <CHTYPE <GETBITS <SET LEN <CHTYPE <NTH .MVEC .LEN> FIX>>
				       ,LHW>
			      FIX>
		      <CHTYPE <GETBITS .LEN ,RHW> FIX>>
		   17>
		18>>
	<SET GBITS <REST .GBITS .LEN>>
	<SET INTERNAL-ENTRYS
	     <MAPF ,UVECTOR
		   <FUNCTION (ITEM
			      "AUX" (ARGS <CHTYPE <GETBITS .ITEM ,LHW> FIX>)
				    (LOC <CHTYPE <GETBITS .ITEM ,RHW> FIX>))
			   #DECL ((ITEM) <PRIMTYPE WORD> (ARGS LOC) FIX)
			   <COND (<OR <L? .LOC .MIN-INST> <0? .MIN-INST>>
				  <SET MIN-INST .LOC>)>
			   <MAPRET <COND (<==? .ARGS 262143> 0) (.ARGS)> .LOC>>
		   .GBITS>>
	<SET STARTING-INSTRUCTION .MIN-INST>
	<SORT <> .INTERNAL-ENTRYS 2 1>>

<DEFINE LOOK-ITEM (LOC) 
	#DECL ((LOC) FIX (INTERNAL-ENTRYS) <UVECTOR [REST FIX]>)
	<REPEAT ((PTR .INTERNAL-ENTRYS))
		#DECL ((PTR) UVECTOR)
		<COND (<EMPTY? .PTR> <RETURN <>>)>
		<COND (<==? <2 .PTR> .LOC> <RETURN <1 .PTR>>)
		      (<G? <2 .PTR> .LOC> <RETURN <>>)>
		<SET PTR <REST .PTR 2>>>>

<DEFINE HRRE (NUM) 
	#DECL ((NUM) FIX)
	<COND (<0? <CHTYPE <GETBITS .NUM <BITS 1 17>> FIX>> .NUM)
	      (<PUTBITS .NUM ,LHW -1>)>>

<DEFINE STORE-INTERNAL-ENTRIES (IENTS LABLS)
		#DECL ((IENTS) <UVECTOR [REST FIX]> (LABLS) VECTOR)
	<REPEAT ((PTR .IENTS) CODPTR LPTR)
	      #DECL ((PTR) <UVECTOR [REST FIX]> (CODPTR) FIX (LPTR) VECTOR)
	      <COND (<EMPTY? .PTR> <RETURN>)>
	      <SET CODPTR <2 .PTR>>
	      <COND (<SET LPTR <MEMQ .CODPTR .LABLS>>
		     <PUT .LPTR 2 <* 2 <1 .PTR>>>)>
	      <SET PTR <REST .PTR 2>>>>

<DEFINE JUMP-STACK (ISINST LABEL CNT) 
	#DECL ((ISINST) STRING (LABEL) <VECTOR [3 ANY]>
	       (STARTING-INSTRUCTION STACK-SIZE CNT) FIX)
	<COND (<=? .ISINST "PUSHJ">)
	      (<G=? .CNT .STARTING-INSTRUCTION>
	       <COND (<AND <3 .LABEL> <N==? <3 .LABEL> .STACK-SIZE>>)
		     (<PUT .LABEL 3 .STACK-SIZE>)>)>>

\

<DEFINE CONVERT-RSUBR EXIT (RVEC
			    "OPTIONAL" (OUTCHAN .OUTCHAN) (STACK T)
			    "AUX" (LABNUM 0) (CNT 0)
				  (MVEC <CHUTYPE <1 .RVEC> FIX>) LABLS LAB-FLG
				  (CAIE-FLG <>) INDEX1 (NOINST <>) (COM-FLG <>)
				  (STACK-SIZE 0) (LAST-A 0) (LAST-O 0)
				  (LAST-P 0) (STARTING-INSTRUCTION 0)
				  INTERNAL-ENTRYS)
   #DECL ((LABNUM) <SPECIAL FIX> (OUTCHAN) <SPECIAL CHANNEL> (RVEC) RSUBR
	  (MVEC) <PRIMTYPE UVECTOR>
	  (STACK-SIZE LAST-A LAST-O LAST-P STARTING-INSTRUCTION) <SPECIAL FIX>
	  (INTERNAL-ENTRYS COM-FLG) <SPECIAL ANY> (STACK) <SPECIAL ANY>)
   <SET LABLS <PASS-1 .MVEC>>
   <COND (.STACK
	  <COND (<GET .RVEC GLUE>
		 <HACK-GLUE-BITS .RVEC>
		 <STORE-INTERNAL-ENTRIES .INTERNAL-ENTRYS .LABLS>)
		(<RETURN #FALSE ("NO GLUE BITS") .EXIT>)>)>
   <TERPRI>
   <TERPRI>
   <PRINC "	<TITLE ">
   <PRINC <2 .RVEC>>
   <PRINC ">">
   <TERPRI>
   <TERPRI>
   <PRINC "	<DECLARE ">
   <PRIN1 <CHTYPE <3 .RVEC> LIST>>
   <PRINC ">">
   <MAPF <>
    <FUNCTION (WRD
	       "AUX" (INST <CHTYPE <GETBITS .WRD ,9BIT> FIX>)
		     (AC <CHTYPE <GETBITS .WRD ,ACF> FIX>)
		     (ATSIGN <ATSIGN? .WRD>)
		     (INDX-AC <CHTYPE <GETBITS .WRD ,IDF> FIX>)
		     (INDEX <CHTYPE <GETBITS .WRD ,RHW> FIX>) ISINST LABEL
		     NAME)
       #DECL ((AC INST INDX-AC INDEX) <PRIMTYPE WORD> (ATSIGN) <OR FALSE ATOM>)
       <SET COM-FLG <>>
       <COND
	(.NOINST <SET NOINST <>>)
	(ELSE
	 <SET LAB-FLG <INIT-INST .CNT .LABLS>>
	 <COND
	  (<SET ISINST <INSTRUCTION? .INST>>
	   <COND
	    (<AND <UUO? .INST> <OR <0? .INDX-AC> <R? .INDX-AC>>>
	     <PRINT-INST .ISINST>
	     <COND (<=? .ISINST "MCALL"> <PRINT-NUMB .AC>)
		   (ELSE <PRINT-ACF .AC .INST>)>
	     <PRINT-ATSIGN .ATSIGN>
	     <COND (<R? .INDX-AC> <PRINT-R .RVEC .INDEX <>>)
		   (<SET NAME <GET-SUBR .INDEX T>> <PRIN1 .NAME>)
		   (<NUMBER-PRINT .WRD>)>)
	    (<AND <==? <CHTYPE .WRD FIX> ,SKIPGE-INTFLG>
		  <==? <CHTYPE <NTH .MVEC <+ .CNT 2>> FIX> ,JSR-LCKINT>>
	     <PRINC "INTGO">
	     <SET NOINST T>)
	    (<JUMP? .INST>
	     <PRINT-INST .ISINST>
	     <COND (<M? .INDX-AC>
		    <SET LABEL <SPEC-MEMQ .INDEX .LABLS>>
		    <COND (.STACK <JUMP-STACK .ISINST .LABEL .CNT>)>
		    <STANDARD-PRINT .AC .ATSIGN <1 .LABEL> .INST>)
		   (<AND <0? .INDX-AC> <SET NAME <GET-SUBR .INDEX>>>
		    <STANDARD-PRINT .AC .ATSIGN .NAME .INST .INDX-AC>)
		   (ELSE
		    <PRINT-ACF .AC .INST>
		    <COND (.ATSIGN <PRINC "@ ">)>
		    <PRINT-INDEX-AC .INDX-AC>
		    <COND (<AND <0? .INDX-AC> <L? .INDEX 16>> <ADDR-AC .INDEX>)
			  (<NOT <0? .INDEX>>
			   <PRINT-NUMB <CHTYPE .INDEX FIX>>)>)>)
	    (<AND <OR <=? .ISINST "DPB"> <=? .ISINST "LDB">>
		  <M? .INDX-AC>
		  <SET INDEX1 <NTH .MVEC <+ .INDEX 1>>>
		  <==? <CHTYPE <ANDB .INDEX1 -16777216> FIX> ,TYPBYT>>
	     <SET INDEX .INDEX1>
	     <SET INDX-AC <CHTYPE <GETBITS .INDEX ,IDF> FIX>>
	     <SET INDEX <CHTYPE <GETBITS .INDEX ,RHW> FIX>>
	     <COND (<=? .ISINST "DPB"> <PRINT-INST "PUTYP">)
		   (<PRINT-INST "GETYP"> <SET CAIE-FLG .AC>)>
	     <PRINT-ACF .AC .INST>
	     <PRINT-ATSIGN <ATSIGN? .INDEX1>>
	     <PRINT-INDEX-AC .INDX-AC>
	     <COND (<AND <0? .INDX-AC> <L? .INDEX 16>> <ADDR-AC .INDEX>)
		   (<OCTAL-PRINT .INDEX T>)>)
	    (ELSE
	     <PRINT-INST .ISINST>
	     <COND
	      (<M? .INDX-AC>
	       <PRINT-ACF .AC .INST>
	       <PRINT-MVAL .MVEC .INDEX .LABLS .INST>)
	      (<R? .INDX-AC> <PRINT-ACF .AC .INST> <PRINT-R .RVEC .INDEX T>)
	      (ELSE
	       <PRINT-ACF .AC .INST>
	       <COND (.ATSIGN <PRINC "@ ">)>
	       <PRINT-INDEX-AC .INDX-AC>
	       <COND
		(<AND <OR <=? .ISINST "MOVSI">
			  <AND <OR <=? .ISINST "CAIN"> <=? .ISINST "CAIE">>
			       <==? .CAIE-FLG .AC>>>
		      <0? .INDX-AC>
		      <L? .INDEX <LENGTH <ALLTYPES>>>>
		 <PRINC "<TYPE-CODE ">
		 <COND (<==? .INDEX 18> <PRINC "DEFER">)
		       (<PRIN1 <NTH <ALLTYPES> <+ .INDEX 1>>>)>
		 <PRINC ">">)
		(<AND <G? .INDEX ,$TLOSE> <L? .INDEX ,$TLOSEHI>>
		 <PRINC "<TYPE-WORD ">
		 <PRIN1 <NTH <ALLTYPES> <- .INDEX ,$TLOSE -1>>>
		 <PRINC ">">)
		(ELSE
		 <COND (<AND <L? .INDEX 16>
			     <0? .INDX-AC>
			     <NOT <IMMEDIATE? .INST>>>
			<ADDR-AC .INDEX>)
		       (<AND <0? .INDX-AC>
			     <NOT <IMMEDIATE? .INST>>
			     <GET-SUBR .INDEX>>
			<PRINC <GET-SUBR .INDEX>>)
		       (<NOT <0? .INDEX>>
			<COND (<0? .INDX-AC> <PRINT-NUMB <CHTYPE .INDEX FIX>>)
			      (ELSE <OCTAL-PRINT .INDEX T>)>)
		       (<IMMEDIATE? .INST> <PRINC !\0>)>)>)>)>)
	  (<M? .INDX-AC> <SET NAME <SPEC-MEMQ1 .INDEX .LABLS>> <PRINC .NAME>)
	  (<NUMBER-PRINT .WRD>)>
	 <COND (<AND <OR <=? .ISINST "CAIN"> <=? .ISINST "CAIE">>
		     <==? .CAIE-FLG .AC>>
		<SET CAIE-FLG <>>)>
	 <FIN-INST .LAB-FLG .CNT>
	 <COND (<AND .ISINST .STACK>
		<STACK-HANDLER .ISINST .AC .MVEC .RVEC .INDEX .INDX-AC .CNT>)>)>
       <SET CNT <+ .CNT 1>>>
    .MVEC>
   <CRLF>>

<DEFINE GROUP-CONVERT LOSPNT (NAM CH "OPTIONAL" (GLU T)
			      "AUX" NM RES (PGNUM 1) (PGLST ()) PGVEC) 
	#DECL ((NAM) ATOM (CH) CHANNEL (PGVEC) VECTOR (PGLST) LIST (PGNUM) FIX)
	<COND (<AND <ASSIGNED? .NAM> <TYPE? <SET NM ..NAM> LIST>>)
	      (<RETURN #FALSE ("Bad group") .LOSPNT>)>
	<MAPF <>
	      <FUNCTION (RSB) 
		      <COND (<AND <TYPE? .RSB FORM>
				  <==? <LENGTH .RSB> 3>
				  <==? <1 .RSB> SETG>
				  <TYPE? <SET RSB <3 .RSB>> RSUBR>>
			     <INDENT-TO 70 .CH>
			     <PRINC "PAGE " .CH>
			     <PRIN1 .PGNUM .CH>
			     <SET PGLST (.PGNUM <2 .RSB> !.PGLST)>
			     <SET PGNUM <+ .PGNUM 1>>
			     <COND (<NOT <SET RES <CONVERT-RSUBR .RSB .CH .GLU>>>
				    <RETURN .RES .LOSPNT>)>
			     <PRINC "" .CH>
			     <CRLF .CH>)>>
	      .NM>
	<SET PGVEC [!.PGLST]>
	<SORT <> .PGVEC 2 1>
	<PRINC "INDEX" .CH>
	<CRLF .CH>
	<CRLF .CH>
	<REPEAT ((PTR .PGVEC))
		#DECL ((PGVEC) <VECTOR [REST FIX ATOM]>)
		<COND (<EMPTY? .PTR> <RETURN>)>
		<PRINC <2 .PTR> .CH>
		<INDENT-TO 30 .CH>
		<PRIN1 <1 .PTR> .CH>
		<CRLF .CH>
		<SET PTR <REST .PTR 2>>>
	"DONE">

"UNASSEMBLE -- top level entry which takes care of channels and such"

<DEFINE UNASSEMBLE (WHO "OPTIONAL" (WHERE <>) (GLUE? T) "AUX" C R (NM2 "UNASSM"))
	#DECL ((WHO) <OR ATOM RSUBR> (WHERE) <OR FALSE CHANNEL STRING>
	       (GLUE?) <OR ATOM FALSE> (R) ANY (C) <OR CHANNEL FALSE>
	       (NM2) <SPECIAL STRING>)
	<COND (<NOT .WHERE>
	       <COND (<TYPE? .WHO ATOM> <SET WHERE <SPNAME .WHO>>)
		     (ELSE <SET WHERE <SPNAME <2 .WHO>>>)>)>
	<COND (<OR <AND <TYPE? .WHERE CHANNEL> <SET C .WHERE>>
		   <SET C <OPEN "PRINT" .WHERE>>>
	       <SET R
		    <COND (<TYPE? .WHO ATOM> <GROUP-CONVERT .WHO .C .GLUE?>)
			  (ELSE <CONVERT-RSUBR .WHO .C .GLUE?>)>>
	       <COND (<TYPE? .WHERE STRING> <CLOSE .C>)>
	       .R)>>

"DUMP-U -- dumps an unassem save file"

<DEFINE DUMP-U ("OPTIONAL" (FNAME
			    <STRING "MUDDLE;"
				    "UNASSM "
				    <UNPARSE ,MUDDLE>
				    "SAVE">))
	<SNAME "">
	<COND (<=? <SAVE .FNAME> "SAVED"> "READY")
	      (<PRINC "MUDDLE UNASSEMBLER."> <CRLF>)>>

<ENDPACKAGE>
