	.SBTTL NEW FILING
	VERSIO

.IFNZ FILDSK
;USER PRIMITIVE ROUTINES

;DIRSET TAKES A LIST AND SETS THE CURRENT DIRECTORY

.IIF NZ UNIX,	.DIRSE:
DSET:	JSR PC,SETNM	;GET NAME OF DIRECTORY
.IFNZ UNIX
	SYS CHDIR
	#NAME
	BCC 1$
	ERROR+ENDR
1$:	RTS PC
.IFF
       	BNE DSET1	;INPUT IS A LIST
	JMP COPDEF
DSET1:	JSR PC,COPDEF
DIRSET:	JSR PC,GNWRD	;GET A WORD FROM THE LIST
	BNE 1$		;ANY LEFT?
	RTS PC		;NONE LEFT, DONE
1$:	JSR PC,DIRGET	;GET NEXT ITEM FROM LIST
	BR DIRSET	;AND CONTINUE WITH THE NEXT NAME


DIRGET:	JSR PC,NNFNGT	;GET A FILE NAME
	MOV #NAME,E
1$:	TSTB (E)+	;NO, FIND IT
	BNE 1$
	DEC E
	CMPB #';,-(E)	;IS THIS THE ROOT DIRECTORY?
	BNE DIRGT1
	CLR NPATH	;WELL THEN PATH IS NIL
	CMP #NAME+1,E	;JUST ROOT?
	BHI DIRGT2
	BLO DIRGT8	;DISK NAME	
	MOVB -(E),A	;NO, GET WHICH ROOT HE WANTS
	SUB #60,A	;MAKE SURE HE TYPED A NUMBER
	BLT DIRGT8	;MAYBE IT IS A NAME
	CMP DISKS,A	;NUMBER?
	BLE DIRGT8	;MAYBE A NAME
DIRGT9:
;FALLS THROUGH
;FALLS IN
.IF NZ SITS
	ADD #10,A	;GET TO THE ROOT CAPABILITIES
	MOV A,CURROT
.IFF
	JSR PC,CRTROT
.ENDC
COPROT:	
DIRGT2:	SAVE A
	MOV CURROT,A
.IFNZ LSI
	BNE 1$
	ERROR+NCD
1$:
.ENDC
	JSR PC,COPCUR
	REST A
	RTS PC

DIRGT8:
.IF NZ SITS
	MOV #DNAMEP,A	;POINTER TO TABLE OF NAME POINTERS
2$:	MOV (A)+,B	;POINTER TO A NAME
	BNE 1$
	ERROR+BDD	;BAD DISK NAME
1$:	MOV #NAME,C	;POINTER TO HIS NAME
3$:	CMPB (C)+,(B)+
	BEQ 3$
	TSTB -1(B)	;END?
	BNE 2$
	CMPB -1(C),#';
	BNE 2$
	SUB #DNAMEP+2,A	;GET NUMBER*2
	ASR A		;CAP NUMBER
	BR DIRGT9
.IFF
	ERROR+BDD
.ENDC


DIRGT1:	JSR PC,NAMMUE	;MUTATE TO NAME
	JSR PC,DIRCHK
	BNE 2$
	ERROR+ENDR
2$:	RTS PC
.IFNZ LSI
CRTROT:	ASL A
	MOV ROTCPS(A),CURROT
	BNE DIRGT2	;WE ALREADY HAVE ONE
	MOV A,ROTBLK
	BIS #.FARUT,ROTBLK
	SAVE <#-1,#ROTBLK,#.FACAP*400+0>
	.INVOK		;TRY TO CREATE A ROOT CAP
	BNE 1$
2$:	ADD #ROTCPS,A
	JSR PC,DELCPC
	JSR PC,FLSCUR
	CLR CURROT
	ERROR+GDE
1$:	MOV (P),CURROT
	REST ROTCPS(A)
	JSR PC,COPROT	;COPY ROOT TO CURCAP
	SAVE <#0,#BITS,@CURCPP>
	BIS #.FAMU,(P)
	.INVOK
	BEQ 2$
	SAVE <,,@CURCPP>
	BIS #.FAMB,(P)	;THSI IS THE BIT TABLE
	.INVOK
	BEQ 2$
	JMP FLSCUR
.ENDC

;MUTATE @CURCPP TO NAME IN NAME; CLOBBERS F
NAMMUT:	TST (P)+
	CLR -(P)
	SAVE <A,B>
	MOV #NPATH,A
2$:	TSTB (A)+
	BNE 2$
	MOVB #40,-1(A)
	MOV #NAME,B
3$:	CMP #NPATH+MAXPLN,A
	BLOS 4$
	MOVB (B)+,(A)+
	BNE 3$
	REST <B,A>
	SAVE <#NAME,@CURCPP>
	BNE 1$			;DON'T MUTATE NUL CAP
	ERROR+NCD
1$:	BIS #.FAMU,(P)		;MUTATE IT
	.INVOK
	JMP (F)

4$:	ERROR+BDD

NAMMUE:	JSR F,NAMMUT
	BNE 1$
	JSR PC,FLSCUR
	ERROR+FNF
1$:	RTS PC

;COPY THE DEFAULT CAPABILITY INTO THE CURRENT CAPABILITY
COPDEF:	SAVE B
	MOV #PATH,A
	MOV #NPATH,B
3$:	MOVB (A)+,(B)+
	BNE 3$
	REST B
	MOV DEFCAP,A
	MOV DEFROT,CURROT
COPCUR:	JSR PC,FLSCUR		;GET RID OF ANY CURRENT CAPABILITY
	TST A			;IS THIS FOR REAL?
	BEQ 2$
	SAVE <#-1,#0,A>		;TO COPY CAPABILITY
	BIS #.CPYCP,(P)		;TO COPY
	.INVOK
	BNE 1$
	ERROR+GDE
1$:	REST @CURCPP
	RTS PC
2$:	CLR @CURCPP
	RTS PC
	
.DIRSE:	JSR PC,SETCHF		;SET TO A FREE CHANNEL
	BIT #7777,@S		;CHECK NAME OF DIRECTORY ON S-PDL
	BNE .DIRS1
	SPOPS A			;NOTHING TO DO
	SEZ
	RTS PC
.DIRS1:	JSR PC,DSET		;SET THE DIRECTORY
USEENT:	JSR PC,DIRGET		;SET UP FILES
	JSR PC,FLSDEF		;OLD DEFAULT NO LONGER NEEDED
	SAVE <A,B>
	MOV #NPATH,A
	MOV #PATH,B
1$:	MOVB (A)+,(B)+
	BNE 1$
	REST <B,A>
	MOV @CURCPP,DEFCAP
	CLR @CURCPP
	MOV CURROT,DEFROT
	SEZ
	RTS PC
.USE:	BIT #7777,@S
	BNE .USE1
	SPOPS A
	SEZ
	RTS PC
.USE1:	CLR NPATH
	JSR PC,SETCHF		;SET US TO A FREE CHANNEL
1$:	MOV DEFROT,A
.IFNZ LSI
	BNE 9$
	CLR A
	JSR PC,CRTROT
	MOV CURROT,DEFROT
	BR 1$
9$:
.ENDC
	JSR PC,COPCUR	;MAKE THE DEFAULT ROOT BE THE CURRENT CAP
	MOV #NAME,A
	MOV #"US,(A)+
	MOV #"ER,(A)+
	MOV #'S,(A)
	JSR PC,NAMMUE
	JSR PC,SETNM
	BEQ 3$
	JSR PC,DIRSET
3$:	BR USEENT
.ENDC				;END IFZ UNIX, PATH IS ONE WORD

.IFZ UNIX
ERINDX:
ERFI:	JSR PC,EVAL		;GET THE FILE NAME OR PATH LIST
	BEQ .DELET		;DIDN'T TELL ME WHAT TO DO
	ERROR+UELX		;UNEXPECTED END OF LINE
.DELI:
.DELET:	JSR PC,SETCHF
	JSR PC,DSET
	JSR PC,NNFNGT
	JSR PC,NAMMUE
	SAVE <,,@CURCPP>
	BIS #.FADL,(P)
	.INVOK
	BNE 2$
	ERROR+GDE
2$:	JSR PC,FLSCUR
	SEZ
	RTS PC

FLSDEF:	SAVE A
	MOV DEFCAP,A
	JSR PC,DELCAP
	CLR DEFCAP
	REST A
	RTS PC
.IFF
ERFI:	JSR PC,EVAL
	BEQ .DELET
	ERROR+UELX
.DELET:	JSR PC,SETNM
	SYS UNLINK
	#NAME
	BCC 1$
	ERROR+GDE
1$:	RTS PC

ERINDX:	JSR PC,EVAL
	BEQ .DELI
	ERROR+UELX
.DELI:	JSR PC,SETNM
	SYS FORK
	BR .DELI1
	MOV A,C			;SAVE KID
1$:	SYS WAIT
	CMP A,C			;RIGHT PROCESS?
	BNE 1$
	TST B
	BEQ 2$
	ERROR+ENDR
2$:	RTS PC

.DELI1:	SYS EXEC
	#.RMDIR			;ASCIZ "/bin/rmdir"
	#.RMARG			; ARGUMENT VECTOR
	MOV #1,A		;INDICATE FAILURE TO PARENT
	SYS EXIT
.ENDC

.IFNZ SITS	;THIS IS PRETTY USELESS ON THE LSI-11, EVEN WITH FLAKEY DISK
;MAIL PRIMITIVE. SENDS "MAIL" TYPED ON SCREEN TO PERSON SPECIFIED
	;BY INSERTING TEXT INTO HIS OWN MAIL FILE, IF ONE EXISTS
	;OR CREATING A NEW ONE IF ONE DOESN'T
MAIL:	JSR PC,SETCH0
	MOV #10,A	;GET CAPABILITY TO ROOT DIRECTORY
	JSR PC,COPCUR
	SAVE <#0,#MAILNM,@CURCPP> ;MUTATE TO MAIL DIR. ENTRY IN ROOT DIR.
	BIS #.FAMU,(P)	
	.INVOK
	JSR PC,.OPNA3	;OPEN MAIL FILE
	MOV #.WRTEC,PCHR	;CHARS. IN BUFFER INTO OUTPUT DEVICE
	PRTXTC ^/------/
STLANC
ENGINS	<PRTXT ^/MAIL FROM />
ENDENG
FRINS	<PRTXT ^/EN PROVENANCE DE />
ENDLAN
	SAVE <#NAME,#-1> 	
	.CRUSR		;GET SENDER'S NAME IN "NAME"
	MOV #NAME,A	
	JSR PC,PRAS	;PRINT NAME POINTED TO BY A
	JSR PC,.CRLF	;CARRIAGE RETURN, LINEFEED
	JSR PC,UDATEG	;SET THE DATE
	MOV #1,D
	JSR PC,TYPE	;PRINT THE DATE
	JSR PC,.SPACE
	JSR PC,UTIMEG	;SET THE TIME
	MOV #1,D
	JSR PC,PRINT	;PRINT THE TIME
	SPUSH PRMTCH	;SAVE NORMAL PROMPT CHARACTER
	MOV #'_,PRMTCH	;NEW ONE IS "_"
	MOV #TYO,PCHR
MAIL2:	JSR PC,RDSTR	;READ A STRING
	BEQ MAIL3	;NO CHARACTERS TYPED
	MOV @S,B	;POINTER TO STRING
	JSR PC,.LOADB	;FIRST CHARACTER
	CMP #'.,B	;IS IT A PERIOD?
	BEQ MAIL1	;YES (NO MORE INPUT)
	JSR PC,..FILP
	BR MAIL2
MAIL1:	SPOP PRMTCH	;GET BACK OLD PRMTCH ("?")
	MOV #.WRTEC,PCHR
	SPOPS A
	PRTXTC ^/------/
	MOV #TYO,PCHR
	JMP .WRTCL
MAIL3:	BR MAIL2	;BREAK CODING USED TO BE HERE
.ENDC

.IFNZ UNIX
READPT:	ERROR+TGD		;READ FROM PAPER TAPE DEVICE (SOMEDAY)
.IFF
READPT:	JSR PC,SETCH0
	JSR PC,FILCHK
	TST D		;ZERO ARGS?
	BEQ READP1	;JUST READ INTO WORKSPACE
	CMP #1,D	;EXACTLY 1?
	BEQ 1$		;YUP
	ERROR+WNA
1$:	JSR PC,..OPNW	;OPEN FILE FOR OUTPUT
	JSR PC,PTRCRT	;TRY TO CREATE A PTR
	MOV F,TMPCP	;SAVE IN THE TEMP CAP
READP3:	SAVE TMPCP
	.BYTI		;READ FROM PT
	BEQ READP2	;DONE
	REST D		;GET THE CHAR WE READ
	JSR PC,.WRTEC	;WRITE TO FILE
	BR READP3

READP2:	REST A		;FLUSH CAP
	JSR PC,DELTMP
	JSR PC,.WRTCL	;CLOSE FILE
	SEZ
	RTS PC	

READP1:	JSR PC,PTRCRT	;GET PAPER TAPE
	JSR PC,FLSCUR
	MOV F,@CURCPP
	MOV #.PREAD,GCHR
	BR .READ9

.PREAD:	SAVE @CURCPP
	.BYTI
	BNE 1$
	MOV #TYI,GCHR
	JSR PC,FLSCUR
	CLR @FILFLP
1$:	REST D
	BIC #177600,D		;FLUSH HIGH BIT
	RTS PC

PTRCRT:	SAVE <#-1,0,#.TRCAP*400>	;CREATE TAPE READER
	.INVOK		;TRY TO GET
	BNE 1$		;READ INTO WORKSPACE
	ERROR+DIU
1$:	REST F
	RTS PC
.ENDC

.READ:	JSR PC,SETCH0
	JSR PC,.READF			;OPEN THE FILE FOR READING
.READ1:	MOV #.READCH,GCHR		;WHERE TO GET THE CHARACTERS
.READ9:	MOV PC,REDFLG			;SAY WE ARE READING
	SAVE TOPRNM			;SAVE POINTER TO PROCEDURE BEING DEFINED
	BEQ 1$				;BRANCH IF THERE WAS NONE
	JSR PC,END			;FLUSH DEFINING PROCEDURE TEMPORARILY
1$:	PUSHS ILINEL			;SAVE THE ILINE FOR LATER
	JSR PC,SAVEVL			;SAVE EVAL
	PUSH #0				;THE NUMBER OF ARGUMENTS
	JSR PC,SAVPPS			;SAVE THE PDL POINTERS
	BIS #DORF,FLAGS			;SAY THIS IS A READ FRAME
	BIS #1,CPDLP			;SAY IT IS A PROCEDURE TYPE PUSH
RMLOOP:	CMP #TYI,GCHR			;ARE WE AT EOF?
	BEQ RMLOO1			;YES, FINISH UP
	JSR PC,SETCH0			;MAKE SURE WE READ FROM PROPER FILE
	JSR PC,RDSTR			;PUSH A STRING ONTO THE STACK
	BEQ RMLOO2			;TRY AGAIN
	JSR PC,MREAD1			;READ IT, AND PUT INTO THE COMMAND BUFFER
	BEQ RMLOO2			;NO TOKENS, CHECK FOR BREAK
	JSR PC,EVLINE			;EVALUATE THE LINE
	BNE RMLOOP			;NO OUTPUT, JUST CONTINUE
	ERROR+WDW			;DONT SAY WHAT TO DO WITH
RMLOO1:	TST TOPRNM			;DONE, DEFINING A PROCEDURE?
	BEQ 1$				;NO, DONT WORRY ABOUT IT
	JSR PC,END			;FINISH ITS DEFINITION
1$:	MOV #2$,DOFRET			;DITTO
	JMP POPVAR			;POP OFF THE READ FRAME
2$:	REST B				;GET BACK OLD TOPRNM
	BEQ 3$				;NO PROCDEURE?
	JSR PC,EDIT2			;REENTER PROCEDURE DEFINITION MODE
3$:	SEZ
	RTS PC
RMLOO2:	TST RBRKF			;BREAK?
	BNE 1$				;YES
	CMP #TYI,GCHR			;STILL INPUTTING FROM FILE?
	BEQ RMLOO1			;NO, FINISH UP
	BR RMLOOP			;GO BACK FOR MORE
1$:	ERROR+BRK

DELALC:	JSR PC,FLSCUR
	JMP DELTMP
.IFNZ LSI
UNMOUN:	JSR PC,G1NARG
	CMP #NDISKS,B
	BHI 1$
	ERROR+BDD
1$:	MOV #CURCAP,A
	MOV #NCHNS,F
2$:	BIT #FILNDK,FILFLG-CURCAP(A)	;IS THIS A NON-DISK CHANNEL?
	BNE 3$
	JSR PC,CMPDKN	;IS THIS CHANNEL OPEN ON THE DISK BEING UNMOUNTED?
	BNE 3$
STLANC
ENGINS <	PRTXT ^/Channel />
ENDENG
FRINS <	PRTXT ^/Le canal />
ENDLAN
	SUB #CURCAP,A
	ASR A
	JSR PC,PRDN
STLANC
ENGINS <	PRTXT ^/ is still open. Close it before unmounting./>
ENDENG
FRINS <		PRTXT ^/ est encore ouvert! Fermer le fichier avant de demonte./>
ENDLAN
	PRCR			
	ERROR+BDD
3$:	TST (A)+
	SOB F,2$
	ASL B		;GET DISK NUMBER
	MOV ROTCPS(B),A
	JSR PC,DELCAP
	MOV ROTCPS(B),F
	CLR ROTCPS(B)
	CMP F,DEFROT
	BNE 4$
	CLR DEFROT
4$:	MOV #DEFCAP,A
	ASR B
	JSR PC,DELCDK	;DETE CAP IF ON DISK(B)
	BNE 9$		;WASN'T
	CLR PATH	;NO LONGER ANY VALID PATH
9$:	SEZ
	RTS PC

DELCDK:	JSR PC,CMPDKN	;COMPARE B WITH DISK NUMBER OF CAP (A)
	BNE 1$
	JSR PC,DELCPC	;DELETE AND CLEAR
	SEZ
1$:	RTS PC

CMPDKN:	TST (A)
	BEQ 1$
	SAVE <,,(A)>
	BIS #.FADI,(P)
	$INVOK
	TST (P)+	;FREE BLOCK COUNT
	CMP B,(P)+	;DISK NUMBER
	RTS PC
1$:	CLZ
	RTS PC
.ENDC

DELCPC:	SAVE A
	MOV (A),A
	JSR PC,DELCAP
	REST A
	CLR (A)
	RTS PC

.IFNZ FILDSK
PRFN.R:	MOV #NAME,A
	JMP PRAS

GDE.R:
.IFZ UNIX
	.GERRW		;GET NEWEST ERROR WORD
	BEQ 1$
	REST <,DSKERW>
1$:
.IIF NZ ENG,	MOV #ENGDER,A
.IIF NZ FR,	MOV #FRDER,A
2$:	TSTB (A)+
	BEQ 3$		;END OF THE LINE
	CMPB DSKERW,-1(A)	;IS THIS OUR THING?
	BEQ 3$		;YUP
5$:	TSTB (A)+	;SEARCH FOR ZERO
	BNE 5$
	BR 2$
3$:	JMP PRAS	;PRINT THE STRING
.IFF
	MOV errno,A		;EXTERNAL VAR PROVIDED BY UNIX
	CMP A,sys_nerr		;NUMBER OF KNOWN ERRORS
	BGE 1$			;JUMP IF UNKNOWN
	ASL A			;MAKE INDEX INTO WORD VECTOR
	MOV sys_errlist(A),A	;GET POINTER TO TEXT STRING
	JMP PRAS
1$:	PRTXT ^/Unknown UNIX error!/
	RTS PC
.ENDC


.WRITE:	JSR PC,SETCH0
	JSR PC,..OPNW
	MOV #.WRTEC,PCHR
	MOV PC,WRTFLG
	JSR PC,SHOWAL
	CLR WRTFLG
	JSR PC,.WRTCL
	MOV #TYO,PCHR
	SEZ
	RTS PC


.OPENR:	JSR PC,CHNSE1
.READF:	JSR PC,OPENR
	BNE 1$
	ERROR+FNF
1$:	SEZ
	RTS PC

OPENR:
.IFNZ UNIX
	JSR PC,SETNM
.IFF
	JSR PC,DSET
	JSR PC,NNFNGT
.ENDC

FREADR:
.IFZ UNIX
	JSR F,NAMMUT
	BEQ FREAD1
	JSR PC,DIRCHK		;FILE OR DIRECTORY?
	BEQ FREAD2		;FILE
	TST CHAN		;DIRETORY CAN ONLY BE OPENED ON CHANNEL ZERO
	BEQ 1$
	JSR PC,FLSCUR
	ERROR+IFN
1$:	MOV #FILDIR!FILRED,@FILFLP	;DIRECTORY
	MOV PC,DIRFLG		;THIS FLAG IS NONZERO TILL DBUF HAS GOTTEN THE END OF THE DIR
	CLR DIRIGC		;NO BYTES
	BR FREAD3
.IFF
	SYS OPEN
	#NAME
	0
	BCC 1$
	ERROR+GDE
1$:	MOV CHAN,B
	ASL B
	MOV A,.FLDSC(B)
.ENDC
FREAD2:	MOV #FILRED,@FILFLP
.IFZ UNIX
FREAD3:	TST CHAN
	BNE FREAD4
	CLR BCHNG
	MOV #DBUF,DBUFP
	MOV #DBUF,DBDEND
	CLR DBUFST
	CLR DBUFST+2		;SET UP INITIAL BUFFER
.ENDC
FREAD4:	CLZ
	RTS PC
.IFZ UNIX
FREAD1:	JSR PC,FLSCUR
	ADD #6,P
	SEZ
	RTS PC
.ENDC

.READC:	BIT #FILRED,@FILFLP	;IS ANYTHING OPEN FOR READING ON THIS CHANNEL?
	BEQ 2$			;NO
.IFNZ UNIX
	MOV CHAN,D
	ASL D
	MOV .FLDSC(D),A
	SYS READ
	#RDBYTE
	#1
	TST A
	BEQ 4$
	BGE 9$
	ERROR+GDE
9$:	MOVB RDBYTE,D
	RTS PC
.IFF
	TST CHAN		;BUFFERED CHANNEL?
	BNE 3$			;NO
	CMP DBUFP,DBDEND	;HAVE WE REACHED THE END OF THE BUFFER
	BNE 1$			;GET A NEW CHAR
	JSR PC,NEWBLK
	BNE .READC		;GOT SOME CHARS
.ENDC
2$:	CLR REDFLG		;NO LONGER READING
4$:	JSR PC,.REDCL		;CLOSE THE FILE FOR READING
	MOV #EOFCHR,D
	RTS PC

.IFZ UNIX
1$:	MOVB @DBUFP,D
	INC DBUFP
	RTS PC

3$:	SAVE <@CURCPP>
	.BYTI
	BEQ 5$			;CLOSE THE FILE AT EOF
	REST D
	RTS PC
5$:	TST (P)+		;POP OFF THE CAPABILITY
	BR 4$			;AND FAIL GRACELESSLY

NEWBLK:	BIT #FILDIR,@FILFLP	;IS IT A DIRECTORY?
	BEQ 1$			;NO
	TST DIRFLG		;DONE WITH THE DIRECTORY?
	BEQ 2$			;YES, DONE
	JSR F,ACSAV		;SAVE AC'S FOR DIRECTORY
	JSR PC,DRBLKI
	JSR F,ACRES
	BR 3$
1$:	JSR PC,FLUSBF		;FLUSH THIS BUFFER
	BNE 3$			;GOT A NEW ONE, GO BACK FOR CHARACTERS
2$:	SEZ
	RTS PC
3$:	CLZ
	RTS PC

FLUSBF:	JSR PC,WRTBUF
REDBLK:	MOV #DBUF,DBUFP
	SAVE <,,@CURCPP>	;READ THE ACCESS POINTER
	BIS #.FARP,(P)		;READ THE POINTER
	$INVOK
	REST <DBUFST,DBUFST+2>
	SAVE <#DBUF,#-DBUFL,@CURCPP>
	.BLKI
	BNE 1$		;GOT A FULL BUFFER
	SAVE A
	MOV #.ERPEF,A		;ATTEMPT TO READ PAST EOF IS EXPECTED
	JSR PC,DERCHK		;ANY OTHER ERROR IS BAD
	REST A
	MOV 4(P),DBDEND		;GET POINTER TO THE END OF THE DATA
	ADD #6,P		;POP OFF THE CALL
	CMP DBDEND,#DBUF	;GET ANYTHING
	BNE 2$			;GOT SOMETHING
	SEZ			;EOF
	RTS PC
1$:	MOV #DBUF+DBUFL,DBDEND	;SET UP POINTER TO THE END OF THE DATA
2$:	RTS PC

WRTBUF:	SAVE D
	TST BCHNG		;BUFFER BEEN MODIFIED?
	BEQ 1$			;NOPE
	SAVE <DBUFST+2,DBUFST,@CURCPP>	;SET POINTER TO START OF BUFFER
	BIS #.FASP,(P)		;SET THE POINTER
	$INVOK
	MOV #DBUF,D		;GET POINTER TO THE LAST ACCURATE BYTE
	SUB DBDEND,D		;GET THE NEGATIVE BYTE COUNT
	SAVE <#DBUF,D,@CURCPP>
	.BLKO			;OUTPUT IT
	BNE 1$			;DID IT
	REST D
	JMP .WRTDF		;DISK FULL
1$:	REST D
	CLR BCHNG		;BUFFER HASN'T CHANGED
	RTS PC

				;THIS ENTIRE PAGE IS IFZ UNIZ
				;THIS GETS PUT IN PCHR WHEN .POI RUNS AS COROUTINE OF .FILER
DIRHAC:	DEC DIRIGN		;SHOULD WE IGNORE THIS CHARACTER?
	BGE 2$			;YUP
	CMP DBUFP,#DBUF+DBUFL	;END OF BUFFER?
	BHIS DRBLK1
	MOVB D,@DBUFP		;MOVE CHARACTER INTO DBUF
	INC DBUFP		;UPDATE POINTER
	INC DBDEND		;AND VALID BYTE POINTER
2$:	RTS PC

DRBLKI:	MOV #DBUF,DBDEND	;NO VALID BYTES YES
	MOV #DBUF,DBUFP		;AND POINTER
	MOV CURCPP,DIRCAP	;WE WANT .POI TO USE CURCAP, NOT TMPCP
	SAVE PCHR		;THESE NEED TO BE DIFFERENT FOR OUR COROUTINE
	MOV #DIRHAC,PCHR	;PCHR SHOULD READ INTO THE BUFFER, NOT PRINT OUT
	MOV P,DIRIGP
	MOV DIRIGC,DIRIGN
	CLR B			;TO DO POI RATHER THAN POTREE
	JSR PC,SETCH0		;SINCE WE WANT TO USE THE BUFFER
	JSR PC,..POI
	CLR DIRFLG
;NON-LOCAL RETURN FROM DIRHAC ENTERS HERE
DRBLK1:	MOV DIRIGP,P
	MOV #DBUF,DBUFP
	ADD #DBUFL,DIRIGC
	REST PCHR	;THESE SHOULD BE NORMAL WHEN CO-RTN NOT RUNNING
	MOV #TMPCP,DIRCAP	;THIS GOES BACK TO NORMAL TOO
	RTS PC
.ENDC				;END IFZ UNIX

.OPENM:	JSR PC,CHNSE1
.IFNZ UNIX
	MOV #2,.APMOD	;SAVE MODES FOR OPEN BELOW
.ENDC
	JSR PC,.OPNAX		;OPEN APPEND THE FILE
	BIS #FILRED,@FILFLP	;AND GIVE HIM READ ACCESS ALSO
	SEZ
	RTS PC

.OPENA:	JSR PC,CHNSE1
.IFNZ UNIX
	MOV #1,.APMOD		;ONLY ALLOW WRITING
.ENDC
.OPNAX:
.IFZ UNIX
	JSR PC,DSET		;SETS DIRECTORY
.OPNA3:	JSR PC,NNFNGT		;SET FILE NAME
	JSR F,NAMMUT
	BEQ .OPNA1
	JSR PC,DIRCHK		;DO WE HAVE A FILE OR A DIRECTORY?
	BEQ .OPNA2		;IF FILE, PROCEED
	JSR PC,FLSCUR		;IF DIRECTORY, FLUSH THE CAPABILITY
	ERROR+FNF		;AND COMPLAIN
.OPNA1:	CLRB 1(P)		;FLUSH OLD FUNCTION
	BIS #.FAAD,(P)		;TRY TO MAKE A NEW FILE
	.INVOK
	BNE .OPNA2
	ERROR+GDE
.OPNA2:	CMP -(P),-(P)		;DUMMY
	SAVE <@CURCPP>
	BIS #.FARE,(P)
	$INVOK			;READ THE END OF FILE
	TST CHAN		;CHANNEL ZERO?
	BNE 1$			;NO, DON'T DO THIS STUFF
	JSR PC,FREAD3		;CLEAR MISC STUFF
	MOV (P),DBUFST		;STORE AWAY THE BUFFER START
	MOV 2(P),DBUFST+2
1$:	SAVE <@CURCPP>
	BIS #.FASP,(P)		;SET THE POINTER TO THE END OF FILE
	$INVOK
.IFF
	JSR PC,SETNM		;GET FILENAME
4$:	SYS INDIR		;OPEN OLD FILE
	.APEND
	BCS 1$			;JUMP IF FILE NOT FOUND, SHOULD BE CREATED
	JMP .OPNA1		;EVERYTHING IS READY
1$:	MOV errno,A		;GET ERROR CODE
	CMP #2,A		;ENOENT - NO SUCH FILE
	BEQ 2$			;RIGHT, OK TO CREATE
	ERROR+GDE		;ANYTHING ELSE, DON'T TRY
2$:	SYS CREAT		;CREATE NEW FILE
	#NAME
	0777			;ANYONE CAN DO ANYTHING
	BCC 3$			;JUMP IF OK
	ERROR+GDE
3$:	SYS CLOSE		;CLOSE SO WE CAN REOPEN IN RIGHT MODE
	JMP 4$			;INFINITE LOOP IF I DON'T UNDERSTAND ERR CODES RIGHT

.OPNA1:	MOV CHAN,B		;STASH FILDES
	ASL B
	MOV A,.FLDSC(B)
	SYS LSEEK		;GET TO EOF
	0
	0
	2
.ENDC
	MOV #FILWRT,@FILFLP	;SET OPEN FILE FLAG FOR WRITE
	SEZ
	RTS PC
QUEST:	JSR PC,ONETYI
	SPUSH D			;SAVE IT
	JSR PC,.CRLF		;PRINT CR AND LINEFEED
	SPOP D			;GET CHARACTER
.IFNZ FR
	CMP #'O,D
	BEQ QUEST1
	CMP #'O+40,D
	BEQ QUEST1
.ENDC
.IFNZ ENG
	CMP #'Y,D		;IS IT "Y"?
	BEQ QUEST1
	CMP #'Y+40,D		;IS IT SMALL Y
.ENDC
QUEST1:	RTS PC

.OPENW:	JSR PC,CHNSE1		;FOR NOW
..OPNW:
.IFNZ UNIX
	JSR PC,SETNM
.IFF
	JSR PC,DSET		;SET DIRECTORY
	JSR PC,NNFNGT		;SET IT
.ENDC
.WRTF2:
.IFZ UNIX
	CLR -(P)
	SAVE <#NAME,@CURCPP>
	BNE 1$
	ERROR+NCD
1$:	BIS #.FAAD,(P)
	.INVOK			;TRY TO PUT IT INTO THE DIRECTORY
	BEQ .WRTF1
	JSR PC,FREAD3		;TO CLEAR MISC STUFF
.IFF
	SYS OPEN		;FIRST TRY TO LOOK IT UP
	#NAME
	0
	BCS 1$			;JUMP IF NO FILE FOUND
	SYS CLOSE		;FILE EXISTS, GIVE BACK DESCRIPTOR
	BR .WRTF1		;ASK USER ABOUT REPLACEMENT
1$:	SYS CREAT		;NO FILE, CREATE ONE
	#NAME
	#0777			;ANYONE MAY DO ANYTHING
	BCC 2$			;WINNING
	ERROR+GDE
2$:	MOV CHAN,B		;SAVE UNIX FILE DESCRIPTOR
	ASL B
	MOV A,.FLDSC(B)
.ENDC
	MOV #FILWRT,@FILFLP
.WRTF6:	SEZ
	RTS PC
.WRTF1:
.IFZ UNIX
	MOV #.EEAE,A	;ENTRY ALREADY EXISTS ERROR IS OK
	JSR PC,DERCHK		;SEE IF THE DIRECTORY FULL
.ENDC
STLANC
ENGINS	<PRTXT ^/FILE ALREADY EXISTS.  DELETE IT?/>
ENDENG
FRINS	<PRTXT ^/FICHIER DEJA EXISTANT. A DETRUIRE?/>
ENDLAN
	JSR PC,QUEST		;GET REPLY
	BEQ 1$			;OK, DELETE IT
	ERROR+GDE		;ENTRY ALREADY EXISTS
1$:
.IFZ UNIX
	MOV @CURCPP,A
	MOV A,TMPCP		;SO IT WILL BE DELETEED ON ERROR
	CLR @CURCPP
	JSR PC,COPCUR		;COPY OLD CURCAP INTO CURCAP
	CLRB 1(P)		;USE OLD STUFF ON STACK
	BIS #.FAMU,(P)		;BUT MUTATE INSTEAD
	.INVOK			;TRY TO GET TO OLD FILE
	BNE .+4
.WRTF9:	ERROR+GDE		;????
	SAVE <#0,#0,A>		;CABILITY TO FILE
	BIS #.FADL,(P)		;WANT TO DELETE
	.INVOK
	BEQ .WRTF9
	JSR PC,DELTMP		;FLUSH CAP TO FILE
	BR .WRTF2		;TRY AGAIN
.IFF
	SYS UNLINK		;TRY TO DELETE THE FILE
	#NAME
	BCC 3$			;JUMP IF OK
	ERROR+GDE
3$:	JMP .WRTF2		;OK, TRY AGAIN
.ENDC

.IFZ UNIX
DERCHK:	$GERRW			;READ THE ERROR WORD, SHOULD NEVER FAIL
	TST (P)+		;POP USELESS ERROR ADDRESS
	MOV (P),DSKERW		;SAVE DISK ERROR CODE
	CMP (P)+,A		;IS THIS THE PERMISSIBLE ERROR?
	BEQ 1$
	JSR PC,CLOSF
	ERROR+GDE
1$:	RTS PC
.ENDC

.WRTEC:	BIT #FILWRT,@FILFLP
	BNE 1$
	BPT
1$:
.IFZ UNIX
	TST CHAN		;ONLY CHANNEL ZERO IS BUFFERED
	BNE .WRTUB
	CMP DBUFP,#DBUF+DBUFL	;FINISHED THIS BUFFER?
	BNE 3$			;STILL STUFF LEFT
	JSR PC,FLUSBF		;GET THE NEXT BUFFER
3$:	MOV PC,BCHNG		;BUFFER CHANGED
	MOVB D,@DBUFP
	INC DBUFP
	CMP DBUFP,DBDEND	;HAVE WE WRITTEN A BYTE THAT HASN'T BEEN TOUCHED BEFORE?
	BLOS 2$			;NOPE
	MOV DBUFP,DBDEND	;UPDATE VALID DATA POINTER
2$:	RTS PC
.IFF
	MOV CHAN,A		;CHANNEL TO WRITE ONTO
	ASL A			;POINTER TO WORD
	MOV .FLDSC(A),A		;FILE DESCRIPTOR
	MOVB D,RDBYTE		;CREATE ONE-BYTE "BUFFER"
	SYS WRITE
	#RDBYTE
	1
	TST A			;-1 IF ERROR, 0 IF NO BYTES WRITTEN, 1 IF ONE WRITTEN
	BLE .WRTDF		;ANYTHING BUT 1 IS BAD
	RTS PC
.ENDC

.WRTDF:	MOV @CURCPE,A		;GET ERROR ROUTINE
	BEQ .WRDF1		;NONE
	JMP (A)
.WRDF1:	TST CHAN		;ONLY DELETE ON CHANNEL ZERO
	BNE 1$
	TST WRTFLG		;AND THEN, ONLY IF WRITING WORKSPACE
	BEQ 1$
.IFZ UNIX
	SAVE <,,@CURCPP>
	BIS #.FADL,(P)
	.INVOK
.ENDC
1$:	JSR PC,.CLSCH
	ERROR+GDE

.IFZ UNIX
.WRTUB:	SAVE <D,@CURCPP>
	.BYTO
	BEQ .WRTDF
	RTS PC
.ENDC

.REDCL:
.WRTCL:
.IFZ UNIX
	TST CHAN		;ONLY CHANNEL ZERO IS BUFFERED
	BNE .CLSCH
	JSR PC,WRTBUF		;WRITE OUT THE BUFFER IF NEEDED
.ENDC
.CLSCH:	JSR PC,FLSCUR
	SEZ
	RTS PC

FLSCUR:	SAVE A
.IFNZ UNIX
	MOV CHAN,A		;GET LOGO CHANNEL NUMBER
	ASL A			;MAKE WORD POINTER
	MOV .FLDSC(A),A		;GET UNIX FILE DESCRIPTOR
	SYS CLOSE		;CLOSE IT
.IFF
	MOV @CURCPP,A
	JSR PC,DELCAP
.ENDC
	REST A
	CLR @CURCPP
	CLR @FILFLP
	RTS PC

..FILP:	MOV #PRINT,A
	BR ..FIL2
.FILET:	MOV #TYPE,A
	BR .FILP2
.FILEP:	MOV #PRINT,A	;PRINT INTO THE FILE
.FILP2:	JSR PC,CHNSE1
..FIL2:	BIT #FILWRT,@FILFLP	;IS FILE OPEN FOR WRITE?
	BNE 1$		;YES
	ERROR+NFO	;NO, INVALID FILE NAME
1$:	SPUSH PCHR
	MOV #.WRTEC,PCHR
	MOV #1,D	;ONE ARG FOR PRINT OR TYPE
	JSR PC,(A)	;PRINT OR TYPE THE CHARACTERS
.FILP1:	SPOP PCHR
	SEZ
	RTS PC

.FTYO:	JSR PC,CHNSE1
	BIT #FILWRT,@FILFLP	;IS FILE OPEN FOR WRITE?
	BNE 1$		;YES
	ERROR+NFO	;NO, INVALID FILE NAME
1$:	JSR PC,G1NARG
	MOV B,D
	JSR PC,.WRTEC
	SEZ
	RTS PC

.FILEW:	JSR PC,CHNSE1
	BIT #FILRED,@FILFLP	;OPEN FOR READ?
	BNE 1$		;YES
	ERROR+NFO
1$:	JSR PC,G1NARG	;GET AN ARGUMENT
	TST B		;ANYTHING
	BGT .FILW2	;YES, AND POSITIVE, GOOD STUFF
	BEQ .FILW4	;AT LEAST IT IS 0 
	ERROR+WTA	;NEGATIVE IS USELESS
.FILW4:	SPUSHS #LSTR	;RETURN EMPTY WORD
.FILW1:	CLZ
	RTS PC
.FILW2:	JSR PC,BLSTI	;INIT THE LSTR
1$:	JSR PC,.READC	;GET A CHACTER
	BIT #FILRED,@FILFLP	;IS IT EOF?
	BEQ .FILW3	;YES, RETURN WHAT WE GOT
	JSR PC,BLST	;ADD IT
	SOB B,1$
.FILW3:	JSR PC,BLSTF	;FINISH IT
	TST TOPS	;DID WE PUT ANY CHARS IN?
	BEQ .FILW4	;NO RETURN THE EMPTY WORD
	SPUSHS TOPS
	CLR TOPS
	BR .FILW1	;AND RETURN

.FILER:	JSR PC,CHNSE0
	BIT #FILRED,@FILFLP	;IS FILE OPEN FOR READ?
	BNE 1$		;YES
	ERROR+NFO	;NO,INVALID FILE NAME
1$:	SPUSH GCHR
	MOV #.READC,GCHR
	JSR PC,RQUEST
	SPOP GCHR
	CLZ
	RTS PC

.FTYI:	JSR PC,CHNSE0
	BIT #FILRED,@FILFLP	;IS FILE OPEN FOR READ?
	BNE 1$		;YES
	ERROR+NFO	;NO, INVALID FILE NAME
1$:	JSR PC,.READC
	MOV D,B
	BIC #-400,B
	JMP R1NARG

.CLOSF:	JSR PC,CHNSE0
.CLOS0:	MOV #TYI,GCHR	;RESET IT FOR TTY INPUT
	CLR REDFLG	;CLEAR READFLAG
	CLR WRTFLG	;CLEAR WRITE FLAG
CLOSF:	BIT #FILWRT,@FILFLP	;IS FILE OPEN FOR WRITE?
	BEQ 1$
	JMP .WRTCL
1$:	BIT #FILRED,@FILFLP	;IS IT OPEN FOR READ?
	BEQ 2$
	JMP .REDCL
2$:	RTS PC


.FILEO:	JSR PC,CHNSE0
	TST @FILFLP		;IS A FILE OPEN
	BEQ 1$			;NO
	JMP RTTRUE		;RETURN TRUE
1$:	JMP RTFALS		;RETURN FALSE

LOGIN:
.IFZ UNIX
	JSR PC,.USE		;GO DO A USE OF THE GIVEN ARGUMENT
.ENDC
				;THEN FALL IN TO READ THE INIT FILE IF ANY

RINIT:	JSR PC,SETCH0
.IFZ UNIX
	JSR PC,COPDEF
.ENDC
	MOV #NAME,A
.IFNZ UNIX
	MOV #"LO,(A)+		;UNDER UNIX, "INIT" IS TOO VAGUE
	MOV #"GO,(A)+
.ENDC
	MOV #"IN,(A)+
	MOV #"IT,(A)+
	CLR (A)
	JSR PC,FREADR		;TRY TO READ THE FILE
	BEQ RINIT1		;LOSE
	JSR PC,.READ1		;GO READ INTO LOGO
RINIT1:	RTS PC

.IFZ UNIX
;PAGENO = THE UPT SLOT WE CAN USE
;PGADD  = THE PAGE ADDRESS
;WE ALSO HAVE TO GET THE CAPABILITY
;BUFFER= THE ADDRESS OF A BUFFER
;POTREE AND POI ROUTINES

.POTREE:	MOV PC,B				;FLAG ALLOWS LISTING OF INFERIOR DIR'S.
	BR POI.1
.POI:	CLR B					;SUPRESSES LISTING OF INFERIOR DIR'S.
POI.1:	JSR PC,SETCHF
..POI:	CMP DIRCAP,CURCPP	;IF DIRCAP POINTS TO CURCAP, .POI IS BEING USED AS A
	BEQ POI.2	; A COROUTINE FOR .FILER, & WANTS THE OPEN CURCAP DIR TO STAY
	JSR PC,FILCHK	;FILE ALREADY OPNE?
	JSR PC,COPDEF
	MOV @CURCPP,TMPCP
	BNE 1$
	ERROR+NCD
1$:	CLR @CURCPP
POI.2:	CLR A					;RECURSION DEPTH COUNTER
	CMP -(P),-(P)
	SAVE <@DIRCAP>			;GET DISK DATA
	BIS #.FADI,(P)
	$INVOK
	REST <FREEBL,DSKNUM>
	MOV #1,TF7				;USED TO ACCUMULATE TOTAL BLOCKS, ALLOW FOR THIS DIR
	JSR PC,PODIR				;LIST IT
	MOV TF7,A
	JSR PC,PRDN
STLANC
ENGINS <	PRTXT ^\ blocks, \>
ENDENG
FRINS <	PRTXT ^\ blocs, \>
ENDLAN
	MOV FREEBL,A				;NUMBER OF FREE BLOCKS
	JSR PC,PRDN				;PRINT NUMBER OF FREE BLOCKS ON DISK
STLANC
ENGINS <	PRTXT ^\ free blocks on disk #\>
ENDENG
FRINS <	PRTXT ^\ blocs libres sur le disque #\>
ENDLAN
	MOV DSKNUM,A				;DISK NUMBER
	JSR PC,PRDN				;PRINT DISK NUMBER
	PRCR					;AND CAR-RET
DELTMP:	MOV TMPCP,A
	JSR PC,DELCAP
	CLR TMPCP
	RTS PC					;WE ARE DONE
.ENDC				;IFZ UNIX

FILCHK:	TST @FILFLP	;IS FILE OPEN?
	BEQ 1$		;NO
	ERROR+FAO
1$:	RTS PC

.IFZ UNIX
DIRCHK:	SAVE <#FILBLK,#10,@CURCPP>
	BIS #.FARI,(P)
	$INVOK		;FIND OUT IF WE'VE OPENED A FILE OR A DIRECTORY
	BIT #.FADIR,FILBLK+2	;WELL, WHICH?
	RTS PC

;STILL IFZ UNIX
;GIVEN DIRECTORY CAPABILITY, TREE FLAG AND LEVEL

PODIR:	CLR D					;NUMBER OF ENTRY BEING PROCESSED
PODIR0:
PODIR1:	JSR PC,POENTB				;SET ACCESS TO ZERO AND GET ENTRY
	SAVE ENTEOF				;SAVE EOF WORD ON THE STACK
	MOV D,E					;SKIP SOME ENTRIES
	BEQ PODI14
PODIR2:	CMP C,(P)				;CHECK EOF
	BLO PODI10
PODI12:	TST (P)+
	RTS PC					;NO MORE ENTRIES SO RETURN
PODI10:	JSR PC,POENTI
	SOB E,PODIR2				;SKIP ANOTHER ENTRY
	BR PODI14
PODIR3:	CMP C,(P)
	BHIS PODI12
	JSR PC,POENTI				;INPUT AN ENTRY
PODI14:	MOVB ENTRY+1,F				;GET TYPE BYTE
	BIC #177761,F				;GET TYPE FIELD
	SAVE C
	JMP @PODIRT(F)				;DISPATCH TO SERVICE ROUTINE

PODIRL:	BPT					;BUG LINKS NOT IMPLEMENTED
	BR PODIRP				;JUST SKIP THE ENTRY
PODIRS:	TST A					;ENTER HERE FOR SELF ENTRY
	BEQ PODIR7				;DON'T PRINT "I" AT TOP LEVEL
	MOV A,F					;LEVEL IS IN A
	SUB #2,F				;PRINT LEVEL-2 SPACES	
PODIR4:	BEQ PODIR6				;DON'T TRY TO PRINT ZERO SPACES
PODIR5:	JSR PC,PODIRB				;PRINT (F) BLANKS
PODIR6:	SAVE D
	MOV #'I,D
	JSR PC,@PCHR
	SPACE
	REST D					;INDICATES INFERIOR DIRECTORY
PODIR7:	MOV #-1,E
	JSR PC,PODIRI				;PRINT NAME,VERSION, AND SIZE
PODIRP:	INC D					;ENTER HERE FOR PARENT TYPE ENTRY
	REST C
	BR PODIR3				;DO THE NEXT ENTRY



;STILL IFZ UNIX
PODIRF:	MOV A,F					;ENTER HERE FOR FILES
	ADD #2,F				;NUMBER OF SPACES BEFORE NAME
	JSR PC,PODIRB				;PRINT THE BLANKS
	JSR PC,PODIRN
	BR PODIRP				;PRINT REST OF INFORMATION
PODIRD:	INC TF7					;ALLOW FOR BLOCK TAKEN BY THE DIR
	TST B					;ENTER HERE FOR DIRECTORY ENTRY
	BNE PODIR8
	MOV A,F					;NUMBER OF PRECEDING SPACES
	BR PODIR4				;SUPPRESS LISTING OF INFERIOR DIRECTORY
PODIR8:	MOV D,(P)
	SAVE <@DIRCAP>				;SAVE THE WORLD
	ADD #2,A				;INCREMENT THE LEVEL
	SAVE <#-1,#0,@DIRCAP>
	BIS #.CPYCP,(P)				;COPY THE CAP.
	.INVOK
	BNE 1$
	ERROR+GDE
1$:	MOV @DIRCAP,@CAPSP
	ADD #2,CAPSP
	SPOP @DIRCAP
	MOV #ENNAME,E				;PUT NAME FOR MUTATE INTO BUFFER
PODIR9:	TSTB (E)+
	BPL PODIR9				;MOVE THE NAME
	BICB #200,-1(E)				;CLEAR BIT IN LAST CHARACTER
	SAVE <A,PCHR>
	MOV TVERN,A
	BLT 1$
	MOVB #'#,(E)+
	MOV #POPRN,PCHR
	JSR PC,PRDN
1$:	REST <PCHR,A>
	CLRB (E)				;ZERO BYTE AT END OF ASCII STRING
	CLR -(P)
	SAVE <#ENNAME,@DIRCAP>
	BIS #.FAMU,(P)				;MUTATE THE NEW CAP.
	.INVOK
	BNE 2$
	ERROR+GDE
2$:	JSR PC,PODIR				;LIST INFERIOR
	CMP -(P),-(P)
	SAVE <@DIRCAP>
	BIS #.DELCP,(P)				;DELETE THE CAP.
	$INVOK
	SUB #2,CAPSP
	CLR @CAPSP
	REST <@DIRCAP,D>				;RESTORE WORLD
	SUB #2,A				;DECREMENT THE LEVEL
	INC D
	REST C
	JMP PODIR0				;CONTINUE LISTING THIS DIRECTORY

POPRN:	MOVB D,(E)+
	RTS PC


;PRINT (F) BLANKS ON THE OUTPUT DEVICE

PODIRB:	SAVE <D>
	MOV #' ,D				;PUT ASCII BLANK IN D
PODIB1:	JSR PC,@PCHR				;PRINT A CHARACTER
	SOB F,PODIB1
	REST <D>
	RTS PC

;STILL IFZ UNIX
POSET:	SAVE <C,#0,@DIRCAP>
	BIS #.FASP,(P)
	$INVOK
	RTS PC

POENTB:	CLR C					;SET TO BEGGINING OF DIR
	JSR PC,POSET
POENTI:	SAVE E
	SAVE <#ENTRY,#-4,@DIRCAP>
	.BLKI					;INPUT THE HEADER WORD AND VERN #
	BNE 2$
3$:	ERROR+GDE
2$:	MOV #TVERN+2,E				;WHERE THE REST OF THE THING GOES
	MOV ENTRY,F				;HEADER WORD
	BLT 1$					;SKIP IF EOF, TIME+ DATE EXIST
	MOV #ENNAME,E				;NOT DATE+TIME, REST OF ENTRY GOES HERE
	CLR DATE
1$:	INC F
	BIC #177401,F				;SIZE OF THIS ENTRY
	ADD F,C
	SAVE E
	SUB #4,F				;ALREADY READ THIS MUCH
	NEG F
	SAVE <F,@DIRCAP>
	SUB F,E					;GET THE END ADDRESS OF THE BUFFER
	SUB #ENTEND,E
	BLE 4$					;THERE IS ROOM FOR ALL OF IT
	ADD E,2(P)				;CAN ONLY READ PART OF IT IN
4$:	.BLKI					;INPUT THE HEADER WORD AND VERN #
	BEQ 3$					;DISK ERROR
	TST E					;DID WE READ IT ALL IN?
	BLE 5$					;YUP
	JSR PC,POSET
5$:	REST E
	RTS PC


;STILL IFZ UNIX
;PRINT OUT A LINE OF INFORMATION ABOUT FILE
;(C)= POINTS TO ENTRY TO PRINT
;SAVE REGISTERS A,B,D

PODIRN:	MOV ENTEOF,F
	ADD #1777,F				;ROUND UP TO BLOCK BOUNDARY
	CLR E					;CLEAR HIGH PART
	ASHC #3,E
	ADD ENTEFH,E				;PAGE NUMBER
	ASHC #3,E				;NOW LEGNTH IN BLOCKS
PODIRI:	SAVE <A,D,E>			;SAVE LEGNTH AND VERSION NUMBER
	MOV #ENNAME,E
2$:	MOVB (E),D
	BIC #177600,D				;CLEAR TOP BIT OF BYTE
	CMPB #'#,D
	BEQ 8$
	CMPB #'",D
	BEQ 8$
	CMPB #'>,D
	BEQ 8$
	CMPB #'<,D
	BNE 9$
8$:	MOV #'",D
	JSR PC,@PCHR
	MOVB (E),D
9$:	JSR PC,@PCHR				;PRINT A CHARACTER
	TSTB (E)+				;LAST BYTE HAS 200 BIT SET
	BPL 2$
	MOV TVERN,A
	BLT 3$				;NO VERSION NUMBER
	MOV #'#,D
	JSR PC,@PCHR
	JSR PC,PRDN				;PRINT THE VERSION NUMBER
3$:	REST <A>				;PRINT THE BLOCK LEGNTH
	BLT 1$
	SPACE
	SPACE
	ADD A,TF7				;ACCUMULATE TOTAL
	JSR PC,PRDN
1$:	JSR PC,PRDAT
	JSR PC,.CRLF
	REST <D,A>
	RTS PC					;DONE WITH THIS ENTRY

;STILL IFZ UNIX
;PRDAT PRINTS DATE & TIME, IF ANY
PRDAT:	JSR F,ACSAV				;SAVE ALL REGISTERS  
	MOV #11,D				;TAB
	JSR PC,@PCHR
	MOV DATE,E				;PUT DATE IN E 
	BEQ 5$					;IF NO DATE & TIME, RETURN
	CMP #-1,E				;SEE IF INITIALIZED
	BNE PRDAT1				;GO ON IF INITIALIZED
	SPACE
	MOV #'-,D				;PRINT " -" IF NOT
	JSR PC,@PCHR
5$:	JSR F,ACRES				;RESTORE ALL REGISTERS
	RTS PC

;CONTROL INSTRUCTIONS FOR PRDAT2
PRDAT1:	MOV #DTTAB,B				;POINT TO BEG. OF DTTAB	
	JSR PC,PRDAT2				;PRINT DATE IN E
	MOV TIME, E				;PUT TIME IN E				
	JSR PC,PRDAT2				;PRINT TIME
	JSR F,ACRES				;RESTORE ALL REGISTERS
	RTS PC

;TABLE DRIVEN ROUTINE TO PRINT DATE & TIME SEGMENT BY SEGMENT
	;ZTYPE & PRDN TAKE ARGUMENT IN A 
PRDAT2:	MOV #3,C				;C IS LOOP INDEX
PRDAT3:	MOV E,A					;PUT DATE OR TIME IN A
	ASH (B)+,A				;SHIFT QUANTITY TO LOW BYTE
	BIC (B)+,A				;ZAP ALL BUT RELEVANT BITS
	ASH (B)+,A				;MULT. FACTOR: 0 EXCEPT FOR SEC/2
	CMP #3,C				;FIRST TIME THRU LOOP?
	BEQ 1$				
	JSR PC,ZPRDN				;PRINT WITH LEADING 0 IF < 10
	BR 2$
1$:	JSR PC,PRDN				;PRINT WITHOUT LEADING 0 IF < 10	
2$:	MOV (B)+,A				;PICK UP DELIMITER CHARACTER
	MOV A,D					;PUT CHARACTER IN D
	JSR PC,@PCHR				;PRINT CHARACTER
	SOB C,PRDAT3				;DO NEXT SEGMENT
PRDAT4:	RTS PC
.IFF
;UNIX VERSION OF DIRECTORY LISTING
.POI:	SYS FORK
	BR .POI1
	MOV A,C			;SAVE KID
1$:	SYS WAIT
	CMP A,C			;RIGHT PROCESS?
	BNE 1$
	RTS PC

.POI1:	SYS EXEC
	#.LS			;ASCIZ "/bin/ls"
	#.LSARG			; ARGUMENT VECTOR
	MOV #1,A		;INDICATE FAILURE TO PARENT
	SYS EXIT

.POTREE:
	SYS FORK
	BR .POTR1
	MOV A,C			;SAVE KID
1$:	SYS WAIT
	CMP A,C			;RIGHT PROCESS?
	BNE 1$
	RTS PC

.POTR1:	SYS EXEC
	#.FIND			;ASCIZ "/bin/find"
	#.FIARG			; ARGUMENT VECTOR
	MOV #1,A		;INDICATE FAILURE TO PARENT
	SYS EXIT

.ENDC				;END UNIX CONDITIONAL FOR POI,POTREE



.CRIND:
.IFZ UNIX
	JSR PC,SETCH0
	JSR PC,DSET	;SET THE DIRECTORY
	JSR PC,NNFNGT	;GET THE NAME
	SAVE <,#NAME,@CURCPP>
	BNE 9$
	ERROR+NCD
9$:	BIS #.FAAD,(P)
	.INVOK		;TRY TO CREATE THE DIRECTORY
	BNE 1$
	ERROR+GDE
1$:	SAVE <#0,@CURCPP>
	.WRDO		;MAKE FILE FILE 1 BLOCK LONG
	BNE 2$
3$:	ERROR+GDE
2$:	SAVE <,,@CURCPP>
	BIS #.FAMD,(P)
	.INVOK		;MAKE INTO A DIR
	BEQ 3$
	JMP FLSCUR
.IFF
	JSR PC,SETNM
	SYS FORK
	BR .CRIN1
	MOV A,C			;SAVE KID
1$:	SYS WAIT
	CMP A,C			;RIGHT PROCESS?
	BNE 1$
	RTS PC

.CRIN1:	SYS EXEC
	#.MKDIR			;ASCIZ "/bin/mkdir"
	#.MKARG			; ARGUMENT VECTOR
	MOV #1,A		;INDICATE FAILURE TO PARENT
	SYS EXIT
.ENDC


.IFNZ LPF
	.SBTTL LINEPRINTER AND PAPER TAPE ROUTINES
.IFNZ SITS			;NO TAPE PUNCH
WRITEP:	MOV #.TPCAP*400,F	;CREATE TAPE PUNCH
	BR LPRIN1
.ENDC
LPRINT:	JSR PC,LPSEL		;GET MW OR LP
LPRIN1:	JSR PC,SETCH0
	JSR PC,FILCHK
	TST D		;ZERO ARGS?
	BNE LPRINF	;JUST WRITE OUT FILE
	JSR PC,OPNDEV	;OPEN LPT OR PAPERTAPE
	JSR PC,FORMFD
	MOV PC,WRTFLG
	MOV #TMPOUT,PCHR
.IF NZ LSI
	CMP #.TTCAP*400,F	;WAS IT THE MULTIWRITER?
	BNE 1$			;NOPE
	MOV #MWOUTC,PCHR
.ENDC
1$:	JSR PC,SHOWAL
	JSR PC,FORMFD
	MOV #TYO,PCHR
	JSR PC,DELTMP
	CLR WRTFLG
	SEZ
	RTS PC

LPRINF:	CMP #1,D	;EXACTLY 1?
	BEQ 1$		;YUP
	ERROR+WNA
1$:	SAVE F
	JSR PC,.READF
3$:	REST F
	JSR PC,OPNDEV
LINEP1:	JSR PC,FORMFD	;FORMFEED IF LPT
;falls through

;falls in
TRNBUF:	TST BRAKE
	BNE 1$		;IF BRAKE, FINISH 
	JSR PC,NEWBLK	;GET A DISK BLOCK
	MOV DBUFP,A
	MOV A,B
	SUB DBDEND,A	;GET NEGATIVE COUNT OF BYTES
	BEQ 1$
.IF NZ LSI
	CMP #.TTCAP*400,F	;WAS IT THE MULTIWRITER?
	BNE 10$			;NOPE
	NEG A
11$:	MOVB (B)+,D
	JSR PC,MWOUTC
	SOB A,11$
	BR TRNBUF
10$:
.ENDC
	SAVE <B,A,TMPCP>	;OUTPUT TO THE LINEPRINTER
	.BLKO			;OUTPUT THE BLOCK
	BNE TRNBUF		;NO ERROR
	JMP LPTERR
1$:	JSR PC,FORMFD
DELWLD:	JSR PC,DELALC	;DELETE ALL DISK CAPS
	SEZ		;NO OUTPUT
	RTS PC

LPSEL:	MOV #.LPCAP*400,F	;CREAT LINEPRINTER
.IF NZ LSI
	TST MWTTY		;DO WE HAVE MULTIWRITER FOR A TTY?
	BEQ 1$			;NOPE
	MOV #.TTCAP*400,F	;CREATE A TTY INSTEAD
	CLR MWFLAG
	MOV #200.,MWCNT
.ENDC
1$:	RTS PC

.IFZ CPF
CPSEL:	CPDSEL:
FORMFD:	CMP #.LPCAP*400,F
	BNE 1$
	SAVE <#14,TMPCP>	;OUTPUT A FORMFEED
	.BYTO
	BEQ LPTERR
2$:	RTS PC
1$:	CMP #.TPCAP*400,F
	BNE 2$
	SAVE A
	MOV #100.,A
3$:	SAVE <#0,TMPCP>
	.BYTO
	BEQ LPTERR
	SOB A,3$
	REST A
	RTS PC
.IFF
FORMFD:	RTS PC


.ENDC
.IF NZ LSI
MWDRIB:	MOV #DRIBFL,MWCOUT
	BR MWOUT
MWOUTC:	MOV #TMPOUT,MWCOUT
MWOUT:	JSR PC,@MWCOUT		;OUTPUT THE CHARACTER
	CMP #15,D		;CR?
	BNE 1$			;NOPE
	CLR LPPOS		;PUT THE PRINTER HEAD BACK TO ZERO
	INC LPLCNT
	SAVE D
	MOV #12,D
	JSR PC,@MWCOUT
	REST D
	DEC MWCNT
	BR 2$
1$:	INC LPPOS		;ONE MORE FROB ON PAPER
	CMP LPPOS,LPLEN		;PAST LINE END?
	BLT 2$			;NOPE
	SAVE D
	MOV #15,D
	JSR PC,MWOUT
	REST D
2$:	DEC MWCNT		;TIME TO SYNC UP?
	BGT 4$			;NOPE
	MOV #200.,MWCNT
	SAVE D
	MOV #3,D
	JSR PC,@MWCOUT		;SEND THE SYNC CHAR
	REST D
	TST MWFLAG		;HAVE WE ALREADY SENT ONE SYNC?
	BEQ 3$			;NOPE
	SAVE <D,F>
7$:	CMP #TMPOUT,MWCOUT	;MW ON TMPCAP?
	BNE 5$			;NOPE
	MOV TMPCP,F
	JSR PC,MWACKI
	BR 6$
5$:	SAVE <B,CHAN>
	JSR PC,SETC17
	MOV @CURCPP,F
	JSR PC,MWACKI
	REST B
	JSR PC,SETCHN
	REST B
6$:	REST <F,D>
3$:	MOV PC,MWFLAG
4$:	RTS PC

MWACKI:	SAVE A
	MOV #10000.,A
1$:	SAVE <,,F>
	BIS #.TTPEK*400,(P)
	$INVOK
	TST (P)+
	BGE 2$
	SOB A,1$
	CMP #TMPOUT,MWCOUT
	BEQ 5$
	REST A
	CMP -(P),-(P)
	JMP DRIBER
5$:	JMP LPTERR
2$:	SAVE F
	$BYTI
	CMP #6,(P)+
	BNE 1$
3$:
;	SAVE <,,F>
;	BIS #.TTPEK*400,(P)
;	$INVOK
;	TST (P)+
;	BLT 4$
;	SAVE F
;	$BYTI
;	TST (P)+
;	BR 3$
4$:	REST A
	RTS PC
.ENDC

TMPOUT:	SAVE <D,TMPCP>
	.BYTO
	BEQ LPTERR
	RTS PC

LPTERR:	JSR PC,DELWLD	;DELETE THE WORLD
	ERROR+DNR	;DEVICE NOT READY
OPNDEV:	JSR PC,DELTMP
	SAVE <#-1,MWTTY,F>	;OPEN SOME DEVICE. IF IT IS THE MULTIWRITER WE HAVE THE TTY #
	.INVOK
	BNE 2$		;CANT
	ERROR+DIU
2$:	REST TMPCP
.IF NZ LSI
	CMP #.TTCAP*400,F	;WAS THAT THE MW?
	BNE 1$			;NOPE
	SAVE <,#.TIMGO+.TIMGI,TMPCP>	;SET THE STATUS TO IMAGE IN AND OUT
	BISB #.TTMOV,1(P)	;DO A MOVE INTO THE STATUS WORD
	$INVOK
.ENDC
1$:	RTS PC
.ENDC			;END LSICOND

.IFNZ UNIX
LPRINT:	CMP #1,D		;MUST HAVE A FILE ARG
	BEQ 1$			;OK
	ERROR+WNA		;(SITS LOGO TAKES 0 ARGS BUT NOT UNIX)
1$:	JSR PC,SETNM		;READ FILENAME TO PRINT
	SYS FORK
	BR .LPRI1
	MOV A,C			;SAVE KID
2$:	SYS WAIT
	CMP A,C			;RIGHT PROCESS?
	BNE 2$
	RTS PC

.LPRI1:	SYS EXEC
	#.LPR			;ASCIZ "/bin/lpr"
	#.LPARG			; ARGUMENT VECTOR
	MOV #1,A		;INDICATE FAILURE TO PARENT
	SYS EXIT
.ENDC

;ROUTINES FOR HANDLING MULTIPLE CHANNELS
;SET TO A FREE CHANNEL
SETCHF:	SAVE <B,C>
	MOV #NCHNS*2+FILFLG-2,B	;AVOID USING DRIBBLE CHANNEL
	MOV #NCHNS-1,C
1$:	TST -(B)
	BEQ 2$
	SOB C,1$
	ERROR+IFN
2$:	SUB #FILFLG,B
	ASR B
	REST C
	BR SETCH1

SETC17:	SAVE B
	MOV #NCHNS-1,B
	BR SETCH1

SETCH0:	SAVE B
	CLR B
SETCH1:	JSR PC,SETCHN
	REST B
	RTS PC

SETCHN:	CMP B,#NCHNS
	BLO 1$
	ERROR+WTA
1$:	MOV B,CHAN	;SET CHANNEL NUMBER
	ASL B
	ADD #CURCAP,B
	MOV B,CURCPP
	ADD #FILFLG-CURCAP,B
	MOV B,FILFLP
	ADD #FILERR-FILFLG,B
	MOV B,CURCPE
	RTS PC

;COME HERE TO SET CHANNEL WHEN DEFULAT # OF ARGS IS 0
CHNSE0:	CLR C
	BR CHNSET

;COME HERE WHEN DEFAULT IS 1 ARG
CHNSE1:	MOV #1,C
CHNSET:	MOV D,B			;NUMBER OF ARGS
	SUB C,B			;GET NUMBER OF EXTRA ARGS SUPPLIED
	BEQ 1$			;IF ZERO DO A SETCHN TO 0
	BLT 2$			;IF NEGATIVE ERROR OUT
	DEC B			;THERE SHOULD BE EXACTLY ONE EXTRA
	BNE 2$			;NOPE, ERROR
3$:	JSR PC,G1NARG		;GET CHANNEL NUMBER
1$:	JMP SETCHN		;SET THE CHANNEL
2$:	ERROR+WNA

.IFZ UNIX
DELCPS:	MOV #NCHNS-1,C
1$:	MOV C,B
	JSR PC,SETCHN
	JSR PC,CLOSF		
	DEC C
	BGE 1$
.IFNZ LSI
	MOV #ROTCPS,A
2$:	JSR PC,DELCPC
	TST (A)+
	CMP #ROTCPS+<NDISKS*2>,A
	BNE 2$		
	CLR DEFROT	;NO LONGER ANY DEFAULT ROOT
.ENDC
	RTS PC
.ENDC

FILPOS:	JSR PC,CHNSE0
	TST @FILFLP
	BNE 9$
	ERROR+NFO
9$:
.IFZ UNIX
	TST CHAN	;BUFFERED?
	BEQ 2$		;YES
	SAVE <,,@CURCPP>
	BIS #.FARP,(P)	;READ THE POINTER
	$INVOK
	REST <A,B>	;GOT, RETURN IT
	BR 1$
2$:	MOV DBUFP,B	;GET THE POINTER INTO THE BUFFER
	SUB #DBUF,B	;GET THE NUMBER OF BYTES TO THE POINTER
	MOV DBUFST,A	;GET THE HIGH ORDER START OF THE BUFFER
	ADD DBUFST+2,B	;ADD ON THE LOW ORDER
	ADC A
1$:
.IFF
	MOV CHAN,A		;GET LOGO CHANNEL NUMBER
	ASL A			; AS WORD POINTER
	MOV .FLDSC(A),A		;GET UNIX FILE DESCRIPTOR
	SYS LSEEK		;SEEK TO CURRENT POSITION
	0
	0
	1			;RETURN WITH 2-WD POINTER IN A AND B
.ENDC
FILEO1:	JSR PC,GRBAD	;MAKE NODE UP WITHT THE NUMBER IN IT
	BIS #INUM,C	;POINT TOT HE NUMBER
	JMP ORTC	;RETURN IT

FILEOF:	JSR PC,CHNSE0
	TST @FILFLP
	BNE 9$
	ERROR+NFO
9$:
.IFZ UNIX
	JSR PC,GETFLP		;JUST GET THE EOF
	TST CHAN		;BUFFERED?
	BNE FILEO1		;NOPE, JUST RETURN SYSTEM EOF
	MOV DBUFST,C		;HIGH ORDER START OF BUFFER
	MOV DBUFST+2,D		;LOW ORDER
	MOV DBDEND,E		;GET BUFFER END
	SUB #DBUF,E		;GET COUNT OF BYTES IN BUFFER
	ADD E,D			;ADD IN BUFFER END
	ADC C
	CMP A,C			;IS THE SSYTEM EOF AFTER THE INTERNAL EOF?
	BHI FILEO1		;YES, USE SYSTEM EOF
	BLO 2$			;NO, USE INTERNAL EOF
				;HAVE TO COMPARE LOW PARTS
	CMP B,D
	BHI FILEO1		;SYSTEM EOF IS HIGHER
2$:	MOV D,B
	MOV C,A
	BR FILEO1
.IFF
	MOV CHAN,A		;HO HUM GET UNIX FILDES
	ASL A
	MOV .FLDSC(A),A
	MOV A,C			;SAVE FOR NEXT SYS CALL
	SYS LSEEK		;GET CURRENT POINTER
	0
	0
	1
	MOV A,.LSOF1		;SAVE FOR LATER RESTORE
	MOV B,.LSOF2
	MOV C,A			;GET BACK FILDES
	SYS LSEEK
	0
	0
	2
	MOV A,D			;RING AROUND THE ACS
	MOV C,A			;GET FILDES ONCE MORE
	MOV D,C			;GET POINTER TO EOF IN C,D
	MOV B,D
	SYS INDIR		;SEEK BACK TO WHERE WE WERE
	#.LSEEK
	BR FILEO1
.ENDC


.IFZ UNIX
GETFLP:	SAVE <,,@CURCPP>
	BIS #.FARE,(P)
	$INVOK		;GET FILE LENGTH
	REST <A,B>	;B IS LOW ORDER, A IS HIGH
	RTS PC
.ENDC

.DRIB:	JSR PC,SETC17
.IFNZ UNIX
	MOV #1,.APMOD		;ONLY ALLOW WRITING
.ENDC
	JSR PC,.OPNAX
.DRIB1:	MOV #DRIBFL,DRIBF
.DRIB2:	MOV #DRIBER,@CURCPE	;SET ERROR ROUTINE
	SEZ
	RTS PC

DRIBER:	MOV #SRTSPC,DRIBF
	CPRTXT <ERROR ON DRIBBLE FILE OUTPUT>
	JSR PC,CLOSF
	CMP (P)+,(P)+	;FLUSH ARGS TO BYTO
	RTS PC		;RETURN TO DRIBFL

.IFNZ CPF
PRTON:	JSR PC,SETC17
	JSR PC,FILCHK
	JSR PC,LPSEL		;MULTIWRITER OR LP
	JSR PC,OPNDEV		;OPEN ON TMPCP
	MOV TMPCP,@CURCPP
	CLR TMPCP
	MOV #FILNDK!FILWRT,@FILFLP
.IF NZ LSI
	TST MWTTY		;MULTIWRITER?
	BEQ .DRIB1		;NOPE
	MOV #MWDRIB,DRIBF
	BR .DRIB2
.IFF
	BR .DRIB1
.ENDC

PRTOFF:
.ENDC
.NODRI:	JSR PC,SETC17
	JSR PC,CLOSF
	MOV #SRTSPC,DRIBF
	SEZ
	RTS PC

	
DRIBFL:	SAVE <B,CHAN>
	JSR PC,SETC17
	JSR PC,.WRTEC
DRIBF1:	REST B
	JSR PC,SETCHN
	REST B
	RTS PC

.IF NZ LSI
MULTIW:	JSR PC,G1NARG
	MOV B,MWTTY
	SEZ
	RTS PC
.ENDC

;COMPARES (A),(B) AND SETS FLAGS AS NEEDED
DBLCMP:	CMP (A),(B)	;COMPARE A AND B
	BNE 1$		;NOT EQUAL, COMPARE ON THE TOP PARTS
	CMP 2(A),2(B)	;COMPARE THE LOWER PARTS
1$:	RTS PC

.SETFI:	JSR PC,CHNSE1
	TST @FILFLP	;ANYTHING OPEN?
	BNE 1$		;YEP
	ERROR+NFO
1$:	JSR PC,G1IARG	;GET THE ARGUMENT TO SET TO
.IF NZ UNIX
	MOV B,.LSOF1		;SAVE ARG IN BLOCK FOR UNIX
	MOV C,.LSOF2
	MOV CHAN,B		;GET FILDES
	ASL B
	MOV .FLDSC(B),A
	SYS INDIR		;SEEK THERE
	#.LSEEK
	BCC 2$			;JUMP IF OK
	ERROR+BDD
2$:	SEZ
	RTS PC
.IFF
	SAVE <C,B>	;SAVE THE NEW POINTER
	MOV P,B		;B POINTS TO THE ARGUMENT
SETFI1:	SAVE <DBUFST+2,DBUFST>	;SAVE THE BUFFER START IN DOUBLE PRECISION
	MOV CHAN,F	;GET THE CHANNEL, AND SEE IF BUFFERED
	BNE SETFI2	;NO, JUST COMPARE THE EOF
	MOV P,A		;B POINTS TO THE END
	JSR PC,DBLCMP	;COMPARE THE START OF THE BUFFER WITH THE ARG
	BHI SETFI2	;FLUSH THE BUFFER, THE ARG IS BEFORE THE BUFFER
	MOV DBDEND,C	;POINTER TO THE END OF THE VALID DATA BYTES
	SUB #DBUF,C	;MAKE IT CORRECT NUMBER OF VALID BYTES
	ADD C,2(P)	;ADD THE NUMBER OF VALID BYTES TO GET THE EOF OF THE FILE
	ADC (P)		;ADD IT ON
	JSR PC,DBLCMP	;COMPARE AGAINST THE END OF THE BUFFER
	BHIS SETFI3	;WE WIN, THE END OF THE BUFFER IS HIGHER THAN THE ARG
SETFI2:	JSR PC,GETFLP	;GET THE EOF INTO A,,B
	MOV A,(P)	;PUT IN THE HIGH ORDER
	MOV B,2(P)	;COMPARE IT AGAINST THE ARG
	MOV P,A		;A POINTS TO THE EOF
	MOV P,B		;B POINTS TO THE ARGUMENT
	CMP (B)+,(B)+
	JSR PC,DBLCMP	;COMPARE THE EOF WITH THE ARGUMENT
	BHIS 1$		;OKAY
	ERROR+BDD
1$:	TST F		;IS IT BUFFERED?
	BNE 2$		;NO
	JSR PC,WRTBUF	;WRITE THE BUFFER
2$:	ADD #4,P	;POP OFF THE END OF BUFFER
	SAVE @CURCPP	;SAVE THE FILE CAPABILITY
	BIS #.FASP,(P)	;SET THE FILE POINTER
	$INVOK
	TST F		;BUFFERED?
	BNE 3$		;NO
	JSR PC,REDBLK	;READ THE BLOCK
3$:	SEZ
	RTS PC		;AND RETURN
SETFI3:	ADD #4,P	;POP OFF THE END OF THE BUFFER
	REST <A,B>	;GET BACK THE ARGUMENT
	SUB DBUFST+2,B	;DOUBLE PRECISION SUBTRACT
	SBC A
	SUB DBUFST,A	;GET THE OFFSET FROM THE START OF THE BUFFER INTO B
	BEQ 1$		;SHOULD BE ZERO (HIGH PART)
	BPT
1$:	ADD #DBUF,B	;GET POINTER INTO DBUF
	MOV B,DBUFP	;SET IT UP
	SEZ
	RTS PC
.ENDC

.IFNZ SITS		;NOT AVAILABLE ON THE LSI-11 RIGHT NOW
LOAD25:	JSR PC,SETCH0
	MOV S,A		;GET POINTER TO THE S PDL
	MOV (A),B	;EXCHANGE THE TWO ARGUMENTS
	MOV 2(A),(A)+
	MOV B,(A)
	JSR PC,UGTTYG	;GET THE USER TTY
	BEQ MYTTY
	SAVE E		;SAVE THE TTY NUMBER
	JSR PC,.READF	;READ THE FILE NAME
	MOV (P),E	;RESTORE THE TTY NUMBER
	MOVB TTYCPS(E),E	;GET THE CAPABILITY NUMBER TO THIS TTY
	BIC #177400,E	;CLEAR OUT THE TOP BYTE
LOAD26:	JSR PC,.READC	;GET A CHARACTER
	CMP #EOFCHR,D	;EOF?
	BEQ LOAD27	;YES
	TST BRAKE	;BREAKING?
	BNE LOAD28	;YES
	SAVE <D,E>	;PUT IT ON THE STACK
	$BYTO		;OUTPUT IT
	BR LOAD26	;CONTINUE UNTIL END OF FILE
LOAD28:	JSR PC,CLOSF	;CLOSE THE FILE
LOAD27:	REST E		;GET BACK TTY NUMBER
	JMP CLOSE1	;CLOSE THE TTY, AND RETURN
MYTTY:	JSR PC,SETTIM
	JSR PC,.POF
	JMP RESTTY
.ENDC

.POFILE:	JSR PC,EVAL
	BNE .POF
	ERROR+UELX


.POF:	JSR PC,SETCH0
	TST @FILFLP	;IS ZERO FREE?
	BEQ 1$		;YUP
	JSR PC,SETCHF	;IF NOT, USE SLOWER UNBUFFERED CHANNEL
1$:	JSR PC,.READF
.POF1:	JSR PC,.READC
	TST BRAKE
	BNE .POF2
	BIT #FILRED,@FILFLP
	BEQ .POF2
	JSR PC,@PCHR
	BR .POF1
.POF2:	JMP CLOSF

.ENDC	;END OF LSICOND

.IFZ UNIX			;THIS IS FOR LIST-FORMAT PATHNAMES
GNWRD:	;INPUT	POINTER TO LIST OF WORDS ON S
	;OUTPUT	-IF LIST IS NOT EMPTY,
	;	 POINTER TO  FIRST OF LIST ON TOP OF S
	;	 POINTER TO BF OF LIST NEXT
	;	 Z WILL BE CLEAR
	;	-IF LIST IS EMPTY, POP S AND SET Z
	;IF F LIST ISNT A WORD, WTA ERROR ISSUED
	JSR F,CACSAV
	MOV @S,B
	BIT #7777,B	;IS LIST EMPTY?
	BEQ GNWRD1
	JSR PC,.LOADB	;NO GET 1ST NODE
	MOV A,@S	;SAVE BF ON S
	PUSHS B		;YES - PUSH FIRST ON S
	JSR F,CACRES
	CLZ
	RTS PC
GNWRD1:	POPS A		;EMPTY LIST QUIT
	JSR F,CACRES
	SEZ
	RTS PC

LSTRCV:	MOV @S,B	;POINTER TO FILE NAME IN B
	MOV #LSTR,A	;DATA TYPE FOR CONVERSION
	JSR PC,CONVER	;MAKE NAME AN LSTR
	BNE 1$
	ERROR+WTA	;INVALID FILE NAME (CONVERSION FAILED)
1$:	JMP SPOPT	;POP THE THING OFF THE STACK

NNFNGT:	MOV #NAME,E
NFNGET:		;INPUT	ADDRESS OF BLOCK IN E
		;	PTR TO LSTR ON S
		;OUTPUT	PUT 1ST 10. CHAR OF LSTR INTO BLOCK
		;	SET 200 BIT IN LAST CHAR, POP S
	JSR F,CACSAV	;SAVE REGISTERS
	JSR PC,LSTRCV	;CONVERT TO LSTR
;	MOV B,@S	;POINTER TO NEW DATA ON STACK (HOPEFULLY THIS IS USELESS)
	BIC #170000,B	;LEAVE DATA TYPE
	MOV B,GNCN	;"GET NEXT CHARACTER" NODE
	MOV #10.,C	;TAKES ONLY THIS MANY CHARACTERS
NFNG1:	JSR PC,GNC	;GET NEXT CHAR
	CMP #15,D	;UGH! (IS IT A CARRIAGE RETURN?)
	BEQ NFNG2	;YES- NO MORE CHARACTERS
	MOVB D,(E)+	;STORE THE NEXT CHARACTER
	MOV D,TEMP
	SOB C,NFNG1	;KEEP GOING UNTIL WE HIT TEN
NFNG2:	CLRB (E)	;CLREAR LAST BYTE
	JSR F,CACRES	;GET BACK THE OLD REGISTERS
	RTS PC
.ENDC				;END IFZ UNIX

.IFNZ LSI&FILDSK
;MAGIC LSI CHAIN COMMAND
.CHAIN:
	JSR PC,LOGBYE	;CLEAN UP WORLD
	MOV P,E
	SUB #40,E	;TAKE SOME PDL SPACE
	SAVE E
	JSR PC,NFNGET	;GOBBLE THE NAME
	RESET		;FLUSH ALL INTERUPTS
	MOV (P),@RMEMT	;PUT POINTER AT THE TOP OF THE WORLD
	MOV (P)+,F	;RANDOM PLACE FOR PDL
	TST -(F)
	JMP 173002
.ENDC
SETNM:		;INPUT	LIST OR WoRD ON S
		;OUTPUT	IF WORD, OUTPUT WORD AND SET Z
		;	IF LIST, OUTPUT LAST AND BL OF LIST ON S
		;		PUT BL ON TOP AND CLEAR Z
		;	OTHERWISE ERROR
.IF NZ FILDSK
	JSR PC,FILCHK
.ENDC
1$:	JSR F,CACSAV	;SAVE REGISTERS
	MOV @S,C	;GET INPUT
	BIT #7777,C
	BNE 2$
	ERROR+IFN	;INVALID FILE NAME
2$:	MOV C,B		;SEE IF IT'S A LIST
	BIC #7777,C
	CMP C,#LIST
	BEQ SETNM1	;YES, IT IS
SETNM2:	JSR F,CACRES	;OK, SET Z AND QUIT
	SEZ
	RTS PC
SETNM1:	
.IFNZ UNIX
	ERROR+IFN
.IFF
	JSR PC,COPYL	;COPY LIST - INPUT IN B
		;OUTPUT IN B;  C POINTS TO LAST NODE IN NEW LIST
		; E POINTS TO 2ND TO LAST NODE
	JSR PC,.LDP2
	MOV A,@S
	MOV E,C
	BEQ SETNM3	;NO BUTLAST
	JSR PC,.LDP1	;FIX UP  LINK
	BIC #7777,A
	JSR PC,.STP1
	BIS #LIST,B
SETNM4:	PUSHS B
	JSR F,CACRES
	CLZ
	RTS PC
SETNM3:	MOV #LSTR,B
	BR SETNM4
.ENDC
