.IF NZ GTL!NDISP!TVS
;	OUTPUT B MOD 360 IN B.
;	ALWAYS OUTPUTS A POSITIVE NUMBER
MOD360:	TST B
	SXT A
	DIV #360.,A		;DIVIDE B BY 360
	TST B			;REM >= 0?
	BGE 1$
	ADD	#360.,B		;IF REMAINDER WAS NEGATIVE, ADD 360 TO IT
1$:	RTS	PC
	;TAKES FNUM POINTED TO BY F, AND PUTS IT IN A NODE
	;RETURNS POINTER TO IT IN B
WHOPIE:	SPUSH C
	MOV (F)+,A	;PUT FNUM IN A AND B
	MOV (F)+,B
	JSR PC,GRBAD	;PUT FNUM IN NODE SPACE
	BIS #FNUM,C	;SET APPROPRIATE TYPE
	MOV C,B		;PUT POINTER IN B
	SPOP C
	RTS PC

.ENDC
 
.IIF NDF LSI,DC LSI,0		;FOR INSERT INTO OLOGO
	.SBTTL 2500 DISPLAY STUFF
	VERSIO
.IFNZ GTL

NOGTL:	CLR GTLDF
.IIF NZ LSI,CLR LSTVEE
	SEZ
	RTS PC

.IIF NDF HOME, HOME:
GTHME:	MOV #GTHOME,B
	JSR PC,GT1WRD		;SEND OUT THE HOME TO THE 2500
GCLXYA:	MOV GTDIZF,GTDIZY	;TURTLE ISN'T DIZZY
	MOV #DCURX,A		;WE WILL CLEAR OUT X, Y AND ANGLE
	MOV #6,C
1$:	CLR (A)+
	SOB C,1$
	BR GTSRTS

GT1WRD:	JSR PC,GTTEST
	CMP #GTUDIS,GTLDF	;DISPLAY?
	BNE GT2NWD		;LET HIM SEND ANYTHING HE WANTS
	CMP GTLEN,GTDLTP	;ABOUT TO HIT SNAPS?
	BLT GT2NWD
	ERROR+TML		;YUP, TOO MANY LINES!
GT2NWD:	INC GTLEN
GTWRD:	JSR PC,GTOUT
GTSRTS:	SEZ
	RTS PC

.IIF NDF SHOWTU, SHOWTU:
GTSHOW:	MOV #GTSTUR,B
	BR GT1WRD

.IIF NDF HIDETU, HIDETU:
GTHIDE:	MOV #GTHTUR,B
	BR GT1WRD

.IIF NDF PENUP, PENUP:
GTPU:	BIS #PENUF,DFLAGS	;SET PEN UP
GTPU1:	MOV #GTPENU,B
	BR GTPENM

.IIF NDF PENDOW, PENDOW:
GTPD:	MOV #GTPEND,B
	BIC #PENUF,DFLAGS	;SET PEN DOWN
GTPENM:	CMP #GTUPLT,GTLDF	;PLOTTER?
	BNE 1$			;NO, IGNORE
.IIF NZ LSI,	JSR PC,PWAIT		;WAIT FOR PLOTTER TO SETTLE
1$:	BR GT1WRD

BLINK:	MOV #GTBLNK,B
	BR GT1WRD

.IIF NDF LAMPON,LAMPON:
GTLON:	MOV #GTLPON,B
	BR GT1WRD

.IIF NDF LAMPOF,LAMPOF:
GTLOFF:	MOV #GTLPOF,B
	BR GT1WRD

USEDIS:
GTLDIS:.IIF NZ LSI,MOV PC,LSTVEE
GTLDI1:	MOV PC,GTLDF		;SAY WE ARE A GTL DISPLAY
	CLR DFLAGS		;FLUSH OLD WRAP AND PEN FLAGS
	CLR GTNEW		;ASSUME NOT NEW
	MOV #GTCS,B		;CLEAR THE SCREEN
	JSR PC,GT2NWD
	CLR B
	SOB B,.			;WAIT FOR THE OLD 2500
	JSR PC,GTWIPE
	MOV #GTRUB+3775,B	;OLD STYLE RUBDIS 3
	JSR PC,GT2NWD		;THIS CROCK CAUSES OLD 2500'S TO IGNORE THE NEXT 3 COMMANDS
	JSR PC,UTURGT
	JSR PC,GETTUR
	BLT 1$
	MOV PC,GTNEW
1$:	JSR PC,UDISGT
GTSRT2:	SEZ
	RTS PC

.IIF NDF STARTT,STARTT:
USETUR:	JSR PC,GTLDIS
UTURGT:	MOV #GTUTUR,B
UDEVGT:	MOV B,GTLDF
	JMP GT1WRD


UDISGT:	MOV #GTUDIS,B
	MOV B,GTLDF
	JSR PC,GT1WRD
	JSR PC,GTWIPE
	JMP GTCLEA

.IIF NDF STRTPL,STRTPL:
USEPLO:	JSR PC,GTLDIS
	MOV #GTUPLT,B
	BR UDEVGT

.IFZ UNIX
GETTUR:	JSR PC,GETTYP		;ANY CHARS?
	BLT 1$
	JSR PC,ONETYI		;EMPTY OUT THE BARFER
	BR GETTUR
1$:	MOV #GTGTST,B		;GET TURTLE STATE
	JSR PC,GT1WRD		;SEND THE COMMAND
	MOV #50.,A
GETTU1:	JSR PC,GETTYP
	BGE 1$
	SOB A,GETTU1
	MOV #-1,D
	RTS PC
1$:	JMP ONETYI

GETTYP:	CMP -(P),-(P)
	SAVE TYICP
	MOVB #.TTPEK,1(P)
	$INVOK		;FIND OUT IF THERE IS A CHARACTER
	TST (P)+	;NEGATIVE IF NONE
	RTS PC
.IFF
GETTUR:	CLR A			;STANDARD INPUT
	SYS GTTY		;GET CURRENT MODES
	#.GTTY
	BCC 1$			;JUMP IF OK (PRIMARY INPUT IS TTY)
	MOV #-1,D		;BAD, CAN'T GET TO DISPLAY TURTLE
	RTS PC
1$:	SYS STTY		;SET MODES: NOOP BUT WAITS FOR IDLE
	#.GTTY			; AND FLUSHES UNREAD INPUT
	MOV #GTGTST,B		;COPIED FROM SITS VERSION
	JSR PC,GT1WRD
	SYS SIGNAL		;PREPARE TO TAKE ALARM INT
	14			;SIGALRM
	1			;IGNORE (ODD NUMBER)
	MOV #2,A		;1 TO 2 SECOND DELAY
	SYS ALARM		;ROLLING
	JSR PC,ONETYI		;CAN RETURN -1 IF ALARM TIMES OUT
	CLR A			;GOT SOMETHING, NOW CLEAR CLOCK
	SYS ALARM
	RTS PC
.ENDC

.IIF NDF CLEARS, CLEARS:
GTCLEA:	MOV #GTCS,B
	JSR PC,GTOUT		;REALLY OUTPUT THE CLEAR
	BIC #PENUF,DFLAGS	;SET PEN DOWN
	CLR GTLEN		;THE DISPLAY LIST IS ZERO LENGTH
	JSR PC,GCLXYA		;CLEAR X Y AND ANGLE
	JMP CHINIT		;INIT DLIST-CHANGE STUFF

.IIF NDF WIPECL, WIPECL:
GTWIPE:	MOV #GTSLEN,GTSNBT	;FLUSH ALL SNAPS
	MOV #GTSLEN-10.,GTDLTP	;SET TOP OF DISPLAY LIST
	TST GTNEW
	BEQ 1$			;OLD
	CLR GTSNBT		;SNAP BOTTOM ALWAYS (RELATIVE) ZERO
	MOV #GTMNDS-10.,GTDLTP	;TOP IS HERE (AND STAYS THERE!)
1$:	BR GTSRT2		;AND RETURN

;dpointer routines

dpoint:	cmp gtdptr,#gtdtop	;out of dpointer index slots?
	blos 1$
	error+wta
1$:	mov gtdptr,b
	bis #gtdpoi,b		;send dpointer command to 2500
	jsr pc,gtout
	mov gtdptr,b		;inc dpointer index and return old index
	inc gtdptr
	jmp r1narg

change:	mov s,f			;swap change's 2 args
	mov (f),-(p)
	mov 2(f),(f)
	mov (p)+,2(f)
	
	jsr pc,g1narg		;1st arg is dlist pointer
	cmp b,gtdptr
	blo 2$
	error+wta
2$:	bis #gtchan,b
	jsr pc,gtout		;send the change command to the 2500

	jsr pc,run		;now run the sentence given by the 2nd arg

	mov #gtendc,b		;send the endch command to the 2500
	jsr pc,gtout
	sez			;no deposit, no return
	rts pc

chinit:	clr gtdptr
	rts pc

SPIN:	MOV #GTSPIN,F
GT11BD:	MOV PC,GTDIZY		;TURTLE IS DIZZY
GT11BT:	JSR PC,G1NARG
GT11B1:	JSR PC,GTTEST
	SAVE B
	MOV B,C
	BIC #1777,C		;CLEAR GOOD BITS
	ASH #-10.,C		;EXTEND SIGN
	BEQ 1$			;ZERO
	INC C
	BEQ 1$			;1
	ERROR+WTA
1$:	BIC #174000,B		;CLEAR UNUSED BITS
	BIS F,B
	JSR PC,GT1WRD
	REST B
	SEZ
	RTS PC

MOVE:	MOV #GTMOVE,F
	BR GT11BD

.IIF NDF SETHEA, SETHEA:
GTSETH:	JSR PC,G1NARG
GTSET1:	MOV #GTSHED,F
	JSR PC,GT11B1
	MOV B,DCURA
GTSRT1:	JMP GTSRTS

.IIF NDF RIGHT, RIGHT:
GTRIGH:	JSR PC,G1NARG
GTRTLT:	MOV #GTRT,F
	JSR PC,GT11B1
	MOV DCURA,A
	ADD A,B
	JSR PC,MOD360
	MOV B,DCURA
	BR GTSRT1

.IIF NDF LEFT, LEFT:
GTLEFT:	JSR PC,G1NARG
	NEG B
	BR GTRTLT

.IIF NDF FORWAR, FORWAR:
GTFORW:	JSR PC,G1ARG
GTFDBK:	SETI
	SETF
	LDF FA,FC		;TEMP INTO FC
	TST GTDIZY		;TURTLE ALREADY DIZZY?
	BNE 1$
	STF FA,-(P)
	LDCIF DCURA,FA
	SUBF #41664,FA
	NEGF FA			;GET 90-HEADING
	STF FA,-(P)		;SAVE "REAL" ANGLE
	JSR PC,SINDEG		;GET SIN OF ANGLE
	STF FA,FB		;SAVE SINE IN FB
	LDF (P)+,FA
	STF FB,-(P)
	JSR PC,COSDEG
	LDF (P)+,FB
	LDF (P)+,FC		;GET BACK LENGTH
	MULF FC,FA		;GET X OFFSET
	MULF FC,FB		;AND Y OFFSET
	ADDF DCURX,FA
	ADDF DCURY,FB
	SETI
	CMP #GTUPLT,GTLDF	;PLOTTER?
	BEQ 9$			;ALWAYS WRAP
	CMP #GTUTUR,GTLDF	;TURTLE?
	BEQ 1$			;NEVER WRAP
9$:	BIT #WRAPF,DFLAGS
	BNE 1$
	STF FA,FF
	LDCIF #200.,FD
	JSR PC,GTCHKB
	STF FB,FF
	JSR PC,GTCHKB
1$:	STCFI FC,B		;BACK TO INTEGER
.IFNZ LSI
	CMP #GTUPLT,GTLDF	;PLOOTER?
	BNE 2$
	JSR PC,PLOTTM		;IF PLOTTER, COMPUTE TIME TAKEN
.ENDC
2$:	MOV #GTFD,F
	JSR PC,GT11B1
	STF FA,DCURX
	STF FB,DCURY
	SEZ
	RTS PC

GTCHKB:	ABSF FF
	CMPF FF,FD		;IS IT < 400.0?
	CFCC
	BLE 1$
	ERROR+OOB
1$:	RTS PC

.IIF NDF BACK, BACK:
GTBACK:	JSR PC,G1ARG
	NEGF FA
	BR GTFDBK

GT10CH:	SAVE A
	MOV GTDLTP,A
	SUB GTLEN,A
	CMP #10.,A
	BLT 1$
	ERROR+TML
1$:	REST A
	RTS PC

.IIF NDF SETXY, SETXY:
GTSXY:	MOV #GTSTXY,F
GTSXY1:	JSR PC,G2NARG
	JSR PC,GT10CH		;CHECK THAT THERE IS LOTS OF ROOM
GTSXY2:	SETI
	SETF
	LDCIF B,FA
	STF FA,DCURX
	JSR PC,GT11B1
	MOV A,B
	LDCIF B,FA
	STF FA,DCURY
	JMP GT1WRD

DELTAX:	MOV #GTDLXY,F
	BR GTSXY1


SETSNA:	JSR PC,G1NARG
	TST GTNEW
	BNE 1$
	SUB #GTSLEN,B
1$:	MOV B,GTSNBT	;FLUSH SOME SNAPS
	SEZ
	RTS PC

OSNAP:	TST GTNEW
	BNE 1$
	MOV #GTSNAP,B
	JSR PC,GT1WRD
	JSR PC,G1NARG
2$:	MOV #1,GTLEN
	JMP GT1WRD

1$:	JSR PC,G1NARG
	ADD #GTNSNP,B
	BR 2$

DIZZY:	JSR PC,G1NARG
	MOV B,GTDIZY
	MOV B,GTDIZF		;SET DIZZY FLAG
	SEZ
	RTS PC

.IIF NDF SNAP, SNAP:
GTSNP:	TST GTNEW
	BNE GTNWSN
	MOV GTSNBT,E		;BOTTOM OF SNAPS
	SUB GTLEN,E		;NEW BOTTOM OF SNAPS
	SUB #2,E		;ROOM FOR POPJ
	CMP E,GTLEN		;DOES IT COLLIDE WITH XISTING LIST?
	BGT 1$			;NO
2$:	ERROR+TML
1$:	CMP E,#GTMNDS		;WILL IT BE BELOW THE MINIMUM ALLOWED?
	BLE 2$
	MOV E,GTSNBT		;SET NEW BOTTOM
	SUB #10.,E
	MOV E,GTDLTP		;SET NEW TOP FOR DISPLAY LIST
	MOV #GTSNAP,B
	JSR PC,GT1WRD
	MOV GTSNBT,B		;GET ADDRESS FOR SNAP
	ADD #GTSTRT,B		;ADD IN OFFSET
	JSR PC,GT1WRD
	MOV GTSNBT,B
GTRSNP:	MOV #1,GTLEN		;NEW LENGTH IS JUST 1 WORD
	JMP R1NARG		;RETURN NUMBER WHERE SNAP WAS STORED

GTNWSN:	MOV GTSNBT,E		;BOTTOM OF SNAPS
	MOV E,A
	ADD GTLEN,A
	ADD #2,A
	CMP #GTNEND,A		;PAST THE END?
	BHI 1$
	ERROR+TML
1$:	MOV A,GTSNBT		;SET NEW BOTTOM
	MOV #GTNSNP,B
	ADD E,B
	JSR PC,GT1WRD
	MOV E,B
	BR GTRSNP

.IIF NDF DISPLA, DISPLA:
GTDIS:	JSR PC,GT10CH
	TST GTNEW
	BNE 1$
	MOV #GTDISP,B
	JSR PC,GT1WRD
	JSR PC,G1NARG
	ADD #GTSTRT,B		;OFFSET TO START OF DISPLAY AREA
	JSR PC,GT1WRD
	BR 2$
1$:	JSR PC,G1NARG
	BIT #176000,B
	BEQ 3$
	ERROR+TML
3$:	ADD #GTNDIS,B
	JSR PC,GT1WRD
2$:	TST GTDIZY		;DIZZY?
	BNE 9$			;YUP, THIS STUFF WON'T HELP
	JSR PC,GTPU1		;PUT UP PEN
	SETI
	LDF DCURX,FB
	LDF DCURY,FA
	STCFI FB,B
	STCFI FA,A
	MOV #GTSTXY,F
	JSR PC,GTSXY2		;SET X AND Y TO WHAT THEY ARE (!?!)
	MOV DCURA,B		;LIKEWISE FOR ANGLE
	JSR PC,GTSET1		;SET HEADING
	BIT #PENUF,DFLAGS	;IS THE PEN SUPPOSED TO BE UP?
	BNE 9$			;YUP
	JSR PC,GTPD		;NO, PUT IT BACK DOWN
9$:	SEZ
	RTS PC

RUBDIS:	CMP #GTUDIS,GTLDF	;DISPLAY?
	BNE 3$
	JSR PC,G1NARG
	CMP B,GTLEN
	BLE RUBDI1
3$:	ERROR+OOB
RUBDI1:	MOV #GTRUB,F
	NEG B
	ADD B,GTLEN
	DEC GTLEN		;SO THE RUBDIS ISN'T COUNTED
	MOV PC,GTDIZY
	TST GTNEW
	BEQ 2$
	NEG B
2$:	JMP GT11B1



.IFZ TVS!NDISP
;PENP
;RETURNS TRUE IF THE PEN IS DOWN
;RETURNS FALSE IF IT IS UP
PENP:	JSR PC,GTTEST	;DOES HE OWN A DISPLAY OR PLOTTER?
	BIT #PENUF,DFLAGS	;IS THE PEN UP?
	BNE PENP1	;YES
	JMP RTTRUE	;NO, RETURN TRUE
PENP1:	JMP RTFALS	;YES, RETURN FALSE

WRAP:	BIS #WRAPF,DFLAGS
	SEZ
	RTS PC

NOWRAP:	BIC #WRAPF,DFLAGS
	SEZ
	RTS PC
.ENDC
GTTEST:	TST GTLDF
	BNE 1$
	JSR F,ACSAV
	JSR PC,GTLDI1	;SET DISPLAY CODES ON, BUT NOT SMART RUBOUT
			;IF IT HAS BEEN TURNED OFF
	JSR F,ACRES
1$:	RTS PC

GTTESD:	JSR PC,GTTEST
	TST GTDIZY	;IS THE TURTLE DIZZY?
	BEQ 1$
	ERROR+TGD
1$:	RTS PC

.IIF NDF HERE,HERE:
GTHERE:	JSR PC,GTTESD	;DOES HE OWN DISPLAY OR PLOTTER?
	MOV #DCURX,F	;GET APPROPRIATE VARIABLES
	JSR PC,WHOPIE	;PUT (F) INTO A NODE, POINTER IN B
	PUSHS B		;STORE POINTER TO FNUMS ON STACK
	JSR PC,WHOPIE	;DO IT AGAIN
	PUSHS B
	MOV (F),B	;PUT ANGLE (SNUM) IN B
	JSR PC,PSHNUM	;PUT SNUM IN B ON S-PDL
	MOV #3,D	;PUSH A FLAG ON	
	JMP SENT.	;CHANGE THE THREE THINGS INTO A SENTENCE

.IIF NDF XCOR,XCOR:
GTXCOR:	MOV #DCURX,F	;GET POINTER TO APPROPRIATE CURX
	BR GTYCR1	;GET NUMBER AND RETURN

.IIF NDF YCOR,YCOR:
GTYCOR:	MOV #DCURY,F	;GET APPROPRIATE POINTER TO CURX
GTYCR1:	JSR PC,GTTESD	;DOES HE OWN A DISPLAY OR PLOTTER?
	JSR PC,WHOPIE	;PUT NUMBER INTO A NODE,POINTER RETURNED IN B
	JMP ORTB	;PUT POINTER IN B ON S-PDL

.IIF NDF HEADIN,HEADIN:
GTHEAD:	JSR PC,GTTEST	;DOES HE OWN A DISPLAY OR PLOTTER?
	MOV #DCURA,F	;GET APPROPRIATE POINTER TO CURX
	MOV (F),B	;MOVE CURA TO B
	JMP R1NARG	;RETURN B

.IFNZ LSI
;CALLED WITH THE AMOUNT OF A FORWARD IN B
;ONLY CALLED IF PLOTTER IS ACTIVE
PLOTTM:	JSR PC,TIMCMP	;IS THE PREVIOUS COMMAND DONE?
	BLO 1$		;NO, JUST ADD
	MOV LSTIME,PTIME
	MOV LSTIME+2,PTIME+2
1$:	SAVE B
	BGE 2$
	NEG B
2$:	INC B		;FUDGE TO BE SURE
	ADD B,PTIME	;TIEM FOR NEXT COMMAND COMPLETION
	ADC PTIME+2
	REST B
	RTS PC

PWAIT:	SAVE B
	MOV #30.,B	;FUDGE FACTOR
	JSR PC,PLOTTM
	REST B
2$:	TST BRAKE
	BEQ 1$
	ERROR+BRK
1$:	JSR PC,TIMCMP
	BLO 2$
	RTS PC

TIMCMP:	CMP LSTIME+2,PTIME+2	;COMPARE HIGH PARTS
	BNE 1$			;CONDITONS SET
	CMP LSTIME,PTIME	;NOW SET
1$:	RTS PC

.ENDC	;lsi
.ENDC	;GTL
