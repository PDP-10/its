.GLOBL AFREE,AROVER,ASPACE,BKPTR,SIZE	;005
;FORMAT OF ARRAY HEADER IS:
;	WORD 0	BACK POINTER TO ATOM BOUND TO THIS ARRAY
;	WORD 1	LENGTH OF STORAGE USED
;	WORD 2	TYPE (INUM, FNUM OR 0 FOR POINTER) + NUMBER OF DIMENSIONS
;	WORD 3	DIMENSION 3
;	WORD 4	DIMENSION 2
;	WORD 5	DIMENSION 1
;	WORDS 6,7,10 AND 11 ARE USED ONLY FOR WINDOWS
;A FREE ARRAY BLOCKS:
;	WORD 0	POINTER TO NEXT FREE BLOCK
;	WORD 1	LENGHT OF BLOCK
;	WORD 2	BACK POINTER TO PREVIOUS FREE BLOCK


	;INPUT--B HAS SIZE OF BLOCK TO BE ALLOCATED IN BYTES
	;OUTPUT--A HAS PTR.TO BLOCK IF ALLOCATION SUCESSFUL
	;        SECOND WORD OF BLOCK CONTAINS SIZE OF BLOCK IN BYTES
	;        AND SKIP RETURN


..ALLO:	CMP	B,ASPACE	;SIZE OF ARRAY .LE. FREE SPACE?
	BGT ARREXP		;NO, TRY TO EXPAND
	PUSH	C
	MOV	AROVER,A	;GET FRE BLOCK PTR.
SRCBLK:	CMP	B,SIZE(A)	;IS BLOCK NOW POINTED AT BIG ENOUGH?
	BLE	OKALOC		;YES
	CMP	(A),AROVER	;CHAIN GONE THRU' ONCE?
	BEQ	CMPRES		;YES
	MOV	(A),A		;NEXT FREE BLOCK
	BNE	SRCBLK		;LAST BLOCK IN CHAIN?
	MOV	AFREE,A		;YES,START FROM THE BEGINNING
	CMP A,AROVER
	BNE SRCBLK

CMPRES:	JSR	PC,.PRESS	;GO COMPRESS THE ARRAY SPACE
.IFNZ LSI
	CMP B,ASPACE		;SPACE COULD HAVE SHRUNK DURING A .PRESS
	BLE 1$			;STILL ROOM
	SPOP C
	BR ARREXP		;EXPAND ARRAY SPACE, SIGH....
1$:
.ENDC
	MOV	AROVER,A	;A POINTS TO FREE SPACE
OKALOC:	MOV SIZE(A),C
	SUB B,C
	CMP #HEADER+4,C
	BGE HOLE
	MOV	A,C		;TO ADDR.OF FREE BLOCK
	ADD	B,C		;ADD SIZE OF ALLOCATED BLOCK TO GET NEW FREE BLOCK ADDR.
	SUB	B,SIZE(A)	;GET SIZE OF NEW FREE BLOCK
	MOV	SIZE(A),SIZE(C)	;AND STORE IN SIZE FIELD OF NEW FREE BLOCK
	MOV B,SIZE(A)
	MOV	BKPTR(A),BKPTR(C)	;PTR. MANAGEMENT
	BEQ	NEWBK1		;IF THIS BLOCK FIRST OF CHAIN,SKIP
	MOV	C,@BKPTR(A)	;CHANGE FORWARD PTR. OF LAST BLOCK
NEWBK1:	MOV	(A),(C)		;FORWARD PTR. FOR NEW BLOCK
	BEQ	NEWBK3		;IF THIS BLOCK IS LAST IN CHAIN,SKIP
NEWBK2:	ADD	#BKPTR,(A)	;TO ACCESS BKPTR FIELD OF NEXT BLOCK
	MOV	C,@(A)		;AND CHANGE IT
NEWBK3:	MOV	C,AROVER	;UPDATE FREE BLOCK ROVING POINTER
	CMP	AFREE,A		;REQUIRED TO UPDATE AFREE?
	BNE	ALDONE		;NO
	MOV	C,AFREE		;YES
ALDONE:	SUB	SIZE(A),ASPACE	;UPDATE FREE SPACE AVAILABLE
	POP	C
	CLZ
	RTS PC

.GLOBL ARRHPG,ARTOP,EXSPAC	;006
HOLE:	MOV	BKPTR(A),C	;TO LINK UP WITH BLOCK BEFORE THE ONE ALLOCATED
	BNE	NEWBK1		
	MOV (A),C		;MAKE THIS THE FIRST BLOCK
	CLR BKPTR(C)		;AND DONT HAVE IT HAVE A BACKPOINTER
	BR NEWBK3

.IF NZ SITS

ARREXP:	MOV ASPACE,A	;AMOUNT OF FREE SPACE WE KNOW ABOUT
	ADD #<ARYHPG-ARYPG+1>_13.+ARYAD,A	;TOTAL POSSIBLE ARRAY SPACE
	SUB ARTOP,A	;AMOUNT ALREADY GOBBLED
	CMP B,A		;NOW THEN, IS THIS POTENTIALLY ENOUGH??
	BLE ARREX4
	BR ARREX1
ARREX3:	ADD #6,P
ARREX1:	SEZ		;TOO GREEDY
	RTS PC
ARREX4:	MOV B,A		;AMOUNT WE WANT
	SUB ASPACE,A	;AMOUNT WE HAVE
	ASH #-10.,A	;AMOUNT WE NEED IN 512 WORD BLOCKS
	SAVE <C,B,A>
ARREX2:	MOV #ARRHPG,A
	JSR PC,EXSPAC	;TRY TO EXPAND ARRAYS
	BEQ ARREX3	;NO LUCK
	MOV ARTOP,B	;OLD TOP OF ARRAYS
	ADD #2000,ARTOP	;NEW!
	MOV #2000,SIZE(B)	;SIZE OF "ARRAY" WE ARE "FREEING"
	JSR PC,.RELES	;FREE THE NEW SPACE
	DEC (P)		;IS THAT ENOUGH?
	BGE ARREX2	;NOT YET
	REST <A,B,C>
	BR ..ALLOC	;TRY IT AGAIN (THIS TIME SURE TO WIN!)

.IFF

ARREXP:	MOV ARTOP,A	;TOP OF ARRAY SPACE
	SAVE B
	DEC B		;XFORM B TO LEAST NUMBER OF
	BIC #1777,B	; 2000-BYTE BLOCKS >OR= B
	ADD #2000,B
	ADD B,A		;EXTEND ARRAY TOP
	CMP A,PPDTOP	;BUMP INTO PDL SPACE?
	BHI ARREXF
	MOV ARTOP,B	;SAVE OLD ARTOP
	MOV A,ARTOP	; AND MAKE NEW ONE
	SUB B,A		;DIFFERENCE IS SIZE OF NEW SPACE
	MOV A,SIZE(B)	;WHICH IS SIZE OF "ARRAY" WE ARE "FREEING"
	JSR PC,.RELS1	;FREE THE NEW SPACE
	REST B
	BR ..ALLOC	;SUCCEED, RETURN TO ..ALLOC
ARREXF:	REST B
	SEZ		;SIGNAL LOSS, FLUNK OUT OF ..ALLOC
	RTS PC
.ENDC
	;RELEASE A BLOCK IN THE ARRAY SPACE
	;INPUT--B HAS PHYSICAL PTR TO BLOCK TO BE RELEASED
	;OUTPUT--B UNCHANGED. RELEASED BLOCK INSERTED INTO CHAIN OF FREE BLOCKS
.GLOBL BAT,LIMIT,NAS,WDIM	;010

.IF NZ SITS
.RELES:
.IFF
.RELES:	JSR PC,.RELS1
	CMP ASPACE,#2000	;MORE THAN 512 WORDS?
	BLO 1$			;NOPE
	JSR PC,.PRESS
1$:	RTS PC
.RELS1:
.ENDC
	ADD	SIZE(B),ASPACE	;UPDATE ASPACE
	TST	AFREE		;IS ARRAY SPACE EMPTY?
	BEQ	ONEBLK		;YES
	PUSH	A
	SPUSH	C
	SPUSH	D
	MOV	AROVER,C
	CMP	B,C		;ADDR OF RELEASED BLOCK > (AROVER)
	BHI CHAIN		;START TRYING TO INSERT AT AROVER
	MOV	AFREE,C		;OTHERWISE START AT AFREE
	CMP B,C
	BHI CHAIN
	MOV C,A			;SAVE POINTER TO THE OLD FIRST FREE BLOCK
	JSR PC,ONEBLK		;MAKE THE THE BLOCK WE ARE FREEING, FIRST
	MOV B,C			;GET POINTER TO THE END OF THIS BLOCK
	ADD SIZE(B),C
	CMP A,C			;IS IT THE SAME AS THE OLD AFREE?
	BNE .RELE1		;NO
	ADD SIZE(C),SIZE(B)	;HERE COMPRESS THE TWO BLOCK
	MOV (C),C		;GET POINTER TO NEXT BLOCK
	MOV C,(B)		;FIX THIS BLOCK TO POINT TO IT
	BR REDON1		;UPDATE THE BACK POINTER OF IT IF NEEDED
.RELE1:	MOV A,(B)
	MOV B,BKPTR(A)
	BR REDONE

CHAIN:	MOV	C,A		;A_CURRENT FREE BLOCK
	MOV	(A),C		;C_NEXT FREE BLOCK
	BEQ	LSTBLK		;CURRENT BLOCK IS LAST IN CHAIN
	CMP	C,B		;ADDR OF NEXT FREE > ADDR OF RELEASED?
	BLO	CHAIN		;NO,TRY NEXT ONE
	MOV	SIZE(B),D	;YES,START INSERTING THE RELEASED BLOCK
	ADD	B,D		;SIZE IN BYTESADDED TO (B) GIVES END OF RELEASED BLOCK
	CMP	C,D		;WHICH MIGHT BE ADJACENT TO NEXT FREE BLK
	BNE	LSTBLK		;NO
	ADD	SIZE(C),SIZE(B)	;YES,COLLAPSE THE TWO
	CMP C,AROVER		;IS AROVER POINTING TO THIS BLOCK?
	BNE 1$			;NO
	MOV B,AROVER		;WELL, NOW B IS THE AROVER
1$:	MOV	(C),C		;UPDATE FWDPTR

LSTBLK:	MOV	SIZE(A),D	;THIS FREE BLOCK 
	ADD	A,D		;MIGHT BE ADJACENT TO THE
	CMP	D,B		;RELEASED BLOCK
	BEQ	CONBLK		;YES
	MOV	C,(B)		;NO,JUST UPDATE PTR
	MOV	A,BKPTR(B)	;SIZE FIELD NEED NOT BE CHANGED
	MOV	B,(A)	
REDON1:	TST	C		;IF THIS FREE BLOCK IS LAST IN CHAIN
	BEQ	REDONE		;THEN NOTHING
	MOV	B,BKPTR(C)	;ELSE UPDATE BKPTR OF NEXT BLK
REDONE:	POP	D
	SPOP	C
	SPOP	A
	RTS PC

ONEBLK:	MOV	B,AFREE		;RELEASED BLOCK IS THE ONLY FREE ONE
	MOV	B,AROVER
	CLR	(B)
	CLR	BKPTR(B)
	RTS	PC

CONBLK:	ADD	SIZE(B),SIZE(A)	;COLLAPSE
	MOV	C,(A)		;AND UPDATE PTR
	MOV A,BKPTR(C)		;UPDATE IT'S BACK POINTER
	CMP B,AROVER		;DID AROVER POINT TO THE BLOCK WE COMPRESSED?
	BNE REDONE		;NO
	MOV A,AROVER		;WELL, MAKE AROVER POINT TO THE START FO THE BLOCK
	BR REDONE

	;THIS ROUTINE COMPRESS THE ARRAY SPACE BY STACKING FREE BLOCKS TOGETHER
	;AFREE POINTS TO FIRST FREE BLOCK IN THE CHAIN
	;FIRST WORD OF USED BLOCK MUST CONTAIN PTR. TO WORD POINTING TO THAT BLOCK FOR RELOCATING
.GLOBL TMPBLK	;011
.PRESS:	TST AFREE		;ANY FREE SPACE?
	BNE 1$			;YES
	RTS PC			;OH WELL....
1$:	PUSH A
	SPUSH B
	SPUSH C
	SPUSH D			;SAVE AC'S
	MOV AFREE,B		;B POINTS TO WHERE TO START COPYING TO
	MOV B,D			;AND D POINTS TO THE NEXT FREE BLOCK
MOVNXT:	MOV D,C			;GET POINTER TO START OF NEXT FREE BLOCK
	ADD SIZE(D),C		;MAKE C POINT TO THE USED BLOCK AFTER IT
	MOV (D),D		;AND UPDATE D TO POINT TO NEXT FREE BLOCK ON LIST
	BNE COLAPS		;THERE IS ANOTHER BLOCK, DONT WORRY ABOUT TOP OF ARRAY SPACE
	CMP C,ARTOP		;IS THIS FREE BLOCK THE LAST BLOCK IN ARRAY SPACE?
	BEQ PSDONE		;YES, WE ARE DONE
	MOV ARTOP,D		;PRETEND THAT THE END OF THE USED BLOCK IS THE END OF
				;ARRAY SPACE
COLAPS:	MOV SIZE(C),A		;GET THE LENGTH OF THE USED ARRAY
	ASR A			;TURN INTO NUMBER OF WORDS
	MOV B,@(C)		;UPDATE THE BINDING POINTER TO POINT TO THE NEW LOCATION
1$:	MOV (C)+,(B)+		;COPY THE ARRAY
	SOB A,1$
	CMP C,D			;HAVE WE COPIED THESE CONTIGUOUS USED ARRAYS
	BNE COLAPS		;NO, COPY THE NEXT USED ARRAY
	CMP D,ARTOP		;HAVE WE COPIED UP TO THE TOP OF ARRAY SPACE
	BNE MOVNXT		;NO, THEREFORE DO THE NEXT USED BLOCK
PSDONE:
.IFNZ LSI
	MOV B,ARTOP		;FIRST FREE SPACE IS NOW TOP
	CLR ASPACE		;GIVING UP ALL FREE SPACE
	CLR B			;NO FREE POINTER
.ENDC
	MOV B,AROVER		;FROM NOW ON, ALLOCATE FROM HERE
	MOV B,AFREE		;B NOW POINTS TO THE FIRST AND ONLY FREE BLOCK
.IFZ LSI
	BEQ 2$			;NO FREE BLOCKS
	MOV ASPACE,SIZE(B)	;ITS SIZE IS THE AMOUNT OF FREE STORAGE LEFT
	CLR (B)			;NO MORE BLOCKS OF FREE STORAGE
	CLR BKPTR(B)		;AND NO PREVIOUS ONE
2$:
.ENDC
	SPOP D
	SPOP C
	SPOP B
	SPOP A
	RTS PC


.GLOBL GETAML
;PUT INTO A THE CONTENTS OF THE MEMORY LOCATION POINTED TO BY A
GETAML:
.IFNZ TS			;THIS IS NECCESSARY BECAUSE MFPI DOESN'T WORK IN USER MODE
	SAVE A
	$MFPI
	REST A
.IFF
	MOV (A),A		;NOW WASN'T THAT MUCH SIMPLER?
.ENDC
	RTS PC

.IFNZ TS
HALCRO:	JSR PC,G1NARG
	MOV B,A
	MOV HALLLM,C	;LAST LIMIT
	SUB HALLIM,C	;AMMOUNT ALREADY ALLOCATED
	SUB C,B		;ADDITIONAL AMOUNT TO BE ALLOWED
	BGE 1$
	ERROR+WTA
1$:	MOV B,HALLIM
	MOV A,HALLLM
	SEZ
	RTS PC
.ENDC
	.SBTTL P AND S PDL SWAP OUTERS

;** NOTE: ALTHO PDL EMERGENCIES WITH DISK CAN ONLY OCCUR WHEN TIMESHARING,
;** WITHOUT THE DISK PDL EMERGENCIES CAN *ALWAYS* OCCUR (DUE TO NODE/ARRAY SPACE
;** HAVING SNUCK UP ON THE PDL BUFFERS) AND THUS MUST BE ACCOUNTED FOR REGARDLESS
;** OF TS.

.IFNZ DSK

PPSWPO:	JSR F,ACSAV	;TIME TO WORK!
.IFNZ TS
	TST PPEMR	;HAS A P PDL EMERGENCY ALREADY OCCURED?
	BEQ 1$		;NOPE
	ERROR+FBUG	;SYSTEM BUG!!
1$:	JSR F,SETUPP
	.BLKO
	BEQ PPEMRP	;GO DO AN EMERGENCY PUSH OF THE STACK
	DEC HALLIM
	BLE 2$
	CMP PPLIMT,PRBAO	;ARE WE BEYOND THE LIMIT ON P YET?
	BHI PPSWP1
2$:	BIS #DSAMFL,FLAGS2	;YES, SET DISK ALMOST FULL
.ENDC
PPSWP1:	MOV POPLM,PPOPL	;NONE OUT BEFORE, CHANGE LIMIT
	BIS #PPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV IP,A
	MOV #PSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,P
	BHIS .-4
	ADD #PPDLL,P	;PDL HAS MOVED!
	ADD #PPDLL,PRBAO
	JSR F,ACRES
	RTS PC

.IFNZ TS
PPEMRP:	MOV PC,PDLEMR	;FLAG THAT A PDL EMERGENCY OCCURED
	MOV PC,PPEMR	;FLAG A P PDL EMERGENCY
	CLR -(P)
	CLR -(P)
	SAVE PPDLCP
	BIS #.FASP,(P)
	$INVOK		;SET POINTER TO BEG OF FILE
	$BLKO		;OUTPUT THIS PDL BLOCK (CAN'T FAIL!!)
	DEC HALLIM
	BIS #DSAMFL,FLAGS2	;WARN THE REST OF THE SYSTEM WE ARE IN TROUBLE
	BR PPSWP1
.ENDC
.ENDC
.IFZ DSK

;ROUTINE TO EXTEND P-PDL SPACE (IN LIEU OF SWAPPING OUT)
PPSWPO:	JSR F,ACSAV
	TST PPEMR	;PENDING EMERGENCY?
	BEQ 1$
	ERROR+FBUG
1$:	BIS #PPNAIF,FLAGS2	;NOT ALL "SWAPPED IN" (IE, >1 PDL BLOCK EXISTS)
	MOV PPDTOP,A	;A_TOP OF STACK SPACE
	SUB #PPDLL,A	;EXTEND IT
	CMP A,ARTOP	;BUMP INTO ARRAY SPACE?
	BLO PPEMRP	;NO, EMERGENCY PUSH
	MOV A,PPDTOP	;ANOTHER BLOCK ALLOCATED
	SUB #PPDLL,PPUSHL	;PPUSHL MOVED ACCORDINGLY
	ADD #<2*PPDLL>-<PDSLOP/3>,A
	MOV A,PPOPL	;AS WELL AS PPOPL
PPSWP2:	ADD #PPDLL,PRB	;ONE MORE BLOCK "ALREADY OUT"
	JSR F,ACRES
	RTS PC

PPEMRP:	BIS #DSAMFL,FLAGS2	;SINGAL "DISK" ALMOST FULL
	MOV PC,PPEMR	;FLAG P PDL EMER
	SUB #PPDLL-PDSLOP,PPUSHL	;PPUSHL IS NOW JUST UNDER TOP OF EMER BLK
	MOV PPDTOP,PPOPL	;NEW PPOPL
	ADD #PPDLL-<PDSLOP/3>,PPOPL
	BR PPSWP2
.ENDC
.IFNZ DSK

SPSWPO:	JSR F,ACSAV	;TIME TO WORK!
.IFNZ TS
	TST SPEMR	;HAS A P PDL EMERGENCY ALREADY OCCURED?
	BEQ 1$		;NOPE
	ERROR+FBUG	;SYSTEM BUG!!
1$:	JSR F,SETUPS
	.BLKO
	BEQ SPEMRP	;GO DO AN EMERGENCY PUSH OF THE STACK
	DEC HALLIM
	BLE 2$
	CMP SPLIMT,SPRBAO	;ARE WE BEYOND THE LIMIT ON P YET?
	BHI SPSWP1
2$:	BIS #DSAMFL,FLAGS2	;YES, SET DISK ALMOST FULL
.ENDC
SPSWP1:	MOV SPOPLM,SPOPL
	BIS #SPNAIF,FLAGS2	;CERTAINLY NOT ALL IN NOW
	MOV IS,A
	MOV #SSWPAD,B	;ADDRESS PDL SWAPED FROM
	MOV -(B),-(A)
	CMP B,S
	BHIS .-6
	ADD #SPDLL,S	;PDL HAS MOVED!
	ADD #SPDLL,SPRBAO
	JSR F,ACRES	;ALL DONE!
	RTS PC

.IFNZ TS
SPEMRP:	MOV PC,PDLEMR	;FLAG THAT A PDL EMERGENCY OCCURED
	MOV PC,SPEMR	;FLAG A P PDL EMERGENCY
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;SET POINTER TO BEG OF FILE
	$BLKO		;OUTPUT THIS PDL BLOCK (CAN'T FAIL!!)
	DEC HALLIM
	BIS #DSAMFL,FLAGS2	;WARN THE REST OF THE SYSTEM WE ARE IN TROUBLE
	BR SPSWP1
.ENDC
.ENDC

.IFZ DSK

;ROUTINE TO EXTEND S-PDL SPACE (IN LIEU OF SWAPPING OUT)
;THIS REQUIRES MOVING THE P-PDL
SPSWPO:	JSR F,ACSAV
	TST SPEMR	;EMERGENCY IN PROGRESS?
	BEQ 1$
	ERROR+FBUG
1$:	BIS #SPNAIF,FLAGS2	;NOT ALL "SWAPPED IN"
	MOV PPDTOP,A	;A_TOP OF *P*PDL SPACE
	SUB #SPDLL,A	;MOVE IT
	CMP A,ARTOP	;BUMP INTO ARRAY SPACE?
	BLO SPEMRP	;IF SO, EMERGENCY PUSH
	MOV A,PPDTOP	;NEW PDL TOP
	MOV P,A		;SAVE P-PDL PTR
SPSWPL:	MOV (P)+,-<SPDLL+2>(P)	;SLIDE P-PDL UP (DOWN) ONE BLOCK
	CMP P,IP	;REACHED THE BOTTOM YET?
	BLO SPSWPL	;IF NOT, CONTINUE

	SUB #SPDLL,A	;UPDATE P
	MOV A,P
	SUB #SPDLL,IP	;ADJUST REMAINING PARAMETERS
	SUB #SPDLL,PPUSHL
	SUB #SPDLL,PPOPL
	SUB #SPDLL,SPUSHL
	MOV IP,SPOPL
	ADD #<2*SPDLL>-<PDSLOP/3>,SPOPL
SPSWP2:	ADD #SPDLL,SPRB	;ONE MORE BLOCK "ALREADY OUT"
	JSR F,ACRES
	RTS PC

SPEMRP:	BIS #DSAMFL,FLAGS2	;SIGNAL "DISK" ALMOST FULL
	MOV PC,SPEMR	;FLAG S-PDL EMERGENCY
	SUB #SPDLL-PDSLOP,SPUSHL	;SPUSHL NOW JUST UNDER TOP OF EMER BLOCK
	MOV IP,SPOPL
	ADD #SPDLL-<PDSLOP/3>,SPOPL	;NEW SPOPL
	BR SPSWP2
.ENDC
	.SBTTL P AND S PDL SWAPER INERS

.IFNZ DSK

PPSWPI:	BIT #PPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE 1$			;NO (PRAISE THE LORD!)
	ERROR+FBUG
1$:	JSR F,ACSAV
	MOV #PSWPAD,A
	MOV A,B
	ADD #PPDLL,A
	MOV -(A),-(B)
	CMP A,P
	BHI .-4
	SUB #PPDLL,P
	SUB #PPDLL,PRBAO
	BNE PSWPI3
	BIC #PPNAIF,FLAGS2
	MOV IP,PPOPL
PSWPI3:
.IFNZ TS
	JSR F,SETUPP
	$BLKI
	INC HALLIM	;GIVE BACK A BLOCK
.ENDC
	JSR F,ACRES
	RTS PC
.IFNZ TS
SETUPP:	TST (P)+
	TST SPEMR	;IS THERE A S PDL EMRG?
	BNE 1$		;YES
	BIC #DSAMFL,FLAGS2	;NO, DISK IS NOW NOT ALMOST FULL
1$:	TST PPEMR	;HAS A P PDL EMERGENCY OCCURED?
	BEQ SETUP1	;NO, DO NORMAL THING
	CLR -(P)	;GO TO START OF FILE FOR EMERGENCY BLOCK
	CLR PPEMR	;NO MORE EMERGENCY!
	BR SETUP2
SETUP1:	SPUSH PRBAO
	ADD #PPDLL,(P)	;SKIP THE EMERGENCY BLOCK
SETUP2:	CLR -(P)
	SPUSH PPDLCP
	BIS #.FASP,(P)
	$INVOK
	SPUSH #PSWPAD
	SPUSH #-PPDLL
	SPUSH PPDLCP
	JMP (F)
.ENDC
.ENDC

.IFZ DSK

;ROUTINE TO CONTRACT P-PDL SPACE (IN LIEU OF SWAPPING IN)

PPSWPI:	BIT #PPNAIF,FLAGS2	;ANYTHING TO POP?
	BNE 1$		;YES (THANK TOASTER!)
	ERROR+FBUG
1$:	JSR F,ACSAV
	SUB #PPDLL,PRB	;ONE LESS BLOCK
	BNE PSWPI3	;IF THAT LEAVES NO EXTRAS,
	BIC #PPNAIF,FLAGS2	; SO FLAG
	MOV IP,PPOPL	;NEW PPOPL FOR BLOCK 0
	BR PSWPI4
PSWPI3:	ADD #PPDLL,PPOPL	;NEW PPOPL FOR BLOCK > 0
PSWPI4:	TST SPEMR	;SPDL EMERGENCY?
	BNE 1$
	BIC #DSAMFL,FLAGS2	;NO, SO "DISK" NO LONGER FULL
1$:	TST PPEMR	;PPDL EMERGENCY?
	BEQ SETUP1
	CLR PPEMR	;NO MORE
	ADD #PPDLL-PDSLOP,PPUSHL	;YES, NEW PPUSHL
	BR SETUP2	;NO BLOCK POPPED HERE
SETUP1:	ADD #PPDLL,PPUSHL	;NEW PPUSHL
	ADD #PPDLL,PPDTOP	;POP TO NEW PPDTOP
SETUP2:	JSR F,ACRES
	RTS PC
.ENDC


.IFNZ DSK

SPSWPI:	BIT #SPNAIF,FLAGS2	;IS THE PDL ALL THE WAY IN?
	BNE 1$		;NO (PRAISE THE LORD!)
	ERROR+FBUG
1$:	JSR F,ACSAV
	MOV #SSWPAD,A
	MOV A,B
	ADD #SPDLL,A
	MOV -(A),-(B)
	CMP A,S
	BHI .-6
	SUB #SPDLL,S
	SUB #SPDLL,SPRBAO
	BNE SPSWI3
	MOV IS,SPOPL
	BIC #SPNAIF,FLAGS2
SPSWI3:
.IFNZ TS
	JSR F,SETUPS
	$BLKI
	INC HALLIM
.ENDC
	JSR F,ACRES
	RTS PC
.IFNZ TS
SETUPS:	TST (P)+
	TST PPEMR	;IS THERE A P PDL EMRG?
	BNE 1$		;YES
	BIC #DSAMFL,FLAGS2	;NO, DISK IS NOW NOT ALMOST FULL
1$:	TST SPEMR	;HAS EMERGENCY OCCURED?
	BEQ SETUS1	;NOPE
	CLR -(P)	;GET EMERGENCY BLOCK THEN
	CLR SPEMR	;NO MORE EMERGENCY
	BR SETUS2
SETUS1:	SPUSH SPRBAO
	ADD #SPDLL,(P)	;PASS BY EMRG BLOCK
SETUS2:	CLR -(P)
	SPUSH SPDLCP
	BIS #.FASP,(P)
	$INVOK
	SPUSH #SSWPAD
	SPUSH #-SPDLL
	SPUSH SPDLCP
	JMP (F)
.ENDC
.ENDC

.IFZ DSK

;ROUTINE TO CONTRACT S-PDL SPACE (IN LIEU OF SWAPPING IN)
;THIS REQUIRES SLIDING THE P-PDL UP

SPSWPI:	BIT #SPNAIF,FLAGS2	;ANYTHING TO POP?
	BNE 1$
	ERROR+FBUG
1$:	JSR F,ACSAV
	SUB #SPDLL,SPRB		;ONE LESS BLOCK
	BNE SPSWI3		;IF THAT LEAVES NO EXTRAS,
	BIC #SPNAIF,FLAGS2	; SO FLAG
	MOV IS,SPOPL		;NEW SPOPL FOR BLOCK 0
	BR SPSWI4
SPSWI3:	ADD #SPDLL,SPOPL	;NEW SPOPL FOR BLOCK > 0
SPSWI4:	TST PPEMR		;PPDL EMERGENCY?
	BEQ 1$
	BIC #DSAMFL,FLAGS2	;NO, SO "DISK" NO LONGER FULL
1$:	TST SPEMR		;SPDL EMERGENCY?
	BEQ SETUS1
	CLR SPEMR		;NO MORE
	ADD #SPDLL-PDSLOP,SPUSHL	;YES, NEW SPUSHL
	BR SETUS2		;NO PPDL SLIDE NEEDED
SETUS1:	ADD #SPDLL,SPUSHL	;YES, NEW SPUSHL
	MOV IP,A
	ADD #SPDLL,IP		;POP TO NEW SPDL TOP
SETUSL:	MOV -(A),SPDLL(A)
	CMP A,P
	BHI SETUSL
	ADD #SPDLL,P		;ADJUST PPDL PARAMETERS
	ADD #SPDLL,PPDTOP
	ADD #SPDLL,PPUSHL
	ADD #SPDLL,PPOPL
SETUS2:	JSR F,ACRES
	RTS PC
.ENDC
.GLOBL MKSSP
.IFNZ DSK
MKSSP:	TST SPRBAO
	BEQ MKSP4
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;GO TO BEG OF FILE
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKO
	CLR SPMSWP
MKSP8:	ADD #2000,SPMSWP
	CMP SPMSWP,SPRBAO
	BHI MKSP6	;NO
MKSP5:	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKI
	MOV #SSWPAD,E
	MOV #SPDLL/2,F
MKSP7:	MOV (E)+,B	;MARK THIS PIECE OF S PDL
	JSR PC,MARKV
	SOB F,MKSP7
	BR MKSP8

MKSP6:	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>
	$BLKI
	CLR SPMSWP
MKSP4:	RTS PC
.IFF
MKSPSW:
MKSSP:	RTS PC
.ENDC
.IFNZ DSK
MKSPSW:	TST SPMSWP	;TOP OF PDL SWAPED OUT FOR MARKING?
	BEQ 1$		;NO, JUST ERROR OUT
	CLR -(P)
	CLR -(P)
	SAVE SPDLCP
	BIS #.FASP,(P)
	$INVOK		;ACCESS BEG OF FILE
	SAVE <#SSWPAD,#-SPDLL,SPDLCP>	;INPUT THE BLOCK IT WAS SAVES ON
	$BLKI
1$:	RTS PC
.ENDC

.IFNZ LSI
.IF Z LSMAP
LSGDBA:	MOV LSDBAD,B
	RTS PC

LSBITM:	MOV GCBITA,GCBITS
	RTS PC
.IFF
.IF NZ RKDSK
LSGDBA:	MOV LSDBAD,B
	RTS PC
.IFF
LSGDBA:	MOV LSDBAD,B
.ENDC
LSBMAP:	TST GOTMAP
	BEQ 1$
	MOV #MAPON!MAPHCK,MAPCSR
	MOV B,MAPADR
	MOV #MAPHCA,B
1$:	RTS PC

LSBITM:	SAVE B
	MOV GCBITA,B
	JSR PC,LSBMAP
	MOV B,GCBITS
	REST B
	RTS PC
.ENDC




.IFF
LSBITM:	RTS PC
.ENDC

.IF Z LSI
GETERW:	MOV (B),B
	RTS PC

GETERB:	MOVB @ERRPT,D
	RTS PC

.IFF

.IF Z LSMAP
GETERW:	ADD RERTXT,B
	MOV (B),B
	RTS PC

GETERB:	MOV RERTXT,D
	ADD ERRPT,D
	MOVB (D),D
	RTS PC

.IFF
GETERW:	TST GOTMAP
	BEQ 1$
	JSR PC,MAPEB
1$:	ADD RERTXT,B
	MOV (B),B
	RTS PC

GETERB:	TST GOTMAP
	BNE 1$
	MOV RERTXT,D
	ADD ERRPT,D
	MOVB (D),D
	RTS PC

1$:	SAVE B
	MOV ERRPT,B
	JSR PC,MAPEB
	MOVB (B),D
	REST B
	TST D
	RTS PC

MAPEB:	SAVE A
	MOV B,A
	BIC #176000,B
	ADD #MAPHCA,B
	BIC #1777,A
	ASH #-10.,A
	ADD RERTXT,A
	MOV #MAPON!MAPHCK,MAPCSR
	MOV A,MAPADR
	REST A
	RTS PC
.ENDC
.ENDC


;WHAT A RANDOM PLACE TO PUT THE METER STUFF. I BET I'LL NEVER FIND IT AGAIN.
.IF NZ METERS

METER:	JSR PC,G1NARG
	ASL B
	ASL B
	ADD #MTZER,B	;GET TO METER ZERO
	MOV 2(B),A
	MOV (B),B
	JSR PC,GRBAD	;MAKE NODE UP WITHT THE NUMBER IN IT
	BIS #INUM,C	;POINT TOT HE NUMBER
	JMP ORTC	;RETURN IT

METERG:	JSR PC,G1NARG
	MOV B,MTFLAG	;ZERO=> ON, NON-ZERO => OFF
	BGE 1$		;NEGATIVE WILL ZERO METERS AND START THEM
	MOV #MTZER,A
2$:	CLR (A)+
	CMP #MTZERE,A
	BNE 2$
1$:	SEZ
	RTS PC

.ENDC
