

	VERSIO
.SBTTL INITIALIZE NODE SPACE
INIT:	MOV #ZEROS,A
	MOV #<EZEROS-ZEROS>/2,B
4$:	CLR (A)+
	SOB B,4$
	MOV #'?,PRMTCH
	MOV #27.,RNSEED
	MOV IS,S
	MOV #UHCT,A	;CLEAR OUT THE USER HASH TABLE
	MOV #HCC,B	;THUS MAKING EVERYTHING GARBAGE
1$:	CLR (A)+
	SOB B,1$
	MOV #GCMKL,A	;CLEAR ALL THE THINGS THAT GET MARKED ON
2$:	MOV (A)+,B
	BEQ 3$
	CLR (B)
	BR 2$
3$:
.IFNZ LSI
	MOV #NODESP+2000,ARYAD
	CLR ASPACE	;RESET ARRAY PARAMETERS
	CLR AROVER
	CLR AFREE
	MOV #NODESP+2000,ARTOP
.ENDC
	MOV #NODESP,A
	MOV #INODES,B
	MOV #400,C
	MOV #IDLE,D
INODCP:	MOV (B)+,(A)+
	MOV (B)+,(A)+
	DEC C
	INC D
	CMP #ASOFN,B
	BNE INODCP
	MOV #NODESP+<400*4>,NODTOP
	JSR PC,.GCOLL
	RTS PC

INIT1:	BIS #PADERF,FLAGS2	;SO OCTAL ERROR ADDR IS PRINTED
STARTF:	RTS PC
.IFNZ LSI
SINIT:	MOV #INITTB,A
.IFNZ LSMAP
	TST GOTMAP		;HAVE WE GOT A MAP?
	BEQ 2$			;NOPE
	MOV HGHPAG,B		;HIGHEST PAGE
3$:	MOV (A)+,C		;SIZE OF THE THING BEING ALLOCATED
	ADD #1777,C
	BIC #1777,C		;MAKING IT AN EVEN NUMBER OF PAGES
	ASH #-10.,C		;PAGES
	SUB C,B
	MOV B,@(A)+
	CMP A,#INITMP		;AT END OF MAP PART?
	BNE 3$
	BIT #177700,B		;DO WE HAVE MORE THAN 32K LEFT?
	BNE 2$
	ASH #10.,B		;GET THE REMAINDER IN BYTES
	CMP B,MEMTOP		;DO WE HAVE MORE THAN WE WILL USE?
	BHIS 2$			;YUP
	MOV B,MEMTOP		;DON'T USE MORE THAN WE HAVE
2$:
.ENDC
	MOV MEMTOP,B
1$:	SUB (A)+,B
	MOV B,@(A)+
	CMP A,#INITTE
	BNE 1$
	RTS PC

EINIT:	MOV #ERTXT,A		;POINTER TO THE TEXT
	MOV RERTXT,B		;POINTER TO WHERE IT WILL REALLY GO
	MOV #ERTXTL/2,C
.IF NZ LSMAP
	TST GOTMAP
	BEQ 1$
	MOV #MAPON!MAPHCK,MAPCSR
	MOV B,MAPADR
3$:	MOV #512.,D
	MOV #MAPHCA,B
4$:	MOV (A)+,(B)+
	DEC C
	BLE 6$		;DONE
	SOB D,4$	;DONE PAGE?
	INC MAPADR
	BR 3$		;NEXT PAGE
1$:
.ENDC

2$:	MOV (A)+,(B)+
	SOB C,2$
6$:	RTS PC

MEMCHK:	SAVE 4
	MOV #MEMCH1,4
	MOV #CODEND,A
1$:	TST (A)+
	BR 1$

MEMCH1:	CMP (P)+,(P)+
	TST -(A)
	MOV A,RMEMT
	SUB #40,A	;LEAVE ROOM FOR LSI DDT
	MOV #MEMCH2,4	;NOW CHECK FOR 11/45
	TST 177772	;pirq?
	MOV #156400,MEMTOP	;WE ARE ON 11/45, LEAVE ROOM FOR RUG
	CLR GOTSMS		;NO SMS
	CLR GOTMAP		;AND NO LSI STYLE MAP
	BR MEMC11		;GO CHECK FOR LPT
MEMCH2:	CMP (P)+,(P)+	;FLUSH THE TRAP
MEMCH3:	MOV A,MEMTOP
.IFNZ FILDSK!TIMCLK
	MOV #MEMCH4,4	;NOW CHECK FOR SMS
	BIS #SMSRSB,SMSCSR	;IF WE HAVE ONE, RESET IT
	MOV PC,GOTSMS	;GOT ONE
	CLR SMSLGT
.IFNZ TIMCLK
	MOV #30.,HSEC	;DEFAULT IS 60HZ
.IF NZ SMSDSK
	BIT #SMS60H,SMSPRE	;IS THIS A 60HZ MACHINE?
	BNE 1$		;YUP
	MOV #25.,HSEC	;NOPE, MUST BE A 50
.ENDC
1$:	BR MEMCH5
MEMCH4:	CMP (P)+,(P)+
MEMCH5:
.ENDC
.ENDC
.IFNZ LSMAP
	MOV #MEMCH8,4
	CLR GOTMAP
	CLR MAPCSR
	MOV PC,GOTMAP
	MOV #8.,A	;WE ARE GOING TO ASSUME 4K RESIDENT
1$:	MOV #777,MAPADR	;WE ASSUME THIS IS NON-EX
	INC MAPCSR
	SOB A,1$
	MOV #64.-8.-4.,A	;OF 64 PAGES, 8 ARE RESIDENT MEM AND 4 ARE I/O
	CLR B
	BIT #100,MAPCSR		;IF THIS BIT IS CLEAR, WE HAVE RESIDENT MEM
	BEQ 2$
	ADD #8.,A
	CLR MAPCSR		;SET BOTTOM 4K TOO
2$:	MOV B,MAPADR
	INC B
	INC MAPCSR
	SOB A,2$
	MOV #4,A	;NOW ABOUT THAT I/O SPACE...
3$:	MOV #777,MAPADR
	INC MAPCSR
	SOB A,3$
	MOV #MEMC10,4
	MOV #MAPON!MAPHCK,MAPCSR	;THE HACK PAGE
	CLR MAPADR
4$:	TST MAPHCA
	INC MAPADR
	BR 4$
MEMC10:	CMP (P)+,(P)+
	MOV MAPADR,HGHPAG	;HIGHEST EXTANT PAGE+1
	DEC HGHPAG
	BR MEMC11
MEMCH8:	CMP (P)+,(P)+
MEMC11:
.ENDC
.IFNZ LSPRNT
	MOV #MEMCH6,4
	TST LPS		;IS THERE A PRINTER?
	BR MEMCH7	
MEMCH6:	CLR LPUSE	;"USED"
.IIF GT LSTTY-1,	MOV #1,MWTTY	;MUST HAVE A MULTIWRITER, IF WE HAVE ANYTHING
	CMP (P)+,(P)+
MEMCH7:
.ENDC
	REST 4
	RTS PC	

HINIT:	BIS #100,LSRCS0	;TTY INTERUPTS
	MOV #LSITRP,LSITRV
.IIF NZ LSDISK,	CLR LSDKOF	;DISK GOT TURNED OFF
.IFNZ LSCLK
	TST GOTSMS
	BEQ 1$
	BIS #SMSCLE,SMSCSR	;ENABLE CLOCK TOO
1$:
.ENDC
.IFNZ LSMAP
	TST GOTMAP
	BEQ 2$
	BIS #MAPON,MAPCSR
2$:
.ENDC
	RTS PC

.ENDC

	.SBTTL READ-EVAL LOOP DRIVER (THE ONE-USER MAIN LOOP)
.IFNZ LSI
PURIFY:	MOV #RSTPDL,P
	JSR PC,SORT
	JSR PC,SYSCHK	;TO INIT XORS BEFORE DUMPING
	HALT
.ENDC

START:
.IFNZ LSI
	RESET
.ENDC
	MOV #.TICTM!.TIECM!.TLIPM!.TICVM,TTYST
	MOV #TYO,PCHR
	MOV #TYI,GCHR
	TST RAN		;DID WE EVER RUN?
	BEQ 2$		;NOPE
	JMP RESTART	;EITHER WE ARE A RELOADED DUMP OR A RESTARTED LIVE PROGRAM
2$:	MOV PC,RAN	;NEXT TIME WE WON'T GET TO HERE
.IFNZ LSI
	MOV #RSTPDL,P
	JSR PC,MEMCHK	;CHECK AMOUNT OF MEMORY
	JSR PC,SORT	;SORT THE SYSTEM OBLIST
	JSR PC,SINIT	;INIT STORAGE
	JSR PC,EINIT	;INIT THE ERRORS
.ENDC
START1:
.IFNZ LSI
	MOV #RSTPDL,P
	JSR PC,SINIT	;INIT STORAGE
	MOV IP,P	;INIT P PDL
	JSR PC,HINIT	;INIT ANY HARDWARE THAT NEEDS IT
	JSR PC,SYSCHK	;SET UP THE SYSTEM CHECKSUMS
.IIF NZ TIMCLK,	JSR PC,GETTIM
	JSR PC,LSINIT	;INIT THE LITTLE SITS EMULATOR
.IFF
	MOV IP,P	;INIT P PDL
.ENDC

.IFNZ TS

	TST INITED	;HAS THE PURIFYING ALREADY BEEN DONE?
	BNE 1$
	JSR PC,PURINT
1$:
	SPUSH #0*400+0		;LENGTH AND START
	TST -(P)		;PAGE TO GET NOT USED WITH SOURCE=FRESH
	SPUSH #<10+NODPG>*400+377	;40000-60000, FRESH PAGE
	SPUSH #<.CRWRT+1>	;INSERT INTO SELF
	$MAP
.ENDC
	JSR PC,SETTTY
.IIF NZ DSK,	JSR PC,DSKINT
.IIF NZ SITS,	JSR PC,BRKINT	;SET UP THE BREAK PROCESS
.IIF NZ TVS,	JSR PC,TVCHK				;SET THE TV FLAG
.IF NZ FPPF
.IIF NZ SITS,	$FLOAT
	LDFPS #40300
.ENDC
	JSR PC,INIT
.IIF NZ SITS,	JSR PC,RINIT
	JSR PC,HELMES
	JMP MLOOP

RESTAR:	MOV #RSTPDL,P	;TEMP PDL
.IFNZ SITS
	SAVE <,,#.SPKIL*400+1>	;KILL ALL PROCESSES BUT ME
	$INVOK
	MOV MAINPR,A	;MAIN PROCESS
	JSR PC,DELCP	;DELETE IT
	$SINK		;I WILL BECOME THE BREAK PROCESS, DON'T NEED FLOATING POINT
	JSR PC,BRKINT	;MAKE SURE BREAK PROCESS IS RUNNING
	$FLOAT		;MAKE SURE WE HAVE FLOATING POINT
.IFF
	JSR PC,HINIT
.ENDC
.IIF NZ TVS,JSR PC,TVCHK	;SET UP TV'S
	LDFPS #40300
	JMP TOPLEVEL	;GO TOP LEVEL US
1$:	BPT		;DOESN'T WORK

HELMES:
STLANC
ENGINS	<CPRTXT ^/Welcome to LOGO />
ENDENG
FRINS	<CPRTXT ^/Bienvenue a LOGO />
ENDLAN
	MOV LVERNF,A
	JSR PC,PRDN
.IIF NZ LSI,	PRTXT ^/ R3D/
	TST DEBSW
	BEQ 1$	;IF DEBUG SWITCH IS ON
		;PRINT MESSAGE
	CPRTXT ^/LOGO being debugged!/
1$:	PRCR		;PRINT CR
	RTS PC

.IFNZ SITS	;LSITS HANDLES ALL THIS DIFFERENTLY
DSKINT:
	SAVE <#PSWPAD,#-PPDLL>			;KLUDGE, TEHSE ARGS FOR BLKO
	SAVE <#-1,#PCRBLK,#.FACAP*400+0>	;THESE ARGS FOR THE INVOKE
	$INVOK
	MOV (P),PPDLCP
	$BLKO			;RESEVRE THE EMERG BLOCK
	SAVE <#SSWPAD,#-SPDLL>			;ARGS FOR BLKO
	SAVE <#-1,#SCRBLK,#.FACAP*400+0>	;ARGS FOR INVOK
	$INVOK
	MOV (P),SPDLCP
	$BLKO			;FOR EMRG BLOCK
	MOV #10,DEFROT		;IF NO DEFAULT, 10 IS THE DEFAULT
	MOV #4,DEFCAP
	SAVE <#0,#4,#<1*400>+1>
	$INVOK			;READ THE C-LIST AT 4 (DEFAULT DIR)
	TST (P)+		;IS ANYTHING THERE?
	BNE HAVDEF		;YES, WE HAVE A DEFAULT DIR.
	SAVE <#-1,#0,#.CPYCP+10>	;NO DEFAULT DIRECTORY,
	$INVOK			;SO USE THE ROOT
	SPOP DEFCAP
HAVDEF:	SAVE <,,DEFCAP>	
	BIS #.FADI,(P)		;WANT TO GET DISK NUMBER
	$INVOK
	REST <A,A>	;DISK NUMBER IS SECOND ON STACK
	ADD #10,A	;CONVERT TO ROT CAP NUMBER
	MOV A,DEFROT	;THIS IS THE DEFAULT ROOT
	MOV #10,C		;FIRST DISK CAP
	CLR A
	CLR DISKS
DSKNAM:	SAVE <#DNAME,#<4+MXNAME>*2,C>	
	BIS #.FARI,(P)		;WANT TO GET DISK NAME
	.INVOK
	BEQ OPNDON		;IF IT FAILS WE MUST BE DONE
	INC DISKS		;ONE MORE DISK
	MOV DNAMEP(A),E		;POINTER TO NAME BLOCK
	MOV #DNAM,F		;POINTER TO NAME READ IN
1$:	MOVB (F)+,(E)+
	BNE 1$
	ADD #2,A		;NEXT DISK NUMBER
	INC C			;POINT TO THE NEXT CAPABILITY
	BR DSKNAM
OPNDON:	CLR (A)			;TERMINATE DISKS
	ADD #6,P		;FIX PDL
	RTS PC
.ENDC

.IF NZ SITS
BRKINT:	SAVE <#-1,#BRKIN1,#.PRCAP*400+0>
	$INVOK		;CREATE THE MAIN PROCESS
	REST MAINPR	;SAVE CAP TO IT
	SAVE <,MAINPR,#<.SPPTP*400>+1>
	$INVOK		;PUT PROCESS INTO OURSELF
	MOV P,A		;PDL FOR MAIN PROCESS
	SAVE <,A,MAINPR>
	BIS #<.PRREG!.PRWRT!6>*400,(P)	;WRITE PDL POINTER
	$INVOK
	SAVE <,#0,MAINPR>
	BIS #<.PRSTOP!.PRWRT>*400,(P)
	$INVOK		;START MAIN PROCESS
	BR BRKPRS	;WE AR ETHE BREAK PROCESS

BRKIN1:	RTS PC		;MAIN PROCESS RETURNS

EBREAK:	ERROR+BRK	;CLOBBER THE MAIN PROCESS TO COME HERE IF HUNG

BRKPRS:	MOV #BRKPDL,P	;MY OWN SPECIAL PDL
BRKPR3:	SAVE <#0,#<'Z-100>*400+'G-100,TYICP>
	MOVB #.TTBRK,1(P)	;TO WAIT FOR ONE OF THESE CHARS
	$INVOK		;WAIT
	CMPB #'Z-100,(P)	;WAS IT A PAUSE?
	BNE BRKPR1
	MOV #-1,BRAKE
BRKPR1:	CMPB #'G-100,(P)	;WAS IT A BREAK?
	BNE BRKPR2
	MOV #1,BRAKE
BRKPR2:	TST (P)+
	TST BRAKE
	BEQ BRKPRS
	SAVE <,#1,MAINPR>
	BIS #<.PRSTOP!.PRWRT>*400,(P)	;WANT TO STOP THE MAIN PROCESS
	$INVOK
	SAVE <,,MAINPR>
	BIS #<.PRREG+7>*400,(P)	;WANT TO READ IT'S PC
	$INVOK
	MOV #BREAKS,A	;TEHMS THE BREAKS
2$:	CMP (P),(A)	;IS THE PC THERE?
	BEQ 1$		;YUP
	TST (A)+	;NEXT
	BNE 2$
	BR BRKPR4
1$:	SAVE <,#EBREAK,MAINPR>
	BIS #<.PRREG+7+.PRWRT>*400,(P)
	$INVOK
BRKPR4:	TST (P)+	;POP PC
	SAVE <,#0,MAINPR>
	BIS #<.PRSTOP!.PRWRT>*400,(P)
	$INVOK
	SAVE <,#.TIRST!.TORST,TYICP>
	MOVB #.TTBIS,1(P)
	$INVOK		;RESET TTY INPUT AND OUTPUT
	BR BRKPR3
.ENDC

.IFNZ TS
PURIFY:	MOV IP,P
	JSR PC,PURINT
	SAVE <#7_8.+0,,#<20+PURPG>_8.+374,#.CRRD+1>
	$MAP			;MAKE PURE CONSTANTS PURE
	MOV #PURPG+1,A		;FIRST I SPACE ONLY PAGE
	MOV #<<LOGEND_-10.>&77>-<<PURPG+1>*8.>,B	;NUMBER OF 512 WORD BLOCKS OF CODE
PURLOP:	SAVE <#7_8.+0,,#374>
	MOVB A,1(P)		;THE PAGE NUMBER
	SAVE <#.CRRD+1>		;ACCESS DESIRED AND SPHERE CAP
	SUB #10,B		;ABOUT TO HACK THIS MANY BLOCKS
	BLT PURLP1		;WE ARE ON LAST PAGE
	INC A			;NEXT PAGE
	$MAP			;MAKE PAGE READ ONLY
	BR PURLOP
PURLP1:	ADD #10,B		;GET LENGTH FOR LAST PAGE
	MOVB B,7(P)		;CLOBBER LENGTH
	$MAP			;PURIFY AND SHORTEN LAST PAGE
	MOV PC,INITED
	CLR DEBSW
	BPT
	JMP START

PURINT:	MOV #PURPG+1+10,A
DELPAG:	CMP -(P),-(P)		;IN DELETE, NOT USED
	SAVE #-3		;DELETE FUNCTION
	MOVB A,1(P)		;WHICH PAGE
	SAVE #1			;SELF
	$MAP			;BETTER NOT FAIL!
	INC A
	BIT #7,A		;LAST PAGE DONE?
	BNE DELPAG
	SAVE <#LSUPBL_8.+0,,#20_8.+374,#.CRWRT+1>	;SHRINK PAGE 0
	$MAP
	JSR PC,SORT
	RTS PC

;THE EXPAND SPACE ROUTINE
;CALL WITH A POINTER IN A TO A BLOCK:
;(A) CURRENT HIGHEST PAGE
;2(A) CURRENT LENGTH OF HIGHEST PAGE
;4(A) HIGHEST PAGE TO USE FOR THIS SPACE
;MAY CLOBBER B AND C
EXSPAC:	TST HALLIM	;HAVE WE ALREADY GOT ALL THAT'S ALLOWED?
	BEQ EXSPA3
	INC 2(A)	;INCREASE HIGH PAGE?
	CMP #10,2(A)	;IS IT ALREADY 4K?
	BEQ EXSPA1	;YUP
	SAVE <#0,#0,#10_8.+374,#.CRWRT+1>	;TO EXPAND THE PAGE
	MOVB 2(A),7(P)	;HOW LONG?
	BISB (A),3(P)	;WHICH PAGE?
	.MAP 		;ATTEMPT TO EXPAND
	BNE EXSPA2	;LOSE?
	ADD #10,P	;POP ARGS OF FAILED CALL
	DEC 2(A)	;WE DIDN'T DO WHAT WE SET OUT TO
EXSPA3:	SEZ		;INFORM OF FAILURE
	RTS PC
EXSPA2:	DEC HALLIM
	CLZ
	RTS PC
EXSPA1:	DEC 2(A)	;NOT INCREASING PAGE SIZE AFTER ALL
	CMP (A),4(A)	;ALREADY ON LAST PAGE?
	BEQ EXSPA3	;IF YES LOSE
	INC (A)		;GO TO NEXT PAGE
	CLR 2(A)	;START WITH 512 WORDS
	SAVE <#0,#0,#10_8.+377,#.CRWRT+1>	;TO CREATE NEW PAGE
	BISB (A),3(P)	;WHICH PAGE?
	.MAP		;TRY TO CREATE
	BNE EXSPA2	;BR ON WINNING
	ADD #10,P	;POP ARGS
	MOV #7,2(A)	;BACK UP
	DEC (A)		;TO PREVIOUS PAGE
	BR EXSPA3	;GO FAIL
.ENDC

GOODBYE:
STLANC
ENGINS	<CPRTXT ^/AND A PLEASANT DAY TO YOU!/>
ENDENG
FRINS	<CPRTXT ^/BONNE JOURNEE/>
ENDLAN
.IF NZ SITS
	IOT
.IFF
	JSR PC,LOGBYE	;CLEAN UP
	JSR PC,ONETYI
	JMP START1
.IFT
	CPRTXT ^/YOU BACK AGAIN???/
	SEZ
	RTS PC
.IFF
LOGBYE:
.IIF NZ CPF,	JSR PC,PRTOFF
.IFNZ FILDSK
	JSR PC,FLSDEF
	JSR PC,DELCPS
	JMP DELALC	;TWO TRYS SHOULD GET ALL OF THEM (I HOPE)
.ENDC
.ENDC
RUNRUG:	JSR PC,CKSST
	BPT
SRTS:	SEZ
	RTS PC

.IF Z UNIX
TSSET:	TST -(P)
	SPUSH D
	SPUSH #.TTMOV*400+2	;SET THE TTY STATUS
	$INVOK
	BR SRTS
.IFF
TSSET:	MOVB D,SGFLAGS		;STORE FLAGS WE WANT IN ARG BLOCK
	BISB #EVENP!ODDP!CRMOD,SGFLAGS	;ALWAYS SET THESE BITS
	SYS IOCTL
	0			;FILE DESCRIPTOR FOR TTY INPUT
	TIOCSETP
	SGTTYB			;POINTER TO ARG BLOCK
	BR SRTS
.ENDC

.IF Z UNIX
.SETLI:	JSR PC,G1NARG
	SAVE <,B,#.TTSLN*400+2>
	$INVOK
	BR SRTS
.ENDC

.IFNZ LSPRNT
.SETLP:	JSR PC,G1NARG
	MOV B,LPLEN
	BR SRTS

.LPLCN:	DEC D
	BLT 1$			;NO ARG, JUST RETURN
	BEQ 2$
	ERROR+WNA
2$:	JSR PC,G1NARG
	MOV B,LPLCNT		;SET THE LINE COUNT
	BR SRTS			;and return no value
1$:	MOV LPLCNT,B
	JMP R1NARG
.ENDC

SETTTY:	SAVE D
	MOV TTYST,D
SETTT1:	JSR PC,TSSET
	REST D
	BR SRTS

WHERE:	JSR PC,GETCNO
	JMP R1NARG	

.IF Z UNIX
GETCNO:	SAVE <,,#.TTCNO*400+2>
	$INVOK
	REST B			;CONDITION CODES SET HERE USED BY INPUTL
	RTS PC
.IFF
GETCNO:	CLR B			;*** UNIX NEEDS THIS FEATURE! ***
	RTS PC
.ENDC

TINECH:	SAVE D
.IIF Z UNIX,	MOV #.TLIPM!.TICVM,D
.IIF NZ UNIX,	MOV #LCASE,D	;NO ECHO, BUT NO CBREAK
	BR SETTT1

ECHOSW:
.IIF Z UNIX,	MOV #.TIECM,C
.IIF NZ UNIX,	MOV #ECHO,C
	BR CASES1
CASESW:
.IIF Z UNIX,	MOV #.TICVM,C
.IIF NZ UNIX,	MOV #LCASE,C
CASES1:	JSR PC,G1NARG
	CLR A
	TST B
	BEQ 1$
	MOV C,A
1$:	BIC C,TTYST
	BIS A,TTYST
	JMP SETTTY
.IFNZ TVS
TVTEST:		BIT #TVF,DFLAGS
	BNE 1$
	ERROR+OTVS
1$:	RTS PC

.TVP:	BIT #TVF,DFLAGS
	BEQ 1$
	JMP RTTRUE
1$:	JMP RTFALS

MEDFON:	MOV #2,A
	BR BIGFO1
SMALLF:	MOV #1,A
	BR BIGFO1
BIGFON:	MOV #0,A
BIGFO1:	JSR PC,TVTEST
	SAVE <,A,TYICP>
	BIS #.TVFNT*400,(P)
	.INVOK
	BNE 1$
	ERROR+WTA
1$:	BIT #DISPF,DFLAGS,DFLAGS	;IS DISPLAY TURNED ON?
	BEQ 2$				;NOPE
	JMP TVSTR1			;GO INIT TV
2$:	JMP KILLD9			;GO RECOMUTE ECHO AREA WITH NO DISPLAY

.ENDC
.IFNZ TIMCLK
CLOCK:
.IFZ UNIX
	SAVE <#SSTATS>	;THE SYSTEM STATUS BLOCK
	$SSTATUS	;FILL IT UP
	MOV STIME,B
	MOV STIME+2,A
.IFF
	SYS FTIME		;GET TIME FROM UNIX
	#.FTIME			;BUFFER TO PUT IT IN
	MOV .MSTIM,B		;A IS R0 IS EVEN
	CLR A			; AND LOW-ORDER PART IS IN A+1
	MUL #74,A		; SO THIS GIVES TWO-WD RESULT
	DIV #1750,A		;MS TIMES 60. OVER 1000. = TICKS
	MOV A,.MSTIM		;SAVE THIS TEMPORARILY
	MOV .STIM2,B		;WHOLE SECONDS IN B WHICH IS ODD
	CLR A			;MAKE IT DOUBLE-LENGTH AGAIN
	MUL #74,A		; THIS PUTS TICKS IN A AND B
	ADD B,.MSTIM		;ADD LOW PARTS
	ADC A			;GOBBLE CARRY BIT
	MOV A,.STIM2		;STASH THIS AWAY
	MOV .STIM1,A		;GOBBLE HIGH TIME
	CLR B
	MUL #74,A		;SIGH
	ADD .STIM2,A		;THIS IS TOTAL HIGH PART
	MOV .MSTIM,B		;THIS IS LOW PART
.ENDC
	JSR PC,GRBAD	;MAKE NODE UP WITHT THE NUMBER IN IT
	BIS #INUM,C	;POINT TOT HE NUMBER
	JMP ORTC	;RETURN IT

UTIMEG:	MOV #HOUR+2,D
	BR UTIME1
UDATEG:	MOV #YEAR+2,D
UTIME1:	MOV #SECOND,E
	MOV #6,F
1$:	CLR (E)+
	SOB F,1$
	SAVE #SECONDS
	MOV #3,F
	.TIME
UTIME2:	MOV -(D),B
	JSR PC,PSHNUM
	SOB F,UTIME2
	MOV #3,D
	JMP SENT.

.GLOBL WTA	;002
.IFZ UNIX
SETTV:	MOV #SECOND,A
	MOV #6,B
1$:	CLR (A)+
	SOB B,1$
	JSR PC,G1IARG
	SPUSH C
	BLT SETTV1
	JSR PC,G1IARG
	TST C
	BLT SETTV1
	CMP #6,C
	BLE SETTV1
	ASL C
	BIS #100000,(P)
	MOV (P)+,SECOND(C)
	SAVE <#SECOND>
	.TIME
SETRT:	SEZ
	RTS	PC
SETTV1:		ERROR+WTA
.ENDC

UWAIT:	JSR PC,G1IARG
.IFZ UNIX
	SAVE <B,C>
.IFF
	DIV #74,B		;TICKS INTO SECONDS (ALL THE PRECISION WE GET)
	MOV B,A			;*** CONSIDER CHANGING DOCUMENTATION TO SECONDS INPUT ***
	TST A
	BGT 1$			;OK IF POSITIVE
	MOV #1,A		;ELSE WAIT AT LEAST 1 SEC
1$:	SAVE <A>
	SYS SIGNAL		;PREPARE TO IGNORE SIGNAL
	14			;SIGALRM
	1			;ODD NUMBER MEANS IGNORE
	REST <A>
	SYS ALARM
	SYS PAUSE
	SEZ
	RTS PC
.ENDC
SLWAIT:
.IFZ UNIX
	$SLEEP
.IFF
	SYS SIGNAL		;MAKE SURE WE'RE STILL CATCHING ALARMS
	14
	1
	CLR A
	SYS ALARM		;SEE WHAT CLOCK SAID
	BLE 2$			;BRANCH IF ALREADY TIMED OUT
	SYS ALARM		;RESTORE ALARM CLOCK
	SYS PAUSE
.ENDC
	SEZ
	RTS PC
.ENDC

.IFNZ FILDSK!MULTTY
DELCP:
DELCAP:	TST A
	BEQ DELCP1
	CMP -(P),-(P)
	SAVE A
	BIS #.DELCP,(P)
	.INVOK
	BNE DELCP1
	ERROR+GDE
DELCP1:	RTS PC
.ENDC
	.SBTTL LOGO TYI/O
ONETYI:
.IIF Z UNIX,	MOV #.TICVM!.TIECM,D
.IIF NZ UNIX,	MOV #LCASE!ECHO!CBREAK,D
	JSR PC,TSSET
	JSR PC,TYI	;GET THE CHARACTER
	JSR PC,SETTTY
	RTS PC

.IF Z UNIX
CTYI:	JSR PC,SAVTTY
	TST -(P)
	SPUSH #.TLIPM+.TIEDM+.TIRBM
	SPUSH TYICP
	BISB #.TTBIC,1(P)
	$INVOK
	SPUSH TYICP
TYWAIT:	$BYTI
	JSR PC,RESTTY
	SPOP B
	JMP R1NARG
.IFF
CTYI:	JSR PC,SAVTTY
	SAVE D
	MOV SGFLAGS,D		;GET EXISTING TTY FLAGS
	BIS #CBREAK,D		;CHAR AT A TIME MODE
	JSR PC,TSSET
	REST D
TYWAIT:	CLR A			;FILDES FOR STANDARD INPUT
	SYS READ
	#RDBYTE
	#1			;READ ONE BYTE
	JSR PC,RESTTY
	MOV RDBYTE,B
	JMP R1NARG
.ENDC

CTYO:	JSR PC,G1NARG	;GET ARGUMENT IN B
CTYO1:	JSR PC,SETTIM	;SET TTY TO IMAGE MODE
.IF Z UNIX
	SPUSH B
	SPUSH TYICP
	$BYTO
.IFF
	MOV B,RDBYTE
	MOV #1,A		;FILDES FOR STANDARD OUTPUT
	SYS WRITE
	#RDBYTE
	#1
.ENDC
	JSR PC,RESTTY
	SEZ
	RTS PC

SETTIM:	JSR PC,SAVTTY
.IF Z UNIX
	TST -(P)
	SPUSH #.TIMGO	;IMAGE OUT
	SPUSH TYICP
	BISB #.TTBIS,1(P)
	$INVOK
.IFF
	SAVE D
	MOV SGFLAGS,D
	BIS #RAW,D
	JSR PC,TSSET		;TOO BAD WE CAN'T HAVE IMAGE OUT WITHOUT IMAGE IN
	REST D
.ENDC
	RTS PC

.IF Z UNIX
RESTTY:	TST -(P)
	SPUSH TTYST
	SPUSH TYICP
	BISB #.TTMOV,1(P)
	$INVOK
	SEZ
	RTS PC

SAVTTY:	SUB #4,P
	SPUSH TYICP
	BISB #.TTRD,1(P)
	$INVOK
	SPOP A
	MOV A,TTYST
	RTS PC
.IFF
RESTTY:	SAVE D
	MOV TTYST,D
	JSR PC,TSSET
	REST D
	SEZ
	RTS PC

SAVTTY:	SYS IOCTL
	#0
	#TIOCGETP
	#SGTTYB
	MOV SGFLAGS,TTYST
	RTS PC
.ENDC
TYI:
.IIF Z UNIX,	SPUSH TYICP
.IIF NZ UNIX,	CLR A		;UNIX STANDARD INPUT FILDES
RLWAIT:
.IF Z UNIX
	$BYTI
	SPOP D
.IFF
	SYS READ
	#RDBYTE
	#1
	MOV RDBYTE,D
.ENDC
	RTS PC

TYO:
	TST BRAKE
	BNE DTYO1
	JSR PC,@DRIBF	;GO TO DRIBBLE ROUTINE IF DRIBBILING
DTYO:
.IF Z UNIX
	SPUSH D
	SPUSH TYOCP
	$BYTO
.IFF
	MOV D,RDBYTE
	MOV #1,A		;UNIX STANDRD OUTPUT FILDES
	SYS WRITE
	#RDBYTE
	#1
.ENDC
DTYO1:	RTS PC
.SPACE:	SAVE D
	MOV #' ,D
.SPAC1:	JSR PC,@PCHR
	REST D
	RTS PC

.CRLF:	SAVE D
	MOV #15,D
	BR .SPAC1

EDITA:
.IF Z UNIX
	TST -(P)	;DUMMY ARG
	SAVE <#.TIEDM!.TERST,#.TTBIS_8.+2>
	$INVOK		;RESET EDIT BUFFER AND ENTER EDIT MODE
.ENDC				;NO SUCH FEATURE IN UNIX (YET!)
	RTS PC

ETYO:
.IF Z UNIX
	TST BRAKE
	BEQ 1$
	RTS PC
1$:	SPUSH D
	SPUSH TYOCP
	BIS #.TTEDM,(P)	;SAY IT SHOULD BE WRITTEN INTO THE EDIT BUFFER
	$BYTO
.ENDC				;NO UNIX LINE EDITOR
	RTS PC


.IFNZ GTL
.GTLOUT:	JSR PC,G1NARG
	JSR PC,GTOUT
	SEZ
	RTS PC

GTOUT:	SAVE <A,B,D,E>
	JSR PC,SETTIM
	CLR A
	ASL B
	MOV #3,D
	MOV #GTLBUF+1,E
GTOUT1:	ASHC #5,A
	BIC #177740,A
	ADD #100,A
	MOVB A,(E)+
	SOB D,GTOUT1
.IF Z UNIX
	SAVE <#GTLBUF,#-4,TYOCP>
	$BLKO
.IFF
	MOV #1,A
	SYS WRITE
	#GTLBUF
	#4
.ENDC
	JSR PC,RESTTY
	REST <E,D,B,A>
	RTS PC
.ENDC
.IF NZ SITS
.HISSP:	JSR PC,GETTTT
	BEQ MYSPE1
	MOVB TTYCPS(E),D
	BR SETSPD

MYSPEE:	JSR PC,G1NARG
MYSPE1:	MOV TYOCP,D

SETSPD:	BIC #177760,B
	MOV B,C
	ASH #4,C
	BIS B,C
	ASH #6,C
	BIS #3,C
	CMP #3,B
	BLT 1$
	BIS #4,C
1$:	SAVE <,C,#.TTSPD*400>
	MOVB D,(P)
	.INVOK
	BNE 2$
	ERROR+TDE
2$:	SEZ
	RTS PC
.ENDC

.IF NZ MULTTY
UGTTYG:	POPS	E	;DEVICE SPEC (NAME OR NUMBER)
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
	JSR	PC,OPEN1
	RTS PC

.TTYP:	JSR PC,UGTTYG
	BEQ TTYP	;SPECIFIED HIS TTY
	CMP -(P),-(P)
	MOVB TTYCPS(E),-(P)
	BR TTYP1
.ENDC

.IF Z UNIX
TTYP:	CMP -(P),-(P)
	SAVE TYICP
TTYP1:	MOVB #.TTPEK,1(P)
	$INVOK		;FIND OUT IF THERE IS A CHARACTER
	TST (P)+	;NEGATIVE IF NONE
	BGE 1$		;YES RETURN TRUE
	JMP RTFALS
1$:	JMP RTTRUE
.ENDC

.IF NZ LSI&LSPRNT
.DIAB:	JSR PC,G1NARG
	MOV B,F
	JSR PC,G1NARG
	MOV F,DIBSPS
	MOV B,DIBLFS
	SEZ
	RTS PC
.ENDC

.IF NZ MULTTY

;DEVTYI-- TYI N OUTPUTS A CHAR FROM TTY N
DEVTYI:	JSR PC,UGTTYG
	BNE 1$		;ANOTHER TTY
	JMP CTYI	;WANTED IT FROM HIS TTY
1$:	CLR -(P)
	MOVB TTYCPS(E),(P)	;CAP WE HAVE TO THE TTY
DTWAIT:	$BYTI		;GET A BYTE
	REST B		;FOR THE USER
	JMP	R1NARG

;DEVTYO-- TYO N M SENDS CHAR M TO TTY N. N MAY BE NAME OR NUMBER.
DEVTYO:	JSR PC,GETTTT
	BNE 1$
	JMP CTYO1
1$:	SAVE <B,#0>
	MOVB TTYCPS(E),(P)	;OUR CAP TO THIS TTY
	$BYTO
RTSPC:	SEZ
	RTS	PC

GETTTT:	JSR	PC,G1NARG	;B _ CHAR
	POPS	E	;DEVICE SPEC
	JSR	PC,DEVNUM	;E _ TTY NUMBER (OR ERROR IF INVALID NAME)
	JSR	PC,OPEN1	;MAKE SURE TTY OK
	RTS PC

.IIF Z SITS,TTYHGH==LSTTY
TTYCHK:	CMP E,#TTYHGH	;TO BIG?
	BLO 1$		;NO
	CMP E,#-1	;IS IT HIS TTY?
	BEQ 1$		;FINE
	ERROR+TDE	;DONT EXIST
1$:	RTS PC

OPEN1:	JSR PC,TTYCHK	;TO BIG A NUMBER
	BEQ 3$		;HIS TTY, DO NOTHING
	TSTB TTYCPS(E)	;ALREADY OPEN?
	BEQ 1$		;NO
	RTS PC
1$:	SAVE <#-1,E,#.TTCAP*400>	;TRY TO CREATE IT
	.INVOK
	BNE 2$		;GOT IT
	ERROR+DIU	;ALREADY IN USE
2$:	MOV (P)+,F	;GET THE CAP NUMBER
	MOVB F,TTYCPS(E)	;SAY THAT WE HAVE IT
	SAVE <,#.TIMGO+.TIMGI,F>	;SET THE STATUS TO IMAGE IN AND OUT
	BISB #.TTMOV,1(P)	;DO A MOVE INTO THE STATUS WORD
	$INVOK
3$:	RTS PC

CLOSE:	POPS E		;GET NUMBER OR SPEC
	JSR PC,DEVNUM	;GET THE NUMBER OR DEVICE
CLOSE1:	JSR PC,TTYCHK	;CHECK FOR VALID NUMBER
	BEQ 1$		;WAS HIS TTY
	MOVB TTYCPS(E),A	;GET THE CAP NUMBER IF OPEN
	BEQ 1$		;NOT OPEN FORGET IT
.IFNZ TVS
	JSR PC,TVTCHK
	BEQ 2$
	SAVE <#0>
	MOVB TTYCPS(E),(P)
	MOVB #.VICAM,1(P)
	SAVE #<.VIABS*400>+17
	$VIDSW			;SWITHC TO BLANKNESS
.ENDC
2$:	CLRB TTYCPS(E)	;CLEAR IT
	JSR PC,DELCAP
1$:	SEZ
	RTS PC

.IFNZ TVS
TVGRAB:	JSR PC,UGTTYG	;OPEN THE TTY
	BEQ TVGRB3	;HIS TTY DOES NOTHING
	JSR PC,TVTCHK
	BNE TVGRB2	;YES TV, GO AHEAD AND TRY TO INIT
TVGRB1:	JSR PC,CLOSE1	;GIVE UP ON THIS ONE
	ERROR+TDE	;DOESN'T EXIST? (WELLL)
TVGRB2:	SAVE <#-1,#140000,#.DSCAP*400+0>	;CREATE A DISPLAY
	MOVB TTYCPS(E),2(P)	;FOR THIS TTY CAP
	.INVOK		;TRY TO GET A DISPLAY
	BEQ TVGRB1	;TOUGH LUCK BUNKY
	MOV (P)+,A	;SAVE CAP TO DISPLAY
	CMP (P)+,(P)+	;EXTRA STUFF NO GOOD FOR TV DISPLAY
	TST -(P)
	SAVE <A,#0>		;CAP TO DISPLAY AGAIN
	MOVB TTYCPS(E),(P)	;TO ATTACH KEYBOARD TO TTY
	MOVB #.TVATC,1(P)	;USE DUMMY FROM ABOVE, DS CAP ON STACK AND THIS
	$INVOK		;SHOULD NEVER FAIL
	JSR PC,DELCP	;NOW WE CAN GET RID OF THE DISPLAY CAP
	CMP -(P),-(P)	;DUMMIES
	SAVE #0
	MOVB TTYCPS(E),(P)
	MOVB #.TVCL,1(P)	;CLEAR SCREEN FUNCTION
	$INVOK
	CMP -(P),-(P)	;DUMMIES
	SAVE #0
	MOVB TTYCPS(E),(P)
	MOVB #.TVREV,1(P)	;REVERSE SCREEN
	$INVOK
	SAVE <,#0,#0>
	MOVB TTYCPS(E),(P)
	MOVB #.TVFNT,1(P)
	$INVOK			;SET FONT 0
	SAVE #0
	MOVB TTYCPS(E),(P)
	MOVB #.VICAM,1(P)	;TTY IS DEST
	SAVE (P)		;AND SOURCE
	$VIDSW			;SWITCH!
TVGRB3:	SEZ
	RTS PC

.SETFO:	JSR PC,G1NARG		;B GETS FONT NUMBER
	SPOPS E			;GET TTY NUMBER
	JSR PC,DEVNUM		;GET NUMBER INTO E
	SAVE <,B,#.TVFNT*400>
	TST E			;IS IT FOR ANOTHER TTY, OR ME
	BPL 1$			;ANOTHER TTY
	MOVB #2,(P)		;MY CONSOLE
	BR 2$
1$:	MOVB TTYCPS(E),(P)
2$:	.INVOK
	BNE 3$
	ERROR+WTA
3$:	SEZ
	RTS PC

.TVOMODE:
	MOV S,A			;REVERSE THE TWO ARGS
	EXCH (A),2(A)
	JSR PC,UGTTYG		;GET THE TTY
	BEQ TVOMOD		;IT IS OUR TTY
	MOVB TTYCPS(E),F	;GET THE TTY NUMBER
	JSR PC,TVTCHK		;BE SURE IT IS A TTY
	BNE TVMOD1		;IT IS A TV
	ERROR+OTVS
TVOMODE:
	MOV #2,F		;THIS CONSOLE
	JSR PC,TVCNSL		;MAKE SURE IT IS A TV
TVMOD1:	JSR PC,G1NARG		;B_ ARGUMENT
	INC B			;CHANGE TO REAL NUMBER SYSTEM UNDERSTANDS
	BEQ TVMOD2		;BARF BAD STUFF
	CMP B,#.TVMOV		;IS IT LEGAL
	BHI TVMOD2		;BAD ARGUMENT
	SAVE <,B,F>		;SAVE ARG AND TTY NUMBER
	BIS #.TVMOD*400,(P)	;SET IN THE FUNCTION
	$INVOK			;SHOULDN'D FAIL
	SEZ
	RTS PC
TVMOD2:	ERROR+WTIB		;BAD ARGUMENT

.TVHERE:
	JSR PC,UGTTYG		;GET THE TTY NUMBER INTO E
	BEQ TVHERE
	MOVB TTYCPS(E),F	;GET THE CAPABILITY NUMBER
	JSR PC,TVTCHK		;IS IT A TV
	BNE TVHER1		;IT IS A TV
	ERROR+OTVS
TVHERE:	MOV #2,F		;FOR THE CAPABILITY FOR THE INPUT CAP
	JSR PC,TVCNSL		;MAKE SURE WE ARE ON TV
TVHER1:	SAVE <,,F>		;READ THE CURSOR POSITION
	BIS #.TVSET*400,(P)	;READ IT,
	$INVOK
	REST <C,B>		;GET THE LINE, THEN CURSOR
	SAVE C			;RESAVE THE LINE NUMBER
	JSR PC,PSHNUM		;PUSH CHARACTER NUMBER ONTO THE S PDL
	REST B			;GET BACK THE LINE NUMBER
	JSR PC,PSHNUM		;PUSH IT
	MOV #2,D		;TELL SENTENCE THERE ARE TWO THINGS TO BE HACKED
	JMP SENT.		;RETURN IT TO THE USER

.CURSET:
	MOV S,A			;POINT INTO THE S STACK
	EXCH (A),2(A)		;EXCHANGE THE TWO ARGUMENTS
	JSR PC,UGTTYG		;GET THE TTY NUMBER INTO E
	BEQ CURSET		;JUST MY CONSOLE
	MOVB TTYCPS(E),F	;GET THE TTY CAPABILITY
	JSR PC,TVTCHK		;IS IT A TV
	BNE CURST1		;YES
	ERROR+OTVS
CURSET:	MOV #2,F		;FOR THE TTY INPUT CAP
	JSR PC,TVCNSL		;MAKE SURE IT IS A TV
CURST1:	MOV @S,C		;GET POINTER TO THE STRING
	MOV #7777,D
	BIT D,C			;BETTER NOT BE EMPTY
	BNE 3$			;OKAY
2$:	ERROR+WTA		;LOSER
3$:	JSR PC,.LOADC		;A,B<= (C)
	MOV A,C			;NEXT ELEMENT
	MOV #SNUM,A		;CONVERT TO SNUM
	JSR PC,CONVERT
	BEQ 2$			;LOST FOR SOME REASON
	SPUSH B			;THERE IS THE CHARACTER NUMBER
	BIT D,C			;STILL LIST LEFT
	BEQ 2$			;NOPE
	JSR PC,.LOADC		;LOAD UP NEXT ELEMENT
	BIT D,A			;FINISHED
	BNE 2$			;NO, WHAT A LOSER
	MOV #SNUM,A		;CONVERT AGAIN
	JSR PC,CONVERT
	BEQ 2$
	SPUSH B			;SAVE THE LINE NUMBER
	SPUSH F			;AND THE TTY CAPABILITY
	BIS #<.TVSET+.TTWRT>*400,(P)	;SET THE CURSOR POSITION
	.INVOK			;HOPE THIS WINS
	BEQ 1$			;FAILED (BAD POSITION?)
	SEZ			;RETURN TRIUMPHANT
	RTS PC
1$:	ERROR+OOB		;TO FAR ONE WAY OR THE OTHER

TVCNSL:	SAVE <,,#2>		;MAKE SURE A TV
	BIS #.TTTYP*400,(P)	;SET IN THE FUNCTION
	$INVOK			;GET THE TYPE OF THE TTY
	BIT #200,(P)+		;CHECK THE TV BIT
	BEQ 1$			;NOT A TV
	RTS PC
1$:	ERROR+OTVS

TVTCHK:	SAVE <,,#0>
	MOVB TTYCPS(E),(P)
	BIS #.TTTYP*400,(P)	;GET THE TYPE
	$INVOK
	BIT #200,(P)+	;IS IT A TV?
	RTS PC
.ENDC

DEVNUM:	PUSH A
	SPUSH B
	MOV #SNUM,A	;TRY TO CONVER TO NUMBER
	MOV E,B		;POINTER TO THE STRING OR NUMBER
	JSR PC,CONVERT
	BEQ 1$		;FAILED TRY TO GET A STRING
	MOV B,E		;RETURN VALUE IN E
2$:	JMP RETB	;RETURN
1$:	MOV #LSTR,A	;INTO STRING
	JSR PC,CONVERT
	BEQ DNUM2	;FAILED IN BOTH
	MOV B,E		;POINTER TO THE NAME
;	JSR PC,DEVNAM	;FIND THE DEVICE NAME
;	BNE 2$		;GOT IT
DNUM2:	PUSHS E		;PUSH BACK THE INVALID NAME
	ERROR+DNA	;BAD NAME

;DEVNAM:	ERROR+SIT

.IFNZ PTBOX
TBREST:	PUSH C
	MOV #CONSO,C
	JSR PC,TBINIT
	POP C
	RTS PC
TBINIT:	TST PTBF
	BNE 1$		;OWNS ONE
	RTS PC
1$:	JSR F,ACSAV
	MOV #PTBTAB,B
TBINT2:	MOV #4,A
TBINT3:	CMPB C,(B)
	BEQ TBINT4
	TST (B)+
	SOB A,TBINT3
TBINSZ:	REST <A,B,,D,E,F>
	SEZ
	RTS PC
TBINT4:
;	TST F
;	BMI TBINT5
	TST (B)
	BPL TBINT5
TBINCZ:	REST <A,B,,D,E,F>
	CLZ
	RTS PC
TBINT5:	TST -(P)	;FOR THE SETTING OF THE STATUS BELOW
	CMP -(P),-(P)
	SPUSH TYOCP
	BIS #.TTRD*400,(P)
	$INVOK		;READ OLD STATUS
	TST -(P)
	SPUSH #.TIMGO
	SPUSH TYOCP
	BIS #.TTBIS*400,(P)	;BIS THE IMAGE OUT BIT
	$INVOK
;NOTE HERE ON THE STACK IS THE OLD STATUS, THEN AN EMPTY WORD
	MOV #21,D
	JSR PC,TYO	;OUTPUT THE ATTENTION CHARACTER TO THE THORTON BOX
	MOV B,D
	SUB #PTBTAB,D	;GET THE INDEX OF THE THING SELECTED
	MOV TBCCHR(D),D	;GET THE SELECT CHARACTER
	JSR PC,TYO
	BIS #100000,(B)
	MOV (B),C
	BIC #TBMASK,C
	CMP C,#CONSO
	BNE TBINT6
	MOV OTTYST,(P)	;CHANGE THE STATUS
	BIS #.TIRST,(P)
	BR TBINT7	;DESTROY OLD USER
TBINT6:	BIS #.TIMGO,(P)
TBINT7:	SAVE TYOCP	;THE CAPABILITY
	BIS #.TTMOV*400,(P)	;SET THE TTY STATUS
	$INVOK
	MOV #PTBTAB,C		;POINT TO THE TABLE AGAIN
	MOV #4,D
TBINT8:	TST (C)
	BGE TBINT9
	CMP C,B
	BEQ TBINT9	;DONT CLEAR THE ONE WE JUST SET
	BIC #100000,(C)
TBINT9:	TST (C)+
	SOB D,TBINT8
	BR TBINCZ
.ENDC
.ENDC	;END TYI/O LSICOND

.exami:	jsr pc,g1narg
	mov (b),b
	jmp r1narg

.DEPOS:	JSR PC,G1NARG
	MOV B,D
	JSR PC,G1NARG
	MOV B,(D)
	SEZ
	RTS PC
.IFNZ SITS

EXNODE:	MOV #NODEHP,A	;POINTER TO BLOCK
	JSR PC,EXSPAC	;TRY TO EXPAND NODE SPACE
	BEQ EXNOD1	;FAILED
	ADD #2000,NODTOP
EXNOD1:	RTS PC		;LOSE OR WIN

.IFF

;ROUTINE TO EXTEND NODE SPACE; MUST SLIDE ARRAY SPACE DOWN
;TO MAKE ROOM
;CLOBBERS A,B,C
EXNODE:	MOV NODTOP,A	;A_TOP OF NODE SPACE
	ADD #2000,A	;EXTEND IT
	CMP A,#NODESP+40000	;MORE THAN 8K WORDS?
	BHI 2$		;SORRY, CAN'T DO THAT (ONLY 12 BITS OF NODE PTRS)
	JSR PC,TOPCOM	;COMPUTE TOP
	BLOS EXNOD1	;YUP, GO ON
1$:	JSR PC,.PRESS
	JSR PC,TOPCOM
	BLOS EXNOD1
2$:	SEZ
	RTS PC

TOPCOM:	MOV ARTOP,B	;B_ARTOP
	ADD #2000,B	;ARRAY SPACE WILL BE SLID UP IF NODESP EXPANDED
	CMP B,PPDTOP	;IS THERE ROOM TO SLIDE?
	RTS PC
			;NOW, ADVANCE ARRAY SPACE POINTERS
EXNOD1:	TST AROVER
	BEQ 1$
	ADD #2000,AROVER
1$:	MOV AFREE,C	;C_PTR TO NEXT FREE BLOCK
	BEQ EXNOD2	;UNLESS PTR WAS NULL,
	ADD #2000,AFREE	; ADVANCE IT
EXNOD2:	MOV ARYAD,D	;D_PTR TO BLOCK AFTER CURRENT ARRAY
	ADD #2000,ARYAD	;ADVANCE ARYAD (AND NODTOP)
EXNODL:	CMP D,ARTOP	;END OF SPACE?
	BEQ EXNODD	;YES, DONE WITH POINTERS
	BLO 1$		;NO, CONTINUE
	ERROR+BUG
1$:	CMP C,D		;IS NEXT BLOCK FREE?
	BEQ EXNOD3
	ADD #2000,@(D)	;NO, IT'S AN ARRAY. ADJUST PTR TO IT
	ADD 2(D),D	;AND POINT TO NEXT BLOCK
	BR EXNODL
EXNOD3:	ADD 2(D),D	;POINT TO NEXT BLOCK
	MOV (C),E	;POINT TO NEXT FREE BLOCK
	BEQ EXNODL	;IF THERE WAS NONE, PROCEED.
	ADD #2000,(C)	;ELSE, ADVANCE OLD BLOCK'S FWD PTR
	ADD #2000,4(E)	;AND NEW BLK'S BK PTR
	MOV E,C		;OLD IS NEW
	BR EXNODL

EXNODD:	MOV B,ARTOP	;SHIFTED BOUND
	MOV B,A
	SUB ARYAD,A
	ASR A		;# OF WORDS IN ARRAY SPACE
	BEQ EXNOD4
EXNDL1:	MOV -2002(B),-(B)	;SLIDE ARRAY SPACE
	SOB A,EXNDL1
EXNOD4:	RTS PC
.ENDC
.IFNZ LSI
;SSYTEM CHECKING CODE

;ROUTINE TO XOR ALL PURE CODE
XORPUR:	MOV #PURES,A
	MOV #<<PUREE-PURES>/2>&77777,B	;COUNT OF PURE WORDS
	CLR F		;WHERE THE XOR IS KEPT
1$:	MOV (A)+,C	;GET A WORD
	XOR C,F		;XOR IT IN
	SOB B,1$
	RTS PC

SETXOR:	JSR PC,XORPUR
	MOV F,SYSXOR	;SAVE THE XOR OF THE SYSTEM
	RTS PC

CHKXOR:	JSR PC,XORPUR
	MOV SYSXOR,C
	XOR F,C	
	RTS PC
.IFZ 105		;MAYBE FASTER WAY TO SET UP TABLE
FASSET:	MOV #SYSTAB,A
	MOV #16.,B
9$:	CLR (A)+
	SOB B,9$
	MOV #PURES,A
	MOV #<<PUREE-PURES>/2>&77777,B
	MOV #2,D
	MOV #SYSTAB-2,F
1$:	MOV (A)+,C
	MOV F,E
2$:	ADD D,E
	ROR C
	BEQ 3$
	BCC 2$
	XOR A,(E)
	BR 2$
3$:	BCC 4$
	XOR A,(E)
4$:	SOB B,1$
	RTS PC
.ENDC





;XOR ADDRESS+2 IN FOR EVERY WORD THAT HAS BIT SET
;BIT NUMBER IN D, RETURNS WITH TABLE ADDRESS IN E
BITXOR:	MOV #PURES,A
	MOV #<<PUREE-PURES>/2>&77777,B
	MOV #1,C
	ASH D,C
	MOV D,E
	ASL E
	ADD #SYSTAB,E
	CLR F
1$:	BIT C,(A)+	;TEST FOR BIT IN C
	BEQ 2$
	XOR A,F
2$:	SOB B,1$
	RTS PC

;SET BIT XOR FOR BIT (D)
SETBIT:	JSR PC,BITXOR
	MOV F,(E)
	RTS PC

;CHECK BIT XOR FOR BIT (D)
CHKBIT:	JSR PC,BITXOR
	MOV (E),A
	XOR A,F
	RTS PC

;SETUP TABLES FOR FIRST TIME, OR AFTER A PATCH
SETTAB:	JSR PC,SETXOR	;DO THE XOR
	MOV #15.,D	;START AT THE TOP
1$:	JSR PC,SETBIT
	DEC D
	BGE 1$
	MOV PC,XORFLG	;INDICATE THAT SYSTEM HAS BEEN XORED
	SEZ		;IF CALLED BY USER
	RTS PC

;CHECK THE WORLD
CHKTAB:	JSR PC,CHKXOR
	BEQ XRTSPC
	SAVE #0		;ADDRESS+2 OF CHANGED WORD
	SAVE C		;THESE ARE THE BITS THAT CHANGED IN THE WORD
	MOV #15.,D
CHKTA1:	JSR PC,CHKBIT	;CHECK THIS BIT
	BEQ CHKTA2		;THIS BIT SHOULD BE RIGHT
	BIT C,(P)	;THIS BIT SHOULD BE WRONG
	BEQ MULERR	;MULTIPLE ERROR
CHKTA4:	TST 2(P)	;HAVE WE ALREADY GOT AN ADDRESS?
	BNE CHKTA3		;YUP
	MOV F,2(P)	;THIS IS THE ERROR ADDRESS
CHKTA3:	CMP F,2(P)	;SAME ERROR ADDRESS?
	BNE MULERR	;NOPE, MULTIPLE WORD ERROR
CHKTA5:	DEC D
	BGE CHKTA1
	REST <A,B>	;A GETS WRONG BITS, B GETS ADDRESS+2	
	XOR A,-(B)	;FIX THE ERROR
	MOV A,WRNGBT	;SAVE FOR LATER
	MOV B,WRNGAD
	SAVE PCHR
	MOV #LSISTY,PCHR	;SPECIAL "SUPER" TYO
	PRTXT <
MEM ERR CORRECTED @>
	MOV WRNGAD,A
	JSR PC,PRONL
	PRTXT < BITS:>
	MOV WRNGBT,A
	JSR PC,PRONL
	JSR PC,.CRLF
	REST PCHR
	INC WRNGCN	;ONE MORE CORRECTED
	RTS PC

CHKTA2:	BIT C,(P)
	BNE MULERR	;THIS BIT SHOULD BE RIGHT, IS WRONG
	BR CHKTA5

MULERR:	SAVE PCHR
	MOV #LSISTY,PCHR	;SPECIAL SUPER TYO
	PRTXT <
WARNING, MULTIPLE MEMORY ERROR DETECTED, IGNORING
>
	REST PCHR
	MOV PC,IGNERR
	CMP (P)+,(P)+
XRTSPC:	RTS PC

SYSCHK:	TST IGNERR	;TOO MANY ERRORS?
	BNE SYSCH1
	JSR F,ACSAV
	TST XORFLG	;HAS SYS BEEN XORED?
	BNE 1$
	JSR PC,SETTAB	;XOR THE SYSTEM
1$:	JSR PC,CHKTAB	;CHECK THE SYSTEM
	JSR F,ACRES		
SYSCH1:	SEZ
	RTS PC

;INCREMENTAL CHECK
INCHK:	TST IGNERR	;IGNOREING ERRORS?
	BNE INCHK3	;THEN DON'T LOOK FOR ANY
	JSR F,ACSAV
	MOV INCNT,B	;GET OLD LEFTOVER COUNT
	BEQ INCHK1	;FINISHED LAST CHECK, RESTART
	MOV INADDR,A	;OLD ADDRESS
	MOV INXOR,F	;OLD XOR
	SUB #500.,B
	BLT 1$
	MOV B,INCNT
	MOV #500.,B
	BR 2$
1$:	ADD #500.,B	;THE REAL COUNT LEFT OVER
	CLR INCNT	;FLAG THAT WE WILL BE FINISHED THIS CHECK
2$:	MOV (A)+,C	;GET A WORD
	XOR C,F		;PUT INTO CHECKSUM
	SOB B,2$
	TST INCNT	;DONE?
	BNE INCHK2	;NOPE, SAVE FOR NEXT TIME
	TST F		;SHOULD BE ZERO
	BEQ INCHK1	;YUP, WIN
	JSR PC,SYSCHK	;CHECK FOR REAL
INCHK1:	MOV #PURES,A
	MOV #<<PUREE-PURES>/2>&77777,INCNT
	MOV SYSXOR,F
INCHK2:	MOV A,INADDR
	MOV F,INXOR
	JSR F,ACRES
INCHK3:	RTS PC

.ENDC
.SBTTL SYSTEM OBLIST SORT
DC PUREE,.
;KLUDEGY SELF MODIFIYING CODE
.IFNZ LSI&TIMCLK
GETTIM:	MOV #207,GETTIM
	JMP RGETTI
.ENDC
.IFNZ LSI
SORT:	MOV #207,SORT	;CLOBBER YOURSELF
	JMP RSORT
STORAG=.		;THE REST OF THE ROUTINE IS USED FOR FREE STORAGE
DC ERTXT,.
.=.+ERTXTL		;LEAVE ROOM FOR THE ERROR TEXT
.ENDC
.IIF Z LSI,SORT:
RSORT:	MOV #SOBLST+2,A	;POINTER TO START AT
	MOV #SOBLSU,B	;PLACE TO FINISH
	MOV PC,F	;SET "SOMETHING MOVED" FLAG
SORTUG:	TST F	;DID SOMETHING GET MOVED LAST PASS?
	BEQ SORTDN	;NO, WE ARE DONE
	CLR F	;NOTHING SO FAR THIS PASS
	MOV A,C	;POINTER INTO TABLE
SORTU:	MOV (C)+,D	;START OF SORT UP
	MOV (C),E	;THINGS TO SORT
	ADD #4+SOBLST,D	;GET TO STRING
	ADD #4+SOBLST,E	;FOR BOTH
SORTU3:	CMPB (D),(E)	;COMPARE THE WORDS
	BLT SORTU2	;IN ORDER, GO TO NEXT PAIR
	BEQ SORTU1	;SAME, CHECK NEXT WORD
	INC F	;HAVE TO SWITHC THEM
	MOV -(C),D
	MOV 2(C),(C)+
	MOV D,(C)
SORTU2:	CMP C,B	;ARE WE AT END?
	BNE SORTU	;NO, CONTINUE
	TST -(B)	;YES, NEXT TIME NOT SO FAR
	BR SORTDG	;GO TO DOWNWARD SORT
SORTU1:	TSTB (D)+
	BNE 1$	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
1$:	TSTB (E)+
	BNE 2$
	MOV #ZERO,E
2$:	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTU3	;OK, CONTINUE
	BPT	;BARF, THEY'RE EQUAL????
	BR SORTU3

SORTDG:	TST F	;DID WE MOVE ANY ON THE UP PASS?
	BEQ SORTDN	;NO,DONE
	CLR F	;CLEAR FLAG
	MOV B,C	;SET POINTER
SORTD:	MOV (C),D
	MOV -(C),E
	ADD #4+SOBLST,D
	ADD #4+SOBLST,E
SORTD3:	CMPB (D),(E)
	BGT SORTD2
	BEQ SORTD1
	INC F
	MOV (C)+,D
	MOV (C),-(C)
	MOV D,2(C)
SORTD2:	CMP C,A
	BNE SORTD
	TST (A)+
	BR SORTUG
SORTD1:	TSTB (D)+
	BNE 1$	;NO, OK
	MOV #ZERO,D	;YES, KEEP IT THAT WAY
1$:	TSTB (E)+
	BNE 2$
	MOV #ZERO,E
2$:	CMP D,E	;ARE THEY THE SAME (I.E. ZERO?)
	BNE SORTD3
	BPT
	BR SORTD3

SORTDN:	RTS PC

.IFNZ LSI&TIMCLK
TCUDAT=174770
TCUTIM=TCUDAT+2
TCUSEC=TCUTIM+2

RGETTI:
	SAVE 4
	MOV #1$,4		;IF THERE IS NO CLOCK
	MOVB TCUDAT+1,B		;GET THE MONTH
	REST 4
	MOV #LSYEAR,A		;POINTER TO THE YEAR
	MOV #79.,(A)		;PROBABLY 79
	CMPB #11.,B		;UNLESS IT'S NOV OR DEC
	BGT 2$			;NOPE
	DEC (A)			;STILL IN 78
2$:	MOV B,-(A)		;STUFF THE MONTH
	MOVB TCUDAT,B		;GET THE DAY
	MOV B,-(A)
	MOVB TCUTIM+1,B		;THE HOUR
	MOV B,-(A)
	MOVB TCUTIM,B
	MOV B,-(A)
	MOV TCUSEC,-(A)
	RTS PC

1$:	CMP (P)+,(P)+
	REST 4
STLANC
ENGINS <	CPRTXT ^\Date and time YY/MM/DD HH:MM:SS :\>
ENDENG
FRINS <		CPRTXT ^\Date et heure AA/MM/JJ HH:MM:SS :\>
ENDLAN
	MOV #LSYEAR+2,C
GETNM1:	CLR B
	CLR F
GETNUM:	JSR PC,ONETYI
	CMP #177,D
	BEQ RGETTI
	CMP #15,D
	BEQ NOTIM1
	JSR PC,TYO
	SUB #60,D
	BLT GOTNUM
	CMP #10.,D
	BLE GOTNUM
	INC F
	MUL #10.,B
	ADD D,B
	BR GETNUM
GOTNUM:	CMP #LSSEC,C
	BEQ NOTIME
	TST F
	BEQ GETNM1
1$:	MOV B,-(C)
	BR GETNM1
NOTIM1:	TST F
	BEQ NOTIME
	MOV B,-(C)
NOTIME:	RTS PC
.ENDC

.IIF NZ NOISPACE,STORAG:
DC CODEND,.
.IIF DF PASS2,PAD ^\CODEND=\,\.
LOGEND=.
.IIF NZ LSI,.IIF DF PASS2,PAD ^\STORAG=\,\STORAG
DC PASS2,0

	.END START

