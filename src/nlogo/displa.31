	.SBTTL TURTLE,DISPLAY, RANDOM DEVICES, AND OTHER CRAP

.MACRO GTJUMP ADDR
.IFNZ GTL
	TST GTLDF
	BEQ .+6
	JMP ADDR
.ENDC
.ENDM

;CONVERT ADDRESS TO DISPLAY PUSHJ
;ARGUMENT IS AC
.MACRO MAKEPJ F
	ASR F
	ADD DRELOC,F
	BIS #DPUSHJ,F
.ENDM

;CONVERT DISPLAY CONTROLLER ADDRESSES TO REAL WORLD ADDRESSES
;	ARG IS AC
.MACRO MAKEAD F
	SUB DRELOC,F
	ASL F
.ENDM
.IFZ LSI	;LSICOND, EXTENDS TILL MUSIC PRIMITIVES

MUWAIT:
	ERROR+SIT
	.SBTTL RANDOM DEVICE CONTROL

.IFNZ AI

ATOD:	ERROR+SIT
.IFZ 105
	JSR PC,G1NARG
	TST B		;IS B NEGATIVE
	BLT ATODLS	;YES, SO NO GOOD
	CMP #7,B	;IS B TOO BIG A CHANNEL NO.?
	BLT ATODLS	;YES ITS BIGGER THEN 7
	ASH #10.,B
	MOV B,ATODB
	TST ATODB
	BPL .-4
	MOV ATODB,B
	BIC #176000,B
	SUB #1000,B
	JMP R1NARG
ATODLS:	ERROR+WTA	;HERE FOR BAD ARG TO ATOD
.ENDC


BITOUT:	ERROR+SIT
.IFZ 105
	JSR PC,G1NARG
	MOV B,DIGO
BITOU1:	SEZ
	RTS PC
.ENDC
RELAY:	ERROR+SIT
.IFZ 105
	JSR PC,G1NARG
	MOV B,F
	JSR PC,G1NARG
	MOV #1,C
	ASH B,C
	TST F
	BEQ RELAY1
	BIS C,DIGO
	BR BITOU1
RELAY1:	BIC C,DIGO
	BR BITOUT

.ENDC
DEVICE==160106	;THE ADDRESS OF THE BUFFER REGISTER
DEVADD==160104	;THE SELECTOR REGISTER

BOXIN:	JSR PC,G1NARG
	JSR PC,RDBOX	;READ THE BOX
	JMP R1NARG

SWITCH:	JSR PC,G2NARG
	CMP A,#15
	BGT SWTWTA
	TST A
	BLT SWTWTA
	JSR PC,RDBOX	;BOX NUMBER IN B, RETURNS THE BOX IN B
	MOV #1,C	;GET THE BIT
	ASH A,C		;SHIFT THE BIT THE NUMBER OF THE SWITCH
	BIT C,B		;IS THE BIT SET
	BNE 1$		;YES
	JMP RTFALS	;RETURN FALS
1$:	JMP RTTRUE	;RETURN TRUE

RDBOX:	ERROR+SIT
SWTWTA:	ERROR+SIT
.IFZ 105
	TST B		;IS IT NEGATIVE
	BGE .+4
SWTWTA:	ERROR+WTA	;BAD ARG
	CMP B,#3	;TO LARGE BOX NO.
	BGT SWTWTA
	ASH #10.,B	;THE NUMBER IS SHIFTED 10 PLACES
	MOV B,DEVADD	;TELL IT WHICH BOX TO READ
	CLR DEVICE	;TELL IT TO GO
	TST DEVICE	;DATA IN YET
	BPL .-4		;NOT YET
	MOV DEVICE,B	;GET THE DATA INTO B
	COM B		;THE BITS ARE COMPLEMENTED
	RTS PC
.ENDC
.ENDC
;ROUTINE FOR THE EYETURTLE.  WE WANT TO FILL A LOGO ARRAY WITH WHAT APPEARS
;A-TO-D CHANNEL, SAMPLING THAT A-TO-D 720 TIMES IN ONE ROTATION OF THE TURTLES'S
;EYE. THE TURTLE SENDS US A PULSE WHENEVER IT SHOULD BE SAMPLED
EYE:	ERROR+SIT
.IFZ 105
	SPUSH #1	;TELL AMAKE THERE IS ONLY ONE ARG
	SPUSH PS	;SAVE PSW AND PRIORITY
	MOV @S,A	;S POINTS TO ARRAY NAME
	JSR PC,AMAKE	;FIND TOP OF THE ARRAY
	ADD #2,S	;POP STACK
	CMPB 5(B),#260	;TEST TYPE BYTE
	BEQ 1$		;BRANCH IF IT'S AN INTEGER ARRAY
	ERROR+BAT	;BAD ARRAY TYPE
1$:	CMP 10.(B),#720.;IS THE FIRST DIMENSION 720. LONG?
	BGE 2$		;AT LEAST THAT BIG
	ERROR+BAT	;TOO SMALL,TOO BAD
	CRDPOS==5	;USE INTERFACE LINE FIVE
;THE A-TO-D DEVICE BUFFER REFERRED TO ABOVE IS ALSO THE SWITCHBOX ADDRESS
;REGISTER. I DON'T KNOW WHY.
2$:	ADD #12.,B	;B NOW POINTS TO FIRST ENTRY OF ARRAY
	MOV #CRDPOS,D
	ASH #10.,D	;THIS MAKES THE LINE-SELECTION ACCEPTABLE TO ADDRESS BUFFER
	MOV D,ATODB	;AND WE HAVE NOW SELECTED INTERFACE LINE FIVE.
	MOV #720.,C	;WE WANT 720. POINTS
	SPL 7		;LOCK OUT ALL INTERRUPTS
GNDATA:	CLR DEVICE	;TAP THE EYETURTLE ON THE SHOLDER,GET READY FOR A PULSE
	TST DEVICE	;DID WE GET A TIMING PULSE BACK YET?
	BPL .-4		;WAIT FOR THAT PULSE
	TST ATODB	;IS CONVERSION COMPLETE?
	BPL .-4		;NO, WAIT
	TST (B)+	;ARRAYS ARE DOUBLEWORD LONG, SO INCR PNTR
	MOV ATODB,(B)+	;YES PUT IN THE ARRAY AND INCREMENT POINTER
	SOB C,GNDATA	;IF NOT YET 720 POINTS GO GET ANOTHER
	SPOP PS		;RESTORE THE OLD PRIORITY
	SPOP A		;CLEAN THE P-PDL UP
	SEZ		;TELL EVAL THAT NOTHING IS BEING RETURNED
	RTS PC
.ENDC
.IIF NZ HALFLG, .INSRT HALHACK >


.SBTTL DISPLAY AND TURTLE

;A  BRIEF DESCRIPTION OF WHAT IS LEFT TO BE DONE TO THIS PROGRAM.


;4)	DECIDING WHAT SNAP AND WIPE REALLY ARE GOING TO DO.
;AT THIS TIME, SNAP OUTPUTS THE ENTIRE SCREEN
;AND WIPE ERASES ONLY TOP LEVEL OCCURRENCES OF THE SNAP



.ENDC
.IFNZ NPLOT!NDISP!TURFLG
;DISPLAY AND TURTLE COMMANDS
	.IFZ <NDISP!NPLOT>
	DLT==0
	DRT==1
	DFD==2
	DBK==3
	DPD==4
	DPU==5
	.ENDC

	CURY==4		;USED FOR INDEXING OFF CURX FOR
	CURA==10	;PLOTTER AND DISPLAY
	COSA==14
	SINA==20
	RCURX==24

BACK:	GTJUMP GTBACK
	MOV	#"@C,D	;D _ CHAR. TO SEND TO TURTLE
	MOV	#DBK,E	;IN ORDER TO CAUSE 1 STEP OF MOTION
	BR	TURD	;THE TOP BYTE CONTAINS THE CHAR.
LEFT:	GTJUMP GTLEFT
	MOV	#"BA,D	;IF THE NUMBER OF STEPS IS NEGATIVE
	MOV	#DLT,E
	BR	TURD
RIGHT:	GTJUMP GTRIGH
	MOV	#"AB,D	;E CONTAINS THE ADDRESS OF THE PARALLEL
	MOV	#DRT,E	;DISPLAY ROUTINE
	BR	TURD
FORWARD:	GTJUMP GTFORW
	MOV	#"C@,D
	MOV	#DFD,E
;THE MOVE COMMANDS ARE PROCESSED HERE

TURD:
.IFZ FPPF
	JSR	PC,G1NARG	;B_SINGLE PRECISION NUMBER
.IFF
	JSR PC,G1NUM	;FA_FLOATING NUMBER
	BNE 1$
	ERROR+WTAB
1$:
.ENDC
	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;DISPLAY, OR REAL TURTLE?
	BEQ	TURD.1
	JMP	(E)		;DISPLAY
	.ENDC
TURD.1:	BIT	#TURTF,DFLAGS
	BNE	TURD.A	;TURTLE
	.IFNZ	NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	TURD.E
	JMP	(E) ;HANDLE PLOTTER COMMAND LIKE DISPLAY
	.ENDC
TURD.E:	ERROR+VTD   ;ONLY VALID FOR TURTLE,DSPLY,OR PLTR
TURD.A:
.IFNZ FPPF
	SETI		;IF IT'S A TURTLE CHANGE FLOATING
	STCFI FA,B	;TO AN INTEGER
	SETL
.ENDC
	TST	B
	BGE	TURD.2
	NEG	B	;MAKE NUMBER POSITIVE
	SWAB	D	;AND SWITCH CHARS
;NOW DO THE MOVING
TURD.2:	CMP	E,#DLT	;FOR LEFT OR RIGHT USE FUDGE FACTOR
	BEQ	TURD.0
	CMP	E,#DRT
	BEQ	TURD.0
	BR	TURD.3
TURD.0:	ASL B
	MOV B,A
	MOVB TURF,E	;MULTIPLY BY FIRST BYTE
	MUL E,A
	MOVB TURF+1,E	;DIVIDE BY SECOND
	DIV E,A
TUTE:	BVS TUTER	;OVERFLOW--LOSE.
	MOV A,B
	ASR B
	ADC B		;DIVIDE BY TWO, ROUNDING.
TURD.3:	MOV TURDN,E	;TURTLE DEVICE NUMBER (FOR TYO ROUTINES)
	SUB	#6.,B
	BLT	TURD.5	;NEVER EVEN MAKE IT TO FULL ACCELERATE MODE
	MOV	#10,C
	CLR A		;AGAIN, DIVIDE BY 4 (8)
	DIV #4,A
	MOV	B,F
		;REM.=NUMBER OF STEPS NEEDED BESIDES ACCELERATION
;		AND DECELERATION WHICH CAN'T BE TAKEN IN 8'S
	INC	F	;F_TOTAL NUMBER OF 1 STEPS
	JSR	PC,TUROUT
	ADD	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	MOV A,F	;F _ NUMBER OF 8 STEPS
	INC F
	ADD C,D	;D_CHAR FOR 8 STEPS
	JSR	PC,TUROUT
	SUB	C,D	;D_CHAR FOR 2 STEPS
	JSR	PC,TURTYO
	SUB	C,D	;D_CHAR FOR 1 STEP
	JSR	PC,TURTYO
.IIF NZ PTBOX,	JSR PC,	TBREST
	SEZ
TURD.4:	RTS PC

;FOR FEWER THAN 14 STEPS, JUST SEND OUT 1 STEPS
;(IN THE WORS CASE, THIS STUPID ALGORITHM REQUIRES TWICE AS
;MANY CHARS AS THE OPTIMAL ALGORITHM)
TURD.5:	ADD	#6.,B	;RESTORE WHAT WAS SUBTRACTED
	MOV	B,F
	INC F
	JSR	PC,TUROUT
	BR	TURB.2
TUTER:	ERROR+TGDZ	;TURTLE GETTING DIZZY
.ENDC

.IFNZ TURFLG
;MORE TURTLE COMMANDS

LAMPON:	GTJUMP GTLON
	MOV	#'!,D
	BR	TURB
LAMPOF:	GTJUMP GTLOFF
	MOV	#'",D

TURB:	JSR	PC,TURTST
TURB.1:	MOV	TURDN,E
	JSR	PC,TURTYO
TURB.2:	.IIF NZ PTBOX,	JSR PC,TBREST
	SEZ
	RTS PC
.ENDC
.IFNZ TURFLG!NDISP!TVS
PENDOWN:	GTJUMP GTPD
	MOV	#'0,D
	MOV	#DPD,E
	BR	TURC
PENUP:	GTJUMP GTPU
	MOV	#'8,D
	MOV	#DPU,E

TURC:
	.IFNZ NDISP
	BIT	#DISPF,DFLAGS	;TURTLE, OR DISPLAY?
	BEQ	TURC.1
	JMP	(E)
	.ENDC
TURC.1:
.IFNZ TURFLG
	BIT	#TURTF,DFLAGS
	BNE	TURB.1
.ENDC
	.IFNZ NPLOT
	BIT #PLOTF,DFLAGS	;USING PLOTTER
	BEQ	TURC.2
	JMP (E)
	.ENDC
	
TURC.2:	ERROR+VTD  ;ONLY VALID FOR TURTLE,DISPLAY,OR PLOTTER
.ENDC
.IFNZ TURFLG
TURTS1:	MOV	TURDN,E
TURTST:	BIT	#TURTF,DFLAGS
	BEQ	1$
	RTS	PC
1$:	ERROR+VTU
.ENDC

.IFNZ TURFLG
TOOT:	JSR	PC,G1NARG
	JSR	PC,TURTS1
	MOV	#"( ,D	;TOOT CHAR IN BOTTOM, NULL IN TOP
	MOV B,A
TOOT.1:	DEC	A	;HOW MANY TIMES TO TOOT
	BLT	TURB.2
	JSR	PC,TURTYO	;SHIP OUT TOOT CHAR
	MOV	#15.,F	;THEN FOLLOW IT WITH 3 NULLS
	SWAB	D
	JSR	PC,TUROUT
	SWAB	D	;RETURN TOOT CHAR TO BOTTOM
	BR	TOOT.1

;TURTLE OUTPUT
;CALL WITH CHAR IN D, NUMBER OF TIMES IN F
TURO9:	JSR	PC,TURTYO
TUROUT:	TST BRAKE
	BNE TURDOR
	SOB	F,TURO9
TURDOR:	RTS	PC

.IFZ BOTUR
TURTYO:	SPUSH C
	MOV #TURT,C
	BIS TURDN,C
	JSR PC,TBTYO
	SPOP C
	RTS PC
.IFF
BOTTKS==177760
BOTTKB==BOTTKS+2
BOTTPS==BOTTKB+2
BOTTPB==BOTTPS+2
TURTYO:	JSR F,ACSAV
	MOV TURDN,C	;TURTLE DEVICE NUMBER
	MOV #21,A
	JSR PC,BOTTYO	;RESET TBOX
	CLR B
1$:	MOV #40,A
	CMP C,B	
	BNE 2$
	MOV D,A
	INC B		;TO OUTPUT ONLY 4 CHARS TOTAL IF TURTLE IS DEV 0, 1 OR 2
2$:	JSR PC,BOTTYO
	INC B
	CMP #4,B	;DONE?
	BGT 1$	
	JSR F,ACRES
	RTS PC

BOTTYO:	TSTB BOTTPS
	BPL BOTTYO
	MOVB A,BOTTPB
	RTS PC

TBTW:	JSR PC,TURTYO
2$:	TSTB BOTTKS
	BLT 1$
	BRAKET		;TEST FOR BREAK TYPED
	BR 2$
1$:	MOVB BOTTKB,D
	RTS PC
.IFT
TBTW:	MOV TURDN,E
	CLR -(P)
	MOVB TTYCPS(E),(P)
	$BYTI
	REST D	
	RTS PC
.ENDC


TOUCH:	PUSH	A
	JSR	PC,TURTS1
	MOV	#'#,D
	JSR PC,TURTYO
	TST PTBF
	BNE TOUCH2
	JSR	PC,TBTW
TOUCH3:
.IIF NZ PTBOX,	JSR PC,TBREST
	POP	A
	BIT	A,D
	BEQ	TOUCH1
	JMP	RTFALS
TOUCH1:	JMP	RTTRUE
TOUCH2:	JSR PC,ONETYI
	BR TOUCH3	

FTOUCH:	MOV #20,A
	BR	TOUCH
BTOUCH:	MOV	#4,A
	BR	TOUCH
LTOUCH:	MOV	#10,A
	BR	TOUCH
RTOUCH:	MOV	#40,A
	BR	TOUCH
LFTOUC:	MOV #30,A
	BR TOUCH
RFTOUC:	MOV #60,A
	BR TOUCH
LBTOUC:	MOV #14,A
	BR TOUCH
RBTOUC:	MOV #44,A
	BR TOUCH
.IFZ 1
;LIGHT--RETURN INTENSITY SEEN BY TURTLE EYE
LIGHT:
	.IFNZ NPLOT
	BIT	#PLOTF,DFLAGS
	BEQ	LIGHT1
	MOV	PLTCHR,B
	BIC	#177774,B	;ONLY 2 SIGNIFICANT BITS
	JMP	R1NARG
	.ENDC
LIGHT1:	JSR	PC,TURTS1	;CHECK TO SEE IF HE HAS A TURTLE
	MOV	#'#,D
	TST PTBF
	BNE LIGHT2
	JSR	PC,TBTW
LIGHT3:	MOV	D,B
	BIC	#177700,B	;ONLY 6 SIGNIFICANT BITS
	JMP	R1NARG
LIGHT2:	JSR PC,TURTYO
	JSR PC,CTYI
	JSR PC,SETTTY
	BR LIGHT3
.ENDC
.ENDC

.IF NZ BOTUR&TURFLG&LSI
STARTT:	JSR PC,G1NARG
	TST B
	BGE 2$
1$:	ERROR+WTA
2$:	CMP #3,B
	BLT 1$
	CLR GTLDF	;NO MORE GTL DISPLAY
	MOV B,TURDN
	MOV STURF,TURF
	BIC #DISPF!PLOTF,DFLAGS
	BIS #TURTF,DFLAGS
	SEZ
	RTS PC

KILLTU:	BIC #TURTF,DFLAGS
	SEZ
	RTS PC


.ENDC
;START TURTLE
.IFZ LSI

ASSTUR:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4

STARTT:	JMP USETUR
.if z 105
	CLR A		;SET FLAG FOR KILLING OTHER DEVICES
	JSR	PC,G1NARG	;WHICH TURTLE
	TST	B
	BGT	.+4
STRTT1:	ERROR+ITN	;INVALID TURTLE NUMBER
	DEC	B
;	CMP	B,#NTUR-1
	BGT STRTT1
STRTT2:	TST PTBF
	BEQ STRTT3
	MOV #TURT,A	;TYPE OF TURTLE
	ADD B,A		;WHICH TURTLE
	JSR PC,TBCHK	;CHECK TO SEE IF HE HAS IT
	BNE 1$
	ERROR+VTU
1$:	MOV B,TURDN	;TURTLE NUMBERR
	MOV STURF,TURF	;USE TURTLE 1'S FUDGE FACTORS
	TST A
	BLT STRTT4
	PUSH B
	JSR PC,KILLT1	;KILL ANOTHER TURTLE
.IIF NZ NPLOT,	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
	POP B
	BR STRTT4
STRTT3:	ASL	B	;TURN INTO WORD INDEX

	PUSH B
	TST A		;KILL OTHER DEVICS?
	BLT ASTRT1	;NO
.IIF NZ NDISP, JSR PC,KILLD1
.IIF NZ NPLOT, JSR PC,KILLPL
	JSR PC,KILLT1
ASTRT1:	SPOP B

	MOV	TURN(B),E
	JSR	PC,OPEN1	;TRY TO OPEN IT
	MOV	E,TURDN	;USER VARIABLE
	MOV	STURF(B),TURF	;TURTLE FUDGE FACTOR
STRTT4:	BIC	#<DISPF+PLOTF>,DFLAGS
	BIS	#TURTF,DFLAGS	;SET FLAG FOR CONTROL OF TURTLE
	BIS #TURTF,DIVOWN	;SET FLAG FOR OWNING TURTLE
	SEZ
	RTS PC
.endc

KILLTURTLE:
KILLT1:

	BIT	#TURTF,DIVOWN
	BEQ	KILLT9	;DOESN'T HAVE A TURTLE
	TST PTBF
	BNE KILLT3
	MOV	TURDN,E
	JSR	PC,CLOSE1
KILLT3:	BIC	#TURTF,DFLAGS
	BIC #TURTF,DIVOWN
KILLT9:	SEZ
	RTS	PC

NODEV:
	.IFNZ NDISP
	JSR	PC,KILLD1
	.ENDC
	JSR	PC,NOMUSIC
	.IFNZ	NPLOT
.IIF NZ NPLOT,	JSR PC,KILLPL	;KILL ANOTHER PLOTTER
	.ENDC
;	JSR	PC,SLAM	;RELEASE ALL DEVICES FOR THIS USER
	TST PTBF
	BNE KILLT3
	RTS	PC

	.IFNZ   NPLOT
;STARTPLOTTER

ASSTPL:	CLR C		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM C
	BR .+4
STRTPL:	GTJUMP USEPLO
	CLR C		;SET FLAG FOR KILLING OTHER DEVICES
	TST PTBF	;THORTON BOX PRIVATE?
	BEQ STRTP2	;NO, JUST IGNORE
	MOV #PLOTT,A	;PLOTTER
	JSR PC,TBCHK	;CHECK IT OUT
	BNE STRTP3	;HE'S GOT IT
	ERROR+DIU	;DONT HAVE ONE, SEND TO THE FACTORY
STRTP2:	MOV PLTDVN,E
	JSR	PC,OPEN1

STRTP3:	TST C		;SHOULD WE KILL OTHER DEVICES?
	BLT STRTP1	;NOPE

	JSR	PC,KILLT1   ;KILL TURTLE IF HE HAS ONE
	BIT	#DISPF,DFLAGS
	BEQ	STRTP1
.IIF NZ NDISP,	JSR	PC,KILLD2   ;KILL DISPLAY IF HE HAS ONE
STRTP1:	MOV     #PORBEG,F   ;SETT [0 0 0]
	BIS     #PLOTF,DFLAGS     ;SET PLOTTER FLAG

	BIC #<DISPF+TURTF>,DFLAGS
	BIS #PLOTF,DIVOWN	;SET FLAG FOR OWNING PLOTTER

ZVAR:	CLR (F)+	;CLEAR USER'S PLOTTER VARIABLES
	CMP #POREND,F
	BNE ZVAR
	BIS #PENUF,PLPENP	;SET PENUP FLAG IN PLOTTER 
	BIS     #PENUF,DFLAGS     ;START WITH PEN UP
	JSR	PC,ANGCRP	;INIT SINE AND COSINE
	CLR	B
	CLR	C
	JSR     PC,MTO.02     ;MOVE PLOTTER THERE
ZVAR1:	SEZ
	RTS	PC
;KILLPLOTTER
KILLPL:
	TST PTBF		;PRIVATE TBOX?
	BNE 1$			;CLEAR FLAGS
	MOV PLTDVN,E
	JSR	PC,CLOSE1
1$:
	BIC #PLOTF,DIVOWN
	BIC	#PLOTF,DFLAGS  ;ELIM. PLOTTER FLAG
	BR ZVAR1
	.ENDC
;HERE IS WHERE THE DISPLAY PRIMITIVES START.
.IFNZ NDISP

;STARTDISPLAY
;	INITIALIZE EVERYTHING
;	ALLOCATE DISPLAY BUFFERS

ASTRDI:	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A
	BR .+4
STARTDISPLAY:	CLR A	;SET FLAG FOR KILLING OTHER DEVICES


;USE THIS PRIMITIVE TO SPECIFY A LARGE DISPLAY
	JSR	PC,G1NARG	;B _ #.  SHOULD BE 0 OR 1


STRTD0:	SPUSH	B	;THE KILLERS CLOBBER B

	TST A		;KILL OTHER DEVICES?
	BLT ASTRD1	;NO

	JSR	PC,KILLT1	;GET RID OF TURTLE IF NECSSARY
.IIF NZ NPLOT,	JSR PC,KILLPL	;KILL ANOTHER PLOTTER

ASTRD1:	BIT #DISPF,DIVOWN	;DOES HE ALREADY OWN ONE?
	BEQ ASD1	;YES
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLING DISPLAY
ASD1:


	BIT	#DISPF,DFLAGS	;DOES HE HAVE A DISPLAY?
	BEQ	STRTD1	;USER DOESN'T HAVE A DISPLAY YET
	JSR	PC,KILLD2	;KILL HIS PREVIOUS DISPLAY FIRST
;FALLS THROUGH
;FALLS IN
STRTD1:
;IS THIS USER A DISPLAY USER?
;I.E. IS THERE AN ACTUAL DISPLAY CONSOLE
;	ASSOCIATED WITH HIM?
;NOW WE MUST ALLOCATE HIM A DISPLAY BUFFER
;FIRST DETERMINE WHAT SIZE BUFFER HE IS LOOKING FOR.
	SPOP	B
.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV DISPLAY?
	BEQ 1$			;NO, START UP TK DISPLAY
	JMP TVSTRT		;YES, START UP TVS
1$:
.ENDC
	SAVE <#-1,TYICP>
	MOVB B,1(P)
	BIS #100000,(P)		;SAY GET THE DISPLAY FOR THIS TTY
	SAVE #.DSCAP*400+0	;ZERO IS MY CREATE CAPABILITY
	.INVOK
	BNE 2$
	ERROR+NDV
2$:	REST <DISCAP,B,A>
	SUB #<DISAD/2>&77777,A
	MOV A,DRELOC
	CLR -(P)	;START AND LENGTH DON'T MATER
	CLR -(P)	;NEIRTHER DOES PAGE IN SOURCE
	SAVE DISCAP	;SOURCE
	MOVB #10+DISPG,1(P)	;PAGE IN ME
	SAVE <#.CRWRT+1>	;MY SPHERE CAP AND GIVE ME WRITE ACCESS
	$MAP
	MOV	#DORBEG,F	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,D	;LAST WORD
SDLOOP:	CLR	(F)+	;ZERO WORD
	CMP	F,D
	BLE	SDLOOP

	BIC #<PLOTF+TURTF+PENUF>,DFLAGS	;CLEAR VARIOUS FLAGS
	CLR DPENP		;START WITH THE PENDOWN
	BIS #DISPF,DIVOWN	;SET FLAG FOR OWNING DISPLAY

	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY
;SET UP TURTLE VARIABLES
	MOV	#TLIST,D
	MOV	D,TUB
	MAKEPJ	D
	MOV	D,PUSHJT
;SET FIRST 2 WORDS OF DLIST
;AND SET THE BUFFER VARIABLES
	MOV	#DLIST,D
	MOV	#<DRSTXY!DPOP>,(D)+
	MOV	PUSHJT,(D)
	MOV	D,STB	;STATIC AREA BOTTOM
	MOV	D,STT	;STATIC AREA TOP
	ASL	B	;B _ LENGTH OF DISPLAY IN BYTES.
			;USE THIS TO CALCULATE WHERE DYNAMIC AREA ENDS
	ADD	#DISAD,B
	CLR	-(B)	;SET UP DUMMY FREE AREA
	MOV	B,DYT	;DYNAMIC AREA TOP
	CLR	-(B)
	MOV	B,DYB	;DYNAMIC AREA BOTTOM
	MOV	B,DYR	;DYNAMIC AREA ROVING POINTER
;DRAW THE TURTLE
	PUSH	C
	JSR	PC,ANGCRP	;CALCULATE ANGLE CRAP
	JSR	PC,DR.TUR	;DRAW TURTLE
	SPOP	C
;NOW MAKE A PUSHJ TO THE DISPLAY LIST
;AND STUFF IT INTO THE HARDWARE FIRST LOCATION FOR THIS DISPLAY
	TST -(P)
	SAVE #<DLIST/2>&77777
	ADD DRELOC,(P)
	SAVE DISCAP
	$INVOK		;START UP THE DISPLAY
;AND LAST BUT NOT LEAST
	JMP NEWSN2	;SET UP FOR SNAPS TO START HERE

;KILLDISPLAY
;	USER WANTS TO GIVE UP HIS DISPLAY
KILLDISPLAY:
KILLD1:
.IIF NZ GTL,CLR GTLDF	;IT'S NOT A GTL DISPLAY THEN

	BIT #DISPF,DIVOWN
	BEQ	KILLDR	;USER DOESN'T HAVE DISPLAY
KILLD2:	CLR	A	;GET USER NUMBER
	CLR	SNLIST	;CLEAR  SNAPS
	BIC #DISPF,DIVOWN	;CLEAR DISPLAY FLAG
	BIC	#DISPF,DFLAGS
	JSR	PC,.GCOLL

.IFNZ TVS
.IIF NZ COLOR,JSR PC,FLSBUF	;GET RID OF COLOR BUFFERS, IF ANY
	BIT #TVF,DFLAGS	;ARE WE USING TV?
	BEQ KILLD3	;NO
KILLD9:	CLR B
	JSR PC,CRECHO	;CREATE AN ECHO AREA OF SIZE 0 IE NO ECHO AREA
	BR KILLDR	;DON'T FLUSH CAP
KILLD3:
.ENDC

	MOV DISCAP,A
	JSR PC,DELCAP
	CLR DISCAP
KILLDR:	SEZ
	RTS	PC
.IFTF
DCHKPL:
.IFNZ    NPLOT
	BIT     #PLOTF,DFLAGS      ;USING PLOTTER?
	BEQ	1$
	RTS	PC
.ENDC
1$:
.IFNZ GTL
	TST GTLDF	;USING THE 2500?
	BEQ DCHK
	RTS PC
.ENDC
DCHK:
.IFF
	ERROR+VTU
.IFT
	BIT	#DISPF,DFLAGS
	BNE	DCHK1
	PUSH	B
	CLR	B	;SPECIFY A SMALL DISPLAY BUFFER

	CLR A		;SET FLAG FOR NOT KILLING OTHER DEVICES
	COM A

	JSR	PC,STRTD0	;STARISPLAY
	SPOP	B
	RTS	PC
DCHK1:
	.IFNZ TVS
	BIT	#TVF,DFLAGS	;IS THIS A TV
	BNE	KILLDR		;YES JUST RETURN
	.ENDC
	CMP	NADXY,#20
	BLT	KILLDR	;DON'T BOTHER TRYING TO COMPRESS ADDXY'S
	JSR	PC,DSGC8	;TRY TO COLLAPSE
	BR	KILLDR

.ENDC
TBOX:	JSR PC,NODEV
	CLR E
	MOV #PTBTAB,B
	MOV #4,A
TBOX3:	DEC A
	BLT TBOX4
TBOX7:	SPUSH A
	SPUSH E
	PRTXT ^\PORT \
	JSR PC,PRDN
	PRTXT ^\: ?\
	JSR PC,QUEST
	SPOP E
	SPOP A
	CMP D,#'P	;IS IT A PLOTTER
	BEQ TPLOT
	CMP D,#'N	;IS IT NULL
	BEQ TNUL
	CMP D,#'C	;IS IT HIS CONSOLE
	BEQ TCON
	CMP D,#'T	;IS IT A TURTLE
	BEQ TTUR
	CMP D,#'M	;IS IT A MUSIC BOX
	BEQ TMUS
	CMP D,#7
	BEQ TBOX6
	SPUSH A
	PRTXT ^\ ? \
	SPOP A
	BR TBOX7
TMUS:	MOV #PMBOX,(B)+
	BR TBOX3
TNUL:	CLR (B)+
	BR TBOX3
TCON:	MOV #CONSO,(B)+
	BR TBOX3
TTUR:	MOV E,(B)
	BIS #TURT,(B)+
	INC E
	BR TBOX3
TPLOT:	MOV #PLOTT,(B)+
	BR TBOX3
TBOX4:	TST -(P)
	SPUSH #.TIRST
	SPUSH TYOCP
	BIS #.TTBIS*400,(P)
	$INVOK
	SUB #4,P
	SAVE TYOCP
	BIS #.TTRD*400,(P)
	$INVOK
	SPOP OTTYST
	MOV #CONSO,C
	MOV #-1,PTBF
	JSR PC,TBINIT
	BEQ TBOX5
	SEZ
	RTS PC
TBOX5:	JSR PC,NOTBOX
	ERROR+TDE
TBOX6:	JSR PC,NOTBOX
	ERROR+BRK

NOTBOX:	JSR PC,NODEV
	CLR PTBF
	SEZ
	RTS PC



.IFNZ NDISP

CTRDIS:	BIT #DISPF,DIVOWN	;DOES HE OWN A DISPLAY?
	BEQ CTRERR		;NO
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+PLOTF>,DFLAGS
	BIS #DISPF,DFLAGS	;SET FLAG FOR CONTROLLING DISPLAY
	BIS DPENP,DFLAGS	;SET DISPLAY PEN POSITION
	SEZ
	RTS PC
.ENDC

CTRTUR:	BIT #TURTF,DIVOWN	;DOES HE OWN A TURTLE?
	BNE .+4			;NO,ERROR
CTRERR:	ERROR+VTD
	BIC #<PLOTF+DISPF>,DFLAGS
	BIS #TURTF,DFLAGS	;SET FLAG FOR CONTROLLING TURTLE
	JSR PC,G1NARG		;WHICH TURTLE DOES HE WANT TO CONTROL?
	TST B			;TEST TURTLE NO.
	BGE .+4			;IT'S OKAY SO FAR
CTRER2:	ERROR+ITN		;INVALID TURTLE NUMBER
	DEC B			;TO START TO TURN INTO AN INDEX
;	CMP B,#NTUR-1
	BGT CTRER2		;IT WAS TO LARGE
	ASL B			;TURN IT INTO A WORD INDEX
	BNE CTRERR		;NOPE
	MOV STURF(B),TURF
CTRRET:	SEZ
	RTS PC

.IFNZ NPLOT

CTRPLT:	BIT #PLOTF,DIVOWN	;DOES HE OWN THE PLOTTER?
	BEQ CTRERR		;NOPE
	BIT #PLOTF,DFLAGS	;IS HE CONTROLLING IT NOW?
	BNE CTRRET		;YES,DONE
	BIC #<PENUF+TURTF+DISPF>,DFLAGS
	BIS PLPENP,DFLAGS	;SET PLOTTER PEN POSITION
	BIS #PLOTF,DFLAGS	;SET FLAG FOR CONTROLLING PLOTTER
	SEZ
	RTS PC


.ENDC

.IFNZ <NDISP!NPLOT>


.IFZ FPPF

DBK:	NEG	B
;DISPLAY FORWARD AND BACK
DFD:	MOV	B,C
	CLR	B
	TST	C
	BGE	DFD1	;IF ARG IS NEG,
	COM	B	;SET B = -1
	CLR	A	;CLEAR FLAG
DFD1:	MOV	#CURX,D
	JSR	PC,MULSIN	;PUTS DX IN E,,F
	SDPADD	(D)+,(D)+,E,F	;NEW X
	PUSH	F	;FRACTION PART
	SPUSH	E	;INTEGER PART
	JSR	PC,MULCOS	;DY IS IN E,,F
	SDPADD	(D),(D)+,E,F	;NEW Y
	SPUSH	F
	SPUSH	E
	BR	SETMOV

.IFF

DBK:	NEGF FA
DFD:	
.IFZ DDF
	LDCFD COSA,FB
	MULF FA,FB
	LDCFD CURY,FC
.IFF
	JSR PC,GTCURX		;IS HE CONTROLLING PLOTTER OR DISPLAY?
	LDCFD COSA(F),FB	;COSINE OF ANGLE -> FB
	MULF FA,FB		;DY -> FB
	LDCFD CURY(F),FC	;CURY -> FC
.IFTF
	ADDF FC,FB	;GET NEW Y IN FB
	STCDF FB,-(P)	;PUT NEW Y ON STACK
.IFT
	LDCFD SINA,FB
	MULF FA,FB	;DX IN FB
	LDCFD CURX,FC	;CURRENT X IN FC
.IFF
	LDCFD SINA(F),FB	;SINE OF ANGLE -> FB
	MULF FA,FB		;DX -> FB
	LDCFD (F),FC		;CURX -> FC
.ENDC
	ADDF FC,FB	;GET NEW X IN FB
	STCDF FB,-(P)	;PUT NEW X ON STACK
	BR SETMOV

.ENDC
.IFNZ DDF
	;PUTS THE ADDRESS OF THE CURX OF DISPLAY IN F
	;IF HE OWN A DISPLAY, ELSE PUTS CURX OF PLOTTER IN F
.IFNZ NDISP
GTCURX:	BIT #DISPF,DFLAGS	;DOES HE OWN A DISPLAY?
	BNE DISP		;YES
	TST GTLDF
	BNE DISP
	MOV #PCURX,F		;PUT ADDRESS OF PCURX IN F
	BR DISP1
DISP:	MOV #DCURX,F		;PUT ADDRESS OF DCURX IN F
DISP1:	RTS PC
.IFF
GTCURX:	MOV #PCURX,F
	RTS PC
.ENDC
.ENDC


.IFZ FPPF


SETX:	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;;NEW X IN B
	CLR	-(SP)	;FRACTION PART OF NEW X
	PUSH	B	;INTEGER PART
	SPUSH	CURY	;NEW Y UNCHANGED
	SPUSH	CURY+2
	BR	SETMOV

SETY:	JSR	PC,DCHKPL
	JSR	PC,G1NARG
	PUSH	CURX	;NEW X UNCHANGED
	SPUSH	CURX+2
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	B	;INTEGER PART OF NEW Y
	BR	SETMOV

SETXY:	GTJUMP GTSXY
	JSR	PC,DCHKPL
	JSR	PC,G2NARG
	CLR	-(SP)	;FRATION PART OF NEW X
	PUSH	B	;INTEGER PART
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	A	;INTEGER PART
SETMOV:	JSR	PC,MOVETO
	RTS PC

SETTURTLE:
	JSR	PC,DCHKPL
	MOV	@S,C
	JSR	PC,LD3NUM	;LOAD D,E,F
SETT1:	PUSH	F	;SAVE NEW ANGLE
	JSR	PC,SPOPT	;POP OFF ARG
	CLR	-(SP)	;FRACTION PART OF NEW X
	SPUSH	D	;INTEGER
	CLR	-(SP)	;FRACTION PART OF NEW Y
	SPUSH	E
	CLR	A	;A FLAG
	JSR	PC,MOVETO	;MOVE TO NEWX,NEWY
	SPOP	B	;NEW HEADING
	JMP	DRT.HD	;SET HEADING

.IFF
SETX:	JSR PC,DCHKPL
.IFZ DDF
	SPUSH CURY+2
	SPUSH CURY
.IFF
	JSR PC,GTCURX
	SPUSH CURY+2(F)	;PUT CURY ON STACK
	SPUSH CURY(F)
.IFTF
	JSR PC,GARG	;PUT NEWX ON STACK
	BR SETMOV
SETY:	JSR PC,DCHKPL
	JSR PC,GARG	;PUT NEW Y ON STACK
.IFT
	SPUSH CURX+2
	SPUSH CURX
.IFF
	JSR PC,GTCURX
	SPUSH 2(F)	;PUT CURX ON STACK
	SPUSH (F)
.ENDC
	BR SETMOV
SETXY:	GTJUMP GTSXY
	JSR PC,DCHKPL
	JSR PC,GARG	;PUT Y ON
	JSR PC,GARG	;PUT X ON
SETMOV:	JSR PC,MOVETO
	RTS PC

SETTURTLE:
	MOV @S,C
	JSR PC,.GFLST	;FA <- NEWX
	LDD A,B		;FB <- NEWX
	JSR PC,.GFLST	;FA <- NEWY
	BIT #7777,C	;ANY MORE LIST?
	BEQ SETT1	;NO?!
	JSR PC,.LOADC	;GET POINTER TO ANGLE
	BIT #7777,A	;ANY MORE LIST? (SHOULDN'T BE)
	BNE SETT1	;THERE IS??
	MOV #SNUM,A	;TAKE POINTER AND TRY TO
	JSR PC,CONVER	;CONVERT IT TO A SNUM
	BNE .+4
SETT1:	ERROR+WTA
	SPUSH B		;STORE ANGLE
	STCDF FA,-(P)	;STORE NEWY
	STCDF FB,-(P)	;STORE NEWX
SETT2:	JSR PC,DCHKPL
	CLR A		;SET A FLAG
	JSR PC,MOVETO	;MOVE IT
	SPOP B		;POP ANGLE
	JMP DRT.HD

.GFLST:	BIT #7777,C	;GETS FLOATING NUMBER OUT OF LIST
	BEQ SETT1	;EMPTY LIST
	JSR PC,.LOADC	;GET NODE IN A AND B
	MOV A,C		;GET POINTER TO REST OF LIST IN C
	JSR PC,G1NUMS	;GET FNUM POINTED TO BY B INTO FA
	BEQ SETT1
	RTS PC

GARG:	SPOP FNPDL+4	;SO THAT THE JMP WILL WORK BELOW
	SPUSH A		;STORES REGISTERS AND GETS NUMBER IN FA
	SPUSH B
	SPUSH F
	JSR PC,G1NUM	;FA <- FNUM POINTER TO BY B
	BEQ SETT1
	SPOP F		;RESTORE REGISTERS
	SPOP B
	SPOP A
	STCDF FA,-(P)	;PUT FA ON STACK
	JMP @FNPDL+4	;DOES A RTS PC

.ENDC

;CALL WITH NEWX AND NEWY ON THE STACK




MOVETO:	JSR PC,PPOPT	;INSURE ENOPUGH STACK IS IN CORE
	.IFNZ	NPLOT
.IFNZ NDISP
	BIT	#PLOTF,DFLAGS ;USING PLOTTER?
	BEQ	MTO.09   ;IF NOT,SKIP ALL THIS
.ENDC


.IFZ FPPF

	MOV	2(P),C	;INT OF Y
	MOV	4(P),A	;FRACTION Y
	MOV	6(P),B	;INT OF X
	MOV	10(P),D	;FRACTION X
	ASL	A
	ADC	C	;ROUND Y
	ASL	D
	ADC	B	;ROUND X
	CMP	B,#128.   ;CHECK IF EXCEEDS PLOTTER BOUNDS
	BGE	MTO.03
	CMP	B,#-128.
	BLT	MTO.03
	CMP     C,#128.    ;NOW CHECK Y BOUNDS
	BGE	MTO.03
	CMP	C,#-128.
	BLT	MTO.03
	JSR	PC,MTO.02
	JMP	MTO.R
;SEND OUT PLOTTER CHARACTERS

.IFF

	LDCFD 2(P),FA	;LOAD NEWX
	LDCFD 6(P),FB	;LOAD NEWY
	STF FA,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	STF FB,FD
	JSR PC,CHKBND	;CHECK BOUNDS
	SETI
	STCFI FA,B	;PUT NEWX INTO B
	STCFI FB,C	;PUT NEWY INTO C
	SETL
	ASR B		;ROUND NEWX
	ADC B
	ASR C		;ROUND NEWY
	ADC C
	JSR PC,MTO.02	;MOVE IT
	JMP MTO.R	;STORE AWAY NEWX AND NEWY
.IFZ DDF

CHKPL:	CMPF #42000,FC
	CFCC
	BLT MTO.03
	CMPF #142000,FC
	CFCC
	BGT MTO.03
	RTS PC
.ENDC

.ENDC

MTO.02:	MOV	#35,D   ;PRIMING CHARACTER
	MOV	PLTDVN,E
	SPUSH C
	MOV #PLOTT,C
	JSR	PC,TBTYO   ;SEND TO TTY
	JSR	PC,MTO.04	;SEND NEW X TO PLOTTER
	JSR	PC,PLT67
	JSR	PC,TBTYO
	SPOP B
	JSR	PC,MTO.04   ;SEND NEW Y TO PLOTTER
	JSR	PC,PLT67
	JSR PC,TBTYO
.IIF NZ PTBOX,	JSR PC,TBREST
	RTS	PC
MTO.03:	ERROR+OOB
MTO.04:	MOV	B,D   ;SEND LOW ORDER 6 BITS
	BIC	#177700,D
	JSR	PC,PLT67
	JSR	PC,TBTYO
	MOV	B,D	;SEND REMAINING 2 BITS
	ASL	D
	ASL	D
	SWAB	D
	BIC	#177774,D
	BIT	#PENUF,DFLAGS   ;SEND PENUP INFO
	BEQ	MTO.05
	BIS	#40,D   ;SET PENUP BIT
MTO.05:	RTS	PC

PLT67:	BIT	#40,D	;SET BIT 6 TO COMP OF BIT 7
	BNE	PLT671
	BIS	#100,D
PLT671:	RTS	PC


.ENDC
.IFNZ NDISP

.IFZ FPPF

MTO.09:	MOV SP,F
	TST	(F)+	;POINT TO ARGS
	MOV	(F)+,B	;INTEGER PART OF NEW Y
	MOV	(F)+,C	;FRACTION PART OF NEW Y
	JSR	PC,CHKBND	;CHECK TO SEE IF IN BOUNDS
	MOV	B,E	;ROUNDED NEWY
	MOV	(F)+,B	;INTEGER PART OF NEW X
	MOV	(F),C	;FRACTION PART OF NEW X
	JSR	PC,CHKBND
	MOV	B,D	;ROUNDED NEWX
;GET D_DX AND E_DY
	MOV	#CURX,F
	ASL	(F)+	;FRACTION OF CURX
	ADC	(F)	;ROUND CURX
	SUB	(F)+,D	;DX
	ASL	(F)+
	ADC	(F)
	SUB	(F),E	;DY

.IFF

MTO.09:
	.IFNZ TVS
	BIT #TVF,DFLAGS
	BEQ MTO.10
	SETF
	LDF DCURX,FA	;FROM X
	LDF DCURY,FB	;FROM Y
	REST F		;THE RETURN ADDRESS	
	LDF (P)+,FC	;TO X
	LDF (P)+,FD	;TO Y
	SAVE F		;PUT THE RETURN ADDRESS BACK
	JMP VECTOR	;DRAW THE VECTOR
MTO.10:
	.ENDC
	
	MOV P,F		;SO IT CAN DO POPS W/O DISTURBING THE STACK
	TST (F)+	;TO GET AROUND THE PC
	LDCFD (F)+,FA	;GET NEW X
	STF FA,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
	LDCFD (F)+,FB	;GET NEW Y
	STF FB,FD	;TO CHECK IF IN BOUNDS
	JSR PC,CHKBND
.IIF Z DDF,	MOV #RCURX,F
.IFNZ DDF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	ADD #RCURX,F	;TO TELL WHERE TO PUT ROUNDED FA AND FB
.ENDC 
	JSR PC,ROUND	;ROUND FA AND FB
	SETF
	SUBF (F)+,FA	;FA <- NEWX - CURX
	SUBF (F)+,FB	;FB <- NEWY - CURY
	SETD
	JSR PC,MOD1K	;PERFORM A MODULAR 32K. (ANY BETTER IDEAS?)
	SETI
	STCFI FA,D	;PUT DX IN D
	STCFI FB,E	;PUT DY IN E
	SETL

.ENDC

	BNE	MTO.1	;CHECK FOR DX=DY=0
	TST	D
	BEQ	MTO.R	;JUST RETURN

MTO.1:	BIT	#PENUF,DFLAGS	;IS PEN UP?
	BNE	MTO.PU	;YES
;FALLS THROUGH
;FALLS IN
;THE PEN IS DOWN
	SPUSH	DIREC
	JSR	PC,XYDIR	;CALCULATE DIREC
	JSR	PC,DR.LIN	;AND DRAW LINE!!
	SPOP	DIREC

;RETURN.  SET CURX & CURY TO NEWX & NEWY


.ENDC

.IFZ FPPF

MTO.R:	POP	A	;RETURN ADDRESS
	MOV	#CURY+2,B
	SPOP	(B)	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP	-(B)
	SPOP	-(B)
	SPOP	-(B)
	JMP	(A)

.IFF

MTO.R:	POP A
.IFZ DDF
	MOV #CURX,B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE SET OF VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
.ENDC
	SPOP (B)+	;PUT NEWX AND NEWY IN CURX AND CURY
	SPOP (B)+
	SPOP (B)+
	SPOP (B)+
	JSR PC,ROUNDER	;ROUND AND PUT IN RCURX AND RCURY
	SEZ
	JMP (A)		;DOES AN RTS!!?

ROUNDER:	;PUTS ROUNDED CURX AND CURY INTO RCURX AND RCURY
.IFZ DDF
	MOV #CURX,B
	MOV #RCURX,F
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
	MOV F,B		;B <- POINTER TO VARIABLES
	ADD #RCURX,F	;MAKE F POINT TO RCURX
.ENDC
	LDCFD (B)+,FA	;FA <-CURX
	LDCFD (B)+,FB	;FB <- CURY
	JSR PC,ROUND	;ROUND FA AND FB
	STCDF FA,(F)+	;RCURX <- ROUNDED CURX
	STCDF FB,(F)+	;RCURY <- ROUNDED CURY
	RTS PC

	;ROUNDS FA AND FB
ROUND:	ADDF #40000,FA	;FA <- FA + 1/2
	STCFI FA,-(P)	;INTEGERIZE FA
	BCS EROOB	;TOO BIG
	LDCIF (P)+,FA	;FA <- INTEGER (FA)
	CFCC		;IS FA > 0?
	BGE 1$		;YES
	SUBF #40200,FA	;FA <- FA - 1 (TO ROUND AWAY FROM 0)
1$:	ADDF #40000,FB	;REPEAT SAME PROCESS FOR FB
	STCFI FB,-(P)
	BCS EROOB
	LDCIF (P)+,FB
	CFCC
	BGE 2$
	SUBF #40200,FB
2$:	RTS PC
EROOB:	ERROR+OOB

MOD1K:	LDD FB,FC
	MODF #34600,FC	;DIVIDES BY 2^16 (FC <- ONLY FRACTIONAL PART)
	CFCC
	BEQ MODK1	;IT WAS ZERO OR UNDERFLOWED
	MULF #43600,FC	;FRACTION * 2^16
	LDD FC,FB	;PUT IT BACK NOW
MODK1:	LDD FA,FC	;NOW DO IT TO FA
	MODF #34600,FC
	CFCC
	BEQ MODK2
	MULF #43600,FC
	LDD FC,FA
MODK2:	RTS PC

.ENDC

.ENDC
.IFNZ NDISP


;THE PEN IS UP
;PUT ADDX AND ADDY COMMANDS INTO DISPLAY LIST
MTO.PU:	SPUSH	#MTO.R	;SO RTS PC'S BELOW WILL WORK (GROAN !!!)
	MOV	STT,A	;POINTER TO TOP OF STATIC DISPLAY ALLOCATION
	CMP	-(A),#ADDY
	BLO	MTO.AD	;PREVIOUS STUFF NOT ADDS ANYWAY
	CMP	-(A),#ADDY	;IS THE NEXT TO LAST DCODE AN ADD,TOO ?
	BLO	MTO.AD	;NO
	CMP	A,SNABOT	;DON'T COMPRESS ACROSS SNAP BOTTOM
	BLO	MTO.AD	;NO
;THERE ARE TWO ADD COMMANDS IN A ROW
	JSR	PC,MTO.AS	;TAKE CARE OF FIRST ADD
	JSR	PC,MTO.AS	;AND SECOND ADD
	BR	MTO.R1


;MTO.AS ADDS THE DELTA X OF AN ADD COMMAND TO THE NEW DX OR DY
MTO.AS:	CMP	(A),#ADDX	;ADDX IS THE BIGGER OF THE ADDS
	BHIS	1$
	ADD	(A)+,E	;DY
	RTS	PC
1$:	ADD	(A)+,D
	RTS	PC



;HAVE TO EXPAND STATIC AREA AND PUT IN ADD COMMANDS
MTO.AD:	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND

MTO.RM:	MOV	A,STT	;A WAS SET IN STXPND
	MOV	PUSHJT,(A)	;DISPLAY JUMP TO TURTLE
MTO.R1:	BIC	#176000,D	;IN CASE EITHER DX OR DY WERE NEGATIVE
	BIC	#176000,E	;CLEAR THE TOP 6 BITS
	BIS	#ADDY,E	;TURN E INTO ADDY COMMAND
	MOV	E,-(A)	;STORE IN DLIST
	BIS	#ADDX,D	;TURN D INTO ADDX COMMAND
	MOV	D,-(A)	;STORE IN DLIST
	CLR DFBCNT
	RTS	PC

.ENDC
.IFNZ <NDISP!NPLOT>

.IFZ FPPF

DLT:	NEG	B

;DISPLAY RIGHT AND LEFT

DRT:	ADD	CURA,B

.IFF

DLT:	NEGF FA
DRT:	SETI
	STCFI FA,B
	SETL
	BCC 1$		;NUMBER TOO LARGE??, NOPE
	ERROR+TGDZ	;TURTLE GETTING DIZZY
1$:
.IFZ DDF
	ADD CURA,B
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE VARIABLES
	ADD CURA(F),B	;B <- NEWA + CURA
.ENDC

.ENDC
DRT.HD:	JSR	PC,MOD360	;SET B=B MOD 360

.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV?
	BEQ 1$			;NO
	JMP TVHEAD		;TV VERSION OF HEADING UPDATE
1$:
.ENDC

.IIF Z DDF,	MOV	B,CURA
.IFNZ DDF
	JSR PC,GTCURX
	MOV B,CURA(F)	;MOVE NEWLY COMPUTED ANGLE TO CURA
.ENDC

;DRAW THE TURTLE IF IT'S BEING SHOWN
TURDO:	JSR	PC,ANGCRP	;DO ALL THE ANGLE CRAP.
	.IFNZ	   NPLOT
	BIT     #PLOTF,DFLAGS   ;USING PLOTTER?
	BNE	DRTRET	;YES, SO RETURN
	.ENDC
.IFZ NDISP
	ERROR+VTU
.IFF
	BIT	#HIDETF,DFLAGS	;IS THE TURTLE BEING HIDDEN ?
	BNE	DRTRET	;YES. SO RETURN
;THE TURTLE IS BEING SHOWN. SO DRAW THE TURTLE
	JSR	PC,DR.TUR
.ENDC

DRTRET:	SEZ
	RTS	PC

;SETHEAD
;	LIKE RIGHT, EXCEPT SET CURA TO ARGUMENT
SETHEAD:	GTJUMP GTSETH
	JSR	PC,DCHKPL
	JSR	PC,G1NARG	;NUMERIC ARGUMENT IN B
	BR	DRT.HD	;JUMP INTO RIGHT

;WRAPAROUND
.IFNZ NDISP

WRAP:	
.IFNZ TVS
	BIT #TVF, DFLAGS
	BEQ WRNTVE
	JSR PC, ETVTUR
WRNTVE:
.ENDC
	BIS #WRAPF, DFLAGS
	BIC #CLIPF, DFLAGS
.IFNZ TVS
	BIT #TVF, DFLAGS
	BEQ WRNTVD
	JMP DTVTUR
WRNTVD:
.ENDC
	SEZ
	RTS PC

;CLIPMODE
.IFNZ TVS

CLIP:	JSR PC,TVTEST		;TVS ONLY
	BIT #TVF, DFLAGS
	BEQ CLNTVE
	JSR PC, ETVTUR
CLNTVE:
	BIC #WRAPF,DFLAGS
	BIS #CLIPF,DFLAGS
	BIT #TVF, DFLAGS
	BEQ CLNTVD
	JMP DTVTUR
CLNTVD:
	SEZ 
	RTS PC

NOCLIP:	JSR PC, TVTEST
.ENDC

NOWRAP:					
.IFNZ TVS
	BIT #TVF, DFLAGS
	BEQ BHNTVE
	JSR PC, ETVTUR			;Erase turtle over this.
BHNTVE:
.ENDC
	BIC #<WRAPF!CLIPF>, DFLAGS
	SETF				;In WRAP or CLIP modes, coordinates may be 
	SETI				;outside screen. Restore to within bounds.
	LDF DCURX, FB			;Subtract left edge to move origin to left.
	SUBF TRLEFT, FB			;Smash down coordinate modulo screen size.
	LDCIF #1., FA			;Reciprocate so MODF does division by TRSIZX.
	DIVF TRSIZX, FA
	MODF FA, FB			;FB=1 is odd, fractional part of product in FB.
	MULF TRSIZX, FB
	CFCC
	BGE BHXPOS
	ADDF TRSIZX, FB
BHXPOS:	ADDF TRLEFT, FB			;Move origin back.
	STF FB, DCURX			;Save as new XCOR.
	LDF DCURY, FB			;Similarly for YCOR.
	SUBF TRBOT, FB
	LDCIF #1., FA
	DIVF TRSIZY, FA
	MODF FA, FB
	MULF TRSIZY, FB
	CFCC
	BGE BHYPOS
	ADDF TRSIZY, FB
BHYPOS:	ADDF TRBOT, FB
	STF FB, DCURY 
.IFNZ TVS
	BIT #TVF, DFLAGS
	BEQ BHNTVD
	JMP DTVTUR
BHNTVD:	
.ENDC
	SEZ
	RTS PC


.IFZ FPPF



;HERE
;	OUTPUT A SENTENCE OF CURX,CURY,CURA
HERE:	GTJUMP GTHERE
	JSR	PC,DCHKPL
	MOV	#CURX,D
	JSR	PC,PSHINT	;PUSH INTEGER OF CURX ONTO S-PDL
	JSR	PC,PSHINT	;PUSH INTEGER OF CURY
	MOV	(D),B	;CURRENT ANGLE
HERE.1:	JSR	PC,PSHNUM	;PUSH CURRENT ANGLE
HERE.2:	MOV	#3,D	;PUSH 3 ONTO P-PDL
	JMP	SENT.


;XCOR
;	OUTPUT THE X COORDINATE
XCOR:	GTJUMP GTXCOR
	JSR	PC,DCHKPL
	MOV	#CURX,D
	BR	YCOR1
;YCOR
;	OUTPUT THE Y COORDINATE
YCOR:	GTJUMP GTYCOR
	JSR	PC,DCHKPL
	MOV	#CURY,D
YCOR1:	JMP	R1INT	;RETURN INTEGER


;HEADING
;	RETURN THE CURRENT ANGLE
HEADIN:	GTJUMP GTHEAD
	JSR	PC,DCHKPL
	MOV	CURA,B
	JMP	R1NARG
	;HOME -- SAME AS SETT [0 0 0]
HOME:	GTJUMP GTHME
	JSR PC,DCHKPL
	JSR PC,SPUSHT
	CLR D
	CLR E
	CLR F
	JMP SETT1

.IFF

HERE:	GTJUMP GTHERE
	JSR PC,DCHKPL	;DOES HE OWN DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURX,D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE VARIABLES
.ENDC
	JSR PC,WHOPIE	;PUT (F) INTO A NODE, POINTER IN B
	PUSHS B		;STORE POINTER TO FNUMS ON STACK
	JSR PC,WHOPIE	;DO IT AGAIN
	PUSHS B
.IIF Z DDF,	MOV (D),B	;STORE ANGLE (SNUM) ON STACK
.IIF NZ DDF,	MOV (F),B	;PUT ANGLE (SNUM) IN B
	JSR PC,PSHNUM	;PUT SNUM IN B ON S-PDL
	MOV #3,D	;PUSH A FLAG ON	
	JMP SENT.	;CHANGE THE THREE THINGS INTO A SENTENCE

XCOR:	GTJUMP GTXCOR
	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IIF Z DDF,	MOV #CURX,D	;PUT POINTER TO CURRENT X IN D
.IIF NZ DDF,	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	BR YCOR1	;GET NUMBER AND RETURN

YCOR:	GTJUMP GTYCOR
	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV #CURY,D	;PUT POINTER TO CURRENT Y IN D
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURY,F	;MAKE F POINT TO CURY
.ENDC
YCOR1:	JSR PC,WHOPIE	;PUT NUMBER INTO A NODE,POINTER RETURNED IN B
	JMP ORTB	;PUT POINTER IN B ON S-PDL

HEADIN:	GTJUMP GTHEAD
	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
.IFZ DDF
	MOV CURA,B	;PUT POINTER TO ANGLE IN B
.IFF
	JSR PC,GTCURX	;GET APPROPRIATE POINTER TO CURX
	ADD #CURA,F	;MAKE F POINT TO CURA
	MOV (F),B	;MOVE CURA TO B
.ENDC
	JMP R1NARG	;RETURN B

HOME:	GTJUMP GTHME
	CLR -(P)	;SETTURTLE [0 0 0]
	CLR -(P)
	CLR -(P)
	CLR -(P)
	CLR -(P)
	JMP SETT2	;SET THE TURTLE!

.ENDC

;PENP
;RETURNS TRUE IF THE PEN IS DOWN
;RETURNS FALSE IF IT IS UP
PENP:	JSR PC,DCHKPL	;DOES HE OWN A DISPLAY OR PLOTTER?
	BIT #PENUF,DFLAGS	;IS THE PEN UP?
	BNE PENP1	;YES
	JMP RTTRUE	;NO, RETURN TRUE
PENP1:	JMP RTFALS	;YES, RETURN FALSE
.IFNZ NDISP


;	HIDETURTLE
HIDETURTLE:
	BIT #HIDETF, DFLAGS
	BNE STRETURN
	GTJUMP GTHIDE
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY??

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV?
	BEQ 1$		;NO
	JMP TVHIDE	;YES, DO THINGS FOR TV
1$:
.ENDC

	BIS	#HIDETF,DFLAGS	;SET THE HIDETURTLE FLAG
	MOV	#DPOP!DSTOP,@TUB
	BR STRETURN


;	SHOWTURTLE
SHOWTURTLE:
	BIT #HIDETF, DFLAGS
	BEQ STRETURN
	GTJUMP GTSHOW
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ NTVST	;NO
	JMP TVSHOW	;YES, SHOW THE TV TURTLE
.ENDC
;HAVE TO DRAW THE TURTLE
NTVST:	BIC	#HIDETF,DFLAGS	;CLEAR THE FLAG FIRST
	JSR	PC,DR.TUR
STRETURN:
	SEZ
	RTS PC

.ENDC


;	DISPLAY PENUP
DPU:	BIS #PENUF,DFLAGS	;SET PEN UP FLAG
.IFNZ TVS
	BIC #<XORF!ERASEF>, DFLAGS
	MOV #-1., WINDATA
.ENDC
.IFNZ DDF
	BIT #DISPF,DFLAGS	;IS HE CONTROLLING A DISPLAY?
	BEQ DPU1	;NO
	BIS #PENUF,DPENP	;SET PEN UP FLAG IN DISPLAY VARIABLES
	BR DPR			;RETURN
DPU1:	BIS #PENUF,PLPENP	;SET PEN UP FLAG IN PLOTTER VARIABLES
.ENDC
DPU3:	BIT #DISPF,DFLAGS	;DISPLAY?
	BNE DPU2		;YES, FORGET IT
.IFZ DDF
	SPUSH CURY+2
	SPUSH CURY
	SPUSH CURX+2
	SPUSH CURX
.IFF
	SPUSH PCURY+2
	SPUSH PCURY
	SPUSH PCURX+2
	SPUSH PCURX
.ENDC
	JSR PC,MOVETO	;HAVE TO SEND MOVE COMMAND TO PLOTTER TO TOGGLE PEN
DPU2:	
	SEZ
	RTS PC


;Display PENDOWN

DPD:	BIC #<PENUF!XORF!ERASEF>, DFLAGS	;Clear display pen up flag.
.IFNZ TVS
	BIT #TVF,DFLAGS		;KILL
	BEQ DPDHEN		;HENRY
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ DPDBW
DPDCOL:	JSR PC, SELPEN		;(SELECT-COLOR :PENNUMBER)
	SEZ
	RTS PC
.ENDC
DPDBW:	JSR PC, IORMODE		;Draw lines in IOR mode.
.ENDC
DPDHEN:
.IFNZ DDF
	BIT #DISPF,DFLAGS
	BEQ DPD1
	BIC #PENUF,DPENP
	BR DPR
DPD1:	BIC #PENUF,PLPENP
DPR:
.ENDC
	BR DPU2
.ENDC


;Display ERASERDOWN
.IFNZ TVS
ERASED:	JSR PC, TVTEST		;Check to see if on a TV.
	BIS #<ERASEF!PENUF>, DFLAGS
	BIC #XORF, DFLAGS	;Assign flags; Eraser on, pen, xor off.
.IFNZ COLOR
ERDCOL:	BIT #COLORF, DFLAGS
	BEQ ERDBW
	JSR PC, SELERA		;If in color, select eraer color.
	BR ERARET
.ENDC				;In B&W, eraser mode check is made by line drawer.
ERDBW:	JSR PC, SETMODE		;Eraser needs SET drawmode.
ERARET:	SEZ
	RTS PC

XORUP:				
ERASEU:	
	JSR PC, TVTEST
	BIS #PENUF, DFLAGS
	BIC #<ERASEF!XORF>, DFLAGS
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ ERUBW
	JSR PC, SELPEN
	BR ERARET
.ENDC
ERUBW:	JSR PC,IORMODE
	BR ERARET


;XORDOWN ROUTINE
XORDOWN: 
	JSR PC,TVTEST			;IS THIS A TV?
	BIS #<PENUF!XORF>, DFLAGS	;Pen is now up, xor is down.
	BIC #ERASEF, DFLAGS		;Eraser is up.
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BNE XDRET
.ENDC
	JSR PC, XORMODE		;SET DRAW MODE TO XOR
XDRET:	SEZ
	RTS PC

.ENDC


.IFNZ NDISP
;CLEARSCREEN--WIPE SCREEN AND RESTORE TURTLE TO [0 0 0]
CLEARSCREEN:	GTJUMP GTCLEA
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY
.IFNZ TVS
	BIT #TVF,DFLAGS		;IS THIS A TV?
	BEQ 1$			;NO
	JMP TVCS		;YES, DO THINGS FOR TV
1$:
.ENDC
	JSR	PC,WC.1	;WIPE IT CLEAN
	SPUSH DFLAGS
	MOV	#DORBEG,C	;ZERO VARIOUS USER DISPLAY VARS
	MOV	#DOREND,B	;INCLUDING CURX, CURY AND OTHERS
CSLOOP:	CLR	(C)+
	CMP	C,B
	BLT	CSLOOP

	SPOP DFLAGS
	CLR DFBCNT
	JSR	PC,TURDO	;DO ANGLE CRAP AND DRAW TURTLE IF SHOWN
	MOV	STB,STT
	MOV	PUSHJT,@STB
	JSR	PC,NEWSN2	;RECALCULATE STARTING POINT FOR SNAPS
	SEZ
	RTS PC

.IFZ FPPF
;SNAP

SNAP:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

;FIRST SET UP THE 3 NODE SNAP STRUCTURE ITSELF
	JSR	PC,PSHNUM	;FIRST NUMBER IS DUMMY FOR NOW
.IIF NZ DDF,	MOV	#DCURX,D
.IIF Z DDF,	MOV	#CURX,D
	JSR	PC,GETINT	;INTEGER OF CURX IN B
	SUB	OLDX,B	;TO GET DELTA X
	JSR	PC,PSHNUM	;PUSH ON S-PDL
	JSR	PC,GETINT	;INTEGER OF CURY
	SUB	OLDY,B	;TO GET DELTA-Y
	JSR	PC,PSHNUM
	MOV	#3,D	;NUMBER OF ARGS TO SENTENCE
	JSR	PC,SENT.

.IFF
	;CALCULATES DX AND DY, AND PUTS POINTERS TO THEM ON S-PDL
OLD:	JSR PC,(PC)	;DO THIS TWICE
	SETF
	LDF (D)+,FA	;SECOND TIME IT POINTS TO CURY
	SUBF (F)+,FA	;SECOND TIME POINTS TO OLDY
	STF FA,-(P)	;PUT DX OR DY ON STACK
	SPOP A		;PUT FNUM IN A,,B
	SPOP B
	SETD
	JSR PC,GRBAD	;PUT A,,B IN NODE
	BIS #FNUM,C	;SET TYPE
	SPUSHS C	;PUT POINTER ON S-PDL
	RTS PC


SNAP:	GTJUMP GTSNP
	JSR PC,DCHK	;DOES HE OWN ADISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ 2$		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
2$:
.ENDC
1$:	JSR PC,PSHNUM	;PUSH SNAP POINTER
.IIF NZ DDF,	MOV	#DCURX,D	;D POINTS TO CURX
.IIF Z DDF,	MOV	#CURX,D		;DITTO
	MOV #OLDX,F	;E POINTS TO WHERE SNAP IS TAKEN FROM
	JSR PC,OLD	;CALCULATE DX AND DY OF SNAP
	MOV #3,D	;SET FLAG FOR SENTENCE
	JSR PC,SENT.	;MAKE THE THREE THINGS INTO A SENTENCE


.ENDC
;FALLS THROUGH
;FALLS IN
;NOW GRAB A NODE FOR THE SNLIST HACKING
	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BNE	SNAP.2
	MOV	#SNUM,A	;FIRST SNAP
	CLR	B	;CREATE SNAP LIST. FIRST NODE IS A DUMMY
	JSR	PC,GRBAD
	BIS	#LIST,C
	MOV	C,SNLIST
SNAP.2:	JSR	PC,.LDP1	;POINTER TO REST OF SNAP LIST
	JSR	PC,GRBAD	;STORE A NODE
	BIS	#LIST,C
	MOV	C,GCP1	;GARBAGE COLLECT PROTECT

;NOW TRANSFER THE DISPLAY CODE (YEAH)
	MOV	SNABOT,D	;BOTTOM OF STUFF TO BE SNAPPED
	JSR	PC,DYXFR	;TRANSFER THE DCODE. SKIP IF SUCCEEDS
	BEQ	SNAP.4	;COULDN'T FIND ENOUGH FREE MEMORY
SNAP.0:	TST	D	;IF 0
	BEQ	SNAP.3	;NO CODE MOVED

;CHECK THAT THIS SNAP WON'T CAUSE DISPLAY PDL OVERFLOW
	TST	-(D)	;POINTER TO SNAP
	CMP	-(D),#<<<DPDLL_-1>&77777>-1>	;DEPTH COUNTER
	BLE	SNAP.1
	CLR	GCP1
	ERROR+STDP	;SNAP TOO DEEP

;NOW GO BACK AND PUT THE SNAP ADDRESS IN RIGHT PLACES
SNAP.1:	TST	(D)+	;POINT D TO REF COUNTER
	INC	(D)+	;INC COUNTER THAT SAYS HOW MANY TIMES DISPLAYED
	MOV	GCP1,C	;NOW HACK SNLIST
	MOV	D,A
	JSR	PC,.STP2	;STORE ADDRESS IN 2ND WORD OF NODE
	MOV	C,A	;POINTER TO NODE
	BIC	#170000,A
	BIS	#SNUM,A
	MOV	SNLIST,C
	JSR	PC,.STP1	;STORE NEW NODE POINTER INTO FIRST NODE OF SNLIST

	CLR	GCP1


	MOV	@S,C	;NOW HACK THE SNAP STRUCTURE
	BIC	#170000,C
	BIS	#SNP,C
	MOV	C,@S	;PUT IN RIGHT DATA TYPE
;PUT ADDRESS OF SNAP INTO FIRST OF STRUCTURE
	JSR	PC,.LDP2	;A_POINTER TO FIRST OF STRUCTURE
	MOV	A,C
	CLR	A
	MOV	D,B
	BGE	SNAP.6	;SIGN EXTEND ADDRESS
	COM	A
SNAP.6:	JSR	PC,.STORE	;STORE ADDRESS OF SNAP AS FIRST OF STRUCTURE

;NOW COLLAPSE STATIC AREA AND DISPLAY THE SNAP
	MOV	#SNABOT,A	;MAKE SURE THERE IS ROOM FOR DISPLAY HERE
	JSR	PC,STXPND
	MOV	A,STT
	MAKEPJ	D
	MOV	PUSHJT,(A)
	MOV	D,-(A)
	CLR	-(A)
	CLR DFBCNT
	CLZ
	RTS PC


;SINCE NO DISPLAY CODE WAS MOVED, RETURN EMPTY SNAP
SNAP.3:	MOV	#SNP,@S
	CLR	GCP1
	CLZ
	RTS PC

SNAP.4:	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	SNABOT,D
	JSR	PC,DYXFR	;TRY TO TRANSFER D.CODE AGAIN
	BNE	SNAP.0	;SUCCESS!
SNAP.5:	CLR	GCP1
	ERROR+TML
.IFZ FPPF

;NEWSNAP
;SET UP FOR NEXT SNAP TO START HERE
NEWSNAP:	JSR	PC,DCHK
NEWSN1:
.IIF NZ DDF,	MOV	#DCURX,D	;ENTER HERE AS SUBROUTINE
.IIF Z DDF,	MOV	#CURX,D	;ENTER HERE AS SUBROUTINE
	JSR	PC,GETINT	;GET INTEGER OF CURX IN B
	MOV	B,OLDX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,OLDY

.IFF

NEWSNAP:	JSR PC,DCHK	;DOES HE OWN A DISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ 1$		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
1$:
.ENDC
NEWSN1:	;ENTER HERE AS SUBROUTINE
.IIF NZ DDF,	MOV	#DCURX,D	;GET POINTER TO CURX
.IIF Z DDF,	MOV	#CURX,D		;GET POINTER TO CURX
	MOV #OLDX,B		;GET POINTER TO OLDX
	MOV (D)+,(B)+	;PUT CURX AND CURY INTO OLDX AND OLDY
	MOV (D)+,(B)+
	MOV (D)+,(B)+
	MOV (D)+,(B)+

.ENDC

NEWSN2:	MOV	STT,SNABOT	;RESET SNAP BOTTOM TO TOP OF DISPLAY
	CLR DFBCNT
	SEZ
	RTS	PC	;EITHER RETURN FROM SUBROUTINE , OR JMP NORT

;DISPLAY A SINGLE SNAP

DISPLAY:	GTJUMP GTDIS
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?
.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ 2$		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
2$:
.ENDC
1$:	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP,CURX,CURY
	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY
.IFZ FPPF
	MOV	E,B
	ADD	CURX+2,B
	CLR	C	;FRACTION PART IS 0 (SEE SNAP)
	JSR	PC,CHKBND	;IS NEW X COR IN BOUNDS?
	MOV	F,B
	ADD	CURY+2,B
	JSR	PC,CHKBND	;IS NEW Y COR IN BOUNDS?
.IFF
	MOV F,B		;PUT POINTER TO DY IN B
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	STF FA,FB	;FB <- DY
	MOV E,B		;PUT POINTER TO DX IN B
	JSR PC,G1NUMS	;FA <- DX
	BNE .+4
DIPSEY:	.BUG.		;NO WAY IT SHOULD FAIL EITHER
.IIF NZ DDF,	MOV #DCURX,B	;PUT POINTER TO CURX IN B
.IIF Z DDF,	MOV #CURX,B
	SETF
	ADDF (B)+,FA	;GET NEW XCOR
	ADDF (B)+,FB	;GET NEW YCOR
	SETD
	STF FA,FD	;CHECK TO SEE IF XCOR IS IN BOUNDS
	JSR PC,CHKBND
	STF FB,FD	;CHECK TO SEE IF YCOR IS IN BOUNDS
	JSR PC,CHKBND
.IFTF
;NOW SEE IF THERE'S ENOUGH ROOM IN THE DISPLAY AREA
	MOV	#STT,A
	JSR	PC,STXPND	;STATIC AREA EXPAND
;FINALLY, WE CAN PLACE THE PUSHJ TO THE SNAP INTO THE DISPLAY LIST
DISRM:	INC	-2(D)	;INCREMENT THE REF COUNTER OF THE SNAP
	MOV	A,STT	;SET STATIC TOP TO HERE IN DLIST
	MOV	PUSHJT,(A)	;PUT PUSHJ TO TURTLE AT TOP OF DLIST
	MAKEPJ D
	MOV	D,-(A)	;PUT IN THE PUSHJ
	CLR	-(A)	;PRECEDE BY A NOP

;NOW, SET CURX AND CURY
.IFT

	ADD	E,CURX+2	;E HAD DX OF THE SNAP
	ADD	F,CURY+2	;F HAS DY OF THE SNAP
.IFF

.IIF NZ DDF,	MOV #DCURX,B	;B <- POINTER TO CURX
.IIF Z DDF,	MOV #CURX,B
	STCDF FA,(B)+	;PUT NEW XCOR INTO CURX
	STCDF FB,(B)+	;PUT NEW YCOR INTO CURY
	JSR PC,ROUNDER	;ROUND CURX,CURY AND PUT INTO RCURX,RCURY

.ENDC

	CLR DFBCNT
D.RET:	JSR	PC,SPOPT	;POP S
	SEZ
	RTS PC

;WIPE A SNAP

WIPE:	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS	;IS THIS A TV
	BEQ 1$		;NO
	ERROR+NTVS	;TVS CANNOT DO THIS FUNCTION
1$:
.ENDC

	JSR	PC,G1SNAP	;LOAD D,E,F WITH PTR TO SNAP, X,  Y
	BEQ	D.RET	;RETURNS HERE IF ARG IS EMPTY

.IFNZ FPPF

	MOV F,B		;B <- POINTER TO DY OF SNAP
	JSR PC,G1NUMS	;FA <- DY
	BEQ DIPSEY
	LDD FA,FB	;FB <- DY
	MOV E,B		;B <- POINTER TO DX
	JSR PC,G1NUMS	;FA <- DX
	BEQ DIPSEY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	JSR PC,ROUND	;ROUND FA AND FB
	SETI
	STCFI FA,E	;E <- DX OF THE SNAP
	STCFI FB,F	;F <- DY OF SNAP
	SETL
.ENDC
	BIC	#176000,E	;CLEAR TOP 6 BITS
	BIS	#ADDX,E	;AND TURN INTO ADDX COMMAND
	BIC	#176000,F	;CLEAR TOP 6 BITS
	BIS	#ADDY,F	;TURN INTO ADDY

	MOV	D,B
	TST	-(D)	;POINT D TO SNAP'S REF COUNTER
	MAKEPJ B	;MAKE B INTO DPUSHJ TO SNAP
	MOV	STT,A	;POINTER TO TOP OF DISPLAY LIST
	MOV	STB,C	;POINTER TO BOTTOM OF DLIST

WIPE.L:	CMP	A,C	;ARE WE AT THE BOTTOM YET?
	BLO	D.RET	;YES, SO WE ARE DONE
	CMP	B,-(A)	;IS THE NEXT WORD A PUSHJ?
	BNE	WIPE.L	;NO.  LOOP BACK AND TRY ANOTHER
;YES!  IT IS A PUSHJ
;PUT ADDX AND ADDY COMMANDS INTO DLIST
	INC	NADXY	;NADXY IS ACOUNTER TO TELL WHEN TO COMPRESS
	MOV	F,(A)	;INSERT ADDY MADE FROM DY OF SNAP
	MOV	E,-(A)	;INSERT ADDX MADE FROM DX OF SNAP

	DEC	(D)	;DECREMENT REF COUNTER
	BR	WIPE.L	;AND THEN LOOP BACK TO SEE IF THERE'S ANOTHER
;			PUSHJ TO THIS SNAP


;WIPE THE ENTIRE DISPLAY

WIPECL:	GTJUMP GTWIPE	;FOR 2500, CLEAR ALL SNAPS
	JSR	PC,DCHK	;DOES HE OWN A DISPLAY?

.IFNZ TVS
	BIT #TVF,DFLAGS
	BEQ 1$		;NO
	JMP TVWC	;TO THE TV FUNCTIONS
1$:
.ENDC

WC.1:	MOV	STB,A	;POINTER TO BOTTOM OF DISPLAY LIST
	MOV	STT,B	;POINTER TO TOP OF DLIST
	MOV	#100000,E	;SMALLEST DPUSHJ
	MOV	#140000,F	;SMALLEST COMMAND BIGGER THAN PUSHJ

WC.LP:	CMP	B,A	;ARE WE AT BOTTOM YET?
	BLOS	WC.DUN	;YES, WE ARE DONE
	CMP	-(B),E	;IS NEXT WORD DOWN A PUSHJ?
	BLO	WC.LP	;NO, IT'S TOO SMALL
	CMP	(B),F
	BHIS	WC.LP	;NO, IT'S TOO BIG
;THIS WORD IS A PUSHJ
	MOV	(B),D	;MOVE	THE PUSHJ COMMAND INTO D
	MAKEAD D	;TURN INTO PDP-11 ADDRESS
	DEC	-(D)	;DECREMENT SNAP'S REF COUNTER
	BR	WC.LP	;LOOP BACK TO LOOK FOR MORE PUSHJ'S

;NOW PLACE ADDX AND ADDY COMMANDS IN THE DISPLAY LIST
;SO THAT THE TURTLE WILL STAY AT THE SAME PLACE IT WAS BEFORE THE WIPE

.IFZ FPPF

WC.DUN:	MOV	#CURX,D
	JSR	PC,GETINT	;GET INTEGER OF  CURX IN B
	SPUSH	B	;SAVE DX
	JSR	PC,GETINT	;GET INTEGER OF CURY IN B
	MOV	B,E	;PUT DY IN E
	SPOP	D	;PUT DX IN B
.IFF
WC.DUN:
.IIF NZ DDF,	MOV #RDCURX,F	;F <- POINTER TO RCURX
.IIF Z DDF,	MOV #RCURX,F
	LDCFD (F)+,FA	;FA <- RCURX
	LDCFD (F)+,FB	;FB <- RCURY
	JSR PC,MOD1K	;DO A MOD 32K ON FA AND FB
	SETI
	STCFI FA,D	;F <- RCURX
	STCFI FB,E	;E <- RCURY
	SETL
.ENDC
	MOV	STB,STT
	JSR	PC,MTO.AD	;PUTS THE ADD COMMANDS INTO THE DLIST
	JSR	PC,NEWSN1	;SO THAT SNAPS WILL START HERE

	RTS	PC
.ENDC
.SBTTL DISPLAY UTILITY ROUTINES

.IFZ FPPF


;CHKBND
;	CHECK BOUNDS.  ERROR IF B IS OFF SCREEN
;	ALSO ROUNDS B,,C
CHKBND:	BIT	#WRAPF,DFLAGS
	BNE	CBRND	;GO AND ROUND
	CMP	B,#200.
	BGE	CBIBIG	;INTEGER PART MAY BE TOO BIG
	CMP	B,#-200.
	BLT	ERROOB	;DUE TO THE FACT THAT FRACTION IS ALWAYS
			;POSITIVE, IF B=-200 THAT GUARANTEES IT IS IN
			;BOUNDS. (I HOPE)
CBRND:	ASL	C
	ADC	B
	RTS	PC
;HERE, THE INTEGER PART IS >= 200.
;SO IF THE FRACTION PART IS NON-ZERO, THAT WILL MEAN THAT THE ENTIRE
;NUMBER IS GREATER THAN 200
CBIBIG:	BGT	ERROOB	;INTEGER>200
	TST	C
	BEQ	CBRND
ERROOB:	ERROR+OOB

.IFF

CHKBND:	BIT #PLOTF,DFLAGS	;IS HE USING PLOTTER?
	BNE CHK1	;YES, IGNORE WRAP FLAG
	BIT #WRAPF,DFLAGS	;IS HE WRAPPING
	BNE CBRND	;YES, DON'T CHECK BOUNDS
CHK1:	CMPF #42110,FD	;IS 200 < FD?
	CFCC
	BLT ERROOB	;YES, ERROR
	CMPF #142110,FD	;IS -200 > FD?
	CFCC
	BGT ERROOB	;YES,ERROR
CBRND:	RTS PC
ERROOB:	ERROR+OOB	;OUT OF BOUNDS

.ENDC

.IFNZ NDISP

;STATIC AREA EXPAND.
;	IS THERE ROOM IN STATIC AREA FOR 2 DISPLAY WORDS?
;	RETURN POINTER TO NEW STATIC TOP IN A
STXPND:	PUSH	A
	MOV	(A),A	;ROUTINE IS CALLED WITH ADDRESS OF VARIABLE
	CMP	(A)+,(A)+	;A _ A+4
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN8	;THERE'S ROOM!
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	MOV	@(SP)+,A	;AND TRY AGAIN
	CMP	(A)+,(A)+
	CMP	A,DYB	;COMPARE A WITH DYNAMIC BOTTOM
	BLO	STXPN9
	ERROR+TML	;TOO MANY LINES
STXPN8:	TST	(SP)+	;POP OFF A
STXPN9:	RTS	PC

.ENDC


.IFZ FPPF

;MULCOS
;	RETURN A*COSINE OF CURA IN B,,C
MULCOS:	MOV	COSA,F
	BR	MULCS2
;MULSIN
;	RETURN A*SINE OF CURA IN B,,C
MULSIN:	MOV	SINA,F
MULCS2:	CLR	E
	ASL	F	;TURN INTO BOTTOM HALF OF DP NUMBER
	SBC	E	;MAKE E NEG. IF F WAS
	JSR	PC,.DPMUL
	NOP	1
	RTS	PC
.ENDC

;ANGCRP
;	CALCULATE ANGLE CRAP.
;	CALCULATE DIREC, SINA, COSA
ANGCRP:
.IFZ FPPF
	CLR E
.IFZ DDF
	MOV CURA,F	;DIVIDE CURA BY 90.
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	MOV CURA(F),F	;F <- CURX
.ENDC
	DIV #90.,E
	MOV F,C		;THE REMAINDER
	MOV E,F		;THE QUOTIENT
	MOV #90.,E	;THE RIGHT ANGLE
	SUB	C,E	;NOW E = 90.- REMAINDER
	MOV	C,A	;A_REMAINDER
	JSR	PC,SINGET	;D_SIN (A)
	MOV	D,B
	MOV	E,A
	JSR	PC,SINGET
	ASL	F	;F = 0,1,2,3
	ADD	F,PC	;JUMP THROUGH THIS DISPATCH TABLE
	BR	ACR.D
	BR	ACRII	;QUADRANT II
	BR	ACRIII	;QUADRANT III
;FOURTH QUADRANT
	MOV	B,A	;SIN (A)
	MOV	D,B	;SIN (90-A)
	NEG	B	;SINA=-SIN(90-A) IN 4TH QUADRANT
	MOV	A,D	;AND COSA=SIN(A) IN 4TH QUADRANT
	BR	ACR.D

;THE THIRD QUADRANT
ACRIII:	NEG	B	;SINA = -SIN (A) IN 3RD QUADRANT
	NEG	D	;COSA = - SIN (90-A) IN 3RD QUADRANT
	BR	ACR.D

;SECOND QUADRANT
ACRII:	MOV	B,A	;SIN (A)
	MOV	D,B	;SINA = SIN (90-A) IN 2ND QUADRANT
	MOV	A,D
	NEG	D	;COSA = -SIN (A) IN 2ND QUADRANT

;IN THE FIRST QUADRANT
;SINA = SIN (A) AND
;COSA = SIN (90-A)
ACR.D:	MOV	B,SINA
	MOV	D,COSA

;FALLS THROUGH
;FALLS IN

;CLACULATE DIREC FROM STUFF LEFT IN F AND C BY ANGCRP
ANGDIR:	CMP	#45.,C
	ADC	F	;CARRY SET IF C<45
	ASL	F
	ASL	F
	ASL	F
	MOV	F,DIREC
	RTS	PC

;GET SIN (A) INTO D.
;THE SINE TABLE HAS ONLY EVEN ANGLES.  INTERPOLATE ODD ANGLES.
SINGET:	BIT	#1,A	;ODD OR EVEN
	BEQ	AEVEN
	ADD	#<SIN+1>,A	;POINT TO ANGLE AFTER IT
	MOV	(A),D	;SIN (A+1)
	ADD	-(A),D	;PLUS SIN (A-1)
	ROR	D	;DIVIDED BY 2
	RTS	PC
AEVEN:	MOV	SIN(A),D
	RTS	PC

.IFF
	SETI
.IFZ DDF
	LDCIF CURA,FA	;ANGCRP FOR FLOATING DISP
.IFF
	JSR PC,GTCURX	;GET POINTER TO APPROPRIATE CURX
	LDCIF CURA(F),FA	;FA <- CURA
.ENDC
	SETL
	STF FA,FE	;SAVE ANGLE
	JSR PC,SINDEG	;FA <- SIN (FA)
.IIF Z DDF,	STCDF FA,SINA
.IIF NZ DDF,	STCDF FA,SINA(F)	;SINA <- SINE OF ANGLE
	LDD FE,FA	;GET ANGLE
	JSR PC,COSDEG	;FA <- COS (FA)
.IIF Z DDF,	STCDF FA,COSA
.IIF NZ DDF,	STCDF FA,COSA(F)	;COSA <- COSINE OF ANGLE
	ASL C		;CALCULATE DIRECTION
	ASL C
	MOV C,DIREC
 	RTS PC






;XYDIR
;	CALL WITH D=DX, E=DY
;	CALCULATE DIREC BASED ON DX AND DY
XYDIR:	CLR	A	;BUILD INDEX IN A
	TST	D	;IS DX POSITIVE
	BGE	XYDIR1
	NEG	D	;ABSOLUTE VALUE OF DX
	TST	(A)+	;PUT 2 INTO A
XYDIR1:	TST	E	;IS DY POSITIVE
	BGE	XYDIR2
	NEG	E	;ABSOLUTE VALUE OF DY
	INC	A	;INCREMENT INDEX
XYDIR2:	CMP	D,E	;WILL GENERATE CARRY IF D<E
	ROL	A	;PUT CARRY INTO BOTTOM BIT OF INDEX.  AND MULTIPLY REST BY 2
	MOVB	DREC(A),DIREC	;NOW MOVE THE RIGHT THING INTO DIREC
	RTS	PC




.IFNZ NDISP

;DYXFR
;	TRANSFER FROM STATIC AREA TO DYNAMIC AREA
;	THE CODE BEING TRANSFERRED STARTS AT D AND GOES UP TO STT
;	ON RETURN, D POINTS TO THE TRANSFERRED DCODE
;	IF NO CODE WAS TRANSFERRED, THEN D = 0.
;	SKIPS IF THERE'S ROOM FOR TRANSFER
DYXFR:	MOV	STT,E
	SUB	D,E	;LENGTH OF DCODE TO BE MOVED
	BEQ	DYRET	;NOTHING TO BE MOVED
;ALLOCATE STORAGE
;LENGTH OF BLOCK TO BE ALLOCATED IS IN E
DYAL:	ADD	#6,E	;INCREASE LENGTH TO ALLOW FOR REF CNTR, DEPTH CNTR, AND POPJ
	MOV	DYR,B	;INITIALIZE POINTER
	MOV	#1,C	;INITIALIZE FLAG
DYAL1:	MOV	2(B),A	;POINTER TO NEXT FREE BLOCK
	BNE	DYAL2
	DEC	C	;NO NEXT FREE BLOCK--TEST AND SET FLAG
	BNE	DYAL7	;NO MORE ROOM--GO TO EXPAND DY AREA
	MOV	DYB,B	;START AGAIN AT BOTTOM OF LIST
	BR	DYAL1
DYAL2:	MOV	(A),F	;FREE BLOCK FOUND--CHECK LENGTH
	SUB	E,F
	BPL	DYAL4
DYAL3:	MOV	A,B	;BLOCK TOO SHORT--MOVE TO NEXT BLOCK
	BR	DYAL1
DYAL4:	BNE	DYAL5	;BLOCK LONG ENOUGH--IF FILLED EXACTLY
	MOV	2(A),2(B)	;REMOVE BLOCK FROM LIST BY CHANGING POINTERS
DYAL5:	CMP	F,#2	;DONT LEAVE A BLOCK OF LENGTH 2 BYTES
	BEQ	DYAL3
	MOV	F,(A)	;NEW LENGTH OF FREE BLOCK
	MOV	2(B),C	;RESET ROVING POINTER
	BNE	DYAL6	;DONT SET IT TO O
	MOV	DYB,C
DYAL6:	MOV	C,DYR	
	ADD	F,A	;START STORING AT THIS ADDRESS
	BR	DYAL9
DYAL7:	MOV	DYB,A	;ADD NEW BLOCK TO BOTTOM OF LIST
	MOV	2(A),F	;POINTER TO 2ND FREE BLOCK
	SUB	E,A
	CMP	A,STT
	BHI	DYAL8	;THERE IS ENOUGH ROOM IN THE DY AREA
	SEZ
	RTS	PC	;NOT ENOUGH ROOM
DYAL8:	MOV	A,DYB	;NEW BOTTOM OF DY
	MOV	A,DYR	;FIX ROVING POINTER
	MOV	DYB,C	;SET UP NEW LIST BOTTOM
	CLR	(A)+
	MOV	F,(A)+
DYAL9:	SUB	#6,E	;RESTORE LENGTH


;NOW A CONTAINS ADDRESS OF FREE BLOCK
;E CONTAINS NUMBER OF BYTES TO BE TRANSFERRED
;NOW FINALLY YOU GET TO DO THE TRANSFER
;WHILE YOU DO IT, INCREMENT THE REF COUNTER OF ANY PUSHJ'S
DYXFR1:	MOV	#100000,C	;THE CODE FOR DISPLAY PUSHJ
	MOV	#140000,B	;NEXT HIGHER DISPLAY COMMAND
	SPUSH	A	;SAVE POINTER TO DEPTH COUNTER
	CLR	(A)+	;DEPTH_0
	CLR	(A)+	;SET REFERENCE COUNTER TO ZERO
	ASR	E	;E/2 = NUMBER OF WORDS TO BE TRANSFERRED
;PICK UP A WORD.  SEE IF ITS A PUSHJ. AND TRANSFER IT
DYXFR2:	DEC	E	;NUMBER OF WORDS TO BE XFRED
	BLT	DYXFR3
	MOV	(D)+,F	;WORD OF DCODE IN F
	MOV	F,(A)+	;PUT THIS WORD IN ITS NEW PLACE
	CMP	F,C
	BLO	DYXFR2	;NOT A PUSHJ
	CMP	F,B
	BHIS	DYXFR2	;NOT A PUSHJ
;IT IS A PUSHJ
	MAKEAD	F
	INC	-(F)	;INCREMENT THE REF COUNTER
	CMP	-(F),@(SP)	;DEPTH _ MAX (DEPTH OF SUB SNAPS)
	BLE	DYXFR2
	MOV	(F),@(SP)	;DEPTH OF SUB SNAP BIGGEST YET
	BR	DYXFR2	;LOOP BACK

;ALL TRANSFERRING DONE.  END THE BLOCK WITH A POPJ
DYXFR3:	MOV	#DPOPJ,(A)
	SPOP	D	;POINTER TO DEPTH COUNTER
	INC	(D)+
	TST	(D)+	;POINTER TO FIRST D.WORD OF SNAP
	CLZ
	RTS PC	;AND RETURN

;THERE WAS NOTHING TO BE MOVED
DYRET:	CLR	D	;TO SIGNAL THIS FACT
	CLZ
	RTS PC

;DYFREE
;	CALLED DURING GARBAGE COLLECTIONS
;	CALL WITH D POINTING TO REF COUNTER (WORD BEFORE SNAP)
;	FREES THE BLOCK!!
DYFREE:	PUSH	A	;SAVE REGISTERS
	SPUSH	B
	SPUSH	C
	SPUSH	D
	SPUSH	E
	SPUSH	F

	MOV	#100000,A
	MOV	#140000,B
	MOV	#DPOPJ,C
	JSR	PC,DYF1	;DOES THE FREEING
	JMP	RETF	;RESTORE AC'S AND RETURN TO OUT OF DYFREE

;REAL WORK OF FREEING STARTS HERE.
DYF1:	MOV	D,-(SP)	;SAVE PTR TO 2ND WORD OF BLOCK
	TST	(D)+	;POINT D TO FIRST WORD

;PICK UP EACH WORD OF BLOCK.  IF IT IS A PUSHJ, FREE THAT BLOCK
;CONTINUE UNTIL A POPJ IS REACHED
DYF11:	MOV	(D)+,F	;NEXT WORD
	CMP	F,A
	BLO	DYF11	;NOT PUSHJ OR POPJ
	CMP	F,B
	BHIS	DYF2	;NOT PUSHJ, BUT MAY BE POPJ

;	ITS A PUSHJ
	MAKEAD	F
	DEC	-(F)	;REF COUNTER
	BR DYF11	;LOOK AT NEXT WORD

;IS THE WORD A POPJ
DYF2:	CMP	F,C	;C CONTAINS A POPJ
	BNE	DYF11	;NOT A POPJ.  LOOK AT NEXT WORD
	SPOP	C	;POINTER TO 2ND WORD OF BLOCK
	TST	-(C)	;NOW IT POINTS TO BOTTOM WORD
	SUB	C,D	;LENGTH OF BLOCK
	MOV	D,F


;NOW LINK BLOCK BACK TO FREE CORE
;C/ADDRESS OF BLOCK TO BE LIBERATED
;F CONTAINS LENGTH OF BLOCK

DYLIB:	MOV	DYB,B	;INITIALIZE POINTER TO BOTTOM OF LIST
DYLIB1:	MOV	2(B),A	;NEXT FREE BLOCK
	BEQ	DYLIB3	;AT END OF LIST
	CMP	A,C
	BHI	DYLIB2	;PASSED BLOCK TO BE FREED
	MOV	A,B	;TRY NEXT FREE BLOCK
	BR	DYLIB1
DYLIB2:	MOV	F,D	;CHECK UPPER BOUND
	ADD	C,D	;DO WE COLLAPSE NEW BLOCK WITH NEXT ONE?
	CMP	D,A
	BNE	DYLIB3	;NO
	ADD	(A),F	;YES--NEW LENGTH
	MOV	2(A),2(C)	;NEW POINTER
	CMP	A,DYR	;DID WE JUST SCREW ROVING POINTER?
	BNE	DYLIB4
	MOV	DYB,DYR	;YES--RESET IT
	BR DYLIB4
DYLIB3:	MOV	A,2(C)	;POINTER TO NEXT FREE BLOCK--NO COLLAPSE ON TOP
DYLIB4:	MOV	(B),D	;CHECK LOWER BOUND
	ADD	B,D
	CMP	D,C	;DO WE COLLAPSE WITH BLOCK ON BOTTOM?
	BNE	DYLIB5	;NO
	ADD	F,(B)	;NEW LENGTH OF PREVIOUS BLOCK
	MOV	2(C),2(B)	;NEW POINTER
	BR	DYLIB6
DYLIB5:	MOV	C,2(B)	;POINTER IN PREVIOUS BLOCK--NO COLLAPSE
	MOV	F,(C)	;LENGTH OF BLOCK JUST FREED
DYLIB6:	MOV	C,A	;DID WE JUST FREE BOTTOM BLOCK IN DY?
	SUB	#4,A
	CMP	A,DYB	;NOTE THAT IF CURRENT BLOCK = DYB+4
			;THEN PREVIOUS BLOCK (ADDR IN B) MUST BE DYB
	BNE	DYLIB7	;NO
	ADD	(C),B	;YES--COLLAPSE DY AREA
	CLR	(B)
	MOV	2(C),2(B)	;NEW BOTTOM BLOCK
	MOV	B,DYB
	MOV	B,DYR	;FIX POINTERS
DYLIB7:	RTS	PC


;DSGCF
;	CALLED BY LOGO GARBAGE COLLECTOR WHEN ITS ALL DONE
;	SEE IF EACH SNAP ON THE SNAP LIST WAS MARKED.
;	AND DYFREE THE SNAP IF NOT MARKED AND IT'S REFERENCE COUNTER IS 0

DSGCF:	CLR	F
	BR	DSGC1

DSGC4:	TST	F	;0 IF FIRST TIME THROUGH
	BEQ	DSGC5

;
;CODE FROM DSGC8 - DSGC9 GETS CALLED BY DCHK TO COMPRESS DISPLAY AREA
;
DSGC8:	MOV	STB,A	;COMPRESS ADDX'S AND ADDY'S IN STATIC AREA
	MOV	SNABOT,B	;FIRST DO PART BELOW SNAP BOTTOM
	JSR	PC,ADDSHK
	MOV	C,SNABOT	;C IS NEXT LOCATION TO STORE INTO
	MOV	STT,B	;NOW DO PART ABOVE SNAP BOTTOM
	JSR	PC,ADHK0	;DON'T RECLOBBER C.
	MOV	(A),(C)	;STORE PUSHJ TURTLE, TOO
	MOV	C,STT
	CLR	NADXY

DSGC9:	RTS	PC
DSGC5:	MOV	#<DSGC6-DSGCF1>,F	;NOW CLEAR MARKED BITS
DSGC1:	MOV	SNLIST,C	;POINTER TO SNAP LIST
	BEQ	DSGC8	;OBVIOUSLY DOESN'T HAVE SNAPS

	JSR	PC,.LOADC	;FIRST NODE OF LIST IS DUMMY
DSGC2:	MOV	C,E	;SAVE POINTER TO NODE
DSGC3:	BIT	#7777,A	;LEAVE ADDRESS ONLY
	BEQ	DSGC4	;END OF LIST
	MOV	A,C	;POINTER TO NEXT NODE
	JSR	PC,.LOADC
	ADD	F,PC	;CHOOSE BETWEEN FREEING AND CLEARING

;TRY TO FREE THE SNAP
DSGCF1:	TST	-(B)	;WAS SNAP MARKED?  (B POINTS TO REF COUNT)
	BNE	DSGC2	;EITHER DISPLAYED OR MARKED

;NOT MARKED, AND NOT DISPLAYED ANYWHERE!!
;FREE THIS SNAP
	JSR	PC,.FREE	;CLEAN UP SNLIST
	MOV	E,C	;POINTER TO PREVIOUS NODE OF SNLIST
	JSR	PC,.STP1	;STORE A AS TOP WORD OF PREVIOUS NODE
	MOV	B,D	;POINTER TO SNAP DCODE
	JSR	PC,DYFREE
	BR	DSGC3

DSGC6:	BIC	#100000,-(B)	;CLEAR MARKED BIT
	BR	DSGC3

;ADDS HACK
;	COMPRESS ADDX'S AND ADDY'S STARTING AT LOCATION IN A
;	AND GOING TO LOCATION IN B. (DOESN'T STORE WORD AT LOC IN B)
ADDSHK:	MOV	A,C	;C IS NEXT LOC TO STORE INTO.
ADHK0:	CLR	-(SP)	;FLAG. (NOT IN MIDDLE OF ADD'S)
ADHK1:	CMP	A,B	;ARE WE DONE?
	BHIS	ADFIN	;YES
	MOV	(A)+,D	;NEXT WORD
	CMP	D,#ADDY
	BLO	ADNOT	;NOT AN ADD
	TST	(SP)	;IN MIDDLE OF ADD'S ALREADY ?
	BNE	ADPHS1	;YES
	CLR	E	;NO. THIS IS FIRST ADD
	CLR	F
	INC	(SP)	;SET FLAG
ADPHS1:	CMP	D,#ADDX	;THE BIGGER ADD COMMAND
	BHIS	ADPHSX
;IT IS AN ADDY
	ADD	D,F	;ADD THE DELTA-Y INTO F
	BR	ADHK1	;LOOP BACK
ADPHSX:	ADD	D,E	;ADD THE DELTA-X INTO E
	BR	ADHK1

ADNOT:	TST	(SP)
	BEQ	ADHK2	;NOT END OF ADD'S
	JSR	PC,ADPHSF	;JUST ENDED ADDS.
	CLR	(SP)
ADHK2:	MOV	D,(C)+	;STORE THIS WORD
	BR	ADHK1

ADFIN:	TST	(SP)+	;ALL WORDS PICKED UP
	BEQ	ADHK3
	JSR	PC,ADPHSF	;BUT FIRST FINISH ADDS
ADHK3:	RTS	PC

;ADD PHASE FINISHED.  STORE ADDX E, ADDY F.
ADPHSF:	BIC	#176000,E
	BIC	#176000,F
	BEQ	ADPF1	;DELTA-Y = 0
	BIS	#ADDY,F
	MOV	F,(C)+	;STORE ADDY
ADPF1:	TST	E
	BEQ	ADPF9	;DELTA-X = 0
	BIS	#ADDX,E
	MOV	E,(C)+	;STORE ADDX
ADPF9:	RTS	PC


;MKDC
;	CALLED BY LOGO GARBAGE COLLECTOR DURING MARKING PHASE
;	CALLED WITH B POINTING TO SNAP NODE
MKDC:	TST	SNLIST	;CALLED TO KILL THE DISPLAY?
	BEQ	MKDC.K	;YES
	BIT	#7777,B
	BEQ DSGC9	;EMPTY SNAP
;MARK THE SNAP
	PUSH	A
	SPUSH	B
	JSR	PC,.LOAD	;POINT B TO NODE CONTAINING SNAP ADDR
	TST B
	BEQ MKDC1
	JSR	PC,.LOAD	;B_SNAP ADDRESS
	BIS	#100000,-(B)	;MARK REF COUNTER
MKDC1:	SPOP	B	;RESTORE A AND B
	SPOP	A
	RTS	PC

;CALLED BY KILLDISPLAY
;TURN SNAP INTO EMPTY SNAP
MKDC.K:	SPUSH	A
	SPUSH	B
	SPUSH	C
	MOV	B,C	;POINTER TO DCODE NODE
	CLR	A
	JSR	PC,.STP2
	JMP	RETC



;HERE START THE LINE AND TURTLE DRAWING PROGRAMS

;DR.LIN
;	DRAW A LINE. D=DX, E=DY, OR VICE VERSA.
;	THE DIRECTION CODE FOR THE LINE IS IN DIREC
DR.LIN:	CMP DIREC,ODIREC
	BEQ 1$
	CLR DFBCNT
1$:	JSR	PC,DR.STUP	;SET A=CON, B=AC.
	SPUSH	D
	ADD	STT,D	;D = HOW MANY MORE WORDS IN DLIST
	CMP	D,DYB	;COMPARE TO DY BOTTOM
	BLO	DR.L1	;THERE'S ROOM
	JSR	PC,.GCOLL	;TRY TO FREE SOME STORAGE
	SPOP	D	;TRY TO FIT LINE AGAIN
	ADD	STT,D
	CMP	D,DYB
	BLO	DR.L2	;THERE'S ROOM!
	ERROR+TML	;TOO MANY LINES

;OKAY, THERE WAS ROOM FOR THE LINE
DR.L1:	TST	(SP)+	;WE HAD PUSHED D UP ABOVE
DR.L2:	MOV	D,STT	;SET STT TO NEW STATIC TOP
	MOV	PUSHJT,(D)	;PUT PUSHJ TURTLE AT TOP
	JSR	PC,DR.ASC	;ASSEMBLE THE DISPLAY CODE
	MOV DIREC,ODIREC
	RTS	PC	;RETURN


;DRAW THE TURTLE
DR.TUR:	PUSH DIREC
	SPUSH DFBCNT
	MOV	#TURSIZ,C	;TURTLE SIZE
.IFZ FPPF
	CLR	B
	JSR	PC,MULCOS	;E,,F _ SIZE * COSA
	ROL	F
	ADC	E	;ROUND
	MOV	E,D
	JSR	PC,MULSIN	;E,,F _ SIZE * SINA
	ROL	F
	ADC	E	;ROUNFD
.IFF
	SETI
	LDCIF C,FA
	SETL
.IIF NZ DDF,	LDCFD DSINA,FB
.IIF Z DDF,	LDCFD SINA,FB
	MULF FA,FB
	ADDF #40000,FB	;ROUND
.IIF NZ DDF,	LDCFD DCOSA,FC
.IIF Z DDF,	LDCFD COSA,FC
	MULF FA,FC
	ADDF #40000,FC
	SETI
	STCFI FB,E
	STCFI FC,D
	SETL
.ENDC

	SPUSH	D
	SPUSH	D
	SUB	E,2(SP)	;NOW SIZE * (COSA - SINA) IS ON STACK
	ADD	E,(SP)	;NOW SIZE * (COSA + SINA) IS ON STACK

	MOV	TUB,TUT	;TUT WILL BE POINTER TO TOP OF TURTLE DLIST SO FAR
;FALLS THROUGH
;FALLS IN

;SIDE 1
	ADD	#20,DIREC	;SIDE 1 IS 2*45 DEGREES LEFT OF CURRENT DIRECTION
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 2
	SUB	#30,DIREC	;SIDE 2 IS 3*45 DEGREES RIGHT OF SIDE 1
	MOV	(SP)+,D	;DX IS SIZE * (COSA + SINA)
	MOV	(SP)+,E	;DY IS SIZE * (COSA - SINA)
	JSR	PC,DR.TSD	;DRAW THE SIDE

;SIDE 3 HAS THE SAME INCREMENTS AS SIDE 2.
;JUST THE DIRECTION IS DIFFERENT
	MOV	DIREC,B
	SUB	#20,B	;SIDE 3 IS 2*45 DEGREES RIGHT
	BIC	#177707,B	;LEAVE ONLY THE 3 BITS
	SWAB	B	;PUT THE DIREC BITS IN TOP BYTE
	MOV	TUT,C	;POINTS TO WORD ABOVE LAST ONE OF TURTLE DLIST
	MOV	C,A
	SUB	D,C	;SINCE D POINTS TO BOTTOM WORD OF SIDE 2
			;C-D IS NUMBER OF BYTES IN SIDE 2'S DLIST
	ASR	C	;C/2 = NUMBER OF WORDS
DR.TS3:	MOV	(D)+,E	;NEXT WORD OF SIDE 2'S DLIST
	BIC	#34000,E	;CLEAR THE DIRECTION BITS THEREIN
	BIS	B,E	;AND SET THEM FROM THE NEW DIREC IN B
	MOV	E,(A)+	;STORE IN DLIST
	DEC	C	;NUMBER OF WORDS IN SIDE 2'S DLIST
	BGT	DR.TS3	;THERE ARE MORE WORDS

;SIDE 4 IS IDENTICAL TO SIDE 1
;FURTHERMORE, SIDE 1 IS MADE UP OF ONLY ONE WORD
	MOV	@TUB,(A)+	;PUT THE FIRST WORD OF TURTLE INTO TOP WORD
	MOV	#DSTOP!DPOP,(A)

;RESTORE DIREC, THEN RETURN
	SPOP DFBCNT
	POP DIREC
	RTS	PC


;DRAW TURTLE SIDE
;	DRAW ONE SIDE OF THE TURTLE
;	DIREC CONTAINS THE DIRECTION
;	TUT POINTS TO TOP OF TURTLE DISPLAY LIST SO FAR
;	C,D = + OR - DX OR DY
DR.TSD:	BIC	#177707,DIREC	;BITS MAY HAVE BEEN SET BY THE SUBTRACTING
	CLR DFBCNT
	JSR	PC,DR.STUP
	ADD	TUT,D	;D = NEW TOP OF TURTLE
	MOV	D,TUT
	JMP	DR.ASC	;ACTUALLY CREAT THE DISPLAY LIST


;SET UP CON AND AC
;	CALL WITH D,E = + OR - DX OR DY
;	PASSES ON A=FRACTION: MIN (DX/DY,DY/DX)
;		B=ACCUMULATED FRACTION PART SIDEWAYS OF MAIN DIRECT.
;		STARTS AT 1/2
DR.STUP:	TST	D
	BGE	DR.TE	;TEST E
	NEG	D	;MAKE D POSITIVE
;MAKE SURE E IS POSITIVE
DR.TE:	TST	E
	BGE	DR.BIG	;NEXT WE'LL SEE WHICH IS BIGGER
	NEG	E	;MAKE D POSITIVE

;WHICH IS BIGGER
DR.BIG:	CLR B		;CLEAR LOW WORD OF WHICHEVER NUMBER
	CMP	D,E
	BGT	DR.DBG	;D IS BIGGER
	BEQ	DR.EQ	;THEY ARE THE SAME SIZE

;OTHERWISE, E IS BIGGER
	ASL	E	;SO EAE WON'T OVERFLOW WITH A 16 BIT QUOTIENT
	MOV D,A		;DIVIDE D,,0 BY E
	DIV E,A
	MOV	E,F	;WHICHEVER IS BIGGER IS THE NUMBER OF INCS
	BR	DR.SC4

;THEY ARE THE SAME SIZE
DR.EQ:	MOV	#-1,A	;SET CON = .777...
	MOV	E,F	;NUMBER OF INCS
	BR	DR.SC5

;D IS BIGGER
DR.DBG:	ASL D
	MOV E,A		;DIVIDE E,,0 BY D
	DIV D,A
	MOV	D,F	;NUMBER OF INCS

;NOW PICK UP THE QUOTIENT
DR.SC4:	ASL	A	;MAKE QUOTIENT 16 BITS
	ASR	F	;SINCE WE DOUBLED IT ABOVE

;NOW SET AC = .1000 = 1/2 IN THIS REPRESENTATION
DR.SC5:	MOV	#100000,B
;FALLS IN!

;CALCULATE THE NEW END POINT OF THE DLIST
;	RETURNS A AND B AS ABOVE
;	C = BIT-POSITION OF LAST BIT OF NEW CODE
;	  (GENERATED BACKWARDS--STORE FROM HERE BACK)
;	D = NUMBER OF MORE WORDS IN DLIST
;	  (WILL BECOME ADDR OF LAST NEW WORD + 2)
;	E = TOP BYTE OF INCR INSTRUCTION, SWAPPED
;	F = # NEW INCREMENTS
DR.NEP:	CLR C		;CLEAR BIT-POSITION
	MOV F,E		;GET # OF INCREMENTS
	SUB DFBCNT,E	;LESS # LEFT OVER
	MOV E,D
	ASH #-3,D	;DIVIDE BY 8
	ASL D
	BIC #177770,E	;REMAINDER IS # BITS IN LAST WORD
	BEQ DR.NE2	;IF 0 THEN = 8 IN PREVIOUS WORD

	MOV #8.,DFBCNT	;ELSE FREE BITS = 8 - # USED
	SUB E,DFBCNT
	ADD #2,D	;ADD ONE-WORD FUDGE FACTOR IN THIS CASE
	SPUSH E
	SEC
DR.NE1:	RORB C		;SHIFT FIRST-BIT IN OR RIGHT ONE BIT
	DEC E		;SHIFT IT RIGHT (REMAINDER) PLACES
	BNE DR.NE1
	SPOP E
	BR DR.NE3

;REMAINDER WAS 0:  LAST WORD GETS FILLED UP
DR.NE2:	INC C		;LAST BIT IS LAST IN WORD
	CLR DFBCNT	;NO FREE BITS

DR.NE3:	ADD #DINC_-8,E	;PUT IN "INCREMENT" CODE
	ADD	DIREC,E	;ADD IN THE DIRECTION
	RTS	PC


;ACTUALLY ASSEMBLE THE NEW DISPLAY LIST
;	CALL WITH A=SIDEWAYS/FORWARD, B=1/2 (ACCUM SIDEWAYS),
;	C=FIRST BIT POS., D=POINTER  TO FIRST WORD TO STORE OF DLIST
;	E=TOP HALF OF THE INC MODE INSTRUCTION, F=NUMBER OF INCS
DR.ASC:	SWAB	E	;STUFF IN E WAS IN WRONG HALF
DR.AS0:	ADD	A,B	;CON+AC
	BCC	DR.AS1
	ADD	C,E	;CARRY, SO PUT A 1 INTO DCODE
DR.AS1:	DEC	F	;NUMBER OF INCS
	BLE	DR.ALW	;THIS WAS THE LAST WORD
	CLC
	ROLB	C	;SHIFT BYCNT
	BCC	DR.AS0	;CONTINUE WITH THIS WORD

;THIS WORD DONE
	JSR	PC,DR.SH
	MOV	E,-(D)	;STORE IN DLIST
	BIC	#3777,E	;0 THE COUNT AND BOTTOM BYTE
	MOV	#1,C	;RESET BYCNT
	BR	DR.AS0

;ALL THAT'S LEFT TO DO IS STORE THE BOTTOM WORD OF NEW DLIST
DR.ALW:	MOV -(D),B	;GET WORD TO HOOK
	CLR A		;SET UP BIT TO HOOK FROM
	SEC		;  "
DR.LW1:	ROL A		;  "  OR NEXT BIT TO HOOK FROM
	CLC
	ROLB C		;NEXT BIT TO HOOK INTO
	BCS DR.LW2	;DONE HOOKING
	BIT A,B		;GET BIT
	BEQ DR.LWX
	ADD C,E		;STORE IT
DR.LWX:	CLC		;SET UP FOR ROL A
	BR DR.LW1

DR.LW2:	JSR	PC,DR.SH	;SHOVE TO RIGHT END OF WORD
	MOV	E,(D)	;STORE LAST WORD
	RTS	PC

;SHIFT CODE RIGHT 8 MINUS COUNT TIMES

DR.SH:	PUSH	E
	SWAB E		;GET COUNT OF USED BITS
DR.SH1:	BIC #177770,E	;ISOLATE COUNT
	BEQ	DR.SH2	;DONE
	INC E		;COUNT UP; DONE AT 8 (OR 0)
	CLC
	RORB	(SP)	;MAKE ANOTHER FREE BIT AT LEFT
	BR	DR.SH1
DR.SH2:	POP	E
	RTS	PC

.ENDC
.ENDC


.IFNZ TVS
.SBTTL TV TURTLE ROUTINES
;;;;;;;;;;;;;;;;;;;;
;TV TURTLE ROUTINTES
;;;;;;;;;;;;;;;;;;;;

;THESE ROUTINES ARE USED TO PROCESS DISPLAY GRAPHICS FOR TVS.
;THE ROUTINES ARE IN MANY CASES BASED ON, AND TRY TO FOLLOW THE
;WORK OF HENRY LIEBERMAN WITH HIS TVRTLE ROUTINES FOR LLOGO.

FAKTVR:				;Move real TV register to Fake locations
				;for debugging. Symbols FAKADR, FAKWIN, FAKINC, ...
	MOV COLORA, FAKCLA
	MOV COLORD, FAKCLD
	MOV TVINCR, FAKINCR
	MOV TVSEL, FAKSEL
	MOV TVRADR, FAKADR
	MOV TVWDCN, FAKWDC
	MOV TVSHR, FAKSHR
	MOV TVMSK, FAKMSK
	MOV TVRWIN, FAKWIN
	MOV TVCNSO, FAKCNS
FAKEND:	RTS PC



TVSTRT:	JSR PC,TVINIT		;CREATE DISPLAY
TVSTR1:	MOV TVBOT,B		;EVERYTHING BELOW DISPLAY AREA CAN BE ECHO AREA
	JSR PC,CRECHO		;CREATE THE ECHO AREA IN SCREEN
	JSR PC,TVCS		;CLEAR SCREEN, RESET TURTLE
	LDFPS #40300		;RESET THE FLOATING POINT PROCESSOR
	SEZ
	RTS PC


;CREATE A DISPLAY CAPABILITY AND INITIALIZE VARIABLES
TVINIT:	JSR PC, IORMODE
CTVINIT:
	BIC #<PLOTF!HIDETF!TURTF!PENUF!XORF!ERASEF!WRAPF!CLIPF>,DFLAGS	
	CLR DPENP		;START WITH PENDOWN
	BIS #DISPF!TVF,DFLAGS	;WE ARE CONTROLING DISPLAY AND IT IS A TV DISPLAY
	BIS #DISPF,DIVOWN	;WE OWN A DISPLAY
	MOV #DORBEG,A
TVINI1:	CLR (A)+		;CLEAR OUT THIS AREA
	CMP A,#DOREND
	BLO TVINI1
	MOV #2.,TVTOP		;TOP OF DISPLAY AREA IS TV LINE 2
	MOV #302.,TVBOT		;BOTTOM OF DISPLAY AREA IS TV LINE 302
	MOV #273.,TVLEFT	;LEFT SIDE OF DISPLAY AREA IS LINE 138
	MOV #573.,TVRIGHT	;RIGHT SIDE OF DISPLAY AREA IS LINE 438
	MOV #301.,TVSIZY	;Y SIZE IS 300.
	MOV #301.,TVSIZX	;X SIZE IS 300.
	MOV #152.,TVCENY	;Y CENTER IS 152.
	MOV #423.,TVCENX	;X CENTER IS 288.
	MOV #301.,TVMIN		;SIZE OF TV PICTURE
	MOV #400.,TRMIN		;TURTLE PICTURE SIZE
	CLR TRCENX		;TURTLE PICTURE CENTER X
	CLR TRCENY		;TURTLE PICTURE CENTER Y
	MOV TVCENX,TVX
	MOV TVCENY,TVY		;THE DRAWER SHOULD GO INTO THE CENTER OF BOX
;	SAVE <TVX,TVY,DISCAP>
;	BIS #.TVDSS*400,(P)	;SET THE DRAWER TO THE RIGHT PLACE
;	$INVOK
	SETF
	SETI			;THE FOLLOWING STUFF IS IN SHORT INTEGER AND FLOAT MODE
	LDCIF #1.,FA
	STF FA,TRSCLX		;STORE 1 AS THE TURTLE SCALE
	STF FA,TRSCLY		;LIKEWISE
REINIT:	SETF
	SETI
	LDCIF TRMIN,FA		;TURTLE SIZE X(Y)=TURTLE SCASLE FACTOR X(Y)
	LDF TRSCLX,FB
	MULF FA,FB		;MULTIPLIED BY THE TURTLE MINIMUM DIMENSION
	STF FB,TRSIZX
	LDF TRSCLY,FC
	MULF FA,FC
	STF FC,TRSIZY
	LDCIF #-2,FD		;TURTLE LEFT BOUNDRY=TURTLE SIZE X/-2
	DIVF FD,FB
	STF FB,TRLEFT
	NEGF FB			;TURTLE RIGHT BOUNDRY= -TURTLE LEFT BOUNDRY
	STF FB,TRRIGH
	DIVF FD,FC		;TURTLE BOTTOM BOUNDRY=TURTLE SIZE Y/-2
	STF FC,TRBOT
	NEGF FC			;TURTLE TOP BOUNDRY= -TURTLE BOTTOM BOUNDRY
	STF FC,TRTOP
	LDCIF TVMIN,FB
	SUBF FLTTOL,FB
	SUBF FLTTOL,FB
	DIVF FB,FA
	STF FA,TRPRTV		;TURTLE PER TV = TRMIN / (TVMIN - FLOAT TOLERANCE * 2)
	LDCIF #15.,FB
	MULF FA,FB
	STF FB,TRFRAD
	LDCIF #10.,FB
	MULF FA,FB
	STF FB,TRSRAD
	RTS PC


;Color TV initializations. Follows Lisp TVRTLE and BEE;CLRTST programs.

.IFNZ COLOR

FLSBUF:				;Delete capabilities to display buffers in DSCAP table.
	MOV #PIXMAX, C		;Size of capability table for loop index.
	MOV #DSCAP, B		;Index into capability table.
FLBLUP:	MOV (B), A	
	CLR (B)+
	JSR PC, DELCP
	SOB C, FLBLUP
	RTS PC

COLORINIT:			;Color initialization.
	JSR PC, FLSBUF		;FLUSH ALL BUFFERS
	JSR PC, G1NARG		;Argument is number of buffers [bits per point].
	TST B
	BLT 1$
	CMP #4,B
	BGE 2$
1$:	ERROR+WTA
2$:
	CLR A
GRABUF:				;Magic SITS system call to grab a buffer.
	SAVE <#-1, #40377, #.DSCAP*400+0>
	.INVOK
	BNE GOTBUF
	ADD #6,P	;FLUSH ARGS TO FAILED CALL
	BR GOTBU1	;TERMINATE PREMATURELY
GOTBUF:
	REST <DSCAP (A), , DSNUM (A)>
	TST (A)+		;Stuff capabilities and associated buffer numbers
	SOB B, GRABUF		;in tables.

GOTBU1:	MOV A,B
	ASR B			;NUMBER OF BUFFERS WE REALLY GOT
	MOV DSCAP, A		;Pass along capability to one of the color buffers.
	JSR PC, TVRMAP		;Do the system call mapping in TV registers.
	MOV B, NCBITS		;Stow this in NCBITS.
	MOV #1, A
	ASH B, A		;(SETQ PALETTE-SIZE (LSH 1 NCBITS))
	MOV A, PALSIZ
	CLR PENNUM
	MOV A, ERANUM		;(SETQ :ERASERNUMBER (1-  PALETTE-SIZE))
	DEC ERANUM
	ASR A
	MOV A, NCSIGB		;High order color bit.
	RTS PC
				
CRESET:	JSR PC,INITCR		;Initialize video switch and console register.
	BIS #TVOFLO,TVINCR	;Mask to handle overlow correctly in TVINCR.
	JSR PC, SETMODE		;Choose SET drawmode [others don't make sense in color].
	MOV #-1., WINDATA	;Always write bits on [SETMODE clears WINDATA].
	BR CLRWRT		;Turn on color write mode.


INITCR:	CLR C			;Initialize console register and video switch.
	MOV NCBITS, B		;Do the following loop NCBITS times, for each buffer.
ICRLUP:	MOV DSNUM (C), D	;Retrieve buffer number from DSNUM table.
	MOV D, TVSEL		;Select that buffer.
	MOV CRMC (C), TVCNSO	;Move magic constant from table to console register.
	MOV C, E
	ASH #<-1.+8.>, E	;Construct word with buffer number in low order byte
	ADD E, D		;and word index in buffer table in high order byte,
	ADD VSWMC, D		;and magic constant added for video switch.
	MOV D, VIDSW
	TST (C)+
	SOB B, ICRLUP

	MOV #6,A	;THERE ARE SIX BITS IN THE COLOR MAP
	SUB NCBITS,A	;NUMBER OF BUFFERS WE SEEM TO HAVE
	ASH #7,C	;FOR NON-EX BUFFERS
	ADD #30_8,C	;MUST SWITCH TO NOTHINGNESS
	ADD #17,C	;I THINK THIS IS IT??
INITC2:	MOV C,VIDSW	;NOTHING FOR YOU
	ADD #1_8,C	;NEXT
	SOB A,INITC2	;THERE BETTER BE AT LEAST ONE COLOR BIT TO SWITCH TO NON-EX!!
	RTS PC


;FULSCREEN:			;For color, the default TV size should be whole screen.
;	MOV #450., TVBOT	;Change TV, TURTLESIZE default to whole screen.
;	MOV #2., TVLEFT
;	MOV #574., TVRIGHT
;	MOV #574., TVSIZX
;	MOV #449., TVSIZY
;	MOV #289., TVCENX
;	MOV #226., TVCENY
;	MOV TVCENX, TVX
;	MOV TVCENY, TVY
;	MOV #449., TVMIN
;	MOV #1000., TRMIN
;	SETF
;	SETI 
;	LDCIF #1000., FA
;	LDCIF #448., FB
;	DIVF FB, FA
;	STF FA, TRSCLX
;	JMP REINIT		;Redo TURTLESIZE to keep variables consistent.


.CLRINIT:			;.COLORINIT user primitive
	JSR PC, COLORINIT	;Additional initialization for color.
	SAVE B			;SAVE NUMBER OF BUFFERS WE GOT
	JSR PC, CTVINIT		;Do standard initializations for all TV's.
	JSR PC,CRESET		;DO EXTRA STUFF FOR COLOR
	BIS #COLORF, DFLAGS	;Set flag indicating use of color display.
CINIWON:
	LDFPS #40300		;Reset floating point processor [whatever that means].
	REST B
	JMP R1NARG

;WBLOCK: 			;[WRITE-TV-BLOCK] uses block mode of
;	TST C			;hardware to write lots of words at once.
;	BEQ WBLEND		;Arguments: ADDRESS, CONTENTS, ITERATIONS, STEP.
;	BIC #TVINC, TVINCR	;(WRITE-CONTROL-FIELD TVINCR-ADDRESS STEP TVINC-MASK)
;	BIS D, TVINCR
;	MOV A, TVRADR		;(WRITE-TV-WORD ADDRESS CONTENTS)
;	MOV B, TVRWIN
;	DEC C
;	TST C			;(COND ((ZEROP (DECREMENT ITERATIONS)) ...)
;	BEQ WBLINC
;	NEG C
;	MOV C, TVWDCN		;(WRITE-TV-WORD-COUNT (- ITERATIONS))
;WBWAIT:
;	BIT #TVWDCM, TVWDCN	;(DO NIL ((ZEROP (READ-TV-WORD-COUNT))))
;	BNE WBWAIT
;WBLINC:
;	BIC #TVINC, TVINCR	;(WRITE-CONTROL-FIELD TVINCR-ADDRESS 0. TVINC-MASK)
;WBLEND: RTS PC


CLRWRT: BIS #COLORW, DFLAGS	;Sets color write mode [COLOR-WRITE].
	BIS #TVCLRW, TVINCR	;Set color write bit in increment register.
	BR RESELC		;Reselect color.

NOCLRW:	BIC #COLORW, DFLAGS	;Turns off color write mode [NO-COLOR-WRITE].
	BIC #TVCLRW, TVINCR	;Falls thru to RESELECT-COLOR.
		
RESELC: BIT #ERASEF, DFLAGS	;Reselects the proper color in the palette
	BNE SELERA		;according to pen or eraser state [RESELECT-COLOR].
				;Falls through to SELECT-PEN.

SELPEN:	MOV PENNUM, A		;Select the pen color.
	BR SELCOL

SELERA:	MOV ERANUM, A		;Select the eraser color.
				;Falls thru to SELECT-COLOR.
SELCOL:				;Selects a current color from the palette or, 
SELBUF:				;Selects one of the TV buffers [same code].
				;[SELECT-COLOR, SELECT-TV-BUFFER]
	BIC #TVRCNS, TVSEL	
	BIS A, TVSEL		;Write the color or buffer number into the
	SEZ
	RTS PC			;console number field in the console select
				;register.

.COLOR: 			;User primitive to select a color in color map.
	JSR PC, G1NARG		;Returns fixpoint number in B.
	MOV B, A
	MOV A, PENNUM
	JMP SELCOL


;[WRITE-COLOR-MAP] Writes a new color into the color map. 
;Arguments: COLOR-MAP-SLOT, RED, GREEN, BLUE intensities.
;
;WCMAP:	SAVE A			;Save slot number.
;	MOV B, COLORD
;	BIS #CLRRED, A		;IOR slot number with red.
;	MOV A, COLORA		;Color written when address register written.
;	MOV C, COLORD
;	MOV (P), A		;Restore slot from stack, without popping.
;	BIS #CLRGREEN, A	;Or with green, 
;	MOV A, COLORA
;	MOV D, COLORD
;	REST A			;Pop off slot number.
;	BIS #CLRBLUE, A		;And similarly for blue.
;	MOV A, COLORA
;	RTS PC
;
;
;.WRIMAP:			;.WRITEMAP user primitive to write into color map.
;	JSR PC, G1NARG		;Takes 4 args: slot number, RED, GREEN, BLUE
;	SAVE B
;	JSR PC, G1NARG
;	SAVE B
;	JSR PC, G1NARG
;	SAVE B
;	JSR PC, G1NARG		;Remove 4 args from stack, put then in A, B, C, D
;	MOV B, D
;	REST <C, B, A>
;	JSR PC, WCMAP		;The routine that does the work.
;	SEZ
;	RTS PC
;

.WRIRED:
	JSR PC, G2NARG		;Get two integer args, return them in A and B.
	MOV #CLRRED, C		;It's the red we want to write.
	BR WRIMAP

.WRIGREEN:
	JSR PC, G2NARG
	MOV #CLRGREEN, C
	BR WRIMAP
	
.WRIBLUE:
	JSR PC, G2NARG
	MOV #CLRBLUE, C
				;Falls thru to WRIMAP.

WRIMAP:				;Writes a color into color map. Args: slot number
				;in B, beam intensity in A, mask for which beam in C.
	BIS C, B		;IOR slot number with mask for RED, GREEN, or BLUE.
	MOV A, COLORD		;Write into color data before color address.
	MOV B, COLORA
	SEZ
	RTS PC
		

.REAPAL:			;.READPALETTE user function. 
	JSR PC, G1NARG
	ASL B			;Double for number of bytes from start of palette.
	SPUSHS PALETTE (B)	;Indexes supplied arg into the palette.
	CLZ
	RTS PC

.WRIPAL:			;.WRITEPALETTE user function.
	MOV @S, B		;Atom from S stack to B [don't pop to leave GC protect]
	MOV #ATOM, A		;Convert to type ATOM, type check, etc.
	JSR PC, CONVERT		;Atom returns in B.
	SAVE B
	ADD #2, S		;Remove atom from S stack.
	JSR PC, G1NARG		;Index to write into in B
	ASL B			;Multiply by 2 to get byte address.
	REST PALETTE (B)	;Move atom into position in palette indexed by A.
	SEZ
	RTS PC

.ENDC				;End of color conditional assembly section.


XORMODE:
	MOV #TVXOR, A
	BR WINMODE
IORMODE:
	MOV #TVIOR, A
WINMODE:
	MOV #-1., WINDATA	;XOR, IOR draw with bits on.
	BR DRAWMODE		
SETMODE:			;SET mode for eraser draws with bits off.
	MOV #TVSET, A		;In color, however, in SETMODE always but bits on.
	CLR WINDATA		
DRAWMODE:			;Sets mode for writing into screen memory.
	BIC #TVRWMD, TVSEL	;Choose from: TVIOR, TVSET, TVXOR.
	BIS A, TVSEL
	RTS PC






;TVCHK CHECKS IF MY TTY IS A TV. IT CLEARS Z IF IT IS, SETS Z OTHERWISE.
;ALSO SETS THE TV FLAG IN DFLAGS.
TVCHK:	SAVE <,,TYOCP>
	BIS #.TTTYP*400,(P)	;GET FLAGS FROM TTY TABLE
	$INVOK
	BIT #200,(P)+		;BIT 200 IS THE TV FLAG
	BEQ TVCHK1		;IS NOT A TV
	BIS #TVF,DFLAGS		;YES IT IS!
	SAVE <#-1,TYOCP>
	BIS #140000,(P)
	SAVE #0+.DSCAP*400	;0 IS CREATE CAPABILITY
	$INVOK
	REST <DISCAP,,>		;CREATE THE DISPLAY CAP
	MOV DISCAP, A		;Falls thru to TVRMAP.

TVRMAP:				;Map in TV control registers.
	SAVE <#0, #4, A, #.CRWRT!1>
	MOVB #DISPG+10, 3 (P)
	$MAP			;Magic SITS system call to access TV control registers.
	SAVE <,,#.TVSAV*400>
	MOVB A, (P)
	$INVOK			;Magic SITS system call enabling saving of TV registers.
TVCHK1:	RTS PC


;CREATE AN ECHO AREA WITH SIZE BASED ON FONT. EXPECTS THE TV LINE OF THE TOP
;OF THE ECHO AREA IN B

CRECHO:	
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ CREBW
	RTS PC
.ENDC
CREBW:
	SAVE <TVSEL, TVMSK>	;Save TV registers over system calls.
	SAVE <,#.TSCRL,TYOCP>
	BIS #.TTBS2*400,(P)	;GO INTO SCROLL MODE FOR NOW
	$INVOK
	SAVE <,,TYOCP>
	BIS #.TVCL*400,(P)	;SO WE CAN RESET THE SCREEN
	$INVOK			;AND DO A REAL CLEAR
	SAVE <,#.TSCRL,TYOCP>
	TST B			;DOES HE REALLY WANT AN ECHO AREA?
	BNE CRECH1
	BIS #.TTBS2*400,(P)	;NO, SET THE SCROLL MODE BIT
	BR CRECH2
CRECH1:	BIS #.TTBC2*400,(P)	;YES, CLEAR THE SCROLL MODE BIT TO USE WRAP MODE
CRECH2:	$INVOK
	SAVE <,,TYOCP>
	BIS #.TVRFN*400,(P)	;READ THE NUMBER OF TV LINES PER CHAR LINE
	$INVOK			;AND THE WIDTH OF CHAR IN BITS
	REST <TVHIGH,TVWIDE>
	CLR A			;FOR THE DIVIDE
	DIV TVHIGH,A		;DIVIDE BY NUBER OF TV LINES PER CHAR LINE
	TST B			;ANY REMAINDER?
	BEQ 1$			;COUNT IT AS ONE MORE LINE
	INC A
1$:	SAVE <,A,TYOCP>
	BIS #<.TVOFF+.PRWRT>*400,(P)	;SET THE OFFSET TO SET THE ECHO AREA
	$INVOK			;THIS WILL CLEAR SCREEN AND THUS SET CURSOR
	MUL TVHIGH,A
	MOV B,TVSIZE		;THE DISPLAY AREA HAS THIS MANY LINES
	REST <TVMSK, TVSEL>
	RTS PC

TVCS:	SETF
	SETI
	LDCIF TRCENX,FA
	STF FA,DCURX		;RESET DCURX
	LDCIF TRCENY,FA
	STF FA,DCURY		;RESET DCURY
	CLR DCURA		;RESET DCURA
	CLRF FA
	STF FA,DSINA		;RESET DSINA
	LDCIF #1,FA
	STF FA,DCOSA		;RESET DCOSA
	MOV TVCENX,TVX
	MOV TVCENY,TVY		;SO THE DRAWER WILL GO BACK TO CENTER OF SCREEN
;FALL IN TO TVWC


TVWC:				;TV WIPECLEAN.
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ WCBW
CTVWC:	JSR PC, TVWCOL		
	BR WCDPAL
.ENDC
WCBW:	JSR PC, TVWCBW
WCDPAL:	JSR PC, CLEPAL
	JMP DTVTUR
TVWC1:	SEZ
	RTS PC


.IFNZ COLOR
TVWCOL:				;Clear screen in color. [TV-CLEARSCREEN] WIPECLEAN
	JSR PC, SELERA		;(SELECT-COLOR :ERASERNUMBER)
	JSR PC, FILSCR
;	JSR PC, SELPEN
;	JSR PC, OUTLIN
	JMP RESELC

FILSCR:	CLR TVMSK
	CLR TVRADR
	MOVB #1, TVINCR
	MOV #TVRWIN, C
	MOV WINDATA, A
	MOV #WORLIN*453., B
FLSCLUP:
	MOV A, (C)
	SOB B, FLSCLUP
	CLRB TVINCR
	RTS PC

;Block mode unreliable when switching processes.
;CTVWC:	CLR A			;(WRITE-TV-BLOCK 0. -1. 16344. 1)
;	MOV #-1., B
;	MOV #16344., C
;	MOV #1, D
;	JSR PC, WBLOCK
;	JMP RESELC		;(RESELECT-COLOR)

.ENDC

TVWCBW:	SAVE <TVSEL, WINDATA>
	JSR PC, SETMODE		;To clear the screen in black and white,
	JSR PC, FILDIS
	JSR PC, IORMODE
	JSR PC, OUTLIN
	REST <WINDATA, TVSEL>
	RTS PC

FILDIS:				;Fill display area bounded by TVTOP, BOT, LEFT, RIGHT.
	MOV TVLEFT, A
	MOV TVRIGHT, B
	MOV TVTOP, C
	MOV TVBOT, D		;Falls through to FILWIN.


FILWIN:				;Fills area bounded by A, B, C, D
	MOVB #WORLIN, TVINCR	;Words written a line at a time.
	SUB C, D
	INC D			;Number of lines to be written in D.
	MOV A, E
	BIC #-<15.+1>, E
	ASL E
	MOV STARMSK (E), TVMSK	;Calculate starting mask.
	MOV B, E
	BIC #-<15.+1.>, E
	ASL E
	SAVE STOPMSK (E)	;Save stopping mask.
	ASH #-4., A
	ASH #-4., B		;Left and right in words.
	MOV C, F		
	MUL #BYTLIN, F
	MOV A, E
	ASL E
	ADD E, F		;Byte address in F.
	MOV WINDATA, E
	CMP A, B		;Starting and stopping words equal? 
	BNE FILMTOW
	BIC (P)+, TVMSK		;And starting and stopping masks.
	BR FILSTRIP
FILMTOW:			;Fill more than one word.
	SUB A, B
	DEC B			;Iteration counter for full word loop.
	BEQ FILAST		;If zero, don't bother.
	JSR PC, FILSTRIP	;Do the first partial word loop.
	CLR TVMSK		;Prepare to write a full word.	
FILWLUP:
	JSR PC, FILSTRIP
	SOB B, FILWLUP
FILAST:	REST TVMSK		;Falls through to do last partial word strip.
FILSTRIP:			;Fills a vertical strip of the area.
	MOV F, TVRADR		;#WORLIN in TVINCR, Address in F, Number of lines in D
	MOV D, A		;WINDATA in E, mask in TVMSK, clobbers A.
FILUP:	MOV E, TVRWIN
	SOB A, FILUP
	TST (F)+		;F now points to first word in next column.
	RTS PC


CLEPAL:				;[CLEAR-PALETTE]
	MOV #PALETTE, A
	MOV ERANUM, B
	MOV ERANUM, C
	SUB PENNUM, C		;(SETQ C (- :ERASERNUMBER :PENNUMBER))
PALUP:	CMP B, C		;If we're currently working on pencolor slot, skip it.
	BEQ NILPAL
	MOV #LIST, (A)		;Fill slots 0 thru :ERASERNUMBER-1 with NILs
NILPAL:	TST (A)+
	SOB B, PALUP		;except for slot :PENNUMBER.
	RTS PC

OUTLINE:			;Draw box outlineing display area.
	SAVE TVSIZX
	INC (P)
	SAVE TVSIZY
	INC (P)
	SAVE TVLEFT
	DEC (P)
	MOV TVTOP, A		;Remember, silly DRAW routine wants arguments
	DEC A
	MOV (P), B		;Y start, X start, delta Y, delta X.
	CLR C
	MOV 4 (P), D		;(1+ TVSIZX)
	JSR PC, DRAW		;Top line.
	MOV TVBOT, A
	INC A
	MOV (P), B		
	CLR C
	MOV 4 (P), D		;(1+ TVSIZX)
	JSR PC, DRAW		;Bottom line.
	MOV TVTOP, A
	MOV (P), B		;(1+ TVLEFT)
	MOV 2 (P), C		;(1+ TVSIZY)
	CLR D
	JSR PC, DRAW		;Left side.
	MOV TVTOP, A
	MOV TVRIGHT, B
	INC B
	MOV 2 (P), C
	CLR D
	ADD #6, P		;Pop three temporaries off stack.
	JMP DRAW		;Right side.
	
;TVWCBW:				;Black and white version.
;	SAVE <TVLEFT,#0,DISCAP>
;	BIS #.TVDSS*400,(P)	;SET THE TV DRAWER TO TOP LEFT OF DISPLAY
;	$INVOK
;	SAVE <TVSIZX,TVSIZE,DISCAP>
;	BIS #.TVDSC*400,(P)	;CLEAR THE AREA OF DISPLAY
;	$INVOK			;THIS LEAVES DRAWER AT BOTTOM RIGHT
;	SAVE <TVLEFT,TVTOP,DISCAP>
;	BIS #.TVDSS*400,(P)	;SET THE CURSOR TO TOP LEFT
;	$INVOK
;	SAVE <TVSIZX,#0,DISCAP>	;X WIDTH OF SCREEN, NO DELTA Y
;	BIS #.TVDSI*400,(P)	;DRAW THE TOP LINE
;	$INVOK
;	SAVE <#0,TVSIZY,DISCAP>	;NO DELTA X, SCREEN HEIGHT IS DELTA Y
;	BIS #.TVDSI*400,(P)	;DRAW THE RIGHT SIDE
;	$INVOK
;	SAVE TVSIZX		;X WIDTH OF SCREEN
;	NEG (P)			;TO GO BACK
;	SAVE <#0,DISCAP>	;NO DELTA Y
;	BIS #.TVDSI*400,(P)	;DRAW THE BOTTOM LINE
;	$INVOK
;	SAVE <#0,TVSIZY>	;NO DELTA X, THE SCREEN HEIGHT AS DELTA Y
;	NEG (P)			;TO GO UP THE SCREEN
;	SAVE DISCAP
;	BIS #.TVDSI*400,(P)	;DRAW THE LEFT SIDE
;	$INVOK
;
;	SAVE <TVX,TVY,DISCAP>
;	BIS #.TVDSS*400,(P)	;RESET THE DRAWER TO ITS OLD POSITION
;	$INVOK



	;TURTLESIZE ROUTINE
TRSIZE:	JSR PC,TVTEST	;ON TV?
	JSR PC,G1NARG
	MOV B,TRMIN
	JSR PC,REINIT
	SEZ
	RTS PC

	;TVSIZE ROUTINE
RESIZE:	JSR PC,TVTEST
	JSR PC,DCHK
	MOV D,A
	CMP A,#2.		;CHECK THE NUMBER OF ARGS.
	BEQ SIZ2ARG
	BGT SIZWNA
	CMP A,#1.		;POPOFF NUMBER OF ARGS.
	BEQ SIZ1ARG			;IF ONE ARG.
SIZWNA:	ERROR+WNA		;ERROR-WRONG NUMBER OF ARGS.
SIZ2ARG:
	JSR PC,G2NARG		;GET TWO ARGS. X IN B Y IN
;	JSR PC,CHSIZE		;CHECK SIZE OF Y ARG. (IN A)

	CMP B, #TVXSMN		;Check reasonableness of TVSIZE args.
	BLT XSIZER
	CMP B, #TVXSMX
	BGT XSIZER
	CMP A, #TVYSMN
	BLT YSIZER
	CMP A, #TVYSMX
	BLE OKSIZE
YSIZER:	MOV A,B
XSIZER:	JSR PC,R1NARG
	ERROR + WTA
OKSIZE:	EXCH A, B		;Exch A, B. Rest of code wants this. Change this? 

	MOV B,-(SP)		;STORE B

;	MOV A,B
;	JSR PC,CHSIZE		;CHECK SIZE OF X ARG. NOW COPIED IN B

	MOV (SP)+,B		;RESTORE B
	CMP A,B			;WHICH IS SMALLER AND PUT IT INTO
	BGT SIZMIN		;TVMIN
	MOV A,TVMIN
	BR SIZRST
SIZ1ARG:
	JSR PC,G1NARG		;GET 1 ARG. (X DIMENSION=Y DIMENSION)
	MOV B,A			;COPY DIMENSION
;	JSR PC,CHSIZE		;CHECK SIZE OF ARG.
	CMP A, #TVYSMN
	BLT YSIZER
	CMP A, #TVYSMX
	BGT YSIZER
SIZMIN:	MOV B,TVMIN
SIZRST:	MOV A,TVSIZX		;RESET PARAMETERS
	MOV B,TVSIZY
	MOV B,TVBOT
	ADD TVTOP,TVBOT		;NEW TV BOTTOM OF DISPLAY AREA
	MOV TVRIGH,TVLEFT	;NEW TVLEFT=TVRIGHT-TVSIZE X
	SUB A,TVLEFT
	SETI
	SETF
	LDCIF A,FA
	LDCIF B,FB		;STORE FOR USE LATER A,B
	ASR A			;TV CENTER X=(TVSIZE X/2)+TVLEFT
	ADD TVLEFT,A
	MOV A,TVCENX
	ASR B			;LIKEWISE FOR Y
	ADD TVTOP,B
	MOV B,TVCENY
	LDCIF TVMIN,FC		;TURTLE SCALE FACTOR X!Y=
	DIVF FC,FA		;TV SIZE X!Y/TVMIN
	STF FA,TRSCLX
	DIVF FC,FB
	STF FB,TRSCLY
	JSR PC,REINIT
	MOV TVBOT,B
	JSR PC,CRECHO
	JSR PC,TVCS
	SEZ
	RTS PC



TVSHOW:	BIC #HIDETF, DFLAGS	;The turtle now not hidden.
	JMP DTVTUR
TVSHO1:	SEZ
	RTS PC

TVHIDE:	JSR PC, ETVTUR		;Remove the turtle cursor from the screen.
	BIS #HIDETF, DFLAGS	;Mark the turtle as being hidden.
TVHID1:	SEZ
	RTS PC


SEETURTLE:			;Returns TRUE if in SHOWTURTLE mode, FALSE in HIDETURTLE
	BIT #HIDETF, DFLAGS
	BNE SEERTF		;HIDETF bit in DFLAGS indicates whether turtle is hidden
	JMP RTTRUE
SEERTF:	JMP RTFALSE




.IFNZ TVS
DTVTUR:				;[DRAW-TURTLE]
	BIT #HIDETF, DFLAGS	;If turtle hidden, forget about it.
	BNE DTUREND
DTURST:
	BIT #CLIPF, DFLAGS	;In CLIP mode, if HERE is out of bounds, forget it.
	BEQ DTNCLP
	LDF DCURX, FA
	LDF DCURY, FB
	JSR PC, CLPVIS
	TST A
	BNE DTUREND
DTNCLP:	
.IFNZ COLOR
	BIT #COLORF, DFLAGS	
	BNE DTVCLR
.ENDC
	SAVE <TVSEL, WINDATA>
	JSR PC, XORMODE		;and draw triangle in XOR mode.
	BR DTRIAN

.IFNZ COLOR
DTVCLR:	JSR PC, SELPEN		;In color, (SELECT-COLOR :PENNUMBER)
.ENDC

DTRIAN:	JSR PC, TRIANG
.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ DTURBW		;In color, restore selected color.
	JMP RESELC
.ENDC

DTURBW:	REST <WINDATA, TVSEL>
				;In black and white, restore drawmode and flags.
DTUREN:	SEZ			;Frequently want to return no-value at this point.
	RTS PC

ETVTUR:				;[ERASE-TURTLE]
	BIT #HIDETF, DFLAGS
	BNE ETUREND
ETURST:
	BIT #CLIPF, DFLAGS	;In CLIP mode, if HERE is out of bounds, forget it.
	BEQ ETNCLP
	LDF DCURX, FA
	LDF DCURY, FB
	JSR PC, CLPVIS
	TST A
	BNE ETUREND
ETNCLP:	

.IFNZ COLOR
	BIT #COLORF, DFLAGS	
	BNE ETVCLR
.ENDC
	SAVE <TVSEL, WINDATA>
	JSR PC, XORMODE
	BR ETRIAN

.IFNZ COLOR
ETVCLR:	JSR PC, SELERA
.ENDC

ETRIAN:	JSR PC, TRIANG

.IFNZ COLOR
	BIT #COLORF, DFLAGS
	BEQ ETURBW
	JMP RESELC
.ENDC

ETURBW:	REST <WINDATA, TVSEL>
ETUREN:	RTS PC
.ENDC


TRIANG:	SETF
	SETI			;THE FOLLOWING STUFF IS DONE IN SHORT, FLOAT MODE
	LDF DCURX,FA
	LDF DCURY,FB		;LOAD UP CURRENT X AND Y
	LDF TRFRAD,FC		;TURTLE FRONT RADIUS
	STF FC,FD		;COPY THE RADIUS
	MULF DSINA,FC		;FONT LINE X IS FRONT RADIUS * SIN A
	MULF DCOSA,FD		;FONT LINE Y IS FRONT RADIUS * COS A
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE THIS POINT LESS RELATIVE
	JSR PC,WRPVEC		;DRAW AS WRAP VECTOR
	STF FC,-(P)		;SAVE THIS POINT
	STF FD,-(P)
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF TRSRAD,FC		;TURTLE SIDE RADIUS
	STF FC,-(P)		;SAVE IT ON STACK
	LDF DSINA,FD
	MULF SIN120,FD
	STF FD,-(P)
	LDF DCOSA,FD
	MULF COS120,FD
	ADDF (P)+,FD		;Y = SIN A * SIN 120 + COS A * COS 120
	MULF (P),FD		;Y = TURTLE SIDE RADIUS * Y
	LDF DCOSA,FC
	MULF SIN120,FC
	STF FC,-(P)
	LDF DSINA,FC
	MULF COS120,FC
	SUBF (P)+,FC		;X = SIN A * COS 120 - COS A * SIN 120
	MULF (P),FC		;X = TURTLE SIDE RADIUS * X
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE LESS RELATIVE
	JSR PC,WRPVEC		;DRAW THE RIGHT SIDE OF TURTLE
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF DSINA,FD
	MULF SIN240,FD
	STF FD,-(P)
	LDF DCOSA,FD
	MULF COS240,FD
	ADDF (P)+,FD		;Y = COS A * COS 240 + SIN A * SIN 240
	MULF (P),FD		;Y = TURTLE SIDE RADIUS * Y
	LDF DCOSA,FC
	MULF SIN240,FC
	STF FC,-(P)
	LDF DSINA,FC
	MULF COS240,FC
	SUBF (P)+,FC		;X = SIN A * COS 240 - COS A * SIN 240
	MULF (P)+,FC		;X = TURTLE SIDE RADIUS * X
	ADDF DCURX,FC
	ADDF DCURY,FD		;MAKE LESS RELATIVE
	JSR PC,WRPVEC		;DRAW THE BOTTOM OF TURTLE
	STF FC,FA		;BECOMES THE FROM X
	STF FD,FB		;BECOMES THE FROM Y
	LDF (P)+,FD		;Y FROM FRONT LINE
	LDF (P)+,FC		;X FROM FRONT LINE
	JSR PC,WRPVEC		;DRAW THE LEFT SIDE OF THE TURTLE
	RTS PC


;VECTOR DRAW LINES ON THE SCREEN. IT EXPECTS:
;FROM X IN FA
;FROM Y IN FB
;TO X IN FC
;TO Y IN FD

VECTOR:	SETF			;ALL THE FOLLOWING STUFF IS IN FLOAT MODE
	SETI			;AND IN SHORT INTEGER MODE
	STF FC, -(P)		;Save TO point over vector drawing.
	STF FD, -(P)
	BIT #<WRAPF!CLIPF>,DFLAGS	;CHECK THE BOUNDS, IF WRAPPING OR
	BNE 2$			;CLIPPING, NO CHECKING IS NEEDED
	JSR PC,TRBOUN
2$:	BIT #HIDETF,DFLAGS	;ARE WE SHOWING THE TURTLE?
	BNE VECTO1		;NO
	JSR F,FACSAV		;SAVE THE REGISTERS
	JSR PC, ETURST		;THIS CAUSES IT TO GO AWAY
	JSR F,FACRES		;RESTORE THE REGISTERS
VECTO1:	BIT #PENUF, DFLAGS	;Check state of pen, etc., decide whether to draw line.
	BEQ VECTDR		;Pendown, draw the line.
	BIT #<XORF!ERASEF>, DFLAGS
	BEQ VECTO3		;Pen, eraser, xor up, skip drawing the line.
VECTDR:	BIT #WRAPF,DFLAGS	;ARE WE IN WRAP MODE?
	BNE VECTO2		;YES

	BIT #CLIPF,DFLAGS	;CLIP MODE?
	BEQ VECTO5		;NO
	JSR PC, CLPVEC
	BR VECTO3
VECTO5:	JSR PC,BNDVEC		;NO DRAW A BOUNDED VECTOR
	BR VECTO3
VECTO2:	JSR PC,WRPVEC		;YES DRAW VECTORS WITH WRAPAROUND
VECTO3:	LDF (P)+, FD
	LDF (P)+, FC
	STF FC,DCURX
	STF FD,DCURY		;THE NEW CURRENT POSITION
	JMP DTVTUR		;PUT THE TURTLE IN ITS NEW HOME
VECTO4:	SEZ
	RTS PC

TVBOUN:	CMP C,TVLEFT
	BLT OUTOFB
	CMP C,TVRIGH
	BGT OUTOFB
	CMP D,TVTOP
	BLT OUTOFB
	CMP D,TVBOT
	BGT OUTOFB
	RTS PC
TRBOUN:				;CHECKS BOUNDRIES FOR TVRTLE
	CMPF TRLEFT,FC
	CFCC
	BGT 1$
	CMPF TRRIGH,FC
	CFCC
	BLT 1$
	CMPF TRTOP,FD
	CFCC
	BLT 1$
	CMPF TRBOT,FD
	CFCC
	BGT 1$
	RTS PC
1$:
OUTOFB:	ERROR+OOB

;Old "clipping" code. To be flushed.
OCLIP:	CMPF TRLEFT,FC		;THIS CODE WHEN IN CLIP MODE 
	CFCC			;CHECKS THE BOUNDS OF THE
	BLE 3$			;VECTOR AND IF THE VECTOR RUNS
	LDF TRLEFT,FC		;OUT OF BOUNDS IT IS CLIPPED BY
3$:	CMPF TRRIGH,FC		;PLACING THE TURTLE COORDINATE OF
	CFCC			;THAT EDGE INTO THE APPROPRIATE
	BGE 4$			;PARAMETER
	LDF TRRIGH,FC
4$:	CMPF TRTOP,FD
	CFCC
	BGE 5$
	LDF TRTOP,FD
5$:	CMPF TRBOT,FD
	CFCC
	BLE VECTO5
	LDF TRBOT,FD
	BR VECTO5



;Code for vectors in CLIP mode. Follows clip algorithm in Newman & Sproull.

;Following routine returns a VISIBILITY number in A 0-15 indicating 
;whether point is outside display area in X and/or Y. Coordinates of point in FA 
;and FB.

CLPVIS:					;[CLIP-VISIBILITY]
	CLR A				
	CMPF TRLEFT, FA			;Compare with left edge, outside if X less.
	CFCC				
	BLE CPVSRT			
	INC A
	BR CPVSBT
CPVSRT:	CMPF TRRIGHT, FA		;Compare against right, outside if X greater.
	CFCC
	BGE CPVSBT
	TST (A)+			;Increment A by 2.
CPVSBT:	CMPF TRBOT, FB			;Outside if Y < bottom edge in turtle coords.
	CFCC
	BLE CPVSTP
	ADD #4., A
	RTS PC
CPVSTP:	CMPF TRTOP, FB			;Outside if Y > top edge.
	CFCC
	BGE CPVSEND
	ADD #8., A
CPVSEND:
	RTS PC


;Vector clipping routine. FROM-X in FA, FROM-Y in FB, TO-X in FC, TO-Y in FD.


CLPVEC:					;[CLIP-VECTOR]
	STF FA, -(P)
	STF FB, -(P)			;Save FROM point.
	JSR PC, CLPVIS			;Compute visibility of FROM point.
	SAVE A
	LDF FC, FA
	LDF FD, FB
	JSR PC, CLPVIS			;Compute visibility of TO point.
	MOV A, B
	REST A
	LDF (P)+, FB
	LDF (P)+, FA			;FROM-VISIBILITY in A, TO-VISIBILITY in B.
CLPVS:					;[CLIP-VECTOR-VISIBILITY]
	MOV A, C
	ADD B, C			;If both points are inside display area
	BNE CLPOUT			;hand off to BOUNDED-VECTOR.
	JMP BNDVEC
CLPOUT:	
	BIT A, B			;If both points are outside X or both
	BEQ CLPDRW			;outside Y whole vector is invisible.
	RTS PC
CLPDRW:
	TST A				;Exchange points if necessary so that
	BNE CLPNSW			;TO point is visible.
	STF FA, -(P)
	LDF FC, FA
	LDF (P)+, FC
	STF FB, -(P)
	LDF FD, FB
	LDF (P)+, FD
	EXCH A, B			
CLPNSW:
	BIT #1., A			;Push towards left edge.
	BEQ CLPRT
	STF FB, -(P)
	STF FA, -(P)			
	SUBF FC, FA					  
	SUBF FD, FB
	DIVF FA, FB
	LDF TRLEFT, FA
	SUBF (P)+, FA
	MULF FA, FB
	ADDF (P)+, FB
	LDF TRLEFT, FA
CLPRT:	BIT #2., A				;Push toward right edge.
	BEQ CLPTP
	STF FB, -(P)
	STF FA, -(P)
	SUBF FC, FA
	SUBF FD, FB
	DIVF FA, FB
	LDF TRRIGHT, FA
	SUBF (P)+, FA
	MULF FA, FB
	ADDF (P)+, FB
	LDF TRRIGHT, FA
;FALLS THROUGH
;FALLS IN
CLPTP:	BIT #4., A				;Push toward top.
	BEQ CLPBT
	STF FA, -(P)
	STF FB, -(P)
	SUBF FC, FA
	SUBF FD, FB
	DIVF FB, FA
	LDF TRBOT, FB
	SUBF (P)+, FB
	MULF FB, FA
	ADDF (P)+, FA
	LDF TRBOT, FB
CLPBT:	BIT #8., A				;Push toward bottom.
	BEQ CLPNVS
	STF FA, -(P)
	STF FB, -(P)
	SUBF FC, FA
	SUBF FD, FB
	DIVF FB, FA
	LDF TRTOP, FB
	SUBF (P)+, FB
	MULF FB, FA
	ADDF (P)+, FA
	LDF TRTOP, FB
CLPNVS:	JSR PC, CLPVIS				;Recompute visibility for FROM point.
	BR CLPVS



;WRPVEC DRAWS VECTORS WITH WRAP AROUND BY SPLITTING THE LINES IN THE VARIOUS
;SCREENS THAT IT CROSSES, AND CALLING BNDVEC TO ACTUALLY DRAW THE LINES ON
;EACH OF THE VIRTUAL SCREENS.  THE SCREEN SPLITTING IS DONE BY CHOPPING OFF
;PIECES OF THE LINE AND CALLING WRPVEC RECURSIVELY.  THIS PROCEDURE IS
;ESSENTIALLY A HAND COMPILATION OF THE PROCEEDURE WRAP-VECTOR IN HENRY
;LIEBERMAN'S TVRTLE, A PART OF LISP LOGO

WRPVEC:	JSR F,FACSAV		;SAVE ALL THE REGISTERS
	STF FA,FE
	SUBF TRLEFT,FA
	DIVF TRSIZX,FA
	TSTF FA
	CFCC
	BGE 1$
	SUBF #40200,FA		;-0.1 SHOULD TRUNCATE TO -1 NOT 0
1$:	STCFI FA,A		;FROM-SCREEN-X=(FROM-X - TR-PIC-LEFT)/ TR-PICT-SIZE
	LDF FE,FA
	STF FC,FE
	SUBF TRLEFT,FC
	DIVF TRSIZX,FC
	TSTF FC
	CFCC
	BGE 2$
	SUBF #40200,FC
2$:	STCFI FC,C		;TO-SCREEN-X=(TO-X - TR-PICT-LEFT)/ TR-PICT-SIZE
	LDF FE,FC
	CMP A,C			;FROM-SCREEN-X = TO-SCREEN-X ?
	BEQ WRPVE2		;YES
	STF FC,-(P)
	STF FD,-(P)		;GET SOME REGISTERS
	SUBF FA,FC		;CHANGE-X = TO-X - FROM-X
	SUBF FB,FD		;CHANGE-Y = TO-Y - FROM-Y
	TSTF FC
	CFCC
	BGE WRPVE1
	MOV #-1,E
	BR .+6
WRPVE1:	MOV #1,E		;IF CHANGE-X >= 0 THEN SIGN-X = 1 ELSE SIGN-X = -1
	DIVF FC,FD
	STF FD,FE		;TAN-HEADING = CHANGE-Y / CHANGE-X
	LDCIF A,FC		;FROM-SCREEN-X
	MULF TRSIZX,FC
	ADDF TRLEFT,FC		;TO-EDGE-X=TR-PIC-SIZE-X*FROM-SCREEN-X + TR-PICT-LEFT
	TST E
	BLT 1$			;IF SIGN-X >= 0
	ADDF TRSIZX,FC		;	THEN ADD TURTLE-PICT-SIZE-X TO TO-EDGE-X
1$:	LDF FC,FD
	SUBF FA,FD
	MULF FE,FD
	ADDF FB,FD		;TO-EDGE-Y=(TO-EDGE-X - FROM-X)*TAN-HEADING + FROM-Y
	STF FC,FE
	LDCIF E,FC
	ADDF FPC0.1,FC
	STF FC,FF		;BACK-OFF-EDGE = SIGN X + 0.1
	LDF FE,FC
	SUBF FF,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	FROM-X
				;		FROM-Y
				;		TO-EDGE-X - BACK-OFF-EDGE
				;		TO-EDGE-Y)
	LDF FE,FA
	ADDF FF,FA
	LDF FD,FB
	LDF (P)+,FD
	LDF (P)+,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	TO-EDGE-X + BACK-OFF-EDGE
				;		TO-EDGE-Y
				;		TO-X
				;		TO-Y)
	JSR F,FACRES
	RTS PC

WRPVE2:	STF FB,FE
	SUBF TRBOT,FB
	DIVF TRSIZY,FB
	TSTF FB
	CFCC
	BGE 1$
	SUBF #40200,FB		;TO MAKE -0.1 TRUNCATE TO -1
1$:	STCFI FB,B		;FROM-SCREEN-Y=(FROM-Y - TR-PICT-BOTTOM) / TR-SIZE-Y
	LDF FE,FB
	STF FD,FE
	SUBF TRBOT,FD
	DIVF TRSIZY,FD
	TSTF FD
	CFCC
	BGE 2$
	SUBF #40200,FD		;TO MAKE -0.1 TRUNCATE TO -1
2$:	STCFI FD,D		;TO-SCREEN-Y=(TO-Y - TR-PICT-BOTTOM) / TR-SIZE-Y
	LDF FE,FD
	CMP B,D			;FROM-SCREEN-Y = TO-SCREEN-Y ?
	
	BEQ WRPVE4		;YES
	STF FC,-(P)
	STF FD,-(P)		;GET SOME REGISTERS
	SUBF FA,FC		;CHANGE-X = TO-X - FROM-X
	SUBF FB,FD		;CHANGE-Y = TO-Y - FROM-Y
	TSTF FD
	CFCC
	BGE WRPVE3		;IF CHANGE-Y < 0
	MOV #-1,E		;	THEN SIGN-Y = -1
	BR .+6
WRPVE3:	MOV #1,E		;	ELSE SIGN-Y = 1
	DIVF FD,FC
	STF FC,FE		;TAN-HEADING = CHANGE-X / CHANGE-Y
	LDCIF B,FD
	MULF TRSIZY,FD
	ADDF TRBOT,FD		;TO-EDGE-Y=FROM-SCREEN-Y * TR-PICT-SIZE-Y + TR-PICT-BOT
	TST E
	BLT .+6			;IF SIGN-Y >= 0
	ADDF TRSIZY,FD		;	THEN TO-EDGE-Y = TO-EDGE-Y + TR-SIZE-Y
	LDF FD,FC
	SUBF FB,FC
	MULF FE,FC
	ADDF FA,FC		;TO-EDGE-X=TAN-HEADING*(TO-EDGE-Y - FROM-Y)+FROM-X
	STF FD,FE
	LDCIF E,FD
	MULF FPC0.1,FD
	STF FD,FF		;BACK-OFF-EDGE = SIGN-Y * 0.1
	LDF FE,FD
	SUBF FF,FD
	JSR PC,WRPVEC		;(WRAP-VECTOR	FROM-X
				;		FROM-Y
				;		TO-EDGE-X
				;		TO-EDGE-Y - BACK-OFF-EDGE)
	LDF FC,FA
	LDF FE,FB
	ADDF FF,FB
	LDF (P)+,FD
	LDF (P)+,FC
	JSR PC,WRPVEC		;(WRAP-VECTOR	TO-EDGE-X
				;		TO-EDGE-Y + BACK-OFF-EDGE
				;		TO-X
				;		TO-Y)
	JSR F,FACRES
	RTS PC

;NOW BOTH FROM X, TO X AND FROM Y, TO Y ARE ALL ON THE SAME SCREEN.
;WE MUST CONVERT THAT SCREEN TO OVERLAY THE CENTER SCREEN BY A
;MODULO TYPE OPERATION.

WRPVE4:	STF FB,-(P)
	SUBF TRLEFT,FA
	DIVF TRSIZX,FA
	MODF #40200,FA		;MUL BY 1, FRACTION IN FA, INTEGER IN FB
	TSTF FA
	CFCC
	BGE 1$
	ADDF #40200,FA		;SO NEGATIVE VALUES WRAP PROPERLY
1$:	MULF TRSIZX,FA
	ADDF TRLEFT,FA		;SHIFT FROM X TO THIS SCREEN
	LDF (P)+,FB
	SUBF TRBOT,FB
	DIVF TRSIZY,FB
	MODF #40200,FB		;MUL BY 1 TO GET FRACTION IN FB
	TSTF FB
	CFCC
	BGE 2$
	ADDF #40200,FB		;SO NEGATIVE VALUES WRAP PROPERLY
2$:	MULF TRSIZY,FB
	ADDF TRBOT,FB		;SHIFT FROM Y TO THIS SCREEN
	STF FD,-(P)
	SUBF TRLEFT,FC
	DIVF TRSIZX,FC
	MODF #40200,FC		;#1 IN FLOATING
	TSTF FC
	CFCC
	BGE 3$
	ADDF #40200,FC		;SO NEGATIVE VALUES WRAP PROPERLY
3$:	MULF TRSIZX,FC
	ADDF TRLEFT,FC		;SHIFT TO X TO THIS SCREEN
	LDF (P)+,FD
	SUBF TRBOT,FD
	DIVF TRSIZY,FD
	MODF #40200,FD		;#1 IN FLOATING
	TSTF FD
	CFCC
	BGE 4$
	ADDF #40200,FD		;SO NEGATIVE VALUES WRAP PROPERLY
4$:	MULF TRSIZY,FD
	ADDF TRBOT,FD		;SHIFT TO Y TO THIS SCREEN
	JSR PC,BNDVEC		;(BOUNDED-VECTOR FROM-X FROM-Y TO-X TO-Y)
	JSR F,FACRES
	RTS PC

;BNDVEC IS THE EQUIVALENT OF HENRY'S BOUNDED-VECTOR. IT IS USED TO DRAW A
;LINE ON THE SCREEN WITHOUT CONSIDERING WRAP AROUND.  THIS PROGRAM ASSUMES
;THAT THE LINE IS WITHIN BOUNDS.

BNDVEC:	JSR F,FACSAV		;SAVE THE REGISTERS
	JSR PC,TVSCAL		;CONVERT FROM TURTLE COORDINATES TO TV COORDS
;	JSR PC,ROUND		;ROUND FA AND FB TO NEAREST INTEGER
	STCFI FA, B
	STCFI FB, A
	LDF FC,FA
	LDF FD,FB
	JSR PC,TVSCAL		;CONVERT FROM TURTLE COORDINATES TO TV COORDS
;	JSR PC,ROUND		;ROUND TO NEAREST INTEGER
	STCFI FA, D
	STCFI FB, C
;	CMP A,TVX		;SEE IF WE SHOULD MOVE THE DRAWER
;	BNE BNDVE1		;YES
;	CMP B,TVY
;	BEQ BNDVE2
BNDVE1:	
;	SAVE <A,B,DISCAP>
;	BIS #.TVDSS*400,(P)	;SET THE DRAWER TO FROM-X AND FROM-Y
;	$INVOK
BNDVE2:	MOV D, TVX
	MOV C, TVY		;TO-X AND TO-Y BECOME CURRENT TV DRAWER COORDS
	SUB A,C
	SUB B,D			;TO GET DELTA-X AND DELTA-Y
;	SAVE <C,D,DISCAP>
;	BISB DRAWMD,1(P)	;SET THE MODE OF THE LINE
;	$INVOK

	JSR PC, DRAW		;Draw the line.

	JSR F,FACRES		;RESTORE THE REGISTERS
	RTS PC

;LINE DRAWER FOR TV'S
;EXPECTS:
;A - STARTING Y POSITION 0-473
;B - STARTING X POSITION 0-575
;C - DELTA Y
;D - DELTA X

DRAW:	
	TST D			;DO WE HAVE A NEGATIVE DELTA X
	BGE DRAW5		;NO
	ADD C,A
	ADD D,B
	NEG C
	NEG D			;REVERSE THE DIRECTION THE LINE IS DRAWN
DRAW5:	JSR PC, ADRMSK		;GET THE BYTE ADDRESS IN B, X MOD 16 IN A
	SAVE B			;THIS WILL GO INTO TVRADR
	MOV A, E		;BIT MASK IN E.
	TST C			;IS DELTA Y POSITIVE?
	BGE DRAW4		;YES
	MOV #-BYTLINE, A	;THE Y STEP IS ONE LINE UP THE SCREEN
	NEG C			;TO MAKE DELTA Y POSITIVE
	BR .+6
DRAW4:	MOV #BYTLINE, A		;THE Y STEP IS ONE LINE DOWN THE SCREEN
	CLR B			;THIS WILL BE FLAG FOR HORIZONTAL OR VERTICAL
	CMP C,D			;IS DELTA Y GREATER THAN DELTA X
	BGE DRAW1		;YES
	SAVE D			;SINCE D > C, D WILL BE DIVISOR
	MOV C,D			;C WILL BE THE DIVIDEND
	BR DRAW3
DRAW1:	SAVE C			;SINCE C > D, C WILL BE DIVISOR
	TST (B)+		;DRAW A VERTICAL LINE
DRAW3:	CLR C			;FOR THE DIVIDE
	ASHC #14.,C		;SO WE GET A FRACTIONAL RESULT
	DIV (P),C		;GET A QUOTIENT IN C
	MOV #40000,D		;ADD TO THIS NUMBER TO GET A CARRY
	REST F			;THE NUMBER OF STEPS WE WILL MOVE
	INC F			;SO WE SHOW THE INITIAL POINT
	BIC #TVINC, TVINCR	;INCREMENT 0
	MOV (P), TVRADR		;Set up the address [on top of stack].
	REST			;Pop one remaining arg.
	JMP @DRAWTB(B)		;DRAW EITHER A HORIZONTAL OR VERTICAL LINE




DRAWH:
	MOV WINDATA, B
DRHLUP:	
	MOV E, TVMSK		;Complement of point mask in TVMSK.
	MOV B, TVRWIN		;Write bits from B.
	ADD C,D			;ADD INCREMENT UNTIL WE OVERFLOW TO NEGATIVE
	BVC DRAWH1
	BIC #100000,D		;GO BACK TO A POSITIVE NUMBER
	BIS #40000,D		;SO WE WILL OVERFLOW AT THE RIGHT PLACE
	ADD A,TVRADR		;IF WE DID, THEN GO UP OR DOWN ONE LINE
DRAWH1:	SEC			;IN CASE PREVIOUS OP CAUSES CARRY
	ROR E			;SHIFT THE BIT RIGHT ONE POSITION
	BCS DRAWH2		;WE DID NOT OVERFLOW
	ROR E			;MOVE CARRY INTO BIT 15
	ADD #2,TVRADR		;ADVANCE TO NEXT WORD
DRAWH2:	SOB F,DRHLUP		;DRAW A MORE HORIZONTAL LINE
	RTS PC

DRAWV:
	MOV WINDATA, B
DRVLUP:
	MOV E, TVMSK
	MOV B, TVRWIN
	ADD C,D			;ADD INCREMENT UNTIL WE OVERFLOW
	BVC DRAWV1
	BIC #100000,D		;GO BACK TO POSITIVE
	BIS #40000,D		;SO WE WILL OVERFLOW AGAIN AT RIGHT PLACE
	SEC
	ROR E			;MOVE THE BIT RIGHT ONE POSITION
	BCS DRAWV1		;NO OVERFLOW
	ROR E			;MOVE BIT FROM CARRY INTO BIT 15
	ADD #2,TVRADR		;NOW DOING THE NEXT WORD
DRAWV1:	ADD A,TVRADR		;ADD THE Y INCREMENT TO THE TV ADDRESS
	SOB F, DRVLUP		;LOOP UNTIL WE FINISH DRAWING THE LINE
	RTS PC

;GETADR USES THE Y POSITION IN A AND THE X POSITION IN B TO GIVE A BYTE ADDRESS
;IN B AND MASK TO THE APPROPRIATE BIT IN A.

ADRMSK:	JSR PC, GETADR
	ASL A
	MOV POIMSK (A), A
	RTS PC


GETADR:	SAVE C			;NEED A REGISTER
	MOV B,C			;PUT X POSITION IN C
	MUL #BYTLINE, A		;ADDRESS OF THE START OF THE LINE
	MOV C,A			;PUT X BACK, THE HIGH ORDER OF MUL SHOULD BE ZERO
	ASH #-4,C		;GET WORD FROM START OF LINE
	ASL C			;BYTE
	ADD C,B			;GET THE FINAL BYTE ADDRESS
	BIC #177760,A		;GET X MOD 16 IN A
	REST C
	RTS PC
	


;CONVERT FROM TURTLE COORDINATES TO TV COORDINATES
TVSCAL:	SUBF TRLEFT,FA
	DIVF TRPRTV,FA
	STF FA,-(P)
	LDCIF TVLEFT,FA
	ADDF (P)+,FA		;X = (X - TR-PICTURE-LEFT)/TURTLE-PER-TV + TV-PICT-LEFT
	SUBF TRBOT,FB
	DIVF TRPRTV,FB		;THIS GIVES THE NUMBER OF TV STEPS FROM TOP OF DISPLAY
	STF FB,-(P)		;  AND SINCE TV LINES INCREASE DOWN THE SCREEN:
	LDCIF TVBOT,FB		
	SUBF (P)+,FB		;Y = TV-PICT-BOTTOM - (Y - TR-PICT-BOTTOM)/TR-PER-TV
;	RTS PC
	JMP ROUND

;TVHEAD IS USED TO SET THE TURTLE TO THE APPROPRIATE HEADING.
;EXPECTS THE NEW HEADING IN B
TVHEAD:	JSR PC, ETVTUR		;Erase the turtle if it's being shown.
TVHEA2:	MOV B,DCURA		;THIS BECOMES THE CURRENT ANGLE
	SETI
	SETD
	LDCIF B,FA
	STF FA,-(P)
	JSR PC,SINDEG		;GET DSIN A
	STCDF FA,DSINA
	LDF (P)+,FA
	JSR PC,COSDEG		;GET DCOS A
	STCDF FA,DCOSA
	JMP DTVTUR		;Show the turtle at its new location.
TVHEA1:	SEZ
	RTS PC




;Point hacking routines.

POINT:
	MOV D,A
	JSR PC, PHACK		;Argument handling routine for POINT and POINTSTATE.
	BIT #HIDETF, DFLAGS
	BNE POIHT
	SAVE <C, D>
	JSR PC, ETURST		;Erase the tutle if it's being shown.
	REST <D, C>
POIHT:	MOV D, TVRADR		;Address comes back in D, bit mask in C
	MOV C, TVMSK		;Mask register gets word with relevant bit off.
	MOV WINDATA, TVRWIN	;which gets written into memory data register.
	JMP DTVTUR

POINTSTATE:			
	MOV D,A
	JSR PC, PSHACK
	BIT #HIDETF, DFLAGS
	BNE PSHT
	SAVE <C, D>
	JSR PC, ETURST
	REST <D, C>
PSHT:
	BIT #COLORF, DFLAGS	;Color or black-and-white? 
	BNE PSCOLOR	
PSBW:	MOV D, TVRADR		;Test to see if point masked by C is on in word at D.
	BIT C, TVRWIN
	BEQ PSRTFALSE
PSRTTRUE:			;Return true.
	JSR PC, DTVTUR
	JMP RTTRUE
PSRTFALSE: 
	JSR PC, DTVTUR
	JMP RTFALSE		;Return false.
PSCOLOR:			;Color version thereof.
	JSR PC, RTVPN		;Find number corresponding to point.
	CMP A, ERANUM		;Is the point on in the eraser color? 
	BEQ PSRTFALSE
	JSR PC, DTVTUR
	JMP RTTRUE


POINTCOLOR:			;Returns the color of a point.
	MOV D,A
	JSR PC, PSHACK
	BIT #HIDETF, DFLAGS
	BNE PCHT
	SAVE <C, D>
	JSR PC, ETURST
	REST <D, C>
PCHT:
	BIT #COLORF, DFLAGS	;As for POINT and POINTSTATE...
	BNE PCLRC 
	MOV PENNUM, A
PCLRBW:	MOV D, TVRADR
	BIT C, TVRWIN		;In black and white, for compatibility, return 
	BNE PCLRN		;either PEN or ERASER color.
	MOV ERANUM, A
	BR PCLRN
PCLRC:	JSR PC, RTVPN		;In color, get the point's color number from the screen.
PCLRN:	ASL A
	SPUSHS PALETTE (A)	;Index into palette to retrieve symbol for color.
	JSR PC, DTVTUR
	CLZ
	RTS PC
		
		
RTVPN:				;[READ-TV-POINT-NUMBER, sort of]
	JSR PC, NOCLRW		;Common routine for point hacking, takes address
	MOV NCBITS, F 		;of a word in D, Mask for a bit in C, reads the point
	CLR B			;and returns number of point's color in A. Color write
	MOV NCSIGB, E		;mode temporarily turned off.
	MOV D, TVRADR		;Word index into address register.
	MOV #DSNUM, D
RTVLUP:	MOV (D)+, A		;Grab number of buffer from DSNUM table.
	JSR PC, SELBUF		;Select buffer number in A [SELBUF doesn't clobber].
	BIT C, TVRWIN		;Read bit in that buffer.
	BNE RTVEND		;Bit is complemented, remember.
	ADD E, B		;Add to the point's total.
RTVEND:	ASR E			;Shift bit one place to the right.
	SOB F, RTVLUP
	JSR PC, CLRWRT		;Needn't save B, CLRWRT doesn't clobber.
 	RTS PC



PHACK:	;THIS IS A KLUDGE THAT DOES THE FIRST PART OF BOTH POINT AND POINTSTATE
	JSR PC,TVDEF		;FA GETS TVX FOR ROUTINE FB GETS TVY AND CHECKS BOUNDS
	STCFI FA, B		;ADRMSK takes X in B, Y in A, returns address of word 
	STCFI FB, A		;in B, mask to point in A.
	JSR PC, ADRMSK
	MOV A, C		;Shuffle registers [perhaps change this?].
	MOV B, D
	RTS PC

PSHACK:				;For POINT reading functions, return complemented mask.
	JSR PC, PHACK
	COM C
	RTS PC



TVARGE:	ERROR+WNA
TVDEF:	TST A
	BEQ TVDEF1		;ARGS NOT 
	CMP #2, A
	BNE TVARGE
	JSR PC, G2NARG		;GET ARGS, returns X in B, Y in A.
	SETF
	SETI
	LDCIF A, FB
	LDCIF B, FA
	LDF FA, FC
	LDF FB, FD
	BR TVDEF2
TVDEF1:	SETF
	SETI
	LDF DCURX, FA
	LDF DCURY, FB		;ARGS NOT SPECIFIED, use turtle's position.
TVDEF2:	JSR PC, TRBOUN
	JMP TVSCAL		;CONVERT TO TV COORDINATES



;ROUTINES FOR SAVING AND RESTORING FLOATING POINT REGISTERS
FACSAV:	PUSH E
	SAVE <D,C,B,A>
	STF FA,-(P)
	STF FB,-(P)
	STF FC,-(P)
	STF FD,-(P)
	STF FA,FACTMP		;TEMPORARY LOCATION
	LDF FE,FA
	STF FA,-(P)
	LDF FF,FA
	STF FA,-(P)
	LDF FACTMP,FA		;RESTORE FA
	JMP (F)			;RETURN

FACRES:	TST (P)+
	LDF (P)+,FA
	STF FA,FF
	LDF (P)+,FA
	STF FA,FE
	LDF (P)+,FD
	LDF (P)+,FC
	LDF (P)+,FB
	LDF (P)+,FA
	REST <A,B,C,D>
	POP E
	RTS F


.IFNZ DPM1
MAKEWINDOW:		;FIRST DO ARGUMENT DECODING, DEFAULT PARAMETERS, BOUNDRY CHECK 
	JSR PC,G2ARG	;FB_W SIZE X
	SETI		;FA GETS W SIZE Y 
	SETF
	STF FA,FE	;COPY
	STF FB,FF	;SIZE
	STF FA,FB	;AND SWITCH ARGS
	LDF FF,FA
	LDCIF #2.,FC
	DIVF FC,FA
	DIVF FC,FB
	LDF DCURX,FC	;PRESENTLY W CENTER IS HOME
	LDF DCURY,FD
;	STCFI FC,C
;	STCFI FD,A
	SUBF FA ,FC	;W RT EDGE=W CENTER X-SIZE/2
	SUBF FB,FD	;LIKEWISE FOR BOTTOM
	JSR PC,TRBOUN	;CHECK BOUNDS
	LDF FC,FA	;STORE THE EDGES
	LDF FD,FB
	ADDF FF,FC	;CALC. OTHER EDGES
	ADDF FE,FD
	JSR PC,TRBOUN	;CHECK BOUNDS
	JSR PC,TVSCAL	;CONVERT [FA,FB] TO TV COORDINATES
;	JSR PC,ROUND	;ROUND OFF
	STCFI FA,E
	STCFI FB,D
	LDF FC,FA	;THE SAME FOR OTHER EDGES
	LDF FD,FB
	JSR PC,TVSCAL
;	JSR PC,ROUND
	STCFI FA,B
	STCFI FB,F
	LDF DCURX,FA
	LDF DCURY,FB
	JSR PC,TVSCAL
;	JSR PC,ROUND
	STCFI FA,C
	STCFI FB,A
	SAVE <F,E,A,C> ;PUSH TOP, LEFT,W CENTER Y,WCENTER X

;FALL THROUGH
;FALLS IN
   ;NOW CALCULATE DIMENSIONS OF WINDOW AND LENGTH OF ARRAY NEEDED
;EMULATE THE ARGUMENT SET UP OF DEFAR SO AS TO BE ABLE TO JUMP INTO
;THE MIDDLE AND HAVE IT BIND AND ALLOCATE THE ARRAY

	SUB E,B		;#OF BITS (W LT EDGE-W RT EDGE)
	CLR A		;SET UP DIVIDE
	DIV #16.,A
	MOV B,-(P)	;PUSH LEFTOVER (REMAINDER)
	BEQ 1$
	INC A		;X DIM.=QUOITIENT+1 UNLESS NO LEFTOVER
1$:	SUB F,D		;Y DIM.=W BOTTOM-W TOP
	MOV D,F	
	MUL A,D		
	;LENGTH OF ARRAY NOW IN D
	SAVE <F,A>
	SAVE <#MAKEW1,F,A,#2>	;PUSH RETURN ADDRESS,Y DIM,X DIM,ARRAY TYPE	
	JMP WALLOC	;DO ARRAY BINDING AND ALLOCATION

  ;SET UP THE ARRAY HEADER WITH NECASSARY WINDOW INFORMATION

MAKEW1:	MOV TMPBLK,F	;F GETS A POINTER TO THE ARRAY
	ADD #4,F	;F NOW POINTS TO WORD ALLOCATED FOR THE # DIM
	MOV #2+LNUM,(F)+	;FILL HEADER- #OF DIM AND ARRAY TYPE
	MOV (P)+,(F)+	;XDIM
	MOV (P)+,(F)+	;YDIM
	MOV (P)+,(F)+	;SINCE THERE IS NO Z DIM I CAN STORE THE LEFTOVER IN IT
	REST <A,E>	;POP W CENX,W CENY
	MOV A,(F)+	;PUT W CENX
	MOV E,(F)+	;AND W CENY INTO ARRAY HEADER
	MOV (P),B
	SUB A,B		;DISTANCE FROM W CENTER TO LEFT EDGE
	MOV B,(F)+	;PUT IT INTO HEADER
	SPOP B
	MOV (P),D
	SUB E,D		;DISTANCE FROM W CENTER TO TOP EDGE
	MOV D,(F)+	;PUT IT IN HEADER
	SPOP D		;HEADER NOW FULL,STACK EMPTY,


;SET UP FOR TRANSFER.   THE TRANSFER IS DONE BY TWO NESTED DO LOOPS
;THE INNER LOOP READS AND SHIFTS AND STORES ONE LINE OF THE WINDOW EXCEPT
;FOR THE LAST WORD OF THE LINE WHICH NEEDS A MASK FOR THE LAST #LEFTOVER
;BITS. WHEN THE INNER LOOP IS FINISHED IT IS REINITIALIZED BY ADDING THE
;NUMBER OF WORDS ACROSS THE SCREEN MINUS THE #OF WORDS IN THE X DIM OF THE W
;TO THE POINTER INTO DISPLAY MEMORY AND PUTTING #OF WORDS IN THE X DIM OF THE W
;MINUS 1 INTO THE COUNTING REGISTER FOR THE INNER LOOP. THE OUTER LOOP DOES THIS 
;THE NUMBER OF LINES IN THE WINDOW (Y DIM)

;;Replace mask-creating code with masks from STARMSK, STOPMSK.
	CLR A		;MAKE MASK
	COM A		;OF THE #LEFTOVER
	ASH -10.(F),A	;LOW ORDER BITS
	COM A
	SPUSH A		;PUSH MASK
;	MOV -14.(F),C	;C GETS XDIM
;	SPUSH C		;PUSH INIT. VALUE OF COUNTER FOR INLUP
	SPUSH -14.(F)
	CLR A
	DIV #16.,A
	MUL #36.,D	;CALCULATE THE FIRST WORD OF WINDOW
	ADD A,D
	ASL D		;CONVERT TO BYTES
;	ADD #DISAD,D
	SPUSH D
	SPUSH B
	MOV -12.(F),C	;COUNTER FOR OUTER LOOP GETS YDIM
 ;NOW DO THE TRANSFER AND SHIFT FROM WINDOW TO THE ARRAY

;	JSR PC,TVMON
;	MOVB #1., TVINCR		;Increment address a word at a time.
;	MOV D, TVRADR
	CLRB	TVINCR
OUTLUP:	MOV 4(P),E	;(RE)SET COUNT1

INLUP:	MOV D,TVRADR
	MOV TVRWIN, A			;Pick up next two words of display memory.
	ADD #2.,D
	MOV D,TVRADR
	MOV TVRWIN,B			;Address increments a word at a time. 
;	MOV (D)+,B	;READ NEXT
;	MOV (D),A	;TWO WORD OF DISPLAY MEMORY


	ASHC (P),A	;SHIFT
	COM A		;STORE THE WINDOW IN COMPLEMENTED FORM 
	MOV A,(F)+	;PUT THE WORD INTO THE WINDOW ARRAY
	SOB E,INLUP	;ITERATE
	BIS 6.(P),-2(F)	;MASK THE EXTRANEOUS BITS

	ADD #BYTLINE, 2(P)		;Point to word in next line. 
;	MOV 2(P), TVRADR		;Less 2 because address incremented each read.
	MOV 2(P),D

	SOB C,OUTLUP	;ITERATE
	ADD #8.,P	;CLEAR STACK
	SEZ
	RTS PC


SHWERR:	ERROR+WNA
	;FIRST DECODE ARGS


HIDEWINDOW:
	SAVE D
	JSR PC,AMAKE	;B GETS A POINTER TO WINDOW ARRAY
	MOV #TVSET, A			;Display window in eraser mode.
	CLR D
	BR DISWIN

SHOWWINDOW:				;Display window in IOR mode.
	SAVE D
	JSR PC,AMAKE
	MOV #TVIOR, A
	BR DRAWIN

XORWINDOW:
	SAVE D
	JSR PC,AMAKE
	MOV #TVXOR, A			;XOR mode.

DRAWIN:	MOV #-1.,D
DISWIN:	
	REST C
	SAVE <WINDATA, TVSEL>	;Bind drawmode over display of window.
	MOV D, WINDATA
	JSR PC, DRAWMODE

;	JSR PC,AMAKE
;	REST C				;Number of arguments in C.
WINDOW:	
	DEC C
	BEQ 1$		;NO ARGS INADDITION TO NAME PUT IT AT IT'S CENTER
	CMP #2,C
	BNE SHWERR	;MUST BE TWO ARGS IF NONE
	SPUSH B
	JSR PC,G2ARG	;XCEN IN A,Y CEN IN B
	SETI
	SETF
	STF FA,FC
	STF FB,FD
	JSR PC,TVSCAL
	STCFI FA,C
	STCFI FB,D
	MOV @P,A	;A GETS POINTER TO ARRAY (THIS CHECKS THE BOUNDS OF THE WINDOW)
	ADD 16.(A),C	;LEFT EDGE = W CENTER X + DELTA X
	ADD 18.(A),D	;TOP EDGE = W CENTER Y +DELTA Y
	SAVE <C,D>	;FOR LATER USE
	JSR PC,TVBOUN	;CHECK BOUNDS
	MOV 6.(A),B	;RIGHT EDGE=LEFT EDGE + #OF X BITS OF WINDOW
	ASH #4,B	;TIMES 16: BITS OF WINDOW = 16 TIMES NUMBER OF WORDS
	TST 10.(A)	;IN X - 16 + NUMBER OF BITS THAT DIDN'T TAKE UP A WHOLE WORD.
	BEQ 3$		;TEST FOR SPECIAL CASE WHEN THE WINDOW FITS EXACTLY
	SUB #16.,C
3$:	ADD 10.(A),B
	ADD B,C
	ADD 8.(A),D	;BOTTOM=TOP +NUMBER OF LINES (Y DIM)
	JSR PC,TVBOUN	;CHECK BOUNDS
	REST <D,F,B>	;D:TOP F:LEFT EDGE B:POINTER TO ARRAY
	BR 4$
1$:	MOV 12.(B),F	;XCEN IN F
	MOV 14.(B),D	;YCEN IN D
2$:	;NOW SET UP STACK AND REGISTERS FOR TRANSFER
	ADD 16.(B),F	;DIST. FROM ORIGINAL WCENT TO LEFTEDGE
 	ADD 18.(B),D
4$:	CLR E		;FOR DIVIDE
	DIV #16.,E
	MUL #36.,D	;CALCULATING THE FIRST WORD IN DISPLAY MEMORY
	ADD E,D
	ASL D		;CONVERT TO BYTES
;	ADD #DISAD,D
;	SAVE <8.(B)>
	ASL F		;CONVERT TO BYTES
	SAVE <STARMS(F),D,6.(B)>   ;SAVE POINTER TO DISPLAY MEM, X INDEX(XDIM),SHIFT
	ASR F
	NEG F
	SPUSH F
	MOV 8.(B),A	;A GETS Y INDEX (YDIM)
	ADD #HEADER,B
	MOV D, TVRADR	
	CLRB TVINCR
;FALLS THROUGH
;FALLS IN
LOOP1:	MOV 2(P),C	;A:counter y,B:pointer into array C:counter x
;D: pointer into display mem. E:,F: used for shift
;stack @P shift,2(P) counter x needed to restore,4(P) points to next line of disp. mem.
LOOP2:	MOV #-1,F		;SET ALL THE BITS IN E FOR THE SHIFT	MOV (B)+,F
	MOV (B)+,E
	ASHC (P),E
	BIS 6.(P),E
;	COM F				;Write words in F and E on screen.
	MOV E, TVMSK			;(This loop can be optimized...)
;	MOV D,TVRADR
	MOV WINDATA, TVRWIN
;	ADD #2.,D
;	COM E
	MOV F, TVMSK
;	MOV D,TVRADR
	ADD #2.,TVRADR
	MOV WINDATA, TVRWIN
;	BIS F,(D)+
;	BIS E,(D)

	SOB C,LOOP2
	ADD #BYTLIN,4(P)
	MOV 4(P),TVRADR
;	MOV 4(P),D
;	ADD 4(P), TVRADR
;	ADD 4(P),D
	SOB A,LOOP1

	ADD #8.,P	;CLEAR STACK
	REST <TVSEL, WINDATA>
	SEZ 
	RTS PC

;	;TURN OFF TVMAP
;	JMP TVMOFF

;XORWIN:	JSR PC,AMAKE
;	MOV 2(P),C
;	MOV (P)+,(P)
;	JSR A,WINDOW
;	SPOP A
;LOOP3:	MOV 2(P),C
;LOOP4:	CLR E
;	MOV (B)+,F
;	ASHC (P),E
;	XOR F,(D)+
;	XOR E,(D)
;	SOB C,LOOP4
;	ADD 4(P),D
;	SOB A,LOOP3
;	ADD #6,P	;CLEAR STACK
;	JMP TVMOFF
;
;ERWINDOW:	JSR PC,AMAKE
;	MOV 2(P),C
;	MOV (P)+,(P)
;	JSR A,WINDOW
;	SPOP A
;LOOP5:	MOV 2(P),C
;LOOP6:	CLR E
;	MOV (B)+,F
;	ASHC (P),E
;	BIC F,(D)+
;	BIC E,(D)
;	SOB C,LOOP6
;	ADD 4(P),D
;	SOB A,LOOP5
;	ADD #6,P	;CLEAR STACK
;	JMP TVMOFF



;PRINTSCREEN
PRINTS:	JSR PC,TVTEST	;MAKE SURE WE ARE ON A TV
	SAVE <#-1,#0,#.LPCAP*400>	;CREAT LINEPRINTER
	.INVOK
	BNE 1$
	ERROR+DIU
1$:	REST TMPCP
	JSR PC,LPTFF		;PRINT FORM FEED
	SAVE <,#3,TMPCP>
	$INVOK			;PUT INTO PLOT MODE, EXPAND BY 3
	MOV #TVRADR,A		;POINT TO THE ADDRESS REGISTER
	MOV #454.,B		;NUMBER OF TV LINES
	MOV #TVRWIN,E		;POINT TO THE WINDOW
	CLR (A)			;START A THE 0 ADDRESS
PRSLP:	SAVE <#110,TMPCP>
	.WRDO
	BEQ PRSERR
	MOV #DBUF,C
	MOV #110/2,D
1$:	MOV (E),F
	ADD #2,(A)		;ADD TO GET NEXT WORD
	SWAB F
	MOV F,(C)+
	SOB D,1$
	SAVE <#DBUF,#-110,TMPCP>
	.BLKO
	BEQ PRSERR
	SOB B,PRSLP
	SAVE <,#0,TMPCP>	;GO BACK TO PRINT MODE
	$INVOK
	JSR PC,LPTFF		;FORM FEED
PRSDON:	JSR PC,DELTMP		;Falls thru to TVMOFF.
	RTS PC

LPTFF:	SAVE <#14,TMPCP>
	.BYTO			;OUTPUT A FORM FEED
	BEQ PRSERR		;ERROR, FORGET IT
	RTS PC

PRSERR:	JSR PC,PRSDON		;PRINT SCREEN DONE
	ERROR+DNR
.ENDC
.ENDC
.ENDC
.ENDC		;LSICOND, BEGINNING AT "TURTLE,DISPLAY,...AND OTHER CRAP"
	.SBTTL	MUSIC PRIMITIVES

.IFNZ SITS	;RESUME LSICOND UNTIL END OF MUSIC PRIMITIVES
SING:	SAVE D
	JSR	PC,MCHK
	JSR	PC,REVS	;FOR MULTIPLE ARGUMENTS
	MOV	(SP)+,D	;NUMBER OF ARGS
	ASR	D	;IS IT EVEN?
	BCC	SING2
	ERROR+WNA	;WRONG NUMBER OF ARGS
SING2:	MOV	VOICEN,E	;INDEX FOR VOICE (0,2,4 OR 6)
	MOV	VLAST(E),F	;POINTER TO LAST NODE IN VOICE
SING3:	DEC	D
	BGE	SING31
	SEZ
	RTS PC
SING31:	JSR	PC,G2NARG	;DURATION IN B, PITCH IN A
	JSR	PC,SINGNO	;NORMALIZE MIDDLE C TO 0.  ERROR IF NOTE OUT OF RANGE
	TST	B	;DURATION
	BGE	SING7
SING6:	ERROR+DOR	;DURATION OUT OF RANGE
SING7:	CMP	B,#177	;LARGEST LEGAL DURATION (+- 7 BITS)
	BGT	SING6
	ADD	B,VOICLN(E)	;ACCUMULATE TOTAL FOR VOICE
	CMP	B,#1
	BLT	SING3	;IF ZERO THEN GO ON
	BNE	SING8
	NEG	B	;IF 1 THEN SET TO -1 AS FLAG FOR PERFORM
SING8:	SWAB	A
	BIC	#177400,B	;CLEAR TOP HALF
	BIS	A,B	;SET UP 8 BITS PITCH, 8 BITS DURATION IN B
	JSR	PC,ACTSTO	;BUILD ON TO VOICE LIST
	MOV	F,VLAST(E)	;NEW LAST NOTE
	BR	SING3


;NORMALIZE MIDDLE C TO 0
;ERROR IF NOTE OUT OF RANGE.
SINGNO:	ADD	#74,A	;NORMALIZE 0 TO MIDDLE C
	CMP A,#MBTRAP
	BEQ SINGN1
	CMP	A,#MBREST	;SMALLEST VALID PITCH
	BGE	SINGN2
SINGN1:	ERROR+NOG	;NOTE OUT OF RANGE
SINGN2:	CMP	A,#137	;HIGHEST VALID NOTE
	BGT	SINGN1
	RTS	PC
NOMUSIC:
	TST PTBF
	BEQ NOMUS1
	MOV #PMBOX,A
	JSR PC,TBCHK
	BEQ NOMU9
	BIC #INITF,(A)
	BR MUSIN
NOMUS1:	MOV	MBDN,E
	JSR	PC,CLOSE1
	BNE	NOMU9	;BR IF NOT OPEN ANYWAY
	BR	MUSIN	;ELSE CLEAR OUT MUSIC VOICES, ETC.

;TRY TO GET MUSIC BOX AND INITIALIZE
;IF DON'T ALREADY HAVE IT
MCHK:	TST PTBF
	BEQ MCHK1
	MOV #PMBOX,A
	JSR PC,TBCHK
	BNE 1$
	ERROR+DNR
1$:	BIT #INITF,(A)
	BNE NOMU9
	BIS #INITF,(A)
	BR MUSIN
MCHK1:	MOV	MBDN,E
	TSTB TTYCPS(E)		;OPEN ALREADY?
	BNE NOMU9		;YES, FORGET IT
	JSR	PC,OPEN1
MUSIN:	MOV	#100,MUCWRD	;FOR NVOICES 4
	MOV	#MUSBEG,A
MUSIN1:	CLR	(A)+
	CMP	A,#MUSEND
	BLT	MUSIN1
	MOV	#MVOC,A	;CLEAR OUT THE POINTERS IN USER SPACE
	CLR	(A)+
	CLR	(A)+
	CLR	(A)+
	CLR	(A)+
	JSR	PC,MCL	;SET UP DUMMY NODES
	MOV	#6,NVOIC	;NUMBER OF VOICES
NOMU9:	SEZ
	RTS	PC

			;SET UP DUMMY MUSIC LISTS
MCL:	MOV	#6,F
	CLR	B
	MOV	#LSTR,A
MCL2:	MOV	MVOC(F),TOPS	;FREE MUSIC NODES
	JSR	PC,FRELST
	JSR	PC,GRBAD	;GET A NEW NODE
	BIS	A,C
	CLR	B
	JSR	PC,.STORE
	MOV	C,MVOC(F)	;POINTER TO IT
	MOV	C,VLAST(F)
	CLR	VOICLN(F)
	SUB	#2,F
	BGE	MCL2
	RTS	PC

MCLEAR:	JSR	PC,MCHK
	JSR	PC,MCL
	SEZ
	RTS PC
VLEN:	JSR	PC,MCHK	;OUTPUT LENGTH OF CURENT VOICE
	MOV	VOICEN,B
	MOV	VOICLN(B),B
	JMP	R1NARG

MLEN:	JSR	PC,MCHK
	MOV	#4,D
	MOV	#VOICLN,F
	CLR	B
MLEN1:	MOV	(F)+,A	;GET MAXIMUM VOICE LENGTH
	CMP	A,B
	BLE	MLEN2
	MOV	A,B
MLEN2:	DEC	D
	BNE	MLEN1
	JMP	R1NARG

;LIKE TYO, EXCEPT TO MUSIC BOX SPECIFICALLY, ALSO TAKES VARIABLE ARGS, AND CONVERTS
;ARGS TO MUSIC BOX NOTES				
MUTYO:	SAVE D
	JSR PC,REVS
	JSR PC,MCHK	;CHECK TO MAKER SURE THAT THE MUSIC BOX IS WHERE IT SHOULD BE
	SPOP C		;THE ARGUMENT
	BEQ MUTYO2	;NO CHARACTERS TO SEND BECAUSE NO ARGS
MUTYO1:	JSR PC,G1NARG	;B _ CHARACTER
	MOV B,A		;COPY IT
	JSR PC,SINGNO	;NORMALIZES IT TO MIDDLE C
	MOV A,D		;THE CHAR TO OUTPUT
	JSR PC,TMBTYO	;TYO THE CHARATER
	SOB C,MUTYO1	;FOR ALL THE CHARACTERS
MUTYO2:	.IIF NZ PTBOX,JSR PC,TBREST	;CHANGE BACK TO CONSOLE MODE (NO CHOICE)
	SEZ
	RTS PC

;SENDS CONTROL INFO TO THE MUSIC BOX
MUCTRL:	JSR PC,MCHK	;CHECK TO MAKE SURE MUSIC BOX IS OPEN
	JSR PC,G1NARG	;GET THE ARGUMENT
	MOV B,D		;THE ARG
	BLT MUCERR	;MUST BE A NUMBER BETWEEN 0,,33
	CMP D,#33.
	BLE MUC1	;FINE
MUCERR:	ERROR+WTIB	;BAD ARGMENT TO MUCTRL
;ARG IS DECODED AS FOLLOWS:
;	TOP DIGIT IS SILENCE CONTROL, BOTTOM DIGIT IS LOADING CONTROL (BOTH <4)
MUC1:	CLR C		;FOR THE DIVIDE
	DIV #10.,C	;C_ 10'S D_ UNITS
	ASH #4,C	;SHIFT INTO BITS 6,5
	BIC #177774,D	;LEAVE ONLY THE BOTTOM TO BITS
	BIS C,D		;SET IN THE SILENCE INFO
	BIT #40,D	;BIT 6 CANT EQUAL BIT 7 (ITS A CROCK!!!)
	BNE MUC2	;BIT 6=1
	BIS #100,D	;SO MAKE BIT 7 = 1
MUC2:	MOV D,MUCWRD	;CURRENT CONTROL WORD
	JSR PC,MUCTYO	;OUTPUT THAT BYTE
.IIF NZ PTBOX,	JSR PC,TBREST	;RESET THE MUSIC BOX (GROAN)
	SEZ
	RTS PC
GTVARG:	JSR	PC,G1NARG
	DEC	B	;TRANSFORM VOICE NUMBER (1,2,3,4) TO INDEX (0,2,4,6)
	ASL	B
	TST	B
	BGE	GTV2
GTV1:	ERROR+IVV	;INVALID VOICE NUMBER
GTV2:	CMP	B,#6
	BGT	GTV1
	RTS	PC

VOICE:	JSR	PC,MCHK
	JSR	PC,GTVARG
	MOV	B,VOICEN
	SEZ
	RTS PC

NVOICES:	JSR	PC,MCHK
	JSR	PC,MCL	;REINITIALIZE
	JSR	PC,GTVARG
	MOV	B,NVOIC	;SET NEW VOICE NUMBER
	SEZ
	RTS PC

MBON:	MOV MBDN,E
	MOV	NVOIC,A
	ASR	A	;TURN INTO BYTE INDEX
	MOV	A,B
	CMP	#2,A	;IN NVOICES 3,
	BNE	MBON1
	INC	A	;IT IS NECESSARY TO SILENCE 4 VOICES
MBON1:	MOVB	MBSCH(A),D	;CHAR FOR A VOICES, BUT ALL SILENT
	JSR	PC,MUCTYO
	MOV	#MBREST,D
	INC	A
MBON2:	JSR	PC,TBTYO1	;OUTPUT REST
	SOB	A,MBON2
	MOVB	MBVCH(B),D	;CONTROL CHR  FOR NUMBER OF VOICES
	MOV	D,MUCWRD
	JSR	PC,MUCTYO	;LEAVE BOX READY FOR NOTES
	RTS	PC

;SILENCE MBOX, BUT DON'T CHANGE NUMBER OF VOICES OR ANYTHING
MBOFF:	MOV	MUCWRD,D
	BIC	#177774,D	;LEAVE NUMBER OF VOICES INFO INTACT
	BIS	#100,D
	MOV	D,MUCWRD
	JSR	PC,MUCTYO
.IIF NZ PTBOX,	JSR PC,TBREST
	RTS	PC

;CALLED BY BREAK AND PAUSE TO SHUT THE  DAMN THING UP
BRKMOF:	MOV	MBDN,E
	TSTB TTYCPS(E)	;OWN MUSIC BOX
	BEQ BRKMO9	;NO
	JSR	PC,MBOFF
	RTS	PC

;CALLED BY CONTINUE TO TURN MBOX BACK ON
BRKMON:	MOV	MBDN,E
	TSTB TTYCPS(E)	;OWN MUSIC BOX
	BEQ BRKMO9	;NO
	MOV	MUCWRD,D
	JSR	PC,MUCTYO
BRKMO9:	RTS	PC
			;OUTPUT MUSIC TO THE BOX
PM:	JSR	PC,MCHK
	JSR	PC,MBON
	MOV	NVOIC,A
	MOV	A,F	;USED AS POINTER TO CORRECT VOICE
	ADD	#VOICLN+2,A	;SET UP FLAGS IN VOICLN SLOTS
PM1:	MOV	#-1,-(A)
	CMP	A,#VOICLN
	BGT	PM1
PM2:	JSR	PC,PMCHP	;GRAB DUMMY NODE OF EACH VOICE
	JSR	PC,PMCHP	;NOW SET UP FIRST NODE OF MUSIC
PM21:	SUB 	#2,F
	TST	F
	BGE	PM2
PM3:	TST BRAKE
	BNE PM6
	CLR	F	;LOOP TO OUTPUT NOTES
PM4:	JSR	PC,PMNXT	;F IS INDEX TO VOICE
	ADD #2,F	;POINT TO THE NEXT ONE
	CMP	F,NVOIC	;ONE NOTE FROM EACH VOICE
	BLE	PM4
	CLR	B
	MOV	NVOIC,A	;ADD FLAGS FOR ALL VOICES
	ADD	#VOICLN+2,A
PM5:	ADD	-(A),B
	CMP	A,#VOICLN
	BGT	PM5
	TST	B	;IF ALL FLAGS CLEARED THEN DONE
	BNE	PM3
PM6:	JSR	PC,MBOFF
	JSR	PC,MCL	;REINIT MUSIC VARIABLES
	SEZ
	RTS PC

			;OUTPUT ONE NOTE FROM VOICE(F)
PMNXT:	DEC	TEMP	;NOTE COUNTER
	MOV	#MBREST,D
	TST	VOICLN(F)	;IF FLAG CLEARED OUTPUT REST
	BNE	PMNXT2
	JSR PC,TMBTYO
	RTS	PC
PMNXT2:	CMPB	VLAST(F),#1	;IF DUR=1 PLAY A REST
	BEQ	PMNX2A
	MOVB	VLAST+1(F),D	;PITCH
PMNX2A:	JSR	PC,TMBTYO
	DECB	VLAST(F)	;DECREMENT DURATION
	BGT	PMNXT3
	JSR	PC,PMCHP	;IF DUR<=0 SET UP NEXT NODE
	RTS	PC
PMNXT3:	CMPB	D,#MBPERC	;IS THIS A PERCUSSION SOUND?
	BGT	PMNXT4	;NO
	MOVB	#MBREST,VLAST+1(F)	;YES--CHANGE ALL BUT FIRST TO RESTS
PMNXT4:	RTS	PC

PMCHP:	MOV	MVOC(F),C	;SET UP NEXT NODE SKIP IF SUCCESSFUL
	BIC	#170000,C
	BNE	PMCHP1
	CLR	VOICLN(F)	;CLEAR FLAG TO INDICATE NO NEXT NODE
	RTS	PC
PMCHP1:	JSR	PC,.LOADC
	BIC #170000,A
	BIS #LSTR,A
	MOV	A,MVOC(F)
	MOV	B,VLAST(F)	;PUT PITCH,,DURATION IN VLAST SLOT
	JSR	PC,.FREE	;FREE OLD NODE
	RTS	PC

TMBTYO:	SPUSH C
	MOV #PMBOX,C
	JSR PC,TBTYO
	SPOP C
	RTS PC

MUCTYO:	SPUSH D
	MOV #MBTRAP,D		;TRAP CHARACTER FOR THE MUSIC BOX
	JSR PC,TMBTYO		;OUTPUT IT
	SPOP D			;GET BACK ORIGINAL CHARACTER
	JSR PC,TBTYO1		;OUTPUT IT
	RTS PC

TBTYO:	JSR PC,TBINIT		;INIT THE PRIVATE THORTON BOX IF OWNED
TBTYO1:	SAVE D			;THE CHARACTER TO OUTPUT
	TST PTBF		;THORTON BOX PRIVATE?
	BEQ 1$			;NO, USE THE NUMBER IN E
	MOV TYICP,-(P)		;USE MY CAPABILITY INSTEAD
	BR 2$			;SKIP CRAP WITH GETTING CAPABILITY NUMBER
1$:	CLR -(P)
	MOVB TTYCPS(E),(P)
2$:	$BYTO			;OUTPUT IT
	RTS PC

TBCHK:	TST PTBF
	BNE TBCHK2
	RTS PC
TBCHK2:	SPUSH B
	SPUSH C
	MOV #4,B
	MOV #PTBTAB,C
TBCHK3:	CMPB A,(C)
	BEQ TBCHCZ
	TST (C)+
	SOB B,TBCHK3
TBCHSZ:	SPOP C
	SPOP B
	SEZ
	RTS PC
TBCHCZ:	MOV C,A
	SPOP C
	SPOP B
	CLZ
	RTS PC

CTYOWA:
TYOWAI:
	ERROR+SIT
.ENDC   ;lsicond

.ifnz lsi

tablet:	mov tabdev,b	;get tablet word
	bmi 1$		;1st arg: true iff hi bit is 1
	push #false
	br 2$
1$:	push #true
2$:	mov @s,-(p)	;1st name
	movb b,c	;2nd arg: true iff hi bit of lo bite is 1
	bmi 3$
	push #false
	br 4$
3$:	push #true
4$:	mov s,f		;2nd name
	mov 2(f),-(p)
	swab b		;3rd arg: hi byte minus its hi bit
	bic #-200,b
	jsr pc,.csnin
	push b
	mov 4(f),-(p)	;3rd name
	movb c,b	;4th arg: lo byte minus its hi bit
	bic #-200,b
	jsr pc,.csnin
	add #6,s
	pushs b		;now set up 4 thing/name pairs on the spdl
	pushs (p)+
	pushs (p)+
	pushs (p)+
	pushs (p)+
	pushs (p)+
	pushs (p)+
	jsr pc,mmake9	;& do 4 calls to make
	jsr pc,mmake9
	jsr pc,mmake9
	jmp mmake9
.endc
