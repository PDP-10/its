;;; -*-Mode:lisp-*-

(or (boundp 'sgincl-loaded) (load "dcp;sgincl"))

(defun bootstrap ()
  (close sgttyo)
  (close sgos)
  (sstatus toplevel '(quit))
  (gc) (gc) (gc)
  (suspend ":Creating  SYS3;TS SUPARDî:pdump dsk:sys3;ts supardî:kill ")
  (setq sgttyo (open "tty:" '(out image tty)))
  (if (eq (status subsys) 'SUPARD)
      (convert (implode (status jcl)) sgttyo)
      (let ((jcl (readlist `(#/( ,@(nreverse (cdr (nreverse (status jcl)))) #/)))))
	(sg-file-output (cadr jcl))
	(convert (car jcl) sgttyo)
	(sg-revert-output)))
  (valret ":kill ")
  (quit))

(defun convert (i-file o-file)
  (cond ((errset (setq ards-in (open i-file '(in ascii))) t)
	 (errset (progn
		  (setq sgos o-file)
		  (setq ards-x -512. ards-y +511.)
		  (cursorpos 'c)
		  (sg-do '(reset enter clear ior))
		  (sg-set-point 0 0)
		  (setq exit-chars '(-1 3 34 35 36 37))
		  (do ((last-char (tyi ards-in) (process-char last-char)))
		      ((member last-char '(-1 3))))
		  (sg-do '(exit)))
		 t))))

(defun process-char (n)
  (sg-do '(enter))
  (caseq n
    (34 (enter-character-mode (tyi ards-in)))
    (35 (enter-set-point-mode))
    (36 (enter-long-vector-mode))
    (37 (enter-short-vector-mode))
    (t  (enter-character-mode n))))

(defun enter-character-mode (n)
  (sg-out %GODCH)
  (do ((n n (tyi ards-in)))
      ((member n exit-chars)
       (sg-out 0)
       (sg-set-point 0 0)
       n)
    (sg-out n)))

(defun enter-set-point-mode ()
  (do ((i 0)
       (chars '())
       (char (tyi ards-in) (tyi ards-in)))
      ((member char exit-chars) char)
    (setq chars (cons char chars)
	  i (1+ i))
    (cond ((= i 4)
	   (let (( (x y vis) (decode-ards-long (nreverse chars))))
	     (sg-move-to (// (setq ards-x x) 2)
			 (// (setq ards-y y) 2)))
	   (setq chars '() i 0)))))

(defun enter-long-vector-mode ()
  (do ((i 0)
       (chars '())
       (char (tyi ards-in) (tyi ards-in)))
      ((member char exit-chars) char)
    (setq chars (cons char chars)
	  i (1+ i))
    (cond ((= i 4)
	   (let (( (x y vis) (decode-ards-long (nreverse chars))))
	     (cond (vis (sg-draw-to (// (setq ards-x (+ ards-x x)) 2)
				    (// (setq ards-y (+ ards-y y)) 2)
				    tv:alu-ior))
		   ('else
		    (sg-move-to  (// (setq ards-x (+ ards-x x)) 2)
				 (// (setq ards-y (+ ards-y y)) 2)))))
	   (setq chars '() i 0)))))

(defun enter-short-vector-mode ()
  (do ((i 0)
       (chars '())
       (char (tyi ards-in) (tyi ards-in)))
      ((member char exit-chars) char)
    (setq chars (cons char chars)
	  i (1+ i))
    (cond ((= i 2)
	   (let (( (x y vis) (decode-ards-short (nreverse chars))))
	     (sg-draw-to (// (setq ards-x (+ ards-x x)) 2)
			 (// (setq ards-y (+ ards-y y)) 2)
			 tv:alu-ior))
	   (setq chars '() i 0)))))

(defun decode-ards-long (l)
  (let (( (a b c d) l))
    (list  (* (+ (lsh (logand b 37) 5) (logand (lsh a -1) 37))
	      (cond ((oddp a) -1) ('else 1)))
	   (* (+ (lsh (logand d 37) 5) (logand (lsh c -1) 37))
	      (cond ((oddp c) -1) ('else 1)))
	   (zerop (logand b 40)))))

(defun decode-ards-short (l)
  (list (* (logand (lsh (car  l) -1) 37)
	   (cond ((oddp (car  l)) -1) ('else 1)))
	(* (logand (lsh (cadr l) -1) 37)
	   (cond ((oddp (cadr l)) -1) ('else 1)))
	'T))

(princ "Type  (bootstrap)  to recreate system program")
