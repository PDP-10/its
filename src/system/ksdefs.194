; -*- Midas -*-				This is the file AI:SYSTEM;KSDEFS >

;;; "Devices"

PI==:4			;Interrupts
PAG==:10		;Paging
 ..D010==:0		;(For DDT)
.RD.==:20		;Read various kludges.
 ..D020==:0
.WR.==:24		;Write various kludges.
 ..D024==:0

;;; XCTR and paging instructions

UMOVE=:704^9		;"BLKI 40,"
			;Same as XCTR XR,[MOVE ...]

UMOVEM=:705^9		;"BLKI 50,"
			;Same as XCTR XW,[MOVEM ...]

XCTR=:103^9		;XCT with mapping.
XCTRI=:102^9		;Same, but page fails cause it to skip.  Done by
			;software as on the KL.
	;;XCTR bits for the KS are theoretically the same as those on the KL.
	;;These values were generated by reading the documentation rather
	;;than by copying the bits for XCTR on MC.
	XR==:4
	XW==:4
	XRW==:4
	XBYTE==:7	;On MC-KL this is 5.  The manual don't list 5 as a
			;reasonable value at all.  The 2 bit causes the EA
			;calculation for the byte pointer to take place in
			;the user's context.  Since ITS does the EA
			;calculation for byte pointers it XCTRs ahead of
			;time, perhaps it doesn't matter?
	XBR==:1
	XBW==:4
	XBRW==:5
	XEA==:10	; On MC-KL this is #o16.  The processor manual for
			; the KL contains some waffling about how 10 won't
			; work and you should use 14 instead.  The KS
			; manual is silent on this point.  Seemingly no
			; bits other than 10 can effect an immediate
			; instruction.  This option doesn't exist on the KA
			; and is used by ITS in only two places, both in
			; the KL-specific page fail code.  One occurance is
			; commented out with the claim that it is buggy.
			; For the moment let us assume that this value will
			; just work on the KS.

;;; Traditional instructions.

RDAPR==:CONI 0,		;= 700240,,	C(E) <- System flags
			;4.3 - 3.5 Flags enabled
			; (on KL 2.8 says the cache is being swept)
			;2.3 - 1.5 Flags set
			;1.4 Some flag is interrupting
			;1.3 - 1.1 PI level

WRAPR==:CONO 0,		;= 700200,,	System flags <- E
			; (on KL 2.8 Clears all IO devices)
			;2.7 - 2.4 Function to perform on flags:
			;  2.7 Enable
			;  2.6 Disable
			;  2.5 Clear
			;  2.4 Set
			;2.3 - 1.5 Flags to perform function upon:
			;  2.3 "Flag 24"
			;  2.2 KS interrupting the 8080
			;  2.1 Power failure
			;  1.9 No memory
			;  1.8 Bad memory data
			;  1.7 Corrected memory data
			;  1.6 Interval done
			;  1.5 8080 interrupting the KS
			;  (on KL flags are:
			;    2.3 S bus error
			;    2.2 No memory
			;    2.1 IO page failure
			;    1.9 MB parity
			;    1.8 Cache directory parity
			;    1.7 Address parity
			;    1.6 Power failure
			;    1.5 Cache sweep done)
			;1.3 - 1.1 PI level

80INT==:12000		;Interrupt 8080 from KS.

RDPI==:CONI PI,		;= 700640,,	C(E) <- PI status
			;3.7 - 3.1 interrupts requested with CONO PI,
			; (on KL 2.9 - 2.7 control parity)
			;2.6 - 1.9 Interrupt in progress
			;1.8 PI system is on
			;1.7 - 1.1 Levels turned on

WRPI==:CONO PI,		;= 700600,,	PI status <- E
			; (on KL 2.9 - 2.7 control parity)
			;2.5 Drop requests on selected levels
			;2.4 Clear PI system
			;2.3 Initiate interrupts on selected levels
			;2.2 Turn on selected levels
			;2.1 Turn off selected levels
			;1.9 Turn off PI system
			;1.8 Turn on PI system
			;1.7 - 1.1 Select level

;;; More traditional looking instructions, sort of...

APRID==:BLKI 0,		;= 700000,,	C(E) <- Processor ID
			;4.9 - 4.1 Microcode options:
			;  4.5 ITS microcode
			;  (on KL options are:
			;    4.9 Tops-20 Paging
			;    4.8 Extended addressing
			;    4.7 Exotic microcode
			;    4.5 ITS microcode)
			;3.9 - 3.1 Microcode version number
			;2.9 - 2.7 Hardware options:
			;  None defined.
			;  (on KL options are:
			;    2.9 50 Hz line frequency
			;    2.8 Cache
			;    2.7 Channel
			;    2.6 Extended KL10
			;    2.5 Master Oscillator)
			;2.6 - 1.1 Processor serial number

RDEBR=:CONI PAG,	;= 701240,,	C(E) <- EBR
WREBR=:CONO PAG,	;= 701200,,	EBR <- E
			;2.6 Tops-20 style
			;2.5 Enable pager (and traps)
			;2.2 - 1.1 EBR physical DEC page number
			;WREBR resets the cache and page table.
			;
			; In the ITS microcode setting bit 2.6 only effects
			; the style in which MUUOs are trapped.  It should
			; never be set.

RDUBR=:DATAI PAG,	;= 701040,,	C(E) <- UBR
WRUBR=:DATAO PAG,	;= 701140,,	UBR <- C(E)
			;4.9 Set AC blocks
			;4.7 Set UBR
			;4.3 - 4.1 Current ACs
			;3.9 - 3.7 Previous ACs
			;3.2 - 1.1 UBR physical base address
			;RDUBR always returns a word with 4.9 and 4.7 set.
			;WRUBR resets the cache and page table.

CLRPT=:BLKO PAG,	;= 701100,,	Clear page table entry
			;Invalidate the page table entry for the page
			;referenced by E and reset the cache.
			;
			;In the ITS microcode this will only invalidate the
			;page table entry for half page referenced by E.

CLRCSH=:BLKI PAG,	;= 701000,,	Clear Cache
			;In the ITS microcode only.
			;Resets the cache.


;;; Instructions for maintaining the DBRs.  LPMR and SPM.

LDBR1=:BLKI .WR.,	;= 702400,,	DBR1 <- E
SDBR1=:BLKI .RD.,	;= 702000,,	C(E) <- DBR1
LDBR2=:DATAI .WR.,	;= 702440,,	DBR2 <- E
SDBR2=:DATAI .RD.,	;= 702040,,	C(E) <- DBR2
LDBR3=:BLKO .WR.,	;= 702500,,	DBR3 <- E
SDBR3=:BLKO .RD.,	;= 702100,,	C(E) <- DBR3
LDBR4=:DATAO .WR.,	;= 702540,,	DBR4 <- E
SDBR4=:DATAO .RD.,	;= 702140,,	C(E) <- DBR4
			;LDBR1, LDBR2, LDBR3 and LDBR4 all reset the cache
			;and page table.  someday they may be careful and
			;not reset the half of the page table they don't
			;effect.

;;; And there is also the traditional:

LPMR=:CONSO .WR.,	;702740,,	DBR1, DBR2, ... <- C(E, E+1, ...)
SPM=:CONSO .RD.,	;702340,,	C(E, E+1, ...) <- DBR1, DBR2, ...
			;The format of the block read and written by these
			;two instructions is:
			;	(E)	DBR1
			;	(E+1)	DBR2
			;	(E+2)	Quantum timer
			;	(E+3)	U.JPC	(If this ucode supports it)
			;	(E+4)	E.JPC	( " " )
			;LPMR resets the cache and page table.

RDTIM=:CONO .RD.,	;= 702200,,	C(E, E+1) <- Time
WRTIM=:CONO .WR.,	;= 702600,,	Time <- C(E, E+1)
			; The time is a 71. bit unsigned number.  The bottom
			; 12. bits cannot be set.  The bottom 2 bits cannot
			; even be read.  It increments at 4.1 MHz.  The top
			; 59. bits (the ones you can set) thus measure
			; (almost) milliseconds.  The top 69. bits (the
			; ones you can read) thus measure "short"
			; microseconds.  The time wraps around every 18.
			; million years.  To make the top 59. bits actually
			; measure milliseconds, the clock would have to run
			; at 4.096 MHz.  However it -really- -does- run at
			; exactly 4.1 MHz!

RDINT=:CONI .RD.,	;= 702240,,	C(E) <- Interval
WRINT=:CONI .WR.,	;= 702640,,	Interval <- C(E)
			;The interval is a 35. bit number in the same units
			;as the time.  At the end of every interval the
			;interval done interrupt occurs (CONI APR, bit
			;1.5).  The biggest interval you can set is about 2
			;hours and 20 minutes.  In the DEC microcode the
			;interval is effectively rounded up to the next
			;millisecond, so it is really only worth your while
			;to set the top 23. bits.  In the ITS microcode all
			;bits of the interval are signifigant.  Although
			;the length of a -single- interval cannot be
			;controlled more accurately than under the DEC
			;microcode, the average time between interval done
			;interrupts should converge to the full 35. bit
			;value.

RDHSB=:CONSZ .RD.,	;= 702300,,	C(E) <- HSB base address
WRHSB=:CONSZ .WR.,	;= 702700,,	HSB base address <- C(E)
			;4.9 Base address is invalid.  If this is set
			;	nothing will be written anywhere when the
			;	machine halts.
			;3.1 - 1.1 Physical address of first location in
			;	which to store debugging info when the
			;	machine halts.
			;In the ITS microcode, the initial HSB base address
			; is #o500.
			;When the machine halts it stores a halt code in
			; physical location 0 and the PC in location 1.
			; Then if 4.9 is not set (and the machine has not
			; just powered on) the contents of the 2901's
			; registers are dumped in the halt status block,
			; followed by the VMA.

;;; Halt Codes

			;CODES 0 TO 77 ARE "NORMAL" HALTS
;	POWER=0		;POWER UP
;	HALT=1		;HALT INSTRUCTION
;	CSL=2		;CONSOLE HALT
			;CODES 100 TO 777 ARE SOFTWARE ERRORS
;	IOPF=100	;I/O PAGE FAIL
;	ILLII=101	;ILLEGAL INTERRUPT INSTRUCTION
;	ILLINT=102	;BAD POINTER TO UNIBUS INTERRUPT VECTOR
			;CODES 1000 TO 1777 ARE HARDWARE ERRORS
;	BW14=1000	;ILLEGAL BWRITE FUNCTION (BAD DROM)
;	NICOND 5=1004	;ILLEGAL NICOND DISPATCH
;	MULERR=1005	;VALUE COMPUTED FOR 10**21 WAS WRONG

;;; Halt Status Block definition

IFNDEF HSB, HSB==:500
HSBMAG=:HSB+0
HSBPC=:HSB+1
HSBHR=:HSB+2
HSBAR=:HSB+3
HSBARX=:HSB+4
HSBBR=:HSB+5
HSBBRX=:HSB+6
HSBONE=:HSB+7
HSBEBR=:HSB+10
HSBUBR=:HSB+11
HSBMASK=:HSB+12
HSBFLG=:HSB+13
HSBPI=:HSB+14
HSBXWD1=:HSB+15
HSBT0=:HSB+16
HSBT1=:HSB+17
HSBVMA=:HSB+20

;;; ITS I/O instructions.

UBAQ==:1			; QSK is on Unibus #1
UBAI==:3			; Everything else is on Unibus #3

IORDI=:710^9			; C(AC) <- IO(UBAI,,E)
IORDQ=:711^9			; C(AC) <- IO(UBAQ,,E)
IORD=:712^9			; C(AC) <- IO(C(E))
IOWR=:713^9			; IO(C(E)) <- C(AC)
IOWRI=:714^9			; IO(UBAI,,E) <- C(AC)
IOWRQ=:715^9			; IO(UBAQ,,E) <- C(AC)

IORDBI=:720^9
IORDBQ=:721^9
IORDB=:722^9
IOWRB=:723^9
IOWRBI=:724^9
IOWRBQ=:725^9

;;; Byte packing and unpacking instructions.

;;; These are new with microcode 262, but came from DEC.
;;; Variations of BLT that the convert format of each word moved.
;;; These are legal in user mode, too.  Good thing DECUUO doesn't use them.
BLTBU=:716^9			;Source 8-bit bytes, Destination Unibus format
BLTUB=:717^9			;Source Unibus format, Destination 8-bit bytes

;;; Future byte packing and unpacking instructions

;;; =:730^9
;;; =:731^9
;;; =:732^9
;;; =:733^9
;;; =:734^9
;;; =:735^9
;;; =:736^9
;;; =:737^9

;;; Format of ITS page fail word:

%PF==:1,,525252		;Left handed bits.
%PFUSR==:400000		;4.9 Indicates user address space.
%PFNXI==:200000		;4.8 Nonexistent IO register.
%PFNXM==:100000		;4.7 Nonexistent memory.
%PFPAR==:040000		;4.6 Uncorrectable memory error.
			;	(AC0 in block 7 has the word unless 4.7 is
			;	 also set.)
			;4.5
%PFWRT==:010000		;4.4 Soft fault reference called for writing.
%PF2.9==:004000		;4.3 - 4.2 Access bits for referenced page in soft
%PF2.8==:002000		;	   fault.
%PFPHY==:001000		;4.1 Address given was physical.
			;3.9
%PFIO==:000200		;3.8 Indicates an IO operation.
			;3.7
			;3.6
%PFBYT==:000020		;3.5 Indicates a byte IO operation.
			;3.4 - 1.1 IO address
			; or
			;3.1 - 1.1 Memory address
$PFPNO==:121000		;2.9 - 2.2 Virtual page number

;;; Format of ITS page table entry:

			;2.9 - 2.8 Access bits
			;  00 Inaccessible
			;  01 Read only
			;  10 Read/Write/First
			;  11 Read/Write
PMAGEM==:020000		;2.5 Age bit
PMCSHM==:010000		;2.4 Cache enable bit
PMRCM==:001777		;2.1 - 1.1 Physical page number
			;	(The page table supports 20 bit physical
			;	 addresses.) 
PMUNSD==:146000		;Unused bits

;;; UPT Offsets
;;; In non-time sharing and at clock level in ITS UPT=EPT.

UPTTR1==:421		;Exec mode arith ovfl trap.
UPTTR2==:422		;Exec mode pdl ov trap.
UPTTR3==:423		;Exec mode trap 3 in non-one-proceed microcode.

UPTUUO==:424		;MUUO stored here.
UPTUPC==:425		;MUUO old PC stored here.
UPTUCX==:426		;MUUO context (from RDUBR (= DATAI PAG,)) stored here.

;;;	 427		;Unused.

UPTUEN==:430		;MUUO new PC obtained from here in exec mode when
			;traps are not enabled.  (MUUO as a trap
			;instruction for example.)
UPTUET==:431		;MUUO new PC obtained from here in exec mode when
			;traps are enabled.

UPT1PO==:432		;One-proceed old PC stored here in one-proceed
			;microcode.
UPT1PN==:433		;One-proceed new PC obtained from here in
			;one-proceed microcode.

UPTUUN==:434		;MUUO new PC obtained from here in user mode when
			;traps are not enabled.
UPTUUT==:435		;MUUO new PC obtained from here in user mode when
			;traps are enabled.

;;;	 436		;Unused.
;;;	 437		;Unused.

;;; EPT Locations

IFNDEF EPT, EPT==:0	;Absolute location of EPT.

PI0LOC=:EPT+40		;PI0LOC+2*PICHN = Address of instr pair for PICHN.
IRP I,,[1,2,3,4,5,6,7]
PI!I!LOC=:PI0LOC+<2*I>
TERMIN

EPTUIT=:EPT+100		;EPTUIT+I contains address of the interrupt table
			; for unibus adapter I.  Only adapters 1 and 3 ever
			; exist.

EPTTR1=:EPT+421		;Exec mode arith ovfl trap.
EPTTR2=:EPT+422		;Exec mode pdl ov trap.
EPTTR3=:EPT+423		;Exec mode trap 3 (1 proceed?).

;;; When EPT = UPT the following are useful to have defined:

EPTUUO=:EPT+UPTUUO
EPTUPC=:EPT+UPTUPC
EPTUCX=:EPT+UPTUCX
EPTUEN=:EPT+UPTUEN
EPTUET=:EPT+UPTUET
EPT1PO=:EPT+UPT1PO
EPT1PN=:EPT+UPT1PN
EPTUUN=:EPT+UPTUUN
EPTUUT=:EPT+UPTUUT

;;; In the ITS microcode the three words used to deliver a page fail are
;;; determined from the current interrupt level.  At level I, the page fail
;;; word is stored in EPTPFW+<3*I>, the old PC is stored in EPTPFO+<3*I>,
;;; and the new PC is obtained from EPTPFN+<3*I>.  If no interrupts are in
;;; progress we just use EPTPFW, EPTPFO and EPTPFN.

EPTPFW=:EPT+440		;Page fail word stored here.
EPTPFO=:EPT+441		;Page fail old PC stored here.
EPTPFN=:EPT+442		;Page fail new PC obtained from here.

IRP I,,[1,2,3,4,5,6,7]
EPTP!I!W=:EPTPFW+<3*I>
EPTP!I!O=:EPTPFO+<3*I>
EPTP!I!N=:EPTPFN+<3*I>
TERMIN

;;; 8080 communication area

8SWIT0=:30		;Simulated switch 0.  Set by 8080 SH command.
8KALIV=:31		;Keep Alive & Status.
8CTYIN=:32		;CTY input.
8CTYOT=:33		;CTY output.
8KLKIN=:34		;KLINIK user input word (from 8080).
8KLKOT=:35		;KLINIK user output word  (to 8080).
8RHBAS=:36		;BOOT RH11 base address.
8QNUM=:37		;BOOT Unit Number.
8BOOTP=:40		;Magtape Boot Format and Slave Number.

;;; 8080 front end (FE) filesystem format

;;; Disk addresses for the 8080 are stored in 36-bit words in "FE format":
;;; (These fields are larger than those given in the DEC document because
;;; the cylinder field given there is too small!  These numbers reflect the
;;; way that the 8080 manipulates 8 bit quantities instead.)
%88==:777700,,177400
%88CYL==:100,,
$88CYL==:301400,,	; 4.9 - 3.7 Cylinder
%88TRK==:400
$88TRK==:101000,,	; 2.7 - 1.9 Track
%88SEC==:1
$88SEC==:001000,,	; 1.8 - 1.1 Sector

;;; The 8080 looks for the "home sector" on cylinder 0, track 0, sector 1.
;;; If it fails to find it there it tries sector 10.  The home sector is
;;; recognized by having SIXBIT /HOM/ in location 0.  Location 103 of the
;;; home sector contains an FE format address of the first sector of the
;;; "FE directory", which is 1000 words (4 sectors) long.  Odd numbered
;;; locations in the FE directory are not looked at by the 8080.  Even
;;; numbered locations contain FE format addresses of the first sector of
;;; the various "FE files".  The following are apparently the only FE files
;;; used by the 8080:
88RAM==:2		; Microcode.  Always 6 blocks long.
			; The rest are always 1000 words long.  (1/2 block)
88BT==:4		; Bootstrap used by BT command and autoboot.
88BT1==:6		; Bootstrap used by BT1 command.
88B2==:12		; Bootstrap used by B2 command.
88FI0==:22		; First indirect file.  Contains a sequence of
			; 8-bit bytes containing ASCII characters packed
			; backwards and right justified:
			;	-------------------------------
			;	| 0's | 4th | 3rd | 2nd | 1st |
			;	-------------------------------
			; The 8080 stops on a zero byte (or perhaps 377?).
			; Lines must be no longer than 80 characters.
			; Lines are separated by a single ^M.
			;
			; Additional indirect files follow.  FIn either
			; runs the file at 88FI0+n or at 88FI0+2*n, I can't
			; tell which.

;;; Note that the only thing described here that doesn't fit inside a
;;; single ITS block is the microcode.  All we need from the filesystem are
;;; the first 2 blocks (for the home sector and the alternate home sectors)
;;; and 6 contiguous blocks elsewhere (for the microcode).

;;; External register addresses

KSECCS==:100000		;Memory Status Register (Controller 0)
%KE==:1,,520040		; Left half bits.  Right half unnamed.
			; [R=Read, W=Write, C=Cleared by writing a 1]
%KEHLD==:400000		; 4.9 Error currently being held [R/C]
%KEUNC==:200000		; 4.8 Uncorrectable error [R]
%KEREF==:100000		; 4.7 Refresh error [R/C]
%KEPAR==:040000		; 4.6 Parity error [R/W]
%KEENA==:020000		; 4.5 ECC enabled [R]
%KEECC==:017700		; 4.4 - 3.7 ECC bits [R]
%KEPWR==:000040		; 3.6 Memory backup power is low [R/C]
			; 3.4 - 1.1 Error address [R]
			; 1.8 - 1.2 Force ECC bits if non-zero [W]
			; 1.1 Disable ECC [W]

;; The 7 ECC bits are decoded as follows:  The top bit is a parity bit for
;; the bottom 6.  The bottom 6 are decoded:
;;
;; ECC code:	Location of failing bit:
;;
;; 01		ECC 01 bit
;; 02		ECC 02 bit
;; 04		ECC 04 bit
;; 10		ECC 10 bit
;; 20		ECC 20 bit
;; 40		ECC 40 bit
;; 11 - 16	4.9 - 4.4
;; 21 - 26	4.3 - 3.7
;; 31 - 36	3.6 - 3.1
;; 41 - 46	2.9 - 2.4
;; 51 - 56	2.3 - 1.7
;; 61 - 66	1.6 - 1.1

UBAPAG==:763000		;(to 763077) UBA Paging RAM (One per Unibus)
UBALEN==:64.		;Length of UBA Paging RAM
			;When read:
%UP==:1,,525377		; Left half bits.
%UPPAR==:020000		; 4.5 RAM parity bit
%UPRPW==:010000		; 4.4 Force read-pause-write
%UP16B==:004000		; 4.3 Disable upper two bits on Unibus transfers
%UPFST==:002000		; 4.2 Fast mode enable
%UPVAL==:001000		; 4.1 Entry is valid
%UPPVL==:000400		; 3.9 Parity is valid
$UPPAG==:121200,,	; 3.2 - 2.2 ITS page number
			; 2.1 ITS half page
			; 3.2 - 2.1 DEC page number
			;When written:
%UQ==:0,,537777		; Right half bits
%UQRPW==:400000		; 2.9 Force read-pause-write
%UQ16B==:200000		; 2.8 Disable upper two bits on Unibus transfers
%UQFST==:100000		; 2.7 Fast mode enable
%UQVAL==:040000		; 2.6 Entry is valid
			; 2.2 - 1.2 ITS page number
			; 1.1 ITS half page
			; 2.2 - 1.1 DEC page number

UBASTA==:763100		;UBA Status Register (One per Unibus)
			; [R=Read, W=Write, C=Cleared by writing a 1,
			;  *=Cleared by any write]
%UB==:0,,525270		; Right half bits.
%UBTIM==:400000		; 2.9 Unibus timeout [R/C]
%UBBAD==:200000		; 2.8 Bad mem data (on NPR transfer) [R/C]
			;   (Master will timeout instead if %UBDXF set)
%UBPAR==:100000		; 2.7 KS10 bus parity error [R/C]
%UBNXD==:040000		; 2.6 CPU addressed non-ex device [R/C]
%UBHIG==:004000		; 2.3 Interrupt request on BR7 or BR6 (high) [R]
%UBLOW==:002000		; 2.2 Interrupt request on BR5 or BR4 (low) [R]
%UBPWR==:001000		; 2.1 Power low [R/*]
%UBDXF==:000200		; 1.8 Disable tranfer on uncorrectable data [R/W]
%UBINI==:000100		; 1.7 Issue Unibus init [W]
%UBPIH==:000070		; 1.6 - 1.4 PI level for BR7 or BR6 (high) [R/W]
%UBPIL==:000007		; 1.3 - 1.1 PI level for BR5 or BR4 (low) [R/W]

UBAMNT==:763101		;UBA Maintenance (One per Unibus)
			; 1.2 Spare maintenance bit (?)
			; 1.1 Change NPR address (?)
