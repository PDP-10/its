<PACKAGE "CLEAN">

;<ENTRY CLEAN-GRP>

<ENTRY CLEANUP CLEAR-CLEANUP FLUSH-CLEANUP PRINT-CLEANUP>

<ENTRY PURELST>

<ENTRY PRINT-DECLS KEEP-DECLS USE-HASH>

<ENTRY FLUSH-PKG-OBLS>

<USE "PURITY">

<SETG KEEP-DECLS T>

<SETG USE-HASH T>

<NEWTYPE ASOTAB UVECTOR '<<PRIMTYPE UVECTOR> [REST LIST]>>

<NEWTYPE HASH WORD>

<SET GLUE T>

<FLOAD "MUDDLE;PUREQ NBIN">

<SETG DECL-TABLE
     '[DECL
       DECLST
       FORM
       FORMLST
       STRING
       STRLST
       VECTOR
       VECTLST
       ANY
       GENLST]>

"Returns - VECTOR of FIXes
	1	# of OBLISTs encountered
	2	# of ATOMs checked
	3	# of DECLs unique'd
	4	# of GDECLs unique'd
	5	# of RSUBRs or RSUBR-ENTRYs in purification list
"

<DEFINE CLEANUP (
		 "OPTIONAL" (PFLG <>) (CLRFLG T) (DECLFLG T) (GDECLFLG T)
			    (PURFLG T) (CHKFLG T)
				(NOBLIST <MAPF ,LIST
						<FUNCTION (ATM)
						<COND	(<GET .ATM OBLIST>)
							(ELSE <MAPRET>)>>
					'![CLEAN!-PACKAGE
					ICLEAN!-CLEAN!-PACKAGE
					PURITY!-PACKAGE
					IPURITY!-PURITY!-PACKAGE
					IPURIFY
					MUDDLE
					ERRORS
					INTERRUPTS
					PACKAGE
					RPACKAGE]>)
		 "AUX" (ASS <ASSOCIATIONS>) (OBLCNT 0) (ATMCNT 0) (DECLCNT 0)
		       (GDECLCNT 0) (PURCNT 0)
		       (IGNOBL (<ROOT> <GET MUDDLE OBLIST>))
		       (PURLST (<FORM SETG SETG ,SETG>)) (RPURLST .PURLST)
		       (RSUB ()) (PRSUB ()) (RSUBENT ()) (FCN ()) (TYPL ()) OBL
		       VAL LOCG)
   #DECL ((VALUE) <VECTOR [REST FIX]>
	  (OBLCNT ATMCNT DECLCNT GDECLCNT PURCNT) FIX
	  (PFLG CLRFLG DECLFLG GDECLFLG PURFLG CHKFLG VAL) ANY
	  (ASS) <OR ASOC FALSE> (LOCG) LOCATIVE (OBL) OBLIST
	  (NOBLIST IGNOBL) <LIST [REST OBLIST]> (PURLST RPURLST) <LIST [REST FORM]>
	  (RSUB PRSUB RSUBENT FCN) <LIST [REST ATOM]>
	  (TYPL) <LIST [REST ATOM <LIST [REST ATOM]>]>)
   <COND (.CLRFLG <CLEAR-CLEANUP>)>
   <REPEAT ()
     <COND
      (<AND <TYPE? <SET VAL <ITEM .ASS>> OBLIST> <NOT <MEMQ .VAL .NOBLIST>>>
       <SET OBL .VAL>
       <SET OBLCNT <+ 1 .OBLCNT>>
       <AND .PFLG
	    <PRINC "
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>Oblist ==> ">
	    <PRIN1 <GET .OBL OBLIST>>>
       <PROG ((OBLIST (.OBL)))
	 #DECL ((OBLIST) <SPECIAL <LIST [REST OBLIST]>>)
	 <MAPF <>
	  <FUNCTION (L) 
	     #DECL ((L) <LIST [REST <PRIMTYPE ATOM>]>)
	     <MAPF <>
	      <FUNCTION (ATMV "AUX" (ATM <CHTYPE .ATMV ATOM>) TYP AVAL VCT TMP)
		 #DECL ((ATM TYP) ATOM (VCT) <PRIMTYPE VECTOR>
			(ATMV) <PRIMTYPE ATOM>)
		 <SET ATMCNT <+ 1 .ATMCNT>>
		 <AND .PFLG <PRINT .ATM>>
		 <COND
		  (<AND <GASSIGNED? .ATM>
			<SET AVAL ,.ATM>
			<NOT <==? .ATM GROUP-PURIFY>>
			<NOT <==? .ATM KILL:PURITY>>>
		<COND	(<PUREQ .AVAL> <AND .PFLG <PRINC "	Already-purified">>)
			(ELSE
			<COND (<TYPE? .AVAL RSUBR RSUBR-ENTRY>
			  <COND (<AND .DECLFLG
				      <G=? <LENGTH <SET VCT .AVAL>> 3>
				      <TYPE? <3 .VCT> DECL>>
				 <PUT .VCT 3 <U-DECL <3 .VCT>>>
				 <SET DECLCNT <+ 1 .DECLCNT>>
				 <AND .PFLG <PRINC "	Uniqued">>)>
			  <AND .PURFLG
				<CHK-FOR-PGLUE .AVAL .PFLG>
			       <SET RPURLST
				    <REST <PUTREST .RPURLST
						   (<FORM SETG .ATM ,.ATM>)>>>
			       <SET PURCNT <+ 1 .PURCNT>>
			       .PFLG
			       <PRINC "	Purified">>)
			 (<AND .GDECLFLG
			       <NOT <MEMQ .OBL .IGNOBL>>
			       <GASSIGNED? .ATM>
			       <SET VAL <GET-DECL <SET LOCG <GLOC .ATM>>>>
			       <NOT <TYPE? .VAL ATOM FIX>>>
			  <PUT-DECL .LOCG <U-DECL .VAL>>
			  <SET GDECLCNT <+ 1 .GDECLCNT>>
			  <AND .PFLG <PRINC "	G-Uniqued">>)>)>
		   <AND .CHKFLG
			<COND (<TYPE? .AVAL RSUBR-ENTRY>
			       <SET RSUBENT (.ATM !.RSUBENT)>
			       <AND .PFLG <PRINC "	Rsubr-Entry">>)
			      (<TYPE? .AVAL FUNCTION>
			       <SET FCN (.ATM !.FCN)>
			       <AND .PFLG <PRINC "	Function">>)
			      (<TYPE? .AVAL RSUBR>
			       <COND (<TYPE? <1 .AVAL> PCODE>
				      <SET PRSUB (.ATM !.PRSUB)>
				      <AND .PFLG <PRINC "	Pure-rsubr">>)
				     (<TYPE? <1 .AVAL> CODE>
				      <SET RSUB (.ATM !.RSUB)>
				      <AND .PFLG <PRINC "	Impure-Rsubr">>)
				     (<ERROR BAD-RSUBR .ATM .AVAL>)>)
			      (<SET TMP <MEMQ <SET TYP <TYPE .AVAL>> .TYPL>>
			       <PUT .TMP 2 (.ATM !<2 .TMP>)>
			       <AND .PFLG <PRINC !\	> <PRIN1 .TYP>>)
			      (<SET TYPL (.TYP (.ATM) !.TYPL)>
			       <AND .PFLG <PRINC !\	> <PRIN1 .TYP>>)>>)>>
	      .L>>
	  .OBL>>)>
     <COND (<SET ASS <NEXT .ASS>>)
	   (ELSE
	    <SETG PURELST <REST .PURLST>>
	    <SETG RSUBLST .RSUB>
	    <SETG PRSUBLST .PRSUB>
	    <SETG RSUBENTLST .RSUBENT>
	    <SETG FCNLST .FCN>
	    <SETG TYPLST .TYPL>
	    <RETURN <SETG RETVCT
			  [.OBLCNT .ATMCNT .DECLCNT .GDECLCNT .PURCNT]>>)>>>

<DEFINE CHK-FOR-PGLUE (AVAL PFLG "AUX" PVAL)
#DECL ((AVAL) <OR RSUBR RSUBR-ENTRY>
	(PFLG) ANY
	(PVAL) RSUBR)
<COND	(<AND	<COND (<TYPE? .AVAL RSUBR> <SET PVAL .AVAL>)
		(<AND <TYPE? .AVAL RSUBR-ENTRY>
			<TYPE? <1 .AVAL> RSUBR>>
		<SET PVAL <1 .AVAL>>)
		(<AND <TYPE? .AVAL RSUBR-ENTRY>
			<TYPE? <1 .AVAL> ATOM>
			<GASSIGNED? <1 .AVAL>>
			<TYPE? <GVAL <1 .AVAL>> RSUBR>>
		<SET PVAL <GVAL <1 .AVAL>>>)>
		<COND	(<TYPE? <1 .PVAL> PCODE> <GET .PVAL PGLUE>)
			(<TYPE? <1 .PVAL> CODE> <GET .PVAL GLUE>)>>
       <COND (<CHK-FOR-GLOCS .AVAL .PFLG>)
	     (ELSE <PUT .PVAL PGLUE> <PUT .PVAL GLUE> <>)>)>>


<DEFINE CHK-FOR-GLOCS (VAL PFLG "OPTIONAL" (RECFLG <>)) 
	<COND (<MONAD? .VAL>
	       <COND (<TYPE? .VAL LOCD>
		      <AND .PFLG <PRINC "***GLOC USED***"> <PRIN1 .VAL>>
		      <>)
		     (T)>)
	      (<AND .RECFLG <TYPE? .VAL STRING RSUBR RSUBR-ENTRY CODE>>)
		(<AND <TYPE? .VAL UVECTOR> <==? <TYPEPRIM <UTYPE .VAL>> WORD>>)
	      (<MAPF <>
		     <FUNCTION (VAL) 
			     <COND (<CHK-FOR-GLOCS .VAL .PFLG T>)
				   (ELSE <MAPLEAVE <>>)>>
		     .VAL>)>>

<DEFINE U-DECL (DECL "AUX" VAL RESULT)
	#DECL ((DECL VAL) ANY)
	<SET RESULT
	     <COND (<TYPE? .DECL ATOM FIX> .DECL)
		   (,USE-HASH <SET VAL <AD-OBJECT .DECL>>)
		   (<AND <NOT ,USE-HASH>
			 <SET VAL
			      <COND (<TYPE? .DECL DECL> <MEMBER .DECL ,DECLST>)
				    (<TYPE? .DECL STRING>
				     <MEMBER .DECL ,STRLST>)
				    (<TYPE? .DECL FORM> <MEMBER .DECL ,FORMLST>)
				    (<TYPE? .DECL VECTOR>
				     <MEMBER .DECL ,VECTLST>)
				    (<MEMBER .DECL ,GENLST>)>>>
		    <1 .VAL>)>>
	<COND (<NOT <==? .RESULT .DECL>> .RESULT)
	      (<AND <==? LIST <PRIMTYPE .DECL>> <NOT <PUREQ .DECL>>>
	       <MAPR <>
		     <FUNCTION (VAL) 
			     <COND (<NOT <TYPE? <1 .VAL> ATOM FIX>>
				    <PUT .VAL 1 <U-DECL <1 .VAL>>>)>>
		     .DECL>
	       <AND ,KEEP-DECLS
		    <COND (<TYPE? .DECL FORM>
			   <SETG FORMLST <CONS .DECL ,FORMLST>>)
			  (<TYPE? .DECL DECL>
			   <SETG DECLST <CONS .DECL ,DECLST>>)
			  (<SETG GENLST <CONS .DECL ,GENLST>>)>>
	       .DECL)
	      (<TYPE? .DECL STRING>
	       <AND ,KEEP-DECLS <SETG STRLST <CONS .DECL ,STRLST>>>
	       .DECL)
	      (<AND <TYPE? .DECL VECTOR> <NOT <PUREQ .DECL>>>
	       <MAPR <>
		     <FUNCTION (VAL) 
			     <COND (<NOT <TYPE? <1 .VAL> ATOM FIX>>
				    <PUT .VAL 1 <U-DECL <1 .VAL>>>)>>
		     .DECL>
	       <AND ,KEEP-DECLS <SETG VECTLST <CONS .DECL ,VECTLST>>>
	       .DECL)
	      (<NOT <TYPE? .DECL ATOM FIX>>
	       <AND ,KEEP-DECLS <SETG GENLST <CONS .DECL ,GENLST>>>
	       .DECL)>>

<DEFINE CLEAR-CLEANUP () 
	<CREATE 1009>
	<SETG DECLST ()>
	<SETG FORMLST ()>
	<SETG STRLST '("VALUE" "OPTIONAL" "TUPLE" "ARGS" "QUOTE")>
	<SETG VECTLST ()>
	<SETG GENLST ()>
	<MAPF <>
	      ,GUNASSIGN
	      '![PURELST RSUBLST PRSUBLST RSUBENTLST FCNLST TYPLST]>>

<DEFINE FLUSH-CLEANUP () 
   <MAPF <>
    <FUNCTION (OBL) 
	    <MAPF <>
		  <FUNCTION (L) 
			  #DECL ((L) <LIST [REST <PRIMTYPE ATOM>]>)
			  <MAPF <>
				<FUNCTION (ATMV "AUX" (ATM
						       <CHTYPE .ATMV ATOM>)) 
					#DECL ((ATMV) <PRIMTYPE ATOM>
					       (ATM) ATOM)
					<GUNASSIGN .ATM>
					<UNASSIGN .ATM>>
				.L>>
		  .OBL>>
    [<GET CLEAN!-PACKAGE OBLIST> <GET ICLEAN OBLIST>]>
   <L-UNUSE "CLEAN">>

<DEFINE PRINT-CLEANUP () 
	<PRINC "A total of ">
	<PRIN1 <1 ,RETVCT>>
	<PRINC " oblists were examined,
containing a total of ">
	<PRIN1 <2 ,RETVCT>>
	<PRINC " atoms.
Out of a total of ">
	<PRIN1 <+ <LENGTH ,RSUBLST>
		  <LENGTH ,PRSUBLST>
		  <LENGTH ,RSUBENTLST>>>
	<PRINC " rsubr's found, ">
	<PRINT <3 ,RETVCT>>
	<PRINC "had their decl's uniquefied, and">
	<PRINT <5 ,RETVCT>>
	<PRINC "were added to the purification group.
">
	<PRINC "There were ">
	<PRIN1 <4 ,RETVCT>>
	<PRINC " atoms whose gdecl's were uniquefied.
">
	<PRINC "
# of VALUES	TYPE">
	<PRINT <LENGTH ,RSUBLST>>
	<PRINC "	RSUBR-Impure">
	<PRINT <LENGTH ,PRSUBLST>>
	<PRINC "	RSUBR-Pure">
	<PRINT <LENGTH ,RSUBENTLST>>
	<PRINC "	RSUBR-Entry">
	<PRINT <LENGTH ,FCNLST>>
	<PRINC "	Function">
	<MAPR <>
	      <FUNCTION (VAL) 
		      <COND (<TYPE? <1 .VAL> ATOM>
			     <PRINT <LENGTH <2 .VAL>>>
			     <PRINC !\	>
			     <PRIN1 <1 .VAL>>)>>
	      ,TYPLST>
	<CRLF>>

<DEFINE PRINT-DECLS ("OPTIONAL" (ARG1 <>) "AUX" VAL) 
	#DECL ((ARG1) <OR <LIST [REST ATOM]> ATOM FALSE> (VAL) ANY)
	<COND (<NOT .ARG1>
	       <REPEAT ((VCT ,DECL-TABLE))
		       <COND (<EMPTY? .VCT> <RETURN>)>
		       <P-DECL <1 .VCT> <2 .VCT>>
		       <SET VCT <REST .VCT 2>>>)
	      (<TYPE? .ARG1 LIST>
	       <MAPF <>
		     <FUNCTION (ATM) 
			     #DECL ((ATM) ATOM)
			     <COND (<SET VAL <MEMQ .ATM ,DECL-TABLE>>
				    <P-DECL .ATM <2 .VAL>>)>>
		     .ARG1>
	       T)
	      (<SET VAL <MEMQ .ARG1 ,DECL-TABLE>>
	       <P-DECL .ARG1 <2 .VAL>>
	       T)>>

<DEFINE P-DECL (TYP ATM "AUX" L)
	#DECL ((ATM) ATOM (L) LIST)
	<COND (<AND <TYPE? .ATM ATOM>
		    <GASSIGNED? .ATM>
		    <TYPE? ,.ATM LIST>>
	       <SET L ,.ATM>
	       <PRINC "
************************ ">
	       <PRIN1 .TYP>
	       <PRINC "******************************">
	       <MAPF <>
		     <FUNCTION (VAL) <TERPRI> <PRINC !\	> <PRIN1 .VAL>>
		     .L>
	       T)>>

<DEFINE FLUSH-PKG-OBLS (
			"OPTIONAL" (NOTLST '("PMAP" "SDML" "VCTMAN" "CPYFIL"))
			"AUX" (OBL <GET PACKAGE OBLIST>) (CNT 0))
   #DECL ((VALUE CNT) FIX (NOTLST) <LIST [REST STRING]> (OBL) OBLIST)
   <MAPF <>
	 <FUNCTION (L) 
		 #DECL ((L) <LIST [REST <PRIMTYPE ATOM>]>)
		 <MAPF <>
		       <FUNCTION (ATM "AUX" VAL) 
			       #DECL ((ATM) ATOM (VAL) STRING)
			       <COND (<MEMBER <SET VAL <PNAME .ATM>> .NOTLST>)
				     (ELSE
				      <L-UNUSE .VAL>
				      <SET CNT <+ 1 .CNT>>)>>
		       .L>>
	 .OBL>
   .CNT>

<GDECL (UNIQ.TABLE) <<PRIMTYPE UVECTOR> [REST LIST]>>

<FLOAD "MUDDLE;RGLOCS NBIN">

<FLOAD "MUDDLE;HASHER NBIN">

<DEFINE CREATE (X "OPTIONAL" (TYPC <>)) 
	#DECL ((X) FIX (VALUE) <PRIMTYPE UVECTOR> (UNIQ.SIZE) <SPECIAL FIX>)
	<SET UNIQ.SIZE .X>
	<SETG UNIQ.TABLE <IUVECTOR .X '()>>
	<COND (.TYPC <SETG UNIQ.TABLE <CHTYPE ,UNIQ.TABLE ASOTAB>>)
	      (ELSE ,UNIQ.TABLE)>>

<DEFINE AD-OBJECT (OBJ "AUX" HASHNUM REMAINDER UNIQ) 
	#DECL ((UNIQ) <OR LIST FALSE> (REMAINDER UNIQ.SIZE) FIX (HASHNUM) HASH (OBJ) ANY
	       (VALUE) ANY)
	<SET HASHNUM <HASH .OBJ>>
	<SET REMAINDER
	     <+ 1 <MOD <CHTYPE .HASHNUM FIX> .UNIQ.SIZE>>>
	<COND (<SET UNIQ <MEMBER .OBJ <NTH ,UNIQ.TABLE .REMAINDER>>>
	       <1 .UNIQ>)
	      (<PUT ,UNIQ.TABLE
		    .REMAINDER
		    (.HASHNUM .OBJ !<NTH ,UNIQ.TABLE .REMAINDER>)>
	       .OBJ)>>

;<DEFINE AD-HASH (OBJ "AUX" HASHNUM REMAINDER UNIQ) 
	#DECL ((UNIQ) <OR LIST FALSE> (REMAINDER) FIX (HASHNUM) HASH (OBJ) ANY
	       (VALUE) LIST)
	<SET HASHNUM <HASH .OBJ>>
	<SET REMAINDER
	     <+ 1 <MOD <CHTYPE .HASHNUM FIX> .UNIQ.SIZE>>>
	<COND (<SET UNIQ <MEMQ .HASHNUM <NTH ,UNIQ.TABLE .REMAINDER>>>
	       <COND (<=? .OBJ <2 .UNIQ>> (.HASHNUM <2 .UNIQ>))
		     (<REPEAT ()
			      #DECL ((VALUE) <OR FALSE LIST>)
			      <OR <SET UNIQ <MEMQ .HASHNUM <REST .UNIQ>>>
				  <RETURN <>>>
			      <AND <=? .OBJ <2 .UNIQ>>
				   <RETURN (.HASHNUM <2 .UNIQ>)>>>)
		     (<PUT ,UNIQ.TABLE
			   .REMAINDER
			   (.HASHNUM .OBJ !<NTH ,UNIQ.TABLE .REMAINDER>)>
		      <LIST .HASHNUM .OBJ>)>)
	      (<PUT ,UNIQ.TABLE
		    .REMAINDER
		    (.HASHNUM .OBJ !<NTH ,UNIQ.TABLE .REMAINDER>)>
	       <LIST .HASHNUM .OBJ>)>>

<DEFINE HASH (OBJ "AUX" (HASHNO #HASH *000000000000*)) 
   #DECL ((OBJ) ANY (VALUE HASHNO) HASH)
   <CHTYPE
    <XORB <TYPE-C <TYPE .OBJ>>
	  <COND (<OR <==? <PRIMTYPE .OBJ> STRING>
		     <==? <PRIMTYPE .OBJ> ATOM>>
		 <HASHER .OBJ>)
		(<TYPE? .OBJ LOCR> <RGLOC-CHTYPE .OBJ>)
		(<STRUCTURED? .OBJ>
		 <MAPF <>
		       <FUNCTION (X) 
			       <SET HASHNO
				    <CHTYPE <XORB .HASHNO <HASH .X>> HASH>>>
		       .OBJ>
		 .HASHNO)
		(.OBJ)>>
    HASH>>

;<DEFINE CHANGE ("OPTIONAL" (NEW <+ <* 2 .UNIQ.SIZE> 1>) "AUX" LEN CUNIQ REM) 
	#DECL ((VALUE CUNIQ) <PRIMTYPE UVECTOR> (NEW REM LEN) FIX)
	<SET CUNIQ <CHTYPE <IUVECTOR .NEW '()> <TYPE ,UNIQ.TABLE>>>
	<MAPF <>
	      <FUNCTION (LIS) 
		      #DECL ((LIS) LIST (VALUE) ATOM)
		      <SET LEN <LENGTH .LIS>>
		      <REPEAT ((N
				<COND (<TYPE? ,UNIQ.TABLE ASOTAB> <- .LEN 2>)
				      (ELSE <- .LEN 1>)>))
			      #DECL ((N) FIX (VALUE) ATOM)
			      <OR <G? .N 0> <RETURN T>>
			      <SET REM
				   <+ 1 <MOD <CHTYPE <NTH .LIS .N> FIX> .NEW>>>
			      <PUT .CUNIQ
				   .REM
				   <COND (<TYPE? ,UNIQ.TABLE ASOTAB>
					  (<NTH .LIS .N>
					   <NTH .LIS <+ .N 1>>
					   <NTH .LIS <+ .N 2>>
					   !<NTH .CUNIQ .REM>))
					 (ELSE
					  (<NTH .LIS .N>
					   <NTH .LIS <+ 1 .N>>
					   !<NTH .CUNIQ .REM>))>>
			      <COND (<TYPE? .CUNIQ ASOTAB> <SET N <- .N 3>>)
				    (ELSE <SET N <- .N 2>>)>>>
	      ,UNIQ.TABLE>
	<SET UNIQ.SIZE .NEW>
	<SETG UNIQ.TABLE .CUNIQ>>

;<DEFINE INSERT-ASSOC (OBJ
		      "OPTIONAL" (NUM #FALSE ())
		      "AUX" HASHNUM REMAINDER UNIQ)
	#DECL ((HASHNUM) HASH (REMAINDER) FIX (UNIQ) <OR LIST FALSE>)
	<SET HASHNUM <HASH .OBJ>>
	<SET REMAINDER
	     <+ 1 <MOD <CHTYPE .HASHNUM FIX> .UNIQ.SIZE>>>
	<COND (<SET UNIQ <MEMBER .OBJ <NTH ,UNIQ.TABLE .REMAINDER>>>
	       <PUT .UNIQ 2 .NUM>
	       <1 .UNIQ>)
	      (<PUT ,UNIQ.TABLE
		    .REMAINDER
		    (.HASHNUM .OBJ .NUM !<NTH ,UNIQ.TABLE .REMAINDER>)>
	       .OBJ)>>

;<DEFINE LOOKUP-ASSOC (OBJ "AUX" HASHNUM REMAINDER UNIQ) 
	#DECL ((HASHNUM) HASH (REMAINDER) FIX (UNIQ) <OR LIST FALSE>)
	<SET HASHNUM <HASH .OBJ>>
	<SET REMAINDER
	     <+ 1 <MOD <CHTYPE .HASHNUM FIX> .UNIQ.SIZE>>>
	<COND (<SET UNIQ <MEMBER .OBJ <NTH ,UNIQ.TABLE .REMAINDER>>>
	       <2 .UNIQ>)>>

<CLEAR-CLEANUP>

<ENDPACKAGE>
