"			CALNDR

For operating instructions see GCA;CALNDR DOC

Global variables:

	INPUT		current command argument string
			(next 5 PARSEd out of ,INPUT by PARSE-INPUT)
		BUFFER	association; holds text to-be-processed
			(including control characters)

	TEXT		literal from ,INPUT - appointments, etc.

	TAGTYPE		one of !\D !\W !\M !\Q !\Y, #FALSE ()

	START		minutes after 00:00

	STOP		as START

	DURATION	minutes, default.  Reset on each specification

	DATELIST	UVECTOR of dates specified in command line

	CURMOD		current mode of display (1=D, 2=M, 3=Y)
			with YEAR, MONTH, and DAY properties
			indicating the current date of display
		PREVMOD	association; previous mode of display
		DATE	association; current date

	TODAY		'=' value;  GDECL'd

	CURPOS		current cursor position - one two-list
			for each display mode (x and y components)

	POSNLIST	one four-list for each display mode;
			(x-offset x-step y-offset y-step)
			GDECL'd

	MONTHSTR	list of string representations for months
			GDECL'd

	DATA-CHAN	channel for REF and CALNDR structure
			GDECL'd

	DISPLAY-CHAN	channel for main cursor
			(also used for hardcopy output)
			GDECL'd

	HARD-CHAN	hardcopy output channel, kept open
			until exit
			GDECL'd	

	MACROS		list of SETG instructions to define
			global variables (in the `calmacs' oblist)
			which hold macro definitions.  False until
			a macro is called; then loaded from SNAME;CALNDR MACROS
			and eval'd. File replaced if used at all.


Contained within CALNDR DAT, CALNDR's database, in order:

	REF		reference month (see diagram below)

	CALNDR		list of months: main database,
			arranged as follows:

	 #CALENDAR ![#MONTH ![#DAY[] [] [] ... []]  each month holds a list for
		     #MONTH ![#DAY[] [] [] ... []]  each day of that month...
		     #MONTH ![#DAY[] [] [] ... []]
		     #MONTH ![#DAY[] [] [] ... []]  <- REF = 4; this month
		     #MONTH ![#DAY[] [] [] ... []]		(default)
				.
				.
				.
		     #MONTH ![#DAY[] [] [] ... []]]
						   \
						    list  of  (defaultly)
						    25  months,   updated
						    the  first  of   each
						    month  by  GCA;CALNDR
						    MAINT which rests off
						    the first (oldest,  3
						    ago) month and  tacks
						    on a new list of  the
						    appropriate number of
						    days.

	Days within CALNDR look like this:

#DAY [{#TAGS [5 STRING]} {#EVENT [FIX FIX STRING] #EVENT [FIX FIX STRING] ...}]

		 where {} is optional.  Events are kept sorted  according
	to times.



See also    GCA;CALNDR DOC
	    GCA;CALNDR MAINT
	    GCA;CALNDR INIT





  macro definitions first"

<DEFMAC SAFETY ()				       ;"dump calendar to disk"
	<FORM PROG ()
	      '<RESET ,DATA-CHAN>			      ;"_CLNDR > until"
	      '<GC-DUMP ,REF ,DATA-CHAN>			       ;" exit"
	      '<GC-DUMP ,CALNDR ,DATA-CHAN>>>

<DEFMAC FC ('DATE)					;"fresh copy of a date"
	<FORM BOOT DATE
	      <FORM NTH .DATE 1>
	      <FORM NTH .DATE 2>
	      <FORM NTH .DATE 3>>>

<DEFMAC CURDATE ("OPTIONAL" 'DATE)			;"get/put current date"
	<COND (<ASSIGNED? DATE>
	       <FORM PROG ()
		     <FORM PUTPROP CURMOD DATE .DATE>
		     <FORM GETPROP CURMOD DATE>>)
	      (ELSE
	       '<FC <GETPROP CURMOD DATE>>)>>  

<DEFMAC CURYAR ("OPTIONAL" 'YEAR)
	<COND (<ASSIGNED? YEAR>
	       <FORM PROG ()
		     <FORM PUTPROP CURMOD DATE
			   <FORM Y <FORM CURDATE> .YEAR>>
		     <FORM GETPROP CURMOD DATE>>)
	      (ELSE
	       <FORM NTH <FORM CURDATE> 1>)>>

<DEFMAC CURMON ("OPTIONAL" 'MONTH)
	<COND (<ASSIGNED? MONTH>
	       <FORM PROG ()
		     <FORM PUTPROP CURMOD DATE
			   <FORM M <FORM CURDATE> .MONTH>>
		     <FORM GETPROP CURMOD DATE>>)
	      (ELSE
	       <FORM NTH <FORM CURDATE> 2>)>>

<DEFMAC CURDAY ("OPTIONAL" 'DAY)
	<COND (<ASSIGNED? DAY>
	       <FORM PROG ()
		     <FORM PUTPROP CURMOD DATE
			   <FORM D <FORM CURDATE> .DAY>>
		     <FORM GETPROP CURMOD DATE>>)
	      (ELSE
	       <FORM NTH <FORM CURDATE> 3>)>>

<DEFMAC DATE-SET ('INTO 'FROM)
	<FORM PROG ()
	      <FORM PUT .INTO 1 <FORM NTH .FROM 1>>
	      <FORM PUT .INTO 2 <FORM NTH .FROM 2>>
	      <FORM PUT .INTO 3 <FORM NTH .FROM 3>>>>

<DEFMAC Y ('DATE "OPTIONAL" 'YEAR)
	<COND (<ASSIGNED? YEAR>
	       <FORM PUT .DATE 1 .YEAR>)
	      (ELSE
	       <FORM NTH .DATE 1>)>>

<DEFMAC M ('DATE "OPTIONAL" 'MONTH)
	<COND (<ASSIGNED? MONTH>
	       <FORM PUT .DATE 2 .MONTH>)
	      (ELSE
	       <FORM NTH .DATE 2>)>>

<DEFMAC D ('DATE "OPTIONAL" 'DAY)
	<COND (<ASSIGNED? DAY>
	       <FORM PUT .DATE 3 .DAY>)
	      (ELSE
	       <FORM NTH .DATE 3>)>>

<DEFMAC PREVMOD ("OPTIONAL" 'MODE) 
	<COND (<ASSIGNED? MODE>
	       <FORM PUTPROP CURMOD PREVMOD .MODE>)
	      (ELSE
	       <FORM GETPROP CURMOD PREVMOD>)>>

<DEFMAC BUFFER ("OPTIONAL" 'TEXT)			;"get/put input buffer"
	<COND (<ASSIGNED? TEXT>
	       <FORM PUTPROP INPUT BUFFER .TEXT>)
	      (ELSE
	       <FORM GETPROP INPUT BUFFER>)>>

<DEFMAC BUFF ('MORE)					 ;"add to input buffer"
	<FORM BUFFER <FORM STRING '<BUFFER> .MORE>>>

<DEFMAC FFUB ('EROM)				;"add to front of input buffer"
	<FORM BUFFER <FORM STRING .EROM '<BUFFER>>>>

<DEFMAC CHOP ('ATM "OPTIONAL" ('AMT 1))
	<FORM SET .ATM
	      <FORM CHTYPE
		    <FORM REST <FORM LVAL .ATM> .AMT>
		    <FORM TYPE <FORM LVAL .ATM>>>>>

<DEFMAC GCHOP ('ATM "OPTIONAL" ('AMT 1))		  ;"to complement CHOP"
	<FORM SETG .ATM
	      <FORM CHTYPE
		    <FORM REST <FORM GVAL .ATM> .AMT>
		    <FORM TYPE <FORM GVAL .ATM>>>>> 

<DEFMAC X-POS ("OPTIONAL" 'VALU ('MODE ',CURMOD)) ;"get/put current x position" 
	<COND (<ASSIGNED? VALU>		   ;"as a function of the display mode"
	       <FORM SETG			   ;"in units as per ,POSNLIST"
		     CURPOS
		     <FORM PUT
			   <FORM GVAL CURPOS>
			   .MODE
			   <FORM PUT
				 <FORM NTH <FORM GVAL CURPOS> .MODE>
				 1
				 .VALU>>>)
	      (ELSE
	       <FORM NTH <FORM NTH <FORM GVAL CURPOS> .MODE> 1>)>>    

<DEFMAC Y-POS ("OPTIONAL" 'VALU ('MODE ',CURMOD)) 
	<COND (<ASSIGNED? VALU>
	       <FORM SETG
		     CURPOS
		     <FORM PUT
			   <FORM GVAL CURPOS>
			   .MODE
			   <FORM PUT
				 <FORM NTH <FORM GVAL CURPOS> .MODE>
				 2
				 .VALU>>>)
	      (ELSE
	       <FORM NTH <FORM NTH <FORM GVAL CURPOS> .MODE> 2>)>>

<DEFMAC UPDATE-DISPLAY ()		      ;"clean sweep over entire screen"
	<FORM PROG ()
	      '<APPLY ,<NTH [DAY MONTH YEAR] ,CURMOD>>	 ;"invoke display subr"
	      <EXPAND '<PREVMOD ,CURMOD>>		   ;"and set prevmod">>

<DEFMAC ^ ('STR) <FORM CHTYPE .STR COMMAND-STRING>>  ;"show carets in commands"

;"initialize the environment"

<PROG ()
      <NEWTYPE COMMAND-STRING STRING '<PRIMTYPE STRING>>
      <PRINTTYPE
       COMMAND-STRING
       <FUNCTION (STR) #DECL ((STR) COMMAND-STRING)
		 <MAPF <>
		       <FUNCTION (C) #DECL ((C) CHARACTER)
				 <PRINC <COND (<AND <N=? <ASCII .C> *033*>
						    <L? <ASCII .C> 32>>
					       <PRINC "^">
					       <ASCII
						<+ <ASCII .C>
						   <ASCII !\A> -1>>)
					      (.C)>>>
		       .STR>
		 .STR>>
      <NEWTYPE DATE UVECTOR '!<UVECTOR [3 FIX]>>		   ;"![y m d!]"
      <PRINTTYPE
       DATE
       <FUNCTION (D) #DECL ((D) DATE)
		 <PRINC <PDATE .D>>>>
      <NEWTYPE EVENT VECTOR '<VECTOR [2 FIX] STRING>>
      <NEWTYPE TAGS VECTOR '<VECTOR [5 STRING]>>
      <NEWTYPE DAY VECTOR '<OR <VECTOR [REST EVENT]>
			       <VECTOR TAGS [REST EVENT]>>>
      <NEWTYPE MONTH UVECTOR '<UVECTOR [REST DAY]>>
      <NEWTYPE CALENDAR UVECTOR '<UVECTOR [REST MONTH]>>
      <DEFINE BOOT (TYPE "TUPLE" TUP)			;"Build Object Of Type"
	      #DECL ((TYPE) ATOM
		     (TUP) TUPLE)
	      <CHTYPE <,<TYPEPRIM .TYPE> !.TUP> .TYPE>>
      <GDECL (INPUT)			STRING
	     (TODAY)			DATE
	     (CURMOD REF STOP)		FIX
	     (START)			<OR FIX FALSE>
	     (MONTHSTR)			!<LIST [24 STRING]>
	     (CURPOS)			!<LIST [3 !<LIST FIX FIX>]>
	     (POSNLIST)			!<LIST [3 !<LIST [4 FIX]>]>
	     (CALNDR)			CALENDAR
	     (DATELIST)			<UVECTOR [REST DATE]>
	     (DURATION)			FIX
	     (TEXT)			STRING
	     (TAGTYPE)			<OR STRING CHARACTER FALSE>
	     (DISPLAY-CHAN DATA-CHAN HARD-CHAN)	<OR CHANNEL FALSE>
	     (MACROS)			<OR FALSE <LIST [REST FORM]>>>
      <USE "DATIME" "MACROS" "TTY" "JCL" "SORTX">
      <DECL-CHECK 'T>
      <SETG DURATION 30>			    ;"initial duration default"
      <SETG START %<>>
      <SETG TEXT "">
      <SETG INPUT "">
      <PREVMOD 1>					       ;"previous mode"
      <SETG CURMOD 1>					;"initial display: DAY"
      <SETG CURPOS ((0 0) (0 0) (0 0))>			    ;"per display mode"
      <SETG POSNLIST '((0 0 0 0) (4 11 3 3) (5 24 3 3))>
      <SETG MONTHSTR
    '("Jan" "Feb" "Mar" "Apr" "May" "Jun" "Jul" "Aug" "Sep" "Oct" "Nov" "Dec"
      "JAN" "FEB" "MAR" "APR" "MAY" "JUN" "JUL" "AUG" "SEP" "OCT" "NOV" "DEC")>
      <SETG MACROS %<>>
      <GUNASSIGN HARD-CHAN>	 ;"assigned when opened and open when assigned"
      <FLOAD "GCA;CRUFT NBIN">				      ;"thanks to TAA">

"Controlling function for calendar system -
  invoke with <CALENDAR>$"

<DEFINE CALENDAR ("AUX" TEMP "ACT" RUFFLED)
	#DECL ((TEMP) ANY
	       (RUFFLED) ACTIVATION)

	;"initialize and load old calendar"

	<SNAME <UNAME>>					;"user's database only"
	<SETG TODAY <FC <DATE>>>
	<CURDATE <FC ,TODAY>>			  ;"start out looking at today"
	<BUFFER <COND (<READJCL>) (ELSE "")>>		  ;"incoming info here"
	<AND <NOT <FILE-EXISTS? "CALNDR DAT">>		     ;"if no database,"
	     <AND <NOT <DECL? <SET TEMP <LPARSE ,INPUT>> '<LIST FIX FIX>>>
		  <SET TEMP '(25 4)>>
	     <FLOAD "GCA;INIT >">				  ;" make one"
	     <INIT <NTH .TEMP 1> <NTH .TEMP 2>>
	     <GUNASSIGN INIT>>
	<SETG DATA-CHAN <OPEN "READB" "CALNDR DAT">>	   ;"retrieve database"
	<SETG REF <GC-READ ,DATA-CHAN>>		       ;"this month in ,CALNDR"
	<SETG CALNDR <GC-READ ,DATA-CHAN>>		   ;"calendar database"
	<CLOSE ,DATA-CHAN>
	<SETG DATA-CHAN <OPEN "PRINTB" "_CLNDR >">>	   ;"temporary-updated"
	<REOPEN>				   ;"send outchan to echo area"
	<SCML 4 ,INCHAN>				        ;"input window"
	<SETG DISPLAY-CHAN <OPEN "PRINT" "TTY:">>	;"pretty pictures here"
	<PUT ,DISPLAY-CHAN 13 *277777777777*>		  ;"avoid system cr/lf"
	<PUT .OUTCHAN 13 *277777777777*>		 ;"(also to echo area)"
	<TTYECHO ,INCHAN %<>>			   ;"reenable echo by QUITting"
	<TYI>						    ;"drop pending esc"
	<UPDATE-DISPLAY>

 	<REPEAT (CHAR "ACT" MAIN)
		#DECL ((CHAR) CHARACTER (MAIN) ACTIVATION)
		<SET CHAR <DEBUFFER>>			      ;"text to ,INPUT"
		<CASE ,==? .CHAR
		      (%<ASCII *021*>				    ;"^Q, quit"
		       <CLEAN-QUIT>)
		      (%<ASCII *027*>			   ;"^W, list macro(s)"
		       <LIST-MACROS>)
		      (%<ASCII *030*>		      ;"^X, do or define macro"
		       <FFUB <COND (<GET-MACRO-DEFN>) (ELSE "")>>
		       <AGAIN .MAIN>)
		      (%<ASCII *031*>			    ;"^Y, delete macro"
		       <FORGET-MACRO>
		       <AGAIN .MAIN>)
		      DEFAULT
		      (<WARN <PRESTIDIGITATE .CHAR>>
		       <FFUB ,INPUT>) ;"if input not processed, restore it.">>>

<DEFINE CLEAN-QUIT ()
	<ECHO "Quit">
	<SAFETY>
	<CLOSE ,DATA-CHAN>
	<RENAME "CALNDR DAT">
	<RENAME "_CLNDR >" TO "CALNDR DAT">
	<AND ,MACROS
	     <SET CHAN <OPEN "PRINT" "CALNDR MACROS">>
	     <PPRINT ,MACROS .CHAN>
	     <CLOSE .CHAN>>
	<AND <GASSIGNED? HARD-CHAN>
	     <CLOSE ,HARD-CHAN>
	     <NOT <SETG HARD-CHAN %<>>>		         ;"here we come, WARN!"
	     <AND <WARN "Tipple hardcopy (space for yes)? " !\ >
		  <FILECOPY <OPEN "READ" "_HCAL >">
			    <OPEN "PRINT" <STRING ".LPTR.;" <SNAME> " ^H">>>
		  <RENAME "_HCAL >">>>
	<PRNT "C">
	<QUIT>>

<DEFINE DEBUFFER ("AUX" CHAR)
	#DECL ((CHAR) CHARACTER)
	<SET CHAR %<ASCII *041*>>					;">040"
	<SETG INPUT
	      <MAPR ,STRING
		    <FUNCTION (STR)
			      #DECL ((STR) STRING)
			      <AND <L? <ASCII <SET CHAR <NTH .STR 1>>> *037*>
				   <BUFFER <REST .STR>>
				   <MAPSTOP>>
			      .CHAR>
		    <BUFFER>>>
	<COND (<L? <ASCII .CHAR> *040*>
	       .CHAR)
	      (ELSE
	       <ECHO <^ <BUFFER>>>
	       <KBI>)>>

<DEFINE KBI ("AUX" CHAR)
	#DECL ((CHAR) CHARACTER)
	<REPEAT (TEMP)
		#DECL ((TEMP) ANY)
		<SET CHAR <TYI>>
		<CASE ,==? .CHAR
		      (%<ASCII *177*>
		       <COND (<0? <SET TEMP <LENGTH <BUFFER>>>>		 ;"del"
			      <ECHO %<ASCII *007*>>)
			     (ELSE
			      <PRINC <NDEL <NTH <BUFFER> .TEMP>>>
			      <BUFFER
			       <SUBSTRUC <BUFFER> 0 <- .TEMP 1>>>)>)
		      (%<ASCII *026*> <ECHO <^ <BUFFER>>>)
		      (%<ASCII *012*> <BUFFER ""> <ECHO "">)
		      (%<ASCII *035*>				   ;"^], quote"
		       <PRINC <^ <STRING <SET TEMP <TYI>>>>>
		       <BUFF .TEMP>)
		      DEFAULT
		      (<COND (<L? <ASCII .CHAR> *040*>
			      <BUFF .CHAR>
			      <RETURN <DEBUFFER>>)
			     (ELSE
			      <PRINC .CHAR>    ;"echo 'normal' characters here"
			      <BUFF .CHAR>)>)>>>

"macro handling routines"

<DEFINE GET-MACRO-DEFN ("AUX" NAME MACDEF "ACT" G-M-D)
	#DECL ((NAME) ATOM
	       (MACDEF) <OR STRING FORM>
	       (G-M-D) ACTIVATION)
	<AND <OR <=? ,INPUT "">
		 <N=?
		  <TYPE <SET NAME <PARSE <STRING ,INPUT "!-calmacs">>>>
		  ATOM>>
	     <WARN "Unusable macro name">
	     <SETG INPUT "">
	     <RETURN %<> .G-M-D>>
	<AND <NOT ,MACROS>
	     <LOAD-MACROS>>
	<COND (<GASSIGNED? .NAME>
	       <SETG INPUT "">
	       <RETURN ,.NAME .G-M-D>)
	      (ELSE
	       <SET MACDEF "">
	       <PRINC ": ">
	       <REPEAT (CHAR TEMP)
		       #DECL ((CHAR) CHARACTER (TEMP) ANY)
		       <SET CHAR <TYI>>
		       <CASE ,==? .CHAR
			     (%<ASCII *030*> <RETURN>)	      ;"^X gets us out"
			     (%<ASCII *012*> <SET MACDEF ""> <RETURN>);"^J fub"
			     (%<ASCII *026*>
			      <ECHO <^ <STRING ,INPUT ": " .MACDEF>>>)
			     (%<ASCII *177*>
			      <COND (<0? <SET TEMP <LENGTH .MACDEF>>>
				     <PRINC %<ASCII *007*>>)
				    (ELSE
				     <PRINC <NDEL <NTH .MACDEF .TEMP>>>
				     <SET MACDEF
					  <SUBSTRUC .MACDEF 0 <- .TEMP 1>>>)>)
			     (%<ASCII *035*>
			      <PRINC <^ <STRING <SET TEMP <TYI>>>>>
			      <SET MACDEF <STRING .MACDEF .TEMP>>)
			     DEFAULT
			     (<PRINC <^ <STRING .CHAR>>>
			      <SET MACDEF <STRING .MACDEF .CHAR>>)>>
	       <COND (<=? .MACDEF "">			;"delete or abort defn"
		      <REMOVE .NAME>
		      <SETG INPUT "">
		      <RETURN %<> .G-M-D>)
		     (ELSE
		      <EVAL <SET MACDEF <FORM SETG .NAME .MACDEF>>>
		      <SETG MACROS (!,MACROS .MACDEF)>
		      <RETURN ,INPUT .G-M-D>)>)>>

<DEFINE FORGET-MACRO ("AUX" NAME "ACT" F-M)
	#DECL ((NAME) ANY
	       (F-M) ACTIVATION)			;"returns T regardless"
	<AND <OR <=? ,INPUT "">
		 <N=?
		  <TYPE <SET NAME <PARSE <STRING ,INPUT "!-calmacs">>>>
		  ATOM>>
	     <WARN "Unusable macro name">
	     <SETG INPUT "">
	     <RETURN 'T .F-M>>
	<COND (,MACROS		    ;"is this method or the serial one better?"
	       <COND (<GASSIGNED? .NAME>
		      <AND <NOT
			    <WARN
			     <STRING "Space to undefine " ,INPUT " -"> !\ >>
			   <RETURN 'T .F-M>>
		      <REMOVE .NAME>
		      <REPEAT ((COUNT 1))
			      #DECL ((COUNT) FIX)
			      <AND <=? <NTH <NTH ,MACROS .COUNT> 2> .NAME>
				   <SETG MACROS
					 <LIST !<SUBSTRUC ,MACROS 0
							  <- .COUNT 1>>
					       !<REST ,MACROS .COUNT>>>>
			      <AND <G? <SET COUNT <+ 1 .COUNT>>
				       <LENGTH ,MACROS>>
				   <RETURN>>>
		      <RETURN 'T .F-M>)
		     (ELSE
		      <WARN <STRING "Macro " ,INPUT " undefined">>
		      <SETG INPUT "">
		      <RETURN 'T .F-M>)>)
	      (ELSE
	       <LOAD-MACROS>
	       <FORGET-MACRO>)>>

<DEFINE LIST-MACROS ("AUX" (MACRO-NAMELIST [])
			   MACRO-ALIST
			   OB
		     "ACT" L-M)
	#DECL ((MACRO-NAMELIST) <VECTOR [REST STRING]>
	       (MACRO-ALIST) <VECTOR [REST ATOM]>
	       (OB) <OR FALSE OBLIST>
	       (L-M) ACTIVATION)
	<AND <NOT ,MACROS>
	     <LOAD-MACROS>>
	<AND <OR <NOT <SET OB <GETPROP calmacs OBLIST>>>
		 <PROG ()
		       <MAPF %<>
			     <FUNCTION (L) #DECL ((L) <LIST [REST ATOM]>)
				       <MAPF %<>
					     <FUNCTION (A) #DECL ((A) ATOM)
						       <SET MACRO-NAMELIST
							    [<MACRO-PNAME .A>
							     !.MACRO-NAMELIST]>>
					     .L>>
			     .OB>
		       <EMPTY? .MACRO-NAMELIST>>>
	     <WARN "No macros defined">
	     <SETG INPUT "">
	     <RETURN 'T .L-M>>
	<SORT %<> .MACRO-NAMELIST>
	<SET MACRO-ALIST
	     <MAPF ,VECTOR
		   <FUNCTION (N) #DECL ((VALUE) ATOM (N) STRING)
			     <PARSE <STRING .N "!-calmacs">>>
		   .MACRO-NAMELIST>>
	<PRNT "C">
	<PRNTCRLF><PRNTCRLF><PRNTCRLF>
	<REPEAT ("ACT" RL1A)
		<REPEAT ((COUNT 20))
			<PRNT <NTH .MACRO-NAMELIST 1>>
			<PRNT ":	">				 ;":^I"
			<PRNT <^ ,<NTH .MACRO-ALIST 1>>>
			<PRNTCRLF>
			<COND (<EMPTY? <CHOP MACRO-NAMELIST>>
			       <WARN "Restore -" %<ASCII *040*>>
			       <RETURN %<> .RL1A>)>
			<CHOP MACRO-ALIST>
			<AND <0? <SET COUNT <- .COUNT 1>>>
			     <RETURN %<>>>>
		<AND <NOT <WARN "More definitions -" %<ASCII *040*>>>
		     <RETURN %<> .RL1A>>>
	<UPDATE-DISPLAY>>

<DEFINE MACRO-PNAME (A)				 ;"drop !-calmacs for printing"
	#DECL ((VALUE) STRING
	       (A) ATOM)
	<SUBSTRUC <UNPARSE .A> 0 <- <INSTR <UNPARSE .A> !\!> 1>>>

<DEFINE LOAD-MACROS ("AUX" CHAN)
	#DECL ((CHAN) CHANNEL)
	<COND (<FILE-EXISTS? "CALNDR MACROS">			    ;"editable"
		    <SET CHAN <OPEN "READ" "CALNDR MACROS">>
		    <SETG MACROS <READ .CHAN>>
		    <CLOSE .CHAN>
		    <EVAL ,MACROS>)			    ;"load definitions"
		   (ELSE			   ;"predefined macros go here"
		    <SETG MACROS
'(<SETG z!-calmacs "(\" *\") (\"Z\");use ^R if tomorrow is sunday">
  <SETG m!-calmacs "(\" *\") (\"M\")">
  <SETG t!-calmacs "(\" *\") (\"T\")">
  <SETG w!-calmacs "(\" *\") (\"W\")">
  <SETG r!-calmacs "(\" *\") (\"R\")">
  <SETG f!-calmacs "(\" *\") (\"F\")">
  <SETG s!-calmacs "(\" *\") (\"S\")">
  <SETG tnx!-calmacs "(1-nov \"&&&R\") D">)>
		    <EVAL ,MACROS>)>>

"supporting functions"

<DEFINE PRESTIDIGITATE (OPERATION
			"AUX" TEMP
			"ACT" TOTOPLEV)
     #DECL ((OPERATION) CHARACTER
	    (TEMP) ANY
	    (TOTOPLEV) <SPECIAL ACTIVATION>)
     <CASE ,==? .OPERATION
      DEFAULT
      (<RETURN "Unrecognized control" .TOTOPLEV>)
      (%<ASCII *025*>
       <CURSOR-UP>)
      (%<ASCII *004*>
       <CURSOR-DOWN>)
      (%<ASCII *014*>
       <CURSOR-LEFT>)
      (%<ASCII *022*>
       <CURSOR-RIGHT>)
      (%<ASCII *011*>					   ;"^I, modebounce in"
       <SETG CURMOD <+ ,CURMOD -1 <* 3 </ 1 ,CURMOD>>>> <UPDATE-DISPLAY>)
      (%<ASCII *017*>					  ;"^O, modebounce out"
       <SETG CURMOD <+ ,CURMOD 1 <* -3 </ ,CURMOD 3>>>> <UPDATE-DISPLAY>)
      (%<ASCII *001*>						     ;"^A, add"
       <ADD-APPOINTMENTS>)
      (%<ASCII *005*>						   ;"^E, erase"
       <DEL-APPOINTMENTS>)
      (%<ASCII *006*>						    ;"^F, find"
       <FIND-EVENTS>)
      (%<ASCII *024*>						     ;"^T, tag"
       <TAG-DATES>)
      (%<ASCII *033*>						  ;"$, display"
       <DISPLAY-DATES>)
      (%<ASCII *020*>			;"^P, permanent entry  (done by maint)"
       <RETURN "Soon, but not implemented yet." .TOTOPLEV>
       <SET TEMP ,INPUT>
       <PARSE-INPUT>)
      (%<ASCII *000*>				     ;"^@, change current date"
       <CHANGE-CURRENT-DEFAULTS>)
      (%<ASCII *010*>					 ;"^H, hardcopy output"
       <APPEND-HARDCOPY>)>
     %<>							  ;"no errors">

<DEFINE CURSOR-UP ("AUX" TEMP (DATE <CURDATE>))
	#DECL ((TEMP) FIX (DATE) DATE)
	<CASE ,==? ,CURMOD				       ;"^U, cursor up"
	      (1
	       <REPEAT ((CNT 7))			   ;"different strokes"
		       #DECL ((CNT) FIX)
		       <AND <DECCURDATE>
			    <RETURN "Out of bounds - Up" .TOTOPLEV>>
		       <AND <0? <SET CNT <- .CNT 1>>> <RETURN>>>
	       <UPDATE-DISPLAY>)
	      (2
	       <REPEAT ((CNT 7))
		       #DECL ((CNT) FIX)
		       <AND <DECCURDATE>
			    <RETURN "Out of bounds - Up" .TOTOPLEV>>
		       <AND <0? <SET CNT <- .CNT 1>>> <RETURN>>>
	       <SET TEMP <- <Y-POS> 1>>
	       <Y-POS .TEMP>
	       <COND (<L? .TEMP 0> <UPDATE-DISPLAY>)
		     (ELSE <PUTCURSOR>)>)
	      (3
	       <AND <L? <M <M .DATE <- <CURMON> 3>>> 1>
		    <M .DATE <+ 12 <M .DATE>>>
		    <Y .DATE <- <Y .DATE> 1>>>
	       <COND (<DATECHK .DATE>
		      <RETURN "Out of bounds - Up" .TOTOPLEV>)
		     (ELSE
		      <CURYAR <Y .DATE>>
		      <CURMON <M .DATE>>
		      <SET TEMP <- <Y-POS> 1>>
		      <Y-POS .TEMP>
		      <COND (<G? .TEMP -1>
			     <PUTCURSOR>)
			    (ELSE <UPDATE-DISPLAY>)>)>)>>

<DEFINE CURSOR-DOWN ("AUX" TEMP (DATE <CURDATE>))
	#DECL ((TEMP) FIX (DATE) DATE)
	<CASE ,==? ,CURMOD				     ;"^D, cursor down"
	      (1
	       <REPEAT ((CNT 7))
		       #DECL ((CNT) FIX)
		       <AND <INCCURDATE>
			    <RETURN "Out of bounds - Down" .TOTOPLEV>>
		       <AND <0? <SET CNT <- .CNT 1>>> <RETURN>>>
	       <UPDATE-DISPLAY>)
	      (2
	       <REPEAT ((CNT 7))
		       #DECL ((CNT) FIX)
		       <AND <INCCURDATE>
			    <RETURN "Out of bounds - Down" .TOTOPLEV>>
		       <AND <0? <SET CNT <- .CNT 1>>> <RETURN>>>
	       <SET TEMP <+ 1 <Y-POS>>>
	       <Y-POS .TEMP>
	       <COND (<G? .TEMP 4>
		      <UPDATE-DISPLAY>)
		     (ELSE <PUTCURSOR>)>)
	      (3
	       <AND <G? <M <M .DATE <+ <CURMON> 3>>> 12>
		    <M .DATE <- <M .DATE> 12>>
		    <Y .DATE <+ <Y .DATE> 1>>>
	       <COND (<DATECHK <D <FC .DATE> 1>>
		      <RETURN "Out of bounds - Down" .TOTOPLEV>)
		     (ELSE
		      <CURYAR <Y .DATE>>
		      <CURMON <M .DATE>>
		      <SET TEMP <+ 1 <Y-POS>>>
		      <Y-POS .TEMP>
		      <COND (<L? .TEMP 4>
			     <PUTCURSOR>)
			    (ELSE <UPDATE-DISPLAY>)>)>)>>

<DEFINE CURSOR-LEFT ("AUX" TEMP (DATE <CURDATE>))
	#DECL ((TEMP) FIX (DATE) DATE)
	<CASE ,==? ,CURMOD				     ;"^L, cursor left"
	      (1
	       <COND (<DECCURDATE>
		      <RETURN "Out of bounds - Left" .TOTOPLEV>)
		     (ELSE <UPDATE-DISPLAY>)>)
	      (2
	       <COND (<DECCURDATE>
		      <RETURN "Out of bounds - Left" .TOTOPLEV>)
		     (ELSE
		      <SET TEMP <- <X-POS> 1>>
		      <COND (<G? .TEMP -1>
			     <X-POS .TEMP> <PUTCURSOR>)
			    (ELSE
			     <X-POS 6>
			     <SET TEMP <- <Y-POS> 1>>
			     <Y-POS .TEMP>
			     <COND (<L? .TEMP 0>
				    <UPDATE-DISPLAY>)
				   (ELSE <PUTCURSOR>)>)>)>)
	      (3
	       <AND <0? <M <M .DATE <- <CURMON> 1>>>>
		    <M .DATE 12>
		    <Y .DATE <- <Y .DATE> 1>>>
	       <COND (<DATECHK .DATE>
		      <RETURN "Out of bounds - Left" .TOTOPLEV>)
		     (ELSE
		      <CURYAR <Y .DATE>>
		      <CURMON <M .DATE>>
		      <SET TEMP <- <X-POS> 1>>
		      <COND (<G? .TEMP -1>
			     <X-POS .TEMP> <PUTCURSOR>)
			    (ELSE
			     <X-POS 2>
			     <SET TEMP <- <Y-POS> 1>>
			     <Y-POS .TEMP>
			     <COND (<L? .TEMP 0>
				    <UPDATE-DISPLAY>)
				   (ELSE <PUTCURSOR>)>)>)>)>>

<DEFINE CURSOR-RIGHT ("AUX" TEMP (DATE <CURDATE>))
	#DECL ((TEMP) FIX (DATE) DATE)
	<CASE ,==? ,CURMOD				    ;"^R, cursor right"
	      (1
	       <COND (<INCCURDATE>
		      <RETURN "Out of bounds - Right" .TOTOPLEV>)
		     (ELSE
		      <UPDATE-DISPLAY>)>)
	      (2
	       <COND (<INCCURDATE>
		      <RETURN "Out of bounds - Right" .TOTOPLEV>)
		     (ELSE
		      <SET TEMP <+ 1 <X-POS>>>
		      <COND (<L? .TEMP 7>
			     <X-POS .TEMP> <PUTCURSOR>)
			    (ELSE
			     <X-POS 0>
			     <SET TEMP <+ <Y-POS> 1>>
			     <Y-POS .TEMP>
			     <COND (<G? .TEMP 4>
				    <UPDATE-DISPLAY>)
				   (ELSE <PUTCURSOR>)>)>)>)
	      (3
	       <AND <G? <M <M .DATE <+ 1 <CURMON>>>> 12>
		    <M .DATE 1>
		    <Y .DATE <+ 1 <Y .DATE>>>>
	       <COND (<DATECHK .DATE>
		      <RETURN "Out of bounds - Right" .TOTOPLEV>)
		     (ELSE
		      <CURYAR <Y .DATE>>
		      <CURMON <M .DATE>>
		      <SET TEMP <+ 1 <X-POS>>>
		      <COND (<L? .TEMP 3>
			     <X-POS .TEMP> <PUTCURSOR>)
			    (ELSE
			     <X-POS 0>
			     <SET TEMP <+ 1 <Y-POS>>>
			     <Y-POS .TEMP>
			     <COND (<G? .TEMP 3>
				    <UPDATE-DISPLAY>)
				   (ELSE <PUTCURSOR>)>)>)>)>>

<DEFINE ADD-APPOINTMENTS ("AUX" TEMP
				ERR)
	#DECL ((TEMP) ANY
	       (ERR) <OR STRING FALSE>)
	<PARSE-INPUT>
	<COND (<NOT ,START> <RETURN "Time needed" .TOTOPLEV>)
	      (<G? <+ 1 ,START> ,STOP>
	       <RETURN "Curfew after midnight" .TOTOPLEV>)
	      (ELSE
	       <SET TEMP ,CURMOD>
	       <SETG CURMOD 1>
	       <MAPF %<>
		<FUNCTION (DATE) #DECL ((DATE) DATE)
			  <CURDATE .DATE>
			  <AND <SET ERR <ADD>>
			       <NOT <WARN
				     <STRING .ERR " * space to resume -">
				     %<ASCII *040*>>>
			       <MAPSTOP>>
			  <AND <=? ,TAGTYPE !\Y> <UPDATE-DISPLAY>>>
		,DATELIST>
	       <COND (<AND .ERR <N=? ,TAGTYPE !\Y> <N=? .TEMP 1>>
		      <UPDATE-DISPLAY>
		      <RETURN .ERR .TOTOPLEV>)
		     (ELSE
		      <COND (<N=? ,TAGTYPE !\Y>
			     <AND <=? .TEMP 1> <UPDATE-DISPLAY>>)
			    (<N=? .TEMP 1>
			     <SETG CURMOD .TEMP>
			     <UPDATE-DISPLAY>)>)>)>>

<DEFINE DEL-APPOINTMENTS ("AUX" TEMP
				ERR)
	#DECL ((TEMP) ANY
	       (ERR) <OR STRING FALSE>)
	<PARSE-INPUT>
	<COND (<AND ,START <G? <+ 1 ,START> ,STOP>>
	       <RETURN "Negative duration?" .TOTOPLEV>)
	      (ELSE
	       <SET TEMP ,CURMOD>
	       <SETG CURMOD 1>
	       <MAPF %<>
		<FUNCTION (DATE) #DECL ((DATE) DATE)
			  <CURDATE .DATE>
			  <AND <SET ERR <ERASE>>
			       <NOT <WARN
				     <STRING .ERR " * space to resume -">
				     %<ASCII *040*>>>
			       <MAPSTOP>>
			  <AND <=? ,TAGTYPE !\Y> <UPDATE-DISPLAY>>>
		,DATELIST>
	       <COND (<AND .ERR <N=? ,TAGTYPE !\Y> <N=? .TEMP 1>>
		      <UPDATE-DISPLAY>
		      <RETURN .ERR .TOTOPLEV>)
		     (ELSE
		      <COND (<N=? ,TAGTYPE !\Y>
			     <AND <=? .TEMP 1> <UPDATE-DISPLAY>>)
			    (<N=? .TEMP 1>
			     <SETG CURMOD .TEMP>
			     <UPDATE-DISPLAY>)>)>)>>

<DEFINE FIND-EVENTS ()
	<PARSE-INPUT>
	<MAPF %<>
	 <FUNCTION (DATE) #DECL ((DATE) DATE)
		   <RETURN "Not yet" .TOTOPLEV>>
	 ,DATELIST>
	<RETURN "Search failed." .TOTOPLEV>>

<DEFINE TAG-DATES ("AUX" (PREVDATE <CURDATE>))
	#DECL ((PREVDATE) DATE)
	<PARSE-INPUT>
	<COND (ELSE					;"pre-err checks here"
	       <MAPF %<>
		<FUNCTION (DATE "AUX" TEMP) #DECL ((DATE) DATE (TEMP) ANY)
			  <CURDATE .DATE>
			  <CHTAG>>
		,DATELIST>
	       <CASE ,==? ,CURMOD
		     (1 <UPDATE-DISPLAY>)
		     (2  ;"this pays attention only to last change!!"
		      <COND (<OR <N=? <M .PREVDATE> <CURMON>>
				 <N=? <Y .PREVDATE> <CURYAR>>
				 <=? ,TAGTYPE !\D>
				 <AND <=? ,TAGTYPE !\W>
				      <=? "Sun" <PDAY <CURDATE>>>>
				 <AND <=? ,TAGTYPE !\M>
				      <=? <CURDAY> 1>>>
			     <UPDATE-DISPLAY>)
			    (ELSE
			     <SET TEMP
				  <+ <DAYSBETWEEN
				      "SUN"
				      <LC-TO-UC
				       <PDAY
					<D <CURDATE> 1>>>>
				     <CURDAY>
				     -1>>
			     <X-POS <MOD .TEMP 7>>
			     <Y-POS </ .TEMP 7>>
			     <PUTCURSOR>)>)
		     (3 <COND (<OR <N=? <Y .PREVDATE> <CURYAR>>
				   <=? ,TAGTYPE !\M>
				   <AND <=? ,TAGTYPE !\Q>
					<=? <CURMON> 1>
					<=? <MOD <CURMON> 3> 1>>
				   <AND <=? ,TAGTYPE !\Y>
					<=? <CURDAY> 1>
					<=? <CURMON> 1>>>
			       <UPDATE-DISPLAY>)
			      (ELSE
			       <SET TEMP <- <CURMON> 1>>
			       <X-POS <MOD .TEMP 3>>
			       <Y-POS </ .TEMP 3>>
			       <PUTCURSOR>)>)>)>>

<DEFINE DISPLAY-DATES ("AUX" (PREVDATE <CURDATE>))
	#DECL ((PREVDATE) DATE)
	<COND
	 (<=? ,INPUT "?">
	  <SETG INPUT "">
	  <PRNT "C">
	  <PRNTCRLF "	?[esc]	This brief command summary
		For more detailed information, :INFO CALENDAR
	^V	Verify (retype) input
	[lf]	Delete input
	^U	Move cursor up
	^D	Move cursor down
	^R	Move cursor right
	^L	Move cursor left
	^I	Modebounce in
	^O	Modebounce out
	^A	Add entry to calendar
	^E	Erase entry from calendar
	^T	Tag
	[esc]	Update display
	^]	Quote
	^@	Change current date (no display update)
	^H	Hardcopy output (to _HCAL >)
	^Q	Quit
">
	  <WARN "Restore -" !\ >
	  <UPDATE-DISPLAY>)
	 (ELSE
	  <PARSE-INPUT>
	  <PREVMOD ,CURMOD>
	  <AND ,TAGTYPE
	       <SETG CURMOD <+ 1 </ <INSTR "DWMQY" ,TAGTYPE> 2>>>>
	  <MAPF %<>
	   <FUNCTION (DATE) #DECL ((DATE) DATE)
		     <SET PREVDATE <CURDATE>>
		     <CURDATE .DATE>
		     <COND
		      (<N=? <PREVMOD> ,CURMOD>
		       <UPDATE-DISPLAY>)
		      (ELSE
		       <CASE ,==? ,CURMOD
			     (1
			      <COND (<OR <N=? <Y .PREVDATE> <CURYAR>>
					 <N=? <M .PREVDATE> <CURMON>>
					 <N=? <D .PREVDATE> <CURDAY>>>
				     <UPDATE-DISPLAY>)>)
			     (2
			      <COND (<OR <N=? <Y .PREVDATE> <CURYAR>>
					 <N=? <M .PREVDATE> <CURMON>>>
				     <UPDATE-DISPLAY>)
				    (ELSE
				     <SET TEMP
					  <+ <DAYSBETWEEN "SUN"
							  <LC-TO-UC
							   <PDAY <D <CURDATE> 1>>>>
					     <CURDAY>
					     -1>>
				     <X-POS <MOD .TEMP 7>>
				     <Y-POS </ .TEMP 7>>
				     <PUTCURSOR>)>)
			     (3
			      <COND (<N=? <Y .DATE> <CURYAR>>
				     <UPDATE-DISPLAY>)
				    (ELSE
				     <SET TEMP <- <CURMON> 1>>
				     <X-POS <MOD .TEMP 3>>
				     <Y-POS </ .TEMP 3>>
				     <PUTCURSOR>)>)>)>
		     <AND <NOT <WARN "Space to continue -" !\ >>
			  <RETURN %<> .TOTOPLEV>>>;"not quite right"
	   ,DATELIST>)>>

<DEFINE CHANGE-CURRENT-DEFAULTS ()
	<PARSE-INPUT>
	<AND ,TAGTYPE
	     <PREVMOD ,CURMOD>
	     <SETG CURMOD <+ 1 </ <INSTR "DWMQY" ,TAGTYPE> 2>>>>
	<AND <N=? <LENGTH ,DATELIST> 1>
	     <RETURN "One date only" .TOTOPLEV>>
	<CURDATE <NTH ,DATELIST 1>>>

<DEFINE APPEND-HARDCOPY ("AUX" TEMP)
	#DECL ((TEMP) CHANNEL)
	<PARSE-INPUT>
	<ECHO "(Working)">
	<PUTPROP TEMP MODE ,CURMOD>
	<AND ,TAGTYPE
	     <SETG CURMOD <+ 1 </ <INSTR "DWMQY" ,TAGTYPE> 2>>>>
	<AND <NOT <GASSIGNED? HARD-CHAN>>
	     <SETG HARD-CHAN <OPEN "PRINT" "_HCAL >">>>
	<SET TEMP ,DISPLAY-CHAN>		  ;"put normal display on hold"
	<SETG DISPLAY-CHAN ,HARD-CHAN>
	<MAPF %<>
	 <FUNCTION (DATE) #DECL ((DATE) DATE)
		   <CURDATE .DATE>
		   <UPDATE-DISPLAY>>
	 ,DATELIST>
	<SETG CURMOD <GETPROP TEMP MODE>>
	<SETG DISPLAY-CHAN .TEMP>
	<ECHO ,INPUT>>

<DEFINE PARSE-INPUT ("AUX" (DATE <CURDATE>)
			   STOPDATE
			   TEMP
			   (ERR %<>)
		     "ACT" PARSED)
   #DECL ((VALUE) <OR STRING FALSE>
	  (DATE STOPDATE) <OR DATE FALSE>
	  (TEMP) ANY
	  (ERR) <OR STRING CHARACTER FALSE>
	  (PARSED) ACTIVATION)
   <AND <=? ,INPUT ""> <SETG INPUT ";">>
   <SETG DATELIST <IUVECTOR 0>>
   <SETG START %<>>
   <SETG STOP 0>
   <SETG TAGTYPE %<>>		 ;"let each routine alter this as it sees fit."
   <AND <MEMBER !\; ,INPUT>
	<SETG INPUT
	      <SUBSTRUC ,INPUT 0
			<- <LENGTH ,INPUT>
			   <LENGTH <SETG TEXT <REST <MEMBER !\; ,INPUT>>>>
			   1>>>>
   <SETG INPUT <LC-TO-UC ,INPUT>>			   ;"deal only with uc"
   <SET PARSD <LPARSE ,INPUT>>					        ;"Hmmm"
   <AND <EMPTY? .PARSD>		      ;"if nothing at all, assume current date"
	<SETG DATELIST <UVECTOR <CURDATE>>>
	<SETG INPUT "">
	<RETURN %<> .PARSED>>
   <REPEAT (ELEM PRVER "ACT" RL1A)
     #DECL ((ELEM) ANY (PRVER) STRING (RL1A) ACTIVATION)
     <SET ELEM <NTH .PARSD 1>>				  ;"ponder one element"
     <CHOP PARSD>						  ;" at a time"
     <CASE ,TYPE? .ELEM
      (!'(FIX FLOAT)					  ;"fixes are duration"
       <SETG DURATION <FIX <+ .5 .ELEM>>>)			  ;"(round up)"
      (ATOM						   ;"atoms are varied:"
       <SET PRVER <PNAME .ELEM>>
       <COND (<MEMBER !\- .PRVER>			 ;" a date (hence NN-)"
	      <SET DATE <CURDATE>>
	      <UNPDATE .PRVER .DATE>
	      <SETG DATELIST <UVECTOR !,DATELIST <FC .DATE>>>)
	     (<MEMBER !\: .PRVER>				     ;" a time"
	      <COND (<NOT ,START> <SETG START <MINS .PRVER>>)
		    (<SETG STOP <MINS .PRVER>>)>)
	     (<AND						  ;" a tagtype"
		   <1? <LENGTH .PRVER>> <MEMBER .PRVER "DWMQY">>
	      <SETG TAGTYPE <NTH .PRVER 1>>)
	     (<AND						  ;" a weekday"
		   <NOT <FIND-WEEKDAY .PRVER .DATE>>
		   <SETG DATELIST <UVECTOR !,DATELIST <FC .DATE>>>>)
	     (<=? "=" .PRVER>					 ;" or to-day."
	      <SETG DATELIST <UVECTOR !,DATELIST <FC ,TODAY>>>)
	     (ELSE
	      <SETG INPUT ""> <RETURN <STRING "???: " .PRVER> .TOTOPLEV>)>)
      (LIST						   ;"lists are compact"
       <SET STOPDATE %<>>				       ;"stopping date"
       <SET DATE %<>>				         ;"date representation"
       <SET PATTRN "*......">
       <SET REPS 0>
       <REPEAT (SUBELEM (ERR %<>) "ACT" RL2A)
	       #DECL ((SUBELEM) ANY (ERR) <OR STRING CHARACTER FALSE>
		      (RL2A) ACTIVATION)
	       <COND (<EMPTY? .ELEM> <RETURN .ERR .RL2A>)
		     (ELSE
		      <SET SUBELEM <NTH .ELEM 1>> <CHOP ELEM>)>
	       <CASE ,TYPE? .SUBELEM
		     (FIX <SET REPS .SUBELEM>)
		     (STRING <SET PATTRN .SUBELEM>)
		     (ATOM
		      <COND (<=? = .SUBELEM>
			     <SET DATE <FC ,TODAY>>)
			    (<NOT <0? <INSTR <PNAME .SUBELEM> !\->>>
			     <COND (<NOT .DATE>;"first date is starting date"
				    <SET DATE <CURDATE>>
				    <UNPDATE <PNAME .SUBELEM> .DATE>)
				   (ELSE    ;"further dates are stop date"
				    <SET STOPDATE <CURDATE>>
				    <UNPDATE <PNAME .SUBELEM> .STOPDATE>)>)
			    (.STOPDATE
			     <NOT
			      <FIND-WEEKDAY <PNAME .SUBELEM> .STOPDATE>>)
			    (.DATE
			     <NOT
			      <FIND-WEEKDAY <PNAME .SUBELEM> .DATE>>)>)
		     DEFAULT
		     (<SETG INPUT "">
		      <RETURN <STRING "(?): " .SUBELEM> .TOTOPLEV>)>>
       <AND <NOT .DATE>				   ;"if no startdate, default"
	    <SET DATE <CURDATE>>>
       <AND <NOT .STOPDATE>   ;"if no stopdate and no reps default to one rep"
	    <0? .REPS>
	    <SET REPS 1>>		  ;"default to one pattern repetition"
       <COND (<MEMBER "*" .PATTRN>			;"pattern -> datelist"
	      <REPEAT ((AMPRSND 1))			   ;"expand &'s first"
		      #DECL ((AMPRSND) FIX)
		      <AND <0? <SET AMPRSND <INSTR .PATTRN !\& .AMPRSND>>>
			   <COND (<0? <MOD <LENGTH .PATTRN> 7>>
				  <RETURN>)
				 (ELSE
				  <SET AMPRSND
				       <LENGTH <SET PATTRN
						    <STRING .PATTRN !\&>>>>)>>
		      <SET PATTRN		       ;"fill out rest of week"
			   <STRING
			    <SUBSTRUC .PATTRN 0 <- .AMPRSND 1>>
			    <REST "......."
				  <MOD <- .AMPRSND 1> 7>>
			    <REST .PATTRN .AMPRSND>>>>
	      <REPEAT ("ACT" RL2B)
		      #DECL ((RL2B) ACTIVATION)
		      <REPEAT ((P 1) "ACT" RL3A)
			      #DECL ((P) FIX (RL3A) ACTIVATION)
			      <AND <=? !\* <NTH .PATTRN .P>>
				   <SETG DATELIST
					 <UVECTOR !,DATELIST <FC .DATE>>>>
			      <AND .STOPDATE	     ;"stopdate<=current date?"
				   <OR <L? <Y .STOPDATE> <Y .DATE>>
				       <AND <=? <Y .STOPDATE> <Y .DATE>>
					    <L? <M .STOPDATE> <M .DATE>>>
				       <AND <=? <Y .STOPDATE> <Y .DATE>>
					    <=? <M .STOPDATE> <M .DATE>>
					    <L=? <D .STOPDATE> <D .DATE>>>>
				   <RETURN %<> .RL2B>>
			      <AND <INCDATE .DATE>
				   <SETG INPUT "">
				   <RETURN "(?) Expansion" .TOTOPLEV>>
			      <COND (<G? <SET P <+ 1 .P>> <LENGTH .PATTRN>>
				     <RETURN %<> .RL3A>)>>
		      <AND <0? <SET REPS <- .REPS 1>>>
			   <RETURN %<> .RL2B>>>)
	     (ELSE
	      <SET PATTRN <STRING .PATTRN !\&>>
	      <REPEAT ((DOW <+ 1
			       </ <- 21
				     <LENGTH <MEMBER <PDAY .DATE>
						     "SunMonTueWedThuFriSat">>>
				  3>>)
		       (DAYS "ZMTWRFS")
		       "ACT" RL2B)
		      <REPEAT ((OFFSET 1)
			       (NXTAMPRSND <INSTR .PATTRN !\&>)
			       "ACT" RL3A)
			      <REPEAT ((COUNT 7)
				       "ACT" RL4A)
				      <AND
				       <NOT <0? <SET TEMP
						     <INSTR .PATTRN
							    <NTH .DAYS .DOW>
							    .OFFSET>>>>
				       <L? .TEMP .NXTAMPRSND>
				       <SETG DATELIST
					     <UVECTOR !,DATELIST <FC .DATE>>>>
				      <AND <INCDATE .DATE>
					   <SETG INPUT "">
					   <RETURN "(?) Expansion" .TOTOPLEV>>
				      <SET DOW
					   <+ 1 .DOW <* -7 </ .DOW 7>>>>
				      <AND <0? <SET COUNT <- .COUNT 1>>>
					   <RETURN %<> .RL4A>>>
			      <SET OFFSET <+ 1 .NXTAMPRSND>>
			      <AND <0? <SET NXTAMPRSND
					    <INSTR .PATTRN !\& .OFFSET>>>
				   <RETURN %<> .RL3A>>>
		      <AND <0? <SET REPS <- .REPS 1>>>
			   <RETURN %<> .RL2B>>>)>)
      DEFAULT
      (<SETG INPUT "">
       <RETURN <STRING "???: " <UNPARSE .ELEM>> .TOTOPLEV>)>
     <AND <EMPTY? .PARSD>
	  <SETG INPUT "">
	  <RETURN .ERR .RL1A>>>
   <AND <EMPTY? ,DATELIST>				        ;"current date"
	<SETG DATELIST <UVECTOR <CURDATE>>>>
   <AND ,START <0? ,STOP>
	<SETG STOP <+ ,START ,DURATION>>>
   <SETG INPUT "">					   ;"no parsing errors"
   %<>>

<DEFINE PUTCURSOR ()	       ;"top left is 0,0; x increases to the right and"
	<PRNT "T">					    ;"y increases down"
	<PRNT <STRING "V"			  ;"and both depend on ,CURMOD"
		      <ASCII <+ 8
				<NTH <NTH ,POSNLIST ,CURMOD> 3>
				<* <Y-POS>
				   <NTH <NTH ,POSNLIST ,CURMOD> 4>>>>>>
	<PRNT <STRING "H"
		      <ASCII <+ 8
				<NTH <NTH ,POSNLIST ,CURMOD> 1>
				<* <X-POS>
				   <NTH <NTH ,POSNLIST ,CURMOD> 2>>>>>>>    

<DEFINE DAY ("AUX" (HARD? <N=? <NTH ,DISPLAY-CHAN 5> "TTY">)      ;"DAY dislay"
		   (DATE <CURDATE>)
		   (DAYLIST <DAYLIST .DATE>)
		   (TAGLIST <TAGLIST .DATE>)
		   (TAGNAMES "*DWMQY")
		   (LINECT 21)
		   (UNDERLINE
"+-------+-------+------------------------------------------------------------+"))
	#DECL ((DATE) DATE
	       (DAYLIST) DAY
	       (TAGLIST) <OR FALSE TAGS>
	       (TAGNAMES UNDERLINE) STRING
	       (LINECT) FIX
	       (HARD?) <OR FALSE ATOM>)
	<PRNT <COND (.HARD? %<ASCII *014*>)
		    (ELSE "C")>>
	<PRNTCRLF <STRING "				- "
			  <PDAY .DATE>
			  ", "
			  <PDATE .DATE>
			  " -"
			  %<ASCII *012*>>>
	<AND .TAGLIST
	     <PRNTCRLF "      *Tags*">
	     <SET LINECT <- .LINECT 1>>
	     <MAPF <>
		   <FUNCTION (STR) #DECL ((STR) STRING)
			     <CHOP TAGNAMES>
			     <AND <N=? .STR "">
				  <PRNTCRLF <STRING
					     "  "
					     <NTH .TAGNAMES 1>
					     ": " .STR>>
				  <SET LINECT <- .LINECT 1>>>>
		   .TAGLIST>>
	<PRNTCRLF "
| start | stop  |  event ...">
	<REPEAT (EVENT START STOP TEXT)
		#DECL ((START STOP) FIX (TEXT) STRING)
		<COND (<EMPTY? .DAYLIST> <PRNTCRLF .UNDERLINE> <RETURN>)>
		<SET EVENT <NTH .DAYLIST 1>>
		<SET START <NTH .EVENT 1>>
		<SET STOP <NTH .EVENT 2>>
		<AND <=? <LENGTH <SET TEXT <NTH .EVENT 3>>> 0>
		     <SET TEXT " ">>		      ;"cover for modulo error"
		<CHOP DAYLIST>
		<PRNTCRLF .UNDERLINE>
		<SET TEXT
		     <STRING .TEXT
			     <ISTRING <MOD <- 5900 <LENGTH .TEXT>> 59> !\ >>>
		<REPEAT ((CNT 0))
			#DECL ((CNT) FIX)
			<PRNTCRLF <STRING "| "
					  <COND (<0? .CNT> <PTIME .START>)
						(ELSE "     ")>
					  " | "
					  <COND (<0? .CNT> <PTIME .STOP>)
						(ELSE "     ")>
					  " | "
					  <SUBSTRUC .TEXT 0 59>
					  "|">>
			<SET LINECT <- .LINECT 1>>
			<SET CNT <+ 1 .CNT>>
			<AND <0? <LENGTH <CHOP TEXT 59>>>
			     <RETURN>>>
		<AND <L=? <SET LINECT <- .LINECT 2>> 0>
		     <PRNTCRLF .UNDERLINE>
		     <AND <NOT .HARD?>
			  <COND (<WARN <STRING "-- more of "
					       <PDATE .DATE>
					       " --">
				       !\ >
				 <SET LINECT 28>
				 <PRNT "C">)
				(ELSE <RETURN>)>>>>>  

<DEFINE MONTH ("AUX" (HARD? <N=? <NTH ,DISPLAY-CHAN 5> "TTY">)
		     (DATE <CURDATE>)
		     (UNKNOWN 0) TEMP NTEMP
		     (UNDERLINE
"+----------+----------+----------+----------+----------+----------+----------+"))
   #DECL ((DATE) DATE
	  (UNKNOWN) <OR FIX FALSE>
	  (TEMP NTEMP) ANY
	  (UNDERLINE) STRING
	  (HARD?) <OR FALSE ATOM>)
   <D .DATE 1>
   <PRNT <COND (.HARD? %<ASCII *014*>)
	       (ELSE "C")>>
   <PRNTCRLF <STRING "				  - "
		     <REST <PDATE .DATE> 3> " -">>
   <COND (<SET TEMP <TAGLIST .DATE>>
	  <PRNTCRLF <NTH .TEMP 3>>)
	 (                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                D <0? <SET COL <- .COL 1>>> <RETURN>>>
     <PRNTCRLF>
     <PRNTCRLF
      <COND
       (<AND <NOT <DATECHK .DATE>>
	     <SET TEMP <TAGLIST .DATE>>>
	<SET TEMP <NTH .TEMP 2>>
	<COND (<N=? .TEMP "">
	       <STRING <SUBSTRUC .UNDERLINE
				 0
				 <SET NTEMP </ <- 75 <LENGTH .TEMP>> 2>>>
		       "^ "
		       .TEMP
		       " ^"
		       <REST .UNDERLINE <+ .NTEMP <LENGTH .TEMP> 4>>>)
	      (.UNDERLINE)>)
       (ELSE .UNDERLINE)>>
     <AND <0? <SET ROW <- .ROW 1>>> <RETURN>>
     <SET DATE <FC .TDATE>>>>

<DEFINE YEAR ("AUX" (HARD? <N=? <NTH ,DISPLAY-CHAN 5> "TTY">)
		    (DATE <CURDATE>)
		    TDATE TEMP NTEMP
		    (UNDERLINE
"+-----------------------+-----------------------+-----------------------+"))
   #DECL ((DATE TDATE) DATE
	  (TEMP NTEMP) ANY
	  (UNDERLINE) STRING
	  (HARD?) <OR FALSE 'T>)
   <M .DATE 1>
   <D .DATE 1>
   <PRNT <COND (.HARD? %<ASCII *014*>)
	       (ELSE "C")>>
   <PRNTCRLF <STRING "				- '"
		     <PAD <UNPARSE <Y .DATE>>>
		     " -">>
   <COND (<AND <NOT <DATECHK .DATE>>
	       <SET TEMP <TAGLIST .DATE>>>
	  <PRNTCRLF <NTH .TEMP 5>>)
	 (ELSE <PRNTCRLF>)>
   <PRNTCRLF .UNDERLINE>
   <REPEAT ((ROW 4))
     #DECL ((ROW) FIX)
     <REPEAT ((COL 3))
	     #DECL ((COL) FIX)
	     <PRNT "| ">
	     <COND (<DATECHK .DATE> <PRNT "???">)
		   (ELSE
		    <PRNT <NTH ,MONTHSTR <M .DATE>>>
		    <AND <=? <M .DATE> <CURMON>>
			 <X-POS <- 3 .COL>>
			 <Y-POS <- 4 .ROW>>>)>
	     <PRNT "                   ">
	     <AND <0? <SET COL <- .COL 1>>>
		  <M .DATE <- <M .DATE> 2>>
		  <RETURN>>
	     <M .DATE <+ <M .DATE> 1>>>
     <PRNTCRLF "|">
     <REPEAT ((COL 3))
	     #DECL ((COL) FIX)
	     <PRNT "|">
	     <PRNT <SUBSTRUC
		    <STRING <COND (<AND <NOT <DATECHK .DATE>>
					<SET TEMP <TAGLIST .DATE>>>
				   <NTH .TEMP 3>)
				  (ELSE "")>
			    "                                 ">
		    0
		    23>>
	     <M .DATE <+ 1 <M .DATE>>>
	     <AND <0? <SET COL <- .COL 1>>>
		  <RETURN>>>
     <PRNTCRLF "|">
     <SET TDATE <FC .DATE>>
     <PRNTCRLF
      <COND
       (<AND <NOT <DATECHK <M .TDATE <- <M .DATE> 3>>>>
	     <SET TEMP <TAGLIST .TDATE>>>
	<SET TEMP <NTH .TEMP 4>>
	<COND (<N=? .TEMP "">
	       <STRING <SUBSTRUC .UNDERLINE
				 0
				 <SET NTEMP </ <- 69 <LENGTH .TEMP>> 2>>>
		       "^ "
		       .TEMP
		       " ^"
		       <REST .UNDERLINE <+ .NTEMP <LENGTH .TEMP> 4>>>)
	      (.UNDERLINE)>)
       (ELSE .UNDERLINE)>>
     <AND <0? <SET ROW <- .ROW 1>>>
	  <RETURN>>>>    

<DEFINE UNPDATE (STR DATE "AUX" TEMP)		   ;"string -> numeric"
	#DECL ((VALUE) <OR STRING FALSE>
	       (STR) STRING
	       (DATE) DATE
	       (TEMP) FIX)
	;"unspec'd parts default to entry DATE"
	<COND (<L? <LENGTH .STR> 5>
	       <SET STR <SUBSTRUC .STR 0 <- <LENGTH .STR> 1>>>
	       <AND <OR <=? .STR ""> <NOT <TYPE? <PARSE .STR> FIX>>>
		    <SETG INPUT "">
		    <RETURN <STRING "NN- expected: " .STR> .TOTOPLEV>>
	       <D .DATE <PARSE .STR>>)
	      (ELSE
	       <AND <0? <SET TEMP <INSTR .STR !\- 2>>>
		    <SETG INPUT "">
		    <RETURN "Date format is YY-Mmm-DD" .TOTOPLEV>>
	       <D .DATE <PARSE <SUBSTRUC .STR 0 <- .TEMP 1>>>>
	       <CHOP STR .TEMP>
	       <AND <NOT <0? <SET TEMP <INSTR .STR !\- 2>>>>
		    <Y .DATE <PARSE <REST .STR .TEMP>>>
		    <SET STR <SUBSTRUC .STR 0 <- .TEMP 1>>>>
	       <AND <0? <SET TEMP <LENGTH <MEMBER .STR ,MONTHSTR>>>>
		    <SETG INPUT "">
		    <RETURN <STRING "Nonmonth: " .STR> .TOTOPLEV>>
	       <M .DATE <+ 1 <MOD <- <LENGTH ,MONTHSTR> .TEMP> 12>>>)>
	<AND <DATECHK .DATE>
	     <SETG INPUT "">
	     <RETURN <STRING "Invalid date: " <PDATE .DATE>> .TOTOPLEV>>>

<DEFINE DATECHK (DATE "AUX" (MONUM <MONTHNUM .DATE>))	       ;"date illegal?"
	#DECL ((VALUE) <OR 'T FALSE>
	       (DATE) DATE
	       (MONUM) FIX)
	<COND (<OR <0? <Y .DATE>>
		   <0? <M .DATE>>
		   <0? <D .DATE>>
		   <L=? .MONUM 0>
		   <G? .MONUM <LENGTH ,CALNDR>>
		   <G? <D .DATE> <LENGTH <NTH ,CALNDR .MONUM>>>>
	       T)
	      (ELSE %<>)>>

<DEFINE ADD ("AUX" (DATE <CURDATE>)			  ;"add an appointment"
		   (DAYLIST <DAYLIST .DATE>)
		   (LEN <LENGTH .DAYLIST>)
	     "ACT" ADD)
	#DECL ((DATE) DATE
	       (LEN) FIX
	       (DAYLIST) DAY
	       (ADD) ACTIVATION)
	<COND (<0? .LEN>			        ;"beat boundary condns"
	       <CHANGE-DAYLIST
		.DATE
		<BOOT DAY
		 <BOOT EVENT ,START ,STOP ,TEXT>>>
	       <RETURN %<> .ADD>)
	      (<L=? ,STOP <NTH <NTH .DAYLIST 1> 1>>
	       <CHANGE-DAYLIST
		.DATE
		<SQUEEZEIN .DAYLIST 0
			   <BOOT EVENT ,START ,STOP ,TEXT>>>
	       <RETURN %<> .ADD>)
	      (<G=? ,START <NTH <NTH .DAYLIST .LEN> 2>>
	       <CHANGE-DAYLIST .DATE
			       <SQUEEZEIN .DAYLIST .LEN
				<BOOT EVENT ,START ,STOP ,TEXT>>>
	       <RETURN %<> .ADD>)>
	<REPEAT ((BUSY 1) START STOP)
		#DECL ((BUSY START STOP) FIX)
		<SET START <NTH <NTH .DAYLIST 1> 1>>
		<SET STOP <NTH <NTH .DAYLIST 1> 2>>
		<COND (<OR <AND <G? ,START .START>
				<L? ,START .STOP>>
			   <AND <G? ,STOP .START>
				<L? ,STOP .STOP>>
			   <AND <L=? ,START .START>
				<G=? ,STOP .STOP>>>
		       <RETURN <STRING "Conflicts with "
				       <PTIME .START>
				       " "
				       <PTIME .STOP>
				       " ;"
				       <NTH <NTH .DAYLIST 1> 3>>>)
		      (<AND <G=? ,START .STOP>
			    <L=? ,STOP <NTH <NTH .DAYLIST <+ 1 .BUSY>> 1>>>
		       <CHANGE-DAYLIST .DATE
				       <SQUEEZEIN .DAYLIST .BUSY
					<BOOT EVENT ,START ,STOP ,TEXT>>>
		       <RETURN %<> .ADD>)>
		<SET BUSY <+ 1 .BUSY>>>>   
 
<DEFINE SQUEEZEIN (VEC POS "TUPLE" NEWELS)		   ;"NEWELS after .POS"
	#DECL ((VEC) <PRIMTYPE VECTOR>				 ;"limited use"
	       (POS) FIX
	       (NEWELS) TUPLE)
	<BOOT <TYPE .VEC>
	 !<SUBSTRUC .VEC 0 .POS> !.NEWELS !<REST .VEC .POS>>>    

<DEFINE ERASE ("AUX" (DATE <CURDATE>)			   ;"erase appointment"
		     (DAYLIST <DAYLIST .DATE>)
	       "ACT" ERASE)
	#DECL ((DATE) DATE
	       (DAYLIST) DAY
	       (ERASE) ACTIVATION)
	<AND <EMPTY? .DAYLIST>
	     <RETURN
	      <STRING <PDATE .DATE> " free day; nothing to delete">
	      .ERASE>>
	<REPEAT ((TEMP <BOOT DAY>)
		 (ERR
		  <STRING "Not found: "
			  <PDATE .DATE>
			  <COND (,START <STRING " " <PTIME ,START>>)
				(ELSE "")>
			  ";" ,TEXT>))
		#DECL ((TEMP) DAY
		       (ERR) <OR STRING FALSE>)
		<COND (<AND <COND (<0? <LENGTH ,TEXT>> T)
				  (ELSE <MEMBER ,TEXT <NTH <NTH .DAYLIST 1> 3>>)>
			    <COND (<NOT ,START>)
				  (ELSE <=? <NTH <NTH .DAYLIST 1> 1> ,START>)>
			    <WARN <STRING "Space to delete "
					  <PDATE .DATE> "  "
					  <PTIME <NTH <NTH .DAYLIST 1> 1>> " "
					  <PTIME <NTH <NTH .DAYLIST 1> 2>> " ;"
					  <NTH <NTH .DAYLIST 1> 3>>
				  !\ >
			    <NOT <SET ERR %<>>>>)
		      (ELSE
		       <SET TEMP
			    <BOOT DAY
				   !.TEMP
				   <BOOT EVENT
					 !<NTH .DAYLIST 1>>>>)>
		<AND <EMPTY? <CHOP DAYLIST>>
		     <CHANGE-DAYLIST .DATE .TEMP>
		     <RETURN .ERR .ERASE>>>>

<DEFINE CHTAG ("AUX" (DATE <CURDATE>)
		     (TAGLIST <TAGLIST .DATE>)
	       "ACT" TAGOUT)
	#DECL ((DATE) DATE
	       (TAGLIST) <OR FALSE TAGS>
	       (TAGOUT) ACTIVATION)
	<PUT <COND (.TAGLIST)
		   (ELSE <SET TAGLIST <BOOT TAGS !<IVECTOR 5 "">>>)>
	     <COND (,TAGTYPE
		    <INSTR "DWMQY" ,TAGTYPE>)
		   (ELSE <- <* 2 ,CURMOD> 1>)>
	     ,TEXT>
	<CHANGE-TAGLIST .DATE <COND (<=? .TAGLIST #TAGS ["" "" "" "" ""]>
				     %<>)
				    (ELSE .TAGLIST)>>
	%<>>   

<DEFINE LOCDAY (DATE)						   ;"easy way?"
	#DECL ((DATE) DATE)
	<AT <IN <AT ,CALNDR <MONTHNUM .DATE>>> <D .DATE>>>   

<DEFINE GETDAY (DATE)					    ;"get list for day"
	#DECL ((DATE) DATE)
	<IN <LOCDAY .DATE>>> 

<DEFINE PUTDAY (DATE LIST)				     ;"replace daylist"
	#DECL ((DATE) DATE
	       (LIST) DAY)
	<SETLOC <LOCDAY .DATE> .LIST>> 
 
<DEFINE DAYLIST (DATE "AUX" (DAYLIST <GETDAY .DATE>))
	#DECL ((VALUE DAYLIST) DAY
	       (DATE) DATE)
	<COND (<AND <NOT <0? <LENGTH .DAYLIST>>>	;"if tags are present,"
		    <DECL? <NTH .DAYLIST 1> TAGS>>		   ;"drop them"
	       <CHTYPE <REST .DAYLIST> DAY>);"boot?"
	      (ELSE .DAYLIST)>>

<DEFINE CHANGE-DAYLIST (DATE "OPTIONAL" (DAYLIST <BOOT DAY>)
			     "AUX" (TAGLIST <TAGLIST .DATE>))
	#DECL ((DATE) DATE
	       (DAYLIST) DAY
	       (TAGLIST) <OR TAGS FALSE>)
	<PUTDAY .DATE
		<COND (.TAGLIST <BOOT DAY .TAGLIST !.DAYLIST>)
		      (ELSE .DAYLIST)>>
	T>

<DEFINE PRCNT-USED (DATE "AUX" (EVENTLIST <DAYLIST .DATE>) (TOTAL 0))
	#DECL ((VALUE) FIX
	       (DATE) DATE
	       (EVENTLIST) DAY
	       (TOTAL) FIX)
	<SET TOTAL
	     <MAPF ,+ <FUNCTION (E) #DECL ((E) EVENT)
				<COND (<=? <NTH <NTH .E 3> 1> !\!> 0)
				      (<- <NTH .E 2> <NTH .E 1>>)>>
		   .EVENTLIST>>
	<MIN <FIX <+ .5 <* 100. </ <FLOAT .TOTAL> %<* 8. 60.>>>>> 99>>

<DEFINE TAGLIST (DATE "AUX" (TEMP <GETDAY .DATE>));"note: date presumed valid!"
	#DECL ((VALUE) <OR TAGS FALSE>
	       (TEMP) DAY)
	<COND (<AND <NOT <EMPTY? .TEMP>>
		    <DECL? <NTH .TEMP 1> TAGS>>
	       <NTH .TEMP 1>)
	      (ELSE %<>)>>

<DEFINE CHANGE-TAGLIST (DATE "OPTIONAL" (TAGLIST %<>))
	#DECL ((DATE) DATE
	       (TAGLIST) <OR TAGS FALSE>)
	<PUTDAY .DATE
		<COND (.TAGLIST
		       <BOOT DAY
			.TAGLIST !<DAYLIST .DATE>>)
		      (ELSE <DAYLIST .DATE>)>>
	T>

<DEFINE MONTHNUM (DATE)					 ;"offset in monthlist"
	#DECL ((VALUE) FIX
	       (DATE) DATE)
	<+ ,REF
	   <M .DATE>
	   <- <M ,TODAY>>
	   <* 12
	      <- <Y .DATE>
		 <Y ,TODAY>>>>>
 
<DEFINE DAYOFWEEK (DATE
		   "AUX" TEMP
			 (Y <Y .DATE>)
			 (M <M .DATE>)
			 (D <D .DATE>))			      ;"TI'S abhorithm"
	#DECL ((VALUE) FIX
	       (DATE) DATE
	       (Y M D TEMP) FIX)
	<SET TEMP <+ <* 365 <+ .Y 1900>> .D <* 31 <- .M 1>>>>
	<SET TEMP
	     <+ .TEMP
		<COND (<L? .M 3>
		       <+ </ <+ .Y 1899> 4>
			  <- </ <* 3 <+ 1 </ <+ .Y 1899> 100>>> 4>>>)
		      (ELSE
		       <+ <- <FIX <+ 2.3 <* .M 0.4>>>>
			  </ <+ .Y 1900> 4>
			  <- </ <* <+ 1 </ <+ 1900 .Y> 100>> 3> 4>>>)>>>
	<+ 1 <MOD .TEMP 7>>>   

<DEFINE DECDATE (DATE					      ;"decrement date"
		 "AUX" (TDATE <FC .DATE>)
		       (TEMP .TDATE)
		 "ACT" ABORT) 
	#DECL ((VALUE) <OR 'T FALSE>
	       (DATE TDATE TEMP) DATE
	       (ABORT) ACTIVATION)
	<COND (<0? <D <D .DATE <- <D .DATE> 1>>>>
	       <AND <0? <M <M .DATE <- <M .DATE> 1>>>>
		    <M .DATE 12>
		    <Y .DATE <- <Y .DATE> 1>>>
	       <SET TEMP <D <SET TEMP .DATE> 1>>
	       <AND <DATECHK .TEMP>
		    <DATE-SET .DATE .TDATE>
		    <RETURN 'T .ABORT>>
	       <D .DATE <LENGTH <NTH ,CALNDR <MONTHNUM .DATE>>>>)>
	%<>> 

<DEFINE DECCURDATE ("AUX" (DATE <CURDATE>))
	#DECL ((DATE) DATE)
	<COND (<DECDATE .DATE> 'T)
	      (ELSE
	       <CURDATE .DATE> %<>)>> 

<DEFINE INCDATE (DATE
		 "AUX" (TDATE <FC .DATE>)
		 "ACT" ABORT) 
	#DECL ((VALUE) <OR 'T FALSE>
	       (DATE TDATE) DATE
	       (ABORT) ACTIVATION)
	<AND <DATECHK .DATE> <RETURN 'T .ABORT>>   ;"is this really necessary?"
	<AND <G? <D <D .DATE <+ <D .DATE> 1>>>
		 <LENGTH <NTH ,CALNDR <MONTHNUM .DATE>>>>
	     <D .DATE 1>
	     <AND <G? <M <M .DATE <+ <M .DATE> 1>>> 12>
		  <M .DATE 1>
		  <Y .DATE <+ <Y .DATE> 1>>>>
	<AND <DATECHK .DATE>
	     <DATE-SET .DATE .TDATE>
	     <RETURN 'T .ABORT>>
	%<>>    

<DEFINE INCCURDATE ("AUX" (DATE <CURDATE>))
	#DECL ((DATE) DATE)
	<COND (<INCDATE .DATE> 'T)
	      (ELSE
	       <CURDATE .DATE> %<>)>> 

<DEFINE FIND-WEEKDAY (STR DATE
		      "AUX" (TDATE <FC .DATE>)
			    (NDAYS %<>)
			    TEMP
		      "ACT" FOUND)
	;"return false if no errors,
	  return 0 if no such weekday
	  return #days off edge of calendar if ye mo da is out of bounds"

	#DECL ((VALUE) <OR FIX FALSE>
	       (STR) STRING
	       (DATE TDATE) DATE
	       (NDAYS) <OR FIX FALSE>
	       (FOUND) ACTIVATION)
	<REPEAT ()
		<COND (<=? .STR <SET TEMP <LC-TO-UC <PDAY .DATE>>>>
		       <RETURN %<> .FOUND>)
		      (<=? .TEMP "SUN">
		       <DATE-SET .DATE .TDATE>
		       <INCDATE .DATE>
		       <RETURN>)
		      (<DECDATE .DATE>
		       <COND (<G=? <SET NDAYS <DAYSBETWEEN .TEMP .STR>> 0>
			      <RETURN>)
			     (ELSE <RETURN .NDAYS .FOUND>)>)>>
	<REPEAT ()
		<COND (<=? .STR <SET TEMP <LC-TO-UC <PDAY .DATE>>>>
		       <RETURN %<> .FOUND>)
		      (<=? .TEMP "SAT">
		       <DATE-SET .DATE .TDATE>
		       <RETURN 0 .FOUND>)
		      (<INCDATE .DATE>
		       <RETURN <DAYSBETWEEN .TEMP .STR> .FOUND>)>>>  
 
<DEFINE DAYSBETWEEN (BEGIN END)					 ;"for MONTH()"
	#DECL ((VALUE) FIX (BEGIN END) STRING)
	<- </ <- 21 <LENGTH <MEMBER .END "SUNMONTUEWEDTHUFRISAT">>> 3>
	   </ <- 21 <LENGTH <MEMBER .BEGIN "SUNMONTUEWEDTHUFRISAT">>> 3>>>    
 
<DEFINE PDATE (DATE)					      ;"date -> string"
	#DECL ((VALUE) STRING
	       (DATE) DATE)
	<STRING <PAD <UNPARSE <D .DATE>> !\ >
		"-"
		<NTH ,MONTHSTR <M .DATE>>
		"-"
		<PAD <UNPARSE <Y .DATE>>>>>
 
<DEFINE PDAY (DATE)						 ;"day of week"
	#DECL ((VALUE) STRING
	       (DATE) DATE)
	<NTH '("Sat" "Sun" "Mon" "Tue" "Wed" "Thu" "Fri")
	     <DAYOFWEEK .DATE>>>
 
<DEFINE PTIME (MINS) 
	#DECL ((VALUE) STRING (MINS) FIX)
	<STRING <PAD <UNPARSE </ .MINS 60>> !\ >
		":"
		<PAD <UNPARSE <MOD .MINS 60>>>>> 
 
<DEFINE PAD (NUMSTR "OPTIONAL" (WITH !\0))		    ;"two columns only"
	#DECL ((VALUE) STRING (NUMSTR) <OR CHARACTER STRING> (WITH) CHARACTER)
	<COND (<1? <LENGTH .NUMSTR>> <STRING .WITH .NUMSTR>)
	      (ELSE .NUMSTR)>>   

<DEFINE MINS (STR "AUX" COLON)					 ;"string -> #"
	#DECL ((STR) STRING (COLON) FIX)
	<SET COLON <INSTR .STR !\:>>
	<AND <OR <=? .COLON 1> <=? .COLON <LENGTH .STR>>>
	     <SETG INPUT "">
	     <RETURN <STRING "Bad time format: " .STR> .TOTOPLEV>>
	<SET MINUTES <PARSE <SUBSTRUC .STR 0 <- .COLON 1>>>>
	<SET HOURS <PARSE <REST .STR .COLON>>>
	<AND <OR <N=? <TYPE .MINUTES> FIX> <N=? <TYPE .HOURS> FIX>>
	     <RETURN <STRING "Bad time format: " .STR> .TOTOPLEV>>
	<SET COLON <+ <* 60 .MINUTES> .HOURS>>
	<COND (<G? .COLON 1439>
	       <RETURN <STRING .STR " is not a valid time of day"> .TOTOPLEV>)
	      (ELSE .COLON)>>   
 
<DEFINE LC-TO-UC (STR)					   ;"type string only!"
	#DECL ((VALUE) STRING (STR) STRING)
	<MAPF ,STRING
	      <FUNCTION (CHAR "AUX" ASC) 
		      #DECL ((CHAR) CHARACTER)
		      <SET ASC <ASCII .CHAR>>
		      <AND <G=? .ASC 97>
			   <L=? .ASC 122>
			   <SET ASC <+ .ASC 65 -97>>>
		      <ASCII .ASC>>
	      .STR>> 

<DEFINE INSTR (STR CHAR "OPTIONAL" (STARTWITH 1)
	       "AUX" (LEN <LENGTH .STR>)
	       "ACT" INSTR)
	#DECL ((VALUE) FIX (STR) STRING (CHAR) CHARACTER    ;"find char in str"
	       (STARTWITH LEN) FIX
	       (INSTR) ACTIVATION)
	<AND <OR <0? .LEN>
		 <G? .STARTWITH .LEN>>
	     <RETURN 0 .INSTR>>
	<REPEAT ((COUNT .STARTWITH))
		#DECL ((COUNT) FIX)
		<COND (<=? .CHAR <NTH .STR .COUNT>> <RETURN .COUNT>)
		      (<G? <SET COUNT <+ 1 .COUNT>> .LEN>
		       <RETURN 0>)>>>

<DEFINE WARN (TEXT					    ;"allows for input"
	      "OPTIONAL" (TIME 2) "AUX" TEMP INCHR "ACT" WARM)
	#DECL ((TEXT) <OR <PRIMTYPE STRING> FALSE>
	       (TIME) <OR CHARACTER FIX>
	       (TEMP) ANY
	       (INCHR) CHARACTER
	       (WARM) ACTIVATION)
	<COND (<NOT .TEXT> <RETURN %<> .WARM>)>	       ;"cleaner to check here"
	<ECHO .TEXT>
	<COND (<=? <TYPE .TIME> CHARACTER>
	       <SET TEMP <=? <SET INCHR <TYI ,INCHAN>> .TIME>>
	       <AND <=? .INCHR %<ASCII *021*>>
		    <OR <NOT <GASSIGNED? HARD-CHAN>>
			,HARD-CHAN>		     ;"if not already quitting"
		    <CLEAN-QUIT>>				    ;"quit noww"
	       <AND <L? <ASCII .INCHR> *040*>
		    <BUFF .INCHR>
		    <RETURN %<> .TOTOPLEV>>
	       <AND <NOT .TEMP>			      ;"if no, stash character"
		    <N=? .INCHR *177*>				;"(unless del)"
		    <BUFF .INCHR>>)			       ;"examine error"
	      (ELSE <SLEEP .TIME> <SET TEMP .TEXT>)>	  ;"return T/F or text"
	<ECHO ,INPUT>
	.TEMP> 

<DEFINE ECHO (STR "AUX" RTIME)				 ;"clean up input area"
	#DECL ((STR) ANY (RTIME) !<LIST [3 FIX]>)
	<PRINC "C">
	<PRINC "T">
	<PRINC "(">
	<PRINC <PAD <UNPARSE <NTH <SET RTIME <RTIME>> 1>> !\ >>
	<PRINC ":">
	<PRINC <PAD <UNPARSE <NTH .RTIME 2>>>>
	<PRINC ")  ">
	<PRINC <CURDATE>>			    ;"header with current date"
	<CRLF><CRLF>
	<PRINC .STR>
	<AND <=? <NTH ,DISPLAY-CHAN 5> "TTY">;"juggle cursor iff output to tty"
	     <PUTCURSOR>>>

<DEFINE NDEL (N)
	#DECL ((N) CHARACTER) 				    ;"#chars to delete"
	<COND (<AND <N=? <ASCII .N> *033*>			      ;"escape"
		    <L? <ASCII .N> *040*>>
	       <STRING %<ASCII *010*>"K"%<ASCII *010*>"K">)
	      (ELSE
	       <STRING %<ASCII *010*>"K">)>>

<DEFINE PRNT (STR)					 ;"output to main disp"
	#DECL ((STR) <OR CHARACTER STRING COMMAND-STRING>)
	<PRINC .STR ,DISPLAY-CHAN>>  

<DEFINE PRNTCRLF ("OPTIONAL" (STR "")) 
	#DECL ((VALUE) 'T (STR) <OR CHARACTER STRING COMMAND-STRING>)
	<PRNT .STR>
	<CRLF ,DISPLAY-CHAN>>