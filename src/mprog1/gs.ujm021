
<PACKAGE "GS">

<ENTRY GSOUT DRAW-SEG SPIN-DP-OR-LIST GSEG>
<ENTRY ALL-SEG REMOVED-SEGS OPEN-SEG DEV-DISPATCH GOUTCHAN DEV-X DEV-Y DEV-CM>
<ENTRY GSBEGIN GSEND GSCHANGE GSMOVE GSDRAW GSTEXT GSAPPEND GSREMOVE>
<ENTRY GSEND-UPDATES GSBLANK GSUNBLANK GSDOT GSINQ GSCONTENTS>
<ENTRY GSREADER GSHIT-TEST GSHIT-REFINE>
<ENTRY OFF-BEGIN OFF-END OFF-CHANGE OFF-MOVE OFF-DRAW OFF-TEXT OFF-APPEND OFF-REMOVE>
<ENTRY OFF-END-UPDATES OFF-BLANK OFF-UNBLANK OFF-DOT OFF-INQ OFF-CONTENTS>
<ENTRY OFF-READER OFF-HIT-TEST OFF-HIT-REFINE>
<ENTRY OK APPENDED CHANGED>
<ENTRY SEG-DP SEG-SEED SEG-TAIL SEG-LX SEG-LY SEG-STAT SEG-UINFO SEG-INT-ID SEG-NUM>
<ENTRY SEG-LVS SEG-LL SEG-NVS>
<ENTRY LBOUND RBOUND BBOUND TBOUND LEFT RIGHT BOTTOM GTOP>
<ENTRY USE-INQ-R INQ-RESP DEV-CHAR-SIZE SCALE_VEC IMLAC-INQ BASIC-DISPATCH>
<ENTRY MAKE-SEG USING-TTY>

<ENTRY
 GSSCALE
 BOUNDS
 WINDOW
 GFMUNG
 GFMUNGER
 POSITION
 LINE
 REL_LINE
 REL_POSITION
 MAPPER
 LINE_SEG
 CONT_L_FLAG>

<NEWTYPE GSEG VECTOR>

<SETG OFF-BEGIN 1>
<SETG OFF-END 2>
<SETG OFF-CHANGE 3>
<SETG OFF-MOVE 4>
<SETG OFF-DRAW 5>
<SETG OFF-TEXT 6>
<SETG OFF-APPEND 7>
<SETG OFF-REMOVE 8>
<SETG OFF-END-UPDATES 9>
<SETG OFF-BLANK 10>
<SETG OFF-UNBLANK 11>
<SETG OFF-DOT 12>
<SETG OFF-INQ 13>
<SETG OFF-CONTENTS 14>
;<SETG OFF-HARD-COPY 15>
<SETG OFF-READER 16>
<SETG OFF-HIT-TEST 17>
<SETG OFF-HIT-REFINE 18>

<SETG SEG-DP 1>
<SETG SEG-SEED 2>
<SETG SEG-TAIL 3>
<SETG SEG-LX 4>
<SETG SEG-LY 5>
<SETG SEG-STAT 6>
<SETG SEG-UINFO 7>
<SETG SEG-INT-ID 8>
<SETG SEG-NUM 9>
<SETG SEG-LVS 10>
<SETG SEG-LL 11>
<SETG SEG-NVS 12>

<GDECL 
(SEG-DP SEG-SEED SEG-TAIL SEG-LX SEG-LY SEG-STAT SEG-UINFO SEG-INT-ID SEG-NUM
 SEG-LVS SEG-LL SEG-NVS
 OFF-BEGIN OFF-END OFF-CHANGE OFF-MOVE OFF-DRAW OFF-TEXT OFF-APPEND OFF-REMOVE
 OFF-END-UPDATES OFF-BLANK OFF-UNBLANK OFF-DOT OFF-INQ OFF-CONTENTS
 OFF-READER OFF-HIT-TEST OFF-HIT-REFINE) FIX>

<MANIFEST
 SEG-DP SEG-SEED SEG-TAIL SEG-LX SEG-LY SEG-STAT SEG-UINFO SEG-INT-ID SEG-NUM
 SEG-LVS SEG-LL SEG-NVS
 OFF-BEGIN OFF-END OFF-CHANGE OFF-MOVE OFF-DRAW OFF-TEXT OFF-APPEND OFF-REMOVE
 OFF-END-UPDATES OFF-BLANK OFF-UNBLANK OFF-DOT OFF-INQ OFF-CONTENTS
 OFF-READER OFF-HIT-TEST OFF-HIT-REFINE>




<DEFINE GSOUT (KIND "TUPLE" TAIL)
	#DECL( (KIND) FIX (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>
		(TAIL) TUPLE)
	<APPLY <NTH .DEV-DISPATCH .KIND> !.TAIL>>


<DEFINE DRAW-SEG (SEG "OPTIONAL" (ADJUST-SEG T)
		"AUX" (DEV-DISPATCH .DEV-DISPATCH) ALIST)
	#DECL ((SEG) GSEG (ADJUST-SEG) <OR ATOM FALSE>
		(ALIST) <PRIMTYPE LIST>
		(DEV-X DEV-Y DEV-CM) FIX
		(DEV-DISPATCH) <VECTOR [REST APPLICABLE]>)
	<SET DEV-CM 0>
	<APPLY <NTH .DEV-DISPATCH ,OFF-MOVE> 0 0>
	<COND (<NTH .SEG ,SEG-DP>
		<APPLY <NTH .SEG ,SEG-DP> <NTH .SEG ,SEG-UINFO>>)
	      (T
		<MAPF <>
		      <FUNCTION (WHAT) #DECL ((WHAT) <LIST FIX [REST ANY]>)
			  <APPLY <NTH .DEV-DISPATCH <1 .WHAT>> !<REST .WHAT>>>
		      <NTH .SEG ,SEG-LL>>)>
	<COND (.ADJUST-SEG
		<PUT .SEG ,SEG-LX .DEV-X>
		<PUT .SEG ,SEG-LY .DEV-Y>)>>

<DEFINE SPIN-DP-OR-LIST (SEG DEV-DISPATCH "TUPLE" TAI)
	#DECL ( (SEG) GSEG
		(DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>
		(TAI) TUPLE)
	<COND (<NTH .SEG ,SEG-DP>
		<APPLY <NTH .SEG ,SEG-DP> <NTH .SEG ,SEG-UINFO> !.TAI>)
	      (T
		<MAPF <>
		      <FUNCTION (WHAT) #DECL ((WHAT) <LIST FIX [REST ANY]>)
			  <APPLY <NTH .DEV-DISPATCH <1 .WHAT>> !<REST .WHAT>>>
		      <NTH .SEG ,SEG-LL>>)>>



<DEFINE GSBEGIN ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-BEGIN> !.YY>>
<DEFINE GSEND ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-END> !.YY>>
<DEFINE GSCHANGE ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-CHANGE> !.YY>>
<DEFINE GSMOVE ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-MOVE> !.YY>>
<DEFINE GSDRAW ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-DRAW> !.YY>>
<DEFINE GSTEXT ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-TEXT> !.YY>>
<DEFINE GSAPPEND ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-APPEND> !.YY>>
<DEFINE GSREMOVE ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-REMOVE> !.YY>>
<DEFINE GSEND-UPDATES ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-END-UPDATES> !.YY>>
<DEFINE GSBLANK ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-BLANK> !.YY>>
<DEFINE GSUNBLANK ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-UNBLANK> !.YY>>
<DEFINE GSDOT ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-DOT> !.YY>>
<DEFINE GSINQ ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-INQ> !.YY>>
<DEFINE GSCONTENTS ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-CONTENTS> !.YY>>
;<DEFINE GSHARD-COPY ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-HARD-COPY> !.YY>>
<DEFINE GSREADER ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-READER> !.YY>>
<DEFINE GSHIT-TEST ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-HIT-TEST> !.YY>>
<DEFINE GSHIT-REFINE ("TUPLE" YY) 
	#DECL ((YY) TUPLE (DEV-DISPATCH) <SPECIAL <VECTOR [REST APPLICABLE]>>)
	<APPLY <NTH .DEV-DISPATCH ,OFF-HIT-REFINE> !.YY>>


<PRINTTYPE GSEG
	<FUNCTION (X) #DECL ((X) GSEG)
		   <PRINC "#GSEG #">
		   <PRINC <NTH .X ,SEG-NUM>>
		   <PRINC " [">
		   <PRINC <COND (<NTH .X ,SEG-DP> DP)
				(T (<LENGTH <NTH .X ,SEG-LL>> PRIMS))>>
		   <PRINC "]">>>

<SET LAST-SEG-NUM -1>

<DEFINE MAKE-SEG ()
	#DECL ((VALUE) <GSEG <OR FALSE APPLICABLE>
			<OR FALSE LIST>
			<OR FALSE LIST>
			FIX
			FIX
			<OR 'OK 'CHANGED 'APPENDED>
			ANY
			ANY
			FIX
			<OR 'T FALSE>
			<OR FALSE <LIST [REST LIST]>>
			<OR 'T FALSE>>
		(LAST-SEG-NUM) <SPECIAL FIX>)
	<CHTYPE [<> <> <> 0 0 'CHANGED <> <> <SET LAST-SEG-NUM <+ 1 .LAST-SEG-NUM>>
		 <> <> <>] GSEG>>

<DEFINE GSEG (NUM "AUX" (VAL <>))
	#DECL ((NUM) FIX (VALUE VAL) <OR FALSE GSEG>
		(ALL-SEG) <LIST [REST GSEG]>)
	<MAPF <>
	      <FUNCTION (GS) #DECL ((GS) GSEG)
		  <COND (<==? .NUM <NTH .GS ,SEG-NUM>>
			 <SET VAL .GS>
			 <MAPLEAVE>)>>
	      .ALL-SEG>
	<COND (.VAL)
	      (T <CHTYPE <LIST NO-CURRENT-SEG-NUM .NUM> FALSE>)>>


<DEFINE GSSCALE ("OPTIONAL" (XMIN .LEFT) (XMAX .RIGHT) (YMIN .BOTTOM)
			  (YMAX .GTOP))
	#DECL ((VALUE SCALE_VEC) <UVECTOR [4 FLOAT]>
		(XMIN XMAX YMIN YMAX) <OR FLOAT FIX>
		(LEFT RIGHT BOTTOM GTOP
		RBOUND LBOUND TBOUND BBOUND) <SPECIAL <OR FLOAT FIX>>)
	<SET LEFT .XMIN>
	<SET RIGHT .XMAX>
	<SET BOTTOM .YMIN>
	<SET GTOP .YMAX>
	<SET SCALE_VEC
	     ![</ <FLOAT <- .RBOUND .LBOUND>> <- .RIGHT .LEFT>>
	       </ <FLOAT <- <* .LBOUND .RIGHT> <* .RBOUND .LEFT>>>
		  <- .RIGHT .LEFT>>
	       </ <FLOAT <- .TBOUND .BBOUND>> <- .GTOP .BOTTOM>>
	       </ <FLOAT <- <* .BBOUND .GTOP> <* .TBOUND .BOTTOM>>>
		  <- .GTOP .BOTTOM>>!]>>

<DEFINE POSITION (X Y)
	#DECL ((VALUE) 'T (X Y) <OR FLOAT FIX>)
	<GFMUNG 0 0 .X .Y>>

<DEFINE LINE (X Y)
	#DECL ((VALUE) 'T (X Y) <OR FIX FLOAT>)
	<GFMUNG 1 0 .X .Y>>

<DEFINE REL_LINE (X Y)
	#DECL ((VALUE) 'T (X Y) <OR FLOAT FIX>)
	<GFMUNG 1 1 .X .Y>>

<DEFINE REL_POSITION (X Y)
	#DECL ((VALUE) 'T (X Y) <OR FIX FLOAT>)
	<GFMUNG 0 1 .X .Y>>

<DEFINE LINE_SEG (X1 Y1 X2 Y2)
	#DECL ((VALUE) 'T (X1 Y1 X2 Y2) <OR FLOAT FIX>)
	<GFMUNG 0 0 .X1 .Y1 .X2 .Y2>>

<DEFINE WINDOW ('TO_DISPLAY
		"OPTIONAL" (XMIN .LEFT) (XMAX .RIGHT) (YMIN .BOTTOM)
			   (YMAX .GTOP)
		"AUX" (LBOUND <+ <* <1 .SCALE_VEC> .XMIN> <2 .SCALE_VEC>>)
		      (RBOUND <+ <* <1 .SCALE_VEC> .XMAX> <2 .SCALE_VEC>>)
		      (BBOUND <+ <* <3 .SCALE_VEC> .YMIN> <4 .SCALE_VEC>>)
		      (TBOUND <+ <* <3 .SCALE_VEC> .YMAX> <4 .SCALE_VEC>>)
		      SCALE_VEC GLOBAL_CONSERVE_SCALE LEFT RIGHT BOTTOM GTOP)
	#DECL ((VALUE) 'T 
		(TO_DISPLAY) STRUCTURED (XMIN XMAX YMIN YMAX) <OR FIX FLOAT>
	       (LBOUND RBOUND BBOUND TBOUND
	        LEFT RIGHT BOTTOM GTOP) <SPECIAL <OR FIX FLOAT>>
	       (SCALE_VEC GLOBAL_CONSERVE_SCALE) <SPECIAL ANY>)
	<GSSCALE 0 1 0 1>
	<COND (.OPEN-SEG <POSITION 0 0>)>
	<EVAL <EVAL .TO_DISPLAY>>
	T>

<DEFINE MAPPER ("BIND" XNV
		MAPPING 'TO-DO
		"AUX"   (MAP-TEM <COND (<ASSIGNED? .MAPPING .XNV>
					<LVAL .MAPPING .XNV>)
				       (T
					<SET .MAPPING
					     [.LEFT .RIGHT .BOTTOM .GTOP .SCALE_VEC]
					     .XNV>)>)
			(LEFT <1 .MAP-TEM>)
			(RIGHT <2 .MAP-TEM>)
			(BOTTOM <3 .MAP-TEM>)
			(GTOP <4 .MAP-TEM>)
			(SCALE_VEC <5 .MAP-TEM>)
			(LBOUND <+ <* <1 .SCALE_VEC> .LEFT>   <2 .SCALE_VEC>>)
			(RBOUND <+ <* <1 .SCALE_VEC> .RIGHT>  <2 .SCALE_VEC>>)
			(BBOUND <+ <* <3 .SCALE_VEC> .BOTTOM> <4 .SCALE_VEC>>)
			(TBOUND <+ <* <3 .SCALE_VEC> .GTOP>   <4 .SCALE_VEC>>))
	#DECL ((LEFT RIGHT BOTTOM GTOP LBOUND RBOUND BBOUND TBOUND)
			<SPECIAL <OR FIX FLOAT>>
		(SCALE_VEC) <SPECIAL <UVECTOR [4 FLOAT]>>
		(VALUE MAP-TEM) <VECTOR [4 <OR FIX FLOAT>] UVECTOR>
		(MAPPING) ATOM (TO-DO) STRUCTURED)
	<PROG (MAP-TEM)
	      <EVAL <EVAL .TO-DO>>>
	<PUT .MAP-TEM 1 .LEFT>
	<PUT .MAP-TEM 2 .RIGHT>
	<PUT .MAP-TEM 3 .BOTTOM>
	<PUT .MAP-TEM 4 .GTOP>
	<PUT .MAP-TEM 5 .SCALE_VEC>>

<DEFINE GFMUNG (UP AB "TUPLE" POS)
	#DECL ((VALUE) 'T (UP AB) FIX (POS) <TUPLE [REST <OR FIX FLOAT>]>)
	<GFMUNGER .UP .AB .POS>>

<DEFINE GFMUNGER (UP AB POS
		  "AUX" X Y (SC .SCALE_VEC)
			FX FY)
   #DECL ((VALUE) 'T 
	  (SC) <UVECTOR [4 FLOAT]>
	  (FX FY) FLOAT
	  (AB UP X Y) FIX
	  (DEV-X DEV-Y) <SPECIAL FIX>
	  (POS) <STRUCTURED [REST <OR FIX FLOAT>]>)
   <COND (<NOT <0? .AB>>
	  <SET FX <FLOAT .DEV-X>>
	  <SET FY <FLOAT .DEV-Y>>)>
   <SET UP <COND (<0? .UP> ,OFF-MOVE)
		 (T ,OFF-DRAW)>>
   <REPEAT ()
	   <COND (<LENGTH? .POS 1> <RETURN>)>
	   <SET X
		<FIX <+ 0.5
			<SET FX <+ <* <FLOAT <1 .POS>> <1 .SC>> <COND (<0? .AB><2 .SC>)
								      (T .FX)>>>>>>
	   <SET Y
		<FIX <+ 0.5
			<SET FY <+ <* <FLOAT <2 .POS>> <3 .SC>> <COND (<0? .AB><4 .SC>)
								      (T .FY)>>>>>>
	   <GSOUT .UP .X .Y>
	   <SET UP ,OFF-DRAW>
	   <SET POS <REST .POS 2>>>
	T>

<DEFINE BOUNDS ("OPTIONAL" (IN_LBOUND .LBOUND) (IN_RBOUND .RBOUND)
			   (IN_BBOUND .BBOUND) (IN_TBOUND .TBOUND)
		"AUX" TEMP)
	#DECL ((VALUE TEMP) <VECTOR [4 <OR FIX FLOAT>]>
		(IN_LBOUND IN_RBOUND IN_BBOUND IN_TBOUND) <OR FIX FLOAT>
		(LBOUND RBOUND BBOUND TBOUND) <SPECIAL <OR FIX FLOAT>>)
	<SET TEMP
	     [<SET LBOUND .IN_LBOUND>
	       <SET RBOUND .IN_RBOUND>
	       <SET BBOUND .IN_BBOUND>
	       <SET TBOUND .IN_TBOUND>]>
	<GSSCALE>
	.TEMP>

<DEFINE USE-INQ-R ("AUX" BDS)
	#DECL ((BDS) <VECTOR [REST <OR FLOAT FIX>]>
		(INQ-RESP DEV-CHAR-SIZE) <SPECIAL VECTOR>)
	<SET INQ-RESP <GSINQ>>
	<SET DEV-CHAR-SIZE <1 <11 .INQ-RESP>>>
	<SET BDS <2 .INQ-RESP>>
	<BOUNDS <1 .BDS> <3 .BDS> <2 .BDS> <4 .BDS>>
	<GSSCALE>>



<DEFINE BAS-ERR ("TUPLE" X) #DECL ((VALUE) ANY)
	<ERROR SLOT-NOT-FILLED-IN-BASIC-DISPATCH!-ERRORS .X>>

<DEFINE BASIC-DISPATCH () #DECL ((VALUE) <VECTOR [REST APPLICABLE]>)
[
;"BEGIN SEGMENT: TAKES OPTIONAL FUNCTION WHICH SHOULD
ACT AS A DISPLAY PROCEDURE AND AN OPTIONAL ARGUMENT TO BE
SUPPLIED TO THE FUNCTION WHENEVER IT IS APPLIED. THE DP SHOULD TAKE AN OPTIONAL
ARGUMENT (IN ADDITION TO THE ONE SUPPLIED
IN THE CALL TO GSBEGIN)."

<FUNCTION ("OPTIONAL" (DP <>)(DP-DATA <>))
	#DECL ( (OPEN-SEG) <OR FALSE GSEG> (DP) <OR APPLICABLE FALSE>
		(DEV-X DEV-Y) FIX)
	<COND (.OPEN-SEG
	       <ERROR SEG-ALREADY-OPEN!-ERRORS>
	       <GNRL-GSEND>)>
	<SET ALL-SEG (!.ALL-SEG <SET OPEN-SEG <MAKE-SEG>>)>
	<PUT .OPEN-SEG ,SEG-STAT 'CHANGED>
	<SET DEV-X <SET DEV-Y 0>>
	<COND (.DP
	       <PUT .OPEN-SEG ,SEG-DP .DP>
	       <PUT .OPEN-SEG ,SEG-UINFO .DP-DATA>)
	      (T
	       <PUT .OPEN-SEG ,SEG-SEED <LIST SEED>>
	       <PUT .OPEN-SEG ,SEG-TAIL <NTH .OPEN-SEG ,SEG-SEED>>)>>

;"END SEGMENT: STOPS APPENDING TO THE CURRENTLY OPEN SEGMENT. IF THERE IS NONE , ERROR"
<SETG GNRL-GSEND <FUNCTION ("AUX" TEM)
	#DECL ((TEM) GSEG ( OPEN-SEG) <OR FALSE GSEG>
		(DEV-X DEV-Y) FIX)
	<COND (<NOT .OPEN-SEG><ERROR NO-SEGMENT-IS-OPEN!-ERRORS>)
	      (T
		<PUT <SET TEM .OPEN-SEG> ,SEG-LX .DEV-X>
		<PUT .TEM ,SEG-LY .DEV-Y>
		<PUT .TEM ,SEG-SEED <CHTYPE <NTH .TEM ,SEG-SEED> FALSE>>
		<SET OPEN-SEG <>>
		.TEM)>>>
	
;"CHANGE SEGMENT: FOR A SEGMENT WITH A DISPLAY PROCEDURE, THIS INDICATES
THAT THE DISPLAY PROCEDURE NEEDS RE-EVALUATION. ERROR IF GIVEN SEG
IS NOT ON LIST OF ALL SEGMENTS OR IF HAS NO DISPLAY PROCEDURE
THIS IS A NO-OP IF THE SEG IS CURRENTLY BLANKED OR WAS
(RECENTLY MEANING SINCE LAST ENDOF BATCHOF ETC) CREATED
OR UNBLANKED."

<FUNCTION (SEG)
	#DECL ( (SEG) GSEG (ALL-SEG) <LIST [REST GSEG]>
		(OPEN-SEG) <OR GSEG FALSE>)
	<COND (.OPEN-SEG
	       <ERROR SEG-ALREADY-OPEN!-ERRORS>
	       <GNRL-GSEND>)>
	<COND (<MEMQ .SEG .ALL-SEG>
		<SET OPEN-SEG .SEG>
		<PUT .SEG ,SEG-STAT 'CHANGED>
		<PUT .SEG ,SEG-NVS <>>
		<SET DEV-X <SET DEV-Y 0>>
		<COND (<NOT <NTH .SEG ,SEG-DP>>
			<PUT .SEG ,SEG-SEED <LIST SEED>>
			<PUT .SEG ,SEG-TAIL <NTH .SEG ,SEG-SEED>>)>)
	      (T <ERROR ARG-NOT-VALID-SEGMENT!-ERRORS .SEG>)>>

;"ABSOLUTE POSITION: MOVE THE BEAM INVISIBLY TO THE GIVEN X Y.
(NOTHING IS DONE IF DOOUT IS FALSE. NOTHING IS OUTPUT TO DEVICE
IF ABOUT TO ERASE THE SCREEN ANYWAY. NOTHING IS CONS'D ONTO THE
LIST OF COMMAND UNITS IF THE LIST SEED IS FALSE)."

<FUNCTION (X Y "AUX" S)
	#DECL ((X Y) FIX (OPEN-SEG) <OR GSEG FALSE>
		(S) GSEG
		(DEV-X DEV-Y) FIX)
  <COND (<NOT .OPEN-SEG>
	 <ERROR NO-SEGMENT-IN-PROGRESS!-ERRORS>)
	(T
	<SET S .OPEN-SEG>
	<SET DEV-X .X>
	<SET DEV-Y .Y>
	<COND (<NTH .S ,SEG-SEED>
	       <PUT .S
		    ,SEG-TAIL
		    <REST <PUTREST
			    <NTH .S ,SEG-TAIL>
			    ((,OFF-MOVE .X .Y))>>>)>)>>

;"ABSOLUTE DRAW: DRAW A LINE FROM WHERE THE BEAM IS TO
THE SPECIFIED LOCATION. SEE MOVE ABSOLUTE FOR CONDITIONS.
IF THE LINE IS TOO LONG FOR THE ARDS TO DRAW, IT IS HALVED RECURSIVELY"

<FUNCTION (X Y "AUX" S)
	#DECL ((X Y DEV-X DEV-Y) FIX
		(S) GSEG
		(OPEN-SEG) <OR FALSE GSEG>)
  <COND (<NOT .OPEN-SEG>
	 <ERROR NO-SEGMENT-IN-PROGRESS!-ERRORS>)
	(T
	<SET DEV-X .X>
	<SET DEV-Y .Y>
	<COND (<NTH <SET S .OPEN-SEG> ,SEG-SEED>
		<PUT .S
		     ,SEG-TAIL
		     <REST <PUTREST
			     <NTH .S ,SEG-TAIL>
			     ((,OFF-DRAW .X .Y))>>>)>)>>

;"OUTPUT TEXT: TAKES A STRING OR A CHARACTER AND PRINC IT.
NOTE THAT IF ONLY AN ASCII LINEFEED CHAR IS
GIVEN THE CHAR IS IMAGE'D, NOT PRINC'D. NOTE CONDITIONS UNDER MOVE ABSOLUTE"

<FUNCTION (XT
	"OPTIONAL" (FIXEDLBOUND <FIX .LBOUND>)
		(FIXEDHEIGHT <FIX <2 .DEV-CHAR-SIZE>>)
	   "AUX" (XXT <COND(<TYPE? .XT STRING> .XT)
			   (T <STRING .XT>)>)
		 S)
	#DECL(  (XT) <OR CHARACTER STRING>  (XXT) STRING
		(OPEN-SEG) <OR FALSE GSEG>
		(S) GSEG
		(DEV-X DEV-Y) FIX
		(FIXEDHEIGHT FIXEDLBOUND) FIX
		(LBOUND) <OR FIX FLOAT>
		(DEV-CHAR-SIZE) <VECTOR [REST <OR FIX FLOAT>]>)
  <COND (<NOT .OPEN-SEG>
	 <ERROR NO-SEGMENT-IN-PROGRESS!-ERRORS>)
	(T
	  <MAPF <>
		<FUNCTION (XCH "AUX" (NCH <ASCII .XCH>))
			#DECL((XCH) CHARACTER (NCH) FIX)
			   <COND (<==? .NCH 13>
				  <SET DEV-X .FIXEDLBOUND>)
				 (<==? .NCH 10>
				  <SET DEV-Y <- .DEV-Y .FIXEDHEIGHT>>)>>
		.XXT>)>
	<COND (<NTH <SET S .OPEN-SEG> ,SEG-SEED>
	       <PUT .S
		    ,SEG-TAIL
		    <REST <PUTREST
			    <NTH .S ,SEG-TAIL>
			    ((,OFF-TEXT .XXT .FIXEDLBOUND .FIXEDHEIGHT))>>>)>>

;"APPEND TO SEGMENT: ERROR IF SOME SEGMENT IS ALREADY OPEN
OR IF THE GIVEN SEGMENT IS NOT ON THE LIST OF SEGMENTS.
NO COMMANDS ACTUALLY GET OUTPUT IF THE SEGMENT HAS A DP AND EITHER
THE NEED-ERASE FLAG IS SET OR THE SEGMENT IS MARKED 'NEW.
RETURNS T IF SHOULD ACTUALLY SHOULD DRAW THE STUFF, <> OTHERWISE.
(<> COULD HAPPEN IF THE SCREEN IS GOING TO BE ERASED ANYWAY AND THE
SEGMENT HAS A DISPLAY PROCEDURE)"

<FUNCTION (SEG "AUX" SSE SSA)
	#DECL ((SEG) GSEG (SSE) <PRIMTYPE LIST> (SSA) <OR ATOM FALSE>
		(OPEN-SEG) <OR GSEG FALSE>
		(DEV-X DEV-Y) FIX
		(ALL-SEG) <LIST [REST GSEG]>)
	<COND (.OPEN-SEG
	       <ERROR SEG-ALREADY-OPEN!-ERRORS>
	       <GNRL-GSEND>)>
	<COND (<NOT <MEMQ .SEG .ALL-SEG>>
		<ERROR ARG-NOT-VALID-SEGMENT!-ERRORS .SEG>
		<>)
	  (T
	   <PUT .SEG ,SEG-NVS <>>
	   <SET DEV-X <NTH .SEG ,SEG-LX>>
	   <SET DEV-Y <NTH .SEG ,SEG-LY>>
	   <SET OPEN-SEG .SEG>
	   <COND
	       (<NTH .SEG ,SEG-DP>
		<PUT .SEG ,SEG-STAT 'CHANGED>)
	       (T
		<COND (<==? <NTH .SEG ,SEG-STAT> 'OK>
			<PUT .SEG ,SEG-STAT 'APPENDED>
			<PUT .SEG ,SEG-SEED <LIST SEED>>
			<PUT .SEG ,SEG-TAIL <NTH .SEG ,SEG-SEED>>)
		      (T
			<PUT .SEG ,SEG-SEED <CHTYPE <NTH .SEG ,SEG-SEED> LIST>>)>)>)>>

;"REMOVE SEGMENT: ERROR IF SEGMENT IS NOT ON THE LIST OF SEGMENTS
OTHERWISE THE GIVEN SEG IS REMOVED FROM THE LIST OF ALL SEGMENTS
AND THE NEED-ERASE FLAG IS SET INDICATING THAT THE SCREEN NEEDS
ERASING."

<FUNCTION (SEG "AUX" RST)
	#DECL ((SEG) GSEG (ALL-SEG) <LIST [REST GSEG]>
		(REMOVED-SEGS) LIST
		(RST) <PRIMTYPE LIST>)
  <COND (<==? .OPEN-SEG .SEG>
	  <ERROR REMOVING-CURRENT-SEGMENT!-ERRORS>
	  <GNRL-GSEND>)>
  <COND (<SET RST <MEMQ .SEG .ALL-SEG>>
	 <COND (<==? <1 .ALL-SEG> .SEG>
		<SET ALL-SEG <REST .ALL-SEG>>)
	       (T
		<PUTREST <REST .ALL-SEG <- <LENGTH .ALL-SEG>
					   <LENGTH .RST>
					   1>>
			 <REST .RST>>)>
	 <SET REMOVED-SEGS (.SEG !.REMOVED-SEGS)>)
	(T
	 <ERROR ARG-NOT-VALID-SEGMENT!-ERRORS .SEG>)>>


;"END-BATCH-OF-UPDATES: FOR NIL OUTPUT HACKING.
(NOTE ST MEANS SET THE LVStatus TO THE NVStatus.
FIXUP MEANS, FOR NON-DP-SEGMENTS,
ADJUST THE LL TO REFLECT ALTERATIONS MADE


STATUS	NVS=	LVS=T	LVS=<>

CHANGED	T	FIXUP	ST
	<>	ST	-
APPNDD	T	FIXUP	ST
	<>	ST	-
OK	T	-	ST
	<>	ST	-
"
,BASIC-GNU


;"BLANK SEGMENT: IF THE SEGMENT IS VISIBLE, IT IS MADE INVISIBLE.
THIS REQUIRES ERASEING THE SCREEN UNLESS THE SEGMENT HAS STATUS 'NEW.
THE STATUS OF A BLANKED SEGMENT IS 'BLANKED."

<FUNCTION (SEG)
	#DECL ((SEG) GSEG (ALL-SEG) <LIST [REST GSEG]>)
	<COND (<==? .OPEN-SEG .SEG>
	       <GNRL-GSEND>)
	      (<MEMQ .SEG .ALL-SEG>
	       <PUT .SEG ,SEG-NVS <>>)
	      (T <ERROR ARG-NOT-VALID-SEGMENT!-ERRORS .SEG>)>>

;"UNBLANK SEGMENT: MAKES A BLANKED SEGMENT VISIBLE AGAIN."

<FUNCTION ("OPTIONAL" (OPTSEG .OPEN-SEG) "AUX" SEG)
	#DECL ((OPTSEG OPEN-SEG) <OR FALSE GSEG>
		(SEG) GSEG (ALL-SEG) <LIST [REST GSEG]>)
	<COND (<NOT .OPTSEG>
	       <ERROR UNBLANK-ARG-DEFAULTED-BUT-NO-CURRENT-SEGMENT!-ERRORS>)
	      (<==? .OPEN-SEG <SET SEG .OPTSEG>>
	       <GNRL-GSEND>
	       <PUT .SEG ,SEG-NVS T>)
	      (<MEMQ .SEG .ALL-SEG>
	       <PUT .SEG ,SEG-NVS T>)
	      (T <ERROR ARG-NOT-VALID-SEGMENT!-ERRORS .SEG>)>>

;"DOT ABSOLUTE: DRAWS A DOT AT THE GIVEN POSITION. CONDITIONS
AS GIVEN UNDER MOVE ABSOLUTE"

<FUNCTION (X Y "AUX" S)
	#DECL ((X Y DEV-X DEV-Y) FIX
		(S) GSEG
		(OPEN-SEG) <OR FALSE GSEG>)
  <COND (<NOT .OPEN-SEG>
	 <ERROR NO-SEGMENT-IN-PROGRESS!-ERRORS>)
	(T
	 <SET DEV-X .X>
	 <SET DEV-Y .Y>
	 <COND (<NTH <SET S .OPEN-SEG> ,SEG-SEED>
	       <PUT .S
		    ,SEG-TAIL
		    <REST <PUTREST
			    <NTH .S ,SEG-TAIL>
			    ((,OFF-DOT .X .Y))>>>)>)>>


;"INQUIRY RESPONSE: RETURNS A VECTOR DESCRIBING THE TERMINAL"
,IMLAC-INQ

;"FOR ALL GRAPHIC ELEMENTS IN ARG1 APPLY
THE APPROPRIATE ELEMENT OF ARG2 (DISPATCH TABLE) TO THE PROPER
ARGUMENTS"
,SPIN-DP-OR-LIST

;"FREE SLOT"
<FUNCTION ("TUPLE" X)  <ERROR FREE-SLOT-REACHED!-ERRORS .X>>

;"TTY CONTROL READER"
,BAS-ERR

;"HIT-TEST-INITIATE"
,BAS-ERR

;"HIT-TEST-REFINE"
,BAS-ERR
]>

<DEFINE BASIC-GNU ("AUX" (OOPEN-SEG .OPEN-SEG))
	#DECL ((VALUE) 'T 
		(OPEN-SEG) <SPECIAL <OR FALSE GSEG>> (OOPEN-SEG) <OR FALSE GSEG>
		(ALL-SEG REMOVED-SEGS) <LIST [REST GSEG]>)
	<SET REMOVED-SEGS ()>
	<MAPF   <>
		<FUNCTION (SEG "AUX" STAT)
			#DECL ((SEG) GSEG (STAT) ATOM)
			<COND (<N==? .SEG .OOPEN-SEG>
			       <COND (<==? <SET STAT <NTH .SEG ,SEG-STAT>> 'APPENDED>
				      <PUTREST <REST <NTH .SEG ,SEG-LL>
						     <- <LENGTH <NTH .SEG ,SEG-LL>> 1>>
					       <REST <NTH .SEG ,SEG-SEED>>>)
				     (<==? .STAT 'CHANGED>
				      <COND (<NOT <NTH .SEG ,SEG-DP>>
					     <PUT .SEG ,SEG-LL <REST
							 <CHTYPE <NTH .SEG ,SEG-SEED>
								 LIST>>>)>)
				     (<==? .STAT 'OK>)
				     (T <ERROR ILLEGAL-STATUS-ATOM!-ERRRS .STAT>)>
				<PUT .SEG ,SEG-STAT 'OK>
				<PUT .SEG ,SEG-LVS <NTH .SEG ,SEG-NVS>>)>>
		.ALL-SEG>
	T>


<DEFINE IMLAC-INQ ()
	#DECL ((VALUE) VECTOR)
[
	[ 0 0 0 0 0 0 0 0 ]
	[-350 -400 450 400 2]
	[1.0 1.0]
	1
	["IMLAC PDS-1" ""]
	1
	2
	1
	<>
	1
	([11 21 8 12 1])
	()
]
>

<SET LEFT <SET BOTTOM 0>>
<SET RIGHT <SET GTOP 1>>

<SET OPEN-SEG <>>
<SET ALL-SEG ()>
<SET REMOVED-SEGS ()>
<SET USING-TTY <>>
<SET DEV-DISPATCH <BASIC-DISPATCH>>
<USE-INQ-R>

<ENDPACKAGE>
