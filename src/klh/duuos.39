.INSRT KLH;MACROS >

IFNDEF UFRIN$,	UFRIN$==0	;IF SET, TRY HACKING FRACTIONAL INTEGER ARITH

IFNDEF $OPCOD,$OPCOD==331100	;INSTR. OP-CODE BYTE PTR
IFNDEF $ACFLD,$ACFLD==270400	;INSTR. AC FIELD
IFNDEF $ERRCD,$ERRCD==220600	;ERROR CODE FROM .STATUS WD
;;;----------------------------------------------------


UUOH:	0
	LDB U1,[$OPCOD,,40]	;GET OPCODE
	PUSH P,UUOH		;EQV OF PUSHJ P,
	JRST @UUOTAB(U1)	;DISPATCH (SAFELY DUE TO FULL TABLE)

IF2 IFNDEF AUTPSY, AUTPSY=.	;IF FATAL ERROR TRAP NOT DEFINED EXTERNALLY, DO SO HERE.
	0			;(CALLED VIA JSR AUTPSY)
	.VALUE


;;; MACRO TO DEFINE UUO'S. DEFINES NAME AND DEPOSITS ROUTINE ADDR IN TABLE.
;;; TYPICAL USE IS
;;; UUODEF OUTSTR,OUTRTN	;DEFINES "OUTSTR" UUO AND JRSTS TO OUTRTN WHEN XCT'D.

DEFINE UUODEF NAME,HANDLR
IF1 [IFNDEF %%UCNT,%%UCNT==0
%%UCNT==%%UCNT+1
IFE 40-%%UCNT,%%UCNT==50
IFL 77-%%UCNT,PRINTC /TOO MANY UUOS... NO KIDDING!/
NAME=%%UCNT_27.
]
%%SAV==.
LOC UUOTAB+NAME_-27.
	HANDLR
LOC %%SAV
TERMIN

	;;; UUO DISPATCH TABLE, INDEXED BY UUO OPCODE.  UNUSED ENTRIES GO TO
	;;; ILLEGAL UUO ROUTINE.

UUOTAB:	REPEAT 100,ILUUO

	;;; ILLEGAL UUO TRAP.
ILUUO:	EXCH U1,40		;ILLEGAL UUO. SAVE INFO FOR DEBUGGING.
	MOVEM U1,ILU40		;SAVE ILLEGAL UUO BEING XCT'D
	EXCH U1,40		;RESTORE U1
	EXCH U1,UUOH
	MOVEM U1,ILULOC		;SAVE LOCATION+1 OF ILLEGAL UUO
	EXCH U1,UUOH		;RESTORE UUOH
	JSR AUTPSY		;FATAL ERROR.
ILU40:	0
ILULOC:	0

UACFLD:	$ACFLD,,40	;BYTE PTR TO UUO ACC FIELD (USED OFTEN)


define ssfix a,b
	muli a,400
	tsc a,a
	ash a+1,-243+19.!b(a)
termin

;floating to integer conversion -- works for pos/neg
define ifix a
	push p,a+1
	ssfix a,-19.
	move a,a+1
	pop p,a+1
termin

;floating to fractional integer conversion; integer in LH, fraction in RH
define frifix a,loc
	move a,loc
	push p,a+1
	ssfix a,-1
	move a,a+1
	pop p,a+1
termin

define fidiv a,loc
setz a+1,
ashc a,-17.
div a,loc
termin
;safe fractional-integer divide
define sfidiv a,loc
push p,a+1
fidiv a,loc
pop p,a+1
termin

define fimul a,loc
mul a,loc
ashc a,17.
termin
;safe integer-fraction multiply
define sfimul a,loc
push p,a+1
fimul a,loc
pop p,a+1
termin

define float a
	FSC a,233	;FLOAT IT
termin

UUODEF MTRBEG,UMTRBG	;BEGIN METERING
UUODEF MTREND,UMTRE	;END METERING

UMTRCT:	0	;CNT OF METER SUMS
UMTRTM:	0	;SUM OF METER TIME
UMTRAV:	0	;AVERAGE, UMTRTM/UMTRCT
UMTRLT:	0	;HOLDS TIME READ AT BEGIN OF METERING
UMTRBG:	.SUSET [.RRUNT,,UMTRLT]
	POPJ P,
UMTRE:	.SUSET [.RRUNT,,U1]
	SUB U1,UMTRLT	;SUBTRACT TIME AT START OF METERING
	ADDB U1,UMTRTM	;ADD INTO TOTAL METERED TIME
	AOS U2,UMTRCT	;INCR CNT OF METERED LOOPS
	IDIV U1,U2	;GET AVG
	MOVEM U1,UMTRAV	;STORE AS CURRENT AVG
	POPJ P,

UUODEF FD,UFDI		;DRAWS LINE FORWARD E UNITS
UUODEF FORWD,UFD	;DRAWS LINE FORWAD C(E) UNITS
UUODEF FDU,UFDIU	;MOVES FORWARD E UNITS (NO DRAW)

UFDIU:	SKIPG UPEN
	 SETOM UPEN	;JUST THIS ONCE DON'T DRAW.
IFE UFRIN$,[
	CAIA
UFD:	 SKIPA U1,@40
UFDI:	  HRRE U1,40		;GET # UNITS TO MOVE
	FLOAT U1
	FMPR U1,USCALE		;SCALE UP OR DOWN
]
IFN UFRIN$,[
UFDI:	HRLZ U1,40
	CAIA
UFD:	 HRLZ U1,@40
	FIMUL U1,USCALE		;SCALE UP/DOWN
]
	MOVE U2,U1
	MOVE U3,HEADNG
IFE UFRIN$,[
	FMPR U1,COSTAB(U3)
	FMPR U2,SINTAB(U3)	;GET X,Y COMPONENTS
]
IFN UFRIN$,[
	SFIMUL U1,COSTAB(U3)
	FIMUL U2,SINTAB(U3)
]
UFDI0:	MOVNS U2		;NEGATE Y CUZ TV-SCREEN Y-COORD IS INVERTED
	SKIPE UPEN
	 JRST UFD50		;UPDATE W/O DRAWING
	MOVM U3,U1
	MOVM U4,U2		;GET MAGNITUDES TO COMPARE
	CAML U3,U4
	 MOVE U4,U3		;GREATEST DELTA IN U4
IFE UFRIN$,[
	FDVR U1,U4		;GET X-STEP
	FDVR U2,U4		;GET Y-STEP
	FRIFIX U1,U1		;CVT TO INTEG FRACTION
	FRIFIX U2,U2
	MOVEM U1,XSTEP'
	MOVEM U2,YSTEP'		;STORE
	IFIX U4			;GET LOOP CNT
	MOVE U5,U4		;STORE
]
IFN UFRIN$,[
	FIDIV U2,U4
	MOVEM U2,YSTEP'
	FIDIV U1,U4
	MOVEM U1,XSTEP'
	HLRZ U5,U4		;STORE LOOP CNT
]

	MOVE U1,XLOC		;GET LOC TO START DRAWING FROM
	MOVE U2,YLOC
	PUSH P,A
	SKIPE VCONT'		;CONTINUING A PIC?
	 JRST [	SETZM VCONT
		JRST UFDI3]	;NO, START FROM SCRATCH
	SUBI U5,1

UFDI2:	ADD U1,XSTEP
	ADD U2,YSTEP
UFDI3:	HLRZ U3,U1		;GET X
	HLRZ U4,U2		;GET Y
	IMULI U4,18.
	MOVE A,PTWTAB(U3)	;GET BIT IN RIGHT PLACE
	MOVEM A,@TWDTAB(U3)	;STORE IN TV BUFFER
	SOJGE U5,UFDI2

	POP P,A
	MOVEM U1,XLOC
	MOVEM U2,YLOC
	POPJ P,

UFD50:	SKIPG UPEN	;DON'T RESET IF POSITIVE.
	 SETZM UPEN
IFE UFRIN$,[
	FRIFIX U1,U1	;DON'T DRAW IF PEN WAS -1
	FRIFIX U2,U2
]
	ADDM U1,XLOC
	ADDM U2,YLOC
	POPJ P,


UUODEF LT,ULTURI		;CHANGE HEADING BY E DEGREES
UUODEF LEFT,ULTURN		;CHANGE HEADING BY C(E) DEGREES
UUODEF RT,URTURI
UUODEF RIGHT,URTURN

URTURN:	SKIPA U1,@40
URTURI:	 HRRE U1,40
	MOVNS U1
	JRST UTURN
ULTURN:	SKIPA U1,@40
ULTURI:	 HRRE U1,40
UTURN:	SKIPE UREVSW
	 MOVNS U1
	ADD U1,HEADNG		;ADD INTO HEADING
	IDIVI U1,360.		;MODULO 360
	CAIGE U2,0
	 ADDI U2,360.		;NORMALIZE TO POSITIVE
	MOVEM U2,HEADNG		;STORE BACK
	POPJ P,
UREVSW:	0		;0 NORMAL, -1 REVERSE

UUODEF ORIGIN,UORIG		;RESTORE POSITION TO ORIGINAL STATE (0,0 HEADING 90)

UORIG:	MOVE U1,ORIGX
	MOVEM U1,XLOC
	MOVE U1,ORIGY
	MOVEM U1,YLOC
	MOVEI U1,90.
	MOVEM U1,HEADNG
	SETOM VCONT
	POPJ P,

UUODEF SETORG,USTORG		;DEFINE ORIGIN REL TO CENTER OF SCREEN

USTORG:	HLLZ U1,@40		;GET X FROM LH
	ADD U1,UTVCX		;ADD IN COORDS OF TV CENTER
	MOVEM U1,ORIGX
	HRLZ U1,@40		;GET Y FROM RH
	MOVNS U1		;SINCE Y=0 IS TOP OF SCREEN
	ADD U1,UTVCY
	MOVEM U1,ORIGY
	POPJ P,

UUODEF SETSCL,USTSCL		;SET SCALE
USTSCL:	MOVE U1,@40		;GET
IFN UFRIN$,	FRIFIX U1,U1		;CVT TO FRACTIONAL INTEGER
	MOVEM U1,USCALE		;PUT
	POPJ P,

USCALE:	0
XLOC:	0
YLOC:	0
HEADNG:	0
ORIGX:	0
ORIGY:	0
UTVCX:	<576._18.>/2		;IN FRACTIONAL INTEGER FORM.
UTVCY:	<455._18.>/2

UUODEF DSKIPE,UDSKPE		;SKIPS IF POINT AT CURRENT PT IS 0

UDSKPE: HLRZ U3,XLOC
	HLRZ U4,YLOC
	IMULI U4,18.
	MOVE U1,PTWTAB(U3)	;GET MASK
	MOVE U2,@TWDTAB(U3)	;GET TV WD
	AND U1,U2
	CAIN U1,0
	 AOS (P)		;MAKE UUO SKIP IF PT WAS 0
	POPJ P,

;UUODEF DRWPT,UDRWPT		;IORM POINT AT CURRENT LOC
UUODEF DOPT,UDOPT		;DO POINT AT CURRENT LOC

UDOPT:	HLRZ U3,XLOC
	HLRZ U4,YLOC
	IMULI U4,18.
	MOVE U1,PTWTAB(U3)
	MOVEM U1,@TWDTAB(U3)
	POPJ P,

UUODEF PENUP,UPENUP
UUODEF PENDWN,UPENDN

UPEN:	0		;0 FOR DRAW, 1 FOR NEVER DRAW, -1 FOR JUST-THIS-ONCE DON'T DRAW
UPENUP:	MOVEI U1,1	;A POSITIVE #
	MOVEM U1,UPEN	;SO IT DOESN'T DRAW AND STAYS THAT WAY
	POPJ P,
UPENDN:	SETZM UPEN
	POPJ P,

UUODEF SPUSH,USPUSH
UUODEF SPOP,USPOP
UUODEF SPOPDR,USPOPD	;LIKE SPOP BUT DRAWS LINE FROM CURRENT TO PLACE POPPED

USPUSH:	POP P,U1
	PUSH P,XLOC
	PUSH P,YLOC
	PUSH P,HEADNG
	JRST (U1)

USPOP:	POP P,U1
	POP P,HEADNG
	POP P,YLOC
	POP P,XLOC
	JRST (U1)

USPOPD:	POP P,UPPRET	;SAVE RETURN LOC
	POP P,HEADNG
IFE UFRIN$,[
	HLRZ U2,(P)	;NEW Y LOC
	HLRZ U1,-1(P)	;NEW X LOC
	HLRZ U3,XLOC
	HLRZ U4,YLOC
	FLOAT U1
	FLOAT U2
	FLOAT U3
	FLOAT U4
	FSBR U1,U3	;GET DELTA X
	FSBRM U4,U2	;<DELTA Y>
]
IFN UFRIN$,[
	MOVE U2,(P)
	MOVE U1,-1(P)
	SUB U1,XLOC	;DELTA X
	SUB U2,YLOC	;<DELTA Y>
	MOVNS U2
]
	PUSHJ P,UFDI0	;GO DRAW IT
	POP P,YLOC
	POP P,XLOC
	JRST @UPPRET
UPPRET:	0

UUODEF RRLV,URRLV	;DRAW (ROTATIVE)RELATIVE VECTOR, C(E) HAS DX,,DY
UUODEF RRLVU,URRLVU	;DITTO BUT PENUP
UUODEF RLV,URLV		;LIKE RRLV BUT NO ROTATION
UUODEF RLVU,URLVU	;DITTO

; MUST GET NEW X = X*COS-Y*SIN
;	NEW Y = X*SIN+Y*COS
URRLVU:	SKIPG UPEN
	 SETOM UPEN	;don't clobber if pen already up.
URRLV:	MOVE U5,HEADNG
IFE UFRIN$,[
	HLRE U1,@40
	HRRE U2,@40
	FLOAT U1
	FLOAT U2
	FMPR U1,USCALE
	FMPR U2,USCALE
	MOVE U3,U1
	MOVE U4,U2
	FMPR U1,COSTAB(U5)	;X*COS
	FMPR U2,COSTAB(U5)	;Y*COS
	FMPR U3,SINTAB(U5)	;X*SIN
	FMPR U4,SINTAB(U5)	;Y*SIN
	FSBR U1,U4		;NEW X
	FADR U2,U3		;NEW Y
]
IFN UFRIN$,[
	HLLZ U1,@40
	HRLZ U2,@40
	SFIMUL U1,USCALE
	FIMUL U2,USCALE
	MOVE U3,U1
	MOVE U4,U2
	SFIMUL U1,COSTAB(U5)
	SFIMUL U2,COSTAB(U5)
	SFIMUL U3,SINTAB(U5)
	SFIMUL U4,SINTAB(U5)
	SUB U1,U4
	ADD U2,U3
]
	PJRST UFDI0

URLVU:	SKIPG UPEN
	 SETOM UPEN
URLV:
IFE UFRIN$,[
	HLRE U1,@40
	HRRE U2,@40
	FLOAT U1
	FLOAT U2
	FMPR U1,USCALE
	FMPR U2,USCALE
]
IFN UFRIN$,[
	HLLZ U1,@40	;GET DELTA X
	HRLZ U2,@40
	SFIMUL U1,USCALE
	FIMUL U2,USCALE
]
	PJRST UFDI0	;GO DO IT

UUODEF CLRPIC,UCLRPI
UUODEF DRWPIC,UDRWPI
UUODEF XORPIC,UXORPI		;SETS ALU TO XOR, AND DRAWS PIC AT E
UUODEF REVPIC,UREVPI		;LIKE XOR BUT REVERSE HANDEDNESS

UCLRPI:	MOVEI U1,2		;ALU VALUE FOR ANDCAM
	JRST UPIC
UDRWPI:	SKIPA U1,[16]		;ALU VALUE FOR IORM
UXORPI:	 MOVEI U1,6		;ALU VALUE FOR XORM
UPIC:	CAMN U1,UTVALU		;DON'T SMASH IF MATCHES CURRENT ALU VALUE
	 PJRST @40		;NO NEED TO CHANGE, GO DO IT.
	.SUSET [.RTVCR,,STVCRG]
	MOVE U2,STVCRG
	DPB U1,[341000,,U2]	;MUST CHANGE-- UPDATE
	MOVEM U2,TVCREG		;CLOBBER DIRECTLY
	.SUSET [.STVCR,,U2]	;CLOBBER LEGALLY
	MOVEM U1,UTVALU
	PJRST @40
UTVALU:	-1
STVCRG:	0

UREVPI:	SETCMM UREVSW
	PUSHJ P,UXORPI
	SETCMM UREVSW
	POPJ P,
DEFINE REVRSE
SETCMM UREVSW
TERMIN

DEFINE MOVPIC PIC,ANG1,MOV,ANG2
SPUSH
XORPIC PIC
SPOP
LT ANG1
FDU MOV
LT ANG2
XORPIC PIC
TERMIN


UUODEF DSTART,UDSTRT		;INITIALIZES TV AND DISPLAY STUFF

UDSTRT:	PUSHJ P,TRIGIN		;SET UP TRIG TABLES
	PUSHJ P,TVMAPR		;SET UP TV
	SETOM UTVALU
	SETZM UPEN
	SETZM UREVSW
	MOVSI U1,(1.0)
IFN UFRIN$,	FRIFIX U1,U1
	MOVEM U1,USCALE
	MOVE U1,UTVCX
	MOVEM U1,ORIGX
	MOVE U1,UTVCY
	MOVEM U1,ORIGY
	SETZM HEADNG
	POPJ P,

;doc snarfed from BKPH;BULL >
;tv's have 455. vertical lines of 576. dots each (262080. bits out 'o 262144).

;memory is organized as 9 64.-bit words (equiv to 18. 32.-bit words) per line.
;the pdp10 accesses half of such a word (or two 16.-bit chunks) at once.
;these 32. bits are packed left justified into the 36. bits.

;tvend (or the last word of the tv-memory) has two functions:
;bit  200000 when on, complements the black/white output.
;bits 177760 are a word-counter for which 64.-bit word the frame is to start on.
;for winnage the number ought to be a multiple of 9.

;Characters are 10. lines high and 5 points wide (right and top justified).
;Line-pitch is 12. TV-lines, Character-pitch is 6 TV-points.
;Thats 96. chrs/line exactly and 37. and 11./12. lines (3552. chrs).


tvpage==367			;want to use top 11 pages of core.
tvbeg=tvpage*2000		;addr of beg of tv buffer
tvend=<tvpage+10>*2000-1	; b/w bit and frame start #
tvcreg=tvend+1			;wd just after tvend is tvcreg (ALU funct and vid sw)

tvmapr:	push p,a
	push p,b
	move a,[-11,,tvpage]
	setz b,
	.call [setz ? 'corblk ? 1000,,600000
		1000,,-1
		a
		1000,,-2
		setz b]
	.value [asciz /: Can't get TV pages???/]
	pop p,b
	pop p,a
	popj p,

; 576. wds, one for each possible X in scan line. indexed by X to produce wd with bit in
; right place for movem'ing into TV buffer.
ptwtab:	repeat 18.,[.outrc==.rpcnt
		repeat 32., <setz_-.rpcnt>
]

twdtab:	repeat 18.,[.outrc==.rpcnt
		repeat 32., .outrc+tvbeg(U4)
]

SINTAB:	BLOCK 360.
COSTAB:	BLOCK 360.

TRIGIN:	PUSHAE P,[A,B]
	MOVSI B,-360.
TRIG1:	HRRZ A,B
	FLOAT A
	PUSH P,A
	PUSHJ P,SIND
IFN UFRIN$,	FRIFIX A,A
	MOVEM A,SINTAB(B)
	POP P,A
	PUSHJ P,COSD
IFN UFRIN$,	FRIFIX A,A
	MOVEM A,COSTAB(B)
	AOBJN B,TRIG1
	POPAE P,[B,A]
	POPJ P,



;FLOATING POINT SINE AND COSINE.  REENTERABLE.

SIND:	FMPR A,[.01745329251994]	;PI/180
	JRST SIN

COSD:	FMPR A,[.01745329251994]
COS:	FADR A,SC1	;PI/2
SIN:	CAMG A,SC9	;.000211431983 IS SUFFICIENT FOR IDENTITY, 10**-15 IS NECESSARY NOT TO UNDERFLOW
	CAMGE A,[-.000211431983]	;ABS X MIGHT CAUSE POLYNOMIAL UNDERFLOW
	JRST .+2
	POPJ P,		;AND IS SMALL ENOUGH FOR SIN X _ X
	FDVR A,SC1	;PI/2
	PUSH P,A
	PUSH P,B
	MULI A,400
	TSC A,A		;CAML A,...SETZB B,-1(P)
	ASH B,-243(A)
	MOVNS A,B
	ANDCMI A,1
	TLC A,232000
	FAD A,A
	FADRB A,-1(P)
	TRNE B,2
	MOVNS A,-1(P)
	FMP A,A
	MOVE B,SC9
	FMP B,A
	FAD B,SC7
	FMP B,A
	FAD B,SC5
	FMP B,A
	FAD B,SC3
	FMP A,B
	FADR A,SC1
	FMPRM A,-1(P)
	POP P,B
	POP P,A
	POPJ P,

SC1:	1.5707963267
SC3:	-0.64596371106
SC5:	0.07968967928
SC7:	-0.00467376557
SC9:	0.00015148419

PIE==3.14159
PI2==PIE*2.0
