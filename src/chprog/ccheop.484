;CHEOPS CONSOLE PROGRAM
;TO BE INSERTED
;CMFLAG MUST BE DEFINED TO SAY WHAT PRGM
;  -1 UNIFARCE TESTER
;  0  OCM
;  1  CM

;UUOS THAT MUST BE DEFINED BY INSERTING PRGM
;HXCT		;PUT INST POINTED TO BY E IN CHEOPS IR AND EXECUTE IT
;HLOAD		;AC HAS LOAD SELECT CODE, DATA IN C(E). STORES DATA IN CHEOPS.
;HSTORE		;AC HAS MUX SELECT CODE, DATA READ FROM THERE INTO E.
;HLOADIR	;PUT INST POINTED TO BY E INTO CHEOPS IR.
;HSOUT		;PRINT ASCIZ STRING POINTED TO BY E ON TTY. MUST NOT CLOBBER ANY ACS.
;UUO HANDLER MUST SAVE AC S IN A BLOCK AT HUUOAC AND XFER TO
; APPROPRIATE SERVICE ROUTINE.  IT WILL POPJ WHEN DONE, WHICH SHOULD
; GO TO UUO EXIT ROUTINE WHICH RESTORES ACS
; THE AC S, TYO, TYI, AND CRR MUST ALSO BE DEFINED.
;MAIN PROGRAM SHOULD ENABLE INTERRUPTS AND JSR TO HUUINT ON A TTY INPUT INTERRUPT
; (IF HTTYMD .NE. 0 ANYWAY).  AC A MUST HAVE BEEN SAVED.

X=PUSHJ P,

UNIFA=740000	;UNIFARCE ADDRESS IN 10 MEMORY
HBMEM=734000	;BUFFER ADDRESS IN 10 MEMORY
HBMEML==4000	;SIZE OF BUFFER MEM IN PDP10 WDS

IFNDEF CBBAS,CBBAS==40000	;BASE ADR OF CHEOP'S BUFFER MEMORY (PDP11 UNIBUS ADR)
IFNDEF CBLEN,CBLEN==20000	;LENGTH BUFFER MEMORY IN BYTES
IFNDEF CBABL,CBABL==40	;LOCATION IN CHEOPS ES BUFFER MEM OF HIGH PRIORITY ARG
			;BLOCK PDP-10 WORD ADDR RELATIVE TO BEGINNING OF BUFFER MEM

CHECML==2000	;EXISTING CHEOPS CONTROL MEMORY SIZE

T11LH==242000
T11RH==042000
;CTRL, STATUS, DBR, MUX
HMUX==T11RH,,UNIFA+1
HMUXSL==340400,,UNIFA
HLODSL==250400,,UNIFA

T11REL==122000	;REL ADR FIELD IN T11MP
T11==320300	;PDP11 # FIELD IN T11MP WD
HPAGE==UNIFA_<-10.>	;TO ADDR UNIFA IN T11MP WD

DEFINE HCONC A,B
A!B!TERMIN


;"EMT" DEFS

IF2 [
ERCMEM==X XRCMEM	;READ CONTROL MEM LOCN IN B TO 4 WD BLOCK (A)
EWCMEM==X XWCMEM	;WRITE LIKEWISE
ERPDLB==X XRPDLB	;READ DATA PDL LOCN IN B INTO LOCN POINTED TO BY A
EWPDLB==X XWPDLB	;WRITE "   "    "   "  " FROM  "     "     "   " "
ERUSTK==X XRUSTK	;READ U STACK LOCN IN B INTO LOCN POINTED TO BY A
EWUSTK==X XWUSTK	;WRITE LIKEWISE
ERAC==X XRAC		;READ AC OR AAC IN B INTO LOCN (A) (IE A B-BUS ADR)
EWAC==X XWAC		;WRITE LIKEWISE
ERSQL==X XRSQL		;READ SQUARE LIST LOCN IN B INTO LOCN (A)
EWSQL==X XWSQL		;WRITE LIKEWISE
ERPLOC==X XRPLOC	;READ PIECE-LOC LOCN IN B INTO LOCN (A)
EWPLOC==X XWPLOC	;WRITE LIKEWISE
ERPVAL==X XRPVAL	;READ PIECE-VAL LOCN IN B INTO LOCN (A)
EWPVAL==X XWPVAL	;WRITE LIKEWISE
ERPTYP==X XRPTYP	;READ PIECE-TYPE LOCN IN B INTO LOCN (A)
EWPTYP==X XWPTYP	;WRITE LIKEWISE
ERPXM==X XRPXM		;READ PIECE-EXISTS "MEMORY"
EWPXM==X XWPXM		;WRITE LIKEWISE
ERAS==X XRAS		;READ A-SOURCE IN B INTO LOCN(A)
EROS==X XROS		;READ O-BUS SELECT CODE IN B INTO LOCN (A)
EWOD==X XWOD		;WRITE CONTENTS (A) INTO OUTPUT DESTINATION IN B

ERSIR==X XRSIR		;READ SIR INTO (A)
EWSIR==X XWSIR		;WRITE LIKEWISE
ERSR==X XRSR		;READ SR INTO (A)
EWSR==X XWSR		;WRITE LIKEWISE
ERPR==X XRPR		;READ PR INTO (A)
EWPR==X XWPR		;WRITE LIKEWISE

ESUSP==X XSUSP		;SAVE U-STACK POINTER INTERNALLY IF HAVENT ALREADY
ESPAR==X XSPAR		;SAVE PAR POINTER INTERNALLY IF HAVENT ALREADY

ERIR==X XRIR		;READ IR (FOUR WDS WORTH FROM IR A THRU D) INTO BLOCK(A)
EWIR==X XWIR		;WRITE IR FROM FOUR WD BLOCK(A).  IR A THRU D ARE WRITTEN,
			; AND IF THE AMOP BIT IS ON, IRA C AND D ARE ALSO WRITTEN.
ERFIR==X XRFIR		;READ FULL IR INTO 6 WD BLOCK (A).
EWFIR==X XWFIR		;WRITE FULL IR FROM 6 WD BLOCK(A).

ERFLG==X XRFLG		;READ FLAG WDS A THRU D INTO 4 WD BLOCK (A)
EWFLG==X XWFLG		;WRITE FLAG WDS A THRU D FROM 4 WD BLOCK (A)

ERERWS==X XRERWS	;READ ERROR STATUS INTO 3 WD BLOCK (A).
			; WD0 GETS UNIBUS STATUS (FROM 176002)
			; WD1 GETS "PARITY BITS" FROM MUX INPUT 14
			; WD2 GETS "SPEC-FCTN BITS" FROM MUX INPUT 15

EWPIEC==X XWPIEC	;WRITE PIECE IN (A) INTO SQUARE IN B.
			; WRITES SQUARE LIST, PIECE LIST AND PIECE-EXISTS MEMS.

ESTOP==X XSTOP		;STOP CHEOPS, CLEAR HRUN, LEAVE HTRUN ALONE.
ECLK==X XCLK		;SINGLE STEP CHEOPS
ERESET==X XRESET	;RESET CHEOPS
ESRUN==X XSRUN		;SET RUN IN CHEOPS
ESRUNS==X XSRUNS	;SET RUN AND ENABLE STAT STOP
ESUCW==X XSUCW		;SET UNIFACE CONTROL WD. A HAS DESIRED CONTENTS IN BITS
			; MASKED BY B.  LEAVE REST OF THE BITS THE SAME.
EOCTP==X XOCTP		;OCTAL PRINT DATA IN B. NUMBER OF OCTAL DIGITS DESIRED IN C

EDPB==X XDPB		;DEPOSIT DATA IN B INTO BLOCK POINTED TO BY A. BYTE DESC
			; IN C
ELDB==X XLDB		;LOAD INTO A SPEC BYTE FROM BLOCK POINTED TO BY A. BYTE
			; SPEC IN B

EPI==X XPI		;PRINT U INST POINTED TO BY A
EPIF==X XPIF		;PRINT "FULL" U-INST. IE BOTH IR AND IRA, 6 WDS WORTH.
IPNFLD==X XPNFLD	;PRINT NUMBERIC FIELD. DATA BLOCK POINTER IN A, BYTE DESC
			; IN B
EPERRS==X XPERRS	;PRINT ERRS AS SPECIFIED BY 3 WD BLOCK POINTED TO BY A.
			;  BLOCK IS IN FORMAT OF ERERWS
EPRPC==X XPRPC		;PRINT (A) AS PIECE
EPRPCL==X XPRPCL	;PRINT "LEFT HALF" (SIXTEEN BITS WISE) OF (A) AS PIECE
EPRSQ==X XPRSQ		;PRINT (A) AS SQUARE
]

;CHEOPS UCODE DEFS

;WD0 DEFS
 HINH==1_15.	;INHIBIT WRITE ON SUCCESSFUL XFER
  %H0INW==.BP HINH
  %H0CF==.BP 074000	;BYTE POINTER TO COND FIELD
  %H0JF==.BP 003777	;BYTE POINTER TO JUMP FIELD
;COND FIELD QUARTER DEFS
H0CAMS==1	; 0 		0 		0 		ANY-MORE-SQUARES 
H0CAMP==2	; 0 		0 		ANY-MORE-PIECES 0
H0CCHK==3	; 0		KCHK		0		0
H0CQ4==4	; LEGAL		DEEP		ALU-EQUAL	ALU-NO-CARRY-OUT
H0CALU==5	; 0		0		ALU-LESS	ALU-LESS-OR-EQUAL
H0CEXB==6	; 0		EXTB2		EXTB1		EXTB0
H0CQ7==7	; STACK-END-CHECK STM		P-BUS-NOBLE	P-BUS-PAWN
H0CQ10==10	; TERM-RANK	PROMOTING-POSS	SELECTED-SQUARE	ANY-SQUARES
H0CQ11==11	; ANY-RANK	TYP2		TYP1		TYP0
H0CQ12==12	; 0		OFF-BOARD	PROMOTE-P	E-P-CAPT
H0CQ13==13	; SEL-P-EXISTS	0		Q-CAS-LGL	K-CAS-LGL
H0CQCNP==14	; WQR MVD	WKR MVD		BQR MVD		BKR MVD
H0CQ15==15	; FLAGCELL-7	KCHKF		DEEP		LEGAL
H0CQ16==16	; 0		UNIBUS-CYCLE	PDP-11-FLAG-1	PDP-11-FLAG-0

;WD1 DEFS
H1AMOP==1_15.	;ARRAY INST OP CODE BIT
 %H1AMOP==.BP H1AMOP
H1STAT==1_14.	;STATISTICS BIT
 %H1ST==.BP H1STAT
H1PSHJ==1_13.	;PUSHJ BIT
 %H1PSJ==.BP H1PSHJ
H1POPJ==1_12.	;POPJ BIT
 %H1RET==.BP H1POPJ
H1PINC==20_7	;PAF INCREMENT (BY 4 BIT TWOS COMP #)
H1PSA==0_7	;SAVE PAR IN AAC N  (SHIFT N 7)
H1PRA==1_7	;RESTORE PAR FROM AAC N  (SHIFT N 7)
 %H1PAF==.BP 007600
H1UBRD==1_5	;INITIATE UNIBUS RD CYCLE
H1UBWR==2_5	;INITIATE UNIBUS WRITE CYCLE
H1UBIN==3_5	;INITIATE UNIBUS INTERRUPT REQ
 %H1UB==.BP H1UBIN
H1ELNG==20	;E LONG BIT
 %H1EL==.BP H1ELNG
;FLAG-CONTROL FCTNS
H1FINF==1	;INITIALIZE-NEXT-FLAGCELL-WORD
H1FSG==2	;SAVE-NEXT-GHOST-POSITION
H1FMNC==3	;MODIFY-NEXT-CASTLE-FLAGS-IF-CASTLE-SQUARE-ON-SQUARE-BUS
H1FCSM==4	;CHANGE-SIDE-TO-MOVE
H1FWTM==5	;FORCE-WHITE-TO-MOVE
H1FBTM==6	;FORCE-BLACK-TO-MOVE
H1FSD==7	;SET-DEEP   (NOTE: NOT NEXT-DEEP)
H1FCD==10	;CLEAR-DEEP (NOTE: NOT NEXT-DEEP)
H1FSKC==11	;SET-NEXT-KCHK-FROM-SELECTED-SQUARE
H1FSLG==12	;SET-LEGAL
H1FCLG==13	;CLEAR-LEGAL
H1FLFC==14	;LOAD-FLAGCELL-FROM-NEXT-FLAGCELL
H1FCSK==15	;CHANGE-SIDE-TO-MOVE AND SET-NEXT-KCHK-FROM-SELECTED-SQUARE
H1FSGM==16	;SAVE-NEXT-GHOST-POSITION AND MODIFY-NEXT-CASTLE-FLAGS
 %H1FC==.BP 000017

;WD2 DEFS ARRAY MODULE INSTRUCTION
H2ARYS==1_15.	;ARRAY SELECT (1 DESTINATION)
 %H2AYS==.BP H2ARYS
H2ACP==1_14.	;0 MOVES, 1 CAPTS
 %H2ACP==.BP H2ARYS
H2AALS==1_13.	;0 SIR SQ, 1 ALL SQS
 %H2AAS==.BP H2AALS
H2ANEN==1_12.	;NOBLE ENABLE
 %H2ANE==.BP H2ANEN
H2APEN==1_11.	;PAWN ENABLE
 %H2APE==.BP H2APEN
H2APX==1_10.	;PEX BIT
 %H2APX==.BP H2APX
H2AWPX==1_9.	;WPEX WRITE PULSE
 %H2WPX==.BP H2AWPX
H2AWSR==1_8	;SR WRITE PULSE
 %H2WSR==.BP H2AWSR
H2AWSIR==1_7	;SIR WRITE PULSE
 %H2WSI==.BP H2AWSIR
H2AWPR==1_6	;PR WRITE PULSE
 %H2WPR==.BP H2AWPR
H2AWMV==1_5	;WMOVE WRITE PULSE
 %H2WMV==.BP H2AWMV
H2APSR==1_4	;PDL SOURCE
 %H2APS==.BP H2APSR
H2AWDT==1_3	;WRITE DATA (IN PLACE OPPOSITE OF SPECD BY PDL SOURCE BIT)
 %H2AWD==.BP H2AWDT
 %H2AAC==.BP 000007	;ARY AC IN LOW 3 BITS

;WD3 DEFS ARRAY MODULE INSTRUCTION
H3APSB==1_10.	;PS-BUS SELECTOR (3 BITS)
 %H3SPS==.BP 016000
H3ALPS==1_9	;LAST PIECE SELECTOR BIT (0 LEFT A BUS, 1 PR)
 %H3SLP==.BP H3ALPS
H3APBB==1_6	;PIECE-BUS SELECTOR (3 BITS)
 %H3SPB==.BP 000700
H3APRS==1_5	;PR SELECTOR (0 LEFT A BUS, 1 NEXT-PIECE)
 %H3SPR==.BP H3APRS
H3ALSS==1_4	;LAST SQUARE SELECTOR BIT (0 HIS K LOCN, 1 SR)
 %H3SLS==.BP H3ALSS
H3ASQB==1_2	;SQUARE BUS SELECTOR (2 BITS)
 %H3SSB==.BP 000014
H3ASRS==1_1	;SR SELECTOR (0 RIGHT A BUS, 1 NEXT-SQUARE)
 %H3SSR==.BP H3ASRS
H3ASIS==1_0	;SIR SELECTOR (0 SQUARE-BUS, 1 PIECE-LOC)
 %H3SSI==.BP H3ASIS

;WD2 DEFS ALU INSTRUCTION
%H2ASH==.BP 176000	;BYTE POINTER TO HIGH A-SOURCE FIELD (FOR NON-IMMED INST)
%H2LIM==.BP 177400	;BYTE POINTER TO IMMEDIATE DATA FIELD
%H2PR==.BP 177400	;BYTE POINTER TO PDL-REGISTER FIELD
%H2LOD==.BP 000374	;BYTE POINTER TO ODEST FIELD
%H2ASL==.BP 000374	;BYTE POINTER TO LOW A-SOURCE FIELD (FOR PDL-DEST INST)
%H2LIT==.BP 000003	;BYTE POINTER TO ALU-INST TYPE FIELD
 H2LNIM==0	;NON-IMMEDIATE INSTRUCTION
 H2LIMM==1	;IMMEDIATE INSTRUCTION
 H2LPSR==2	;PDL SOURCE
 H2LPDS==3	;PDL DESTINATION

;WD3 DEFS ALU INSTRUCTION
H3LOBB==1_10.	;O-BUS SELECTOR (3 BITS)
 %H3LOB==.BP 016000
H3LCRY==1_9	;CARRY IN TO ALU
 %H3LCY==.BP H3LCRY
H3LALM==1_8		;ALU MODE
H3LALU==1_4		;ALU MODE (4 BITS)
 %H3LAL==.BP 000760
 %H3LBB==.BP 000017	;BBUS ADR IN LOW 4 BITS


;A-SOURCE S
HASPDL==0		;PDL
HASORG==2		;OREG
HASPSB==3		;PSBUS
HASFC==4		;FLAG-CELL
HASNFC==5		;NEXT-FLAG-CELL
HASEXB==6		;EXTERNAL-BUS
HASFLA==10		;FLAG A
HASFLB==11		;FLAG B
HASFLC==12		;FLAG C
HASFLD==13		;FLAG D
HASSTA==14		;STAT A
HASSTB==15		;STAT B
HASUAR==16		;UAR
HASUDR==17		;UDR
HASAC==20		;AC (+ AC #)

;ODEST S
HODUDR==2		;UDR
HODUAR==3		;UAR
HODSTA==4		;STAT A
HODSTB==5		;STAT B
HODWMV==10		;W-MOVE
HODSIR==11		;SIR
HODTYP==13		;TYP
HODVAL==14		;VAL
HODSR==15		;SR (FROM R A-BUS)
HODPR==16		;PR (FROM L A-BUS)
HODPSR==17		;BOTH PR AND SR (FROM A-BUS)
HODPDL==20		;PDL
HODUS==21		;U-STACK (SPC)
HODUSP==22		;U-STACK PTR (SPCPTR)
HODFC==23		;FLAG-CELL
HODNFC==24		;NEXT-FLAG-CELL
HODSTR==25		;STAR (SOFTWARE STATUS REG READABLE FROM UNIBUS)
HODEXC==26		;EXTERNAL-DEVICE (CONTROL)
HODEXD==27		;EXTERNAL-DEVICE (DATA)
HODAC==60		;AC (+ AC #)
HODAAC==70		;AAC (+ AAC #)

;OUTPUT SELECTOR CODES
HOSALU==0		;ALU
HOSALS==1		;ALU SWAPPED
HOSRLC==2		;RELOC
HOSDBR==3		;DBR
HOSUSP==4		;U-STACK POINTER (SPCPTR)
HOSUS==5		;U-STACK (SPC)
HOSSW==6		;SWITCH REGISTER
HOSPSB==7		;PS-BUS


;UNIBUS REGISTERS
;XXXX00	UNIBUS CONTROL
HU0F1==1_15.	;PDP11 FLAG 1
HU0F0==1_14.	;PDP11 FLAG 0
HU0LSC==1_13.	;0 -> LOAD DIAR ON STAT BIT, 1-> ON EVERY CLOCK
HU0SER==1_12.	;1 -> STOP ON ERROR
;MUX SELECT (SHIFT THESE 8)
 H0MIA==0	;MUX SELECT TO READ IR A
 H0MIB==1	;MUX SELECT TO READ IR B
 H0MIC==2	;MUX SELECT TO READ IR C
 H0MID==3	;MUX SELECT TO READ IR D
 H0MIAC==4	;MUX SELECT TO READ IRA C
 H0MIAD==5	;MUX SELECT TO READ IRA D
 H0MPC==6	;MUX SELECT TO READ PC
 H0MOAD==7	;MUX SELECT TO READ OLD-ADR
 H0MDIA==10	;MUX SELECT TO READ DIAGNOSTIC REGISTER
 H0MOB==11	;MUX SELECT TO READ O-BUS
 H0MPAR==14	;MUX SELECT TO READ PARITY BITS WORD
 H0MSFN==15	;MUX SELECT TO READ SPECIAL FUNCITON BITS
 H0MFLD==16	;MUX SELECT TO READ UDR
HU0RES==1_7	;RESET
HU0IEB==1_6	;INTERRUPT ENABLE (ENABLE CHEOPS TO GENERATE 11 INTERRUPTS)
HU0NEB==1_5	;NPR ENABLE (ENABLE CHEOPS TO MAKE NPR MEMORY REFS)
;LOAD SELECT WHEN H0GO = 0 (SHIFT THESE 1)
 H0LIA==1	;LOAD SELECT IR A
 H0LIB==2	;LOAD SELECT IR B
 H0LIC==3	;LOAD SELECT IR C
 H0LID==4	;LOAD SELECT IR D
 H0LIAC==5	;LOAD SELECT IRA C
 H0LIAD==6	;LOAD SELECT IRA D
 H0LUDR==7	;LOAD SELECT UDR
 H0LCMA==10	;LOAD SELECT CMEM A
 H0LCMB==11	;LOAD SELECT CMEM B
 H0LCMC==12	;LOAD SELECT CMEM C
 H0LCMD==13	;LOAD SELECT CMEM D
 H0LFLA==14	;LOAD SELECT FLAG A
 H0LFLB==15	;LOAD SELECT FLAG B
 H0LFLC==16	;LOAD SELECT FLAG C
 H0LFLD==17	;LOAD SELECT FLAG D
;WHEN H0GO =1
HU0STS==1_3	;STATISTICS STOP
HU0SS==0_1	;SINGLE STEP
HU0SLO==1_1	;SLOW SPEED
HU0CRZ==2_1	;CRUISE SPEED
HU0FAS==3_1	;FAST SPEED
HU0GO==1_0	;GO


;STATUS REGISTER XXXX02
HU2RUN==1_15.	;RUN FLOP
HU2HER==1_14.	;HIRUN ERROR
HU2PAR==1_13.	;PARITY ERROR
HU2NXM==1_12.	;NXM
HU2SPO==1_11.	;SPC OVFLO
;LOW 6 BITS ARE STAR (SOFTWARE STATUS REGISTER)
 %HSTAR== 040600,,		;BYTE POINTER TO LOAD STAR FROM UNIFA
;NEXT 4 BITS ARE DOORBELL REGISTER
 %HDBL==  120400,,

;DBR  XXXX04
;MUX  XXXX06
;BITS IN PARITY REGISTER (MUX SELECT 14)
H6PPOU==1_15.	;POUT
H6PTYP==1_14.	;TYP
H6PVAL==1_13.	;VAL
H6PLOC==1_12.	;LOC
H6PSPC==1_11.	;SPC
H6PIR==1_10.	;IR
H6PRPD==1_9.	;R PDL
H6PLPD==1_8.	;L PDL
H6PSPO==1_7.	;SPC OVFLO
H6PNXM==1_6.	;NXM
H6PRBB==1_5.	;R B-BUS
H6PLBB==1_4.	;L B-BUS
H6PRAC==1_3.	;R AC
H6PLAC==1_2.	;L AC
H6PRAA==1_1.	;R AAC
H6PLAA==1_0.	;L AAC

;BITS IN SPEC-FCTN WD (MUX SELECT 15)
H6FSTM==1_7	;SIDE TO MOVE
H6FPMV==1_6	;PRO MV (PROMOTING MOVE POSSIBLE)
H6FEPC==1_5	;EN PASENT CAPT (5TH RANK P CAPTURING INTO FILE OF GHOST)
H6FTGF==1_4	;TO GHOST FILE
H6FF5R==1_3	;FROM 5TH RANK
H6FTRK==1_2	;TRANK
H6FPRO==1_1	;PROMOTE (PAWN MOVE AND TRANK)
H6FPMV==1_0	;PAWN MOVE

;CHEOPS REGISTER ADDRESS DEFS
HRORG==40000	;ORIGIN OF CHEOPS REGISTER ADDRESS SPACE
HRCMO==40000	;ORIGIN OF CONTROL MEM
 HRCME==44000	; CONTROL MEM (C) 2K
HRPDO==44000
 HRPDE==46000	; DATA PDL (P) 1K
HRUSO==46000
 HRUSE==46400	; U STACK (U) 256 REG
HRACO==46400
 HRACE==46420	; AC S AND AAC S (A) 16 REG TOTAL
  HRRPAR==46410	;  PAR IS AAC 0
;(BEFORE SQ LIST AND PC LIST SO ARRAYS GET LOADED CORRECTLY WHEN SCANNING UP)
HRPTO==46420
 HRPTE==46520	; PIECE TYPE (T) 64 REG 
HRSQO==46520
 HRSQE==46620	; SQUARE LIST (S) 64 REG
HRPLO==46620
 HRPLE==46720	; PIECE LOC (L) 64 REG
HRPVO==46720
 HRPVE==47020	; PIECE VALUE (V) 64 REG
HRPXMO==47020	; PIECE-EXISTS "MEMORY"  (64 LOCN)  EACH LOCN IS A BIT.
 HRPXME==47120	;  ADDRESSES CORRESPOND WITH PIECE-LOC MEMORY
		;  LOCNS 0-7 AND 40-47 SHOULD BE ALWAYS 0
		;  SINCE THEY CORRESPOND TO NULL PIECES.
HRRDRO==47120	; RAID REGISTERS
 HRRDRE==47130  
HRRGO==47130
 HRRGE==47330	; RANDOM REGISTERS AND THINGS
  HRRFLA==47130	;  FLAGA (THESE PRINT NUMERICALLY)
  HRRFLB==47131	;  FLAGB
  HRRFLC==47132	;  FLAGC
  HRRFLD==47133 ;  FLAGD
  HRRSTA==47134	;  STATA
  HRRSTB==47135	;  STATB
  HRRUAR==47136	;  UAR
  HRRUDR==47137	;  UDR
  HRRORG==47140	;  OREG
  HRRFC== 47141	;  FLAGCELL
  HRRNFC==47142	;  NEXT-FLAGCELL
  HRRUSP==47143	;  U-STACK POINTER
  HRRSIR==47144	;  SIR
  HRRSR== 47145	;  SR
  HRRPR== 47146	;  PR
  HRRIR== 47147	;  IR
  HRRIRA==47150	;  IRA (2 WDS WORTH, SO GETS LOADED, DUMPED, AND CLEARED)
  HRRNAF==47151	;  NAF  (THIS IS ACTUALLY IR 10-0)
  HRRPC== 47152	;  PC
  HRRSC== 47153	;  STEP COUNT (INTERNAL TO CONSOLE PROG, THIS REGISTER COUNTS
		;   FOR EVERY STEP TAKEN BY ^N ETC.  CLEARED BY ^P OR :TP
  HRRLTP==47154	;  LAST TEST POSITION USED
  HRRSA== 47155	;  UCODE STARTING ADR
  HRRSTR==47156	;  STAR (UNIBUS STATUS REGISTER)
  HRRDBL==47157 ;  DOORBELL REGISTER
HRRDMP==47157	;LAST REGISTER LOCATION INCLUDED IN DUMP FILE
HRVO==  47157	;ORIGIN OF "VIRTUAL REGISTERS" IN REGISTER SPACE
  HRRSET==HRVO+1	;  RESET REGISTER (STUFF DEPOSITED HERE GETS PUT EVERYWHERE!)
;-CONTINUES ON NEXT PAGE-

;THE FOLLOWING GROUP ARE PSEUDO-REGISTERS, WHOSE VALUES ARE OBTAINED BY
;READING THE INDICATED POINTS WITH THE REST OF THE MACHINE STATE RESTORED.
  HRRNXP==HRVO+2	;  NEXT PIECE OUTPUT OF PIECE SCANNER
  HRRNXS==HRVO+3	;  NEXT SQUARE OUTPUT OF SQUARE SCANNER
  HRRPBS==HRVO+4	;  PIECE-BUS
  HRRSBS==HRVO+5	;  SQUARE-BUS
  HRRPOU==HRVO+6	;  POUT (OUTPUT OF SQUARE-LIST MEMORY)
  HRRPLC==HRVO+7	;  (P)LOC (OUTPUT OF PIECE-LIST MEMORY)
  HRRPVL==HRVO+10	;  (P)VAL (OUTPUT OF VAL MEMORY)
  HRRPTP==HRVO+11	;  (P)TYP (OUTPUT OF TYP MEMORY)
;THE FOLLOWING PRINT OUT "SYMBOLICALLY"
  HRSFLA==HRVO+12	;  FLAGA
  HRSFLB==HRVO+13	;  FLAGB
  HRSFLC==HRVO+14	;  FLAGC
  HRSFLD==HRVO+15	;  FLAGD
;THE FOLLOWING AS PSEUDO REGISTER WHICH REFERENCE THE "NEXT" STATE
;  IE THEY RESTORE THE MACHINE,  NO-OP THE IR (CHANGING IT AS LITTLE AS
;  POSSIBLE), PULSE THE CLOCK, AND PRINT THE RESULTING REGISTER.
;  THIS DOES NOT CHANGE THE SAVED FLAG WORDS, SO HOPEFULLY MACHINE STATE IS 
;  NOT ALTERED.
  HRRNLA==HRVO+16	;  NEXT-FLAGA
  HRRNLB==HRVO+17	;  NEXT-FLAGB
  HRRNLC==HRVO+20	;  NEXT-FLAGC
  HRRNLD==HRVO+21	;  NEXT-FLAGD
;THE FOLLOWING COMBINE THE PROPERTIES OF THE ABOVE TWO GROUPS, IE
;  THEY PRINT THE INDICATED NEXT-FLAG REGISTER "SYMBOLICALLY".
  HRSNLA==HRVO+22	;  NEXT-FLAGA SYMBOLICALLY
  HRSNLB==HRVO+23	;  NEXT-FLAGB      "
  HRSNLC==HRVO+24	;  NEXT-FLAGC      "
  HRSNLD==HRVO+25	;  NEXT-FLAGD      "
;THE FOLLOWING ARE PSEUDO REGISTERS CORRESPONDING TO FLAGWORD QUARTERS.
;  THE PRINT THE CORRESPONDING QUARTER BOTH SYMBOLICALLY AND NUMERICALLY
  HRRQ0== HRVO+26	;  QUARTER 0 (THRU 17)
;THE FOLLOWING PRINT THE NEXT-QUARTER BOTH WAYS.
  HRRNQ0==HRVO+46	;  NEXT-QUARTER 0 (THRU 17)
;
  HRRSTM==HRVO+66	;  SIDE TO MOVE
  HRRSQL==HRVO+67	;  DRAW PICTURE OF STATE OF SQUARE LINES
  HRRBD== HRVO+70	;  DRAW PICTURE OF BOARD (IE IN SQUARE LIST MEM)
  HRP11F==HRVO+71	;  PDP-11 FLAGS 1 AND 0 AS A 2 BIT QUANTITY.
			;   (WORKS FOR EXAMINE AND DEPOSIT)
  HRRGM== HRVO+72	;  PRINT CURRENT GAME LINE 
			;   (300@P -> C(PAR)
  HRRSPD==HRVO+73	;  SPEED SELECT (0 - SINGLE STEP, 1 SLOW, 2 CRUISE, 3 FAST
  HRRSTC==HRVO+74	;  STATA AND STATB AS A 32 BIT REGISTER
  HRRPV== HRVO+75	;  PRINCIPLE VARIATION
HRASO==HRVO+100
 HRASE==HRVO+200	; ASOURCE S (A-BUS AND R-BUS) (R) 64 LOCN
HRODO==HRVO+200
 HRODE==HRVO+300	; ODEST S (64 LOCN)
HRREND==HRVO+300	;END OF REGISTER ADR SPACE

HUBADR:	776000	;UNIBUS ADDRESS OF UNIFACE
H11N:	3	;CHEOPS PDP11 NUMBER
TLCTL:	0	;TEMP IN TEST LOOP
		;0 RUN 1,2 SPEED
		;3 STAT STOP, 4 -, 5 MEMR ENB
		;6 INTR ENB, 7 RESET, 8 MUXSL0
		;9 MUXSL1, 10 MUXSL2, 11 MUXSL3
		;12 ERR STOP, 13 DIAR LOAD, 14 PDP-11 FLAG1
		;15 PDP-11 FLAG0
HSA:	0
HDA:	1

HINIT:	PUSHJ P,HINIM		;INITIALIZE MEM PAGES
	PUSHJ P,HINIC		;PREPARE TO FROB CHEOPS ITSELF.
	POPJ P,

HINIM:	MOVE A,[3_42+10000_12+1777]		;R/W. NO PROTECT  INSERT MEMORY PAGES
	MOVE D,H11N		; JUST THIS IS ENUF IF INTEND TO RUN SOLELY IN BUFFERED MODE
				; AND UCODE ALREADY LOADED, ETC.
	DPB D,[320300,,A]	;STORE IN PDP11 NUMBER
	MOVEI D,<CBLEN/10000>	;EA PDP-10 PAGE ADDRESS ES 10000 BYTES
	MOVEI C,HBMEM_-12
	MOVEI B,CBBAS
HINIT1:	PUSH P,B		;INSERT UNIBUS MEMORY PAGES
	PUSHJ P,HGPDP
	POP P,B
	ADDI C,1
	ADDI B,10000
	SOJG D,HINIT1
	HRRZ B,HUBADR		;INSERT I/O PAGE (FOR CHEOPS CONTROL LOCNS)
	PUSHJ P,HGPDP
	POPJ P,

HINIC:	MOVE A,[100000_4]	;INITIALIZE CHEOPS FOR FROBBING WITH, ETC
	TDNE A,UNIFA		;CHEOPS RUNNING?
	ESTOP			;TRY STOPPING IT
	LDB A,[40600,,UNIFA]	;GOBBLE DOWN STAR REG
	CAIE A,77		;JUST POWERED ON? (IT POWERS UP 77)
	POPJ P,
	ERESET			;FOO, MUST HAVE JUST BEEN POWERED ON, RESET IT
	CLEARM HTPLDF
	PUSHJ P,HINPCM		;INITIALIZE VAL AND TYP TOO
	MOVSI A,-HBMEML		;CLEAR OUT BUFFER MEM
HINILP:	CLEARM HBMEM(A)
	AOBJN A,HINILP
	POPJ P,

HGPDP:	ASH B,-2		;B IS DESIRED UNIBUS ADR
	DPB B,[T11REL,,A]
	.CALL [	SETZ
		SIXBIT /T11MP/
		C
		SETZ A ]
	.VALUE
	POPJ P,

HCMAIN:	MOVEM P,HSPDL		;SAVE BASE PDL LVL
	.CALL [	SETZ		;SAVE TTY STATUS
		SIXBIT /TTYGET/
		1000,,TYIC
		2000,,HTSST1
		2000,,HTSST2
		402000,,HTSSTS]
	.VALUE
	.CALL [	SETZ		;DO ALL OWN ECHOING
		SIXBIT /TTYSET/
		1000,,TYIC
		[030202,,020202]
		400000,,[030202,,020202] ]
	.VALUE
	.CALL [	SETZ		;GET SCREEN SIZE
		SIXBIT /CNSGET/
		1000,,TYIC
		2000,,A		;SCREEN VERTICAL SIZE
		402000,,B]	;SCREEN HORIZONAL SIZE
	.VALUE
	CLEARM HTICMF		;LEAVE COMMAND FILE MODE
	SUBI A,10.
	MOVEM A,HDLNN		;START CONSOLE DISPLAY THERE
	SUBI B,5
	MOVEM B,HCHWD
HREI1:	MOVEI A,1		;CONSOLE PROGRAM MAIN LOOP
	MOVEM A,HTTYMD		;INDICATE IN CONSOLE MONITOR MODE
	MOVE A,[100000_4]		;IF CHEOPS RUNNING, STOP IT
	TDNN A,UNIFA
	JRST HCMN2
	ESTOP
	PUSHJ P,HRDHU
	HSOUT [ASCIZ /CHEOPS WAS RUNNING NOW STOPPED!/]
HCMN2:	PUSHJ P,HENTER		;SAVE REST OF STATE AS WELL
	CLEARM HCSDPF		;NOT DISPLAYING CONSOLE
	PUSHJ P,HCSDPY		;DISPLAY CONSOLE
	PUSHJ P,HRDHU		;HOME UP (BUT STAY BELOW RAID REG)
HCMN1R:	CLEARM HRGOPF		;NO REGISTER OPEN
HCMN1:	CLEARM HDPFLG		;DEPOSIT DONE FLAG
	.CALL [	SETZ		;READ CURSOR POS
		SIXBIT /RCPOS/
		1000,,TYIC
		2000,,A
		402000,,B]
	.VALUE
	HLRZM A,HCLINE
	HRRZM A,HCPOS
	SETOM HRAIDM		;CONFINE PRINTOUT TO BETWEEN RAID AREA AND CONSOLE AREA
	SETOM HCMREQ		;INDICATE GOT HERE
	PUSHJ P,HGECOM		;RETURN WITH ASCIZ STRING IN HCBUF
				;HCNUMF ETC VALID. TERM CHAR IN A
	CAIN A,33		;ALT MODE
	JRST HCMNX		;RETURN TO REGULAR MODE
	SKIPL HCVALF
	JRST HCMN1A		;NO VALUE, SO WHAT EVER HCNUMF HAS IS IT
	MOVSI C,-4		;ADD VALUE TO NUM, 16 BIT WISE
	MOVEI B,0		;CRY IN B
HCNM1L:	ADD B,HCVAL(C)
	ADD B,HCNUM(C)
	DPB B,[002000,,HCNUM(C)]
	LSH B,-20		;CRY IF ANY
	AOBJN C,HCNM1L
	SETOM HCNUMF
HCMN1A:	CLEARM HCVALF
	MOVE B,A
	MOVE A,HCNUM		;LOW ORDER ARG IN A ON DISPATCH
	PUSHJ P,@HCMTAB(B)
	DPB A,[002000,,HCVAL]	;THIS A NO-OP UNLESS COMMAND HAS SOS ED HCVALF
	SKIPGE HTICMF
	JRST HCMN1B		;DONT UPDATE IF IN COMMAND FILE MODE
	SKIPGE HDPFLG
	PUSHJ P,HCSDPY		;UPDATE RAID REGISTER IF DEPOSIT DONE
HCMN1B:	JRST HCMN1

HREINI:	MOVE P,HSPDL		;GET HERE ON SECOND ^X IF NO RESPONCE TO FIRST
	HSOUT [ASCIZ /QUIT/]
	JRST HREI1

HCMNX:	CLEARM HTTYMD		;LEAVE CONSOLE MODE
	MOVE P,HSPDL		;RETURN TO CALLER
	.CALL [	SETZ		;RESTORE NORMAL ECHOING
		SIXBIT /TTYSET/
		1000,,TYIC
		HTSST1
		HTSST2
		SETZ HTSSTS]
	.VALUE
	POPJ P,
	
HCMCR:	PUSHJ P,HRGCLS		;CLOSE OPEN REGISTER, IF ANY
	JRST HCRR

HCMERR:	HSOUT [ASCIZ /???/]	;COMMAND ERROR
	MOVE P,HSPDL		;RESET PDL
	CLEARM HTICMF		;FLUSH ANY COMMAND FILES
	JRST HCMN1R


HFF:	PUSHJ P,HHU	;WIPE SCREEN
	PUSHJ P,HCLEOF
	PUSHJ P,HCSDPY
	PUSHJ P,HRDHU
	POPJ P,

HGECMA:	TDZA T,T	;READ COMMAND, NO ERROR ON UNDEF SYM (CALLER HANDLES)
HGECOM:	MOVEI T,1	;READ COMMAND, TYPE ERR ON UNDEF SYM
	MOVEM T,HGEUSF
	CLEARM HSMFND
	PUSHJ P,HGCOM
	SKIPGE HCSYL	;SKIP ON SYL NULL
	SKIPGE HCNUMF
	JRST HGECMX	;GOT NUMBER, OK
	MOVEI B,HGSYMT	;SEARCH SYM TABLE
HGCSML:	CAIL B,HGSYME
	JRST HGCNF	;NOT FOUND
	MOVE T,[440700,,HCBUF]
	MOVE TT,(B)
	HRLI TT,440700
HGCSM2:	ILDB ZR,T
	ILDB C,TT
	CAME ZR,C
	JRST HGCSM3	;THAT ONE LOSES
	JUMPN C,HGCSM2
	MOVE B,1(B)
	DPB B,[002000,,HCNUM]
	SETOM HCNUMF
	SETOM HSMFND
HGECMX:	POPJ P,

HGCSM3:	ADDI B,2
	JRST HGCSML

HGCNF:	SKIPE HGEUSF
	HSOUT [ASCIZ /??/]
	POPJ P,


;SYMBOL TABLE FORMAT
; WD0 POINTER TO ASCIZ STRING
; WD1 VALUE (16 BITS)

HGSYMT:	[ASCIZ /FLAGA/]
	HRRFLA
	[ASCIZ /SFLAGA/]
	HRSFLA
	[ASCIZ /NFLAGA/]
	HRRNLA
	[ASCIZ /NSFLAGA/]
	HRSNLA
	[ASCIZ /FLAGB/]
	HRRFLB
	[ASCIZ /SFLAGB/]
	HRSFLB
	[ASCIZ /NFLAGB/]
	HRRNLB
	[ASCIZ /NSFLAGB/]
	HRSNLB
	[ASCIZ /FLAGC/]
	HRRFLC
	[ASCIZ /SFLAGC/]
	HRSFLC
	[ASCIZ /NFLAGC/]
	HRRNLC
	[ASCIZ /NSFLAGC/]
	HRSNLC
	[ASCIZ /FLAGD/]
	HRRFLD
	[ASCIZ /SFLAGD/]
	HRSFLD
	[ASCIZ /NFLAGD/]
	HRRNLD
	[ASCIZ /NSFLAGD/]
	HRSNLD
	[ASCIZ /STATA/]
	HRRSTA
	[ASCIZ /STATB/]
	HRRSTB
	[ASCIZ /STATC/]
	HRRSTC
	[ASCIZ /UAR/]
	HRRUAR
	[ASCIZ /UDR/]
	HRRUDR
	[ASCIZ /OREG/]
	HRRORG
	[ASCIZ /FCELL/]
	HRRFC
	[ASCIZ /NFCELL/]
	HRRNFC
	[ASCIZ /USP/]
	HRRUSP
	[ASCIZ /SIR/]
	HRRSIR
	[ASCIZ /SR/]
	HRRSR
	[ASCIZ /PR/]
	HRRPR
	[ASCIZ /IR/]
	HRRIR
	[ASCIZ /NAF/]
	HRRNAF
	[ASCIZ /PC/]
	HRRPC
	[ASCIZ /RAIDR/]
	HRRDRO
	[ASCIZ /PAR/]
	HRRPAR
	[ASCIZ /RESET/]
	HRRSET
	[ASCIZ /NXP/]
	HRRNXP
	[ASCIZ /NXS/]
	HRRNXS

	[ASCIZ /PBUS/]
	HRRPBS
	[ASCIZ /SBUS/]
	HRRSBS
	[ASCIZ /POUT/]
	HRRPOU
	[ASCIZ /LOC/]
	HRRPLC
	[ASCIZ /VAL/]
	HRRPVL
	[ASCIZ /TYP/]
	HRRPTP
  REPEAT 20,[
	[HCONC ASCIZ /Q,\.RPCNT,/]
	HRRQ0+.RPCNT
]
  REPEAT 20,[
	[HCONC ASCIZ /NQ,\.RPCNT,/]
	HRRNQ0+.RPCNT
]
	[ASCIZ /STM/]
	HRRSTM
	[ASCIZ /SQL/]
	HRRSQL
	[ASCIZ /BD/]
	HRRBD
	[ASCIZ /STEPC/]
	HRRSC
	[ASCIZ /SA/]
	HRRSA
	[ASCIZ /STAR/]
	HRRSTR
	[ASCIZ /DBELL/]
	HRRDBL
	[ASCIZ /P11F/]
	HRP11F
	[ASCIZ /GM/]
	HRRGM
	[ASCIZ /SPD/]
	HRRSPD
	[ASCIZ /PV/]
	HRRPV
HGSYME:


HCMTAB:	HCMERR		;0
	HCMERR		;^A
	HCB		;^B  PROCEED TO BREAKPOINT
	HSPC		;^C  IGNORE
	HCMERR		;^D
	HCMERR		;^E
	HCMERR		;^F
	HCMERR		;^G (BELL)
	HBS		;^H (BS)  ??
	HCMERR		;^I (TAB)
	HLF		;^J (LF)  DDT-STYLE LINEFEED
	HCMERR		;^K
	HFF		;^L (FF)  WIPE SCREEN
	HCMCR		;^M (CR)
	HCN		;^N       STEP MACHINE.  
	HCMERR		;^O
	HCP		;^P
	HCMERR		;^Q (MUST BE QUOTED)
	HCR		;^R
	HCMERR		;^S
	HCMERR		;^T
	HCMERR		;^U
	HCMERR		;^V
	HCMERR		;^W
	HCMERR		;^X
	HCMERR		;^Y
	HCMERR		;^Z
	HCMERR		;ALT
	HCMERR		;^\
	HCMERR		;^]
	HCMERR		;^^
	HCMERR		;^_
	HPLS		;SPACE
	HCMERR		;!
	HCMERR		;"
	HCMERR		;#
	HCMERR		;$
	HTISM		;% (TYPE IN USER SYMBOL)
	HCMERR		;&
	HCMERR		;'
	HCMERR		;(
	HCMERR		;)
	HCMERR		;*
	HPLS		;+
	HCMERR		;,
	HCMERR		;-
	HCMERR		;.
	HSLSH		;/

	HCMERR		;0 (MUST FOLLOW @ TO DISPATCH)
	HCMERR		;1
	HCMERR		;2
	HCMERR		;3
	HCMERR		;4
	HCMERR		;5
	HCMERR		;6
	HCMERR		;7
	HCMERR		;8
	HCMERR		;9
	HCLN		;:
	HCMERR		;;
	HCMERR		;<
	HEQ		;=
	HCMERR		;>
	HCMERR		;?
	HCMERR		;@
	HA		;A (MUST FOLLOW @ TO DISPATCH)
	HCMERR		;B
	HC		;C
	HCMERR		;D
	HCMERR		;E
	HCMERR		;F
	HG		;G
	HCMERR		;H
	HCMERR		;I
	HCMERR		;J
	HCMERR		;K
	HL		;L
	HCMERR		;M
	HCMERR		;N
	HO		;O
	HP		;P
	HCMERR		;Q
	HR		;R
	HS		;S
	HT		;T
	HU		;U
	HV		;V
	HCMERR		;W
	HX		;X
	HCMERR		;Y
	HCMERR		;Z

	HCMERR		;[
	HCMERR		;\
	HCMERR		;]
	HUPAR		;^
	HCMERR		;_
	HCMERR		;`
	HCMERR		;{
	HCMERR		;|
	HCMERR		;}
	HCMERR		;~
HRBCOD=.-HCMTAB		;MAPPED CODE FOR RUBOUT
	HCMERR		;RUBOUT
IFN .-HCMTAB-200+32,.ERR \HCMTAB LOSES\


HA:	ADDI A,HRACO	;ADDRESS AC OR AAC
HVLRET:	SOS HCVALF
	POPJ P,

HC:	ADDI A,HRCMO	;ADDRESS CONTROL MEM
	JRST HVLRET

HP:	ADDI A,HRPDO	;ADDRESS DATA PDL MEM
	JRST HVLRET

HU:	ADDI A,HRUSO	;ADDRESS U-STACK (SPC)
	JRST HVLRET

HS:	ADDI A,HRSQO	;ADDRESS SQUARE LIST
	JRST HVLRET

HL:	ADDI A,HRPLO	;ADDRESS PIECE-LIST MEM
	JRST HVLRET

HV:	ADDI A,HRPVO	;ADDRESS PIECE-VAL MEM
	JRST HVLRET

HT:	ADDI A,HRPTO	;ADDRESS PIECE-TYPE MEM
	JRST HVLRET

HX:	ADDI A,HRPXMO	;ADDRESS PIECE-EXISTS MEM
	JRST HVLRET

HR:	ADDI A,HRASO	;ADDRESS A-SOURCE
	JRST HVLRET

HO:	ADDI A,HRODO	;ADDRESS O-DEST
	JRST HVLRET

HPCNSP:	MOVE A,HCHPT
	PUSHJ P,HPAD
	HSOUT [ASCIZ ?/   ?]
	MOVE A,HCHPT
	POPJ P,

HRGPNT:	PUSH P,A	;PRINT XXX/<CURRENT VAL> WHERE XXX IS REG ADR
	PUSHJ P,HPAD
	HSOUT [ASCIZ ?/   ?]
	POP P,A
	PUSH P,HRGOPF	;DONT AFFECT HRGOPF
	MOVEI B,HEXAMV
	SETOM HEXPF
	PUSHJ P,HREGDE
	SKIPE HCPOS
	HSOUT [ASCIZ /  /]	;DONT PRINT SPACE AT BEG OF LINE
	POP P,HRGOPF
	POPJ P,

HUPAR:	PUSHJ P,HRGCLS	;UP ARROW
	SOS HCHPT	;REGISTER CLOSED BEFORE MODIFING PT
	JRST HLF2

HLF:	PUSHJ P,HRGCLS	;CLOSE REGISTER BEFORE MODIFYING PT
	AOS HCHPT	;LF EXAMINE NEXT REGISTE
HLF2:	SKIPE HCPOS	;CR UNLESS AT BEG OF LINE
	PUSHJ P,HCRR
HLF1:	PUSHJ P,HPCNSP
	SOS HCNUMF	;SIGNAL VALID ARG IN A
HSLSH:	PUSHJ P,HPCSET	;SET UP POINT
	MOVEI B,HEXAMV	;EXAMINE VECTOR
	SETOM HEXPF	;WANT TO PRINT IT OUT
	PUSHJ P,HREGDE
	MOVE ZR,HRGDEF	;BASE OF LAST MEM EXAMINED
	MOVEM ZR,HBLMEX
	POPJ P,


HPCSET:	SKIPL HCNUMF
	JRST HSLSH3	;NO ARG
	CAIL A,HRORG
	JRST HSLSH1	;REGISTER ADDR OK
	ADD A,HBLMEX	;TRY EXAMINING WITHIN LAST MEM
	CAIL A,HRORG	;SKIP ON STILL LOSING
HSLSH1:	MOVEM A,HCHPT
	POPJ P,

HSLSH3:	MOVE A,HCHPT
	POPJ P,

HRGCLS:	SKIPE HRGOPF	;CLOSE OPEN REGISTER
	SKIPL HCNUMF
	POPJ P,
	MOVE A,HCHPT
	MOVEI B,HDPV
	PUSHJ P,HREGDD
	POPJ P,

HBS:	PUSHJ P,HPCSET   ;??
	SKIPN HCNUMF
	PUSHJ P,HPCNSP
	MOVE A,HCHPT
	MOVEI B,HTIV
	PUSHJ P,HREGDE
	JRST HCRR

HCR:	CLEARM HTPLDF	;SIGNAL TYPE AND VAL MEMS NOT LOADED
	PUSHJ P,HRESSV	;RESET
	ERESET
	POPJ P,

HCB:	SKIPL HCNUMF	;PROCEED TO BREAKPOINT
	AOS HCNUM	;DEFAULT ARG OF 1
	MOVE A,HCNUM+1
	LSH A,16.
	IOR A,HCNUM
	MOVEM A,HCSTP1
	MOVE ZR,HSTFLG
	CAIE ZR,1
	JRST [	PUSHJ P,HZST	;ZERO STAT BITS, REMEMBER WHERE THEY WERE
	      	JRST HCB2]
	SKIPLE HBPTIN
	JRST HCB1	;BPTS IN, OK
HCB2:	MOVEI C,1
	MOVEM C,HBPTIN
	PUSHJ P,HCB4
	JRST HCB1

HBOUT:	MOVEI C,1	;MAKE SURE BPTS OUT
	CAMN C,HSTFLG
	CAME C,HBPTIN
	POPJ P,		;THEY RE NOT IN
	CLEARB C,HBPTIN	;TAKE OUT BPTS
HCB4:	HRLZ T,HBBPTP	;STORE LOW BIT OF C IN STAT BIT OF LOCNS IN BPT TBL
	JUMPGE T,HCB1
HCB3:	MOVEI A,HELNTM
	MOVE B,HBBPT(T)
	JUMPL B,HCB5	;XFER ON THIS ENTRY FLUSHED
	ERCMEM
	DPB C,[%H1ST HELNTM+1]
	EWCMEM
HCB5:	AOBJN T,HCB3
	MOVEI B,0		;THE FOLLOWING IS A TOTAL KLUDGE TO GRONK INSTRUCTIONS
	MOVEI A,HELNTM		; THAT WRITE INTO STATA OR STATB (THUS LOUSING UP THE WORKS).
	MOVEI T,0		; IT EVEN ATTEMPTS TO UNGRONK THEM SOMETIMES!
	JUMPE C,HUCLBS	;UNCLOBBER STAT U INSTS.
HCLBS1:	ERCMEM
	LDB ZR,[%H1AMOP HELNTM+1]
	JUMPN ZR,HCLBS2	;SPARE THAT ONE, ITS AN ARRAY OP
	LDB ZR,[%H2LIT HELNTM+2]
	CAIN ZR,H2LPDS
	JRST HCLBS2	;PDL DEST IS OK TOO
	LDB ZR,[%H2LOD HELNTM+2]
	CAIE ZR,HODSTA
	CAIN ZR,HODSTB
	JRST .+2
	JRST HCLBS2
	MOVEM B,SCLB(T)	;FOUND ONE, SMASH IT
	HRLM ZR,SCLB(T)
	AOS T
	MOVEI ZR,0
	DPB ZR,[%H2LOD HELNTM+2]
	EWCMEM
HCLBS2:	CAIGE B,CHECML-1
	AOJA B,HCLBS1
	CLEARM SCLB(T)
	POPJ P,

HUCLBS:	SKIPN SCLB(T)
	POPJ P,
	HRRZ B,SCLB(T)
	JUMPE B,CPOPJ
	ERCMEM
	HLRZ ZR,SCLB(T)
	DPB ZR,[%H2LOD HELNTM+2]
	EWCMEM
	AOJA T,HUCLBS

SCLB:	BLOCK 40

HCN:	SKIPL HCNUMF
	AOS HCNUM	;DEFAULT ARG OF 1
	MOVE A,HCNUM+1
	LSH A,16.
	IOR A,HCNUM
	MOVEM A,HCSTP1
	CAIGE A,400000	;MAX REASONABLE TO TRY STEPPING WITH 10
	SKIPE HSTEPM	;SKIP ON STEP WITH 10
	JRST HCNSTA	;STEP WITH STATISTICS COUNTER
	PUSHJ P,HRESSV	;RESTORE STATE, SAVE, AND COME BACK
HCN1:	SOSGE HCSTP1
	JRST HCN1X
HCN1A:	AOS HSTEPS
	ECLK
	SKIPGE HCMREQ		;SKIP ON GUY WANTS TO QUIT OUT
	JRST HCN1
HCN1X:	POPJ P,

HCNSTA:	SKIPL HSTFLG		;MAKE SURE STAT BITS SET
	JRST [	PUSH P,HCNUM
		MOVEI A,1
		MOVEM A,HCNUM
		PUSHJ P,HSTAT1
		POP P,HCNUM
		JRST .+1]
HCB1:	AOS A,HCSTP1		;(+1 BECAUSE HARDWARE STOPS ON -1) 32 BIT # OF STEPS
	MOVNM A,HCSTPT
	MOVEI A,HCSTPT		;LOAD MINUS NUMBER STEPS IN STATA, STATB
	MOVEI B,HODSTA
	EWOD
	MOVN A,HCSTP1
	LSH A,-16.
	MOVEM A,HCSTPT
	MOVEI A,HCSTPT
	MOVEI B,HODSTB
	EWOD
	PUSHJ P,HCSTA1
	SOS A,HCSTP1		;COMPENSATE FOR AOS ABOVE
	ADDM A,HSTEPS
	POPJ P,

HCSTA1:	PUSHJ P,HRESSV
	ESRUNS			;SET RUN AND ENABLE STAT STOP
	MOVE A,[100000_4]	;RUN SIGNAL
	TDNE A,UNIFA
HCHWA1:	.HANG
	JRST HCPX
	
HCSTPT:	0
HCSTP1:	0

HCP:	CLEARM HSTEPS
	PUSHJ P,HRESSV	;PROCEED!
	ECLK			;CLOCK ONCE TO ELIMINATE POSSIBLE IR PARITY ERR
	ESRUN			;SET RUN
	SKIPL HCMREQ
	JRST HCPX
	MOVE A,[100000_4]	;WAIT FOR RUN TO GO AWAY
	TDNE A,UNIFA
HCHWAT:	.HANG
HCPX:	MOVE A,UNIFA
	TDNE A,[10000_<16.+4.>]	;SKIP ON PARITY STOP NOT ENABLED
	TDNN A,[20000_4]	;SKIP ON PARITY ERROR
	JRST HCPX1
	HSOUT [ASCIZ /PARITY STOP/]
HCPX1:	ESTOP
	POPJ P,

HRESSV:	PUSHJ P,HLEAVE		;LEAVE - CALL BACK -ENTER -RETURN
	PUSHJ P,@(P)
	PUSHJ P,HENTER
	SOS HDPFLG		;REMEMBER TO UPDATE DISPLAY AT COMMAND LOOP
	SUB P,[1,,1]
	POPJ P,


;HRESNV IS SIMILAR TO HRESSV EXCEPT THE GENERAL IDEA IS TO GET THE
; MACHINE INTO A STATE WHERE IT CAN BE CLOCKED WITHOUT DESTROYING ITS STATE.
; IT THEN CALLS BACK CALLER, WHO CAN HACK.  ON RETURN, REAL STATE OF MACHINE
; IS RESTORED (INSTEAD OF READING IT BACK FROM HARDWARE).

HRESNV:	MOVE A,[HSVIR,,HNVTIR]	;SAVE REAL IR
	BLT A,HNVTIR+5	
	MOVE A,HSVIR+1		;NOW NO-OP IR
	TRNE A,H1AMOP
	JRST HRESN1		;ARRAY INST, CLEAR WRITE PULSES
	LDB C,[%H2LIT HSVIR+2]	;GET ASDEST TYPE FIELD
	CAIN C,3
	JRST HRVCPD		;PDL DEST, CHANGE TO NON-IMMED
	MOVE B,[.BM %H2LOD]	;OTHERWISE, CLEAR ODEST
	ANDCAM B,HSVIR+2
HRESN2:	MOVE B,[H1STAT+H1PSHJ+H1POPJ+<.BM %H1PAF>+<.BM %H1UB>+<.BM %H1FC>]
	ANDCAM B,HSVIR+1	;CLEAR WD1 BITS THAT MIGHT DO SOMETHING BAD
	PUSH P,HPSVAL		;REMEMBER HOW MUCH OF MACHINE STATE REALLY SAVED
	PUSH P,HFSVAL
	PUSH P,HPARSF
	PUSH P,HUSPSF
 NHPSH==4			;NUMBER OF PUSH ES DONE HERE
	PUSHJ P,HLEAVE		;RESTORE MACHINE STATE
	PUSHJ P,@-NHPSH(P)	;RETURN TO CALLER
	POP P,HUSPSF
	POP P,HPARSF
	POP P,HFSVAL
	POP P,HPSVAL
	MOVE A,[HNVTIR,,HSVIR]
	BLT A,HSVIR+5		;PUT BACK IR
	SUB P,[1,,1]		;FLUSH RETURN TO CALL BACK GUY
	POPJ P,

HRVCPD:	LDB A,[%H2ASL HSVIR+2]	;CHANGE PDL-DEST TO NON-IMMED
	CLEARM HSVIR+2
	DPB A,[%H2ASH HSVIR+2]	;MOVE TO HIGH A-SRC FIELD
	JRST HRESN2

HRESN1:	MOVE B,[H2AWPX+H2AWSR+H2AWSIR+H2AWPR+H2AWMV+H2AWDT]
	ANDCAM B,HSVIR+2	;CLEAR WRITE PULSES
	ANDCAM B,HSVIR+4
	JRST HRESN2
	
HSPC:
HPLS:	SKIPL HCNUMF
	POPJ P,			;NULL ARG, RETURN NULL
	MOVE A,[HCNUM,,HCVAL]	;PLUS, SPACE JUST RETURN ARG AS VALUE
	BLT A,HCVAL+4-1
	MOVE A,HCNUM
	SOS HCVALF
	POPJ P,

HEQ:	SKIPN HCNUMF
	JRST HEQ1		;TYPE OUT LAST REG INSTEAD
	MOVE B,A
	MOVEI C,6
	EOCTP
HEQ2:	JRST HCRR

HEQ1:	CLEARM HEXPF		;FETCH POINT AND PRINT NUMERIC
	MOVE A,HCHPT
	MOVEI B,HEXAMV
	PUSHJ P,HREGDE
	IPNFLD
	JRST HEQ2


;CHECK IR BITS
HTEST:	X HRESET			;TEST SEQUENCE
	SETZM HSA
HLUP:	MOVE A,HSA
	AOJ A,
	MOVEM A,HDA
	DPB A,[10400,,TLCTL]	;DESTINATION
	MOVE A,HSA
	DPB A,[100400,,TLCTL]	;MUX
	MOVE A,TLCTL
	X HS1
	MOVEI A,0
	X HS2
	LDB B,[HMUX]
	CAME A,B
	.VALUE
	MOVEI A,177777
	X HS2
	LDB B,[HMUX]
	MOVE C,HSA
	CAIN C,4		;IRA 42-47
	ANDI A,176000
	CAME A,B
	.VALUE
	AOS A,HSA
	CAIE A,6
	JRST HLUP

;CHECK CMEM BITS
	X HRESET
	SETZM HDATA
HLUP1B:	SETZM HSA
HLUP1:	MOVE B,HSA		;CMEM ADDRESS
	MOVEI A,1		; IR 0-16
	X HDEP
	MOVEI B,0
HLUP1A:	AOJ A,
	X HDEP
	CAIE A,6
	JRST HLUP1A
	MOVEI A,10
HLUP2:	MOVE B,HDATA
	X HDEP
	CAIE A,13
	AOJA A,HLUP2
	X HSS
	X HEXIR
	MOVEI C,0
HLUP3:	MOVE A,HDATA
	ANDI A,177777
	CAIN C,4
	ANDI A,176000
	MOVE B,HIRA(C)
	CAME A,B
	.VALUE
	CAIE C,5
	AOJA C,HLUP3
	X HSS
	X EXMPAR
	TRNE B,2000
	.VALUE
	AOS B,HSA
	CAIE B,2000
	JRST HLUP1
	SETCMB A,HDATA
	JUMPN A,HLUP1B

;TEST A MEMORY
	X HRESET
	SETZM HDATA
HLUP5A:	SETZM HSA		;MEMORY LOCN
HLUP5:	MOVE A,HSA
	DPB A,[020400,,HCWAC+2]	;ODEST=AC
	DPB A,[000400,,HCRAC+3]	;BBUS=AC
	TRO A,20
	DPB A,[120600,,HCRAC+2]	;ASOURCE ALSO=AC
	DPB A,[120600,,HCRACA+2]	; READ ABUS SIDE OF AC
	MOVEI A,HCWAC		;WRITE AC OP
	X HDEPI
	MOVE A,HDATA
	X HS2
	X HSS			;SINGLE STEP - WRITE AC
	MOVEI A,HCRAC
	X HDEPI
	X EXMO
	MOVE A,HDATA
	ANDI A,177777
	CAME A,B
	.VALUE
	MOVE A,HSA
	TRNE A,20		;STILL IN AC'S (NOT AAC'S)
	JRST HLUP5C
	MOVEI A,HCRACA		;READ AC, THRU ABUS
	X HDEPI
	X EXMO
	MOVE A,HDATA
	ANDI A,177777
	CAME A,B
	.VALUE
HLUP5C:	X HSS
	X EXMPAR
	AOS A,HSA
	TRNN A,20		;UP INTO AAC YET?
	TRZ B,3			;IGNORE AAC ERRS UNTIL THEN
	TRNE B,77		; RBBUS, LBBUS, RAC, LAC, RAAC, LAAC
	.VALUE
	CAIE A,20
	JRST HLUP5
	SETCMB A,HDATA
	JUMPN A,HLUP5A

;TEST PDL CONTENTS
HLUP6:	X HRESET
	SETZM HDATA
HLUP6B:	SETZM HSA		;MEMORY LOCN
HLUP6A:	MOVEI A,[0 ? 0 ? 77_2 ? 3_10. ? 0 ? 0]	;WRITE PAR
	X HDEPI
	MOVE A,HSA
	X HS2			; PDL POINTER
	X HSS
	MOVEI A,[0 ? 0 ? 20_2 ? 3_10. ? 0 ? 0]	;WRITE PDL
	X HDEPI
	MOVE A,HDATA
	X HS2
	X HSS			;SINGLE STEP
	MOVEI A,[0?0? 0? 32_4? 0?0]		;READ PDL(PAR)
	X HDEPI
	X EXMO
	MOVE A,HDATA
	ANDI A,177777
	CAME A,B
	.VALUE
	X HSS
	X EXMPAR
	TRNE B,1400
	.VALUE
	AOS A,HSA
	CAIE A,2000
	JRST HLUP6A
	SETCMB A,HDATA
	JUMPN A,HLUP6B

;TEST SPC CONTENTS
HLUP7:	X HRESET
	SETZM HDATA
HLUP7A:	SETZM HSA
HLUP7B:	MOVEI A,[0?0? 22_2? 3_10.? 0?0]	;WRITE SPCPTR
	X HDEPI
	MOVE A,HSA
	X HS2
	X HSS
	MOVEI A,[0?0? 21_2? 3_10.? 0?0]	;WRITE SPC(SPCPTR)
	X HDEPI
	MOVE A,HDATA
	X HS2
	X HSS
	MOVEI A,[0?0? 0? 5_10.? 0?0]	;READ SPC=>OBUS
	X HDEPI
	X EXMO
	MOVE A,HDATA
	ANDI A,3777
	CAME A,B
	.VALUE	
	MOVEI A,[0?1_12.? 0?0? 0?0]	;POPJ
	X HDEPI
	X HSS
	MOVEI A,6_8			;LOOK AT PC
	X HS1
	MOVE A,HDATA
	ANDI A,3777
	LDB B,[HMUX]
	ANDI B,3777
	CAME A,B
	.VALUE
	MOVEI A,[0?0? 0?4_10.? 0?0]	;READ SPCPTR
	X HDEPI
	X EXMO
	MOVE A,HSA
	SOJ A,
	ANDI A,377
	CAME A,B
	.VALUE
	X EXMPAR
	TRNE B,4000
	.VALUE
	AOS A,HSA
	CAIE A,400
	JRST HLUP7B
	SETCMB A,HDATA
	JUMPN A,HLUP7A
	
;TEST RANDOM REGISTERS
HLUP9:	X HRESET
	SETZM HDATA
HLUP9A:	SETZM HSA
HLUP9B:	MOVE A,HSA
	ADDI A,14
	MOVE B,HDATA
	X HDEP
	MOVE A,HSA
	ADDI A,10
	DPB A,[120600,,HASRC+2]	;READ BACK THRU ABUS
	MOVEI A,HASRC
	X HDEPI
	X EXMO
	MOVE A,HDATA
	MOVE D,HSA
	AND A,HFLGBT(D)
	AND B,HFLGBT(D)
	CAME A,B
	.VALUE
	AOS A,HSA
	CAIGE A,4
	JRST HLUP9B
	SETCMB A,HDATA
	JUMPN A,HLUP9A
	
;NOW RUN THROUGH SOME RANDOM REGISTERS
HLUP10:	X HRESET
	SETZM HDATA
	;STATA, STATB, UAR, FLAG-CELL, NXFLAG-CELL
HLP10A:
  IRP ODEST,,[4,5,3,23,24]ASOURC,,[14,15,16,4,5]TAG,,[STATA,STATB,UAR,FLGCEL,NXFLGC]
TAG:	HLOAD 7,HDATA
	HXCT [0?0? 17_10.+ODEST_2 ? 32_4]	;UDR => ODEST
	HXCT [0?0? ASOURC_10.+2_2 ? 32_4]	;ASOURC => UDR
	HSTORE 17,A				;UDR => OBUS
	CAME A,HDATA
	.VALUE
  TERMIN
      ;PR
HPR:	HLOAD 7,HDATA
	HXCT [1?0?	17_10.+17_2?	32_4]		;UDR => PR,,SR
	HLOADIR [0?H1AMOP?	0?		2_10.+1_6+1_2]	; PR=>PBUS=>PSBUS.L
	HSTORE 11,A
	LDB A,[101000,,A]
	MOVE B,HDATA
	ANDI B,377
	CAME A,B
	.VALUE
      ;SR
HSR:	HLOAD 7,HDATA
	HXCT [1?0?	17_10.+17_2?	32_4]		;UDR => PR,,SR
	HLOADIR [0?H1AMOP?	0?		2_10.+1_6+1_2]	; SR=>SBUS=>PSBUS.R
	HSTORE 11,A
	LDB A,[1000,,A]
	MOVE B,HDATA
	ANDI B,377
	CAME A,B
	.VALUE

HPLIST:	SETZM HSA
HPLST1:	MOVE A,HDATA
	MOVE B,HSA
	DPB B,[101000,,A]	; ADR,,DATA => PR,,SR
	HLOAD 7,A
	HXCT [1?0?	17_10.+17_2?	32_4]		;UDR=>PR,,SR
HLOC:	HXCT [2?H1AMOP?	40?		5_10.+1_6+1_2]	;WMOVE, LOC,,POUT =>PSBUS
	HLOADIR [0?H1AMOP?	0?		5_10.+1_6+1_2]	; POUT,,LOC =>PSBUS
	HSTORE 11,A
	LDB A,[1000,,A]
	LDB D,[1000,,HDATA]
	CAME A,D
	.VALUE
HVAL:	HLOAD 7,HDATA
	HXCT [1?0?	17_10.+14_2?	32_4]		;UDR =>VAL(ADR)
	HLOADIR [0?H1AMOP?	0?		3_10.+1_6+1_2]	; VAL =>PSBUS
	HSTORE 11,A
	CAME A,D
	.VALUE
HTYP:	HXCT [1?0?	17_10.+13_2?	32_4]		;UDR => TYP(ADR)
	HLOADIR [0?H1AMOP?	0?		4_10.+1_6+1_2]	; TYP => PSBUS
	HSTORE 11,A
	CAME A,D
	.VALUE
HPOUT:	MOVE A,HSA
	DPB D,[101000,,A]
	HLOAD 7,A
	HXCT [1?0?	17_10.+17_2?	32_4]		;DATA,,ADR => PR,,SR
	HXCT [2?H1AMOP?	40?		5_10.+1_6+1_2]	;WMOVE
	HLOADIR [0?H1AMOP?	0?		5_10.+1_6+1_2]
	HSTORE 11,A
	LDB A,[101000,,A]
	CAME A,D
	.VALUE
	AOS A,HSA
	CAIGE A,256.
	JRST HPLST1

	MOVEI A,177777
	XORB A,HDATA
	JUMPN A,HLP10A

	.VALUE
;SETUP LOOP IN CMEM
HLUPR:	X HRESET
	MOVEI D,HPROG
	X HLODC
	MOVEI A,5		;SET RUN
	DPB A,[T11LH,,UNIFA]	;START
	.VALUE
	POPJ P,

XSRUNS:	MOVE A,HCHSPD		;SET RUN, ENABLE STAT STOP
	TROA A,4
XSRUN:	MOVE A,HCHSPD		;SET RUN
	ANDI A,7
	LSH A,1
	TRO A,10141		;SET PARITY STOP, NPRENB AND INTENB
	MOVEI B,10377		;FIELD IN CONTROL WD WANT TO AFFECT (CLR RESET)
XSUCW:	MOVE ZR,UNIFA		;READ IN CURRENT CONTROL WD
	LSH A,16.+4.
	LSH B,16.+4.
	ANDCAM B,ZR		;SET CHEOPS CONTROL WORD
	IORM A,ZR
	TRO ZR,1_2		;WRITE LEFT HALF ONLY
	MOVEM ZR,UNIFA
	LSHC A,-16.-4.		;PUT BACK A AND B
	POPJ P,

;LOAD PROGRAM POINTED TO BY (D)
HLODC:	PUSH P,A
	PUSH P,B
	HLRZ A,(D)
	HRRM A,HCGO
HLOD1:	SKIPN A,(D)
	JRST HLODG
	HLRZ B,A
	X HDEPC
	AOJA D,HLOD1
HLODG:	MOVEI A,HCGO
	X HDEPI
POPBJ:	POP P,B
	POP P,A
	POPJ P,

HCGO:	0? 0? 0? 0? 0? 0

HASRC:	0 ? 0
	0 ? 32_4	;ALU = ABUS
	0 ? 0

HFLGBT:	41020 ? 177777 ? 177777 ? 170000	;LOADABLE BITS

HCWAC:	0 ? 0
	60_2		;ODEST=AC
	3_10.		;OBUS=DBR
	0 ? 0

HCRAC:	0 ? 0
	0 ? 0		;BBUS>ALU>OBUS
	0 ? 0

HCRACA:	0 ? 0
	20_10. ? 32_4	; AC=>ABUS=>ALU=>OBUS
	0 ? 0

HPROG:	100,,[	100?0? 20_10.+60_2? 1_9]	;AC0+1 => AC0
	101,,[	102?0? 64_2? 34_4]	;SETO=>AC4
	102,,[	103?0? 65_2? 34_4]	;SETO => AC5
	103,,[	101?0? 25_10.? 32_4]	; AC(5) => OBUS
	0

HDATA:	0

HIRA:	0
HIRB:	0
HIRC:	0
HIRD:	0
HIRAC:	0
HIRAD:	0

;RANDOM ROUTINES
HBLATT:	MOVEI A,HPROG
	HLRZ B,(A)		;ADDRESS
	LSH B,20.
	TRO B,1
HBLTT3:	SKIPN C,(A)
	JRST HBLTT1
	HRLI C,-4
	MOVEI TT,1
	DPB TT,[HLODSL]
	MOVEM B,UNIFA+1		;SET ADDRESS
	MOVEI T,10
HBLTT2:	DPB T,[HLODSL]
	MOVE TT,(C)
	LSH TT,20.
	TRO TT,1_2
	MOVEM TT,UNIFA+1
	AOJ T,
	AOBJN C,HBLTT2
	ADD B,[1_20.]
	AOJA A,HBLTT3
HBLTT1:	POPJ P,

HQ:	X HSS
HEXIR:	MOVEI A,0
HEXIR0:	DPB A,[HMUXSL]
	LDB B,[HMUX]
	MOVEM B,HIRA(A)
	CAIE A,5
	AOJA A,HEXIR0
	POPJ P,

HDEPIF:	PUSH P,A	;DEPOSIT ALL 6 WDS FROM BLOCK(A) INTO IR
	MOVEI A,4(A)
	PUSHJ P,HDEPI4	;DO WDS 4 AND 5 FIRST SO HARDWARE IR PARITY FROB WINS
	JRST HDEPI3
	

;DEPOSIT INTO IR (FROM C(A))
HDEPI:	PUSH P,A
	MOVE TT,1(A)
	MOVEI A,2(A)
	TRNE TT,H1AMOP
	PUSHJ P,HDEPI4		;IF ARRAY OP, PUT IR C AND D INTO IRA C AND D
HDEPI3:	MOVE A,[100000_4]	;WAIT FOR RUN TO GO AWAY
	TDNE A,UNIFA
	XCT R.VL		;MACHINE HAD BETTER NOT BE RUNNING
	MOVE A,(P)
	MOVEI T,1	;IR
	HRLI A,-4
HDEPI1:	DPB T,[HLODSL]
	MOVE TT,(A)
	DPB TT,[T11LH,,UNIFA+1]
	AOJ T,
	AOBJN A,HDEPI1
	JRST HDEPC3

HDEPI4:	MOVE T,[100000_4]	;WAIT FOR RUN TO GO AWAY
	TDNE T,UNIFA
	XCT R.VL			;MACHINE HAD BETTER NOT BE RUNNING
	HRLI A,-2		;LOAD IRA C AND D FROM (A), 1(A)
	MOVEI T,5
HDEPI2:	DPB T,[HLODSL]
	MOVE TT,(A)
	DPB TT,[T11LH,,UNIFA+1]
	AOJ T,
	AOBJN A,HDEPI2
	POPJ P,



;DEPOSIT INTO CMEM (FROM C(A)) AT LOC (B)
HDEPC:	PUSH P,A
	MOVEI T,10	;CMEM
	HRLI A,-4
HDEPC2:	MOVEI TT,1	;IRA
	DPB TT,[HLODSL]	;SET NADR
	DPB B,[T11LH,,UNIFA+1]
	MOVEI TT,2	;IRB  ASSURE POPJ BIT IS CLEAR!!!
	DPB TT,[HLODSL]
	MOVEI ZR,0
	DPB ZR,[T11LH,,UNIFA+1]
HDEPC1:	DPB T,[HLODSL]	;STORE
	MOVE TT,(A)
	DPB TT,[T11LH,,UNIFA+1]
	AOJ T,
	AOBJN A,HDEPC1
	HSTORE 0,TT
	ANDI TT,3777
	CAME TT,B
	.VALUE
HDEPC3:	MOVEI TT,0
	DPB TT,[HLODSL]	;CLEAR LOADSL
	POP P,A
	POPJ P,

;STORE C(B) INTO LOADSL(A)
HDEP:	MOVE T,[100000_4]	;WAIT FOR RUN TO GO AWAY
	TDNE T,UNIFA
	XCT R.VL			;MACHINE HAD BETTER NOT BE RUNNING
	MOVEI T,0
	DPB A,[010400,,T]
	MOVEI TT,1_2
	DPB T,[T11LH,,TT]
	MOVEM TT,UNIFA
	DPB B,[T11LH,,TT]
	MOVEM TT,UNIFA+1
	POPJ P,

XRESET:
HRESET:	MOVEI A,200
	X HS1
	MOVEI A,0
	X HS1			;RESET
	POPJ P,

XSTOP:	CLEARM HRUN		;STOP CHEOPS
	MOVEI A,0
	MOVEI B,201		;MAKE SURE RESET OFF TOO
	ESUCW			;FIRST TURN OFF RUN
	MOVEI A,0
	MOVEI B,237
	ESUCW			;THEN CLEAR OUT THE REST (FOR RANDOMNESS)
	POPJ P,


;SINGLE STEP
HSS:	MOVE ZR,[100000_4]	;WAIT FOR RUN TO GO AWAY
	TDNE ZR,UNIFA
	XCT R.VL		;MACHINE HAD BETTER NOT BE RUNNING
	MOVEI ZR,1
	DPB ZR,[T11LH,,UNIFA]
	SETZ UNIFA
	POPJ P,

XCLK:	PUSH P,A		;SINGLE STEP CLOCK
	PUSH P,B
	MOVE A,[100000_4]	;WAIT FOR RUN TO GO AWAY
	TDNE A,UNIFA
	XCT R.VL		;MACHINE HAD BETTER NOT BE RUNNING
	MOVEI A,141
	MOVEI B,377
	ESUCW
	MOVEI A,0
	MOVEI B,237
	ESUCW
	POP P,B
	POP P,A
	POPJ P,

EXMPAR:	MOVEI A,14_8		; SELECT PARITY BITS
	X HS1
	LDB B,[HMUX]
	POPJ P,

EXMO:	MOVEI A,11_8		;MUX SEL=OBUS
	X HS1
	LDB B,[HMUX]
	POPJ P,

HS1:	MOVEI B,1_2		;SET UNIFARCE CTL REG
	DPB A,[T11LH,,B]
	MOVEM B,UNIFA
	POPJ P,


HS2:	MOVEI B,1_2		; SET DBR
	DPB A,[T11LH,,B]
	MOVEM B,UNIFA+1
	POPJ P,

;	CAIN A,HXCT_<-33>
;	JRST HUUXCT
;	CAIN A,HLOAD_<-33>
;	JRST HUULOD
;	CAIN A,HSTORE_<-33>
;	JRST HUUSTO
;	CAIN A,HLOADIR_<-33>
;	JRST HUUIR
;	CAIN A,HSOUT_<-33>
;	JRST HUUSOU
;UUO HANDLER MUST XFER TO APPROPRIATE UUO ROUTINE WITH RUNTIME ACS 
; SAVED IN BLOCK AT HUUOAC

HUUINT:	0			;PROCESS TTY INTERRUPT
	MOVEI A,TYIC
	.ITYIC A,
	JRST HUUINX
	SKIPN HTTYMD
	JRST HUUINX		;NOT IN CONSOLE MODE
	CAIE A,^X
	JRST HUUINX
	MOVE A,42
	HRRZ A,1(A)
	CAIE A,HCHWA1
	CAIN A,HCHWAT
	 JRST [	MOVE A,42	;IF WAITING ON CHEOPS, QUIT OUT
		AOS 1(A)
		JRST .+1]
	AOSG HCMREQ		;TRY TO REACH COMMAND LVL
	JRST HUUINX
	MOVE A,42		;QUIT OUT
	HRLI A,HREINI
	HLRM A,1(A)		
HUUINX:	JRST @HUUINT

HUUSOU:	HRRZ C,40
	HRLI C,440700
HUUSO1:	ILDB A,C
	JUMPE A,HUUXIT
	PUSHJ P,HTYO
	JRST HUUSO1

HUUSTO:	LDB A,[270400,,40]
	DPB A,[HMUXSL]
	LDB A,[HMUX]
	HRRZ B,40
	CAIGE B,20
	ADDI B,HUUOAC
	MOVEM A,(B)
	JRST HUUXIT

HUULOD:	LDB A,[270400,,40]
	DPB A,[HLODSL]		;PUT STUFF IN LOAD SELECT FIELD
	HRRZ B,40
	CAIGE B,20
	ADDI B,HUUOAC
	HRRZ A,(B)
	DPB A,[T11LH,,UNIFA+1]	;PUT DATA IN DBR
	MOVEI A,0
	DPB A,[HLODSL]		;CLEAR OUT LOAD SELECT
	JRST HUUXIT

HUUIR:	HRRZ A,40
	X HDEPI
	JRST HUUXIT

HUUXCT:	HRRZ A,40
	X HDEPI
	X HSS
HUUXIT:	POPJ P,



;"REGISTER ADDRESS" ORIENTED ADDRESS TEST
HADRT:	CLEARM HADRRC		;ROTATE COUNT
HADRL1:	MOVEI T,HADRB
	MOVEI B,HDPV
	PUSHJ P,HADRSC		;MAKE SCAN WRITING
	JFCL
	MOVEI T,HADRC
	MOVEI B,HEXAMV
	CLEARM HEXPF		;DONT PRINT ANYTHING
	PUSHJ P,HADRSC		;MAKE SCAN READING
	PUSHJ P,HADTST
	AOS A,HADRRC
	CAIGE A,64.
	JRST HADRL1
HADCPJ:	POPJ P,

HADTST:	LSH B,-9		;# OF BITS IN THAT MEM
	MOVEI C,HADRB
HADTS1:	JUMPLE B,HADCPJ
	MOVE D,(C)
	XOR D,(A)
	CAIGE B,16.
	AND D,HADMSK(B)
	TRNE D,177777
	.VALUE			;LOST
	SUBI B,16.
	AOS C
	AOJA A,HADTS1

HADRSC:	MOVEI C,HRGHTB		;TABLE OF "HOLES" IN REGISTER ADR SPACE
	MOVEM B,HADRV		;MAKE SCAN THRU REGISTER ADDRESS SPACE
	MOVEM T,HADRBP
	MOVEI A,HRORG
HADRT3:	MOVEM C,HADRHP
HADRT2:	MOVE C,HADRHP		;GOT TO NEXT HOLE YET?
	CAML A,(C)
	 AOJA C,[	MOVE A,(C)	;PLACE TO PICK UP
			AOJA C,HADRT3]
	CAIL A,HRREND
	 JRST [	AOS (P)
		POPJ P,]		;THRU WITH PASS
	MOVE T,HADRBP		;DEPOSIT IN THAT REG
	MOVE B,HADRV		;VECTOR
	HRR C,A			;GENERATE N BITS OF .
	HRL C,A
	MOVE D,C
	ROTC C,@HADRRC
	DPB D,[2000,,HADRB]
	LSHC C,-20
	DPB D,[2000,,HADRB+1]
	LSHC C,-20
	DPB D,[2000,,HADRB+2]
	LSHC C,-20
	DPB D,[2000,,HADRB+3]
	PUSH P,A
	PUSHJ P,HREGDC
	XCT @-1(P)		;MAYBE DO CHECKING
	POP P,A
	AOJA A,HADRT2


HADRV:	0			;SAVE VECTOR TO DISPATCH ON
HADRBP:	0			;WHAT TO HAVE IN T ON HREGDC (AND THENCE IN A ON DISP)
HADRRC:	0			;ROTATE COUNT
HADRHP:	0			;POINTER TO HOLES TABLE

HADRB:	0			;BLOCK USED TO HOLD DATA
	0
	0
	0

HADRC:	0			;BLOCK USED TO READ IN DATA
	0
	0
	0

HADMSK:	0
	1
	3
	7
	17
	37
	77
	177
	377
	777
	1777
	3777
	7777
	17777
	37777
	77777
	177777

HRGHTB:
IFN HRCME-HRCMO-CHECML,[
	HRCMO+CHECML		;TABLE OF HOLES IN REG ADR SPACE
	HRCME			; ODD WDS GIVE END OF HOLE
]
	HRSQO			;SQ LIST WOULD LOSE SINCE IT ALSO GETS WRITTEN WITH LOC
	HRSQE
	HRRGO			;RANDOM REGISTERS
	HRREND
	200000,,



XRCMEM:	PUSH P,T		;READ C-MEM
	PUSH P,TT
	PUSH P,A
	DPB B,[%H0JF XRCMA1]	;MAKE A 0 INSTRUCTION WITH THE DESIRED NAF
	MOVEI A,XRCMA1
	EWIR
	ECLK
	MOVE A,(P)
	JRST XRIR1

XRCMA1:	0
	0
	0
	0

XRFIR:	PUSH P,T		;READ FULL IR (ALL 6 WDS)
	PUSH P,TT
	PUSH P,A
	MOVSI T,-6
	JRST XRIR2

XRIR:	PUSH P,T		;READ IR
	PUSH P,TT
	PUSH P,A
XRIR1:	MOVSI T,-4
XRIR2:	DPB T,[HMUXSL]
	LDB TT,[HMUX]
	MOVEM TT,(A)
	AOS A
	AOBJN T,XRIR2
	POP P,A
	POP P,TT
	POP P,T
	POPJ P,

XWFIR:	PUSH P,T		;WRITE FULL IR (ALL 6 WDS)
	PUSH P,TT
	PUSHJ P,HDEPIF
	JRST XWFI1

XWIR:	PUSH P,T		;WRITE IR
	PUSH P,TT
	PUSHJ P,HDEPI
XWFI1:	POP P,TT
	POP P,T
	POPJ P,

XWCMEM:	PUSH P,T		;WRITE C-MEM
	PUSH P,TT
	PUSHJ P,HDEPC
	POP P,TT
	POP P,T
	POPJ P,


XRPDLB:	PUSH P,B		;READ DATA PDL MEMORY
	PUSHJ P,XLDPAR		;ASSURE PAR SAVED AND LOAD IN B
	MOVEI B,HASPDL		;ASOURCE ADR OF PDL
	ERAS
	POP P,B
	POPJ P,

XLDPAR:	PUSH P,A
	MOVEM B,XRPDT1		;SAVE PAR AND PUT B IN PAR
	ESPAR			;ASSURE PAR SAVED
XSVPA1:	MOVEI A,XRPDT1
	MOVEI B,HODAAC		;ODEST ADR OF PAR (AAC 0)
	EWOD
	POP P,A
	POPJ P,

XRPDT1:	0

XSPAR:	SKIPGE HPARSF		;SAVE PAR IF NOT ALREADY
	POPJ P,			;PAR ALREADY SAVED
	PUSH P,A
	PUSH P,B
	MOVEI A,HPARSV		;SAVE PAR
	MOVEI B,10		;PAR IS AAC 0
	ERAC
	SETOM HPARSF
	POP P,B
	POP P,A
	POPJ P,

XWPDLB:				;WRITE DATA PDL MEMORY
	PUSHJ P,XLDPAR		;ASSURE PAR SAVED AND LOAD IN B
	MOVEI B,HODPDL		;ODEST ADR OF PDL
	EWOD
	POPJ P,

XLDUSP:	PUSH P,A
	MOVEM B,XRPDT1		;SAVE USP AND PUT B IN USP
	ESUSP
XSVUS1:	MOVEI A,XRPDT1
	MOVEI B,HODUSP		;ODEST ADR OF USP
	EWOD
	POP P,A
	POPJ P,


XSUSP:	SKIPGE HUSPSF		;SKIP IF USP NOT SAVED ALREADY
	POPJ P,			;USP ALREADY SAVED
	PUSH P,A
	PUSH P,B
	MOVEI A,HUSPSV		;SAVE USP
	MOVEI B,HOSUSP
	EROS
	SETOM HUSPSF
	POP P,B
	POP P,A
	POPJ P,

XRUSTK:	PUSHJ P,XLDUSP		;READ U-STACK MEM (SAVE AND LOAD USP (SPCPTR)
	MOVEI B,HOSUS		;O-BUS ADR OF U-STACK
	EROS
	POPJ P,

XWUSTK:	PUSHJ P,XLDUSP		;WRITE U-STACK MEM
	MOVEI B,HODUS
	EWOD
	POPJ P,

XRAC:	PUSH P,A
	DPB B,[%H3LBB XRACIN+3]	;READ B-BUS ADR (AC OR AAC)
	MOVEI A,XRACIN
	EWIR
	POP P,A
	HSTORE H0MOB,(A)	;READ OBUS
	POPJ P,

XRACIN:	0			;ALU INSTRUCTION TO READ B-BUS
	0
	0
	37_4	;SET B


XWAC:	ADDI B,HODAC		;WRITE B-BUS ADR (CONVERT TO ODEST ADR)
XWOD:	DPB B,[%H2LOD XWODIN+2]	;WRITE ODEST ADR (PUT DEST IN ALU INST)
	PUSH P,A
	MOVEI A,XWODIN		;PUT THAT IN IR
	EWIR
	POP P,A			;STORE DESIRED DATA IN DBR
	MOVE B,(A)
	DPB B,[T11LH,,UNIFA+1]
	ECLK			;NOW CLOCK IT
	POPJ P,

XWODIN: 0
	0
	0		;ODEST GETS STORED HERE
	HOSDBR_10.


XRSQL:	PUSH P,A		;READ SQUARE LIST MEM
	PUSHJ P,XSQLSL		;SELECT ADDRESS IN SQARE LIST MEM
				;  ALSO SELECT PS-BUS FROM POUT,,LOC
	HSTORE H0MOB,B		;READ O-BUS
	LDB B,[101000,,B]	;GET POUT
	POP P,A
	MOVEM B,(A)
	POPJ P,

XSQLSL:	MOVEM B,XSQLS1		;SELECT SQUARE LIST ADR IN B
	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB			;DEPOSIT THAT IN PDL-MEM 0 (ALSO LEAVING PAR=0)
	MOVEI A,XSQLS2
	EWIR
	POPJ P,

XSQLS1:	0

XSQLS2:	0			;ARRAY INSTRUCTION
	H1AMOP			; PDL -> SBUS, POUT,,LOC -> PS-BUS
	H2APSR
	5*H3APSB+1*H3ASQB

XWSQL:	PUSH P,A		;WRITE SQUARE LIST (DOES WMOVE)
	MOVEM B,XSQLS1
	MOVE B,(A)		;GET DATA TO WRITE
	DPB B,[101000,,XSQLS1]	;PUT THAT IN LH OF ADR (SO IT SHOW UP ON L A-BUS
XWSQL1:	PUSH P,[XSQLS3]
XWSQL2:	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB
	POP P,A
	EWIR
	ECLK
	POP P,A
	POPJ P,

XSQLS3:	0
	H1AMOP
	H2APSR+H2AWMV
	5*H3APSB+1*H3ASQB

XWPIEC:	PUSH P,A		;XWSQL AND ALSO SET PEX BIT
	MOVEM B,XSQLS1
	MOVE B,(A)		;GET DATA TO WRITE
	DPB B,[101000,,XSQLS1]	;PUT THAT IN LH OF ADR (SO IT SHOW UP ON L A-BUS
	PUSH P,[XWPEC1]
	JRST XWSQL2

XWPEC1:	0			;SIMILAR TO ABOVE BUT ALSO WRITES PIECE-EXISTS BIT
	H1AMOP
	H2APSR+H2AWMV+H2APX+H2AWPX
	5*H3APSB+1*H3ASQB


XRPLOC:	PUSH P,A		;READ PIECE-LOC MEM
	CLEARM XSQLS1
	DPB B,[101000,,XSQLS1]	;WILL APPEAR ON L A-BUS
	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB
	MOVEI A,XSQLS4
XRPTY1:	EWIR
	HSTORE H0MOB,B		;READ O-BUS
	ANDI B,377
	POP P,A
	MOVEM B,(A)
	POPJ P,

XSQLS4:	0			;ARRAY INST
	H1AMOP			;PDL -> P-BUS
	H2APSR			;POUT,,LOC -> PS-BUS
	5*H3APSB+0*H3APBB

XWPLOC:	PUSH P,A		;WRITE PIECE-LOC MEM (DOES WMOVE)
	CLEARM XSQLS1
	DPB B,[101000,,XSQLS1]
	MOVE B,(A)
	DPB B,[001000,,XSQLS1]
	JRST XWSQL1

XRPTYP:	PUSH P,A		;READ PIECE-TYP MEM
	CLEARM XSQLS1
	DPB B,[101000,,XSQLS1]	;STORE PIECE NUMBER (IE ADDRESS)
	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB
	MOVEI A,XSQLS5
	JRST XRPTY1

XSQLS5:	0			;ARRAY INST
	H1AMOP			;PDL -> P-BUS
	H2APSR			;TYP -> PS-BUS
	4*H3APSB+0*H3APBB

XWPTYP:	PUSH P,A		;WRITE PIECE-TYP MEM
	DPB B,[101000,,XSQLS1]	;PIECE NUMBER (TO L A-BUS)
	MOVE B,(A)
	DPB B,[001000,,XSQLS1]	;VAL (TO R A-BUS)
	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB
	MOVEI A,XSQLS6		;WRITE TYP
	EWFIR			;WRITE FULL IR TO ASSURE P-BUS DRIVEN FROM A-BUS
	ECLK
	POP P,A
	POPJ P,

XSQLS6:	0			;ALU INST
	0
	HASPDL_11.+HODTYP_2	; PDL -> ABUS, ODEST. -> TYP
	0*H3LOBB+32*H3LALU
	0
	0*H3APBB


XRPVAL:	PUSH P,A		;READ PIECE-VAL MEM
	CLEARM XSQLS1
	DPB B,[101000,,XSQLS1]	;STORE PIECE NUMBER (IE ADDRESS)
	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB
	MOVEI A,XSQLS8
	JRST XRPTY1

XSQLS8:	0			;ARRAY INST
	H1AMOP			;PDL -> P-BUS
	H2APSR			;VAL -> PS-BUS
	3*H3APSB+0*H3APBB


XWPVAL:	PUSH P,A		;WRITE PIECE-VAL MEM
	DPB B,[101000,,XSQLS1]	;PIECE NUMBER (TO L A-BUS)
	MOVE B,(A)
	DPB B,[001000,,XSQLS1]	;TYP (TO R A-BUS)
	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB
	MOVEI A,XSQL10		;WRITE VAL
	EWFIR			;WRITE FULL IR TO ASSURE P-BUS DRIVEN FROM A-BUS
	ECLK
	POP P,A
	POPJ P,

XSQL10:	0			;ALU INST
	0
	HASPDL_11.+HODVAL_2	; PDL -> ABUS, ODEST. -> VAL
	0*H3LOBB+32*H3LALU
	0
	0*H3APBB

XRAS:	PUSH P,A		;READ A-SOURCE
	DPB B,[%H2ASH XRAS1+2]
	MOVEI A,XRAS1
	EWIR
	POP P,A
	HSTORE H0MOB,(A)
	POPJ P,

XRAS1:	0		;ALU INST
	0
	0		;ABUS -> OBUS
	32*H3LALU

XROS:	PUSH P,A		;READ O-BUS SELECTOR
	DPB B,[%H3LOBB XROS1+3]
	MOVEI A,XROS1
	EWIR
	POP P,A
	HSTORE H0MOB,(A)
	POPJ P,

XROS1:	0		;ALU INST
	0
	0
	0


XRPXM:	PUSH P,A		;READ PIECE-EXISTS "MEMORY"
	CLEARM XSQLS1
	DPB B,[101000,,XSQLS1]
	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB
	MOVEI A,XSQL11
	EWIR
	ECLK			;CLOCK TO GET DATA INTO FLAG WD
	MOVEI A,XRPXT1
	MOVEI B,HASFLC
	ERAS
	POP P,A
	LDB B,[170100,,XRPXT1]	;SELP IS THE HIGH BIT
	MOVEM B,(A)
	POPJ P,

XRPXT1:	0

XSQL11:	0	;ARRAY INST
	H1AMOP
	H2APSR		;PDL -> ABUS
	0*H3ALPS	;LAST PIECE FROM LEFT A-BUS

XWPXM:	PUSH P,A		;READ PIECE-EXISTS "MEMORY"
	CLEARM XSQLS1
	DPB B,[101000,,XSQLS1]
	MOVE B,(A)
	DPB B,[%H2APX XSQL12+2]	;INTO PEX BIT
	MOVEI A,XSQLS1
	MOVEI B,0
	EWPDLB
	MOVEI A,XSQL12
	EWIR
	ECLK			;CLOCK TO WRITE DATA
	POP P,A
	POPJ P,

XSQL12:	0
	H1AMOP
	1*H2AWPX+H2APSR		;WPEX WRITE PULSE
	0*H3ALPS

XRSIR:	PUSH P,A		;READ SIR REGISTER
	MOVEI A,XRCHT1
XRSIR2:	MOVE ZR,[001000,,XRCHT2]
XRSIR3:	MOVEM ZR,XRCHT3
	EWIR
	MOVEI A,XRCHT2
	MOVEI B,HOSPSB
	EROS
	POP P,A
	LDB ZR,XRCHT3
	MOVEM ZR,(A)
	POPJ P,

XRCHT1:	0
	H1AMOP
	0
	0*H3APSB		;PS-BUS FROM PR,,SIR

XRCHT2:	0
XRCHT3:	0

XRCHT4:	0
	H1AMOP
	0
	1*H3APSB+0*H3ASQB	;PS-BUS FROM POUT,,SQ-BUS
				;SQ-BUS FROM SR


XRSR:	PUSH P,A		;READ SR
	MOVEI A,XRCHT4
	JRST XRSIR2
	
XRPR:	PUSH P,A		;READ PR
	MOVEI A,XRCHT1
	MOVE ZR,[101000,,XRCHT2]
	JRST XRSIR3

XWSIR:	PUSH P,A
	PUSH P,B		;WRITE SIR
	MOVEI B,0
	EWPDLB			;PUT DATA IN DATA-PDL LOCN 0
	MOVEI A,XWCHT1
XWSR1:	EWIR
	ECLK
	POP P,B
	POP P,A
	POPJ P,

XWCHT1:	0
	H1AMOP			;ARRAY INST.
	H2APSR+H2AWSIR		;PDL-SRC AND WRITE SIR
	1*H3ASQB+0*H3ASIS	;SQ-BUS FROM RA BUS, SIR FROM SQ-BUS

XWSR:	PUSH P,A		;WRITE SR
	PUSH P,B
	MOVEI B,0
	EWPDLB
	MOVEI A,XWCHT2
	JRST XWSR1

XWCHT2:	0
	H1AMOP
	H2APSR+H2AWSR		;PDL SRC AND WRITE SR
	0*H3ASRS		;SR FROM RA BUS

XWPR:	PUSH P,A		;WRITE PR
	PUSH P,B
	MOVE B,(A)
	DPB B,[101000,,XWCHT3]
	MOVEI A,XWCHT3
	MOVEI B,0
	EWPDLB
	MOVEI A,XWCHT4
	JRST XWSR1

XWCHT3:	0

XWCHT4:	0
	H1AMOP
	H2APSR+H2AWPR		;PDL SRC AND WRITE PR
	0*H3APRS		;PR FROM LA BUS


XRFLG:	PUSH P,A		;STORE ALL FOUR FLAG WORDS
	HRLI A,-4
	MOVEI B,HASFLA
XRFLG1:	PUSH P,B
	ERAS
	POP P,B
	AOS B
	AOBJN A,XRFLG1
	POP P,A
	POPJ P,

XWFLG:	HLOAD H0LFLA,(A)	;LOAD ALL FOUR FLAG WORDS
	HLOAD H0LFLB,1(A)
	HLOAD H0LFLC,2(A)
	HLOAD H0LFLD,3(A)
	POPJ P,

XRERWS:				;READ IN CHEOPS STATUS
	LDB ZR,[T11RH,,UNIFA]	;176002
	MOVEM ZR,(A)		;WD0 GETS UNIBUS STATUS
	HSTORE H0MPAR,1(A)	;WD1 GETS PARITY BITS
	HSTORE H0MSFN,2(A)	;WD2 GETS SPEC-FCTN BITS
	POPJ P,


HREGDD:	MOVEI T,HCNUM		;GOOD FOR DEPOSITING
	JRST HREGDC

HREGDE:	MOVEI T,HRGB		;USE THAT FOR READING INTO ...
HREGDC:	MOVEI C,0		;DECODE REGISTER ADR IN A, VECTOR IN B
HRGDCL:	CAML A,HRGATL(C)	;A WILL GET ORIGINAL CONTENTS OF T ON DISPATCH
	AOJA C,HRGDCL		;HIGHER THAN THAT
	MOVE ZR,HRGATL-1(C)
	MOVEM ZR,HRGDEF		;BASE OF LAST MEM ADDRESSED
	SUB A,ZR		;GET RELATIVE ADR
	ADD C,B			;GET DISPATCH ADR
	MOVE B,A
	MOVE A,T
	JRST @(C)

HRGDEF:	0		;BASE OF LAST MEM ADDRESSSED
HBLMEX:	0		;BASE OF LAST MEM EXAMINED (WITH /, ETC)
HEXPF:	0		;EXAMINE PRINT FLAG. IF -1 EXAMINE ROUTINE
			; PRINTS DATA, OTHERWISE IT RETURNS WITH
			; POINTER TO DATA IN A AND FIELD SPEC IN B

	0	;MUST BE HERE
HRGATL:	HRORG	;TOO LOW ..
HRGATH:	HRCME	;CONTROL MEM
	HRPDE	;DATA PDL
	HRUSE	;U STACK
	HRACE	;AC S AND AAC S
	HRPTE	;PIECE TYPE LIST
	HRSQE	;SQUARE LIST
	HRPLE	;PIECE LOC LIST
	HRPVE	;PIECE VAL LIST
	HRPXME	;PIECE-EXISTS "MEMORY"
	HRRDRE	;RAID REGISTERS
	HRRGE	;RANDOM REGISTERS, ETC
	HRASE	;A-SOURCE S
	HRODE	;ODEST S
	SETZ-1


;IF HEXPF = -1, EXAMINE AND PRINT FROB
; OTHERWISE, RETURN WITH A POINTING TO DATA AND B A FIELD SPEC

HEXAMV:	HCMERR	;TOO LOW
	HEXC	;CONTROL MEM
	HEXP	;DATA PDL
	HEXU	;U STACK
	HEXAC	;AC S AND AAC S
	HEXPT	;PIECE TYPE LIST
	HEXS	;SQUARE LIST
	HEXPL	;PIECE LOC LIST
	HEXPV	;PIECE VAL LIST
	HEXPXM	;PIECE-EXISTS "MEMORY"
	HEXRDR	;RAID REGISTERS
	HEXRG	;RANDOM REGISTERS, ETC
	HEXAS	;A-SOURCE S
	HEXOD	;ODEST S
	HCMERR	;TOO HIGH

HEXC:	ERCMEM			;EXAMINE CONTROL MEM
HEXIR1:	MOVEI B,64.*1000+0
	SKIPL HEXPF
	POPJ P,
	EPI
	JRST HCRR

HEXPXM:	ERPXM			;EXAMINE PIECE-EXISTS "MEMORY"
	MOVEI B,1.*1000+0
	JRST HEXPC1

HEXP0:	MOVE C,HSVPD0
HEXP0A:	MOVEM C,(A)
	JRST HEXPB1

HEXP:	JUMPE B,HEXP0		;PDL MEM 0 LOCN SPECIALLY STORED
	PUSH P,B
	ERPDLB			;EXAMINE DATA PDL
	POP P,B
	SKIPGE HEXPF
	CAIGE B,300
	JRST HEXPB1		;NO PRINTOUT OR IN REGISTER AREA
	ANDI B,3		;IN MOVE PDL AREA, PRINT AS MOVE AS WELL
	CAIN B,3
	JRST HEXPB1		;SAVED ALPHA-BETA, JUST PRINT NUMERIC
	CAIN B,2
	JRST HEXPB1		;SAVED FLAGCELL, JUST NUMERIC FOR NOW
	EPRPCL			;PRINT LEFT HALF OF PDL DATA AS PC
	EPRSQ			;PRINT RIGHT HALF OF PDL DATA AS SQ
HEXPB1:	MOVEI B,16.*1000+0
HEXPC1:	SKIPL HEXPF
	POPJ P,
	IPNFLD
HEXRDX:	SOS HRGOPF
	POPJ P,

HEXU:	ERUSTK			;EXAMINE U STACK
	MOVEI B,11.*1000+0
	JRST HEXPC1

HEXAC:	SKIPE HPARSF		;IS PAR SAVED?
	CAIE B,HRRPAR-HRACO	;AND EXAMINING PAR?
	JRST HEXAC1
	MOVE C,HPARSV		;LOOK AT SAVED THING
	JRST HEXP0A

HEXAC1:	ERAC			;EXAMINE AC S OR AAC S
	JRST HEXPB1


HEXS:	ERSQL			;EXAMINE SQUARE LIST
	SKIPGE HEXPF
	EPRPC
HEXS1:	MOVEI B,8*1000+0
	JRST HEXPC1

HEXPL:	ERPLOC			;EXAMINE PIECE LOC
	SKIPGE HEXPF
	EPRSQ
	JRST HEXS1

HEXPV:	ERPVAL			;EXAMINE PIECE VAL
	MOVEI B,8*1000+0
	JRST HEXPC1

HEXPT:	ERPTYP			;EXAMINE PIECE TYPE
	MOVEI B,8*1000+0
	JRST HEXPC1

HEXAS:	ERAS			;EXAMINE A-SOURCE
	JRST HEXPB1

HEXOD:	JRST HCMERR		;CHECK FOR WHICH OF THESE WANT TO WIN ..

HEXRDR:	MOVE C,HRAIDA(B)	;EXAMINE RAID REGISTERS
	MOVEM C,(A)
	MOVEI B,16.*1000+0
	SKIPL HEXPF
	POPJ P,
	SKIPE A,(A)		;SKIP ON NULL
	PUSHJ P,HPAD
HEXSET:	HSOUT [ASCIZ / /]	;RESET REGISTER
	JRST HEXRDX

HEXRG:	CAIL B,HEXCVL
	JRST HCMERR
	JRST @HRGCT(B)

HRGCT:	HEXFLW		;FLAGA
	HEXFLW		;FLAGB
	HEXFLW		;FLAGC
	HEXFLW		;FLAGD
	HEXSTA		;STATA
	HEXSTB		;STATB
	HEXUAR		;UAR
	HEXUDR		;UDR
	HEXORG		;O-REG
	HEXFL		;FLAGCELL
	HEXNFL		;NEXT-FLAGCELL
	HEXUSP		;U-STACK POINTER
	HEXSIR		;SIR
	HEXSR		;SR
	HEXPR		;PR
	HEXIR2		;SAVED IR
	HEXIRA		;SAVED IRA
	HEXNAF		;SAVED NAF	
	HEXPC		;SAVED PC
	HEXSC		;STEP COUNTER
	HEXLTP		;LAST TEST POSITION USED
	HEXSA		;STARTING ADR
	HEXSTR		;STAR REGISTER
	HEXDBL		;DOORBELL REGISTER
;ADD NEW REGISTERS TO BE INCLUDED IN DUMP FILE HERE
	HEXSET		;RESET REGISTER
	HEXNXP		;NEXT-PIECE OUTPUT OF PIECE SCANNER
	HEXNXS		;NEXT-SQUARE OUTPUT OF SQUARE SCANNER
	HEXPBS		;PIECE-BUS
	HEXSBS		;SQUARE-BUS
	HEXPOU		;POUT
	HEXPLC		;PIECE-LOC
	HEXPVL		;PIECE-VAL
	HEXPTP		;PIECE-TYPE
	HEXFLS		;FLAGA SYMBOLICALLY
	HEXFLS		;FLAGB SYMBOLICALLY
	HEXFLS		;FLAGC SYMBOLICALLY
	HEXFLS		;FLAGD SYMBOLICALLY
	HEXNFW		;NEXT-FLAGA
	HEXNFW		;NEXT-FLAGB
	HEXNFW		;NEXT-FLAGC
	HEXNFW		;NEXT-FLAGD
	HEXNFS		;NEXT-FLAGA SYMBOLICALLY
	HEXNFS		;NEXT-FLAGB SYMBOLICALLY
	HEXNFS		;NEXT-FLAGC SYMBOLICALLY
	HEXNFS		;NEXT-FLAGD SYMBOLICALLY
  REPEAT 20,HEXFQ	;FLAGWORD QUARTER BOTH WAYS
  REPEAT 20,HEXNFQ	;NEXT-FLAGWORD QUARTER BOTH WAYS
	HEXSTM		;SIDE-TO-MOVE
	HEXSQL		;DRAW PICTURE OF SQUARE LINES
	HEXBD		;DRAW PICTURE OF BOARD
	HEXP1F		;PDP11 FLAGS 1 AND 0
	HEXGM		;PRINT CURRENT GAME LINE (300@P -> C(PAR)
	HEXSPD		;MACHINE SPEED CONTROL BITS
	HEXSTC		;STATA AND STATB AS 32 BIT REGISTER
	HEXPVP		;PRINCIPLE VARIATION
HEXCVL==.-HRGCT


HEXBD:	PUSH P,HCPOS	;DRAW PICTURE OF BOARD
	PUSH P,HCLINE
	MOVEI A,70
	MOVEM A,HSQPSN
HEXBD1:	LDB A,[300,,HSQPSN]	;THIS FIRST FILE OF RANK?
	JUMPN A,HEXBD2
	LDB B,[30300,,HSQPSN]	;DO CURSOR POSITION
	MOVNS B
	ADDI B,18.+7		;TO PUT IT BELOW SQUARE LINE PICTURE
	MOVE A,HCHWD
	SUBI A,8*5+4
	PUSHJ P,HCSRPS
	PUSHJ P,HCLEOL
HEXBD2:	MOVE B,HSQPSN
	MOVEI A,HSQPST
	ERSQL
	SKIPN (A)
	 JRST [	LDB A,[30100,,HSQPSN]
		XOR A,HSQPSN
		ANDI A,1
		HSOUT HBDTX(A)
		HSOUT [ASCIZ / /]
		JRST HEXBD3]
	EPRPC
HEXBD3:	AOS A,HSQPSN
	TRNN A,7
	SUBI A,20
	MOVEM A,HSQPSN
	JUMPGE A,HEXBD1
	JRST HEXBDX
	
HBDTX:	ASCIZ / ++ /
	ASCIZ / -- /

HEXSQL:	PUSH P,HCPOS	;DRAW PICTURE OF SQUARE LINES
	PUSH P,HCLINE
	MOVEI A,HEXSSR
	ERSR		;SAVE SR
	MOVE A,HSVIR+4	;PRESERVE ARRAY SELECT, NOBLE ENABLE,ETC
	ANDCM A,[H2AWPX+H2AWSR+H2AWSIR+H2AWPR+H2AWMV+H2AWDT]
	MOVEM A,HSQPT1+4
	MOVE A,HSVIR+5
	TRO A,H3ALSS	;LAST SQ SELECT FROM SR
	MOVEM A,HSQPT1+5
	MOVEI A,70
	MOVEM A,HSQPSN
HSQPL1:	LDB A,[300,,HSQPSN]	;THIS FIRST FILE OF RANK?
	JUMPN A,HSQPL2		;NO
	LDB B,[30300,,HSQPSN]	;DO CURSOR POSITION
	MOVNS B
	ADDI B,10.+7
	MOVE A,HCHWD
	SUBI A,15.
	PUSHJ P,HCSRPS
	PUSHJ P,HCLEOL	;CLEAR TO END OF LINE
HSQPL2:	MOVEI A,HSQPSN	;SQUARE TO HACK
	EWSR		;PUT THAT IN SR
	MOVEI A,HSQPT1	;NOW PUT RIGHT THING IN IR
	EWFIR
	ECLK		;CLOCK IT TO LOAD FLAGS
	MOVEI B,HASFLC	;READ IN FLAG WD C
	MOVEI A,HSQPST
	ERAS
	LDB C,[010100,,HSQPST]	;GET SEL-SQ BIT
	HSOUT HSQPTX(C)
	AOS A,HSQPSN
	TRNN A,7
	SUBI A,20
	MOVEM A,HSQPSN
	JUMPGE A,HSQPL1
	MOVEI A,HEXSSR
	EWSR		;RESTORE SR
HEXBDX:	POP P,B
	POP P,A
	PUSHJ P,HCSRPS
	POPJ P,

HEXSSR:	0		;TEM FOR SAVING SR
HSQPST:	0		;TEM FOR READING FLAG WD INTO
HSQPSN:	0		;SQUARE HACKING
HSQPT1:	BLOCK 6		;MODIFIED IR

HSQPTX:	ASCIZ /-/
	ASCIZ /+/



HEXGM:	ESPAR			;ASSURE PAR SAVED
	MOVE B,HPARSV
	CAILE B,300+20.*4
	MOVEI B,300+20.*4	;PRINT MAX OF 20 MOVES
	MOVEM B,HEXGT2
	MOVEI B,300		;PRINT CURRENT GAME LINE
HEXGM1:	CAML B,HEXGT2
	JRST HEXGMX
	MOVEI A,HEXGT1
	PUSH P,B
	ERPDLB
	EPRPCL			;PRINT MOVING PC
	EPRSQ			;PRINT ORIGIN SQ
	MOVEI A,"-
	PUSHJ P,HTYO
	POP P,B
	AOS B
	CAML B,HEXGT2
	JRST HEXGMX
	PUSH P,B
	ERPDLB
	MOVE C,(A)
	TRNE C,377_8
	EPRPCL			;PRINT PIECE CAPT IF ANY
	EPRSQ			;DESTINATION
	MOVEI A,40
	PUSHJ P,HTYO
	POP P,B
	CAIL B,300		;SKIP IF PRINTING PV (TOTAL CROCK)
	ADDI B,2
	AOJA B,HEXGM1

HEXGT1:	0
HEXGT2:	0

HEXGMX:	JRST HCLEOL

HEXPVP:	PUSH P,HCPOS		;PRINT PRINCIPLE VARIATION
	PUSH P,HCLINE
	MOVEI B,7
	PUSHJ P,HXPVP1
	MOVEI B,12		;PV10A
	MOVEM B,HEXGT2		;SET LIMIT
	MOVEI B,4		;PV00A
	PUSHJ P,HEXGM1		;PRINT LVL 0 P.V. LINE
	MOVEI B,7+1
	PUSHJ P,HXPVP1
	MOVEI B,16		;PV20A
	MOVEM B,HEXGT2
	MOVEI B,12		;PV10A
	PUSHJ P,HEXGM1		;PRINT LVL 1 P.V. LINE
	MOVEI B,7+1+1
	PUSHJ P,HXPVP1
	MOVEI B,20		;PV20B+1
	MOVEM B,HEXGT2
	MOVEI B,16
	PUSHJ P,HEXGM1
	JRST HEXBDX
	
HXPVP1:	MOVE A,HCHWD
	SUBI A,55.
	PUSHJ P,HCSRPS
	JRST HCLEOL

HEXSTM:	LDB C,[160100,,HSVFLA+1]	;EXAMINE SIDE TO MOVE
	MOVEM C,(A)
	MOVEI B,1*1000+0
	JRST HEXPC1

HEXFQ:	SUBI B,HRRQ0-HRRFLA	;EXAMINE FLAGWORD QUARTER BOTH WAYS
HEXFQC:	MOVEI D,HSVFLA		;ENTER HERE FROM CONSOLE DISPLAY
HEXFQ1:	LDB T,[000200,,B]	;QUARTER WITHIN FLAGWORD
	LSH B,-2		;GET FLAGWORD #
	ADD D,B			;GET POINTER TO WHERE IT IS STORED
	LDB C,HEXFQT(T)		;GET QUARTER ITSELF
	MOVEM C,(A)
	PUSH P,A
	SKIPL HEXPF
	JRST HEXFQ2
	MOVE C,HEXFLT(B)	;GET POINTER TO SYMBOL TABLE FOR ENTIRE FLAGWORD
	MOVE B,(D)		;GET ENTIRE FLAGWORD
	AND B,HEXFQU(T)		;MASK TO DESIRED QUARTER
	PUSHJ P,XPER1		;PRINT THAT
HEXFQ2:	POP P,A			;SET UP POINTER TO NUMERIC VALUE
	MOVEI B,4.*1000+0
	JRST HEXPC1

HEXFQT:	000400,,(D)
	040400,,(D)
	100400,,(D)
	140400,,(D)

HEXFQU:	.BM <000400,,>
	.BM <040400,,>
	.BM <100400,,>
	.BM <140400,,>

HEXFQM:	0		;TEMP
	
HEXNFQ:	PUSHJ P,HRNFWS		;EXAMINE NEXT FLAGWORD QUARTERS BOTH WAYS
	MOVEI D,HNFWDS
	SUBI B,HRRNQ0-HRRFLA
	JRST HEXFQ1

HEXFLW:	MOVE C,HSVFLA(B)	;EXAMINE SAVED FLAG WORDS
	JRST HEXP0A

HEXFLS:	MOVE D,HSVFLA-HRSFLA+HRRFLA(B)	;EXAMINE SAVED FLAGS SYMBOLICALLY
	MOVEM D,(A)
	MOVE C,HEXFLT-HRSFLA+HRRFLA(B)	;POINTER TO "SYMBOL TABLE BLOCK"
HEXNF1:	SKIPL HEXPF
	JRST HEXPB1
	MOVE B,(A)
	PUSHJ P,XPER1
	POPJ P,

HEXFLT:	HFLASM			;POINTER TO "SYMBOL TABLE BLOCK"
	HFLBSM
	HFLCSM
	HFLDSM


HEXNFW:	PUSHJ P,HRNFWS		;READ IN NEXT-FLAG WORDS
	MOVE C,HNFWDS-HRRNLA+HRRFLA(B)
	JRST HEXP0A

HEXNFS:	PUSHJ P,HRNFWS		;READ IN NEXT-FLAG WORDS AND PRINT SYMBOLICALLY
	MOVE D,HNFWDS-HRSNLA+HRRFLA(B)
	MOVEM D,(A)
	MOVE C,HEXFLT-HRSNLA+HRRFLA(B)
	JRST HEXNF1

HRNFWS:	PUSH P,A
	PUSH P,B		;READ IN "NEXT" FLAGWORDS
	PUSHJ P,HRNFW1
	POP P,B
	POP P,A
	POPJ P,

HRNFW1:	PUSHJ P,HRESNV		;LIKE HRESSV BUT DONT RESTORE MACHINE STATE AFTERWARDS
	ECLK			; ALSO NO-OPS IR BEFORE LOADING IT
	MOVEI A,HNFWDS
	ERFLG
	POPJ P,

HEXSTC:	MOVEI B,HASSTB		;EXAMINE STATB AND STATA AS 32 BIT REGISTER
	AOS A
	ERAS			;READ HIGH ORDER WORD
	SOS A
	MOVEI B,HASSTA
	ERAS			;NOW FOR LOW ORDER WORD
	MOVEI B,32.*1000+0
	JRST HEXPC1

HEXSTA:
HEXSTB:
HEXUAR:
HEXUDR:	MOVEI B,HASSTA-4(B)	;TURN INTO EQUIVALENT A-SOURCE
	JRST HEXAS

HEXORG:	MOVE C,HSVORG		;EXAMINE SAVED O-REG
	JRST HEXP0A

HEXFL:	MOVEI B,HASFC		;EXAMINE FLAG-CELL
	JRST HEXAS

HEXNFL:	MOVEI B,HASNFC		;EXAMINE NEXT-FLAG-CELL
	JRST HEXAS

HEXUSP:	SKIPL HUSPSF		;EXAMINE U-STACK POINTER
	ESUSP			;SAVE IF NOT ALREADY SAVED
	MOVE C,HUSPSV
	MOVEM C,(A)
	MOVEI B,8.*1000+0
	JRST HEXPC1

HEXSIR:	ERSIR			;EXAMINE SIR
HEXSI1:	SKIPGE HEXPF
	EPRSQ
HEXSI2:	MOVEI B,8.*1000+0
	JRST HEXPC1

HEXSR:	ERSR			;EXAMINE SR
	JRST HEXSI1

HEXPR:	ERPR			;EXAMINE PR
	SKIPGE HEXPF
	EPRPC
	JRST HEXSI2


HEXIR2:	MOVE C,HSVIR		;EXAMINE SAVED IR
	MOVEM C,(A)
	MOVE C,HSVIR+1
	MOVEM C,1(A)
	MOVE C,HSVIR+2
	MOVEM C,2(A)
	MOVE C,HSVIR+3
	MOVEM C,3(A)
	JRST HEXIR1

HEXIRA:	MOVE C,HSVIR+4		;EXAMINED SAVED IRA
	MOVEM C,(A)
	MOVE C,HSVIR+5
	MOVEM C,1(A)
	MOVEI B,32.*1000+0
	JRST HEXPC1

HEXNAF:	MOVE C,HSVNAF		;EXAMINE SAVED NAF
	MOVEM C,(A)
HEXOP1:	MOVEI B,11.*1000+0
	JRST HEXPC1

HEXPC:	MOVE C,HSVPC		;EXAMINE SAVED PC
	MOVEM C,(A)
	JRST HEXOP1

HEXSC:	MOVE C,HSTEPS		;EXAMINE STEP COUNTER
HEXSC1:	MOVEM C,(A)
	MOVEI B,36.*1000+0
	JRST HEXPC1

HEXLTP:	MOVE C,HTPLST		;EXAMINE LAST TEST POSITION USED
	JRST HEXSC1

HEXSA:	MOVE C,HUSADR		;EXAMINE UCODE STARTING ADR
	JRST HEXOP1

HEXSTR:	LDB C,[%HSTAR UNIFA]	;EXAMINE STAR REGISTER (UNIBUS STATUS)
	MOVEM C,(A)
	MOVEI B,6.*1000+0
	JRST HEXPC1

HEXDBL:	LDB C,[%HDBL UNIFA]	;EXAMINE DOORBELL REGISTER
	MOVEM C,(A)
	MOVEI B,4.*1000+0
	JRST HEXPC1

HEXSPD:	SKIPA C,HCHSPD
HEXP1F:	LDB C,[100200,,HSVFLA+3];EXAMINE PDP-11 FLAGS 0 AND 1 AS A TWO BIT QUANTITY
	MOVEM C,(A)
	MOVEI B,2.*1000+0
	JRST HEXPC1

HEXNXP:	PUSHJ P,HEXNX0		;EXAMINE NXP
HEXPB2:	LDB C,[101000,,HENPT2]
	MOVE A,HENPT1
	MOVEM C,(A)
	SKIPGE HEXPF
	EPRPC
	JRST HEXSI2

HEXNXS:	PUSHJ P,HEXNX0		;EXAMINE NXS
HEXSB1:	LDB C,[001000,,HENPT2]
	MOVE A,HENPT1
	MOVEM C,(A)
	SKIPGE HEXPF
	EPRSQ
	JRST HEXSI2

HEXPBS:	PUSHJ P,HEXNX4		;EXAMINE PIECE-BUS
	JRST HEXPB2

HEXSBS:	PUSHJ P,HEXNX4		;EXAMINE SQUARE-BUS
	JRST HEXSB1

HEXPOU:	PUSHJ P,HEXNX6		;EXAMINE POUT
	JRST HEXPB2

HEXPLC:	PUSHJ P,HEXNX6		;EXAMINE PIECE-LOC
	JRST HEXSB1

HEXPVL:	MOVEI C,3		;READ VAL FROM PS-BUS
	PUSHJ P,HEXNX7
HEXPV1:	LDB C,[001000,,HENPT2]
	MOVE A,HENPT1
	MOVEM C,(A)
	JRST HEXSI2

HEXPTP:	MOVEI C,4		;READ TYP FROM PS-BUS
	PUSHJ P,HEXNX7
	JRST HEXPV1

HEXNX6:	MOVEI C,5		;READ POUT,,LOC FROM PS-BUS
HEXNX7:	SETOB D,T
	JRST HEXNX

HEXNX4:	SETOB D,T		;DONT CHANGE THOSE
	JRST HEXNX5


HEXNX0:	MOVEI D,3		;EVENTUALLY FOR SQUARE-BUS SELECTOR
	MOVEI T,2		;EVENTUALLY FOR PIECE-BUS SELECTOR
HEXNX5:	MOVEI C,2		;EVENTUALLY FOR PS-BUS SELECTOR TO SELECT P-BUS,,S-BUS
HEXNX:	REPEAT 6,PUSH P,HSVIR+.RPCNT	;EXAMINE PS-BUS WITH MACHINE STATE
	MOVEM A,HENPT1			;"RESTORED" EXCEPT:
	MOVE A,HSVIR+1			;IF NON-NEG, C HAS NEW PS-BUS SELECTOR
	TRNE A,H1AMOP			;D HAS SQUARE-BUS AND T PIECE-BUS
	JRST HEXNX1		;ARRAY OP, O-BUS WILL SELECT PS-BUS
	MOVEI A,HOSPSB
	DPB A,[%H3LOB HSVIR+3]	;MAKE SURE ALU INST SELECTS PS-BUS OUTPUT ON O-BUS
HEXNX1:	SKIPL C
	DPB C,[%H3SPS HSVIRA+1]	;PUT THAT IN PS-BUS SELECTOR
	SKIPL D
	DPB D,[%H3SSB HSVIRA+1]	;PUT THAT IN SQUARE BUS SELECTOR
	SKIPL T
	DPB T,[%H3SPB HSVIRA+1]	;PUT THAT IN PIECE BUS SELECTOR
	PUSHJ P,HEXNX2
	REPEAT 6,POP P,HSVIR+5-.RPCNT	;UNBUGGER SAVED IR
	POPJ P,

HEXNX2:	PUSHJ P,HRESSV		;"RESTORE" STATE OF MACHINE
	HSTORE H0MOB,HENPT2
	POPJ P,

HENPT1:	0			;SAVED A
HENPT2:	0			;SAVE P-BUS,,S-BUS WITH BUGGERED MACHINE STATE RESTORED

HRGB:	0			;TEMP BLOCK FOR EXAMINING FCTNS
	0
	0
	0


HDPV:	HCMERR	;TOO LOW
	HDPC	;CONTROL MEM (NUMERIC STYLE)
	HDPP	;DATA PDL
	HDPU	;U STACK
	HDPAC	;AC S AND AAC S
	HDPPT	;PIECE TYPE LIST
	HDPS	;SQUARE LIST
	HDPPL	;PIECE LOC LIST
	HDPPV	;PIECE VAL LIST
	HDPPXM	;PIECE-EXISTS "MEMORY"
	HDPRDR	;RAID REGISTERS
	HDPRG	;RANDOM REGISTERS, ETC
	HDPAS	;A-SOURCE S
	HDPOD	;ODEST S
	HCMERR	;TOO HIGH


HDPPXM:	EWPXM	;DEPOSIT IN PIECE-EXISTS "MEMORY"
	JRST HDPXIT

HDPP0:	MOVE C,(A)		;STORE IN PDL LOCN 0
	MOVEM C,HSVPD0
	JRST HDPXIT

HDPP:	JUMPE B,HDPP0		;PDL LOCN 0 SPECIALLY STORED
	EWPDLB	;DEPOSIT IN DATA PDL
	JRST HDPXIT

HDPU:	EWUSTK	;DEPOSIT IN U STACK
	JRST HDPXIT

HDPAC:	SKIPE HPARSF		;IS PAR SAVED?
	CAIE B,HRRPAR-HRACO	;AND STORING INTO PAR?
	JRST HDPAC1
	MOVE C,(A)
	MOVEM C,HPARSV		;STORE INTO SAVED THING
	JRST HDPXIT

HDPAC1:	EWAC	;DEPOSIT IN AC S OR AAC S
	JRST HDPXIT

HDPS:	EWSQL	;DEPOSIT IN SQUARE LIST
	JRST HDPXIT

HDPPL:	EWPLOC	;DEPOSIT IN PIECE LOC MEM
	JRST HDPXIT

HDPPV:	EWPVAL	;DEPOSIT IN PIECE VAL MEM
	JRST HDPXIT

HDPPT:	EWPTYP	;DEPOSIT IN PIECE TYPE MEM
	JRST HDPXIT

HDPAS:	JRST HCMERR	;A-SOURCE (CHECK FOR THOSE THAT ARE TO WORK)

HDPOD:	EWOD	;DEPOSIT IN ODEST
	JRST HDPXIT

HDPRDR:	MOVE C,(A)	;DEPOSIT IN RAID REGISTER
	MOVEM C,HRAIDA(B)
	JRST HDPXIT


HDPRG:	CAIL B,HDPCVL
	JRST HCMERR
	JRST @HDRGCT(B)

HDRGCT:	HDPFLW		;FLAGA
	HDPFLW		;FLAGB
	HDPFLW		;FLAGC
	HDPFLW		;FLAGD
	HDPSTA		;STATA
	HDPSTB		;STATB
	HDPUAR		;UAR
	HDPUDR		;UDR
	HDPORG		;O-REG
	HDPFL		;FLAGCELL
	HDPNFL		;NEXT-FLAGCELL
	HDPUSP		;U-STACK POINTER
	HDPSIR		;SIR
	HDPSR		;SR
	HDPPR		;PR
	HDPIR		;SAVED IR
	HDPIRA		;SAVED IRA
	HDPNAF		;SAVED NAF	
	HDPPC		;SAVED PC
	HDPSC		;STEP COUNTER
	HDPLST		;LAST TEST POSITION
	HDPSA		;UCODE STARTING ADR
	HDPSTR		;STAR REGISTER
	HDPDBL		;DOORBELL REGISTER
;ADD NEW REGISTERS TO BE INCLUDED IN DUMP FILES HERE
	HDPSET		;RESET REGISTER
	HCMERR		;NEXT-PIECE OUTPUT OF PIECE SCANNER
	HCMERR		;NEXT-SQUARE OUTPUT OF SQUARE SCANNER
	HCMERR		;PIECE-BUS
	HCMERR		;SQUARE-BUS
	HCMERR		;POUT
	HCMERR		;PIECE-LOC
	HCMERR		;PIECE-VAL
	HCMERR		;PIECE-TYP
	HCMERR		;FLAGA SYMBOLICALLY
	HCMERR		;FLAGB SYMBOLICALLY
	HCMERR		;FLAGC SYMBOLICALLY
	HCMERR		;FLAGD SYMBOLICALLY
	HCMERR		;NEXT-FLAGA
	HCMERR		;NEXT-FLAGB
	HCMERR		;NEXT-FLAGC
	HCMERR		;NEXT-FLAGD
	HCMERR		;NEXT-FLAGA SYMBOLICALLY
	HCMERR		;NEXT-FLAGB SYMBOLICALLY
	HCMERR		;NEXT-FLAGC SYMBOLICALLY
	HCMERR		;NEXT-FLAGD SYMBOLICALLY
  REPEAT 20,HCMERR	;FLAGWORD QUARTERS BOTH WAYS
  REPEAT 20,HCMERR	;NEXT FLAGWORD QUARTERS BOTH WAYS
	HDPSTM		;SIDE-TO-MOVE
	HCMERR		;SQUARE LINES PICTURE
	HCMERR		;BOARD PICTURE
	HDPP1F		;PDP-11 FLAGS 1 AND 0
	HCMERR		;GAME LINE
	HDPSPD		;CHEOPS SPEED CONTROL 
	HDPSTC		;STATA AND STATB AS 32 BIT REGISTER
	HCMERR		;PRINCIPLE VARIATION
HDPCVL==.-HDRGCT


HDPSTM:	MOVE C,(A)	;DEPOSIT IN SIDE-TO-MOVE
	DPB C,[160100,,HSVFLA+1]
	PUSH P,A
	PUSHJ P,HDPST1
	POP P,A
	JRST HDPXIT

HDPST1:	PUSHJ P,HRESSV	;DO RESTORE AND SAVE IN ORDER TO GET IT INTO HARDWARE
	POPJ P,		;STM, SO IT WILL BE THERE WHILE SITTING IN TTY WAIT

HDPFLW:	MOVE C,(A)	;DEPOSIT IN SAVED FLAG WORDS
	MOVEM C,HSVFLA(B)
	JRST HDPXIT

HDPSTA:	MOVEI B,HODSTA	;DEPOSIT IN STATA
	JRST HDPOD	;CHANGE TO APPROPRIATE ODEST

HDPSTB:	MOVEI B,HODSTB	;DEPOSIT IN STATB
	JRST HDPOD

HDPSTC:	MOVEI B,HODSTA	;DEPOSIT IN STATA AND STATB AS A 32 BIT REGISTER
	EWOD
	AOS A
	MOVEI B,HODSTB
	EWOD
	SOJA A,HDPXIT

HDPUAR:	MOVEI B,HODUAR	;DEPOSIT IN UAR
	JRST HDPOD

HDPUDR:	MOVEI B,HODUDR	;DEPOSIT IN UDR
	JRST HDPOD

HDPORG:	MOVE C,(A)	;DEPOSIT IN O-REG
	MOVEM C,HSVORG	;PUT THAT IN SAVED O-REG
	JRST HDPXIT

HDPFL:	MOVEI B,HODFC	;DEPOSIT IN FLAG-CELL
	JRST HDPOD

HDPNFL:	MOVEI B,HODNFC	;DEPOSIT IN NEXT-FLAG-CELL
	JRST HDPOD

HDPUSP:	SKIPL HUSPSF	;DEPOSIT IN U-STACK POINTER
	ESUSP		;SAVE U-STACK POINTER IF NOT ALREADY
	MOVE C,(A)
	MOVEM C,HUSPSV
	JRST HDPXIT

HDPSIR:	EWSIR		;DEPOSIT IN SIR
	JRST HDPXIT

HDPSR:	EWSR		;DEPOSIT IN SR
	JRST HDPXIT

HDPPR:	EWPR		;DEPOSIT IN PR
	JRST HDPXIT


HDPIR:	MOVE C,(A)	;DEPOSIT IN IR
	MOVEM C,HSVIR
	MOVE C,1(A)
	MOVEM C,HSVIR+1
	MOVE D,2(A)
	MOVEM D,HSVIR+2
	MOVE TT,3(A)
	MOVEM TT,HSVIR+3
	TRNN C,H1AMOP
	JRST HDPXIT
	MOVEM D,HSVIRA	;DEPOSITING ARRAY OP, SO PUT IT IN IRA C AND IRA D
	MOVEM TT,HSVIRA+1
	JRST HDPXIT

HDPIRA:	MOVE C,(A)		;DEPOSIT IN SAVED IRA
	MOVEM C,HSVIRA
	MOVE C,1(A)
	MOVEM C,HSVIRA+1
	JRST HDPXIT

HG:	CLEARM HSVIR		;"GO" COMMAND
	CLEARM HSVIR+1		;NO-OP OUT IR
	CLEARM HSVIR+2
	CLEARM HSVIR+3
	MOVEI A,HCNUM
HDPNAF:	MOVE C,(A)		;DEPOSIT IN NAF
	MOVEM C,HSVNAF
	JRST HDPXIT

HDPPC:	MOVE C,(A)		;DEPOSIT IN PC
	MOVEM C,HSVPC
	JRST HDPXIT

HDPSC:	MOVE C,(A)		;DEPOSIT IN STEP COUNTER
	MOVEM C,HSTEPS
	JRST HDPXIT

HDPLST:	MOVE C,(A)		;DEPOSIT IN LAST TEST POSITION USED
	MOVEM C,HTPLST
	JRST HDPXIT

HDPSA:	MOVE C,(A)		;DEPOSIT IN UCODE STARTING ADR
	MOVEM C,HUSADR
	JRST HDPXIT

HDPSTR:	MOVEI B,HODSTR		;DEPOSIT IN STAR (UNIBUS STATUS REGISTER)
	EWOD
	JRST HDPXIT

HDPDBL:	MOVE C,(A)		;DEPOSIT IN DOORBELL REGISTER
	DPB C,[%HDBL UNIFA]
	JRST HDPXIT

HDPDB1:	DPB A,[%HDBL UNIFA]	;DEPOSIT IN DOORBELL FROM OCM
	POPJ P,

HDPP1F:	MOVE C,(A)		;DEPOSIT IN PDP11 FLAGS 1 AND 0
	DPB C,[100200,,HSVFLA+3]
	JRST HDPXIT

HDPSPD:	MOVE C,(A)		;DEPOSIT IN SPEED CONTROL
	MOVEM C,HCHSPD
	JRST HDPXIT

HDPSET:	MOVEI B,HRCMO		;DEPOSIT IN "RESET" REGISTER
	MOVEM B,HDPRC
HDPSE1:	MOVEI B,HDPV
	MOVE A,HDPRC
	CAILE A,HRRDMP
	JRST HDPXIT
IFN HRCME-HRCMO-CHECML,[
	CAIG A,HRCME
	CAIGE A,HRCMO+CHECML
	JRST .+2
	JRST HDPSE2		;DONT TRY TO RESET NON-EXISTANT CONTROL MEM
]
	PUSHJ P,HREGDD
HDPSE2:	AOS HDPRC
	JRST HDPSE1

HDPRC:	0

HTIV:	HCMERR	;TOO LOW
	HTIC	;CONTROL MEM
	HCMERR	;DATA PDL
	HCMERR	;U STACK
	HCMERR	;AC S AND AAC S
	HCMERR	;PIECE TYPE LIST
	HCMERR	;SQUARE LIST
	HCMERR	;PIECE LOC LIST
	HCMERR	;PIECE VAL LIST
	HCMERR	;PIECE-EXISTS "MEMORY"
	HCMERR	;RAID REGISTERS
	HTIRG	;RANDOM REGISTERS, ETC
	HCMERR	;A-SOURCE S
	HCMERR	;ODEST S
	HCMERR	;TOO HIGH

HTIC:	ERCMEM	;GET CURRENT CONTENTS FOR DEFAULTING
	PUSH P,B
	PUSHJ P,HTIUI	;TYPE IN U-INST
	POP P,B
HDPC:	EWCMEM	;DEPOSIT IN C MEM
	PUSH P,A
	MOVEI A,HDPCTM
	ERCMEM		;READ IT BACK TO CHECK
	POP P,A
REPEAT 4,[
	MOVE ZR,HDPCTM+.RPCNT
	CAME ZR,.RPCNT(A)
	.VALUE		;DEPOSIT TO CONTROL MEM LOST
]
HDPXIT:	SOS HDPFLG	;INDICATE DEPOSITING DONE
	POPJ P,

HDPCTM:	0
	0
	0
	0


HTIRG:	CAIL B,HTICVL
	JRST HCMERR
	JRST @HTRGCT(B)

HTRGCT:	HCMERR		;FLAGA
	HCMERR		;FLAGB
	HCMERR		;FLAGC
	HCMERR		;FLAGD
	HCMERR		;STATA
	HCMERR		;STATB
	HCMERR		;UAR
	HCMERR		;UDR
	HCMERR		;O-REG
	HCMERR		;FLAGCELL
	HCMERR		;NEXT-FLAGCELL
	HCMERR		;U-STACK POINTER
	HCMERR		;SIR
	HCMERR		;SR
	HCMERR		;PR
	HTIIR		;SAVED IR
	HCMERR		;SAVED IRA
	HCMERR		;SAVED NAF
	HCMERR		;SAVED PC	
	HCMERR		;STEP COUNTER
	HCMERR		;LAST TEST POSITION
	HCMERR		;UCODE STARTING ADR
	HCMERR		;STAR
	HCMERR		;DOORBELL REGISTER
;ADD NEW REGISTERS TO BE INCLUDED IN DUMP FILES HERE
	HCMERR		;RESET REGISTER
	HCMERR		;NEXT-PIECE OUTPUT OF PIECE SCANNER
	HCMERR		;NEXT-SQUARE OUTPUT OF SQUARE SCANNER
	HCMERR		;PIECE-BUS
	HCMERR		;SQUARE-BUS
	HCMERR		;POUT
	HCMERR		;PIECE-LOC
	HCMERR		;PIECE-VAL
	HCMERR		;PIECE-TYP	
	HCMERR		;FLAGA SYMBOLICALLY
	HCMERR		;FLAGB SYMBOLICALLY
	HCMERR		;FLAGC SYMBOLICALLY
	HCMERR		;FLAGD SYMBOLICALLY
	HCMERR		;NEXT-FLAGA
	HCMERR		;NEXT-FLAGB
	HCMERR		;NEXT-FLAGC
	HCMERR		;NEXT-FLAGD
	HCMERR		;NEXT-FLAGA SYMBOLICALLY
	HCMERR		;NEXT-FLAGB SYMBOLICALLY
	HCMERR		;NEXT-FLAGC SYMBOLICALLY
	HCMERR		;NEXT-FLAGD SYMBOLICALLY
  REPEAT 20,HCMERR	;FLAGWORD QUARTERS BOTH WAYS
  REPEAT 20,HCMERR	;NEXT FLAGWORD QUARTERS BOTH WAYS
	HCMERR		;SIDE-TO-MOVE
	HCMERR		;SQUARE LINES PICTURE
	HCMERR		;BOARD PICTURE
	HCMERR		;PDP11 FLAGS 1 AND 0
	HCMERR		;GAME LINE
	HCMERR		;CHEOPS SPEED CONTROL
	HCMERR		;STATA AND STATB AS 32 BIT REGISTER
HTICVL==.-HTRGCT

HTIIR:	MOVEI A,HSVIR	;TYPE INTO IR
	PUSHJ P,HTIUI
	MOVE C,HSVIR+1
	TRNN C,H1AMOP
	JRST HDPXIT
	MOVE C,HSVIR+2
	MOVEM C,HSVIRA
	MOVE C,HSVIR+3
	MOVEM C,HSVIRA+1
	JRST HDPXIT

HPAD:	PUSHJ P,HPUSM	;PRINT USER SYMBOL IF ANY .. 
	MOVEI TT,HGSYMT	;PRINT SYMBOL IF ONE FOUND EXACTLY EQUAL
HPASY1:	CAIL TT,HGSYME
	JRST HPASYX
	CAMN A,1(TT)
	JRST HPASYF	;FOUND IT
	ADDI TT,2
	JRST HPASY1

HPASYF:	HSOUT @(TT)	;SYMBOL FOUND, PRINT IT
	POPJ P,

HPASYX:	MOVEI B,HPAV
	PUSHJ P,HREGDE
	POPJ P,

HPAV:	HPATL	;TOO LOW, JUST PRINT NUMBER
	HPAC	;CONTROL MEM
	HPAP	;DATA PDL
	HPAU	;U STACK
	HPAAC	;AC S AND AAC S
	HPAPT	;PIECE TYPE LIST
	HPAS	;SQUARE LIST
	HPAPL	;PIECE LOC LIST
	HPAPV	;PIECE VAL LIST
	HPAPXM	;PIECE-EXISTS "MEMORY"
	HPARDR	;RAID REGISTERS
	HPANUL	;RANDOM REGISTERS, ETC
	HPAAS	;A-SOURCE S
	HPAOD	;ODEST S
	HPANUL	;TOO HIGH

HPARDR:	HSOUT [ASCIZ /RAIDR+/]	;RAID REGISTERS
	MOVEI C,1
	EOCTP
	POPJ P,

HPANUL:	ADD B,HRGDEF	;GET BACK FULL ADR
	HSOUT [ASCIZ /REGADR /]
HPATL:	MOVEI C,6
	EOCTP
	POPJ P,



HPAC:	MOVEI C,4	;CONTROL MEM
	EOCTP
	HSOUT [ASCIZ /@C/]
	POPJ P,

HPAP:	MOVEI C,4	;DATA PDL
	EOCTP
	HSOUT [ASCIZ /@P/]
	POPJ P,

HPAU:	MOVEI C,3	;U STACK
	EOCTP
	HSOUT [ASCIZ /@U/]
	POPJ P,

HPAAC:	MOVEI C,2	;AC S AND AAC S
	EOCTP
	HSOUT [ASCIZ /@A/]
	POPJ P,

HPAS:	MOVEI C,2	;SQUARE LIST
	EOCTP
	HSOUT [ASCIZ /@S/]
	POPJ P,

HPAPL:	MOVEI C,2	;PIECE LOC
	EOCTP
	HSOUT [ASCIZ /@L/]
	POPJ P,

HPAPV:	MOVEI C,2	;PIECE VAL
	EOCTP
	HSOUT [ASCIZ /@V/]
	POPJ P,

HPAPT:	MOVEI C,2	;PIECE TYPE
	EOCTP
	HSOUT [ASCIZ /@T/]
	POPJ P,

HPAAS:	MOVEI C,2	;A SOURCE
	EOCTP
	HSOUT [ASCIZ /@R/]
	POPJ P,

HPAOD:	MOVEI C,2	;ODEST
	EOCTP
	HSOUT [ASCIZ /@D/]
	POPJ P,

HPAPXM:	MOVEI C,2	;PIECE-EXISTS "MEMORY"
	EOCTP
	HSOUT [ASCIZ /@X/]
	POPJ P,


;THE FIELD SYMBOL TABLE IS USED TO ASSOCIATE BIT FIELDS IN THE MICRO-INSTRUCTION
; WITH SYMBOLIC NAMES ON BOTH INPUT AND OUTPUT.  EACH ENTRY IN THE TABLE
; ALSO CONTAINS "CONTEXTS".  THESE MAY BE NULL (IN WHICH CASE THE ENTRY IS
; ALWAYS VALID), OR MAY SPECIFY THAT CERTAIN FIELDS (IN THE MICRO-INSTRUCTION
; BEING PRINTED OR INPUTTED) MUST HAVE CERTAIN VALUES FOR THIS ENTRY TO BE
; VALID.  FOR CHEOPS, THERE ARE TWO "CONTEXT FIELDS":
;   A) THE OP CODE BIT (ARRAY OR ALU OP)
;   B) THE TWO "INSTRUCTION TYPE" BITS IN WD2 OF THE ALU INSTRUCTION.
; THUS THE "A" CONTEXT IS TWO BITS HAVING THREE STATES: 
;	ALWAYS VALID, VALID IN ALU-INST, AND VALID IN ARRAY-INST
; THE "B" CONTEXT IS 3 BITS HAVING 5 STATES:
;	ALWAYS VALID, VALID IN NON-IMMEDIATE-ALU, IN IMMEDIATE-ALU,
;	IN PDL-SOURCE ALU, OR IN PDL-DEST ALU.
; ON BOTH INPUT AND OUTPUT, SYMBOLS NOT HAVING THE APPROPRIATE CONTEXT ARE IGNORED.

;   ON INPUT, THE ORDER OF THE SYMBOLS IN THE TABLE IS IMPORTANT,
;SINCE THIS DEFINES THE BASIC PROMPT SEQUENCE.  
;   THE INPUT OPERATION PROCEEDS AS FOLLOWS:
;	1) FIRST, THE DEFAULT IS GENERATED.  THIS IS THE CURRENT CONTENTS
;		OF THE OPEN REGISTER, IF ANY, OTHERWISE 0.
;	2) A POINTER IS INITIALIZED TO THE BEGINNING OF THE FIELD SYMBOL TABLE.
;	3) THE CONTEXT OF THIS SYMBOL IS CHECKED.  IF IT LOSES GO TO STEP 6.
;	4) THE SYMBOL IS TYPED OUT AS A PROMPT AND INPUT AWAITED.
;	5) IF THE INPUT IS NUMERIC, IT IS DEPOSITED IN THE FIELD OF THE AS
;	   MICRO-INSTRUCTION AS DEFINED BY THE SYMBOL.
;	   IF THE INPUT IS SYMBOLIC, A SEARCH IS MADE FOR A MATCHING SYMBOL
;	   IN THE AUX SYMBOL TABLE OF A VALID SYMBOL.  IF FOUND, THAT VALUE IS
;	   SUBSTITUTED AND THE PROMPT SEQUENCE PICKS UP FROM THERE.
;	   IF SEARCHING ON FROM THE ORIGINAL POINT DOESNT WIN,
;	   AN ATTEMPT TO WIN BY RESETING THE POINTER TO THE ROOT OF THE
;	   FIELD SYMBOL TABLE IS MADE BEFORE GIVING UP.
;	6) THE POINTER IS ADVANCED TO THE NEXT SYMBOL AND THE PROCESS REPEATED.
;	   WHEN ALL SYMBOLS WITH THE APPROPRIATE CONTEXT ARE EXHAUSTED,
;	   THE PROCESS TERMINATES.
;   THIS PROCESS CAN BE MODIFIED IF A VALID SYMBOL WITH A "DISPATCH-ON-INPUT"
;	BIT IS ENCOUNTERED.  IN THAT CASE, CONTROL IS IMMEDIATELY TRANSFERRED
;	TO THE LOCATION GIVEN BY THE SYMBOL.

;ON OUTPUT, A MASK WHOSE LENGTH IS EQUAL TO THE LENGTH OF THE MICRO-INSTRUCTION
;   (64 BITS FOR CHEOPS) IS INITIALIZED TO -1.  THIS MASK CONTAINS ONES IN THOSE
;   BIT POSITIONS THAT HAVE NOT BEEN "PRINTED" YET.
; THE OUTPUT OPERATION THEN PROCEEDS AS FOLLOWS:
;	1) A POINTER IS INITIALIZED TO THE BEGINNING OF THE FIELD SYMBOL TABLE.
;	2) THE CONTEXT OF THIS SYMBOL IS CHECKED. IF IT LOSES, GO TO STEP 7.
;	3) THE BYTE NAMED BY THE SYMBOL IS LOADED FROM THE MASK.
;	   IF THIS RESULT IS NOT ALL ONES, THE FIELD IS A LOSER (HAVING ALREADY
;	   BEEN PARTIALLY (OR COMPLETELY) PRINTED. GO TO STEP 7.
;	4) A BIT IS CHECKED TO SEE IF THIS FIELD PRINTS OUT "SYMBOLICALLY".
;	   IF SO, THE ASCIZ STRING FOUND AT THE NTH (VALUE OF FIELD IN U-INST
;	   TO BE PRINTED) IS PRINTED. GO TO STEP 6.
;	5) PRINT OUT THE NAME OF THE FIELD, FOLLOWED BY ITS VALUE AS
;	   EXTRACTED FROM THE MICRO-INST TO BE PRINTED.
;	6) ZERO THE BITS CORRESPONDING TO THE FIELD IN THE MASK
;	7) CONTINUE UNTIL ALL BITS HAVE BEEN PRINTED.  IF RUN OUT OF
;	   FIELD SYMBOL TABLE FIRST, ITS A SEMI-ERROR. PRINT BIT NUMBERS
;	   OF ANY  ONE BITS IN THE MICRO-INST TO BE PRINTED WHICH ARE MASKED
;	   ONES BY THE MASK.


;FIELD SYMBOL TABLE
;WD0 (LH) FLAGS AND CONTEXT INDICATORS
HSYIV==400000,,		;  INPUT VALID (1)
HSYOV==200000,,		;  OUTPUT VALID (1)
HSYAT==100000,,		;  AUX SYMTAB FOR SYMBOLIC TYPEIN/OUT OF THIS FIELD EXISTS.
			;    WD2 IS POINTER TO IT.
HSYACN==30000,,		;  CONTEXT A (2)
 HSYACA==10000,,	;    VALID IN ARRAY INSTRUCTION
 HSYACL==20000,,	;    VALID IN ALU INSTRUCTION
HSYBCN==7000,,		;  CONTEXT B (3)
 HSYBCR==1000,,		;    VALID IN NON-IMMEDIATE ALU INSTRUCTION
 HSYBCI==2000,,		;    VALID IN IMMEDIATE ALU INSTRUCTION
 HSYBCS==3000,,		;    VALID IN PDL-SRC ALU INSTRUCTION
 HSYBCD==4000,,		;    VALID IN PDL-DEST ALU INSTRUCTION
 HSYBCO==5000,,		;    VALID EXCEPT IN PDL-DEST (FOR ODEST)
HOZNUL==400,,		;  IF FIELD ZERO, GENERATE NULL TYPOUT ON OUTPUT
;    (RH) BYTE DEF <SIZE*1000>+OFFSET
;WD1 POINTER TO ASCIZ
;WD2 (IF AUX SYMTAB) POINTER TO AUX SYMTAB
;   AN AUX SYMTAB IS CONSISTS OF ONE WORD PER ENTRY, WHICH IS A
;     POINTER TO AN ASCIZ STRING.  THE SYMTAB MUST BE 2**<LENGTH OF FIELD>
;     ENTRIES LONG, AND EACH ENTRY REPRESENTS THE VALUE GIVEN BY ITS
;     POSITION IN THE TABLE.
HIFST:
	HSYIV+HSYOV+1*1000+31.		;OP CODE BIT
	[ASCIZ /OP/]
	HSYIV+HSYACL+2.*1000+32.		;ASDEST TYPE (INPUT ALU ONLY)
	[ASCIZ /ASD-TYP/]
;WD2 ALU
	HSYIV+HSYOV+HSYACL+HSYBCR+6*1000+42.	;A-SOURCE HIGH
	[ASCIZ /A-SRC/]
	HSYIV+HSYOV+HSYACL+HSYBCI+8*1000+40.	;IMMED DATA
	[ASCIZ /IMM-DAT/]
	HSYIV+HSYOV+HSYACL+HSYBCS+8*1000+40.	;PDL SRC
	[ASCIZ /PS/]
	HSYIV+HSYOV+HSYACL+HSYBCD+8*1000+40.	;PDL DEST
	[ASCIZ /PD/]
	HSYIV+HSYOV+HSYACL+HSYBCO+6*1000+34.+HOZNUL	;ODEST
	[ASCIZ /OD/]
	HSYIV+HSYOV+HSYACL+HSYBCD+6*1000+34.	;A-SOURCE LOW
	[ASCIZ /A-SRC/]
;WD3 ALU
	HSYIV+HSYOV+HSYACL+4*1000+48.		;B-BUS
	[ASCIZ /B-BUS/]
	HSYIV+HSYOV+HSYACL+5*1000+52.+HSYAT	;ALU OP
	[ASCIZ /ALU/]
	HASTAL					;AUX SYMBOL TABLE FOR ALU OPS
	HSYIV+HSYOV+HSYACL+1*1000+57.+HOZNUL	;CRY
	[ASCIZ /CRY/]
	HSYIV+HSYOV+HSYACL+3*1000+58.+HOZNUL	;O-BUS SELECTOR
	[ASCIZ /O-BUS/]

HIFAST:	;WD2 ARRAY-OP
	HSYIV+HSYOV+HSYACA+1*1000+47.		;ARRAY-SELECT BIT
	[ASCIZ /ARY/]
	HSYIV+HSYOV+HSYACA+1*1000+46.		;CAPT/MOVE BIT
	[ASCIZ /CAPT/]
	HSYIV+HSYOV+HSYACA+1*1000+45.		;ALLS
	[ASCIZ /ALLS/]
	HSYIV+HSYOV+HSYACA+1*1000+44.		;NOBLE-ENABLE BIT
	[ASCIZ /N-ENB/]
	HSYIV+HSYOV+HSYACA+1*1000+43.		;PAWN-ENABLE BIT
	[ASCIZ /P-ENB/]
	HSYIV+HSYOV+HSYACA+1*1000+42.		;PIECE-EXISTS BIT
	[ASCIZ /PEX/]
	HSYIV+HSYOV+HSYACA+1*1000+41.+HOZNUL	;WRITE PIECE-EXISTS REGISTER
	[ASCIZ /WPEX/]
	HSYIV+HSYOV+HSYACA+1*1000+40.+HOZNUL	;WRITE SQUARE REGISTER
	[ASCIZ /WSR/]
	HSYIV+HSYOV+HSYACA+1*1000+39.+HOZNUL	;WRITE SQUARE INPUT REGISTER
	[ASCIZ /WSIR/]
	HSYIV+HSYOV+HSYACA+1*1000+38.+HOZNUL	;WRITE PIECE REGISTER
	[ASCIZ /WPR/]
	HSYIV+HSYOV+HSYACA+1*1000+37.+HOZNUL	;WRITE MOVE
	[ASCIZ /WMOV/]
	HSYIV+HSYOV+HSYACA+1*1000+36.		;PDL-SOURCE BIT
	[ASCIZ /PDL-S/]
	HSYIV+HSYOV+HSYACA+1*1000+35.+HOZNUL	;WRITE DATA (IN OPPOSITE PLACE FROM
	[ASCIZ /WDAT/]				; SPECD BY PDL-SOURCE
	HSYIV+HSYOV+HSYACA+3*1000+32.		;ARRAY OP AC
	[ASCIZ /AC/]
;WD3 ARRAY-OP
	HSYIV+HSYOV+HSYACA+3*1000+58.		;PS-BUS SELECTOR
	[ASCIZ /PS-B/]
	HSYIV+HSYOV+HSYACA+1*1000+57.		;LAST-PIECE SELECTOR
	[ASCIZ /LPC/]
	HSYIV+HSYOV+HSYACA+3*1000+54.		;PIECE-BUS SELECTOR
	[ASCIZ /P-B/]
	HSYIV+HSYOV+HSYACA+1*1000+53.		;PIECE-REGISTER SELECTOR
	[ASCIZ /PR-S/]
	HSYIV+HSYOV+HSYACA+1*1000+52.		;LAST-SQUARE SELECTOR
	[ASCIZ /LSQ/]
	HSYIV+HSYOV+HSYACA+2*1000+50.		;SQUARE-BUS SELECTOR
	[ASCIZ /SQ-B/]
	HSYIV+HSYOV+HSYACA+1*1000+49.		;SQUARE-REGISTER SELECTOR
	[ASCIZ /SR-S/]
	HSYIV+HSYOV+HSYACA+1*1000+48.		;SQUARE-INPUT-REGISTER SELECTOR
	[ASCIZ /SIR-S/]
LHAST==.-HIFAST			;LENGTH OF ARRAY INST WD 2 AND 3 PART

;WD0 ALL INSTRUCTIONS
	HSYIV+HSYOV+1*1000+15.+HSYAT		;INHIBIT-WRITE (ON SUCCESSFUL XFER)
	[ASCIZ /INH-W/]
	HASTI
	HSYIV+HSYOV+4*1000+11.+HOZNUL		;COND FIELD
	[ASCIZ /COND/]
	HSYIV+HSYOV+11.*1000+0			;JUMP ADDRESS
	[ASCIZ /JMP/]
;WD1 ALL INSTRUCTIONS
	HSYIV+HSYOV+1*1000+30.+HSYAT		;STATISTICS BIT
	[ASCIZ /S/]
	HASTS
	HSYIV+HSYOV+1*1000+29.+HSYAT		;PUSHJ BIT
	[ASCIZ /P/]
	HASTP
	HSYIV+HSYOV+1*1000+28.+HSYAT		;RETURN BIT
	[ASCIZ /R/]
	HASTR
	HSYIV+HSYOV+5*1000+23.+HOZNUL		;PDL ADDRESS FIELD
	[ASCIZ /PAF/]
	HSYIV+HSYOV+2*1000+21.+HSYAT		;UNIBUS OP
	[ASCIZ /UB/]
	HASTUB
	HSYIV+HSYOV+1*1000+20.+HSYAT		;E-LONG (LONG CLOCK TIMING)
	[ASCIZ /E-L/]
	HASTEL
	HSYIV+HSYOV+4*1000+16.+HOZNUL		;FLAG-CONTROL
	[ASCIZ /FC/]
HIFSTE:
LHFST==HIFSTE-HIFST		;LENGTH OF ENTIRE FIELD SYM TAB

;AUX SYMBOL TABLE FOR ALU OPS
HASTAL:	[ASCIZ /INCB/]
	[ASCIZ /ALU1/]
	[ASCIZ /ALU2/]
	[ASCIZ /ALU3/]
	[ASCIZ /ALU4/]
	[ASCIZ /ALU5/]
	[ASCIZ /SUB/]
	[ASCIZ /ALU7/]
	[ASCIZ /ALU10/]
	[ASCIZ /ADD/]
	[ASCIZ /ALU12/]
	[ASCIZ /ALU13/]
	[ASCIZ /SHFTB/]
	[ASCIZ /ALU15/]
	[ASCIZ /ALU16/]
	[ASCIZ /DECB/]
	[ASCIZ /SETCB/]
	[ASCIZ /ANDCBOTH/]
	[ASCIZ /ANDCB/]
	[ASCIZ /SETZ/]
	[ASCIZ /ORCBOTH/]
	[ASCIZ /SETCA/]
	[ASCIZ /XOR/]
	[ASCIZ /ANDCA/]
	[ASCIZ /ORCB/]
	[ASCIZ /EQV/]
	[ASCIZ /SETA/]
	[ASCIZ /AND/]
	[ASCIZ /SETO/]
	[ASCIZ /ORCA/]
	[ASCIZ /OR/]
	[ASCIZ /SETB/]


HASTI:	0			;AUX SYM TABLE FOR INHIBIT WRITE BIT
	[ASCIZ /INHW/]
HASTS:	0			;AUX SYM TABLE FOR STAT BIT
	[ASCIZ /STAT/]

HASTP:	0			;AUX SYM TABLE FOR P BIT
	[ASCIZ /PUSHJ/]

HASTR:	0			;AUX SYM TABLE FOR R BIT
	[ASCIZ /POPJ/]

HASTUB:	0			;AUX SYM TABLE FOR UNIBUS OP
	[ASCIZ /UBRD/]
	[ASCIZ /UBWR/]
	[ASCIZ /UBIN/]

HASTEL:	0			;AUX SYM TABLE FOR E-LONG
	[ASCIZ /ELNG/]



HTIUI:	CLEARM HTICRF		;POINTER TO INITAL UINST IN A
	MOVEI TT,HIFST		;POINTER TO FIELD SYMBOL TABLE
HTIU3:	MOVE Q,(TT)		;GET FIRST WD OF SYM ENTRY
	TLNN Q,(HSYIV)
	JRST HTIU6		;THAT ONE NOT VALID FOR INPUT
	LDB C,[%H1AMOP 1(A)]	;CHECK A CONTEXT - GET AMOP BIT
	LDB D,[.BP HSYACN Q]	;A CONTEXT OF SYMBOL
	XCT HTACXT(D)
	JRST HTIU6		;LOSES
	LDB C,[%H2LIT 2(A)]	;A CONTEXT OK, CHECK B CONTEXT. GET INST TYPE BITS
	LDB D,[.BP HSYBCN Q]
	XCT HTBCXT(D)
	JRST HTIU6		;B CONTEXT LOSES.
	HSOUT @1(TT)		;TYPE OUT PROMPT
	HSOUT [ASCIZ / /]	;AND SPACE
HTIU5D:	PUSH P,A
	PUSH P,Q
	PUSH P,TT
	PUSHJ P,HGECMA		;INPUT FIELD 
	CLEARM HTICRF
	CAIN A,15
	SETOM HTICRF
	POP P,TT
	POP P,Q
	POP P,A
	SKIPL HCSYL
	JRST HTIU6		;NULL, PROCEED TO NEXT FIELD
	SKIPL HCNUMF
	JRST HTIU5B		;SYMBOL TYPED, LOOK IN AUX SYMTAB S
	MOVE B,HCNUM
HTIU5C:	CAIE TT,HIFST
	JRST HTIU5E
	CLEARM (A)		;DEPOSITING INTO OP FIELD
	CLEARM 1(A)		;SO INITIALIZE WHOLE U-INST
	CLEARM 2(A)
	CLEARM 3(A)
	MOVEI C,H1ELNG		;BUT SET E-LONG AS DEFAULT IF E-LONG BITS ARE SET
	SKIPGE HELFLG
	IORM C,1(A)
	MOVEI C,H1STAT		;LIKEWISE STAT
	SKIPGE HSTFLG
	IORM C,1(A)
HTIU5E:	HRRZ C,(TT)		;GET BYTE DESCRIPTOR
	EDPB
HTIU6:	SKIPGE HTICRF
	JRST HTIUX
	TLNE Q,(HSYAT)
	AOS TT			;SKIP OVER AUX SYMTAB POINTER
	ADDI TT,2
	CAIGE TT,HIFSTE
	JRST HTIU3
HTIUX:	POPJ P,

HTIU5B:	MOVEM TT,HTIU5T		;SAVE IN CASE HAVE TO RETURN HERE
	PUSHJ P,HTISS		;AUX SYMBOL SEARCH. IF FOUND, RETURN VAL IN B
	SKIPGE HCNUMF		; AND HCNUM,  UPDATE TT.
	JRST HTIU5C		;FOUND IT,
	MOVEI TT,HIFST		;TRY AGAIN FROM BEGINNING
	PUSHJ P,HTISS
	SKIPGE HCNUMF
	JRST HTIU5C		;WON THAT TIME
	HSOUT [ASCIZ /??? /]
	MOVE TT,HTIU5T		;RETURN TO INPUTTING ORIG FLD
	JRST HTIU5D

HTIU5T:	0


HTISS:	MOVE Q,(TT)		;SEARCH AUX SYMTAB FOR SYM IN HCBUF
	TLNE Q,(HSYIV)		;PICK UP AT CURRENT FIELD SYMTAB ENTRY IN TT
	TLNN Q,(HSYAT)
	JRST HTISS1		;NOT VALID FOR INPUT OR DOESNT HAVE AUX SYMTAB ANYWAY
	LDB C,[%H1AMOP 1(A)]	;CHECK A CONTEXT - GET AMOP BIT
	LDB D,[.BP HSYACN Q]	;A CONTEXT OF SYMBOL
	XCT HTACXT(D)
	JRST HTISS1		;LOSES
	LDB C,[%H2LIT 2(A)]	;A CONTEXT OK, CHECK B CONTEXT. GET INST TYPE BITS
	LDB D,[.BP HSYBCN Q]
	XCT HTBCXT(D)
	JRST HTISS1		;B CONTEXT LOSES.
	LDB D,[111100,,(TT)]	;BYTE SIZE
	MOVEI B,1
	LSH B,(D)		;GET LENGTH OF AUX SYMTAB
	MOVEM B,HTISSC		;SAVE INITIAL COUNT
	MOVE C,2(TT)		;GET POINTER TO AUX SYMTAB
HTISS4:	MOVE D,(C)		;AUX SYMTAB SEARCH LOOP
	HRLI D,440700
	MOVE R,[440700,,HCBUF]
HTISS3:	ILDB ZR,R		;CHARACTER COMPARISON LOOP
	ILDB I,D
	CAME ZR,I
	JRST HTISS2
	JUMPN ZR,HTISS3
	MOVNS B			;NEGATE REMAINING COUNT
	ADD B,HTISSC		;ADD INITIAL COUNT TO GET FIELD VALUE
	MOVEM B,HCNUM
	CLEARM HCNUM+1
	CLEARM HCNUM+2
	CLEARM HCNUM+3
	SETOM HCNUMF		;INDICATE HCNUM VALID
	POPJ P,			;RETURN VALUE

HTISS2:	AOS C
	SOJG B,HTISS4		;TRY NEXT SYM
HTISS1:	TLNE Q,(HSYAT)		;TRY NEXT FIELD
	AOS TT			;SKIP OVER AUX SYMTAB POINTER
	ADDI TT,2
	CAIGE TT,HIFSTE
	JRST HTISS
	POPJ P,			;OUT OF FIELDS, GIVE UP..

HTISSC:	0			;LENGTH OF AUX SYMTAB

;A CONTEXT TABLE
HTACXT:	SKIPA			;SYM ALWAYS VALID
	SKIPN C			;FLUSH IF ARRAY OP
	SKIPE C			;FLUSH IF ALU OP
	.VALUE

;B CONTEXT TABLE
HTBCXT:	SKIPA			;ALWAYS VALID
	CAIE C,0		;VALID ON NON-IMMED
	CAIE C,1		;VALID ON IMMED
	CAIE C,2		;VALID ON PDL-SRC
	CAIE C,3		;VALID ON PDL-DEST
	CAIN C,3		;VALID EXCEPT ON PDL-DEST
	.VALUE
	.VALUE


HCLN:	PUSHJ P,HGCOM		;ACCEPT "COLON" COMMANDS
	SKIPE HCSYL		;NO SYL
	SKIPGE HCNUMF		;OR NUMBER
	JRST HCMERR		;IS ERR
	MOVE B,HCBUF
	MOVE A,[-LHCLCM,,HCLCMT]
HCLN1:	CAMN B,(A)
	JRST @1(A)
	AOBJN A,.+1
	AOBJN A,HCLN1
	JRST HCMERR

HCLCMT:	ASCIZ /DUMP/	;NOTE!! THESE COMMAND CAN ONLY BE 4 CHRS LONG MAX!!
	HDUMP
	ASCIZ /SDMP/
	HSDMP			;DUMP "STATE" (EVERYTHING EXCEPT CONTROL MEM)
	ASCIZ /LOAD/
	HFLOAD
	ASCIZ /SYML/		;LOAD ONLY SYMBOLS
	HSLOAD
	ASCIZ /TP/		;SET BOARD TO PRESET TEST POSITION
	HTP
	ASCIZ /STEP/		;"SET" STEP #.  DO LAST :TP AGAIN, SET 
	HSETS			; PC TO STARTING ADDR, AND DO ARG STEPS
	ASCIZ /SAVP/		;SAVE CURRENT POSITION OFF SOMEWHERE
	HSAVP
	ASCIZ /RESP/		;GET IT BACK FROM THERE
	HRESP
	ASCIZ /ELNG/		;HACK E-LONG BITS IN CONTROL MEM
	HELNG
	ASCIZ /ZEL/		;ZERO E-LONG BITS IN CONTROL MEM
	HZEL
	ASCIZ /REL/		;REMEMBER WHERE E-LONG BITS ARE, BUT DONT AFFECT THEM
	HREL
	ASCIZ /STAT/		;HACK STAT BITS IN CONTROL MEM
	HSTAT
	ASCIZ /ZST/		;ZERO STAT BITS IN CONTROL MEM
	HZST
	ASCIZ /RST/		;REMEMBER STAT BIT
	HRST
	ASCIZ /HUNT/		;ENTER LOG SEARCH FOR LOSSAGE LOOP
	HHUNT
	ASCIZ /EHNT/		;ENTER LOG SEARCH MODE FOR WHERE E-LONG BITS
	HHUEL			; BITS IN CONTROL MEM HELP
	ASCIZ /FEHU/		;FILE E-LONG HUNT
	HFEHNT
	ASCIZ /CHNT/		;DO "COMPARE" HUNT, SLOW SPEED VS CURRENT SPEED
	HHUCM
	ASCIZ /FCHU/		;FILE COMPARE HUNT. (REINIT EACH TIME FROM
	HFCHNT			; LAST FILE MENTIONNED
	ASCIZ /SSB/		;SET STAT BIT (OF SYM)
	HSSB
	ASCIZ /CSB/		;CLEAR STAT BIT
	HCSB
	ASCIZ /SEL/		;SET E-LONG BIT (OF SYM)
	HSEL
	ASCIZ /CEL/		;CLEAR E-LONG BIT
	HCEL
	ASCIZ /CMF/		;READ COMMAND FILE
	HCMF
	ASCIZ /B/
	HB
	ASCIZ /UB/
	HUB
	ASCIZ /UAB/
	HUAB
	ASCIZ /SYME/
	HSYME
LHCLCM==.-HCLCMT

HSDMP:	TDZA A,A		;DONT DUMP CONTROL MEM
HDUMP:	MOVNI A,1		;DUMP CONTROL MEM
	MOVEM A,HDMPCM
	PUSHJ P,HFRDR
	.OPEN UTYOC,HDUMO
	.VALUE
	MOVNI A,2		;START FILE WITH -2 TO INDICATE NON-ZERO DUMP
	SKIPL HDMPCM
	MOVNI A,5		; OR -5 IF NOT DUMPING CONTROL MEM
	PUSHJ P,HDUMN
	PUSHJ P,HDUCR
	CLEARM HEXPF		;DUMP ENTIRE STATE OF CONS ONTO DISK FILE
	MOVEI A,HRORG
	SKIPL HDMPCM
	MOVEI A,HRCME		;DONT DUMP CONTROL MEM
HDUMP1:	CAIL A,HRCMO+CHECML
	CAIL A,HRCME
	JRST HDUMP2
	MOVEI A,HRCME		;ONLY DUMP EXISTING CONTROL MEM
HDUMP2:	CLEARM HDUMV		;CLEAR VECTOR TO READ INTO
	MOVE T,[HDUMV,,HDUMV+1]
	BLT T,HDUMV+3
	MOVEI T,HDUMV
	MOVEI B,HEXAMV
	MOVEM A,HDUMAD
	PUSHJ P,HREGDC		;EXAMINE REGISTER
	PUSHJ P,HDUMW		;WRITE IT OUT
	MOVE A,HDUMAD
	CAIGE A,HRRDMP
	AOJA A,HDUMP1
	MOVNI A,1
	PUSHJ P,HDUMN		;TERMINATE FILE IN -1
	.CLOSE UTYOC,
	PUSHJ P,HCRR
	POPJ P,

HDMPCM:	0		;-1 -> DUMP CONTROL MEM. ALWAYS DUMP ALL ELSE

HDUMW:	SKIPE HDUMV+3
	JRST HDUMW1		;ALL FOUR WDS NON-ZERO
	SKIPE HDUMV+2
	JRST HDUMW2
	SKIPE HDUMV+1
	JRST HDUMW3
	SKIPN HDUMV
	POPJ P,			;ALL FOUR WDS 0, SO DONT WRITE ANYTHING
	PUSHJ P,HDUMN1
	MOVE A,HDUMV
HDMWX1:	PUSHJ P,HDUMN
HDUCR:	MOVEI A,15		;CR FOR THE END
	PUSHJ P,HDMOCH
	MOVEI A,12
	JRST HDMOCH

HDUMW3:	PUSHJ P,HDUMN1
	MOVE A,HDUMV
	PUSHJ P,HDUMN
	MOVE A,HDUMV+1
	JRST HDMWX1

HDUMW2:	PUSHJ P,HDUMN1
	MOVE A,HDUMV
	PUSHJ P,HDUMN
	MOVE A,HDUMV+1
	PUSHJ P,HDUMN
	MOVE A,HDUMV+2
	JRST HDMWX1

HDUMW1:	PUSHJ P,HDUMN1
	MOVE A,HDUMV
	PUSHJ P,HDUMN
	MOVE A,HDUMV+1
	PUSHJ P,HDUMN
	MOVE A,HDUMV+2
	PUSHJ P,HDUMN
	MOVE A,HDUMV+3
	JRST HDMWX1

HDUMN1:	MOVE A,HDUMAD
HDUMN:	MOVEI B,-20	;SPACE FOR THE END
	HRLM B,(P)
	PUSH P,[HDUMN3]
	JUMPGE A,HDUMN2
	MOVEM A,HDUMNT
	MOVEI A,"-
	PUSHJ P,HDMOCH
	MOVN A,HDUMNT
HDUMN2:	IDIVI A,10
	HRLM B,(P)
	SKIPE A
	PUSHJ P,HDUMN2
HDUMN3:	HLRZ A,(P)
	ADDI A,"0
HDMOCH:	.IOT UTYOC,A
	POPJ P,

HDUMO:	1,,(SIXBIT /DSK/)
HFNAM1:	SIXBIT /CHEOPS/
HFNAM2:	SIXBIT /DMP/
	0

HDUMV:	BLOCK 4			;TEMP TO READ REG ADR INTO
HDUMAD:	0			;CURRENT REG ADR
HDUMNT:	0			;TEM


HCMF:	PUSHJ P,HFRDR		;SET UP COMMAND FILE
	.CALL [	SETZ
		SIXBIT /OPEN/
		5000,,0
		1000,,UTICOM
		[SIXBIT /DSK/]
		HFNAM1
		SETZ HFNAM2]
	JRST HCMERR
	SETOM HTICMF
	POPJ P,

HTICMF:	0		;-1 IN COMMAND FILE READING MODE

HFSTU1:	.CALL [	SETZ
		SIXBIT /OPEN/
		5000,,2
		1000,,UTYIC
		[SIXBIT /DSK/]
		HFNAM1
		SETZ HFNAM2]
	JRST HCMERR
	MOVE A,[440700,,INBUF+INBFSZ]
	MOVEM A,INBUFP
	POPJ P,

HFGQAN:	MOVEI C,HFLDV
HFLO3:	PUSHJ P,INITGW
	POPJ P,
	MOVEM T,(C)
	CAIGE C,HFLDV+3
	AOS C
	JRST HFLO3

HSLOAD:	PUSHJ P,HFRDR
	PUSHJ P,HFSTU1
HSLD1:	PUSHJ P,INITGW
	JRST .-1
	JUMPL T,HSLD2
	MOVEM T,HFLOA		;SAVE REG ADR IN CASE ITS UCODE STARTING ADDRESS
	PUSHJ P,HFGQAN		; (THE ONLY THING WE REALLY LOAD)
	MOVE A,HFLOA
	MOVEI T,HFLDV
	MOVEI B,HDPV
	CAIN A,HRRSA		;SKIP UNLESS UCODE SA
	PUSHJ P,HREGDC
	JRST HSLD1

HSLD2:	AOJE T,HSLOX		;EOF
	AOJE T,HSLD1		;NON-ZERO DUMP
	AOJE T,HSLOSM		;SYMBOLS YEAH!!
	AOJE T,HSLD1		;NON-ZERO DUMP
	AOJE T,HSLD1		;OTHER FLAVOR NON ZERO DUMP
	.VALUE

HSLOX:	.CLOSE UTYIC,
	JRST HFLOX1

HSLOSM:	PUSHJ P,HFLOS0
	JRST HSLD2

HFLOAD:	PUSHJ P,HFRDR		;READ FILE NAMES
HFLOA1:	PUSHJ P,HFSTU1
	SETOM HFLDM		;START OUT IN NORMAL LOAD MODE
	PUSHJ P,HFLISQ	;LOAD TEMP PIECE LIST AND SQUARE LIST ARRAYS FROM HARDWARE
HFLO1:	CLEARM HFLDV
	MOVE C,[HFLDV,,HFLDV+1]
	BLT C,HFLDV+3
	PUSHJ P,INITGW
	JRST .-1
	JUMPL T,HFLO2		;SPECIAL CODE
	MOVEM T,HFLOA		;SAVE REG ADR
	SKIPL A,HFLDM
	PUSHJ P,HFLOZ		;LOADING NON-ZERO DUMP, ZERO STUFF IF NECC
	PUSHJ P,HFGQAN
	PUSHJ P,HFLO4
	JRST HFLO1

HFLO4:	MOVE A,HFLOA		;ACTUALLY SALT IT
HFLO4A:	MOVEI T,HFLDV
	CAIL A,HRSQO		;DO SPECIAL CASE CHECKS FOR SQUARE LIST AND PIECE LIST
	CAIL A,HRSQE		;(FIGURE OUT HOW TO LOAD THESE LATER)
	JRST HFLO4C
	MOVE C,(T)
	MOVEM C,HFISQL-HRSQO(A)
	POPJ P,

HFLO4C:	CAIL A,HRPLO
	CAIL A,HRPLE
	JRST HFLO4D
	MOVE C,(T)
	MOVEM C,HFIPCL-HRPLO(A)
	POPJ P,

HFLO4D:	MOVEI B,HDPV
	PUSHJ P,HREGDC
	POPJ P,

HFLOZ:	MOVE T,HFLOA		;NOW GOING TO LOAD INTO ADR IN HFLOA
	CAML A,T		;A HAS FIRST LOCN TO ZERO IF LESS THAN THAT
	JRST [	AOS T
		MOVEM T,HFLDM	;NOW UP TO HERE
		POPJ P,]
	SKIPLE HFLDM1
	JRST [	CAIL A,HRCMO	;DONT ZERO CONTROL MEM IF HFLDM1 IS +
		CAIL A,HRCME
		JRST HFLOZ1
		AOJA A,HFLOZ]
	SKIPGE HFLDM1
	JRST [	CAIL A,HRPTO	;ORIGIN OF TYPE MEM
		CAIL A,HRRDRE	;END OF RAID REG
		JRST HFLOZ1	;OK, ZERO IT
		AOJA A,HFLOZ]	;IN SQUARE MEM RANGE, DONT.
HFLOZ1:
IFN 4000-CHECML,[
	CAIL A,HRCMO+CHECML
	CAIL A,HRCME
	JRST HFLOZ3
	MOVEI A,HRCME		;DONT TRY TO ZERO NON-EXISTANT CONTROL MEM
	JRST HFLOZ
]
HFLOZ3:	PUSH P,A
	PUSHJ P,HFLO4A
	POP P,A
	AOJA A,HFLOZ

HFLO2:	AOJE T,HFLOX		;-1 TERMS FILE  -- SEE ALSO HSLD2 --
	AOJE T,HFLONZ		;-2 SIGNALS NON-ZERO DUMP
	AOJE T,HFLOSM		;-3 SIGNALS BEG OF SYMBOLS
	AOJE T,HFLNZ1		;-4 SIGNALS NON-ZERO DUMP, BUT LEAVE BOARD, RAID REG
	AOJE T,HFLNZ3		;-5 LIKE -2, BUT DONT ZERO CM SINCE IT WASNT DUMPED
	.VALUE

HFLOX:	MOVEI T,HRRDMP+1
	MOVEM T,HFLOA
	SKIPL A,HFLDM
	PUSHJ P,HFLOZ		;ZERO REST IF NECC
	.CLOSE UTYIC,
	PUSHJ P,HFDISQ		;LOAD HARDWARE FROM TEM SQUARE LIST AND PIECE LIST
	SKIPL HFLDM1
	JRST HFLOX1
	MOVE A,HUSADR		;THIS AN ASSEMBLED FILE? (SORT OF)
	MOVEM A,HCNUM
	PUSHJ P,HG		;SET STARTING ADR
HFLOX1:	PUSHJ P,HCRR
	POPJ P,

HFLNZ1:	SETOM HFLDM1		;LEAVE BOARD, RAID REG
	JRST HFLNZ2

HFLONZ:	TDZA A,A		;CLEAR ALL
HFLNZ3:	MOVEI A,1		;DONT CLEAR CONTROL MEMORY
	MOVEM A,HFLDM1
HFLNZ2:	MOVEI A,HRORG
	MOVEM A,HFLDM		;WHERE UP TO IN NON-ZEROING
	CLEARM HSTEPS		;PROBABLY THE MOST REASONABLE THING ...
	CLEARM HSTFLG		;SIGNAL STATISTICS BIT TABLE INVALID
	CLEARM HBPTIN		;BPTS NOT IN
	CLEARM HELFLG		;ALSO E-LONG TABLE
	CLEARM HTPLDF		;INDICATE TYPE AND VAL NOT LOADED
	JRST HFLO1
	
;SYMBOL TABLE FORMAT:
;IN FILE:
; <OTHER-STUFF> .. -3  <GENERATION #> <NUMBER SYMBOL-LOCS> <SYMBOL-LOCS> SYMBOL-NAME ...
;       SYMBOL TABLE SECTION IS TERMINATED BY ANY - NUMBER.
;IN CORE:
; BEGINS AT HSMTAB, FIRST FREE LOCN IS POINTED TO BY HSMPTR.
;  ONE WD SYMBOL  WHICH HAS GENERATION NUMBER AND NUMBER SYMBOL-LOCS IN LH,
;	DATA POINTER IN RH.
; THE DATA TABLE BEGINS AT HSMDAT, FIRST FREE LOCN IS POINTED TO BY HDTPTR.
;  EACH ENTRY IS POINTED TO BY HSMTAB ENTRY.  FIRST N WDS ARE SYMBOL-LOCS.
;   AFTER THAT STARTING IN THE NEXT WORD IS THE ASCIZ SYMBOL NAME, TAKING AS
;   MANY WORDS AS NECESSARY.

HSMSIZ==2000		;POINTER TABLE SIZE
HDTSIZ==14000		;DATA TABLE SIZE

;LH OF POINTER WORD
%HSMNL==.BP <7700,,>		;NUMBER LOCATIONS
%HSGNN==.BP <77,,>		;GENERATION NUMBER

HFLOSM:	PUSHJ P,HFLOS0
	JRST HFLO2

HFLOS0:	MOVEI A,HSMTAB		;RESET SYMBOL TABLE
	MOVEM A,HSMPTR
	MOVEI A,HSMDAT
	MOVEM A,HDTPTR
	CLEARM HSMDAT		;PHYSICALLY ZERO TO AVOID LOSING ON LOW ORDER BIT
	MOVE A,[HSMDAT,,HSMDAT+1]  ;LOSSAGE, ETC (OF ASCIZ STRING)
	BLT A,HSMDAT+HDTSIZ-1
HFLOS1:	PUSHJ P,INITGW		;LOOP TO LOAD SYMBOL
	JRST .-1
	JUMPL T,CPOPJ		;THRU LOADING SYMBOLS
	HRRZ A,HSMPTR
	CAIL A,HSMTAB+HSMSIZ
	.VALUE			;OVERLOW OF POINTER SPACE
	AOS HSMPTR
	HRRZ B,HDTPTR
	HRL B,T			;PUT IN GENERATION
	PUSHJ P,INITGW
	JRST .-1
	MOVE C,T		;NUMBER SYMBOL-LOCS
	DPB C,[%HSMNL B]
	MOVEM B,(A)
HFLOS2:	JUMPLE C,HFLOS3		;HAVE LOADED ALL SYMBOL-LOCS
	PUSHJ P,INITGW
	JRST .-1
	AOS D,HDTPTR
	CAIL D,HSMDAT+HDTSIZ
	.VALUE			;OVERFLOW OF DATA SPACE
	MOVEM T,-1(D)
	SOJA C,HFLOS2

HFLOS3:	ILDB R,INBUFP		;NOW READ IN SYMBOL NAME.
	CAIN R,3		;FLUSH ANY GARBAGE UP TO SYMBOL CONSTITUENT
	PUSHJ P,NEWBF
	CAIG R,40
	JRST HFLOS3
	MOVE D,HDTPTR
	HRLI D,440700
	JRST HFLOS5

HFLOS4:	ILDB R,INBUFP
	CAIN R,3
	PUSHJ P,NEWBF
	CAILE R,40
HFLOS5:	IDPB R,D		;STORE CHAR
	CAIE R,40
	JRST HFLOS4		;SYMBOL TERM BY SPACE
	MOVEI ZR,0
HFLOS6:	IDPB ZR,D		;TERM ASCIZ STRING
	TLNE D,760000
	JRST HFLOS6
	MOVEI D,1(D)
	CAIL D,HSMDAT+HDTSIZ
	.VALUE			;LOST
	MOVEM D,HDTPTR
	JRST HFLOS1		;THRU WITH THAT SYMBOL

HSMPTR:	0			;SYMBOL TABLE POINTER
HDTPTR:	0			;DATA TABLE POINTER

HFLISQ:	MOVEI A,HFISQL		;LOAD TEMP ARRAY FROM HARDWARE
	MOVEI B,0
HFLIS1:	PUSH P,B
	ERSQL
	MOVE B,(P)
	ADDI A,100
	ERPLOC
	POP P,B
	SUBI A,100
	AOS A
	CAIGE B,77
	AOJA B,HFLIS1
	POPJ P,

HFDISQ:	MOVEI B,0		;FIGURE OUT HOW TO LOAD HARDWARE FROM TEMP ARRAYS
HFDIS3:	SKIPE C,HFISQL(B)	;GET RID OF THE PAIRED ENTRIES
	CAME B,HFIPCL(C)
	JRST HFDIS1		; (THESE WILL BE NO PROBLEM)
	PUSH P,B		;PUSH SQUARE NUMBER
	PUSH P,C		;PUSH PIECE NUMBER
	PUSH P,[HFDIS2]
	CLEARM HFISQL(B)
	CLEARM HFIPCL(C)
HFDIS1:	CAIGE B,77
	AOJA B,HFDIS3
	MOVEI B,0		;NOW PUT IN THE LOOSE PIECE-LIST ENTRIES
	MOVEI A,HFIPCL
HFDIS4:	PUSH P,B
	EWPLOC
	POP P,B
	AOS A
	CAIGE B,77
	AOJA B,HFDIS4
	MOVEI B,0
	MOVEI A,HFISQL		;PUT IN LOOSE SQUARE LIST ENTRIES
HFDIS5:	PUSH P,B
	EWSQL
	POP P,B
	AOS A
	CAIGE B,77
	AOJA B,HFDIS5
	POPJ P,


HFDIS2:	POP P,HFDIST		;ROUTINE TO PUT MATCHED ENTRIES IN (POP PIECE NUMBER)
	POP P,B			;POP SQUARE NUMBER
	MOVEI A,HFDIST
	EWSQL
	POPJ P,

HFDIST:	0			;TEMP
HFISQL:	BLOCK 64.		;TEMP ARRAY FOR SQUARE LIST
HFIPCL:	BLOCK 64.		;TEMP ARRAY FOR PIECE LIST

;ARG IS REG ADR IN A.  PRINT ANY USER SYMBOL THAT MATCHES EXACTLY
HPUSM:	PUSH P,A
	PUSH P,B
	PUSH P,C
	PUSH P,D
	SKIPN B,HSMPTR
	JRST HPUSMX		;NO SYMS
HPUSM1:	CAIG B,HSMTAB
	JRST HPUSMX		;NOT FOUND
	MOVE C,-1(B)
	LDB D,[%HSMNL C]	;GET NUMBER LOCNS
HPUSM2:	JUMPE D,HPUSM3
HPUSM5:	CAMN A,(C)
	SOJA B,HPUSM4		;FOUND IT
	AOS C
	SOJG D,HPUSM5
HPUSM3:	SOJA B,HPUSM1

HPUSM4:	PUSHJ P,HPNTUS		;PRINT USER SYM IN B
	MOVEI A,40
	PUSHJ P,HTYO
HPUSMX:	POP P,D
	POP P,C
	POP P,B
	POP P,A
	POPJ P,

HPNTUS:	MOVEI A,"%		;PRINT GENERATION
	PUSHJ P,HTYO
	LDB A,[%HSGNN (B)]
	ADDI A,"0
	PUSHJ P,HTYO
	HRRZ C,(B)		;PRINT USER SYM, TAKES POINTER TO SYMBOL POINTER TBL
	LDB D,[%HSMNL (B)]	;IN B
	ADD C,D
	HSOUT (C)
	POPJ P,


HTISM:	MOVEM A,HTISMT		;SAVE INPUT ARG (TO ADD IT IN LATER)
	PUSHJ P,HTISC		;READ IN CHAR STRING
	PUSHJ P,HUSEV		;EVALUATE IT
	JRST HCMERR		;NOT FOUND
	MOVE A,HTISMT
	ADD A,(C)		;ADD IN FIRST VALUE WORD
	JRST HVLRET	

HTISC:	CLEARM HIUSGN		;GENERATION NUMBER
	MOVE B,[440700,,HIUSBF]
HTISC6:	PUSHJ P,HTYI		;GET FIRST CHAR
	CAIN A,"%
	JRST HTISC6		;IN CASE GUY TYPES AN EXTRA ONE, FLUSH IT
	CAIN A,">
	JRST [	SETOM HIUSGN	;ALL GENERATIONS
		JRST HTISC4]
	CAIL A,"0
	CAILE A,"9
	JRST HTISC1		;NOT A NUMBER
	SUBI A,"0
	MOVEM A,HIUSGN		;ITS GENERATION NUMBER
HTISC4:	PUSHJ P,HTYI
HTISC1:	CAIN A,177
	JRST HCMERR
	CAIL A,140
	SUBI A,40
	CAIL A,"A
	CAILE A,"Z
	JRST HTISC2
HTISC3:	IDPB A,B
	JRST HTISC4

HTISC2:	CAIL A,"0
	CAILE A,"9
	CAIN A,"-		;MINUS A SYM CONST IN THESE
	JRST HTISC3
	CAIN A,"+		;SO IS +
	JRST HTISC3
	MOVEM A,HTYIUR		;UNRCH THIS CHAR LATER ..
	MOVEI ZR,0
HTISC5:	IDPB ZR,B
	TLNE B,760000
	JRST HTISC5
	POPJ P,

HIUSGN:	0			;GENERATION OF USER SYMBOL READ
HIUSBF:	BLOCK 20		;GETS ASCIZ STRING OF SYMBOL
HTISMT:	0			;TEM

HUSEV:	MOVE B,HSMPTR		;SEARCH USER SYMBOL TABLE FOR SYM IN HIUSGN,HIUSBF
HUSEV1:	CAIG B,HSMTAB		; IF HIUSGN IS -, FIND ALL GENERATIONS
	POPJ P,			;NOT FOUND
	MOVE C,-1(B)
	SKIPGE HIUSGN
	JRST HUSEV3		;GOBBLE ALL
	LDB D,[%HSGNN C]
	CAME D,HIUSGN
	SOJA B,HUSEV1		;WRONG GENERATION
HUSEV3:	LDB D,[%HSMNL C]
	ADD C,D
	MOVEI D,HIUSBF
HUSEV2:	MOVE ZR,(C)
	CAME ZR,(D)
	SOJA B,HUSEV1		;LOSES
	TRNE ZR,177_1		;SKIP ON WINS
	AOJA C,[AOJA D,HUSEV2]
	MOVE C,-1(B)
	AOS (P)
	SOS B		;RETURN SYM POINTER WD IN C
	POPJ P,

HFLDM:	-1			;-1 OR FIRST LOCN TO ZERO IF LESS THAN WHERE LOADING
HFLDM1:	0			;WHEN LOADING NON-ZERO DUMP:
				; 0 -> A FULL NON-ZERO DUMP
				;-1 -> DONT ZERO BOARD MEMORIES OR RAID REG
				; 1 -> DONT ZERO CONTROL MEMORY
HFLOA:	0			;REG ADR LOADING
HFLDV:	BLOCK 4			;TEMP BLOCK


HUSMAP:	MOVE B,HSMPTR		;CALL WITH SYM IN HIUSGN,HIUSBF
HUSMA1:	PUSHJ P,HUSEV1		;CALLS BACK FOR EACH VALUE OF SYM 
	JRST HUSMAX		;WITH VALUE IN B
	PUSH P,B		;FOUND A GENERATION THAT MATCHES
	LDB D,[%HSMNL C]
HUSMA2:	JUMPE D,HUSMA3
	MOVE B,(C)
	PUSH P,C
	PUSH P,D
	PUSHJ P,@-3(P)		;CALL GUY FOR EACH VALUE OF THAT GENERATION
	POP P,D
	POP P,C
	SOS D
	AOJA C,HUSMA2
HUSMA3:	POP P,B
	SKIPGE HIUSGN		;SKIP ON ONE GENERATION, ASSUME ITS UNIQUE
	JRST HUSMA1		;WANT ALL GENERATIONS, SO KEEP LOOKING
HUSMAX:	AOS (P)
	POPJ P,

HFRDR:	MOVE T,[-2,,HFNAM1]		;READ FILE NAMES
	MOVE A,HLASTC
HFRDR1:	MOVE B,[440600,,C]
	MOVEI C,0
HFRDR2:	CAIN A,177
	JRST HCMERR
	CAIE A,12
	CAIN A,15
	JRST HFRDX
	CAIG A,40
	JRST HFRDR3		;TERM
	CAIL A,140
	SUBI A,40		;UPPER-CASIFY
	SUBI A,40		;SIXBIT IFY
	IDPB A,B
	TLNN B,770000
	TLZ B,-1
	PUSHJ P,HTYI
	JRST HFRDR2

HFRDR3:	JUMPE C,HFRDR4
	SKIPGE T
	MOVEM C,(T)
	AOBJP T,.+1
HFRDR4:	PUSHJ P,HTYI
	JRST HFRDR1

HFRDX:	JUMPE C,HFRDX1
	SKIPGE T
	MOVEM C,(T)
HFRDX1:	POPJ P,

INITGW:	MOVEI T,0		;RETURN WORD IN T, CLOBBER R
INITG1:	ILDB R,INBUFP		;SKIP UNLESS ENCOUNTER CR BEFORE NUMBER
	CAIN R,3
	PUSHJ P,NEWBF
	CAIN R,"-
	JRST INIMNS		;HACK HACK
	CAIN R,15
	POPJ P,
	CAIL R,"0
	CAILE R,"9
	JRST INITG1
INITG2:	LSH T,3
	ADDI T,-"0(R)
	ILDB R,INBUFP
	CAIN R,3
	PUSHJ P,NEWBF
	CAIN R,"-
	JRST INIMNS		;HACK HACK
	CAIL R,"0
	CAILE R,"9
	JRST INITG3
	JRST INITG2

INITG3:	CAIE R,"_
	JRST 	[SETOM UTUNRF
		 MOVEM R,UTURCH
		 AOS (P)
		 POPJ P,]
	PUSH P,T
	PUSHJ P,INITGW
	JFCL
	MOVE R,T
	POP P,T
	LSH T,(R)
	AOS (P)
	POPJ P,

INIMNS:	PUSHJ P,INITGW		;HACK (AND I DO MEAN HACK) -
	JFCL
	MOVNS T
	AOS (P)
	POPJ P,

NEWBF:	HRRZ R,INBUFP		;UNSKIPS TWICE, CLOBBERS R
	SKIPGE NEWBEF
	JRST .+3
	CAIE R,INBUF+INBFSZ
	.VALUE
	MOVE R,[-INBFSZ,,INBUF]
	.IOT UTYIC,R
	JUMPL R,[	CAMN R,[-INBFSZ,,INBUF]
			POPJ P,		;NO DATA XFERRED, RETURN IN R -
			HRLI R,3_11.
			MOVEM R,(R)	;ASSURE ^C AT END OF DATA
			SETOM NEWBEF
			JRST .+1]
	MOVE R,[440700,,INBUF]
	MOVEM R,INBUFP
	SOS (P)
	SOS (P)
	SOS (P)
	POPJ P,

INBUFP:	440700,,INBUF+INBFSZ
NEWBEF:	0		;-1 LAST IOT DID NOT XFER FULL AMT OF WDS
UTUNRF:	0		;UNRCH FLAG
UTURCH:	0		;UNRCH CHAR

INBFSZ==100

INBUF:	BLOCK INBFSZ
	3_29.


HSETS:	PUSHJ P,HGCNUM		;"SET" STEP #
	CLEARM HRFFLG		;DONT REINITIALIZE FROM FILE
HSETS1:	PUSH P,HCNUM
	SKIPL HRFFLG
	PUSHJ P,HTP1R		;REDO LAST :TP (AND GIVE RUN COMMAND)
	SKIPGE HRFFLG
	PUSHJ P,HFLOA1		;REINITIALIZE INSTEAD FROM LAST MENTIONED FILE
	POP P,HCNUM
	SETOM HCNUMF
	JRST HCN		;DO THAT MANY STEPS

HFCHNT:	SKIPA A,[-2]		;COMPARE (SPEED) FILE HUNT.  
HFEHNT:	MOVEI A,1		;E-LONG FILE HUNT
	SETOM HRFFLG		;SIGNAL REINIT FROM FILE
	JRST HFHNT1

HHUCM:	SKIPA A,[-2]		;COMPARE (AT DIFFERENT SPEEDS) HUNT MODE
HHUEL:	MOVEI A,1		;E-LONG FLAVOR HUNT MODE
	CLEARM HRFFLG		;SIGNAL REINIT FROM START
HFHNT1:	MOVEM A,HHUNTM
	JRST HHUEL1

HHUNT:	SETOM HHUNTM		;USTEP FLAVOR HUNT MODE
	CLEARM HRFFLG		;REINIT FROM START
HHUEL1:	PUSHJ P,HGCOM		;ENTER LOG SEARCH LOOP
	SKIPE HCSYL
	SKIPL HCNUMF
	JRST HHUNT3		;CONTINUE PREVIOUS HUNT
	MOVE B,HCNUM+1
	LSH B,16.
	IOR B,HCNUM
	MOVEM B,HHUNTV
HHUNT2:	CAILE B,1
	LSH B,-1
	MOVEM B,HHUNTS		;STEP SIZE
HHUNT1:	MOVE A,HHUNTV
	DPB A,[2000,,HCNUM]
	LSH A,-16.
	MOVEM A,HCNUM+1
	SKIPL A,HHUNTM
	JRST HHUEL2		;E-LONG FLAVOR HUNT
	AOJN A,HHUCM1		;XFER ON SPEED COMPARE MODE HUNT
	PUSHJ P,HSETS1
HHUNT3:	PUSHJ P,HCSDPY		;UPDATE DISPLAY
	CLEARM HDPFLG		;HAVENT DONE ANY DEPOSITS SINCE THEN
HHUNT4:	PUSHJ P,HTYI
	MOVE B,HHUNTS
	MOVN C,B
	CAIN A,"*
	 JRST HHUNT1		;GO AGAIN SAME PARAMETERS
	CAIN A,"+
	 JRST [	SKIPG HHUNTM	;IF IN E-LONG HUNT MODE, DONT CHANGE
		ADDM B,HHUNTV	; HHUNTV, SINCE IT REPRESENTS THE TOP OF THE RANGE
		JRST HHUNT2]
	CAIN A,"-
	 JRST [	ADDM C,HHUNTV
		JRST HHUNT2]
	CAIN A,"?
	 JRST HHUNT	;ACCEPT NEW BASE VALUE
	CAIN A,"/
	 JRST [	MOVE B,HHUNTV	;DOUBLE HUNT BASE
		ADDB B,HHUNTV
		JRST HHUNT2]
	CAIN A,">		;DOUBLE STEP SIZE WITHOUT "MOVING"
	 JRST [	LSH B,1
		MOVEM B,HHUNTS
		JRST HHUNT3]
	CAIN A,"<
	 JRST [	CAILE B,1
		LSH B,-1	;HALVE STEP SIZE WITHOUT "MOVING"
		MOVEM B,HHUNTS
		JRST HHUNT3]
	CAIN A,"#
	 JRST [	PUSHJ P,HGCNUM	;SET STEP SIZE
		MOVE B,HCNUM+1
		LSH B,16.
		IOR B,HCNUM
		MOVEM B,HHUNTS
		JRST HHUNT3]		
	CAIN A,40
	 JRST HHUNT4
	MOVEM A,HTYIUR		;UNRCH CHAR AND DROP OUT
	PUSHJ P,HCRR
	CLEARM HHUNTM
	POPJ P,

HHUEL2:	SKIPL HELFLG		;SET ALL E-LONG BITS EXCEPT THOSE IN
	PUSHJ P,HELNG1		;RANGE FROM HHUNTV-HHUNTS TO HHUNTV.
	MOVE TT,HHUNTV		;HOWEVER, LEAVE SET ANY IN THAT RANGE THAT WERE
	SUB TT,HHUNTS		;"ORIGINALLY" SET.  FIRST, SET ALL AND SAVE
	SKIPGE TT		;ONES THAT WERE ORIGINALLY SET IF HAVENT ALREADY.
	MOVEI TT,0
	MOVEI B,0
	MOVEI A,HELNTM
	MOVEI C,H1ELNG
	PUSHJ P,HHUELS		;SET ALL E-LONG BITS UP TO TT
	MOVEI T,HELTBL		;FIND PLACE IN TABLE
HHUEL3:	SKIPGE (T)
	JRST HHUEL4		;REACHED END OF TBL
	CAMLE B,(T)
	AOJA T,HHUEL3
HHUEL4:	CAIGE B,CHECML
	CAML B,HHUNTV
	JRST HHUEL5		;THRU
	ERCMEM
	CAMN B,(T)
	AOJA T,HHUEL6		;SET THAT ONE SINCE IT ORIGINALLY WAS
	ANDCAM C,HELNTM+1
HHUEL8:	EWCMEM
HHUEL7:	AOJA B,HHUEL4

HHUEL6:	IORM C,HELNTM+1
	JRST HHUEL8

HHUEL5:	MOVEI TT,CHECML		;SET THE REST ABOVE THAT
	PUSHJ P,HHUELS
	SKIPL HRFFLG
	PUSHJ P,HTP1R		;RESET POSITION
	SKIPGE HRFFLG
	PUSHJ P,HFLOA1		;RESET FROM FILE INSTEAD
	PUSHJ P,HCP		;PROCEED AND DO SEARCH
	JRST HHUNT3

HHUELS:	CAML B,TT
	POPJ P,
	ERCMEM
	IORM C,1(A)
	EWCMEM
	AOJA B,HHUELS

HHUNTV:	0		;HUNT VALUE
HHUNTS:	0		;HUNT STEP SIZE
HHUNTM:	0		;0 NOT IN HUNT MODE (.NE. 0-> DISPLAY HHUNTS)
			; -1 USTEP FLAVOR HUNT MODE
			; +1 ELNG FLAVOR HUNT MODE
			; -2 SPEED COMPARE HUNT MODE
HRFFLG:	0		;-1 -> REINIT FROM FILE AT HSETS1
			;0 -> REINIT TO START OF SEARCH

HHUCM1:	PUSH P,HCHSPD		;SAVE PREVIOUS SPEED
	MOVEI A,1		;SWITCH TO SLOW SPEED
	MOVEM A,HCHSPD
	PUSHJ P,HSETS1		;DO THAT!
	MOVE A,HSVPC
	MOVEM A,HHUCMT		;SAVE "CORRECT" PC
	POP P,HCHSPD		;RESTORE SPEED
	PUSHJ P,HSETS1
	MOVE A,HHUCMT
	CAME A,HSVPC
	 JRST [	HSOUT [ASCIZ /LOST! CORRECT PC=/]
		MOVE B,HHUCMT
		PUSHJ P,HOCTP
		JRST HHUNT3]
	HSOUT [ASCIZ /OK/]
	JRST HHUNT3

HHUCMT:	0			;"CORRECT" PC AFTER N STEPS

HTP:	PUSHJ P,HGCOM		;LOAD TEST POSITION
	SKIPE HCSYL
	SKIPL HCNUMF
	JRST HCMERR
	MOVE A,HCNUM
	CAIL A,HNTSTP		;NUMBER TEST POSITIONS
	JRST HCMERR
	MOVEM A,HTPLST		;SAVE LAST TEST POSITION USED
HTP1R:	SKIPGE A,HTPLST		;LOAD HTPPCL WITH RIGHT THING
	JRST HTP1R1		;IT ALREADY HAS RIGHT THING
	MOVE A,HTPTAB(A)	;LOAD IT TO POINT TO APPRO TEST POSITION.
	MOVEM A,HTPPCL
HTP1R1:	PUSHJ P,HTP1
HCCMS:	MOVEI A,1		;GIVE CHEOPS COMMAND 1 (INITIATE SEARCH) 
HCCOM:	DPB A,[100200,,HSVFLA+3];WHEN IT GETS STARTED
	POPJ P,

HTP1:	MOVE A,HUSADR		;LOAD CHEOPS WITH BOARD, ETC, SPECIFIED BY
	MOVEM A,HCNUM		; BLOCK STARTING AT CONTENTS OF HTPPCL
.SEE HSVPTB			; USE "CLOSE-COUPLED" MODE
	PUSHJ P,HG		;START AT HUSADR (AND SOS HDPFLG)
	MOVEI A,[0]		;ZERO STATA, STATB
	MOVEI B,HODSTA
	EWOD
	MOVEI B,HODSTB
	EWOD
	MOVEI B,HODSTR		;CLEAR STAR (CLEARING ANY COMPUTATION COMPLETE FLAG)
	EWOD
	MOVEI B,0
HTP1L:	PUSH P,B		;CLEAR OUT AC S AND AAC S FOR REPRODUCABILITY.
	EWAC
	POP P,B
	CAIGE B,17
	AOJA B,HTP1L
	MOVE A,HTPPCL		;INITIALIZE ALPHA
	SUBI A,4
	MOVEI B,1
	EWAC
	MOVE A,HTPPCL		;AND BETA
	SUBI A,3
	MOVEI B,2
	EWAC
	MOVE A,HTPPCL		;MAYBE SET DEPTH
	SUBI A,5
	MOVEI B,1
	SKIPL (A)		;-1 -> NO CHANGE
	EWPDLB			;SET DEPTH
	CLEARM HSTEPS
	CLEARM HSVFLA		;CLEAR FLAGS, PARTICULARLY STM
	MOVE A,[HSVFLA,,HSVFLA+1]
	BLT A,HSVFLA+3
	PUSHJ P,HINPCM		;CLEAR PXM, PIECE LOC. INITIALIZE VAL, TYP
	PUSHJ P,HINSQ		;CLEAR SQUARE LIST
	MOVE A,HTPPCL
	SUBI A,1		;GET POINTER TO BITS AND MODES WD
	LDB B,[170100,,(A)]	;GET STM BIT FROM BITS AND MODES WD
	MOVEM B,HS1TEM
	MOVEI B,20		;BITS AND MODES WD
	EWPDLB			;PUT IN BITS AND MODES WD OF MACHINE
	MOVEI A,HS1TEM
;	SOS A
	PUSHJ P,HDPSTM		;RESTORE SIDE TO MOVE
;	SOS A			;NOW GET POINTER TO FLAGCELL WORD
	MOVE A,HTPPCL
	SUBI A,2
	MOVEI B,HODFC		;PUT THAT IN FLAGCELL
	EWOD
	MOVE A,HTPPCL		;GET PIECE LIST POINTER
	MOVEI C,0		;ADD UP MATERIAL BALANCE
HTPL:	SKIPGE (A)
	JRST HTPLX
	MOVE B,1(A)
	EWPIEC
	MOVE B,(A)		;ADD UP MATERIAL BALANCE
	TRNN B,10
	ADD C,HPNMV(B)
	TRNE B,10
	SUB C,HPNMV(B)
	ADDI A,2
	JRST HTPL

HTPLX:	MOVEM C,HS1TEM		;STORE INITIAL MATERIAL BALANCE IN 
	MOVEI A,HS1TEM		;AC[MATERIAL]
	MOVEI B,3
	EWAC
	POPJ P,

;LOAD CHEOPS COMMAND BLOCK FOR OPERATION IN BUFFERED MODE
;TAKES ARGS IN SAME FORMS AS HTP1
.SEE HSVPTB
HLDPB:	MOVEM A,HTPPCL		;LOAD PARAMETER BLOCK
HBM1:	MOVE B,HTPPCL		;GET ARG BLOCK POINTER
	MOVEI C,CBABL		;ORIGIN OF PARAMETER BLOCK IN CHEOPS BUFFER MEMORY
				; (IN PDP-10 WDS)
	PUSHJ P,HBM2		;DO WORK
	MOVE TT,C
	LSH TT,1		;CONVERT TO 16BIT WDS
	ADDI TT,CBBAS/2		;RELOCATE FOR START OF BUFFER MEM IN UNIBUS ADR SPACE.
				; /2 TO CONVERT BYTES TO WDS
	LSH TT,4		;GET POINTER TO BLOCK JUST LOADED 
	MOVEM TT,HBMEM+5	;MAKE BACKGROUND ARG BLOCK POINTER POINT TO IT
	POPJ P,

HBM2:	MOVE A,C		;ENTER HERE WITH CHEOPS BUFFER ADR IN C,
				; AND PARAMETER BLOCK POINTER IN B.  TRANSFERS PARAMETER
				; BLOCK TO CHEOPS BUFFER MEMORY. DOES NOT START CHEOPS,ETC.
	ADD A,[442000,,HBMEM+1]	;POINTER TO ARG SECTION OF COMMAND BLOCK
	SETZM -1(A)		;CLEAR OUT STATEWORD
	MOVE ZR,-1(B)	;BITS AND MODES WD
	IDPB ZR,A
	MOVE ZR,-5(B)	;DEPTH
	IDPB ZR,A
	MOVE ZR,-4(B)	;INITIAL ALPHA
	IDPB ZR,A
	MOVE ZR,-3(B)	;INITIAL BETA
	IDPB ZR,A
	MOVE ZR,-2(B)	;INITIAL FLAGWORD
	IDPB ZR,A
	MOVE A,C
	ADD A,[242000,,HBMEM+17]	;GET POINTER TO PIECE POSITION SECTION
	MOVE D,B
HBM1L:	SKIPGE TT,(D)	;LOAD PIECES
	JRST HBM1X
	LSH TT,8
	IOR TT,1(D)
	IDPB TT,A
	ADDI D,2
	JRST HBM1L

HBM1X:	MOVEI TT,0
	IDPB TT,A	;STORE 0 TO TERMINATE LIST
	MOVSI TT,-4
	MOVEM TT,HBMEM(C)	;SIGNAL BLOCK HAS ARGS FOR CHEOPS
	POPJ P,


HTPTAB:	HTPOS0		;TWO KINGS EACH ON K1
	HTPOS1		;INITIAL POSITION
	HTPOS2		;WK ON K3 BK ON W'S K5
	HTPOS3		;K S ON K1 WKR ON KR1
	HTPOS4		;K S ON K1 WQR ON QR1
	HTPOS5		;K S ON K1 BKR ON KR1
	HTPOS6		;K S ON K1 BQR ON QR1
	HTPOS7		;WK ON K1, BK ON KB1, WKRP ON KR7
	HTPS10		;WK ON K7, WKBP ON KB7, BK ON K8, BR ON KR2 
			; (TEST PROMOTING MOVE ILLEGAL)
	HTPS11		;WK ON K3, WKP ON K4, BK ON K2, BQP ON Q4.
	HTPS12		;K S ON K1, WKP ON WK2, BQP ON BQ5
	HTPS13		;K S ON K1, WQP ON Q5, BKP ON K2
	HTPS14		;K S ON K1, WKRP ON KR7, BQN ON KN1, BKN ON KR1
			; (TEST PROMOTING CAPTURE)
  HNTSTP==.-HTPTAB

;10 -> WQR OR K MOVED
; 4 -> WKR OR K MOVED
; 2 -> BQR OR K MOVED
; 1 -> BKR OR K MOVED

HFCTAB:	17		;THING TO PUT IN FLAGCELL (RE: CASTLING PRIV AND GHOSTS)
	0		;CASTLING BOTH WAYS FOR BOTH SIDES
	17
	13		;WKR NOT MOVED
	7		;WQR NOT MOVED
	16		;BKR NOT MOVED
	15		;BQR NOT MOVED
	17		;NO CASTLING
	17
	17
	17
	17
	17

	-1		;CHEOPS DEPTH (-1 -> NO CHANGE)
	-20000		;ALPHA
	20000		;BETA
	17		;FLAGCELL WD
	0		;STM
HTPS14:	26		;WKRP
	67		; WKR7
	56		;BKN
	77		; BKR1
	57		;BQN
	76		; BKN1
	50		;BK
	74		; BK1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	17
	0
HTPS12:	20		;WKP
	14		; WK2
	31		;BQP
	33		; BQ5
	50		;BK
	74		; BK1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	17
	0
HTPS13:	21		;WQP
	43		; WQ5
	30		;BKP
	64		; BK2
	50		;BK
	74		; BK1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	17
	0
HTPS10:	40		;WK
	64		; WK7
	22		;WKBP
	65		; WKB7
	50		;BK
	4		; BK8
	52		;BKR
	67		; BKR2
	-1

	-1
	-20000
	20000
	17
	0
HTPS11:	40		;WK
	24		; WK3
	20		;WKP
	34		; WK4
	50		;BK
	64		; BK2
	31		;BQP
	43		; BQ4
	-1

	-1
	-20000
	20000
	7		;WQR NOT MOVED
	0
HTPOS4:	43		;WQR
	0		;WQR1
	50		;BK
	74		; BK1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	16		;BKR NOT MOVED
	0
HTPOS5:	52		;BKR
	77		; BKR1
	50		;BK
	74		; BK1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	15		;BQR NOT MOVED
	0
HTPOS6:	53		;BQR
	70		;BQR1
	50		;BK
	74		; BK1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	17
	0
HTPOS7:	26		;WKRP
	67		; WKR7
	50		;BK
	75		; BKB1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	13		;WKR NOT MOVED
	0
HTPOS3:	42		;WKR
	7		; WKR1
	50		;BK
	74		; BK1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	17
	0
HTPOS0:	50		;BK
	74		; BK1
	40		;WK
	4		; WK1
	-1

	-1
	-20000
	20000
	0		;NO PCS MOVED
	0
HTPOS1:	40		;WK
	4
	41		;WQ
	3
	42		;WKR
	7
	43		;WQR
	0
	44		;WKB
	5
	45		;WQB
	2
	46		;WKN
	6
	47		;WQN
	1
	20		;WKP
	14
	21		;WQP
	13
	22		;WKBP
	15
	23		;WQBP
	12
	24		;WKNP
	16
	25		;WQNP
	11
	26		;WKRP
	17
	27		;WQRP
	10
	50		;BK
	74
	51		;BQ
	73
	52		;BKR
	77
	53		;BQR
	70
	54		;BKB
	75
	55		;BQB
	72
	56		;BKN
	76
	57		;BQN
	71
	30		;BKP
	64
	31		;BQP
	63
	32		;BKBP
	65
	33		;BQBP
	62
	34		;BKNP
	66
	35		;BQNP
	61
	36		;BKRP
	67
	37		;BQRP
	60
	-1

	-1
	-20000
	20000
	17
	0
HTPOS2:	40		;WK
	24		; WK3
	50		;BK
	44		; WK5
	-1


HSAVP:	MOVEI A,HS1TEM		;SAVE CURRENT POSITION
	MOVEI B,0
	MOVEI C,HSVPTB
HSAVP1:	PUSH P,B
	ERSQL
	POP P,B
	SKIPE D,(A)
	CAILE D,77
	JRST HSAVP2
	MOVEM D,(C)	;STORE PIECE
	MOVEM B,1(C)	;STORE SQUARE
	ADDI C,2
HSAVP2:	CAIGE B,77
	AOJA B,HSAVP1
	SETOM (C)	;TERMINATE LIST
;	LDB C,[160100,,HSVFLA+1]	;STM
;	MOVEM C,HSPSTM
	MOVEI A,HSPSTM		;SAVE BITS AND MODES
	MOVEI B,20
	ERPDLB
	MOVEI A,HSPFLW
	MOVEI B,HASFC
	ERAS			;SAVE FLAGWORD
	POPJ P,

HRESP:	MOVEI A,HSVPTB		;RESTORE SAVED POSITION
HLDPOS:	MOVEM A,HTPPCL		;ENTER HERE TO LOAD POSITION FROM OCM, ETC
	SETOM HTPLST
	PUSHJ P,HTP1
	PUSHJ P,HCCMS		;GIVE RUN COMMAND
	POPJ P,

HS1TEM:	0

HSPD:	-1		;CHEOPS DEPTH (-1 -> NO CHANGE)
HSPIA:	-20000		;INITIAL ALPHA
HSPIB:	20000		;INITIAL BETA
HSPFLW:	0		;FLAGCELL WORD
HSPSTM:	0		;BITS AND MODES WD (100000 BIT -> STM)
HSVPTB:	-1		;TAKE SIDE TO MOVE FROM WD BEFORE PIECE LIST BLOCK
	BLOCK 64.*2
	
HINSQ:	MOVEI A,100	;CLEAR SQUARE LIST MEM
	MOVEM A,HINSQT
HINSQ1:	SOSGE B,HINSQT
	POPJ P,
	MOVEI A,[0]
	EWSQL
	JRST HINSQ1

HINPCM:	MOVEI A,100		;CLEAR PXM, INITIALIZE TYP AND VAL
	MOVEM A,HINSQT
HINPC1:	SOSGE B,HINSQT
	JRST [	SETOM HTPLDF	;INDICATE TYP AND VAL LOADED
		POPJ P,]
	MOVEI A,[0]
	EWPXM
	SKIPGE HTPLDF
	JRST HINPC1		;TYP AND VAL ALREADY LOADED
	MOVE B,HINSQT
	MOVEI A,HPNMV(B)
	EWPVAL
	MOVE B,HINSQT
	MOVEI A,HPNMT(B)
	EWPTYP
	JRST HINPC1

HINSQT:	0	

HELNG1:	MOVEI D,HELTBL		;ENTRY WHEN ARG ALREADY IN HCNUM
	MOVEI C,H1ELNG
	JRST HELN2

HZEL:	MOVEI D,HELTBL		;ZERO E-LONG BITS, REMEMBER WHERE THEY WERE
	MOVEI C,H1ELNG
HZST1:	MOVEI ZR,1
	MOVEM ZR,HELSET		;DESIRED STATE OF HELFLG
HREL1:	MOVEI ZR,105
	MOVEM ZR,HCNUM		;FAKE OUT THAT LOSER
	JRST HELN3

HREL:	MOVEI D,HELTBL		;REMEMBER STATE OF E-LONG BITS IN TABLE,
	MOVE C,H1ELNG		; DONT AFFECT THEM
HRST1:	CLEARM HELSET
	JRST HREL1

HELNG:	MOVEI D,HELTBL		;TABLE OF U INST LOCNS THAT HAVE THE "REAL" E LONG
	MOVEI C,H1ELNG		;E LONG BIT IN WD1 OF UINST
HELN1:	PUSH P,D		;D HAS POINTER TO "REAL BIT TABLE"
	PUSH P,C		;C HAS WD1 BIT IN QUESTION
	PUSHJ P,HGCNUM
	POP P,C
	POP P,D
HELN2:	SETOM HELSET		;REMEMBER IN SETTING MODE
HELN3:	MOVEI A,HELNTM		;TEMP BLOCK
	MOVE T,D		;TABLE POINTER
	MOVEI B,0		;CONTROL MEM ADR
	MOVE ZR,HCNUM
	JUMPE ZR,HELNC		;XFER ON CLEAR BITS (IE RESTORE TO ORIG STATE)
	SKIPE -1(D)
	JRST HELA1		;BITS ALREADY REMEMBERED
HELNS1:	ERCMEM			;READ CONTROL MEM LOCN
	TDNE C,HELNTM+1
	JRST HELNS2		;THAT BIT SET, REMEMBER THE FACT
	IORM C,HELNTM+1		;SET IT NOW
	SKIPL HELSET
	JRST HELNS3		;REALLY WANT TO LEAVE IT CLEAR (OR NOT AFFECT IT)
HELNS5:	EWCMEM			;WRITE IT BACK
	PUSH P,A		;SEE IF IT WON
	MOVEI A,HELCKB
	ERCMEM			;READ IT BACK
REPEAT 4,[
	MOVE ZR,HELCKB+.RPCNT
	CAME ZR,HELNTM+.RPCNT
	.VALUE
]	POP P,A
HELNS3:	CAIGE B,CHECML-1
	AOJA B,HELNS1
	SETOM (T)		;SIGNAL END OF TBL
HELAX:	SKIPN B,HELSET
	MOVEI B,2		;REALLY JUST VALIDATING TABLE
	MOVEM B,-1(D)		;SIGNAL TABLE LOADED
	POPJ P,

HELNS2:	CAML T,-2(D)		;IF TABLE NOT FULL
	JRST HELNS4
	MOVEM B,(T)		;REMEMBER THAT ADDRESS
	AOJA T,HELNS4

HELNS4:	SKIPG HELSET
	JRST HELNS3		;LEAVE THAT ONE SET (OR NO CHANGE)
	ANDCAM C,HELNTM+1	;REALLY WANT TO CLEAR IT
	JRST HELNS5

HELA1:	MOVE ZR,HELSET
	JUMPE ZR,CPOPJ		;JUST VALIDATING, AND IT ALREADY IS
HELA2:	ERCMEM			;HAVE ALREADY REMEMBERED WHERE THEY WERE SET
	IORM C,HELNTM+1		;JUST GRONK THEM THE DESIRED WAY
	SKIPL HELSET
	ANDCAM C,HELNTM+1
	EWCMEM
	CAIGE B,CHECML-1
	AOJA B,HELA2
	JRST HELAX

HELNC:	SKIPN -1(D)
	POPJ P,			;NO INFO IN TABLE, SO THEY MUST BE WINNING
HELNC2:	ERCMEM
	CAMN B,(T)
	AOJA T,[IORM C,HELNTM+1		;THAT ONE WANTS TO BE SET
		JRST HELNC3]
	ANDCAM C,HELNTM+1		;WANTS TO BE CLEAR
HELNC3:	EWCMEM
HELNC1:	CAIGE B,CHECML-1
	AOJA B,HELNC2
	CLEARM -1(D)		;SIGNAL TABLE INVALID
	POPJ P,

HELSET:	0	; 1 -> CLEAR BIT, REMEMBER WHERE THEY WERE SET
		;-1 -> SET BIT, REMEMBER WHERE THEY WERE SET
		;0 MAKE TABLE VALID, DONT AFFECT BITS IN C-MEM
		;EVENTUALLY GETS PUT INTO HELFLG, ETC
HELNTM:	0
	0
	0
	0

HELCKB:	0
	0
	0
	0

LHELTB==200		;LENGTH OF TBL TO REMEMBER WHERE E-LONG BITS WERE
	HELTBL+LHELTB-1
HELFLG:	0		;-1 E-LONG BITS ARE SET AND HELTBL REMEMBERS WHERE THEY WERE
			;1 E-LONG BITS CLEAR, AND HELTBL REMEMBERS WHERE THEY WERE
			;2 E-LONG BITS UNAFFECTED, AND HELTBL REMEMBERS " "  "
HELTBL:	BLOCK LHELTB

HSTAT:	MOVEI C,H1STAT	;SET OR CLEAR STATISTICS BITS.
	MOVEI D,HSTTBL
	JRST HELN1

HSTAT1:	MOVEI C,H1STAT	;INTERNAL ENTRY WITH COMMAND ALREADY IN HCNUM
	MOVEI D,HSTTBL
	JRST HELN2

HZST:	MOVEI C,H1STAT	;ZERO STAT BITS
	MOVEI D,HSTTBL
	JRST HZST1

HRST:	MOVEI C,H1STAT	;REMEMBER STAT BITS
	MOVEI D,HSTTBL
	JRST HRST1

LHSTTB==200		;LENGTH OF TBL TO REMEMBER WHERE STAT BITS WERE
	HSTTBL+LHSTTB-1
HSTFLG:	0		;-1 STAT BITS ARE SET AND HSTTBL REMEMBERS WHERE THEY WERE
			;1 STAT BITS CLEAR, AND HSTTBL REMEBERS WHERE THEY WERE
HSTTBL:	BLOCK LHSTTB    ; IF HSTFLG =1, HBPTIN SAYS WHETHER BPTS ARE IN



HSEL:	SETOM HELSET		;SET E-LONG
HCEL1:	MOVEI C,H1ELNG
	JRST HSSB1

HCEL:	MOVEI C,1		;CLEAR E-LONG
	MOVEM C,HELSET
	JRST HCEL1

HCSB:	MOVEI C,1		;CLEAR STAT
	MOVEM C,HELSET
	JRST HCSB1

HSSB:	SETOM HELSET		;SET STAT
HCSB1:	MOVEI C,H1STAT
HSSB1:	MOVEM C,HSSBTM
	PUSHJ P,HTISC		;TYI CHEOPS SYM
	PUSHJ P,HUSEV		;LOOK IT UP
	JRST HCMERR		;LOSES
	PUSHJ P,HUSMAP		;MAP OVER ALL VALUES OF ALL MATCHING GENERATIONS
	JRST HSSB2		;COME HERE FOR EACH WITH VALUE IN B
	POPJ P,

HSSB2:	CAIGE B,CHECML
	JRST HSSB3
	CAILE B,HRCME
	POPJ P,
	SUBI B,HRCMO
HSSB3:	MOVEI A,HELNTM
	ERCMEM
	MOVE C,HSSBTM
	IORM C,HELNTM+1
	SKIPL HELSET
	ANDCAM C,HELNTM+1
	EWCMEM
	POPJ P,

HSSBTM:	0

HSYME:	PUSHJ P,HTISC	;TYI CHEOPS SYM
	PUSHJ P,HUSEV	;LOOK IT UP
	JRST HCMERR
	PUSHJ P,HUSMAP
	SKIPA		;COME BACK HERE FOR EACH WITH VALUE IN B
	POPJ P,
	MOVEI C,4	;DIGITS
	EOCTP
	HSOUT [ASCIZ / /]
	POPJ P,


;BREAKPOINT STUFF
HB:	SKIPA C,[  [ CPOPJ	;INSERT IN BPT TBL    ALL READY THERE
		     HBIN1]]
HUB:	MOVEI C,[  HBREM1	;REMOVE FROM BPT TBL   FOUND IT, FLUSH
		   CPOPJ]
	MOVEM C,HBTEM
	PUSHJ P,HBOUT
	PUSHJ P,HTISC		;INSERT BREAKPOINT (TYI CHEOPS SYMBOL)
	PUSHJ P,HUSEV		;LOOK IT UP
	 JRST HCMERR		;LOSES
	PUSHJ P,HUSMAP		;MAP OVER ALL VALUES OF ALL MATCHING GENERATIONS
	 JRST HBI1		;COME HERE FOR EACH WITH VALUE IN B
	POPJ P,

HBI1:	MOVE C,HBTEM
	CAIGE B,CHECML
	JRST HB1A		;INTERPRET DIRECTLY AS C-MEM ADR
	CAILE B,HRCME
	POPJ P,
	SUBI B,HRCMO
HB1A:	HRLZ T,HBBPTP		;- # ENTRIES IN TBL
	JUMPGE T,@1(C)		;END OF TBL REACHED
HB1B:	CAMN B,HBBPT(T)
	JRST @(C)		;FOUND DESIRED ENTRY
	AOBJN T,HB1B
	JRST @1(C)		;END OF TBL

HBIN1:	MOVN T,HBBPTP
	CAIL T,BPTLEN-1
	.VALUE		;BPT TBL FULL
	AOS T
	MOVEM B,HBBPT-1(T)
	MOVNM T,HBBPTP
	POPJ P,

HBREM1:	SETOM HBBPT(T)
	POPJ P,

HUAB:	PUSHJ P,HBOUT
	CLEARM HBBPTP
	POPJ P,

HBBPTP:	0		;- # ENTRIES IN BPT TBL
HBTEM:	0
HBPTIN: 0		;IF 1 AND HSTFLG=1, BPTS ARE IN.

BPTLEN==40
HBBPT:	BLOCK BPTLEN    ;LOCNS TO PUT BPTS (-1 -> NULL ENTRY)


HGCNUM:	PUSHJ P,HGCOM		;GET NUMBER
	SKIPE HCSYL
	SKIPL HCNUMF
	JRST HCMERR
	POPJ P,

HGCOM:	MOVEI A,HSVIR		;PUT REAL IR IN MACHINE SO AS MUCH AS POSSIBLE
	EWFIR			;OF TRUE STATE WILL SIT THERE. (ESP IN ARRAY MODULE)
	MOVE B,[440700,,HCBUF]	;READ IN SYLABLE
	MOVEM B,HCBUFP
	CLEARM HCBUF
	MOVEI B,HCBUFL*5-2
	MOVEM B,HCBUFC
	PUSHJ P,HGCZNM		;CLEAR HCNUM BLOCK
	CLEARM HCDNUM
	SETOM HCNUMF
	CLEARM HCMFRC		;COMMAND FORCE
	CLEARM HCSYL
HGCOM1:	PUSHJ P,HTYI
	MOVEM A,HLASTC		;LAST CHAR SEEN
	CAIN A,3
	JRST HGCOM1
	CAIGE A,173
	JRST HGCM1B
	SUBI A,32		;COLAPSE HOLE LEFT BY LOWER CASE LETTERS
	JRST HGCMT		;LEAVING OPEN BRACE JUST ABOVE

HGCM1B:	CAILE A,140
	SUBI A,40		;UPPER CASE IFY
	SKIPE HCMFRC
	JRST HGCMT		;FORCE TO BE COMMAND CHR
	CAIL A,"0
	CAILE A,"9
	JRST HGCOM2
HGCOMN:	MOVE T,HCNUM		;READ IN 4 (16 BIT EA) PRECISION NUMBER
	LSH T,3
	ADDI T,-"0(A)
	MOVSI J,-4
HGCMN1:	DPB T,[2000,,HCNUM(J)]	;STORE BACK LOW 16 BITS
	LSH T,-20		;FLUSH THOSE
	MOVE ZR,HCNUM+1(J)	;NEXT HIGH PRECISION PART
	LSH ZR,3
	ADD T,ZR
	AOBJN J,HGCMN1		;PROPAGATE ON UP
	MOVE T,HCDNUM
	IMULI T,10.
	ADDI T,-"0(A)
	MOVEM T,HCDNUM
HGCHRS:	SETOM HCSYL		;SIGNAL SYLABLE NOT NULL
	SOSL HCBUFC		;SKIP ON STRING BUFFER FULL
	IDPB A,HCBUFP
	JRST HGCOM1

HGCOM2:	CAIL A,"A
	CAILE A,"Z
	JRST HGCOM3
HGCALP:	PUSHJ P,HGCNNM		;SIGNAL NO NUMBER
	JRST HGCHRS

HGCOM3:	CAIN A,".
	JRST HGCPD
	CAIN A,"@
	JRST HGCAT
HGCMT:	MOVEI B,0
	IDPB B,HCBUFP		;STORE 0 ON ASCIZ STRING
	MOVE B,HCBUF
	CAMN B,[ASCIZ /./]
	JRST HGCMPT		;GEE. THATS OUR SYMBOL!
	SKIPE HCSYL
	JRST HGCMT1
HGCNNM:	CLEARM HCNUMF		;NULLNESS IS REALLY NO NUMBER
HGCZNM:	CLEARM HCNUM		;ASSURE HCNUM IS REALLY 0 IF NO NUMBER
HGCZN1:	CLEARM HCNUM+1
	CLEARM HCNUM+2
	CLEARM HCNUM+3
HGCMT1:	POPJ P,


HGCAT:	SETOM HCMFRC		;FORCE NEXT CHAR TO BE COMMAND
	JRST HGCOM1

HGCMPT:	MOVE B,HCHPT		;SYMBOL = .
	MOVEM B,HCNUM		;STORE "VALUE"
	SETOM HCNUMF		;MAKE NUMBER AGAIN
	JRST HGCMT1

HGCPD:	MOVE B,HCDNUM		;PERIOD SEEN
	MOVEM B,HCNUM
	PUSHJ P,HGCZN1
	SKIPN HCSYL
	JRST HGCALP		;INITIAL . IS ALPHABETIC
	JRST HGCHRS

HCSDPY:	AOS HCSDPF		;INDICATE IN CONSOLE DISPLAYER
	PUSH P,HRAIDM		;MAKE "CONSOLE" DISPLAY
	CLEARM HRAIDM
	PUSH P,HCPOS
	PUSH P,HCLINE
	SKIPE HLLMOD
	JRST HDSPL1		;DONT DISPLAY RAID STUFF IN LL MODE
	PUSHJ P,HHU		;START AT TOP OF SCREEN
	PUSHJ P,HCLEOL
	MOVEI B,0
HDSRL:	SKIPN HRAIDA(B)
	JRST HDSRL1		;THAT ONE NULL
	PUSH P,B
	SKIPE HCPOS
	PUSHJ P,HCRR		;AT END OF PREV LINE
	MOVEI C,1
	EOCTP			;PRINT RAID REG #
	HSOUT [ASCIZ / /]
	MOVE B,(P)
	MOVE A,HRAIDA(B)
	PUSHJ P,HRGPNT
	PUSHJ P,HCLEOL		;TRY TO AVOID CLEARING LINE AFTER RAIDR AREA
	POP P,B
HDSRL1:	CAIGE B,10-1
	AOJA B,HDSRL
HDSPL1:	MOVEI A,0
	MOVE B,HDLNN
	PUSHJ P,HCSRPS		;POSITION CURSOR TO START CONSOLE SECTION
	MOVE B,HCHWD
	SUBI B,10
	MOVEI A,"*
	PUSHJ P,HTYO
	SOJG B,.-1
	HSOUT [ASCIZ /
NAF=/]
	MOVE B,HSVNAF
	MOVEI C,4
	EOCTP
	HSOUT [ASCIZ /  PC=  /]
	MOVE B,HSVPC
	MOVEI C,4
	EOCTP
	HSOUT [ASCIZ /  O-BUS=/]
	MOVE B,HSOBUS		;PRINT OUTPUT BUS
	MOVEI C,6
	EOCTP
	LDB B,[160100,,HSVFLA+1]	;GET STM
	HSOUT @HSTMTX(B)
	MOVE A,HSVPC
	ANDI A,3777
	ADDI A,HRORG
	PUSHJ P,HPUSM		;TRY PRINTING PC SYMBOLICALLY
	PUSHJ P,HCRR
	MOVEI A,HSVIR
	EPIF
	PUSHJ P,HCRR
	MOVEI A,HSERR1
	EPERRS
	PUSHJ P,HCRR
	HSOUT [ASCIZ /STEPC=/]
	MOVE B,HSTEPS
	PUSHJ P,HOCTP
	SKIPG HHUNTM
	JRST HCSDP3
	HSOUT [ASCIZ / TOP HUNT RANGE=/];IF IN E-LONG HUNT MODE, STEPC IS
	MOVE B,HHUNTV			;NOT HHUNTV
	PUSHJ P,HOCTP
HCSDP3:	SKIPN HHUNTM		;IF IN HUNT MODE, DISPLAY HUNT STEP SIZE
	JRST HCSDP2
	HSOUT [ASCIZ / HUNT DELTA=/]
	MOVE B,HHUNTS
	PUSHJ P,HOCTP
HCSDP2:	LDB B,[130400,,HSVIR]	;COND FIELD OF CURRENT INST
	JUMPE B,HCSDP1
	HSOUT [ASCIZ / SELECTED FW Q= /]
	SETOM HEXPF
	PUSHJ P,HEXFQC
HCSDP1:	PUSHJ P,HCLEOL
	POP P,B
	POP P,A
	PUSHJ P,HCSRPS
	POP P,HRAIDM
	SOS HCSDPF
	POPJ P,

HSTMTX:	[ASCIZ /  STM = 0 (WHITE) /]
	[ASCIZ /  STM = 1 (BLACK) /]


;STATE SAVING IN CHEOPS:
; A PASSIVE STATE SAVE GENERALLY SAVES EVERYTHING THAT CAN BE SAVED
;WITHOUT ACTIVELY AFFECTING CHEOPS.  THE FOLLOWING QUANTITES,
;READABLE FROM THE UNIBUS, EITHER DIRECTLY OR VIA THE MUX FALL IN THIS CATEGORY:
; IR (ALL 6 WDS), FLAG WORDS (ALL 4), ERROR WORDS (UNIBUS STATUS, AND
; PARITY ERRORS AND SPEC-FCTN WORDS ACCESSIBLE VIA MUX).

;THE "PC".  DEPENDING ON ONE'S POINT OF VIEW, CHEOPS EITHER DOESNT HAVE
;  A PC OR HAS SEVERAL. THE "PC" REGISTER HAS WHERE THE CURRENT MICRO-INSTRUCTION
;  CAME FROM (ASSUMING IT CAME FROM CONTROL-MEMORY), AND REALLY IS MORE OF AN
;  "OPC" REGISTER.  BECAUSE OF THIS, THE NEXT-ADDRESS FIELD OF THE CURRENT
;  MICROINSTRUCTION IS CLOSER TO BEING A "PC" IN THAT IT HAS MORE TO DO WITH
;  WHERE THE NEXT INSTRUCTION WILL COME FROM (ALTHO, OF COURSE, EVEN IT
;  CAN BE MODIFIED BY THE FLAG LOGIC AND/OR THE U-STACK LOGIC).  FOR THIS REASON,
;  WHEN A STATE SAVE IS DONE, THE NEXT ADDRESS FIELD OF THE MICROINSTRUCTION
;  IN THE IR IS SPECIALLY EXTRACTED AND STORED IN THE SAVED "NAF" (HSVNAF).
;  WHEN A STATE RESTORE IS DONE,  THE QUANTITY THERE IS DEPOSITED IN THE NEXT
;  ADDRESS FIELD OF THE SAVED IR BEFORE THE IR IS RESTORED.

HENTER:	PUSHJ P,HPSSAV		;ENTERING, SAVE STATE AS APPRO TO HLLMOD
	SKIPN HLLMOD
	PUSHJ P,HFSSAV		;HIGH LVL MODE, DO FULL
	POPJ P,

HLEAVE:	PUSHJ P,HFSRES		;LEAVING, RESTORE WHAT SAVED
	PUSHJ P,HPSRES
	POPJ P,

HPSSAV:	SKIPE HPSVAL		;DO PASSIVE STATE SAVE
	JRST HPSSAX		;STATE ALREADY SAVED
	HSTORE H0MOB,HSOBUS	;READ OBUS STATUS
	HSTORE H0MPC,HSVPC	;SAVE PC
	MOVEI A,3777
	ANDM A,HSVPC		;FLUSH EXTRA BITS THAT WILL SCREW US
	MOVEI A,HSERR1		;READ ERROR STATUS
	ERERWS
	MOVEI A,HSVIR		;SAVE IR
	ERFIR			;FULL IR (ALL 6 WDS)
	LDB A,[%H0JF HSVIR]	;CONSIDER JUMP FIELD OF IR TO BE "NAF"
	MOVEM A,HSVNAF
	MOVEI A,HSVFLA		;SAVE FLAGS
	ERFLG
	MOVE A,HSERR1
	TRNE A,HU2RUN		;UNIBUS STATUS RUN BIT
	JRST HPSSAX		;MACHINE REALLY RUNNING, SO THAT PRETTY RANDOM
	AOS HPSVAL		;INDICATE VALID STATE SAVED
HPSSAX:	POPJ P,

HFSSAV:	SKIPE HFSVAL		;DO FULL STATE SAVE
	JRST HFSSAX		;FULL STATE ALREADY SAVED
	ESTOP			;STOP MACHINE, CLEAR HRUN, LEAVE HTRUN ALONE
	CLEARM HPARSF		;INDICATE PAR NOT SAVED
	CLEARM HUSPSF		;INDICATE USP NOT SAVED
	PUSHJ P,HPSSAV		;DO PASSIVE SAVE
	MOVEI A,HSVPD0
	MOVEI B,0
	ERPDLB			;SAVE PDL LOCN 0
	AOS HFSVAL		;INDICATE FULL SAVE VALID
HFSSAX:	POPJ P,


HPSRES:	CLEARM HPSVAL		;DO "RESTORE" AFTER PASSIVE SAVE
	POPJ P,

HFSRES:	SKIPN HFSVAL		;RESTORE AFTER FULL SAVE
	JRST HFSREX		; IMPORTANT NOTE!! IF ANY "DISTRUCTIVE" CODE
	MOVEI A,HSVPD0		;  ADDED HERE, HRESNV MUST BE CHANGED TO SAVE
	MOVEI B,0		;  AND RESTORE IT!!
	EWPDLB			;RESTORE PDL LOCN 0
	SKIPL HPARSF
	JRST HFSRE1		;PAR NOT SAVED
	MOVEI A,HPARSV		;RESTORE PAR
	MOVEI B,HODAAC		;ODEST ADR OF PAR
	EWOD			;RESTORE PAR
	CLEARM HPARSF		;NOT SAVED ANY MORE
HFSRE1:	SKIPL HUSPSF
	JRST HFSRE2		;USP NOT SAVED
	MOVEI A,HUSPSV		;RESTORE USP
	MOVEI B,HODUSP
	EWOD
	CLEARM HUSPSF
HFSRE2:	LDB B,[160100,,HSVFLA+1];JUST LOADING FLAGWORD IS UNFORTURNATELY
	MOVE A,HFSRTB(B)	;NOT SUFFICIENT TO SET SIDE TO MOVE
	EWIR			;IT MUST ALSO BE SET VIA FLAG-CONTROL FCTN
	ECLK
	MOVEI A,HSVPC		;RESTORE PC. CAUTION! THIS GENERATES A CLOCK
	EWIR			;AND WILL BE CLOBBERED IF ANYONE ELSE GENERATES
	ECLK			;ONE
	MOVEI A,HSVFLA
	EWFLG
	MOVE A,HSVNAF
	DPB A,[%H0JF HSVIR]	;PUT THAT BACK IN JUMP FIELD OF IR
	MOVEI A,HSVIR
	EWFIR			;FULL IR (ALL 6 WDS)
	LDB A,[100200,,HSVFLA+3];LOAD PDP11 FLAGS IN UNIFACE
	LSH A,14.
	MOVEI B,140000
	ESUCW
	CLEARM HFSVAL
HFSREX:	POPJ P,

HFSRTB:	HFSSMW
	HFSSMB

HFSSMW:	0
	6
	0
	0

HFSSMB:	0
	5
	0
	0

XPIF:	MOVE C,1(A)		;PRINT "FULL" U INST
	TRNE C,H1AMOP
	JRST XPI		;ARRAY-OP, SO JUST PRINT IT
	PUSHJ P,XPI		;PRINT THE ALU PART
	HSOUT [ASCIZ /
--IRA CARRIED-- /]
	MOVE A,XPIAS
	MOVE C,4(A)		;GOBBLE DOWN IRA C AND D
	MOVEM C,XPIFT1+2	;PUT THEM IN WDS 2 AND 3 OF ARRAY INST
	MOVE C,5(A)
	MOVEM C,XPIFT1+3
	MOVEI A,XPIFT1
	MOVE TT,[-LHAST,,HIFAST];PNTR TO ARRAY INST WD 2 AND 3 PART OF FIELD TBL
	JRST XPIF1		;PRINT THE REST

XPIFT1:	0		;DUMMY UP ARRAY INST TO PRINT HERE
	H1AMOP
	0
	0

XPI:	MOVE TT,[-LHFST,,HIFST]	;PRINT INSTRUCTION POINTED TO BY A
XPIF1:	MOVEM A,XPIAS
	MOVEI C,177777		;SET UP PRINTED MASK
	MOVEM C,XPIM0
	MOVEM C,XPIM1
	MOVEM C,XPIM2
	MOVEI C,017777		;TOP 3 BITS WD 3 ARE SPARE
	MOVEM C,XPIM3
XPIL1:	MOVE Q,(TT)
	TLNN Q,(HSYOV)
	JRST XPIL7		;FIELD NOT VALID ON OUTPUT
	MOVE A,XPIAS
	LDB C,[%H1AMOP 1(A)]	;CHECK A CONTEXT - GET AMOP BIT
	LDB D,[.BP HSYACN Q]	;A CONTEXT OF SYMBOL
	XCT HTACXT(D)
	JRST XPIL7
	LDB C,[%H2LIT 2(A)]	;A CONTEXT OK, CHECK B CONTEXT. GET INST TYPE BITS
	LDB D,[.BP HSYBCN Q]
	XCT HTBCXT(D)
	JRST XPIL7		;B CONTEXT LOSES.
	HRRZ B,(TT)		;GET BYTE SPEC
	MOVEI A,XPIM0
	ELDB			;LOAD FIELD FROM MASK
	LDB D,[111100,,B]	;FIELD SIZE
	CAME A,HONET(D)
	JRST XPIL7		;NOT ALL ONES
	MOVE A,XPIAS
	TLNE Q,(HSYAT)
	JRST XPIL5		;GEN SYMBOLIC PRINTOUT
	TLNE Q,(HOZNUL)
	 JRST [	ELDB		;MAKE NULL PRINTOUT IF FIELD ZERO
		JUMPE A,XPIL6
		MOVE A,XPIAS
		JRST .+1]
	HSOUT @1(TT)
	HSOUT [ASCIZ / /]
	CAIN B,11.*1000
	 JRST [	PUSH P,A
		MOVE A,(A)
		ANDI A,3777
		ADDI A,HRORG	;JMP FIELD, TRY TO PRINT SYMBOLICALLY TOO
		PUSHJ P,HPUSM
		POP P,A
		JRST .+1]
	IPNFLD
XPIL6:	MOVEI A,XPIM0
	MOVEI B,0
	HRRZ C,(TT)
	EDPB			;INDICATE HAVE PRINTED THOSE BITS
XPIL7:	TLNE Q,(HSYAT)
	ADD TT,[1,,1]		;SKIP OVER AUX SYMTAB POINTER
	ADD TT,[1,,1]
	AOBJN TT,XPIL1
;	SKIPN XPIM0		;SHOULD HAVE PRINTED ALL THE BITS
;	SKIPE XPIM1
;	.VALUE
;	SKIPN XPIM2
;	SKIPE XPIM3
;	.VALUE
	POPJ P,


XPIL5:	ELDB		;LOAD FIELD FROM U INST
	ADD A,2(TT)
	SKIPN (A)
	JRST XPIL6	;NULL PRINTOUT, (DONT PRINT SPACE EITHER)
	HSOUT @(A)
	HSOUT [ASCIZ / /]
	JRST XPIL6

XPIM0:	0		;MUST BE CONSEC
XPIM1:	0
XPIM2:	0
XPIM3:	0

XPIAS:	0		;TEMP FOR SAVING POINTER TO INST AT XPI


XPERRS:	MOVE B,(A)	;PRINT ERROR WD BLOCK (A)
	MOVEI C,XPERT1
	PUSHJ P,XPER1
	MOVE B,1(A)
	MOVEI C,XPERT2
	PUSHJ P,XPER1
	MOVE B,2(A)
	MOVEI C,XPERT3
	PUSHJ P,XPER1
	POPJ P,

XPER1:	TRNN B,177777
	POPJ P,
	TRNN B,100000
	JRST XPER2
	SKIPE (C)
	HSOUT @(C)
XPER2:	LSH B,1
	AOJA C,XPER1

XPERT1:	[ASCIZ /RUN /]
	[ASCIZ /HIERR /]
	[ASCIZ /PARERR /]
	[ASCIZ /NXMR /]
	[ASCIZ /SPCOVF /]
REPEAT 11.,0

XPERT2:	[ASCIZ /POUT-P /]
	[ASCIZ /TYP-P /]
	[ASCIZ /VAL-P /]
	[ASCIZ /LOC-P /]
	[ASCIZ /SPC-P /]
	[ASCIZ /OLD-IR-P /]
	[ASCIZ /R-PDL-P /]
	[ASCIZ /L-PDL-P /]
	[ASCIZ /SPCOVF /]
	[ASCIZ /NXMR /]
	[ASCIZ /R-BBUS /]
	[ASCIZ /L-BBUS /]
	[ASCIZ /R-AC /]
	[ASCIZ /L-AC /]
	[ASCIZ /R-AAC /]
	[ASCIZ /L-AAC /]

XPERT3:	REPEAT 7.,0
	[ASCIZ /IR-P /]
	[ASCIZ /STM /]
	[ASCIZ /PROMV /]
	[ASCIZ /EP-CPT /]
	[ASCIZ /TO-G-FILE /]
	[ASCIZ /FM-5-RANK /]
	[ASCIZ /TRANK /]
	[ASCIZ /PROMOTE /]
	[ASCIZ /P-MV /]


HONET:	0	;ALL ONES TABLE (INDEX OF NUMBER OF ONES)
	1
	3
	7
	17
	37
	77
	177
	377
	777
	1777
	3777
	7777
	17777
	37777
	77777
	177777
	377777
	777777

XLDB:	PUSH P,I	;POINTER TO BLOCK OF 16 BIT DATA WORDS IN A
	PUSH P,J	;BYTE DESCRIPTOR IN B, LOAD FIELD INTO A
	PUSH P,R
	LDB I,[040500,,B]	;WORDS COMPONENT OF SHIFT
	ADD A,I
	MOVE R,(A)		;LOW WORD
	LSH R,2			;LEFT ADJUST IN RIGHT HALF OF WD
	HRL R,1(A)		;GET HIGH WORD
	LDB I,[000400,,B]	;BITS COMPONENT OF SHIFT
	ADDI I,2		;LOW TWO BITS DONT COUNT
	MOVEI J,R
	DPB I,[360600,,J]
	LDB I,[111100,,B]	;BYTE SIZE
	DPB I,[300600,,J]
	LDB A,J
	POP P,R
	POP P,J
	POP P,I
	POPJ P,


XDPB:	PUSH P,I	;POINTER TO BLOCK OF 16 BIT DATA WORDS IN A
	PUSH P,J	;DATA IN B
	PUSH P,R	;BYTE DESC IN C
	PUSH P,A
	LDB I,[040500,,C]	;WORDS COMPONENT OF SHIFT
	ADD A,I
	MOVE R,(A)		;"LOW" WORD
	LSH R,2			;LEFT ADJUST IN RH
	HRL R,1(A)		;GET HIGH WORD
	LDB I,[000400,,C]	;BITS COMPONENT OF SHIFT
	ADDI I,2		;LOW BITS DONT COUNT
	MOVEI J,R
	DPB I,[360600,,J]
	LDB I,[111100,,C]
	DPB I,[300600,,J]
	DPB B,J
	HLRM R,1(A)
	LSH R,-2
	ANDI R,177777
	HRRM R,(A)
	POP P,A
	POP P,R
	POP P,J
	POP P,I
	POPJ P,
	
XPNFLD:	PUSH P,A		;PRINT NUMERIC FIELD.  POINTER TO DATA BLOCK IN A
	PUSH P,B		; BYTE FIELD DESCRIPTION IN B
	PUSH P,C
	PUSH P,D
	PUSH P,B
	LDB C,[111100,,B]
	CAILE C,16.
	 JRST [		SUBI B,20000
			ADDI B,20
			PUSHJ P,XPNFLD
			HSOUT [ASCIZ / /]
			MOVEI B,20
			DPB B,[111100,,(P)]
			MOVE B,(P)
			JRST .+1]
	ELDB
	POP P,B
	LDB C,[111100,,B]
	ADDI C,2
	IDIVI C,3		;GET # OF DIGITS TO PRINT
	MOVE B,A
	EOCTP
	HSOUT [ASCIZ / /]
	POP P,D
	POP P,C
	POP P,B
	POP P,A
	POPJ P,

XOCTP:	PUSH P,A		;PRINT DATA IN B, NUMBER OF DIGITS IN C
	PUSH P,C
XOCTP1:	LDB A,XOCTPT(C)
	ADDI A,"0
	PUSHJ P,HTYO
	SOJG C,XOCTP1
	POP P,C
	POP P,A
	POPJ P,

XOCTPT:	000000,,B		;BITS TO PRINT ON NTH FROM LAST DIGIT
	000300,,B
	030300,,B
	060300,,B
	110300,,B
	140300,,B
	170300,,B
	210300,,B

HOCTP:	LSHC B,-35.		;ZERO SUPPRESSING 36 BIT OCTAL PRINT OF B
	LSH C,-1
	DIVI B,10
	HRLM C,(P)
	SKIPE B
	PUSHJ P,HOCTP
	HLRZ A,(P)
	ADDI A,"0
	JRST HTYO



HTYI:	SKIPL A,HTYIUR
	JRST [	SETOM HTYIUR		;READ UNRCH CHAR
		POPJ P,]
	SKIPGE HTICMF
	 JRST HTICF1		;IN COMMAND FILE MODE
	PUSHJ P,TYI	
HTICF2:	CAIE A,12
	CAIN A,15
	POPJ P,		;DONT ECHO CR OR LF NOW
	PUSH P,A
	PUSHJ P,HTYO	;DO OWN ECHOING
	POP P,A
	POPJ P,

HTICF1:	.IOT UTICOM,A	;GOBBLE COMMAND FILE
	ANDI A,177
	CAIN A,3
	JRST HTICF2
	.CLOSE UTICOM,
	CLEARM HTICMF
	MOVEI A,"_
	PUSHJ P,HTYO
	JRST HTYI

HCRR:	MOVEI A,15
	PUSHJ P,HTYO
	MOVEI A,12
HTYO:	CAIN A,12	;TYO CHR AND KEEP TRACK OF THINGS
	JRST HTYOC1
	CAIE A,15
	JRST HTYO2
	PUSHJ P,HCLEOL
	PUSHJ P,HTCR
	SKIPN HRAIDM
	JRST HTYOC2
	MOVE A,HCLINE
	AOS A
	CAMGE A,HDLNN
	JRST HTYOC2	;WILL STILL BE ABOVE CONSOLE AREA
HRDHU:	PUSH P,B
	PUSH P,C
	CLEARB A,B	;HOME UP TO BOTTOM OF ACTIVE RADI AREA
	MOVEI C,HRAIDA
HRDHU1:	SKIPE (C)	;COUNT RAID REGISTERS IN USE
	AOS B
	CAIGE C,HRAIDA+7
	AOJA C,HRDHU1
	PUSHJ P,HCSRPS
	POP P,C
	POP P,B
	JRST HTYOC1

HTYOC2:	PUSHJ P,HTLF
HTYOC1:	PUSHJ P,HCLEOL
HTYOX:	POPJ P,

HTCR:	.IOT TYOC,[15]
	CLEARM HCPOS
	POPJ P,

HTLF:	.IOT TYOC,[12]		;DO LOGICAL LINE FEED
	AOS HCLINE
	POPJ P,

HCLEOL:	.IOT TYOC,[^P]		;OUTPUT CLEAR END OF LINE
	.IOT TYOC,["L]
	POPJ P,

HCLEOF:	.IOT TYOC,[^P]		;CLEAR TO EOF
	.IOT TYOC,["E]
	POPJ P,


HCSRPS:			;SET CURSOR TO HORIZ POS IN A, VERT IN B
	MOVEM A,HCPOS
	MOVEM B,HCLINE
	.IOT TYOC,[^P]
	.IOT TYOC,["H]
	ADDI A,10
	.IOT TYOC,A
	.IOT TYOC,[^P]
	.IOT TYOC,["V]
	MOVEI A,10(B)
	.IOT TYOC,A
	POPJ P,

HHU:	.IOT TYOC,[^P]
	.IOT TYOC,["T]
	CLEARM HCPOS
	CLEARM HCLINE
	POPJ P,

HTYO2:	PUSH P,B
	CAIGE A,40	;ACTUALLY TYOIFY
	JRST HTYO2A
HTYO2B:	AOS B,HCPOS
	CAMGE B,HCHWD
	JRST HTYO2T	;OK WILL STILL BE ON LINE
	PUSH P,A
	PUSHJ P,HCRR
	POP P,A
	JRST HTYO2B

HTYO2A:	PUSH P,A
	MOVEI A,"^
	PUSHJ P,HTYO
	MOVE A,(P)
	ADDI A,100
	PUSHJ P,HTYO
	POP P,A
	POP P,B
	POPJ P,

HTYO2T:	.IOT TYOC,A
	POP P,B
	POPJ P,


XPRSQ:	PUSH P,A			;PRINT SYMBOLICALLY (A) AS SQUARE
	PUSH P,B
	PUSH P,C
	MOVE C,(A)
	ANDI C,377
	TRNE C,200
	 JRST [	HSOUT [ASCIZ / NS /]	;NULL SQUARE
		JRST HPRSQ2]
	CAIL C,100
	JRST HPRSQ2
	LDB B,[160100,,HSVFLA+1]	;GET STM
	HSOUT HPRSQT(B)
	LDB C,[300,,(A)]
	HSOUT HFNM(C)
	LDB A,[30300,,(A)]
	AOS A
	JUMPE B,HPRSQ1
	MOVNS A
	ADDI A,9
HPRSQ1:	ADDI A,"0
	PUSHJ P,HTYO
	MOVEI A,40
	PUSHJ P,HTYO
HPRSQ2:	POP P,C
	POP P,B
	POP P,A
	POPJ P,

HPRSQT:	ASCIZ /W/
	ASCIZ /B/

XPRPCL:	PUSH P,B		;PRINT "LEFT HALF" (SIXTEEN BITS WISE) AS PIECE INDEX
	LDB B,[101000,,(A)]
	JRST XPRPC2

XPRPC:	PUSH P,B		;PRINT PIECE INDEX
	MOVE B,(A)
	ANDI B,377
XPRPC2:	CAIL B,100
	JRST HPRPC1
	HSOUT HPNM(B)
	HSOUT [ASCIZ / /]
HPRPC1:	POP P,B
	POPJ P,

	


HFLASM:	[ASCIZ /0-15 /]		;QUARTER 3
	[ASCIZ /KCHK /]
	[ASCIZ /0-13 /]
	[ASCIZ /0-12 /]
	[ASCIZ /0-11 /]		;QUARTER 2
	[ASCIZ /0-10 /]
	[ASCIZ /A-M-P /]
	[ASCIZ /0-8 /]
	[ASCIZ /0-7 /]		;QUARTER 1
	[ASCIZ /0-6 /]
	[ASCIZ /0-5 /]
	[ASCIZ /A-M-S /]
	[ASCIZ /0-3 /]		;QUARTER 0
	[ASCIZ /0-2 /]
	[ASCIZ /0-1 /]
	[ASCIZ /0-0 /]

HFLBSM:	[ASCIZ /STACK-END-CHECK /]	;QUARTER 7
	[ASCIZ /STM /]
	[ASCIZ /B-13 /]
	[ASCIZ /DBELL /]
	[ASCIZ /0-11 /]			;QUARTER 6
	[ASCIZ /EXTB-2 /]
	[ASCIZ /EXTB-1 /]
	[ASCIZ /EXTB-0 /]
	[ASCIZ /0-7 /]			;QUARTER 5
	[ASCIZ /0-6 /]
	[ASCIZ /ALU-LESS /]
	[ASCIZ /ALU-LEQ /]
	[ASCIZ /LEGAL /]		;QUARTER 4
	[ASCIZ /DEEP /]
	[ASCIZ /ALU-EQ /]
	[ASCIZ /ALU-NO-CRY-OUT /]

HFLCSM:	[ASCIZ /SEL-P-EXISTS /]		;QUARTER 13
	[ASCIZ /0-14/]
	[ASCIZ /Q-CAS-LGL /]
	[ASCIZ /K-CAS-LGL /]
	[ASCIZ /0-11 /]			;QUARTER 12
	[ASCIZ /OFF-BOARD /]
	[ASCIZ /PROMOTE-P /]
	[ASCIZ /E-P-CAPT /]
	[ASCIZ /ANY-RANK /]		;QUARTER 11
	[ASCIZ /P-TYP-2 /]
	[ASCIZ /P-TYP-1 /]
	[ASCIZ /P-TYP-0 /]
	[ASCIZ /TERM-RANK /]		;QUARTER 10
	[ASCIZ /PROMOTING-POSS /]
	[ASCIZ /SEL-SQ /]
	[ASCIZ /ANY-SQS /]

HFLDSM:	[ASCIZ /O-BUS-3 /]			;QUARTER 17
	[ASCIZ /O-BUS-2 /]
	[ASCIZ /O-BUS-1 /]
	[ASCIZ /O-BUS-0 /]
	[ASCIZ /0-11 /]			;QUARTER 16
	[ASCIZ /UNIBUS-CYC /]
	[ASCIZ /PDP-11F1 /]
	[ASCIZ /PDP-11F0 /]
	[ASCIZ /FC-7 /]			;QUARTER 15
	[ASCIZ /F-C-KCHK /]
	[ASCIZ /F-C-DEEP /]
	[ASCIZ /F-C-LEGAL /]
	[ASCIZ /W-Q-CS-NOT-POSS /]	;QUARTER 14
	[ASCIZ /W-K-CS-NOT-POSS /]
	[ASCIZ /B-Q-CS-NOT-POSS /]
	[ASCIZ /B-K-CS-NOT-POSS /]




HBOARD:	BLOCK 64.		;PIECE IMAGE OF BOARD FOR HACKING

HFNM:	ASCIZ /QR/		;FILE NAMES
	ASCIZ /QN/
	ASCIZ /QB/
	ASCIZ /Q/
	ASCIZ /K/
	ASCIZ /KB/
	ASCIZ /KN/
	ASCIZ /KR/

HPNM:	REPEAT 8,[HCONC ASCIZ /WNL,\.RPCNT,/
]						;0X
	REPEAT 8,[HCONC ASCIZ /BNL,\.RPCNT,/
]						;1X
	ASCIZ /WKP /	;2X
	ASCIZ /WQP /
	ASCIZ /WKBP/
	ASCIZ /WQBP/
	ASCIZ /WKNP/
	ASCIZ /WQNP/
	ASCIZ /WKRP/
	ASCIZ /WQRP/

	ASCIZ /BKP /	;3X
	ASCIZ /BQP /
	ASCIZ /BKBP/
	ASCIZ /BQBP/
	ASCIZ /BKNP/
	ASCIZ /BQNP/
	ASCIZ /BKRP/
	ASCIZ /BQRP/

	ASCIZ / WK /	;4X
	ASCIZ / WQ /
	ASCIZ /WKR /
	ASCIZ /WQR /
	ASCIZ /WKB /
	ASCIZ /WQB /
	ASCIZ /WKN /
	ASCIZ /WQN /

	ASCIZ / BK /	;5X
	ASCIZ / BQ /
	ASCIZ /BKR /
	ASCIZ /BQR /
	ASCIZ /BKB /
	ASCIZ /BQB /
	ASCIZ /BKN /
	ASCIZ /BQN /

	ASCIZ /WKX /	;PROMOTED KP	6X
	ASCIZ /WQX /
	ASCIZ /WKBX/
	ASCIZ /WQBX/
	ASCIZ /WKNX/
	ASCIZ /WQNX/
	ASCIZ /WKRX/
	ASCIZ /WQRX/

	ASCIZ /BKX /	;PROMOTED KP	7X
	ASCIZ /BQX /
	ASCIZ /BKBX/
	ASCIZ /BQBX/
	ASCIZ /BKNX/
	ASCIZ /BQNX/
	ASCIZ /BKRX/
	ASCIZ /BQRX/

HPNMV:			;ALL THESE VALUES MULTIPLIED BY 2 SO THAT POSITION
	REPEAT 2*8,0*2	;VALUE IS ALWAYS EVEN.  THUS, ODD VALUES CAN BE USED
	REPEAT 2*8,4*2	;FOR ALPHA BETA HACKING, AND CAN BE DISTINGUISHED
REPEAT 2,[
	254.	;K VALUE, HOPEFULLY ACADEMIC
	35.*2
	20.*2
	20.*2
	14.*2
	14.*2
	13.*2
	13.*2
]	REPEAT 2*8,35.*2	;ASSEMBLE FOR Q PROMOTION

HPNMT:
	REPEAT 2*8,0
	REPEAT 8,207
	REPEAT 8,306
REPEAT 2,[
	200+.RPCNT*100+1
	200+.RPCNT*100+2
	200+.RPCNT*100+3
	200+.RPCNT*100+3
	200+.RPCNT*100+4
	200+.RPCNT*100+4
	200+.RPCNT*100+5
	200+.RPCNT*100+5
]	REPEAT 8,202	;ASSEMBLE FOR Q PROMOTION
	REPEAT 8,302


HSMTAB:	BLOCK HSMSIZ		;SYMBOL TABLE POINTER TABLE
HSMDAT:	BLOCK HDTSIZ		;SYMBOL TABLE DATA AREA

R.VL:	.VALUE	;THIS XCT ED WHEN RUN OF CHEOPS OBSERVED ON WHEN IT SHOULDNT.
		; HERE FOR EASE OF CHANGING SINCE SOMETIMES THE WORLD GETS
		; INTO A HUNG MODE.
HCSYL:	0	;-1 SYL TYPED
HCNUMF:	0	;-1 HCNUM VALID
HCNUM:	0	;NUMBER
	0
	0
	0
HCDNUM:	0	;DECIMAL NUMBER

HCVALF:	0	;-1 HCVAL VALID (COMMAND HAS RETURNED VALUE)
HCVAL:	0	;COMMAND S RETURN VALUES IN HCVAL (IF HCVALF -1)
	0
	0
	0

HCHPT:	0	;VALUE OF SYMBOL "."
HRGOPF:	0	;-1 -> REGISTER "OPEN"

HCMFRC:	0	;-1 FORCE NEXT CHR TO BE A BREAK AT HGCOM
HTICRF:	0	;-1 LAST FIELD TERM BY CR AT HTIUI

HCBUFL==10
HCBUF:	BLOCK HCBUFL		;COMMAND STRING BUFFER
HCBUFC:	0			;CHARS LEFT IN HCBUF
HCBUFP:	0			;POINTER TO HCBUF
HLASTC:	0			;LAST CHR TYI ED BY HGCOM

HPSVAL:	0	;NON ZERO -> PASSIVE STATE SAVE VALID
HFSVAL:	0	;NON ZERO -> FULL STATE SAVE VALID
HRUN:	0	;NON ZERO -> CHEOPS ACTUALLY RUNNING
HTRUN:	0	;NON ZERO -> CHEOPS "TRYING" TO RUN
		; DOES NOT GET CLEARED WHEN CHEOPS STOPPED ON FULL STATE SAVE
HLLMOD:	0	;NON ZERO -> "LOW LEVEL MODE". 0 NORMAL

HSVIR:	0	;"OBSERVED" IR A
	0	;	    IR B
	0	;	    IR C
	0	;	    IR D
HSVIRA:	0	;"OBSERVED" IRA C
	0	;	    IRA D

HNVTIR:	BLOCK 6	;TEMP FOR IR AT HRESNV
HNFWDS:	BLOCK 4	;"NEXT FLAGS" READ IN BY HEXRNF

HSVFLA:	0	;"OBSERVED" FLAG A
	0	;           FLAG B
	0	;	    FLAG C
	0	;	    FLAG D

HSVNAF:	0	;"OBSERVED" NAF  (THIS IS ACTUALLY IR 10-0)
HSVPC:	0	;"OBSERVED" PC
	0	;DUMMY WDS MUST FOLLOW HSVPC
	0
	0

HSOBUS:	0	;"OBSERVED" O-BUS
HSVORG:	0	;"OBSERVED" O-REG
HSVPD0:	0	;"OBSERVED" LOCN 0 OF DATA PDL MEMORY 
		;  (THAT LOCN USED INTERNALLY BY CONSOLE PRGM)

HSERR1:	0	;SAVED STATUS (FROM 176002)
HSERR2:	0	;SAVED PARITY BITS (FROM MUX-SEL 14)
HSERR3:	0	;SAVED "SPEC-FCTN" BITS (FROM MUX-SEL 15)

HPARSF:	0	;-1 PAR SAVED IN HPARSV
HPARSV:	0	;IF HPARSF IS -1, SAVED PAR. 
		;  (TO AVOID LOADING AND UNLOADING ON EVERY REF TO PDL)
HUSPSF:	0	;-1 USP SAVED IN HUSPSV
HUSPSV:	0	;IF HUSPSF IS -1, SAVED USP.

HSTEPS:	0	;STEP COUNTER. INCR FOR EACH STEP BY ^N. CLEARED BY
		;^P OR :TP AND BY :LOAD BEFORE LOADING A NON-ZERO DUMP FILE
HTPLST:	1	;LAST TEST POSITION USED
HTPPCL:	0	;PIECE LIST POINTER TO USE IF HTPLST IS -
HTPLDF:	0	;IF -1, TYP AND VAL MEMORIES HAVE BEEN RELOADED SINCE
		;LAST RESET OR NON-ZERO FILE LOAD
HSTEPM:	0	;STEP MODE. IF ZERO, CNTRL-N COMMAND STEPS
		;CHEOPS DIRECTLY, IF >0, IT USES STAT STOP FEATURE
		;OF CHEOPS.
HUSADR:	0	;UCODE STARTING ADR

HCHSPD:	3	;CHEOPS RUNNING SPEED

HDPFLG:	0	;NON ZERO -> SOME DEPOSITING DONE, RECOMPUTE RAID REG

HSPDL:	0	;SAVED PDL LVL WHEN ENTERED CONSOLE MODE
HTSST1:	0	;SAVED TTYST1 WD WHEN ENTERED
HTSST2:	0	;SAVED TTYST2
HTSSTS:	0	;SAVED TTYSTS

HTTYMD:	0	;0 -> NORMAL, 1-> CHEOPS CONSOLE MODE
HCMREQ:	-1	;+ OR ZERO, "TRYING" TO REACH COMMAND LOOP

HGEUSF:	0	;ZERO -> NO ERROR ON "UNDEFINED" SYMBOL
HSMFND:	0	;-1 -> SYMBOL FOUND AT HGECOM

HTYIUR:	-1	;-1 OR UNRCH THIS CHAR AT HTYI

HCLINE:	0	;LINE POSITION
HCPOS:	0	;CHARACTER POSITION
HCHWD:	80.	;SCREEN WIDTH IN CHARACTERS

HCSDPF:	0	;NON-ZERO -> IN CONSOLE DISPLAYER
HDLNN:	26.	;LINE NUMBER TO START CONSOLE AREA ON
HRAIDM:	0	;-1 -> CONFINE PRINTOUT TO MAIN CONSOLE AREA 
		; (AVOID RAID REG AREA AND CONSOLE AREA)

HRAIDA:	REPEAT 10,0	;RAID REGISTERS (REGISTER ADR TO DISPLAY, OR ZERO)

CONSTANTS
VARIABLES

