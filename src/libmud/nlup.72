
<PACKAGE "LUP">

<ENTRY LUP-ACT
       LUP-DCT
       LUP-ADD-PACK
       LUP-ADD-DATUM
       LUP-DEL
       LIB-GC
       LIB-STAT
       DO-ADD
       FLUSH-CURRENT-PACKAGE>

<ENTRY CUR-TYPE CUR-UPD>

"Stuff for doing library updates:  add, delete package, garbage-collect
a data base, initialize a data base, etc."

<USE "LIB">

<FLOAD "LIBMUD;NLUPCRF NBIN">

<GDECL (MUDDLE) FIX>
î
;"dskdate &c."

<NEWTYPE UPDB
	 VECTOR
	 '<<PRIMTYPE VECTOR> DATA-BASE
			     <OR FALSE DATA-BASE>
			     CHANNEL
			     <OR CHANNEL FALSE>
			     CHANNEL
			     STRING
			     STRING>>

<SETG UPDB-BASE 1>

<SETG UPDB-NEW 2>

<SETG UPDB-DATFILE 3>

<SETG UPDB-NEWDAT 4>

<SETG UPDB-LOCK 5>

<SETG UPDB-ONAME 6>

<SETG UPDB-NNAME 7>

<MANIFEST UPDB-BASE
	  UPDB-NEW
	  UPDB-DATFILE
	  UPDB-NEWDAT
	  UPDB-LOCK
	  UPDB-ONAME
	  UPDB-NNAME>

<SETG DB-MIN-ENTRY <+ ,FUNCTION-NAMEBEG 1 1>>

<MANIFEST DB-MIN-ENTRY>

"Smallest possible entry has two words of header, 1 of name, 1 of data."

<SETG DB-DEAD 0>

<SETG LOAD-CHANNEL <>>

<GDECL (DB-DEAD) FIX (NO-ENT) FIX (LOAD-CHANNEL) <OR CHANNEL FALSE>>

""

"SUBTITLE File management"

<DEFINE LUP-ACT LA (NAME
		    "OPTIONAL" (TRY? T) (GC? <>)
		    "AUX" GB CH DB L UD NN (OUTCHAN .OUTCHAN) (SNM <SNAME>)
			  (NM2 ,L-LIBRARY-NAME) (MUDDLE ,MUDDLE) DATCHN
			  (DATCHN2 <>))
   #DECL ((UD) UPDB (NN NAME) STRING (DB) <OR DATA-BASE FALSE> (OUTCHAN) CHANNEL
	  (DATCHN2 DATCHN L) <OR FALSE CHANNEL> (CH) <OR CHANNEL FALSE>
	  (GB) <UVECTOR [REST FIX]>
	  (GC? TRY?) <OR ATOM FALSE> (SNM NM2) <SPECIAL STRING> (MUDDLE) FIX)
   <COND (<GASSIGNED? CUR-UPD>
	  <COND (<G? ,DB-DEAD 0> <LUP-DCT T>)
		(<PRINC "DB already active."> <CRLF> <RETURN T .LA>)>)>
   <COND
    (<AND <SET DB <DB-OPEN .NAME "READB">>
	  <OR <SET DATCHN <OPEN-DAT-FILE "READ" .NAME>> .GC?>>
     <COND (<G? .MUDDLE 100>
	    <SET NAME <STRING !\< <6 <DB-CHAN .DB>> !\> <3 <DB-CHAN .DB>>>>)
	   (<SET NAME <STRING <6 <DB-CHAN .DB>> !\; <3 <DB-CHAN .DB>>>>)>
     <SET SNM <6 <DB-CHAN .DB>>>
     <COND (<SET L
		 <HARD-LOCK <COND (<G? ,MUDDLE 100>
				   <STRING !\<
					   <10 <DB-CHAN .DB>>
					   !\>
					   <7 <DB-CHAN .DB>>
					   ".LOCK">)
				  (<STRING <10 <DB-CHAN .DB>>
					   !\;
					   <7 <DB-CHAN .DB>>
					   " LOCK">)>>>
	    <COPY-FILE <DB-CHAN .DB> <SET NN <NEW-NAME <DB-CHAN .DB>>>
		       <> "PRINTB">
	    <COND (<NOT .GC?> <SET DATCHN <COPY-FILE .DATCHN
						     <COND (<G? .MUDDLE 100> "ZDATA.TMP")
							   ("_DATA TMP")> T>>)>
	    <DB-CLOSE .DB>
	    <SET DB <DB-OPEN .NN "PRINTO">>
	    <DB-HASH-MAP .DB>
	    <PUT <DB-DATA .DB> <+ ,LASTUP 1> <DSKDATE>>
	    <COND (.GC?
		   <SET DATCHN2 <OPEN "PRINT" <COND (<G? .MUDDLE 100> "ZDATA.TMP")
						    ("_DATA TMP")>>>
		   <PUT .DATCHN2 13 *377777777777*>)
		  (<PUT .DATCHN 13 *377777777777*>)>
	    <SETG CUR-UPD <CHTYPE [.DB <> .DATCHN .DATCHN2 .L .NAME .NN] UPDB>>
	    <PRINC .NAME>
	    <PRINC " ACTIVATED">
	    <CRLF>
	    T)
	   (<DB-CLOSE .DB> .L)>)
    (.TRY?
     <TELL "Creating new library " .NAME>
     <SET CH <OPEN "PRINTB" .NAME>>
     <COND (<GASSIGNED? GROW-BUF> <SET GB ,GROW-BUF>)
	   (<SETG GROW-BUF <SET GB <IUVECTOR 1024 0>>>)>
     <PUT .GB 1023 4295229440>
     <PUT .GB <+ ,FILNAM 1> -20777869980>
     <PUT .GB <+ ,HLEN1 1> 251>
     <PUT .GB <+ ,HLEN2 1> 751>
     <PUT .GB <+ ,FREEPT 1> <+ ,HDRLEN 251 751>>
     <PUT .GB
	  <+ ,HDRLEN 251 751 1>
	  <CHTYPE <PUTBITS 0 ,LENGET <- 1022 <+ ,HDRLEN 251 751>>> FIX>>
     <PRINTB .GB .CH>
     <MAPR <> <FUNCTION (X) <PUT .X 1 0>> .GB>
     <PUT .GB 1023 4295229440>
     <CLOSE .CH>
     <SET CH <OPEN-DAT-FILE "PRINT" .NAME>>
     <CLOSE .CH>
     <LUP-ACT .NAME <>>)
    (.DB)>>

<DEFINE GET-DB ("AUX" U) 
	#DECL ((U) UPDB)
	<COND (<GASSIGNED? CUR-UPD> <DB-OK?>)
	      (<LUP-ACT <COND (<G? ,MUDDLE 100> "<MDLLIB>LIBMUD")
			      ("LIBMUD;LIBMUD")>>)>>

<DEFINE OPEN-DAT-FILE (MODE NAME "AUX" (NM2 ,L-DATFILE-NAME)) 
	#DECL ((MODE NAME) STRING (NM2) <SPECIAL STRING>)
	<OPEN .MODE .NAME>>

<DEFINE DB-OK? () 
	<COND (<NOT <GASSIGNED? CUR-UPD>> <>)
	      (<G? ,DB-DEAD 0> <ERROR DB-IN-BAD-STATE DB-OK?>)
	      (T)>>

<DEFINE LUP-DCT LD ("OPTIONAL" (FLUSH? <>) "AUX" U CH DB DF (MUDDLE ,MUDDLE)) 
	#DECL ((DB) <OR DATA-BASE FALSE> (U) UPDB (FLUSH?) <OR ATOM FALSE>
	       (MUDDLE) FIX (DF) CHANNEL)
	<COND (<NOT <DB-OK?>>
	       <PRINC "No libraries activated.">
	       <CRLF>
	       <RETURN <> .LD>)>
	<SET U ,CUR-UPD>
	<COND (<NOT <SET DB <UPDB-NEW .U>>> <SET DB <UPDB-BASE .U>>
	       <SET DF <UPDB-DATFILE .U>>)
	      (<SET DF <UPDB-NEWDAT .U>>)>
	<DB-HASH-MAP .DB>
	<COND (<OR .FLUSH?
		   <COND (<G? .MUDDLE 100>
			  <DB-CLOSE .DB>
			  <RENAME <FILNAME <DB-CHAN .DB> 9>
				  TO
				  <STRING <UPDB-ONAME .U> !\. ,L-LIBRARY-NAME>>
			  <CLOSE .DF>
			  <RENAME <FILNAME .DF 9>
				  TO
				  <STRING <UPDB-ONAME .U>
					  !\.
					  ,L-DATFILE-NAME>>
				      ;"rename while open not supported on 10x")
			 (<RENAME <DB-CHAN .DB>
				  <STRING <UPDB-ONAME .U> !\  ,L-LIBRARY-NAME>>
			  <RENAME .DF
				  <STRING <UPDB-ONAME .U> !\  ,L-DATFILE-NAME>>
			  <DB-CLOSE .DB>
			  <CLOSE .DF>)>>
	       <COND (.FLUSH? <RENAME <UPDB-NNAME .U>>)>
	       <UNLOCK <UPDB-LOCK .U>>
	       <SETG DATA-BASES <REST ,DATA-BASES 2>>
	       <COND (<UPDB-NEW .U>
		      <DB-CLOSE <UPDB-BASE .U>>
		      <RENAME <FILNAME <DB-CHAN <UPDB-BASE .U>> 9>>
		      <PUT .U ,UPDB-NEW <>>
		      <CLOSE <UPDB-DATFILE .U>>
		      <PUT .U ,UPDB-NEWDAT <>>
		      <SETG DATA-BASES <REST ,DATA-BASES 2>>)>
	       <GUNASSIGN CUR-UPD>
	       "DONE")>>

<DEFINE NEW-NAME (CH) 
	#DECL ((CH) CHANNEL)
	<COND (<G? ,MUDDLE 100> <STRING !\< <10 .CH> ">Z" <7 .CH>>)
	      (<STRING <10 .CH> ";_" <7 .CH>>)>>

<DEFINE FILNAME (CH "OPTIONAL" (BASE 5)) 
	#DECL ((CH) CHANNEL (BASE) FIX)
	<COND (<G? ,MUDDLE 100>
	       <STRING <9 .CH>
		       ":<"
		       <NTH .CH <+ .BASE 1>>
		       !\>
		       <NTH .CH <- .BASE 2>>
		       !\.
		       <NTH .CH <- .BASE 1>>>)
	      (T
	       <STRING <NTH .CH .BASE>
		       !\:
		       <NTH .CH <+ .BASE 1>>
		       !\;
		       <NTH .CH <- .BASE 2>>
		       !\ 
		       <NTH .CH <- .BASE 1>>>)>>

<DEFINE COPY-FILE (CH NAME2 "OPTIONAL" (APPEND? <>) (MODE "PRINT")
		   "AUX" OCH BUF) 
	#DECL ((CH OCH) CHANNEL (MODE NAME2) STRING (BUF) UVECTOR
	       (APPEND?) <OR ATOM FALSE>)
	<COND (<GASSIGNED? BUF> <SET BUF ,BUF>)
	      (<SETG BUF <SET BUF <IUVECTOR 1024>>>)>
	<SET OCH <OPEN .MODE .NAME2>>
	<ACCESS .CH 0>
	<REPEAT (CT)
		<SET CT <MYIOT .BUF .CH>>
		<COND (<0? .CT> <RETURN>)>
		<MYIOT .BUF .OCH .CT>
		<COND (<L? .CT 1024> <RETURN>)>>
	<COND (<NOT <0? <1 .CH>>> <CLOSE .CH>)>
	<COND (.APPEND?
	       <PUT .OCH 17 <FILE-LENGTH .OCH>>)
	      (<CLOSE .OCH>)>>

<COND (<OR <NOT <GASSIGNED? NPACKAGE>> <N==? ,PACKAGE ,NPACKAGE>>
       <SETG OPACKAGE ,PACKAGE>
       <SETG ORPACKAGE ,RPACKAGE>
       <SETG OENTRY ,ENTRY>
       <AND <GASSIGNED? RENTRY> <SETG ORENTRY ,RENTRY>>
       <SETG OENDPACKAGE ,ENDPACKAGE>
       <SETG OUSE ,USE>
       <SETG OUSE-DEFER ,USE-DEFER>)>

""

"SUBTITLE Locking crap"

<DEFINE HARD-LOCK HL (FNM "AUX" CH) 
	#DECL ((HL) ACTIVATION (FNM) STRING (CH) <OR CHANNEL FALSE>)
	<COND (<NOT <SET CH <OPEN "READ" .FNM>>>
	       <COND (<OR <AND <L? ,MUDDLE 100> <==? <3 .CH> 1048576>>
			  <AND <G? ,MUDDLE 100> <==? <3 .CH> 196671>>>
		      <COND (<SET CH <OPEN "PRINT" .FNM>> <CLOSE .CH>)
			    (<RETURN .CH .HL>)>)
		     (<RETURN .CH .HL>)>)
	      (<CLOSE .CH>)>
	<OPEN "PRINTO" .FNM>>

<DEFINE UNLOCK (CHN) #DECL ((CHN) CHANNEL) <CLOSE .CHN>>

""

"SUBTITLE Add and delete packages"

"Add a package to the data base"

<DEFINE LUP-ADD-PACK LAP (FILE
			  "OPTIONAL" (UPDATE? <>) (DATA? T)
			  "AUX" (IND '(1)) U CH PCK ENTL RENTL DB GRP TMP
				(DID-DEL? <>) CRDATE TVAL)
   #DECL ((FILE) STRING (DATA? UPDATE?) <OR ATOM FALSE> (U) UPDB (GRP) LIST
	  (CH) <OR CHANNEL FALSE> (PCK) <OR FALSE STRING> (TVAL) ANY
	  (DID-DEL?) <OR ATOM FALSE> (RENTL ENTL) <LIST [REST ATOM]>
	  (DB) DATA-BASE (LAP) ACTIVATION (CRDATE) FIX)
   <GET-DB>
   <SET U ,CUR-UPD>
   <COND (<SET TVAL
	       <PROG ()
	         <COND (<NOT <SET CH <OPEN "READ" .FILE>>>
			<RETURN .CH>)>
		 <SET CRDATE <CRDATE .CH>>
		 <SET FILE <FILNAME .CH>>
		 <SET GRP <LOAD-PACKAGE .CH>>>>
	  <COND
	   (<AND <NOT <0? ,NO-ENT>>
		 <NOT <ERROR UNBALANCED-PACKAGES
			     LUP-ADD-PACK
			     ERRET-T-TO-CONTINUE>>>)
	   (<SET PCK ,CUR-PACK>
	    <SET ENTL ,CUR-ENTRY>
	    <SET RENTL ,CUR-RENTRY>
	    <COND
	     (<OR <NOT <EMPTY? .ENTL>> <NOT <EMPTY? .RENTL>>>
	      <COND (<NOT <SET TMP <CL .GRP>>>		    ;"Bless the package"
		     <RETURN .TMP .LAP>)>
	      <COND (<PACKAGE-FIND .PCK <UPDB-BASE .U> T>
		     <COND (<AND <NOT .UPDATE?>
				 <NOT <ERROR PACKAGE-ALREADY-EXISTS
					     ERRET-T-TO-REDEFINE
					     LUP-ADD-PACK>>>
			    <RETURN <> .LAP>)>
		     <SETG DB-DEAD <+ ,DB-DEAD 1>>
		     <SET DID-DEL? T>
		     <DO-DEL .PCK .U>	     ;"If it already exists, flush it")>
	      <SETG DB-DEAD <+ ,DB-DEAD 1>>
	      <DO-ADD .PCK .ENTL .RENTL ,CUR-USES ,CUR-USE-DEFERS
		      .CRDATE .FILE .U .DATA?>
	      <COND (.DID-DEL? <SETG DB-DEAD <- ,DB-DEAD 1>>)>
	      <SETG DB-DEAD <- ,DB-DEAD 1>>
	      <DEFER-FIND .PCK <UPDB-BASE .U> T>)
	     (#FALSE ("NO ENTRIES IN PACKAGE"))>)
	   (#FALSE ("FILE DID NOT DEFINE A PACKAGE"))>)
	 (T .TVAL)>>

<DEFINE LOAD-PACKAGE LOAD-ACT (CHN "AUX" GRP (IND '(1)))
  #DECL ((CHN) CHANNEL (LOAD-ACT) <SPECIAL ACTIVATION>)
  <UNWIND
   <PROG ()
     <INIT-LUP-PS>
     <SETG LOAD-CHANNEL .CHN>
     <SET GRP <MAPF ,LIST
		    <FUNCTION ("AUX" TMP)
		      <COND (<==? <SET TMP <READ .CHN '.IND>> .IND> <MAPSTOP>)
			    (T <EVAL .TMP> <MAPRET .TMP>)>>>>
     <SETG LOAD-CHANNEL <>>
     <UNINIT-LUP-PS>
     .GRP>
   <PROG ()
     <SETG LOAD-CHANNEL <>>
     <UNINIT-LUP-PS>
     <COND (<NOT <0? <1 .CHN>>>
	    <CLOSE .CHN>)>>>>

<DEFINE INIT-LUP-PS ()
  <SETG CUR-PACK <>>
  <SETG CUR-ENTRY ()>
  <SETG CUR-RENTRY ()>
  <SETG CUR-USES ()>
  <SETG CUR-USE-DEFERS ()>
  <SETG ALL-USES ()>
  <SETG CUR-TYPE <>>
  <SETG NO-ENT 0>
  <SETG PACKAGE ,NPACKAGE>
  <SETG RPACKAGE ,NRPACKAGE>
  <SETG ENTRY ,NENTRY>
  <SETG RENTRY ,NRENTRY>
  <SETG ENDPACKAGE ,NENDPACKAGE>
  <SETG USE ,NUSE>
  <SETG EXTERNAL ,NUSE>
  <SETG USE-DEFER ,NUSE-DEFER>>

<DEFINE UNINIT-LUP-PS ()
  <SETG PACKAGE ,OPACKAGE>
  <SETG RPACKAGE ,ORPACKAGE>
  <SETG ENTRY ,OENTRY>
  <SETG RENTRY ,ORENTRY>
  <SETG ENDPACKAGE ,OENDPACKAGE>
  <SETG USE ,OUSE>
  <SETG EXTERNAL ,OUSE>
  <SETG USE-DEFER ,OUSE-DEFER>>

<DEFMAC STRL ('STR) <FORM STRLC <FORM LENGTH .STR>>>

<DEFMAC STRLC ('LEN) 
	<FORM +
	      <FORM / .LEN 5>
	      <FORM COND (<FORM 0? <FORM MOD .LEN 5>> 0) (1)>>>
""

; "Magic error handler"
<DEFINE LUP-ERROR-HANDLER (FRM "TUPLE" JUNK "AUX" (OUTCHAN .OUTCHAN) O ATM)
  #DECL ((FRM) FRAME (JUNK) TUPLE (OUTCHAN) CHANNEL)
  <COND (<AND <NOT <EMPTY? .JUNK>>
	      <N==? <1 .JUNK> FILE-SYSTEM-ERROR!-ERRORS>
	      <N==? <1 .JUNK> CONTROL-G?!-ERRORS>
	      <NOT <AND <==? 3 <LENGTH .JUNK>>
			<OR <AND <==? <1 .JUNK> UNASSIGNED-VARIABLE!-ERRORS>
				 <==? <3 .JUNK> GVAL>>
			    <AND <==? <1 .JUNK> UNBOUND-VARIABLE!-ERRORS>
				 <OR <==? <3 .JUNK> VALUE>
				     <==? <3 .JUNK> CALLER>>>>
			<TYPE? <SET ATM <2 .JUNK>> ATOM>
			<COND (<==? <SET O <OBLIST? .ATM>> <ROOT>>
			       <GET .ATM USE-DEFER>)
			      (.O <GET .O USE-DEFER>)>>>
	      <ASSIGNED? LOAD-ACT>
	      <TYPE? .LOAD-ACT ACTIVATION>
	      <LEGAL? .LOAD-ACT>>
	 <COND (<AND <GASSIGNED? CUR-PACK>
		     ,CUR-PACK>
		<TELL "Flushing load of package " ,CUR-PACK
		      ":  error during loading.">
		<MAPF <> <FUNCTION (X) <PRINC .X> <PRINC !\ >> .JUNK>
		<CRLF>)
	       (<TELL "Flushing load of current package:">
		<MAPF <> <FUNCTION (X) <PRINC .X> <PRINC !\ >> .JUNK>
		<CRLF>)>
	 <COND (<G? ,NO-ENT 0>
		<REPEAT ((NE ,NO-ENT))
		  #DECL ((NE) FIX)
		  <ENDPACKAGE>
		  <COND (<0? <SET NE <- .NE 1>>> <RETURN>)>>
		<SETG NO-ENT 0>)>
	 <INT-LEVEL 0>
	 <RETURN <CHTYPE (!.JUNK) FALSE>
		 .LOAD-ACT>)>>

<ON "ERROR" ,LUP-ERROR-HANDLER 100> 

<DEFINE DO-ADD (PCK ENTL RENTL USES USE-DEFERS CRDATE FILE U DATA?
		"AUX" (DB <UPDB-BASE .U>) HASH UV PCK-DATA FILLEN PCKLEN
		      (OLD-ENT 0) DAT-ENTLEN DAT-ACCESS (SAVE-ENTL .ENTL)
		      (SAVE-RENTL .RENTL))
	#DECL ((FILE PCK) STRING (ENTL) <LIST [REST ATOM]> (U) UPDB
	       (DB) DATA-BASE (DATA?) <OR ATOM FALSE> (DAT-ENTLEN) <OR FALSE FIX>
	       (DAT-ACCESS CRDATE OLD-ENT FILLEN PCKLEN PCK-DATA HASH) FIX
	       (USES USE-DEFERS) <LIST [REST STRING]>
	       (RENTL) <OR FALSE <LIST [REST ATOM]>> (UV) <UVECTOR [REST FIX]>)
	<SET UV <DB-HASH-MAP .DB>>		        ;"Get to the hash table"
	<SET HASH <HASH-NAME .PCK .UV ,HLEN1>>
	<SET FILLEN <STRL .FILE>>
	<SET PCKLEN <STRL .PCK>>
	<SETG DB-DEAD <+ ,DB-DEAD 1>>	    ;"Data base is no longer consistent"
	<SET PCK-DATA
	     <ALLOC .DB						    ;"Data base"
		    <+ .FILLEN .PCKLEN ,PACKAGE-NAMEBEG>      ;"Length of entry"
		    <NTH .UV .HASH>	   ;"Bucket address (try to be close)">>
	<BUCKET-ADD .DB <- .HASH 1> .PCK-DATA>		        ;"Add to bucket"
	<SET UV <DB-ACCESS .DB .PCK-DATA>>
	<STR-BLT .UV .PCK ,PACKAGE-NAMEBEG ,BUCKET>
	<STR-BLT .UV .FILE <+ ,PACKAGE-NAMEBEG .PCKLEN> ,FCNCHAIN>
							   ;"Put string data in"
	<TYPHACK .UV ,FCNCHAIN <COND (,CUR-TYPE 1) (0)>>
						   ;"Package type--1-->RPACKAGE"
	<TYPHACK .UV ,BUCKET 1>			      ;"This is a package entry"
	<REPEAT (ENT-DATA NAMLEN STR OFF (TBIT 0))
		#DECL ((TBIT OFF ENT-DATA NAMLEN) FIX (STR) STRING)
		<COND (<EMPTY? .ENTL>
		       <COND (<AND .RENTL <NOT <EMPTY? .RENTL>>>
			      <SET ENTL .RENTL>
			      <SET RENTL <>>
			      <SET TBIT 1>)
			     (<RETURN>)>)>
		<SET STR <SPNAME <1 .ENTL>>>
		<SET NAMLEN <STRL .STR>>
		<SET HASH <HASH-NAME .STR <SET UV <DB-HASH-MAP .DB>> ,HLEN2>>
		<SET ENT-DATA
		     <ALLOC .DB
			    <+ .NAMLEN 1 ,FUNCTION-NAMEBEG>
			    <NTH .UV .HASH>>>
		<BUCKET-ADD .DB <- .HASH 1> .ENT-DATA>
		<SET UV <DB-ACCESS .DB .ENT-DATA>>
		<STR-BLT .UV .STR ,FUNCTION-NAMEBEG ,BUCKET>
							    ;"Put in entry name"
		<PTRHACK .UV ,FCNCHAIN .OLD-ENT>
				        ;"Chain to previous entry (initially 0)"
		<TYPHACK .UV ,FCNCHAIN .TBIT>		     ;"Entry or rentry?"
		<TYPHACK .UV ,BUCKET 0>			        ;"Not a package"
		<SET OLD-ENT .ENT-DATA>
		<PUT .UV <SET OFF <+ ,FUNCTION-NAMEBEG 1 .NAMLEN>> .PCK-DATA>
						       ;"Point to package entry"
		<SET ENTL <REST .ENTL>>>
	<SET UV <DB-ACCESS .DB .PCK-DATA>>
	<PUT .UV <+ ,PACKAGE-CRDATE 1> .CRDATE>
	<SET DAT-ACCESS <17 <UPDB-DATFILE .U>>>
	<COND (<OR <NOT .DATA?>
		   <NOT <SET DAT-ENTLEN <WRITE-PACKAGE .PCK
				   ,CUR-TYPE
				   .SAVE-ENTL
				   .SAVE-RENTL
				   .USES
				   .USE-DEFERS
				   <UPDB-DATFILE .U>>>>>
	       <PUT .UV <+ ,PACKAGE-ACCESS 1> -1>
	       <PUT .UV <+ ,PACKAGE-ENTLEN 1> 0>
	       <PUT .UV <+ ,PACKAGE-CRDATE 1> -1>)
	      (<PUT .UV <+ ,PACKAGE-ACCESS 1> .DAT-ACCESS>
	       <PUT .UV <+ ,PACKAGE-ENTLEN 1> .DAT-ENTLEN>)>
	<PTRHACK .UV ,FCNCHAIN .OLD-ENT> ;"Make package point to function entry"
	<SETG DB-DEAD <- ,DB-DEAD 1>>>

""

"SUBTITLE Bless a package"

"This was all stolen straight from the old LUP, with modifications to
allow for the different method of acquiring package names and entries."

<DEFINE COB (ATM "AUX" (FOO .ATM) (R <ROOT>) (I <GET INITIAL OBLIST>)) 
   #DECL ((ATM) ATOM (R I) OBLIST)
   <REPEAT ()
	   <COND
	    (<OR <NOT <SET FOO <OBLIST? .FOO>>> <==? .FOO .R>> <RETURN>)
	    (<==? .FOO .I>
	     <RETURN <CHTYPE (<STRING "ATOM, "
				      <PROG ((OBLIST ()))
					    #DECL ((OBLIST) <SPECIAL ANY>)
					    <UNPARSE .ATM>>
				      ", GOES THROUGH INITIAL">)
			     FALSE>>)
	    (<NOT <SET FOO <GET .FOO OBLIST>>> <RETURN>)>>>

<DEFINE CL (LST "AUX" (GOOD-OB <ROOT>) TF TA TMP FROB) 
	#DECL ((LST) LIST (GOOD-OB) <OR OBLIST FALSE> (TF) FORM (TA) ATOM
	       (FROB) ANY)
	<REPEAT ()
		<COND (<EMPTY? .LST> <RETURN T>)
		      (<AND <TYPE? <SET FROB <1 .LST>> FORM>
			    <NOT <EMPTY? <SET TF .FROB>>>>
		       <COND (<==? <1 .TF> PACKAGE>
			      <SET GOOD-OB
				   <GET <LOOKUP <2 .TF> <GET PACKAGE OBLIST>>
					OBLIST>>)
			     (<==? <1 .TF> ENDPACKAGE> <SET GOOD-OB <ROOT>>)
			     (<==? <1 .TF> DEFINE>
			      <COND (<NOT <SET TMP <CPL .TF T>>>
				     <RETURN .TMP>)>)
			     (<AND <==? <1 .TF> SETG>
				   <APPLICABLE? ,<SET TMP <GATM <2 .TF>>>>
				   <NOT <TYPE? ,.TMP FIX>>>
			      <COND (<NOT <SET TMP <CPL .TF T>>>
				     <RETURN .TMP>)>)
			     (T
			      <COND (<NOT <SET TMP <CPL .TF <>>>>
				     <RETURN .TMP>)>)>)
		      (<==? <PRIMTYPE .FROB> LIST>
		       <COND (<NOT <SET TMP <CPL .FROB <>>>> <RETURN .TMP>)>)
		      (<STRUCTURED? .FROB>
		       <COND (<NOT <SET TMP <CPA .FROB <>>>> <RETURN .TMP>)>)
		      (<TYPE? .FROB ATOM>
		       <COND (<NOT <SET TMP <COB .FROB>>> <RETURN .TMP>)>)>
		<SET LST <REST .LST>>>>

<DEFINE CPL (ITM OK-T-F "AUX" TMP) 
	#DECL ((ITM) <PRIMTYPE LIST>)
	<PROG ()
	      <COND (<EMPTY? .ITM> <RETURN>)
		    (<AND <NOT .OK-T-F> <TYPE? .ITM FORM> <==? <1 .ITM> FLOAD>>
		     <RETURN #FALSE ("FLOAD ENCOUNTERED")>)>
	      <REPEAT ()
		      <COND (<EMPTY? .ITM> <RETURN>)
			    (<TYPE? <1 .ITM> ATOM>
			     <COND (<NOT <SET TMP <COB <1 .ITM>>>>
				    <RETURN .TMP>)>)
			    (<==? <PRIMTYPE <1 .ITM>> LIST>
			     <COND (<NOT <SET TMP <CPL <1 .ITM> .OK-T-F>>>
				    <RETURN .TMP>)>)
			    (<STRUCTURED? <1 .ITM>>
			     <COND (<NOT <SET TMP <CPA <1 .ITM> .OK-T-F>>>
				    <RETURN .TMP>)>)>
		      <SET ITM <REST .ITM>>>>>

<DEFINE CPA (ITM OK-T-F "AUX" TMP) 
	#DECL ((ITM) STRUCTURED)
	<COND (<OR <TYPE? .ITM STRING>
		   <AND <==? <PRIMTYPE .ITM> UVECTOR>
			<==? <TYPEPRIM <UTYPE .ITM>> WORD>>>
	       T)
	      (<TYPE? .ITM RSUBR-ENTRY>
	       <COND (<G=? <LENGTH .ITM> 3> <CPL <3 .ITM> .OK-T-F>) (T)>)
	      (T
	       <REPEAT ()
		       <COND (<EMPTY? .ITM> <RETURN>)
			     (<TYPE? <1 .ITM> ATOM>
			      <COND (<NOT <SET TMP <COB <1 .ITM>>>>
				     <RETURN .TMP>)>)
			     (<==? <PRIMTYPE <1 .ITM>> LIST>
			      <COND (<NOT <SET TMP <CPL <1 .ITM> .OK-T-F>>>
				     <RETURN .TMP>)>)
			     (<STRUCTURED? <1 .ITM>>
			      <COND (<NOT <SET TMP <CPA <1 .ITM> .OK-T-F>>>
				     <RETURN .TMP>)>)>
		       <SET ITM <REST .ITM>>>)>>

<DEFINE GATM (ITM) 
	<COND (<TYPE? .ITM ATOM> .ITM)
	      (<GET .ITM VALUE>)
	      (<AND <TYPE? .ITM FORM>
		    <==? <LENGTH .ITM> 2>
		    <==? <1 .ITM> ENTRY>>
	       <2 .ITM>)
	      (T <ERROR BAD-FIRST-ARG-TO-DEFINE-OR-SETG!-ERRORS .ITM>)>>

""

"Add a datum"

<DEFINE LUP-ADD-DATUM LAD (NM FIL "OPTIONAL" (UPDATE? <>) "AUX" U (DID-DEL?
								   <>)) 
	#DECL ((NM FIL) STRING (U) UPDB (DID-DEL?) <OR ATOM FALSE>)
	<GET-DB>
	<SET U ,CUR-UPD>
	<COND (<PACKAGE-FIND .NM <UPDB-BASE .U> T>
	       <COND (<AND <NOT .UPDATE?>
			   <NOT <ERROR DATUM-ALREADY-EXISTS
				       ERRET-T-TO-REDEFINE
				       LUP-ADD-DATUM>>>
		      <RETURN <> .LAD>)>
	       <SETG DB-DEAD <+ ,DB-DEAD 1>>
	       <SET DID-DEL? T>
	       <DO-DEL .NM .U>		     ;"If it already exists, flush it")>
	<SETG DB-DEAD <+ ,DB-DEAD 1>>
	<DO-ADD .NM () () () () -1 .FIL ,CUR-UPD <>>
	<SETG DB-DEAD <- ,DB-DEAD 1>>
	<COND (.DID-DEL? <SETG DB-DEAD <- ,DB-DEAD 1>>)>
	<DEFER-FIND .NM <UPDB-BASE .U> <>>>

"Delete things"

<DEFINE LUP-DEL (PCK "AUX" U) 
	#DECL ((PCK) STRING (U) UPDB)
	<GET-DB>
	<SET U ,CUR-UPD>
	<COND (<PACKAGE-FIND .PCK <UPDB-BASE .U> T> <DO-DEL .PCK .U>)
	      (#FALSE ("PACKAGE NOT FOUND"))>>

""

"Delete a package from the data base"

<DEFINE DO-DEL (PCK U "AUX" (DB <UPDB-BASE .U>) UV BUCKET OB NB FCHAIN TMP HASH)
 
   #DECL ((PCK) STRING (U) UPDB (DB) DATA-BASE
	  (BUCKET NB OB FCHAIN HASH CENT) FIX (UV) <UVECTOR [REST FIX]>)
   <SET UV <DB-HASH-MAP .DB>>
   <SET HASH <HASH-NAME .PCK .UV ,HLEN1>>
   <SET OB <- .HASH 1>>
   <SET BUCKET <NTH .UV .HASH>>
   <SETG DB-DEAD <+ ,DB-DEAD 1>>
   <REPEAT ()
	   <COND (<0? .BUCKET> <ERROR PACKAGE-NOT-FOUND .PCK DO-DEL>)
		 (T
		  <SET UV <DB-ACCESS .DB .BUCKET>>
		  <COND (<STRING=? .UV .PCK>
			 <SET FCHAIN <PTRHACK .UV ,FCNCHAIN>>
						    ;"Pointer to function chain"
			 <SET NB <PTRHACK .UV ,BUCKET>>
					        ;"Pointer to next elt in bucket"
			 <DE-ALLOC .DB
				   <+ ,PACKAGE-NAMEBEG
				      <STRLC <LENHACK .UV ,BUCKET>>
				      <STRLC <LENHACK .UV ,FCNCHAIN>>>
				   .BUCKET>	      ;"De-allocate the storage"
			 <SET UV <DB-ACCESS .DB .OB>>
			 <PTRHACK .UV ,BUCKET .NB>
					     ;"Splice this guy out of the chain"
			 <RETURN>)
			(<SET OB .BUCKET>
			 <SET BUCKET <PTRHACK .UV ,BUCKET>>)>)>>
 ;
"Now whip down the function chain, deleting each item and splicing it
    out of its hash bucket.  Boy is this a pain."
   <REPEAT ((SBUF ,SBUF) NC NB LEN SL B TMP)
	   #DECL ((SBUF) <UVECTOR [REST FIX]> (NC NB LEN SL B TMP) FIX)
	   <COND (<0? .FCHAIN> <RETURN>)>
	   <SET UV <DB-ACCESS .DB .FCHAIN>>
	   <SET NC <PTRHACK .UV ,FCNCHAIN>>		  ;"Next thing on chain"
	   <SET NB <PTRHACK .UV ,BUCKET>>	  ;"Next element in this bucket"
	   <SET LEN
		<+ ,FUNCTION-NAMEBEG
		   <SET TMP <STRLC <SET SL <LENHACK .UV ,BUCKET>>>>
		   1>>
	   <SUBSTRUC .UV ,FUNCTION-NAMEBEG .TMP .SBUF> ;"Copy the function name"
	   <DB-HASH-MAP .DB>
	   <SET B <HASH-NAME <MAKE-STRING .SBUF .SL> <DB-DATA .DB> ,HLEN2>>
	   <SET UV <DB-ACCESS .DB <- .B 1>>>
	   <REPEAT ()
		   <COND (<==? <SET B <PTRHACK .UV ,BUCKET>> .FCHAIN>
							    ;"Found the pointer"
			  <PTRHACK .UV ,BUCKET .NB>	        ;"Splice it out"
			  <DE-ALLOC .DB .LEN .FCHAIN>
			  <RETURN>)
			 (<0? .B> <ERROR DATA-BASE-MUNGED .PCK .SBUF DO-DEL>)
			 (<SET UV <DB-ACCESS .DB .B>>)>>
	   <SET FCHAIN .NC>>
   <SETG DB-DEAD <- ,DB-DEAD 1>>>

<SETG SBUF <IUVECTOR 12 0>>

""

"SUBTITLE Write out data file entry"

<DEFINE WRITE-PACKAGE WP (NAME RPACKAGE? ENTRIES RENTRIES USES USE-DEFERS
			  OUTCHAN
		       "AUX" (FORMCT 0) (ACCPTR <17 .OUTCHAN>) (MANIFESTS ())
			     (GDECLS ()) OBLIST ATM
			     (PAD-STRING <REST "     " 5>) TMP
			     AUX-ENT NEEDED RES)
	#DECL ((NAME) STRING (ATM RPACKAGE?) <OR ATOM FALSE>
	       (OBLIST) <SPECIAL <LIST [REST OBLIST]>> (GDECLS) LIST
	       (MANIFESTS ENTRIES RENTRIES AUX-ENT NEEDED) <LIST [REST ATOM]>
	       (USES USE-DEFERS) <LIST [REST STRING]> (OUTCHAN) CHANNEL
	       (TMP FORMCT ACCPTR) FIX (RES) <OR FALSE <VECTOR [2 LIST]>>)
	<COND (<AND <SET ATM <LOOKUP .NAME <GET PACKAGE OBLIST>>>
		    <GASSIGNED? .ATM>>
	       <SET OBLIST ,.ATM>)
	      (T <ERROR PACKAGE-HAS-NO-OBLIST? WRITE-PACKAGE>)>
	<COND (<NOT <SET RES <MACRO-GROVEL .ENTRIES .RENTRIES <1 .OBLIST>>>>
	       <TELL "Package " .NAME " can't have datfile entry.">
	       <RETURN <> .WP>)>
	<SET AUX-ENT <1 .RES>>
	<SET NEEDED <2 .RES>>
	<PRINC !\<>
	<COND (.RPACKAGE? <PRINC "RPACKAGE ">) (T <PRINC "PACKAGE ">)>
	<PRIN1 .NAME>
	<PRINC !\>>				  ;"Write out <PACKAGE \"FOO\">"
	<SET FORMCT <+ .FORMCT 1>>
	<COND (<NOT <EMPTY? .ENTRIES>>
	       <PRIN1 <CHTYPE (ENTRY !.ENTRIES) FORM>>
	       <SET FORMCT <+ .FORMCT 1>>)>		  ;"Entries for package"
	<COND (<NOT <EMPTY? .RENTRIES>>
	       <PRIN1 <CHTYPE (RENTRY !.RENTRIES) FORM>>
	       <SET FORMCT <+ .FORMCT 1>>)>			     ;"Rentries"
	<COND (<NOT <EMPTY? .USES>>
	       <PRIN1 <CHTYPE (USE !.USES) FORM>>
	       <SET FORMCT <+ .FORMCT 1>>)>				 ;"USEs"
	<COND (<NOT <EMPTY? .USE-DEFERS>>
	       <PRIN1 <CHTYPE (USE !.USE-DEFERS) FORM>>
	       <SET FORMCT <+ .FORMCT 1>>)>			   ;"USE-DEFERs"
	<COND (<NOT <EMPTY? .ENTRIES>>
	       <PUTREST <REST .ENTRIES <- <LENGTH .ENTRIES> 1>> .RENTRIES>)
	      (<SET ENTRIES .RENTRIES>)>
	<COND (<NOT <EMPTY? .ENTRIES>>
	       <PUTREST <REST .ENTRIES <- <LENGTH .ENTRIES> 1>> .AUX-ENT>)
	      (<SET ENTRIES .AUX-ENT>)>
	<MAPF <>
	      <FUNCTION (X "AUX" RND) 
		      #DECL ((X) ATOM (RND) ANY)
		      <COND (<VALID-TYPE? .X>
			     <PRINC "<NEWTYPE ">
			     <PRIN1 .X>
			     <PRINC " ">
			     <PRIN1 <TYPEPRIM .X>>
			     <COND (<SET RND <GET .X DECL>>
				    <PRINC !\'>
				    <PRIN1 .RND>)>
			     <PRINC !\>>
			     <SET FORMCT <+ .FORMCT 1>>)
						  ;"<NEWTYPE FOO BAR '<BLETCH>>"
			    (<SET RND <GET .X DECL>>
			     <PRINC "<PUT ">
			     <PRIN1 .X>
			     <PRINC " DECL ">
			     <PRIN1 .RND>
			     <PRINC !\>>
			     <SET FORMCT <+ .FORMCT 1>>)>
							 ;"<PUT FOO DECL 'FEEP>"
		      <COND (<GASSIGNED? .X>
			     <COND (<MANIFEST? .X>
				    <PRINC "<SETG ">
				    <PRIN1 .X>
				    <PRINC " ">
				    <PRIN1 ,.X>
				    <PRINC !\>>
				    <SET MANIFESTS (.X !.MANIFESTS)>
				    <SET FORMCT <+ .FORMCT 1>>)
						   ;"<SETG FOO 1><MANIFEST FOO>"
				   (<AND <TYPE? <SET RND ,.X> RSUBR-ENTRY RSUBR>
					 <G=? <LENGTH .RND> 3>>
				    <PRINC "<SETG ">
				    <PRIN1 .X>
				    <PRINC 
" %<RSUBR-ENTRY '[\\ \\ F!- ">
				    <PRIN1 .X>
				    <PRINC " ">
				    <PRIN1 <3 .RND>>
				    <PRINC "] 0>>">
				    <SET FORMCT <+ .FORMCT 1>>)	       ;"RSUBRs"
				   (<AND <MONAD? .RND>
					 <MEMQ .X .NEEDED>>
				    <PRINC "<SETG ">
				    <PRIN1 .X>
				    <PRINC " ">
				    <PRIN1 .RND>
				    <PRINC ">">
				    <SET FORMCT <+ .FORMCT 1>>)
				   (<TYPE? .RND MACRO>
				    <PRINC "<SETG ">
				    <PRIN1 .X>
				    <PRINC !\ >
				    <PRIN1 .RND>
				    <PRINC !\>>
				    <SET FORMCT <+ .FORMCT 1>>)>)>     ;"MACROs"
		      <COND (<AND <GBOUND? .X>
				  <NOT <MANIFEST? .X>>
				  <SET RND <GET-DECL <GLOC .X>>>>
			     <SET GDECLS ((.X) .RND !.GDECLS)>)>>
							    ;"Accumulate GDECLs"
	      .ENTRIES>
	<COND (<NOT <EMPTY? .MANIFESTS>>
	       <PRIN1 <CHTYPE (MANIFEST !.MANIFESTS) FORM>>
	       <SET FORMCT <+ .FORMCT 1>>)>
	<COND (<NOT <EMPTY? .GDECLS>>
	       <PRIN1 <CHTYPE (GDECL !.GDECLS) FORM>>
	       <SET FORMCT <+ .FORMCT 1>>)>
	<PRINC "<ENDPACKAGE>">
	<SET FORMCT <+ .FORMCT 1>>
	<COND (<G? <SET TMP <MOD <17 .OUTCHAN> 5>> 0>
	       <PRINC <BACK .PAD-STRING <- 5 .TMP>>>)>  ;"Fill to word boundary"
	<CHTYPE <PUTBITS .FORMCT <BITS 18 18> <- <17 .OUTCHAN> .ACCPTR>> FIX>>
""
<DEFINE MACRO-GROVEL MG (ENTRIES RENTRIES IOBL "AUX" (RES [()()]) ENTS)
  #DECL ((MG) ACTIVATION (ENTRIES RENTRIES) <LIST [REST ATOM]>
	 (RES) <OR VECTOR FALSE>)
  <SET ENTS (!.RENTRIES !.ENTRIES)>
  <MAPF <>
    <FUNCTION (X)
      <COND (<NOT <SET RES <ENTRY-BLESS .X .RES .ENTS .IOBL>>>
	     <RETURN <> .MG>)>>
    .ENTS>
  .RES>

<DEFINE ENTRY-BLESS EB (X RES ENTS IOBL "AUX" TMP)
  #DECL ((EB) ACTIVATION (X) ATOM (RES) <OR VECTOR FALSE> (ENTS) <LIST [REST ATOM]>)
  <COND (<AND <GASSIGNED? .X>
	      <TYPE? <SET TMP ,.X> MACRO>>
	 <COND (<TYPE? <SET TMP <1 .TMP>> RSUBR>
		<MAPF <>
		  <FUNCTION (X "AUX" ATM)
		    <COND (<TYPE? .X LOCR>
			   <COND (<NOT <SET RES <VERIFY-GVAL <LOCR-TO-ATOM .X>
							     .RES .ENTS .IOBL>>>
				  <RETURN <> .EB>)>)
			  (<TYPE? .X ATOM>
			   <RETURN <> .EB>)>>
		  .TMP>)
	       (T
		<LIST-BLESS .TMP .RES .ENTS .IOBL>)>)
	(.RES)>>

<DEFINE LIST-BLESS LB (LST RES ENTS IOBL)
  #DECL ((LST) <PRIMTYPE LIST> (ENTS) <LIST [REST ATOM]> (RES) <OR VECTOR FALSE>)
  <MAPF <>
    <FUNCTION (X)
      <COND (<AND <TYPE? .X LIST>
		  <NOT <EMPTY? .X>>>
	     <COND (<NOT <SET RES <LIST-BLESS .X .RES .ENTS .IOBL>>>
		    <RETURN <> .LB>)>)
	    (<TYPE? .X FORM>
	     <COND (<AND <NOT <EMPTY? .X>>
			 <TYPE? <1 .X> ATOM>>
		    <COND (<AND <==? <1 .X> GVAL>
				<G? <LENGTH .X> 1>
				<TYPE? <2 .X> ATOM>>
			   <COND (<NOT <SET RES <VERIFY-GVAL <2 .X> .RES .ENTS .IOBL>>>
				  <RETURN <> .LB>)>)
			  (<NOT <SET RES <VERIFY-GVAL <1 .X> .RES .ENTS .IOBL>>>
			   <RETURN <> .LB>)
			  (<NOT <EMPTY? <REST .X>>>
			   <COND (<NOT <SET RES <LIST-BLESS <REST .X> .RES .ENTS .IOBL>>>
				  <RETURN <> .LB>)>)>)
		   (<NOT <EMPTY? .X>>
		    <COND (<NOT <SET RES <LIST-BLESS .X .RES .ENTS .IOBL>>>
			   <RETURN <> .LB>)>)>)>>
    .LST>
  .RES>

<DEFINE VERIFY-GVAL (ATM RES ENTS IOBL "AUX" RND)
  #DECL ((IOBL) OBLIST (ATM) ATOM (RES) <VECTOR [2 LIST]> (ENTS) <LIST [REST ATOM]>)
  <COND (<MEMQ .ATM <1 .RES>> .RES)
	(<MEMQ .ATM .ENTS>
	 <COND (<OR <NOT <GASSIGNED? .ATM>>
		    <MANIFEST? .ATM>
		    <MONAD? <SET RND ,.ATM>>
		    <TYPE? .RND MACRO>>
		<PUT .RES 2 (.ATM !<2 .RES>)>)>)
	(<N==? <OBLIST? .ATM> .IOBL> .RES)
	(<OR <NOT <GASSIGNED? .ATM>>
	     <MANIFEST? .ATM>
	     <MONAD? <SET RND ,.ATM>>
	     <TYPE? .RND MACRO>>
	 <PUT .RES 1 (.ATM !<1 .RES>)>
	 <PUT .RES 2 (.ATM !<2 .RES>)>)>>

""

"SUBTITLE Free storage management"

"Free LEN words at ADDR"

<DEFINE DE-ALLOC (DB LEN ADDR
		  "AUX" UV NEW (OLD ,FREEPT) (AP </ .ADDR 1024>) NP
			(LOWB <+ .ADDR .LEN>)
			(HIGHB <+ .LOWB <- ,DB-MIN-ENTRY 1>>) NLOW NLEN)
   #DECL ((DB) DATA-BASE (LOWB HIGHB AP NP OLD LEN ADDR NEW) FIX
	  (UV) <UVECTOR [REST FIX]>)
   <SET UV <DB-HASH-MAP .DB>>
   <SET NEW <NTH .UV <+ ,FREEPT 1>>>
   <REPEAT ()
	   <COND (<0? .NEW> <ADD-FREE-CHAIN .DB .ADDR .OLD .NEW .LEN> <RETURN>)>
	   <SET UV <DB-ACCESS .DB .NEW>>
	   <COND (<==? .AP <SET NP </ .NEW 1024>>>		   ;"Same page?"
		  <COND (<AND <G=? .NEW .LOWB> <L=? .NEW .HIGHB>>
						       ;"Can we merge into one?"
			 <SET LEN <+ .LEN <LENHACK .UV ,BUCKET> <- .NEW .LOWB>>>
			 <SET NEW <PTRHACK .UV ,BUCKET>>
			 <PUT .UV <+ ,BUCKET 1> 0>
			 <ADD-FREE-CHAIN .DB .ADDR .OLD .NEW .LEN>
			 <RETURN>)
			(<AND <G=? .ADDR
				   <SET NLOW
					<+ .NEW
					   <SET NLEN <LENHACK .UV ,BUCKET>>>>>
			      <L=? .ADDR <+ .NLOW <- ,DB-MIN-ENTRY 1>>>>
			 <ZERO .DB .ADDR .LEN>
			 <SET UV <DB-ACCESS .DB .NEW>>
			 <LENHACK .UV ,BUCKET <+ .LEN .NLEN <- .ADDR .NLOW>>>
			 <RETURN>)>
		  <ADD-FREE-CHAIN .DB .ADDR .OLD .NEW .LEN>
		  <RETURN>)
		 (<L? .NEW .ADDR>      ;"Past the place where we want to put it"
		  <ADD-FREE-CHAIN .DB .ADDR .OLD .NEW .LEN>
		  <RETURN>)
		 (T <SET OLD .NEW> <SET NEW <PTRHACK .UV ,BUCKET>>)>>>

"Add LEN words to free chain at ADDR"

<DEFINE ADD-FREE-CHAIN (DB ADDR OLD NEW LEN "AUX" UV) 
	#DECL ((DB) DATA-BASE (ADDR OLD NEW LEN) FIX)
	<DB-ACCESS .DB .ADDR>
	<ZERO .DB .ADDR .LEN>
	<LENHACK <DB-DATA .DB> ,BUCKET .LEN>
	<PTRHACK <DB-DATA .DB> ,BUCKET .NEW>
	<SET UV <DB-ACCESS .DB .OLD>>
	<PTRHACK .UV ,BUCKET .ADDR>>

"Allocate free storage"

<DEFINE ALLOC (DB LEN TARG
	       "AUX" UV (BEST 0) OBEST CCH OCCH (TPG </ .TARG 1024>) NPG)
	#DECL ((DB) DATA-BASE (TPG CCH OCCH LEN TARG BEST OBEST) FIX
	       (UV) UVECTOR)
	<DB-HASH-MAP .DB>
	<SET OCCH ,FREEPT>
	<SET CCH <NTH <DB-DATA .DB> <+ ,FREEPT 1>>>	   ;"Current free chain"
	<REPEAT ()
		<COND (<0? .CCH>
		       <COND (<0? .BEST> <RETURN <GROW-ALLOC .DB .LEN>>)
			     (<RETURN <DO-ALLOC .DB .BEST .OBEST .LEN>>)>)>
		<COND (<G=? <LENHACK <SET UV <DB-ACCESS .DB .CCH>> ,BUCKET>
			    .LEN>			     ;"Will fit, anyway"
		       <COND (<OR <0? .TPG>			   ;"Don't care"
				  <==? <SET NPG </ .CCH 1024>> .TPG>>
							      ;"In winning area"
			      <RETURN <DO-ALLOC .DB .CCH .OCCH .LEN>>)
			     (<L? .CCH .TARG>		   ;"Already passed it?"
			      <COND (<0? .BEST>
				     <RETURN <DO-ALLOC .DB .CCH .OCCH .LEN>>)
				    (<RETURN <DO-ALLOC .DB
						       .BEST
						       .OBEST
						       .LEN>>)>)
			     (<SET BEST .CCH> <SET OBEST .OCCH>)>)>
		<SET OCCH .CCH>
		<SET CCH <PTRHACK .UV ,BUCKET>>>>

"Allocate LEN words at CCH, fixing up free chain pointers and such"

<DEFINE DO-ALLOC (DB CCH OCCH LEN "AUX" UV VAL REM) 
	#DECL ((DB) DATA-BASE (VAL OCCH CCH LEN) FIX (UV) UVECTOR)
	<SET UV <DB-ACCESS .DB .CCH>>
	<SET VAL <+ .CCH <SET REM <- <LENHACK .UV ,BUCKET> .LEN>>>>
	<COND (<G=? .REM ,DB-MIN-ENTRY> <LENHACK .UV ,BUCKET .REM>)
	      (<SET CCH <PTRHACK .UV ,BUCKET>>	   ;"Get next elt in free chain"
	       <PTRHACK .UV ,BUCKET 0>		      ;"Zero this guy's pointer"
	       <SET UV <DB-ACCESS .DB .OCCH>>
					     ;"Go to previous elt in free chain"
	       <PTRHACK .UV ,BUCKET .CCH>		      ;"Point to next")>
	.VAL>

"Grow the data base by a page"

<DEFINE GROW-ALLOC (DB LEN
		    "AUX" UV NF OF GB (CH <DB-CHAN .DB>) (FL <DB-FLEN .DB>))
	#DECL ((DB) DATA-BASE (NF OF FL LEN) FIX (CH) CHANNEL
	       (UV GB) <UVECTOR [REST FIX]>)
	<COND (<NOT <GASSIGNED? GROW-BUF>>
	       <SETG GROW-BUF <SET GB <IUVECTOR 1024 0>>>
	       <PUT .GB 1023 4295229440>			   ;"UTYPE FIX")
	      (<SET GB ,GROW-BUF>)>
	<COND (<L? ,MUDDLE 100>
	       <RESET .CH>
	       <ACCESS .CH .FL>
	       <PRINTB .GB .CH>
	       <RESET .CH>)
	      (T <ACCESS .CH .FL> <PRINTB .GB .CH>)>
	<PUT .DB ,DB-FLEN <+ .FL <LENGTH .GB>>>			  ;"Grow the db"
	<SET UV <DB-HASH-MAP .DB>>
	<SET OF <NTH .UV <+ ,FREEPT 1>>>       ;"Add to beginning of free chain"
	<PUT .UV <+ ,FREEPT 1> <SET NF <+ .FL .LEN>>>
	<SET UV <DB-ACCESS .DB .NF>>
	<PUT .UV <+ ,BUCKET 1> <CHTYPE <PUTBITS .OF ,LENGET <- 1022 .LEN>> FIX>>
	.FL>

"Add a new entry to the end of a hash bucket"

<DEFINE BUCKET-ADD (DB HASH ADDR "AUX" UV) 
	#DECL ((DB) DATA-BASE (HASH ADDR) FIX (UV) UVECTOR)
	<SET UV <DB-ACCESS .DB .HASH>>
	<REPEAT (TMP)
		<COND (<0? <SET HASH <PTRHACK .UV ,BUCKET>>>
		       <PTRHACK .UV ,BUCKET .ADDR>
		       <RETURN>)
		      (<SET UV <DB-ACCESS .DB .HASH>>)>>>

""

"SUBTITLE Fake package system stuff"

<DEFINE NPACKAGE NPA (STR "TUPLE" X) 
	#DECL ((STR) STRING (X) TUPLE)
	<COND (<0? ,NO-ENT>
	       <COND (,CUR-PACK
		      <TWO-PACKAGES .STR>
		      <RETURN T .NPA>)>
	       <SETG CUR-PACK .STR>)>
	<SETG NO-ENT <+ ,NO-ENT 1>>
	<OPACKAGE .STR !.X>>

<DEFINE NRPACKAGE NRPA (STR "TUPLE" X) 
	#DECL ((STR) STRING (X) TUPLE)
	<COND (<0? ,NO-ENT>
	       <COND (,CUR-PACK
		      <TWO-PACKAGES .STR>
		      <RETURN T .NRPA>)>
	       <SETG CUR-PACK .STR>
	       <SETG CUR-TYPE T>)>
	<SETG NO-ENT <+ ,NO-ENT 1>>
	<ORPACKAGE .STR !.X>>

<DEFINE TWO-PACKAGES (STR "AUX" (CHN ,LOAD-CHANNEL) (OUTCHAN .OUTCHAN))
  #DECL ((STR) STRING (CHN) <OR <CHANNEL FIX> FALSE> (OUTCHAN) CHANNEL)
  <COND (<AND .CHN
	      <NOT <0? <1 .CHN>>>>
	 <PRINC "WARNING:  two packages defined in file ">
	 <PRINC <FILNAME .CHN 9>>
	 <PRINC !\.>
	 <CRLF>
	 <PRINC "Only ">
	 <PRINC ,CUR-PACK>
	 <PRINC " will be added to the library.">
	 <CRLF>
	 <PRINC "The second package is ">
	 <PRINC .STR>
	 <PRINC !\.>
	 <CRLF>
	 <ACCESS .CHN <FILE-LENGTH .CHN>>)
	(<ERROR TWO-PACKAGES-IN-FILE? ,CUR-PACK .STR>)>>

<DEFINE NENTRY ("TUPLE" ATMS "AUX" VAL (L ,CUR-ENTRY)) 
	#DECL ((ATMS) <TUPLE [REST ATOM]> (L) <LIST [REST ATOM]>)
	<SET VAL <OENTRY !.ATMS>>
	<COND (<1? ,NO-ENT>
	       <MAPF <>
		     <FUNCTION (X) <COND (<NOT <MEMQ .X .L>> <SET L (.X !.L)>)>>
		     .ATMS>
	       <SETG CUR-ENTRY .L>)>
	.VAL>

<DEFINE NRENTRY ("TUPLE" ATMS "AUX" VAL (L ,CUR-RENTRY)) 
	#DECL ((ATMS) <TUPLE [REST ATOM]> (L) <LIST [REST ATOM]>)
	<SET VAL <ORENTRY !.ATMS>>
	<COND (<1? ,NO-ENT>
	       <MAPF <>
		     <FUNCTION (X) <COND (<NOT <MEMQ .X .L>> <SET L (.X !.L)>)>>
		     .ATMS>
	       <SETG CUR-RENTRY .L>)>
	.VAL>

<DEFINE NENDPACKAGE () 
	<COND (<L? <SETG NO-ENT <- ,NO-ENT 1>> 0>
	       <ERROR UNBALANCED-PACKAGES NENDPACKAGE>)>
	<OENDPACKAGE>>

<DEFINE NUSE ("TUPLE" NMS)
  <COND (<1? ,NO-ENT> <SETG CUR-USES (!.NMS !,CUR-USES)>)>
  <SETG ALL-USES (!.NMS !,ALL-USES)>
  <OUSE !.NMS>>

<DEFINE NUSE-DEFER ("TUPLE" NMS) 
  <COND (<1? ,NO-ENT> <SETG CUR-USE-DEFERS (!.NMS !,CUR-USE-DEFERS)>)>
  <SETG ALL-USES (!.NMS !,ALL-USES)>
  <OUSE-DEFER !.NMS>>

<DEFINE FLUSH-CURRENT-PACKAGE ("AUX" (NM ,CUR-PACK) (USES ,ALL-USES))
  #DECL ((NM) <OR FALSE STRING> (USES) <LIST [REST STRING]>)
  <COND (<AND .NM
	      <NOT <MEMBER .NM ,SACRED-PACKAGES>>>
	 <MAPF <>
	   <FUNCTION (X)
	     <UNMANIFEST .X>
	     <GUNASSIGN .X>
	     <REMOVE .X>>
	   ,CUR-ENTRY>
	 <MAPF <>
	   <FUNCTION (X)
	     <UNMANIFEST .X>
	     <GUNASSIGN .X>
	     <REMOVE .X>>
	   ,CUR-RENTRY>
	 <FLUSH-PACKAGE .NM ,CUR-TYPE>
	 <MAPF <> ,FLUSH-PACKAGE .USES>)>>

<DEFINE FLUSH-PACKAGE (NM "OPTIONAL" (RPACKAGE? 0))
  #DECL ((NM) STRING (RPACKAGE?) <OR ATOM FIX FALSE>)
  <COND (<NOT <MEMBER .NM ,SACRED-PACKAGES>>
	 <COND (<TYPE? .RPACKAGE? FIX>
		<COND (<LOOKUP .NM <GET PACKAGE OBLIST>>
		       <L-UNUSE .NM>)
		      (<LOOKUP <STRING !\I .NM> <GET RPACKAGE OBLIST>>
		       <L-UNUSE .NM>)>)
	       (.RPACKAGE?
		<COND (<LOOKUP <STRING !\I .NM> <GET RPACKAGE OBLIST>>
		       <L-UNUSE .NM>)>)
	       (<LOOKUP .NM <GET PACKAGE OBLIST>>
		<L-UNUSE .NM>)>)>>

<SETG SACRED-PACKAGES ("PP" "PCK" "FIXUP" "HELPLD" "EDIT" "FR&" "GRLOAD" "PAGES"
		       "LIB" "LUP" "NLIB" "NLUP")>

""

"SUBTITLE Garbage collector"

<DEFINE LIB-GC LL (LIBNAM
		   "OPTIONAL" (VB? T) (FORCE? T) (NEW? <>)
		   "AUX" U DB1 DB2 NN CH (NM2 ,L-LIBRARY-NAME) GB UV
			 LAST-UPDATE)
	#DECL ((LIBNAM NN) STRING (U) UPDB (DB1 DB2) <OR FALSE DATA-BASE>
	       (LAST-UPDATE) FIX
	       (UV GB) <UVECTOR [REST FIX]> (CH) CHANNEL (NM2) <SPECIAL STRING>
	       (NEW?) <OR ATOM FALSE>)
	<LUP-DCT>
	<COND (<NOT <SET DB1 <DB-OPEN .LIBNAM>>>      ;"Get frob to be updated"
	       <RETURN .DB1 .LL>)>
	<SET UV <DB-DATA .DB1>>
	<SET LAST-UPDATE <NTH .UV <+ ,LASTUP 1>>>
	<COND (<AND <NOT .FORCE?>
		    <G=? <NTH .UV <+ ,LASTGC 1>> .LAST-UPDATE>>
	       <PRINC "GC not necessary.">
	       <CRLF>
	       <DB-CLOSE .DB1>
	       <RETURN T .LL>)>
	<DB-CLOSE .DB1>
	<COND (<LUP-ACT .LIBNAM <> T>
	       <SET U ,CUR-UPD>
	       <SET DB1 <UPDB-BASE .U>>
	       <SET UV <DB-DATA .DB1>>
	       <SET NN <NEW-NAME <DB-CHAN .DB1>>>
	       <SETG DB-DEAD <+ ,DB-DEAD 1>>
	       <PUT .U ,UPDB-NNAME .NN>
	       <SET CH <OPEN "PRINTB" .NN>>
	       <COND (<GASSIGNED? GROW-BUF> <SET GB ,GROW-BUF>)
		     (<SETG GROW-BUF <SET GB <IUVECTOR 1024 0>>>)>
	       <PUT .GB 1023 4295229440>
	       <PUT .GB <+ ,FILNAM 1> -20777869980>
	       <PUT .GB <+ ,HLEN1 1> 251>
	       <PUT .GB <+ ,HLEN2 1> 751>
	       <PUT .GB <+ ,FREEPT 1> <+ 1023 923>>
	       <PUT .GB <+ ,LASTUP 1> .LAST-UPDATE>
	       <PUT .GB
		    <+ ,HDRLEN 251 751 1>
		    <CHTYPE <PUTBITS 0 ,LENGET <- 1022 <+ ,HDRLEN 251 751>>>
			    FIX>>
	       <PRINTB .GB .CH>
	       <MAPR <> <FUNCTION (X) <PUT .X 1 0>> .GB>
	       <PUT .GB 1023 4295229440>
	       <LENHACK .GB 0 <- 1022 100>>
	       <PTRHACK .GB 922 <+ 751 251 ,HDRLEN>>
	       <LENHACK .GB 922 100>			  ;"Set up initial page"
	       <PRINTB .GB .CH>
	       <CLOSE .CH>
	       <SET DB2 <DB-OPEN .NN "PRINTO">>
	       <PUT .U ,UPDB-NEW .DB2>
	       <DO-GC .DB1 .DB2 <UPDB-DATFILE .U> <UPDB-NEWDAT .U> .VB? .NEW?>
	       <SETG DB-DEAD <- ,DB-DEAD 1>>
	       <DB-HASH-MAP .DB2>
	       <PUT <DB-DATA .DB2> <+ ,LASTGC 1> <DSKDATE>>
						  ;"Last time garbage-collected"
	       <DB-CLOSE .DB1>
	       <LUP-DCT>)>>

"Get time from system"

<DEFINE DSKDATE () <COND (<G? ,MUDDLE 100> <TDSKDATE>) (<IDSKDATE>)>>

""
<SETG SAVED-ENTRIES <IUVECTOR 1022 ()>>
<DEFINE DO-GC (DB1 DB2 DCH1 DCH2 VB? NEW? "AUX" UV1 UV2 H LIM CUR-BUCKET NEW-ENT
	       (SE ,SAVED-ENTRIES)) 
   #DECL ((DB1 DB2) DATA-BASE (DCH1 DCH2) CHANNEL (UV1 UV2) <UVECTOR [REST
								      FIX]>
	  (NEW-ENT CUR-BUCKET H LIM) FIX (NEW?) <OR ATOM FALSE>
	  (SE) <UVECTOR [REST <LIST [REST <VECTOR STRING FIX FIX>]>]>)
   <SET UV1 <DB-HASH-MAP .DB1>>
   <SET UV2 <DB-HASH-MAP .DB2>>
   <MAPR <> <FUNCTION (X) <PUT .X 1 ()>> .SE>
   <SET H ,HDRLEN>
   <SET LIM <NTH .UV1 <+ ,HLEN1 1>>>
 ;
"First we blt all the package entries to the new data base.  This includes
checking for the existence of each package's file, and for the correctness
of information in the data file.  If the file doesn't exist, the package is
deleted (a message is printed); if the data base entry isn't current, we
redo it (which involves some reasonably gross hacks)."
   <REPEAT ((CT 0))
	   #DECL ((CT) FIX)
	   <COND (<G=? .CT .LIM> <RETURN>)>
	   <DB-ACCESS .DB1 .H>		     ;"Point to beginning of hash table"
	   <SET CUR-BUCKET <PTRHACK <DB-DATA .DB1> ,BUCKET>>
					      ;"Go grovelling down this bucket."
	   <REPEAT (NL (NH .H) (CURLEN 0) PCK-CHAN PCK-CRDATE PCK-ACCESS
		    PCK-ENTLEN)
		   #DECL ((NL PCK-CRDATE PCK-ACCESS NH CURLEN) FIX
			  (PCK-CHAN) <OR CHANNEL FALSE> (PCK-ENTLEN) <OR FIX FALSE>)
		   <COND (<0? .CUR-BUCKET> <RETURN>)>
		   <SET UV1 <DB-ACCESS .DB1 .CUR-BUCKET>>
						       ;"Point to package entry"
		   <COND (<PROG ()
			     <COND (<NOT <SET PCK-CHAN <OPEN-NR "READ" <GET-FILE .UV1>>>>
				    ;"Does file exist?"
				    <RETURN .PCK-CHAN>)>
			     <SET PCK-CRDATE <NTH .UV1 <+ ,PACKAGE-CRDATE 1>>>
			     <COND (<AND <N==? .PCK-CRDATE -1> ;"-1-->no dat file entry"
					 <OR .NEW?
					     <L? .PCK-CRDATE
						 <SET PCK-CRDATE <CRDATE .PCK-CHAN>>>>>
				    ;"Needs data file entry"
				    <COND (.VB?
					   <TELL "Package " <GET-NAME .UV1>
						 " getting new entry.">)>
				    <SET PCK-ACCESS <17 .DCH2>>
				    ;"Access pointer for package"
				    <COND (<NOT <SET PCK-ENTLEN
						  <GC-NEW-PACKAGE .PCK-CHAN .CUR-BUCKET
								  .DCH2 .DB2 .SE>>>
					   <COND (<NOT <EMPTY? .PCK-ENTLEN>>
						  <RETURN .PCK-ENTLEN>)>
					   <SET PCK-ACCESS -1>
					   <SET PCK-ENTLEN 0>
					   <SET PCK-CRDATE -1>)>
				    <PUT .UV1 <+ ,PACKAGE-ACCESS 1> -1>)
				   ;"-1 here-->new entry"
				   (<N==? .PCK-CRDATE -1>
				    <CLOSE .PCK-CHAN>
				    <SET PCK-ACCESS <17 .DCH2>>
				    <SET PCK-ENTLEN
					 <NTH .UV1 <+ ,PACKAGE-ENTLEN 1>>>
				    <COPY-PACKAGE .UV1 .DCH1 .DCH2>)
				   (<PUT .UV1 <+ ,PACKAGE-ACCESS 1> -2>
				    <SET PCK-ACCESS -1>
				    <SET PCK-ENTLEN 0>)>
			     <COND (<AND .PCK-CHAN <NOT <0? <1 .PCK-CHAN>>>>
				    <CLOSE .PCK-CHAN>)>
			     T>
			  <SET NL
			       <+ ,PACKAGE-NAMEBEG
				  <STRLC <LENHACK .UV1 ,BUCKET>>
				  <STRLC <LENHACK .UV1 ,FCNCHAIN>>>>
							      ;"Length of entry"
			  <SET NEW-ENT <GC-ALLOC .DB2 .NL>>
							 ;"Allocate new storage"
			  <DB-ACCESS .DB2 .NH>
					     ;"Point at last hash bucket entry."
			  <PTRHACK <DB-DATA .DB2> ,BUCKET .NEW-ENT>
						   ;"Make it point at new entry"
			  <SET UV2 <DB-ACCESS .DB2 .NEW-ENT>>
							   ;"Point at new entry"
			  <SUBSTRUC .UV1 0 .NL .UV2>	   ;"BLT the entry over"
			  <PTRHACK .UV2 ,FCNCHAIN 0>	      ;"No longer valid"
			  <PTRHACK .UV1 ,FCNCHAIN 0>
			  <PTRHACK .UV2 ,BUCKET 0>
			  <PUT .UV2 <+ ,PACKAGE-ACCESS 1> .PCK-ACCESS>
			  <PUT .UV2 <+ ,PACKAGE-ENTLEN 1> .PCK-ENTLEN>
			  <PUT .UV2 <+ ,PACKAGE-CRDATE 1> .PCK-CRDATE>
							       ;"Datafile stuff"
			  <SET NH .NEW-ENT>
				      ;"So next entry will be consed correctly."
			  <SET CUR-BUCKET <PTRHACK .UV1 ,BUCKET>>
							   ;"Next elt of bucket"
			  <PTRHACK .UV1 ,BUCKET .NEW-ENT>
					   ;"Used in hacking function pointers")
			 (T
			  <COND (.VB?
				 <COND (<TYPE? .PCK-CHAN CHANNEL>
					<TELL "Package " <GET-NAME .UV1>
					      " being flushed.">
					<COND (<NOT <0? <1 .PCK-CHAN>>>
					       <CLOSE .PCK-CHAN>)>)
				       (<TELL "Package " <GET-NAME .UV1>
					      " being flushed:  " <2 .PCK-CHAN>
					      "--" <1 .PCK-CHAN>>)>)>
			  <SET CUR-BUCKET <PTRHACK .UV1 ,BUCKET>>
						        ;"Losers have cdrs too."
			  <PTRHACK .UV1 ,BUCKET 0>
					    ;"So we'll know to flush the guy")>>
	   <SET H <+ .H 1>>				    ;"Next hash bucket"
	   <SET CT <+ .CT 1>>>
 ;
"Now move entries over.  Note that the following special hacks have already
happened:
The BUCKET slot of packages in the old db is either a pointer to the entry in the
new db or 0 (if the package is going away).  This is used for hacking the function
chain.
If a new entry for the package is being made, the PACKAGE-ACCESS slot in the old db
entry is -1.  In this case, data for the package entries is stored in .SE, already
properly hashed."
   <SET UV1 <DB-HASH-MAP .DB1>>
   <SET LIM <NTH .UV1 <+ ,HLEN2 1>>>
   <REPEAT ((CT 0) (NH .H) NEW-ENTRY (CURLEN 0) PCK-POINTER FNCT-CHAIN)
     #DECL ((NEW-ENTRY CURLEN PCK-POINTER FNCT-CHAIN NH CT) FIX)
     <COND (<G=? .CT .LIM> <RETURN>)>
     <REPEAT ((HH .H) OLD-ENTRY)
       #DECL ((HH OLD-ENTRY) FIX)
       <SET UV1 <DB-ACCESS .DB1 .HH>>			   ;"Point to a pointer"
       <COND (<0? <SET OLD-ENTRY <PTRHACK .UV1 ,BUCKET>>> <RETURN>)>
						     ;"Through with this bucket"
       <SET UV1 <DB-ACCESS .DB1 .OLD-ENTRY>>		    ;"Point to an entry"
       <SET CURLEN <+ 1 ,FUNCTION-NAMEBEG <STRLC <LENHACK .UV1 ,BUCKET>>>>
       <COND (<AND <NOT <0? <PTRHACK <SET UV1
					  <DB-ACCESS .DB1 <NTH .UV1 .CURLEN>>>
				     ,BUCKET>>>
		   <N==? <NTH .UV1 <+ ,PACKAGE-ACCESS 1>> -1>>
	        ;"True if package is staying around and already had valid entry"
	      <SET NEW-ENTRY <GC-ALLOC .DB2 .CURLEN>>	     ;"Allocate storage"
	      <DB-ACCESS .DB2 .NH>
	      <PTRHACK <DB-DATA .DB2> ,BUCKET .NEW-ENTRY>
						     ;"Point previous elt at me"
	      <SET UV2 <DB-ACCESS .DB2 .NEW-ENTRY>>
	      <SET PCK-POINTER <PTRHACK .UV1 ,BUCKET>>
						 ;"Get pointer to package entry"
	      <SET FNCT-CHAIN <PTRHACK .UV1 ,FCNCHAIN>> ;"And to function chain"
	      <PTRHACK .UV1 ,FCNCHAIN .NEW-ENTRY>       ;"Update c1 of fcnchain"
	      <SET UV1 <DB-ACCESS .DB1 .OLD-ENTRY>>   ;"Point back at old entry"
	      <SUBSTRUC .UV1 0 .CURLEN .UV2>		        ;"Copy the data"
	      <PTRHACK .UV2 ,BUCKET 0>	    ; "Zero in case next elt going away"
	      <PTRHACK .UV2 ,FCNCHAIN .FNCT-CHAIN>      ;"Put in function chain"
	      <PUT .UV2 .CURLEN .PCK-POINTER>		  ;"And package pointer"
	      <PTRHACK <DB-ACCESS .DB2 .PCK-POINTER> ,FCNCHAIN .NEW-ENTRY>
							       ;"C2 of fcnchain"
	      <SET NH .NEW-ENTRY>)>
       <SET HH .OLD-ENTRY>>
     ;"Now go down saved entries for this hash bucket."
     <MAPF <>
	   <FUNCTION (ENT) 
		   #DECL ((ENT) <VECTOR STRING FIX FIX>)
		   <SET CURLEN
			<+ 1 ,FUNCTION-NAMEBEG <STRLC <LENGTH <1 .ENT>>>>>
		   <SET NEW-ENTRY <GC-ALLOC .DB2 .CURLEN>>
		   <DB-ACCESS .DB2 .NH>
		   <PTRHACK <DB-DATA .DB2> ,BUCKET .NEW-ENTRY>
		   <SET UV2 <DB-ACCESS .DB2 .NEW-ENTRY>>
		   <SET UV1 <DB-ACCESS .DB1 <2 .ENT>>>
		   <SET PCK-POINTER <PTRHACK .UV1 ,BUCKET>>
		   <SET FNCT-CHAIN <PTRHACK .UV1 ,FCNCHAIN>>
		   <PTRHACK .UV1 ,FCNCHAIN .NEW-ENTRY>
		   <STR-BLT .UV2 <1 .ENT> ,FUNCTION-NAMEBEG ,BUCKET>
							     ;"Copy the name in"
		   <PTRHACK .UV2 ,FCNCHAIN .FNCT-CHAIN>
						      ;"Point to function chain"
		   <TYPHACK .UV2 ,BUCKET 0>	        ;"This is not a package"
		   <TYPHACK .UV2 ,FCNCHAIN <3 .ENT>>		 ;"entry/rentry"
		   <PUT .UV2 .CURLEN .PCK-POINTER>	     ;"Point to package"
		   <SET UV2 <DB-ACCESS .DB2 .PCK-POINTER>>
		   <PTRHACK .UV2 ,FCNCHAIN .NEW-ENTRY>  ;"Update function chain"
		   <SET NH .NEW-ENTRY>>
	   <NTH .SE <+ .H 1>>>
     <SET H <+ .H 1>>
     <SET NH .H>
     <SET CT <+ .CT 1>>>
   <GC-CLEANUP .DB2>>

""

<SETG CUV <IUVECTOR 30>>

<DEFINE COPY-PACKAGE (UV1 DCH1 DCH2
		      "AUX" (CUV ,CUV)
			    (LEN
			     </
			      <CHTYPE
			       <GETBITS <NTH .UV1 <+ ,PACKAGE-ENTLEN 1>>
					<BITS 18 18>>
			       FIX>
			      5>))
	#DECL ((UV1) UVECTOR (DCH1 DCH2) CHANNEL)
	<ACCESS .DCH1 <NTH .UV1 <+ ,PACKAGE-ACCESS 1>>>
	<BUFOUT .DCH2>
	<REPEAT (CT)
		<SET CT <MYIOT .CUV .DCH1 <MIN 30 .LEN>>>
		<MYIOT .CUV .DCH2 .CT>
		<COND (<L=? <SET LEN <- .LEN .CT>> 0> <RETURN>)>>
	<PUT .DCH2 17 <FILE-LENGTH .DCH2>>>

<DEFINE GC-NEW-PACKAGE (PCK-CHAN CUR-BUCKET DCH2 DB SAVED-ENTRIES "AUX"
			(TMP 0) GRP PCK ENTL RENTL (IND '(1)))
  #DECL ((PCK-CHAN DCH2) CHANNEL (CUR-BUCKET) FIX (SAVED-ENTRIES) <UVECTOR [REST LIST]>
	 (ENTL RENTL) LIST (GRP) <OR LIST FALSE>)
  <COND (<NOT <SET GRP <LOAD-PACKAGE .PCK-CHAN>>>
	 <ERROR LOAD-FAILED .GRP GC-NEW-PACKAGE>)>
  <COND (<AND <NOT <0? ,NO-ENT>>
	      <NOT <ERROR UNBALANCED-PACKAGES GC-NEW-PACKAGE ERRET-T-TO-CONTINUE>>>)
	(<SET PCK ,CUR-PACK>
	 <SET ENTL ,CUR-ENTRY>
	 <SET RENTL ,CUR-RENTRY>
	 <COND (<OR <NOT <EMPTY? .ENTL>> <NOT <EMPTY? .RENTL>>>
		<COND (<NOT <SET TMP <CL .GRP>>>
		       <ERROR .PCK .TMP GC-NEW-PACKAGE>)>
		<FROB-ENTRIES .ENTL .CUR-BUCKET .SAVED-ENTRIES 0 .DB>
		<FROB-ENTRIES .RENTL .CUR-BUCKET .SAVED-ENTRIES 1 .DB>
		<SET TMP <WRITE-PACKAGE .PCK ,CUR-TYPE .ENTL .RENTL
					,CUR-USES ,CUR-USE-DEFERS .DCH2>>
		<BUFOUT .DCH2>
		<L-UNUSE .PCK>)>)>
  <UNINIT-LUP-PS>
  .TMP>

<DEFINE FROB-ENTRIES (EL CUR-BUCKET SE RP? DB "AUX" UV)
  #DECL  ((EL) <LIST [REST ATOM]> (CUR-BUCKET) FIX (SE) <UVECTOR [REST LIST]>
	  (DB) DATA-BASE)
  <SET UV <DB-HASH-MAP .DB>>
  <MAPF <>
	<FUNCTION (X "AUX" HSH)
	  <SET X <PNAME .X>>
	  <SET HSH <HASH-NAME .X .UV ,HLEN2>>
	  <PUT .SE .HSH ([.X .CUR-BUCKET .RP?] !<NTH .SE <+ .HSH 1>>)>>
	.EL>>


<DEFINE TELL ("TUPLE" FOO "AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((OUTCHAN) CHANNEL)
	<COND (<NOT <0? <14 .OUTCHAN>>>
	       <CRLF>)>
	<MAPF <> ,PRINC .FOO>
	<CRLF>>

""

<DEFINE GC-CLEANUP (DB "AUX" REM CL UV) 
	#DECL ((DB) DATA-BASE (REM CL) FIX (UV) <UVECTOR [REST FIX]>)
	<SET CL <- <DB-FLEN .DB> 1024>>
	<SET UV <DB-ACCESS .DB .CL>>	    ;"Access to beginning of last page."
	<COND (<G? <SET REM <LENHACK .UV ,BUCKET>> ,DB-MIN-ENTRY>
					       ;"Enough here to be interesting?"
	       <PTRHACK .UV ,BUCKET <PTRHACK .UV 922>>
						 ;"Splice this into free chain."
	       <PTRHACK .UV 922 .CL>)
	      (<PUT .UV <+ ,BUCKET 1> 0>	 ;"No space, so just zero it.")>
	T>

<DEFINE GC-ALLOC (DB LEN "AUX" CH UV CL REM (W? <>)) 
	#DECL ((DB) DATA-BASE (LEN CL REM) FIX (UV) <UVECTOR [REST FIX]>
	       (W?) <OR FIX FALSE> (CH) CHANNEL)
	<SET CL <- <DB-FLEN .DB> 1024>>
	<SET UV <DB-ACCESS .DB .CL>>	      ;"Go to beginning of current page"
	<COND (<G? <SET REM <- <LENHACK .UV ,BUCKET> .LEN>> 0>
	       <LENHACK .UV ,BUCKET .REM>
				  ;"If it will fit with space left, just return"
	       <+ .CL .REM>		        ;"Allocate at end of free area")
	      (T
	       <COND (<AND <L? .REM 0>			      ;"Any space left?"
			   <G=? <LENHACK .UV ,BUCKET> ,DB-MIN-ENTRY>
						    ;"Big enough to be useful?">
		      <PTRHACK .UV ,BUCKET <PTRHACK .UV 922>>
 ;
"Make this extra point to the previous page's free area
		   (which this page's free area points to now..."
		      <PTRHACK .UV 922 .CL>
				     ;"Make this free area point to the extra.")
		     (<PUT .UV <+ ,BUCKET 1> 0>
				     ;"Zero the length field, if not freeing.")>
	       <DB-ACCESS .DB ,FREEPT>			  ;"Get to free pointer"
	       <PTRHACK ,GROW-BUF 922 <1 <DB-DATA .DB>>>
 ;
"New free area points to current chain.  Note that lengths already set
	    up."
	       <PTRHACK <DB-DATA .DB> ,BUCKET <+ .CL 1024 922>>
		 ;"And free chain points to new area (which doesn't exist yet)."
	       <SET CH <DB-CHAN .DB>>
	       <COND (<L? ,MUDDLE 100> <RESET .CH>)>
	       <COND (<0? .REM> <SET W? .CL>)>
				 ;"Returning pointer to old area, don't forget."
	       <ACCESS .CH <SET CL <DB-FLEN .DB>>>		    ;"Go to eof"
	       <PUT .DB ,DB-FLEN <+ .CL 1024>>		   ;"Update file length"
	       <PRINTB ,GROW-BUF <DB-CHAN .DB>>			 ;"Print it out"
	       <COND (<L? ,MUDDLE 100> <RESET .CH>)>
	       <SET UV <DB-ACCESS .DB .CL>>		   ;"Access to new page"
	       <COND (<NOT .W?>
		      <SET REM <- <LENHACK .UV ,BUCKET> .LEN>>
						  ;"Get length after allocation"
		      <LENHACK .UV ,BUCKET .REM>	       ;"Put it back in"
		      <+ .CL .REM>)
		     (<+ .W? .REM>
		  ;"There was enough on the previous page, but that's all.")>)>>

""

"SUBTITLE Statistics"

<DEFINE LIB-STAT (LN
		  "AUX" (PKC 0) (PKW 0) (ENC 0) (ENW 0) (FRC 0) (FRW 0) PKF ENF
			(DB <>) UV HUV (TMP <UVECTOR 0 0 0 0 0 0>) FL
			(OUTCHAN .OUTCHAN) HLEN PKE ENE (DFLEN 0) (DFUSE 0) (DFCT 0))
	#DECL ((LN) STRING (DB) <OR DATA-BASE FALSE>
	       (DFCT DFLEN DFUSE PKE ENE HLEN PKF ENF FL PKC PKW ENC ENW FRC FRW) FIX
	       (UV HUV) <UVECTOR [REST FIX]> (TMP) <UVECTOR [6 FIX]>
	       (OUTCHAN) CHANNEL)
	<UNWIND
	 <COND (<SET DB <DB-OPEN .LN>>
		<PROG (CH)
		      <COND (<SET CH <OPEN-DAT-FILE "READ" .LN>>
			     <SET DFLEN <FILE-LENGTH .CH>>
			     <CLOSE .CH>)>>
		<SET UV <DB-HASH-MAP .DB>>
		<COND (<GASSIGNED? HUV> <SET HUV ,HUV>)
		      (<SETG HUV <SET HUV <IUVECTOR 1022 0>>>)>
		<SUBSTRUC .UV 0 1022 .HUV>	  ;"Permanent copy of hash page"
		<REPEAT ((PT <NTH .HUV <+ ,FREEPT 1>>))
			#DECL ((PT) FIX)
			<COND (<0? .PT> <RETURN>)
			      (<SET UV <DB-ACCESS .DB .PT>>
			       <SET FRC <+ .FRC 1>>
			       <SET FRW <+ .FRW <LENHACK .UV ,BUCKET>>>
			       <SET PT <PTRHACK .UV ,BUCKET>>)>>
		<HASH-HACK <REST .HUV ,HDRLEN>
			   <NTH .HUV <+ ,HLEN1 1>>
			   .DB
			   5
			   T
			   .TMP>
		<SET PKC <1 .TMP>>
		<SET PKW <2 .TMP>>
		<SET PKF <3 .TMP>>
		<SET PKE <4 .TMP>>
		<SET DFUSE <5 .TMP>>
		<SET DFCT <6 .TMP>>
		<HASH-HACK <REST .HUV <+ ,HDRLEN <NTH .HUV <+ ,HLEN1 1>>>>
			   <NTH .HUV <+ ,HLEN2 1>>
			   .DB
			   3
			   <>
			   .TMP>
		<SET ENC <1 .TMP>>
		<SET ENW <2 .TMP>>
		<SET ENF <3 .TMP>>
		<SET ENE <4 .TMP>>
		<CRLF>
		<PRINC "Last update:  ">
		<PDSKDATE <NTH .HUV <+ ,LASTUP 1>> .OUTCHAN>
		<CRLF>
		<PRINC "Last GC:  ">
		<COND (<0? <SET FL <NTH .HUV <+ ,LASTGC 1>>>> <PRINC "Never">)
		      (<PDSKDATE <NTH .HUV <+ ,LASTGC 1>> .OUTCHAN>)>
		<CRLF>
		<PRINC "Library file length:  ">
		<PRIN1 <SET FL <FILE-LENGTH <DB-CHAN .DB>>>>
		<CRLF>
		<PRIN1 <SET HLEN
			    <+ ,HDRLEN
			       <NTH .HUV <+ ,HLEN1 1>>
			       <NTH .HUV <+ ,HLEN2 1>>>>>
		<PRINC " words of header and hash tables.">
		<CRLF>
		<PRIN1 .PKC>
		<PRINC " packages, ">
		<PRIN1 .PKW>
		<PRINC " words.">
		<CRLF>
		<PRINC "   ">
		<PRIN1 .PKF>
		<PRINC " crossing">
		<COND (<NOT <1? .PKF>> <PRINC !\s>)>
		<PRINC " of page boundaries.  ">
		<PRIN1 .PKE>
		<PRINC " empty hash bucket">
		<COND (<NOT <1? .PKE>> <PRINC !\s>)>
		<PRINC !\.>
		<CRLF>
		<PRIN1 .ENC>
		<PRINC " entries, ">
		<PRIN1 .ENW>
		<PRINC " words.">
		<CRLF>
		<PRINC "   ">
		<PRIN1 .ENF>
		<PRINC " crossing">
		<COND (<NOT <1? .ENF>> <PRINC !\s>)>
		<PRINC " of page boundaries.  ">
		<PRIN1 .ENE>
		<PRINC " empty hash bucket">
		<COND (<NOT <1? .ENE>> <PRINC !\s>)>
		<PRINC !\.>
		<CRLF>
		<PRINC "Free chain is ">
		<PRIN1 .FRC>
		<PRINC " entries long, containing ">
		<PRIN1 .FRW>
		<PRINC " words.">
		<CRLF>
		<PRIN1 <SET FL
			    <- .FL
			       <+ <* 2 </ .FL 1024>> .HLEN .PKW .ENW .FRW>>>>
		<PRINC " word">
		<COND (<NOT <1? .FL>> <PRINC !\s>)>
		<PRINC " lost.">
		<CRLF>
		<COND (<0? .DFLEN> <PRINC "The data file is empty.">)
		      (T
		       <PRINC "The data file is ">
		       <PRINC </ .DFLEN 5>>
		       <PRINC " words long; ">
		       <PRINC </ .DFUSE 5>>
		       <PRINC " words in use.">
		       <CRLF>
		       <PRIN1 .DFCT>
		       <PRINC " packages with data file entries.">)>
		<DB-CLOSE .DB>
		<CRLF>)>
	 <COND (.DB <DB-CLOSE .DB>)>>>

<DEFINE HASH-HACK (HUV NUM DB OVH PACKAGE? TMP
		   "AUX" (DFCT 0) (DFUSE 0) (E 0) (C 0) (W 0) (F 0) UV)
   #DECL ((HUV UV) <UVECTOR [REST FIX]> (DB) DATA-BASE (DFCT DFUSE F NUM OVH C W) FIX
	  (TMP) <UVECTOR [6 FIX]> (PACKAGE?) <OR ATOM FALSE>)
   <REPEAT (PT TC)
     #DECL ((TC PT) FIX)
     <COND
      (<NOT <0? <SET PT <1 .HUV>>>>
       <REPEAT ()
	 <SET UV <DB-ACCESS .DB .PT>>
	 <SET C <+ .C 1>>
	 <SET W
	      <+ .W
		 .OVH
		 </ <+ 4 <LENHACK .UV ,BUCKET>> 5>
		 </ <+ 4 <LENHACK .UV ,FCNCHAIN>> 5>>>
	 <COND (.PACKAGE?
		<SET DFUSE
		     <+ .DFUSE
			<CHTYPE <GETBITS <NTH .UV <+ ,PACKAGE-ENTLEN 1>>
					 <BITS 18 18>>
				FIX>>>
		<COND (<N==? <NTH .UV <+ ,PACKAGE-ACCESS 1>> -1>
		       <SET DFCT <+ .DFCT 1>>)>)>
	 <COND (<0? <SET PT <PTRHACK .UV ,BUCKET>>> <RETURN>)>
	 <COND (<OR <AND <0? <DB-CPAGE .DB>> <N==? <DB-PAGE0 .DB> </ .PT 1024>>>
		    <AND <1? <DB-CPAGE .DB>>
			 <N==? <DB-PAGE1 .DB> </ .PT 1024>>>>
		<SET F <+ .F 1>>)>>)
      (<SET E <+ .E 1>>)>
     <COND (<0? <SET NUM <- .NUM 1>>>
	    <PUT .TMP 1 .C>
	    <PUT .TMP 2 .W>
	    <PUT .TMP 3 .F>
	    <PUT .TMP 4 .E>
	    <COND (.PACKAGE? <PUT .TMP 5 .DFUSE>
		   <PUT .TMP 6 .DFCT>)>
	    <RETURN>)
	   (<SET HUV <REST .HUV>>)>>>

<DEFINE PDSKDATE (DATE OUTCHAN "AUX" TMP) 
	#DECL ((TMP DATE) FIX (OUTCHAN) CHANNEL)
	<PRIN1 <CHTYPE <GETBITS .DATE <BITS 4 23>> FIX>>
	<PRINC !\/>
	<PRIN1 <CHTYPE <GETBITS .DATE <BITS 5 18>> FIX>>
	<PRINC !\/>
	<PRIN1 <CHTYPE <GETBITS .DATE <BITS 7 27>> FIX>>
	<PRINC " at ">
	<SET DATE </ <CHTYPE <GETBITS .DATE <BITS 18 0>> FIX> 2>>
	<SET TMP </ .DATE 3600>>
	<COND (<0? .TMP> <PRINC !\0>)>
	<PRIN1 .TMP>
	<PRINC !\:>
	<SET DATE <MOD .DATE 3600>>
	<SET TMP </ .DATE 60>>
	<COND (<L? .TMP 10> <PRINC !\0>)>
	<PRIN1 .TMP>
	<PRINC !\:>
	<SET TMP </ .DATE 60>>
	<COND (<L? .TMP 10> <PRINC !\0>)>
	<PRIN1 .TMP>>

<ENDPACKAGE>
