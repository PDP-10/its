;;;MODIFICATION HISTORY
;;;
;;; 15 NOV 75  OBTAINED FROM DEC (KLDCP REV 7)
;;; 15 NOV 75  CONVERTED TO PALX FORMAT
;;; 19 DEC 75  BUG FIXES, BREAK, DDT CMD, PCF CMD
;;; 30 MAR 76  MODIFIED TO COEXIST WITH ITS IOELEVEN PROGRAM

.SBTTL	CONSOLE PACKAGE FOR KL10/11 INTERFACE, 9-SEPT-75

CONSL:	;MOV #PR7,PS		;DISABLE INTERRUPTS
	;MOV #PR7,EMTVEC+2
	MOV #STACK,SP		;RESET STACK
	MOV #$STUF,R0		;SETUP FOR STACK UNDERFLOW
	MOV R0,(SP)
1$:	PUSH R0

	MOV SP,$KONSP

KONSL:	MOV $KONSP,SP		;RESET STACK POINTER

	TTPINI 			;INIT TTY POINTERS

	CLR DDTFLG
	CLR IFILEF
	CLR HLPPNT
	CLR PCMDFLG
	PFORCE 			;ALL OUTPUT TO TTY

	JSR PC,$CKSUM		;COMPUTE CHECKSUM OF "KLDCP"

	CMP R0,$ILDSUM		;DOES IT MATCH AS LOADED ?
	BEQ 2$			;YES, OK !!!!

	MOV R0,$ILDSUM		;NO, ONLY REPORT CHANGES
	PMSG <?"KLDCP" CKSUM\>

2$:	TST JFILEF
	BNE $$CONSL
	PMSG <CMD:\>
	BR $$CONSL

$KONSL:	TTIBRK 			;GET BREAK CHAR FROM LAST OPERATION
	 BCS $KONS1		;NO DATA
	CMPB #',,R0		;WAS LAST BREAK A COMMA ?
	BEQ $RPT		;BR IF YES, CONTINUE STRING PROCESS
	CMPB #' ,R0		;WAS LAST BREAK A SPACE ?
	BEQ $RPT		;YES, CONTINUE STRING PROCESS
	CMPB #TAB,R0		;WAS LAST BREAK A TAB ?
	BEQ $RPT		;YES, CONTINUE STRING PROCESS
	TST R0
	BEQ 11$			;NULL, EOL
	CMP #LF,R0		;IS IT LF ?
	BEQ 11$			;YES
	CMP #ALTMOD,R0
	BEQ 11$			;IS IT ALTMODE ?
	CMP #CR,R0		;IS IT A CR ?
	BNE 2$			;NO, INVALID TERMINATION

11$:	TST RPTFLG		;PRESENTLY DOING A REPEAT ?
	BEQ $KONS1		;BR IF NO

	JSR PC,$PTTYC		;CHECK OPERATOR INTERRUPT

1$:	MOV #$INBUF+2,$INPTC	;REPEAT, REDO COMMAND
	BR $RPT

2$:	JMP $CMDER

$$CONSL:CLR RPTFLG
	CLR DVDIRF		;CLEAR DEVICE DIRECTORY FLAG
$KONS1:	TST PCMDFLG		;DOING PROGRAM COMMAND ?
	BEQ 1$			;NO
	JMP PCMDE		;YES, RETURN TO PROGRAM
1$:	TST IFILEF		;PROCESSING INDIRECT FILE ?
	BEQ 2$			;NO
	JMP IFILIN		;YES, GET CHARS FROM STORAGE
2$:	TST JFILEF		;DOING DOUBLE INDIRECT ?
	BPL $KONS2		;NO
	JMP JFILIN		;YES, GET CHARS FROM STORAGE
$KONS2:	MOV SP,$KONSP		;SAVE STACK POINTER
	TSTB TENRUN		;IF TEN IS RUNNING,
	BNE 2$			;DON'T GIVE COMMAND PROMPT
1$:	PFORCE
	PNTCI
	'>
	PMSG <. _>
2$:	RUNLP 			;RUN LOOP &/OR READ IN A TTY LINE
	 BCC $RPT		;RESPONSE, GO PROCESS
	CMP #$INBUF,$INPTR	;ANYTHING BEEN TYPED ?
	BNE 1$			;YES, REPROMPT
	BR 2$

$RPT:	CLR ALLFLG		;CLEAR ALL PRINT FLAG
	TTISDL 			;READ ONE CHARACTER
	 BCC $CMDER		;...NUMBER, ILLEGAL
1$:	CMPB #';,R0
	BEQ $$CONSL		;SEMICOLON, LOCAL COPY ONLY
	CMPB #'.,R0
	BEQ $RPT		;DOT, IGNORE
	MOVB R0,$KDCEN		;PLACE IN END OF DECODER

	TTICHR 			;READ SECOND CHARACTER
	 BCS $KONS1		;EVEN 1 CHAR CMDS ARE 2 CHAR MIN.
	CMPB #12,R0		;IF THIS CHAR IS A LINE FEED
	BEQ $KONS1		;..1ST CHAR MUST HAVE BEEN CR, IGNORE
	CMPB #15,R0		;IF THIS CHAR A CR
	BEQ 3$			;THIS IS A SINGLE LETTER COMMAND
	CMPB #33,R0		;IF ALTMODE
	BEQ 3$			;       DITTO
	MOVB R0,$KDCEN+1	;PLACE SECOND IN END OF DECODER

;THE COMMAND PORTION OF THE INPUT STRING IS READY TO BE DECODED

4$:	MOV $KDCEN,R0		;COMMAND TO R0
	MOV #$KDCRE,R1		;ADDRESS OF LIST TO R1

2$:	CMP R0,(R1)+		;TEST FOR COMMAND
	BNE 2$			;NOT FOUND YET
	CLR $KDCEN
	CLR ENQFLG
	JMP @$DISPH-$KDCRE-2(R1)	;EXIT TO SELECTED SUBROUTINE

3$:	MOVB #40,$KDCEN+1	;MAKE SINGLE LETTER COMMAND
	BR 4$			;LETTER & SPACE FOR LOOKUP

$CMDER:	PNTCI
	'?
	BR $$$CC

$$CNTLC:CLR DIAFLG
	CLRB TENRUN		;CLEAR PDP-10 RUNNING FLAG
	TST PCMDFLG		;DOING PROGRAM COMMAND ?
	BNE $$$CC		;YES
	CLR PRGRUN		;CLEAR PROGRAM RUNNING FLAG
$$$CC:	SETFLG
	  $TTLKF
	TST DEVTYP		;IN ACT10 MODE ?
	BPL 1$			;NO
	TST ENQFLG		;DOING APT10 COMMAND ?
	BEQ 1$			;NO

	COMCLR 			;ACT10, CLEAR COMM, THEN TO CONSL

1$:	PUSH $FORCE		;SAVE FORCED PRINTING FLAG
	PFORCE
	PCRLF 			;FORCE PRINT ERROR
	POP $FORCE		;RESTORE

	TST PCMDFLG		;DOING PROGRAM COMMAND ?
	BEQ 2$			;NO
	JMP PCMDE1		;YES, TAKE ERROR RETURN

2$:	CLR JFILEF		;CLEAR DOUBLE INDIRECT FLAG
	JMP KONSL

.SBTTL	CONSOLE DISPATCH TABLE

$KDCRE:	.ASCII /R /		;REPEAT OPERATOR
	.ASCII /FX/		;DIAGNOSTIC FUNCTION EXECUTE
	.ASCII /FW/		;DIAGNOSTIC FUNCTION WRITE
	.ASCII /FR/		;DIAGNOSTIC FUNCTION READ
	.ASCII /FS/		;DIAGNOSTIC FUNCTION SYNC
	.ASCII /DA/		;DIAGNOSTIC DEPOSIT INTO AR
	.ASCII /EX/		;PDP-10 INSTRUCTION EXECUTE
	.ASCII /MR/		;MASTER RESET

;PDP-10 EXAMINE/DEPOSIT FUNCTIONS

	.ASCII /EM/		;EXAMINE 10 AT ADR AND PRINT
	.ASCII /DM/		;DEPOSIT DATA IN 10 ADDRESS
	.ASCII /EN/		;EXAMINE AND PRINT NEXT 10 ADDRESSES
	.ASCII /DN/		;DEPOSIT DATA INTO NEXT 10 ADDRESSES
	.ASCII /MZ/		;MEMORY ZERO

;START/STOP FUNCTIONS

	.ASCII /SP/		;STOP 10, CLEAR RUN FLOP
	.ASCII /RN/		;START 10, SET RUN FLOP
	.ASCII /SI/		;SINGLE INSTRUCTION,PUSH CONTINUE
	.ASCII /PL/		;PULSE CLOCK
	.ASCII /BU/		;BURST CLOCK
	.ASCII /SM/		;START MICRO CODE,SUPPORT EXAMINE/DEPOSIT
	.ASCII /ST/		;START AT 10 ADDRESS
	.ASCII /SW/		;PDP-10 SWITCHES
	.ASCII /AC/		;"AC BLK" SELECTION
	.ASCII /MC/		;PDP-10 MONITOR CONTINUE
	.ASCII /EP/		;SET EOP INTERVAL

;PDP-11 FUNCTIONS

	.ASCII /SE/		;START 11 AT ADR
	.ASCII /EE/		;EXAMINE 11 AT ADR AND PRINT
	.ASCII /DE/		;DEPOSIT DATA IN 11 ADDRESS
	.ASCII /EB/		;EXAMINE 11 BYTE
	.ASCII /DB/		;DEPOSIT 11 BYTE
	.ASCII /ZE/		;ZERO ELEVEN

;RAM FUNCTIONS

	.ASCII /EC/		;EXAMINE C-RAM AT ADDRESS AND PRINT
	.ASCII /DC/		;DEPOSIT DATA INTO C-RAM ADDRESS
	.ASCII /RC/		;READ C-RAM, FR'S 140-141-142-143
	.ASCII /ED/		;EXAMINE D-RAM AT ADDRESS AND PRINT
	.ASCII /DD/		;[START DDT] OR DEPOSIT D-RAM
	.ASCII /MM/		;MICRO-CODE SYNC MARK
	.ASCII /MU/		;MICRO-CODE SYNC UNMARK
	.ASCII /MT/		;MICRO-CODE TIME CHANGE

;CLOCK OPERATIONS

	.ASCII /CS/		;CLOCK SOURCE
	.ASCII /CR/		;CLOCK RATE

;PROCESSOR PARITY FUNCTIONS

	.ASCII /PD/		;DISABLE PARITY STOP
	.ASCII /PE/		;ENABLE PARITY STOP

;INTERNAL E-BOX REGISTER READ FUNCTIONS

	.ASCII /AR/		;READ & PRINT AR REGISTER
	.ASCII /BR/		;READ & PRINT BR REGISTER
	.ASCII /MQ/		;READ & PRINT MQ REGISTER
	.ASCII /FM/		;READ & PRINT FM REGISTER
	.ASCII /AD/		;READ & PRINT ADDER
	.ASCII /PC/		;READ & PRINT PC
	.ASCII /VM/		;READ & PRINT VMA
	.ASCII /SC/		;READ & PRINT SC REGISTER
	.ASCII /FE/		;READ & PRINT FE REGISTER
	.ASCII /ER/		;READ & PRINT E-BUS REGISTER
	.ASCII /PI/		;READ & PRINT PI SYSTEM
	.ASCII /AL/		;PRINT ALL, C-RAM & REGISTERS

;CACHE OPERATIONS

	.ASCII /CE/		;CACHE ENABLE
	.ASCII /CI/		;CACHE INVALIDATE
	.ASCII /CF/		;CACHE FLUSH

;REPEAT CONTROL

	.ASCII /RP/		;REPEAT & PRINT OR RP04 SELECT
	.ASCII /TD/		;TIME DELAY

;CONSOLE (TTY) CONTROL FUNCTION

	.ASCII /TP/		;SET TTY PAGE LENGTH
	.ASCII /TW/		;SET TTY PAGE WIDTH
	.ASCII /TF/		;SET TTY FILL COUNT

	.ASCII /TT/		;SWITCH TO REMOTE TELETYPE OPERATION
;	.ASCII /LP/		;LINE PRINTER SELECTION

	.ASCII /KL/		;KLINIK SELECTION

;KL10 MONITOR (PROGRAM & ACT10) COMMANDS

	.ASCII /B /		;BOOT
	.ASCII /LI/		;LOGIN
	.ASCII /H /		;HELP
	.ASCII /P /		;PROGRAM
	.ASCII /LT/		;LOAD TEN
	.ASCII /LE/		;LOAD ELEVEN
	.ASCII /LR/		;LOAD RAM
	.ASCII /LB/		;LOAD ELEVEN BINARY
	.ASCII /V /		;VERFIY PROGRAM
	.ASCII /S /		;SCRIPT
	.ASCII /M /		;MASTER SCRIPT
	.ASCII /C /		;COMMENT/CORRECTIVE ACTION
	.ASCII /GO/		;GO START PROGRAM
	.ASCII /LO/		;LOGOUT
	.ASCII /GS/		;GENERATE SCRIPT
;	.ASCII /CD/		;PDP-11 CORE DUMP
	.ASCII /TA/		;ACT10 TO RP04 TRANSFER
	.ASCII /WF/		;DECTAPE TO RP04 WRITE
	.ASCII /WU/		;RP04 TO DECTAPE WRITE
	.ASCII /UI/		;DECTAPE INITIALIZE
	.ASCII /UD/		;DECTAPE DELETE
	.ASCII /US/		;DECTAPE SALVAGE
	.ASCII /FL/		;FLAP DECTAPE
	.ASCII /RE/		;'RENM' RENAME RP04 FILE
	.ASCII /T /		;TIME
	.ASCII /BT/		;BOOT TEN

	.ASCII /AT/		;SWITCH TO ACT10 MODE
	.ASCII /DT/		;SWITCH TO DECTAPE MODE, SELECT UNIT
	.ASCII /RX/		;SWITCH TO FLOPPY MODE, SELECT UNIT
	.ASCII /DI/		;DIRECTORY, DECTAPE/RP04/FLOPPY

	.ASCII /BP/		;BREAKPOINT TRAP LAYER
	.ASCII /BC/		;BREAKPOINT CONTINUE
	.ASCII /RG/		;TYPE OUT BREAK STUFF
	.ASCII /RB/		;REMOVE BREAKPOINTS
	.ASCII /HC/		;ERROR HALT CONTINUE

	.ASCII /RI/		;REINITIALIZE SYSTEM

	.ASCII /I /		;INDIRECT COMMAND FILE PROCESS
	.ASCII /J /		;DOUBLE INDIRECT COMMAND FILE
	.ASCII /JC/		;"J" FILE CONTINUE
	.ASCII /IT/		;TURN ON I.T.S. PROG
	.ASCII /DS/		;DISK STATUS

$KDCEN:	0 			;ERROR TRAP FOR NONEXISTANT COMMANDS

;DISPATCH TABLE

$DISPH:	.RPT 			;REPEAT OPERATION
	.DFXCT 			;DIAGNOSTIC FUNCTION EXECUTE
	.DFWRT 			;   "         "      WRITE
	.DFRD 			;   "         "      READ
	.FS 			;   "         "      SYNC
	.DA 			;   "       DEPOSIT INTO AR
	.XCT 			;EXECUTE 10 INSTRUCTION
	.MRESET 		;MASTER RESET
	.EXM 			;EXAMINE 10
	.DP 			;DEPOSIT 10
	.EXMNX 			;EXAMINE NEXT 10
	.DPNX 			;DEPOSIT NEXT 10
	.MZ 			;MEMORY ZERO
	$SP 			;STOP 10
	$RN 			;RUN 10
	$SI 			;SINGLE INSTRUCT 10
	.PL 			;PULSE 10
	.BU 			;BURST CLOCK
	.SM 			;START MACHINE
	$ST 			;START 10
	$SW 			;SWITCHES 10
	.AC 			;"AC BLK" SELECTION
	$MC 			;MONITOR CONTINUE
	.EP 			;SET EOP INTERVAL
	.SE 			;START ELEVEN
	.EE 			;EXAMINE ELEVEN
	.DE 			;DEPOSIT ELEVEN
	.EB 			;EXAMINE 11 BYTE
	.DB 			;DEPOSIT 11 BYTE
	.ZE 			;ZERO ELEVEN
	$EC 			;EXAMINE C_RAM
	$DC 			;DEPOSIT C-RAM
	$RC 			;READ C-RAM
	$ED 			;EXAMINE D_RAM
	$DDTX 			;[START DDT] OR DEPOSIT D_RAM
	.MM 			;MICRO-CODE MARK
	.MU 			;MICRO-CODE UNMARK
	.MT 			;MICRO-CODE TIME CHANGE

	.CS 			;SELECT CLOCK SOURCE
	.CR 			;SELECT CLOCK RATE
	.PD 			;PROCESSOR PARITY DISABLE
	.PE 			;PROCESSOR PARITY ENABLE
	.AR 			;READ REGISTERS
	.BR
	.MQ
	.FM
	.AD
	.PC
	.VM
	.SC
	.FE
	.ERG
	.PI 			;READ & PRINT PI SYSTEM
	.ALL 			;PRINT ALL
	.CE 			;CACHE ENABLE
	.CI 			;CACHE INVALIDATE
	.CF 			;CACHE FLUSH
	.RPTP 			;REPEAT & PRINT
	.TD 			;TIME DELAY
	$TP 			;SET TTY PAGE LENGTH
	$TW 			;SET TTY PAGE WIDTH
	$TF 			;SET TTY FILL PARAMETER
	$TT 			;SWITCH TO REMOTE TTY
;	$LPT 			;LINE PRINTER SELECTION
	.KLINIK 		;KLINIK SELECTION

;KL10 MONITOR (PROGRAM & ACT10) COMMANDS

	$BOOT 			;BOOT SYSTEM
	$LOGIN 			;LOG IN
	$HELP 			;HELP
	$PROG 			;LOAD PROGRAM
	$LDT 			;LOAD TEN
	$LDE 			;LOAD ELEVEN
	$LDR 			;LOAD RAM
	$LDB 			;LOAD ELEVEN BINARY
	$VERIFY 		;VERIFY PROGRAM
	$SCRPT 			;SCRIPT REQUEST
	$MSCP 			;MASTER SCRIPT REQUEST
	$COMNT 			;COMMENT
	$GO 			;PROGRAM GO
	$LOGO 			;LOG OUT
	$GSCP 			;GENERATE SCRIPT
;	$CD 			;PDP-11 CORE DUMP
	$TA 			;ACT10 TO RP04 TRANSFER
	$WF 			;DECTAPE TO RP04 WRITE FILE
	$WU			;RP04 TO DECTAPE WRITE
	$UI			;DECTAPE INITIALIZE
	$UD			;DECTAPE DELETE
	$US			;DECTAPE SALVAGE
	$UF			;DECTAPE FLAP
	$RE 			;'RENM' RP04 RENAME FILE
	$TIME 			;TIME
	$BOOTT 			;BOOT PDP-10
	$AT 			;SELECT ACT-10 MODE
	$DT 			;SELECT DECTAPE MODE & UNIT
	$RX 			;SELECT FLOPPY MODE & UNIT
	$DI 			;DIRECTORY, DECTAPE/RP04/FLOPPY
	.BP 			;BREAKPOINT INSERTION
	.BC 			;BREAKPOINT CONTINUE
	.RG 			;PRINT SAVED REGISTERS
	.RB 			;REMOVE BREAKPOINTS
	.HC 			;HALT CONTINUE
	.RI 			;REINITIALIZE CONSOLE
	$IFILE 			;INDIRECT FILE
	$JFILE 			;DOUBLE INDIRECT FILE
	$JC 			;J FILE CONTINUE
	$ITS			;TURN ON I.T.S. PROG
	DSKSTS			;PRINT DISK STATUS

	$CMDER 			;NO SUCH COMMAND

.SBTTL	DIAGNOSIC CONSOLE UTILITY COMMAND PROCESS

;UTILITY PROGRAM CHECK

$KLUCK:	CMP PID,PIDU		;UTILITY PROGRAM IN CORE ?
	BNE 1$
	CMP PID+2,PIDU+2
	BNE 1$
	CMP PDVER,#DECVER	;PROPER VERSION ?
	BNE 1$
	RTS PC			;OK

1$:	PMSG <PLEASE LOAD "KLDCPU.A11" FIRST>
	JMP $CNTLC

PIDU:	.RAD50 /KLDCPU/

;TRANSFER FROM APT10 DISPATCH

$TA:	JSR PC,$KLUCK		;UTILITY IN CORE ?
	JMP @TAPT		;YES

;WRITE FILE FROM DTA/FLOPPY DISPATCH

$WF:	JSR PC,$KLUCK		;UTILITY IN CORE ?
	JMP @WFILE		;YES

$WU:	JSR PC,$KLUCK
	JMP @WUTAPE

$UI:	JSR PC,$KLUCK
	JMP @UINIT

$UD:	JSR PC,$KLUCK
	JMP @UFDELE

$US:	JSR PC,$KLUCK
	JMP @USALV

$UF:	JSR PC,$KLUCK
	JMP @UFLAP

;REMOTE TELETYPE COMMUNICATIONS DISPATCH

$TT:	JSR PC,$KLUCK		;UTILITY IN CORE ?
	JMP @REMOTE		;YES

;RP04 DISK DIRECTORY DISPATCH

$RPDIR:	JSR PC,$KLUCK		;UTILITY IN CORE ?
	JMP @DSKDIR		;YES

;CHECK FOR I.T.S. IOELEVEN PROGRAM IN CORE

ITSCHK:	CMP PID,PIDI
	BNE 1$
	CMP PID+2,PIDI+2
	BNE 1$
	RTS PC			;OK

1$:	PMSG <? I.T.S. IO-ELEVEN PROGRAM NOT IN CORE>
	CLR ITSFLG
	MOV #PR7,PS		;TURN OFF INTS AGAIN
	MOV #PR7,EMTVEC+2
	JMP $CNTLC

PIDI:	.RAD50 /IOELEV/

;THE "ITS" COMMAND COMES HERE

$ITS:	TTICHR			;MAKE SURE 3RD CHAR IS "S"
	 BCS 1$
	CMPB R0,#'S
	BNE 1$
20$:	TTICHR			;COULD BE ITS OFF COMMAND
	 BCS 1$
	CMPB R0,#40
	BEQ 20$
	CMPB R0,#'O
	BNE 2$
	TTICHR
	 BCS 1$
	CMPB R0,#'F
	BNE 1$
	TTICHR
	 BCS 1$
	CMPB R0,#'F
	BNE 1$
	TTITRM
	JSR PC,ITSOF1		;TURN IOELEV OFF
	JMP $KONSL

2$:	TTBTRM
	JSR PC,ITSCHK		;MAKE SURE IOELEV IS AROUND
	MOV #-1,ITSFLG
	MOV #PR0,PS		;TURN ON INTERRUPTS
	MOV #PR0,EMTVEC+2
	JSR PC,@#3000		;GET PROGRAM INITIALIZED, WILL RETURN IF TEN NOT RUNNING
	JMP $KONSL		;RETURN TO COMMAND PROC

1$:	JMP $CMDER

;SUBROUTINE TO TURN ITS OFF IF ON.  CLOBBERS NO REGISTERS,
;BUT DOES DO A RESET.
ITSOFF:	TST ITSFLG
	BNE 1$
	RTS PC

1$:	MOV R0,-(SP)
	PMSG <ITS OFF\>
	JSR PC,ITSOF1
	MOV (SP)+,R0
	RTS PC

ITSOF1:	CLR ITSFLG
30$:	TSTB @$TPS
	BPL 30$
	RESET			;IS THIS DESIRABLE?
				;GOTTA FLUSH INTERRUPTS SOMEHOW
	CLR R0
	SOB R0,.		;DELAY 100 MS FOR LUCK
	RTS PC

.SBTTL	CONSOLE COMMAND REPEAT CONTROL

.RPT:	SETFLG
	  RPTFLG		;SET REPEAT FLAG

.RPTX:	PNORML
	JMP $RPT

.RPTP:	TTISDL
	 BCC 1$			;NUMBER
	TTBACK
	MOV #177400,RPTFLG	;SET REPEAT & PRINT
	BR .RPTX

1$:	JMP $RP			;MUST BE RP04 SELECTION

.SBTTL	PROGRAM CONSOLE COMMAND PROCESS

$PRGNPT:SETFLG 			;PROGRAM COMMAND, NO PRINT
	  PCMDNF
	BR $PRGXX
$PRGCMD:CLR PCMDNF
$PRGXX:	SETFLG
	  PCMDFLG		;SET PROGRAM COMMAND FLAG
	TST R0
	BEQ 2$			;USE CURRENT INPUT BUFFER, R0=0
	CMP #-1,R0
	BNE 3$
	MOV #$OUTBF,R0		;USE OUTPUT BUFFER, R0 = -1
	MOV R0,$OUTPT
3$:	JSR PC,$PCMDX		;TRANSFER COMMAND TO INPUT BUFFER
2$:	MOV #$INBUF,$INPTC	;SET PICKUP POINTER
	MOV SP,$$SVSP		;SAVE STACK POINTER
	JMP $RPT		;PROCESS COMMAND

PCMDE:	MOV $$SVSP,SP		;RESTORE STACK POINTER
	CLR PCMDFLG
	CLR PCMDNF
	CLR ENQFLG
	EXIT
PCMDE1:	MOV $$SVSP,SP
PCMDE3:	CLR PCMDFLG		;ERROR, C-BIT SET RETURN
	CLR PCMDNF
	CLR HLPPNT
	EXITERR
PCMDE2:	MOV $$SVSP,SP
	BIS #NBIT,14(SP)	;CONTROL C DURING TYPEOUT
	BR PCMDE3		;NBIT & CBIT SET RETURN

$PCMDX:	MOV #$INBUF,R1		;MOVE COMMAND TO INPUT BUFFER
$DIASX=.
1$:	MOVB (R0)+,(R1)+	;TRANSFER CHARS
	BNE 1$			;TILL NULL
	DEC R1
	MOVB #CR,(R1)+
	MOVB #LF,(R1)+
	MOV R1,$INPTR		;SAVE EOL POINTER
	RTS PC

;PROGRAM INDIRECT CCL FILE PROCESS

$TTICCL:MOV IFINP,R1		;XFER CHARS INTO INPUT BUFFER
	TSTB (R1)		;FIRST CHAR A NULL ?
	BEQ 1$			;YES, FINISHED
	JSR PC,IJFILX
	MOV R1,IFINP		;RESAVE POINTER
	EXIT
1$:	EXITERR 		;FINISHED, C-BIT SET RETURN

;INDIRECT COMMAND FILE PROCESS

IFILIN:	MOV IFINP,R1		;XFER CHARS INTO INPUT BUFFER
	TSTB (R1)		;FIRST CHAR A NULL ?
	BEQ IFILX1		;YES, FINISHED
	JSR PC,IJFILX
	MOV R1,IFINP		;RESAVE STORAGE POINTER
	TST JFILEF		;DON'T PRINT "I" IF UNDER "J"
	BNE 3$
IFILX=.
	$PMSG 			;PRINT COMMAND LINE
	$INBUF
3$:	JMP $RPT		;GO PROCESS

IFILX1:	JMP CONSL		;FINISHED

;DOUBLE INDIRECT COMMAND FILE PROCESS

JFILIN:	TST PRGRUN		;PROGRAM PRESENTLY RUNNING ?
	BEQ 3$			;NO
	JMP $KONS2		;YES, WAIT TILL IT'S DONE
3$:	MOV JFINP,R1		;XFER CHARS INTO INPUT BUFFER

	TSTB (R1)		;FIRST CHAR A NULL ?
	BEQ 2$			;YES, FINISHED

	JSR PC,IJFILX
	MOV R1,JFINP		;RESAVE STORAGE POINTER
	BR IFILX

2$:	CLR JFILEF
	BR IFILX1

IJFILX:	MOV #$INBUF,R0
	MOV R0,$INPTC

1$:	MOVB (R1)+,(R0)+
	BNE 1$

	MOV R0,$INPTR
	RTS PC

.SBTTL	DIAGNOSTIC FUNCTIONS

;DIAGNOSTIC FUNCTION EXECUTE

.DFXCT:	DFLEGAL 		;FUNCTION LEGAL ?
	TTISDO 			;GET FUNCTION
	CMP R0,#037		;FUNCTION VALID ?
	BGT $DFERR		;FX IS 000 TO 037

	DFXCT 			;DF EXECUTE
	BR .DFX			;RETURN TO CONSOLE

;DIAGNOSTIC FUNCTION WRITE

.DFWRT:	DFLEGAL 		;FUNCTION LEGAL ?
	TTISDO 			;GET FUNCTION
	CMP R0,#040
	BLT $DFERR
	CMP R0,#077
	BGT $DFERR		;FW IS 040 TO 077
	MOV R0,R2		;SAVE FUNCTION
	TTIS36 			;GET DATA
	MOV R0,R1		;PUT ADR OF 36BITS IN R1
	
	MOV R2,R0		;FUNCTION IN R0
	DFWRT 			;DIAGNOSTIC FUNCTION WRITE

.DFX:	JMP $KONSL

;DIAGNOSTIC FUNCTION SYNC, GENERATES PULSE AT "A36E1"

.FS:	DFLEGAL 		;FUNCTION LEGAL ?
	TTITRM
	DFXCTT
	  74 			;SYNC IS FUNCTION EXECUTE 74
	BR .DFX

$DFERR:	PMSG <?FUNCTION ERR>
	JMP $CNTLC

;DIAGNOSTIC READ AND PRINT

.DFRD:	DFLEGAL 		;FUNCTION LEGAL ?
	CLR R3
	TTISDO 			;GET FUNCTION
	MOV R0,R2
	TTIBRK
	 BCS $DFERR
	CMPB #COMMA,R0		;IF BREAK IS A COMMA, MULTIPLE DFRD
	BNE 1$

	INC R3
	TTCOCT
	MOV R0,R4		;SAVE LAST DFRD
1$:	TSTB RPTFLG
	BNE 2$

	MOV R2,R0
	PNTOCS
	PSLASH
2$:	MOV R2,R0
	BEQ 21$			;FR 0 USED TO READ E-BUS
	CMP R0,#100
	BLT $DFERR
	CMP R0,#177
	BGT $DFERR		;FR IS 100 TO 177
21$:	MOV #.DFRDA,R1
	DFRDMV
	TSTB RPTFLG
	BNE 3$
	MOV R1,R0
	PNT36B 			;PRINT IN BINARY

3$:	TST R3
	BEQ 4$

	PCRLF
	CMP R2,R4
	BHIS 4$
	INC R2
	BR 1$

4$:	BR ALLEXT

.DFDP:	DFLEGAL 		;FUNCTION LEGAL ?
	MOV #.DFRDA,R1
	DFRDMV 			;READ THE E-BUS

	TSTB RPTFLG
	BNE .DFX
.DFDPC:	MOV #.DFRDA,R0
	PNT36 			;PRINT IT OUT

ALLEXT:	TST ALLFLG		;DOING ALL ?
	BNE 1$			;YES
	TSTB RPTFLG		;DOING A REPEAT ?
	BNE 2$			;YES
ALLEX1=.
	PCRLF
2$:	BR .DFX
1$:	RTS PC			;ALL, CONTINUE

.MQ:	TTITRM
$ALLMQ=.
	PMSGR <MQ />
1$:	MOV #DPMQ,R0
	BR .DFDP

.FM:	DFLEGAL 		;FUNCTION LEGAL ?
	TTITRM
$ALLFM=.
	TSTB RPTFLG
	BNE 1$
	PNTCI
	"FM
	DFRDT 			;READ FM ADDRESS
	  DPFMA
	MOV @.DAT2,R0
	SHIFTR
	  5
	BIC #177760,R0
	PNTODT
	  2
	PNTCI
	'/
1$:	MOV #DPFM,R0
	BR .DFDP

$DPERR:	JMP $DFERR

.AR:	TTICHR
	 BCS $DPERR
	CMPB #'X,R0		;IS COMMAND 3 LETTERS ?
	BEQ 1$			;BR IF 3RD LETTER IS X
	TTBTRM
$ALLAR=.
	PMSGR <AR />
2$:	MOV #DPAR,R0
	BR .DFDP		;READ AND PRINT AR

1$:	TTITRM
$ALARX=.
	PMSGR <ARX/>
3$:	MOV #DPARX,R0
	BR .DFDP

.AD:	TTICHR
	 BCS $DPERR
	CMPB #'X,R0		;IS COMMAND 3 LETTERS ?
	BEQ 1$			;BR IF 3RD LETTER IS X
	CMPB #'B,R0
	BEQ .ADB		;ADB, PRINT ADDRESS BREAK
	TTBTRM
$ALLAD=.
	PMSGR <AD />
2$:	MOV #DPAD,R0
	BR .DFDP		;READ AND PRINT AD

1$:	TTITRM
$ALADX=.
	PMSGR <ADX/>
3$:	MOV #DPADX,R0
	BR .DFDP		;READ AND PRINT ADX

.BR:	TTICHR
	 BCS $DPERR
	CMPB #'X,R0		;IS COMMAND 3 LETTERS ?
	BEQ 1$			;BR IF 3RD LETTER IS X
	TTBTRM
$ALLBR=.
	PMSGR <BR />
2$:	MOV #DPBR,R0
	BR .DFDP		;READ AND PRINT BR

1$:	TTITRM
$ALBRX=.
	PMSGR <BRX/>
3$:	MOV #DPBRX,R0
	BR .DFDP		;READ AND PRINT THE BRX

.ERG:	TTICHR
	 BCS $DPER1
	CMPB #'G,R0
	BNE $DPER1
	TTITRM

$ALLEB:	PMSGR <ERG/>
	MOV #DPERG,R0
	BR .DFDP		;READ & PRINT EBUS REGISTER

;MASTER RESET

.MRESET:TTITRM
	MRESET
	BR .DAX

;DEPOSIT INTO AR

.DA:	DFLEGAL 		;FUNCTION LEGAL ?
	TTIS36 			;GET 36 BIT AR DATA
	MOV R0,R1		;ADR OF 36 BITS TO R1
	JSR R5,WIRAR1		;CALL IR/AR WRITE ROUTINE
.DAX:	JMP $KONSL

.PC:	TTICHR
	 BCS $DPER1
	CMPB #'F,R0
	BEQ .PCF
	TTBTRM
$ALLPC=.
	PMSG <PC />
	TST TENRUN		;PDP-10 PRESENTLY RUNNING ?
	BEQ 1$			;NO, GO AHEAD THEN
	DFXCTT
	  CLRRUN		;CLEAR RUN
	TDELAY 			;WAIT FOR HALT LOOP
	DFXCTT
	  STPCLK		;STOP CLOCK

	DFPC 			;READ PC

	PUSH R0
	DFXCTT
	  STRCLK		;START CLOCK
	DFXCTT
	  SETRUN		;SET RUN
	DFXCTT
	  CONBUT		;SET CONTINUE
	POP R0
	BR PCVMAP		;GO PRINT

1$:	DFPC

PCVMAP:
	PNTADR
	TST ALLFLG
	BNE 1$
	JMP ALLEX1		;RETURN TO CONSOLE
1$:	RTS PC			;ALL, RETURN TO ROUTINE

.VM:	DFLEGAL 		;FUNCTION LEGAL ?
	TTICHR
	 BCS $DPER1
	CMPB #'A,R0
	BEQ 1$
	CMPB #'H,R0
	BEQ .VMH
	BR $DPER1
1$:	TTITRM
$ALVMA=.
	PMSG <VMA/>
	DFVMA
	BR PCVMAP

$DPER1:	JMP $DFERR

.VMH:	TTITRM
$ALVMH=.
	PMSG <VMH/>
	DFVMAH
	BR PCVMAP

.ADB:	DFLEGAL 		;FUNCTION LEGAL ?
	TTITRM
	PMSG <ADB/>
	DFADB
	BR PCVMAP

;PCF COMMAND - PRINT THE PC FLAGS

.PCF:	TTITRM
	TST TENRUN		;TEN MUST BE STOPPED WHILE FLAGS ARE GOBBLED
	BEQ 1$
	DFXCTT
	  CLRRUN
	TDELAY
	DFXCTT
	  STPCLK
	JSR PC,PCF
	DFXCTT
	  STRCLK
	DFXCTT
	  SETRUN
	DFXCTT
	  CONBUT
	BR 2$

1$:	JSR PC,PCF
2$:	JMP ALLEX1		;CRLF AND RETURN TO KONSL

PCF:	PMSG <PCF/ >
	MOV #PCFTBL,R5
	CLR R4			;R4 ZERO IF THIS IS FIRST FROB TYPED
1$:	MOVB (R5)+,R0		;GET DIAG FUNC FOR NEXT BIT
	BEQ 9$			;BR IF END OF TABLE
	DFRD			;GET BIT INTO DTE REG
	MOV @.DAT1,R2		;BITS 0-3
	MOV @.DAT2,R1		;BITS 4-19
	.REPT 4
	 ASL R1
	 ROL R2
	.ENDR			;BITS 0-7 (4.9-4.2) RIGHT ALIGNED IN R2
	MOVB (R5)+,R1		;GET MASK FOR BIT OF INTEREST
	BPL 2$
	COM R2			;BIT BACKWARDS IN HARDWARE
	NEG R1
2$:	MOV (R5)+,R0		;GET POINTER TO BIT NAME STRING
	BIT R1,R2
	BEQ 3$
	TST R4			;IF NOT FIRST, PUT A COMMA, SPACE
	BEQ 4$
	PNTCI
	  ", 
4$:	PNTAL			;BIT IS ON, GIVE NAME
	INC R4
3$:	BR 1$			;LOOP BACK FOR NEXT BIT

9$:	RTS PC

;PC FLAGS TABLE
;FIRST BYTE IS DIAG FCN, SECOND IS MASK FOR BIT (NEGATIVE => BIT COMPLEMENTED)
;SECOND WORD -> ASCIZ BIT NAME

.MACRO PCFTE NAME,DFN,MASK
	.LIT $$ZZQ,<.ASCIZ\NAME\>
	.BYTE DFN,MASK
	.WORD $$ZZQ
.ENDM

PCFTBL:	PCFTE OV,131,40
	PCFTE CRY0,131,20
	PCFTE CRY1,131,10
	PCFTE FOV,132,20
	PCFTE FPD,130,2
	PCFTE USER,134,-40
	PCFTE IOTLSR,136,4
	PCFTE PUBLIC,135,20
	PCFTE ADB INH,137,40
	PCFTE TRP 2,130,40
	PCFTE TRP 1,130,4
	PCFTE FXU,132,10
	PCFTE DIV,131,2
	0

.FE:	TTITRM
$ALLFE:	PMSGR <FE/>
1$:	MOV #DPFE,R4
	BR FESCP

.SC:	TTITRM
$ALLSC:	PMSGR <SC/>
1$:	MOV #DPSC,R4


FESCP:	DFLEGAL 		;FUNCTION LEGAL ?
	MOV R4,R0
	DFRD

	MOV @.DAT2,R3		;GET LO-ORDER 5 BITS
	SWAB R3			;FROM 7-11 OF DEXWDS
	BIC #177740,R3

	MOV R4,R0
	INC R0
	DFRD

	MOV @.DAT2,R0		;GET HI-ORDER 5 BITS
	SHIFTR
	3
	BIC #176037,R0
	BIS R3,R0		;COMBINE HI & LO ORDER BITS

	TSTB RPTFLG
	BNE 1$
	PNTODT
	4
	PSPACE
1$:	JMP ALLEXT

;PRINT PRIORITY INTERRUPT FUNCTIONS

.PI:	DFLEGAL 		;FUNCTION LEGAL ?
	TTITRM
	JSR PC,$ALPIG		;PRINT PI GENS
	JSR PC,$ALPIH		;PRINT PI HOLDS
	JSR PC,$ALPIO		;PRINT PI ON'S
	PCRLF
	JMP $KONSL

$ALPIG:	PMSG <PI GEN/>
	DFRDT
	  READ1 		;READ PI GENS
		;FR 101, BITS 11-17
$ALPIY:	MOV @.DAT2,R0
	SHIFTR
	  2

$ALPIX:	BIC #177600,R0		;DATA IS ONLY 7 BITS
	PNTODT
	  3
	RTS PC

$ALPIH:	PMSG < PI HOLD/>
	DFRDT
	  READ0 		;READ PI HOLDS
	MOV @.DAT2,R0		;FR 100, BITS 03-09
	MOV @.DAT1,R1
	ROR R1
	ROR R0
	SHIFTR
	  9.
	BR $ALPIX

$ALPIO:	PMSG < PI ON/>
	DFRDT
	  READ0 		;READ PI ONS
	BR $ALPIY		;FR 100, BITS 11-17

;PRINT ALL - C-RAM & REGISTERS

.ALL:	TTICHR
	 BCS 1$
	CMPB #'L,R0
	BNE 1$
	TTITRM
	DFLEGAL 		;FUNCTION LEGAL ?
	PNTCPU
	JMP $KONSL
1$:	JMP $DFERR		;ERROR

$PNTCPU:SETFLG
	  ALLFLG		;SET ALL FLAG
	PUSH RPTFLG
	CLR RPTFLG

	JSR PC,$ALLEC		;PRINT C-RAM

	JSR PC,$ALLAR		;PRINT AR
	JSR PC,$ALLBR		;PRINT BR
	JSR PC,$ALLAD		;PRINT ADDER
	JSR PC,$ALLSC		;PRINT SC
	JSR PC,$ALLPC		;PRINT PC
	PCRLF

	JSR PC,$ALARX		;PRINT ARX
	JSR PC,$ALBRX		;PRINT BRX
	JSR PC,$ALADX		;PRINT ADX
	JSR PC,$ALLFE		;PRINT FE
	JSR PC,$ALVMA		;PRINT VMA
	PCRLF

	JSR PC,$ALLMQ		;PRINT MQ
	JSR PC,$ALLFM		;PRINT FM
	JSR PC,$ALLEB		;PRINT EBUS REGISTER
	JSR PC,$ALVMH		;PRINT VMA HELD
	PCRLF

;THESE JUST TAKE UP TIME DURING MICROCODE TRACING, SO HAVE BEEN COMMENTED OUT
;	JSR PC,$ALPIG		;PRINT PI GENS
;	JSR PC,$ALPIH		;PRINT PI HOLDS
;	JSR PC,$ALPIO		;PRINT PI ON'S
;	PCRLF
	POP RPTFLG
	CLR ALLFLG
	EXIT

.SBTTL	PDP-10 START/STOP FUNCTIONS

;THESE REQUIRE STANDARD MICROCODE TO DO ANYTHING WORTHWHILE!

;STOP PDP-10, CLEAR RUN FLOP

$SP:	TTITRM
	TENSP 			;STOP TEN
	BCC 1$
	JMP .XCTER		;DID NOT STOP PROPERLY
1$:	CLR PRGRUN
	BR $RNX			;HOPE ENOUGH DELAY BUILT IN

;CONTINUE PDP-10 FROM OLD PC. ASSUME CLOCK MAY BE OFF

$RN:	TTICHR
	CMPB #'P,R0
	BEQ $RNP
	TTBTRM
$RNN:	CLR CLKPE		;CLEAR CLOCK PARITY ENABLES
	MOV #20,R2
	MOV PEBITS,R1		;GET ENABLE BITS
	BEQ 2$			;NOT ENABLED
	BIT R2,R1		;AR/ARX PARITY ENABLED ?
	BEQ 1$			;NO
	BIS #2,CLKPE		;YES, SET ENABLE BIT
1$:	BIS #1,CLKPE		;SET CLOCK STOP ENABLE

2$:	DFWRTT
	  CLKPE
	  LDCHK2		;LOAD ENABLE FUNCTION REGISTER

3$:	BIC R2,R1
	MOV R1,CLKPE		;SETUP FM,CRAM,DRAM, FS
	DFWRTT
	  CLKPE
	  LDCHK1		;LOAD CONDITION ENABLE REGISTER

	DFXCTT 			;GET CLOCK RUNNING
	  STRCLK
	DFXCTT 			;SET RUN AND LET 'ER GO
	  SETRUN
	DFXCTT 			;SET CONTINUE BUTTON
	  CONBUT
	SETFLG
	  TENRUN		;SET TEN RUN FLAG
	SETFLG
	  PRGRUN		;SET PROGRAM RUNNING FLAG
$RNX:	JMP $KONSL

$RNP:	TTITRM			;RUN WITH MICRO TRACE
	DFXCTT			;STOP CLOCK SO WON'T RUN UNTIL WE'RE READY
	  STPCLK
	DFXCTT 			;SET RUN AND LET 'ER GO
	  SETRUN
	JMP SIPNT		;PUSH CONTINUE & START TRACING

;START PDP-10 DDT

$DDTX:	TTISDL
	 BCS 1$			;NON-NUMBER
	JMP $DD			;NUMBER, MUST BE FOR D-RAM

1$:	CMPB #'T,R0
	BEQ 2$			;"DDT", START PDP-10 AT "DDTSRT"
	JMP $DFERR
2$:	TTITRM
	MOV TDDT,$$STJRS	;SET UP JRST INSTRUCTION
	MOVB TDDT+2,$$STJRS+2
		;I WISH THE HARDWARE PROVIDED AND EASY WAY TO CLEAR "USER"
		;MAYBE WE SHOULD PUT A SPECIAL JRST IN THE MICRCODE?
		;INSTEAD, A WARNING:
	DFRDT
	  134
	BIT #2,@.DAT1
	BNE 3$
	PMSG <? 10 IN USER MODE, YOU'VE GOTTA "MR" FIRST.>
	JMP $CNTLC

3$:	CLR TENTTY
	MOV #$$STJRS,R0
	EXCT			;DO JRST TO DDT START ADDRESS
	BCC $RNN		;AND GO SAY -10 IS RUNNING
$DDTER:	JMP .XCTER		;OR BARF IF UCODE HUNG

;SINGLE INSTRUCT PDP-10. ASSUME CLOCK IS RUNNING AND RUN IS SET

$SI:	TENSP 			;STOP TEN
	BCS $DDTER		;DID NOT STOP PROPERLY, BARF
	CLR R5
	TTISDL
	 BCS 4$			;NON-NUMBER
	TTIDEC
	 BCS 2$			;NO ARG, DO ONCE
	MOV R0,R5
2$:	DFXCTT 			;PRESS CONTINUE PULSER
	  CONBUT
	TDELAY 			;SMALL TIME DELAY
	DEC R5			;COMPLETED REQUESTED INSTRUCTIONS ?
	BGT 2$
	JMP $KONSL		;YES, RETURN TO CONSOLE

4$:	CMPB #'P,R0
	BNE 2$

5$:	TTITRM 			;"SIP",SINGLE INSTRUCT AND PRINT
	DFXCTT 			;STOP CLOCK
	  STPCLK
	JMP SIPNT		;REST SAME AS LAST OF "EXP"

;DIAGNOSTIC FUNCTION LEGALITY CHECK

$DFLEGAL:TST TENRUN		;PDP-10 PRESENTLY RUNNING ?
	BNE 1$			;YES, OPERATION ILLEGAL, ABORT
	EXIT
1$:	PMSG <?KL10 RUNNING, TYPE "SP" FIRST>
	JMP $$$CC

;PULSE THE E-BOX CLOCK

.PL:	DFLEGAL 		;FUNCTION LEGAL ?
	CLR TENCLK		;TURN OFF CLOCK IF ON
	TTISDL
	 BCS 1$			;NO ARG, DO ONCE
	TTIDEC
	 BCS 1$			;DO ONCE ANYWAY
	MOV R0,R1		;SAVE PULSE COUNT
	BR 2$
1$:	CLR R1
2$:	ECLOK
	 BCC 3$
	JSR R1,$ECTIM
3$:	DEC R1			;DONE REQUESTED CLOCKS ?
	BGT 2$			;NOT YET
.PLX:	JMP $KONSL

;START MICROCODE IDLE.
;SUPPORT EXAMINE, DEPOSIT, AND EXECUTE OPERATIONS.

.SM:	TTITRM
	SM 			;DO THE EMT
	BCS .XCTER
	BR .PLX

;CACHE INVALIDATE

.CI:	MOV #$$CI,R0

.CIF:	TTITRM
	DFLEGAL 		;FUNCTION LEGAL ?
	EXCT
	 BCS .XCTER		;FAILED
	BR .PLX			;OK, RETURN TO CONSOLE

;CACHE FLUSH

.CF:	MOV #$$CF,R0
	BR .CIF

$$CI:	IO10 DATAI,CCA,,0	;INVALIDATE WITHOUT CORE UPDATE
$$CF:	IO10 BLKO,CCA,,0	;SWEEP CACHE, VALIDATING CORE
.EVEN

;EXECUTE A PDP10 INSTRUCTION.

.XCT:	TENSP 			;STOP TEN
	BCS .XCTER		;DID NOT STOP PROPERLY

	TTISDL
	 BCS 1$			;NON-NUMBER

	TTIS36

	EXCT
	 BCS .XCTER

	BR .XCT2

1$:	CMPB #'P,R0		;"EXP" = EXECUTE & PRINT
	BNE .XCT1

	TTIS36

	LODAR 			;LOAD INTO AR
	 BCS .XCTER

SIPNT=.
	PNORML
	DFXCTT 			;SET CONTINUE BUTTON
	  CONBUT

2$:	ECLOK 			;CLOCK TO GET STARTED
	 BCC 3$
	JSR R1,$ECTIM

3$:	BIT #HALTLP,@.DIAG1
	BNE 2$			;TILL WE LEAVE HALT LOOP
	PNTCPU 			;PRINT C-RAM & REGISTERS

4$:	ECLOK 			;CLOCK
	 BCC 5$
	JSR R1,$ECTIM

5$:	PNTCPU 			;& PRINT TILL BACK TO HALT LOOP
	BIT #HALTLP,@.DIAG1
	BEQ 4$

.XCT2:	JMP $KONSL

.XCT1:	CMPB #'T,R0		;"EXT" = EXECUTE & TRACE SETUP
	BNE .CNSER

	TTIS36

	LODAR 			;LOAD INTO AR
	 BCS .XCTER

	DFXCTT 			;SET CONTINUE BUTTON
	  CONBUT

	BR .XCT2

.XCTER:	PMSG <?UCODE HUNG>
	JMP $CNTLC

.CNSER:	JMP $DFERR

;BURST THE KL10 CLOCK

.BU:	DFLEGAL 		;FUNCTION LEGAL ?
	CLR TENCLK		;TURN OFF CLOCKK IF ON
	TTISDL
	BCS 2$			;NO ARG, DO ONCE
	TTIDEC
	BCS 2$			;DO ONCE ANYWAY
1$:	BURST 			;PERFORM BURST
	BR .XCT2
2$:	MOV #1,R0		;DO ONE BURST
	BR 1$

;SELECT CLOCK SOURCE

.CS:	TTISDL
	BCC 1$
	MOV CLKDFL,R0
	SR R0,2
.CSR=.
	BIC #177774,R0
	PNTNBR
	PCRLF
	JMP $CONSL

1$:	TTISDO
	CMP R0,#2
	BGT .CSRER

	SHIFTL
	2
	BIC #14,CLKDFL		;CLEAR OLD SOURCE
.CCMN1:	BIS R0,CLKDFL		;SET NEW SOURCE
.CCMN:	DFLEGAL 		;FUNCTION LEGAL ?
	TST TENRUN
	BEQ 1$
	TENSP 			;STOP TEN
	BCS .XCTER		;DID NOT STOP PROPERLY
1$:	DFWRTT 			;WRITE TO CLOCK
	CLKDFL
	LDSEL
	JMP $KONSL

.CSRER:	JMP $PARA

;SELECT CLOCK RATE

.CR:	TTISDL
	BCC 1$
	MOV CLKDFL,R0
	BR .CSR

1$:	TTISDO
	CMP R0,#3
	BGT .CSRER

	BIC #3,CLKDFL		;CLEAR OLD RATE
	BR .CCMN1

;PROCESSOR PARITY DISABLE

.PD:	TTITRM
	CLR PEBITS		;CLEAR PARITY ENABLE BITS
	JMP $CONSL

;PARITY ENABLED AND CLOCK ERROR STOP MESSAGES

$PEAR:	.ASCIZ %, AR/ARX%
$PEFM:	.ASCIZ %, FM PARITY%
$PECR:	.ASCIZ %, CRAM PARITY%
$PEDR:	.ASCIZ %, DRAM PARITY%
$PEFS:	.ASCIZ %, FS PROBE%
.EVEN

;PROCESSOR PARITY ENABLE

;PARITY ENABLE BITS ARE CODED AS FOLLOWS:
; 	AR/ARX, FM, CRAM, DRAM, FS
;	0 = PARITY DISABLED
;	37 WOULD = ALL ENABLED

.PE:	TTISDL
	 BCC 1$

20$:	PMSG <ENABLED: >
	MOV PEBITS,R1		;PRINT PARITY ENABLE BITS
	MOV R1,R0
	PNTODT
	  2
10$:	BIT #20,R1
	BEQ 11$
	$PMSG
	  $PEAR 		;AR/ARX PAGE FAIL
11$:	BIT #10,R1
	BEQ 12$
	$PMSG
	  $PEFM 		;FM PARITY
12$:	BIT #4,R1
	BEQ 13$
	$PMSG
	  $PECR 		;CRAM PARITY
13$:	BIT #2,R1
	BEQ 14$
	$PMSG
	  $PEDR 		;DRAM PARITY
14$:	BIT #1,R1
	BEQ 15$
	$PMSG
	  $PEFS 		;FS PROBE
15$:	PCRLF
3$:	JMP $CONSL

1$:	TTISDO
	CMP R0,#37
	BGT .CSRER
	MOV R0,PEBITS		;SAVE
	BR 20$

;MICRO-CODE SYNC MARK ROUTINES

.MU:	MOV #-1,R5		;MICRO UNMARK
	BR .MMC

.MM:	CLR R5			;MICRO MARK

.MMC:	DFLEGAL 		;FUNCTION LEGAL ?
	TTICRA 			;GET C-RAM ADDRESS
	MOV R0,$ECADR

	RCRAM 			;READ C-RAM

	TST R5
	BNE 3$
	BIS #20,4(R0)		;SET MARK BIT
	BR .MMX
3$:	BIC #20,4(R0)		;CLEAR MARK BIT

.MMX:	MOV R0,R1
	MOV $ECADR,R0
	WCRAM 			;WRITE C-RAM BACK
	JMP $KONSL

;MICRO-CODE TIME FIELD CHANGE ROUTINE

.MT:	DFLEGAL 		;FUNCTION LEGAL ?
	TTICRA
	MOV R0,$ECADR

	TTISDO
	CMP R0,#3		;TIME FIELD IS 0-3
	BGT .CSRER
	MOV R0,R5

	MOV $ECADR,R0
	RCRAM 			;READ C-RAM
	BIC #12,(R0)		;CLEAR OLD TIME
	CLR R4
	BIT #2,R5
	BEQ 1$
	BIS #10,R4
1$:	BIT #1,R5
	BEQ 2$
	BIS #2,R4
2$:	BIS R4,(R0)		;SET NEW TIME
	BR .MMX

;CACHE ENABLE

;CACHE ENABLE BITS ARE CODED AS FOLLOWS:
;	10 = CACHE 0
;	 4 = CACHE 1
;	 2 = CACHE 2
;	 1 = CACHE 3
;	17 WOULD = ALL CACHES ENABLED

.CE:	TTISDL 			;GET ENABLE CODE
	BCS 20$			;CR, PRINT ENABLE
1$:	TTISDO
	CMP R0,#17		;ENABLE IS 0 TO 17
	BGT 2$
	MOV R0,CLKDFL+4		;PUT IN CLOCK DEFAULT PARAMETER WORD
	BR 20$
2$:	JMP $PARAM

20$:	PMSG <CACHES ENABLED: >
	MOV CLKDFL+4,R1
	MOV R1,R0
	PNTODT 			;PRINT CODE
	  2
21$:	CLR R2
	BIT #10,R1		;CACHE 0 ENABLED ?
	BEQ 22$
	JSR PC,.CEP

22$:	INC R2
	BIT #4,R1		;CACHE 1 ENABLED ?
	BEQ 23$
	JSR PC,.CEP

23$:	INC R2
	BIT #2,R1		;CACHE 2 ENABLED ?
	BEQ 24$
	JSR PC,.CEP

24$:	INC R2
	BIT #1,R1		;CACHE 3 ENABLED ?
	BEQ 25$
	JSR PC,.CEP

25$:	PCRLF
	JMP $CONSL

.CEP:	PMSG <, CACHE >
	MOV R2,R0
	PNTNBR 			;PRINT CACHE ENABLE DIGIT
	RTS PC

;AC BLOCK SELECTION
;SETS UP "PAGDFL" WORD USED BY "DATAO PAG,0"
;DURING "STD,STM,STL & DDT" START COMMANDS
;SAME "PAGDFL" WORD USED BY "DATAO PAG,20"
;DURING AC BLOCK SELECTION COMMAND

.AC:	DFLEGAL
	MOV #PAGDFL+2,R5
	TTISDL 			;ALLOW FOR "ACBLK" OR "AC BLK"
	 BCC 5$			;NUMBER
	CMPB #'B,R0
	BNE 5$
	TTICHR
	CMPB #'L,R0
	BNE 5$
	TTICHR
	CMPB #'K,R0
	BNE 5$

	TTISDL 			;ANY NUMBER ?
	 BCS 4$			;NO, PRINT PRESENT SELECTION

	TTISDO 			;GET SELECTION DIGIT
	CMP R0,#7		;MUST BE 0 TO 7
	BGT 5$
	BEQ 3$			;IF BLK #7, GIVE UCODE WARNING

1$:	PUSH R0
	PMSG <PREV AC BLK >
	MOV (R5),R0
	SHIFTR
	  11.
	PNTNBR
	PNTCI
	", 
	POP R0
	SHIFTL 			;PLACE SELECTION DIGIT IN BITS 6-8
	  11.
	BIC #034000,(R5)
	BIS R0,(R5)		;INSERT IN PAGE DEFAULT WORD

4$:	PMSG <SELECTED AC BLK >
	MOV (R5),R0		;PRINT PRESENT AC BLOCK SELECTION
	SHIFTR
	  11.
	PNTNBR
	PCRLF
	EXAMT 			;SAVE MEM LOCATION 20
	  20
	  $SAV20
	BCS 6$
	DPOSVT 			;PUT DATAO PAG ARGUMENT IN 20
	  20
	  PAGDFL
	BCS 6$
	MOV #DATPAG,R0
	EXCT 			;EXECUTE DATAO PAG
	 BCS 6$
	DPOSVT 			;RESTORE 20
	  20
	  $SAV20
	BCS 6$
	JMP $CONSL

3$:	PUSH R0
	PMSG <UCODE BLK\>
	POP R0
	BR 1$

6$:	PMSG <?SELECTION ERR>
	JMP $CNTLC

5$:	JMP $PARAM		;ERROR

DATPAG:	IO10 DATAO,PAG,,20	;SELECT AC BLOCK
.EVEN

;START PDP10 AT ADDRESS SPECIFIED AS LOWER 18 BITS OF 36-BIT ARGUMENT.

$ST:	TTISDL
	 BCS 4$			;NON-NUMBER
	TTIS36			;READ ADDRESS, LEAVE R0 POINTING AT IT
$$ST=.
	CLR R5

5$:	MOV #$$STJRS,R1		;STUFF ADDRESS INTO JRST
	MOVB (R0)+,(R1)+
	MOVB (R0)+,(R1)+
	BICB #3,(R1)
	BISB (R0),(R1)		;DO LAST TWO BITS

3$:	TST R5			;ADDRESS START ?
	BNE 31$			;NO, PERFORM FULL SYSTEM RESET
	BR 11$			;YES, JUST DO JRST

1$:	PUSH R0
	EXCT 			;EXECUTE A TEN INSTR
	 BCS $STERR
	POP R0
	ADD #5,R0
	DEC R1
	BNE 1$			;DO ANOTHER
	JSR PC,$TI36C		;ZERO SELECTED AC BLOCK
	MOV #$DRAM,R1
	MOV #16.,R0		;FROM AC0 TO AC17
	D10ZRO 			;NECESSARY FOR FM PARITY
	 BCS $STERR

11$:	MOV #$$STJRS,R0
	EXCT 			;EXECUTE JRST TO START ADR
	 BCS $STERR

	CLR TENTTY		;TURN OFF "TENCHR" ROUTINE
	JSR PC,$CMCLR		;CLEAR COMMON STORAGE
	MOV #100.,$ENDCT	;REPORT EOP EVERY 100
	JMP $RNN

31$:	SM 			;START MACHINE
	 BCS $STERR
	DPOSVT 			;DEPOSIT "DATAO PAG,0" ARGUMENT
	  0 			;IN AC0, SELECTS CURRENT AC USAGE
	  PAGDFL
	 BCS $STERR
	SETFLG 			;SET TEN RUN FLAG
	  TENRUN
	TENSW 			;DEPOSIT PDP-10 SWITCHES
	 BCC 32$
	JMP C10SWE		;SWITCH ERROR
32$:	MOV #4.,R1
	MOV #$STTB1,R0
	BR 1$

4$:	CMPB #'D,R0		;IF "STD", START 10 DIAGNOSTIC
	BNE 6$
	MOV #TDIAG,R0
7$:	TTITRM
$$$ST=.
	MOV #-1,R5
	BR 5$
6$:	CMPB #'L,R0		;IF "STL", START PDP-10 LOADER
	BNE 8$
	MOV #TLDR,R0
	BR 7$
8$:	CMPB #'M,R0		;IF "STM", START PDP-10 MONITOR
	BNE 11$
	MOV #TMON,R0		;IF NONE, START AT LAST START ADR
	BR 7$
$STERR:	JMP .XCTER

$STTB1:	IO10 CONO,APR,,267760		;RESET APR
	IO10 CONO,PI,,10000		;PI SYSTEM CLEAR
	IO10 CONO,PAG,,0		;PAGING SYSTEM CLEAR
	IO10 DATAO,PAG,,0		;USER BASE CLEAR & AC SELECT
.EVEN
.CNERR:	JMP $PARA

.SBTTL	PDP-10 DEPOSIT AND EXAMINE CONSOLE FUNCTIONS

.DP:	MOV #.DPXAD,R5
	TTISDL
	 BCS .DPS
	TTIS36
	MOV (R0)+,(R5)+		;LOW ADDRESS
	MOV (R0),(R5)		;HIGH ADDRESS
.DPNX1:	TST -(R5)

.DPCOM:	TTIS36 			;GET DATA
	MOV R5,R1		;PTR TO ADR
	JSR PC,$TENRN
	DPOS 			;DO IT
	 BCS 1$
	JMP $KONSL

1$:	PMSG <?DM>
	JSR R1,$DFTM1

.DPNX:	MOV #.DPXAD,R5
	ADD #1,(R5)+		;BUMP LOW
	ADC (R5)		;CARRY TO HIGH
	BR .DPNX1

.DPS:	BVS .DPCOM		;COLON, USE PRESENT ADDRESS
	BR .CNERR

$TENRN:	BIT #ERRSTP,@.DIAG1	;TEN CLOCK RUNNING ?
	BEQ 1$			;YES, OK
	JMP TENCERR		;NO, REPORT IT
1$:	RTS PC

;MEMORY ZERO
;  "MZ ADR,COUNT"

.MZ:	DFLEGAL 		;FUNCTION LEGAL ?
	TTIS36 			;INPUT PDP-10 START ADDRESS
	MOV $DRAM,MMDAT		;SAVE IT
	MOV $DRAM+2,MMDAT+2
	MOV #MMDAT,R1		;POINTER FOR D10ZRO
	TTIS36			;INPUT NUMBER OF PDP-10 WORDS
	 BCS 1$
	MOV $DRAM+2,R2		;PICK UP NUMBER OF 64K MOBIES
	BEQ 2$
	BPL 4$
	MOV #XMEMSZ/64.,R2	;MZ 0,-1.  DON'T TRY TO CLEAR
	CLR $DRAM		; 4096 MILLION WORDS.
4$:	CLR R0			;CLEAR ONE SMALL MOBY
	D10ZRO
	 BCS 3$
	JSR PC,$TIRDY		;ALLOW ^C IN THIS SLOW LOOP
	BCS 69$
	CMPB $TICHR,#CNTRLC
	BNE 69$
	JMP $TICC		;^C, ABORT

69$:	INC MMDAT+2		;BUMP ADDRESS
	DEC R2
	BGT 4$
2$:	MOV $DRAM,R0		;CLEAR FINAL FRACTIONAL MOBY
	BEQ 5$			;EXACT MULTIPLE OF 64K
	D10ZRO 			;ZERO MEMORY
	 BCS 3$

5$:	JMP $KONSL

1$:	MOV #1,$DRAM		;NO COUNT SPECIFIED
	BR 2$			;SO CLEAR ONE WORD

3$:	PMSG <?MZ>
	JSR R1,$DFTM1

.EXM:	MOV #.DPXAD,R5
	CLR R3
	TTISDL
	 BCS .EXMSP		;NON-NUMBER
	TTIS36 			;GET PDP-10 ADDRESS
	MOV (R0)+,(R5)+		;SAVE LOW 16 BITS
	MOV (R0),(R5)		;SAVE HIGH BITS
	TST -(R5)
	TTIBRK 			;GET BREAK
	 BCS .CNERR
	CMPB #',,R0
	BNE .EXCOM
	COM R3			;COMMA, MULTIPLE PRINT
	PNORML
	TTIS36 			;GET ENDING ADDRESS
	MOV (R0),R4		;SAVE LOW 16 BITS

.EXCOM:	MOV R5,R0
	JSR PC,$TENRN
	EXAM
	 BCS 3$
5$:	TSTB RPTFLG
	BNE 1$
	MOV R5,R0
	PNTADR
	PNTBAK 			;BACKUP POINTER TO WIPE OUT SPACE
	PSLASH
	MOV #$DRAM,R0
	PNT36

	TST R3			;DOING MULTIPLE PRINT ?
	BEQ 2$
	PCRLF
	CMP (R5),R4
	BEQ 2$
	INC (R5)		;INCREMENT LOW 16 BITS, 64K
	BR .EXCOM		;DO NEXT ADDRESS
2$:	PCRLF
1$:	JMP $KONSL

3$:	BMI 4$
	PMSG <?EM>
	JSR R1,$DFTM1

4$:	$PMSGR
	  $EBPAR		;E-BUS PARITY ERROR
	BR 5$

.EXMSP:	BVS .EXMNX		;COLON OR SLASH, EXAMINE NEXT
	BNE .EXCOM		;NONE, EXAMINE SAME
	SUB #1,(R5)+		;UPARROW, EXAMINE PREVIOUS
	SBC (R5)
	BR .EXMN1
.EXMNX:	MOV #.DPXAD,R5
	ADD #1,(R5)+
	ADC (R5)
.EXMN1:	INC $INPTC
	CLR R3
	TST -(R5)
	BR .EXCOM

.SBTTL	CONSOLE IDLE RUN LOOP

;PROVIDES PDP-10 SUPPORT WHEN "TENRUN" SET
;AND ADDITIONALY PDP-10 MONITOR SUPPORT IF "MONMODE" SET

$RUNLP:	TSTB TENRUN		;PDP-10 RUN TIME SUPPORT ?
	BNE 1$
	JMP $TTILIN		;NO, CONSOLE COMMAND INPUT

1$:	CLR DDTTM2		;SETUP DDT MODE TIMEOUT
;LOOPS BACK TO HERE IF NOTHING TO DO.
2$:	TST ITSFLG		;USING I.T.S. IO-ELEVEN PROGRAM?
	BEQ 11$			;NO, USE D.E.C. STUFF
	JSR PC,ITSCHK		;YES, MAKE SURE IT'S STILL IN CORE
	JSR PC,@#3000		;IT IS, CALL IT
	BCS MTTYI0		;RETURNS WITH CARRY SET => TEMPORARY KLDCP CMD MODE.
				;OTHERWISE, PROBABLY 10 HALTED.  CHECK IT OUT.
11$:	BIT #KLRUN,@.DIAG1
	BNE 3$
	JMP TENDEAD		;PDP-10 HALTED

3$:	BIT #ERRSTP,@.DIAG1	;PDP-10 CLOCK ERROR STOP ?
	BEQ 31$
	JMP TENCERR		;YES, REPORT
31$:	BIT #TO11DB,@.STDTE
	BNE TENCMD		;PDP-10 REQUESTED SERVICE

4$:	JSR PC,C10COP		;PERFORM CLOCK OPERATIONS

5$:	TST MONMODE		;MONITOR SUPPORT MODE ?
	BEQ 20$			;NO

6$:	JSR PC,$TIRDY		;TTY INPUT FLAG SET ?
	BCC MTTYIN		;YES, SEND CHAR TO 10

7$:	TST MTTYOF		;TTY OUTPUT IN PROGRESS ?
	BEQ 2$			;NO

8$:	JSR PC,$TORDY		;TTY OUTPUT COMPLETED ?
	BCC MTTYOC		;YES, NOTIFY 10
	BR 2$			;STAY IN MONITOR LOOP

20$:	TST DDTFLG		;PDP-10 DDT INPUT MODE ?
	BEQ 21$			;NO
23$:	DEC DDTTM2		;WAITED LONG ENOUGH ?
	BNE 2$			;NOT YET
	CLR DDTFLG		;YES, REVERT TO CONSOLE MODE

21$:	JSR PC,$TIRDY		;ANY TTY INPUT YET ?
	BCS 2$			;NO, STAY IN RUN LOOP
	JMP $TILRN		;YES, GO INPUT

;MONITOR TELETYPE CHARACTER INPUT

MTTYIN:	MOVB $TICHR,R0		;GET INPUT CHAR
	CMPB R0,#MSWCHR		;MONITOR TO "KLDCP" SWITCH CHAR ?
	BNE MTTYI1
MTTYI0:	PMSG <\KLDCP\. _>	;PROMPT FOR TEMPORARY KLDCP MODE
	JMP $TTILIN		;AND READ ONE KLDCP COMMAND LINE

MTTYI1:	MOV R0,TENDAT
	DPOSVT 			;SEND CHAR TO TEN
	  $DTF11
	  TENDAT
	 BCS MTTYER		;FAILED
	D10MON 			;SET -1 TO 10 TTY INPUT FLAG
	  $DTMTI
	 BCS MTTYER
C10DN1:	MOV #INT10S,@.STDTE	;DING TEN
	BR $RUNLP
MTTYER:	JMP C10TIE

;MONITOR TELETYPE OUTPUT COMPLETE

MTTYOC:	D10MON 			;SET -1 TO 10 TTY OUTPUT DONE FLAG
	  $DTMTD
	 BCS MTTYER
	CLR MTTYOF		;CLEAR OUTPUT IN PROGRESS
	BR C10DN1		;CAUSE DTE20 INTERRUPT

;MONITOR TELETYPE OUTPUT ROUTINE

MTTYO:	MOV R5,R0		;GET OUTPUT CHAR
	BIC #177400,R0		;STRIP TO 8 BITS, 10 DOES PARITY
	MOVB R0,$TOCHR		;PRINT CHAR
	JSR PC,$TOOUT
	SETFLG
	  MTTYOF		;SET OUTPUT IN PROGRESS FLAG
MTTYX:	BR C10DON		;ALLOW 10 TO CONTINUE

;MONITOR MODE CONTROL

MTTYC:	SETFLG 			;SET
	  MONMODE
	BR MTTYX
MTTYCF:	CLR MONMODE		;CLEAR
	BR MTTYX
$MC:	SETFLG 			;CONSOLE MONITOR CONTINUE
	  MONMODE
	JMP $CONSL

MTTYS:	MOV MONMODE,R0		;SEND 10 MONITOR TTY STATE
	JMP C10TIX

.SBTTL	PDP-10 RUN TIME SUPPORT

TENCMD:	EXAMT 			;GET COMMAND CODE
	  $DTCMD
	  $ECMD
	BCC 1$
	BPL 2$			;EXAMINE FAILED
	$PMSG
	  $EBPAR		;E-BUS PARITY ERROR
2$:	BR C10DNX

1$:	MOV $ECMD,R5
	MOV R5,R1
	SWAB R1
	BIC #177760,R1
	SL R1,1
	JMP @CMD10T(R1)		;DISPATCH TO ROUTINE

CMD10T:	C10TO 			;TTY OUT
	C10PRG 			;PROGRAM CONTROL
	C10CLK 			;CLOCK
	C10SW 			;SWITCHES
	C10TO 			;TTY OUT
	C10TI 			;TTY IN
	C10PNT 			;PRINT CONTROL
	C10DDT 			;DDT INPUT MODE
	MTTYO 			;MONITOR TTY OUTPUT
	MTTYC 			;MONITOR TTY MODE CONTROL ON
	MTTYCF 			;MONITOR TTY MODE CONTROL OFF
	MTTYS 			;MONITOR TTY STATE
	C10DNX 			;14-17 UNUSED NOW
	C10DNX
	C10DNX
	C10DNX

C10DON:	MOV #INT11C,@.STDTE	;CLEAR DONG
	D10MON 			;SET -1 TO 10 "$DTFLG"
	  $DTFLG		;DTE20 OPERATION COMPLETE FLAG
	 BCS C10DNX
	JMP $RUNLP		;WAIT FOR NEXT COMMAND

C10DNX:	CLR TENRUN
	PMSG <?10 CMD>
	BR $$TDX

TENCERR:CLR TENRUN
	CLR KLCLKR		;CLEAR TEN RUNNING
	PFORCE
	PMSG <\KL10 CLOCK ERROR STOP>
	DFRDT
	  106
	BIT #BIT5,@.DAT3	;FIELD SERVICE ?
	BEQ 1$
	$PMSG 
	  $PEFS 		;FS PROBE

1$:	DFRDT
	  105
	BIT #BIT5,@.DAT3	;FM PARITY ?
	BEQ 2$
	$PMSG 
	  $PEFM 		;FM PARITY

2$:	DFRDT
	  104
	BIT #BIT5,@.DAT3	;CRAM PARITY ?
	BEQ 3$
	$PMSG 
	  $PECR 		;CRAM PARITY

3$:	DFRDT
	  103
	BIT #BIT5,@.DAT3	;DRAM PARITY ?
	BEQ 4$
	$PMSG 
	  $PEDR 		;DRAM PARITY
4$:	PNTCPU 			;PRINT ALL CPU INFORMATION
	BR $$TDX

TENDEAD: CLR TENRUN		;CLEAR TEN RUN FLAG
	PFORCE
	PMSG <\KL10 HALTED >
	SETFLG
	  ALLFLG
	JSR PC,$ALLPC
	JSR PC,$ALVMA
.IF DF MBYHLT
	PCRLF
	MOV #111,R0		;GET APR FM BLOCK 1,2,4 (BITS 4.1-4.3)
				;ALSO 3.7-3.9 GET PREV AC BLOCK
	MOV #$DRAM,R1		;INTO $DRAM (HANDY BUFFER)
	DFRDMV
	MOVB $DRAM+3,R0		;BITS 4-11
	BIC #-100,R0		;GET JUST CURRENT*8+PREVIOUS
	PUSH R0			;SAVE SELECTED BLOCK
	PMSG <AC BLK 7\>
	MOV #-1,R0
	PRGCMD
	BCS $$TDX
	PMSG <EM0,5\>
	MOV #-1,R0
	PRGCMD
	PMSG <AC BLK >
	POP R0
	MOVB R0,PAGDFL+3	;STORE INTO PAGE DEFAULT WORD
	ASR R0			; SO PREVIOUS BLOCK GETS RESTORED
	ASR R0			;THEN EXTRACT CURRENT BLOCK
	ASR R0
	PNTOCS			;NOW DO AC BLK N COMMAND
	PCRLF
	MOV #-1,R0
	PRGCMD
.ENDC ;MBYHLT
$$TDX:	PCRLF			;TEN BLEW UP (FELL FLAT?)
	MOV #7,R5		;((WAS MOWED DOWN BY A FELL FLAT DISK?))
1$:	PBELL			;GO FEEP FEEP FEEP FEEP FEEP
	CLR R0
3$:	DEC R0
	BNE 3$
	DEC R5
	BNE 1$
	JMP $CONSL

C10TO:	SETFLG
	  TENTTY		;ALLOW "TENCHR" TO OPERATE
	MOV #$TNBUF,$TNPTC	;RESET 10 INPUT POINTERS
	MOV #$TNBUF,$TNPTR
	MOV R5,R1		;GET ASCII CHAR
	PLDBUF 			;PUT IN TTY OUT BUFFER
C10DNJ:	BR C10DON

C10TI:	CLR DDTFLG
	CMP #$OUTBF,$OUTPT	;ANY OUTPUT WAITING ?
	BNE C10TIZ		;YES
11$:	CMP $TNPTC,$TNPTR	;CURRENT BUFFER EMPTY ?
	BGE C10TIZ		;YES

	MOV $TNPTC,R1		;GET CHAR POINTER
	MOVB (R1)+,R0		;FETCH CHAR FROM 10 BUFFER
	MOV R1,$TNPTC

C10TIX:	MOV R0,TENDAT		;PUT CHAR IN 28-35 OF TEN WORD
	DPOSVT 			;DEPOSIT IN FROM 11 WORD
	  $DTF11
	  TENDAT
	 BCC C10DNJ
C10TIE:	PMSG <?10 TTI>
	BR $$TDX

C10TIZ:	TTILIN 			;INPUT LINE FOR TEN
	 BCS 5$			;NO RESPONSE
	MOV #$TNBUF,R1
3$:	TTICHR 			;GET CHAR FROM INPUT
	 BCS 4$			;EMPTY
	MOVB R0,(R1)+		;PUT IN TEN BUFFER
	BR 3$
4$:	MOV R1,$TNPTR		;UPDATE 10 EOL POINTER
	MOV #$TNBUF,$TNPTC	;SET PICKUP POINTER TO START
	BR C10TI		;GO SEND FIRST CHAR TO TEN
5$:	CLR R0			;NULL = TIMEOUT
	BR C10TIX

C10PNT:	MOV R5,R1		;GET CONTROL BYTE
	BIC #177400,R1
	MOV R1,$FORCE		;PUT IN FORCE FLAG
	CLR DDTFLG		;CLEAR DDT MODE
C10X:	JMP C10DON

C10SW:	DPOSVT 			;LOAD SWITCHES INTO FROM 11 WORD
	  $DTF11
	  SWS10
	 BCC C10X
C10SWE:	PMSG <?10 SW>
	BR $$TDX

$SW:	MOV #SWS10,R5
	TTISDL
	 BCS 1$			;NON-NUMBER, TYPE PRESENT
	TTIS36
	MOV (R0)+,(R5)+		;PUT IN SWITCH WORD
	MOV (R0),(R5)
2$:	TENSW 			;DO PDP-10 SWITCHES
	 BCS C10SWE		;ERROR
	JMP $KONSL

1$:	PFORCE
	MOV R5,R0		;PRINT CURRENT SWITCHES
	PNT36
	PCRLF
	BR 2$

C10DDT:	SETFLG
	  DDTFLG		;SET FOR DDT MODE INPUT
	PFORCE 			;SET FORCED PRINTOUT
	CMP #$OUTBF,$OUTPT	;ANY OUTPUT WAITING ?
	BEQ 2$			;NO
	SETFLG
	  $TTLKF		;PREVENT INPUT CHECKS
	PRINTT 			;YES, PRINT IT
2$:	TTLOOK 			;GET INPUT CHAR
	 BCS 3$			;NOTHING THERE, SEND ZERO
3$:	CMPB R0,#MSWCHR
	BEQ 4$			;BREAK => RETURN TO KLDCP
	CMPB R0,#CNTRLX		;CONTROL X, NEXT LINE IS CONSOLE CMD
	BNE C10TIX
	PNTCI
	"^X
	JMP $TTILIN

4$:	JMP MTTYI0

C10PRG:	MOV R5,R1		;GET CONTROL FIELD
	BIC #177760,R1
	SL R1,1
	JMP @C10PT(R1)		;DISPATCH

C10PT:	TENDEAD 		;HALT
	C10P1 			;FATAL
	C10P2 			;ERROR HALT
	C10P3 			;END OF PROGRAM
	C10P4 			;END OF PASS
	C10P5 			;GIVE PDP-10 CLOCK DEFAULT WORD
	DIASEL 			;"DIAMON" FILE SELECTION
	DIARD 			;"DIAMON" FILE READ
	P10CMD 			;PDP-10 PROGRAM COMMAND
	C10DNX
	C10DNX
	C10DNX
	C10DNX
	C10DNX
	C10DNX
	C10DNX

C10P2:	CLRB TENRUN
C10P1:	CLR TENCLK
C10X1:	BR C10X

C10P3:	CLRB TENRUN		;TURN OFF TEN RUNNING
	ERREOP 			;END OF PROGRAM

C10P4:	EOP
	BR C10X

C10P5:	DPOSVT
	  $DTF11
	  CLKDFL
	 BCS C10CER
	BR C10CX

C10CLK:	MOV R5,R1
	BIC #177774,R1
	SL R1,1
	JMP @C10CPT(R1)

C10CPT:	C10C0 			;DISABLE
	C10C1 			;ENABLE
	C10C2 			;ENABLE & WAIT
	C10C3 			;READ PDP-10 CLOCK COUNT

C10C0:	CLR TENCLK
C10CX:	BR C10X1

C10C3:	DPOSVT 			;LOAD CLOCK COUNT INTO FROM 11 WORD
	  $DTF11
	  CLKCNT
	 BCS C10CER		;ERROR
	BR C10CX

C10C1:	SETFLG
	  TENCLK
C10CX1:	BIC #200,KWLKS
1$:	TSTB KWLKS		;WAIT FOR CLOCK
	BPL 1$			;THEN CLEAR TO ALLOW FOR
	BIC #200,KWLKS		;16MS BEFORE 1ST CLOCK
	MOV #CLKCNT,R0		;INIT CLOCK COUNTER
	CLR (R0)+
	CLR (R0)+
	CLR (R0)
	BR C10CX

C10C2:	EXAMT 			;GET WAIT COUNT FROM TO 11 WORD
	  $DTT11
	  C10CW
	 BCS C10CER
	MOV #177400,TENCLK
	BR C10CX1

C10COP:	TSTB KWLKS		;CLOCK FLAG SET ?
	BPL 1$			;NO, RETURN
	BIC #200,KWLKS		;CLEAR FLAG
	INC $TTYTIM		;COUNT TTY TIMER
	CMP SWR,$$SWR		;PDP-11 CONSOLE SWITCHES CHANGED ?
	BEQ 3$			;NO
	PUSH R0
	TENSW 			;YES, DO PDP-10 SWITCHES
	 BCS C10CER		;ERROR
	POP R0
3$:	TSTB TENRUN		;IS 10 RUNNING ?
	BEQ 1$			;NO
	TST TENCLK
	BEQ 1$			;CLOCK NOT ENABLED
	ADD #1,CLKCNT		;INCREMENT PDP-10 CLOCK COUNT
	ADC CLKCNT+2
	ADC CLKCNT+4
	TSTB TENCLK		;DOING WAIT ?
	BNE 2$			;NO
	CMP CLKCNT,C10CW	;WAITED LONG ENOUGH ?
	BNE 1$			;NOT YET
2$:	PUSH <R0,R1>
	D10MON 			;SET -1 TO 10 "$DTCLK"
	  $DTCLK
	 BCS C10CER
	MOV #INT10S,@.STDTE	;DING TEN
	POP <R1,R0>
1$:	RTS PC

C10CER:	CLR TENCLK
	PMSG <?10 CLKOP>
	JMP $$TDX

;PDP-10 SWITCH REGISTER

$TENSW:	MOV SWR,$$SWR		;GET PDP-11 SWITCHES
	MOV $$SWR,$SWS10+2

	MOV #$SWS10,R1		;POSITION FOR 0 TO 15 OF
	MOV #4,R3		;PDP-10 SWITCH REGISTER
	PROL36

	MOV #$SWS10+2,R4
	MOV #SWS10+2,R5

	BIC #17,(R4)		;CLEAR 16-19 FROM NEW
	BIC #177760,(R5)	;CLEAR 4-15 FROM OLD

	BIS (R4)+,(R5)+		;INSERT BITS 4-15

	BIC #177760,(R4)	;CLEAR HI JUNK FROM NEW
	BIC #17,(R5)		;CLEAR 0-3 FROM OLD

	BIS (R4),(R5)		;INSERT BITS 0-3

	TSTB TENRUN		;PDP-10 RUNNING ?
	BEQ 1$			;NO

	DPOSVT 			;DEPOSIT PDP-10 SWITCH REGISTER
	  $DTSWR		;IN DTE20 COMM AREA
	  SWS10
	 BCS 2$			;ERROR
$TCX=.
1$:	EXIT
2$:	EXITERR 		;RETURN

;PDP-10 LAST TYPED CHARACTER ROUTINE

$TENCHR:TSTB TENRUN		;PDP-10 RUNNING ?
	BEQ $TCX		;NO
	TST TENTTY		;TTY DEPOSIT ALLOWED ?
	BEQ $TCX		;NO
	PUSH R0
	DPOST 			;YES, SEND LAST TYPED CHAR
	  $DTCHR
	  $TNCHR
	POP R0
	BR $TCX			;DON'T CARE IF FAILED

.SBTTL	PDP-10 PROGRAM COMMAND

P10CMD:	MOV #-1,R0		;USE OUTPUT BUFFER
	PRGCMD 			;& PROGRAM COMMAND
	 BCS DIANF		;C-BIT SET, ERROR
	BR DIAFND		;PASSED

.SBTTL	"DIAMON" FILE SELECTION AND READ ROUTINES

DIASEL:	MOV #$INBUF,R1		;PUT "P" & "SPACE" FIRST
	MOV #"P ,(R1)+		;IN CASE ACT10 LOAD
	MOV #$OUTBF,R0		;TRANSFER "DIAMON" FILE.EXT
	MOV R0,$OUTPT		;TO INPUT BUFFER
	JSR PC,$DIASX
	MOV #$INBUF+2,$INPTC ;SET PICKUP POINTER

	NAMEXT 			;SETUP FILE NAME.EXT

	SETFLG
	  LDCNTL		;SET LOAD CONTROL TO HELP
	SETFLG
	  DIAFLG		;SET PROCESSING TO "DIAMON" MODE

	JMP DEVFIL		;GO LOOKUP & READ FIRST ASCII LINE

;RETURN HERE WHEN FILE FOUND

DIAFND:	CLR R0			;SET FOUND INDICATOR

$DIAFX:	JMP C10TIX		;USE 10 TTY INPUT ROUTINE

;RETURN HERE WHEN FILE NOT FOUND

DIANF:	MOV #-1,R0		;SET NOT FOUND INDICATOR
	BR $DIAFX

;"DIAMON" FILE READ

DIARD:	JSR PC,$TI36C		;CLEAR 36 BIT WORD STORAGE

	CMP $INPTC,$INPTR	;ANY CURRENT INPUT ?
	BLE DIARNL		;NO
1$:	JMP ACTLD2		;GO READ NEXT INPUT LINE

DIARNL=. 			;RETURN HERE WITH NEW LINE SETUP
2$:	MOV #5,R2		;5 ASCII CHARS PER 36 BIT WORD

3$:	CMP $INPTC,$INPTR	;EOL ?
	BGT 4$			;YES
	MOVB @$INPTC,R0		;GET FILE LINE CHAR
	INC $INPTC
	MOV #7,R1
	JSR PC,SHFT36		;SHIFT 36 BIT WORD LEFT 7
	BISB R0,$DRAM		;INSERT NEW ASCII BYTE
	DEC R2			;DONE 5 CHARS ?
	BGT 3$			;NOT YET

4$:	CLR R1			;LEFT JUSTIFY FOR PDP-10 ASCII
	JSR PC,SHFT36

	DPOSVT 			;LOAD INTO FROM 11 WORD
	  $DTF11
	  $DRAM
	 BCC 6$			;OK

5$:	PMSG <?DIAMON XFER>
	JMP $$TDX

DIAEOF=. 			;DIAMON READ END-OF-FILE
	D10MON 			;SET FROM 11 WORD -1
	  $DTF11
	 BCS 5$			;ERROR

6$:	JMP C10DON		;TELL 10 TO CONTINUE

.SBTTL	PDP-11 CONSOLE FUNCTIONS

;START PDP11 AT ADDRESS GIVEN

.SE:	TTISDL
	 BCS 2$			;NON-NUMBER

1$:	TTOCTE 			;READ AN OCTAL ADDRESS

4$:	MOV R0,SEADR		;GO TO ADDRESS IN R0
	JMP SRT11

2$:	CMPB #'D,R0		;"D", START DIAGNOSTIC
	BEQ 3$
	CMPB #'C,R0		;"C", START CONSOLE
	BNE $$CMDE
	MOV #PRGSRT,R0
	BR 4$
3$:	MOV #3000,R0
	BR 4$

;EXAMINE ELEVEN AT ADDRESS GIVEN

.EE:	MOV #1,R5
	BR .EEB

.EB:	CLR R5

.EEB:	MOV #.EADR,R2
	CLR R3
	TTISDL
	 BCS 6$			;NON-NUMBER

	TTCOCT 			;READ AN OCTAL ADDRESS

	MOV R0,R1
	MOV R0,(R2)		;SAVE ADR FOR DEPOSIT

	TTIBRK 			;GET BREAK CHAR
	 BCS $$PARA
	CMPB #COMMA,R0
	BNE 2$
	INC R3			;SET MULTIPLE PRINT FLAG
	PNORML
	TTCOCT 			;GET LAST ADDRESS
	MOV R0,R4		;SAVE END ADR

2$:	BIC R5,R1		;IF WORD, MAKE EVEN
21$:	MOV R1,R0
	MOV R1,(R2)		;SAVE ADDRESS
	PNTOCT 			;PRINT ADDRESS
	PSLASH

1$:	TST R5			;BYTE ?
	BEQ 3$			;YES

	MOV (R1),R0
	PNTOCT 			;PRINT CONTENTS OF ADDRESS
	BR 4$

3$:	MOVB (R1),R0
	BIC #177400,R0
	PNTOCS 			;PRINT BYTE CONTENTS

4$:	TST R3
	BEQ 5$
	PCRLF
	CMP R1,R4
	BHIS 5$
	INC R1			;INCREMENT ADDRESS
	ADD R5,R1		;IF WORD, INC BY 2
	BR 2$

5$:	PCRLF
	JMP $KONSL

6$:	BEQ 7$			;UPARROW
	BVC 61$			;NONE
	INC (R2)		;EXAMINE NEXT 11 ADDRESS
	ADD R5,(R2)
61$:	MOV (R2),R1
	INC $INPTC		;ADVANCE PAST TERMINATOR
	BR 2$

7$:	DEC (R2)
	SUB R5,(R2)
	BR 61$

;ZERO ELEVEN

.ZE:	TTOCTE 			;GET START ADDRESS
	MOV R0,R5

	TTCOCT 			;GET END ADDRESS

1$:	CLR (R5)+		;ZERO 11
	CMP R5,R0		;COMPLETED ?
	BLOS 1$			;NO
	JMP $CONSL

;DEPOSIT ELEVEN DATA

.DE:	MOV #1,R5		;DEPOSIT 11 WORD
	BR .DEB

.DB:	CLR R5			;DEPOSIT 11 BYTE

.DEB:	MOV #.EADR,R2
	TTISDL
	 BCS 5$			;NON-NUMBER

	TTCOCT 			;READ OCTAL ADDRESS

1$:	MOV R0,R1
	TST R5
	BEQ 2$
	BIT R5,R0
	BNE $$PARA		;WORD, ODD ADDRESSES ILLEGAL

2$:	TTISDL
	 BCS $$CMDE
	TTCOCT 			;GET DATA

	MOV R1,(R2)

	TST R5			;BYTE ?
	BEQ 3$

	MOV R0,(R1)		;STOW IT
	BR 4$

3$:	MOVB R0,(R1)		;STOW 11 BYTE
4$:	JMP $KONSL

5$:	BVC $$CMDE		;IF COLON, USE PREVIOUS EXAMINE ADDRESS
	MOV (R2),R0
	BR 1$

$$PARA:	JMP $PARA
$$CMDE:	JMP $CMDE

.SBTTL	KL10 MONITOR & ACT10 COMMAND ROUTINES

$VERIFY:SETFLG
	  VERIFY
	PNORML
	BR $PROG1

$LDT:	MOV #1,LDOVRD		;LOAD TEN, OVERRIDE EXT
	BR $PROG2
$LDE:	MOV #2,LDOVRD		;LOAD ELEVEN, OVERRIDE EXT
	BR $PROG2
$LDR:	MOV #3,LDOVRD		;LOAD RAM, OVERRIDE EXT
	BR $PROG2
$LDB:	MOV #6,LDOVRD		;LOAD ELEVEN BIN, OVERRIDE EXT
	BR $PROG2

$PROG:	CLR LDOVRD		;CLEAR OVERRIDE
$PROG2:	CLR VERIFY
$PROG1:	CLR LDCNTL		;CLEAR LOAD CONTROL FLAG
	CLR SRTFLG		;CLEAR SELF START FLAG
	CLRB CONSOL-1		;OVERLAY INUSE INDICATOR
	BR $HELP1		;GO LOAD PROGRAM

$JFILE:	SETFLG
	  JFILEF		;SET DOUBLE INDIRECT FLAG
	CLR PRGRUN		;CLEAR PROGRAM RUNNING FLAG
	MOV #TOUTBF+5000,IFINP	;SETUP STORAGE POINTER
	BR $IIX

$IFILE:	MOV #TOUTBF,IFINP	;SETUP STORAGE POINTER
$IIX:	CLR PCMDFLG		;CLEAR PROGRAM COMMAND
	SETFLG
	  IFILEF		;SET INDIRECT FILE FLAG
	CLR @IFINP		;CLEAR 1ST BUFFER WORD
	CLRB CONSOL-1		;OVERLAY INUSE INDICATOR

$HELP:	CLR LDOVRD		;CLEAR LOAD OVERRIDE FOR H,I,J
	SETFLG
	  LDCNTL		;SET LOAD CONTROL TO "HELP"
	PNORML
	TST DEVTYP
	BPL $HELP1
	JMP ACTFIL		;ACT10 HELP
$HELP1:	JMP DVLOAD		;RP04/DECTAPE/FLOPPY HELP

$AT:	TTITRM
	SETFLG
	  DEVTYP		;SET ACT10 MODE
	COMCLR 			;CLEAR COMMUNICATIONS
	BR $DTX

$DT:	CLR FLOPPY
	TTISDL
	BCS $DTC		;LETTER
	TTISDO 			;GET UNIT SELECTION DIGIT
	CMP R0,#7		;MUST BE 0 TO 7
	BGT $CMDEJ
	SWAB R0			;PUT IN PROPER PLACE FOR TC11
	MOV R0,DTUNIT		;SAVE IT
$RXX:	CLR DEVTYP		;SET DECTAPE MODE
$DTX:	JMP $KONSL

$RX:	SETFLG
	  FLOPPY
	TTISDL
	  BCS $DTC		;LETTER
	TTISDO 			;GET SELECTION DIGIT
	CMP R0,#1		;MUST BE EITHER 0 OR 1
$CMDEJ:	BGT $CMDE
	BNE $RX.1
	MOV #RXU1,R0
$RX.1:	MOV R0,RXUNIT		;SAVE FOR RX11/RX01 FLOPPY
	BR $RXX

$DTC:	CMP #"CO,$INBUF+2	;IS COMMAND 'DTCOPY'/'RXCOPY' ?
	BNE 1$
	CMP #"PY,$INBUF+4
	BNE 1$
	JSR PC,$KLUCK		;UTILITY IN CORE ?
	TST FLOPPY
	BEQ 2$
	JMP @RXCOPY		;FLOPPY COPY
2$:	JMP @DTCOPY		;YES
1$:	JMP $CMDER

$GO:	INC $INPTC
$$GO:	MOV PGOCTL,R0		;GO, START PROGRAM
	JMP @LDSTRT(R0)

LDSTRT:	SRT11X
	SRT10

$JC:	TTITRM
	SETFLG 			;SET J FILE FLAG TO CONTINUE
	  JFILEF		;INTERRUPTED J FILE PROCESS
	BR $DTX

SRT11X:	MOV PGOADR,SEADR
SRT11:	TST SEADR
	BEQ 1$			;IF ADR 0, START AT 3000
	BIT #1,SEADR
	BNE ADRERR		;ODD ADDRESSES NOT ALLOWED

2$:	JSR PC,$CMCLR		;CLEAR COMMON STORAGE

	CLR IFILEF		;END INDIRECT PROCESS
	SETFLG
	  PRGRUN
	MOV #STACK-2,R0		;PASS STACK BASE ADR IN R0
	MOV R0,SP		;RESET STACK
	TST EMTLDD		;CLOBBER IN EMT VECTOR IF NECC.
	BEQ 10$
	MOV EMTLDD,EMTVEC
	MOV EMTLDD+2,EMTVEC+2
10$:	JMP @SEADR		;START 11 PROGRAM AT LOAD ADDRESS

1$:	MOV #3000,SEADR
	BR 2$

;ACT10 TIME REQUEST

$TIME:	TTBTRM
	TST DEVTYP
	BPL $TIME1		;ONLY LEGAL IN ACT10 MODE

	COMENQ 			;REQUEST APT10 SERVICE

	MOV #$INBUF,R0
	COMCMD 			;SEND COMMAND

	$PMSG 			;PRINT INPUT LINE
	CINBF
	COMCLR
$TIME3:	JMP $CONSL

$TIME1:	JMP NONACT		;NON ACT10

$LOGO:
$LOGIN:	TST DEVTYP		;ONLY LEGAL IN ACT10 MODE
	BPL $TIME1
	TTITRM

	COMENQ 			;REQUEST SERVICE

	MOV #$INBUF,R0
	COMCMD 			;SEND COMMAND
	COMEOT
	BR $TIME3

SRT10:	MOV #TGOADR+2,R0
	MOV #PGOADR+2,R1	;PUT LOAD ADR IN 10 GO ADR
	MOV (R1),(R0)
	MOV -(R1),-(R0)
	JMP $$$ST		;GO TO 10 START ROUTINE

$COMNT:	TST DEVTYP		;ACT10 MODE ?
	BPL 1$			;NO, LOCAL ONLY

	COMENQ 			;REQUEST APT10 SERVICE

	MOV #$INBUF,R0
	COMCMD 			;SEND MESSAGE
	COMEOT

1$:	BR $TIME3		;BACK TO CONSOLE

$BOOT:
$SCRPT:
$MSCP:
$GSCP:
$BOOTT:	JMP $CMDER

ADRERR:	PMSG <?ADR>
	BR COMNER

$PARA:	PMSG <?PARAM>
	BR COMNER

$CMDE:	JMP $CMDER

NONACT:	PMSG <?ACT10>
	BR COMNER

NORESP:	PMSG <?RESPONSE>

COMNER:	JMP $CNTLC

;REINITIALIZE SYSTEM

.RI:	CLR $ONETM
	JMP START

.SBTTL	LINE PRINTER SELECTION ROUTINE

.IFNZ 0				;TURN OFF TO SAVE SPACE?
$LPT:	PMSG <LP, Y OR N ? - _>
	TTILIN
	TTIYES
	 BCS $LPT		;JUNK
	BMI 10$			;NO
	MOV #NOLP,ERRVEC	;DO WE HAVE A LINE PRINTER CONTROLLER ?
	MOV $LPS,R0
	TST (R0)
	TST R0
	BNE 1$			;LP11
	MOV #LP20A,R0
	TST (R0)
	TST R0
	BNE 2$			;LP20A
	MOV #LP20B,R0
	TST (R0)
	TST R0
	BNE 2$			;LP20B
	MOV #$TIMOT,ERRVEC
	PMSG <?NO LPT>
	JMP $CNTLC
1$:	CLR LPTYPE		;LP11 - TYPE = 0
	BR 3$
2$:	MOV R0,LPTYPE		;LP20 - TYPE = CONTROLLER BASE ADDRESS
3$:	MOV #$TIMOT,ERRVEC
	SETFLG
	  LPTFLG
	TST LPTYPE
	BNE 5$
	TST @$LPS		;LP11 - LPT OK ?
	BMI 20$			;NO
4$:	JMP $CONSL

5$:	JSR PC,LP20INI		;INITIALIZE LP20
	BCS 20$			;ERROR
	BR 4$
10$:	CLR LPTFLG		;TURN OFF LINE PRINTER
	BR 4$
20$:	PMSG <?LP ERR\>
	BR $LPT

NOLP:	CLR R0			;NO LP CONTROLLER BUS TRAP
	RTI

.SBTTL	LP20 INITIALIZATION ROUTINE

LP20INI:MOV LPTYPE,R5		;SETUP BASE ADDRESS
	MOV #LPLINI!LPRERR,(R5) ;CLEAR LP20
	MOV #VFUDAT,R0		;SETUP VFU BUFFER
	MOV R0,LPBSAD(R5)	;SETUP BUFFER ADDRESS
	MOV #037756,(R0)+	;VFU LOAD CODE & ALL CHANS
	MOV #77,(R0)+
	MOV #100,R1		;SET FOR 64 LINES ON PAGE
1$:	CLR (R0)+
	DEC R1
	BNE 1$
	MOV #167400,(R0)	;VFU STOP LOAD CODE
	MOV #-206,LPBCTR(R5) ;206 BYTE XFER
	MOV #LPVLOD!LPPENB!LPGO,(R5) ;VFU LOAD & GO
	JSR PC,LP20DN		;WAIT FOR DONE
	BCS 3$			;ERROR
	CLR LPCBUF(R5)		;CLEAR LP20 RAM
	MOV #LPLINI!LPRERR,(R5)
	MOV #-1000,R0		;LOCATION COUNT
	MOVB #LPPENB,(R5)	;PARENB & NOT GO
2$:	CLR LPRAMD(R5)		;CLEAR
	INC LPCBUF(R5)		;INCREMENT ADDRESS
	INC R0			;COUNT IT
	BNE 2$			;IF NOT DONE, GO BACK
	CLC 			;COMPLETED, C-BIT CLEAR RETURN
	RTS PC

3$:	SEC 			;ERROR, C-BIT SET RETURN
	RTS PC
.ENDC ;TURN OFF TO SAVE SPACE?

.SBTTL	CONSOLE TELETYPE FUNCTIONS

$TP:	MOV #$TPLIN,R5		;SET TTY PAGE LENGTH
	BR $TPW

$TW:	MOV #$PGWID,R5		;SET TTY PAGE WIDTH

$TPW:	TTISDL
	 BCS $PARAM

	TTIDEC 			;SPECIFIED IN DECIMAL
	 BCS $DECN		;WASNT A DECIMAL NUMBER

	MOV R0,(R5)		;SET IT UP

$TPWF:	JMP $CONSL		;RETURN TO CONSOLE FOR NEXT COMMAND

;TTY FILL CHARACTER PARAMETER

$TF:	TTISDO

	CMP R0,#5		;CHECK FILL PARAMETER UPPER LIMIT
	BGT $FILPL

	MOV R0,$TTYFL		;SET TTY FILL PARAMETER

	BR $TPWF

;MESSAGES TO OPERATOR

$DECN:
$FILPL:
$OCTN:
$PARAM:	JMP $PARA

.SBTTL	KLINIK FIELD SERVICE REMOTE DIAGNOSTICS ENABLE

.KLINIK:CMP #"IN,$INBUF+2
	BNE 2$
	CMP #"IK,$INBUF+4
	BNE 2$

	TST DL11EFLG		;PRESENTLY ENABLED ?
	BEQ 1$			;NO

KLUNK=.
	CLR DL11EFLG		;YES, CLEAR IT
	PMSG <KLINIK CLEARED>
	JMP $CNTLC

1$:	CLR @$FSTKS		;INITIALIZE
	BIS #DLDTR!DLRTS,@$FSTKS	;SET DATA TERMINAL READY
	BIT #DLCTS,@$FSTKS	;DO WE HAVE CLEAR TO SEND ?
	BEQ FSDISC		;NO
	COM DL11EFLG		;ENABLE KLINIK
	PMSG <KLINIK ENABLED>
	JMP $CNTLC

2$:	JMP $CMDER

;DL11E DISCONNECT, CLEAR TO SEND NOT SET

FSDISC:	CLR DL11EFLG
	PMSG <\DL11E NOT CLR TO SEND, >
	BR KLUNK

.SBTTL DISK STATUS PRINTER

;DS n TELLS YOU ALL ABOUT RP04 #n.  PDP10 MUST BE STOPPED SINCE WE USE ITS RH10
DSKSTS:	DFLEGAL			;10 MUST NOT BE RUNNING
	TTCOCT			;DISK NUMBER TO R0
	BIC #-8,R0		;TRUNCATE TO LOW 3 BITS
	MOV R0,R2		;SAVE DSK #
	ASL R2			;SHIFTED LEFT 2 BITS
	ASL R2
	EXAMT			;SAVE LOCATION 20
	 .WORD 20,$SAV20
	MOV #TENDAT,R4		;3-WORD BLOCK TO HOLD PDP10 DATAO/DATAI WORD
	MOV #DSKSTB,R3		;ADDRESS TABLE OF REGISTERS TO DISPLAY
10$:	MOVB (R3)+,R0		;GET CHAR
	BEQ 99$			;NULL MEANS ALL REGS DISPLAYED
	PNTCHR
	MOVB (R3)+,R0		;GIVE NAME OF REG
	PNTCHR
	MOVB (R3)+,R0
	PNTCHR
	PSPACE
	CLR (R4)+		;CLEAR 1.1-2.7 OF WORD TO DATAO WITH
	MOV R2,(R4)		;DRIVE NUMBER TO 3.1-3.3
	MOVB (R3)+,R0		;GET REGISTER NUMBER, WHICH GOES TO 4.4-4.9
	CLR R1			;R1 WILL GET LOW 2 BITS, R0 HIGH 4
	ASR R0
	ROR R1
	ASR R0
	ROR R1
	BIS R1,(R4)+		;LOW 2 BITS TO 4.4-4.5
	MOV R0,(R4)		;HIGH 4 BITS TO 4.6-4.9
	CMP -(R4),-(R4)		;RESTORE POINTER TO 36-BIT WORD
	DPOSVT			;PUT TENDAT INTO 20
	 .WORD 20,TENDAT
	BCS 69$
	MOV #DTO270,R0		;EXECUTE DATAO 270,20
	EXCT
	BCS 69$			;LOST, GIVE IT UP
	MOV #DTI270,R0		;EXECUTE DATAI 270,20
	EXCT
	BCS 69$
	EXAMT			;GET BACK 20
	 .WORD 20,TENDAT	;1.1-2.7 IS THE INTERESTING STUFF
	MOV TENDAT,R0		;PRINT 6 DIGITS
	PNTOCT
	PCRLF			;WHAT THE HELL, DON'T TRY TO PUT MULTIPLE PER LINE
	BR 10$			;NEXT REGISTER

69$:	PMSG <LOSE>		;HERE IF EXAMINE/DEPOSIT FAILS OR SOMETHING
	JMP $CNTLC

99$:	DPOSVT			;RESTORE 20
	 .WORD 20,$SAV20
	BCS 69$
	JMP $KONSL		;DONE WITH COMMAND, CONTINUE EXECUTING LINE

DTI270:	IO10 DATAI,270,0,20,0	;DATAI 270,20
DTO270:	IO10 DATAO,270,0,20,0	;DATAO 270,20

;TABLE OF DISK REGISTER NAMES (3 CHARS) AND REGISTER NUMBERS (1 BYTE)
;TERMINATE WITH NULL CHARACTER
DSKSTB:	.ASCII /DCL/
	.BYTE 0
	.ASCII /STS/
	.BYTE 1
	.ASCII /ATN/
	.BYTE 4
	.ASCII /ER1/
	.BYTE 2
	.ASCII /ER2/
	.BYTE 14
	.ASCII /ER3/
	.BYTE 15
	.ASCII /CCY/
	.BYTE 13
	.ASCII /CYL/
	.BYTE 12
	.ASCII /ADR/
	.BYTE 5
	.BYTE 0
	.EVEN
