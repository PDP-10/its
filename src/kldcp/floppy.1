;;;MODIFICATION HISTORY
;;;
;;; 15 NOV 75  OBTAINED FROM DEC (KLDCP REV 7)
;;; 15 NOV 75  CONVERTED TO PALX FORMAT
;;;

.SBTTL	RX11/RX01 (FLOPPY) DEVICE DRIVER ROUTINES, 22-JULY-75

;FLOPPY READ/WRITE FILE ROUTINES

$RXFILE:RXINIT 			;INITIALIZE FLOPPY
	JMP DTAFL1		;REST SAME AS DECTAPE

$RXRDFL:TST DVBUF		;ANY DATA BLOCKS REMAINING ?
	BNE $RXRFL		;YES
$$RXXE:	EXITERR 		;NO

$RXRFL:	MOV DVBUF,RXBLK		;SET REQUESTED BLOCK
	MOV #DVBUF,CASAV	;SET BUFFER ADDRESS
	MOV #-256.,WCSAV	;SET WORD COUNT

	RXREAD 			;FLOPPY READ
	 BCS $$RXXC		;FAILED

	MOV #$DTINFO,R0
$$RXX:	EXIT

$$RXXC:	EXITERR 		;FAILED

$RXWTFL:MOV #DVBUF,CASAV
	MOV #-256.,WCSAV

	RXWRT 			;WRITE FLOPPY
	 BCC $$RXX		;OK
	BR $$RXXC		;FAILED

RXERA:	PMSG <?BLK#>
	BR RXERC
RXERB:	PMSG <?HARD>
RXERC:	PMSG < FLOPPY ERROR>
	JMP $CNTLC

;FLOPPY READ/WRITE ROUTINE

$RXREAD:CLR RXCMD		;INDICATE READ OPERATION
	BR $RXXFR

$RXWRT:	MOV #1,RXCMD		;INDICATE WRITE OPERATION

$RXXFR:	MOV #10.,TRYCTR		;SET MAXIMUM TRY COUNT, 10.
	MOV #RXCS,R4		;RX11 COMMAND REG ADDRESS TO R4
	MOV RXUNIT,RXWCMD	;UNIT # TO COMMAND WORD
	MOV RXBLK,RXBLKT	;BLOCK NUMBER TO WORK TEMP
	CMP RXBLKT,#494.	;CHECK FOR VALID BLOCK NUMBER
	BLO 1$			;BR IF OK
	BR RXERA		;NOT, REPORT BLOCK NUMBER ERROR

1$:	JSR PC,$RXCTS		;COMPUTE TRACK AND SECTOR ADDRESS

2$:	MOV TRYCTR,R2		;GET RETRY COUNT
3$:	JSR PC,$PTTYC		;DO OPERATOR CHECKS
	CLR R1			;CLEAR ERROR INDICATOR
	TST RXCMD		;READ OR WRITE ?
	BNE 4$			;WRITE

	JSR PC,$RXR1		;READ A SECTOR
	BR 5$

4$:	JSR PC,$RXW1		;WRITE A SECTOR

5$:	BEQ 6$			;BR IF NO ERROR IN OPERATION
	JSR R5,$RXFUNC		;READ STATUS, INIT FLOPPY
	  RXINI!RXRSTAT!RXGO
	MOV RXWCMD,(R4)		;REALLY DO IT

	JSR PC,$RXCKDN		;WAIT FOR DONE
	DEC R2			;DONE # OF REQUIRED RETRIES ?
	BNE 3$			;NO
	BR RXERB		;YES, REPORT HARD ERROR

6$:	SUB #64.,WCSAV		;ALL WORDS TRANSFERED ?
	BLE 7$			;BR IF YES
	ADD #128.,CASAV		;NO, UPDATE TRANSFER ADDRESS
	JSR PC,$RXITS		;UPDATE TRACK AND SECTOR ADDRESS
	BR 2$			;DO NEXT TRANSFER

7$:	EXIT 			;DONE

;SUBROUTINE TO READ ONE SECTOR

$RXR1:	JSR R5,$RXFUNC		;ISSUE A READ FUNCTION
	  RXRSEC!RXGO
	JSR PC,$RXLTS		;LOAD TRACK AND SECTOR ADDRESS
	JSR PC,$RXGBUF		;GET THE SECTOR READ
	BR $RXW2		;FINISH UP

;SUBROUTINE TO WRITE ONE SECTOR

$RXW1:	JSR PC,$RXFBUF		;FILL BUFFER WITH 1 SECTOR OF DATA
	JSR R5,$RXFUNC		;ISSUE A WRITE FUNCTION
	  RXWSEC!RXGO
	JSR PC,$RXLTS		;LOAD TRACK AND SECTOR ADDRESS

$RXW2:	JSR PC,$RXCKDN		;WAIT FOR DONE
	TST R1			;TEST ERROR INDICATOR
	RTS PC			;DONE, RETURN

;SUBROUTINE TO CHECK FOR DONE/ERROR

$RXCKDN:TST R1			;ERROR ALREADY ?
	BNE $RXTR3		;BR IF YES
1$:	BIT #RXERROR!RXDONE,(R4)
	BMI $RXTR2		;ERROR
	BEQ 1$			;NOTHING YET
	BR $RXTR3		;DONE SET

;SUBROUTINE TO CHECK FOR TRANSFER REQUEST

$RXTRQ:	TST R1			;ERROR ALREADY ?
	BNE $RXTR3		;YES
1$:	BIT #RXERROR!RXTREQ,(R4)
	BMI $RXTR2		;ERROR SET
	BEQ 1$			;NOTHING YET
	BR $RXTR3		;TRANSFER REQUEST SET

$RXTR2:	INC R1			;SET ERROR INDICATOR
$RXTR3:	TST R1			;TEST ERROR INDICATOR
	RTS PC

;SUBROUTINE TO ISSUE DESIRED FUNCTION

$RXFUNC:BIC #177757,RXWCMD	;CLEAR ALL BUT UNIT #
	BIS (R5)+,RXWCMD	;SET THE DESIRED FUNCTION
	JSR PC,$RXCKDN		;WAIT FOR DONE
	BNE 1$			;BR IF ERROR INDICATOR SET
	MOV RXWCMD,(R4)		;ISSUE THE FUNCTION
1$:	RTS R5

;SUBROUTINE TO LOAD TRACK AND SECTOR ADDRESS

$RXLTS:	JSR PC,$RXTRQ		;WAIT FOR TRANSFER REQUEST
	MOV RXSADR,2(R4)	;LOAD THE SECTOR ADDRESS
	JSR PC,$RXTRQ		;WAIT FOR TRANSFER REQUEST
	MOV RXTADR,2(R4)	;LOAD THE TRACK ADDRESS
	RTS PC

;SUBROUTINE TO EMPTY SECTOR BUFFER INTO DESIRED CORE AREA

$RXGBUF:JSR R5,$RXFUNC		;ISSUE EMPTY BUFFER FUNCTION
	  RXEBUF!RXGO
	MOV CASAV,R3		;GET TRANSFER ADDRESS
	MOV #128.,R0		;WILL TRANSFER 128 BYTES
1$:	JSR PC,$RXTRQ		;WAIT FOR TRANSFER REQUEST
	BNE 3$			;BR IF ERROR INDICATOR SET
2$:	MOVB 2(R4),(R3)+	;MOVE BYTE INTO CORE BUFFER
	DEC R0			;DONE 128 BYTES ?
	BNE 1$			;NOT YET
3$:	RTS PC

;SUBROUTINE TO FILL SECTOR BUFFER FROM DESIRED CORE AREA

$RXFBUF:JSR R5,$RXFUNC		;ISSUE FILL BUFFER FUNCTION
	  RXFBUF!RXGO
	MOV CASAV,R3		;GET TRANSFER ADDRESS
	MOV #128.,R0		;WILL TRANSFER 128 BYTES
1$:	JSR PC,$RXTRQ		;WAIT FOR TRANSFER REQUEST
	BNE 3$			;BR IF ERROR INDICATOR SET
2$:	MOVB (R3)+,2(R4)	;MOVE BYTE INTO SECTOR BUFFER
	DEC R0			;DONE 128 BYTES ?
	BNE 1$			;NOT YET
3$:	RTS PC

;SUBROUTINE TO INCREMENT TRACK AND SECTOR ADDRESS AS FOLLOWS:
; ADD 8 TO SECTOR ADDRESS, IF RESULT GREATER THAN 26, SUBTRACT
; 26 FROM RESULT.  ADD 1 TO TRACK ADDRESS, DO ONLY IF "$RXITS" ENTERED
; LESS THAN 4 TIMES.  IF 4, ADD 1 TO BLOCK NUMBER AND RECOMPUTE
; TRACK AND SECTOR ADDRESS FOR NEW BLOCK NUMBER.

$RXITS:	DEC $$ITS1		;4TH TIME THROUGH ?
	BEQ 2$			;YES
	ADD #8.,RXSADR		; +8 TO SECTOR ADDRESS
	CMP RXSADR,#26.		;LARGER THAN 26 ?
	BLOS 1$			;NO
	SUB #26.,RXSADR		;YES, SUBTRACT 26
1$:	INC RXTADR		; +1 TO TRACK ADDRESS
	RTS PC

2$:	INC RXBLKT		; +1 TO BLOCK NUMBER
		;RECOMPUTE TRACK AND SECTOR ADDRESS

;SUBROUTINE TO COMPUTE TRACK AND SECTOR ADDRESS FROM BLOCK NUMBER
; VALID BLOCK NUMBERS ARE 0 TO 493(10)
; TRACK ADDRESS = BLOCK NUMBER/26X4+1
; SECTOR ADDRESS = (REMAINDER OF BK/26)+1

$RXCTS:	MOV RXBLKT,RXSADR
	CLR -(SP)		;CLEAR THE QUOTIENT
1$:	SUB #26.,RXSADR		;DIVIDE BY 26 BY SUBTRACTING
	BCS 2$			;BR IF GONE UNDER, CORRECT DIVIDEND
	ADD #4,(SP)		; +4 TO QUOTIENT
	BR 1$			;GO FOR MORE
2$:	ADD #27.,RXSADR		;FINAL SECTOR ADDRESS
	INC (SP)		;ADD 1 TO QUOTIENT
	MOV (SP)+,RXTADR	;FINAL TRACK ADDRESS
	MOV #4,$$ITS1		;FOR "$RXITS" SUBROUTINE
	RTS PC

;FLOPPY INITIALIZATION ROUTINE

$RXINIT:MOV #3,DVBUF		;SET STARTING UFD BLOCK NUMBER
	EXIT

;FLOPPY PARAMETER BASE ADDRESS

$RXBASE:MOV #RXBLK,R0		;BASE ADDRESS TO R0
	EXIT
