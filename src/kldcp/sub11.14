;;;MODIFICATION HISTORY
;;;
;;; 15 NOV 75  OBTAINED FROM DEC (KLDCP REV 7)
;;; 15 NOV 75  CONVERTED TO PALX FORMAT
;;; 19 DEC 75  BUG FIXES, BREAK, LA36
;;; 30 MAR 76  MODIFIED TO COEXIST WITH ITS IOELEVEN PROGRAM

.SBTTL	BASIC INITIALIZATION ROUTINE, 19-AUG-75

;*THIS SUBROUTINE PERFORMS THE MOST ELEMENTARY SET UP FOR THE CPU
;*THIS ROUTINE MUST BE EXECUTED BY ALL OF THE POSSIBLE START
;*OPTIONS PRIOR TO ANY OTHER SUBROUTINE

$$ILOAD:RESET			;DISABLE ALL DEVICES FROM INTERRUPTING
	MOV #STACK,SP
	MOV #<<.DELAY-$ILDCLR>/2>,R1
	MOV #$ILDCLR,R0
1$:	CLR (R0)+		;CLEAR SPECIAL CONTROL WORDS
	DEC R1
	BGT 1$
	MOV #17,CLKDFL+4	;INITIAL DEFAULT, ALL 4 CACHES
	MOV #36,PEBITS		;INITIAL DEFAULT, AR/ARX, FM, CRAM, DRAM
		;AND NOT FS PROBE, PARITY STOP ENABLES
	JSR PC,$CKSUM		;CHECKSUM "KLDCP"
	MOV R0,$ILDSUM		;SAVE

$SBRINT:MOV #STACK,SP	 	;SET THE STACK POINTER
	TST ITSFLG
	BNE 11$			;IF IOELEV IN, DON'T CLOBBER VECTORS
	CLR PID			;CLOBBERING VECTORS, IT'S ALL
				;OVER FOR ANY PROGRAM IN LOW CORE
.IF DF %%DDT
	MOV @#14,-(SP)		;IF DDT IS IN CORE, DON'T WIPE OUT BPT VEC
	MOV @#16,-(SP)
.ENDC
	MOV #PR7,PS		;SET CPU TO PR7
	CLR R0			;SET ENTIRE VECTOR AREA TO:
1$:	MOV #$FATLE,(R0)+	;	;ADDRESS OF ERROR HANDLER
	MOV #PR7,(R0)+		;	;PR7
	CMP R0,#1000
	BLT 1$

	MOV #$TIMOT,@#ERRVEC ;TIME OUT BUS ERROR VECTOR
	MOV #$RESVD,@#RESVEC ;RESERVED INSTRUCTION VECTOR
	MOV #$PWRDN,@#PWRVEC ;POWER FAIL VECTOR
	MOV #$BRKPT,@#IOTVEC ;IOT VECTOR
	MOV #$EMTRP,@#EMTVEC ;EMT VECTOR

.IF NDF %%DDT
	MOV #.BCCT,@#BPTVEC	;SET BP VECTOR
.IFF
	MOV (SP)+,@#16		;SET UP FOR DDT
	MOV (SP)+,@#14		;WE WON'T BE USING THE KLDCP BREAKPOINTS, PROBABLY
.ENDC
11$:	MOV #BUFCLR,R0		;CLEAR BUFFER STORAGE BETWEEN:
21$:	CLR (R0)+		;BUFCLR: AND $ILDCLR:
	CMP R0,#$ILDCLR
	BNE 21$
	MOV SP,$KONSP

	CLR CONSOL-2

	TTPINI 			;RESET TTY POINTERS

	MOV #120.,$PGWID	;SET PAGE WIDTH FOR LA36
	MOV #0,$TTYFL		;SET FILL PARAMETER FOR LA36
	PFORCE 			;MUST TYPE STARTUP

	MOV #NOPAR,ERRVEC	;SET BUS TIMEOUT IN CASE NO PARITY
	MOV #MEMPE,MMLPIV	;SETUP PARITY VECTOR
	MOV #MMPIE,MMLPBA	;ENABLE PARITY ERRORS
	MOV #$TIMOT,ERRVEC	;RESTORE BUS TIMEOUT

	TST $ONETM
	BNE 3$

	JSR PC,.CB		;CLEAR BP'S

	PMSG <\DECSYSTEM10 DIAGNOSTIC CONSOLE\VERSION >
	MOV #MCNVER,R0
	PNTOCS
	PNTCI
	'.
	MOV #DECVER,R0
	PNTOCS
	PMSG <, MIT VERSION >
	MOV #MITVER,R0
	PNTDEC
	PMSG <\11 SWR = >
	MOV SWR,R0
	PNTOCT 			;PRINT CONSOLE SWITCHES
	PCRLF

3$:	JSR PC,DTEINI		;DTE20 INITIALIZATION

	TST DEVTYP		;USING RP04 ?
	BLE 4$			;NO
	RPLOAD 			;YES, INIT & LOAD PACK
	 BCC 4$
	RPERROR 		;FAILED

4$:	JMP CONSL		;NOW TO CONSOLE

NOPAR:	RTI 			;NO PARITY REGISTER

$CMCLR:	MOV #$CMTAG,R0		;CLEAR COMMON STORAGE
1$:	CLR (R0)+
	CMP R0,#MONCTL
	BLT 1$
	RTS PC

$CKSUM:	CLR $KDCEN		;CLEAR ONLY CHANGEABLE LOCATION
	MOV #START,R1
	CLR R0
2$:	ADD (R1)+,R0		;CHECKSUM "KLDCP"
	CMP R1,$$FF
	BLOS 2$
	RTS PC

.SBTTL	SET EOP INTERVAL TALLY

$EOPSET:MOV R0,$ENDCT		;SET EOP INTERVAL TALLY
	EXIT

;CONSOLE SET EOP INTERVAL

.EP:	TTISDL
	 BCS 1$
	TTIDEC 			;SPECIFIED AS DECIMAL INTERVAL
	 BCS 1$
	MOV R0,$ENDCT
	CLR $EOPCT
	JMP $KONSL
1$:	JMP $PARAM

.SBTTL	END OF PASS ROUTINE

$EOP:	MOV #$PASS,R5
	INC (R5)		;INCREMENT THE PASS NUMBER
	CMP (R5),#30001.	;LIMIT MAX COUNT TO 30000
	BLT 4$
	CLR (R5)
	INC (R5)
	MOV $ENDCT,$EOPCT	;RESET REPORT INTERVAL

4$:	MOV (R5),SWR		;DISPLAY PASS COUNT
	SWITCH 			;READ THE SWITCH REGISTER

	BIT R0,#ABORT		;ABORT AFTER CURRENT PASS?
	BNE 1$			;YES

	DEC $EOPCT		;DECREMENT EOP
	BGT 3$
	BR 2$

1$:	MOV #1,$ITERA		;SET ITERATION SO WE WILL EXIT

2$:	PMSG <END PASS >

	MOV (R5),R0		;PASS COUNT TO  R0
	PNTDEC
	PCRLF

	MOV $ENDCT,$EOPCT	;RESTORE COUNTER

3$:	DEC $ITERA		;DECREMENT ITERATION COUNT
	BEQ $ERREOP
	CLR $ITERA
	EXIT

.SBTTL	ERROR EOP

$ERREOP:TST MONCTL		;STAND ALONE ?
	BNE $EROP		;NO, *WHAT TO DO ??*
	CLR TENRUN		;TURN OFF TEN SUPPORT
	CLR PRGRUN		;YES, ALLOW "J" AGAIN

$EROP:	JMP CONSL		;MONITOR, TO NEXT SCRIPT ENTRY

.SBTTL	ERROR HALT

$PRGHLT:PUSH R0
	PMSG <\PRG>
	BR $PH2

$ERRHLT:PUSH R0
	SWITCH
	BIT R0,#ERSTOP		;STOP ON ERROR ?
	BNE 1$			;YES
	POP R0
	EXIT 			;NO, KEEP GOING

1$:	PMSG <\ERROR>

$PH2:	SETFLG
	  .HCFLG		;ALLOW HALT CONTINUE

$PH1:	MOV (SP)+,$R0SAV	;SETUP SO "RG" CAN PRINT
	MOV (SP)+,$R5SAV
	MOV (SP)+,$R4SAV
	MOV (SP)+,$R3SAV
	MOV (SP)+,$R2SAV
	MOV (SP)+,$R1SAV
	MOV (SP)+,.HCADR
	MOV (SP)+,$PSSAV
	MOV SP,$SPSAV
	PMSG < HALT AT >

	MOV .HCADR,R0		;GET ADDRESS
	SUB #2,R0		;COMPUTE ACTUAL ADDRESS
	PNTOCT 			;PRINT ERROR HALT ADDRESS
	PCRLF
	JMP $CONSL		;RETURN TO MONITOR

.HC:	TST .HCFLG
	BNE 1$
	JMP $CMDER		;HC NOT ALLOWED
1$:	CLR .HCFLG
	JSR PC,.BCHC
	MOV $SPSAV,R6
	MOV $PSSAV,PS
	JMP @.HCADR

.SBTTL	PRINT ASCIZ MESSAGE (PNTAL)

$PNTAL:	BICB #200,(R0)		;CLEAR JUNK
	TSTB (R0)		;REACHED EOL YET?
	BEQ 3$			;YES
	TST HLPPNT		;PRINTING A HELP FILE
	BNE 4$			;YES
	CMPB (R0),#BKARW	;BACKARROW (-)?
	BEQ 2$			;YES
	CMPB (R0),#BKSLH	;BACKSLASH (\)?
	BEQ 1$
4$:	MOVB (R0)+,R1		;PUT CHAR IN R1
	PLDBUF 			;LOAD INTO OUTPUT BUFFER
	BR $PNTAL		;DO TILL E-O-L

1$:	MOV #CR,R1		;BACKSLASH
	PLDBUF 			;OUTPUT CR & LF
	MOV #LF,R1
	PLDBUF
11$:	INC R0
	BR $PNTAL

2$:	CLR CTRLOF		;CLEAR CONTROL O FLAG
	PRINTT 			;BACKARROW, PRINT BUFFER
	BR 11$

3$:	BR $$PNTX

.SBTTL	PRINT ASCII NUMBER (PNTNBR)

$PNTNBR:BIC #177770,R0
	BIS #'0,R0

.SBTTL	PRINT ASCII CHARACTER (PNTCHR)

$PNTCHR:MOVB R0,R1
	PLDBUF
$$PNTX:	EXIT

$PSPACE: MOV #SPACE,R0
	BR $PNTCHR

$PSLASH: MOV #SLASH,R0
	BR $PNTCHR

$PCOMMA: MOV #COMMA,R0
	BR $PNTCHR

$PTAB:	MOV #TAB,R0
	BR $PNTCHR

.SBTTL	PRINT BUFFER LOAD ROUTINE

$PLDBUF:PUSH R0
	MOV $OUTPT,R0
	BIC #177600,R1		;STRIP TO 7 BITS
	MOVB R1,(R0)+		;PUT CHAR IN BUFFER
	CLRB (R0)		;INSERT TRAILING NULL
	MOV R0,$OUTPT
	POP R0
	CMP $OUTPT,#$OUTBF+140.;EXCEEDED BUFFER CAPACITY
	BGE 2$

1$:	CMPB #LF,R1		;WAS CHAR LINE FEED
	BEQ 2$			;YES
	CMPB #BELL,R1		;WAS CHAR BELL ?
	BEQ 2$			;YES
	CMPB #NULL,R1		;WAS CHAR NULL ?
	BEQ 2$			;YES
3$:	BR $$PNTX		;NO, RETURN

2$:	TST PCMDNF		;DOING NO PRINT PROGRAM COMMAND
	BNE 3$
	PLPT 			;LINE PRINTER
	PRINTT 			;PRINT BUFFER
	CLR $TTLKF		;CLEAR TTLOOK  FLAG
	PUSH R0
	PNTRST 			;RESET OUTPUT POINTERS
	POP R0
	BR 3$

;PRINT, BACKUP OUTPUT INSERTION POINTER

$PNTBAK:CMP $OUTPT,#$OUTBF	;ALL THE WAY BACK ?
	BLE 1$			;YES
	DEC $OUTPT		;NO, BACKUP ONE BYTE
1$:	BR $$PNTX

;TELETYPE POINTER INITIALIZATION

$TTPINI:MOV #$INBUF,$INPTC
	MOV #$INBUF,$INPTR

$PNTRST:MOV #$OUTBF,R0
	MOV R0,$OUTPT
	MOV R0,$OUTPP
	BR $$PNTX

.SBTTL	TELETYPE PRINT OUTPUT ROUTINE

$PRINT:	PUSH R0
	TST $FORCE		;FORCED PRINT OUT
	BNE 19$			;YES BYPASS SWITCH TEST

	TSTB LPTFLG		;PRINT ON LPT ?
	BNE 99$			;BR IF YES

	SWITCH
	BIT R0,#NOPNT		;PRINTOUT INHIBITED
	BEQ 1$

99$:	MOV $OUTPT,$OUTPP	;DONE, SET PRINTED TO POSITION
	POP R0
	BR $$PNTX		;RETURN

19$:	CLR CTRLOF		;CLEAR CONTROL O FLAG
1$:	MOV $OUTPP,R1

11$:	CMPB #CR,(R1)		;IS CHAR CR?
	BEQ 2$			;BR IF YES
	CMP $PRNTH,$PGWID	;NO,ARE WE AT RIGHT MARGIN
	BLT 3$			;BR IF NO
	MOVB #CR,R0		;YES, FREE CR/LF
	PTTY
	MOVB #LF,R0
	PTTY

2$:	INC $TPLIT		;COUNT LINE

3$:	MOVB (R1),R0		;GET CHARACTER
	BEQ 99$			;IF NULL, DONE
	PTTY 			;PRINT CHAR
	TSTB (R1)+		;LOOP TILL E-O-L
	BNE 11$
4$:	JSR PC,C10COP
	JSR PC,$TORDY		;THEN WAIT FOR TTY TO BE READY
	BCS 4$
	BR 99$

.SBTTL	TELETYPE DRIVER

$PTTY:	CLR R2
	CLR R3
1$:	JSR PC,$PTTYC		;DO OPERATOR CHECKS
	TST R3			;R3 = 0 IF NOTHING
	BEQ 4$
2$:	CMPB #XON,R3
	BEQ 6$			;XON,PRINT
	CMPB #XOFF,R3
	BNE 4$
3$:	MOV #-1,R2		;XOFF,STOP PRINT
4$:	TST R2
	BNE 1$			;IF XOFF, WAIT FOR XON
6$:	TST CTRLOF		;CONTROL O'D ?
	BNE 7$			;YES
	CMPB #CR,R0		;CR
	BNE 7$
	TST $TPLIN		;YES, IN PAGE MODE
	BEQ 7$			;NO
	CMP $TPLIT,$TPLIN	;FILLED THIS PAGE
	BLT 7$
	CLR $TPLIT		;YES,CLEAR COUNTER,XOFF
	BR 3$

7$:	CLR R2
	CMPB #CNTRLI,R0		;IS CHAR A TAB?
	BNE 10$
8$:	JSR PC,$PTTY1		;COMPUTE SPACES COUNT
9$:	INC R2			;COMPLETED "TAB"?
	MOVB #BLANK,R0

10$:	CMPB #33,R0		;IS IT ALTMODE?
	BNE 101$
	MOV #'$,R0		;YES, CHANGE INTO DOLLAR SIGN
101$:	JSR PC,C10COP		;PERFORM CLOCK OPERATIONS
	TST CTRLOF
	BNE 11$
	JSR PC,$TORDY		;WAIT TILL TTY IS READY
	BCS 10$
	MOVB R0,$TOCHR		;PRINT CHAR
	JSR PC,$TOOUT
19$:	JSR PC,$PTTY2		;WILL CHAR MOVE PRINT HEAD ?

11$:	TST R2			;DOING SPACES?
	BNE 9$			;BR IF YES

	TST CTRLOF
	BNE 15$
	MOV #$DTBL0,R2		;FILLER PROCESS
12$:	TSTB (R2)
	BEQ 15$			;BR IF CHAR DOESN'T REQUIRE FILLS
	CMPB (R2)+,R0
	BNE 12$
	DEC R2			;FOUND
	SUB #$DTBL0,R2
	ASL R2
	MOV $DTBL1(R2),R2	;ADDRESS TO R2
	ADD $TTYFL,R2		;ADD FILL PARAMETER
	MOVB (R2),R2		;R2 = NUMBER OF FILLS
	CMPB R0,#CR		;CR?
	BNE 13$			;NO
	CMP $PRNTH,#15.		;MORE THEN 15 CHARS ON LINE ?
	BGT 16$
	SR R2,1			;NO, 1/4 TH OF FILLERS THEN
16$:	CMP $PRNTH,#40.		;MORE THAN 40 CHARS ON LINE ?
	BGT 17$
	SR R2,1			;NO, 1/2 OF FILLERS THEN
17$:	CLR $PRNTH		;SET PRINT HEAD TO LEFT MARGIN

13$:	DEC R2			;COMPLETED FILLERS?
	BLT 15$
14$:	JSR PC,C10COP		;PERFORM CLOCK OPERATIONS
	JSR PC,$TORDY
	BCS 14$
	MOVB #NULL,$TOCHR	;SEND FILLER
	JSR PC,$TOOUT
	BR 13$
15$:	EXIT 			;RETURN

$PTTY1:	MOV $PRNTH,R2		;HEAD POSITION
1$:	SUB #8.,R2		;DIVIDED BY 8
	BGE 1$			;REMAINDER IS SPACES COUNT
	RTS PC

$PTTY2:	CMPB R0,#BLANK		;WILL CHAR MOVE PRINT HEAD?
	BLT 1$			;BR IF NO
	INC $PRNTH		;YES
1$:	RTS PC

.SBTTL	LINE PRINTER DRIVER

.IF DF LPASB
$PLPT:	PUSH R0
	TST LPTFLG		;PRINT ON LPT ?
	BPL 99$			;NO
	TSTB LPTFLG
	BEQ 99$
	TST $FORCE		;FORCED PRINT ?
	BNE 1$			;YES, BYPASS SWITCH TEST
	SWITCH
	BIT R0,#NOPNT		;PRINTOUT INHIBITED ?
	BEQ 1$			;NO
99$:	POP R0
	EXIT 			;RETURN

1$:	TST LPTYPE		;LP20 OR LP11 ?
	BNE 50$			;LP20
	TST @$LPS		;IS LPT OK ?
	BMI 4$			;BR IF ERROR
	MOV #$OUTBF,R1
2$:	MOVB (R1)+,R0		;GET CHAR
	BEQ 99$			;NULL, DONE
3$:	CLR R2
	CMPB #CNTRLI,R0		;TAB ?
	BNE 41$
	JSR PC,$PTTY1		;YES, COMPUTE SPACES COUNT
42$:	INC R2
	MOV #BLANK,R0
41$:	JSR PC,$PTTYC		;DO OPERATOR CHECKS
32$:	TST @$LPS		;LPT OK ?
	BMI 4$			;NO
	JSR PC,C10COP		;PERFORM CLOCK OPERATIONS
	TSTB @$LPS		;LPT READY ?
	BPL 41$			;NO
	MOVB R0,@$LPB		;PRINT CHARACTER
	JSR PC,$PTTY2		;WILL CHAR MOVE PRINT HEAD ?
45$:	TST R2			;COMPLETED "TAB" ?
	BNE 42$
43$:	CMPB R0,#CR
	BNE 44$
	CLR $PRNTH		;IF CR, RESET HEAD POSITION
44$:	BR 2$

4$:	MOV #$LPTOF,R1		;"LPT OFF LINE"
5$:	MOVB (R1),R0
	PTTY
	TSTB (R1)+
	BEQ 6$
	BR 5$
6$:	CLRB LPTFLG		;PRINT ON TTY TILL RESELECTED
	BR 99$

50$:	MOV LPTYPE,R5		;LP20 DRIVER ROUTINE
	MOV #LPLINI!LPRERR,(R5) ;CLEAR LP20
	DEC LPPCTR(R5)		;CLEAR PAGE COUNTER
	MOV #$OUTBF,R0		;GET BUFFER ADDRESS
	MOV R0,LPBSAD(R5)	;SETUP LP20 BUFFER ADDRESS
	SUB $OUTPT,R0		;COMPUTE BYTE COUNT
	MOV R0,LPBCTR(R5)	;SETUP LP20 BYTE COUNT
	MOV #LPPENB!LPGO,(R5) ;START XFER
	JSR PC,LP20DN		;WAIT FOR DONE
	BCS 4$			;ERROR
	BR 99$			;DONE

LP20DN:	JSR PC,C10COP		;PERFORM CLOCK OPERATIONS
	BIT #LPERR!LPPZRO!LPUCHR!LPDONE,(R5)
	BEQ LP20DN		;WAIT FOR DONE OR ERROR

	TSTB (R5)		;DONE ?
	BPL 1$			;NO, ERROR
	CLC
	RTS PC			;DONE, C-BIT CLEAR RETURN

1$:	SEC
	RTS PC			;ERROR, C-BIT SET RETURN

$LPTOF:	.ASCIZ /LPT OFF
/
.EVEN

.ENDC ;LPASB
.IELSE $PLPT: EXITERR

;OPERATOR INTERRUPT TYPEIN CHECKS

$PTTYC:	CLR R3
	TST $TTLKF		;INPUT CHECKS INHIBITED ?
	BNE 5$			;YES
	JSR PC,$TIRDY		;ANY OPERATOR ACTION ?
	BCS 5$			;NO
	MOVB $TICHR,R3
	MOV R3,$TNCHR
	TENCHR 			;SEND CHAR TO TEN
	CMPB #CNTRLC,R3		;CONTROL C ?
	BNE 3$
	TTPINI 			;FLUSH REST OF OUTPUT
	TST PCMDFLG		;DOING PROGRAM COMMAND ?
	BNE 2$			;YES
	JMP $TICC		;CONTROL C, RETURN TO CONSOLE

2$:	JMP PCMDE2		;PROGRAM COMMAND, RETURN TO CALLER

3$:	CMPB #CNTRLO,R3
	BNE 1$
	COM CTRLOF		;CONTROL O, STOP OUTPUT
	MOV #$PTCO,R3
10$:	JSR PC,C10COP
	JSR PC,$TORDY
	BCS 10$
	MOVB (R3)+,$TOCHR
	BNE 90$
	CLR R3
	BR 5$
90$:	JSR PC,$TOOUT
	BR 10$
1$:	CMPB #CNTRLL,R3		;CONTROL L, CHANGE LPT SELECTION
	BNE 4$
	TST LPTFLG
	BPL 4$
	COMB LPTFLG		;ONLY IF SELECTED
4$:	CMPB #CNTRLX,R3		;CONTROL X, CONSOLE COMMAND
	BNE 5$
	JMP $TICX		;DO "TTILIN" & GO TO "$RPT"
5$:	RTS PC

$PTCO:	.ASCIZ /^O
/
.EVEN

.SBTTL	PRINT CRLF

$PCRLF:	PMSG <\>
	BR $$PEX

.SBTTL	RING TTY BELL

$PBELL:	MOVB #BELL,R0
	PTTY 			;DING THE BELL DIRECTLY
	BR $$PEX

.SBTTL	PRINT SPECIFIED OCTAL DIGITS

$PODT:	MOV @$EMADR,R1		;TRAILING PARAMETER
	ADD #2,12(SP)

$PNTODC:MOV R1,R2		;SETUP DIGIT COUNT
	BGT 1$
	FATAL
1$:	CMP R1,#6
	BLE 2$
	FATAL
2$:	MOV #$TTSAV+2,R1
	CLR (R1)		;SETUP OCTAL NUMBER
	MOV R0,-(R1)
	JSR PC,$PODMV		;SETUP PARAMETERS
	CLR $0FLG		;NO SPACE FOLLOWING NUMBER
	MOVB $PODCD-1(R2),R3	;GET PRESET SHIFT COUNT
	PROL36 			;PRESET NUMBER
	BR $P23X		;GO PRINT NUMBER

$PODCD:	.BYTE 33.,30.,27.,24.,21.,18.

.SBTTL	PRINT PDP-10 ADDRESS

;PRINTS 23 BIT FORMAT IF ANY OF 13-17 ADDRESS BITS ARE SET.
;OTHERWISE PRINTS 18 BIT FORMAT.

$PADR:	JSR PC,$$P23
	BIT #174,4(R1)		;ANY OF 13-17 SET ?
	BNE $P23Y		;YES
	MOV #6,R3
	PROL36 			;NO, DUMP HI-ORDER BITS
	BR $P18X		;PRINT 18 BITS

$$P23:	JSR PC,$P36MV
	MOV #12.,R3
	PROL36 			;POSITION 23 BITS
	BIC #177600,4(R1)	;CLEAR UPPER JUNK BITS
	RTS PC

.SBTTL	PRINT LOWER 18 BITS OF 36 BIT NUMBER

$PNT18:	JSR PC,$P36MV

	MOV #18.,R3
	PROL36 			;SHIFT LOWER 18 BITS TO UPPER
	BR $P18X

.SBTTL	PRINT LOWER 23 BITS OF 36 BIT NUMBER

$PNT23:	JSR PC,$$P23

$P23Y:	MOV #2,R2
	INC R4
	BR $P23X

.SBTTL	PRINT 36 BIT NUMBER IN BINARY

$P36B:	JSR PC,$P36MV
	COM R5
	BR $P36BX

.SBTTL	PRINT 36 BIT NUMBER

$PNT36:	JSR PC,$P36MV
$P36BX:	INC R4
$P18X=.

2$:	MOV #6,R2
$P23X=.
1$:	MOV #3,R3

	PROL36 			;ROTATE 3
	JSR PC,$PRT36		;PRINT OCTAL

	DEC R2			;FINISHED HALF WORD YET ?
	BNE 1$

	TST $0FLG
	BEQ 3$
	PSPACE

3$:	DEC R4			;FINISHED FULL WORD YET ?
	BPL 2$

$$PEX:	EXIT

$PRT36:	MOV 4(R1),R0		;GET THE WORD
	SWAB R0
	TST R5
	BNE 1$
	PNTNBR 			;PRINT OCTAL
	RTS PC

1$:	PUSH R4
	MOV R0,R4
	MOV #177776,R3
	SR R0,2
	BIC R3,R0
	PNTNBR 			;PRINT HI-BIT OF OCTAL
	MOV R4,R0
	SR R0,1
	BIC R3,R0
	PNTNBR 			;PRINT MIDDLE-BIT OF OCTAL
	MOV R4,R0
	BIC R3,R0
	PNTNBR 			;PRINT LO-BIT OF OCTAL
	PSPACE
	POP R4
	RTS PC

$P36MV:	MOV #6,R3		;MOVE 6 BYTES
	MOV #$TTSAV,R2		;TO SETUP DATA
	MOV R2,R1
1$:	MOVB (R0)+,(R2)+
	DEC R3
	BNE 1$
$PODMV:	CLR R5
	CLR R4
	MOV #4,R3
	MOV R3,$0FLG		;SET SPACE FLAG
	PROL36 			;PRESET NUMBER
	RTS PC

$PROL36:ROL (R1)
	ROL 2(R1)
	ROL 4(R1)
	DEC R3
	BNE $PROL36
	BR $$PEX

.SBTTL	PRINT OCTAL

$PNTOCT:MOV #-1,R4		;PRINT OCTAL
	BR $PNTO

.SBTTL	PRINT OCTAL ZERO SUPRRESS

$PNTOSC:CLR R4			;PRINT OCTAL ZERO SUPPRESS
$PNTO:	MOV #6,R1		;SET FOR 6 DIGITS
	MOV R0,R2		;SAVE INPUT NUMBERS
	CLR R5			;CLEAR THE ZERO FILL FLAG
	TST R4			;ZERO SUPPRESS ?
	BNE 10$			;NO
	TST R0			;TEST FOR A ZERO INPUT NUMBER
	BNE 1$
	CLR R1			;INPUT = 0 PRINT AND EXIT
	BR 5$

10$:	INC R5
1$:	CLR R0
	ROL R2			;MSD TO C BIT
	BR 3$

2$:	ROL R2
	ROL R2
	ROL R2
	MOV R2,R0
3$:	ROL R0

	BIC #177770,R0		;GET RID OF JUNK
	BEQ 4$
	INC R5			;SET ZERO FILL FLAG

4$:	TST R5			;SUPPRESS ?
	BEQ 6$
5$:	PNTNBR 			;PRINT DIGIT
6$:	DEC R1
	BGT 2$

	TST R4
	BEQ 7$
	PSPACE 			;SPACE UNLESS OCTAL SUPPRESS
7$:	BR $$PEX1

.SBTTL	CONVERT BINARY TO DECIMAL AND TYPE ROUTINE

$PNTDEC:MOV #5,R1		;SET FOR 5 DIGIT
	MOV R0,R2		;SAVE INPUT NUMBER
	CLR R5			;CLEAR ZERO FILL FLAG
	TST R0			;TEST SIGN OF INPUT NUMBER
	BPL 1$			;POSITIVE GO TYPE IT
	MOVB #'-,R0		;PRINT A MINUS SIGN
	PNTCHR 			;SEND TO BUFFER
	NEG R2			;NEGATE THE NUMBER
	MOV R2,R0		;GET NUMBER AGAIN
	BIC #100000,R0		;CLEAR SIGN BIT
1$:	TST R0			;TEST FOR A ZERO INPUT NUMBER
	BNE 2$			;NON ZERO
	PNTNBR 			;PRINT A SINGLE ZERO AND EXIT
	BR 9$			;EXIT
2$:	CLR R3			;ZERO THE CONSTANTS INDEX
3$:	CLR R0			;CLEAR THE BCD NUMBER
4$:	SUB $DTBL(R3),R2	;FORM THIS BCD DIGIT
	BLT 5$			;BR IF DONE
	INC R0			;INCREASE THE BCD DIGIT BY 1
	BR 4$
5$:	ADD $DTBL(R3),R2	;ADD BACK THE CONSTANT
	TST R0			;TEST IF DIGIT IS A ZERO
	BEQ 6$			;YES
	INC R5			;NO SET ZERO FILL FLAG
	BR 7$

6$:	TST R5			;IS ZERO FILL FLAG SET
	BEQ 8$			;YES EXIT
7$:	BIS #'0,R0		;MAKE THE BCD DIGIT ASCII
	PNTCHR
8$:	TST (R3)+		;JUST INCREMENTING
	DEC R1			;DONE YET
	BGT 3$			;GO DO THE NEXT DIGIT
9$:	PNTCI
	'. 			;PRINT DECIMAL POINT
$$PEX1:	EXIT 			;RETURN TO USER

.SBTTL	TTY INPUT ROUTINE TTICHR

$TTICHR:CLR R0
	CMP $INPTC,$INPTR	;ARE WE AT END ON CURRENT BUFFER
	BGT $TTIX2		;YES EXIT
	MOVB @$INPTC,R0		;FETCH CHARACTER FROM BUFFER
	INC $INPTC

$TTIX1:	BIC #177600,R0
	BR $$PSX2		;OK RETURN
$TTIX2:	BR $$PEX2		;ERROR RETURN

.SBTTL	TTY LOOK

;*TELETYPE KEYBOARD CHECK ROUTINE
;*CHECKS FOR ANY KEY STRUCK,RETURNS IMMEDIATELY
;*RETURNS WITH C-BIT SET IF NO TYPEIN

$TTLOOK:INC $TTLKF		;SET INHIBIT INPUT CHECKS
	CLR R0
	JSR PC,$TIRDY		;ANYTHING BEEN TYPED
	BCS $TTIX2		;NO, C-BIT RETURN
	MOVB $TICHR,R0		;YES, PUT IT IN R0
	CLR $TTLKF		;CLEAR INHIBIT INPUT CHECKS
	BR $$PSX2		;RETURN

.SBTTL	TTY ALT-MODE CHECK ROUTINE

;*CHECK FOR ALT-MODE IF NOTHING TYPED OR NOT ALTMODE C-BIT SET
;*IF ALT-MODE WAS TYPED THEN C-BIT CLEAR

$TTALTM:TTLOOK 			;ANYTHING TYPED
	 BCS 2$			;NO

	CMPB R0,#175
	BEQ 3$
	CMPB R0,#176
	BEQ 3$
	CMPB R0,#ALTMOD
	BEQ 1$

$$PEX2=.
2$:	EXITERR 		;EXIT
$$PSX2=.
1$:	EXIT 			;OK RETURN

3$:	MOVB #ALTMOD,R0
	BR 1$

.SBTTL	TTIYES YES OR NO ROUTINE

; NO BITS SET IF YES
; N-BIT SET IF NO
; C-BIT SET IF NEITHER

$TTIYES:TTICHR 			;GET INPUT CHARACTER
	 BCS $$PEX2		;NO CHAR AVAILABLE
	CMPB #'Y,R0		;WAS THE CHAR A "Y" ?
	BEQ $$PSX2		;BR IF YES
	CMPB #'N,R0		;WAS THE CHAR AN "N" ?
	BNE $$PEX2		;BR IF NO, NEITHER
	BIS #NBIT,14(SP)	;"NO", SET N-BIT
	BR $$PSX2

.SBTTL	PRINT A SELECTED NUMBER OF SPACES

$PNTSPC:DEC R1
	BLT 1$

	PSPACE 			;PRINT SPACE
	BR $PNTSPC

1$:	RTS PC

.SBTTL	BACKUP TTY INPUT BUFFER POINTER

$TTBACK:CMP $INPTC,#$INBUF
	BLE $$PEX2		;CAN'T, C-BIT SET RETURN
	DEC $INPTC		;BACKUP POINTER
	BR $$PSX2

.SBTTL	READ SWITCH REGISTER

$SWITCH:MOV SWR,R0		;PUT SWR INTO R0

1$:	MOV R0,$SWTCH		;SAVE A COPY FOR FUTURE REFERENCE
	BR $$PEX3		;RETURN TO USER

.SBTTL	RETURN WITH COPY OF SWITCHES 

$SWTSAM:MOV $SWTCH,R0		;COPY OF SWITCHES TO RO
	BR $$PEX3

.SBTTL	SET FORCE PRINT FLAG

$PFORCE:SETFLG
	  $FORCE		;177777 TO FORCE FLAG
	BR $$PEX3		;RETURN


.SBTTL	CLEAR FORCE PRINT FLAG

$PNORML:CLR $FORCE		;0 TO FORCE FLAG
$$PEX3:	EXIT 			;RETURN

;TTILIN ENTRY POINT FROM RUNLP

$TILRN:	CLR TILNWF		;CLEAR TTY WAIT FLAG
	JSR PC,$TILN3		;INIT TTILIN ROUTINE
	PUSH $FORCE
	MOV #$INBUF,R1
	BR $TILN2		;GO INPUT, 1ST CHAR ALREADY AVAILABLE

$TILN3:	CLR CTRLOF		;CLEAR CONTROL O FLAG
	CMP #$OUTBF,$OUTPT	;ANY OUTPUT WAITING ?
	BEQ 1$			;NO
	PRINTT 			;YES, PRINT IT
1$:	CLR $TPLIT		;CLEAR LINES ON PAGE
	CLR $0FLG		;CLEAR RUBOUT FLAG
	CLR $TTYTIM		;CLEAR TTY TIMEOUT
	RTS PC

.SBTTL	INPUT A STRING FROM TTY

$TTILNW:SETFLG 			;SET TTY WAIT FLAG
	  TILNWF
	BR $TILNX

$TTILIN:CLR TILNWF		;CLEAR TTY WAIT FLAG

$TILNX:	JSR PC,$TILN3		;INIT ROUTINE
	PUSH $FORCE
	PFORCE
95$:	MOV #$INBUF,R1
$TILN1=.
2$:	JSR PC,C10COP		;PERFORM CLOCK OPERATIONS
	TST TILNWF		;WAIT FOREVER ?
	BNE 21$			;YES, NO TIMEOUT
	CMP $TTYTIM,#<3*60.*60.>;TTY TIMED OUT ?
	BGT 99$			;YES, C-BIT SET EXIT

21$:	JSR PC,$TIRDY		;TTY IN FLAG SET
	BCS 2$
$TILN2=.
	CLR $TTYTIM
	MOVB $TICHR,(R1)	;MOVE CHARACTER TO BUFFER
	MOVB (R1),$TNCHR	;SAVE CHAR FOR TEN
	BEQ 2$			;NULL, IGNORE
	TENCHR 			;SEND TEN THE CHAR

	CLR R5			;DO SPECIAL CHAR PROCESS
80$:	CMPB (R1),TILINC(R5)
	BEQ 81$			;FOUND
	INC R5
	TSTB TILINC(R5)
	BEQ 82$			;IF 0, END OF LIST
	BR 80$

81$:	SL R5,1			;DISPATCH
	JMP @TILINA(R5)

82$:	CMPB (R1),#141
	BLT 83$
	CMPB (R1),#172
	BGT 83$
	BICB #40,(R1)		;CONVERT LOWER TO UPPER CASE

83$:	PUSH R1
	MOVB (R1),R1		;PUT CHAR IN R1
	PLDBUF 			;INSERT FOR LPT
	INC $OUTPP		;MOVE PRINTED-TO-POSITION
	POP R1

10$:	TST $0FLG		;RUBOUT KEY SET?
	BEQ 11$			;BR IF NO

	MOVB #BKSLH,R0		;TYPE A BACK SLASH
	PTTY
	CLR $0FLG		;CLEAR RUBOUT FLAG

11$:	MOVB (R1)+,R0		;CHAR TO R0
	PTTY 			;PRINT IT
	BR 2$			;BACK FOR MORE

99$:	MOV R1,$INPTR		;SAVE INPUT POINTER
	POP $FORCE
	EXITERR 		;TIMED OUT, C-BIT SET RETURN

$TIRUB:	TST $0FLG		;MULTIPLE RUBOUTS ?
	BNE 1$			;YES
	INC $0FLG		;SET RUBOUT FLAG
	MOVB #BKSLH,R0		;TYPE A BACKSLASH
	PTTY

1$:	DEC R1			;BACKUP BY ONE
	CMP R1,#$INBUF-1	;INPUT BUFFER EMPTY ?
	BNE 2$			;NO

	PCRLF 			;EMPTY, PRINT CR/LF
	POP $FORCE
	BR $TILNX		;AWAIT NEW LINE

2$:	MOVB (R1),R0		;PRINT RUBBED OUT CHAR
	PTTY
	BR $TILN1

;SPECIAL CHAR PROCESS

$TICU:	PMSG <^U\>		;CONTROL U, DUMP LINE
	POP $FORCE
	BR $TILNX

$TICR:	INC R1			;CARRIAGE RETURN
	MOVB #LF,(R1)		;INSERT LF ALSO

$TIBELL:PCRLF 			;PRINT CR/LF

$TIEXT:	MOV R1,$INPTR		;UPDATE INPUT POINTER
	MOV #$INBUF,$INPTC	;INIT CHAR POINTER
	POP $FORCE
	EXIT 			;RETURN

$TIALT:	MOVB #ALTMOD,(R1)	;ALTMODE
	PMSG <$\>		;PRINT DOLLAR SIGN CR/LF
	BR $TIEXT

$TIBKS:	PCRLF 			;BACKSLASH, DO LOCAL CR/LF
	BR $TILN1


$TICC:	PNTCI 			;CONTROL C, ABORT
	"^C
	JMP $CNTLC

$TICL:	TST LPTFLG		;CONTROL L, LPT SELECTION
	BPL $TILN1
	COMB LPTFLG
	BR $TILN1

$TILF:	MOVB (R1),R0		;LINE FEED
	PTTY
	BR $TIEXT

$TICO:	CLR CTRLOF		;CLEAR CONTROL O FLAG
	PNTCI
	"^O
	BR $TIBELL		;CR/LF & TERMINATE

$TICX:	TTPINI
	PNTCI
	"^X
	TTILIN 			;GET COMMAND LINE
	 BCS $TICC		;TIMED OUT
	MOV $KONSP,SP		;RESTORE STACK POINTER
	JMP $RPT		;GO PROCESS COMMAND

;SPECIAL CHARACTERS

TILINC:	.BYTE CR,LF
	.BYTE BELL,ALTMOD
	.BYTE 175,176
	.BYTE CNTRLL,CNTRLU
	.BYTE CNTRLC,BKSLH
	.BYTE RUBOUT,CNTRLO
	.BYTE XON,XOFF
	.BYTE CNTRLX,0

;SPECIAL CHAR DISPATCH TABLE

TILINA:	$TICR
	$TILF
	$TIBELL
	$TIALT
	$TIALT
	$TIALT
	$TICL
	$TICU
	$TICC
	$TIBKS
	$TIRUB
	$TICO
	$TIBELL
	$TIBELL
	$TICX

.SBTTL	CTY & FSTTY DL11 DRIVERS

$TIRDY:	TSTB @$TKS		;ANY CTY INPUT ?
	BPL 2$			;NO
	BIT #20000,@$TKB	;BREAK?
	BNE 5$
	MOVB @$TKB,$TICHR	;GET CHAR
	BICB #200,$TICHR
1$:	CLC 			;C-BIT CLEAR RETURN
	RTS PC

5$:	MOVB #MSWCHR,$TICHR	;TURN BREAK INTO MAGIC CHARACTER WHICH, WHEN READ,
	BR 1$			;CAUSES CONSOLE TO SWITCH OUT OF MONITOR MODE.

2$:	TST DL11EFLG		;DOING DL11E ?
	BEQ 3$			;NO
	BIT #DLCTS,@$FSTKS	;YES, STILL HAVE CLEAR TO SEND ?
	BEQ 4$			;NO

	TSTB @$FSTKS		;ANY FSTTY INPUT ?
	BPL 3$			;NO
	MOVB @$FSTKB,$TICHR	;YES, GET CHAR
	BR 1$			;C-BIT CLEAR RETURN

3$:	SEC 			;NO INPUT, C-BIT SET RETURN
	RTS PC

4$:	JMP FSDISC		;DL11E DISCONNECT

$TORDY:	TSTB @$TPS		;IS CTY READY ?
	BPL 2$			;NO
	TST DL11EFLG		;DOING DL11E ?
	BEQ 1$			;NO
	BIT #DLCTS,@$FSTKS	;STILL HAVE CLEAR TO SEND ?
	BEQ 3$			;NO

	TSTB @$FSTPS		;IS FSTTY READY ?
	BPL 2$			;NO

1$:	CLC 			;ALL READY, C-BIT CLEAR RETURN
	RTS PC

2$:	SEC 			;NOT READY
	RTS PC

3$:	JMP FSDISC		;DL11E DISCONNECT

$TOOUT:	MOVB $TOCHR,@$TPB	;PRINT ON CTY

	TST DL11EFLG
	BEQ 1$
	MOVB $TOCHR,@$FSTPB	;PRINT ON FSTTY
1$:	RTS PC

.SBTTL	READ AN OCTAL NUMBER FROM THE TTY

;REGISTER USAGE
;R0 = TTY CHARACTER 7 BIT FROM $INBUF
;R2 = WORK REGISTER
;R3 = CLEARED/SET = NO OCTAL CHARS/AT LEAST 1 OCTAL CHAR

$TTIOCT:CLR R2			;CLEAR WORK REGISTER
	JSR PC,$TMINUS		;CHECK FOR PLUS & MINUS
1$:	TTICHR 			;PICKUP THIS CHARACTER
	 BCS 2$

	CMPB R0,#60		;MAKE SURE THIS CHARACTER
	BLT 2$			;IS AN OCTAL DIGIT
	CMPB R0,#67
	BGT 2$

	INC R3			;TO SHOW I GOT ONE CHARACTER

	ASL R2
	ASL R2
	ASL R2

	BIC #177770,R0
	ADD R0,R2
	BR 1$

2$:	CLR R0			;SET UP FOR EXIT

	TST R3			;DID WE GET ANY DATA
	BEQ $$PEX7		;NO, ERROR RETURN

	MOV R2,R0
	TST R4			;NEGATE FLAG SET ?
	BEQ $$PEX6		;NO
	NEG R0			;YES, MAKE NUMBER NEGATIVE
$$PEX6:	JMP $TTERM		;VERIFY TERMINATION & EXIT
$$PEX7:	EXITERR 		;ERROR RETURN

$TMINUS:CLR R3			;CLEAR CHAR COUNTER
	CLR R4			;CLEAR NEGATE FLAG
	MOV $INPTC,R5		;SAVE INPUT POINTER
	TTICHR 			;GET 1ST CHAR
	 BCS 82$		;NONE AVAILABLE
	CMPB #'+,R0
	BEQ 80$
	CMPB #'-,R0		;NEGATE ?
	BNE 81$			;BR IF NO
	INC R4			;YES, SET NEGATE FLAG
80$:	INC R5			;YES, ADVANCE PAST -
81$:	MOV R5,$INPTC
82$:	RTS PC

.SBTTL	READ A DECIMAL NUMBER FROM THE TTY

$TTIDEC:MOV #$TTSAV,R2		;RESERVE STORAGE
	JSR PC,$TMINUS		;CHECK FOR PLUS & MINUS
1$:	TTICHR 			;READ IN A CHARACTER
	 BCS 2$
	CMPB R0,#60		;MAKE SURE THIS CHARACTER
	BLT 2$			;IS A DIGIT BETWEEN 0 & 9
	CMPB R0,#71
	BGT 2$
	INC R3			;SO I KNOW I GOT A DIGIT
	BIC #177760,R0		;DON'T LET NUMBER GET TO BIG
	MOVB R0,(R2)+
	BR 1$
2$:	CLR R0			;CLEAR OUTPUT
	TST R3			;DID WE GET ANY THING
	BEQ 6$			;NO

;NOW WE CONVERT IT

	CLR R1			;CLEAR TABLE INDEX
3$:	CMP R2,#$TTSAV
	BLT 5$			;YES NORMAL EXIT
	MOVB -(R2),R5		;PUT IN R5
4$:	DEC R5			;DONE YET
	BLT 7$
	ADD $TBLL(R1),R0	;TALLY IT UP
	BR 4$
7$:	TST (R1)+		;UPDATE TABLE TALLY
	BR 3$
5$:	TST R4			;NEGATE NUMBER ?
	BEQ 9$
	NEG R0			;YES
9$:	BR $$PEX6		;RETURN
6$:	BR $$PEX7		;ERROR RETURN

.SBTTL	READ A 12 DIGIT OCTAL (36 BIT) NUMBER

;$0FLG, 0=NO DATA; 0,-1=ONE DATA WORD; -1,-1= TWO PART DATA
;DATA IS TRUNCATED TO 6 OCTALS IN EITHER HALF OF 2 PART DATA
;DATA IS TRUNCATED TO 12 OCTALS IN 1 PART DATA
;DURING CONVERSION
;1 PART DATA; $0FLG =0
;2 PART DATA; $0FLG=-1,0 DURING HI6; 0,-1 DURING LO6

$TTI36:	JSR PC,$TI36C
	CLR $SVH
	CLR $SVM
	CLR $0FLG
	CLR $NEG
	JSR PC,$TMINUS
	TST R4
	BEQ 1$
	INCB $NEG+1		;SET NEGATE FLAG

1$:	TTICHR 			;READ A CHAR
99$:	 BCS 98$		;BUFFER EMPTY

	CMPB R0,#60		;MAKE SURE ITS OCTAL
	BLT 2$
	CMPB R0,#67
	BGT 2$

	MOVB #-1,$0FLG		;WE GOT AT LEAST 1 DIGIT
	BR 1$

2$:	TSTB $0FLG
	BEQ 69$
	CMPB R0,#BLANK		;WAS IT A SPACE ?
	BNE 3$			;NOPE
	MOVB #-1,$0FLG+1	;SET 2 WORD FLAG
	TTICHR 			;GET 1ST CHAR OF 2ND PART
98$:	 BCS 97$
	CMPB #'+,R0
	BEQ 71$
	CMPB #'-,R0		;IS IT MINUS ?
	BEQ 21$			;YES
	DEC $INPTC		;NO, BACKUP INPUT POINTER
	BR 1$
21$:	INCB $NEG		;SET 2ND PART NEGATE FLAG
71$:	BR 1$			;PROCESS 2ND HALF WORD

3$:	MOV R5,$INPTC		;RESET INPUT POINTER
	CLRB $0FLG

4$:	TTICHR
97$:	 BCS 96$
	CMPB R0,#60
	BLT 5$
	CMPB R0,#67
	BGT 5$

	BICB #370,R0
	MOV #3,R1

6$:	JSR PC,SHFT36		;SHIFT 36 BIT WORD LEFT 3

	BISB R0,$DRAM		;INSERT NEW CHAR
	BR 4$

5$:	TSTB $0FLG+1		;DOING 2 PART NUMBER ?
	BEQ 8$			;BR IF NO

51$:	TSTB $NEG+1		;NEGATE UPPER PART ?
	BEQ 52$			;NO

	JSR PC,NEG36		;NEGATE 36 BIT WORD

52$:	MOV #18.,R1		;YES, MOVE NUMBER TO UPPER 18 BITS

7$:	JSR PC,SHFT36		;SHIFT 36 BIT WORD LEFT 18

	MOV -(R5),$SVH		;SAVE UPPER BITS
	MOV -(R5),$SVM		;SAVE MIDDLE BITS
	JSR PC,$TI36C

	SWAB $0FLG		;MAKE $0FLG 0,-1
	TTICHR 			;GET 1ST CHAR OF 2ND PART
96$:	 BCS 9$
	CMPB #'+,R0
	BEQ 4$
	CMPB #'-,R0		;IS IT MINUS ?
	BEQ 4$			;YES
	DEC $INPTC		;NO, BACKUP INPUT POINTER
	BR 4$

8$:	TSTB $0FLG
	BEQ 10$			;BR IF 1 PART
	TSTB $NEG		;NEGATE LOWER PART ?
	BEQ 81$			;NO

	JSR PC,NEG36		;NEGATE 36 BIT WORD

81$:	MOV #$DRAM+2,R1
	BIC #177774,(R1)
	BIS $SVM,(R1)+
	CLR (R1)		;CLEAR BITS 0-17
	BIS $SVH,(R1)		;REINSERT UPPER BITS
	BR 12$

10$:	TSTB $NEG+1		;MAKE NUMBER NEGATIVE ?
	BEQ 12$			;BR IF NO
	JSR PC,NEG36		;NEGATE 36 BIT WORD

12$:	BIC #177760,$DRAM+4	;STRIP OVERFLOW
	MOV #$DRAM,R0		;RETURN STORAGE ADR IN R0
	JMP $TTERM		;VERIFY TERMINATION & EXIT
69$:	CLR R0			;NO DIGITS TYPED
9$:	TTERM 			;VERIFY TERMINATION
	EXITERR 		;ERROR RETURN

;SHIFT 36 BIT WORD C(R1) PLACES LEFT

SHFT36:	MOV #$DRAM,R5
	CLC
	ROL (R5)+
	ROL (R5)+
	ROL (R5)+
	DEC R1
	BGT SHFT36
	RTS PC

;NEGATE - TWO'S COMPLEMENT 36 BIT WORD

NEG36:	MOV #$DRAM,R1		;MAKE 1'S COMPLEMENT
	COM (R1)+
	COM (R1)+
	COM (R1)
	MOV #$DRAM,R1
	ADD #1,(R1)+		;MAKE THAT 2'S COMPLEMENT
	ADC (R1)+
	ADC (R1)
	BIC #177760,(R1)	;STRIP OVERFLOW
	RTS PC

$TI36C:	MOV #$DRAM,R0		;CLEAR STORAGE
	CLR (R0)+
	CLR (R0)+
	CLR (R0)+
	RTS PC

.SBTTL	SIGNED MULTIPLY SUBROUTINE

$MULTP:	PUSH R0
	MOV 22(SP),R1
	MOV 20(SP),R0		;MULTIPLICAND
	CLR R4			;CLEAR SIGN
	TST R0			;TEST SIGN
	BPL 1$

	INC R4			;SET SIGN BIT
	NEG R0			;MAKE MULTIPLICAND POSITIVE

1$:	TST R1			;TEST SIGN OF MULTIPLIER
	BPL 2$

	DEC R4			;UPDATE SIGN BIT
	NEG R1			;MAKE MULTIPLIER POSITIVE

2$:	MOV #17.,R3		;SET LOOP COUNT
	CLR R2			;SET UP FOR MULTIPLY LOOP

3$:	 BCC 4$			;DONT ADD IF MULTIPLICAND IS ZERO
	ADD R1,R2

4$:	ROR R2			;POSITION THE PARTIAL PRODUCT
	ROR R0			;AND THE MULTIPLICAND
	DEC R3			;DONE YET
	BNE 3$			;NOPE

	TST R4			;TEST SIGN
	BEQ 5$			;PRODUCT IS POSITIVE

	NEG R0			;PRODUCT SHOULD BE NEGATIVE
	NEG R2
	SBC R0			;SUBTRACT CARRY

5$:	MOV R0,20(SP)		;MOST SIGNIFICANT BITS
	MOV R2,22(SP)		;LEAST SIGNIFICANT BITS
	POP R0
	EXIT 			;EXIT

.SBTTL	BREAK CHARACTER

$TTIBRK:DEC $INPTC		;BACKUP INPUT POINTER
	TTICHR
	 BCC $$PEX4		;NOTHING IN BUFFER
$$PEX5:	EXITERR

.SBTTL	TELETYPE INPUT SPACE DELETE ROUTINE

$TTSDL:	TTICHR
	 BCS $TTSDX		;BUFFER EMPTY
	CMPB R0,#BLANK
	BEQ $TTSDL		;DELETE SPACES
	CMPB R0,#TAB
	BEQ $TTSDL		;DELETE TABS
	CMPB #'-,R0			;TREAT + OR -
	BEQ 3$			;SAME AS NUMBER
	CMPB #'+,R0
	BEQ 3$
	CMPB R0,#60
	BLT 1$			;BR IF NON-NUMBER
	CMPB R0,#71
	BGT 1$			;BR IF NON-NUMBER
3$:	DEC $INPTC		;NUMBER, BACKUP INPUT POINTER
	BR $$PEX4		;C-BIT CLEAR RETURN
1$:	CMPB R0,#':		;COLON OR SLASH, V-BIT & C-BIT SET
	BEQ 10$
	CMPB R0,#'/
	BEQ 10$
	CMPB R0,#'^		;UPARROW, Z-BIT & C-BIT SET
	BNE $$PEX5
	BIS #ZBIT,14(SP)
	BR $$PEX5

10$:	BIS #VBIT,14(SP)
	BR $$PEX5
$TTSDX:	JMP $PARAM

.SBTTL	TELETYPE INPUT TERMINATION CHECK

$TTITRM:INC $INPTC		;BECAUSE "TTERM" DECREMENTS
$TTBTRM:TTERM 			;VERIFY TERMINATOR
	BCS $TTSDX		;BAD, C-BIT SET RETURN
	BR $$PEX4		;OK

$TTERM:	PUSH R0
	DEC $INPTC		;BACKUP INPUT POINTER
	TTICHR 			;GET TERMINATION CHAR
	 BCS 2$			;NONE
	MOV #TRMTAB,R1		;SETUP TERMINATION SCAN POINTER
1$:	CMPB R0,(R1)		;CHAR MATCH LEGAL TERMINATOR ?
	BEQ 2$			;YES
	TSTB (R1)+		;NOT YET, GO TO NEXT
	BEQ 3$			;NO MATCH, ERROR
	BR 1$
2$:	POP R0
	BR $$PEX4		;OK, C-BIT CLEAR RETURN
3$:	POP R0
	BR $$PEX5		;ERROR, C-BIT SET RETURN

TRMTAB:	.BYTE SPACE,TAB
	.BYTE COMMA,CR
	.BYTE ALTMOD,72		;COLON
	.BYTE 57,0		;SLASH

.SBTTL	INPUT & CHECK OCTAL NUMBER

$TTCOCT:TTISDL
	 BCS $TTSDX
	TTIOCT
	 BCS $TTSDX		;NON-OCTAL
	BR $$PEX4		;OK

$TOCTE:	TTCOCT
	BIT #1,R0		;ONLY EVEN OCTAL
	BNE $TTSDX
	BR $$PEX4

.SBTTL	TELETYPE DELETE SPACES & INPUT OCTAL NUMBER

$TTSDO:	TTCOCT
	TST R0			;MUST BE POSITIVE ALSO
	BMI $TTSDX
$$PEX4=.
	EXIT

.SBTTL	TELETYPE DELETE SPACES & INPUT 36BIT NUMBER

$TTS36:	TTISDL 			;DELETE SPACES
	 BCS $TTSDX
	TTI36 			;INPUT 36 BIT NUMBER
	 BCS $TTSDX
	BR $$PEX4

.SBTTL	TELETYPE INPUT C-RAM ADDRESS

$TICRA:	TTISDO 			;GET ADDRESS
	CMP R0,#CRMSIZ
	BLE $$PEX4
	JMP ADRERR		;TOO BIG

.SBTTL	SHIFT R0 RIGHT/LEFT ROUTINES

$SHFTR:	MOV @$EMADR,R1		;GET SHIFT COUNT
1$:	ASR R0			;SHIFT RIGHT
	DEC R1
	BGT 1$
$SHFTX:	EXITSKP 		;SKIP OVER TRAILING PARAMETER

$SHFTL:	MOV @$EMADR,R1
1$:	ASL R0			;SHIFT LEFT
	DEC R1
	BGT 1$
	BR $SHFTX

.SBTTL	PRINT MESSAGE, CONDITIONAL DEPENDING ON "RPTFLG"

$$PMSR:	TSTB RPTFLG		;DOES REPEAT FLAG ALLOW PRINTING ?
	BNE $SHFTX		;NO

.SBTTL	PRINT MESSAGE

$$PMSG:	MOV @$EMADR,R0		;MESSAGE ADDRESS TO R0
	PNTAL 			;PRINT
	BR $SHFTX		;SKIP RETURN

.SBTTL	PRINT CHARACTER IMMEDIATE

$PNTCI:	MOV $EMADR,R2		;GET DATA ADDRESS
	MOVB (R2)+,R1		;GET FIRST BYTE
	PLDBUF 			;INSERT IN BUFFER
	MOVB (R2),R1		;GET 2ND BYTE
	BEQ 1$			;IS THERE ANY ?
	PLDBUF 			;YES, INSERT IN BUFFER
1$:	BR $SHFTX		;SKIP RETURN

.SBTTL	SMALL TIME DELAY

$DELAY:	MOV #10.,R1
1$:	DEC R1
	BNE 1$
	EXIT

;CONSOLE TIME DELAY FOR REPEAT LOOPS

.TD:	TTISDL
	 BCS 1$			;NO ARG, DO ONCE
	TTIDEC
	 BCS 1$			;DO ONCE ANYWAY
	MOV R0,R1		;SAVE DELAY COUNT
	BR 2$
1$:	CLR R1
2$:	TDELAY 			;SMALL TIME DELAY
	DEC R1			;DONE REQUESTED DELAYS ?
	BGT 2$
	JMP $KONSL

.SBTTL	SAVE AND RESTORE R0-R5 ROUTINES

$REGSAV:PUSH R0
	PUSH 16(SP)
	PUSH 16(SP)
	RTI

;*RESTORE R0-R5

$REGRST:MOV 14(SP),34(SP)
	MOV 12(SP),32(SP)
	ADD #16,SP
	POP <R0,R5,R4,R3,R2,R1>
	RTI

;FATAL VECTOR INTERRUPT

$FATLE:	PUSH R0
	PMSG <?FATAL INTR>
	BR $EOR

$TIMOT:	PUSH R0
	PMSG <?BUS TIMEOUT>
	BR $EOR

$RESVD:	PUSH R0
	PMSG <?RESERVED INST>

$EOR:	CLR TENRUN
	POP R0
	PUSH <R1,R2,R3,R4,R5,R0>
	BR $EOR2

;STACK UNDERFLOW

$STUF:	MOV #STACK-2,SP
	MOV SP,$KONSP
	PMSG <?ST UNFLO>
	CLR PCMDFLG
	JMP $CNTLC

$NOTAS:	PMSG <?UNAS EMT>
$EOR2:	CLR PCMDFLG
	JMP $PH1

$FATAL:	PUSH R0
	PMSG <?FATAL>
	BR $EOR2

.SBTTL	EMT DECODER

;*THIS ROUTINE WILL PICKUP THE LOWER BYTE OF THE "EMT" INSTRUCTION
;*AND USE IT TO INDEX THROUGH THE EMT TABLE FOR THE STARTING ADDRESS
;*OF THE DESIRED ROUTINE. THEN USING THE ADDRESS OBTAINED IT WILL
;*GO TO THAT ROUTINE.

$EMTRP:	CMP SP,#COREND-600+20
	BLE $STUF			;OFF BOTTOM OF STACK
	PUSH <R1,R2,R3,R4,R5,R0>
	MOV 14(SP),R0			;GET EMT ADDRESS (+2)
	BIC #17,16(SP)			;CLEAR ALL STATUS BITS
	MOV R0,$EMADR			;SAVE
	MOV -(R0),R0			;GET RIGHT BYTE OF EMT
	BIC #177400,R0
	CMP R0,#<<$EMTAE-$EMTAD>/2>
	BGE $NOTAS			;EMT IN RANGE ?
	SL R0,1				;ROUND TO WORD ADDRESS
	MOV $EMTAD(R0),R0		;INDEX TO TABLE
	RTS R0				;GO TO ROUTINE

.SBTTL	EMT TABLE

;*THIS TABLE CONTAINS THE STARTING ADDRESSES OF THE ROUTINES CALLED
;*BY THE "EMT" INSTRUCTION.

;	ROUTINE
;	-------
$EMTAD:	$FATAL 			;EMT + 0
	$ERRHLT 		; 1
	$PRGHLT 		; 2
	$RUNLP 			; 3
	$TTILIN 		; 4	
	$TTICHR 		; 5
	$TTLOOK 		; 6
	$TTIOCT 		; 7
	$TTCOCT 		;EMT + 10
	$TTIDEC 		; 11	
	$TTIYES 		; 12
	$TTALTM 		; 13
	$TTI36 			; 14	
	$TTIBRK 		; 15
	$TTSDL 			; 16
	$TTSDO 			; 17
	$TTS36 			;EMT + 20
	$TICRA 			; 21
	$TTITRM 		; 22
	$TTBTRM 		; 23
	$PNTAL 			; 24	
	$$PMSG 			; 25
	$$PMSR 			; 26
	$PNTCHR 		; 27

	$PNTNBR 		;EMT + 30
	$PCRLF 			; 31
	$PSPACE 		; 32
	$PSLASH 		; 33
	$PCOMMA 		; 34
	$PNTOCT 		; 35
	$PNTOSC 		; 36	
	$PNTDEC 		; 37
	$PNT18 			;EMT + 40
	$PNT23 			; 41
	$PNT36 			; 42
	$PFORCE 		; 43
	$PNORML 		; 44	
	$PBELL 			; 45
	$PNTODC 		; 46
	$PODT 			; 47
	$REGSAV 		;EMT + 50	
	$REGRST 		; 51
	$CMP36 			; 52	
	$SHFTR 			; 53
	$SHFTL 			; 54
	$SETFLG 		; 55
	$DELAY 			; 56
	$SWITCH 		; 57	
	$SWTSAM 		;EMT + 60
	$EOP 			; 61	
	$ERREOP 		; 62
	$EOPSET 		; 63
	$COMLIN 		; 64
	$COMSND 		; 65
	$COMACK 		; 66
	$COMNAK 		; 67
	$COMCLR 		;EMT + 70
	$COMCTL 		; 71
	$MULTP 			; 72	
	$WCRAM 			; 73
	$RCRAM 			; 74
	$WWADR 			; 75
	$MRESET 		; 76	
	$TENSP 			; 77
	$SM 			;EMT + 100
	$XCT 			; 101
	$LODAR 			; 102
	$EXAM 			; 103
	$EXAMT 			; 104
	$DPOS 			; 105
	$DPOST 			; 106
	$DPOSVR 		; 107

	$DPSVT 			;EMT + 110
	$D10MON 		; 111
	$D10ZRO 		; 112
	$DTEBAS 		; 113
	$DFXCT 			; 114
	$DXCTT 			; 115
	$DFRD 			; 116
	$DFRDMV 		; 117	
	$DFWRT 			;EMT + 120
	$DFWIR 			; 121
	$DFSCLK 		; 122
	$DFPC 			; 123
	$DFVMA 			; 124
	$DFADB 			; 125
	$RDRAM 			; 126
	$WDRAM 			; 127
	$DRAMAD 		;EMT + 130
	$BURST 			; 131
	$PNTCPU 		; 132
	$PRGCMD 		; 133	
	$P36B 			; 134
	$ECLOK 			; 135
	$ESYNC 			; 136
	$PADR 			; 137
	$DFRDT 			;EMT + 140
	$DWRTT 			; 141
	$PCRAM 			; 142
	$PDRAM 			; 143
	$TTBACK 		; 144
	$TENSW 			; 145
	$PROL36 		; 146
	$SETMPH 		; 147
	$DFVMH 			;EMT + 150
	$PRINTT 		; 151
	$PTTY 			; 152
	$PLPT 			; 153
	$PLDBUF 		; 154
	$R50UPK 		; 155
	$DTINIT 		; 156
	$RPINIT 		; 157
	$DVDATA 		;EMT + 160
	$DTREAD 		; 161
	$RPREAD 		; 162
	$DVFRAM 		; 163
	$DVWRD 			; 164
	$ASCR50 		; 165
	$RPLOAD 		; 166
	$RPFIND 		; 167

	$RPLKUP 		;EMT + 170
	$RPRDFL 		; 171
	$RPWRFL 		; 172
	$RPWRIT 		; 173
	$RPADDR 		; 174
	$RPBASE 		; 175
	$TENCHR 		; 176
	$PNTBAK 		; 177
	$TOCTE 			;EMT + 200
	$TTERM 			; 201
	$CLKPRM 		; 202
	$MICNUL 		; 203
	$MICFIL 		; 204
	$DTWRT 			; 205
	$NAMEXT 		; 206
	$DTAFILE		; 207
	$RPFILE 		;EMT + 210
	$DTRDFL 		; 211
	$DTWTFL 		; 212
	$DTBASE 		; 213
	$PNTCI 			; 214
	$PNTRST 		; 215
	$PRGNPT 		; 216
	$TTPINI 		; 217
	$COMCMD 		;EMT + 220
	$CMRTRY 		; 221
	$COMENQ 		; 222
	$COMEOT 		; 223
	$TTILNW 		; 224
	$TTICCL 		; 225
	$DFLEGAL		; 226
	$PTAB 			; 227
	$RXFILE 		;EMT + 230
	$RXINIT 		; 231
	$RXRDFL 		; 232
	$RXWTFL 		; 233
	$RXBASE 		; 234
	$RXREAD 		; 235
	$RXWRT 			; 236
	$RPERR 			; 237
$EMTAE=.

$ESYNC:	PUSH R0
	JMP $NOTAS

.SBTTL	POWER DOWN AND UP ROUTINES

$PWRDN:	MOV #$PWRUP,@#PWRVEC	;SET UP VECTOR
$ILLUP:	HALT
	BR $ILLUP		;HANG UP

;POWER UP ROUTINE

$PWRUP:	MOV #PR7,PS		;SET CPU PRIO:7
	MOV #STACK,SP		;SET SP 
	CLR R5			;WAIT LOOP FOR THE TTY
1$:	INC R5			;WAIT FOR THE INC
	BNE 1$			;OF  WORD
	MOV #$PWRDN,@#PWRVEC	;SET UP THE POWER DOWN VECTOR
	CLR CONSOL-2
	CLR LPTFLG		;DISCONNECT LINE PRINTER
	CLR DL11EFLG		;DISCONNECT KLINIK !!!
	INC $PWRCNT		;COUNT POWER RESTARTS
	MOV #KWLKS,R3
	CLR R5
10$:	TSTB (R3)		;WAIT FOR CLOCK TICK
	BPL 10$
	BIC #200,(R3)
	INC R5			;COUNT IT
	CMP R5,#<5.*60.>	;WAITED 5 SEC FOR TTY POWER ?
	BLE 10$			;NOT YET
	PMSG <\"POWER RESTART" >
	MOV $PWRCNT,R0
	PNTDEC
	PCRLF
	CLR R5			;CLEAR TIME-UP COUNTER
2$:	JSR PC,$TIRDY		;ANY OPERATOR INTERRUPT ?
	BCS 3$			;NO
	MOVB $TICHR,R4		;YES, GET CHAR
	CMPB #CNTRLC,R4		;IS IT CONTROL C ?
	BEQ 4$			;YES, ABORT TIME-UP WAIT
3$:	TSTB (R3)		;CLOCK SET ?
	BPL 2$			;NO
	BIC #200,(R3)
	INC R5			;COUNT CLOCK TICK
	CMP R5,#<5.*60.>	;WAITED 5 SECONDS FOR KL10 ?
	BLE 2$			;NOT YET
4$:	JMP START

.SBTTL	EXIT SUBROUTINE

$EXITE:	BIS #CBIT,14(SP)	;SET C-BIT ERROR
	BR $EXIT

$SETFLG:MOV @$EMADR,R1		;SET -1 TO FLAG WORD
	MOV #-1,(R1)

$EXITS:	ADD #2,12(SP)		;SKIP RETURN
$EXIT:	POP <R5,R4,R3,R2,R1>
	RTI 			;RETURN TO USER

;MEMORY PARITY

MEMPE:	TST MEMPEF		;BEEN HERE ALREADY ?
	BPL 1$
	FATAL 			;YES
1$:	COM MEMPEF		;SET FLAG
	BIC #MMPIE,MMLPBA	;CLEAR ENABLE
	BIT #MMERRF,MMLPBA	;ERROR SET ?
	BNE 2$
	FATAL 			;NO, HOW DID THIS GET HERE ?
2$:	PMSG <?PARITY>
	JMP $CNTLC

.SBTTL	PDP10 OPERATIONS

;PDP-10 MEMORY ZERO
; R0 = COUNT, R1 = POINTER TO START ADDRESS

$D10ZRO: MOV R0,R5		;SAVE COUNT
	DEC R5
	MOV #.DPXAD,R4
	MOVB (R1)+,(R4)+
	MOVB (R1)+,(R4)+
	MOVB (R1),(R4)
	TST -(R4)
	CLR @.DAT1		;CLEAR DTE20 DATA WORDS
	CLR @.DAT2
	CLR @.DAT3

$D10ZX: MOV R4,R1		;POINTER TO ADDRESS
	BR $DPSX1

;PDP-10 SET -1 TO FLAG WORD
; ADDRESS IN TRAILING PARAMETER

$D10MON: MOV #L10ADR+2,R1	;SETUP 10 ADR BLOCK POINTER
	CLR (R1)
	MOV @$EMADR,-(R1)	;PUT 10 ADR IN ADR BLOCK
	MOV #TENMO,R0		;SETUP -1 DATA WORD
	ADD #2,12(SP)		;SKIP RETURN OVER TRAILING PARAMETER
	CLR R5
	BR $DPOSX

;EXAMINE AND DEPOSIT 10 MEMORY

$DPOST:	JSR PC,$10ADR		;SETUP PARAMETERS

$DPOS:	CLR R5
	JSR PC,$D10ADR		;SETUP PDP-10 ADDRESS

$DPOSX:	MOV #$TEMP0,R2		;STUFF THE DEXWRDS
	MOVB (R0)+,(R2)+
	MOVB (R0)+,(R2)+
	MOVB (R0)+,(R2)+
	MOVB (R0)+,(R2)+
	MOVB (R0)+,(R2)+
	MOVB (R0),(R2)+
	BIC #177760,-(R2)
	MOV .DAT1,R3
	MOV (R2),(R3)		;BITS 00-03 TO .DAT1
	MOV -(R2),-(R3)		;BITS 04-19 TO .DAT2
	MOV -(R2),-(R3)		;BITS 20-35 TO .DAT3
$DPSX1:	BIS #DEP,2(R1)		;SET FLAG
	BR $EXDEP

$EXAMT:	JSR PC,$10ADR		;SETUP PARAMETERS
	BR $EXAMX

$EXAM:	MOV R0,R1
	JSR PC,$D10ADR		;SETUP PDP-10 ADDRESS
	MOV #$DRAM,R0
$EXAMX:	CLR R5
	BIC #DEP,2(R1)		;CLEAR FLAG BIT

$EXDEP:	MOV #EBUSPC,@.STDTE	;E-BUS PARITY CLEAR
	BIS #PHYS!PRTOFF,2(R1)

	MOV 2(R1),@.TENA1
	MOV (R1),@.TENA2	;START DTE20

	MOV EMTIMO,-(SP)	;SET TIMEOUT COUNT
93$:	BIT #DEXDON,@.STDTE	;TEST BIT
	BNE 94$			;LEAVE IF NOW A ONE(OK)
	DEC (SP)		;DECREMENT COUNT
	BNE 93$			;CONTINUE LOOP
	TST RPTFLG		;OTHERWISE TIMEOUT
	BNE 94$			;UNLESS UNDER REPEAT
	CLR TENRUN		;CLEAR TEN RUNNING
	CLR R5			;CLEAR BLOCK ZERO INDICATOR
	BIS #CBIT,16(SP)
94$:	TST (SP)+		;RESET STACK

	BIT #DEP,2(R1)
	BNE 1$			;DEPOSIT BRANCHES
	PUSH R0
	MOV .DAT3,R3
	MOV (R3)+,(R0)+		;BITS 20-35 FROM .DAT3
	MOV (R3)+,(R0)+		;BITS 04-19 FROM .DAT2
	MOV (R3),(R0)		;BITS 00-03 FROM .DAT1
	BIC #177760,(R0)
	POP R0
	BIT #BPARER,@.STDTE	;E-BUS PARITY ERROR ?
	BEQ 1$			;NO
	BIS #CBIT!VBIT!NBIT!ZBIT,14(SP) ;SET ALL COND BITS
1$:	TST R5			;EXAM, DPOS OR FINISHED BLOCK ZERO ?
	BEQ 2$			;YES
	DEC R5			;BLOCK ZERO, DECREMENT COUNT
	ADD #1,(R4)		;INCREMENT PDP-10 ADDRESS
	ADC 2(R4)
	BR $D10ZX		;CLEAR NEXT WORD
2$:	EXIT

$D10ADR:MOV #L10ADR,R4
	MOVB (R1)+,(R4)+
	MOVB (R1)+,(R4)+
	MOVB (R1),(R4)
	BIC #177760,(R4)
	MOV #L10ADR,R1
	RTS PC

$EBPAR:	.ASCIZ/?E-BUS PARITY ERROR /
.EVEN

$DPSVT:	JSR PC,$10ADR		;SETUP PARAMETERS

$DPOSVR: PUSH R0
	DPOS
	 BCS $DPVRP
	MOV R1,R0
	EXAM
	 BCS $DPVRE
	POP R0
	MOV #$DRAM,R1

;5-BYTE COMPARE ROUTINE, C & V BIT SET IF ERROR

$CMP36:	PUSH R1
	MOV #5,R2
1$:	CMPB (R0)+,(R1)+
	BNE 2$
	DEC R2
	BNE 1$
	BR $DPVRX
2$:	BIS #CBIT!VBIT,16(SP)	;SET C & V FOR VERIFY ERROR
$DPVRX:	POP R0			;POINT TO ACTUAL
	EXIT

$DPVRP:	BIS #CBIT!NBIT,16(SP)
	BR $DPVRX
$DPVRE:	BIS #CBIT!ZBIT,16(SP)
	BR $DPVRX

;PDP-10 ADDRESS PARAMETER SETUP

$10ADR:	MOV $EMADR,R5		;SETUP TRAILING PARAMETER PICKUP
	MOV #L10ADR+2,R1	;SETUP 10 ADR BLOCK POINTER
	CLR (R1)		;CLEAR HI ADR

	MOV (R5)+,-(R1)		;SETUP PDP-10 ADDRESS
	MOV (R5),R0		;POINTER TO DATA BLOCK IN R0
	ADD #4,14(SP)		;RETURN OVER TRAILING PARAMETERS
	RTS PC

;START MICROCODE

$SM:	PUSH R0
	MRESET 			;RESET KL10
	CLR R0			;SELECT UCODE START ADR
	WWADR
	DFXCTT 			;GET CLOCK GOING
	  STRCLK

	MOV #2,R1
	MOV #$SMTAB,R0
1$:	PUSH R0
	EXCT 			;DO TEN INSTR
	 BCS 2$
	POP R0
	ADD #5,R0		;NEXT
	DEC R1
	BNE 1$

	POP R0
	EXIT

2$:	POP R0
	POP R0
$SMERR:	EXITERR

$SMTAB:	IO10 CONO,APR,,200000	;IO SYS CLEAR
	IO10 CONO,PI,,10000	;PI SYS CLEAR
	.EVEN

;PDP-10 INSTRUCTION EXECUTE

$XCT:	LODAR
	 BCS 6$
	DFXCTT 			;SET CONTINUE BUTTON
	  CONBUT
	DFXCTT 			;RUN THE CLOCK
	  STRCLK

	TST RPTFLG		;DOING REPEAT ?
	BNE 2$			;YES, NO CHECK

	MOV #1000.,R1
4$:	BIT #HALTLP,@.DIAG1
	BNE 2$
	DEC R1			;NO, WAITED LONG ENOUGH
	BNE 4$
6$:	BR $SMERR

2$:	EXIT

;ECLOK - GIVE A COMPLETE EBOX CLOCK

$ECLOK:	MOV #4000.,R5

91$:	DFSCLK 			;STEP RAW CLOCK
	DFRDT 			;READ CLOCK STATE
	104
	BIT #BIT2,@.DAT3	;CLK E BOX SOURCE HIGH ?
	BNE 92$
	DEC R5
	BNE 91$
	TST RPTFLG
	BNE 92$
	BIS #CBIT,14(SP)	;REPORT TIMEOUT

92$:	DFXCTT
	  CECLK
	EXIT

;PDP-10 CONTROLLED STOP ROUTINE

$TENSP:	PUSH R0
	CLR TENRUN		;CLEAR LOGICAL TEN RUNNING FLAG
;	CLR TENCLK		;CLEAR TEN USING CLOCK FLAG
		;DON'T CLEAR TENCLK BECAUSE MIGHT WANT TO CONTINUE THE SYSTEM

	MOV #DCOMST!DFUNC!<CLRRUN*1000>,@.DIAG1
	JSR PC,$$DFXDN		;CLEAR RUN FLOP

	MOV #1000.,R1
1$:	BIT #HALTLP,@.DIAG1
	BNE 2$			;TEN RETURNED TO HALT LOOP
	DEC R1
	BNE 1$
	BR 5$			;FAILED TO RETURN TO HALT LOOP

2$:	DFRDT
	  131
	BIT #BIT1,@.DAT2	;BIT 18, CON CACHE LOOK
	BEQ 4$			;FALSE, CACHE IS NOT ON

	MOV #$$CF,R0
	EXCT 			;EXECUTE CACHE FLUSH
	  BCS 5$		;FAILED

	MOV #1000.,R1
3$:	DFRDT
	  110
	BIT #BIT2,@.DAT1	;BIT 1, SWEEP BUSY ENABLE
	BEQ 4$			;FINISHED SWEEP
	DEC R1
	BNE 3$
	BR 5$			;FAILED TO FINISH CACHE SWEEP

4$:	POP R0			;SUCESSFUL RETURN
	EXIT

5$:	POP R0			;FAILED RETURN
	EXITERR
