
<PACKAGE "S2NN2S">
;"S2N CONVERTS A STRING TO A NUMBER AND
  N2S CONVERTS A NUMBER TO A STRING. THE
  FUNCTIONS WILL WORK WITH ANY BASE FROM
  2 TO 36 AND WILL DEFAULT TO BASE 10, IF
  NO BASED IS GIVEN"

<ENTRY S2N N2S HEXSTR>

<SETG HEXSTR "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ">
<SETG BMAX <- <LENGTH ,HEXSTR> 0>>
<SETG BMIN 2>
<SETG HEXARRY [ !,HEXSTR ]>
            
<DEFINE N2S (NUM "OPT" (BASE 10) "AUX" STR SGN "ACT" FOO)
	<COND (<L? .BASE 2> 
	       <ERROR BASE-SMALLER-THAN-2!-ERRORS .BASE>)>
	<SET SGN "">
	<SET NUM <FIX .NUM>>
	<SET STR "">
	<COND (<0? .NUM> <RETURN "0" .FOO>)>
	<COND (<L? .NUM 0> <SET SGN "-"> <SET NUM <ABS .NUM>>)>
	<COND (<G? .BASE <LENGTH ,HEXSTR>>
	       <ERROR BSASE-TOO-LARGE!-ERRORS>)>
	<REPEAT (DIG CHR)
	   <COND (<0? .NUM> <RETURN STR>)>
	   <SET DIG <MOD .NUM .BASE>>
	   <SET CHR <NTH ,HEXARRY  <+ .DIG 1> >>
	   <SET STR <STRING .CHR .STR>>
	   <SET NUM <FIX </ .NUM .BASE>>>>
	<STRING .SGN .STR>>

<DEFINE S2N (STR "OPT" (BASE 10)
             "AUX" (NUM 0) (CHR <1 .STR>) (SGN 1) "ACT" TOP )
	<COND (<L? .BASE 2> 
	       <ERROR BASE-SMALLER-THAN-2!-ERRORS .BASE>)>
        <SET STR <REST .STR>>
        <COND (<N=? .CHR !\-> <SET STR <STRING .CHR .STR>>)
              (ELSE <SET SGN -1> )>
        <REPEAT ( )
		<COND (<==? <LENGTH .STR> 0><RETURN T>)>
		<SET CHR <1 .STR>>
		<SET STR <REST .STR>>
		<SET DIG <CHR2DIG .CHR ,HEXSTR>>
                 <COND (<==? .DIG -1> <ERROR INVALID-SYMBOL!-ERRORS>)
		      (<G=? .DIG .BASE> 
		       <ERROR TOO-LARGE-FOR BASE!-ERRORS .DIG>)>
		<SET NUM <+ .DIG <* .NUM .BASE>>> >
        <* .SGN .NUM>>

<DEFINE CHR2DIG (CHR STR "AUX" (IND -1) "ACT" ACT)
        <REPEAT ((I 0) J)
                <SET J <+ .I 1>>
                <COND (<G? .J <LENGTH .STR>> 
                       <ERROR SYMBOL-NOT-FOUND!-ERRORS>)>
                <COND (<==? .CHR <NTH .STR .J>> <RETURN .I .ACT>)>
                <COND (<G=? .I .BASE> <RETURN -1 .ACT>) >
                <SET I <+ .I 1>> > >




<ENDPACKAGE>
