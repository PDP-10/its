;;;-*-Lisp-*-

(declare (load '((alan) lspenv init)))

(defun *make-array (dims opts)
  (do ((opts opts (cddr opts))
       (type t)
       (ival nil)
       (ival-p nil))
      ((null opts)       
       (let ((a (cond ((fixp dims)
		       (*array nil type dims))
		      ((atom dims)
		       (error '|-- bad dimension list to make-array.| dims))
		      (t
		       (lexpr-funcall '*array nil type dims)))))
	 (if ival-p
	     (fillarray a (list ival)))
	 a))
    (caseq (car opts)
      ((type /:type)
       (setq type
	     (caseq (cadr opts)
	       ((art-q t) t)
	       ((art-32b art-16b art-8b art-4b art-2b art-1b fixnum) 'fixnum)
	       ((art-float flonum) 'flonum)
	       ((nil) nil)
	       (t (error '|-- unsupported make-array type.| opts)))))
      ((area /:area named-structure /:named-structure))
      ((initial-value /:initial-value)
       (setq ival (cadr opts))
       (setq ival-p t))
      (t (error '|-- unsupported make-array option.| opts)))))

(defun expand-defsubst (form)
  (let ((def (get (car form) 'defsubst)))
    (do ((vars (car def) (cdr vars))
	 (exprs (cdr form) (cdr exprs))
	 (alist '() (cons (cons (car vars) (car exprs)) alist)))
	((null vars)
	 (unless (null exprs)
	   (error "-- too many arguments." form))
	 (sublis alist (cdr def)))
      (when (null exprs)
	(error "-- too few arguments." form)))))

(defun copyalist (l)
  (do ((l l (cdr l))
       (a nil (cons (if (atom (car l))
			(car l)
			(cons (caar l) (cdar l)))
		    a)))
      ((atom l) (nreconc a l))))

(defun copytree (l)
  (do ((l l (cdr l))
       (a nil (cons (copytree (car l)) a)))
      ((atom l) (nreconc a l))))

(defun *rem (pred item list n)
  (declare (fixnum n))
  (do ((list list (cdr list))
       (l nil))
      ((or (null list)
	   (not (plusp n)))
       (nreconc l list))
    (cond ((funcall pred item (car list))
	   (setq n (1- n)))
	  (t
	   (setq l (cons (car list) l))))))

(defun *del (pred item list n)
  (declare (fixnum n))
  (do ((l list)
       (last nil))
      ((or (null l)
	   (not (plusp n)))
       list)
    (cond ((funcall pred item (car l))
	   (setq n (1- n))
	   (setq l (cdr l))
	   (cond ((null last)
		  (setq list l))
		 (t (rplacd last l))))
	  (t (setq last l)
	     (setq l (cdr l))))))

(defun ass (pred item list)
  (do ((list list (cdr list)))
      ((null list) nil)
    (and (funcall pred item (caar list))
	 (return (car list)))))

(defun mem (pred item list)
  (do ((list list (cdr list)))
      ((null list) nil)
    (and (funcall pred item (car list))
	 (return list))))

(defun listp (x)
  (or (not (atom x))
      (null x)))

(defun ferror n
  (ferror-cerror-hack nil nil (arg 1) (listify (- 1 n))))

(args 'ferror '(1 . 776))

(defun cerror n
  (ferror-cerror-hack (arg 1) (arg 2) (arg 3) (listify (- 3 n))))

(args 'cerror '(4 . 776))

(defun ferror-cerror-hack
		(proceedable restartable format-string-or-nil format-args)
  (format msgfiles "~2&Error: ")
  (if (null format-string-or-nil)
      (lexpr-funcall #'format msgfiles format-args)
      (lexpr-funcall #'format msgfiles format-string-or-nil format-args))
  (or (null *rset)
      (let ((bl (cdddr (baklist)))
	    (prinlevel 2))
	(cond ((not (null bl))
	       (format msgfiles "~&While in the function ~S"
		       (caar bl))
	       (do ((i 0 (1+ i))
		    (bl (cdr bl) (cdr bl)))
		   ((or (null bl)
			(= i 3)))
		 (declare (fixnum i))
		 (format msgfiles " <- ~S" (caar bl)))))))
  (cond (proceedable (format msgfiles "~&(proceedable)"))
	(restartable (format msgfiles "~&(restartable)")))
  (terpri msgfiles)
  (let ((v (break error)))
    (cond (proceedable v)
	  (restartable (*throw 'error-restart v))
	  (t (error "Can't proceed or restart.")))))

(defun get-macro-definition (sym)
  (let ((p (or (getl sym '(macro subr lsubr expr
			   fsubr fexpr array))
	       (let ((f (get sym 'autoload)))
		 (cond ((null f) nil)
		       (t
			(load f)
			(or (getl sym '(macro subr lsubr expr
					fsubr fexpr array))
			    (ferror "Autoloading failed to define: ~S"
				    sym))))))))
    (if (eq (car p) 'macro)
	(cadr p)
	nil)))

(defun macroexpand (form)
  (do ()
      ((or (atom form)
	   (not (symbolp (car form))))
       form)
    (let ((f (get-macro-definition (car form))))
      (when (null f)
	(return form))
      (setq form (funcall f form)))))

(defun macroexpand-1 (form)
  (if (or (atom form)
	  (not (symbolp (car form))))
      form
      (let ((f (get-macro-definition (car form))))
	(if (null f)
	    form
	    (funcall f form)))))

(defun mexp ()
  (or (get 'gprint1 'lsubr)
      (load '((liblsp) gprint fasl)))
  (terpri)
  (princ '|>|)
  (do ((x (read) (read)))
      ((eq x t))
    (do ()
	((or (atom x)
	     (not (symbolp (car x)))))
      (let ((f (get-macro-definition (car x))))
	(when (null f)
	  (return nil))
	(terpri)
	(princ '|==> |)
	(gprint1 (setq x (funcall f x)) nil nil nil nil nil nil)))
    (terpri)
    (princ '|>|))
  'done)

(defun r-p () (do x '(r-p) (read) (eq x t) (print x) (terpri)) 'done)

(defun xcar (x) (car x))
(defun xrplaca (x v) (rplaca x v))
(defun xcdr (x) (cdr x))
(defun xrplacd (x v) (rplacd x v))
(defun xcxr (n x) (cxr n x))
(defun xrplacx (n x v) (rplacx n x v))
(defun vcell (sym) (cdar sym))
(defun pname (sym) (cxr 2 (car sym)))

(sstatus feature alan/;lspint)
