.TITLE	TECOIO
.SBTTL	GLOBALS, MACROS, DEFINITIONS

.CSECT	TECOIO

.GLOBL	CLSFIL,	CURFRE,	DATE,	DOCCL,	EOFLAG,	GETBUF,	GETFLS
.GLOBL	INPSAV,	LISTEN,	NI,	NO,	NWATCH,	NOCTLO
.GLOBL	P,	PDL,	PRINT,	PUTBUF,	QMAX,	QRSTOR,	QZ
.GLOBL	RWSIZE,	SCHBUF,	SCHSIZ,	SIZER,	SWITCH,	TECO,	TECOPD
.GLOBL	TECOSP,	TEXIT,	TIME,	TXSTOR,	TYPE,	XITNOW
.GLOBL	ZMAX,	ZZ,	.VVV.V
.GLOBL	DOCCL,	TECOCH
.GLOBL	DSPLAY,	ECHO,	TYO,	DERFLG,	CMDFLG,	TOPDIS,	TTINIT
;THIS IS ALL THE NEW STUFF

.MCALL	.CLOSE,	.CSISPC,.DATE,	.DSTAT,	.ENTER,	.EXIT,	.FETCH
.MCALL	.LOCK,	.LOOKU,	.PRINT,	.RCTRLO,.READ,	.RELEAS,.RENAME
.MCALL	.REOPEN,.SAVEST,.SETTOP,.SRESET,.TTINR,	.TTYIN,	.TTYOUT
.MCALL	.UNLOCK,.WRITE,	.WAIT


.MACRO	ERROR	R50COD,TEXT
	.CSECT	$TIOER
$$$=.
	.RAD50	/R50COD/
	.ASCIZ	TEXT
	.EVEN
	.CSECT	TECOIO
	JSR	R5,ERR
	.WORD	$$$
.ENDM	ERROR

.MACRO	ERROR1	R50COD,TEXT
	.CSECT	$TIOER
$$$=.
	.RAD50	/R50COD/
	.ASCIZ	TEXT
	.EVEN
	.CSECT	TECOIO
	MOV	#$$$,R2
	MOV	(R2)+,R0
	SEC
	RETURN
.ENDM	ERROR1

	.SBTTL MACROS FOR GENERATING CODE

;MACRO TO PUSH THINGS ONTO THE STACK
.MACRO SAVE THINGS
.IRP X,<THINGS>
	MOV X,-(SP)
.ENDM
.ENDM

;MACRO TO POP THINGS FROM STACK
.MACRO REST THINGS
.IRP X,<THINGS>
	MOV (SP)+,X
.ENDM
.ENDM


; GLOBAL ERROR CODES
NI	== 54171	;RAD 50 OF NFI
NO	== 54177	;RAD 50 OF NFO

; RT-11 PARAMETERS
PGMTOP	== 50	;POINTER TO TOP OF LOADED PROGRAM
RMON	== 54	;POINTER TO START OF RMON
USRBUF	== 266	;OFFSET INTO RMON OF USR START
STACK	== 42	;START OF USER STACK
USTART	== 40	;START ADDRESS OF PROGRAM
JSW	== 44	;JOB STATUS WORD
TTYUSR	== 10000	;TELETYPE I/O IN USER MODE
REENTR	== 20000	;PROGRAM IS REENTERABLE

; TECO SIZE PARAMETERS
SCHSIZ	== 100	;SIZE OF SEARCH BUFFER
SIZEPD	== 100	;PUSH DOWN SIZE

; VARIOUS ASCII CHARACTERS
BELL	= 7
TAB	= 11
LF	= 12
FF	= 14
CR	= 15
RIGHT	= 30	;USED BY DISPLAY
LEFT	= 31	;GUESS WHAT?
UP	= 32	;UP 1 LINE (USED BY DISPLAY)
ALTMOD	= 33
BOT	= 34	;BOTTOM OF SCREEN
TOP	= 35	;TOP OF SCREEN
ERLINE	= 36	;ERASE LINE
ERSCRN	= 37	;ERASE SCREEN
SPACE	= 40
RUBOUT	= 177
.SBTTL	CORE ORGANIZATION

;THE CORE OBTAINED BY TECOIO AND GIVEN TO TECO IS
;	ORGANIZED AS FOLLOWS:
;
;	*********************************
;	*				*
;	*	READ/WRITE AREA		*
;	*	SIZE = RWSIZE		*
;	*				*
;	*	CLEARED BY TECOIO	*
;	*				*
;	*********************************
;	*				*
;	*	PUSH DOWN LIST		*
;	*	POINTED TO BY TECOPD	*
;	*	SIZE = SIZEPD (GLOBAL)	*
;	*				*
;	*********************************
;	*				*
;	*	SEARCH BUFFER		*
;	*	POINTED TO BY SCHBUF	*
;	*	SIZE = SCHSIZ (GLOBAL)	*
;	*				*
;	*********************************
;	*				*
;	*	TEXT STORAGE AREA	*
;	*	POINTED TO BY TXSTOR	*
;	*	SIZE IN ZMAX(RW AREA)	*
;	*				*
;	*********************************
;	*				*
;	*	Q-REGISTER STORAGE	*
;	*	POINTED TO BY QRSTOR	*
;	*	SIZE IN QMAX(RW AREA)	*
;	*				*
;	*********************************
;	*				*
;	*	FREE STORAGE		*
;	*	SIZE IN CURFRE 		*
;	*	NO POINTER		*
;	*				*
;	*********************************
;
; ALL POINTERS IN TECOIO ARE RELATIVE TO THE BEGINNING OF
;	THE IMPURE AREA, WHICH IS POINTED TO BY FREEST IN TECOIO.
; THE TEXT STORAGE AREA AND Q-REGISTER STORAGE AREAS
;	ALSO HAVE AN ASSOCIATED WORD IN THE R/W AREA TELLING HOW
;	MUCH OF THE ALLOCATED STORAGE IS IN USE.
;	THE POINTERS ARE ARRANGED AS:
;		TXSTOR, ZZ, ZMAX
;	AND	QRSTOR, QZ, QMAX


.SBTTL	SAVE, RESTORE, ERROR

.ENABL	LSB

SAVREG:	MOV	E,-(SP)
	MOV	D,-(SP)
	MOV	C,-(SP)
	MOV	B,-(SP)
	MOV	SP,SPSAVE	;SAVE FOR ERROR RETURN
	MOV	A,-(SP)
	MOV	F,-(SP)	;RETURN ADDRESS
	MOV	6*2(SP),F
	CLR	LOCKFL		;SAY USR NOT LOCKED IN YET
	JSR PC,	@(SP)+		;EXCHANGE HIM FOR US

	INC	LOCKFL		;WAS USR LOCKED IN?
	BNE	1$		;NO IF NON-0
	.UNLOCK			;FREE USR IF LOCKED IN
1$:	CLC			;SAY NORMAL RETURN
	MOV	(SP)+,A
2$:	MOV	(SP)+,B
	MOV	(SP)+,C
	MOV	(SP)+,D
	MOV	(SP)+,E
	MOV	(SP)+,F
	RTS PC

ERR:	INC	LOCKFL		;WAS USR LOCKED IN?
	BNE	3$		;NO IF NON-0
	.UNLOCK			;ERRORS FREE USR, TOO
3$:	SEC			;TELL TECO THINGS ARE NO GOOD
	MOV	(R5)+,B		;POINT TO RAD50 CODE
	MOV	(B)+,A		;GET CODE IN R0, POINTER IN B
	MOV	SPSAVE,SP	;RESTORE STACK
	MOV	B,2(SP)	;POINTER IS RETURNED IN R2
	BR	2$		;AND EXIT

.DSABL	LSB

;LISTEN FOR CHARACTER, RETURNED IN D
LISTEN:	BIS #TTYUSR,@#JSW		;THIS WILL GO AWAY IN SITS
	JSR PC,TIOQ		;GET THE CHARACTER
	BEQ .-4			;NOT THERE YET
	MOV D,A		;MAKE THINGS COMPATIBLE
	JMP ECHO


;DISPLAY PARAMETERS
TOPMAR=7		;# OF LINES CURSOR IS (INITIALLY) FROM TOP OF SCREEN
BOTMAR=3		;# OF LINES -1 FROM BOTTOM OF SCREEN FOR COMMAND INPUT
VSPACE=20		;AMOUNT OF LINES ALLOWED ON SCREEN
HSPACE==70		;HORIZONTAL SCREEN SPACE
DISPTR: 0		;DISPLAY POINTER (STARTING LINE OF CURRENT DISPLAY)
CMDPTR: .WORD 0,0		;POINTER TO COMMAND INPUT
CURPTR: .WORD 0,0		;POINTER TO CURSOR
CMDFLG:	0		;IF 0 => NO INITIALIZATION OF COMMAND DISPLAY NEEDED
DERFLG:	0		;SET WHEN AN ERROR HAS BEEN PRINTED TO PROTECT TOP LINE OF SCREEN
MSG1:	.ASCII	/TECO/
MSG2:	.ASCII /--MORE--/
MSG3:	.ASCII /FLUSHED/
MSG4:	.ASCII /SITS CONSOLE FREE/


;CONTROLLER FOR DISPLAY SCREEN
DSPLAY:	JSR PC,ACSAV		;SAVE REGISTERS
	MOV TOPMAR,C		;PTR IS THIS MANY LINES FROM TOP OF SCREEN
	MOV P(F),B		;CURRENT TEXT POINTER (WILL CHANGE)
	MOV B,E			;COPY IT
	ADD TXSTOR(F),B		;MAKE POINTER ABSOLUTE
	MOV B,F			;AND SAVE IT
	MOV ZZ(F),D		;LENGTH OF BUFFER CURRENTLY IN USE
	ADD TXSTOR(F),D		;MAKE AN ABSOLUTE POINTER TO END
	SAVE D			;KEEP IT ON TOP OF THE STACK
	TST E			;IS POINTER AT TOP OF PAGE?
	BEQ DSPLA5		;PTR IS AT TOP OF PAGE
DSPLA1:	CMPB -(B),LF		;START COUNT BACK <TOPMAR> # OF LINEFEEDS FROM CURSOR
	BEQ DSPLA2		;FOUND ONE
	CMP B,F			;BACK TO THE START YET?
	BNE DSPLA1		;NOT YET
	MOV DISPTR,B		;YES, MARK THIS POINT AS START OF DISPLAY
	BR DSPLA5		;AND GO DISPLAY
DSPLA2:	SOB C,DSPLA1		;ONE LESS LINE
	TST (B)+		;CORRECT PTR, NOW WE'RE AT THE RIGHT PLACE
DSPLA5:	MOV #35,D		;THIS PUTS US AT THE TOP OF THE PAGE
	JSR PC,TYO		;PRINT IT
	MOV VSPACE,C		;# OF LINES ALLOWED ON THE SCREEN
	TEST DERFLG		;WAS THERE AN ERROR PRINTED LAST TIME?
	BEQ DSPLA3		;NO, NORMAL DISPLAY
	MOV #LF,D		;YES, SAVE TOP LINE OF DISPLAY
	JSR PC,TYO		;START ONE LINE FROM TOP
	CLR DERFLG		;NEXT DISPLAY IS NORMAL
DSPLA3:	CMP B,F			;HAVE WE REACHED THE CURSOR?
	BNE DSPLA4		;NOPE
	MOV '/,D		;YES, DISPLAY IT
	JSR PC,TYO
	MOV '\,D
	JSR PC,TYO
DSPLA4:	MOV (B)+,D		;GET NEXT CHARACTER TO PRINT
	JSR PC,TYO		;OUTPUT THE CHARACTER
	CMP B,SP		;ARE WE AT END OF TEXT?
	BEQ DSPRET		;THEN DONE FOR NOW
	CMP D,LF		;WAS IT A LINEFEED?
	BNE DSPLA3		;NOPE, GO AHEAD
	SOB C,DSPLA3		;YES, THAT MEANS ONE LESS LINE OF SPACE
	MOV #8,E		;# OF ARGS FOR PRINT
	MOV #MSG2,D		;REACHED THE END OF THE SCREEN, PRINT OUT "--MORE--"
	JSR PC,PRINT
	JSR PC,LISTEN		;WAIT FOR REPLY
	CMP D,SPACE		;DOES HE WANT MORE?
	BEQ DSPLA5		;YES, GIVE HIM WHAT HE WANTS
DSPLA6:	MOV #7,E		;ARGS FOR PRINT
	MOV #MSG3,D		;PRINT OUT "FLUSHED"
	JSR PC,PRINT
;HERE, SET UP FOR COMMAND MODE (PROBABLY SHOULD SET FLAG)
;OR, WE COULD JUST FALL RIGHT IN
DSPCM4:	MOV #BOT,D		;GET TO BOTTOM OF SCREEN
	JSR PC,TYO
	MOV CMDPTR,B		;GET POSITION WHERE WE LEFT OFF
	MOV (B)+,C		;THIS MANY LINES FROM BOTTOM
	BEQ DSPCM1		;WE'RE ALREADY THERE
	MOV #UP,D		;MOVE US UP
	JSR PC,DSPCM3		;THIS PRINTS THE CHARACTER C TIMES
DSPCM1:	MOV (B),C		;THIS MANY CHARACTERS FROM EDGE OF SCREEN
	BEQ DSPCM2		;THERE AGAIN
	MOV #RIGHT,D		;PUT US THERE
	JSR PC,DSPCM3
;DO ANY NECSSARY THINGS BEFORE LEAVING
DSPCM2:	TST (SP)+		;GET RID OF CRUD ON TOP OF STACK
	JSR PC,ACRES
	RTS PC
DSPCM3:	JSR PC,TYO
	SOB C,DSPCM3
	RTS PC
DSPCMD:	JSR PC,ACSAV	;THIS IS CALLED FROM MAIN TECO LOOP
	BR DSPCM4
DSPRET:	MOV #-1, CMDFLG		;DONE WITH DISPLAY, THIS CAUSES COMMAND ECHO TO INIT ITSELF
	BR DSPCM2


;THIS ROUTINE ECHOES COMMAND INPUT ON SCREEN.
;IT IS ESSENTIALLY A SOPHISTICATED TYO
ECHO:	MOV A,D		;HAVE TO BE COMPATIBLE
	MOV CMDPTR,B		;KEEP TRACK OF WHERE WE ARE
	TST CMDFLG		;SHOULD WE INITIALIZE FIRST?
	BEQ ECHO3		;NOPE,ALREADY DONE
	JSR PC,DSPCMD		;YES, THIS DOES THE WORK
	CLR CMDFLG		;WON'T HAVE TO BE DONE AGAIN
ECHO3:	JSR PC,TYO
	CMP D,#LF		;WAS THAT A LINEFEED?
	BEQ ECHO1		;YES
	MOV CHARNO,2(B)		;SET POSITION FOM EDGE OF SCREEN
	RTS PC
ECHO1:	DEC (B)			;ONE LINE CLOSER TO BOTTOM OF SCREEN
	BGE ECHO2		;WE'RE STILL ON IT
	MOV #BOTMAR,C		;WE FELL OFF THE BOTTOM
	MOV #UP,D		;GET BACK TO THE  TOP
	JSR PC,DSPCM3
ECHO2:	CLR 2(B)		;STARTING AT EDGE AGAIN
	MOV #ERLINE,D		;CLEAR OUT OLD STUFF
	JSR PC,TYO
	MOV D,A		;ONCE AGAIN
	RTS PC			;DONE, GO GET NEXT CHARACTER

TOPDIS:	MOV #TOP,D		;GET TO TOP OF SCREEN
	JSR PC,TYO
	TST DERFLG		;DO WE HAVE A PENDING ERROR?
	BNE .+4		;YES, INDEED
1$:	RTS PC			;ALL DONE
	MOV #ERLINE,D		;MAKE ROOM FOR IT
	JSR PC,TYO
	BR 1$

TTINIT:	BIC #TILIPM!TIMAGO!TIMAGI!TOTRAN,TTYST
	BIS #TICVM!TIECM,TTYST
	RTS PC
.SBTTL	PRINT STRING, TEXIT, NOCTLO, TIME, DATE, SWITCH
;EXPECTS POINTER TO STRING IN D, LENGTH OF STRING IN E

PRINT:	TST D			;IS THERE A STRING THERE?
	BEQ 3$			;NOPE, THAT WAS EASY
1$:	MOVB	(D)+,D
	JSR PC,TYO		;OUTPUT THE CHARACTER
	SOB E,1$		;THIS MANY CHARACTERS
3$:	RTS PC


TEXIT:				;EXIT FROM TECO
	MOV #TOP,D
	JSR PC,TYO
	MOV #ERSCRN,D		;ERASE SCREEN
	JSR PC,TYO		;CLEAR THE SCREEN
	MOV #MSG4,D		;FAREWELL MESSAGE
	MOV #17,E		;THIS LONG
	JSR PC, PRINT		;PRINT IT
	MOV	SP,A		;SOFT EXIT
	.EXIT

XITNOW:	BIC	#TTYUSR,@#JSW	;TURN OFF SPECIAL MODE BIT
NOCTLO:	.RCTRLO
	RTS PC

DATE:	.DATE
	RTS PC

TIME:	CLR	A		;SORRY, WE HAVE NO TIME
	RTS PC

SWITCH:	MOV	@#177570,A
	RTS PC

.SBTTL	SIZER SWAPS THE USR TO GET MORE CORE

SIZER:	MOV	A,-(SP)	;SAVE A FOR TECO
	MOV	@#RMON,A	;POINT TO THE RESIDENT
	TST	-(A)		;FIX FOR FUNNY SETTOP
	SUB	@#PGMTOP,A	;SUBTRACT OFF OUR CURRENT TOP
	CMP	A,B		;CAN WE GET HIM WHAT HE WANTS?
	BLO	1$		;HE LOSES
	ADD	A,CURFRE(F)	;YES. GIVE HIM WHAT WE CAN
	ADD	@#PGMTOP,A	;FIX FOR A SETTOP
	.SETTOP			;TELL THE MONITOR WE'RE SWAPPING
	.RCTRLO			;TELL THE USER
	.PRINT	#MESSAG
	CLC			;AND BE SUCCESSFUL
1$:	MOV	(SP)+,A	;RESTORE A
	RTS	PC
.SBTTL	GETFLS - ENTRY FOR ER, EW, AND EB

FNEB:	JMP	FNERR		;OUT OF BRANCH RANGE
GETFLS:	JSR	F,SAVREG	;CAREFUL WITH THESE
	MOV	E,C		;MOVE LENGTH TO WHERE WE WANT IT
	MOV	#FILSPC,D	;COPY FILE SPEC BEFORE LOCKING USR
	CMP	C,#23		;IS THE STRING TOO LONG?
	BHI	FNEB		; YES, BOOT HIM
1$:	MOVB	(A)+,(D)+	;MOVE A BYTE
	DEC	C		;COUNT DOWN
	BGT	1$		; TO 0 (-1 IF ORIGINALLY 0)
	MOVB	#'<,(D)+	;PUT IN TERMINATOR
	CLRB	(D)+		;AND  END IT
	.LOCK			;KEEP THE USR HANDY
	DEC	LOCKFL		;AND FORCE US TO UNLOCK HIM LATER
	TST	B		;WHAT ARE WE DOING?
	BEQ	EREAD
	BPL	EWRITE

; EDIT BACKUP:
;	CLOSE ANY EXISTING OUTPUT FILE (AND FIX EB)
;	DO AN EDIT READ
;	FUDGE THE NAME, AND FALL THROUGH TO AN EDIT WRITE

	CALL	FLUSH		;CLOSE OUTPUT FILE, IF ANY
	CALL	EREAD		;START AN INPUT FILE
	MOV	#INBLK+12,A	;PREPARE TO COPY OUTPUT NAME
	MOV	#OUTBLK+12,F	;  AND SET UP POINTER, TOO
	MOV	-(A),-(F)
	MOV	-(A),-(F)
	MOV	-(A),-(F)
	MOV	-(A),-(F)
	MOV	-(A),-(F)
	MOV	SP,EBFLG	;MARK EB IN PROGRESS
	BR	EWRIT1		;AND ENTER THE OUTPUT FILE
.SBTTL	EDIT WRITE

; EDIT WRITE:
;	IF AN OUTPUT FILE IS OPEN, CLOSE IT (AND FIX EB)
;	SCAN THE FILE NAME
;	CLEAR THE OUTPUT BUFFERS

EWRITE:	TST	EBFLG		;WE CAN'T DO THIS IF EB-ING
	BNE	EBERR		;SO CLOBBER HIM
	CALL	FLUSH		;YES, CLOSE IT
				;NOTE THAT FLUSH SETS F TO OUTBLK
	CALL	FNGET		;GET THE FILE NAME SCANNED, HANDLERS
EWRIT1:	.ENTER	13,F,FILENG	;ENTER THE FILE
	BCS	DEVFUL		;AN ERROR IS DEVICE FULL
	MOV	#OUTFNM,B	;POINT TO AREA FOR SAVED NAME
	MOV	#FILSPC,A	;POINT TO INPUT NAME
1$:	MOVB	(A)+,E	;GET A BYTE
	MOVB	E,(B)+	;SAVE IT
	CMPB	#'0,E		;CHECK FOR ALPHA, NUMBER, OR :
	BHI	2$
	CMPB	#':,E
	BHIS	1$
	CMPB	#'A,E
	BHI	2$
	CMPB	#'Z,E
	BHIS	1$
2$:	CLRB	-(B)
	MOV	#OBUF1+512.,-(F) ;POINT TO FIRST BUFFER TOP
	MOV	#OBUF1,-(F)	;POINT TO DATA START
	CLR	-(F)		;START WITH BLOCK 0
	RETURN			;RETURN (WHAT A COMMENT!)
DEVFUL:	ERROR	FUL,<"DEVICE FULL">
EBERR:	ERROR	EBK,<"EDIT BACKUP STILL OPEN">
.SBTTL	EDIT READ, READ NEXT BLOCK

; EDIT READ:
;	FIX UP ANY EB FILES
;	RELEASE INPUT HANDLER
;	SCAN FILE NAME, GET HANDLER
;	LOOKUP FILE, PRIME ONE BLOCK, BEGIN READ OF NEXT

EREAD:	MOV	#IBUF1+512.,E	;WE WILL BE NEEDING PTR TO BUFFER TOP
	TST	C		;IS FILE NAME NULL?
	BGE	1$		;NO, DO AN EDIT READ
	MOV	#SSINFO,D	;YES, DO A REOPEN
	TST	@D		;IS THERE A SAVED FILE?
	BEQ	NOFSAV		;NO, ERROR
	MOV	#INBLK,F	;POINT TO INPUT BLOCK
	.CLOSE	12		;GET RID OF OLD INPUT FILE
	CALL	RELEAS		;GET RID OF OLD HANDLER
	MOV	(D)+,@F	;PUT BACK DEVICE NAME
	CALL	FETCH		;MAKE SURE HANDLER IS IN
	MOV	E,-(F)	;SET TOP-OF-BUFFER
	MOV	(D)+,-(F)	;SET BUFFER OFFSET
	ADD	E,@F		;MAKE ABSOLUTE BUFFER POINTER
	MOV	(D)+,-(F)	;RESTORE BLOCK NUMBER
	MOV	(D)+,-(F)	; AND EOF FLAGS
	.REOPEN	12,D		;REOPEN THE FILE
	BR	2$		;AND REPRIME BUFFERS

1$:	MOV	#IBTOP,F	;POINT TO FLAG WORD
	CLR	(F)+		;AND SAY WE HAVE NO INPUT
	.CLOSE	12		;  AND CLOSE US IF HE DIDN'T
	CALL	RELEAS		;DUMP THE HANDLER
	CALL	FNGET		;SCAN THE NAME
	.LOOKUP	12,F		;AND FIND THE FILE
	BCS	EINOFL		;IT WEREN'T THERE
	MOV	#IBUF1+512.,E	;POINT TO THE FIRST BUFFER TOP
	MOV	E,-(F)	;SAVE IT AS BUFFER PTR
	MOV	@E,-(F)	;SAVE BUFFER PTR
	CLR	-(F)		;START AT BLOCK #0
	MOV	#-1,-(F)	;NO EOF YET!
2$:	MOV	FREEST,A	;SET TECO'S EOF FLAG
	CLR	EOFLAG(A)	; IN HIS AREA
	CALL	BREAD		;GET A BLOCK IN CORE
;				;BREAD RETURNS POINTER TO OTHER TOP
;	CALL	BREAD		;FALL INTO READ ROUTINE

;BUFFER READ: READS NEXT BLOCK INTO DESIGNATED AREA

BREAD:	TST	EFFLG		;ARE WE SWITCHED TO EOF BUFFER?
	BGT	1$		;YES, BOOT HIM
	.WAIT	12
	BCS	1$		;DID WE GET AN ERROR?
;				;@E IS BOTTOM PTR, 2(E) IS NEXT TOP
	.READ	12,(E)+,#400,IBLKNM	;READ A LOAD
	MOV	@E,E		;RETURN POINTER TO NEXT TOP
	INC	IBLKNM		;BUMP BLOCK NUMBER
	BCC	1$		;CARRY IS INPUT ERROR OR EOF
	TSTB	@#52		;WHAT KIND OF ERROR?
	BNE	INERR		;HARDWARE
	INC	EFFLG		;EOF, SOFT ERROR
1$:	RETURN
EINOFL:	ERROR	FNF,<'FILE "'<-2>'" NOT FOUND'>
INERR:	ERROR	INP,<"INPUT ERROR">
NOFSAV:	ERROR	NFS,<"NO FILE SAVED">
.SBTTL	CLOSE FILE, FLUSH OUTPUT BUFFER

;END FILE
;	DO ANY EB CLOSING NEEDED
;	RELEASE HANDLER FOR OUTPUT, CLEAR FLAG

CLSFIL:	TST	OBTOP		;IS AN OUTPUT FILE OPEN?
	BEQ	NOOFIL		;ERROR IF NOT
	JSR	F,SAVREG
	.LOCK			;HOLD TIGHT TO USR
	DEC	LOCKFL		;BUT TELL US WHEN TO GIVE HIM UP
;	BR	FLUSH		;FLUSH BUFFER, CLOSE FILE

;FLUSH:
;	IF OUTPUT BUFFER HAS DATA IN IT, IT IS PADDED WITH ZEROS
;	  AND WRITTEN OUT
;	WAIT FOR IO TO QUIESCE
;	CLOSE FILE, DO EB RENAME IF NEEDED

FLUSH:	MOV	#OBPTR,F	;POINT TO BUFFER POINTERS
	MOV	(F)+,E	;E -> NEXT BYTE IN BUFFER
	MOV	(F)+,A	;A -> TOP OF BUFFER
	BEQ	ERTN		;RETURN IF NO FILE OPEN
	CMP	E,@A		;IF THE BUFFER IS EMPTY
	BEQ	3$		;   DO NOT WRITE IT
	BR	2$		;ENTER FILL LOOP
1$:	CLRB	(E)+
2$:	CMP	E,A		;FULL TO TOP?
	BNE	1$
	CALL	BWRITE		;WRITE IT OUT
3$:	.WAIT	13		;QUIET DOWN
	BCS	OUTERR
	TST	EBFLG		;WERE WE IN EB?
	BEQ	OUTCLS		;  IF NOT, JUST CLOSE OUTPUT

	.CLOSE	12		;CLOSE INPUT FILE
	MOV	#OUTBLK+16,B	;POINT TO NEWNAME AREA
	MOV	#OUTBLK+6,A	;POINT TO OLD INPUT NAME
	MOV	(PC)+,@B	;SET NEW EXTENSION TO BAK
	 .RAD50	/BAK/
	MOV	-(A),-(B)	;PUT IN REST OF NEW NAME
	MOV	-(A),-(B)
	MOV	-(A),-(B)
	.RENAME	14
	CLR	IBTOP		;SWITCH OFF INPUT FILE
	CLR	EBFLG		;NO LONGER IN EB
OUTCLS:	.CLOSE	13		;CLOSE THE OUTPUT FILE
	CLR	OBTOP		;SWITCH OFF OUTPUT FILE
;	BR	RELEAS		;DUMP HANDLER AND RETURN
.SBTTL	RELEASE DEVICE HANDLER

;RELEASE RELEASES A HANDLER FROM ITS AREA
;NOTHING IS DONE IF BOTH INPUT + OUTPUT NEED IT

RELEAS:	MOV	#SCRACH,B	;SOME WORKING AREA
	.DSTATU	B,#INBLK	;GET STATUS OF INPUT DEVICE
	MOV	@B,-(SP)	;HOLD IT
	CLR	@B
	.DSTATU	B,#OUTBLK	;AND OF OUTPUT DEVICE
	CMP	@B,(SP)+	;SAME?
	BEQ	ERTN
	CMP	@F,HAND1	;DOES AREA 1 HAVE THE HANDLER?
	BNE	1$		;NO, TRY AGAIN
	CLR	HAND1		;MARK IT NON-RESIDENT
	BR	2$		;AND GO TO FREE IT
1$:	CMP	@F,HAND2	;DOES AREA 2 HAVE IT?
	BNE	ERTN		;NO, IT WAS RESIDENT
	CLR	HAND2
2$:	.RELEAS	F		;PURGE IT
ERTN:	RETURN

OUTERR:	ERROR	OUT,<"OUTPUT ERROR">
.SBTTL	BWRITE - WRITE BLOCK TO OUTPUT FILE

BWRITE:	.WAIT	13		;WAIT FOR PREVIOUS OP TO FINISH
	BCS	OUTERR		;MAKE SURE IT WAS GOOD
	.WRITE	13,(E)+,#400,OBLKNM
	MOV	@E,E		;SET POINTER TO NEXT TOP
	BCS	OUTERR		;IF CARRY, ERROR
	INC	OBLKNM		;ELSE ADVANCE OUTPUT BLOCK NUMBER
	RETURN
.SBTTL	FNGET AND FETCH - CALL CSI, FETCH HANDLER

;FNGET SCANS OFF THE FILE NAME INTO THE BUFFER AREA
;ASSOCIATED WITH THE BLOCK IN F.
;IT THEN CALLS THE CSI, AND FETCHES A HANDLER

FNGET:	TST	C		;WAS NAME NULL?
	BMI	FNERR		;YES, THAT'S A NO-NO
	.CSISPC	F,#DEFEXT,#FILSPC
	BCS	FNERR		;ERROR IN NAME
	TST	(SP)+		;NO SWITCHES ARE VALID!
	BNE	FNERR

FETCH:	MOV	#HAND1,B	;POINT TO FIRST HANDLER AREA
	TST	(B)+		;IS IT FREE?
	BEQ	1$
	MOV	#HAND2+2,B	;IF NOT, USE OTHER AREA
1$:	.FETCH	B,F		;GET THE HANDLER
	BCS	DEVERR		;SOME KIND OF ERROR
	CMP	A,B		;WAS IT ALREADY HERE?
	BEQ	2$		;IF SO, AREA IS STILL FREE
	MOV	@F,-(B)	;SAVE NAME OF DEVICE
2$:	RTS	PC
FNERR:	ERROR	IFN,<'FILE NAME "'<-2>'" INVALID'>
DEVERR:	ERROR	DEV,<'INVALID DEVICE "'<-2>'"'>
NOOFIL:	ERROB	NFO,<"NO OUTPUT FILE">
.SBTTL	INPSAV - SAVE INPUT FILE STATUS

INPSAV:	TST	IBTOP		;IS THERE A FILE OPEN?
	BEQ	NOIFIL		;NO, GIVE AN ERROR
	JSR	F,SAVREG	;SAVE REGISTERS
	MOV	#SSBLOK,D	;POINT TO SAVED STATUS
	.SAVES	12,D		;AND SAVE IT
	MOV	#EFFLG,F	;POINT TO OTHER STUFF TO SAVE
	MOV	(F)+,-(D)	;EOF FLAGS
	MOV	(F)+,-(D)	;BLOCK NUMBER
	SUB	#2,@D		;(WHICH WAS 2 TOO HIGH)
	MOV	(F)+,-(D)	;BUFFER POINTER
	SUB	@F,@D		;WHICH WE MAKE INTO BUFFER OFFSET
	CLR	(F)+		;AND MARK INPUT FILE NOT THERE
	MOV	@F,-(D)	;FINALLY, DEVICE NAME
	BR	RELEAS		;NOW, GO GET RID OF HANDLER
.SBTTL	GETBUF - READ A TECO BUFFER LOAD

;GETBUF:
;	READS BUFFER LOAD, AS PER TECO'S DESIRES

GETBUF:	TST	IBTOP		;IS A FILE OPEN?
	BEQ	NOIFIL		;NO, RETURN AN ERROR
	TST	EOFLAG(F)	;ARE WE AT END-OF-FILE?
	BNE	51$		;YES, SAY SO
	TST	EFFLG		;ARE WE ABOUT TO BE AT EOF?
	BGT	50$		;YES, RETURN INDICATION
	JSR	F,SAVREG	;SAVE EVERYTHING
	MOV	A,C		;HOLD ON TO DESTINATION POINTER
	CLR	6(SP)		;CLEAR RETURNED C FORM FEED FLAG
	TST	B		;DID THE FOOL WANT US TO READ 0?
	BEQ	4$		;  WELL, THAT'S EASY
	MOV	A,-(SP)	;SAVE START FOR LENGTH COMPUTE
	MOV	#IBPTR,D	;GET POINTERS
	MOV	(D)+,F	;F -> BUFFER
	MOV	@D,E		;E -> TOP
1$:	CMP	E,F		;IS THE BUFFER EMPTY
	BLOS	10$		;  IF SO, GO FILL IT
	MOVB	(F)+,A	;GET THE BYTE
	BIC	#177600,A	;MAKE IT GOOD ASCII
	BEQ	1$		;IGNORE NULLS
	CMPB	A,#RUBOUT	;  AND RUBOUTS
	BEQ	1$
	CMPB	A,#FF		;IF FORM FEED
	BEQ	30$		;   GO SET FLAG AND EXIT
	MOVB	A,(C)+	;PUT BYTE, ADVANCE POINTER
	DEC	B		;IS THERE ANY ROOM LEFT
	BEQ	3$		;IF NOT, WE OUGHT TO LEAVE NOW
	CMP	B,#128.	;IF FEWER THAN 128 BYTES LEFT
	BHIS	1$		;  KEEP GOING
	CMP	A,#LF		;ELSE STOP AT LINE FEED
	BNE	1$		;  IF WE GOT ONE
3$:	MOV	E,@D		;SAVE NEW BUFFER TOP
	MOV	F,-(D)	;   AND BUFFER POINTER
	SUB	(SP)+,C	;COMPUTE NUMBER OF CHARACTERS READ
	MOV	C,4(SP)	;RETURN IT IN B
	BNE	4$		;NO EOF IF WE GOT STUFF
	TST	EFFLG		;NULL PAGE: IS IT THE END?
	BLE	4$		;  NO, JUST A NULL PAGE
	MOV	FREEST,F	;POINT TO RW AREA
50$:	COM	EOFLAG(F)	;TURN ON EOF INDICATION
51$:	CLR	B		;SET NO CHARACTERS
	CLR	C		;SET NO FORM FEED
4$:	RETURN

30$:	COM	10(SP)		;SET FORM FEED FLAG (C)
	BR	3$		;EXIT (NOTE FF IS NOT IN BUFFER)

10$:	CALL	BREAD		;GET BUFFER LOAD (NOTE E->TOP)
;				;E NOW -> TOP OF OTHER BUFFER
	MOV	@E,F		;POINT TO BOTTOM OF THAT BUFFER
	TST	EFFLG		;DID WE SWITCH TO EOF?
	BLE	1$		;NOPE
	MOV	F,E		;YEP, SET TO GIVE EOF NEXT TIME
	BR	3$		;AND GET OUT NOW
NOIFIL:	ERROB	NFI,<"NO INPUT FILE">
.SBTTL	PUTBUF - OUTPUT A TECO BUFFER LOAD

;PUTBUF:
;	OUTPUTS A BUFFER THE WAY TECO WANTS TO

PUTBUF:	TST	OBTOP		;IS AN OUTPUT FILE OPEN?
	BEQ	NOOFIL		;ERROR IF NAE
	JSR	F,SAVREG	;SAVE REGS
	ADD	A,B		;POINT TO END OF TEXT STRING
	TST	C		;FF REQUIRED?
	BMI	1$		;GO IF YES
	MOVB	-(B),-(SP)	;SAVE LAST CHAR IN TEXT
	BR	2$
1$:	MOVB	@B,-(SP)	;SAVE CHAR AFTER LAST
	MOVB	#FF,@B		;AND REPLACE IT WITH FF
2$:	MOV	#OBPTR,D
	MOV	(D)+,F	;GET PTR INTO OUTPUT BUFFER
	MOV	@D,E		;  AND BUFFER TOP
	MOV	A,C		;COPY TEXT POINTER
3$:	CMP	C,B		;END OF TEXT (B -> LAST)?
	BHI	4$		;YES, GO RESTORE LAST CHAR
	MOVB	(C)+,(F)+	;GET NEXT BYTE
	CMP	F,E		;END OF BUFFER?
	BLO	3$		;NO, KEEP GOING
	CALL	BWRITE		;YES, PUT OUT THIS LOAD
	MOV	@E,F		;;E POINTS TO NEW TOP, F TO NEW BOTTOM
	BR	3$		;GO FOR MORE
4$:	MOVB	(SP)+,@B	;RESTORE LAST CHAR
	MOV	E,@D		;SAVE TOP
	MOV	F,-(D)	;BOTTOM
6$:	RETURNîî.SBTTL	DATA AREA

; DATA AREA

FREEST	= .+2			;TOP OF PROGRAM AFTER LINK
	.LIMITS
LOCKFL:	.WORD	0		;FLAG FOR USR LOCKED IN
SPSAVE:	.WORD	0		;SP FOR ERROR RETURN
SCRACH:	.BLKW	4
DEFEXT:	.WORD	0,0,0,0
SSINFO:	.WORD	0,0,0,0		;DEV NAME, BUFFER OFFSET, BLOCK #, EOF
SSBLOK:	.BLKW	5		;SAVESTATUS STUFF
OUTFNM:	.BLKB	12.		;SAVED OUTPUT FILE NAME IN ASCIZ

; INPUT

EBFLG:	.WORD	0
EFFLG:	.WORD	-1
IBLKNM:	.WORD	0
IBPTR:	.WORD	0
IBTOP:	.WORD	0
INBLK:	.BLKW	5
IBUF1:	.BLKW	256.
	.WORD	IBUF1		;LINK TO THIS BUFFER START
	.WORD	IBUF2+512.	;LINK TO OTHER BUFFER TOP

IBUF2:	.BLKW	256.
	.WORD	IBUF2		;LINK TO THIS BUFFER START
	.WORD	IBUF1+512.	;LINK TO OTHER BUFFER TOP

; OUTPUT

OBLKNM:	.WORD	0
OBPTR:	.WORD	0
OBTOP:	.WORD	0
OUTBLK:	.BLKW	4
FILENG:	.WORD	0
OBUF1:	.BLKW	256.
	.WORD	OBUF1		;LINK TO THIS BUFFER START
	.WORD	OBUF2+512.	;LINK TO NEXT BUFFER TOP

OBUF2:	.BLKW	256.
	.WORD	OBUF2		;LINK TO THIS BUFFER START
	.WORD	OBUF1+512.	;LINK TO NEXT BUFFER TOP


; HANDLERS

HAND1:	.BLKW	130.
HAND2:	.BLKW	130.

.IF DF	GT40
DISBUF:	.BLKB	2000.

.ENDC
.NLIST	BEX
MESSAG:	.ASCIZ	/[+2K CORE]/
FILSPC:	.BLKB	25
.EVEN
.LIST	BEX
.SBTTL	START AND REENTER CODE

	BR	GOTECO		;ON REENTRY, REENTER
START:	.SRESET
	MOV	@#RMON,B	;POINT TO RMON
	MOV	USRBUF(B),B	;LEAVE USR RESIDENT
	MOV	FREEST,F	;WERE WE HERE BEFORE (SETTOP!)
	MOV	B,A
	TST	-(A)
	.SETTOP
	MOV	F,C
	MOV	#RWSIZE,D	;GET SIZE OF R/W AREA
	ASR	D		;MAKE IT WORDS
SYMBOL:	CLR	(C)+
	DEC	D
	BNE	SYMBOL
	MOV	C,TECOPD(F)	;START OF PUSH DOWN LIST
	MOV	C,PDL(F)	;AND AGAIN
	ADD	#SIZEPD,C	;SKIP OVER PD SPACE
	MOV	C,SCHBUF(F)	;START OF SEARCH BUFFER
	MOVB	#-1,@C		;SET UP A NULL SEARCH BUFFER
	ADD	#SCHSIZ,C	;SKIP OVER SEARCH BUFFER
	MOV	SP,TECOSP(F)	;START HIS STACK
	MOV	C,TXSTOR(F)	;START OF TEXT AREA
	SUB	C,B		;SIZE OF TEXT AND QREG AREAS
	CLC
	ROR	B		;HALVSIES
	MOV	B,ZMAX(F)
	MOV	B,QMAX(F)
	ADD	B,C
	MOV	R2,QRSTOR(F)
	CLR	CURFRE(F)	;WE'VE GIVEN HIM ALL FOR NOW
GOTECO:	MOV	FREEST,F	;IN CASE OF REENTRY
	CLR	HAND1		;NO HANDLERS ARE HERE
	CLR	HAND2
	CLR	OBTOP		;NO FILE OPEN
	CLR	IBTOP
	CLR	EBFLG		;NO EB IN PROGRESS
	BIS	#TTYUSR+REENTR,@#JSW ;TURN ON OUR OWN I/O
	MOV	#1,B		;CHECK FOR CCL
	BIT	B,@#JSW	;CCL?
	BEQ	1$
	BIC	B,@#JSW
	MOV	#400,A
	MOV	A,E
2$:	TSTB	(E)+		;COUNT IT
	BNE	2$
	DEC	E
	SUB	A,E		;LEAVE COUNT IN E
	COM	B
	JSR	PC,DOCCL	;DO THE EB
	MOV	#TECOCH,E
	JSR	PC,@'Y*2(E)	;DO THE YANK
1$:	JMP	TECO
