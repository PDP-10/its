MEMTOP==160000

FRENCH:	0
BRAKE:	0
FILNIL:	0
MEMLIM:	140000


BRKINT:	PUSH <#0,#0,#.SPKIL*400+1>
	$INVOK
	PUSH <#BRKPRS>
	$FORK
	RTS PC		;MAIN PROCESS RETURNS

	.BLKW 20
BRKPDL:

BRKPRS:	MOV #BRKPDL,SP	;MY OWN SPECIAL PDL
BRKPR3:	PUSH <#0,#377*400+'G-100,#2>
	MOVB #.TTBRK,1(SP)	;TO WAIT FOR ONE OF THESE CHARS
	$INVOK		;WAIT
	CMPB #'G-100,(SP)	;WAS IT R0 BREAK?
	BNE BRKPR2
	MOV #1,BRAKE
BRKPR2:	TST (SP)+
	BR BRKPR3


; APPIT,BACKT,CHECKC,CHEI,CHEL,CHEP,CHET,CLO,CLRTTY
; DELIT,EMOPEN,EMCLOS,EMREAD,FILNIL,INTTY,LO,MEMLIM,MOPEN
; PPINIT,PPO,PPOL,PRI,PRINIT,RSTTY,SSTAT,START,TTFLSH
; .REDCH

;ROUTINE TO OPEN A FILE FOR APPEND

APPIT:	PUSH	<R0>			;NEED A REGISTER
	JSR	PC,CLOO			;CLOSE ANY CURRENTLY OPEN FILE
	TSTB	FILNAM			;TRYING TO OPEN A NULL FILE NAME?
	BEQ	1$			;YES, IT WOULD OPEN DIRECTORY SO ERROR
.IF NZ SITS
	MOV #FILNAM,R0
	JSR PC,OPENRF			;OPEN FILE
	BCC 13$				;FOUND OLD FILE
	JSR PC,OPENW			;CREATE NEW FILE
13$:
.ENDC
	;SYS	S_OPEN,FILNAM,1		;OPEN FILNAM FOR WRITING
	BCS	1$
	MOV	R0,OUPFH		;SAVE FILE HANDLE
	INCB	OUTFLG			;SIGNAL THAT WE HAVE OUTPUT FILE OPEN
.IIF NZ SITS,	JSR PC,SEEKEN		;SEEK TO END
	;SYS	S_SEEK,0,2		;SEEK TO END OF FILE TO APPEND
	BCS	1$			;IF SOMETHING WENT WRONG
	POP	<R0>			;CLEAN UP
	CCC				;SIGNAL NO ERRORS
	RTS	PC

1$:	POP	<R0>			;CLEAN UP
	SEC				;SIGNAL ERROR
	RTS	PC

NAMSTR:	.ASCIZ	"TECO"
TMPSTR:	.ASCIZ	".TMP"
BAKSTR:	.ASCIZ	".BAK"
.EVEN

;ROUTINE TO OPEN BAKFIL FOR INPUT, AND TECO.TMP FOR OUTPUT WHERE TECO.TMP
;SHOULD BE IN THE SAME DIRECTORY AS BAKFIL.

BACKT:	PUSH	<R0,R1,R2>	;NEED SOME REGISTERS
	MOV	#FILNAM,R0	;PTR TO SOURCE FIELD
	MOV	#BAKFIL,R1	;PTR TO RESULT FIELD
	MOV	#50.,R2		;SIZE OF RESULT FIELD
	JSR	PC,MOVSTR	;COPY IT SOURCE TO RESULT FIELD
	BCS	1$		;ON OVERFLOWS
	JSR	PC,PRINIT	;NOW OPEN IT FOR INPUT
	BCS	1$		;IF WE COULDN'T
;	JSR	PC,SAVMOD	;SAVE THE FILE MODE
	MOV	#BAKFIL,R0	;PTR TO SOURCE
	MOV	#TMPFIL,R1	;PTR TO DESTINATION
	MOV	#50.,R2		;SIZE OF DESTINATION
	JSR	PC,PUTDIR	;COPY DIRECTORY PART OF SOURCE TO DESTINATION
	MOV	#NAMSTR,R0	;POINTER TO STRING "TECO"
	MOV	#TMPFIL,R1	;PTR TO DESTINATION FIELD
	MOV	#50.,R2		;LENGTH OF DESTINATION FIELD
	JSR	PC,CONCAT	;CONCATENATE TECO.TMP TO DIRECTORY
	BCS	1$		;IF NAME OVERFLOWS
	MOV	#TMPFIL,R1	;PTR TO DESTINATION FIELD
	MOV	#50.,R2		;LENGTH OF DESTINATION
;	JSR	PC,APDPID	;APPEND THE PROCESS ID
;	BCS	1$		;IF NAME OVERFLOWS
	MOV	#TMPSTR,R0	;POINTER TO STRING ".TMP"
	MOV	#TMPFIL,R1	;POINTER TO DESTINATION
	MOV	#50.,R2		;LENGTH OF DESTINATION
	JSR	PC,CONCAT	;CONCATENATE TO NAME
	BCS	1$		;IF NAME OVERFLOWS
	MOV	#TMPFIL,R0	;PTR TO SOURCE
	MOV	#FILNAM,R1	;PTR TO DESTINATION
	MOV	#50.,R2		;LENGTH OF DESTINATION FIELD
	JSR	PC,MOVSTR	;COPY SOURCE TO DEST
	JSR	PC,DELIT	;DELETE ANY INSTANCES OF "TECO.TMP"
	JSR	PC,PPINIT	;OPEN FILE FOR OUTPUT
	BCS	1$		;IF PROBLEMS
	INCB	BAKFLG		;WE HAVE BACKUP FILE PENDING
	POP	<R2,R1,R0>	;CLEAN UP
	CCC			;SIGNAL NO ERRORS
	RTS	PC

1$:	JSR	PC,CLOI		;CLOSE THE INPUT FILE
	POP	<R2,R1,R0>	;CLEAN UP
	SEC			;SIGNAL THE ERROR
	RTS	PC

W.PTR:	.WORD	0
W.CNT:	.WORD	0

;ROUTINE TO CLOSE ANY OPEN OUTPUT FILE.

CLO:
CLOO:	TSTB	OUTFLG			;ANY OUTPUT FILES OPEN?
	BEQ	1$			;NOTHING OPEN, JUST RETURN
	PUSH	<R0>			;NEED A REGISTER
	CLRB	OUTFLG			;NO LONGER ANYTHING OPEN
	MOV	OUPFH,R0		;OUTPUT FILE HANDLE
.IIF NZ SITS,	JSR PC,DELCAP
	;SYS	S_CLOSE			;CLOSE THE FILE
	;BCS	2$			;IF SOMETHING WENT WRONG
	POP	<R0>			;CLEAN UP
;	TSTB	BAKFLG			;DID WE HAVE A BACKUP FILE?
;	BEQ	1$			;NO, JUST RETURN
;	JSR	PC,UNBACK		;BACKUP THE INPUT FILE, RN TMP TO FILNM
;	BCS	3$			;IF WE COULDN'T
1$:	CCC				;SIGNAL NO ERRORS
	RTS	PC

2$:	POP	<R0>			;CLEAN UP
3$:	SEC				;SIGNAL THE ERROR
	RTS	PC

;ROUTINE TO CLOSE OPEN INPUT FILES

CLOI:	TSTB	INPFLG		;ANY INPUT FILES OPEN?
	BEQ	1$		;NOPE JUST RETURN
	CLRB	INPFLG		;NONE OPEN AFTER THIS..
	PUSH	<R0>		;GET A REGISTER
	MOV	INPFH,R0	;GET THE INPUT FILE HANDLE
.IIF NZ SITS,	JSR PC,DELCAP
	;SYS	S_CLOSE		;CLOSE IT
	BCS	2$		;IF SOMETHING WENT WRONG
	POP	<R0>		;CLEAN UP
1$:	CCC			;SIGNAL NO ERRORS
	RTS	PC

2$:	POP	<R0>		;CLEAN UP
	SEC			;SIGNAL AN ERROR
	RTS	PC

;ROUTINE TO RESTORE THE INITIAL TTY STATUS

CLRTTY:	JSR	PC,COPOLD	;PUT THE OLD TTY DATA BACK
	JSR	PC,COPNEW	;PUT IT IN THE COMMAND TO SET
	JSR	PC,SSTAT
	RTS	PC

COPNEW:	MOV TTFLAG,SFL
	RTS PC

COPOLD:	MOV GFL,TTFLAG
	RTS PC

CHET:	CMP	R0,#'T
	BNE	CHEU
	JSR PC,FILUNM		;GET FILE NAME COMPLETE WITH SPACES
	JSR PC,SETDIR
	BCS CHERWE
	EXIT

CHECKC:
.IFNZ SITS
	TST BRAKE
	BLE 1$
	INC GOSW
	CLR BRAKE
.ENDC
	TSTB	GOSW
	BEQ	1$
	MOV	STKSV,SP
	MOV	EOA,R1
	JMP	BAKG

1$:	RTS	PC

;ROUTINE TO WRITE OUT THE BUFFER, AND RESET COUNT AND POINTER

TTFLSH:	PUSH	R0		;NEED A REGISTER
	MOV	TTFLDS,R0	;FILE DESCRIPTOR FOR THE TTY
	MOV	#512.,TTWCNT	;THE COUNT FOR THE WRITE
	SUB	TTLEFT,TTWCNT	;SUBTRACT NUMBER OF SPACES LEFT
	BEQ	1$		;IN CASE THERE WERE NONE LEFT
.IF NZ SITS
	NEG	TTWCNT
	MOV	#TTOBFF,-(SP)
	MOV	TTWCNT,-(SP)
	MOV	#2,-(SP)
	$BLKO
.ENDC
	;SYS	S_INDIR,TTWRIT	;DO THE WRITE

1$:	MOV	#TTOBFF,TTNEXT	;RESET THE NEXT POINTER
	MOV	#512.,TTLEFT	;RESET THE SLOTS LEFT COUNT
	POP	R0		;CLEAN UP
	RTS	PC

;ROUTINE TO CREATE A FILE FOR OUTPUT.  IT IS CREATED WITH R/W ACCESS.
.IFNZ SITS
PPINNW:	PUSH <R0>
	JSR PC,CLOO
	JSR PC,OPENWN		;TRY TO CREATE A NEW FILE
	BR PPINI1
.ENDC
PPINIT:
	PUSH	<R0>		;NEED A REGISTER
	JSR	PC,CLOO		;CLOSE ANY CURRENTLY OPEN OUTPUT FILES
	TSTB	FILNAM		;SEE IS HE IS TRYING TO OPEN DIRECTORY
	BEQ	1$		;YES, ERROR
.IIF NZ SITS,	JSR PC,OPENW
	;SYS	S_OPEN,FILNAM,1	;SEE IF THERE IS A FILE WITH THAT NAME
	;BCC	1$		;THERE IS!!, BETTER NOT CLOBBER IT WITH CREATE
	;SYS	S_CREAT,FILNAM,666	;CREATE FILNAM WITH R/W ACCESS
PPINI1=.
	BCS	1$		;IN CASE WE HAVE PROBLEMS
	MOV	R0,OUPFH	;SAVE OUTPUT FILE HANDLE
	INCB	OUTFLG		;SIGNAL THAT WE HAVE OUTPUT FILE OPEN
	POP	<R0>		;CLEAN UP
	CLC			;NO ERRORS
	RTS	PC

1$:	POP	<R0>		;CLEAN UP
	SEC			;SIGNAL THAT WE COULND'T CREATE FILE
	RTS	PC

;ROUTINE TO DELETE A FILE

DELIT:	
.IIF NZ SITS,	JSR PC,DELFIL
	;SYS	S_UNLINK,FILNAM		;UNLINK FILNAM
	RTS	PC			;SIGNALS C IF IT CAN'T

;ROUTINE TO OPEN AN EMFILE, RETURNS FILE HANDLE IN R0

EMOPEN:	;SYS	S_OPEN,EMFIL,0	;OPEN FOR READ
.IFNZ SITS	
	MOV #EMFIL,R0
	JSR PC,OPENRF		;OPEN FOR READ, RETURN CAP IN R0
.ENDC
	RTS	PC

;ROUTINE TO CLOSE ANY EMFILES OPEN, EXPECTS FILE HANDLE IN R0

EMCLOSE:;SYS	S_CLOSE		;CLOSE FILE SPECIFIED IN R0
.IIF NZ SITS,	JSR PC,DELCAP
	RTS	PC

;ROUTINE TO READ IN A BLOCK, EXPECTS FILE HANDLE IN R0, RETURNS COUNT IN R0

EMREAD:	;SYS	S_READ,EMBUF,100.	;READ 100. BYTES INTO EMBUF
.IFNZ SITS
	PUSH <#EMBUF,#-100.,R0>
	MOV #100.,R0
	.BLKI
	BNE 1$
	TST (SP)+
	ADD (SP)+,R0
	TST (SP)+
.ENDC
1$:	RTS	PC		;RETURN ACTUAL NUMBER IN R0

INTTY:	MOV	#.TIMGI!.TIMGO!.TICTM,GETCMD
				;SET STATUS TO IMAGE IN, IMAGE OUT, NO ECHO
	JSR	PC,COPOLD	;COPY THE DEFAULT
	JSR	PC,COPNEW	;AND SAVE IT
	JSR	PC,SSTAT	;SET THE STATUS TO 
	RTS PC

SSTAT:	TST	-(SP)
	MOV	SETCMD,-(SP)
	MOV	#2,-(SP)
	MOVB	#.TTMOV,1(SP)
	$INVOK
	RTS	PC

RSTTY:	RTS	PC

;ROUTINE TO READ A BLOCK OF THE FILE INTO THE INPUT BUFFER PINBUF

PRINIT:
	PUSH	<R0>		;NEED REGISTER
	JSR	PC,CLOI		;CLOSE CURRENT INPUT FILE IF ANY
	TSTB	FILNAM		;ARE WE TRYING TO OPEN NULL FILE?
	BEQ	1$		;YES, IT WOULD OPEN DIRECTORY SO ERROR
.IFNZ SITS
	MOV #FILNAM,R0
	JSR PC,OPENRF
.ENDC
	;SYS	S_OPEN,FILNAM,0	;OPEN FILE FILNAM FOR READING
	BCS	1$		;IF CANNOT
	MOV	R0,INPFH	;SAVE FILE HANDLE
	INCB	INPFLG
	CLR	PINCNT
	POP	<R0>
	RTS	PC		;AND QUIT

1$:	POP	<R0>		;CLEAN UP
	SEC			;SIGNAL ERROR
	RTS	PC

;ROUTINE TO READ CHARS FROM FILE AND SAVE IN INPUT BUFFER

PRI:	DEC	PINCNT		;IS THERE ANYTHING TO READ?
	BGE	2$		;NO
	MOV	#PINBUF,PINPTR		;SET UP INPUT POINTER TO START
	MOV	INPFH,R0		;INPUT FILE HANDLE
.IFNZ SITS
	PUSH <#PINBUF,#PINMAX>
	NEG (SP)
	PUSH <R0>
	MOV #PINMAX,R0
	.BLKI
	BNE 3$
	TST (SP)+
	ADD (SP)+,R0	
	TST (SP)+
3$:
.ENDC
	;SYS	S_READ,PINBUF,PINMAX	;READ PINMAX BYTES INTO PINBUF
	;BCS	1$		;IF THERE WAS SOME READ ERROR
	MOV	R0,PINCNT	;MOVE COUNT OF HOW MUCH WE READ
	BNE	PRI		;GOT SOMETHING, SO RETURN IT
1$:	JSR	PC,CLOI
	SEC
	RTS	PC

2$:	MOVB	@PINPTR,R0
	INC	PINPTR
	CLC
	RTS	PC

;ROUTINE TO OUTPUT ONE CHAR TO THE OUTPUT FILE

;PPO:	MOVB	R0,IOTMP		;SAVE THE CHAR IN IO TEMPORARY
;	MOV	OUPFH,R0		;OUTPUT FILE HANDLE
;	SYS	S_WRITE,IOTMP,1		;WRITE THIS ONE CHAR
;	BCS	1$			;IF SOMETHING WENT WRONG
;	MOVB	IOTMP,R0		;RESTORE THE CHAR
;	CCC				;NO ERROR
;	RTS	PC
;
;1$:	MOVB	IOTMP,R0		;RESTORE THE CHAR
;	SEC				;SIGNAL ERROR
;	RTS	PC
.IF NZ SITS
PPO:	PUSH <R0,OUPFH>
	.BYTO
	BEQ 1$
	CCC
	RTS PC

1$:	CMP (SP)+,(SP)+
	SEC
	RTS PC
.ENDC
;ROUTINE TO OUTPUT A BLOCK OF TEXT.  USES THE INDIRECT WRITE MECHANISM
;BECAUSE THE START AND COUNT WILL BE VARIABLES.

PPOL:	PUSH	<R0>			;NEED A REGISTER
	MOV	R1,W.PTR		;POINTER TO START OF TRANSFER
	MOV	R2,W.CNT		;POINTER TO END OF BLOCK
	SUB	R1,W.CNT		;SUBTRACT START TO GET COUNT OF CHARS
	MOV	OUPFH,R0		;THE OUTPUT FILE HANDLE
.IFNZ SITS
	PUSH <W.PTR,W.CNT>
	NEG (SP)
	PUSH <R0>
	.BLKO
	BEQ 1$
.ENDC
	;SYS	S_INDIR,W_FNC	;DO THE WRITE FUNCTION INDIRECTLY
	;BCS	1$			;IF SOMETHING WENT WRONG
	POP	<R0>			;CLEAN UP
	CCC				;SIGNAL NO ERRORS
	RTS	PC

1$:
.IF NZ SITS
	CMP (SP)+,(SP)+
	TST (SP)+
.ENDC
	POP	<R0>			;CLEAN UP
	SEC				;SIGNAL AN ERROR
	RTS	PC

.REDCH:	POP <TEMP>
	PUSH #2
	$BYTI
	JMP @TEMP
TEMP:	0
;SITS FILES ROUTINES
.IFNZ SITS
;OPENRF	OPENR BUT RESULT MUST BE A FILE
OPENRF:	JSR PC,OPENR
	BCS 1$
	JSR PC,DIRCHK
	BNE 1$
	CLC
	RTS PC
1$:	SEC
	RTS PC

DIRCHK:	PUSH <#FILBLK,#40,R0>
	BIS #.FARI,(SP)
	$INVOK
	BIT #.FADIR,FILBLK+2
	RTS PC

;SEEKEN	CAP IN R0, SEEK TO EOF
SEEKEN:	CMP -(SP),-(SP)
	PUSH <R0>
	BIS #.FARE,(SP)
	$INVOK
	PUSH <R0>
	BIS #.FASP,(SP)
	$INVOK
	RTS PC


;OPENW	CREATE FILNAM IF IT DOESN'T EXIST
OPENW:	JSR PC,COPCUR		;COPY DIR CAP
	BCS 2$
	PUSH <#0,#FILNAM,R0>
	BIS #.FAAD,(SP)
	.INVOK
	BEQ 1$
	RTS PC

1$:	CMP (SP)+,(SP)+
	TST (SP)+
	JSR PC,DELCAP
2$:	SEC
	RTS PC


;OPENWN	CREATE FILNAM, APPENDING > IF NOT ALREADY THERE (FLUSHING #NM ALSO)
OPENWN:	PUSH <R1>
	MOV #FILNAM,R0
1$:	TSTB (R0)+
	BNE 1$
	TSTB -(R0)
	MOV R0,R1
	TSTB -(R0)
	CMPB #'>,(R0)
	BEQ 3$
2$:	CMPB #'#,-(R0)
	BEQ 4$
	CMP #FILNAM,R0
	BLO 2$
	MOV R1,R0
4$:	MOVB #'>,(R0)+
	CLRB (R0)
3$:	POP <R1>
	JMP OPENW



;DELETE FILE IN FILNAM
DELFIL:	MOV #FILNAM,R0
	JSR PC,OPENR
	BCS 1$
	CMP -(SP),-(SP)
	PUSH <R0>
	BIS #.FADL,(SP)
	$INVOK
	JSR PC,DELCAP
	CLC
1$:	RTS PC

;POINTER TO FILE NAME IN R0, RETURN CAP # IN R0
;OPEN FOR READING
OPENR:	PUSH <R1,R0>
	JSR PC,COPCUR	;RETURN IN R0 A COPY OF THE CURRENT DIR CAP
	BCS 2$
	POP <R1>	;GET BACK NAME POINTER INTO R1
	PUSH <#0,R1,R0>	
	BIS #.FAMU,(SP)
	.INVOK		;TRY TO MUTATE TO FILE
	BNE 1$		;SUCCESS
	CMP (SP)+,(SP)+
	TST (SP)+
	POP <R1>
2$:	SEC
	RTS PC

1$:	POP <R1>
	CCC
	RTS PC

COPCUR:	TST CURCAP
	BEQ 1$
	PUSH <#-1,#0,CURCAP>
	BIS #.CPYCP,(SP)
	$INVOK
	POP <R0>
	CLC
	RTS PC
1$:	SEC
	RTS PC

DELCAP:	TST R0
	BEQ 1$
	PUSH <#0,#0,R0>
	BIS #.DELCP,(SP)
	$INVOK
1$:	RTS PC

SETDIR:	PUSH <R1>
	MOV #FILNAM,R5
	TSTB (R5)
	BEQ SETDI5
	CMPB #';,(R5)+
	BEQ SETDI0
	CMPB #';,(R5)+
	BEQ SETDI1
	DEC R5
	DEC R5
SETDI9:	MOV R5,R0
	JSR PC,OPENR		;MUTATE THERE
	BCS 1$			;ERROR?
	PUSH <R0>
	MOV CURCAP,R0
	JSR PC,DELCAP
	POP <CURCAP>
SETDI5=.
	CCC
1$:	POP <R1>
	RTS PC

SETDI0:	MOV CURROT,R1
	BR SETDI2

SETDI1:	MOVB FILNAM,R1
	SUB #'0,R1
	BLT 1$
	CMP #4,R1
	BLE 1$
SETDI2=.
	JSR PC,CRTROT	
	BNE SETDI9

1$:	SEC
	POP <R1>
	RTS PC

CRTROT:	MOV R1,CURROT
	ASL R1
	MOV ROTCPS(R1),R0
	BNE CRTRO1	;WE ALREADY HAVE ONE
	MOV R1,ROTBLK
	BIS #.FARUT,ROTBLK
	PUSH <#-1,#ROTBLK,#.FACAP*400+0>
	.INVOK		;TRY TO CREATE A ROOT CAP
	BNE 1$
2$:	CMP (SP)+,(SP)+
	TST (SP)+
	SEZ
	RTS PC
1$:	POP <ROTCPS(R1)>
	JSR PC,SETROT
	JSR PC,COPCUR
	PUSH <#0,#BITS,R0>
	BIS #.FAMU,(SP)
	.INVOK
	BEQ 2$
	CMP -(SP),-(SP)
	PUSH <R0>
	BIS #.FAMB,(SP)	;THSI IS THE BIT TABLE
	.INVOK
	BEQ 2$
	JSR PC,DELCAP
	CLZ
	RTS PC

UNMOUN:	PUSH R0
	ASL R0
	MOV ROTCPS(R0),R0
	JSR PC,DELCAP
	CLR ROTCPS(R0)
	MOV (SP),R0	;GET BACK DISK NUMBER
	ASL R0
	TST CURCAP
	BEQ 1$
	CMP -(SP),-(SP)
	PUSH <CURCAP>
	BIS #.FADI,(SP)
	$INVOK
	TST (SP)+	;FREE BLOCK COUNT
	CMP R0,(SP)+	;DISK NUMBER
	BNE 1$
	MOV CURCAP,R0
	JSR PC,DELCAP
	CLR CURCAP
1$:	POP R0
	RTS PC


SETROT:	MOV CURCAP,R0
	JSR PC,DELCAP
	PUSH <#-1,#0,ROTCPS(R1)>
	BIS #.CPYCP,(SP)
	$INVOK
	POP <CURCAP>
	RTS PC

CRTRO1:	JSR PC,SETROT
	CLZ
	RTS PC

;TTYMOD COMMAND USED TO READ THE TTY INITIAL STATUS

GETCMD:
GFL:	.BYTE	0	;LOW BYTE OF TTFLAG
	.BYTE	4.
GFH:	.BYTE	0	;HIGH BYTE
	.BYTE	5.
GF2L:	.BYTE	0	;LOW BYTE OF TTFLG2
	.BYTE	6.
GF2H:	.BYTE	0	;HIGH BYTE
	.BYTE	7.
GF3L:	.BYTE	0	;LOW BYTE OF TTFLG3
	.BYTE	8.
GF3H:	.BYTE	0	;HIGH BYTE
	.BYTE	9.
GLL:	.BYTE	0	;LINE LENGTH
	.BYTE	12.
GPS:	.BYTE	0	;PAGE SIZE
	.BYTE	13.
	.WORD	-1


;TTYMOD COMMAND USED TO REPLACE THE TTY DATA

SETCMD:	
SFL:	.BYTE	0
	.BYTE	300!4	;REPLACE TTFLAG LOW BYTE
SFH:	.BYTE	0
	.BYTE	300!5	;REPLACE TTFLAG HIGH BYTE
SF2L:	.BYTE	0
	.BYTE	300!6	;REPLACE TTFLG2 LOW BYTE
SF2H:	.BYTE	0
	.BYTE	300!7	;REPLACE TTFLG2 HIGH BYTE
SF3L:	.BYTE	0
	.BYTE	300!8.	;REPLACE TTFLG3 LOW BYTE
SF3H:	.BYTE	0
	.BYTE	300!9.	;REPLACE TTFLG3 HIGH BYTE
	.WORD	-1


BITS:	.ASCIZ /BITS/
	.EVEN
ROTBLK:	0
CURROT:	0	;CURRENT ROOT DISK
CURCAP:	4
ROTCPS:	.WORD 10,11,12,13
FILBLK:	.BLKW 40
