	 .TITLE	   FTPLOG
;***********************************************************************
;TNLOG	 LOGGER	PROCESS	FOR FILE TRANSFER PROCESSES
;PROGRAMMER:	   T. HAUGLAND
;PURPOSE:	   THE ROUTINE ISSUES A	CALL TO	$SICP (SERVER ICP) AND
;	 CREATES A NEW PROCESS,	TNFTP, IF SUCCESSFUL ICP. THE ICP SOCKET
;	 (CCT) IS PASSED TO THE	FTP AS A PARAMETER. IT CONTAINS	TH
;	 DEFAULT VALUES	FOR THE	DATA SOCKET (U+3). THE TNFTP PROCESS
;	 ID IS ALSO PASSED SINCE THE DATA PROCESS, DTFTP, HAS TO
;	 POST TNFTP.
;
;***********************************************************************
;
	 .MCALL	   $N.SND,$N.CON,$N.CLS,$N.LSN,$N.RCV,$N.CNT
	 .MCALL	   $WAIT,$POST,$STIME
	 .MCALL	   $PUSH,$POP
	 .MCALL	   $ALOCB,$FREEB
	 .MCALL	   $DFCCT,$CNFIG,$DFREG,$DISCC
	 .GLOBL	   TNLOG
	 .GLOBL	   $SICP
	 .GLOBL	   $LGPCT,$TNPCT
	 .GLOBL	   $ALOCW
	 $CNFIG			   ;SYSTEM PROCESSOR CONFIGURATION
	 $DFCCT			   ;DDEFINE CCT	ENTRY
	 $DFREG			   ;DEFINE REGS
	 $DISCC			   ;DEFINE COMPLETION CODES
;$DFCCT
;CCTHOS=0
;CCTOP=1
;CCTCC=2
;CCTBS=3
;CCTLCL=4
;CCTFGN=6
;
;DISCC
;RDY=200
;TIM=100
;IO=40
;ACK=20
;BUF=10
;
BFPOOL=3			   ;EXHANGE BUFFER 16 WORDS
CCPOOL=3			   ;CCT	POOL ID
LINPOOL=2			   ;LINE BUFFER	ID 64 WORDS
LINLEN=128.			   ;LENGTH OF LINE BUFFFER IN CHARS.
;
SPACE=	 40
CR=	 15
LF=	 12
IAC=	 255.
;
;***********************************************************************
LGCUR:	 .WORD	   0		   ;CURRENT NO OD TNFTP-PROCESSES
LGMAX:	 .WORD	   1		   ;MAX	NO OF POROCESSES
LGPRT:	 .WORD	   0,0,0,0,0,0	   ;TNFTP ID TABLE
	 .GLOBL	   PTEX
PTEX:	 .WORD	   0		   ;TEMPORARY PRT TO EXCHANGE BUFFER
;EACH ACTIVE FTP-PROCESS
;
;NOW DEFINE POINTERS TO	 THE EXCHANGE BUFFER
PRID=	 0			   ;PROC. ID TNFTP
PICP=	 2			   ;PTR	ICP CCT
FLAG=	 4
PSCCT=	 12			   ;PTR	SEND CCT
PRCCT=	 14			   ;PTR	REC. BUFFER
;
;***********************************************************************
TNPRIO=6			   ;PRIORITY TNFTP
;NOW INITIALIZE	CURRENT	NO OF TNFTP-PROCESSES AND CLEAR	STACK
;FOR ACTIVE PTOCESS IDS
TNLOG:	 CLR	   LGCUR
	 MOV	   #LGPRT,R0	   ;ADDRESS LGPRT
	 MOV	   #-6,R1	   ;CLEAR LGPRT	AND LGEXC
TNLOG1:	 CLR	   (R0)+
	 INC	   R1
	 TST	   R1
	 BNE	   TNLOG1
; AT THIS POINT	WE HAVE	TO ISSUE A CALL	TO $SICP, BUT FIRST A
;NEW ENTRY IN LGPRT HAS	TO BE IDENTIFIED
;
LGPRO1:	 CMP	   LGCUR,LGMAX	   ;NO MORE TNFTPS ALLOWED?
	 BPL	   LGMON
;IF TRUE, GO AND WAIT FOR SOMEBODE TO ELSE TO FINISH
;ALLOCATE A NEW	EXCHANGE BUFFER
	 MOV	   #BFPOOL,R0
	 JSR	   PC,$ALOCW	   ;ALLOCATE SPACE
	 $PUSH	   R1		   ;SAVE ON STACK
	 MOV	   R1,R5	   ;[5 IS USED AS BUFFER PTR
	 CLR	   FLAG(R5)	   ;SET	EXVH FLAG FREO TNFTP TO	0
;ELSE WE CAN ALLOCATE SPACE FOR	CCTS
	 MOV	   #CCPOOL,R0	   ;ICP	CCT
	 JSR	   PC,$ALOCW	   ;ALLOCATE SPACE
	 MOV	   (SP),R5	   ;RESET PTR
	 MOV	   R1,PICP(R5)	   ;SET	PTR ICP	SOCKET
	 MOV	   #3,CCTLCL(R1)   ;LOCAL SOCET=3
	 MOVB	   #32.,CCTBS(R1)  ;BYTE SIZE=32 ICP
	 MOV	   #CCPOOL,R0	   ;SEND CCT
	 JSR	   PC,$ALOCW	   ;ALLOCATE SPACE
	 MOV	   (SP),R5
	 MOV	   R1,PSCCT(R5)	   ;SAVE SEND CCT
	 MOV	   #CCPOOL,R0	   ;RECEIVE CCT
	 JSR	   PC,$ALOCW	   ;ALLOCATE SPACE
	 MOV	   (SP),R5
	 MOV	   R1,PRCCT(R5)	   ;PTR	REC SOCKET
;NOW SET UP PARAMETERS FOR $SICP
LGPRO2:	 MOV	   (SP),R5
	 MOV	   PICP(R5),R0	   ;ICP	SOCKET
	 MOV	   PSCCT(R5),R3	   ;SEND SOCKET
	 MOV	   PRCCT(R5),R4	   ;REC. SOCKET
	 JSR	   PC,$SICP	   ;SERVER ICP
;IF RETURN=JSR.. +1, SOMETHING FAILED AND WE HAVE TO GO	BACK
;AND ISSUE A NEW CALL $SICP. IF	RETURN=	JSR... +2 OK
	 BR	   LGPRO2	   ;TRY	AGAIN
	 MOV	   (SP),R5
	 MOV	   #LGPRT,R0	   ;FIND FREE ENTRY FOR	PROC ID
	 CLR	   R1		   ;COUNTER
LGPRO3:	 TST	   (R0)+	   ;CHEGK IF 0
	 BEQ	   LGPRO4	   ;FOUND
	 INC	   R1		   ;NOT	FOUND, TRY NEXT
	 CMP	   R1,LGMAX	   ;SEE	IF THROUGH LIST
	 BMI	   LGPRO3	   ;DOUBLE CHECK
	 HALT			   ;CAN,T HAPPEN
;LGPRO4:  SET ENTRY (EXCH BUFFER ADDR. INTO LGPRT ENTRY)
;
LGPRO4:	 SUB	   #2,R0
	 MOV	   R5,(R0)	   ;PTR
;
;NOW TRY TO CONNECT THE	TNFTP PROCESS
;R2=PTR	EXCH BUFFER
;R5=PTR	EXCGNAGE BUFFER
	 MOV	   R5,PTEX	   ;PRELIMINARY
	 $POST	   #$TNPCT+2,#RDY+ACK ;PRELIMINARY
	 BR	   LGPRO7
;	 $ATTCH	   TNPTF,TNPRIO
	 TST	   R0		   ;IF R/=0, SOMETHING WRONG
	 BEQ	   LGPRO5	   ;WRONG
	 MOV	   (SP),R5
	 MOV	   R0,PRID(R5)	   ;SET	PROCESS	ID
LGPRO7:	 INC	   LGCUR
	 $POP	   R5
	 BR	   LGPRO1	   ;ISSUE NEW LISTEN
LGPRO5:	 HALT			   ;SHOULDNT HAPPEN
;LGMON:THIS ROUTINE GETS CONTROL EVERY TIME THE	NO OF ACTIVE PROS
;=MAX NO OF PROCESSES AND WE CHEK IF A PROCESS IS FREE(	WE KNOW	THAT
;THIS CANNOT GO	ON AT THE SAME TIME AS THE PROC	IS WAITING IN $SICP
;BUT THE LTNFTP	COULD HAVE POSTED US WHILE IN THE $SICP	SO WE
;HAVE TO CHECK COMPLETION CODE BEFORE $WAIT
LGMON:	 MOV	   #LGPRT,R0	   ;PTR	LGEXC
	 CLR	   R1		   ;COUNTER
LGMO2:	 MOV	   (R0)+,R5	   ;CHECK FLAG
	 TST	   FLAG(R5)
	 BNE	   LGMO1	   ;FREE PROC IF SET
	 INC	   R1
	 CMP	   R1,LGMAX	   ;END	OF TABLE
	 BMI	   LGMO2	   ;NO,	TRY NEXT
	 $WAIT	   ;WAIT FOR SOMEONE TO	POST YOU
	 BR	   LGMON	   ;AND	TRY AGAIN
;
;FREE SEND CCT,	REC CCT, DETACH	TNFTP AND FREE EXCH BUFFER
;AT ENTRY R0 POINTS TO LGPRT+2,	R5 POINTS TO EXCHANGE BUFFER
;
LGMO1:	 MOV	   PRID(R5),R2
	 $PUSH	   R2		   ;SAVE ID
	 $PUSH	   R5		   ;PTR	EXCH BUFFER
	 CLR	   -(R0)	   ;CLEAR ENTRY	LGPRT
;FREE SEND CCT AND REC CCT
	 MOV	   PSCCT(R5),R1
	 MOV	   #CCPOOL,R0
	 $FREEB
	 MOV	   (SP),R5
	 MOV	   PRCCT(R5),R1	   ;GET	REC CCT
	 MOV	   #CCPOOL,R0
	 $FREEB
	 MOV	   (SP),R5
	 MOV	   PICP(R5),R1	   ;ICP	AND DATA SOCKET
	 MOV	   #CCPOOL,R0
	 $FREEB
	 $POP	   R1
	 MOV	   #BFPOOL,R0
	 $FREEB			   ;FREE EXCHANGE BUFFER
	 $POP	   R0
;	 $DETACH   R0		   ;DETACH TNFTP
	 DEC	   LGCUR	   ;DECR CURRENT NI OF ACTIVE PROC.
	 JMP	   LGPRO1
;
;***********************************************************************
;
;$SICP:	 SERVER	ICP
;
;	 AT ENTRY THE PARAMETERS ARE:
;	 R0=ICP	CCT
;	 R3=SEND CCT
;	 R4=REC	CCT
;IF ICP	IS SUCCESSFUL ,	RETURN=JSR+2 ELSE JSR+1
;
$SICP:	 $PUSH	   R0,R3,R4	   ;SAVE REGS
	 $N.LSN			   ;LISTEN
SIH1:	 $WAIT			   ;WAIT FOR COMLETION
	 MOV	   4(SP),R0	   ;GET	PTR CCT	AGAIN
	 TSTB	   CCTCC(R0)	   ;CHECK COMPLETION
	 BPL	   SIH1		   ;NOT	FINISHED
	 BITB	   #37,CCTCC(R0)   ;ERROR?
         BEQ       SIH6            ;YES
	 JMP	   SICERR	   ;YES
SIH6:	 $N.CON			   ;OK,	TRY TO CONNECT
    BR SIH7
SIH2:	 $WAIT			   ;WAIT FOR COMLETION
SIH7:	 MOV	   4(SP),R0	   ;CCT	PTR
	 TSTB	   CCTCC(R0)	   ;DONE?
	 BPL	   SIH2		   ;NO
	 BITB	   #37,CCTCC(R0)
	 BNE	   SICERR	   ;SOMETHING WRONG
;
;NOW  SEND OUR SOCKET NO AS DATA. USE THE REC. SOKET CCT AS OUTPUT SINCE
;THE SOCKET  S HAS TO BE PUT IN	THERE ANYHOW
;
	 MOV	   (SP),R4	   ;;GET REC CCT
	 MOV	   R4,CCTLCL(R4)   ;REC	SOCKET=S=CCT ADDRESS
	 MOV	   2(SP),R3	   ;SEND CCT
	 MOV	   R4,CCTLCL(R3)
	 INC	   CCTLCL(R3)	   ;;SEND SOCKET=S+1
	 MOV	   R4,CCTFGN+2(R4) ;ACTUAL SEND	MESSAGE
         SWAB      CCTFGN+2(R4)    ;*****PROBLEM******
	 CLR	   CCTFGN(R4)	   ;CLEAR HIGH ORDER BITS
	 ADD	   #CCTFGN,R4	   ;PTR	MESSAGE
	 MOV	   #32.,R3	   ;BIT	COUNT
	 $N.SND			   ;SEND MESSAGE
SIH3:	 $WAIT	   ;WAIT FOR COMPLETION
	 MOV	   4(SP),R0	   ;PTR	CCT
	 TSTB	   CCTCC(R0)	   ;TEST FOR COMPLETION
	 BPL	   SIH3		   ;NOT	DONE
	 BITB	   #177,CCTCC(R0)  ;DONE, TEST IF OK
	 BNE	   SICERR	   ;CANT SEND, SOMETHING WRONG
         JSR       PC,SIWAIT       ;INTRODUCE DELAY
         MOV       4(SP),R0        ;PTR CCT
	 $N.CLS			   ;OK,	CLOSE ICP SOCKET
SIH5:	 $WAIT
	 MOV	   4(SP),R0	   ;CHECK IF COMPLETED
	 TSTB	   CCTCC(R0)
	 BPL	   SIH5		   ;NOT	DONE
	 MOV	   (SP),R4	   ;OK,	GET REC	CCT
	 MOV	   2(SP),R3	   ;SEND CCT
;SEND SOCKET=U+3
	 MOV	   CCTFGN+2(R0),CCTFGN+2(R3)
	 MOV	   CCTFGN(R0),CCTFGN(R3)
	 ADD	   #2,CCTFGN+2(R3)
	 ADC	   CCTFGN(R3)	   ;ADD	CARRY
	 MOV	   CCTFGN+2(R0),CCTFGN+2(R4)
;REC SOKET=U+2
	 MOV	   CCTFGN(R0),CCTFGN(R4)
	 ADD	   #3,CCTFGN+2(R4)
	 ADC	   CCTFGN(R4)	   ;ADD	CARRY
      MOV   (R0),(R4)      ;SET HOST ID
     MOV    (R0),(R3)
;SET BYTE SIZE FOR SEN SOCKET
	 MOVB	   #8.,CCTBS(R3)
;NOW , TRY OT CONNECT
	 MOV	   2(SP),R0	   ;SEND CCT
	 $N.CON			   ;CONNECT
	 MOV	   (SP),R0	   ;REC	CCT
	 $N.CON			   ;CONNECT
      BR   SIH8
SIH4:	 $WAIT			   ;WAIT FOR COMPLETION
SIH8:	 MOV	   2(SP),R3
	 MOV	   (SP),R4
	 MOVB	   CCTCC(R3),R0	   ;COMPL CODE SEND
	 BITB	   CCTCC(R4),R0	   ;MASK WITH REC
	 BPL	   SIH4		   ;NOT	FINISHED
	 BITB	   #177,CCTCC(R3)
	 BNE	   SIERR	   ;SOMETHING WRONG
	 BITB	   #177,CCTCC(R4)
	 BNE	   SIERR	   ;SOMETHING WRONG
	 $POP	   R4,R3,R0	   ;EVERYTHINGS	OK
	 ADD	   #2,(SP)	   ;RETURN=RETURN+1
	 RTS	   PC		   ;RETURN
;SIERR:	CLOSE CONN
;AND ERROR RETURN
;
SIERR:	          JSR       PC,SIWAIT       ;INTRODUCE DELAY
         MOV	   2(SP),R0
	 $N.CLS
	 MOV	   (SP),R0
	 $N.CLS
SIER1:	 $WAIT	   ;CLOSE AND WAIT
	 MOV	   2(SP),R3	   ;FOR	COMPLETION
	 MOV	   (SP),R4
	 MOVB	   CCTCC(R3),R0
	 BITB	   CCTCC(R4),R0
	 BPL	   SIER1
	 $POP	   R4,R3,R0
	 RTS	   PC		   ;ERROR RETURN
;
;SICERR: COULDNT DO INIT CONNECTION , CLOSE
;
SICERR:	 JSR     PC,SIWAIT
         MOV	   4(SP),R0
	 $N.CLS
SICER1:	 $WAIT
	 MOV	   4(SP),R0
	 TSTB	   CCTCC(R0)
	 BPL	   SICER1	   ;NOT	DONE
	 $POP	   R4,R3,R0	   ;DONE, RETURN
	 RTS	   PC
;
SIWAIT:  $STIME   2000.           ;WAIT 2 SEC.
         $WAIT                    ;WAIT FOR FINISHED
         BIT      #TIM,-(R4)      ;IS IT TIMER
         BEQ      SIWAIT          ;NO
         RTS      PC              
;***********************************************************************
	 .END
                                                                             