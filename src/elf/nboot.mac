	TITLE NBOOT -- PDP-11 NETWORK BOOTSTRAP
	SUBTTL E. R. MADER -- APRIL 30, 1974

	SEARCH STENEX
	OPDEF SNDIM [JSYS 750]
	OPDEF RCVIM [JSYS 751]
	OPDEF ASNSQ [JSYS 752]
	OPDEF RELSQ [JSYS 753]


;
; AC ASSIGNMENTS
;

	JS=4				; JOBSYM PUT HERE
	I=5				; INDEX INTO INDEX PAGE
	LC=6				; LOCATION COUNTER
	B=7				; USED FOR BYTE BOPING
	C=10				; PDP-11 WORD CODE ICI
	BC=11				; FREE BYTE COUNT
	WD=12				; INDEX INTO DATA PAGE
	W=13				; DATA TRANSFERED THROUGH HERE
	W1=14				; FIRST OF 9 PACKED BYTES
	W2=15				; SECOND OF 9 PACKED BYTES
	CNT=16				; COUNT OF SAME
	P=17				; PUSH DOWN POINTER



;
; DATA AREAS
;

	IDXPAG==4			; INDEX PAGE MAPED HERE
	IDX=IDXPAG_9			; ADDRESS OF INDEX PAGE
	DATPAG==5			; DATA PAGES MAPPED HERE
	DAT=DATPAG_9			; ADDRESS OF DATA PAGE
	OUTBUF=7000			; OUTPUT BUFFER
	INBUF=10000			; INPUT BUFFER
	DATBUF=6000			; DATA BUFFER
	MAXBYT==1000			; NUMBER OF BYTES IN BUFFER
	PDP=11000			; PUSH DOWN LIST


;
;    VARIOUS ASSEMBLY PARAMATERS
;

	.LINK=377			; LINK TO USE FOR MESSAGES
	TIMOUT=^D15*^D1000		; NUMBER OF SECONDS TO TIMEOUT



	LOC 1000			; CODE STARTS ON PAGE 1

NBOOT:	RESET				; RESET NIFTY STUFFS
	MOVE	P,[IOWD 1000,PDP]	; SET UP STACK POINTER
	HRROI	1,HEARLD
	PSOUT				; IDENTIFY SELF
	MOVSI	1,(1B0+1B1)		; CREATE AN INFERIOR WITH --
	CFORK				; -- SAME MAP AS ME
	JRST	CFORKX			; FAILED - YELL AND SCREAM
	MOVEM	1,FHAN			; SAVE IT FOR LATER USE
	MOVEI	1,400000
	MOVE	2,[LEVTAB,,CHNTAB]
	SIR				; SET UP INTERRUPT SYSTEM
	EIR				; ENABLE INTERRUPT SYSTEM
	PUSHJ	P,NETINI		; SET UP THE NETWORK IO
GETIN:	MOVEI	1,37
	PBOUT				; TYPE A EOL
	HRROI	1,[ASCIZ "INPUT FILE: "]
	PSOUT				; ASK FOR A FILE NAME
	MOVSI	1,60003			; SHORT FORM, FROM TTY
	MOVE	2,[100,,101]
	GTJFN				; GET A JFN
	JRST	GETINX			; FAILED - TRY AGAIN
	MOVEM	1,INJFN			; SAVE FOR FUTURE REFERENCE
	DVCHR				; FIND OUT ABOUT DEVICE
	HLRZS	1			; GET TYPE
	ANDI	1,777			; ONLY 9 BITS
	JUMPN	1,BININ			; BINARY IF NOT DISK
	MOVE	1,INJFN			; RESTORE JFN
	MOVE	2,[1,,11]		; WORD 11 IN FDB
	MOVEI	3,3			; TO AC 3
	GTFDB				; GET IT
	LDB	2,[POINT 6,3,11]	; GET BYTE SIZE
	CAIE	2,44			; 36?
	JRST	BININ			; NO - ASSUME IS BINARY




;
;    HERE IF FILE IS IN SSAVE FORMAT (I.E. NOT BINARY).
;

	MOVE	2,[44B5+1B19]		; 36 BITS, READ
	OPENF				; OPEN THE FILE
	JRST	GETINX			; FAILED - TRY AGAIN



;
;
;    SET UP THE INDEX PAGE AT IDX. MAP IN PAGE 0 AND
;  GET JOBSYM(LOC 116) AS AN INDICATION OF WHERE TO STOP.
;  PDP-11 CORE WILL BE DUMPED STARTING AT LOCATION 400.
;
;

	MOVEI	LC,400			; LOCATION COUNTER STARTS AT 400
	PUSHJ	P,OUTINI		; SET UP THE BUFFER
	HRLZ	1,INJFN			; PAGE ZERO FROM INJFN --
	MOVE	2,[400000,,IDXPAG]	; -- TO PAGE IDX OF THIS FORK
	MOVSI	3,(1B2)			; READ ACCESS
	PMAP				; DO THE MAPPING
	MOVN	I,IDX			; -CODE,,-NUMBER OF PAGES
	HRLZ	I,I			; -NUMBER OF PAGES,,0
	HRRI	I,1			; NOW I IS A GOOD AOBJN POINTER
	HRR	1,IDX(I)		; ADDRESS OF PAGE 0
	HRRI	2,DATPAG		; TO DAT
	PMAP				; MAP IT!
	HRRZ	JS,DAT+116		; RH(JOBSYM), END
	SKIPGE	DAT+117			; ANY UNDEFINED SYMBOLS?
	HRRZ	JS,DAT+117		; YES - STOP THERE INSTEAD



;
;
;    CYCLE THROUGH ALL PAGES OUTPUTING PDP-11
;  BYTES VIA DATBUF. THE CODES IN THE LH OF THE '10 WORDS
; INDICATE HOW TO DEAL WITH THE BYTES. CODES ARE:
;
;      -1	IGNORE THIS BYTE
;	0	NO DATA HERE, PROGRAM BREAK
;	1	ONE PDP-11 BYTE
;	2	TWO PDP-11 BYTES IN LOWER 16 BITS
;  20000X	NEGATIVE RELOCATION FIXUP (SUBTRACT ADDRESS FROM DATA)
;
;


	SKIPA	WD,[-1000+400,,400]	; PAGE ZERO "STARTS" AT 400
GETPAG:	MOVSI	WD,-1000		; AOBJN POINTER INTO DAT
GETWRD:	SKIPGE	W,DAT(WD)		; ANY BYTES IN THIS WORD?
	JRST	IGNORE			; NO - IGNORE IT THEN
	HLRZ	C,DAT(WD)		; YES - GET CODE
	JUMPE	C,BREAK			; 0 => PROGRAM BREAK
GETWD2:	TRZE	C,200000		; NEED FIXUP?
	SUBI	W,0(LC)			; YES - DO IT
	CAILE	C,2			; VALID?
	Z				; NO - CHUCK IT
	CAIGE	BC,0(C)			; ROOM FOR THESE BYTES?
	PUSHJ	P,OUT			; NO - EMPTY BUFFER
	SUBI	BC,0(C)			; COUNT THESE BYTES
	LDB	B,LOWPNT		; GET THE LOW ORDER BYTE
	IDPB	B,OUTPNT		; PUT INTO BUFFER
	CAIE	C,2			; ANOTHER BYTE HERE?
	JRST	GETNXT			; NO - GET NEXT WORD
	LDB	B,HGHPNT		; YES - FETCH IT
	IDPB	B,OUTPNT		; PUT INTO BUFFER
GETNXT:	ADDI	LC,0(C)			; UPDATE LOCATION COUNTER
	CAIL	LC,0(JS)		; HAVE WE BUMPED SYMBOLS?
	JRST	FINSAV			; YES - WE'RE THROUGH
IGNORE:	AOBJN	WD,GETWRD		; NO - DO THE WHOLE PAGE
	PUSHJ	P,NXTPAG		; NONE LEFT - ADVANCE TO NEXT
	JRST	GETPAG			; AND CONTINUE

;
;  HERE ON PROGRAM BREAK
;

BREAK:	TRNN	LC,1			; START ON ODD ADDRESS?
	JRST	BREAK2			; NO - JUST FINE
	IDPB	C,OUTPNT		; YES - OUTPUT A ZERO BYTE
	SOJA	BC,BREAK2		; AND COUNT IT

BREAK1:	HLRZ	C,DAT(WD)		; GET THE CODE
	JUMPN	C,BRKDUN		; NON-ZERO => END OF BREAK
BREAK2:	AOJ	LC,			; INCREMENT LOCATION COUNTER
	CAIL	LC,0(JS)		; BUMPED SYMBOL TABLE?
	JRST	FINSAV			; YES - FINISH IT OFF
	AOBJN	WD,BREAK1		; NO - KEEP GOING
	PUSHJ	P,NXTPAG		; FINISHED PAGE - GET ANOTHER
	MOVSI	WD,-1000		; A NEW AOBJN POINTER
	JRST	BREAK1			; KEEP ON TRUCKIN'
BRKDUN:	MOVE	W,DAT(WD)		; GET THE WORD FOUND
	PUSHJ	P,OUT			; OUTPUT BUFFER
	TRNN	LC,1			; END ON EVEN ADDRESS?
	JRST	GETWD2			; YES - THAT'S JUST FINE
	SETZ	B,			; NO - THEN SEND OUT A --
	IDPB	B,OUTPNT		; -- ZERO BYTE FIRST
	SOS	ARG1			; MAKE LOAD ADDRESS EVEN
	SOJA	BC,GETWD2		; COUNT THIS BYTE AND CONTINUE



;
;    HERE WHEN THE CODE IS ALL LOADED
;

FINSAV:	AOBJN	I,.			; FIND STARTING ADDRESS
	HRRZ	1,IDX(I)		; LOAD IT UP
	PUSHJ	P,OUT			; DUMP LAST BLOCK
	JRST	FINISH			; AND FINISH OFF



;
;    ROUTINE TO ADVANCE TO THE NEXT SOURCE PAGE
;

NXTPAG:	AOBJN	I,.+1			; ADDRESS NEXT INDEX WORD
	PUSH	P,LC			; SAVE L. C. FOR BREAK TEST
	HRR	1,IDX(I)		; GET NEXT FILE PAGE NUMBER
	PMAP				; MAP IT INTO DAT
	LDB	LC,[POINT 9,IDX(I),17]	; GET CORE PAGE NUMBER
	LSH	LC,9			; MAKE AN ADDRESS
	CAME	LC,0(P)			; IS IT THE NEXT ONE?
	PUSHJ	P,OUT			; NO - OUTPUT BUFFER
	SUB	P,[2,,2]		; ADJUST STACK
	JRST	@1(P)			; RETURN



;
;    HERE IF INPUT FILE IS IN BINARY FORMAT
;

BININ:	MOVE	2,[8B5+1B19]		; 8 BIT BYTES, READ
	OPENF				; OPEN FOR INPUT
	JRST	GETINX			; CAN'T - TRY AGAIN
	SETO	LC,			; AN UNLIKELY ADDRESS
	PUSHJ	P,OUTINI		; INIT THE BUFFER
	SETZ	I,			; A ZERO FOR LATER

;
;    READ IN ONE LOAD BLOCK FROM THE FILE
;

BINBLK:	BIN				; READ ONE BYTE
	SOJN	2,BINBLK		; LOOP 'TILL WE GET A 1
	BIN				; SKIP THE ZERO WHICH IS NEXT
	PUSHJ	P,IN16			; READ A WORD --
	MOVEI	C,-6(3)			; -- AS THE BYTE COUNT
	PUSHJ	P,IN16			; READ A WORD --
	MOVEI	LC,0(3)			; -- AS THE LOAD ADDRESS
	MOVEM	LC,ARG1			; SET ARG1 CORRECTLY
	JUMPE	C,FINBIN		; ZERO LENGTH IS JUMP BLOCK



;
;    SEND THE BLOCK AS A SERIES OF OF DEPOSIT COMMANDS
;

BINDEP:	MOVE	2,[POINT 8,DATBUF]	; POINTER FOR OUTPUTTING BYTES
	TRNN	LC,1			; LOAD INTO ODD ADDRESS?
	JRST	BINDE2			; NO - THAT MAKES IT EASY
	IDPB	I,2			; YES - OUTPUT A ZERO BYTE
	SOS	ARG1			; POINT ARG1 TO EVEN ADDRESS
	SOJ	BC,			; AND COUNT ONE BYTE
BINDE2:	MOVNI	3,0(C)			; ASSUME CAN USE WHOLE BLOCK
	CAILE	C,0(BC)			; CAN WE?
	MOVNI	3,0(BC)			; NO - JUST FILL BUFFER
	ADD	BC,3			; COUNT THE BYTES
	ADD	C,3			; COMPUTE THE NUMBER LEFT TO GO
	SUB	LC,3			; AND THEIR LOAD ADDRESS
	SIN				; READ IN THE BYTES
	TRNN	LC,1			; FILL A WORD?
	JRST	BINDE3			; YES - JUST GREAT
	IDPB	I,2			; NO - PAD WITH A ZERO
	SOJ	BC,			; COUNT THE ZERO
BINDE3:	PUSHJ	P,OUT			; SEND THE BUFFER
	JUMPG	C,BINDEP		; LOOP TILL WHOLE BLOCK IS SENT
	BIN				; SKIP THE CHKSUM
	JRST	BINBLK			; READ THE NEXT BLOCK

;
;    HERE WHEN ALL BLOCKS LOADED
;

FINBIN:	MOVEI	1,0(LC)			; GET LOAD ADDRESS
	JRST	FINISH			; AND FINISH UP



;
;    ROUTINE TO READ A PDP-11 WORD FROM THE BINARY FILE
;

IN16:	BIN				; READ LOW ORDER BYTE
	MOVEI	3,0(2)			; SAVE IT
	BIN				; READ THE HIGH ORDER BYTE
	LSH	2,8			; SHIFT IT INTO PISITION
	IORI	3,0(2)			; AND PUT IT IN PLACE
	POPJ	P,			; AND RETURN IT IN 3






;
;    HERE WITH STARTING ADDRESS IN 1 WHEN ALL CODE HAS BEEN
;  LOADED. IF STARTING ADDRESS IS ODD, JUST GET MORE
;  TO DO, OTHERWISE DEPOSIT IT INTO THE STATE VECTOR AND RESUME
;  THE PDP-11.
;

FINISH:	TRNE	1,1			; ODD?
	JRST	FINIS2			; YES - DON'T START YET
	MOVEI	2,7			; NO - DEPOSIT STATE COMMAND
	MOVEM	2,CMD
	MOVEI	2,2*7			; INTO PC
	MOVEM	2,ARG1
	MOVEI	2,2			; TWO BYTES WORTH
	MOVEM	2,ARG2
	PUSHJ	P,CMDOUT		; PUT COMMAND INTO BUFFER
	PUSH	P,1			; SAVE ST. ADDR. FOR PRINTING
	MOVEI	B,0(1)			; GET STARTING ADDRESS
	PUSHJ	P,OUTBYT		; SEND OUT LOW 8 BITS
	MOVEI	B,0(1)			; NOW GET THE --
	LSH	B,-8			; -- HIGH 8 BITS --
	PUSHJ	P,OUTBYT		; -- AND SEND THEM OUT
	PUSHJ	P,SNDMSG		; SEND MESSAGE, GET REPLY
	SETZM	ARG1			; CLEAR THE --
	SETZM	ARG2			; -- ARGUEMENTS
	MOVEI	2,5			; THE RESUME COMMAND
	MOVEM	2,CMD
	PUSHJ	P,CMDOUT		; WRITE A COMMAND
	PUSHJ	P,SNDMSG		; SEND IT AND GET A ANSWER
	SETO	1,
	RELSQ				; RELEASE THE SPECIAL QUEUE
	PUSHJ	P,FINIO			; CLEAN UP FILE STUFF
	HRROI	1,[ASCIZ "STARTED AT "]
	PSOUT				; ANNOUNCE STARTING ADDRESS
	MOVEI	1,101			; TO TTY
	POP	P,2
	MOVEI	3,10			; IN OCTAL
	NOUT
	0				; HAD SHOULD OUGHTA WORK
	MOVEI	1,37
	PBOUT				; A EOL TOO
	HALTF

FINIS2:	HRROI	1,[ASCIZ "LOADED."]
	PSOUT
	MOVEI	1,37
	PBOUT
	PUSHJ	P,FINIO
	JRST	GETIN


;
;    ROUTINE TO CLEAN THE FILE IO.
;

FINIO:	SETO	1,
	CLOSF
	0
	HRLZI	2,400000		; REMOVE THE FILE --
	HRRI	2,IDXPAG		; -- PAGES FROM --
	PMAP				; -- OUR ADDRESS --
	HRRI	2,DATPAG		; -- SPACE
	PMAP
	POPJ	P,



;
;
;    ROUTINE TO OUTPUT CURRENT BUFFER.
;
;

OUT:	CAIN	BC,MAXBYT		; ANYTHING IN THIS BUFFER?
	JRST	OUTNUL			; NO - JUST UPDATE LOAD ADDRESS
	PUSH	P,1			; SAVE THE --
	PUSH	P,2			; -- PMAP ARGUEMENTS --
	PUSH	P,3			; -- ON THE STACK
	MOVEI	3,MAXBYT		; COMPUTE NUMBER OF --
	SUBI	3,0(BC)			; -- BYTES TO STORE
	MOVEM	3,ARG2			; PUT IN ARG2
	MOVEI	2,4			; DEPOSIT COMMAND
	MOVEM	2,CMD
	PUSHJ	P,CMDOUT		; WRITE A COMMAND
	MOVE	2,[POINT 8,DATBUF]	; PTR TO DATA BYTES
OUTL2:	ILDB	B,2			; GET A DATA BYTE
	PUSHJ	P,OUTBYT		; SEND IT OUT
	SOJG	3,OUTL2			; DO THEM ALL
	PUSHJ	P,SNDMSG		; SEND THE MESSAGE, GET REPLY
	POP	P,3			; RESTORE THE --
	POP	P,2			; -- PMAP ARGUEMENTS --
	POP	P,1			; -- FROM THE STACK

;
;    HERE TO SET UP FOR NEXT BUFFER
;

OUTINI:	MOVE	B,[POINT 8,DATBUF]
	MOVEM	B,OUTPNT		; NEW OUTPUT POINTER
	MOVEI	BC,MAXBYT		; WHOLE BUFFER NOW LEFT
OUTNUL:	MOVEM	LC,ARG1			; LOAD ADDRESS OF BUFFER
	SETZB	W1,W2			; CLEAR BYTE COLLECTERS
	MOVEI	CNT,9			; NINE TO GO NOW
	POPJ	P,			; RETURN



;
;    ROUTINE TO COMPOSE A COMMAND
;

CMDOUT:	SETZM	OUTBUF			; CLEAR THE WORD COUNT
	MOVEI	2,OUTBUF+1		; POINT STORE PTR --
	MOVEM	2,OUTLOC		; -- TO FIRST DATA WORD IN BUF
	MOVSI	2,-CMDL			; AOBJN PTR TO CMDTAB
CMDOU1:	LDB	B,CMDTAB(2)		; GET A BYTE
	PUSHJ	P,OUTBYT		; STUFF IT IN THE BUFFER
	AOBJN	2,CMDOU1		; DO THE WHOLE THING
	POPJ	P,			; THEN EXIT


;
;    ROUTINE TO OUTPUT THE BYTE IN B
;

OUTBYT:	ANDI	B,377			; ONLY 8 BITS
	LSHC	W1,8			; SHIFT OVER OLD STUFF
	IORI	W2,0(B)			; INCLUDE NEW BYTE
	SOJLE	CNT,OUT2		; COUNT, JUMP IF FULL
	POPJ	P,			; EXIT IF NOT


OUT2:	MOVE	B,W1			; OUTPUT THE --
	PUSHJ	P,OUT1			; -- FIRST WORD
	MOVE	B,W2			; AND THE SECOND
	SETZB	W1,W2			; FIX THE BYTE STUFFIES
	MOVEI	CNT,9
OUT1:	MOVEM	B,@OUTLOC		; STORE THE WORD
	AOS	OUTLOC			; UPDATE THE STORE POINTER
	AOS	OUTBUF			; BUMP THE WORD COUNT
	POPJ	P,			; EXIT




SNDMSG:	CAIN	CNT,9			; ANY STRAY BYTES?
	JRST	SNDMS2			; NO - JUST SEND THE BUFFER
	IMULI	CNT,8			; YES - FIND OFFSET
	LSHC	W1,0(CNT)		; LEFT JUSTIFY THEM
	PUSHJ	P,OUT2			; AND SEND THEM OUT
SNDMS2:	SETZ	B,			; SEND A ZERO WORD --
	PUSHJ	P,OUT1			; -- JUST FOR LUCK
SNDXMT:	MOVE	1,SQH			; GET THE QUEUE HANDLE
	MOVEI	2,OUTBUF		; ADDRESS THE BUFFER
	SNDIM				; SEND THE BUFFER
	0				; BETTER WORK !!!!
	MOVE	1,FHAN
	MOVEI	2,TIMER
	SFORK				; START TIMER FORK
SNDWAT:	MOVEI	1,400000
	MOVSI	2,(1B0)
	AIC				; ALLOW INTERRUPT ON CHANNEL 0
	SETOM	TFLAG			; SAY TIMER SHOULD INTERRUPT
	MOVE	1,SQH			; GET THE QUEUE HANDLE BACK
	MOVEI	2,INBUF			; ADDRESS THE INPUT BUFFER
	RCVIM				; FILL IT
	0				; BETTER WORK!!
	SETZM	TFLAG			; TELL TIMER NOT TO INTERRUPT
	MOVEI	1,400000
	MOVSI	2,(1B0)
	DIC				; SHUT OFF THE INTERRUPT
	MOVE	1,FHAN
	HFORK				; AND HALT THE TIMER
	MOVE	3,OUTBUF+1
	MOVE	2,INBUF+1
	CAME	2,3
	JRST	SNDWAT
	MOVE	3,OUTBUF+2
	MOVE	2,INBUF+2
	CAME	2,3
	JRST	SNDWAT
	MOVE	3,OUTBUF+3
	AND	3,[BYTE (8) 377,0,0,0]
	MOVE	2,INBUF+3
	AND	2,[BYTE (8) 377,0,0,0]
	CAME	2,3
	JRST	SNDWAT
	POPJ	P,			; PRETTY NEET, HUH??



;
;    HERE IF TIMER FORK INTERRUPTS, SET TO RESTART AT SNDXMT
;  TO CAUSE RE-TRANSMISSION OF LAST MESSAGE.
;


TIMINT:	PUSH	P,1
	MOVEI	1,SNDXMT		; RETURN TO --
	MOVEM	1,TIMPC			; -- RE-TRANSMIT
	POP	P,1
	DEBRK				; DISMIS



;
;    THIS IS THE TIMER FORK. IT DISMISSES FOR THE SPECIFIED
;  PERIOD OF TIME AND INTERRUPTS ITS SUPERIOR ON CHANNEL 0 IF
;  TFLAG IS NON-ZERO
;

TIMER:	MOVE	1,[TIMOUT]
	DISMS				; GO TO SLEEP
	SETO	1,
	MOVSI	2,(1B0)
	SKIPE	TFLAG			; SHOLD WE INTERRUPT?
	IIC				; YES - POKE SUPERIOR ON CH. 0
	HALTF				; AND HALT





;
; ROUTINE TO SET-UP THE NETWORK IO. PROMPTS USER FOR A HOST ADDRESS,
; ASSIGNS A SPECIAL FOR THAT HOST AND ENABLES THE NETWIZ CAPABILITY.
;

NETINI:	SETO	1,
	RELSQ				; RELEASE ALL SPECIAL Q'S
	MOVEI	1,400000		; GET THE CAPABILITIES --
	RPCAP				; -- OF THIS FORK
	TRNN	2,20000			; CAN THE GUY NETWIZ?
	JRST	NTWZX			; NO - TOO BAD FOR HIM!
	IORI	3,20000			; YES - THEN LET HIM --
	EPCAP				; -- DO IT
NETIN2:	HRROI	1,[ASCIZ "HOST: "]
	PSOUT				; ASK FOR A HOST ADDRESS
	MOVEI	1,100			; GET AN OCTAL HOST --
	MOVEI	3,10			; -- ADDRESS FROM THE --
	NIN				; -- TELETYPE
	JRST	NETINX			; FAILED - TRY AGAIN
	BKJFN				; BACK UP TTY
	0				; SHOULD HAD OUGHTA WORK
	PBIN				; READ LAST CHARACTER
	CAIE	1,37			; A EOL?
	JRST	NETINX			; NO - YELL A WHOLE BUNCH
	ANDI	2,377			; TAKE ONLY 8 BITS
	MOVEM	2,HOST			; SAVE FOR LATER USE
	MOVE	1,[BYTE (8) 17,377,377,0]
	LSH	2,24			; SHIFT INTO HOST POSITION
	IOR	2,[BYTE (8) 0,0,.LINK,0]
	ASNSQ				; ASSIGN A SPECIAL Q
	JRST	ASNQX			; FAILED - TRY AGAIN
	MOVEM	1,SQH			; SAVE IT FOR LATER
	PUSHJ	P,OUTINI		; INIT OUTPUT BUFFERS
	SETZM	ARG1			; ZERO ARGS.
	SETZM	ARG2
	MOVEI	2,1			; THE DEBUG OP-CODE
	MOVEM	2,CMD
	PUSHJ	P,CMDOUT		; COMPOSE THE COMMAND
	JRST	SNDMSG			; SEND AND RETURN TO CALLER


NETINX:	HRROI	1,[ASCIZ " ?
"]
	PSOUT
	JRST	NETIN2




CFORKX:	HRROI	1,[ASCIZ "
COULD NOT GET A FORK!!!
"]
	PSOUT
	HALTF
	JRST	NBOOT



NTWZX:	HRROI	1,[ASCIZ "
YOU AIN'T A NET WIZZARD!!
"]
	PSOUT
	HALTF


ASNQX:	HRROI	1,[ASCIZ "
CANNOT ASSIGN SPECIAL QUEUE!
"]
	PSOUT
	HALTF
	JRST	NBOOT


GETINX:	HRROI	1,[ASCIZ " ?"]
	PSOUT
	JRST	GETIN





	RELOC				; DATA AREA ON PAGE ZERO!

INJFN:	Z
SQH:	Z
FHAN:	Z


CMD:	Z
ARG1:	Z
ARG2:	Z


;
;    TABLE OF POINTERS TO BYTES TO BUILD A COMMAND
;

CMDTAB:	POINT 0,0
	POINT 8,HOST,35
	POINT 8,LINK,35
	POINT 0,0
	POINT 0,0
	POINT 8,CMD,35
	POINT 8,ARG1,35
	POINT 8,ARG1,27
	POINT 8,ARG2,35
	POINT 8,ARG2,27

	CMDL=.-CMDTAB

HOST:	0
LINK:	.LINK

LOWPNT:	POINT	8,W,35		; LOW ORDER BYTE OF WORD
HGHPNT:	POINT	8,W,27		; HIGH ORDER BYTE OF WORD

LEVTAB:	TIMPC
	Z
	Z

CHNTAB:	1,,TIMINT
	REPEAT ^D35,<
	Z
	>

TFLAG:	Z
TIMPC:	Z




OUTPNT:	Z				; POINTER INTO DATBUF
OUTLOC:	Z



HEARLD:	ASCIZ "
PDP-11 NETWORK BOOTSTRAP 
"
	LIT				; LITERALS HERE TOO

	END	NBOOTî