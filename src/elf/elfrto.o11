	.TITLE	NETRTO - SCRL/ARPANET
	.MCALL	$NETHW,$CNFIG,$DFREG,$DISCC
	.MCALL	$STIME,$WAIT,$FREEB,$PUSH,$POP
	.NLIST	CND,ME
	$CNFIG
	$DFREG
	.LIST	ME
	$DISCC
	$NETHW

	.GLOBL	$APCT
	.GLOBL	$MS03,$MS04
	.GLOBL	$RTPOU,$DEAD,$OEIN,$OEOUT,$IHBIT,$RTOIU
	.GLOBL	$CHNLO,$HIQ,$DEQ,$FMQE
	.GLOBL	$TSET,$TGET
	.GLOBL	$VDHFL,$VDHCT


	.SBTTL	RELIABLE TRANSMISSION PACKAGE
	.PAGE
	.SBTTL	RTP - OUTPUT PROCESSOR

RTNCH = 2			;SETUP FOR 2-CHANNEL RTP

$RTPOU:
RTRS:	BITB	#1,$VDHFL	;NEED TO SEND 'I HEARD YOU' ?
	BEQ	RNIHY		;NO, SKIP OVER
	BICB	#1,$VDHFL	;CLEAR FLAG
	JSR	PC,ROSPI	;SEND I HEARD YOU PACKET
RNIHY:	BIT	#TIM,@$APCT	;HAS TIMER GONE OFF?
	BEQ	RNHELL		;NO HELLO PACKET TO BE SENT
	TSTB	$DEAD		;ARE WE WAITING 2*T*R ?
	BGT	RNEIT		;WAIT SOME MORE
	BMI	RN2D		;COMING UP, SEND HELLO
	DEC	$VDHCT		;DECREMENT COUNT IF ALIVE
	BGE	RN2D		;NOT DEAD YET
	MOVB	#1,$DEAD	;DECLARE LINK TO IMP DEAD!
	BR	RTODW		;WAIT 2*T*R SECS
RN2D:	JSR	PC,ROSPH	;SEND 'HELLO' PACKET
RNEIT:	$STIME	1250.		;SET TIMER TO 1.25 SEC
RNHELL:	TSTB	$DEAD
	BNE	RTORT		;BACK TO WAIT
	MOV	#$HIQ,R2	;ANYTHING ON QUEUE?
	JSR	PC,$DEQ		;ATTEMPT TO REMOVE IT
	BNE	RTSNDM		;GOT ONE, SEND IT
	BIT	#ACK,@$APCT	;ACK OR MSG TO BE SENT?
	BNE	RSN		;ACK MESSAGE RCD WITH NULL PACKET
RTORT:	$WAIT			;GO TO SLEEP
	BR	RTRS		;TEST OUTPUT CONDITIONS AGAIN

	.PAGE
	.SBTTL	OUTPUT MESSAGE CONTROL

RTSNDM:	MOV	R0,MQPT		;SAVE MESSAGE QUEUE POINTER
	BIC	#ACK,@$APCT	;CLEAR ACK FLAG
	MOV	-(R0),AMSG	;GET ADDRX OF MESSAGE
	MOV	-(R0),POOLID	;GET POOLID
	MOV	-(R0),MSGL	;MESSAGE LENGTH

;		***
;		***  WE HAVE WORK TO DO
;		***  I.E., THERES A MESSAGE
;		***  ON THE HOST/IMP QUEUE
;		***


	CLR	MSGNDX		;INITIALIZE INDEX TO MESSAGE
;			TRANSMIT THE NEXT PACKET IN A
;			MESSAGE
PCHNL:	MOV	$CHNLO,R0	;GET CHNL NR
	TSTB	$RTOIU(R0)	;TEST OUTPUT IN USE
	BEQ	RTSND		;NOT IN USE, READY-TO-SEND
	JSR	PC,RESEND	;RE TRANSMIT MESSAGE
PCHW2:	$WAIT			;WAIT FOR COMPL
	BIT	#IO,-(R4)	;SEE IF COMPLETE
	BEQ	PCHW2		;BRANCH IF NOT COMPLETE
	BR	PCHNL		;OK, RETRY THIS CHANNEL
RTODW:	$STIME	10000.		;WAIT 10 SECS.
RTODWW:	$WAIT
	BIT	#TIM,-(R4)	;TIMER GONE OFF?
	BEQ	RTODWW
	BR	RTRS		;RE-START VDH
RTSND:	INCB	$RTOIU(R0)	;SET IN-USE FLAG
	ASL	R0
	MOV	OBUFL(R0),R2	;GET OUTPUT BUFFER ADDRX
	TST	MSGNDX		;IS THIS THE FIRST PACKET IN MSG
	BNE	RREMSG		;SEND REMAINDER
	MOV	AMSG,R1		;SEND ONLY LEADER IN FIRST PACKET
	MOV	#2,R3		;SET LENGTH EQ 2 WORDS
RTS2:	JSR	PC,SENDIT	;INITIATE TRANSMISSION OF MSG
RTS3:	$WAIT			;WAIT FOR MSG TO BE SENT
	TSTB	$DEAD		;HAVE WE KONKED?
	BNE	RTODW		;DEAD-WAIT CONDITION
	BIT	#IO,-(R4)	;IO POSTED?
	BEQ	RTS3		;WAIT FOR IO COMPLETE
	MOV	$CHNLO,R0	;GET CHNL NR
	INC	R0		;ADVANCE TO NEXT
	CMP	R0,#RTNCH	;IS THAT THE LAST CHNL?
	BLT	.+4		;NOPE
	CLR	R0		;YUP, RESET TO BEGIN
	MOV	R0,$CHNLO	;UPDATE $CHNL

	CMP	MSGNDX,MSGL	;DID WE FINISH MSG?
	BLT	PCHNL		;NOPE

			;MESSAGE HAS BEED SUCCESSFULLY
			;TRANSMITTED...
			;SEE IF WE HAVE MORE.

	TST	$HIQ		;ARE THERE ANY MORE TO GO OUT?
	BNE	RTRS		;CHECK FOR RE-TRANSMISSIONS ON NEXT
	BIS	#ACK,@$APCT	;ELSE CAUSE RETRANSMISSIONS
	BR	RTRS		;BY SENDING NULL PACKET REQUEST

RSN:	CLR	R0		;SEE IF ANY ARE LEFT OUTSTANDING
	BIC	#ACK,@$APCT	;CLEAR ACK FLAG
ROQTB:	TSTB	$RTOIU(R0)	;ANY CHNLS BZY?
	BEQ	RTOSCN		;NO, NOT THIS ONE
	$PUSH	R0
	JSR	PC,RESEND	;RE-INIT TRANSMISSION
ROQ0:	$WAIT			;FOR IO
	BIT	#IO,-(R4)
	BEQ	ROQ0
	$POP	R0
RTOSCN:	INC	R0		;INCREMENT INDEX
	CMP	R0,#RTNCH	;SENT ALL CHNLS?
	BLT	ROQTB		;LOOP THRU THEM
	JSR	PC,ROSNUL	;SEND NULL
	JMP	RTRS		;RESTART

RREMSG:	MOV	MSGL,R3		;XFER MESSAGE LENGTH
	SUB	MSGNDX,R3	;HOW MUCH IS THERE TO GO?
	CMP	R3,#63.		;TRIM
	BLE	.+6
	MOV	#63.,R3		;TO 63 IF GT 63
	MOV	MSGNDX,R1	;GET BUFFER ADDRX
	ASL	R1		;IN BYTES
	ADD	AMSG,R1		;ADD TO BASE OF BUFFER
	BR	RTS2		;BACK TO ISSUE SENDIT

ROSPH:	MOV	#300,R0		;SETUP TO SEND 'HELLO' PACKET
	BR	ROSCOM		;SEND SPECIAL PACKET
ROSPI:	MOV	#100300,R0	;SETUP FOR 'I HEARD YOU'
	BR	ROSCOM		;SEND SPECIAL PACKET


ROSNUL:	MOV	#200,R0		;SET 'FOR-IMP' BIT
	BISB	$OEIN,R0	;OR IN RECEIVE ACK BITS
ROSCOM:	MOV	R0,RTONP	;MOVE TO NULL PACKET
	MOV	R5,-(SP)	;SAVE RETURN ADDRESS
	MOV	#VDHSO,R3	;ADDR OF HW REG
	BIC	#TMPT,(R3)	;POINT TO DATA MAR
	MOV	#RTONP,@#VDHMO	;PUT ADDR OF NUL PACKET IN MAR
	MOV	#1,@#VDHWO	;SET WORD COUNT 1
	BIC	#IO+ACK,@$APCT	;CLEAR MY IO DISPATCH FLAG
	BIS	#1,(R3)		;OR IN GO BIT
RTOW2:	$WAIT			;WAIT FOR I/O INTRPT
	BIT	#IO,-(R4)	;IS THIS IO
	BEQ	RTOW2		;HANG TEN UNTIL I/O CMP
	MOV	(SP)+,R5	;RESTORE RET ADDRX
	RTS	PC		;RETURN

;		*** OUTPUT CONTROLLER ***
;			R1 = MSG BUFFER ADDR
;			R2 = PACKET BUFFER ADDR
;			R3 = NUMBER OF WORDS TO SEND

SENDIT:	MOV	R3,R0		;XFER NR WDS
	INC	$MS03		;INCR NR ORIGINAL XMISSIONS
	SWAB	R0		;INTO WORD COUNT
	BIS	#200,R0		;SET 'FOR IMP'
	BISB	$OEIN,R0	;FETCH ACKNOWLEDGE BITS
	BIS	$CHNLO,R0	;GET CHNL NUMBER
	MOV	#12.,R4	;MOVE NR SHIFTS
	SUB	$CHNLO,R4	;SHIFT LEFT BY
	$PUSH	R0		;SAVE R0, CURRENT
	MOVB	$OEOUT,R0	;GET ODD/EVEN OUTPUT BITS
SEASL:	ASL	R0		;SHIFT (R4) TIMES
	DEC	R4		;TALLY
	BGT	SEASL
	BIC	#137777,R0	;CLEAR ALL BUT ODD/EVEN BIT
	BIS	(SP)+,R0	;OR ODD/EVEN BIT INTO CTRL WORD
	ADD	R3,MSGNDX	;BUMP INDEX
	CMP	MSGNDX,MSGL	;IS THIS THE LAST
	BLT	.+6		;BRANCH IF NO
	BIS	#100000,R0	;ELSE SET 'LAST PACKET'
	MOV	R0,(R2)+	;STORE CONTROL WORD
	MOV	R3,R0		;MOVE WORD COUNT
	MOV	(R1)+,(R2)+	;STORE DATA IN PACKET BUFFER
	.IF EQ	P1140!P1145-1
	SOB	R0,.-2		;LOOP FOR NR WORDS IN PACKET
	.IFF
	DEC	R0		;TALLY
	BGT	.-4		;AND XFER THE WHOLE BUFFER
	.ENDC
	INC	R3		;INCLUDE CONTROL WORD
	SUB	R3,R2		;RECOVER
	SUB	R3,R2		;MESSAGE POINTER
	BIC	#TMPT,@#VDHSO	;RESET TIMER POINTER
	MOV	R3,@#VDHWO	;STORE WORD COUNT
	MOV	R2,@#VDHMO	;AND BUFFER ADDRESS
	BIC	#IO,@$APCT	;CLEAR IO FLAGS
	BIS	#1,@#VDHSO	;START OUTPUT
	RTS	PC		;RETURN

RESEND:	ASL	R0		;CHNLNR * 2
	INC	$MS04		;INCREMENT NR RETRANSMISSIONS
	MOV	OBUFL(R0),R2	;GET BUFFER ADDR
	MOV	(R2),R0		;GET CONTROL WORD
	BIC	#74,R0		;UPDATE ACK BITS
	BISB	$OEIN,R0	;IN CONTROL WORD
	MOV	R0,(R2)		;STORE BACK IN BUFFER
	SWAB	R0		;EXTRACT WORD COUNT
	BIC	#177700,R0	;CLEAR OTHER BITS
	INC	R0		;INCLUDE CONTROL WORD
	BIC	#TMPT,@#VDHSO	;RESET TIMER POINTER
	MOV	R0,@#VDHWO	;SET HWR
	MOV	R2,@#VDHMO	;SET MAR
	BIC	#IO,@$APCT	;RESET IO FLAG IN MY PCT C.B.
	BIS	#1,@#VDHSO	;RESTART BUFFER (TRY AGAIN)
	RTS	PC

	.PAGE
	.SBTTL	I/O ROUTINES TO READ/WRITE VDH TIMER

;			----------

;			$TGET GETS CURRENT TIMER SETTING IN
;			MILLISECONDS. TIME VALUE IS ASSUMED IN R0

;			----------

$TGET:	BIS	#TMPT,@#VDHSO	;SET TIMER POINTER IN STAT
	.IF EQ	PMDV!PEAE	;NEITHER EAE NOR MULDIV ?
	MOV	@#VDHBO,R1	;CURRENT TIMER VAL TO R1
	CLR	R0		;PREPARE FOR SHIFT
	ASL	R1		;SHIFT LEFT 3
	ROL	R0
	ASL	R1
	ROL	R0		;DOUBLE SHIFT
	ASL	R1		;TO GET TIMER VAL TIMES 8
	ROL	R0		;IN REGS R0,R1
	MOV	R0,$AC		;SET LEFT HALF DIVIDEND
	MOV	R1,$MQ		;SET RIGHT HALF DIVIDEND
	MOV	#1000.,$XDVSR	;SET DIVISOR EQUAL TO 1000.
	JSR	PC,$DIV		;DIVIDE TO OBTAIN TIME IN MS.
	MOV	$MQ,R0		;PLACE QUOTIENT IN REG 0
;				 R0 NOW IS TIME-TO-GO, MS.
	.ENDC
	.IF EQ	 P1105!P1110!P1120&PEAE-1
	MOV	@#VDHBO,@#MQ	;MOVE TIME-TO-GO
	CLR	@#AC		;INIT AC FOR LEFT SHIFT
	MOVB	#3,@#LSHFT	;SHIFT LEFT LOGICAL 3 BITS
	MOV	#1000.,@#XDVSR	;DIVIDE BY 1000.
	MOV	@#MQ,R0		;OBTAIN RESULT IN R0 - MILLISECS.
	.ENDC
	.IF EQ	P1140!P1145&PMDV-1	;MUL/DIV OPTION ON 40/45 ?
	CLR	R0			;INIT MULTIPLIER
	MOV	@#VDHBO,R1		;WITH BUFFER OUT
	ASHC	#3,R0		;MULTIPLY BY 8.
	DIV	#1000.,R0		;AND DIV BY 1000.
	.ENDC
	RTS	PC			;AND RETURN


;			----------

;			$TSET SETS THE TIMER TO A NUMBER OF
;			MILLISECONDS SPECIFIED IN R0. IF
;			R0 CONTAINS 0, THE TIMER IS TURNED OFF.

;			----------

$TSET:	TST	R0		;R0 = 0?
	BEQ	TCLRT		;YUP, TURN OFF TIMER
	.IF EQ	PMDV!PEAE	;NO EAE OR MULDIV?
	MOV	R0,$MQ		;PREPARE TO MULTIPLY
	MOV	#1000.,$XMUL	;BY 1000. TO GET TIME IN MICROSECS
	JSR	PC,$MUL		;MULTIPLY
	MOV	$AC,R0		;SHIFT RIGHT 3
	MOV	$MQ,R1		;IN R0,R1
	ASR	R0
	ROR	R1
	ASR	R0
	ROR	R1
	ASR	R0		;OBTAIN DESIRED SETTING IN R1
	ROR	R1		;WHICH IS IN 8-MICROSEC INTERVALS
	.ENDC
	.IF EQ	PEAE-1		;EAE?
	MOV	#MQ,R4
	MOV	R0,(R4)+	;TIME VALUE IN MS TO MQ
	MOV	#1000.,(R4)	;MULTIPLY BY 1000.
	MOVB	#-3,@#LSHFT	;SHIFT LOGICAL LEFT 3
	MOV	-(R4),R1	;MQ TO REG 1
	.ENDC
	.IF EQ	P1140!P1145&PMDV-1
	MUL	#1000.,R0	;MULTIPLY BY 1000. TO GET MICROSECS.
	ASHC	#-3,R0		;DIVIDE BY 8.
	.ENDC
	MOV	#VDHSO,R3	;FOR EFFICIENT ADDRESSING OF STAT REG
	BIS	#TMPT,(R3)+	;SET TIMER POINTER IN STAT
	MOV	R1,(R3)		;SET TIMER
	BIS	#TMRE+VDOIE,-(R3) ;SET TIMER RUN ENABLE AND INT ENABL
	RTS	PC		;AND RETURN

TCLRT:	BIC	#TMRE,@#VDHSO	;DISABLE TIMER
	RTS	PC		;AND RETURN
	.PAGE
	.SBTTL	RTP OUTPUT CONTROLLER DATA AREA

$RTOIU:	.REPT	RTNCH		;LIST OF OUTPUT CHNL STAT BYTES
	.BYTE	0
	.ENDR
RTONP:	.WORD	0		;CELL FOR USE AS NULL PACKET
AMSG:	.WORD	0		;ADDR OF CURRENT MSG
POOLID:	.WORD	0		;CURRENT BUFFER POOL DESCR
MSGL:	.WORD	0		;MSG LEN (WORDS)
MSGNDX:	.WORD	0		;CURRENT INDEX INTO MSG (WORDS)
MQPT:	.WORD	0		;CURRENT MSG QUEUE POINTER
OBUFL:	.WORD	TBUF0,TBUF1	;OUTPUT BUFFERS
TBUF0:	.BLKW	64.
TBUF1:	.BLKW	64.

	.END
 -AV