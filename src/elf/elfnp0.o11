	.TITLE	NETNP0	SCRL NCP PROCEDURES
	.LIST	ME
	.NLIST	CND
	.MCALL	$CNFIG,$DFREG,$DFHTE,$PUSH,$POP
	.MCALL	$DFCT,$DISCC,$WAIT,$ALOCB,$FREEB
	.MCALL	$ERROR

	.CSECT

	$CNFIG
	$DFREG
	$DISCC
	$DFHTE		;DEFINE HOST TABLE ENTRIES
	$DFCT		;DEFINE CONNECTION TBL ENT


	.GLOBL	$SHL,$BLDCT,$ICT,$GLINK,$FLINK,$HLIST
	.GLOBL	$ENQ,$DEQ,$ALOCW
	.GLOBL	$FCTBL,$MATSK,$MALCL,$ETCST
	.GLOBL	$GFMQE,$FMQE,$MQFMT,$DISMQ,$IQF,$HIQ,$IHQ
	.GLOBL	$RLSCT,$FQBUF
	.GLOBL	$LLDEL,$QDEL
	.GLOBL	$INCAL,$DECAL
	.GLOBL	$EXMCH,$SLL,$LSLST

CTPOOL = 2		;BUFFER POOL ID FOR CONN TBL


	.NLIST	ME
	.PAGE
	.SBTTL	$SHL -- SEARCH HOST-LIST
;			*** $SHL *** 
;			***    SEARCH HOST-LIST
;			***  FOR <HOSTID>
;			***  IN R0

$SHL:	MOV	#$HLIST,R1		;BASE OF HOSTLIST TO R1
	MOV	(R1)+,R4		;ENTRY LENGTH
	MOV	(R1)+,R2		;NUMBER OF ENTRIES
SRCHC:	CMPB	R0,(R1)		;IS HOSTID THAT SPECIFIED?
	BEQ	SRCHR		;FOUND HOSTID
	ADD	R4,R1		;BUMP BY ENTRY LENGTH
	DEC	R2		;AND TALLY ON NR ENTRIES
	BGT	SRCHC		;BACK TILL FOUND
	RTS	PC		;RETURN UNSUCCESSFUL, CC = 0
SRCHR:	CLZ			;SET COMPLETION CODE
	RTS	PC		;AND HAPPILY RETURN


	.SBTTL	$EXMCH -- EXHAUSTIVE SEARCH FOR LOCAL SOCKET

;			THIS PROCEDURE PERFORMS AN EXHAUSTIVE
;			SEARCH OF ALL KNOWN CT'S
;			(EXCLUDING LISTING CT'S)
;			IN AN ATTEMPT TO LOCATE A PENDING
;			CALL TO A LOCAL LISTENER.
;			THE DESIRED LOCAL SOCKET IS 
;			SPECIFIED IN R0.
;			THE PROCEDURE IS CALLED BY
;			THE LISTEN ($N.LSN) PRIMITIVE

;			RETURNS THE TARGET CT ADDRESS IN R2,
;			IF IT WAS FOUND. THE ADDRESS OF
;			THE PRECEEDING CT ENTRY IS RETURNED
;			IN R3, TO FACILITATE DELETION OF
;			THE ENTRY FROM A LIST OF CT'S ASSOCIATED
;			WITH A SPECIFIC HOST. (FOR ADDITION
;			TO THE LISTENING-SOCKET LIST.)
;			IF THE SOCKET WAS NOT LOCATED,
;			R2 IS RETURNED AS 0, AND
;			THE CONDITION CODE Z BIT IS SET IN PSW.

;			RETURNS HT POINTER IN R1.  R0 IS
;			RETURNED UNCHANGED.

$EXMCH:	MOV	#$HLIST,R1	;GET BASE OF HOST-LIST
	MOV	(R1)+,R4	;GET ENTRY LENGTH
	$PUSH	(R1)+		;PUT NUMBER OF ENTRIES ON STACK

EXSRCH:	MOV	R1,R3		;HTE ADDRX TO R3
	ADD	#HTECTI,R3	;AND GET ADDRX OF INPUT CHAIN HEAD
EXSRC0:	MOV	(R3),R2		;ADDRX OF POSSIBLE CT TO R2
	BEQ	EXS2		;NONE HERE
	CMP	R0,CTLCL(R2)	;LCL SCK CMPR?
	BEQ	ESRCHR		;YEAH.
	MOV	R2,R3		;ADVANCE TO NEXT
	BR	EXSRC0		;SEARCH INPUT CTS

EXS2:	MOV	R1,R3		;HTE ADDR TO R3
	ADD	#HTECTO,R3	;BASE OF CT CHAIN FOR THIS HOST
EXS3:	MOV	(R3),R2		;OBTAIN ADDR OF POSSIBLE CT
	BEQ	EXSR		;BRCH IF THERE AREN'T ANY
	CMP	R0,CTLCL(R2)	;IS THIS IT?
	BEQ	ESRCHR		;YEAH, FOUND HIM
	MOV	R2,R3		;ADVANCE TO NEXT
	BR	EXS3

EXSR:	ADD	R4,R1		;BUMP TO NEXT HOST TBL ENTRY
	DEC	@SP		;DECREMENT TALLY ON NR ENTRIES
	BGT	EXSRCH		;SEARCH THEM ALL
ESRCHR:	TST	(SP)+		;SET COND CODES
	RTS	PC		;RETURN, CC Z=1, R2=0


	.PAGE
	.SBTTL	$SLL -- SEARCH LIST OF LISTENING CT'S

;			THIS PROCEDURE SEARCHES FOR 
;			A LISTENING CT HAVING A SPECIFIED
;			LOCAL SOCKET, CONTAINED IN R0.
;			BECAUSE LISTENING SOCKETS ARE NOT
;			ASSOCIATED WITH A PARTICULAR HOST,
;			THE HOST-TABLE POINTER FIELD IN
;			THESE CT'S IS 0.

;			$SLL RETURNS THE ADDRESS OF THE
;			TARGET CT, IF FOUND, IN R2.
;			THE ADDRESS OF THE PRECEDING CT IS RETURNED
;			IN R3, TO ALLOW THE CALLER TO EASILY DELETE
;			THE CT FROM THE LISTENING LIST.

;			R0, R1 ARE RETURNED UNCHANGED.

$SLL:	MOV	#$LSLST,R3	;BASE OF LISTENER LIST
SLL2:	MOV	(R3),R2		;FETCH ADDRESS OF A CT FROM LIST
	BEQ	SLSCN0		;NONE IN LIST, OR END LIST.
	CMP	R0,CTLCL(R2)	;IS THIS IT?
	BEQ	SLLF		;WE FOUND HIM
	MOV	R2,R3		;SETUP TO ADVANCE TO NEXT
	BR	SLL2		;LOOP BACK AND CHECK FOR END.
SLLF:	CLZ			;SET COMPLETION CODE NE 0
SLSCN0:	RTS	PC		;AND RETURN

	.PAGE
	.SBTTL	$GLINK - GET A LINK FOR SPEC. HOST
;			*** $GLINK ***

;			ASSUMES HTE ADDR IN R1

;			FETCHES A FREE LINK FOR
;			SPECIFIED HOST


;			RETURNS

;			LINK NUMBER IN REG 0
;			CC = EQ IF NO LINKS,
;			CC = NE IF LINK ALLOCATED.


LMAX = 71		;LAST USABLE LINK NR

$GLINK:	CLR	R0		;GET AN UNUSED LINK
	MOV	R1,R2		;HTE POINTER TO R2
	ADD	#HTLINK,R2	;SET POINTER TO LINKBITS FIELD
FL0:	TSTB	(R2)+		;AND SEARCH FOR 0'S
	BNE	FBYTE		;BRANCH IF FOUND A NZRO BYTE
	ADD	#8.,R0		;BUMP R0
	CMP	#LMAX,R0	;LINKS ALL USED UP?
	BGT	FL0		;NOPE, KEEP SEARCHING
	RTS	PC		;RTN, CC IS L.E.
FBYTE:	DEC	R2		;BACKUP
	MOV	#1,R3		;INITIALIZE BIT POINTER
FBLUP:	BITB	R3,(R2)		;IS IT THIS ONE?
	BNE	FBIT		;YUP, WE FOUND IT
	INC	R0		;ELSE INC LINK COUNTER
	ASL	R3		;RE-ALIGN MASK
	BR	FBLUP	;AND KEEP LOOKING...

FBIT:	BICB	R3,(R2)		;CLEAR BIT IN LINK FIELD
	CLZ			;CLEAR Z BIT, CC=N.E.
	RTS	PC		;RETURN WITH VALUE IN R0
	.PAGE
	.SBTTL	$FLINK - FREE A LINK FOR SPEC HOST
	
;		*** $FLINK ***

;		FREE A LINK BELONGING
;		TO HOST WHOSE HTE ADDR IS
;		IN R1

$FLINK:	MOV	R1,R2		;BASE HTE TO R2
	ADD	#HTLINK,R2	;GET BASE OF LINK BYTES
	MOV	R0,R3		;PREPARE TO DIV BY 8
	ASR	R3
	ASR	R3
	ASR	R3		;TO GET OFFSET IN LINKBYTES
	ADD	R3,R2
	BIC	#177770,R0	;GET BYTE OFFSET IN 
	BISB	FPWR2(R0),(R2)	;PWR-OF-2 TBL
	RTS	PC		;SET AVAIL BIT AND RETURN

FPWR2:	.BYTE	1,2,4,10,20,40,100,200	;POWER-OF-2 TBL

	.PAGE
	.SBTTL	$FCTBL -- FIND CT ENTRY GIVEN LINK NR

;			***  $FCTBL  ***

;			ASSUMES
;			R0 IS LINK NR,  R1 IS HTE PTR
;			RETURNS
;			R2 = CT ADDRESS

$FCTBL:
FCT00:	BEQ	FCTRS		;BRANCH IF NONE MORE
	CMPB	R0,CTLINK(R2)	;IS SAME LINK?
	BEQ	FCTF		;YUP
	MOV	(R2),R2	;ADVANCE TO NEXT CT ENTRY
	BR	FCT00		;CHECK FOR END OF LIST
FCTF:	TST	R2		;RETURN STATUS
FCTRS:	RTS	PC		;RETURN

	.SBTTL	$MATSK -- MATCH SOCKET NRS

;			***  $MATSK  **

;			ASSUMES
;			R0 IS LCL SCK NR
;			R1 IS HTE POINTER
;			R3,R4 ARE FGN SCK NR
;			RETURNS
;			R2 = CT ADDRESS

$MATSK:	JSR	PC,MASET2	;GET HEAD OF CTLIST
MATCK:	BEQ	MATRT		;NO MORE
	CMP	R0,CTLCL(R2)		;LCL SCK COMPARE?
	BNE	MATNX		;NO, GET NEXT ADDR
	CMP	R3,CTFGN(R2)		;FGN SCK CMP?
	BNE	MATNX		;GET NEXT
	CMP	R4,CTFGN+2(R2)		;2ND WD COMP?
	BNE	MATNX		;GO TO NEXT
	TST	R2		;SET C.C.
MATRT:	RTS	PC		;RETURN

MATNX:	MOV	(R2),R2		;GET NEXT CT IN CHAIN
	BR	MATCK		;CHECK FOR LAST

	.SBTTL	$MALCL -- MATCH LOCAL SOCKET IDENTIFIERS

;			***  $MALCL  ***

;			ASSUMES
;			R0 IS LCL SCK NR
;			R1 IS HTE POINTER

;			RETURNS
;			R2 IS CT POINTER, IF FOUND

$MALCL:	JSR	PC,MASET2	;GET PTR TO CT LIST
MA00:	BEQ	MAR2		;BRANCH IF NO CT ENTRIES
	CMP	R0,CTLCL(R2)	;SAME LCL SOCKET?
	BEQ	MAR2		;RETURN IF SO W/ CT PTR
	MOV	(R2),R2	;BUMP TO NEXT IN CHAIN
	BR	MA00		;CHECK FOR END OF CHAIN
MAR2:	TST	R2		;SET C.C. ACCORDING TO SUCCESS
	RTS	PC		;IF Z BIT SET, NONE FND
MASET2:	BIT	#1,R0	;IS LCL SCK SENDER?
	BNE	MASEN		;YES
	MOV	HTECTI(R1),R2	;HEAD CT TO R2
	RTS	PC		;AND RETURN
MASEN:	MOV	HTECTO(R1),R2	;HEAD CT SENDERS TO R2
	RTS	PC		;AND RETURN
	.PAGE
	.SBTTL	$BLDCT -- BUILD CT ENTRY FOR SPEC. HOST

;			*** $BLDCT ***

;			ASSUMES
;			R0 = LCL SCK NR
;			R1 = HTE PTR , OR 0.
;			RETURNS
;			R1 UNCHANGED.
;			R2 = NEW CT PTR
$BLDCT:	$PUSH	R0		;SAVE LCL SCK NR
	MOV	R1,-(SP)	;SAVE HTE POINTER
	MOV	#CTPOOL,R0	;SETUP POOLID
	JSR	PC,$ALOCW	;ALLOCATE AND WAIT
	MOV	#CTLEN,R3	;SETUP LEN OF CT
	MOV	R1,R4		;LEN IN WDS IN R3, ADDR IN R4
CLRCT:	CLR	(R4)+		;INITIALIZE THE CT ENTRY
	DEC	R3		;TALLY
	BGT	CLRCT		;FOR ALL WDS
	MOV	R1,R2		;CT PTR TO R2
	$POP	R1		;RECOVER HTE PTR
				; R3 CONTAINS 0
	$POP	CTLCL(R2)	;SET LCL SCK NR
	MOV	-(R3),-(SP)	;SAVE PS
	TST	R1		;WAS HOST SPECIFIED?
	BEQ	BLDS2		;NO, SKIP HTE SETUP.
	BIS	#340,(R3)	;LOCKOUT WHILE UPDATING...
	BIT	#1,CTLCL(R2)	;LCL SCK SENDER?
	BNE	BLDSN		;YES
	MOV	HTECTI(R1),(R2)	;CHAIN HOSTLIST ENTS
	MOV	R2,HTECTI(R1)	;STORE CT ADDR IN CHAIN
BLDS2:	MOV	R1,CTHTA(R2)	;STORE HTE ADDR IN CT
	MOV	(SP)+,(R3)	;RESET PRIO
	RTS	PC		;RETURN WITH
				;  R1 = CT ADDR
				;  R2 = HTE ADDR
BLDSN:	MOV	HTECTO(R1),(R2)
	MOV	R2,HTECTO(R1)
	BR	BLDS2

	.SBTTL 	$ICT -- INITIALIZE CT ENTRY

;			***  $ICT  ***

;			ASSUMES R2 = CT PTR

$ICT:	MOV	R2,R3		;SCRATCH REG
	ADD	#CTMCT,R3	;ADDR OF MSG CNT
	CLR	(R3)+		;CLEAR MSG CNT ON CONN
	CLR	(R3)+		;CLEAR BIT CNT HI
	CLR	(R3)+		;CLEAR BIT CNT LO
	CLR	CTBCI(R2)	;BIT COUNT IN
	CLR	CTBCO(R2)	;BIT COUNT OUT
	RTS	PC		;RETURN

	.SBTTL	$RLSCT -- RELEASE AND FORGET CT ENTRY
$RLSCT:	$PUSH	R2		;SAVE CT POINTER
	ROR	CTLCL(R2)	;IS HE RECEIVE SOCKET?
	BCS	IHFNFL		;BRANCH IF SEND SOCK
	MOVB	CTLINK(R2),R0	;GET LINK
	BEQ	IHFNFL		;IF HAVEN'T ALLOC, DONT FREE
	MOV	CTHTA(R2),R1	;FETCH HTE ADDR
	BEQ	IHFNFL		;DON'T FREE IF NO HOST ASSIGNED
	JSR	PC,$FLINK	;FREE LINK
	MOV	@SP,R2		;RESTORE CT POINTER
IHFNFL:
IHD02:	ADD	#CTQ,R2		;POINT TO CONN QUEUE
	JSR	PC,$DEQ		;DEQUEUE A MESSAGE
	BEQ	IHFACT		;NONE
	JSR	PC,$FQBUF	;FREE MQE AND ITS BUFF
	MOV	@SP,R2		;CT PTR AGAIN
	BR	IHD02		;LOOP THRU CT MSG PTRS

IHFACT:	MOV	@SP,R2		;GET CT PTR
	MOV	CTMQA(R2),R0	;ACTIVE MSG?
	BEQ	IHFMQP		;FREE MQP
	JSR	PC,$FQBUF	;FREE MQE AND ITS BUF
	MOV	@SP,R2		;CT AGAIN
IHFMQP:	MOV	CTMQP(R2),R0	;MESSAGE QUEUE PTR TO R0
	BEQ	IHFFQ		;ALL DONE, FREE CT
	JSR	PC,$FQBUF	;FREE MQE AND BUF
IHFFQ:	$POP	R1		;FREE THE FRIGGING CT
	MOV	#CTPOOL,R0	;POOLID FOR CONN TBL
	$FREEB			;FREE IT
	RTS	PC		;AND RETURN

$FQBUF:	$PUSH	R0		;SAVE MQE PTR
	MOV	-(R0),R1	;GET BUFFER ADDRESS
	MOV	-(R0),R0	;AND POOLID
	$FREEB			;FREE THE BUFFER
	$POP	R4		;POP THE MQE ADDR
	JSR	PC,$FMQE		;AND FREE IT
	RTS	PC		;AND RETURN

	.SBTTL	$ALOCW -- ALLOCATE BUFFER AND WAIT IF NECC

;		*** $ALOCW ***

;		ALLOCATE A BUFFER AND WAIT IF NECC.

;		POOLID IN R0

$ALOCW:	MOV	R0,-(SP)	;SAVE R0
ALOCW0:	$ALOCB			;GET A BUFFER
	BEQ	ALOCW1		;WAIT IF NONE
	MOV	(SP)+,R0	;RESTORE R0
	RTS	PC		;AND RETURN
ALOCW1:	MOV	R5,-(SP)	;SAVE RETURN ADDR
ALOCW2:	$WAIT			;WAIT FOR BUFFER
	BIT	#BUF,-(R4)	;HAVE WE GOT ONE?
	BEQ	ALOCW2		;NOPE
	MOV	(SP)+,R5	;YES, RESTORE R5
	MOV	(SP),R0		;RESTORE 0, DONT POP
	BR	ALOCW0		;RETURN TO TRY AGAIN


	.PAGE
	.SBTTL	$ENQ -- PLACE QUEUE ELEMENT IN FIFO QUEUE

;			***  $ENQ  ***
;			PLACE ENTRY IN FIFO QUEUE
;			R2 = ADDR (HEAD,TAIL)
;			R0 = ADDR (NEW Q EL)

$ENQ:	CLR	R3		;SAVE STATUS
	$PUSH	-(R3)	;SAVE STATUS ON STACK
	BIS	#340,(R3)
			;WE'RE DISABLED NOW

	CLR	(R0)	;CLEAR LINK FROM NEW QUEUE EL
	TST	(R2)+	;HEAD OF QUEUE NULL?
	BEQ	ENQNL	;YES
	MOV	R0,@(R2)+	;UPDATE LINK TO TAIL
	BR	ENQR		;GO SETUP NEW TAIL
ENQNL:	MOV	R0,(R2)		;SET NEW TAIL IF Q MTY
ENQR:	MOV	R0,-(R2)	;UPDATE TAIL OR HEAD
	$POP	(R3)		;RESET PROCESSOR PRIORITY
	RTS	PC		;RETURN

	.SBTTL	$DEQ -- REMOVE ELEMENT FROM FIFO QUEUE

;			***  $DEQ  ***
;			FETCH ENTRY FROM FIFO QUEUE
;			R2 = ADDR (HEAD,TAIL) OF QUEUE
;			RETURNS R0 = ADDR (Q EL)
;			CC Z BIT SET IF NUL

$DEQ:	CLR	R3
	$PUSH	-(R3)
	BIS	#340,(R3)	;RUN DISABLED
	MOV	(R2),R0		;QHEAD TO R0
	BEQ	DQRTS		;ITS NULL
	MOV	(R0),(R2)	;UPDATE QUEUE HEAD
DQRTS:	$POP	(R3)		;RETURN TO PREV PRIO
	TST	R0		;SET C.C.
	RTS	PC		;RETURN

	.SBTTL	$LLDEL -- DELETE AN ELEMENT FROM A LINKED LIST

;			***  $LLDEL  ***

;			ASSUMES:

;			R0 = POINTER TO A QUEUE ELEMENT
;			R2 = HEAD OF A QUEUE

;			RETURNS:
;			R2 POINTS TO ELEMENT PREV. TO ONE DEL'D.


$LLDEL:	
QDLUP:	CMP	(R2),R0		;IS LINK OF (R2) TO BE DEL'D
	BEQ	QDGOT		;SEARCH FOR IT
	MOV	(R2),R2		;SCAN
	BNE	QDLUP		;ERROR IF NOT FOUND
	RTS	PC		;DON'T COMPLAIN.
QDGOT:	MOV	@R0,@R2		;PATCH LINK TO SKIP DEL'D QEL
	RTS	PC		;AND RETURN

	.SBTTL	$QDEL -- DELETE AN ENTRY FROM A QUEUE

;			***  $QDEL  ***

;			SAME ASSUMPTIONS AS $LLDEL,
;			EXCEPT $QDEL PATCHES UP THE
;			TAIL FIELD OF A QUEUE POINTER.

$QDEL:	MOV	R2,R3		;MOVE QUEUE HEAD PTR SAVE
	JSR	PC,$LLDEL	;DELETE ENTRY FROM LINKLIST
	TST	(R2)		;IS TAIL TO BE UPDATED?
	BNE	QDG2		;NO, SIMPLY RETURN
	MOV	R2,2(R3)	;STORE NEW TAIL IN Q POINTER
QDG2:	RTS	PC		;RETURN..

	.SBTTL	$GFMQE -- GET FREE MESSAGE QUEUE ELEMENT

;			***  $GFMQE  ***
;			GET FREE MESSAGE QUEUE ELEMENT
;			RETURNS FREE ELEMENT IN R4
;			CALLS $ERROR IF NONE AVAIL

$GFMQE:	CLR	R3	;DISABLE
	$PUSH	-(R3)
	BIS	#340,(R3)	;AT PRIO 7
	MOV	$IQF,R4		;GET TOP OF FREELIST
	BEQ	GFERR		;ERROR, NONE AVAIL
	MOV	(R4),$IQF	;UPDATE HEAD OF FREE QUEUE
	$POP	(R3)		;BACK TO PREV. STATUS
	RTS	PC

GFERR:	$ERROR	1		;ERROR 1 -- NO MESSAGE QUEUE SPACE

	.SBTTL	$FMQE -- FREE MESSAGE QUEUE ELEMENT

;			***  $FMQE  ***

;			ASSUMES R4 = ADDR ELEMENT
;			TO BE PLACED ON FREE MSG QUEUE

$FMQE:	CLR	R3		;DISABLE
	$PUSH	-(R3)		;WHILE UPDATING
	BIS	#340,(R3)	;QUEUE

	MOV	$IQF,(R4)	;LINK TO CURRENT TOP FREE QUEUE
	MOV	R4,$IQF

	$POP	(R3)		;RESTORE STATUS
	RTS	PC		;AND RETURN


	.SBTTL	$MQFMT -- FORMAT MESSAGE QUEUE ELEMENT

;			*** $MQFMT  ***

;			THIS PROCEDURE GETS AND ENTRY
;			FROM THE FREE MESSAGE QUEUE
;			AND FORMATS IT WITH
;			MSG ADDR, POOLID, AND LEN

;			ASSUMES:
;			R0 = BUFFER POOL ID
;			R1 = A(MSG)
;			R2 = LENGTH

$MQFMT:	JSR	PC,$GFMQE	;GET AN ENTRY FROM MESSAGE QUEUE
	MOV	R1,-(R4)	;STORE MESSAGE ADDRESS
	MOV	R0,-(R4)	;STORE POOL ID
	MOV	R2,-(R4)	;STORE LENGTH
	ADD	#6,R4		;RE-SET R4 TO QUEUE ENTRY
	RTS	PC		;RETURN

	.SBTTL	$DISMQ	DISCARD MQE AND ASSOCIATED BUFFER
$DISMQ:	$PUSH	R0		;MQE ADDRESS ASSUMED IN R0
	MOV	-(R0),R1	;ADDRESS TO R1
	MOV	-(R0),R0	;POOLID TO R0
	$FREEB			;RELEASE THE BUFFER
	$POP	R4		;MQE TO R4
	JSR	PC,$FMQE	;FREE THE MQE
	RTS	PC		;AND RETURN

	.SBTTL	$ETCST	SET CONNECTION STATE

;			***  $ETCST  *** 

;			ASSUMES
;			R0 IS NEW STATE
;			R2 IS CT POINTER

$ETCST:	MOVB	CTSTAT(R2),R3
	BICB	#17,R3		;CLEAR STATE BITS
	BISB	R0,R3		;SET NEW STATE
	MOVB	R3,CTSTAT(R2)	;UPDATE CTSTAT FIELD
	RTS	PC		;AND RETURN

	.SBTTL	$INCAL -- INCREASE ALLOCATION FOR CONNECTION
;			*** $INCAL ***

;			ASSUMES
;			R2 IS CT POINTER
;			R3,R4 ARE BIT COUNTS

$INCAL:	ADD	R4,CTBCT+2(R2)	;INCREASE BIT COUNT
	ADC	CTBCT(R2)
	ADD	R3,CTBCT(R2)
	RTS	PC		;RETURN

$DECAL:	SUB	R4,CTBCT+2(R2)
	SBC	CTBCT(R2)
	SUB	R3,CTBCT(R2)	;DECREMENT BIT COUNT
	RTS	PC


	.END

î

