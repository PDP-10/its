	.TITLE	NETNP1	SCRL NCP PROCEDURES 1
	.LIST	ME
	.NLIST	CND
	.MCALL	$CNFIG,$DFREG,$DFHTE,$DFCCT,$PUSH,$POP
	.MCALL	$STIME,$DFSCC
	.MCALL	$DFCT,$DISCC,$WAIT,$ALOCB
	.MCALL	$N.CON,$N.LSN,$N.CLS,$N.SND,$N.RCV
	.MCALL	$ERROR
	.CSECT
	$CNFIG
	$DFREG			;DEFINED REGS
	.NLIST	ME
	$DISCC
	$DFHTE			;DEFINE HOST TBL ENTRIES
	$DFCT			;DEFINE CONN TBL ENTRIES
	$DFCCT			;CONNECTION COMM. TBLS
	$DFSCC			;SOCKET COMPLETION CODES


	.GLOBL	$SHL,$BLDCT,$GLINK,$FLINK,$ENQ,$DEQ
	.GLOBL	$GFMQE,$FMQE,$MQFMT,$HHENQ,$HIENQ
	.GLOBL	$ALOCW,$SBCLS,$SNDAL,$SNDRT,$SNDRS,$SNDRP
	.GLOBL	$INCAL,$DECAL
	.GLOBL	$RFCLS,$SNNOP,$SINOP
	.GLOBL	$UICP

	.SBTTL	HH MESSAGE DECLARATIVE SPECIFICATION

HHML0 = 0
HHML1 = 2
HHMSIZ = 4
HHMCNT = 6
HHMOP = 10
HHMMY0 = 12
HHMMY1 = 14
HHMUR0 = 16
HHMUR1 = 20
HHMBS = 23
HHMLNK = 23

ALL = 4.	;OPCODE FOR HH ALL CMD
RET = 6.	;OPCODE FOR HH RET CMD
CLS = 3.	;OPCODE FOR HH CLS CMD
RTS = 1.	;OPCODE FOR HH RTS CMD (RFC)
STR = 2.	;OPCODE FOR HH STR CMD (RFC)
NOP = 0.	;OPCODE FOR HH NOP CMD
RST = 14	;OPCODE FOR RST HH OP
RRP = 15	;OPCODE FOR RRP HH OP

GVB = 5.	;OPCODE FOR HH GVB CMD
INR = 7.	;OPCODE FOR HH INR CMD
INS = 8.	;OPCODE FOR HH INS CMD



	.PAGE
	.SBTTL	$RFCLS	SEND AN RFC OR CLS

;			***  $RFCLS  ***

;			ASSUMES
;			R0 = 0 FOR CLS
;			R0 NE 0 FOR RFC

;			R2 = CT POINTER



POOL32 = 2		;POOL ID FOR 32 WORD UNITS
LCMSG = 12

$RFCLS:	$PUSH	R0,R2		;SAVE OP, CT PTR
	JSR	PC,ARFCM	;ALLOC AND FMT RFC/CLS MSG
	$POP	R2		;POP MSG
	CLR	HHMMY0(R1)	;CLR MY SCK HI WORD
	MOV	CTLCL(R2),HHMMY1(R1)	;SET LO WORD
	MOV	CTFGN(R2),HHMUR0(R1)	;SET HI WORD FGN SCK
	MOV	CTFGN+2(R2),HHMUR1(R1)	;SET LO WORD
	MOV	#10,HHMSIZ(R1)	;MSG SIZE
	MOV	CTHTA(R2),R0	;HOST TABLE ADDR TO R0
	MOV	HTEID(R0),HHML0(R1)	;HOST ID TO FORMAT LDR
	CLR	HHML1(R1)	;CLR TO IND CTRL LINK
	TST	(SP)+		;POP OPCODE (0 IF CLS)
	BEQ	RTSC03		;PROCESS CLS
	BIT	#1,CTLCL(R2)	;IS LCL SCK SENDER?
	BNE	RTSC02		;YUP, HE'S SENDER
RTSC01:	MOVB	CTLINK(R2),HHMLNK(R1)	;SETUP LINK ID
	MOV	#RTS,R3		;SET RTS OPCODE
	BR	RTSCOM		;TO COMMON CODE
RTSC02:	MOVB	CTBSIZ(R2),HHMBS(R1)	;SETUP BYTE SIZE
	MOV	#STR,R3		;SETUP STR OP
RTSCOM:	MOV	#12,HHMCNT(R1)	;SETUP BYTE COUNT
	MOVB	#200,HHMLNK-1(R1)	;SETUP PADDING
RTCLZ:	MOV	R3,HHMOP(R1)	;SET OPCODE
	MOV	R0,R1		;HTE PTR TO R1
	MOV	R4,R0		;MQE PTR TO R0
	CLR	R2		;INDICATE CONTROL LINK
	JSR	PC,$HHENQ	;TO HOST-HOST ENQUE ROUTINE
	RTS	PC		;RETURN

RTSC03:	MOV	#11,HHMCNT(R1)	;SET BYTE COUNT
	MOV	#100000,HHMLNK-1(R1)	;SET PADDING
	MOV	#CLS,R3		;SET CLS OPCODE
	BR	RTCLZ		;TO COMMON CODE

	.PAGE
	.SBTTL	$SBCLS -- RETURNS A CLS TO FGN HOST

;			***  $SBCLS  ***

;			SENDS A CLS TO HOST ID SPEC IN R0
;			AND LCL,FGN SCKS POINTED TO BY R1

$SBCLS:	$PUSH	R0,R1		;SAVE HOSTID AND SCK PTRS
	JSR	PC,ARFCM	;ALLOC A MSG
	$POP	R0		;POINTER TO LIST IN R0
	MOV	(R0)+,HHMUR0(R1)	;YOUR SOCKET
	MOV	(R0)+,HHMUR1(R1)	;YOUR SOCKET
	$POP	(R1)+	;STO HOSTID IN LDR
	CLR	(R1)+		;SET LINK 0
	MOV	#10,(R1)+	;SET BYTE SIZE
	MOV	#11,(R1)+	;BYTE COUNT
	MOV	#3,(R1)+	;CLS OP
	MOV	(R0)+,(R1)+	;FGN SCK
	MOV	(R0)+,(R1)+	;TO MSG
	MOV	#100000,(R1)	;PADDING
	$PUSH	R4		;SAVE MQE POINTER
	MOV	@-(R4),R0		;HOSTID TO R0
	JSR	PC,$SHL		;SEARCH HOST-LIST
	BEQ	SBNQF		;SEARCH UNSUCCESSFUL
	CLR	R2		;INDICATE CTRL LINK
	$POP	R0		;MQE PTR TO R0
	JSR	PC,$HHENQ	;STICK ON CTRL LINK QUEUE FOR HOST
	RTS	PC		;AND RETURN
SBNQF:	$POP	R0		;MQE PTR TO R0
	JSR	PC,$HIENQ	;STICK ON HOST-IMP QUEUE
	RTS	PC


ARFCM:	MOV	#POOL32,R0	;SETUP FOR ALLOC
	JSR	PC,$ALOCW	;GET A BUFFER
	MOV	#POOL32,R0	;BUFFER LEN
	MOV	#LCMSG,R2	;MSG LEN
	JSR	PC,$MQFMT	;FORMAT MSG
	RTS	PC		;RETURN, R1 = A(MSG)
				;R4 = A(MQE)

	.PAGE
	.SBTTL	$SNDAL -- SENDS AN ALLOCATE CMD

;			***  $SNDAL  ***

;			ASSUMES
;			R0 IS MSG CNT INCREMENT
;			R2 IS CT PTR
;			R3,R4 IS BIT CNT INCREMENT

$SNDAL:	JSR	PC,$INCAL	;INCREASE ALLOCATION
	ADD	R0,CTMCT(R2)	;INCREASE MESSAGE COUNT
	JSR	PC,SARET	;GO TO COMMON ALL/RET PROCESS
	.WORD	ALL		;CMD IS ALL
	RTS	PC		;RETURN


	.SBTTL	$SNDRT -- SENDS A RET CMD

;			***  $SNDRT  ***

;			SAME ASSUMPTIONS AS $SNDAL

$SNDRT:	JSR	PC,$DECAL	;DECREASE ALLOCATION
	SUB	R0,CTMCT(R2)	;DECREASE MESSAGE COUNT
	JSR	PC,SARET	;CALL COMMON PROCESSOR
	.WORD	RET		;WITH RET CMD
	RTS	PC		;RETURN TO CALLER

SARET:	$PUSH	R4,R3,R0,R2	;PUT PARAMETERS ON STACK
	JSR	PC,ARFCM	;ALLOCATE MESSAGE
	$POP	R2	;GET CT PTR
	MOVB	@CTHTA(R2),(R1)+	;HOSTID TO BEGIN MSG
	CLRB	(R1)+		;CLEAR LEADER
	CLR	(R1)+		;LINK 0 (CTRL LNK)
	MOV	#10,(R1)+	;B.S. = 8.
	MOV	#11,(R1)+	;NR BYTES IS 9.
	CLR	(R1)+		;SET M2 = 0, NOP CMD
	MOVB	CTLINK(R2),(R1)+	;MOVE LINK TO MSG
HHOP:	MOV	6(SP),R5		;OBTAIN RETURN ADDRESS
	MOVB	(R5)+,(R1)+		;MOVE OPCODE (ALL OR RET)
	INC	R5		;FIX RETURN ADDRESS
	$POP	(R1)+,(R1)+,(R1)+	;MOVE PARAMS TO MSG
	MOV	R5,(SP)		;RESTORE RETURN ADDRESS
	MOV	#100000,(R1)+		;MOVE PADDING
	MOV	CTHTA(R2),R1	;HTE ADDR TO R1
	MOV	R4,R0		;MQE PTR TO R0
	CLR	R2		;INDICATE CTRL LINK
	JSR	PC,$HHENQ	;PLACE ON HOST-HOST QUEUE
	RTS	PC		;AND RETURN
	.PAGE
	.SBTTL	$SNDRS -- SEND A RST CMD TO FGN SITE

;			***  $SNDRS  ***

;			ASSUMES
;			HOSTID IN R0

$SNDRS:	JSR	PC,SRSRP	;TO COMMON PROCESSOR
	.WORD	RST		;RST IS OPCODE
	RTS	PC		;RETURN

$SNDRP:	JSR	PC,SRSRP	;TO COMMON PROCESSOR
	.WORD	RRP		;OPCODE IS RRP
	RTS	PC		;AND RETURN

$SNNOP:	JSR	PC,SRSRP	;TO COMMON CODE
	.WORD	NOP		;NOP CODE
	RTS	PC		;AND RETURN

SRSRP:	$PUSH	R0		;SAVE HOSTID
	JSR	PC,ARFCM	;GET MESSAGE
	MOV	@SP,(R1)+	;MOVE HOSTID TO MESSAGE
	CLR	(R1)+		;LINK 0
	MOV	#10,(R1)+	;BITSIZ 8.
	MOV	#1,(R1)+	;1 BYTE TO SEND
	MOV	@2(SP),(R1)+	;H-H OP CODE TO MSG
	ADD	#2,2(SP)		;INCREMENT RETURN ADDRESS
	MOV	#100000,(R1)+	;PADDING
	$POP	R0		;HOSTID TO R0 AGAIN
	$PUSH	R4		;SAVE MQE PTR
	JSR	PC,$SHL		;GET HTE POINTER
	CLR	R2		;INDICATE CONTROL LINK
	$POP	R0		;MQE TO R0
	MOV	#6,-6(R0)	;SET LENGTH
	JSR	PC,$HHENQ	;ENQ MESSAGE FOR HOST
	RTS	PC		;AND RETURN...

	.PAGE
	.SBTTL	HOST-IMP COMMAND EMITTERS
;			***  $SINOP  ***

;			SEND AN HOST/IMP NOP MESSAGE


$SINOP:	JSR	PC,ARFCM	;ALLOC BUFFER AND MQE
	MOV	#2000,(R1)+	;SET HOST-IMP NOP
	CLR	(R1)
	MOV	R4,R0		;MQE POINTER
	MOV	#2,-6(R0)	;LENGTH OF DATA
	JSR	PC,$HIENQ	;STICK ON HOST/IMP QUEUE
	RTS	PC		;AND RETURN


	.PAGE
	.SBTTL	$UICP -- USER ICP PROCEDURE

;			***  $UICP  ***

;			ASSUMES
;			R0 = ICP CCT ADDR
;			R3 = SND CCT ADDR
;			R4 = RCV CCT ADDR

;			PERFORMS ICP,
;			  RETURNS +0 IF ERROR
;			    	  +2 IF NO ERROR


$UICP:	$PUSH	R5,R3,R4,R0	;SAVE RA, SND, RCV, ICP
	MOV	R4,CCTLCL(R0)	;SET LOCAL SCK NR
	MOV	R4,R1		;SAME AS RCV CCT ADDRX
	TST	(R1)+		;GET LCL SCK + 2
	MOV	R1,CCTLCL(R4)	;SETUP MY RECEIVE SCK
	INC	R1		;COMPUTE ICP SCK + 3
	MOV	R1,CCTLCL(R3)	;SETUP MY SEND SOCKET
	MOV	CCTHOS(R0),CCTHOS(R3)	;MOVE HOSTID TO SND
	MOV	CCTHOS(R0),CCTHOS(R4)	;HOSTID TO RCV CCT
	MOVB	#32.,CCTBS(R0)	;BYTE SIZE
	MOVB	#8.,CCTBS(R3)	;SND B.S.
	MOVB	#8.,CCTBS(R3)	;RCV B.S.
	$STIME	30000.		;SET TIME-OUT TO 30 SECS.
	MOV	@SP,R0		;RECOVER ICP CCT PTR
	$N.CON		;CONNECTION TO ICP SCK
UIW1:	$WAIT		;WAIT TILL RESPONSE
	BIT	#TIM,-(R4)	;HAVE WE TIMED OUT?
	BNE	UITO1		;YES, CLOSE AND ABORT
	MOV	@SP,R0		;CCT TO R0
	TSTB	CCTCC(R0)	;COMPLETE?
	BEQ	UIW1		;NOPE
	BITB	#177,CCTCC(R0)	;ERRORS?
	BNE	UIER1		;YES, ABORT
	MOV	2(SP),R4	;RCV CCT TO R4
	MOV	#32.,R3		;NR BITS TO RECV
	ADD	#CCTFGN,R4	;DESTINATION ADDRX
	$N.RCV			;ISSUE RECEIVE
UIW2:	$WAIT			;WAIT TILL RCD
	BIT	#ACK,-(R4)	;REALLY DONE?
	BEQ	UIW2
	MOV	@SP,R0		;ICP CCT TO R0
	TSTB	CCTCC(R0)	;DONE?
	BPL	UIW2
	BITB	#177,CCTCC(R0)	;ERRORS?
	BNE	UIER1		;YUP
	$N.CLS			;OK, THRU WITH ICP SCK

UIW3:	$WAIT			;WAIT TILL THRU
	BIT	#ACK,-(R4)	;SEE IF POSTED
	BEQ	UIW3		;WAIT TILL ICP CLOSED
	MOV	@SP,R0		;GET ICP CCT
	MOV	2(SP),R4	;RCV CCT
	MOV	4(SP),R3	;SND CCT
	SWAB	CCTFGN(R4)	;CORRECT BYTE SWAP PROBLEM
	SWAB	CCTFGN+2(R4)
	MOV	CCTFGN(R4),CCTFGN(R3)
	MOV	CCTFGN+2(R4),CCTFGN+2(R3)
	INC	CCTFGN+2(R4)	;COMPUTE FGN SOCKET NRS
	ADC	CCTFGN(R4)	;INCR RCV SCK

	MOV	R4,R0		;ATTEMPT CONN ON RCV SCK
	$N.CON			;ISSUE INIT
	MOV	4(SP),R0	;ISSUE CONN FOR SND SCK
	$N.CON
	BR	UIW4T		;TEST COMPLETION OF CONNEC
UIW4:	$WAIT
	BIT	#ACK,-(R4)
	BEQ	UIW4
UIW4T:	MOV	2(SP),R4	;RECEIVE SCK
	MOV	4(SP),R3	;SND SCK
	MOVB	CCTCC(R4),R0	;SEE IF ANY ERRORS
	BISB	CCTCC(R3),R0	;RESULT TO R0
	BIC	#177600,R0	;EXCLUDE READY BIT
	BNE	UIER2		;ERROR.
	BITB	CCTCC(R4),CCTCC(R3)	;SEE IF BOTH RDY
	BPL	UIW4		;WAIT UNTIL BOTH CCTS POSTED
	MOV	#2,R2		;INDICATE SUCCESS
UIERR:	MOV	@SP,R0		;RESET ERROR COND ON ICP SOCK
	MOVB	#WCCCMP,CCTCC(R0)	;CLEAR CLOSED STAT ERROR
UIRET:	$POP	R0,R4,R3,R5	;POP REGS
	ADD	R2,(SP)		;UPDATE BY COMPL CODE
	RTS	PC		;AND RETURN

UITO1:	MOV	@SP,R0		;TIME-OUT ERROR
	$N.CLS			;CLOSE ICP SOCKET
	MOV	@SP,R0		;DON'T WAIT FOR RESPONSE
	MOVB	#WCCTIM,CCTCC(R0)	;SET CONDX CODE
UIER1:	CLR	R2		;INDICATE ERROR
	BR	UIRET		;RETURN
;			NOTE -- IF ERROR HAS OCCURRED
;			AT THIS POINT (I.E., WITH
;			THE ACTUAL CONNECION SOCKETS)
;			THEN WE CAN ASSUME THAT THE
;			ICP CONNECTION WAS SUCCESSFUL.
;			WE SHOULD THEREFORE RESET
;			THE CLOSED CONDITION ON ICP
UIER2:	CLR	R2		;INDICATE ERROR
	BR	UIERR		;AND RESET ICP ERROR


	.END

                                                                                                                                                                                                                                                                                                                                                            