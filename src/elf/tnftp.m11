        .TITLE      FTPTEL
;***********************************************************************
;TNFTP:	 \HIS ROUTINE ACCPTES COMMANDS ON THE TELNET CONNECTIONS
;	 AND GIVE APPROPRIATE DE REPLIES.
;	 WHEN THE COOMMAND 'MLFL' IS RECEIVED IT CREATES A PROCESS
;	 DTFTP WHICH RECEIVES A	MAILFILE ON THE	DATA CONNECTION.
;	 WHENEVER THE PROCRAM WAITS FOR	A POS, EITHER BY  BY WAITING
;	 FOR SOMETHING TO RECEIVE ON THE TELNET	CONNECTION OR  A FLAG
;	 SET FROM THE FTFTP, IT	GOES TO	TNMON WHICH GIVES CONTROL TO
;	 A ROUTINE HANDLING THE	INPUT OR FLAG.
;
;***********************************************************************
;
	 .MCALL	   $N.SND,$N.CON,$N.CLS,$N.LSN,$N.RCV,$N.CNT
	 .MCALL	   $WAIT,$POST,$STIME
	 .MCALL	   $PUSH,$POP
	 .MCALL	   $ALOCB,$FREEB
	 .MCALL	   $DFCCT,$CNFIG,$DFREG,$DISCC
	 .GLOBL	   PTEX		   ;PRELIMINARY	PTR EXCH BUFFER	(
	 .GLOBL	   $SICP
	 .GLOBL	   $LGFTP,$TNPCT,TNFTP,$ALOCW,$DTPCT
	 $CNFIG			   ;SYSTEM PROCESSOR CONFIGURATION
	 $DFCCT			   ;DDEFINE CCT	ENTRY
	 $DFREG			   ;DEFINE REGS
	 $DISCC			   ;DEFINE COMPLETION CODES
;$DFCCT
;CCTHOS=0
;CCTOP=1
;CCTCC=2
;CCTBS=3
;CCTLCL=4
;CCTFGN=6
;
;DISCC
;RDY=200
;TIM=100
;IO=40
;ACK=20
;BUF=10
;
WKPOOL=2                           ;BUFFER, WORKING VARIABLES
BFPOOL=3			   ;EXHANGE BUFFER 16 WORDS
CCPOOL=3			   ;CCT	POOL ID
LINPOOL=0			   ;LINE BUFFER	ID 64 WORDS
LINLEN=128.			   ;LENGTH OF LINE BUFFFER IN CHARS.
;
SPACE=	 40
CR=	 15
LF=	 12
IAC=	 255.
;
;NOW DEFINE POINTERS TO	 THE EXCHANGE BUFFER
PRID=	 0			   ;PROC. ID TNFTP
PICP=	 2			   ;PTR	ICP CCT
FLAG=	 4
FLAGTD=  6                   ;FLAG TNFTP-DTFTP
FLAGN=   10                      ;FLAG DTFTP-TNFTP
FLAGO=   11                      ;OLD FLAG DTFTP-TNFTP
PSCCT=	 12			   ;PTR	SEND CCT
PRCCT=	 14			   ;PTR	REC. BUFFER
;
;
;***********************************************************************
;
;
;FIRST WE HAVE TO INITIALIZE THE WORKING AREA
;R5 POINTS TO EXCHANGE BUFFER
;
TNFTP:	 $WAIT			   ;WAIT FOR SIGNAL BY TNLOG, PRELIMINARY
	 MOV	   PTEX,R5	   ;PRELIMINARY
         BEQ       TNFTP
	 $PUSH	   R5		   ;SAVE ARGUMENTS
	 MOV	   #WKPOOL,R0	   ;ALLOCATE BUFFER FOR	VARIABLES
	 JSR   PC,$ALOCW
	 MOV	   R1,R5	   ;R5=PTR WORKING AREA
	 $POP	   R1		   ;RESET PTR EXCH BUFFER
	 MOV	   R1,24(R5)	   ;PTR	EXCHANGE BUFFER
	 MOV	   PSCCT(R1),22(R5) ;TR	SEND CCT
	 MOV	   PRCCT(R1),20(R5) ;PTR REC. CCT
	 MOV	   SP,36(R5)	   ;SAVE STACK POINTER
	 MOV	   #LINPOOL,R0	   ;ALLOCATE SPACE REC BUFFER
	 $PUSH	   R5		   ;SAVE PTR
	 JSR   PC,$ALOCW
	 $POP	   R5		   ;RESTORE PTR
	 MOV	   R1,14(R5)	   ;PTR	REC BUFFER
	 MOV	   R1,10(R5)	   ;FAKE EMPTY BUFFER
	 INC	   R1
	 MOV	   R1,12(R5)	   ;BY SETTING CURR. PTR =ENDPTR+1
;ALLOCATE SYMBOL BUFFER	(32 CHARS)
	 MOV	   #BFPOOL,R0
	 $PUSH	   R5
	 JSR   PC,$ALOCW
	 $POP	   R5
	 MOV	   R1,6(R5)
;SET CURRENT STATE TO 0
	 CLR	   (R5)
;SET THE DEFAULT VALUES	OF THE CCT FOR THE DATA	SOCKET
	 MOV	   24(R5),R1	   ;PTR	EXCH BUFFER
	 MOV	   PICP(R1),R1	   ;GRT	PTR CCT
	 MOVB	   #8.,CCTBS(R1)   ;SET	BYTE SIZE=8
	 MOV	   20(R5),R2	   ;REC	CCT
;SET THE DATA SOKET TO DEFAULT VALUE, I.E. REC SOCKET(TELNET)+2
	 MOV	   CCTLCL(R2),CCTLCL(R1)
	 ADD	   #2,CCTLCL(R1)
	 ADD	   #5,CCTFGN+2(R1) ;FOR	SOCKET=DEFAULT U+4
	 ADC	   CCTFGN(R1)	   ;ADD	CARRY TO MOST SIGN. BITS OF FOR.
;PREPARE A PREPLY BUFFER 'IAC' IN WORKING AREA (SEE WORK. AREA LAYOUT)
	 MOV	   #24.,30(R5)	   ;BITCOUNT, SEND BUFFER
	 MOVB	   #255.,32(R5)	   ;'IAC'
;CLEAR 'BYE-FLAG'
	 CLR	   26(R5)
;
;SEND	 '300 AWAITING INPUT''
	 MOV	   #M300,R0
	 JSR	   PC,TNREP
;
;***********************************************************************
;
;MAINLOOP:	   THIS	IS THE MAIN PROCESSING LOOP WHICH READS
;	 COMMANDS FOROM	THE USER FTP, INTERPRETS THE COMMAND TYPA
;	 AND GIVES CONTROL TO SUBROUTINE ACCORDIN TO TYPE
;
TNMAIN:	 JSR	   PC,TNSYM	   ;GET	FIRST SYMBOL OF	INPUT
	 MOV	   6(R5),R0	   ;PTR	TO SYMBOL BUFFER TO R0
        CMPB       (R0),#CR         ;IS IT CR?
         BEQ       TNMAIN          ;YES
         CMPB      (R0),#LF         ;NO, IS IT LF?
         BEQ       TNMAIN          ;YES
	 CMPB	   #255.,(R0)	   ;CHECK IF 'IAC'
	 BEQ	   TNMA3	   ;YES	, TAKE CARE OF THIS
;NO, FTP COMMAND , FIND	TYPE AND ENTER SUBROUTINE ACC. TO TYPE
	 MOV	   #TNTAB,R1	   ;GET	ADDRESS	OF COMM. TABLE
	 MOV	   R1,R2
TNMA1:	 CMPB	   (R0),(R2)	   ;SAME CHAR IN BUFFFER AND TABLE?
	 BNE	   TNMA2	   ;NO,	WRONG COMMAND
	 INC	   R0		   ;YES, TRY NEXT CHAR
	 INC	   R2
	 CMP	   4(R5),R0
;IF NOT	LAST CHAR. BRANC BACK AND COMPARE NEXT
	 BPL	   TNMA1
;MATCH HAS BEEN	FOUND, AND WE HAVE TO ENTER CORRECT ROUTINE
	 ADD	   #4,R1	   ;FIND ADDRESS
	 MOV	   (R1),PC	   ;TRANSFER CONTROL
;
;BEFORE	WE GO ON TO CHECK TH E NEXT COMMAND , WE HAVE TO CHECK IF WE
;ARE AT	THE END	OF THE TABLE
TNMA2:	 ADD	   #6,R1	   ;NEW	ENTRY
	 MOV	   R1,R2
	 CMP	   R1,#TNEND	   ;END	OF TABLE?
	 BPL	   TNMA10	   ;;NO, TRY THIS ENTRY
         MOV       6(R5),R0
         BR        TNMA1
TNMA10:	 JSR	   PC,DUMMY	   ;YES, RED DUMMY TILL	CR
;	 REPLY '500 LAST COMMAND COMPLETELY UNRECOGNIZED'
         MOV       #M500,R0
	 JSR	   PC,TNREP
	 BR	   TNMAIN	   ;TRY	AGAIN
;
;***********************************************************************
;
;TNMA3:	 AT THIS POINT WE KNOW THAT AN 'IAC' HAS ARRIVED, AND R0
;POINTS	TO THE START OF	THE BUFFER
;;THE FOLLOWING	IS DONE:
;IF COMM.<251. OR >254.	THE DO NOTHING (NO ACTION)
;IF COMM.=251.(WILL) RETURN 'WONT' AND COPY 2(R0) TO 32(R5)
;IF COMM.=252.(WONT) RETURN 'DONT' AND COPY
;IF COMM.=253(DO) RETURN 'WONT'	AND COPY
;IF COMM.=254(DONT) RETURN 'WONT' AND COPY
;
TNMA3:	 CMPB	   1(R0),251.
	 BMI	   TNGA		   ;RETURN TO MAIN IF <251.
	 CMPB	   1(R0),255.
	 BPL	   TNGA		   ;RETURN IF >254.
	 MOV	   2(R0),34(R5)	   ;MOV	OPTION TO OUTPUT
	 MOV	   #252.,33(R5)	   ;MOV	'WONT' TO BUFFER
	 CMPB	   1(R0),#252.	   ;SEE	IF 'DONT' INSTED
	 BNE	   TNMA4
	 MOV	   #254.,33(R5)	   ;YES
TNMA4:	 MOV	   R5,R0	   ;PTR	TO R0
	 ADD	   #30,R0	   ;PTR	TO OUTPUT BUFFER
	 JSR	   PC,TNREP	   ;REPLY
TNGA:	 JMP	   TNMAIN	   ;GO BACK AND	GET NEXT COMMAND
;
;***********************************************************************
;
;TABLE OF COMMANDS
;
TNTAB:	 .ASCII	   'USER'
	 .WORD	   USER
	 .ASCII	   'PASS'
	 .WORD	   PASS
	 .ASCII	   'ACCT'
	 .WORD	   ACCT
	 .ASCII	   'REIN'
	 .WORD	   REIN
	 .ASCII	   'BYE	'
	 .WORD	   BYE
	 .ASCII	   'BYTE'
	 .WORD	   BYTE
	 .ASCII	   'SOCK'
	 .WORD	   SOCK
	 .ASCII	   'TYPE'
	 .WORD	   TYPE
	 .ASCII	   'FORM'
	 .WORD	   FORM
	 .ASCII	   'STRU'
	 .WORD	   STRU
	 .ASCII	   'MODE'
	 .WORD	   MODE
	 .ASCII	   'RETR'
	 .WORD	   RETR
	 .ASCII	   'STOR'
	 .WORD	   STOR
	 .ASCII	   'APPE'
	 .WORD	   APPE
	 .ASCII	   'ALLO'
	 .WORD	   ALLO
	 .ASCII	   'REST'
	 .WORD	   REST
	 .ASCII	   'RNFR'
	 .WORD	   RNFR
	 .ASCII	   'RNTO'
	 .WORD	   RNTO
	 .ASCII	   'ABOR'
	 .WORD	   ABOR
	 .ASCII	   'DELE'
	 .WORD	   DELE
	 .ASCII	   'LIST'
	 .WORD	   LIST
	 .ASCII	   'NLST'
	 .WORD	   NLST
	 .ASCII	   'STAT'
	 .WORD	   STAT
	 .ASCII	   'HELP'
	 .WORD	   HELP
	 .ASCII	   'MLFL'
	 .WORD	   MLFL
	 .ASCII	   'NOOP'
TNEND:	 .WORD	   NOOP
;
;***********************************************************************
;
TNREP:	 MOV	   (R0),R3	   ;BIT	COUNT
	 ADD	   #2,R0
	 MOV	   R0,R4	   ;PTR	MESSAGE
	 MOV	   22(R5),R0	   ;PTR	CCT
	 $PUSH	   R5		   ;SAVE PRT WORKING AREA
	 $N.SND			   ;SEND REPLY
TNREP1:	 $WAIT			   ;WAIT FOR COMPLETION
	 MOV	   (SP),R5	   ;RESET PTR
	 MOV	   22(R5),R0	   ;PTR	CCT
	 TSTB	   CCTCC(R0)
	 BPL	   TNREP1	   ;NOT	COMPLETED
	 $POP	   R5		   ;DONE , TEST	COMPL CODE
	 BITB	   #37,CCTCC(R0)
	 BNE	   TNDOWN	   ;ERROR
	 CLRB	   CCTCC(R0)	   ;CLEAR COMPL	CODE
	 RTS	   PC		   ;RETURN
;***********************************************************************
;
;TNDOWN: ENRERED BOTH FROM TNREP AND TNMON WHEN	CANT SEND OR RECEIVE
;BE AWARE OF THE FACT THAT THE STACK IS	RESET BEFORE GOING BAK TO
;TNFRZ OR TNMAIN.  REMEMBER THAT THIS REQUIRES THAT THE	REC PRIM.
;IS UNFULFILLED
;IF STATA = 2 OR 3, SET	FLAG FOR DTFTP AND WAIT	FOR ANSWER
;IF STATE=5 DTFTP IS ALREADY POSTED, RETURN TO TNMAIN AFTER SETSTATETO6
;ELSE FREEZE TNFTP
;TNFRZ RESET THE STACK
TNDOWN:	 JSR	   PC,TNCLS	   ;SOMETHING WRONG, CLOSE TELNET CONNS.
	 CMPB	   (R5),#5	   ;STATE=6?
	 BEQ TNREP3		   ;YES
	 CMP	   (R5),#2	   ;NO,	STATE=2?
	 BEQ	   TNREP4	   ;YES
	 CMP	   (R5),#3	   ;3?
	 BEQ	   TNREP4	   ;YES
	 JMP	   TNFRZ	   ;NO,	FREEZE TNRTP
TNREP4:	 MOV	   24(R5),R0	   ;PTR	EXCH BUFFER
	 MOV	   #1,6(R0)	   ;SET	FLAG TO	DTFTP
TNREP3:	 MOV	   #6,(R5)	   ;SET	STATE TO 6
	 MOV	   36(R5),SP	   ;REST STACK
	 JMP	   TNMON	   ;RETURN TO MON TOWAIT FOR
;SIGNAL	FROM DTFTP
;
;***********************************************************************
;
;TNSYM:	 THIS ROUTINE RETURNS THE NEXT RECEIVED	WORD (SYMBOL) IN
;	 SYMBUF	(PTR=6(R5)
;	 THE SUBROUTINELTNCHAR	   IS USED TO GET THE NEXT CHAR	INTO
;	 R1.
BUFLEN=32.	   ;LENGTH OF SYMBUF
;IF WORD IS LONGER THAN	64 CHARS IT WILL BE TRUNCATED TO 64
;
TNSYM:	 JSR	   PC,TNCHAR	   ;GET	CHAR
	 CMP	   R1,#SPACE	   ;IS IT SPACE
	 BEQ	   TNSYM	   ;YES, RED LEADING SPACES
	 MOV	   #BUFLEN,16(R5)  ;WORKING COUNTER
	 MOV	   6(R5),4(R5)	   ;INIT ENDBUF
	 CMP	   #CR,R1	   ;CR?
	 BNE	   TNSY1	   ;NO
	 MOVB	   R1,@4(R5)	   ;YES
	 JSR	   PC,TNCHAR	   ;GET	NEXT CHAR
	 CMP	   R1,#LF	   ;LF?
	 BEQ	   TNSY3	   ;YES, RETURN
	 BR	   TNSY3	   ;IMPOSSIBLE,	TAKE A CHANCE
TNSY1:	 CMP	   #LF,R1	   ;IS LF FIRST	CHAR
	 BNE	   TNSY2	   ;NO
	 MOVB	   #CR,@4(R5)	   ;YES, FAKE CR
	 BR	   TNSY3	   ;RETURN
;
;CHAR IS NOT END OF LINE , AND WE HAVE TO READ CHAES TILL
;CR OR SPACE IF	COMMAND(FTP) OR	2 OR 3 CHARS IF	'IAC' OVER THE
;TELNET	CONNECTION
TNSY2:	 DEC	   16(R5)	   ;DEC	NO OF CHARS.
	 MOVB	   R1,@4(R5)	   ;SET	CHAR INO BUFFER
	 CMPB	   R1,#IAC	   ;'INTERPRET AS COMMAND'?
	 BNE	   TNSY4	   ;NO
	 JSR	   PC,TNCHAR	   ;YES	GET NEXT CHAR
	 INC	   4(R5)	   ;INC	ENDPTR
	 MOVB	   R1,@4(R5)	   ;SET	NEW CHAR INTO FILE
	 CMP	   R1,#255.	   ;OPTON REQUEST?
	 BPL	   TNSY3	   ;NO
	 CMP	   #250.,R1	   ;MAY	BE
	 BPL	   TNSY3	   ;NO
	 JSR	   PC,TNCHAR	   ;YES
	 INC	   4(R5)
	 MOVB	   R1,@4(R5)	   ;SET	LAST CHAR INTO BUFFER
TNSY3:	 RTS	   PC		   ;RETURN TO CALLER
;TNSY4:	 READ CHARS TILL CR OR SPACE
;
TNSY4:	 JSR	   PC,TNCHAR	   ;READ NEXT
	 CMP	   R1,#SPACE	   ;SPACE?
	 BEQ	   TNSY3	   ;YES, EXIT
	 CMP	   R1,#CR	   ;CR?
	 BEQ	   TNSY3	   ;YES, EXIT
	 TST	   16(R5)	   ;END	OD BUFFER?
	 BEQ	   TNSY5	   ;READ DUNMY IF YES
	 INC	   4(R5)	   ;NO,	UPDATE ENDPTR
	 DEC	   16(R5)
	 MOVB	   R1,@4(R5)	   ;SET	IN CHAR
	 BR	   TNSY4	   ;AND	READ NEXT CHAR
;TNSY5:	 READ DUMMY TILL CR OR SPACE
TNSY5:	 JSR	   PC,TNCHAR
	 CMP	   R1,#SPACE	   ;SPACE?
	 BEQ	   TNSY3	   ;YES
	 CMP	   R1,#CR	   ;NO,	CR?
	 BEQ	   TNSY3	   ;YES
	 BR	   TNSY5	   ;NO TRY NEXT
;
;***********************************************************************
;
;TNFRZ:	 THIS ROUTINE FREES ALL	BUFFER SPACE, POST THE TNLOG
;	 AND FREEZES ITSELF.
TNFRZ:	 MOV	   36(R5),SP	   ;RESET SATCK	POINTER
	 MOV	   14(R5),R1	   ;FREE REC BUFFER
	 MOV	   #LINPOOL,R0
	 $PUSH	   R5
	 $FREEB			   ;FREE IT
	 $POP	   R5
	 MOV	   6(R5),R1
	 MOV	   #BFPOOL,R0	   ;SYMBOL BUFFER
	 $PUSH	   R5
         $FREEB
	 $POP	   R5
	 MOV	   24(R5),R1	   ;EXCH BUFFER	PTR
	 $PUSH	   R1		   ;SAVE PTR
	 MOV	   R5,R1	   ;FREE WORKOMG AREA
	 MOV	   #WKPOOL,R0
	 $FREEB			   ;FREE IT
	 $POP	   R0		   ;RESET PTR EXCH BUFFER
	 MOV	   #1,FLAG(R0)	   ;SET	FLAG TO	LOGGER
         CLR       PTEX            ;********!!!!!!**********
         $POST     #$LGFTP+2,#RDY+ACK ;POST LOGGER
	 CLR	   R0		   ;ID FOR FREEZE
;
;	 $FREEZE		   ;TO BE SET IN LATER
;
	 JMP	   TNFTP	   ;INTERMEDIATE, TO BE	CHANGED
;
;***********************************************************************
;
;TNCHAR: TAKES ONE CHAR. FROM INPUT BUFFER AND INTO R1.
;	 IF BUFFER IS EMPTY, A NEW BUFFFER IS RECEIVED FROM THE	NET.
;	 COMPLETION OF REC. IS WAITED FOR IN TNMON. IF THE REC.
;	 IS NOT	SUCCESSFUL, THE	RETURN IS TO TNERR ELSE	TNRET.
;	 EXIT FROM TNCHAR IS JSR+2 IF SUCCESSFUL ANDJSR+1 IF UNSUCCESSFU    6
;
;CHECK IF END OF INPUTBUFFER
TNCHAR:	 CMP	   10(R5),12(R5)
	 BPL	   TNRET	   ;NO,	GO AND GET CHARACTER
;YES, SET UP PAR. FOR RECEIVIN A BUFFER
	 MOV	   #LINLEN*10,R3   ;BIT	COUNT
	 MOV	   14(R5),R4	   ;PTR	REC BUFFER
	 MOV	   20(R5),R0	   ;REC	CCT
	 $PUSH	   R5
	 $N.RCV			   ;REC	A BUFFER
	 $POP	   R5
	 JMP	   TNMON	   ;WAIT FOR COMPLETION
;
TNRET:	 MOVB	   @12(R5),R1	   ;CHAR= TO R1
	 INC	   12(R5)	   ;POINTS TO NEXT CHAR
;IF @41	LE. CHAR LE @72		   THEN	CHAR=CHAR AND. @37
;THIS MEANS CONVERTING SMALL ASCII LTTERS TO CAPITAL LETTERS
         CMP       R1,#177         ;IS IT RUBOUT?
         BEQ       TNCHAR          ;YES
	 CMP	   R1,#141	   ;>41?
	 BMI	   TNRTS	   ;NO
	 CMP	   #172,R1	   ;YES,<=72?
	 BMI	   TNRTS	   ;NO
	 BIC	   #40,R1	   ;YES, MASK
TNRTS:	 RTS	   PC
;
;***********************************************************************
;
;TNMON:	 MONITOR ROUTINE WHICH GIVES CONTROL TO	TNCHAR OR DTREC
;	 ACC. TO POST FROM $RCFLO OR DTFTP
;
;	 IF ERROR IN REC RETURN=TNERR ELSE TNRET.
;
TNMON:	 MOV	   20(R5),R0	   ;PTR	TO REC CCT
	 TSTB	   CCTCC(R0)	   ;COMPL. CODE=0?
	 BEQ	   TNMO1	   ;YES, TRY MESS. FROM	DTFTP
	 BITB	   #37,CCTCC(R0)   ;NO,	IS MESSAGE RECEIVED OK?
	 BEQ	   TNMO3	   ;YES
	 CLRB      CCTCC(R0)
        JMP	   TNDOWN	   ;NO,	ERROR RETURN
TNMO3:	 $PUSH	   R5
	 $N.CNT			   ;COUNT REMAINING BYTES
	 $POP	   R5
	 ASR	   R3
	 ASR	   R3		   ;TO BYTES
	 ASR	   R3
	 MOV	   #LINLEN,R2
	 SUB	   R3,R2	   ;NO OF REC BYTES IN R2
	 MOV	   14(R5),10(R5)   ;START OF BUFFER
	 ADD	   R2,10(R5)
	 DEC	   10(R5)	   ;SET	END OF BUFFER
	 MOV	   14(R5),12(R5)   ;CUR	PTR=START OF BUFFER
	 JMP	   TNRET	   ;NORMAL RETURN TO TNCHAR
;
;CHECK LAST POSSIBILITY:SIGNAL FROM FTFTP
;
TNMO1:	 MOV	   24(R5),R0	   ;PTR	EXCH BUFFER
	 MOVB	   FLAGN(R0),R1	   ;GET	CUR. FLAG
	 CMPB	   FLAGO(R0),R1	   ;SAME AS OLD	FLAG?
	 BEQ	   TNMO2	   ;YES
	 MOVB	   R1,FLAGO(R0)	   ;NO,	CHANGE OLD FLAG
	 JMP	   DTREC	   ;HANDLE FLAG
TNMO2:	 $PUSH	   R5
	 $WAIT			   ;WAIT FOR COMPLETION
	 $POP	   R5
	 JMP	   TNMON	   ;COMPLETION,	TRY AGAIN
;***********************************************************************
;
;TNCLS:	 THIS IS A CLOSING OF THE TELNET CONNECTIONS
;
TNCLS:	 $PUSH     R5
         $STIME    2000.           ;DUMMY DELAY
TNCLS1:         $WAIT                     ;WAIT FOR COMPL.
         BIT       #TIM,-(R4)      ;TIMER
         BEQ       TNCLS1          ;WAIT AGAIN
         $POP      R5
         MOV	   20(R5),R0	   ;PTR	EEC CCT
	 $PUSH	   R5
	 $N.CLS			   ;CLOSE PRIMITIVE
MONE1:	 $WAIT			   ;_AIT FOR COMPLETION
	 MOV	   (SP),R5	   ;RESTORE WORKING AREA PTR
	 MOV	   20(R5),R0	   ;CCT
	 TSTB	   CCTCC(R0)
	 BPL	   MONE1	   ;WAIT AGAIN
	 MOV	   22(R5),R0	   ;OK,	CLOSE SEND CONN	NOW
	 $N.CLS
MONE2:	 $WAIT
	 MOV	   (SP),R5
	 MOV	   22(R5),R0	   ;CCT
	 TSTB	   CCTCC(R0)
	 BPL	   MONE2	   ;WAIT AGAIN
	 $POP	   R5
	 RTS	   PC		   ;RETURN
;
;***********************************************************************
;***********************************************************************
;
;BYE:	 ANSWER	TO COMMAND 'BYE'. IF STATE=0 OR	1 THEN REPLY
;'231 USER IS LOGGED OUT , SERVICE TERMINATED' ELSE
;'232 LOGOUT WILL COMPLETE WHEN	FILE TRANSFER COMPLETED' AND
;BYE-FLAG WILL BE SET.
BYE:	 JSR	   PC,DUMMY	   ;RED	DUMMY TILL CR
	 TST	   (R5)		   ;STATE=0?
	 BNE	   BYE2		   ;NO
BYE1:	 MOV	   #M231,R0	   ;YES, SEND REPLY
	 JSR	   PC,TNREP
	 JSR	   PC,TNCLS	   ;CLOSE CONNECTIONS AND
	 JMP	   TNFRZ	   ;GIVE UP CONTROL
BYE2:	 MOV	   #M232,R0	   ;GIVE REPLY
	 JSR	   PC,TNREP	   ;REPLY
         MOV       #1,26(R5)       ;SET BYE-FLAG
	 JMP	   TNMAIN	   ;ACJ	TO COMPLETE DTFTP ACTIONS BEFORE
;LOGOUT
;
;***********************************************************************
;
;HELP:	 HELP GIVES THE	INFORMATION ABOUR THE IMPLEMENTATION.
;
HELP:	 JSR	   PC,DUMMY	   ;READ TILL CR
	 MOV	   #M050,R0	   ;PAR	FOR TNREP
	 JSR	   PC,TNREP	   ;REPLY
	 JMP	   TNMAIN	   ;BACK TO RECEIVE MORE
;
;***********************************************************************
;
;NOOP,R402: THESE ROUTINES GIVE	THE REPLIES
;'402 NLY MAIL SERVICE IMPLEMENTED' OR
;'200 LAST COMMAND RECEIVED CORRECTLY'
;
NOOP:	 JSR	   PC,DUMMY	   ;READ DUMMY TILL CR
	 MOV	   #M200,R0
	 JSR	   PC,TNREP	   ;REPLY
	 JMP	   TNMAIN	   ;BACK TO RECEIVE MORE
;
R402:	 JSR	   PC,DUMMY	   ;READ DUMMY TILL CR
	 MOV	   #M402,R0
	 JSR	   PC,TNREP	   ;REPLY
	 JMP	   TNMAIN	   ;BACK TO RECEIVE MORE
;
;***********************************************************************
;
;DUMMY:	 THIS ROUTINE READS SYMBOLS(WORDS) UNTIL CR IS ENCOUNTERED.
;
DUMMY:	 JSR	   PC,TNSYM	   ;READ ONE WORD
	 MOV	   6(R5),R0	   ;GET	PTR TO BUFFER
	 CMPB	   (R0),#CR	   ;CR?
	 BNE	   DUMMY	   ;F NO, READ ONE MORE	WORD
	 RTS	   PC		   ;YES, RETURN
;
;***********************************************************************
;THE FOLLOWING IS A PRELIMARY ACTION  SPECIFICATION WHEN A COMMAND FROM
;THE TELNET CONN. HAS BEEN RECEIVED.
;
USER=	 R402
PASS=	 R402
ACCT=	 R402
REIN=	 R402
;BYE IS	CODED
;BYTE IS CODED
;SOCK IS CODED
;TYPE IS CODED
FORM=	 R402
;STRU IS CODED
;MODE IS CODED
RETR=	 R402
STOR=	 R402
APPE=	 R402
ALLO=	 R402
REST=	 R402
RNFR=	 R402
RNTO=	 R402
;ABOR IS CODED
DELE=	 R402
LIST=	 R402
NLST=	 R402
STAT=	 R402
;HELP IS CODED
;MLFL IS CODED
;NOOP IS CODED
;
;*;*************************************************************************
;
;
;TNREP:	 GENERAL SUBROUTINE WHICH SENDS	REPLIES	OVER THE TELNET
;	 CONNECTION. AT	ENTRY PTR TO REPLY CODE	MUST BE	IN R0.
;
M050:	 .WORD	   133.*8.
	 .ASCII	   '050-ONLY MAIL SERVICE IMPLEMENTED'
	 .BYTE	   CR,LF
	 .ASCII	   'TYPE=ASCII, NONPRINT OR TELNET FORMAT EFFECTORS'
	 .BYTE	   CR,LF
	 .ASCII	   'MODE=STREAM'
	 .BYTE	   CR,LF
	 .ASCII	   'FILESTRUCTURE=FILE'
	 .BYTE	   CR,LF
	 .ASCII	   '050 BYTESIZE=8'
	 .BYTE	   CR,LF
	 .EVEN
;
M200:	 .WORD	   37.*8.
	 .ASCII	   '200 LAST COMMAND RECEIVED CORRECTLY'
	 .BYTE	   CR,LF
	 .EVEN
;
M201:	 .WORD	   38.*8.
	 .ASCII	   '201 AN ABORT HAS TERMINATED ACTIVITY'
	 .BYTE	   CR,LF
	 .EVEN
;
M202:	 .WORD	   52.*8.
 .ASCII	'202 ABORT REQUEST IGNORED, NO ACTIVITY IN PROGRESS'
	 .BYTE	   CR,LF
	 .EVEN
;
M231:	 .WORD	   44.*8.
	 .ASCII	   '231 USER IS LOGGED OUT, SERVICE TERMINATED'
	 .BYTE	   CR,LF
	 .EVEN
;
M232:	 .ASCII	   '232 LOGOUT WILL COMPLETE WHEN TRANSFER DONE'
	 .BYTE	   CR,LF
	 .EVEN
;
M250:    .WORD     36.*8.
         .ASCII    '250 FTP TRANSFER STARTED CORRECTLY'
         .BYTE     CR,LF
         .EVEN
;
M252:    .WORD     38.*8.
         .ASCII    '252 FTP TRANSFER COMPLETED CORRECTLY'
         .BYTE     CR,LF
         .EVEN
;
M256:    .WORD     20.*8.
         .ASCII    '256 MAIL COMPLETED'
         .BYTE     CR,LF
         .EVEN
;
M300:	 .WORD	   20.*8.
	 .ASCII	   '300 AWAITING INPUT'
	 .BYTE	   CR,LF
	 .EVEN
;
M400:	 .WORD	   33.*8.
	 .ASCII	   '400 THIS SERVICE NOT IMPLEMENTED'
	 .BYTE	   CR,LF
	 .EVEN
;
M401:	 .WORD	   51.*8.
 .ASCII	'401 THIS SERVICE NOT ACCEPTING	USERS NOW, GOODBYE'
	 .BYTE	   CR,LF
	 .EVEN
;
M402:	 .WORD	   35.*8.
	 .ASCII	   '402 ONLY MAIL SERVICE IMPLEMENTED'
	 .BYTE	   CR,LF
	 .EVEN
;
M452:	 .WORD	   53.*8.
 .ASCII	'452 FILE TRANSFER INCOMPLETE, DATA CONNECTION CLOSED'
	 .BYTE	   CR,LF
	 .EVEN
;
M454:	 .WORD	   40.*8.
	 .ASCII	   '454 CANNOT CONNECT TO YOUR DATA SOCKET'
	 .BYTE	   CR,LF
	 .EVEN
;
M455:	 .WORD	   47.*8.
	 .ASCII	   '455 FILE SYSTEM ERROR, DATA CONNECTION CLOSED'
	 .BYTE	   CR,LF
	 .EVEN
;
M500:	 .WORD	   42.*8.
	 .ASCII	   '500 LAST COMMAND COMPLETELY UNRECOGNIZED'
	 .BYTE	   CR,LF
	 .EVEN
;
M503:	 .WORD	   67.*8.
	 .ASCII	   '503 LAST COMMAND IGNORED,'
	 .ASCII	   ' ILLEGAL SYNTAX OR PARAMETER COMBINATION'
	 .BYTE	   CR,LF
	 .EVEN
;
;*****;***********************************************************************
	 
;***********************************************************************
;$BLDSC: BUILDS	A 32 BITS BINARY NUMBER	FROM A STRING OF DECIMAL
;	 DIGITS	AS ASCII CHARACTERS.
;
;	 INPUT:	   R0  POINTS TO FIRST CHARACTER
;		   R1  NUMBER OF DIGITS
;
;	 OUTPUT:   R2  MOST SIGNIFICANT	16 BITS	OF BINARY NUMBER
;		   R3  LEAST SIGNIFICANT 16 BITS OF BINARY NUMBER
;
;	 R1  DESTROYED
;	 R0, R4, R5, R6	 AS BEFORE
;	 CHARACTER STRING AS BEFORE
;
;***********************************************************************
$BLDSC:	 $PUSH	   R4,R5
				   ; INITIALIZE
	 ADD	   R0,R1	   ; R1	 POINTS	TO LAST	DIGIT+1
	 MOV	   #CVTB,R4	    ; R4  POINTS TO CONVERSION TABLE
	 CLR	   R2
	 MOVB	   -(R1),R3	   ; R2:=0   R3:=LAST DIGIT
         BIC       #177760,R3
BLDS1:	 ADD	   #4,R4	   ; FOR REST OF DIGITS	DO
	 CMP	   R0,R1
	 BEQ	   BLDS3	   ; JMP IF DONE
	 MOV	   -(R1),R5
         BIC       #177760,R5
BLDS2:	 BEQ	   BLDS1
	 ADD	   2(R4),R3	   ; ADD FROM  CVTB  TO	 R2, R3
	 ADC	   R2		   ; R5	 TIMES
	 ADD	   (R4),R2
	 DEC	   R5
	 BR	   BLDS2
;
BLDS3:	 $POP	   R5,R4
	 RTS	   PC		   ; RETURN
;
CVTB:	 .WORD	   0,10.	   ; DIGIT 2
	 .WORD	   0,100.	   ; DIGIT 3
	 .WORD	   0,1000.	   ; DIGIT 4
	 .WORD	   0,10000.	   ; DIGIT 5
	 .WORD	   1,103144	   ; DIGIT 6
	 .WORD	   17,037750	   ; DIGIT 7
	 .WORD	   230,077420	   ; DIGIT 8
	 .WORD	   2764,173240	   ; DIGIT 9
	 .WORD	   35621,121100	   ; DIGIT 10
;
	 .EOT
;***********************************************************************
;
;DTREC:	THIS ROUTINE IS	ENTERED	WHEN TNFTP IS POSTED FROM DTFTP
;	 IF THE	TELNET CONNECTONS ARE CLOSED (STATE=6),	LOOK AT	FLAG FRO
;	 DTFTP.	IF 2, WAIT FOR NEW FLAG	FROM DTFTP.
;	 IF NOT	2, GIVE	CONTROL	TO THE LOGGER
;
;	 IF STATE^=6 THEN BEGIN
;	 FLAG=1	   CANT	CONNECT, REPORT, SET STATE=0, GO TO DTTRM
;
;	 FLAG=2	   REPLY 'FILE TRANSFER	STARTED	CORRECTLY'
;	 STATE=2 AND GO	TO TNMON(GET NEW POAT)
;
;	 FLAG=3	   REPLY 'FILE SYSTEM ERROR...'	SET STATE TO 0
;	 AND GO	TO DTTRM
;
;	 FLAG=4	   REPLY 'AN ABOR HAS TERMINATED ACTIVITY AS REQ'
;	 STATE=0 AND GO	TO DTTRM
;
;	 FLAG=5	   REPLY 'FILE TRANSFER	COMPLETED CORRECTLY'
;	 SET STATE=0 AND GO TO DTTRM
;
DTREC:	 CMP	   (R5),#6	   ;STATE=6?
	 BNE	   DTRECV	   ;NO
;AT ENTRY R1 CONTAINS FLAG
	 CMP	   R1,#2	   ;YES, FLAG=2?
	 BEQ	   DTRE1	   ;YES, WAIT OFR ANOTHER FLAG SET
	 JMP	   TNFRZ	   ;NO,	POST LOGGER
DTRE1:	 JMP	   TNMAIN
DTRECV:	 ASL      R1
         ADD	   #DTSTAB,R1	   ;ENTER ACTION ACC. TO FLAG (R0)
	 MOV	   (R1),PC
DTSTAB:	 .WORD	   0,DTREC1,DTREC2,DTREC3,DTREC4,DTREC5
;
DTREC1:	 MOV	   #M454,R0	   ;REPLY 'CANT	CONNECT...
	 JSR	   PC,TNREP
	 CLR	   (R5)		   ;STATE=0
	 BR	   DTTRM
;
DTREC2:	 MOV	   #M250,R0	   ;REPLY 'FILE	TRANSFER STARTED'
	 JSR	   PC,TNREP	   ;SEND REPLY
	 MOV	   #3,(R5)	   ;SET	STATE TO 3
	 JMP	   TNMON	   ;WAIT AGAIN
;
DTREC3:	 MOV	   #M455,R0	   ;REPLY FILE SYSTEM ERROR'
	 CLR	   (R5)		   ;STATE=0
	 JSR	   PC,TNREP
	 BR	   DTTRM
;
DTREC4:	 MOV	   #M201,R0	   ;REPLY 'AN ABOR HAS TREM......
	 JSR	   PC,TNREP
	 CLR	   (R5)
	 BR	   DTTRM
;
DTREC5:	 MOV	   #M252,R0	   ;REPLY 'FILE	TRANSFER COMPLETED CORRE
	 JSR	   PC,TNREP	   ;CTLY
         CLR       (R5)
	 BR	   DTTRM
;
;DTTRM:	 IF BYE-FLAG SET IT SENDS 'USER	IS LOOGED OUT, SERVICE
;	 TERMINATED'
;	 CONTROL IS GIVEN BACK TO TNMON
DTTRM:	 TST	   26(R5)	   ;FLAG SET?
	 BNE	   DTTRM1	   ;YES
	 JMP	   TNMON	   ;NO
DTTRM1:	 CLR	   26(R5)	   ;CLEAR FLAG
	 JMP	   BYE1
;
;***********************************************************************
;
;MLFL:	  GETS CONTROL WHEN 0HE	COMMAND	'MLFL' HAS BEEN	RECEIVED
;	 THE COMMAND IS	ONLY ACCEPTED WHEN STATE=0, AND	IN THAT
;	 CASE DTFTP IS POSTED FOR DATA (MAIL) TRANSFER.
;
MLFL:	 JSR	   PC,DUMMY	   ;READ DUMMY TILL CR
	 TST	   (R5)		   ;STATE=0?
	 BEQ	   MLFL1	   ;YES
	 MOV	   #M202,R0	   ;NO,	ISSUE '202 LSAT	COMMAND
;				   INVALID'
         JSR       PC,TNREP
	 JMP	   TNMAIN	   ;BACK TO RECEIVE MORE
MLFL1:	 MOV	   24(R5),R0	   ;PTR	EXCH BUFFER
	 CLR	   FLAGTD(R0)	   ;FLAG TNFTP-DTFTP
	 CLR	   FLAGN(R0)	   ;FLAG THE OTHER WAY
	 MOV	   #M200,R0	   ;REPORT SUCCESS
	 JSR	   PC,TNREP
         MOV       24(R5),PTEX     ;*********!!!!!!**********
         $PUSH     R5
	 $POST	   #$DTPCT+2,#RDY+ACK ;POST DTFTP
         $POP      R5
	 MOV	   #2,(R5)	   ;STATE=2
	 JMP	   TNMAIN	   ;OK,	DONE
;
;***********************************************************************
;
;ABOR:	 GIVEN CONTROL WHEN THE	COMMAND	ABOR IS	RECEIVED.
;	 THE COMMAND SYNTAX IS CHECKED.
;	 IF STATE=2 OR 3 THEN COMMAND OK, ANSWER  WITH POSTING
;	 DTFTP AND REPLY SUCCESS, ELSE REPLY NEG.
;
ABOR:	 JSR	   PC,TNSYM	   ;READ NEXT WORD
	 MOV	   6(R5),R0	   ;SEE	IF CR
	 CMPB	   (R0),#CR
	 BEQ	   ABOR1	   ;SYNTAX OK
	 MOV	   #M503,R0	   ;NO,	REPL SYNTAX ERROR
	 JSR	   PC,TNREP
	 JMP	   TNMAIN	   ;GETNEXT COMMAND
ABOR1:	 CMP	   (R5),#2	   ;STATE =2?
	 BEQ	   ABOR2	   ;YES
	 CMP	   (R5),#3	   ;IS IT 3?
	 BEQ	   ABOR2	   ;YES
;REPLY 'ABOR REQUEST IGNORED, NO ACTIVITY IN PROGRESS'
	 MOV	   #M202,R0
	 JSR	   PC,TNREP
	 JMP	   TNMAIN
ABOR2:	 MOV	   #M200,R0	   ;REPORT SUCCESS
	 JSR	   PC,TNREP
	 MOV	   #5,(R5)	   ;SET	STATE=5
	 MOV	   24(R5),R0
	 MOV	   #1,FLAGTD(R0)   ;SET	FLAG FOR DTFTP
	 $POST	   #$DTPCT+2,#RDY+ACK ;POST IT
	 JMP	   TNMAIN	   ;AND	GET NEW	COMMAND
;
;***********************************************************************
;
;TYPE:	 THE ONLY PAR COMBINATIONS ALLOWED ARE:
;	 A!A N!A T
;
CHRA=	 101
CHRN=	 116
CHRT=	 124
;
TYPE:	 JSR	   PC,TNSYM	   ;READ PARAMETER
	 CMP	   6(R5),4(R5)	   ;TEST IF ONE	CHAR
	 BNE	   TYPE7	   ;NO,	ERROR
	 MOV	   6(R5),R0	   ;CR?
	 CMPB	   (R0),#CR
	 BEQ	   TYPE8	   ;ERROR
	 CMPB	   (R0),#CHRA	   ;A?
	 BNE	   TYPE7	   ;NO,	ERROR
	 JSR	   PC,TNSYM	   ;YES, READ NEXT
	 CMP	   6(R5),4(R5)	   ;ONE	CHAR?
	 BNE	   TYPE7	   ;NO,	ERROR
	 CMPB	   (R0),#CR	   ;CF?
	 BEQ	   TYPE10	   ;YES, OK
	 MOV	   6(R5),R0
	 CMPB	   (R0),#CHRT	   ;NO,	T?
	 BEQ	   TYPE6	   ;YES
	 CMPB	   (R0),#CHRN	   ;NO,	N?
	 BNE	   TYPE7	   ;NO,	ERROR
TYPE6:	 JSR	   PC,TNSYM	   ;YES
	 CMPB	   @6(R5),#CR	   ;CR?
	 BNE	   TYPE7	   ;NO,	ERROR
TYPE10:	 MOV	   #M200,R0	   ;REPORT SUCCESS
	 JSR	   PC,TNREP
	 BR	   TYPE9
TYPE7:	 JSR	   PC,DUMMY
TYPE8:	 MOV	   #M503,R0	   ;REPLY
	 JSR	   PC,TNREP
TYPE9:	 JMP	   TNMAIN
;***********************************************************************
;
;STRU:	 ALLOWED PARAMETER = F (FILE)
;
CHRF=	 106
STRU:	 JSR	   PC,TNSYM	   ;READ PARAMETER
	 CMP	   6(R5),4(R5)	   ;ONE	CHAR?METER
	 BNE	   STRU5	   ;NO,	ERROR
	 MOV	   6(R5),R0	   ;GET	CHAR
	 CMPB	   (R0),#CR	   ;CR?
	 BEQ	   STRU6	   ;ES,	ERROR
	 CMPB	   (R0),#CHRF	   ;NO,	F?
	 BNE	   STRU5	   ;NO,	ERROR
	 JSR	   PC,TNSYM	   ;YES, READ NEXT PAR
	 CMPB	   @6(R5),#CR	   ;CR?
	 BNE	   STRU5	   ;NO,	ERROR
	 MOV	   #M200,R0	   ;YES, REPORT	SUCCESS
	 JSR	   PC,TNREP
	 BR	   STRU7
STRU5:	 JSR	   PC,DUMMY	   ;READ DUMMY TILL CR
STRU6:	 MOV	   #M503,R0	   ;ERROR REPLY
	 JSR	   PC,TNREP
STRU7:	 JMP	   TNMAIN	   ;BACK TO GET	ANOTHER	COMMAND
;
;***********************************************************************
;
;BYTE:	 READ ONE PAR.,	IF 8 REPORT SUCCESS
;
BYTE:	 JSR	   PC,TNSYM	   ;READ PARAMETER
	 MOV	   6(R5),R0	   ;PTR	FIRST CHAR
	 CMPB	   (R0),#CR	   ;END	OF COMMAND?
	 BEQ	   BYTE5	   ;YES, SYNTAX	ERROR
	 MOV	   4(R5),R1	   ;END	PTR
	 SUB	   R0,R1	   ;BYTE COUNT
	 INC	   R1
	 CMP	   R1,10.	   ;>10	DIGITS
	 BPL	   BYTE4	   ;YES, ERROR
	 JSR	   PC,$BLDSC	   ;NO,	RETURN WITH NO IN R2,R3
	 CMP	   R3,#8.
	 BNE	   BYTE4	   ;ERROR IF NOT 8
	 TST	   R2		   ;TEST HIGH ORDER BITS
	 BNE	   BYTE4	   ;TO ERROR IF	NOT 0
;
	 JSR	   PC,TNSYM
	 CMPB	   @6(R5),#CR	   ;CHECK IF CR
	 BNE	   BYTE4	   ;NO,	ERROR
	 MOV	   #M200,R0	   ;SUCCESS
	 JSR	   PC,TNREP
	 BR	   BYTE6
BYTE4:	 JSR	   PC,DUMMY
BYTE5:	 MOV	   #M503,R0	   ;REP-Y ERROR
	 JSR	   PC,TNREP
BYTE6:	 JMP	   TNMAIN
;
;***********************************************************************
;
;SOCK:	 READ A	COMMAND	OF THE FORMAT
;	 'SOCK <HOST NO>,<SOCK NO > OR 'SOCK <SOCK NO>'
;	 IF SYNTAX IS WRONG OR NUMBERS OUT OF ORDER, REPLY
;	 WITH '503 ILLEGAL SYNTAX.....'
;
COMMA=	 54
;
SOCK:	 SUB	   #6,SP	   ;SAVE STACK FOR SOCK,HOST NO
	 MOV	   24(R5),R0
	 MOV	   PICP(R5),R0	   ;SAVE HOST DEFAULT VALUE
	 MOV	   CCTHOS(R0),(SP)
	 JSR	   PC,TNSYM	   ;READ PARAMETER
	 MOVB	   6(R5),R0	   ;FIRST BYTE
	 CMPB	   (R0),#CR	   ;IS IT CR?
	 BEQ	   SOCK11	   ;YES, REPLY ERROR
	 CMPB	   (R0),#COMMA	   ;CHECK IF COMMA
	 BEQ	   SOCK11	   ;YES
	 MOV	   #1,R1	   ;NO,	INIT LOOP
	 MOV	   R0,R4
SOCK2:	 CMP	   R4,4(R5)	   ;END	OF SYMBUF?
	 BEQ	   SOCK4	   ;YES
	 INC	   R4		   ;NO,	GET CHAR.
	 CMPB	   (R4),#COMMA	   ;IS IT COMMA?
	 BEQ	   SOCK6	   ;YES, READ HOST NO
	 INC	   R1		   ;NO,	INCR NO	OF CHARS.
	 BR	   SOCK2	   ;AND	LOOP AGAIN
;
;SOCK4:	 BUILD A SOCK NO, THE POINTER IS IN R0,R1
;
SOCK4:	 CMP	   R1,10.	   ;IF >10 DIGITS, ERROR
	 BPL	   SOCK10	   ;ERROR REPLY
	 JSR	   PC,$BLDSC	   ;BUILD NO
	 MOV	   R2,2(SP)	   ;SAVE
	 MOV	   R3,4(SP)
	 JSR	   PC,TNSYM	   ;READ NEXT
	 CMPB	   @6(R5),#CR	   ;IS IR CR?
	 BNE	   SOCK10	   ;ERROR
	 MOV	   24(R5),R0	   ;SUCCESS, SET IN HOST,SOCK NO INTO CC
	 MOV	   PICP(R0),R0
	 MOV	   (SP),CCTHOS(R0) ;HOST NO
	 MOV	   2(SP),CCTFGN(R0)
	 MOV	   4(SP),CCTFGN+2(R0) ;SET SOCKET NO
	 MOV	   #M200,R0	   ;REPORT SUCCESS
	 JSR	   PC,TNREP
	 BR	   SOCK12
;
;SOCK6:	 FIND HOST NO
;
SOCK6:	 JSR	   PC,$BLDSC	   ;BUILD HOST NO
	 TST	   R2
	 BNE	   SOCK10	   ;TOO	LARGE
	 CMP	   R3,#400
	 BPL	   SOCK10	   ;TOO	LARGE
	 CMP	   R4,4(R5)	   ;LAST CHAR?
	 BEQ	   SOCK10	   ;YES, SYNTAX	ERROR
	 MOV	   R3,(SP)	   ;OK,	SAVE HOST NO
	 MOV	   4(R5),R1	   ;END	PTR
	 SUB	   R4,R1	   ;GET	NO OF CHARS
	 MOV	   R4,R0	   ;START PTR
	 BR	   SOCK4	   ;AND	FIND SOCK NO
;
SOCK10:	 JSR	   PC,DUMMY	   ;READ DUMMY RILL CR
SOCK11:	 MOV	   #M503,R0
	 JSR	   PC,TNREP	   ;REPLY ERROR
SOCK12:	 ADD	   #6,SP	   ;RESET STACK
	 JMP	   TNMAIN
;***********************************************************************
;
;MODE:	 ALLOWED PARAMETER = S (STREAM)
;
CHRS=	 123
MODE:	 JSR	   PC,TNSYM	   ;READ PARAMETER
	 CMP	   6(R5),4(R5)	   ;ONE	CHAR?METER
	 BNE	   MODE5	   ;NO,	ERROR
	 MOV	   6(R5),R0	   ;GET	CHAR
	 CMPB	   (R0),#CR	   ;CR?
	 BEQ	   MODE6	   ;ES,	ERROR
	 CMPB	   (R0),#CHRS	   ;NO,	S?
	 BNE	   MODE5	   ;NO,	ERROR
	 JSR	   PC,TNSYM	   ;YES, READ NEXT PAR
	 CMPB	   @6(R5),#CR	   ;CR?
	 BNE	   MODE5	   ;NO,	ERROR
	 MOV	   #M200,R0	   ;YES, REPORT	SUCCESS
	 JSR	   PC,TNREP
	 BR	   MODE7
MODE5:	 JSR	   PC,DUMMY	   ;READ DUMMY TILL CR
MODE6:	 MOV	   #M503,R0	   ;ERROR REPLY
	 JSR	   PC,TNREP
MODE7:	 JMP	   TNMAIN	   ;BACK TO GET	ANOTHER	COMMAND
;
;***********************************************************************
	 .END
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           