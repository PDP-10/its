	.NLIST

	.enabl	lc		; // don't fold unnecessarily //

	.MACRO	$SNAME		; ASCII SYSTEM NAME
	.ASCII	"UCB ELF-I TELNET"
	.ENDM	$SNAME

	.MACRO	$CNFIG		;SYSTEM PROCESSOR CONFIGURATION
P1145	=	0		;SET PDP 11/45 PROCESSOR
P1140	=	1		;NOT AN 11/40
P1120	=	0		;SET 11/20 PROCESSOR
P1105	=	0		;NOT AN 11/05
P1110	=	0		;NOT AN 11/10
PEAE	=	0		;NO EAE
PMDV	=	1		; MULTIPLY/DIV ON 1140/45
PMMGMT	=	0		;MEMORY MANAGEMENT OPTION
PFLTPT	=	0		; FLT POINT OPTION

	.IF NE P1140+P1145+P1120+P1110+P1105-1
	.ERROR	P1145	;PROCESSOR SPECIFICATION ERROR
	.ENDC
	.IF EQ	P1105!P1110!P1120!P1140!P1145
	.ERROR	1	;PROCESSOR SPECIFICATION ERROR
	.ENDC
	.IF NE P1120!P1110!P1105&PMMGMT
	.ERROR	PMMGMT	;MEMORY MANAGEMENT ERROR
	.ENDC

;	-------   CLOCK  SPECIFICATION   -------

;	POSSIBLE CLOCKS:

KW11P	= 1		; PROGRAMMABLE CLOCK
KW11L	= 2		; LINE CLOCK
KWVDH	= 3		; EMBEDDED IN IMP INTERFACE

CLOCK	= KWVDH		; <---- SPECIFY PROGRAMMABLE CLOCK

;			DOSSYS DEFINED IF RUNS UNDER 
;			DEC DOS SYSTEM
DOSSYS	=	1	;SET DOS OPTION
DOSRG1	=	177406	;BOOTSTRAP REG 1 (RC-11)
DOSBUT	=	77000	;START ADDRESS OF BOOT
BINDER	=	157444	;Restart address of binder (i.e. loader)
;
;	-------  IMP INTERFACE SPECIFICATION  -------

;	POSSIBLE INTERFACES:

IIVDH	= 1		;  VERY DISTANT HOST
IIISI	= 2		;  ISI VARIANT OF ANTS INTERFACE
IIANTS	= 3		;  STRAIGHT ANTS INTERFACE

IITYPE	= IIVDH		; <--- INTERFACE IS VERY DISTANT HOST.
	.ENDM


	.MACRO $DFREG
R0=%0
R1=%1
R2=%2
R3=%3
R4=%4
R5=%5
R6=%6
SP=%6
PC=%7
PS=177776		;PROCESSOR STATUS
	.IF NE	P1140!P1145&PMMGMT	;MEMORY MANAGEMENT?
KDR0	=	172300	;KERNEL DESCRIPTOR REG 0 (I-SPACE)
KAR0	=	172340	;KERNEL ADDRESS REG 0
UDR0	=	177600	;USER DESCRIPTOR REG 0 (I-SPACE)
UAR0	=	177640	;USER ADDRESS REG 0

SR0	=	177572	;SEGMENTATION REG 0
SR1	=	177574	;SEG REG	1
SR2	=	177576	;SEG REG	2
	.IF EQ	P1145&PMMGMT-1
SR3	=	172516	;SEG STAT REG 3  11/45 ONLY
	.ENDC
	.ENDC
	.IF EQ	PEAE-1		;EAE DEFINED
AC = 177302		;EAE -- AC
MQ = 177304		;EAE -- MQ
XMPY = 177306		;MULTIPLICAND
XSTAT = 177310		;EAE -- SC,STATUS BYTES
XDVSR = 177300		;EAE -- DIVISOR REGISTER
LSHFT = 177314		;EAE -- LOGICAL SHIFT
ASHFT = 177316		;EAE -- ARITHMETIC SHIFT
	.ENDC
	.IF EQ	PEAE!PMDV	;NO EAE NOR MULDIV?
	.GLOBL	$AC,$MQ,$XDVSR,$XMUL,$MUL,$DIV
	.ENDC
	.ENDM

	.MACRO	$TTYRG
;		*** DEVICE REGISTERS FOR TTY ***

TKS = 177560
TKB = 177562
TPS = 177564
TPB = 177566

TKIV = 60		;TELETYPE KB INT VECT
TPIV = 64		;TELEPRINTER INT VECT
	.ENDM


	.MACRO	$N.CON
	TRAP	11	;CONNECT
	.ENDM	$N.CON

	.MACRO	$N.LSN	
	TRAP	12	;LISTEN
	.ENDM	$N.LSN
	.MACRO	$N.CLS
	TRAP	13
	.ENDM	$N.CLS

	.MACRO	$N.SND
	TRAP	14
	.ENDM	$N.SND

	.MACRO	$N.RCV
	TRAP	15
	.ENDM	$N.RCV

	.MACRO	$N.CNT
	TRAP	16
	.ENDM	$N.CNT

	.MACRO	$N.STA
	TRAP	17
	.ENDM	$N.STA


	.MACRO	$NETHW
	.IF EQ	IITYPE-IIVDH
;			HARDWARE REGISTERS
;			FOR VERY-DISTANT HOST
;			TYPE CONNECTION TO ARPA NET
;			S C R L

VDIVI = 270		;INTERRUPT VECTOR IN
VDIVO = 274		;INTERRUPT VECTOR OUT

VDHSI = 167600		;STATUS IN
VDHBI = VDHSI + 2	;DATA BUFFER IN
VDHMI = VDHSI + 4	;M.A.R. IN
VDHWI = VDHSI + 6		;W.C. IN

VDHSO = 167610		;STATUS OUT
VDHBO = VDHSO + 2		;DATA BUFFER OUT/CLOCK
VDHMO = VDHSO + 4		;M.A.R. OUT
VDHWO = VDHSO + 6		;W.C. OUT

;			BIT ALLOCATION IN STATUS REGS

VDOIE = 100		;VDH OUTPUT INTERRUPT ENABLE BIT
TMRE = 20		;TIMER RUN ENABLE
TMPT = 40		;CLOCK POINTER IN OUTPUT BUFFER
TIMI = 4		;TIMER INTERRUPT ENABLE
VDEOD = 10		;OUTPUT EOD INTERRUPT
VDIIP = 4		;DEVICE POINTER/ INPUT
VDEOT = 2		;END OF TRANSFER
	.ENDC
	.if ne	<iitype-iiisi>!<iitype-iiants>

;		IMP interface hardware definition
	.if eq	iitype-iiisi
;		for USC-ISI (modified ANTS) interface.
	.iff
;		for standard ANTS interface.
	.endc

;  ------------- Register Addresses ---------------

impspi	= 164000		; Start pointer		input
	.if eq	iitype-iiisi
impbci	= 164002		; Byte count		input
	.iff
impepi	= 164002		; End pointer		input
	.endc
imps1i	= 164004		; Status register 1	input
imps2i	= 164006		; Status register 2	input


impspo	= 164010		; Start pointer		output
	.if eq	iitype-iiisi
impbco	= 164012		; Byte count		output
	.iff
impepo	= 164012		; End pointer		output
	.endc
imps1o	= 164014		; Status register 1	output
imps2o	= 164016		; Status register 2	output


impivi	= 170			; Input interrupt vector
impivo	= 174			; Output interrupt vector


;  ----------------  Bit Definitions  ------------------

;		input status register 1:

imperr	= 100000		; IMP error
nexmem	= 040000		; Nonexistent memory
bceq0	= 010000		; Byte count = 0
busy	= 004000		; Busy
endmsg	= 000400		; End of message
bufull	= 000200		; Input buffer full
intena	= 000100		; Interrupt enable
noswap	= 000020		; Suppress byte swapping
	.if eq	iitype-iiisi
memex	= 000006		; Memory address extenstion
	.endc

;		input status register 2:

tstinc	= 002000		; Test increment
lock	= 001000		; Lock interface (don't start
	.if eq	iitype-iiisi
				;     when BCI is loaded)
	.iff
				;     when EPI is loaded)
	.endc
loop	= 000400		; Loop output to input
imprdy	= 000200		; IMP master ready
scosyn	= 000001		; Scope sync


;		output status register 1:

nexmem	= 040000		; Nonexistent memory
bceq0	= 010000		; Byte count = 0
busy	= 004000		; Busy
done	= 000200		; Done
intena	= 000100		; Interrupt enable
noswap	= 000020		; Suppress byte swapping
	.if eq	iitype-iiisi
memex	= 000006		; Memory address extension
	.endc
diseom	= 000001		; Disable end of message

;		output status register 2:

ireset	= 000400		; Interface reset
hosrdy	= 000001		; Host master ready

	.endc
	.endm	$nethw
	.MACRO	$DISCC
;			SCRL/ARPANET  DISPATCHER
;			CONTROL BYTE BIT ASSIGNMENTS

RDY = 200		;PROCESS READY TO BE DISPATCHED
TIM = 100		;TIMER HAS GONE OFF
IO  = 40		;I/O INTERRUPT
ACK = 20		;RQST ACK TO TRANSMIT
BUF = 10		;BUFFER OBTAINED

	.ENDM


	.MACRO $GPCT NEXT,PQE,ENTRY,PRIO	;GENERATE PCT
	.WORD	NEXT			;A(NEXT IN CHAIN)
	.WORD	100000		; PCT CONTROL BYTE, RDY FLAGS
	.WORD	.+110.+10.		; STACK POINTER /ISI-PR/
	.WORD	PQE+2	;PRIOQ PTR
	.WORD	0	; .RCV COMPLETION CODE MASK	/ISI-PR/
	.WORD	0	; PENDING MSG QUEUE FOR .RCV	/ISI-PR/
	.WORD	70707	;STACK FLAG WORD
	.BLKB	110.	;STACK SPACE		/ISI-PR/
	.WORD	ENTRY,PRIO	;EP OF PROCESS
	.ENDM	$GPCT		;END GEN PCT

	.MACRO	$GPRQ PQNEXT,PRIO,HEAD,TAIL
	.WORD	PQNEXT+2,HEAD,TAIL,PRIO	;DEFINE PRIO Q LVL
	.ENDM	$GPRQ

	.MACRO $WAIT		;WAIT ON EVENT
	TRAP	0		;ISSUE TRAP FOR $WAIT
	.ENDM	$WAIT

	.MACRO	$POST PCTA,REASON	;FLAG AN EVENT COMPLETE
	MOV	REASON,R1 ;LOAD CONDX CODE
	MOV	PCTA,R0	;SET PCT ADDR CONTROL BYTE
	TRAP	5		;TRAP TO POST ROUTINE
	.ENDM

	.MACRO	$ATTCH	EP,PRIO
	MOV	#PRIO,-(SP)
	MOV	#EP,-(SP)	;SETUP ENTRY AND PRIORITY
	TRAP	6	;TRAP TO $ATTCH ROUTINE
	.ENDM	$ATTCH


	.MACRO	$ALOCB
	TRAP	2
	TST	R1		;TEST STATUS
	.ENDM	$ALOCB

	.MACRO	$FREEB
	TRAP	3
	.ENDM	$FREEB

	.MACRO	$STIME VALUE,PCTA	;SET THE TIMER
	.IF	EQ VALUE
	CLR	R1		;INDICATE CANCELTIMER
	.ENDC
	.IF	NE VALUE
	MOV	#VALUE,R1	;PUT TIME VALUE IN R1
	.ENDC
	.IF	NB PCTA
	MOV	#PCTA+2,R2	;MOVE PCTADDR TO R2
	.ENDC
	.IF	B PCTA
	CLR R2			;CLEAR PCT ADDR (INDIC $APCT)
	.ENDC
	TRAP	1		;ISSUE TRAP TO SET TIMER
	.ENDM	$STIME

	.MACRO	$GTQE COUNT
	.REPT	COUNT-1
	.WORD	0	;PCT ADDR CONTROL BYTE
	.WORD	0	;TIME VALUE
	.WORD	.+6	;NEXT ONE IN LINE
	.ENDM
	.WORD	0	;PCT ADDR
	.WORD	0
	.WORD	0
	.ENDM	$GTQE	;  END   G T Q E

	.MACRO	$DFHTE	;DEFINE HOST TABLE ENTRY

HTEID = 0
HTECTI = 2		;CT CHAIN INPUT CONNS
HTECTO = 4		; CT CHAIN OUTPUT
HTLINK = 6		; LINK ALLOCATION FLAGS
HTEST = 17		;HOST STATUS BYTE
HTCLQ = 20		;NEXT, LAST (CONTROL LINK QUEUE )
HTDIR = 24		;HOST NAME DIRECTORY POINTER
HTMQA = 26		;ACTIVE MSG ON CONTROL LINK (MQE)

	.ENDM	$DFHTE

	.MACRO	$DFCT	; DEFINE CONNECTION TABLE ENTRY
CTHL = 0		;HOST LINK
CTLINK = 2		;LINK NR FOR THIS CONN.
CTHTA = 4		;HTE POINTER
CTPCT = 6		;PCT ADDRESS CONTROL BYTE
CTSTAT = 10		;CONNECTION STATUS
CTBSIZ = 11		;CONNECTION BYTE SIZE
CTLCL = 12		;LOCAL SOCKET NR
CTFGN = 14		;FGN SCK NR
CTMCT = 20		;MESSAGE COUNTER
CTBCT = 22		;BIT COUNTER    *** FOR FLOW CONTROL
CTOFFI = 26		;BIT COUNT OFFSET, INPUT
CTOFFO = 27		;BIT COUNT OFFSET, OUTPUT
CTQ  = 30		;OUTPUT QUEUE (NEXT,LAST)
CTADI = 34		;ADDRX IN (MOVEBITS)
CTBCI = 36		;BIT COUNT IN (MOVEBITS)
CTADO = 40		;ADDRESS OUT (MOVEBITS)
CTBCO = 42		;BIT COUNT OUT (MOVEBITS)
CTCCT = 44		;ADDRX OF CONNECTION COMM. TBL
CTMQP = 46		;INPUT MESSAGE QUEUE POINTER
CTMQA = 50		;OUTPUT ACTIVE MQE ON CONN.
CTWD  =  CTMQA+2	;WATCHDOG PROCESSOR TIMER WORD
CTLEN = CTWD+2/2	;CONN. TBL LENGTH, WORDS

	.ENDM
	.MACRO	$DFDIR	NX,MIN,CNT,EP,CHSTR
	.WORD	NX+2
	.BYTE	MIN,CNT
	.WORD	EP
	.ASCII	'CHSTR'
	.EVEN
	.ENDM	$DFDIR


	.MACRO	$IOT		;TRAP TO IO CONTROL
	TRAP	10		;IO TRAP
	.ENDM	$IOT

	.MACRO	$DFTCA
TCANXT	=	0
TCAESC	=	2	;ESCAPE CHAR
TCAMOD	=	3	;TERMINAL MODE
;			 OFFSETS 4 AND 5 NOT USED
TCADCI	=	6	;DCT INPUT
TCADCO	=	10	;DCT OUTPUT
TCALI	=	12	;LINE BUFFER IN
TCALO	=	14	;LINE BUFFER OUT
TCAIPT	=	16	;INPUT BUFFER PTR (FOR PARSER)
TCACCI	=	20	;CONNECTION CCT IN
TCACCO	=	22	;CONNECTION CCT OUT
TCACHD	=	24	;CCT CHAIN HEAD
TCACTL	=	26	;CCT CHAIN TAIL
TCAL	=	14	;LENGTH OF TCA (WORDS)

; Bit definitions for TCAMOD
TCBESC	=	200
TCBPAG	=	40
TCBFIL	=	20
TCBTAB	=	10
TCBECO	=	4
	.ENDM	$DFTCA

	.MACRO	$DFDCT		;DEFINE DEVICE CONTROL TABLE
DCTMA	=	0	;MATE DCT (FOR TERMINALS)
DCTCSR	=	2	;CSR PTR FOR TTY-LIKE DEVS
DCTIV	=	4	;INT VECTOR PTR
DCTA	=	6	;ADDRX ACTIVE TRANSFER
DCTCNT	=	10	;CHAR COUNT (BYTES)
DCTPCT	=	12	;ACTIVE PCT ASSOC WITH DCT
DCTTTY	=	14	;TTY NUMBER (PHYSICAL)
DCTFCN	=	15	;FUNCTION/STATUS
DCTTCA	=	16	;A(ASSOC. TCA)
DCTOPN	=	20	;A(OPEN ROUTINE)
DCTRDW	=	22	;A(READ/WRITE)
DCTCLS	=	24	;A(CLS ROUTINE)
DCTIPR	=	26	;INTERRUPT PROCESSOR
DCTEND	=	32	;END INTERRUPT ATRIUM
DCTHCT 	=	32	;HORIZ COUNT
DCTVCT	=	33	;VERTICAL COUNT (FOR FORM)
DCTFIL	=	34	;FILL COUNT (FOR TERMINALS)
DCTTCT	=	35	;TAB COUNT (FOR TERMINALS)
DCTECT	=	36	;ERROR COUNT (FOR DEVICES W/ PARITY)
	.ENDM	$DFDCT

	.MACRO	$GDCT	DCTMA,CSR,IV,TTY,OPN,RDW,CLS,DCTIP
	.WORD	DCTMA,CSR
	.WORD	IV,0,0,0
	.BYTE	TTY,0	;TTYNR, FUNCT
	.WORD	0	;TCA POINTER
	.WORD	OPN,RDW,CLS
;			SAVE R0 AND LINK TO INTRPT ROUTINE
	JSR	R0,DCTIP	;LINK TO INTERRUPT PROCESSOR
	.WORD	0		;HORIZ, VER TAB COUNTS
	.BYTE	0		;FILL COUNT
	.BYTE	0		;TAB COUNT
	.BYTE	0		; ERROR COUNT
	.BYTE	0		; NOT USED
	.ENDM	$GDCT



	.MACRO	$PUSH	A,B,C,D,E,F,G
	.IF	NB	A
	MOV	A,-(SP)
	.ENDC
	.IF	NB	B
	MOV	B,-(SP)
	.ENDC
	.IF	NB	C
	MOV	C,-(SP)
	.ENDC
	.IF	NB	D
	MOV	D,-(SP)
	.ENDC
	.IF	NB	E
	MOV	E,-(SP)
	.ENDC
	.IF	NB	F
	MOV	F,-(SP)
	.ENDC
	.IF	NB	G
	MOV	G,-(SP)
	.ENDC
	.ENDM	$PUSH

	.MACRO	$POP	A,B,C,D,E,F,G
	.IF	NB	A
	MOV	(SP)+,A
	.ENDC
	.IF	NB	B
	MOV	(SP)+,B
	.ENDC
	.IF	NB	C
	MOV	(SP)+,C
	.ENDC
	.IF	NB	D
	MOV	(SP)+,D
	.ENDC
	.IF	NB	E
	MOV	(SP)+,E
	.ENDC
	.IF	NB	F
	MOV	(SP)+,F
	.ENDC
	.IF	NB	G
	MOV	(SP)+,G
	.ENDC
	.ENDM	$POP


	.MACRO	$ERROR	CODE
	MOV	#CODE,-(SP)		;SET ERR CD
	TRAP	4			;TO SYS ERR
	.ENDM


	.MACRO	$DFCCT

CCTHOS = 0	;HOST ID
CCTOP = 1
CCTCC = 2	;COMPLETION CODE
CCTBS = 3	;BYTE SIZE
CCTLCL = 4	;LCL SCK
CCTFGN = 6	;FGN SCK

	.ENDM


	.MACRO	$DFSCC		;DEFINE SOCKET COMPLETION CODES

WCCCMP = 200		;OPERATION COMPLETE, NO ERRORS
WCCUDH = 201		;ERROR, UNDEFINED HOST
WCCNL = 202		;NO LINKS AVAILABLE
WCCIVO = 203		;INVALID OP (CONNECT ON OPEN SCK)
WCCNXC = 204		;ATTEMPTED CLOSE ON NON-EXISTENT CONN
WCCWCL = 205		;ATTEMPTED CLOSE ON CLOSE-WAIT SCK
WCCID = 206		;IMP DIED
WCCHD = 207		;HOST DIED
WCCDED = 210		;LOCAL IMP CONN BROKEN ($DEAD)
WCCCLS = 211		;CONNECTION CLOSED
WCCTIM = 212		;TIME-OUT ERROR (CONN. CLOSED)


	.ENDM	$DFSCC

	.MACRO $MOVE FROM,TO,CNT
	JSR	R5,$MOVE
	.WORD	FROM,TO,CNT
	.ENDM


;<VOICE>ELFMAC.ISI-ADDITIONS;3    19-MAR-74 17:25:11	EDIT BY RAVELING

;	Added .list at end, to pop listing level up.  This matches
;	the .nlist at the start of the macro file.

;<VOICE>ELFMAC.ISI-ADDITIONS;2    11-MAR-74 03:59:19	EDIT BY RAVELING

;	Added .PCTD (PCT field definitions)

;<VOICE>ISI-ELF-MACROS.M11;2    11-MAR-74 03:04:28	EDIT BY RAVELING

;	Corrected configuration check used to generate sob
;	in .loop.  It had checked for EIS, now checks for
;	model 40 or 45.

;<VOICE>ISI-ELF-MACROS.M11;1     5-MAR-74 17:31:03	EDIT BY RAVELING

;	Defined .loop macro.

	.macro	.loop reg,loc
	.if ne	p1145!p1140
	sob	reg,loc
	.iff
	dec	reg
	bgt	loc
	.endc
	.endm	.loop


	.macro	.PCTD			; PCT field definitions
PCTNXT	= 0		; Next PCT pointer for ready queue
PCTCB	= 2		; Completion variable
PCTWT	= 3		; Waiting/blocked state flags
PCTSP	= 4		; Saved stack pointer
PCTPQP	= 6		; PRQ pointer
PCTRCM	= 10		; .RCV completion code mask
PCTPMQ	= 12		; Pending msg queue for .RCV
PCTFLG	= 14		; Stack overflow detection flag

PCTSTK	= 200		; Bottom of stack
	.endm	.PCTD
	.list
