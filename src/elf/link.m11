;	PDP-11 LINKER,LINK V011A
;	COPYRIGHT 1970,1971,1972 DIGITAL EQUIPMENT CORPORATION
;       14 AUG 72
	.TITLE	LINK
;	TAPE 1
;
.MCALL	.CLOSE,.CORE,.CSI1,.CSI2,.CVTDT,.DELET,.DTCVT,.D2BIN
.MCALL	.EXIT,.INIT,.MONF,.OPEN,.O2BIN,.RADPK,.READ,.RLSE,.RSTRT
.MCALL	.STAT,.TMCVT,.TRAN,.TRAP,.WAIT,.WRITE,.GTCIL,.LOOK
;

	.MACRO	VRSION
	.ASCII	/V11A01/
	.ENDM

;

;
	.IFDF	DEBUG
	.GLOBL	REPORT
	.ENDC
;
;	DEFINE REGISTERS
;
	R0=%0
	R1=%1
	R2=%2
	R3=%3
	R4=%4
	R5=%5
	SP=%6
	PC=%7
;
;	DEFINE PARAMETERS
;
;	ASCII CHARACTERS
	CR=15
	LF=12
	VT=13
	TAB=11
	FF=14			;FORM FEED
	LANG=74			;<
	RANG=76			;>
	CRLF=005015
	L=114

;
;	SYMBOL TABLE PARAMETERS
;
	BPSYM=10.		;# OF BYTES PER SYMBOL
	BASE=8.			;DISTANCE TO BASE OF A SECTION
	FLAGS=4			;DISTANCE TO FLAGS OF AN ENTRY
	VALR=6			;DISTANCE TO RELOCATABLE VALUE OF AN ENTRY
	NAME2=2			;DISTANCE TO 2ND WORD ON AN ENTRY
	OBJMN=0			;OBJECT MODULE NAME
	SECTN=1			;SECTION NAME
	SYMN=4			;SYMBOL ENTRY
	ABSREL=40		;ABS/REL BIT (0/1)
	UNDEF=10		;UNDEFINED/DEFINED (0/1)
	INTGLB=100		;INTERNAL/GLOBAL (0/1)
	MONCND=1		;MONITOR ROUTINE CANDIDATE
	LOCAL=5			;LOCAL SECTION NAME
	IDENT=6			;IDENT DIRECTIVE.
î
;
;	TXT MODIFICATION COMMANDS
;
	TCMD1=1			;INTERNAL RELOCATION
	TCMD2=2			;GLOBAL RELOCATION
	TCMD3=3			;INTERNAL DISPLACED
	TCMD4=4			;GLOBAL DISPLACED
	TCMD5=5			;GLOBAL ADDITIVE
	TCMD6=6			;GLOBAL ADDITIVE DISPLACED
	TCMD7=9.		;GENERATE LIMITS

;
;	PC MODIFICATION COMMANDS
;
	PCMD1=7			;SET PC
	PCMD2=8.			;MODIFY PC
;	MISCELLANEOUS

	SPLEN=100.		;STACK LENGTH

	ALODSZ=320		;ABSOLUTE LOADER SIZE
	HGHMEM=16384.		;HIGH MEMADR +1

;
;	MONITOR IO COMMANDS
;
	INIT=6
	OPEN=16
	OPENI=4
	OPENO=2
	RSTRT=41
	WAIT=1
	READ=4
	WRITE=2
	CLOSE=17
	RELEAS=7
	TRAPV=41
	CSI1=56
	CSI2=57
	FMS=41
	CONV=42
	DELET=21
	TRAN=10
	STAT=13
	GET=65
	GUT=41
	ACTION=40003			;EXECUTE LOAD MOD
î	.IFDF	BLKIO
	.GLOBL	READIT,READST,CLOSRD,INITRD
	.GLOBL	RLSRD,OPENRD,READIU,XXREAD,INA,INB,OBJDEV
	.GLOBL	TRNBLK,OBJADR
	.ENDC

;
;	MONITOR IO DATA MODES
;
	FASC=0
	FBIN=1
	UFBIN=3
;
;	MONITOR IO ERROR BITS
;
	EOF=100
;
;	BLOCK TYPE COMMANDS
;
	GSDBLK=1
	TXTBLK=3
	RLDBLK=4
	ISDBLK=5
	MODEND=6
	GSDEND=2
	STBBLK=9.
	STBEND=10.
;
;	JUMP TABLE MAX INDICES.
;
	SWSMAX=6
	TMAX=3		;SEE LINK57
	GSDMAX=6	;SEE GGSD05
	PMAX=6		;SEE SCMDT
	CMDMAX=14.	;SEE RCMDT
	ERMAX=3		;SEE ERTAB
;	COMD SIZE (BYTES)
	COMDSZ=36
	IND=6		;INDEX INTO FILE BLOCK
;	MISCELLANEOUS
	BUF=104.	;52 WORDS FOR CSI BUFFS.
	DETACH=40	;DETACH BIT FOR HEADERS
	MXDVSZ=1000.	;ASSUME 500 WORDS MAX SIZE FOR
			;  DRIVER AND BUFFER.
	OCTOBI=4	;OCTAL TO BINARY CODE
	DETOBI=2	;DECIMAL TO BINARY CODE
	RATOBI=0	;RADIX50 TO BINARY CODE
	DOTBLK=127400	;RADIX50 FOR ".  "
	BLANKS=0	;RADIX50 FOR "   "
	INC=256.
	ERR10=1444	;F044-ERROR IN FORTRAN COMMAND STRING
;THIS SOURCE OF THE LINKER CAN BE
;ASSEMBLED INTO TWO UNIQUE VERSIONS:
;1.  IF THE SYMBOL "NOSEG" IS DEFINED, THE
;    RESULTING OBJECT MODULE IS THE FULL
;    LINKER.
;    *************************************
;2.  IF THE SYMBOL "NOSEG" IS NOT DEFINED,
;    THE RESULTING PACKAGE IS A LINKER
;    THAT UTILIZES CORE OVERLAYS FROM THE SYSTEM
;    DEVICE TO CONSERVE ON SYMBOL TABLE SPACE.
î;
;	THIS VERSION OF THE LINKER
;	UTILIZES CORE OVERLAYS FROM THE SYSTEM
;	DEVICE TO CONSERVE ON SYMBOL TABLE SPACE.
;
;THE OVERLAY VERSION OF THE LINKER IS SELF CONTAINED
;IN THAT IT IS ITS OWN OVERLAY BUILDER.
;
;WHEN THE SYMBOL "OVRBLD" IS DEFINED, THE
;RESULTING OBJECT MODULE IS THE BUILDER.
;
;WHEN THE SYMBOL "OVRBLD" IS NOT DEFINED, THE
;RESULTING OBJECT MODULE IS THE RESIDENT LINKER.
;
;WHEN LINKED, THE BUILDER'S TOP SHOULD BE XXX460.
;EXECUTING THE BUILDER'S LOAD MODULE
;VIA THE MONITOR COMMAND RUN
;CAUSES THE CREATION OF THE
;CONTIGUOUS FILE OF OVERLAYS
;(LINK11.OVR) ON THE SYSTEM DEVICE WITH LOGIN UIC.
;
;WHEN LINKED, THE RESIDENT LINKER'S TOP SHOULD ALSO BE XXX460.
;AT RUN TIME, THE RESIDENT LINKER
;REQUIRES THE OVERLAYS TO BE ON THE SYSTEM DEVICE
;WITH FILE NAME LINK11.OVR AND LOGIN OR [1,1]UIC.
;
	.CSECT
	.IFDF	NOSEG
OVRBLD=1			;PORTIONS OF
L1=0				;BUILD SECTION
L2=0				;ARE NEEDED.
L3=0				;SET ALL SYMBOLS
L4=0
L5=0				;USED IN ADJUSTING
L6=0
L7=0				;ADDRESSES TO WORK
L8=0
L9=0				;IN OVERLAY
BEGO01=0			;ENVIRONMENT
BEGO02=0			;TO 0.
BEGO03=0
BEGO04=0
BEGO05=0
BEGO06=0
BEGO07=0
BEGO08=0
BEGO09=0
BEGOVR=0
	.ENDC
;
;*****OVERLAY PROCEDURES*****
;
;THE NUMBER OF BYTES ALLOCATED FOR THE
;OVERLAY AREA
OVRSIZ=2000	;1024 DECIMAL BYTES
;THE NUMBER OF WORDS ALLOCATED FOR THE
;OVERLAY AREA
OVRWRD=1000	;512 DECIMAL WORDS
;
;IF THE SYMBOL "OVRBLD" IS DEFINED (VIA A
;PARAMETER ASSIGNMENT) THE RESULTING OBJECT
;MODULE WILL CONSIST OF:
;		OVERLAY BUILDER
;		OVERLAY #1
;		OVERLAY #2
;		.
;		.
;		.
;		OVERLAY #N
;		OVERLAY AREA
;		RESIDENT LINK-11
;
;THE RUN TIME TRANSFER ADDRESS WILL BE
;"STARTB" IN THE OVERLAY BUILDER
;
;IF THE SYMBOL "OVRBLD" IS NOT DEFINED
;THE RESULTING OBJECT MODULE WILL
;CONSIST OF:
;		OVERLAY AREA
;		RESIDENT LINK-11
;
;THE RUN TIME TRANSFER ADDRESS WILL
;BE "LNK" IN RESIDENT LINK-11
;
;
;
;PARAMETER ASSIGNMENTS
WTCMD=1				;.WAIT
OPN=16				;.OPEN
DLT=21				;.DELETE
RLS=7				;.RELEASE
R6=%6				;REGISTER 6
R7=%7				;REGISTER 7
ERR9=1640			;NOT ENOUGH ROOM AT BUILD TIME
				;TO ALLOCATE CONTIGUOUS FILE
ERR8=2207			;EOD OR DEVICE ERROR ON OUTPUT
				;.TRAN OR DEVICE ERROR ON
				;INPUT .TRAN
;
;
;IF IN RSX PROCESS RTH ALWAYS
;
	.IFDF	RSX
	RTH=1
	.ENDC
	.IFDF	OVRBLD
	.IFNDF	NOSEG
	.TITLE	LINKOB
;
;THE FOLLOWING TABLE CONTAINS THE
;STARTING CORE ADDRESS OF EACH OVERLAY
;IN THE ORDER OF ASCENDING LOCATIONS.
;A 0 WORD TERMINATES THE ENTRIES.
;AS NEW OVERLAYS ARE CREATED THEIR
;POINTERS MUST BE ADDED TO THE END
;OF THE TABLE AND THE OVERLAY ITSELF
;PUT IN THE SAME POSITION
;RELATIVE TO THE OTHER OVERLAYS.
;
OVRTAB:	.WORD	BEGO01		;OVERLAY #1
	.WORD	BEGO02		;OVERLAY #2
	.WORD	BEGO03		;OVERLAY #3
	.WORD	BEGO04		;OVERLAY #4
	.WORD	BEGO05		;OVERLAY #5
	.WORD	BEGO06		;OVERLAY #6
	.WORD	BEGO07		;OVERLAY #7
	.WORD	BEGO08		;OVERLAY #8
	.WORD	BEGO09		;OVERLAY #9
	.WORD	0
;
;OVERLAY DEVICE OUTPUT TRAN BLOCK
;
OVRTBO:	.WORD	0		;DEVICE BLOCK NUMBER
OVROSA:	.WORD	0		;MEMORY START ADDRESS
	.WORD	OVRWRD		;WORD COUNT
OVRERR:	.WORD	2		;FUNCTION (WRITE)
	.WORD	0		;NUMBER OF WORDS NOT TRAN'D.
;RESTART ADDRESS OF OVERLAY BUILDER---
;RELEASE OVERLAY DEVICE IF STILL INIT'D.
AGAIN:	TST	OVRLB		;IS DATA SET INIT'D
	BEQ	STARTB		;NO
	.RLSE	#OVRLB		;YES-RELEASE IT
;
;STARTING ADDRESS OF OVERLAY BUILDER
STARTB:	MOV	#OVRTAB,R6	;INITIALIZE THE STACK
	START=STARTB		;SET UP TRANSFER ADRESS
	;SET UP RESTART ADDRESS
	.RSTRT	#AGAIN
;
;USE THE COMMAND STRING INTERPRETER (CSI)
;TO DETERMINE THE SYSTEM DEVICE AND
;UNIT OF THIS SYSTEM.
;
	MOV	#ONCE,R0	;ADDRESS OF ONCE ONLY FLAG.
	TSTB	(R0)+		;BRANCH IF ALREADY
	BEQ	OVER		;DONE ONCE.
;THE FLAG AT ONCE IS CLEARED BY CSI
;DUE TO ITS PROXIMITY TO OVRFB.
;R0 NOW POINTS TO OVRBLK.
	.CSI1	@R0		;ADDRESS OF CMDBUF
;THE LINE IS SYNTACTICALLY ACCEPTABLE, THUS
;THE RETURN FLAG ON TOP OF STACK IS IGNORED.
	MOV	R0,@R6		;ADDRESS OF OVRBLK
	EMT	57		;CSI2
	TST	(R6)+		;CORRECT STACK
OVER:
	MOV	#OVRLB,R1	;LINK BLOCK
	CLR	@R1		;FOR ^C BEGIN
	MOV	#OVRFB,R2	;FILE BLOCK
	MOV	#OVRTBO,R3	;OUTPUT TRAN BLOCK
;.INIT OVERLAY DEVICE
	.INIT	R1
;OBTAIN DEVICE STATUS
	.STAT	R1
	CMP	(R6)+,(R6)+	;CORRECT STACK.
				;PHYSICAL BLOCK SIZE
	MOV	@R6,R4		;(IN WORDS) OF OVERLAY DEVICE
	MOV	#OVRWRD,-(R6)
	JSR	R7,DIVIDE
	MOV	(R6)+,R5	;NUMBER OF PHYSICAL
				;BLOCKS PER OVERLAY
	CLR	-(R6)
	MOV	#OVRTAB,R0
BLDR01:	TST	(R0)+		;TOP OF STACK
	BEQ	BLDR02		;CONTAINS TOTAL
	ADD	R5,@R6		;NUMBER OF PHYSICAL
	BR	BLDR01		;BLOCKS REQUIRED.
BLDR02:	MOV	#64.,-(R6)	;DIVIDE PHYSICAL BLOCK
	MOV	R4,-(R6)	;SIZE BY 64 (DECIMAL)
	JSR	R7,DIVIDE	;QUOTIENT ON STACK.
	MOV	(R6)+,R0	;NUMBER OF 64'S IN
				;PHYSICAL BLOCK
	MOV	@R6,R4		;TOTAL NUMBER OF
				;PHYSICAL BLOCKS REQUIRED

BLDR03:	DEC	R0
	BEQ	BLDR08		;TOTAL NUMBER OF
	ADD	R4,@R6		;64 (DECIMAL) WORD BLOCKS
	BR	BLDR03		;REQUIRED ON TOP OF
				;STACK
;DELETE FILE IF ALREADY EXISTING
BLDR08:	MOV	#BLDR04,-4(R2)	;ERROR RETURN
	.DELET	R1,R2
BLDR04:	CLR	-4(R2)		;ERRORS TO MONITOR
;ALLOCATE THE NECESSARY SPACE FOR ONE
;CONTIGUOUS FILE.
	MOV	R2,-(R6)	;FILE BLOCK
	MOV	R1,-(R6)	;LINK BLOCK
	EMT	15
	TST	(R6)+
	BLT	BLDR09		;SPACE AVAILABLE?
	CLR	-(R6)		;NO.
	MOV	#ERR9,-(R6)	;FATAL ERROR.
	BR	BLDR10
;
;DETERMINE THE PHYSICAL STARTING BLOCK
;OF THE CONTIGUOUS FILE AND PLACE IT
;IN THE 1ST WORD OF THE OUTPUT TRAN BLOCK.
BLDR09:	.LOOK	R1,R2,1
	MOV	(R6)+,@R3	;STARTING BLOCK.
	CMP	(R6)+,(R6)+	;CORRECT STACK
;THE ONE CONTIGUOUS FILE WILL CONTAIN
;N OVERLAYS WITH EACH BEGINNING AT THE
;START OF A PHYSICAL BLOCK ON THE DEVICE
;
	MOV	#OVRTAB,R0
BLDR07:	MOV	(R0)+,OVROSA	;MEMORY START ADDRESS
	BEQ	BLDR05
;TRAN OUT AN OVERLAY.
;
	.TRAN	R1,R3
;WAIT FOR COMPLETION OF TRANSFER
;
	.WAIT	R1
;CHECK FOR ERROR ON TRANSFER
;
	BIT	#140000,OVRERR
	BEQ	BLDR06
;ERROR ON TRANSFER
	MOV	OVRERR,-(R6)	;PUSH STATUS BYTE
	BIC	#377,@R6	;INTO LOW INFO BYTE
	SWAB	@R6		;AND CLEAR THE REST.
	MOV	#ERR8,-(R6)	;ERROR CODE

BLDR10:	IOT
	.EXIT			;RETURN TO MONITOR
BLDR06:	ADD	R5,@R3		;CHANGE BLOCK NUMBER
				;IN TRAN BLOCK FOR
	BR	BLDR07		;NEXT OVERLAY TRANSFER
;
;ALL OVERLAYS HAVE BEEN TRAN'D OUT.
;
BLDR05:	.RLSE	R1
;
;RETURN TO THE MONITOR
	.EXIT
;*****OVERLAYS BEGIN HERE*****
;
;	OVERLAY #1
L1=BEGOVR-BEGO01		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO01:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START1		;ENTRY1
	.ENDC
;
;	CREATE COMD
;
;	INIT THE OUTPUT DATA SET TO HSP.
;
;
;	INITIALIZE LOAD MODULE DATA SET
;
START1:	TST	LODDEV+6-L1	;ANY LOAD MOD OUTPUT?
	BEQ	LINK24		;NO--
;	INIT OUTPUT DATA SET, DELETE OUTPUT FILE
;	OPEN OUTPUT FILE
	MOV	#OPLOD-BEGO01+BEGOVR,LODADR-4-L1	;SET UP ERROR RETURN
	.INIT	#LODDEV		;INIT THE DATA SET
	TST	LODADR+4-L1
	BNE	.+10
	MOV	#0,LODADR+4-L1
	.=.-4
	.RAD50	/LDA/
	.=.+2
	.DELET	#LODDEV,#LODADR
;	IF THE FILE ALREADY EXISTED IT WAS
;	DELETED AND CONTROL WAS RETURNED
;	NORMALLY.
;	IF THE FILE DID NOT EXIST, THE ERROR
;	RETURN "OPLOD" WAS TAKEN.
;
;	OPEN LOAD MODULE FILE
;
OPLOD:	CLR	LODADR-4-L1	;NOW LET MON HANDLE ERRORS
	INCB	LODOPF-L1	;INDICATE LOAD MODULE OPENED
	TST	LODADR+4-L1
	BNE	.+10
	MOV	#0,LODADR+4-L1	;SET DEFAULT EXTENSION
	.=.-4
	.RAD50	/LDA/
	.=.+2
	.OPEN	#LODDEV,#LODADR
;	INIT OUTPUT
;
LINK24:	IOOI			;SETS R0,R1 TO PROPER BUFFER
;
;	SET UP THE BUFFER AND DUMP IT.  USE R0,R1 AS POINTERS.
;
	MOV	#COMDSZ,(R0)	;SET BC
;	SET COMD LOAD ADDRESS
	MOV	LOWADR-L1,-(SP)	;ASSUME LOWADR IS OK.
	CMP	PRSIZE-L1,#COMDSZ	;IS PROGRAM SMALLER THAN COMD?
	BHIS	LINK15		;NO - USE LOWADR
	CLR	(SP)		;ASSUME 0 AS LOAD ADDRESS.
	CMP	TOPMEM-L1,#COMDSZ	;IS TOP TOO LOW?
	BLO	LINK15		;YES - USE 0 AS LOAD ADDRESS
	MOV	TOPMEM-L1,(SP)	;YES - PUT COMD UP AGAINST TOP.
	SUB	#COMDSZ,(SP)	;CALCULATE CORRECT ADDRESS.
LINK15:	MOV	(SP)+,(R1)+	;SET LOAD ADDRESS FOR COMD.
	MOV	#6001,(R1)+	;SET COMMAND FOR 12. GENERAL WORDS.
	MOV	LOWADR-L1,(R1)+	;SET PROGRAM LOW ADDRESS
	.IFDF	RTH		;BRTH20
	TSTB	RTF-L1		;RTH WITH MODULE?
	BEQ	.+16		;NO-
	SUB	SS-L1,-2(R1)	;YES, LA=LA - STACK SIZE
	SUB	#2,-2(R1)
	.ENDC			;ERTH20
	MOV	PRSIZE-L1,(R1)+	;SET PROGRAM SIZE
	.IFDF	RTH		;BRTH21
	TSTB	RTF-L1		;RTH WITH MODULE?
	BEQ	LNK177		;NO-
	TSTB	NOIOF-L1
	BEQ	.+10
	ADD	RTHSIZ-L1,-2(R1)
	.ENDC			;ERTH21
LNK177:	MOV	TRA-L1,(R1)+	;SET TRA
	MOV	TRADDT-L1,(R1)+	;DDT ADDRESS
	CLR	(R1)+		;NOT LOAD-TIME RELOCATABLE
	MOV	SYMC-L1,R2
	MOV	(R2)+,(R1)+	;SET MODULE NAME
	MOV	(R2)+,(R1)+
	.IFDF	RTH		;BRTH22
	TSTB	RTF-L1
	BEQ	LNK179
	TSTB	NOIOF-L1
	BEQ	LNK178
	TSTB	CSIN-L1		;NAME FROM CSI
	BNE	LNK178		;YES-
	MOV	-4(R1),NAM1-L1	;NO-FILL NAME FROM COMD
	MOV	-2(R1),NAM2-L1
	BR	LNK179
LNK178:	MOV	NAM1-L1,-4(R1)	;NO-FILL NAME FROM COMD
	MOV	NAM2-L1,-2(R1)
LNK179:	CLRB	NOIOF-L1
	.ENDC			;ERTH22
;
;	SET .IDENT
;
	ADD	#BPSYM,R2	;R2 POINTS TO FLAG WORD OF NEXT
				;ENTRY IN SYMBOL TABLE
	CMP	(R2),#3000	;IS .IDENT SPECIFIED?
	BNE	1$		;NO-
	CMP	-(R2),-(R2)	;YES-SET R2 TO .IDENT IN SYMTAB
	MOV	(R2)+,(R1)+	;SET .IDENT
	MOV	(R2)+,(R1)+
	BR	2$
;
;	SET TIME OF DAY WHEN MODULE LINKED
;
1$:	CLR	(R1)+		;CLEAR AREA OF .IDENT IN COMD
	CLR	(R1)+
2$:	MOV	#104,-(SP)
	EMT	41
	MOV	(SP)+,(R1)+	;SET TIME
	MOV	(SP)+,(R1)+
;
;	SET DATE WHEN MODULE LINKED IN JULIAN
;
	MOV	#103,-(SP)
	EMT	41
	MOV	(SP)+,(R1)+	;SET DATE
	MOV	R1,R2
	MOV	#2,(R1)+
	MOV	SSYME-L1,R3
LNK119:	CMP	R3,USYME-L1
	BHIS	LNK120
	CMP	-4(R0),(R0)
	BLE	LNK126
	BIT	#MONCND,FLAGS(R3)
	BEQ	LNK125
	MOV	BASE(R3),(R1)+
	ADD	#INC,(R2)
	ADD	#2,(R0)
	MOV	R3,R4
	SQUISH
	SUB	#BPSYM,USYME-L1
	BR	LNK119
LNK125:	ADD	#BPSYM,R3
	BR	LNK119
LNK126:	IOOP
	TSTB	IOOPER-L1
	BEQ	.+6
LNK160:	JMP	LINK25-L1
	ADD	-4(R0),LOWADR-L1
	MOV	LOWADR-L1,(R1)+
	MOV	R1,R2
	MOV	#2,(R1)+
	MOV	#4,(R0)
	BR	LNK119
LNK120:	MOV	(R0),-(SP)
	ADD	#2,(SP)
	CMP	-4(R0),(SP)+
	BGE	LNK127
	IOOP
	TSTB	IOOPER-L1
	BNE	LNK160
	ADD	-4(R0),LOWADR-L1
	MOV	LOWADR-L1,(R1)+
	ADD	#2,(R0)
LNK127:	ADD	#2,(R0)
	CLR	(R1)+		;END OF COMD
	IOOP			;PUT OUT THE COMD
	TSTB	IOOPER-L1		;CHECK FOR ERROR
	BNE	LNK160		;YES.
	MOV	R0,PUTR0-L1	;SAVE R0
	MOV	R1,PUTR1-L1	;AND R1 FOR NEXT PUT.
	TSTB	FORTRF-L1		;CS FROM FORTRAN?
	BEQ	1$			;NO-
	MOV	BEGCS-L1,CMDBUF-L1	;YES-
	BR	2$
1$:	MOV	LIMIT-L1,CMDBUF-L1	;RESET CSI POINTER
2$:	CMP	SSYME-L1,USYME-L1
	BEQ	.+4
	ERR23
	JMP	LINK73-L1
	.IFNDF	NOSEG
	.EOT
;TAPE 2
ENDO01:
SIZO01=ENDO01-BEGO01
;
;*****OVERLAY #2*****
L2=BEGOVR-BEGO02		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO02:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START2		;ENTRY1
	.ENDC
;
;	RESET-CLOSE & RELEASE ALL OPENED FILES & INITED DATA SETS
;
START2:	TST	INCMD-L2		;IS KB INITED?
	BEQ	RESE06		;NO-
	.RLSE	#INCMD		;RELEASE KB
	.RLSE	#OUTCMD		;RELEASE TELEPRINTER
RESE06:	TST	OBJDEV-L2		;IS OBJ DEV INITED?
	BEQ	RESE01		;NO-
	IOIC
RESE01:	MOV	#MAPDEV,R0
	TSTB	MAPOPF-L2		;IS MAP OPEN?
	BEQ	RESE02		;NO-
	.CLOSE	R0		;YES-CLOSE AND RELEASE
RESE02:	TST	@R0		;IS IT INITED?
	BEQ	RESE03		;NO-
	.RLSE	R0
RESE03:	MOV	#LODDEV,R0
	TSTB	LODOPF-L2		;IS LOD DEV OPEN?
	BEQ	RESE04		;NO-
	.CLOSE	R0		;YES-CLOSE AND RELEASE IT
	.DELET	R0,#LODADR	;DELETE LOAD MODULE FILE
RESE04:	TST	@R0		;IS IT INITED?
	BEQ	RESE05		;NO-
	.RLSE	R0		;YES-
RESE05:	TSTB	STBOPF-L2	;IS STB DEV OPEN?
	BEQ	RESE08		;NO-
	.CLOSE	#STBDEV		;YES-CLOSE AND RELEASE
RESE08:	TST	STBDEV-L2
	BEQ	RESE07
	.RLSE	#STBDEV
RESE07:	MOV	#STCLR,R0	;GET START OF AREA TO BE CLEARED
1$:	CLR	(R0)+		;CLEAR IT ALL
	CMP	R0,#ENDCLR	;ONE WORD AT
	BLO	1$		;A TIME
	MOV	EXT-L2,STBDEV+2-L2
	MOV	DEV-L2,STBDEV+6-L2
	MOV	FIL-L2,STBADR-L2
	MOV	NAM-L2,STBADR+2-L2
;
;	INITIALIZE KEYBOARD DATA SET
;
	.INIT	#INCMD
;
;	INITIALIZE TELETYPE DATA SET
;
	.INIT	#OUTCMD
;
	.RSTRT	#LINK		;RESTART
;
;	PRINT NAME
;
	MOV	#LNKNM,R0
	TYPE
;
;	START PASS 1
;
LINK66:
	JMP	LINK80-L2
	.IFNDF	NOSEG

ENDO02:
SIZO02=ENDO02-BEGO02
;
;*****OVERLAY #3*****
L3=BEGOVR-BEGO03		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO03:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	STRT31		;ENTRY1
	JMP	STRT32		;ENTRY2
	.ENDC
;
; PROCESS OUTPUT SPECIFICATIONS AND SET MONITOR TOP.
;
STRT31:	.MONF
	MOV	(SP)+,MONTOP-L3	;INITIALIZE AT CURRENT SIZE
	MOV	CMDBUF-L3,BLKO-L3
	MOV	#2,@CMDBUF-L3	;PREPARE FOR OUTPUT FIELD
	.CSI2	#BLKO		;GET FIRST OUTPUT FIELD
	.IF NDF	RSX
	MOV	#LODADR,R0	;ADDRESS OF FILE NAME BLOCK
	MOV	#NAME,R1	;ADDRESS OF ASCII STRING STORAGE
	UNPACK			;CONVERT IT TO ASCII
	MOV	#LODADR,R0	;ADDRESS OF FILE NAME
	TST	(R0)+		;IGNORE
	BEQ	1$		;BLANK NAME
	TST	(R0)+
	TST	@R0		;IS THE EXTENSION NULL??
	BNE	1$		;NO
	MOV	#.-.,@R0	;MOVE IN THE PROPER EXTENSION
.=.-2
	.RAD50	/LDA/		;EXTENSION IS LDA
1$:	INC	R1		;SKIP OVER "."
	UNPACK			;UNPACK THE EXTENSION
	MOVB	#' ,R0
	MOVB	R0,-(R1)	;CLEAR
	MOVB	R0,-(R1)	;POTENTIAL
	MOVB	R0,-(R1)	;TRASH
	.ENDC
	TST	LODDEV+6-L3
	BNE	2$
	INCB	NOOUTP-L3
2$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	3$		;NO-
	INCB	BIT2F-L3	;YES-
3$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	4$		;NO-
	ERR19			;YES-
4$:	ASR	(SP)+
	BCS	LINK86		;ODD=>NO MAP FOLLOWS
	MOV	CMDBUF-L3,BLKM-L3	; GET MAP FILE
	.CSI2	#BLKM
	TSTB	MAPDEV+6-L3
	BEQ	5$
	INCB	MAPF-L3		;SET MAP FLAG
5$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	6$		;NO-
	INCB	BIT2F-L3	;YES-
6$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	7$		;NO-
	ERR19			;YES-
7$:	ASR	(SP)+
	BCS	LINK86
	MOV	CMDBUF-L3,BLKS-L3
	.CSI2	#BLKS
	TST	STBDEV+6-L3	;SYMBOL TABLE TO BE OUTPUT?
	BEQ	8$		;NO-
	INCB	SYMTAB-L3	;YES-
8$:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	9$		;NO-
	INCB	BIT2F-L3	;YES-
9$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	10$		;NO-
	ERR19			;YES-
10$:	ASR	(SP)+
	BCS	LNK157
	ERR20
LINK86:	TSTB	NOOUTP-L3
	BEQ	.+12
	CLRB	NOOUTP-L3
	INCB	NOONOM-L3
LNK157:	TSTB	NOONOM-L3
	BEQ	.+12
	CLRB	NOONOM-L3
	INCB	NOMMS-L3
	CLR	@CMDBUF-L3
	MOV	CMDBUF-L3,BLKI-L3
	.CSI2	#BLKI
	TST	OBJDEV+6-L3
	BNE	LNK136
	ASR	(SP)+
	BCS	LNK135
	ERR17
LNK135:	TSTB	NOMMS-L3
	BEQ	.+6
	JMP	LNK145-L3
	ERR02
LNK136:	BIT	#4,(SP)		;BIT2 SET?
	BEQ	1$		;NO-
	INCB	BIT2F-L3	;YES-
1$:	BIT	#2,(SP)		;BIT1 SET?
	BEQ	2$		;NO-
	ERR19			;YES-
2$:	TST	LODDEV+6-L3
	BEQ	LINK35
	MOV	#LODADR,R0
	TST	(R0)
	BNE	LINK35
	MOV	#OBJADR,R1
	MOV	(R1)+,(R0)+
	MOV	(R1),(R0)
LINK35:	JMP	LNK128-L3
;
; OBTAIN ADR OF HIGHEST WORD IN CORE
;
STRT32:	.CORE
	MOV	#ALODSZ,-(SP)
	SUB	(SP)+,(SP)
	ADD	#2,(SP)
	MOV	(SP)+,TOPMEM-L3
	JMP	LINK84-L3
	.IFNDF	NOSEG
ENDO03:
SIZO03=ENDO03-BEGO03
;
;*****OVERLAY #4*****
L4=BEGOVR-BEGO04		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO04:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	LINK13		;ENTRY1
	.ENDC
LINK13:
	.IFDF	RSX
	INCB	FLAG-L4
	MOVTAB
	CLRB	FLAG-L4
	.ENDC
	MOV	SYME-L4,R0	;GET BEGINNING OF UNDEFINES
	MOV	R0,SSYME-L4	;SAVE FOR PMAP
LINK27:	CMP	R0,USYME-L4	;ANY UNDEFINES LEFT?
	BHIS	LNK112		;NO-GO SEE ABOUT MAP.
	.IFNDF	RSX
	CMP	#DOTBLK,NAME2(R0) ;IS 2ND WORD ".  "?
	BEQ	LNK111		;YES-GO CHANGE ".  " INTO "   "
	BIT	#MONCND,FLAGS(R0) ;MONCND FLAG SET?
	BEQ	LNK130		;NO-
	TST	BASE(R0)	;YES-EMT FILLED IN?
	BNE	LNK116		;YES-
	BIC	#MONCND,FLAGS(R0) ;NO-
	MOV	#DOTBLK,NAME2(R0)
	BR	LNK130
	.ENDC
LNK130:	BIC	#ABSREL,FLAGS(R0)	;NO-MAKE ABSOLUTE
	BIS	#UNDEF+INTGLB,FLAGS(R0)	;MAKE DEFINED & GLOBAL
	MOVB	#SYMN,FLAGS+1(R0)	;MAKE IT A SYMBOL DEFINITION
	CLR	VALR(R0)
	CLR	BASE(R0)
LNK116:	ADD	#BPSYM,R0		;UPDATE R0 TO NEXT SYMBOL
	BR	LINK27
	.IFNDF	RSX
LNK111:	MOV	#BLANKS,NAME2(R0) ;CHANGE ".  " INTO "   "
	BIS	#MONCND,FLAGS(R0) ;FLAGS ENTRY: MON ROUTINE CAND
	CLR	BASE(R0)	;CLEAR SPACE OF EMT
	BR	LNK116
	.ENDC
LNK112:
	.IFNDF	RSX
	TSTB	SECTIM-L4
	BNE	LNK131
	INCB	MONLIB-L4	;IN MON LIB SEARCH
	JMP	LINK80-L4	;CHECK FOR ROOM FOR COM ST
LNK131:	CLRB	SECTIM-L4
	.ENDC
;	INITIALIZE FOR PASS 2
	CMP	SYMC-L4,SYME-L4	;ANY SYMBOLS?
	BNE	.+6		;YES
	JMP	LINK-L4		;NO, RESTART!
	MOVB	#1,TMP1-L4		;SET ADDRESS REPEAT FLAG
	MOV	TOPMEM-L4,CURPC-L4	;GET TOP OF MEMORY INTO CURRENT
;	ASSIGN ADDRESSES, CALCULATE TOTAL SIZE, KEEP LOWEST ADDRESS LOADED.
LINK63:	CLR	PRSIZE-L4	;0 TO PROGRAM SIZE
	.IFDF	RTH		;BRTH2
	TSTB	RTF-L4		;RTH?
	BEQ	LNK182		;NO-
	MOV	SS-L4,PRSIZE-L4	;YES-
	ADD	#2,PRSIZE-L4
	TSTB	TMP1-L4
	BEQ	LNK184
	SUB	SS-L4,CURPC-L4
	SUB	#2,CURPC-L4
	BR	LNK182
LNK184:	ADD	SS-L4,CURPC-L4
	ADD	#2,CURPC-L4
	.ENDC			;ERTH2
LNK182:	MOV	SYMC-L4,R0	;SET PTR TO FIRST MODULE NAME.
	MOV	R0,PTRG-L4
	BR	LINK17
LINK16:	ADD	#BPSYM,R0	;MOVE TO NEXT ENTRY
LINK17:	CMP	R0,SYME-L4	;DONE?
	BHIS	LINK18		;YES-GET OUT

	MOVB	FLAGS+1(R0),R1	;GET FLAG TO HIGH BYTE (ENTRY TYPE)
	MOVB	FLAGS(R0),R2	;GET FLAG LOW BYTE
	CMPB	#OBJMN,R1	;OBJ-MODULE NAME?
	BEQ	LINK16		;YES-IGNORE
LNK170:	CMPB	#SYMN,R1	;SYMBOL ENTRY?
	BEQ	LINK19		;YES-GO
	CMPB	#SECTN,R1	;SECTION NAME?
	BEQ	LINK20		;YES-GO
	CMPB	#LOCAL,R1	;LOCAL SECTION NAME?
	BEQ	LINK20		;YES-GO
	BR	LINK16		;IGNORE ALL OTHER THINGS.
;
;	ENTRY POINT
LINK19:	BITB	#ABSREL,R2	;ABS OR REL?
	BEQ	LINK33		;ABS
	MOV	PTSECT-L4,R3
	MOV	BASE(R3),BASE(R0)	;GET SECTION BASE
	ADD	VALR(R0),BASE(R0)	;RELOCATE
	BR	LINK16		;DO NEXT ENTRY
LINK33:	MOV	VALR(R0),BASE(R0) ;SET ABS VALUE
	BR	LINK16
;
;	SECTION NAME
;
LINK20:	BITB	#ABSREL,R2	;ABS OR REL?
	BNE	LINK21		;GO IF REL
	CLR	BASE(R0)	;SET BASE AND
	CLR	VALR(R0)	;SIZE TO 0
	BR	LINK22
LINK21:	MOV	VALR(R0),R3	;GET SECTION SIZE
	MOV	R3,-(SP)	;MAKE SIZE EVEN
	ASR	R3
	MOV	(SP)+,R3
	ADC	R3
	ADD	R3,PRSIZE-L4	;SUM UP FOR TOTAL SIZE
	.IFDF	RTH		;BRTH3
	CMP	RTHPTR-L4,R0	;PROCESSING RTH?
	BHI	.+6		;NO-
	MOV	R3,RTHSIZ-L4	;YES-EXTRACT RTH SIZE FROM SYMTAB
	.ENDC			;ERTH3
	TSTB	TMP1-L4		;IS THIS FIRST TIME?
	BNE	LINK78		;FIRST
	MOV	CURPC-L4,BASE(R0)	;SECOND--SET BASE
	ADD	R3,CURPC-L4	;ADJUST PC
	BR	LINK22
LINK78:	SUB	R3,CURPC-L4	;ADJUST PC BY SIZE.
	MOV	CURPC-L4,BASE(R0)	;SET BASE OF SECTION TO NEW PC.
LINK22:	MOV	R0,PTSECT-L4	;SAVE PTR TO THIS SECTION.
	BR	LINK16		;DO NEXT ONE.
;
LINK18:
;

;	IF BOTTOM SET, CALCULATE NEW TOP AND 
;	ASSIGN ADDRESSES AGAIN.
	TSTB	TMP1-L4
	BEQ	LNK183
	.IFDF	RTH		;BRTH4
	TSTB	NOIOF-L4	;RTH ?
	BEQ	LNK183		;NO-
	ADD	RTHSIZ-L4,PRSIZE-L4	;YES-
	SUB	RTHSIZ-L4,CURPC-L4
	.ENDC			;ERTH4
LNK183:	TSTB	BOTF-L4
	BEQ	LINK77		;NO BOTTOM.
	CLRB	BOTF-L4
	SUB	CURPC-L4,TOPMEM-L4	;CALCULATE NEW TOP AS
	ADD	BOTMEM-L4,TOPMEM-L4	;  TOP-(CURRENT-BOTTOM)
LINK77:	TSTB	TMP1-L4		;DONE TWICE?
	BEQ	LINK64		;YES
	CLRB	TMP1-L4
	MOV	TOPMEM-L4,-(SP)	;CALCULATE LOWADR
	SUB	PRSIZE-L4,(SP)
	MOV	(SP),CURPC-L4
	.IFDF	RTH		;BRTH5
	TSTB	RTF-L4		;RTH?
	BEQ	LNK185		;NO-
	ADD	SS-L4,(SP)	;YES-
	ADD	#2,(SP)
	.ENDC			;ERTH5
LNK185:	MOV	(SP)+,LOWADR-L4
	JMP	LINK63
;	FINALIZE THE TRANSFER ADDRESS
;
LINK64:	CMP	TOPMEM-L4,PRSIZE-L4
	BHIS	.+6
	INCB	BELOW0-L4
	TSTB	TRAF-L4		;IS THERE ONE?
	BNE	LINK60		;YES
	MOV	#1,TRA-L4	;ASSUME 1
	BR	LINK61
LINK60:	TSTB	FTRA-L4		;WAS ONE FORCED?
	BNE	LINK61		;YES-
	TSTB	STRA-L4		;MUST WE SEARCH?
	BEQ	LINK30		;NO-
	MOV	#1,R0		;YES- SEARCH
	MOV	#TRABLK+4,R4
	SRGLOB
	MOV	R0,R4
	MOV	R4,TRA-L4
	BR	LINK61
LINK30:	MOV	#TRABLK,R4
	SRMODN			;SEARCH FOR MODULE NAME
	BR	LINK32		;FOUND
	ERR12			;MODULE NAME MUST BE THERE.
LINK32:	MOV	R4,PTRG-L4	;SET PTRG TO CURRENT NAME.
	MOV	#TRABLK+4,R4
	GETSEC			;SEARCH FOR SECTION NAME.
	ERR13			;MUST BE THERE.
	ADD	BASE(R4),TRA-L4	;CALCULATE TRA
;  FINALIZE DDT TRA
LINK61:	TSTB	SDDTRA-L4	;HAVE WE SEEN ONE?
	BEQ	LINK31		;NO-
	MOV	#DDTTRA,R4	;YES-FIX IT UP
	SRMODN
	BR	.+4
	ERR12
	MOV	R4,PTRG-L4
	MOV	#DDTTRA+4,R4
	GETSEC
	ERR13
	ADD	BASE(R4),TRADDT-L4
LINK31:	MOV	SYMC-L4,PTRG-L4	;SET PTRG
	MOV	TRA-L4,R0	;PRINT MSG--TRA,LOW ADR-L4,ETC
	MOV	#TRAMA,R1
	OTOA
	MOV	LOWADR-L4,R0
	.IFDF	RTH		;BRTH6
	TSTB	RTF-L4		;PROCESSING RTH ?
	BEQ	LNK172		;NO-
	SUB	SS-L4,R0	;YES,LA=LA-SS
	SUB	#2,R0
	.ENDC			;ERTH6
LNK172:	MOV	#TRAMB,R1
	OTOA
	MOV	TOPMEM-L4,R0
	.IFDF	RTH		;BRTH7
	TSTB	NOIOF-L4	;CREATING RTH?
	BEQ	LNK173		;NO-
	MOV	CURPC-L4,R0
	MOV	R0,SLARTH-L4	;SAVE RTH LOAD ADDR
	ADD	RTHSIZ-L4,R0	;YES, HI=HI+RTHSIZE
	.ENDC			;ERTH7
LNK173:	MOV	#TRAMC,R1
	OTOA
	JMP	EXOVL4-L4
	.IFNDF	NOSEG

ENDO04:
SIZO04=ENDO04-BEGO04
;
;*****OVERLAY #5*****
L5=BEGOVR-BEGO05		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO05:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
	JMP	START5		;ENTRY1
	.ENDC
;
;
;	GET GSD (GGSD)
;
;	READ GSD OFF A TAPE AND BUILDS A SYMBOL TABLE.
;
;
START5:	SAVREG			;SAVE REGISTER
	TSTB	LIBF-L5		;TEST LIB FLAG
	BNE	GGSD22		;IN DIR SEARCH
	MOVTAB			;INPUT INIT.  SET R0, R1
	MOV	#INA,IN-L5
	.IFDF	BLKIO
	JSR	PC,@#READIT	;INITIATE READ ON INA
	.ENDC
	.IFNDF	BLKIO
	.READ	#OBJDEV,#INA
	.ENDC
GGSD26:	IOIG
GGSD23:	BITB	#EOF,-1(R0)	;ERROR?
	BNE	GGSDEX		;YES, GET OUT
	CMPB	#STBBLK,(R1)	;IS THIS STB?
	BNE	.+6		;NO-
	JMP	BEGSTB-L5	;YES-GO PROCESS IT.
	CMPB	#GSDBLK,(R1)	;IS THIS GSD?
	BEQ	.+4		;YES, OK
	ERR03			;ERROR IF NOT GSD.
	CMPB	#OBJMN,7(R1)	;IS 1-ST ENTRY OBJ MOD NAME?
	BEQ	.+4		;YES, OK
	ERR04			;ELSE, ERROR.
GGSD01:	BITB	#EOF,-1(R0)	;TEST STATUS FOR ERRORS
	BNE	GGSDEX		;ERROR - EXIT AND IGNORE
	INCB	NSTBF-L5	;CAN'T INPUT CORE LIBS ANY MORE
GGSD02:	MOV	(R1)+,R2	;GET BLOCK TYPE
	SUB	#2,(R0)		;DECREMENT BC
	CMPB	#GSDBLK,R2	;GSD
	BEQ	GGSD03		;YES
	.IFDF	RTH		;BRTH8
	TSTB	RTF-L5		;PROCESSING RTH?
	BEQ	GGSD29		;NO-
	CMPB	#TXTBLK,R2	;YES - TEXT?
	BNE	GGSD04		;NO - GET ANOTHER BLOCK
	TSTB	CSISS-L5	;YES - SS FROM CSI?
	BNE	GGSDEX		;YES-
	MOV	22(R1),SS-L5	;NO - EXTRACT SS FROM O.M.
	MOV	SS-L5,-(SP)	;ODD STACK SIZE
	ASR	(SP)+
	BCC	EVEN		;EVEN
	INC	SS-L5		;ODD, MAKE EVEN
EVEN:	TSTB	CSIN-L5		;NAME FROM CSI?
	BNE	GGSDEX		;NO -
	MOV	40(R1),NAM2-L5	;YES - EXTRACT NAME FROM O.B.
	MOV	42(R1),NAM1-L5
	BR	GGSDEX		;GET OUT.
	.ENDC			;ERTH8
GGSD29:	TSTB	LIBF-L5
	BNE	GGSD30
	MOVB	TAPES-L5,-(SP)
	BISB	CONCAT-L5,(SP)+
	BNE	GGSD04		;IGNORE GSDEND IF EITHER
				;  TAPES OR CONCAT ON.
GGSD30:	CMPB	#GSDEND,R2	;GSD END
	BNE	GGSD04		;NO
GGSDEX:	RESREG			;YES - EXIT
	TSTB	LIBF-L5		;TEST LIB FLAG
	BNE	GGSDE1		;IN DIR SEARCH
	IOIC			;CLOSE OBJECT MODULE FILE
GGSDE1:	RTS	PC
GGSD22:	TSTB	SBBF-L5		;MATCH IN 2ND LINE?
	BNE	GGSD24		;YES - FIX UP "IN"
	IOIG			;NO - GET NEXT BLOCK
	BR	GGSD23
GGSD24:	CMP	#2,CNT-L5
	BNE	GGSD04
	MOV	IN-L5,R0
	CMP	(R0)+,(R0)+
	MOV	R0,R1
	TST	(R1)+
	DEC	CNT-L5
	BR	GGSD23
GGSD04:	CMP	#1,CNT-L5
	BNE	GGSD25
	MOV	INSAVE-L5,IN-L5
	CLR	CNT-L5
	CLRB	SBBF-L5
GGSD25:	IOIG
	BR	GGSD01
GGSD03:	SUB	#8.,(R0)	;ANY ENTRY LEFT?
	BLT	GGSD04		;NO - GO GET ANOTHER BLOCK
	MOV	R1,R4		;SET R4 TO THE ENTRY
	ADD	#8.,R1		;MOVE R1 TO NEXT ENTRY.
	MOVB	FLAGS+1(R4),R2	;GET ENTRY TYPE
	CMP	R2,#GSDMAX
	BLE	.+4
	ERR14
	ASL	R2
	JMP	@GGSD05-BEGO05+BEGOVR(R2)	;DISPATCH
GGSD05:	+GGSD06-BEGO05+BEGOVR	;MODULE NAME
	+GGSD07-BEGO05+BEGOVR	;SECTION NAME
	+GGSD03-BEGO05+BEGOVR	;ISD SIZE (IGNORE)
	+GGSD08-BEGO05+BEGOVR	;TRA SPECIFICATION
	+GGSD09-BEGO05+BEGOVR	;SYMBOL
	+GGSD07-BEGO05+BEGOVR	;LOCAL SECTION NAME
	+GGSD32-BEGO05+BEGOVR	;IDENT DIRECTIVE
;
;	MODULE NAME
;
GGSD06:	CLRB	SAMECS-L5
	MOV	R4,R2		;SAVE R4
	SRMODN			;CHECK IF MODULE NAME IS UNIQUE
	BR	GGSD10		;ERROR IF NOT UNIQUE
GGSD31:	MOV	R2,R4
	MOV	SYME-L5,PTRG-L5	;SET PTR TO MODULE NAME
	INSYME			;INSERT AT SYME + UPDATE PTRS
	BR	GGSD03		;DO NEXT ENTRY
GGSD10:	CMP	(R2),MAIN1-L5	;MODULE NAME NOT UNIQUE
	BNE	ASBEF1		;MODULE NAME MAIN.?
	CMP	2(R2),MAIN2-L5
	BNE	ASBEF1		;NO-
	CMP	SYMB-L5,SYMC-L5	;YES - PROCESSING CORE LIBS?
	BEQ	ASBEF1		;NO-
	TSTB	MAINF-L5	;YES - WAS ONE MAIN. SEEN ALREADY?
	BNE	PREPAR		;YES - PRINT ERROR AND ABORT OBJ MOD.
	INCB	MAINF-L5	;NO - MARK FIRST MAIN. WAS SEEN.
	BR	GGSD31		;AND DON'T PRINT ERROR AND CONTINUE
				;PROCESSING OBJECT MODULE.
PREPAR:	CLRB	MAINF-L5
	BR	ASBEF3
ASBEF1:	CMP	(R2),DATA1-L5	;MODULE NAME DATA.?
	BNE	ASBEF3
	CMP	2(R2),DATA2-L5
	BNE	ASBEF3
	CMP	SYMB-L5,SYMC-L5	;PROCESSING CORE LIBS?
	BEQ	ASBEF3
	TSTB	DATAF-L5	;WAS 1 DATA. SEEN ALREADY?
	BNE	1$
	INCB	DATAF-L5
	MOV	R4,-(SP)
	MOV	R2,R4
	SRMODN
	BR	.+4
	ERR25
	MOV	#126423,(R4)
	MOV	(SP)+,R4
	BR	GGSD31
1$:	CLRB	DATAF-L5
ASBEF3:	ERR05			;ERROR-MODULE NAME NOT UNIQUE
	TSTB	CONCAT-L5
	BEQ	GGSD27
GGSD28:	IOIG
	BITB	#EOF,-1(R0)
	BNE	GGSDEX
	CMPB	#MODEND,(R1)
	BEQ	.+4
	BR	GGSD28
	JMP	GGSD26
GGSD27:	JMP	GGSDEX
;
;	SECTION NAME
;
GGSD07:	MOV	R4,R2		;GIND THE GLOBAL + GET
	PTGLOB			;PTR (R4) TO IT.
	BR	GGSD11		;NOT FOUND, GO INSERT IT.
	BITB	#UNDEF,FLAGS(R4) ;IS IT DEFINED
	BNE	GGSD12		;YES
	SQUISH			;NO - REMOVE THE UNDEFINED SYMBOL
	SUB	#BPSYM,USYME-L5
GGSD11:	MOV	R2,R4		;INSERT AT SYME-L5 AND UPDATE PTRS.
	MOV	SYME-L5,PTRH-L5
	INSYME
	BR	GGSD14
GGSD12:	CMPB	FLAGS+1(R4),#SECTN ;IS IT A SECTION NAME?
	BEQ	GGSD33
	CMPB	FLAGS+1(R4),#LOCAL	;LOCAL SECTION NAME?
	BNE	GGSD13		;NO - ERROR - MULT DEFINITION.
GGSD33:	TSTB	SCOUNT-L5	;READ AT LEAST 1 SYMTAB?
	BEQ	LNK163		;NO-
	TSTB	NSTBF-L5	;YES-FINISHED READING SYMTABS?
	BEQ	LNK163		;NO-
	INCB	SAMECS-L5	;YES-SET FLAG TO AID IN
				;CHECKING FOR EXTRA ENTRIES
LNK163:	CMPB	FLAGS+1(R4),#LOCAL
	BEQ	GGSD11
	MOV	R4,PTRH-L5
	CMP	VALR(R4),VALR(R2) ;WHICH SIZE IS BIGGEST
	BHIS	GGSD14
	TSTB	SAMECS-L5
	BEQ	.+8.
	CMP	R4,SYMC-L5
	BLO	.+10.
	MOV	VALR(R2),VALR(R4) ;GET BIGGEST SIZE.
	BR	GGSD14
	ERR26			;W323,CSECT SIZE TOO LARGE
LNK193:	BR	GGSD14		;GO DO NEXT ENTRY

;
;	TRA SPECIFICATION
;
GGSD08:	TSTB	DDTF-L5		;IS THIS THE DEBUG FILE?
	BEQ	GGSD20		;NO-
	INCB	SDDTRA-L5
	MOV	#DDTTRA,R2
	BR	GGSD21
GGSD20:	TSTB	UTRA-L5		;SHOULD WE USE THIS ONE?
	BEQ	GGSD18
	CLRB	UTRA-L5
	INCB	TRAF-L5
	BR	GGSD19
GGSD18:	TSTB	TRAF-L5		;IS THERE ONE ALREADY?
	BNE	GGSD14		;YES, GET OUT
GGSD19:	MOV	#TRABLK,R2
;	GET CURRENT OBJ MODULE NAME
GGSD21:	MOV	PTRG-L5,R3
	MOV	(R3)+,(R2)+
	MOV	(R3),(R2)+
;	GET TRA SPEC
	MOV	(R4)+,(R2)+	;SECTION NAME
	MOV	(R4)+,(R2)+
	TST	(R4)+		;SKIP FLAGS
	MOV	(R4)+,(R2)+	;CONSTANT
	MOVB	DDTF-L5,-(SP)	;IS THIS THE DDT TRA?
	CLRB	DDTF-L5
	TSTB	(SP)+
	BNE	GGSD14		;YES-DO NOT TEST FOR ODD VALUE
	BIT	#1,-(R2)	;IS IT ODD
	BNE	GGSD14		;YES - IGNORE
	INCB	TRAF-L5		;NO - SET FLAG
GGSD14:	JMP	GGSD03

;
;	SYMBOL DEFINITION
;

GGSD09:	MOV	R4,R2		;SAVE R4
	BITB	#UNDEF,FLAGS(R2) ;REF OR DEF?
	BEQ	GGSD15		;REF
	PTGLOB			;SEARCH FOR IT AND SET R4
	BR	GGSD16		;NOT FOUND
	BITB	#UNDEF,FLAGS(R4) ;FOUND, IS IT DEFINED
	BNE	GGSD13		;YES - ERROR
	SQUISH
	SUB	#BPSYM,USYME-L5
GGSD16:	TSTB	SAMECS-L5
	BEQ	.+8.
	CMP	PTRH-L5,SYMC-L5
	BLO	.+8.
	MOV	R2,R4
	INPTRH
	BR	GGSD14
	ERR06			;W342,TOO MANY ENTRIES IN CSECT
	BR	GGSD14
;
;	MULTIPLY DEFINED SYMBOL--BROADCAST IT
;
GGSD13:	MOV	R0,CONVER-L5	;SAVE R0,R1
	MOV	PTRG-L5,R0	;MOVE ADR OF MOD NAME TO R0
	CMP	(R0),MAIN1-L5	;IS IT MAIN.?
	BNE	ASBEF2		;NO-
	CMP	2(R0),MAIN2-L5
	BNE	ASBEF2		;NO-
	CMP	SYMB-L5,SYMC-L5	;YES - PROCESSING CORE LIBS?
	BEQ	ASBEF2		;NO-
	CMP	(R4),MAIN1-L5	;YES - IS GLOBAL MAIN.?
	BNE	ASBEF2		;NO-
	CMP	2(R4),MAIN2-L5
	BNE	ASBEF2		;NO-
	CMP	MAINF-L5,#1	;1ST MAIN. GLOBL?
	BNE	ASBEF2		;NO-
	INCB	MAINF-L5	;YES-MARK IT: MAINF=2
	MOV	#126423,(R4)	;GLOB NAME IN COR LIB STB =$$$N.
	MOV	R0,R4
	SRMODN
	BR	.+4
	ERR25
	MOV	#126423,(R4)	;MOD NAME IN COR LIB STB =$$$N.
	MOV	CONVER-L5,R0
	BR	GGSD16		;INSERT MAIN. GLOBAL INTO SYM TAB
	BR	NOMES		;YES - DON'T PRINT MESSAGE.

ASBEF2:	MOV	R1,-(SP)
	MOV	#MULMSA,R1	;ADR OF ASCII CHAR
	MOV	R4,R0		;ADR OF MOD40#
	UNPACK
	MOV	#MULMSB,R1	;MODULE NAME
	MOV	PTRG-L5,R0

	UNPACK
	MOV	(SP)+,R1	;RESTORE R1.
	MOV	#MULMSG,R0

	TYPE
	MOV	#1302,R0	;CODE=W302

	CLR	-(SP)
	MOV	R0,-(SP)
	IOT
NOMES:	MOV	CONVER-L5,R0
	BR	GGSD14
;
;	REFERENCE TO A GLOBAL
;
GGSD15:	PTGLOB
	BR	GGSD17		;NOT THERE - INSERT IT.
	BR	GGSD14		;IF THERE, IGNORE
GGSD17:	MOV	R2,R4
	INUSYM			;INSERT AS UNDEFINED SYMBOL
	BR	GGSD14
;
;	IDENT DIRECTIVE
;
;	PLACE BLOCK OF .IDENT AFTER THE BLOCK OF THE CORRESPONDING
;	.TITLE IN THE SYMBOL TABLE
;
GGSD32:	SAVREG
	MOV	R4,-(SP)	;SAVE R4 THE POINTER TO ENNTRY
				;IN READ BUFFER
	CMP	PTRG-L5,SYMC-L5	;1ST .IDENT?
	BNE	1$		;NO-
	MOV	(SP),R0		;YES-ADDRESS OF INPUT IN R0
	MOV	#ID,R1		;ADDRESS OF OUTPUT IN R1
	UNPACK
1$:	TSTB	IDF-L5		; .IDENT INTO SYMTAB?
	BEQ	2$		;YES-
	CMP	PTRG-L5,SYMC-L5	;1ST .IDENT?
	BEQ	2$		;YES-
	TST	(SP)+		;NO-POP R4 OFF STACK
	BR	3$
2$:	MOV	PTRG-L5,R4	;YES-OBTAIN POINTER TO CURRENT
				;OBJECT MODULE NAME
	ADD	#BPSYM,R4	;MAKE R4 POINT AFTER IT
	UNSQUISH		;MAKE A HOLE WHERE R4 POINTS
				;NOTE-R4 STILL CONTAINS ADDRESS OF
				;BEGINNING OF HOLE IN SYMBOL TABLE
	MOV	(SP)+,R3	;SET INTO R3 THE POINTER TO THE
				;ENTRY IN READ BUFFER
	MOV	(R3)+,(R4)+	;MOVE BLOCK OF .IDENT
	MOV	(R3)+,(R4)+	;AFTER BLOCK OF .TITLE
	MOV	(R3)+,(R4)+
	MOV	(R3)+,(R4)+
	ADD	#BPSYM,SYME-L5	;UPDATE SYMTAB POINTERS
	ADD	#BPSYM,USYME-L5
3$:	RESREG
	JMP	GGSD03
	.IFNDF	NOSEG
	.EOT
î;TAPE 3
ENDO05:
SIZO05=ENDO05-BEGO05
;
;*****OVERLAY #6*****
L6=BEGOVR-BEGO06		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO06:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START6		;ENTRY1
	.ENDC
;
;	LIBRARY SEARCHING ROUTINE
;
;	INITIALIZATION
;
;
;	REGISTER ASSIGNMENTS
;
;	EVEN REGISTERS ARE ASSOCIATED WITH A LIBRARY DIRECTORY
;	ODD REGISTERS ARE ASSOCIATED WITH A SYMBOL TABLE.
;	R0	DIRECTORY POINTER
;	R1	SYMBOL TABLE POINTER
;	R2	SIZE OF DIRECTORY SEGMENT
;	R3	SIZE OF SYMBOL TABLE
;	R4	CURRENT DIRECTORY SYMBOL
;	R5	CURRENT UNDEFINED FROM SYMBOL TABLE
;
START6:	MOV	STBC-L6,R3	;GET SYMTAB BC
	BEQ	OUT5		;NO UNDEFINED GLOBALS IN SYMT
	MOV	R3,SVSTBC-L6	;SAVE SYMTAB BC
	MOV	FDATA-L6,R0	;GET PTR TO 1ST DATA ITEM
	MOV	BC-L6,R2	;GET DIR BC
	ADD	#2,R2
	MOV	SYME-L6,R1	;SET UP SYMTAB PTR
	MOV	(R0)+,R4	;GET NEXT DIRECTORY SYMBOL
	MOV	(R1)+,R5	;GET NEXT UNDEFINED IN SYMBOL TABLE
	.IFDF	OLDLUK
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	TSTEND
	.ENDC
	.ENDC
COMP1:	CMP	R4,R5		;COMPARE SYMTAB SYMBOL TO DIRECTORY
				;SYMBOL
	BEQ	MATCH1		;IF SYMBOLS MATCH GO TO 2ND COMP

;
;	MISMATCH
;	ATTEMPT TO INCREMENT INDEX OF SYMBOL TABLE
;
MISM1:	TST	(SP)		;NOOP
TRYINC:	ADD	#12,R3		;INCREMENT SYMBOL TABLE COUNT
	BNE	INCTAB		;IF MORE SYMBOLS IN SYMTAB GO TO
				;INCREMENT INDEX
;
;	REACHED THE END OF THE UNDEFINEDS IN SYMBOL TABLE
;
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	INCMC1
	.ENDC
	ADD	#10,R2		;INCREMENT DIRECTORY COUNT
OUT1:	BR	OUT6
OUT5:	JMP	FINI
	.IFNDF	RSX
INCMC1:
	.IFNDF	OLDLUK
	ADD	#2,R2
	.ENDC
	.IFDF	OLDLUK
	ADD	#16,R2
	.ENDC
	.ENDC
OUT6:	BGE	FINI		;FINISHED IF NO MORE SYMBOLS IN DIRECTORY
;
;	DID NOT REACH THE END OF THE DIRECTORY
;
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	INCE1
	.ENDC
	ADD	#6,R0		;POINT TO NEXT DIR ENTRY
	BR	OUT2
	.IFNDF	RSX
INCE1:
	.IFNDF	OLDLUK
	INC	INDEX-L6	;UPDATE MRT TABLE INDEX
	.ENDC
	.IFDF	OLDLUK
	ADD	#14,R0
	.ENDC
	.ENDC
OUT2:	MOV	(R0)+,R4	;GET NEXT DIRECTORY SYMBOL
;	RESTART UNDEFINEDS IN SYMBOL TABLE
	MOV	SVSTBC-L6,R3	;RESET SYMBOL TABLE SIZE COUNT
	MOV	SYME-L6,R1	;REPOSITION THE POINTER IN R1 TO
				;THE BEGINNING OF THE SYMBOL TABLE
	MOV	(R1)+,R5	;GET NEXT UNDEFINED IN SYMBOL TABLE
	BR	COMP1		;GO TO COMPARE FIRST UNDEFINED
				;IN SYMBOL TABLE
;	INDEX UNDEFINEDS IN SYMBOL TABLE
;
INCTAB:	ADD	#10,R1		;POINT TO NEXT SYMTAB ENTRY
	MOV	(R1)+,R5
	BR	COMP1		;GO TO COMPARE FIRST UNDEFINED
MATCH1:
	.IFNDF	OLDLUK
	TSTB	MONLIB-L6	;1ST PARTS MATCHED
	BEQ	COMP2
	MOV	(R1)+,R5
	TST	R5
	BEQ	MATCH2
	BR	MISM2
	.ENDC
COMP2:	MOV	(R0)+,R4	;PREPARE FOR 2ND MATCHING
	MOV	(R1)+,R5
	CMP	R4,R5
	BEQ	MATCH2		;2ND PARTS MATCHED?
MISM2:				;NO-
MISM3:		
TRYIN2:	ADD	#12,R3		;TRY INCR SYMTAB COUNT
	BNE	INCT2		;SYMTAB ENDED?
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	INCM2
	.ENDC
	ADD	#10,R2		;YES-TRY INCR DIR COUNT
	BR	OUT3
	.IFNDF	RSX
INCM2:
	.IFNDF	OLDLUK
	ADD	#2,R2
	.ENDC
	.IFDF	OLDLUK
	ADD	#16,R2
	.ENDC
	.ENDC
OUT3:	BGE	FINI		;DIR ENDED?
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	INCE2
	.ENDC
	ADD	#4,R0		;NO- GET NEXT DIR ENTRY
	BR	OUT4
	.IFNDF	RSX
INCE2:
	.IFNDF	OLDLUK
	INC	INDEX-L6	;UPDATE MRT TABLE INDEX
	.ENDC
	.IFDF	OLDLUK
	ADD	#12,R0
	.ENDC
	.ENDC
OUT4:	MOV	(R0)+,R4
	MOV	SVSTBC-L6,R3	;RESTART UNDEFINES
	MOV	SYME-L6,R1	;IN SYMTAB
	MOV	(R1)+,R5
	BR	COMP1
INCT2:	ADD	#6,R1		;POINT TO NEXT SYMTAB ENTRY
	MOV	(R1)+,R5	;SYMTAB DID NOT END YET
	TSTB	MONLIB-L6	;MONITOR SEARCH
	BNE	COMP1		;YES, ENTRY IS CORRECT
	CMP	-(R0),-(R0)	;RESTART DIR ENTRY TO 1ST PART
	MOV	(R0)+,R4	;OF SYMBOL PAIR
	BR	COMP1
				;IN SYMBOL TABLE
;
;	SYMBOLS MATCHED
;
MATCH2:
	.IFNDF	RSX
	TSTB	MONLIB-L6
	BNE	MONLT3
	.ENDC
	MOVB	(R0)+,LBYTE-L6
	BITB	#10,LBYTE-L6
	BEQ	INTERM		;UNDEF
	MOVB	(R0)+,HBYTE-L6	;DEFINED
	CMPB	#1,HBYTE-L6	;IS IT A SECTION,OR A SYMBOL?
	BEQ	MATCH3		;MATCHED A SECTION NAME
	CMPB	#4,HBYTE-L6	;MATCHED A SYMBOL
	BEQ	MATCH3
	TST	-(R0)
	BR	MISM3
	.IFNDF	RSX
MONLT3:	BITB	#1,(R1)
	BNE	MONMAT
	BR	MISM3
	.ENDC
INTERM:	TSTB	-(R0)
	BR	MISM3
	.IFNDF	RSX
MONMAT:
	.IFNDF	OLDLUK
	MOV	INDEX-L6,4(R1)
	SUB	#2,4(R1)	;MAKE THE EMT VALUE CORRECT
	.ENDC
	.IFDF	OLDLUK
	CMP	6(R0),4(R1)
	.ENDC
	CMP	-(R1),-(R1)
	BR	INCM2
	.ENDC
MATCH3:	MOV	#1,DIRSRV-L6
	BR	FINI1
	.IFDF	OLDLUK
	.IFNDF	RSX
TSTEND:	TST	R4
	BEQ	FINI
	JMP	COMP1
	.ENDC
	.ENDC
FINI:	MOV	#0,DIRSRV-L6
FINI1:	RTS	PC
	.IFNDF	NOSEG

ENDO06:
SIZO06=ENDO06-BEGO06
;
;*****OVERLAY #7*****
L7=BEGOVR-BEGO07		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO07:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START7		;ENTRY1
	JMP	PMAP10		;ENTRY2
	.ENDC

;
;	SUBROUTINE TO PRINT THE LOAD MAP (PMAP)
;
;	OUTPUT TO MAPSL
;	INIT MAPSL TO DEVICE CODE IN MAPDEV
;
;	SET POINTERS TO SYMBOL TABLE
START7:	SAVREG
	MOV	SP,SSP-L7	;SAVE SP
	MOV	SYMB-L7,R2	;BEGINNING OF TABLE
;
;	INITIALIZE MAP OUTPUT DEVICE
;
	MOV	#ERRET3-BEGO07+BEGOVR,MAPADR-4-L7	;SET UP
						;ERROR RETURN
	.INIT	#MAPDEV		;INIT THE DATA SET
	TST	MAPADR+4-L7
	BNE	.+10
	MOV	#0,MAPADR+4-L7
	.=.-4
	.RAD50	/MAP/
	.=.+2
	.DELET	#MAPDEV,#MAPADR
ERRET3:	CLR	MAPADR-4-L7	;NOW LET MONITOR HANDLE ERRORS
	INCB	MAPOPF-L7	;INDICATE MAP OPEN
	TST	MAPADR+4-L7
	BNE	.+10
	MOV	#0,MAPADR+4-L7	;SET DEFAULT EXTENSION
	.=.-4
	.RAD50	/MAP/
	.=.+2
	.OPEN	#MAPDEV,#MAPADR
	.RSTRT	#PMAP14		;SET UP ABORTING ADDRESS
	.IFNDF	RSX
	.DTCVT	#DATE		;GET TODAY'S DATE
	.TMCVT	#TIME		;AND THE TIME
	MOVB	#' ,R0
	MOV	#DATE,R1
	MOVB	R0,-(R1)
	MOVB	R0,-(R1)
	.ENDC
	MOV	#PMAP86,R0	;PRINT HEAD
	MAPTYP
;
;	CLEAR ID
;
	MOV	#100040,-(SP)
	MOV	(SP),ID-L7
	MOV	(SP),ID-L7+2
	MOV	(SP),ID-L7+4
	MOV	(SP)+,ID-L7+6
	.IFDF	RTH		;BRTH9
	TSTB	RTF-L7		;TYPE RTH IN LOAD MAP ?
	BEQ	.+10		;NO-
	MOV	#RTHB,R0
	MAPTYP
	.ENDC			;ERTH9
;	MSG TRAM IS ALREDY FORMATTED
	MOV	#TRAM,R0
	MAPTYP
	MOV	#4,-(SP)	;SET COUNT FLAG TO NON-GLOBAL
	BR	PMAP01		;GO TO PRINT LOOP
;	UPDATE POINTER AND LOOK FOR END OF TABLE.
PMAP02:	ADD	#BPSYM,R2
PMAP01:	CMP	R2,SSYME-L7	;DONE
	BHIS	PMAP09		;YES - GO DO UNDEFINES
	MOVB	FLAGS+1(R2),R3	;NO - GET ENTRY TYPE
	MOV	#PMAP82+6,R1	;ADR OF OUTPUT BUFFER
	CMP	R3,#PMAX
	BLE	.+4
	ERR14
	ASL	R3
	JMP	@SCMDT-BEGO07+BEGOVR(R3) ;DISPATCH
;
;	TEST FOR & LIST UNDEFINES
;
PMAP09:	JSR	PC,FINLIN	;TERMINATE LAST LINE
	TST	(SP)+		;DISCARD COUNT FLAG
	MOV	SSYME-L7,R0	;ANY UNDEFINES?
	CMP	USYME-L7,R0
	BEQ	PMAPX1		;NO - GET OUT
				;YES - PRINT THE HEADING
;
;	PRINT HEADING
;
	MOV	R0,-(SP)
	MOV	#PMAP80,R0	;PRINT SOME STARS
	MAPTYP
	MAPTYP			;MORE STARS
	MOV	#PMAP84,R0	;"UNDEFINED REFS"
	MAPTYP
	MOV	(SP)+,R0
	CLRB	PMAP11-L7
;
;	PRINT VARIABLES, ONE PER LINE.
;
PMAP16:	BIT	#MONCND,FLAGS(R0)
	BEQ	PMAP10
	ADD	#BPSYM,R0
	CMP	R0,USYME-L7
	BLO	PMAP16
	BR	PMAPX1

PMAP10:	MOV	#PMAP82+6,R1
	UNPACK
	MOVB	#CR,(R1)+
	MOVB	#LF,(R1)+
	MOV	#8.,PMAP82+4-L7	;SET BC
	MOV	R0,-(SP)
	MOV	#PMAP82,R0
	TSTB	PMAP11-L7
	BEQ	PMAP12
	TYPE
	BR	PMAP13
PMAP12:	MAPTYP
PMAP13:	MOV	(SP)+,R0
	ADD	#BPSYM,R0	;UPDATE PTR TO NEXT SYMBOL
	CMP	R0,USYME-L7	;DONE?
	BLO	PMAP16		;NO - DO IT AGAIN
;	DONE
PMAPX1:	.RSTRT	#LINK
	RESREG			;RESTORE REGISTERS
;
;	CLOSE MAP FILE
;
	TSTB	PMAP11-L7	;DO NOT CLOSE IF
	BNE	PMAP15		;LISTING UNDEFINES
	CLRB	MAPOPF-L7	;CLEAR MAP DEV OPEN FLAG
	.CLOSE	#MAPDEV
;
;	RELEASE MAP DATA SET
;
	.RLSE	#MAPDEV
PMAP15:	RTS	PC		;EXIT
;	SCMDT--SYMBOL TABLE ENTRY TYPE DISPATCH TABLE.
;	COMMANDS ARE:  OBJ-MOD NAME, PROG-SECT NAME, INT-SYM NAME,
;		      TRA-SPEC, SYMBOL ENTRY
;
SCMDT:	.WORD	PMAP03-BEGO07+BEGOVR
	.WORD	PMAP04-BEGO07+BEGOVR
	.WORD	PMAP05-BEGO07+BEGOVR
	.WORD	PMAP05-BEGO07+BEGOVR
	.WORD	PMAP06-BEGO07+BEGOVR
	.WORD	PMAP04-BEGO07+BEGOVR
;	CNTRL-C RETURN SEEN DURING MAP
;		ABORT IT.
;
PMAP14:	MOV	SSP-L7,SP	;RESTORE SP
	BR	PMAPX1		;GET OUT
;
;	OBJ-MOD NAME
PMAP03:	JSR	PC,FINLIN	;FINISH LAST LINE
	MOV	#PMAP80,R0	;PRINT STARS
	MAPTYP
;MOVE IN "MODULE"
	MOV	#"MO,(R1)+
	MOV	#"DU,(R1)+
	MOV	#"LE,(R1)+
	MOVB	#TAB,(R1)+	;PUT TAB IN BUFFER
	MOV	R2,R0		;R0=ADR OF NAME
	UNPACK			;DO MOD40 UNPACK
;
;	IF .IDENT IS SPECIFIED THEN INSERT .IDENT
;	AFTER THE OBJECT MODULE NAME IN LOAD MAP
;
	ADD	#BPSYM,R2	;ADVANCE POINTER TEMPORARILY
				;TO NEXT ENTRY AFTER NAME
	MOVB	FLAGS+1(R2),HBYTE-L7
	CMPB	HBYTE-L7,#6	;IS NEXT ENTRY .IDENT?
	BNE	1$		;NO-
	MOVB	#TAB,(R1)+	;YES-INSERT .IDENT
	MOV	R2,R0		;R0=ADR OF NAME
	UNPACK
	BR	PMAP07
1$:	SUB	#BPSYM,R2	;RETRACT POINTER TO NAME
PMAP07:	CMP	(SP),#4		;ARE WE IN NON GLOBAL MODE?
	BEQ	3$		;YES, DO NORMAL ENDING
	CMP	(SP),#2		;HAS THE LINE OVERFLOWED?
	BGE	1$		;YES
	INC	(SP)		;ADVANCE COUNT
	MOVB	#TAB,(R1)+
	MOVB	#VT,(R1)+	;STORE VERTICAL TAB
	BR	2$
1$:	CLR	(SP)
3$:	MOVB	#CR,(R1)+	;PUT IN CR
	MOVB	#LF,(R1)+	;   AND LF
2$:	MOV	#PMAP82,R0	;
	SUB	#PMAP82+6,R1	;GET THE BYTE COUNT
	MOV	R1,PMAP82+4-L7	;SAVE IT AWAY
	MAPTYP
;PRINT EXTRA HEADING IF OBJ-MODULE
	CMP	SCMDT-BEGO07+BEGOVR(R3),#PMAP03-BEGO07+BEGOVR
	BNE	11$
	MOV	#PMAP88,R0
	MAPTYP
11$:	JMP	PMAP02		;GO FOR MORE
;
;	PROG-SECTION NAME
;
PMAP04:	JSR	PC,FINLIN	;TERMINATE PREVIOUS LINE IF NECESSARY
	MOVB	#LANG,(R1)+	; MOV IN "<"
	MOV	R2,R0
	UNPACK			;MOD40 UNPACK
	MOVB	#RANG,(R1)+
	CMPB	FLAGS+1(R2),#LOCAL
	BNE	PMAP17
	MOVB	#L,(R1)+
PMAP17:	MOVB	#TAB,(R1)+
	MOV	BASE(R2),R0	;GET BASE VALUE INTO R0
	OTOA			;OCTAL TO ASCII CONVERSION
	MOVB	#TAB,(R1)+	;INSERT A TAB
	MOV	VALR(R2),R0	;GET SIZE
	OTOA			;DO CONVERSION
	BR	PMAP07

;
;	INTERNAL SYMBOLS AND TRA ARE ILLEGAL
PMAP05:	JSR	PC,FINLIN
	ERR07
;
;	ENTRY SYMBOL
;
PMAP06:	CMP	(SP),#4		;NON GLOBAL MODE?
	BNE	1$		;NO
	CLR	(SP)		;YES , CLEAR THE FLAG
1$:	MOVB	#TAB,(R1)+	;INSERT TAB
	MOV	R2,R0
	UNPACK			;MOD40 UNPACK
	MOVB	#TAB,(R1)+
	MOV	BASE(R2),R0
	OTOA			;CONVERT ABSOLUTE VALUE TO ASCII
	BR	PMAP07
;SPECIAL LINE TERMINATOR
FINLIN:	CMP	2(SP),#4	;WAS IT GLOBAL
	BEQ	1$		;YES
	TST	2(SP)
	BEQ	2$
	MOV	#4,2(SP)	;RESET FLAG
	MOV	#2,DUMIN+4-L7
	MOV	#CRLF,DUMIN+6-L7
	MOV	#DUMIN,R0
	MAPTYP
	CLR	DUMIN+4-L7
	CLR	DUMIN+6-L7
1$:	RTS	PC
2$:	MOV	#4,2(SP)
	RTS	PC
;

	.IFNDF	NOSEG
ENDO07:
SIZO07=ENDO07-BEGO07

;
;*****OVERLAY #9*****
L9=BEGOVR-BEGO09		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO09:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY
;
	JMP	DONE		;ENTRY1
	.ENDC
;
;	ALL OBJ MODULES HAVE BEEN READ.  CREATE TRA BLOCK
;	ON THE LOAD MODULE, FOLLOWED BY TRAILER.
DONE:
	.IFDF	RTH		;BRTH10
	TSTB	NOIOF-L9	;CREATE RTH?
	BEQ	NORTH		;NO-
	SAVREG			;YES
	MOV	#38.,@PUTR0-L9
	MOV	#19.,R4
	MOV	PUTR1-L9,R5
ZERRTH:	CLR	(R5)+
	DEC	R4
	BGT	ZERRTH
;
;           FILL IN RTH
;
	TST	-(R5)
	TSTB	CSICN-L9	;CALL NO FROM CSI ?
	BEQ	LNK181		;NO- USE DEFAULT 
	MOV	CN-L9,(R5)	;YES-
	CLRB	CSICN-L9
	BR	LNK189
LNK181:	MOV	LOWADR-L9,(R5)	;USE LOWADR AS DEFAULT CN
LNK189:	MOV	NAM1-L9,-2(R5)	;FILL IN NAME
	MOV	NAM2-L9,-4(R5)
	CLRB	CSIN-L9
	MOV	TRA-L9,-14(R5)	;FILL IN TRA ADR
	MOV	LOWADR-L9,-16(R5)	;PUT LOW LIM OF PROG
	MOV	LOWADR-L9,-(SP)	;PREPARE STACK LIMIT
	SUB	SS-L9,(SP)
	SUB	#2,(SP)
	MOV	(SP)+,-22(R5)	;FILL IN STACK LIMIT
	MOV	PRIOR-L9,-24(R5)	;FILL IN PRIORITY
	MOV	MT-L9,-30(R5)	;FILL IN MAX TIME
	MOV	#FIO1,R4	;SET PTR TO $OTSV INTO R4
	SRGLOB			;SEARCH FOR FORTRAN INP A PTR
	BR	LNK191		;NOT FOUND
	MOV	R4,-42(R5)	;FOUND- FILL IN
LNK191:	MOV	SLARTH-L9,-44(R5) ;FILL IN LOAD ADDRESS FOR RTH
	IOOP
	TSTB	IOOPER-L9
	BEQ	.+6
	JMP	LINK25-L9
	MOV	R0,PUTR0-L9
	MOV	R1,PUTR1-L9
	RESREG
	.ENDC			;ERTH10
NORTH:	MOV	PUTR0-L9,R0	;GET PTR'S TO OUTPUT BUFFER.
	MOV	PUTR1-L9,R1
	MOV	#2,(R0)		;SET BC
	MOV	TRA-L9,(R1)	;SET TRA
	IOOP			;DUMP
	TSTB	IOOPER-L9
	BEQ	.+6
	JMP	LINK25-L9
;
;	CLOSE LOAD MODULE FILE
;
	TST	LODDEV+6-L9	;ANY LOAD MOD OUTPUT?
	BEQ	LINK05		;NO--
	CLRB	LODOPF-L9		;CLEAR LOD DEV OPEN FLAG
	MOV	#LODDEV,-(SP)
	MOV	(SP),-(SP)
	EMT	CLOSE
;
;	RELEASE LOAD MODULE DATA SET
;
	EMT	RELEAS
;
;	CLOSE KEYBOARD FILE
;
LINK05:	MOV	#INCMD,-(SP)
	MOV	(SP),-(SP)
	EMT	CLOSE
;
;	RELEASE KEYBOARD DATA SET
;
	EMT	RELEAS
;
;	CLOSE TELETYPE FILE
;
	MOV	#OUTCMD,-(SP)
	MOV	(SP),-(SP)
	EMT	CLOSE
;
;	RELEASE TELETYPE DATA SET
;
	EMT	RELEASE

	TSTB	OVLC-L9		;LINKING OVERLAYS?
	BLE	1$		;NO-
	TSTB	OVLF-L9		;YES-WHAT SECTION?
	BEQ	3$
	CLRB	OVLF-L9		;RESIDENT-CLEAR FLAG
	MOV	SYMB-L9,SSYMB-L9	;SAVE RESIDENT
;					 SYMBOL TABLE
	MOV	SYME-L9,SASYME-L9	;POINTERS
	MOV	LOWADR-L9,-(SP)	;SAVE RES LOWADR-2,
	MOV	(SP),OVLTOP-L9
	BR	4$
3$:	MOV	OVLTOP-L9,-(SP)	;OVERLAYS
4$:	SUB	#2,(SP)		;THE DEFAULT TOP OF MEM
	MOV	(SP)+,@SASYME-L9	;FOR THE OVERLAYS
1$:	TSTB	GOF-L9		;EXECUTE LOAD MOD?
	BEQ	2$		;NO-
	.IFNDF	NOSEG
	MOV	#OVRLB,-(SP)	;RELEASE OVERLAY DATASET
	EMT	RELEAS
	.ENDC
	MOV	#RUNBLK,-(SP)	;YES-ISSUE GET EMT
	EMT	GET
2$:	JMP	LINK-L9		;RESTART LINKER
	.IFNDF	NOSEG

ENDO09:
SIZO09=ENDO09-BEGO09

	.ENDC
	.ENDC			;END OF OVRBLD
	.IFNDF	NOSEG

	.CSECT
;BEGINNING OF OVERLAY AREA
;THE SIZE OF THE OVERLAY AREA IS DETERMINED
;BY THE SYMBOL "OVRSIZ"
;
BEGOVR:
;THE BEGINNING REGISTERS OF EACH
;OVERLAY CONTAIN JMP'S TO THE
;ENTRY POINTS OF THE OVERLAY

ENTRY1=.
ENTRY2=.+4
ENTRY3=.+10
ENTRY4=.+14
ENTRY5=.+20
ENTRY6=.+24
ENTRY7=.+30
ENTRY8=.+34
ENTRY9=.+40
	.ENDC

	.IFDF	OVRBLD		;B35
	.IFNDF NOSEG
;
;*****OVERLAY #8*****
L8=BEGOVR-BEGO08		;COMPUTE OFFSET FROM
				;RUN TIME OVERLAY AREA
BEGO08:
;JUMP TABLE TO ENTRY POINTS
;IN THIS OVERLAY.
;
	JMP	START8		;ENTRY1
	.ENDC
;
;	PROCESSING FOR PASS2
;
START8:	TSTB	LIBF-L8
	BNE	LNK03
	IOII			;INPUT INIT. SET R0,R1 TO BUFFER.
LNK05:	CLR	GENDF-L8	;NO GSD END SEEN.
LINK76:	BITB	#EOF,-1(R0)	;ERROR?
	BEQ	.+6
	JMP	LINK53		;YES,IGNORE INPUT
	CMPB	#GSDBLK,(R1)	;IS THIS A GSD BLOCK
	BEQ	LINK42		;
	ERR03			;ERROR-MODULE MUST START
				;WITH GSD FOR MODULE NAME
LINK42:	CMPB	#OBJMN,7(R1)	;IS THIS THE NAME?
	BEQ	LINK43
	ERR04			;ERROR.
LINK43:	MOV	PTRG-L8,R2		;SET R2 TO NAME IN SYMBOL TABLE
	TST	(R1)+		;ADVANCE POINTER TO MODULE NAME
	CMP	(R2)+,(R1)+	;IS THE NAME OK?
	BNE	LINK44		;NO-ERROR
	CMP	(R2),(R1)	;TRY SECOND WORD.
	BNE	LINK44		;ERROR.
	CLRB	FILEOR-L8
;	START READING THE NON-GSD BLOCKS.
LINK45:	GNGSD			;GET A NON-GSD BLOCK
				;R0 POINTS TO BC.
				;R1 POINTS TO FIRST BYTE OF BUFFER.
	SUB	#2,(R0)		;DECREMENT BC.
	MOV	(R1)+,R2	;GET BLOCK TYPE
	BITB	#EOF,-1(R0)	;INPUT ERROR?
	BNE	LNK169		;YES,TREAT AS MODULE END
	CMP	#TXTBLK,R2	;TXT?
	BEQ	LINK46		;YES.
	CMP	#MODEND,R2	;MODULE END?
	BEQ	LINK47		;YES
	CMP	#GSDEND,R2	;GSD END?
	BNE	.+6
	INC	GENDF-L8
	CMP	#RLDBLK,R2	;RLD?
	BNE	LINK45		;NO-IGNORE ALL OTHER BLOCKS.
	MOVB	#3,T-L8		;SET T SWITCH TO 3.
	CMP	-(SP),-(SP)	;FAKE DOUBLE PUSH.
	JMP	LINK48		;GO PROCESS RLD.
LNK169:	BR	LINK47
;
;	MODULES OUT OF ORDER
;
LINK44:
	.IFDF	BLKIO
	JSR	PC,@#READST	;GET DEVICE STATUS
	.ENDC
	.IFNDF	BLKIO
	.STAT	#OBJDEV
	.ENDC
	TST	(SP)+
	BPL	LNK151
	CMP	(SP)+,(SP)+
	INCB	FILEOR-L8
	TSTB	CONCAT-L8
	BEQ	LNK150
LNK141:	IOIG
	BITB	#EOF,-1(R0)
	BEQ	.+10
	CLRB	FILEOR-L8
	BR	LNK150
	CMPB	#MODEND,(R1)
	BEQ	.+4
	BR	LNK141
	JMP	LINK75
LNK150:	JMP	LINK53
LNK151:	CMP	(SP)+,(SP)+
	MOV	PTRG-L8,R0
	MOV	#ORDRER,R1
	UNPACK
	MOV	#ORDRM,R0
	TYPE
	CLR	-(SP)
	MOV	#406,-(SP)	;CODE=A006
	IOT
	.IFDF	BLKIO
	JSR	PC,@#CLOSRD	;CLOSE AND RELEASE INPUT
	.ENDC
	.IFNDF	BLKIO
	MOV	#OBJDEV,-(SP)	;CLOSE & RELEASE INPUT
	MOV	(SP),-(SP)
	EMT	CLOSE
	EMT	RELEASE
	.ENDC
	BR	START8		;TRY AGAIN
LNK03:	IOIG
	BR	LNK05
;
;	TXT BLK
;
;	MOVE TXT BLOCK TO A SAVE AREA
;
LINK46:	MOV	#TXTSVB,R2	;ADR OF TXT SAVE AREA
	MOV	R2,-(SP)
	MOV	(R0),(R2)	;MOVE IN BC
	SUB	#2,(R2)+
	SUB	#2,(R0)
	MOV	CURPC-L8,(R2)+	;MOVE IN CURRENT PC
	MOV	R2,-(SP)
	TST	(R1)+		;ADVANCE PTR TO 1-ST
				;  DATA WORD.
LINK59:	DEC	(R0)		;DONE?
	BLT	LINK49		;YES
	MOVB	(R1)+,(R2)+	;MOVE IN A BYTE
	BR	LINK59
LINK49:	CLRB	T-L8
	GNGSD			;GET NEXT NON-GSD BLOCK.
	MOV	(R1)+,R2	;GET BLK TYPE.
	SUB	#2,(R0)
	BITB	#EOF,-1(R0)	;ERROR?
	BNE	LINK62		;YES,TREAT AS MODULE END
	CMP	#RLDBLK,R2	;RLD?
	BEQ	LINK48		;YES
	CMP	#TXTBLK,R2	;TXT
	BEQ	LINK50		;YES
	CMP	#GSDEND,R2	;GSD END?
	BNE	.+6
	INC	GENDF-L8
	CMP	#MODEND,R2	;MODULE END
	BNE	LINK49		;NO-IGNORE ALL ELSE
LINK62:	MOVB	#2,T-L8		;TXT FOLLOWED BY MODULE END.
	BR	LINK51
LNK06:	JMP	LNK10-L8
;
;	ADVANCE TO NEXT MODULE (MOVE PTRG IN SYMBOL TABLE).
;
LINK47:	MOV	PTRG-L8,R2		;GET PTRG
	ADD	#5,R2		;SET TO FLAGS OF A SYMBOL.
LINK52:	ADD	#BPSYM,R2	;MOVE TO NEXT ENTRY.
	CMP	R2,SYME-L8		;TOO FAR
	BHIS	LINK53		;YES
	CMPB	(R2),#OBJMN	;IS ENTRY AN OBJ MODULE NAME?
	BNE	LINK52		;NO-TRY NEXT ONE
	SUB	#5,R2		;YES,DO ANOTHER
	MOV	R2,PTRG-L8	;INPUT FILE
	TSTB	LIBF-L8
	BNE	LNK186
	MOVB	TAPES-L8,-(SP)
	BISB	CONCAT-L8,(SP)+
	BNE	LINK75		;IGNORE GENDF-L8 IF TAPES OR 
				;CONCAT IS ON.
LNK186:	TST	GENDF-L8	;SEEN GSD END?
	BEQ	LINK75		;NO, STAY IN SAME FILE
LINK53:	TSTB	LIBF-L8
	BNE	LNK06
LNK152:	IOIC			;CLOSE OBJECT MODULE FILE
				;AND RELEASE ITS DATA SET
				;IN SECOND PASS
	JMP	LINK97-L8		;YES, DO NEXT FILE		
LINK75:	IOIG		;GET NEXT BLOCK
	JMP	LINK76		;   AND PROCESS.
;
;	TXT FOLLOWED BY TXT
;
LINK50:	MOVB	#1,T-L8
;
;	UPDATE CURPC BY SIZE OF LAST TXT BLK
;
	ADD	@2(SP),CURPC-L8	;USES STACKED R0 FOR POINTER TO
				;LAST TXT BLK BC.
	BR	LINK54		;GO OUTPUT LAST TXT BLK.
;
;	TXT FOLLOWED BY RLD
;
LINK48:	JSR	PC,PRLD00	;PROCESS RLD
LINK51:	CMPB	#3,T-L8		;ANY TXT TO OUTPUT?
	BEQ	LINK55		;NO
;
;	OUTPUT TXT
;
LINK54:	MOV	(SP),R3		;PTR'S TO TXT DATA
	MOV	2(SP),R2	;AND TO TXT BC
	MOV	PUTR0-L8,R4	;PTR'S TO OUTPUT BC
	MOV	PUTR1-L8,R5	;AND TO OUTPUT DATA.
	MOV	-2(R3),(R5)+	;GET LOAD ADDRESS
	ADD	#2,(R4)		;UPDATE OUTPUT BC.
LINK56:	MOVB	(R3)+,(R5)+	;MOVE A DATA BYTE
	INC	(R4)		;OUTPUT BC UPDATE.
	DEC	(R2)		;DONE
	BGT	LINK56		;NO-DO ANOTHER.
	MOV	R0,-(SP)
	MOV	R1,-(SP)
	.IFDF	RTH		;BRTH11
	TSTB	RTF-L8		;DOING RTH?
	BEQ	LNK174		;NO-
	CMP	RTHPTR-L8,PTRG-L8 ;RTH NEXT?
	BNE	LNK174		;NO-
	TST	-(R5)		;YES
	MOV	LOWADR-L8,-(SP)	;PREPARE STACK LIMIT
	SUB	SS-L8,(SP)
	SUB	#2,(SP)
	MOV	(SP)+,-22(R5)
	CLRB	CSISS-L8
	TSTB	CSIMT-L8	;MT FROM CSI?
	BEQ	.+14		;NO-
	MOV	MT-L8,-30(R5)	;YES-
	CLRB	CSIMT-L8
	TSTB	CSICN-L8	;CN FROM CSI?
	BEQ	LNK190		;NO-
	MOV	CN-L8,(R5)	;YES-
	CLRB	CSICN-L8
LNK190:	TSTB	CSIP-L8		;PRIOR FROM CSI?
	.EOT
;TAPE 4
	BEQ	.+14		;NO-
	MOV	PRIOR-L8,-24(R5) ;YES
	CLRB	CSIP-L8
	TSTB	CSIN-L8		;NAME FROM CSI?
	BEQ	LNK171		;NO-
	MOV	NAM1-L8,-2(R5)	;YES-
	MOV	NAM2-L8,-4(R5)
	CLRB	CSIN-L8
LNK171:	MOV	TRA-L8,-14(R5)	;FILL IN TRA ADR
	MOV	LOWADR-L8,-16(R5)	;FILL IN LOW LIM OF PROG
	MOV	#FIO1,R4	;SET PTR TO $OTSV INTO R4
	SRGLOB			;SEARCH FOR IT
	BR	LNK174		;NOT FOUND
	MOV	R4,-42(R5)	;FOUND - FILL IN.
	.ENDC			;ERTH11
LNK174:	IOOP			;OUTPUT THE BUFFER
	TSTB	IOOPER-L8		;OUT ERROR?
	BEQ	.+6
	JMP	LINK25-L8
	MOV	R0,PUTR0-L8	;SAVE R0,R1
	MOV	R1,PUTR1-L8	;FOR NEXT OUTPUT
	MOV	(SP)+,R1
	MOV	(SP)+,R0
LINK55:	CMP	(SP)+,(SP)+	;REMOVE THE STACKED R0,R1
	MOVB	T-L8,R2
	CMP	R2,#TMAX	;INDEX OK?
	BLE	.+4		;YES
	ERR14
	ASL	R2
	JMP	@LINK57-BEGO08+BEGOVR(R2)
LINK57:	.WORD	LINK45-BEGO08+BEGOVR
	.WORD	LINK46-BEGO08+BEGOVR
	.WORD	LINK47-BEGO08+BEGOVR
	.WORD	LINK45-BEGO08+BEGOVR



;
;	SUBROUTINE TO PROCESS RLD
;
;	INPUT --
;		R0 PTS TO RLD BC
;		R1 PTS TO BYTE FOLLOWING RLD BLK WORD
;		STACKED R0 AND R1 POINT TO PREVIOUS TXT BLOCK (IF ANY).
;
PRLD00:	TST	(R0)		;DONE WITH RLD?
	BGT	PRLD01		;NO -
	ADD	@4(SP),CURPC	;YES, UPDATE CURRENT PC
PRLDEX:	RTS	PC
;
;	PROCESS NEXT COMMAND
;
PRLD01:	MOVB	(R1)+,R2	;GET CMD
	MOVB	(R1)+,R3	;GET OFFSET INTO TXT
	MOV	R3,OFFSET	;SAVE IT
	SUB	#2,OFFSET
	ADD	2(SP),R3	;ADD PUSHED TXT POINTER TO
	ADD	#-4,R3		;FORM ACTUAL ADDRESS
	MOV	R2,-(SP)	;STACK CMD
	BIC	#177600,R2	;SAVE LOW 7 BITS
	MOV	PTSECT,R5
	CMP	R2,#CMDMAX
	BLE	.+4
PRLD06:	ERR14
	ASL	R2
	JMP	@RCMDT(R2)	;GO EXECUTE PROPER HANDLER
RCMDT:	+PRLD06,CMD1,CMD2,CMD3,CMD4,CMD5,CMD6
	+CMD7,CMD8,CMD9,CMD2,PRLD06,CMD4,CMD5,CMD6
;
;	CMD #1 -- INTERNAL RELOC
;
CMD1:	MOV	(R1)+,R4	;GET REL VALUE
	ADD	BASE(R5),R4	;RELOCATE IT
	TXTPUT
PRLD02:	SUB	#4,(R0)
	BR	PRLD00
;
;	CMD #2 -- GLOBAL RELOC

;
CMD2:	MOV	R1,R4		;SET ADR OF NAME
	CMP	(R1)+,(R1)+
	SRGLOB			;SEARCH FOR GLOBAL NAME
	ERR09		;ERROR
	TXTPUT
PRLD04:	SUB	#6,(R0)
	BR	PRLD00

;
;	CMD #3 -- INTERNAL DISPLACED RELOC
;
CMD3:	GETPC			;GET PC AT CURRENT PLACE.
	NEG	R4
	ADD	(R1)+,R4	;FORM (X - (.+2))
	BR	PRLD02-2
;
;	CMD #4 -- GLOBAL DISPLACED RELOC
;
CMD4:	GETPC			;GET PC NOW
	MOV	R4,TMP1
	MOV	R1,R4
	CMP	(R1)+,(R1)+
	SRGLOB			;GET GLOBAL VALUE
	ERR09		;ERROR
PRLD05:	SUB	TMP1,R4		;FORM (X-(.+2))
	BR	PRLD04-2
;
;	CMD #5 -- GLOBAL ADDITIVE RELOC
;
CMD5:	MOV	R1,R4
	SRGLOB			;GET GLOBAL VALUE
	ERR09		;ERROR
	CMP	(R1)+,(R1)+
	ADD	(R1)+,R4	;ADDITIVE CONSTANT
	SUB	#2,(R0)
	BR	PRLD04-2
;
;	CMD #6 -- GLOBAL ADDITIVE DISPLACED
;
CMD6:	GETPC			;GET PC NOW
	MOV	R4,TMP1
	MOV	R1,R4
	CMP	(R1)+,(R1)+
	SRGLOB
	ERR09		;ERROR
	ADD	(R1)+,R4
	SUB	#2,(R0)
	BR	PRLD05
;
;	CMD #7 -- SET PC
;
CMD7:	MOV	R1,R4
	CMP	(R1)+,(R1)+
	GETSEC			;GET SECTION POINTER
	ERR11		;FATAL ERROR
	MOV	R4,PTSECT	;SET PTSECT
	MOV	R4,R5
	SUB	#4,(R0)
	BR	CMD8
;
;	CMD #8 -- PC MODIFICATION
;
CMD8:	MOV	BASE(R5),R4	;GET SECTION BASE VALUE
	ADD	(R1)+,R4	;MODIFY
	MOV	R4,CURPC
	TST	(SP)+
	SUB	#4,(R0)
;	PC COMMANDS MUST BE LAST IN RLD
	BLE	PRLDEX
;	IF NOT DONE, NEXT COMMAND MUST ALSO BE PC TYPE
	CMPB	#PCMD1,(R1)
	BEQ	PRLD00
	CMPB	#PCMD2,(R1)
	BEQ	PRLD00
;
;	ERROR --- CMD MUST BE PC TYPE.
;
	ERR10		;FATAL ERROR
;
;	CMD #9---SET PROGRAM LIMITS
;
CMD9:	MOV	LOWADR,R4	;SET LOW LIMIT
	MOV	(SP),-(SP)	;GET TWO COPIES OF FLAG
	TXTPUT
	MOV	TOPMEM,R4	;SET HIGH LIMIT

	.IFDF	RTH		;BRTH12
	TSTB	RTF		;RTF AND NOT NOIOF?
	BEQ	.+14
	TSTB	NOIOF		;RTH WAS PREASSEMBLED?
	BNE	.+6		;NO-
	SUB	RTHSIZ,R4	;YES-SUBSTRUCT ITS SIZE
	.ENDC			;ERTH12
	TXTPUT
	SUB	#2,(R0)		;ADJUST BC
	JMP	PRLD00
	.IFNDF	NOSEG
ENDO08:
SIZO08=ENDO08-BEGO08
	.ENDC
	.ENDC			;E35

	.IFNDF NOSEG
	.=BEGOVR+OVRSIZ
;OVERLAY DEVICE LINK BLOCK
;
	.WORD	0		;ERROR RETURN ADDRESS
OVRLB:	.WORD	0		;LINK POINTER (DDB)
	.RAD50	/OVR/		;LOGICAL DATA SET NAME
	.BYTE	1		;DEVICE SPECIFIED
	.BYTE	0		;UNIT NUMBER
	.RAD50	/SY/		;DEVICE NAME
;
;OVERLAY DEVICE FILE BLOCK
;
	.WORD	0		;ERROR RETURN ADDRESS
	.BYTE	13		;HOW OPEN COEE (OPENC)
	.BYTE	0		;ERROR RETURN CODE
OVRFB:	.RAD50	/LIN/		;FILENAME AND EXTENSION
	.RAD50	/K11/		;IN RADIX 50
	.RAD50	/OVR/		;NOTATION
USERID:	.WORD	0		;USER ID CODE
	.BYTE	233		;PROTECT CODE
ONCE:	.BYTE	377		;ONCE ONLY FLAG
;
;CSI BLOCK FOR OVERLAY DEVICE DATA SET
;
OVRBLK:	.WORD	CMDB		;ADDRESS OF CSI BUFFER (7 WORDS)
	.WORD	OVRLB		;ADDRESS OF LINK BLOCK
	.WORD	OVRFB		;ADDRESS OF FILE BLOCK
;
;OVERLAY DEVICE INPUT TRAN BLOCK
;
OVRTBI:	.WORD	0		;DEVICE BLOCK NUMBER
	.WORD	BEGOVR		;MEMORY START ADDRESS
	.WORD	OVRWRD		;WORD COUNT
OVRIER:	.WORD	4		;FUNCTION (READ)
	.WORD	0		;NUMBER OF WORDS NOT TRAN'D

;SUBROUTINE TO DIVIDE THE TOP WORD OF
;THE STACK BY THE NEXT WORD. EXITS
;WITH THE QUOTIENT ON TOP OF THE
;STACK. THE QUOTIENT IS INCREMENTED BY
;ONE IF THERE IS A REMAINDER.
;	CALLING SEQUENCE:
;		MOV	DIVISOR,-(R6)
;		MOV	DIVIDEND,-(R6)
;		JSR	R7,DIVIDE
;		MOV	(R6)+,QUOTIENT
;R0 IS DESTROYED
DIVIDE:	MOV	#1,R0		;QUOTIENT AT LEAST 1

DIVID1:	SUB	4(R6),2(R6)	;SUBTRACT DIVISOR FROM DIVIDEND
	BLE	DIVID2		;DONE?
	INC	R0		;NO.
	BR	DIVID1
DIVID2:	MOV	R0,4(R6)	;QUOTIENT
	MOV	(R6)+,@R6	;R7
	RTS	R7
;
;THE FOLLOWING TABLE IN THE RESIDENT
;LINKER CONTAINS A ONE WORD ENTRY
;FOR EACH OF THE N OVERLAYS. THE
;1ST WORD OF THE TABLE CONTAINS N*2.
;AS NEW OVERLAYS ARE CREATED, ENTRIES
;MUST BE ADDED TO THE END OF THE TABLE.
;WHEN THE LINKER GETS CONTROL AT
;"LNK", IT WILL PLACE THE STARTING
;PHYSICAL BLOCK NUMBER OF EACH OVERLAY
;IN THE RESPECTIVE ENTRY.
;THE SIGN BIT (BIT 15) OF EACH ENTRY WILL
;INDICATE WHETHER OR NOT THE ASSOCIATED
;OVERLAY IS IN CORE:
;	1=RESIDENT
;	0=NOT RESIDENT
;
RUNTAB:	.WORD	RUNEND-RUNTAB	;N*2
	.WORD	0		;OVERLAY #1
	.WORD	0		;OVERLAY #2
	.WORD	0		;OVERLAY #3
	.WORD	0		;OVERLAY #4
	.WORD	0		;OVERLAY #5
	.WORD	0		;OVERLAY #6
	.WORD	0		;OVERLAY #7
	.WORD	0		;OVERLAY #8
RUNEND:	.WORD	0		;OVERLAY #9
;
;SUBROUTINE TO TRANSFER A REQUESTED
;  OVERLAY FROM THE SYSTEM DEVICE TO THE OVERLAY AREA.
;CALLING SEQUENCE:
;		CONTRL
;		.WORD	N	;WHERE N IS
;				;THE OVERLAY NUMBER
;
;IF THE REQUESTED OVERLAY IS ALREADY RESIDENT,
;CONTROL IS RETURNED IMMEDIATELY TO THE CALLER.
;


;
;IF THE REQUESTED OVERLAY IS NOT RESIDENT:
;	1.  IT IS TRAN'D IN (.TRAN, .WAIT)
;	2.  A CHECK IS MADE FOR ERRORS
;	    DURING TRANSFER
;	3.  RUNTAB IS UPDATED TO REFLECT
;	    WHICH OVERLAY IS NOW RESIDENT
;	4.  RETURN TO CALLER
;
;CONTRL:
SUBR46:	SAVREG			;SAVE REGISTERS 0 THRU 5
	MOV	@16(R6),R1	;OVERLAY NUMBER TO R1
	ASL	R1		;ADJUST TO WORD OFFSET
	MOV	#RUNTAB,R2	;BASE OF TABLE
	ADD	R2,R1		;ADDRESS OF REQUESTED ENTRY
	MOV	@R1,OVRTBI	;SET UP TRAN BLOCK
	BLT	CONTR1		;OVERLAY ALREADY IN
	MOV	#OVRTBI,-(R6)	;.TRAN IN
	MOV	#OVRLB,-(R6)	;THE OVERLAY
	EMT	10
;UPDATE RUNTAB
	MOV	(R2)+,R3	;N*2
CONTR3:	SUB	#2,R3
	BLT	CONTR4		;MORE ENTRIES?
	BIC	#100000,(R2)+	;YES, CLEAR IN FLAG
	BR	CONTR3
CONTR4:	BIS	#100000,@R1	;SET NEW IN FLAG
	RESREG			;RESTORE REGISTERS
	MOV	#OVRLB,-(R6)	;WAIT FOR
	EMT	WTCMD		;COMPLETION
;CHECK FOR ERROR ON TRANSFER
	BIT	#140000,OVRIER
	BEQ	CONTR2
;ERROR ON TRANSFER
	MOV	OVRIER,-(R6)	;PUSH STATUS BYTE
	BIC	#377,@R6	;INFO INTO LOW
	SWAB	@R6		;INFO BYTE AND
	MOV	#ERR8,-(R6)	;CLEAR THE REST.
	JMP	ERROUT
CONTR1:	RESREG			;RESTORE REGS. 0 THRU 5
CONTR2:	ADD	#2,@R6		;INCREMENT PAST ARGUMENT
	RTS	R7		;RETURN TO CALLER
	.ENDC

;
;	BEGIN MAIN PROGRAM
;
;

	.CSECT
LNK:
	.IFDF	DEBUG
	JSR	PC,REPORT
	.ENDC
	BR	5$		;COMMAND STRINGS THROUGH CSI
	INCB	FORTRF		;COMMAND STRINGS FROM FORTRAN
	MOV	SP,BEGCS	;SAVE POINTER TO COMMAND STRING
	;
	;	GET BYTE COUNT OF FORTRAN COMMAND STRING
	;
	MOV	SP,R1
	CLR	R0
3$:	MOVB	(R1)+,CHAR
	CMPB	#LF,CHAR
	BEQ	4$
	INCB	R0
	BR	3$
4$:	INCB	R0
	MOV	R0,FORTBC
5$:	CLR	INCMD
	CLR	OBJDEV
	CLR	MAPDEV
	CLR	LODDEV
	CLR	STBDEV
	CLRB	STBOPF
	CLRB	MAPOPF
	CLRB	LODOPF
	MOVB	#377,NOINIT	;INIT OVERLAY DEVICE FLAG
	.IFNDF	NOSEG
	CLR	OVRLB		;FOR ^C BEGIN
	.ENDC
	.IFNDF	OVRBLD		
	START=LNK		;TRANSFER ADDR.
	.ENDC
	.IFDF	NOSEG
START=LNK
	.ENDC
LINK:	TSTB	FORTRF	;CS FROM FORTRAN?
	BEQ	1$		;NO-
	CMPB	FORTRF,#1	;1ST TIME?
	BEQ	2$		;YES-
	.EXIT			;NO-
2$:	INCB	FORTRF		;MARK 1ST TIME
1$:	DEC	OVLC		;LINKING OVERLAY FILES?
	BLT	INIT1		;NO-
	MOV	SSYMB,SP	;YES-SET STACK POINTER
	MOV	SP,SB		;SET STACK BASE
	;
	;	RESET STACK BASE TO NEW VALUE
	;
	MOV	SB,-(SP)	;NEW STACK BASE ON THE STACK
	MOV	#4,-(SP)	;REQUEST CODE
	EMT	GUT		;EMT CALL
	TST	(SP)+		;CLEAN RETURN VALUE FROM STACK
	;
	;
	MOV	SP,SYMB		;    AND RESTORE SAVED
				;    RESIDENT SYMBOL
	MOV	SASYME,-(SP)	;    TABLE POINTERS
	MOV	(SP),SYMC
	MOV	(SP),SYME
	MOV	(SP),USYME
	MOV	@(SP)+,TOPMEM	;SET DEFAULT TOP OF MEM
	MOV	LIMIT,ENDM	;SET END OF FRE