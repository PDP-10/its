
	.LIST	MD,ME
	.NLIST	CND
	.MCALL	$CNFIG
	.MCALL	$GPCT,$GPRQ,$GTQE,$DFREG
	.MCALL	$PUSH,$POP,$ALOCB,$FREEB
	.MCALL	$DISCC,$WAIT,$POST
	$CNFIG
	$DFREG
	$DISCC


	.TITLE	NETDIS SCRL/ARPANET
	.SBTTL  DISPATCHER CONTROL TABLES
	.CSECT
	.GLOBL	$IEXIT,$SVST,$IH
	.GLOBL	$APCT,$IOC,$TCI
	.GLOBL	$RTPIN,$RTPOU,$IMPIN
	.GLOBL	$DUMP
	.GLOBL	$PCTRO,$PCTIH,$LGPCT,$PCTRI,$PCTIM,$LGR
	.GLOBL	$TSET,$TGET	;TIMER WRITE/READ ROUTINES
	.GLOBL	$WDOG1
	.GLOBL	$FTP0		;ENTRY POINT FOR PRINT FTP
	.GLOBL	$ALOLOBL	$ENQ,$DEQ,$FMQE,$SNDAL,$RCFLO
	.GLOBL	$SNFLO,$SNFL1,$SNFL2
	.GLOBL	$N.CON,$N.LSN,$N.CLS,$N.SND,$N.RCV
	.GLOBL	$LSLST,$EXMCH,$SLL,$RLSCT

	.PAGE
	.SBTTL	$N.LSN -- ESTABLISH A LISTENING SOCKET
	.NLIST	ME	;NO MACRO EXPANSIONS PLEASE

;			***  $N.LSN  *** 

;			CAUSE A SOCKET TO BE CREATED
;			IN A LISTENING STATE

;			ASSUMES CCT PTR IN R0

$N.LSN:	BIS	R0,CLFLG	;SET LISTEN FLAG
	MOV	R0,N.CCT	;SAVE CCT ADDRX
	CLRB	CCTCC(R0)	;INIT CONDX CODE TO 0
	MOV	CCTLCL(R0),R0	;GET LOCAL SOCK ID SPECIFIED
	JSR	PC,$EXMCH	;PERFORM EXHAUSTIVE SEARCH FOR SOCK
	BNE	LSNS0		;IF DEFINED, SEE IF PENDING STATE.
	JSR	PC,$SLL		;SEARCH LISTENING SOCKET LIST
	BNE	LSFAIL		;ITS ALREADY LISTENING -- ERROR
	CLR	R1		;INDICATE NO HOSTID
	JSR	PC,$BLDCT	;ALLOC A CT
	MOV	$LSLST,@R2	;PLACE CT ON LISTENING SOCK LIST
	MOV	R2,$LSLST	;SET NEW HEAD OF LIST
	BR	CONSIM		;GO SIMULATE CONNECT

LSNS0:	MOV	N.CCT,R0	;CCT PTR TO R0
	MOV	R1,N.HTE	;SET HTE PTR
	MOV	CTFGN(R2),CCTFGN(R0)	;COPY FOREIGN SOCKET
	MOV	CTFGN+2(R2),CCTFGN+2(R0)  ;INTO CALLER'S CCT
	MOV	(R1),(R0)	;AND COPY HOSTID TOO.
	BR	CONSIM		;SIMULATE CONNECT.
LSFAIL:	MOVB	#WCCIVO,CCTCC(R0)	;SET ERROR COND CODE
LSPOST:	BIS	#RDY+ACK,@$APCT	;POST CALLING PROCESS
	RTS	PC		;AND RETURN


	.SBTTL	$N.CON -- ESTABLISH A CONNECTION (INIT)

;			***  $N.CON  ***

;			ASSUMES CCT PTR IN R0

$N.CON:	CLR	CLFLG		;CLEAR LISTEN FLAG
	TSTB	$DEAD		;HAS HOST/IMP CONN. DIED?
	BNE	CONDED		;YES, NOTIFY CALLING PROCESS
	MOV	R0,N.CCT	;SAVE CCT POINTER
	MOVB	(R0),R0		;GET HOSTID FROM CCT
	BIC	#177400,R0	;CLEAR HIGH BYTE
	JSR	PC,$SHL		;GET HTE POINTER
	BEQ	CONUDH		;UNDEFINED HOST - ERROR
	MOV	R1,N.HTE	;SAVE HTE POINTER
	MOV	N.CCT,R4	;CCT PTR TO R4
	CLRB	CCTCC(R4)	;INITIALIZE CONDITION CODE
	MOV	CCTLCL(R4),R0	;OBTAIN LOCAL SOCK NR
	MOV	CCTFGN(R4),R3	;AND FOREIGN SOCK NR
	MOV	CCTFGN+2(R4),R4	;AND 2ND WORD
	JSR	PC,$MATSK	;MATCH LCL, FGN SOCK ?
	BEQ	CBLD		;NOT FOUND, GO BUILD CT ENTRY
CONSIM:	MOV	R2,N.CT		;SAVE CT POINTER
	MOVB	CTSTAT(R2),R3	;STATUS WORD TO R3
	BIC	#177760,R3	;OBTAIN INDEX
	MOV	N.CCT,R4	;CCT POINTER
	MOV	R4,CTCCT(R2)	;SETUP CCT PTR IN CT
	MOV	$APCT,CTPCT(R2)	;AND PCT POINTER IN CT
	TST	CLFLG		;LISTENING?
	BNE	CLSN		;YUP, PROCESS LISTEN REQUEST
	ASL	R3		;OBTAIN WORD INDEX
	JSR	PC,@CONTB(R3)	;JSR THRU TABLE
	RTS	PC		;RETURN TO CALLER

CONDED:	MOVB	#WCCDED,CCTCC(R0)	;SET 'DEAD IMP' COMPL
	BR	COPOST			;POST COMPL

CBLD:	MOV	N.CCT,R4	;SETUP CCT ADDRX
	MOV	CCTLCL(R4),R0	;SPECIFY LCL SCK
	JSR	PC,$BLDCT	;BUILD CT ENTRY (FIX HOSTLINKS)
	MOV	N.CCT,R4	;OBTAN CCT ADR
	ADD	#CCTBS,R4	;PLUS OFFSET TO BYTE SIZE
	$PUSH	R2		;SAVE CT POINTER
	ADD	#CTBSIZ,R2	;POINT TO BYTE SIZE FIELD OF CT
	MOVB	(R4)+,(R2)+	;STORE BYTE SIZE
	MOV	(R4)+,(R2)+	;LCL SCK
	MOV	(R4)+,(R2)+	;FGN SCK
	MOV	(R4)+,(R2)+	;FGN SCK
	BIT	#1,-(R4)	;IS FGN SCK SEND SCK?
	BEQ	CLCSND		;NOPE, LCL IS SEND
	JSR	PC,$GLINK	;LCL IS RCV, ALLOC A LINK
	BEQ	CLCLE		;NO LINKS AVAIL .. ERROR
CLCSND:	$POP	R2		;CT ADDRX AGAIN
	MOVB	R0,CTLINK(R2)	;SETUP LINK FIELD IN CT
	BR	CONSIM		;GO PROCESS CLOSED CONN

CONUDH:	MOV	N.CCT,R4		;OBTAIN CCT PTR
	MOVB	#WCCUDH,CCTCC(R4)	;SET COMPLETION CODE
COPOST:	BIS	#RDY+ACK,@$APCT		;POST CALLER
	RTS	PC		;AND RETURN TO CALLER

CLCLE:	$POP	R2		;NO LINKS, POP R2 AGAIN
	MOV	N.CCT,R4	;CCT ADDR
	MOVB	#WCCNL,CCTCC(R4)	;SET COMPLETION CODE
	BR	COPOST		;POST CALLER AND RETURN


CLSN:	TST	R3		;ARE WE CLOSED ALREADY?
	BEQ	COLSN0		;YUP, GO TO LISTENING
	CMP	#8.,R3		;PENDING CALL?
	BNE	CLSNE	;NO, INVALID STATE TRANSITION
	MOV	#2,R0		;YES, GO TO RULING
	JSR	PC,$ETCST	;SET STATUS
	MOV	N.CCT,R4	;CCT PTR TO R4
	MOVB	#WCCCMP,CCTCC(R4)	;AND POST HIM COMPLETE
	BR	COPOST		;POST PROCESS TO RCV CONTROL
COLSN0:	MOV	#1,R0		;GO TO LISTENING STATE
	JSR	PC,$ETCST	;SET STATUS
	RTS	PC		;AND RETURN
CLSNE:	JMP	CONERR		;STATE TRANSITION ERROR


;			***  CONNECT  ***
;			***  BRANCH   ***
;			***  TABLE    ***

CONTB:	.WORD	CONCON,CONERR,CONOPN
	.WORD	CONERR,CONERR,CONERR
	.WORD	CONERR,CONERR
	.WORD	CONTST


;			STATE PROCESSORS FOR CONNECT (INIT)

CONCON:	JSR	PC,$ICT		;INIT CT
	MOV	#7,R0		;GO TO ST 7 (CONNECT)
CONCO2:	JSR	PC,$ETCST	;SET STATUS
	MOV	(PC),R0		;R0 IS NON-ZERO, SEND RFC
	JSR	PC,$RFCLS	;TO FOREIGN HOST
	RTS	PC		;AND RETURN

;			***  CT WAS IN 'RULING' STATE ***

;			CALLER ACCEPTS FOREIGN
;			RFC BY ISSUING $N.CON


CONOPN:	MOV	CTLCL(R2),R0	;FETCH LOCAL SOCK FROM CT
	ROR	R0		;IS IT SEND OR RECV?
	BCS	RFOSND		;BRCH IF SEND SOCK.
	JSR	PC,$GLINK	;GET A LINK
	BEQ	RFONL0		;NO LINKS, ABORT.
	MOV	N.CT,R2		;RELOAD CT POINTER
	MOVB	R0,CTLINK(R2)	;SAVE LINK IN CT
RFOACC:	MOV	N.CCT,R0	;FETCH CCT ADDR
RFOAC2:	MOVB	#WCCCMP,CCTCC(R0)	;IMMEDIATE SATISFACTION
	BIS	#RDY+ACK,@$APCT	;POST CALLER
	MOV	#6,R0		;TO STATE 6 (OPEN)
	BR	CONCO2		;RETURN AN RFC

RFONL0:	MOV	N.CCT,R0	;CCT ADDR, PLEASE
	MOVB	#WCCNL,CCTCC(R0) ;SET 'NO LINKS' COMP CODE
	MOV	N.CT,R2		;AND GET CT PTR
	MOV	#3,R0		;GO TO CLOSE-WAIT
	JSR	PC,$ETCST	;SET CONNECTION STATE
	CLR	R0		;SEND A CLS TO CALLER
	JSR	PC,$RFCLS	;AND REJECT CONNECTION
	BR	COPOST		;POST IN ERROR

RFOSND:	MOV	N.CCT,R0	;CCT POINTER
	MOVB	CCTBS(R0),CTBSIZ(R2)	;CT BYTE SIZE SETUP
	BR	RFOAC2		;CONTINUE



;			***  CT WAS IN 'PENDING' STATE ***

;			CHECK TO SEE IF LINK EXISTS
;			AND ALLOC ONE IF NECC.
;			IF FGN SCKS DONT CMPR, TRANSIT
;			TO 'CONNECT' STATE
;			AND SEND A CLS TO FGN SITE
;			IF FGN SCK DOES COMPARE, TRANSIT
;			TO 'OPEN' STATE.

CONTST:	BIT	#1,CTLCL(R2)	;IS LCL RECEIVE SCK?
	BNE	CNBYT		;NO, SETUP BYTESIZE
	TSTB	CTLINK(R2)	;HAS LINK BEEN ALLOCATED?
	BNE	CONC3		;OK, DONT ALLOC ONE
	$PUSH	R2		;SAVE CT POINTER
	JSR	PC,$GLINK	;GET A FREE LINK
	BEQ	CLCLE		;TO UPPER LEVEL WITH ERROR
	$POP	R2		;RESTORE CT POINTER
	MOVB	R0,CTLINK(R2)	;LINK TO CT
	MOV	N.CCT,R4	;GET CCT POINTER
CONC3:	CMP	CCTFGN(R4),CTFGN(R2)	;CMPR FGN SCKS
	BNE	CONCRJ		;IF NO CMPR, REJECT FGN CONN.
	CMP	CCTFGN+2(R4),CTFGN+2(R2)
	BNE	CONCRJ
	BR	RFOACC		;GO TO 'OPEN' STATE

CNBYT:	MOV	N.CCT,R4	;GET CCT POINTER
	MOVB	CCTBS(R4),CTBSIZ(R2)
	BR	CONC3		;BACK TO CHECK FGN SCK

;			***  CONCRJ  ***

;			SENDS A CLS TO FGN SITE
;			AND ENTERS 'CONNECT' STATE

CONCRJ:	BR	CONCON		;(TEMP) TO 'CONNECT' STATE


CONERR:	MOVB	#WCCIVO,CCTCC(R4)	;SET INVALID OPERATION
	BR	CLPOST		;POST CALLER AND RETURN


;			***  $N.CLS  ***

;			CLOSE AN ESTABLISHED CONNECTION
;			OR A LISTENING SOCKET
;			OR REJECT AN ATTEMPT TO CONNECT

$N.CLS:	$PUSH	R0		;SAVE CCT POINTER
	CLRB	CCTCC(R0)	;INIT CONDX CODE
	MOV	CCTLCL(R0),R0	;GET CONDITION CODE
	JSR	PC,$SLL		;SEARCH FOR LISTENER
	BNE	CLSN00	;YUP, HE'S LISTENING
	MOV	@SP,R0		;FETCH CCT PTR AGAIN
	MOV	(R0),R0		;GET HOSTID
	JSR	PC,$SHL		;SEARCH HOSTLIST
	BEQ	CLSUDH		;UNDEFINED HOST
	MOV	R1,N.HTE	;SAVE HTBL ADDRX
	MOV	@SP,R0		;CCT AGAIN
	MOV	CCTFGN(R0),R3	;PERFORM MATCH
	MOV	CCTFGN+2(R0),R4	;OF LOCAL, FGN SOCKS
	MOV	CCTLCL(R0),R0	;GET LCL SCK
	JSR	PC,$MATSK	;MATCH?
	BEQ	CLSERR		;CANT CLOSE UNKNOWN SOCK PAIR
	MOV	R2,N.CT		;SAVE CONN TBL ADDRESS
        MOV     $APCT,CTPCT(R2)    ;UPDATE PROCESS ID
	MOVB	CTSTAT(R2),R3	;FETCH CONNECTION STATUS
	BIC	#177760,R3	;BYTE OFFSET
	$POP	R4		;GET CCT PTR
	ASL	R3		;WORD OFFSET TO TBL
	JSR	PC,@CLSTBL(R3)	;JSR THRU CLS STATE TBL
	RTS	PC		;AND RETURN
CLSUDH:	$POP	R0		;POP OFF R0
	JMP	CONUDH		;AND BEHAVE LIKE CONNECT ERROR

CLSN00:	MOV	(R2),(R3)	;CLOSE LISTENING SOCKET
	CLRB	CTSTAT(R2)	;DELETE FROM LISTEN LIST
	MOV	(SP)+,R0	;OBTAIN CCT AGAIN
	MOVB	#WCCCMP,CCTCC(R0)	;SET CCT COND CODE
	JSR	PC,$RLSCT	;RELEASE CT
CLPOST:	BIS	#RDY+ACK,@$APCT	;POST CALLER
	RTS	PC		;AND RETURN


;			***  CLOSE  ***
;			*** BRANCH  ***
;			***  TABLE  ***
CLSTBL:	.WORD	CLSER1	;ERROR (IT WAS CLOSED)
	.WORD	CLSLSN		;STOP LISTENING (RETRACT LISTEN)
	.WORD	CLSWT		;TO STATE 3 (WERE RULING)
	.WORD	CLSER2,CLSER2,CLSDRN
	.WORD	CLSTST		;IF SEND TO ST4, IF RCV TO ST3
	.WORD	CLSWT
	.WORD	CLSER1


CLSERR:	$POP	R4
CLSER1:	MOVB	#WCCNXC,CCTCC(R4)	;SET NON-EXISTENT CONNECTION
	BR	CLPOST		;TO ERROR PROCESSOR

CLSER2:	MOVB	#WCCWCL,CCTCC(R4)	;WAITING TO CLOSE
	BR	CLPOST

CLSLSN:	CLR	R0		;SEND CLS
	JSR	PC,$ETCST	;SET STATE 0
	MOVB	#WCCCMP,CCTCC(R4)	;COMPLETE
	BR	CLPOST

CLSWT:	CLR	R0		;INDICATE CLS
	$PUSH	R2,R4		;SAVE CT, CCT
	JSR	PC,$RFCLS		;SEND CLS
	$POP	R4,R2		;RSTORE CCT, CT
	CLRB	CCTCC(R4)	;CLEAR CONDITION CODE
	MOV	#3,R0		;GO TO STATE 3
	JSR	PC,$ETCST	;(CLOSE-WAIT)
	RTS	PC

CLSTST:	BIT	#1,CTLCL(R2)	;IS LCL SOCK SEND SCK?
	BNE	CLSDWD		;YES, GO TO DATA-WAIT
CLSPUS:	$PUSH	R2,R4		;SAVE CT,CCT
	CLR	R0		;SEND A CLS
	JSR	PC,$RFCLS
	$POP	R4,R2
	MOV	#3,R0		;TO STATE 3
	JSR	PC,$ETCST
	CLRB	CCTCC(R4)	;CLEAR CC
	RTS	PC

CLSDWD:	TST	CTBCI(R2)	;IS THERE DATA STILL TO BE SENT??
	BEQ	CLSPUS		;NO, GO AHEAD AND SND CLS
	MOV	#4,R0		;TO DATA WAIT
	CLRB	CCTCC(R4)
	JSR	PC,$ETCST
	RTS	PC

;				 CLOSE OP IN DRAIN-WAIT
CLSDRN:	$PUSH	R2,R4		;SAVE CT, CCT POINTERS
	CLR	R0		;SET OP-CODE CLS FOR $RFCLS
	JSR	PC,$RFCLS	;ISSUE CLS
	$POP	R4,R2		;RESTORE CCT, CT
	CLRB	CTSTAT(R2)		;TRANSIT TO CLOSED STATE (0)
	MOVB	#WCCCMP,CCTCC(R4)	;SET COMPL CODE
	BR	CLPOST		;BRANCH TO POST CALLER


	.SBTTL	$N.RCV -- RECEIVE BITS ON A CONNECTION

;			***  $N.RCV  ***

;			ASSUMES
;			R0 = CCT PTR
;			R3 = BIT COUNT
;			R4 = BUFFER ADDRESS

$N.RCV:	$PUSH	R3,R4
	JSR	PC,RSINIT		;INIT RCV/SND
	TSTB	CCTCC(R0)	;HAS HE HAD AN ERROR?
	BMI	RSPOP		;YUP, CLEAN STACK AND RETURN
	CMPB	R3,#5		;IN DRAIN-WAIT?
	BEQ	RCVS5		;YES, ALLOW RECEIVE
;				 ONLY IF MORE TO BE GOTTEN.
	CMPB	R3,#6		;OPEN?
	BNE	RSIV		;IF NOT, INVALID OPERATION
RCVC1:	$POP	CTADO(R2),CTBCO(R2)	;POP ADDRX, BIT CNT
	JSR	PC,$RCFLO		;AND INIT FLOW CONTROL
	RTS	PC		;THATS IT.
RSIV:	MOVB	#WCCIVO,CCTCC(R0)
RSPOP:
RCVPS2:	CMP	(SP)+,(SP)+	;  CLEAN STACK
RCVPST:	BIS	#RDY+ACK,@$APCT	;AND POST CALLER
	RTS	PC		;RETURN

;				WE'RE IN STATE 5...SEE IF
;				MORE DATA IS AVAILABLE.

RCVS5:	TST	CTBCI(R2)	;CHECK FLOW PARAMETERS ON CONNX
	BNE	RCVC1		;SOME MORE AVAIL
	TST	CTQ(R2)		;ANOTHER QUEUE EL. TO BE GOTTEN?
	BNE	RCVC1		;YES, ALLOW RECEIVER TO GET IT
;				 ELSE TELL RECEIVER CONNX CLOSED.

SCLSD:	MOVB	#WCCCLS,CCTCC(R0)	;SET CONNECTION CLOSED
	BR	RCVPS2		;CLEAN STACK AND RETURN

	.SBTTL	$N.SND -- SEND BITS ON A CONNECTION
$N.SND:	$PUSH	R3,R4		;SAVE BIT CNT, ADDR
	JSR	PC,RSINIT	;INIT RCV/SND
	TSTB	CCTCC(R0)
	BMI	RSPOP
	CMPB	R3,#6		;IS CONN OPEN?
	BEQ	S.GO		;OK, ITS VALID
	CMPB	R3,#5		;ARE WE IN DRAIN-WAIT?
	BGT	RSIV		;IF NOT, INVALID OP
	TST	R3		;IS IT CLOSED?
	BEQ	SCLSD		;SET CLOSED FLAG
	CMP	R3,#3		;ELSE, IS IT IN PENDING CLOSE COND.
	BGE	SCLSD		;YES, TELL CALLER ITS CLOSED.
S.GO:	$POP	CTADI(R2),CTBCI(R2)	;INIT ADDRX, BIT COUNT
	JSR	PC,$SNFLO	;INIT FLOW CONTROL
	RTS	PC		;AND RETURN

	.SBTTL	$N.CNT -- OBTAIN REMAINING BITS FOR RECEIVE
$N.CNT:	JSR	PC,RSINIT	;FIND SOCKETS
	TSTB	CCTCC(R0)	;CHECK FOR ERRORS
	BMI	NCNTRS		;BRCH IF UNSUCCESSFUL
	MOV	CTBCO(R2),R3	;GET REMAINING BIT CNT
	CLR	CTBCO(R2)	;AND FLUSH THE REST
NCNTRS:	RTS	PC		;RETURN TO CALLER


RSINIT:	MOV	R0,N.CCT	;SAVE CCT ADDRESS
	$PUSH	R0		;SAVE CCT ADDR
	CLRB	CCTCC(R0)	;INIT CONDITION CODE
	MOV	(R0),R0		;OBTAIN HOSTID
	JSR	PC,$SHL		;ERROR - NONEXISTENT HOST
	BEQ	RCVNXH		;NONEXISTENT
	MOV	R1,N.HTE	;SAVE HTE ADDRESS
	MOV	@SP,R0		;OBTAIN CCT ADRESS AGAIN
	MOV	CCTFGN+2(R0),R4	;FGN SCK
	MOV	CCTFGN(R0),R3
	MOV	CCTLCL(R0),R0		;LCL SCK
	JSR	PC,$MATSK	;FIND MATCHING PAIR
	BEQ	RCVNXS		;NON-EXISTENT SOCKETS
        MOV     $APCT,CTPCT(R2) ;UPDATE CURRENT PROCESS
	MOVB	CTSTAT(R2),R3	;SEE IF OPEN
	BIC	#177760,R3	;TRIM BITS
	MOV	R2,N.CT		;SAVE CT ADDRESS
	$POP	R0		;RECOVER CCT ADDR
	RTS	PC		;RETURN

RCVNXS:	$POP	R0		;RECOVER CCT
	MOVB	#WCCNXC,CCTCC(R0) ;INDICATE NONEXIST. CONN
	BR	RCVPST		;GO POST CALLER
RCVNXH:	$POP	R0		;RECOVER CCT ADDR
	MOVB	#WCCUDH,CCTCC(R0)	;SET UNDEFINED HOST
	BR	RCVPST		;POST CALLER




	.SBTTL	$RCFLO -- RCV CONN FLOW CONTROL

;			***  $RCFLO  ***

;			ASSUMES R2 = CT PTR
ALLEAD = 2			;NR MSGS LEAD ON CONNECTION
ALTHRS = 2		;MIN MSGCT TO BE REACHED
			;BEFORE AN ALLOCATE MSG
			;WILL BE TRANSMITTED ON
			;A RECEIVE CONNECTION.

$RCFLO:	$PUSH	R2		;SAVE CT PTR
RCFL2:	TST	CTBCI(R2)	;BITS REMAINING IN
	BEQ	RCGETQ		;NONE, GET A MSG FM QUEUE
RCFL3:	TST	CTBCO(R2)	;BITS REMAINING OUT
	BEQ	RCDON		;IF 0, CANT DO ANY MORE NOW
	MOV	CTBCI(R2),R0	;COMPUTE NR BITS TO MOVE
	CMP	R0,CTBCO(R2)	;CMPR INP BITS TO OUT BITS
	BLE	RC000
	MOV	CTBCO(R2),R0	;GET MIN OF BCI, BCO
RC000:	JSR	PC,MBITS	;MOVE BITS TO RECEIVER
;				POST RECEIVER NOW
	MOV	CTCCT(R2),R3	;GET HIS CCT ADDRESS
	MOVB	#WCCCMP,CCTCC(R3)	;SET CONDITION CODE
	$POST	CTPCT(R2),#RDY+ACK	;POST WAITING PROCESS
RCVX:	MOV	@SP,R2		;RESTORE CT PTR
	BR	RCFL2		;AND CHECK AGAIN BIT CNTS

RCGETQ:	MOV	CTMQP(R2),R4	;WAS THERE A PREV MSG?
	BEQ	RCGET1		;NOPE
	$PUSH	R4		;SAVE MQE PTR
	MOV	-(R4),R1	;SETUP TO FREE BUFFER
	MOV	-(R4),R0	;SETUP POOLID
	$FREEB			;FREE THE BUFFER
	$POP	R4
	JSR	PC,$FMQE	;IF SO, FREE IT
	MOV	@SP,R2		;SETUP R2 AGAIN
	CLR	CTMQP(R2)	;ERASE MSG QUEUE PTR
;			TRY TO GET A MSG FM QUEUE
RCGET1:	ADD	#CTQ,R2		;POINT R2 TO QUEUE HEAD
	JSR	PC,$DEQ		;FETCH AN ENTRY FROM QUEUE
	BEQ	RCDON		;NO QUEUE ELS LEFT
	MOV	@SP,R2		;RESTORE CT PTR
	MOV	R0,CTMQP(R2)	;SAVE MQE ADDRESS
	DEC	CTMCT(R2)	;DECREMENT MESSAGE COUNT
	MOV	-(R0),R1	;MOVE BUFFER ADDRESS
	$PUSH	R1		;AND SAVE IT
	ADD	#4,R1		;ADVANCE TO HOST-HOST INFO IN MESSAGE
	.IF EQ	PEAE!PMDV	;NEITHER EAE NOR MDV
	MOV	(R1)+,$MQ	;BYTE SIZE TO MQ
	MOV	(R1)+,$XMUL	;COUNT TO SOFT MULTIPLIER
	JSR	PC,$MUL		;MULTIPLY TO GET NR BITS IN
	MOV	$MQ,R4		;NR BITS TO REG 4
	ADD	R4,CTBCI(R2)	;SET NEW BIT COUNT IN INPUT CT
	.ENDC
	.IF EQ	PEAE-1
	MOV	(R1)+,@#MQ	;SET BYTE SIZE IN MQ
	MOV	(R1)+,@#XMPY	;MPY BYTE SIZE BY COUNT
	MOV	@#MQ,R4		;GET AMOUNT TO DEC BIT ALLOCATION
	ADD	R4,CTBCI(R2)	;UPDATE BIT COUNT IN INPUT CT
	.ENDC
	.IF EQ	P1140!P1145&PMDV-1
	MOV	(R1)+,R3	;COMPUTE INPUT NR BITS
	MUL	(R1)+,R3	;IN R3
	ADD	R3,CTBCI(R2)	;UPDATE BIT COUNT INPUT
	MOV	R3,R4		;SETUP FOR DECR ALLOCATION
	.ENDC
	CLR	R3
	$PUSH	R4		;SAVE AMOUNT TO DECR ALLOCATION
	JSR	PC,$DECAL	;DECREASE BIT ALLOCATION
	$POP	R3		;RELOAD BIT COUNT
	CLR	R4
	MOV	#4.,R0		;OBTAIN TALLY
	ASR	R3		;DIV BY 16.
	ROR	R4
	DEC	R0		;TALLY AND SHIFT RIGHT DOUBLE
	BGT	.-6
	TST	R4		;TEST REMAINDER
	BEQ	.+4		;DONT INC IF NO REM
	INC	R3		;INCREMENT REM COUNT
	SWAB	(R1)+		;SWAP BYTES IN MSG
	DEC	R3		;AND LOOP THRU
	BGE	.-4		;SO WE CAN CORRECTLY ADDRESS IT

	$POP	R1		;RESTORE BUFFER POINTER
	ADD	#11,R1		;OFFSET TO BEGIN TEXT
	MOV	R1,CTADI(R2)	;SETUP ADDRX INPUT
	BR	RCFL2		;CHECK FLOW PARAMETERS


;			RCDON -- CHECK TO SEE IF
;			IT IS NECCESSARY TO SEND
;			AN ALLOCATE 'ALL' MESSAGE
;			TO FOREIGN HOST.


RCDON:	MOV	@SP,R2		;SET UP CT POINTER
	MOV	#ALTHRS,R0	;SET THRSH NR MSGS FOR ALL
	SUB	CTMCT(R2),R0	;ARE WE DEFICIENT IN MSG CNT?
	BLE	RCNALL		;NONE, DONT SEND ALL
	MOV	#77,R3		;ENSURE BIG BITCOUNT
	MOV	#177777,R4	;BUT NOT TOO BIG
	SUB	CTBCT+2(R2),R4	;DONT TAKE ANY CHANCES ON
	SBC	R3		;OVERFLOWING AT FGN SITE
	SUB	CTBCT(R2),R3
	ADD	#ALLEAD,R0	;INCLUDE LEAD VALUE FOR ALLS
	JSR	PC,$SNDAL	;SEND AN ALLOCATE TO FGN HOST
RCNALL:	$POP	R2		;NOW WAIT FOR EITHER A
	RTS	PC		;RECEIVE OP OR A MESSAGE


SDMBS = 9.		;MESSAGE BASE
SDESIZ = 6.		;DEFAULT SIZE, WORDS
SDEBCT = 7800.		;MAX BITS TO BE SENT.

;				 TO BE TRANSMITTED (BITS)

	.SBTTL	$SNFLO -- SEND FLOW CONTROL

$SNFLO:	BITB	#100,CTSTAT(R2)	;IN-USE?
	BNE	SNRTS		;YES, SIMPLY RETURN
	BISB	#100,CTSTAT(R2)	;RETURN
	BITB	#60,CTSTAT(R2)	;ARE WE IN STATE 0 ?
	BNE	SNRTRN		;NO, RETURN AND CLR IN-USE
SNOK0:	TST	CTBCT(R2)	;DO WE HAVE BIT COUNT ALLOC?
	BNE	SNOK1		;YEAH, AND ITS BIG TOO.
	CMP	#8.,CTBCT+2(R2)	;FORCE US TO HAVE AT LEAST 8
	BGT	SNJST1		;IF NOT, TO STATE 1
SNOK1:	MOV	CTBCI(R2),R0	;OUTPUT DESIRED COUNT (FROM USER)
	CMP	R0,CTBCO(R2)	;GET MIN
	BLE	SNOK2		;IS IT?
	MOV	CTBCO(R2),R0	;GET NEW MIN
SNOK2:	TST	CTBCT(R2)
	BNE	SNOK3
	CMP	R0,CTBCT+2(R2)	;IS ALLOC MIN. ?
	BLOS	SNOK3		;NO
	MOV	CTBCT+2(R2),R0	;GOT MIN
SNOK3:	$PUSH	R0		;SAVE LENGTH TO MOVE
	JSR	PC,MBITS	;MOVE IT
	$POP	R4		;RESTORE
	CLR	R3		;DECREASE BIT-SPACE ALLOCATION
	JSR	PC,$DECAL	;DOUBLE SUBTRACT
	TST	CTBCI(R2)	;SENT EVERYTHING?
	BNE	SNOK4		;NOPE

;				 DON'T POST CALLER
;				 IF HE'S ISSUED A CLOSE
;				 OP

	MOVB	CTSTAT(R2),R3	;SEE IF IN STATE 4
	BIC	#177760,R3	;(RFNM-WAIT)
	CMPB	R3,#4		;STATE 4?
	BEQ	SNRSN		;DON'T POST
	$PUSH	R2		;POST CALLER
	MOV	CTCCT(R2),R3
	MOVB	#WCCCMP,CCTCC(R3)	;SET CC IN CCT
	$POST	CTPCT(R2),#RDY+ACK	;POST HIM
	$POP	R2		;RESTORE CT POINTER
SNRSN:

SNOK4:	TST	CTMQP(R2)	;MESSAGE DEFINED?
	BNE	SNOK6		;YES, SEND ALL WE CAN
	$PUSH	R2		;SAVE CT POINTER
SNOK11:	MOV	#1,R0		;GET POOLID
	JSR	PC,$ALOCW	;GET A BUFFER
	MOV	#SDESIZ,R2	;GET DEFAULT BUFF SIZ, WORDS
	JSR	PC,$MQFMT	;GET MQE
	$POP	R2		;RESTORE CT
	MOV	R4,CTMQP(R2)	;MQP POINTER
	ADD	#SDMBS,R1	;OFFSET TO FIRST BYTE MSG
	MOV	R1,CTADO(R2)	;SETUP OUTPUT BUFFER ADDR
	MOV	#SDEBCT,CTBCO(R2)	;GET DEFAULT BIT COUNT
	TST	CTBCI(R2)	;SEE IF WE'VE SENT ALL
	BNE	SNOK0		;NO, CYCLE THRU AGAIN.
	BICB	#60,CTSTAT(R2)	;CLEAR STATUS: TO ST 0
	MOVB	CTSTAT(R2),R3	;SEE IF WE'RE IN STATE 4
	BIC	#177760,R3	;TRIM ALL BUT INTERESTING BITS
	CMP	R3,#4		;STATE 4 (RFNM-WAIT) ?
	BNE	SNRTRN		;BRANCH DOWN TO PROCESS
	MOVB	#3,CTSTAT(R2)	;TRANSIT TO STATE 3 (CLS WAIT)
	CLR	R0		;INDICATE CLS OP
	$PUSH	R2		;SAVE CT PTR
	JSR	PC,$RFCLS	;SEND CLS
	$POP	R2		;RESTORE CT PTR
SNRTRN:	BICB	#100,CTSTAT(R2)	;CLEAR IN-USE FLAG
SNRTS:	RTS	PC		;AND RETURN...

SNJST1:	JMP	SNST1		;JUMP THRU TO ST1


SNOK6:	TST	CTMQA(R2)	;RFNM-AWAITED?
	BNE	SNOK7		;YES, WAIT
SNOK8:	TST	CTMCT(R2)	;MSG SPACE ALLOC?
	BEQ	SNOK10	;NO, WAIT.
	DEC	CTMCT(R2)	;UPDATE MSG COUNT
	MOV	CTMQP(R2),R4	;GET MSG QUEUE PTR
	MOV	-(R4),R1	;BUFFER ADDRESS

;		*** FORMAT THE OUT-GOING MESSAGE ***

	MOV	@CTHTA(R2),(R1)+	;HOSTID
	CLRB	(R1)+
	MOVB	CTLINK(R2),(R1)+	;LINK
	MOVB	CTBSIZ(R2),(R1)+	;BYTE-SIZE
	CLRB	(R1)+		;M1
	MOV	#SDEBCT,R0	;DEFAULT BIT COUNT
	SUB	CTBCO(R2),R0	;AMT LEFT IN BUF
	MOVB	CTBSIZ(R2),R3	;OBTAIN CONN BYTE SIZE
	.IF EQ	PEAE!PMDV	;NEITHER EAE NOR MULDIV?
	MOV	R0,$MQ		;SET SOFT MQ REGISTER
	CLR	$AC		;INIT AC
	MOV	R3,$XDVSR	;SET DIVISOR
	JSR	PC,$DIV		;DIVIDE TO OBTAIN BYTE COUNT
	MOV	$MQ,(R1)+	;MOVE IT TO OUTGOING MESSAGE
	.ENDC
	.IF EQ	PEAE-1		;EAE DEFINED?
	MOV	R0,@#MQ		;SET DIVIDEND
	CLR	@#AC		;CLEAR HIGH 16 BITS DIVIDEND
	MOV	R3,@#XDVSR	;DIVIDE BY BYTE SIZE
	MOV	@#MQ,(R1)+	;MOVE NUMBER BYTES TO OUTGOING MESSAGE
	.ENDC
	.IF EQ	PMDV-1		;MULDIV?
	$PUSH	R0,R1		;SAVE COUNT, BUFF POINTER
	MOV	R0,R1
	CLR	R0
	DIV	R3,R0		;DIVIDE TO GET NR BYTES
	$POP	R1		;AREN'T INTERESTED IN REM
	MOV	R0,(R1)+	;PLACE NR BYTES IN MESSAGE
	$POP	R0
	.ENDC
	CLRB	(R1)		;M2

;			GET NR WORDS OF DATA

	ASR	R0
	ASR	R0
	ASR	R0
	ASR	R0
	INC	R0		;ADD 1
	$PUSH	R0		;SAVE NR WORDS
SNOK9:	SWAB	(R1)+		;SWAB MESSAGE
	DEC	R0
	BGT	SNOK9		;SWAB WHOLE THING
	$POP	R0		;RECOVER NR WRDS
	ADD	#5,R0		;GET NR WORDS TO BE SENT
	MOV	R0,-4(R4)	;MOVE INTO MQE
	MOV	CTMQP(R2),R0	;MSG QUEUE PTR
	MOV	CTHTA(R2),R1	;SETUP FOR HHENQ
	$PUSH	R2		;SAVE CT POINTER
	JSR	PC,$HHENQ	;TO IMP...
	JMP	SNOK11

SNOK7:	TST	CTBCO(R2)	;IS OUTPUT BUF FULL?
	BEQ	SNOK8		;YES, SEND MSG ANYWAY.
	BISB	#60,CTSTAT(R2)	;GO TO STATE 3 (RFNM-AWAITED)
SNOK12:	JMP	SNRTRN

SNOK10:	BICB	#60,CTSTAT(R2)	;TO STATE 2
	BISB	#40,CTSTAT(R2)
	BR	SNOK12

SNST1:	BICB	#60,CTSTAT(R2)	;TO STATE 1
	BISB	#20,CTSTAT(R2)
	BR	SNOK12


$SNFL1:	BITB	#100,CTSTAT(R2)
	BNE	SNOK13		;IN USE?
	JSR	PC,SNST00	;GET CURRENT STATE
	CMP	#2,R0		;ARE WE IN 2?
	BEQ	SNOK8
	CMP	#1,R0		;1?
	BNE	SNOK12
	JMP	SNOK0


$SNFL2:	BITB	#100,CTSTAT(R2)	;IN-USE?
	BNE	SNOK13
	JSR	PC,SNST00
	CMP	#3,R0
	BEQ	SNOK6
	BR	SNOK12

SNOK13:	RTS	PC
SNST00:	MOVB	CTSTAT(R2),R0
	BISB	#100,CTSTAT(R2)	;SET IN-USE
	BIC	#177717,R0	;CLEAR EXTRANEOUS BITS
	ASR	R0
	ASR	R0
	ASR	R0
	ASR	R0
	RTS	PC		;RETURN W/ STATE ID IN R0






MBITS:		;NR BITS TO MOVE ASSUMED IN R0
MBIT0:	TST	R0		;IS MIN L.E. 0
	BLE	MBITR		;YUP, CANT DO ANYTHING
	SUB	R0,CTBCI(R2)	;UPDATE BIT CNT IN
 	SUB	R0,CTBCO(R2)	;UPDATE BIT CNT OUT

;				TEMPORARILY REQUIRE
;				BYTE SIZES TO BE
;				MULTIPLES OF 8

	ASR	R0
	ASR	R0
	ASR	R0

	MOV	CTADI(R2),R3	;MOVE ADDRESS IN
	MOV	CTADO(R2),R4	;ADDRESS OUT
MBIT1:	MOVB	(R3)+,(R4)+	;MOVE THE BYTES
	DEC	R0		;AND TALLY
	BGT	MBIT1		;FOR ALL OF THEM
	MOV	R3,CTADI(R2)	;UPDATE ADDRESSES
	MOV	R4,CTADO(R2)	;IN AND OUT
MBITR:	RTS	PC		;AND RETURN




CLFLG:	.WORD	0		;FLAG TO INDICATE LISTEN REQUEST
N.CCT:	.WORD	0		;FOR STORING CCT POINTER
N.CT:	.WORD	0		;CT POINTER
N.HTE:	.WORD	0		;HTE POINTER


	.END



                                                                                                                                                 