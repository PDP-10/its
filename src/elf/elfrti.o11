	.MCALL	$CNFIG
	.MCALL	$NETHW,$DFREG,$DISCC
	.MCALL	$PUSH,$POP
	.MCALL	$STIME,$WAIT,$POST,$ALOCB
	.LIST	ME
	.NLIST	CND
	$CNFIG
	$DFREG
	$DISCC
	$NETHW

	.TITLE	NETRTI -- IMP INPUT PROCESSOR
	.SBTTL	RELIABLE TRANSMISSION PACKAGE GLOBLS 
	.GLOBL	$APCT,$IEXIT,$SVST
	.GLOBL	$RTOIU,$RTPIN,$IMPIN,$DEAD,$OEIN,$OEOUT,$IHBIT
	.GLOBL	$PCTRO,$PCTIM,$PCTIH,$CHNLO,$CHNLI,$DEBUG
	.GLOBL	$IHQ,$GFMQE,$ENQ
	.GLOBL	$PCTRI		;PCT FOR RTP INPUT
	.GLOBL	$MS00,$MS01	;MEASUREMENT GLOBLS
	.GLOBL	$MS02,$MS03,$MS04,$MS05,$MS06
	.GLOBL	$VDHCT,$VDHFL
	.PAGE
	.SBTTL	NETWORK INTERFACE INITIALIZATION PROCEDURE

;			---------

;			THIS PROCEDURE  INITIALIZES THE
;			VERY-DISTANT HOST STYLE INTERFACE
;			TO THE ARPA NETWORK, AND INITIALIZES
;			THE RELIABLE TRANSMISSION PACKAGE.

;			---------


$IMPIN:	MOV	#VDIVI,R0	;SET ADDRESS OF VDH INPUT VEC
	MOV	#340,R1		;SET PROC STAT 7
	MOV	#VIII,(R0)+	;ADDRX OF INPUT INTERRUPT PROCESSOR
	MOV	R1,(R0)+	;SET PS
	MOV	#VIOI,(R0)+	;SET OUTPUT INT VEC
	MOV	R1,(R0)+	;SET OUTPUT INT VEC PS
	MOVB	#1,$DEAD	;INIT DEAD LINE CONDITION
	RTS	PC		;AND RETURN

	.PAGE
	.SBTTL	RTP - INPUT PROCESSOR

;			----------

;			THE RELIABLE TRANSMISSION PACKAGE
;			PERFORMS ACKNOWLEDGEMENT AND
;			RETRANSMISSION FUNCTIONS FOR
;			RELIABLE COMMUNICATION VIA AN IMP
;			MODEM.   REFER TO BBN RPT #1822.

;			THE FOLLOWING CODE PROCESSES INCOMING
;			PACKETS FROM THE IMP.

;			----------


MAXMGL = 508.			;MAXIMUM MESSAGE LENGTH
RTNCH = 2			;SETUP FOR 2-CHANNEL RTP
RTNMSK = 37400			;MASK TO OBTAIN WORD COUNT

RT1:	JSR	PC,RTID		;RE-INITIALIZE INPUT DEVICE
	BR	RT3		;WAIT FOR IO OR TIMER

$RTPIN:	MOVB	#1,$DEAD		;GO TO DEAD STATUS
	MOV	#-4,$VDHCT		;INIT VDH COUNTER
	$POST	#$PCTRO+2,#RDY+ACK	;POST OUTPUT SIDE
RT0:	$STIME	5000.		;SET TIME TO 15 SECS.
	CLR	R0		;RE-INITIALIZE RTP
CLP1:	CLRB	$RTOIU(R0)	;CLEAR OUTPUT IN-USE FLGS
	INC	R0
	CMP	R0,#RTNCH	;NR CHNLLS?
	BLT	CLP1
	CLR	$OEIN		;CLEAR $OEIN, $OEOUT
	CLR	$CHNLI		;INIT INPUT CHNL NR
	CLR	$CHNLO		;INIT OUTPUT CHNL NR

RT2:	$WAIT			;WAIT FOR TIMER
	BIT	#TIM,-(R4)	;DID IT GO OFF
	BEQ	RT2		;NO, BACK WE GO
	$POST	#$PCTRO+2,#RDY+ACK+TIM
	COMB	$DEAD		;INDICATE COMING UP
	JSR	PC,RTID2	;INIIALIZE INPUT DEVS.
RT3:	$WAIT			;AND WAIT FOR EITHER INPUT OR TIMER
	BIT	#IO,-(R4)	;HOW ABOUT IO INTS?
	BEQ	RT3		;NO, NONE OF THOSE..
	JSR	PC,RTDDV	;WELL, WHODONNIT?
	BEQ	RT3		;NO EOTS FOUND, ALAS
	TST	(R3)		;TEST I/O STATUS FOR ERRS
	BMI	RT1		;RE-INIT INPUT AND WAIT
	MOV	(R4),R0		;GET CONTROL WORD FROM PACKET

	MOV	R4,-(SP)	;SAVE POINTER TO MESSAGE

;
	MOV	(SP)+,R4	;RELOAD R4
;			*** NOW DETERMINE ACK FOR XMITTED ***
;
RIPFIX:	MOV	(R4),R0		;GIT FINGERS ON CONTROL WORD
	BIT	#100,R0		;SPECIAL PACKET?
	BNE	SPCPAK		;BRANCH IF SO
	MOVB	$OEOUT,R3	;ODD/EVEN, TRANSMIT SIDE TO R3
	MOVB	R0,$OEOUT	;MOVE CTRL WD ACK TO $OEOUT
	MOV	R3,R2		;MOVE OLD ODD/EVEN
	BIC	R0,R2		;COMPUTE XOR($OEOUT,ACKBITS)
	BIC	R3,R0		;ANY 1'S WILL INDICATE SUCCESS
	BIS	R0,R2		;R2=1 FOR EACH XMIT CHNL ACKNOLEGED
	ASR	R2		;ALIGN TO FLAG CHNL IN-USE BITS
	ASR	R2
	MOV	#$RTOIU,R3	;GET CHNL IN-USE PTR
	MOV	#RTNCH,R1	;GET NUMBER OF CHANNLS
RTOC:	ROR	R2		;MOVE BIT TO C
	BCC	RONCL		;BRANCH IF NO ACK
	CLRB	(R3)		;CLEAR IN-USE FLAG
RONCL:	INC	R3		;INCREMENT POINTER
	DEC	R1		;AND TALLY
	BGT	RTOC		;FOR ALL CHANNELS
	MOV	(R4),R0		;CONTROL WORD TO R0
	BIT	#RTNMSK,R0	;SEE IF NULL PACKET (WC=0)
	BEQ	RTINUL		;YUP, DONT MESS WITH RCV ODD/EVENS
	$PUSH	R0,R4		;SAVE REGS
	$POST	#$PCTRO+2,#RDY+ACK	;POST OUTPUT PROCESSOR
	$POP	R4,R0		;RESTORE THEM

;		***	NOW PROCESS RECEIVE CHNLS IF NON-NUL
;				LOOK FOR DUPLICATE

	BIC	#100000,R0	;CLEAR LAST-PACKET BIT
	MOV	R0,R2		;SETUP FOR SHIFT
	BIC	#177774,R0	;GET CHANNEL NR RCD
	CMP	R0,$CHNLI	;IS THIS THE ONE WE WANT?
	BNE	RTINUL		;THROW IT AWAY
	SUB	#12.,R0		;PREPARE FOR RIGHTSHIFT
	$PUSH	R0		;R0 CONTAINS NEGATIVE NUMBER OF SHIFTS
	CLC			;SETUP FOR LOGICAL SHF RIGHT
	ROR	R2		;SHIFT RIGHT
	BR	RONRR		;INCREMENT TALLY AND SHIFT
	ASR	R2		;SHIFT DATA RIGHT
RONRR:	INC	R0		;INCREMENT AND TALLY
	BMI	.-4		;TILL 12.-CHNLNO PLACES
	MOV	#137777,R0		;OBTAN MASK IN R0
	ASR	R0		;SHIFT HIM 12.-CHNLNO PLACES
	INC	(SP)		;NOW USE TALLY ON STACK
	BMI	.-4		;INCREMENT TILL 0
	TST	(SP)+		;REMOVE THE 0 FROM STACK
	MOVB	$OEIN,R1	;PUT RCV O/E BITS IN R1
	MOV	R2,R3		;COMPUTE XNOR(R1,R2)
	BIC	R1,R3		;AND STICK RESULT
	BIC	R2,R1		;IN R1, INDICATING DUPLICATE
	BIS	R3,R1		;GET XOR
	BIC	R0,R1		;SELECT CORRECT CHNL O/E BIT
;
;			** NOTE **
;
;		IF R1 NE 0 THEN DUPLICATE

	COM	R2		;COMPLEMENT PACKET O/E BIT
	BIC	R0,R2		;AND SELECT ONLY CORRECT CHNL
	COM	R0		;COMPUTE NOT(MASK)
	BICB	R0,$OEIN	;CLEAR APPROPRIATE O/E BIT IN $OEIN
	BISB	R2,$OEIN	;AND SET ITS NEW VALUE
	BICB	#303,$OEIN	;CLEAR ALL BUT RCV OE BITS
;
;			*** END OF RECEIVE ODD/EVEN LOGIC ***
;

	MOV	(R4),R0		;GRAB CONTROL WORD BY ASS
	INC	$MS00		;INCR NR PACKETS RCVED W/O ERROR
	TST	R1		;SEE IF DUPLICATE PACKET
	BGT	REINI		;REINIT INPUT, AND USE CRASS LANGUAGE
;			***
;			***  ITS A MESSAGE PACKET
;			***
	INC	$MS01		;INCR NR NON-DUPLICATES
	JSR	PC,RIENQ	;PUT MESSAGE IN IMP-HOST QUEUE
	MOV	$CHNLI,R0	;GET INPUT CHNL NR
	INC	R0		;INCREMENT IT
	CMP	R0,#RTNCH	;CMPR TO MAX CHNL
	BLT	.+4		;SKIP RESET
	CLR	R0
	MOV	R0,$CHNLI	;SETUP CHNL IN

RTINUL:				;NULL PACKET
REINI:	MOV	#VDHSI,R3	;SETUP POINTER TO VDH STAT REG
	JSR	PC,RTID		;INIT DEVICE
	BR	RIWT0		;SKIP DOWN TO CHECK FOR ANY TERMINATOR
SPCPAK:	TST	R0		;SPECIAL PACKET; HELLO?
	BMI	SPCIHY		;ITS 'I HEARD YOU'
	BISB	#1,$VDHFL	;INDICATE AN I-HEARD-YOU MUST GO
	$POST	#$PCTRO+2,#RDY+ACK	;SIGNAL OUTPUT PROCESS
	BR	REINI
SPCIHY:	TSTB	$DEAD		;HAVE WE DIED?
	BEQ	SDCT		;NO, RESET COUNTER
	INC	$VDHCT		;INCREMENT VDH COUNTER
	BLE	REINI		;RE-INIT INPUT IF NOT ALIVE YET
	CLRB	$DEAD		;INDICATE ALIVE
SDCT:	MOV	#4,$VDHCT	;INIT VDH COUNTER FOR ALIVE
	BR	REINI
RIWT:	$WAIT			;AND WAIT FOR EITHER TIMER OR IO
	BIT	#IO,-(R4)	;POSTED FOR IO?
	BEQ	RIWT		;NO, WAIT FOR IO
RIWT0:	JSR	PC,RTDDV	;GET DEV AND BUFFER IN R4
	BEQ	RIWT		;NOONE HAD AN EOT, ALAS
	TST	(R3)		;ANY ERRORS?
	BMI	RTERR		;WELL, RE-START INPUT IF SO
	MOV	(R4),R0		;CONTROL WD TO R0
	JMP	RIPFIX		;GO SETUP ODD/EVEN BITS

RTERR:	INC	$MS02		;INCREMENT ERROR COUNT
	BR	REINI		;AND REINITIALIZE


RTDDV:	MOV	#VDHSI,R3	;DETERMINE DEVICE CAUSING INTRPT
	MOV	VDCHN,R0	;GET VDH CHANNL NR
	JSR	PC,SET		;SET INPUT DEVICE POINTER
	BIT	#VDEOT,(R3)	;EOT FLAG SET?
	BNE	RVICOM		;YES, RETURN WITH THIS ONE
	JSR	PC,ADV		;NO, ADVANCE TO NEXT DEVICE
	JSR	PC,SET
	BIT	#VDEOT,(R3)	;EOT ON OTHER CHANNEL?
	BNE	RVICOM		;YES, RETURN WITH NEW ONE
	RTS	PC		;CAN'T FIND ONE
ADV:	COM	R0		;COMPLEMENT DEVICE NUMBER
	BIC	#177777-VDIIP,R0	;CLEAR ALL BUT DEV BIT
	RTS	PC		;AND RETURN
SET:	BIC	#VDIIP,(R3)	;SET DEVICE POINTER
	BIS	R0,(R3)		;IN STATUS REG
	RTS	PC		;AND RETURN
RVICOM:	MOV	R0,R4		;SAVE DEV NR
	JSR	PC,ADV		;ADVANCE TO NEXT IN R0
	MOV	R0,VDCHN	;NEXT CHANNEL
	ASR	R4		;GET BYTE INDEX IN R4
	BIC	#VDEOT,(R3)	;EOT FLAG CLEARED
	MOV	RTABL(R4),R4	;RETURN BUFFER ADDRESS
	RTS	PC
VDCHN:	.WORD	0		;CURRENT CHANNEL NR

RTID2:	MOV	#VDHSI,R3	;MOVE ADDR STAT IN
	BIC	#VDIIP,(R3)	;SET DEV NR 0
	MOV	#RBUF0,R4	;SET BUFFER ADDRX
	JSR	PC,RTID		;INIT DEVICE
	BIS	#VDIIP,(R3)	;SET DEV NR 1
	MOV	#RBUF1,R4	;A(BUF1)
	JSR	PC,RTID		;INIT DEVICE
	RTS	PC

RTID:	MOV	#100,@#VDHWI	;STORE WC
	BIC	#IO,@$APCT	;CLEAR IO BIT IN MY PCT
	JSR	PC,RTITRC	;TRACE IT
	MOV	R4,@#VDHMI	;STORE MAR
	BIS	#VDOIE+1,(R3)	;SET GO BIT AND INT ENABL
	RTS	PC		;RETURN

	.SBTTL	TRACE INPUT BUFFER
TRCELS = 20.

RTITRC:	MOV	TRCTBL,R0	;GET TRCTBL POINTER
	MOV	R4,(R0)+
	MOV	(R0),TRCTBL
	RTS	PC

TRCTBL:	.WORD	.+2
	.REPT	TRCELS-1
	.WORD	0,.+2
	.ENDR
	.WORD	0,TRCTBL+2


	.PAGE
	.SBTTL	ENQUEUE MESSAGE FOR NCP

RIENQ:	MOV	R4,APAK		;SAVE ADDRESS OF PACKET
	MOV	AMSG,R1		;GET ADDRX OF MESSAGE
	BNE	MMS1		;DEFINED? BRCH IF YES
	TST	(R4)		;LAST PACKET?
	BMI	MLSTP		;BRANCH IF YES
	MOV	#1,R0		;SET POOL 1, 512 WORD MSG
MLAL0:	MOV	R0,APOOL	;STORE POOL NUMBER
MLALC:	$ALOCB			;ALLOC A BUFFER
	BEQ	RIWBUF		;UNSUCCESSFUL?
	MOV	R1,AMSG		;STORE ADDRX OF MESSAGE
	CLR	AMNDX		;CLEAR MSG INDEX
MMS1:	MOV	APAK,R4		;RESTORE BASE OF PACKET
	MOV	(R4),R0		;GET CONTROL WORD
	MOV	AMNDX,R2	;SETUP INDEX
	BIC	#177777-RTNMSK,R0	;GET WORD COUNT
	SWAB	R0		;IN LO BYTE
	ADD	R0,R2
	CMP	R2,#MAXMGL	;G.T. MAX MSGLEN?
	BGT	RIMPE1		;IMP ERROR
	MOV	AMNDX,R2	;MOVE MESSAGE INDEX TO R2
	ASL	R2		;GET OFFSET (BYTES)
	ADD	R2,R1		;COMPUTE MSG PTR
	ADD	R0,AMNDX	;UPDATE MSG INDEX (WORDS)
	TST	(R4)+		;POINT TO ACTUAL MESSAGE
RIMLP1:	MOV	(R4)+,(R1)+	;MOVE PACKET TO MSG
	DEC	R0		;TALLY NR WDS
	BGT	RIMLP1		;LOOP TO MOVE PACKET TO MESSAGE
	MOV	APAK,R4		;RESTORE ADDRX OF PACKET
	TST	(R4)		;LAST PACKET?
	BGE	RINQ		;IF NOT, DONT ENQUEUE MSG TO I-H

	JSR	PC,$GFMQE	;GET FREE MSG QUEUE EL
	MOV	R4,R0		;ELEMENT ADDR TO R0 FOR $ENQ
	MOV	AMSG,-(R4)	;MESSAGE ADDR
	MOV	APOOL,-(R4)	;POOL ID
	MOV	AMNDX,-(R4)	;LENGTH
	MOV	#$IHQ,R2	;ADDR OF IMP-HOST QUEUE
	JSR	PC,$ENQ		;ENQUEUE MESAGE
	$POST	#$PCTIH+2,#RDY+ACK	;POST IMP-HOST PROCESSOR
	MOV	APAK,R4		;RESTORE ADDR OF PACKET
	CLR	AMSG	;INDICATE NO MESSAGE
RINQ:	RTS	PC	


RIMPE1:	TRAP	100
MLSTP:	CLR	R0		;SET POOL 0
	BR	MLAL0		;CONTINUE WITH 64 WORD BUFFER
RINQT:	MOVB	#1,$DEAD	;SET DEAD - ERROR FROM IMP
	CMP	(SP)+,(SP)+	;CLEAN STACK
	JMP	$RTPIN		;RE-INITIALIZE


;		*** WAIT FOR A BUFFER ***


RIWBUF:	MOV	R5,-(SP)	;SAVE R.A.
RWT2:	$WAIT
	BIT	#TIM,-(R4)	;TIMER GO OFF?
	BNE	RINQT		;ERROR
	BIT	#BUF,(R4)	;DO WE HAVE A BUFFER NOW?
	BEQ	RWT2		;NO.
	MOV	(SP)+,R5	;RESTORE R.A.
	MOV	APOOL,R0	;RE-SETUP POOL ID
	BR	MLALC

;			----------

;			THESE INTERRUPT ROUTINES SIGNAL THAT
;			THE RTP INPUT OR OUTPUT ROUTINES
;			ARE DISPATCHABLE, AND INDICATE THE
;			COMPLETION OF A PACKET INPUT OR OUTPUT.
;			THEY $POST THE I/O PROCESSES, AND
;			EXIT TO THE DISPATCHER.

;			----------



VIOI:	JSR	R5,$SVST	;SAVE STATUS
	BIT	#TIMI,@#VDHSO	;TIMER INTERRUPT?
	BEQ	SKTI		;SKIP TIMER INTERRUPT
	BIC	#TMRE+TIMI,@#VDHSO	;STOP THE TIMER
	$POST	#$PCTIM+2,#RDY+TIM
SKTI:				;AND CLEAR TIM FLAG	
	BIT	#VDEOD,@#VDHSO	;TEST FOR OUTPUT END DATA
	BEQ	IEXTRP		;EXIT IF NO MORE TO DO
	$POST	#$PCTRO+2,#RDY+IO	;POST HIM
	BIC	#VDEOD,@#VDHSO	;CLEAR EOD BIT IN STAT
IEXTRP:	JMP	$IEXIT		;ENTER DISPATCHER


VIII:	JSR	R5,$SVST	;SAVE STATUS
	$POST	#$PCTRI+2,#RDY+IO	;POST HIM
	BR	IEXTRP		;ENTER DISPATCHER

	.PAGE
	.SBTTL	RTP -- DATA AREA


;			----------

;			RTP CRITICAL CONSTANTS

;			----------

$DEBUG:	.BYTE	0		;DEBUG MODE - SET BY OPERATOR
$VDHFL:	.BYTE	0		;VDH FLAGS (LINE DEAD/ALIVE)
$IHBIT:	.BYTE	0		;CURRENT IMP-HOST FLAG
$DEAD:	.BYTE	0		;LINE DEAD FLAG 1=DEAD, -1=COMING UP
;				 0 = ALIVE
$OEIN:	.BYTE	0		;ODD/EVEN BITS , INPUT
$OEOUT:	.BYTE	0		;ODD/EVEN BITS, OUTPUT
$VDHCT:	.WORD	0		;VDH LINE MONITOR COUNTER
$CHNLI:	.WORD	0		;CURRENT INPUT CHANNEL (LOGICAL)
$CHNLO:	.WORD	0		;CURRENT OUTPUT CHANNEL
RTABL:	.WORD	RBUF0,RBUF1	;ADDRESSES OF BUFFERS

AMSG:	.WORD	0
APAK:	.WORD	0
APOOL:	.WORD	0
AMNDX:	.WORD	0

;		***		RTP		   ***
;		***  SYSTEM MEASUREMENT CONSTANTS  ***


$MS00:	.WORD	0
$MS01:	.WORD	0
$MS02:	.WORD	0
$MS03:	.WORD	0
$MS04:	.WORD	0
$MS05:	.WORD	0
$MS06:	.WORD	0

RBUF0:	.BLKW	64.		;INPUT BUFFERS
RBUF1:	.BLKW	64.

	.END



î