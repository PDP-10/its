;<VOICE>ELFDIS.M11;11    12-MAR-74 08:38:04	EDIT BY RAVELING

;	Looking for assembler bug (?) - tried changing .blkw's
;	to equates (.=.+...)

;<VOICE>ELFDIS.M11;10    11-MAR-74 08:35:13	EDIT BY RAVELING

;	Corrected consequences of previous correction.  Bah!

;<VOICE>ELFDIS.M11;9    11-MAR-74 08:23:51	EDIT BY RAVELING

;	Corrected addressability errors in branches.

;<VOICE>ELFDIS.M11;8    11-MAR-74 07:37:59	EDIT BY RAVELING

;	Added .SND & .RCV, modified $ATTCH for revised pct format,
;	added labels for enqueue & dequeue pct.

;<VOICE>ELFDIS.M11;7    23-FEB-74 00:32:13	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;6    10-FEB-74 21:46:13	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;5    10-FEB-74 00:29:05	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;4     9-FEB-74 23:12:17	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;3     7-FEB-74 16:11:02	EDIT BY RAVELING
;<VOICE>ELFDIS.M11;2     6-FEB-74 12:47:27	EDIT BY RAVELING
	®LIST	ÍD,ME
	®NLIST	ÃND
	®MCALL	¤CNFIG
	®MCALL	¤GPCT,$GPRQ,$GTQE,$DFREG
	®MCALL	¤PUSH,$POP,$ALOCB,$FREEB
	®MCALL	¤DISCC,$WAIT,$POST
	¤CNFIG
	¤DFREG
	¤DISCC
	.PCTD


	®TITLE	ÎETDIS SCRL/ARPANET
	®SBTTL  DISPATCHER CONTROL TABLES
	®CSECT
	®GLOBL	¤IEXIT,$SVST,$IH
	®GLOBL	¤APCT,$IOC,$TCI
	®GLOBL	¤RTPIN,$RTPOU,$IMPIN
	®GLOBL	¤DUMP
	®GLOBL	¤PCTRO,$PCTIH,$LGPCT,$PCTRI,$PCTIM,$LGR
	®GLOBL	¤TSET,$TGET	»TIMER WRITE/READ ROUTINES
	.globl	$CLKIN		; clock initialization routine
	®GLOBL	¤WDOG1
	.GLOBL	$FTP0
	®GLOBL	¤ALOCB,$FREEB

;	‰‰ÎCP GLOBLS
	®GLOBL	¤N.CON,$N.LSN,$N.CLS,$N.SND,$N.RCV,$N.CNT

	®PAGE
	®SBTTL	ÐROCESS PRIORITY QUEUES


;	‰‰ª**  SCRL ARPANET CONTROL ***
;	‰‰ª**       T A B L E S     ***


$PRQ6:	¤GPRQ	¤PRQ5,6,$PCTIM,$PCTIM
$PRQ5:	¤GPRQ	¤PRQ4,5,$PCTRI,$PCTRO
$PRQ4:	¤GPRQ	¤PRQ3,4,$PCTIH,$PCTIH
$PRQ3:	¤GPRQ	¤PRQ0,3,$LGPCT,$WDPCT
$PRQ0:	¤GPRQ	¤PRQ6,0,$PCTD,$PCTD


	®PAGE
	®SBTTL	ÐROCESS CONTROL TABLES

$PCTIM:	¤GPCT	°,$PRQ6,$TIMER,340	»TIMER PROCESSOR
PCTLEN = .-$PCTIM/2	‰»PCT LEN, WORDS
$PCTRI:	¤GPCT	¤PCTRO,$PRQ5,$RTPIN,340	»RTP INPUT
$PCTRO:	¤GPCT	°,$PRQ5,$RTPOU,340	»RTP OUTPUT
$PCTIH:	¤GPCT	°,$PRQ4,$IH,340	‰»IMP-HOST PROTOCOL
$LGPCT:	¤GPCT	¤FTPCT,$PRQ3,$LGR,340	»LOGGER, AND TERMINALS
$FTPCT:	$GPCT	$WDPCT,$PRQ3,$FTP0,0
$WDPCT:	¤GPCT	°,$PRQ3,$WDOG1,0	»PCT FOR WATCH-DOG PROC.
$PCTD:	¤GPCT	¤PCTD,$PRQ0,$DUMMY,0	»DUMMY PCT (WAIT-STATE)



$APCT:	®WORD	°	»ADDRESS OF ACTIVE PROCESSOR CONTROL TBL
TSETL:	®WORD	°	»LAST TIMER SETTING
TFQH:	®WORD	ÔQ+4	»ADDRESS OF TIMER FREE QUEUE HD
TQAH:	®WORD	°	»ADDRESS OF TIMER ACTIVE QUEUE HEAD


TQ:	¤GTQE	¶	»GENERATE 6 TIMER QUEUE ELEMENTS

VIO = 10	‰»VDH INTFC INT OUT

REGTLY = 6.	‰»NR REGS SAVED BY $SVST
PCPOOL = 0	‰»POOLID FOR PCT
	®PAGE
	®SBTTL	ÍULTIPROCESSING DISPATCHER

 	»	‰ª**  SCRL ARPANET SYSTEM ***
	»	‰ª**    MULTIPROCESSING   ***
	»	‰ª**     DISPATCHER       ***

$WAIT:	ÍOV	¤APCT,R4	»MOVE ACTIVE PCT ADDRESS
	ÍOV	ÓP,2(R4)	»SAVE PROCESS' STACK POINTER
WTST:	ÔSTB	¨R4)	‰»IS PROCESS READY AGAIN?
	ÂPL	×TI0	‰»NO, BUMP TO NEXT PROCESS
	ÍOV	Ò4,$APCT	»SAVE ACTIVE PCT PTR
	ÂIC	£140200,(R4)+	»GO BACK TO PROCESS
	ÍOV	¨R4),SP	‰»GIVE HIM BACK HIS STACK
	ÒTI	‰‰»AND RETURN...

WTI0:	ÂIS	£140000,(R4)	»SET WAITING...
deqpct:	ÍOV	­(R4),@6(R4)	»BUMP QUEUELINK TO NEXT
WTI:	ÍOV	£$PRQ6+2,R3	»SETUP HEAD OF PRIOQ
	ÂR	®+4	‰»JUMP INTO PRIOQ DISPATCHER
	ÍOV	­(R3),R3	»NEXT IN CHAIN
	ÍOV	¨R3),R4	‰»PCT ADDR
	ÂEQ	®-4	‰»BACK TO NEXT
	ÔST	¨R4)+	‰»BUMP TO CONTROL BYTE
	ÔST	¨R4)	‰»WAS HE WAITING
	ÂMI	×TST	‰»YES, SEE IF HE'S RDY
	ÍOV	Ò4,$APCT	»SETUP ACTIVE PCT ADDR
	ÍOV	²(R4),SP	‰»GET HIS STACK POINTER
	ÊSR	Ò5,SRST	‰»RESTORE STATUS
	ÒTI	‰‰»AND RETURN


	®PAGE
	®SBTTL	¤POST  --  PLACE PROCESS IN READY QUEUE

;	‰‰ª**  $POST  ***

;	‰‰ÁSSUMES:
;	‰‰Ò0 = A(PCT CONTROL BYTE)
;	‰‰Ò1 = COMPLETION CODE

$POST:	ÂIS	Ò1,(R0)	‰»SET COMPLETION CODE
	ÂIT	£40000,(R0)	»IS HE IN RDY QUEUE ALREADY?
	ÂEQ	‡POSWT	‰»YES, JUST RETURN
enqpct:	ÂIC	£40000,(R0)	»OK, INDICATE HES IN RDY QUEUE
	ÍOV	´(R0),R3	»GET PRIOQ POINTER
	ÃLR	­(R0)	‰»CLEAR CHAIN FIELD TO NEXT PCT
	ÔST	¨R3)+	‰»IS THERE ONE IN QUEUE
	ÂNE	ÐOSW2	‰»BRCH IF YES
	ÍOV	Ò0,(R3)	‰»SET NEW TAIL
POSW0:	ÍOV	Ò0,-(R3)	»SET HEAD PTR (OR TAIL)
POSWT:	ÒTI	‰‰»RETURN

POSW2:	ÍOV	Ò0,@(R3)+	»SET LINK FROM CURRENT 'LAST'
	ÂR	ÐOSW0	‰»GO SET NEW TAIL PTR






	®PAGE
	®SBTTL	ÄISPATCHER RETURN, REGSAVE, RESTORE.


$IEXIT:	ÍOV	¤APCT,R4	»GE ACTIVE PCT ADDR
	ÍOV	ÓP,2(R4)	»SAVE HIS STACK POINTER
	ÂR	×TI	‰»ENTER DISPATCHER



$SVST:	¤PUSH	Ò0,R1,R2,R3,R4	‰»SAVE REGS
	ÍOV	Ò5,PC	‰»RETURN

SRST:	ÉNC	¨SP)+	‰»THROW AWAY CALLERS R5
	¤POP	Ò4,R3,R2,R1,R0
	ÒTS	Ò5	»R5 GETS RESTORED TOO...

	.page
	.sbttl	.SEND Primitive (temporary version)

;	   This isn't commented because it's temporary &
;	   the !#$)&$#""$( system probably won't stay up
;	   long enough.

.SEND:	jsr	r5,$SVST
	bit	r1,pctrcm(r0)	; waiting for this msg?
	beq	mesenq
	clr	pctrcm(r0)		; yes.
	mov	pctsp(r0),r5
	jsr	pc,setmes
	tst	(r0)+
	br	enqpct


mesenq:	mov	freemq,r5
	bne	.+4
	halt
	mov	(r5)+,freemq
	jsr	pc,setmes
	clr	-(r5)

	mov	#pctpmq,r4
	add	r0,r4

1$:	mov	@r4,r3
	beq	atend
	mov	r3,r4
	br	1$

atend:	mov	r5,@r4
	br	$IEXIT



setmes:	mov	.TOD,(r5)+
	mov	r3,(r5)+
	mov	r2,(r5)+
	mov	r1,(r5)+
	mov	$APCT,r3
	tst	-(r3)
	mov	r3,(r5)+
	mov	.TOD+2,(r5)+
	sub	#12.,r5
	rts	pc
	.page
	.sbttl	.RCV primitive -- temporary version


.RCV:	jsr	r5,$SVST
	mov	#pctpmq-2,r4
	add	$APCT,r4

rqn:	mov	@r4,r5
	beq	block
	bit	r1,8.(r5)
	beq	rqs
	tst	r0
	beq	rtrv
	cmp	r0,10.(r5)
	beq	rtrv
rqs:	mov	r5,r4
	br	rqn



rtrv:	mov	(r5)+,@r4
	mov	sp,r4
	mov	#6,r0
1$:	mov	(r5)+,(r4)+
	.loop	r0,1$

	sub	#14.,r5
	mov	freemq,@r5
	mov	r5,freemq
	br	$IEXIT


block:	mov	$APCT,r4
	mov	r1,pctrcm-2(r4)
	bis	#040000,@R4
	jmp	deqpct
	.sbttl	Free message block queue

.TOD:	0,0		; temp..

freemq:	.+2
	.rept	7
	.+16.
	.=.+14.
	.endr

	0
	.=.+14.
	®PAGE
	®SBTTL	ÔIMER PROCESSOR

TSMAX = 520.	‰»520 MSEC. MAX SETTING FOR HWR TIMER

TWAIT:	¤WAIT	‰‰»TIMER PROCESSOR INACTIVE
$TIMER:	ÍOV	ÔSETL,R1	»GET LAST VALUE SET IN R1
	ÍOV	ÔQAH,R0	‡	»GET ACTIVE QUEUE HEAD
	ÂEQ	ÔWAIT	‰»WAIT IF NO QUEUE ENTRIES
TLMOD:	ÓUB	Ò1,-2(R0)	»CORRECT ENTRIES BY TIME LAPSE
	ÂGT	ÔSVQ	‰»BRANCH IF ENTRY NOT EXPIRED
	¤PUSH	Ò0,R1	‰»SAVE PARAM REGS
	¤POST	­4(R0),#RDY+TIM	»POST HIM
	¤POP	Ò1,R0	‰»RESTORE REGS
	ÍOV	¨R0),TQAH	»DELETE FROM QUEUE
	ÍOV	ÔFQH,(R0)	»LINK TO FREE QUEUE HEAD
	ÍOV	Ò0,TFQH	‰»STICK HIS ADDRX ON FREE QUEUE
	ÍOV	ÔQAH,R0	‰»GET NEW VALUE
	ÂNE	ÔLMOD	‰»BRANCH IF MORE TO GO
	ÃLR	Ò0	‰»TURN OFF THE TIMER
	ÊSR	ÐC,$TSET	»BY SETTING IT TO 0
	ÂR	ÔWAIT	‰»AND WAIT FOR WORK...

TLMOD2:	ÓUB	Ò1,-2(R0)	»FIX REMAINING ENTRIES IN QUEUE
TSVQ:	ÍOV	¨R0),R0	‰»BUMP QUEUE POINTER
	ÂNE	ÔLMOD2	‰»AND CORRECT THEIR TIME VALS

;	‰‰‰ÎOW SET VALUE OF TIME TO VALUE
;	‰‰‰ÁT HEAD OF QUEUE

	ÍOV	ÔQAH,R4	‰»ACTIVE QUEUE EL PTR
	ÍOV	­(R4),R0	»GET REQUEST SET VALUE
	ÃMP	Ò0,#TSMAX	»IS IT GREATER THAN MAXIMUM
	ÂLOS	ÓTNTR	‰»NO, BY-PASS TRIM
	ÍOV	£TSMAX,R0	»YES, TRIM TO MAX ALLOWED.
STNTR:	ÍOV	Ò0,TSETL	»SAVE CURRENT SETTING VALUE
	ÊSR	ÐC,$TSET	»SET TIMER TO NR MSECS IN R0
	ÂR	ÔWAIT	‰»WAIT ON R.T. CLOCK


	®PAGE
	®SBTTL	ÓET PROCESS TIMER
	‰‰»  THIS PROCESSOR ROUTINE
	‰‰»
	‰‰»  RUNS AT PRIO 7
	‰‰» ASSUMES TIMER VAL IN R1
	‰‰» AND PCT ADDR IN R2, OR 0 IN R2


$STIME:	ÔST	Ò2	‰»SEE IF HAVE NULL ARGUMENT
	ÂNE	ÓTNUL	‰»DONT LOAD $APCT
	ÍOV	¤APCT,R2	»SETUP ADDRX OF PCT CONTROL BYTE
STNUL:	ÔST	Ò1	‰»ONLY ALLOW POS TIME VAL
	ÂEQ	‡STPOST	‰»IF 0 , POST HIM NOW
	ÍOV	£TQAH,R3	»POINTER TO TQ ACTIVE WD
	ÍOV	¨R3),R0	‰»FIRST ENTRY
	ÂEQ	ÓTADD	‰»BRANCH IF NONE
STCMP:	ÃMP	Ò2,-4(R0)	»SAME PCT?
	ÂEQ	ÓTREM	‰»YUP, REMOVE HIME FROM LIST
	ÍOV	Ò0,R3	‰»GET NEXT IN LIST...
	ÍOV	¨R0),R0
	ÂNE	ÓTCMP	‰»SERCH FOR SPECIFIED PCT
	ÔST	ÔFQH	‰»ANY IN FREE QUEUE?
	ÂEQ	ÓTERR	‰»IF NOT, THROW UP OUR HANDS
STCON1:	¤PUSH	Ò1	‰»SAVE REQUEST TIME SETTING
	ÊSR	ÐC,$TGET	»GET CURRENT TIME, IN MSECS.
	¤PUSH	Ò0	‰»AND SAVE IT ON STACK
	ÃLR	Ò0	‰»THEN STOP TIMER
	ÊSR	ÐC,$TSET	»BY SETTING TO 0
	¤POP	Ò3,R1	‰»PUT CURRENT TIME IN R3
	ÓUB	ÔSETL,R3	»SUBTRACT TO GET TIME GONE BY
	ÍOV	£TQAH,R0	»ACTIVE HEAD TO R0
	ÂR	ÓTCH	‰»CORRECT EVERYBODY AS IF
STCOR:	ÁDD	Ò3,-2(R0)	»TIMER HAD EXPIRED.
STCH:	ÍOV	¨R0),R0	‰»MOVE TO NEXT ENTRY
	ÂNE	ÓTCOR	‰»LOOP THRU TBL
	ÍOV	£TQAH,R0	»POINT TO BEGIN
	ÂR	ÓTSTEP	»	ÅNTRY SEARCH
STSTP2:	ÃMP	Ò1,-2(R0)
	ÂLE	ÓTADD	‰»BRAH IF NEW TIME L.E.
STSTEP:	ÍOV	Ò0,R3	‰»BUMP POINTER
	ÍOV	¨R0),R0	‰» TO ENTRY
	ÂNE	ÓTSTP2	‰»BRANCH IF NOT AT END
STADD:	ÍOV	ÔFQH,(R3)	»STICK NEW GUY IN QUEUE
	ÍOV	¨R3),R3	‰»BUMP TO NEXT
	ÍOV	¨R3),TFQH	»CHAIN FREE QUEUE
	ÍOV	Ò0,(R3)	‰»NEW LINK FROM CURRENT...
	ÍOV	Ò1,-(R3)	»STORE TIME VALUE
	ÍOV	Ò2,-(R3)	»STORE PCT ADDR
STNSET:	ÃLR	ÔSETL	‰»INDICATE TIMER CLEARED
	¤POST	£$PCTIM+2,#RDY+TIM	»POST TIMER PROCESS
; (TIMER PROCESSOR WILL SET TIMER)
	ÂIC	£TIM,@$APCT	»CLEAR TIM BIT IN ACTIVE PCT
STPOST:	ÒTI	‰»RETURN FROM $STIME

STREM:	ÍOV	¨R0),(R3)	»CHAIN AROUND HIM
	ÍOV	ÔFQH,(R0)	»LINK TO PREV HD OF Q
	ÍOV	Ò0,TFQH	»SETUP NEW HEAD
	ÂR	ÓTCON1	‰»BACK TO SEARCH LIST

STERR:	ÔRAP	²00	‰»TEMP *** ERROR CONDX
	®PAGE
	®SBTTL	¤ATTCH  --  CREATE A NEW SYSTEM PROCESS

;	‰‰ª**  $ATTCH  ***

;	‰‰ÁSSUMES
;	‰‰¨SP) CONTAINS ENTRY POINT OF NEW
;	‰‰  PROCESS
;	‰‰²(SP) CONTAINS ITS PRIORITY


$ATTCH:	ÊSR	Ò5,$SVST	»SAVE CALLERS STATUS
	ÍOV	ÒEGTLY+3 * 2 (SP), R0	»SOFTWARE PRIORITY TO R0
	ÍOV	£$PRQ6+2,R1	»POINTER TO PRIORITY QUEUE LIS
ANCKF:	ÍOV	´(R1),R2	»GET HIS PRIO
	ÂEQ	ÁNF00	»WE'RE AT END OF LIST
	ÃMPB	Ò0,R2	‰»COMPARE PRIORITY
	ÂEQ	ÁNOKF	»THIS IS IT
	ÍOV	­(R1),R1	»BUMP TO NEXT IN CHAIN
	ÂR	ÁNCKF	‰»SEARCH FOR SPECIFIED PRIO
ANF00:	ÁDD	£REGTLY*2,SP	»BUMP STACK PTR PAST SVST WDS
	ÍOV	£2,R0	‰»SET ERROR CODE (UNDEF. PRIO)
	ÂR	ÁTRTI	‰»CLEAN STACK AND RETURN

ANOKF:	¤PUSH	Ò1	‰»SAVE PTR TO PROCESS PRIO Q
	ÍOV	£PCPOOL,R0	»GET POOLID FOR PCT
	¤ALOCB	‰‰»TRY TO GET A BUFFER
	ÂEQ	ÁTNBF	»CANT FIND A BUFFER
	ÍOV	£REGTLY,R3	»GET NR WDS TO COPY
	ÍOV	ÓP,R4	‰»SO WE CAN FORMAT NEW PCT
	ÔST	¨R4)+	‰»SKIP OVER PQE POINTER
	ÍOV	Ò1,R2	‰»SAVE NEW PCT ADDR
	ÁDD	£PCTLEN-REGTLY-2*2,R2	»GET DEST BEGIN AREA
	ÍOV	Ò2,4(R1)	»INIT NEW PCT STACK POINTER
	clr	pctrcm(r1)	; Receive mask = 0
	clr	pctpmq(r1)	; Pending msg queue empty
	mov	#70707,pctflg(r1) ; set stack overflow detector
	ÍOV	ÒEGTLY+3*2(SP),PCTLEN-2*2(R1)
;	‰‰‰×E JUST SETUP HIS ENTRY POINT
	ÃLR	ÐCTLEN-1*2(R1)	»CLEAR HIS CONTROL BYTE
AMSTAK:	ÍOV	¨R4)+,(R2)+	»COPY CALLER'S STACK TO NEW PCT
	ÄEC	Ò3
	ÂGT	ÁMSTAK
	ÃLR	¨R1)+	‰»NEXT PCT PTR
	ÃLR	¨R1)+	‰»CLEAR HIS CONTROL BYTE
	ÔST	¨R1)+	‰»SKIP OVER HIS STK PTR
	¤POP	¨R1)	‰»STICK PQE PTR IN PCT
	ÍOV	Ò1,R0	‰»SETUP FOR POST
	ÃMP	­(R0),-(R0)	»GET ADDR PCT CNTRL BYTE
	ÍOV	£40000,R1	»SETUP CMP CODE 
	ÔRAP	µ	‰»TRAP TO POST ROUTINE
	ÁDD	£REGTLY*2,SP	»CLEAN STACK
	ÃLR	Ò0	‰»SET SUCCESSFUL COMPLETION
	ÂR	ÁTRTI	‰»AND RETURN

ATNBF:	ÁDD	£REGTLY+1*2,SP	»SKIP OVER REGS
	ÍOV	£4,R0	‰»CC 4 MEANS NO BUFFER SPC

ATRTI:	ÍOV	¨SP)+,2(SP)	»SLIDE STACK
	ÍOV	¨SP)+,2(SP)	»DOWN
	ÒTI	‰‰»AND RETURN

	®SBTTL	¤DETCH -- KILL PROCESS
$DETCH:	ÒTI




$DUMMY:	WAIT		; ------- ACT IDLE -------  /ISI-PR/
	BR	$DUMMY	;			    /ISI-PR/
	®PAGE
	®SBTTL	ÔRAP -- SYSTEM TRAP PROCESSOR


;	‰‰ª*******************
;	‰‰ª   	‰   *
;	‰‰ª  TRAP PROCESSOR  *
;	‰‰ª   	‰   *
;	‰‰ª*******************

TRAP:	ÍOV	Ò0,TR0SV	»SAVE REG 0
	ÍOV	¨SP),R0	‰»GET ADDR OF TRAPPING INSTR
	ÍOV	­(R0),R0	»GET TRAP INSTR CAUSING TRAP
	ÂIC	£177400,R0	‰»MASK TO GET LOW BYTE
	ÃMP	Ò0,#TRMAX	»DONT ALLOW ILLEGAL TRAPS!
	ÂGE	ÔRE	‰»TRAP ERROR
	ÁSL	Ò0	‰»TRAP CODE TIMES 2
	ÍOV	ÔTBL(R0),-(SP)	»PUSH ADDR ONTO STACK
	ÍOV	ÔR0SV,R0	»RESTORE R0
	ÒTS	ÐC	‰»ENTRY TO TRAP ROUTINE @ PRIO 7

TR0SV:	®WORD	°


TTBL:	®WORD	¤WAIT	» TRAP 0 -- WAIT
	®WORD	¤STIME	» TRAP 1 -- SET TIMER
	®WORD	¤ALOCB	» TRAP 2 -- ALLOC BUFFER
	®WORD	¤FREEB	» TRAP 3 -- FREE BUFFER
	®WORD	¤ERROR	» TRAP 4 -- ABNORMAL ERROR 
	®WORD	¤POST	» TRAP 5 -- INDICATE PROCESS READY
	®WORD	¤ATTCH	» TRAP 6 -- CREATE PROCESS
	®WORD	¤DETCH	» TRAP 7 -- KILL PROCESS
	®WORD	¤IOC	» TRAP 10 -- LINK TO I/O CONTROL
	®WORD	Î.CON	» TRAP 11 -- CONNECT TO FGN SCK
	®WORD	Î.LSN	» TRAP 12 -- LISTEN ON LCL SCK
	®WORD	Î.CLS	» TRAP 13 -- CLOSE CONNECTION
	®WORD	Î.SND	» TRAP 14 -- SEND DATA
	®WORD	Î.RCV	» TRAP 15 -- RECEIVE DATA
	®WORD	Î.CNT	» TRAP 16 -- RETURN BYTE COUNT
	®WORD	Î.STA	» TRAP 17 -- RETURN STATUS 
	.word	.SEND	; Trap 20 -- Send
	.word	.RCV	; Trap 21 -- Receive

TRMAX = .-TTBL/2	‰»NUMBER OF TRAPS ALLOWED



$ERROR:
TRE:	ÈALT	‰»HALT PROCESSOR IF ERROR



N.CON:	ÊSR	ÐC,$N.CON	»ISSUE CONNECT
	ÒTI
N.LSN:	ÊSR	ÐC,$N.LSN	»ISSUE LISTEN
	ÒTI
N.CLS:	ÊSR	ÐC,$N.CLS
	ÒTI
N.SND:	ÊSR	ÐC,$N.SND
	ÒTI
N.RCV:	ÊSR	ÐC,$N.RCV
	ÒTI
N.CNT:	ÊSR	ÐC,$N.CNT
	ÒTI
N.STA:	ÒTI




;	‰‰‰ª** SCRL ARPA CONTROL ***
;	‰‰‰ª** PROGRAM           ***
;	‰‰‰ª**  INITIALIZE       ***

NETINI:	ÒESET	‰»INITIALIZE SYSTEM
	MOV	#157776,SP	; USE TOP OF ADDR SPACE FOR STACK
	ÍOV	£340,R1
	ÍOV	Ò1,@#PS	»RISE TO PRIORITY 7 NOW
	ÍOV	£TRAP,@#34	»INIT TRAP VECTOR
	ÍOV	Ò1,@#36	‰»AND ITS PRIORITY
	ÍOV	£ETRAP,@#4	»SETUP ERROR TRAP
	ÍOV	Ò1,@#6	‰»AND ITS PRIORITY
	ÍOV	£RTRAP,@#10	»RESERVED-INSTRUCTION TRP
	ÍOV	Ò1,@#12
	ÍOV	£IOTRAP,@#20	»IOT TRAP
	ÍOV	Ò1,@#22	‰»ITS PRIO

	jsr	pc,$clkin	; Initialize clock
	ÊSR	ÐC,$IMPIN	»INITIALIZE IMP
	ÊSR	ÐC,$TCI	‰»INIT TERMINAL CONTROLLER


	ÍOV	£100200,$PCTRI+2	»INIT RTP INPUT
	mov	#100200,$pctro+2	; init RTP output
	ÍOV	£100200,$PCTD+2	‰»INIT DUMMY PROCESS
	ÍOV	£100200,$WDPCT+2	»INIT WATCHDOG PROCESS
	ÊMP	×TI	»ENTER DISPATCHER
;	‰‰»ERROR TRAP ENTRY ADDRESSES

;	‰‰»TRAP TO SYSTEM DUMP ROUTINE

ETRAP:	ÊSR	Ò5,$DUMP	»ERROR TRAP
	®WORD	‡342	‰»CODE = 342

ETTRAP:	ÊSR	Ò5,$DUMP
	®WORD	³46	»TRACE TRAP

RTRAP:	ÊSR	Ò5,$DUMP	»RESERVED-INSTRUCTION TRAP
	®WORD	³44

IOTRAP:	ÊSR	Ò5,$DUMP
	®WORD	³60	‰»IO TRAP


	®END	ÎETINI	»END SCRL NET, MODULE 1


