;<CASNER>ELFNCP.O11;2    14-OCT-74 16:30:28	EDIT BY RAVELING

;	INSTALLED QUICK & DIRTY CODE TO ANSWER HH RST WITH RRP.

	.TITLE	NETNCP	SCRL NETWORK CONTROL
	.MCALL	$DISCC,$CNFIG,$DFREG,$WAIT,$POST,$STIME,$ALOCB,$FREEB
	.MCALL	$PUSH,$POP,$DFHTE,$DFCT
	.MCALL	$DFCCT,$DFSCC
	.LIST	ME
	.NLIST	CND
	.GLOBL	$IH,$DEAD
	.GLOBL	$IHQ,$HIQ,$IQF
	.GLOBL	$APCT,$PCTRO
	.GLOBL	$SHL,$ENQ,$DEQ,$GFMQE,$FMQE,$MQFMT,$ALOCW
	.GLOBL	$RFCLS,$SBCLS,$SINOP,$GLINK,$FLINK
	.GLOBL	$SNDRS,$HLIST
	.GLOBL	$FCTBL,$BLDCT,$ICT
	.GLOBL	$RCFLO,$SNFLO,$SNFL1,$SNFL2,$INCAL,$DECAL
	.GLOBL	$DMPMG
	.GLOBL	$ETCST,$MALCL,$MATSK
	.GLOBL	$HHENQ,$HIENQ
	.GLOBL	$FQBUF,$RLSCT,$SLL,$LSLST

	$CNFIG
	$DFREG
	$DFCT
	$DISCC
	$DFCCT
	$DFSCC
	$DFHTE
	.CSECT
	.PAGE

	.SBTTL	$IH -- IMP/HOST MESSAGE DEQUE ROUTINE

NIHQEL = 64.		;NUMBER OF HOST/IMP QUEUE ELS
$IH:	$WAIT
	BIT	#ACK,-(R4)
	BEQ	$IH
IHOLE:	MOV	#$IHQ,R2	;GET ADDRESS OF IMP/HOST QUEUE
	JSR	PC,$DEQ		;DEQ MESSAGE
	BEQ	$IH		;WAIT IF QUEUE NULL
	MOV	R0,IHQP		;SAVE MESSAGE QUEUE POINTER
	MOV	R0,-(SP)	;SAVE POINTER TO M Q E
	MOVB	#'R,R1		;INDICATE RECEIVE MSG
	JSR	PC,$DMPMG
	MOV	(SP),R0		;OBTAIN MQE AGAIN
	JSR	PC,IHPRC	;PROCESS IMP-HOST MSG
	TST	IHQP		;HAS ANYONE TAKEN MESSAGE?
	BEQ	IHDROP		;OK, FORGET IT
	MOV	(SP),R0		;GET BASE OF M Q E
	MOV	-(R0),R1	;A(BUFFER)
	MOV	-(R0),R0	;POOLID
	$FREEB			;FREE THE BUFFER
	MOV	(SP)+,R4	;RELOAD BASE OF M Q E
	JSR	PC,$FMQE	;PUT ON FREE MSG Q
	BR	IHOLE		;SCAN THE LIST
IHDROP:	TST	(SP)+		;STRAIGHTEN STACK
	BR	IHOLE		;AND SCAN THE IMP/HOST QUEUE

;			*** IMP/HOST MESSAGE PROCESSOR ***
	.SBTTL	IHPRC -- IMP/HOST MESSAGE PROCESSOR

IHPRC:	MOV	-(R0),R4	;BUFFER ADDRX TO R4
	TST	-(R0)		;SKIP POOLID
	MOV	-(R0),R1	;LENGTH
	MOV	R4,IHMA		;STORE MESSAGE ADDRESS
	MOVB	(R4)+,R0	;SOURCE HOST ID TO R0
	MOVB	(R4)+,R3	;MESSAGE TYPE
	BIC	#177760,R3	;TRIM TO GET INDEX
	ASL	R3		;ON ADDRESS LIST
	JSR	PC,@IHVL(R3)	;CALL PROPER HANDLER
	RTS	PC		;RETURN

IHMA:	.WORD	0		;SAVE AREA FOR BUFFER ADRX
IHQP:	.WORD	0		;SAVE IH MSG QUEUE PTR
IHTE:	.WORD	0		;BASE OF HOST TBL ENTRY
IHCT:	.WORD	0		;BASE OF C.T. ENTRY

HHIM:	.WORD	0		;BASE OF HOST/HOST MSG (OUT)

IHVL:	.WORD	IHREG	; 0	REGULAR MESSAGE
	.WORD	IHERL	; 1	ERROR IN LEADER
	.WORD	IHIGD	; 2	IMP GOING DOWN
	.WORD	IHUD	; 3	UNDEFINED
	.WORD	IHN	; 4	NOP
	.WORD	IHRFN	; 5	RFNM
	.WORD	IHUD	; 6	UNDEFINED
	.WORD	IHDD	; 7	DESTINATION DEAD
	.WORD	IHERD	; 8	ERROR IN DATA
	.WORD	IHICT	; 9	INCOMPLETE XMISSION
	.WORD	IHIRS	; 10	INTERFACE RESET
	.REPT	5
	.WORD	IHUD	; 11-15	UNDEFINED
	.ENDR
	.PAGE

;			*** HOST-HOST REGULAR MESSAGE ***
	.SBTTL	IHREG -- REGULAR MESSAGE PROCESSOR

IHREG:	$PUSH	R4		;SAVE PTR TO LINK
	JSR	PC,$SHL		;GET HTE PTR
	BEQ	IHHR		;UNKNOWN HOST
	MOV	R1,IHTE		;HTE POINTER
	$POP	R4		;RESTORE PTR TO LINK
	MOV	(R4)+,R2	;LINK TO HI BYTE R2
	SWAB	R2		;PUT LINK NR IN LO BYTE
	TSTB	R2		;IS THIS THE CONTROL LINK?
	BEQ	HHICTL		;YUP

;			MESSAGE ON A CONNECTION

	MOVB	R2,R0		;LINK NR TO R0
	MOV	HTECTI(R1),R2	;INPUT CHAIN ON HOST TO R2
	JSR	PC,$FCTBL	;FIND HIS CT
	BEQ	IHMUDL		;UNDEFINED LINK
	$PUSH	R2		;SAVE CT POINTER
	ADD	#CTQ,R2		;GET PTR TO QUEUE
	MOV	IHQP,R0		;MQE TO R0
	CLR	IHQP		;IM TAKING RESPONSIBILITY
	JSR	PC,$ENQ		;BY STICKING HIM ON INPUT QUEUE
	$POP	R2		;CT AGAIN IN R2
	JSR	PC,$RCFLO	;MAINTAIN FLOW CONTROL
IHMUDL:	RTS	PC		;AND RETURN.

IHHR:	$POP	R4		;RECOVER R4
	RTS	PC		;RETURN

;			R4 POINTS TO HH MESSAGE
;			(AFTER LEADER)

;				;R1 IS HTE POINTER
HHICTL:	TST	(R4)+		;ASSUME BYTE SIZE 8 FOR C.L.
	MOV	(R4)+,R2	;BYTE COUNT TO R2
	MOV	R4,-(SP)	;SAVE IT
	MOV	R2,-(SP)	;AND BYTE CNT
	ASR	R2		;GET WORD COUNT
HHSWP:	SWAB	(R4)+
	DEC	R2		;SWAP BYTES IN TXT
	BGE	HHSWP		;LOOP TO SWAP THEM
	MOV	(SP)+,R2
	MOV	(SP)+,R4
	TSTB	(R4)+		;GET ADDR FIRST BYTE
HHNCMD:	MOVB	(R4)+,R3	;GET CODMMAND CODE
	BIC	#177760,R3	;MASK TO GET INDEX
	DEC	R2		;DECREMENT BYTE COUNT
	ASL	R3		;IN WORDS
	JSR	PC,@HHICV(R3)	;TO H-H INPUT INTERPRETER
	MOV	IHTE,R1		;RECOVER HTE POINTER
	TST	R2		;ANY BYTES LEFT?
	BGT	HHNCMD		;BACK TO INTERPRET NEXT COMMAND
	RTS	PC		;BACK TO GET NEXT MSG

HHICV:	.WORD	HHNOP	; 0	NOP
	.WORD	HHRTS	; 1	RTS
	.WORD	HHSTR	; 2	STR
	.WORD	HHCLS	; 3	CLS
	.WORD	HHALL	; 4	ALL
	.WORD	HHGVB	; 5	GVB
	.WORD	HHRET	; 6	RET
	.WORD	HHINR	; 7	INR
	.WORD	HHINS	; 8	INS
	.WORD	HHECO	; 9	ECO
	.WORD	HHERP	; 10	ERP
	.WORD	HHERR	; 11	ERR
	.WORD	HHRST	; 12	RST
	.WORD	HHRRP	; 13	RRP
	.WORD	HHIUN,HHIUN	;  UNDEFINED

HHNOP:	RTS	PC
	.PAGE
NERP = 12		;CODE FOR ECHO REPLY
NRRP = 15		;CODE FOR RESET REPLY

REPOP:	0		; VALUE OF REPLY OP

	.SBTTL	HHECO -- HOST/HOST ECHO PROCESSOR

HHRST:	MOV	#NRRP,REPOP	; HH RESET --- JUST SEND BACK RRP.
	BR	REPLY

HHECO:	MOV	#NERP,REPOP	; ANSWER ECO WITH ERP.

REPLY:	MOV	R2,-(SP)	;SAVE R2
	MOV	R4,-(SP)	;AND R4
	CLR	R0		;SET POOL 0
	JSR	PC,$ALOCW	;ALLOCATE AND WAIT
	MOV	(SP)+,R4	;RESTORE R4
	MOV	R1,HHIM		;SAVE NEW MSG ADDR
	JSR	PC,HHCLDR	;COPY LEADER TO NEW BUFFER
	MOV	REPOP,(R1)+	;SETUP REPLY OP
	MOVB	(R4)+,1(R1)	;AND ECHO REPLY DATA
	BISB	#200,(R1)	;SETUP PADDING
	MOV	R4,-(SP)	;SAVE R4
	MOV	HHIM,R1		;LOAD BASE OF MESSAGE
	CLR	R0		;INDICATE POOL 0
	MOV	#6,R2		;COUNT (WORDS)
	JSR	PC,$MQFMT	;GET A MSG QUEUE EL AND FORMAT IT
	MOV	R4,R0		;SETUP FOR ENQ
	MOV	IHTE,R1		;GET HTE ADDR
	CLR	R2		;INDICATE CONTROL LINK
	JSR	PC,HHENQ	;PLACE ON QUEUE
	MOV	(SP)+,R4	;RESTORE R4
	MOV	(SP)+,R2	;AND R2
	DEC	R2		;INDICATE NR ADDNL BYTES TAKEN
	RTS	PC		;RETURN TO INTERPRETER

HHRRP:	RTS	PC
HHERP:
HHGVB:
HHRET:
HHERR:
HHIUN:	CLR	R2		;DISCARD HH MSG
	RTS	PC

HHINR:
HHINS:	INC	R4		;SKIP LINK #
	DEC	R2		;DECREASE BYTE COUNT
	RTS	PC		;AND RETURN


IHERL:	RTS	PC
IHIGD:	RTS	PC
IHN:	RTS	PC
IHUD:	RTS	PC
IHERD:	RTS	PC

;			***  IHIRS  ***

;			IMP-HOST INTERFACE-RESET
;			PROCESSOR.  INITIALIZES IMP-HOST
;			CONNECTION

IHIRS:	CLRB	$DEAD		;GO TO LIVE STATUS

	MOV	#4.,HINCNT	;HOST/IMP NOP COUNT=4
HINIT:	JSR	PC,$SINOP	;SEND AN IMP NOP MESSAGE
	DEC	HINCNT		;DECREMENT HOST/IMP COUNT
	BGT	HINIT		;INIT HOST/IMP CONNECTION
	MOV	#$HLIST,R1	;RESET ALL HOSTS WE KNOW ABOUT
	MOV	(R1)+,R4	;HTE ENTRY LENGTH
;			*** TEMP  ***
	MOV	(R1)+,R2	;NUMBER OF ENTRIES
	MOV	#7.,R2	;	*** TEMP  ***
SRS00:	$PUSH	R1,R2,R4	;SAVE HTE PTR, TALLY, ENTSIZ
	MOV	@R1,R0		;GET HOSTID IN R0
	JSR	PC,$SNDRS	;RESET THE HOST
	$POP	R4,R2,R1	;RESTORE REGS
	ADD	R4,R1		;ADVANCE TO NEXT HTE
	DEC	R2		;CHECK TALLY
	BGT	SRS00		;AND LOOP FOR ALL OF THEM
	RTS	PC
HINCNT:	.WORD	0		;HOST/IMP NOP COUNT
	.PAGE
	.SBTTL	IHRFN -- IMP-HOST RFNM PROCESSOR

IHRFN:	$PUSH	R4		;SAVE CURRENT HH MSG ADDR
;				;HOST ID IS IN R0
	JSR	PC,$SHL		;FIND HTE ADDR
	BEQ	IHRFNR		;BR IF HE DOESNT EXIST
	MOV	R1,IHTE		;SAVE HIS HTE PTR
	$POP	R4		;RESTORE POINTER TO LINK
	MOV	(R4)+,R0	;GET LINK CODE
	SWAB	R0		;PUT LINK IN LOW BYTE
	TSTB	R0		;IS IT CONTROL LINK?
	BEQ	HRFCTL		;YES, PROCESS RFNM ON C.L.
	MOV	HTECTO(R1),R2	;SET HEAD OF OUTPUT LINKLIST
	JSR	PC,$FCTBL	;FIND CT ENTRY BY LINK ID
	BEQ	IHRFR2		;CANT FIND HIM
;				ITS A RFNM ON A CONNECTION
	MOV	R2,IHCT		;SAVE CT POINTER
	MOV	CTMQA(R2),R4	;GET OLD MQE POINTER IN R4
	BEQ	IHRFNU		;AVOID IMP ERROR
	JSR	PC,IHRFQ	;GO FREE OLD QUEUE ELEMENT
	MOV	IHCT,R2		;RESTORE CT POINTER
	MOVB	CTSTAT(R2),R3	;GET CONN STATE
	BIC	#177760,R3	;MASK OFF EXTRANEOUS BITS
	ASL	R3		;GET OFFSET IN WORDS
	JSR	PC,@IHRFTB(R3)	;JUMP TO RFNM PROCESSOR
IHRFNU:	RTS	PC		;RETURN
IHRFNR:	$POP	R4		;RESET STACK
	RTS	PC		;RETURN

;				BRANCH-TABLE FOR RFNM

IHRFTB:	.WORD	IHRFNU,IHRFNU,IHRFNU,IHRFNU
	.WORD	IHRFN4,IHRFN5,IHRFN6
	.WORD	IHRFNU,IHRFNU,IHRFNU

;				RFNM RCD FOR OPEN CONNECTION

IHRFN6:	ADD	#CTQ,R2		;ADD OFFSET TO QUEUE
	JSR	PC,$DEQ		;FETCH NEXT MSG TO BE SENT
	BEQ	IZRNNQ		;NONE IN QUEUE
	MOV	IHCT,R2		;CT POINTER TO R2
	MOV	R0,CTMQA(R2)	;NEW MQE POINTER ACTIVE
	JSR	PC,HIENQ	;PUT ON HOST-IMP QUEUE
	RTS	PC
IHRNNQ:	MOV	IHCT,R2		;OBTAIN BASE OF CT AGAIN
	CLR	CTMQA(R2)	;CLEAR INDICATOR INDIC ACTIVE
	JSR	PC,$SNFL2	;PROCESS FLOW CONTROL
IHRFR2:	RTS	PC		;AND RETURN

HRFCTL:	MOV	HTMQA(R1),R4	;SETUP TO FREE OLD ACTIVE QUEUE
	BEQ	IHRFNU		;NO FREE NONEXIST MQE
	JSR	PC,IHRFQ	;FREE IT (MQE IS IN R4)
	MOV	IHTE,R2		;GET HTE PTR IN R2
	ADD	#HTCLQ,R2	;OBTAIN BASE CTRL LINK Q IN R2
	JSR	PC,$DEQ		;ANY NEW ENTS
	BEQ	HRF02
	MOV	IHTE,R1		;OBTAINE HTE PTR AGAIN
	MOV	R0,HTMQA(R1)	;NEW ACTIVE PTR FOR CTRL LINK
	JSR	PC,HIENQ	;GOT ONE, STICK ON HOST/IMP QUEUE
	RTS	PC			;AND RETURN

HRF02:	MOV	IHTE,R1		;OBTAIN HTE ADDR AGAIN
	CLR	HTMQA(R1)	;INDIC NO ACTIVE ENTRY
IHRFN5:		;RFNM RCD IN RFNM-WAIT STATE
IHRFN4:		;RFNM RECEIVED IN DATA-WAIT STATE
	RTS	PC		;AND RETURN

IHRFQ:	$PUSH	R4		;FREE MQE, SAVE MQE POINTER
	MOV	-(R4),R1	;GET BUFFER ADDRESS
	MOV	-(R4),R0	;AND POOLID
	$FREEB			;FREE THE BUFFER
	$POP	R4		;RECOVER MQE
	JSR	PC,$FMQE	;FREE MSG QUEUE EL
	RTS	PC		;AND RETURN
	.PAGE
	.SBTTL	IHICT -- INCOMPLETE TRANSMISSION PROCESSOR

;			***  IHICT  ***

;			RECEIVES CONTROL ON A TYPE
;			9 IMP-HOST MESSAGE (INCOMPLETE
;			TRANSMISSION).  TAKES
;			MESSAGE WHICH WAS ACTIVE
;			AND RE-TRANSMITS IT BY PLACING
;			IT ON THE HOST/IMP QUEUE
;			THROUGH A CALL TO $HIENQ.


IHICT:	$PUSH	R4		;SAVE PTR TO MESSAGE
	JSR	PC,$SHL		;SEARCH FOR HTE POINTER
	BEQ	IHRFNR		;TO RFNM ERROR ABORT
	MOV	R1,IHTE		;SAVE HTE POINTER
	$POP	R4		;RELOAD MSG POINTER
	MOV	(R4)+,R0	;GET LINK IN R0
	SWAB	R0
	TSTB	R0		;SEE IF ITS CONTROL LINK
	BEQ	IHICTL		;YES, RE-TRANSMIT CTRL LINK
	MOV	HTECTO(R1),R2	;GET BEGINNING OUT CONN. LIST
	JSR	PC,$FCTBL	;FIND OUT CONN W/ THIS LINK
	BEQ	IHICT2		;CANT FIND
	MOV	R2,IHCT		;CT POINTER TO SAVE
	MOV	CTMQA(R2),R0	;PUT BACK ON HOST IMP QUEUE
IHICT3:	BEQ	IHICT2		;AVOID IMP ERRORS
	JSR	PC,$HIENQ	;ENQ IT
IHICT2:	RTS	PC		;AND RETURN

IHICTL:	MOV	HTMQA(R1),R0	;GET MQE PTR FOR CTRL LINK
	BR IHICT3		;BACK TO STICK ON HOST/IMP QUEUE
	.PAGE
	.SBTTL	IHDD -- IMP HOST 'DESTINATION DEAD'

IHDD:	$PUSH	R4		;SAVE PTR TO MSG
	JSR	PC,$SHL		;FIND HTE
	BEQ	IHDDRT		;UNDEFINED HOST, FORGET
	MOV	@SP,R4		;GET PTR TO MSG
	MOV	(R4),R0		;SUBTYPE FIELD TO R0
	$PUSH	R0,R1		;SAVE SUBTYPE, HTE PTR
	MOV	R1,R2		;HTE PTR TO R2
IHD00:	ADD	#HTCLQ,R2	;GET BASE OF CNTRL LINK Q
	JSR	PC,$DEQ		;FETCH ANY ENTS IF THEY EXIST
	BEQ	IHF002		;AREN'T ANY
	JSR	PC,$FQBUF	;FREE MQE AND ITS ASSOC BUF
	MOV	@SP,R2		;HTE PTR TO R2
	BR	IHD00		;LOOP TO FREE ALL MSGS ON CLQ
IHF002:	MOV	@SP,R1		;HTE PTR
	MOV	HTMQA(R1),R0	;FREE ANY ACTIVE QUEUE ENT IF SO
	BEQ	IHD01		;NOPE
	CLR	HTMQA(R1)	;CLEAR ACTIVE PTR
	JSR	PC,$FQBUF	;FREE MQE AND ITS BUF
IHD01:	$POP	R1,R0		;POP HTE AND SUBTYPE
	BIC	#177776,R0	;CLEAR ALL BUT LOW BIT
	MOV	HTECTI(R1),R2	;GET PTR TO INPUT CONNECTIONS
	BEQ	IHPNXT		;NO INPUTS
	CLR	HTECTI(R1)	;INDIC NO MORE INPUT CONNS
	JSR	PC,IHDNX0	;FREE (CLOSE) INPUT CONNS
IHPNXT:	MOV	HTECTO(R1),R2	;ANY OUTPUT CONNS?
	BEQ	IHPNX2		;NOPE
	CLR	HTECTO(R1)	;INDIC NO MORE OUTPUT CONNS
	JSR	PC,IHDNX0	;RELEASE OUTPUT CONNS
IHPNX2:
IHDDRT:	$POP	R4		;RESTORE PTR TO MSG
	RTS	PC		;AND RETURN

IHDNX0:	$PUSH	R0,R1,R2	;SAVE REGS
IHDNX1:	CLRB	CTSTAT(R2)	;CLOSE CONN
	MOV	CTPCT(R2),R4	;PCT ASSOC?
	BEQ	IHDNP		;NO
	$POST	R4,#RDY+ACK	;POST ASSOC PROCESS
IHDNP:	$POP	R2	;RESTORE
	MOV	CTCCT(R2),R3	;CCT ASSOC?
	BEQ	IHDNSC		;NO
	MOVB	#WCCID,CCTCC(R3)	;SET COMPL CODE
	BISB	2(SP),CCTCC(R3)
IHDNSC:	$PUSH	(R2)		;SAVE PTR TO NEXT
	JSR	PC,$RLSCT	;RELEASE CT ENTRY
	MOV	@SP,R2		;GET NEXT CT IN CHAIN
	BNE	IHDNX1
	$POP	R2,R1,R0		;RESTORE REGS
	RTS	PC


	.PAGE
	.SBTTL	HHRFC -- HOST/HOST INPUT RFC PROCESSOR

;			INPUT R1 = HT POINTER



HHRTS:
HHSTR:
HHRFC:	MOV	#9.,R3		;SETUP FOR COPY
	SUB	R3,R2		;DECREMENT BYTE COUNT
	$PUSH	R2		;AND SAVE IT
	MOV	#RFMSYS,R0	;ADDR FOR COPY
RFC0:	MOVB	(R4)+,(R0)+	;TO TEMP AREA
	DEC	R3		;TALLY
	BGT	RFC0
	$PUSH	R4		;SAVE MSG POINTER
	SWAB	RFMSYS		;SWAP BACK FGN SCK
	SWAB	RFMSYS+2
	SWAB	RFMSYS+6	;AND LOW WORD LCL SCK
	TST	RFMSYS+4	;TEST VALIDITY
	BNE	RFCR	;RETURN, INVALID LCL SCK
	MOV	RFMSYS+6,R0	;GET LCL SCK ID
	JSR	PC,$SLL		;SEE IF SOCK IS LISTENING
	BNE	RFCMLS		;YES, PLACE IN RULING STATE
	MOV	RFMSYS,R3	;PERFORM COMPARE
	MOV	RFMSYS+2,R4	;OF BOTH LCL, FGN SOCKS
	JSR	PC,$MATSK	;MATCH THEM
	BEQ	RFC01		;BRCH IF NO LUCK
RFSIM1:	MOV	R2,IHCT	;SET CT
	MOVB	CTSTAT(R2),R3	;GET CT STATUS
	BIC	#177760,R3	;TRIM BITS
	ASL	R3		;GET BRANCH INDEX
RFSIM0:	JSR	PC,@RFCTB(R3)	;JUMP TO CORRECT INTERPRETER
RFCR:	$POP	R4,R2		;RESTORE MSG PTR, BYTE COUNT
	RTS	PC		;TO HERE TO RETURN

RFC01:	JSR	PC,$BLDCT	;BUILD A CT
	BR	RFSIM1		;GO SIMULATE STATE 0

RFCMLS:	MOV	(R2),(R3)	;DELETE FROM LISTEN LIST
	ROR	R0		;SEND OR RECEIVE ?
	BCS	RFSNDL		;BRCH IF SEND
	MOV	HTECTI(R1),(R2)	;INSERT ON INPUT QUEUE
	MOV	R2,HTECTI(R1)
RFC22:	MOV	R1,CTHTA(R2)	;SET HTE POINTER IN CT
	MOV	CTCCT(R2),R0	;GET CCT ADDRESS
	MOV	RFMSYS,CCTFGN(R0)	;AND COPY FGN SOCK
	MOV	RFMSYS+2,CCTFGN+2(R0) ;TO CCT
	MOV	(R1),(R0)	;AND SET CALLER'S HOSTID
	BR	RFSIM1		;CARRY ON WITH FORMER LISTENER

RFSNDL:	MOV	HTECTO(R1),(R2)	;STICK ON OUTPUT CT QUEUE
	MOV	R2,HTECTO(R1)	;AND UPDATE QUEUE HEAD
	BR	RFC22		;BACK TO PUT SCKS IN CCT.

;			*** BRANCH TBL  ***
;			*** FOR RFC     ***

RFCTB:	.WORD	RFPND		;0 (CLOSED) GO TO PENDING CALLS
	.WORD	RFRUL		;1 (LISTEN) GO TO RULING
	.WORD	RFNUL,RFNUL,RFNUL,RFNUL,RFNUL	;SENSELESS
	.WORD	RFOPN		;7 (CONNECT) GO TO OPEN
	.WORD	RFNUL,RFNUL	;SENSELESS STATE TRANSITIONS

RFPND:	JSR	PC,$ICT		;INIT CT
	MOVB	#10,R0		;SET CONN STATE TO PENDING CALLS
	JSR	PC,$ETCST	;CALL STATE SETTER
	JSR	PC,RFCSCK	;SETUP SOCKETS IN CT
	RTS	PC		;AND RETURN
RFCSCK:	MOV	RFMSYS,CTFGN(R2)	;SET FGN SCK
	MOV	RFMSYS+2,CTFGN+2(R2)	;IN CT
	RORB	RFMSYS+2	;CHECK GENDER OF FGN SCK
	BCS	RFSTR		;IF 1, WAS STR OP
	MOVB	RFMSYS+10,CTLINK(R2)	;SETUP LINK NR
	RTS	PC		;RETURN
RFSTR:	MOVB	RFMSYS+10,CTBSIZ(R2)	;SETUP BYTE SIZE
	RTS	PC
RFRUL:	JSR	PC,$ICT		;INIT ALLOCATION PARAMS
	MOV	#2,R0		;GO TO RULING STATE
	JSR	PC,$ETCST	;SET THE STATE
	JSR	PC,RFCSCK	;SETUP SOCKETS
RFPOS:	MOV	CTCCT(R2),R3	;GET CCT ADDR
	BEQ	RCNRTS
	MOVB	#WCCCMP,CCTCC(R3)	;SET CONDITION CODE
	$POST	CTPCT(R2),#RDY+ACK	;POST CALLER TO RULE
RCNRTS:	RTS	PC
RFOPN:	JSR	PC,$ICT		;INIT CT ALL PARAMS
	MOV	#6,R0		;GO TO OPEN STATE
	JSR	PC,$ETCST	;TO SET STATE
	JSR	PC,RFCSCK	;AND SET OPEN LINK OR B.S.
	BR	RFPOS	;POST CCT AND WAITING PRC


RFNUL:	RTS	PC


	.PAGE
	.SBTTL	HHCLS -- CLS PROCESSOR

HHCLS:	MOV	#8.,R3	;BYTE COUNT
	SUB	R3,R2		;DECREMENT REMAINING
	$PUSH	R2		;AND SAVE IT
	MOV	#RFMSYS,R0	;ADDR OF WORK SPACE
CLS0:	MOVB	(R4)+,(R0)+	;MOVE SCKS TO WORK SPC
	DEC	R3		;TALLY
	BGT	CLS0
	$PUSH	R4		;NOW SAVE CURRENT MSG PTR
	SWAB	-(R0)		;SWAP LCL SCK
	TST	-(R0)		;SHOULD BE 0
	SWAB	-(R0)		;FGN SCK, WD 1
	MOV	@R0,R4		;TO REG 4
	SWAB	-(R0)		;SWAP FGN SCK, WD 0
	MOV	@R0,R3		;AND BACK OFF...
	MOV	6(R0),R0	;PUT LCL SCK IN R0
	JSR	PC,$MATSK	;FIND MATCHING PAIR
	BEQ	CLSB		;NOP, CANT FIND MATCH
	MOV	R2,IHCT		;SET CONN TBL
	MOVB	CTSTAT(R2),R3	;SETUP TO BRANCH THRU TBL
	BIC	#177760,R3	;SETUP TO BRNCH
	ASL	R3		;THRU STATE TABLE
	JSR	PC,@CLSTB(R3)	;OFF WE GO
CLRTS:	$POP	R4,R2		;RESTORE MSG CNT
CLSNL:	RTS	PC		;AND RETURN
CLSB:	MOV	@IHTE,R0		;HOST ID TO R0
	MOV	#RFMSYS,R1		;INPUT SCK SPECIFIERS
	JSR	PC,$SBCLS		;SEND A MATCHING CLS
	BR	CLRTS			;POP STACK AND RETURN


;			***  CLS  ***
;			*** BRANCH ***
;			*** TABLE ***

CLSTB:	.WORD	CLSNL,CLSNL	;NULL (CLOSED, LISTEN)
	.WORD	CLSCLS		;CLOSE IT (RULING)
	.WORD	CLSW1		;CLOSE WAIT
	.WORD	CLSS5		;DATA WAIT - TRANSIT TO DRAIN WT.
	.WORD	CLSNL		;INVALID WHEN IN DRAIN-WAIT (5)
	.WORD	CLSRS		;RCV/SND
	.WORD	CLSCLS		;CLOSED (CONNECT)
	.WORD	CLSCL2		;PENDING
CLSCLS:
CLSCL2:	CLR	R0		;INDICATE CLS OPERATION
	$PUSH	R2		;SAVE CT POINTER
	JSR	PC,$RFCLS	;ISSUE CLS TO CT
	$POP	R2		;RESTORE CT PTR
CLSW1:	CLRB	CTSTAT(R2)	;INDICATE CLOSED
	$PUSH	R2		;SAVE CT PTR
	MOV	CTPCT(R2),R0	;SEE IF PCT DEFINED
	BEQ	CLSNP		;IF NOT, NO POST REQUIRED
	$POST	R0,#RDY+ACK	;POST ASSOC. PROCESS
CLSNP:	$POP	R2		;RESTORE CT
	MOV	CTCCT(R2),R0	;RECOVER CCT PTR
	BEQ	CLSRTS		;RTS IF NO CCT
	MOVB	#WCCCLS,CCTCC(R0)	;SET CMPL CODE IN CCT
CLSRTS:	RTS	PC		;AND RETURN




CLSRS:	BITB	#1,CTLCL(R2)	;SEND SOCKET?
	BEQ	CLSCLR		;IF RECEIVER, CHECK DATA RECD.
	TST	CTMQA(R2)	;IF SND SOCK, SEE IF RFNM AWAITED
	BEQ	CLSCL2		;IF NOT, SEND CLS AND GO ST 0.
CLSS5:	MOV	#5,R0		;GO TO STATE 5
	JSR	PC,$ETCST	;SET STATUS
	RTS	PC		;RETURN
CLSCLR:	TST	CTBCI(R2)	;RECEIVER EXHAUSTED DATA
	BEQ	CLSCL2		;YEAH, RETURN CLS AND GO ST 0.
	BR	CLSS5		;RECEIVER GOES TO ST 5 WAIT
;				(REMAINS IN DATA-WAIT
;				UNTIL RECEIVER TAKES ALL
;				OUTSTANDING DATA)

	.PAGE
	.SBTTL	ALL PROCESSOR

HHALL:	MOV	#7,R3		;SET NR BYTES TO EAT
	SUB	R3,R2		;DECREMENT REM CNT IN MSG
	$PUSH	R2		;SAVE FOR INTERPRETER
	MOVB	(R4)+,R0	;GET LINK NUMBER
	$PUSH	R4		;SAVE POINTER TO STRING
	MOV	HTECTO(R1),R2	;SETUP FOR FIND CT ENTRY
	JSR	PC,$FCTBL	;BY LINK NR (OUTPUT)
	BEQ	ALLAB		;ABORT, LINK NOT DEFINED
	MOV	#6,R3		;REMAINING COUNT IN R3
	$POP	R4		;RECOVER POINTER TO STRING
	MOV	#RFMSYS,R0	;ADDRX OF WORK AREA
ALL0:	MOVB	(R4)+,(R0)+		;MOVE DATA TO ALIGN
	DEC	R3		;ON WORD BOUNDARY
	BGT	ALL0
	$PUSH	R4		;SAVE PTR TO STRING
	SWAB	RFMSYS		;SWAB BYTES
	ADD	RFMSYS,CTMCT(R2)	;INCREMENT MESSAGE COUNT
	MOV	RFMSYS+2,R3
	MOV	RFMSYS+4,R4	;SETUP TO INCREMENT BIT COUNT
	SWAB	R3
	SWAB	R4		;HAVE TO SWAP BIT COUNTS
	JSR	PC,$INCAL	;INCREASE ALLOCATION
	JSR	PC,$SNFL1	;ENABLE FLOW CONTROL
	$POP	R4,R2		;RESTORE POINTERS
	RTS	PC		;AND RETURN CONTROL TO INTERP

ALLAB:	$POP	R4,R2
	ADD	#6,R4		;BUMP PASE MCT, BITCT
	RTS	PC

RFMSYS:	.WORD	0,0,0,0,0	;HH RFC FROM FGN HOST

HHCLDR:	MOV	IHMA,R3		;FORMAT LEADER
	MOV	(R3)+,(R1)+		;FROM INPUT MSG
	MOV	(R3)+,(R1)+	;NEXT...
	MOV	(R3)+,(R1)+	;UP TO COUNT WORD IN HH MESSAGE
	MOV	(R3)+,(R1)+
	RTS	PC


;			*** HOST-IMP/IMP-HOST QUEUES
	.SBTTL	$IHQ,$HIQ -- IMP/HOST, HOST/IMP QUEUES

$LSLST:	.WORD	0	;QUEUE OF LISTENING LOCAL SOCKETS
$IHQ:	.WORD	0,0	;IMP/HOST QUEUE (HEAD,TAIL)
$HIQ:	.WORD	0,0	;HOST/IMP QUEUE (HEAD,TAIL)
	.NLIST	ME
$IQF:	.WORD	FREEQ
	.WORD	0,0,0
FREEQ:	.WORD	.+10
	.REPT	NIHQEL-1
	.WORD	0,0,0
	.WORD	.+10
	.ENDR
	.WORD	0,0,0,0
	.SBTTL	HIENQ -- PLACE ENTRY ON HOST/IMP QUEUE

;			***  HIENQ  ***

;			ASSUMES R0 = MESSAGE QUEUE ADDR


$HIENQ:
HIENQ:	$PUSH	R0	;SAVE MQE PTR
	MOV	R0,R1
	MOV	-(R1),R1
	TST	(R1)
	BNE	NOH
	TST	R1
NOH:	MOV	#'S,R1	;FLAG SEND MSG
	JSR	PC,$DMPMG	;DUMP MSG
	$POP	R0	;RESTORE MQE POINTER
	MOV	#$HIQ,R2		;SETUP QUEUE ADDR
	JSR	PC,$ENQ			;PLACE IN HOST/IMP QUEUE
	$POST	#$PCTRO+2,#RDY+ACK	;POST IMPOUTPUT FOR WORK
	RTS	PC			;RETURN

;			***  HHENQ  ***

;			PLACE A MSG QUEUE ELEMENT
;			ON HOST MSG QUEUE
;			ASSUMES
;			R0 = A(MSG QUEUE ELEMENT)
;			R1 = A(HTE)
;			R2 = A (CT)  IF LINK NE 0
;			R2 = 0       IF LINK EQ 0

$HHENQ:
HHENQ:	TST	R2		;CONTROL LINK?
	BNE	HHQCON		;NO, ITS FOR A CONNECTION
;			*** ITS FOR THE CONTROL LINK ***
	TST	HTMQA(R1)	;RFNM-AWAITED ON C.L. ?
	BNE	HHQNQ		;YES, PLACE ON CTRL LLINK QUEUE
	MOV	R0,HTMQA(R1)	;SAVE ADDRX OF MQE ACTIVE
HHNQ2:	JSR	PC,HIENQ	;ALL CLEAR, QUEUE FOR IMP
	RTS	PC

HHQNQ:	MOV	R1,R2		;COMPUTE CONTROL LINK Q ADR
	ADD	#HTCLQ,R2
HHNQ3:	JSR	PC,$ENQ		;PLACE ON QUEUE
	RTS	PC		;AND RETURN

HHQCON:	TST	CTMQA(R2)	;SEE IF RFNM-AWAITED ON CONN.
	BEQ	HHNQ4		;NO, SET NEW MQE ACTV AND PUT IN Q
	ADD	#CTQ,R2		;GET ADDR OF CONNECTION QUEUE
	BR	HHNQ3		;ENQUEUE FOR CONNECTION

HHNQ4:	MOV	R0,CTMQA(R2)	;INDIC RFNM-AWAITED
	BR	HHNQ2


	.END


