
<BLOCK <ROOT>>

PACKAGE 

RPACKAGE 

ENTRY 

EXTERNAL 

USE

USE-TOTAL 

DROP 

NULL-OBLIST

ENDPACKAGE 

FILSTR

FILPRS

L-SEARCH-PATH

L-SECOND-NAMES

L-TEMP-PATH 

L-LOAD 

L-DOITEM 

L-ITEMS-NAME 

L-INDEX-NAME 

L-DATUM 

USE-DATUM 

L-NO-FILES

L-NO-MAGIC 

L-ALWAYS-INQUIRE 

L-HANDLER 

L-UNUSE 

L-FIND 

USE-DEFER 

L-GASSIGNED? 

L-NO-DEFER 

L-NOISY 

INDENT-TO

L-TRANSLATIONS

TRANSLATE

UNTRANSLATE

<MOBLIST PACKAGE 29>

<MOBLIST PKG!-PACKAGE 17>

<SETG OBLIST (<GET INITIAL OBLIST> <ROOT>)>

<BLOCK (<MOBLIST IPKG!-PKG!-PACKAGE 23>
	<GET PKG!-PACKAGE OBLIST>
	<ROOT>)>

<SETG PKG!-PACKAGE .OBLIST>

<SETG PKG-OB <GET PACKAGE OBLIST>>

<SETG COL-OB <MOBLIST RPACKAGE 7>>

<SET L-SEARCH-PATH '("LIBMUD" "LIBMUD;LIBMUD" [] ["MBPROG"] ["MPROG" ">"])>

<SETG L-SECOND-NAMES '["FBIN" "GBIN" "NBIN" ">"]>
<GDECL (L-SECOND-NAMES) VECTOR>

<SETG L-ITEMS-NAME "ITEMS">

<SETG L-INDEX-NAME "INDEX">

<SETG L-NO-FILES <>>

<SETG L-NOISY T>

<SET L-TEMP-PATH <>>

<SETG L-TRANSLATIONS ()>

<SETG L-NULL-TRANS ()>

<DEFINE FILSTR ("TUPLE" T "AUX" (CHN <CHANNEL "READ" !.T>))
  #DECL ((VALUE) STRING (T) <TUPLE [REST STRING]> (CHN) CHANNEL)
  <STRING <9 .CHN> !\: <10 .CHN> !\; <7 .CHN> !\  <8 .CHN>>>

<DEFINE FILPRS (FIL "AUX" (CHN <CHANNEL "READ" .FIL>))
  #DECL ((VALUE) <LIST [REST STRING]> (FIL) STRING (CHN) CHANNEL)
  (<7 .CHN> <8 .CHN> <9 .CHN> <10 .CHN>)>

<DEFINE FIND/LOAD (STR
		   "OPTIONAL" (L <OR .L-TEMP-PATH .L-SEARCH-PATH>)
		   "AUX" CHN TMP (OUTCHAN ,OUTCHAN) (L-TEMP-PATH <>)
		   (OBLIST .OBLIST) TSTR TEMP)
	#DECL ((STR) STRING (L) LIST (OUTCHAN) <SPECIAL CHANNEL>
	       (L-TEMP-PATH) <SPECIAL ANY> (TSTR) <OR STRING FALSE>
	       (TEMP) <OR LIST FALSE>)
	<COND (<SET TEMP <TRANSLATE? .STR>>
	       <SET TSTR <1 .TEMP>>)
	      (<SET TSTR .STR>)>
	<COND (<AND .TSTR <SET TMP <LOOKUP .TSTR ,PKG-OB>> <GASSIGNED? .TMP>>
	       .TMP)
	      (<SET CHN <SEARCH .STR .L>>
	       <COND (,L-NOISY
		      <PRINC "/">
		      <PRINC .STR>
		      <COND (<N==? .STR .TSTR>
			     <PRINC !\=>
			     <COND (<NOT .TSTR>
				    <PRINC "<>">)
				   (<PRINC .TSTR>)>)>
		      <PRINC !\ >)>
	       <UNWIND
		<PROG ()
		  <LOAD .CHN>
		  <COND (.TSTR
			 <OR <LOOKUP .TSTR ,PKG-OB>
			     <PROG ()
				   <SET TMP <INSERT .STR ,PKG-OB>>
				   <SETG .TMP .OBLIST>
				   .TMP>>)
			(T)>>
		<PROG (PCK (LN ,L-NULL-TRANS))
		  #DECL ((PCK) <OR ATOM FALSE> (LN) <LIST [REST <OR ATOM FALSE>]>)
		  <COND (<NOT <0? <1 .CHN>>> <CLOSE .CHN>)>
		  <COND (<AND <SET PCK <GET .OBLIST IN-COLLECTION>>
			      <=? .TSTR <SPNAME .PCK>>>
			 <PUT .OBLIST IN-COLLECTION>
			 <SETG L-NULL-TRANS <REST .LN>>
			 <ENDBLOCK>)
			(<1 .LN>
			 <SETG L-NULL-TRANS <REST .LN>>)>>>)
	      (T .CHN)>>

<DEFINE SEARCH (IND L)
  #DECL ((L) <LIST [REST <OR STRING VECTOR>]>)
  <REPEAT SEARCH (CH SPEC DIR (L-NO-FILES ,L-NO-FILES))
    #DECL ((CH) <OR CHANNEL FALSE> (SPEC) <OR STRING VECTOR>
	   (SEARCH) ACTIVATION)
    <COND (<EMPTY? .L> <RETURN <>>)>
    <COND (<TYPE? <SET SPEC <1 .L>> STRING>
	   <COND (<SET CH <AND <GASSIGNED? GDCHN>
			       <GDCHN .IND .SPEC ,L-ITEMS-NAME>>>
		  <RETURN .CH>)>)
	  (<NOT .L-NO-FILES>
	   <COND (<OR <EMPTY? .SPEC>
		      <NOT <1 .SPEC>>>
		  <SET DIR <SNAME>>)
		 (<SET DIR <1 .SPEC>>)>
	   <COND (<LENGTH? .SPEC 1>
		  <SET SPEC ,L-SECOND-NAMES>)
		 (<SET SPEC <REST .SPEC>>)>
	   <MAPF <>
	     <FUNCTION (X) #DECL ((X) STRING)
	       <COND (<SET CH <OPEN "READ" .IND .X "DSK" .DIR>>
		      <RETURN .CH .SEARCH>)>>
	     .SPEC>)>
    <SET L <REST .L>>>>

<DEFINE PACKAGE (NAME
		 "OPTIONAL" (INAME .NAME) (SIZE 19) (ISIZE 23)
		 "EXTRA" TNAME ATM IATM OBL IOBL TMP)
	#DECL ((NAME INAME) STRING (SIZE ISIZE) FIX (ATM IATM VALUE) ATOM
	       (OBL IOBL) OBLIST (TNAME) <OR FALSE STRING>)
	<COND (<SET TMP <TRANSLATE? .NAME>>
	       <SET TNAME <1 .TMP>>)
	      (<SET TNAME .NAME>)>
	<COND (.TNAME
	       <COND (<==? .INAME .NAME> <SET INAME <STRING !\I .TNAME>>)>
	       <SET ATM
		    <OR <LOOKUP .TNAME ,PKG-OB> <INSERT .TNAME ,PKG-OB>>>
	       <SET OBL <MOBLIST .ATM .SIZE>>
	       <SET IATM <OR <LOOKUP .INAME .OBL> <INSERT .INAME .OBL>>>
	       <SET IOBL <MOBLIST .IATM .ISIZE>>
	       <BLOCK <SETG .ATM <SET TMP (.IOBL .OBL <ROOT>)>>>
	       <PUT .ATM IOBLIST .IATM>
	       <PUT .TMP IN-COLLECTION .ATM>
	       <SETG L-NULL-TRANS (<> !,L-NULL-TRANS)>
	       .ATM)
	      (<SETG L-NULL-TRANS (T !,L-NULL-TRANS)>
	       T)>>

<DEFINE RPACKAGE (NAME
		  "OPTIONAL" (INAME .NAME) (ISIZE 23)
		  "AUX" ATM IATM IOBL TMP TNAME)
	#DECL ((NAME INAME) STRING (ISIZE) FIX (ATM IATM VALUE) ATOM
	       (IOBL) OBLIST (TNAME) <OR FALSE STRING>)
	<COND (<SET TMP <TRANSLATE? .NAME>>
	       <SET TNAME <1 .TMP>>)
	      (<SET TNAME .NAME>)>
	<COND (.TNAME
	       <COND (<N==? .NAME .INAME> <SET INAME  <STRING !\I .NAME>>)>
	       <SET ATM
		    <OR <LOOKUP .TNAME ,PKG-OB> <INSERT .TNAME ,PKG-OB>>>
	       <SET IATM
		    <OR <LOOKUP .INAME ,COL-OB> <INSERT .INAME ,COL-OB>>>
	       <SET IOBL <MOBLIST .IATM .ISIZE>>
	       <BLOCK <SETG .ATM <SET TMP (.IOBL <ROOT>)>>>
	       <PUT .ATM IOBLIST .IATM>
	       <PUT .TMP IN-COLLECTION .ATM>
	       <SETG L-NULL-TRANS (<> !,L-NULL-TRANS)>
	       .ATM)
	      (<SETG L-NULL-TRANS (T !,L-NULL-TRANS)>)>>

<DEFINE ENTRY ("TUPLE" NAMES "AUX" (NAME T))
	#DECL ((VALUE NAME) ATOM (NAMES) <TUPLE [REST ATOM]>)
  <COND (<NOT <1 ,L-NULL-TRANS>>
	 <REPEAT ((OBLIST .OBLIST))
		#DECL ((OBLIST) LIST)
		<COND (<EMPTY? .NAMES> <RETURN .NAME>)>
		<SET NAME <1 .NAMES>>
		<SET NAMES <REST .NAMES>>
		<PUT .NAME USE-DEFER>
		<COND (<NOT <GET .OBLIST IN-COLLECTION>>
		       <ERROR ENTRY NOT-IN-PACKAGE-OR-COLLECTION!-ERRORS>)
		      (<==? <OBLIST? .NAME> <1 .OBLIST>>
		       <INSERT <REMOVE .NAME> <2 .OBLIST>>)
		      (<NOT <==? <OBLIST? .NAME> <2 .OBLIST>>>
		       <ERROR ENTRY .NAME ALREADY-USED-ELSEWHERE!-ERRORS>)>>)
	(T)>>

<DEFINE USE ("TUPLE" NAMES "AUX" (OBLIST .OBLIST) NAME PK OBL N M)
   #DECL ((VALUE) ATOM (NAMES) <TUPLE [REST STRING]> (PK) <OR ATOM FALSE>
	  (NAME) STRING (OBL) <OR FALSE OBLIST> (N M) FIX
	  (OBLIST) <LIST [REST OBLIST]>)
   <REPEAT ()
	   <COND (<EMPTY? .NAMES> <RETURN USE>)>
	   <SET NAME <1 .NAMES>>
	   <SET NAMES <REST .NAMES>>
	   <SET PK <FIND/LOAD .NAME>>
	   <COND
	    (<NOT .PK> <ERROR PACKAGE .NAME NOT-FOUND!-ERRORS>)
	    (<==? .PK T>)
	    (<AND <SET OBL <GET .PK OBLIST>> <NOT <MEMQ .OBL .OBLIST>>>
	     <COND (<NOT <0? <SET N <LENGTH <MEMQ ,PKG-OB .OBLIST>>>>>
		    <PUTREST <REST .OBLIST <- <SET M <LENGTH .OBLIST>> .N 1>>
			     (.OBL !<REST .OBLIST <- .M .N>!>)>)
		   (T
		    <PUTREST <REST .OBLIST <- <LENGTH .OBLIST> 1>> (.OBL)>)>)>>>

<DEFINE USE-TOTAL ("TUPLE" NAMES "AUX" (OBLIST .OBLIST) NAME PK OBL N M)
   #DECL ((VALUE) ATOM (NAMES) <TUPLE [REST STRING]> (PK) <OR ATOM FALSE>
	  (NAME) STRING (OBL) <OR FALSE OBLIST> (N M) FIX
	  (OBLIST) <LIST [REST OBLIST]>)
   <REPEAT ()
	   <COND (<EMPTY? .NAMES> <RETURN USE>)>
	   <SET NAME <1 .NAMES>>
	   <SET NAMES <REST .NAMES>>
	   <SET PK <FIND/LOAD .NAME>>
	   <COND
	    (<NOT .PK> <ERROR PACKAGE .NAME NOT-FOUND!-ERRORS>)
	    (<==? .PK T>)
	    (<AND <SET OBL <GET .PK OBLIST>> <NOT <MEMQ .OBL .OBLIST>>>
	     <COND (<NOT <0? <SET N <LENGTH <MEMQ ,PKG-OB .OBLIST>>>>>
		    <PUTREST <REST .OBLIST <- <SET M <LENGTH .OBLIST>> .N 1>>
			     (.OBL !<REST .OBLIST <- .M .N>!>)>)
		   (T
		    <PUTREST <REST .OBLIST <- <LENGTH .OBLIST> 1>> (.OBL)>)>)>
	<COND
	    (<AND <SET PK <OR	<GET .PK IOBLIST>
				<LOOKUP <STRING !\I <SPNAME .PK>> <GET .PK OBLIST>>>>
			<SET OBL <GET .PK OBLIST>>
			<NOT <MEMQ .OBL .OBLIST>>>
	     <COND (<NOT <0? <SET N <LENGTH <MEMQ ,PKG-OB .OBLIST>>>>>
		    <PUTREST <REST .OBLIST <- <SET M <LENGTH .OBLIST>> .N 1>>
			     (.OBL !<REST .OBLIST <- .M .N>!>)>)
		   (T
		    <PUTREST <REST .OBLIST <- <LENGTH .OBLIST> 1>> (.OBL)>)>)>>>
<SETG L-NO-DEFER <>>

<DEFINE L-GASSIGNED? (ATM "AUX" TMP (L-TEMP-PATH .L-SEARCH-PATH))
	#DECL ((L-TEMP-PATH) <SPECIAL LIST> (TMP) <PRIMTYPE LIST>)
	<COND (<GASSIGNED? .ATM>)
	      (<SET TMP <GET .ATM USE-DEFER>>
	       <SET L-TEMP-PATH <REST .TMP>>
	       <USE <1 .TMP>>
	       <COND (<NOT <GASSIGNED? .ATM>>
		      <ERROR PACKAGE "PACKAGE DID NOT DEFINE FUNCTION">)>
	       T)>>

<SETG EXTERNAL ,USE>

<DEFINE DROP ("TUPLE" NAMES "AUX" NAME PK OBL N)
	#DECL ((VALUE) ATOM (NAMES) <TUPLE [REST STRING]> (PK) <OR ATOM FALSE>
	       (N) FIX (NAME) <OR STRING FALSE> (OBL) <OR FALSE OBLIST>
	       (OBLIST) <LIST [REST OBLIST]>)
	<REPEAT ((OBLIST .OBLIST) TMP)
		#DECL ((OBLIST) LIST (TMP) <OR <LIST <OR STRING FALSE>> FALSE>)
		<COND (<EMPTY? .NAMES> <RETURN DROP>)>
		<SET NAME <1 .NAMES>>
		<SET NAMES <REST .NAMES>>
		<COND (<AND <SET TMP <TRANSLATE? .NAME>>
			    <NOT <SET NAME <1 .TMP>>>>
		       <AGAIN>)>
		<COND (<NOT <SET PK <LOOKUP .NAME ,PKG-OB>>>
		       <ERROR PACKAGE .NAME NOT-PACKAGE-OR-COLLECTION!-ERRORS>)>
		<SET OBL <GET .PK OBLIST>>
		<COND (<NOT <0? <SET N <LENGTH <MEMQ .OBL .OBLIST>>>>>
		       <PUTREST <REST .OBLIST <SET N <- <LENGTH .OBLIST> .N 1>>>
				<REST .OBLIST <+ .N 2>>>)>
		<COND (<AND <SET PK <OR <GET .PK IOBLIST>
					<LOOKUP <STRING !\I <SPNAME .PK>>
						.OBL>>>
			    <SET OBL <GET .PK OBLIST>>>
		       <COND (<NOT <0? <SET N <LENGTH <MEMQ .OBL .OBLIST>>>>>
			      <PUTREST <REST .OBLIST <SET N <- <LENGTH .OBLIST> .N 1>>>
				       <REST .OBLIST <+ .N 2>>>)>)>>>

<SETG NULL-OBLIST <MOBLIST NULL 1>>

<DEFINE ENDPACKAGE ("AUX" (OBLIST .OBLIST)
		    (PK <GET .OBLIST IN-COLLECTION>) IATM OBL VAL
		    (LNT ,L-NULL-TRANS))
	#DECL ((PK) <OR ATOM FALSE> (VALUE) ATOM
		(IATM) <OR ATOM FALSE> (LNT) <LIST [REST <OR ATOM FALSE>]>
		(OBL) <OR OBLIST FALSE>
		(VAL) ANY (OBLIST) <OR OBLIST LIST>)
	<COND (<1 .LNT>
	       <SETG L-NULL-TRANS <REST .LNT>>
	       T)
	      (.PK
		<PUT .OBLIST IN-COLLECTION>
		<ENDBLOCK>
		<SETG L-NULL-TRANS <REST .LNT>>
		<COND (<AND <SET IATM <OR <GET .PK IOBLIST>
					  <LOOKUP <STRING !\I <SPNAME .PK>>
						  <GET .PK OBLIST>>>>
			    <SET OBL <GET .IATM OBLIST>>
			    <MAPF <>
				  <FUNCTION (L)
					    #DECL ((L) LIST)
					    <COND (<EMPTY? .L>)
						  (ELSE <MAPLEAVE <>>)>>
				  .OBL>>
		       <PUT <PUT .IATM OBLIST> OBLIST>
		       <PUT .PK IOBLIST>
		       <COND (<AND <GASSIGNED? .PK>
				   <TYPE? ,.PK LIST>
				   <SET VAL <MEMQ .OBL ,.PK>>>
			      <PUT .VAL 1 ,NULL-OBLIST>)>)>
		.PK)
	      (ELSE
	       <ERROR UNMATCHED-ENDPACKAGE-OR-ENDCOLLECTION!-ERRORS>)>>

<DEFINE L-UNUSE (STR "AUX" TMP IATM)
  #DECL ((STR) <OR STRING FALSE> (TMP) ANY (IATM) <OR ATOM FALSE>)
  <COND (<SET TMP <TRANSLATE? .STR>>
	 <SET STR <1 .TMP>>)>
  <COND (<NOT .STR>)
	(<AND <SET TMP <LOOKUP .STR ,PKG-OB>> <GASSIGNED? .TMP>>
	 <DROP .STR>
	 <COND (<SET IATM <OR <PUT .TMP IOBLIST>
			      <LOOKUP <STRING !\I <SPNAME .TMP>> <GET .TMP OBLIST>>>>
		<PUT <PUT .IATM OBLIST> OBLIST>)>
	 <GUNASSIGN .TMP>
	 <PUT <PUT .TMP OBLIST> OBLIST>
	 <REMOVE .TMP ,PKG-OB>
	 "PACKAGE REMOVED")
	(<SET TMP <LOOKUP .STR ,UDOB>>
	 <REMOVE .TMP ,UDOB>
	 "DATUM REMOVED")
	(T #FALSE ("NOT PACKAGE OR DATUM"))>>

<DEFINE TRANSLATE? (NAME "OPTIONAL" (HAIR? <>) "AUX" (L ,L-TRANSLATIONS))
  #DECL ((NAME) STRING (HAIR?) <OR ATOM FALSE>
	 (L) <LIST [REST STRING <OR STRING FALSE>]>)
  <REPEAT (TEMP)
    <COND (<EMPTY? .L>
	   <RETURN <>>)
	  (<NOT .HAIR?>
	   <COND (<=? <1 .L> .NAME>
		  <RETURN <REST .L>>)>)
	  (T
	   <COND (<AND <==? <MEMBER <SET TEMP <1 .L>> .NAME> .NAME>
		       <==? <MEMBER "!-" .NAME> <REST .NAME <LENGTH .TEMP>>>>
		  <RETURN <REST .L>>)>)>
    <SET L <REST .L 2>>>>

"/*	MAGIC KLUDGE, LOAD SDML HERE, WHERE ENOUGH IS DEFINED, BUT NOT THE
	PART THAT DEPENDS ON SDML, OLD BOOTSTRAPPING PROBLEM	*/"

<EXTERNAL "PMAP" "SDML">

<DEFINE USE-DEFER ("TUPLE" NAMES "AUX" (OBLIST .OBLIST) NAME TMP T1 (POB <>) M N NMLST)
   #DECL ((NAMES) <TUPLE [REST STRING]> (NAME) STRING (M N) FIX
	  (TMP) <PRIMTYPE LIST> (ATMLST) <LIST [REST ATOM]>
	  (NMLST) <SPECIAL LIST> (OBLIST) <LIST [REST OBLIST]>)
   <COND
    (,L-NO-DEFER <USE !.NAMES> USE-DEFER)
    (T
     <REPEAT ()
       <COND (<EMPTY? .NAMES> <RETURN USE-DEFER>)>
       <SET NAME <1 .NAMES>>
       <SET NAMES <REST .NAMES>>
       <COND (<AND <SET T1 <LOOKUP .NAME ,PKG-OB>> <GASSIGNED? .T1>>
	      <SET POB <GET .T1 OBLIST>>)
	     (<NOT <SET TMP
			<GDCHN <STRING <ASCII 127> .NAME>
			       .L-SEARCH-PATH
			       ,L-INDEX-NAME
			       ,SDMGET>>>
	      <ERROR PACKAGE .NAME NOT-FOUND!-ERRORS>
	      <AGAIN>)
	     (<NOT <EMPTY? .TMP>>
	      <SET POB <OBLIST? <PARSE <1 .TMP>>>>
	      <SET NMLST <LIST .NAME !.L-SEARCH-PATH>>
	      <MAPF <>
		    #FUNCTION ((X) <PUT <PARSE .X> USE-DEFER .NMLST>)
		    .TMP>)>
       <COND (<AND .POB
		   <NOT <==? .POB <ROOT>>>
		   <NOT <MEMQ .POB .OBLIST>>>
	      <COND (<NOT <0? <SET N <LENGTH <MEMQ ,PKG-OB .OBLIST>>>>>
		     <PUTREST <REST .OBLIST <- <SET M <LENGTH .OBLIST>> .N 1>>
			      (.POB !<REST .OBLIST <- .M .N>!>)>)
		    (T
		     <PUTREST <REST .OBLIST <- <LENGTH .OBLIST> 1>>
			      (.POB)>)>)>>)>>

<DEFINE L-DATUM (IND "OPTIONAL" (L .L-SEARCH-PATH) "AUX" CHN TMP)
	<COND (<SET CHN <SEARCH .IND .L>>
	       <SET TMP <READ .CHN '<>>>
	       <CLOSE .CHN>
	       .TMP)
	      (T #FALSE ("DATUM NOT FOUND"))>>

<SETG UDOB <MOBLIST USE-DATUM 17>>

<DEFINE USE-DATUM (IND "AUX" TMP)
	<COND (<SET TMP <TRANSLATE? .IND>>
	       <SET IND <1 .TMP>>)>
	<COND (<SET TMP <LOOKUP .IND ,UDOB>> ,.TMP)
	      (<SET TMP <L-DATUM .IND>> <SETG <INSERT .IND ,UDOB> .TMP>)
	      (T .TMP)>>

<DEFINE TRANSLATE (FROM TO "AUX" (L ,L-TRANSLATIONS))
  #DECL ((FROM) STRING (TO) <OR FALSE STRING>
	 (L) <LIST [REST STRING <OR FALSE STRING>]>)
  <REPEAT ()
     <COND (<EMPTY? .L>
	    <SETG L-TRANSLATIONS (.FROM .TO !,L-TRANSLATIONS)>
	    <RETURN>)
	   (<=? <1 .L> .FROM>
	    <PUT .L 2 .TO>
	    <RETURN>)>
     <SET L <REST .L 2>>>
   .TO>

<DEFINE UNTRANSLATE (NAME "AUX" (L ,L-TRANSLATIONS))
  #DECL ((NAME) STRING (L) <LIST [REST STRING <OR FALSE STRING>]>)
  <REPEAT ((L1 .L) L2)
    #DECL ((L1 L2) <LIST [REST STRING]>)
    <COND (<EMPTY? .L1>
	   <RETURN #FALSE ("NOT TRANSLATED")>)
	  (<=? <1 .L1> .NAME>
	   <COND (<==? .L .L1>
		  <SETG L-TRANSLATIONS <REST .L 2>>)
		 (<PUTREST <REST .L2> <REST .L1 2>>)>
	   <RETURN .NAME>)>
    <SET L2 .L1>
    <SET L1 <REST .L1 2>>>>

<DEFINE GDCHN (IND LST MODIF "OPTIONAL" (FNC ,SDMGETCHAN))
	#DECL ((IND MODIF) STRING (LST) <OR LIST STRING>)
	<COND (<TYPE? .LST LIST>
	       <REPEAT ((L .LST) TMP SPEC)
		       #DECL ((L) LIST (SPEC) <OR VECTOR STRING>)
		       <COND (<EMPTY? .L> <RETURN <>>)
			     (<AND <TYPE? <SET SPEC <1 .L>> STRING>
				   <SET TMP <GDCHN .IND <1 .L> .MODIF .FNC>>>
			      <RETURN .TMP>)>
		       <SET L <REST .L>>>)
	      (<L-DOITEM .LST .MODIF <> .FNC .IND>)>>

<DEFINE L-LOAD (STR "OPTIONAL" (L .L-SEARCH-PATH) "AUX" CHN)
	<COND (<SET CHN <GDCHN .STR .L ,L-ITEMS-NAME>> <LOAD .CHN>)
	      (T .CHN)>>

<SETG DBASEOB <MOBLIST DBASEOB 7>>

<DEFINE L-DOITEM (BASE MODIF CREATE? TODO
		  "TUPLE" JUNK
		  "AUX" TMP TC TV VAL ITM SN
			(DB
			 <COND (<LOOKUP .BASE ,DBASEOB>)
			       (<SET TMP <INSERT .BASE ,DBASEOB>>
				<SETG .TMP ()>
				.TMP)>)
			(DV ,.DB))
   #DECL ((BASE MODIF SN) STRING (DV) <LIST [REST VECTOR]>
	  (TV) <PRIMTYPE VECTOR> (ITM) <VECTOR STRING ANY CHANNEL ANY>
	  (JUNK) TUPLE (TC) CHANNEL (DB) ATOM)
   <PROG ()
     <REPEAT ()
       <COND
	(<EMPTY? .DV>
	 <SETG .DB
	  <SET DV
	   ([.MODIF
	     <NOT <MEMQ !\; .BASE>>
	     <SET TC <CHANNEL "READ" <STRING .BASE " " .MODIF>>>
	     <SET TV <PCLOSE <POPEN "PRINT" "NUL:">>>]
	    !,.DB)>>
	 <PUT .TV 1 .TC>
	 <PUT .TV 7 0>)>
       <COND (<=? <1 <SET ITM <1 .DV>>> .MODIF> <RETURN>)>
       <SET DV <REST .DV>>>
     <COND (<AND <2 .ITM>
		 <NOT <=? <SET SN <SNAME>> <6 <SET TC <3 .ITM>>>>>>
	    <PUT .TC 6 .SN>
	    <PUT .TC 10 .SN>
	    <PUT .TC 7 <3 .TC>>
	    <PUT .TC 8 <4 .TC>>)>
     <PUT <SET TC <3 .ITM>> 2 "READ">
     <RESET .TC>
     <COND (<0? <1 .TC>>
	    <COND (.CREATE?
		   <SDMDCT <SDMACT <STRING .BASE " " .MODIF>>>
		   <SET CREATE? <>>
		   <AGAIN>)>)
	   (T
	    <PRESET <SET TV <4 .ITM>>>
	    <SET VAL <APPLY .TODO .TV !.JUNK>>
	    <PCLOSE .TV>
	    .VAL)>>>

<DEFINE DOSEARCH (LST MODIF IND "AUX" (RSLT ()) RPOS)
   #DECL ((LST) LIST (RSLT RPOS) <LIST [REST LIST]> (MODIF) STRING)
   <REPEAT ()
	   <COND
	    (<EMPTY? .LST> <RETURN .RSLT>)
	    (<REPEAT ((IT <1 .LST>) ITM TMP (WON <>))
		#DECL ((ITM) STRING)
		<COND (<TYPE? .IT VECTOR> <RETURN .WON>)
		      (<TYPE? .IT LIST STRING>
		       <COND (<TYPE? .IT LIST>
			      <COND (<EMPTY? .IT> <RETURN .WON>)
				    (<SET ITM <1 .IT>>)>)
			     (<SET ITM .IT>)>
		       <COND (<SET TMP <L-DOITEM .ITM .MODIF <> ,SDMGET .IND>>
			      <SET WON T>
			      <COND (<EMPTY? .RSLT>
				     <SET RSLT <SET RPOS ((.TMP .ITM))>>)
				    (T
				     <SET RPOS
					  <REST <PUTREST .RPOS
							  ((.TMP .ITM))>>>)>)>
		       <COND (<TYPE? .IT LIST> <SET IT <REST .IT>>)
			     (T <RETURN .WON>)>)
		      (<ERROR BAD-ARG!-ERRORS DOSEARCH .IT .LST>)>>
	     <RETURN .RSLT>)>
	   <SET LST <REST .LST>>>>

<DEFINE EXSEARCH (LST MODIF IND
		  "AUX" (SL <DOSEARCH .LST .MODIF .IND>) (RL ()) RP)
   #DECL ((SL) <LIST [REST <LIST ANY ANY>]> (RL RP) <LIST [REST LIST]>)
   <REPEAT ()
     <COND (<EMPTY? .SL> <RETURN .RL>)>
     <REPEAT ((IN <2 <1 .SL>>) (L <1 <1 .SL>>))
	     #DECL ((IN) STRING (L) LIST)
	     <COND (<EMPTY? .L> <RETURN>)>
	     <REPEAT ((V <1 .L>) (EL .RL))
		     #DECL ((EL) <LIST [REST <LIST ANY ANY>]>)
		     <COND (<EMPTY? .EL>
			    <COND (<EMPTY? .RL> <SET RL <SET RP ((.V .IN))>>)
				  (T <SET RP <REST <PUTREST .RP ((.V .IN))>>>)>
			    <RETURN>)
			   (<=? .V <1 <1 .EL>>> <RETURN>)>
		     <SET EL <REST .EL>>>
	     <SET L <REST .L>>>
     <SET SL <REST .SL>>>>

<DEFINE L-FIND (STR "AUX" (LST <EXSEARCH .L-SEARCH-PATH ,L-INDEX-NAME .STR>) TMP)
	#DECL ((STR) STRING (LST) LIST)
	<AND <NOT <EMPTY?
		   <SET TMP
			<MAPF ,UVECTOR
			      #FUNCTION ((X)
					 #DECL ((X)
						<LIST <LIST [2 STRING]> STRING>)
					 [<2 <1 .X>> <2 .X>])
			      .LST>>>>
	     .TMP>>

<SETG L-NO-MAGIC <>>

<SETG L-ALWAYS-INQUIRE <>>

<SETG IOB <GET <LOOKUP "INITIAL" <ROOT>> OBLIST>>

<DEFINE L-HANDLER (FRM
		   "TUPLE" JUNK
		   "AUX" ATM N POSSIB PN TMP RSLT GOODS FINOB
			 (REDEFINE
			  <COND (<ASSIGNED? REDEFINE> .REDEFINE) (T <>)>)
			 PCK-NAME TPCK-NAME)
   #DECL ((FRM) FRAME (JUNK) TUPLE (ATM) ATOM (N) FIX
	  (POSSIB) <LIST [REST LIST]> (PN) STRING (PCK-NAME) STRING
	  (TPCK-NAME) <OR STRING FALSE>
	  (GOODS) <LIST <LIST [2 STRING]> STRING> (REDEFINE) <SPECIAL ANY>)
   <PROG ()
	 <COND (<OR <NOT <==? 3 <LENGTH .JUNK>>>
		    <NOT <OR <AND <==? <1 .JUNK> UNASSIGNED-VARIABLE!-ERRORS>
				  <==? <3 .JUNK> GVAL>>
			     <AND <==? <1 .JUNK> UNBOUND-VARIABLE!-ERRORS>
				  <OR <==? <3 .JUNK> VALUE>
				      <==? <3 .JUNK> CALLER>>>>>>
		<RETURN>)>
	 <COND (<L-GASSIGNED? <SET ATM <2 .JUNK>>>
		<INT-LEVEL 0>
		<APPLY ,ERRET ,.ATM .FRM>)
	       (<OR ,L-NO-MAGIC <NOT <==? <OBLIST? .ATM> ,IOB>>> <RETURN>)>
	 <COND (<EMPTY? <SET POSSIB
			     <EXSEARCH .L-SEARCH-PATH
				       ,L-INDEX-NAME
				       <SET PN <SPNAME .ATM>>>>>
		<RETURN>)>
	 <INT-LEVEL 0>
	 <COND (<OR <G? <LENGTH .POSSIB> 1> ,L-ALWAYS-INQUIRE>
		<SET N <DISP-CHOICE .POSSIB .PN>>)
	       (<SET N 1>)>
	 <COND (<OR <L? .N 1> <G? .N <LENGTH .POSSIB>>> <RETURN>)>
	 <SET REDEFINE T>
	 <SET GOODS <NTH .POSSIB .N>>
	 <SET PCK-NAME <2 <1 .GOODS>>>
	 <COND (<SET TMP <TRANSLATE? .PCK-NAME>>
		<SET TPCK-NAME <1 .TMP>>)
	       (<SET TPCK-NAME .PCK-NAME>)>
	 <SET FINOB
	      <COND (<=? " " <SET TMP <REST <MEMQ !\! <1 <1 .GOODS>>> 2>>>
		     <ROOT>)
		    (<==? .TPCK-NAME .PCK-NAME>
		     <MOBLIST <PARSE .TMP> 17>)
		    (.TPCK-NAME
		     <MOBLIST <PARSE <STRING .TPCK-NAME "!-PACKAGE!- ">> 17>)
		    (<1 .OBLIST>)>>
	 <COND (<NOT .TPCK-NAME>
		<SET RSLT .ATM>)
	       (<SET TMP <LOOKUP .PN .FINOB>>
		<SUBSTITUTE .TMP <REMOVE .ATM>>
		<SET RSLT .TMP>)
	       (<SET RSLT <INSERT <REMOVE .ATM> .FINOB>>)>
	 <PROG ((L-TEMP-PATH <REST .GOODS>))
	       #DECL ((L-TEMP-PATH) <SPECIAL <LIST <OR STRING VECTOR>>>)
	       <USE <2 <1 .GOODS>>>>
	 <COND (<NOT <GASSIGNED? .RSLT>>
		<ERROR "PACKAGE DID NOT DEFINE FUNCTION"
		       .RSLT
		       <2 <1 .GOODS>>>)
	       (T <INT-LEVEL 0> <APPLY ,ERRET ,.RSLT .FRM>)>>>

<DEFINE DISP-CHOICE (POSSIB PN "AUX" (OUTCHAN ,OUTCHAN) IN P)
	#DECL ((P) <LIST <LIST [2 STRING]> STRING> (POSSIB) <LIST [REST LIST]>
	       (OUTCHAN) <SPECIAL CHANNEL>)
	<PRINTSTRING "
TO GET ">
	<PRINTSTRING .PN>
	<PRINTSTRING " DYNAMICALLY LOAD
0	NONE -- GENERATE ERROR
">
	<REPEAT ((N 1))
		#DECL ((N) FIX)
		<COND (<EMPTY? .POSSIB> <RETURN>)>
		<SET P <1 .POSSIB>>
		<PRINC .N>
		<PRINTSTRING "	">
		<PRINC <2 <1 .P>>>
		<INDENT-TO 18>
		<PRINTSTRING "in    ">
		<PRINC <2 .P>>
		<TERPRI>
		<SET N <+ .N 1>>
		<SET POSSIB <REST .POSSIB>>>
	<PROG ()
	      <PRINTSTRING "# to load?  ">
	      <SET IN <READ ,INCHAN>>
	      <COND (<NOT <TYPE? .IN FIX>> <TERPRI> <AGAIN>)>
	      <TERPRI>
	      .IN>>

<ENDBLOCK>

<ENDBLOCK>

<SET OBLIST ,OBLIST>

<ON "ERROR" ,L-HANDLER 100>
