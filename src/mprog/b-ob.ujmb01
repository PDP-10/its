<PACKAGE "B-OBJECT">

;"Package to convert 8-bit MSDTP format bytes to a MDL object.
	Use <EXTRACT-ITEM .BS>, where .BS is a string of 8-bit
bytes.  (This may be created by <BYTER8!-MSDTP!-PACKAGE .BUF>,
where BUF is a uvector of primtype-words.) It returns the
converted object.
	<EXTRACT-ITEM .BS T> returns the number of bytes needed
for the complete object.  It looks at only the type, and possibly
size, bytes to determine the length.
	REFILL-BUFFER should be defined to be a function that,
given a buffer, refills it with bytes.  It will be called whenever
more bytes are needed to complete an object."

<ENTRY EXTRACT-ITEM REFILL-BUFFER MAX-STRING STRING-FILE>

<USE "MSDTP">

<SETG MAX-STRING 5120>

<SETG STRING-FILE "DSK:NETOPS;MSDTP >">

<DEFINE EXTRACT-ITEM (BS
		      "OPTIONAL" (SIZE? <>)
		      "AUX" (BL <LENGTH .BS>)
			    (BOFF 0)
			    (BYTES 0)
			    BYTE
			    WD)
	#DECL ((VALUE) ANY
	       (BS) <SPECIAL STRING>
	       (SIZE?) <OR 'T FALSE>
	       (BL BYTES BOFF) <SPECIAL FIX>
	       (BYTE) WORD
	       (WD) <OR WORD FIX>)
	<COND (.SIZE?
	       <COND (<==? <GETBITS <SET BYTE <GET-BYTE>> #BITS *050300000000*> #WORD 6>
		      <B-NON-ATOM <CHTYPE <GETBITS .BYTE #BITS *000500000000*> FIX> T>)
		     (<NOT <SET WD <ANDB .BYTE *370*>>>)
		     (<OR <==? .WD #WORD *340*> <==? .WD #WORD *360*>>
		      <SET WD <CHTYPE <GETBITS .BYTE #BITS *000300000000*> FIX>>
		      <COND (<0? .WD> 9) (<+ .WD 1>)>)
		     (<==? .WD #WORD *350*>
		      <ERROR RESERVED-CODE-USED!-ERRORS EXTRACT-ITEM>)
		     (1)>)
	      (<GET-ITEM>)>>

<DEFINE GET-BYTE () 
	#DECL ((VALUE) WORD)
	<COND (<G=? .BYTES <+ .BL .BOFF>>
	       <REFILL-BUFFER .BS>
	       <SET BOFF <+ .BOFF .BL>>)>
	<CHTYPE <GET .BS <- <SET BYTES <+ .BYTES 1>> .BOFF>> WORD>>

<DEFINE NEXT-BYTE () 
	#DECL ((VALUE) WORD)
	<COND (<G=? .BYTES <+ .BL .BOFF>>
	       <REFILL-BUFFER .BS>
	       <SET BOFF <+ .BOFF .BL>>)>
	<CHTYPE <GET .BS <- <+ .BYTES 1> .BOFF>> WORD>>

<DEFINE B-NON-ATOM (OBTYPE "OPTIONAL" (SIZE? <>) "AUX" OBLEN "NAME" B-NON-ATOM)
   #DECL ((VALUE) ANY (SIZE?) <OR 'T FALSE> (OBTYPE OBLEN) FIX (B-NON-ATOM) ACTIVATION)
   <SET OBLEN <CHTYPE <GET-BYTE> FIX>>
   <COND (<0? .OBLEN> <SET OBLEN *200*>)
	 (<L? .OBLEN *200*>)
	 (<NOT <SET OBLEN <- .OBLEN *200*>>>)
	 (<G? .OBLEN 4>
	  <ERROR TOO-MANY-SIZE-BYTES!-ERRORS B-NON-ATOM .OBLEN>)
	 (<SET OBLEN
	       <REPEAT ((LEN 0))
		       <AND <0? .OBLEN> <RETURN .LEN>>
		       <SET LEN <+ <* .LEN *400*> <CHTYPE <GET-BYTE> FIX>>>
		       <SET OBLEN <- .OBLEN 1>>>>)>
   <AND <OR <0? .OBTYPE> <G? .OBTYPE 6>>
	<ERROR BAD-OBJECT-TYPE-CODE!-ERRORS B-NON-ATOM .OBTYPE>>
   <COND (.SIZE? <+ .BYTES .OBLEN>)
	 (<APPLY ,<NTH '![B-LBITSTR B-STRUC B-EDT B-REPEAT B-USTRUC B-STRING!]
		       .OBTYPE>
		 .OBLEN>)>>

<DEFINE B-LBITSTR (OBLEN
		   "AUX" (FINLEN <+ .OBLEN .BYTES>)
			 (BITLEN <GET-ITEM>)
			 (UV <IUVECTOR <+ </ <- .FINLEN .BYTES 1> 4> 2> #WORD 0>)
			 (BBS <BYTER8 <REST .UV>>))
	#DECL ((VALUE) BITSTR
	       (OBLEN FINLEN BITLEN) FIX
	       (UV) <UVECTOR [REST WORD]>
	       (BBS) STRING)
	<OR <G=? <- .FINLEN .BYTES> <+ </ <- .BITLEN 1> 8> 1>>
	    <AND <0? .BITLEN> <==? .FINLEN .BYTES>>
	    <ERROR NOT-ENOUGH-BYTES-FOR-BITS!-ERRORS
		   P-LBITSTR
		   <- .FINLEN .BYTES>
		   .BITLEN>>
	<PUT .UV 1 <CHTYPE .BITLEN WORD>>
	<REPEAT ((N 0))
		<AND <==? .BYTES .FINLEN> <RETURN>>
		<PUT .BBS
		     <SET N <+ .N 1>>
		     <CHTYPE <GET-BYTE> CHARACTER>>>
	<CHTYPE .UV BITSTR>>

<DEFINE B-STRING (OBLEN)
	#DECL ((VALUE) <OR STRING POINTER> (OBLEN) FIX)
	<COND (<G? .OBLEN ,MAX-STRING>
	       <REPEAT ((C <OR <OPEN "PRINT" ,STRING-FILE>
			       <ERROR CANT-OPEN!-ERRORS B-STRING ,STRING-FILE>>)
			(LEN .OBLEN))
		       #DECL ((VALUE) POINTER (C) CHANNEL (LEN) FIX)
		       <PRINC <CHTYPE <GET-BYTE> CHARACTER> .C>
		       <AND <0? <SET LEN <- .LEN 1>>>
			    <CLOSE .C>
			    <RETURN <CHTYPE (0 .OBLEN <STRING <9 .C>
							      !":
							      <10 .C>
							      !";
							      <7 .C>
							      !" 
							      <8 .C>>)
					    POINTER>>>>)
	      (<ISTRING .OBLEN '<CHTYPE <GETBITS <GET-BYTE> #BITS *000700000000*>
					CHARACTER>>)>>

<DEFINE B-STRUC (OBLEN
		"OPTIONAL" LIST?
		"AUX" (FINLEN <+ .OBLEN .BYTES>) THISOB ITEM LASTOB) 
   #DECL ((VALUE ITEM LASTOB) <OR LIST STRING> (OBLEN FINLEN) FIX (LIST? THISOB) ANY)
   <REPEAT ()
	   <AND <G=? .BYTES .FINLEN> <SET ITEM ()> <RETURN>>
	   <COND
	    (<TYPE? <SET THISOB <GET-ITEM>> SPLICE>
	     <COND (<EMPTY? .THISOB>)
		   (<SET ITEM <CHTYPE .THISOB LIST>>
		    <SET LASTOB <REST .THISOB <- <LENGTH .THISOB> 1>>>
		    <RETURN>)>)
	    (<SET LASTOB <SET ITEM (.THISOB)>> <RETURN>)>>
   <OR <G=? .BYTES .FINLEN>
       <REPEAT ()
	       <COND (<TYPE? <SET THISOB <GET-ITEM>> SPLICE>
		      <COND (<EMPTY? .THISOB>)
			    (<PUTREST .LASTOB .THISOB>
			     <SET LASTOB
				  <REST .THISOB <- <LENGTH .THISOB> 1>>>)>)
		     (<PUTREST .LASTOB <SET LASTOB (.THISOB)>>)>
	       <AND <G=? .BYTES .FINLEN> <RETURN>>>>
   <OR <==? .BYTES .FINLEN>
       <ERROR BAD-SIZE-SPECIFICATION!-ERRORS B-STRUC .OBLEN>>
   <COND (<ASSIGNED? LIST?> .ITEM)
	 (<MAPF <> <FUNCTION (E) <OR <TYPE? .E CHARACTER> <MAPLEAVE <>>>> .ITEM>
	  <STRING !.ITEM>)
	 (.ITEM)>>

<DEFINE B-REPEAT (OBLEN "AUX" (FINLEN <+ .OBLEN .BYTES>) REPNUM REPOBS) 
	#DECL ((VALUE) SPLICE (REPNUM) FIX (REPOBS) LIST)
	<SET REPNUM <GET-ITEM>>
	<AND <G=? .BYTES .FINLEN>
	     <ERROR BAD-SIZE-SPECIFICATION!-ERRORS B-REPEAT .OBLEN>>
	<SET REPOBS <B-STRUC <- .FINLEN .BYTES> T>>
	<REPEAT ((ITEM ()))
		#DECL ((VALUE) SPLICE (ITEM) LIST)
		<AND <0? .REPNUM> <RETURN <CHTYPE .ITEM SPLICE>>>
		<SET ITEM (!.REPOBS !.ITEM)>
		<SET REPNUM <- .REPNUM 1>>>>

<DEFINE B-USTRUC (OBLEN)
	#DECL ((VALUE) <OR LIST STRING> (OBLEN) FIX)
	<COND (<AND <NEXT-BYTE> <L? <CHTYPE <NEXT-BYTE> FIX> *200*>> <B-STRING .OBLEN>)
	      (<B-STRUC .OBLEN>)>>

<SETG ERRIHEAD <OR <GET ERROR!-INTERRUPTS INTERRUPT> <EVENT ERROR!-INTERRUPTS 100>>>

<SETG ERRPARSE <OFF <HANDLER ,ERRIHEAD <FUNCTION ("TUPLE" T) <OFF ,ERRPARSE>
							     <DISMISS 0 .ACTPARSE>>>>>

<DEFINE B-EDT (OBLEN "AUX" ITEM STYPE VAL)
	#DECL ((VALUE VAL) ANY (ITEM) LIST (STYPE) ATOM)
	<SET ITEM <B-STRUC .OBLEN T>>
	<SET STYPE <GET-SEMTYPE <1 .ITEM>>>
	<COND (<AND <==? .STYPE %<GET-SEMTYPE "UNPARSED">>
		    <NOT <TYPE? <SET VAL <PROG ACTPARSE ()
					       #DECL ((ACTPARSE) <SPECIAL ACTIVATION>)
					       <HANDLER ,ERRIHEAD ,ERRPARSE>
					       <PARSE <3 .ITEM>>>>
				FIX>>>
	       <OFF ,ERRPARSE>
	       .VAL)
	      (<CHTYPE <REST .ITEM> .STYPE>)>>

<SETG GET-ITEM
      %<FIXUP!-RSUBRS '[
#CODE ![23751557122 23085677572 25614352384 272105478 -14747172736 23088857096 
17188482051 23088857130 17188482049 -14210301888 23088857130 -14747172832 
23088857105 23848812545 23848812546 280494088 23088857130 -16894656488 
23088857111 23848812545 23848812546 280494090 23088857130 -14210301936 943194127
-14747172856 23088857119 23848812545 23848812546 280494092 23088857130 
-14747172860 23088857123 17191927825 23088857130 -14747172862 23088857127 
17191927827 23088857130 26055016448 23088857091 17191927829 25614352384 
24150802432 2 6076118911 0 262146!]
			GET-ITEM
			#DECL ("VALUE" ANY)
			GET-BYTE
			B-NON-ATOM
			B-LINTEGER
			B-SBITSTR
			RESERVED-CODE-USED!-ERRORS
			%<TYPE-W XTRA WORD>
			%<TYPE-W BOOL WORD>
			%<TYPE-W EMPTY WORD>]
		      '(52
			FINIS!-MUDDLE
			228356
			(2)
			$TLOSE!-MUDDLE
			224256
			(9 7))>>

<AND <ASSIGNED? GLUE>
     .GLUE
     <PUT ,GET-ITEM
	  GLUE
	  '![17734583332 17796703348 31255953408 2!]>>

<SETG B-LINTEGER
      %<FIXUP!-RSUBRS '[
#CODE ![23851171840 23851171841 23751557124 23085677572 25614352384 17339252744 
29799219200 17476354048 272105478 -34334572544 -16357785472 23088857102 
-26281508864 24716247082 17213423618 34228404224 23088857113 23848812547 
23848812548 272105478 23983030276 23983030275 22036873224 -30568087550 
23088857103 23983030274 23983030273 26063405056 27677425707 23088857128 
17196646403 23848812545 23848812546 17196646404 23848812545 23848812546 
17322475522 23748386737 17191927817 23085696409 17196646404 23085696409 -256 -1 
262148 5581342911 0 262146!]
			B-LINTEGER
			#DECL ("VALUE" <OR FIX DFIX> FIX)
			GET-BYTE
			%<TYPE-W DFIX UVECTOR>]
		      '(52
			FINIS!-MUDDLE
			228356
			(4)
			CIUVEC!-MUDDLE
			237489
			(38)
			MPOPJ!-MUDDLE
			247193
			(42 40))>>

<AND <ASSIGNED? GLUE>
     .GLUE
     <PUT ,B-LINTEGER
	  GLUE
	  '![1074270468 8594149376 3221225472 262148!]>>

<SETG B-SBITSTR
      %<FIXUP!-RSUBRS '[
#CODE ![23851171840 23851171841 23751557124 23085677572 25614352384 17339252744 
29799219200 17476354048 -33931919356 33959968768 23088857107 23848812547 
23848812548 272105478 23983030276 23983030275 22305308680 -30568087550 
23088857097 33285996555 33285996555 17188482104 26600275968 23088857122 
17196646403 23848812545 23848812546 17196646404 23848812545 23848812546 
17322475522 23748386737 17191927817 23085696409 17196646404 23085696409 262148 
5598806925 0 262146!]
			B-SBITSTR
			#DECL ("VALUE" <OR WORD DWORD> FIX)
			GET-BYTE
			%<TYPE-W DWORD UVECTOR>]
		      '(52
			FINIS!-MUDDLE
			228356
			(4)
			$TLOSE!-MUDDLE
			224256
			(22)
			CIUVEC!-MUDDLE
			237489
			(32)
			MPOPJ!-MUDDLE
			247193
			(36 34))>>

<AND <ASSIGNED? GLUE>
     .GLUE
     <PUT ,B-SBITSTR GLUE '![1073758720 17196646592 262148!]>>

<ENDPACKAGE>
