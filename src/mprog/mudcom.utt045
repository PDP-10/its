<DEFINE N-KILL (LIST POS)
	#DECL ((LIST VALUE) LIST (POS) FIX)
	<COND (<1? .POS> <REST .LIST>)
	      (<PUTREST <REST .LIST <- .POS 2>> <REST .LIST .POS>> .LIST)>>

<DEFINE N-APPEND (LIST1 LIST2)
	#DECL ((LIST1 LIST2 VALUE) LIST)
	<COND (<EMPTY? .LIST1> .LIST2)
	      (<PUTREST <REST .LIST1 <- <LENGTH .LIST1> 1>> .LIST2>
	       .LIST1)>>

<DEFINE APPEND (A B) #DECL ((A B VALUE) LIST) (!.A !.B)>

<DEFINE N-APPENDG (LIST-OF-LISTS)
	#DECL ((LIST-OF-LISTS) <LIST [REST LIST]> (VALUE) LIST)
	<REPEAT ((TEMP-POS <LENGTH .LIST-OF-LISTS>)
		 (NEW-LIST
		  <COND (<0? .TEMP-POS> <RETURN ()>)
			(<NTH .LIST-OF-LISTS .TEMP-POS>)>))
		#DECL ((VALUE NEW-LIST) LIST (TEMP-POS) FIX)
		<SET TEMP-POS <- .TEMP-POS 1>>
		<AND <0? .TEMP-POS> <RETURN .NEW-LIST>>
		<SET NEW-LIST
		     <N-APPEND <NTH .LIST-OF-LISTS .TEMP-POS> .NEW-LIST>>>>

<DEFINE APPENDG (LIST-OF-LISTS)
	#DECL ((LIST-OF-LISTS) <LIST [REST LIST]> (VALUE) LIST)
	<REPEAT ((NEW-LIST ()) (TEMP-POS <LENGTH .LIST-OF-LISTS>))
		#DECL ((NEW-LIST VALUE) LIST (TEMP-POS) FIX)
		<AND <0? .TEMP-POS> <RETURN .NEW-LIST>>
		<SET NEW-LIST
		     <APPEND <NTH .LIST-OF-LISTS .TEMP-POS> .NEW-LIST>>
		<SET TEMP-POS <- .TEMP-POS 1>>>>

<DEFINE TOP-LEVEL1 (LIST)
	#DECL ((LIST VALUE) LIST)
	<REPEAT ((LIST1 ()) (LIST2 ()))
		#DECL ((LIST1 LIST2 VALUE) LIST)
		<AND <EMPTY? .LIST>
		     <RETURN <APPEND .LIST1 <APPENDG .LIST2>>>>
		<COND (<OR <==? <TYPE <1 .LIST>> LIST>
			   <==? <TYPE <1 .LIST>> VECTOR>
			   <==? <TYPE <1 .LIST>> UVECTOR>>
		       <SET LIST2 <CONS <1 .LIST> .LIST2>>)
		      (<SET LIST1 <CONS <1 .LIST> .LIST1>>)>
		<SET LIST <REST .LIST>>>>

<DEFINE UNION2 (BIG-SET SMALL-SET)
	#DECL ((BIG-SET SMALL-SET VALUE) LIST)
	<REPEAT ()
		#DECL ((VALUE) LIST)
		<AND <EMPTY? .SMALL-SET> <RETURN .BIG-SET>>
		<OR <MEMBER <1 .SMALL-SET> .BIG-SET>
		    <SET BIG-SET <CONS <1 .SMALL-SET> .BIG-SET>>>
		<SET SMALL-SET <REST .SMALL-SET>>>>

<DEFINE UNION (SET-OF-SETS)
	#DECL ((SET-OF-SETS) <LIST [REST LIST]> (VALUE) LIST)
	<REPEAT ((NEW-SET-OF-SETS ()))
		#DECL ((NEW-SET-OF-SETS VALUE) LIST)
		<AND <EMPTY? .SET-OF-SETS> <RETURN .NEW-SET-OF-SETS>>
		<SET NEW-SET-OF-SETS
		     <UNION2 .NEW-SET-OF-SETS <1 .SET-OF-SETS>>>
		<SET SET-OF-SETS <REST .SET-OF-SETS>>>>

<DEFINE SET-MINUS (BIG-SET SMALL-SET "OPTIONAL" (TAG CHANGED?))
	#DECL ((BIG-SET SMALL-SET VALUE) LIST
	       (TAG) ATOM
	       (CHANGED?) <SPECAIL ATOM>)
	<PROG ()
	      #DECL ((VALUE) LIST)
	      <SET .TAG <>>
	      <REPEAT ((DIFFERENCE ()))
		      #DECL ((DIFFERENCE) LIST)
		      <AND <EMPTY? .BIG-SET> <RETURN .DIFFERENCE>>
		      <COND (<MEMBER <1 .BIG-SET> .SMALL-SET> <SET .TAG T>)
			    (<SET DIFFERENCE <CONS <1 .BIG-SET> .DIFFERENCE>>)>
		      <SET BIG-SET <REST .BIG-SET>>>>>

<DEFINE ADD-TO (SET ITEM)
	#DECL ((SET VALUE) LIST)
	<COND (<MEMBER .ITEM .SET> .SET) (<CONS .ITEM .SET>)>>

<DEFINE RE-GROUP (GROUP-OF-SETS SET)
        #DECL ((GROUP-OF-SETS) <LIST [REST LIST]>
               (VALUE SET) LIST)
        <REPEAT ((NEW-GROUP ())
                 (TEST-SET .SET)
                 (CHECKED-GROUP ())
                 (UNCHECKED-GROUP .GROUP-OF-SETS)
                 changed?)
                #DECL ((TEST-SET VALUE) LIST
                       (NEW-GROUP CHECKED-GROUP UNCHECKED-GROUP)
                       <LIST [REST LIST]>
		       (changed?) <SPECIAL ANY>)
                <AND <EMPTY? .TEST-SET>
                     <RETURN <N-APPENDG ((<APPENDG .NEW-GROUP>)
                                        .CHECKED-GROUP
                                        .UNCHECKED-GROUP)>>>
                <AND <EMPTY? .UNCHECKED-GROUP>
                     <RETURN <CONS <APPENDG <CONS .TEST-SET .NEW-GROUP>>
                                   .CHECKED-GROUP>>>
                <SET TEST-SET
                     <SET-MINUS .TEST-SET <1 .UNCHECKED-GROUP> changed?>>
                <COND (.changed?
                       <SET NEW-GROUP <CONS <1 .UNCHECKED-GROUP> .NEW-GROUP>>)
                      (<SET CHECKED-GROUP
                            <CONS <1 .UNCHECKED-GROUP> .CHECKED-GROUP>>)>
                <SET UNCHECKED-GROUP <REST .UNCHECKED-GROUP>>>>


<DEFINE PRINT&SET (ATOM CHANNEL)
	#DECL ((ATOM) ATOM (CHANNEL) CHANNEL)
	<PROG ()
	      <PRINC "<SET " .CHANNEL>
	      <PRIN1 .ATOM .CHANNEL>
	      <PRINC " " .CHANNEL>
	      <PPRINT ..ATOM .CHANNEL>
	      <PRINC ">
" .CHANNEL>>>

<DEFINE SIMPLIFY (SET)
	#DECL ((SET VALUE) LIST)
	<REPEAT ((NEW-SET ()))
		#DECL ((NEW-SET VALUE) LIST)
		<AND <EMPTY? .SET> <RETURN .NEW-SET>>
		<OR <MEMBER <1 .SET> .NEW-SET>
		    <SET NEW-SET <CONS <1 .SET> .NEW-SET>>>
		<SET SET <REST .SET>>>>

<DEFINE STRUCTURE (SO)
	#DECL ((SO) STRUCTURED (VALUE) SUBR)
	<COND (<==? <PRIMTYPE .SO> LIST> ,LIST)
	      (<==? <PRIMTYPE .SO> VECTOR> ,VECTOR)
	      (<==? <PRIMTYPE .SO> UVECTOR> ,UVECTOR)
	      (<==? <PRIMTYPE .SO> STRING> ,STRING)>>

<DEFINE ISTRUCTURE (SO)
	#DECL ((SO) STRUCTURED (VALUE) SUBR)
	<COND (<==? <PRIMTYPE .SO> LIST> ,ILIST)
	      (<==? <PRIMTYPE .SO> VECTOR> ,IVECTOR)
	      (<==? <PRIMTYPE .SO> UVECTOR> ,IUVECTOR)
	      (<==? <PRIMTYPE .SO> STRING> ,ISTRING)
	      (<==? <PRIMTYPE .SO> STORAGE> ,ISTORAGE)>>

<DEFINE N-SECTION (SO BEG-POS END-POS)
	#DECL ((SO VALUE) STRUCTURED (BEG-POS END-POS) FIX)
	<REPEAT ((LEN1 <- .BEG-POS 1>)
		 (NEW-SO
		  <REST .SO <- <LENGTH .SO> <+ <- .END-POS .BEG-POS> 1>>>)
		 (TEMP-POS <LENGTH .NEW-SO>))
		#DECL ((LEN1 TEMP-POS) FIX (VALUE NEW-SO) STRUCTURED)
		<AND <0? .TEMP-POS> <RETURN .NEW-SO>>
		<PUT .NEW-SO .TEMP-POS <NTH .SO <+ .LEN1 .TEMP-POS>>>
		<SET TEMP-POS <- .TEMP-POS 1>>>>

<DEFINE SECTION (SO BEG-POS END-POS)
	#DECL ((SO VALUE) STRUCTURED (BEG-POS END-POS) FIX)
	<PROG ((NEW-SO <APPLY <ISTRUCTURE .SO> <- .END-POS .BEG-POS -1>>))
	      #DECL ((NEW-SO VALUE) STRUCTURED)
	      <AND <==? <PRIMTYPE .SO> UVECTOR>
		   <CHUTYPE .NEW-SO <UTYPE .SO>>>
	      <REPEAT ((TEMP-POS .END-POS))
		      #DECL ((TEMP-POS) FIX (VALUE) STRUCTURED)
		      <AND <L? .TEMP-POS .BEG-POS> <RETURN .NEW-SO>>
		      <PUT .NEW-SO <- .TEMP-POS .BEG-POS -1> <NTH .SO .TEMP-POS>>
		      <SET TEMP-POS <- .TEMP-POS 1>>>>>

<DEFINE N-GET-RID-OF (SO BEG-POS END-POS)
	#DECL ((SO VALUE) STRUCTURED (BEG-POS END-POS) FIX)
	<REPEAT ((NEW-SO <REST .SO <+ 1 <- .END-POS .BEG-POS>>>)
		 (TEMP-POS <- .BEG-POS 1>))
		#DECL ((NEW-SO VALUE) STRUCTURED (TEMP-POS) FIX)
		<AND <0? .TEMP-POS> <RETURN .NEW-SO>>
		<PUT .NEW-SO .TEMP-POS <NTH .SO .TEMP-POS>>
		<SET TEMP-POS <- .TEMP-POS 1>>>>

<DEFINE GET-RID-OF (SO BEG-POS END-POS)
	#DECL ((SO VALUE) STRUCTURED (BEG-POS END-POS) FIX)
	<PROG ((GARBAGE-LEN <- .END-POS .BEG-POS -1>)
	       (NEW-SO <APPLY <ISTRUCTURE .SO> <- <LENGTH .SO> .GARBAGE-LEN>>))
	      #DECL ((GARBAGE-LEN) FIX (NEW-SO VALUE) STRUCTURED)
	      <AND <==? <PRIMTYPE .SO> UVECTOR>
		   <CHUTYPE .NEW-SO <UTYPE .SO>>>
	      <REPEAT ((TEMP-POS <- .BEG-POS 1>))
		      #DECL ((TEMP-POS) FIX)
		      <AND <0? .TEMP-POS> <RETURN>>
		      <PUT .NEW-SO .TEMP-POS <NTH .SO .TEMP-POS>>
		      <SET TEMP-POS <- .TEMP-POS 1>>>
	      <REPEAT ((TEMP-POS <LENGTH .SO>))
		      #DECL ((TEMP-POS) FIX)
		      <AND <==? .END-POS .TEMP-POS> <RETURN>>
		      <PUT .NEW-SO <- .TEMP-POS .GARBAGE-LEN> <NTH .SO .TEMP-POS>>
		      <SET TEMP-POS <- .TEMP-POS 1>>>
	      <RETURN <CHTYPE .NEW-SO <TYPE .SO>>>>>

<DEFINE N-REVERSE (SO)
	#DECL ((SO VALUE) STRUCTURED)
	<REPEAT ((TEMP-POS <LENGTH .SO>) TEMP-VAL)
		#DECL ((TEMP-POS) FIX (VALUE) STRUCTURED)
		<AND <L=? .TEMP-POS </ <LENGTH .SO> 2>> <RETURN .SO>>
		<SET TEMP-VAL <NTH .SO <- <LENGTH .SO> .TEMP-POS -1>>>
		<PUT .SO <- <LENGTH .SO> .TEMP-POS -1> <NTH .SO .TEMP-POS>>
		<PUT .SO .TEMP-POS .TEMP-VAL>
		<SET TEMP-POS <- .TEMP-POS 1>>>>

<DEFINE REVERSE (SO)
	#DECL ((SO VALUE) STRUCTURED)
	<PROG ((NEW-SO <APPLY <ISTRUCTURE .SO> <LENGTH .SO>>))
	      #DECL ((NEW-SO VALUE) STRUCTURED)
	      <AND <==? <PRIMTYPE .SO> UVECTOR>
		   <CHUTYPE .NEW-SO <UTYPE .SO>>>
	      <REPEAT ((TEMP-POS <LENGTH .SO>))
		      #DECL ((TEMP-POS) FIX (VALUE) STRUCTURED)
		      <AND <0? .TEMP-POS> <RETURN .NEW-SO>>
		      <PUT .NEW-SO
			   <- <LENGTH .SO> .TEMP-POS -1>
			   <NTH .SO .TEMP-POS>>
		      <SET TEMP-POS <- .TEMP-POS 1>>>>>

<DEFINE SWAP (NAME1 NAME2)
	#DECL ((NAME1 NAME2) ATOM)
	<PROG (TEMP)
	      <SET TEMP ..NAME1>
	      <SET .NAME1 ..NAME2>
	      <SET .NAME2 .TEMP>>>

<DEFINE SGN (NUM)
	#DECL ((NUM) <OR FIX FLOAT> (VALUE) FIX)
	<COND (<L? .NUM 0> -1) (1)>>

<DEFINE LAMBDA (BVL BODY)
	#DECL ((BVL) LIST (BODY) FORM (VALUE) FUNCTION)
	<CHTYPE (.BVL .BODY) FUNCTION>>

<DEFINE COPY (SO)
	<COND (<MONAD? .SO> .SO)
	      (<CHTYPE <MAPF <STRUCTURE .SO> ,COPY .SO> <TYPE .SO>>)>>
