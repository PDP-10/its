<PACKAGE "STR">

<ENTRY
;"this file contains the following functions -- LEX is the only non-RSUBR."
BACKS 		;"Searches backwards in a string."
FIRST-OF 	;"Searches for any member of first arg in second arg."
LEX 		;"Returns a list of tokens (strings) from a string."
EXTRACT 	;"Useful for copying a substring."
SUBSTR 		;"Searches for a substring.  Obsolete -- use MEMBER"
SUBSNC		;"Like SUBSTR, but ignores case."
UPPERCASE 	;"Changes a string to all uppercase."
RSHIFT 		;"Right-shifts a string by N in its muddle vector -- useful for
		buffers which have free-space in them but need to be looked
		at by functions which take standard strings."
SIXTOS 		;"SIXbit-TO-String -- returns six chars!! "
STRTOX 		;"STRing-TO-siXbit."
>

<DEFINE LEX (STR N BREAKS)	;"RETURNS LIST OF TOKENS"
	#DECL ((VALUE) <LIST [REST STRING]>
		(STR BREAKS) <SPECIAL STRING>
		(N) <SPECIAL FIX>)
	<REPEAT ((TKNS ()))
	#DECL ((TKNS) <LIST [REST STRING]>)
	<AND <OR <L? .N 1><EMPTY? .STR>><RETURN .TKNS>>
	<SET TKNS (
	<MAPR ,STRING <FUNCTION (CHRS "AUX" (TEM <1 .CHRS>))
			#DECL ((CHRS) STRING (TEM) CHARACTER)
		<COND (<L? <SET N <- .N 1>> 0>
			<MAPSTOP> ;"RETS STRING")
			(<MEMQ .TEM .BREAKS>
			<SET STR <REST .CHRS>>	;"REST OFF PREV"
			<MAPSTOP> ;"AND RET STRING")>
			.TEM>	;"ELSE STRING THE CHARS"
	.STR>
	!.TKNS)>
	>>

<TITLE SIXTOS>
	<DECLARE ("VALUE" STRING <PRIMTYPE WORD>)>
	<MOVE O* 1 (AB)>
	<MOVSI C* *440600*>
	<MOVEI D* 6>
LOOP
	<ILDB	A* C>
	<ADDI	A* *40*>	;"TO ASCII"
	<PUSH	TP* $TCHARACTER>
	<PUSH	TP* A>
	<SOJN	D* LOOP>
	<MCALL 6 STRING>
	<JRST FINIS>

<TITLE STRTOX>
	<DECLARE ("VALUE" FIX STRING)>
	<HRRZ	D* (AB)>	;"COUNT"
	<CAIL	D* 6>
	<MOVEI	D* 6>	;"MIN (6,LENGTH)"
	<SETZM	B>	;"ACCUMULATOR"
	<JUMPE	D* OUT>	;"NO CHARS"
	<MOVE	C* [*440600000002*]>	;"SIXBIT POINTER TO B"
	<MOVE	O* 1 (AB)>	;"ASCII POINTER"
LOOP
	<ILDB	A* O>	;"GET CHARACTER"
	<CAIL	A* *140*>	;"lower case"
	<SUBI	A* *40*>	;"goes to upper case"
	<SUBI	A* *40*>	;"MAKE SIXBIT"
	<IDPB	A* C>	;"DEPOSIT IN C"
	<SOJN	D* LOOP>
OUT
	<MOVSI	A* TFIX>
	<JRST FINIS>

<TITLE SUBSTR>
	<DECLARE ("VALUE" <OR STRING FALSE> STRING STRING "OPTIONAL" FIX)>
	<HLRZ	O* AB>
	<CAILE	O* -4>	;"AT LEAST 2 ARGS"
	<JRST WNA>
	<JUMPE	O* WNA>
	<GETYP	D* 0 (AB)>
	<GETYP	A* 2 (AB)>
	<CAIN	D* TSTRING>
	<CAIE	A* TSTRING>
	<JRST	WRONGT>
	<HRRZ	C* 0 (AB)>	;"L(S1)"
	<HRRZ	A* 2 (AB)>	;"L(S2)"
;"CHECKS FOR THIRD ARG, WHICH IS THE 'EFFECTIVE LENGTH' OF S1,
  AND LIMITS THE SEARCH FOR THE SUBSTR."
	<CAIE	O* -6>		;"3 ARGS?"
	<JRST	NOT3>
	<GETYP	E* 4 (AB)>
	<CAIE	E* TFIX>	;"FIX, MAX FOR SEARCH"
	<JRST	WRONGT>
	<SKIPE	E* 5 (AB)>	;"CAN'T HAVE SUBSTR OF STRING OF LENGTH 0"
	<CAMGE	E* A>		;"IS MAX < L(S1)"
	<MOVE	A* E>		;"YES, SUBSTITUTE"
NOT3
	<CAMLE	C* A>	;"IS LENGTH OF SUBSTR TO LARGE?"
	<JRST	RETFALSE>
	<PUSH	P* A>		;"SAVE MAX ON STACK"
	<PUSH	P* 1 (AB)>	;"BP2"
	<MOVE	B* 3 (AB)>
	<JUMPE	A* RETFALSE>	;"LENGTH 0?"
	<JUMPE	C* RETFALSE>
	<ILDB	E* (P)>
	<PUSH	P* E>		;"SAVE FIRST CHAR OF SUBSTR"
	<SUBI	C* 1>		;"HAVE REST OF SUBSTR"
	<PUSH	P* C>		;"AND SAVE COUNT"
;"AT THIS POINT, STACK VARIABLES ARE:
	-3(P)	MAX (ARG3 OR L(S1))
	-2(P)	BYTE-POINTER TO REST OF SUBSTR
	-1(P)	FIRST CAHR OF SUBSTR
	0(P)	COUNT OF REST OF SUBSTR"

FIRST?	;"LOOKS FOR INSTANCE OF FIRST CHAR"
	<ILDB	O* B>
	<CAMN	O* E>	;"=? FIRST CHAR OF SUBSTR"
	<JRST	CHECKREST>	;"THEN LOOK AT REST"
FIRSTCON
	<SOJG	A* FIRST?>	;"ELSE LOOK FURTHER"
	<JRST	RETFALSE>	;"COUNTED OUT STRING"
CHECKREST
	<SKIPN	C* 0 (P)>	;"SINGLE CHAR?"
	<JRST	GOTCHA>		;"MATCH ONE=> MATCH SUBSTR"
	<CAILE	C* -1 (A)>	;"A NOT DECREMENTED YET"
	<JRST	RETFALSE>	;"NOT ENOUGH CHARS REMAIN"
	<MOVE	D* -2(P)>	;"RESTORE BP TO SUBSTR"
	<PUSH	P* B>		;"SAVE BP INTO STRING"
LOOPR
	<ILDB	E* D>
	<ILDB	O* B>
	<CAME	O* E>		;"COMPARE FIRSTS"
	<JRST	CONTIN>		;"NO MATCH"
	<SOJG	C* LOOPR>	;"WIN IF COUNT OUT C(C)"
	<POP	P* B>		;"GET BACK INCREMENTED BP TO STRING"
GOTCHA
	<ADD	B* [*070000000000*]>	;"DECREMENT BP"
	<SUB	A* -3 (P)>	;"REMAINING LENGTH - MAX"
	<ADD	A* 2 (AB)>	;"ADD LENGTH OF ORIGINAL STRING"
	;"(GET TYPE GRATIS)"
	<JRST FINIS>
RETFALSE
	<MOVSI	A* TFALSE>
	<SETZ	B*>
	<JRST FINIS>
CONTIN
	<POP	P* B>		;"RESTORE BP"
	<MOVE	E* -1 (P)>	;"AND FIRST SUBSTR CHAR"
	<JRST	FIRSTCON>		;"LOOK FOR ANOTHER INSTANCE OF THE FIRST CHAR"


<TITLE SUBSNC>
	<DECLARE ("VALUE" <OR STRING FALSE> STRING STRING "OPTIONAL" FIX)>
;"CHECKS FOR THIRD ARG, WHICH IS THE 'EFFECTIVE LENGTH' OF S2,
  AND LIMITS THE SEARCH FOR THE SUBSTR (S1)."
<PSEUDO <DEFINE UPPERAC (AC*)
	#DECL ((AC*) ATOM (VALUE) SPLICE)
	<CHTYPE
	(<FORM CAIL .AC* '<ASCII !"a>>
	 <FORM CAILE .AC* '<ASCII !"z>>
	 '<SKIPA>
	 <FORM SUBI .AC* 32>) SPLICE>>>
	<HLRZ	O* AB>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<CAIE	O* -6>		;"three args"
	<JRST	ONLY2>
	<PUSHJ	P* ISUBSNC3>
	<JRST FINIS>
ONLY2	<PUSHJ	P* ISUBSNC2>
	<JRST	FINIS>
<INTERNAL-ENTRY ISUBSNC2 2>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* -2(TP)>	;"length of main"
	<HRRZS	(TP)>		;"flush rhw"
<INTERNAL-ENTRY ISUBSNC3 3>
	<SUBM	M* (P)>
	<HRRZ	A* 0(TP)>	;"length of main to examine"
	<HRRZ	B* -3(TP)>	;"length of main"
	<CAMLE	A* B>		;"get min"
	<MOVE	A* B>
	<HRRZ	C* -5(TP)>	;"get length of substring"
	<CAMLE	C* A>	;"IS LENGTH OF SUBSTR TO LARGE?"
	<JRST	RETFALSE>
	<PUSH	P* A>		;"SAVE MAX ON STACK"
	<PUSH	P* -4 (TP)>	;"SUBSTRING BYTE POINTER"
	<MOVE	B* -2 (TP)>	;"main byte pointer"
	<JUMPE	A* RETFALSE>	;"LENGTH 0?"
	<JUMPE	C* RETFALSE>
	<ILDB	E* (P)>
	<UPPERAC E*>		;"make upper case"
	<PUSH	P* E>		;"SAVE FIRST CHAR OF SUBSTR"
	<SUBI	C* 1>		;"HAVE REST OF SUBSTR"
	<PUSH	P* C>		;"AND SAVE COUNT"
;"AT THIS POINT, STACK VARIABLES ARE:
	-3(P)	MAX (ARG3 OR L(S1))
	-2(P)	BYTE-POINTER TO REST OF SUBSTR
	-1(P)	FIRST CAHR OF SUBSTR
	0(P)	COUNT OF REST OF SUBSTR"

FIRST?	;"LOOKS FOR INSTANCE OF FIRST CHAR"
	<ILDB	O* B>
	<UPPERAC O*>	;"don't distinguish case"
	<CAMN	O* E>	;"=? FIRST CHAR OF SUBSTR"
	<JRST	CHECKREST>	;"THEN LOOK AT REST"
FIRSTCON
	<SOJG	A* FIRST?>	;"ELSE LOOK FURTHER"
	<JRST	RETFALSEPOP>	;"COUNTED OUT STRING"
CHECKREST
	<SKIPN	C* 0 (P)>	;"SINGLE CHAR?"
	<JRST	GOTCHA>		;"MATCH ONE=> MATCH SUBSTR"
	<CAILE	C* -1 (A)>	;"A NOT DECREMENTED YET"
	<JRST	RETFALSEPOP>	;"NOT ENOUGH CHARS REMAIN"
	<MOVE	D* -2(P)>	;"RESTORE BP TO SUBSTR"
	<PUSH	P* B>		;"SAVE BP INTO STRING"
LOOPR
	<ILDB	E* D>
	<UPPERAC E*>
	<ILDB	O* B>
	<UPPERAC O*>
	<CAME	O* E>		;"COMPARE FIRSTS"
	<JRST	CONTIN>		;"NO MATCH"
	<SOJG	C* LOOPR>	;"WIN IF COUNT OUT C(C)"
	<POP	P* B>		;"GET BACK INCREMENTED BP TO STRING"
GOTCHA
	<ADD	B* [*070000000000*]>	;"DECREMENT BP"
	<SUB	A* -3 (P)>	;"REMAINING LENGTH - MAX"
	<ADD	A* -3 (TP)>	;"ADD LENGTH OF ORIGINAL STRING"
	;"(GET TYPE GRATIS)"
	<SUB	P* [<4 (4)>]>	;"restore stacks"
	<SUB	TP* [<6 (6)>]>
	<JRST	MPOPJ>
RETFALSEPOP
	<SUB	P* [<4 (4)>]>
RETFALSE
	<MOVE	A* <TYPE-WORD FALSE>>
	<SETZ	B*>
	<SUB	TP* [<6 (6)>]>
	<JRST MPOPJ>

CONTIN
	<POP	P* B>		;"RESTORE BP"
	<MOVE	E* -1 (P)>	;"AND FIRST SUBSTR CHAR"
	<JRST	FIRSTCON>		;"LOOK FOR ANOTHER INSTANCE OF THE FIRST CHAR"




<TITLE EXTRACT>

<DECLARE ("VALUE" <OR STRING FALSE> STRING "OPTIONAL" <OR FIX STRING FALSE> FIX)>

	<HLRE	A* AB>
	<MOVMS	A>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<CAIE	A* 6>
	<JRST	EXTOPT>
	<PUSHJ	P* IEXTRACT3>
	<JRST	FINIS>

EXTOPT	<CAIE	A* 4>
	<JRST	EXT1ARG>
	<PUSHJ	P* IEXTRACT2>
	<JRST	FINIS>

EXT1ARG	<PUSHJ	P* IEXTRACT1>
	<JRST	FINIS>


<INTERNAL-ENTRY IEXTRACT1 1>

	<SUBM	M* (P)>
	<HRRZ	A* -1(TP)>
IEXTR1	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* A>
	<MCALL	1 ISTRING>
	<DPUSH	TP* A>
	<HRRZS	A>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* A>
	<JRST	IEXTR3>

<INTERNAL-ENTRY IEXTRACT2 2>

	<SUBM	M* (P)>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE FIX>>
	<JRST	IEXT11>
	<HRRZ	A* (TP)>
	<SUB	TP* [<2(2)>]>
	<JRST	IEXTR1>
IEXT11	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	EXTFLS>
	<HRRZ	A* -3(TP)>
	<HRRZ	B* -1(TP)>
	<SKIPLE	A* B>
	<MOVE	A* B>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* A>
	<JRST	IEXTR3>


<INTERNAL-ENTRY IEXTRACT3 3>

	<SUBM	M* (P)>
IEXTR3	<GETYP	O* -5(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	EXTFLS>
	<HRRZ	A* -5(TP)>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	EXTFLS>
	<HRRZ	B* -3(TP)>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE FIX>>
	<JRST	EXTFLS>
	<MOVE	C* (TP)>
	<CAMLE	C* A>		;"skips if amount being extracted is < or =
					length of source string"
	<MOVE	C* A>
	<CAMLE	C* B>
	<MOVE	C* B>
	<MOVE	A* -4(TP)>
	<MOVE	B* -2(TP)>
	<ILDB	D* A>
	<SOJL	C* HERE 3>
	<IDPB	D* B>
	<JRST	HERE -3>
	<DMOVE	A* -3(TP)>
EXTRET	<SUB	TP* [<6(6)>]>
	<JRST	MPOPJ>

EXTFLS	<DPUSH	TP* <PQUOTE BAD-ARGS-TO-EXTRACT!-ERRORS>>
	<PUSH	TP* -7(TP)>
	<PUSH	TP* -7(TP)>
	<PUSH	TP* -7(TP)>
	<PUSH	TP* -7(TP)>
	<PUSH	TP* -7(TP)>
	<PUSH	TP* -7(TP)>
	<MCALL	4 ERROR>
	<JRST	EXTFLS>

<TITLE RSHIFT>
	<DECLARE ("VALUE" STRING STRING FIX)>
	<HRRZ	C* 0 (AB)>	;"COUNT"
	<CAMGE	C* 3 (AB)>	;"COMPARE TO SHIFT QTTY"
	<JRST	OUTR>		;"ARG OUT OF RANGE"

	<LDB	D* [*360611000001*]>	;"P BITS"
	<IDIVI	D* 7>		;"GIVES # BYTES INTO WORD"
	<SUBM	C* D>		;"L-P INTO D"
	<IDIVI	D* 5>		;"E CONTAINS Q -- # BYTES IN LAST WORD"
	<SKIPN	E>		;"Q=0=>Q=5, #WORDS=#WORDS-1"
	<SUBI	D* 1>
	<SKIPN	E>
	<MOVEI	E* 5>
	<MOVEI	C* 1 (D)>	;"# WORDS INCLUDING FIRST"
	<SETZM	D>
	<CAMLE	E* 3 (AB)>	;"IS Q > SHIFT QTTY ?"
	<JRST	NOWORDS>	;"THEN DON'T DO ANY SHIFTING"	<MOVE	D* 3 (AB)>	;"# BYTES TO SHIFT"
	<ADDI	D* 5>
	<SUB	D* E>		;"-Q"
	<IDIVI	D* 5>		;"D/# WORDS TO BACK UP"
;"CROCK IS FLOOR(M+5-Q) MOD 5, WHERE M IS AMOUNT OF SHIFT,
  Q IS NUMBER OF REAL BYTES IN LAST WORD"

	<SUBI	C* -1 (D)>	;"COUNT OF TRANSFERS"
	<HRRZ	A* 1 (AB)>	;"POINTER TO TOP"
	<ADDI	A* -1 (C)>		;"POINT AT END"

	<MOVE	B* D>		;"# WORDS TO MOVE"
	<HRLI	B* A>		;"INDEX ON A"
LOOP
	<MOVE	(A)>
	<MOVEM	@ B>
	<SUBI	A* 1>		;"DEC POINTER"
	<SOJG	C* LOOP>
NOWORDS
	<MOVE	B* 1 (AB)>
	<ADD	B* D>	;"3 WORDS HACKED"
	<MOVE	A* 0 (AB)>	;"TYPE,,COUNT"
	<SUB	A* 3 (AB)>	;"SUBTRACT SHIFT QTTY"
	<JRST FINIS>


OUTR
	<PUSH	TP* $TATOM>
	<PUSH	TP* <MQUOTE ARG-OUT-OF-RANGE>>
	<JRST	CALER1>

<TITLE BACKS>
	<DECLARE ("VALUE" <OR STRING FALSE> STRING STRING "OPTIONAL" FIX)>
	;"string to search, match(es), max to back, returns backed string/FALSE"
<PUSH	TP* $TFIX>
<PUSH	TP* RETFLS>	;"large fix"
<HLRZ	AB>
<CAIE	-6>
<JRST	NOT3>
<MOVE	5 (AB)>
<MOVEM	1 (TB)>		;"fix was given"
;"find real max, top string"
NOT3
<HRRZ	A* 0 (AB)>
<LDB	D* [*360611000001*]>	;"get P bits from 1(AB)"
<IDIV	D* [-7]>		;"find -(# chars in first word)"
<ADDI	A* 5 (D)>		;"simulate *440700* pointer"
<IDIVI	A* 5>		;"# chrs/word"
<SKIPE	B>		;"number of chars in partial word"
<ADDI	A* 1>
<ADD	A* 1 (AB)>
<HLRZ	C* 1 (A)>	;"vector length"
<SUBI	C* 2>		;"account for dope words"
<IMULI	C* 5>		;"full words"
<SKIPE B>		;"no partial end word=>skip"
<SUBI	B* 5>		;"B gets # extra chars in C"
<ADD	C* B>		;"account for partial word"
<MOVE	A* 0 (AB)>	;"get visible length"
<SUBI	C* (A)>		;"find 'invisible' length"
<CAMGE	C* 1 (TB)>	;"check against 'user' length"
<MOVEM	C* 1 (TB)>	;"use least length"
;"check lengths"
<MOVE	C* 1 (TB)>
<JUMPLE	C* RETFLS>
<HRRZ	C* 2 (AB)>
<JUMPLE	C* RETFLS>
;"now start back"
<MOVE	B* 1 (AB)>	;"A contains type,,length"
LOOP1
<PUSHJ	P* BACK1>
<AOS	A>
<HRRZ	O* 2 (AB)>		;"length string 2"
<MOVE	D* 3 (AB)>
LOOP2
<ILDB	E* D>
<CAMN	E* C>
<JRST	FMATCH>		;"found match"
<SOJG	O* LOOP2>
<SOSLE	1 (TB)>		;"count down max"
<JRST	LOOP1>
;"here to return FALSE"
RETFLS
<MOVSI	A* TFALSE>
<SETZ	B*>
<JRST FINIS>
FMATCH
<HRLI	A* TSTRING>
<JRST	FINIS>

BACK1
<JUMPGE	B* JUSTBP>
<SOS	B>
<HRLI	B* *010700*>
JUSTBP
<LDB	C* B>		;"get a byte"
<ADD	B*  [<0 (*070000*)>]>
<POPJ	P*>

<TITLE FIRST-OF>
<DECLARE ("VALUE" <OR STRING FALSE> STRING STRING "OPTIONAL" FIX)>
<HRRZ	E* 2 (AB)>
<HLRZ	D* AB>
<CAIE	D* -6>	;"opt given?"
<JRST NOTHIRD>
<CAMLE	E* 5 (AB)>
<MOVE	E* 5 (AB)>	;"least of two lengths"
NOTHIRD
<HRRZ	D* 2 (AB)>	;"length"
<SUB	D* E>	;"number of extra chars, not tested"
<PUSH	P* D>	;"save for the end"
<PUSH	P* E>	;"number to test"
<JUMPE	E* DONEF>
<HRRZ	E* 0 (AB)>	;"length of test string"
<JUMPE	E* DONEF>
<MOVE	B* 3 (AB)>	;"second string"
LOOP
<ILDB	A* B>	;"get char"
<HRRZ	C* 0 (AB)>
<MOVE	D* 1 (AB)>
ILOOP
<ILDB	E* D>	;"get test char"
<CAMN	E* A>
<JRST	DONET>	;"found one"
<SOJG	C* ILOOP>	;"try next"
<SOSE	(P)>	;"count down"
<JRST	LOOP>
DONEF	;"not found"
<MOVSI	A* TFALSE>
<SETZ	B*>
<JRST	FINIS>

DONET
<POP	P* A>	;"count remaining"
<ADD	A* (P)>	;"number untested"
<HRLI	A* TSTRING>
<JUMPG	B* BACKBYTE>
<MOVSI	B* *100700*>
<AOSA	B>
BACKBYTE
<ADD	B* [<0 (*070000*)>]>
<JRST	FINIS>


<TITLE UPPERCASE>
	<DECLARE ("VALUE" STRING STRING "OPTIONAL" FIX)>
	<HRRZ	D* 0 (AB)>	;"LENGTH OF ARG1"
	<HLRZ	C* AB>
	<CAIE	C* -4>	;"ARE THERE TWO ARGS?"
	<JRST	JUST1>
	<CAMLE	D* 3 (AB)>	;"NOT > LENGTH (STRING)"
	<MOVE	D* 3 (AB)>
JUST1
	<JUMPE	D* FLUSH>	;"COUNT=0"
	<MOVE	C* 1 (AB)>	;"BP"
LOOP
	<ILDB	E* C>
	<CAILE	E* <ASCII !"z>>
	<JRST	NOTUC>	;"TOO LARGE"
	<CAIGE	E* <ASCII !"a>>
	<JRST	NOTUC>	;"TOO SMALL"
	<SUBI	E* *40*>	;"CONVERT TO LC"
	<DPB	E* C>	;"PUT BACK IN STRING"
NOTUC
	<SOJG	D* LOOP>
FLUSH
	<MOVE	A* 0 (AB)>
	<MOVE	B* 1 (AB)>
	<JRST	FINIS>

<END>

<ENDPACKAGE>
