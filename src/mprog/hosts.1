<PACKAGE "HOSTS">

<ENTRY DO-HOST-LOAD DO-HOST-FLUSH HOST SERVER MACHINE-NAME SYSTEM-NAME
	HOSTNAMES GATEWAYS ARPA-NET CHAOS-NET>

<OR <GASSIGNED? HOST-PAGE> <SETG HOST-PAGE <>>>
<OR <GASSIGNED? HOST-LEN> <SETG HOST-LEN 0>>
<SETG ARPA-NET *12*>
<SETG CHAOS-NET 7>
<MANIFEST ARPA-NET CHAOS-NET>
<SETG NET-SEARCH-LIST ![,ARPA-NET ;"ARPA"
			,CHAOS-NET    ;"CHAOS"]>
<SETG GATEWAY-LIST [,CHAOS-NET
		    ["MIT-MC" "MIT-AI"]]>
%%<SETG NWNET <BITS 8 27> ; "NETWORK NUMBER">
%%<SETG ARIMP <BITS 16 9> ; "IMP NUMBER IN ARPANET ADDRESS">
%%<SETG ARHST <BITS 8 0> ; "HOST NUMBER IN ARPANET ADDRESS">
%%<SETG ARPA-NET *12*>
%%<SETG OARIMP <BITS 6 0> ; "OLD-FORMAT ARPA IMP NUMBER">
%%<SETG OARHST <BITS 2 6> ; "OLD-FORMAT ARPA HOST NUMBER">

; "RANDOM OFFSETS"

; "TABLE LOCATIONS"
%%<SETG NAMPTR *10*>
%%<SETG SITPTR *11*>
%%<SETG NETPTR *12*>

; "NETWORK TABLE"
%%<SETG NETNUM 0>	; "NETWORK NUMBER"
%%<SETG NTRTAB 1>	; "RH-ADDRESS OF ADDRESS TABLE"

; "ADDRESS TABLES"
%%<SETG ADDADR 0>	; "ADDRESS"
%%<SETG ADLSIT 1>	; "LH-SITE TABLE ENTRY"
%%<SETG ADRCDR 1>	; "RH-NEXT ON CHAIN"

; "SITE TABLE"
%%<SETG STLNAM 0>	; "LH-OFFICIAL NAME POINTER"
%%<SETG STRADR 0>	; "RH-ADDRESS CHAIN"
%%<SETG STLSYS 1>	; "LH-SYSTEM NAME"
%%<SETG STRMCH 1>	; "RH-MACHINE NAME"
%%<SETG STLFLG 2>	; "LH-FLAGS"
%%<SETG STFSRV *400000*>; "SERVER BIT"

; "NAMES TABLE"
%%<SETG NMLSIT 0>	; "LH-SITE TABLE"
%%<SETG NMRNAM 0>	; "RH-NAME"

<TITLE DO-HOST-LOAD>
	<DECLARE ("VALUE" <OR FIX FALSE> "OPTIONAL" <OR ATOM FALSE>)>
	<JUMPL	AB* DO-ONE>
	<PUSHJ	P* IDOHL0>
	<JRST	FINIS>
DO-ONE	<DPUSH	TP* (AB)>
	<PUSHJ	P* IDOHL1>
	<JRST	FINIS>

<INTERNAL-ENTRY IDOHL0 0>
	<PUSH	TP* <TYPE-WORD FALSE>>
	<PUSH	TP* [0]>
<INTERNAL-ENTRY IDOHL1 1>
	<SUBM	M* (P)>
	<MOVE	B* <MQUOTE <RGLOC HOST-PAGE>>>
	<ADD	B* GLOTOP 1>
	<GETYP	O* (B)>
	<CAIN	O* <TYPE-CODE FALSE>>
	 <JRST	DOOPEN>
	<SKIPL	(TP)>			; "RELOAD ANYWAY?"
	 <JRST	[
<IFOPSYS (ITS	 <HRLZ	A* 1(B)>
		 <ADD	A* [<(*200*) C>]>
		 <*SUSET A>		; ".RPMAP OF FIRST PAGE"
		 <JUMPE	C* DOOPEN>	; "PAGE DOESN'T EXIST, SO RELOAD"
		 <MOVE	B* 1(B)>)
	 (TOPS20 <MOVE	C* B>		; "SAVE LOCATIVE"
		 <HRRZ	A* 1(B)>
	  	 <HRLI	A* *400000*>
		 <RMAP>
		 <JUMPE	B* DOOPEN>
		 <MOVE	B* 1(C)>)>
		 <MOVSI	A* <TYPE-CODE FIX>>
		 <JRST	HLOUT>]>
DOOPEN	<DPUSH	TP* <PQUOTE "READ">>
<IFOPSYS
(TOPS20	<DPUSH	TP* <PQUOTE "<SYSTEM>HOSTS2.BIN">>)
(ITS	<DPUSH	TP* <PQUOTE "SYSBIN;HOSTS2 >">>)>
	<MCALL	2 OPEN>			; "TRY TO OPEN IT"
	<JUMPGE	B* HLOUT>		; "FAIL"
	<DPUSH	TP* A>			; "SAVE THE CHANNEL"

<IFOPSYS
(TOPS20	<PUSH	P* 1(B)>		; "SAVE CHANNEL"
	<MOVE	A* 1(B)>
	<SIZEF>
	 <HALTF>
	<MOVE	A* C>			; "NUMBER OF 512 WD PAGES"
	<ADDI	A* 1>
	<LSH	A* -1>
	<POP	P* C>)
(ITS	<MOVE	C* 1(B)>		; "PICK UP THE CHANNEL NUMBER"
 	<*CALL	[<SETZ>
		 <SIXBIT "FILLEN">
		 <MOVE	C>
		 <SETZM	A>]>		; "GET THE FILE LENGTH"
	 <*LOSE	*1400*>
	<IDIVI	A* *2000*>
	<JUMPE	B* NOREM>
	<ADDI	A* 1>)>
; "NUMBER OF PAGES NEEDED IS IN A"
NOREM	<MOVE	B* <MQUOTE <RGLOC HOST-PAGE>>>
	<ADD	B* GLOTOP 1>
	<GETYP	O* (B)>
	<CAIE	O* <TYPE-CODE FALSE>>
	 <JRST	[<MOVE	D* <MQUOTE <RGLOC HOST-LEN>>>
		 <ADD	D* GLOTOP 1>
		 <CAMG	A* 1(D)>	; "HAS THE FILE GROWN ENOUGH TO NEED A NEW PAGE?"
		  <JRST	DO-MAP>		; "NO"
		 <PUSH	P* A>
		 <PUSH	P* C>
		 <PUSHJ	P* IFLUSH>	; "FLUSH THE OLD TABLE, THEN"
		 <POP	P* C>
		 <POP	P* A>
		 <JRST	FOO>]>	; "AND START FROM SCRATCH"
; "GET PAGES FOR HOST TABLE.  NUMBER NEEDED IS IN A; CHANNEL # IS IN C"
FOO	<PUSH	P* C>
	<PUSH	P* A>
	<PUSHJ	P* PGFIND>
	<JUMPLE	B* [<ERRUUO* <MQUOTE CANT-GET-PAGES>>]>
	<POP	P* A>
	<POP	P* C>
	<MOVE	D* <MQUOTE <RGLOC HOST-LEN>>>
	<ADD	D* GLOTOP 1>
	<MOVEM	A* 1(D)>
	<MOVSI	O* <TYPE-CODE FIX>>
	<MOVEM	O* (D)>			; "SETG HOST-LEN"
	<MOVE	D* <MQUOTE <RGLOC HOST-PAGE>>>
	<ADD	D* GLOTOP 1>
	<IFOPSYS (TOPS20 <LSH B* 1>)>	; "SO SAVE 20X PAGE #"
	<MOVEM	B* 1(D)>
	<MOVEM	O* (D)>			; "SETG HOST-PAGE"
	<JRST	DO-MAP1>
; "# PAGES TO MAP IN A, CHANNEL IN C, CORE PAGE IN B (AT DO-MAP1)
   OR LOCATIVE IN B (AT DO-MAP)"
DO-MAP	<MOVE	B* 1(B)>	; "GET HOST-PAGE INTO B (ASSUMES LOCD IN B)"
DO-MAP1	<PUSH	P* B>
<IFOPSYS
(ITS	<MOVNS	A>
	<HRL	B* A>
	<*CALL	[<SETZ>
		 <SIXBIT "CORBLK">
		 <MOVEI *10000*> ; "%CBNDR"
		 <MOVEI -1>	 ; "%JSELF"
		 <MOVE	B>
		 <SETZ	C>]>
	 <*LOSE	*1000*>)
(TOPS20	<EXCH	A* C>
	<HRLZS	A>
	<HRLI	B* *400000*>
	<LSH	C* 1>		;"ITTY BITTY TWENEX PAGES"
	<HRLI	C* *600000*>	;"PM%CNT+PM%RD"
	<PMAP>)>
	<MCALL	1 CLOSE>	; "WE PUSHED THE CHANNEL A WHILE BACK, REMEMBER?"
	<POP	P* B>
	<MOVSI	A* <TYPE-CODE FIX>>
HLOUT	<SUB	TP* [<(2) 2>]>
	<JRST	MPOPJ>

<SUB-ENTRY DO-HOST-FLUSH ("VALUE" ATOM)>
	<PUSHJ	P* IFLUSH>
	<JRST	FINIS>

<INTERNAL-ENTRY IFLUSH 0>
	<SUBM	M* (P)>
	<MOVE	C* <MQUOTE <RGLOC HOST-PAGE>>>
	<ADD	C* GLOTOP 1>
	<GETYP	O* (C)>
	<CAIN	O* <TYPE-CODE FALSE>>
	 <JRST	FLUSHO>
	<MOVE	B* 1(C)>		; "PAGE NUMBER"
	<MOVSI	O* <TYPE-CODE FALSE>>
	<MOVEM	O* (C)>
	<SETZM	1(C)>			; "MAKE IT BE FALSE"
	<MOVE	C* <MQUOTE <RGLOC HOST-LEN>>>
	<ADD	C* GLOTOP 1>
	<MOVE	A* 1(C)>		; "NUMBER OF PAGES"
	<SETZM	1(C)>			; "ZERO IT"
	<PUSH	P* A>
	<PUSH	P* B>
<IFOPSYS
(ITS	<MOVNI	C* (A)>
	<HRLS	C>
	<HRR	C* B>			; "AOBJN POINTER"
	<*CALL	[<SETZ>
		 <SIXBIT "CORBLK">
		 <MOVEI	0>
		 <MOVEI -1>
		 <SETZ	C>]>	; "FLUSH THE PAGES"
	 <JFCL>)
(TOPS20	<MOVE	C* A>
	<LSH	C* 1>		;"ITTY BITTY TWENEX PAGES"
	<HRLI	C* *400000*>	;"PM%CNT"
	<MOVNI	A* 1>
	<HRLI	B* *400000*>
	<PMAP>)>
	<POP	P* B>
	<POP	P* A>
<IFOPSYS (TOPS20
	<LSH	B* -1>)>
	<PUSHJ	P* PGGIVE>		; "GIVE BACK TO INTERPRETER"
FLUSHO	<MOVSI	A* <TYPE-CODE ATOM>>
	<MOVE	B* <MQUOTE T>>
	<JRST	MPOPJ>


; "TAKE HOST NUMBER OR NAME, RETURN NAME IF GIVEN NUMBER, NUMBER IF GIVEN
   NAME, FALSE IF NOT FOUND."
<SUB-ENTRY HOST ("VALUE" <OR FALSE STRING FIX> <OR FIX STRING>
		 "OPTIONAL" <OR FIX FALSE>)>
	<MOVE	A* AB>
HPLOOP	<PUSH	TP* (AB)>
	<AOBJN	AB* HPLOOP>
	<HLRES	A>
	<ASH	A* -1>
	<ADDI	A* HPTABE>
	<PUSHJ	P* @ (A) 1>
	<JRST	FINIS>
	<IHOST2>
HPTABE	<IHOST1>

<INTERNAL-ENTRY IHOST1 1>
	<PUSH	TP* <TYPE-WORD FALSE>>
	<PUSH	TP* [0]>
<INTERNAL-ENTRY IHOST2 2>
	<SUBM	M* (P)>
	<PUSH	TP* -3(TP)>
	<PUSH	TP* -3(TP)>
	<PUSHJ	P* NUMTBS> ; "SEARCH RIGHT TABLE.  RETURNS SITE TABLE ENTRY"
			   ; "INSTEAD OF TYPE IN A, RETURNS TABLE ADDRESS"
	 <JRST	OTFALS>    ; "FAILED, RETURN FALSE"
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE FIX>>
	 <JRST	NUMHAK>			; "RETURN A NET ADDRESS"
	<HLRZ	B* STLNAM(B)>		; "GET FILE ADDRESS OF OFFICIAL NAME"
	<ADDI	B* (A)>			; "CORE ADDRESS"
	<PUSHJ	P* STRGET>		; "RETURN STRING POINTER IN A AND B"
HSTOUT	<SUB	TP* [<(6) 6>]>
	<JRST	MPOPJ>
; "RETURN A FALSE"
OTFALS	<MOVSI	A* <TYPE-CODE FALSE>>
	<MOVEI	B* 0>
	<JRST	HSTOUT>

; "POINTER TO SITE IN A & B, RETURN PREFERRED ADDRESS OR FALSE,
ALSO IN A AND B"
NUMHAK	<PUSH	P* B>
	<PUSH	P* C>
	<PUSH	P* E>
	<PUSH	P* F>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE FIX>>
	 <JRST	ANYNET>
	<SKIPN	E* -2(TP)>
	 <JRST	ANYNET>
	<MOVEI	F* 0>
	<JRST	NUMSL1>
ANYNET	<MOVE	B* <MQUOTE <RGLOC NET-SEARCH-LIST T>>>
	<ADD	B* GLOTOP 1>
	<MOVE	F* 1(B)>
NUMSL	<MOVE	E* (F)>
NUMSL1	<MOVE	B* -3(P)>
	<HRRZ	B* STRADR(B)>		;"ADDRESS OF FIRST ADDRESS TABLE ENTRY"
	<JUMPE	B* NUMFAL>
	<PUSHJ	P* NUMLOP>
	 <JRST	NUMNXT>
;	<LDB	C* [<NWNET B>]>
;	<CAIE	C* ARPA-NET>
;	 <JRST	NUMNOZ>
;	<MOVEI	C* 0>
;	<DPB	C* [<NWNET B>]>		; "FOR NOW, ZERO THE NETWORK NUMBER"
NUMNOZ	<POP	P* F>
	<POP	P* E>
	<POP	P* C>
	<SUB	P* [<(1) 1>]>
	<JRST	HSTOUT>			; "RETURN"
NUMNXT	<AOBJN	F* NUMSL>
NUMFAL	<POP	P* F>
	<POP	P* E>
	<POP	P* C>
	<POP	P* B>
	<JRST	OTFALS>

; "SITE IN A, ADDRESS TABLE POINTER IN B, NET IN E. RETURNS # IN B, SKIPS
IF WON"
NUMLOP	<ADDI	B* (A)>
	<MOVE	C* ADDADR(B)>
	<LDB	D* [<NWNET C>]>		; "GET NETWORK #"
	<CAMN	D* E>			; "RIGHT NETWORK?"
	 <JRST	NUMFND>
	<HRRZ	B* ADRCDR(B)>
	<JUMPN	B* NUMLOP>		; "NEXT"
	<POPJ	P*>			; "FAILED"
NUMFND	<MOVSI	A* <TYPE-CODE FIX>>
	<MOVE	B* C>
	<AOS	(P)>
	<POPJ	P*>

; "TAKE CORE ADDRESS IN B, RETURN STRING POINTER IN A AND B"
STRGET	<PUSH	P* C>
	<SUBI	B* 1>
	<HRLI	B* *010700*>		; "BYTE POINTER"
	<PUSH	P* B>			; "SAVE IT"
	<MOVEI	A* 0>
STRLOP	<ILDB	C* B>
	<JUMPE	C* STRGOT>
	<AOJA	A* STRLOP>
STRGOT	<HLL	A* <TYPE-WORD STRING>>
	<POP	P* B>
	<POP	P* C>
	<POPJ	P*>

; "RETURN NAME OF MACHINE (PDP10, ETC.)"
<SUB-ENTRY MACHINE-NAME ("VALUE" <OR FALSE STRING FIX> <OR FIX STRING>)>
	<DPUSH	TP* (AB)>
	<PUSHJ	P* IMACH>
	<JRST	FINIS>

<INTERNAL-ENTRY IMACH 1>
	<SUBM	M* (P)>
	<PUSHJ	P* NUMTBS>
	 <JRST	OTFALS>			; "NO SUCH MACHINE"
	<HRRZ	B* STRMCH(B)>		; "GET POINTER TO MACHINE NAME"
	<JUMPE	B* RETZERO>		; "UNKNOWN"
	<ADDI	B* (A)>			; "ADDRESS OF NAME"
	<PUSHJ	P* STRGET>		; "MAKE A STRING POINTER"
	<JRST	HSTOUT>
RETZERO	<MOVSI	A* <TYPE-CODE FIX>>
	<MOVEI	B* 0>
	<JRST	HSTOUT>

<SUB-ENTRY SYSTEM-NAME ("VALUE" <OR FALSE STRING FIX> <OR FIX STRING>)>
	<DPUSH	TP* (AB)>
	<PUSHJ	P* ISYS>
	<JRST	FINIS>

<INTERNAL-ENTRY ISYS 1>
	<SUBM	M* (P)>
	<PUSHJ	P* NUMTBS>
	 <JRST	OTFALS>
	<HLRZ	B* STLSYS(B)>
	<JUMPE	B* RETZERO>
	<ADDI	B* (A)>
	<PUSHJ	P* STRGET>
	<JRST	HSTOUT>

<SUB-ENTRY SERVER ("VALUE" <OR FALSE FIX> <OR FIX STRING>)>
	<DPUSH	TP* (AB)>
	<PUSHJ	P* ISERVER>
	<JRST	FINIS>

<INTERNAL-ENTRY ISERVER 1>
	<SUBM	M* (P)>
	<PUSHJ	P* NUMTBS>
	 <JRST	OTFALS>
	<HLRZ	C* STLFLG(B)>
	<MOVEI	B* 0>
	<TRNE	C* STFSRV>
	 <MOVNI	B* 1>
	<MOVSI	A* <TYPE-CODE FIX>>
	<JRST	HSTOUT>

; "RETURN VECTOR CONTAINING ALL NAMES FOR HOST"
<SUB-ENTRY HOSTNAMES ("VALUE" <OR FALSE <VECTOR [REST STRING]>> <OR FIX STRING>)>
	<DPUSH	TP* (AB)>
	<PUSHJ	P* IHOSTN>
	<JRST	FINIS>

<INTERNAL-ENTRY IHOSTN 1>
	<SUBM	M* (P)>
	<PUSHJ	P* NUMTBS>
	 <JRST	OTFALS>
	<SUBI	B* (A)>			; "TURN BACK INTO FILE ADDRESS"
	<PUSH	P* A>
	<PUSH	P* B>
	<MOVE	C* NAMPTR(A)>		; "FILE ADDRESS OF NAME TABLE"
	<ADDI	C* 2(A)>		; "SKIP HEADER OF NAME TABLE"
	<MOVN	D* -2(C)>		; "- NUMBER OF ENTRIES"
	<IMUL	D* -1(C)>		; "MULTIPLY BY WORDS/ENTRY"
	<MOVE	E* -1(C)>
	<HRLS	E>			; "WORDS/ENTRY,,WORDS/ENTRY"
	<PUSH	P* E>
	<HRL	C* D>			; "AOBJN POINTER TO TABLE"
	<PUSH	P* [0]>			; "COUNTER"
HSNLOP	<HLRZ	E* NMLSIT(C)>
	<CAME	E* -2(P)>		; "SAME AS SAVED SITE TABLE?"
	 <JRST	ENDLOP>
	<HRRZ	B* NMRNAM(C)>		; "GET THE NAME POINTER"
	<ADD	B* -3(P)>		; "IN CORE"
	<PUSHJ	P* STRGET>
	<DPUSH	TP* A>
	<AOS	(P)>
ENDLOP	<ADD	C* -1(P)>
	<JUMPL	C* HSNLOP>
	<POP	P* A>
	<SUB	P* [<(3) 3>]>
	<PUSHJ	P* CIVEC>		; "RETURN A VECTOR"
	<JRST	HSTOUT>			; "FLUSH"

<SUB-ENTRY GATEWAYS ("VALUE" <OR FALSE <VECTOR [REST STRING]>> FIX)>
	<DPUSH	TP* (AB)>
	<PUSHJ	P* IGATE>
	<JRST	FINIS>

<INTERNAL-ENTRY IGATE 1>
	<SUBM	M* (P)>
	<LDB	A* [<NWNET (TP)>]>
	<MOVE	B* <MQUOTE <RGLOC GATEWAY-LIST T>>>
	<ADD	B* GLOTOP 1>
	<MOVE	B* 1(B)>
GATLOP	<CAMN	A* 1(B)>
	 <JRST	GATOUT>
	<ADD	B* [<(4) 4>]>
	<JUMPL	B* GATLOP>
	<JRST	OTFALS>
GATOUT	<MOVE	A* 2(B)>
	<MOVE	B* 3(B)>
	<SUB	TP* [<(2) 2>]>
	<JRST	MPOPJ>

; "
ROUTINE TO SEARCH NAMES TABLE OR ADDRESS TABLE FOR HOST (STRING OR FIX).
SKIPS IF SUCCESS.  ON SUCCESS, RETURNS POINTER TO HOST TABLE IN A, CORE
ADDRESS OF SITE TABLE ENTRY FOR SPECIFIED HOST IN B.  ARG IS TOP OF TP
STACK, NOT POPPED."

NUMTBS	<SUBM	M* (P)>
ERRTRY	<PUSHJ	P* IDOHL0>		; "MAKE SURE HOST TABLE LOADED"
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE FIX>>
	 <JRST	[<DPUSH	TP* <PQUOTE CANT-LOAD-HOST-TABLE>>
		 <DPUSH	TP* A>
		 <DPUSH	TP* <PQUOTE NUMTBS>>
		 <MCALL 3 ERROR>
		 <JRST	ERRTRY>]>
	<IFOPSYS (TOPS20 <IMULI B* *1000*>)
		 (ITS    <IMULI	B* *2000*>)>	; "CORE ADDRESS OF HOST TABLE"
	<PUSH	P* B>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE FIX>>	; "ARG A FIX?"
	 <JRST	STRSRC>			; "NO, SO STRING-->FIX"
	<MOVE	A* (TP)>		; "HOST ADDRESS"
	<PUSHJ	P* OTONEW>		; "CONVERT TO NEW FORMAT, IF NOT ALREADY"
	<MOVEM	A* (TP)>		; "SAVE"
; "FIRST, GET RIGHT ADDRESS TABLE BY SEARCHING NETWORK TABLE"
	<MOVE	C* NETPTR(B)>		; "NETWORK TABLE ADDRESS"
	<ADDI	C* (B)>			; "CORE ADDRESS"
	<MOVN	D* (C)>			; "NUMBER OF ENTRIES"
	<IMUL	D* 1(C)>		; "LENGTH OF TABLE"
	<HRL	C* D>
	<MOVE	D* 1(C)>
	<HRLS	D>			; "LEN,,LEN"
	<ADDI	C* 2>			; "BEGINNING OF TABLE"
	<LDB	E* [<NWNET (TP)>]>	; "GET NET NUMBER"
NETLOP	<CAMN	E* NETNUM (C)>		; "COMPARE"
	 <JRST	NETWON>			; "FOUND IT"
	<ADD	C* D>
	<JUMPL	C* NETLOP>
	<JRST	NUMLOS>			; "NO SUCH NET"
NETWON	<HRRZ	B* NTRTAB(C)>		; "FILE ADDRESS OF ADDRESS TABLE"
	<ADD	B* (P)>			; "CORE ADDRESS"
	<PUSH	P* B>
	<PUSH	P* [<PUSHJ P* HADCMP>]> ; "HOST ADDRESS COMPARISON"
	<MOVE	F* -2(P)>		; "BASE ADDRESS"
	<PUSHJ	P* BINSRC>
	 <JRST	NUMLOS>
	<HLRZ	B* ADLSIT (B)>		; "SITE TABLE ENTRY"
	<ADD	B* (P)>			; "CORE ADDRESS"
NUMWIN	<SOS	-1(P)>
NUMLOS	<POP	P* A>
	<JRST	MPOPJ>
; "STRING-->FIX HACK"
STRSRC	<MOVE	C* NAMPTR(B)>
	<ADDI	C* (B)>
	<PUSH	P* C>
	<PUSH	P* [<PUSHJ P* STRCMP>]>
	<MOVE	F* -2(P)>		; "BASE ADDRESS"
	<PUSHJ	P* BINSRC>
	 <JRST	NUMLOS>
	<HLRZ	B* NMLSIT(B)>
	<ADD	B* (P)>
	<JRST	NUMWIN>

; "CONVERT OLD-STYLE ARPA ADDRESS TO NEW FORMAT, IF THING IN A IS OLD-STYLE.
   RETURN HOST ADDRESS IN A."
OTONEW	<PUSH	P* B>
	<LDB	B* [<NWNET A>]>		; "NETWORK # TO B"
	<JUMPN	B* OTONEO>		; "MUST BE NEW FORMAT ALREADY, SO FLUSH"
	<CAIL A* *400*>
	 <JRST NETSTF>			; "NEW-STYLE WITH 0 NET, SO PUT THAT IN"
	<PUSH	P* C>
	<LDB	C* [<OARIMP A>]>	; "GET THE IMP NUMBER"
	<DPB	C* [<ARIMP B>]>
	<LDB	C* [<OARHST A>]>
	<DPB	C* [<ARHST B>]>
	<POP	P* C>
	<MOVE	A* B>
NETSTF	<MOVEI	B* ARPA-NET>		; "NOW PUT IN THE NETWORK NUMBER"
	<DPB	B* [<NWNET A>]>
OTONEO	<POP	P* B>
	<POPJ	P*>

; "COMPARISON ROUTINES FOR BINARY SEARCH.  ALL TAKE POINTER TO APPROPRIATE TABLE
   ENTRY IN B.  MAY CLOBBER AC 0.  SKIP 0, 1, OR 2 TIMES, DEPENDING ON HOW THE
   COMPARISON COMES OUT.  EXPECT TARGET TO BE (TP)."

; "COMPARISON FOR ADDRESS TABLE.  ADDRESS IS TOP OF STACK."
HADCMP	<MOVE	O* ADDADR(B)>		; "PICK UP NET # FROM TABLE"
NUMCMP	<CAMLE	O* (TP)>
	 <POPJ	P*>			; "NO SKIP IF TABLE OFFSET IS TOO HIGH"
	<AOS	(P)>			; "AT LEAST ONE SKIP OTHERWISE"
	<CAML	O* (TP)>
	 <AOS	(P)>
	<POPJ	P*>

; "COMPARISON FOR NAME TABLE.  SORTED BY TREATING NAMES AS VECTORS OF SIGNED
   INTEGERS (IN CONTRAST TO TREATING THEM AS ASCII STRINGS, WHICH WOULD MAKE
   THIS MUCH SIMPLER)(BUT SLOWER IN GENERAL)."
STRCMP	<SUBM	M* (P)>
	<INTGO>
	<PUSH	P* A>
	<PUSH	P* B>
	<PUSH	P* C>
	<PUSH	P* D>
	<PUSH	P* E>
	<HRRZ	B* NMRNAM(B)>		; "POINTER TO NAME"
	<ADDI	B* (F)>			; "CORE ADDRESS OF TABLE"
	<MOVE	A* (TP)>
	<HRRZ	C* -1(TP)>		; "GET LENGTH OF OUR STRING"
STRCLP	<PUSHJ	P* GETWRD>		; "GET A WORD OF ASCII FROM OUR STRING, IN D"
	<MOVE	E* (B)>
	<LSH	E* -1>
	<CAMGE	D* E>			; "COMPARE WITH NEXT WORD OF FILE STRING"
	 <JRST	STROUT>			; "FLUSH, NO SKIPS"
	<CAME	D* E>
	 <JRST	STROU1>			; "FLUSH, ONE SKIP"
	<JUMPLE	C* CHFDON>		; "OUR STRING IS DONE, SO CHECK FILE"
	<LDB	D* [<(*010702*) 0>]>	; "EXAMINE LAST BYTE OF THIS WORD OF FILE STRING"
	<JUMPE	D* FILSHR>		; "FILE STRING IS SHORTER"
	<SKIPE	1(B)>			; "IS NEXT WORD OF STRING ALL ZERO?"
	 <JRST	STRCON>			; "NO"
; "HERE IF FILE STRING IS SHORTER THAN USER STRING"
FILSHR	<JRST	STROU1>			; "NULL SORTS AHEAD OF EVERYTHING"

; "USER STRING EXHAUSTED.  CHECK FILE STRING"
CHFDON	<LDB	D* [<(*010702*) 0>]>
	<JUMPE	D* STROU2>		; "SO'S THE FILE STRING, SO WIN"
	<SKIPN	D* 1(B)>
	 <JRST	STROU2>			; "NEXT WORD ALL 0, SO EXHAUSTED ANYWAY"
	<JRST	STROUT>			; "DECREASE TABLE OFFSET"

; "NEITHER STRING EXHAUSTED, STILL EQUAL."
STRCON	<AOJA	B* STRCLP>		; "POINT TO NEXT FILE WORD, CONTINUE"

STROU2	<SOS	-5(P)>
STROU1	<SOS	-5(P)>
STROUT	<POP	P* E>
	<POP	P* D>
	<POP	P* C>
	<POP	P* B>
	<POP	P* A>
	<JRST	MPOPJ>

; "GET A WORD OF ASCII FROM A MUDDLE STRING.  POINTER IS IN A, LENGTH IN C,
   RESULT GOES IN D.  O IS SCRATCH."
GETWRD	<PUSH	P* E>
	<TLNN	A* *760000*>		; "DON'T SKIP IF ALREADY WORD-ALIGNED"
	 <JRST	[<MOVE	D* 1(A)>		; "GET THE WORD"
		 <ADDI	A* 1>
		 <SUBI	C* 5>		; "UPDATE LENGTH"
		 <JUMPGE C* UPPERC>
		 <MOVEI	O* [<(*776000*) 0>
			    <(*777770*) 0>
			    <(*777777*) *740000*>
			    <(*777777*) *777600*>] 4>
		 <ADD	O* C>
		 <AND	D* @ O>
		 <JRST	UPPERC>]>
	<MOVE	E* [<(*440700*) D>]>	; "POINTER TO D"
	<MOVEI	D* 0>
GETLOP	<ILDB	O* A>			; "GET A CHAR"
	<IDPB	O* E>
	<SUBI	C* 1>
	<TLNE	E* *760000*>		; "SKIP IF D IS FULL"
	 <JUMPG	C* GETLOP>		; "JUMP IF D NOT FULL & CHARS LEFT IN STRING"
UPPERC	<MOVE	E* [<(*402010*) *40200*>]>
	<AND	E* D>			; "MASK FOR CHARS > 100"
	<LSH	E* -1>			; "MASK 40 BITS IN SUCH CHARS"
	<TDZ	D* E>			; "AND TURN THEM OFF"
	<LSH	D* -1>			; "LSH RIGHT, TO CLEAR SIGN BIT"
	<POP	P* E>
	<POPJ	P*>


; "DO BINARY SEARCH.  TAKES TWO ARGUMENTS, ON P:  FIRST IS CORE ADDRESS OF TABLE
   TO SEARCH, SECOND IS INSTRUCTION TO EXECUTE FOR COMPARISONS.  ALL TABLES ARE
   ASSUMED TO HAVE TWO-WORD HEADER:  # ENTRIES, WORDS/ENTRY.  RETURNS IN B A POINTER
   TO THE WINNING ENTRY, IF IT SKIPS.
   CALLED WITH BASE ADDRESS IN F, FOR NO GOOD REASON
   CLOBBERS EVERY CONCEIVABLE AC.
   THE THING BEING SEARCHED FOR IS ASSUMED BY THE COMPARISON ROUTINES TO BE (TP),
   THOUGH OBVIOUSLY IT COULD BE ELSEWHERE; BINSRC DOESN'T DO ANYTHING TO TP, SO THIS
   WILL WORK.  COMPARISON ROUTINES SHOULD SKIP TWICE IF A MATCH, ONCE IF >, NOT AT ALL
   IF <.  THEY ARE CALLED WITH A POINTER TO THE APPROPRIATE TABLE ENTRY IN B, AND SHOULD
   CLOBBER NO AC'S OTHER THAN 0."

BINSRC	<SUBM	M* (P)>
	<INTGO>
	<MOVE	B* -2(P)>		; "CORE ADDRESS OF TABLE"
	<MOVE	A* (B)>			; "NUMBER OF ENTRIES"
	<PUSH	P* A>
	<PUSH	P* A>
	<PUSH	P* 1(B)>		; "WORDS/ENTRY"
	<IMUL	A* (P)>			; "LENGTH OF TABLE"
	<PUSH	P* A>
	<ADDI	B* 2>			; "POINT TO FIRST ENTRY"
	<ADDM	B* (P)>			; "FIRST WORD PAST TABLE"
	<PUSH	P* B>
BINLOP	<MOVE	A* -4(P)>
	<JUMPE	A* BINOUT>		; "TERMINATE"
	<SKIPN	-3(P)>			; "DIDN'T CHANGE?"
	 <JRST	BINOUT>			; "FLUSH"
	<ASH	A* -1>			; "DIVIDE LENGTH BY TWO"
	<MOVEM	A* -3(P)>		; "SAVE"
	<IMUL	A* -2(P)>		; "OFFSET"
	<ADDI	B* (A)>
	<CAML	B* -1(P)>
	 <JRST	BINDWN>
	<XCT	-6(P)>			; "COMPARISON INSTRUCTION"
	 <JRST	BINDWN>			; "REDUCE OFFSET"
	 <JRST	BINUP>			; "INCREASE OFFSET"
	<SOS	-5(P)>			; "WON"
BINOUT	<MOVE	A* -5(P)>		; "RETURN ADDRESS"
	<SUB	P* [<(8) 8>]>
	<SUBM	M* A>
	<JRST	(A)>			; "RETURN"

; "REDUCE TABLE OFFSET"
BINDWN	<MOVE	B* (P)>			; "JUST RESTORE TABLE BEGINNING"
	<MOVE	A* -3(P)>
	<MOVEM	A* -4(P)>		; "NEW LENGTH"
	<JRST	BINLOP>

; "INCREASE TABLE OFFSET"
BINUP	<MOVE	A* -4(P)>
	<SUB	A* -3(P)>
	<MOVEM	A* -4(P)>
	<MOVEM	B* (P)>			; "NEW TABLE BEGINNING"
	<JRST	BINLOP>
<END>
<ENDPACKAGE>