
<PACKAGE "LUP">

<USE "SDM">

<ENTRY LUP-ACT LUP-DCT LUP-DEC LUP-ADD-DATUM LUP-ADD-PACK LUP-MOVE
       LUP-ADD-ENTRY LUP-DEL-ENTRY LUP-DEL>

<OR <GASSIGNED? FC-BUF> <SETG FC-BUF <IUVECTOR 100 0>>>

<DEFINE FC (I O "AUX" (IC <OPEN "READB" .I>) (OC <OPEN "PRINTB" .O>))
	#DECL ((I O) STRING (IC OC) <OR CHANNEL FALSE>)
	<COND (<NOT <AND .IC .OC>>
	       <AND .IC <CLOSE .IC>>
	       <AND .OC <CLOSE .OC>>
	       <AND .IC .OC>)
	      (T
	       <REPEAT ((N <FILE-LENGTH .IC>) (BUF ,FC-BUF))
		       #DECL ((N) FIX (BUF) <UVECTOR [REST FIX]>)
		       <COND (<0? .N> <RETURN>)
			     (<G=? .N <LENGTH .BUF>>
			      <READB .BUF .IC>
			      <PRINTB .BUF .OC>
			      <SET N <- .N <LENGTH .BUF>>>)
			     (<SET BUF <REST .BUF <- <LENGTH .BUF> .N>>>)>>
	       <CLOSE .IC>
	       <CLOSE .OC>
	       T)>>

<DEFINE LOCK (FILNM
	      "AUX" CHN (LNAME <STRING .FILNM " _LOCK_">)
		    (BNM <STRING .FILNM " _BLOK_">))
	<REPEAT ()
		<COND (<SET CHN <OPEN "PRINTO" .LNAME>> <RETURN .CHN>)
		      (<=? <1 .CHN> "FILE LOCKED"> <RETURN .CHN>)>
		<COND (<SET CHN <OPEN "PRINT" .BNM>>) (<RETURN .CHN>)>
		<CLOSE .CHN>
		<RENAME .BNM TO .LNAME>>>

<DEFINE UNLOCK (CHN "AUX" (SNM <6 .CHN>))
	#DECL ((CHN) CHANNEL (SNM) <SPECIAL STRING>)
	<RENAME .CHN "_UN LOCK_">
	<CLOSE .CHN>
	<RENAME "_UN LOCK_">>

<OR <GASSIGNED? ACTIVE-LUP> <SETG ACTIVE-LUP <>>>

<OR <GASSIGNED? DBASE-LOCKED> <SETG DBASE-LOCKED <>>>

<DEFINE LUP-ACT (FIL
		 "OPTIONAL" (DO-GC <>)
		 "AUX" (TMS <STRING .FIL " _" ,L-ITEMS-NAME>)
		       (NDX <STRING .FIL " _" ,L-INDEX-NAME>)
		       (OTMS <STRING .FIL " " ,L-ITEMS-NAME>)
		       (ONDX <STRING .FIL " " ,L-INDEX-NAME>) TMP VAL
		       (IN-LOCK <>))
	#DECL ((FIL TMS NDX OTMS ONDX) STRING)
	<SET VAL
	     <PROG ()
		   <COND (,ACTIVE-LUP
			  <RETURN <CHTYPE (,ACTIVE-LUP "CURRENTLY ACTIVATED")
					  FALSE>>)>
		   <COND (<SETG DBASE-LOCKED <SET IN-LOCK <LOCK .FIL>>>)
			 (T <RETURN #FALSE ("DATA BASE LOCKED")>)>
		   <COND (<SET TMP <SDMACT .OTMS>> <SDMDCT .TMP>)
			 (<RETURN .TMP>)>
		   <COND (<SET TMP <SDMACT .ONDX>> <SDMDCT .TMP>)
			 (<RETURN .TMP>)>
		   <COND (.DO-GC <SET TMP ,SDMGBC>) (T <SET TMP ,FC>)>
		   <APPLY .TMP .OTMS .TMS>
		   <APPLY .TMP .ONDX .NDX>
		   <SETG INDX-CHN <SDMACT .NDX>>
		   <SETG ITMS-CHN <SDMACT .TMS>>
		   <COND (<NOT <AND ,INDX-CHN ,ITMS-CHN>>
			  <AND ,INDX-CHN <SDMDCT ,INDX-CHN>>
			  <AND ,ITMS-CHN <SDMDCT ,ITMS-CHN>>
			  <RETURN <AND ,INDX-CHN ,ITMS-CHN>>)>
		   <SETG UPN1 .TMS>
		   <SETG UPN2 .NDX>
		   <SETG OSNM <SNAME>>
		   <SETG ON1 .OTMS>
		   <SETG ON2 .ONDX>
		   <SETG ACTIVE-LUP .FIL>
	 	   <CRLF>
		   <PRINC .FIL>
		   <PRINC " ACTIVATED">
		   <RETURN ,NULL>>>
	<COND (<AND <NOT .VAL> .IN-LOCK>
	       <RENAME .TMS>
	       <RENAME .NDX>
	       <UNLOCK .IN-LOCK>
	       <SETG DBASE-LOCKED <>>)>
	.VAL>

<DEFINE LUP-DCT ("AUX" (SNM ,OSNM) RN1 RN2)
	#DECL ((SNM) <SPECIAL STRING>)
	<PROG ()
	      <OK-BASE?>
	      <COND (<NOT ,ACTIVE-LUP> <RETURN #FALSE ("NO DATA BASE ACTIVE")>)>
	      <SDMDCT ,INDX-CHN>
	      <SDMDCT ,ITMS-CHN>
	      <SET RN1 <OPEN "PRINTO" ,UPN1>>
	      <SET RN2 <OPEN "PRINTO" ,UPN2>>
	      <COND (<NOT <AND .RN1 .RN2>> <RETURN <AND .RN1 .RN2>>)>
	      <RENAME .RN1 ,ON1>
	      <RENAME .RN2 ,ON2>
	      <CLOSE .RN1>
	      <CLOSE .RN2>
	      <UNLOCK ,DBASE-LOCKED>
	      <SETG DBASE-LOCKED <>>
	      <SETG ACTIVE-LUP <>>
	      T>>

<DEFINE DEL-ENTS (CHN PCK-NAM ENTS
		  "AUX" ENAM (UNAML ()) REC OLD-ENTS
			(FNY-NAM <STRING <ASCII 127> .PCK-NAM>) (OBLIST ()))
	#DECL ((PCK-NAM FNY-NAM ENAM) STRING (OLD-ENTS) <LIST [REST STRING]>
	       (ENTS) <LIST [REST ATOM]> (UNAML) <LIST [REST STRING]>
	       (REC) <LIST [REST <LIST [2 STRING]>]> (OBLIST) <SPECIAL ANY>)
	<REPEAT ((ENTS .ENTS))
		#DECL ((ENTS) <LIST [REST ATOM]>)
		<COND (<EMPTY? .ENTS> <RETURN>)>
		<SET REC
		     <OR <SDMGET .CHN <SET ENAM <PNAME <1 .ENTS>>>> ()>>
		<SET UNAML (<UNPARSE <1 .ENTS>> !.UNAML)>
		<REPEAT ((L (() !.REC)) (TOP .L))
			#DECL ((L) <LIST LIST [REST <LIST [2 STRING]>]>)
			<COND (<EMPTY? <REST .L>> <RETURN>)
			      (<=? .PCK-NAM <2 <2 .L>>>
			       <PUTREST .L <REST .L 2>>
			       <SET REC <REST .TOP>>
			       <RETURN>)>
			<SET L <REST .L>>>
		<COND (<EMPTY? .REC> <SDMDLI .CHN .ENAM>)
		      (T <SDMPUT .CHN .ENAM .REC>)>
		<SET ENTS <REST .ENTS>>>
	<SET OLD-ENTS <OR <SDMGET .CHN .FNY-NAM> ()>>
	<REPEAT ((L (() !.OLD-ENTS)) (TL .L))
		#DECL ((L) <LIST ANY [REST STRING]>)
		<COND (<EMPTY? <REST .L>> <SET OLD-ENTS <REST .TL>> <RETURN>)
		      (<MEMBER <2 .L> .UNAML> <PUTREST .L <REST .L 2>> <AGAIN>)>
		<SET L <REST .L>>>
	<COND (<EMPTY? .OLD-ENTS> <SDMDLI .CHN .FNY-NAM>)
	      (T <SDMPUT .CHN .FNY-NAM .OLD-ENTS>)>
	T>

<DEFINE ADD-ENTS A-E-ACT (CHN PCK-NAM ENTS
			  "AUX" REC OLD-ENTS (NEW-ENTS ()) ENAM (OBLIST ()) UNAM
				(UNAML ())
				(FNY-NAM <STRING <ASCII 127> .PCK-NAM>))
   #DECL ((PCK-NAM FNY-NAM) STRING (OBLIST) <SPECIAL ANY> (ENAM UNAM) STRING
	  (UNAML) <LIST [REST STRING]> (ENTS) <LIST [REST ATOM]>
	  (NEW-ENTS)
	  <LIST [REST <LIST STRING <LIST [REST <LIST [2 STRING]>]>>]>
	  (OLD-ENTS) <LIST [REST STRING]> (REC) <LIST [REST <LIST [2 STRING]>]>)
   <REPEAT ((ENTS .ENTS))
	   #DECL ((ENTS) <LIST [REST ATOM]>)
	   <COND (<EMPTY? .ENTS> <RETURN>)>
	   <SET REC
		<OR <SDMGET .CHN <SET ENAM <PNAME <1 .ENTS>>>> ()>>
	   <SET UNAM <UNPARSE <1 .ENTS>>>
	   <SET UNAML (.UNAM !.UNAML)>
	   <REPEAT ((R .REC))
		   <COND (<EMPTY? .R>
			  <SET REC ((.UNAM .PCK-NAM) !.REC)>
			  <RETURN>)
			 (<=? .PCK-NAM <2 <1 .R>>> <RETURN>)
			 (<==? <OBLIST? <1 .ENTS>> <ROOT>>
			  <RETURN <CHTYPE ("ROOT ENTRY NOT ONLY ENTRY"
					   <1 <1 .R>>
					   "ALSO PRESENT IN"
					   <2 <1 .R>>)
					  FALSE>
				  .A-E-ACT>)
			 (<=? "!- " <MEMQ !"! <1 <1 .R>>>>
			  <RETURN <CHTYPE ("ROOT ENTRY"
					   <1 <1 .R>>
					   "IN PACKAGE"
					   <2 <1 .R>>
					   "ALREADY PRESENT")
					  FALSE>
				  .A-E-ACT>)>
		   <SET R <REST .R>>>
	   <SET NEW-ENTS ((.ENAM .REC) !.NEW-ENTS)>
	   <SET ENTS <REST .ENTS>>>
   <REPEAT (TMP)
	   #DECL ((TMP) <LIST STRING <LIST [REST <LIST [2 STRING]>]>>)
	   <COND (<EMPTY? .NEW-ENTS> <RETURN>)>
	   <SET TMP <1 .NEW-ENTS>>
	   <SET NEW-ENTS <REST .NEW-ENTS>>
	   <SDMPUT .CHN <1 .TMP> <2 .TMP>>>
   <SET OLD-ENTS <OR <SDMGET .CHN .FNY-NAM> ()>>
   <REPEAT ()
	   <COND (<EMPTY? .UNAML> <RETURN>)
		 (<NOT <MEMBER <1 .UNAML> .OLD-ENTS>>
		  <SET OLD-ENTS (<1 .UNAML> !.OLD-ENTS)>)>
	   <SET UNAML <REST .UNAML>>>
   <SDMPUT .CHN .FNY-NAM .OLD-ENTS>
   T>

<DEFINE COB (ATM "AUX" (FOO .ATM) (R <ROOT>) (I <GET INITIAL OBLIST>))
   #DECL ((ATM) ATOM (R I) OBLIST)
   <REPEAT ()
	   <COND
	    (<OR <NOT <SET FOO <OBLIST? .FOO>>> <==? .FOO .R>>
	     <RETURN>)
	    (<==? .FOO .I>
	     <RETURN <CHTYPE (<STRING "ATOM, "
				      <PROG ((OBLIST ()))
					    #DECL ((OBLIST) <SPECIAL ANY>)
					    <UNPARSE .ATM>>
				      ", GOES THROUGH INITIAL">)
			     FALSE>>)
	    (<NOT <SET FOO <GET .FOO OBLIST>>> <RETURN>)>>>

<DEFINE CL (LST "AUX" (ENTS ()) (GOOD-OB <ROOT>) TF TA TMP (PKNM <>))
   #DECL ((LST) LIST (ENTS) <LIST [REST ATOM]> (GOOD-OB) <OR OBLIST FALSE>
	  (TF) FORM (TA) ATOM (PKNM) <OR STRING FALSE>)
   <REPEAT ()
	   <COND (<EMPTY? .LST> <RETURN (.PKNM <MAPR ,LIST <FUNCTION (L)
				#DECL ((L) <LIST [REST ATOM]>)
				<COND	(<MEMQ <1 .L> <REST .L>> <MAPRET>) (<1 .L>)>>
							.ENTS>)>)
		 (<AND <TYPE? <1 .LST> FORM>
		       <NOT <EMPTY? <SET TF <1 .LST>>>>>
		  <COND (<==? <1 .TF> PACKAGE>
			 <SET GOOD-OB
			      <GET <LOOKUP <2 .TF> <GET PACKAGE OBLIST>>
				   OBLIST>>
			 <SET PKNM <2 .TF>>)
			(<==? <1 .TF> RPACKAGE> <SET PKNM <2 .TF>>)
			(<==? <1 .TF> ENTRY>
			<SET ENTS (!<REST .TF> !.ENTS)>)
			(<==? <1 .TF> ENDPACKAGE> <SET GOOD-OB <ROOT>>)
			(<==? <1 .TF> DEFINE>
			 <COND (<==? .GOOD-OB <OBLIST? <SET TA <GATM <2 .TF>>>>>
				<SET ENTS (.TA !.ENTS)>)>
			 <COND (<NOT <SET TMP <CPL .TF T>>> <RETURN .TMP>)>)
			(<AND <==? <1 .TF> SETG>
			      <APPLICABLE? ,<SET TMP <GATM <2 .TF>>>>
			      <NOT <TYPE? ,.TMP FIX>>>
			 <COND (<==? .GOOD-OB <OBLIST? .TMP>>
				<SET ENTS (.TMP !.ENTS)>)>
			 <COND (<NOT <SET TMP <CPL .TF T>>> <RETURN .TMP>)>)
			(T
			 <COND (<NOT <SET TMP <CPL .TF <>>>> <RETURN .TMP>)>)>)
		 (<==? <PRIMTYPE <1 .LST>> LIST>
		  <COND (<NOT <SET TMP <CPL <1 .LST> <>>>> <RETURN .TMP>)>)
		 (<STRUCTURED? <1 .LST>>
		  <COND (<NOT <SET TMP <CPA <1 .LST> <>>>> <RETURN .TMP>)>)
		 (<TYPE? <1 .LST> ATOM>
		  <COND (<NOT <SET TMP <COB <1 .LST>>>> <RETURN .TMP>)>)>
	   <SET LST <REST .LST>>>>

<DEFINE CPL (ITM OK-T-F "AUX" TMP)
	#DECL ((ITM) <PRIMTYPE LIST>)
	<PROG ()
	      <COND (<EMPTY? .ITM> <RETURN>)
		    (<AND <NOT .OK-T-F> <TYPE? .ITM FORM> <==? <1 .ITM> FLOAD>>
		     <RETURN #FALSE ("FLOAD ENCOUNTERED")>)>
	      <REPEAT ()
		      <COND (<EMPTY? .ITM> <RETURN>)
			    (<TYPE? <1 .ITM> ATOM>
			     <COND (<NOT <SET TMP <COB <1 .ITM>>>>
				    <RETURN .TMP>)>)
			    (<==? <PRIMTYPE <1 .ITM>> LIST>
			     <COND (<NOT <SET TMP <CPL <1 .ITM> .OK-T-F>>>
				    <RETURN .TMP>)>)
			    (<STRUCTURED? <1 .ITM>>
			     <COND (<NOT <SET TMP <CPA <1 .ITM> .OK-T-F>>>
				    <RETURN .TMP>)>)>
		      <SET ITM <REST .ITM>>>>>

<DEFINE CPA (ITM OK-T-F "AUX" TMP)
	#DECL ((ITM) STRUCTURED)
	<COND (<AND <==? <PRIMTYPE .ITM> UVECTOR>
		    <==? <TYPEPRIM <UTYPE .ITM>> WORD>>
	       T)
	      (T
	       <REPEAT ()
		       <COND (<EMPTY? .ITM> <RETURN>)
			     (<TYPE? <1 .ITM> ATOM>
			      <COND (<NOT <SET TMP <COB <1 .ITM>>>>
				     <RETURN .TMP>)>)
			     (<==? <PRIMTYPE <1 .ITM>> LIST>
			      <COND (<NOT <SET TMP <CPL <1 .ITM> .OK-T-F>>>
				     <RETURN .TMP>)>)
			     (<STRUCTURED? <1 .ITM>>
			      <COND (<NOT <SET TMP <CPA <1 .ITM> .OK-T-F>>>
				     <RETURN .TMP>)>)>
		       <SET ITM <REST .ITM>>>)>>

<DEFINE GATM (ITM)
	<COND (<TYPE? .ITM ATOM> .ITM)
	      (<GET .ITM VALUE>)
	      (<AND <TYPE? .ITM FORM>
		    <==? <LENGTH .ITM> 2>
		    <==? <1 .ITM> ENTRY>>
	       <2 .ITM>)
	      (T <ERROR BAD-FIRST-ARG-TO-DEFINE-OR-SETG!-ERRORS .ITM>)>>

<OR <GASSIGNED? DBASE-BAD> <SETG DBASE-BAD <>>>

<OR <LOOKUP "NULL" <ROOT>> 
    <SETG <INSERT "NULL" <ROOT>>
	  <INSERT <STRING <ASCII 127>> <ROOT>>>>

<DEFINE OK-BASE? ()
    <REPEAT ()
	<COND (,DBASE-BAD
	       <ERROR DATA-BASE-MUNGED!-ERRORS
		      DEACTIVATION-NOT-ALLOWED>)
	      (<NOT ,ACTIVE-LUP>
	       <ERROR NO-ACTIVE-DATA-BASE!-ERRORS
		      ERRET-NON-FALSE-TO-RETRY>)
	      (<RETURN>)>>>

<DEFINE FNEXP (STR "AUX" (C <CHANNEL "READ" .STR>))
	(<3 .C> <STRING <5 .C> !": <6 .C> !"; <3 .C> !"  <4 .C>>)>

<DEFINE LUP-DEL (NM "AUX" LST (VAL "DELETED"))
	#DECL ((NM) STRING (LST) <LIST [REST STRING]>)
	<OK-BASE?>
	<SETG DBASE-BAD T>
	<OR <SDMGETYPE ,ITMS-CHN .NM>
	    <SET VAL "OBJECT APPARENTLY NOT PRESENT">>
	<SDMDLI ,ITMS-CHN .NM>
	<SET LST
	     <OR <SDMGET ,INDX-CHN <STRING <ASCII 127> .NM>> ()>>
	<DEL-ENTS ,INDX-CHN .NM <MAPF ,LIST ,PARSE .LST>>
	<SETG DBASE-BAD <>>
	.VAL>

<DEFINE LUP-ADD-DATUM (DATUM-NAME FLSPC
		       "OPTIONAL" (UPDT <>) (REALARC <>)
		       "AUX" (FULFLSPC <FNEXP .FLSPC>) FN TMP)
	#DECL ((FLSPC DATUM-NAME) STRING (FULFLSPC) <LIST [2 STRING]>)
	<PROG ()
	      <OK-BASE?>
	      <COND (<AND <NOT .UPDT> 
			  <SDMGETYPE ,ITMS-CHN .DATUM-NAME>
		          <NOT <ERROR 
			 	    ITEM-ALREADY-PRESENT!-ERRORS
				    ERRET-NON-FALSE-TO-UPDATE!-ERRORS
			 	    LUP-ADD-DATUM
			 	    .DATUM-NAME>>
			  <RETURN <>>>)>
	      <COND (.REALARC <SET FN ,SDMPUTARC>)
		    (T <SET FN ,SDMPUTVARC>)>
	      <SETG DBASE-BAD T>
	      <COND (<NOT <SET TMP
			       <APPLY .FN ,ITMS-CHN .DATUM-NAME <2 .FULFLSPC>>>>
		     <RETURN .TMP>)>
	      <SETG DBASE-BAD <>>
	      "DATUM ADDED">>

<DEFINE LUP-ADD-PACK (FLSPC
		      "OPTIONAL" (UPDT <>) (REALARC <>)
		      "AUX" (FULFLSPC <FNEXP .FLSPC>) FN ENTL FNM PNM EL TMP)
   #DECL ((FLSPC FNM PNM) STRING (FULFLSPC) <LIST [2 STRING]>
	  (ENTL) <PRIMTYPE LIST> (EL) <LIST [REST ATOM]>)
   <PROG ()
     <OK-BASE?>
     <COND (<NOT <SET ENTL
		      <CL .<OR <SET TMP <GROUP-LOAD .FLSPC RECYCLED-GROUP-NAME>>
			       <REPEAT ()
				       <ERROR .TMP LUP-ADD-PACK>>>>>>
	    <RETURN .ENTL>)
	   (<SET FNM
		 <STRING <ASCII 127> <SET PNM <OR <1 .ENTL> <1 .FULFLSPC>>>>>)>
     <COND (<AND <NOT .UPDT>
		 <OR <SDMGETYPE ,ITMS-CHN .PNM>
		     <SDMGETYPE ,INDX-CHN .FNM>>
	         <NOT
		     <ERROR 
		  	 PACKAGE-ALREADY-PRESENT!-ERRORS
			 ERRET-NON-FALSE-TO-UPDATE!-ERRORS
			 LUP-ADD-PACK
			 .PNM>>
		 <RETURN <>>>)>
     <SET EL
	  <MAPF ,LIST ,PARSE <OR <SDMGET ,INDX-CHN .FNM> ()>>>
     <SETG DBASE-BAD T>
     <DEL-ENTS ,INDX-CHN .PNM <LDIF .EL <2 .ENTL>>>
     <COND (<NOT <SET TMP <ADD-ENTS ,INDX-CHN .PNM <LDIF <2 .ENTL> .EL>>>>
	    <RETURN .TMP>)>
     <COND (.REALARC <SET FN ,SDMPUTARC>)
	   (T <SET FN ,SDMPUTVARC>)>
     <COND (<NOT <SET TMP <APPLY .FN ,ITMS-CHN .PNM <2 .FULFLSPC>>>>
	    <RETURN .TMP>)>
     <SETG DBASE-BAD <>>
     [.PNM <2 .ENTL>]>>

<DEFINE LDIF (L1 L2)
	#DECL ((L1) <LIST [REST ATOM]> (L2) <SPECIAL LIST>)
	<MAPF ,LIST
	      <FUNCTION (ATM)
		      #DECL ((ATM) ATOM (L2) <LIST [REST ATOM]>)
		      <COND (<MEMQ .ATM .L2> <MAPRET>)>
		      .ATM>
	      .L1>>

<DEFINE LUP-HACK-ENTRY (PCK ENT ADD?
			"AUX" AENT ENTL EL
			      (FNM <STRING <ASCII 127> .PCK>))
	#DECL ((PCK FNM) STRING (ENT) <OR ATOM <LIST [REST ATOM]>>
	       (AENT ENTL EL VALUE) <LIST [REST ATOM]>
	       (ADD?) <OR 'T FALSE>)
	<SET ENTL <COND (<TYPE? .ENT LIST> .ENT) ((.ENT))>>
	<OK-BASE?>
	<COND (<SDMGETYPE ,ITMS-CHN .PCK>
	       <SET EL
		    <MAPF ,LIST ,PARSE <OR <SDMGET ,INDX-CHN .FNM> '()>>>
	       <SETG DBASE-BAD T>
	       <COND (.ADD?
		      <ADD-ENTS ,INDX-CHN
				.PCK
				<SET AENT <LDIFA .ENTL .EL>>>)
		     (<DEL-ENTS ,INDX-CHN
				.PCK
				<SET AENT <LINCA .ENTL .EL>>>)>
	       <SETG DBASE-BAD <>>
	       .AENT)
	      (<ERROR PACKAGE-NOT-PRESENT!-ERRORS LUP-HACK-ENTRY .PCK>)>>


<DEFINE LUP-ADD-ENTRY (PCK ENT) 
	#DECL ((PCK) STRING (ENT) <OR ATOM <LIST [REST ATOM]>>)
	<LUP-HACK-ENTRY .PCK .ENT T>>


<DEFINE LUP-DEL-ENTRY (PCK ENT) 
	#DECL ((PCK) STRING (ENT) <OR ATOM <LIST [REST ATOM]>>)
	<LUP-HACK-ENTRY .PCK .ENT <>>>


<DEFINE LUP-MOVE (PCK FIL "AUX" (FILE <FNEXP .FIL>)) 
	#DECL ((PCK FIL) STRING (FILE) <LIST STRING STRING [REST <NOT ANY>]>)
	<OK-BASE?>
	<COND (<SET CH <OPEN "READ" .FIL>>
	       <CLOSE .CH>
	       <SETG DBASE-BAD T>
	       <SDMPUTVARC ,ITMS-CHN .PCK <2 .FILE>>
	       <SETG DBASE-BAD <>>
	       <2 .FILE>)
	      (<ERROR FILE-DOES-NOT-EXIST!-ERRORS LUP-MOVE .FIL>)>>

<DEFINE LINCA (L1 L2) 
	#DECL ((L1) <LIST [REST ATOM]> (L2) <SPECIAL LIST>)
	<MAPR <>
	    <FUNCTION (X)
		<PUT .X 1 <SPNAME <1 .X>>>>
	    .L2>
	<MAPF ,LIST
	      <FUNCTION (ATM) 
		      #DECL ((ATM) ATOM (L2) <LIST [REST STRING]>)
		      <COND (<MEMBER <SPNAME .ATM> .L2> .ATM) (<MAPRET>)>>
	      .L1>>

<DEFINE LDIFA (L1 L2)
	#DECL ((L1) <LIST [REST ATOM]> (L2) <SPECIAL LIST>)
	<MAPR <>
	    <FUNCTION (X)
		<PUT .X 1 <SPNAME <1 .X>>>>
	    .L2>
	<MAPF ,LIST
	      <FUNCTION (ATM)
		      #DECL ((ATM) ATOM (L2) <LIST [REST STRING]>)
		      <COND (<MEMBER <SPNAME .ATM> .L2> <MAPRET>)>
		      .ATM>
	      .L1>>

<ENDPACKAGE>

