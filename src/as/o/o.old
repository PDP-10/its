
#define FHOLE 1
#define FCORNER 2

/*
 * hole - does the position resulting from a move at P by C contain a
 * hole for O? If so, what value square is given up?
 *
 */

hole(b,c,o,p)
	board b;
	color c, o;
	position p;

	{register int h;
	if (horizedge (p))
		h = hole1 (b,c,o,p,EAST) | hole1 (b,c,o,p,WEST);
	else
		h = hole1 (b,c,o,p,NORTH) | hole1 (b,c,o,p,SOUTH);
	if (h == (FHOLE+FCORNER)) return (CORNERVALUE);
	if (h & FHOLE) return (EDGEVALUE);
	return (0);
	}

/*
 *   [_ X		= FCORNER
 *   [_ c+ o* X		= FCORNER	-- this seems wrong
 *
 */

hole1(b,c,o,p,d)
	board b;
	color c, o;
	register position p;
	direction d;

	{int n, m;
	n = 0;
	while (b[p] == o)
		if (!valid (nextpos (p, d))) return (0);
		else ++n;
	m = 0;
	while (b[p] == c)
		if (!valid (nextpos (p, d))) return (0);
		else ++m;
	if (corner (p))
		{if (b[p] == EMPTY)
			{if (n == 0) return (FCORNER);
			if (m > 0) return (FCORNER);
			}
		return (0);
		}
	while (b[p] == o) if (!valid (nextpos (p, d))) return (0);
	if (b[p] == c) return (0);
	if (corner (p)) return (0);
	n = 0;
	while (b[p] == EMPTY)
		{++n;
		if (!valid (nextpos (p, d))) return (0);
		}
	if ((n & 1) == 0) return (0);
	while (b[p] == o) if (!valid (nextpos (p, d))) return (FHOLE);
	if (b[p] != c) return (0);
	while (b[p] == c) if (!valid (nextpos (p, d))) return (FHOLE);
	if (b[p] == o) return (FHOLE);
	if (corner (p)) return (FHOLE+FCORNER);
	return (FHOLE);
	}


takeback(b,c,o,p)
	board b;
	color c, o;
	position p;

	{return (takb1(b,c,o,p,NORTH) ||
		takb1(b,c,o,p,NORTHEAST) ||
		takb1(b,c,o,p,EAST) ||
		takb1(b,c,o,p,SOUTHEAST));
	}

takb1(b,c,o,p,d)
	board b;
	color c, o;
	position p;
	direction d;

	{register int c1, c2;
	c1 = takb2(b,c,o,p,d);
	c2 = takb2(b,c,o,p,oppdir(d));
	return(c1==o&&c2==EMPTY || c1==EMPTY&&c2==o);
	}

takb2(b,c,o,p,d)
	board b;
	color c, o;
	register position p;
	direction d;

	{nextpos (p, d);
	if (valid (p))
		{while (b[p] == o)
			{nextpos (p, d);
			if (!valid (p) || b[p]==EMPTY) return (o);
			}
		}
	while (valid (p) && b[p] == c) nextpos (p, d);
	if (!valid (p)) return (c);
	return (b[p]);
	}

int trydepth;

int tryedge (oldb,b,c,o,p,d)	/* return score from O's point of view */
	board oldb, b;
	color c, o;
	position p;
	direction d;

	{int s1, s2, rc;

	++trydepth;
	if (eflag)
		{putn (trydepth);
		printf ("tryedge (%c, %d%d):\n", pcolor[c],
			posx(p)+1, posy(p)+1);
		}
	s1 = try1edge (oldb,b,c,o,p,d);
	s2 = try1edge (oldb,b,c,o,p,oppdir(d));
	if (s1 == 0)
		{if (s2 == 0) rc = 1;
		else rc = -s2;
		}
	else if (s2 == 0) rc = -s1;
	else
		{if (s2>s1) s1=s2;
		rc = -s1;
		}
	if (eflag)
		{putn (trydepth);
		printf ("tryedge (%c, %d%d) = %d\n", pcolor[c],
			posx(p)+1, posy(p)+1, rc);
		}
	--trydepth;
	return (rc);
	}

int try1edge (oldb,b,c,o,p,d)	/* return score from C's point of view */
	board oldb, b;
	color c, o;
	position p;
	direction d;

	{position p1;
	int rc;

	++trydepth;
	if (eflag)
		{putn (trydepth);
		printf ("try1edge (%c, %d%d, %d):\n", pcolor[c],
			posx(p)+1, posy(p)+1, d);
		}

	rc = 0;
	p1 = p;
	while (valid (nextpos (p, d)))
		{if (b[p] == EMPTY)
			{if (ismove (b,c,p))
				{board a;
				cpybrd (a,b);
				putmov (a,c,p);
			/*	if (a[p1]==o) {rc = -1; break;} 	*/
				if (corner(p))
					{if (ismove (oldb,c,p)) rc = 1;
					else rc = 2;
					break;
					}
				rc = tryedge (oldb,a,o,c,p,d);
				if (rc<0 && !ismove(b,o,p))
					rc = 1;	/* C need not move */
				break;
				}
			if (ismove (b,o,p))	/* C can't move, but O can */
				{rc = -try1edge (oldb,b,o,c,p1,d);
				if (rc > 0) rc = 0;	/* O need not move */
				break;
				}
			break;
			}
		}
	if (eflag)
		{putn (trydepth);
		printf ("try1edge (%c, %d%d, %d) = %d\n", pcolor[c],
			posx(p)+1, posy(p)+1, d, rc);
		}
	--trydepth;
	return (rc);
	}

/*
		else
			{struct mt t[64], *tp[64];
			register struct mt **mp;
			register int k;
			k = pmvgen (a,o,c,tp,t,movnum>=MIDDLEMOVE);
			mp = tp;
			while (--k >= 0)
				{position q;
				register int temp;
				q = (*mp++)->p;
				temp = -meval(a,o,c,q,-minmove);
				if (temp<minmove)
					{minmove=temp;
					if (minmove<alpha) break;
					}
				}
			}

*/
