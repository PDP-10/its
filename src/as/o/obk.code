#include "ob.h"

extern bnode *bnlist[MAXNODE];
extern int nnodes;
bnode *curbn;
bnode *bnfind();
rotation currot;

/**********************************************************************

	rotation code

**********************************************************************/

position rotate (p, r)
	position p;
	rotation r;

	{int x, y;

	x = posx (p);
	y = posy (p);
	switch (r/4) {
	case 0:		break;
	case 1:		y = 7 - y; break;
	case 2:		x = 7 - x; break;
	default:	cprint ("bad flip");
			}
	r =% 4;
	while (--r >= 0)
		{int temp;
		temp = y;
		y = 7 - x;
		x = temp;
		}
	return (pos (x, y));
	}

rotation rotadd (r1, r2)
	rotation r1, r2;

	{int flip1, flip2;

	if (r1 == R0) return (r2);
	if (r2 == R0) return (r1);
	flip1 = r1 / 4;
	r1 = r1 % 4;
	flip2 = r2 / 4;
	r2 = r2 % 4;
	if (flip2==0)
		return (flip1*4 + ((r1 + r2) % 4));
	if ((r1 % 2) != 0) flip2 = oppflip (flip2);
	return (rotadd (flipadd (flip1, flip2), (r1 + r2) % 4));
	}

rotation flipadd (f1, f2)

	{if (f1 == f2) return (R0);
	if (f1 == 0) return (f2*4);
	if (f2 == 0) return (f1*4);
	return (R180);
	}

int oppflip (f1)

	{if (f1 == 0) return (0);
	return (3 - f1);
	}

/**********************************************************************

	bk_clear

**********************************************************************/

bk_init ()

	{int i;
	extern int book[];
	for (i=1;i<nnodes;++i)
		{int o;
		o = bnlist[i];
		if (o) bnlist[i] = book+o;
		}
	}

bk_clear (c)
	color c;

	{curbn = bnfind (1);
	currot = R0;
	if (c == WHITE) currot = V0;
	}

bk_flush ()

	{curbn = 0;
	}

position bkmvn (n)

	{return (rotate (getpos (&curbn->moves[n]), currot));}

bk_move (p)

	{bnode *extrace ();
	if (curbn)
		{int n;
		n = curbn->nmoves;
		while (--n >= 0)
			{if (p == bkmvn (n))
				{currot = rotadd (getrot (&curbn->moves[n]), currot);
				curbn = extrace (curbn, n);
				return;
				}
			}
		curbn = 0;
		}
	}

bnode *extrace (bn, n)
	bnode *bn;

	{return (bnfind (getnext (&bn->moves[n])));
	}

int bk_lookup (t, tp)
	struct mt t[64], *tp[64];

	{int n, k;
	if (curbn == 0) return (0);
	
	k = 0;
	n = curbn->nmoves;
	while (--n >= 0)
		{if (getgood (&curbn->moves[n]))
			{t[k].p = bkmvn (n);
			tp[k] = &t[k];
			++k;
			}
		}
	return (k);
	}

bnode *bnfind (n)

	{if (n>0 && n<=nnodes) return (bnlist[n]);
	return (0);
	}

