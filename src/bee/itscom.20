	.TITLE 10-11 COMUNICATIONS PACKAGE
.INSRT SITS;SITMAC >
.INSRT SITS;SITSS SYMS
FOO==0

.MACRO CROCK A,MESSAGE
	MES'A=.
	FOOBAR==.
	.ASCII ÍESSAGEŠ	MES'A'L==.-FOOBAR
	.EVEN
.ENDM

.MACRO MESS MESSAGE
	CROCK \FOO,^/MESSAGE/
	FOO==FOO+1
.ENDM

MESS ^/INPUT TO LONGî/
MESS ^/DISK NUMBER:	/
MESS ^/DIRECTORY:	/
MESS ^/FILE NAME:	/
MESS ^/INPUT FILE:	/
MESS ^/CANT COPY ROOTî/
MESS ^/CANT MUTATE TO DIRECTORYî/
MESS ^/CANT ADD FILE TO DIRECTORYî/
MESS ^/CANT OPEN ITSî/
MESS ^/PDP11U/
MESS ^/NLODER/

	.BLKW 40
PDL:
	.BLKW 2		;FOR THE INTERRRUPT PROCESSOR
PDL1:
ITSTTY:	1		;TTY FOR ITS
ITSCAP:	0
OLDPTR:	.BLKW 2		;STORAGE FOR THE POINTER TO THE START OF LAST BLOCK IN FILE
SYMFLG:	0		;ZERO MEANS NO SYMBOLS YET
TTYCAP==3
FILLEN==40.
FILBLK:	.BLKB FILLEN+2	;PLACE FOR FILE NAME AND EXTRA BYTE FOR SURE
FILCAP:	0	
PATCH:	.BLKW 100

START:	MOV #PDL,P
	SAVE <,#.TIECM!.TICVM!.TLIPM!.TIRST,#TTYCAP>
	BIS #.TTMOV,(P)	;SET THE TTY STATUS
	$INVOK
	SAVE <#-1,ITSTTY,#.TTCAP*400>
	.INVOK		;CREATE THE ITS TTY
	BNE ITSOPN	;GOT IT
	ADD #6,P	;POP ARGUMENTS
	SAVE <#MES10,#-MES10L,#TTYCAP>	;OUTPUT ERROR MESSAGE
	$BLKO
	BPT
	BR START
ITSOPN:	REST ITSCAP	;SAVE IT
	SAVE <,#.TIMGO!.TIMGI!.TIRST,ITSCAP>	;SET IT TO IMAGE IN IMAGE OUT
	BIS #.TTMOV,(P)	;SET THE STATUS
	$INVOK
TRYAGA:	SAVE <#MES1,#-MES1L,#TTYCAP>
	$BLKO		;FIND OUT WHICH DISK
	JSR PC,GETLIN	;GET THE LINE
	BEQ TRYAGA	;TRY AGAIN
	MOV #4,B	;THE DEFAULT DIRECTORY
	CMP A,#FILBLK	;IS IT NULL?
	BEQ DEFDIR	;JUST USE THE DEFAULT
	CMP A,#FILBLK+1	;BETTER BE ONLY ONE BYTE
	BNE TRYAGA	;TRY AGAIN
	MOV FILBLK,B	;GET THE BYTE
	SUB #'0-10,B	;TURN IT INTO CAPABILITY INDEX
DEFDIR:	SAVE <#-1,,B>	;COPY THE APPROPRIATE ROOT CAPABILITY
	BIS #.CPYCP,(P)	;COPY IT
	.INVOK
	BNE GODROT	;SO FAR OKAY
	ADD #6,P	;POP OFF STUFF
	SAVE <#MES5,#-MES5L,#TTYCAP>
	$BLKO		;SAY ERROR IN ROOT COPY
	BR TRYAGA	;AND TRY AGAIN
GODROT:	REST FILCAP	;THE FILE CAPABILITY
	SAVE <#MES2,#-MES2L,#TTYCAP>
	$BLKO		;ASK FOR DIRECTORY
	JSR PC,GETLIN	;GET THE LINE FROM TTY
	BNE MUTRUT	;NO
	CMP A,#FILBLK	;ANY INPUT
	BEQ GODMUT	;DONT MUTATE IT
ERR:	SAVE <,,FILCAP>	;DELETE THE FILE CAPABILITY
	BIS #.DELCP,(P)	;DELETE IT
	$INVOK
	BR TRYAGA	;TRY AGAIN
MUTRUT:	CMP A,#FILBLK	;ANY INPUT
	SAVE <,#FILBLK,FILCAP>	;MUTATE THE RUT TO THE DIRECTORY
	BIS #.FAMU,(P)
	.INVOK
	BNE GODMUT	;GOT IT
	ADD #6,P	;POP JUNK
	SAVE <#MES6,#-MES6L,#TTYCAP>
	$BLKO		;OUTPUT MESSAGE
	BR ERR		;DELETE CAPABILITY AND TRY AGAIN
GODMUT:	SAVE <#MES3,#-MES3L,#TTYCAP>
	$BLKO		;ASK FOR THE FILE NAME
	JSR PC,GETLIN	;GET THE LINE
	BEQ ERR		;FAILED SO DELETE AND TRY AGAIN
	SAVE <#0,#FILBLK,FILCAP>
	BIS #.FAAD,(P)	;ADD THE FILE WITH THAT NAME TO THE DIRECTORY
	.INVOK		;ADD IT
	BNE GODADD	;ADDED IT SUCESSFULLY
	ADD #6,P	;GO IT
	SAVE <#MES7,#-MES7L,#TTYCAP>
	$BLKO		;COMPLAIN ABOUT NOT ADDING IT
	BR ERR
GODADD:	SAVE <,#FILBLK,FILCAP>	;TRY TO MUTATE TO IT
	BIS #.FAMU,(P)
	$INVOK		;MUTATE TO IT.
	SAVE <#MES4,#-MES4L,#TTYCAP>
	$BLKO		;ASK FOR ITS FILE NAME
	JSR PC,GETLIN	;GET THE ITS FILE LINE
	SUB #FILBLK,A	;GET THE NUMBER OF BYTES
	MOV A,F		;SAVE IT
	BEQ ERR		;GOT TO HAVE A FILE NAME
	SAVE <#32,ITSCAP>	;OUTPUT A ^Z TO ITS
	$BYTO
	JSR PC,WAIT10	;WAIT FOR THE 10 TO RESPOND
	SAVE <#MES11,#-MES11L,ITSCAP>	;OUTPUT STRING TO LOG IN AS PDP11
	$BLKO
	NEG F		;NEGATIVE BYTE COUNT
	JSR PC,WAIT10	;WAIT FOR THE 10
	SAVE <#MES12,#-MES12L,ITSCAP>	;OUTPUT THE STRING TO START NLODER
	$BLKO
	SAVE <#FILBLK,F,ITSCAP>		;OUTPUT FILE NAME
	$BLKO		;OUTPUT THE FILE NAME TO ITS
	SAVE <,#.TIRST,ITSCAP>	;RESET THE INPUT BUFFER
	BIS #.TTBIS,(P)	;JUST SET THE FLAG
	$INVOK
	SAVE <#15,ITSCAP>	;OUTPUT CR
	$BYTO
	SAVE #INTRUP	;FOR THE INTERRUPT HANDLER
	$FORK		;START IT UP
	CLR SYMFLG	;SAY WE HAVEN'T LOADED SYMBOLS YET
WATLOP:	CLR F		;THE CHECKSUM
	JSR PC,REDBYT	;READ A BYTE
	CMP D,#1	;IS IT THE START OF A BLOCK
	BNE WATLOP	;YES
	JSR PC,REDBYT	;THROW AWAY A 0
	MOV #OLDPTR,D	;POINT TO THE STORAGE FOR IT
	SAVE <,,FILCAP>	;READ THE POINTER
	BIS #.FARP,(P)
	$INVOK
	REST <(D)+,(D)+>	;PUT AWAY THE POINTER
	SAVE <#1,FILCAP>	;OUTPUT TO THE FILE
	$BYTO		;OUTPUT THE BYTE TO START
	MOV #5,E	;THE NUMBER OF BYTES LEFT (JUST A KLUDGE TO GET CONSTANT 3)
	JSR PC,GWORD	;GET A WORD INTO A
	SUB E,A		;ALREADY GRABBED 3 BYTES
	CMP E,A		;IS IT NOW 3 (IMPLYING LENGTH OF 6)
	BEQ CHKDON	;SEE IF WE ARE DONE
	MOV A,E		;NEW BYTE COUNT
RECEV:	JSR PC,GWORD	;GET WORD INTO A
	TST E		;ANY MORE BYTES
	BGT RECEV
	INCB F		;IS THE CHECKSUM 0?
	BNE BADBLK	;NO
	SAVE <#4,ITSCAP>	;SEND A GOOD ACKNOWLEDGE
	$BYTO
	BR WATLOP	;GET THE NEXT BLOCK
BADBLK:	SAVE <#6,ITSCAP>	;SEND A BAD ACKNOWLEDGE
	$BYTO
	MOV #OLDPTR+4,E	;POINT TO START OF THIS BLOCK IN THE FILE
	SAVE <-(E),-(E),FILCAP>	;RESET THE POINTER TO POINT TO THE START (OVERWRITE THE
			;BAD BLOCK
	BIS #.FASP,(P)	;SET THE POINTER
	$INVOK
	BR WATLOP	;TRY AGAIN

CHKDON:	TST SYMFLG	;HAVE WE RECEIVED THE SYMBOLS YET?
	BEQ .+4		;NO
FINIS:	BPT		;DONE
	COM SYMFLG	;SET THE FLAG
	BR WATLOP	;PRETEND TO RECEIVE A NEW PROGRAM (MAINLY THE SYMBOL TABLE)

WAIT10:	SAVE <ITSCAP,(P),(P)>	;FOR THE 3 BYTI'S
	$BYTI		;INPUT 3 BYTES
	TST (P)+
	$BYTI
	TST (P)+
	$BYTI
	TST (P)+
	SAVE <#23,ITSCAP>	;OUTPUT A ^S
	$BYTO
	RTS PC

;THE 10 PROGRAM SENDS LOW 6 BITS, THEN 4 BITS, THEN 6 BITS =>16 BITS
GWORD:	JSR PC,REDBYT	;READ A BYTE
	MOV D,A		;PLACE TO RETURN THE WORD OR BYTE
	JSR PC,REDBYT	;GET THE TOP OF THIS BYTE
	SWAB D		;PUT INTO THE TOP BYTE
	ASR D
	ASR D		;SHIFT IT DOWN TO COVER TOP 2 BITS OF BOTTOM BYTE
	BIS D,A		;SET IT IN
	MOV A,D		;COPY IT
	BIC #177400,D	;CLEAR THE TOP BYTE
	ADD D,F		;FIX UP THE CHECKSUM
	SAVE <D,FILCAP>	;THE FILE CAPABILITY
	$BYTO		;WRITE OUT THE BYTE
	DEC E		;DECREMENT THE BYTE COUNT
	BEQ DONE	;DONE NO MORE BYTES
	JSR PC,REDBYT	;GET THE OTHER BYTE
	SWAB D		;PUT INTO THE TOP BYTE
	ASL D
	ASL D		;PUT THE CHAR INTO THE TOP 6 BITS
	BIS D,A		;SET IT INTO THE TOTAL WORD
	MOV A,D		;COPY IT AGAIN
	SWAB D		;WANT THE TOP BYTE THIS TIME
	BIC #177400,D	;CLEAR THE BOTTOM BYTE (REMEMBER THEY ARE SWABBED HERE)
	ADD D,F		;FIX UP CHECKSUM
	SAVE <D,FILCAP>	;OUTPUT THIS BYTE TO
	$BYTO
DONE:	DEC E		;ONE LESS BYTE
	RTS PC

REDBYT:	SAVE ITSCAP
	$BYTI
	REST D
	BIC #177600,D	;CLEAR ALL BUT THE BOTTOM BITS
	SUB #40,D	;THIS IS A KLUDGE TO AVOID CONTROL CHARACTERS
	RTS PC
INTRUP:	MOV #PDL1,P	;SET UP P
	SAVE <,#.TIRST,#TTYCAP>
	BIS #.TTBIS,(P)	;BIS SET THE RESET FLAG
	$INVOK		;RESET THE TTY
CTZLOP:	SAVE #TTYCAP
	$BYTI
	CMPB (P)+,#32	;IS IT CONTROL Z?
	BNE .+4		;NO
	BPT
	BR CTZLOP	;JUST CONTINUE
GETLIN:	MOV #FILBLK,A	;THE POINTER TO WHERE TO PUT THE DATA
	MOV #FILLEN,B	;NUMBER OF BYTES IN INPUT BUFFER
CHARLP:	SAVE #TTYCAP
	$BYTI		;GET A BYTE
	CMPB (P),#15	;IS IT CARRIAGE RETURN
	BEQ CHARDN	;YES, WE ARE DONE
	MOVB (P)+,(A)+	;PUT IT INTO THE BUFFER
	SOB B,CHARLP	;TRY UNTIL IT IS FULL
	SAVE <#MES0,#-MES0L,#TTYCAP>
	$BLKO		;OUTPUT LINE TO LONG
	SEZ
	RTS PC
CHARDN:	TST (P)+	;POP CHARCTER
	CLRB (A)	;MAKE SURE THERE IS A ZERO BYTE
	CLZ
	RTS PC
.END START
