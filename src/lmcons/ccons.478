.TITLE CONS-CONSOLE  -- ALSO DATAPOINT EMULATOR
;ALSO GENERAL PURPOSE GRAPHICS DISPLAY

;PITTS JARVIS/JOE COHEN  --  AUGUST 1973

%ABSADR==1

.IIF NDF GT40P,	GT40P==0	;1 TO ASSEMBLE GT40 ROUTINES
.IIF NDF TVP,	TVP==1		;1 TO ASSEMBLE TV ROUTINES
.IIF NDF KBDP,	KBDP==0		;0 TO USE FANCY KEYBOARD
.IIF NDF DEBUG,	DEBUG==0	;1 TO RUN UNDER PDP11 SIMULATOR?

;VARIOUS DEBUGGING AIDS
.MACRO BPT		;MISFEATURE IN PALX
	RMS LOSES
.ENDM
.MACRO NOP
	RMS LOSES
.ENDM
.IFNZ DEBUG
	.STITL DEBUGGING VERSION FOR 11/20
	BPT==3	;BREAKPOINT INSTUCTION
	NOP==BPT
	PATL==100
.ENDC
.IFZ DEBUG
	.STITL GT40 VERSION
	DEBUG==0
	BPT==3
	NOP==BPT
	PATL==40
.ENDC

;DLIMSW==0		;IF NZ, ASSEMBLE DISPLAY LIMITING 
			;(THIS HACK USED EMT FOR SOME WEIRD REASON)
PCHIST==0		;KEEPS HISTORY OF PCS IN PCBUF

.SBTTL DEFINITIONS
.IF2
;.IFNZ DLIMSW
;.PRINT /DISPLAY LIMITING
;/
;.ENDC
.IFNZ PCHIST
.PRINT /PC HISTORY
/
.ENDC
.ENDC

;MACROS

.MACRO	PUSH A
	.NLIST
	MOV	A,-(SP)
	.LIST
.ENDM

.MACRO	POP A
	.NLIST
	MOV	(SP)+,A
	.LIST
.ENDM

.MACRO REPORT TEXT,NUM
.IF2
	.PRINT /TEXT NUM
/
.ENDC
.ENDM

.MACRO ZAPFLG FOO
.NLIST
%COMPAT==0
	MOV	PC,FOO
%COMPAT==1
.LIST
.ENDM

;REGISTER ASSIGNMENTS

A=%0			;USED FOR ARGUMENT PASSING
B=%1
C=%2
T=%3
TT=%4
U=%5			;RESERVED FOR PIECE OF PAPER NUMBER
SP=%6
PC=%7
.XCREF	A,B,C,T,TT,SP,PC

;MEMORY MAP

NXMPC=   4		;BUS ERROR VECTOR
NXMPSW=  6
RESPC== 10		;RESERVED INTRUCTION VECTOR
RESPSW==12
BPTPC== 14		;BREAK POINT VECTOR
BPTPSW==16
IOTPC== 20		;IOT VECTOR
IOTPSW==22
PWRPC=  24		;POWER FAIL TRAP VECTOR
PWRPS=  26
EMTPC=  30		;EMULATE TRAP VECTOR
EMTPSW= 32
TRPPC== 34		;TRAP INSTRUCTION VECTOR
TRPPSW==36
TIMEH==40		;32 BIT 60 CYCLE COUNTER FOR LISPM, HIGH PART
TIMEL==42		;"  "  LOW PART
TYIPC=  60		;TTY INPUT INTERUPT VECTOR
TYIPSW= 62
LKPC=  100		;LINE CLOCK INTERUPT VECTOR
LKPSW= 102
KLIPC= 300		;KL11 INPUT INTERUPT VECTOR
KLIPSW=302
DSPC=  320		;DISPLAY STOPPED INTERRUPT VECTOR
DSPSW= 322
DLPPC= 324		;LIGHT PEN INTERRUPT VECTOR
DLPPSW=326
DTOPC= 330		;DISPLAY TIME/SHIFT OUT VECTOR
DTOPSW=332

HMEML==35714		;HI LIMIT OF MEM USED BY DYNAMIC HACK
DSKRQB=35716		;DISK REQUEST BUFFER (SEE CCDISK)
DSKRBL==30.		;NUMBER OF REQUESTS IN BUFFER
DSKRBE==DSKRQB+4+<10.*DSKRBL> ;END ADDRESS
.IIF P2 .IIF GT DSKRBE-LDBFF2, .ERR DISK REQUEST BUFFER OVERLAPS AUX LOAD BUFFER
LDBUFF=37002		;LOW 1/2 OF FLAG DOUBLE WD USED TO SIGNAL STATE OF
			;LOADER BUFFER
			; 0 -> BUFFER EMPTY,
			;-1 -> DO READING OP
			;	(BUFFER FULL OF REGISTER EXAMINE COMMANDS)
			;+  -> DO WRITING OP
			;	(BUFFER FULL OF REGISTER DEPOSIT COMMANDS)
LDBUF=37004		;ADDRESS OF FIRST BUFFER BLOCK
LDBUFB==40		;LOAD BUFFER LENGTH IN BLOCKS (4 WD EA)
LDBUFL==LDBUFB*10	;LOAD BUFFER LENGTH IN BYTES
LDBFF2=36376		;FLAG WORD FOR AUXILIARY BUFFER
LDBUF2=36400		;ADDR OF FIRST BUFFER BLOCK IN AUX BUFFER
.IIF GT LDBUF2+LDBUFL-LDBUFF-2, .ERR BUFFERS OVERLAP

;RUGSA==37000		;RUG STARTING ADDRESS
;RUGBRK==RUGSA+162	;RUG BREAK POINTER HANDLER

KLIS=175610		;KL11 INPUT STATUS
KLIB=175612		;KL11 INPUT BUFFER
KLOS=175614		;KL11 OUTPUT STATUS
KLOB=175616		;KL11 OUTPUT BUFFER
TKS= 177560		;TTY KEYBOARD STATUS
TKB= 177562		;TTY KEYBOARD BUFFER
LKS= 177546		;LINE CLOCK STATUS
CSR= 177570		;CONSOLE SWITCH REGISTER
PS=  177776		;PROCESSOR STATUS REGISTER
.SBTTL GT40 DEFINITIONS
.IFNZ GT40P

;GEOMETRY

BITPL==2000		;BITS PER LINE
NLINS==1400		;LINES ON SCREEN
BYTPL==BITPL/10		;BYTES PER LINE
WRDPL==BYTPL/2		;WORDS PER LINE

CHRWD==16		;CHARACTER WIDTH
CHRHT=30		;CHARACTER HEIGHT
CHRPL==BITPL/CHRWD	;CHARACTERS PER LINE
CHRLN==NLINS/CHRHT	;CHARACTER LINES ON SCREEN

DPC= 172000		;DISPLAY PROGRAM COUNTER
DSR= 172002		;DISPLAY STATUS REGISTER
XSR= 172004		;X STATUS REGISTER, GRAPH PLOT INCREMENT
YSR= 172006		;Y STATUS REGISTER, CHARACTER REGISTER

;GT40 OPCODES

DPYJMP==160000
DPYNOP==164000
DPYSTP==173400		;STOP DISPLAY AND CAUSE INTERRUPT
DPYJSR==DPYSTP+1	;CALL DPY SUBROUTINE
DPYRTS==DPYSTP+2	;RETURN FROM DPY SUBROUTINE
DPYJSI==DPYSTP+3	;INDIRECT CALL DPY SUBROUTINE
SETPNT==114000
RPOINT==130000
SVW==104000
LVW==110000
CHARS==100000
DPYNRM==3724		;NORMAL SET GRAPHIC MODE BITS
			;	INTENSITY 7
			;	NO LIGHT PEN
			;	NO BLINK
			;	NO ITALICS
			;	SOLID LINE
BLENAB==20		;	LISTEN TO DBLINK BIT
DBLINK==10		;	YES BLINK (IF ENABLED)

STSNRM=171640		;NORMAL A REGISTER SETTINGS
			;	ENABLE STOP INTERRUPTS
			;	DISABLE LIGHT PEN INTERRUPTS
SYNC==4			;	SYNCS DPU WITH CLOCK
ITALICS==20		;	CAUSE ITALICS
LITEPN==200		;	ENABLE LIGHT PEN INTERRUPTS

ESCHR==20		;ESCAPE TO DISPLAY SLAVE (^P)
XLOD==6			;EXTRA BYTES IN LOADER BLOCK (TYPE, SIZE, ITEM)
.ENDC ;GT40P
.SBTTL TV DEFINITIONS
.IFNZ TVP
	;FROM TS TV STUFF

FONTSW==1	;COMPILE FONTS
FONTMS==0	;USE MACROS TO COMPILE FONTS

.MACRO CHECK TAG,LENGTH
.NLIST
.IF NE .-<TAG>-<LENGTH>
.ERROR TAG WRONG LENGTH
.ENDC
.EVEN
.LIST
.ENDM

.MACRO CONC A,B,C,D,E,F,G,H,I
A'B'C'D'E'F'G'H'I
.ENDM

TVCTL=176660	;CONTROL REG
 BOWBIT==1	;1.1 WHITE ON BLACK OF SELECTED CHANNEL
		;1.2-1.4 VIDEO SWITCH
		;1.9-2.2 CHANNEL SELECT
 VERINC==100000	;2.7 VERTICAL INCREMENT MODE
TVPTR=176662	;RELATIVE ADDRESS IN TV BUFFER
TVDAT=176664	;DATA READ/WRITE
TVDATI=176666	;SAME EXCEPT AUTO INCREMENTS TVPTR ON WRITE ONLY
TVCTL2=176670	;SECOND CONTROL REG
		;AT THIS ADDRESS YOU CAN WRITE WHITE ON BLACK AND VIDEO SWITCH
		;AT THE TVCTL ADDRESS YOU CAN WRITE PLANE SELECT AND VERTICAL INCR
		;THE OTHER THREE REGISTERS ARE REPEATED HERE

;TVMEM=200000	;TV 16K STARTS ABOVE FIRST 32K OF ADDRESS
;TVMEM=0		; LOW 16 BITS OF TV ADDRESS
;TVMEMX=1*10000	;EXTENSION BITS FOR ADDR

;GEOMETRY

BITPL==576.		;BITS PER LINE
NLINS==454.		;LINES ON SCREEN
BYTPL==BITPL/10		;BYTES PER LINE
WRDPL==BYTPL/2		;WORDS PER LINE

CHRWD==6		;CHARACTER WIDTH ON TEXT LINE
GRIDWD==5		;WIDTH OF CHARACTER GRID
CHRHT==12		;CHARACTER HEIGHT
CHRVSP==2		;BLANK RASTER LINES BETWEEN CHARACTER LINES
LINHT==CHRHT+CHRVSP	;CHRACTER LINE HEIGHT
CHRPL==BITPL/CHRWD	;CHARACTERS PER LINE
CHRLN==NLINS/LINHT	;CHARACTER LINES ON SCREEN

TVLO==0			;RELATIVE ORIGIN OF DISPLAY MEMORY
TVFENCE=TVHI-<LINHT*BYTPL>	;DON'T START ORDINARY TEXT LINE PAST THIS POINT
TVCFENC=TVHI-<BYTPL*<CHRHT-1>>	;DON'T TRY TO DISPLAY A CHARACTER AFTER THIS POINT
TVHI=TVLO+<BYTPL*NLINS>-2	;HIGHEST LEGAL DISPLAY ADDRESS
...==0
....==0

;VARIOUS BUFFER SIZES AND ETC.

BUFSIZ==200		;DL11 INPUT BUFFER SIZE
PDL==400		;PDL SIZE
.IFNZ GT40P
MCHRPL==3*CHRPL+1	;MAXIMUM CHARS PER LINE (ALLOW UNDERLINING OF WHOLE LINE)
LBL==MCHRPL+6		;WORST CASE LINE LINE LENGTH
XTLBYT==6		;EXTRA TEXT LINE BYTES
NEBISH==20		;BYTES WE'RE WILLING TO WASTE IN FREE STORAGE ALLOCATOR
INUSE==1		;BLOCK IN USE
DPYPDL==40		;DPY PUSH DOWN LENGTH
OPENSW=LINBUF+2		;0 IMPLIES LINE CLOSED, NON-0 IMPLIES LINE OPEN
MIBFRS==10		;# MAIN/INTERUPT LEVEL COMMUNICATION BUFFERS
.ENDC ;GT40P
.IFNZ PCHIST
PCS==90.		;# PC'S TO SAVE
PCL==4			;LENGTH OF EACH PC RECORD
PCBFL==PCS*PCL		;SIZE OF PC BUFFER
.ENDC


;BEGIN CONSOLE RELATED STUFF

.SBTTL EMT DEFINITIONS

CONS=164000		;CONS INTERFACE BASE ADDRESS

;EMTS
EFATL=EMT!0		;FATAL ERROR
ETEXT=EMT!1		;OUTPUT ASCIZ TEXT STRING POINTED TO BY FOLLOWING WD
EERRO=EMT!2		;OUTPUT TEXT CORRESPONDING TO ERROR CODE IN A
EROBUS=EMT!3		;READ OBUS INTO DOUBLE WORD POINTED TO BY A
ERIR=EMT!4		;READ IR INTO TRIPLE WD POINTED TO BY A
ERPC=EMT!5		;READ MICRO PC INTO WD POINTED TO BY A
ERERWS=EMT!6		;READ ERROR WORDS INTO DOUBLE WD POINTED TO BY A
EWDIB=EMT!7		;WRITE DIAG INST BUFFER FROM TRIPLE WD POINTED TO BY A
EDDEST=EMT!10		;DEPOSIT CONTENTS OF B INTO THREE WD
			;BLOCK POINTED TO BY A.  POSITION B
			;INTO DEST FIELD OF ALU OR BYTE INST.
			;THIS IS THE ALSO THE SAME FIELD USED FOR THE 
			;DISPATCH OFFSET OF A DISPATCH INSTRUCTION.
EDALUF=EMT!11		;DEPOSIT B INTO ALU OP FIELD OF BLOCK POINTED TO BY A
EDOBSL=EMT!12		;DEPOSIT B INTO OUTPUT BUS SELECT FIELD
			; OF U INST POINTED TO BY A
EDMSRC=EMT!13		;DEPOSIT B INTO M SOURCE FIELD OF U INST
			; POINTED TO BY A
EDASRC=EMT!14		;DEPOSIT B INTO A SOURCE FIELD OF U INST
			; POINTED TO BY A
EUICLR=EMT!15		;CLEAR UI 3 REG TEMP BLOCK AND SET UP A
			; TO POINT THERE
EDCLK=EMT!16		;TICK CLOCK ONCE IN DEBUG MODE
EDMM0=EMT!17		;DEPOSIT CONTENTS OF TWO WD BLOCK
			; POINTED TO BY A IN DEST GIVEN BY B.
			; B IS INTERPRETED AS A DESTINATION FIELD
			; (AS IN ALU INSTRUCTION).  IF B IS
			; A M MEMORY LOCN, DESIRED VALUE IS
			; "BUILT UP" DIRECTLY IN B. OTHERWISE,
			; IT IS BUILT UP IN M MEM LOCN 0 AND
			; THEN STORED IN B.
ENPCLK=EMT!20		;TICK CLOCK ONCE WITH NO-OP BIT ON
EEXAMD=EMT!21		;EXAMINE DATA PATH MEMORIES. LOCN OF TWO
			; WD BLOCK IN A, MEM LOCN 
			; (AS FOR DESTINATION) IN B
EDJPC=EMT!22		;DEPOSIT B IN PC FIELD (OF JUMP INST)
			; IN BLOCK POINTED TO BY A
EDCMEM=EMT!23		;DEPOSIT 3 WD BLOCK IN A IN CONTROL MEM
			; AT ADR IN B
EICLR=EMT!24		;ZERO 3 WD BLOCK POINTED TO BY A
ECLK=EMT!25		;CYCLE CLOCK ONCE IN REGULAR RUN MODE
EEXAMC=EMT!26		;EXAMINE CONTROL MEM AT LOCN IN B.
			; RETURN RESULT IN BLOCK POINTED TO BY A
ENCLK=EMT!27		;CYCLE CLOCK ONCE IN REGULAR RUN MODE
			; BUT WITH NO-OP BIT SET
EOCTP4=EMT!30		;DO 4 DIGIT PRINT OF # IN A
EOCTPD=EMT!31		;PRINT OUT TWO WD BLOCK POINTED TO BY A AS 11 OCTAL DIGITS
EPI=EMT!32		;PRINT 3 WD BLOCK POINTED TO BY A AS U INST
EPASRC=EMT!33		;EXTRACT A SOURCE FIELD AND PRINT IT
EPMSRC=EMT!34		;EXTRACT M SOURCE FIELD AND PRINT IT
EPDEST=EMT!35		;EXTRACT DEST FIELD (OF ALU OR BYTE) AND PRINT IT
EPOBSL=EMT!36		;EXTRACT OUTPUT BUS SELECT (OF ALU) AND PRINT IT
EPALUF=EMT!37		;EXTRACT ALU FUNCTION (OF ALU INST) AND PRINT IT
EPCRYC=EMT!40		;EXTRACT CARRY CONTROL FIELD OF ALU INST AND PRINT IT
EPQC=EMT!41		;EXTRACT Q CONTROL FIELD OF ALU INST AND PRINT IT
EPDDC=EMT!42		;EXTRACT DISPATCH CONSTANT OF DISPATCH INST AND PRINT
EPDDO=EMT!43		;EXTRACT DISPATCH OFFSET AND PRINT IT
EPDNB=EMT!44		;EXTRACT DISPATCH # OF BITS FIELD AND PRINT IT
EPMROT=EMT!45		;EXTRACT M ROTATE FIELD AND PRINT IT
EPJPC=EMT!46		;EXTRACT JUMP ADDRESS FIELD OF JUMP INST AND PRINT IT
EPJRB=EMT!47		;PRINT JUMP INST R BIT
EPJPB=EMT!50		;PRINT JUMP INST P BIT
EPJNB=EMT!51		;PRINT JUMP INST N BIT
EPJINV=EMT!52		;PRINT JUMP INVERT SENSE BIT
EPJCND=EMT!53		;PRINT JUMP CONDITION FIELD
EPBMD=EMT!54		;PRINT BYTE INST MODE (LDB DPB ETC)
EPBLEN=EMT!55		;PRINT BYTE INST BYTE LENGTH

EXFLD=EMT!56		;EXTRACT BYTE FROM UINST IN 3 WD BLOCK
ELDB=EMT!56		; POINTED TO BY A.
			;B HAS FIELD DESCRIPTION (SEE IPNFLD)
			;RETURN RESULT IN A.

EWPC=EMT!57		;WRITE CONTENTS OF WD POINTED TO BY A
			;INTO PC OF CONS
EPERRS=EMT!60		;PRINT TWO WORD BLOCK POINTED TO BY A
			; INTERPRETED AS ERROR BITS
ESTOP=EMT!61		;STOP CONS AND CLEAR CONS RUNNING FLAG
EDPB==EMT!62		;DEPOSIT B IN WORD BLOCK POINTED TO BY A
			;AT POSITION SPECIFIED BY "BYTE POINTER"
			;IN C. WORKS FOR UP TO 3 PRECISION
EDMDST==EMT!63		;DEPOSIT B IN M MEM PART OF DEST OF BLOCK (A)
EDRDST==EMT!64		;DEPOSIT B IN REG PART OF DEST OF BLOCK (A)
EDDSPO==EMT!65		;DEPOSIT B IN DISPATCH OFFSET FIELD OF BLOCK (A)
ERPDLB==EMT!66		;READ PDL BUFFER ADR IN B INTO 2 WD 
			; BLOCK POINTED TO BY A
EWPDLB==EMT!67		;DEPOSIT BLOCK POINTED TO BY A IN
			;PDL BUFFER ADR IN B
ESUSTK==EMT!70		;SAVE ENTIRE U STACK IN USSVD BLOCK
			; SAVES POINTER IN USTPNR
			;NOTE: TESTS USSVDF TO SEE IF USTACK
			; ALREADY SAVED. IF SO, DOES NOTHING
EUUSTK==EMT!71		;UNSAVE ENTIRE U STACK AND POINTER
			; IF THEY HAVE BEEN SAVED BY ESUSTK
ETEXTP==EMT!72		;OUTPUT ASCIZ TEXT STRING POINTED TO BY A
ECCLK==EMT!73		;DO ECLK UNLESS NOOPF SET, IN WHICH CASE
			;DO ENCLK. CLEAR NOOPF.
EDCCLK==EMT!74		;DO EDCLK UNLESS NOOPF SET, IN WHICH CASE
			;DO ENPCLK
ERESET==EMT!75		;RESET CONS
ERDSP==EMT!76		;READ DISPATCH MEM INTO WD POINTED TO BY A,
			;ADDR IN B.  TRANSPARENT TO DISPATCH CONSTANT REGISTER.
EWDSP==EMT!77		;WRITE DISPATCH MEM FROM WD POINTED TO BY A,
			;ADDR IN B.  TRANSPARENT TO DISPATCH CONSTANT REGISTER.
ERDSPC==EMT!100		;READ DISPATCH CONSTANT REGISTER INTO WD POINTED TO BY A
EWDSPC==EMT!101		;WRITE DISPATCH CONSTANT REGISTER FROM WD POINTED TO BY A
EWIR==EMT!102		;DO EWDIB, THEN ENPCLK TO LOAD INTO IR
EDPBLK==EMT!103		;TAKES POINTER TO 4 WD BLOCK IN A.
			;FIRST WD IS REGISTER ADR,
			;NEXT THREE ARE VALUE, WHICH IS
			;DEPOSITED IN INDICATED ADR
ERL1MP==EMT!104		;READ LVL 1 MAP INTO WD POINTED TO BY A. ADR IN B.
EWL1MP==EMT!105		;WRITE LVL 1 MAP FROM WD POINTED TO BY A. ADR IN B.
ERL2MP==EMT!106		;READ LVL 2 MAP INTO 2 WD BLOCK POINTED TO BY A.
			;ADR IN B.
EWL2MP==EMT!107		;WRITE LVL 2 MAP INTO 2 WD BLOCK POINTED TO BY A.
			;ADR IN B.
ERMEMS==EMT!110		;SAVE MEM SUBROUTINE (VMA+MWD)
EWMEMS==EMT!111		;WRITE MEM SUBROUTINE (VMA+MWD)
ERDBLK==EMT!112		;TAKES POINTER TO 4 WD BLOCK IN A.
			;FIRST WD IS REGISTER ADR. EXAMINE THIS ADR, AND STORE
			;RESULT IN NEXT THREE WORDS.
EWPVMA==EMT!113		;WRITE "PHYSICAL" VMA. TAKES POINTER TO TWO WD BLOCK
			; AND LOADS VMA, LVL 1 AND 2 MAPS SO THAT LOCN WILL BE REF'ED
			; (CLOBBERS MWD)
EMMWC==EMT!114		;CAUSE MAIN MEMORY WRITE CYCLE. (ASSUME EVERYTHING SET UP,
			; IE, DATA IN MWD, ADR IN VMA AND MAPS, ETC)
EMMRC==EMT!115		;CAUSE MAIN MEMORY READ CYCLE.  (ASSUME ADR IN VMA AND MAPS)
EVMEMS==EMT!116		;VALIDIFY MEMORY SUBROUTINE (JUST THE MAPS, NOT MWD,MRD,VMA)

;TRP S ARE SIMILAR TO EMTS BUT SAVE ALL AC S BEFORE DISPATCH
;AND RESTORE AFTERWARDS. NO PROVISION FOR ERROR RETURN VIA
;CARRY FLAG.

TRP=104400

IFATL=TRP!0		;FATAL ERROR
IPNFLD=TRP!1		;EXTRACT AND PRINT NUMERIC FIELD.
			; POINTER TO U INST IN A.
			; B HAS FIELD DESCRIPTOR.
			;  BYTE 1 LENGTH IN BITS,
			;  BYTE 0 NUMBER OF BITS OVER (TRIPLE
			;   PRECISION WISE)
			;AFTER EXTRACTION, FIELD IS PRINTED AS
			;A FIXED WIDTH OCTAL FIELD, WHERE WIDTH
			;IS JUST GREAT ENUF TO ACCOMODATE FIELD 
			;SIZE
IPSFLD=TRP!2		;EXTRACT AND PRINT "SYMBOLIC" FIELD.
			; POINTER TO UINST IN A
			; FIELD DESCRIPTION IN B (SAME AS FOR
			;  IPNFLD).
			; TABLE BASE IN C.
			;FIELD IS EXTRACTED, THEN VALUE USED TO
			;INDEX WORD ORIENTED TABLE STARTING AT
			;ADR IN C.  WORD FROM TABLE POINTS AT
			;.ASCIZ STRING WHICH IS PRINTED.


;EETST=EMT 1		;EXAMINE CONS TO SEE IF ANY ERRORS ARE ON. (PARITY, ETC)
;			; IF SO, DISPLAY ERRORS AND RETURN WITH CARRY SET.
;			; IF NOT, RETURN WITH CARRY CLEAR
;ENORM=EMT 2		;"NORMALIZE" CONS. IE CYCLE CLOCK ONCE WITH NO-OP ON TO ASSURE
;			; THAT EVERYTHING THATS GOING TO GET WRITTEN, GETS WRITTEN, ETC.
;ERDOB=EMT 3		;READ OBUS INTO DOUBLE WORD POINTED TO BY AC A.
;ERDIR=EMT 4		;READ IR INTO TRIPLE WORD POINTED TO BY AC A.
;EWDIB=EMT 5		;WRITE TRIPLE WORD POINTED TO BY A
;			; INTO DIAGNOSTIC INSTRUCTION BUFFER
;EWCM=EMT 6		;WRITE CONTROL MEMORY. A POINTS TO THREE WORD BLOCK,
;			; B GIVES CONTROL MEMORY ADDRESS.  CHECKS DATA WRITTEN
;			; AND RETURNS WITH CARRY SET IF BAD.
;ERCM=EMT 7		;READ CONTROL MEMORY. A POINTS TO THREE WORD BLOCK,
;			; B GIVES CONTROL MEMORY ADDRESS.
;ERPC=EMT 10		;READ MICRO PC INTO ADDRESS POINTED TO BY A
;EWPC=EMT 11		;WRITE MICRO PC FROM LOCN POINTED TO BY A
;EROPC=EMT 12		;READ OPC VECTOR INTO 8 REGISTER VECTOR POINTED TO BY A
;ERDSM=EMT 13		;READ DISPATCH MEMORY. LOCN IN B.
;EWDSM=EMT 14		;WRITE DISPATCH MEMORRY. LOCN IN B.
;ERAM=EMT 15		;READ A MEM. POINTER TO TWO WD BLOCK IN A. LOCN IN B
;ERMM=EMT 16		;READ M MEM. (OR MMUX).
;EWDATM=EMT 17		;WRITE "DATA PATH" MEMORIES. B HAS WHAT TO PUT IN DEST OF INST.

.SBTTL DEFINE VARIOUS CONS MACHINE WORD FORMATS

;"PSEUDO" DESTINATION DEFS
; EDMM0 KNOWS ABOUT THESE.  THEY ARE DISTINGISHED FROM REAL
;  DESTINATIONS BY PRESENCE OF 2000 BIT
; THESE REGISTERS ARE UNUSAL IN THAT THEY CANNOT BE SPECIFIED
;  AS A NORMAL "FUNCTIONAL DESTINATION".
CSDQ==  2000		;Q REGISTER
CSDUSP==2001		;U CODE STACK POINTER
CSDDC== 2002		;DISPATCH CONSTANT REGISTER


;CONS MICRO WORD FIELD DEFS

CDAMEM==1000		;IF SET, SELECT DEST TO A MEMORY
 CAMEMB==200		; SAME BIT IN DIRECT FORM (IE IN WD1)
CDMD==	40		;MEMORY DATA REG
CDMDWN==100		;MEMORY DATA REG, WRITE NOW
CDVMA==	200		;VMA
CDVMAR==240		;VMA START READ
CDVMAW==300		;VMA START WRITE
CDVMAM==340		;VMA WRITE MAP
CDCPPH==440		;PDL(POINTER), PUSH
CDCPI==	500		;PDL(INDEX)
CDPI==	540		;PDL INDEX
CDPP==	600		;PDL POINTER
CDSPCH==640		;MICRO-PC-STACK(SPCPTR), PUSH SPCPTR
CDIMH==	700		;INSTRUCTION MODIFIER HI (44-24)
CDIML==	740		;INSTRUCTION MODIFIER LO (23-0)

;O BUS CONTROL (ALU INST)
COBMSK==0		;SELECT MASKING LOGIC (RANDOM)
COBA==	1		;SELECT ALU OUTPUT
COBAR==2		;SELECT ALU OUTPUT SHIFTED RIGHT 1
COBAL==3		;SELECT ALU OUTPUT SHIFTED LEFT 1

;ALU FUNCTION DEFS (NOTE: THE M MUX IS HOOKED TO THE "A" SIDE OF THE ALU)
; BOOLEAN ONES  ( AND THE A MEMORY IS HOOKED TO THE "B" SIDE)
USETCM==20		;OUTPUT COMPLEMENT OF M SIDE
UANDCB==21		;AND, COMPLEMENT BOTH
UANDCM==22		;AND, COMPLEMENT M
USETZ==	23		;OUTPUT ZEROS
UORCB==	24		;IOR, COMPLEMENT BOTH
USETCA==25		;OUTPUT COMPLEMENT OF A SIDE
UXOR==	26		;XOR
UANDCA==27		;AND, COMPLEMENT A SIDE
UORCM==	30		;IOR, COMPLEMENT M SIDE
UEQV==	31		;EQV
USETA==	32		;OUTPUT A SIDE
UAND==	33		;AND
USETO==	34		;OUTPUT ONES
UORCA==	35		;IOR, COMPLEMENT A SIDE
UIOR==	36		;IOR
USETM==	37		;OUTPUT M SIDE
; ARITHMETIC ONES
UAOSM==	0		;OUTPUT M+1
USUB==	6		;OUTPUT M-A
UADD==	11		;OUTPUT M+A
UASHM==	14		;OUTPUT M+M  (IE ASH M 1)
USOSM==	17		;OUTPUT M-1


;CONS OP CODES (IN PROPER PLACE FOR BIS ING INTO 3 WD)
CIALU==0		;ALU
CIDSP==200		;DISPATCH
CIJMP==400		;JUMP
CIBYTE==600		;BYTE

CIPJB==100		;POPJ-AFTER-NEXT BIT

;CONS JUMP INSTRUCTION BITS
CIJRB==1000		;RETURN BIT
CIJPB==400		;PUSHJ BIT
CIJNB==200		;N BIT (NO-OP FOLLOWING INST)
CIJINV==100		;INVERT JUMP SENSE
CIJTC==40		;TEST CONDITION (AS OPPOSED TO TEST BIT)

;CONS JUMP INSTRUCTION CONDITIONS
CIJALN==CIJTC+1		;ALU NEGATIVE CONDITION
CIJA31==CIJTC+2		;ALU BIT 31
CIJAEM==CIJTC+3		;A = M CONDITION
CIJINT==CIJTC+4		;INTERRUPT PENDING CONDITION
CIJPF==CIJTC+5		;VMA NOT OK CONDITION (PAGE FAULT)
CIJPFI==CIJTC+6		;VMA NOT OK OR INTERRUPT PENDING
CIJUC==CIJTC+7		;UNCONDITIONAL 1

;CONS M SOURCE DEFS
CMSMMD==42		;MAIN MEMORY DATA
CMSMWD==52		;MAIN MEMORY WRITE DATA
CMSVMA==62		;VMA
CMSPMD==72		;PAGE MAP DATA
CMSQ==  43		;Q REGISTER
CMSPPI==44		;PDL INDEX (9-0), PDL POINTER (19-10)
CMSUS== 45		;U STACK DATA (17-0) U STACK POINTER (31-27)
CMSUSP==55		;SAME AS ABOVE, ALSO POP SPC POINTER
CMSDC== 46		;DISPATCH CONSTANT
CMSCI== 47		;PDL (INDEX)
CMSPPP==57		;PDL (POINTER), POP
;67 UNUSED
CMSCP== 77		;PDL (POINTER)


;CONS FUNCTIONAL DESTINATION DEFS
CFDMWD==1		;MAIN MEMORY WRITE DATA REGISTER
CFDMMW==2		; AS ABOVE, AND INITIATE WRITE
;3
CFDVMA==4		;VMA
CFDVMR==5		;VMA, START READ
CFDVMW==6		;VMA, START WRITE
CFDVWM==7		;VMA, WRITE MAP
CFDCP==10		;PDL(POINTER)
CFDCPP==11		;PDL(POINTER), PUSH
CFDCI== 12		;PDL(INDEX)
CFDPI== 13		;PDL INDEX
CFDPP== 14		;PDL POINTER
CFDUSP==15		;U STACK (CAUSES PUSH)
CFDIMH==16		;INST MOD HI (44-24)
CFDIML==17		;INST MOD LO (23-0)

;BITS IN DISPATCH MEM
CDMPAR==100000		;PARITY BIT
CDMR==40000		;R
CDMP==20000		;P
CDMN==10000		;N

;MISC FUNCTION BITS (IN POSITION FOR BIS ING INTO FIRST WD OF U INST)
CMF1==1_10.
CMF2==2_10.
CMF3==3_10.

;ERROR BITS
;ERROR WD 1
; HIGH BYTE FROM 164000 HIGH BYTE
CESPCP==100000		;SPC PARITY
CEDSPP==40000		;DISPATCH PARITY
CEHIER==20000		;HIGH RUN LOSSAGE
CECP==	10000		;MAIN CONTROL MEM PARITY (IN IR NOW)
CEMMP==	4000		;M MEM PARITY
CEAMP==	2000		;A MEM PARITY
CEPDL==	1000		;PARITY ERROR IN PDL BUFFER
CEMNMP==400		;MAIN MEMORY PARITY
; LOW BYTE FROM 164002 HIGH BYTE
;  	;200	;100000	;- ERRHALT
CEHNOK==100	;40000	;- HIGH OK (DC SIGNAL)
CESRUN==40	;20000	;S RUN (1 IF RUN=1 AND ALL ERRORS ARE 0)
CESSDN==20	;10000	;SINGLE STEP DONE
; 4000,2000,1000, AND 400 BITS ARE OPC BITS AND ARE NOT CONSIDERED
; PART OF ERROR WORD

;WD1
; HIGH BYTE FROM HIGH BYTE OF 164010
CEWIM==	100000		;WRITE INSTRUCTION MEMORY ON NEXT CLOCK
CEIMOD==40000		;INSTRUCTON IN IR WAS MODIFIED VIA OA PATHS
CEINOP==20000		;IF SET, MACHINE WILL NO-OP INSTRUCTION
			; TRYING TO BE EXECUTED ON NEXT CLOCK
;  REST OF BITS IN HIGH BYTE OF 164010 ARE IR BITS AND NOT
;  CONSIDERED PART OF ERROR WORD.
; LOW BYTE FROM HIGH BYTE OF 164012
	;200	;100000	;UNUSED
CENMMW==100	;40000	;NOT WAITING FOR MAIN MEMORY
CEWPDL==40	;20000	;WRITE INTO PDL BUFFER WILL OCCUR ON NEXT CLOCK
CEWSPC==20	;10000	;WRITE INTO SPC WILL OCCUR ON NEXT CLOCK
CEPF==	10	;4000	;MAPPED ADR NOT OK
CEJC==	4	;2000	;JUMP CONDITION BIT
CEPCS1==2	;1000	;PC SOURCE BIT 1
CEPCS0==1	;400	;PC SOURCE BIT 0
			; 0 -> PC+1
			; 1 -> DISPATCH MEM
			; 2 -> SPC (AS IN POPJ)
			; 3 -> IR 23-12 (JUMP OPERATION)


.SBTTL START OF PROGRAM

.=400+PDL

GO:	RESET			;IN THE PRIVACY OF YOUR OWN HOME
	MOV #2,CMREQ		;GO INTO CONSOLE MODE AS DEFAULT
GO0:	CLR	PS
	CLR LDBUFF		;CLEAR 10 BUFFER FLAG
	CLR DSKRQB+2		;CLEAR DISK REQUEST
	CLR DSKRQB		;MUST BE IN THIS ORDER!
	CLR LDBFF2		;..
	CLR TNRQFG
	MOV	VERSE,0
	MOV	#GO,SP		;SET UP PUSH DOWN POINTER
	MOV	#KLIBRK,KLIPC	;SET UP INTERRUPT VECTORS
	MOV	#5_5,KLIPSW
	MOV	#CLKBRK,LKPC
	MOV	#6_5,LKPSW
	MOV	#4_5,A		;LEVEL 4 IN AC A
	MOV	#6_5,C		;ALL PROCESSOR TRAPS GO ON 6
	CLR TT			;LEVEL 0 IN TT
	MOV	#NXMPC,B
	MOV	#NXMFND,(B)+	;BUS TIME OUT
	MOV	C,(B)+
	MOV	#RESBRK,(B)+	;RESERVED INSTRUCTION
	MOV	C,(B)+
	MOV	#RUGBRK,(B)+	;BREAK POINT
	MOV	C,(B)+
	MOV	#IOTBRK,(B)+	;IOT TRAP
	MOV	C,(B)+
	MOV	#POWERF,(B)+	;POWER FAILURE
	MOV	C,(B)+
	MOV	#EMTBRK,(B)+	;EMT
	MOV	TT,(B)+		;PUT EMT ON PROGRAM LEVEL (0)
	MOV	#TRPBRK,(B)+	;"TRAP" TRAP (LEV 0)
	MOV	TT,(B)+
	MOV	#TYIBRK,TYIPC	;KEYBOARD ON 4
	MOV	A,TYIPSW
.IF NZ TVP
	CLR TVCTL		;SELECT PLANE 0
	CLR TVCTL2		;BLACK ON WHITE, CLEAR VIDEO SWITCH
.ENDC ;TVP
.IFNZ GT40P
	MOV	#DSPC,B		;DISPLAY BREAKS (LEV 4)
	MOV	#DSBRK,(B)+
	MOV	A,(B)+
	MOV	#LPBRK,(B)+
	MOV	A,(B)+
	MOV	#DTOBRK,(B)+
	MOV	A,(B)+
	MOV	#HMEML,TT
	MOV	TT,MEMTOP
	MOV	#FS,T
	JSR	PC,CLRL3	;CLEAR ALL OF MEMORY, FIRST NXM STOPS IT
.ENDC ;GT40P
	CLR	ACTCHR
	MOV	#BUF,GETCC	;DL11 INPUT VECTOR
	MOV	#BUF,PUTCC
.IFNZ DEBUG
	JSR	PC,DEBST	;DO ASSORTED HACKING (RE INTERRUPT VECTORS, ETC.)
.ENDC
	MOV	#NXMBRK,NXMPC	;ALL FUTHER BUS ERRORS WILL HALT
;DROPS THRU

;DROPS IN
.IFNZ GT40P	;FREE STORAGE ONLY EXISTS IN GT40 VERSION
	MOV	MEMTOP,T
	MOV	#-1,-(T)	;EVERYTHING ABOVE FREE STORAGE RESERVED
	MOV	T,MEMTOP	;SET UP FREE STORAGE
	MOV	#FAKEBL+2,T
	MOV	T,AVAIL
	MOV	T,ROVER
	MOV	#FS+2,TT	;SET UP FAKE BLOCK
	CLR	-2(T)		;SIZE 0
	MOV	TT,(T)		;FAKEBL FD PNTR
	MOV	TT,2(T)		;BACK PNTR
	MOV	#-1,4(T)	;LOOKS TAKEN FROM ABOVE
	MOV	T,(TT)		;FD PNTR IN FS
	MOV	T,2(TT)		;BACK PNTR IN FS
	MOV	MEMTOP,A
	SUB	#FS,A		;SIZE OF FREE STORAGE (LEAVE 1 WD FOR -1)
	MOV	A,-(TT)
	CLR	RETLAD
	CLR	TXSTRT
	CLR	GRSTRT
	MOV	#DPYRTS,GRJMP
	MOV	#LOWLIN+TXTIDX,T	;INITIALIZE TEXT RING
GO2:	CLR	(T)+
	MOV	#DPYJMP,(T)
	ADD	#LHDRS-2,T
	CMP	T,#HILIN+TXTIDX
	BLO	GO2
	CLR	(T)+
	MOV	#DPYRTS,(T)
	MOV	#-DPYPDL/2,DPYPDC	;SET UP DPY PUSH DOWN LIST
	MOV	#DPYPDB+DPYPDL,DPYPDP
	CLR	CPOS			;SET SCREEN VARIABLES
	CLR	CLINE
	MOV	#NLINS-CHRHT+1,CURSY	;CURSOR Y 
	CLR	BYTCNT
	JSR	PC,HU
	JSR	PC,CLRLIN
	MOV	#LOWLIN,TXSTRT
	MOV	#<LOWLIN+TXTIDX>,TEXTP
	CLR	CASE
	DEC	OCSR			;FORCE DSBRK TO LOOK AT CSR
	MOV	#MIBFRS-1,B
	MOV	#MIBUF,A		;SET THE MAIN/INTERUPT BUFFERS
	MOV	#6,C			;6 BYTES PER BUFFER
	MOV	#MIBUF+2,PUTDPY
	MOV	#MIBUF+2,GETDPY
GO3:	MOV	A,(A)
	ADD	C,(A)+
	CLR	(A)+			;FOR ADDRESS
	CLR	(A)+			;FOR CONTENTS
	DEC	B
	BGT	GO3
	MOV	#MIBUF,(A)+
	CLR	(A)+
	CLR	(A)+
.ENDC ;GT40P
 	MOV	#100,A
	MOV	A,TKS			;ENABLE INTERUPTS
	MOV	A,@AKLIS
.IIF NZ TVP, MOV A,LKS		;CLK BRKS ENABLED IF TV
.IFNZ PCHIST
	MOV	#PCBUF,PCPNT
.ENDC
.IFNZ GT40P
;.IFNZ DLIMSW				;CLOCK NEEDED ONLY FOR DISPLAY LIMITING
;	MOV	A,LKS
;	CLR	DSTOPD
;	CLR	DTIME
;	CLR	TICKS
;.ENDC
	MOV	#DPYSA,@ADPC		;START THE DISPLAY
.ENDC ;GT40P
MAINLR:;CLR	LMHTTY
	CLR	CNHTTY
	CLR 	BLKTIM		;JUST TO GET OUT OF WEDGED STATE IF 60 CY COUNTER OVFL 16 BITS
	BR	MAINL


.SBTTL MAIN LOOP & COMMAND PROCESSOR

MAINL1:	JSR	PC,ADDCHR		;PROCESS CHAR FROM INPUT BUFFER
MAINL:	CLR RAIDM			;USE WHOLE SCREEN
	MOV	CURSX,RCURSX
	MOV	CURSY,RCURSY
	TST CMREQ
	BGE CMAIN			;GO TO CONSOLE MONITOR MAIN LOOP
	JSR	PC,GETCHW		;WAIT FOR CHARACTER
;	CMP	#ESCHR,A
;	BNE	MAINL1
;	JSR	PC,CMND			;PROCESS DISPLAY SLAVE COMMAND
	BR	MAINL1


CMAIN:	ZAPFLG CNHTTY		;INDICATE IN CONSOLE MONITOR MODE
	JSR PC,ENTER
	JSR PC,CDSPLY		;DISPLAY CONSOLE
	JSR PC,RDHU		;HOME UP (BUT STAY BELOW RAID AREA)
CMN1R:	CLR REGOPF		;NO REGISTER OPEN
CMN1:	CLR DEPFLG		;DEPOSIT DONE FLAG
	MOV #-1,RAIDM		;CONFINE PRINTOUT TO BETWEEN RAID AREA AND CONSOLE AREA
	MOV #-1,CMREQ		;INDICATE GOT HERE
	JSR PC,GECOM		;RETURN WITH ASCIZ STRING IN CBUF
				;IF CNUMF HAS -1, CONVERTED INTEGER IN CNUM, +2, +4
				;TERMINATING CHR IN A
	CMP A,#'		;ALT MODE
	BEQ CMNX
	TST CVALF
	BEQ CMN1A		;NO VALUE, SO WHAT EVER CNUMF HAS IS IT
	MOV #CNUM,T		;CNUM MUST BE 0 IF CNUMF IS 0
	MOV #CVAL,TT
	ADD (TT)+,(T)+
	ADC (T)
	ADD (TT)+,(T)+
	ADC (T)
	ADD (TT)+,(T)+
	DEC CNUMF		;INDICATE "NUMBER"
CMN1A:	CLR CVALF		;USE UP VALUE
	ASL A
	MOV A,B
	MOV CNUM,A		;(LOW ORDER) ARG ALSO IN A (0 IF NO ARG)
	JSR PC,@COMTAB(B)	;ARGP IN CNUMF, ARG IN CNUM
	MOV A,CVAL		;BUT THIS IS A NO-OP UNLESS COMMAND HAS DEC'ED CVALF
	TST DEPFLG
	BEQ CMN1B
	JSR PC,CDSPLY		;POSSIBLY UPDATE RAID VARS
CMN1B:	BR CMN1


CMNX:	JMP MAINLR		;GO BACK TO DATAPOINT MODE

CMCR:	JSR PC,REGCLS		;CLOSE OPEN REG, IF ANY
	MOV #15,A
	JSR PC,TYOCHR
	RTS PC

COMERR:	ETEXT
	ASCQQ
	TST TNRQFG
	BEQ 1$
	CLR LDBUFF		;REQUEST FROM 10 LOST, FLUSH IT
	CLR LDBFF2		;..
	CLR TNRQFG
1$:;	CLR LMHTTY		;TAKE TTY AWAY FROM LISP MACHINE
	TST CNHTTY
	BNE CMAINR
	JMP GO0

CMAINR:	MOV #GO,SP
	BR CMN1R

RDFLD1:	ETEXT
	ASCXXX
RDFLD:	JSR PC,GECOM		;GET FIELD
	CMP A,#RUBCOD
	BEQ RDFLD1
	CMP A,#7
	BEQ COMERR
	TST CNUMF
	BLT RDFLDX
	CMP A,#40
	BEQ RDFLD		;SPACE DOES NOT TERM NULL FIELD
RDFLDX:	RTS PC

QFF:	JSR PC,TVPREP
	JSR PC,HU		;CLEAR SCREEN
	JSR PC,CLEOF
	JSR PC,CDSPLY		;PUT BACK CONSOLE DISPLAY
	JSR PC,RDHU		;GO TO TOP OF CONSOLE AREA
	CLR BLKDFR
	RTS PC

RDNM:	JSR U,ACSAV		;READ NUMBER
	JSR PC,GECOM
	JSR U,ACRES
	TST CNUMF
	BNE RDNM1
	SEC			;SET CARRY -> NO NUMBER
RDNM1:	RTS PC

GECOM:	CLR SYMFND
	JSR PC,GCOM		;GET COMMAND, EVAL SYMS
	TST CNUMF
	BLT GECOMX
	TST CSYL
	BEQ GECOMX
	MOV #GSYMT,B		;SEARCH SYMTAB
GECSML:	CMP B,#GSYMTE
	BHIS GECNF		;NOT FOUND
	MOV #CBUF,T
	MOV (B)+,U
GECSM2:	CMPB (T)+,(U)
	BNE GECSM3
	TSTB (U)+
	BNE GECSM2
	MOV (B),CNUM		;RETURN VALUE
	DEC CNUMF		;INDICATE VALUE PRESENT
	DEC SYMFND
GECOMX:	RTS PC

GECSM3:	TST (B)+		;MOVE TO NEXT SYM
	BR GECSML

GECNF:	ETEXT
	ASCQST
	JMP BELL

SYMFND:	0


GSYMT:	ASCRST			;RESET
	RARSET
	ASCVMA			;VMA
	RAVMA
	ASCMWD			;MWD
	RAMWD
	ASCRDR			;RAIDR
	RARDRO
	ASCNPF			;NOOPF
	RACSWO+<<NOOPF-CSSWO>/2>
	ASCLLM			;LLMODE
	RACSWO+<<CLLMOD-CSSWO>/2>
	ASCFSV			;FSV
	RACSWO+<<CFSVAL-CSSWO>/2>
	ASCPSV			;PSV
	RACSWO+<<CPSVAL-CSSWO>/2>
	ASCFD			;FDEST
	RAFDO
	ASCFS
	RAFSO
	ASCIR			;.IR
	RAIR
	ASCSIR			;IR
	RASIR
	ASCPC			;PC
	RAPC
	ASCUSP			;USP
	RAUSP
	ASCQ			;Q
	RAQ
	ASCDC1			;DC
	RADC
	ASCPP			;PP
	RAPP
	ASCPI			;PI
	RAPI
	ASCCIB			;CIB
	RACIBO
	ACVMAR			;CVMAR
	RACVMR
	ACMRD			;CMRD
	RACRDR
	ACPMAR			;CPMAR
	RACPMR
	ACMWD			;CMWD
	RACMWD
	ACVMAW			;CVMAW
	RACVMW
	ACPMAW			;CPMAW
	RACPMW
	ASCMOD			;MODE
	RAMOD
GSYMTE:


GCOM:	MOV #CBUF,GCMPTR
	MOV #<CBUFL-1>*2,CBUFC
	JSR PC,GCZNM		;ZERO CNUM
	CLR CDNUM
	MOV #-1,CNUMF
	CLR CSYL
	CLR COMFRC		;COMMAND FORCE
GCOM1:	JSR PC,CTYI
;	TST LMHTTY
;	BGT LMTYI		;GO FEED CHAR TO LISP MACHINE
	CMP A,#3
	BEQ GCOM1		;IGNORE ^C S (IN CASE THEY COME FROM 10 IN COMMAND FILE)
	CMP A,#173
	BLT GCOM1B
	SUB #32,A		;COLLAPSE HOLE LEFT BY LOWER CASE LETTERS
	BR GCOMT		;LEAVING OPEN BRACE JUST ABOVE `

GCOM1B:	CMP A,#140
	BLE GCOM1A
	SUB #40,A		;UPPER CASEIFY
GCOM1A:	TST COMFRC
	BNE GCOMT		;FORCE TO BE COMMAND CHAR
	CMP A,#'0
	BLT GCOM2
	CMP A,#'9
	BLE GCOMN		;DIGIT
GCOM2:	CMP A,#'A
	BLT GCOM3
	CMP A,#'Z
	BLE GCALP
GCOM3:	CMP A,#'.
	BEQ GCOMPD
	CMP A,#'@
	BEQ GCOMAT		;ATSIGN FORCES NEXT CHR TO DISPATCH
GCOMT:	CLRB @GCMPTR		;STORE 0 ON ASCIZ STRING
	CMP CBUF,(PC)+
	.ASCIZ /./
	BEQ GCMPT		;GEE THATS OUR SYMBOL!!
	TST CSYL
	BNE GCOMT1
GCNONM:	CLR CNUMF		;NULLNESS, REALLY NO NUMBER
GCZNM:	MOV #CNUM,TT		;ASSURE CNUM IS 0 IF NO NUMBER
	CLR (TT)+
	CLR (TT)+
	CLR (TT)+
GCOMT1:	RTS PC

;LMTYI:	CMP A,#23	;^S TAKEN AS COMMAND EVEN IF LISP MACHINE HAS TTY
;	BEQ GCOMT
;	CMP A,#24	;^T ..
;	BEQ GCOMT
;	CMP A,#30	;^X ..
;	BEQ GCOMT
;	CLR -(SP)
;	MOV A,-(SP)
;	CMP A,#15
;	BNE 1$
;	JSR PC,TYOCHR		;ECHO CR AS CR,LF,CLEOL
;1$:	MOV SP,A
;	JSR PC,QDPRC0
;	CMP (SP)+,(SP)+		;FLUSH TEMP REGISTERS
;	BR GCOM

GCMPT:	MOV CONSPT,CNUM		;SUPPLY VALUE OF PT
	DEC CNUMF		;MAKE NUMBER AGAIN
	BR GCOMT1

GCOMAT:	DEC COMFRC		;FORCE TO BE COMMAND
	BR GCOM1

GCOMN:	MOV #CNUM,C		;ASSEMBLE OCTAL NUMBER
	JSR PC,GCOMN1
	ASL CDNUM
	ADD CDNUM,T		;WHICH HAS LAST DIGIT
	ASL CDNUM
	ASL CDNUM
	ADD T,CDNUM		;ASSEMBLE DECIMAL NUMBER 
				; 8+2=10.!
	BR GCCHRS

GCOMPD:	MOV CDNUM,CNUM		;USE DECIMAL NUMBER
	CLR CNUM+2		;LOSER S WHO TYPE THREE PRECISION DECIMAL NUMBERS DESERVE TO LOSE
	TST CSYL
	BEQ GCALP		;NO FLOATING POINT! INITIAL . IS ALPHABETIC
	BR GCCHRS

GCOMN3:	JSR PC,GCOMN2		;THREE PRECISION DOUBLE ASL (C)
GCOMN2:	ASL (C)			;THREE PRECISION ASL (C)
	ROL 2(C)
	ROL 4(C)
	RTS PC

GCOMN1:	JSR PC,GCOMN3
	JSR PC,GCOMN2
GCOMN5:	MOV A,T
	SUB #'0,T
GCOMN4:	ADD T,(C)
	ADC 2(C)
	ADC 4(C)
	RTS PC


GCALP:	JSR PC,GCNONM		;NO NUMBER
GCCHRS:	MOV #-1,CSYL
	DEC CBUFC
	BLE GCCHR1
	MOVB A,@GCMPTR		;STORE CHAR IN STRING
	INC GCMPTR
GCCHR1:	JMP GCOM1

CTYI:	MOV	CURSX,RCURSX	;MAKE SURE CURSOR DISPLAYING IN RIGHT PLACE
	MOV	CURSY,RCURSY
CTYI1B:	TST TENMOD
	BNE CTYI1		;PDP-10 MODE, DONT TOUCH
	JSR PC,WATST		;STARTING A WAIT, SO MAYBE RELOAD IR
CTYI1:	TST LDBFF2
	BNE 1$
	TST LDBUFF
	BEQ CTYI1A		;NO COMMAND FROM 10
1$:	JSR PC,C10CM		;PROCESS 10 COMMAND
	BR CTYI1B		;THAT MAY HAVE CLOBBERED IR, SO PUT IT BACK

CTYI1A:	TST DSKRQB		;REQUEST FROM 10?
	BEQ 2$			;NO
	JSR PC,DSKRUN		;YES, RUN THE DISK
2$:	TST TENMOD
	BNE 1$			;PDP-10 MODE, DONT TOUCH
	TST CTRUN
	BEQ 1$
	TST 164002		;IF CONS TRYING TO RUN, BUT HALTED,
	BMI 1$
	CLR CTRUN		;LOSE, ERROR; NOT ONLY STOP, BUT STOP TRYING
	JSR PC,ENTER		;SAVE STATE OF MACHINE
	JSR PC,CDSPLY		;AND UPDATE THE DISPLAY
1$:
CTYI1C:	JSR PC,FOO105		;CHECK FOR 105 FOOBAR REQUEST
	MOV TYICH,A		;COMMAND TYPEIN.
	BEQ CTYI1		;NO CHR
	CLR TYICH
	PUSH A
	CMP A,#40
	BLT CTYI2		;DONT ECHO CONTROL CHRS
	CMP A,#177
	BEQ CTYI2		;NOR RUBOUT
	JSR PC,ADDCHR		;ECHO CHR
CTYI2:	POP A
	RTS PC

WATST:	TST CPSVAL		;POSSIBLY STARTING A WAIT, SO RELOAD IR
	BEQ WATSTX		; SAVED IR NOT VALID
	MOV #CIR,A
	EWIR			;RELOAD IR SO ITS THERE FOR DEBUGGING
WATSTX:	RTS PC

CDSPLY:	PUSH RAIDM		;GOING TO DISPLAY TEXT OUTSIDE MAIN WINDOW
	CLR RAIDM
	PUSH CPOS		;SAVE CURRENT CURSOR POS
	PUSH CLINE
	TST CLLMOD
	BNE CDSPL1		;DONT DISPLAY RAID STUFF IN LL MODE
	JSR PC,TVPREP
	JSR PC,HU		;START AT TOP OF SCREEN
	CLR B
CDSRL:	TST RAIDA(B)
	BEQ CDSRL1		;THAT ONE NULL
	PUSH B
	ASR B			;FLUSH BYTE BIT
	MOV #1,C
	JSR PC,OCTPNB		;PRINT RAID REG #
	ETEXT
	ASCSP			;PRINT SPACE
	MOV (SP),B
	MOV RAIDA(B),A
	JSR PC,REGPNT		;PRINT IT OUT
	TST CPOS		;CR IF NOT AT BEG OF LINE
	BEQ CDSRL2
	ETEXT
	ASCCR
CDSRL2:	POP B
CDSRL1:	TST (B)+
	CMP B,#<10*2>
	BLT CDSRL		;LOOP IF NOT THRU
CDSPL1:	CLR A			;UPDATE CONSOLE DISPLAY SECTION
	MOV CDLNN,B		;LINE NUMBER TO START CURSOR DISPLAY ON
	JSR PC,CSRPOS
	ETEXT
	CSTARS
	MOV CPC,A		;PRINT PC
	EOCTP4			;4 DIGIT OCTAL PRINT
	ETEXT
	ASC3SP
	MOV #CIR,A
	EPI
	ETEXT
	COBTX
	MOV #COBUS,A		;PRINT OUTPUT BUS
	MOV #<<32.*400>+0>,B
	IPNFLD
	MOV #<RACSWO+<<CLLMOD-CSSWO>/2>>,A
	JSR PC,REGPNT		;PRINT LLMODE=X
	MOV #<RACSWO+<<CFSVAL-CSSWO>/2>>,A
	JSR PC,REGPNT		;PRINT FSV=X
	MOV #<RACSWO+<<CPSVAL-CSSWO>/2>>,A
	JSR PC,REGPNT		;PRINT PSV=X
	MOV #<RACSWO+<<NOOPF-CSSWO>/2>>,A
	JSR PC,REGPNT		;PRINT NOOPF=X
	ETEXT
	CERRST
	MOV #CCERR1,A
	EPERRS
	POP B
	POP A
	JSR PC,CSRPOS		;RESTORE CURSOR POS
	CLR BLKDFR
	POP RAIDM
	RTS PC

;CONSOLE COMMAND PROCESSOR COMMAND FORMAT
;  COMMANDS TO THE CONSOLE PROCESSOR ARE A SINGLE CHARACTER
;   THEY MAY TAKE A (16 BIT MAX) NUMERIC ARG PRECEEDING.
;   MANY COMMANDS ARE "INTERACTIVE" IN THAT THEY PROMPT THE
;   USER FOR FURTHER ARGS ETC AFTER THE COMMAND IS INVOKED.
;   WHEN THE USER IS PROMPTED, THE STANDARD DEFAULT FOR
;   "I DONT WANT TO BOTHER ABOUT THIS FIELD, GO ON TO THE NEXT ON/E"
;   IS SPACE.  A CR USUALLY SAYS "FINISH OFF THE COMMAND AND
;   EXECUTE IT. A RUBOUT INDICATES AN ERROR WAS MADE IN TYPING
;   THE LAST FIELD. THE LAST FIELD IS ERASED AND MAY BE TYPED
;   IN AGAIN.  A CONTROL G QUITS OUT OF THE COMMAND IMMEDIATELY
;   WITHOUT EXECUTING IT.

; ARGUMENTS AND VALUES.
;   MANY COMMANDS CAN TAKE A NUMERIC ARGUMENT PRECEEDING
;   THE COMMAND.  IF NO ARGUMENT IS TYPED, THE ARGUMENT MAY
;   BE SUPPLIED BY THE VALUE OF THE LAST COMMAND.
;   ANY ARGUMENT TYPED OVERRIDES THE VALUE OF THE LAST COMMAND,
;   HOWEVER.  A CR INTERPRETED AT TOP LEVEL CAUSES THE VALUE
;   OF THE LAST COMMAND TO BE DISCARDED.

; VARIOUS MEMORIES.
;   THE CONSOLE PROGRAM KNOWS ABOUT THE FOLLOWING MEMORIES:
;     INTERNALLY, THESE MEMORIES ARE "ADDRESSED" BY A SINGLE
;     SIXTEEN BIT QUANTITY, CALLED THE "REGISTER ADDRESS".
;     IN PARENS BELOW IS THE "KEY" USED TO DENOTE
;     "SYMBOLICALLY" ADDRESSES IN THE GIVEN MEMORY.
;    THE ADDRESS SPACE BELOW COMMENCES AT 40000. ADDRESSES BELOW THIS ARE
;     "NUMBERS".  (QUANTITIES WITH THE 100000 BIT SET ARE ALSO NUMBERS,
;     CALLED "NEGATIVE NUMBERS"). IF "NUMBERS" ARE USED TO REFERENCE MEMORIES,
;     THEY ARE RELOCATED BY THE BASE OF THE LAST MEMORY REFERENCED.

;  REFERENCES TO "MAIN MEMORY".
;     GENERALLY SPEAKING, REGISTER ADDRESSES ARE ASSIGNED ONLY TO REGISTERS
;   WITHIN THE PROCESSOR ITSELF.  THUS, TO REFERENCE MAIN MEMORY ONE MUST
;   "SIMULATE" WHAT THE MICROCODE ITSELF MUST DO (IE LOAD THE VMA-START-READ
;   AND READ THE READ-DATA-REGISTER, ETC.)  ADDITIONALLY, THE MAP (BOTH 1ST
;   AND 2ND LEVELS MUST BE SET UP PROPERLY.  THIS IS A GREAT PAIN, AND ALSO
;   IS VERY INEFFICIENT.  BELOW IS DESCRIBED A MECHANISM FOR SOMEWHAT 
;   ALEVIATING THIS PROBLEM.
;   	PART OF THE PROBLEM IS THE NECESSITY OF SAVING AND RESTORING THE
;   VARIOUS REGISTERS (VMA, MWD, LEVEL 1 AND 2 MAP).  TO ASSIST HERE,
;   SEVERAL "VIRTUAL" REGISTERS ARE DEFINED.  THESE HAVE FUNCTIONS SIMILAR
;   TO THE HARDWARE ONES, BUT HAVE INDEPENDANT EXISTANCE.  THE CONSOLE PROGRAM
;   TAKES CARE OF SAVING AWAY THE "REAL" VALUES AND RESTORING THEM AT THE
;   APPROPRIATE TIMES.
;	FOR ADDITIONAL "EFFIECIENCY" ON REFERENCES FROM THE 10, A HACK IS
;   PROVIDED WHICH MAKES IT POSSIBLE TO DO A "COMPLETE" OPERATION IN ONE
;   4 WORD COMMAND BLOCK.  THIS HACK IS TRIGGERRED WHEN THE 10 SPECIFIES A 
;   NEGATIVE REGISTER ADDRESS.   THE PARTICULAR OPERATION IS SPECIFIED
;   BY THE MAGNITUDE OF THE REGISTER ADDRESS.  THE MOST NOTABLE ONES ARE
;   MAIN MEMORY READS (PHYSICAL AND VIRTUAL PROVIDED).  THE OPERATION IS TO
;   WRITE THE VMA-START-READ FROM THE DATA, THEN CLOBBER THE DATA WITH THE
;   READ DATA REGISTER.  (IF IT WERE NOT FOR THIS HACK, ONE WOULD HAVE TO
;   "TURN THE BUFFER AROUND" FOR EVERY INDIVIDUAL EXAMINE SINCE IT WOULD
;   CONSIST OF "WRITING" THE VMA-START-READ AND "READING" THE READ-DATA-REGISTER.)
;   SINCE DATA IS ACTUALLY FLOWING IN BOTH DIRECTIONS, NEGATIVE REGISTER
;   ADDRESSES ARE DECODED IDENTICALLY REGARDLESS OF WHICH WAY THE BUFFER
;   IS SET UP.


;BASIC COMMANDS:
; REGISTER EXAMINATION
;   /   TAKES AS ARG ADDRESS.  IF ITS A "NUMBER" IT IS RELOCATED BY
;	CURRENT DEFAULT MEMORY.  GOES TO APPROPRIATE EXAMINE ROUTINE
;	WHICH PRINTS CONTENTS OF INDICATED MEMORY.  THEN GOES TO
;	TO DEPOSIT ROUTINE WHICH GIVES USER AN OPPORTUNITY TO ALTER
;	REGISTER CONTENTS
;  <LF>	EXAMINE NEXT REGISTER
;  <UP ARROW> EXAMINE PREVIOUS
;  \    PROMPTS WITH MEM?  USER TYPES SYMBOLIC MEMORY DESIGNATOR.
;	RETURNS VALUE OF REGISTER ADDRESS OF BEGINNING OF SAID MEMORY.
;  ^S	STOP CONS.
;  ^N	STEP CONS (ARG # OF TIMES, NO ARG -> 1)
;  ^G   START CONS (AT LOCATION).  IF NO LOCATION, LAST SPECIFIED
;	IS USED.  IF LOCN IN CI MEM, CONSOLE COMPUTER ENTERS A LOOP
;	FEEDING THE CONTENTS OF CI MEMORY AT CONS.

;STATE SAVING
; THERE ARE TWO "MODES" IN WHICH THE STATE OF CONS CAN BE "SAVED".
;	"PASSIVE" MODE CONSISTS OF SAVING JUST WHAT CAN BE WITHOUT AFFECTING
;	  CONS IN ANY WAY. (IE THAT INFO THAT CAN BE DIRECTLY READ IN:
;		THE PC, IR, OUTPUT BUS, AND ERROR INDICATIONS).
;	  A PASSIVE SAVE CAN BE DONE WITH CONS RUNNING, ALTHO THE RESULTS ARE
;	  SOMEWHAT RANDOM OF COURSE.
;	"FULL" MODE SAVES THE A MEM 0 AND M MEM 0. IT ALSO DOES HAIR NECESSARY
;	  TO GET STARTED AGAIN RE THE IR. (SIMULATES OA HACKERY, REMEMBERS THE
;	  NO-OP BIT, ETC.)  AFTER A FULL SAVE HAS BEEN DONE, INTERNAL CONS
;	  REGISTERS CAN BE EXAMINED, MODIFIED, ETC. 
;	  THE PROCESS OF TAKING A FULL SAVE INVOLVES STOPPING CONS.
;  NORMALLY WHEN THE CONSOLE LOOP IS ENTERED, FIRST A PASSIVE SAVE IS DONE.
;      IF THAT SHOWS CONS STILL TO BE RUNNING, A FULL SAVE IS NOT DONE.
;      IF CONS IS NOT RUNNING, A FULL SAVE IS DONE IMMEDIATELY.
;  THE ^S COMMAND (STOP) WILL CAUSE A FULL SAVE TO BE DONE.


; LOW LEVEL "CLOCK TICKING"
;	MOST CONSOLE MONITOR COMMANDS ARE "HIGH LEVEL" IN THE SENSE THAT
;	IN ORDER TO EXECUTE THEM THE CONSOLE COMPUTER MUST GO THRU
;	A (FREQUENTLY FAIRLY ELABORATE) SERIES OF MACHINATIONS, INVOLVING
;	MANY CLOCK CYCLES ON CONS.  HOWEVER, A "LOW LEVEL" MODE
;       IS PROVIDED, WHICH ALLOWS THE USER TO DIRECTLY MANIPULATE THE MACHINE
;	WITHOUT ANYTHING "EXTRA" HAPPENING THE USER DOESNT EXPLICTLY
;	COMMAND. IN LOW LEVEL MODE, ONLY INFORMATION THE CONSOLE COMPUTER
;	CAN DETERMINE WITHOUT DISTURBING THE STATE OF CONS IS DISPLAYED.
;	(THIS CONSISTS OF THE PC, IR, OUTPUT BUS, AND ERROR INDICATIONS,
;	IE PASSIVE STATE SAVES.)

COMTAB:	CRTSPC		;0
	COMERR		;^A
	COMERR		;^B
	CRTSPC		;^C
	COMERR		;^D
	COMERR		;^E
	COMERR		;^F
	COMERR		;^G (BELL)
	QBS		;^H (BS)
	COMERR		;^I (TAB)
	QLF		;^J (LF)
	COMERR		;^K
	QFF		;^L (FF)
	CMCR		;^M (CR)
	QCN		;^N
	COMERR		;^O
	QCP		;^P
	COMERR		;^Q (MUST BE QUOTED)
	QCR		;^R
	QCS		;^S
	QCT		;^T
	COMERR		;^U
	COMERR		;^V
	COMERR		;^W
	COMERR		;^X
	COMERR		;^Y
	QCZ		;^Z (ZONK)
	COMERR		;ALT
	COMERR		;^\
	COMERR		;^]
	COMERR		;^^
	COMERR		;^_
	QPLS		;SPACE
	COMERR		;!
	COMERR		;"
	COMERR		;#
	COMERR		;$
	COMERR		;%
	QAMP		;&
	COMERR		;'
	COMERR		;(
	COMERR		;)
	COMERR		;*
	QPLS		;+
	COMERR		;,
	COMERR		;-
	COMERR		;.
	QSLSH		;/

	COMERR		;0 (MUST FOLLOW @ TO DISPATCH)
	QM1		;1
	QM2		;2
	COMERR		;3
	COMERR		;4
	COMERR		;5
	COMERR		;6
	COMERR		;7
	COMERR		;8
	COMERR		;9
	COMERR		;:
	COMERR		;;
	COMERR		;<
	QEQ		;=
	COMERR		;>
	COMERR		;?
	COMERR		;@
	QA		;A (MUST FOLLOW @ TO DISPATCH)
	COMERR		;B
	QC		;C
	QD		;D
	COMERR		;E
	COMERR		;F
	QG		;G
	COMERR		;H
	COMERR		;I
	COMERR		;J
	COMERR		;K
	COMERR		;L
	QM		;M
	COMERR		;N
	COMERR		;O
	QP		;P
	COMERR		;Q
	COMERR		;R
	COMERR		;S
	COMERR		;T
	QU		;U
	COMERR		;V
	COMERR		;W
	COMERR		;X
	COMERR		;Y
	COMERR		;Z
	COMERR		;[
	COMERR		;\
	COMERR		;]
	QUPAR		;^
	COMERR		;_
	COMERR		;`
	COMERR		;{
	COMERR		;|
	COMERR		;}
	COMERR		;~
RUBCOD=<.-COMTAB>/2		;MAPPED CODE FOR RUBOUT
	COMERR		;RUBOUT
.IFNZ <<.-COMTAB>/2>-200+32
	.PRINT \COMTAB LOSES\
.ENDC

QCS:
QDPSTP:	CLR CTRUN	;NO LONGER TRYING TO RUN
	JSR PC,QDPHLT
QCT1:;	CLR LMHTTY	;TAKE TTY AWAY FROM LISP MACHINE
	RTS PC

QDPHLT:	ESTOP		;STOP CONS  ^S
	JSR PC,ENTER	;DO FULL SAVE
	RTS PC

QCT:;	TST LMHTTY	;COMPLEMENT STATE OF LISP MACHINE HAVING TTY
;	BNE QCT1
;	ZAPFLG LMHTTY
	RTS PC

QA:	ADD #RAAMO,A	;ADDRESS A MEM
VALRET:	DEC CVALF	;INDICATE VALUE PRESENT
	RTS PC

QU:	ADD #RAUSO,A	;ADDRESS U STACK
	BR VALRET

QM:	ADD #RAMMO,A	;ADDRESS M MEM
	BR VALRET

QC:	ADD #RACMO,A	;ADDRESS MAIN CONTROL MEM
	BR VALRET

QP:	ADD #RAPBO,A	;ADDRESS PDL BUFFER
	BR VALRET

QD:	ADD #RADMO,A	;ADDRESS DISPATCH MEMORY
	BR VALRET

QM1:	ADD #RAM1O,A	;ADDRESS LVL 1 MAP
	BR VALRET

QM2:	ADD #RAM2O,A	;ADDRESS LVL 2 MAP
	BR VALRET

PCNSPT:	MOV CONSPT,A
	JSR PC,QPAD
	ETEXT
	ASCSLT		;SLASH TAB
	MOV CONSPT,A
	RTS PC

REGPNT:	PUSH A		;PRINT XXX/<CURRENT VAL>  WHERE XXX IS REG ADR
	JSR PC,QPAD
	ETEXT
	ASCSLH
	POP A
	PUSH REGOPF	;DONT AFFECT REGOPF
	MOV #QEXAMV,B
	MOV #-1,QEXPF	;WANT TO PRINT IT OUT
	JSR PC,REGDC
	TST CPOS
	BEQ REGPN2	;DONT PRINT SPACE AT BEG OF LINE
	ETEXT
	ASCSP		;PRINT SPACE
REGPN2:	POP REGOPF
	RTS PC

QUPAR:	JSR PC,REGCLS	;CLOSE REG BEFORE MODIFING PT
	DEC CONSPT	;UP ARROW (OR CARRET)
	BR QLF2

QLF:	JSR PC,REGCLS	;CLOSE REG BEFORE MODIFING PT
	INC CONSPT	;LF EXAMINE NEXT REGISTER
QLF2:	TST CPOS
	BEQ QLF1	;CR UNLESS AT BEG OF LINE
	ETEXT
	ASCCR
QLF1:	JSR PC,PCNSPT
	DEC CNUMF	;SIGNAL VALID ARG IN A
QSLSH:	JSR PC,QPTSET	;SET UP POINT (CONSPT)
	MOV #QEXAMV,B	;/ EXAMINE
	MOV #-1,QEXPF	;WANT TO PRINT IT OUT
	JSR PC,REGDC	;DECODE REGISTER ADDR IN A, DISPATCHING 
			;VIA VECTOR IN B
	MOV REGDEF,QBLMEX	;BASE OF LAST MEM EXAMINED
	RTS PC

QPTSET:	TST CNUMF
	BEQ QSLSH3	;NO ARG
	CMP A,#RAORG
	BGE QSLSH1	;REGISTER ADDR, OK
	ADD QBLMEX,A	;TRY EXAMINING WITHIN LAST MEM
	CMP A,#RAORG
	BLT QSLSH2	;STILL DIDNT WIN, WILL GO TO COMERR
QSLSH1:	MOV A,CONSPT	;LAST LOCN EXAMINED
QSLSH2:	RTS PC

QSLSH3:	MOV CONSPT,A
	RTS PC

.SBTTL REGISTER ADDRESS DEFS

RAORG==40000	; ORIGIN OF REGISTER ADDRESS SPACE
RACMO==40000	;   ORIGIN OF CONTROL MEM 
 RACME==50000	;   CONTROL MEMORY (C)  4K
RADMO==50000
 RADME==52000	;   DISPATCH MEMORY (D) 1K
RAPBO==52000
 RAPBE==54000	;   PDL BUFFER (P)	1024 REG
RAM1O==54000
 RAM1E==60000	;   MAP (1ST LEVEL)(1) 2048 REG (5 BITS EA)
RAM2O==60000
 RAM2E==62000	;   MAP (2ND LEVEL)(2) 1024 REG (20 BITS EA)
RAAMO==62000
 RAAME==62400	;   A MEMORY (A)	256 REG
RAUSO==62400
 RAUSE==62440	;   U STACK (U)		32 REG
RAMMO==62440
 RAMME==62500	;   M MEMORY (M)	32 REG
RAFSO==62500	;    NOTE: M MEM MUST BE CONTIG WITH FUNCT SRC
 RAFSE==62540	;   FUNCTIONAL SOURCES  32 REGS
RAFDO==62540	;   FUNCTIONAL DESTINATIONS 16 REG
 RAFDE==62560
   RAMWD==RAFDO+CFDMWD	;MAIN MEM WRITE DATA REGISTER
   RAVMA==RAFDO+CFDVMA	;VMA (VIRTUAL MEMORY ADDRESS)
   RAPP==RAFDO+CFDPP	;PDL POINTER (TO PDL BUFFER)
   RAPI==RAFDO+CFDPI	;PDL INDEX (TO PDL BUFFER)
		;   MICROPROCESSOR REGISTERS  
RARGO==62560	;   INTERNAL (COPY OF) REGISTER SECTION
 RARGE==62600	;    (OR IN SOME CASES, THESE REQUIRE SPECIAL ACCESS FOR
		;      "HARWARE" REASONS)
RAPC==62560	;     PC  (PC)
RAUSP==62561	;     U STACK POINTER  (USP)
RAIR==62562	;     .IR (PUT IN DIAG INST REG, THEN LOAD INTO IR, THEN 
		;	  UPDATE OBUS DISPLAY. DIAGNOSTIC ONLY)
RASIR==62563	;     SAVED IR (THE ONE SAVE ON FULL STATE SAVE
		;      AND RESTORED ON FULL RESTORE)
		;      THIS IS NORMALLY THE UINST ABOUT TO GET EXECUTED.
RAQ==62564	;     Q REGISTER  (Q)
RADC==62565	;     DISPATCH CONSTANT REGISTER (DC)
RARSET==62566	;     RESET REGISTER!  DEPOSITING HERE
		;       CLEARS ENTIRE C, D, P, M1, M2, A, U AND
		;	M MEMORIES!
RASTS==62567	;     STATUS REGISTER (32 BIT, AS READ BY ERERWS)
RAOBS==62570	;     OUTPUT BUS STATUS (32 BITS)
;THE FOLLOWING REGISTERS MAKE VARIOUS FUNCTIONS AVAILABLE TO THE PDP-10
;  WHICH ARE OTHERWISE ACCESSIBLE ONLY BY TYPIN.
RARS==  62571	;     RESET (CNTRL-R)
RASTEP==62572	;     STEP (CNTRL-N)
RASTOP==62573	;     STOP (CNTRL-S)
RASA==  62574	;     SET STARTING ADR (@G)
RAGO==  62575	;     GO (CNTRL-P, BUT KEEP LISTENING)
		;      WHEN EXAMINED, RETURN STATE OF CTRUN.
RAMOD== 62576	;MODE REGISTER, BIT 1.1 => RUN SLOW, BIT 1.2 => DON'T HALT IF ERROR
		; ZERO IS THE NORMAL DEFAULT VALUE FOR THIS REG
RARCON==62577	;REMOTE CONSOLE, DEPOSIT = TYI, EXAMINE = TYO

	; BUFFERS WITHIN THE CONSOLE COMPUTER
RACSWO==62600	;  MODE SWITCHES (CLLMOD, ETC)
 RACSWE==62620
RARDRO==62620	;  "RAID" REGISTERS (RAIDR)
 RARDRE==62630
RACIBO==62630
 RACIBE==62640	;  CONSOLE INST BUFFER (CI)   8 REG
		;   (EA HOLDS A U INST. CAN BE SENT TO CONS VIA DIB IN A LOOP)

RACMFO==62640	;  MAIN MEMORY FUNCTION REGISTERS
 RACVMR==62640	;    VIRTUAL MEMORY (ADDRESS), INITIATE READ
 RACRDR==62641	;    CONSOLE MEMORY READ DATA (LAST READ BY RACVMR OR RACPMR)
 RACPMR==62642	;    PHYSICAL MEMORY, INITIATE READ
		; 62643 IS ANOTHER ADDRESS FOR 62642 (FOR LINE-FEEDING CONVENIENCE)
 RACMWD==62644	;    CONSOLE MEMORY WRITE DATA REGISTER
 RACVMW==62645	;    VIRTUAL MEMORY, INITIATE WRITE
		; 62646 IS ANOTHER ADDRESS FOR 62645
 RACPMW==62647	;    PHYSICAL MEMORY, INITIATE WRITE
RACMFE==62650

RAOPCO==62650	;8 OLD PC REGISTERS
RAOPCE==62660



; IN ADDITION, THE CONSOLE PROGRAM KNOWS SOME ABOUT THE FOLLOWING, BUT
;  THEY OBVIOUSLY DONT FIT INTO THE 16 BIT ADDRESS SCHEME:

;   MAIN MEMORY VIRTUAL ADDRESS -  23 BITS
;   MAIN MEMORY PHYSICAL ADDRESS - 20 BITS

; TELETYPE KLUDGE

;RATYI==RAAMO+40	;SET BY 11, CLEARED BY LM
;RATYO==RAAMO+3	;SET BY LM, CLEARED BY 11

.SBTTL REGISTER ADDRESS DECODER

REGDC:			;DECODE REGISTER ADDR IN A, VECTOR IN B
	MOV #REGATL,C		;ADDRESS TABLE
REGDCL: CMP A,(C)
	BHIS REGDC1		;HIGHER THAN THAT
	MOV -(C),REGDEF		;BASE OF LAST MEM ADDRESSED
	SUB (C),A		;LEAVE RELATIVE ADDR WITHIN MEM IN B
	MOV B,C
	MOV A,B
	MOV #QEXB,A
	JMP @(C)		;FOUND IT, GO TO CORRESPONDING PLACE IN GIVEN VECTOR

REGDC1:	TST (B)+
	TST (C)+
	CMP C,#REGATE
	BLO REGDCL
	JMP COMERR		;OFF END, TOO HIGH

REGDEF:	0	;BASE OF LAST MEM SUCCESSFULLY ADDRESSED
QBLMEX:	0	;BASE OF LAST MEM EXAMINED (WITH /, ETC)
QEXPF:	0	;EXAMINE PRINT FLAG. IF -1 EXAMINE ROUTINE
		; PRINTS DATA. OTHERWISE, IT RETURNS WITH
		; POINTER TO DATA IN A, AND FIELD SPEC IN B

	0	;MUST BE HERE
REGATL:	RACMO	;TOO LOW ..
REGATH:	RACME	;CONTROL MEM
	RADME	;DISPATCH MEM
	RAPBE	;PDL BUFFER
	RAM1E	;1ST LVL MAP
	RAM2E	;2ND LVL MAP
	RAAME	;A MEM
	RAUSE	;U STACK
	RAMME	;M MEM
	RAFSE	;FUNCTIONAL SOURCES
	RAFDE	;FUNCTIONAL DESTINATIONS
	RARGE	;CONSOLE COMPUTER REGS
	RACSWE	;CONSOLE COMPUTER MODES AND SWITCHES
	RARDRE	;RAID REGISTERS
	RACIBE	;CONSOLE COMPUTER INST BUFFER
	RACMFE	;MAIN MEMORY FUNCTION REGISTERS
	RAOPCE	;OLD PCS
REGATE==.	;TOP

.SBTTL EXAMINATION ROUTINES

;IF QEXPF = -1, EXAMINE AND PRINT FROB
;OTHERWISE, RETURN WITH A POINTING TO DATA AND B A FIELD SPEC
QEXAMV:	COMERR	;TOO LOW
	QEXC	;CONTROL MEM
	QEXD	;DISPATCH MEM
	QEXPB	;PDL BUFFER
	QEX1MP	;1ST LVL MAP
	QEX2MP	;2ND LVL MAP
	QEXA	;A MEM
	QEXUS	;U STACK
	QEXM	;M MEM
	QEXFS	;FUNCTIONAL SOURCES
	QEXFD	;FUNCTIONAL DESTINATIONS
	QEXCON	;CONSOLE COMPUTER REGS
	QEXSW	;CONSOLE COMPUTER MODES AND SWITCHES
	QEXRDR	;RAID REGISTERS
	QEXCIB	;CONSOLE COMPUTER INST BUFFER
	QEXMMF	;MAIN MEMORY FUNCTION REGISTERS
	QEXOPC	;OLD PCS
	COMERR	;TOO HI

QEXCIB:	JSR PC,QEXCI1		;GET BUFFER ADR IN C
QEXSI1:	MOV A,B			;PLACE WE WANT TO STORE IT
	MOV (C)+,(B)+		;STORE THREE WDS WORTH
	MOV (C)+,(B)+
	MOV (C),(B)
	BR QEXIR1

QEXCI1:	MOV B,C			;EXAMINE CONSOLE INST BUFFER (COMPUTE ADR IN C)
	ASL C			;3 WDS PER ENTRY
	ADD B,C
	ASL C			;CONVERT TO WORDS
	ADD #CIBUF,C
	RTS PC

QEXC:	EEXAMC			;EXAMINE CONTROL MEM
QEXIR1:	MOV #<<44.*400>+0>,B
	TST QEXPF
	BEQ QEXCX
	EPI
CRLF:	ETEXT
	ASCCR
QEXCX:	RTS PC

QEXFD:	EWMEMS			;ASSURE VMA AND MWD VALID
	MOV B,C			;FUNCTIONAL DESTINATIONS
	MOV #CMSMWD,B		; TRY TO TURN INTO RIGHT THING
	CMP C,#CFDMMW
	BLE QEXM		;MAIN WRITE MEMORY DATA
	MOV #CMSVMA,B		;VMA SOURCE
	CMP C,#CFDVWM
	BLE QEXM		;EXAMINE VMA IN VARIOUS FORMS
	MOV #CMSCP,B		;PDL (POINTER)
	CMP C,#CFDCPP
	BLE QEXM
	MOV #CMSCI,B		;PDL (INDEX)
	CMP C,#CFDCI
	BLE QEXM
	CMP C,#CFDPP
	BLE QEXPPI		;EXAMINE PDL INDEX OR PDL POINTER
	JMP COMERR		;THATS AS MUCH AS WE FEEL LIKE..

QEXOPC:	ASL B
	MOV OLDPCS(B),(A)
	JMP QEXPC0

QEXPPI:	PUSH C			;EX PDL INDEX OR PDL POINTER
	MOV #CMSPPI,B
	EEXAMD			;EXAMINE BOTH
	POP C
	CMP C,#CFDPI
	BEQ QEXPP1		;EX PDL INDEX, ITS IN LOW PART
	PUSH A			;EX PDL POINTER, ITS IN HIGH
	MOV #<<10.*400>+10.>,B	; PART
	EXFLD
	MOV A,@(SP)
	POP A
QEXPP1:	BIC #176000,(A)
	CLR 2(A)
	MOV #<<10.*400>+0>,B
	BR QEXPC1

QEXD:	ERDSP			;EXAMINE DISPATCH MEM
	MOV #<<16.*400>+0>,B
	BR QEXPC1

QEXFS:	EWMEMS			;ASSURE VMA AND MWD VALID
	ADD #40,B		;EXAMINE FUNCT SOURCES
	BR QEXM			; (TURN INTO M SOURCE)

QEXA1:	MOV CAMEM1,(A)
	MOV CAMEM1+2,2(A)
	BR QEXPB1

QEXM0:	MOV CMMEM0,(A)
	MOV CMMEM0+2,2(A)
	BR QEXPB1

QEXA:	CMP B,#1
	BEQ QEXA1		;USE SAVED A MEM 1
	BIS #CDAMEM,B		;EXAMINE A MEM
QEXM:	TST B			;EXAMINE M MEM
	BEQ QEXM0		;USE SAVED M MEM 0
	EEXAMD
QEXPB1:	MOV #<<32.*400>+0>,B	;FIELD DESCRIPTION
QEXPC1:	TST QEXPF
	BEQ QEXMX		;JUST WANT TO FETCH DATA
	DEC REGOPF
	IPNFLD
QEXMX:	RTS PC

QEXQ:	MOV #CMSQ,B		;EXAMINE Q
	BR QEXM

QEXPB:	ERPDLB			;EXAMINE PDL BUFFER
	BR QEXPB1

QEXRDR:	ASL B			;EXAMINE RAID REGISTER
	MOV B,C
	MOV RAIDA(C),(A)
	MOV #<<16.*400>+0>,B
	TST QEXPF
	BEQ QEXRDX
	MOV (A),A
	BEQ QEXRD1		;0 IS NULL
	JSR PC,QPAD		;PRINT IT AS ADDRESS
QEXRST:				;GET HERE TO "OPEN" RESET REGISTER
QEXRD1:	ETEXT
	ASCSP
	DEC REGOPF
QEXRDX:	RTS PC

QEXSW:	MOV B,C
	ASL C
	MOV CSSWO(C),(A)
	MOV #<<3.*400>+0>,B	;EXAMINE SWITCH (PRINT ONE DIGIT)
	BR QEXPC1

QEX1MP:	TST B
	BEQ QEX1M1
	ERL1MP			;EXAMINE 1ST LVL MAP
QEX1M2:	MOV #<<5*400>+0>,B
	BR QEXPC1

QEX1M1:	MOV CL1M0,(A)		;LOCN 0 SAVED AWAY SPECIALLY
	BR QEX1M2

QEX2MP:	TST B
	BEQ QEX2M1
	ERL2MP			;EXAMINE 2ND LVL MAP
QEX2M2:	MOV #<<20.*400>+0>,B
	BR QEXPC1

QEX2M1:	MOV CL2M0,(A)		;LOCN 0 SAVED AWAY SPECIALLY
	MOV CL2M0+2,2(A)
	BR QEX2M2

QEXSTS:	MOV CCERR1,(A)		;EXAMINE SAVED ERROR STATUS
	MOV CCERR2,2(A)
	BR QEXPB1

QEXOBS:	MOV COBUS,(A)		;EXAMINE SAVED OBUS STATUS
	MOV COBUS+2,2(A)
	BR QEXPB1

QEXNL:	CLR B			;"NULL" EXAMINE
	RTS PC

QEXGO:	MOV CTRUN,(A)		;RETURN STATE OF WHETHER TRYING TO RUN OR NOT
QEX1WD:	CLR 2(A)
	MOV #<<16.*400>+0>,B
	JMP QEXPC1

QEXMOD:	MOV MODREG,(A)		;EXAMINE MODE REGISTER AS LAST SET
	BR QEX1WD

QEXRCN:	CLR (A)			;REMOTE CONSOLE EXAMINE, 0 OR CHAR BEING TYO'ED
	TST CTRUN
	BEQ QEX1WD
;;	tyo wait loop in CONS
;;	((M-GARBAGE) A-TYO IR-FLAG-TO-11)
;;	(JUMP A-ZERO M-ZERO .-1 IR-FLAG-TO-11)
;;	((M-GARBAGE) M-ZERO IR-FLAG-TO-11)
;;--ALSO SEE TYO HACKER AT QCN2
	BIT 164010,#4000	;IR43
	BEQ QEX1WD
	MOV #0,164006		;STOP CONS
	MOV #100,B
2$:	MOV 164004,(A)		;LOW 16 BITS OF OBUS
	BNE 3$
	JSR PC,XCLK
	DEC B
	BGT 2$
	CLR (A)		;SOMETHING SCREWED, EITHER ITS TYPING OUT RANDOMNESS OR NOT REALLY
	BR QEX1WD	;IN RIGHT LOOP. AT LEAST DONT HANG UP.

3$:	JSR PC,XNCLK		;CLOCK PAST FIRST ALU INST
	JSR PC,XNCLK		;CLOCK PAST JUMP, NO-OP ING IT
	MOV #1,164006		; START 'ER UP
	BR QEX1WD

QEXCON:	ASL B	;EXAMINE CONSOLE COMPUTER REGS
	CMP B,#QEXCVL
	BHIS QEXCER
	JMP @QEXCT(B)

QEXCER:	JMP COMERR

QEXCT:	QEXPC			;EXAMINE PC
	QEXUSP			;U STACK POINTER
	QEXIR			;HARDWARE IR
	QEXSIR			;SAVED IR
	QEXQ			;EXAMINE Q
	QEXDC			;EXAMINE DISPATCH CONSTANT
	QEXRST			;RESET REGISTER (JUST "OPEN" IT)
	QEXSTS			;EXAMINE STATUS REGISTER
	QEXOBS			;EXAMINE O-BUS STATUS
	QEXNL			;RESET FUNCTION
	QEXNL			;STEP FUNCTION
	QEXNL			;STOP FUNCTION
	QEXPC			;EXAMINE STARTING ADR
	QEXGO			;GO FUNCTION (RETURN CTRUN)
	QEXMOD			;MODE REGISTER
	QEXRCN			;REMOTE CONSOLE
QEXCVL==.-QEXCT


QEXUS:	PUSH A
	PUSH B			;EXAMINE U STACK
	ESUSTK
	POP B
	POP A
	ASL B
	MOV USSVD(B),(A)
	MOV #<<16.*400>+0>,B
	BR QEXPC2

QEXUSP:	PUSH A
	ESUSTK			;EXAMINE U STACK POINTER
	POP A
	MOV USTPNR,(A)
	MOV #<<5.*400>+0>,B
	BR QEXPC2

QEXPC:	MOV CPC,(A)
QEXPC0:	MOV #<<12.*400>+0>,B
	BR QEXPC2

QEXDC:	ERDSPC			;EXAMINE DISPATCH CONSTANT
	MOV #<<8*400>+0>,B
QEXPC2:	JMP QEXPC1

QEXIR:	ERIR
	JMP QEXIR1

QEXSIR:	MOV #CIR,C
	JMP QEXSI1

QEXMMF:	ASL B			;MAIN MEMORY FUNCTIONS
	JMP @QEMMFT(B)

QEMMFT:	QECVMR			;EXAMINE CONSOLE VIRTUAL ADDRESS REGISTER
	QECVRD			;EXAMINE CONSOLE READ DATA
	QECVMR			;EXAMINE CONSOLE PHYSICAL ADR REGISTER
	QECVRD			;EXAMINE CONSOLE READ DATA
	QECVWD			;EXAMINE CONSOLE VIRTUAL WRITE DATA REGISTER
	QECVMR			;EXAMINE CONSOLE VIRTUAL ADR REGISTER
	QECVWD			;EXAMINE CONSOLE VIRTUAL WRITE DATA REGISTER
	QECVMR			;EXAMINE CONSOLE VIRTUAL ADR REGISTER

QECVMR:	MOV CVMVMA,(A)		;EXAMINE CONSOLE VIRTUAL ADR REGISTER
	MOV CVMVMA+2,2(A)
QEXPB2:	JMP QEXPB1		;OUT OF RANGE, LOSE LOSE

QECVRD:	MOV CVMMRD,(A)		;EXAMINE CONSOLE READ DATA REGISTER
	MOV CVMMRD+2,2(A)
	MOV CVMMPF,4(A)		;HIGH WORD FAULT STATUS
	BR QEXPB2

QECVWD:	MOV CVMMWD,(A)		;EXAMINE CONSOLE WRITE DATA REGISTER
	MOV CVMMWD+2,2(A)
	BR QEXPB2

QEXB:	0			;TEMP BLOCK FOR EXAMINING FCTNS
	0
	0


.SBTTL DEPOSITATION ROUTINES

QDEPV:	COMERR	;TOO LOW ..
	QDPC	;CONTROL MEM (NUMERIC STYLE)
	QDPD	;DISPATCH MEM
	QDPPB	;PDL BUFFER
	QDP1MP	;1ST LVL MAP
	QDP2MP	;2ND LVL MAP
	QDPA	;A MEM
	QDPUS	;U STACK
	QDPM	;M MEM
	COMERR	;FUNCTIONAL SOURCES
	QDPFD	;FUNCTIONAL DESTINATIONS
	QDPCON	;CONSOLE COMPUTER REGS
	QDPSW	;CONSOLE COMPUTER MODES AND SWITCHES
	QDPRDR	;RAID REGISTERS
	COMERR	;CONSOLE COMPUTER INST BUFFER
	QDPMMF	;MAIN MEMORY FUNCTION REGISTERS
	COMERR	;OLD PCS
	COMERR	;TOO HI

QDPD:	MOV #CNUM,A		;DEPOSIT IN DISPATCH MEM
	EWDSP
	BR QDPXIT

QDPFD:	SWAB B	;DEPOSIT IN FUNCT DEST
	ASR B	; (ALSO CLOBBERS M MEM 0 BUT THAT DOESNT HURT)
	ASR B
	ASR B
	EWMEMS	;ASSURE VMA AND MWD VALID
	JSR PC,QDPM		;DO STUFF
	ERMEMS	;READ THEM AGAIN AS THEY MAY HAVE CHANGED
	RTS PC

QDPA1:	MOV #CAMEM1,A		;DEPOSIT IN A MEM 1
QDPM1:	MOV CNUM,(A)+
	MOV CNUM+2,(A)
	BR QDPXIT

QDPM0:	MOV #CMMEM0,A		;DEPOSIT IN M MEM 0
	BR QDPM1

QDPA:	CMP B,#1
	BEQ QDPA1		;DEPOSIT IN A MEM 1
	BIS #CDAMEM,B		;DEPOSIT IN A MEM
QDPM:	TST B
	BEQ QDPM0
	CMP B,#1		;WRITING 1@M CLOBBERS 1@A
	BNE 1$
	MOV CNUM,CAMEM1
	MOV CNUM+2,CAMEM1+2
1$:	MOV #CNUM,A		;DEPOSIT IN M MEM
	EDMM0
QDPXIT:	DEC DEPFLG		;SIGNAL DEPOSIT DONE
	RTS PC

QDPPB:	MOV #CNUM,A		;DEPOSIT IN PDL BUFFER
	EWPDLB
	BR QDPXIT

QDPRDR:	ASL B			;DEPOSIT IN RAID REGISTER
	ADD #RAIDA,B
	BR QDPRD1

QDPSW:	ASL B
	ADD #CSSWO,B		;DEPOSIT IN CONSOLE COMPUTER SWITCH
QDPRD1:	MOV CNUM,(B)
	BR QDPXIT

REGCLS:	TST REGOPF		;CLOSE OPEN REGISTER
	BEQ REGCLX		;NO REG OPEN
	TST CNUMF
	BEQ REGCLX		;NO NUMBER TYPED
	MOV CONSPT,A
	MOV #QDEPV,B
	JSR PC,REGDC
REGCLX:	RTS PC

QDP1MP:	MOV #CNUM,A
	TST B
	BEQ QDP1M1
	EWL1MP			;DEPOSIT IN LVL 1 MAP
	BR QDPXIT

QDP1M1:	MOV (A),CL1M0		;HACK LOCN 0 SPECIALLY
	MOV #1,CL1M0F
	BR QDPXIT

QDP2MP:	MOV #CNUM,A
	TST B
	BEQ QDP2M1
	EWL2MP			;DEPOSIT IN LVL 2 MAP
	BR QDPXIT

QDP2M1:	MOV (A),CL2M0
	MOV 2(A),CL2M0+2
	MOV #1,CL2M0F
	BR QDPXIT

QDPCON:	ASL B			;DEPOSIT IN CONSOLE COMPUTER REGS
	CMP B,#QDPVL
	BHIS QDPCER
	JMP @QDPCV(B)

QDPCER:	JMP COMERR

QDPCV:	QDPPC			;DEPOSIT IN PC
	QDPUSP			;DEPOSIT IN U STACK POINTER
	COMERR			;DEPOSIT IN HARDWARE IR
	COMERR			;DEPOSIT IN SAVED IR
	QDPQ			;DEPOSIT IN Q
	QDPDC			;DEPOSIT IN DISPATCH CONSTANT REGISTER
	QDPRST			;DEPOSIT IN RESET REGISTER (ZAP)
	COMERR			;STATUS REGISTER
	COMERR			;O-BUS STATUS
	QDPRS			;RESET FUNCTION
	QDPSTE			;STEP FUNCTION
	QDPSTP			;STOP FUNCTION
	QDPSA			;SET STARTING ADR
	QDPGO			;GO FUNCTION
	QDPMOD			;MODE REGISTER
	QDPRCN			;REMOTE CONSOLE
QDPVL==.-QDPCV

QDPUS:	PUSH B			;DEPOSIT IN U STACK
	ESUSTK
	POP B
	ASL B
	ADD #USSVD,B
	MOV CNUM,(B)
	BR QDPXIT

QDPUSP:	ESUSTK			;DEPOSIT IN U STACK POINTER
	MOV CNUM,USTPNR
	BIC #177740,USTPNR
	BR QDPXIT

QG:
QDPSA:	MOV #1,NOOPF		;NO OP PRESENT CONTENTS OF IR
QDPPC:	MOV CNUM,CPC
	BIC #170000,CPC
	BR QDPXIT

QDPQ:	MOV #CSDQ,B		;DEPOSIT IN Q REGISTER
	BR QDPM			; ("PSEUDO" DEST Q)

QDPDC:	MOV #CNUM,A		;DEPOSIT IN DISPATCH CONSTANT REGISTER
	EWDSPC
	BR QDPXIT

QDPRST:	ERESET			;RESET MISC STATE
	MOV #RACMO,QDPRC	;CLEAR ALL MEMORIES!!
QDPR1:	MOV #QDEPV,B		;START OFF WITH CONTROL MEM
	MOV QDPRC,A
	CMP A,#RAMME
	BHIS QDPXIT
	JSR PC,REGDC
	INC QDPRC
	BR QDPR1

QDPRC:	0

QDPMMF:	MOV #CNUM,A
	ASL B			;MAIN MEMORY FUNCTION REGISTERS
	JMP @QDMMFT(B)

QDMMFT:	QDCVMR			;CONSOLE VIRTUAL ADDRESS REGISTER, INITIATE READ
	QDCVRD			;CONSOLE VIRTUAL READ DATA REGISTER
	QDCPMR			;CONSOLE PHYSICAL ADDRESS REGISTER, INITIATE READ
	QDCVRD			;CONSOLE VIRTUAL READ DATA REGISTER
	QDCMWD			;CONSOLE VIRTUAL WRITE DATA REGISTER
	QDCVWD			;CONSOLE VIRTUAL ADDRESS REGISTER, INITIATE WRITE
	QDCMWD			;CONSOLE VIRTUAL WRITE DATA REGISTER
	QDCPWD			;CONSOLE PHYSICAL ADDRESS REGISTER, INITIATE WRITE.

QDCVMR:	MOV (A)+,CVMVMA		;DEPOSIT IN CONSOLE VMA, INITIATE READ
	MOV (A),CVMVMA+2
	EVMEMS			;"VALIDIFY" MEM SUBROUTINE
	MOV #CVMVMA,A
	MOV #<CFDVMR_5>,B
	EDMM0			;START READ
QDCVM1:	INC CSMRDF		;HACKING WITH "REAL" READ DATA REG
	JSR PC,QCVFLT		;CHECK FOR PAGE FAULT
	MOV #CVMMRD,A		;UPDATE CONSOLE READ DATA REG
	MOV #CMSMMD,B
	EEXAMD
QDPXI1:	JMP QDPXIT		;OUT OF RANGE, LOSE LOSE

QCVFLT:	CLR CVMMPF		;ASSUME NO FAULT
	MOV #QEXB,A		;CHECK FOR FAULT
	MOV #CMSPMD,B
	EEXAMD
	BIT #3,(A)
	BEQ 1$
	INC CVMMPF		;FAULT PRESENT
1$:	RTS PC

QDCVRD:	MOV (A)+,CVMMRD		;DEPOSIT IN CONSOLE VIRTUAL MEM DATA REGISTER
	MOV (A),CVMMRD+2	; (TOTALLY RANDOM OPERATION)
	BR QDPXI1

QDCPMR:	MOV (A)+,CVMVMA		;LOAD CONSOLE "PHYSICAL" VMA
	MOV (A),CVMVMA+2
	MOV #CVMVMA,A
	EWPVMA			;LOAD "PHYSICAL" VMA
	EMMRC			;START READ CYCLE
	BR QDCVM1		;UPDATE CONSOLE READ DATA REG

QDCMWD:	MOV (A)+,CVMMWD		;WRITE CONSOLE MEMORY WRITE DATA REG
	MOV (A),CVMMWD+2
	BR QDPXI1

QDCVWD:	MOV (A)+,CVMVMA		;DEPOSIT IN CONSOLE VMA, START WRITE
	MOV (A),CVMVMA+2
	EVMEMS			;GET BACK EVERYTHING (SAVED MAP, ETC)
	MOV #CVMMWD,A
	MOV #<CFDMWD_5>,B
	EDMM0			;LOAD MWD WITH CONSOLE MWD
	MOV #CVMVMA,A
	MOV #<CFDVMW_5>,B
	EDMM0			;DO VMA START WRITE
	JSR PC,QCVFLT		;CHECK FOR FAULT
	BR QDPXI1	

QDCPWD: MOV (A)+,CVMVMA		;LOAD CONSOLE "PHYSICAL" VMA, START WRITE
	MOV (A),CVMVMA+2
	MOV #CVMVMA,A
	EWPVMA			;LOAD "PHYSICAL" VMA
	MOV #CVMMWD,A
	MOV #<CFDMWD_5>,B
	EDMM0			;LOAD MWD WITH CONSOLE MWD
	EMMWC			;START WRITE CYCLE
	BR QDPXI1


.SBTTL FUNNY-FORMAT TYPE-IN

QBS:	JSR PC,QPTSET
	TST CNUMF
	BLT QBS1
	JSR PC,PCNSPT
QBS1:	MOV #QTIVEC,B		;TYPE IN FUNNY FORMATS
	JSR PC,REGDC
	JMP CRLF


;TYPE IN VECTOR FOR FUNNY FORMAT TYPE INS
QTIVEC:	COMERR	;TOO LOW, TRY LAST MEM
	QUICM	;CONTROL MEMORY
	COMERR	;DISPATCH MEM
	COMERR	;PDL BUFFER
	COMERR	;1ST LVL MAP
	COMERR	;2ND LVL MAP
	COMERR	;A MEM
	COMERR	;U STACK
	COMERR	;M MEM
	COMERR	;FUNCTIONAL SOURCES
	COMERR	;FUNCTIONAL DESTINATIONS
	QUICR	;CONSOLE COMPUTER REGS
	COMERR	;CONSOLE COMPUTER MODES AND SWITCHES
	COMERR	;RAID REGISTERS
	QUICIB	;CONSOLE COMPUTER INST BUFFER
	COMERR	;MAIN MEMORY FUNCTION REGISTERS
	COMERR	;OLD PCS
	COMERR	;TOO HI

QUICIB:	JSR PC,QEXCI1		;DEPOSIT IN CONSOLE INST BUFFER
	MOV C,A
	JSR PC,QUTYI
	BR QUIXIT

QDPC:	MOV #CNUM,A		;DO NUMERIC STYLE DEPOSIT
	BR QDPC1

QUICM:	EEXAMC			;GET CURRENT CONTENTS FOR DEFAULTING
	PUSH B			;DEPOSIT IN CONTROL MEM
	JSR PC,QUTYI
	POP B
QDPC1:	EDCMEM
QUIXIT:	DEC DEPFLG
	RTS PC

QUICR:	ASL B			;SPECIAL DEPOSIT IN CONSOLE REG
	CMP B,#QUIVL
	BHIS QUIVER
	JMP @QUIVC(B)

QUIVER:	JMP COMERR

QUIVC:	COMERR			;DEPOSIT IN PC
	COMERR			;DEPOSIT IN U STACK POINTER
	QUIIR			;DEPOSIT IN HARDWARE IR
	QUISIR			;DEPOSIT IN SAVED IR
	COMERR			;DEPOSIT IN Q
	COMERR			;DEPOSIT IN DISPATCH CONSTANT
	COMERR			;DEPOSIT IN RESET REGISTER
	COMERR			;STATUS REGISTER
	COMERR			;O-BUS STATUS
	COMERR			;RESET FUNCTION
	COMERR			;STEP FUNCTION
	COMERR			;STOP FUNCTION
	COMERR			;SET STARTING ADR
	COMERR			;GO FUNCTION
QUIVL==.-QUIVC

QUIIR:	ERIR			;READ IN CURRENT IR FOR DEFAULT
	JSR PC,QUTYI		;READ IN U INST
	EWIR			;PUT IN IR
	MOV #COBUS,A		;READ IN NEW O BUS
	EROBUS
	BR QUIXIT

QUISIR:	MOV #CIR,A
	JSR PC,QUTYI
	BR QUIXIT
	

;U INST TYPEIN -- 
; THERE ARE TWO ROUTINES ASSOCIATED WITH EA FIELD, A PROMPT
;  GENERATING FIELD AND A DEPOSITING FIELD.
; AT EACH STAGE OF THE GAME THE USER IS PROMPT ED BY SOME
;  PROMPT ROUTINE. IF HE TYPES A NUMBER, THAT NUMBER IS FED
;  TO THE APPROPRIATE DEPOSIT ROUTINE.  IF HE TYPES A SYMBOL,
;  IT IS LOOKED UP IN A TABLE. IF NOT FOUND, ERROR.
;  IF IT IS FOUND, IT SPECIFIES A TRANSFER ADDRESS AND A 
;  VALUE.  THE TRANSFER ADDRESS MAY BE EITHER A PROMPT OR
;  A DEPOSIT ROUTINE. IF A PROMPT, THE ARG (FROM THE SYMBOL
;  TABLE) IS IGNORED. IF A DEPOSIT, IT GETS DEPOSITED!!
; EACH DEPOSIT ROUTINE FALLS THRU INTO AN "APPROPRIATE"
; PROMPT ROUTINE.  CR AS A TERMINATOR, STOPS PROMPTING AND
; DEPOSITS! RUBOUT FLUSHES CURRENT COMMAND (U CAN TRY AGAIN IF
; YOU WANT).  ^G QUITS OUT OF ENTIRE THING. SPACE ADVANCES
; TO THE NEXT PROMPT ROUTINE.

QUTYI:	CLR QIFCRT		;POINTER TO QEXB IN A
QPUOP:	ETEXT			;TYPE IN U INST
	ASCTOP			;TYPE TAB OP<SPC>
	JSR PC,QIFLD		;GOBBLE FIELD. IF SYMBOLIC, ZAP
	BR QDUOP1		;SPACE LEAVE OP AND REST 
				;THE SAME TO START WITH
QDUOP:	EICLR			;INTIALIZE STUFF
	MOV #<<2*400>+47>,C
	EDPB
	TST B
	BNE QDUOP1
	BIS #1_14,(A)		;ALU OP, DEFAULT ALU OUTPUT BUS
QDUOP1:
QPAS:	ETEXT			;A SOURCE (D C FOR DSP)
	ASCA
	JSR PC,QIFLD
	BR QPMS
QDAS:	EDASRC
QPMS:	ETEXT			;M SOURCE (ALL INSTS)
	ASCM
	JSR PC,QIFLD
	BR QPDD
	EDMSRC
QPDD:	MOV 4(A),B
	ASL B
	ASL B
	SWAB B
	BIC #177771,B
	JMP @QPDDT(B)

QPDDT:	QPDSTA			;ALU TAKES DEST
	QPDIS			;DISPATCH PROMPT SEQ
	QPJMP			;JMP PROMPT SEQ
	QPDSTA			;BYT TAKES DEST


QPDSTM:	ETEXT			;DESTINATION M
	ASCDM
	JSR PC,QIFLD
	BR QPDSTR
	EDMDST			;DEPOSIT IN M PART OF DESTINATION
QPDSTR:	ETEXT			;DESTINATION REGISTER/FUNCTION
	ASCDR
	JSR PC,QIFLD
	BR QPAOB
	EDRDST			;DEPOSIT IN R PART OF DEST
	BR QPAOB

QPDSTA:	ETEXT			;DESTINATION A
	ASCDA
	JSR PC,QIFLD
	BR QPDSTM
	BIS #CDAMEM,B
	EDDEST
QPAOB:	MOV 4(A),B
	BIC #177177,B
	BNE QPBYT		;BYTE PROMPT SEQ
QPALU:	ETEXT			;ALU PROMPT SEQ
	ASCALU
	JSR PC,QIFLD
	BR QPCRYC
	EDALUF
QPCRYC:	ETEXT
	ASCCRY
	JSR PC,QIFLD
	BR QPQC
	MOV #<<2*400>+2>,C
	EDPB
QPQC:	ETEXT
	ASCQC
	JSR PC,QIFLD
	BR QPMF
	MOV #<<2*400>+0>,C
	EDPB
QPMF:	ETEXT
	ASCMF
	JSR PC,QIFLD
	BR QPILG
	MOV #<<2*400>+12>,C
	EDPB
QPILG:	ETEXT
	 ASCILG
	JSR PC,QIFLD
	 BR QTIDEP
	MOV #<<1*400>+41.>,C
	EDPB
QTIDEP:	RTS PC			;RETURN FROM U INST TYPE IN 
				;U INST IN QEXB

QPBYT:	ETEXT		;BYTE PROMPT SEQ
	ASCMD
	JSR PC,QIFLD
	BR QPBLEN
	MOV #<<2*400>+14>,C
	EDPB
QPBLEN:	ETEXT		;BYTE LENGTH
	ASCNB
	JSR PC,QIFLD
	BR QPBROT
	MOV #<<5*400>+5>,C
QPDNB1:	EDPB
QPBROT:
QPDMR:	ETEXT		;BYTE ROTATE
	ASCMR
	JSR PC,QIFLD
	BR QPBMF
	MOV #<<5*400>+0>,C
	EDPB
QPBMF:	BR QPMF		;MISC FUNCTION SAME POSITION IN ALL INST

QIFBS2:	BIS B,4(A)	;BIS VAL OF SYM INTO WD2
QPUOPJ:	JMP QPUOP

QIFBC2:	BIC B,4(A)	;BIC VAL OF SYM INTO WD2
	BR QPUOPJ

QIFOB:	BIC #3_12.,(A)	;DEPOSIT INTO ALU OBUS SELECTION FIELD
	BIS B,(A)
	BR QPALU

QPDIS:	ETEXT		;DISPATCH INST SEQUENCE
	ASCDO		;DISPATCH OFFSET
	JSR PC,QIFLD
	BR QPDNB
	EDDSPO		;DEPOSIT INTO DISPATCH OFFSET FIELD
QPDNB:	ETEXT
	ASCNB
	JSR PC,QIFLD
	BR QPDMR
	MOV #<<3*400>+5>,C
	BR QPDNB1
	
QPJMP:	ETEXT		;JMP SEQUENCE
	ASCJPC
	JSR PC,QIFLD
	BR QPJR
	EDJPC
QPJR:	ETEXT
	ASCR
	JSR PC,QIFLD
	BR QPJP
	MOV #<<1*400>+11>,C
	EDPB
QPJP:	ETEXT
	ASCP
	JSR PC,QIFLD
	BR QPJN
	MOV #<<1*400>+10>,C
	EDPB
QPJN:	ETEXT
	ASCN
	JSR PC,QIFLD
	BR QPJI
	MOV #<<1*400>+7>,C
	EDPB
QPJI:	ETEXT
	ASCI
	JSR PC,QIFLD
	BR QPJC
	MOV #<<1*400>+6>,C
	EDPB
QPJC:	ETEXT
	ASCJC
	JSR PC,QIFLD
	BR QPJTB	;NULL HERE TO TEST BIT
	ADD #40,B	;SET TEST CONDITION BIT
QPJTB1:	MOV #<<6*400>+0>,C
	EDPB
QPJMF:	JMP QPMF


QPJTB:	ETEXT
	ASCTB
	JSR PC,QIFLD
	BR QPJMF
	BR QPJTB1

QIFSU:	ETEXT 		;SYM UNDEFINED
	ASCU		;RUB IT OUT!
QIFRUB:	ETEXT
	ASCXXX
	BR QIFRB1

QIFLD:	PUSH A			;READ IN FIELD
QIFRB1:	TST QIFCRT		;SKIP UNLESS FIELD NULL
	BNE QIFCL		;TYPED CR BEFORE, CLOSE REG
QIFLD1:	JSR PC,GECOM		;G COM, EVAL SYMS
	CMP A,#RUBCOD
	BEQ QIFRUB
	CMP A,#7
	BEQ QIFQT
	TST CNUMF
	BLT QIFNM		;HE TYPED A NUMBER!
	TST CSYL
	BNE QIFSYL		;HE TYPED SYM, LOOK IT UP
	CMP A,#40
	BEQ QIFSP		;SKIP OVER THIS FLD 
				; IE RETURN W/O SKIPPING
	CMP A,#15
	BEQ QIFCL		;CR CLOSE REG
	BR QIFLD1		;SOMETHING ELSE RANDOM, IGNORE

QIFCL:	MOV #QTIDEP,2(SP)	;FORCE RETURN TO QTIDEP
	BR QIFSP

QIFNM:	CMP A,#15		;TERM BY CR?
	BNE QIFLDX
	DEC QIFCRT		;REMEMBER CR TYPED
QIFLDX:	ADD #2,2(SP)		;SKIP ON RETURN
QIFSP:	MOV CNUM,B		;DONT SKIP ON RETURN (MEANS SKIP
				;FIELD
QIFSP1:	POP A
	RTS PC

QIFQT:	JMP COMERR

QIFSYL:	MOV #QIFST,C		;SEARCH SYMTAB
QIFSY1:	CMP C,#QIFSTE
	BHIS QIFSU		;SYMBOL UNDEFINED
	MOV #CBUF,T
	MOV (C)+,U
QIFSY2:	CMPB (T)+,(U)
	BNE QIFSY3		;THAT ONE LOSES
	TSTB (U)+
	BNE QIFSY2		;KEEP LOOKING
	MOV (C)+,B		;VALUE TO RETURN
	MOV (C)+,2(SP)		;PLACE TO FORCE RETURN
	BR QIFSP1

QIFSY3:	CMP (C)+,(C)+		;TRY NEXT SYMBOL
	BR QIFSY1

QIFCRT:	0			;-1 CR TYPED

;SYMBOL TABLE FORMAT:
; WD0 POINTER TO ASCIZ STRING
; WD1 VALUE
; WD2 FORCE RETURN ADR

QIFST:	ASCPJ1			;PJ
	CIPJB
	QIFBS2			;BIS INTO WD 2
	ASCNPJ			;NPJ
	CIPJB
	QIFBC2			;BIC INTO WD 2	
	ASCOL1			;OBL1 (OUTPUT BUS LEFT 1)
	COBAL_12.
	QIFOB
	ASCOR1			;OBR1 (OUTPUT BUS RIGHT 1)
	COBAR_12.
	QIFOB
QIFSTE:


.SBTTL MISC COMMAND CHARS' ROUTINES

QCZ:	EDCLK			;ZONK. CYCLE CLOCK ONCE
	RTS PC

QCR:
QDPRS:	JSR PC,RESSV		;RESET
	ERESET
	RTS PC

QCN:
QDPSTE:	JSR PC,RESSV		;RESTORE STATE, SAVE AND COME BACK
	CMP CNUM,#RAORG
	BHIS QCN2		;BRANCH IF ARG IS REGISTER ADDRESS
	TST CNUMF
	BLT QCN1
	INC CNUM		;DEFAULT ARG OF 1
QCN1:	SUB #1,CNUM
	SBC CNUM+2
	SBC CNUM+4
	BLT QCNX
	ECCLK
	TST CMREQ
	BLT QCN1		;GUY WANTS TO QUIT OUT
QCNX:	RTS PC

QCN2:	SUB #RACMO,CNUM		;C MEM ADDRESS OF INSTR TO STOP AT
QCN3:	JSR PC,XCCLK		;PROCEED UNTIL ABOUT TO EXECUTE THAT
	CLR CPSVAL		;BUT ALWAYS PROCEED AT LEAST ONCE
QCN4:	TST CMREQ
	BGE QCNX		;STOP IF GUY ASKS TO QUIT OUT
	MOV TYICH,A
	BNE QCNTYI		;HACK TYPEIN
	TST 164002
	BPL QCNX		;MACHINE LOSSAGE, CEASE PROCEEDING
	BIT 164010,#4000	;IR43
	BNE QCN5		;HANDLE TYO WHILE STEPPING
	MOV 164006,A		;READ PC INTO A
	BIC #170000,A		; PC 12 BITS
	CMP A,CNUM		;DON'T STOP IF HAVEN'T REACHED DESIRED PC
	BNE QCN3
	ECCLK			;CLOCK ONCE MORE TO FETCH DESIRED INSTR
	CLR CPSVAL
	JSR PC,PSCONS
	TST NOOPF		;BUT IF ITS NOOPED, DON'T STOP
	BNE QCN4		;BECAUSE NOT REALLY EXECUTING IT
	RTS PC

QCN5:	MOV 164004,A		;LOW 16 BITS OF OBUS
	BNE 3$
	ECCLK
	BR QCN5

3$:	JSR PC,TYOCHR		;GOT THE STUFF, TYPE IT
	MOV CURSX,RCURSX	;MAKE SURE CURSOR DISPLAYING IN RIGHT PLACE
	MOV CURSY,RCURSY
	ENCLK			;CLOCK PAST FIRST ALU INST
	ENCLK			;CLOCK PAST JUMP, NO-OP ING IT
	BR QCN3

QCNTYI:	CLR TYICH		;HERE WHEN KEY HIT WHILE ONE-PROCEEDING
	CMP A,#23		;^S STOP
	BEQ QCNX
	BR QCN4			;EVERYTHING ELSE IGNORED
;	MOV CNUM,-(SP)		;I'M A LITTLE PARANOID ABOUT THIS
;	CLR -(SP)		;OTHER CHAR, GIVE TO CONS
;	MOV A,-(SP)
;	CMP A,#40
;	BLT 2$
;	CMP A,#177
;	BEQ 2$
;	JSR PC,ADDCHR		;ECHO NON-CONTROLS EXCEPT RUBOUT
;	MOV (SP),A
;2$:	CMP A,#15
;	BNE 1$
;	JSR PC,TYOCHR		;ECHO CR AS CR,LF,CLEOL
;1$:	MOV CURSX,RCURSX	;MAKE SURE CURSOR DISPLAYING IN RIGHT PLACE
;	MOV CURSY,RCURSY
;	JSR PC,ENTER		;SAVE STATE OF CONS
;	CMP -(SP),-(SP)		;CHECK THE TYI REGISTER
;	MOV SP,A
;	MOV #RATYI-RAAMO+CDAMEM,B
;	EEXAMD
;	BIS (SP)+,(SP)+		;IS IT ZERO?
;	BEQ 3$			;YES, OK
;	JSR PC,BELL		;NO, BEEP, PREV CHAR NOT PICKED UP YET
;	BR 4$

;3$:	MOV SP,A		;GIVE IT THE CHARACTER
;	MOV #RATYI-RAAMO+CDAMEM,B
;	EDMM0
;4$:	CMP (SP)+,(SP)+		;FLUSH TEMP REGISTERS
;	JSR PC,LEAVE		;RESTORE STATE OF CONS
;	MOV (SP)+,CNUM
;	BR QCN4			;RETURN TO ONE-PROCEED LOOP

QCP:;	JSR PC,RESSV		;RESTORE STATE, SAVE AND COME BACK
;	ECCLK			;MAYBE XCT IR (MIGHT CAUSE IR PARITY ERR)
;	ECLK			;MAKE SURE ERRORS CLEARED
;	MOV #1,164006		;SET RUN!
;QCP1:	WAIT
;	TST CMREQ
;	BLT QCP1
;	RTS PC

QDPGO:	MOV #-1,CTRUN		;INDICATE "TRYING TO RUN"
	JSR PC,QDPRUN
;	TST CNUM		;IF VALUE STORING IS NON-ZERO, DON'T GIVE UP TTY
;	BNE 1$
;	ZAPFLG LMHTTY		;GIVE THE TTY TO THE LISP MACHINE
;	TST CNUM		;IF VALUE STORING NON-ZERO
;	BEQ 1$
;	COM LMHTTY		;SET IT NEGATIVE FOR REMOTE CONSOLE MODE
1$:	RTS PC

QDPRUN:	TST CTRUN		;SET REAL RUN. FIRST SEE IF REALLY WANT TO
	BEQ QDPRUX		; MUST HAVE BEEN CLEARED BY DETECTING AN ERROR 
	JSR PC,LEAVE		;START MACHINE, KEEP LISTENING (PRESUMABLY TO 10)
	ECCLK
	ECLK
	MOV #1,164006
	MOV #-1,CRUN		;CONS SHOULD REALLY BE RUNNING NOW!
QDPRUX:	RTS PC

RESSV:	JSR PC,LEAVE		;LEAVE - CALL BACK -ENTER -RETURN
	JSR PC,@(SP)		;CALL GUY BACK
	JSR PC,ENTER
	JSR PC,CDSPLY		;UPDATE DISPLAY
	TST (SP)+
	RTS PC

QPLS:	MOV #CNUM,TT		;PLUS, SPACE
	MOV #CVAL,T		;JUST RETURN ARG AS VALUE
	MOV (TT)+,(T)+
	MOV (TT)+,(T)+
	MOV (TT),(T)
	DEC CVALF
QAMP3:	RTS PC

QAMP:	INC NOOPF		;NO OP FIRST CYCLE
	MOV A,B			;SEND CONSOLE INST BUFFER
	JSR PC,QEXCI1		;TO MACHINE, ARG IS HOW MANY TO
	MOV C,QAMPL		;POINTER TO BUFFER AT LAST PLACE
	JSR PC,RESSV
QAMP2:	MOV #CIBUF,A
QAMP1:	TST CMREQ
	BGE QAMP3		;LEAVE LOOP
	CMP A,QAMPL
	BHIS QAMP2
	EWDIB
	EDCCLK			;DO DEBUG CLOCK OR NOOP DEBUG
	ADD #<3*2>,A		; CLOCK FIRST TIME
	BR QAMP1

QAMPL:	0			;HIGH CONSOLE BUFFER ADR TO SEND

QEQ:	TST CNUMF
	BEQ QEQ1		;TYPE OUT LAST REG INSTEAD
	MOV A,B			;=
	MOV #6,C
	JSR PC,OCTPNB
QEQ2:	JMP CRLF

QEQ1:	CLR QEXPF		;FETCH PT AND PRINT NUMERIC
	MOV CONSPT,A
	MOV #QEXAMV,B
	JSR PC,REGDC
	IPNFLD
	BR QEQ2

QDPRCN:	MOV #CNUM,A
;QDPRC0:	TST CTRUN
;	BNE 1$
	JMP COMERR

;1$:	PUSH A
;	JSR PC,QDPHLT		;STOP MOMENTARILY
;	POP A
;	MOV #RATYI-RAAMO+CDAMEM,B
;	EDMM0
;	JMP QDPRUN		;RESUME (IF NO ERROR)

QDPMOD:	TST CTRUN
	BEQ 10$
	JMP COMERR		;DOESN'T WIN IF MACHINE RUNNING

10$:	MOV CNUM,MODREG		;STORE INTO MODE REGISTER
MODSET:	MOV #100000,A		;CONVERT TO MACHINE FORMAT
	BIT #1,MODREG		;SLOW MODE
	BEQ 1$
	BIS #400,A
1$:	BIT #2,MODREG		;DISABLE ERROR HALT MODE
	BNE 2$
	BIS #1000,A
2$:	MOV A,164006		;STORE INTO HARDWARE MODE
	RTS PC

.SBTTL PRINT ADDRESS

QPAD:	MOV #GSYMT,TT		;PRINT SYMBOL IF ONE FOUND EXACTLY EQUAL
QPASY1:	CMP TT,#GSYMTE
	BHIS QPASYX		;NO MATCH
	CMP A,2(TT)
	BEQ QPASYF		;FOUND IT
	ADD #4,TT
	BR QPASY1

QPASYF:	MOV (TT),A		;SYMBOL FOUND, PRINT IT
	ETEXTP
	RTS PC

QPASYX:	MOV #QPADV,B		;PRINT ADDRESS (IN A)
	JSR PC,REGDC
	RTS PC

QPADV:	QPATL	;TOO LOW, JUST PRINT NUMBER
	QPAC	;CONTROL MEM    PRINT ADDRESS VECTOR
	QPADM	;DISPATCH MEM
	QPAPB	;PDL BUFFER
	QPA1MP	;1ST LVL MAP
	QPA2MP	;2ND LVL MAP
	QPAA	;A MEM
	QPAUS	;U STACK
	QPAM	;M MEM
	QPAFS	;FUNCTIONAL SOURCES
	QPAFD	;FUNCTIONAL DESTINATIONS
	QPANUL	;CONSOLE COMPUTER REGS
	QPANUL	;CONSOLE COMPUTER MODES AND SWITCHES
	QPARDR	;RAID REGISTERS
	QPACIB	;CONSOLE COMPUTER INST BUFFER
	QPANUL	;MAIN MEMORY FUNCTION REGISTERS
	QPANUL	;OLD PCS
	QPANUL	;TOO HI

QPA1MP:	MOV #4,C
	JSR PC,OCTPNB
	ETEXT			;1ST LVL MAP
	ASC1MP
	RTS PC

QPA2MP:	MOV #4,C
	JSR PC,OCTPNB
	ETEXT			;2ND LVL MAP
	ASC2MP
	RTS PC

QPARDR:	ETEXT			;RAID REGISTERS
	ASCRDP
	MOV #1,C
	JSR PC,OCTPNB
	RTS PC

QPACIB:	ETEXT			;CONSOLE INST BUFFER
	ASCCBP			;CIB+
	MOV #2,C
	JSR PC,OCTPNB
	RTS PC

QPAUS:	MOV #2,C		;PRINT U STACK ADR
	JSR PC,OCTPNB
	ETEXT
	ASCIUS
	RTS PC

QPADM:	MOV #4,C		;PRINT DISPATCH MEM ADR
	JSR PC,OCTPNB
	ETEXT
	ASCIDM
	RTS PC

QPAC:	MOV #4,C		;PRINT CONTROL MEM ADR
	JSR PC,OCTPNB
	ETEXT
	ASCICM
	RTS PC

QPAPB:	MOV #4,C		;PRINT PDL BUFFER ADR
	JSR PC,OCTPNB
	ETEXT
	ASCIPB
	RTS PC

QPAA:	MOV #3,C
	JSR PC,OCTPNB
	ETEXT
	ASCIAM
	RTS PC

QPAFD:	MOV #2,C		;FUNCTIONAL DEST
	JSR PC,OCTPNB
	ETEXT
	ASCFDP
	RTS PC

QPAFS:	ADD #40,B		;TURN F SRC INTO M ADR S
QPAM:	MOV #2,C
	JSR PC,OCTPNB
	ETEXT
	ASCIMM
	RTS PC

QPANUL:	ADD REGDEF,B		;GET BACK FULL ADR
QPANL1:	ETEXT			;DONT KNOW HOW TO PRINT THAT, SO
	ASCREG			;PRINT INTERNAL ADDR
QPATL:	MOV #6,C
	JSR PC,OCTPNB
	RTS PC

.SBTTL EMT HANDLER

EMTBRK:	CMP SP,#PDL+30
	BLO STAKO		;STACK OVERFLOW
	PUSH #EMTRET
	PUSH A
	BIC #17,6(SP)		;CLEAR PROCESSOR FLAGS
				; SO THEY CAN BE USED TO RETURN INFO
	MOV 4(SP),A		;GET RETURN PC
	MOV -(A),A		;GET EMT INST
	ASL A			;SHIFT TO CONVERT TO WORD INDEX
	CMP A,#TWHEMT
	BHI BADEMT		;OUT OF RANGE
	MOV EMTTAB-TWLEMT(A),A
	RTS A			;XFER TO EMT ROUTINE. WHEN IT RETURNS, IT WILL GO
				;TO EMTRET AND RETURN AGAIN
XFATL:	BPT
EMTERX:	BIS #1,4(SP)		;SET CARRY ON RETURN INDICATING ERROR
	RTS PC

EMTRET:	RTI

STAKO:	BPT
BADEMT:	BPT

;THIS ROUTINE MUST BE CALLED IMMEDIATELY AFTER EMT DISPATCH BY EMT WANTING
;TO ACCESS ARG AFTER THE EMT. IT SAVES ALL AC S, LOADS THE WD AFTER THE EMT
;INTO A, AND BUGGERS THE RETURN SO IT WILL RESTORE THE STATE OF THE MACHINE
;AND SKIP OVER THE ARG WORD.  U IS CLOBBERED IN THIS PROCESS ALTHO IT WILL
;BE RESTORED AT EXIT FROM EMT

EMTARG:	JSR U,ACSAV		;SAVE AC S (PUSHING 5 WDS)
	MOV <5+1+1+1>*2(SP),U	;ACCESS EMT ADR (+2)
				; ON STACK ARE 5 WDS PUSHED AT ACSAV, ONE FOR JSR U,
				; ONE BY JSR PC,EMTARG AND ONE FOR EMTRET.
	MOV (U)+,A		;GET ARG WD
	MOV U,<5+1+1+1>*2(SP)	;SMASH BACK SO ARG WD WILL BE SKIPPED OVER
EMTSA1:	JSR PC,@<5+1>*2(SP)	;CALL BACK EMT HANDLER TO FINISH THAT STUFF
	JSR U,ACRES
	TST (SP)+		;FLUSH WD WHERE EMT GUY CALLED US
	RTS PC

EMTSAV:	JSR U,ACSAV		;CALLED BY EMT S WISHING TO SAVE AND RESTORE ALL ACS
	BR EMTSA1

LEMT=EMT!0
TWLEMT=LEMT+LEMT
EMTTAB:	XFATL			;EMT 0
	XTEXT			;  1
	XERRO			;  2
	XROBUS			;  3
	XRIR			;  4
	XRPC			;EMT 5
	XRERWS			;  6
	XWDIB			;  7
	XDDEST			; 10
	XDALUF			; 11
	XDOBSL			;EMT 12
	XDMSRC			; 13
	XDASRC			; 14
	XUICLR			; 15
	XDCLK			; 16
	XDMM0			;EMT 17
	XNPCLK			; 20
	XEXAMD			; 21
	XDJPC			; 22
	XDCMEM			; 23
	XICLR			; 24
	XCLK			; 25
	XEXAMC			; 26
	XNCLK			; 27
	XOCTP4			; 30
	XOCTPD			; 31
	XPI			; 32
	XPASRC			; 33
	XPMSRC			; 34
	XPDEST			; 35
	XPOBSL			; 36
	XPALUF			; 37
	XPCRYC			; 40
	XPQC			; 41
	XPDDC			; 42
	XPDDO			; 43
	XPDNB			; 44
	XPMROT			; 45
	XPJPC			; 46
	XPJRB			; 47
	XPJPB			; 50
	XPJNB			; 51
	XPJINV			; 52
	XPJCND			; 53
	XPBMD			; 54
	XPBLEN			; 55
	XXFLD			; 56
	XWPC			; 57
	XPERRS			; 60
	XSTOP			; 61
	XDPB			; 62
	XDMDST			; 63
	XDRDST			; 64
	XDDSPO			; 65
	XRPDLB			; 66
	XWPDLB			; 67
	XSUSTK			; 70
	XUUSTK			; 71
	XTEXTP			; 72
	XCCLK			; 73
	XDCCLK			; 74
	XRESET			; 75
	XRDSP			; 76
	XWDSP			; 77
	XRDSPC			;100
	XWDSPC			;101
	XWIR			;102
	XDPBLK			;103
	XRL1MP			;104
	XWL1MP			;105
	XRL2MP			;106
	XWL2MP			;107
	XRMEMS			;110
	XWMEMS			;111
	XRDBLK			;112
	XWPVMA			;113
	XMMWC			;114
	XMMRC			;115
	XVMEMS			;116
HEMT=EMT!<<.-EMTTAB>/2>
TWHEMT==HEMT+HEMT


.SBTTL RANDOM EMT ROUTINES

XTEXTP:	JSR PC,EMTSAV		;PRINT ASCIZ TEXT STRING IN A
	BR PTEXT

XTEXT:	JSR PC,EMTARG		;SAVE ALL AC S, CHANGE EMT RETURN, RTN WD AFTER EMT IN A
PTEXT:	MOV A,B			;TYPE OUT ASCIZ STRING POINTED TO BY A -CLOBBERS ACS-
PTEXTL:	MOVB (B)+,A
	BEQ PTEXTX
	PUSH B
	JSR PC,TYOCHR
	POP B
	BR PTEXTL

PTEXTX:	RTS PC

XERRO:	CMP A,#NERMS		;OUTPUT SYSTEM ERR MSG WHOSE NUMBER IS IN A
	BHIS XERROF
	ASL A
	MOV ERRTXT(A),A
	BR PTEXT

XERROF:	EFATL

ERRTXT:				;POINTER TO ASCIZ STRING FOR ERR MSG
NERMS==<.-ERRTXT>/2


XROBUS:	PUSH A			;READ OBUS INTO DOUBLE WD POINTED TO BY A
	MOV 164004,(A)+
	MOVB 164000,(A)+
	MOVB 164012,(A)+
	POP A
	RTS PC

XRIR:	PUSH A			;READ IR INTO TRIPLE WD POINTED TO BY A
	MOV 164014,(A)+
	MOV 164016,(A)+
	MOV 164010,(A)
	BIC #160000,(A)		;THOSE BITS ARENT REALLY PART OF IR
	POP A
	RTS PC

XRPC:	MOV 164006,(A)		;READ PC INTO WD POINTED TO BY A
	BIC #170000,(A)		; PC 12 BITS
	RTS PC


XRERWS:	PUSH A			;READ ERROR DOUBLE WORD INTO BLOCK POINTED TO BY A
	MOVB 164003,(A)+	;LOW BYTE FROM HIGH BYTE OF 002
	MOVB 164001,(A)+	;HIGH BYTE FROM HIGH BYTE OF 000
	BIC #17,-2(A)		;THOSE BITS SOMETHING ELSE ..
	MOVB 164013,(A)+	;LOW BYTE FROM HIGH BYTE OF 012
	MOVB 164011,(A)+	;HIGH BYTE FROM HIGH BYTE OF 010
	BIC #17600,-(A)		;THOSE BITS ALSO SOMETHING ELSE ..
	POP A
	RTS PC

XWDIB:	MOV (A)+,164000		;WRITE DIAG INST BUFFER FROM TRIPLE WD POINTED TO BY A
	MOV (A)+,164002
	MOV (A),164004
	SUB #<2*2>,A		;RESTORE A
	RTS PC

XDDEST:				;DEPOSIT B INTO DEST FIELD OF
	ROR B			;DONT CARE ABT CARRY SINCE WILL MASK
	ROR B			;LOW 2 BITS OF B GO IN HIGH 2 BITS OF FIRST WD
	PUSH B			;PUSH IT WHEN LOW BYTE HAS HIGH 8 BITS
	ROR B			;GET BIT OUT OF CARRY BACK INTO WD
	BIC #37777,B
	BIC #140000,(A)
	BIS B,(A)+
	POP B
	BIC #377,(A)		;OTHER 8 BITS GO IN LOW BYTE OF SECOND WD
	BISB B,(A)
	TST -(A)		;RESTORE A
	RTS PC

	
XDALUF:				;DEPOSIT B INTO ALU OP FIELD OFU-INST POINTED TO BY A
	ROL B
	ROL B
	ROL B
	ROL B
	BIC #1760,(A)
	BIC #176017,B
	BIS B,(A)
	RTS PC


XDOBSL:				;DEPOSIT B INTO OUTPUT BUS CNTRL
	SWAB B			;OF U INST POINTED TO BY A
	ROL B
	ROL B
	ROL B
	ROL B
	BIC #030000,(A)
	BIC #147777,B
	BIS B,(A)
	RTS PC


XDMSRC:				;DEPOSIT B INTO M SRC FIELD
	TST (A)+
	SWAB B
	BIC #037400,(A)
	BIC #140377,B
	BIS B,(A)
	TST -(A)
	RTS PC

XDASRC:				;DEPOSIT B INTO A SRC FIELD
	TST (A)+
	ROR B			;DONT CARE ABT CARRY SINCE WILL MASK
	ROR B			;LOW 2 BITS OF B GO IN HIGH 2 BITS OF SECOND WD
	PUSH B			;PUSH IT WHEN LOW BYTE HAS
				;HIGH 6 BITS RIGHT ADJUSTED
	ROR B			;GET BIT OUT OF CARRY BACK INTO WD
	BIC #37777,B
	BIC #140000,(A)
	BIS B,(A)+
	POP B
	BIC #77,(A)		;OTHER 6 BITS GO IN LOW BYTE OF THIRD WD
	BIC #177700,B
	BIS B,(A)
	SUB #4,A
	RTS PC


XUICLR:	MOV #UI+6,A		;CLEAR OUT TEM 3 REG BLOCK AND LEAVE A POINTING THERE
	CLR -(A)
	CLR -(A)
	CLR -(A)
	RTS PC

XDMM0:	PUSH A
	PUSH B			;SAVE FINAL DEST
	BIT B,#3740
	BEQ XDMMM		;DEST IS MM LOCN, BUILD THERE
	CLR B			;BUILD IN M MEM 0
XDMMM:	MOV #XDMTM1,A		;CLEAR MM LOCN
	JSR PC,XICLR
	PUSH B			;SAVE BUILD DEST
	JSR PC,XDDEST		;AND PUT IT INTO U INST
	MOV (SP),B
	JSR PC,XDMSRC			;ALSO M SRC
	MOV #COBA,B
	JSR PC,XDOBSL
	MOV #USETZ,B
	JSR PC,XDALUF
	JSR PC,XWIR
	JSR PC,XDCLK
	MOV 4(SP),T		;GET BACK ORIG CONTENTS OF A
	TST (T)+
	BNE XDMMB
	TST (T)
	BEQ XDMMC		;DEPOSITING ZERO
XDMMB:	MOV #UASHM,B		;LOAD ASH IN ALU FCTN
	EDALUF
	MOV 4(SP),T		;GET BACK ORIG CONTENTS OF A
	MOV 2(T),C		;DEPOSIT 2 WD BLOCK POINTED
	BEQ XDMMA		;TO BY A IN M MEMORY LOCN 0
	JSR PC,XDM0A
XDMMA:	MOV @4(SP),C
	JSR PC,XDM0A
XDMMC:	JSR PC,XNPCLK		;MAKE SURE DATA NOT IN PASS AROUND PATH
	MOV #USETM,B
	EDALUF
;	EWIR
;	MOV #XDM0BB,A
;	EROBUS
;	MOV 4(SP),C		;GET BACK ORIG CONTENTS OF A
;	CMP (C),XDM0BB
;	BNE XDM0ER
;	CMP 2(C),XDM0BB+2
;	BNE XDM0ER
	POP C		;BUILD DEST
	POP B		;FINAL DEST
	MOV #XDMTM1,A	;RESTORE A
	CMP B,C
	BEQ XDM0EX	;HAVE STORED IT WHERE DESIRED
	PUSH B
	BIT #2000,B
	BNE XDMSD	;GEE, REALLY WANT THIS IN PSEUDO DEST
	JSR PC,XDDEST	;DEPOSIT IN FINAL DEST
;	MOV #USETM,B
;	JSR PC,XDALUF
	JSR PC,XWIR
	JSR PC,XDCLK
	JSR PC,XNPCLK	;GENERATE AN EXTRA JUST TO MAKE SURE 
	POP B		;IT REALLY GETS WRITTEN IF TO PDL BUFFER
XDM0EX:;BIT #CDAMEM,B
;	BEQ XDM0X1
;	PUSH B
;	EDASRC		;CHECK DEPOSIT INTO A MEM
;	MOV #USETA,B
;	EDALUF
;	EWIR
;	MOV #XDM0BB,A
;	EROBUS
;	MOV 2(SP),C
;	CMP (C),XDM0BB
;	BNE XDM0E1
;	CMP 2(C),XDM0BB+2
;	BNE XDM0E1
;XDM0X2:	POP B
XDM0X1:	POP A
	RTS PC

;XDM0ER:	POP B
XDM0E1:	POP B
	POP A
	RTS PC
;	JMP EMTERX	;LOSES ON DIRECT CALL

XDMSD:	CMP B,#CSDQ	;DEPOSIT IN PSEUDO DEST
	BNE XDM0E1
	BIS #3,(A)	;LOAD Q INTO Q CONTROL
	EWIR
	EDCLK
	POP B
	BR XDM0X1

XDM0BB:	0
	0

XDMTM1:	0
	0
	0


XDM0A:	MOV #16.,T		;LOOP COUNT
	MOV #4,TT		;CARRY IN BIT OF ALU
XDM0B:	BIC TT,(A)
	TST C
	BGE XDM0C
	BIS TT,(A)		;SET CARRY IN
XDM0C:	JSR PC,XWIR		;GO DIRECTLY TO SAVE TIME!
	JSR PC,XDCLK
	ROL C
	DEC T
	BNE XDM0B
	RTS PC

XEXAMD:	PUSH A		;EXAMINE DATA PATH MEMORIES
	PUSH B
	MOV #XEXM1,A
	EICLR
	EDDEST
	MOV #COBA,B
	EDOBSL
	MOV (SP),B
	BIT B,#CDAMEM
	BNE XEXAM	;A MEM
	EDMSRC
	MOV #USETM,B
XEXAM1:	EDALUF
	EWIR
	MOV 2(SP),A
	EROBUS
	POP B
	POP A
	RTS PC

XEXAM:	EDASRC
	MOV #USETA,B
	BR XEXAM1

XEXM1:	0
	0
	0


XDJPC:	ROR B	;DEPOSIT B INTO JUMP FIELD OF A
	ROR B
	ROR B
	ROR B
	PUSH B
	ROR B
	BIC #7777,B
	BIC #170000,(A)
	BIS B,(A)
	POP B
	BIC #377,2(A)
	BISB B,2(A)
	RTS PC

XDCMEM:	PUSH A		;LOAD U INST POINTED TO BY A INTO CONTROL
	PUSH B		;MEM LOCN IN B
	MOV 2(SP),A
	ADD #4,A
	MOV #CDAMEM+1,B
	JSR PC,XDMM0		;DEPOSIT HI PART IN A-MEM LOCN 1
	MOV 2(SP),A
	CLR B
	JSR PC,XDMM0		;DEPOSIT LOW PART IN M-MEM LOCN 0
;	MOV #XDCIPC,A
;	JSR PC,XRPC		;SAVE PC BEFORE HACKING HAIRY PART
	MOV #XDCIB,A
	JSR PC,XICLR
	BIS #CIJMP,4(A)
	MOV (SP),B
	JSR PC,XDJPC
	BIS #CIJNB+CIJRB+CIJPB+CIJUC,(A)
	BIS #40000,2(A)		;A SOURCE 1
	JSR PC,XWIR
;	MOV #XDCTPC,A
;	JSR PC,XRPC
;	DEC XDCTPC
;	BIC #170000,XDCTPC
;	CMP XDCTPC,XDCIPC
;	BEQ XDCEC1
;	INC XDCME1		;THEY SHOULD HAVE BEEN EQUAL
XDCEC1:	JSR PC,XCLK
;	ERPC
;	CMP XDCTPC,(SP)
;	BEQ XDCEC2
;	INC XDCME2
XDCEC2:	JSR PC,XNPCLK
;	ERPC
;	DEC XDCTPC
;	BIC #170000,XDCTPC
;	CMP XDCTPC,XDCIPC
;	BEQ XDCEC3
;	INC XDCME3
XDCEC3:	POP B
	POP A
	RTS PC

;XDCME1:	0
;XDCME2:	0
;XDCME3:	0

XDCIB:	0
	0
	0

;XDCIPC:	0			;INITIAL PC (BEFORE HACKING)
;XDCTPC:	0			;TEMP FOR READING IN PC


XICLR:	PUSH A			;CLEAR THREE INST BLOCK POINTED
	CLR (A)+		;TO BY A
	CLR (A)+
	CLR (A)
	POP A
	RTS PC

XEXAMC:	PUSH A			;EXAMINE CONTROL MEM AT LOCN IN B
	PUSH B
	MOV #XEXC1,A
	EICLR
	BIS #CIJNB+CIJUC,(A)
	EDJPC
	BIS #CIJMP,4(A)
	EWIR
	EDCLK
	ENCLK
	POP B
	POP A
	ERIR
	RTS PC

XEXC1:	0
	0
	0

XRESET:	MOV #4,164006		;DO CONS RESET
	MOV #0,164006
	JMP MODSET		;SET SPEED AND ENABLE HALT ON ERROR

;	MOV #101000,164006	;NORMAL SPEED, ENABLE HALT ON ERROR
;	CLR MODREG
;	RTS PC

XDCLK:	MOV #110,164006		;TICK CLOCK IN DEBUG MODE
	MOV #112,164006		;NOT CHANGING OPCS
	RTS PC

XWIR:	JSR PC,XWDIB		;WRITE INTO IR (FIRST INTO DIB)
	BR XNPCLK		;THEN NO-OP CLOCK

XDCCLK:	TST NOOPF		;EDCLK UNLESS NOOPF SET
	BEQ XDCLK		;IN WHICH CASE ENPCLK
	CLR NOOPF
XNPCLK:	MOV #130,164006		;TICK CLOCK WITH BOTH DEBUG AND NO OP ON
	MOV #132,164006		;NOT AFFECTING OPCS
	MOV #112,164006		;CLEAR NO OP
	RTS PC

XCLK:	MOV #0,164006		;TICK CLOCK ONCE IN REGULAR RUN
	MOV #2,164006		;MODE
	RTS PC

XCCLK:	TST NOOPF		;CLOCK UNLESS NOOPF SET
	BEQ XCLK		;NO NOOP
	CLR NOOPF
XNCLK:	MOV #120,164006		;CYCLE CLOCK ONCE IN REGULAR
	MOV #122,164006		;MODE WITH NO-OP BIT SET, NOT AFFECTING OPCS
	MOV #12,164006		;CLEAR NO OP
	RTS PC


XOCTPD:	JSR PC,EMTSAV		;PRINT 11 OCTAL DIGITS OF BLOCK POINTED TO BY A
	PUSH A
	MOV 2(A),A		;GET HIGH WORD
	CLC
	ROR A
	ASR A
	ASR A
	ASR A
	MOV #5,C
	JSR PC,OCTPN		;PRINT HIGH FIVE DIGITS (14 BITS WORTH)
	MOV (SP),C
	MOV (C),A
	ROL A			;GET HIGH BIT OF LOW WORD IN CARRY
	MOV 2(C),A
	ROL A
	MOV #1,C
	JSR PC,OCTPN		;PRINT THE SPLIT DIGIT
	POP C
	MOV (C),A
	MOV #5,C
	BR OCTPN		;FINISH OFF WITH LAST 5 DIGITS.

XPI:	MOV 4(A),C		;PRINT BLOCK POINTED TO BY A AS U INST.
	BIT #100,C
	BEQ XPI1		;TEST POPJ BIT
	ETEXT			;POPJ BIT ON
	ASCPJ
XPI1:	ROL C
	SWAB C
	BIC #177774,C
	ASL C
	JMP @XPIDT(C)		;DISPATCH ON OP CODE

XOCTP4:	JSR PC,EMTSAV		;SAVE AC S
	MOV #4,C		;PRINT 4 DIGITS OF A
OCTPN:	MOV A,B			;PRINT # DIGITS IN C OF A
OCTPNB:	MOV #6,T
	CLR A			;DROP IN HERE SINCE FIRST "DIGIT" HAS ONE BIT
OCTPL:	ROL B
	ROL A
	CMP C,T
	BLT OCTPL1		;DONT WANT THAT DIGIT
	ADD #'0,A
	PUSH B
	PUSH C
	PUSH T
	JSR PC,ADDCHR
	POP T
	POP C
	POP B
OCTPL1:	DEC T
	BEQ OCTPX
	CLR A
	ROL B
	ROL A
	ROL B
	ROL A
	BR OCTPL

OCTPX:	RTS PC

.SBTTL ASCII CONSTANTS

ASC3SP:	.ASCIZ /   /
ASC2SP=ASC3SP+1
ASCSP=ASC3SP+2
ASCPJ:	.ASCIZ / PJ /
ASCALU:	.ASCIZ /ALU /
ASCDSP:	.ASCIZ /DSP /
ASCJMP:	.ASCIZ /JMP /
ASCBYT:	.ASCIZ /BYT /
ASCA:	.ASCIZ /A /
ASCM:	.ASCIZ /M /
ASCD:	.ASCIZ /D /
ASCDM:	.ASCIZ /DM /
ASCDR:	.ASCIZ /DR /
ASCDA:	.ASCIZ /DA /
ASCMSK:	.ASCIZ /MSK?? /
ASCAR1:	.ASCIZ /ALUR1 /
ASCAL1:	.ASCIZ /ALUL1 /
ASCMB:	.ASCIZ /MULT /
ASCINM:	.ASCIZ /INCM /
ASC1:	.ASCIZ /1 /
ASC2:	.ASCIZ /2 /
ASC3:	.ASCIZ /3 /
ASC4:	.ASCIZ /4 /
ASC5:	.ASCIZ /5 /
ASCSUB:	.ASCIZ /SUB /
ASC7:	.ASCIZ /7 /
ASC10:	.ASCIZ /10 /
ASCADD:	.ASCIZ /ADD /
ASC12:	.ASCIZ /12 /
ASC13:	.ASCIZ /13 /
ASLSHM:	.ASCIZ /LSHM /
ASC15:	.ASCIZ /15 /
ASC16:	.ASCIZ /16 /
ASCDCM:	.ASCIZ /DECM /
ASETCM:	.ASCIZ /SETCM /
AANDCB:	.ASCIZ /ANDCB /
AANDCM:	.ASCIZ /ANDCM /
ASETZ:	.ASCIZ /SETZ /
AORCB:	.ASCIZ /ORCB /
ASETCA:	.ASCIZ /SETCA /
AXOR:	.ASCIZ /XOR /
AANDCA:	.ASCIZ /ANDCA /
AORCM:	.ASCIZ /ORCM /
AEQV:	.ASCIZ /EQV /
ASETA:	.ASCIZ /SETA /
AAND:	.ASCIZ /AND /
ASETO:	.ASCIZ /SETO /
AORCA:	.ASCIZ /ORCA /
AOR:	.ASCIZ /OR /
ASETM:	.ASCIZ /SETM /
ASCC0:	.ASCIZ /C0 /
ASCC1:	.ASCIZ /C1 /
ASCCL:	.ASCIZ /CRYLAST /
ASCCQ:	.ASCIZ /CRYQ /
ASCNUL:	.ASCIZ //
ASCQL:	.ASCIZ /QLEFT /
ASCQR:	.ASCIZ /QRIGHT /
ASCLQ:	.ASCIZ /LOADQ /
ASCDC:	.ASCIZ /DISP-C /
ASCDO:	.ASCIZ /DISP-O /
ASCNB:	.ASCIZ /BYT-LEN /
ASCMR:	.ASCIZ /M-ROT /
ASCR:	.ASCIZ /R /
ASCP:	.ASCIZ /P /
ASCN:	.ASCIZ /N /
ASCI:	.ASCIZ /I /
ASCTB:	.ASCIZ /TEST-BIT /
ASCSR:	.ASCIZ / R /
ASCLDB:	.ASCIZ /LDB /
ASCDPB:	.ASCIZ /DPB /
ASCSBB:	.ASCIZ /SUBS /
ASCAUM:	.ASCIZ /ALU- /
ASCAUH:	.ASCIZ /ALU-31 /

ASCAEM:	.ASCIZ /A=M /
ASCINT:	.ASCIZ /INT /
ASCPF:	.ASCIZ /PF /
ASCIPF:	.ASCIZ /IPF /
ASCUNC:	.ASCIZ /UNC /
ASCQQ:	.ASCIZ /??
/
ASCSPC:	.ASCIZ /PC-FROM-SP /
ASCPC1:	.ASCIZ /PC+1 /
ASCJT:	.ASCIZ /JC-TRUE /
ASCJF:	.ASCIZ /JC-FALSE /
ASCSPP:	.ASCIZ /SPC-PAR /
ASCDPP:	.ASCIZ /DSP-PAR /
ASCHER:	.ASCIZ /HI-ERR /
ASCCPP:	.ASCIZ /C-MEM-PAR /
ASCMPP:	.ASCIZ /M-MEM-PAR /
ASCAPP:	.ASCIZ /A-MEM-PAR /
ASCPPP:	.ASCIZ /PDL-BUF-PAR /
ASCMNP:	.ASCIZ /MN-MEM-PAR /
ASCHOK:	.ASCIZ /HI-NOT-OK /
ASCRUN:	.ASCIZ /SRUN /
ASCWIM:	.ASCIZ /W-C-MEM /
ASCIMD:	.ASCIZ /IMOD /
ASCNOP:	.ASCIZ /NOP /
ASCMMW:	.ASCIZ /MN-MEM-WT /
ASCWPD:	.ASCIZ /W-P-BUF /
ASCWSP:	.ASCIZ /W-USTK /
ASCICM:	.ASCIZ /@C/
ASCIAM:	.ASCIZ /@A/
ASCIMM:	.ASCIZ /@M/
ASCIPB:	.ASCIZ /@P/
ASCIUS:	.ASCIZ /@U/
ASC1MP:	.ASCIZ /@1/
ASC2MP:	.ASCIZ /@2/
ASCIDM:	.ASCIZ /@D/
ASCREG:	.ASCIZ /REGADR /
ASCCR:	.ASCIZ /
/
ASCSLT:	.ASCIZ ?/	?
ASCQQJ:	.ASCIZ /JC?? /
ASCQST=ASCQQJ+3
ASCTOP:	.ASCIZ / OP /
ASCQC:	.ASCIZ /QC /
ASCMF:	.ASCIZ /MF /
ASCXXX:	.ASCIZ /XXX /
ASCU:	.ASCIZ /U /
ASCCRY:	.ASCIZ /CRYC /
ASCJC:	.ASCIZ /JC /
ASCJPC:	.ASCIZ /J-ADR /
ASCMD:	.ASCIZ /MD /
ASCHLT:	.ASCIZ /HALT /
ASCMF2:	.ASCIZ /MF2 /
ASCLLB:	.ASCIZ /LD-LOW-PC-BIT /
ASCLLR: .ASCIZ /LOW-PC-BIT-SEL-HW /
ASCIR:	.ASCIZ /.IR/
ASCSIR:	.ASCIZ /IR/
ASCPC:	.ASCIZ /PC/
ASCUSP:	.ASCIZ /USP/
ASCFSP:	.ASCIZ /+FSRC/
ASCFS=ASCFSP+1
ASCFDP:	.ASCIZ /+FDST/
ASCFD=ASCFDP+1		;HACK HACK
ASCQ:	.ASCIZ /Q/
ASCPP:	.ASCIZ /PP/
ASCPI:	.ASCIZ /PI/
ASCCIB:	.ASCIZ /CIB/
ASCCBP:	.ASCIZ /CIB+/
ACVMAR:	.ASCIZ /CVMAR/
ACMRD:	.ASCIZ /CMRD/
ACPMAR:	.ASCIZ /CPMAR/
ACMWD:	.ASCIZ /CMWD/
ACVMAW:	.ASCIZ /CVMAW/
ACPMAW:	.ASCIZ /CPMAW/

CSTARS:	.ASCIZ /******************************************************
PC= /
COBTX:	.ASCIZ /
OBUS= /
CERRST:	.ASCIZ /
STATUS: /
ASCLLM:	.ASCIZ /LLMODE/
ASCFSV:	.ASCIZ /FSV/
ASCPSV:	.ASCIZ /PSV/
ASCSLH:	.ASCIZ ?/?
ASCNPF:	.ASCIZ /NOOPF/
ASCRDR:	.ASCIZ /RAIDR/
ASCRDP:	.ASCIZ /RAIDR+/
ASCDC1:	.ASCIZ /DC/
ASCVMA:	.ASCIZ /VMA/
ASCMWD:	.ASCIZ /MWD/
ASCRST:	.ASCIZ /RESET/
ASCPJ1:	.ASCIZ /PJ/
ASCNPJ:	.ASCIZ /NPJ/
ASCOL1:	.ASCIZ /OBL1/
ASCOR1:	.ASCIZ /OBR1/
ASCMOD:	.ASCIZ /MODE/
ASCILG:	.ASCIZ /ILONG /
ASCB42:	.ASCIZ /BIT42 /
ASCPFG:	.ASCIZ /PDP11-FLAG /
.EVEN


.SBTTL PRINT VARIOUS FIELDS

XPIDT:	XPIALU
	XPIDSP
	XPIJMP
	XPIBYT

XPIALU:	ETEXT
	ASCALU
	EPASRC			;PRINT A SOURCE
	EPMSRC			;PRINT M SOURCE
	EPOBSL			;PRINT OUTPUT BUS SELECT
	EPDEST			;PRINT DEST
	EPALUF			;PRINT ALU FCTN
	EPCRYC			;PRINT CARRY CODE
	EPQC			;PRINT Q CONTROL
	MOV #XPALMF,C		;MISC FCTN
	BR XPMF1

XPALMF:	ASCNUL			;MF S FOR ALU
	ASCHLT
	ASCMF2
	ASCLLB

XPIDSP:	ETEXT
	ASCDSP
	EPDDC			;PRINT DISPATCH CONSTANT
	EPMSRC
	EPDDO			;PRINT DISPATCH OFFSET
	EPDNB			;DISPATCH # BITS
	EPMROT			;M ROTATE
XPMF:	MOV #XPMFT,C		;MISC FTCN
XPMF1:	MOV #<<2*400>+12>,B
	IPSFLD
	BIT #1000,4(A)		;THE 4 EXTRA BITS (BUT DON'T PRINT PARITY BIT)
	BEQ 1$
	ETEXT
	 ASCILG
1$:	BIT #2000,4(A)
	BEQ 2$
	ETEXT
	 ASCB42
2$:	BIT #4000,4(A)
	BEQ 3$
	ETEXT
	 ASCPFG
3$:	RTS PC

XPMFT:	ASCNUL			;MISC FCTN TBL FOR JMP BYT DSP
	ASCHLT
	ASCMF2
	ASCLLR

XPIJMP:	ETEXT
	ASCJMP
	EPASRC
	EPMSRC
	EPJPC			;NEW PC
	EPJRB			;R BIT
	EPJPB			;P BIT
	EPJNB			;N BIT
	EPJINV			;INVERT
	EPJCND			;CONDITION
	BR XPMF			;ONLY THING LEFT IS MISC FCTN

XPIBYT:	ETEXT
	ASCBYT
	EPASRC
	EPMSRC
	EPDEST
	EPBMD			;BYTE MODE
	EPBLEN			;BYTE LENGTH
	EPMROT			;BYTE ROTATE
	BR XPMF			;ONLY THING LEFT IS MISC FCTN


XPASRC:	ETEXT			;PRINT A SOURCE
	ASCA
XPASR1:	MOV #<<8*400>+36>,B	;8 BIT FLD 36 OVER
				; ENTER HERE FOR DISPATCH CONSTANT
XPMSR1:	IPNFLD			;EXTRACT AND PRINT FIELD
	RTS PC

XPMSRC:	ETEXT			;PRINT M SOURCE
	ASCM
	MOV #<<6*400>+30>,B	;6 BIT FIELD 30 OVER
	BR XPMSR1

XPDEST:				;PRINT DEST (OF BYTE AND ALU INSTS)
	BIT #CAMEMB,2(A)
	BNE XPDES1		;A MEM DESTINATION
	ETEXT		;M MEM AND/OR REGISTER DESTINATION
	ASCDM
	MOV #<<5*400>+16>,B	;PRINT M MEM DEST
	IPNFLD
	ETEXT
	ASCDR			;PRINT REGISTER DEST
	MOV #<<4*400>+23>,B
	IPNFLD
	RTS PC

XPDES1:	ETEXT			;PRINT A MEM DESTINATION
	ASCDA
	MOV #<<8*400>+16>,B
	IPNFLD
	RTS PC


XPOBSL:	MOV #<<2*400>+14>,B	;PRINT O BUS SELECTOR FIELD OF ALU INST
	MOV #XOPBTX,C
	IPSFLD
	RTS PC

XOPBTX:	ASCMSK
	ASCALU
	ASCAR1
	ASCAL1

XPALUF:	BIT #1000,(A)		;PRINT ALU FCTN
	BEQ XPALU1
	ETEXT
	ASCMB			;"MULTIPLY" BIT ON
XPALU1:	MOV #<<5*400>+4>,B
	MOV #XPALTX,C
	IPSFLD
	RTS PC

XPALTX:	ASCINM
	ASC1
	ASC2
	ASC3
	ASC4
	ASC5
	ASCSUB
	ASC7
	ASC10
	ASCADD
	ASC12
	ASC13
	ASLSHM
	ASC15
	ASC16
	ASCDCM
	ASETCM
	AANDCB
	AANDCM
	ASETZ
	AORCB
	ASETCA
	AXOR
	AANDCA
	AORCM
	AEQV
	ASETA
	AAND
	ASETO
	AORCA
	AOR
	ASETM


XPCRYC:	MOV #<<2*400>+2>,B	;PRINT CARRY CONTROL FIELD
	MOV #XPCRYT,C
	IPSFLD
	RTS PC

XPCRYT:	ASCC0
	ASCC1
	ASCCL
	ASCCQ

XPQC:	MOV #<<2*400>+0>,B	;PRINT Q CONTROL FIELD
	MOV #XPQCT,C
	IPSFLD
	RTS PC

XPQCT:	ASCNUL
	ASCQL
	ASCQR
	ASCLQ

XPDDC:	ETEXT		;PRINT DISPATCH CONSTANT
	ASCDC		;DISPATCH CONSTANT SAME AS A SOURCE
	JMP XPASR1

XPDDO:	ETEXT		;PRINT DISPATCH OFFSET
	ASCDO
	MOV #<<12*400>+16>,B	;10. BIT FIELD 16 OVER
	IPNFLD
	RTS PC
	
XPDNB:	ETEXT		;PRINT # BITS FIELD OF DISPATCH INST
	ASCNB		;GET BYTE LENGTH
	MOV #<<3*400>+5>,B
	IPNFLD
	RTS PC

XPMROT:	ETEXT		;PRINT M ROTATE FIELD
	ASCMR
XPMRT1:	MOV #<<5*400>+0>,B	;ENTER HERE FOR JUMP COND ON BIT
	IPNFLD
	RTS PC

XPJPC:	ETEXT		;PRINT JUMP NEW PC FIELD
	ASCJPC
	MOV #<<14*400>+14>,B
	IPNFLD
	RTS PC


XPJRB:	MOV #<<1*400>+11>,B	;PRINT JUMP R BIT FIELD
	MOV #XPJRBT,C
XPJPB1:	IPSFLD
	RTS PC

XPJRBT:	ASCNUL
	ASCR

XPJPB:	MOV #<<1*400>+10>,B	;PRINT JUMP P BIT FIELD
	MOV #XPJPBT,C
	BR XPJPB1

XPJPBT:	ASCNUL
	ASCP

XPJNB:	MOV #<<1*400>+7>,B	;PRINT JUMP N BIT FIELD
	MOV #XPJNBT,C
	BR XPJPB1

XPJNBT:	ASCNUL
	ASCN

XPJINV:	MOV #<<1*400>+6>,B	;PRINT JUMP INVERT SENSE FIELD
	MOV #XPJIBT,C
	BR XPJPB1

XPJIBT:	ASCNUL
	ASCI

XPJCND:	MOV #<<5*400>+0>,B	;PRINT JUMP CONDITION FIELD
	BIT #40,(A)
	BEQ XPJCN1		;XFER ON TEST BIT
	MOV #XPJCNT,C
	IPSFLD
	RTS PC

XPJCN1:	ETEXT			;TEST BIT
	ASCTB
	JMP XPMRT1		;SAME AS M ROTATE

XPJCNT:	ASCNUL	;0		;TABLE OF JUMP CONDITIONS
	ASCAUM	;1
	ASCAUH	;2
	ASCAEM	;3
	ASCINT	;4
	ASCPF	;5
	ASCIPF	;6
	ASCUNC	;7
	ASCQQJ	;10
	ASCQQJ	;11
	ASCQQJ	;12
	ASCQQJ	;13
	ASCQQJ	;14
	ASCQQJ	;15
	ASCQQJ	;16
	ASCQQJ	;17
	ASCQQJ	;20
	ASCQQJ	;21
	ASCQQJ	;22
	ASCQQJ	;23
	ASCQQJ	;24
	ASCQQJ	;25
	ASCQQJ	;26
	ASCQQJ	;27
	ASCQQJ	;30
	ASCQQJ	;31
	ASCQQJ	;32
	ASCQQJ	;33
	ASCQQJ	;34
	ASCQQJ	;35
	ASCQQJ	;36
	ASCQQJ	;37

XPBMD:	MOV #<<2*400>+14>,B	;PRINT MODE FIELD OF BYTE INST
	MOV #XPBMTX,C
	IPSFLD
	RTS PC

XPBMTX:	ASCNUL
	ASCLDB
	ASCSBB
	ASCDPB

XPBLEN:	ETEXT		;PRINT BYTE LENGTH FIELD OF BYTE INST
	ASCNB
	MOV #<<5*400>+5>,B
	IPNFLD
	RTS PC

XXFLD:	PUSH B
	MOV 4(A),C	;EXTRACT FIELD FROM U INST
	MOV 2(A),T	;B HAS FIELD DESC
	MOV (A),TT
	MOVB B,U
	BEQ XXFLD1
XXFLD2:	ROR C
	ROR T
	ROR TT
	DEC U
	BNE XXFLD2
XXFLD1:	MOVB 1(SP),U	;FIELD LENGTH
	CMP U,#16.
	BLE XXFLD3
	MOV #16.,U	;GIVE LOW 16. BITS OF FIELD > 16. BITS
XXFLD3:	ASL U
	MOV TT,A
	BIC XXMSK(U),A
	POP B
	RTS PC

XXMSK:	177777
	177776
	177774
	177770
	177760
	177740
	177700
	177600
	177400
	177000
	176000
	174000
	170000
	160000
	140000
	100000
	0

	

XWPC:	MOV (A),B	;WRITE LOCN POINTED TO BY A INTO CONS PC
	PUSH B
	MOV #XWPCI,A
	EICLR
	BIS #CIJMP,4(A)
	EDJPC
	BIS #CIJUC,(A)
	EWIR
	EDCLK
	MOV #XWPCT,A
	ERPC
	CMP XWPCT,(SP)+
	BEQ XWPCR
	INC XWPCL
	JMP EMTERX

XWPCR:	RTS PC

XWPCI:	0
	0
	0
XWPCT:	0
XWPCL:	0


XPERRS:	PUSH A			;PRINT ERRORS
	BIT #CESPCP,(A)
	BEQ XPER1
	ETEXT
	ASCSPP
XPER1:	BIT #CEDSPP,(A)
	BEQ XPER2
	ETEXT
	ASCDPP
XPER2:	BIT #CEHIER,(A)
	BEQ XPER3
	ETEXT
	ASCHER
XPER3:	BIT #CECP,(A)
	BEQ XPER4
	ETEXT
	ASCCPP
XPER4:	BIT #CEMMP,(A)
	BEQ XPER5
	ETEXT
	ASCMPP
XPER5:	BIT #CEAMP,(A)
	BEQ XPER6
	ETEXT
	ASCAPP
XPER6:	BIT #CEPDL,(A)
	BEQ XPER7
	ETEXT
	ASCPPP
XPER7:	BIT #CEMNMP,(A)
	BEQ XPER8
	ETEXT
	ASCMNP
XPER8:	BIT #CEHNOK,(A)
	BEQ XPER9
	ETEXT
	ASCHOK
XPER9:	BIT #CESRUN,(A)+
	BEQ XPER10
	ETEXT
	ASCRUN
XPER10:	BIT #CEWIM,(A)		;2ND WORD BITS
	BEQ XPER11
	ETEXT
	ASCWIM
XPER11:	BIT #CEIMOD,(A)
	BEQ XPER12
	ETEXT
	ASCIMD
XPER12:	BIT #CEINOP,(A)
	BEQ XPER13
	ETEXT
	ASCNOP
XPER13:	BIT #CENMMW,(A)
	BNE XPER14
	ETEXT
	ASCMMW
XPER14:	BIT #CEWPDL,(A)
	BEQ XPER15
	ETEXT
	ASCWPD
XPER15:	BIT #CEWSPC,(A)
	BEQ XPER16
	ETEXT
	ASCWSP
XPER16:	BIT #CEPF,(A)
	BEQ XPER17
	ETEXT
	ASCPF
XPER17:	MOV #<<1*400>+2>,B		;JUMP CONDITION BIT
	MOV #XPERJT,C
	IPSFLD
	MOV #<<2*400>+0>,B		;PC SOURCE FIELD
	MOV #XPERPT,C
	IPSFLD
	POP A
	RTS PC

XPERJT:	ASCJF
	ASCJT

XPERPT:	ASCPC1
	ASCDSP
	ASCSPC
	ASCJMP

.SBTTL READ & WRITE VARIOUS PARTS OF CONS

XSTOP:	TST CTRUN
	BEQ XSTOP1
	TST 164002
	BMI XSTOP1
	CLR CTRUN		;LOSE, ERROR; NOT ONLY STOP, BUT STOP TRYING
;	CLR LMHTTY		;ALSO FLUSH TTY
XSTOP1:	MOV #0,164006		;STOP CONS
	CLR CRUN
	RTS PC

XDPB:	PUSH B			;DPB B IN BLOCK (A) AT POS IN C
	PUSH C
	MOVB 1(SP),U		;# BITS IN FIELD
	ASL U
	MOV XXMSK(U),C		;MASK FOR FIELD
	BIC C,B			;CLEAR ANY EXTRA BITS IN B
	COM C
	MOVB (SP),U		;# PLACES TO SHIFT
	JSR PC,XDPBS		;SHIFT IFY
	BIC C,(A)
	BIC T,2(A)
	BIC TT,4(A)
	MOV B,C
	MOVB (SP),U
	JSR PC,XDPBS
	BIS C,(A)
	BIS T,2(A)
	BIS TT,4(A)
	POP C
	POP B
XDPBX:	RTS PC

XDPBS:	CLR T
	CLR TT
XDPBS1:	TST U			;THREE PRECISION SHIFT OF C T TT AMT IN U
	BEQ XDPBX
	ASL C
	ROL T
	ROL TT
	DEC U
	BR XDPBS1

XDMDST:	MOV #<<5*400>+16>,C	;DEPOSIT IN M MEM PART OF DESTINATION
XDRDS1:	BIC #CAMEMB,2(A)	;TURN OFF A DEST BIT
XDDSP1:	EDPB
	RTS PC

XDRDST:	MOV #<<4*400>+16+5>,C	;DEPOSIT IN REG PART OF DESTINATION
	BR XDRDS1

XDDSPO:	MOV #<<10.*400>+16>,C	;DEPOSIT IN DISPATCH OFFSET FIELD
	BR XDDSP1


XRPDLB:	JSR PC,SVPDLI		;READ PDL BUFFER ADR IN B
	MOV #CMSCI,B		; STORE RESULT IN 2 WD BLOCK(A)
	EEXAMD			;READ DATA
RSPDLI:	PUSH A			;RESTORE PDL INDEX
	MOV #SVPITM,A
	BR RSPI1

XWPDLB:	JSR PC,SVPDLI		;WRITE PDL BUFFER ADR IN B FROM
	MOV #<CFDCI_5>,B	; DATA IN BLOCK(A)
	EDMM0
	BR RSPDLI

SVPDLI:	PUSH A
	MOV B,SVPDTM		;SAVE DESIRED NEW CONTENTS OR
	MOV #SVPITM,A		;PDL INDEX
	MOV #CMSPPI,B
	EEXAMD			;SAVE PDL INDEX
	BIC #176000,(A)+	;LEAVE JUST PI
	CLR (A)
	MOV #SVPDTM,A
RSPI1:	MOV #<CFDPI_5>,B
	EDMM0			;WRITE IN NEW CONTENTS
	MOV SVPDTM,B
	POP A
	RTS PC

SVPDTM:	0			;TEMP BLOCK HOLDING NEW DATA
	0
SVPITM:	0			;TEMP BLOCK HOLDING OLD PI
	0
	
XSURUP:	MOV #XSUTP,A		;SAVE ENTIRE USTACK
	MOV #CMSUS,B		;GET USTACK POINTER
	EEXAMD
	MOV #<<5*400>+27.>,B	;POINTER READS INTO THOSE BITS
	EXFLD
	RTS PC

XSUSTK:	TST USSVDF
	BNE XSUSTY		;ALREADY SAVED
	JSR PC,XSURUP		;READ U STACK PNTR
	MOV A,USTPNR
	MOV #32.,XSUSTC		;SAVE 32 REG
	ASL A			;CONVERT TO WDS
	ADD #USSVD,A		;GET ADR IN USTK IMAGE
XSUSTL:	MOV A,XSUSTP
	MOV #XSUTP,A
	MOV #CMSUSP,B		;USTACK DATA, POP
	EEXAMD
	EDCLK			;CLOCK WITH THAT IN IR TO POP
	MOV XSUSTP,A
	MOV XSUTP,(A)		;SALT DATA AWAY
	TST -(A)		;HARDWARE DECREMENTS ON POP
	DEC XSUSTC
	BEQ XSUSTX		;THRU
	CMP A,#USSVD
	BHIS XSUSTL
	MOV #USSVDE-2,A		;WRAP AROUND TO TOP
	BR XSUSTL
XSUSTX:	DEC USSVDF		;INDICATE SAVED
XSUSTY:	RTS PC	

XSUSTP:	0			;POINTER TO PLACE IN PDL BUFFER
XSUSTC:	0			;COUNT OF LOCNS
XSUTP:	0			;TEMP BLOCK
	0

XUUSTK:	TST USSVDF
	BEQ XUUSTX
XUUST1:	JSR PC,XSURUP		;READ USTACK PDL
	CMP A,USTPNR
	BEQ XUUST2		;GOT THAT RESTORED ..
	MOV #XSUTP,A
	MOV #CMSUSP,B
	EEXAMD			;BUMP IT BY ONE
	EDCLK			;CLOCK IT WITH THAT IN IR
	BR XUUST1		;TRY AGAIN!
XUUST2:	MOV #32.,XSUSTC
	INC A			;HARDWARE WILL INC BEFORE PUSH
	BIC #177740,A		;SET UP A TO POINT TO USSVD
	ASL A			; LOCN THAT WILL GET WRITTEN
XUUST4:	ADD #USSVD,A
XUUST3:	MOV (A)+,XSUTP		;HARDWARE INCRS ON PUSH
	MOV A,XSUSTP
	MOV #XSUTP,A
	CLR 2(A)		;MAYBE RUN A LITTLE FASTER (HA)
	MOV #<CFDUSP_5>,B	;RESTORE THAT ONE
	EDMM0
	DEC XSUSTC
	BEQ XUUSTX		;THRU
	MOV XSUSTP,A
	CMP A,#USSVDE
	BLO XUUST3
	CLR A
	BR XUUST4
XUUSTX:	CLR USSVDF		;NOW RESTORED
	RTS PC

XRDSP:	PUSH A			;READ DISPATCH MEMORY
	PUSH B			;FIRST SAVE DISPATCH CONSTANT REGISTER
	JSR PC,XDSPSU		;"SET UP" DISPATCH INST
	EWIR			;PUT THAT CONCONCTION IN IR ..
	MOV #XRDT,A		;READ IN PC SELECT BITS AND FIGURE OUT P AND R
	ERERWS			;READ IN ERROR WDS
	MOV XRDT+2,C
	BIC #177774,C		;GET PC SELECT BITS
	ASL C
	MOV XRDSTB(C),XRDSPW	;TRANSLATE TO WHAT THOSE TWO BITS REALLY MEAN
	MOV #XRDSB,A		;GET POINTER TO UINST AGAIN
	BIS #CMF1,(A)		;TURN ON MISC FCTN 1 (FORCE STRAIGHT DISPATCH)
	EWIR
	EDCLK			;EXECUTE INST
	MOV #XRDT,A
	ERPC			;READ IN PC
	MOV XRDT,C		;GOBBLE PC BITS
	BIS XRDSPW,C		;IOR IN P AND R BITS
	BIT #1_13.,164010	;TEST NO-OP CONDITION
	BEQ XRDS1
	BIS #CDMN,C		;N BIT MUST HAVE BEEN ON
XRDS1:	POP B
	POP A
	MOV C,(A)
	RTS PC

XRDSTB:	CDMR+CDMP	; (PC+1) IT WAS GOING TO FALL THRU, SO BOTH P AND R SET
	0		; (DSP)
	CDMR		; (SPC)  IT WAS GOING TO POPJ
	0		; (JMP)  ??

XRDSPW:	0		;TEMP FOR BUILDING UP WD
XRDT:	0		;TEMP BLOCK
	0
XRDSB:	0		;TEMP BLOCK FOR DISPATCH U INST
	0
	0

XDSPSU:	MOV #XRDT,A		;READ DISP CONST
	ERDSPC			; CAUTION!! TAKES DISP OFFSET ARG IN 2(SP) 
XDSPS1:	ESUSTK			;SAVE USTACK SINCE HACKING WITH
				;DISP MEMORY CAN CLOBBER IT
				; (REMOVE THIS WHEN HARDWARE MOD
				; MADE) 
	MOV #XRDSB,A		;DUMMY UP DISP INST
	EICLR
	BIS #CIDSP,4(A)
	MOV 2(SP),B		;GET DESIRED DISPATCH OFFSET
	EDDEST			;STORE IN DISPATCH OFFSET (SAME FLD AS DEST)
	MOV XRDT,B
	EDASRC			;PUT IN DISPATCH CONSTANT AS IT IS
	RTS PC

XWDSP:	PUSH A		;WRITE DISPATCH MEM
	PUSH B
	MOV (A),C
	BIC #100000,C	;THAT BIT TO BE PARITY
	JSR PC,PARCMP	;RETURN 0 OR -1 IN T
	BIC #77777,T	;LEAVE PARITY IN DESIRED PLACE
	BIS C,T	;OR IN REST OF BITS
	MOV T,XRDT	;SAVE THAT
	CLR XRDT+2
	MOV #XRDT,A
	CLR B
	EDMM0		;PUT DATA TO WRITE IN MM LOCN 0
	JSR PC,XDSPSU	;SET UP DISP INSTRUCTION
	BIS #CMF2,(A)	;MF2 IS WRITE DISPATCH MEM
	EWIR		;PUT IN IR
	EDCLK		;EXECUTE
	ENPCLK		;LET IT ACTUALLY GET WRITTEN
	POP B
	POP A
	RTS PC

PARCMP:	MOV #-1,T	;COMPUTE PARITY OF C
	TST C
	BEQ PARCMX	;SPECIAL CASE CHECK FOR 0 TO RUN FAST
	MOV #16.,TT	;RETURN T -1 OR 0 SUCH AS TO MAKE ODD PARITY
PARCM1:	ROL C
	BCC PARCM2
	COM T
PARCM2:	DEC TT
	BNE PARCM1
	ROL C		;RESTORE TO FORMER GLORY
PARCMX:	RTS PC

XRDSPC:	PUSH A		;READ DISP CONSTANT
	MOV #XRDCTB,A
	MOV #CMSDC,B
	EEXAMD
	MOV (A),@(SP)
	POP A
	RTS PC

XRDCTB:	0
	0

XWDSPC:	PUSH A		;WRITE DISP CONSTANT
	MOV (A),XRDT	;DESIRED CONTENTS OF DISP CONST REGISTER.
	CLR -(SP)	;PUT 0 IN DISP OFFSET (FOR RANDOMNESS,
	JSR PC,XDSPS1	; SHOULDNT MATTER)
	BIS #CMF1,(A)	;SET FORCE XFER BIT TO STOP ANY CLOBBERAGE OF
	EWIR		;U STACK OR U STACK POINTER
	EDCLK
	TST (SP)+
	POP A
	RTS PC

XDPBLK:	PUSH A		;DEPOSITIFY 4 WD BLOCK POINTED TO BY A
	MOV (A),A
	BLT XDPBL2	;MINUS -> COMBINATION BLOCK
	BEQ XDPBL1	;ADDRESS OF 0 IS NULL BLOCK
XCVMR2:	MOV (SP),C
	MOV #CNUM,T
	TST (C)+	;SPACE PAST REG ADR
	MOV (C)+,(T)+
	MOV (C)+,(T)+
	MOV (C),(T)
	MOV #-1,CNUMF	;INDICATE NUMBER TYPED
	MOV #QDEPV,B
	JSR PC,REGDC
XDPBL1:	POP A
	RTS PC

XDPBL2:	NEG A
	ASL A
	CMP A,#XCBLTL
	BHIS XDPBL1	;IGNORE IF TOO HIGH
	JMP @XCBLT-2(A)

XCBLT:	XCVMR		;VIRTUAL MEMORY READ
	XCPMR		;PHYSICAL MEMORY READ
XCBLTL==.-XCBLT+2

XCPMR:	MOV #RACPMR,A	;CONSOLE PHYSICAL VMA, START READ
	BR XCPMR1

XCVMR:	MOV #RACVMR,A	;CONSOLE VIRTUAL VMA, START READ
XCPMR1:	MOV #XCVMR1,-(SP)
	MOV 2(SP),-(SP)	;PUSH POINTER TO BLOCK TO FAKE OUT LOSING ROUTINE
	BR XCVMR2	; THIS WILL ALSO BE IN A ON RETURN

XCVMR1:	TST (A)+	;POINTER TO BLOCK IN A ON RETURN
	MOV CVMMRD,(A)+	;CLOBBER BACK CONSOLE READ DATA REG
	MOV CVMMRD+2,(A)+
	MOV CVMMPF,(A)	;HIGH WORD PAGE FAULT STATUS
	BR XDPBL1

XRDBLK:	PUSH A		;EXAMINIFY 4 WD BLOCK POINTED TO BY A
	MOV (A),A
	BLT XDPBL2	;COMBINATION OP, SAME AS ON WRITE
	BEQ XDPBL1
	MOV #QEXB,B	;CLEAR IT OUT TO MINIMIZE RANDOMNESS, ESPECIALLY IN
	CLR (B)+	;HIGH ORDER WORDS
	CLR (B)+
	CLR (B)
	MOV #QEXAMV,B
	CLR QEXPF	;DONT PRINT IT OUT
	JSR PC,REGDC	;EXAMINE STUFF AND LEAVE RESULT IN QEXB
	MOV (SP),A
	TST (A)+
	MOV #QEXB,B
	MOV (B)+,(A)+	;STORE DATA
	MOV (B)+,(A)+
	MOV (B),(A)
	BR XDPBL1

XRL1MP:	PUSH A		;READ LVL 1 MAP
	MOV #XRL1T1,A
	MOV #<<11.*400>+12.>,C	;SHIFT 12 TO MOVE INTO LVL1 PART OF VMA
	EDPB
	MOV #<CFDVMA_5>,B
	EDMM0		;PUT THAT IN VMA
	MOV #XRL1T2,A	;NOW READ MAP DATA
	MOV #CMSPMD,B
	EEXAMD
	MOV #<<5*400>+27.>,B	;GET LVL1 MAP PART
	ELDB
	MOV A,B
	POP A
	MOV B,(A)		;STORE AWAY DATA
	RTS PC

XRL1T1:	0		;TEMP TO CONSTRUCT VMA
	0

XRL1T2:	0		;TEMP TO READ BACK MAP DATA
	0

XWL1MP:	PUSH A		;WRITE LVL 1 MAP
	PUSH B
	MOV (A),B	;DATA TO WRITE
	MOV #XWL1T1,A
	MOV #<<5*400>+27.>,C	;PUT IN RIGHT PLACE
	EDPB
	MOV #<CFDMWD_5>,B
	EDMM0		;AND PUT THAT IN WRITE DATA REG
	POP B
	MOV #XRL1T2,A	;GENERATE RIGHT THING TO PUT IN VMA
	MOV #<<11.*400>+12.>,C	;SHIFT 12 TO MOVE INTO LVL1 PART OF VMA
	EDPB
	MOV #<CFDVWM_5>,B	;VMA WRITE MAP
	EDMM0			;WILL WRITE FIRST LVL MAP
	POP A
	RTS PC
		
XWL1T1:	0		;DATA TO WRITE (GOES TO MWD)
	0

XWL1T2:	0		;ADDRESS WD (GOES TO VMA WRITE MAP)
	0

XRL2A:	PUSH B		;SET UP ADDRESS FOR LVL 2 MAP
	MOV #XRL2T1,A	;WRITE HIGH 5 BITS OF ADDRESS IN LVL1 MAP LOCN 0
	ASL B
	ASL B
	ASL B
	SWAB B
	BIC #177740,B
	MOV B,(A)
	CLR B
	EWL1MP
	MOV #XRL2T2,A	;PUT LOW 5 BITS IN VMA WD
	POP B
	MOV #<<5*400>+7>,C
	EDPB
	RTS PC

XRL2MP:	PUSH A		;READ LVL 2 MAP
	JSR PC,XRL2A		;PUT RIGHT THING IN LVL 1 MAP AND GEN RIGHT THING
				;FOR VMA
	MOV #<CFDVMA_5>,B	;NOW PUT THAT IN VMA
	EDMM0
	MOV #XRL2T3,A		;READ VMA DATA
	MOV #CMSPMD,B
	EEXAMD
	MOV #<<4*400>+16.+7>,B	;LDB HIGH DATA WD
	ELDB
	MOV (SP),B
	MOV A,2(B)		;STORE HIGH DATA WD
	MOV #XRL2T3,A
	MOV #<<16.*400>+7>,B
	ELDB			;LDB LOW DATA WD
	MOV A,@(SP)		;STORE LOW DATA WD
XWL2M1:	MOV #1,CL1M0F		;INDICATE LVL 1 MAP LOCN 0 HAS BEEN HACKED
	POP A			; (NOT NECESSARILY TO 0)
	RTS PC

XRL2T1:	0		;LVL 1 MAP DATA

XRL2T2:	0		;VMA ADR WD
	0

XRL2T3:	0		;MAP DATA READ BACK
	0

XWL2MP:	PUSH A		;WRITE 2ND LVL MAP
	JSR PC,XRL2A	;GENERATE RIGHT THING TO PUT IN VMA
			;MUST DO THIS FIRST SINCE IN WRITES IN 1ST LVL MAP
			;AND CLOBBERS MWD.  LEAVE STUFF TO PUT IN VMA  IN
			;XRL2T2
	MOV (SP),A
	MOV 2(A),B	;SET UP DATA FOR MWD (HIGH WD)
	MOV #XWL2T1,A
	MOV #<<4*400>+16.+7>,C
	EDPB
	MOV @(SP),B	;SET UP DATA FOR MWD (LOW WD)
	MOV #<<16.*400>+7>,C
	EDPB
	MOV #<CFDMWD_5>,B
	EDMM0		;PUT THAT IN MWD
	MOV #XRL2T2,A	;GET BACK POINTER TO STUFF TO PUT IN VMA
	MOV #<CFDVWM_5>,B
	EDMM0		;PUT IT IN VMA WRITE MAP
	BR XWL2M1	;CLR OUT LVL 1 MAP LOCN 0 AGAIN

XWL2T1:	1		;SET UP DATA FOR MWD (1 SELECTS 2ND LVL MAP)
	0

XRMEMS:	PUSH A
	PUSH B
	MOV #CSVMA,A		;SAVE MEM SUBROUTINE
	MOV #CMSVMA,B
	EEXAMD			;SAVE VMA
	MOV #CSPMD,A
	MOV #CMSPMD,B
	EEXAMD			;SAVE PAGE FAULT STATUS
	MOV #CSMWD,A
	MOV #CMSMWD,B
	EEXAMD			;SAVE MWD
	MOV #CSMRD,A
	MOV #CMSMMD,B
	EEXAMD			;SAVE MAIN MEMORY READ DATA
	CLR CSMRDF		;AND INDICATE IT HASNT CHANGED
	MOV #CL1M0,A
	CLR B
	ERL1MP			;SAVE 1ST LEVEL MAP, LOCN 0
	CLR CL1M0F		; VALID IN HARDWARE STATE
	MOV #CL2M0,A
	CLR B
	ERL2MP
	CLR CL2M0F		;CLR HACKED WITH 2ND LVL MAP, LOCN 0 FLAG
	POP B			; (SINCE ITS SUCH A PAIN TO RELOAD)
	POP A
	RTS PC

XWMEMS:	PUSH A			;RESTORE MEMORY SUBROUTINE
	PUSH B			;NOTE: THIS ROUTINE CAN ALSO BE CALLED WITH THE 
	TST CSMRDF		; INTENTION OF "VALIDIFING" THE MEM SUBROUTINE
	BEQ XWMEM1		;XFER ON READ DATA MEMORY REG HASNT BEEN CHANGED
	MOV #CSMGBR,A		;TRY TO RESTORE IT
	EWPVMA			; BY WRITING IN A GARBAGE REGISTER AND
	MOV #CSMRD,A		; READING IT BACK
	MOV #<CFDMWD_5>,B
	EDMM0			;PUT DATA IN MWD
	EMMWC			;DO MAIN MEM WRITE CYCLE
	EMMRC			;DO MAIN MEM READ CYCLE, GETTING IT BACK!!
XWMEM1:	TST CL2M0F
	BEQ XWMEM2
	MOV #CL2M0,A
	CLR B
	EWL2MP			;RESTORE LVL 2 MAP, LOCN 0
XWMEM2:	TST CL1M0F
	BEQ XWMEM3
	MOV #CL1M0,A
	CLR B
	EWL1MP			;RESTORE LVL 1 MAP, LOCN 0
	CLR CL1M0F		;SINCE IF VALIDIFING, ITS NO LONGER NECESSARILY 0
XWMEM3:	MOV #CSMWD,A
	MOV #<CFDMWD_5>,B
	EDMM0			;RESTORE MWD
	MOV #CSVMA,A
	MOV #<CFDVMA_5>,B
	EDMM0			;RESTORE VMA
	BIT #1,CSPMD		;RESTORE PAGE FAULT STATUS
	BEQ 1$
	MOV #SETRPF,A
	JSR PC,XWIR
	JSR PC,XDCLK
	JSR PC,XNPCLK
	BR 2$

1$:	BIT #2,CSPMD
	BEQ 2$
	MOV #SETWPF,A
	JSR PC,XWIR
	JSR PC,XDCLK
	JSR PC,XNPCLK
2$:	POP B
	POP A
	RTS PC

XVMEMS:	PUSH A			;VALIDIFY MAPS FOR CONSOLE VIRTUAL
	PUSH B			; READ OR WRITE CYCLE
	TST CL2M0F
	BEQ XVMEM2
	MOV #CL2M0,A
	CLR B
	EWL2MP			;RESTORE LVL 2 MAP, LOCN 0
	CLR CL2M0F		;REMEMBER THAT IT IS RESTORED
XVMEM2:	TST CL1M0F
	BEQ XVMEM3
	MOV #CL1M0,A
	CLR B
	EWL1MP			;RESTORE LVL 1 MAP, LOCN 0
	CLR CL1M0F		;REMEMBER THAT IT IS RESTORED
XVMEM3:	POP B
	POP A
	RTS PC

XMMRC:	MOV #XMMRI,A		;DO MAIN MEM READ CYCLE
	BR XMMWC1

XMMWC:	MOV #XMMWI,A		;DO MAIN MEM WRITE CYCLE
XMMWC1:	EWIR
	EDCLK
	RTS PC

XMMWI:	<COBA_12.>+<USETM_4>	;O-BUS FROM ALU, ALU-OP SETM
	<CMSVMA_8>+<CFDVMW_3>	;M-SRC VMA, FDST VMA-START-WRITE
	CIALU

XMMRI:	<COBA_12.>+<USETM_4>
	<CMSVMA_8>+<CFDVMR_3>	;M-SRC VMA, FDST VMA-START-READ
	CIALU

XWPVMA:	PUSH A			;WRITE "PHYSICAL" VMA
	PUSH B
	MOV (A)+,XWPVT1
	MOV (A),XWPVT1+2
	TST CL1M0F
	BLT XWPVM1		;0 ALREADY THERE
	MOV #CZERO,A
	CLR B
	EWL1MP			;MAKE SURE LEVEL 1 MAP LOCN 0 POINTS TO LEVEL 2 LOCN 0
	MOV #-1,CL1M0F
XWPVM1:	MOV #XWPVT1,A
	PUSH (A)		;SAVE LOW VMA BEFORE CLOBBERING IT
	BIS #1,(A)		;SELECT 2ND LVL MAP
	BIS #3000,2(A)		;SET VALID AND WRITE OK
	MOV #<CFDMWD_5>,B
	EDMM0			;PUT THAT IN MWD
	MOV #CZERO,A
	MOV #<CFDVWM_5>,B
	EDMM0			;PUT ZERO ON VMA, WRITE MAP (WRITES LVL2 MAP LOCN 0)
	MOV #1,CL2M0F		;FLAG HACKED WITH LVL 2 MAP LOCN 0
	MOV #XWPVT1,A		;RESTORE A
	POP (A)			;GET BACK LOW VMA
	BIC #177600,(A)		;BITS WITHIN PAGE REALLY COME FROM VMA
	CLR 2(A)		;REST DONT (SELECT LOCN 0, LVL 1 AND 2  MAPS)
	MOV #<CFDVMA_5>,B
	EDMM0			;PUT THAT IN VMA
	POP B
	POP A
	RTS PC

XWPVT1:	0
	0

CZERO:	0
	0
	
SETRPF:	010760		;((VMA-START-READ) VMA)
	.BYTE 50,62
	0
	
SETWPF:	010760		;((VMA-START-WRITE) VMA)
	.BYTE 60,62
	0

.SBTTL TRAP HANDLER

TRPBRK:	CMP SP,#PDL+30	;TRP BRK
	BLO ISTKO
	BIC #17,2(SP)		;CLEAR PROCESSOR FLAGS ON RETURN
	JSR U,ACSAV		;PUSHES 5 FROBS (+1 FOR JSR)
	MOV <5+1>*2(SP),U	;GET RETURN PC
	MOV -(U),U
	ASL U
	CMP U,#TWHTRP
	BHI BADTRP
	JSR PC,@TRPTAB-TWLTRP(U)
TRPRET:	JSR U,ACRES
	RTI

TRPERX:	BIS #1,<6+1+1>*2(SP)	;SET CARRY ON RETURN
	RTS PC

JFATL:	BPT
ISTKO:	BPT
BADTRP:	BPT

LTRP=TRP!0
TWLTRP=LTRP+LTRP
TRPTAB:	JFATL		;TRP 0
	JPNFLD		; 1
	JPSFLD		; 2

HTRP=TRP!<<.-TRPTAB>/2>
TWHTRP==HTRP+HTRP

JPNFLD:	CMP B,#<17.*400>
	BGE JPNF1	;FIELD > 16. BITS
JPNF2:	EXFLD		;PRINT NUMERIC FIELD
	MOV B,C
	SWAB C
	BIC #177400,C		;GET # OF BITS IN C
	MOVB JPNTAB(C),C	;CONVERT TO # OF DIGITS
	JSR PC,OCTPN
	MOV #' ,A
	JMP ADDCHR

JPNF1:	PUSH A
	PUSH B
	ADD #170020,B		;.BYTE -20,20
	JSR PC,JPNFLD	;PRINT OUT HIGH PART (S)
	POP B
	POP A
	BIC #177400,B
	BIS #<16.*400>,B	;PRINT 16 BITS AT ORIGINAL POSITION
	BR JPNF2

JPNTAB:	<1*400>+1
	<1*400>+1
	<2*400>+2
	<3*400>+2
	<3*400>+3
	<4*400>+4
	<5*400>+4
	<5*400>+5
	<6*400>+6
	<6*400>+6

JPSFLD:	PUSH C
	EXFLD
	ASL A
	ADD (SP)+,A
	MOV (A),A
	JMP PTEXT


.SBTTL SAVE & RESTORE STATE OF MACHINE

ENTER:	JSR PC,PSCONS		;ENTER, SAVING STATE AS APPRO TO CLLMOD
	TST CLLMOD
	BNE ENTERX
	JSR PC,FSCONS		;HIGH LVL MODE, DO FULL
ENTERX:	RTS PC

LEAVE:	JSR PC,FRCONS		;LEAVE, RESTORING WHAT SAVED
	JSR PC,PRCONS
	RTS PC

PSCONS:	TST CPSVAL		;DO PASSIVE STATE CHANGE..
	BNE PSCONX		;STATE ALREADY SAVED
	MOV #CCERR1,A		;"PASSIVE" STATE SAVE
	ERERWS			;READ ERROR WDS
	MOV #CPC,A		;SAVE STATE OF CONS PROCESSOR
	ERPC			; (AS BEST AS CAN)
	MOV #CIR,A
	ERIR
	MOV #COBUS,A
	EROBUS
;	BIT #CESRUN,CCERR1  ;THIS BIT STAYS ON IF MACHINE STOPS FOR ERROR SO..
;	BNE PSCONX		;MACHINE STILL RUNNING, THIS FAIRLY RANDOM
	INC CPSVAL		;INDICATE STATE SAVED
	CLR NOOPF		;IS NEXT INST TO BE NO-OP ED?
	BIT #CEINOP,CCERR2
	BEQ PSCONX
	INC NOOPF		;YEP, THAT INST A LOSER
PSCONX:	RTS PC


FSCONS:	TST CFSVAL		;DO FULL STATE SAVE
	BNE FSCONX		;FULL STATE ALREADY SAVED
	ESTOP			;STOP MACHINE, CLEAR CRUN, LEAVE CTRUN ALONE.
	JSR PC,PSCONS		;DO PASSIVE SAVE
	MOV #OLDPCS,A		;SAVE OLD PCS
1$:	MOV @#164002,(A)
	BIC #170000,(A)+
	MOV #40,164006
	MOV #0,164006
	CMP A,#OLDPCS+20
	BLO 1$
	MOV #CMMEM0,A
	CLR B
	EEXAMD			;SAVE M MEM LOCN 0
	MOV #CAMEM1,A
	MOV #CDAMEM+1,B
	EEXAMD			;SAVE A MEM LOCN 1
	ERMEMS			;SAVE MEM SUBROUTINE (VMA+MWD)
	INC CFSVAL		;INDICATE FULL SAVE VALID
FSCONX:	RTS PC

PRCONS:	CLR CPSVAL		;DO "RESTORE" AFTER PASSIVE SAVE
	RTS PC

FRCONS:	TST CFSVAL
	BEQ FRCONX
	EUUSTK			;RESTORE U STACK IF SAVED
	EWMEMS			;RESTORE MEM SUBROUTINE (VMA+MWD)
	MOV #CAMEM1,A		;DO RESTORE AFTER FULL SAVE
	MOV #CDAMEM+1,B
	EDMM0			;RESTORE A MEM LOCN 1
	MOV #CMMEM0,A
	CLR B
	EDMM0			;RESTORE M MEM LOCN 0
	MOV #OLDPCS,A		;RESTORE OPC HISTORY REGISTERS
1$:	PUSH A
	EWPC			;LOAD PC WITH WHAT IS TO GO IN OPCS
	POP A
	MOV #40,164006		;THEN CLOCK OPCS
	MOV #0,164006
	TST (A)+
	CMP A,#OLDPCS+20
	BLO 1$
	MOV CPC,CPCT		;COPY PC
	DEC CPCT		;COMPENSATE FOR THE FACT IT WILL GET INCREMENTED
	MOV #CPCT,A		;WHEN IR IS RELOADED
	EWPC
	MOV #CIR,A
	EWIR			;PUT IR BACK (THIS INCRS THE PC)
	CLR CFSVAL		;CLEAR FULL SAVE VALID
FRCONX:	RTS PC
	

.SBTTL TEST LOOPS

TL2:	MOV #TL2DTA,A		;DEST DEPOSIT IN DATA PATH MEM 
	CLR TL2DTA		; M LOCN 10 INITIALLY
	MOV CSR,TL2DTA+2
	MOV #10,B		;DEST M MEM LOCN 10
	EDMM0
	BCS TL2B
	JMP TL2

TL2B:	INC TL2DTC
	JMP TL2

TL2DTA:	0
	0
TL2DTC:	0

TL3:	MOV #377,TL3T1		;A MEM LOCN
TL3A:	MOV TL3T1,TL3T2		;ADDRESS TEST ON A MEM
	MOV TL3T1,TL3T2+2
	MOV #TL3T2,A
	MOV TL3T1,B
	BIS #CDAMEM,B
	EDMM0
	DEC TL3T1
	BGE TL3A
TL3B:	MOV #377,TL3T1
TL3C:	MOV #TL3T2,A
	MOV TL3T1,B
	BIS #CDAMEM,B
	EEXAMD
	CMP TL3T1,TL3T2
	BNE TL3L
	CMP TL3T1,TL3T2+2
	BNE TL3L
TL3D:	DEC TL3T1
	BGE TL3C
	JMP TL3

TL3L:	INC TL3LC
	JMP TL3D

TL3T1:	0
TL3T2:	0
	0
TL3LC:	0

TL4:	CLR TL4T1		;TEST ABILITY TO WRITE PC
TL4A:	MOV #TL4T2,A
	EICLR			;CLEAR 3 WD BLOCK
	BIS #CIJMP,4(A)
	MOV TL4T1,B
	EDJPC
	BIS #47,(A)	;SET TEST CONDITION AND UNCONDITONAL CONDITION
	EWIR		;LOAD INTO IR
	EDCLK		;EXECUTE IT
	MOV #TL4T3,A
	ERPC
	CMP TL4T3,TL4T1
	BNE TL4L
TL4L1:	INC TL4T1
	BIC #170000,TL4T1
	BR TL4A

TL4L:	INC TL4LC
	BR TL4L1

TL4LC:	0
TL4T1:	0
TL4T2:	0
	0
	0
TL4T3:	0

TL5:	CLR TL5T1		;DATA TEST ON CONTROL MEM
TL5A:	EUICLR
	MOV CSR,(A)
	MOV CSR,2(A)
	MOV CSR,4(A)
	BIC #177000,4(A)	;THATS HOW MANY THERE ARE
	MOV TL5T1,B
	EDCMEM
	MOV #TL5T2,A
	MOV TL5T1,B
	EEXAMC
	BIC #177000,TL5T2+4	;DONT TRY TO CHECK PARITY FOR NOW
	CMP UI,TL5T2
	BNE TL5L
	CMP UI+2,TL5T2+2
	BNE TL5L
	CMP UI+4,TL5T2+4
	BNE TL5L
TL5L1:	INC TL5T1
	BIC #170000,TL5T1	;MASK TO CNTRL MEM SIZE
	JMP TL5A

TL5L:	INC TL5LC
	JMP TL5L1

TL5LC:	0
TL5T1:	0
TL5T2:	0
	0
	0

TL6:	CLR TL6T1		;ADDRESS TEST ON CONTROL MEM
	MOV CSR,CSRSV
TL6C:	EUICLR
	MOV TL6T1,(A)
	MOV TL6T1,2(A)
	MOV TL6T1,4(A)
	TST CSRSV
	BGE TL6A
	COM (A)
	COM 2(A)
	COM 4(A)
TL6A:	BIC #177000,4(A)
	MOV TL6T1,B
	EDCMEM
	INC TL6T1
	BIC #170000,TL6T1	;MASK TO CNTRL MEM SIZE
	BNE TL6C
TL6D:	MOV #TL6T2,A
	MOV TL6T1,B
	EEXAMC
	BIC #177000,TL6T2+4
	MOV TL6T1,A
	TST CSRSV
	BGE TL6E
	COM A
TL6E:	CMP A,TL6T2
	BNE TL6L
	CMP A,TL6T2+2
	BNE TL6L
	BIC #177000,A
	CMP A,TL6T2+4
	BNE TL6L
TL6B:	INC TL6T1
	BIC #170000,TL6T1	;MASK TO CNTRL MEM SIZE
	BNE TL6D
	JMP TL6

TL6L:	INC TL6T3
	JMP TL6B

TL6T1:	0
TL6T2:	0
	0
	0
TL6T3:	0
CSRSV:	0

TL7:	CLR TL7T1		;ADDRESS TEST ON PDL BUFFER
	MOV CSR,CSRSV
TL7A:	MOV TL7T1,A
	TST CSRSV
	BGE TL7B
	COM A
TL7B:	MOV A,TL7T2
	MOV A,TL7T2+2
	MOV #TL7T2,A
	MOV TL7T1,B
	EWPDLB
	INC TL7T1
	CMP TL7T1,#2000
	BNE TL7A
	CLR TL7T1
TL7C:	MOV TL7T1,B
	MOV #TL7T3,A
	ERPDLB
	MOV TL7T1,C
	TST CSRSV
	BGE TL7D
	COM C
TL7D:	CMP TL7T3,C
	BNE TL7L
	CMP TL7T3+2,C
	BNE TL7L
TL7L1:	INC TL7T1
	CMP TL7T1,#2000
	BNE TL7C
	JMP TL7

TL7L:	INC TL7LC
	JMP TL7L1

TL7LC:	0
TL7T1:	0
TL7T2:	0
	0
TL7T3:	0
	0

.SBTTL DISPLAY INTERRUPT ROUTINES

.IFNZ GT40P

RETST:	PUSH	T
	PUSH	TT
	JSR	PC,RETBLK
	POP	TT
	POP	T
	RTS	PC

;DISPLAY INTERRUPT ROUTINES

LPBRK:	JSR	PC,DPYSAV
	BPT			;LIGHT PEN
	RTI
DTOBRK:	JSR	PC,DPYSAV
	BPT			;TIMEOUT/SHIFTOUT
	RTI

DPYSAV:	MOV	DPC,SAVDPC	;SAVE STATE OF DISPLAY
	MOV	DSR,SAVDSR
	MOV	XSR,SAVXSR
	MOV	YSR,SAVYSR
	RTS	PC

DSBRK:	PUSH	A
	PUSH	B
;;;;;;;	JSR	PC,DPYSAV
	CMP	OCSR,CSR	;CHECK SWITCH REGISTER OPTIONS
	BEQ	DSBRK1
	PUSH	C
	MOV	CSR,OCSR
	MOV	#1,A		;DON'T BLINK
	MOV	#DBLINK,B
	MOV	#DPYSPT,C
	COM	OCSR		;FAKE OUT SETDPY
	JSR	PC,SETDPY
	COM	OCSR
	ASL	A		;ITALICS
	MOV	#ITALICS,B
	MOV	#DPYSA,C
	JSR	PC,SETDPY
	POP	C
DSBRK1:	MOV	RETLAD,A
	BEQ	.+6
	JSR	PC,RETST	;FREE BLOCKS

DSBRK3:
;.IFNZ DLIMSW
;	TST	DSTOPD
;	BNE	DUNLIM		;BR IF WE WERE JUST RESTARTED BY CLOCK
;.ENDC
	MOV	@ADPC,A
	MOV	-2(A),B		;HALT INSTRUCTION
	BIC	#3,B
	CMP	#DPYSTP,B
	BNE	DSBERR		;ITS NOT A HALT!!!
	MOV	-2(A),B
	BIC	#177774,B
	ASL	B		;MAKE IT A WORD INDEX
	JMP	@.+4(B)		;DISPATCH

	DSBERR		;0 ERROR
	AJSR		;1 DPYJSR
	ARTS		;2 DPYRTS
	AJSI		;3 DPYJSI
;DISPLAY INTERRUPT CONTINUED

DSBERR:	TST	FORGIV		;TO ERR IS HUMAN (PROBABLY A TIMING SCREW)
	BNE	DSRET		;TO FORGIVE, DIVINE
	JSR	PC,DPYSAV
	BPT			;ILLEGAL INSTRUCTION
	BR	DSRET

AJSR:	TST	(A)+
	BEQ	DSRET		;DPYJSR 0 IS A NOOP
	JSR	PC,AJPUSH
	MOV	-(A),A		;JSR DESTINATION
	BR	DSRET

AJSI:	TST	(A)
	BEQ	DSRET		;DPYJSI 0 IS NOOP
	TST	@(A)+		;DPYJSI @0 IS ALSO NOOP
	BEQ	DSRET
	JSR	PC,AJPUSH
	MOV	@-(A),A
	BR	DSRET

AJPUSH:	INC	DPYPDC
	BLE	.+4
	BPT			;DISPLAY OVERPUSH
	SUB	#2,DPYPDP
	MOV	A,@DPYPDP
	RTS	PC

ARTS:	DEC	DPYPDC
	MOV	@DPYPDP,A
	ADD	#2,DPYPDP
DSRET:	MOV	@GETDPY,B
	BEQ	DSTART
	PUSH	A
	MOV	GETDPY,A
	MOV	2(A),(B)	;PUT CONTENTS IN ADDRESS
	CLR	(A)		;FREE THIS BUFFER
	MOV	-(A),B		;NEXT ON RING
	TST	(B)+		;POINT AT ADDRESS
	MOV	B,GETDPY
	POP	A
	BR	DSRET

;.IFNZ DLIMSW
;	CMP	A,#TXSTRT+2
;	BNE	DSTART
;	TST	DTIME		;READY TO DISPLAY TEXT
;	BEQ	DLIMIT		;BR IF IT TOOK<CLOCK TICK TO SHOW ALL LISTS
;DRSTRT:	CLR	DTIME
;.ENDC
DSTART:	MOV	A,@ADPC		;RESTART THE DISPLAY
DEXIT:	POP	B
	POP	A
	RTI

;.IFNZ DLIMSW
;DLIMIT:	MOV	A,DSTOPD	;SAVE DPC & SET FLAG
;	BR	DEXIT
;DUNLIM:	MOV	DSTOPD,A	;RESUME FROM LIMITING
;	CLR	DSTOPD
;	BR	DRSTRT
;.ENDC

SETDPY:	BIT	A,OCSR
	BNE	SETDP1
	BIC	B,(C)
	RTS	PC
SETDP1:	BIS	B,(C)
	RTS	PC
.ENDC ;GT40P

.SBTTL CLOCK INTERRUPT ROUTINE

CLKBRK:
;.IFZ DLIMSW
.IFZ TVP
	BPT			;CLOCK INTERRUPTS NOT ENABLED
.IFF ;TVP
	JSR PC,CRSCLK		;BLINK TV CURSOR
.ENDC ;TVP
	INC TIMEL		;MAKE 32 BIT 60 CYCLE COUNTER FOR LISPM
	BNE CLKBRX
	INC TIMEH
CLKBRX:
	RTI
;.ENDC
;.IFNZ PCHIST
;	CMP	PCPNT,#<PCBUF+PCBFL>
;	BLO	.+10
;	MOV	#PCBUF,PCPNT
;	MOV	(SP),@PCPNT
;	ADD	#2,PCPNT
;	MOV	2(SP),@PCPNT
;	ADD	#2,PCPNT
;.ENDC
;.IFNZ DLIMSW
;	INC	TICKS
;	TST	DSTOPD
;	BNE	CLKDS		;BR IF DISPLAY STOPPPED
;	INC	DTIME
;	RTI
;
;CLKDS:	MOV	#DLINT,@ADPC	;CAUSE DISPLAY INTERRUPT
;	RTI
;
;DLINT:	DPYSTP			;DISPLAY LIST TO CAUSE INTERRUPT
;.ENDC

.SBTTL 105 FOOBAR ROUTINE

;IF THE MACHINE IS STOPPED, AND SOMEONE HITS RIGHT-CTRL RIGHT-META CALL
;ON THE KNIGHT KEYBOARD, RESTART THE MACHINE.  SAVES WALKING TO THE OTHER ROOM.
FOO105:	TST CTRUN
	BMI FOO109		;JUMP IF RUNNING
	BIT #20000,164002	;ALSO TEST IF MACHINE REALLY RUNNING
	BNE FOO109		; (THIS EXPECIALLY FOR PDP-10 MODE)
	TST 164102
	BPL FOO109		;JUMP IF KEYBOARD NOT READY
	MOV 164100,-(SP)	;GET INPUT, CLEAR KEYBOARD (OK SINCE MACH STOPPED)
	COM (SP)		;COMPENSATE FOR BRAIN BUBBLES
	BIC #165700,(SP)	;CLEAR ALL BUT RIGHT CTL, RIGHT META, KEYCODE
	CMP (SP)+,#12020	;CHECK FOR CONTROL META CALL
	BNE FOO109
	MOV #1,CNUM		;1@G
	JSR PC,QG
	JSR PC,QDPGO		;^P
FOO109:	RTS PC

.SBTTL KEYBOARD INTERRUPT ROUTINE

TYIBRK:	TSTB	@AKLOS
	BEQ	TYIBRK
	PUSH A
	PUSH B
	MOVB	TKB,A
	BIC #177600,A		;LOSEY LOSEY
	TST TYIQF
	BMI TYIB1		;CHAR QUOTED
	CMP A,#'		;CNTRL X
	BEQ TYICX
	CMP A,#'		;CNTRL Q
	BEQ TYICQ
	TST TYIQM		;(LOOK FOR OTHER CONTROLS?) CHECK QUOTE MODE
	BEQ TYIB2		;NO
	CMP A,#'		;CNTRL S
	BEQ TYICS		; STOP LISP MACHINE
	CMP A,#'		;CNTRL D
	BEQ TYICD		; COMPLEMENT STATE OF DISPLAY CONSOLE SWITCH
TYIB2:	MOV #-1,CMREQ		;NOT TRYING TO ENTER MONITOR MODE NOW..
	TST CNHTTY
	BNE TYIMCM		;CONSOLE HAS THE TTY, FEED IT CHAR
;	TST LMHTTY
;	BNE TYIMCM		;LISP MACHINE HAS THE TTY, FEED CHAR TO CONSOLE
	BR TYIMGT		;NEITHER, FEED CHARACTER TO TTY LINE TO 10

TYIB1:	CLR TYIQF		;PROCESS CHAR WHICH HAS BEEN QUOTED
	BR TYIB2

TYICS:	CLR 164006		;STOP LISP MACHINE, ENTER CONSOLE MONITOR LOOP
	CLR CTRUN
	CLR CRUN
TYICX:	INC CMREQ		;CNTRL X TYPED
	BEQ TYIEX		;ON FIRST CNTRL X, TRY FOR GRACEFUL ENTRY
	ZAPFLG CNHTTY		;GRONK AND RESET WORLD
;	CLR LMHTTY
	JMP GO0			;(TRY TO ENTER CONSOLE LOOP)

TYICQ:	MOV #-1,TYIQF		;QUOTE FOLLOWING CHAR
	BR TYIEX

TYICD:	COM CONSF		;COMPLEMENT "DISPLAY CONSOLE" FLAG
	BR TYIEX

TYIMCM:	MOV A,TYICH		;LEAVE CHAR FOR CONSOLE MONITOR
	BR TYIEX

TYIMGT:	MOVB A,@AKLOB		;GT40 MODE SEND CHAR TO 10
TYIEX:	POP B
	POP A
	RTI

.SBTTL TTY LINE INPUT INTERRUPT ROUTINE

KLIBRK:	PUSH	A
	MOV	@AKLIB,A	;GET THAT CHARACTER
	BGE	.+4
	BPT			;DL11 HARDWARE ERROR
	BIC	#177600,A
	CMP	#177,A
	BEQ	KLIRET		;IGNORE PADDING ON INTERRUPT LEVEL
.IFNZ DEBUG
	MOVB	A,177566	;ECHO ON CONSOLE
.ENDC
	CMP	ACTCHR,#BUFSIZ
	BGE	KLIER
	INC	ACTCHR
	MOVB	A,@PUTCC
	CMP	ACTCHR,MAXACT
	BLE	.+10
	MOV	ACTCHR,MAXACT	;TO FIND A GOOD SIZE FOR BUFFER
	INC	PUTCC
	CMP	PUTCC,#BUFEND
	BLO	KLIRET
	MOV	#BUF,PUTCC
KLIRET:	POP	A
	RTI

KLIER:	BPT			;BUFFER OVERFLOWED
	BR	KLIRET

.SBTTL PROCESSOR TRAP ROUTINES

NXMFND:	PUSH	MEMTOP
	SUB	#2,T		;REGISTER HAS ALREADY BEEN INCREMENTED
	MOV	T,MEMTOP
	POP	T
	RTI

POWERF:	HALT
;	JSR	U,ACSAV
;	MOV	#POWERU,PWRPC
;	MOV	SP,SAVSP
;	HALT
POWERU:	HALT
;	RESET
;	MOV	#<7_5>,PS
;	MOV	#POWERF,PWRPC
;	MOV	SAVSP,SP
;	MOV	#100,A		;RENABLE ALL INTERRUPTS
;	MOV	A,TKS
;	MOV	A,@AKLIS
;.IFNZ DLIMSW
;	MOV	A,LKS
;	CLR	DSTOPD
;	CLR	DTIME
;.ENDC
;	MOV	#DPYSA,@ADPC
;	JSR	U,ACRES
;	RTI

;VARIAOUS PROCESSOR ERRORS COME HERE

NXMBRK:	BPT
	RTI

IOTBRK:	BPT
	RTI

RESBRK:	BPT
	RTI

RUGBRK:	TST CSR		;THERE'S NO RUG IN THIS LOSING MACHINE
	BMI BPTBRK	;SIGN OF SWITCHES => STOP FOR CARPET
	JMP GO0		;OTHERWISE REINITIALIZE PROGRAM

;BPT BREAKS COME HERE IF THERE IS NO RUG.
;DON'T WANT TO HALT THE 11 SINCE 11TEN INTERFACE WOULDN'T BE ABLE TO GET TO BUS.
;WANT TO PUT CONTENTS OF REGISTERS IN CORE WHERE CARPET CAN GET AT THEM.

BPTBRK:	.REPT 7			;SAVE THE ACS
	 MOV %0+.RPCNT,BPTACS+<2*.RPCNT>
	.ENDR

	WAIT			;PUT 000001 IN LIGHTS (11/05)
	BR .			;WAIT FOR RELOAD OR MANUAL INTERVENTION
				;BRANCH TO POINT SO STUFF WILL AUTOMATICALLY START IT.
	.REPT 7			;PROCEED
	 MOV BPTACS+<2*.RPCNT>,%0+.RPCNT
	.ENDR
	RTI

BPTACS:	.BLKW 7

.SBTTL WAIT FOR COMMAND FROM 10 OR KEYBOARD TYPEIN

GETCH1:	TST TENMOD
	BNE GETCH0
	JSR PC,WATST		;STARTING A WAIT, LOAD IR
GETCH0:	WAIT
GETCHW:	CLR A
	TST CMREQ		;WANT TO GO TO CONSOLE MONITOR
	BGE GETC1		;RETURN NULL CHAR
	TST LDBFF2
	BNE 1$
	TST LDBUFF		;COMMANDS FROM 10 APPEARED?
	BEQ GETCH2
1$:	JSR PC,C10CM		;YEP, HACK THEM
GETCH2:	TST DSKRQB		;REQUEST FROM 10?
	BEQ 2$			;NO
	JSR PC,DSKRUN		;YES, RUN THE DISK
2$:	JSR PC,FOO105		;CHECK FOR 105 FOOBAR REQUEST
	TST	ACTCHR
	BLE	GETCH1		;WAIT TILL CHARS IN BUFFER
GETCHR:	DEC	ACTCHR
	MOVB	@GETCC,A
	INC	GETCC
	CMP	GETCC,#BUFEND
	BLO	GETC1
	MOV	#BUF,GETCC
GETC1:	RTS	PC

C10CM:	ZAPFLG TNRQFG
	MOV #LDBUF,A
	MOV #LDBUFF,-(SP)
	MOV #<LDBUF+LDBUFL>,-(SP)
	TST LDBUFF
	BEQ C10CM2
	BGT CLDR1		;DEPOSIT IN REGISTER ADRS
CEXR1:	TST (A)			;EXAMINE REGISTER ADRS
	BEQ CEXRX		;EXIT ON ZERO (SAVES A BIT OF TIME)
	ERDBLK
	ADD #<4*2>,A
	CMP A,(SP)
	BLO CEXR1
	BR CEXRX

CLDR1:	TST (A)
	BEQ CEXRX		;SAVE A BIT OF TIME
	EDPBLK
	ADD #<4*2>,A
	CMP A,(SP)
	BLO CLDR1
CEXRX:	TST (SP)+
	CLR @(SP)+		;CLEAR FLAG FOR BUFFER THAT GOT SERVICED
	CLR TNRQFG
	RTS PC

C10CM2:	MOV #LDBFF2,2(SP)
	MOV #<LDBUF2+LDBUFL>,(SP)
	MOV #LDBUF2,A
	TST LDBFF2
	BGT CLDR1
	BEQ CEXRX
	BR CEXR1

.SBTTL RUN DISK FOR 10

;A REQUEST IS 5 WORDS:
; COMMAND REG, TRACK REG, DUSH REG, LM CORE ADD, LM PAGE COUNT

;BASHES ALL REGISTERS
DSKRUN:	CLR DSKRQB+2		;CLEAR SUCCESSFULL TRANSFER COUNT
	MOV DSKRQB,A		;GET REQUEST COUNT
	BLE DSKRNE
	MOV #DSKRQB+4,B		;POINTER TO FIRST REQUEST
DSKRN0:	MOV #164320,C		;SET UP THE UNIBUS MAP (USE MAP REGS 10 AND UP)
	MOV 6(B),T		;CORE ADD
	BIS #100000,T		;WRITE PERMIT
	MOV 8(B),TT		;PAGE COUNT
1$:	MOV T,(C)+		;STORE MAP
	INC T			;NEXT PAGE
	DEC TT
	BGT 1$
20$:	TSTB 176700		;MAKE SURE DISK CONTROL IS IDLE
	BPL DSKRNE		;IF NOT, TREAT AS ERROR
	MOV 4(B),176702		;DUSH
	MOV #150000,176704	;CA<15:0>.  CA<17:16> IS CMD<13:12>, BUT FORTUNATELY IT'S ZERO.
	MOV 8(B),T		;PAGE COUNT
	SWAB T			;400 PDP11 WORDS PER PAGE
	NEG T
	MOV T,176706		;-WC
	MOV 2(B),176710		;TRACK
	MOV (B),176700		;COMMAND
DSKRN2:	TSTB 176700		;AWAIT COMPLETION	
	BPL DSKRN2
	TST 176700		;CHECK ERROR SUMMARY
	BMI DSKRNE		;LOSE
	INC DSKRQB+2		;WIN
	ADD #10.,B		;NEXT REQUEST
	DEC A			;COUNT
	BGT DSKRN0
	MOV #-1,DSKRQB+2	;WON ON ALL TRANSFERS
DSKRNE:	CLR DSKRQB		;AWAKEN, MONSTER
	RTS PC

.SBTTL PUT CHARACTER ON SCREEN

TYOCHR:	JSR PC,TVPREP
	CMP A,#12
	BEQ TYOCH1		;JUST CLEAR LINE ON LF
	CMP A,#15
	BNE ADDCHR		;NORMAL CHR
	JSR PC,CLEOL		;CLEAR REST OF THIS LINE
	JSR PC,CR		; (INCLUDING CLEAR LINE ON CR, LF)
	TST RAIDM
	BEQ TYOCH2		;NOT IN RAID MODE, USE WHOLE SCREEN
	MOV CLINE,A
	INC A
	CMP A,CDLNN
	BLT TYOCH2		;STILL GOING TO BE ABOVE CONSOLE AREA
RDHU:	CLR B			;HOME UP TO BOTTOM OF ACTIVE RAID AREA
	MOV #RAIDA,A		;COUNT LINES IN USE
RDHU1:	TST (A)+
	BEQ RDHU2		;THAT ONE ISNT
	INC B
RDHU2:	CMP A,#RAIDA+<10*2>
	BLO RDHU1		;LOOP
	CLR A
	JSR PC,CSRPOS		;POSITION CURSOR THERE
	BR TYOCH1

TYOCH2:	JSR PC,LF
TYOCH1:	JSR PC,CLEOL
TYOCHX:	CLR BLKDFR
	RTS PC

TVPREP:
.IFNZ TVP
	MOV #PPVAR,U
	JSR PC,BLKOFF
.ENDC ;TVP
	RTS PC

ADDCHR:	BIC #177600,A
.IF NZ TVP
	PUSH U
	JSR PC,TVPREP
	CMP	#40,A
	BGT	FORMAT		;CONTROL CHARACTER
	JSR PC,TVO
ADDCRT:	CLR BLKDFR
	POP U
.ENDC ;TVP
.IFNZ GT40P
	CMP	#40,A
	BGT	FORMAT		;CONTROL CHARACTER
	CMP	CPOS,#MCHRPL
	BGE	RTSPC1		;IGNORE OVERFLOW
PUTCHR:	TST	OPENSW
	BNE	PUTCH1
	JSR	PC,OPNLIN	;OPEN UP THIS LINE
PUTCH1:	CMP	CPOS,BYTCNT
	BLT	PUTCH2
	MOV	CPOS,BYTCNT	;IN CASE WE LINE FED OR MOVED UP FROM FULL LINE TO NEARLY EMPTY ONE
PUTCH6:	INC	BYTCNT
PUTCH2:	MOVB	A,@LINPNT
PUTCH3:	INC	LINPNT
	INC	CPOS
	ADD	#CHRWD,CURSX
.ENDC ;GT40P
RTSPC1:	RTS	PC

;HERE FOR CONTROL CHARACTER

FORMAT:	ASL	A
.IFNZ GT40P
	JMP	@DPTAB(A)
.ENDC ;GT40P
.IFNZ TVP
	JSR PC,@DPTAB(A)
	BR ADDCRT
.ENDC ;TVP

DPTAB:	FORMA1	;^@ 00
	FORMA1	;^A 01
	FORMA1	;^B 02
	FORMA1	;^C 03
	FORMA1	;^D 04
	FORMA1	;^E 05
	FORMA1	;^F 06
	BELL	;^G 07
	BS	;^H 10
	TAB	;^I 11
	LF	;^J 12
	ALT	;^K 13
	FORMA1	;^L 14
	CR	;^M 15
	FORMA1	;^N 16
	FORMA1	;^O 17
	FORMA1	;^P 20
	FORMA1	;^Q 21
	FORMA1	;^R 22
	FORMA1	;^S 23
	FORMA1	;^T 24
	FORMA1	;^U 25
	FORMA1	;^V 26
	FORMA1	;^W 27
	CFS	;^X 30 MOVE FORWARD
	CLRCHR	;^Y 31 CLEAR CHARACTER
	MU	;^Z 32 MOVE UP
	ALT	;^[ 33 ALT-MODE
	HD	;^\ 34 HOME DOWN
	HU	;^] 35 HOME UP
	CLEOL	;^^ 36 CLEAR TO END OF LINE
	CLEOF	;^_ 37 CLEAR TO END OF FILE

.IFNZ GT40P

BELL:	CLR	DSR		;TRYING TO WRITE DSR CAUSES BEEP
ALT:
FORMA1:	RTS	PC

BS:	BIT	#1_2,CSR
	BEQ	MB		;IF OPTION NOT CHOSEN, JUST MOVE BACK
	CMP	CPOS,#MCHRPL
	BGE	RTSPC1
	SUB	#CHRWD*2,CURSX	;TO COMPENSATE FOR MOVING IT FWD ONE
	MOV	#10,A
	BR	PUTCHR		;NOW INSERT BS

MB:	TST	CPOS		;MOVE BACK
	BEQ	CRTSPC
	CMP	LINPNT,#OPENSW
	BLOS	MB1		;AT BEGINNING OR LINE NOT OPEN
	DEC	LINPNT
MB1:	DEC	CPOS
	SUB	#CHRWD,CURSX
	RTS	PC

TAB:	CMP	CPOS,#MCHRPL
	BGE	CRTSPC
	MOV	#40,A		;AT LEAST ONE SPACE
	JSR	PC,ADDCHR
	BIT	#7,CPOS
	BNE	TAB
	RTS	PC

CR:	CLR	CPOS
	CLR	CURSX
	MOV	#OPENSW,LINPNT
	RTS	PC

CFS:	CMP	CPOS,#MCHRPL	;FORWARD SPACE
	BGE	CRTSPC
	BIT	#1_2,CSR
	BEQ	PUTCH3
	TST	OPENSW		;IF INSERTING BS, BE A BIT CLEVER ABOUT FS
	BNE	.+6
	JSR	PC,OPNLIN
	JSR	PC,PUTCH3	;GO PAST A CHAR
	CMPB	@LINPNT,#10	;IS NEXT CHAR A BS?
	BNE	FORMA1		;NO
	SUB	#CHRWD*2,CURSX
	JSR	PC,CFS		;RECURSIVELY GO PAST BACKSPACE
	BR	PUTCH3		;NOW GO PAST A REAL CHAR TO GET TO RIGHT COLUMN

LF:	TST	@TEXTP
	BEQ	LF1		;LINE DIDN'T EXIST (YET)
	TST	OPENSW
	BEQ	LF2		;LINE NEVER OPENED
LF1:	JSR	PC,CLSLIN	;CLOSE THE LINE
LF2:	MOV	TEXTP,A
	MOV	NXTIDX-TXTIDX(A),A
	ADD	#TXTIDX,A
	MOV	A,TEXTP
	INC	CLINE
	SUB	#CHRHT,CURSY
	CMP	CLINE,#CHRLN-1
	BLE	CRTSPC		
	JMP HU			;AT BOTTOM, GO TO TOP
CRTSPC:	RTS	PC

HD:	JSR	PC,CR
HD1:	CMP	CLINE,#CHRLN-1
	BGE	HD2
	JSR	PC,LF
	BR	HD1
HD2:	RTS	PC

MU:	TST	CLINE		;MOVE UP
	BEQ	CRTSPC		;ALREADY AT TOP LINE
	TST	@TEXTP
	BEQ	MU0		;IF LINE DIDN'T EXIST, INVENT CRLF
	TST	OPENSW
	BEQ	MU1		;BR IF NO LINE OPEN
MU0:	JSR	PC,CLSLIN
MU1:	DEC	CLINE
	ADD	#CHRHT,CURSY
	MOV	TEXTP,A
	SUB	#TXTIDX,A
	MOV	BACIDX(A),A
	ADD	#TXTIDX,A
	MOV	A,TEXTP
	RTS	PC

HU:	JSR	PC,CR		;HOME UP
HU1:	TST	CLINE
	BEQ	CRTSPC
	JSR	PC,MU
	BR	HU1

CLEOL:	TST	@TEXTP
	BEQ	CLEOL2		;LET MU OR LF WORRY ABOUT LINE WHICH NEVER EXISTED
	TST	OPENSW
	BNE	.+6
	JSR	PC,OPNLIN	;OPEN IT SO WE CAN FREE WHERE IT POINTED
	BIT	#1,CPOS
	BEQ	CLEOL1
	MOVB	#' ,@LINPNT
CLEOL1:	MOV	CPOS,BYTCNT
	JSR	PC,CLSLIN
CLEOL2:	RTS	PC

CLEOF:	JSR	PC,CLEOL		;CLEAR THE LINE THAT'S THERE
	MOV	#CHRLN-1,B
	SUB	CLINE,B			;# OF ADDITIONAL LINES TO FLUSH
	BEQ	CLEOF3
	MOV	TXSTRT,C		;TOP LINE
	BNE	.+4
	BPT				;HOW CAN THERE BE NO TEXT?
					;FLUSH TEXT
CLEOF1:	MOV	BACIDX(C),C
	MOV	TXTIDX(C),A
	BEQ	CLEOF2			;NO TEXT ON THAT LINE
	CLR	TXTIDX(C)
	JSR	PC,RETLIN		;RETURN LINE TO FREE STORAGE
CLEOF2:	DEC	B
	BGT	CLEOF1
CLEOF3:	MOV	#GRJSR-HJSIDX,TT	;FLUSH THE GRAPHICS AS WELL
	MOV	GRSTRT,T
	BEQ	CLEOF4
	BPT				;GRAPHICS FLUSHED
;	JSR	PC,DITEM2
;	BR	CLEOF3
CLEOF4:	RTS	PC

CSRPOS:	PUSH A			;POSITION CURSOR TO H,V IN A,B
	PUSH B
CSPV1:	CMP (SP),CLINE
	BEQ CSPH1		;VERTICAL POSITION RIGHT
	BLE CSPV2
	JSR PC,LF		;MOVE DOWN
	BR CSPV1

CSPV2:	JSR PC,MU		;MOVE UP ONE
	BR CSPV1

CSPH1:	CMP 2(SP),CPOS
	BEQ CSPHX		;HORIZONAL POSITION RIGHT TOO
	BLE CSPH2
	JSR PC,CFS		;FORWARD SPACE
	BR CSPH1

CSPH2:	JSR PC,MB		;MOVE BACK
	BR CSPH1

CSPHX:	POP B
	POP A
	RTS PC

;HERE TO CLOSE A LINE

CLSLIN:	MOV	BYTCNT,A
	ASR	A		;MAKE A EVEN
	ADC	A
	ASL	A
	ADD	#XTLBYT,A	;SIZE OF BUFFER DESIRED (INCLUDE CHARS,CRLF,DPYRTS)
	MOV	A,B
	JSR	PC,GETBLK
	MOV	#CHARS,(A)
	ADD	A,B
	MOV	#DPYRTS,-(B)
	MOV	#<<15_10>+12>,-(B)
	MOV	BYTCNT,B
	BEQ	CLSL2		;EMPTY LINE
	MOV	A,TT
	MOV	#LINBUF,T
	MOV	(T)+,(TT)+
	ASR	B
	ADC	B		;WORD COUNT
CLSL1:	MOV	(T)+,(TT)+
	DEC	B
	BGT	CLSL1
CLSL2:	MOV	A,@TEXTP
CLRLIN:	CLR	BYTCNT
	MOV	#LINBUF+LBL-4,T	;DON'T CLEAR CRLF OR DPYRTS
	MOV	#LINBUF,TT	;OR THE CHARS EITHER
CLRL1:	CLR	-(T)
	CMP	T,TT
	BHI	CLRL1
	RTS	PC

CLRL3:	CLR	(T)+
	CMP	T,TT
	BLO	CLRL3
	RTS	PC

;OPENS CURRENT LINE, COPIES CURRENT LINE INTO LINBUF
;	AND RETURNS LINE BUFFER TO FREE STORAGE
OPNLIN:	PUSH	A
	MOV	@TEXTP,T
	BEQ	OPNL4		;NO TEXT ON LINE
	MOV	#LINBUF,TT
	MOV	(T)+,(TT)+	;SHOULD BE CHARS
	MOV	(T)+,(TT)+
	BGE	.-2		;UGH! THIS WORKS ONLY BECAUSE DPYRTS
				;HAS 100000 BIT ON, AND CHARS DON'T.
	CMP	-(TT),-(TT)	;DPYRTS AND CRLF
	MOV	TT,T
	SUB	#LINBUF+2,TT	;NUMBER OF BYTES IN LINE
	MOV	TT,BYTCNT
OPNL1:	MOV	#LINBUF+LBL-2,TT
	MOV	#DPYRTS,(TT)
	MOV	#<15_10>+12,-(TT)
	MOV	#"  ,A		;2 SPACES
	BIT	#1,A
	BEQ	OPNL2
	MOVB	A,(T)+		;FILL ODD BYTE
	BR	OPNL2
	MOV	A,(T)+		;FILL LINE WITH SPACES
OPNL2:	CMP	T,TT
	BLO	.-4
	MOV	@TEXTP,A
	BEQ	OPNL3		;NO LINE TO RETURN
	MOV	#FAKEL,@TEXTP
	JSR	PC,RETLIN	;RETURN LINE AT INTERUPT LEVEL
OPNL3:	MOV	#LINBUF,@TEXTP
	POP	A
	RTS	PC

;HERE FOR NO TEXT ON OPEN LINE

OPNL4:	MOV	#LINBUF,T
	MOV	#CHARS,(T)+
	CLR	BYTCNT
	BR	OPNL1

.IFNZ 0	;FLUSHED TO SAVE CORE

.SBTTL DISPLAY SLAVE COMMAND PROCESSOR

CMND:	JSR	PC,GETCHW	;GET COMMAND
	CMP	A,#CMTBLL/2
	BHIS	RTSPC3		;NOT A COMMAND IGNORE
	MOV	A,COMAND	;FOR DEBUGGING
	CLR	CKS
	CLR	C		;ONE LESS THAN # OF WORDS WE EXPECT
	ASL	A
	JMP	@CMTBL(A)	;DISPACH

;COMMAND DISPATCH TABLE
CMTBL:	LODERS			;LOAD A LIST AND SHOW IT
	LODER			;JUST LOAD IT
	DITEM			;DELETE AN ITEM
	GO0			;RESTART WORLD
	SITEM			;SHOW AND ITEM
	EITEM			;ERASE AN ITEM
	CITEM			;COPY AN ITEM
	MITEM			;MOVE ITEM
	CMITEM			;CHANGE THE SET GRAPHICS MODE OF ITEM
	ADITEM			;ADD TO AN ITEM
	SBRITM			;SUBROUTINIZE AN ITEM
	USBITM			;UNSUBROUTINIZE AN ITEM

CMTBLL==.-CMTBL

;DRAWING PROGRAM STYLE COMMANDS

;HERE TO LOAD DISPLAY ITEM AND SHOW IT
LODERS:	MOV	#<XLOD+2>,C	;COUNT
	JSR	PC,GETWRD
	CMP	A,#2
	BEQ	LODER2
	CMP	A,#1
	BNE	RTSPC3
	JSR	PC,LODER	;LOAD ITEM
RTSPC3:	RTS	PC


;HERE TO DELETE AN ITEM FROM OVER COMMUNICATION LINK

LODER2:	JSR	PC,GETWRD
	MOV	A,C
	SUB	#<XLOD-2>,C
LOD2A:	JSR	PC,DITEM
	TST	C
	BGT	LOD2A
	JSR	PC,LODEND
	RTS	PC

GETCNT:	JSR	PC,GETWRD	;SIZE OF BLOCK
	MOV	A,C
	MOV	A,COUNT		;FOR DEBUGGING
	ADD	#<XITEM-XLOD>,A	;BYTES OF CORE WE WANT
	SUB	#<XLOD-2>,C	;WE'VE ONLY 2 LEFT TO READ
	RTS	PC

GTAIB2:	JSR	PC,GTAIB	;DO GTAIB TWICE
;GET WORD AND INSERT AT (B)+
GTAIB:	JSR	PC,GETWRD
	MOV	A,(B)+
	RTS	PC

;HERE TO READ A WORD IN LODER FORMAT
GETWRD:	JSR	PC,GETCHW	;6 BITS
	PUSH	A
	JSR	PC,GETCHW	;4 BITS
	SWAB	A
	ASR	A
	ASR	A
	ADD	A,(SP)
	MOVB	(SP),A
	BIC	#<377_10>,A
	ADD	A,CKS
	DEC	C
	JSR	PC,GETCHW	;LAST 6 BITS
	SWAB	A
	ASL	A
	ASL	A
	ADD	A,(SP)
	DEC	C
	BLT	POPAJ		;ONLY 8 BITS OF CHECK SUM
	MOVB	1(SP),A
	BIC	#<377_10>,A
	ADD	A,CKS
POPAJ:	POP	A
	RTS	PC

;SOME SBRS USED BY ALL STYLE COMMANDS
;GET ITEM AND FIND IT
;CALL WITH ITEM # IN A
;RETURN WITH ITEM # IN A, & IF FOUND, Z BIT CLEARED, & ITEM ADDR IN T
GFITEM:	JSR	PC,GETWRD
FHEDR:	MOV	#GRSTRT-HNXIDX,TT
	BR	FHEDR2
FHEDR1:	MOV	T,TT
FHEDR2:	MOV	HNXIDX(TT),T
	BEQ	RTSPC4		;BR IF ITEM DOESN'T EXIST
	CMP	A,HITIDX(T)
	BNE	FHEDR1
	CLZ			;FOUND IT, CLR Z BIT
RTSPC4:	RTS	PC

;CREATE A HEADR, CALL WITH ITEM # IN A
;INSERT INTO DISPLAY RING &RETURN WITH HEADR ADDR IN T
CHEDR:	JSR	PC,FHEDR
	BNE	DELIS1		;ALREADY EXISTS
	PUSH	A
	MOV	#HSIZE,A
	JSR	PC,GETBLK	;GET A NEW HEADER BLOCK
	MOV	A,T
	POP	A
	PUSH	T
	MOV	#DPYNOP,(T)+	;SETPNT
	MOV	#DPYNOP,(T)+	;X
	MOV	#DPYNOP,(T)+	;Y
	MOV	#DPYJSR,(T)+
	CLR	(T)+		;THIS ITEM'S LIST ADDR
	CMP	(T)+,(T)+	;JMP OR JSR TO NEXT LIST & NEXT LIST
	MOV	A,(T)+		;ITEM #
	CLR	(T)+		;LIST ADDR
	CLR	(T)+		;# OF SUBR CALLS TO THIS LIST
	POP	T
IINSRT:	MOV	GRJMP,HJMIDX(T)
	MOV	GRSTRT,HNXIDX(T)
	MOV	T,GRSTRT		;FLASH
	MOV	#DPYJMP,GRJMP
	RTS	PC

;DELETE ITEM WITH # IN A
;RETURN HEADR ADDR, IF ANY, IN T & CLR Z BIT
GDELIS:	JSR	PC,GETWRD
DELIS:	JSR	PC,FHEDR
	BEQ	RTSPC4		;HEADER DOESN'T EXIST
DELIS1:	TST	HIAIDX(T)
	BEQ	RTSPC4		;NO ASSOCIATED LIST
	CLR	HDSIDX(T)	;DON'T SHOW IT
	PUSH	A
	MOV	HIAIDX(T),A	;LIST ADDR
	CLR	HIAIDX(T)
	JSR	PC,RETLIN	;FREE IT UP
	POP	A
	CLZ
	RTS	PC

;LISP STYLE COMMANDS

;HERE TO LOAD AN ITEM
LODER:	JSR	PC,GETCNT
	SUB	#LINHDR,A	;LIST BYTES IN HEADER
	PUSH	A		;LIST SIZE IN A
	JSR	PC,GETWRD
	JSR	PC,CHEDR	;CREATE A HEADR
	MOV	T,B		;HEADR ADDR
	PUSH	B
	JSR	PC,GTAIB	;SET POINT
	JSR	PC,GTAIB2	;X&Y
	POP	B
	POP	A		;LIST SIZE
	JSR	PC,GETBLK	;GET ITEM
	MOV	A,T
	MOV	A,HIAIDX(B)	;LIST ADDR
	MOV	#DPYRTS,(A)
	MOV	T,HDSIDX(B)	;DEST OF DPYJSR
	MOV	A,B
	JSR	PC,GTALL	;GET WRDS UNTILL C=0, PUT THEM AT (B)+, CHECKSUM
	RTS	PC

;HERE TO DELETE AN ITEM!
DITEM:	JSR	PC,GDELIS
	TST	T
	BEQ	RTSPC4		;NO HEADER EXISTS
DHEDR:	TST	HSCIDX(T)
	BNE	EDHEDR	
DITEM2:	MOV	HJMIDX(T),HJMIDX(TT)	;TAKE IT OUT OF DISPLAY LIST RING
	MOV	HNXIDX(T),HNXIDX(TT)
	PUSH	A
	MOV	T,A		;HEADER ADDR
	JSR	PC,RETLIN
	BR	POPAJ

EDHEDR:	BPT			;CAN'T DELETE THIS, IT'S A SUBR
	RTS	PC

;GET ALL WORDS AND INSERT AT (B)+, THEN CHECKSUM
;MAIN LODER LOOP

GTALL1:	MOV	#DPYRTS,2(B)
	PUSH	B		;SAVE THE ADDRESS
	JSR	PC,GETWRD
	TST	@PUTDPY		;PUT THE WORD IN LIST AT INTERRUPT LEVEL
	BEQ	.+4
	BPT			;NOT FAST ENOUGH FOR OUR TASTE
	MOV	PUTDPY,B
	MOV	A,2(B)		;THAT'S THE CONTENTS
	POP	A		;GET THE ADDRESS BACK
	MOV	A,(B)		;ADDRESS MARKS BUFFER AS GOOD
	MOV	-(B),B		;NEXT BUFFER ON RING
	TST	(B)+		;MAKE IT POINT TO ADDRESS
	MOV	B,PUTDPY	;SET FOR NEXT TIME
	MOV	A,B		;GET ADRRESS BACK IN RIGHT PLACE
	TST	(B)+		;AND INCREMENT IT
GTALL:	TST	C
	BGT	GTALL1
LODEND:	TST	C
	BEQ	.+4
	BPT			;ODD # OF BYTES
LGCKS:	JSR	PC,GETWRD
	TSTB	CKS
	BEQ	.+4
	BPT			;CHECKSUM
	RTS	PC

;HERE TO SHOW DISPLAY ITEM
SITEM:	JSR	PC,GFITEM	;GET ITEM NUMBER AND FIND IT
	BEQ	RTSPC5		;NO SUCH ITEM
RSITEM:	MOV	HIAIDX(T),HDSIDX(T)
	RTS	PC

;HERE TO ERASE ITEM
EITEM:	JSR	PC,GFITEM
	BEQ	RTSPC5		;NO SUCH ITEM
	CLR	HDSIDX(T)
	RTS	PC

;HERE TO CALL ITEM2 AS A SUBROUTINE OF ITEM1
SBRITM:	INC	C		;2 MORE WORDS LEFT
	JSR	PC,GFITEM
	BEQ	IG1WD2
	MOV	T,B		;SOURCE ADDR
	JSR	PC,GFITEM
	BEQ	RTSPC5
	INC	HSCIDX(T)	;# OF TIMES THIS IS CALLED AS SUBR
	ADD	#HDSIDX,T	;WHERE TO DPYJSR TO
	PUSH	T
	MOV	HIAIDX(B),A	;OLD DEST LIST
	MOV	#4,T		;ADDED SIZE OF CALLING ITEM
	JSR	PC,TCOPY	;COPY CALLING ROUTINE, RETURN WITH NEW ADDRESS IN A
				;PNTR TO LAST WORD IN T
	MOV	#DPYJSI,(T)+	;PUT A CALL TO SUBR AT END OF NEW COPY
	POP	(T)+
	MOV	#DPYRTS,(T)
	PUSH	HIAIDX(B)	;OLD DEST LIST
	MOV	A,HIAIDX(B)
	TST	HDSIDX(B)
	BEQ	.+6		;WASN'T BEING SHOWN
	MOV	A,HDSIDX(B)	;SHOW IT
	POP	A
	BEQ	RTSPC5		;SHOULDN'T HAPPEN
	JSR	PC,RETLIN	;FLUSH OLD LIST
RTSPC5:	RTS PC

;HERE TO UNSUBROUTINIZE AN ITEM
USBITM:	INC	C		;2 MORE WORDS LEFT
	JSR	PC,GFITEM
	BEQ	IG1WD2
	MOV	T,B		;OLD SOURCE
	JSR	PC,GFITEM
	BEQ	RTSPC5
	MOV	HIAIDX(B),B
	MOV	T,A
	ADD	#HDSIDX,A	;DEST OF DPYJSRS
USBIT1:	CMP	(B),#DPYRTS
	BEQ	RTSPC5		;END OF THAT LIST
	CMP	(B)+,#DPYJSI
	BNE	USBIT1		;THAT WORD WASN'T A SBR CALL
	CMP	(B),A
	BNE	USBIT1		;DEST WASN'T WHAT WE WANTED
	CLR	(B)		;FLUSH IT
	DEC	HSCIDX(T)	;ONE LESS CALL TO ME
	RTS	PC
	BR	USBIT1		;NOOP PREV INSTR TO REMOVE ALL CALLS TO THIS ITEM

IG1WD2:	JMP IG1WD

;HERE TO COPY ITEM
CITEM:	INC	C		;2 MORE WORDS LEFT
	JSR	PC,GFITEM
	BEQ	IG1WD1		;NO SUCH ITEM
	PUSH	T		;HEADER ADDRESS
	JSR	PC,GETWRD
	JSR	PC,CHEDR	;CREATE A HEADER
	POP	A		;SOURCE HEADER ADDR
	MOV	HSPIDX(A),HSPIDX(T)	;SETPOINT
	MOV	HXCIDX(A),HXCIDX(T)	;X
	MOV	HYCIDX(A),HYCIDX(T)	;Y
	TST	HIAIDX(A)
	BEQ	RTSPC5		;NO LIST
	PUSH	A		;OLD HEADER ADDR
	PUSH	T		;NEW HEADER ADDR
	MOV	HIAIDX(A),A	;LIST TO BE COPIED
	CLR	T
	JSR	PC,TCOPY	;COPY LIST
	POP	T		;NEW HEADER ADDR
	MOV	A,HIAIDX(T)	;LIST ADDRESS
	POP	A
	TST	HDSIDX(A)
	BEQ	RTSPC5		;OLD ITEM WASN'T BEING SHOWN
	MOV	HIAIDX(T),HDSIDX(T)
	RTS	PC


;MAKE A COPY OF ITEM WITH ADDRESS IN A,
;		LEAVE T EXTRA BYTES
;RETURN PNTR TO NEW ITEM IN A, TO END OF NEW ITEM IN T
TCOPY:	PUSH	TT
	PUSH	A
	MOV	-BLIDX(A),TT
	BIC	#INUSE,TT
	SUB	#BXTRA,TT	;MAX LIST SIZE
	ADD	A,TT		;PNTR PAST END OF LIST
TCOPY2:	CMP	A,TT
	BHIS	TCOPY3		;PAST END OF LIST
	CMP	(A)+,#DPYRTS	;FIND THE END OF DISPLAY INSTRUCTIONS
	BNE	TCOPY2
TCOPY3:	SUB	(SP),A
	MOV	A,TT
	ASR	TT		;# OF WORDS TO BLT
	PUSH	TT
	ADD	T,A		;GRAND TOTAL SIZE
	JSR	PC,GETBLK
	MOV	A,T		;COPY ADDR
	POP	TT		;WD COUNT
	POP	A		;SOURCE ADDR
	PUSH	T
TCOPY1:	MOV	(A)+,(T)+	;BLT OLD ITEM TO NEW
	DEC	TT
	BGT	TCOPY1
	TST	-(T)		;LAST WORD IN COPY
	POP	A		;COPY ADDRESS
	POP	TT
	RTS	PC

;CHANGE MODE (INTENSITY, BLINK, ETC)
CMITEM:	INC	C		;2 MORE WORDS LEFT
	JSR	PC,GFITEM
IG1WD1:	BEQ	IG1WD
	JSR	PC,GETWRD
	MOV	(T),TT		;OLD SET GRAPH MODE WORD
	BIC	#003777,TT	;COMBINE OLD MODE
	BIC	#174000,A	;WITH NEW ENABLE, ETC. BITS
	BIS	A,TT
	MOV	TT,(T)		;NEW WORD
	RTS	PC

;ADD TO ITEM1 N WORDS
ADITEM:	JSR	PC,GETCNT	;RETURNS AMOUNT OF CORE WE NEED IN A
	MOV	A,B		;# OF XTRA BYTES
	JSR	PC,GFITEM
	BNE	ADITE1		;BR IF FOUND ITEM
	INC	C		;IGNORE CKS ALSO
	BR	IGWDS
ADITE1:	MOV	HIAIDX(T),A	;OLD LIST ADDR
	PUSH	A
	PUSH	T		;HEADR ADDR
	MOV	B,T
	JSR	PC,TCOPY
	MOV	T,B		;END OF NEW LIST
	POP	T		;HEADR ADR
	MOV	A,HIAIDX(T)	;LIST ADDR
	TST	HDSIDX(T)
	BEQ	ADITE2
	MOV	A,HDSIDX(T)
ADITE2:	JSR	PC,GTALL
	POP	A
	JSR	PC,RETLIN	;FREE OLD LIST SPACE
	RTS	PC

	
;MOVE AN ITEM TO X, Y
MITEM:	MOV	#2,C		;3 MORE WORDS
	JSR	PC,GFITEM
	BEQ	IG2WD		;NO SUCH ITEM
	MOV	T,B		;ITEM ADDRESS
	ADD	#HXCIDX,B
	JSR	PC,GTAIB2	;GET X&Y
	RTS	PC

;IGNORE 2 WORDS
IG2WD:	MOV	#2,C
	BR	IGWDS1
;IGNORE 1 WORD
IG1WD:	MOV	#1,C
;IGNORE C WORDS
IGWDS1:	JSR	PC,GETWRD
IGWDS:	TST	C
	BGE	IGWDS1
	RTS	PC

.ENDC ;IFNZ 0

.SBTTL DYNAMIC STORAGE ALLOCATOR ROUTINES

GETBLK:	ASR	A		;INSURE AN EVEN # OF BYTES
	ADC	A
	ASL	A
	ADD	#BXTRA,A	;SIZE OF BLOCK HE REALLY WANTS
	BGT	.+4
	BPT			;HE WANTS NEGATIVE OR ZERO BLOCK
	PUSH	PS		;DON'T ALLOW RETBLK AT INTERRUPT LEVEL
	MOV	DSPSW,PS
	MOV	ROVER,T
	BNE	GETBL1
	MOV	@AVAIL,T
	MOV	T,ROVER
GETBL1:	MOV	(T),TT		;NEXT BLOCK
	CMP	A,-(T)
	BLOS	GETBL2		;FOUND A WINNER
	CMP	TT,AVAIL
	BEQ	GETBL3		;END OF CHAIN
	MOV	TT,T
	BR	GETBL1

;HERE IF WINNER FOUND

GETBL2:	MOV	TT,ROVER
	SUB	A,(T)		;SIZE OF THIS BLOCK NOW
	CMP	(T)+,#NEBISH
	BLO	GETB21
	MOV	T,TT		;BREAK INTO TWO BLOCKS
	ADD	-(T),TT		;ORIGIN OF NEW BLOCK
	MOV	(T),-4(TT)	;SIZE INTO TOP OF OLD BLOCK
GETBL4:	MOV	A,T		;LENGTH OF NEW BLOCK
	BIS	#INUSE,A	;MARKS BLOCK IN USE
	CLR	(TT)+		;CLEAR FREE NEXT BLK PNTR
	MOV	A,-BLIDX(TT)	;MARKER INTO BLOCK
	MOV	TT,A		;RETURN POINTER TO CALLER
	ADD	T,TT		;ORIGIN OF NEXT BLOCK
	MOV	#INUSE,-BLIDX-2(TT)	;MARK LAST WORD OF NEW BLOCK
	POP	PS
	RTS	PC

;HERE TO GIVE CALLER ENTIRE BLOCK

GETB21:	JSR	PC,UNLINK	;TAKE BLOCK OUT OF FREE LIST
	ADD	-2(T),A		;SIZE OF BLOCK
	MOV	T,TT		;NEW BLOCK
	BR	GETBL4

;BLOCK FORMAT
	;FREE BLOCK
		;SIZE
BNXIDX==2	;PNTR TO NEXT FREE BLOCK
		;PNTR TO PREVIOUS FREE BLOCK
		;BLOCK
		;SIZE

	;ALLOCATED BLOCK
		;SIZE!INUSE
		;IF NON-ZERO, PNTR TO NEXT BLOCK TO BE FREED
BLIDX==BNXIDX+2	;BLOCK
		;SIZE!INUSE

BXTRA==6		;NUMBER OF EXTRA BYTES IN A BLOCK

;HERE ON END OF FREE LIST

GETBL3:	TST	ROVER
	BEQ	ENOFRE		;BLOCK CANNOT BE FOUND
	CLR	ROVER
	MOV	@AVAIL,T
	BR	GETBL1

;TAKES BLOCK IN T AND PATCHES IT OUT OF FREE STORAGE LIST
UNLINK:	MOV	(T),TT
	MOV	TT,@2(T)	;PATCH FORWARD POINTER INTO PRECEEDING BLOCK
	MOV	2(T),2(TT)	;PATCH BACK POINTER INTO NEXT BLOCK
	CMP	ROVER,T
	BNE	.+6
	MOV	TT,ROVER	;DON'T LET ROVER POINT TO NON-EXISTENT BLOCK
	RTS	PC


;ERROR ROUTINES
ENOFRE:	CLR	A		;NO FREE STORAGE LEFT
;	JSR	PC,ESND
	MOV	#GO,SP
	JMP	MAINL

;EINT:	MOV	#34,A		;INTERNAL ERROR
;ESND:	MOV	A,@AKLOB
;	BR	.+6
;ESND1:	JSR	PC,GETWRD
;	TST	C		;IGNORE C+1 WORDS
;	BGE	ESND1
;	RTS	PC
;HERE TO RETURN A BLOCK TO FREE STORAGE (RUNS DURING DISPLAY INTERRUPTS)

RETBLK:	MOV	A,OLDBLK	;SAVE FOR DEBUGGING
	TST	-(A)
	CMP	A,#FS+2
	BHIS	.+4
	BPT			;CAN'T TAKE THAT ONE BACK
	MOV	-2(A),T		;SIZE
	BIT	#INUSE,T
	BNE	.+4
	BPT			;CAN'T FREE A BLOCK WHICH ISN'T IN USE
	MOV	(A),RETLAD	;IF NZ, NEXT BLOCK TO BE FREED
	BIC	#INUSE,T
	BIT	#INUSE,-4(A)	;IS BLOCK BELOW RESERVED
	BNE	RETBL1		;YES, CHECK LOWER BOUND
	SUB	-4(A),A		;POINTS TO ENLARGED BLOCK
	ADD	T,-2(A)		;NEW SIZE
	MOV	A,T
	ADD	-2(A),T		;POINTS TO BLOCK ABOVE
	MOV	-2(A),-4(T)	;PUT MARKER AT TOP OF BLOCK
	BIT	#INUSE,-2(T)
	BNE	RTSPC2		;BLOCK ABOVE RESERVED, GOOD BYE
	ADD	-2(T),-2(A)	;NEW SIZE OF MOBY BIG BLOCK
	JSR	PC,UNLINK	;TAKE THIS BLOCK OUT OF FREE LIST
	MOV	A,T		;MARK TOP OF ENLARGED BLOCK
	ADD	-2(A),T		;POINTS TO NEXT BLOCK
	MOV	-2(A),-4(T)	;MARK TOP OF BLOCK WITH SIZE
	RTS	PC

;BLOCK BELOW RESERVED, CHECK ABOVE

RETBL1:	MOV	T,-2(A)		;MARK THIS BLOCK AS FREE
	ADD	A,T		;POINTS TO NEXT BLOCK
	MOV	-2(A),-4(T)	;MARKER INTO TOP OF BLOCK
	BIT	#INUSE,-2(T)
	BNE	LINK		;BR IF BLOCK ABOVE RESERVED, PATCH THIS ONE BACK IN
	JSR	PC,UNLINK	;TAKE BLOCK ABOVE OUT OF FREE STORAGE
	ADD	-2(T),-2(A)	;NEW SIZE
	MOV	A,T
	ADD	-2(A),T		;POINTS TO NEXT BLOCK
	MOV	-2(A),-4(T)	;MARK TOP OF BLOCK
LINK:				;PATCH THIS IN AT AVAIL
	CMP	ROVER,A
	BNE	.+6
	CLR	ROVER
	MOV	AVAIL,T		;PREVIOUS BLOCK
	MOV	(T),TT		;NEXT BLOCK
	MOV	A,(T)		;FWD PNTR IN PREV BLK
	MOV	TT,(A)		;FWD PNTR IN THI BLK
	MOV	T,2(A)		;BACK PNTR IN THIS BLK
	MOV	A,2(TT)		;BACK PNTR IN NEXT BLK
RTSPC2:	RTS	PC

;MAIN PROGRAM LEVEL ROUTINE TO RETURN BLOCK AT INTERRUPT LEVEL

RETLIN:	CMP #FAKEL,A
	BEQ RETERR
	TST A
	BEQ RETERR
	PUSH	PS
	MOV	DSPSW,PS	;GO TO DISPLAY INTERRUPT LEVEL
	MOV	RETLAD,-BNXIDX(A)	;ADD LIST TO FRONT OF CHIAN
	MOV	A,RETLAD
;.IFNZ DLIMSW
;	EMT			;IF DISP ISN'T RUNNING, FREE BLOCK ON DISBRK LEVEL
;.ENDC
.IFNZ DEBUG
	IOT			;FAKE A DISPLAY INTERRUPT
.ENDC
	POP	PS
	RTS	PC

RETERR:	BPT
.ENDC ;GT40P

.SBTTL TV CHARACTER DISPLAY ROUTINES
.IFNZ TVP

TVOMSK:	BIC	#177600,A	;HERE IF YOU DON'T TRUST THE HIGH BITS
TVO:	JSR	PC,GENCHR	;GENERATES CHARACTER AND ADVANCES CURSOR
				;BY FALLING INTO LEDADC
;LEDADC ADVANCES LINE EDITOR CURSOR
;TAKES AND PRESERVES CHAR IN A
CFS::
LEDADC:	TST	PPPHS(U)
	BGT	LEDAD1
	ADD	#20,PPPHS(U)	;# BITS/WORD
	ADD	#2,PPCC(U)	;ADVANCE TO NEXT WORD IN DISPLAY
	CMP	PPCC(U),#TVCFENCE
	BLOS	LEDAD1
	MOV	#TVLO,PPCC(U)
LEDAD1:	SUB	#CHRWD,PPPHS(U)
	INC	PPCPOS(U)
	RTS	PC

;RETREATS LINE EDITOR CURSOR

BS::
LEDREC:	TST	PPCPOS(U)
	BEQ	LEDRE1
	DEC	PPCPOS(U)
	ADD	#CHRWD,PPPHS(U)
	CMP	#<20-CHRWD>,PPPHS(U)
	BGE	LEDRE1
	SUB	#20,PPPHS(U)	;BACKUP A WORD IN DISPLAY
	SUB	#2,PPCC(U)
	CMP	PPCC(U),#TVLO
	BHIS	LEDRE1
	MOV	#TVFENCE,PPCC(U)
LEDRE1:	RTS	PC

;TURN BLINKER OFF
BLKOFF:	ZAPFLG BLKDFR
	TST BLKPHS
	BEQ 1$
	JSR PC,XORCHR
	CLR BLKPHS
1$:	RTS PC


;CLOCK BREAK COMES HERE TO HACK BLINKER
CRSCLK:	DEC BLKTIM
	BGT 1$
	TST BLKDFR
	BNE 1$
	TST BLKPHS
	BNE 2$		;ALWAYS TURN BLINKER OFF ON TIME
;	TST LMHTTY	;THESE DAYS, TURN CURSOR ON ONLY IF IN DATAPOINT TO 10 MODE
;	BNE 1$
	TST CNHTTY
	BNE 1$
2$:	PUSH U
	MOV #PPVAR,U
	JSR PC,XORCHR
	POP U
	COM BLKPHS
	MOV #15.,BLKTIM
1$:	TST BELTIM
	BEQ 4$
	DEC BELTIM
	BGT 4$
	CLR BELTIM
	JSR PC,BOWXOR
4$:	RTS PC

BOWXOR:	BIT #BOWBIT,TVCTL
	BEQ 1$
	BIC #BOWBIT,TVCTL
	RTS PC

1$:	BIS #BOWBIT,TVCTL
	RTS PC

;COME HERE TO "DISPLAY" "FORMAT" CHARACTER ANYWAY
ALT:	ASR A		;COMPENSATE FOR ASL DONE BEFORE DISPATCH
	JMP TVO

;BELL, FLASH SCREEN

BELL:	PUSH PS
	MOV #300,PS	;PREVENT CLOCK BREAKS
	TST BELTIM
	BNE 1$		;ONLY ONE BELL AT A TIME
	MOV #20.,BELTIM
	JSR PC,BOWXOR
1$:	POP PS
	RTS PC

FORMA1::	;HERE TO IGNORE RANDOM CONTROL CHARS
TAB::		;TAB NOT IMPLEM
	RTS PC

MU:	MOV CPOS,A
	MOV CLINE,B
	DEC B
	BGT SXYJ
	CLR B
SXYJ:	JMP SETXY

HD:	CLR A
	MOV #CHRLN-1,B
	BR SXYJ

;HERE FOR LINE FEED, NO FRILLS

LF:	INC	PPLINE(U)
	ADD	#<BYTPL*LINHT>,PPLCC(U)
	ADD	#<BYTPL*LINHT>,PPCC(U)
	CMP	#TVFENCE,PPLCC(U)
	BHI	LF1
	CLR	PPLINE(U)
	SUB	PPLCC(U),PPCC(U)
	ADD	#TVLO,PPCC(U)
	MOV	#TVLO,PPLCC(U)
LF1:	RTS	PC

;HERE FOR CARRIAGE RETURN

CR:	MOV	PPLCC(U),PPCC(U)	;ORIGIN OF THIS LINE
CR1:	MOV	#20-CHRWD,PPPHS(U)	;PHASE
	CLR	PPCPOS(U)		;CHAR POSN
	RTS	PC
;DATA POINT ROUTINES

;CLEARS TO END OF LINE

CLEOL:	PUSH	PPCC(U)
	PUSH	PPPHS(U)
	PUSH	PPCPOS(U)
	JSR	PC,CLEOL1	;DO THE DIRTY WORK
CLEOX:	POP	PPCPOS(U)
	POP	PPPHS(U)
	POP	PPCC(U)
	RTS	PC

CLEOL1:	CMP	PPCPOS(U),#CHRPL-1
	BGE	CLEOLX		;ALREADY AT END OF LINE
	CMP	PPPHS(U),#20-CHRWD
	BEQ	CLEOL2		;IF AT START OF WORD, START CLEARING WORD-WISE
	JSR	PC,CLRCHR	;ELSE CLEAR 1 CHAR AT A TIME TILL REACH WORD BOUNDARY.
	JSR	PC,LEDADC
	BR	CLEOL1

CLEOL2:	MOV	PPLCC(U),-(SP)
	SUB	PPCC(U),(SP)
	ADD	#BYTPL,(SP)	;# OF BYTES TO CLEAR
	ASR	(SP)
	PUSH	PPCC(U)		;ADDR OF 1ST WORD TO CLEAR,
	PUSH	#LINHT		;# LINES TO PROCESS
CLEOL3:	MOV	2(SP),TVPTR	;START CLEARING HERE
	BIC	#VERINC,TVCTL	;HORIZONTAL INCREMENT MODE
	MOV	4(SP),TT	;# WDS TO CLEAR
CLEOL4:	CLR	TVDATI
	DEC	TT
	BNE	CLEOL4
	ADD	#BYTPL,2(SP)
	DEC	(SP)
	BGT	CLEOL3
	ADD	#6,SP		;CLEANSE STACK
	MOV	TVPTR,PPCC(U)
	BR	CR1		;RESET X AND PHASE

CLEOLX:	MOV	PPLCC(U),T
	ADD	#<LINHT*BYTPL>,T	;HERE IF ALREADY AT END OF LINE
	MOV	T,PPCC(U)
	BR	CR1
;DATA POINT ROUTINES CONTINUED

;CLEARS TO END OF SCREEN

CLEOF:	PUSH	PPCC(U)
	PUSH	PPPHS(U)
	PUSH	PPCPOS(U)
	PUSH	PPLCC(U)
	TST	PPCPOS(U)	;IF WE'RE AT THE LEFT MARGIN
	BEQ	CLEOF0		;START DOING FAST LINE-BY-LINE CLEARING RIGHT AWAY.
	JSR	PC,CLEOL1	;CLEAR TO END OF LINE FIRST
CLEOF0:	MOV	#TVHI+2,TT
	SUB	PPCC(U),TT
	ASR	TT		;# OF WDS REMAINING IN TV MEMORY
	BEQ	CLEOFX
	MOV	#TVDATI,T
	BIC	#VERINC,TVCTL	;HORIZONTAL INCREMENT MODE
CLEOF1:	CLR	(T)
	DEC	TT
	BNE	CLEOF1
CLEOFX:	POP	PPLCC(U)
	BR	CLEOX		;RESTORE ALL THAT OTHER STUFF

;HERE TO HOME UP

HU:	MOV	PPORG(U),PPCC(U)	;RESET MA
	MOV	PPORG(U),PPLCC(U)
	CLR	PPCPOS(U)
	CLR	PPLINE(U)
	BR	CR1			;SET CHARACTER PHASE AND X
;MULTIPLY, DIVIDE SUBROUTINES, BORROWED FROM TRANTOR

R0==%0	;for some reason they like funny names for ACs
R1==%1
R2==%2
R3==%3
R4==%4
R5==%5

.MACRO SOB R,D
	DEC R
	BNE D
.ENDM SOB

;.sbttl	Register save/restore routines

; SAVE6 routine saves R0 through R5 on stack, R0 at top:
; SP ->	R0
;	R1
;	R2
;	R3
;	R4
;	R5
; Call by JSR R5,SAVE6.  Restore regs by REST6 routine.

save6:	push r4			; R5 already on stack by JSR.
	push r3
	push r2
	push r1
	push r0
	jmp (r5)		; return.


; SAVE5 is similar to SAVE6, but only saves r0-r4, thus leaving r5
; as a return ptr for JSR R5,FOO calls.  Call with "JSR R4,SAVE5".

save5:	push r3			; R4 on stack from JSR.
	push r2
	push r1
	push r0
	jmp (r4)


; REST6 routine restores R0 through R5 from stack, where
; R0 is considered to be the top word of the stack (which is
; how SAVE6 pushes the registers).  Call by JSR R5,REST6.
; REST6 returns with the 6 words popped off the stack.

rest6:	tst (sp)+		; forget old R5 contents.
	pop r0			; restore other regs.
	pop r1
	pop r2
	pop r3
	pop r4
	rts r5			; return and restore R5.

; Same as above, except used for restoring SAVE5 calls.
; Call with "JSR R4,REST5".

rest5:	tst (sp)+		; forget old R4 contents.
	pop r0			; restore regs
	pop r1
	pop r2
	pop r3
	rts r4			; and return

;	.sbttl	Flow of control macros

;IF macro: Generates code that executes the if clause
;if the specified conditon is true, the else clause if
;it is false.  The else clause is not required.  Example:
;	if eq,<	mov	r0,r1
;		mov	(r1)+,r2 >
;	else <	jsr	pc,foo >

.macro	if cond,code
	.nlist
	gncnt===gncnt+1
	.irp foo,\gncnt
	.iif p1,  .word 0
	.else
	  %.itmp===<g'foo-<.+2>>/2
	  .iif gt %.itmp-377,	.err Branch out of range
	  .iif lt %.itmp+377,	.err Branch out of range
	  .iif eq  <b'cond>&400,  <b'cond>+%.itmp+400
	  .ielse		  <b'cond>+%.itmp-400
	  .endc
	code
g'foo===.
ifcnt===foo
	.endm .irp
	.list
	.endm if

.macro	else code
	gncnt===gncnt+1
	.irp	foo,\ifcnt
	.irp	bar,\gncnt
	br	g'bar
g'foo===.
	code
g'bar===.
	.endm
	.endm
	.endm else

gncnt===777		;gensym count.


;LOOP macro allows loops without labels.  Use RPTL and EXITL
;to repeat loop and exit loop.  Both take branch condition arguments.
;If condition arg is null, then BR is used, i.e. unconditional.
;End of CODE falls out of loop unless specific RPTL is used.

;Example of LOOP macro:
;loop <	  cmpb	r0,(r1)+	;found char yet?
;	  exitl	eq		;exit loop on equal.
;	  inc	r2		;not found.
;	  cmp	r2,r5		;too many?
;	  rptl	lt		;no, keep going.
;	  jmp	error		;too many.
;	>
;				;EXITL comes here.

;Loop defines two lables around the code argument,
;the first for looping back via the RPTL macro, the
;second for exiting the loop via the EXITL macro.
;Labels are of the form %Lnv or %Xnv where n signifies
;that this is the nth use of the LOOP macro, and v is
;the level of nesting of this loop macro.  Up to 7
;levels of nesting are allowed.
	%level===0
	%loopn===0
.macro	loop	code
	.iif eq  %level,  %loopn===%loopn+1
	%level===%level+1
	.if gt  <10*%loopn>+%level-7777
	 .error	Too many loops and/or nestings.
	 .mexit
	 .endc
	.if gt  %level-7
	 .error	Too many loop nestings (7 allowed).
	 .mexit
	 .endc
	.irp	n,\<<10*%loopn>+%level>
	  %l'n===.	;loop back to here.
	  code
	  %x'n===.	;exit to here.
	  .endm .irp
	%level===%level-1
	.endm loop

.macro	rptl	cond
	.if eq  %level
	 .error	RPTL not inside LOOP
	 .mexit
	 .endc
	.irp	n,\<<10*%loopn>+%level>
	  .iif b  cond,	br %l'n	;loop back.
	  .ielse	b'cond %l'n
	  .endm	.irp
	.endm rptl

; SORL expands into a SOB instruction back to the last LOOP
; point.  SORL takes one arg, a register to use with the SOB
; instruction.
.macro	sorl r
	.if eq  %level
	 .error SORL not inside LOOP
	 .mexit
	 .endc
	.irp n,\<<10*%loopn>+%level>
	  sob r,%l'n
	  .endm .irp
	.endm sorl


.macro	exitl cond
	.if eq  %level
	 .error EXITL not inside LOOP
	 .mexit
	 .endc
	.irp n,\<<10*%loopn>+%level>
	  .iif b  cond,	br %x'n	;exit.
	  .ielse	b'cond %x'n
	  .endm	.irp
	.endm exitl

;.sbttl	Multiply, Divide, Base-conversion

;.if eq  pdp11-10

; DIV2 divides a double word quantity by a single word
; quantity yielding a quotient and remainder.  It is meant
; to simulate the DIV instruction found on reasonable 11s.

;	ARGS:			VALS:
; SP ->	divisor		 SP ->	quotient
;	dividend lo		remainder
;	dividend hi

div2:	jsr r4,save5		; save regs
	mov 20(sp),r0		; dividend hi
	mov 16(sp),r1		; divident lo
	mov 14(sp),r2		; divisor
	if mi,<	neg r2		; negate divisor and dividend
		com r0		; double word negate
		neg r1		; ...
		adc r0 >	; ...
	clr r3
	mov #16.,r4
loop <	asl r3
	rol r1
	rol r0
	cmp r2,r0
	if le,<	sub r2,r0
		inc r3 >
	sorl r4
      >
	mov r0,20(sp)
	mov r3,16(sp)
	jsr r4,rest5
	pop (sp)
	rts r5



; Multiply routine, args and vals each 1 word.

;	ARGS:				VALS:
; SP ->	A			SP ->	P (product)
;	B

mul1:	jsr r5,save6		; save registers r0-r5.
	mov 16(sp),r1		; first arg.
	mov 20(sp),r2		; second arg.
	clr 20(sp)		; where result will go.
loop <	tst r2			; done?
	exitl eq		; yes, exit the loop.
	ror r2			; no, get next bit in arg2.
	if cs,<	add r1,20(sp) >	; if bit is 1 then add arg1 into result
	asl r1			; then mult arg1 by 2.
	rptl 			; and repeat.
       >
	jsr r5,rest6		; restore regs.
	mov (sp)+,(sp)		; pop R5 down one word.
	rts r5			; return with result on stack.
;.endc
;DATA POINT ROUTINES CONTINUED

CSRPOS:	JSR PC,TVPREP

;HERE TO SET CURSOR GIVEN A DATAPOINT COORDINATE PAIR (X,Y)
;X AND Y ARE IN A AND B RESPECTIVELY, (0,0) IS UPPER LEFTHAND CORNER
;(1,3) IS THE SECOND CHARACTER OF FOURTH LINE

SETXY:	CMP	#CHRPL,A		;CHECK FOR LEGAL POSITION
	BLOS	SETXY1
	CMP	#CHRLN,B
	BLOS	SETXY1
SETXY0:	MOV	B,PPLINE(U)
	MOV	A,PPCPOS(U)
	MOV	B,-(SP)			;Y POSITION
	MOV	#BYTPL*LINHT,-(SP)	;FIND ORIGIN OF LINE IN MEMORY
	JSR	5,MUL1
	MOV	(SP),PPLCC(U)
	MOV	(SP)+,PPCC(U)
	CLR	-(SP)			;FOR DIVIDE LATER
	MOV	A,-(SP)			;X POSITION
	MOV	#CHRWD,-(SP)
	JSR	5,MUL1			;PUSH #BITS FROM LEFT OF SCREEN
	MOV	#20,-(SP)
	JSR	5,DIV2
	MOV	(SP)+,T			;QUOTIENT
	ASL	T			;BYTES FROM BEGIN OF LINE
	ADD	T,PPCC(U)
	MOV	#20-CHRWD,T		;PHASE OF LEFT EDGE OF WORD
	BIT	#1,(SP)
	BEQ	1$
	BPT				;DIVIDE BIT THE BAG?
1$:	SUB	(SP)+,T			;REMAINDER
	MOV	T,PPPHS(U)		;SET PHASE
	CMP	PPORG(U),#TVLO
	BEQ	.+4
	BPT				;NOT PREPARED TO HANDLE THAT PROBLEM
	ADD	PPORG(U),PPCC(U)
	ADD	PPORG(U),PPLCC(U)
	BIT	#1,PPCC(U)		;MAKE SURE IT LINES UP ON WORD BOUNDARY
	BEQ	.+4
	BPT
SETXY1:	RTS	PC

;SAVE ALL ACS ON STACK

ACSAVE:	PUSH	TT
	PUSH	T
	PUSH	C
	PUSH	B
	PUSH	A
	PUSH	U		;RETURN ADDRESS
	MOV	14(SP),U	;RESTORE U
	RTS	PC
.SBTTL CHARACTER GENERATOR ROUTINES

;ROUTINES TO GENERATE A CHARACTER
;CALL WITH CHARACTER IN A AND PAGE PRINTER IN U
;PRESERVES ALL ACS

;IOR CHARACTER AT CURSOR

GENCHR:	JSR	U,ACSAVE
	MOV	PPPHS(U),C
	MOV	PPCC(U),TVPTR
	ASL	A		;MAKE IT A BYTE OFFSET
	MOV	CTAB(A),T	;POINTS AT FONT DESCRIPTION
	JSR	PC,GENCH1
ACREST:	POP	A
	POP	B
	POP	C
	POP	T
	POP	TT
	POP	U
CRTSPC:	RTS	PC

;CLEARS CHARACTER AT LINE EDITOR CURSOR

CLRCHR:	JSR	U,ACSAVE
	MOV	CTAB+<177*2>,T	;RUBOUT MASKS ENTIRE CHARACTER
	MOV	PPPHS(U),C
	MOV	PPCC(U),TVPTR
	JSR	PC,CLRCH1
	BR	ACREST

;BLINK CHARACTER AT CURSOR

XORCHR:	JSR	U,ACSAVE
	MOV	CTAB+<177*2>,T	;RUBOUT MASKS ENTIRE CHARACTER
	MOV	PPPHS(U),C
	MOV	PPCC(U),TVPTR
	JSR	PC,XORCH1
	BR	ACREST

;ARRAY OF ROUTINES TO SHIFT B LEFT SPECIFIED AMOUNT
;ONLY EVEN INDICES WILL BE USED SINCE CHAR WIDTH AND WORD WIDTH BOTH EVEN
;INCOMING MASK IN B IS KNOWN TO BE 0 EXCEPT IN BOTTOM 5 BITS, WHICH HELPS
SHLTAB:	SHL0
	SHL2
	SHL4
	SHL6
	SHL8
	SHL10
	SHL12
	SHL14

SHL14:	ROR B
	ROR B
	ROR B
	BIC #37777,B
	RTS PC

SHL10:	ASL B
	ASL B
SHL8:	SWAB B
	RTS PC

SHL12:	SWAB B
SHL4:	ASL B
	ASL B
SHL2:	ASL B
	ASL B
SHL0:	RTS PC

;ARRAY OF ROUTINES TO SHIFT B RIGHT SPECIFIED AMOUNT
;ONLY NEED EVEN AMOUNTS LESS THAN GRID WIDTH (I.E. -2, -4)

	SHR4
	SHR2
SHRTAB::		;INDEXED NEGATIVELY

SHL6:	SWAB B
SHR2:	ASR B
	ASR B
	RTS PC

SHR4:	ASR B
	ASR B
	ASR B
	ASR B
	RTS PC

.MACRO CGEN OP		;OP IS GEN, CLR, OR XOR
;The lowest level character generator
;AC use   (CLOBBERS ALL)

;A	temp
;B	bit raster
;C	number of desired shifts
;T	points into font description
;TT	counts lines
;U	-
;Called with TVPTR already set up from PPCC

;THIS ROUTINE CLOBBERS -ALL- ACS

OP'CH1:	BIS	#VERINC,TVCTL	;USE VERTICAL INCREMENT MODE
	TST	C		;CHECK SHIFT COUNT
	BLT	OP'OVRL		;OVERLAP CASE
	MOV	SHLTAB(C),C	;EASY CASE, GET PTR TO SHIFT ROUTINE
OP'EZCS:MOV	#CHRHT,TT	;LINE COUNTER
OP'CGLP:MOVB	(T)+,B		;CHARACTER RASTER LINE INTO B
	JSR	PC,(C)		;SHIFT IT
.LIF IDN OP,GEN
	BIS	B,TVDATI	;IOR INTO TV MEMORY AND BUMP TVPTR
.LIF IDN OP,CLR
	BIC	B,TVDATI	;ANDCA ..
.IF IDN OP,XOR
	MOV	B,A		;NO XOR INSN ON MACHINE
	BIC	TVDAT,A
	BIC	B,TVDAT
	BIS	A,TVDATI
.ENDC
	DEC	TT		;LOOP.  NOT WORTH OPEN-CODING SINCE
	BNE	OP'CGLP		;SHIFT ROUTINES ARE SO SLOW ANYWAY AND
	RTS	PC		;WE'RE TIGHT ON CORE.

;Character overlaps word boundaries.  Do first column
;then transfer back to EZCS to do second column.

OP'OVRL:PUSH C
	MOV SHRTAB(C),C	;routine to shift right
	JSR PC,OP'EZCS	;generate first column
	SUB #CHRHT,T	;restore T
	SUB #<CHRHT*BYTPL>-2,TVPTR	;point to top of second column
	POP C
	MOV SHLTAB+20(C),C	;SHIFT LEFT ROUTINE
	BR OP'EZCS		;DO SECOND COLUMN
.ENDM CGEN

;ASSEMBLE 3 FLAVORS OF CHARACTER GENERATOR

CGEN GEN
CGEN XOR
CGEN CLR

RTSPC:	RTS	PC
.SBTTL KEYBOARD TABLES
.IFNZ KBDP

.MACRO KBDKEY N,PLAIN,SH,SL,SLSH,TOP
.XLIST
.=XTAB+N
.BYTE PLAIN
.=XTAB+N+100
.BYTE SH
.=XTAB+N+200
.BYTE SL
.=XTAB+N+300
.BYTE SLSH
.=XTAB+N+400
.BYTE TOP
.LIST
.ENDM

;WHAT FOLLOWS IS THE GRAND CHARACTER CONVERSION TABLE

;AN 8 BIT QUANTITY IS USED TO INDEX INTO THE XTAB
;	0-5	KEYBOARD KEY NUMBER
;	  6	SHIFT
;	  7	SHIFT LOCK
;	  8	TOP (6 AND 7 GUARANTEED TO BE ZERO)

;IF THE BYTE PICKED IS NEGATIVE, YOU HAVE STRUCK A KEY THAT DOES NOT
;HAVE AN ASCII CODE.  THESE CODES ARE ASSIGNED AS FOLLOWS:

NASCTB:	NONAS1	;	 0	ILLEGAL
	RTSPC	;	-1	BREAK
	ESCAPE	;	-2	ESCAPE
	CALL	;	-3	CALL
	RTSPC	;	-4	CLEAR
	RTSPC	;	-5	CAP DELTA
	RTSPC	;	-6	CIRCLE MINUS
	RTSPC	;	-7	DEL
	RTSPC	;	-10	CIRCLE PLUS
	RTSPC	;	-11	BACK
	RTSPC	;	-12	NEXT
	RTSPC	;	-13	HELP
	RTSPC	;	-14	BACK SPACE
MAXNAS==<<.-NASCTB>/2>-1	;MAXIMUM # NON-ASCII CHARACTERS

;GOODIES TO PRINT TO REPRESENT META BITS

METATB:	.BYTE 0,2,3,6	;NOTHING, ALPHA, BETA, EPSILON
.EVEN


;	CHAR	NORMAL	SHIFT	LOCK	SHIFT&LOCK	TOP

XTAB:
KBDKEY	0,	-1,	-1,	-1,	-1,		-1	;BREAK
KBDKEY	1,	-2,	-2,	-2,	-2,		-2	;ESCAPE
KBDKEY	2,	'1,	'!,	'1,	'!,		'!
KBDKEY	3,	'2,	'",	'2,	'",		'"
KBDKEY	4,	'3,	'#,	'3,	'#,		'#
KBDKEY	5,	'4,	'$,	'4,	'$,		'$
KBDKEY	6,	'5,	'%,	'5,	'%,		'%
KBDKEY	7,	'6,	'&,	'6,	'&,		'&
KBDKEY	10,	'7,	'',	'7,	'',		''
KBDKEY	11,	'8,	'(,	'8,	'(,		'(
KBDKEY	12,	'9,	'),	'9,	'),		')
KBDKEY	13,	'0,	'_,	'0,	'_,		'_
KBDKEY	14,	'-,	'=,	'-,	'=,		'=
KBDKEY	15,	'@,	'`,	'@,	'`,		'`
KBDKEY	16,	'^,	'~,	'^,	'~,		'~
KBDKEY	17,	10,	10,	10,	10,		10	;BACK SPACE
KBDKEY	20,	-3,	-3,	-3,	-3,		-3	;CALL
KBDKEY	21,	-4,	-4,	-4,	-4,		-4	;CLEAR
KBDKEY	22,	11,	11,	11,	11,		11	;TAB
KBDKEY	23,	33,	33,	33,	33,		33	;ALT-MODE
KBDKEY	24,	'q,	'Q,	'Q,	'Q,		4,	;and
KBDKEY	25,	'w,	'W,	'W,	'W,		37	;or
KBDKEY	26,	'e,	'E,	'E,	'E,		22	;intersection
KBDKEY	27,	'r,	'R,	'R,	'R,		23	;union
KBDKEY	30,	't,	'T,	'T,	'T,		20	;subset
KBDKEY	31,	'y,	'Y,	'Y,	'Y,		21	;superset
KBDKEY	32,	'u,	'U,	'U,	'U,		5	;not
KBDKEY	33,	'i,	'I,	'I,	'I,		26	;xor
KBDKEY	34,	'o,	'O,	'O,	'O,		1	;down arrow
KBDKEY	35,	'p,	'P,	'P,	'P,		13	;up arrow
KBDKEY	36,	'[,	'{,	'[,	'{,		'{
KBDKEY	37,	'],	'},	'],	'},		'}
KBDKEY	40,	'\,	'|,	'\,	'|,		'|
KBDKEY	41,	'/,	16,	'/,	16,		16	;infinity
KBDKEY	42,	-6,	-5,	-6,	-5,		-5	;circle minus, cap delta
KBDKEY	43,	-10,	-7,	-10,	-7,		-7	;circle plus, cap del
KBDKEY	44,	14,	14,	14,	14,		14	;form
KBDKEY	45,	13,	13,	13,	13,		13	;vertical tab
KBDKEY	46,	177,	177,	177,	177,		177	;rubout
KBDKEY	47,	'a,	'A,	'A,	'A,		34	;.leq.
KBDKEY	50,	's,	'S,	'S,	'S,		35	;.geq
KBDKEY	51,	'd,	'D,	'D,	'D,		36	;equivalence
KBDKEY	52,	'f,	'F,	'F,	'F,		17	;delta (partial derivative)
KBDKEY	53,	'g,	'G,	'G,	'G,		32	;not equals
KBDKEY	54,	'h,	'H,	'H,	'H,		-13	;HELP!!!!!
KBDKEY	55,	'j,	'J,	'J,	'J,		30	;back arrow
KBDKEY	56,	'k,	'K,	'K,	'K,		31	;forward arrow
KBDKEY	57,	'l,	'L,	'L,	'L,		27	;both ways arrow
KBDKEY	60,<';>,	'+,<';>,	'+,		'+
KBDKEY	61,	':,	'*,	':,	'*,		'*
KBDKEY	62,	15,	15,	15,	15,		15	;carriage return
KBDKEY	63,	12,	12,	12,	12,		12	;line feed
KBDKEY	64,	37,	37,	37,	37,		37	;next, back gives ^_
;KBDKEY	64,	-12,	-11,	-12,	-11,		-11	;next, back
KBDKEY	65,	'z,	'Z,	'Z,	'Z,		2	;alpha
KBDKEY	66,	'x,	'X,	'X,	'X,		3	;beta
KBDKEY	67,	'c,	'C,	'C,	'C,		6	;epsilon
KBDKEY	70,	'v,	'V,	'V,	'V,		10	;lambda
KBDKEY	71,	'b,	'B,	'B,	'B,		7	;pi
KBDKEY	72,	'n,	'N,	'N,	'N,		24	;for all
KBDKEY	73,	'm,	'M,	'M,	'M,		25	;there exists
KBDKEY	74,<',>,	'<,<',>,	'<,		'<
KBDKEY	75,	'.,	'>,	'.,	'>,		'>
KBDKEY	76,	'/,	'?,	'/,	'?,		'?
KBDKEY	77,	40,	40,	40,	40,		40	;space
.ENDC ;KBDP
.SBTTL FONT MACROS AND DEFINITION

.IIF E FONTSW,CTAB==0
.IF NE FONTSW
FNTORG==.
	.MACRO CTBENT A
	.XCREF ...'A
	...'A
	.ENDM

CTAB:	.REPT 200
	CTBENT \.RPCNT
	.ENDR

.MACRO	FONT A
....==0
...==1_GRIDWD

.IRPC	CHR,A
...==..._<-1>
.IF NB	CHR
....==....!...
.ENDC
.ENDM

.IF NE	...-1
ERROR	\CURCHR
.ENDC

;...FOO==%XLIST
;.REPT ...FOO
;.LIST
;.ENDR
.BYTE	....
;.XLIST
;%XLIST=...FOO
.ENDM

.MACRO CDEF A
CURCHR==''A
CDEF1	\CURCHR
.ENDM

.MACRO	CDEF1 A
;.XCREF ...'A
CURCHR==A
;...FOO==%XLIST
;.REPT ...FOO
;.LIST
;.ENDR
...'A==.
;.XLIST
;%XLIST=...FOO
.ENDM

.MACRO	ERROR NUM
.IF1
.ERROR	;FONT LOSSAGE NUM
.ENDC
.ENDM
.ENDC
.XLIST
.IF NE FONTSW
.IF NE FONTMS
.XCREF CURCHR,FONT,CDEF1,CDEF

CDEF1 0
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 1
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <* * *>
FONT < *** >
FONT <  *  >
FONT <     >
FONT <     >

CDEF1 2
FONT <     >
FONT <     >
FONT <     >
FONT < ** *>
FONT <*  * >
FONT <*  * >
FONT <*  * >
FONT < ** *>
FONT <     >
FONT <     >

CDEF1 3
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <**** >
FONT <*   *>
FONT <**** >
FONT <*    >
FONT <*    >

CDEF1 4
FONT <     >
FONT <     >
FONT <     >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 5
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT <    *>
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 6
FONT <     >
FONT <     >
FONT <     >
FONT <  ** >
FONT < *   >
FONT < *** >
FONT < *   >
FONT <  ** >
FONT <     >
FONT <     >

CDEF1 7
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT < * * >
FONT < * * >
FONT < * * >
FONT < * * >
FONT <     >
FONT <     >

CDEF1 10
FONT <     >
FONT <     >
FONT <*    >
FONT <*    >
FONT < *   >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF1 11
FONT <***  >
FONT < *   >
FONT < *   >
FONT < *   >
FONT <     >
FONT <  ** >
FONT <  * *>
FONT <  ** >
FONT <  * *>
FONT <  ** >

CDEF1 12
FONT <*    >
FONT <*    >
FONT <*    >
FONT <***  >
FONT <     >
FONT <  ***>
FONT <  *  >
FONT <  ** >
FONT <  *  >
FONT <     >

CDEF1 13
FONT <     >
FONT <  *  >
FONT < *** >
FONT <* * *>
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF1 14
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <*****>
FONT <  *  >
FONT <  *  >
FONT <*****>
FONT <     >
FONT <     >
FONT <     >

CDEF1 15
FONT < *** >
FONT <*    >
FONT <*    >
FONT < *** >
FONT <     >
FONT < *** >
FONT < *  *>
FONT < *** >
FONT < *  *>
FONT < *  *>

CDEF1 16
FONT <     >
FONT <     >
FONT <     >
FONT < * * >
FONT <* * *>
FONT <* * *>
FONT < * * >
FONT <     >
FONT <     >
FONT <     >

CDEF1 17
FONT <     >
FONT < **  >
FONT <   * >
FONT <    *>
FONT < ****>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF1 20
FONT <     >
FONT <     >
FONT < ****>
FONT <*    >
FONT <*    >
FONT <*    >
FONT < ****>
FONT <     >
FONT <     >
FONT <     >

CDEF1 21
FONT <     >
FONT <     >
FONT <**** >
FONT <    *>
FONT <    *>
FONT <    *>
FONT <**** >
FONT <     >
FONT <     >
FONT <     >

CDEF1 22
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 23
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 24
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*****>
FONT <*   *>
FONT < * * >
FONT < * * >
FONT <  *  >
FONT <     >
FONT <     >

CDEF1 25
FONT <     >
FONT <*****>
FONT <    *>
FONT <    *>
FONT < ****>
FONT <    *>
FONT <    *>
FONT <*****>
FONT <     >
FONT <     >

CDEF1 26
FONT <     >
FONT <     >
FONT < *** >
FONT <** **>
FONT <* * *>
FONT <** **>
FONT < *** >
FONT <     >
FONT <     >
FONT <     >

CDEF1 27
FONT <     >
FONT <  *  >
FONT <   * >
FONT <*****>
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <*****>
FONT < *   >
FONT <  *  >

CDEF1 30
FONT <     >
FONT <     >
FONT <  *  >
FONT < *   >
FONT <*****>
FONT < *   >
FONT <  *  >
FONT <     >
FONT <     >
FONT <     >

CDEF1 31
FONT <     >
FONT <     >
FONT <  *  >
FONT <   * >
FONT <*****>
FONT <   * >
FONT <  *  >
FONT <     >
FONT <     >
FONT <     >

CDEF1 32
FONT <     >
FONT <    *>
FONT <   * >
FONT <*****>
FONT <  *  >
FONT <*****>
FONT < *   >
FONT <*    >
FONT <     >
FONT <     >

CDEF1 33
FONT <     >
FONT <  *  >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF1 34
FONT <     >
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <     >
FONT < *** >
FONT <     >
FONT <     >

CDEF1 35
FONT <     >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <     >
FONT < *** >
FONT <     >
FONT <     >

CDEF1 36
FONT <     >
FONT <     >
FONT <*****>
FONT <     >
FONT <*****>
FONT <     >
FONT <*****>
FONT <     >
FONT <     >
FONT <     >

CDEF1 37
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF < >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <!>
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <  *  >
FONT <     >
FONT <     >

CDEF <">
FONT < * * >
FONT < * * >
FONT < * * >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <#>
FONT <     >
FONT <     >
FONT < * * >
FONT <*****>
FONT < * * >
FONT < * * >
FONT <*****>
FONT < * * >
FONT <     >
FONT <     >

CDEF <$>
FONT <  *  >
FONT < *** >
FONT <* * *>
FONT <* *  >
FONT < *** >
FONT <  * *>
FONT <* * *>
FONT < *** >
FONT <  *  >
FONT <     >

CDEF <%>
FONT <     >
FONT <*****>
FONT <**  *>
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <*  **>
FONT <*  **>
FONT <     >
FONT <     >

CDEF <&>
FONT <     >
FONT < *   >
FONT <* *  >
FONT <* *  >
FONT < *   >
FONT <* * *>
FONT <*  * >
FONT < ** *>
FONT <     >
FONT <     >

CDEF <'>
FONT < **  >
FONT < **  >
FONT <**   >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <(>
FONT <     >
FONT <    *>
FONT <   * >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <   * >
FONT <    *>
FONT <     >
FONT <     >

CDEF <)>
FONT <     >
FONT <*    >
FONT < *   >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT < *   >
FONT <*    >
FONT <     >
FONT <     >

CDEF <*>
FONT <     >
FONT <  *  >
FONT <* * *>
FONT < *** >
FONT <  *  >
FONT < *** >
FONT <* * *>
FONT <  *  >
FONT <     >
FONT <     >

CDEF <+>
FONT <     >
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <*****>
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >
FONT <     >

CDEF <,>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT < **  >
FONT < **  >
FONT <**   >
FONT <     >

CDEF <->
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <.>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT < **  >
FONT < **  >
FONT <     >
FONT <     >

CDEF </>
FONT <     >
FONT <     >
FONT <    *>
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <*    >
FONT <     >
FONT <     >
FONT <     >

CDEF 0
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*  **>
FONT <* * *>
FONT <**  *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 1
FONT <     >
FONT <  *  >
FONT < **  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT < *** >
FONT <     >
FONT <     >

CDEF 2
FONT <     >
FONT < *** >
FONT <*   *>
FONT <    *>
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <*****>
FONT <     >
FONT <     >

CDEF 3
FONT <     >
FONT < *** >
FONT <*   *>
FONT <    *>
FONT <  ** >
FONT <    *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 4
FONT <     >
FONT <   * >
FONT <  ** >
FONT < * * >
FONT <*  * >
FONT <*****>
FONT <   * >
FONT <   * >
FONT <     >
FONT <     >

CDEF 5
FONT <     >
FONT <*****>
FONT <*    >
FONT <**** >
FONT <    *>
FONT <    *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 6
FONT <     >
FONT <  ** >
FONT < *   >
FONT <*    >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 7
FONT <     >
FONT <*****>
FONT <    *>
FONT <   * >
FONT <   * >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF 8
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF 9
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT < ****>
FONT <    *>
FONT <   * >
FONT < **  >
FONT <     >
FONT <     >

CDEF <:>
FONT <     >
FONT <     >
FONT <     >
FONT < **  >
FONT < **  >
FONT <     >
FONT < **  >
FONT < **  >
FONT <     >
FONT <     >

CDEF <;>
FONT <     >
FONT <     >
FONT <     >
FONT < **  >
FONT < **  >
FONT <     >
FONT < **  >
FONT < **  >
FONT <**   >
FONT <     >

CDEF1 74
FONT <     >
FONT <     >
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <     >
FONT <     >
FONT <     >

CDEF <=>
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT <     >
FONT <*****>
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 76
FONT <     >
FONT <     >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <  *  >
FONT < *   >
FONT <     >
FONT <     >
FONT <     >

CDEF <?>
FONT <     >
FONT < *** >
FONT <*   *>
FONT <   * >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <  *  >
FONT <     >
FONT <     >

CDEF <@>
FONT <     >
FONT < *** >
FONT <*   *>
FONT <* ***>
FONT <* * *>
FONT <* ***>
FONT <*    >
FONT < *** >
FONT <     >
FONT <     >

CDEF A
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*****>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF B
FONT <     >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <     >
FONT <     >

CDEF C
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF D
FONT <     >
FONT <**** >
FONT < *  *>
FONT < *  *>
FONT < *  *>
FONT < *  *>
FONT < *  *>
FONT <**** >
FONT <     >
FONT <     >

CDEF E
FONT <     >
FONT <*****>
FONT <*    >
FONT <*    >
FONT <**** >
FONT <*    >
FONT <*    >
FONT <*****>
FONT <     >
FONT <     >

CDEF F
FONT <     >
FONT <*****>
FONT <*    >
FONT <*    >
FONT <**** >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <     >
FONT <     >

CDEF G
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*    >
FONT <*    >
FONT <*  **>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF H
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*****>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF I
FONT <     >
FONT < *** >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT < *** >
FONT <     >
FONT <     >

CDEF J
FONT <     >
FONT <    *>
FONT <    *>
FONT <    *>
FONT <    *>
FONT <    *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF K
FONT <     >
FONT <*   *>
FONT <*  * >
FONT <* *  >
FONT <**   >
FONT <* *  >
FONT <*  * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF L
FONT <     >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <*****>
FONT <     >
FONT <     >

CDEF M
FONT <     >
FONT <*   *>
FONT <** **>
FONT <* * *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF N
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <**  *>
FONT <* * *>
FONT <*  **>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF O
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF P
FONT <     >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <*    >
FONT <*    >
FONT <*    >
FONT <     >
FONT <     >

CDEF Q
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <* * *>
FONT <*  * >
FONT < ** *>
FONT <     >
FONT <     >

CDEF R
FONT <     >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <* *  >
FONT <*  * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF S
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*    >
FONT < *** >
FONT <    *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF T
FONT <     >
FONT <*****>
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF U
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF V
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT < * * >
FONT <  *  >
FONT <     >
FONT <     >

CDEF W
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <* * *>
FONT <** **>
FONT <*   *>
FONT <     >
FONT <     >

CDEF X
FONT <     >
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF Y
FONT <     >
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF Z
FONT <     >
FONT <*****>
FONT <    *>
FONT <   * >
FONT <*****>
FONT < *   >
FONT <*    >
FONT <*****>
FONT <     >
FONT <     >

CDEF <[>
FONT <  ***>
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  ***>
FONT <     >

CDEF <\>
FONT <     >
FONT <     >
FONT <*    >
FONT < *   >
FONT <  *  >
FONT <   * >
FONT <    *>
FONT <     >
FONT <     >
FONT <     >

CDEF <]>
FONT <***  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <***  >
FONT <     >

CDEF <^>
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF <_>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <*****>

CDEF <`>
FONT <  ** >
FONT <  ** >
FONT <   **>
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF a
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <    *>
FONT < ****>
FONT <*   *>
FONT < ****>
FONT <     >
FONT <     >

CDEF b
FONT <     >
FONT <*    >
FONT <*    >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <     >
FONT <     >

CDEF c
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*    >
FONT <*    >
FONT < ****>
FONT <     >
FONT <     >

CDEF d
FONT <     >
FONT <    *>
FONT <    *>
FONT < ****>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < ****>
FONT <     >
FONT <     >

CDEF e
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <**** >
FONT <*    >
FONT < *** >
FONT <     >
FONT <     >

CDEF f
FONT <     >
FONT <  ** >
FONT < *  *>
FONT < *   >
FONT <***  >
FONT < *   >
FONT < *   >
FONT < *   >
FONT <     >
FONT <     >

CDEF g
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < ****>
FONT <    *>
FONT < *** >

CDEF h
FONT <     >
FONT <*    >
FONT <*    >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF i
FONT <     >
FONT <     >
FONT <  *  >
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF j
FONT <     >
FONT <     >
FONT <    *>
FONT <     >
FONT <    *>
FONT <    *>
FONT <    *>
FONT <    *>
FONT <*   *>
FONT < *** >

CDEF k
FONT <     >
FONT <*    >
FONT <*    >
FONT <*   *>
FONT <*  * >
FONT <***  >
FONT <*  * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF l
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <     >
FONT <     >

CDEF m
FONT <     >
FONT <     >
FONT <     >
FONT <** * >
FONT <* * *>
FONT <* * *>
FONT <* * *>
FONT <* * *>
FONT <     >
FONT <     >

CDEF n
FONT <     >
FONT <     >
FONT <     >
FONT <* ** >
FONT <**  *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <     >
FONT <     >

CDEF o
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF p
FONT <     >
FONT <     >
FONT <     >
FONT <**** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <**** >
FONT <*    >
FONT <*    >

CDEF q
FONT <     >
FONT <     >
FONT <     >
FONT < *** >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < ****>
FONT <    *>
FONT <    *>

CDEF r
FONT <     >
FONT <     >
FONT <     >
FONT <* ** >
FONT <**  *>
FONT <*    >
FONT <*    >
FONT <*    >
FONT <     >
FONT <     >

CDEF s
FONT <     >
FONT <     >
FONT <     >
FONT < ****>
FONT <*    >
FONT < *** >
FONT <    *>
FONT <**** >
FONT <     >
FONT <     >

CDEF t
FONT <     >
FONT <  *  >
FONT <  *  >
FONT <*****>
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <   **>
FONT <     >
FONT <     >

CDEF u
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < *** >
FONT <     >
FONT <     >

CDEF v
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT <     >
FONT <     >

CDEF w
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <* * *>
FONT <* * *>
FONT < * * >
FONT <     >
FONT <     >

CDEF x
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT < * * >
FONT <*   *>
FONT <     >
FONT <     >

CDEF y
FONT <     >
FONT <     >
FONT <     >
FONT <*   *>
FONT <*   *>
FONT <*   *>
FONT < * * >
FONT <  *  >
FONT < *   >
FONT <*    >

CDEF z
FONT <     >
FONT <     >
FONT <     >
FONT <*****>
FONT <   * >
FONT < *** >
FONT < *   >
FONT <*****>
FONT <     >
FONT <     >

CDEF1 173
FONT <    *>
FONT <   * >
FONT <   * >
FONT <   * >
FONT <  *  >
FONT <   * >
FONT <   * >
FONT <   * >
FONT <    *>
FONT <     >

CDEF1 174
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >
FONT <  *  >

CDEF1 175
FONT <*    >
FONT < *   >
FONT < *   >
FONT < *   >
FONT <  *  >
FONT < *   >
FONT < *   >
FONT < *   >
FONT <*    >
FONT <     >

CDEF1 176
FONT < ** *>
FONT <* ** >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >
FONT <     >

CDEF1 177
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
FONT <*****>
.ENDC	;.IF NE FONTMS
.IF E FONTMS
...0==.
.BYTE 140,140,140,140,140,140,140,140,140,140
...1==.
.BYTE 000,004,004,004,004,025,016,004,000,000
...2==.
.BYTE 000,000,000,015,022,022,022,015,000,000
...3==.
.BYTE 000,000,000,016,021,036,021,036,020,020
...4==.
.BYTE 000,000,000,004,012,021,000,000,000,000
...5==.
.BYTE 000,000,000,000,037,001,000,000,000,000
...6==.
.BYTE 000,000,000,006,010,016,010,006,000,000
...7==.
.BYTE 000,000,000,037,012,012,012,012,000,000
...10==.
.BYTE 000,000,020,020,010,004,012,021,000,000
...11==.
.BYTE 034,010,010,010,000,006,005,006,005,006
...12==.
.BYTE 020,020,020,034,000,007,004,006,004,000
...13==.
.BYTE 000,004,016,025,004,004,004,004,000,000
...14==.
.BYTE 000,004,004,037,004,004,037,000,000,000
...15==.
.BYTE 016,020,020,016,000,016,011,016,011,011
...16==.
.BYTE 000,000,000,012,025,025,012,000,000,000
...17==.
.BYTE 000,014,002,001,017,021,021,016,000,000
...20==.
.BYTE 000,000,017,020,020,020,017,000,000,000
...21==.
.BYTE 000,000,036,001,001,001,036,000,000,000
...22==.
.BYTE 000,000,016,021,021,021,000,000,000,000
...23==.
.BYTE 000,000,021,021,021,016,000,000,000,000
...24==.
.BYTE 000,021,021,037,021,012,012,004,000,000
...25==.
.BYTE 000,037,001,001,017,001,001,037,000,000
...26==.
.BYTE 000,000,016,033,025,033,016,000,000,000
...27==.
.BYTE 000,004,002,037,002,004,010,037,010,004
...30==.
.BYTE 000,000,004,010,037,010,004,000,000,000
...31==.
.BYTE 000,000,004,002,037,002,004,000,000,000
...32==.
.BYTE 000,001,002,037,004,037,010,020,000,000
...33==.
.BYTE 000,004,004,012,021,012,004,004,000,000
...34==.
.BYTE 000,002,004,010,004,002,000,016,000,000
...35==.
.BYTE 000,010,004,002,004,010,000,016,000,000
...36==.
.BYTE 000,000,037,000,037,000,037,000,000,000
...37==.
.BYTE 000,000,000,021,012,004,000,000,000,000
...40==.
.BYTE 000,000,000,000,000,000,000,000,000,000
...41==.
.BYTE 000,004,004,004,004,004,000,004,000,000
...42==.
.BYTE 012,012,012,000,000,000,000,000,000,000
...43==.
.BYTE 000,000,012,037,012,012,037,012,000,000
...44==.
.BYTE 004,016,025,024,016,005,025,016,004,000
...45==.
.BYTE 000,037,031,002,004,010,023,023,000,000
...46==.
.BYTE 000,010,024,024,010,025,022,015,000,000
...47==.
.BYTE 014,014,030,000,000,000,000,000,000,000
...50==.
.BYTE 000,001,002,004,004,004,002,001,000,000
...51==.
.BYTE 000,020,010,004,004,004,010,020,000,000
...52==.
.BYTE 000,004,025,016,004,016,025,004,000,000
...53==.
.BYTE 000,000,004,004,037,004,004,000,000,000
...54==.
.BYTE 000,000,000,000,000,000,014,014,030,000
...55==.
.BYTE 000,000,000,000,037,000,000,000,000,000
...56==.
.BYTE 000,000,000,000,000,000,014,014,000,000
...57==.
.BYTE 000,000,001,002,004,010,020,000,000,000
...60==.
.BYTE 000,016,021,023,025,031,021,016,000,000
...61==.
.BYTE 000,004,014,004,004,004,004,016,000,000
...62==.
.BYTE 000,016,021,001,002,004,010,037,000,000
...63==.
.BYTE 000,016,021,001,006,001,021,016,000,000
...64==.
.BYTE 000,002,006,012,022,037,002,002,000,000
...65==.
.BYTE 000,037,020,036,001,001,021,016,000,000
...66==.
.BYTE 000,006,010,020,036,021,021,016,000,000
...67==.
.BYTE 000,037,001,002,002,004,004,004,000,000
...70==.
.BYTE 000,016,021,021,016,021,021,016,000,000
...71==.
.BYTE 000,016,021,021,017,001,002,014,000,000
...72==.
.BYTE 000,000,000,014,014,000,014,014,000,000
...73==.
.BYTE 000,000,000,014,014,000,014,014,030,000
...74==.
.BYTE 000,000,002,004,010,004,002,000,000,000
...75==.
.BYTE 000,000,000,037,000,037,000,000,000,000
...76==.
.BYTE 000,000,010,004,002,004,010,000,000,000
...77==.
.BYTE 000,016,021,002,004,004,000,004,000,000
...100==.
.BYTE 000,016,021,027,025,027,020,016,000,000
...101==.
.BYTE 000,016,021,021,037,021,021,021,000,000
...102==.
.BYTE 000,036,021,021,036,021,021,036,000,000
...103==.
.BYTE 000,016,021,020,020,020,021,016,000,000
...104==.
.BYTE 000,036,011,011,011,011,011,036,000,000
...105==.
.BYTE 000,037,020,020,036,020,020,037,000,000
...106==.
.BYTE 000,037,020,020,036,020,020,020,000,000
...107==.
.BYTE 000,016,021,020,020,023,021,016,000,000
...110==.
.BYTE 000,021,021,021,037,021,021,021,000,000
...111==.
.BYTE 000,016,004,004,004,004,004,016,000,000
...112==.
.BYTE 000,001,001,001,001,001,021,016,000,000
...113==.
.BYTE 000,021,022,024,030,024,022,021,000,000
...114==.
.BYTE 000,020,020,020,020,020,020,037,000,000
...115==.
.BYTE 000,021,033,025,021,021,021,021,000,000
...116==.
.BYTE 000,021,021,031,025,023,021,021,000,000
...117==.
.BYTE 000,016,021,021,021,021,021,016,000,000
...120==.
.BYTE 000,036,021,021,036,020,020,020,000,000
...121==.
.BYTE 000,016,021,021,021,025,022,015,000,000
...122==.
.BYTE 000,036,021,021,036,024,022,021,000,000
...123==.
.BYTE 000,016,021,020,016,001,021,016,000,000
...124==.
.BYTE 000,037,004,004,004,004,004,004,000,000
...125==.
.BYTE 000,021,021,021,021,021,021,016,000,000
...126==.
.BYTE 000,021,021,021,021,012,012,004,000,000
...127==.
.BYTE 000,021,021,021,021,025,033,021,000,000
...130==.
.BYTE 000,021,021,012,004,012,021,021,000,000
...131==.
.BYTE 000,021,021,012,004,004,004,004,000,000
...132==.
.BYTE 000,037,001,002,037,010,020,037,000,000
...133==.
.BYTE 007,004,004,004,004,004,004,004,007,000
...134==.
.BYTE 000,000,020,010,004,002,001,000,000,000
...135==.
.BYTE 034,004,004,004,004,004,004,004,034,000
...136==.
.BYTE 004,012,021,000,000,000,000,000,000,000
...137==.
.BYTE 000,000,000,000,000,000,000,000,000,037
...140==.
.BYTE 006,006,003,000,000,000,000,000,000,000
...141==.
.BYTE 000,000,000,016,001,017,021,017,000,000
...142==.
.BYTE 000,020,020,036,021,021,021,036,000,000
...143==.
.BYTE 000,000,000,016,021,020,020,017,000,000
...144==.
.BYTE 000,001,001,017,021,021,021,017,000,000
...145==.
.BYTE 000,000,000,016,021,036,020,016,000,000
...146==.
.BYTE 000,006,011,010,034,010,010,010,000,000
...147==.
.BYTE 000,000,000,016,021,021,021,017,001,016
...150==.
.BYTE 000,020,020,036,021,021,021,021,000,000
...151==.
.BYTE 000,000,004,000,004,004,004,004,000,000
...152==.
.BYTE 000,000,001,000,001,001,001,001,021,016
...153==.
.BYTE 000,020,020,021,022,034,022,021,000,000
...154==.
.BYTE 000,004,004,004,004,004,004,004,000,000
...155==.
.BYTE 000,000,000,032,025,025,025,025,000,000
...156==.
.BYTE 000,000,000,026,031,021,021,021,000,000
...157==.
.BYTE 000,000,000,016,021,021,021,016,000,000
...160==.
.BYTE 000,000,000,036,021,021,021,036,020,020
...161==.
.BYTE 000,000,000,016,021,021,021,017,001,001
...162==.
.BYTE 000,000,000,026,031,020,020,020,000,000
...163==.
.BYTE 000,000,000,017,020,016,001,036,000,000
...164==.
.BYTE 000,004,004,037,004,004,004,003,000,000
...165==.
.BYTE 000,000,000,021,021,021,021,016,000,000
...166==.
.BYTE 000,000,000,021,021,021,012,004,000,000
...167==.
.BYTE 000,000,000,021,021,025,025,012,000,000
...170==.
.BYTE 000,000,000,021,012,004,012,021,000,000
...171==.
.BYTE 000,000,000,021,021,021,012,004,010,020
...172==.
.BYTE 000,000,000,037,002,016,010,037,000,000
...173==.
.BYTE 001,002,002,002,004,002,002,002,001,000
...174==.
.BYTE 004,004,004,004,004,004,004,004,004,004
...175==.
.BYTE 020,010,010,010,004,010,010,010,020,000
...176==.
.BYTE 015,026,000,000,000,000,000,000,000,000
...177==.
.BYTE 037,037,037,037,037,037,037,037,037,037
.ENDC	;.IF E FONTMS
.LIST

.IIF E FONTSW,.=.+3000		;APPROXIMATE SIZE OF FONT

REPORT FONT SIZE=,\.-FNTORG
.NLIST
.ENDC	;.IF NE FONTSW
.LIST

PPVAR:		.OFFSET -.	;PAGE PRINTER VARIABLES.
PPCC::		TVLO		;ADDRESS WHERE NEXT CHARACTER GOES
PPPHS::		20-CHRWD	;CHARACTER PHASE
;PPX::		-BITPL		;X POSITION OF CHARACTER
;PPLE::		0		;LINE EDITOR ASSOCIATED WITH PAGE
;PPCREG::	.BYTE -1	;CONSOLE REGISTER #
;		.BYTE 0		;UNUSED

;PPCHN::	-1		;PAGE PRINTER CHANNEL, -1=>THESE VARIABLES UNUSED
;PPY::		-NLINS		;Y POSITION
PPLCC::		TVLO		;ORIGIN OF THIS LINE IN MEMORY
PPORG::		TVLO		;ORIGIN OF THIS PIECE OF PAPER IN MEMORY
PPCPOS::	0		;CHARACTER COLUMN POSITION (0=LEFT MARGIN)
PPLINE::	0		;LINE NUMBER (0=TOP LINE)
;PPXORG::	-BITPL		;X ORIGIN OF PAGE
;PPYORG::	-NLINS		;Y ORIGIN OF PAGE
;PPFONT::	CTAB		;FONT WE ARE PRINTING WITH
;PPLPG::	.BYTE 4		;LINES/GLITCH COUNTER
;PPLPGK::	.BYTE 4		;LINES/GLITCH CONSTANT (0=>WRAP AROUND)
;PPNGL::	.BYTE 11	;# GLITCHES/PAGE COUNTER
;PPNGLK::	.BYTE 11	;# GLITCHES/PAGE CONSTANT
PPLEN::		.OFFSET 0

CPOS=PPVAR+PPCPOS
CLINE=PPVAR+PPLINE

BLKPHS:	0	;0 NORMAL 1 CHAR UNDER BLINKER INVERTED
BLKTIM:	0	;COUNT DOWN CLOCK BREAKS UNTIL BLINK
BELTIM:	0	;IF NON-ZERO, COUNT DOWN CLOCK BREAKS UNTIL BELL
.ENDC ;TVP
BLKDFR:	0	;NON-ZERO INHIBIT BLINKING [OUTSIDE CONDITIONAL FOR EASE]

.SBTTL SOME LOWER LEVEL GOODIES

ACSAV:	PUSH	A		;CALL WITH JSR U,
	PUSH	B
	PUSH	C
	PUSH	T
	PUSH	TT
	JMP	@U

ACRES:	TST	(SP)+		;CALL WITH JSR U,
	POP	TT
	POP	T
	POP	C
	POP	B
	POP	A
	RTS	U

.IFNZ DEBUG

;DEBST-- START UP 11/20

DEBST:	MOV	#174000,AKLIS
	MOV	#174002,AKLIB
	MOV	#174004,AKLOS
	MOV	#174006,AKLOB
	MOV	#KLIBRK,320	;WAS CLOBBERED
	MOV	#DSBRK,20	;USE IOT TO FAKE DISPLAY INTERRUPT
	MOV	DSPSW,22
	MOV	#FDPC,ADPC
	RTS	PC

FDPC:	0	;FAKE DPC

.ENDC ;DEBUG

.SBTTL VARIABLES

;SOME DEBUGGING AIDS

VERSE:	%FNAM2	;VERSION NUMBER

.IFNZ GT40P
ADPC:	DPC	;CAN BE CHANGED TO NON-NXM FOR DEBUGGING ON PDP11
.ENDC ;GT40P
AKLIS:	KLIS
AKLIB:	KLIB
AKLOS:	KLOS
AKLOB:	KLOB

;VARIABLES

ACTCHR:	0	;# CHARACTERS BUFFERED
MAXACT:	0	;THE BIGGEST ACTCHR WE'VE SEEN
GETCC:	0	;WHERE TO GET NEXT CHARACTER
PUTCC:	0	;WHERE TO PUT NEXT CHARACTER

.IFNZ GT40P
CURSX:	0	;X-Y CURSOR POSITION
CURSY:	0	; (SCOPE COORDS)
BYTCNT:	0	;# CHARACTERS ON THIS LINE
LINPNT:	0	;BYTE POINTER INTO LINBUF
OCSR:	0	;OLD CONSOLE SWITCH REGISTER
AVAIL:	0	;POINTS TO FIRST FREE BLOCK
ROVER:	0	;POINTS TO HEAD OF SEARCH LIST
OLDBLK:	0
CASE:	0	;-1 IMPLIES SHIFT OUT (SPECIAL CHARACTERS)
TEXTP:	0	;INDIRECT POINTER TO TEXT LINE
TLINE:	0	;INDEX OF TOP RING ON SCREEN
CKS:	0	;LODER CHECKSUM
COMAND:	0	;FOR DEBUGGING (DISPLAY SLAVE COMMAND)
COUNT:	0	;FOR DEBUGGING (# BYTES IN LODER BLOCK)
CLINE:	0	;CURRENT LINE (STARTS AT 0)
CPOS:	0	;CURSOR POSITION ON LINE
.ENDC ;GT40P
MEMTOP:	0	;FIRST NXM

.IFZ GT40P
CURSX: CURSY: RCURSX: RCURSY: 0	;THESE ARE HERE TO MAKE PALX HAPPY
.ENDC

;INTERUPT LEVEL STORAGE

;.IFNZ DLIMSW
;TICKS:	0	;CLOCK TICK TIMER
;DTIME:	0	;TIME TO DISPLAY EVERYTHING
;DSTOPD:	0	;IF NON 0, WHERE DISPLAY STOPPED
;.ENDC
.IFNZ PCHIST
PCPNT:	0
PCBUF:	.=.+PCBFL
.ENDC
RETLAD:	0	;ADDRESS OF BLOCK TO BE RETURNED
SAVSP:	0	;SP SAVED AT POWER FAILURE
SAVDPC:	0	;DPY STATUS AT LAST DISPLAY BREAK
SAVDSR:	0
SAVXSR:	0
SAVYSR:	0
FORGIV:	0	;IF NON-ZERO, IGNORE MYSTERIOUS DISPLAYS STOPS

;CONSOLE RELATED STORAGE AND SWITCHES

CNHTTY:	0	;0 NORMAL DATAPOINT MODE TO 10, NON-ZERO LM CONSOLE HAS THE TTY
;LMHTTY:	0	;NON-ZERO LISP MACHINE HAS THE TTY, NEGATIVE REMOTE CONSOLE MODE
;LMTOCK: 0	;LISP-MACHINE TYPE-OUT CHECK DELAY COUNTER

TNRQFG:	0	;-1 PROCESSING REGISTER EXAM/DEPOS REQUEST FROM 10
CONSF:	0	;0 FULL CONSOLE SCREEN USED FOR TTY
		;-1 BOTTOM N LINES USED TO DISPLAY "LISP MACHINE CONSOLE"
TYIQM:	0	;TYPE IN QUOTE MODE
		;CHARACTERS ARE ACTED UPON AT THE INTERRUPT LEVEL AS FOLLOWS:
		;ALWAYS ACTIVE:
		; ^Q QUOTES FOLLOWING CHR
		; ^X ENTERS CONSOLE MONITOR MODE
		;IN ADDITION, IF TYIQM=2
		; ^S STOP LISP MACHINE
		; ^N SINGLE STEP LISP MACHINE
		; ^D COMPLEMENT DISPLAY CONSOLE SWITCH
		;   (HOWEVER, THE CONSOLE IS ALWAYS DISPLAYED IN CONSOLE MONITOR MODE,
		;   INDEPENDANT OF THE SETTING OF THE DISPLAY CONSOLE SWITCH).
TYIQF:	0	;IF -1, QUOTE NEXT TYI CHAR
TYICH:	0	;CHAR INPUT FROM KEYBOARD FOR CONSOLE MONITOR
CMREQ:	-1	;-1 NOT TRYING TO REACH CONSOLE MONITOR LEVEL
		;0 CNTRL X TYPED. RANDOM LOOPS SEEING THIS SHOULD XFER TO
		;  CONSOLE MONITOR LOOP
		;  IF A SECOND CNTRL X IS TYPED WHEN CMREQ=0, A GROSS QUIT OUT
		;  AND REINITIALIZATION AT GO WILL OCCUR.
CDLNN:	CHRLN-7	;LINE NUMBER TO START CONSOLE DISPLAY ON
		; (THIS MAY MAKE REMAINING SCREEN DATAPOINT SIZED)

;SAVED CONS MACHINE STATE
CSSWO:	;ORIGIN OF BLOCK OF SWITCHES ACCESSIBLE VIA RACSWO-RACSWE REGISTER
	;ADDRESSES
CPSVAL:	0	;NON ZERO -> PASSIVE STATE SAVE VALID
CFSVAL:	0	;NON ZERO -> FULL STATE SAVE VALID
	   ;THE "RUN" FLIP-FLOP IN CONS:
	   ; CTRUN REFLECTS THE "COMMAND" FROM THE 10 OR THE GT40 KEYBOARD.
	   ;WHEN THE 10 EXAMINES RAGO, THE CONTENTS OF CTRUN ARE RETURNNED.
	   ;QDPGO AND QDPSTP ARE THE ROUTINES TO SET AND CLEAR CTRUN RESPECTIVELY.
	   ; CRUN REFLECTS THE "ACTUAL" STATE OF CONS.  QDPRUN AND QDPHLT
	   ;ARE ROUTINES TO SET AND CLEAR CRUN.  NORMALLY, CRUN "FOLLOWS" CTRUN,
	   ;BUT VARIOUS CIRCUMSTANCES AND CAUSE IT TO DIFFER MOMENTARILY
	   ;(TYPE IN/OUT LOSSAGE NOTABLY).
CRUN:	0	;NON ZERO -> CONS ACTUALLY RUNNING
		; IF THIS SET, CONS CLOCK SHOULD ACTUALLY BE TICKING AT HIGH SPEED.
		; SET BY QDPRUN, CLEARED BY ESTOP (AND QDPHLT WHICH CALLS IT).
CTRUN:	0	;NON ZERO -> CONS "TRYING" TO RUN, ALTHO IT MAY BE TEMPORARILY STOPPED.
		; SET BY QDPGO (CNTRL-P OR RUN COMMAND FROM 10)
		; CLEARED BY QDPSTP (CNTRL-S OR STOP COMMAND FROM 10)
		; ALSO IF CRUN WAS -1 AND CONS HALTED DUE TO AN ERROR

CLLMOD:	0	;NON ZERO "LOW LEVEL MODE", 0 NORMAL
NOOPF:	0	;NON ZERO -> NEXT INST WAS TO BE NO-OP ED WHEN
		; MACHINE STATE SAVED

MODREG:	0	;SAVES LAST SETTING OF MODE REGISTER (RAMOD)

TENMOD:	0	;NON ZERO -> PDP-10 FLAVOR CONSOLE PRGM ACTIVE, PDP-11 TO DO NOTHING
		;  EXCEPT CNTRL-META-CALL HACK.
CSSWE:	;END OF RACSW BLOCK
.IFGE <<CSSWE-CSSWO>/2-<RACSWE-RACSWO>>
	 .ERR RACSW OVERFLOW!!
.ENDC

COBUS:	0	;"OBSERVED" OBUS  (LOW 16 BITS)
	0	;    HIGH 16 BITS
CIR:	0	;"OBSERVED" IR 15-00
	0	;    IR 31-16
	0	;    IR 44-32
CPC:	0	;"OBSERVED" PC
CPCT:	0	; TEMP (AT FRCONS)
CCERR1:	0	;"OBSERVED" ERROR WD1
		;   (HIGH BYTE COMES FROM 164000 HIGH BYTE)
		;   (LOW BYTE COMES FROM HIGH BYTE OF 164002)
CCERR2:	0	;"OBSERVED" ERROR WD2
		;   (HIGH BYTE COMES FROM 164010 HIGH BYTE)
		;   (LOW BYTE FROM 164012 HIGH BYTE)

;M MEM LOCN 0 GET CLOBBERED BY VARIOUS OPERATIONS SO IT MUST
;BE SAVED AND RESTORED. IT AND A MEM LOCN 1 ARE USED WHEN
;WRITING CONTROL MEMORY

CMMEM0:	0	;SAVED M MEM LOCN 0 (LOW WD)
	0	;   HIGH WD
CAMEM1:	0	;SAVED A MEM LOCN 1 (LOW WD)
	0
CSVMA:	0	;SAVED VMA (LOW WD)
	0
CSPMD:	0	;SAVED PAGE MAP DATA (LOW WD). 1-BIT=READ-FLT, 2-BIT=WRT-FLT
	0
CSMWD:	0	;SAVED WRITE DATA REGISTER (LOW WD)
	0
CSMRD:	0	;SAVED READ DATA REGISTER
	0
CSMRDF:	0	;.NE. 0, -> READ DATA REGISTER ALTERED, SO (TRY) TO RESTORE IT

CSMGBR:	177	;ADDRESS OF GARBAGE REGISTER TO WRITE IN ORDER TO RELOAD (LAST IN PG 0)
	0	;READ DATA REGISTER (20 BIT PHYSICAL ADDRESS)
CL1M0:	0	;LEVEL 1 MAP, LOCN 0

CL1M0F:	0	;.NE. 0, LVL 1 MAP LOCN 0 HACKED
		; IF -1, 0 HAS BEEN WRITTEN IN HARDWARE
CL2M0:	0	;LEVEL 2 MAP, LOCN 0
	0
CL2M0F:	0	;.NE. 0, LVL 2 MAP LOCN 0 HACKED

CVMMWD:	0	;CONSOLE "VIRTUAL" MAIN MEM WRITE DATA REGISTER
	0
CVMVMA:	0	;CONSOLE "VIRTUAL" MAIN MEM ADDRESS  REGISTER
	0
CVMMRD:	0	;CONSOSLE "VIRTUAL" MAIN MEM READ DATA REGISTER
	0
CVMMPF:	0	;PAGE FAULT FLAG ON CONSOLE VIRTUAL READ/WRITE (0 OR 1)
USSVDF:	0	;U STACK SAVED IN USSVD
USTPNR:	0	;SAVED USTACK POINTER
USSVD:	.BLKW 32.	;SAVED STATE OF USTACK
USSVDE:			; (ALL 32 REGS SAVED SINCE THERE IS
			; NO RANDOM ACCESS TO HARDWARE RAM)

UI:	0	;TEM BLOCK FOR "ASSEMBLING" MICRO INSTRUCTIONS
	0
	0

OLDPCS:	.BLKW 8	;OLD PCS  

;COMMAND VARIABLES AND SWITCHES

CDNUM:	0	;ASSEMBLED DECIMAL NUMBER

CNUM:	0	;RETURNED NUMERIC VALUE FROM COMMAND SCANNER. 
	0	; (POTENTIALLY 3 PRECISION)
	0
	0	;MUST BE HERE SO RESET WILL RUN FAST!!
		; DURING READIN, ASSEMBLE OCTAL NUMBER HERE
CNUMF:	0	; (ON RETURN FROM GCOM) -1 NUMBER HAS BEEN TYPED VALUE IN CNUM

CBUFL==10		;COMMAND BUFFER LENGTH IN WDS

CBUF:	.BLKW CBUFL	;ASCIZ STRING TYPED IN

CDELIM:	0		;DELIMITER ENCOUNTERED
CBUFC:	0		;AMT OF ROOM REMAINING IN CBUF
GCMPTR:	0		;FILLING POINTER TO CBUF
CSYL:	0		;-1 NON NULL SYLABLE SEEN
CVAL:	0		;VALUE OF PREVIOUS COMMAND
	0		; POTENTIALLY 3 PRECISION
	0

CVALF:	0		;-1 -> CVAL NON-NULL
COMFRC:	0		;-1 FORCE NEXT CHR TO BE COMMAND CHAR (@ SETS THIS)
CONSPT:	0		;"." FOR CONS MACHINE
REGOPF:	0		;-1 REG OPEN


CIBUF:	.REPT 8		;CONSOLE INSTRUCTION BUFFER
	0
	0
	0
	.ENDR

;"RAID MODE" VARIABLES AND SWITCHES.
RAIDA:	.REPT 8		;REGISTER ADDRESSES TO BE DISPLAYED. 0 -> NULL
	0
	.ENDR
RAIDM:	0		;-1 CURRENTLY PRINTING TEXT IN RAID MODE,
			; IE WRAP CURSOR BETWEEN LINES 
			; C(RAIDN) AND CDLNN
DEPFLG:	0		;NON ZERO -> DEPOSIT TYPE OPERATION 
			; DONE BY LAST COMMAND, SO DO CDSPLY  

.SBTTL DISPLAY LISTS & BUFFERS
.IFNZ GT40P

;TEXT RING HEADER

DPYSA:
	STSNRM		;SET STATUS REGISTER
	SETPNT		;OFF SCREEN
	0		;WATSE SOME TIME TO LET
	1400		;THE MAIN PROGRAM RUN A LITTLE
	CHARS
	17		;SHIFT IN
	.ASCII /**************************/
	.EVEN
DPYSPT:	SETPNT+DPYNRM	;CURSOR
RCURSX:	0
RCURSY:	NLINS-CHRHT+1
	CHARS
	<177_10>+17	;CURSOR
	17		;SHIFT IN
	0
	SETPNT+DPYNRM
	0		;X
	NLINS-CHRHT+1	;Y
	DPYJSR
TXSTRT:	0		;PATCHED BY PROGRAM
	DPYJSR
	GRJSR
	DPYJMP
	DPYSA

GRHDR==.-HJSIDX
GRJSR:	DPYNOP
	DPYNOP
GRJMP:	DPYRTS
GRSTRT:	0

;FORMAT OF DISPLAY ITEM
HSPIDX==0	;SETPOINT
HXCIDX==2	;X CORDINATE
HYCIDX==4	;Y COORDINATE
HJSIDX==6	;DPYJSR
HDSIDX==10	;DESTINATION (LIST)
HJMIDX==12	;DPYJMP
HNXIDX==14	;ADDRESS OF NEXT HEADER
HITIDX==16	;ITEM NUMBER
HIAIDX==20	;ADDRESS OF LIST
HSCIDX==22	;# OF SUBROUTINE CALLS TO THIS LIST

HSIZE==HSCIDX+2		;SIZE OF HEADER
LINHDR==HYCIDX+2	;NUMBER OF LIST BYTES IN HEADER

;DISPLAY LIST
;DPYRTS
XITEM==2		;NUMBER OF EXTRA BYTES IN LIST (DPYRTS)

;RING OF LINE HEADERS

LHDRS==12	;SIZE OF LINE HEADER

		;DPYJSR
TXTIDX==2	;OFFSET OF TEXT POINTER
JMPIDX==4	;OFFSET OF DPYJMP
NXTIDX==6	;OFFSET OF NEXT LINE HEADER
BACIDX==10	;OFFSET OF BACK POINTER


FAKEL:	CHARS
	<<15_10>+12>
	DPYRTS

LOWLIN:	DPYJSR
	0
	DPYJMP
	.+4
	HILIN

.REPT CHRLN-2
.XLIST
	DPYJSR
	0
	DPYJMP
	.+4
	.+2-<LHDRS*2>
.LIST
.ENDR

HILIN:	DPYJSR
	0
	DPYRTS
	LOWLIN
	.+2-<LHDRS*2>
.ENDC ;GT40P
;DL11 INPUT BUFFER

BUF=.
.=.+BUFSIZ
BUFEND==.

.IFNZ GT40P
;DPY CHARACTER LINE BUFFER

LINBUF=.
.=.+LBL
.EVEN

;DPY PUSH DOWN LIST

DPYPDP:	0	;PUSH DOWN POINTER
DPYPDC:	0	;PUSH DOWN COUNTER
DPYPDB=.
.=.+DPYPDL
.ENDC ;GT40P

;PATCH AREA

PAT:PATCH:
.=.+PATL

.IFNZ GT40P
;***********INTERUPT/MAIN PROG LEVEL COMMUNICATION RING********

;ALL OF THIS HACKERY IS TO PUT GOODIES INTO DISPLAY LIST WHILE
;DISPLAY IS STOPPED AT INTERUPT LEVEL.  BUFFERS ARE SET UP AT GO3.
;EACH BUFFER IS 6 BYTES AND IS OF THE FOLLOWING FORM

;	NEXT ON RING
;	ADDRESS TO WRITE FOLLOWING WORD
;	CONTENTS

;GETDPY AND PUTDPY POINT AT ADDRESS WORD OF BUFFER AND ARE FOR
;INTERUPT AND MAIN PROGRAM LEVELS RESPECTIVELY

PUTDPY:	0
GETDPY:	0
MIBUF:	.=.+<MIBFRS*6>

;FAKE BLOCK
FAKEBL:	0
	FS+2
	FAKEBL+2
	-1

;FREE STORAGE
FS=.		;FREE STORAGE STARTS HERE
REPORT <DL11 BUFSIZ=>,\BUFSIZ
REPORT <FS=>,\FS
REPORT <FS SIZE=>,\<HMEML-FS>
.IFF
REPORT <FIRST FREE LOC=>,\.
REPORT <LEFT BEFORE MEM TOP=>,\HMEML-.
.ENDC ;GT40P

.END GO
