TITLE TREES -- P. D. LEBLING (PDL)

A=1
B=2
C=3
D=4
E=5
F=6
G=7

U=16   ;user ptr into system
P=17

; mode bits

TYOC==2

PDL:	BLOCK 40
SNM:	0
MASK:	-1
COMMND:	BLOCK 10.

START:	MOVE	P,[-40,,PDL]
	.OPEN	TYOC,[SIXBIT /  !TTYXXXXXXYYYYYY/]
	.VALUE

	.BREAK	12,[5,,COMMND]
	SKIPN	COMMND			; none there?
	 JRST	DEFSNM
;parse jcl
	MOVE	A,[440700,,COMMND]
	MOVE	B,[440600,,SNM]
	MOVE	C,[440600,,MASK]
	SETOM	MASK
	SETZM	SNM
	MOVEI	D,0
LOOP:	ILDB	0,A
     	CAILE	0,40
     	 CAIL	D,6
     	  JRST	DONE
	ADDI	D,1
	CAIE	0,"*
	 JRST	NOTSTR
	MOVEI	0,0
	IDPB	0,B
	IDPB	0,C
	JRST	LOOP
NOTSTR:	IBP	C
	SUBI	0,40
	CAIL	0,100
	 JRST	.-2
	IDPB	0,B
	JRST	LOOP
DONE:	CAIE	D,1
	 JRST	SYSTEM
	SKIPG	MASK		;means was a *
	 JRST	SYSTEM
	SETZM	SNM
	SETZM	MASK
	JRST	SYSTEM

DEFSNM:	.SUSET	[.RXUNA,,SNM]	;default is user himself

SYSTEM:	PUSHJ	P,INIT		;init symbols and map system
	MOVE	U,L
	LSH	U,1		;skip sys and core jobs
SYSLUP:	SKIPE	A,@XUNAME
	 SKIPL	@SUPPRO		;skip if top level job
	  JRST	SYSNXT		;not top-level job
	SKIPN	@UNAME
	 JRST	SYSNXT		;job gone
	AND	A,MASK
	CAME	A,SNM		;matches mask?
	 JRST	SYSNXT		;no

TTYL:	MOVE	B,@JNAME	;job name
	SKIPL	@APRC
	 CAME	B,[SIXBIT /TELSER/] ;telser is dull unless disowned
	  SKIPA
	   JRST	SYSNXT
     	MOVE B,@UTMPTR		;resource word
	SUB B,USRRCE
	CAML B,NCT		;skip if console
	 JRST	[SUB B,NCT
		 SUBI B,2
		 JRST .+1]	;otherwise sys or disowned
	CAMN	B,[-2]
	 OASC	[ASCIZ /    /]	;disowned tree
	CAMN	B,[-1]
	 OASC	[ASCIZ /SYS /]	;system tree
	JUMPL	B,UJ
UTTY:	OASCI	"T		;tty num
	CAIGE	B,10
	 OASCI	"0
	OOCT	B
	OASCI	" 

UJ:   	OSIXS	@UNAME		;uname of top job
	OASC	[ASCIZ / /]
	OSIXS	@JNAME		;jname of top job
	SKIPE	@USTP
	 SKIPL	@APRC		;stopped and disowned?
	  SKIPA
	   JRST	[OASC	[ASCIZ /  (Detached)/]
		 JRST UCR]
	SKIPGE	@APRC		;just disowned?
	 OASC	[ASCIZ /  (Disowned)/]
UCR:	OASCR	[0]

SYSNXT:	ADD	U,L		;next job
	CAMGE	U,@USRHI
	 JRST	SYSLUP

QUIT:	.BREAK	16,140000	;exit


; ================================================================
;		uuo handler (typeout uuos)
; ================================================================

ZZZ==.
        LOC 40
        0
        JSR UUOH
        LOC ZZZ
UUOCT==0
UUOTAB:	JRST ILUUO
	IRPS X,,[DEC BPTR OCT CTLP ASCC SIX ASC ASCI ASCR SIXS HPOS ALIGN SIGN]
	UUOCT==UUOCT+1
	O!X=UUOCT_27.
	JRST UO!X
	TERMIN

IFG UUOCT-37, PRINTC /---TOO MANY UUO'S---/

UUOMAX==.-UUOTAB


UUOD:	0		; contents of UUO eff addr.
UUOE:	0		; UUO effad.

UUOH:	0
	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	MOVEI	@40			; get eff addr. of uuo
	MOVEM	UUOE
	MOVE	@0
	MOVEM	UUOD			; contents of eff adr
	MOVE	B,UUOE			; eff adr
	LDB	A,[270400,,40]		; get uuo ac,
	LDB	C,[330600,,40]		; op code
	CAIL	C,UUOMAX
	MOVEI	C,0			; grt=>illegal
	JRST	@UUOTAB(C)		; go to proper rout

UUORET:	POP	P,D
	POP	P,C
	POP	P,B
	POP	P,A			; restore ac's
	JRST	2,@UUOH

ILUUO:	.VALUE	[ASCIZ /:ILLEGAL UUO/]

UOBPTR:	MOVEI	C,0
	MOVE	B,UUOD
	JRST	UOASC1

UOASCR:	SKIPA	C,[^M]			; cr for end of type
UOASC:	MOVEI	C,0			; no cr
	HRLI	B,440700		; make ascii pointer
UOASC1:	ILDB	A,B			; get char
	JUMPE	A,.+3			; finish?
	PUSHJ	P,IOTA
	JRST	.-3			; and get another
	SKIPE	A,C			; get saved cr?
	PUSHJ	P,IOTA
	JRST	UUORET

UOASCC:	HRLI	B,440700		; make ascii pointer
UOAS1C:	ILDB	A,B			; get char
	CAIN	A,^C
	JRST	UUORET
	PUSHJ	P,IOTA
	JRST	UOAS1C			; and get another

UOCTLP:	MOVEI	A,^P
	PUSHJ	P,IOTA1

UOASCI:	MOVE	A,B			; prt ascii immediate
	PUSHJ	P,IOTA
	JRST	UUORET

UOSIX:	MOVE	B,UUOD
USXOOP:	JUMPE	B,UUORET
	LDB	A,[360600,,B]
	ADDI	A,40
	PUSHJ	P,IOTA
	LSH	B,6
	JRST	USXOOP

UOSIXS:	MOVE	A,[440600,,UUOD]
USLOOP:	ILDB	C,A
	ADDI	C,40
	PUSHJ	P,IOTC
	TLNE	A,770000
	JRST	USLOOP
	JRST	UUORET

UOHPOS:	SUB B,HPOS
	SKIPG B
	MOVEI B,1	; always at least one space
UOHPO1:	MOVEI A,40
	PUSHJ P,IOTA
	SOJG B,UOHPO1
	JRST UUORET

POWER:	0 ? 1 ? 10. ? 100. ? 1000. ? 10000. ? 100000. ? 1000000.

UOSIGN:	MOVM D,UUOD
	ANDI A,7
	MOVE A,POWER-1(A)
	MOVEI C,40
UOSIG1:	CAMLE A,D
	PUSHJ P,IOTC
	IDIVI A,10.
	CAIE A,1
	 JRST UOSIG1
	MOVEI A,"+
	SKIPGE UUOD
	MOVEI A,"-
	SKIPN UUOD
	MOVEI A," 
	PUSHJ P,IOTA
	SETZ A,
	JRST UODEC

UOALIG:	MOVE D,UUOD
	ANDI A,7
	MOVE A,POWER(A)
	MOVEI C,40
UOALI1:	CAMLE A,D
	PUSHJ P,IOTC
	IDIVI A,10.
	CAIE A,1
	 JRST UOALI1
	SETZ A,

UODEC:	SKIPA	C,[10.]			; get base for decimal
UOOCT:	MOVEI	C,8.			; octal base
	MOVE	B,UUOD			; get actual word to prt
	JRST	.+3			; join code
UODECI:	SKIPA	C,[10.]			; decimal
UOOCTI:	MOVEI	C,8.
	MOVEM	C,BASE'
	SKIPN	A
	HRREI	A,-1			; a=digit count
	PUSHJ	P,UONUM			; print numbr
	JRST	UUORET

UONUM:	IDIV	B,BASE
	HRLM	C,(P)			; save digit
	SOJE	A,UONUM1		; done if 0
	SKIPG	A			; + => more
	SKIPE	B			; - => b=0 => done
	PUSHJ	P,UONUM			; else more
UONUM1:	HLRZ	C,(P)			; retreive digits
	ADDI	C,"0			; make to ascii
	CAILE	C,"9			; is it good dig
	ADDI	C,"A-"9-1		; make hex digit
	PUSHJ	P,IOTC
	POPJ	P,			; ret

IOTC:	PUSH	P,A
	MOVE	A,C
	PUSHJ	P,IOTA
	POP	P,A
	POPJ	P,

HPOS:	0	; line pos

IOTA:	CAIN	A,^P
	JRST	[.IOT TYOC,["^]
		 ADDI A,100
		 JRST IOTA1]
	CAIN	A,^J
	POPJ	P,
IOTA1:	.IOT	TYOC,A
	CAIE	A,^M
	 JRST	IOTTAB
	SKIPE	SCRFLG'
	 .IOT TYOC,[^J]
	SETZM	HPOS
	POPJ	P,
; update line pos
IOTTAB:	CAIN	A,^I
	 JRST	[MOVE A,HPOS
		 ADDI A,10
		 ANDI A,7770
		 MOVEM A,HPOS
		 POPJ P,]
	AOS	HPOS
	POPJ	P,

INIT:	MOVE	A,[-200,,200]
	MOVEI	B,0
	.CALL	[SETZ
		 SIXBIT	/CORBLK/
		 MOVEI	%CBRED
		 MOVEI	%JSELF
		 A
		 MOVEI	%JSABS
		 SETZ	B]
	 .LOSE	1000

	MOVE	A,USRVAR
USRLOP:	MOVE	B,(A)
	.EVAL	B,
	 .VALUE
	ADDI	B,400000
	HRLI	B,U
	MOVEM	B,1(A)
	ADD	A,[2,,2]
	JUMPL	A,USRLOP
	MOVE	A,SYSLOC
SYSLOP:	MOVE	B,(A)
	.EVAL	B,
	 .VALUE
	ADDI	B,400000
	MOVEM	B,1(A)
	ADD	A,[2,,2]
	JUMPL	A,SYSLOP
	MOVE	A,SYSCON
SYSCLP:	MOVE	B,(A)
	.EVAL	B,
	 .VALUE
	MOVEM	B,1(A)
	ADD	A,[2,,2]
	JUMPL	A,SYSCLP
	POPJ	P,

; TABLES FOR EVAL

; GROUP 1:  VALUE SAVED HAS U IN LH, 400000 ADDED.
USRTAB:	SQUOZE	0,APRC
APRC:	0
	SQUOZE	0,USTP
USTP:	0
	SQUOZE	0,UNAME
UNAME:	0
	SQUOZE	0,XUNAME
XUNAME:	0
	SQUOZE	0,XJNAME
XJNAME:	0
	SQUOZE	0,JNAME
JNAME:	0
	SQUOZE	0,SUPPRO
SUPPRO:	0					; SUPERIOR PROCESS
	SQUOZE	0,UTMPTR
UTMPTR:	0
USRVAR:	USRTAB-.,,USRTAB

; GROUP 2: VALUE SAVED HAS 400000 ADDED.  REFERS TO ABSOLUTE LOCATIONS IN SYSTEM
SYSTAB:	SQUOZE	0,USRHI
USRHI:	0
SYSLOC:	SYSTAB-.,,SYSTAB

; GROUP 3:  LOCATION-INDEPENDENT VALUES
SYSCTB:	SQUOZE	0,L
L:	0
	SQUOZE	0,NCT
NCT:	0
	SQUOZE	0,USRRCE
USRRCE:	0
SYSCON:	SYSCTB-.,,SYSCTB

	END	START
