
;COMPARISON OF DSK:SYSEN1;@ 695 AND DSK:GUEST4;SKEF NEWAT
;OPTIONS ARE    /E /L /W /3

**** FILE DSK:SYSEN1;@ 695, 2-5 (1616) AFTER P=:
1)	;;; GLS		Guy L. Steele Jr.   (GLS@MIT-MC)
1)	;;; RMS		Richard M. Stallman (RMS@MIT-AI)
1)	;;; RHG/RG02	Richard H. Gumpertz (Gumpertz@CMU-10A)
1)	;;; MRC		Mark Crispin        (MRC@SU-AI)
1)	;;; MOON	David A. Moon       (MOON@MIT-MC)
1)	;;; EAK		Earl A. Killian     (EAK@MIT-MC)
1)	;;; MT		Michael Travers	    (MT@MIT-XX)
1)	;;; JMN		Joseph M. Newcomer  (Newcomer@CMU-10A)
1)	;;; KLH		Ken Harrenstien	    (KLH@MIT-AI/SRI-NIC)
1)	;;; THE AUTHORITATIVE SOURCE FOR @ IS [MIT-AI]SYSEN1;@ >
1)	;; WARNING: RMS, MRC, AND GLS DON'T TAKE THIS BUREAUCRACY VERY SERIOUSLY.
**** FILE DSK:GUEST4;SKEF NEWAT, 2-5 (1616) AFTER P=:
2)	;;; GLS		Guy L. Steele Jr.	(GLS@MIT-MC)
2)	;;; RMS		Richard M. Stallman	(RMS@MIT-AI)
2)	;;; RHG/RG02	Richard H. Gumpertz	(Gumpertz@CMU-10A)
2)	;;; MRC		Mark Crispin		(MRC@SU-AI)
2)	;;; MOON	David A. Moon		(MOON@MIT-MC)
2)	;;; EAK		Earl A. Killian		(EAK@MIT-MC)
2)	;;; MT		Michael Travers		(MT@MIT-XX)
2)	;;; JMN		Joseph M. Newcomer	(Newcomer@CMU-10A)
2)	;;; KLH		Ken Harrenstien		(KLH@MIT-AI/SRI-NIC)
2)	;;; LNZ		Leonard N. Zubkoff	(Zubkoff@CMU-20C)
2)	;;; SKEF	J. Skeffington Wholey	(Wholey@CMU-20C)
2)	;;; THE AUTHORITATIVE SOURCE FOR @ IS [MIT-AI]QUUX;@ >
2)	;; WARNING: RMS, MRC, AND GLS DON'T TAKE THIS BUREAUCRACY VERY SERIOUSLY.
***************

**** FILE DSK:SYSEN1;@ 695, 2-476 (27936) AFTER P=:
1)	;;; 16-Jan-81	KLH	Added /D[Canon] as an ersatz XGP which accepts
1)	;;;			ITS XGP format files, but has different resolution.
1)	;;;			Fixed bug at FPSFN3, the minus-flag in B wasn't
1)	;;;			being saved during font filename parsing.
1)	;;;			Noti¸yr √ 10X monitor bug: GTJFN of a F˘ÃPaŸl by itself
1)	;;;			will cause "No such version" error on 10X, even tho
1)	;;;			the GJ%OFG bit is set!!!  Not sure if buggy on T20 too.
1)	;;;			Apparently only sure way to win is to parse the string
1)	;;;			completely like MIDAS does, rather than trying to
1)	;;;			get GTJFN to do the work.
1)	;;;			Fixe¸à#PâFN3 to only zap last 3 chars of file extension
1)	;;;			if on DOS system, rather than NOITS.
1)	;;;			Fixed MCRFN4 to account for overlarge page #'s (was
1)	;;;			running CREF lines off the right margin).  In general,
1)	;;;			any text of more than 10,000 lines per page is going
1)	;;;			to lose grossly... in case anyone didn't know this.
1)	;;;			(the doc doesn't mention this sort of thing)
1)	;;;  1-Mar-82	JMN	Added device Florida (Florida Data Systems OSP-130)
**** FILE DSK:GUEST4;SKEF NEWAT, 2-478 (28007) AFTER P=:
2)	;;;  1-Mar-82	JMN	Added device Florida (Florida Data Systems OSP-130)
***************

**** FILE DSK:SYSEN1;@ 695, 2-499 (29260) AFTER P=:
1)	;;; 29-Jun-82	KLH	Took out the ADD C,FNTBAS at FNTCPP-3 (calculating
1)	;;;			default # lines on page) because it seems to be
1)	;;;			completely wrong-headed; it was screwing up
1)	;;;			our Canon spooler (which is diligent about going to
1)	;;;		Ò;≤¯È page if a line runs over BOTM¯4îÆA If someone
1)	;;;			can explain why it works for XGP, and prove it isn't
1)	;;;			an XGP bug, please do so.
1)	;;;			FINALLY!!!!! R¸º6a«ed losing TNX GTJFN filename parser
1)	;;;			with by-hand parser from MIDAS source.  Incomplete
1)	;;;			filenames now default sensibly, tho still have sixbit
1)	;;;			restricti˝˚π†ﬂn FN1 and EXT.
1)	;;; 25-Sep-82	KLH	Increased DIRDLN to 4000 (so can list ITS)
1)	SUBTTL	SYSTEM-DEPENDENT DEFINITIONS
**** FILE DSK:GUEST4;SKEF NEWAT, 2-484 (28366) AFTER P=:
2)	;;; 17-Mar-82	JMN	Removed device Florida since we didn't get it after all
2)	;;;		Ò0rdÀ¸à2eÌice Sanders
2)	;;; 17-Mar-82	JMN	Experienced  numerous problems with copyrights coming
2)	;;;			out on the next page.  Looking at the code after 
2)	;;;			OUTPP2, I found that the IDIVI and test for
2)	;;;			zero remainder make sense only if the increment is
2)	;;;			1!  Stepping by more than 1, as is done a few
2)	;;;			instructions before that, will cause the
2)	;;;			test to fail.
2)	;;; 28-May-82	LNZ	Change Sanders support to handle margins properly; that
2)	;;;			is, send VMON rather than VMOFF.
2)	;;;  7-Jun-82	JMN	Fixed GETHST code so that if it fails (such as on a
2)	;;;			non-TOPS-20AN system) AT keeps running
2)	;;; 21-Aug-82	SKEF	Added "new" LREC format for TNX sites.  Groups start
2)	;;;			with an ascii string which is the name of the file,
2)	;;;			followed by a zero WORD, followed by data.  In @ file
2)	;;;			blocks, SNAME is a byte pointer to the file name.
2)	;;;			NAMBLK is now an area in which name strings are consed.
2)	SUBTTL	SYSTEM-DEPENDENT DEFINITIONS
***************

**** FILE DSK:SYSEN1;@ 695, 3-85 (32031) AFTER P=:
1)		; True site-dependent (as opposed to OS-dependent) stuff
1)	IFE <.SITE 0>-<SIXBIT /SRI-NI/>,[
1)		XGPFMT==:ITSFLG		; ITS type XGP cmds, but require /D[C]
1)					; to select Canon.  Later fix up?
1)		FNTDSN==:144	; <FONTS> directory on SRI-NIC
1)	] ;SRI-NIC
1)	IFNDEF XGPFMT,[			;WHAT SORT OF XGP COMMANDS DO WE WANT TO OUTPUT?
**** FILE DSK:GUEST4;SKEF NEWAT, 4-2 (31482) AFTER P=:
2)	IFNDEF XGPFMT,[			;WHAT SORT OF XGP COMMANDS DO WE WANT TO OUTPUT?
***************

**** FILE DSK:SYSEN1;@ 695, 4-13 (32674) AFTER P=:
1)	IFNDEF FLAFLG,[		; Support Florida Data Systems OSP/130
1)		FLAFLG==:1	; yes
1)		IFNDEF FLAFLG,  FLAFLG==:0
1)	];IFNDEF FLAFLG
1)		;NONZERO TO ALLOW PRESS FILE OUTPUT.
**** FILE DSK:GUEST4;SKEF NEWAT, 4-12 (31871) AFTER P=:
2)	ifNDEF VFXFLG,[		; Support Sanders VariFlex S700
2)		VFXFLG==:1	; yes
2)		IFNDEF VFXFLG,  VFXFLG==:0
2)	];IFNDEF VFXFLG
2)		;NONZERO TO ALLOW PRESS FILE OUTPUT.
***************

**** FILE DSK:SYSEN1;@ 695, 4-48 (33345) AFTER P=:
1)		DEFINE FLORIDA
1)	˘1ß çLAFLG!TERMIN
1)		DEFINE NOFLORIDA
1)	IFE FLAFLG!TERMIN
1)		DEFINE XGPRES
**** FILE DSK:GUEST4;SKEF NEWAT, 4-47 (32535) AFTER P=:
2)		DEFINE VARIFLEX
2)	IFN VFXFLG!TERMIN
2)		DEFINE NOVARIFLEX
2)	IFE VFXFLG!TERMIN
2)	Ò1"∆ìNE XGPRES
***************

**** FILE DSK:SYSEN1;@ 695, 7-44 (40070) AFTER OLOOP:
1)	IFNDEF DIRDLN,DIRDLN==:4000	;DEFAULT DIRBUF SIZE IN 18-BIT BYTES
1)	CMU,IFNDEF DFMARG,DFMARG==:394.	;AT CMU, USE 1CM MARGINS
**** FILE DSK:GUEST4;SKEF NEWAT, 7-44 (39264) AFTER OLOOP:
2)	IFNDEF DIRDLN,DIRDLN==:2000	;DEFAULT DIRBUF SIZE IN 18-BIT BYTES
2)	CMU,IFNDEF DFMARG,DFMARG==:394.	;AT CMU, USE 1CM MARGINS
***************

**** FILE DSK:SYSEN1;@ 695, 10-4 (46919) AFTER C.CREF==:
1)	;THE FIRST WORD OF AN LREC FILE SHOULD NOW BE SIXBIT/LREC/+1.
1)	;ATTEMPTS TO USE FILES WHICH DO NOT SATISFY THAT CRITERION
1)	;CAUSE ERROR MESSAGES.
1)	;THE REST OF FILE IS COMPOSED OF ENTRIES, ONE AFTER THE OTHER.
**** FILE DSK:GUEST4;SKEF NEWAT, 10-4 (46113) AFTER C.CREF==:
2)	;THE FIRST WORD OF AN LREC FILE SHOULD NOW BE SIXBIT/LREC/+1 FOR NOTNX SYSTEMS
2)	;AND SIXBIT/LREC/+2 FOR TNX SYSTEMS.  THE LREC FORMATS DIFFER IN THE WAY A
2)	;FILENAME IS STORED.  THE FORMAT FOR NOTNX SYSTEMS WILL BE CALLED THE "OLD"
2)	;FORMAT, AND THE TNX FORMAT WILL BE CALLED THE "NEW" FORMAT.
2)	;ATTEMPTS TO USE FILES WHICH DO NOT SATISFY THE PROPER CRITERION (WITH RESPECT
2)	;TO TNX-ISHNESS) CAUSE ERROR MESSAGES.
2)	;THE REST OF FILE IS COMPOSED OF ENTRIES, ONE AFTER THE OTHER.
***************

**** FILE DSK:SYSEN1;@ 695, 10-11 (47310) AFTER C.CREF==:
1)	;AN ENTRY BEGINS WITH 4 WORDS GIVING THE SNAME, DEV, FN1 AND FN2 OF THE FILE.
1)	;THEN COME 0 OR MORE SUBENTRIES, FOLLOWED BY A -1 SIGNIFYING THE END
**** FILE DSK:GUEST4;SKEF NEWAT, 10-14 (46772) AFTER C.CREF==:
2)	;AN OLD FORMAT ENTRY BEGINS WITH 4 WORDS GIVING THE SNAME, DEV, FN1 AND FN2 OF
2)	;THE FILE.  A NEW FORMAT ENTRY BEGINS WITH AN ASCIZ STRING GIVING THE FILENAME
2)	;FOLLOWED BY A 0 WORD.
2)	;THEN COME 0 OR MORE SUBENTRIES, FOLLOWED BY A -1 SIGNIFYING THE END
***************

**** FILE DSK:SYSEN1;@ 695, 13-14 (52678) AFTER DEVPDO==:
1)	DEVANA==:6	; Anadex something
1)	DEVCGP==:7	; Canon LBP-10 hacking XGP-type input
1)	DEVFLA==:10	; Florida something
1)	DEVMAX==:1ˆ"]±A+ <LARGEST LEGAL DEVICE VALUE>
1)	XGPP:Ò,ªa => DEVICE DOESN'T CONTAIN XGP, -1 => DEVIXG, +1 => DEVCXG
1)			;-2 => DEVCGP (ersatz ITS XGP)
1)	¯s‚T≥P:	DFLANG	;TYPE OF INPUT EXPECTED (WHAT LANGUAGE IT'S IN)
**** FILE DSK:GUEST4;SKEF NEWAT, 13-14 (52245) AFTER DEVPDO==:
2)	DEVMAX==:10	;1 + <LARGEST LEGAL DEVICE VALUE>
2)	XGPP:	0	;0 => DEVICE DOESN'T CONTAIN XGP, -1 => DEVIXG, +1 => DEVCXG
2)	CODTYP:	DFLANG	;TYPE OF INPUT EXPECTED (WHAT LANGUAGE IT'S IN)
***************

**** FILE DSK:SYSEN1;@ 695, 15-56 (61203) AFTER FWIDFL:
1)	FWIDFL:	XWD 0,0
1)		SIXBIT /FON/		;on FON:
1)		SIXBIT /FONTS/
1)		SIXB˘5/ØID/
1)	];CMU20
**** FILE DSK:GUEST4;SKEF NEWAT, 15-56 (60622) AFTER FWIDFL:
2)	FWIDFL:	440700,,[asciz /FON:Fonts.Wid/]
2)	];CMU20
***************

**** FILE DSK:SYSEN1;@ 695, 15-63 (61337) AFTER FWIDFL:
1)	FWIDFL:	0
1)		SIXBIT /SYS/
1)		SIXBIT /FONTS/
1)		SIXBIT /WID/
1)	];NOCMU20
**** FILE DSK:GUEST4;SKEF NEWAT, 15-60 (60723) AFTER FWIDFL:
2)	¯’‰ƒçL:	440700,,[asciz /P˙nûFﬂ˝›9æçonts.Wid/]
2)	˚ÆÁOáMU20
***************

**** FILE DSK:SYSEN1;@ 695, 19-6 (69932) AFTER F.==:
1)	F.ISNM==:0		;INPUT SNAME
1)	F.IDEV==:1		;INPUT DEVICE
**** FILE DSK:GUEST4;SKEF NEWAT, 19-6 (69307) AFTER ¯ÀûΩu
2)	¯À§”ùM==:0		;INPUT SNAME, or byte pointer to name string
2)	F.IDEV==:1		;INPUT DEVICE
***************

**** FILE DSK:SYSEN1;@ 695, 19-55 (72246) AFTER MULTI:
1)	NAMSIZ==:40.		; big buffer for accumulating filenames
1)	NAMBLK:	BLOCK NAMSIZ	;  here it is
1)	JFNBLK:	BLOCK	17	; for longform JFN
**** FILE DSK:GUEST4;SKEF NEWAT, 19-55 (71653) AFTER MULTI:
2)	NAMSIZ==:200.		; big buffer for accumulating filenames
2)	NAMBLK:	BLOCK NAMSIZ	;  here it is
2)	NAMEND::		;  and here it isn't
2)	NAMNXT:	NAMBLK		; pointer to next free word in it
2)	JFNBLK:	BLOCK	17	; for longform JFN
***************

**** FILE DSK:SYSEN1;@ 695, 22-14 (78304) AFTER CRDFN2:
1)	IPTFN2:	OFFSET -.
**** FILE DSK:GUEST4;SKEF NEWAT, 22-14 (77795) AFTER CRDFN2:
2)	NOTNX,[
2)	IPTFN2:	OFFSET -.
***************

**** FILE DSK:SYSEN1;@ 695, 22-26 (78555) AFTER T10,CODTXT
1)	TNX,CODTXT::0
1)	CODMDL:: SIXBIT/MDL/
**** FILE DSK:GUEST4;SKEF NEWAT, 22-27 (78055) AFTER T10,CODTXT
2)	CODMDL:: SIXBIT/MDL/
***************

**** FILE DSK:SYSEN1;@ 695, 22-36 (78734) AFTER T10,FNDFN2
1)	TNX,FNDFN2:	SIXBIT/KST/
1)	CMU,FNDFN2:	SIXBIT/KST/
1)	SAI,FNDFN2:	SIXBIT/FNT/
1)	˚ÆÁOìTS
1)	OPTFN2:	OFFSET -.
**** FILE DSK:GUEST4;SKEF NEWAT, 22-36 (78219) AFTER T10,FNDFN2
2)	CMU,FNDFN2:	SIXBIT/KST/
2)	SAI,FNDFN2:	SIXBIT/FNT/
2)	];NOTNX
2)	TNX,[
2)	IPTFN2:	OFFSET -.
2)	CODMID:: 440700,,[ASCIZ /MID/]
2)	CODRND:: 440700,,[0]
2)	CODFAI:: 440700,,[ASCIZ /FAI/]
2)	CODP11:: 440700,,[ASCIZ /M11/]
2)	CODLSP:: 440700,,[ASCIZ /LSP/]
2)	CODM10:: 440700,,[ASCIZ /MAC/]
2)	CODUCO:: 440700,,[0]
2)	CODTXT:: 440700,,[0]
2)	CODMDL:: 440700,,[ASCIZ /MDL/]
2)	CODH16:: 440700,,[ASCIZ /H16/]
2)	CODMAX:: OFFSET 0
2)	LRCFN2:	440700,,[ASCIZ /LREC/]
2)	ALRFN2:	440700,,[ASCIZ /LRC/]
2)	˘Û)Fù2:	440700,,[ASCIZ /OLR/]
2)	CRDFN2:	440700,,[ASCIZ /ATC/]
2)	TNX,FNDFN2:	440700,,[ASCIZ /KST/]
2)	];TNX
2)	];NOITS
2)	NOTNX,[
2)	OPTFN2:	OFFSET -.
***************

**** FILE DSK:SYSEN1;@ 695, 22-56 (79111) AFTER OPTFN2:
1)	    DEVCGP::	SIXBIT/CGP/
1)	    DEVFLA::	SIXBIT/FLA/
1)	    DEVMAX::OFFSET 0
1)	SUBTTL LINE AND PAGE LENGTH BY DEVICE
**** FILE DSK:GUEST4;SKEF NEWAT, 22-80 (79099) AFTER OPTFN2:
2)	    DEVVFX::    SIXBIT/VFX/
2)	    DEVMAX::OFFSET 0
2)	];NOTNX
2)	TNX,[
2)	OPTFN2:	OFFSET -.
2)	DEVLPT:: 440700,,[ASCIZ/LST/]
2)	¯ëkI±¯Óù i40700,,[ASCIZ/XGP/]
2)	DEVCXG:: 440700,,[ASCIZ/XGO/]
2)	DEVGLD:: 440700,,[ASCIZ/GLD/]
2)	DEVLDO:: 440700,,[ASCIZ/PRESS/]
2)	DEVPDO:: 440700,,[ASCIZ/PRESS/]
2)	DEVANA:: 440700,,[ASCIZ/ANA/]
2)	DEVVFX:: 440700,,[ASCIZ/VFX/]
2)	DEVMAX::OFFSET 0
2)	];TNX
2)	SUBTTL LINE AND PAGE LENGTH BY DEVICE
***************

**** FILE DSK:SYSEN1;@ 695, 23-14 (79460) AFTER DEVANA:
1)	DEVCGP::	119.
1)	DEVFLA::	132.
1)	DEVMAX::OFFSET 0
**** FILE DSK:GUEST4;SKEF NEWAT, 23-14 (79739) AFTER DEVANA:
2)	DEVVFX::	132.
2)	DEVMAX::OFFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 23-28 (79753) AFTER DEVANA:
1)	DEVCGP::	85.
1)	DEVFLA::	60.
1)	DEVMAX::OFFSET 0
**** FILE DSK:GUEST4;SKEF NEWAT, 23-27 (80017) AFTER DEVANA:
2)	DEVVFX::	60.
2)	DEVMAX::OFFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 23-42 (80043) AFTER DEVANA:
1)	DEVCGP::	240.
1)	DEVFLA::	0
1)	DEVMAX::OFFSET 0
**** FILE DSK:GUEST4;SKEF NEWAT, 23-40 (80293) AFTER DEVANA:
2)	DEVVFX::	960.
2)	DEVMA˚ùOçFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 23-56 (80346) AFTER DEVANA:
1)	DEVCGP::	240.
1)	DEVFLA::	0
1)	DEVMAX::OFFSET 0
**** FILE DSK:GUEST4;SKEF NEWAT, 23-53 (80584) AFTER DEVANA:
2)	DEVVFX::	288.
2)	DEVMAX::OFFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 23-70 (80642) AFTER DEVANA:
1)	DEVCGP::	1980.	; Theoretically 2040 but right margin has 60-pixel bug
1)	DEVFLA::	0
1)	DEVMAX::OFFSET 0
**** FILE DSK:GUEST4;SKEF NEWAT, 23-66 (80868) AFTER DEVANA:
2)	DEVVFX::	8160.
2)	DEVMAX::OFFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 23-84 (81015) AFTER DEVANA:
1)	DEVCGP::	240.*11.	 ; Should be able to hack full page.
1)	¯ëkFô¯.ù	a
1)	¯ëkMÉX::OF¯‘‚‘A0
**** FILE DSK:GUEST4;SKEF NEWAT, 23-79 (81174) AFTER DEVANA:
2)	DEVVFX::	3168.
2)	DEVMAX::OFFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 23-100 (81416) AFTER DEVANA:
1)	DEVCGP::	0,,-2
1)	DEVFLA::	0
1)	DEVMAX::OFFSET 0
**** FILE DSK:GUEST4;SKEF NEWAT, 23-94 (81523) AFTER DEVANA:
2)	DEVVFX::	0
2)	DEVMAX::OFFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 26-20 (84247) AFTER FLSNLR:
1)	FLSFNT::[ASCIZ /Font file not in known format (KST or FNT)/]
**** FILE DSK:GUEST4;SKEF NEWAT, 26-20 (84338) AFTER FLSNLR:
2)	TNX,FLSNNL::[ASCIZ /Old format LREC file.  Run ZAPLRC.EXE to convert this file to the new format./]
2)	FLSFN˙éù[ÉSCIZ ıÒ∑ÓÈ file not in known format (KSTÙ˘ ç˘’Øª
***************

**** FILE DSK:SYSEN1;@ 695, 37-19 (105886) AFTER SYSINI:
1)	TNX,.ERR This 1-word lossage should be fixed.
1)	T20,[ 
**** FILE DSK:GUEST4;SKEF NEWAT, 37-19 (106078) AFTER SYSINI:
2)	T20,[ 
***************

**** FILE DSK:SYSEN1;@ 695, 37-28 (106160) AFTER SYSINI:
1)		 jrst	MFail		; couldn't
1)		setzm	machine		; indicate ASCII value is valid
**** FILE DSK:GUEST4;SKEF NEWAT, 37-27 (106305) AFTER SYSINI:
2)		 erjmp	MFail		; couldn't
2)		setzm	machine		; indicate ASCII value is valid
***************

**** FILE DSK:SYSEN1;@ 695, 37-106 (107924) AFTER GOSCEL:
1)		CAIE A,"a
1)		 CAIN A,"A		; If not "A" for "ATSIGN"
1)		  JRST RSCAN1
1)	¯ÛÈ√ã˘éÑ√É˘3êAY˚“Ñâw assume line is not ¸(3Ôﬂd cmd string.
1)		 JRST POPJ1		; (this is pretty dumb, though)
1)		PBIN
1)		JRST GOSCEL
1)	˙T·¡ùˆ.Ñ–ÖIN			˜h)Â√rch for space
**** FILE DSK:GUEST4;SKEF NEWAT, 37-105 (108070) AFTER GOSCEL:
2)	;	CAIE A,"a
2)	;	 CAIN A,"A		; If not "A" for "ATSIGN"
2)	;	  JRST RSCAN1
2)	;GOSCEL:	CAIN A,^J		; assume line is not a good cmd string.
2)	;	 JRST POPJ1		; (this is pretty dumb, though)
2)	;	PBIN
2)	;	JRST GOSCEL
2)	RSCAN1:	PBIN			; Search for space
***************

**** FILE DSK:SYSEN1;@ 695, 43-7 (117783) AFTER FPFILE:
1)		MOVE	CP,[440700,,NAMBLK]
1)		SETZ	CC,
**** FILE DSK:GUEST4;SKEF NEWAT, 43-7 (117936) AFTER FPFILE:
2)		move	cp, namnxt		; get addr of next file name word
2)		hrli	cp, 440700		; make it a 7 bit byte pointer
2)	Ò;wˆÀm	cp,ÙLSÒ.–sÈore bˇ=2†·˝˙wtÀr in file block
2)		SETZ	CC,
***************

**** FILE DSK:SYSEN1;@ 695, 43-35 (118577) AFTER FPLOO2:
1)		JRST	FPLOOP			; get more
**** FILE DSK:GUEST4;SKEF NEWAT, 43-37 (118858) AFTER FPLOO2:
2)		hrrz	a, cp			; get address
2)		cail	a, namend		; skip if we haven't destroyed things
2)		 jrs˛ÇPf›˛y˜ÓÒ"]†À˝úÚ†Ôe ranÙ˙ÙA˝˘êf”lenam¸®9√ce
2)		JRST	FPLOOP			; get more
***************

**** FILE DSK:SYSEN1;@ 695, 43-40 (118702) AFTER FPSPC:
1)		MOVE A,[440700,,NAMBLK]
1)		PUSHJ P,TNXRFD
1)	IFN 0,[ 
1)	;;; Now, s¸Ωu· the longform GTJFN arguments that are n˝˝aŸready
**** FILE DSK:GUEST4;SKEF NEWAT, 43-45 (119122) AFTER FPSPC:
2)	;;; Now, set up the longform GTJFN arguments that are not already
***************

**** FILE DSK:SYSEN1;@ 695, 43-63 (119336) AFTER FPSPC:
1)		HRROI	B,NAMBLK
1)		PUSHJ	P,CVJFN			; Get JFN
1)		 JRST	FILBOG			; bogus filespec
1)		PUSHJ	P,UNJFN
1)		RLJFN				˜h)eŸ¸∏yÂAJFN, don'tÙ≤Â… any more
1)		 NOP
1)	] ;IFN 0
1)	FPSWL:
**** FILE DSK:GUEST4;SKEF NEWAT, 43-64 (119701) AFTER FPSPC:
2)		MOVE	B,0(P)			; Filename from file block
2)		PUSHJ	P,CVJFN			; Get JFN
2)		 JRST	FILBOG			; bogus filespec
2)		HRRI	B,1(CP)			; 1 plus addr of last char -> A
2)		MOVEM	B,NAMNXT		; point to next free name word
2)		RLJFN				; Release JFN, don't need any more
2)		 NOP
2)		
2)	FPSWL:
***************

**** FILE DSK:SYSEN1;@ 695, 43-96 (119991) AFTER FILBOG:
1)	;;;	SIXBIT word
1)	UNJFN:	PUSH	P,D
1)		PUSH	P,A			; save JFN
1)		HRROI	A,NAMBLK		; where to write string
1)		HRRZ	B,(P)			; get JFN back
**** FILE DSK:GUEST4;SKEF NEWAT, 43-97 (120455) AFTER FILBOG:
2)	;;;	SIXBIT word.
2)	UNJFN:	pus˝x,Ar
2)		PUSH	P,D
2)		PUSH	P,A			; save JFN
2)		hrro	a, namnxt		; where to write string
2)		hrr	r, a			; address for call to JFN6
2)		HRRZÒ0ñ(°ı"DâwÙÚÙA˘Qß ≈ack
***************

**** FILE DSK:SYSEN1;@ 695, 43-105 (120219) AFTER UNJFN:
1)		PUSHJ	P,JFN6			; convertÙ7†Áixbit, return in A
1)		MOVEM	A,1(L)
1)		; Convert dev:<directory> to PPN
1)	T20,[	HRROI	A,NAMBLK
1)		HRRZ	B,(P)
1)	Ò3g÷ãÒ0÷[c00000,,0]		; device and no punctuation
1)		SETZ	D,
1)		JFNS
1)		PUSH	P,A			; save string pointer
1)		PUSHJ	P,JFN6			; check for nullness
1)		JUMPN	A,JFNNZD		; non-null
1)		MOVE	A,[ASCII /PS/]		; dummy device
1)		MOVEM	A,NAMBLK
1)		MOVE	A,[260700,,NAMBLK]	; pointer to just past it
1)		MOVEM	A,(P)
1)	JFNNZD:
1)		MOVEI	A,":			; Punctuation
1)		IDPB	A,(P)			; put it into string
1)		MOVE	A,NAMBLK		;PRESERVE STRUCTURE NAME
1)		MOVE	B,NAMBLK+1
1)		MOVEM	A,STRBUF
1)		MOVEM	B,STRBUF+1
1)		MOVE	A,(P)			; where to write directory name
1)		HRRZ	B,-1(P)			; get JFN back
1)		MOVE	C,[20000,,1]		; <directory>
1)		JFNS				; convert to string
1)		POP	P,A			; pointer to where it should be
1)		ILDB	B,A			; anything?
1)		SKIPN	B
1)	         JRST	 FILZPP
1)		MOVSI A,(RC%EMO)		; Want exact match
1)		HRROI B,NAMBLK	
1)		RCDIR				; Error shouldn't happen
1)		MOVE B,C			; Get dir # into B
1)	];T20
1)	10X,[	HRROI A,NAMBLK
1)		HRRZ B,(P)
1)		MOVE C,[20000,,0]		; "directory"
1)		JFNS
1)		MOVE A,[440700,,NAMBLK]
1)		ILDB B,A			; Anything?
1)		JUMPE B,FILZPP
1)		SETZ A,
1)		HRROI B,NAMBLK
1)		STDIR
1)		 .VALUE		; No match - should never happen
1)		 .VALUE		; ambiguous - ditto
1)		MOVE B,A	; Get dir # into B
1)	];10X
1)		
**** FILE DSK:GUEST4;SKEF NEWAT, 43-108 (120736) AFTER UNJFN:
2)		hrri	d, 1(a)			; see if we ran out of string space
2)		cail	d, namend
2)		 jrst	 fnsgon			; yup, all gone
2)		movem	d, namnxt		; update next filename pointer
2)		PUSHJ	P,JFN6			; convert to sixbit, return in A
2)	Ò3g÷ã˘¢`¨c(L)
2)		; Convert dev:<directory> to PPN@@@@We have to hack this sometime?
2)	;T20,˚btrÂo	a, namnxt		; pointer to next filename string
2)	;	HRRZ	B,(P)
2)	;	MOVE	C,[100000,,0]		; device and no punctuation
2)	;	SETZ	D,
2)	;	JFNS
2)	;	hrri	d, 1(a)			; see if we ran out of string space
2)	;	cail	d, namend
2)	˜bPjÂst	 fnsgon			; yup, all gone
2)	;	movem	d, namnxt		; update next filename pointer
2)	;	PUSH	P,A			; save string pointer
2)	;	PUSHJ	P,JFN6			; check for nullness
2)	;	JUMPN	A,JFNNZD		; non-null
2)	;	MOVE	A,[ASCII /PS/]		; dummy device
2)	;	MOVEM	A,NAMBLK
2)	;	MOVE	A,[260700,,NAMBLK]	; pointer to just past it
2)	;	MOVEM	A,(P)
2)	;JFNNZD:	MOVEI	A,":			; punctuation
2)	;	IDPB	A,(P)			; put it into string
2)	;	MOVE	A,NAMBLK		;PRESERVE STRUCTURE NAME
2)	;	MOVE	B,NAMBLK+1
2)	;	MOVEM	A,STRBUF
2)	;	MOVEM	B,STRBUF+1
2)	;	MOVE	A,(P)			; where to write directory name
2)	;	HRRZ	B,-1(P)			; get JFN back
2)	;	MOVE	C,[20000,,1]		; <directory>
2)	;	JFNS				; convert to string
2)	;	POP	P,A			; pointer to where it should be
2)	;	ILDB	B,A			; anything?
2)	;	SKIPN	B
2)	;         JRST	 FILZPP
2)	;	MOVSI A,(RC%EMO)		; Want exact match
2)	;	HRROI B,NAMBLK	
2)	;	RCDIR				; Error shouldn't happen
2)	;	MOVE B,C			; Get dir # into B
2)	;];T20
2)	;10X,[	HRROI A,NAMBLK
2)	;	HRRZ B,(P)
2)	;	MOVE C,[20000,,0]		; "directory"
2)	;	JFNS
2)	;	MOVE A,[440700,,NAMBLK]
2)	;	ILDB B,A			; Anything?
2)	;	JUMPE B,FILZPP
2)	;	SETZ A,
2)	;	HRROI B,NAMBLK
2)	;	STDIR
2)	;	 .VALUE		; No match - should never happen
2)	;	 .VALUE		; ambiguous - ditto
2)	;	MOVE B,A	; Get dir # into B
2)	;];10X
2)		
***************

**** FILE DSK:SYSEN1;@ 695, 43-158 (121533) AFTER FILZPP:
1)		HRROI	A,NAMBLK
1)		HRRZ	B,(P)
**** FILE DSK:GUEST4;SKEF NEWAT, 43-168 (122474) AFTER FILZPP:
2)		hrro	a, namnxt	; next free filename string
2)	Ò:9r˛Ka	; address for call ˛õ–JçN6
2)		HRRZ	B,(P)
***************

**** FILE DSK:SYSEN1;@ 695, 43-162 (121591) AFTER FILZPP:
1)		PUSHJ	P,JFN6
**** FILE DSK:GUEST4;SKEF NEWAT, 43-173 (122599) AFTER FILZPP:
2)		hrri	d, 1(a)		; see if we ran out of string space
2)		cail	d, namend
2)		 jrst	 fnsgon		; yup, all gone
2)		movem	d, namnxt	; update next filename pointer
2)		PUSHJ	P,JFN6
***************

**** FILE DSK:SYSEN1;@ 695, 43-165 (121654) AFTER FILZPP:
1)		HRROI	A,NAMBLK
1)		HRRZ	B,(P)
**** FILE DSK:GUEST4;SKEF NEWAT, 43-180 (122813) AFTER FILZPP:
2)		hrro	a, namnxt	; next free filename string
2)		hrr	˛Ka	; address for call ˛õ–JçN6
2)		HRRZ	B,(P)
***************

**** FILE DSK:SYSEN1;@ 695, 43-169 (121712) AFTER FILZPP:
1)		PUSHJ	P,JFN6
**** FILE DSK:GUEST4;SKEF NEWAT, 43-185 (122938) AFTER FILZPP:
2)		hrri	d, 1(a)		; see if we ran out of string space
2)		cail	d, namend
2)		 jrst	 fnsgon		; yup, all gone
2)		movem	d, namnxt	; update next filename pointer
2)		PUSHJ	P,JFN6
***************

**** FILE DSK:SYSEN1;@ 695, 43-173 (121777) AFTER FILZPP:
1)		POPJ	P,
1)	˜n›†«˝˚ªeÂ˛à9ÙÂing in NAM¯S%†Èo SIXBIT and leave in A
1)	JFN6:	PUSH P,CH
1)		MOVE	B,[440600,,A]
1)		MOVE	C,[440700,,NAMBLK]
1)		SETZ	A,
1)	JFN6A:	ILDB	CH,C
1)	Ò2™Õ°E CH,JFN6B
1)		SUBI	CH,40
**** FILE DSK:GUEST4;SKEF NEWAT, 43-193 (123154) AFTER FILZPP:
2)		pop	p, r
2)		POPJ	P,
2)	;;; convert string starting at what R points to to SIXBIT and leave in A
2)	JFN6:	PUSH	P,CH
2)		MOVE	B,[440600,,A]
2)		hrli	r, 440700
2)		SETZ	A,
2)	JFN6A:	ILDB	CH,r
2)		JUMPE	CH,JFN6B
2)		SUBI	CH,40
***************

**** FILE DSK:SYSEN1;@ 695, 43-185 (121994) AFTER JFN6A:
1)		 JRST JFN6A
1)	JFN6B:	POP P,CH
1)		POPJ P,
1)	˜n›†áonvert the JFNBLK sp¸∏–tﬂÙPJçN
**** FILE DSK:GUEST4;SKEF NEWAT, 43-206 (123392) AFTER JFN6A:
2)		 JRST	 JFN6A
2)	JFN6B:	POP	P,CH
2)		POPJ	P,
2)	;;; C˝˚ªeÂ˛à:hÀ JFNBLK spec to a JFN
***************

**** FILE DSK:SYSEN1;@ 695, 44-2 (122328) AFTER CVJFN:
1)	SUBTTL File Description Storage (FILBLK's)
1)	TNXSW==<T20FLG+10XFLG>
1)	IFN T˘÷)◊Y[
1)	ITSSW==<DECSW==0>
1)	;VBLK
1)		; Definitions for indices into a FILBLK.
1)		; Scratch block FB is formed while defining indices...
1)	FB:	OFFSET -.
1)			; Lots of crocks depend on the exact order of these 4 items.
1)	$F6DEV:: 0			; SIXBIT Device name
1)	$F6FNM:: $F6FN1:: 0		; SIXBIT Filename (on ITS, FN1)
1)	$F6TYP:: $F6FN2:: $F6EXT:: 0	; SIXBIT Extension (on ITS, FN2)
1)	$F6DIR:: 0Ò"DªASIXBIT Directory (may be numerical PPN)
1)		L$F6BLK==.
1)	$FVER˙nù IFGEN:˜H	w File vers˝;˜ Qor generation).  NUMBER, not string.
1)	IFN TNXSW,[		; Almost all entries here are BP's to ASCIZ strings.
1)	$FDEV::  0		; Device name
1)	$FDIR::  0		; Directory name
1)	$FNAME:: 0		; File name (i.e. main name)
1)	$FTYPE:: $FEXT:: 0	; File type (or extension)
1)	$FTEMP:: 0		; -1 => File is a temporary file.
1)	$FACCT:: 0		; Account string
1)	$FPROT:: 0		; Protection string
1)	$FJFN::  0		; JFN for file (may be <desired JFN>,,<temp JFN>)
1)	]
1)	IFN ITSSW\¯ëa”Ø,[
1)	$FDEV==:$F6DEV		; These definitions made so some common code can do
1)	$FDIR==:$F6DIR		; the right things.
1)	$FNAME==:$F6FNM
1)	$FTYPE==:$F6TYP
1)	$FEXT==:$F6TYP
1)	]
1)		L$FBLK==.	; Length of a FILBLK.
1)		OFFSET 0	; End of index definitions.
1)	] ;TNXSW
1)	IFN TNXSW,[	; Moby conditional for Tenex reader.
1)	; TNXRFD - ATSIGN TNX filename reader.
1)	;	Takes BP in A to ASCIZ string to parse.
1)	;	Takes L as ptr to filename block to fill out.
1)	˜baÏﬂ¸X≤ÚÁ nothing.
1)	TNXRFD:
1)	.BEGIN RFDBLK
1)	MAXIND==100.
1)	FL20X==400000
1)	FLUNRD==200000
1)	FRCMND==2
1)	FRNNUL==1
1)	IFNDEF FRFDEV,FRFDEV==2		; Set if read device.
1)	IFNDEF FRFDIR,FRFDIR==1		; Set if read directory.
1)	FRFN1==4
1)	IFNDEF FRFEXT,FRFEXT==FRFN1	; Borrow this bit.  Set if read extension.
1)	FRARRO==10
1)	F=R	; F must not == L.
1)	FF=R+1
1)	AA=R+2
1)	T=R+3
1)	TT=R+4
1)		INSIRP PUSH P, A B C D F FF AA T TT
1)		SETZ FF,	; set up flags
1)	T20,	TLO FF,FL20X
1)		MOVEI F,FB	; Point to scratch FB
1)		MOVEM A,RCHBP	; Save BP to asciz string
1)		SETZM FB
1)		MOVE A,[FB,,FB+1]
1)		BLT A,FB+L$FBLK-1
1)		PUSHJ P,TRFD
1)		INSIRP POP P, TT T AA FF F D C B
1)		PUSH P,F
1)		MOVEI F,FB
1)		PUSHJ P,CVFSIX		; Convert to sixbit entries
1)		IRP STF,,[DIR,DEV,FN1,FN2]
1)		MOVE A,$F6!STF(F)
1)		MOVEM A,(L).IRPCNT
1)		TERMIN
1)		PUSHJ P,TDIRNM
1)		CAIE A,		; If got a dir number,
1)		 SETZM 1(L)	; Zap the device field.
1)		MOVEM A,0(L)	; Else keep it anyway, store result.
1)		POP P,F
1)		POP P,A
1)	APOPJ:	POPJ P,
1)	; TDIRNM - Given filblk pointed to by F, returns in A the dir #
1)	;	for dev/dir combination.  Returns 0 if failure.
1)	TDIRNM:	SKIPN A,$FDIR(F)	; Get BP to dir name
1)		 POPJ P,		; Not specified, leave all alone.
1)		PUSH P,B
1)	10X,[
1)		MOVE B,A
1)		SETZ A,
1)		STDIR
1)		 SETZ A,	; No match - should never happen
1)		 SETZ A,	; ambiguous - ditto
1)	];10X
1)	T20,[	PUSH P,C
1)		SKIPN A,$FDEV(F)		; Device exists?
1)		 MOVE A,[440700,,[ASCIZ /PS/]]		; dummy device
1)		SKIPA B,[440700,,STRBUF]
1)		 IDPB C,B
1)		ILDB C,A
1)		JUMPN C,.-2
1)		MOVEI C,":
1)		IDPB C,B
1)		MOVEI C,"<	;>
1)		IDPB C,B
1)		SKIPA A,$FDIR(F)
1)		 IDBP C,B
1)		ILDB C,A
1)		JUMPN C,.-2	;<
1)		MOVEI C,">
1)		IDPB C,B
1)		SETZ C,
1)		IDPB C,B
1)		MOVSI A,(RC%EMO)		; Want exact match
1)		HRROI B,STRBUF	
1)		RCDIR				; Error shouldn't happen
1)		 ERJMP [SETZ C, ? JRST .+1]
1)		MOVE A,C			; Get dir # into A
1)		POP P,C
1)	];T20
1)		POP P,B
1)		POPJ P,
1)	; TRFD - TENEX-style Filename Reader.
1)	;	Takes input from RCH.
1)	;	Deposits name strings into filblk F points to.
1)	;	Clobbers A,B,C,D, (and AA,T,TT due to FNCHK)
1)	; Uses FRFEXT flag to see if already read extension (type) or not.
1)	;	Refuses to accept existing defaults for version, ;T, account,
1)	;	protection, or JFN.  It will also zap an existing directory
1)	;	default if a device is specified, and vice versa.  This is so that
1)	;	logical names will win a little better.
1)	; 	Implements crufty ^R hack (if see ^R, act as if just starting to
1)	;	read filename, so effect is stuff before ^R has set defaults.)
1)	TRFD:	TRZ FF,FRNNUL
1)		SETZM $FJFN(F)	; Zap JFN since the filename we'll read won't match it.
1)		SETZM $FACCT(F)	; Also zap other things that we don't want defaulted.
1)		SETZM $FPROT(F)
1)		SETZM $FTEMP(F)
1)		SETZM $FVERS(F)
1)	TRFD01:	TRZ FF,FRFEXT+FRFDEV+FRFDIR	; Jump here if ^R seen.
1)	TRFD10:	PUSHJ P,GPASST	; remove tabs, spaces and get first non-tab/space
1)		TRNN FF,FRCMND	; If parsing command line,
1)		 CAIE A,";	; or if char isn't semicolon,
1)		  JRST TRFD21	; just handle normally.
1)	TRFD15:	PUSHJ P,RCH	; Semi-colon and not command line, it's a comment!
1)		CAIE A,^M	; So flush rest, up to EOL.
1)		 JRST TRFD15
1)		POPJ P,
1)	TRFD1:	TLO FF,FLUNRD	; come here to re-read last char
1)	TRFD2:	PUSHJ P,RCH	; Get char
1)	TRFD21:	CAIE A,40	; Space? (come here to scan already-read char)
1)		 CAIN A,^I	; or tab?
1)		  JRST [TRNE FF,FRCMND	; Space/tab, if reading command line
1)			 JRST TRFD2	; then ignore and continue scanning (for switches), but
1)			JRST TRFD15]	; if not in cmd line, go flush entire rest of line!
1)		CAIN A,^M	; End of line?
1)		 POPJ P,	; If so, obviously done.
1)		CAIN A,^R	; Crufty ^R hack?
1)		 JRST TRFD01	; Sigh, pretend starting over.
1)		TRNN FF,FRCMND	; Must we check for cmd line frobs?
1)		 JRST TRFD22	; Nope, skip them.
1)		; Must check for chars special only in command line.
1)		CAIN A,"=
1)		 MOVEI A,"_
1)		CAIE A,"_	; backarrow is filename terminator...
1)		 CAIN A,",	; as is comma.
1)		  POPJ P,
1)		CAIN A,"!	; For CCL hacking...
1)		 POPJ P,	.SEE RFDRUN
1)	;	PUSHJ P,CMDSW	; Check for switches...
1)	;	 JRST TRFD21	; got some, process next char (returned by CMDSW)
1)				; Skips if none, drop thru.
1)		; Now see if char signifies start of anything in particular.
1)	TRFD22:	CAIE A,"<	; Start of directory name?
1)		 JRST TRFD24	; No
1)		PUSHJ P,RCH
1)		PUSHJ P,TRFDW	; Read word, starting with next char
1)	TRFD23:	CAIN A,".	; Allow . as part of directory name
1)		 JRST [	PUSHJ P,TRFDW5	; Read a continuation to this word
1)			JRST TRFD23]	; And try again
1)		MOVEI D,$FDIR	; Set up index.
1)		CAIN A,">	; Terminator should be end of dir name...
1)		 PUSHJ P,RCH	; If so, get next to avoid scan of ">".
1)				; else bleah, but aren't supposed to fail...
1)		TRNN FF,FRFDEV	; Unless a device has been explicitly given,
1)		 SETZM $FDEV(F)	; zap any furnished default.  0 means DSK.
1)		TRO FF,FRFDIR	; Now say dir was explicitly given.
1)		JRST TRFD6	; Go store it.
1)	TRFD24:	CAIN A,".	; Start of $FTYPE or $FVERS (20x)?
1)		 JRST [	MOVEI D,$FTYPE	; Assume reading $FTYPE field,
1)			TLNE FF,FL20X	; always if 10X, but if really on 20X, then
1)			 TRON FF,FRFEXT	; use $FTYPE only if not already seen.
1)			  JRST TRFD4	; $FTYPE - jump to get word & store.
1)			PUSHJ P,TRFDNM	; $FVERS - 20X and $FTYPE already seen. Get #.
1)			 MOVEM B,$FVERS(F)	; Store it away if successful.
1)			JRST TRFD1]		; and go re-read delimiting char.
1)		CAIN A,";	; Start of $FVERS (10x) or attribute?
1)		 JRST [	PUSHJ P,RCH	; Find what next char is.
1)			CAIL A,"a	; Must uppercasify.
1)			 CAILE A,"z
1)			  CAIA
1)			   SUBI A,40
1)			CAIN A,"T	; Temporary file?
1)			 JRST [	SETOM $FTEMP(C)
1)				JRST TRFD2]
1)			CAIN A,"A	; Account?
1)			 JRST [	MOVEI D,$FACCT	; Set index, and
1)				JRST TRFD4]	; go gobble following word.
1)			CAIN A,"P	; Protection?
1)			 JRST [	MOVEI D,$FPROT	; Set index, and
1)				JRST TRFD4]	; go gobble following word.
1)			TLO FF,FLUNRD	; Not alpha, try numeric.  Re-read char,
1)			PUSHJ P,TRFDNM	; trying to parse as number.
1)			 MOVEM B,$FVERS(F)	; Win, parsed as number! Store it.
1)			JRST TRFD1]	; If none of above, ignore ";" entirely.
1)		PUSHJ P,TRFDW	; Let's try reading it as word,
1)		JUMPLE C,APOPJ	; If nothing read, assume it's some terminating delimiter.
1)		CAIN A,":	; Else have something, check trailing delim for special cases
1)		 JRST [	MOVEI D,$FDEV		; Aha, a device.
1)			PUSHJ P,RCH		; Flush the terminator & get next char.
1)			TRNN FF,FRFDIR		; Unless dir was explicitly given,
1)			 SETZM $FDIR(F)		; zap furnished default. 0 uses connected dir.
1)			TRO FF,FRFDEV		; Say device was explicitly given, and
1)			JRST TRFD6]		; store name away.
1)		MOVEI D,$FNAME	; Else assume it's the filename.
1)		JRST TRFD6
1)	TRFD4:	PUSHJ P,RCH	; Here when must gobble next char,
1)	TRFD5:	PUSHJ P,TRFDW	; here when first char of wd already read.
1)	TRFD6:	PUSHJ P,FNCHKZ	; Note this can return and store a null string!
1)		ADDI D,(F)	; Get address (filblk+index), and
1)		MOVEM A,(D)	; store string pointer in the appropriate place.
1)		TRO FF,FRNNUL	; Say non-null spec seen,
1)		JRST TRFD1	; and go re-read the delimiter, to process it.
1)	; TRFDW - Read a word (string), for use by TNXRFD.  Copies sequence of
1)	;	acceptable filename chars into FNBUF, until non-valid char seen.
1)	;	A/ First char of word,
1)	;	Returns A/ delimiting char, C/ count of chars in string,
1)	;	clobbers nothing else.
1)	TRFDW4:	SUBI A,40	; Make lowercase
1)	TRFDW5:	IDPB A,FNBWP	; Deposit into FNBUF,
1)		PUSHJ P,RCH	; get next char,
1)		AOSA C		; and bump count, skipping over zap instruction.
1)	TRFDW:	 SETZ C,	; When called, zero cnt of chars in string.
1)		CAIL A,"A	; See if char is uppercase alpha,
1)		 CAILE A,"Z
1)		  CAIA
1)		   JRST TRFDW5
1)		CAIL A,"a	; or lowercase alpha,
1)		 CAILE A,"z
1)		  CAIA
1)		   JRST TRFDW4
1)		CAIL A,"0	; or numeric,
1)		 CAILE A,"9
1)		  CAIA
1)		   JRST TRFDW5
1)		CAIE A,"$	; or dollarsign
1)		 CAIN A,"-	; or hyphen
1)		  JRST TRFDW5
1)		CAIN A,"_	; Backarrow is special case, because
1)		 JRST [	TRNN FF,FRCMND	; if reading command,
1)			 TLNN FF,FL20X	; or running on 10X,
1)			  POPJ P,	; must treat as delimiter.
1)			JRST TRFDW5]
1)		CAIN A,^V	; ^V is quote char...
1)		 JRST [	PUSHJ P,RCH	; Quote, get next.
1)			CAIE A,^M	; Quote anything but this.
1)			 CAIN A,0	; or this.
1)			  POPJ P,	; time to exit.
1)			PUSH P,A	; Quote it!  Save char,
1)			MOVEI A,^V	; so that a quoter can precede it.
1)			IDPB A,FNBWP	; Fortunately this hair
1)			POP P,A		; only needs care
1)			IDPB A,FNBWP	; for quoted chars, which are
1)			JRST TRFDW5]	; rare.
1)		TLNE FF,FL20X	; Are we on a 10X?
1)		 POPJ P,	; If not, anything at this point is delimiter.
1)		CAIL A,41	; Check general bounds
1)		 CAIL A,137	; Range from space to _ exclusive.
1)		  POPJ P,	; If outside that, delimiter.
1)		CAIL A,72	; This range includes :, ;, <, =, >
1)		 CAILE A,76
1)		  CAIA
1)		   POPJ P,	; delimiter.
1)		CAIE A,".
1)		 CAIN A,",
1)		  POPJ P,
1)		CAIE A,"*
1)		 CAIN A,"@
1)		  POPJ P,
1)		; Finally, check out chars which are acceptable to 10X but which
1)		; might be delimiter in cmd line...
1)		TRNN FF,FRCMND
1)		 JRST TRFDW5	; Not hacking cmd line, it's an OK char.
1)		CAIE A,"/
1)		 CAIN A,"(
1)		  POPJ P,
1)		CAIN A,"!
1)		 POPJ P,
1)		JRST TRFDW5	; at long last done.
1)	; TRFDNM - Read numerical string, halt when non-digit
1)	;	seen, leaves result (decimal) in B, with delimiting char in A.
1)	;	One peculiarity is skip return if no numerical char is seen at all;
1)	;	else doesn't skip and B has a valid number.
1)	TRFDNM:	PUSHJ P,RCH		; First char needs special check.
1)		CAIL A,"0
1)		 CAILE A,"9
1)		  JRST POPJ1		; Not a number at all?
1)		TDZA B,B
1)	TRFDN2:	 IMULI B,10.
1)		ADDI B,-"0(A)		; Convert to number
1)		PUSHJ P,RCH		; Get following chars.
1)		CAIL A,"0
1)		 CAILE A,"9
1)		  POPJ P,		; Nope, not digit so treat as delimiter.
1)		JRST TRFDN2	; Yep, a number
1)	;; Extra stuff to support ATSIGN use of MIDAS code
1)	.SCALAR LASTCH, RCHBP
1)	RCH:	TLZE FF,FLUNRD
1)		 SKIPA A,LASTCH
1)		  ILDB A,RCHBP
1)		CAIN A,
1)		 MOVEI A,^M
1)		MOVEM A,LASTCH
1)		POPJ P,
1)	GPASST:	PUSHJ P,RCH
1)		CAIE A,40
1)		 CAIN A,^I
1)		  JRST GPASST
1)		POPJ P,
1)	] ;IFN TNXSW
1)	SUBTTL TENEX misc. Filename Routines, FS string storage
1)	IFN TNXSW,[	.SEE FSDSK	; Part of this page is NOT conditionalized!!
1)	; To handle filenames of ASCIZ strings instead of SIXBIT words, each
1)	; word has instead a byte pointer to an ASCIZ string.  For purposes of
1)	; easy comparison, all of these bp's point into FNBUF, and a routine
1)	; (FNCHK) is provided which checks a just-stored string and returns a bp
1)	; to either this string, if unique, or to a previously stored string if
1)	; it is the same as the one just stored (which is then flushed).  Thus
1)	; strings can be compared for equality simply by a comparison of their
1)	; byte pointers.  While not necessary, strings are stored beginning on
1)	; word boundaries for easier hacking.
1)		; <# files>*<avg # strings/file>*<avg # words/string>+<# wds for constants>
1)	LFNBUF==<MAXIND+5>*5*3+20	; Enough to hold strings for all output files,
1)			; all translated files, and all .insrt files encountered.
1)			; Later a GC'er can be hacked up so that of the latter only
1)			; enough for the max .insrt level need be allocated.
1)	FNBUF:	block LFNBUF
1)		; Macro to easily define constant strings for comparison purposes
1)	DEFINE DEFSTR *STR*
1)	440700,,%%FNLC
1)	%%LSAV==.
1)	LOC %%FNLC
1)	ASCIZ STR
1)	%%FNLC==.
1)	LOC %%LSAV
1)	TERMIN
1)		%%FNLC==FNBUF
1)	] ; IFN TNXSW!!!
1)		; If not assembling for TENEX, the following strings become
1)		; simple SIXBIT values.  This makes it possible to write simple
1)		; code to work for both TENEX and non-TENEX without messy conditionals.
1)	IFE TNXSW,[EQUALS DEFSTR,SIXBIT]
1)	FSDSK:	DEFSTR /DSK/	; This stuff defines various BP's into FNBUF to
1)	FSSYS:	DEFSTR /SYS/	; use for comparison purposes later.
1)	FSTTY:	DEFSTR /TTY/
1)	FSNUL:	DEFSTR /NUL/
1)	FSPTP:	DEFSTR /PTP/
1)	FSATSN:	DEFSTR /@/
1)	FSSBSY:	DEFSTR /SUBSYS/
1)	FSPROG:	DEFSTR /PROG/
1)	FSMID:	DEFSTR /MID/
1)	FSMDAS:	DEFSTR /MIDAS/
1)	FSGRTN:	DEFSTR />/
1)	FSCRF:	DEFSTR /CRF/
1)	FSCREF:	DEFSTR /CREF/
1)	FSERR:	DEFSTR /ERR/
1)	FSLST:	DEFSTR /LST/
1)	FSLIST:	DEFSTR /LIST/
1)	FSSAV:	DEFSTR /SAV/
1)	FSEXE:	DEFSTR /EXE/
1)	IFN TNXSW,[
1)	;VBLK
1)	FNBBP:	440700,,FNBUF	; Points to beg of FNBUF (hook for dynamic alloc)
1)	FNBEP:	FNBUF+LFNBUF-1	; Points to last wd in FNBUF (address, not BP)
1)	FNBWP:	440700,,%%FNLC	; Write Pointer into FNBUF.
1)	FNBLWP:	440700,,%%FNLC	; Last Write Pointer, points to beg of string being stored
1)	;PBLK
1)	EXPUNG %%FNLC
1)	; NOTE - provided MIDAS never restarts, no initialization is necessary to
1)	; start using FNCHK.  (Unless of course FNBUF is dynamically allocated someday)
1)	; FNCHK - Check out just-stored filename.  Returns BP in A to ASCIZ string,
1)	;	which will be "canonical" for comparison purposes.
1)	;	Clobbers A,B,T,TT,AA
1)	; FNCHKZ - Makes sure just-writ string is ASCIZ'd out before FNCHK'ing.
1)	FNCHKZ:	MOVE B,FNBWP		; Get write ptr,
1)		LDB A,B			; see if last char was 0,
1)		JUMPE A,FNCHK0		; if so can skip one clobberage.
1)		SETZ A,
1)		IDPB A,B		; zero out bytes,
1)	FNCHK0:	TLNE B,760000		; until at end of word.
1)		 JRST .-2
1)		ADD B,[<440700,,1>-<010700,,>]	; bump BP to point canonically at next.
1)		MOVEM B,FNBWP
1)	FNCHK:	HRRZ B,FNBWP		; See if write ptr
1)		CAML B,FNBEP		; has hit end of FNBUF, and
1)	;	 ETF [ASCIZ /Filename buffer overflow/]	; barf horribly if so.
1)		 .VALUE ; sigh
1)		MOVE A,FNBBP		; A  - bp to start of existing string
1)		MOVE AA,FNBLWP		; AA - bp to start of new string to store
1)	FNCHK2:	MOVEI T,(A)		; T  - current addr being checked, existing str
1)		MOVEI TT,(AA)		; TT - current addr, new str
1)		CAIL T,(TT)		; If addrs are same, or overran somehow,
1)		 JRST [	MOVE A,AA	; didn't find any match, accept new string.
1)			MOVE B,FNBWP
1)			MOVEM B,FNBLWP	; Set up new last-write-ptr
1)			POPJ P,]
1)	FNCHK3:	MOVE B,(T)
1)		CAMN B,(TT)		; Compare strings, full word swoops.
1)		 JRST [	TRNE B,377			; equal, last char zero?
1)			 AOJA T,[AOJA TT,FNCHK3]	; no, continue for whole string
1)			; Found it!  Flush just-stored string, don't want duplicate.
1)			MOVEM AA,FNBWP		; Clobber write ptr to previous value.
1)			POPJ P,]
1)		; Not equal, move to next string to compare
1)		MOVEI B,377	; Check for ASCIZ,
1)		TDNE B,(T)	; moving to end of current string
1)		 AOJA T,.-1
1)		HRRI A,1(T)	; and updating BP to point at new string.
1)		JRST FNCHK2	; (T gets pointed there too at FNCHK2).
1)	; CVSSIX - Converts ASCIZ string to SIXBIT word.
1)	;	A/ BP to ASCIZ string,
1)	;	Returns SIXBIT word in A.  Clobbers nothing else.
1)	CVSSIX:	PUSH P,B
1)		PUSH P,C
1)		PUSH P,D
1)		MOVE D,A
1)		SETZ A,
1)		MOVE B,[440600,,A]
1)		JRST CVSSX3
1)	CVSSX2:	CAIL C,140
1)		 SUBI C,40	; Uppercase force
1)		SUBI C,40	; cvt to 6bit
1)		IDPB C,B	; deposit
1)		TLNN B,770000	; If BP at end of word,
1)		 JRST CVSSX5	; leave loop.
1)	CVSSX3:	ILDB C,D
1)		JUMPN C,CVSSX2
1)	CVSSX5:	POP P,D
1)		POP P,C
1)		POP P,B
1)		POPJ P,
1)	; CVFSIX - Takes current filblk (pointed to by F) and puts the
1)	;	right stuff in $F6 entries.
1)	CVFSIX:	PUSH P,A
1)		PUSH P,B
1)		MOVSI B,-L$F6BL
1)	CVFSX2:	MOVE A,@CVFTAB(B)	; Get BP to string
1)		PUSHJ P,CVSSIX		; Convert to 6bit
1)		ADDI B,$F6DEV(F)	; Get index to right place to store.
1)		MOVEM A,(B)
1)		SUBI B,$F6DEV(F)	; restore aobjn pointer...
1)		AOBJN B,CVFSX2
1)		POP P,B
1)		POP P,A
1)		POPJ P,
1)	CVFTAB:	$FDEV(F)
1)		$FNAME(F)
1)		$FEXT(F)
1)		$FDIR(F)
1)	IFN <.-CVFTAB>-L$F6BL, .ERR CVFTAB loses.
1)	.END RFDBLK
1)	] ;IFN TNXSW
1)	SUBTTL	COMMAND LINE SWITCH PARSER
**** FILE DSK:GUEST4;SKEF NEWAT, 44-2 (123727) AFTER CVJFN:
2)	SUBTTL	COMMAND LINE SWITCH PARSER
***************

**** FILE DSK:SYSEN1;@ 695, 57-36 (150988) AFTER FPSFN0:
1)	FPSFN3:	INSIRP PUSH P,CC CP FPNTBP L R D F B
1)	FPSFNP==:.-FPSFN3
**** FILE DSK:GUEST4;SKEF NEWAT, 52-36 (135982) AFTER FPSFN0:
2)	FPSFN3:	INSIRP PUSH P,CC CP FPNTBP L R D F
2)	FPSFNP==:.-FPSFN3
***************

**** FILE DSK:SYSEN1;@ 695, 57-47 (151442) AFTER FPSFN1:
1)		INSIRP POP P,B F D R L FPNTBP CP CC
1)		JRST FPSXGP
**** FILE DSK:GUEST4;SKEF NEWAT, 52-47 (136434) AFTER FPSFN1:
2)		INSIRP POP P,F D R L FPNTBP CP CC
2)		JRST FPSXGP
***************

**** FILE DSK:SYSEN1;@ 695, 59-22 (152532) AFTER FPSDE1:
1)		CAIN A,'C
1)		 JRST [	MOVEI A,DEVCGP	;"C" => CGP (Canon ersatz XGP)
1)			JRST FPSDV3]
1)	];XGP
**** FILE DSK:GUEST4;SKEF NEWAT, 54-22 (137522) AFTER FPSDE1:
2)	];XGP
***************

**** FILE DSK:SYSEN1;@ 695, 59-30 (152709) AFTER FPSDE1:
1)	FLORIDA,[CAIN A,'F		; F => FLORIDA
1)		jrst	[MOVEI A,DEVFLA
1)			 JRST  FPSDV4]
1)	];FLORIDA
1)	PRESS,[	CAIE A,'D
**** FILE DSK:GUEST4;SKEF NEWAT, 54-27 (137615) AFTER FPSDE1:
2)	VARIFLEX,[CAIN A,'V		; V - Variflex
2)		jrst	[MOVEI A,DEVVFX
2)			 JRST  FPSDV4]
2)	];VARIFLEX
2)	PRESS,[	CAIE A,'D
***************

**** FILE DSK:SYSEN1;@ 695, 64-10 (164749) AFTER FPDFN2:
1)		MOVE H,CODTYP
1)		MOVE H,IPTFN2(H)	;NOITS, DEFAULT FN2 IS APPROPRIATE TO LANGUAGE.
1)	];NOITS
**** FILE DSK:GUEST4;SKEF NEWAT, 59-10 (149657) AFTER FPDFN2:
2)	NOTNX,[	MOVE H,CODTYP
2)		MOVE H,IPTFN2(H)	;NOITS, DEFAULT FN2 IS APPROPRIATE TO LANGUAGE.
2)	];NOTNX
2)	˙ì¨,∑	move	b, codtyp	; get cod¸®2¯È¸ªπÈﬂn
2)		move	b, (b)
2)		call	defext		; default extension of block in a to name in b
2)	];TNX
2)	];NOITS
***************

**** FILE DSK:SYSEN1;@ 695, 64-18 (164962) AFTER FPDFN2:
1)		MOVEM H,F.IFN2(A)
1)	FPDFN3:
1)	DOS,	HLLZS F.IFN2(A)		;DEFAULTING'S PAST, SO FLUSH THE RH "FOO." USES TO AVOID IT.
1)		JRST 2INOPN		;IF IT SKIPS, WE DO TOO!
1)	;DEFAULT DIRECTORY OF LREC FILE.
1)	;NOTE OUTPUT FN2 DEFAULTED IN WLREC. INPUT FN2 DEFAULTED IN RLREC.
**** FILE DSK:GUEST4;SKEF NEWAT, 59-23 (150012) AFTER FPDFN2:
2)	NOTNX,	MOVEM H,F.IFN2(A)
2)	FPDFN3:
2)	NOITS,	HLLZS F.IFN2(A)		;DEFAULTING'S PAST, SO FLUSH THE RH "FOO." USES TO AVOID IT.
2)		JRST 2INOPN		;IF IT SKIPS, WE DO TOO!
2)	;DEFAULT DIRECTORY OF LREC FILE.@*@*
2)	;NOTE OUTPUT FN2 DEFAULTED IN WLREC. INPUT FN2 DEFAULTED IN RLREC.
***************

**** FILE DSK:SYSEN1;@ 695, 68-33 (171942) AFTER FPRCHS:
1)	]
1)	DOS,[	LSH CH,LGEXTL
**** FILE DSK:GUEST4;SKEF NEWAT, 63-33 (157004) AFTER FPRCHS:
2)	];TNX
2)	DOS,[	LSH CH,LGEXTL
***************

**** FILE DSK:SYSEN1;@ 695, 70-100 (177986) AFTER FNTCP6:
1)					;COMPUTE PAGEL FROM FONTS AND VSP.
1)		ADD C,D			;ASSUME 1ST LINE VSP IS IGNORED, SO RECLAIM IT
1)		ADD D,FNTHGT		;FIND TOTAL POI˘’)†°ER LINE
1)	;;;	ADD C,FNTBAS	;WHAT THE FUCK WAS THIS FOR????
1)		IDIV C,D		;FIND # WHOLE LINES THATÙ‰Ãô FIT
1)		MOVEM C,PAGEL
**** FILE DSK:GUEST4;SKEF NEWAT, 65-100 (163052) AFTER FNTCP6:
2)		ADD C,D			;COMPUTE PAGEL FROM FONTS AND VSP.
2)		ADD D,FNTHGT
2)		ADD C,FNTBAS
2)		IDIV C,D
2)		MOVEM C,PAGEL
***************

**** FILE DSK:SYSEN1;@ 695, 72-32 (185721) AFTER RLRR1:
1)		PUSHJ P,[ SKIPN F.IFN2(A)
1)			   JRST RLRRD	;OPEN INPUT LREC FILE WITH RLRRD TO DEFAULT FN2
**** FILE DSK:GUEST4;SKEF NEWAT, 67-33 (170638) AFTER RLRR1:
2)	TNX,[	call	getext		; see if this file has an extension
2)		call	[skipn	b
2)			  jrst	 rlrrd
2)			 jrst	2inopn]
2)		 caia
2)		jrst	rlrr1a
2)	];TNX
2)	NOTNX,[	PUSHJ P,[ SKIPN F.IFN2(A)
2)			   JRST RLRRD	;OPEN INPUT LREC FILE WITH RLRRD TO DEFAULT FN2
***************

**** FILE DSK:SYSEN1;@ 695, 72-37 (185873) AFTER RLRR1:
1)	ITS,	.STATUS UTIC,B		;ON ITS, ANY ERROR OTHER THAN "FILE NOT FOUND"
1)	ITS,	LDB B,[220600,,B]	;MEANS WE WOULD PROBABLY BE UNABLE TO CREATE THE LREC FILE,
1)	ITS,	¯pd≈AB,%EN˙q¶	;SO WE SHO˙≥" â¯±§Œì˙ëfYACOMPLAIN.
1)	ITS,	 JRST RLRR1E
1)		MOVE R,SFILE		;CAN'T FIND THE INPUT LREC FILE!! WAS IT THE ONLY FILE SPEC'D?
**** FILE DSK:GUEST4;SKEF NEWAT, 67-45 (170932) AFTER RLRR1:
2)	ITS,[	.STATUS UTIC,B		;ON ITS, ANY ERROR OTHER THAN "FILE NOT FOUND"
2)		LDB B,[220600,,B]	;MEANS WE WOULD PROBABLY BE UNABLE TO CREATE THE LREC FILE,
2)		CAIE B,%ENSFL		;SO WE SHOULD DEFINITELY COMPLAIN.
2)		 JRST RLRR1E
2)	];ITS
2)		MOVE R,SFILE		;CAN'T FIND THE INPUT LREC FILE!! WAS IT THE ONLY FILE SPEC'D?
***************

**** FILE DSK:SYSEN1;@ 695, 72-49 (186599) AFTER RLRR1E:
1)	RLRR1B:	STRT [ASCIZ /(LREC file new - listing all files in full)
1)	/]
1)		POPJ P,
**** FILE DSK:GUEST4;SKEF NEWAT, 67-57 (171652) AFTER RLRR1E:
2)	];NOTNX
2)	RLRR1B:	STRT [ASCIZ /(LREC file new - listing all files in full)
2)	/]				; @@@@ make this work
2)		POPJ P,
***************

**** FILE DSK:SYSEN1;@ 695, 72-62 (186971) AFTER RLRR1C:
1)	RLRRD:	MOVE CH,LRCFN2		;FIRST TRY "LREC" OR "LRC" AS FN2.
**** FILE DSK:GUEST4;SKEF NEWAT, 67-72 (172060) AFTER RLRR1C:
2)	TNX,[
2)	rlrrd:	push	p, f.isnm(a)	; save pointer to file name
2)		moveÒ8ñ Ÿrcfn2	; while we mun¸˘Po›ce...
2)		call	defext
2)		call	2inopn		; try to open with first try at extension
2)		 jrst	 rlrrd1
2)		pop	p, ch		; throw away old file name pointer
2)		move	ch, f.isnm(a)	; copy into output file name
2)		movem	ch, f.osnm(a)
2)		jrst	popj1
2)	rlrrd1:	pop	p, f.isnm(a)	; restore the unmunged file name
2)		move	b, alrfn2	; munge again with alternate extension
2)		call	defext
2)		call	2inopn
2)		 jfcl			; this is our last chance
2)		move	ch, f.isnm(a)	˜h1Ô·y into output file name
2)		movem	ch, f.osnm(a)
2)		dropthruto popj1
2)	];TNX
2)	NOTNX,[
2)	RLRRD:	MOVE CH,LRCFN2		;FIRST TRY "LREC" OR "LRC" AS FN2.
***************

**** FILE DSK:SYSEN1;@ 695, 72-72 (187224) AFTER RLRRD1:
1)	POPJ1:	AOSA (P)
**** FILE DSK:GUEST4;SKEF NEWAT, 67-103 (172924) AFTER RLRRD1:
2)	];NOTNX
2)	POPJ1:	AOSA (P)
***************

**** FILE DSK:SYSEN1;@ 695, 73-23 (187753) AFTER RLRR1A:
1)		CAMN R,[SIXBIT/LREC/+1]	;THIS IS WHAT IT SHOULD BE.
1)		 JRST RLRR2		;FILE LOOKS LIKE LREC FILE.
**** FILE DSK:GUEST4;SKEF NEWAT, 68-23 (173464) AFTER RLRR1A:
2)	TNX,[	camn	r, [sixbit /LREC/ + 2] ; this is what i˛à9Ëﬂuld be for new lrec
2)		 jrst	 rlrr2
2)		came	r, [sixbit /LREC/ + 1] ; might be old format
2)		 jrst	 rlrr1y		; nope, just a losing file
2)		flosei	flsnnl, 0(a)	; "File is old format LREC file."
2)		 jrst	 rlrr1z		; he wants to press on anyway...
2)	];TNX
2)	NOTNX,[	CAMN R,[SIXBIT/LREC/+1]	;THIS IS WHAT IT SHOULD BE.
2)		 JRST RLRR2		;FILE ˘ìÁÀßÙ$Àã LREC FILE.
***************

**** FILE DSK:SYSEN1;@ 695, 73-27 (187961) AFTER RLRR1A:
1)		FLOSEI FLSNLR,F.ISNM(A)	;"FILE IS NOT AN LREC FILE".
1)		 JFCL [	PUSH DP,R	;BUT USER INSISTS? OK, ASSUME IT IS ONE
1)			JRST RLRR2]
**** FILE DSK:GUEST4;SKEF NEWAT, 68-34 (173979) AFTER RLRR1A:
2)	];NOTNX
2)	rlrr1y:	FLOSEI FLSNLR,F.ISNM(A)	;"FILE IS NOT AN LREC FILE".
2)	rlrr1z:	 JFCL [	PUSH DP,R	;BUT USER INSISTS? OK, ASSUME IT IS ONE
2)			JRST RLRR2]
***************

**** FILE DSK:SYSEN1;@ 695, 73-76 (189630) AFTER ˙S)Rô3:
1)	RLRRE:	HRLZI D,(C)		;COME HERE FOR EACH ENTRY IN FILE. C -> ENTRY.
1)		HRRI D,INSSNM
**** FILE DSK:GUEST4;SKEF NEWAT, 68-84 (175671) AFTER RLRRL3:
2)	RLRRE:	hlrz d,(c)		;COME HERE FOR EACH ENTRY IN FILE. C -> ENTRY.
2)	TNX,[	hrr	¸ãc	; build byte pointer for TNX long file name
2)		hrli	d, 440700
2)		movem	d, inssnm	; store as input file name
2)		skipe	(c)		; move ahead until 0 word
2)		aobjn	c, .-1
2)		push	p, [0]		; save specified fn2
2)		add	c, [1,,1]	; move to subentries
2)	];TNX
2)	NOTNX,[	HRLZI D,(C)
2)		HRRI D,INSSNM
***************

**** FILE DSK:SYSEN1;@ 695, 73-82 (189902) AFTER RLRRE:
1)		PUSH˘H(,•˘î©S	;NOW SKIP OVER SUBE˘’)Iã˙kP•OCESS˘3£†ßAVED SWITCHES, ETC.
**** FILE DSK:GUEST4;SKEF NEWAT, 68-101 (176224) AFTER RLRRE:
2)	];NOTNX
2)		PUSHJ P,RLRRS		;NOW SKIP OVER SUBENTRIES, PROCESSING SAVED SWITCHES, ETC.
***************

**** FILE DSK:SYSEN1;@ 695, 76-16 (196657) AFTER MLREC1:
1)		ADD B,[4,,4]		;ADVANCE PAST FILENAMES AT BEGINNING OF ENTRY.
1)	;ADVANCE PAST THE NEXT SUBENTRY.
**** FILE DSK:GUEST4;SKEF NEWAT, 71-16 (182990) AFTER MLREC1:
2)	TNX,[	skipe (b)		; move ahead until 0 word
2)		aobjn b,.-1
2)		add b,[1,,1]		; mov¸®:oA˛}qe›˛ú¥ÂÁ
2)	];TNX
2)	NOTNXıÇ`ƒâÙñ[i,,4]	Ò.‡ƒ≠ANCE PAST FILENAMES ¯5BãGINNING OF ENTRY.
2)	;ADVANCE PAST THE NEXT SUBENTRY.
***************

**** FILE DSK:SYSEN1;@ 695, 77-31 (199464) AFTER XLREC2:
1)	WLRDF:	SKIPE A,WLRECP
**** FILE DSK:GUEST4;SKEF NEWAT, 72-31 (185905) AFTER XLREC2:
2)	TNX,[
2)	wlrdf:	skipn	a, wlrecp
2)		 ret
2)		call	getext		; get extension for file in a
2)		skip¸¢q	; if b = 0, no ¸æ:e›˛zwÓAgiven
2)	Ò(9eÈ			; otherwise there was one
2)		move	 b, lrcfn2	; just grab default extension
2)		jrst	defext		; cons up name with extension & return
2)	];TNX
2)	NOTNX,[
2)	WLRDF:	SKIPE A,WLRECP
***************

**** FILE DSK:SYSEN1;@ 695, 78-2 (200251) AFTER WLREC3:
1)	SUBTTL	LREC DUMPING ROUTINES (¯”È âEBUGGING)
**** FILE DSK:GUEST4;SKEF NEWAT, 72-67 (186969) AFTER WLREC3:
2)	];NOTNX
2)	SUBTTL	LREC DUMPING ROUTINES (FOR DEBUGGING)
***************

**** FILE DSK:SYSEN1;@ 695, 82-42 (208231) AFTER WLREC:
1)		WLRWWD B,[SIXBIT/LREC/+1]	;1ST WORD OF LREC FILE IS SIXBIT/LREC/+1
1)		MOVEI A,FILES			;LOOK AT ALL FILES,
**** FILE DSK:GUEST4;SKEF NEWAT, 77-42 (194961) AFTER WLREC:
2)	TNX,	wlrwwd b,[sixbit /LREC/ + 2]	; 1st word is sixbit /LREC/ + 2 for TNX
2)	NOTNX,	WLRWWD B,[SIXBIT/LREC/+1]	;1ST WORD OF LREC FILE IS SIXBIT/LREC/+1
2)	Ò3g÷ã˘( ¨ç˘3"”		;LO˘Ú–A© ALL FILES,
***************

**** FILE DSK:SYSEN1;@ 695, 84-50 (212474) AFTER WLRW:
1)		WLRWWD B
1)	NOCMU,[				;UNDER CMU, USE THE SPECIFIED DEVICE, N˘ıTëE REAL DEVICE
**** FILE DSK:GUEST4;SKEF NEWAT, 79-50 (199285) AFTER WLRW:
2)	TNX,[	hrrz	b, b		; address of file block pointer
2)		hrrz	b, (b)		; address of file block
2)		hrrz	b, (b)		; address of filename string
2)		push p,l ? push p,r	; save good old l & r
2)	wlrwn0:	move	l,(b)		; get the word
2)		wlrwwd	l		; write it out
2)		aos	b
2)		ldb	r, [350700,,l]	; see if first byte was 0
2)		jumpe	r, wlrwn1	; finish up if so
2)		ldb	r, [260700,,l]	; how about 2nd?
2)		jumpe	r, wlrwn1
2)		ldb	r, [170700,,l]	; etc.
2)		jump¸¢y,A˛˚9w›1
2)		ldb	r, [100700,,l]
2)	Ò:∫Ì·e	r, wlrwn1
2)		ldb	r, [010700,,l]
2)		jumpe	r, wlrwn1
2)		jrst	wlrwn0		; go for next word of file name
2)	wlrwn1:	setz	l,		; write out a zero word
2)		wlrwwd	l
2)		pop p,r ? pop ˛6	wÙ≤ÛÈ˝¸≤†œood old r & l
2)		jrst	wlrwss		; go down to switch setting writing outing ing
2)	];TNX
2)	NOTNX,	WLRWWD B
2)	NOCMU,[				;UNDER CMU, USE THE SPECIFIED DEVICE, NOT THE REAL DEVICE
***************

**** FILE DSK:SYSEN1;@ 695, 84-65 (212813) AFTER WLRW:
1)		WLRWWI R,LR.PSW		;SAVE ALL SWITCH SETTINGS.
1)		WLRW˙ÚPLY-14.	Ò.÷±iı»$ŒAL.H.
**** FILE DSK:GUEST4;SKEF NEWAT, 79-88 (200355) AFTER wlrwn1:
2)	WLRWSS:	WLRWWI R,LR.PSW		;SAVE ALL SWITCH SETTINGS.
2)		WLRWWI L,-14.		;-14. IN L.H.
***************

**** FILE DSK:SYSEN1;@ 695, 86-24 (216834) AFTER CPRF:
1)		 JRST [	CAIE D,DEVIXG	;IT PROBABLY CONTAINS XGP COMMANDS WHOSE LOSS WOULD SCREW.
1)			 CAIN D,DEVCGP
1)			  SETZM (B)
1)			JRST .+1]
1)	];ITSXGP
**** FILE DSK:GUEST4;SKEF NEWAT, 81-24 (204383) AFTER CPRF:
2)		 CAIE D,DEVIXG		;IT PROBABLY CONTAINS XGP COMMANDS WHOSE LOSS WOULD SCREW.
2)		  CAIA
2)		   SETZM (B)
2)	];ITSXGP
***************

**** FILE DSK:SYSEN1;@ 695, 143-14 (316870) AFTER 2OCLS:
1)	; This is also set up to do the same for the Florida Data Systems OSP-130
1)	˘€‡Ó√¸ô|,∑
**** FILE DSK:GUEST4;SKEF NEWAT, 138-14 (304391) AFTER 2OCLS:
2)	; This is also set up to do the same for the Sanders S700 Variflex
2)	NoAnadex,[
***************

**** FILE DSK:SYSEN1;@ 695, 143-19 (317052) AFTER 2OCLS:
1)	IFN ANAFLG!FLAFLG,[
1)		MOVE	B,DEVICE
**** FILE DSK:GUEST4;SKEF NEWAT, 138-19 (304566) AFTER 2OCLS:
2)	IFN ANAFLG!VFXFLG,[
2)		MOVE	B,DEVICE
***************

**** FILE DSK:SYSEN1;@ 695, 143-24 (317165) AFTER 2OCLS:
1)		CAIN	B,DEVFLA		; skip if not Florida OSP-130
1)		 pushj  p,CRLOUT
**** FILE DSK:GUEST4;SKEF NEWAT, 138-24 (304679) AFTER 2OCLS:
2)		CAIN	B,DEVVFX		; skip if not Sanders Variflex
2)		 pushj  p,CRLOUT
***************

**** FILE DSK:SYSEN1;@ 695, 144-61 (319863) AFTER DEVPDO:
1)	DEVANA::	0
1)	DEVCGP::	0
1)	DEVFLA::	0
1)	DEVMAX::OFFSET 0
1)	];ITS
1)	CMU, 2QUEUE:	POPJ P,
1)	T10, 2QUEUE:	POPJ P,
**** FILE DSK:GUEST4;SKEF NEWAT, 139-61 (307378) AFTER DEVPDO:
2)	DEVANA:: 	0
2)	DEVVFX:: 	0
2)	DEVMAX::OFFSET 0
2)	];ITS
2)	;CMU, 2QUEUE:	POPJ P,		; screwing assembly with SITE==CMU20FLG!
2)	T10, 2QUEUE:	POPJ P,
***************

**** FILE DSK:SYSEN1;@ 695, 145-43 (321133) AFTER DEVPDO:
1)	DEVANA::	0
1)	DEVCGP::	0
1)	DEVFLA::	0
**** FILE DSK:GUEST4;SKEF NEWAT, 140-43 (308681) AFTER DEVPDO:
2)	DEVANA:: 	0
2)	DEVFLA::	0
***************

**** FILE DSK:SYSEN1;@ 695, 147-6 (323316) AFTER 2LOOPD:
1)	REPEAT 4,[
**** FILE DSK:GUEST4;SKEF NEWAT, 142-6 (310853) AFTER 2LOOPD:
2)	TNX,[	skipn	b, outfil	; skip if outfil was given
2)		 jrst	 2loopo
2)		movem	b, f.osnm(a)	; make that the filename here
2)		jrst	2loopz		; go and open it up
2)	2loopo:	push	p, a		; save a
2)		skipe	a, ofile	; close output file if one is open
2)		 call	 2oclsq
2)		move	a, (p)		; look at file block again
2)		move	b, f.isnm(a)	; get input name
2)		movem	b, f.osnm(a)	; copy to output name
2)		movei	a, f.osnm(a)	; move to output filename
2)		skipe	b, fntspc	; grab default extension in b
2)		 skipl	 b, device
2)		  cail	  b, devmax
2)		   .value
2)		move	b, optfn2(b)
2)		call	defext		; defaultify extension of output name
2)	Ò;wˆÀ	a, (˛
Dâw restore pointer to ˛˙7ÏÀ fileÙ∂o«k
2)		movem	a, ofile
2)	2loopz:
2)	];TNX
2)	NOTNX,[
2)	REPEAT 4,[
***************

**** FILE DSK:SYSEN1;@ 695, 147-48 (324663) AFTER 2LOOPO:
1)	ITS,	MOVE H,[SIXBIT/OUTPUT/]
**** FILE DSK:GUEST4;SKEF NEWAT, 142-70 (312887) AFTER 2LOOPO:
2)	];NOTNX
2)	ITS,	MOVE H,[SIXBIT/OUTPUT/]
***************

**** FILE DSK:SYSEN1;@ 695, 147-69 (325124) AFTER DEVANA:
1)	DEVCGP::2FNTIX		; Like ITS XGP
1)	DEVFLA::FLAINI
1)	DEVMAX::OFFSET 0
**** FILE DSK:GUEST4;SKEF NEWAT, 142-92 (313357) AFTER DEVANA:
2)	DEVVFX::VFXINI
2)	DEVMAX::OFFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 152-2 (329558) AFTER ADAINI:
1)	SUBTTL Assorted Florida Data OSP-130 code
1)	NOFLO˙RbAYFLAINI==:CPOPJ
1)	FLORIDA,[
1)	FLAINI:
1)		POPJ	P,
1)	];FLORIDA
1)	SUBTTL	PASS 2 INPUT FILE OPEN ROUTINES
**** FILE DSK:GUEST4;SKEF NEWAT, 147-1 (317757) AFTER ADAINI:
2)	SUBTTL Assorted Sanders Variflex
2)	NOVARIFLEX,FLAINI==:CPOPJ
2)	VARIFLEX,[
2)	VFXINI:
2)	; first of all, compute number of lines per page and establish all the
2)	; vertical formatting parameters
2)		move	A,PGLDOT+DEVVFX	; get paper height
2)		movei	B,[ASCIZ /FL/]
2)		pushj	P,RCLNUM	; output numeric RCL
2)		movei	B,[ASCIZ /VMON/]
2)		pushj	P,OUTRCL	; turn on vertical forms control
2)		move	B,MARG.T	; get top marg in mils
2)		imul	B,DOTPIV+DEVVFX	; compute in 1K VEPs
2)		addi	B,500.		; round
2)		idivi	B,1000.		; convert to VEPs
2)		push	P,A
2)		push	P,B
2)		move	A,B		; send it out
2)		movei	B,[ASCIZ /TM/]
2)		pushj	P,RCLNUM
2)		pop	P,B
2)		pop	P,A
2)		sub	A,B		; deduct top margin
2)		move	B,MARG.B	; get bottom margin in mils
2)		imul	B,DOTPIV+DEVVFX	; compute in ˆ2–VãPs
2)		addi	B,500.		; round
2)		idivi	B,1000.		; convert to VEPs
2)		push	P,A
2)		push	P,B
2)		move	A,B
2)		movei	B,[ASCIZ /BM/]
2)		pushj	P,RCLNUM
2)		pop	P,B
2)		pop	P,A
2)		sub	A,B		; deduct b˝˝:o€ÙpÚœin
2)		idivi	A,48.		; divide by Veps/Line
2)		skipn	EPAGEL		; did user give explicit page length?
2)		 movem	A,PAGEL		; no, store this value
2)	; Now output the horizontal parameters, and update the LNL parameter
2)		
2)		move	A,LNLDOT+DEVVFX	; get paper width
2)		movei	B,[ASCIZ /FW/]
2)		pushj	P,RCLNUM	; output numeric RCL
2)		move	B,MARG.L	; get left marg in mils
2)		add	B,MARG.H	; add hole margin in mils
2)		imul	B,DOTPIH+¯ëkVçX	; compute in 1K HEPs
2)		addi	B,500.		; round
2)		idivi	B,1000.		; convert to HEPs
2)		push	P,A
2)		push	P,B
2)		move	A,B		; send it out
2)		movei	B,[ASCIZ /LM/]
2)		pushj	P,RCLNUM
2)		pop	P,B
2)		pop	P,A
2)	Ò<˙‚A,B		; deduct left margin
2)	Ò;wˆÀÒ0ñMÉRG.R	; get right mar¸˙w ”n mils
2)		imul	B,DOTPIH+DEVVFX	; compute in 1K HEPs
2)		addi	B,500.		; round
2)		idivi	B,1000.		; convert to HEPs
2)		push	P,A
2)		push	P,B
2)		move	A,B
2)		movei	B,[ASCIZ /RM/]
2)		pushj	P,R¯s'Uõ
2)		pop	P,B
2)		pop	P,A
2)		sub	A,B		; deduct right margin
2)		imuli	A,16.		; multiply by Chars/In (Using GOUS1617)
2)		idiv	A,DOTPIH+DEVVFX	; divide by Heps/In
2)		skipn	ELINEL		; did user give /W?
2)		movem	A,LINEL	Ò.–nﬂıà9Ùﬂre as chars/line
2)	; now, finally select the font
2)		movei	B,[ASCIZ /AF0,GOUS1617/]
2)		pushj	P,outRCL
2)		movei	B,[ASCIZ /SF0/]
2)		pushj	P,outRCL
2)		pushj	P,2INIT		; re-initialize pass 2 values!
2)	Ò4'–ï	P,
2)	; OUTRCL --- write an unparamterized RCL command
2)	;	B - pointer to ASCIZ string
2)	˜h¡A- preserved
2)	OUTRCL:	push	P,A
2)		push	P,B
2)		2patCH	"!
2)		pop	P,B
2)		pushj	P,ASCRCL
2)		2patCH	"!
2)		pop	P,A
2)		popj	P,
2)	; RCLNUM --- write an RCLÙ˜Ì€and with a numeric argument
2)	;	B - pointer to ASCIZ string
2)	;	A - numeric value
2)	;	  -Ù9eÁerved
2)	RCLNUM: push	P,A
2)		push	P,B
2)		2patCH	"!
2)		pop	P,B
2)		pushj	P,ASCRCL
2)		move	A,(P)
2)		pushj	P,000X		; write out  number
2)		2patCH	"!
2)		pop	P,A
2)		popj	P,
2)	];VARIFLEX
2)	SUBTTL	PASS 2 INPUT FILE OPEN ROUTINES
***************

**** FILE DSK:SYSEN1;@ 695, 154-9 (332027) AFTER 2RDAHD:
1)	TF6TOA:	PUSH P,B
1)		MOVE B,[440700ıã*FìLNM]
1)		SETZM TFILNM			; Ensure string initially empty
1)		CALL TF6TOB
**** FILE DSK:GUEST4;SKEF NEWAT, 149-9 (322792) AFTER 2RDAHD:
2)	; If the left hand side of the SNAME is -1, the right hand side is the address
2)	; of a long file name.  In this case, we just copy the string into TFILNM and
2)	; everyone should be happy.
2)	TF6TOA:	PUSH P,B
2)		hlrz b,(a)		; check SNAME
2)	Ò8ÈÀ b,440700;real quick hack for testing... would be ı¨W.]
2)		 jrst tf6to0
2)		push p,a		; copy long file name into TFILNM
2)		push p,c
2)		hrrz a,(a)
2)		hrli a,440700
2)		move b,[440700,,tfilnm]
2)		ildb c,a
2)		idpb c,b
2)		jumpn c,.-2
2)		pop p,c
2)		pop p,a
2)		pop p,b
2)		ret
2)	tf6to0:	STRT [asciz /Old format file block encountered.  TNX @ Bug./]
2)		MOVE B,[440700,,TFILNM]
2)		push p,B		; insure string is initially empty because
2)					; of various problems with non-robust code
2)					; around JSYSes
2)		setz B,
2)		IDPB B,(P)
2)		pop  P,B
2)		MOVE B,[440700,,TFILNM]
2)		CALL TF6TOB
***************

**** FILE DSK:SYSEN1;@ 695, 154-30 (332475) AFTER TF6TOB:
1)	10X,		MOVEI C,"< ? IDPB C,A
1)			MOVE C,A	; Preserve byte pointer in case of failure
1)			DIRST		; T20 adds punctuation by itself.
1)			 ERCAL [MOVE A,C	; If fail, restore old byte pointer
1)				POPJ P,]
1)	10X,		MOVEI C,"> ? IDPB C,A
1)			JRS˙à+c]
**** FILE DSK:GUEST4;SKEF NEWAT, 149-56 (323925) AFTER TF6TOB:
2)	10X,		MOVEI C,"< 
2)	10X,		IDPB C,A
2)			move C,A	; preserve byte pointer
2)	Ò"bI•˙uâw T20 adds punctuatio˝»1yA˝=9ÂŸf.
2)			 ercal [ move A,C	; if fail, restore old byte pointer
2)			         popj P,]
2)					; ...otherwise, DIRST has updated the pointer
2)	ˆ,,,Ò3g÷ãI C,"> 
2)	10X,		IDPB C,A
2)			JRST .+1]
***************

**** FILE DSK:SYSEN1;@ 695, 154-74 (333357) AFTER LBPAS1:
1)	];TNX
**** FILE DSK:GUEST4;SKEF NEWAT, 149-105 (324864) AFTER LBPAS1:
2)	;;; DefExt defaults the extension of a file name i˝»:hÀ file bloc˝h8o”nted to
2)	;;; by A to the string pointed to by B.
2)	defext:	push p,c ? push p,d ? push p,h ; save these things
2)		push	p, b		; save b on top
2)		move	b, 0(a)		; copy file name
2)		move	h, namnxt
2)		hrli	h, 440700
2)		movem	h, 0(a)		; replace file name with the one we're making
2)	defex1:	ildb	c, b
2)		jumpe	c, ¸ôseÒ2	; end of fileÙ∞ÌÀ 1 if end of string
2)		cain	c, ".		; or we hit a dot
2)		jrst	defex2
2)		idpb	c, h
2)		hrrz	d, h		; see if we've run out of filename space
2)		caige	d, namend
2)		 jrst	 defex1		; if not, keep looping
2)		jrst	fnsgon		; all gone
2)	defex2:	movei	c, ".		; throw a dot down
2)		idpb	c, h
2)		pop	p, b		; get ext¸ªπÈﬂn
2)	defex3:	ildb	c, b
2)		idpb	c, h
2)		jumpe	c, defex4
2)		hrrz	d, h		; see if we've run out of filename space
2)		caige	d, namend
2)		 jrst	 defex3		; nah, keep copying
2)		jrst	fnsgon		; all gone
2)	defex4:	aos	h		; save new next filename pointer
2)		hrrm	h, namnxt
2)		pop p,h ? pop p,d ? pop p,c
2)		ret
2)	;;; GetExt returns aÙºÙÀÙ7È›ter to the file's extensi˝˚êi›Ùñ ﬂr zero.
2)	getext:	push p,c ? push p,d	; save c & d
2)		move	c, 0(a)		; get pointer to filename
2)	getex1:	ildb	d, c
2)		jumpe	d, getex2	; return zero if end of string
2)		caie	d, ".		; return pointer if we've hit a dot
2)		 jrst	 getex1		; else keep on looping
2)		move	b, c
2)		pop p,d ? pop p,c	; restore c & d
2)		ret
2)	getexˆNÑﬂp p,d ? pop p,c	; re˛}7ÚÀ c & d
2)		setz	b,
2)		ret
2)	;;; FNSGon tells the luser that we're out of filename space, and dies.
2)	fnsgon:	STRT	[ASCIZ /Out of filename space!
2)	/]
2)		jrst	errdie
2)	];TNX
***************

**** FILE DSK:SYSEN1;@ 695, 162-71 (349333) AFTER PRSD4:
1)		 CAIL L,EFILES		;PRESS FILE HEADER PAGE.
1)		  JRST PRSD5
1)		MOVE CH,F.OFN1(L)	;BUT, IF THIS OUTPUT FILE CORRESPONDS TO AN INPUT FILE
1)		CAMN CH,F.RFN1(L)	;WHICH HAS THE SAME FN1 AS THE OUTPUT FILE,
**** FILE DSK:GUEST4;SKEF NEWAT, 157-71 (342393) AFTER PRSD4:
2)	TNX,	 NOP
2)	NOTNX,[	 CAIL L,EFILES		;PRESS FILE HEADER PAGE.
2)		  JRST PRSD5
2)	];NOTNX
2)	TNX,[	move	b, f.osnm(l)	; pointer to file name
2)		call	ascout		; shove it out
2)	˚ÆÍN±
2)	NOTNXıñƒÕü˙—PCë,F.OFN1(L)	;BUTıà$∆ATHIS ˘ıjP´T FILE COR˙Qi–üNDS TO AN ˘3®U©Ù§Ãã
2)		CAMN CH,Fı‘£Nc(L)	;˙Ú$√ëÙ ”ATHE SAME FN1 ASÙ$EA˘ıjP´˙à#IôE,
***************

**** FILE DSK:SYSEN1;@ 695, 162-78 (349705) AFTER PRSD5:
1)		POP P,A
**** FILE DSK:GUEST4;SKEF NEWAT, 157-83 (342884) AFTER PRSD5:
2)	];NOTNX
2)		POP P,A
***************

**** FILE DSK:SYSEN1;@ 695, 181-26 (387191) AFTER SLURP3:
1)	IFN ANAFLG!FLAFLG,[
1)	SLGLEQ:	PUSH	P,B		.SEE 2MXCRF ; to understand PUSH
**** FILE DSK:GUEST4;SKEF NEWAT, 176-25 (380377) AFTER SLURP3:
2)	IFN ANAFLG!VFXFLG,[
2)	SLGLEQ:	PUSH	P,B		.SEE 2MXCRF ˜h:oA˛ª≤eÂ˛}0Ó…Ù*”ë
***************

**** FILE DSK:SYSEN1;@ 695, 181-48 (387767) AFTER SLGNC1:
1)	FLORIDA,[
1)		CAIE	B,DEVFLA		; skip if OSP-130
1)		 JRST	SLGNC2		Ò.–sÀe if some ˝˝4eÂ type, or done
**** FILE DSK:GUEST4;SKEF NEWAT, 176-47 (380953) AFTER SLGNC1:
2)	VARIFLEX,[
2)		CAIE	B,DEVVFX		; skip if Sanders S700
2)		 JRST	SLGNC2			; see if some other type, or done
***************

**** FILE DSK:SYSEN1;@ 695, 181-53 (387917) AFTER SLGNC1:
1)		MOVEI	CH,33		; underline on
1)		2PUTCH
1)		MOVEI	CH,'E		; <esc>E
1)		2PUTCH
1)		MOVE	CH,0(P)		; get input char back
**** FILE DSK:GUEST4;SKEF NEWAT, 176-52 (381109) AFTER SLGNC1:
2)		movei	B,[ASCIZ /BU/]
2)		pushj	P,OutRCL
2)		MOVE	CH,0(P)		; get input char back
***************

**** FILE DSK:SYSEN1;@ 695, 181-62 (388148) AFTER SLGNC1:
1)		MOVEI	CH,33		; underline off
1)		2PUTCH
1)		MOVEI	CH,'R
1)		2PUTCH
1)		POP	P,CH		; return original
**** FILE DSK:GUEST4;SKEF NEWAT, 176-59 (381308) AFTER SLGNC1:
2)		movei	B,[ASCIZ /EU/]
2)		pushj	P,OutRCL
2)	Ò4'–˙!»	; return ˝¸¥Á”nal
***************

**** FILE DSK:SYSEN1;@ 695, 181-72 (388364) AFTER SLGNC2:
1)	]; ANADEX!FLORIDA
1)	SLLF:	TRZE F,FRLCR
**** FILE DSK:GUEST4;SKEF NEWAT, 176-67 (381501) AFTER SLGNC2:
2)	]; ANADEX!VARIFLEX
2)	SLLF:	TRZE F,FRLCR
***************

**** FILE DSK:SYSEN1;@ 695, 181-118 (389550) AFTER SLTAB:
1)	FLORIDA,[
1)		PUSH	P,B
1)		MOVE	B,DEVICE
1)		CAIN	B,DEVFLA	; skip if not florida OSP-130
1)			JRST [POP P,B
**** FILE DSK:GUEST4;SKEF NEWAT, 176-113 (382688) AFTER SLTAB:
2)	VARIFLEX,[
2)		PUSH	P,B
2)		MOVE	B,DEVICE
2)		CAIN	B,DEVVFX	; skip if not Sanders S700
2)			JRST [POP P,B
***************

**** FILE DSK:SYSEN1;@ 695, 181-125 (389683) AFTER SLTAB:
1)	]; FLORIDA
1)		TLNE F,FLXGP		;IN XGP LISTINGS, MUST CONVERT TABS TO SPACES
**** FILE DSK:GUEST4;SKEF NEWAT, 176-120 (382819) AFTER SLTAB:
2)	]; VARIFLEX
2)		TLNE F,FLXGP		;IN XGP LISTINGS, MUST CONVERT TABS TO SPACES
***************

**** FILE DSK:SYSEN1;@ 695, 181-153 (390317) AFTER SLURP4:
1)		2PUTCH "$
**** FILE DSK:GUEST4;SKEF NEWAT, 176-148 (383454) AFTER SLURP4:
2)	VARIFLEX,[
2)	Ò3g÷ã	B,DEVICE
2)		CAIE	B,DEVVFX
2)		 jrst	 SLURP5
2)		2PUTCH	"=
2)		movei	B,[ASCIZ /NE/]
2)		pushj	P,outRCL
2)		2PATCH	"/
2)		jrst	SLALT1
2)	SLURP5:
2)		];VARIFLEX
2)		2PUTCH "$
***************

**** FILE DSK:SYSEN1;@ 695, 182-2 (390437) AFTER ANADEX,SLA
1)	SLTBL:		JRST SLNUL		;^@
**** FILE DSK:GUEST4;SKEF NEWAT, 176-164 (383733) AFTER ANADEX,SLA
2)	SLVFX:
2)	VARIF˘ël,∑
2)		move	B,DEVICE
2)		caie	B,DEVVFX
2)		 jrst	SLURP1		; nothing special if not Variflex
2)		movei	B,[ASCIZ /IC/]
2)		pushj	P,OutRCL	; insert it
2)	];VARIFLEX
2)	NOVARIFLEX,[
2)		2PUTCH	"!
2)	];NOVARIFLEX
2)		movei	CH,'!
2)		aojaÒ0·¨QH)
2)	SLTBL:		JRST SLNUL		;^@
***************

**** FILE DSK:SYSEN1;@ 695, 182-14 (390705) AFTER SLTBL:
1)	IFE ANAFLG!FLAFLG,[
1)	REPEAT 4,	JRST SLCTL		;^\-^_
1)	];ANAFLG!FLAFLG
1)	IFN ANAFLG!FLAFLG,[
1)			JRST	SLGLEQ		;^\ - leq [
**** FILE DSK:GUEST4;SKEF NEWAT, 177-14 (384238) AFTER SLTBL:
2)	IFE ANAFLG!VFXFLG,[
2)	REPEAT 4,	JRST SLCTL		;^\-^_
2)	];ANAFLG!VFXFLG
2)	IFN ANAFLG!VFXFLG,[
2)			JRST	SLGLEQ		;^\ - leq [
***************

**** FILE DSK:SYSEN1;@ 695, 182-21 (390878) AFTER SLTBL:
1)	];IFN ANAFLG!FLAFLG
1)			TRO F,FRLTAB		;SPACE
1)	REPEAT 14.,	TRZ F,FRLTAB		;! " # $ % & ' ( ) * + , - .
1)			JRST SLSLSH		;/
**** FILE DSK:GUEST4;SKEF NEWAT, 177-21 (384411) AFTER ˙s*Bô:
2)	];IFN ANAFLG!VFXFLG
2)			TROÙñF•LTAB		;SPACE
2)	IFE VFXFLG,[
2)			TRZ F,FRLTAB		;!
2)	]
2)	IFN VFXFLG,[
2)			jrst	SLV¯÷âw!
2)	]
2)	REPEAT 13.,	TRZ F,FRLTAB		;" # $ % & ' ( ) * + , - .
2)			JRST SLSLSH		;/
***************

**** FILE DSK:SYSEN1;@ 695, 196-26 (411285) AFTER SIXOUT:
1)	;OUTPUT ASCIZ STRING POINTED TO BY ADDRESS IN B.
**** FILE DSK:GUEST4;SKEF NEWAT, 191-26 (404888) AFTER SIXOUT:
2)	VARIFLEX,[
2)	; OUTPUT ASCIZ STRING POINTED TO BY ADDRESS IN B.
2)	; DOE˙h'O©ÙhDÉTE CC OR O˙µ+P]  CRLF'S M¯6PBã INCLUDED.
2)	;
2)	ASCRCL:	HRLI	B,440700
2)	ASCRC1:	ILDB	CH,B
2)		JUMPE	CH,CPOPJ
2)		2PATCH
2)		jrst	ASCRC1
2)	]; VARIFLEX
2)	;OUTPUT ASCIZ STRING POINTED TO BY ADDRESS IN B.
***************

**** FILE DSK:SYSEN1;@ 695, 197-53 (414120) AFTER FILOU2:
1)		MOVE CH,A		; Save BP in case of error
1)		DIRST			; Dir # is in B
1)		 ERCAL [MOVE A,CH	; Error, restore BP
1)			POPJ P,]
1)	ˆ,,,MOVEI CH,"˜»†ì¯î! áH,A
**** FILE DSK:GUEST4;SKEF NEWAT, 192-53 (407943) AFTER FILOU2:
2)		move	ch,A
2)		DIRST			; Dir # is in B
2)		  ercal [move A,CH	; in case of error, A was destroyed
2)			 popj P,]
2)	10X,	MOVEI CH,"> ? IDPB CH,A
***************

**** FILE DSK:SYSEN1;@ 695, 197-157 (416219) AFTER ITS,FNTOUT
1)	NOITS,[
1)	IFN <.SITE 0,>-<SIXBIT /MIT-XX/>,FNTOUT==:FILOUT
1)	.ELSE [
1)	;Print an ITS-style file name on a non-ITS system (for XGP purposes).
1)	; Assumes directory is FONTS.  MIT-XX
1)	;is the on˝ûPm√¸z4ÓÀÙ4aÈ shou˝ôuÁe this, mo˛}l”kely.
**** FILE DSK:GUEST4;SKEF NEWAT, 192-157 (410032) AFTER ITS,FNTOUT
2)	SAI,FNTOUT==:FILOUT
2)	NOITS,[
2)	NOSAI,[
2)	;Print an ITS-style file name on a non-ITS system (for XGP purposes).
2)	˜p˙ÚÂ¸ª∫lÛ onlyÙ˜Ú◊˛h3oÂÙ∞Y and ¸<˘ı€¸º–d”rectory is FONTS.  MIT-XX
2)	;is t˝Po›ly machineÙ4aÈ shou˝ôuÁe thi˛kmﬂ˛}l”kely.
***************

**** FILE DSK:SYSEN1;@ 695, 200-23 (420801) AFTER BEGUN2:
1)	FLORIDA,[
1)		MOVE	B,DEVICE
1)		CAIE	B,DEVFLA
1)		   JRST  BEGUN3
1)		2PATCH  33
1)		2PATCH  "E
1)		POPJ	P,
1)	BEGUN3:
1)	];FLORIDA
1)		TLNN F,FLXGP
**** FILE DSK:GUEST4;SKEF NEWAT, 195-23 (414618) AFTER BEGUN2:
2)	VARIFLEX,[
2)		MOVE	B,DEVICE
2)		CAIE	B,DEVVFX
2)		   JRST  BEGUN3
2)		2PATCH  "!
2)		2PATCH  "B
2)	Ò,®A©¯r¢´
2)		2PAT¯r E!
2)		POPJ	P,
2)	BEGUN3:
2)	];VARIFLEX
2)		TLNN F,FLXGP
***************

**** FILE DSK:SYSEN1;@ 695, 200-58 (421286) AFTER ENDUN1:
1)	FLORIDA,[
1)		MOVE	B,DEVICE
1)		CAIE	B,DEVFLA
1)		 JRST	ENDUN2
1)		2PATCH	33
1)		2PATCH	"R
1)		POPJ	P,
1)	ENDUN2:
1)	];FLORIDA
1)		TLNN F,FLXGP
**** FILE DSK:GUEST4;SKEF NEWAT, 195-60 (415130) AFTER ENDUN1:
2)	VARIFLEX,[
2)		MOVE	B,DEVICE
2)		CAIE	B,DEVVFX
2)		 JRST	ENDUN2
2)		2PATCH	"!
2)		2PATCH	"E
2)		2PATCH	"U
2)		2PATCH	"!
2)		POPJ	P,
2)	ENDUN2:
2)	];VARIFLEX
2)		TLNN F,FLXGP
***************

**** FILE DSK:SYSEN1;@ 695, 203-22 (427429) AFTER DEVANA:
1)	DEVCGP::[ASCIZ /Canon "XGP"/]
1)	DEVFLA::[ASCIZ /Florida/]
1)	DEVMAX::OFFSET 0
**** FILE DSK:GUEST4;SKEF NEWAT, 198-22 (421299) AFTER DEVANA:
2)	DEVVFX::[ASCIZ /Variflex/]
2)	DEVMAX::OFFSET 0
***************

**** FILE DSK:SYSEN1;@ 695, 205-99 (431820) AFTER LRPRIN:
1)		PUSH P,F.OFN2(L)
1)		MOVE B,LRCFN2
**** FILE DSK:GUEST4;SKEF NEWAT, 200-99 (425660) AFTER LRPRIN:
2)	NOTNX,[	PUSH P,F.OFN2(L)
2)		MOVE B,LRCFN2
***************

**** FILE DSK:SYSEN1;@ 695, 205-103 (431894) AFTER LRPRIN:
1)		MOVEI B,[ASCIZ/LREC File:  /]
1)		PUSHJ P,ASCOUT
1)		ADDI L,F.OFN1-F.RFN1
1)		PUSHJ P,FILOUM
1)		POP P,F.RFN2(L)
1)		JRST CRLOUT
**** FILE DSK:GUEST4;SKEF NEWAT, 200-103 (425741) AFTER LRPRIN:
2)	];NOTNX
2)		MOVEI B,[ASCIZ/LREC File:  /]
2)		PUSHJ P,ASCOUT
2)	TNX,[	move	b, f.osnm(l)	; get pointer to filename string
2)		call	ascou1		; print that out
2)	];TNX
2)	NOTNX,[	ADDI L,F.OFN1-F.RFN1
2)		PUSHJ P,FILOUM
2)		POP P,F.RFN2(L)
2)	];NOTNX
2)		JRST CRLOUT
***************

**** FILE DSK:SYSEN1;@ 695, 221-73 (464318) AFTER MCRFN6:
1)		ADDI CC,1		;Account for oversize page #.
1)	MCRFN4:	MO˙—PAYB
**** FILE DSK:GUEST4;SKEF NEWAT, 216-73 (458287) AFTER MCRFN6:
2)	MCRFN4:	MOVE A,B
***************

**** FILE DSK:SYSEN1;@ 695, 229-57 (471499) AFTER IMPTOP:
**** FILE DSK:GUEST4;SKEF NEWAT, 224-58 (465427) AFTER IMPTOP:
2)	;;; Things that need to be done before this thing will really fly:
2)	;;;
2)	;;; Maybe add some sort of reclaimation of filename space.
***************
