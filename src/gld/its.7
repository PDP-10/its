.TITLE ITS: DATAPOINT SIMULATOR AND FILE TRANSFERER
.SBTTL DATA

.INSRT SITS;SITMAC >
.INSRT SITS;SITSS SYMS

INVSTK:	.WORD 0
.MACRO	INVOKI A1,A2,A3,A4
	MOV P,INVSTK
	INVOK A1,A2,A3,A4
	BNE .+6
	MOV INVSTK,P
.ENDM

	.BLKW 40
PDL2:
	.BLKW 40
PDL:

.INSRT GLD;UTILIT >

CRCAP=	0
DATCAP:	.WORD 0
TTYCAP=	2
ITSTTY:	11.
CHARS:	90.
LINES:	35.
QUOTFL:	.WORD 0
SPEED:	.WORD 27322

.MACRO	DISPCH TABLE,CHAR,RTN
.=TABLE+<CHAR*2>
	RTN
.ENDM


DISTBO:	.REPT 200
	SEND
	.ENDR
	DISPCH DISTBO,35,ESCAPE
	DISPCH DISTBO,200
DISTBC:	.REPT 200
	IGNORE
	.ENDR
	DISPCH DISTBC,'L,LOADER
	DISPCH DISTBC,'Q,QUIT
	DISPCH DISTBC,35,SEND
	DISPCH DISTBC,200

DISTBI:	.REPT 177
	ECHO
	.ENDR
	IGNORE
	DISPCH DISTBI,1,LOADRR
	DISPCH DISTBI,7,FLASH
	DISPCH DISTBI,10,BKSPER
	DISPCH DISTBI,12,LINEFD
	DISPCH DISTBI,13,LINEFD
	DISPCH DISTBI,30,RIGHT
	DISPCH DISTBI,31,LEFT
	DISPCH DISTBI,32,UP
	DISPCH DISTBI,34,HOMEDN
	DISPCH DISTBI,35,HOMEUP
	DISPCH DISTBI,37,ERSEOF
	DISPCH DISTBI,200
.SBTTL INITIALIZATION AND READ/WRITE LOOPS

ITS:	MOV #PDL,P		;INITIALIZE STACK
	CREATE .TTCAP,ITSTTY	;TTY LINK TO PDP10
	IFERR LOSE		;LOSE IF CREATE FAILED
	REST DATCAP		;SAVE CAP NO
	INVOKI DATCAP,#.TTSPD*400,SPEED,#0	;SET ITSTTY TO 4800 B
	INVOKI DATCAP,#.TTMOV*400,#.TIMGI+.TIMGO
	INVOKI #TTYCAP,#.TTBIS*400,#.TIMGI+.TIMGO+.TICTM+.TICVM
	BYTO #TTYCAP,#14	;CLEAR SCREEN
	FORK #READ		;START PROCESS TO READ FROM 10

WRITE:	BYTI #TTYCAP		;READ CHAR FROM KEYBOARD
	REST A			;PUT IT IN A
	BIC #177600,A		;JUST IN CASE
	ASL A			;BYTE>WORD
	TST QUOTFL		;QUOTED?
	BEQ 1$			;IF NOT,PROCEED
	JSR PC,SEND		;OTHERWISE,SEND THE CHAR
	CLR QUOTFL		; AND CLEAR THE QUOTE
	BR WRITE
1$:	JSR PC,@DISTBO(A)	;SCREEN AND SEND
	BR WRITE

READ:	MOV #PDL2,P		;INITIALIZE STACK
	BYTI DATCAP		;READ CHAR FROM 10
	REST A			;CHAR IN A
	BIC #177600,A		;JUST IN CASE
	ASL A			;BYTE>WORD
	JSR PC,@DISTBI(A)	;DISPATCH TO CHAR.EMULATORS
	BR READ
LOSE:	TYPE #TTYCAP,#SIGH	;YOU KNOW HOW IT IS
	BPT

SIGH:	.ASCII /SORRY, LINE BUSY. TRY LATER./
	.BYTE 15,0
	.EVEN

.SBTTL DISPATCH ROUTINES

SEND:	ASR A			;READJUST
	BYTO DATCAP,A		;SEND IT OFF
	RTS PC

ESCAPE:	BYTI #TTYCAP		;READ COMMAND CHAR
	REST A
	BIC #177400,A		;JUST IN CASE
	ASL A
	JSR PC,@DISTBC(A)		;EXECUTE COMMAND
	RTS PC

QUIT:	BPT
	RTS PC

QUOTE:	DEC QUOTFL		;QUOTE NEXT CHAR
	RTS PC

FLASH:	INVOKI #TTYCAP,#.TVREV*400	;REVERSE SCREEN COLORS
	SLEEP #0,#20
	INVOKI #TTYCAP,#.TVREV*400	; AND BACK AGAIN
	RTS PC				;(THIS IS IN LIEU OF BELL)
 
ECHO:	ASR A				;READJUST
	BYTO #TTYCAP,A			;JUST SPIT OUT
	RTS PC

IGNORE:	RTS PC

BKSPER:	BYTO #TTYCAP,#37		;SITS' BACKSPACE/ERASE
	RTS PC

HOMEDN:	INVOKI #TTYCAP,#<.TVSET+.PRWRT>*400,#34.,#0	;CURSOR TO LAST LINE
	RTS PC

HOMEUP:	INVOKI #TTYCAP,#<.TVSET+.PRWRT>*400,#0,#0	;CURSOR TO TOP
	RTS PC

ERSEOF:	INVOKI #TTYCAP,#.TVSET*400,#0,#0	;READ CURSOR PLACE
	REST A			;CURRENT TVLINE
	REST B			;CURSOR POSITION
	BYTO #TTYCAP,#36	;CLEAR EOL
	MOV #35.,C
	SUB A,C			;# REMAINING LINES TO ERASE
	BLE 2$			;MAKE SURE THAT'S POSITIVE
1$:	BYTO #TTYCAP,#15	;GO TO NEXT LINE
	BYTO #TTYCAP,#12
	BYTO #TTYCAP,#36	;CLEAR EOL
	SOB C,1$		;AND ALL THE REST
	INVOKI #TTYCAP,#<.TVSET+.PRWRT>*400,A,B	;RESTORE CURSOR
2$:	RTS PC

LINEFD:	INVOKI #TTYCAP,#.TVSET*400,#0,#0	;READ CURSOR POSITION
	REST A			;CURRENT LINE#
	REST B			;CURSOR POSITION
	INC A			;NEXT LINE
	INVOKI #TTYCAP,#<.TVSET+.PRWRT>*400,A,B	;NEW CURSOS POSITION
	RTS PC

RIGHT:	INVOKI #TTYCAP,#.TVSET*400,#0,#0	;READ CURSOR POSITION
	REST A			;CURRENT LINE#
	REST B			;CURSOR POSITION
	INC B			;NEXT SPACE
	INVOKI #TTYCAP,#<.TVSET+.PRWRT>*400,A,B	;NEW POSITION
	RTS PC

LEFT:	INVOKI #TTYCAP,#.TVSET*400,#0,#0	;READ CURSOR POSITION
	REST A			;CURRENT LINE
	REST B			;CURSOR POSITION
	DEC B			;BACK ONE SPACE
	INVOKI #TTYCAP,#<.TVSET*+.PRWRT>*400,A,B	;NEW POSITION
	RTS PC

UP:	INVOKI #TTYCAP,#.TVSET*400,#0,#0	;READ CURSOR POSITION
	REST A			;CURRENT LINE
	REST B			;CURSOR POSITION
	DEC A			;UP ONE LINE
	INVOKI #TTYCAP,#<.TVSET+.PRWRT>*400,A,B	;NEW POSITION
	RTS PC
.SBTTL LOADER

FILCAP:	.WORD 0
DELCAP:	.WORD 0
FILNAM:	.BLKW 200

LOADER:	INVOKI #TTYCAP,#.TTMOV*400,#.TLIPM+.TIMGI+.TICVM+.TIRST+.TIECM
			;LINE INPUT,EDITS,RUBOUTS,CAPITALIZE,RESET
FILREQ:	TYPE #TTYCAP,#DUMPAS		;ASK FOR FILENAME TO CREATE
	MOV #FILNAM,A		;POINTER

L1:	BYTI #TTYCAP		;GET A CHAR
	MOVB (P)+,(A)+		;PUT IT IN BUFFER
	CMPB -1(A),#35		;ESCAPE?
	BNE L11
	JMP GOHOME
L11:	CMPB -1(A),#15		;<LF>?
	BNE L1			;IF NOT,KEEP GOING

	MOV A,B
	SUB #FILNAM,B		;COUNTER
	MOV A,C			;SAVE A COPY OF STRING PTR
	MOV B,D			; AND A COPY OF THE COUNTER

L2:	CMPB -(C),#';		;A ; ?
	BEQ CRROOT		;IF SO,COPY CAP TO ROOT DIR
	SOB D,L2		;IF NOT,LOOK AGAIN

	INVOK #4,#.CPYCP,#0,#-1	;IF NO ; WAS FOUND,CPY DFLT DIR CAP
	REST FILCAP
	MOV C,F			;ALSO,SAVE PTR TO DIR SPECIFICATION
	JMP CRFIL		; AND PROCEED TO CREATE THE FILE

CRROOT:	MOV C,F
	INC F			;SAVE PTR TO DIR SPECIFICATION
	MOVB -(C),E		;GET ROOT CHAR
	CMPB PARSTB(E),#2	;IF VALID,PARSTB ENTRY IS 2
	BNE CR1			;IF SO,PROCEED
	TYPE #TTYCAP,DLOSE	;IF NOT,ANNOUNCE LOSS
	JMP FILREQ		;AND TRY AGAIN

CR1:	SUB #50,E		;TRNSLT ASCII->CAP # OF ROOT DIR
	INVOK C,#.CPYCP,#0,#-1	;COPY ROOT CAP
	REST FILCAP
				;NOW,PROCEED TO CREATE FILE
CRFIL:	MOVB -(A),E		;LOOK AT NEXT TO LAST CHAR
	TSTB PARSTB(E)		;SPECIAL CHAR?
	BNE CR2			;IF NOT,WE'VE GOT A FILNAM CHAR
	SOB B,CRFIL		;IF SO,KEEP LOOKING

	TYPE #TTYCAP,#FLOSE	;WE GET HERE IFF NO FILE WAS NAMED
	JMP FILREQ		;TRY AGAIN

CR2:	DEC B			;ADJUST COUNTER (SINCE LAST SOB SKIPPED)
	CLRB 1(A)		;ZERO CHAR AFTER FILNAM
CR3:	MOVB -(A),E		;NEXT CHAR BACK
	TSTB PARSTB(E)		;SPECIAL?
	BEQ MUTDIR		;IF SO,GO MUTATE A DIRECTORY
	SOB B,CR3		;IF NOT,KEEP LOOKING

	JMP ADDFIL		;IF WE FIND NONE,JUST ADD THE FILE

MUTDIR:	CLRB (A)+		;CLEAR FENCE CHAR,POINT A TO FILNAM
	INVOK FILCAP,#.FAMU,F,#0	;MUTATE TO DIRECTORY NAMED

ADDFIL:	INVOK FILCAP,#.FAAD,A,#0	;ADD FILE TO DIRECTORY
	BNE FILWIN		;IF IT WORKED,PROCEED
	$GERRW			;IF NOT,FIND OUT WHY
	REST			;NOT INTERESTED IN THIS WORD
	CMP (P)+,#.EEAE		;WAS IT CUZ FILE ALREADY EXISTS?
	BEQ AD1			;IF SO,PROCEED
	TYPE #TTYCAP,#FLOSE	;OTHERWISE LOSE
	JMP FILREQ		;AND TRY AGAIN
AD1:	TYPE #TTYCAP,#DELETE	;DELETE FILE?
	BYTI #TTYCAP		;WELL,
	CMPB (P)+,#'Y		; YES OR NO?
	BEQ DELFIL		;YES,DELETE FILE
	JMP FILREQ		;NO,LOSE,TRY AGAIN

DELFIL:	ADD #6,P		;POP PREV. ARGS
	INVOK FILCAP,#.CPYCP,#0,#-1	;COPY DIRECTORY CAP
	REST DELCAP
	INVOK DELCAP,#.FAMU,A,#0	;MUTATE TO OFFENDING FILE
	INVOK DELCAP,#.FADL	;AND DELETE IT
	JMP ADDFIL		;THIS SHOULD WORK NOW


FILWIN:	TYPE DATCAP,#NLOAD	;DO A :NLODER

GOHOME:	INVOKI #TTYCAP,#.TTMOV*400,#.TIMGI+.TIMGO+.TICTM+.TICVM
	RTS PC			;RESTORE PREVIOUS TTY MODE&RETURN


DLOSE:	.ASCII /CAN'T ACCESS DIRECTORY/
	.BYTE 15,0
FLOSE:	.ASCII /CAN'T ACCESS FILE/
	.BYTE 15,0
DUMPAS:	.BYTE 15
	.ASCIZ /DUMP FILE AS:  /
DELETE:	.ASCIZ /FILE EXISTS. DELETE? /
NLOAD:	.ASCII /:NLODER/
	.BYTE 15,0
	.EVEN

PARSTB:	.REPT 200
	.BYTE 1
	.ENDR
.=PARSTB+40
	.BYTE 0
.=PARSTB+11
	.BYTE 0
.=PARSTB+12
	.BYTE 0
.=PARSTB+15
	.BYTE 0
.=PARSTB+'1
	.BYTE 2
.=PARSTB+'2
	.BYTE 2
.=PARSTB+200

.SBTTL LOADRR

LOADRR:	JSR PC,BLCKIN		;READ A BLOCK INTO FILBUF
	BLKO FILCAP,A,#FILBUF	;DUMP IT
	BYTO DATCAP,#4		;ACKNOWLEDGE
	CMP COUNT,#6		;END BLOCK?
	BNE LOADRR		;IF NOT,GET ANOTHER

	BYTO DATCAP,#5		;ASK FOR SYMBOLS
SYMBS:	JSR PC,BLCKIN		; AND GET THEM
	BYTO DATCAP,#4		;ACKNOWLEDGE
	CMP COUNT,#6		;END?
	BEQ LDONE		;IF SO,ALL DONE
	ADD #120000,ADDR	;IF NOT,RELOCATE ADDR
	MOVB (D),B		;ADJUST CHECKSUM
	SUB #240,B
	MOVB B,(D)
	BLKO FILCAP,A,#FILBUF	;WRITE BLOCK INTO FILE
	BR SYMBS		;AND GET THE NEXT ONE

LDONE:	BLKO FILCAP,A,#FILBUF	;WRITE LAST BLOCK OUT
	INVOKI FILCAP,#.DELCP	;DELETE FILE CAP.
	RTS PC

				;READ BLOCK;RETURN NEG. BYTE CNT IN A 
BLCKIN:	MOV #FILBUF,D		;D IS FILBUF POINTER
	CLR F			;INIT F TO BE CHECKSUM
B1:	BYTI DATCAP		;GET A CODED 1 (HOPEFULLY)
	REST A
	SUB #40,A
	CMPB A,#1
	BNE B1			;IF NOT,TRY AGAIN
	BYTI DATCAP		;NEXT BYTE (0)
	REST B
	SUB #40,B
	ASH #6,B
	ADD B,A
	MOV A,(D)+		;STASH THE 0,1
	ADD A,F			;UPDATE CHECKSUM

	JSR PC,WORDIN		;GET COUNT
	MOV A,E			;COUNT IN E
	MOV A,(D)+		;AND INTO FILBUF
	ADD A,F
	SWAB A
	ADD A,F			;UPDATE CHECKSUM
	SUB #4,E		;GOT 4 BYTES ALREADY
BLOOP:	JSR PC,WORDIN		;ANOTHER WORD
	MOVB A,(D)+		;WRITE LO BYTE INTO FILBUF
	ADD A,F			;UPDATE CHECKSUM
	SWAB A			;MAKE NEXT BYTE LOW
	DEC E			;UPDATE COUNT
	BEQ BDONE		;IF NO MORE LEFT,DONE
	MOVB A,(D)+		;2ND BYTE INTO FILBUF
	ADD A,F			;AND INTO CHECKSUM
	SOB E,BLOOP		;IF MORE REMAIN,GET THEM

	JSR PC,WORDIN		;GET CHECKSUM
				;UNLESS ALREADY GOT IT
BDONE:	MOVB A,(D)		;PUT IT IN FILBUF
	ADD A,F
	TSTB F			;SAME AS EXPCTED?
	BEQ FILDMP		;IF SO,DUMPIT
	BYTO DATCAP,#6		;BAD ACKNOWLEDGE
	JMP BLCKIN		;OTHERWISE,TRY AGAIN

FILDMP:	MOV COUNT,A
	INC A			;EXTRA BYTE FOR CHECKSUM
	NEG A			;NEED NEG # OF BYTES TO WRITE
	RTS PC


		;A WORD COMES IN AS FOLLOWS:6 BITS + 40 IN FIRST BYTE,
		;4 BITS + 40 IN 2ND BYTE, AND 6 BITS +40 IN THIRD BYTE.
		;WORDIN ASSEMBLES THIS INTO A WORD IN A
		;A & B ARE CLOBBERED
WORDIN:	BYTI DATCAP		;LOW 6 BITS IN HERE
	REST A
	SUB #40,A
	BYTI DATCAP		;NEXT 4 BITS
	REST B
	SUB #40,B
	ASH #6,B
	ADD B,A
	BYTI DATCAP		;FINAL 6 BITS
	REST B
	SUB #40,B
	ASH #10.,B
	ADD B,A
	RTS PC

FILBUF:	.WORD 0			;STANDARD BLOCK BEGINNING
COUNT:	.WORD 0
ADDR:	.BLKW 1000		;512 WORDS LONG

.END ITS
