.INSRT GLD;MACROS >

.MACRO	TYPE CAP,BEGM
	SAVE <A,B>
	MOV CAP,A
	MOV BEGM,B
	JSR PC,TYPE..
	REST <B,A>
.ENDM

TYPE..:	MOVB (B)+,-(P)
	BEQ TYPND.
	CLRB 1(P)
	SAVE A
	$BYTO
	BR TYPE..
TYPND.:	REST
	RTS PC

;ROOT. IS CALLED WITH PTR TO PATHNAME IN A.
;GETS COPY OF SPECIFIED ROOT DIRECTORY, PUTS # IN B.
;ADVANCES A TO POINT TO BYTE AFTER ;, IF ANY.
;RETURNS WITH Z SET IF NO ROOT WAS SPECIFIED,
;Z & N SET IF BAD ROOT SPECIFIED.
ROOT.:	SAVE C
	MOV A,B

ROOTL.:	MOVB (A)+,C	;1ST CHAR
	MOVB ROOTB.(C),C	;GET INDEX OF ROOT NAMES
	BEQ ROOTL.	;IF FILLER CHAR, GET NEXT
	BMI BADRT.	;IF INVALID 1ST CHAR,LOSE

	ADD #NAMES.,C
RTL2.:	TSTB (C)	;ALL CHARS LOOKED AT?
	BEQ RTDN.
	CMPB (C)+,(A)+	;CHECK NEXT ONE
	BNE BADRT.	;OK?
	BR RTL2.	;YEAH,GO ON

RTDN.:	MOVB 1(C),C	;GET CAP # OF SPECIFIED ROOT
	INVOK C,#.CPYCP,#0,#-1	;COPY CAP OF SPECIFIED ROOT
	REST B
	REST C
	CLN!CLZ
	RTS PC

BADRT.:	TSTB (A)	;ANY MORE?
	BEQ BADDN.
	CMPB (A)+,#';	;SEMICOLON?
	BNE BADRT.

	MOV B,A		;HERE, NO ROOT WAS SPECIFIED
	REST C
	SEZ
	CLN
	RTS PC

BADDN.:	REST C		;HERE, INCORRECT ROOT WAS SPECIFIED
	SEZ!SEN
	RTS PC

ROOTB.:	.REPT 200	;ASCII DISPATCH
	.BYTE -1
	.ENDR
	DISPB ROOTB.,'0,N1.-NAMES.
	DISPB ROOTB.,'1,N2.-NAMES.
	DISPB ROOTB.,'2,N3.-NAMES.
	DISPB ROOTB.,'S,N4.-NAMES.
	DISPB ROOTB.,'A,N5.-NAMES.
	DISPB ROOTB.,'F,N6.-NAMES.
	DISPB ROOTB.,40,0
	DISPB ROOTB.,9,0
	.=ROOTB.+200
NAMES.:	.WORD 0
N1.:	.ASCIZ /;/
	.BYTE DK0CAP
N2.:	.ASCIZ /;/
	.BYTE DK1CAP
N3.:	.ASCIZ /;/
	.BYTE DK2CAP
N4.:	.ASCIZ /ITS0;/
	.BYTE DK0CAP
N5.:	.ASCIZ /I01;/
	.BYTE DK1CAP
N6.:	.ASCIZ /IXED;/
	.BYTE DK2CAP
.EVEN
