; THIS ROUTINE WILL MAINTAIN THE MUDDLE SAV-FIXUP WHICH WILL CONSIST OF TWO
; DIRECTORIES.  ONE WILL HOLD TWO MASTER FILES, ONE FOR FIXUPS AND ONE FOR
; SAVS.  THE OTHER WILL CONTAIN FILES TO BE ADDED TO THE MASTER ONES ALONG
; WITH A COMMAND FILE AND TEMPS CREATED BY THIS MAINTAINER.
; THE MAINTAINER WILL BE ABLE TO ADD AND DELETE FILES TO THE MASTER DIRECTORIES
; AND WILL GARBAGE COLLECT THESE DIRECTORIES FOR SPACE.

.MLLIT==1




; THIS IS THE START OF THE MAINTAINING ROUTINE.  HERE IT WILL ATTEMPT TO OPEN THE
; SCRIPT CHANNEL AND INPUT MAPPING CHANNEL AND INITIALIZE SOME VARIABLES.


START:	MOVE	P,[-PDLNT,,PDS]
	PUSHJ	P,INIT
	PUSHJ	P,%INTST
	MOVNI	A,5*BUFLNT
	MOVEM	A,BUFCNT
	MOVE	A,[440700,,SCBUF]
	MOVEM	A,BUFBYT		; BYTE POINTER FOR BUFFER
	PUSHJ	P,SETDAT		; GET SIXBIT OF DATE
	OPEN	SCHAN,[READ?WRKDIR?[SIXBIT /SCRIPT/]?CDATE]
	SKIPA
	JRST	SCOPEN
	OPEN	SCHAN,[WRITE?WRKDIR?[SIXBIT /SCRIPT/]?CDATE]
	JRST	NOSCRP
	CLOSE	SCHAN,			; CLOSE THE SCRIPT CHANNEL
CNSCRP:	MOVE	A1,CDATE
	PUSHJ	P,OUTINF		; SEND OUT DATE TO SCRIPT FILE
	PUSHJ	P,CRLF			; SEND OUT CARRIAGE RETURN TO SCRIPT FILE
	MOVEI	A1,[ASCIZ /MUDDLE SAV-FIXUP MAINTAINER IN OPERATION/]
	PUSHJ	P,MSGOUT		; SEND OUT OPENING MESSAGE
TREOPN:	OPEN	IMAPCH,[READ?MNDIR?MNFB?<MNFB+1>]
	JRST	CNTOPN
	PUSHJ	P,%CKDMP
	SKIPGE	NOFILE
	JRST	RDDIRS
	SKIPL	CSFILE
	PUSHJ	P,DELDIR

; NOW I WILL GET THE MAIN DIRECTORY IN.

RDDIRS:	MAPIN	IMAPCH,[CWRITP?[0]?MDBLKN]
	CLOSE	IMAPCH,		; CLOSE THE MAPPING CHANNEL

; AND THE FIXUP DIRECTORY

	OPEN	IMAPCH,[READ?MNDIR?MFDB?<MFDB+1>]
	JRST	CNTOPN
	MAPIN	IMAPCH,[CWRITP?[0]?FDBLKN]

; NOW TO DELETE ALL FILES IN THE IN THE FIXUP AND SAV LIBRARIES
; ACCORDING TO THE DELETE FILES SLOTS.

DREOPN:	OPEN	RCHAN,[READC?WRKDIR?[SIXBIT /DELETE/]?[SIXBIT /FIXUPS/]]
	JRST	NOSDEL
	MOVEI	A1,FDBLK		; GET ARGUMENT TO DELETE ROUTINE

; GET IN FIXUP FREE STORAGE BLOCK IN

	STARTB	IMAPCH,[[1]?FSBLKN]
	PUSHJ	P,DELFIL		; DELETE THOSE FILES
	CLOSE	IMAPCH,
	CLOSE	RCHAN,
	DELETE	[WRKDIR?[SIXBIT /DELETE/]?[SIXBIT /FIXUPS/]]
	JFCL

NOSDEL:
FREOPN:	OPEN	RCHAN,[READC?WRKDIR?[SIXBIT /DELETE/]?[SIXBIT /SAVS/]]
	JRST	LOOPLN
	MOVEI	A1,MDBLK		; ARG TO DELETE FILE ROUTINE
	OPEN	IMAPCH,[READ?MNDIR?MNFB?<MNFB+1>]
	JRST	CNTOPN
	STARTB	IMAPCH,[[1]?FSBLKN]
	PUSHJ	P,DELFIL
	CLOSE	RCHAN,
	CLOSE	IMAPCH,
	DELETE	[WRKDIR?[SIXBIT /DELETE/]?[SIXBIT /SAVS/]]
	JFCL

; THIS ROUTINE ATTEMPS OPENING EITHER THE SPLAN OR FPLAN FILES AND
; IF IT SUCCEEDS WILL UPDATE THE DIRECTORIES AND PLACE THE NEW FILES
; INTO EITHER THE FIXUP OR SAV DATA-BASE.

LOOPLN:	PUSH	P,[0]			; FLAG SAYING WHETHER WE FAILED TO OPEN
SPLANC:	OPEN	RCHAN,[READ?WRKDIR?[SIXBIT /SPLAN/]?CDATE]
	JRST	NSPLAN			; SPLAN NON-EXISTENT?
	MOVEI	A1,MDBLK		; ARGUMENTS TO UPDATE ROUTINE
	OPEN	IMAPCH,[READ?MNDIR?MNFB?<MNFB+1>]
	JRST	CNTOPN
	MOVEI	A2,SIXBIT /   SAV/	; NAME OF FILES
	MOVEI	0,GSAVL1		; GET LENGTH ROUTINE FOR UPDIR
	MOVEM	0,GETLNT
	MOVEI	0,SAVUPD		; ROUTINE TO UPDATE SAV DATA BASE
	MOVEM	0,ADJPAG
	PUSHJ	P,UPDIR			; UPDATE THE WORLD
	SKIPE	NOMUNG			; IF NOMUNG IS SET THEN DON'T FUDGE WITH BIT
	JRST	NODMP
	PUSHJ	P,%SDMPBT
NODMP:	CLOSE	RCHAN,
	CLOSE	IMAPCH,
	MOVE	A1,[SIXBIT /SAV/]	; GO TO ADFILE
	PUSHJ	P,ADFILE
	DELETE	[WRKDIR?[SIXBIT /SPLAN/]?CDATE]
	JFCL
FPLANC:	OPEN	RCHAN,[READ?WRKDIR?[SIXBIT /FPLAN/]?CDATE]
	JRST	NFPLAN			; FPLAN NON-EXISTANT?
	MOVEI	A1,FDBLK
	MOVEI	A2,SIXBIT /   FIX/	; ARGS TO UPDIR
	OPEN	IMAPCH,[READ?MNDIR?MFDB?<MFDB+1>]
	JRST	CNTOPN
	MOVEI	0,GFIXL1		; GET LENGTH ROUTINE FOR UUPDIR
	MOVEM	0,GETLNT
	MOVEI	0,FIXUPD
	MOVEM	0,ADJPAG		; ROUTINE TO UPDATE IN DATA BASE
	PUSHJ	P,UPDIR
	SKIPE	NOMUNG			; IF NOMUNG IS SET DON'T FUDGE WITH BIT
	JRST	NODMP1
	PUSHJ	P,%SDMPBT
NODMP1:	CLOSE	RCHAN,
	CLOSE	IMAPCH,
	MOVE	A1,[SIXBIT /FIXUP/]
	PUSHJ	P,ADFILE			; GO TO ADFILE
	DELETE	[WRKDIR?[SIXBIT /FPLAN/]?CDATE]
	JFCL
FPLANF:	POP	P,A			; SEE IF PLANS HAVE TO BE MADE
	JUMPN	A,CPLANS		; SET UP PLANS
	MOVEI	A1,[ASCIZ /DEMON FINISHED/]
	PUSHJ	P,MSGOUT
	MOVEI	A,40			; ASCII SPACE
EBUF:	MOVE	B,BUFBYT		; GET BUFBYT
	CAML	B,[350700,,0]
	JRST	.+3			; DONE PADDING
	IDPB	A,BUFBYT
	JRST	EBUF
	HRRZ	E,BUFBYT
	SUBI	E,SCBUF			; CALCULATE AOBJN PTR FOR REST OF SCRIPT BUFFER
	MOVNS	E
	HRLZS	E
	HRRI	E,SCBUF
	PUSHJ	P,BUFED1
	JRST	SALVGE


NSPLAN:	SETOM	(P)			; INDICATE OPEN FAILED
	JRST	FPLANC			; TRY FIXUPS

NFPLAN:	SETOM	(P)			; INDICATE FNF
	JRST	FPLANF


; NOW WE WILL LOOK AT THE WRKDIR AND LOOK FOR FILES TO ADD.  I WILL
; BUILD UP A FILE OF DIRECTIONS FOR THE SAVS AND ALSO THE FIXUP FILES.
; THE DESCRIPTOR IT BUILDS FOR BOTH THE FIXUP AND SAV FILES ARE AS FOLLOWS
; WD1==SIXBIT FIRST NAME WD2==BLOCK NUMBER,,VERSION NUMBER.  IT INITIALLY
; OPENS THE FIRST FILE AS _TEMP_ > AND WHEN DONE RENAMES THE FILE TO
; EITHER FIXADD > OR SAVADD >.  THE DEMON WILL CHECK TO SEE WHETHER THIS FILE
; EXISTS BEFORE ATTEMPTING TO GENERATE THESE PLAN FILES.  IF THE FILES EXIST
; ALL UPDATES WILL BE DONE AS INDICATED BY THAT FILE UNLESS THE FILES TO BE
; ADDED WERE DELETED.

CPLANS:	OPEN	IMAPCH,[READ?MNDIR?MNFB?<MNFB+1>]
	JRST	CNTOPN				; OPEN MAPPING CHANNELS
	OPEN	OMAPCH,[READ?MNDIR?MFDB?<MFDB+1>]
	JRST	CNTOPN
	OPEN	WCHAN,[WRITE?WRKDIR?FIXTMP?CDATE]
	JRST	CNTOPN
	OPEND	CPYCHN,[WRKDIR]
	OPEN	TCHAN,[WRITE?WRKDIR?SAVTMP?CDATE]
	JRST	CNTOPN
	MAPIN	IMAPCH,[CWRITP?[1]?T2BLKN]
	MAPIN	OMAPCH,[CWRITP?[1]?T2BLKN-1]
	SETZM	TOTST1				; TOTAL STORAGE REQUEST
	SETZM	TOTST2
	FILLEN	IMAPCH,RCL
	MOVE	A,RCL
	ASH	A,-PGSZ				; CONVERT TO PAGES
	MOVEM	A,HIBLK1
	FILLEN	OMAPCH,RCL
	MOVE	A,RCL
	ASH	A,-PGSZ-MINLEN
	MOVEM	A,HIBLK2
LOPBUF:	GETF	CPYCHN,A1
	JRST	CPLAN1				; CLOSE CHANNELS AND RENAME FILES
	PUSH	P,A1
	PUSH	P,A2
	MOVE	A1,A2
	PUSHJ	P,NM2CHK
	JRST	LOPBF1
	JUMPE	A,LOPBF2
	MOVEI	A1,FDBLK			; DELETE POSSIBLE FILE
	MOVE	A2,-1(P)			; FIRST FILE NAME
	MOVE	A3,B				; VERSION #
	MOVEI	A4,OMAPCH
	PUSH	P,B				; SAVE VERSION #
	STARTB	OMAPCH,[[1]?FSBLKN]
	PUSHJ	P,DELUPF
	POP	P,A2				; RESTORE AC'S
	POP	P,B
	POP	P,A
	MOVEI	A3,WCHAN			; TO FTMP FILE
	MOVEI	A4,T2BLK-PAGE
	MOVEI	A5,TOTST2
	MOVEI	A6,HIBLK2
	MOVEI	0,GFIXLN			; ROUTINE TO CONVERT TO SAV BLOCKS
	MOVEM	0,GETLNT
	JRST	SNDIT				; OUT IT GOES
LOPBF1:	SUB	P,[2,,2]			; CLEAN OFF STACK
	JRST	LOPBUF
LOPBF2:	MOVEI	A1,MDBLK
	MOVE	A2,-1(P)			; DELETE POSSIBLE FILE
	MOVE	A3,B
	MOVEI	A4,IMAPCH			; MAPPING CHANNEL TO USE
	PUSH	P,B
	STARTB	IMAPCH,[[1]?FSBLKN]
	PUSHJ	P,FILCHS			; SEE IS THERE
	SKIPA
	JRST	ERRFIL
	POP	P,A2
	POP	P,B
	POP	P,A			; RESTORE FILE NAMES
	MOVEI	A3,TCHAN
	MOVEI	A4,T2BLK
	MOVEI	A5,TOTST1
	MOVEI	A6,HIBLK1
	MOVEI	0,GSAVLN		; ROUTINE TO CONVERT TO FIX BLOCKS
	MOVEM	0,GETLNT

; ROUTINE TO SEND OUT INFOMATION TO TEMP FILE
; ARGS: A1==PTR TO DIRECTORY   A2==VERSION #    A3==CHANNEL TO TEMP FILE
;       A4==PTR TO FREE STORAGE LIST    A5==PTR TO TOTAL STORAGE REQ
;       A6==PTR TO HIGH BLOCK
; RETS: A UPDATED TO POINT AFTER DIR BLOCK

SNDIT:	OPEN	STCHAN,[READ?WRKDIR?A?B]
	JRST	LOPBUF
	PUSH	P,A			; SAVE FIRST FILE NAME
	FILLEN	STCHAN,RCL
	CLOSE	STCHAN,
	MOVE	A,RCL
	JUMPE	A,SNDIT7		; IF ZERO FILE LENGTH TRY TO WIN
	PUSHJ	P,@GETLNT		; NUMBER OF BLOCKS IN FILE
	HRRZ	B,(A4)			; GET LENGTH
	MOVNS	B			; GET NEGATIVE LENGTH
	ADDI	A4,1			; POINT TO NEXT WORD
	HRL	A4,B			; CREATE AOBJN POINTER
SNDIT3:	HLRZ	B,(A4)			; GET LENGTH OF BLOCK
	CAILE	A,(B)			; SKIP IF EQUAL
	JRST	SNDIT2
	HRRZ	B,(A4)			; GET BLOCK #
	ADDM	A,(A4)
	MOVNS	A
	HRLZS	A			; SMASH POINTER
	ADDM	A,(A4)
	JRST	SNDIT4
SNDIT2:	AOBJN	A4,SNDIT3
	ADDM	A,(A5)			; TOTAL STORAGE REQUEST
	MOVE	B,(A6)
	ADDM	A,(A6)			; HIGHEST ALLOCATED BLOCK
SNDIT4:	POP	P,C			; GET FIRST FILE NAME
	MOVEM	C,RCL
	OUTPUT	[A3?[-1,,RCL]]
	HRLZS	B			; SWAP POINTERS
	HRRI	B,(A2)			; PUT IN VERSION #
	MOVEM	B,RCL
	OUTPUT	[A3?[-1,,RCL]]
	JRST	LOPBUF			; LOOP BACK
SNDIT7:	SUB	P,[1,,1]		; CLEAN OFF STACK
	JRST	LOPBUF
CPLAN1:	CLOSE	TCHAN,
	RENNAM	[WRKDIR
		 SAVTMP
		 CDATE
		 [SIXBIT /SPLAN/]
		 CDATE]
	FATAL	RENAME FAILED
	CLOSE	WCHAN,
	RENNAM	[WRKDIR
	 	 FIXTMP
		 CDATE
		 [SIXBIT /FPLAN/]
		 CDATE]
	FATAL	RENAME FAILED
	CLOSE	CPYCHN,
	CLOSE	IMAPCH,			; CLOSE MAPPING CHANNELS
	CLOSE	OMAPCH,
	OPEN	WCHAN,[WRITEO?MNDIR?MNFB?<MNFB+1>] ; EXTEND FILES
	JRST	CNTOPN
	MOVE	A1,TOTST1
	PUSHJ	P,EXFIL
	CLOSE	WCHAN,
	OPEN	WCHAN,[WRITEO?MNDIR?MFDB?<MFDB+1>]
	JRST	CNTOPN
	MOVE	A1,TOTST2
	ADDI	A1,FIXLNT-1		; COMPUTE FIXUP EXPANSION
	ASH	A1,MINLEN
	PUSHJ	P,EXFIL
	CLOSE	WCHAN,
	JRST	LOOPLN			; GO BACK AND TRY UPDATE
	
NOSCRP:	SETOM	SCTFLG			; TURN OFF SCRIPTING
	JRST	TREOPN



; HERE IF FILE IS ALREADY IN THE DATA-BASE

ERRFIL:	MOVEI	A1,[ASCIZ /FILE ALREADY IN DATA-BASE/]
	PUSHJ	P,MSGOUT		; SEND OUT MESSAGE
	MOVE	A1,-2(P)		; GET FIRST FILE NAME
	PUSHJ	P,OUTINF
	MOVE	A1,-1(P)		; 2ND FILE NAME
	PUSHJ	P,OUTINF
	SUB	P,[3,,3]			; CLEAN OFF STACK
	JRST	LOPBUF



; HERE TO CHECK TO SEE IF A FILE IS IN THE DATA BASE
; IT SKIPS IF IT IS
; ARGS: A1==POINTER TO MAIN DIRECTORY BLOC (FD OR MD)
; A2==SIXBIT FN1     A3==VERSION #     A4==MAPPING CHANNEL

FILCHS:	TLO	0,400000
	MOVE	B,A2			; GET FIRST FILE NAME
FILCH2:	LDB	A,[000600,,B]		; GET LAST CHARACTER
	JUMPN	A,FILCH1			; LEAVE IF FOUND LAST CHARACTER
	LSH	B,-6			; GET RID OF CHARS
	JRST	FILCH2
FILCH1:	PUSH	P,0
	IDIV	A,(A1)			; GET DIRECTORY NUMBER
	ADDI	B,1(A1)			; POINT TO DIRECTORY BLOCK SLOT
	MOVE	0,A4			; BUILD A STARTB INSTRUCTION
	LSH	0,27			; MOVE INTO AC FIELD
	IOR	0,[STARTB [(B)?TBLKN]]
	XCT	0
	MOVEI	A1,TBLK-PAGE		; POINTER TO DIRECTOR
	MOVN	E,(A1)			; PRODUCE AOBJN POINTER
	HRL	A1,E
	ADDI	A1,1			; ADJUST POINTER TO POINT AFTER FIRST WORD
	POP	P,0
	SKIPGE	0
	JRST	DIRSRC			; SEACH DIRECTOR FOR FILE
	JRST	DIRSR1

; HERE IF SCRIPT FILE FOR TODAY EXISTS
	
SCOPEN:	CLOSE	SCHAN,
	PUSHJ	P,CRLF
	PUSHJ	P,CRLF
	JRST	CNSCRP		; CONTINE SCRIPT HACKING


GFIXLN:	ADDI	A,FROUND
	ASH	A,-PGSZ-MINLEN
	POPJ	P,

GFIXL1:	ADDI	D,FROUND
	ASH	D,-PGSZ-MINLEN
	POPJ	P,

GFIXL2:	ADDI	A1,FROUND
	ASH	A1,-PGSZ-MINLEN
	POPJ	P,

GSAVLN:	ADDI	A,ROUND
	ASH	A,-PGSZ
	POPJ	P,

GSAVL1:	ADDI	D,ROUND
	ASH	D,-PGSZ
	POPJ	P,

GSAVL2:	ADDI	A1,ROUND
	ASH	A1,-PGSZ
	POPJ	P,

; THESE ARE THE DELETE SPECIFIC ROUTINES


; DELFILE IS A ROUTINE USED TO DELETE FILES. IT ASSUMES THAT RCHAN IS OPEN TO A
; DELETE FILE (I.E. DELETE SAV OR DELETE FIXUP) AND THAT A1 IS THE POINTER TO
; THE MAIN DIRECTORY BLOCK
; ARGS: A1==PTR TO MAIN DIR BLOCK (FD OR MD).

DELFIL:	PUSH	P,A1			; SAVE A1
	MOVEM	P,SAVPDL		; SAVE PSTACK
DELFL4:	MOVEI	B,1(P)
	HRLI	B,440700
	MOVE	A1,B			; SAVE PTR TO STRING
DELFL2:	PUSH	P,[0]			; CREATE STRING OF FILE NAMES
	MOVEI	C,5			; # CHARS TO A WORD
DELFL1:	ICHAR	[[RCHAN]?RCL]
	JRST	EXDEL			; EXIT EOF
	MOVE	A,RCL
	CAIN	A,CARRET		; SEE IF CR
	JRST	DELFL3			; DONE READING
	IDPB	A,B			; SMASH IN CHARACTER
	SOJG	C,DELFL1		; LOOP BACK IF MORE CHARS
	JRST	DELFL2			; READ IN ANOTHER WORD OF THE STRING
DELFL3:	PUSHJ	P,GETNAM		; GET IT
	JRST	LOSDEL
	PUSH	P,A
	MOVE	A1,B			; RESTED BYTE PTR INTO A1
	PUSHJ	P,GETNAM
	JRST	LOSDEL
	PUSH	P,A			; SAVE SECOND FILE NAME
	MOVEI	A1,[ASCIZ /DELETING FILE /]
	PUSHJ	P,MSGOUT
	MOVE	A1,-1(P)			; SIXBIT FILE NAME 1
	PUSHJ	P,OUTINF
	MOVE	A1,(P)			; FILE NAME 2
	PUSHJ	P,OUTINF
	POP	P,A1
	PUSHJ	P,NM2CHK
	JRST	DELERR
	POP	P,A2
	MOVE	A3,B			; GET VERSION NUMBER AS SECOND ARG
	MOVE	P,SAVPDL
	MOVE	A1,(P)			; GET DIRECTORY BLOCK POINTER
	MOVEI	A4,IMAPCH
	PUSHJ	P,DELUPD
	JRST	DELFL4
EXDEL:	MOVE	P,SAVPDL
	SUB	P,[1,,1]		; POP ARGUMENT OFF STACK
	POPJ	P,			; EXIT

DELERR:	MOVE	P,SAVPDL
	JRST	DELFL4


; LOSDEL IS A ROUTINE CALLED IF THE DELETE FILE IS IN BAD SHAPE.  IT WILL
; PRINT A MESSAGE TO THE SCRIPT AND LEAVE DELETE ROUTINE WITHOUT DELETING
; ANY MORE FILES.

LOSDEL:	MOVE	P,SAVPDL		; RESTORE STATE OF PDL
	MOVEI	A1,[ASCIZ /DELETE FILE IN BAD FORMAT/]
	PUSHJ	P,MSGOUT		; SEND OUT WARNING
	SUB	P,[1,,1]
	RFNAM	RCHAN,RCL
	MOVE	A1,RCL			; SEND OUT LOSING FILE NAMES
	PUSH	P,RCL+1			; SAVE SECOND FILE NAME
	PUSHJ	P,OUTINF		; SEND OUT FIRST
	POP	P,A1			; SEND OUT SECOND
	PUSHJ	P,OUTINF
	POPJ	P,


; DELUPD UPDATES A DIRECTORY BY DELETING A FILE
; ARGS:  A2==SIXBIT FN1     A3==VERSION #     A1==MAIN DIRECTORY POINTER
;	 A4==MAPPING CHANNEL

DELUPF:	TLZA	0,400000		; FLAG INDICATING 1 FILE-NAME DELETE
DELUPD:	TLO	0,400000
	MOVE	B,A2			; GET FIRST FILE NAME
DELPD2:	LDB	A,[000600,,B]		; GET LAST CHARACTER
	JUMPN	A,DELPD1			; LEAVE IF FOUND LAST CHARACTER
	LSH	B,-6			; GET RID OF CHARS
	JUMPE	B,DELSE			; SEND OUT MESSAGE INDICATING SERIOUS LOSSAGE
	JRST	DELPD2
DELPD1:	PUSH	P,0			; SAVE CHECKER
	IDIV	A,(A1)			; GET DIRECTORY NUMBER
	ADDI	B,1(A1)			; POINT TO DIRECTORY BLOCK SLOT
	MOVE	0,A4			; BUILD A STARTB INSTRUCTION
	LSH	0,27			; MOVE INTO AC FIELD
	IOR	0,[STARTB [(B)?TBLKN]]
	XCT	0
	MOVEI	A1,TBLK-PAGE		; POINTER TO DIRECTOR
	MOVN	E,(A1)			; PRODUCE AOBJN POINTER
	HRL	A1,E
	ADDI	A1,1			; ADJUST POINTER TO POINT AFTER FIRST WORD
	POP	P,0			; RESTORE 0
	JUMPGE	DELPF1
	PUSHJ	P,DIRSRC		; SEACH DIRECTOR FOR FILE
	POPJ	P,
DELPD4:	PUSH	P,1(A)
	HLRE	B,A1			; CALCULATE END POINTER
	MOVE	C,A1
	SUB	C,B
	HRLI	A,2(A)			; BUILD BLT POINTER
	BLT	A,-1(C)			; FIX UP DIRECTORY
	SOS	TBLK-PAGE		; INDICATE DELETION IN FLIE LENGTH	
	SOS	TBLK-PAGE
	MOVEI	A1,TBLKN		; SEND OUT DIRECTORY PAGE
	PUSHJ	P,SNDOUT
	POP	P,A
	HRRZ	A1,A
	LDB	A2,[340700,,A]		; GET LENGTH FOR CALL TO UPDFRE
	PUSHJ	P,UPDFRE
	POPJ	P,


DELPF1:	PUSHJ	P,DIRSR1
	POPJ	P,
	JRST	DELPD4

DELSE:	MOVEI	A1,[ASCIZ /BAD DELETE NAME/]
	PUSH	P,MSGOUT
	POPJ	P,


; UPDFRE UPDATES THE FREE STORAGE TABLE IN CORE
; ARGS:     A1==BLOCK OF START      A2==LENGTH OF BLOCK

UPDFRE:	MOVEI	A,AFSBLK		; GET POINTER TO FREE STORAGE BLOCK
	MOVN	B,(A)
	HRLZS	B			; BUILD AOBJN PTR TO FREE STORAGE TABLE
	HRRI	B,AFSBLK+1
	MOVEI	A,(A1)
	ADDI	A,(A2)			; CALCULATE END OF NEW FREE STORAGE BLOCK
	JUMPGE	B,UPDFR4
UPDFR3:	HRRZ	C,(B)
	CAIE	A,(C)			; SEE IF WE CAN TACK ONTO THIS BLOCK
	JRST	UPDFR1
	HRLZI	A,(A2)			; GET LENGTH INTO LEFT HALF OF A
	ADDM	A,(B)			; UPDATE POINTER
	HRRM	A1,(B)			; FIX UP POINTER
	JRST	UPDFR2
UPDFR1:	HLRZ	D,(B)			; GET LENGTH OF ITEM
	ADDI	C,(D)			; CALCULEATE END OF SLOT
	CAIE	C,(A1)			; SEE IF WE CAN CONTINUE SLOT
	JRST	UPDFR5			; NO SUCH LUCK
	HRLZI	A,(A2)			; CONTINUE SLOT
	ADDM	A,(B)
	JRST	UPDFR2
UPDFR5:	AOBJN	B,UPDFR3
UPDFR4:	HRRZS	B			; CLEAN UP FREE STORAGE TABLE
	CAILE	B,AFSBLK+ROUND		; SKIP IF NOT AT HAIRY EDGE
	FATAL	NO ROOM IN FREE STORAGE TABLE
	HRRM	A1,(B)			; SMASH INTO TABLE
	HRLM	A2,(B)
	AOS	FSBLK-PAGE		; FIX UP FSBLK LENGTH
UPDFR2:	MOVEI	A1,FSBLKN		; SEND OUT FREE STORAGE TABLE
	PUSHJ	P,SNDOUT
	POPJ	P,


; THESE ARE THE DATA-BASE UPDATING ROUTINES


; UPDIR UPDATES EITHER A FIXUP OR SAV FILE.  IT READS COMMANDS FROM
; RCHAN AND ASSUMES IMAPCH IS OPEN TO THE FILE BEING UPDATED.
; ARGS:  A1==PTR TO MAIN DIRECTOR     A2==SIXBIT OF FIRST 3 CHARS OF FNAME

UPDIR:	STARTB	IMAPCH,[[1]?FSBLKN]
	PUSH	P,A1
	PUSH	P,A2			; SAVE ARGS
UPDIR5:	INPUT	[[RCHAN]?[-1,,RCL]]
	JRST	0,UPDI20
	MOVE	A,RCL
	INPUT	[[RCHAN]?[-1,,RCL]]
	FATAL	TEMP FILE IN BAD FORMAT
	MOVE	F,RCL
	MOVEI	B,0			; BUILD SECOND NAME IN B
	HRRZ	D,F			; GET VERSION # INTO E
	PUSH	P,D
UPDIR2:	IDIVI	D,10.			; GET A DIGIT
	ADDI	E,20			; CONVERT TO SIXBIT
	DPB	E,[140600,,B]
	JUMPE	D,UPDIR1
	LSH	B,-6			; SHIFT DIGITS
	JRST	UPDIR2
UPDIR1:
UPDIR3:	HRLI	B,(A2)			; CREATE FILE NAME
	PUSH	P,A
	PUSH	P,B
	PUSH	P,F
	PUSH	P,A1
	PUSH	P,A2			; SAVE AC'S
	MOVEI	A1,[ASCIZ /ADDING FILE/]
	PUSHJ	P,MSGOUT
	MOVE	A1,-4(P)
	PUSHJ	P,OUTINF
	MOVE	A1,-3(P)
	PUSHJ	P,OUTINF
	POP	P,A2
	POP	P,A1
	POP	P,F
	POP	P,B
	MOVE	A,(P)
UPREOP:	OPEN	STCHAN,[READ?WRKDIR?A?B]
	JRST	UPNOFL
	OPEN	CPYCHN,[WRITE?SAVDIR?A?B] ; SET UP CHANNEL FOR FILE-COPY
	JRST	CNTOPN
	FILLEN	STCHAN,RCL
	MOVE	D,RCL
	PUSHJ	P,@GETLNT		; ADJUST THE LENGTH
	MOVEI	B,AFSBLK
	HLRZ	C,F			; GET BLOCK # OF START
	HRRZ	E,(B)			; GET LENGTH OF FREE STORAGE BLOCK
	MOVEI	A3,1(B)			; GET COPY OF PTR TO FSBLK
UPDI10:	HRRZ	0,(A3)			; GET BLOCK #
	CAIE	0,(C)			; SKIP IF THIS IS THE BLOCK
	JRST	UPDIR4
	HLRZ	0,(A3)			; GET WORD FROM TABLE
	SUBI	0,(D)			; CALCULATE NEW BLOCK LENGTH
	SKIPGE	0			; SKIP IF STILL WINNING
	FATAL	FREE STORAGE MISALLOCATED
	JUMPE	0,SLIPCO		; SPICE OUT NOW NONEXISTANT BLOCK
UPDI13:	HRLM	0,(A3)			; SMASH IN NEW LENGTH
	ADDM	D,(A3)
UPDI15:	PUSH	P,D			; LENGTH
	PUSH	P,F			; STARTING BLOCK NUMBER
	MOVEI	A1,FSBLKN		; SEND OUT UPDATED FREE STORAGE BLOCK
	PUSHJ	P,SNDOUT
UPDI11:	MOVE	F,(P)
	HLRZS	F			; THIS IS START OF FILE IN DATA BASE
	MOVEI	B,0			; PAGE IN FILE
UPDIR6:	PUSH	P,B
	PUSH	P,F
	PUSH	P,D
	PUSHJ	P,@ADJPAG		; SEND OUT PAGES
	POP	P,D
	POP	P,F
	POP	P,B
	ADDI	F,1			; NEXT PAGE IN DATA BASE
	ADDI	B,1			; NEXT PAGE IN FILE
	SOJG	D,UPDIR6
	CLOSE	CPYCHN,			; CLOSE COPYING CHANNEL
	CORE	[FLUSH?[TBLKN-1]]
	CORE	[CREATE?[TBLKN-1]]
UPDI30:	MOVE	A,-2(P)			; GET FIRST FILE NAME
	LDB	B,[000600,,A]		; CALCULATE OFFSET IN DIRECTORY
	JUMPN	B,UPDIR7
	LSH	A,-6			; LOOK FOR LAST CHAR
	JRST	.-3
UPDIR7:	MOVE	A1,-5(P)		; GET POINTER TO DIRECTORY
	IDIV	B,(A1)			; GET DIRECTORY NUMBER IN C
	ADDI	C,1(A1)
	MOVE	C,(C)			; GET BLOCK OF DIRECTORY
	STARTB	IMAPCH,[C?TBLKN]
	MOVEI	A,TBLK-PAGE
	MOVE	B,(A)			; GET LENGTH
	MOVEI	E,2(B)			; GET FINAL COUNT
	CAILE	E,ROUND			; SEE IF OVERFLOW
	JRST	DIRFIL
	MOVEM	E,(A)
	MOVNS	B
	HRRZ	A1,A
	HRL	A1,B			; BUILD AOBJN POINTER
	ADDI	A1,1			; POINT AFTER COUNT
	MOVE	C,A			; GET PTR TO END OF DIR
	SUB	C,B
	PUSH	P,A			; BEGINNING POINTER
	PUSH	P,C			; END POINTER
	MOVE	A2,-4(P)		; GET FIRST FILE NAME
	MOVE	A3,-5(P)		; GET VERSION #
	PUSHJ	P,SDIRSC		; GET PTR INTO DIRECTORY
	FATAL	PLACEMENT PLAN FAILED
	POP	P,B			; GET END POINTER
	POP	P,C			; BEGINNING POINTER
	POP	P,D			; BEGINNING BLOCK
	POP	P,A3			; LENGTH OF FILE
	POP	P,E			; FIRST FILE NAME
	POP	P,F			; VERSION NUMBER
	MOVSS	D			; GET BLOCK # IN LEFT HALF
	DPB	A3,[340700,,D]
	CAIGE	A,(B)			; SEE IF AT END
	JRST	UPDIR8
	MOVEM	E,1(B)			; SMASH INTO DIRECTORY
	MOVEM	D,2(B)
UPDIR9:	MOVEI	A1,TBLKN		; SEND OUT DIRECTORY
	PUSHJ	P,SNDOUT
	RFNAM	STCHAN,RCL
	CLOSE	STCHAN,			; CLOSE CHANNEL AND DELETE FILE
	DELETE	[WRKDIR?RCL?<RCL+1>]
	JFCL
	MOVE	A1,-1(P)
	MOVE	A2,(P)
	JRST	UPDIR5

DIRFIL:	MOVE	A1,-5(P)
	PUSHJ	P,ADDIR
	JRST	UPDI30

UPDI20:	SUB	P,[2,,2]		; CLEAN OFF STACK
	POPJ	P,

UPNOFL:	SUB	P,[2,,2]
	JRST	UPDIR5

; HERE TO DO A BACKWARDS BLT.  A HAS SOURCE  2(A) IS START OF DEST AND 2(B)
; IS END OF DEST

UPDIR8:	MOVEI	F,(B)			; GET END
	SUBI	F,-1(A)
	MOVE	A5,F			; SAVE ADDITION
	HRLZS	F			; SWAP AND 0
	HRR	F,A
	ADDI	F,-1(A5)
	MOVEI	A6,(A)			; SET UP DEST WORD
	SUBI	A6,(F)			; CALC DIFF
	ADDI	A6,1(A5)
	HRLI	A6,F
	POP	F,@A6			; BLT
	TLNE	F,-1
	JRST	.-2
	MOVEM	E,(A)
	MOVEM	D,1(A)			; SMASH IN ENTRIES FOR BUFFER
	JRST	UPDIR9

UPDIR4:	ADDI	A3,1
	SOJGE	E,UPDI10
	PUSH	P,D
	PUSH	P,F
	JRST	UPDI11

SLIPCO:	PUSH	P,A3
	HRLI	A3,1(A3)		; BLT OUT SLOT
	BLT	A3,FSBLK-1
	SOS	AFSBLK			; KILL FREE STORAGE BLOCK
	POP	P,A3
	JRST	UPDI15

; F POINTS TO PAGE IN DATA-BASE
; B POINTS TO PAGE IN FILE

SAVUPD:	MAPIN	IMAPCH,[WRITP?F?TBLKN]
	MAPIN	STCHAN,[READP?B?TBLKN-1]
	OUTPUT	[[CPYCHN]?[-PAGE,,ATBLK]]
	MOVEI	A1,TBLKN		; DUMP OUT PAGE
	PUSHJ	P,SNDOUT
	POPJ	P,

FIXUPD:	MOVE	D,F
	ASH	D,MINLEN		; CONVERT TO REAL PAGES
	STARTB	IMAPCH,[D?TBLKN]
	ANDI	F,FIXLNT-1		; CALCULATE WHERE TO BLT TO
	ASH	F,PGSZ+MINLEN		; CALCULATE BLT POINTER
	ADDI	F,ATBLK
	HRLI	F,-FROUND-1
	MOVE	C,F			; SAVE POINTER
	ASH	B,PGSZ+MINLEN		; ACESS TO RIGHT PLACE
	ACCESS	STCHAN,B
	INPUT	[[STCHAN]?C]
	JFCL
	OUTPUT	[[CPYCHN]?F]
	MOVEI	A1,TBLKN		; DUMP OUT PAGE
	PUSHJ	P,SNDOUT
	POPJ	P,

	

; ROUTINES TO HANDLE OUTPUT TO THE SCRIPT FILE


; SMBUF SMASHES A CHARACTER INTO THE BUFFER AND OUTPUTS WHEN NECESSARY
; ARGS: A1==ASCII OF CHARACTER 
; BUFCNT IS A CHARACTER COUNTER
; BUFBYT IS BYTE POINTER TO BUFFER



SMBUF:	SKIPGE	SCTFLG
	POPJ	P,			; IF SCRIPTING IS TURNED OFF LEAVE
	IDPB	A1,BUFBYT		; SMASH CHARACTER INTO BUFFER
	AOSE	BUFCNT			; SKIP IF FILLED A WORD
	POPJ	P,
BUFEND:	MOVE	E,[-BUFLNT,,SCBUF]
BUFED1:	OPEN	SCHAN,[WRITEO?WRKDIR?[SIXBIT /SCRIPT/]?CDATE]
	JRST	NOSCR			; FORGET ABOUT SCRIPTING
	FILLEN	SCHAN,RCL
	ACCESS	SCHAN,RCL
	MOVNI	0,5*BUFLNT
	MOVEM	0,BUFCNT
	OUTPUT	[[SCHAN]?E]
	CLOSE	SCHAN,
	MOVE	0,[440700,,SCBUF]
	MOVEM	0,BUFBYT
	POPJ	P,

NOSCR:	SETOM	SCTFLG			; KILL SCRIPTING
	POPJ	P,			; LEAVE

; CRLF SENDS A CARRIAGE RETURN LINE-FEED TO THE BUFFER

CRLF:	MOVEI	A1,CARRET		; CR
	PUSHJ	P,SMBUF
	MOVEI	A1,12			; LF
	PUSHJ	P,SMBUF
	POPJ	P,

; OUTINFO TAKES A SIXBIT ARGUMENT IN A1 AND OUTPUTS IT WITH A SPACE
; ARGS:  A1==SIXBIT WORD

OUTINF:	MOVE	A2,A1
OUTIN1:	JUMPE	A2,OUTIF1		; DONE?
	LDB	A1,[360600,,A2]
	ADDI	A1,40			; CONVERT TO ASCII
	PUSH	P,A2
	PUSHJ	P,SMBUF
	POP	P,A2
	LSH	A2,6
	JRST	OUTIN1
OUTIF1:	MOVEI	A1,11			; SEND OUT TAB
	PUSHJ	P,SMBUF
	POPJ	P,

; PTIME PRINTS THE TIME

PTIME:	PUSHJ	P,%TIME
	PUSHJ	P,OUTINF		; PRINT OUT THE TIME
	POPJ	P,

; MSGOUT PRINTS A CRLF THE TIME AND A MESSAGE PROVIEDED IN A1 AND ENDS WITH A SPACE
; ARGS: A1==ASCIZ STRING

MSGOUT:	PUSH	P,A1			; SAVE ARG
	PUSHJ	P,CRLF
	PUSHJ	P,PTIME			; PRINT TIME
	POP	P,A
	MOVE	B,[440700,,(A)]		; BUILD BYTE POINTER TO THE STRING
MSGOT2:	ILDB	A1,B			; GET BYTE
	JUMPE	A1,MSGOT1		; DONE IF 0
	PUSH	P,A
	PUSH	P,B
	PUSHJ	P,SMBUF
	POP	P,B
	POP	P,A
	JRST	MSGOT2
MSGOT1:	MOVEI	A1,11			; SPACE
	JRST	SMBUF


; SETDAT SETS THE CURRENT DATE AS CDATE

SETDAT:	PUSHJ	P,%DATE
	MOVEM	A1,CDATE
	POPJ	P,			; EXIT



; ADDIR IS A ROUTINE TO RECREATE THE DIRECTORIES FOR THE DATA BASES.  IT
; ASSUMES THAT IMAPCH IS OPEN TO THE DATA BASE TO BE RESTRUCTURED AND THAT
; ITS ARGUMENT POINTS TO THE MAIN DIRECTORY BLOCK.
; ARGS:  A1==PTR TO MAIN DIRECTORY BLOCK

ADDIR:	PUSH	P,A1			; SAVE ARGUMENT
	MOVEI	A1,[ASCIZ /ADDING DIRECTORY/]
	PUSHJ	P,MSGOUT
	POP	P,A1
	MOVEI	A5,(A1)
	MOVE	A,(A1)			; GET # OF DIRECTORIES
	AOS	(A1)			; INCREMENT # OF DIRECTORIES
	MOVNI	C,1(A)			; GET #DIRS + 1
	HRLI	C,(C)
	HRRI	C,DIRVEC		; BUILD A DIRECTORY VECTOR
	MOVE	D,TOPBLK		; FIRST BLOCK
	ASH	D,-PGSZ
ADDIR1:	CORE	[CREATE?D]
	MOVEI	0,(D)			; GET PAGE #
	ASH	0,PGSZ			; NOW SMASH INTO DIRVEC
	HRRZM	0,(C)
	ADDI	D,1
	AOBJN	C,ADDIR1		; LOOP BUILDING DIRECTORY VECTOR
ADDIR3:	ADDI	A1,1			; POINT TO FIRST DIRECTORY
	MOVE	E,(A1)			; GET BLOCK OF DIRECTORY
	STARTB	IMAPCH,[E?TBLKN]
	MOVEI	F,TBLK-PAGE
	MOVN	0,(F)			; GET LENGTH OF DIRECTOR
	HRL	F,0			; BUILD AOBJN PTR TO DIR
	ADDI	F,1
	JUMPGE	F,ADDI30
ADDIR2:	MOVE	A2,(F)			; GET A NAME
	LDB	A3,[000600,,A2]		; FIND LAST CHARACTER
	JUMPN	A3,.+3
	LSH	A2,-6
	JRST	.-3
	IDIV	A3,(A5)			; GET DIRECTORY NUMBER INTO WHICH FILE WILL GO
	MOVE	C,DIRVEC(A4)		; GET DIRECTORY VECTOR POINTER
	MOVE	A2,(F)			; GET BACK NAME
	MOVEM	A2,(C)			; SMASH IN
	MOVE	A2,1(F)			; GET NEXT WORD
	MOVEM	A2,1(C)
	ADD	C,[2,,2]		; INC POINTER
	HLRZ	0,C			; GET COUNT
	CAIL	0,ROUND-1		; SKIP IF STILL WINNING
	FATAL	DIRECTORY REHASHING FAILED
	MOVEM	C,DIRVEC(A4)
	ADD	F,[2,,2]
	JUMPL	F,ADDIR2
ADDI30:	SOJN	A,ADDIR3

; NOW WE WILL GET IN A FREE STORAGE BLOCK AND TRY TO FIND ROOM FOR OUR NEW DIRECTORIES

	MOVN	F,(A5)			; -NUMBER OF DIRECTORIES
	HRLS	F
	HRRI	F,1(A5)			; BUILD AN AOBJN POINTER TO THE DIRTAB


ADDI20:	PUSH	P,[0]
	FILLEN	IMAPCH,(P)
	MOVE	0,(P)
	ASH	0,-10.			; NUMBER OF PAGES TO HI BLOCK
	MOVEI	C,0			; INITIALIZE COUNT OF PAGES TO ADD
ADDIR6:	MOVEM	0,(F)
	ADDI	0,1			; NEXT PAGE STARTS IT
	ADDI	C,1
	AOBJP	F,.+2
	JRST	ADDIR6			; LOOP BACK ALLOCATING PAGES
	RFNAM	IMAPCH,A2
	CLOSE	IMAPCH,
	POP	P,RCL
	OPEN	IMAPCH,[WRITEO?MNDIR?A2?A3]
	JRST	CNTOPN
	ACCESS	IMAPCH,RCL
	OUTPUT	[[IMAPCH]?[-PAGE,,TBLK]]
	SOJG	C,.-1			; LOOP UNTIL EXTENDED
	CLOSE	IMAPCH,
	OPEN	IMAPCH,[READ?MNDIR?A2?A3]
	JRST	CNTOPN

; NOW TO MAP IN DIRECTORIES MAKE SURE ALL DIRECTORY POINTERS ARE UPDATED ETC.
; NOW ALL THE DIRECTORIES HAVE THERE BLOCK NUMBERS IN THE MAIN TABLE
; A1==PTR TO MAIN TABLE  DIRVEC POINTS TO NEW DIRECTORIES WITH EACH
; ENTRY AS LENGTH,,PTR.  THE POINTER POINTS WITHIN A PAGE SO CAN BE
; ASH'D

ADDIR7:	MOVEI	A1,FSBLKN
	PUSHJ	P,SNDOUT
	MOVN	F,(A5)			; GET -NUMBER OF DIRS
	HRLZS	F
	HRR	F,A5			; BUILD AOBJN POINTER
	ADDI	F,1
	MOVEI	E,DIRVEC
NDRLP:	HRRZ	B,(E)			; GET END OF DIRECTORY
	MOVE	A,B			; FIND BEGINNING OF DIRECTORY
	ANDCMI	A,ROUND			; DIRECTORY BEGINS ON PAGE BOUNDRY
	PUSHJ	P,SORT			; GO SORT DIRECTORY
	HRRZ	C,(F)			; GET PAGE NUMBER OF DIRECTORY
	MAPIN	IMAPCH,[WRITP?C?TBLKN]
	HRRZ	A,(E)			; GET START OF DIRECTORY
	ANDCMI	A,ROUND
	HRLS	A
	HLRZ	B,(E)			; GET LENGTH OF DIRECTORY
	MOVEM	B,TBLK
	HRRI	A,TBLK+1
	BLT	A,TBLK+ROUND		; SEND OVER DIRECTORY
	PGDUMP	[[TBLKN]]
	ADDI	E,1
	AOBJN	F,NDRLP
	MAPIN	IMAPCH,[WRITP?[0]?TBLKN]
	HRLS	A5			; SET UP BLT POINTER
	HRRI	A5,TBLK
	BLT	A5,TBLK+ROUND		; SEND OUT DIRECTORY
	PGDUMP	[[TBLKN]]
	POPJ	P,			; DIRECTORIES ARE NOW FIXED UP?




; SORT ROUTINE STOLEN OUT OF TECO AND ADJUSTED TO SORT NUMERICALLY
; A==START OF AREA TO BE SORTED  B==END OF AREA TO BE SORTED

SORT:	MOVSI	C,400000	;PART 1 OF MOBY SYMBOL SORT
SORT1:	HRLM	B,(P)
	CAIL	A,-2(B)
	JRST	SORT7
	PUSH	P,A
SORT3:	MOVE	D,(A)
	PUSHJ	P,TDNN1
	JRST	SORT4
	SUBI	B,2
	MOVE	D,(B)
	PUSHJ	P,TDNN2
	JRST	SORT2
	MOVE	D,(A)
	EXCH	D,(B)
	MOVEM	D,(A)
	MOVE	D,1(A)
	EXCH	D,1(B)
	MOVEM	D,1(A)
SORT4:	ADDI	A,2
SORT2:	CAME	A,B
	JRST	SORT3
	ROT	C,-1
	POP	P,A
	JUMPL	C,SORT6
	PUSHJ	P,SORT1
	HLRZ	B,(P)
	PUSHJ	P,SORT1
SORT6:
SORT6A:	ROT	C,1
SORT7:	HLRZ	A,(P)
	POPJ	P,

TDNN1:	JUMPL	C,TDNN3
TDNN4:	TDNE	C,D
	AOS	(P)
	POPJ	P,
TDNN2:	JUMPL	C,TDNN4
TDNN3:	TDNN	C,D
	AOS	(P)
	POPJ	P,



; THESE ROUTINESE ARE USED TO DECODE FILE NAMES


; GETNAM IS A ROUTINE WHICH GETS A SIXBIT FILE NAME FROM A STRING AND UPDATE THE
; STRING POINTER AFTER THE TERMINATOR WHICH IS EITHER A SPACE OR ASCII 0.
; ARGS: A1==BYTE POINTER TO STRING
; RETS: A==SIXBIT FILE NAME       B==UPDATED STRING POINTER


GETNAM:	MOVEI	A,0			; SIXBIT GOES TO A
	MOVE	F,[440600,,A]		; BYTE POINTER FOR STRING
	MOVEI	D,0			; COUNT OF CHARACTERS FOR CHECK
GETNM3:	ILDB	B,A1			; GET CHARACTER
	CAIN	B,12
	JRST	GETNM3
	CAIE	B,0			; SKIP IF END OF STRING
	CAIN	B,40			; DON'T SKIP IF DONE
	JRST	GETNM2			; EXIT DONE
	SUBI	B,40			; CONVERT TO SIXBIT
	JUMPL	B,GETNM1		; LOSE LOSE LOSE
	IDPB	B,F			; DEPOSIT CHARACTER IN RETURN STRING
	ADDI	D,1			; AOS COUNT IN D
	CAIG	D,6			; SKIP IF COUNT IS TO HIGH
	JRST	GETNM3
GETNM1:	POPJ	P,			; LOSSAGE EXIT
GETNM2:	AOS	(P)			; SKIP RETURN WIN
	MOVE	B,A1			; GET UPDATED STRING POINTER
	POPJ	P,			; LEAVE



; NM2CHK LOOKS AT THE SECOND NAME OF A FILE AND DETERMINES WHETHER IT IS A SAV
; OR FIXUP AND SKIPS IF IT IS EITHER
; ARGS: A1==SIXBIT SECOND NAME
; RETS: A==0 OR -1 (-1 IF FIXUP, 0 IF SAV) B==VERSION NUMBER

NM2CHK:	HLRZ	0,A1			; GET FIRST 3 CHARACTERS
	CAIE	0,SIXBIT /   SAV/	; SKIP IF A SAV FILE
	JRST	NM2CK1
	SETZ	A,			; INDICATE SAV
	JRST	NUMGET
NM2CK1:	CAIE	0,SIXBIT /   FIX/	; SKIP IF FIXUP FILE
	POPJ	P,
	SETO	A,			; INDICATE ITS A FIXUP
NUMGET:	LSH	A1,18.			; GET RID OF LEFT HALF
	SETZ	B,			; ACCUMULATING TOTAL
NUMGT1:	JUMPE	A1,NUMGT2		; IF 0 WE'RE FINISHED
	LDB	C,[360600,,A1]		; GET DIGIT
	JUMPE	C,NUMGT2
	IMULI	B,10.			; SHIFT DIGITS
	CAIL	C,20			; SEE IF IN RANGE
	CAIL	C,32
	POPJ	P,			; INDICATE BAD NAME
	SUBI	C,20			; CONVERT TO NUMERAL
	ADDI	B,(C)			; ADD IT TO ACCUMULATING TOTAL
	LSH	A1,6			; SHIF OUT DIGIT
	JRST	NUMGT1
NUMGT2:	SKIPE	B			; SKIP IF 0 VERSION # (EXPERIMENTAL)
	AOS	(P)			; SKIP RETURN INDICATES WINAGE
	POPJ	P,


; THESE ARE DIRECTORY SEARCH ROUTINES


; THIS ROUTINE DOES A BINARY SEARCH ON A DIRECTORY AND RETURNS A POINTER
; RESTED DOWN TO THE APPROPRIATE SLOT IN THE DIRECTORY.
; ARGS: A1==DIR POINTER A2==FILE-NAME 1 A3==VERSION #
; RETS: A==RESTED DOWN DIRECTORY

DIRSR1:	TLOA	0,400000		; INDICATION OF ONE ARGUMENT SEARCH
DIRSRC:	TLZ	0,400000		; INDICATOR OF 2 ARGUMENT SEARCH
	HLRE	B,A1			; GET LENGTH INTO B
	MOVNS	B
	MOVE	A,A1
	HRLS	B			; GET BOTH SIDES
UP:     ASH     B,-1            	; HALVE TABLE
        AND     B,[-2,,-2]      	; FORCE DIVIS BY 2
        MOVE    C,A             	; COPY POINTER
        JUMPLE  B,LSTHLV        	; CANT GET SMALLER
        ADD     C,B
        CAMLE   A2,(C)			; SKIP IF EITHER FOUND OR IN TOP
        MOVE    A,C             	; POINT TO SECOND HALF
        CAMN    A2,(C)           	; SKIP IF NOT FOUND
        JRST    WON
        CAML    A2,(C)           	; SKIP IF IN TOP HALF
        JRST    UP
        HLLZS   C               	; FIX UP POINTER
        SUB     A,C
        JRST    UP

WON:	JUMPL	0,SUPWIN
	MOVEI	D,0			; DOWN FLAG
WON1:	LDB	A,[221200,,1(C)]	; GET VERSION NUMBER
	CAIN	A,(A3)			; SKIP IF NOT EQUAL
	JRST	SUPWIN
	CAIG	A,(A3)			; SKIP IF LT
	JRST	SUBIT
	SETO	D,
	SUB	C,[2,,2]		; GET NEW C
	JRST	SUBIT1
SUBIT:	ADD	C,[2,,2]		; SUBTRACT
	JUMPN	D,CPOPJ
SUBIT1:	CAMN	A2,(C)			; SEE WHETHER WERE STILL WINNING
	JRST	WON1
	POPJ	P,			; LOSE LOSE LOSE
SUPWIN:	MOVE	A,C			; RETURN ARGUMENT IN A  
	AOS	(P)			; SKIP RETURN INDICATES IT WAS FOUND
	POPJ	P,

LSTHLV: CAMN    A2,(C)           	; LINEAR SEARCH REST
        JRST    WON
        ADD     C,[2,,2]
        JUMPL   C,.-3
	POPJ	P,



; SDIRSC IS A SPECIAL DIRECTORY SEARCH ROUTINE.  IT TAKES AN AOBJN POINTER TO
; A DIRECTORY AND A NAME TO SEARCH ON AND RETURNS AN AOBJN POINTER TO WHERE
; THE ADDITION SHOULD GO.  IT USES A BINARY SEARCH TO DO THIS. IT SKIPS IN ALL
; CASES BUT THE CASE WHERE THE FILE EXISTS WHICH INDICATES VERY GREAT LOSSAGE
; IN THE PLANNING ROUTINE
; ARGS A1==AOBJN POINTER TO DIRECTOR     A2==FIRST FN   A3==VERSION #
; RETS A== POINTER INTO DIRECTORY

SDIRSC:	MOVE	A,A1
	HLRE	B,A1			; CALCULATE LENGTH
	MOVNS	B
	MOVEI	D,(A)
	ADDI	D,(B)
	MOVE	C,A
	HRLS	B

SUP:	ASH	B,-1			; HALF B
	AND	B,[-2,,-2]
	MOVE	C,A			; COPY PTR TO DIR
	JUMPLE	B,SLSTHV
	ADD	C,B
	CAMLE	A2,(C)			; GO ON FIRST NAME
	MOVE	A,C			; GO UP A BIT
	CAMN	A2,(C)
	JRST	EQDIR			; FOUND == GO LOOKING
	CAMG	A2,(C)
	JRST	SUP1
	CAIE	D,2(C)			; ARE WE POINTING AT THE END
SUP2:	CAMGE	A2,2(C)
	JRST	SWON1
SUP1:	CAML	A2,(C)			; SKIP IF IN TOP HALF
	JRST	SUP
	HLLZS	C
	SUB	A,C
	JRST	SUP
SWON:	AOS	(P)
	MOVE	A,C
	POPJ	P,	
EQDIR:	LDB	B,[221200,,1(C)]		; GET VERSION #
	CAMN	A3,B			; SKIP IF NOT EQUAL
	POPJ	P,			; LEAVE INDICATING LOSSAGE
	CAML	A3,B			; SEE IF LT
	JRST	LOCHK			; LOOK FOR LOWER
EQDIR1:	SUB	C,[2,,2]		; INC DIR POINTER
	CAME	A2,(C)			; SEE IF STILL EQUAL
	JRST	SWON1
	LDB	B,[221200,,1(C)]	; GET VERSION #
	CAMN	A3,B			; SEE IF =
	POPJ	P,
	CAML	A3,B			; SEE IF LT
	JRST	SWON1
	JRST	EQDIR1			; GO BACK
LOCHK:	ADD	C,[2,,2]
	CAME	A2,(C)			; SEE IF STILL EQUAL
	JRST	SWON
	LDB	B,[221200,,1(C)]	; GET VERSION #
	CAMN	A3,B
	POPJ	P,
	CAMG	A3,B
	JRST	SWON
	JRST	LOCHK


SWON1:	ADD	C,[2,,2]		; FIXUP POINTER
	JRST	SWON

SLSTHV: CAMN	A2,(C)			; SKIP IF NOT ==
	JRST	EQDIR
	CAMG	A2,(C)			; SKIP IF GT
	JRST	SWON			; WIN
	ADD	C,[2,,2]
	JUMPL	C,SLSTHV
	JRST	SWON


; THESE ARE FILE SPECIFIC ROUTINES


; SNDOUT SENDS OUT A BUFFER.  IN A1 IS A POINTER OF THE PAGE TO BE PGDUMPED.  ITS
; BUFFER IS IMMEDIATELY AFTER THE PAGE.  THIS ROUTINE BLT'S THE BUFFER INTO THE
; WRITEABLE PAGE AND DUMPS IT OUT.
; ARGS:     A1==PAGE NUMBER

SNDOUT:	MOVE	A,A1			; COPY POINTER TO PAGE
	ASH	A,PGSZ			; POINT TO BEGINNING OF PAGE
	HRLI	A,-PAGE(A)		; SET UP BLT POINTER
	HRRZ	B,A			; COPY PTR FOR BLT
	BLT	A,ROUND(B)
	PGDUMP	[A1]
	POPJ	P,

; EXFIL IS A ROUTINE TO EXTEND A FILE.  IT ASSUMES WCHAN IS OPEN TO THE FILE TO BE
; EXTENDED AND THAT A1 WILL CONTAIN THE NUMBER OF BLOCKS TO EXDEND IT BY.
; ARGS:  A1==# OF BLOCKSS TO EXTEND FILE

EXTEN:
EXFIL:	JUMPE	A1,CPOPJ
	FILLEN	WCHAN,RCL
	ACCESS	WCHAN,RCL			; ACCESS TO END OF FILE
	OUTPUT	[[WCHAN]?[-PAGE,,TBLK]]
	SOJG	A1,.-1
CPOPJ:	POPJ	P,			; EXIT

; ROUTINE TO CREATE FILES SAV FILE AND FIXUP FILE

CFILES:	MOVE	P,[-PDLNT,,PDS]
	OPEN	WCHAN,[WRITE?MNDIR?MNFB?<MNFB+1>]
	FATAL	CANT CREATE SAV FILE
	MOVEI	A1,4		; WRITE FIRST 3 BLOCKS
	PUSHJ	P,EXFIL		; EXTEND IT
	CLOSE	WCHAN,
	OPEN	WCHAN,[WRITE?MNDIR?MFDB?<MFDB+1>]
	FATAL	CANT CREATE FIXUP FILE
	MOVEI	A1,4
	PUSHJ	P,EXFIL
	CLOSE	WCHAN,
	OPEN	IMAPCH,[READ?MNDIR?MNFB?<MNFB+1>]
	FATAL	CANT OPEN SAV FILE
	PUSHJ	P,CFL
	CLOSE	IMAPCH,
	OPEN	IMAPCH,[READ?MNDIR?MFDB?<MFDB+1>]
	FATAL	CANT OPEN FIXUP FILE
	PUSHJ	P,CFL
	CLOSE	IMAPCH,
	OPEN	LKCHN,[WRITE?MNDIR?[SIXBIT/LOCK/]?[SIXBIT/MUDSAV/]]
	FATAL	CANT CREATE LOCK FILE
	CLOSE	LKCHN,
	JRST    4,
	JRST	.-1


CFL:	MAPIN	IMAPCH,[WRITP?[0]?T2BLKN]
	MOVEI	A,2
	MOVEM	A,T2BLK
	MOVEI	A,2
	MOVEM	A,T2BLK+1
	MOVEI	A,3
	MOVEM	A,T2BLK+2
	CORE	[FLUSH?[T2BLKN]]
	POPJ	P,	

; A SALVAGER FOR THE MUDDLE SAV-FIXUP SYSTEM

SALVGE:	OPEN	IMAPCH,[READ?MNDIR?MNFB?<MNFB+1>]
	JRST	CNTOPN
	MOVEI	0,1			; NUMBER OF BLOCKS TO A REAL BLOCK
	MOVEM	0,DIRLNT
	MOVEI	0,GSAVL2
	MOVEM	0,GETLNT
	PUSHJ	P,SALV
	CLOSE	IMAPCH,
	OPEN	IMAPCH,[READ?MNDIR?MFDB?<MFDB+1>]
	JRST	CNTOPN
	MOVEI	0,FIXLNT
	MOVEM	0,DIRLNT
	MOVEI	0,GFIXL2
	MOVEM	0,GETLNT
	PUSHJ	P,SALV
	CLOSE	IMAPCH,
	SKIPGE	NOFILE			; IF NOFILE IS SET DON'T HACK ADD FILES
	JRST	FINIS
	MOVE	A1,CSFILE
	PUSHJ	P,SETFIL		; HACK ADDED FILES TO BE UP TO DATE
FINIS:	PUSHJ	P,%FINIS


; SALV IS THE MAIN SALVAGER ROUTINE.  IT ASSUMES THAT IMAPCH IS OPEN TO THE DATA
; BASE TO BE SALVAGED.  IT FIRST MARKS ALL THE PAGES IN USE IN A BIT-VECTOR.  THEN
; LOOKING THRU THE BIT VECTOR DECIDES WHICH PAGES ARE REALLY FREE

SALV:	SETZM	BITVEC			; ZERO BIT TABLE
	MOVE	0,[BITVEC,,BITVEC+1]
	BLT	0,BITEND
	MAPIN	IMAPCH,[READP?[0]?T2BLKN]
	MOVEI	A1,0
	PUSHJ	P,MARKX
	MOVEI	A1,1
	PUSHJ	P,MARKX
	HRRZ	B,(A)
	MOVN	A,T2BLK
	HRLZS	A			; CREATE AOBJN POINTER TO DIRECTORY
	HRRI	A,T2BLK+1
SALV1:	HRRZ	A1,(A)			; GET PAGE NUMBER OF DIRECTORY
	PUSH	P,A		; SAVE POINTER
	PUSH	P,A1
	PUSHJ	P,MARKX		; MARK DIRECTORY PAGE
	POP	P,B
	MAPIN	IMAPCH,[READP?B?T2BLKN-1]
	MOVN	B,AT2BLK		; SET UP AOBJN POINTER TO DIRECTORY
	HRLZS	B
	HRRI	B,AT2BLK+1
SALV2:	HRRZ	A1,1(B)			; GET BLOCK #
	LDB	A2,[340700,,1(B)]	; GET NUMBER OF BLOCKS
	PUSH	P,B
	PUSHJ	P,MARK			; MARK IT
	POP	P,B
	ADD	B,[2,,2]		; INC POINTER
	JUMPL	B,SALV2			; LOOP
	POP	P,A			; RESTORE A
	AOBJN	A,SALV1			; LOOP BACK FOR DIRECTORIES

; NOW ALL BLOCKS POINTED TO ARE MARKED IN THE BITVEC AND I WILL SET UP TO RECOMPUTE
; THE FREE STORAGE BLOCK.
; AC'S:   A==BYTE POINTER  B==COUNT FOR WORD   C==COUNT FOR TOTAL   
;	  D==# OF FREE BLOCKS SO FAR   E==START OF BLOCK OF FREE STORAGE
;	  F==PTR TO FREE STORAGE AREA

	FILLEN	IMAPCH,A1
	PUSHJ	P,@GETLNT
	SETZM	AFSBLK			; ZERO FREE STORAGE AREA
	MOVE	0,[AFSBLK,,AFSBLK+1]
	BLT	0,AFSBLK+ROUND
	MOVEI	F,AFSBLK+1
	MOVEI	D,0
	MOVEI	E,0
	MOVEI	C,0
	MOVE	A,[440100,,BITVEC]	; BYTE PTR INITIALLY POINTS TO BITVEC
SALV6:	MOVEI	B,0
SALV5:	ILDB	0,A			; GET A BIT
	JUMPE	0,SALV3			; JUMP IF FREE BLOCK
	JUMPE	D,SALV4			; JUMP IF NO FREE STORAGE IN THIS BLOCK
	HRLM	D,(F)			; SMASH IN FREE STORAGE
	HRRM	E,(F)
	AOS	AFSBLK			; AOS COUNT OF # OF WORDS OF FSBLK
	ADDI	F,1			; INC PTR TO FREE STORAGE BLOCK
	CAILE	F,AFSBLK+ROUND		; SKIP IF STILL IN RANGE
	FATAL	FREE STORAGE BLOCK OVERFLOW
SALV4:	MOVEI	D,0			; RESET COUNT
	MOVEI	E,1(C)			; AND PTR TO BEGINNING OF FREE STORAGE BLOCK
SALV7:	ADDI	C,1
	CAILE	C,-1(A1)		; SKIP IF NOT FINISHED
	JRST	DONSAL
	ADDI	B,1
	CAIGE	B,40			; SKIP IF HIT TOP
	JRST	SALV5
	ADDI	A,1			; GO TO NEXT WORD
	HRLI	A,440100		; POINT TO BEGINNING OF WORD
	JRST	SALV6
SALV3:	ADDI	D,1
	JRST	SALV7
DONSAL:	JUMPE	D,DONSA1		; SEE IF MORE FREE STORAGE
	HRLM	D,(F)			; SMASH IT IN
	HRRM	E,(F)
	AOS	AFSBLK
DONSA1:	MAPIN	IMAPCH,[WRITP?[1]?FSBLKN]
	MOVEI	A1,FSBLKN		; ARG TO SNDOUT
	PUSHJ	P,SNDOUT		; SEND OUT THE FREE STORAGE LIST
	POPJ	P,			; LEAVE WER'RE ALL DONE



; THIS IS THE MARK ROUTINE USED BY THE SALVAGER.  IT TURNS A BIT ON IN THE
; BITVEC TO INDICATE THAT A PAGE IS IN USE.  EACH WORD IN THE BITVEC STORES
; 32 ENTRIES.
; MARK TAKES TWO ARGUMENTS  A1==BEGINNING OF BLOCK  A2==LENGTH OF BLOCK
; MARKX SETS THE LENGTH FIELD TO 1

MARKX:	IMUL	A1,DIRLNT
	MOVE	A2,DIRLNT
MARK:	MOVE	A,A1			; GET A COPY OF THE BLOCK #
	ASH	A,-5			; GET OFFSET INTO TABLE
	ADDI	A,BITVEC		; GET REAL POINTER TO BITVEC
	MOVE	B,A1			; CALCULATE MARKER
	ANDI	B,37			; AMOUNT TO LSH
	MOVSI	C,400000
	MOVNS	B			; BUILD LSH COMMAND
	HRRZS	B
	IOR	B,[LSH C,0]
	XCT	B
MARK1:	IORM	C,(A)			; NOW FIRST IS MARKED
	SOJLE	A2,CPOPJ		; DEC COUNT AND LEAVE IF DONE
	LSH	C,-1			; LSH MARKER
	MOVE	D,C			; SEE IF AT END OF WORD
	ANDI	D,17
	JUMPE	D,MARK1
	MOVSI	C,400000		; RESET UP POINTER
	ADDI	A,1			; INC POINTER INTO BITVEC
	CAILE	A,BITEND		; SKIP IF STILL IN TABLE
	FATAL	BIT TABLE OVERFLOW
	JRST	MARK1			; LOOP BACK AND MARK



; ADFILE IS A ROUTINE TO KEEP A FILE OF THINGS ADDED TO THE DATA BASE.
; THE FORMAT OF THE FILE ('ADDED FILES') IS AS FOLLOWS.  THERE ARE FIELDS
; STARTED WITH A 0.  THE SECOND WORD OF EACH FIELD IS THE TYPE OF FILES
; (I.E. SAV OR FIXUP) AND THEN THE STUFF THAT IS USUALLY FOUND IN THE SPLAN
; FILES.

ADFILE:	CAMN	A1,[SIXBIT /SAV/]		; SKIP IF NOT SAV
	JRST	ADSAV				; ADD SPLAN FILE
	CAMN	A1,[SIXBIT /FIXUP/]		; SKIP IF NOT FIXUP
	JRST	ADFIX				; ADD FPLAN FILE
	FATAL	BAD ARG TO ADFILE
ADSAV:	PUSHJ	P,GETEND			; GET TO END OF 'ADDED FILES'
	OPEN	RCHAN,[READ?WRKDIR?[SIXBIT /SPLAN/]?CDATE]
	JRST	CNTOPN
	PUSHJ	P,ADDEND			; ADD TO FILE
	POPJ	P,
ADFIX:	PUSHJ	P,GETEND			; GET TO END OF FILE
	OPEN	RCHAN,[READ?WRKDIR?[SIXBIT /FPLAN/]?CDATE]
	JRST	CNTOPN
	PUSHJ	P,ADDEND
	POPJ	P,

GETEND:	OPEN	TCHAN,[WRITEO?WRKDIR?[SIXBIT /ADDED/]?[SIXBIT /FILES/]]
	JRST	GETEN1
	FILLEN	TCHAN,RCL
	ACCESS	TCHAN,RCL
	POPJ	P,

GETEN1:	OPEN	TCHAN,[WRITE?WRKDIR?[SIXBIT /ADDED/]?[SIXBIT /FILES/]]
	JRST	CNTOPN
	POPJ	P,

ADDEND:	OUTPUT	[[TCHAN]?[-1,,[0]]]
	OUTPUT	[[TCHAN]?[-1,,A1]]
	FILLEN	RCHAN,RCL
	MOVE	A,RCL
	JUMPE	A,CLFLS
	MOVNI	A,(A)				; GET NEGATIVE
	HRLZI	A,(A)
ADDELP:	INPUT	[[RCHAN]?[-2,,RCL]] ; NOW READ IN ONE NAME AT A TIME
	JFCL
	OUTPUT	[[TCHAN]?[-2,,RCL]]
	ADD	A,[2,,2]			; INCREMENT A
	JUMPL	A,ADDELP
CLFLS:	CLOSE	RCHAN,
	CLOSE	TCHAN,
	POPJ	P,

; SETFILE IS USED TO MAINTAIN THE ADDED FILES.
; IF A1=-1 THEN RENAME ADDED FILES TO ADDED > AND CREATE A NEW ADDED FILES
; IF A1= 0 THEN DELETE ADDED FILE

SETFIL:	DELETE	[WRKDIR?[SIXBIT /ADDED/]?[SIXBIT /FILE/]]
	JRST	RENCHK
	JUMPL	A1,RENFIL
	POPJ	P,
RENCHK:	SKIPL	A1
	POPJ	P,
RENFIL:	RENNAM	[WRKDIR
		 [SIXBIT /ADDED/]
		 [SIXBIT /FILES/]
		 [SIXBIT /ADDED/]
		 [SIXBIT /FILE/]]
	FATAL RENAME FAILED
	OPEN	TCHAN,[WRITE?WRKDIR?[SIXBIT /ADDED/]?[SIXBIT /FILES/]]
	JRST	CNTOPN
	OUTPUT	[[TCHAN]?[-1,,[0]]]
	CLOSE	TCHAN,
	POPJ	P,

CNTOPN:	FATAL	CANT OPEN FILE

