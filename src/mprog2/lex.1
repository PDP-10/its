<PACKAGE "LEX">

<ENTRY LEXTABLE LEXID>

<ENTRY LEX-LOOKUP LEX-INSERT LEX-GET LEX-COMPARE LEX-DELETE>

<ENTRY LEX-FIX-STRING-TBL LEX-FIX-MASTER-TBL>

<ENTRY MAKELST LSTINSERT LSTDELETE LSTOPS LSTLOOKUP LSTEVAL LSTPOSSYM LSTPRTSYMS
	LSTEXACT LSTGETNAME LSTGETVAL LSTGETIVAL LSTALLPOS>

<ENTRY LEX-SCRATCH-STRING>

<NEWTYPE LEXID WORD>

<NEWTYPE LEXTABLE VECTOR '<VECTOR	<OR UVECTOR FALSE>
					<OR UVECTOR FALSE>
					<OR UVECTOR FALSE>
					<OR UVECTOR FALSE>>>

<SETG LEX-SCRATCH-STRING <ISTRING 200 !"  >>

<SETG LHALFBITS <BITS 18 18>>


<USE "CALSYM">


<DEFINE LEX-FIX-MASTER-TBL (LXTBL)
#DECL ((LXTBL) LEXTABLE)
<COND	(<TYPE? <1 .LXTBL> UVECTOR>
	<PUT .LXTBL 4 ![!<1 .LXTBL>!]>)>>


<DEFINE LEX-FIX-STRING-TBL (LXTBL)
#DECL ((LXTBL) LEXTABLE)
<COND	(<TYPE? <3 .LXTBL> UVECTOR>
	<COND	(<TYPE? <2 .LXTBL> UVECTOR>
		<PUT .LXTBL 2 ![!<CHUTYPE <2 .LXTBL> WORD>
				!<CHUTYPE <3 .LXTBL> WORD>!]>)
		(<PUT .LXTBL 2 <3 .LXTBL>>)>
	<PUT .LXTBL 3 <>>
	<PUT <2 .LXTBL> 1 <PUTBITS <1 <2 .LXTBL>> ,LHALFBITS -1>>)>
.LXTBL>



<DEFINE MAKELST (TITLE CONTENTS "OPTIONAL" (KILLER <>)
				"AUX"
				(LNT </ <LENGTH .CONTENTS> 2>)
				(CNT 0)
				(TBL <LEXTABLE>)
				(VCT [.TBL <>])
				(STBL <CHTYPE [LSTOPS .VCT .TITLE .KILLER] SYMTABLE>))
#DECL ((TITLE) STRING
	(CONTENTS) <OR <VECTOR [REST STRING ANY]> FALSE>
	(KILLER) ANY
	(CNT LNT) FIX
	(TBL) LEXTABLE
	(VCT) <VECTOR LEXTABLE <OR VECTOR FALSE>>
	(STBL) SYMTABLE)
<COND	(<TYPE? .CONTENTS VECTOR>
	<PUT .VCT 2 <REST <IVECTOR .LNT> .LNT>>
	<PUT .TBL 1 <REST <CHUTYPE <IUVECTOR .LNT> LEXID> .LNT>>
	<REPEAT ((V .CONTENTS))
	#DECL ((V) <VECTOR [REST STRING ANY]>)
	<COND	(<EMPTY? .V> <RETURN>)
		(<TYPE? <1 .V> STRING>
		<SET CNT <+ .CNT 1 </ <LENGTH <1 .V>> 5>
				<OR <AND <0? <MOD <LENGTH <1 .V>> 5>> 0> 1>>>)
		(<ERROR NOT-STRING/VALUE-PAIRS!-ERRORS>)>
	<SET V <REST .V 2>>>
	<PUT .TBL 3 <REST <IUVECTOR <+ 1 .CNT> #WORD *0*> .CNT>>
	<REPEAT ((V .CONTENTS))
	#DECL ((V) <VECTOR [REST STRING ANY]>)
	<COND	(<EMPTY? .V> <RETURN>)>
	<LSTINSERT .STBL <1 .V> <2 .V>>
	<SET V <REST .V 2>>>
	<PUT .TBL 2 <3 .TBL>>
	<PUT .TBL 3 <>>)>
.STBL>



<DEFINE LSTOPS (OPC "TUPLE" T "AUX" (LNT <LENGTH .T>))
#DECL ((OPC LNT) FIX (T) <TUPLE ANY>)
<COND	(<==? 1 .OPC>
	<AND	<==? 4 .LNT>
		<LSTLOOKUP <1 .T> <2 .T> <3 .T> <4 .T>>>)
	(<==? 2 .OPC>
	<AND	<==? 2 .LNT>
		<LSTEVAL <1 .T> <2 .T>>>)
	(<==? 3 .OPC>
	<COND	(<==? 3 .LNT> <LSTPOSSYM <1 .T> <2 .T> <3 .T> <> <>>)
		(<==? 4 .LNT> <LSTPOSSYM <1 .T> <2 .T> <3 .T> <4 .T> <>>)
		(<==? 5 .LNT> <LSTPOSSYM <1 .T> <2 .T> <3 .T> <4 .T> <5 .T>>)>)
	(<==? 4 .OPC>
	<AND	<==? 1 .LNT>
		<LSTPRTSYMS <1 .T>>>)
	(<==? 5 .OPC>
	<AND	<==? 2 .LNT>
		<LSTEXACT <1 .T> <2 .T>>>)
	(<==? 6 .OPC>
	<AND	<==? 3 .LNT>
		<LSTALLPOS <1 .T> <2 .T> <3 .T>>>)>>



<DEFINE LSTGETNAME (TBL ID "OPTIONAL" (STR <>) "AUX" VAL)
#DECL ((TBL) SYMTABLE (ID) LEXID (STR) <OR STRING FALSE> (VAL) ANY)
<COND	(<AND	<TYPE? .TBL SYMTABLE>
		<TYPE? <SET VAL <2 .TBL>> VECTOR>
		<==? 2 <LENGTH .VAL>>
		<TYPE? <1 .VAL> LEXTABLE>>
	<LEX-GET <1 .VAL> .ID .STR>)>>


;"####################################################################
#####################################################################"

<TITLE LEXTABLE>

<DECLARE ("VALUE" LEXTABLE)>

	<PUSHJ	P* ILEXTABLE>
	<JRST	FINIS>

<INTERNAL-ENTRY ILEXTABLE 0>

	<SUBM	M* (P)>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* [4]>
	<PUSH	TP* <TYPE-WORD FALSE>>
	<PUSH	TP* [0]>
	<MCALL	2 IVECTOR>
	<MOVEI	O* <TYPE-CODE LEXTABLE>>
	<PUTYP	O* A>
	<JRST	MPOPJ>


;"####################################################################
#####################################################################"


<SUB-ENTRY LEX-LOOKUP ("VALUE" <OR LEXID FALSE> LEXTABLE STRING "OPTIONAL" FIX)>

	<MOVEI	A* 0>
	<PUSH	TP* (AB)>
	<ADDI	A* 1>
	<AOBJN	AB* HERE -2>
	<CAIE	A* 6>
	<JRST	LKUP2>
	<PUSHJ	P* ILEX-LOOKUP3>
	<JRST	FINIS>
LKUP2	<PUSHJ	P* ILEX-LOOKUP2>
	<JRST	FINIS>


<INTERNAL-ENTRY ILEX-LOOKUP2 2>

	<SUBM	M* (P)>
	<HRRZ	A* -1(TP)>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* A>
	<JRST	ILEX-LOOKUP>


<INTERNAL-ENTRY ILEX-LOOKUP3 3>

	<SUBM	M* (P)>
ILEX-LOOKUP	<GETYP	O* -5(TP)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	NOTLEXTBL>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	BADARG>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE FIX>>
	<JRST	BADARG>
	<DMOVE	A* -5(TP)>
	<DMOVE	C* -3(TP)>
	<MOVE	E* (TP)>
	<PUSHJ	P* LEXSEARCH>
	<JUMPLE	C* LKUPFLS>
	<MOVEI	A* 0>
	<MOVEI	O* <TYPE-CODE LEXID>>
	<PUTYP	O* A>
	<MOVE	B* (B)>
LKUPRET	<SUB	TP* [<6(6)>]>
	<JRST	MPOPJ>
LKUPFLS	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEI	B* 0>
	<JRST	LKUPRET>


;"####################################################################
#####################################################################"


<SUB-ENTRY LEX-INSERT ("VALUE" <OR LEXID FALSE> LEXTABLE STRING "OPTIONAL" FIX)>


	<MOVEI	A* 0>
	<PUSH	TP* (AB)>
	<ADDI	A* 1>
	<AOBJN	AB* HERE -2>
	<CAIE	A* 6>
	<JRST	LINS2>
	<PUSHJ	P* ILEX-INSERT3>
	<JRST	FINIS>
LINS2	<PUSHJ	P* ILEX-INSERT2>
	<JRST	FINIS>


<INTERNAL-ENTRY ILEX-INSERT2 2>

	<SUBM	M* (P)>
	<HRRZ	A* -1(TP)>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* A>
	<JRST	ILEX-INSERT>


<INTERNAL-ENTRY ILEX-INSERT3 3>

	<SUBM	M* (P)>
ILEX-INSERT	<PUSHJ	P* LINSUV>
	<SUB	TP* [<6(6)>]>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	MPOPJ>
	<MOVE	A* <TYPE-WORD LEXID>>
	<MOVE	B* (B)>
	<JRST	MPOPJ>



;"####################################################################
#####################################################################"


;"-5(TP)/ LEXTABLE
-3(TP)/ STRING
-1(TP)/ FIX, length of string

==>	A&B/ UVECTOR, cptr to slot of LEXID tbl where LEXID of STRING
		either existed or was inserted."
LINSUV	<SUBM	M* (P)>
	<GETYP	O* -5(TP)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	NOTLEXTBL>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	BADARG>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE FIX>>
	<JRST	BADARG>
	<DMOVE	A* -5(TP)>
	<DMOVE	C* -3(TP)>
	<MOVE	E* (TP)>
	<PUSHJ	P* LEXSEARCH>
	<SKIPLE	C>
	<JRST	MPOPJ>	;"Returns cptr to slot in LEXID tbl where LEXID exists"
;"Here if string doesn't exist in table, insert it
A&B/ cptr to slot of UVECTOR where the LEXID belongs"
	<DPUSH	TP* A>
	<DMOVE	A* -7(TP)>
	<GETYP	O* 6(B)>
	<CAIE	O* <TYPE-CODE UVECTOR>>		;"Skips if a master LEXID tbl exists"
	<JRST	LINSNOMAST>
;"Here if a master LEXID tbl exists, search it"
	<DMOVE	C* -5(TP)>
	<MOVE	E* -2(TP)>
	<PUSHJ	P* MLEXSEARCH>
	<JUMPLE	C* LINSMAST>		;"Jumps if not in master either"
;"Here if in master LEXID tbl"
	<MOVE	B* (B)>		;"B/ LEXID from master table"
	<JRST	LINSID>

;"Here if string not in table and no master LEXID table exists"
LINSNOMAST	<DMOVE	A* -7(TP)>
	<DMOVE	C* -5(TP)>
	<MOVE	E* -2(TP)>
	<PUSHJ	P* LEX-INSERT-STRING>
;"B/ LEXID of string inserted into LEXTABLE's string tbl
(TP)/ cptr to slot in LEXID where new LEXID belongs"
LINSID	<MOVE	E* B>		;"E/ LEXID of new string"
	<DPOP	TP* C>		;"C&D/ cptr to slot in LEXID tbl where new LEXID
					belongs (or FALSE)"
	<DMOVE	A* -5(TP)>
	<PUSHJ	P* LEX-INSERT-LEXID>
	<JRST	MPOPJ>	;"Returns cptr to slot in LEXID tbl where new LEXID exists"

;"Here if master LEXID table exists, but string not in it either."
LINSMAST <DPUSH	TP* A>	;"Saves cptr to slot in master tbl where new LEXID belongs"
	<DMOVE	A* -9(TP)>
	<DMOVE	C* -7(TP)>
	<MOVE	E* -4(TP)>
	<PUSHJ	P* LEX-INSERT-STRING>
;"A&B/ LEXID of inserted string"
	<DPOP	TP* C>		;"C&D/ cptr to slot in master LEXID tbl"
	<MOVE	E* B>		;"E/ new LEXID"
	<DPUSH	P* A>
	<DMOVE	A* -7(TP)>		;"A&B/ LEXTABLE"
	<PUSHJ	P* MLEX-INSERT-LEXID>
	<DPOP	P* A>
	<JRST	LINSID>





;"####################################################################
#####################################################################"


<SUB-ENTRY LEX-DELETE ("VALUE" <OR LEXID FALSE> LEXTABLE STRING "OPTIONAL" FIX)>


	<MOVEI	A* 0>
	<PUSH	TP* (AB)>
	<ADDI	A* 1>
	<AOBJN	AB* HERE -2>
	<CAIE	A* 6>
	<JRST	LDEL2>
	<PUSHJ	P* ILEX-DELETE3>
	<JRST	FINIS>
LDEL2	<PUSHJ	P* ILEX-DELETE2>
	<JRST	FINIS>


<INTERNAL-ENTRY ILEX-DELETE2 2>

	<SUBM	M* (P)>
	<HRRZ	A* -1(TP)>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* A>
	<JRST	ILEX-DELETE>


<INTERNAL-ENTRY ILEX-DELETE3 3>

	<SUBM	M* (P)>
ILEX-DELETE	<PUSHJ	P* LDELUV>
	<SUB	TP* [<4(4)>]>
	<DPOP	TP* A>
	<JRST	MPOPJ>



;"####################################################################
#####################################################################"


;"-5(TP)/ LEXTABLE
-3(TP)/ STRING
-1(TP)/ FIX, length of string

==>	A/ offset of removed LEXID"

LDELUV	<SUBM	M* (P)>
	<GETYP	O* -5(TP)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	NOTLEXTBL>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	BADARG>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE FIX>>
	<JRST	BADARG>
	<DMOVE	A* -5(TP)>
	<DMOVE	C* -3(TP)>
	<MOVE	E* (TP)>
	<PUSHJ	P* LEXSEARCH>
	<JUMPLE	C* LDELNOMCH>		;"jumps if string not found"
	<DMOVE	C* A>
	<DMOVE	A* -5(TP)>
	<HRRZ	O* D>
	<HRRZ	E* 1(B)>
	<SUB	O* E>		;"O/ offset of LEXID on LEXID tbl"
	<PUSH	P* O>		;"Saves offset on stack"
	<PUSH	P* (D)>		;"Saves LEXID on P-stack"
	<PUSHJ	P* LEX-DELETE-LEXID>
	<DMOVE	A* -5(TP)>
	<POP	P* C>
	<GETYP	O* 6(B)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<PUSHJ	P* LEX-DELETE-STRING>
	<POP	P* A>
	<JRST	MPOPJ>

LDELNOMCH	<HRREI	A* -1>
	<JRST	MPOPJ>



;"####################################################################
#####################################################################"


<SUB-ENTRY LEX-COMPARE ("VALUE" FIX LEXTABLE LEXID STRING FIX)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILEX-COMPARE>
	<JRST	FINIS>

<INTERNAL-ENTRY ILEX-COMPARE 4>

	<SUBM	M* (P)>
	<MOVE	A* -4(TP)>
	<MOVE	B* (TP)>
	<DMOVE	C* -3(TP)>
	<SUB	TP* [<6(6)>]>
	<DPUSH	TP* C>
	<MOVEI	C* 0>
	<PUSHJ	P* LEXCOMP>
	<MOVE	B* A>
	<MOVE	A* <TYPE-WORD FIX>>
	<SUB	TP* [<4(4)>]>
	<JRST	MPOPJ>
	

;"####################################################################
#####################################################################"


<SUB-ENTRY LEX-GET ("VALUE" <OR STRING FALSE> LEXTABLE LEXID <OR STRING FALSE>)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILEX-GET>
	<JRST	FINIS>

<INTERNAL-ENTRY ILEX-GET 3>

	<SUBM	M* (P)>
	<GETYP	O* -1(TP)>
	<CAIN	O* <TYPE-CODE STRING>>
	<JRST	LEXGET1>
;"Here if have to build string"
	<HLRZ	A* -2(TP)>
	<IDIVI	A* 5>
	<SKIPE	B>
	<AOS	A>
	<PUSH	P* A>
	<MOVEI	O* IBLOCK>
	<PUSHJ	P* RCALL>
	<POP	P* A>
	<IMULI	A* 5>
	<MOVEI	O* <TYPE-CODE STRING>>
	<PUTYP	O* A>
	<HLRE	C* B>
	<SUBM	B* C>
	<MOVEI	O* <TYPE-CODE CHARACTER>>
	<PUTYP	O* (C)>
	<SUBI	B* 1>
	<HRLI	B* *010700*>
	<DMOVEM	A* -1(TP)>
LEXGET1	<MOVE	E* -4(TP)>
	<HLRE	D* 3(E)>
	<MOVMS	D>
	<HRRZ	A* -2(TP)>
	<CAML	A* D>
	<JRST	LEXGETUPD>
	<ADD	A* 3(E)>
LEXGET2	<HRRZ	B* -1(TP)>
	<IDIVI	B* 5>
	<SKIPE	C>
	<ADDI	B* 1>
	<HRRZ	C* (A)>
	<MOVE	E* C>
	<IDIVI	C* 5>
	<SKIPE	D>
	<ADDI	C* 1>
	<SUB	B* C>
	<SKIPGE	B>
	<JRST	TOOSMALL>
	<ADD	B* (TP)>
	<HLRZ	O* (TP)>
	<CAIN	O* *010700*>
	<ADDI	B* 1>
	<HRLI	D* 1(A)>
	<HRR	D* B>
	<ADD	C* B>
	<BLT	D* -1(C)>
	<MOVE	A* E>
	<MOVEI	O* <TYPE-CODE STRING>>
	<PUTYP	O* A>
	<SUBI	B* 1>
	<HRLI	B* *010700*>
	<SUB	TP* [<6(6)>]>
	<JRST	MPOPJ>


LEXGETUPD	<GETYP	O* 4(E)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	LEXGETFLS>
	<HLRE	C* 5(E)>
	<MOVMS	C>
	<SUB	A* D>
	<CAML	A* C>
	<JRST	LEXGETFLS>
	<ADD	A* 5(E)>
	<JRST	LEXGET2>
	
LEXGETFLS	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEI	B* 0>
	<SUB	TP* [<6(6)>]>
	<JRST	MPOPJ>


TOOSMALL	<DMOVE	A* -1(TP)>
	<DPUSH	TP* <PQUOTE SUPPLIED-STRING-TOO-SMALL!-ERRORS>>
	<DPUSH	TP* A>
	<MCALL	2 ERROR>
	<JRST	TOOSMALL>

NOTLEXTBL	<DPUSH	TP*  <PQUOTE FIRST-ARG-NOT-A-LEXTABLE!-ERRORS>>
	<MCALL	1 ERROR>
	<JRST	NOTLEXTBL>

BADARG	<DPUSH	TP* <PQUOTE ILLEGAL-ARGUMENT!-ERRORS>>
	<MCALL	1 ERROR>
	<JRST	BADARG>



;"####################################################################
#####################################################################"


<SUB-ENTRY LSTEXACT ("VALUE" <OR SYMBOL FALSE> STRING
			<VECTOR LEXTABLE <OR VECTOR UVECTOR FALSE>>)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILSTEXACT>
	<JRST	FINIS>

<INTERNAL-ENTRY ILSTEXACT 2>

	<SUBM	M* (P)>
	<MOVE	E* (TP)>
	<DMOVE	A* (E)>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	EXACTFLS>
	<DMOVE	C* -3(TP)>
	<HRRZ	E* C>
	<PUSHJ	P* LEXSEARCH>
	<JUMPLE	C* EXACTFLS>
	<HRRZ	C* B>		;"C/ ptr to id's slot in LEXID table"
	<MOVE	E* (TP)>
	<DMOVE	A* (E)>
	<HRRZ	D* 1(B)>		;"D/ ptr to beginning of LEXID table"
	<SUB	C* D>		;"C/ offset of id on LEXID table"
;"A&B/ LEXTABLE
C/ offset of LEXID"
LSTBLDSYM	<HLRE	D* 1(B)>
	<MOVMS	D>
	<CAMG	D* C>
	<JRST	OUT-OF-RANGE>
	<PUSH	P* C>
	<DPUSH	TP* A>
	<PUSH	TP* <TYPE-WORD LEXID>>
	<ADD	C* 1(B)>
	<PUSH	TP* (C)>
	<PUSH	TP* <TYPE-WORD FALSE>>
	<PUSH	TP* [0]>
	<MCALL	3 LEX-GET>
	<POP	P* C>		;"C/ offset of value slot on value table"
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	EXACTFLS>
	<DPUSH	TP* A>
	<MOVE	E* -2(TP)>
	<GETYP	O* 2(E)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<CAIN	O* <TYPE-CODE UVECTOR>>
	<SKIPA>
	<JRST	EXACTNOVAL>
	<HLRE	D* 3(E)>
	<MOVMS	D>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<ASH	D* -1>
	<CAMG	D* C>
	<JRST	EXACTNOVAL>
	<MOVE	D* 3(E)>		;"D/ cptr to value table"
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	EXACTUVAL>
	<ASH	C* 1>
	<ADD	D* C>		;"D/ ptr to value slot of id"
	<DPUSH	TP* (D)>
EXACTVAL	<MCALL	2 VECTOR>
	<MOVE	A* <TYPE-WORD SYMBOL>>
EXACTRET	<SUB	TP* [<4(4)>]>
	<JRST	MPOPJ>

EXACTNOVAL	<MOVE	D* 1(E)>
	<MOVE	D* 1(D)>		;"D/ cptr to LEXID tbl"
	<ADD	D* C>
	<PUSH	TP* <TYPE-WORD LEXID>>
	<PUSH	TP* (D)>
	<JRST	EXACTVAL>

EXACTUVAL	<ADD	C* D>
	<MOVE	B* (C)>
	<HLRE	C* D>
	<SUBM	D* C>
	<GETYP	O* (C)>
	<MOVS	A* O>
	<DPUSH	TP* A>
	<JRST	EXACTVAL>

EXACTFLS	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEI	B* 0>
	<JRST	EXACTRET>

OUT-OF-RANGE <DPUSH	TP* <PQUOTE ARG-OUT-OF-RANGE!-ERRORS>>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* C>
	<MCALL	2 ERROR>
	<JRST	OUT-OF-RANGE>



;"####################################################################
#####################################################################"


<SUB-ENTRY LSTGETVAL ("VALUE" ANY STRING FIX SYMTABLE)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILSTGETVAL>
	<JRST	FINIS>


<INTERNAL-ENTRY ILSTGETVAL 3>

	<SUBM	M* (P)>
	<MOVE	E* (TP)>
	<MOVE	E* 3(E)>	;"E/ cptr to vector with LEXTABLE and value table"
	<DMOVE	A* (E)>
	<DMOVE	C* -5(TP)>
	<MOVE	E* -2(TP)>
	<PUSHJ	P* LEXSEARCH>
	<JUMPLE	C* LGVNOVAL>
;"A&B/ cptr to slot of LEXID tbl where matching LEXID exists"
	<MOVE	E* (TP)>
	<MOVE	E* 3(E)>
	<MOVE	D* 1(E)>		;"D/ cptr to LEXTABLE"
	<HRRZ	C* 1(D)>
	<SUBI	B* (C)>			;"B/ ...,,offset of LEXID"
	<GETYP	O* 2(E)>
	<CAIN	O* <TYPE-CODE VECTOR>>
	<JRST	LGVCTVAL>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	LGVNOVAL>
	<ADD	B* 3(E)>
	<HLRE	D* 3(E)>
	<MOVMS	D>
	<ADD	D* 3(E)>
	<HRRZS	D>
	<CAIG	D* (B)>
	<JRST	LGVNOVAL>
	<GETYP	O* (D)>
	<MOVEI	A* 0>
	<PUTYP	O* A>
	<MOVE	B* (B)>
	<JRST	LGVRET>

LGVCTVAL	<HRRZS	B>
	<IMULI	B* 2>
	<HRLS	B>
	<ADD	B* 3(E)>
	<JUMPGE	B* LGVNOVAL>
	<DMOVE	A* (B)>
	<JRST	LGVRET>

LGVNOVAL	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEI	B* 0>
LGVRET	<SUB	TP* [<6(6)>]>
	<JRST	MPOPJ>


;"####################################################################
#####################################################################"


<SUB-ENTRY LSTGETIVAL ("VALUE" <OR VECTOR UVECTOR FALSE> SYMTABLE <OR LEXID STRING>)>


	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILSTGETIVAL>
	<JRST	FINIS>


<INTERNAL-ENTRY ILSTGETIVAL 2>

	<SUBM	M* (P)>
	<DMOVE	A* -1(TP)>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE LEXID>>
	<JRST	LGIVTRYSTR>
	<MOVE	E* -2(TP)>
	<MOVE	E* 3(E)>	;"E/ cptr to vector with LEXTABLE and value table"
	<DPUSH	TP* (E)>	;"pushes LEXTABLE onto stack"
	<PUSH	TP* -3(TP)>
	<PUSH	TP* -3(TP)>
	<MOVE	E* <MQUOTE '%<RGLOC LEX-SCRATCH-STRING T>>>
	<ADD	E* GLOTOP 1 (TVP)>
	<DPUSH	TP* (E)>	;"pushes scratch string onto stack"
	<MCALL	3 LEX-GET>
	<GETYP	O* A>
LGIVTRYSTR	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	LGIVNOVAL>
	<DMOVE	C* A>
	<MOVE	E* -2(TP)>
	<MOVE	E* 3(E)>
	<DMOVE	A* (E)>		;"A&B/ LEXTABLE"
	<HRRZ	E* C>
	<PUSHJ	P* LEXSEARCH>
	<JUMPLE	C* LGIVNOVAL>
;"A&B/ cptr to slot of LEXID tbl where matching LEXID exists"
	<MOVE	E* -2(TP)>
	<MOVE	E* 3(E)>
	<MOVE	D* 1(E)>		;"D/ cptr to LEXTABLE"
	<HRRZ	C* 1(D)>
	<SUBI	B* (C)>			;"B/ ...,,offset of LEXID"
	<GETYP	O* 2(E)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<CAIN	O* <TYPE-CODE VECTOR>>
	<SKIPA>
	<JRST	LGIVNOVAL>
	<CAIN	O* <TYPE-CODE VECTOR>>
	<ASH	B* 1>
	<HRLS	B>
	<ADD	B* 3(E)>
	<JUMPGE	B* LGIVNOVAL>
	<MOVE	A* 2(E)>
	<JRST	LGIVRET>

LGIVNOVAL	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEI	B* 0>
LGIVRET	<SUB	TP* [<4(4)>]>
	<JRST	MPOPJ>


;"####################################################################
#####################################################################"


<SUB-ENTRY LSTEVAL ("VALUE" <OR SYMBOL FALSE> FIX
			<VECTOR LEXTABLE <OR VECTOR UVECTOR FALSE>>)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILSTEVAL>
	<JRST	FINIS>

<INTERNAL-ENTRY ILSTEVAL 2>

	<SUBM	M* (P)>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE FIX>>
	<JRST	BADARG>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	BADARG>
	<MOVE	E* (TP)>
	<DMOVE	A* (E)>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	BADARG>
	<MOVE	C* -2(TP)>
	<JRST	LSTBLDSYM>


;"####################################################################
#####################################################################"


<SUB-ENTRY LSTINSERT ("VALUE" <OR LEXID FALSE> SYMTABLE STRING
				"OPTIONAL" ANY FIX)>
	<MOVE	A* AB>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<HRRZ	B* AB>
	<SUBI	B* (A)>
	<CAIN	B* 8>
	<JRST	LSTI4>
	<CAIE	B* 6>
	<JRST	LSTI2>
	<PUSHJ	P* ILSTINSERT3>
	<JRST	FINIS>

LSTI2	<PUSHJ	P* ILSTINSERT2>
	<JRST	FINIS>

LSTI4	<PUSHJ	P* ILSTINSERT4>
	<JRST	FINIS>

<INTERNAL-ENTRY ILSTINSERT2 2>

	<PUSH	TP* <TYPE-WORD UNBOUND>>
	<PUSH	TP* [-1]>
	<JRST	ILSTINSERT3>

<INTERNAL-ENTRY ILSTINSERT4 4>

	<SUBM	M* (P)>
	<DPOP	TP* A>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE FIX>>
	<JRST	LSTINS1>
	<HRRZ	C* -3(TP)>
	<CAIGE	C* B>
	<JRST	LSTIN1>
	<PUSH	P* B>
	<JRST	LSTIN2>


<INTERNAL-ENTRY ILSTINSERT3 3>

	<SUBM	M* (P)>
LSTIN1	<HRRZ	O* -3(TP)>
	<PUSH	P* O>
LSTIN2	<GETYP	O* -5(TP)>
	<CAIE	O* <TYPE-CODE SYMTABLE>>
	<JRST	BADARG>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	BADARG>
	<MOVE	E* -4(TP)>
	<GETYP	O* 2(E)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	BADARG>
	<MOVE	D* 3(E)>	;"cptr to VECTOR"
	<GETYP	O* (D)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	BADARG>
	<DMOVE	A* (D)>
	<DMOVE	C* -3(TP)>
	<DPUSH	TP* A>
	<DPUSH	TP* C>
	<PUSH	TP* <TYPE-WORD FIX>>
	<POP	P* E>		;"E/ length of string"
	<PUSH	TP* E>
	<PUSHJ	P* LINSUV>
	<SUB	TP* [<6(6)>]>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	LSTINSFLS>
	<MOVE	E* -4(TP)>		;"E/ cptr to SYMTABLE"
	<MOVE	D* 3(E)>
	<GETYP	O* 2(D)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<CAIN	O* <TYPE-CODE VECTOR>>
	<SKIPA>
	<JRST	LSTINSNOVAL>		;"Jumps if no value vector (or uvector)"
	<GETYP	A* -1(TP)>
	<CAIE	A* <TYPE-CODE UNBOUND>>
	<JRST	HERE 4>
	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEM	A* -1(TP)>
	<SETZM	(TP)>
	<HLRE	C* 3(D)>
	<MOVMS	C>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<ASH	C* -1>
	<MOVE	A* 1(D)>		;"A/ cptr to LEXTABLE"
	<HLRE	A* 1(A)>
	<MOVMS	A>
	<CAIE	A* 1(C)>		;"Skips if LEXID tbl 1 longer than value tbl"
	<JRST	LSTINSRET>
;"Here if need to insert new value into value tbl"
	<PUSH	TP* <TYPE-WORD UVECTOR>>
	<PUSH	TP* B>
	<MOVE	E* 1(D)>		;"E/ cptr to LEXTABLE"
	<HRRZ	C* 1(E)>		;"C/ ptr to beginning of LEXID table"
	<SUBM	B* C>
	<HRRZS	C>			;"C/ offset of new LEXID on LEXID tbl"
	<MOVE	B* 3(D)>
	<HLRE	A* B>
	<SUBM	B* A>
	<HLRZ	B* 1(A)>
	<HLRE	A* 3(D)>
	<MOVMS	A>
	<ADDI	A* 3>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<ADDI	A* 1>
	<CAMGE	B* A>		;"Skips if enough slush space for new value"
	<JRST	LSTINSNEWVAL>
;"O/ type code of value vector/uvector
C/ offset of new value
D/ cptr to two-element vector"
	<MOVE	B* 3(D)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	LSTINS1>
	<SUB	B* [<2(2)>]>
	<ASH	C* 1>
	<SKIPA>
LSTINS1	<SUB	B* [<1(1)>]>
	<JUMPE	C* LSTINS2>
	<HRL	A* 3(D)>
	<HRR	A* B>
	<HRRZ	E* B>
	<ADDI	E* (C)>
	<BLT	A* -1(E)>
LSTINS2	<HRLS	C>
	<ADD	C* B>		;"C/ cptr to slot for new value"
	<MOVEM	B* 3(D)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	LSTINS3>
	<DMOVE	A* -3(TP)>
	<DMOVEM	A* (C)>
LSTINSPOP	<DPOP	TP* A>
;"Here to return LEXID of new/old symbol
A&B/ cptr to slot in LEXID tbl where LEXID exists"
LSTINSRET	<SUB	TP* [<6(6)>]>
	<MOVE	A* <TYPE-WORD LEXID>>
	<MOVE	B* (B)>
	<JRST	MPOPJ>

LSTINS3	<MOVE	A* -2(TP)>
	<MOVEM	A* (C)>
	<JRST	LSTINSPOP>

LSTINSFLS	<SUB	TP* [<6(6)>]>
	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEI	B* 0>
	<JRST	MPOPJ>

;"Here if SYMTABLE has no value vector/uvector
A&B/ cptr to slot in LEXID tbl where new LEXID is stored
D/ cptr to two-element VECTOR
E/ cptr to SYMTABLE"
LSTINSNOVAL	<GETYP	O* -1(TP)>
	<CAIN	O* <TYPE-CODE UNBOUND>>
	<JRST	LSTINSRET>		;"Jumps if no value vector/uvector needed"
	<MOVE	E* 1(D)>		;"E/ cptr to LEXTABLE"
	<HLRE	C* 1(E)>
	<MOVMS	C>
	<CAIE	C* 1>
	<JRST	LSTINSERR>
	<DPUSH	TP* A>
	<MOVEI	A* 1>
	<MOVEI	O* IBLOK1>
	<PUSHJ	P* RCALL>
	<MOVE	E* -6(TP)>
	<MOVE	D* 3(E)>
	<DMOVEM	A* 2(D)>
	<DMOVE	C* -3(TP)>
	<DMOVEM	C* (B)>
	<JRST	LSTINSPOP>

;"Here when old value vector/uvector hasn't enough slush space for new value
O/ type code of value vector/uvector
C/ offset of new value
D/ cptr to two-element vector"
LSTINSNEWVAL	<PUSH	P* C>
	<HLRE	A* 3(D)>
	<MOVMS	A>
	<MOVEI	O* IBLOCK>
	<GETYP	C* 2(D)>
	<CAIE	C* <TYPE-CODE VECTOR>>
	<JRST	HERE 3>
	<ASH	A* -1>
	<MOVEI	O* IBLOK1>
	<ADDI	A* 11>
	<PUSHJ	P* RCALL>
	<MOVE	E* -6(TP)>
	<MOVE	D* 3(E)>
	<GETYP	O* 2(D)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<ADD	B* [<10(10)>]>
	<ADD	B* [<10(10)>]>
	<EXCH	B* 3(D)>		;"B/ cptr to old vector/uvector"
	<HLRE	C* B>
	<SUBM	B* C>
	<GETYP	E* (C)>			;"E/ UTYPE of uvector (if it IS a uvector)"
	<HLRE	C* 3(D)>
	<MOVMS	C>
	<ADD	C* 3(D)>	;"C/ ptr to first dope word of new vector/uvector"
	<CAIN	O* <TYPE-CODE UVECTOR>>
	<PUTYP	E* (C)>		;"makes new uvector have same UTYPE as old one"
	<MOVE	C* (P)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<ASH	C* 1>
	<HRLS	C>
	<MOVEM	C* (P)>
	<ADD	C* 3(D)>		;"C/ cptr to slot where new value belongs"
	<HRL	E* B>
	<HRR	E* 3(D)>
	<CAME	C* 3(D)>		;"Skips if new val in first slot"
	<BLT	E* -1(C)>
	<MOVE	E* -2(TP)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	LSTINSTOR>
	<MOVEM	E* 1(C)>
	<MOVE	E* -3(TP)>
	<MOVEM	E* (C)>
	<ADD	C* [<1(1)>]>
	<SKIPA>
LSTINSTOR	<MOVEM	E* (C)>
	<ADD	C* [<1(1)>]>
	<POP	P* E>
	<ADD	B* E>		;"B/ cptr to rest of old value vector"
	<JUMPGE	B* LSTINSPOP>
	<JUMPGE	C* LSTINSPOP>
	<HRL	E* B>
	<HRR	E* C>
	<HLRE	D* C>
	<SUBM	C* D>
	<BLT	E* -1(D)>
	<JRST	LSTINSPOP>


LSTINSERR	<DMOVE	A* -1(TP)>
	<DMOVE	C* -5(TP)>
	<DPUSH	TP* <PQUOTE TRIED-TO-INSERT-VALUE-INTO-VALUELESS-SYMBOL-TABLE!-ERRORS>>
	<DPUSH	TP* A>
	<DPUSH	TP* C>
	<MCALL	3 ERROR>
	<JRST	LSTINSERR>




;"####################################################################
#####################################################################"


<SUB-ENTRY LSTDELETE ("VALUE" <OR SYMTABLE FALSE> SYMTABLE STRING
				"OPTIONAL" ANY)>
	<MOVE	A* AB>
	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<HRRZ	B* AB>
	<SUBI	B* (A)>
	<CAIE	B* 6>
	<JRST	LSTD2>
	<PUSHJ	P* ILSTDELETE3>
	<JRST	FINIS>

LSTD2	<PUSHJ	P* ILSTDELETE2>
	<JRST	FINIS>

<INTERNAL-ENTRY ILSTDELETE2 2>

	<PUSH	TP* <TYPE-WORD UNBOUND>>
	<PUSH	TP* [-1]>
	<JRST	ILSTDELETE3>


<INTERNAL-ENTRY ILSTDELETE3 3>

	<SUBM	M* (P)>
	<GETYP	O* -5(TP)>
	<CAIE	O* <TYPE-CODE SYMTABLE>>
	<JRST	BADARG>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	BADARG>
	<MOVE	E* -4(TP)>
	<GETYP	O* 2(E)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	BADARG>
	<MOVE	D* 3(E)>	;"cptr to VECTOR"
	<GETYP	O* (D)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	BADARG>
	<DMOVE	A* (D)>
	<DMOVE	C* -3(TP)>
	<DPUSH	TP* A>
	<DPUSH	TP* C>
	<PUSH	TP* <TYPE-WORD FIX>>
	<HRRZ	E* C>
	<PUSH	TP* E>
	<PUSHJ	P* LDELUV>
	<SUB	TP* [<6(6)>]>
	<JUMPL	A* LSTDRET>
	<MOVE	E* -4(TP)>		;"E/ cptr to SYMTABLE"
	<MOVE	D* 3(E)>
	<GETYP	O* 2(D)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<CAIN	O* <TYPE-CODE VECTOR>>
	<SKIPA>
	<JRST	LSTDRET>	;"jumps if no VALUE vector or uvector to mung"
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<IMULI	A* 2>
	<HLRE	C* 3(D)>
	<MOVMS	C>		;"C/ length of VALUE vct/uvct"
	<CAML	A* C>
	<JRST	LSTDRET>	;"Jumps if out of range"
	<HRLS	A>
	<ADD	A* 3(D)>		;"A/ cptr to slot to be over-written"
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	LSTDELVCT>		;"if a VECTOR"
LSTDELP1	<CAMN	A* 3(D)>
	<JRST	LSTDELUVF>		;"Jumps if first slot, simple"
	<MOVE	O* -1(A)>
	<MOVEM	O* (A)>
	<SUB	A* [<1(1)>]>
	<JRST	LSTDELP1>

LSTDELUVF	<ADD	A* [<1(1)>]>
	<MOVEM	A* 3(D)>
LSTDRET	<SUB	TP* [<4(4)>]>
	<DPOP	TP* A>
	<JRST	MPOPJ>

LSTDELVCT	<CAMN	A* 3(D)>
	<JRST	LSTDELVCTF>
	<MOVE	O* -1(A)>
	<MOVEM	O* 1(A)>
	<MOVE	O* -2(A)>
	<MOVEM	O* (A)>
	<SUB	A* [<2(2)>]>
	<JRST	LSTDELVCT>
LSTDELVCTF	<ADD	A* [<2(2)>]>
	<MOVEM	A* 3(D)>
	<JRST	LSTDRET>


;"####################################################################
#####################################################################"


<SUB-ENTRY LSTLOOKUP ("VALUE" <OR VECTOR FALSE> STRING FIX <VECTOR LEXTABLE ANY> VECTOR)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILSTLOOKUP>
	<JRST	FINIS>

<INTERNAL-ENTRY ILSTLOOKUP 4>

	<SUBM	M* (P)>
	<GETYP	O* -3(TP)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	BADARG>
	<MOVE	E* -2(TP)>
	<GETYP	O* (E)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	BADARG>
	<DMOVE	A* (E)>
	<DMOVE	C* -7(TP)>
	<MOVE	E* -4(TP)>
	<JUMPE	E* LKPALLMCH>	;"Jumps if key length is zero, all symbols match"
	<PUSHJ	P* LEXTBLSRC>
	<JUMPLE	C* LSTLKPNOMCH>
;"A&B/ cptr to first matching LEXID
C/ # of matches"
LKPMCH	<MOVE	E* (TP)>
	<MOVE	O* <TYPE-WORD FIX>>
	<MOVEM	O* (E)>
	<MOVEM	O* 2(E)>
	<MOVEM	O* 6(E)>
	<CAIG	C* 1>
	<JRST	LSTLKPONEMCH>		;"jumps if only one match"
	<HLRZ	D* (B)>		;"D/ # of characters in matching LEXID"
	<CAMN	D* -4(TP)>
	<JRST	LSTLKPONEMCH>
	<MOVEI	O* 2>		;"more than one partial match"
	<MOVEM	O* 1(E)>
;"Here to find partial match with longest name and the # of chars
beyond the key which all of the partial matches have in common"
	<MOVE	E* B>
	<MOVE	D* C>
	<MOVE	A* -2(TP)>
	<MOVE	A* 1(A)>		;"A/ cptr to LEXTABLE"
	<MOVE	B* (E)>
	<PUSHJ	P* LEX-BPTR>		;"gets bptr to string in A, length in B"
	<PUSH	P* E>
	<PUSH	P* A>
	<PUSH	P* B>
	<PUSH	P* B>
	<SUBI	D* 1>
LKPLONGEST	<MOVE	A* -2(TP)>
	<MOVE	A* 1(A)>
	<MOVE	B* (E)>
	<PUSHJ	P* LEX-BPTR>
	<CAMG	B* -1(P)>		;"skips if longer than longest yet encountered"
	<JRST	HERE 4>
	<EXCH	B* -1(P)>
	<EXCH	A* -2(P)>
	<MOVEM	E* -3(P)>
	<CAMLE	B* (P)>
	<MOVE	B* (P)>		;"Only check as far as previous matches"
	<PUSH	P* B>
	<MOVE	B* -3(P)>		;"B/ bptr to longest match yet encountered"
	<PUSH	P* [0]>
LKPOVRMCH	<ILDB	O* A>
	<ILDB	D* B>
	<CAMN	O* D>
	<JRST	LKPOVRMCH1>
	<CAIL	O* 97>
	<CAILE	O* 122>
	<SKIPA>
	<SUBI	O* 32>
	<CAMN	O* D>
	<JRST	LKPOVRMCH1>
	<CAIL	D* 97>
	<CAILE	D* 122>
	<SKIPA>
	<SUBI	D* 32>
	<CAME	O* D>
	<JRST	LKPOVRMCH2>
LKPOVRMCH1	<AOS	(P)>
	<SOSLE	-1(P)>
	<JRST	LKPOVRMCH>
LKPOVRMCH2	<POP	P* B>
	<POP	P* O>
	<MOVEM	B* (P)>		;"stores length of overmatch"
	<ADD	E* [<1(1)>]>
	<SOJG	C* LKPLONGEST>
	<MOVE	E* (TP)>
	<POP	P* A>
	<MOVEM	A* 7(E)>
	<SUB	P* [<2(2)>]>
	<POP	P* B>		;"B/ cptr to LEXID with longest name"
	<JRST	LSTLKPSTRID>

LKPALLMCH	<MOVE	E* -2(TP)>
	<MOVE	E* 1(E)>		;"E/ cptr to LEXTABLE"
	<DMOVE	A* (E)>		;"A&B/ cptr to LEXID tbl"
	<HLRE	C* B>
	<MOVMS	C>
	<JRST	LKPMCH>

;"Here if only one match (either partial or exact)"
LSTLKPONEMCH	<HLRZ	D* (B)>		;"D/ # of characters in matching LEXID"
	<MOVEI	C* 3>		;"one exact match"
	<CAME	D* -4(TP)>
	<MOVEI	C* 1>		;"one partial match"
	<MOVEM	C* 1(E)>
	<MOVEM	D* 7(E)>
;"A&B/ cptr to LEXID to be returned"
LSTLKPSTRID	<MOVE	E* -2(TP)>
	<MOVE	D* 1(E)>	;"D/ cptr to LEXTABLE"
	<HRRZ	E* B>
	<HRRZ	C* 1(D)>
	<SUB	E* C>		;"E/ offset of LEXID on LEXID tbl"
	<MOVE	C* (TP)>
	<MOVEM	E* 3(C)>		;"stores offset in return vector"
	<MOVE	E* -2(TP)>
	<DPUSH	TP* (E)>
	<PUSH	TP* <TYPE-WORD LEXID>>
	<PUSH	TP* (B)>
	<PUSH	TP* <TYPE-WORD FALSE>>
	<PUSH	TP* [0]>
	<MCALL	 3 LEX-GET>
	<MOVE	E* (TP)>
	<DMOVEM	A* 4(E)>
	<DPOP	TP* A>
	<SUB	TP* [<6(6)>]>
	<JRST	MPOPJ>

LSTLKPNOMCH	<DMOVE	A* -1(TP)>
	<MOVE	O* <TYPE-WORD FIX>>
	<MOVEM	O* (B)>
	<SETZM	1(B)>
	<SUB	TP* [<8(8)>]>
	<JRST	MPOPJ>


;"####################################################################
#####################################################################"


<SUB-ENTRY LSTPOSSYM ("VALUE" FIX STRING FIX <VECTOR LEXTABLE ANY>
			<OR STRING FALSE> <OR STRING FALSE>)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILSTPOSSYM>
	<JRST	FINIS>

<INTERNAL-ENTRY ILSTPOSSYM 5>

	<SUBM	M* (P)>
	<GETYP	O* -5(TP)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	BADARG>
	<MOVE	E* -4(TP)>
	<GETYP	O* (E)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	BADARG>
	<DMOVE	A* (E)>
	<DMOVE	C* -9(TP)>
	<MOVE	E* -6(TP)>
	<JUMPE	E* LPOSALLMCH>		;"jumps if key length is 0, all symbols match"
	<PUSHJ	P* LEXTBLSRC>
	<JUMPLE	C* LPOSNOMCH>
;"A&B/ cptr to first matching LEXID
C/ # of matches"
LPOSMCH	<DPUSH	TP* A>
	<PUSH	P* C>
	<PUSH	P* C>
	<GETYP	O* -5(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	LPOSLP1>
	<DMOVE	A* <PQUOTE OUTCHAN>>
	<PUSHJ	P* CILVAL>
	<DMOVE	C* -5(TP)>
	<PUSHJ	P*  CPCSTR>
LPOSLP1	<MOVE	E* -6(TP)>
	<DMOVE	A* (E)>
	<MOVE	E* (TP)>
	<DPUSH	TP* A>
	<PUSH	TP* <TYPE-WORD LEXID>>
	<PUSH	TP* (E)>
	<MOVE	C* <MQUOTE '%<RGLOC LEX-SCRATCH-STRING T>>>
	<ADD	C* GLOTOP 1 (TVP)>
	<DPUSH	TP* (C)>
	<MCALL	3 LEX-GET>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	LPOSLP2>
	<DPUSH	TP* A>
	<DMOVE	A* <PQUOTE OUTCHAN>>
	<PUSHJ	P* CILVAL>
	<DPOP	TP* C>
	<PUSHJ	P* CPCSTR>
	<DMOVE	A* <PQUOTE OUTCHAN>>
	<PUSHJ	P* CILVAL>
	<DMOVE	C* <PQUOTE "
">>
	<PUSHJ	P* CPCSTR>
LPOSLP2	<MOVE	E* [<1(1)>]>
	<ADDM	E* (TP)>
	<SOSLE	(P)>
	<JRST	LPOSLP1>
	<POP	P* O>
	<POP	P* B>
	<MOVE	A* <TYPE-WORD FIX>>
	<SUB	TP* [<12(12)>]>
	<JRST	MPOPJ>

LPOSALLMCH	<MOVE	E* -4(TP)>		;"E/ cptr to VECTOR"
	<MOVE	E* 1(E)>		;"E/ cptr to LEXTABLE"
	<DMOVE	A* (E)>		;"A&B/ cptr to LEXID tbl"
	<HLRE	C* B>
	<MOVMS	C>		;"C/ length of LEXID tbl"
	<JRST	LPOSMCH>

LPOSNOMCH	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	LPOSRET>
	<DMOVE	A* <PQUOTE OUTCHAN>>
	<PUSHJ	P* CILVAL>
	<DMOVE	C* -1(TP)>
	<PUSHJ	P* CPCSTR>
	<MOVE	A* <TYPE-WORD FIX>>
	<MOVEI	B* 0>
LPOSRET	<SUB	TP* [<10(10)>]>
	<JRST	MPOPJ>




;"####################################################################
#####################################################################"


<SUB-ENTRY LSTPRTSYMS ("VALUE"'T <VECTOR LEXTABLE ANY>)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILSTPRTSYMS>
	<JRST	FINIS>

<INTERNAL-ENTRY ILSTPRTSYMS 1>

	<SUBM	M* (P)>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	BADARG>
	<MOVE	E* (TP)>
	<GETYP	O* (E)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	BADARG>
	<MOVE	E* 1(E)>		;"E/ LEXTABLE"
	<GETYP	O* (E)>
	<CAIN	O* <TYPE-CODE UVECTOR>>
	<SKIPL	B* 1(E)>
	<JRST	LPRTRET>
;"B/ cptr to LEXID tbl
C/ # of matches"
	<PUSH	TP* <TYPE-WORD UVECTOR>>
	<PUSH	TP* B>
	<PUSH	P* [70]>
LPRTLP1		<MOVE	E* -2(TP)>
	<DMOVE	A* (E)>
	<MOVE	E* (TP)>
	<DPUSH	TP* A>
	<PUSH	TP* <TYPE-WORD LEXID>>
	<PUSH	TP* (E)>
	<MOVE	C* <MQUOTE '%<RGLOC LEX-SCRATCH-STRING T>>>
	<ADD	C* GLOTOP 1 (TVP)>
	<DPUSH	TP* (C)>
	<MCALL	3 LEX-GET>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE STRING>>
	<JRST	LPRTLP4>
	<MOVE	D* (P)>
	<IDIVI	D* 8>
	<SKIPG	E>
	<MOVEI	E* 8>
	<HRRZ	C* A>
	<ADD	C* E>
	<ADDB	C* (P)>
	<DPUSH	TP* A>
	<CAIG	C* 70>
	<JRST	LPRTLP2>
	<HRRZ	C* A>
	<MOVEM	C* (P)>
	<DPUSH	TP* <PQUOTE "
">>
	<JRST	LPRTLP3>
LPRTLP2	<DPUSH	TP* <PQUOTE "	">>
LPRTLP3	<DMOVE	A* <PQUOTE OUTCHAN>>
	<PUSHJ	P* CILVAL>
	<DPOP	TP* C>
	<PUSHJ	P* CPCSTR>
	<DMOVE	A* <PQUOTE OUTCHAN>>
	<PUSHJ	P* CILVAL>
	<DPOP	TP* C>
	<PUSHJ	P* CPCSTR>
LPRTLP4	<MOVE	E* [<1(1)>]>
	<ADDB	E* (TP)>
	<JUMPL	E* LPRTLP1>
	<POP	P* O>
LPRTRET	<DMOVE	A* <PQUOTE T>>
	<SUB	TP* [<4(4)>]>
	<JRST	MPOPJ>






;"####################################################################
#####################################################################"


<SUB-ENTRY LSTALLPOS ("VALUE" <OR <LIST [REST SYMBOL]> FALSE>
			STRING FIX <VECTOR LEXTABLE ANY>)>

	<PUSH	TP* (AB)>
	<AOBJN	AB* HERE -1>
	<PUSHJ	P* ILSTALLPOS>
	<JRST	FINIS>

<INTERNAL-ENTRY ILSTALLPOS 3>

	<SUBM	M* (P)>
	<GETYP	O* -1(TP)>
	<CAIE	O* <TYPE-CODE VECTOR>>
	<JRST	BADARG>
	<MOVE	E* (TP)>
	<GETYP	O* (E)>
	<CAIE	O* <TYPE-CODE LEXTABLE>>
	<JRST	BADARG>
	<DMOVE	A* (E)>
	<DMOVE	C* -5(TP)>
	<MOVE	E* -2(TP)>
	<PUSHJ	P* LEXTBLSRC>
	<SKIPG	C>
	<PUSHJ	P* LALLPOSNOMCH>
	<JUMPLE	C* LALLPOSEMPTY>
;"A&B/ cptr to first matching LEXID
C/ # of matches"
	<PUSH	P* [0]>
	<PUSH	P* C>
	<DMOVE	C* -1(TP)>
	<DPUSH	TP* C>
	<MOVE	D* 1(D)>		;"C/ cptr to LEXTABLE"
	<MOVE	D* 1(D)>		;"D/ cptr to LEXID tbl"
	<HRRZS	B>
	<SUBI	B* (D)>
	<PUSH	P* B>
LALLPOSLP1	<DMOVE	A* -1(TP)>
	<PUSH	TP* <TYPE-WORD FIX>>
	<PUSH	TP* (P)>
	<DPUSH	TP* A>
	<MCALL	2 LSTEVAL>
	<GETYP	O* A>
	<CAIE	O* <TYPE-CODE SYMBOL>>
	<JRST	LALLPOSLP2>
	<EXCH	A* -1(TP)>
	<EXCH	B* (TP)>
	<DPUSH	TP* A>
LALLPOSLP2	<AOS	(P)>
	<AOS	-2(P)>
	<SOSLE	-1(P)>
	<JRST	LALLPOSLP1>
	<SUB	P* [<2(2)>]>
	<SUB	TP* [<2(2)>]>
	<POP	P* A>
	<PUSHJ	P* IILIST>
LALLPOSRET	<SUB	TP* [<6(6)>]>
	<JRST	MPOPJ>


LALLPOSNOMCH	<MOVE	E* (TP)>
	<MOVE	E* 1(E)>	;"E/ cptr to LEXTABLE"
	<DMOVE	A* (E)>		;"A&B/ cptr to LEXID tbl"
	<HLRE	C* B>
	<MOVMS	C>		;"C/ length of LEXID TBL"
	<POPJ	P*>

LALLPOSEMPTY	<DMOVE	A* <PQUOTE ()>>
	<JRST	LALLPOSRET>



;"############################LEXTBLSRC###############################
#####################################################################"


;"A&B/ LEXTABLE
C&D/ STRING to be looked up
E/ length of STRING (overrides real length)

==>	A&B/ cptr to slot of id tbl where string is or belongs
	C/ # of matches found"
LEXTBLSRC	<SUBM	M* (P)>
	<DPUSH	TP* A>
	<DPUSH	TP* C>
	<PUSH	P* E>
	<GETYP	O* (B)>
	<CAIN	O* <TYPE-CODE UVECTOR>>
	<SKIPL	E* 1(B)>
	<JRST	LTSRCFLS>
	<HLRE	D* E>
	<MOVMS	D>
	<JRST	LTSRCL2>
;"D/ size of space being searched
E/ cptr to beginning of space"
LTSRCL1	<CAILE	D* 3>
	<JRST	LTSRCBIN>
LTSRCL2	<MOVE	A* (E)>
	<MOVE	B* (P)>
	<HRREI	C* -1>
	<PUSHJ	P* LEXCOMP>
	<JUMPE	A* LTSRCFND>		;"Jumps if a match found"
	<JUMPL	A* LTSRCNOMCH>
	<ADD	E* [<1(1)>]>
	<SOJG	D* LTSRCL1>
LTSRCNOMCH	<MOVE	A* <TYPE-WORD UVECTOR>>
	<MOVE	B* E>
	<MOVEI	C* 0>
LTSRCRET	<SUB	TP* [<4(4)>]>
	<POP	P* 0>
	<JRST	MPOPJ>

LTSRCFLS	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEI	B* 0>
	<MOVEI	C* 0>
	<JRST	LTSRCRET>

;"Here when match found, see how many matches there are"
LTSRCFND	<PUSH	P* [1]>
	<PUSH	P* E>
	<AOBJP	E* LTSRCFND2>
LTSRCFND1	<MOVE	A* (E)>
	<MOVE	B* -2(P)>
	<HRREI	C* -1>
	<PUSHJ	P* LEXCOMP>
	<JUMPN	A* LTSRCFND2>
	<AOS	-1(P)>
	<AOBJN	E* LTSRCFND1>
LTSRCFND2	<MOVE	A* <TYPE-WORD UVECTOR>>
	<POP	P* B>
	<POP	P* C>
	<JRST	LTSRCRET>

;"Here when binary-search"
LTSRCBIN	<MOVE	A* D>
	<IDIVI	A* 2>
	<MOVE	B* D>
	<SUB	B* A>
	<PUSH	P* B>		;"B/ size of lower section"
	<MOVE	D* A>
	<HRLS	A>
	<ADD	A* E>
	<PUSH	P* A>		;"A/ cptr to lower section"
	<MOVE	A* (A)>
	<MOVE	B* -2(P)>
	<HRREI	C* -1>
	<PUSHJ	P* LEXCOMP>
	<POP	P* C>
	<POP	P* B>
	<SKIPN	A>
	<AOS	D>
	<JUMPLE	A* LTSRCL1>
	<MOVE	E* C>
	<MOVE	D* B>
	<JRST	LTSRCL1>


;"############################LEXSEARCH###############################
#####################################################################"



;"A&B/ LEXTABLE
C&D/ STRING to be looked up
E/ length of STRING (overrides real length)

==>	A&B/ cptr to slot of id table where string is or belongs
	C/  1 ==> exact match"

MLEXSEARCH	<MOVE	O* [<6(6)>]>
	<SKIPA>
LEXSEARCH	<MOVEI	O* 0>
	<SUBM	M* (P)>
	<DPUSH	TP* A>
	<DPUSH	TP* C>
	<PUSH	P* E>
	<ADD	B* O>
	<GETYP	O* (B)>
	<CAIN	O* <TYPE-CODE UVECTOR>>
	<SKIPL	E* 1(B)>
	<JRST	LEXSRCFLS>
	<HLRE	D* E>
	<MOVMS	D>
	<JRST	LSRCL2>		;"check first id in tbl, quit if STRING < it"
;"D/ size of space being searched
E/ cptr to beginning of space"
LSRCL1	<CAILE	D* 3>
	<JRST	LSRCBIN>
LSRCL2	<MOVE	A* (E)>
	<MOVE	B* (P)>
	<MOVEI	C* 0>
	<PUSHJ	P* LEXCOMP>
	<JUMPE	A* LSRCFND>		;"Jumps if a match found"
	<JUMPL	A* LSRCNOMCH>
	<ADD	E* [<1(1)>]>
	<SOJG	D* LSRCL1>
LSRCNOMCH	<MOVEI	C* 0>
	<SKIPA>
LSRCFND	<MOVEI	C* 1>
	<MOVE	A* <TYPE-WORD UVECTOR>>
	<MOVE	B* E>
LSRCRET	<SUB	TP* [<4(4)>]>
	<POP	P* 0>
	<JRST	MPOPJ>

LEXSRCFLS	<MOVE	A* <TYPE-WORD FALSE>>
	<MOVEI	B* 0>
	<MOVEI	C* 0>
	<JRST	LSRCRET>

;"Here when binary-search"
LSRCBIN	<MOVE	A* D>
	<IDIVI	A* 2>
	<MOVE	B* D>
	<SUB	B* A>
	<PUSH	P* B>		;"B/ size of lower section"
	<MOVE	D* A>
	<HRLS	A>
	<ADD	A* E>
	<PUSH	P* A>		;"A/ cptr to lower section"
	<MOVE	A* (A)>
	<MOVE	B* -2(P)>
	<MOVEI	C* 0>
	<PUSHJ	P* LEXCOMP>
	<POP	P* C>
	<POP	P* B>
	<JUMPL	A* LSRCL1>
	<MOVE	E* C>
	<MOVE	D* B>
	<JUMPE	A* LSRCFND>
	<JRST	LSRCL1>


;"#############################LEX-BPTR###############################
#####################################################################"


;"A/ cptr to LEXTABLE
B/ LEXID

==>	A/ bptr to string
	B/ length of string"
LEX-BPTR	<PUSH	P* C>
	<HLRE	C* 3(A)>
	<MOVMS	C>
	<CAIG	C* (B)>
	<JRST	UPDUVBPTR>		;"jumps if LEXID out of range of str tbl"
	<MOVE	A* 3(A)>
	<ADDI	A* 1(B)>
	<HRRZ	B* -1(A)>
	<SUBI	A* 1>
	<HRLI	A* *010700*>
	<POP	P* C>
	<POPJ	P*>

UPDUVBPTR	<GETYP	O* 4(A)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	RANGERR>
	<PUSH	P* D>
	<HLRE	D* 5(A)>
	<MOVMS	D>
	<SUB	B* C>
	<CAIG	D* (B)>
	<JRST	BPTRERR>
	<MOVE	A* 5(A)>
	<ADDI	A* 1(B)>
	<HRRZ	B* -1(A)>
	<SUBI	A* 1>
	<HRLI	A* *010700*>
	<POP	P* D>
	<POP	P* C>
	<POPJ	P*>

BPTRERR	<DPUSH	TP* <PQUOTE LEXID-OUT-OF-RANGE-OF-STR-TABLE!-ERRORS>>
	<MCALL	1 ERROR>
	<JRST	BPTRERR>



;"#############################LEX-COMP################################
#####################################################################"


;"A/ LEXID
B/ length of key
C/	0 ==> Regular comparison
	-1 ==> compare only up to length of STRING
(TP)/ STRING being looked up
-2(TP)/ LEXTABLE

==>	-1 ==> STRING < LEXID
	0 ==> STRING = LEXID
	1 ==> STRING > LEXID"
LEXCOMP	<SUBM	M* (P)>
	<PUSH	P* D>
	<PUSH	P* E>
	<PUSH	P* C>
	<MOVE	E* -2(TP)>
	<HLRE	D* 3(E)>
	<MOVMS	D>
	<CAIG	D* (A)>
	<JRST	TRYUPDUV>
	<ADD	A* 3(E)>
LEXCOMP1	<HRRZ	C* (A)>		;"C/ length of LEXID string"
	<HRLI	A* *010700*>	;"A/ bptr to LEXID string"
	<MOVE	D* (TP)>		;"D/ bptr to key string"
COMPL1	<ILDB	O* A>
	<ILDB	E* D>
	<CAMN	O* E>
	<JRST	COMPL2>
	<CAIL	O* 97>
	<CAILE	O* 122>
	<SKIPA>
	<SUBI	O* 32>
	<CAMN	O* E>
	<JRST	COMPL2>
	<CAIL	E* 97>
	<CAILE	E* 122>
	<SKIPA>
	<SUBI	E* 32>
	<CAMN	O* E>
	<JRST	COMPL2>
	<MOVEI	A* 1>
	<CAMG	E* O>		;"Skips if STRING > LEXID"
COMPRETN	<HRREI	A* -1>
COMPRET	<POP	P* C>
	<POP	P* E>
	<POP	P* D>
	<JRST	MPOPJ>

;"Here if both match so far"
COMPL2	<SOJLE	B* COMPKEY>	;"jumps if STRING exhausted"
	<SOJG	C* COMPL1>	;"iterates if neither exhausted"
	<MOVEI	A* 1>		;"LEXID exhausted, STRING isn't;  STRING > LEXID"
	<JRST	COMPRET>

;"Here if STRING exhausted"
COMPKEY	<MOVEI	A* 0>
	<SKIPGE	(P)>
	<JRST	COMPRET>
	<SOJLE	C* COMPRET>	;"jumps if LEXID exhausted too, STRING == LEXID"
	<JRST	COMPRETN>	;"STRING < LEXID"

TRYUPDUV	<GETYP	O* 4(E)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	RANGERR>
	<HLRE	C* 5(E)>
	<MOVMS	C>
	<HRLS	D>
	<SUB	A* D>
	<CAIG	C* (A)>
	<JRST	RANGERR>
	<ADD	A* 5(E)>
	<JRST	LEXCOMP1>

RANGERR	<DMOVE	A* -3(TP)>
	<DMOVE	C* -1(TP)>
	<DPUSH	TP* <PQUOTE LEXID-OUT-OF-RANGE-OF-LEXTABLE!-ERRORS>>
	<DPUSH	TP* A>
	<DPUSH	TP* C>
	<MCALL	3 ERROR>
	<JRST	RANGERR>



;"#######################LEX-INSERT-STRING############################
#####################################################################"

;"A&B/ LEXTABLE
C&D/ STRING to be inserted
E/ length of C&D"

LEX-INSERT-STRING	<SUBM	M* (P)>
	<DPUSH	TP* C>		;"Saves STRING on TP-stack"
	<PUSH	P* E>		;"Saves length of STRING on P-stack"
	<MOVE	C* E>		;"C/ length of string"
	<IDIVI	C* 5>
	<SKIPE	D>
	<ADDI	C* 1>
	<ADDI	C* 1>		;"C/ # of words needed to hold new string"
	<PUSH	P* C>		;"Saves on P-stack"
	<GETYP	O* 2(B)>
;"See if there are any free slots in the string tbl which are big
enough to hold the new string"
	<CAIN	O* <TYPE-CODE UVECTOR>>
	<SKIPL	D* 3(B)>	;"D/ cptr to string tbl"
	<SKIPA>
	<JRST	HERE 5>
	<GETYP	O* 4(B)>
	<CAIN	O* <TYPE-CODE UVECTOR>>
	<SKIPL	D* 5(B)>
	<JRST	INSUPDUV>	;"Jumps if string tbl empty"
	<MOVE	C* D>
INSLP1	<MOVE	D* 3(B)>
	<MOVE	E* C>		;"E/ cptr to current free slot of string tbl"
	<HRRZ	C* (C)>		;"C/ offset of next free slot"
	<JUMPE	C* INSUPDUV>	;"Jumps if no free slots left"
	<HLRE	O* D>
	<MOVMS	O>
	<CAMGE	C* O>		;"skips if in update tbl"
	<JRST	INSLP2>
	<SUB	C* O>		;"C/ offset on UPDATE tbl"
	<HLRE	O* 5(B)>
	<MOVMS	O>
	<CAML	C* O>
	<JRST	INSUPDUV>	;"jumps if out of range of UPDATE tbl"
	<MOVE	D* 5(B)>
INSLP2	<HRLS	C>
	<ADD	C* D>		;"C/ cptr to next free slot"
	<HLRZ	O* (C)>		;"O/ size of free slot"
	<CAMGE	O* (P)>		;"Skips if slot big enough for new string"
	<JRST	INSLP1>		;"jumps if not large enough"
;"Here if free slot found"
	<HRR	O* (C)>		;"O/ offset of next free slot"
	<HRRM	O* (E)>		;"patches found slot out of chain"
	<MOVEI	O* -1>
	<HRLM	O* (D)>		;"Sets 'MODIFIED' flag in string uvct"
	<POP	P* O>		;"O/ # of words needed for STRING"
	<HRRZ	A* C>
	<SUBI	A* (D)>		;"A/ offset of free slot"
	<HLRE	E* 3(B)>
	<MOVMS	E>		;"E/ length of STRING tbl"
	<CAME	D* 3(B)>
	<ADD	A* E>		;"adjusts offset if in UPDATE tbl"
	<HRL	A* (P)>		;"A/ LEXID of new string: char count,,offset"
	<MOVE	B* (C)>
	<HRR	B* (P)>		;"B/ header word for new slot: length,,char count"
;"A/ new LEXID
B/ header word of slot in string tbl
C/ cptr to slot in string tbl for new string
TP/ new STRING
P/ length of new string"
INSLOT	<MOVEM	B* (C)>		;"stores header word in str tbl slot"
	<MOVE	B* (TP)>	;"B/ bptr to STRING"
	<HRLI	C* *010700*>		;"C/ bptr to slot in str tbl"
	<MOVE	D* (P)>		;"D/ # of characters to transfer"
	<IDIVI	D* 5>
	<SKIPE	E>
	<ADDI	D* 1>
	<ADDI	D* (C)>	;"D/ ptr to word in which last characters
					of string will reside"
	<SETZM	(D)>		;"makes all trailing characters null (ASCII 0)"
	<MOVE	D* (P)>		;"D/ # of characters to transfer"
;"transfer STRING to its slot in str tbl"
	<ILDB	E* B>
	<IDPB	E* C>
	<SOJG	D* HERE -2>
;"Return new LEXID"
	<MOVE	B* A>
	<MOVE	A* <TYPE-WORD LEXID>>
	<SUB	P* [<1(1)>]>
	<SUB	TP* [<2(2)>]>
	<JRST	MPOPJ>

;"Here if have to add new string to the 'update' string tbl
A&B/ LEXTABLE
(TP)/ STRING to be inserted
-1(P)/ length of string
(P)/ # of words needed to store string"

INSUPDUV	<GETYP	O* 4(B)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	NEWSUVCT>
	<HLRE	D* 5(B)>
	<MOVMS	D>		;"D/ length of update tbl"
	<HLRE	C* 3(B)>
	<SKIPN	C>
	<SKIPE	D>
	<JRST	INSUP2>
;"Here only if both STRING and UPDATE tbls are empty"
	<MOVE	C* 5(B)>
	<HLRZ	E* 1(C)>	;"REAL length of UPDATE tbl, from dope word"
	<CAIGE	E* 3>
	<JRST	NEWSUVCT>	;"jumps if UPDATE tbl REALLY empty"
	<SUB	C* [<1(1)>]>
	<MOVEM	C* 5(B)>
	<SETZM	(C)>		;"Saves first word as header word"
	<MOVEI	D* 1>
INSUP2	<HRRZ	C* 5(B)>
	<ADD	C* D>		;"C/ ptr to first dope word of update tbl"
	<HLRZ	E* 1(C)>	;"E/ real length of UVECTOR"
	<MOVE	C* (P)>
	<ADD	C* D>		;"C/ total length required"
	<CAIGE	E* 2(C)>	;"skips if enough slush space for new string"
	<JRST	NEWSUVCT>
	<MOVE	A* (P)>		;"A/ number of additional words needed"
	<HRLS	A>
	<MOVE	C* 5(B)>
	<SUB	C* A>		;"C/ cptr to new UVECTOR: backs original"
	<HRLS	D>		;"D/ original length,,original length"
	<ADD	D* C>		;"D/ cptr to slot for new string"
;"Here to move data from old uvct to new uvct
C/ cptr to 'backed' update tbl
D/ cptr to slot in update tbl for new string
5(B)/ cptr to original update tbl (not backed)"
INSTRMOV	<HRL	E* 5(B)>
	<HRR	E* C>
	<CAME	C* D>		;"Skips if first string to be inserted into update tbl"
	<BLT	E* -1(D)>	;"moves top portion of update tbl up (lower address)"
	<MOVEM	C* 5(B)>	;"saves cptr to new update tbl in LEXTABLE"
;"Construct new LEXID for string"
	<HLRE	E* 3(B)>
	<MOVMS	E>		;"E/ length of string tbl"
	<HRRZ	A* D>		;"A/ ptr to slot for new string in update tbl"
	<SUBI	A* (C)>		;"A/ offset of new slot on update tbl"
	<ADD	A* E>
	<HRL	A* -1(P)>	;"A/ new LEXID:  char count,,offset"
	<MOVE	C* D>		;"C/ cptr to slot for new string"
	<HRL	B* (P)>
	<HRR	B* -1(P)>	;"B/ header word for new slot:  size,,char count"
	<SUB	P* [<1(1)>]>
	<JRST	INSLOT>		;"store string in new slot and return"


;"Here when 'update' string uvector either too small or doesn't exist
A&B/ cptr to LEXTABLE
(TP)/ STRING to be inserted into update tbl
-1(P)/ length of string
(P)/ # of words required for new string"
NEWSUVCT	<GETYP	O* 4(B)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	NEWSU1>
	<HLRE	D* 5(B)>
	<MOVMS	D>		;"D/ length of existing update tbl"
	<JUMPE	D* NEWSU1>	;"jumps if tbl empty"
	<DPUSH	TP* A>
	<MOVE	A* (P)>		;"A/ # of words needed for new slot"
	<ADDI	A* 20(D)>	;"A/ # of words to get"
	<MOVEI	O* IBLOCK>
	<PUSHJ	P* RCALL>
	<MOVE	C* B>
	<DPOP	TP* A>		;"A&B/ LEXTABLE"
	<ADD	C* [<20(20)>]>	;"C/ cptr to head of new update tbl"
	<HLRE	D* C>
	<SUBM	C* D>	;"D/ ptr to first dope word of new tbl"
	<MOVEI	O* <TYPE-CODE WORD>>
	<PUTYP	O* (D)>		;"makes tbl's UTYPE be LEXID"
	<HLRE	D* 5(B)>
	<MOVMS	D>		;"D/ length of original tbl"
	<PUSH	P* D>
	<HRLS	D>
	<ADD	D* C>		;"D/ cptr to slot of new tbl for new string"
	<HRL	E* 5(B)>
	<HRR	E* C>
	<BLT	E* -1(D)>	;"transfers entire original tbl to new tbl"
	<MOVEM	C* 5(B)>	;"stores cptr to ne tbl in LEXTABLE"
	<MOVE	C* D>		;"C/ cptr to slot of new tbl where new string belongs"
	<POP	P* A>		;"A/ offset of new slot on update tbl"
	<HLRE	E* 3(B)>
	<MOVMS	E>		;"E/ length of string tbl"
	<ADD	A* E>
	<HRL	A* -1(P)>	;"A/ new LEXID:  char count,,offset"
	<HRL	B* (P)>
	<HRR	B* -1(P)>	;"B/ header word for new slot: size,,char count"
	<SUB	P* [<1(1)>]>
	<JRST	INSLOT>


NEWSU1	<DPUSH	TP* A>
	<MOVE	A* (P)>		;"A/ # of words needed for new slot"
	<ADDI	A* 20>
	<MOVEI	O* IBLOCK>
	<PUSHJ	P* RCALL>
	<MOVE	C* B>
	<DPOP	TP* A>		;"A&B/ LEXTABLE"
	<HLRE	E* 3(B)>
	<MOVMS	E>		;"E/ length of str tbl"
	<MOVE	O* <TYPE-WORD UVECTOR>>
	<MOVEM	O* 4(B)>
	<ADD	C* [<19(19)>]>
	<SKIPLE	E>		;"leave extra word at top if no str tbl"
	<ADD	C* [<1(1)>]>	;"C/ cptr to new update tbl"
	<MOVEM	C* 5(B)>	;"stores new update tbl in LEXTABLE"
	<SKIPG	E>
	<ADD	C* [<1(1)>]>	;"C/ cptr to new slot"
	<HLRE	D* C>
	<SUBM	C* D>		;"D/ ptr to first dope word of update tbl"
	<MOVEI	O* <TYPE-CODE WORD>>
	<PUTYP	O* (D)>		;"makes UTYPE of update tbl be WORD"
	<HLRE	A* 3(B)>
	<MOVMS	A>
	<SKIPG	A>
	<MOVEI	A* 1>
	<HRL	A* -1(P)>	;"A/ new LEXID:  char count,,offset"
	<HRL	B* (P)>
	<HRR	B* -1(P)>	;"B/ header word for new slot:  size,,char count"
	<SUB	P* [<1(1)>]>
	<JRST	INSLOT>




;"#######################LEX-INSERT-LEXID#############################
#####################################################################"

;"A&B/ LEXTABLE
C&D/ cptr to slot in LEXID tbl where new LEXID belongs
E/ new LEXID"
MLEX-INSERT-LEXID	<ADD	B* [<6(6)>]>
LEX-INSERT-LEXID	<SUBM	M* (P)>
	<PUSH	P* E>
	<DPUSH	TP* C>
;"See if enough slush space exists to insert new LEXID in its table
(TP)/ cptr to slot in LEXID tbl where new LEXID belongs (FALSE if empty)
(P)/ new LEXID"
	<GETYP	O* (B)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	NEWLUVCT>
	<HLRE	D* 1(B)>
	<MOVMS	D>
	<HRRZ	C* 1(B)>
	<ADD	C* D>
	<HLRZ	E* 1(C)>
	<CAIGE	E* 3(D)>		;"Skips if at least one word of slush space"
	<JRST	NEWLUVCT>
	<MOVE	E* 1(B)>
	<SUB	E* [<1(1)>]>		;"E/ cptr to head of new LEXID tbl"
	<DPOP	TP* C>		;"D/ cptr to slot in old tbl where new LEXID belongs"
	<EXCH	E* 1(B)>	;"E/ cptr to head of old LEXID tbl"
	<GETYP	O* C>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	INSFIRST>	;"Jumps if first LEXID to be inserted"
	<CAMN	E* D>		;"skips if new id not in first slot"
	<JRST	INSID>
	<HRLS	E>
	<HRR	E* 1(B)>
	<BLT	E* -2(D)>		;"moves upper portion of uvct up one word"
INSID	<SUB	D* [<1(1)>]>
	<POP	P* (D)>		;"stores new LEXID in slot"
	<DMOVE	A* C>
	<JRST	MPOPJ>

INSFIRST	<MOVE	A* <TYPE-WORD UVECTOR>>
	<MOVE	B* 1(B)>		;"B/ cptr to head of new LEXID tbl"
	<POP	P* (B)>
	<JRST	MPOPJ>

;"Here if LEXID uvct either is too small or doesn't exist"
NEWLUVCT	<DPUSH	TP* A>		;"Saves LEXTABLE on TP-stack"
	<MOVEI	A* 0>
	<GETYP	O* (B)>
	<CAIE	O* <TYPE-CODE UVECTOR>>
	<JRST	HERE 3>
	<HLRE	A* 1(B)>
	<MOVMS	A>
;"A/ length of existing LEXID tbl"
	<PUSH	P* A>
	<ADDI	A* 20>
	<MOVEI	O* IBLOCK>
	<PUSHJ	P* RCALL>
	<ADD	B* [<19(19)>]>
	<HLRE	C* B>
	<SUBM	B* C>
	<MOVEI	O* <TYPE-CODE LEXID>>
	<PUTYP	O* (C)>
	<DMOVE	C* A>		;"C&D/ cptr to head of new LEXID tbl"
	<DPOP	TP* A>		;"A&B/ cptr to LEXTABLE"
	<EXCH	D* 1(B)>	;"D/ cptr to head of old LEXID tbl"
	<MOVE	O* <TYPE-WORD UVECTOR>>
	<MOVEM	O* (B)>
	<POP	P* E>		;"E/ length of old LEXID tbl"
	<JUMPE	E* NEWLU1>	;"jumps if old tbl didn't exist"
;"transfer top portion of old tbl into new tbl"
	<HRRZ	E* (TP)>	;"E/ ptr to new slot in old tbl"
	<SUBI	E* (D)>		;"E/ garbage,,offset of new slot"
	<HRLS	E>
	<ADD	E* 1(B)>	;"E/ cptr to slot of new tbl for new LEXID"
	<HRL	C* D>
	<HRR	C* 1(B)>
	<CAME	E* 1(B)>		;"Skips if new LEXID in first slot"
	<BLT	C* -1(E)>
;"store new LEXID in new tbl"
	<POP	P* (E)>
;"transfer bottom portion of old tbl into new tbl"
	<HRL	C* (TP)>
	<HRRI	C* 1(E)>
	<HLRE	D* E>
	<MOVMS	D>
	<ADDI	D* (E)>		;"D/ ptr to first dope word of new tbl"
	<CAILE	D* (C)>		;"Skips if new LEXID in last slot"
	<BLT	C* -1(D)>
	<MOVE	B* E>		;"B/ cptr to new LEXID's slot in new tbl"
NEWLRET	<MOVE	A* <TYPE-WORD UVECTOR>>
	<SUB	TP* [<2(2)>]>
	<JRST	MPOPJ>

NEWLU1	<DMOVE	A* (B)>		;"A&B/ cptr to head of new LEXID tbl"
	<POP	P* (B)>
	<JRST	NEWLRET>


;"#########################LEX-DELETE-LEXID############################
#####################################################################"

;"A&B/ LEXTABLE
C&D/ cptr to slot in LEXID tbl from which LEXID is to be removed"

MLEX-DELETE-LEXID	<ADD	B* [<6(6)>]>
LEX-DELETE-LEXID	<SUBM	M* (P)>
LIDELP1	<CAMN	D* 1(B)>
	<JRST	DELFIRSTID>		;"jumps if first id in LEXID tbl, simple"
;"Here if have to move upper portion of LEXID tbl down over deleted LEXID"
	<MOVE	O* -1(D)>
	<MOVEM	O* (D)>
	<SUB	D* [<1(1)>]>
	<JRST	LIDELP1>

DELFIRSTID	<ADD	D* [<1(1)>]>
	<MOVEM	D* 1(B)>
	<JRST	MPOPJ>



;"#########################LEX-DELETE-STRING##########################
#####################################################################"

;"A&B/ LEXTABLE
C/ LEXID of string to be removed from STRING tbl"

LEX-DELETE-STRING	<SUBM	M* (P)>
	<HLRE	D* 3(B)>
	<MOVMS	D>		;"D/ length of STRING tbl"
	<JUMPE	D* NOSTRTBL>		;"jumps if there is no STRING tbl"
	<CAIG	D* (C)>
	<JRST	LSDELUPDV>		;"jumps if LEXID points into UPDATE uvector"
;"Here if target string in STRING tbl"
	<MOVE	D* 3(B)>
	<ADDI	D* (C)>		;"D/ ptr to header of target string"
	<MOVE	E* 3(B)>	;"E/ cptr to head of STRING tbl"
LSDELFIX	<HRRZ	O* (E)>
	<HRRM	O* (D)>		;"splices deleted string into free chain"
	<HRRM	C* (E)>		;"puts ptr to free chain in first word of tbl"
	<MOVEI	O* -1>
	<HRLM	O* (E)>		;"sets bit indicating modification"
	<JRST	MPOPJ>

;"Here if no STRING tbl exists"
NOSTRTBL	<HLRE	D* 5(B)>
	<MOVMS	D>
	<JUMPE	D* LSDELERR>	;"Jumps if no UPDATE tbl either"
	<CAIG	D* (C)>
	<JRST	LSDELERR>	;"jumps if out of range of UPDATE tbl"
	<MOVE	D* 5(B)>
	<ADDI	D* (C)>
	<MOVE	E* 5(B)>
	<JRST	LSDELFIX>

;"Here if LEXID out of range of STRING tbl, try UPDATE tbl"
LSDELUPDV	<HLRE	E* 5(B)>
	<MOVMS	E>
	<ADD	E* D>		;"E/ combined length of both tbls"
	<CAIG	E* (C)>
	<JRST	LSDELERR>	;"jumps if out of range of UPDATE tbl too"
	<HRRZ	E* C>
	<SUBM	E* D>		;"D/ offset on UDPATE tbl"
	<ADD	D* 5(B)>	;"D/ ptr to header word of target string"
	<MOVE	E* 3(B)>	;"E/ cptr to STRING tbl"
	<JRST	LSDELFIX>

LSDELERR	<PUSH	TP* <PQUOTE LEXID-OUT-OF-RANGE!-ERRORS>>
	<PUSH	TP* <TYPE-CODE LEXID>>
	<PUSH	TP* C>
	<DPUSH	TP* A>
	<MCALL	3 ERROR>
	<JRST	LSDELERR>


	


;"####################################################################
#####################################################################"
<END>


<ENDPACKAGE>
