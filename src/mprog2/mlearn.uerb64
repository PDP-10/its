<PACKAGE "MLEARN">
<ENTRY	LEARN	MNEME-BEGIN	MNEME-END	RANDOM-MNEME-ITEM
	CONVERT	NON-INVERT	MNUM		MNEME-LOCK	MNEME-WRITE
	MNEME-UNLOCK PIO-TRACE>

<USE "PIO" "MNEME">

<SETG PIO-HANG-ON-UNMAP? T>	;"Never delete this"
<SETG PIO-PAGE-LIMIT 100>
<SETG MNUM <>>
<SETG NAMELIST ()>
<SETG EHT <IUVECTOR 60 ()>>
<GDECL	(NAMELIST) <LIST [REST ATOM]> (MNUM) <OR FALSE ATOM>     (PIO-TRACE) CHANNEL
	(EHT) <UVECTOR [60 LIST] [REST LIST]> (MNEME-READ-TABLE) <VECTOR [256 ANY]>>

<DEFINE MNEME-LOCK   ("OPTIONAL" (KEY "MNEME"))	#DECL ((KEY) STRING)
	<OR <GASSIGNED? MNEMECHN><ERROR "You forgot to MNEME-INITialize">>
	<MNEME-WRITE <HASH-ATOM .KEY 92681> 1>>

<DEFINE MNEME-UNLOCK ("OPTIONAL" (KEY "MNEME"))
	#DECL ((KEY) STRING)
	<OR <GASSIGNED? MNEMECHN><ERROR "You forgot to MNEME-INITialize">>
	<AND <==? <HASH-ATOM .KEY 92681><MNEME-READ 1 1>>
	     <CLOSEP ,MNEMECHN>
	     <SETG MNEMECHN <OPENP "PRINT" <2 ,DHT> 1 T>>
	     <MNEME-WRITE 0 1>
	     <PUT ,DHT 1 "PRINT">
	     "Reopened in print mode">>

<DEFINE INIT-READ-TABLE ()
	<PUT <SETG MNEME-READ-TABLE <IVECTOR 256. 0>>
	      <+ 1 <ASCII !\| >>	;"SETUP | "
		#FUNCTION ((X) #DECL ((OBLIST)<SPECIAL LIST>)
			 <READCHR .INCHAN>
			 <ATOM <UNPARSE <READ .INCHAN '<ERROR> .OBLIST>>>)>>


<DEFINE MNEME-BEGIN ("OPTIONAL" (INCHAN .INCHAN) "AUX" SAV X MNEME-SEEN
			(ATOMLIST ()) (LISTLIST ())
			(READ-TABLE<COND (<GASSIGNED? MNEME-READ-TABLE>
					  ,MNEME-READ-TABLE)
					 (<INIT-READ-TABLE>)> )
			(OBLIST (,MNEME-OBLIST !.OBLIST)))
 #DECL ((ATOMLIST LISTLIST MNEME-SEEN OBLIST)<SPECIAL LIST>
	(READ-TABLE) <SPECIAL <VECTOR [256 ANY]>>)
 <COND
  (<NOT <GASSIGNED? DHT>><ERROR "You forgot to MNEME-INITialize">)
  (<REPEAT ()
   <SET X <REPEAT ()<COND (<==? <SET X <NEXTCHR .INCHAN>> !\< >
			   <RETURN <READ .INCHAN '<ERROR> ,OBLIST>>)
			  (<==? .X !\[ ><RETURN <READ .INCHAN '<ERROR> .OBLIST>>)
			  (<==? .X !\( ><ERROR "Unmatched or missing bracket">)
			  (<==? .X !\;><READ .INCHAN '<ERROR> .OBLIST>)
			  (<READCHR .INCHAN>)>>>
   <COND (<TYPE? .X FORM>
	  <COND (<0? <STRCOMP MNEME-END <1 .X>>>
		 <UV-ZAP ,EHT><RETURN .SAV>)
		(<EVAL .X>)>)
	(<MNEME-NAMES .X>
	<MNEME-NAMES2 .X>
	<UV-ZAP ,EHT>
	<SET MNEME-SEEN (SEEN)>
	<MAPF <><FUNCTION (I)<MAKEUNIQUE <> .I>>
	      .X>
	<SET LISTLIST <NREVERSE .LISTLIST>>
	;"Listlist always has uses of item after item"
	<SET SAV     <MAPF <>,ATOMLEARN1 .ATOMLIST>> 
	<SET SAV <OR <MAPF <>,LISTLEARN1 .LISTLIST> .SAV>> 
	<MAPF <> <FUNCTION (X)<PUTPROP .X .MNEME-SEEN>> .ATOMLIST>
	<MAPF <> ,UNASSIGN ,NAMELIST>
	<UV-ZAP ,MNEME-OBLIST>
	<SETG NAMELIST ()>
	<SET ATOMLIST ()>
	<SET LISTLIST ()>
	  )>
	>)>>

<SETG MNEME-OBLIST <MOBLIST MNEME-OBLIST 23>>
<GDECL (MNEME-OBLIST) OBLIST>

<DEFINE MNEME-END ()<PRINT "ERROR--EVALing MNEME-END">>

<DEFINE LEARN ("TUPLE" L
	       "AUX" (LISTLIST ()) (ATOMLIST ())
		     (MNEME-SEEN (SEEN)) SAV)
	#DECL ((LISTLIST ATOMLIST MNEME-SEEN) <SPECIAL LIST>
		(L)<OR TUPLE LIST>)
	<SET L (!.L)>
	<OR <AND <GASSIGNED? DHT>
		 <=? <1 ,DHT> "PRINT">>
	    <ERROR "You forgot to MNEME-INITialize">>
	<MNEME-NAMES .L>
	<MNEME-NAMES2 .L>
	<UV-ZAP ,EHT>
	<MAPF <> <FUNCTION (I) <MAKEUNIQUE <> .I>> .L>
	<SET LISTLIST <NREVERSE .LISTLIST>>
	<SET SAV     <MAPF <> ,ATOMLEARN1 .ATOMLIST>>
	<SET SAV <OR <MAPF <> ,LISTLEARN1 .LISTLIST> .SAV>>
	<MAPF <> <FUNCTION (X)<PUTPROP .X .MNEME-SEEN>> .ATOMLIST>
	<MAPF <> ,UNASSIGN ,NAMELIST>
	<UV-ZAP ,MNEME-OBLIST>
	<SETG NAMELIST ()>
	.SAV>




<DEFINE ATOMLEARN1 (ATM "AUX" MNEME)
   #DECL ((ATM) ATOM (VALUE) OWT (MNEME) <OR FIX OWT FALSE>)
   <SET MNEME <GETPROP .ATM .MNEME-SEEN>>
   <AND <==? ,MNEME-VERBOSE T> <NOT <TYPE? .MNEME OWT>> <PRINC "Learning ">
	<PRINC .ATM><TERPRI>>
   <COND
    (<TYPE? .MNEME OWT> .MNEME)
    (<NOT .MNEME><ERROR "Shouldn't get this">)
    (<PROG ((INT-LEVEL1 <INT-LEVEL 200>)(HLOC <+ 8 <HASH-ATOM .ATM 2039.>>)
	    DLOC (B-LOC <MNEME-READ 1 .HLOC>)(INTLOC <HASH-ATOM .ATM 509>)
	    (UVP <SPNAME .ATM> )
	    (NITMS <CHTYPE <GETBITS .B-LOC <BITS 12 24>> FIX>)
	    (UVPLEN </ <+ <LENGTH .UVP> 4> 5>) DATA (MCHN ,MNEMECHN))
	   #DECL ((HLOC B-LOC NITMS DLOC UVPLEN INT-LEVEL1 INTLOC) FIX
		  (UVP) STRING (DATA) <UVECTOR [REST FIX]> (MCHN) CHANP)
	   <COND (<0? .NITMS> <SET B-LOC <RALLOCP .MCHN 4>>
	          <AND <L=? .B-LOC 2048><ERROR "Shouldnt get this" .HLOC .ATM>>)>
	   <SET DATA <MNEME-READ <IUBKT <+ .NITMS 1>> <- .B-LOC 1>>>
	   <COND(<L=? <1 .DATA> .NITMS>
		 <COND (<L? <1 .DATA> .NITMS>
			<ERROR "Shouldnt get this" .DATA .HLOC .ATM>)>
		 <SET DLOC .B-LOC>
		 <SET B-LOC <CHTYPE <PUTBITS <RALLOCP .MCHN <+ .NITMS </ .NITMS 2> 3>>
					     <BITS 12 24>
					     .NITMS> FIX>>
		 <MNEME-WRITE <REST .DATA> .B-LOC>
		 <RDALLOCP .MCHN <CHTYPE <GETBITS .DLOC <BITS 24.>> FIX>>)>
	  <COND (<G=? .NITMS 4089.><ERROR "Bucket overflow">)>
	  <MNEME-WRITE <+ .B-LOC *000100000000*> .HLOC>
	  <SET DLOC
	       <CHTYPE <PUTBITS <RALLOCP .MCHN <+ 1 .UVPLEN <MIN 6 <MAX .MNEME 1>>>>
				<BITS 12 24>
				.INTLOC>    FIX>>
	  <COND (<L? <- ,STORSIZ ,STORNXT> 75>
		 <GROUP-PAGE-OUT>)>
	  <PUT ,IHT .INTLOC <STORALLOC
			     .DLOC
			     <PUTBITS <* *100000* <NTH ,IHT .INTLOC>><BITS 6 30>.UVPLEN>
			     .UVP>>
	  <PUTPROP .ATM .MNEME-SEEN .DLOC>
	  <MNEME-WRITE .DLOC <+ .B-LOC .NITMS>>  ;"UPDATE BUCKET"
	  <MNEME-WRITE .UVP <+ 1 .DLOC>>
	  <MNEME-WRITE <PUTBITS 0 <BITS 6 30> .UVPLEN> .DLOC>  ;"NO USES YET"
	  <INT-LEVEL .INT-LEVEL1>
	  <RETURN <CHTYPE .DLOC OWT>>
		  >)> >


<DEFINE LISTLEARN1 (LST "AUX" INT-LEVEL1 (LSTSAV <RGET .LST>)
			  (HASH <3 .LSTSAV>)
			  (INTLOC <+ <COND (<TYPE? .LSTSAV MNEME-INSTANCE> 1025.)
					   ( 513.)>
				     <MOD .HASH 509>>)
			  (HLOC   <+ 8 <MOD .HASH 2039.>>) (KNOWN ())
			  (FLAG <>) KFLG)
   #DECL ((LSTSAV) <OR <LIST LIST FIX <OR ATOM FIX>> MNEME-INSTANCE>
	  (LST) <OR LIST MNEME-INSTANCE> (KNOWN) <LIST [REST FIX]>
	  (INTLOC HLOC HASH INT-LEVEL1) FIX (FLAG KFLG) <OR 'T FALSE>)
   <AND <==? ,MNEME-VERBOSE T> <PRINC "Learning ">
	<PRINC .LST>
	<TERPRI>>
   <SET INT-LEVEL1 <INT-LEVEL 10.>>
   <PROG ()
     <COND
      (<TYPE? .LSTSAV MNEME-INSTANCE>
       <SET LST (<PROG ((DOWN <1 <1 .LSTSAV>>))
		  <1 <SET KNOWN (<COND  (<TYPE? .DOWN ATOM>
					 <CHTYPE <GETPROP .DOWN .MNEME-SEEN> FIX>)
					(<TYPE? .DOWN LIST MNEME-INSTANCE>
					 <2 <RGET .DOWN>>)
					(<TYPE? .DOWN OWT> <CHTYPE .DOWN FIX>)
					(<ERROR "Illegal instance">)>)>>>)>)
      (<AND <SET LST <MAPF ,LIST		;"See if new due to having new element"
		  <FUNCTION (DR1)	;"Remem known for updating uses"
			  #DECL ((VALUE) FIX)
			  <COND (<AND ,MNUM <TYPE? .DR1 FIX>
				      <OR <G? <ABS .DR1> *037777777777*>
					   <N==? ,MNUM CONVERT>>
				      <SET DR1 <MNUM-ATOM .DR1>>
				      <>>)
				(<TYPE? .DR1 ATOM>
				 <SET KFLG <AND <==? ,MNUM NON-INVERT>
						<==? <1 <SPNAME .DR1>> <ASCII 26>>>>
				 <SET DR1 <GETPROP .DR1 .MNEME-SEEN>>
				 <COND  (<TYPE? .DR1 OWT> <SET DR1 <CHTYPE .DR1 FIX>>)
					(.DR1 <SET FLAG T>)
					(<ERROR LISTLEARN1 .DR1>)>
				 <OR .KFLG <SET KNOWN (.DR1 !.KNOWN)>>
				 .DR1)
				(<TYPE? .DR1 LIST MNEME-INSTANCE>
				 <SET DR1 <RGET .DR1>>
				 <COND (<==? <3 .DR1> ALREADY-EXISTS>)
				       (<SET FLAG T>)>
				 <1 <SET KNOWN (<2 .DR1> !.KNOWN)>>)
				(<TYPE? .DR1 FIX>
				 <COND (<L=? <ABS .DR1> *37777777777*>)
				       (<ERROR .DR1 "Number too big for MNEME"> 0)>
				 <CHTYPE <PUTBITS .DR1 <BITS 3 33> 5> FIX>)
				(<TYPE? .DR1 OWT>
				 <SET KNOWN (<CHTYPE .DR1 FIX> !.KNOWN)>
				 <CHTYPE .DR1 FIX>)
				(<ERROR "Unrecognized " .DR1 .LST LISTLEARN1>)>>
		  .LST>>
	    .FLAG>)
      (<REPEAT ((P <NTH ,IHT .INTLOC>)) #DECL ((P) FIX)
					;"KNOWN INTERNALLY? "
	  <COND (<0? .P><RETURN <>>)
		(<AND <MAPF <> <FUNCTION (E L) #DECL ((E L) FIX)
					       <OR <==? .E .L>
						   <MAPLEAVE <>>>>
			  <REST ,STORPLUS1 .P>
			  .LST>
		      <==? <LENGTH .LST>
			   <CHTYPE <GETBITS <NTH ,STORPLUS1 .P> <BITS 6 30>> FIX>>>
		 <PUT <PUT .LSTSAV 2 <NTH ,STOR .P>> 3 ALREADY-EXISTS>
		 <RETURN T>)
		(<SET P <CHTYPE <GETBITS <NTH ,STORPLUS1 .P> <BITS 15 15>> FIX>>)>>
	<INT-LEVEL .INT-LEVEL1>
	<RETURN <CHTYPE <2 .LSTSAV> OWT>>)
      (<MAPF <>		;"Already known on dsk? "
	     <FUNCTION (ENTRY1) #DECL ((ENTRY1) FIX)
		     <AND <==? <GETBITS .ENTRY1 <BITS 12 24>>
			       <CHTYPE .INTLOC WORD>>
			  <COMPARE-DSK-LIST .ENTRY1 .LST>
			  <PUT .LSTSAV 2 .ENTRY1>
			  <PUT .LSTSAV 3 ALREADY-EXISTS>
			  <MAPLEAVE T>>>
	     <GETBUCKET .HLOC>>
       <INT-LEVEL .INT-LEVEL1>
       <RETURN <CHTYPE <2 .LSTSAV> OWT>>)>

     <RETURN <PROG ((B-LOC <MNEME-READ 1 .HLOC>) DLOC ATOMNAME (UVLEN 0)
		    (NITMS <CHTYPE <GETBITS .B-LOC <BITS 12 24>> FIX>)(MCHN ,MNEMECHN))
	   #DECL ((B-LOC DLOC NITMS UVLEN) FIX
		  (ATOMNAME) STRING (MCHN) CHANP)
	   <COND (<TYPE? .LSTSAV MNEME-INSTANCE>
		  <SET ATOMNAME <SPNAME <2 <1 .LSTSAV>>>>
		  <SET UVLEN </ <+ <LENGTH .ATOMNAME> 4> 5>>)>
	   <SET DLOC
		<CHTYPE <PUTBITS <RALLOCP .MCHN  <+ 1 <LENGTH .LST>  .UVLEN
						      <MIN 6 <MAX 1 <2 .LSTSAV>>>>>
				 <BITS 12 24>
				 .INTLOC>
			FIX>>
	   <COND (<TYPE? .LSTSAV LIST>
		  <COND (<0? .NITMS> <SET B-LOC <RALLOCP .MCHN 4>>)
			(<L=? <MNEME-READ 1 <- .B-LOC 1>> .NITMS>
			 <PROG ((BLOC-SAV .B-LOC))
			  <SET B-LOC <CHTYPE <PUTBITS 
				       <MNEME-WRITE
					   <MNEME-READ <IUBKT .NITMS> .B-LOC>
					   <RALLOCP .MCHN <+ .NITMS </ .NITMS 2> 3>>>
			       <BITS 12 24>
			       .NITMS> FIX>>
			  <RDALLOCP .MCHN <CHTYPE <GETBITS .BLOC-SAV <BITS 24>> FIX>>>)>
		  <MNEME-WRITE <+  *000100000000* .B-LOC> .HLOC>
		  <MNEME-WRITE .DLOC <+ .B-LOC .NITMS>>
		  <COND (<G? .NITMS 4090><ERROR "Bucket overflow">)>)>
	   <MAPF <>
		 <FUNCTION (KNOWN) #DECL ((KNOWN) FIX)
		   <COND (<GETPROP <CHTYPE .KNOWN OWT> NON-INVERT>)
			 (<PUTPROP .KNOWN NEW-USES
				   (.DLOC !<GETPROP .KNOWN NEW-USES>)>)>>
		 .KNOWN>
	   <COND (<TYPE? .LSTSAV MNEME-INSTANCE>
		  <UNASSIGN <2 <1 .LSTSAV>>>
		  <MNEME-WRITE .ATOMNAME <+ .DLOC 2>>
		  <PUTREST <1 .LSTSAV> ()> )>
	   <PUT .LSTSAV 2 .DLOC>
	   <MNEME-WRITE (<CHTYPE <PUTBITS 0 <BITS 6 30>
				 <+ <LENGTH .LST> .UVLEN>> FIX> !.LST)	 .DLOC>
	   <INT-LEVEL .INT-LEVEL1>
	   <RETURN <CHTYPE .DLOC OWT>>  >>>>



<DEFINE GETBUCKET (HLOC "AUX" (B-LOC <MNEME-READ 1 .HLOC>))
   #DECL ((HLOC B-LOC) FIX (VALUE) <UVECTOR [REST FIX]>)
   <COND (<0? .B-LOC> 
	  ![!] )
	 (<MNEME-READ <IUBKT <CHTYPE <GETBITS .B-LOC <BITS 12 24>> FIX>> .B-LOC>)>>


<DEFINE COMPARE-DSK-LIST (LOC ITM "AUX" (LEN <LENGTH .ITM>)
					(DATA <MNEME-READ <IUVEC9 <+ .LEN 1>> .LOC>) )
   #DECL ((LOC LEN) FIX (ITM) <LIST [REST FIX]> (VALUE) <OR 'T FALSE>
	  (DATA) <UVECTOR [REST FIX]>)
   <AND <==? .LEN <CHTYPE <GETBITS <1 .DATA> <BITS 6 30>> FIX>>
	<OR <0? .LEN>
	    <MAPF <>
		<FUNCTION (MNEME OWT)<OR <==? .MNEME .OWT> <MAPLEAVE <>>>>
		 .ITM
		 <REST .DATA>>>>>



<GDECL (RANL)<UVECTOR [REST FIX]> (RANN) FIX>
<SETG RANL ![]>
<SETG RANN 7>
<DEFINE RANDOM-MNEME-ITEM () #DECL ((VALUE) OWT)
	<COND (<NOT <GASSIGNED? DHT>><ERROR "You forgot to MNEME-INITialize">)
	      (<EMPTY? ,RANL>
	       <REPEAT ()<SETG RANN <+ ,RANN 1>>
			<COND (<G? ,RANN 2047.><SETG RANN 8>)>
			<SETG RANL <GETBUCKET ,RANN>>
			<OR <EMPTY? ,RANL><RETURN>>>)>
	<SETG RANL <REST ,RANL>>
	<CHTYPE <1 <BACK ,RANL>> OWT>>



<DEFINE MNEME-NAMES (S "AUX" N OBJ NAME STR)
	#DECL ((STR) STRING (N) <OR FALSE FIX> (OBJ NAME) ATOM)
	<COND (<TYPE? .S ATOM>
		<COND (<SET N <COLON-CHK .S>>
			<COND (<0? .N> .S)
			      (<SET NAME <PARSE <REST <SET STR <SPNAME .S>> <+ 1 .N>>>>
			       <SET OBJ <PARSE <SUBSTRUC .STR 0 .N>>>
			       <COND (<ASSIGNED? .NAME>
				      <COND (<NOT <TYPE? ..NAME MNEME-INSTANCE>>
					     <ERROR "Colon usage">)>
				      ..NAME)
				     (<SET .NAME <CHTYPE ((.OBJ .NAME) -1 0)
							MNEME-INSTANCE>>
				      <SETG NAMELIST (.NAME !,NAMELIST)>
				      <PUT ..NAME 3 <SHASH ..NAME>>)>)>)
		      (.S)>)
	      (<AND <STRUCTURED? .S> <NOT <TYPE? .S MNEME-INSTANCE>>>
	       <MAPR <><FUNCTION (STRUC)<PUT .STRUC 1 <MNEME-NAMES <1 .STRUC>>>> .S>
	       <REPEAT ((S3 .S))
		 <COND (<EMPTY? .S3> <RETURN>)
		       (<AND <STRUCTURED? <1 .S3>>
			     <NOT <LENGTH? .S3 1>> <TYPE? <2 .S3> ATOM>
			     <SET N <COLON-CHK <2 .S3>>>>
			<SET NAME <PARSE <REST  <SPNAME <2 .S3>> <+ 1 .N>>>>
			<COND(<ASSIGNED? .NAME>
			      <COND (<NOT <TYPE? ..NAME MNEME-INSTANCE>>
				     <ERROR "Colon usage">)>)
			     (<SET .NAME <CHTYPE ((<1 .S3> .NAME) -1 0) MNEME-INSTANCE>>
			      <SETG NAMELIST (.NAME !,NAMELIST)>
			      <PUT .S3 1 <PUT ..NAME 3 <SHASH ..NAME>>>
			      <COND (<TYPE? .S3 LIST><PUTREST .S3 <REST .S3 2>>)
				    (<PUT .S3 2 IGNORE--THIS>)>)>)>
		 <SET S3 <REST .S3>>>
		.S)
	       (.S)>>

<DEFINE MNEME-NAMES2 (S)
   <COND (<AND <STRUCTURED? .S><NOT <TYPE? .S MNEME-INSTANCE>>>
	  <COND (<EMPTY? .S>)
		(<AND <TYPE? <1 .S> ATOM>
		      <ASSIGNED? <1 .S>>
		      <COND (<TYPE? .<1 .S> MNEME-INSTANCE>
			     <PUT .S 1 .<1 .S>>)>>)
		(<STRUCTURED? <1 .S>><MNEME-NAMES2 <1 .S>>)>
	  <COND (<EMPTY? .S>)
		(<MNEME-NAMES2 <REST .S>>)>)>>
	
<DEFINE MAKEUNIQUE (BAK ITM "AUX" X Y)
	#DECL ((BAK) <OR FIX FALSE>
	       (ITM) <OR LIST ATOM MNEME-INSTANCE FIX OWT> (X Y) ANY
	       (ATOMLIST LISTLIST MNEME-SEEN) <SPECIAL LIST>)
	 <COND (<==? .ITM IGNORE--THIS><>)
	       (<TYPE? .ITM ATOM>
		<SET Y <COND (<GETPROP .ITM .MNEME-SEEN>)
			     (<COND (<SET X <MNEME-EXIST .ITM>>
				     <PUTPROP .ITM .MNEME-SEEN .X>)
				    (<PUTPROP .ITM .MNEME-SEEN 0>
				     <SET ATOMLIST (.ITM !.ATOMLIST)> 0)>)>>
		<AND .BAK <TYPE? .Y FIX> <PUTPROP .ITM .MNEME-SEEN <+ .Y 1>>>
		.ITM)
	       (<TYPE? .ITM MNEME-INSTANCE>
		<COND ( <==? <2 .ITM> -1>
			<MAKEUNIQUE 1 <1 <1 .ITM>>>
			<SET LISTLIST (.ITM !.LISTLIST)> )>
		<PUT .ITM 2 <OR .BAK 0>>
		.ITM)
	       (<TYPE? .ITM OWT> .ITM)
	       (<TYPE? .ITM FIX>
		<COND (,MNUM 
		       <COND (<AND <==? ,MNUM CONVERT><L? <ABS .ITM> *037777777777*>>
			      .ITM)
			     (<MAKEUNIQUE .BAK <MNUM-ATOM .ITM>>)>)
		      (.ITM)>)
	       (<NOT <TYPE? .ITM LIST>> <ERROR "Bad type to makeunique" .ITM>)
	       (<SET Y <RGET .ITM>>		;"MAY RETURN NONEMPTY FALSE"
		<AND .BAK <PUT .Y 2 <+ <2 .Y> 1>>>  .Y)
	       (<SET X (.ITM <OR .BAK 0> <1 .Y>)>
		<COND (<EMPTY? .ITM> ())
		      ( <RPUT .ITM .X>
			<MAPF <><FUNCTION (I)<MAKEUNIQUE 1 .I>> .ITM>
			<SET LISTLIST (.ITM !.LISTLIST)>   .X)> )  >>


<SETG FALS-CON #FALSE (0 0 0)>
<GDECL (FALS-CON) <FALSE FIX ANY ANY>>

<DEFINE RGET (ITM "AUX" (H <SHASH .ITM>) L)
	#DECL ( (H) FIX (L) <OR FALSE LIST>
		(ITM VALUE) <OR MNEME-INSTANCE LIST FALSE>)
	<COND (<TYPE? .ITM MNEME-INSTANCE> .ITM)
	      (<AND <SET L <MEMQ .H <NTH ,EHT <+ <MOD .H 59> 1>>>>
		    <MAPF <>
		      <FUNCTION (LITM) #DECL ((LITM) <LIST LIST>)
			<COND (<=? <1 .LITM> .ITM> <MAPLEAVE .LITM>)
			      (<MAPF <><FUNCTION (A B)
					<COND (<TYPE? .A ATOM FIX>
					       <AND <TYPE? .B ATOM FIX>
						    <N==? .A .B><MAPLEAVE <>>>)
					      (<TYPE? .A STRING>
						<AND <TYPE? .B STRING><N=? .A .B>
						     <MAPLEAVE <>>>)
					      (<TYPE? .A OWT>
						<AND <TYPE? .B OWT><N==? .A .B>
						     <MAPLEAVE <>>>)
					      (T)>>
				     .ITM <1 .LITM> >
				<MAPLEAVE .LITM>)>>
		       <2 .L>>>)
	      (ELSE <PUT ,FALS-CON 1 .H>)>>

<DEFINE RPUT (ITM VAL "AUX" (H <SHASH .ITM>)
			    (L  <+ <MOD .H 59> 1>)
			    (EHTLST <NTH ,EHT .L>)
			    (L2 <MEMQ .H .EHTLST>))
	#DECL ((H L VALUE) FIX (EHTLST) LIST (L2) <OR LIST FALSE>)
	<COND (.L2 <PUT <SET L2 <REST .L2>> 1 (.VAL !<1 .L2>)>)
	      (<PUT ,EHT .L (.H (.VAL) !.EHTLST)>)>
	.H>

<DEFINE PAGE-REST ("AUX" (AS <ASSOCIATIONS>) AS2)
	#DECL ((AS AS2) <OR FALSE ASOC>)
	<REPEAT () <SET AS2 <NEXT .AS>>
		   <COND (<AND <==? <INDICATOR .AS> NEW-USES><TYPE? <ITEM .AS> FIX>>
			  <PAGE-OUT <ITEM .AS>>)>
		   <COND (<SET AS .AS2>)(<RETURN T>)>>>

<DEFINE PAGE-OUT (OWT "AUX" SIZ ULEN OLD-USIZ E-USES HEADER A-FIX LASTITEM
			    (USES <GETPROP .OWT NEW-USES>))
  #DECL ((OWT SIZ ULEN OLD-USIZ A-FIX HEADER LASTITEM) FIX
	 (USES) <OR FALSE <LIST [REST FIX]>> (E-USES) <LIST [REST FIX]>)
  <COND (.USES
	 <SET HEADER <MNEME-READ 1 .OWT>>
	 <SET SIZ <+ <CHTYPE <GETBITS .HEADER <BITS 6 30>>FIX>
		     <SET OLD-USIZ <CHTYPE <GETBITS .HEADER <BITS 15>> FIX>>
		     1>>
	 <COND (<G? .SIZ 16><PRINT ["*** Note--SIZ=" .SIZ .OWT]>)>
	 <SET ULEN <LENGTH .USES>>
	 <COND (<G=? <+ .ULEN .OLD-USIZ> 16383><ERROR "Capacity exceeded">)>
	 <SET LASTITEM <MNEME-READ 1 <+ .OWT .SIZ -1>>>
	 <COND (<AND <N==? .OLD-USIZ 0>
		     <==? <CHTYPE <GETBITS .LASTITEM <BITS 3 33>> FIX> 7>>
		<EXTEND-EXTENSION .USES <+ .OWT .SIZ -1> .LASTITEM .ULEN>)
	       (ELSE
		<SET A-FIX <MNEME-READ 1 <- .OWT 1>>>
		<COND (<OR <L=? .A-FIX 0> <G? .A-FIX 16382>>
			<ERROR "PIO block size = " .A-FIX .OWT PAGE-OUT>)
		      (<==? .SIZ .A-FIX>
		       <MNEME-WRITE <BLD-EXTENSION (.LASTITEM !.USES)>
				    <+ .OWT .SIZ -1>>)
		      (<L=? <+ .SIZ .ULEN> .A-FIX>
			<MNEME-WRITE .USES <+ .OWT .SIZ>>
			<MNEME-WRITE <ANDB <+ .HEADER .ULEN> *770000077777*> .OWT>)
		      (<SET E-USES <REST .USES <- .A-FIX .SIZ 1>>>
		       <COND (<==? <- .A-FIX .SIZ> 1><SET USES ()>)
			     (<PUTREST <REST .USES <- .A-FIX .SIZ 2>> ()>
			      <MNEME-WRITE .USES <+ .OWT .SIZ>>)>
		       <MNEME-WRITE <ANDB <+ .HEADER <LENGTH .USES> 1>
					  *770000077777*> .OWT>
		       <MNEME-WRITE <BLD-EXTENSION .E-USES>
				  <+ .OWT .A-FIX -1 >>)>)>
	 <PUTPROP .OWT NEW-USES>)>
	>


<DEFINE BLD-EXTENSION (USES "AUX" (LEN <LENGTH .USES>))
	#DECL ((USES) <LIST [REST FIX]> (VALUE) FIX)
	<SET USES (.LEN !.USES)>
	<COND (<G=? <1 .USES> 16383><ERROR "More than 16382 uses">)>
	<CHTYPE <PUTBITS <MNEME-WRITE .USES <RALLOCP ,MNEMECHN <+ 3 .LEN </ .LEN 3>>>>
			 <BITS 3 33> 7> FIX>   >

<SETG EEUV ![0 0]>
<GDECL (EEUV) <UVECTOR FIX FIX>>

<DEFINE EXTEND-EXTENSION (USES EXT-PTR EXT ULEN "AUX"
				       BLEN ELEN NUEXT UV )
	#DECL ((USES) <LIST [REST FIX]> (ULEN BLEN ELEN NUEXT EXT SIZ EXT-PTR) FIX
	       (VALUE) ANY (UV)<UVECTOR FIX FIX> )
	<SET UV <MNEME-READ ,EEUV <- .EXT 1>>>
	<SET BLEN <1 .UV>>
	<SET ELEN <2 .UV>>
	<COND (<OR <G? .BLEN 16383>
		   <G=? <+ .ULEN .ELEN> 16383>>
	       <ERROR "More than 16383 uses" .UV .EXT-PTR EXTEND-EXTENSION>)>
	<MNEME-WRITE <+ .ULEN .ELEN> .EXT>
	<COND (<G=? <+ .ULEN .ELEN> .BLEN>
		<SET NUEXT <RALLOCP ,MNEMECHN <+ 4 .ULEN .ELEN </ .ELEN 3>>>>
		<MNEME-WRITE <MNEME-READ <IUVEC8 <+ 1 .ELEN>> .EXT> .NUEXT>
		<RDALLOCP ,MNEMECHN <CHTYPE <GETBITS .EXT <BITS 24>> FIX>>
		<MNEME-WRITE .USES <+ .NUEXT .ELEN 1>>
		<MNEME-WRITE <ORB *700000000000* .NUEXT> .EXT-PTR>)
	       (<MNEME-WRITE .USES <+   .EXT .ELEN 1>>)>
	T  >


<SETG TEMP-UVEC9 <IUVECTOR <SETG TEMP-UVEC9-LEN 10> 0>>
<GDECL (TEMP-UVEC9-LEN) FIX (TEMP-UVEC9) <UVECTOR [REST FIX]>>

<DEFINE IUVEC9 (LEN) #DECL ((LEN) FIX (VALUE) <UVECTOR FIX>)
  <COND (<G? .LEN ,TEMP-UVEC9-LEN>
	 <SETG TEMP-UVEC9 <IUVECTOR <SETG TEMP-UVEC9-LEN <+ .LEN 32>> 0>>)>
  <REST ,TEMP-UVEC9 <- ,TEMP-UVEC9-LEN .LEN>>>

<SETG TEMP-UVEC8 <IUVECTOR <SETG TEMP-UVEC8-LEN 10> 0>>
<GDECL (TEMP-UVEC8-LEN) FIX (TEMP-UVEC8) <UVECTOR [REST FIX]>>

<DEFINE IUVEC8 (LEN) #DECL ((LEN) FIX (VALUE) <UVECTOR FIX>)
  <COND (<G? .LEN ,TEMP-UVEC8-LEN>
	 <SETG TEMP-UVEC8 <IUVECTOR <SETG TEMP-UVEC8-LEN <+ .LEN 32>> 0>>)>
  <REST ,TEMP-UVEC8 <- ,TEMP-UVEC8-LEN .LEN>>>

<SETG TEMP-UVEC10B <IUVECTOR <SETG TEMP-UVEC10B-LEN 10> 0>>
<GDECL (TEMP-UVEC10B-LEN) FIX (TEMP-UVEC10B) <UVECTOR [REST FIX]>>

<DEFINE IUVEC10B (LEN) #DECL ((LEN) FIX (VALUE) <UVECTOR FIX>)
  <COND (<G? .LEN ,TEMP-UVEC10B-LEN>
	 <SETG TEMP-UVEC10B <IUVECTOR <SETG TEMP-UVEC10B-LEN <+ .LEN 32>> 0>>)>
  <REST ,TEMP-UVEC10B <- ,TEMP-UVEC10B-LEN .LEN>>>


<DEFINE MNEME-WRITE (DATA LOC "AUX" WRITN)
	#DECL ((DATA) <OR <UVECTOR  <PRIMTYPE WORD>> <PRIMTYPE WORD> STRING LIST>
	       (LOC VALUE) FIX (WRITN) <OR FIX FALSE>)
	<SET LOC <CHTYPE <ANDB .LOC *000077777777*> FIX>>
	<COND (<GASSIGNED? PIO-TRACE>
	       <PRINT <COND (<==? <PRIMTYPE .DATA> WORD> 1)
			    (<TYPE? .DATA STRING></ <+ <LENGTH .DATA> 4> 5>)
			    (<LENGTH .DATA>)>
				  ,PIO-TRACE>
	       <PRINC "	W@	" ,PIO-TRACE>
	       <PRINC .LOC	  ,PIO-TRACE>)>
	<COND (<==? <PRIMTYPE .DATA> WORD>
		<OR <SET WRITN <PRINTP ,MNEMECHN .LOC <CHTYPE .DATA WORD>>>
		    <ERROR "PRINTP returns false" .LOC .WRITN
			   <NTH ,PIO-ERROR-VECTOR <1 .WRITN>>>>)
	      (<EMPTY? .DATA>)
	      (<TYPE? .DATA UVECTOR LIST>
		<COND (<TYPE? .DATA LIST>
		       <MAPR <><FUNCTION (X Y) #DECL ((X) LIST (Y) UVECTOR)
				<PUT .Y 1 <1 .X>>>
			     .DATA <SET DATA <IUVEC10B <LENGTH .DATA>>>>)>
		<OR <SET WRITN <PRINTP ,MNEMECHN .LOC .DATA>>
		    <ERROR "PRINTP returns false" .LOC .WRITN
			   <NTH ,PIO-ERROR-VECTOR <1 .WRITN>>>>)
	      (<TYPE? .DATA STRING>
		<REPEAT ((N .LOC)) #DECL ((N) FIX)
		   <OR <SET WRITN <PRINTP ,MNEMECHN
					  .N <CHTYPE <STR-TO-FIX .DATA> WORD>>>
		       <ERROR "PRINTP returns false" .LOC .WRITN
			      <NTH ,PIO-ERROR-VECTOR <1 .WRITN>>>>
		   <COND (<LENGTH? .DATA 5><RETURN>)>
		   <SET DATA <REST .DATA 5>>
		   <SET N <+ .N 1>>  >      )
	      (<ERROR "Bad type to MNEME-WRITE" .DATA>)>
	.LOC>

<DEFINE RDALLOCP (CHNP LOC "AUX" X) #DECL ((CHNP) CHANP (LOC) FIX)
	<SET X <DALLOCP .CHNP .LOC>>
	<COND (<GASSIGNED? PIO-TRACE>
		<CRLF ,PIO-TRACE>
		<PRINC !\	 ,PIO-TRACE>
		<PRINC .LOC ,PIO-TRACE>
		<PRINC !\	 ,PIO-TRACE>
		<PRINC .X ,PIO-TRACE>)>
	<OR .X
	    <ERROR "DALLOCP returns false: " .X <NTH ,PIO-ERROR-VECTOR <1 .X>>
		   "ERRET <> to try again">
	     <DALLOCP .CHNP .LOC> <ERROR "SORRY">>>

<DEFINE RALLOCP (CHNP AMT "AUX" X) #DECL ((CHNP) CHANP (AMT) FIX)
	<SET X <ALLOCP .CHNP .AMT 3>>
	<COND (<GASSIGNED? PIO-TRACE>
		<PRINT .AMT ,PIO-TRACE>
		<PRINC !\	 ,PIO-TRACE>
		<PRINC .X ,PIO-TRACE>)>
	<OR .X
	    <ERROR "ALLOCP return false: " .X <NTH ,PIO-ERROR-VECTOR <1 .X>>
		   "ERRET <> to try again">
	    <ALLOCP .CHNP .AMT> <ERROR "SORRY">>>

<SETG MNEME-PAGE-OUT ,PAGE-REST>

<ENDPACKAGE>
