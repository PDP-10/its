<PACKAGE "MNEME">
'<BLOAT 45000 0 2000 3000 50> 
<ENTRY  MNEME-INIT	MNUM-EXIST	STORALLOC
	MNEMECHN	SUPERFIND	LIST-MNEME-EXIST DHT		STR-TO-FIX
	MNEME-LIST	MNEME-NTH	OWT		NREVERSE	FINDVAL
	MNEME-EXIST	MNEME-VERBOSE 	STR-TO-NUM	UV-ZAP		FINDVALS
 	MNEME-COMP	MNEME-VERSION	SHASH		COLON-CHK	FINDOBJ
	MNEME-EXIST?	MNEME-TO-MUDDLE	FIND		FINDS		FINDUSE
	MNEME-INSTANCE	MNEME-PAGE-OUT 	HASH-ATOM	FINDUSES	GROUP-PAGE-OUT
	MNEME-ATOM	MNEME-CLOSE	FINDOBJS	RECLAIM-MIN	NEW-USES
	MNEME-TYPE?	TRANSCHK	TRANSFINDVAL	TRANSFINDOBJ	MNUM-ATOM
	MNEME-LENGTH	IUBKT		STOR		STORSIZ
 	MNEME-READ	STORNXT		STORPLUS1	IHT	PARTIAL-PAGE-IN-CHK
	HASH-OWT-ATOM	HASH-OWT-INST>

<SETG MNEME-VERSION 0>

<USE "PIO">
<SETG PIO-HANG-ON-UNMAP? T>	;"Never delete this"
<SETG PIO-PAGE-LIMIT 100>

<GDECL (MNEME-PAGE-OUT) APPLICABLE>
<SETG GC-OB <MOBLIST GC-OB 1>>
<SETG MNEME-VERBOSE T>
<NEWTYPE MNEME-INSTANCE LIST '<LIST <LIST ANY> ANY>>
<EVALTYPE MNEME-INSTANCE LIST>
<NEWTYPE OWT WORD>

<DEFINE MNEME-IPRINT (X) #DECL ((X) MNEME-INSTANCE) 
	<COND (<LENGTH? <1 .X> 1><PRINC <CHTYPE <2 .X> OWT>>)
	      (<PRINC <COND (<TYPE? <1 <1 .X>> OWT><1 <1 .X>>)
			    ("Not-printable-yet")>>
		<PRINC !\: ><PRINC <2 <1 .X>>>)>>

<PRINTTYPE MNEME-INSTANCE ,MNEME-IPRINT>

<DEFINE OWTPRINT (O!-GC-OB "AUX" CNT TYP O2!-GC-OB)
  #DECL ((O!-GC-OB O2!-GC-OB) <SPECIAL <OR OWT FIX>> (CNT TYP) FIX
	 (OUTCHAN) <SPECIAL ANY>)
  <SET TYP <CHTYPE <GETBITS .O!-GC-OB #BITS *410300000000*> FIX>>
  <COND(<==? .TYP 5>
	  <PRINC <CHTYPE <PUTBITS .O!-GC-OB
				  <BITS 3 33>
				  <* 7 <CHTYPE <GETBITS .O!-GC-OB <BITS 1 32>>
							FIX>>>
		  FIX>>)
	(<NOT <GASSIGNED? MNEMECHN>><ERROR "MNEME-CHANNEL-CLOSED">)
        (<G? .TYP 2><ERROR "Trying to print unknown or illegal MNEME-type">)
	(<0? <CHTYPE .O!-GC-OB FIX>><ERROR "Zero mneme item"> 0)
        (<SET O!-GC-OB <PARTIAL-PAGE-IN-CHK .O!-GC-OB>>
         <SET CNT
	      <CHTYPE <GETBITS <NTH ,STORPLUS1 .O!-GC-OB> #BITS *360600000000*>
		      FIX>>
         <COND
          (<0? .TYP>
	   <COND (<AND <TYPE? .OUTCHAN CHANNEL>
		       <G? <* .CNT 5> <- <13 .OUTCHAN><14 .OUTCHAN>>>>
		  <CRLF>)>
	   <REPEAT ((CNTUP 0) X) #DECL ((CNTUP) FIX (X) STRING)
		    <COND (<==? .CNTUP .CNT><RETURN>)(<SET CNTUP <+ .CNTUP 1>>)>
		    <SET X <PUT-FIX-IN-STRING <NTH <REST ,STORPLUS1 .CNTUP> .O!-GC-OB>
					      ,STRING5>>
		    <PRINC <COND (<==? <1 .X> <ASCII 26>> <REST .X>)(.X)>>>)
	  (<==? .TYP 1><PRINC "#MNEME (">
	   <REPEAT ((CNTUP 1)) #DECL ((CNTUP) FIX)
	     <SET O2!-GC-OB <NTH <REST ,STORPLUS1 .CNTUP> .O!-GC-OB>>
	     <PRINC <CHTYPE <COND (<AND <L=? .O2!-GC-OB 262143><G? .O2!-GC-OB 0>>
				   <NTH ,STOR .O2!-GC-OB>)
				  (.O2!-GC-OB)> OWT>>
	     <COND (<==? .CNTUP .CNT><RETURN>)(<SET CNTUP <+ 1 .CNTUP>><PRINC !\  >)>>
	   <PRINC !\) >)
	  (<==? .TYP 2> <SET O2!-GC-OB <NTH ,STORPLUS2 .O!-GC-OB>>
	   <PRINC <CHTYPE <COND (<AND <L=? .O2!-GC-OB 262143.><G? .O2!-GC-OB 0>>
				 <NTH ,STOR .O2!-GC-OB>)
			        (.O2!-GC-OB)> OWT>>
	   <PRINC !\: >
	   <REPEAT ((CNTUP 1)) #DECL ((CNTUP) FIX)
	    <COND (<==? .CNTUP .CNT><RETURN>)(<SET CNTUP <+ .CNTUP 1>>)>
	    <PRINC <PUT-FIX-IN-STRING <NTH <REST ,STORPLUS1 .CNTUP> .O!-GC-OB>
				      ,STRING5>>>
	   <PRINC !\  >)>)>>

<PRINTTYPE OWT ,OWTPRINT>

<FLOAD "RSOWL NBIN ARC:">


<SETG STRING5 "     ">

<GDECL  (STOR STORPLUS1 STORPLUS2 UBKT TEMP2-UVEC TEMP4-UVEC)
	<UVECTOR [REST FIX]> (IHT) <UVECTOR [1536 FIX] [REST FIX]>
	(TEM-STR STRING5) STRING (DHT) <VECTOR STRING STRING FIX>
	(TEMP2-UVEC-LEN TEMP4-UVEC-LEN
	 TEM-STR-LEN UBKTLEN STORSIZ STORNXT)	 FIX
	(MNEMECHN) CHANP (MNEME-VERBOSE) <OR FALSE ATOM>   >


<DEFINE MNEME-COMP (OWT AorS)
	#DECL ((OWT) OWT (AorS) <OR ATOM STRING> (VALUE)<OR FALSE 'PROBABLY>)
	<AND <==? <CHTYPE <GETBITS .OWT <BITS 12 24>> FIX> <HASH-ATOM .AorS 509>>
	     'PROBABLY>>


;"Timing test for SUPERFIND and MNEME-EXIST:  (VERSION 23 IN ())
	SUPERFIND of 1 arg in NEW-USES	0.0062 seconds (.0074)
	SUPERFIND          on disk	0.0081 (?)
	SUPERFIND	   in cache	0.0071 (.0055)
	SUPERFIND          NON-EXISTing 0.0146
	MNEME-EXIST string in NEW-USES	0.0125 (.0037)
	MNEME-EXIST	   on disk	0.0145 (.0234)
	MNEME-EXIST	   in cache	0.0118 (.0036)
	MNEME-EXIST	   non-existing 0.0124 (.0092)
	<MNEME-INIT ...><MNEME-CLOSE> takes 0.3 (.27)"

<DEFINE SUPERFIND (ITM1
		   "OPTIONAL" (POS1 !\A) (ITM2 <>) (POS2 1) (AMOUNT 1)
		   (EXTRACT <>) "AUX" ITM!-GC-OB
				      (STOR <COND (<GASSIGNED? DHT> ,STOR)
						  (<ERROR "You forgot to MNEME-INIT.">)>)
					(STORPLUS1 <REST .STOR>)
					)
   #DECL ((ITM!-GC-OB) <SPECIAL FIX>
	  (ITM2 ITM1) <OR OWT ATOM FALSE FIX STRING>
	  (VALUE) <OR OWT LIST FALSE FIX> (POS1 POS2) <OR CHARACTER FIX>
	  (EXTRACT) <OR FALSE FIX CHARACTER>
	  (AMOUNT)<OR FIX CHARACTER> (STOR STORPLUS1)<UVECTOR [REST FIX]>)

   <OR  <TYPE? .ITM1 OWT>
	<SET ITM1 <MNEME-EXIST? .ITM1>>
	<SET ITM1 0>>

   <SET ITM1 <CHTYPE .ITM1 FIX>>
   <OR <0? .ITM1> <SET ITM!-GC-OB <PARTIAL-PAGE-IN-CHK .ITM1>>>

   <AND .ITM2
	<COND (<TYPE? .ITM2 OWT>)
	      (<SET ITM2 <MNEME-EXIST? .ITM2>>)
	      (<SET ITM2 <SET ITM1 0>>)>
	<SET ITM2 <CHTYPE .ITM2 FIX>>>

   <AND
    <COND (<0? .ITM1> #FALSE (NON-EXISTENT-ITEM)) (T)>
    <REPEAT ((FLAG 0) (ANS <>)
	     (CNTSAV <CHTYPE <GETBITS <NTH .STORPLUS1 .ITM!-GC-OB> <BITS 15>> FIX>)
	     (OFFSET <REST .STORPLUS1
			   <CHTYPE <GETBITS <NTH .STORPLUS1 .ITM!-GC-OB> <BITS 6 30>>
				   FIX>>)
	     (USES '![]) USE!-GC-OB XX DCNT)

      #DECL ((OFFSET) <UVECTOR FIX> (FLAG CNTSAV DCNT) FIX
	     (ITM!-GC-OB USE!-GC-OB) <SPECIAL FIX>
	     (VALUE ANS) <OR LIST FALSE FIX OWT>
	     (USES) <UVECTOR [REST FIX]> (XX) <OR LIST FALSE> )

      <COND (<EMPTY? .USES>
	     <COND
		(<AND <0? .FLAG><SET XX <GETPROP .ITM1 NEW-USES>>>	;"Do new uses"
		 <SET FLAG 1>
		 <SET USES <UVECTOR !.XX>>)
		(<L=? .FLAG 1>
		 <SET FLAG 2>			;"Do local uses"
		 <AND <0? .CNTSAV><RETURN .ANS>>
		 <SET USES <SUBSTRUC <REST .OFFSET .ITM!-GC-OB> 0 .CNTSAV
				     <IUVEC4 .CNTSAV>>>)
		(<==? .FLAG 2><RETURN .ANS>)>

	     <AND <EMPTY? .USES><AGAIN>>)>

      <SET USE!-GC-OB <1 .USES>>
      <SET USES <REST .USES>>

      <AND
	;"Beginning of first and clause--purpose= get next use"
	<COND (<==? <CHTYPE <GETBITS .USE!-GC-OB <BITS 3 33>> FIX> 7>	;EXTENSION
		<SET USE!-GC-OB <PARTIAL-PAGE-IN-CHK .USE!-GC-OB>>
		<SET CNTSAV <CHTYPE <GETBITS <NTH .STORPLUS1 .USE!-GC-OB>
					     <BITS 15>> FIX>>
		<SET USES <COND (<0? .CNTSAV>![])
				(<SUBSTRUC <REST .STORPLUS1 .USE!-GC-OB> 0 .CNTSAV
					   <IUVEC4 .CNTSAV>>)>>
		<AGAIN>)
	      (<AND <NOT .EXTRACT><NOT .ITM2><==? .POS1 !\A>>)
	      (<SET USE!-GC-OB <PARTIAL-PAGE-IN-CHK .USE!-GC-OB>>
		<SET DCNT <CHTYPE <GETBITS <NTH .STORPLUS1 .USE!-GC-OB>
					   <BITS 6 30>> FIX>>)>

	;"Beginning of second and-clause"
       <COND (<==? .AMOUNT !\N>
	      <SET ANS <COND (.ANS <+ .ANS 1>)(1)>>
	      <L=? <COND (<GETPROP .ITM1 .ITM2>)
			 (<PUTPROP .ITM1 .ITM2 0> 0)>
		   .ANS>)
	     (<==? .AMOUNT !\R>
	      <RETURN <PUTPROP .ITM1 .ITM2>>)
	     (T)>

	;"Beginning of third moby and clause--purpose= to check position"
       <OR
	<==? .POS1 !\A>
	<COND (<TYPE? .POS1 FIX>
	       <==? .ITM1 <NTH .STORPLUS1 <+ .USE!-GC-OB .POS1>>>)
	      (<==? .POS1 !\L>
	       <==? .ITM1 <NTH .STORPLUS1 <+ .USE!-GC-OB .DCNT>>>)>>

	 ;"Beginning of fourth clause--purpose to chk ITM2's position"
       <COND
	(.ITM2
	 <COND
	  (<TYPE? .POS2 FIX>
	   <==? .ITM2 <NTH .STORPLUS1 <+ .USE!-GC-OB .POS2>>>)
	  (<==? .POS2 !\A>
	   <REPEAT ((CNT .DCNT))
		   #DECL ((CNT) FIX)
		   <COND (<0? .CNT> <RETURN <>>)
			 (<==? .ITM2 <NTH .STORPLUS1 <+ .USE!-GC-OB .CNT>>>
			  <RETURN T>)>
		   <SET CNT <- .CNT 1>>>)
	  (<==? .POS2 !\L>
	   <==? .ITM2 <NTH .STORPLUS1 <+ .USE!-GC-OB .DCNT>>>)>)
	(T)>

	 ;"Beginning of last AND clause--gets amount"
       <COND
	(<==? .AMOUNT 1>
	 <RETURN <COND  (.EXTRACT <INT-MNEME-NTH .USE!-GC-OB .EXTRACT .DCNT>)
			(<L=? .USE!-GC-OB *777777*>
			 <CHTYPE <NTH .STOR .USE!-GC-OB> OWT>)
			(<CHTYPE .USE!-GC-OB OWT>)>>)
	(<TYPE? .AMOUNT FIX>
	 <SET ANS (<COND (.EXTRACT <INT-MNEME-NTH .USE!-GC-OB .EXTRACT .DCNT>)
			 (<L=? .USE!-GC-OB *777777*>
			  <CHTYPE <NTH .STOR .USE!-GC-OB> OWT>)
			 (<CHTYPE .USE!-GC-OB OWT>)> !.ANS)>
	 <COND (<G=? <LENGTH .ANS> .AMOUNT> <RETURN .ANS>)
	       (<SET ANS <CHTYPE .ANS FALSE>>)>)
	(<MEMQ .AMOUNT '![ !\A !\S]>
	 <SET ANS (<COND (.EXTRACT <INT-MNEME-NTH .USE!-GC-OB .EXTRACT .DCNT>)
			 (<L=? .USE!-GC-OB *777777*>
			  <CHTYPE <NTH .STOR .USE!-GC-OB> OWT>)
			 (<CHTYPE .USE!-GC-OB OWT>)> !.ANS)>)
	(<==? .AMOUNT !\N>
	 <COND (<G? .ANS <GETPROP .ITM1 .ITM2>>
	        <PUTPROP .ITM1 .ITM2 .ANS>
		<RETURN <COND (.EXTRACT <INT-MNEME-NTH .USE!-GC-OB .EXTRACT .DCNT>)
			      (<L=? .USE!-GC-OB *777777*>
			       <CHTYPE <NTH .STOR .USE!-GC-OB> OWT>)
			      (<CHTYPE .USE!-GC-OB OWT>)> >)>)
	(<==? .AMOUNT !\C> <SET ANS <COND (.ANS <+ .ANS 1>) (1)>>)
	(<ERROR "Other amount options not implemented yet">)>>>>
	>




<DEFINE FINDVAL (OBJ REL) #DECL ((OBJ REL)<OR OWT ATOM STRING>)
		<SUPERFIND .OBJ 2   .REL 1>>
<DEFINE FINDVALS(OBJ REL) #DECL ((OBJ REL)<OR OWT ATOM STRING>)
		<SUPERFIND .OBJ 2   .REL 1 !\A>>
<DEFINE FINDOBJ (OBJ REL) #DECL ((OBJ REL)<OR OWT ATOM STRING>)
		<SUPERFIND .OBJ 3   .REL 1>>
<DEFINE FINDOBJS(OBJ REL) #DECL ((OBJ REL)<OR OWT ATOM STRING>)
		<SUPERFIND .OBJ 3   .REL 1 !\A>>
<DEFINE FIND    (OBJ REL) #DECL ((OBJ REL)<OR OWT ATOM STRING>)
		<SUPERFIND .OBJ !\A .REL 1>>
<DEFINE FINDS   (OBJ REL) #DECL ((OBJ REL)<OR OWT ATOM STRING>)
		<SUPERFIND .OBJ !\A .REL 1 !\A>>
<DEFINE FINDUSE (OBJ) #DECL ((OBJ)<OR OWT ATOM STRING>) <SUPERFIND .OBJ>>
<DEFINE FINDUSES(OBJ) #DECL ((OBJ)<OR OWT ATOM STRING>) <SUPERFIND .OBJ !\A <> 1 !\A>>


<DEFINE MNEME-TYPE? (MNEME "TUPLE" TYPES)
   #DECL ((MNEME) OWT (VALUE) <OR ATOM FALSE>)
   <COND (<EMPTY? .TYPES><NTH '![MNEME-ATOM MNEME-LIST MNEME-INSTANCE!]
	 		      <+ 1 <CHTYPE <GETBITS .MNEME <BITS 3 33>> FIX>>>)
	 (<MEMQ <MNEME-TYPE? .MNEME> .TYPES> T)>>


<DEFINE MNEME-LENGTH (OWT "AUX" (OTYP <CHTYPE <GETBITS .OWT <BITS 3 33>> FIX>))
	#DECL ((OWT) OWT (VALUE OTYP) FIX)
	<COND (<==? .OTYP 1>
		<CHTYPE <GETBITS <NTH ,STORPLUS1 <PARTIAL-PAGE-IN-CHK .OWT>>
				 <BITS 6 30>> FIX>)
	      (<==? .OTYP 2> 1)
	      (<ERROR "Illegal mneme-type to MNEME-LENGTH">)>>

<DEFINE INT-MNEME-NTH (STORPTR N SIZ)
	  #DECL ((STORPTR SIZ) FIX (N) <OR FIX CHARACTER> (VALUE)<OR OWT FIX>)
   <COND (<==? .N !\L><SET N .SIZ>)>
   <COND (<OR <G? .N .SIZ><L=? .N 0>>
	  <ERROR "MNEME-NTH out of bounds--bad arg to SUPERFIND">)
         (<SET STORPTR <NTH ,STORPLUS1 <+ .N .STORPTR>>>
	  <COND (<G? .STORPTR *777777*> <CHTYPE .STORPTR OWT>)
		(<==? <CHTYPE <GETBITS .STORPTR <BITS 3 33>> FIX> 5>
		 <CHTYPE <PUTBITS .STORPTR <BITS 3 33>
				<* 7 <CHTYPE <GETBITS .STORPTR <BITS 1 32>> FIX>>>
			FIX>)
	(<ERROR "Funny item extracted">) >)>>

<DEFINE MNEME-NTH (MNEME "OPTIONAL" (N 1) "AUX" IN!-GC-OB)
 #DECL ((MNEME) OWT (N) FIX (IN!-GC-OB) <SPECIAL FIX> (VALUE) <OR OWT FIX>)
 <COND (<MEMQ <GETBITS .MNEME <BITS 3 33>> '![#WORD 1 #WORD 2]>
	<SET IN!-GC-OB <PARTIAL-PAGE-IN-CHK .MNEME>>
	<COND (<OR <G? .N<CHTYPE <GETBITS <NTH ,STORPLUS1 .IN!-GC-OB> <BITS 6 30>> FIX>>
		   <L=? .N 0>>
	       <ERROR "MNEME-NTH out of bounds">)>
	<SET IN!-GC-OB <NTH ,STORPLUS1 <+ .N .IN!-GC-OB>>>
	<COND (<G? .IN!-GC-OB *777777*> <CHTYPE .IN!-GC-OB OWT>)
	      (<==? <CHTYPE <GETBITS .IN!-GC-OB <BITS 3 33>> FIX> 5>
	       <CHTYPE <PUTBITS .IN!-GC-OB <BITS 3 33>
				<* 7 <CHTYPE <GETBITS .IN!-GC-OB <BITS 1 32>>FIX>>>
			 FIX>)
	      (<ERROR "Funny item extracted">)>)
       (<ERROR "Wrong type to MNEME-NTH">)>>



<DEFINE PARTIAL-PAGE-IN (OWT "AUX" UV ITMSIZ2 ITMSIZ USIZ IHTLOC)
 #DECL ((ITMSIZ VALUE USIZ IHTLOC ITMSIZ2) FIX (OWT) <OR OWT FIX> 
	(UV) <OR FIX <UVECTOR FIX>>)
 <SET UV <MNEME-READ 1 .OWT>>
 <SET ITMSIZ <CHTYPE <GETBITS .UV <BITS 6 30>> FIX>>
 <SET   USIZ <CHTYPE <GETBITS .UV <BITS 15.>> FIX>>
 <SET UV <MNEME-READ <IUVEC2 <+ .ITMSIZ .USIZ 1>> .OWT>>
 <SET IHTLOC <CHTYPE <GETBITS .OWT <BITS 12 24>> FIX>>
 <AND <G? .IHTLOC 1536><SET IHTLOC <+ 1024 <MOD .OWT 509>>>>
 <SET ITMSIZ2 <- .ITMSIZ 1>>
 <COND (<G? <+ .ITMSIZ .USIZ 4><- ,STORSIZ ,STORNXT>>
        <SET UV ![!.UV!]>   ;"COPY DUE TO IUVEC2"
        <GROUP-PAGE-OUT>)>
 <NTH <PUT ,IHT .IHTLOC <STORALLOC .OWT <PUTBITS <1 .UV> <BITS 15 15>
						 <NTH ,IHT .IHTLOC>>
				 <REST .UV>>> .IHTLOC>   >


<SETG TEMP4-UVEC <IUVECTOR <SETG TEMP4-UVEC-LEN 10> 0>>

<DEFINE IUVEC4 (LEN) #DECL ((LEN) FIX (VALUE) <UVECTOR FIX>) ;"Used by superfind"
  <COND (<G? .LEN ,TEMP4-UVEC-LEN>
	 <SETG TEMP4-UVEC <IUVECTOR <SETG TEMP4-UVEC-LEN <+ .LEN 32>> 0>>)>
  <REST ,TEMP4-UVEC <- ,TEMP4-UVEC-LEN .LEN>>>

<SETG TEMP2-UVEC <IUVECTOR <SETG TEMP2-UVEC-LEN 10> 0>>

<DEFINE IUVEC2 (LEN) #DECL ((LEN) FIX (VALUE) <UVECTOR FIX>)
  <COND (<G? .LEN ,TEMP2-UVEC-LEN>
	 <SETG TEMP2-UVEC <IUVECTOR <SETG TEMP2-UVEC-LEN <+ .LEN 32>> 0>>)>
  <REST ,TEMP2-UVEC <- ,TEMP2-UVEC-LEN .LEN>>>


<DEFINE STORALLOC ("TUPLE" TUP "AUX" (LOC ,STORNXT)
				     (WHERE <REST ,STOR <- .LOC 1>>)(CNT 0))
	#DECL ((LOC CNT) FIX (WHERE)<UVECTOR [REST FIX]>
		)
	<MAPF <><FUNCTION (ITM)
		   <COND
		      (<STRUCTURED? .ITM>
		       <COND (<TYPE? .ITM STRING>
			      <OR <==? .ITM <TOP .ITM>><ERROR STORALLOC>>
			      <REPEAT ()<COND (<EMPTY? .WHERE><STORGRO>)>
					<PUT .WHERE 1 <STR-TO-FIX .ITM>>
					<SET CNT <+ .CNT 1>>
					<SET WHERE <REST .WHERE>>
					<AND <LENGTH? .ITM 5><RETURN>>
					<SET ITM <REST .ITM 5>>>)
			     (<MAPF <><FUNCTION (Z) #DECL ((Z)<PRIMTYPE WORD>)
					<AND <EMPTY? .WHERE><STORGRO>>
					<PUT .WHERE 1 <CHTYPE .Z FIX>>
					<SET CNT <+ .CNT 1>>
					<SET WHERE <REST .WHERE>>>
				    .ITM>)>)
		      (<SET CNT <+ .CNT 1>> <AND <EMPTY? .WHERE><STORGRO>>
		       <SET WHERE <REST <PUT .WHERE 1 <CHTYPE .ITM FIX>>>>)>>
		.TUP>
	<SETG STORNXT <+ .LOC .CNT>>
	.LOC>

<DEFINE STORGRO ()
	<AND ,MNEME-VERBOSE <PRINT "Increasing STOR">>
	<GROW ,STOR 256 0>
	<SETG STORSIZ <LENGTH ,STOR>>>

<DEFINE MNEME-CLOSE ("OPTIONAL" (FLUSH <>)) #DECL ((FLUSH) <OR ATOM FALSE>)
  <COND(<GASSIGNED? DHT>
	<OR <=? <1 ,DHT> "READ"> <PAGE-OUT-EVERYTHING>>
	<GUNASSIGN DHT>
	<CLOSEP ,MNEMECHN>
	'"<FORCE-PAGES>		;Useful only for pmap"
	<GUNASSIGN MNEMECHN>
	<AND .FLUSH <SETG STOR <SETG STORPLUS1 <SETG STORPLUS2 ![]>>>>
	"Done")
       (T #FALSE ("File already closed?"))>>

<DEFINE PAGE-OUT-EVERYTHING ("AUX" (INT-LEVEL1 <INT-LEVEL 4000>)
				  (RESET-LIST ())  LVALA "ACT" F)
 #DECL ((LVALA INT-LEVEL1) FIX (RESET-LIST) <LIST [REST LOCATIVE]>
	 (F)<OR ACTIVATION FRAME>)

   <REPEAT ()
    <COND (<==? <FUNCT .F>  TOPLEVEL><RETURN T>)>
    <MAPF <><FUNCTION (ATM) #DECL ((ATM) ATOM)
	    <COND (<AND <ASSIGNED? .ATM .F>
			<TYPE? <LVAL .ATM .F> FIX>
			<SET LVALA <LVAL .ATM .F>>
			<COND (<G? .LVALA 0> <L=? .LVALA ,STORSIZ>)
			      (<==? <CHTYPE <GETBITS .LVALA <BITS 3 33>> FIX> 6>
			       <SET LVALA <CHTYPE <GETBITS .LVALA <BITS 18>> FIX>>)>>
		   <SET .ATM <NTH ,STOR .LVALA> .F>
		   <SET RESET-LIST (<LLOC .ATM .F> !.RESET-LIST)>)> >
	<1 ,GC-OB>>
     <SET F <FRAME .F>> >

   <UV-ZAP ,IHT>
   <UV-ZAP ,STOR>
   <SETG STORNXT 1>
   <AND <GASSIGNED? MNEME-PAGE-OUT> <APPLY ,MNEME-PAGE-OUT>>

   <MAPF <><FUNCTION (ATM) #DECL ((ATM) LOCATIVE)
	     <SETLOC .ATM <COND (<==?  <CHTYPE <ANDB <IN .ATM> *700000000000*> FIX>
					*700000000000*>
				 <PARTIAL-PAGE-IN <IN .ATM>>)
				(<PARTIAL-PAGE-IN-CHK <IN .ATM>>)>>>
	  .RESET-LIST>

   <INT-LEVEL .INT-LEVEL1> >

<DEFINE GROUP-PAGE-OUT ()<AND ,MNEME-VERBOSE <PRINC "MNEME-GARBAGE-COLLECTION"><TERPRI>>
			 <PAGE-OUT-EVERYTHING>
			 <AND ,MNEME-VERBOSE <PRINC "RECLAIMED-EVERYTHING"><TERPRI>> >


<DEFINE FIRSTATOMN (X)  #DECL ((X) ANY (VALUE) FIX)
  <COND (<TYPE? .X ATOM STRING> <HASH-ATOM .X 92681>)
	(<TYPE? .X FIX> <+ 1 <MOD <* 4 <ABS .X>> 92681>>)
	(<TYPE? .X OWT>
	 <COND (<0? <CHTYPE <GETBITS .X <BITS 3 33>> FIX>>
		<HASH-OWT-ATOM .X 92681>)
	       (<==? 2 <CHTYPE <GETBITS .X <BITS 3 33>> FIX>>
		<HASH-OWT-INST .X 92681 <MNEME-NTH .X>>)
	       (<SHASH <MNEME-TO-MUDDLE .X>>)>)
	(<TYPE? .X LIST><SHASH .X>)
	(<TYPE? .X MNEME-INSTANCE><3 .X>)
	(<ERROR .X "Bad type to hash">)>>


<DEFINE UVECIFY (ATM N) #DECL ((ATM) ATOM (N) FIX (VALUE) <UVECTOR FIX>)
	<COND (<AND <GASSIGNED? .ATM><==? <LENGTH ,.ATM> .N>>
		<UV-ZAP ,.ATM> ,.ATM)
	      (<SETG .ATM <IUVECTOR .N 0>>)>>

<DEFINE MNEME-INIT ("OPTIONAL"  (MODE "READ")
				(FILE-SPEC "DICT;ERB MNEME")
				(PAGE-SIZE 4096) (MAP-SPACE 22)
				   "AUX" TEMP)
  #DECL ((FILE-SPEC MODE) STRING (PAGE-SIZE) FIX (MAP-SPACE) <OR FIX FALSE>)
  <AND  <MEMBER .FILE-SPEC '["READ" "PRINT"]>
	<SET TEMP .FILE-SPEC>
	<SET FILE-SPEC .MODE>
	<SET MODE .TEMP>>
  <COND (<G? .PAGE-SIZE 32767><ERROR "Paging space > 32767">)>
  <AND <GASSIGNED? DHT><MNEME-CLOSE> ,MNEME-VERBOSE <PRINT "Closing old channel">>
  <UVECIFY IHT 1536>
  <SETG STORSIZ .PAGE-SIZE>
  <SETG STORNXT 1>
  <SETG STORPLUS2 <REST <SETG STORPLUS1 <REST <UVECIFY STOR .PAGE-SIZE>>>>>
  <SET TEMP <OPENP .MODE .FILE-SPEC <OR .MAP-SPACE 30> <NOT .MAP-SPACE>>>
  <COND (<NOT .TEMP><ERROR .TEMP>)
	(<0? <LENGTHP <SETG MNEMECHN .TEMP>>>		;"New file?"
	 <OR <SET TEMP <PRINTP ,MNEMECHN 2047 #WORD 0>><ERROR .TEMP>>)>
  <AND  <N=? .MODE "READ">
	<NOT <0? <MNEME-READ 1 1>>>
	<CLOSEP ,MNEMECHN>
	<GUNASSIGN MNEMECHN>
	<ERROR "File locked in read-only mode">>
  <SETG DHT [.MODE <NAMEP ,MNEMECHN> .PAGE-SIZE .MAP-SPACE]>>



'<SETG UV0 ![0]>
'<GDECL (UV0) <UVECTOR FIX>>


<DEFINE MNEME-READ (UVEC LOC "AUX" ANS)
   #DECL ((UVEC ANS) <OR <UVECTOR FIX> FIX FALSE WORD> (LOC) <OR FIX OWT WORD>
	  (VALUE) <OR UVECTOR FIX>)
   <SET LOC  <CHTYPE <ANDB *000077777777* .LOC> FIX>>
   <COND (<NOT <TYPE? .UVEC UVECTOR>> <SET ANS <READP ,MNEMECHN .LOC <>>>
	  <COND (.ANS <CHTYPE .ANS FIX>)(<ERROR "READP returns "  .ANS>)>)
	 (ELSE <UV-ZAP .UVEC>
	  <SET ANS <READP ,MNEMECHN .LOC .UVEC>>
	  <COND (.ANS)(<ERROR "READP returns " .ANS>)>)>>


<DEFINE TRANSFINDVAL (X Y Z) #DECL ((Y Z) OWT (VALUE X) <OR FALSE FIX OWT>)
   <COND (<SUPERFIND .X 2 .Y 1 1 3>)
	 (<MAPF <><FUNCTION (UP) #DECL ((UP) <OR OWT FIX>)
			<AND <SET X <TRANSFINDVAL .UP .Y .Z>> <MAPLEAVE .X>>>
		  <OR <SUPERFIND .X 3 .Z 1 !\A 2> ()>>)>>


<DEFINE TRANSFINDOBJ (X Y Z) #DECL ((Y Z) OWT (VALUE X) <OR FALSE FIX OWT>)
   <COND (<SUPERFIND .X 3 .Y 1 1 2>)
	 (<MAPF <><FUNCTION (UP) #DECL ((UP) <OR OWT FIX>)
			<AND <SET X <TRANSFINDOBJ .UP .Y .Z>> <MAPLEAVE .X>>>
		  <OR <SUPERFIND .X 3 .Z 1 !\A 2> ()>>)>>

<SETG   TCHKLST (() () ())>
<GDECL (TCHKLST) <LIST [3 ANY]>>

<DEFINE TRANSCHK (REL OBJ VAL) #DECL ((REL OBJ VAL) OWT (VALUE) <OR FALSE FIX OWT 'T>)
   <COND (<==? .OBJ .VAL>)
	 (<LIST-MNEME-EXIST <PUT <PUT <PUT ,TCHKLST 3 .VAL> 2 .OBJ> 1 .REL>>)
	 (<MAPF <><FUNCTION (UP) #DECL ((UP) <OR OWT FIX>)
			  <AND  <TRANSCHK .REL .OBJ .UP>
				<MAPLEAVE T>>>
		  <OR <SUPERFIND .VAL 3 .REL 1 !\A 2> ()>>)>>


<DEFINE MNEME-TO-MUDDLE (MNEME "OPTIONAL" ANS-LIST
			       "AUX" (OTYP <CHTYPE <GETBITS .MNEME <BITS 3 33>> FIX>))
   #DECL ((MNEME) OWT (OTYP) FIX
	  (VALUE ANS-LIST) <OR STRING FIX <LIST [REST <OR FIX OWT>]>>)
   <COND (<==? .OTYP 1>
	  <REPEAT ((LEN <MNEME-LENGTH .MNEME>)(ANS<COND (<ASSIGNED? ANS-LIST> .ANS-LIST)
							(<ILIST .LEN>)>))
		#DECL ((ANS VALUE) <LIST [REST <PRIMTYPE WORD>]> (LEN) FIX)
		<COND (<0? .LEN><RETURN .ANS>)>
		<PUT .ANS .LEN <MNEME-NTH .MNEME .LEN>>
		<SET LEN <- .LEN 1>>>)
	 (<==? .OTYP 0>
	  <REPEAT ((IN!-GC-OB <PARTIAL-PAGE-IN-CHK .MNEME>)
		 (CNTSAV <CHTYPE <GETBITS <NTH ,STORPLUS1 .IN!-GC-OB>
					  <BITS 6 30>> FIX>) (CNT .CNTSAV)
		 (ANS <ISTRI .CNTSAV>) (STR <REST .ANS <- <LENGTH .ANS> 5>>))
		#DECL ((IN!-GC-OB) <SPECIAL FIX> (CNTSAV CNT) FIX
			(VALUE ANS STR) <OR FIX STRING>)
		<AND <0? .CNT> <RETURN <COND (<==? <ASCII 26> <1 .ANS>>
					      <PARSE <REST .ANS>>)
					     (.ANS)>>>
		<AND <==? .CNT .CNTSAV>
		     <SET ANS <PUT-FIX-IN-STRING <NTH <REST ,STORPLUS1 .CNT> .IN!-GC-OB>
					        .ANS>>>
		<PUT-FIX-IN-STRING <NTH <REST ,STORPLUS1 .CNT> .IN!-GC-OB> .STR>
		<SET CNT <- .CNT 1>>
		<SET STR <BACK .STR 5>>>)
	 (<==? .OTYP 2>
	  <MNEME-TO-MUDDLE <MNEME-NTH .MNEME>>)
	 (<ERROR "Illegal type to MNEME-TO-MUDDLE">)>>

<SETG TEM-STR ""><SETG TEM-STR-LEN 0>

<DEFINE ISTRI (LEN "AUX" (ST ,TEM-STR)) #DECL ((LEN) FIX (ST VALUE) STRING)
  <SET LEN <* .LEN 5>>
  <COND (<G? .LEN ,TEM-STR-LEN>
	 <SET ST <SETG TEM-STR <ISTRING <SETG TEM-STR-LEN <+ .LEN 25>>  >>>)>
  <PUT-FIX-IN-STRING 0 <REST .ST <- ,TEM-STR-LEN 5>>>
  <REST .ST <- ,TEM-STR-LEN .LEN>>>

<SETG NSTR <PUT "Z*000000000000*" 1 <ASCII 26.>>>
<GDECL (NSTR) STRING>

<DEFINE MNUM-ATOM (N "OPTIONAL" (FLAG <>) "AUX" (L 33))
	#DECL ((L N) FIX (VALUE) <OR STRING ATOM> (FLAG)<OR FALSE 'T>)
	<MAPR <><FUNCTION (S) #DECL ((S) STRING)
		 <PUT .S 1 <ASCII <+ <ASCII !\0><CHTYPE <GETBITS .N<BITS 3 .L>> FIX>>>>
		 <AND <L? <SET L <- .L 3>> 0> <MAPLEAVE>>>
	      <REST ,NSTR 2>>
	<COND (.FLAG ,NSTR)
	      (<LOOKUP ,NSTR <GETPROP INITIAL OBLIST>>)
	      (<INSERT ,NSTR <GETPROP INITIAL OBLIST>>)>>

<DEFINE MNUM-EXIST (N) #DECL ((N) FIX (VALUE) <OR FALSE OWT>)
	<MNEME-EXIST <MNUM-ATOM .N 'T>>>

<DEFINE MNEME-EXIST (ATM
		    "AUX" (INTLOC <HASH-ATOM .ATM 509>)
			  (UVP <COND (<TYPE? .ATM ATOM><SPNAME .ATM>)
				     (.ATM)>)
			  (P <COND (<GASSIGNED? DHT><NTH ,IHT .INTLOC>)
				   (<ERROR "You forgot to MNEME-INIT.">)>)
			  (UVPLEN </ <+ 4 <LENGTH .UVP>> 5>))
   #DECL ((ATM) <OR ATOM STRING> (INTLOC P UVPLEN) FIX (UVP) STRING
	  (VALUE)<OR FALSE OWT>)
   <COND
    (<REPEAT () #DECL ((VALUE) <OR FALSE OWT>)
	<COND (<0? .P><RETURN <>>)
	      (<AND <STR-UV-COMP .UVP <REST ,STORPLUS1 .P>>
		    <==? .UVPLEN
			 <CHTYPE <GETBITS <NTH ,STORPLUS1 .P> <BITS 6 30>> FIX>>>
	       <RETURN <CHTYPE <NTH ,STOR .P> OWT>>)>
	<SET P <CHTYPE <GETBITS <NTH ,STORPLUS1 .P> <BITS 15 15>> FIX>> > )
    (<PROG ((HLOC <+ 8 <HASH-ATOM .ATM 2039>>) (B-LOC <MNEME-READ 1 .HLOC>)
	    (NITMS <CHTYPE <GETBITS .B-LOC <BITS 12 24>> FIX>)
	    DATA)
	   #DECL ((HLOC B-LOC NITMS) FIX (DATA) <UVECTOR [REST FIX]>
		  (VALUE) <OR FALSE OWT>)
	   <COND (<0? .NITMS><RETURN <>>)>
	   <RETURN
	    <COND (<MAPF <>		;"LOOK ON DSK FOR ITEM"
			<FUNCTION (ENTRY1) #DECL ((ENTRY1) FIX (VALUE)<OR FALSE OWT>)
				<COND (<==? <CHTYPE <GETBITS .ENTRY1 <BITS 12 24>> FIX>
					    .INTLOC>
				       <SET DATA <MNEME-READ <IUVEC <+ 1 .UVPLEN>>
							     .ENTRY1>>
				       <AND <STR-UV-COMP .UVP <REST .DATA>>
					    <MAPLEAVE <CHTYPE .ENTRY1 OWT>>>)>>
		   <MNEME-READ <IUBKT .NITMS> .B-LOC>>)
		 (ELSE <>)>>>)>
   >



<DEFINE LIST-MNEME-EXIST (LST "AUX" (HASH <SHASH .LST>)
				    (IHTLOC <+ 513 <MOD .HASH 509>>)
				    (P <COND (<GASSIGNED? DHT><NTH ,IHT .IHTLOC>)
					     (<ERROR "You forgot to MNEME-INIT.">)>))
			#DECL ((LST) LIST (P IHTLOC) FIX (VALUE)<OR OWT FIX FALSE>)
	<COND (<REPEAT () #DECL ((VALUE)<OR OWT FIX FALSE>)
		<COND (<0? .P><RETURN <>>)
		      (<COMPARE-MNEME .P .LST>
		       <RETURN <CHTYPE <NTH ,STOR .P> OWT>>)
		      (<SET P <CHTYPE<GETBITS <NTH ,STORPLUS1 .P> <BITS 15 15>>FIX>>)>>)
	      (<MAPF <><FUNCTION (OWT) #DECL ((OWT) FIX (VALUE) <OR 'T FALSE>)
			<COND (<AND <==? <CHTYPE <GETBITS .OWT <BITS 12 24>> FIX>
					 .IHTLOC>
				    <COMPARE-MNEME <PARTIAL-PAGE-IN-CHK .OWT> .LST>>
				<MAPLEAVE <CHTYPE .OWT OWT>>)>>
		     <COND (<0? <SET HASH <MNEME-READ 1 <+ 8 <MOD .HASH 2039>>>>> ![])
			   (<SET P <CHTYPE <GETBITS .HASH <BITS 12 24>> FIX>>
			    <MNEME-READ <IUBKT .P> .HASH>)>>)>>

<DEFINE COMPARE-MNEME (STOR LST) #DECL ((STOR) FIX (LST) LIST (VALUE)<OR 'T FALSE>)
	<MAPF<><FUNCTION (O L) #DECL ((O) FIX (L)<OR OWT ATOM LIST FIX STRING FALSE>
				      (VALUE) <OR 'T FALSE>)
		<OR <COND (<TYPE? .L OWT><==? <CHTYPE .L FIX> .O>)
			  (<AND <TYPE? .L ATOM STRING><SET L <MNEME-EXIST .L>>>
			   <==? <CHTYPE .L FIX> .O>)
			  (<AND <TYPE? .L LIST><SET L <LIST-MNEME-EXIST .L>>>
			   <==? <CHTYPE .L FIX> .O>)
			  (<TYPE? .L FIX>
			   <OR <==? .L <CHTYPE <PUTBITS .O <BITS 3 33>
						  <* 7 <CHTYPE <GETBITS .O <BITS 1 32>>
								FIX>>> FIX>>
			       <==? <MNUM-EXIST .L><CHTYPE .O OWT>>>)>
		     <MAPLEAVE <>> >>
	     <REST ,STORPLUS1 .STOR>
	     .LST>>

<DEFINE MNEME-EXIST? (ANY1) #DECL ((ANY1)<OR ATOM LIST STRING FIX>
				   (VALUE)<OR OWT FIX FALSE>)
	<COND (<TYPE? .ANY1 LIST><LIST-MNEME-EXIST .ANY1>)
	      (<TYPE? .ANY1 FIX><MNUM-EXIST .ANY1>)
	      (<MNEME-EXIST .ANY1>)>>

<SETG UBKT <IUVECTOR <SETG UBKTLEN 32> 0>>
<DEFINE IUBKT (LEN) #DECL ((LEN) FIX (VALUE) <UVECTOR FIX>)
  <COND (<G? .LEN ,UBKTLEN>
	 <SETG UBKT <IUVECTOR <SETG UBKTLEN <+ .LEN 32>> 0>>)>
  <REST ,UBKT <- ,UBKTLEN .LEN>>>

<GDECL (TEMP-UVEC-LEN) FIX (TEMP-UVEC) UVECTOR>

<SETG TEMP-UVEC <IUVECTOR <SETG TEMP-UVEC-LEN 10> 0>>

<DEFINE IUVEC (LEN) #DECL ((LEN) FIX (VALUE) <UVECTOR FIX>)
  <COND (<G? .LEN ,TEMP-UVEC-LEN>
	 <SETG TEMP-UVEC <IUVECTOR <SETG TEMP-UVEC-LEN <+ .LEN 32>> 0>>)>
  <REST ,TEMP-UVEC <- ,TEMP-UVEC-LEN .LEN>>>

<SETG STUVCO [<ISTRING 40 !\ ><ISTRING 36 !\ ><ISTRING 37 !\ ><ISTRING 38 !\ >
	      <ISTRING 39 !\ >]>
<MAPR <><FUNCTION (X)<PUT .X 1 <REST <1 .X> <LENGTH <1 .X>>>>> ,STUVCO>
<GDECL (STUVCO) <VECTOR [5 STRING]>>

<DEFINE STR-UV-COMP (STR UV "OPTIONAL" (FLAG <>))
   #DECL ((VALUE)<OR 'T FALSE> (STR) STRING (UV) UVECTOR (FLAG) <OR ATOM FALSE>)
   <COND(<EMPTY? .STR><>)
	(<OR <==? .STR <TOP .STR>> .FLAG>
	 <REPEAT ()
	  <COND (<EMPTY? .UV><RETURN T>)
		(<==? <STR-TO-FIX .STR> <1 .UV>>
		 <COND (<LENGTH? .STR 5><RETURN T>)>)
		(<RETURN <>>)>
	  <SET UV <REST .UV>>
	  <SET STR <REST .STR 5>>>)
	(<STR-UV-COMP <SUBSTRUC .STR 0 <LENGTH .STR>
				       <BACK <NTH ,STUVCO <+ <MOD <LENGTH .STR> 5> 1>>
					     <LENGTH .STR>>>
		      .UV T>)>>


<ENDPACKAGE>
