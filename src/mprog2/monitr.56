
<PACKAGE "MONITOR">

<ENTRY MONITOR
       KILL-MONITOR
       CLEAN-MONITORS
       NEWVAL
       OLDVAL
       KILL-ALL-MONITORS
       MONSPEC
       MONOBJ
       MONITORS>

<NEWTYPE KMODE STRING>

<NEWTYPE MONSPEC VECTOR '<<PRIMTYPE VECTOR> ANY LIST ANY ANY>>

<SETG MSTEST 1>

<SETG MSTODO 2>

<SETG MSOBJ 3>

<SETG MSTYP 4>

<MANIFEST MSTEST MSTODO MSOBJ MSTYP>

<NEWTYPE MONITOR VECTOR '<<PRIMTYPE VECTOR> LOCATIVE ATOM MONSPEC>>

<SETG MONLOC 1>

<SETG MONTYP 2>

<SETG MONSPC 3>

<OR <GASSIGNED? SPARE-MONS> <SETG SPARE-MONS ()>>

<OR <GASSIGNED? SPARE-MSPCS> <SETG SPARE-MSPCS ()>>

<OR <GASSIGNED? MONITORS> <SETG MONITORS ()>>

<GDECL (SPARE-MONS MONITORS)
       <LIST [REST MONITOR]>
       (SPARE-MSPCS)
       <LIST [REST MONSPEC]>>

<MANIFEST MONLOC MONTYP MONSPC>

<DEFINE MONPRINT (MON "AUX" (SPC <MONSPC .MON>) (OUTCHAN .OUTCHAN)) 
	#DECL ((MON) MONITOR (SPC) MONSPEC (OUTCHAN) CHANNEL)
	<PRINC "#MONITOR [">
	<PRINC <SPNAME <MONTYP .MON>>>
	<PRINC " of ">
	<COND (<LEGAL? <MONLOC .MON>> <&1 <MSOBJ .SPC>>) (<PRINC "ILLEGAL">)>
	<PRINC "]">>

<PRINTTYPE MONITOR ,MONPRINT>

<DEFINE MONITOR (MODE OBJ POS "OPTIONAL" ('TEST T) "ARGS" PO "AUX" LOC) 
	#DECL ((PO) LIST (LOC) <OR FALSE LOCATIVE> (MODE) <PRIMTYPE STRING>
	       (POS) ANY (OBJ TEST) ANY)
	<SET LOC
	     <COND (<AND <NOT <TYPE? .POS FIX>>
			 <N==? .POS LVAL>
			 <N==? .POS GVAL>>
		    <GETL .OBJ .POS>)
		   (<TYPE? .OBJ ATOM>
		    <COND (<==? .POS LVAL>
			   <COND (<ASSIGNED? .OBJ> <LLOC .OBJ>)
				 (T #FALSE ("NOT-ASSIGNED"))>)
			  (<==? .POS GVAL>
			   <COND (<GBOUND? .OBJ> <GLOC .OBJ>)
				 (T #FALSE ("NOT-GASSIGNED"))>)
			  (T #FALSE ("BAD-MONITOR-ARGS"))>)
		   (<STRUCTURED? .OBJ>
		    <COND (<TYPE? .POS FIX>
			   <COND (<G? .POS <LENGTH .OBJ>>
				  #FALSE ("OUT-OF-BOUNDS"))
				 (<AT .OBJ .POS>)>)
			  (T #FALSE ("BAD-MONITOR-ARGS"))>)
		   (T #FALSE ("CANT-BE-MONITORED"))>>
	<COND (<NOT .LOC> .LOC)
	      (<TYPE? .MODE STRING>
	       <MONITR .LOC .MODE <SPC-GET .TEST .PO .OBJ .POS>>)
	      (<IKILL-MON .LOC .MODE>)>>

<DEFINE MONITR (LOC MODE DATA "AUX" ATM MON) 
	#DECL ((LOC) LOCATIVE (MODE) STRING (DATA) MONSPEC (ATM) ATOM
	       (MON) MONITOR)
	<COND (<OR <=? .MODE "READ"> <=? .MODE "RW">>
	       <SET ATM READ!-INTERRUPTS>
	       <ON "READ" ,RMONF 4 0 .LOC>)
	      (<ON .MODE ,WMONF 4 0 .LOC> <SET ATM WRITE!-INTERRUPTS>)>
	<SETG MONITORS (<SET MON <MON-GET .LOC .ATM .DATA>> !,MONITORS)>
	<COND (<=? .MODE "RW">
	       <MONITR .LOC "WRITE" .DATA>
	       <SET MON <MON-GET .LOC RW!-INTERRUPTS .DATA>>)>
	.MON>

<DEFINE MON-GET ("TUPLE" TUP "AUX" (SM ,SPARE-MONS) MON)
	#DECL ((TUP) <TUPLE LOCATIVE ATOM MONSPEC> (SM) <LIST [REST MONITOR]>
	       (MON) MONITOR)
	<COND (<EMPTY? .SM>
	       <CHTYPE <VECTOR <1 .TUP> <2 .TUP> <3 .TUP>> MONITOR>)
	      (<SET MON <1 .SM>>
	       <SETG SPARE-MONS <REST .SM>>
	       <SUBSTRUC .TUP 0 3 <CHTYPE .MON VECTOR>>
	       .MON)>>

<DEFINE SPC-GET ("TUPLE" TUP "AUX" (SM ,SPARE-MSPCS) MON) 
	#DECL ((TUP) <TUPLE ANY LIST ANY ANY> (SM) <LIST [REST MONSPEC]>
	       (MON) MONSPEC)
	<COND (<EMPTY? .SM>
	       <CHTYPE <VECTOR <1 .TUP> <2 .TUP> <3 .TUP> <4 .TUP>> MONSPEC>)
	      (<SET MON <1 .SM>>
	       <SETG SPARE-MSPCS <REST .SM>>
	       <SUBSTRUC .TUP 0 4 <CHTYPE .MON VECTOR>>
	       .MON)>>

<DEFINE P&EVAL (LST "AUX" (OUTCHAN .OUTCHAN))
	#DECL ((LST) LIST (OUTCHAN) CHANNEL)
	<MAPF <>
	      <FUNCTION (X)
			#DECL ((X) ANY)
			<PRINT .X>
			<SET X <EVAL .X>>
			<PRINC "= ">
			<&1 .X>>
	      .LST>>

<DEFINE MMEMQ (LOC ATM TBL "AUX" (CLEAN <>) MAPVAL)
	#DECL ((LOC) LOCATIVE (ATM) ATOM (TBL) <LIST [REST MONITOR]> 
	       (CLEAN) <OR ATOM FALSE> (MAPVAL) <OR FALSE MONITOR>)
	<SET MAPVAL
	     <MAPF <>
		   <FUNCTION (X)
			     #DECL ((X) MONITOR)
			     <OR <LEGAL? <MONLOC .X>>
				 <SET CLEAN T>>
			     <COND (<AND <==? .LOC <MONLOC .X>>
					 <==? .ATM <MONTYP .X>>>
				    <MAPLEAVE .X>)>>
		   .TBL>>
 	<AND .CLEAN <CLEAN-MONITORS>>
	.MAPVAL>

<DEFINE RMONF (LOC FRM "AUX" (M <MONSPC <MMEMQ .LOC READ!-INTERRUPTS ,MONITORS>>)) 
	#DECL ((LOC) LOCATIVE (FRM) FRAME (M) MONSPEC)
	<INT-LEVEL 0>
	<COND (<AND <ASSIGNED? MONFFLG>
		    <==? .M .MONFFLG>>)
	      (<MONTEST .M> <MONF .LOC .M <> "**READ">)>>

<DEFINE WMONF (LOC NEWVAL FRM
	       "AUX" (WMONFL <MMEMQ .LOC WRITE!-INTERRUPTS ,MONITORS>)
		     (M <MONSPC .WMONFL>))
	#DECL ((LOC) LOCATIVE (FRM) FRAME (M) MONSPEC
	       (NEWVAL WMONFL) <SPECIAL ANY>)
	<INT-LEVEL 0>
	<COND (<MONTEST .M> <MONF .LOC .M T "**WRITE">)>>

<DEFINE MONF (LOC M WRT STR "AUX" (ASS <>) TYP (OBJ <MSOBJ .M>) OLDVAL (MONFFLG .M)
				  (OUTCHAN .OUTCHAN)) 
	#DECL ((M) MONSPEC (TYP OBJ) ANY (WRT ASS) <OR FALSE ATOM> (OUTCHAN) CHANNEL
	       (OLDVAL MONFFLG) <SPECIAL ANY> (LOC) LOCATIVE (STR) STRING)
	<PRINC .STR>
	<COND (<OR <==? <SET TYP <MSTYP .M>> LVAL> <==? .TYP GVAL>>
	       <PRINC " of ">
	       <PRIN1 .TYP>)
	      (<TYPE? .TYP FIX> <PRINC " of element "> <PRIN1 .TYP>)
	      (<PRINC " of assocation of ">
	       <&1 .OBJ 40>
	       <PRINC " and ">
	       <&1 .TYP 15>
	       <SET ASS T>)>
	<COND (<NOT .ASS> <PRINC " of "> <&1 .OBJ 40>)>
	<PRINC "**">
	<SET OLDVAL <IN .LOC>>
	<COND (.WRT
	       <PRINC "
Old Value: ">
	       <PRINC .OLDVAL>
	       <PRINC "
New Value: ">
	       <&1 .NEWVAL>)
	      (<PRINC "
Value: "> <&1 .OLDVAL>)>
	<P&EVAL <MSTODO .M>>
	<SET MONFFLG <>>
	<LISTEN>>

<DEFINE MONTEST (M "AUX" (MONOBJ <MSOBJ .M>) (MONFFLG .M))
	#DECL ((M) MONSPEC (MONFFLG MONOBJ) <SPECIAL ANY>)
	<EVAL <MSTEST .M>>>

<DEFINE KILL-MONITOR (MON/MODE "OPTIONAL" OBJ POS) 
	#DECL ((MON/MODE) <OR MONITOR STRING> (OBJ POS) ANY)
	<COND (<TYPE? .MON/MODE STRING>
	       <MONITOR <CHTYPE .MON/MODE KMODE> .OBJ .POS>)
	      (<KILL-MON .MON/MODE>)>>

<DEFINE IKILL-MON (LOC KMODE "AUX" (MON <>)) 
	#DECL ((LOC) LOCATIVE (KMODE) KMODE (MON) <OR FALSE MONITOR>)
	<COND (<AND <=? .KMODE #KMODE "RW">
		    <IKILL-MON .LOC #KMODE "READ">
		    <SET KMODE #KMODE "WRITE">
		    <>>)
	      (<=? .KMODE #KMODE "READ">
	       <SET MON <MMEMQ .LOC READ!-INTERRUPTS ,MONITORS>>)
	      (<=? .KMODE #KMODE "WRITE">
	       <SET MON <MMEMQ .LOC WRITE!-INTERRUPTS ,MONITORS>>)>
	<COND (.MON <KILL-MON .MON>) (T #FALSE ("NOT FOUND"))>>

<DEFINE KILL-MON (MON "AUX" (MONITORS ,MONITORS)) 
	#DECL ((MON) MONITOR (MONITORS) <LIST [REST MONITOR]>)
	<COND (<==? <MONTYP .MON> RW!-INTERRUPTS>
	       <PUT .MON ,MONTYP READ!-INTERRUPTS>
	       <KILL-MONITOR .MON>
	       <PUT .MON ,MONTYP WRITE!-INTERRUPTS>)>
	<COND (<=? <1 .MONITORS> .MON>
	       <SETG MONITORS <REST .MONITORS>>
	       <RECYCLE-MON .MON>
	       .MON)
	      (T
	       <REPEAT ((NL <REST .MONITORS>) (OL .MONITORS))
		       #DECL ((NL) LIST (OL) <LIST ANY>)
		       <COND (<=? <1 .NL> .MON>
			      <PUTREST .OL <REST .NL>>
			      <RECYCLE-MON .MON>
			      <SETG MONITORS .MONITORS>
			      <RETURN .MON>)
			     (<SET OL .NL> <SET NL <REST .NL>>)>>)>>

<DEFINE CLEAN-MONITORS ("AUX" (LL ,MONITORS) (L .LL)) 
	#DECL ((LL L) <LIST [REST MONITOR]>)
	<REPEAT (MON)
		#DECL ((MON) MONITOR)
		<COND (<EMPTY? .L> <RETURN .LL>)
		      (<NOT <LEGAL? <MONLOC <SET MON <1 .L>>>>>
		       <RECYCLE-MON .MON>
		       <SET L <SET LL <REST .L>>>
		       <AGAIN>)
		      (<RETURN>)>>
	<REPEAT (MON)
		#DECL ((MON) MONITOR)
		<COND (<LENGTH? .L 1> <RETURN <SETG MONITORS .LL>>)
		      (<NOT <LEGAL? <MONLOC <SET MON <2 .L>>>>>
		       <RECYCLE-MON .MON>
		       <PUTREST .L <REST .L 2>>
		       <AGAIN>)
		      (ELSE <SET L <REST .L>>)>>>

<DEFINE RECYCLE-MON (MON)
	#DECL ((MON) MONITOR)
	<PUTPROP <MONLOC .MON> <MONTYP .MON>>
	<SETG SPARE-MONS (.MON !,SPARE-MONS)>
	<SETG SPARE-MSPCS (<MONSPC .MON> !,SPARE-MSPCS)>
	T>

<DEFINE KILL-ALL-MONITORS ()
	<MAPF <> ,KILL-MONITOR ,MONITORS>>

<DEFINE MONOBJ (MON)
	#DECL ((MON) MONITOR)
	<MSOBJ <MONSPC .MON>>>

<DEFINE MONSPEC (MON)
	#DECL ((MON) MONITOR)
	<MSTYP <MONSPC .MON>>>

<ENDPACKAGE>
