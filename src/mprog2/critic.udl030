
<PACKAGE "CRITIC">

<ENTRY CRITIC CRITIC-NOTES>

<AND? <OR <LOOKUP "NO-DECL" <ROOT>> <INSERT "NO-DECL" <ROOT>>>
      <OR <LOOKUP "NO-VALUE" <ROOT>> <INSERT "NO-VALUE" <ROOT>>>>

<NEWTYPE FAMILY
	 VECTOR
	 '<VECTOR <LIST [REST ATOM LIST LIST VECTOR]>
		  [3 <LIST [REST <PRIMTYPE ATOM>]>]
		  <LIST [REST OBLIST]>
		  <LIST [REST ATOM]>
		  [2 <LIST [REST <OR STRING FALSE>]>]
		  ATOM
		  STRING
		  <VECTOR [4 DECL] [2 LIST] [2 DECL] LIST>
		  LIST>>

<AND? <SETG TREE 1>
      <SETG TOP-FCNS 2>
      <SETG TOP-GLOBALS 3>
      <SETG TOP-LOCALS 4>
      <SETG OBJECT-OBLISTS 5>
      <SETG ENTRIES 6>
      <SETG USED-PACK 7>
      <SETG USED-DATUM 8>
      <SETG OBJECT-NAME 9>
      <SETG OBJECT-TYPE 10>
      <SETG GABST 11>
      <SETG NEWTYPES 12>>

<MANIFEST TREE
	  TOP-FCNS
	  TOP-GLOBALS
	  TOP-LOCALS
	  OBJECT-OBLISTS
	  ENTRIES
	  USED-PACK
	  USED-DATUM
	  OBJECT-NAME
	  OBJECT-TYPE
	  GABST
	  NEWTYPES>

<AND? <SETG GSET 1>
      <SETG GUSED 2>
      <SETG LSET 3>
      <SETG LUSED 4>
      <SETG EXTF 5>
      <SETG NARGS 6>
      <SETG SPEC 7>
      <SETG RDECL 8>
      <SETG NOTES 9>
      <SETG DATUMS 10>
      <SETG GOFFSET 11>
      <SETG ATOML 12>>

<MANIFEST GSET
	  GUSED
	  LSET
	  LUSED
	  EXTF
	  NARGS
	  SPEC
	  RDECL
	  NOTES
	  DATUMS
	  GOFFSET
	  ATOML>

<AND? <SETG RGSET 0>
      <SETG RGUSED 1>
      <SETG RLSET 2>
      <SETG RLUSED 3>
      <SETG REXTF 4>
      <SETG RSPEC 6>
      <SETG RDATUMS 9>>

<MANIFEST RGSET
	  RGUSED
	  RLSET
	  RLUSED
	  REXTF
	  RSPEC
	  RDATUMS>

<AND? <SETG NAME 1>
      <SETG FATHERS 2>
      <SETG SONS 3>
      <SETG ABST 4>
      <SETG NODE-SIZE 4>>

<MANIFEST NAME FATHERS SONS ABST NODE-SIZE>

<NEWTYPE FATHER VECTOR '<VECTOR [2 ATOM] DECL [2 LIST]>>

<AND? <SETG CTYPE 2> <SETG FDLST 3> <SETG FPLST 4> <SETG FSPEC 5>>

<MANIFEST CTYPE FDLST FPLST FSPEC>

\ 

<SETG KNOWN-ATOMS '![INCHAN OUTCHAN OBLIST!]>

<SETG KNOWN-DECLS
      #DECL ((INCHAN) <SPECIAL CHANNEL> (OUTCHAN) <SPECIAL CHANNEL>
	     (OBLIST) <SPECIAL <OR OBLIST [LIST <REST OBLIST>]>>)>

<SETG DECLS-SEEN ()>

<SETG QUOTING-SUBRS
      [,IUVECTOR
       2
       ,ISTRING
       2
       ,ILIST
       2
       ,IFORM
       2
       ,IVECTOR
       2
       ,ITUPLE
       2
       ,IBYTES
       3
       ,ISTORAGE
       2
       ,READ
       2
       ,READCHR
       2
       ,NEXTCHR
       2
       ,GC-READ
       2
       ,GET
       3
       ,GETPROP
       3
       ,GETPL
       3
       ,READB
       3
       ,READSTRING
       4]>

<AND? <SETG EVAL-OR-APPLY
	    '![LIST FORM SEGMENT FUNCTION MACRO CLOSURE VECTOR UVECTOR!]>
      <SETG APPLICABLE-TYPES '![SUBR FSUBR FUNCTION MACRO RSUBR RSUBR-ENTRY!]>
      <SETG USER-APPLICABLE-TYPES <REST ,APPLICABLE-TYPES 2>>
      <SETG INT-SUBRS
	    [,SET ,SETG ,DEFINE ,DEFMAC ,LVAL ,LLOC ,GVAL ,GLOC ,VALUE]>
      <SETG CONTROL-STRUCTURES [,DEFINE ,DEFMAC ,PROG ,REPEAT ,BIND ,FUNCTION]>
      <SETG FUNNY-FSUBRS ![,COND ,QUOTE!]>
      <SETG PRINTING-SUBRS ![,PRINT ,PRINC ,PRIN1 ,TERPRI ,CRLF!]>
      <SETG OPEN-SUBRS ![,OPEN ,OPEN-NR ,FLOAD ,SAVE ,RESTORE ,CHANNEL]>
      <SETG LVAL-LLOC ![,LVAL ,LLOC!]>
      <SETG GVAL-GLOC ![,GVAL ,GLOC!]>
      <SETG SETG-DEFINE [,SETG ,DEFINE ,DEFMAC]>
      <SETG APPLY-MAPF-MAPR [,APPLY ,MAPF ,MAPR ,STACKFORM]>
      <SETG MAPF-MAPR ![,MAPF ,MAPR!]>
      <SETG DEFINE-DEFMAC [,DEFINE ,DEFMAC]>
      <SETG PACKAGE-RPACKAGE [,PACKAGE ,RPACKAGE]>
      <SETG BLOCK-ENDBLOCK [,BLOCK ,ENDBLOCK]>
      <SETG USE-USE-DEFER [,USE ,USE-DEFER]>>

<GDECL (KNOWN-ATOMS
	EVAL-OR-APPLY
	APPLICABLE-TYPES
	USER-APPLICABLE-TYPES)
       <UVECTOR [REST ATOM]>
       (KNOWN-DECLS)
       DECL
       (DECLS-SEEN)
       LIST
       (QUOTING-SUBRS)
       <VECTOR [REST SUBR FIX]>
       (INT-SUBRS)
       <VECTOR [REST APPLICABLE]>
       (CONTROL-STRUCTURES SETG-DEFINE APPLY-MAPF-MAPR)
       <VECTOR [REST <OR SUBR FSUBR>]>
       (FUNNY-FSUBRS)
       <UVECTOR [REST FSUBR]>
       (PRINTING-SUBRS OPEN-SUBRS LVAL-LLOC GVAL-GLOC MAPF-MAPR)
       <UVECTOR [REST SUBR]>
       (DEFINE-DEFMAC PACKAGE-RPACKAGE BLOCK-ENDBLOCK USE-USE-DEFER)
       <VECTOR [REST APPLICABLE]>>

\ 

<DEFINE CRITIC (GRPNAME
		"OPTIONAL" (C .OUTCHAN) (NOTES? <>)
		"AUX" (OUTCHAN .OUTCHAN) GRP CH)
	#DECL ((GRPNAME) ATOM (GRP) ANY (NOTES?) ANY
	       (C) <OR CHANNEL STRING> (CH) <OR CHANNEL FALSE>
	       (OUTCHAN) <SPECIAL CHANNEL>)
	<PROG ()
	      <COND (<TYPE? .C CHANNEL> <SET OUTCHAN .C>)
		    (ELSE
		     <COND (<EMPTY? .C> <SET C <SPNAME .GRPNAME>>)>
		     <COND (<SET CH
				 <PROG ((NM2 "CRITIC"))
				       #DECL ((NM2) <SPECIAL STRING>)
				       <OPEN "PRINT" .C>>>
			    <SET OUTCHAN .CH>)
			   (ELSE <RETURN .CH>)>)>
	      <COND (<AND <ASSIGNED? .GRPNAME> <TYPE? <SET GRP ..GRPNAME> LIST>>
		     <SETG DECLS-SEEN ()>
		     <PROG ((F <GROUP-DATA <BUILD-FAMILY .GRP>>) (T <TREE .F>)
			    (NM? Group) (OFFS 0) (OBLIST <OBJECT-OBLISTS .F>) FIL
			    (TENEX? <G? ,MUDDLE 100>))
			   #DECL ((F) FAMILY
				  (T) <LIST [REST ATOM LIST LIST VECTOR]>
				  (OBLIST) <SPECIAL <LIST [REST OBLIST]>>
				  (OFFS) <SPECIAL FIX>
				  (NM?) <SPECIAL <OR ATOM FALSE>>
				  (FIL) <OR FALSE <LIST [4 STRING]>>
				  (TENEX?) <OR ATOM FALSE>)
			   <CRLF>
			   <PRINC "====== CRITIC's Review of Group: ">
			   <PRINC .GRPNAME>
			   <COND (<SET FIL <GET .GRPNAME CHANNEL>>
				  <PRINC " from file \"">
				  <PRINC <3 .FIL>>
				  <PRINC !\:>
				  <COND (.TENEX? <PRINC !\<>)>
				  <PRINC <4 .FIL>>
				  <PRINC <COND (.TENEX? !\>)
					       (!\;)>>
				  <PRINC <1 .FIL>>
				  <PRINC <COND (.TENEX? !\.)
					       (!\ )>>
				  <PRINC <2 .FIL>>
				  <PRINC !\">)>
			   <PRINC " ======">
			   <CRLF>
			   <PRINT-GROUP-UNUSED .F>
			   <PRINT-NOTES () <GABST .F>>
			   <REPEAT ()
				   <COND (<EMPTY? .T>
					  <TERPRI>
					  <AND <TYPE? .C STRING> <CLOSE .CH>>
					  <RETURN "DONE">)>
				   <PRINT-SHORT .T .NOTES?>
				   <SET T <REST .T ,NODE-SIZE>>>>)
		    (ELSE
		     <AND <TYPE? .C STRING> <CLOSE .CH>>
		     #FALSE ("NOT A GROUP"))>>>

<DEFINE CRITIC-NOTES (GRPNAME "OPTIONAL" (C .OUTCHAN)) 
	#DECL ((GRPNAME) ATOM (C) <OR STRING CHANNEL>)
	<CRITIC .GRPNAME .C T>>

\ 

<DEFINE PRINT-SHORT (TR NOTES?
		     "AUX" (NM <NAME .TR>) (FTH <FATHERS .TR>) (SON <SONS .TR>)
			   (AB <ABST .TR>) (NM? .NM) (OFFS <GOFFSET .AB>)) 
	#DECL ((NM) ATOM (TR FTH SON) LIST (AB) VECTOR (NM?) <SPECIAL ANY>
	       (OFFS) <SPECIAL FIX> (NOTES?) <OR ATOM FALSE>)
	<COND (<NOT .NOTES?>
	       <MAPF <>
		     ,PRINT-FIELD
		     '["Called-by"
		       "Calls"
		       "SETG"
		       "GVAL"
		       "SET"
		       "LVAL"
		       "SPECIAL"
		       "USE"
		       "USE-DATUM"]
		     [<FATHER-LIST .FTH>
		      <EXTF .AB>
		      <GSET .AB>
		      <GUSED .AB>
		      <LSET .AB>
		      <LUSED .AB>
		      <SPEC .AB>
		      ()
		      <DATUMS .AB>]>)>
	<OR .NM? <TERPRI>>
	<PRINT-NOTES .SON .AB>>

<DEFINE PRINT-FIELD (FN FB) 
	#DECL ((FN) STRING (FB) <PRIMTYPE LIST> (OFFS) <SPECIAL FIX>)
	<COND (<NOT <EMPTY? .FB>>
	       <PRINT-NAME>
	       <TERPRI>
	       <PRINC "  ">
	       <PRINC .FN>
	       <PRINC ":  ">
	       <COND (<TYPE? .FB LIST> <PRINT-LIST .FB>)
		     (<TYPE? .FB DECL> <PRINT-DECL .FB>)
		     (ELSE <CPRIN1 .FB 4>)>)>>

<DEFINE PRINT-NOTES (SON AB "AUX" (N <NOTES .AB>)) 
	#DECL ((NM?) <OR FALSE ATOM STRING> (SON) <LIST [REST FATHER]>
	       (AB) VECTOR (N) LIST (OFFS) FIX)
	<OR <0? .OFFS> <PRINT-UNUSED .SON <ATOML .AB>>>
	<COND (<NOT <EMPTY? .N>>
	       <PRINT-NAME>
	       <REPEAT (N1)
		       #DECL ((N1) ANY)
		       <COND (<EMPTY? .N> <RETURN>)>
		       <TERPRI>
		       <PRINC "  ">
		       <COND (<TYPE? <SET N1 <1 .N>> LIST>
			      <REPEAT ()
				      <COND (<EMPTY? .N1> <RETURN>)
					    (<TYPE? <1 .N1> STRING>
					     <PRINC <1 .N1>>
					     <SET N1 <REST .N1>>)
					    (<PRINC ":  "> <RETURN>)>>
			      <COND (<TYPE? <1 .N1> LIST> <PRINT-LIST <1 .N1>>)
				    (ELSE <CPRIN1 <1 .N1> 4>)>)
			     (<TYPE? .N1 VECTOR>
			      <PRINC <1 .N1>>
			      <PRINC ":  ">
			      <MAPF <>
				    <FUNCTION (X) <CPRIN1 .X 4> <PRINC !\ >>
				    <REST .N1>>)
			     (<TYPE? .N1 STRING> <PRINC .N1>)
			     (ELSE <CPRIN1 .N1 4>)>
		       <SET N <REST .N>>>)>
	<OR .NM? <CRLF>>>

\ 

<DEFINE PRINT-GROUP-UNUSED (FAM "AUX" (FL <TOP-FCNS .FAM>) (GL <TOP-GLOBALS .FAM>)
			    (UP <USED-PACK .FAM>) (PL ())
			    (UNF ()) (UNG ()) (UNM ()) (E <ENTRIES .FAM>))
   #DECL ((FAM) FAMILY (FL GL UNF UNG UNM E) <LIST [REST <PRIMTYPE ATOM>]>
	  (UP) <LIST [REST <OR STRING FALSE>]> (PL) <LIST [REST STRING]>)
   <MAPF <>
	 <FUNCTION (P)
	    #DECL ((P) <OR STRING FALSE>)
	    <COND (.P <SET PL (.P !.PL)>)>>
	 .UP>
   <COND (<NOT <EMPTY? .PL>> <PRINT-NAME> <CRLF> <PRINC "  ">
	  <PRINC "Packages USEd but not referenced: ">
	  <PRINT-LIST .PL>)>
   <MAPF <>
	 <FUNCTION (F)
	    #DECL ((F) <PRIMTYPE ATOM>)
	    <COND (<AND <TYPE? .F ATOM> <NOT <MEMQ .F .E>>>
		   <SET UNF (.F !.UNF)>)>>
	 .FL>
   <UNPRINT .UNF "Internal Functions never called" DEFINE>
   <MAPF <>
	 <FUNCTION (G)
	    #DECL ((G) <PRIMTYPE ATOM>)
	    <COND (<AND <TYPE? .G ATOM> <NOT <MEMQ .G .E>>>
		   <COND (<AND <GBOUND? .G> <MANIFEST? .G>>
			  <SET UNM (.G !.UNM)>)
			 (ELSE <SET UNG (.G !.UNG)>)>)>>
	 .GL>
   <UNPRINT .UNG "Internal Globals never used" DEFINE>
   <UNPRINT .UNM "Internal Manifests never used" DEFINE>>

<DEFINE PRINT-UNUSED (SON ARGL) 
   #DECL ((SON) <LIST [REST FATHER]> (ARGL) <LIST [REST ATOM]>)
   <MAPF <>
    <FUNCTION (DAD
	       "AUX" (PL <1 <FPLST .DAD>>)
		     (SL <1 <FSPEC .DAD>>) (TY <CTYPE .DAD>) (UNARG ())
		     (UNPAR ()) (UNSPC ()) (NONSPC ()))
	    #DECL ((PL SL) <LIST [REST <PRIMTYPE ATOM>]> (DAD) FATHER
		   (UNARG UNPAR UNSPC NONSPC ARGL) <LIST [REST ATOM]>
		   (TY) ANY)
	    <PROG ()
		  <COND (<==? .TY ARGS> <RETURN>)>
		  <MAPF <>
		   <FUNCTION (P "AUX" S K) 
			   #DECL ((P) <PRIMTYPE ATOM>
				  (S) <OR <PRIMTYPE ATOM> FALSE>)
			   <SET S <PARATOM? <CHTYPE .P ATOM> .SL>>
			   <SET K <MEMQ <CHTYPE .P ATOM> ,KNOWN-ATOMS>>
			   <COND (<TYPE? .P ATOM>
				  <COND (.K
					 <COND (<NOT .S>
						<PRINT-NAME>
						<TERPRI>
						<PRINC "  ">
						<PRINC <SPNAME .P>>
					 <PRINC 
" is unused or should be SPECIAL.">)>)
					(<TYPE? .S DISMISS>)
					(<TYPE? .S ATOM>
					 <SET UNSPC (.P !.UNSPC)>)
					(<MEMQ .P .ARGL>
					 <SET UNARG (.P !.UNARG)>)
					(ELSE <SET UNPAR (.P !.UNPAR)>)>)
				 (<AND <TYPE? .P DISMISS>
				       <TYPE? .S ATOM>
				       <NOT .K>>
				  <SET NONSPC (<CHTYPE .P ATOM> !.NONSPC)>)>>
		   .PL>>
	    <UNPRINT .UNARG "Arguments unused" .TY>
	    <UNPRINT .UNPAR "Unused" .TY>
	    <UNPRINT .UNSPC "Unused SPECIALs" .TY>
	    <UNPRINT .NONSPC "SPECIALs never used as SPECIALs" .TY>>
    .SON>>

<DEFINE UNPRINT (L HEAD TYP) 
	#DECL ((L) <LIST [REST ATOM]> (HEAD) STRING (TYP) ATOM)
	<COND (<NOT <EMPTY? .L>>
	       <PRINT-NAME>
	       <CRLF>
	       <PRINC "  ">
	       <PRINC .HEAD>
	       <COND (<==? .TYP DEFINE>)
		     (ELSE <PRINC " in "> <PRINC <SPNAME .TYP>>)>
	       <PRINC ": ">
	       <PRINT-LIST .L>)>>

<DEFINE PRINT-NAME ()
	#DECL ((NM?) <OR FALSE ATOM> (OFFS) FIX)
	<COND (.NM?
	       <TERPRI>
	       <PRINC .NM?>
	       <COND (<NOT <0? .OFFS>>
		      <PRINC "   (">
		      <PRINC .OFFS>
		      <PRINC ")">)>
	       <TERPRI>
	       <SET NM? <>>)>>
\ 

<DEFINE PRINT-LIST (L) 
	#DECL ((L) LIST)
	<MAPR <>
	      <FUNCTION (R) 
		      #DECL ((R) LIST)
		      <COND (<EMPTY? <REST .R>> <CPRIN1 <1 .R> 4> <PRINC ".">)
			    (ELSE <CPRIN1 <1 .R> 4> <PRINC ", ">)>>
	      .L>>

<DEFINE PRINT-DECL (R) 
	#DECL ((R) <<PRIMTYPE LIST> [REST <LIST ATOM> ANY]>)
	<REPEAT ()
		<COND (<EMPTY? <REST .R 2>>
		       <CPRIN1 <1 <1 .R>> 4>
		       <PRINC ".">
		       <RETURN>)
		      (ELSE <CPRIN1 <1 <1 .R>> 4> <PRINC ", ">)>
		<SET R <REST .R 2>>>>

<DEFINE CPRIN1 (O N) 
	#DECL ((O) ANY (N) FIX)
	<COND (<NOT <FLATSIZE .O <- <13 .OUTCHAN> <14 .OUTCHAN> 2>>>
	       <TERPRI>
	       <INDENT-TO .N>)>
	<PRIN1 .O>>

<DEFINE FATHER-LIST (F) 
	#DECL ((F) <LIST [REST <VECTOR ATOM LIST DECL>]>
	       (VALUE) <LIST [REST ATOM]>)
	<REPEAT ((L ()) DAD)
		#DECL ((L) <LIST [REST ATOM]> (DAD) ATOM)
		<COND (<EMPTY? .F> <RETURN .L>)
		      (<NOT <MEMQ <SET DAD <1 <1 .F>>> .L>> <SET L (.DAD !.L)>)>
		<SET F <REST .F>>>>

\ 

;"START OF OLD ADATA PACKAGE"

<DEFINE GROUP-DATA (FAMILY) 
	#DECL ((FAMILY) <SPECIAL FAMILY>)
	<REPEAT ((F <TREE .FAMILY>))
		#DECL ((F) <LIST [REST ATOM LIST LIST VECTOR]>)
		<COND (<EMPTY? .F> <RETURN>)>
		<PASS-ONE .F>
		<SET F <REST .F ,NODE-SIZE>>>
	<REPEAT ((F <TREE .FAMILY>))
		#DECL ((F) <LIST [REST ATOM LIST LIST VECTOR]>)
		<COND (<EMPTY? .F> <RETURN>)>
		<PASS-TWO .F>
		<SET F <REST .F ,NODE-SIZE>>>
	.FAMILY>

\ 

<DEFINE BUILD-FAMILY (GRP
		      "AUX" (TREE ()) (STUMP .TREE) (TOP-FCNS ())
			    (TOP-GLOBALS ()) (TOP-LOCALS ())
			    (OBJECT-OBLISTS (<GET INITIAL OBLIST> <ROOT>))
			    (ENTRIES ()) (USED-PACK ()) (USED-DATUM ())
			    (OBJECT-NAME T) (OBJECT-TYPE "FILE")
			    (GABST
			     [#DECL ()
			      #DECL ()
			      #DECL ()
			      #DECL ()
			      ()
			      ()
			      #DECL ()
			      #DECL ()
			      ()
			      ()
			      0
			      ()]) (NEWTYPES ()) (NOTES ()))
   #DECL ((VALUE) FAMILY (GRP) LIST
	  (TREE) <SPECIAL <LIST [REST ATOM LIST LIST VECTOR]>>
	  (STUMP) <SPECIAL LIST>
	  (TOP-FCNS TOP-GLOBALS TOP-LOCALS ENTRIES) <SPECIAL <LIST [REST
								    ATOM]>>
	  
	  (USED-PACK USED-DATUM) <SPECIAL <LIST [REST STRING]>>
	  (OBJECT-OBLISTS) <SPECIAL <LIST [REST OBLIST]>>
	  (OBJECT-NAME) <SPECIAL ATOM> (OBJECT-TYPE) <SPECIAL STRING>
	  (GABST) <VECTOR [10 <PRIMTYPE LIST>]>
	  (NEWTYPES) <SPECIAL <LIST [REST STRING]>> (NOTES) <SPECIAL LIST>)
   <TOP-WALK .GRP>
   <REPEAT ((E .ENTRIES) A (N ()) (ALL <ALLTYPES>))
	   #DECL ((E N) <LIST [REST ATOM]> (A) ATOM)
	   <COND (<EMPTY? .E>
		  <COND (<NOT <EMPTY? .N>>
			 <SET NOTES
			      (("ENTRYs not bound, assumed locals" .N)
			       !.NOTES)>)>
		  <PUT .GABST ,NOTES .NOTES>
		  <RETURN>)
		 (<OR <PARATOM? <SET A <1 .E>> .TOP-LOCALS>
		      <PARATOM? .A .TOP-GLOBALS>
		      <PARATOM? .A .TOP-FCNS>>)
		 (<GASSIGNED? .A>
		  <COND (<MEMQ ,.A ,USER-APPLICABLE-TYPES>
			 <SET TOP-FCNS (.A !.TOP-FCNS)>)
			(ELSE <SET TOP-GLOBALS (.A !.TOP-GLOBALS)>)>)
		 (<AND <GBOUND? .A> <GET-DECL <GLOC .A>>>
		  <SET TOP-GLOBALS (.A !.TOP-GLOBALS)>)
		 (<ASSIGNED? .A> <SET TOP-LOCALS (.A !.TOP-LOCALS)>)
		 (<MEMQ .A .ALL>)
		 (ELSE <SET TOP-LOCALS (.A !.TOP-LOCALS)> <SET N (.A !.N)>)>
	   <SET E <REST .E>>>
   <CHTYPE [.TREE
	    .TOP-FCNS
	    .TOP-GLOBALS
	    .TOP-LOCALS
	    .OBJECT-OBLISTS
	    .ENTRIES
	    .USED-PACK
	    .USED-DATUM
	    .OBJECT-NAME
	    .OBJECT-TYPE
	    .GABST
	    .NEWTYPES]
	   FAMILY>>

\ 

<DEFINE TOP-WALK (G "AUX" (GOFF 0)) 
   #DECL ((G) <PRIMTYPE LIST> (TREE STUMP) <SPECIAL LIST> (GOFF) FIX)
   <MAPF <>
    <FUNCTION (XX "AUX" X X1 BARK) 
       #DECL ((XX X1) ANY (X) FORM (BARK) <LIST ATOM LIST LIST VECTOR>)
       <SET GOFF <+ .GOFF 1>>
       <COND
	(<AND <TYPE? .XX FORM> <NOT <MONAD? .XX>> <SET X1 <LGVAL <1 .XX>>>>
	 <SET X .XX>
	 <COND
	  (<G=? <LENGTH .X> 1>
	   <COND (<MEMQ .X1 ,PACKAGE-RPACKAGE>
		  <SET OBJECT-TYPE "PACKAGE">
		  <COND (<SET OBJECT-NAME <LOOKUP <2 .X> <GET PACKAGE OBLIST>>>
			 <SET OBJECT-OBLISTS ,.OBJECT-NAME>)>)
		 (<MEMQ .X1 ,USE-USE-DEFER>
		  <SET USED-PACK (!<REST .X> !.USED-PACK)>)
		 (<==? .X1 ,USE-DATUM>
		  <SET USED-DATUM (!<REST .X> !.USED-DATUM)>)
		 (<==? .X1 ,ENTRY> <SET ENTRIES (!<REST .X> !.ENTRIES)>)
		 (<==? .X1 ,NEWTYPE>
		  <COND (<AND <LENGTH? .X 3>
			      <TYPE? <2 .X> ATOM>
			      <MEMQ <2 .X> <ALLTYPES>>
			      <MEMQ <TYPEPRIM <2 .X>>
				    '![LIST VECTOR UVECTOR TUPLE!]>>
			 <SET NOTES (("NEWTYPE not DECLed" <2 .X>) !.NOTES)>)>
		  <SET NEWTYPES (<UNPARSE .X> !.NEWTYPES)>)
		 (<==? .X1 ,FLOAD> <SET NOTES (("FLOAD in file" .X) !.NOTES)>)
		 (<AND <MEMQ .X1 ,BLOCK-ENDBLOCK> <=? .OBJECT-TYPE "PACKAGE">>
		  <SET NOTES
		       (("BLOCK or ENDBLOCK at top level in PACKAGE." .X)
			!.NOTES)>)>)>
	 <COND (<G=? <LENGTH .X> 3>
		<COND (<OR <==? .X1 ,DEFINE>
			   <AND <==? .X1 ,SETG>
				<MEMQ <TYPE <3 .X>> ,USER-APPLICABLE-TYPES>>>
		       <SET BARK
			    (<GET <2 .X> VALUE '<2 .X>>
			     ()
			     ()
			     [#DECL ()
			      #DECL ()
			      #DECL ()
			      #DECL ()
			      ()
			      ()
			      #DECL ()
			      #DECL ()
			      ()
			      ()
			      .GOFF
			      ()])>
		       <COND (<EMPTY? .TREE> <SET TREE <SET STUMP .BARK>>)
			     (ELSE <PUTREST .STUMP <SET STUMP .BARK>>)>
		       <PASS-ZERO .STUMP>
		       <SET STUMP <REST .STUMP 3>>
		       <SET TOP-FCNS (<GET <2 .X> VALUE '<2 .X>> !.TOP-FCNS)>)
		      (<==? .X1 ,SET>
		       <SET TOP-LOCALS
			    (<GET <2 .X> VALUE '<2 .X>> !.TOP-LOCALS)>)
		      (<==? .X1 ,SETG>
		       <SET TOP-GLOBALS
			    (<GET <2 .X> VALUE '<2 .X>> !.TOP-GLOBALS)>)>)>
	 <COND (<AND <N==? .X1 ,QUOTE> <NOT <MEMQ .X1 ,DEFINE-DEFMAC>>>
		<TOP-WALK .X>)>)>>
    .G>>

\ 

<DEFINE PASS-ZERO (FTREE "AUX" (FATHER-NAME <NAME .FTREE>) (ABST <ABST .FTREE>)
		   (FNC ,.FATHER-NAME)) 
	#DECL ((FTREE) <LIST [REST ATOM LIST LIST VECTOR]> (FATHER-NAME) ATOM
	       (ABST) <SPECIAL VECTOR>)
	<RSUBR-DECL .FNC>>

<DEFINE PASS-ONE (FTREE "AUX" (FATHER-NAME <NAME .FTREE>) (ABST <ABST .FTREE>)
		  (FNC ,.FATHER-NAME) DCL PAR DAD) 
	#DECL ((FTREE) <SPECIAL <LIST [REST ATOM LIST LIST VECTOR]>>
	       (FATHER-NAME) <SPECIAL ATOM> (DCL) DECL (PAR) <LIST [2 LIST]>
	       (DAD) FATHER (FNC) <OR FUNCTION MACRO RSUBR RSUBR-ENTRY>
	       (ABST) <SPECIAL <VECTOR [4 DECL] [2 LIST] [2 DECL] [2 LIST]>>)
	<COND (<TYPE? .FNC MACRO> <SET FNC <1 .FNC>>)>
	<COND (<TYPE? .FNC FUNCTION>
	       <SET PAR <PARAMS .FNC () <SET DCL <DECLS .FNC>> ()>>
	       <SET DAD <FATHER DEFINE .DCL (<1 .PAR>) (<2 .PAR>)>>
	       <WALK <COND (<TYPE? <1 .FNC> ATOM> <REST .FNC 2>)
			   (ELSE <REST .FNC 1>)>
		     .DAD
		     T>)>
	<PUT .FTREE ,ABST .ABST>>

<DEFINE PASS-TWO (FTREE
		  "AUX" (FATHER-NAME <NAME .FTREE>) (FATHERS <FATHERS .FTREE>)
			(ABST <ABST .FTREE>) (GA <GABST .FAMILY>))
	#DECL ((FTREE) <LIST [REST ATOM LIST LIST VECTOR]>
	       (FATHER-NAME) <SPECIAL ATOM> (FATHERS) LIST
	       (GA) <VECTOR [4 DECL] [2 LIST] [2 DECL] [2 LIST]>
	       (ABST) <SPECIAL <VECTOR [4 DECL] [2 LIST] [2 DECL] [2 LIST]>>
	       (FAMILY) FAMILY)
	<COND (<TYPE? <LGVAL .FATHER-NAME> FUNCTION MACRO>
	       <EXT-LOCALS <REST .GA ,RLSET>
			   <LSET .ABST>
			   .FATHERS
			   "External locals set">
	       <EXT-LOCALS <REST .GA ,RLUSED>
			   <LUSED .ABST>
			   .FATHERS
			   "External locals used">
	       <EXT-GLOBALS <REST .GA ,RGSET> <GSET .ABST>>
	       <EXT-GLOBALS <REST .GA ,RGUSED> <GUSED .ABST>>)>>

<DEFINE LGVAL (X "AUX" XA) 
	#DECL ((X VALUE) ANY (XA) ATOM)
	<COND (<NOT <TYPE? .X ATOM>> <>)
	      (<GASSIGNED? <SET XA .X>> ,.XA)
	      (<ASSIGNED? .XA> ..XA)>>

<DEFINE LGTYP (X "AUX" XA) 
	#DECL ((X VALUE) ANY (XA) ATOM)
	<COND (<NOT <TYPE? .X ATOM>> <>)
	      (<GASSIGNED? <SET XA .X>> <TYPE ,.XA>)
	      (<ASSIGNED? .XA> <TYPE ..XA>)>>

\ 

<DEFINE PARAMS (FUNC PLIST DLIST SLIST "AUX" PL (DL #DECL ()) DAD) 
	#DECL ((FUNC) <PRIMTYPE LIST> (PLIST SLIST) <LIST [REST LIST]> (PL) LIST
	       (DAD) FATHER (DLIST DL) DECL (VALUE) <LIST [2 LIST]>)
	<COND (<TYPE? .FUNC MACRO> <SET FUNC <1 .FUNC>>)>
	<PROG ((PP ()) (PS ()) (FF <LGVAL <1 .FUNC>>))
	      #DECL ((PP PS) <SPECIAL <LIST [REST <PRIMTYPE ATOM>]>> (FF) ANY)
	      <SET FUNC
		   <COND (<TYPE? .FUNC FUNCTION> .FUNC)
			 (<NOT <TYPE? .FUNC FORM>> <RETURN ()>)
			 (<OR <==? .FF ,DEFMAC> <==? .FF ,DEFINE>>
			  <REST .FUNC 2>)
			 (<MEMQ .FF <REST ,CONTROL-STRUCTURES>> <REST .FUNC 1>)
			 (ELSE <RETURN ()>)>>
	      <COND (<EMPTY? .FUNC>)
		    (<TYPE? <1 .FUNC> ATOM>
		     <COND (<TYPE? <3 .FUNC> DECL> <SET DL <3 .FUNC>>)>
		     <ADDPARAM <1 .FUNC> .DL>
		     <SET FUNC <REST .FUNC>>)
		    (ELSE <COND (<TYPE? <2 .FUNC> DECL> <SET DL <2 .FUNC>>)>)>
	      <COND (<EMPTY? .FUNC>)
		    (<TYPE? <1 .FUNC> LIST> <SET PL <1 .FUNC>>)
		    (ELSE <SET PL ()>)>
	      <REPEAT (P)
		      #DECL ((P) ANY)
		      <COND (<EMPTY? .PL> <RETURN (.PP .PS)>)
			    (T <SET P <1 .PL>>)>
		      <COND (<TYPE? .P STRING>)
			    (<TYPE? .P ATOM> <ADDPARAM .P .DL>)
			    (<AND <TYPE? .P LIST>
				  <OR <TYPE? <1 .P> ATOM>
				      <AND <TYPE? <1 .P> FORM>
					   <==? <1 <1 .P>> QUOTE>>>>
			     <COND (<AND <STRUCTURED? <2 .P>>
					 <NOT <EMPTY? <2 .P>>>>
				    <SET DAD
					 <FATHER ARGS
						 .DLIST
						 (.PP !.PLIST)
						 (.PS !.SLIST)>>
				    <WALK <REST .P> .DAD T>)>
			     <ADDPARAM <1 .P> .DL>)
			    (<AND <TYPE? .P FORM> <==? <1 .P> QUOTE>>
			     <ADDPARAM <2 .P> .DL>)>
		      <SET PL <REST .PL>>>>>

<DEFINE ADDPARAM (P DL) 
	#DECL ((P) ATOM (PP) <LIST [REST <PRIMTYPE ATOM>]> (DL) DECL)
	<COND (<NOT <PARATOM? .P .PP>>
	       <SET PP (<CHKPARAM .P> !.PP)>
	       <COND (<FIND-SPECIAL-DECL .P .DL> <SET PS (.P !.PS)>)>)
	      (ELSE
	       <ADDNOTE <STRING "ATOM "
				<SPNAME .P>
				" used twice in parameter list.">>)>>

<DEFINE FIND-SPECIAL-DECL (A DCL
			   "AUX" (TOKEN
				  <COND (<==? <SPECIAL-MODE> UNSPECIAL> SPECIAL)
					(ELSE UNSPECIAL)>))
	#DECL ((A TOKEN) ATOM (DCL) DECL)
	<MAPR <>
	      <FUNCTION (DD "AUX" (D <1 .DD>)) 
		      #DECL ((DD) LIST (D) ANY)
		      <AND <TYPE? .D LIST>
			   <MEMQ .A .D>
			   <NOT <LENGTH? .DD 1>>
			   <TYPE? <SET D <2 .DD>> FORM>
			   <==? <LENGTH .D> 2>
			   <==? <1 .D> .TOKEN>
			   <MAPLEAVE T>>>
	      .DCL>>

\ 

<DEFINE CHKPARAM (P) 
	#DECL ((VALUE P) ATOM (ABST) VECTOR)
	<COND (<AND <==? <OBLIST? .P> <ROOT>>
		    <MEMQ <TYPE <LGVAL .P>> ,APPLICABLE-TYPES>>
	       <ADDNOTE <STRING "Untasteful re-use of ATOM "
				<SPNAME .P>
				" in ROOT.">>)>
	.P>

<DEFINE DECLS (PR) 
	#DECL ((PR) <PRIMTYPE LIST> (VALUE) DECL)
	<PROG ()
	      <COND (<AND <NOT <EMPTY? .PR>> <TYPE? <1 .PR> ATOM>>
		     <SET PR <REST .PR>>
		     <AGAIN>)>
	      <COND (<AND <NOT <EMPTY? .PR>> <TYPE? <1 .PR> LIST>>
		     <SET PR <REST .PR>>)>
	      <COND (<AND <NOT <EMPTY? .PR>> <TYPE? <1 .PR> DECL>>
		     <SET PR <1 .PR>>)
		    (ELSE <SET PR #DECL ()>)>>
	<SPEC-LIST .PR>
	<DECL-EXPAND .PR>>

<DEFINE DECL-EXPAND (PR) 
	#DECL ((VALUE) DECL (PR) <PRIMTYPE LIST>)
	<REPEAT ((P .PR) (NEW ()) LOSS)
		#DECL ((P NEW) <PRIMTYPE LIST>)
		<COND (<EMPTY? .P> <RETURN <CHTYPE .NEW DECL>>)
		      (<TYPE? <1 .P> LIST>
		       <COND (<LENGTH? .P 1>
			      <ADDNOTE ("No DECL in DECL for" <1 .P>)>)
			     (<SET LOSS <BAD-DECL? <2 .P>>>
			      <ADDNOTE ["Illegal DECL" <1 .P> <2 .P> .LOSS]>)>
		       <COND (<==? <LENGTH <1 .P>> 1>
			      <SET NEW (<1 .P> <2 .P> !.NEW)>)
			     (<REPEAT ((A <1 .P>) (D <2 .P>))
				      #DECL ((A) <LIST [REST ATOM]> (D) ANY)
				      <COND (<EMPTY? .A> <RETURN>)
					    (ELSE
					     <SET NEW ((<1 .A>) .D !.NEW)>)>
				      <SET A <REST .A>>>)>)>
		<SET P <REST .P>>>>

\ 

<DEFINE BAD-DECL? (DD
		   "AUX" (ALL <ALLTYPES>) (D1 <>) (REST? <>) OR-DECL? (OPT? <>)
			 (FUNNY '![ANY LOCATIVE STRUCTURED APPLICABLE!]))
   #DECL ((DD) ANY (ALL) <VECTOR [REST ATOM]> (REST? OR-DECL? OPT?) <OR ATOM FALSE>
	  (FUNNY) <UVECTOR [REST ATOM]>)
   <PROG ()
     <COND (<NOT <TYPE? .DD ATOM FORM SEGMENT>> <RETURN "Not a legal type">)>
     <COND (<TYPE? .DD ATOM>
	    <COND (<NOT <OR <MEMQ .DD .ALL>
			    <MEMQ .DD .FUNNY>
			    <SET D1 <GETPROP .DD DECL>>>>
		   <RETURN <STRING "Type-name not a type: " <SPNAME .DD>>>)
		  (<AND .D1 <NOT <MEMQ .DD ,DECLS-SEEN>>>
		   <SETG DECLS-SEEN (.DD !,DECLS-SEEN)>
		   <SET DD .D1>
		   <SET D1 <>>
		   <AGAIN>)
		  (ELSE <RETURN <>>)>)>
     <COND (<LENGTH? .DD 1> <RETURN "FORM/SEGMENT too short">)>
     <SET D1 <1 .DD>>
     <COND (<TYPE? .DD FORM>
	    <COND (<==? .D1 QUOTE> <RETURN <>>)
		  (<MEMQ .D1 '![SPECIAL UNSPECIAL!]>
		   <COND (<LENGTH? .DD 2> <SET DD <2 .DD>> <SET D1 <>> <AGAIN>)
			 (<RETURN "SPECIAL/UNSPECIAL with three or more elements">)>)
		  (<==? .D1 PRIMTYPE>
		   <COND (<LENGTH? .DD 2>
			  <COND (<MEMQ <2 .DD> .ALL> <RETURN <>>)
				(<RETURN "Bad PRIMTYPE type">)>)
			 (<RETURN "PRIMTYPE with three or more elements">)>)>)>
     <COND (<TYPE? .D1 ATOM>
	    <COND (<NOT <OR <==? .D1 OR>
			    <MEMQ .D1 .ALL>
			    <MEMQ .D1 <REST .FUNNY 2>>>>
		   <RETURN "Bad type of structured type">)
		  (<==? .D1 BYTES>
		   <COND (<LENGTH? .DD 1> <RETURN "BYTES DECL too short">)
			 (<NOT <LENGTH? .DD 3>> <RETURN "BYTES DECL too long">)
			 (<OR <NOT <TYPE? <2 .DD> FIX>>
			      <G? <2 .DD> 36>
			      <AND <NOT <LENGTH? .DD 2>> <NOT <TYPE? <3 .DD> FIX>>>>
			  <RETURN "Bad BYTES specification">)
			 (ELSE <RETURN <>>)>)>)>
     <SET OR-DECL? <==? .D1 OR>>
     <MAPF <>
      <FUNCTION (D "AUX" E) 
	 <COND
	  (.REST? <MAPLEAVE "REST must terminate DECL">)
	  (<TYPE? .D VECTOR>
	   <COND
	    (.OR-DECL? <MAPLEAVE "VECTOR in OR specification">)
	    (<LENGTH? .D 1> <RETURN "Nth/REST/OPT too short">)
	    (<OR <TYPE? <1 .D> FIX> <MEMQ <1 .D> '![REST OPT!]>>
	     <COND (<AND .OPT? <TYPE? <1 .D> FIX>>
		    <MAPLEAVE "Only REST or OPT may follow OPT">)
		   (<==? <1 .D> REST> <SET REST? T>)
		   (<==? <1 .D> OPT> <SET OPT? T>)>
	     <COND (<SET E
			 <MAPF <>
			       <FUNCTION (X "AUX" Y) 
				       <COND (<SET Y <BAD-DECL? .X>>
					      <MAPLEAVE .Y>)>>
			       <REST .D>>>
		    <MAPLEAVE .E>)>)>)
	  (<TYPE? .D ATOM FORM SEGMENT>
	   <COND (.OPT? <MAPLEAVE "Only REST or OPT may follow OPT">)
		 (<SET E <BAD-DECL? .D>> <MAPLEAVE .E>)>)
	  (ELSE <MAPLEAVE "Not a legal type">)>>
      <REST .DD>>>>

\ 

<DEFINE SPEC-LIST (DCL
		   "AUX" (TOKEN
			  <COND (<==? <SPECIAL-MODE> SPECIAL> UNSPECIAL)
				(T SPECIAL)>))
   #DECL ((DCL) DECL (TOKEN) ATOM)
   <MAPR <>
    <FUNCTION (DR "AUX" (D1 <1 .DR>) D2) 
	    #DECL ((DR D1) <OR <PRIMTYPE LIST> ATOM> (D2) <OR LIST FORM ATOM>
		   (ABST) <VECTOR [10 <PRIMTYPE LIST>]>)
	    <COND (<AND <TYPE? .D1 LIST> <G=? <LENGTH .DR> 2>>
		   <SET D2 <2 .DR>>
		   <COND (<AND <TYPE? .D2 FORM>
			       <G=? <LENGTH .D2> 2>
			       <==? <1 .D2> .TOKEN>>
			  <MAPF <>
				<FUNCTION (D) 
					#DECL ((D) ATOM)
					<ADDLVAL <REST .ABST ,RSPEC>
						 .D
						 #DECL ()
						 <2 .D2>>>
				.D1>)>)>>
    .DCL>>

<DEFINE EXT-GLOBALS (VAR GG "AUX" (V <1 .VAR>)) 
   #DECL ((VAR) <VECTOR DECL> (GG) DECL (V) DECL)
   <REPEAT ((G .GG) G1)
	   #DECL ((G) <PRIMTYPE LIST> (G1) <LIST [REST ATOM]> (FAMILY) FAMILY)
	   <COND (<EMPTY? .G> <RETURN>)
		 (<TYPE? <1 .G> LIST>
		  <SET G1 <1 .G>>
		  <COND (<AND <NOT <MEMQ <1 .G1> <TOP-FCNS .FAMILY>>>
			      <NOT <MEMQ <1 .G1> <TOP-GLOBALS .FAMILY>>>>
			 <COND (<HAS-DECL? <1 .G1> .V>)
			       (ELSE
				<PUT .VAR
				     1
				     <SET V
					  <CHTYPE (.G1 <2 .G> !.V) DECL>>>)>)>)>
	   <SET G <REST .G 2>>>>

<DEFINE HAS-DECL? (ATM DCL "OPTIONAL" ADECL) 
	#DECL ((VALUE) <OR FALSE ATOM FORM> (ATM) ATOM (DCL) <PRIMTYPE LIST>
	       (ADECL) <OR ATOM FORM>)
	<REPEAT ()
		<COND (<EMPTY? .DCL> <RETURN <>>)
		      (<AND <TYPE? <1 .DCL> LIST>
			    <MEMQ .ATM <1 .DCL>>
			    <NOT <EMPTY? <REST .DCL>>>>
		       <COND (<ASSIGNED? ADECL> <PUT .DCL 2 .ADECL>)>
		       <RETURN <2 .DCL>>)>
		<SET DCL <REST .DCL>>>>

<DEFINE HAS-TYPE-DECL? (ATM DCL "AUX" (HAS? <HAS-DECL? .ATM .DCL>)) 
	#DECL ((HAS? VALUE) <OR FALSE ATOM FORM> (ATM) ATOM (DCL) DECL)
	<COND (<AND .HAS? <N==? .HAS? NO-DECL>> .HAS?)>>

\ 

<DEFINE ADDGVAL (VAR X
		 "AUX" (T NO-DECL) TMP (O <OBJECT-OBLISTS .FAMILY>) (VAL <LGVAL .X>)) 
   #DECL ((VAR) <VECTOR DECL> (X) ATOM (TMP) ANY (FAMILY) FAMILY
	  (VAL) ANY (T) <OR ATOM FORM> (O) <LIST [REST OBLIST]>)
   <USED-ATOM .X <TOP-GLOBALS .FAMILY>>
   <COND (<TYPE? .VAL SUBR FSUBR>)
	 (<MEMQ <OBLIST? .X> .O>
	  <COND (<NOT <GBOUND? .X>>)
		(<SET TMP <GET-DECL <GLOC .X>>>
		 <COND (<AND <==? .TMP MANIFEST> <GASSIGNED? .X>>
			<SET T <FORM MANIFEST <TYPE <SET TMP ,.X>>>>
			<COND (<STRUCTURED? .TMP>
			       <ADDNOTE <STRING <SPNAME .X>
						": MANIFESTed structure">>)>)
		       (ELSE <SET T .TMP>)>)
		(<MEMQ <SET TMP <LGTYP .X>> ,USER-APPLICABLE-TYPES>
		 <SET T .TMP>)
		(<SET TMP <HAS-DECL? .X ,KNOWN-DECLS>> <SET T .TMP>)>
	  <USED-PACKAGE .X>)>
   <COND (<HAS-DECL? .X <1 .VAR>>)
	 (ELSE <PUT .VAR 1 <CHTYPE ((.X) .T !<1 .VAR>) DECL>>)>>

<DEFINE USED-PACKAGE (X
		      "AUX" (O <OBJECT-OBLISTS .FAMILY>)
			    (P? <N==? <1 .O> <GET INITIAL OBLIST>>) TMP)
	#DECL ((X) ATOM (O) <LIST [REST OBLIST]>)
	<COND (<AND .P? <N==? <OBLIST? .X> <1 .O>> <N==? <OBLIST? .X> <2 .O>>>
	       <COND (<SET TMP
			   <MEMBER <SPNAME <SET X <GET <OBLIST? .X> OBLIST>>>
				   <USED-PACK .FAMILY>>>
		      <PUT .TMP 1 <CHTYPE (<1 .TMP>) FALSE>>)>)>>

<DEFINE ADDLVAL (VAR X DL "OPTIONAL" D) 
	#DECL ((VAR) <VECTOR DECL> (X) ATOM (DL) DECL (D) <OR ATOM FORM>)
	<COND (<NOT <ASSIGNED? D>>
	       <SET D <COND (<HAS-DECL? .X .DL>) (ELSE NO-DECL)>>)>
	<COND (<HAS-DECL? .X <1 .VAR> .D>)
	      (ELSE <PUT .VAR 1 <CHTYPE ((.X) .D !<1 .VAR>) DECL>>)>>

<DEFINE ADDFNC (X FV RLEAF
		"AUX" (F <MEMQ .X <TREE .FAMILY>>) (XF <REST .ABST ,REXTF>) A XV
		      (ANUM 0) (SEG? <>) (GXF <REST <GABST .FAMILY> ,REXTF>))
	#DECL ((X) ATOM (FV) FATHER (RLEAF) <PRIMTYPE LIST> (ANUM) FIX
	       (SEG?) <OR ATOM FALSE> (A) LIST (XV) ANY
	       (F) <OR FALSE <LIST [REST ATOM LIST LIST VECTOR]>>
	       (XF GXF) <VECTOR LIST> (FAMILY) FAMILY (ABST) VECTOR)
	<COND (<NOT .F>
	       <COND (<SET XV <LGVAL .X>> <SET A <RSUBR-DECL .XV <>>>)
		     (ELSE
		      <SET A <LIST 0 100000000>>
		      <ADDNOTE <STRING "Calls undefined function "
				       <SPNAME .X>>>)>
	       <USED-PACKAGE .X>)
	      (ELSE <USED-ATOM .X <TOP-FCNS .FAMILY>> <SET A <NARGS <ABST .F>>>)>
	<MAPF <>
	      <FUNCTION (L) 
		      <COND (<TYPE? .L SEGMENT> <SET SEG? T>)
			    (ELSE <SET ANUM <+ .ANUM 1>>)>>
	      .RLEAF>
	<COND (<N==? <LENGTH .A> 2>)
	      (<AND <L? .ANUM <1 .A>> <NOT .SEG?>>
	       <ADDNOTE <STRING "Calls "
				<SPNAME .X>
				" with too few arguments.">>)
	      (<G? .ANUM <2 .A>>
	       <ADDNOTE <STRING "Calls "
				<SPNAME .X>
				" with too many arguments.">>)>
	<COND (<NOT <MEMQ .X <1 .XF>>> <PUT .XF 1 (.X !<1 .XF>)>)>
	<COND (<AND .F <NOT <MEMQ .FV <FATHERS .F>>>>
	       <PUT .F ,FATHERS (.FV !<FATHERS .F>)>)>
	<COND (<AND <NOT .F> <NOT <MEMQ .X <1 .GXF>>>>
	       <PUT .GXF 1 (.X !<1 .GXF>)>)>>

<DEFINE ADDATUM (DDL D "AUX" (DL <1 .DDL>) (FDL <USED-DATUM .FAMILY>)) 
	#DECL ((DDL) VECTOR (DL FDL) <LIST [REST STRING]> (D) STRING)
	<COND (<MEMBER .D .DL>) (ELSE <PUT .DDL 1 (.D !.DL)>)>
	<COND (<MEMBER .D .FDL>) (ELSE <PUT .FAMILY ,USED-DATUM (.D !.FDL)>)>>

<DEFINE ADDNOTE (N "OPTIONAL" (AB .ABST) (NL <NOTES .AB>)) 
	#DECL ((N) ANY (ABST AB) VECTOR (NL) LIST)
	<COND (<EMPTY? .NL> <SET NL (.N)>)
	      (ELSE <PUTREST <REST .NL <- <LENGTH .NL> 1>> (.N)>)>
	<PUT .AB ,NOTES .NL>>

\ 

<DEFINE EXT-LOCALS (VAR DD FATHERS SU) 
	#DECL ((DD) DECL (FATHERS) <LIST [REST FATHER]> (VAR) <VECTOR DECL>
	       (SU) STRING)
	<REPEAT ((D .DD) B? D? A TMP (UNB ()) (UND ()) AUNB
		 (OO <OBJECT-OBLISTS .FAMILY>))
		#DECL ((D) <<PRIMTYPE LIST> [REST <LIST ATOM> ANY]> (A) ATOM
		       (B? D?) <SPECIAL ANY> (FAMILY) FAMILY (TMP) ANY
		       (AUNB) <SPECIAL LIST> (UNB UND) <LIST [REST ATOM]>
		       (OO) <LIST [REST OBLIST]>)
		<COND (<EMPTY? .D>
		       <COND (<AND <NOT <EMPTY? .UNB>> <NOT <EMPTY? .UND>>>
			      <ADDNOTE (<STRING .SU " but unbound and unDECLed">
					.UNB)>)
			     (<NOT <EMPTY? .UNB>>
			      <ADDNOTE (<STRING .SU " but unbound"> .UNB)>)
			     (<NOT <EMPTY? .UND>>
			      <ADDNOTE (<STRING .SU " but unDECLed"> .UND)>)>
		       <RETURN T>)>
		<SET D? <COND (<N==? <2 .D> NO-DECL> <2 .D>)>>
		<SET B? <>>
		<SET A <1 <1 .D>>>
		<COND (<MEMQ .A ,KNOWN-ATOMS>
		       <SET AUNB ()>
		       <AND <NOT .B?> <SET B? T>>
		       <SET D? <2 <HAS-TYPE-DECL? .A ,KNOWN-DECLS>>>)
		      
		      (<NOT <EMPTY? .FATHERS>>
		       <SET AUNB ()>
		       <EXT-LOCAL1 .A
				   .FATHERS
				   ()
				   <TREE .FAMILY>
				   (.FATHER-NAME)
				   <PARATOM? .A <TOP-LOCALS .FAMILY>>>)>
		<COND (.D? <PUT .D 2 .D?>)
		      (<SET TMP <HAS-DECL? .A ,KNOWN-DECLS>>
		       <SET D? .TMP>
		       <PUT .D 2 .TMP>)
		      (ELSE <SET UND (.A !.UND)>)>
		<COND (<NOT .B?>
		       <OR .D? <SET D? NO-DECL>>
		       <COND (<NOT <MEMQ <OBLIST? .A> .OO>>
			      <ADDLVAL .VAR .A #DECL () .D?>)
			     (<USED-ATOM .A <TOP-LOCALS .FAMILY>>)
			     (ELSE <SET UNB (.A !.UNB)>)>)
		      (<NOT <EMPTY? .AUNB>>
		       <ADDNOTE (<STRING <SPNAME .A> " unbound in paths">
				 .AUNB)>)>
		<SET D <REST .D 2>>>>

\ 

<DEFINE EXT-LOCAL1 (ATM FATHERS UF TR PATH TOPLVAL "AUX" DTMP TA F1) 
   #DECL ((ATM) ATOM (FATHERS) <LIST [REST FATHER]> (UF) LIST
	  (TOPLVAL DTMP B? D?) ANY (TA) <PRIMTYPE LIST> (F1) FATHER
	  (TR) <LIST [REST ATOM LIST LIST VECTOR]> (PATH) <LIST [REST ATOM]>)
   <REPEAT ((F .FATHERS))
     #DECL ((F) <LIST [REST FATHER]>)
     <COND (<EMPTY? .F> <RETURN>)
	   (<NOT <MEMQ <SET F1 <1 .F>> .UF>>
	    <COND (<PARAMETER? .ATM <FPLST .F1>>
		   <AND <NOT .B?> <SET B? T>>
		   <AND <SET DTMP <HAS-TYPE-DECL? .ATM <FDLST .F1>>>
			<SET D? .DTMP>>
		   <COND (<AND .D? <SPECIAL-DECL? .D?>>
			  <SET D? <2 .D?>>
			  <USED .ATM <FSPEC .F1>>)
			 (ELSE
			  <PROG ((S
				  <STRING "The ATOM "
					  <SPNAME .ATM>
					  " used in "
					  <SPNAME .FATHER-NAME>
					  " should be special in "
					  <SPNAME <NAME .F1>>
					  ".">))
				<ADDNOTE .S>
				<COND (<SET TA <MEMQ <NAME .F1> .TR>>
				       <ADDNOTE .S <ABST .TA>>)>>)>
		   <SET F <REST .F>>
		   <AGAIN>)
		  (<SET TA <MEMQ <NAME .F1> .TR>>
		   <COND (<NOT <EMPTY? <2 .TA>>>
			  <EXT-LOCAL1 .ATM
				      <2 .TA>
				      (.F1 !.UF)
				      .TR
				      (<NAME .F1> !.PATH)
				      .TOPLVAL>)
			 (<NOT .TOPLVAL> <SET AUNB ((<NAME .F1> !.PATH) !.AUNB)>)>)
		  (ELSE
		   <ADDNOTE <STRING "External FUNCTION "
				    <SPNAME <NAME .F1>>>>)>)>
     <SET F <REST .F>>>>

<DEFINE SPECIAL-DECL? (D) 
	#DECL ((D) <OR ATOM FORM> (VALUE) <OR ATOM FORM FALSE>)
	<COND (<AND <TYPE? .D FORM>
		    <G? <LENGTH .D> 1>
		    <OR <==? <1 .D> SPECIAL> <==? <1 .D> UNSPECIAL>>>
	       <2 .D>)>>

\ 

"Make a father and add it to the list of sons of a node"

<DEFINE FATHER (TY DL PL SP "AUX" (FT .FTREE) (SFT <SONS .FT>) F) 
	#DECL ((TY) ATOM (PL SP) <LIST [REST LIST]> (DL) DECL
	       (FT) <LIST ATOM [2 LIST] VECTOR> (SFT) <LIST [REST FATHER]>
	       (F VALUE) FATHER)
	<SET F <CHTYPE <VECTOR .FATHER-NAME .TY .DL .PL .SP> FATHER>>
	<COND (<EMPTY? .SFT> <PUT .FT ,SONS (.F)>)
	      (ELSE <PUTREST <REST .SFT <- <LENGTH .SFT> 1>> (.F)>)>
	.F>

<DEFINE WALK (L "OPTIONAL" FATHER (CHANGE <>)
	      "AUX" (PLIST <FPLST .FATHER>) (DLIST <FDLST .FATHER>)
	            (SLIST <FSPEC .FATHER>)
	            CTLS DAD V (LMAP <>) (Q? <>) (QLEAF <>) (LCNT 0))
   #DECL ((L) <OR <PRIMTYPE LIST> VECTOR UVECTOR> (PLIST SLIST) <LIST [REST LIST]>
	  (FATHER DAD) FATHER (DLIST) DECL (CTLS) ATOM
	  (LCNT) FIX (QLEAF) <OR FIX FALSE> (CHANGE Q?) <OR ATOM FALSE>)
   <COND (<MEMQ <SET V <LGVAL <1 .L>>> ,MAPF-MAPR> <SET LMAP <3 .L>>)
	 (<MEMQ .V ,FUNNY-FSUBRS> <SET Q? T>)
	 (<MEMQ .V ,PRINTING-SUBRS> <USED OUTCHAN .PLIST>)
	 (<MEMQ .V ,OPEN-SUBRS>
	  <USED DEV .SLIST> <USED SNM .SLIST> <USED NM1 .SLIST> <USED NM2 .SLIST>)
	 (<AND <TYPE? .V SUBR> <SET LMAP <MEMQ .V ,QUOTING-SUBRS>>>
	  <SET QLEAF <2 .LMAP>>)>
   <MAPF <>
    <FUNCTION (LEAF "AUX" TMP TMP1 FUN (V1LEAF <>)) 
       #DECL ((LEAF) ANY (TMP1) LIST (TMP) DECL (FUN) <PRIMTYPE LIST>)
       <SET LCNT <+ .LCNT 1>>
       <COND
	(<TYPE? .LEAF ATOM> <USED .LEAF .PLIST>)
	(<AND <MEMQ <TYPE .LEAF> ,EVAL-OR-APPLY> <NOT <EMPTY? .LEAF>>>
	 <AND <TYPE? .LEAF FORM SEGMENT>
	      <COND (<SET V1LEAF <AND <TYPE? <1 .LEAF> ATOM> <1 .LEAF>>>
		     <SET V1LEAF <LGVAL .V1LEAF>>
		     <SET CHANGE
			  <OR <INT-FORM .LEAF .L .FATHER>
			      .CHANGE>>)
		    (<TYPE? <1 .LEAF> FIX> <SET CHANGE T>)>>
	 <COND (<TYPE? .LEAF MACRO> <SET LEAF <1 .LEAF>>)>
	 <COND (<OR <TYPE? .LEAF FUNCTION>
		    <AND .V1LEAF <MEMQ .V1LEAF ,CONTROL-STRUCTURES>>>
		<COND (<TYPE? <1 .LEAF> ATOM> <SET FUN <REST .LEAF>>)
		      (ELSE <SET FUN .LEAF>)>
		<COND (<TYPE? <1 .FUN> ATOM> <SET FUN <REST .FUN>>)>
		<SET TMP <DECLS .LEAF>>
		<SET TMP1 <PARAMS .LEAF .PLIST .DLIST .SLIST>>
		<SET CTLS
		     <COND (<TYPE? .LEAF FUNCTION> FUNCTION)
			   (ELSE <1 .LEAF>)>>
		<COND (<AND <N==? .LMAP .LEAF>
			    <OR <TYPE? .LEAF FUNCTION> <==? .V1LEAF ,FUNCTION>>>
		       <SET DAD
			    <FATHER .CTLS
				    .TMP
				    (<1 .TMP1>)
				    (<2 .TMP1>)>>)
		      (ELSE
		       <SET DAD
			    <FATHER .CTLS
				    <CHTYPE (!.TMP !.DLIST) DECL>
				    (<1 .TMP1> !.PLIST)
				    (<2 .TMP1> !.SLIST)>>)>
		<WALK <REST .FUN> .DAD>)
	       (<OR <==? .LCNT .QLEAF> <N==? .V1LEAF ,QUOTE>>
		<SET CHANGE
		     <OR <WALK <COND (<TYPE? <LGVAL <1 .LEAF>> MACRO> (<EXPAND .LEAF>))
				     (ELSE .LEAF)>
			       .FATHER
			       .Q?>
			 .CHANGE>>)>)
	(<TYPE? .LEAF VECTOR UVECTOR>
	 <ADDNOTE ["Possibly should be QUOTEd" .LEAF]>)>>
    .L>
   <COND (<AND <TYPE? .L LIST VECTOR UVECTOR> <NOT .CHANGE>>
	  <ADDNOTE ["Possibly should be QUOTEd" .L]>)>
   .CHANGE>

<DEFINE USED (A PL) 
	#DECL ((PL) <LIST [REST <LIST [REST <PRIMTYPE ATOM>]>]> (A) ATOM)
	<MAPF <>
	      <FUNCTION (P) 
		   #DECL ((P) <LIST [REST <PRIMTYPE ATOM>]>)
		   <COND (<MAPR <>
				<FUNCTION (QQ "AUX" (Q <1 .QQ>))
				     #DECL ((QQ) LIST (Q) <PRIMTYPE ATOM>)
				     <COND (<==? .A .Q>
					    <PUT .QQ 1 <CHTYPE .Q DISMISS>>
					    <MAPLEAVE T>)
					   (<==? <CHTYPE .A DISMISS> .Q>
					    <MAPLEAVE T>)>>
				.P>
			  <MAPLEAVE T>)>>
	      .PL>>

<DEFINE USED-ATOM (A PL)
	#DECL ((A) ATOM (PL) <LIST [REST <PRIMTYPE ATOM>]>)
	<MAPR <>
	      <FUNCTION (QQ "AUX" (Q <1 .QQ>))
			#DECL ((QQ) LIST (Q) <PRIMTYPE ATOM>)
			<COND (<==? .A .Q>
			       <PUT .QQ 1 <CHTYPE .Q DISMISS>>
			       <MAPLEAVE T>)
			      (<==? <CHTYPE .A DISMISS> .Q>
			       <MAPLEAVE T>)>>
	      .PL>>

<DEFINE PARAMETER? (A PL)
	#DECL ((A) ATOM (PL) <LIST [REST <LIST [REST <PRIMTYPE ATOM>]>]>)
	<MAPF <>
	      <FUNCTION (P)
		   #DECL ((P) <LIST [REST <PRIMTYPE ATOM>]>)
		   <COND (<PARATOM? .A .P> <MAPLEAVE T>)>>
	      .PL>>

<DEFINE PARATOM? (A PL)
	#DECL ((A) ATOM (PL) <LIST [REST <PRIMTYPE ATOM>]>
	       (VALUE) <OR <PRIMTYPE ATOM> FALSE>)
	<MAPF <>
	      <FUNCTION (Q)
			#DECL ((Q) <PRIMTYPE ATOM>)
			<COND (<OR <==? .A .Q> <==? <CHTYPE .A DISMISS> .Q>>
			       <MAPLEAVE .Q>)>>
	      .PL>>

\ 

<DEFINE INT-FORM (LEAF LIMB FATHER
		  "AUX" (F <1 .LEAF>) FF LL
			(A <COND (<G? <LENGTH .LEAF> 1> <2 .LEAF>)>)
			(FTYP <LGTYP .F>) P (CHANGE T))
   #DECL ((LEAF) <<PRIMTYPE LIST> ATOM> (CHANGE) <OR ATOM FALSE>
	  (LIMB) <OR <PRIMTYPE LIST> VECTOR UVECTOR> (F) ATOM (FATHER) FATHER
	  (A FF LL FTYP P) ANY)
   <COND (<AND <SET FF <LGVAL .F>> <==? .FF ,USE-DATUM>>
	  <ADDATUM <REST .ABST ,RDATUMS> .A>)
	 (<OR <NOT .FTYP> <MEMQ .FTYP ,USER-APPLICABLE-TYPES>>
	  <ADDFNC .F .FATHER <REST .LEAF>>)
	 (<AND <TYPE? .A ATOM> .FF <MEMQ .FF ,INT-SUBRS>>
	  <SET P <PARAMETER? .A <FPLST .FATHER>>>
	  <COND (<AND <==? .FF ,SET> <NOT .P>>
		 <ADDLVAL <REST .ABST ,RLSET> .A <FDLST .FATHER>>)
		(<AND <MEMQ .FF ,LVAL-LLOC> <NOT .P>>
		 <ADDLVAL <REST .ABST ,RLUSED> .A <FDLST .FATHER>>)
		(<MEMQ .FF ,SETG-DEFINE> <ADDGVAL <REST .ABST ,RGSET> .A>)
		(<OR <MEMQ .FF ,GVAL-GLOC> <AND <==? .FF ,VALUE> <NOT .P>>>
		 <COND (<AND <TYPE? .LIMB FORM SEGMENT>
			     <NOT <LENGTH? .LIMB 1>>
			     <TYPE? <1 .LIMB> ATOM>
			     <SET LL <LGVAL <1 .LIMB>>>
			     <OR <AND <MEMQ .LL ,APPLY-MAPF-MAPR>
				      <==? <2 .LIMB> .LEAF>>
				 <AND <MEMQ .LL ,MAPF-MAPR>
				      <NOT <LENGTH? .LIMB 2>>
				      <==? <3 .LIMB> .LEAF>>>>
			<SET FTYP <LGTYP .A>>
			<COND (<NOT <MEMQ .FTYP '![SUBR FSUBR!]>>
			       <ADDFNC .A
				       .FATHER
				       <REST .LIMB
					     <COND (<==? .LL ,APPLY> 2)
						   (ELSE 3)>>>)>)
		       (<MEMQ .FTYP ,USER-APPLICABLE-TYPES>
			<ADDFNC .A .FATHER <REST .LEAF>>)
		       (ELSE
			<COND (<AND <GBOUND? .A> <MANIFEST? .A>>
			       <SET CHANGE <>>)>
			<ADDGVAL <REST .ABST ,RGUSED> .A>)>)>)
	 (<AND <GBOUND? .F> <MANIFEST? .F>>
	  <ADDGVAL <REST .ABST ,RGUSED> .F>)>
   .CHANGE>

\ 

<DEFINE RSUBR-DECL (A
		    "OPTIONAL" (N? T)
		    "AUX" (AB .ABST) TEMP (MACRO? <>) (AL '(0 0)))
	#DECL ((A) <OR ATOM <PRIMTYPE LIST> RSUBR RSUBR-ENTRY>
	       (AL) <LIST FIX FIX> (AB) VECTOR (TEMP) ANY (N? MACRO?) <OR ATOM FALSE>)
	<COND (<TYPE? .A MACRO> <SET A <1 .A>> <SET MACRO? T>)>
	<COND (<AND .N? <TYPE? .A ATOM>>
	       <COND (<MEMQ .A <ALLTYPES>>
		      <SET TEMP <GET .A DECL '.A>>
		      <AND .TEMP <CHTYPE (.TEMP) DECL>>)
		     (ELSE #DECL (NOT-A-TYPE))>)
	      (<MEMQ <TYPE .A> '![RSUBR-ENTRY RSUBR!]>
	       <COND (<AND <G? <LENGTH .A> 2> <TYPE? <3 .A> DECL>>
		      <SET AL <RSUBR-NARGS <3 .A>>>
		      <AND .N? <PUT .AB ,RDECL <3 .A>>>
		      <AND .N? <PUT .AB ,NARGS .AL>>)
		     (ELSE
		      <AND .N? <ADDNOTE "RSUBR has no DECL.">>
		      <SET AL <LIST 0 100000000>>
		      <AND .N?
			   <PUT .AB ,RDECL #DECL ("VALUE" ANY "TUPLE" TUPLE)>>
		      <AND .N? <PUT .AB ,NARGS .AL>>)>)
	      (<TYPE? .A FUNCTION>
	       <COND (<TYPE? <1 .A> ATOM> <SET A <REST .A>>)>
	       <COND (<TYPE? <2 .A> DECL>
		      <SET AL <FUNC-DECL <1 .A> <2 .A> .N?>>)
		     (ELSE
		      <COND (<AND .N? <NOT .MACRO?> <NOT <EMPTY? <1 .A>>>>
			     <ADDNOTE "FUNCTION has no DECL.">)>
		      <SET AL <FUNC-DECL <1 .A> <> .N?>>)>)>
	.AL>

<DEFINE RSUBR-NARGS (DE "AUX" A) 
	#DECL ((DE) DECL (VALUE) <LIST FIX FIX> (A) <PRIMTYPE LIST>)
	<FUNC-DECL <COND (<SET A <MEMBER "VALUE" .DE>> <REST .A 2>)
			 (ELSE <REST .DE 0>)>
		   <>
		   <>>>

\ 

<DEFINE FUNC-DECL (ARGL DE N?
		   "AUX" (DD ("VALUE")) (AA ()) (PAR? T) (AMIN 0) (AMAX <>)
			 (AB .ABST))
   #DECL ((ARGL) LIST (DD) LIST (ABST AB) VECTOR (AMIN) FIX
	  (AA) <LIST [REST ATOM]> (AMAX) <OR FIX FALSE> (DE) <PRIMTYPE LIST>
	  (PAR? N?) <OR ATOM FALSE>)
   <SET ARGL (VALUE !.ARGL)>
   <REPEAT (ARG (PUN ()) ADCL)
	   #DECL ((ARG) ANY (PUN) <SPECIAL <LIST [REST ATOM]>>)
	   <COND (<EMPTY? .ARGL>
		  <AND .N?
		       <COND (<NOT <EMPTY? .PUN>>
			      <ADDNOTE ("Parameters not DECLed" .PUN)>)>>
		  <RETURN>)
		 (ELSE <SET ARG <1 .ARGL>>)>
	   <COND
	    (<=? .ARG "BIND">
	     <OR .PAR? <AND .N? <ADDNOTE "\"BIND\" illegally located.">>>
	     <SET ARGL <REST .ARGL>>)
	    (<MEMBER .ARG '["NAME" "ACT"]> <SET ARGL <REST .ARGL>>)
	    (<MEMBER .ARG '["CALL" "ARGS"]>
	     <OR .PAR?
		 <AND .N? <ADDNOTE "\"CALL\"/\"ARGS\" illegally located.">>>
	     <SET ARGL <REST .ARGL>>
	     <SET AMAX 100000000>)
	    (<MEMBER .ARG '["OPTIONAL" "OPT"]>
	     <COND (.PAR? <SET AMAX .AMIN> <AND .N? <APPEND DD "OPTIONAL">>)
		   (ELSE <ADDNOTE "\"OPTIONAL\" illegally located.">)>)
	    (<=? .ARG "TUPLE">
	     <SET ARGL <REST .ARGL>>
	     <COND (.PAR?
		    <SET AMAX 1000000>
		    <AND .N? <APPEND DD <ARG-DECL <1 .ARGL> .DE TUPLE>>>)
		   (ELSE <ADDNOTE "\"TUPLE\" illegally located.">)>)
	    (<MEMBER .ARG '["AUX" "EXTRA"]> <SET PAR? <>>)
	    (<AND <TYPE? .ARG FORM>
		  <OR <AND <==? <LENGTH .ARG> 2> <==? <1 .ARG> QUOTE>>
		      <NOT .N?>>>
	     <COND (.PAR?
		    <COND (.AMAX <SET AMAX <+ .AMAX 1>>)
			  (ELSE <SET AMIN <+ .AMIN 1>>)>
		    <COND (.N?
			   <APPEND DD <ARG-DECL <2 .ARG> .DE>>
			   <SET AA (<2 .ARG> !.AA)>)>)
		   (ELSE <ADDNOTE (<2 .ARG> "\"AUX\" Illegally QUOTEd")>)>)
	    (<AND <TYPE? .ARG ATOM> <N==? .ARG VALUE>>
	     <AND .N? <SET ADCL <ARG-DECL .ARG .DE>>>
	     <COND (.PAR?
		    <COND (.N? <APPEND DD .ADCL> <SET AA (.ARG !.AA)>)>
		    <COND (.AMAX <SET AMAX <+ .AMAX 1>>)
			  (ELSE <SET AMIN <+ .AMIN 1>>)>)>)
	    (<TYPE? .ARG LIST>
	     <AND .N?
		  <SET ADCL
		       <ARG-DECL <1 .ARG>
				 .DE
				 <COND (<TYPE? <2 .ARG> FORM> ANY)
				       (ELSE <FORM OR <TYPE <2 .ARG>>>)>>>>
	     <COND (.PAR?
		    <COND (.N? <APPEND DD .ADCL> <SET AA (<1 .ARG> !.AA)>)>
		    <COND (.AMAX <SET AMAX <+ .AMAX 1>>)
			  (ELSE <SET AMIN <+ .AMIN 1>>)>)>)>
	   <SET ARGL <REST .ARGL>>>
   <COND (.N?
	  <PUT .AB ,RDECL <CHTYPE .DD DECL>>
	  <PUT .AB ,NARGS <LIST .AMIN <OR .AMAX .AMIN>>>
	  <PUT .AB ,ATOML .AA>
	  <NARGS .AB>)
	 (ELSE <LIST .AMIN <OR .AMAX .AMIN>>)>>

<DEFINE ARG-DECL (ARG DEC "OPTIONAL" (DEF ANY)) 
	#DECL ((ARG) ATOM (DEC) <PRIMTYPE LIST> (VALUE DEF) <OR ATOM FORM>
	       (ABST) VECTOR)
	<COND (.DEC
	       <COND (<HAS-DECL? .ARG .DEC>)
		     (<N==? .ARG VALUE> <SET PUN (.ARG !.PUN)> .DEF)
		     (ELSE .DEF)>)
	      (ELSE .DEF)>>

<DEFMAC APPEND ('AA 'STUFF) 
	<FORM PROG
	      <LIST <LIST A <FORM LVAL .AA>> (STUFF .STUFF)>
	      #DECL ((A) LIST)
	      <FORM SET
		    .AA
		    '<COND (<EMPTY? .A> (.STUFF))
			   (ELSE
			    <PUTREST <REST .A <- <LENGTH .A> 1>> (.STUFF)>
			    .A)>>>>

<ENDPACKAGE>
