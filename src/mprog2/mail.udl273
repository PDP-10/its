
<BLOAT 50000 1 30 300 3 30>

<PACKAGE "MAIL">

<ENTRY SAVE-MAIL>

"For Reader"

<ENTRY COMPOSING? IN-READER? COMPOS-CHRTABLE MUDDLE-ESCAPE
       MAILER MAILER-INIT OPEN-FAILED GET-TEMP GET-IDS FLIP-EDITOR
       MSG-NO IN-REPLY-TO ID-IRT SUBJECT CARBON-COPY-TO TEXT SKIP-MSG-NO
       FBUF>

<USE "SYMBOLS" "BUF" "NSTR" "ITIME" "DDT" "JCL"
     "PARSE-DATE" "LEXER" "HOSTS" "LSRTNS" "CHKADR">

<USE "CTABLE">

\ 

"Constant (more or less) GVALS"

<SETG COMPOSING? <>>

<SETG IN-READER? <>>

<SETG MORE-MSGS <>>

<SETG IFILE "COMSYS;M >">

<SETG DUMP-FILE ".MAIL >">

<GDECL (CONSOLE-START) FIX
       (CPU-START) FLOAT>

<GDECL (NOTES-LIST) LIST>

<SETG SAVE-WHERE "DSK:LIBRDR;">

;"default directory for save file"

<SETG DIVERT-HAND
      <HANDLER <SETG DIVERT-INT <EVENT "DIVERT-AGC" 1000>>
	       <FUNCTION (AMT REASON) <BLOAT <+ .AMT 4000>>>>>

<OFF ,DIVERT-HAND>

<SETG TTY2 #WORD *030202020202*>	;"let ^G and ^S interrupt"
<SETG BUF-CTL-G? <>>			;"but don't hack ^G"

\ 

<SETG INITED <>>

<SETG ASK-ME <SETG MAIL-ASK-ME '("TO" "SUBJECT" "TEXT")>>

<SETG MSG-ASK-ME '("MSG-FILE" "SUBJECT" "TO" "TEXT")>

<SETG FORWARD-ASK-ME '("MSG-NO" "TO" "ANNOTATION")>

<SETG BUG-ASK-ME '("PROGRAM" "SUBJECT" "TEXT")>

<GDECL (ASK-ME TO-ASK-ME MSG-ASK-ME FORWARD-ASK-ME BUG-ASK-ME)
       <LIST [REST STRING]>>

\ 

<DEFINE SAVE-MAIL (VERNUM "OPTIONAL" (DIR ,SAVE-WHERE))
    #DECL ((VERNUM) <OR FIX FALSE> (DIR) STRING)
    <MAILER-INIT>
    <COND (<AND .VERNUM
		<PROG ()
		      <SNAME "">
		      <HANDLER ,DIVERT-INT ,DIVERT-HAND>
		      <RESET .INCHAN>
		      <SETG BUF-CTL-G? <>>
		      T>
		<=? <SAVE <STRING .DIR "MAIL" <UNPARSE .VERNUM>>>
		    "SAVED">>
	   "SAVED")
	  (ELSE <MAILER>)>>

<DEFINE MUDDLE-ESCAPE ()
	<COND (<LOGGED-IN?>
	       <SETG BUF-CTL-G? T>
	       <INTERRUPT "CHAR" <ASCII 7> ,INCHAN>
	       <SETG BUF-CTL-G? <>>)>> 

<DEFINE LOGGED-IN? ("OPTIONAL" (PRINT? T) "AUX" (U <UNAME>))
	#DECL ((U) STRING)
	<COND (<AND <==? <LENGTH .U> 6>
		    <==? !\_ <1 .U>>
		    <==? !\_ <2 .U>>
		    <==? !\_ <3 .U>>>
	       <AND .PRINT? <PRINC " (Not logged in?) ">>
	       <>)
	      (ELSE T)>>

<DEFINE MAILER-INIT ("OPTIONAL" (REINIT? T))
	#DECL ((REINIT?) <OR ATOM FALSE>)
	<COND (<NOT ,INITED>
	       <INIT-FIELDS>
	       <INIT-MESSAGE>
	       <SETG INITED T>)
	      (ELSE <ALLCLEAR> <INIT-MESSAGE .REINIT?>)>>

<DEFINE MAILER ("OPTIONAL" (JNAM <JNAME>))	   
	#DECL ((JNAM) <OR FALSE STRING>)
	<INIT>				;"set up BUF defaults"
	<COND (<NOT <LOGGED-IN? <>>> <SETG REP ,QUIT>)>
	<COND (.JNAM
	       <SETG COMPOSING? T>
	       <COND (<MEMBER "FEA" .JNAM> <SETG FEATURE T>)
		     (<MEMBER "BUG" .JNAM> <SETG BUG T>)
		     (<MEMBER "REM" .JNAM> <SETG REMIND T>)
		     (<MEMBER "MSG" .JNAM> <SETG MSG T>)
		     (<MEMBER "FOR" .JNAM> <SETG FORWARD T>)
		     (<MEMBER "ANS" .JNAM> <SETG ANSWER T>)
		     (<MEMBER "COR" .JNAM> <SETG FORWARD T> <SETG CORRECT T>)>
	       <AND <NOT ,IN-READER?> <JCL?> <HACK-JCL <READJCL>>>
	       <BUFCLEAR <FBUF ,FROM>>
	       <COND (<NOT ,FORWARD> <ADDSTRING <FBUF ,FROM> <XUNAME>>)>)>
	<COND (<NOT .JNAM> <MESSAGE-LOOP -1>)
	      (,JCL-CTRL-C <MESSAGE-LOOP 1>)
	      (<MESSAGE-LOOP 0>)>>

\ 

"Main message composing and sending loop:
       -1 -- reentering from reader
	0 -- Composing/Editing Level
	1 -- Sending level
	2 -- Editing level (after aborted Send)
"

<DEFINE MESSAGE-LOOP ANOTHER-MSG (CLEVEL)
	#DECL ((ANOTHER-MSG) <SPECIAL ACTIVATION> (CLEVEL) <SPECIAL FIX>)
	<COND (<G=? .CLEVEL 0>
	       <SETG ASK-ME ,MAIL-ASK-ME>
	       <COND (,REMIND <REMIND-HACK>)
		     (,MSG
		      <SETG ASK-ME ,MSG-ASK-ME>
		      <SETG ALWAYSFIELDS ,MSGALWAYS>)
		     (<OR ,BUG ,FEATURE>
		      <SETG SKIP-SUBJECT T>
		      <SETG ALWAYSFIELDS ,BUGALWAYS>
		      <SETG ASK-ME ,BUG-ASK-ME>)
		     (,FORWARD
		      <SETG ASK-ME ,FORWARD-ASK-ME>
		      <SETG ALWAYSFIELDS ,FWDALWAYS>)
		     (,ANSWER
		      <SETG ASK-ME <LIST !,MAIL-ASK-ME>>
		      <COND (<NOT <0? <BUFLENGTH <FBUF ,IN-REPLY-TO>>>>
			     <PUTREST <REST ,ASK-ME>
				      ("IN-REPLY-TO" !<REST ,ASK-ME 2>)>)>
		      <COND (<NOT <0? <BUFLENGTH <FBUF ,CARBON-COPY-TO>>>>
			     <PUTREST ,ASK-ME
				      ("CARBON-COPY-TO" !<REST ,ASK-ME>)>)>
		      <SETG ANSWER <>>)>
	       <SETG CPU-START <TIME>>
	       <SETG CONSOLE-START <ITIME>>)
	      (ELSE <SET CLEVEL 0>)>
	<KLUDGE-IT>>

<DEFINE KLUDGE-IT ()
	<REPEAT LERR\ !-INTERRUPTS (CLOOP)
		#DECL ((LERR\ !-INTERRUPTS CLOOP) <SPECIAL ACTIVATION>)
		<SET CLOOP .LERR\ !-INTERRUPTS>
		<COND (<0? .CLEVEL> <LAZY-MSG ,ASK-ME ,COMPOSING?>)>
		<COND (<1? .CLEVEL>
		       <COND (,JCL-CTRL-C
			      <COND (<SEND-NORMAL>)
				    (ELSE
				     <PROG ((OUTCHAN .OUTCHAN))
					   #DECL ((OUTCHAN) CHANNEL)
					   <CRLF>
					   <PRINC "ERROR">>
				     <SET CLEVEL 2>)>
			      <SETG JCL-CTRL-C <>>)
			     (ELSE <SEND-LOOP>)>)>
		<COND (<==? .CLEVEL 2>
		       <EDIT-LOOP>)>>>

\ 

"Here to initiate another message:
	If MORE-MSGS is T, clears out volatile buffers, sets level to 0 again.
	If MORE-MSGS is <>, QUITs.
"

<DEFINE NEXT-MSG ()
	#DECL ((ANOTHER-MSG) ACTIVATION)
	<SETG COMPOSING? <>>
	<COND (,IN-READER? <RETURN T .ANOTHER-MSG>)
	      (,MORE-MSGS
	       <ALLCLEAR>
	       <INIT-MESSAGE T>
	       <SET CLEVEL 0>
	       <AGAIN .ANOTHER-MSG>)
	      (ELSE <QUIT>)>>

<DEFINE QUITIT ()
	<SETG COMPOSING? <>>
	<COND (,IN-READER? <RETURN <> .ANOTHER-MSG>)
	      (ELSE <QUIT>)>>

"Redo the Message loop at a given level"

<DEFINE GO-TO-LEVEL (N "AUX" CL)
	#DECL ((N) FIX (CL) ANY)
	<SET CLEVEL .N>
	<AND <ASSIGNED? CLOOP>
	     <LEGAL? <SET CL .CLOOP>>
	     <AGAIN .CL>>>

<DEFINE SEND-LEVEL ("OPTIONAL" X Y)
	<GO-TO-LEVEL 1>>

<DEFINE SEND-LOOP ("AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((OUTCHAN) CHANNEL)
	<REPEAT LERR\ !-INTERRUPTS ()
		#DECL ((LERR\ !-INTERRUPTS) <SPECIAL ACTIVATION>)
		<PRINC "A">
		<PROG COMMAND-LOOP-ACTIVATION ()
		      #DECL ((COMMAND-LOOP-ACTIVATION) <SPECIAL ACTIVATION>)
		      <SEND-COMMANDS>>>>

<DEFINE NEXT-LEVEL ("OPTIONAL" X Y)
	#DECL ((CLEVEL) FIX)
	<COND (,IN-READER? <RETURN <> .ANOTHER-MSG>)
	      (<1? .CLEVEL> <SEND-LEVEL>)
	      (ELSE <EDIT-LEVEL>)>>

<DEFINE EDIT-LEVEL ("OPTIONAL" X Y)
	<GO-TO-LEVEL 2>>

<DEFINE EDIT-LOOP ("AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((OUTCHAN) CHANNEL)
	<REPEAT LERR\ !-INTERRUPTS ()
		#DECL ((LERR\ !-INTERRUPTS) <SPECIAL ACTIVATION>)
		<PRINC "A">
		<PROG COMMAND-LOOP-ACTIVATION ()
		      #DECL ((COMMAND-LOOP-ACTIVATION) <SPECIAL ACTIVATION>)
		      <EDIT-COMMANDS>>>>

<DEFINE EDIT-ONCE (BUF CH "AUX" (OUTCHAN .OUTCHAN))
	#DECL ((BUF) BUFFER (CH) CHARACTER (OUTCHAN) CHANNEL)
	<PRINC "A">
	<EDIT-COMMANDS>
	<BUFPRINT .BUF>>

<DEFINE EDIT-SEND (BUF CH "AUX" (OUTCHAN .OUTCHAN))
	#DECL ((BUF) BUFFER (CH) CHARACTER (OUTCHAN) CHANNEL)
	<PRINC "A">
	<EDIT-COMMANDS>
	<GO-TO-LEVEL .CLEVEL>>

\ 

"Initialize buffers and top-level variables"

<DEFINE INIT-MESSAGE ("OPTIONAL" (REINIT <>))
	#DECL ((REINIT) <OR ATOM FALSE>)
	<COND (<NOT .REINIT>		;"one-time initialization"
	       <SETG BUG <>>		;"T if its :BUG"
	       <SETG FEATURE <>>	;"T if its :FEATURE"
	       <SETG REMIND <>>		;"T if its :REMIND"
	       <SETG MSG <>>		;"T if its :MSG"
	       <SETG FORWARD <>>	;"T if its :FORWARD"
	       <SETG CORRECT <>>	;"T if its :CORRECT"
	       <SETG ANSWER <>>)>
	<PUT ,ACK-CONDS 1 <>>
	<PUT ,ACK-CONDS 2 <>>
	<SETG ALWAYSFIELDS ,TOALWAYS>	;"fields that must be included"
	<SETG EXPIRES <>>	;"When a :MSG expires, default one week"
	<SETG SKIP-TO <>>	;"T if To specified in JCL"
	<SETG SKIP-SUBJECT <>>	;"T if Subject to be skipped (as in BUG)"
	<SETG SKIP-MSG-FILE <>>	;"T if MSG file given in JCL"
	<SETG SKIP-MSG-NO <>>
	<SETG JCL-CTRL-C <>>	;"T if ^C encountered on JCL line"
	<SETG JCL-TEXT <>>	;"T if text on JCL line"
	<SETG STIME <>>		;"When to deliver message:  <> ==> ASAP"
	"DONE">

\ 

"**************** AUTOMATIC MESSAGE COMPOSER ************************"

"Simple message sender"

<DEFINE LAZY-MSG (LFLDS PREFER
		  "AUX" (FLDS <VECTOR !.LFLDS>) (MBF ,FIELD-TABLE) X INFO)
	#DECL ((LFLDS) LIST (FLDS) <VECTOR [REST STRING]> (X) STRING
	       (MBF) <UVECTOR [REST VECTOR]> (INFO) <OR FALSE VECTOR>)
	<COND (<SET INFO <MEMBER .PREFER .FLDS>>
	       <SET FLDS .INFO>)>
	<REPEAT ()
		<COND (<EMPTY? .FLDS>
		       <SET CLEVEL 1>
		       <RETURN>)
		      (ELSE <SET X <1 .FLDS>>)>
		<COND (<AND <OR <=? .X "TO"> <=? .X "PROGRAM">> ,SKIP-TO>
		       <SETG SKIP-TO <>>)
		      (<AND <=? .X "SUBJECT"> ,SKIP-SUBJECT>
		       <SETG SKIP-SUBJECT <>>)
		      (<AND <=? .X "MSG-FILE"> ,SKIP-MSG-FILE>
		       <SETG SKIP-MSG-FILE <>>)
		      (<AND <=? .X "MSG-NO"> ,SKIP-MSG-NO>
		       <SETG SKIP-MSG-NO <>>)
		      (<SET INFO <FIELD? .X .MBF>>
		       <SETG COMPOSING? .X>
		       <COND (<PROG COMMAND-LOOP-ACTIVATION ()
			            #DECL ((COMMAND-LOOP-ACTIVATION)
					   <SPECIAL ACTIVATION>)
				    <FAP .INFO T>>)
			     (<N==? .FLDS <TOP .FLDS>>
			      <SET FLDS <BACK .FLDS>>
			      <AGAIN>)>)>
		<SET FLDS <REST .FLDS>>>>

"Back up one in Lazy-MSG"

<DEFINE LAZY-CTRL-R (A B) 
	#DECL ((GETSTRACT) <SPECIAL ACTIVATION>)
	<COND (<REENTER-COMMAND-LOOP>)
	      (<RETURN 0 .GETSTRACT>)>>

<DEFINE FIELD? (STR FT)
	#DECL ((STR) STRING (FT) <UVECTOR [REST VECTOR]> (VALUE) <OR VECTOR FALSE>)
	<MAPF <>
	      <FUNCTION (I)
		   #DECL ((I) VECTOR)
		   <COND (<=? .STR <SPNAME <FLDNM .I>>>
			  <MAPLEAVE .I>)>>
	      .FT>>

\ 

"*********************** 'EDIT' MODE COMMANDS ********************"

"Edit-level commands dispatch to here --
	 Each of these functions is a command handler"

"Exit command mode"

<DEFINE EDIT-FLUSH ()
	<COND (<==? .CLEVEL 2> <SEND-LEVEL>)
	      (ELSE
	       <PROG ((OUTCHAN .OUTCHAN))
		     #DECL ((OUTCHAN) CHANNEL)
		     <PRINC "(Done) ">
		     <CRLF>>)>>

"Here to set ^E function -- either Teco or Imedit"

<DEFINE FLIP-EDITOR ("AUX" EDT FIL (OUTCHAN .OUTCHAN))
	#DECL ((EDT) <LIST [REST STRING]> (FIL) STRING (OUTCHAN) CHANNEL)
	<SET EDT <GET-TEMP "Editor to use" ,DBRKS ,TECO-PROGRAM>>
	<COND (<==? <LENGTH .EDT> 1>
	       <SET FIL <ANYTHING <1 .EDT>>>
	       <SET FIL <UPPERCASE .FIL>>
	       <PRINC "Using TECO (as 'TS ">
	       <PRINC .FIL>
	       <PRINC "')
">
	       <SETG TECO-PROGRAM .FIL>)
	      (ELSE
	       <PRINC
"I can't understand that.  Please type the name of the job to run,
e.g., TECO, T, RMODE, EMACS, etc.
">
	       <>)>>

\ 

"Print out a mail file onto a channel"

<SETG ACK-CONDS (<> <>)>
<GDECL (ACK-CONDS) <LIST [REST <OR FALSE STRING>]>>

<DEFINE PRMAIL ("OPTIONAL" (OUTCHAN .OUTCHAN)) 
	#DECL ((OUTCHAN) <SPECIAL CHANNEL>)
	<COND (<NOT ,FORWARD>
	       <PRINT "WHEN-ORIGINATED">
	       <PRINT <ITIME>>
	       <PRINT "SENDER">
	       <PRINT <XUNAME>>)>
	<MAPF <>
	      <FUNCTION (INFO)
	           #DECL ((INFO) VECTOR)
		   <AND <PFIELD .INFO>
			<APPLY <PFIELD .INFO> .INFO>>>
	      ,FIELD-TABLE>
	<COND (,EXPIRES <PRINT "EXPIRES"> <PRIN1 ,EXPIRES>)>
	<COND (<OR? !,ACK-CONDS>
	       <PRINT "ACKNOWLEDGE">
	       <PRINT <MAPF ,LIST
			    <FUNCTION (S) 
				    #DECL ((S) <OR STRING FALSE>)
				    <COND (<NOT .S> <MAPRET>)
					  (<=? .S "FAILED">
					   <LIST "DELIVERY" ,FAILED 1>)
				          (<LIST .S <> 2>)>>
							 ;"STANDARD ACK FCN #2"
			    ,ACK-CONDS>>)>
	<COND (<NOT ,FORWARD>
	       <PRINT "CONSOLE-MINUTES">
	       <PRINC <- <ITIME> ,CONSOLE-START>>
	       <PRINT "CPU-SECONDS">
	       <PRINC <- <TIME> ,CPU-START>>)>>

\ 

"PTO -- print to-lists; deals with all to-style lists"

<DEFINE PTO (INFO
	     "AUX" TOL BLOL CCTOL (NOTESTO ()) (HAS-TO? T) (OUTCHAN .OUTCHAN)) 
	#DECL ((INFO) VECTOR (FORWTO TOL BLOL CCTOL NOTESTO) LIST
	       (HAS-TO?) <OR ATOM FALSE> (OUTCHAN) CHANNEL)
	<SET TOL <FINDHOSTS ,TO>>
	<COND (<OR ,BUG ,FEATURE>
	       <SET TOL
		    <LIST !.TOL
			  !<FINDHOSTS ,PROGRAM
				      <COND (,BUG "BUG-")
					    (ELSE "FEATURE-")>>>>)> 
	<SET BLOL <FINDHOSTS ,BLIND>>
	<SET CCTOL <FINDHOSTS ,CARBON-COPY-TO>>
	<COND (<NOT <EMPTY? ,NOTES-LIST>>
	       <REPEAT ((NL ,NOTES-LIST) (BEG .NL) A NT)
		       #DECL ((NL) <LIST LIST> (BEG A NT) LIST)
		       <COND (<0? <BUFLENGTH <2 <1 .NL>>>>)
			     (ELSE
		       <PUT ,NOTES ,FBUF <1 <1 .NL>>>
		       <COND (<EMPTY? <SET A <FINDHOSTS ,NOTES>>>)
			     (<COND (<EMPTY? .NOTESTO> <SET NOTESTO .A>)
				    (ELSE <PUTREST .NT .A>)>
			      <SET NT <REST .A <- <LENGTH .A> 1>>>)>)>
		       <COND (<==? <SET NL <REST .NL>> .BEG> <RETURN>)>>)>
	<COND (<AND ,FORWARD <NOT <EMPTY? .TOL>>>
	       <PFORWARD .TOL .NOTESTO>)
	      (<NOT <AND <EMPTY? .TOL>
			 <EMPTY? .CCTOL>
			 <EMPTY? .BLOL>
			 <EMPTY? .NOTESTO>>>
	       <PRINT <SPNAME <FLDNM .INFO>>>
	       <CRLF>
	       <PRINC !\(>
	       <PUNIQUE !.TOL !.CCTOL !.BLOL !.NOTESTO>
	       <PRINC !\)>)
	      (ELSE <SET HAS-TO? <>>)>
	<COND (<AND <NOT ,FORWARD> <NOT <EMPTY? .TOL>>>
	       <PRINT "ACTION-TO">
	       <PRINT .TOL>)>
	<COND (<NOT <EMPTY? .CCTOL>> <PRINT "CARBON-COPY-TO"> <PRINT .CCTOL>)>
	<COND (<NOT <EMPTY? .BLOL>>
	       <PRINT "BLIND">
	       <PRINT <MAPF ,LIST
			    <FUNCTION (A)
				      #DECL ((A) STRING)
				      ((.A) (.A))>
			    .BLOL>>)>
	<COND (,CORRECT
	       <PRINT "EMERGENCY">
	       <PRINT '("CORRECTION")>)
	      (.HAS-TO?
	       <COND (<AND ,REMIND ,STIME>
		      <PRINT '"REMIND">
		      <PRIN1 ,STIME>)>
	       <CRLF>
	       <PRINC "\"SCHEDULE\" (\"SENDING\"">
	       <PRINC !\)>)>>

\

<DEFINE PFROM (INFO "AUX" (X <XUNAME>) FR L F S UNDER?)
     #DECL ((INFO) VECTOR (FR) BUFFER (L) <LIST [REST STRING]>
	    (UNDER?) <OR ATOM FALSE> (X F S) STRING)
     <SET UNDER?
	  <AND <==? <1 .X> !\_>
	       <==? <2 .X> !\_>
	       <==? <3 .X> !\_>>>
     <REPEAT ()
	     <COND (<AND .UNDER?
			 <SET L <BUFLEX <SET FR <FBUF .INFO>>>>
			 <NOT <EMPTY? .L>>
			 <SET F <1 .L>>
			 <==? <1 .F> !\_>
			 <==? <2 .F> !\_>
			 <==? <3 .F> !\_>>
		    <SET S 
			 <CORRECT-ADDRESS <PR1 .INFO>
					  "You must give your name instead of"
					  .F
					  "Real name">>
		    <PUT .L 1 .S>
		    <REMAKE .FR .L>)
		   (ELSE
		    <PONE .INFO>
		    <RETURN>)>>>

\

"PFORWARD -- print special to-list for forwarding message"

<DEFINE PFORWARD (TOL NOTESTO "AUX" (OUTCHAN .OUTCHAN) X)
	#DECL ((TOL NOTESTO) LIST (OUTCHAN) CHANNEL (X) STRING)
	<PRINT "MORE-TO">
	<CRLF>
	<PRINC !\(>
	<PUNIQUE !.TOL !.NOTESTO>
	<PRINC !\)>
	<CRLF>
	<COND (<NOT ,CORRECT>
	       <PRINC "(\"FORWARDING\" \"APPEND\")">
	       <CRLF>
	       <PRINC "(((">
	       <PRIN1 <SET X <XUNAME>>>
	       <PRINC !\ >
	       <PUNIQUE !.TOL !.NOTESTO>
	       <PRINC ") ((">
	       <PRIN1 .X>
	       <PRINC !\ >
	       <PRIN1 .TOL>
	       <PRINC !\ >
	       <PRIN1 <ITIME>>
	       <PRINC "))))">)>>

<DEFINE PMSG-FILE (INFO "AUX" (BUF <FBUF .INFO>)) 
	#DECL ((INFO) VECTOR (BUF) BUFFER)
	<COND (<NOT <EMPTY-FIELD .INFO>>
	       <PROG ((OUTCHAN .OUTCHAN))
		     #DECL ((OUTCHAN) CHANNEL)
		     <PRINT "MSG-FILE">
		     <BUFSPRINT .BUF>>)>>

\ 

"Printers for fields which are message ids"

<DEFINE PIDS (INFO "AUX" X (OUTCHAN .OUTCHAN)) 
	#DECL ((INFO) VECTOR (X) <OR FALSE <LIST [REST STRING]>> (OUTCHAN) CHANNEL)
	<COND (<SET X <FINDIDS .INFO>> 
	       <PRINT <SPNAME <FLDNM .INFO>>>
	       <PRINC .X>)>>

<DEFINE PID (INFO "AUX" X (OUTCHAN .OUTCHAN)) 
	#DECL ((INFO) VECTOR (X) <OR FALSE <LIST [REST STRING]>> (OUTCHAN) CHANNEL)
	<COND (<AND <SET X <FINDIDS .INFO>>
		    <==? <LENGTH? .X 1> 1>>
	       <PRINT <SPNAME <FLDNM .INFO>>>
	       <PRINC <1 .X>>)>>

<DEFINE FINDIDS (INFO "OPTIONAL" (P? T) "AUX" (BUF <FBUF .INFO>) XX) 
	#DECL ((INFO) VECTOR (BUF) BUFFER (XX) <LIST [REST STRING]>
	       (P?) <OR ATOM FALSE>)
	<PROG ()
	      <COND (<OR <0? <BUFLENGTH .BUF>>
			 <EMPTY? <SET XX <BUFLEX .BUF>>>>
		     <>)
		    (<MAPR <>
			   <FUNCTION (X "AUX" S)
				#DECL ((X) <LIST [REST STRING]>
				       (S) <OR STRING FALSE>)
				<COND (<CHECK-FIX <1 .X>>)
				      (ELSE
				       <SET S <CORRECT-ADDRESS
					          <AND .P? <PR1 .INFO>>
						  "Message id is not a number"
						  <1 .X>
						  "Message id">>
				       <PUT .X 1 .S>
				       <REMAKE .BUF .XX>
				       <MAPLEAVE <>>)>>
			   .XX>
		     .XX)
		    (ELSE <AGAIN>)>>>

<DEFINE CHECK-FIX (S)
	#DECL ((S) STRING)
	<MAPF <>
	      <FUNCTION (C)
		   #DECL ((C) CHARACTER)
		   <COND (<AND <G=? <ASCII .C> <ASCII !\0>>
			       <L=? <ASCII .C> <ASCII !\9>>>)
			 (ELSE <MAPLEAVE <>>)>>
	      .S>>

\

"General message field printers for various sorts of fields"

<DEFINE PUNIQUE ("TUPLE" TL "AUX" (OUTCHAN .OUTCHAN))
	#DECL ((TL) <TUPLE [REST STRING]> (OUTCHAN) CHANNEL)
	<MAPR <>
	      <FUNCTION (A "AUX" (A1 <1 .A>))
		   #DECL ((A) <TUPLE [REST STRING]> (A1) STRING)
		   <COND (<NOT <MEMBER .A1 <REST .A>>>
			  <PRIN1 .A1> <PRINC !\ >)>>
	      .TL>>

<DEFINE PSTR (INFO "AUX" (BUF <FBUF .INFO>)) 
	#DECL ((INFO) VECTOR (BUF) BUFFER)
	<COND (<0? <BUFLENGTH .BUF>>)
	      (ELSE
	       <PRINT <SPNAME <FLDNM .INFO>>>
	       <BUFSPRINT .BUF>)>>

<DEFINE PLST (INFO "AUX" (BUF <FBUF .INFO>)) 
	#DECL ((INFO) VECTOR (BUF) BUFFER)
	<COND (<0? <BUFLENGTH .BUF>>)
	      (<PROG ((OUTCHAN .OUTCHAN))
		     #DECL ((OUTCHAN) CHANNEL)
	       <PRINT <SPNAME <FLDNM .INFO>>>
	       <PRINT <BUFLEX .BUF>>>)>>

<DEFINE PONE (INFO "AUX" (BUF <FBUF .INFO>) L)
	#DECL ((INFO) VECTOR (BUF) BUFFER (L) <LIST [REST STRING]>)
	<COND (<OR <0? <BUFLENGTH .BUF>>
		   <EMPTY? <SET L <BUFLEX .BUF>>>>)
	      (<PROG ((OUTCHAN .OUTCHAN))
		     #DECL ((OUTCHAN) CHANNEL)
	       <PRINT <SPNAME <FLDNM .INFO>>>
	       <PRINT <1 .L>>>)>>
\ 

"Printers for specific sorts of fields"

<DEFINE PSUBJ (INFO
	       "AUX" (SBUF <FBUF .INFO>) (BEMPTY? <0? <BUFLENGTH .SBUF>>)
		     (TOBUF <FBUF ,TO>) (PBUF <FBUF ,PROGRAM>))
	#DECL ((INFO) VECTOR (SBUF TOBUF PBUF) BUFFER
	       (BEMPTY?) <OR ATOM FALSE>)
	<COND (<AND .BEMPTY? <OR ,BUG ,FEATURE ,REMIND>>
	       <COND (<OR ,BUG ,FEATURE>
		      <ADDSTRING .SBUF <COND (,BUG "BUG")(ELSE "FEATURE")>>
		      <COND (<NOT <0? <BUFLENGTH .PBUF>>>
			     <ADDSTRING .SBUF " => ">
			     <ADDSTRING .SBUF <1 .PBUF> <BUFLENGTH .PBUF>>)>)
		     (,REMIND
		      <ADDSTRING .SBUF "REMINDER">
		      <COND (<NOT <0? <BUFLENGTH .TOBUF>>>
			     <ADDSTRING .SBUF
					" for "
					<1 .TOBUF>
					<BUFLENGTH .TOBUF>>)>)>
	       <SET BEMPTY? <>>)>
	<COND (<NOT .BEMPTY?>
	       <PRINT <SPNAME <FLDNM .INFO>>>
	       <BUFSPRINT .SBUF>)>>

<DEFINE PEXPUSING (INFO)
	#DECL ((INFO) VECTOR)
	<PEXPAND <GET-FILES .INFO>>>

<DEFINE PEXPAND (LF)
	#DECL ((LF) <LIST [REST STRING]>)
	<REPEAT ()
		<COND (<EMPTY? .LF> <RETURN>)
		      (<PROG ((OUTCHAN .OUTCHAN))
			     #DECL ((OUTCHAN) CHANNEL)
			     <PRINT '("EXPAND-USING" "ADD")>
			     <PRINT <1 .LF>>>)>
		<SET LF <REST .LF>>>>


"The notes list consists of a list of two element lists.  Each of
the two elements is a buffer.  The first is the addressee buffer,
the second the text buffer.  NOTE!!!!! The list is circular, with
the current last buffer edited being the pointer into it.  BE
CAREFUL GROVELLING OVER THIS CROCK!!!!!!! "

<DEFINE PNOTES (INFO "AUX" (NL ,NOTES-LIST) (BEG .NL) (PL ()) AL N P
		(OUTCHAN .OUTCHAN) ANN) 
	#DECL ((INFO) VECTOR (NL BEG) LIST (OUTCHAN) CHANNEL
	       (PL) <LIST [REST <OR STRING LIST> LIST]>
	       (AL) <LIST [REST STRING]> (N) <LIST BUFFER BUFFER>
	       (ANN) <OR FALSE BUFFER> (P) <OR FALSE LIST>)
	<PROG ()
	      <COND (<AND <EMPTY? .NL>
			  <0? <BUFLENGTH <SET ANN <FBUF ,ANNOTATION>>>>>
		     <RETURN>)>
	      <COND (<EMPTY? .NL>)
		    (<==? .BEG <REST .NL>>
		     <COND (<0? <BUFLENGTH <2 <SET N <1 .BEG>>>>>)
			   (ELSE
			    <PUT .INFO ,FBUF <1 .N>>
			    <SET PL (<FINDHOSTS .INFO> (<2 .N>))>)>)
		    (<REPEAT ()
			     <SET NL <REST .NL>>
			     <COND (<0? <BUFLENGTH <2 <SET N <1 .NL>>>>>)
				   (ELSE
			     <PUT .INFO ,FBUF <1 .N>>
			     <SET AL <FINDHOSTS .INFO>>
			     <MAPF <>
				   <FUNCTION (A) 
					#DECL ((A) STRING)
					<COND (<SET P <MEMBER .A .PL>>
					       <PUT .P 2 (<2 .N> !<2 .P>)>)
					      (<SET PL (.A (<2 .N>) !.PL)>)>>
				   .AL>)>
			     <COND (<==? .NL .BEG> <RETURN>)>>)>
	      <COND (<AND <EMPTY? .PL> <NOT .ANN>>
		     <RETURN>)>
	      <CRLF>
	      <AND ,FORWARD <PRINC !\(>>
	      <PRIN1 <SPNAME <FLDNM .INFO>>>
	      <AND ,FORWARD <PRINC " \"APPEND\")">>
	      <CRLF>
	      <PRINC !\(>
	      <COND (.ANN
		     <PRINC !\(>
		     <PRIN1 (<XUNAME> !<FINDHOSTS ,TO>)>
		     <CRLF>
		     <PRINC !\(>
		     <PRINC "\"[From ">
		     <PRINC <XUNAME>>
		     <PRINC "]\" ">
		     <CRLF>
		     <BUFSPRINT!-BUF!-PACKAGE .ANN>
		     <PRINC "))">)>
	      <REPEAT (P1)
		      #DECL ((P1) LIST)
		      <COND (<EMPTY? .PL> <PRINC !\)> <CRLF> <RETURN>)>
		      <COND (<TYPE? <1 .PL> LIST> <SET P1 <1 .PL>>)
			    (ELSE <SET P1 (<1 .PL>)>)>
		      <COND (<SET P <NEMBER <2 .PL> <REST .PL 2>>>
			     <COND (<TYPE? <1 .P> LIST>
				    <PUT .P 1 (!.P1 !<1 .P>)>)
				   (ELSE <PUT .P 1 (<1 .P> !.P1)>)>)
			    (ELSE
			     <CRLF>
			     <PRINC !\(>
			     <PRIN1 <COND (,FORWARD (<XUNAME> !.P1))
					  (ELSE .P1)>>
			     <CRLF>
			     <PRINC !\(>
			     <COND (,FORWARD
				    <PRINC "\"[From ">
				    <PRINC <XUNAME>>
				    <PRINC "]\" ">)>
			     <MAPF <> ,BUFSPRINT!-BUF!-PACKAGE <2 .PL>>
			     <PRINC "))">)>
		      <SET PL <REST .PL 2>>>>>

"Pseudo-MEMBER for notes list.  Check for a message entry that
is like the one we have.  Like means same length and notes
buffers in it.  Message entries are even numbered elements of
the structure and consist of lists of buffers."

<DEFINE NEMBER (X S "AUX" M (LX <LENGTH .X>))
	#DECL ((LX) FIX (S) <LIST [REST ANY <LIST [REST BUFFER]>]>
	       (VALUE) <OR FALSE LIST> (X M) <LIST [REST BUFFER]>)
	<REPEAT ()
		<COND (<EMPTY? .S> <RETURN <>>)>
		<SET M <2 .S>>
		<AND <==? .LX <LENGTH .M>>
		     <MAPF <>
			   <FUNCTION (M1 X1)
				     #DECL ((M1 X1) BUFFER)
				     <COND (<==? .M1 .X1>)
					   (ELSE <MAPLEAVE <>>)>>
			   .M .X>
		     <RETURN .S>>
		<SET S <REST .S 2>>>>

\ 

<DEFINE FNAME (STR "AUX" (CH <CHANNEL "READ" .STR>))
    #DECL ((STR) STRING (CH) CHANNEL)
    <STRING <7 .CH> !\  <8 .CH> !\  <9 .CH> !\: <10 .CH> !\;>>

<DEFINE PENCLOSURES (INFO "AUX" (FL <GET-FILES .INFO>))
	#DECL ((FL) <LIST [REST STRING]> (INFO) VECTOR)
	<COND (<EMPTY? .FL>)
	      (<PROG ((OUTCHAN .OUTCHAN))
		     #DECL ((OUTCHAN) CHANNEL)
	       <PRINT <SPNAME <FLDNM .INFO>>>
	       <PRINC !\(>
	       <MAPF <>
		     <FUNCTION (X "AUX" C)
			  #DECL ((X) STRING (C) <OR CHANNEL FALSE>)
			  <COND (<SET C <CHANNEL "READ" <UPPERCASE .X>>>
				 <PRINC !\[>
				 <PRIN1 <7 .C>>
				 <PRINC !\ >
				 <PRIN1 <8 .C>>
				 <PRINC !\ >
				 <PRIN1 <9 .C>>
				 <PRINC !\ >
				 <PRIN1 <10 .C>>
				 <PRINC !\]>
				 <CRLF>)>>
		     .FL>
	       <PRINC !\)>>)>>

<DEFINE PFILE-OUTPUT (INFO)
	#DECL ((INFO) VECTOR)
	<PFILES <GET-FILES .INFO <>>>>

<DEFINE PFILES (FL)
    #DECL ((FL) <LIST [REST STRING]>)
    <COND (<EMPTY? .FL>)
	  (ELSE
	   <PROG ((OUTCHAN .OUTCHAN))
		 #DECL ((OUTCHAN) CHANNEL)
		 <PRINT "SCHEDULE">
	   <PRINT '("FILE-OUTPUT" #FALSE ())>
	   <PRINT '("AUTHOR-FILE-OUTPUT" "APPEND")>
	   <PRINC !\(>
	   <MAPF <>
		<FUNCTION (X)
		    #DECL ((X) STRING)
		    <TERPRI>
		    <PRINC !\(>
		    <PRIN1 <FNAME .X>>
		    <PRINC !\ >
		    <PRIN1 "APPEND">
		    <PRINC !\)>>
		.FL>
	   <PRINC !\)>
	   <TERPRI>>)>>

"Returns a LIST of File names for FILE-OUTPUT"

<DEFINE GET-FILES (INFO "OPTIONAL" (EXIST? T) "AUX" (BF <FBUF .INFO>)) 
	#DECL ((EXIST?) <OR ATOM FALSE> (VALUE) <LIST [REST STRING]>
	       (INFO) VECTOR (BF) BUFFER)
	<MAPF ,LIST
	      <FUNCTION (S "AUX" R)
		  #DECL ((S) STRING (R) <OR ATOM <FALSE STRING>>)
		  <PROG ()
			<COND (<NOT <GOOD-FILE-NAME? .S>>
			       <SET S <CORRECT-ADDRESS <PR1 .INFO>
						       "File name incomprehensible?"
						       .S
						       "File"
						       <>
						       ,FILEBRKS>>
			       <AGAIN>)
			      (<AND .EXIST? <NOT <SET R <FILE-EXISTS? .S>>>>
			       <SET S <CORRECT-ADDRESS <PR1 .INFO>
						       <1 .R>
						       .S
						       "File"
						       <>
						       ,FILEBRKS>>
			       <AGAIN>)
			      (ELSE .S)>>>
	      <BUFLEX .BF ,FILEBRKS>>>

<SETG FILEBRKS ",
">

<GDECL (FILEBRKS) STRING>

<DEFINE GOOD-FILE-NAME? (ST "AUX" (SP 0) (CL 0) (SM 0) C)
	#DECL ((ST) <OR FALSE STRING> (SP CL SM) FIX (C) CHARACTER)
	<COND (<ANYTHING .ST>
	       <REPEAT ()
		       <COND (<OR <NOT .ST> <EMPTY? .ST>>
			      <RETURN <AND <L? .CL 2> <L? .SM 2> <L? .SP 2>>>)
			     (<AND <==? <SET C <1 .ST>> !\> <NOT <LENGTH? .ST 2>>>
			      <SET ST <REST .ST 2>>)
			     (<==? .C !\ >
			      <SET SP <+ .SP 1>>
			      <SET ST <ANYTHING <REST .ST>>>)
			     (<==? .C !\:>
			      <SET CL <+ .CL 1>>
			      <SET ST <ANYTHING <REST .ST>>>)
			     (<==? .C !\;>
			      <SET SM <+ .SM 1>>
			      <SET ST <ANYTHING <REST .ST>>>)
			     (ELSE <SET ST <REST .ST>>)>>)>>

\ 

"Buffer parser"

<DEFINE BUFLEX (BF
		"OPTIONAL" (BRKS ,TOBRKS) (ENDS "")
		"AUX" (BAL <>) (LL ("")) (L .LL) (S <1 .BF>) (S1 .S)
		(SX <2 .BF>) ST (Q? <NOT <MEMQ !\/ .BRKS>>)
		(ADR? <OR <==? .BRKS ,JCLBRKS> <==? .BRKS ,TOBRKS>>) C CC)
   #DECL ((BF) BUFFER (C ST) <OR STRING FALSE> (S S1 SX BRKS ENDS CC) STRING
	  (BAL Q?) <OR ATOM FALSE> (VALUE) <OR FALSE LIST>
	  (ADR?) <OR FALSE ATOM> (LL L) <LIST [REST STRING]>)
   <REPEAT ()
	   <COND (<AND .ADR?
		       <G? <LENGTH .S1> <LENGTH .SX>>
		       <OR <AND <MEMQ <1 .S1> " 	">
				<SET C <ANYTHING .S1 .SX>>
				<MEMQ <1 .C> "@%">>
			   <MEMQ <1 <SET C .S1>> "@%">>>
		  <SET S1 .C>
		  <AND <SET C <ANYTHING <REST .S1> .SX>>
		       <SET S1 .C>>
		  <AGAIN>)>
	   <COND (<OR <==? <LENGTH .S1> <LENGTH .SX>>
		      <MEMQ <1 .S1> .BRKS>
		      <MEMQ <1 .S1> .ENDS>
		      <AND .Q? <==? <1 .S1> !\/>>>
		  <AND <N==? .S .S1>
		       <PUTREST .L
				<SET L
				     (<CONSTRUC .S .S1 .ADR?>)>>>
		  <COND (<==? <LENGTH .S1> <LENGTH .SX>>
			 <RETURN <REST .LL>>)
			(<MEMQ <1 .S1> .ENDS>
			 <COND (<AND <SET ST <ANYTHING .S1 .SX>>
				     <SET S1 .ST>
				     <NOT <AND .Q? <==? <1 .S1> !\/>>>>
				<SET CC <SUBSTRUC .S1 0 <- <LENGTH .S1> <LENGTH .SX>>>>
				<COND (<EMPTY? .CC> <RETURN <REST .LL>>)
				      (ELSE
				       <PUT .LL 1 .CC>
				       <RETURN <CHTYPE .LL FALSE>>)>)>)>
		  <SET BAL <>>
		  <SET S <COND (<AND .Q? <==? <1 .S1> !\/>> .S1)(<REST .S1>)>>)
		 (<==? <1 .S1> %<ASCII *134*>> <SET S1 <REST .S1>>)>
	   <COND (<AND <NOT .BAL>
		       <NOT <EMPTY? .S>>
		       <SET C <MEMQ <1 .S> "([{">>
		       <SET C <BALANCED? .S .SX>>>
		  <SET S1 .C>
		  <SET BAL T>)>
	   <OR <EMPTY? .S1> <SET S1 <REST .S1>>>>>

<DEFINE CONSTRUC (S S1 ADR? "AUX" TMP (AT? <>))
	#DECL ((S S1) STRING (ADR? AT?) <OR ATOM FALSE>
	       (TMP) <OR FALSE STRING>)
	<MAPR ,STRING
	      <FUNCTION (ST "AUX" (C <1 .ST>))
		   #DECL ((ST) STRING (C) CHARACTER)
		   <COND (<==? .ST .S1> <MAPSTOP>)
			 (<AND .ADR? <MEMQ .C "@%">>
			  <SET AT? T>
			  <MAPRET !\@>)
			 (<AND .ADR?
			       <MEMQ .C " 	">
			       <SET TMP <ANYTHING .ST .S1>>
			       <OR .AT? <MEMQ <1 .TMP> "@%">>>
			  <MAPRET>)
			 (<==? .C %<ASCII *134*>> <MAPRET>)
			 (ELSE <SET AT? <>> <MAPRET .C>)>>
	      .S>>

<DEFINE BALANCED? (L "OPTIONAL" (R <REST .L <LENGTH .L>>)
		   "AUX" (OP <STRSRC <REST .L> "([{">) (BR <1 .L>) RB CL)
	#DECL ((R) STRING (L) STRING (OP CL VALUE) <OR STRING FALSE>
	       (BR RB) CHARACTER)
	<REPEAT ((L .L))
		#DECL ((L) STRING)
		<COND (<SET CL <MEMQ <SET RB <COND (<==? .BR !\(> !\))
						   (<==? .BR !\[> !\])
						   (<==? .BR !\{> !\})>>
				     <REST .L>>>
		       <AND <N==? <1 <BACK .CL>> %<ASCII *134*>>
			    <RETURN T>>
		       <SET L .CL>)
		      (<RETURN <>>)>>
	<COND (<OR <NOT .OP> <AND .CL <L? <LENGTH .OP> <LENGTH .CL>>>>
	       <AND <G? <LENGTH .CL> <LENGTH .R>> .CL>)
	      (.CL
	       <AND <SET L <BALANCED? .OP .R>>
		    <MEMQ .RB <REST .L>>>)>>

<DEFINE ADDBREAK (BF CHR) 
	#DECL ((VALUE BF) BUFFER (CHR) CHARACTER)
	<COND (<OR <==? <LENGTH <1 .BF>> <LENGTH <2 .BF>>>	    ;"nothing in buffer"
		   <MEMQ <1 <BACK <2 .BF>>> ,KEYBREAKS>>
	       .BF)					       ;"already broken"
	      (<ADDCHR .BF .CHR>)>>

<DEFINE MAILCRLF (BF CHR)
	#DECL ((BF) BUFFER (CHR) CHARACTER (OUTCHAN) CHANNEL)
	<COND (<BUF-BITS .BF 35>	;"terminate on crlf"
	       <PUT .OUTCHAN 14 0>
	       <RETURN .BF .GETSTRACT>)
	      (ELSE <ADDCRLF .BF .CHR>)>>

<DEFINE RETBUF (BF CHR)
	#DECL ((BF) BUFFER (CH) CHARACTER)
	<PRINC .CHR>
	<PUT .OUTCHAN 14 1>
	<RETURN .BF .GETSTRACT>>

"Keyword extractors"

<DEFINE KEYWEX (BUF CHR
		"AUX" (BST ,KEYBREAKS) (IK <FBUF ,KEYWORDS>) (L <BUFLENGTH .BUF>)
		      (BB <2 .BUF>) CH)
	#DECL ((BUF VALUE IK) BUFFER (CHR CH) CHARACTER (BST BB) STRING (L) FIX)
	<COND (<0? .L> .BUF)
	      (ELSE
	       <REPEAT ((LC .L))
		       #DECL ((LC) FIX)
		       <SET CH <1 <SET BB <BACK .BB>>>>
		       <COND (<MEMQ .CH .BST>
			      <ADDBREAK .IK !\ >			   ;"sp"
			      <ADDSTRING .IK
					 <REST .BB>
					 <- <LENGTH .BB> <LENGTH <2 .BUF>> 1>>
			      <RETURN .BUF>)
			     (<0? <SET LC <- .LC 1>>>
			      <ADDBREAK .IK !\ >
			      <ADDSTRING .IK .BB .L>
			      <RETURN .BUF>)>>)>>

\ 

"Sending methods"

<DEFINE SEND-NORMAL ()
	<AND <SENDER> <NEXT-MSG>>>
	
<DEFINE SEND-TO-FILE ("AUX" (OUTCHAN .OUTCHAN) FIL)
	#DECL ((OUTCHAN) CHANNEL (FIL) STRING)
	<SET FIL <GET-TEMP "File to write to" <> <STRING <SNAME> ";M >">>>
	<COND
	 (<EMPTY? .FIL> <PRINC "[Aborted]"> <CRLF>)
	 (ELSE <SENDER .FIL <>>)>
	T>

"Return T because we don't want to go to command level"

<DEFINE SEND-TTY ("AUX" (OUTCHAN .OUTCHAN))
	#DECL ((OUTCHAN) CHANNEL)
	<SENDER <> <>>
	<CRLF>
	T>

\ 

<DEFINE EMPTY-FIELD (INFO) 
	#DECL ((INFO) VECTOR)
	<0? <BUFLENGTH <FBUF .INFO>>>>

<DEFINE SENDER ("OPTIONAL" (FILE ,IFILE) (ALL? T)
		"AUX" CH (OUTCHAN .OUTCHAN))
	#DECL ((ALL?) <OR FALSE ATOM> (CH) <OR FALSE CHANNEL> (OUTCHAN) CHANNEL
	       (FILE) <OR FALSE <VECTOR [REST STRING]> STRING>)
	<MAPF <>
	      <FUNCTION (F "AUX" (INFO ,.F)) 
			#DECL ((F) ATOM (INFO) VECTOR)
			<COND (<EMPTY-FIELD .INFO>
			       <TERPRI>
			       <PRINC !\'>
			       <PRINC <PR1 .INFO>>
			       <PRINC "' empty? Specify it before sending.">
			       <EDIT-LEVEL>)>>
	      ,ALWAYSFIELDS>
	<COND (<NOT .FILE>
	       <SET CH .OUTCHAN>)
	      (<SET CH
		    <COND (<TYPE? .FILE STRING> <OPEN "PRINT" .FILE>)
			  (ELSE <OPEN "PRINT" !.FILE>)>>)
	      (ELSE
	       <OPEN-FAILED .CH .FILE>
	       <EDIT-LEVEL>)>
	<PRMAIL .CH>
	<AND .FILE <CLOSE .CH>>
	<COND (<AND .ALL? <NOT ,JCL-CTRL-C>>
	       <DEMSIG "COMSYS">)>
	<CRLF>
	"SENT">

"Beautiful error messages"

<DEFINE OPEN-FAILED (CH FILE "AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((CH) FALSE (FILE) ANY (OUTCHAN) CHANNEL)
	<TERPRI>
	<PRINC "Open of ">
	<PRINC .FILE>
	<PRINC " failed">
	<PRINC <COND (<LENGTH? .CH 1> <PRINC ": "> <1 .CH>) (!\.)>>
	<TERPRI>>

\ 

"***********************JCL LINE INTERPRETATION***********************"

<DEFINE ANYTHING (STR "OPTIONAL" (STEND <>)) 
	#DECL ((STR) STRING (VALUE STEND) <OR STRING FALSE>)
	<MAPR <>
	      <FUNCTION (X)
			#DECL ((X) STRING)
			<COND (<==? .X .STEND> <MAPLEAVE <>>)
			      (<G? <ASCII <1 .X>> 32> <MAPLEAVE .X>)>>
	      .STR>>

<SETG JCLBRKS ",">
<GDECL (JCLBRKS) STRING>

<DEFINE HACK-JCL (STR
		  "OPTIONAL" (ENDS " 	î")
		  "AUX" (X <ANYTHING .STR>) L LX TRM (TMP <FBUF ,TEMPORARY>)
			(TBUF <FBUF ,TEXT>) (TOBUF <FBUF ,TO>)
			(PROGRAM <FBUF ,PROGRAM>) (MSGBUF <FBUF ,MSG-FILE>))
	#DECL ((STR ENDS) STRING (X) <OR FALSE STRING> (TRM) CHARACTER
	       (L) <OR <FALSE [REST STRING]> <LIST [REST STRING]>>
	       (PROGRAM TMP TBUF TOBUF MSGBUF) BUFFER (LX) FIX)
	<PROG ()
	      <COND (<OR <NOT .X> <EMPTY? .X>> <RETURN <>>)>
	      <BUFCLEAR .TMP>
	      <ADDSTRING .TMP .X>
	      <COND (<NOT <SET L <BUFLEX .TMP ,JCLBRKS .ENDS>>>
		     <SET LX <LENGTH <SET X <1 .L>>>>
		     <SET L <REST .L>>
		     <SET TRM <1 <REST .X <- .LX 1>>>>
		     <COND (,MSG
			    <ADDSTRING <FBUF ,SUBJECT> .X <- .LX 1>>)
			   (ELSE
			    <ADDSTRING .TBUF .X <- .LX 1> ,EOL>
			    <SETG JCL-TEXT T>
			    <COND (<OR <==? <ASCII 3> .TRM>
				       <==? <ASCII *37*> .TRM>>
				   <SETG JCL-CTRL-C T>)
				  (ELSE <SETG JCL-CTRL-C <>>)>)>
		     <SETG SKIP-SUBJECT T>)>
	      <MAPR <>
		    <FUNCTION (XX "AUX" (X <1 .XX>) (XEND <LENGTH? .XX 1>)) 
			 #DECL ((X) STRING (XX) LIST (XEND) <OR FALSE FIX>)
			 <COND (<==? <1 .X> !\/> <FLAG-HACK <REST .X>>)
			       (,BUG
				<SETG SKIP-TO T>
				<ADDSTRING .PROGRAM .X>
				<OR .XEND <ADDCHR .PROGRAM !\,>>)
			       (,FEATURE
				<SETG SKIP-TO T>
				<ADDSTRING .PROGRAM .X>
				<OR .XEND <ADDCHR .PROGRAM !\,>>)
			       (,MSG
				<ADDSTRING .MSGBUF .X>
				<SETG SKIP-MSG-FILE T>)
			       (ELSE
				<SETG SKIP-TO T>
				<ADDADDR .TOBUF .X>
				<OR .XEND <ADDCHR .TOBUF !\,>>)>>
		    .L>>>

"Search a string for a 'winner' or a 'loser'.  If a loser is
found return #FALSE(loser)."

<DEFINE STRSRC (STR TERM "OPTIONAL" (CTRLOSS <>))
	#DECL ((STR TERM) STRING (CTRLOSS) <OR ATOM FALSE>)
	<REPEAT ()
		<COND (<EMPTY? .STR> <RETURN <>>)
		      (<MEMQ <1 .STR> .TERM> <RETURN .STR>)
		      (<AND .CTRLOSS <L=? <ASCII <1 .STR>> 32>>
		       <RETURN .STR>)>
		<SET STR <REST .STR>>>>

\ 

"******SWITCH HACKERY*******"

<DEFINE SWITCH-HACK ("AUX" JCL)
	#DECL ((JCL) STRING)
	<SET JCL <GET-TEMP "JCL switches" <>>>
	<COND (<EMPTY? .JCL>)
	      (ELSE
	       <SETG ACK-CONDS ()>
	       <FLAG-HACK .JCL>)>>

<DEFINE FLAG-HACK (X "AUX" X1)
	#DECL ((X) STRING (X1) CHARACTER)
	<REPEAT ()
		<COND (<EMPTY? .X> <RETURN .X>)
		      (<AND <G? <ASCII <SET X1 <1 .X>>> *140*>
			    <L? <ASCII .X1> *173*>>
		       <SET X1 <ASCII <- <ASCII .X1> 32>>>)>
		<COND (<OR <MEMQ .X1 "/ ,">
			   <L? <ASCII .X1> 32>>
		       <RETURN <REST .X>>)
		      (<==? .X1 !\L>
		       <LOAD-FROM-FILE>)
		      (<==? .X1 !\D> <ACK-DELIVERY>)
		      (<==? .X1 !\F> <FAIL-HACK>)
		      (<==? .X1 !\C> <SETG FORWARD T> <SETG CORRECT T>)
		      (<OR <==? .X1 !\M> <==? .X1 !\#>>
		       <SETG FORWARD T>)
		      (ELSE
		       <PROG ((OUTCHAN .OUTCHAN))
			     #DECL ((OUTCHAN) CHANNEL)
			     <CRLF>
		       <PRINC "Uninterpreted switch ignored:  ">
		       <PRINC .X1>>)>
		<SET X <REST .X>>>>

\ 

"***************************APPEND TO NOTES****************************"

"Special routine to hack notes fields"

<DEFINE HACK-NOTES ("OPTIONAL" (NEW? <>)
		    "AUX" NL N (NADD ,NOTES) (NTXT ,NOTE-TEXT) (NLEVEL 0))
   #DECL ((NEW?) ANY (NL N) LIST (NLEVEL) <SPECIAL FIX> (NADD NTXT) VECTOR)
   <UNWIND
    <PROG NOTES-LOOP ()
      #DECL ((NOTES-LOOP) <SPECIAL ACTIVATION>)
      <SET NL ,NOTES-LIST>
      <COND (<OR .NEW? <EMPTY? .NL>>
	     <SET NEW? <>>				  ;"watch out for AGAIN"
	     <SET N (<INIT-BUF .NADD> <INIT-BUF .NTXT>)>
	     <COND (<EMPTY? .NL> <PUTREST <SET NL (.N)> .NL>)
		   (ELSE <PUTREST .NL <SET NL (.N !<REST .NL>)>>)>
	     <SETG NOTES-LIST .NL>)
	    (ELSE <SET N <1 .NL>>)>
      <PUT .NADD ,FBUF <1 .N>>
      <PUT .NTXT ,FBUF <2 .N>>
      <NOTING T>
      <COND
       (<0? .NLEVEL>
	<APPEND-BUF .NADD T>
	<COND (<0? <BUFLENGTH <1 .N>>>				  ;"flushed it?"
	       <COND (<==? .N <1 <REST .NL>>> <SETG NOTES-LIST <SET NL ()>>)
		     (ELSE
		      <MAPR <>
			    <FUNCTION (R) 
				    #DECL ((R) LIST)
				    <AND <==? <2 .R> .N>
					 <PUTREST .R <REST .R 2>>
					 <SETG NOTES-LIST .R>
					 <MAPLEAVE>>>
			    .NL>
		      <SET NLEVEL -1>)>)
	      (<SET NLEVEL 1>)>)>
      <COND (<1? .NLEVEL> <APPEND-BUF .NTXT T>)>
      <NOTING <> .NADD .NTXT>>
    <NOTING <> .NADD .NTXT>>>

<DEFINE NOTING (ON-OFF
		"OPTIONAL" A B
		"AUX" (CTRLP <MEMQ !\ ,COMPOS-CHRTABLE>)
		      (CTRLT <MEMQ !\ ,COMPOS-CHRTABLE>))
	#DECL ((CTRLP CTRLT) <OR FALSE VECTOR> (A B) VECTOR (ON-OFF) <OR ATOM FALSE>)
	<COND (<ASSIGNED? A> <PUT .A ,FBUF <>>)>
	<COND (<ASSIGNED? B> <PUT .B ,FBUF <>>)>
	<COND (<NOT <AND .CTRLP .CTRLT>> <ERROR COMPOS-CHRTABLE-MUNGED>)
	      (.ON-OFF
	       <PUT <REST .CTRLP> 1 ,PREVIOUS-NOTE>
	       <PUT <REST .CTRLT> 1 ,NOTE-LEVEL>)
	      (ELSE <PUT <REST .CTRLP> 1 ,TIME> <PUT <REST .CTRLT> 1 ,TIME>)>>

<DEFINE NOTE-LEVEL (X Y)
	#DECL ((NLEVEL) FIX)
	<COND (<0? .NLEVEL> <SET NLEVEL 1>)
	      (<1? .NLEVEL> <SET NLEVEL 0>)>
	<CRLF>
	<NOTE-AGAIN>>

<DEFINE PREVIOUS-NOTE (X Y "AUX" (BEG ,NOTES-LIST)) 
	#DECL ((BEG) <LIST LIST>)
	<MAPR <>
	      <FUNCTION (N) 
		      #DECL ((N) LIST)
		      <COND (<==? <REST .N> .BEG>
			     <SETG NOTES-LIST .N>
			     <MAPLEAVE>)>>
	      .BEG>
	<SET NLEVEL 0>
	<CRLF>
	<NOTE-AGAIN>>

<DEFINE NOTE-AGAIN ("AUX" NL)
	#DECL ((NOTES-LOOP) <SPECIAL ACTIVATION> (NL) ACTIVATION)
	<AND <ASSIGNED? NOTES-LOOP>
	     <LEGAL? <SET NL .NOTES-LOOP>>
	     <AGAIN .NL>>>

\ 

"************************APPEND TO FIELDS*****************************"

"Appending routines (ie: normal input) for various fields"

<DEFINE FAP (INFO "OPTIONAL" (P? <>) "AUX" (APP <APPENDER .INFO>))
	#DECL ((INFO) VECTOR (APP) <OR FALSE APPLICABLE>)
	<AND .APP <APPLY .APP .INFO .P?>>>

"General buffer appending routine"

<DEFINE APPEND-BUF (INFO
		    "OPTIONAL" (PROMPT? <>) (SILENT? <>)
		    "AUX" (PROMPT-VERBOSE <PR2 .INFO>)
			  (BUF <FBUF .INFO>) (OUTCHAN .OUTCHAN))
	#DECL ((INFO) VECTOR (BUF) <SPECIAL BUFFER> (PROMPT?) <OR ATOM FALSE>
	       (OUTCHAN) CHANNEL (PROMPT-VERBOSE) <SPECIAL STRING>)
	<COND (<OR <NOT ,FORWARD> <BTEST ,BFORWARD .INFO>>
	       <COND (<ABREAK .INFO> <ADDBREAK .BUF <ABREAK .INFO>>)>
	       <COND (<NOT .SILENT?>
		      <COND (.PROMPT? <PRINC "A">)>
		      <BUFPRINT .BUF .OUTCHAN .PROMPT?>)>
	       <GETSTR .BUF ,COMPOS-CHRTABLE <>>)
	      (ELSE
	       <PRINC "A">
	       <PRINC "You cannot change that field during Forwarding!">
	       .BUF)>>

"Append to message itself.  There is a special hack in here such that
if there was text on the JCL line there will be no prompt and all that
stuff on the first call to APPEND-MESSAGE."

<DEFINE APPEND-MESSAGE (INFO "OPTIONAL" (PROMPT? <>) "AUX" (SILENT? ,JCL-TEXT))
	#DECL ((VALUE) BUFFER (PROMPT? SILENT?) <OR ATOM FALSE>)
	<SETG JCL-TEXT <>>
	<OR .SILENT? <PRINC "A">>
	<APPEND-BUF .INFO .PROMPT? .SILENT?>>

"Buffer prompts"

<SETG SPACE ": ">
<SETG SPEOL ":
">

"Print a Prompt -- ? function"

<DEFINE QUESTION (BUF CHR "AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((BUF) BUFFER (CHR) CHARACTER (PROMPT-VERBOSE) STRING
	       (OUTCHAN) CHANNEL)
	<COND (<0? <BUFLENGTH .BUF>>
	       <TERPRI>
	       <PRINC .PROMPT-VERBOSE>
	       <TERPRI>
	       <PRINC "Terminate input with 'ESC'.">
	       <TERPRI>
	       <BUFPRINT .BUF>)
	      (ELSE <PRINC .CHR> <ADDCHR .BUF .CHR>	       ;"IF BUFFER NOT EMPTY")>>

\ 

"Buffer clearing functions"

<DEFINE ALLCLEAR ("OPTIONAL" (ALL? <>) (FLDS ,FIELD-TABLE)) 
	#DECL ((FLDS) <UVECTOR [REST VECTOR]> (ALL?) <OR ATOM FALSE>)
	<MAPF <>
	      <FUNCTION (INFO)
		   #DECL ((INFO) VECTOR)
		   <AND <FBUF .INFO>
			<OR .ALL? <NOT <BTEST ,BSAVE .INFO>>>
			<BUFCLEAR <FBUF .INFO>>>>
	      .FLDS>
	<SETG NOTES-LIST ()>>

"Print the current state of the message"

<DEFINE PRINTER ("AUX" (OUTCHAN .OUTCHAN)) 
	#DECL ((OUTCHAN) CHANNEL)
	<CRLF>
	<MAPF <>
	      <FUNCTION (INFO) 
		      #DECL ((INFO) VECTOR)
		      <AND <QFIELD .INFO>
			   <APPLY <QFIELD .INFO> .INFO>>>
	      ,FIELD-TABLE>
	<CRLF>
	<CRLF>>

<DEFINE QNOTES (AINF
		"AUX" (TINF ,NOTE-TEXT) BEG (OA <FBUF .AINF>)
		      (OT <FBUF .TINF>) (NL ,NOTES-LIST))
	#DECL ((AINF TINF) VECTOR (OA OT) <OR BUFFER FALSE> (BEG) LIST
	       (NL) LIST)
	<COND (<NOT <EMPTY? .NL>>
	       <SET BEG <1 .NL>>
	       <MAPF <>
		     <FUNCTION (N) 
			     #DECL ((N) <LIST BUFFER BUFFER>)
			     <CRLF>
			     <PUT .AINF ,FBUF <1 .N>>
			     <PUT .TINF ,FBUF <2 .N>>
			     <FIELDPRINT .AINF>
			     <FIELD& .TINF>
			     <AND <==? .N .BEG> <MAPLEAVE>>>
		     <REST .NL>>
	       <PUT .AINF ,FBUF .OA>
	       <PUT .TINF ,FBUF .OT>)>>

"Print an individual field"

<DEFINE FIELDPRINT (INFO "AUX" (BUF <FBUF .INFO>)) 
	#DECL ((INFO) VECTOR (BUF) <OR BUFFER FALSE>)
	<COND (<NOT .BUF>)
	      (<OR <MEMQ <FLDNM .INFO> ,ALWAYSFIELDS>
		   <NOT <0? <BUFLENGTH .BUF>>>>
	       <FIELDHEADER <PR1 .INFO> <PRD .INFO>>
	       <BUFPRINT .BUF .OUTCHAN <>>)>>

"Print a field truncated to one line"

<DEFINE FIELD& (INFO
		"AUX" (BUF <FBUF .INFO>) (BL <BUFLENGTH .BUF>) (PL .BL) BR B1)
	#DECL ((INFO) VECTOR (BUF) BUFFER (BR) <OR STRING FALSE> (BL PL) FIX
	       (B1) STRING)
	<COND (<OR <MEMQ <FLDNM .INFO> ,ALWAYSFIELDS> <NOT <0? .BL>>>
	       <PROG ((OUTCHAN .OUTCHAN))
		     #DECL ((OUTCHAN) CHANNEL)
		     <FIELDHEADER <PR1 .INFO> <PRD .INFO>>
		     <COND (<SET BR <MEMQ <ASCII 13> <SET B1 <1 .BUF>>>>
			    <SET PL <MIN .BL <- <LENGTH .B1> <LENGTH .BR>>>>)>
		     <SET PL <MIN .PL <- <13 .OUTCHAN> <14 .OUTCHAN> 3>>>
		     <PRINTSTRING .B1 .OUTCHAN .PL>
		     <OR <==? .BL .PL> <PRINC "...">>>)>>

<DEFINE FIELDHEADER (P D "AUX" (OUTCHAN .OUTCHAN))
	#DECL ((P D) STRING (OUTCHAN) CHANNEL)
	<CRLF>
	<PRINC .P>
	<PRINC .D>
	<COND (<==? .D ,SPACE>
	       <PRINC <REST ,SP <MIN <+ <LENGTH .P> 1>
				     <- <LENGTH ,SP> 1>>>>)>>

\ 

<DEFINE FILE-CURRENT-STATE ("AUX" FIL CH BEG (NL ,NOTES-LIST) (OUTCHAN .OUTCHAN)) 
   #DECL ((FIL) STRING (CH) <OR CHANNEL FALSE> (NL) <LIST LIST>
	  (OUTCHAN) CHANNEL (BEG) LIST)
   <REPEAT ()
     <SET FIL <GET-TEMP "File to write to" <> ,DUMP-FILE>>
     <COND
      (<EMPTY? .FIL> <PRINC "[Aborted]"> <CRLF> <RETURN>)
      (<SET CH <OPEN "PRINT" .FIL>>
       <SET OUTCHAN .CH>
       <MAPF <>
	     <FUNCTION (V) #DECL ((V) ATOM) <PRINT <FORM SETG .V ,.V>>>
	     ,INTERESTING-GVALS>
       <MAPF <>
	     <FUNCTION (F) 
		     #DECL ((F) VECTOR)
		     <COND (<AND <FBUF .F> <NOT <0? <BUFLENGTH <FBUF .F>>>>>
			    <CRLF>
			    <PRINC !\(>
			    <PRIN1 <FLDNM .F>>
			    <PRINC !\ >
			    <BUFSPRINT <FBUF .F> .OUTCHAN>
			    <PRINC !\)>)>>
	     ,FIELD-TABLE>
       <COND (<NOT <EMPTY? ,NOTES-LIST>>
	      <SET BEG <1 ,NOTES-LIST>>
	      <CRLF>
	      <PRINC !\[>
	      <PRIN1 NOTES-LIST>
	      <PRINC " (">
	      <MAPF <>
		    <FUNCTION (N) 
			    #DECL ((N) <LIST [2 BUFFER]>)
			    <CRLF>
			    <PRINC !\(>
			    <BUFSPRINT <1 .N> .OUTCHAN>
			    <PRINC !\ >
			    <BUFSPRINT <2 .N> .OUTCHAN>
			    <PRINC !\)>
			    <AND <==? .N .BEG> <PRINC ")]"> <MAPLEAVE>>>
		    <REST ,NOTES-LIST>>)>
       <CLOSE .OUTCHAN>
       <RETURN>)
      (ELSE <OPEN-FAILED .CH .FIL>)>>>

<DEFINE LOAD-FROM-FILE ("AUX" FIL CH OBJ B TMP (OUTCHAN .OUTCHAN)) 
   #DECL ((FIL) STRING (CH) <OR CHANNEL FALSE> (B) BUFFER (TMP) LIST
	  (OUTCHAN) CHANNEL)
   <REPEAT ()
     <SET FIL <GET-TEMP "File to load from" <> ,DUMP-FILE>>
     <COND
      (<EMPTY? .FIL> <PRINC "[Aborted]"> <CRLF> <RETURN>)
      (<SET CH <OPEN "READ" .FIL>>
       <ALLCLEAR T>
       <REPEAT ()
	 <COND
	  (<SET OBJ <READ .CH '<>>>
	   <COND (<TYPE? .OBJ FORM> <EVAL .OBJ>)
		 (<AND <TYPE? .OBJ LIST>
		       <==? <LENGTH .OBJ> 2>
		       <TYPE? <1 .OBJ> ATOM>
		       <TYPE? <2 .OBJ> STRING>>
		  <SET B <FBUF ,<1 .OBJ>>>
		  <ADDSTRING .B <2 .OBJ>>)
		 (<AND <TYPE? .OBJ VECTOR>
		       <==? <LENGTH .OBJ> 2>
		       <==? <1 .OBJ> NOTES-LIST>
		       <TYPE? <2 .OBJ> LIST>>
		  <MAPF <>
			<FUNCTION (L "AUX" B) 
				#DECL ((L) LIST (B) BUFFER)
				<SET B <INIT-BUF ,NOTES <+ 20 <LENGTH <1 .L>>>>>
				<ADDSTRING .B <1 .L>>
				<PUT .L 1 .B>
				<SET B <INIT-BUF ,NOTE-TEXT <* 2 <LENGTH <2 .L>>>>>
				<ADDSTRING .B <2 .L>>
				<PUT .L 2 .B>>
			<SET TMP <2 .OBJ>>>
		  <SETG NOTES-LIST <REST .TMP <- <LENGTH .TMP> 1>>>
		  <PUTREST ,NOTES-LIST .TMP>)
		 (ELSE
		  <CRLF>
		  <PRINC "[Illegal object of type ">
		  <PRINC <TYPE .OBJ>>
		  <PRINC " in MAIL dump file]">
		  <RETURN>)>)
	  (ELSE <RETURN>)>>
       <CRLF>
       <CLOSE .CH>
       <EDIT-LEVEL>
       <RETURN>)
      (ELSE <OPEN-FAILED .CH .FIL>)>>>

<SETG INTERESTING-GVALS
      '![BUG
	 FEATURE
	 REMIND
	 MSG
	 FORWARD
	 CORRECT
	 ACK-CONDS
	 ASK-ME
	 ALWAYSFIELDS
	 EXPIRES
	 STIME
	 TECO-PROGRAM!]>

<GDECL (INTERESTING-GVALS) <UVECTOR [REST ATOM]>>

\ 

"Set up Forwarding, and edit Msg-no field"

<DEFINE FORWARD-HACK ()
	<COND (<NOT ,FORWARD>
	       <SETG FORWARD T>
	       <SETG ASK-ME ,FORWARD-ASK-ME>
	       <SETG ALWAYSFIELDS ,FWDALWAYS>)>
	<FAP ,MSG-NO>>

"If :REMIND, then ask for a delivery date"

<DEFINE REMIND-HACK ("AUX" STR DT (TOBUF <FBUF ,TO>) (OUTCHAN .OUTCHAN))
    #DECL ((STR) STRING (DT) <OR FIX FALSE> (TOBUF) BUFFER
	   (OUTCHAN) CHANNEL)
    <REPEAT ()
	<SET STR <GET-TEMP "When to remind" <>>>
	<COND (<SET DT <PARSE-DATE <LEXER .STR>>>
	       <AND <L? .DT <ITIME>> <AGAIN>>
	       <SETG STIME .DT>
	       <SETG FAILED <- <+ .DT <* 262144 2>> <ITIME>>>
	       <PUT ,ACK-CONDS 2 "FAILED">
	       <AND <0? <BUFLENGTH .TOBUF>> <ADDSTRING .TOBUF <XUNAME>>>
	       <SETG SKIP-TO T>
	       <RETURN>)
	      (ELSE
	       <PRINC "Can't understand that date: ">
	       <PRINC .STR>
	       <PRINC " Please try again.">
	       <CRLF>)>>>

<DEFINE ACK-DELIVERY ("AUX" (AC ,ACK-CONDS) (OUTCHAN .OUTCHAN))
	#DECL ((AC) LIST (OUTCHAN) CHANNEL)
	<COND (<NOT <1 .AC>>
	       <PUT .AC 1 "DELIVERY">)
	      (ELSE
	       <PUT .AC 1 <>>
	       <PRINC "Disabled.">)>>

"If ACK on failure, ask for how long to wait"

<DEFINE FAIL-HACK ("AUX" STR DT (OUTCHAN .OUTCHAN) (AC ,ACK-CONDS))
    #DECL ((STR) STRING (DT) <OR FALSE FIX> (OUTCHAN) CHANNEL
	   (AC) LIST)
    <COND (<NOT <2 .AC>>
	   <REPEAT ()
		   <SET STR <GET-TEMP "When to report if not delivered" <>>>
		   <COND (<SET DT <PARSE-DATE <LEXER .STR>>>
			  <AND <L? .DT <ITIME>> <AGAIN>>
			  <SETG FAILED <- .DT <ITIME>>>
			  <PUT .AC 2 "FAILED">
			  <RETURN>)
			 (ELSE
			  <PRINC "Can't understand that date: ">
			  <PRINC .STR>
			  <PRINC " Please try again.">
			  <CRLF>)>>)
	  (ELSE
	   <PUT .AC 2 <>>
	   <PRINC "Default failure acknowledgment (two days).">)>>

"Expiration date for :MSG"

<DEFINE EXPIRES-HACK ("AUX" STR DT (OUTCHAN .OUTCHAN))
    #DECL ((STR) STRING (DT) <OR FALSE FIX> (OUTCHAN) CHANNEL)
    <REPEAT ()
	<SET STR <GET-TEMP "When MSG expires" <>>>
	<COND (<SET DT <PARSE-DATE <LEXER .STR>>>
	       <AND <L? .DT <ITIME>> <AGAIN>>
	       <SETG EXPIRES .DT>
	       <RETURN>)
	      (ELSE
	       <PRINC "Can't understand that date: ">
	       <PRINC .STR>
	       <PRINC " Please try again.">
	       <CRLF>)>>>

"Input to a temporary buffer with a given prompt and breaks and with
the buffer optionally having preset contents"

<DEFINE GET-TEMP (P1
		  "OPTIONAL" (BRKS ,DBRKS) (ST "") (STL <LENGTH .ST>)
		  "AUX" (TMP ,TEMPORARY) (BUF <FBUF .TMP>))
	#DECL ((TMP) VECTOR (BRKS) <OR FALSE STRING> (P1 ST) STRING (BUF) BUFFER
	       (STL) FIX (VALUE) <OR STRING <LIST [REST STRING]>>)
	<PUT .BUF ,BPRMPT1 .P1>
	<BUFCLEAR .BUF>
	<AND <NOT <EMPTY? .ST>> <ADDSTRING .BUF .ST .STL>>
	<APPEND-BUF .TMP T>
	<COND (.BRKS <BUFLEX .BUF .BRKS>)(ELSE <BUFTOS .BUF>)>>

<DEFINE GET-IDS ("AUX" (TMP ,TEMPORARY) (BUF <FBUF .TMP>))
	#DECL ((TMP) VECTOR (BUF) BUFFER (VALUE) <OR FALSE <LIST [REST STRING]>>)
	<PUT .BUF ,BPRMPT1 " numbers">
	<BUFCLEAR .BUF>
	<APPEND-BUF .TMP T>
	<FINDIDS .TMP <>>>

\

<DEFINE CHECKER (BUF CHAR "AUX" ADRS (DBS ()) (EXP ,EXPUSING) INFO)
	#DECL ((BUF) BUFFER (CHAR) CHARACTER (ADRS DBS) LIST
	       (INFO EXP) VECTOR)
	<COND (<AND <SET INFO <FIND-BUF .BUF>>
		    <BTEST ,BADDR .INFO>>
	       <SET ADRS <BUFLEX .BUF>>
	       <COND (<NOT <0? <BUFLENGTH <FBUF .EXP>>>>
		      <SET DBS <GET-FILES .EXP>>)>
	       <SET DBS ("COMEXP" !.DBS)>
	       <CHECK-ADDRESSEES .ADRS .DBS>
	       <CRLF>
	       <BUFPRINT .BUF>)>>

<DEFINE FIND-BUF (BUF "AUX" (FT ,FIELD-TABLE))
	#DECL ((BUF) BUFFER (FT) UVECTOR)
	<MAPF <>
	      <FUNCTION (INFO)
		   #DECL ((INFO) VECTOR)
		   <COND (<==? <FBUF .INFO> .BUF> <MAPLEAVE .INFO>)>>
	      .FT>>

\ 

"************************ HOST NAME HACKING *************************"

"Check any hosts specified, ask for corrections if some are losers"

<DEFINE FINDHOSTS (INFO "OPTIONAL" (PREFIX <>)
		   "AUX" (BF <FBUF .INFO>) LX (LOSER <>) FIXP NML HST LP)
	#DECL ((INFO) VECTOR (BF) BUFFER (LX VALUE) <LIST [REST STRING]>
	       (FIXP) <OR FALSE STRING> (SYMB PREFIX) <OR STRING FALSE>
	       (LOSER) <OR ATOM FALSE> (NML) FIX (LP) LIST (HST) ANY (VALUE) STRING)
	<SET LX <BUFLEX .BF>>
	<COND (.PREFIX
	       <MAPR <>
		     <FUNCTION (L)
			  #DECL ((L) <LIST [REST STRING]>)
			  <PUT .L 1 <STRING .PREFIX <1 .L>>>>
		     .LX>)>
	<MAPR <>
	      <FUNCTION (L "AUX" (S <1 .L>))
		#DECL ((L) LIST (S) STRING)
		<REPEAT ()
			<COND (<SET FIXP <ATSIGN? .S>>
			       <SET NML <- <LENGTH .S> <LENGTH .FIXP>>>
			       <SET FIXP <REST .FIXP>>)
			      (ELSE
			       <PUT .L 1 .S>
			       <RETURN>)>
			<COND (<SET HST <HOST <UPPERCASE .FIXP>>>
			       <PUT .L 1 .S>
			       <RETURN>)
			      (<AND <NOT <EMPTY? <SET LP <LPARSE .FIXP>>>>
				    <TYPE? <SET HST <1 .LP>> FIX>
				    <G? .HST 0>
				    <L? .HST 256>>
			       <PUT .L 1 .S>
			       <RETURN>)
			      (ELSE
			       <SET S <CORRECT-ADDRESS <PR1 .INFO>
						       "Unknown host given in addressee"
						       .S
						       "Host"
						       .NML>>
			       <SET LOSER T>)>>>
	      .LX>
	<COND (.LOSER <REMAKE .BF .LX>)>
	.LX>

<DEFINE ATSIGN? (KEY "AUX" C (SKIP <>) (BEST <>)) 
	#DECL ((KEY) STRING (C) CHARACTER (SKIP) <OR ATOM FALSE>
	       (BEST) <OR STRING FALSE>)
	<MAPR <>
	      <FUNCTION (S) 
		      #DECL ((S) STRING)
		      <COND (.SKIP <SET SKIP <>>)
			    (<==? <SET C <1 .S>> !\@>
			     <SET BEST .S>)
			    (<==? .C !\> <SET SKIP T>)
			    (ELSE <SET SKIP <>>)>>
	      .KEY>
	.BEST>

<DEFINE CORRECT-ADDRESS (WHO PROMPT S PR1
			 "OPTIONAL" (NML <>) (BRKS ,TOBRKS)
			 "AUX" TMP (OUTCHAN ,OUTCHAN))
	#DECL ((WHO) <OR STRING FALSE> (PROMPT PR1 S BRKS) STRING (NML) <OR FALSE FIX>
	       (TMP) <LIST [REST STRING]> (OUTCHAN) <SPECIAL CHANNEL>)
	<PROG ()
	      <CRLF>
	      <COND (.WHO
		     <PRINC !\'>
		     <PRINC .WHO>
		     <PRINC "' field: ">)>
	      <PRINC .PROMPT>
	      <PRINC ": '">
	      <PRINC .S>
	      <PRINC "'.">
	      <CRLF>
	      <SET TMP
		   <COND (.NML
			  <GET-ADDR .PR1 .BRKS .S <+ .NML 1>>)
			 (ELSE
			  <GET-ADDR .PR1 .BRKS>)>>
	      <COND (<NOT <EMPTY? .TMP>> <1 .TMP>)
		    (ELSE <AGAIN>)>>>

<DEFINE GET-ADDR (P1
		  "OPTIONAL" (BRKS ,DBRKS) (ST "") (STL <LENGTH .ST>)
		  "AUX" (TMP ,TEMPORARY) (BUF <FBUF .TMP>))
	#DECL ((TMP) VECTOR (BRKS) <OR FALSE STRING> (P1 ST) STRING (BUF) BUFFER
	       (STL) FIX (VALUE) <OR STRING <LIST [REST STRING]>>)
	<PUT .BUF ,BPRMPT1 .P1>
	<BUFCLEAR .BUF>
	<AND <NOT <EMPTY? .ST>> <ADDADDR .BUF .ST .STL>>
	<APPEND-BUF .TMP T>
	<COND (.BRKS <BUFLEX .BUF .BRKS>)(ELSE <BUFTOS .BUF>)>>

<DEFINE REMAKE (BUF TMP)
	#DECL ((BUF) BUFFER (TMP) <LIST [REST STRING]>)
	<BUFCLEAR .BUF>
	<MAPF <>
	      <FUNCTION (X)
			#DECL ((X) STRING)
			<ADDADDR .BUF .X>
			<ADDCHR .BUF !\,>>
	      .TMP>>

<DEFINE ADDADDR (BUF X "OPTIONAL" (L <LENGTH .X>) "AUX" (BRKS ,TOBRKS))
	#DECL ((BUF) BUFFER (X BRKS) STRING (L) FIX)
	<REPEAT ()
		<COND (<OR <EMPTY? .X> <0? .L>> <RETURN .BUF>)>
		<COND (<MEMQ <1 .X> .BRKS>
		       <ADDCHR .BUF %<ASCII *134*>>)>
		<ADDCHR .BUF <1 .X>>
		<SET L <- .L 1>>
		<SET X <REST .X>>>>

<DEFINE MORE-MESSAGES ()
	<COND (<SETG MORE-MSGS <NOT ,MORE-MSGS>>
	       <PRINC "More messages to come">)
	      (ELSE <PRINC "No more messages">)>>

\ 

"Various breaks and things"

<SETG TOBRKS " ,
">

<SETG KEYBREAKS <MAPF ,STRING ,ASCII (13 9 10 32 <ASCII !\,> <ASCII !\.>)>>

<SETG EOL "
">

<SETG SP <ISTRING 15 '<ASCII 32>>>

<SETG DBRKS ".,/ 	
">

<GDECL (DBRKS SP TOBRKS KEYBREAKS EOL) STRING>

\ 

"**************************FIELD INFORMATION*************************"

"Fields that are always printed, whether empty or not"

<SETG ALWAYSFIELDS <SETG TOALWAYS '(TO FROM TEXT)>>

<SETG MSGALWAYS (MSG-FILE SUBJECT !,ALWAYSFIELDS)>

<SETG FWDALWAYS '(MSG-NO TO)>

<SETG BUGALWAYS '(PROGRAM FROM TEXT)>

<GDECL (ALWAYSFIELDS TOALWAYS MSGALWAYS FWDALWAYS BUGALWAYS)
       <LIST [REST ATOM]>>

<DEFINE INIT-FIELDS ()
	<SETG NOTES-LIST ()>	;"List of notes"
	<MAPF <>
	      <FUNCTION (INFO)
		 #DECL ((INFO) VECTOR)
		 <SETG <FLDNM .INFO> .INFO>
		 <INIT-BUF .INFO>>
	      ,FIELD-TABLE>
	T>

<DEFINE INIT-BUF (INFO "OPTIONAL" (N <BUFSIZ .INFO>) B)
	#DECL ((INFO) VECTOR (N) FIX (B) BUFFER)
	<SET B <BUFMAKE .N <PR1 .INFO> <PRD .INFO>>>
	<COND (<BTEST ,BLFP .INFO>
	       <BUF-BITS .B ,BUF-BIT-PROMPT T>)>
	<COND (<BTEST ,BCRLF .INFO>
	       <BUF-BITS .B 35 T>)>
	<PUT .INFO ,FBUF .B>
	.B>

"Offsets in a field information vector"

<SETG FLDNM 1>

;"atom which is the name of the field"

<SETG FBUF 2>

;"BUFFER which is the field's input buffer (or <>)"

<SETG BUFSIZ 3>

;"size of initial BUFFER"

<SETG BFLAGS 4>

<SETG BSAVE 1>
<SETG BFORWARD 2>
<SETG BLFP 4>
<SETG BCRLF 8>
<SETG BADDR 16>

<DEFMAC BTEST ('BIT 'BUF)
	<FORM NOT
	      <FORM 0?
		    <FORM CHTYPE
			  <FORM ANDB
				<FORM BFLAGS .BUF>
				.BIT>
			  FIX>>>>

;"T if BUFFER to be cleared after each message"

<SETG APPENDER 5>

;"apply this to info to append to field"

<SETG ABREAK 6>

;"ADDBREAK this to buffer on each call"

<SETG PFIELD 7>

;"apply this to print message file for this field"

<SETG QFIELD 8>

;"apply this to print message reference during editing"

<SETG PR1 9>

;"short prompt and pretty header to print"

<SETG PRD 10>

;"tail end of short prompt (crlf for TEXT...)"

<SETG PR2 11>

;"verbose prompt for this field"

<MANIFEST FLDNM FBUF BUFSIZ BFLAGS APPENDER ABREAK PFIELD QFIELD PR1 PRD PR2>
<MANIFEST BSAVE BFORWARD BLFP BCRLF BADDR>
\ 

"Field information uvector"

<SETG FIELD-TABLE
      ![[FROM
	 <>
	 10
	 <+ ,BSAVE ,BCRLF ,BADDR>
	 ,APPEND-BUF
	 <>
	 ,PFROM
	 ,FIELDPRINT
	 "From"
	 ,SPACE
	 "Type the name of the principal author."]
	[FULL-NAME
	 <>
	 100
	 ,BCRLF
	 ,APPEND-BUF
	 <>
	 ,PSTR
	 ,FIELDPRINT
	 "Full name"
	 ,SPACE
"Type the full name of the author; it will
be printed in addition to the mailbox name
in the 'From' field.  (This is not necessary
if you are known to INQUIR.)"]
	[REPLY-TO
	 <>
	 20
	 <+ ,BLFP ,BADDR>
	 ,APPEND-BUF
	 !\,
	 ,PLST
	 ,FIELDPRINT
	 "Reply-to"
	 ,SPACE
	 "The return address, if it is different from the From
or Sender fields.  Separated by space, 'CR'
or comma."]
	[PROGRAM
	 <>
	 100
	 <+ ,BLFP ,BFORWARD>
	 ,APPEND-BUF
	 !\,
	 <>
	 ,FIELDPRINT
	 "Programs"
	 ,SPACE
	 "List the programs, separated by
space, 'CR' or comma."]
	[TO
	 <>
	 100
	 <+ ,BLFP ,BFORWARD ,BADDR>
	 ,APPEND-BUF
	 !\,
	 ,PTO
	 ,FIELDPRINT
	 "To"
	 ,SPACE
	 "List the action addressees, separated by
space, 'CR' or comma."]
	[SUBJECT
	 <>
	 100
	 ,BCRLF
	 ,APPEND-BUF
	 <>
	 ,PSUBJ
	 ,FIELDPRINT
	 "Subject"
	 ,SPACE
	 "Type a short description of the contents
of the message."]
	[IN-REPLY-TO
	 <>
	 10
	 ,BLFP
	 ,APPEND-BUF
	 <>
	 ,PSTR
	 ,FIELDPRINT
	 "In reply to"
	 ,SPACE
	 
"Type the Message id number(s) of the
message(s) to which this is a reply."]
	[CARBON-COPY-TO
	 <>
	 40
	 <+ ,BLFP ,BADDR>
	 ,APPEND-BUF
	 !\,
	 <>
	 ,FIELDPRINT
	 "Carbon-copy-to"
	 ,SPACE
	 
"List the names of recipients of a carbon
copy.  Separate the names by space, 'CR' or
comma."]
	[BLIND
	 <>
	 20
	 <+ ,BLFP ,BADDR>
	 ,APPEND-BUF
	 !\,
	 <>
	 ,FIELDPRINT
	 "Blind-copy-to"
	 ,SPACE
	 
"List the names of recipients of 'Blind'
carbons.  The people in the 'Carbon-copy'
list will not be apprised of the names in
the 'Blind' list."]
	[FILES
	 <>
	 20
	 ,BLFP
	 ,APPEND-BUF
	 !\,
	 ,PFILE-OUTPUT
	 ,FIELDPRINT
	 "Output to"
	 ,SPACE
	 
"List the names of files to which you
want the message to be sent, in addition
to the primary addressees, using the
FILE-OUTPUT process.  The names should be
separated by 'CR' or comma."]
	[ENCLOSURES
	 <>
	 20
	 ,BLFP
	 ,APPEND-BUF
	 !\,
	 ,PENCLOSURES
	 ,FIELDPRINT
	 "Enclosures"
	 ,SPACE
	 
"List any files which are to be treated
as enclosures, separated by 'CR' or comma.
Enclosures will be copied to the message
file at delivery time by the Daemon."]
	[MSG-FILE
	 <>
	 10
	 ,BCRLF
	 ,APPEND-BUF
	 !\,
	 ,PMSG-FILE
	 ,FIELDPRINT
	 "Msg. File Name"
	 ,SPACE
	 
"Give the file-name-one, file-name-two
pair to use for this message.  Name-one
defaults to 'MSG->', name-two to '>'"]
	[MSG-NO
	 <>
	 10
	 <+ ,BFORWARD ,BCRLF>
	 ,APPEND-BUF
	 <>
	 ,PID
	 ,FIELDPRINT
	 "Message to forward"
	 ,SPACE
"Type the Message id number of the message
being forwarded."]
	[ID-IRT
	 <>
	 10
	 ,BLFP
	 ,APPEND-BUF
	 <>
	 ,PID
	 ,FIELDPRINT
	 "ID In reply to"
	 ,SPACE
	 
"Type the Message id number(s) of the
message(s) to which this is a reply."]
	[EXPUSING
	 <>
	 20
	 ,BLFP
	 ,APPEND-BUF
	 !\,
	 ,PEXPUSING
	 ,FIELDPRINT
	 "Expand-using"
	 ,SPACE
	 
"Type the names of additional expansion
data base files to use in expanding the
addressees of the message."]
	[TEXT
	 <>
	 400
	 0
	 ,APPEND-MESSAGE
	 <>
	 ,PSTR
	 ,FIELD&
	 "Message"
	 ,SPEOL
	 
"Type the text of the message.  You may
edit the message by typing 'Control E',
or insert a file by typing 'Control Y'."]
	[ANNOTATION
	 <>
	 100
	 ,BFORWARD
	 ,APPEND-MESSAGE
	 <>
	 <>
	 ,FIELD&
	 "Annotation"
	 ,SPEOL
	 
"Type an annotation to the message.  You may
edit it by typing 'Control E', or insert a
file by typing 'Control Y'."]
	[KEYWORDS
	 <>
	 100
	 ,BLFP
	 ,APPEND-BUF
	 !\,
	 ,PLST
	 ,FIELDPRINT
	 "Keywords"
	 ,SPACE
	 
"List any keywords, separated by comma,
'CR' or space.  The keywords will be
available for searching the data-base"]
	[NOTES
	 <>
	 50
	 <+ ,BLFP ,BFORWARD ,BADDR>
	 ,HACK-NOTES
	 <>
	 ,PNOTES
	 ,QNOTES
	 "Note to"
	 ,SPACE
	 
"Addressee(s) for this note, separated by
space, carriage return, or comma."]
	[NOTE-TEXT
	 <>
	 200
	 ,BFORWARD
	 <>
	 <>
	 <>
	 <>
	 "Note text"
	 ,SPEOL
	 
"Text of this note.  It will be sent only
to the addressees for this note."]
	[TEMPORARY
	 <>
	 20
	 <+ ,BFORWARD ,BCRLF ,BADDR>
	 <> <> <> <> "" ,SPACE ""]!]>

<GDECL (FIELD-TABLE) <UVECTOR [REST <VECTOR ATOM>]>
       (TO PROGRAM FROM SUBJECT TEXT ANNOTATION CARBON-COPY-TO BLIND FULL-NAME
	TEMPORARY NOTE-TEXT NOTES EXPUSING ENCLOSURES FILES MSG-NO
	KEYWORDS IN-REPLY-TO ID-IRT REPLY-TO MSG-FILE)
       <VECTOR ATOM>>

\ 

"******************* 'EDIT' MODE DISPATCH TABLE ******************"

"Info string for 'Edit:' mode"

<SETG EDTEXPL

"Edit commands:

	'Edit-flush' (default) to leave Edit level
	'Send-level' to move to Send level
	'Reader' to return to Reader (if you are in it)
	'Print' to print the current state of the message
	'Save-mail' to save the current state of buffers and switches
	'Load-mail' to load a previously saved state
	'Quit' quits out of the mailer

Standard fields:
	'To'
	'Carbon-copy-to' or 'cc'
	'Blind-carbon-copy-to' or 'bcc'
	'Subject'
	'From'
	'Reply-to'
	'Message'
	'Keywords'
	'Note'
	'Last-note'
	'Enclosures'

Esoteric fields:
	'In-reply-to' (READER only) is normally filled in automatically
	'Full-name-of-sender' is paired with 'Sender'

	'Set-switches' processes a new set of JCL switches
	'Select-editor'	allows you to change the TECO editor

	'Expansion-data-bases' specifies your own addressee expansions
	'File-output-to' specifies files to get a copy of the mail

	'Program' contains the programs being 'BUGged' or 'FEATURed'
	'Annotation' is explanatory text for a forwarded message

	'Msg-file' (:MSG only) specifies the file name for the MSGS file
	'Msg-expiration' (:MSG only) specifies the expiration for a MSGS file
	'Forward-message' (:FORWARD only) specifies the message to forward">

"Dispatch for 'Edit:' mode"

<SETG EDIT-CHRS
      [!\
       ,EDIT-LEVEL]>

<SETG EDIT-CHRTABLE <LIST ,EDIT-CHRS ,SYMBOL-CHRS>>

<GDECL (EDIT-CHRS) VECTOR>

<DEFINE EDIT-COMMANDS ()
	<SETG SYMBOL-CHRTABLE ,EDIT-CHRTABLE>
	<CTABLE "Edit: " "" ,EDTEXPL

      * "Edit-flush"	<EDIT-FLUSH>
	"Send-level"	<SEND-LEVEL>
	"Reader"	<NEXT-LEVEL>
	"Print"		<PRINTER>

	"To"		<FAP ,TO>
	"Carbon-copy-to" <FAP ,CARBON-COPY-TO>
	"c"		<FAP ,CARBON-COPY-TO>
	"cc"		<FAP ,CARBON-COPY-TO>
	"Blind-carbon-copy-to" <FAP ,BLIND>
	"bcc"		<FAP ,BLIND>
	"Subject"	<FAP ,SUBJECT>
	"From"		<FAP ,FROM>
	"Reply-to"	<FAP ,REPLY-TO>
	"Message"	<FAP ,TEXT>
	"Keywords"	<FAP ,KEYWORDS>
	"Note"		<HACK-NOTES T>
	"Last-note"	<HACK-NOTES <>>
	"Enclosures"	<FAP ,ENCLOSURES>

	"In-reply-to"	<FAP ,IN-REPLY-TO>
	"Full-name-of-sender" <FAP ,FULL-NAME>

	"Set-switches"	<SWITCH-HACK>
	"Select-editor"	<FLIP-EDITOR>

	"Expansion-data-bases" <FAP ,EXPUSING>
	"File-output-to" <FAP ,FILES>

	"Program"	<FAP ,PROGRAM>
	"Annotation"	<FAP ,ANNOTATION>
	"Msg-file"	<FAP ,MSG-FILE>
	"Msg-expiration" <EXPIRES-HACK>
	"Forward-message" <FORWARD-HACK>

	"Muddle"	<MUDDLE-ESCAPE>
	"Save-mail"	<FILE-CURRENT-STATE>
	"Load-mail"	<LOAD-FROM-FILE>
	"Quit"		<QUITIT>>>

\ 

"******************* 'SEND' MODE DISPATCH TABLE *********************"

"Dispatch for 'Send:' mode"

<SETG SEND-CHRS
      [!\
       ,EDIT-SEND]>

<SETG SEND-CHRTABLE <LIST ,SEND-CHRS ,SYMBOL-CHRS>>

<GDECL (SEND-CHRS) VECTOR>

<DEFINE SEND-COMMANDS ()
	<SETG SYMBOL-CHRTABLE ,SEND-CHRTABLE>
	<CTABLE "Send: " "" 

"Send commands:

	'Normally' to send the message (default)
	'Save-mail' to save the current state of buffers and switches
	'Load-mail' to load a previously saved state
	'Tty' to print the message on the TTY
	'File' to print the message to a File
	'More-messages' to toggle multiple message mode

	'Acknowledge-delivery' toggles delivery acknowledgment
	'Acknowledge-failure' toggles delivery failure acknowledgment
	
	'Edit-level' to get to Edit level
	'Reader' to return to the Reader (if you are in it)
	'Quit' to quit the mailer"

	"Edit-level"	<EDIT-LEVEL>
	"Reader"	<NEXT-LEVEL>
      * "Normally"	<SEND-NORMAL>
	"File"		<SEND-TO-FILE>
	"Save-mail"	<FILE-CURRENT-STATE>
	"Load-mail"	<LOAD-FROM-FILE>
	"More-messages" <MORE-MESSAGES>
	"Tty"		<SEND-TTY>
	"Muddle"	<MUDDLE-ESCAPE>
	"Quit"		<QUITIT>
	
	"Acknowledge-delivery" <ACK-DELIVERY>
	"Acknowledge-failure" <FAIL-HACK>>>

\ 

"********************* BUFFER SPECIAL CHARACTERS ********************"

"Buffer special character table for Mail Composer"

<SETG REENTER-TECO-CHAR !\>

<DEFINE SAFETECO ("TUPLE" T)
	<COND (<LOGGED-IN?>
	       <APPLY ,BUFTECO !.T>)>>

<SETG COMPOS-CHRTABLE
      [!\ 	,IBUFCLEAR				    ;"CLEAR THE BUFFER"
       !\	,ADDCHR				     ;"IN READER, INSERT FIELD"
       !\	,SAFETECO					;"BACK TO TECO"
       !\	,EDIT-ONCE				  ;"PUSH TO EDIT LEVEL"
       !\	,IBUFPRINT				      ;"REPRINT BUFFER"
       !\	,SAFETECO					  ;"ENTER TECO"
       !\	,CHECKER				    ;"CHECK ADDRESSEES"
       !\	,KEYWEX					   ;"KEYWORD EXTRACTOR"
       <ASCII 12> ,IBUFPRINT				      ;"REPRINT BUFFER"
       <ASCII 13> ,MAILCRLF				     ;"CARRIAGE RETURN"
       !\	,TIME					       ;"PREVIOUS-NOTE"
       !\	,QUOTECHR				;"QUOTE NEXT CHARACTER"
       !\	,LAZY-CTRL-R			    ;"RETURN TO PREVIOUS FIELD"
       !\	,TIME						  ;"NOTE-LEVEL"
       !\	,DLINE					       ;"DELETE A LINE"
       !\	,DWORD					       ;"DELETE A WORD"
       !\	,DLINE					       ;"DELETE A LINE"
       !\	,FILEINP					;"SNARF A FILE"
       !\	,RETBUF						   ;"TERMINATE"
       !\?	,QUESTION					      ;"PROMPT"
       <ASCII 127> ,IDELCHR					    ;"RUBOUT"]>

<GDECL (COMPOS-CHRTABLE) <VECTOR [REST CHARACTER ANY]>>

<ENDPACKAGE>
