
;title nntj6
;Text justifier and adjuster
;impurities go at the beginning
.MLLIT==1

Z=0	;flag register used in cmd
A=1	;usually char
B=2	;sometimes cdtab(character in a), sometimes command routine address
C=3	;usually points into buff
D=4	;width of char in a
E=5
F=6	;sometimes free storage pntr
G=7	;xgp horiz pos
H=10	;jsp to chrc & at xct rltbl(a)
I=11	;used by chrc as pntr to next char
J=12	;jsp to scnr1
K=13	;temporary in commands from file e.g.
L=14
M=15
W=16	;width of current line in xgp dots

P=17	;pdl pointer
.XCREF A,B,C,D,H,K,P,Z
.XCREF CDTAB,LTYI,UTYI,TTYI

MAXFNT==9	;highest legal font
CSETSZ==200	;size of character set
BUFSIZ==600	;size of buff
SFS==<3*BUFSIZ>/2	;size of free storage (fs)
HBUFL==120	;size of header
PDLL==40	;size of pdl
CMSWL==20	;size of end-of-line call buffer
OBSIZ==200	;size of output buffer for block iots
LFNTRNG==100	;length of ring buffer of font changes

ERR==1000	;uuo for printing error comments
EGG==2000	;print uuo
BUGR==3000	;like err, but for internal bugs

TYIC==1		;type in
TYOC==2		;type out
UTYIC==3	;file input
UTYOC==4	;file output
ERRC==5		;error device in
FNTC==6		;font channel in

SCBIT==200000	;On in BUFF if single char command
ARGBIT==100000	;On if arg to single char command
XQUOBT==40000	;Try to "normalize" quoted char
JUSBIT==1000	;Prefer for justification (. ? ! at end of sentence)
BKBIT==400	;Break (.?!:; at end of sentence or clause)
MKBIT==200	;Marked space

;On input (ie things in the source file)
BLDCH==^A	;Base line down
BLUCH==^K	;Base line up
BLZCH==^W	;Base line reset
BSCRCH==^Y	;Begin underscore
ESCRCH==^X	;End underscore
SFCH==^F	;Select font n
GENCH==^G	;Generate number (=.GENNUM 1) followed by counter number
FNMCH==^N	;File name
DATCH==^D	;Date
;On output (ie, things TJ6 puts in BUFF)
;BSCRCH
;ESCRCH		;End underscore followed by where it goes
;SFCH		;Followed by fnt #
BLSCH==BLZCH	;Base line set, followed by where
BLICH==BLDCH	;Base line increment, followd by that
ICSPCH==^Z	;Set intercharacter spacing
VSPCH==^_	;Variable space
TABCH==^I	;Tab (for variable width)

;XGP information
VRES==192.	;Resolution in dots per inch
HRES==200.	;Horizontal res
ULBUG==3	;Underline bugger factor. # of dots below baseline

;Chars sent to XGP
XGPESC==177	;XGP escape
XRASET==40	;SP= set raster position
XBASCH==43	;#= set base line
STRTUL==46	;&= start underscore
STOPUL==47	;'= end underscore
XICHSP==50	;( set intercharacter space

;Program character dispatch table
;Flags in left half
CDIGF==1_0	;Digit
CLETF==1_1	;Letter
CDUMF==1_2	;Dummy char, treated like letter
CQUOF==1_3	;Quoting char
CEOLF==1_4	;End of line char (cr of lf)
CEOSF==1_5	;End of sentence (.?!)
CEOCF==1_6	;End of clause (;:)
CSMSF==1_7	;Space or marked space (240)
CHYPF==1_10	;On if hyphen allowed to break
CHHYF==1_11	;Hidden hyphen
CFSPF==1_12	;Causes forward spacing (sp, tab)
CLOSF==1_13	;"closing character" can follow super marked .  -)]"'
CITCF==1_14	;In text command 
CNNRF==1_15	;Usual XGP meaning is not "normal"
CEOFF==1_16	;Can appear at or past eof (^@ ^C ^L)
;Dispatch index in right half
	CCOLX==1	; :
	CSEMX==2	; ;
	CSLSX==3	; /
	CSPCX==4	; SP
	CBKAX==5	; _
	CCRTX==6	; CR
	CLNFX==7	; LF
	CLETX==10	; UPPER CASE LETTER
	CDIGX==11	;Digit
	CLLTX==12	;lower case letter
	CMINX==13	; -
	CRBOX==14	;RBO
	CFFDX==15	;^L
	CEOFX==16	;^C
	CQUOX==17	;quote
;	CTABX==20	;tab
;	CBLDX==21	;^A
;	CDATX==22	;^D
;	CFNTX==23	;^F
;	CGNMX==24	;^G
;	CFNMX==25	;^N
;	CBLZX==26	;^W
;	CBULX==27	;^X
;	CEULX==30	;^Y
;	CEOSX==31	;! ? .
;	CDUMX==32	;
;	CHHYX==33	;
;	C6BTX==34	;6 bit but none of above
;CIDXL==35		;Length of dispatch tables
	C6BTX==20
CIDXL==21

;macros
DEFINE PRINT ARG\	;print error message (no CRLF)
	EGG,,[ASCIZ /!ARG!/]
TERMIN
DEFINE BARF ARG\	;error message+file locations (+CRLF)
	ERR,,[ASCIZ /!ARG!/]
TERMIN
DEFINE BUG ARG\		;TJ6BUG
	BUGR,,[ASCIZ /!ARG!/]
TERMIN

;INTERRUPT LOCATIONS
LOC 41
JSR ERRH
JSR TSINT
LOC 100

;variables and other impurities
RAN:	0			;-1 if program ran (prevents purification)

ONAM:	0,,(SIXBIT /DSK/)	;to-file name
	0
	SIXBIT /MEMO/
OSYSNM:	-1

RNBLK==.-1			;for final rename from tj6 output to memo
	0			;called with .FDELE RNBLK
	UTYOC
	0
	0

RANTXT:	BLOCK 10		;for storage of random strings
	RANMAX==5*<.-RANTXT>
RANCNT:	0
RANIPT:	440700,,RANTXT		;for writing into rantxt
RANOPT:	440700,,RANTXT
RSYSNM:	0			;initial system name
DATE:	BLOCK 4			;asciz date stored here
;these 4 must be in order (are printed like a file name)
ITSNAM:	0			;machine name (AI,ML, or DM)
JNAME:	.FNAM1			;file name of tj6
	.FNAM2
UNAME:	0			;user name
;font stuff
FEOF:	0			;font eof ptr
TFBLK:	SIXBIT /  &DSK/		;font file specs temporarily stored here
	SIXBIT /25FG/		;default font
	SIXBIT /KST/
	SIXBIT /FONTS/

FNTBLK:
FFDEV==.
FFSYS==.+3
	BLOCK	4
HEIGHT:	<VRES/6>-6		;changed if in xgpmod
BASE:	20
WIDTHS:	;REPEAT CSETSZ,HRES/10.
	REPEAT CSETSZ,16.
	FNTBKL==.-FNTBLK	;font block length
BLOCK <MAXFNT*FNTBKL>		;room for other fonts

PAT:
PATCH:	BLOCK 40

;variables
INDS:	0		;amount to indent
NINDS:	0		;new
NXLSPC:	0		;number of spaces to add to next line after current output line
NXLC1:	0		;number of spaces at beginning of line
MXPF:	0		;max position used in buff so far (see mxpf1 also)
MXPF1:	0		;length of line up to where we cut off for full line output
PSMX:	0		;max position used for pstrg
NLFS:	0		;number line feeds extra after next line
NBRKS:	0		;number spaces in line
NPRDS:	0		;number of periods in line
SPN:	0		;number spaces needed in justifying
SINCR:	0		;space increment (left half integer)
PGCMFL:	0		;-1 during .page command
PGSPFL:	0		;on during .space or .page
JERRF:	0		;-1 >one space needed per space
C240S:	0		;# of marked spaces this column
PRNCRS:	0		;# of printed chrs in a position
PNST:	0		;0 or page to start with
AUNDT:	0		;amount to undent
CENTF:	0		;on during .space & .center
;Following are numbers and variables which can be accessed with GENNUM
GENNUM:	BLOCK 10	;Numbers gened
CHAPNO:	0		;>0 chapter #
OUTPAG:	0		;output page #, 1=first
GENWMX==.-GENNUM	;End of writables
OUTLIN:	0		;text line number on page, 1 = first line
FPGPOS:	0		;line count on output from very top of page
NPAGES:	0		;actual # of pages printed
GENMAX==.-GENNUM
DOTPOS:	0		;. or : or ? stored
DOTPOB:	0		;cdtab indexed by dotpos
DOTWID:	0		;width of dotpos
ROTPNT:	0		;saved pointer to command for error output
BLCKNT:	0		;.block count
PLACEF:	0		;-1 print file locations with error msg
BUGF:	0		;-1 print octal uuo pc
EPGIN:	0		;epage increment
EPGINN:	0		;new epage increment
RGHCN:	0		;0 for center, -1 for right
NWAITF:	0		;-1 for nowait at top of page
NHEADF:	0		;-1 for no header
PHP1F:	0		;-1 print header on pd 1
THSFLG:	0		;pg #s inside margins
PWHDF:	0		;align margin with paper width
NVRADJ:	0		;non-zero to cause no adjusting at all to happen
JMODE:	0		;1 justify and fill, 0 fill, -1 do nothing
NJMODE:	0		;new jmode
SPSPF:	0		;-1 leadings sp and tab don't break
CRBRF:	0		;-1 break on all crs
SPFLSF:	0		;-1 compact spaces
CRCOMF:	0		;-1 compact cr's
MID.F:	0		;-1 use smarts about  .?!;:
CONTEN:	0		;-1 table of contents
SLASHC:	0		;/c in file specs
CONFLG:	0		;>1 when printing contents line
CNTFL:	0		;counts number of times we go to rdeol during section title
IOPUSD:	0		;# of nested inserts
APPFLG:	0		;0 for insrt, -1 for appnd
HYPOP:	0		;-1 broke on hidden hyphen
FIGP:	0		;# lines this fig,,pntr to next
LTLF:	0		;>1 line too long message typed for this line
COMLF:	0		;-1 sucessfully read initial command line
SLASHT:	0		;-1 /t flag in initial line
			;xgp stuff
SLASHX:	0		;-1 /x typed, ignore user page specs
XGPMOD:	0		;-1 use xgp (output dev=dsk & .xgp or /x typed)
FONTD:	0		;desired font
FONTC:	0		;current font
ULD:	0		;desired underline state (1=underline)
ULC:	0		;current underline state
HEDSPT:	0		;-1 use split headers
BLPOS:	0		;baseline position +=down
LBLPOS:	0		;last base line position sent
XSPGF:	0		;-1 no xgp command pg
SQUISF:	0		;-1 print ;squish
LTRSPF:	-1		;0 suppress letterspacing (allow .adjust to space only between words)
XNORF:	-1		;-1 to "normalize" quoted characters
IFNT:	0		;input font
IFNIDX:	0		;index to input font
RSEFNT:	0		;ifnt at end of rstrg
HDFONT:	0		;ifnt at end of .header (font that pg num will appear in)
OFNIDX:	0		;index to output font
INCHSP:	0		;intercharacter space
HPCW:	0		;-hlf previous character width
TABSEF:	0		;-1 if user specified tab or space width
TABFNT:	0		;idx of font whose widest char is 1/8 tab. -1 for all fonts

BLOCKM:	0		;-1 if output block iots
CMIDX:	0		;index to cmblk on ouput
CMCNT:	0		;same on input
RDTXTF:	0		;-1 if some text has been read
OFN2F:	0		;-1 user specified output fnm2

HYPCHR:	-1		;Character to hide hyphen
NQUOTE:	^Q		;Quote character
STERMC:	"/		;Used as separator in written .spreads
PROMPT:	"_		;Prompt character for tty input

LNL:	73.		;Line length (=tw-indentation-leading spaces)
XLNL:	73.*16.		;In xgp dots
OPTST:	CAMGE C,LNL	;Skip if enough to output line
OPTST1:	CAMLE C,LNL	;skip if not too much for one line
TW:	73.		;Text width in chars
PW:	85.		;Full page width
TL:	50.		;Text length in lines
PL:	66.		;Full page length
WIDTH:	HRES/10.	;Width of above units in xgp dots
TABW:	<10*HRES>/10.	;Width of tab
	;Order of following is important
PWINCH:	8500.		;Paper width in 1000-th of an inch
PLINCH:	11000.		;Length
TWINCH:	<73.*16.*1000.>/HRES	;Text width
TLINCH:	<50.*<6+25.>*1000.>/VRES	;Text length
LMINCH:	1500.		;Left margin
VSP:	6.		;Xgp vertical spacing
TOPMAR:	50.		;TOPMAR to send to XGP
LFTMAR:	50.		;LFTMAR to send to XGP

LFMD:	1		;1= single spacing, 2=double, etc.
OLFMD:	1		; .. for previous line output
DIRSCN:	-1		;Direction of justifing scan
TYRFL:	TYO		;PUSHJ P,@TYRFL to output character
CHARO:	BUFOUT		;Output char to file (different for blaock and unit output)
CHARI:	TTYI		;Input char (switch among file, tty, rantxt, last char)
CHARI1:	TTYI		;Moved to chari after lchar is used
COMTYI:	FTYI		;Used by command reader
LCHAR:	0		;Character to be reread
FFFF:	0		;-1 supply ff at end of page (not on for lpt and tty)
MARGIN:	6		;Left (and hopefully right) margin
HBUFC:	5		;Number columns taken by text in hbuf
HBUFW:	5*16.		;Width of text
HBUFC1:	0		;number of columns of left header
HBUFW1:	0		;width of left header
HBUFC2:	0		;number of columns of right header
HBUFW2:	0		;width of right header
TPMAR:	8		;Top margin in lines counting heading (heading takes 3 lines)
TPMAR3:	5		;top margin-heading space
PRCNT:	60.		;Percent of paging margin which goes at top of page
PRSNT:	50.		;Percent of line margin which goes on left side
TERMC:	-1		;Terminator in RSTRG
CBUF1:	0		;Count for first field in spread
CBUF2:	0		;Second field
RNLL:	73.		;"Real" NLL (used for header)
RMARGI:	6		;"Real" margin
ULBASI:	ULBUG		;underline position for input stream
ULBASO:	ULBUG		;			output
BLAMT:	12.		;Amount ^A or ^K will move base
ULFNT:	1		;Font to underline if not to XGP
SEPCHR:	-1		;terminator in spread
SBLOCK:	2		;size of .block implied by .sect
TCTYPE:	0		;its tctyp variable 0 =printing console
ALTFLG:	0		;alternates heading 1 & 2 when non-zero (bkph)
SWPFLG:	0		;zero means he1 on left & he2 on right

;various buffers & pntrs
COMCAL:	0			;last call from COMMA1
CMBLK:	BLOCK CMSWL		;commands to do after printing line currently in buff
TRNTBL:	REPEAT CSETSZ,.RPCNT	;(Input) translation table
CDTAB:	BLOCK	CSETSZ		;character bit and dispatch table

TPNTR:	10700,,TBUF-1		;tty buffer pntr
TCNT:	0			;# of chars in tbuf

DNAM:	'DSK			;from-file name
FNAM1:	0
FNAM2:	SIXBIT />/
ISYSNM:	-1
IACCES:	0			;.access pntr
	INBLK==.
INPAGN:	1			;page # in input file
INLINE:	0			;line count on input file
INPTR:	10700,,RCHBUF-1
BLKIP:	0			;.iot pntr after iot
IEOFP:	0			;possible byte pntr to end of file
RCHBUF:	BLOCK 200		;input buffer
	TBUF==RCHBUF		;doubles as tty buffer
RCHBFE:	^C_35

IOPDLB:				;inpagn,inline,inptr,ieofp, + 1 buffer wd saved here
PBLKIP==.+BLKIP-INBLK
PIEOFP==.+IEOFP-INBLK
PINWD==PIEOFP+1
IOBKL==PINWD+1-IOPDLB
	BLOCK 7*IOBKL

OUTFLS:	0			;-1 flush output (used by contents and begin)
OUTBUF:	BLOCK OBSIZ		;buffer for block iots
OUTCNT:	OBSIZ			;# of free bytes in outbuf
OUTPTR:	700,,OUTBUF-1		;byte pntr to outbuf

HBUF: IRPC C,,[PAGE ]
	"C,,0
TERMIN
	LOC HBUF+HBUFL
HBUF1:	BLOCK HBUFL/2		;left header character string
HBUF2:	BLOCK HBUFL/2		;right header character string

FNTRPT:	LFNTRNG-1		;font ring pointer
FNTRNG:	REPEAT LFNTRNG, -1	;ring buffer of IFNT as of before each ^F command

FF:	.+1			;pntr to head of fs
	REPEAT SFS,.+1		;fs chain
	0
	FNTBUF==.		;following double for font buffer
BUFF:	BLOCK BUFSIZ		;contains chrs, marked chrs and pointers into chains
	0			;losing crock can run 1 over buffer
COLWID:	BLOCK BUFSIZ		;width of columns
	FNTBFL==.-FNTBUF
	0			;losing crock can run 1 over buffer
PDL:	-PDLL,,.+1
	BLOCK PDLL+1

;start of code
ERRH:	0			;uuo handler
	JRST	ERRHAN

				;interrupt code
TSINTA:	0			;A saved here
TSINT:	0			;interupt has to be type in
	0
PURE==.				;start of pure code
	MOVEM	A,TSINTA
	MOVEI	A,TYIC
	.ITYIC	A,		;int caused by tty?
	JRST	DINT		;no
	CAIN	A,^Z
	.VALUE			;to replace toplevel TJ6 with DDT
	CAIN	A,^G
	JRST	CNTRLG
DINT:	MOVE	A,TSINTA
	.DISMIS	TSINT+1

CNTRLG:	SKIPN	FFFF		;user trying to quit
	.RESET	UTYOC,
	.RESET	TYIC,
	MOVE	A,CHARI1
	CAME	A,TTYI
	JRST	ENDAR		;To avoid getting stuck in TYI
	JRST	DINT

;4 types of error output routines
ERRHAN:	PUSH	P,A
	PUSH	P,B
	PUSH	P,C
	PUSH	P,H
	PUSH	P,K
	PUSHJ	P,TTYOON
	HLRZ	B,40		;uuo
	CAIN	B,BUGR
	JRST	BGRH
	CAIN	B,EGG		;print uuo
	JRST	EGGH
	CAIN	B,ERR
	JRST	ERRH2
	PUSHJ	P,PLACET
ILLUUO:	.VALUE
	JRST	ENDAR		;start again if return from ddt

EGGH:	SETZM	PLACEF
	JRST	.+2
ERRH2:	SETOM	PLACEF
	SETZM	BUGF
ERRH3:	HRRZ	B,40		;normal error message output routine
	HRLI	B,440700
	JRST	ERRHP

BGRH:	SETOM	PLACEF
	MOVEI	H,[ASCIZ /TJ6BUG /]
	PUSHJ	P,OPSTH		;print string
	HRRZ	A,ERRH		;location
	SOJ	A,
	PUSHJ	P,OCPT
	PUSHJ	P,OPSP
	SKIPN	PURED
	SETOM	BUGF		;.value if unpure
	JRST	ERRH3

	PUSHJ	P,@TYRFL
ERRHP:	ILDB	A,B
	JUMPN	A,.-2
	SKIPE	PLACEF
ERRHPL:	PUSHJ	P,PLACET	;print file place info
	POP	P,TYRFL
	POP	P,K
	POP	P,H
	POP	P,C
	POP	P,B
	POP	P,A
	SKIPN	BUGF
	SKIPE	ERBRK
BUGVAL:	.VALUE
	JRST	2,@ERRH		;return

;print IFNAME(page,line)(output page,line)
PLACET:	SKIPN	BLOCKM
	PUSHJ	P,PRNTRA	;To avoid top of page hassle
	PUSHJ	P,OPSP
	PUSHJ	P,OPINAM	;Print file name
	PUSHJ	P,OPOPAR	;Input page & line
	MOVE	A,INPAGN
	PUSHJ	P,DPT
	PUSHJ	P,OPCOMA
	MOVE	A,INLINE
	PUSHJ	P,DPT
	PUSHJ	P,OPCPAR
	PUSHJ	P,OPOPAR	;Output chapter,page and line
	PUSHJ	P,PGNPT
	PUSHJ	P,OPCOMA
	MOVE	A,OUTLIN
	AOJ	A,
	PUSHJ	P,DPT
	PUSHJ	P,OPCPAR
	SKIPE	BLOCKM
	JRST	OPCRLF
	JRST	CRR
;character input routines
RNCH:	MOVE	A,CHARI1	;read next char
	MOVEM	A,CHARI
	JRST	@A

UNCHCR:	MOVEI	A,^J		;make lf last char
UNCH:	MOVEM	A,LCHAR
	MOVEI	A,LTYI		;reread last char
	MOVEM	A,CHARI
	POPJ	P,

RURCH:	PUSHJ	P,RCH		;read and "unread" char
UNCHA:	PUSHJ	P,UNCH
	MOVE	A,LCHAR
	POPJ	P,

RCH:	PUSHJ	P,@CHARI	;Read an untranslated char
	MOVE	A,TRNTBL(A)	;Translate
	MOVE	B,CDTAB(A)	;Get char description bits
RWID:	MOVE	D,A		;Get width
	ADD	D,IFNIDX
	MOVE	D,WIDTHS(D)
	POPJ	P,

LTYI:	MOVE	A,CHARI1	;reread last char
	MOVEM	A,CHARI		;reset chari
	MOVE	A,LCHAR
	MOVE	B,CDTAB(A)
	POPJ	P,

RTYI:	SOSGE	RANCNT		;input from rantxt
	JRST	RTY1		;nothing left
	ILDB	A,RANOPT
	POPJ	P,
RTY1:	SETZM	RANCNT		;reset counters
	MOVE	A,[440700,,RANTXT]
	MOVEM	A,RANIPT
	MOVEM	A,RANOPT
	PUSHJ	P,FTYION
	JRST	FTYI		;get char from file

RTYION:	SKIPA	A,[RTYI]
FTYION:	MOVEI	A,FTYI
TYION:	MOVEM	A,CHARI1	;change CHARI
	EXCH	A,CHARI		;return old CHARI
	POPJ	P,
FTYI:	ILDB	A,INPTR		;read char from file
	MOVE	B,ICDTAB(A)
FTYI1:	XCT	FTYITB(B)
	POPJ	P,

FTYITB: REPEAT CIDXL,POPJ P,
LOC FTYITB+CEOFX
	JRST	RDFCC
LOC FTYITB+CLNFX
	AOS	INLINE
LOC FTYITB+CFFDX
	JRST	RPAK
LOC FTYITB+CIDXL

RPAK:	AOSN	LCHAR
	POPJ	P,		;quoted ^L
	AOS	INPAGN		;count input file page #
	MOVEI	A,1
	MOVEM	A,INLINE
	JRST	FTYI		;Read another char

RDFCC:	MOVE	L,INPTR		;read a ^c from file
	CAMN	L,IEOFP
	JRST	RCHEOF		;Real end of file
	CAME	L,[350700,,RCHBFE]
	POPJ	P,		;Not end of buffer, real ^C
REFILL:	MOVE	A,[-200,,RCHBUF]
	.IOT	UTYIC,A
	HRRZM	A,BLKIP
	JUMPL	A,REFEOF	;end of file in this block
	SETZM	IEOFP
REFIL1:	MOVE	A,[10700,,RCHBUF-1]
	MOVEM	A,INPTR
	JRST	FTYI

REFEOF:	HLL	A,RCHBFE
	HLLZM	A,(A)		;make sure of end of file char
	MOVE	L,A
	HRLI	L,350700	;make b byte pointer
REDBP:	PUSHJ	P,DECBP		;decrement it
	CAMN	L,[10700,,RCHBUF-1]
	JRST	REDBP3		;at start of buffer
REDBP1:	LDB	A,L
	JUMPE	A,REDBP		;null
	CAIE	A,^C
	CAIN	A,^L
	JRST	REDBP		;not yet backed past eof
REDBP2:	ILDB	A,L		;found 1st char before eof, now go back to eof
	CAIE	A,^C
	JRST	REDBP2
	MOVEM	L,IEOFP
	JRST	REFIL1
				;bletch, eof was in previous buffer
	PUSH	P,H
	JSP	H,CHRC		;traps if not ^c or ^l
	 QPEOF
REDBP3:	SOJGE	C,.-2
	POP	P,H
	SETZ	C,
	JRST	QPEOF1

QPEOF:	TLNE	B,CEOFF
	POPJ	P,		;this char can appear at or after eof
	POP	P,
QPEOF1:	MOVEM	C,MXPF
	MOVEM	C,MXPF1
	JRST	RCHEOF

DECBP:	ADD	L,[70000,,0]	;decrement byte pntr in L
	SKIPGE	L
	SUB	L,[430000,,1]
	POPJ	P,

;stuff to output to file
DAMBUF:	PUSH	P,A
	MOVE	A,[-OBSIZ,,OUTBUF]
	.IOT	UTYOC,A		;block mode .IOT
	MOVEI	A,OBSIZ*5
	MOVEM	A,OUTCNT
	MOVE	A,[440700,,OUTBUF]
	MOVEM	A,OUTPTR
	POP	P,A
BUFOUT:	SOSGE	OUTCNT		;block mode
	JRST	DAMBUF
	IDPB	A,OUTPTR
	POPJ	P,

UNITYO:	.IOT	UTYOC,A		;unit mode
	POPJ	P,


;Low level printing routines
OPCRLF:	MOVEI	A,^M
	PUSHJ	P,@TYRFL
	MOVEI	A,^J
	JRST	@TYRFL

OPFF:	SKIPA	A,[^L]
OPSP:	MOVEI	A,40
	JRST	@TYRFL

OPDOT:	SKIPA	A,[".]
OPCOMA:	MOVEI	A,",
	JRST	@TYRFL

OPOPAR:	SKIPA	A,["(]
OPCPAR:	MOVEI	A,")
	JRST	@TYRFL

PGNPT:	SKIPG	A,CHAPNO	;print page & chapter
	JRST	PGNPT1		;no chapter
	PUSHJ	P,DPT		;print it
	PUSHJ	P,OPDOT
PGNPT1:	MOVE	A,OUTPAG
DPT:	JUMPGE	A,DPT2
	MOVNS	A
	SKIPA	B,["- - "0]
DPT2:	IDIVI	A,10.		;decimal output routine
	HRLM	B,(P)		;store digits in lefthalf of pdl words
	JUMPE	A,DPT1
	PUSHJ	P,DPT2		;more digits to come
DPT1:	HLRZ	A,(P)		;get digits off pdl again
	ADDI	A,"0
	PUSHJ	P,@TYRFL
	POPJ	P,

OCPT:	IDIVI	A,10		;octal print
	HRLM	B,(P)
	JUMPE	A,DPT1
	PUSHJ	P,OCPT
	JRST	DPT1

PSTN:	PUSHJ	P,OPSTH		;print ASCIZ string, number, CRLF
	MOVE	A,K
PSTN1:	PUSHJ	P,DPT
	JRST	OPCRLF

OPSTH:	HRLI	H,440700
	JRST	.+2
	PUSHJ	P,@TYRFL
	ILDB	A,H
	JUMPN	A,.-2
	POPJ	P,

OPSTHC:	PUSHJ	P,OPSTH		;print string, then crlf
	JRST	OPCRLF

OPINAM:	MOVEI	K,DNAM		;input file name
;output file name at k
OPFNM:	HRLZ	H,(K)		;device
	PUSHJ	P,OP6BT
	MOVEI	A,":
	PUSHJ	P,@TYRFL
OPFNM1:	MOVE	H,3(K)		;sys name
	PUSHJ	P,OP6BT
	MOVEI	A,";
	PUSHJ	P,@TYRFL
OPFNM2:	MOVE	H,1(K)		;1st name
	PUSHJ	P,OP6BT
	MOVEI	A,40
	PUSHJ	P,@TYRFL
	MOVE	H,2(K)		;2nd name
	JRST	OP6BT

OPFNMA:	HRRZ	H,(K)		; Output possibly foreign font file name.
	CAIE	H,(SIXBIT /DM/)
	 CAIN	H,(SIXBIT /MC/)
	  JRST	OPFNM
	CAIN	H,(SIXBIT /ML/)
	 JRST	OPFNM
	JRST	OPFNM1

	LDB	A,[360600,,H]
	LSH	H,6
	ADDI	A,40		;convert to ascii
	PUSHJ	P,@TYRFL
OP6BT:	JUMPN	H,.-4		;output 6bt in h
	POPJ	P,

OPDECK:	IDIVI	K,1000.		;print "decimal" # in k
	MOVE	A,K
	PUSHJ	P,DPT		;print to left of decimal
	SKIPN	K,L
	POPJ	P,		;nothing to right of .
	PUSHJ	P,OPDOT		;print .
	IDIVI	K,10.
	PUSH	P,L
	IDIVI	K,10.
	MOVEI	A,"0(K)
	PUSHJ	P,@TYRFL
	MOVEI	A,"0(L)
	PUSHJ	P,@TYRFL
	POP	P,A
	ADDI	A,"0
	JRST	@TYRFL

SPUMPB:	ADD	B,MARGIN	;sp or underlin
SPUL:	JUMPLE	B,SPARET
	MOVE	A,ULFNT
	CAME	A,FONTD
	SKIPE	ULD
	JRST	.+2
	JRST	SPAZIG		;space
	MOVEI	A,"_
	JRST	SPAZI2

SPMPB1:	MOVE	G,B		;use real spaces
	IDIV	G,WIDTH
	SKIPA	B,G
SPAZIG:	PUSHJ	P,SPNULF	;insert b spaces
SPAZI1:	JUMPLE	B,SPARET
	MOVEI	A,40
SPAZI2:	PUSHJ	P,@CHARO
	SOJG	B,.-1
SPARET:	POPJ	P,

SPMPB:	SKIPE	CONTEN
	JRST	SPMPB1
	MOVE	G,MARGIN	;space to margin +b raster dots
	IMUL	G,WIDTH
	ADD	G,B
	JRST	OPRAST

SPMBSP:	ADD	B,MARGIN	;space to margin + B spaces
	JUMPGE	B,SPB
	SKIPGE	MARGIN
	BARF TW>PW		;margin is negative
	SETZB	B,MARGIN
SPB:	PUSHJ	P,FIXUSE	;turn off underlining
SPB1:	SKIPE	XGPMOD		;space to b spaces
	SKIPE	CONTEN
	JRST	SPAZI1
	MOVE	G,B
	IMUL	G,WIDTH
OPRAST:	PUSHJ	P,OPESC1	;tab to raster position in g
	MOVEI	A,XRASET
	PUSHJ	P,BUFOUT
	LDB	A,[70700,,G]
	PUSHJ	P,BUFOUT
	MOVE	A,G
	JRST	BUFOUT

OPCINC:	PUSHJ	P,OPESC2	;output column increment in k
	MOVE	A,K
	ADD	G,K
	JRST	BUFOUT

;fix underline state and font
SPNULF:	PUSHJ	P,FIXUSE	;fix underline state
OPFNTZ:	TDZA	A,A		;space in font 0
OPFNTD:	MOVE	A,FONTD
OPFNTA:	SKIPE	XGPMODE		;output font command, font in a
	CAMN	A,FONTC
	POPJ	P,		;not xgp, or right font
	SETZM	LBLPOS		;font change resets base line
	MOVEM	A,FONTC		;current font
	SKIPE	CONTEN
	POPJ	P,
	PUSHJ	P,OPES1A	;output escape 1,then a
OPBASE:	MOVE	A,BLPOS		;output base line position from blpos
	SKIPE	XGPMOD
	CAMN	A,LBLPOS
	POPJ	P,
	MOVEM	A,LBLPOS
	SKIPE	CONTEN
	POPJ	P,
	MOVEI	A,XBASCH
	PUSHJ	P,OPES1A
	MOVE	A,BLPOS
	JRST	BUFOUT

;fix underline state
FIXUSE:	TDZA	A,A		;end uderscore
FIXUS:	MOVE	A,ULD
	EXCH	A,ULC
	SKIPE	XGPMOD
	CAMN	A,ULC
	POPJ	P,		;current state is desired one
	SKIPN	CONTEN
FIXUSP:	JRST	@FIXUST(A)
	POPJ	P,

	OPESCR
FIXUST:	OPBSCR			;idx by -1

;output begin underscore
OPBSCR:	MOVEI	A,STRTUL
	JRST	OPES1A

;end underscore
OPESCR:	PUSHJ	P,OPSTPU
	MOVE	A,ULBASO	;where to underline
	PUSHJ	P,BUFOUT
	PUSHJ	P,OPSTPU
	MOVE	A,ULBASO
	SOJA	A,BUFOUT	;another one one dot down

OPSTPU:	MOVEI	A,STOPUL
OPES1A:	PUSH	P,A
	PUSHJ	P,OPESC1	;output escape 1,
	JRST	OPPA		;then a

OPESC2:	SKIPA	A,[2]
OPESC1:	MOVEI	A,1		;output xgp escape 1
OPESCA:	PUSH	P,A		;output escape then a
OPESPA:	MOVEI	A,XGPESC	;escape, then pushed a
	PUSHJ	P,BUFOUT
OPPA:	POP	P,A		;pushed a
	JRST	BUFOUT

;Loop untill fill or adjusted, long enough to output
;Unfilled, centered, etc. untill eol
RLOOPX:	XCT	RLTBL(A)	;pushj p, jsp h, or jrst
	JUMP	RLOOPI		;for JRST @(H), noop otherwise
RLOOP:	CAMLE	C,MXPF
	MOVEM	C,MXPF		;furthest into buffer we have been
	PUSHJ	P,RCH		;read char in a, bits in b
RLOOP2:	TLNE	B,CEOSF+CEOCF+CQUOF+CHHYF+CDUMF+CHYPF
	JRST	RLOOPS
	CAIG	A,40
	JRST	RLOOPX
RLOOPI:	PUSHJ	P,BE		;put goodie in a into buffer
RLOOP1:	CAIGE	C,BUFSIZ-1
	AOJA	C,RLOOP
	JRST	MNBRR		;line too long, print it

;Here if .!? ;: quote hidden - dummy or hyphen
RLOOPS:	TLNE	B,CEOSF+CEOCF
	JRST	RDOT		;!?. or ;:
	TLNE	B,CDUMF
	JRST	RDDUM		;dummy
	TLNE	B,CHYPF
	JRST	RDHYP		;-
	TLNE	B,CQUOF
	JRST	RDQUO		;gobble next unconditionally
	JUMPLE	C,RLOOP		;hidden hyphen, ignore in 1st col
	SOJ	C,		;put in previous col
	SETZ	D,
	PUSHJ	P,BE		;store
	MOVE	A,IFNIDX
	MOVE	A,WIDTHS+"-(A)
	ADDI	A,ARGBIT	;Store width of - as arg
	JRST	RLOOPI

RDHYP:	PUSH	P,D
	PUSHJ	P,RURCH
	POP	P,D
	MOVEI	A,"-
	TLNE	B,CHYPF
	ADDI	A,XQUOBT	;Quote first - to prevent break in middle of dash
	JRST	RLOOPI

RDDUM:	PUSHJ	P,RDUM
	JRST	RLOOP1

RDUM:	MOVEI	A,40		;dummy, quoted space
	JRST	RQUOT1

RDQUO:	PUSHJ	P,RQUOT
	JRST	RLOOP1

;here on quote char
RQUOT:	SETOM	LCHAR		;kluge so that ^l can be quoted
	PUSHJ	P,@CHARI	;gobble another guy, untranslated
	SETZM	LCHAR
RQUOT1:	PUSHJ	P,RWID
	ADDI	A,XQUOBT
	JRST	BE		;store the quoted char

;DISPATCH TABLE FOR RLOOP, READIN
;Called with XCT RLTBL(A), table contains JSP H, to know who did XCT
;NOTE THIS TABLE INCLUDES SPACE (for RLOOP only)
RLTBL:	REPEAT 41,JSP H,RLDEF	;All but following simply default
LOC RLTBL+BLDCH
	PUSHJ	P,RBLD		;base line down
LOC RLTBL+DATCH
	PUSHJ	P,ADATE		;date
LOC RLTBL+SFCH
	PUSHJ	P,RFNT		;select font
	PUSHJ	P,RDGEN		;^G .GENNUM
	PUSHJ	P,RDBS		;^H
	JSP	H,RDTAB		;^I TAB
	JSP	H,RDLF		;^J Line feed
	PUSHJ	P,RBLU		;^K Base line up
	JSP	H,RLDEF
	JSP	H,RDCR		;^M CR
	PUSHJ	P,AFNAME	;^N file name
LOC RLTBL+BLZCH
	PUSHJ	P,RBLZ		;^W Zero base line
	PUSHJ	P,RESCR		;^X End score
	PUSHJ	P,R1CMD		;^Y Begin underscore
LOC RLTBL+40
	JRST	RDSP		;Space (only called from RLOOPX)

RLDEF:	JRST	@(H)		;simply return to where indicated at call

RDTABF:	MOVEI	A,40
RDSP:	SKIPE	SPFLSF		;Here if char is a space
	JUMPE	C,RLOOP		;Ignore leading spaces in adjust mode
RDSP1:	PUSHJ	P,BE		;Stow it
RDSPC:	PUSHJ	P,RCH		;Here if char we put in buff acts like a space
	TLNE	B,CFSPF
	JRST	RDFLSP		;Treat series of spaces and tabs like one
RDSPC1:	TLNE	B,CEOLF
	AOJA	C,RLOOPX	;Handle CR&LF now to avoid extra blank lines
	PUSHJ	P,UNCH
RDOTST:	XCT	OPTST
	JRST	RLOOP1
	JRST	MNBRR		;Enough for output

RDFLSP:	SKIPE	SPFLSF
	JRST	RDSPC		;Flushing spaces in middle of line
	AOJA	C,RDSP1		;Stow it

;Tab handling routines
RDTAB:	HRRZ	H,H
	CAIE	H,RLOOPX+1
	JRST	RDTAB1		;Called from readin
	SKIPE	SPFLSF
	JRST	RDTABF		;flushing redundant spacing
	SKIPN	XGPMOD
	JRST	RDTAB1
	MOVEI	B,10(C)
	LSH	B,-3
	IMUL	B,TABW
	CAML	B,XLNL
	JRST	MNBRK		;output the line
RDTAB1:	PUSH	P,H		;where to popj to
	SKIPN	XGPMOD
	JRST	RETAB
				;var width tab
RVTAB:	MOVE	A,NXLC1		;size of tab=(10-(c+nxlc1)!7)*width
	ADD	A,C
	ANDI	A,7
	MOVEI	D,10
	SUB	D,A		;# of columns taken by this tab
	ADDI	C,-1(D)		;put tab in 7'th mod 10 column
	CAIL	C,BUFSIZ-1
	JRST	RVTAB1		;buffer full
	MOVE	D,WIDTH
	IMULI	D,1(C)		;absolute distance from start of text on this line
	SUB	D,W		;size of tab
	JUMPG	D,.+3
	ADD	D,TABW		;in case user made width too small
	JUMPLE	D,.-1
	MOVEI	A,TABCH+SCBIT
	PUSHJ	P,BE		;put tab in buf
	MOVEI	A,ARGBIT+1(C)	;column for next char as arg
	PUSHJ	P,BE
	PUSHJ	P,BE3		;fix column width
	AOJA	C,RETABP

RVTAB1:	POP	P,		;fix stack
	MOVEI	A,^I		;for unch
	JRST	MNBRK		;print line

RETAB1:	MOVE	A,C
	ADD	A,NXLC1
RETABP:	POPJ	P,
RETAB:	PUSHJ	P,BESP
	AOJA	C,RETAB1

;read single char subrs

;change font
RFNT:	PUSHJ	P,RCH
	CAIN	A,"*		;^F* means pop ring buffer
	JRST	RFNT4
	PUSHJ	P,TSTFNC	;convert to font & test
	POPJ	P,		;bad font #
	AOS	H,FNTRPT	;bump font ring pointer
	CAIL	H,LFNTRNG
	SETZ	H,
	MOVEM	H,FNTRPT
	MOVE	D,IFNT		;push old font onto ring
	MOVEM	D,FNTRNG(H)
RFNT2:	MOVEM	A,IFNT		;install new input font #
	MOVE	H,A
	IMULI	H,FNTBKL
	MOVEM	H,IFNIDX
	PUSH	P,A
	MOVEI	A,SFCH
RFNT1:	PUSHJ	P,R1CMD		;put a in buffer
	POP	P,A
	CAILE	A,77
	ANDI	A,77
	ANDI	A,177
	TROA	A,ARGBIT
R1CMD:	ADDI	A,SCBIT		;single char command, just put in buffer
	JRST	BE

RFNT4:	MOVE	H,FNTRPT	;handle ^F*
	SKIPGE	A,FNTRNG(H)	;if top entry on ring is -1,
	JRST	FNOPOP		; then the ring has been overpopped
	SETOM	FNTRNG(H)	;set vacated entry to -1
	SOSGE	H		;decrement ring pointer
	MOVEI	H,LFNTRNG-1
	MOVEM	H,FNTRPT
	JRST	RFNT2		;go install new input font #

FNOPOP:	BARF Font overpop
	POPJ P,

;get font # in k, skip if valid, barf if not
GFONTN:	PUSHJ	P,GNUMAR
	JUMPE	H,GFONER	;no font #
	SKIPA	A,K
;test font char in a
TSTFNC:	SUBI	A,"0		;convert to #
	JUMPL	A,.+3
	CAIG	A,MAXFNT
	AOSA	(P)		;skip return
GFONER:	BARF Bad font #
POPJP:	POPJ	P,

;end underscore, store at end of previous column
RESCR:	JUMPLE	C,RESCR1	;jump if no previous column
	PUSH	P,[RESCR2]	;return to RESCR2 from RESCR1
	SOJA	C,RESCR1	;dec C, and call rescr1 as subr
RESCR2:	AOJA	C,POPJP

RBLZ:	PUSH	P,[0]		;zero base line
RBLS:	SKIPA	A,[BLSCH]	;here to set base to (p)
RESCR1:	PUSH	P,ULBASI
	JRST	RFNT1

RBLU:	SKIPA	A,BLAMT		;read base line up
RBLD:	MOVN	A,BLAMT		;read base line down
	PUSH	P,A
	MOVEI	A,BLICH		;increment base line
	JRST	RFNT1

;^G gennum 1<counternum>
RDGEN:	PUSHJ	P,RDNUM		;read number from text
	MOVEI	D,1
	JRST	AGENN2

;read a number, leave in K, skip if there is a number, 0 in K as default
RDNUM:	SETZB	K,G
RDNUM1:	PUSHJ	P,@CHARI
	CAIL	A,"0
	CAILE	A,"9
	JRST	RDNUM2
	IMULI	K,10.
	ADDI	K,-"0(A)
	SOJA	G,RDNUM1

RDNUM2:	JUMPN	G,UNCH		;did read a number
	AOJA	K,UNCH		;return 1 as default

;this and next page decides if the . is of the type found ending sentences
;if so stores it as .+bkbit, and puts 2 marked spaces afterwards
;if . is .?!, then it is prefered in justification, & stored with jusbit.

;ab.cd

;the . will always be the end of clause or sentence
;if c is a cr or lf, otherwise
;the point will not be used in justifying
;and will not have two marked spaces put after it, if:
;0 b is a number
;1 b is a letter and a is a space or .
;2 c is not a sp tab cr lf ) " ' ]
;3 c is a ) ] " ' and d is not a sp, tab cr lf

;here from slt if a ends a sentence or clause (.?! ;:)
RDOT:	MOVEM	A,DOTPOS	;save the . or ? or :
	MOVEM	B,DOTPOB	;type of .
	MOVEM	D,DOTWID	;width
	PUSHJ	P,RURCH		;look at next char
	TLNE	B,CEOLF
	JRST	RDBK		;. followed by cr or lf
	TLNE	B,CFSPF+CLOSF
	SKIPN	MID.F
	JRST	RDNBK		;in fill mode, or next char not sp or close
	SOJL	C,RDL4A
	JSP	H,CHRC		;see what the chr before the . is 
	 QRB.			;trap out on not letter
	SOJL	C,RDL4C
	JSP	H,CHRC		;look at chr before that
	 QRB1.			;trap out on not space or .
	ADDI	C,2
RDNBK:	PUSHJ	P,BEDOT		;here if not a break, just store .
	JRST	RLOOP1		;go on as usual

QRB.:	TLNN	B,CLETF+CDUMF	;check before .
	TRNE	A,XQUOBT
	POPJ	P,		;it's a letter
	POP	P,
	TLNE	B,CDIGF
	AOJA	C,RDNBK
RDL4A:	AOJA	C,RDAF.		;look after .

QRB1.:	TLNN	B,CSMSF+CEOCF+CEOSF	;check 2 before .
	TRNE	A,MKBIT+BKBIT
	POPJ	P,		;it's sp or .?!;:
	POP	P,
RDL4C:	AOJA	C,RDL4A

;chars before . ok, look after
RDAF.:	PUSHJ	P,RURCH
	TLNE	B,CFSPF+CEOLF
	JRST	RDBK		;. followed by sp tab cr lf
	TLNN	B,CLOSF
	JRST	RDNBK		;not )
RDAF1:	EXCH	A,DOTPOS
	EXCH	D,DOTWID
	PUSHJ	P,BE
	PUSHJ	P,RNCH		;read next chr
	TLNE	B,CLOSF
	AOJA	C,RDAF1		;it's another )"]
	PUSHJ	P,UNCH
	TLNN	B,CEOLF+CFSPF
	AOJA	C,RDNBK		;not cr lf sp tb
	AOJ	C,

RDBK:	MOVE	A,DOTPOS	;this . ends a clause or sentence
	MOVE	B,DOTPOB
	MOVE	D,DOTWID
	ADDI	A,BKBIT
	TLNE	B,CEOSF
	ADDI	A,JUSBIT	;prefer for justification also
	PUSHJ	P,BE		;put in . with appropriate bits
	AOJ	C,
	PUSHJ	P,BEMIN		;stow marked space
	AOJA	C,RDSP1		;pretend we just read a cr

;this page handles the end of an input line
RDCR:	HRRZ	H,H
	CAIE	H,RLOOPX+1
	JRST	RECR
	SKIPE	CRBRF
	JRST	RDCR2		;break on all crs
	SKIPN	CRCOMFL		;here on cr
	JUMPE	C,MNBRR
RDCR2:	PUSHJ	P,RCH
RDCR1:	CAIE	A,^J
	PUSHJ	P,UNCH		;next char not lf
	SKIPE	CRBRF
	JRST	RDEOL2		;break on all crs
RDLF1:	JUMPE	C,RDEOL1	;don't put in space if nothing on line
	PUSHJ	P,GLC		;get last char in a
	CAIE	A,40
	CAIN	A,40+MKBIT
	SOJA	C,RDEOL		;marked space or space
	PUSHJ	P,BESP		;otherwise, put in space
				;C now points to space at end of buffer
RDEOL:	XCT	OPTST		;here on end of line (also after non-autob command)
	JRST	RDEOL1		;not enough for an output line
RDEOL2:	MOVEI	B,LTYI
	CAME	B,CHARI
	PUSHJ	P,UNCHCR
	JRST	MNBRR		;enough, first finish last line
RDEOL1:	SKIPE	CONTEN		;here when finished with eol calls
	PUSHJ	P,CONTES	;listing contents
RD1ST:	PUSHJ	P,RCH		;first char of next input line
	SKIPE	CRCOMF
	JRST	.+3
	CAIN	A,^M
	JUMPN	C,MNBRK
	CAIN	A,".
	JRST	RDF.		;it's a command
	TLNE	B,CFSPF
	JRST	RDFSP		;first on new line is space
RD1ST1:	JUMPN	C,RDSPC1
	JRST	RLOOP2

RDLF:	HRRZ	H,H
	CAIN	H,RLOOPX+1
	JRST	RDLF1
	JRST	REOL

RDFSP:	SKIPE	SPSPF		;1st on next line is sp
	JRST	RDFSNB		;don't break on spaces
	PUSHJ	P,RDFSPS
	JUMPN	C,MNBRR
	JRST	MNLP		;will wipe out .un?

RDFSNB:	SKIPN	SPFLSF		;here if not breaking on spaces
	JRST	RD1ST1		;jump if not flushing spaces
	JUMPN	C,RDSPC		;if in middle of line, just go to where space is read
	JRST	RLOOPX

RDFSPS:	MOVEI	K,1
	CAIE	A,40
	MOVEI	K,10
	ADDB	K,NXLSPC	;add in space count
	CAML	K,TW
	PUSHJ	P,RDBUST
	PUSHJ	P,RCH
	TLNE	B,CFSPF
	JRST	RDFSPS		;another space next on line
	JRST	UNCH

RDBUST:	BARF Too many leading spaces
	SETZM	NXLSPC
	POPJ	P,

CONTES:	SKIPN	OUTFLS
	AOSG	CNTFL		;flag setomed by commands
	POPJ	P,		;haven't read text lie
	PUSHJ	P,UNCHCR	;make cr last char
CONPRN:	SETOM	CONFLG
	JUMPN	C,CONPR1	;output cruft
	SETZM	CONFLG
	JRST	SECTN		;put in page number

CONPR1:	POP	P,
	JRST	MNBRR

RDBS:	SOJL	C,RDBS1		;here on bs
	JSP	H,CHRC		;see if previous chr is space or marked space
	 QBS
	POPJ	P,

RDBS1:	BARF Backspaced too far
	SETZ	C,
	POPJ	P,

QBS:	TLNE	B,CSMSF		;predicate used by rdl1
	BARF Backspaced over space 
	POPJ	P,

BEDOT:	MOVE	A,DOTPOS
	MOVE	D,DOTWID
	JRST	BE
BEMIN:	SKIPA	A,[40+MKBIT]
BESP:	MOVEI	A,40
	MOVE	D,IFNIDX
	MOVE	D,WIDTHS+40(D)

;put char at end of chain at c
BE:	CAILE	C,BUFSIZ-1
	JRST	BELTL		;no space in line buffer for this char
	SKIPE	B,BUFF(C)	;put (a) in buffer at c
	JRST	BE1		;need to grovel along chain
	HRLZM	A,BUFF(C)	;space existed, just put it in
BE2:	SKIPE	XGPMOD
	TRNE	A,SCBIT+ARGBIT
	POPJ	P,
BE3:	SUB	D,COLWID(C)	;difference in column size
	JUMPLE	D,BER		;this column already as wide as this char
	ADDM	D,COLWID(C)	;new size of this column
	ADD	W,D
BER:	POPJ	P,

BE1:	MOVEI	F,BUFF(C)	;pntr to head of chain
	MOVE	B,F
	HRRZ	F,(B)		;cdr
	JUMPN	F,.-2		;more to chain
	PUSHJ	P,CONS		;free space pointed to by F
	HRRM	F,(B)		;add F to end of chain
	HRLZM	A,(F)		;store char
	JRST	BE2

;trying to put char past end of buffer
BELTL:	AOS	C,LTLF
	CAIG	C,1		;skip if error message already printed for this line
	BARF Line too long
	MOVE	C,BUFSIZ-1
	POPJ	P,

;apply test to character chain at c, called with jsp h,
;(h)	;test predicate (either returns or goes on of its own)
;1(h)	;return
CHRC:	SKIPA	I,BUFF(C)
CHRC1:	MOVE	I,(I)		;next word in chain
	HLRZ	A,I		;char
	CAIN	A,SCBIT+TABCH
	JRST	CHRC4		;variable width tab
	TRNE	A,SCBIT+ARGBIT
	JRST	CHRC2		;command char or argument
	SETZ	B,
	CAIGE	A,200
	MOVE	B,CDTAB(A)
	CAIN	A,40+MKBIT
	MOVSI	B,CSMSF
CHRC3:	PUSHJ	P,@(H)		;call test function
CHRC2:	TRNE	I,-1		;skip if no next char
	JRST	CHRC1
	JRST	1(H)		;return

CHRC4:	MOVEI	B,ICDTAB+^I	;get bits for tab
	JRST	CHRC3

;get last char of column pointed to by c
GLC:	SETZ	A,
	SKIPA	B,BUFF-1(C)
GLC1:	MOVE	B,(B)
	TLNN	B,ARGBIT+SCBIT
	HLRZ	A,B		;save char
	TRNN	B,-1		;more in chain?
	POPJ	P,		;no
	JRST	GLC1

;flush chain of characters starting at buff(c)
FLS:	HRRZ	A,BUFF(C)	;pntr to next char
	SETZM	BUFF(C)
	SKIPN	XGPMOD
	JRST	FLS1
	SUB	W,COLWID(C)
	SKIPGE	W
	SETZ	W,
	SETZM	COLWID(C)
FLS1:	JUMPE	A,FLSR		;jump if no cdr
	HRRZ	B,(A)		;next entry
	EXCH	A,FF		;make ff point to this loc
	HRRZM	A,@FF		;this loc to former ff
	MOVE	A,B
	JRST	FLS1

;flush line just printed
FLSLIN:	SETCM	C,MXPF1		;-c-1
	HRLZ	C,C
	JRST	FLSBU1
FLSBUF:	MOVSI	C,-BUFSIZ
FLSBU1:	PUSHJ	P,FLS
	AOBJN	C,.-1
FLSR:	POPJ	P,

CONS:	MOVE	F,FF		;'expand' buffer storage
	JUMPE	F,SCE
	HRRZ	E,(F)		;by grabbing tail of free storage chain
	MOVEM	E,FF
	SETZM	(F)		;free word pointed to by F
	POPJ	P,

SCE:	BARF Free storage exceeded 
	JRST	ENDAR

;main line for nofill mode
;no justification-do this instead of mnchrr, mnlp1, rch,slt,...
NJMN1:	PUSHJ	P,RCH		;flush previous CR or LF
	CAIN	A,15
	PUSHJ	P,RCH
	CAIN	A,12
	PUSHJ	P,RCH
	CAIN	A,".
	JRST	NJMNC		;command
	TLNN	B,CFSPF
	JRST	NJMN2
	PUSHJ	P,RDFSPS	;increments nxlspc
	MOVE	A,NXLSPC
	MOVEM	A,NXLC1
	ADDM	A,INDS
	SETZM	NXLSPC
	JRST	.+2
NJMN2:	PUSHJ	P,UNCH
	PUSHJ	P,READIT
	XCT	OPTST1
	PUSHJ	P,NJMER
	SKIPN	CONTEN
	JRST	MNPRN
	SKIPN	OUTFLS
	AOSE	CNTFL
	JRST	MNPRN
	PUSHJ	P,PRNTR		;Print contents line
	PUSHJ	P,SECTN
	JRST	MNJ6L

NJMNC:	PUSHJ	P,COMMAN	;Here on command
	JRST	MNLPR

NJMER:	PRINT NOFILL
LTWER:	BARF  line wider than TW
	POPJ	P,
;read in .nofill .center or .spread line
READIT:	SETOM	SEPCHR
READIS:	SETZB	W,MXPF
	SETZB	C,MXPF1
	JRST	READI1
READIX:	XCT	RLTBL(A)
	JUMP	READIN
READI1:	CAMLE	C,MXPF1
	MOVEM	C,MXPF1
	PUSHJ	P,RCH		;get a char
	CAMN	A,SEPCHR
	JRST	REOL		;we are done
	TLNE	B,CQUOF+CDUMF
	JRST	READI4
	CAIGE	A,40
	JRST	READIX
READIN:	PUSHJ	P,BE		;put in buffer
	AOJA	C,READI1

READI4:	TLNN	B,CDUMF
	JRST	REQUO
	PUSHJ	P,RDUM
	AOJA	C,READI1
REQUO:	PUSHJ	P,RQUOT		;quote next char
	AOJA	C,READI1

REOL:	PUSHJ	P,UNCHA
RECR:	MOVEM	A,TERMC
	MOVEM	C,MXPF
	POPJ	P,

;If filling, normal path is
;RLOOP untill enough to output
;MNBRR to decide how much to print
;MNPRN to print, and back to MNLPA
;If in NOFILL mode, path is NJMN1, MNPRN, MNLP
MNBEG:	.CORE	CORSIZ
	.VALUE			;couldn't core down
MNLPR:	PUSHJ	P,UNCHCR	;cause lf to appear as next chr read
MNLP:	SETZB	C,MXPF		;initialise pointers to beginning of buffer
	SETZB	W,MXPF1
MNLPA:	SETZM	LTLF
	SKIPE	C,MXPF
	SKIPN	NXLSPC		;Next line spaces
	SKIPA	A,TW
	SOJA	C,MNLPC1	;some text still in BUFF, finish out rest of line
	MOVE	B,NJMODE	;move in new flags now
	CAME	B,JMODE
	JRST	MNSMOD		;changing output mode
MNLP1:	MOVEM	B,JMODE
	SUB	A,NXLSPC	;calculate new line length
	SUB	A,NINDS
	PUSHJ	P,LNLCHK	;line length check
	PUSHJ	P,NINDC		;fix number of indents
	SKIPE	CMCNT
	JRST	CMEOL		;do end of line command call
	JUMPL	B,NJMN1		;nofill mode
	XCT	OPTST
	JRST	RLOOP		;not enough to output
	SOJA	C,MNLPC

NINDC:	MOVE	A,NXLSPC	;number of spaces to add to beginning of line
	MOVEM	A,NXLC1		;factor in inds due to nxlspc
	SETZM	NXLSPC
	ADD	A,NINDS		;if inds was unlocked
	MOVEM	A,INDS		;spaces to indent
	POPJ	P,		;inds=ninds+nxlspc

MNSMOD:	JUMPE	C,MNSMO1	;here on mode change
	PUSHJ	P,NINDC		;something in buffer
	SOJA	C,MNLPC		;finish line in old mode

MNSMO1:	JUMPGE	B,MNLP1		;if filling, proceed
	PUSHJ	P,UNCHCR	;just switched to nofill
	MOVE	A,TW
	JRST	MNLP1

MNLPC1:	MOVN	B,NXLC1		;something in buffer, or leading spaces
	ADDM	B,INDS
	SETZM	NXLC1
	JRST	MNLPC		;print the line

LNLCHK:	JUMPG	A,.+3		;Check for line length <1
	BARF Line length<1
	MOVE	A,TW
	MOVEM	A,LNL
	IMUL	A,WIDTH
	MOVEM	A,XLNL
	POPJ	P,

;here when it is time to break
MNBRK:	PUSHJ	P,UNCH
MNBRR:	CAMGE	C,MXPF		;here when enough for ouput line
	SKIPA	C,MXPF
MNLPC:	MOVEM	C,MXPF
	SKIPGE	JMODE
	JRST	MNHEM2		;nofill mode
	XCT	OPTST
	JRST	MNHEM		;not enough for one full line
MNLP3:	JUMPE	C,MNLP		;move back over spaces which broke-unless line was blank
	JSP	H,CHRC		;test if last was a space
	 QSPMS			;jumps to mnlp4a,4e,2d on non-space
	SUB	W,COLWID(C)
	SOJA	C,MNLP3		;search until find non-space

QSPMS:	TLNE	B,CSMSF+CFSPF
	POPJ	P,		;it's a space or marked space

	POP	P,		;end of a word
	SKIPN	XGPMOD
	AOJA	C,MNLP2T
	XCT	OPTST1
MNLP2H:	SOJA	C,MNLPBU	;too much for line, back up another word
				;have found word to break at
MNLP2A:	JSP	H,CHRC		;return if no - or hidden -
	 QNHYP
ADTST:	SKIPE	XGPMOD
	JRST	MNLP2E		;we have less than a full line
	MOVE	D,LNL
	CAIE	D,1(C)
	JRST	MNLP2E		;we have less than a full line
	JRST	MNHEM2

MNLP2T:	XCT	OPTST1
	SOJA	C,MNLP2H
	SOJA	C,MNLP2A

QNHYP:	TLNN	B,CHHYF+CHYPF
	POPJ	P,
	TLNE	B,CHYPF
	JRST	BEMIN		;hyphen, add space

	POP	P,
	SKIPN	XGPMOD		;hidden hyhen at end of word we are breaking at
	JRST	HYPTS1
	HLRZ	D,(I)
	SUBI	D,ARGBIT	;Arg is width of hidden -
	ADD	D,W
	CAMLE	D,XLNL		;Room on line for hyphen?
	SOJA	C,MNLPBU	;No
	SETOM	HYPOP
	MOVE	W,D
	JRST	MNLP2E		;adjust

HYPTS1:	CAIGE	D,2(C)		;Room for hidden hyphen?
	SOJA	C,MNLPBU	;no
	SETOM	HYPOP		;indicate we broke on hidden hyphen
	SOJA	D,ADTST


;found a non-break char--back-up one and look for break
MNLPBU:	SUB	W,COLWID+1(C)
	JSP	H,CHRC		;move back to last space or hyphen
	 QBRK			;jumps to MNLP3 on break
	SOJG	C,MNLPBU	;search until find a space or hyphen

	MOVE	C,MXPF		;single word wider than TW
	PUSHJ	P,LTWER
	JRST	MNHEM2		;print it anyway

QBRK:	TLNN	B,CSMSF+CHYPF+CHHYF+CFSPF
	POPJ	P,		;not sp, marked sp, - or hidden -
	POP	P,		;found a break
	JRST	MNLP3		;now move back over space

;no justification needed, eliminate trailing marked spaces & spaces
MNHEM:	jUMPLE	C,MNHEM2
	MOVEI	B,BUFF(C)
	JRST	MNHEM1
MNHFSP:	HRRZS	(B)		;flush sp
	SETZM	COLWID(C)
MNHEMN:	HRRZ	B,(B)
	JUMPE	B,MNHEM3	;nothing more in column
MNHEM1:	HLRZ	A,(B)
	CAIE	A,40
	CAIN	A,40+MKBIT
	JRST	MNHFSP		;sp or marked sp
	TRNE	A,SCBIT+ARGBIT
	JRST	MNHEMN		;command, etc, ignore
	SKIPN	(B)
MNHEM3:	SOJG	C,MNHEM
MNHEM2:	MOVEM	C,MXPF1
	JRST	MNPRN

;here to adjust, C<LNL or W<XLNL
MNLP2E:	MOVEM	C,MXPF1		;pointer to end of what is to go on next line
	SKIPLE	JMODE
	SKIPE	NVRADJ
	JRST	MNPRN		;filling or never adjust
	XCT	OPTST1		;too much input for one line?
	JRST	MNPRN		;yes, couldn't back up far enough

	SETZB	C,NBRKS
	SETZM	NPRDS
MNLP2G:	CAMLE	C,MXPF1
	JRST	MNLP2B
	JSP	H,CHRC		;count spaces and .'s in line
	 QCBRK
	AOJA C,MNLP2G

;counting places used for justifying
QCBRK:	CAIN	A,40
	AOSA	NBRKS		;count breaks - only real spaces
	TRNN	A,JUSBIT
	POPJ	P,
	CAMGE	C,MXPF1
	AOS	NPRDS		;was .?! at end of sentence
	POPJ	P,		;dont count .'s at end of line
;put spaces in
MNLP2B:	SETZM	SPN
	SKIPE	XGPMOD
	SOJA	C,MNJX
	MOVE	H,LNL
	SUB	H,MXPF1		;amount of space needed
	SKIPE	HYPOP
	SOJ	H,		;one less for hidden hyphen
	SOJL	H,MNJERR
	JUMPE	H,MNPRN		;don't need any (probably because of hidden hyphen)
	MOVEM	H,SPN		;spaces total needed
	MOVE	A,NPRDS
	ADD	A,NBRKS
	JUMPE	A,MNHEM2	;no place to put spaces
MNJ1B:	SETCMM	DIRSCN		;complement scan direction
	SKIPN	NPRDS
	JRST	MNJ1		;no .'s
	HRLZS	H		;insert spaces at periods first
	IDIV	H,NPRDS		;spaces per period _18.
	PUSHJ	P,SINCRC

	JSP J,SCNR1		;put spaces at end of sentences
	 QJUS

MNJ1:	SKIPN	NBRKS
	JRST	MNJ9		;no spaces exist
	HRLZ	H,SPN
	JUMPE	H,MNPRN		;need no more spaces
	IDIV	H,NBRKS		;spaces per space _18.
	PUSHJ	P,SINCRC

	JSP	J,SCNR1		;put spaces after spaces
	 QRS

MNJ9:	SKIPN	H,SPN		;have we put in all needed justification spaces?
	JRST	MNPRN		;yea team
	AOSN	JERRF		;needed more than one space per break?
	JRST	MNJ1B		;yes, so go it once more
	JRST	MNJERR

QRS:	CAIE	A,40		;skip if real space
	POPJ	P,
QRS1:	POP	P,
	JRST	2(H)		;condition met, real space (or .)

QJUS:	TRNE	A,JUSBIT	;put spaces after sentences (used by mnj1b)
	CAML	C,MXPF1
	POPJ	P,		;not . or at end of line
	JRST	QRS1

SINCRC:	SETZM	JERRF		;calculate space increment
	ADDI	H,100
	CAML	H,[1,,]		;more than one per break ?
	JRST	SINCR1		;yes
SINCR2:	MOVEM	H,SINCR
	POPJ	P,

SINCR1:	MOVSI	H,1		;put in one space per break this time round
	SETOM	JERRF		;indicate we need to repeat this performance
	JRST	SINCR2

;(j)	routine to test chr
;1(j)	return
SCNR1:	SETZ	K,		;scan and put in spaces for justification
	MOVE	A,DIRSCN	;A set to scan direction
	XCT	SCNT1(A)	;get starting value for c
SCNR3:	XCT	SCNT3(A)	;test c for end
	JRST	1(J)		;done

	JSP	H,CHRC		;use predicate specified by calling routine
	 @(J)			;skip if condition matched

	 JRST	SCNR2		;condition not matched
	ADD	K,SINCR		;spacing increment
	TLZN	K,-1
	 JRST	SCNR2		;don't put one in yet

	SOS	SPN		;reduce count of spaces still needed
	PUSHJ	P,BEMIN		;put in a marked space
SCNR2:	MOVE	A,DIRSCN
	XCT	SCNT2(A)	;increment c and jrst scnr3

;these are executed by scnr1 etc.
;indexed by -1 for backward, 0 for forward
	MOVE	C,MXPF1
SCNT1:	SETZ	C,		;set c to starting value

	SOJA	C,SCNR3		;backward
SCNT2:	AOJA	C,SCNR3		;move forward

	SKIPGE	C
SCNT3:	CAMLE	C,MXPF1		;test c for completion

MNJX:	MOVE	J,XLNL		;line length in xgp dots
	SUB	J,W		;amount of justification needed
	JUMPL	J,MNJERR
	SKIPE	HYPOP
	AOJ	C,
	MOVE	K,J
	SKIPN	LTRSPF		;.LTRSPC 0 suppresses letter-spacing
	TDZA	J,J		; causing inter char space to be zero
	IDIV	J,C		;amount of inter char space
	SETZ	C,
	JUMPE	J,.+2
	PUSHJ	P,MNICS		;set inter char spacing
	JUMPE	K,MNPRN		;inter char space took up all justification
	MOVE	D,NPRDS
	ADD	D,NBRKS
	JUMPE	D,MNPRN		;line is one word!
	MOVNM	K,SPN		;-# spaces needed
	HRLZ	K,K
	IDIV	K,D		;# of xtra dots per space_18.

MNJXSP:	SKIPE	SPN		;put spaces after .s and spaces
	CAML	C,MXPF1
	JRST	MNJX2
	JSP	H,CHRC		;put in adjusting space
	 QSPBR
	AOJA	C,MNJXSP

QSPBR:	CAIE	A,40
	TRNE	A,JUSBIT
	JRST	.+2
	POPJ	P,

	POP	P,		;space or break
	HLRZ	D,K		;integral spacing increment
	ADDI	L,(K)		;L + fractional spacing inc
	CAIGE	L,-1
	JRST	.+3
	SUB	L,[1,,0]	;fractional part overflowed
	AOJA	D,.+2
	JUMPE	D,QSPBR1	;no extra this sp
	ADDM	D,SPN
	MOVEI	A,SCBIT+VSPCH
	PUSHJ	P,BE
	MOVEI	A,ARGBIT(D)
	PUSHJ	P,BE
QSPBR1:	AOJA	C,MNJXSP

MNICS:	PUSH	P,J		;put in inter character spacing
	MOVEI	A,ICSPCH
	JRST	RFNT1

MNJX2:	SKIPE	SPN
MNJERR:	BUG Adjust bug		;still not adjusted (can get here several ways)

MNPRN:	PUSHJ	P,PRNTR		;go output line at last
MNJ6L:	CAML	C,MXPF		;anything left at end of buffer?
	JRST	MNTLC		;no
	JSP	H,CHRC		;flush spaces at end before remaining text
	 QFSPE
;blt remaining text to beginning of buff
MNEBLT:	MOVE	D,MXPF
	MOVE	B,D
	SUBI	B,-1(C)		;# of columns to blt
	HRLZ	A,C
	ADD	A,[BUFF,,BUFF]
	BLT	A,BUFF-1(B)
	SKIPN	XGPMOD
	JRST	MNEBL1
	HRLZ	A,C		;fix up colwid
	ADD	A,[COLWID,,COLWID]
	BLT	A,COLWID-1(B)	;blt to beginning columns
	MOVE	A,C
	HRL	A,A
	ADD	A,[COLWID,,COLWID+1]
	SETZM	COLWID(C)
	BLT	A,COLWID(D)
	SETZB	A,W
	ADD	W,COLWID(A)	;calculate new w for remaining columns
	CAIG	A,-1(B)
	AOJA	A,.-2
MNEBL1:	SETZM	BUFF(C)		;wipe out old stuff
	HRL	C,C
	ADD	C,[BUFF,,BUFF+1]
	BLT	C,BUFF(D)
	MOVEI	C,-1(B)		;end of where we blted to
	JSP H,CHRC
	 QSPEND			;traps to mnlpb if ends with space, 240 or .
	AOJ	C,
	SKIPE	LTLF		;skip if broke because line too long
	PUSHJ	P,BESP		;delimit with space
	AOJA	C,MNLPB

MNTLC:	SKIPE	A,BUFF(C)	;test past last column
	PUSHJ	P,MNFSP		;Do commands there
	JRST	MNLP

QSPEND:	TLNN	B,CSMSF+CFSPF
	TRNE	A,BKBIT
	JRST	.+2		; text ends on space, 240 or .
QSPR:	POPJ	P,
	POP	P,
	AOJ	C,
MNLPB:	MOVEM	C,MXPF
	JRST	MNLPA		;grand exit at last

QFSPE:	TLNN	B,CSMSF+CFSPF
	JUMPN	A,QSPR		;not space or marked space or blank
	POP	P,
	MOVE	A,BUFF(C)
	PUSHJ	P,MNFSP		;do commands before flushing column
	AOJA	C,MNJ6L

MNFSP1:	MOVE	A,(B)
MNFSP:	HRRZ	B,A		;pntr to next char
	HLRZ	A,A		;char
	TRZE	A,SCBIT
	XCT	PRTAB(A)	;do in text command before flushing column
	JUMPN	B,MNFSP1
	JRST	FLS		;finally flush column

CONSTA

;print something
PRNTRA:	SETOM	CENTF		;call from  .space & .center & .page goes here
				;test only --  not line output
PRNTR:	MOVE	A,OUTLIN	;output a line
	CAMGE	A,TL
	JRST	PRNTR1
	PUSHJ	P,NPAGER	;time for a new page
	AOSN	PGCMFL
	JRST	PRNTR9		;doing a .page
PRNTR1:	SKIPN	FPGPOS
	JRST	HEADTY		;time for heading
PRNTR9:	AOSN	CENTF
	POPJ	P,		;don't print (test only)
	MOVE	B,INDS
PRNTR2:	PUSHJ	P,PRNBSP	;print and flush line
PREOL:	SKIPN	HYPOP		;here at end of output line
	JRST	PREOL1
	SETZM	HYPOP
	MOVEI	A,"-
	SKIPN	OUTFLS
	PUSHJ	P,PPAX		;output hidden hyphen
PREOL1:	MOVE	B,LFMD		;here after center, spread
	MOVEM	B,OLFMD
	SKIPN	CONTEN
	JRST	CRRB
	JRST	CRFAKB		;fake crs

;print line in buff from 0 through mxpf1, then flush it
PRNTIT:	SKIPN	OUTFLS
	JRST	PRNTI2
	JRST	FLSLIN
PRNMRG:	SETZ	B,
PRNBSP:	SKIPE	OUTFLS
	JRST	FLSLIN
	SKIPE	CONTEN
	SUB	B,MARGIN	;Don't put in margin for contents
	PUSHJ	P,SPMBSP	;go to marg + b spaces
PRNTI3:	PUSHJ	P,FIXUS		;fix underline
	PUSHJ	P,OPFNTD	;font
	PUSHJ	P,OPBASE	;base line
PRNTI2:	SETZB	C,INCHSP
PRNTI1:	CAMLE	C,MXPF1
	JRST	FLSLIN		;flush and exit
	SKIPE	A,BUFF(C)	;ignore nulls?
	PUSHJ	P,PRC		;print all chars in this column
	AOJA	C,PRNTI1

;print all the chars in column pointed to by c
PRC:	SETZM	C240S		;#of marked spaces
	SETOM	PRNCRS		;#of chars in this column
PRC1:	HRRZ	B,A		;pntr to cdr
	HLRZ	A,A		;car=character
	JUMPE	A,PRC2
	TRZE	A,SCBIT
	JRST	PRCMD		;it's a command
	CAIN	A,40+MKBIT
	JRST	PRCMS		;marked space
	TRNN	A,ARGBIT
	CAMN	A,HYPCHR
	JRST	PRC2		;ignore arguments & hidden hyphen
	AOSN	PRNCRS
	JUMPE	B,PRC3		;jump if only one char this column
	SKIPE	XGPMOD
	JRST	PRCV
	SKIPE	PRNCRS
	PUSHJ	P,PRCBS		;not first char, print back space
PRC3:	PUSHJ	P,PPAX		;print char
PRC2:	JUMPE	B,PRCE		;no next character
	MOVE	A,(B)		;next word
	JRST	PRC1

PRCE:	SKIPLE	PRNCRS		;print end of output column
	SKIPN	XGPMOD
	JRST	PRCE1
	MOVE	K,COLWID(C)
	ASH	K,-1
	ADD	K,HPCW		;-1/2 previous char width
	SKIPLE	K		;skip if prev char as wide as column
	PUSHJ	P,OPCINC	;otherwise, space to end of column
PRCE1:	SKIPG	B,C240S
	POPJ	P,
	SKIPE	XGPMOD
	JRST	SPAZI1		;print marked spaces
	JRST	SPUL

PRCMS:	CAMGE	C,MXPF1		;ignore marked spaces in last col
	AOS	C240S		;marked space
	JRST	PRC2

PRCV:	PUSH	P,A		;so as not to loose xnorf
	ANDI	A,177		;variable spacing
	MOVE	K,OFNIDX
	ADD	K,A
	MOVE	D,WIDTHS(K)	;width of this char
	MOVN	K,D
	ASH	K,-1
	EXCH	K,HPCW		;1/2 previous char width
	SKIPN	PRNCRS
	JRST	PRCV1		;1st char for this column
	ASH	D,-1		;move back 1/2 width this char
	SUB	K,D		;+1/2 width previous char
	SUB	K,INCHSP	;+interchar space
	PUSHJ	P,OPCINC
PRCV1:	POP	P,A
	JRST	PRC3

;fix underline state & font if necessary, then print char
PPAX:	SKIPN	XGPMOD
	JRST	PPAX1
PPAX2:	TRZN	A,XQUOBT
	JRST	@CHARO		;not quoted
	PUSH	P,A
	SKIPE	CONFLG
	JRST	PPAX3		;Printing contents line
	MOVE	A,CDTAB(A)
	SKIPE	XNORF
	TLNN	A,CNNRF
	JRST	OPPA		;Not normalizing, or normal is non-escape
	JRST	OPESPA		;normal is escape

PPAX3:	MOVE	A,NQUOTE	;printing contents
	PUSHJ	P,@CHARO	;print quote
	JRST	OPPA		;print character

;not using xgp
PPAX1:	SKIPE	CONFLG
	JRST	@CHARO
	MOVE	K,FONTD
	CAMN	K,ULFNT
	JRST	PPAUL		;underline this "font"
	SKIPN	ULD		;not xgp, just worry about underlines
	JRST	@CHARO		;no underlines
PPAUL:	PUSHJ	P,@CHARO	;print char
	MOVEI	A,"_
	PUSHJ	P,PRCBS		;print BS
	JRST	@CHARO		;and underbar

PRCBS:	PUSH	P,A
	MOVEI	A,^H		;print bs
	PUSHJ	P,@CHARO
POPAJ:	POP	P,A
	POPJ	P,

;found a command char
PRCMD:	XCT	PRTAB(A)
	JRST	PRC2

PRTAB:	REPEAT 40,.VALUE	;shouldn't get here
LOC PRTAB+TABCH
	PUSHJ	P,PTAB
LOC PRTAB+BLICH
	PUSHJ	P,PBLAD		;increment base line
LOC PRTAB+BLSCH
	PUSHJ	P,PBLS		;base set
LOC PRTAB+BSCRCH
	PUSHJ	P,PBSCR		;begin underscore
LOC PRTAB+ESCRCH
	PUSHJ	P,PESCR		;end underscore
LOC PRTAB+SFCH
	PUSHJ	P,PFNT
LOC PRTAB+VSPCH
	PUSHJ	P,PVRSP		;variable space
LOC PRTAB+ICSPCH
	PUSHJ	P,PSICHS	;set inter char space
LOC PRTAB+40

PBSCR:	SETOM	ULD
	PUSHJ	P,PCTST
	JRST	FIXUS

PESCR:	SETZM	ULD
	PUSHJ	P,PCTST
	PUSHJ	P,PRARG		;end underscore (next char arg)
	MOVEM	A,ULBASO
	JRST	FIXUS

PCTST:	SKIPN	CONFLG
	POPJ	P,		;if not contenting, ignore
	POP	P,		;return up one level
	JRST	@CHARO		;print A

;read argument in 7 bit 2's complement, extend sign
PRARG:	MOVE	A,(B)		;next word
	HRRZ	B,A		;pntr to next
	HLRZ	A,A		;character
	SUBI	A,ARGBIT
	CAIL	A,100
	SUBI	A,200		;negative, extend sign
	POPJ	P,

PBLAD:	PUSHJ	P,PRARG		;adjust base line with next char
	MOVE	K,A
	ADD	A,BLPOS
	CAIGE	A,200
	CAMGE	A,[-200]
	JRST	BLERR
	MOVEM	A,BLPOS
	MOVEI	A,BLUCH
	JUMPG	K,.+2
	MOVEI	A,BLDCH		;base line down
	PUSHJ	P,PCTST
	JRST	OPBASE

BLERR:	BARF Too much script
	POPJ	P,

PBLS:	PUSHJ	P,PCTST
	PUSHJ	P,PRARG		;set base line to next char
	MOVEM	A,BLPOS
	JRST	OPBASE

PFNT:	PUSHJ	P,PRARG		;switch font (next char arg)
PFNT1:	MOVEM	A,FONTD
	IMULI	A,FNTBKL
	MOVEM	A,OFNIDX
	SKIPN	CONFLG
	JRST	OPFNTD
	MOVEI	A,SFCH
	PUSHJ	P,@CHARO	;print ^F
	MOVE	A,FONTD
	ADDI	A,"0
	JRST	@CHARO		;print font #

PVRSP:	SKIPE	CONFLG
	POPJ	P,
	PUSHJ	P,PRARG		;print a variable space
	MOVE	K,A
	JRST	OPCINC

PSICHS:	SKIPE	CONFLG
	POPJ	P,
	MOVEI	A,XICHSP	;set inter-char space
	PUSHJ	P,OPES1A
	PUSHJ	P,PRARG
	JRST	BUFOUT

;print a tab (variable width spacing)
PTAB:	PUSHJ	P,PCTST
	PUSHJ	P,FIXUS		;fix underline state
	MOVE	A,(B)
	HRRZ	B,A
	PUSH	P,B
	HLRZ	B,A		;column # of next char
	ADD	B,INDS
	ADD	B,MARGIN
	PUSHJ	P,SPB1
POPBJ:	POP	P,B
	POPJ	P,

NPAGER:	SKIPGE	PGCMFL		;skip if not doing a .page now
	SETZM	NLFS
	MOVE	B,PL
	SUB	B,FPGPOS
	SKIPN	XGPMOD
	PUSHJ	P,CRRB		;finish off page
	SETZM	OUTLIN		;reset page position
	SETZM	FPGPOS		;full page position
	SKIPE	OUTFLS
	POPJ	P,
	MOVEI	A,^L
	SKIPE	FFFF		;need form feed ?
	JRST	@CHARO		;yes, and no wait for type in (not lpt or tty)
NOISTZ:	MOVE	A,NWAITF
	IOR	A,FFFF
	IOR	A,SLASHT
	IOR	A,OUTFLS
	JUMPE	A,TYI		;if all flags off, wait at top of page for typed char
	POPJ	P,

CRRB:	SKIPE	OUTFLS
	JRST	CRFAKB		;fake b crrs
	JUMPLE	B,CRRET		;do b crlfs
	SKIPN	FFFF
	JRST	CRRB1
	MOVE	A,OUTLIN
	ADD	A,B
	CAML	A,TL
	JRST	CFAKE		;crs will move us past text area
CRRB1:	PUSHJ	P,CRR
	SOJLE	B,CRRET
	AOS	OUTLIN		;update position
	AOS	FPGPOS
	PUSHJ	P,@CHARO	;output a lf
	SOJG	B,.-3
CRRET:	POPJ	P,

CRR:	AOS	OUTLIN		;output a cr and lf and advance the page position
	AOS	FPGPOS
	SKIPE	OUTFLS	
	POPJ	P,
	PUSHJ	P,SPNULF	;end underline, switch to font 0
	SETZM	LBLPOS		;cr resets baseline
CRROF:	MOVEI	A,^M		;here for output which doesn't want to be counted
	PUSHJ	P,@CHARO
	MOVEI	A,^J
	JRST	@CHARO

CFAKE:	MOVE	A,TL		;fake enough crs to get out of text area
	SUB	A,OUTLIN
CRFAK1:	ADDM	A,OUTLIN
	ADDM	A,FPGPOS
	POPJ	P,

CRFAKB:	ADDM	B,OUTLIN	;fake b crlfs
	ADDM	B,FPGPOS
	POPJ	P,

;here when it's time to print heading
HEADTY:	SETOM	RDTXTF
	MOVE	A,EPGIN
	ADDM	A,OUTPAG	;Add in EPAGE increment
	SETZM	EPGIN
	AOS	NPAGES
	AOS	D,OUTPAG
	CAML	D,PNST
	PUSHJ	P,TXSTRT	;time to start output
	SKIPE	FIGP
	PUSHJ	P,FIGTP		;need to put extra lines at top of page due to .figure
	SKIPE	THSFLG
	SKIPA	B,TPMAR3	;thesis mode, put in top marg before header
	MOVEI	B,2		
	PUSHJ	P,CRRB		;TWO (or TPMAR-3) blank lines before header
	SETZM	OUTLIN
	PUSHJ	P,HICTOR	;line of heading
	SKIPN	THSFLG
	SKIPA	B,TPMAR3	;normal mode, put in margin after header
	MOVEI	B,2
	PUSHJ	P,CRRB		;TPMAR-3 (or TWO) blank lines after header
	SETZM	OUTLIN		;reset page position

	HLRZ	B,FIGP		;actually put in figures
HFIG:	PUSHJ	P,CRRB
	HRRZ	A,FIGP		;pntr to next figure
	SETZM	FIGP
	JUMPE	A,PRNTR		;no next figure
	MOVE	B,(A)
	MOVEM	B,FIGP
	EXCH	A,FF		;add word to fs
	HRRZM	A,@FF
	MOVE	A,TL
	SUB	A,OUTLIN	;# of lines left
	HLRZ	B,B		;size of fig
	CAMG	B,A
	JRST	HFIG
	JRST	PRNTR

FIGTP:	SKIPL	PGCMFL		;are we doing a .page ?
	POPJ	P,		;no
	SKIPN	A,FIGP		;yes - so do .epage in effect
	JRST 	FIGTP1		;no figures waiting
	HRRZ	A,A
	SETZM	FIGP
	PUSHJ	P,FLS1		;flush string of waiting figs
FIGTP1:	AOS	D,OUTPAG
	AOS	NPAGES
	SETZM	NLFS
	POPJ	P,

;print line of heading
HICTOR:	SKIPN	OUTFLS
	SKIPE	NHEADF		;do we want heading and page numbers?
	JRST	CRR		;no
	SKIPN	PHP1F
	SOJE	D,CRR		;don't print page 1 header
	PUSH	P,ULD
	PUSH	P,FONTD
	PUSH	P,BLPOS		;save these states
	PUSH	P,ULBASI
	SETZM	ULD		;and intialize them
	SETZM	FONTD
	SETZM	BLPOS
	MOVEI	A,ULBUG
	MOVEM	A,ULBASI
	MOVEM	A,ULBASO

	PUSHJ	P,OPBASE
	MOVE	B,OUTPAG	;page number
	SETOM	SWPFLG		;hack for alternating headings (bkph)
	SKIPE	ALTFLG		;do headings get alternated
	TRNE	B,1		;on odd page ?
	SETZM	SWPFLG		;yes, he1 on left, he2 on right
	SKIPE	HEDSPT
	JRST	HICTOP		;split header
	SKIPE	SWPFLG		;test if header should be on left (bkph) 
	JRST	HIMPLE		;yes, simple margin
	MOVE	B,RNLL
	ADD	B,RMARGIN
	SKIPE	XGPMOD		;in XGP mode?
	JRST	HTYIV
	SUB	B,HBUFC
	PUSHJ	P,HPNCMP	;dec b by # of digits in page #
	PUSHJ	P,SPB		;space up to heading
HTYI2:	PUSHJ	P,PSTRG		;print header
	 HBUFC
	 HBUF
	PUSHJ	P,PGNPT		;print page #
HEND:	PUSHJ	P,FIXUSE	;end underscore
	POP	P,ULBASI
	POP	P,BLPOS
	POP	P,FONTD
	POP	P,ULD
	PUSHJ	P,OPBASE
	JRST	CRR

HIMPLE:	MOVE	B,RMARGIN	;yes, simple margin (bkph)
	PUSHJ	P,SPB		;space up to heading
	JRST	HTYI2

HTYIV:	MOVE	G,B
	IMUL	G,WIDTH		;calculate size of var width header
	SUB	G,HBUFW
	SETZ	B,
	MOVE	H,HDFONT	;Font pg # will be in
	PUSHJ	P,HPCWDR	;Decrement by width of page#
	ADD	G,B
	PUSHJ	P,OPRAST
	JRST	HTYI2

HPNCMP:	SKIPG	A,CHAPNO	;dec b by pg & chap size
	JRST	.+3		;no chapter #
	PUSHJ	P,HNCMP
	SOJ	B,		;account for .
	MOVE	A,OUTPAG
HNCMP:	CAIL	A,100.		;dec b by # of digits in a
	SOJ	B,
	CAIL	A,10.
	SOJ	B,
	SOJ	B,
	POPJ	P,		;assumes not more than 999 pages!

HPCWD:	MOVE	H,FONTD		;for variable width
HPCWDR:	IMULI	H,FNTBKL	;call here for .header
	SKIPLE	K,CHAPNO
	SUB	B,WIDTHS+".(H)
	PUSHJ	P,NUMWID
	MOVE	K,OUTPAG
NUMWID:	JUMPLE	K,NUMWIR
	IDIVI	K,10.
	ADD	L,H
	SUB	B,WIDTHS+"0(L)
	JUMPG	K,.-3
NUMWIR:	POPJ	P,

;print string stored at @1(p), which is @(p) columns
PSTRG:	MOVE	C,@(P)
	MOVE	C,(C)
	MOVEM	C,PSMX		;size of string
	AOS	(P)
	MOVE	C,@(P)		;location of string
	ADDM	C,PSMX
	AOS	(P)
	SETZM	INCHSP
PSTRG1:	CAMLE	C,PSMX
	POPJ	P,
	SKIPE	A,(C)
	PUSHJ	P,PRC
	AOJA	C,PSTRG1

;routine to output split header
HICTOP:	MOVE	B,RMARGIN
	PUSHJ	P,SPB		;output margin
	SKIPN	SWPFLG
	PUSHJ	P,LHEADE	;print header 1
	SKIPE	SWPFLG
	PUSHJ	P,RHEADE	;print header 2
	SETZ	B,		;calculate sign of center field
	SKIPE	XGPMOD
	JRST	HICV
	PUSHJ	P,HPNCMP	;get -size of pg # in b
	ADD	B,RNLL		;sps after he1=linel/2-center fieldsz/2-he1 size
	LSH	B,-1
	SKIPN	SWPFLG
	SUB	B,HBUFC1	;normal
	SKIPE	SWPFLG
	SUB	B,HBUFC2	;swapped
	PUSHJ	P,SPUL		;space or ul
HICTPC:	PUSHJ	P,PGNPT		;print pg & chap
	SKIPE	XGPMOD
	JRST	HICV1
	MOVE	B,RNLL		;# of spaces after center=
	PUSHJ	P,HNCMP
	AOS	B
	LSH	B,-1
	SKIPN	SWPFLG
	SUB	B,HBUFC2	;normal
	SKIPE	SWPFLG
	SUB	B,HBUFC1	;swapped
	PUSHJ	P,SPUL
HICTP4:	SKIPN	SWPFLG
	PUSHJ	P,RHEADE	;print header 2
	SKIPE	SWPFLG
	PUSHJ	P,LHEADE	;print header 1
	JRST	HEND

LHEADE:	PUSHJ	P,PSTRG		;print he1
	 HBUFC1
	 HBUF1
	POPJ	P,

RHEADE:	PUSHJ	P,PSTRG		;print he2
	 HBUFC2
	 HBUF2
	POPJ	P,

;print space after 1st field=linel/2-cent field/2
HICV:	PUSHJ	P,HPCWD		;get size of center field in b
	MOVE	G,RMARGI
	ASH	G,1
	ADD	G,RNLL
	IMUL	G,WIDTH
	ADD	G,B
	ASH	G,-1
	PUSHJ	P,FIXUS		;fix underline state
	PUSHJ	P,OPRAST
	JRST	HICTPC

;print space after center field=linel-2nd field
HICV1:	MOVE	G,RNLL
	ADD	G,RMARGI
	IMUL	G,WIDTH
	SKIPN	SWPFLG
	SUB	G,HBUFW2	;normal
	SKIPE	SWPFLG
	SUB	G,HBUFW1	;swapped
	PUSHJ	P,FIXUS
	PUSHJ	P,OPRAST
	PUSHJ	P,OPFNTZ
	JRST	HICTP4

;Get a Sixbit syllable in H, with decimal number in K
;Terminator in A, index in B
;Flags in Z

CMSYLF==1	;read any SIXBIT character
CMFN1F==2
CMFN2F==4
CMDEVF==10
CMSNMF==20
GSLETF==40	;read a non-digit
GSMINF==100	;read odd number of minus signs
GSNUMF==200	;terminate on a non-digit

GSYLFS:	PUSHJ	P,@CHARI	;flush spaces
	CAIN	A,40
	JRST	.-2
	PUSHJ	P,UNCH
GSYL:	SETZB	H,K
	TLZ	Z,CMSYLF+GSLETF+GSMINF
	MOVE	I,[440600,,H]
	JRST	GSYLI

GSYLTB: REPEAT CIDXL,GSYLT	;all chars terminate except:
	GSILL			;non 6bit
LOC GSYLTB+CLNFX
	GSLF			;linefeed
	GSLET			;UPPER CASE LETTERS
	GSDIG			;0-9
	GSLOW			;lower case letters
	GSMIN			; -
REPEAT 3,GSILL			;rbo, ^L, ^C
	GSQUO			;quote
	GSO6B			;"other" 6bit
LOC GSYLTB+CIDXL

GSLOW:	SUBI	A,40		;convert lower to upper case
GSLET:	TLO	Z,GSLETF	;it's a letter
GSO6B:	TLO	CMSYLF
	TLNE	Z,GSNUMF
	JRST	GSYLT		;but we were trying to read number
GSDIG2:	SUBI	A,40		;convert
	TLNE	I,770000
	IDPB	A,I
GSYLI:	PUSHJ	P,@CHARI	;read char
	JRST	@GSYLTB(B)

GSDIG:	TRNE	H,77
	JRST	GSYLI		;ignore >6 digits
	IMULI	K,10.		;assemble decimal number
	ADDI	K,-"0(A)
GSDIG1:	TLO	Z,CMSYLF
	JRST	GSDIG2		;also add to chr string

GSMIN:	TLNE	Z,GSNUMF
	TLNE	Z,GSLETF
	JRST	GSO6B		;can't be a number
	TLC	Z,GSMINF	;flip minus flag
	JRST	GSYLI		;read more

GSQUO:	PUSHJ	P,@CHARI	;get another char
	CAILE	A,"_
	JRST	GSLOW
	CAIL	A,40
	JRST	GSLET
GSILL:	TRZA	B,B		;give all non 6bit same dispatch #
GSLF:	MOVE	B,ICDTAB+15	;make lf look like cr
GSYLT:	SKIPN	H
	MOVEI	K,1		;if no text, return the number 1 (default value)
	TLNE	Z,GSMINF
	MOVNS	K		;negate it
	MOVEM	A,LCHAR		;save terminator
	TLZ	Z,GSNUMF
	POPJ	P,

;read a number, leave in k returns 1 as default if no arg
GNUMAR:	HRLI	Z,GSNUMF	;break on non-digit
	PUSHJ	P,GSYLFS
	TLZ	Z,GSNUMF
	TLNN	Z,GSLETF
	POPJ	P,
	PUSHJ	P,AERLIN
	BARF  Non-numeric argument 
	POPJ	P,

GFNUM:	PUSHJ	P,GNUMAR	;get "decimal" number
	SKIPN	H
	SOJ	K,GFNUMR	;gnum returned 1 as default!
	CAIE	A,".
	JRST	GFNUM2		;no decimal point
	PUSH	P,K
	PUSHJ	P,GNUMAR
	SKIPE	H
	SKIPN	K
	AOJA	H,GFNUM1	;no or 0 arg
	POP	P,K
	MOVE	I,[440600,,H]
	MOVEI	B,3

	ILDB	A,I		;get one digit
	IMULI	K,10.
	SKIPE	A
	ADDI	K,-'0(A)
	SOJG	B,.-4
GFNUMR:	POPJ	P,

GFNUM1:	POP	P,K
GFNUM2:	IMULI	K,1000.
	POPJ	P,

;in nofill mode, just:  pushj p,comman, jrst mnlpr
;If Filling or Adjusting, come here for . at start of line;
RDF.:	SKIPN	CNTFL
	SETOM	CNTFL		;inside a .sect
	PUSHJ	P,RCOM		;read command
	JRST	RUDDER		;lost
	JUMPL	B,POWB
	PUSHJ	P,COMMA1
RUDDER:	JUMPN	C,RDEOL
	SKIPN	CMCNT
	JUMPE	C,MNLPR		;buffer is empty and no end of line call
RDL2X:	JUMPE	C,MNLP		;buffer is empty and an end of line call
	JRST	MNBRR		;buffer not empty

COMMAN:	PUSHJ	P,RCOM		;Read command
	POPJ	P,		;Lost
COMMA1:	MOVE	A,CHARI1
	MOVEM	A,COMTYI	;Save where cmnd comes from
	SETZB	K,H
	HRRZM	B,COMCAL
	LDB	A,[222100,,B]	;dispatch for pre-command instruction
	CAIL	A,PCTBL
	MOVEI	A,PCTBL		;unknown dispatch #
	XCT	PCTAB(A)	;do any pre-command instruction
	PUSHJ	P,@COMCAL	;do command
FINLIN:	SKIPA	A,LCHAR
FINLI2:	PUSHJ	P,@COMTYI	;Ignore rest of command line
FINLI3:	CAIE	A,^J
	JRST	FINLI2
	POPJ	P,

RCOM:	PUSHJ	P,GSYL		;Read a command - get syllable into H
	MOVSI	B,-COML
	CAMN	H,COMT(B)	;compare with valid commands
	JRST	RCOM1		;Found it
	AOBJN	B,.-2
RCOMER:	PUSHJ	P,RCOMO		;ERROR-output command
	BARF  unknown command 
	JRST	FINLIN

RCOM1:	MOVEM	B,ROTPNT
	MOVE	B,COMDT1(B)
POPJ1:	AOS	(P)		;Skip return
	POPJ	P,

;table for instruction done before commands
PCTAB:	JFCL			;0 no precommand instr
	PUSHJ	P,GNUMAR	;1 get a numerical argument
	PUSHJ	P,GFNUM		;2 get a "floating" argument
	PUSHJ	P,LATEST	;3 see if before text
	JRST	CMONE		;4 put command on end of line list
	PUSHJ	P,RCSV		;5 read one char and save in lchar
	SETO	K,		;6 for use as flag
PCTBL==.-PCTAB
	BUG Comidx

AERLIN:	MOVE	H,ROTPNT	;Output command
	MOVE	H,COMT(H)
RCOMO:	PUSHJ	P,TTYOON
	PUSHJ	P,OP6BT		;Output 6bit syllable in H
	PUSHJ	P,OPSP
POPTJ:	POP	P,TYRFL
	POPJ	P,

POWB:	MOVEI	B,POWER		;Here on autob command in fill mode
	PUSHJ	P,CMONE
	JRST	RDL2X

POWER:	JUMPN	C,DUPLXT
	MOVE	B,ROTPNT	;Finally do an AUTOB command
	MOVE	B,COMDT1(B)
	PUSHJ	P,COMMA1
	AOS	H,CMIDX
	SETOM	CMBLK-1(H)	;Indicate Command done
	POP	P,
	JRST	RDL2X

DUPLXT:	SOS	C,MXPF
	POP	P,		;Still some left in buffer after all
	JRST	MNBRR

CMEOL:	MOVE	H,CMIDX		;Here when there are end of line command calls
CMEOL1:	CAML	H,CMCNT
	JRST	CMEOL2
	SETZ	K,
	SKIPLE	H,CMBLK(H)	;Get next call
	PUSHJ	P,(H)		;do it
	AOS	H,CMIDX
	SETOM	CMBLK-1(H)
	JRST	CMEOL1

CMEOL2:	SETZM	CMIDX
	SETZM	CMCNT
	SKIPGE	JMODE
	JRST	NJMN1		;not filling
	JUMPLE	C,RDEOL1	;nothing on line
	SOSGE	C,MXPF
	SETZB	C,MXPF
	JRST	RDEOL

CMONE.:	POP	P,B		;eol routine is just after call to me
CMONE:	MOVE	A,CMCNT
	HRRZM	B,CMBLK(A)	;store end of line routine address
	AOS	B,CMCNT
	CAIGE	B,CMSWL
	POPJ	P,
	BUG Too many eol calls
	SOS	CMCNT
	POPJ	P,

COMT:		;Searched linearly from this end
SIXBIT	/SP/
SIXBIT	/SPACE/
SIXBIT	/PA/
SIXBIT	/PAGE/
SIXBIT	/BR/
SIXBIT	/BREAK/

SIXBIT	/IN/
	'INDENT
SIXBIT	/UN/
	'UNDENT
SIXBIT	/RIN/
	'RINDEN
SIXBIT	/OF/

SIXBIT	/SS/
	'SINGLE
SIXBIT	/DS/
	'DOUBLE
SIXBIT	/NF/
	'NOFILL
SIXBIT	/FI/
SIXBIT	/FILL/
SIXBIT	/AD/
	'ADJUST
	'HALFAD

SIXBIT	/CE/
	'CENTER
SIXBIT	/RI/
SIXBIT	/RIGHT/
	'SPREAD

SIXBIT	/SECT/
	'SECTIO
	'GENNUM
	'GENSET
SIXBIT	/C/
	'COMMEN
	'FIGURE
SIXBIT	/BLOCK/
SIXBIT	/INSRT/
SIXBIT	/AP/
	'APPEND
SIXBIT	/RLINE/
SIXBIT	/RTW/

SIXBIT	/HE1/
SIXBIT	/HE2/
SIXBIT	/HE/
	'HEADER
	'HEADIN
SIXBIT	/CHAP/

	'ULFONT
SIXBIT	/FINCH/
	'TABFNT
SIXBIT	/SPW/
	'SBLOCK
SIXBIT	/STERM/

SIXBIT	/SPBR/
SIXBIT	/SPSP/
SIXBIT	/CRBR/
SIXBIT	/CRSP/
	'SPCOMP
	'SPRETA
	'CRCOMP
	'CRRETA

SIXBIT	/ASP/
	'ABLOCK
	'SELECT
SIXBIT	/EP/
SIXBIT	/EPAGE/
SIXBIT	/SPAGE/
SIXBIT	/PV/
SIXBIT	/PD/
	'BLADJU
	'PSCORE
	'SCRIPT

SIXBIT	/DUMMY/
SIXBIT	/QUOTE/
	'HYPCHR
	'HYPHEN
	'PERIOD
SIXBIT	/TRANS/
	'NORMAL

SIXBIT	/SINCH/
	'TWINCH
	'TLINCH
	'PWINCH
	'PLINCH
SIXBIT	/TW/
SIXBIT	/TL/
SIXBIT	/PW/
SIXBIT	/PL/
SIXBIT	/HVW/
SIXBIT	/TOPM/
SIXBIT	/SIDM/
	'THESIS
	'HEADPW
SIXBIT	/PHP1/
	'NOHEAD

SIXBIT	/XGP/
SIXBIT	/FONT/
SIXBIT	/VSP/
	'NOSPEC
	'SQUISH
	'LTRSPC

SIXBIT	/END/
SIXBIT	/BEGIN/
	'NOWAIT
	'NVRADJ
SIXBIT	/VERSE/
SIXBIT	/DEBUG/
SIXBIT	/ET/
SIXBIT	/ALTER/

COML==.-COMT
DEFINE CM A/
	A
	A
TERMIN
COMMENT \;table for instruction done before commands
PCTAB:	JFCL			;0 no precommand instr
	PUSHJ	P,GNUMAR	;1 get a numerical argument
	PUSHJ	P,GFNUM		;2 get a "floating" argument
	PUSHJ	P,LATEST	;3 see if before text
	JRST	CMONE		;4 put command on end of line list
	PUSHJ	P,RCSV		;5 read one char and save in lchar
	SETO	K,		;6 for use as flag\
;these numbers are in index field
COMDT1:
CM SETZ	ASPC(1)		;SPACE
CM SETZ APAGE(1)	;PAGE
CM SETZ POPJP		;BREAK

CM SETZ AIND(1)		;INDENT
CM SETZ AUND(1)		;UNDENT
CM SETZ ARIN(1)		;RINDEN
   SETZ	AOFFSE(1)	;OFFSET

CM SETZ ASS		;SINGLE
CM SETZ ADS		;DOUBLE
CM SETZ ANF		;NOFILL
CM SETZ AFILL		;FILL
CM SETZ AADJ		;ADJUST
   SETZ	AHALFA		;HALFAD

CM SETZ ACENT(4)	;CENTER
CM SETZ ARIGHT(4)	;RIGHT
   SETZ	ASPREA(4)	;SPREAD

CM SETZ ASECT		;SECT
	AGENNU(1)	;GENNUM
	AGENSE(1)	;GENSET
CM	POPJP		;COMMEN
	AFIGUR(1)	;FIGURE
   SETZ	ABLOCK(1)	;BLOCK
	AINSRT		;INSRT
CM	AAP(6)		;APPEND
CM SETZ ARLINE(1)		;RTW Add n to line length

   SETZ	AHE1(4)		;Header to left of centered page #
   SETZ	AHE2(4)		;Header to right of centered page #
CM SETZ AHEAD(4)	;HEADER
   SETZ	AHEAD(4)
   SETZ	ACHAP(1)	;chapter number to be printed with page #

   SETZ	AULFON(1)	;ULFONT font to be automatically underlined on tty
	AFINCH(2)	;figure (arg in inches)
	ATABFN(1)	;TABFNT font used for tab and spacing unit
   SETZ	ASPW(1)		;# of xgp dots in width
	ASBLOC(1)	;SBLOCK -- size of .sect implied block
	ASTERM(5)	;STERM -- set terminator for written spreads

   SETZ	ASPBR		;SPBR leading spac or tab breaks
	ASPSP(6)	;SPSP don't break
   SETZ	ACRBR(6)	;CRBR break on crs
	ACRSP		;CRSP don't
	ASPCOM(6)	;SPCOMP compact consecutive spaces
	ASPRET		;SPRETA retain them
   SETZ	ACRCOM(6)	;CRCOMP compact consecutive CRs
   SETZ	ACRRET		;CRRETA retain them

   SETZ	AASP(1)		;ASP absolute space
   SETZ	AABLOC(1)	;ABLOCK absolute block
   SETZ	ASELEC		;SELECT font #
CM 	AEPAGE(1)	;EPAGE
	ASPAGE(1)	;Set page #
   SETZ	APV		;PV-even page force
   SETZ	APD		;PD-odd page force
	ABLADJ(1)	;BLADJU set baseline
	APSCOR(1)	;PSCORE set underscore position
	ASCRIP(1)	;SCRIPT set super and subscript amount

   SETZ	ADUMMY(5)	;DUMMY
   SETZ	AQUOTE(5)	;QUOTE
   SETZ	AHYPCHR(5)	;HYPCHR
	AHYPH(1)	;HYPHEN
   SETZ	APERI(1)	;PERIOD
	ATRANS(5)	;TRANS input TRANSlation
	ANORMA(1)	;NORMAL Arg means "normalize" quoted xgp chars

   SETZ	ASINCH(2)	;SINCH set pw,tw,pl,tl,lmarg in inches
   SETZ	ATWINC(2)	;TWINCH text width
   SETZ	ATLINC(2)	;TLINCH text length
   SETZ	APWINC(2)	;PWINCH paper width in 1/10 inch
   SETZ	APLINC(2)	;PLINCH paper length
   SETZ	ATW(1)		;TW
   SETZ	ATL(1)		;TL
   SETZ	APW(1)		;PW
   SETZ	APL(1)		;PL
   SETZ	AHVW(1)		;HVW set height, vsp, width
   SETZ	ATOPP(1)	;TOPM
   SETZ	ASIDP(1)	;SIDM
   SETZ	ATHES(1)	;THESIS
   SETZ	AHEADP(1)	;HEADPW make heading as wide as page
	APHP1(1)	;PHP1 print header on page 1
   SETZ	ANOHEA(1)	;NOHEAD

   SETZ	AXGP(3)		;XGP set xgp mode
   SETZ	AFONT(3)	;FONT read in font
   SETZ	AVSP(3)		;VSP interline space
   SETZ	ANOSPE(3)	;NOSPEC don't output xgp spec page
	ASQUIS(3)	;SQUISH -- causes ;SQUISH to appear on command page
	ALTRSP(1)	;LTRSPC -- 0 arg suppresses letterspacing on XGP in adjust mode

   SETZ	AEND		;END
   SETZ	ABEGIN(1)	;BEGIN
   SETZ	ANOWT(1)	;NOWAIT
   SETZ	ANVRAD(1)	;NVRADJ
	AVERSE		;VERSE version # (like .DATE)
	ADEBUG		;DEBUG does a .VALUE if debugging
	AET		;ET end typein
   SETZ AALTER(1)	;ALTERnate left and right headings	

IFN .-COMDT1-COML,[
	PRINTC /COMMANDS DONT MATCH
 /
]

;Various routines to handle commands

;Some commands like to do things at the end of the next output line
;This can be done in two ways:
;Save paramters now, then swap them in in MNLP or
;Generate an end of line routine and put its adress into CMSW

ATW:	PUSHJ	P,CVWTI		;convert to 1/10 inch
	MOVEM	H,TWINCH
ATW1:	SKIPN	XGPMOD
	CAIG	K,BUFSIZ-1
	JRST	.+3
	BARF TW too wide
	MOVEI	K,BUFSIZ-1
	MOVEM	K,TW
ATW4:	MOVEM	K,RNLL
ATW2:	SUB	K,PW
ATW3:	PUSHJ	P,MCAL		;caculate margin
	SKIPE	PWHDF
	POPJ	P,
	PUSH	P,A
	MOVE	A,RNLL		;update rmargin only if tw = rtw
	CAMN	A,TW
	MOVNM	K,RMARGIN
	JRST	POPAJ

ARLINE:	SUB	K,TW		;.RTW adds to NLL but not RNLL (doesn't affect header)
	MOVNS	K
	MOVEM	K,TW
	SUB	K,PW
MCAL:	IMUL	K,PRSNT		;calculate left margin from %
	IDIVI	K,100.
	CAIL	L,50.
	AOJ	K,
	MOVNM	K,MARGIN	;if margin < 0, none appears 
	MOVE	K,PWINCH
	SUB	K,TWINCH
	IMUL	K,PRSNT
	IDIVI	K,100.
	CAIL	L,50.
	AOJ	K,
	MOVEM	K,LMINCH
	MOVN	K,MARGIN
	POPJ	P,		;so in effect pw > or = lnl.

APW:	PUSHJ	P,CVWTI		;convert to 1/10 inch
	MOVEM	H,PWINCH
APW1:	MOVEM	K,PW
	SUB	K,TW
	MOVNS	K
	JRST 	ATW3

APL:	PUSHJ	P,CVLTI		;convert to 1/10 inch
	MOVEM	H,TLINCH
APL1:	MOVEM	K,PL
	SUB	K,TL
	JRST	ATL3

ATL:	PUSHJ	P,CVLTI		;convert to 1/10 inch
	MOVEM	H,TLINCH
ATL1:	SKIPE	THSFLG
	 SUBI	K,3		;Thesis mode, discount for header included in text area
	MOVEM	K,TL
ATL2:	SUB	K,PL
	MOVNS	K
ATL3:	SKIPE	THSFLG
	 SUBI	K,3
	IMUL	K,PRCNT		;calculate top margin
	IDIVI	K,100.
	CAIL	L,50.
	AOJ	K,
	CAIGE	K,5		;do we have 5 lines for top
	MOVEI	K,5		;no
	SKIPE	THSFLG
	 ADDI	K,3
	MOVEM	K,TPMAR		;prcnt of extra lines in top margin
	SUBI	K,3		;top margin minus heading
	MOVEM	K,TPMAR3
	POPJ	P,		;if margin < 0 it, none appears
				;so in effect pl > or = pl+5

CVLTI:	MOVE	A,HEIGHT
	ADD	A,VSP
	MOVE	H,XVRES
	JRST	CVCHTI
CVWTI:	MOVE	A,WIDTH
	MOVE	H,XHRES
;CONVERT # OF CHARS IN K TO 1/1000 INCH IN H
CVCHTI:	PUSH	P,K
	IMUL	K,A		;xgp dots per char
	IMULI	K,1000.
	IDIV	K,H
	ASH	H,-1
	CAML	L,H
	AOJ	K,
	MOVE	H,K
	POP	P,K
	POPJ	P,

ACHAP:	SKIPN	H		;.CHAP
	AOSA	CHAPNO		;no arg, simply increment chapter
	MOVEM	K,CHAPNO
	SETZM	OUTPAG		;Restart page numbering
	POPJ	P,

AIND:	MOVEM	K,NINDS		;.INDENT
	POPJ	P,

ARIN:	ADDM	K,NINDS		;.RTW
	POPJ	P,

AOFFSE:	PUSHJ	P,ARIN		;.OF
AUND:	MOVEM	K,AUNDT		;.UNDENT
	PUSHJ	P,CMONE.
	MOVN	K,AUNDT
	ADDB	K,INDS
	JUMPGE	K,.+2
	SETZB	K,INDS		;If INDS<0, set to 0
	MOVE	A,TW		;recalculate line length
	SUB	A,NXLSPC
	SUB	A,INDS
	JRST	LNLCHK

ASS:	SKIPA	K,[1]		;.SINGLE
ADS:	MOVEI	K,2		;.DOUBLE
	MOVEM	K,LFMD
	POPJ	P,

ANVRAD:	MOVNM	K,NVRADJ	;.NVRADJ
	POPJ	P,

AFILL:	TDZA	A,A		;.FILL
ANF:	SETOM	A		;.NOFILL
	SETZM	SPFLSF		;don't flush extra spaces
	SETZM	MID.F		;.s not special in middle of line
ANF1:	MOVEM	A,NJMODE
	POPJ	P,

AHALFA:	TDZA	A,A		;.HALFAD fill but treat . & sp like .ad
AADJ:	MOVEI	A,1		;.ADJUST
	SETOM	SPFLSF		;flush redundant spaces
	SETOM	MID.F		;. special in middle
	JRST	ANF1

ACENT:	SETZM	RGHCN		;.CENTER
	JRST	ARI1

ARIGHT:	SETOM	RGHCN		;.RIGHT
ARI1:	PUSHJ	P,PRNTRA	;do at end of line after .center
	PUSHJ	P,RCH
	TLNE	B,CEOLF+CFSPF
	JRST	.-2		;flush cr, lf, sp tab
	PUSHJ	P,UNCH
	PUSHJ	P,READIT
	SKIPN	CONTEN
	SKIPE	OUTFLS
	JRST	ACENT3
	MOVE	B,TW		;line length
	SKIPE	XGPMOD
	JRST	ACENX
	SUB	B,C		;length of text to be centered
	JUMPL	B,ACENER
	SKIPN	RGHCN
	ASH	B,-1		;calculate spaces needed
	ADD	B,MARGIN
	PUSHJ	P,SPB1
ACENT3:	PUSHJ	P,[ SKIPN OUTFLS ? JRST PRNTI3 ? JRST FLSLIN ]
	SETZB	C,MXPF
	JRST	PREOL1

ACENX:	MOVE	B,TW		;center for xgp
	IMUL	B,WIDTH
	SUB	B,W
	JUMPL	B,ACENER
	SKIPN	RGHCN
	ASH	B,-1
	PUSHJ	P,SPMPB
	JRST	ACENT3

ACENER:	PUSHJ	P,AERLIN	;print command name
	PUSHJ	P,LTWER		;print line wider than TW
	JRST	ACENT3

AHEAD:	SETZM	HEDSPT		;.HEADER
	PUSHJ	P,HEDST
	JSP H,RSTRG		;put it in headin hbuf
	 HBUFC
	 HBUFW
	 HBUF
	 HBUFL
	 PUSHJ P,FTLER
	MOVE	A,RSEFNT	;Current input font
	MOVEM	A,HDFONT	;Save, Pg # is in this font
	POPJ P,

AHE1:	SETOM	HEDSPT		;.HE1
	PUSHJ	P,HEDST
	JSP H,RSTRG
	 HBUFC1
	 HBUFW1
	 HBUF1
	 HBUFL/2
	 PUSHJ P,FTLER
	POPJ P,

AHE2:	SETOM	HEDSPT		;.HE2
	PUSHJ	P,HEDST
	JSP H,RSTRG
	 HBUFC2
	 HBUFW2
	 HBUF2
	 HBUFL/2
	 PUSHJ P,FTLER
	POPJ P,

HEDST:	PUSHJ	P,RNCH
	CAIE	A,12
	JRST	UNCH
	POPJ	P,

FTLER:	PUSHJ	P,AERLIN	;print command name
	BARF  field too wide
	POPJ	P,

;0(H)	Place to put number of columns taken
;1(H)	Place to put width
;2(H)	Place to put goodies
;3(H)	Maximum width
;4(H)	What to do when too long
;5(H)	Return

RSTRG:	SKIPN	C,@(H)
	JRST	RSTRG1		;No previous data
	HRLZ	A,2(H)		;Flush current data
	HRRI	A,BUFF
	BLT	A,BUFF(C)	;Put in input buffer
	MOVEM	C,MXPF1
	PUSHJ	P,FLSLIN	;Then flush it
	MOVE	A,2(H)
	SETZM	(A)
	ADD	C,A
	HRL	A,A
	AOJ	A,
	BLT	A,-1(C)		;Zero out string buffer
RSTRG1:	PUSH	P,H
	PUSH	P,IFNT
	PUSH	P,IFNIDX
	SETZM	IFNT
	SETZM	IFNIDX
	PUSHJ	P,READIT	;Read a line into buff
	MOVE	A,IFNT
	MOVEM	A,RSEFNT	;Save font # for .HEADER
	POP	P,IFNIDX
	POP	P,IFNT
	POP	P,H
	CAML	C,3(H)
	JRST	RSTRTL		;Too Long
RSTRG2:	MOVEM	C,@(H)		;# of columns
	MOVEM	W,@1(H)		;Width
	MOVE	A,2(H)
	ADD	C,A
	HRLI	A,BUFF
	BLT	A,(C)		;BLT from BUFF to string buffer
	SETZM	BUFF
	MOVE	A,[BUFF,,BUFF+1]
	MOVE	C,@(H)
	BLT	A,BUFF(C)	;Clear out buffer
	MOVE	A,[COLWID,,COLWID+1]
	SETZB	W,COLWID
	BLT	A,COLWID(C)
	SETZB	C,MXPF
	JRST	5(H)

RSTRTL:	PUSH	P,H
	XCT	4(H)
	POP	P,H
	SETCA	C,
	ADD	C,3(H)	;Flush 1 extra column
	HRLZS	C
	HRR	C,3(H)	;First one to flush
	PUSHJ	P,FLSBU1
	MOVE	C,3(H)
	JRST	RSTRG2

ABLOCK:	MOVE	H,LFMD		;.BLOCK
	IMULI	K,(H)
	ADDI	K,-1(H)
AABLOC:	MOVEM	K,BLCKNT	;.ABLOCK
	PUSHJ	P,CMONE.
	MOVE	K,TL
	SUB	K,OUTLIN
	CAML	K,BLCKNT
	POPJ	P,		;enough space
	SETOM	PGSPFL		;need to do .page
	JRST	ASPAG

AEPAGE:	ADDM	K,EPGINN	;.EPAGE
	PUSHJ	P,CMONE.
	MOVE	K,EPGINN
	SETZM	EPGINN
	ADDM	K,EPGIN
	POPJ	P,

APV:	SETOM	PGSPFL		;.PV even page force
	PUSHJ	P,CMONE.
	MOVE	K,OUTPAG
APV1:	ADD	K,EPGIN
	TRNN	K,1
	AOS	EPGIN
	JRST	ASPAG

APD:	SETOM	PGSPFL		;.PO odd page force
	PUSHJ	P,CMONE.
	MOVE	K,OUTPAG
	AOJA	K,APV1

ASPC:	IMUL	K,LFMD		;.SPACE
ASP1:	ADDM	K,NLFS		;.ASP
	SETOM	PGSPFL
	PUSHJ	P,CMONE.
	JRST	ASPC1

AASP:	SKIPN	OUTLIN
	JRST	ASP1
	SUB	K,OLFMD		;account for LFs at end of previous line
	AOJA	K,ASP1

APAGE:	SOJL	K,POPJP		;.PAGE
	ADDM	K,EPGIN
	SETOM	PGSPFL
	PUSHJ	P,CMONE.
ASPAG:	MOVE	K,TL		;used by .page .block, etc. at end of line
	SUB	K,OUTLIN
	ADDI	K,2		;?
	MOVEM	K,NLFS		;lines after present one
	SETOM	PGCMFL		;indicate that we are doing a .page
	SKIPLE	PNST		;avoid ^l before xgp specs
	SKIPG	FPGPOS
ASPC1:	PUSHJ	P,PRNTRA	;here for .sp eol call
	SKIPN	OUTPAG
	JRST	ASPC2		;page 1
	MOVE	B,NLFS
	ADD	B,OUTLIN
	;SKIPE	THSFLG
	;SUBI	B,3		;for 3 lines in thesis mode
	CAMLE	B,OLFMD		;ignore .sp 1 at top of page
ASPC2:	SKIPG	B,NLFS
	JRST	ASPPG
	MOVE	H,TL
	SUB	H,OUTLIN	;# of lines left on page
	CAMLE	B,H
	MOVE	B,H		;don't space >h lines
	SETZM	NLFS
	PUSHJ	P,CRRB		;do a cr and b crlfs
	JRST	ASPC1

ASPPG:	MOVE	K,TL
	SUB	K,OUTLIN
	IDIV	K,LFMD
	SOJL	K,ASPAG		;jump if at bottom of page
	SETZM	NLFS
	POPJ	P,

ASPAGE:	MOVEM	K,EPGINN	;.SPAGE
	PUSHJ	P,CMONE.
	SOSE	K,EPGINN
	SETZM	EPGINN
	MOVEM	K,OUTPAG
	POPJ	P,

AFINCH:	PUSHJ	P,CVLITC	;.FINCH
AFIGUR:	AOJ	K,		;.FIGURE
	SUB	K,LFMD
	CAMLE	K,TL
	MOVE	K,TL		;figure can't be bigger than page
	SKIPE	FIGP
	JRST	AFIGU3		;already figures waiting
	HRLZM	K,FIGP
	PUSHJ	P,CMONE.
AFIGU2:	HLRZ	K,FIGP		;first figure
	MOVE	A,TL
	SUB	A,OUTLIN	;lines left on page
	CAMLE	K,A		;enough space?
	POPJ	P,		;no - so let happen at top of next page
	PUSH	P,NLFS
	MOVEM	K,NLFS
	PUSHJ	P,ASPC1
	POP	P,NLFS
	HRRZ	A,FIGP		;next figure
	SETZM	FIGP
	JUMPE	A,AFIGUP	;no next figure
	MOVE	K,(A)
	MOVEM	K,FIGP		;move next q entry to figp
	EXCH	A,FF
	HRRZM	A,@FF		;free up where it was
	JRST	AFIGU2

AFIGU3:	MOVEI	H,FIGP		;find end of figure queue
	MOVE	A,H
	HRRZ	H,(A)
	JUMPN	H,.-2
	PUSHJ	P,CONS		;get new wd of fs
	HRRM	F,(A)		;add this figure to q
	HRLZM	K,(F)
AFIGUP:	POPJ	P,

ABEGIN:	MOVEM	K,PNST		;.BEGIN page to start output at
ABEGI1:	SETOM	OUTFLS		;switch off output 
	POPJ	P,

ACONT:	SETOM	CONTEN		;/C in command line, output tabel of contents
	MOVE	A,['CONTEN]
	SKIPN	OFN2F
	MOVEM	A,ONAM+2
	SETOM	OFN2F
	JRST	ABEGI1

ANOHEA:	MOVEM	K,NHEADF	;.NOHEAD
	POPJ	P,

AFNAME:	PUSHJ	P,RANBEG	;control N (in-text command)
	PUSHJ	P,OPINAM
	JRST	AGENN1

RANIN:	AOS	I,RANCNT	;put char in a into rantxt
	CAILE	I,RANMAX
	JRST	RANER
	IDPB	A,RANIPT
	AOS	(P)		;win, skip
	POPJ	P,
RANER:	SOS	RANCNT
	BUG Too much GENTXT
	POPJ	P,

RANBEG:	MOVEI	A,NRANIN
	EXCH	A,TYRFL
	EXCH	A,(P)
	JRST	(A)

ADATE:	MOVE	H,[440700,,DATE]
	JRST	.+3		;.ADATE
	PUSHJ	P,RANIN
	POPJ	P,
	ILDB	A,H		;get next char in date
	JUMPN	A,.-3
RANSET:	PUSHJ	P,RTYION	;set up input from random text
	CAIE	A,LTYI
	POPJ	P,
	MOVE	A,LCHAR		;don't destroy lchar
NRANIN:	PUSHJ	P,RANIN
	POPJ	P,
	POPJ	P,

AGENNU:	MOVE	D,K		;.GENNUM  1st arg, amount to inc by
	MOVEI	K,1
	TLNN	B,CEOLF
	PUSHJ	P,GNUMAR
	PUSHJ	P,UNCHCR	;make LF appear after .GENNUM text
AGENN2:	ADD	D,GENNUM-1(K)
	PUSHJ	P,AGENW		;Update gennum
	PUSHJ	P,RANBEG
	MOVE	A,D
	PUSHJ	P,DPT		;put gened # into rantxt buffer
AGENN1:	POP	P,TYRFL
	JRST	RANSET

AGENSE:	MOVEI	D,-1(K)		;.GENSET
	MOVEI	K,1
	TLNN	B,CEOLF
	PUSHJ	P,GNUMAR
AGENW:	JUMPLE	K,AGENER
	CAILE	K,GENMAX
	JRST	AGENER
	CAIG	K,GENWMX	;Skip if read-only
	MOVEM	D,GENNUM-1(K)
	POPJ	P,

AGENER:	PUSHJ	P,AERLIN
	BARF  Bad GENNUM counter #
	JRST	POPAJ

AVERSE:	PUSHJ	P,RANBEG
	PUSHJ	P,PVERSE
	PUSHJ	P,UNCHCR	;don't loose LF after .VERSE
	JRST	AGENN1

PVERSE:	MOVEI	K,ITSNAM	;Print TJ6 Version #
	JRST	OPFNM2

ADUMMY:	TLNE	B,CEOLF		;.DUMMY
	POPJ	P,		;don't dummy cr or lf
	MOVE	D,A
	PUSHJ	P,GNUMAR
	MOVSI	H,CDUMF
	JUMPN	K,.+3
	ANDCAM	H,CDTAB(D)	;out with the old dummy
	POPJ	P,
	IORM	H,CDTAB(D)	;or in with the new
	POPJ	P,

AQUOTE:	TLNE	B,CEOLF		;.QUOTE
	SETO	A,
	MOVSI	H,CQUOF
	EXCH	A,NQUOTE
	SKIPL	A
	ANDCAM	H,CDTAB(A)
	SKIPL	A,NQUOTE
	IORM	H,CDTAB(A)
	POPJ	P,

AHYPCH:	TLNE	B,CEOLF		;.HYPCHR
	SETO	A,		;turn off
	MOVSI	H,CHHYF
	EXCH	A,HYPCHR
	SKIPL	A
	ANDCAM	H,CDTAB(A)
	SKIPL	A,HYPCHR
	IORM	H,CDTAB(A)
	POPJ	P,

AHYPH:	MOVSI	A,CHYPF		;.HYPHEN
	JUMPE	K,.+3
	ANDCAM	A,CDTAB+"-	;turn off
	POPJ	P,		;drop out
	IORM	A,CDTAB+"-	;turn on (arg=0)
	POPJ	P,

RCSV:	PUSHJ	P,@CHARI
	MOVEM	A,LCHAR
	POPJ	P,

APERI:	CAIN	A,40		;.PERIOD
	JRST	APERI2		;more args
	MOVSI	A,CEOSF		;turn off special treatment of . ! ?
	MOVSI	H,CEOCF
	SKIPN	K
	JRST	APERON		;arg=0, turn on
	ANDCAM	A,CDTAB+".
	ANDCAM	A,CDTAB+"?
	ANDCAM	A,CDTAB+"!
	ANDCAM	H,CDTAB+":
	ANDCAM	H,CDTAB+";
	POPJ	P,
APERON:	IORM	A,CDTAB+".
	IORM	A,CDTAB+"?
	IORM	A,CDTAB+"!
	IORM	H,CDTAB+":
	IORM	H,CDTAB+";
	POPJ	P,

APERI2:	PUSHJ	P,RCSV
	TLNE	B,CEOLF
	POPJ	P,
	CAIE	A,":
	CAIN	A,";
	SKIPA	H,[CEOCF,,]
	MOVSI	H,CEOSF
	SKIPE	K
	JRST	.+3
	ANDCAM	H,CDTAB(A)	;turn off
	POPJ	P,
	IORM	H,CDTAB(A)
	POPJ	P,

ATRANS:	MOVE	K,A		;.TRANS
	PUSHJ	P,RCSV
	MOVEM	A,TRNTBL(K)
	PUSHJ	P,RCSV
	CAIE	A,",
	POPJ	P,
	PUSHJ	P,RCSV
	JRST	ATRANS

ASTERM:	MOVEM	A,STERMC	;.STERM
	POPJ	P,

ASBLOC:	JUMPL	K,.+2		;.SBLOCK
	MOVEM	K,SBLOCK
	POPJ	P,

ASECT:	MOVE	K,SBLOCK	;.SECT make sure enough lines on page
	PUSHJ	P,ABLOCK	;by simulating .BLOCK
	SKIPN	CONTEN
	POPJ	P,		;if not /c, do nothing else
	PUSHJ	P,CMONE.
	PUSHJ	P,PRNTRA	;to avoid top of page hassle
	SETZM	OUTFLS
	SETOM	CNTFL		;counts times we got to rdeol
	MOVEI	H,[ASCIZ /.Spread
/]
	SETOM	CONFLG
	PUSHJ	P,OPSTH
ASECT1:	MOVE	A,STERMC
	JRST	@CHARO

SECTN:	SETZM	CONFLG		;Write page #
	PUSHJ	P,ASECT1
	PUSHJ	P,@CHARO
	PUSHJ	P,PGNPT
	PUSHJ	P,ASECT1
	PUSHJ	P,CRROF
	SETOM	OUTFLS
	POPJ	P,

ATOPP:	MOVEM	K,PRCNT		;.TOPM % of margin on top
	MOVE	K,TL
	JRST	ATL2

ASIDP:	MOVEM	K,PRSNT		;.SIDM  % of margin on side
	MOVE	K,TW
	JRST	ATW2

ATHES:	MOVNM	K,THSFLG	;.THESIS
	POPJ	P,

AHEADP:	MOVNM	K,PWHDF		;.HEADPW
	JUMPE	K,APGNR1
	SETZM	RMARGIN
	MOVE	A,PW
	MOVEM	A,RNLL
	POPJ	P,

APGNR1:	MOVE	K,TW
	JRST	ATW4

ANOWT:	MOVEM	K,NWAITF	;.NOWAIT
	POPJ	P,

ASPSP:				;.SPSP
ASPBR:	MOVEM	K,SPSPF		;.SPBR
	POPJ	P,

ACRBR:				;.CRBR
ACRSP:	MOVEM	K,CRBRF		;.CRSP
	POPJ	P,

ASPCOM:				;.SPCOMP
ASPRET:	MOVEM	K,SPFLSF	;.SPRETA
	POPJ	P,

ACRCOM:				;.CRCOMP
ACRRET:	MOVEM	K,CRCOMF	;.CRRETA
	POPJ	P,

AINSRT:	MOVE	A,IOPUSD	;.INSRT
	CAIL	A,7
	JRST	PSHFAR
AAP:	MOVEM	K,APPFLG	;.APPEND
	PUSHJ	P,AET		;turn off tty input
	MOVE	A,CHARI1
	MOVEM	A,CHARI
	MOVEI	Z,-1		;only get input specs
	PUSHJ	P,FNR
	PUSHJ	P,FINLI2
	PUSHJ	P,UNCHCR	;make cr appear to be next char
	SKIPE	APPFLG
	JRST	AINSR2
	MOVE	A,IOPUSD
	IMULI	A,IOBKL
	MOVEI	B,IOPDLB(A)
	HRLI	B,INBLK
	BLT	B,PIEOFP(A)	;save INPAGN, INLINE, INPTR, BLKIP, IEOFP
	MOVE	B,INPTR
	MOVE	B,(B)		;Save one buffered word
	MOVEM	B,PINWD(A)
	AOS	IOPUSD
	.IOPUSH	UTYIC,		;Push current file
AINSR2:	PUSHJ	P,TTYOON
	PUSHJ	P,OPNRD
	JRST	PSHFA1		;Failed to open
	JRST	POPTJ

PSHFAR:	BARF >7 nested inserts
	POPJ	P,
PSHFA1:	POP	P,TYRFL
	SKIPN	APPFLG
	JRST	ENDER1		;Just pop back old file
	JRST	ENDAR		;No point on .APPEND

RCHEOF:	MOVE	P,PDL		;read real eof
	MOVEI	A,RDL2X
	MOVEM	A,(P)
AEND:	PUSHJ	P,CMONE.	;.END
ENDER:	JUMPN	C,DUPLXT	;if not all flushed from buffer (unlikely ?)
ENDER1:	SOSGE	A,IOPUSD
	JRST	REND		;no inputs left to pop
	.IOPOP	UTYIC,
	IMULI	A,IOBKL
	HRLI	B,IOPDLB(A)
	HRRI	B,INBLK
	BLT	B,IEOFP
	MOVE	B,PINWD(A)	;one word of buffer we saved
	MOVEM	B,RCHBFE-1
	HRRZ	B,INPTR		;Where it was pointing
	MOVEI	A,RCHBFE-1
	HRRM	A,INPTR		;Mung it
	SUB	A,B		;Amnt INPTR advanced by
	ADDM	A,IEOFP
	MOVE	A,[UTYIC,,DNAM]
	.RCHST	A,		;Get file name and .ACCESS pntr
	SUB	B,BLKIP		;-Amount of buffer we lost in .INSRT
	AOS	B		;But 1 wd was saved
	ADDB	B,IACCES	;+ old ACCESS pntr
	.ACCES	UTYIC,B		;= new pntr
	JRST	UNCHCR		;make cr last char

ANORMA:	SKIPN	H		;.NORMAL
	SETZ	K,		;no arg
	MOVEM	K,XNORF		;0 means don't normalize quoted chars
	POPJ	P,

AET:	SKIPN	SLASHT		;.ET
	POPJ	P,
	SETZM	SLASHT		;end typein
	PUSHJ	P,FTYION	;turn on file input
	JRST	RESETT		;reset pointers

AALTER:	MOVEM	K,ALTFLG	;set alternating header flag (bkph)
	POPJ	P,

ASPREA:	PUSHJ	P,PRNTRA	;.SPREAD
	PUSHJ	P,FINLIN
ASPRE1:	PUSHJ	P,@CHARI
	CAIN	A,12
	 JRST	 ASPRE1		;kludge kludge kludge.  sorry -- DAM
	MOVEM	A,SEPCHR
	PUSHJ	P,READIS
	SKIPE	XGPMOD
	MOVE	C,W		;if xgp
	MOVEM	C,CBUF1
	PUSHJ	P,PRNMRG
	PUSHJ	P,ASPRT		;get next field
	JRST	ASPRV		;output flushed or contents
	JRST	ASPRE3		;not xgp
	IMUL	B,WIDTH
	SUB	B,W
	ASH	B,-1
	PUSHJ	P,FIXUS
	PUSHJ	P,SPMPB
	JRST	ASPRV

ASPRE3:	MOVEM	C,CBUF2
	SUB	B,C
	ASH	B,-1
	SUB	B,CBUF1
	SKIPGE	B
	SETZ	B,
	ADDM	B,CBUF2
	PUSHJ	P,SPUL		;put in spaces or _s
ASPRV:	PUSHJ 	P,PRNTIT
	PUSHJ	P,ASPRT		;get next field
	JRST	ASPRV1
	JRST	ASPRE6
	IMUL	B,WIDTH
	SUB	B,W
	PUSHJ	P,FIXUS
	PUSHJ	P,SPMPB
	JRST	ASPRV1

ASPRE6:	SUB	B,C
	SUB	B,CBUF2
	SUB	B,CBUF1
	SKIPGE	B
	SETZ	B,
	PUSHJ	P,SPUL		;put in spaces
ASPRV1:	PUSHJ	P,PRNTIT
	PUSHJ	P,@CHARI
	PUSHJ	P,FINLI3
	JRST	ASPRP1

ASPRT:	MOVE	A,TERMC		;get next field
	CAIN	A,15
	JRST	ASPRP		;no more args
	MOVE	A,CHARI1
	MOVEM	A,CHARI
	PUSHJ	P,READIS
	SKIPE	OUTFLS
	POPJ	P,		;Don't skip
	MOVE	B,TW
	AOS	(P)
	SKIPN	CONTEN
	SKIPN	XGPMOD
	POPJ	P,
	AOS	(P)		;XGP
	POPJ	P,


ASPRP:	POP	P,
ASPRP1:	SETOM	SEPCHR
	SETZB	C,MXPF
	JRST	PREOL1

ABLADJ:	PUSH	P,K		;.BLADJU
	JRST	RBLS

APSCOR:	CAILE	K,77		;.PSCORE
	ANDI	K,77
	MOVEM	K,ULBASI
	POPJ	P,

ASCRIP:	CAILE	K,77		;.SCRIPT
	ANDI	K,77
	MOVEM	K,BLAMT
	POPJ	P,

APHP1:	MOVEM	K,PHP1F		;.PHP1
	POPJ	P,

AULFON:	MOVEM	K,ULFNT		;.ULFONT
	POPJ	P,

ASELEC:	PUSHJ	P,GFONTN	;.SELECT, like ^F
	POPJ	P,
	JRST	PFNT1

;Associate font n with file
AFONT:	SKIPE	XGPMOD		;.FONT
	PUSHJ	P,GFONTN	;Get font #
	POPJ	P,		;None or illegal
	IMULI	K,FNTBKL	;Index into font block
	PUSH	P,K
	PUSHJ	P,GFNAM		;Get name & open
	JRST	POPAJ		;Open lost
	POP	P,K
	SETZB	H,FEOF
	MOVEI	D,FNTBUF+FNTBFL
GKST:	MOVEI	A,FFDEV(K)
	HRLI	A,TFBLK
	BLT	A,FFSYS(K)	;Move names to permanent resting place
	PUSHJ	P,KSTYI
	JRST	GKSTER
	PUSHJ	P,KSTYI		;Ignore kstid
	JRST	GKSTER
	HRRZM	A,HEIGHT(K)
	TLZ	A,777000
	HLRZM	A,BASE(K)
	SETZM	WIDTHS(K)	;Zero out widths
	MOVSI	A,WIDTHS(K)
	HRRI	A,WIDTHS+1(K)
GKST1:	PUSHJ	P,KSTYI		;user id
	JRST	GKSTER
	TRNN	A,1		;beginning of char info has this bit on
	JRST	GKST1
	AOJE	A,GKSTE		;end of font has -1
	PUSHJ	P,KSTYI		;char id
	JRST	GKSTER
	HRRZ	L,A
	ADDI	L,WIDTHS(K)	;Where to store width
	PUSHJ	P,KSTYI
	JRST	GKSTER
	HRRZM	A,(L)		;save char width
	JRST	GKST1

GKSTER:	PUSHJ	P,OFNER		;print font file name
	BARF Bad font file
	SETZM	FNTBLK(K)
	POPJ	P,

GKSTE:	.CLOSE	FNTC,
	MOVE	A,[FNTBUF,,FNTBUF+1]
	SETZM	FNTBUF
	BLT	A,FNTBUF+FNTBFL-1
	SKIPL	TABFNT
GKSTE1:	CAMN	K,TABFNT
	PUSHJ	P,GKSTAB
	JRST	RECALM

KSTYI1:	MOVE	D,[-FNTBFL,,FNTBUF]
	.IOT	FNTC,D		;refill disk buffer
	SKIPGE	D
	HRRZM	D,FEOF		;eof in this buffer load
	MOVEI	D,FNTBUF
KSTYI:	CAMN	D,FEOF
	POPJ	P,
	CAIL	D,FNTBUF+FNTBFL
	JRST	KSTYI1		;at end of buffer
	MOVE	A,(D)
	AOJA	D,POPJ1

OFNER:	PUSHJ	P,TTYOON
	MOVEI	K,TFBLK
	PUSHJ	P,FAILD		;Print loosing name and ERR device msg
	JRST	POPTJ

GKSTAB:	SKIPE	FFDEV(K)
	SKIPE	TABSEF		;Take this font into account when setting tabstops
	POPJ	P,		;font not defined or tabs frozen
	SETZM	WIDTH
	SETZM	TABW
	HRLI	K,-CSETSZ
GKSTA1:	MOVE	A,WIDTHS(K)
	CAMG	A,WIDTH
	JRST	GKSTA2
	MOVEM	A,WIDTH
	LSH	A,3
	MOVEM	A,TABW
GKSTA2:	AOBJN	K,GKSTA1
	POPJ	P,

ATABFN:	JUMPE	H,ATABFE	;.TABFNT
	CAML	K,[-1]
	CAILE	K,MAXFNT
	JRST	ATABFE
	IMULI	K,FNTBKL
	MOVEM	K,TABFNT
	SETZM	TABSEF
	JUMPGE	K,GKSTE1	;Only one font
	SETZB	K,H		;arg was negative, use all fonts
ATABF1:	PUSHJ	P,GKSTAB
	CAIL	H,MAXFNT*FNTBKL
	JRST	RECALM
	ADDI	H,FNTBKL
	MOVE	K,H
	JRST	ATABF1

ATABFE:	PUSHJ	P,AERLIN
	JRST	GFONER

;GET FONT NAME IN TFBLK & TRY OPENING SKIP IF WINNER
GFNAM:	SETZ	Z,
GFNAM1:	PUSHJ	P,GSYLFS	;GET 6BIT SYLLABLE IN B, BREAK CHAR INDEX IN A
	JRST	@GFNTAB(B)

GFNTAB:	GFNAM2	;ILLEGAL CHAR
	GFCL	;:
	GFSC	;;
	GFNAM2	;/
	GFSP	;SP
	GFNAM2	;_
	GFCR	;CR

GFSP:	PUSHJ	P,GFNM
	JRST	GFNAM2		;LOST
	JRST	GFNAM1

GFNM:	JUMPE	H,POPJ1		;IGNORE LEADING SPACES
	TLOE	Z,CMFN1F
	JRST	GFNM1		;ALREADY READ ONE NAME
	MOVEM	H,TFBLK+1	;MAKE IT 1ST FILE NAME
	JRST	POPJ1

GFNM1:	TLOE	Z,CMFN2F
	POPJ	P,		;read 2 names already
	MOVEM	H,TFBLK+2
	JRST	POPJ1

GFSC:	TLOE	Z,CMSNMF
	JRST	GFNAM2		;ALREADY READ SYS NAME
	MOVEM	H,TFBLK+3
	JRST	GFNAM1

GFCL:	TLOE	Z,CMDEVF
	JRST	GFNAM2
	MOVSS	H
	CAIE	H,'DSK
	 CAIN	H,(SIXBIT /AI/)
	  JRST	GFCL1
	CAIE	H,(SIXBIT /DM/)
	 CAIN	H,(SIXBIT /MC/)
	  JRST	GFCL1
	CAIE	H,(SIXBIT /ML/)
	 JRST	GFNAM2		;BAD DEVICE NAME
GFCL1:	HRRM	H,TFBLK
	JRST	GFNAM1

GFCR:	PUSHJ	P,GFNM		;POSSIBLE FILE NAME
	JRST	GFNAM2		;LOST
	.SUSET	[.SSNAME,,TFBLK+3]
	.OPEN	FNTC,TFBLK
	JRST	.+2
	JRST	POPJ1
	PUSHJ	P,OFNER
	BARF Can't read font
	POPJ	P,

GFNAM2:	BARF Illegal font name
	POPJ	P,

ASPW:	JUMPE	H,ASPWR		;.SPW
	JUMPLE	K,ASPWR
	SETOM	TABSEF		;freeze width
	JRST	AHVWW

AHVW:	SKIPE	H		;.HVW
	MOVEM	K,HEIGHT
	PUSHJ	P,GNUMAR
	SKIPE	H
	MOVEM	K,VSP
	PUSHJ	P,GNUMAR
	JUMPE	H,RECALM	;No more args
AHVWW:	MOVEM	K,WIDTH
	LSH	K,3
	MOVEM	K,TABW
	JRST	RECALM		;Recalculate, but keep constant margin

AVSP:	PUSHJ	P,GNUMAR	;.VSP
	JUMPE	H,POPJP		;no arg
	MOVEM	K,VSP
	JRST	RECAL

;set various page parameters in 1/100s inch
APWINC:	MOVEM	K,PWINCH	;.PWINCH
	JRST	RECAL

ATWINC:	MOVEM	K,TWINCH	;.TWINCH
	JRST	RECAL

APLINC:	MOVEM	K,PLINCH	;.PLINCH
	JRST	RECAL

ATLINC:	MOVEM	K,TLINCH	;.TLINCH
	JRST	RECAL

;get size in 1/1000 inch
ASINCH:	SKIPE	H		;.SINCH
	MOVEM	K,PWINCH
	PUSHJ	P,GFNUM
	SKIPE	H
	MOVEM	K,TWINCH
	PUSHJ	P,GFNUM
	SKIPE	H
	MOVEM	K,PLINCH
	PUSHJ	P,GFNUM
	SKIPE	H
	MOVEM	K,TLINCH
	PUSHJ	P,GFNUM
	JUMPE	H,RECAL
	MOVEM	K,LMINCH

;FALLS THROUGH

;FALLS IN
;RECALCULATE SIDM TO KEEP LEFT MARG CONSTANT
RECALM:	MOVE	K,PWINCH
	CAMGE	K,TWINCH
	PUSHJ	P,RECWER
	SUB	K,TWINCH
	MOVE	A,LMINCH
	IMULI	A,100.
	IDIV	A,K
	ASH	K,-1
	CAML	B,K
	AOJ	A,
	MOVEM	A,PRSNT
	MOVE	K,PLINCH
	CAMGE	K,TLINCH
	PUSHJ	P,RECLER

;RECALCULATE PAGE & TEXT SIZE IN CHARS AND LINES,
;BASED ON THOSE SIZES IN INCHES, VSP, AND FONT SPECS
RECAL:	MOVE	K,PWINCH	;PAGE WIDTH
	PUSHJ	P,CVWITC	;CONVERT TO # OF CHARS
	PUSHJ	P,APW1
	MOVE	K,TWINCH	;TEXT WIDTH
	PUSHJ	P,CVWITC
	PUSHJ	P,ATW1
	MOVE	K,PLINCH	;PAPER LENGTH
	PUSHJ	P,CVLITC
	PUSHJ	P,APL1
	MOVE	K,TLINCH	;TEXT LENGTH
	PUSHJ	P,CVLITC
	JRST	ATL1

RECWER:	MOVEM	K,TWINCH
	BARF TW>PW
	POPJ	P,

RECLER:	MOVEM	K,TLINCH
	BARF TL>PL
	POPJ	P,

CVLITC:	MOVE	A,HEIGHT
	ADD	A,VSP
	IMUL	K,XVRES
	JRST	CVITCH
CVWITC:	MOVE	A,WIDTH
	IMUL	K,XHRES
;CONVERT # IN 1/1000 INCHES TO CHARS OR LINES
CVITCH:	IDIVI	K,1000.
	CAIL	L,500.
	AOJ	K,
	IDIV	K,A
	ASH	A,-1
	CAML	L,A
	AOJ	K,
ASPWR:	POPJ	P,

;XGP RESOLUTION IN DOTS PER INCH
XHRES:	HRES	;HORIZONTAL
XVRES:	VRES	;VERTICAL

;here when ready to output first text
TXSTRT:	MOVEI	A,-1		;large number
	MOVEM	A,PNST		;to avoid coming here again
	SKIPE	CONTEN
	JRST	CSTART
	SETZM	OUTFLS		;switch output on now
XGSPG:	SKIPE	XGPMOD		;output page of xgp specs (called if pgout was neg)
	SKIPE	XSPGF
	JRST	NOISTZ
	PUSH	P,TYRFL
	MOVEI	A,BUFOUT
	MOVEM	A,TYRFL		;so that margin won't be inserted
	MOVEI	H,[ASCIZ /;SIZE /]
	PUSHJ	P,OPSTH
	MOVE	K,PLINCH
	PUSHJ	P,OPDECK	;print "decimal" # in k
	PUSHJ	P,OPCRLF
	MOVEI	H,[ASCIZ /;VSP /]
	MOVE	K,VSP
	PUSHJ	P,PSTN
	MOVE	K,TOPMAR	;TOP MARGIN TO SEND TO XGP
	MOVEI	H,[ASCIZ /;TOPMAR /]
	PUSHJ	P,PSTN
	SETZ	K,		;REDUNDANT ? (since SIZE specified)
	MOVEI	H,[ASCIZ /;BOTMAR /]
	PUSHJ	P,PSTN
	MOVE	K,LFTMAR	;LEFT MARGIN TO SEND TO XGP
	MOVEI	H,[ASCIZ /;LFTMAR /]
	PUSHJ	P,PSTN
	MOVEI	H,[ASCIZ /;SKIP 1/]
	PUSHJ	P,OPSTHC
	SKIPN	SQUISF
	JRST	.+3
	MOVEI	H,[ASCIZ /;SQUISH/]
	PUSHJ	P,OPSTHC
	MOVEI	H,[ASCIZ /;KSET /]
	PUSHJ	P,OPSTH
	SKIPA	K,[FNTBLK]
XGSPG1:	PUSHJ	P,OPCOMA
	SKIPN	(K)
	JRST	XGSPG2		;this font not specified
	PUSHJ	P,OPFNMA
XGSPG2:	ADDI	K,FNTBKL
	CAIG	K,FNTBLK+<FNTBKL*MAXFNT>
	JRST	XGSPG1
	PUSHJ	P,OPCRLF	;The following appears in first page of file,
				;is ignored by XGP spooler, and is not printed.
	MOVEI	K,ITSNAM
	PUSHJ	P,OPFNM		;Print ITSNAM:UNAME;FNAM1 FNAM2
	PUSHJ	P,OPCRLF
	PUSHJ	P,OPDATE	;Print date
	PUSHJ	P,OPCRLF
	PUSHJ	P,OPINAM	;Print in-file name
	PUSHJ	P,OPCRLF
	POP	P,TYRFL
	JRST	OPFF

OPDATE:	MOVE	H,[440700,,DATE]
DATELP:	ILDB	A,H
	CAIGE	A,40
	POPJ	P,
	PUSHJ	P,@TYRFL
	JRST	DATELP

CSTART:	PUSH	P,TYRFL
	MOVE	A,[@CHARO]
	MOVEM	A,TYRFL
	MOVEI	H,[ASCIZ /.C TJ6-generated Contents/]
	PUSHJ	P,OPSTHC
	JRST	POPTJ
;Here to use XGP -- font switching, special underlining, etc.
AXGP:	HRRZ	A,ONAM		;.XGP and /X
	CAIE	A,'LPT		;ignore if output to LPT or TPL
	CAIN	A,'TPL
	POPJ	P,
	MOVE	A,[XPAGE,,PWINCH]
	BLT	A,VSP		;Initialize page size
	MOVEI	A,25.
	MOVEM	A,HEIGHT
	MOVEI	A,16.
	MOVEM	A,WIDTH
	MOVEI	A,16.*10
	MOVEM	A,TABW
	SETOM	XGPMOD		;Turn on XGP mode
	MOVE	A,[CAMGE W,XLNL]
	MOVEM	A,OPTST
	HRLI	A,(CAMLE W,)	;CAMLE W,XLNL
	MOVEM	A,OPTST1
	SKIPE	OFN2F
	JRST	RECAL		;user specified output FNM2
	MOVSI	A,'XGP
	MOVEM	A,ONAM+2
	MOVEM	A,RNBLK+4
	JRST	RECAL

ASQUIS:	SETOM	SQUISF		;.SQUISH
	POPJ	P,

ANOSPE:	SETOM	XSPGF		;.NOSPEC no XGP spec page
	POPJ	P,

ALTRSP:	MOVEM	K,LTRSPF	;.LTRSPC <arg>	0 arg suppresses letterspacing
	POPJ	P,

XPAGE:	85.*100.		;PW
	11.*1000.		;PL
	6*1000.			;TW
	8*1000.			;TL
	125.*10.		;LM
	6			;V

LATEST:	JUMPN	C,.+3		;See if text has been input
	 SKIPN	 RDTXTF
	 POPJ	 P,
	PUSHJ	P,AERLIN	;Print commmand name
	BARF  command must appear before text
	JRST	POPJ1		;Skip command execution

ADEBUG:	SKIPN	PURED		;.DEBUG
	.VALUE			;Break if impure
	POPJ	P,

OPNRD:	MOVEI	A,2		;Open input file
	HRLM	A,DNAM
	.SUSET	[.SSNAME,,ISYSNM]
	.OPEN	UTYIC,DNAM
	JRST	IPFAIL
	MOVE	A,[UTYIC,,DNAM]
	.RCHST	A,		;Get real file name
	AOS	(P)		;skip return
RESETT:	MOVEI	A,1
	MOVEM	A,INPAGN
	SETZM	INLINE
	MOVE	A,[440700,,RCHBFE]
	MOVEM	A,INPTR		;Force reload
	POPJ	P,

IPFAIL:	PRINT Input 
	MOVEI	K,DNAM
FAILD:	PUSHJ	P,OPFNM
	MOVEI	A,40
	PUSHJ	P,@TYRFL
	.OPEN	ERRC,[SIXBIT /   ERR     !     /]
	.VALUE
FAILLP:	.IOT	ERRC,A
	CAIN	A,14		;Control L
	POPJ	P,
	PUSHJ	P,@TYRFL	;Output reason
	JRST	FAILLP

CMD:	SETZ	Z,		;clear flags
FNR:	PUSHJ	P,GSYL		;return syllable in h, delimiter in a, index in b
CMDIGN:	TLNN	B,CEOCF
	TLNN	Z,CMSYLF	;take care of left arg as followed by space
	JRST	@CMDTB(B)	; : ; or blank syllable
	TLOE	Z,CMFN1F
	JRST	[TLON Z,CMFN2F	;already read 1st name, must be 2nd
		MOVEM H,FNAM2
		JRST @CMDTB(B)]
	MOVEM	H,FNAM1
	JRST	@CMDTB(B)

CMDTB:	CMDBCH	;Illeg char
	CMDCOL	;:
	CMDSEM	;;
	CMSWIT	;/
	FNR	; space or tab
	CMDLEF	;_
	CMEND	;CR

CMSWIT:	PUSHJ	P,@CHARI	;get one char
	CAILE	A,"_
	SUBI	A,40
	CAIN	A,"C		;possibly set switches
	SETOM	SLASHC
	CAIN	A,"X
	SETOM	SLASHX
	CAIN	A,"T
	SKIPE	COMLF
	JRST	FNR
	SETOM	SLASHT		;only set for initial command line
	JRST	FNR

CMEND:	TLNN	Z,CMFN1F
	JRST	CMDILF		;no source file
	MOVEI	H,'DSK		;default device specs
	TLNN	Z,CMDEVF
	HRRM	H,DNAM
	TRNN	Z,CMDEVF
	HRRM	H,ONAM
	MOVE	H,RSYSNM	;default sysnam
	TLNN	Z,CMSNMF
	MOVEM	H,ISYSNM
	TRNN	Z,CMSNMF
	MOVEM	H,OSYSNM
	MOVSI	H,(SIXBIT />/)	;default input fn2
	TLNN	Z,CMFN2F
	MOVEM	H,FNAM2
	MOVE	H,[SIXBIT /MEMO/]	;default output fn2
	TRNN	Z,CMFN2F
	MOVEM	H,ONAM+2
	MOVE	H,FNAM1		;default fn1 of output
	TRNN	Z,CMFN1F
	MOVEM	H,ONAM+1
	POPJ	P,

CMDCOL:	TLNN	Z,CMSYLF	;here on :
	JRST	CMDILF		;nothing came before :
	HLRZM	H,DNAM
	TLO	Z,CMDEVF
	JRST	FNR

CMDSEM:	TLNN	Z,CMSYLF	;here on ;
	JRST	CMDILF
	MOVEM	H,ISYSNM
	TLO	Z,CMSNMF
	JRST	FNR

CMDLEF:	TRNE	Z,-1		;here on _
	JRST	CMDILF		;too many left arrows
	MOVE	A,[DNAM,,ONAM]
	BLT	A,OSYSNM
	HLRZS	Z
	JRST	FNR

CMDBCH:	PRINT Non 6-bit character in file name
	JRST	CMD

CMDILF:	PRINT Bad file name format
	JRST	CMD
;INITIAL CHARACTER BIT TABLE
ICDTAB:	CNNRF+CEOFF,,	;^@			Control characters
	CITCF,,		;^A
	0
	CEOFF,,CEOFX	;^C
	CITCF,,	;^D
	0
	CITCF,,		;^F
	CITCF,,		;^G
	CNNRF,,	;^H BACKSPACE
 CNNRF+CFSPF,,CSPCX	;^I TAB
 CNNRF+CEOLF,,CLNFX	;^J LINEFEED
	CITCF,,		;^K
 CEOFF+CNNRF,,CFFDX	;^L FORMFEED
 CNNRF+CEOLF,,CCRTX	;^M CARRIAGE RETURN
BLOCK ^Q-^N
	CQUOF,,CQUOX	;^Q
BLOCK ^W-^R
	CITCF,,	;^W
	CITCF,,	;^X
	CITCF,,	;^Y
BLOCK 40-^Z
CFSPF+CSMSF,,CSPCX	;SP			;Printing chars
	CEOSF,,C6BTX	;!
	CLOSF,,C6BTX	;"
	REPEAT 4,C6BTX	;# $ % &
	CLOSF,,C6BTX	;'
	0,,C6BTX	;(
	CLOSF,,C6BTX	;)
	0,,C6BTX	;*
	0,,C6BTX	;+
	0,,C6BTX	;,
	CHYPF,,CMINX	;-
	CEOSF,,C6BTX	;.
	0,,CSLSX	;/
REPEAT 10.,CDIGF,,CDIGX	;0-9
	CEOCF,,CCOLX	;:
	CEOCF,,CSEMX	;;
	0,,C6BTX	;<
	0,,C6BTX	;=
	0,,C6BTX	;>
	CEOSF,,C6BTX	;?
	0,,C6BTX	;@			;UPPER CASE
REPEAT 26.,CLETF,,CLETX
	0,,C6BTX	;[
	0,,C6BTX	;\
	CLOSF,,C6BTX	;]
	0,,C6BTX	;^
	0,,CBKAX	;_
	0		;`			;lower case
REPEAT 26.,CLETF,,CLLTX
LOC ICDTAB+177
	CNNRF,,CRBOX	;^? (RBO)

;really the end of all files
REND:	PUSHJ	P,NPAGER	;finish last page
ENDAR:	MOVE	P,PDL
	SKIPN	BLOCKM
	JRST	CLOFI2		;Unit mode
	MOVE	A,OUTCNT	;# of bytes left
	IDIVI	A,5
	JUMPE	B,CLOFI1	;No free bytes in current word
	SKIPA	A,[^C]		;Fill wd with ^C, nulls
	SETZ	A,
	PUSHJ	P,BUFOUT
	SOJG	B,.-2
CLOFI1:	HRLZ	A,OUTPTR
	MOVN	A,A
	ADD	A,[OUTBUF-1,,OUTBUF]
	.IOT	UTYOC,A
CLOFI2:	.FDELE	RNBLK		;rename output file from OUTPUT to MEMO or whatever
	.VALUE
	.CLOSE	UTYOC,
	.LOGOUT			;Flush if top level
	PUSHJ	P,TTYOON
	MOVE	A,NPAGES
	PUSHJ	P,DPT
	PRINT  pages
	SKIPN	PURED
	.VALUE
	.BREAK	16,160000	;have ddt kill job

TTYIB:	POP	P,TYRFL
TTYI:	SOSGE	TCNT		;read chars from tty
	JRST	TFILLB		;first refill TBUF
	ILDB	A,TPNTR		;read from tbuf
	MOVE	B,ICDTAB(A)
	POPJ	P,

TFILLB:	PUSHJ	P,TTYOON	;turn on tty output
TFILL:	SETZM	TCNT		;read chars from tty into TBUF til eol
	MOVE	L,[10700,,TBUF-1]
	MOVEM	L,TPNTR
	PUSHJ	P,OPCRLF	;prompt user
	MOVE	A,PROMPT
TFILL1:	PUSHJ	P,@TYRFL
TFILL2:	PUSHJ	P,TYI		;get one char from tty
	CAIN	A,^G
	JRST	TFILL
	CAIN	A,177
	JRST	TFRBO
TFILL3:	IDPB	A,L		;put into buffer
	AOS	TCNT
	CAIN	A,^J
	JRST	[ PUSHJ P,OPCRLF ? JRST TTYIB ]	;now go back and feed chars to main prog
	CAIE	A,^M
	JRST	TFILL2
	MOVEI	A,^J
	JRST	TFILL3		;put lf into buffer

TFRBO:	SKIPG	TCNT		;here on rubout
	JRST	TFRBO1		;buffer empty
	LDB	A,L
	PUSHJ	P,DECBP		;back up pntr
	SOS	TCNT
	SKIPN	TCTYPE
	JRST	TFILL1		;printing console, echo rubbed out char
	MOVEI	A,^P		;display, back up and rub out
	PUSHJ	P,@TYRFL
	MOVEI	A,"X
	JRST	TFILL1

TFRBO1:	SKIPE	TCTYPE		;buffer empty
	JRST	TFILL2		;display tty, don't do anything
	JRST	TFILL		;printing tty, reprompt user

TTYION:	SETZM	TCNT		;turn on tty input
	MOVEI	A,TTYI
	JRST	TYION

TTYOON:	MOVEI	A,TYO		;switch on tty output
	EXCH	A,TYRFL
	EXCH	A,(P)
	JRST	(A)

TYI:	.IOT 	TYIC,A
	POPJ	P,

TYO:	.IOT	TYOC,A
	POPJ	P,

CONSTA
FPUR==<PURE+1777>_-10.		;# of first pure page

ERBRK:	0			;-1 .value on all errors
PURED:	0			;-1 and pure when purified

CORE==.
CORSIZ==<CORE+1777>_-10.	;we will core down to here

BEGGAR:	MOVE	A,[ICDTAB,,CDTAB]
	BLT	A,CDTAB+CSETSZ-1
	PUSHJ	P,FTYION
	SKIPN	RCHBUF		;skip if jcl
BEG2:	PUSHJ	P,TTYION	;turn on tty input
	SETZB	Z,SLASHC
	SETZM	SLASHT
	SETZM	SLASHX
	SETZM	OFN2F
	PUSHJ	P,FNR		;Get file specs
	TRNE	Z,CMFN2F
	SETOM	OFN2F		;user gave output FNM2
	MOVE	A,CHARI1
	PUSHJ	P,FINLIN	;read till lf
	MOVEM	A,COMTYI
	MOVE	A,ISYSNM
	MOVEM	A,RSYSNM
	SETZ	C,
	SKIPE	SLASHC		;Fix up output device open block
	PUSHJ	P,ACONT		;Table of contents
	SKIPE	SLASHX		;See what output device is
	JRST	BXGPO		;It's XGP
	HRRZ	A,ONAM
	MOVE	B,[-DKTBL,,DKTAB]
	CAMN	A,(B)
	JRST	BDSKO		;Some flavor of DISK
	AOBJN	B,.-2
	pushj p,mchok0
	 jrst BDSKO		;an ITS
	CAIE	A,'TPL
	CAIN	A,'LPT
	JRST	BLPTO
	LSH	A,-12.		;1st letter of odev
	CAIN	A,'T
BTTYO:	SETZM	NWAITF		;tty or tnm
	MOVEI	A,1		;ascii mode
	MOVEI	B,UNITYO	;unit mode
BOPN:	HRLM	A,ONAM		;.open mode
	MOVEM	B,CHARO		;output instr
	PUSHJ	P,OPNRD		;open input file
	JRST	BEG2		;failed
	PUSHJ	P,WINIT		;open output file
	JRST	BEG2
				;all .OPENs succeeded, start examining input
BEG3:	SETOM	COMLF		;set command line flag
	MOVEI	A,PPAX
	MOVEM	A,TYRFL		;where to pushj to print char
	MOVEI	A,">
	MOVEM	A,PROMPT
	PUSHJ	P,FTYION	;read from file
	SKIPE	SLASHT
	PUSHJ	P,TTYION	;read from tty
	JRST	MNBEG		;Start analysing file

WINIT:	.SUSET	[.SSNAME,,OSYSNM]
	MOVE	A,[ONAM+1,,RNBLK+3]
	BLT	A,RNBLK+4		;save file name
	MOVE	A,[[SIXBIT /TJ6/
			   'OUTPUT],,ONAM+1]
	BLT	A,ONAM+2		;open TJ6 OUTPUT instead
	.OPEN	UTYOC,ONAM
	JRST	OPFAIL
	JRST	POPJ1

OPFAIL:	PRINT Output 
	MOVEI	K,ONAM
	JRST	FAILD

BLPTO:	MOVEI	A,7			;blk image mode
	JRST	BBLKO
BXGPO:	PUSHJ	P,AXGP
BDSKO:	SETOM	FFFF
	MOVEI	A,3			;block ascii
BBLKO:	SETOM	NWAITF			;don't wait
	SETOM	BLOCKM
	MOVEI	B,OBSIZ*5		;set up output buffer
	MOVEM	B,OUTCNT
	MOVE	B,[440700,,OUTBUF]
	MOVEM	B,OUTPTR
	MOVEI	B,BUFOUT
	JRST	BOPN

;; For the ITSNMS table
mchcnt==:20
mchtab: block mchcnt

;; Look for an ITS name in RH(A)
mchok0:	push p,d
	hrlzs a			;swap a
	movsi d,-mchcnt
mchok1:	camn a,mchtab(d)
	 jrst popj1d		;skip return
	skipe mchtab(d)		;no more to check?
	 aobjn d,mchok1
	pop p,d
	hlrzs a			;swap back
	popj p,			;non-skip return
popj1d:	pop p,d
	hlrzs a			;swap back
	jrst popj1

DKTAB:	'DSK				;these devices open in block ascii mode
	'NUL
DKTBL==.-DKTAB

BEGJCL:	MOVE	A,[10700,,RCHBUF-1]
	ILDB	B,A		;find end of jcl
	CAIE	B,15
	JRST	.-2
	MOVEI	B,^J
	IDPB	B,A
	SETZ	B,
	IDPB	B,A		;write null byte
	JRST	BEG1

BEG:	SETOM	RAN		;indicate program has run
	.OPEN	TYOC,[4001,,'TTY]	;Allow ^P codes
	.VALUE
	.OPEN	TYIC,[10,,'TTY]
	.VALUE
	.SUSET [.SMASK,,[1]]	;type in bit on
	.SUSET [.SPICL,,[-1]]	;enable all
	MOVE P,PDL
	.CALL [SETZ
		'SSTATU
		REPEAT 5 2000,,
		SETZM A]	;Read name of ITS
	.VALUE
	HLRZM	A,ITSNAM
	.SUSET [.RUNAME,,UNAME]	;Uname
	.SUSET [.RSNAME,,RSYSNM]	;get sname
	.BREAK	12,[5,,RCHBUF]	;try reading jcl
BEGDAT: .CALL	[SETZ
		'RQDATE
		SETZM B]
	 .VALUE
	LDB	A,[270400,,B]	;month
	MOVE	H,MONTHS-1(A)	;byte pntr to asciz month
	MOVE	K,[440700,,DATE]
	PUSHJ	P,ASHTK		;move month to date buffer
	PUSH	P,TYRFL
	MOVEI	A,BEGCH		;redirect output
	MOVEM	A,TYRFL
	PUSH	P,B
	LDB	A,[220500,,B]	;day
	PUSHJ	P,DPT
	MOVE	H,[440700,,[ASCIZ /, /]]
	PUSHJ	P,ASHTK
	POP	P,B
	LDB	A,[331100,,B]	;year
	ADDI	A,1900.
	PUSHJ	P,DPT
	POP	P,TYRFL
	SKIPE	RCHBUF
	JRST	BEGJCL		;there is a jcl
	PUSHJ	P,PVERSE	;print NNTJ6 and version #
BEG1:	.CALL	[SETZ		;get tctyp
		'CNSGET
		1000,,TYIC
		2000,,0
		2000,,0
		402000,,TCTYPE]
	.VALUE
	JRST	BEGGAR

	IDPB	A,K
ASHTK:	ILDB	A,H		;move asciz in h to asci in k
	JUMPN	A,.-2
	POPJ	P,

BEG6D:	ADDI	A,40		;change a to asci
BEGCH:	IDPB	A,K
	POPJ	P,

MONTHS:
	440700,,[ASCIZ /January /]
	440700,,[ASCIZ /February /]
	440700,,[ASCIZ /March /]
	440700,,[ASCIZ /April /]
	440700,,[ASCIZ /May /]
	440700,,[ASCIZ /June /]
	440700,,[ASCIZ /July /]
	440700,,[ASCIZ /August /]
	440700,,[ASCIZ /September /]
	440700,,[ASCIZ /October /]
	440700,,[ASCIZ /November /]
	440700,,[ASCIZ /December /]

PURIFY:	SKIPN	[VBLKL]
	SKIPE	PURED
	.VALUE			;can't or already purify(ied)
	SKIPE	RAN
	.VALUE			;program has been run
	MOVEI	A,FPUR+FPUR_9+400000
	SETOM	PURED
PURIF1:	.CBLK	A,
	.VALUE
	ADDI	A,1001
	CAIGE	A,HICORE+HICORE_9+400000
	JRST	PURIF1
	.VALUE	[ASCIZ /:PURIFIED
:PDUMP SYS;TS NTJ6/]
	JRST	BEG

EPURE==.			;end of purity
	VARIABLES		;there should not be any
	VBLKL==.-EPURE
IFN VBLKL,[PRINTC /VARIABLES=IMPURITY
/]
CONSTA
HILOC==.
HICORE==<HILOC+1777>_-10.
END BEG
