/*
 * code common to SORT and USORT
 *
 */

# define	LL	512
# define	NN	7
# define	MEM	(16*2048)
# define MAX_FIELDS	10
# define large_pointer 0777777

extern int cin, cout;

int	ibuf;
int	obuf;
int	ifiles[20];
char	file[20];
char	*filep;
int	nfiles;
int	nlines;
int	ntext;
int	*lspace;
char	*tspace, *etext, *estop;
int	cmp();
int	term();
int 	mflg;
int	uflg;
char	*outfil;
char	tabchar;
int 	eargc;
char	**eargv;
char	*setfil(), *mk_temp();

# ifndef usort

char	fold[128] {
	0000,0001,0002,0003,0004,0005,0006,0007,
	0010,0011,0012,0013,0014,0015,0016,0017,
	0020,0021,0022,0023,0024,0025,0026,0027,
	0030,0031,0032,0033,0034,0035,0036,0037,
	0040,0041,0042,0043,0044,0045,0046,0047,
	0050,0051,0052,0053,0054,0055,0056,0057,
	0060,0061,0062,0063,0064,0065,0066,0067,
	0070,0071,0072,0073,0074,0075,0076,0077,
	0100,0101,0102,0103,0104,0105,0106,0107,
	0110,0111,0112,0113,0114,0115,0116,0117,
	0120,0121,0122,0123,0124,0125,0126,0127,
	0130,0131,0132,0133,0134,0134,0136,0137,
	0140,0101,0102,0103,0104,0105,0106,0107,
	0110,0111,0112,0113,0114,0115,0116,0117,
	0120,0121,0122,0123,0124,0125,0126,0127,
	0130,0131,0132,0173,0174,0175,0176,0177
};
char	nofold[128];
char	dict[128] {
	1,1,1,1,1,1,1,1,1,0,0,1,1,1,1,1,
	1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
	0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,
	1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
	0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1
};
char	nodict[128] { 1 };

struct	field {
	char *code;
	char *ignore;
	int nflg;
	int rflg;
	int bflg;
	char *m[2];
	char *n[2];
}	fields[MAX_FIELDS];
struct field protofield {
	&fold, &nodict,
	0, 1, 0, 0, -1, 0, 0
};
int	nfields;

# endif

int 	error 1;

main (argc, argv)
	char **argv;

	{char *arg;

	on (ctrlg_interrupt, term);
	on (ctrls_interrupt, term);

# ifndef usort

	{register int a;
	for(a=0; a<128; a++) nofold[a] = a;
	}
	nodict[127] = 1;
	copyproto();

# endif

# ifdef usort

	uflg++;

# endif

	eargv = argv;
	while (--argc > 0) {
		if(**++argv == '-') for(arg = *argv;;) {
			switch(*++arg) {
			case '\0':
				if(arg[-1] == '-')
					eargv[eargc++] = "-";
				break;

			case 'm':
				mflg++;
				continue;

# ifndef usort
			case 'u':
				uflg++;
				continue;
# endif
			case 'o':
				if(--argc > 0)
					outfil = *++argv;
				continue;

			default:

# ifndef usort
				get_field(++*argv,1);
# endif
# ifdef usort
				badopt (*argv);
# endif
				break;
			}
			break;
		} else if (**argv == '+') {
# ifndef usort
			if(++nfields>=MAX_FIELDS) {
				mess ("Too many keys");
				cexit(1);
			}
			copyproto();
			get_field(++*argv,0);
# endif
# ifdef usort
			badopt (*argv);
# endif
		} else
			eargv[eargc++] = *argv;
	}

# ifndef usort
	{register int a;
	int *q;
	q = &fields[0];
	for(a=1; a<=nfields; a++) {
		register int i, *p;
		if (!cmpproto (&fields[a])) continue;
		p = &fields[a];
		for(i=0; i<5; i++) p[i] = q[i];
		}
	}
# endif

	if (eargc == 0) eargv[eargc++] = "-";
	lspace = tspace = calloc (MEM);
	estop = tspace + MEM;
	etext = estop - LL;
	nlines = ((MEM-LL)/(sizeof nlines)) & 077777;
	nlines =/ 5;
	tspace = lspace+nlines;
	stcpy ("_sort_.tmXaa", file);;
loop:
	filep = mk_temp ();
	nfiles = eargc;
	if (!mflg)
		{ibuf = -1;
		sort();
		cclose(ibuf);
		}
	{register int a;
	for(a = mflg?0:eargc; a+NN < nfiles; a=+NN) {
		newfile();
		merge(a, a+NN);
		}
	if(a != nfiles) {
		oldfile();
		merge(a, nfiles);
		}
	}
	error = 0;
	term();
	}

sort()

	{register char *cp;
	register int *lp, c;
	int done;
	int i;
	int f;

	done = 0;
	i = 0;
	do {
		cp = tspace;
		lp = lspace;
		while(lp < lspace+nlines && cp < etext) {
			*lp++ = cp;
			for (;;)
				{if (ibuf >= 0)
					{*cp++ = c = cgetc (ibuf);
					if (cp >= estop) mess ("Line too long");
					if (c == '\n') break;
					if (c > 0 || !ceof (ibuf)) continue;
					cp--;
					cclose(ibuf);
					}
				if (i < eargc)
					{if (f = setfil(i++))
						{if ((ibuf = copen(f, 'r')) == OPENLOSS)
							cant(f);
						}
					else ibuf = cin;
					}
				else
					{done++;
					break;
					}
			}
			if (done) {
				lp--;
				break;
			}
		}
		iqsort(lspace, lp-lspace, cmp);
		if(done == 0 || nfiles != eargc)
			newfile(); else
			oldfile();
		while(lp > lspace) {
			cp = *--lp;
			if (uflg && lp > lspace &&
				cmp (&cp, &lp[-1])==0) continue;
			if(*cp)
				do
				cputc (*cp, obuf);
				while (*cp++ != '\n');
		}
		cclose (obuf);
	} while(done == 0);
}

struct merg
	{
	char	l[LL];
	int	b;
	};

merge(a, b)

	{register struct merg *p;
	register char *cp;
	register int i;
	int *ip, f, j, k, l;

	p = lspace;
	j = 0;
	for(i=a; i<b; i++) {
		f = setfil(i);
		if(f == 0) p->b = 0;
		else if ((p->b = copen (f, 'r')) == OPENLOSS) cant(f);
		ifiles[j] = p;
		if(!rline(p)) j++;
		p++;
	}

	do {
		i = j;
		iqsort(ifiles, i, cmp);
		l = 0;
		while(i--) {
			cp = ifiles[i];
			if(*cp == '\0') {
				l = 1;
				if(rline(ifiles[i])) {
					k = i;
					while(++k < j)
						ifiles[k-1] = ifiles[k];
					j--;
				}
			}
		}
	} while(l);

	i = j;
	if(i > 0) for(;;) {
		cp = ifiles[i-1];
		if(i == 1 || !uflg || cmp(&ifiles[i-1], &ifiles[i-2]))
			do
				cputc (*cp, obuf);
			while(*cp++ != '\n');
		if(rline(ifiles[i-1])) {
			i--;
			if(i == 0)
				break;
		}
		ip = &ifiles[i];
		while (--ip > ifiles && cmp(ip, ip-1) < 0) {
			p = *ip;
			*ip = *(ip-1);
			*(ip-1) = p;
		}
	}
	p = lspace;
	for(i=a; i<b; i++) {
		cclose(p->b);
		p++;
	}
	cclose (obuf);
}

rline(mp)
struct merg *mp;
{
	register char *cp;
	register int *bp, c;

	bp = mp->b;
	cp = mp->l;
	do {
		c = cgetc(bp);
		if (c <= 0 && ceof (bp)) return(1);
		*cp++ = c;
	} while(c != '\n');
	*cp = '\0';
	return (0);
}

newfile()

	{char *s;

	s = setfil (nfiles);
	if ((obuf = copen (s, 'w')) == OPENLOSS)
		{mess ("Can't create temp: %s", s);
		term();
		}
	nfiles++;
	}

char *setfil(i)

	{if (i < eargc)
		if (eargv[i][0] == '-' && eargv[i][1] == '\0')
			return (0);
		else return (eargv[i]);
	i =- eargc;
	filep[0] = i/26 + 'a';
	filep[1] = i%26 + 'a';
	return(file);
	}

oldfile()

	{if (outfil)
		{if ((obuf = copen (outfil, 'w')) == OPENLOSS)
			{mess ("Can't create output file: %s", outfil);
			term ();
			}
		}
	else obuf = cout;
	}

term()

	{register int i;

	if (nfiles == eargc) nfiles++;
	for (i=eargc; i<nfiles; i++) delete (setfil(i));
	cexit (error);
	}

# ifdef usort

cmp (a, b)
	char **a, **b;

	{register char *ra, *rb;
	ra = *a - 1;
	rb = *b - 1;
	while (*++ra == *++rb) if (*ra == '\n') return (0);
	return (*rb - *ra);
	}

# endif

# ifndef usort

cmp (i, j)
	char **i, **j;

	{register char *pa, *pb;
	int a, b, k, sb;
	char *code, *ignore, *la, *lb, *ipa, *ipb, *jpa, *jpb;
	register int sa;
	struct field *fp;

	for(k = nfields>0; k<=nfields; k++) {
		fp = &fields[k];
		pa = *i;
		pb = *j;
		if (k)
			{la = skip(pa, fp, 1);
			pa = skip(pa, fp, 0);
			lb = skip(pb, fp, 1);
			pb = skip(pb, fp, 0);
			}
		else
			{la = large_pointer;
			lb = large_pointer;
			}
		if(fp->nflg)
			{while (blank(*pa)) pa++;
			while (blank(*pb)) pb++;
			sa = sb = fp->rflg;
			if(*pa == '-')
				{pa++;
				sa = -sa;
				}
			if(*pb == '-')
				{pb++;
				sb = -sb;
				}
			if (sa != sb) sa = 0;
			for (ipa = pa; ipa<la&&digit(*ipa); ipa++);
			for (ipb = pb; ipb<lb&&digit(*ipb); ipb++);
			jpa = ipa;
			jpb = ipb;
			a = 0;
			if(sa) while(ipa > pa && ipb > pb)
				if(b = *--ipb - *--ipa)	a = b;
			while(ipa > pa)	if(*--ipa != '0')
					return(sa ? -sa : sb);
			while(ipb > pb)	if(*--ipb != '0')
					return(sa ? sa : sb);
			if (a) return(a*sa);
			if (*(pa=jpa) == '.') pa++;
			if (*(pb=jpb) == '.') pb++;
			while (pa<la && digit(*pa))
				if(pb<lb &&digit(*pb))
					{if(a = *pb++ - *pa++)
						return(sa ? a*sa : sb);
					}
				else if(*pa++ != '0')
					return(sa ? -sa : sb);
			while (pb<lb && digit(*pb)) if(*pb++ != '0')
					return(sa ? sa : sb);
			continue;
			}
		code = fp->code;
		ignore = fp->ignore;
loop:		while (*pa<0 || ignore[*pa]) pa++;
		while (*pb<0 || ignore[*pb]) pb++;
		if (pa>=la || *pa=='\n')
			{if(pb<lb && *pb!='\n') return(fp->rflg);
			else continue;
			}
		if (pb>=lb || *pb=='\n') return(-fp->rflg);
		if ((sa = code[*pb++]-code[*pa++]) == 0) goto loop;
		return (sa*fp->rflg);
		}
	pa = *i;
	pb = *j;
	while (*pa != '\n')
		{if(*pa == *pb)
			{pa++;
			pb++;
			continue;
			}
		if (*pb == '\n') return(-1);
		return (*pb - *pa);
		}
	return (*pb != '\n');
	}

skip (pp, fp, j)
	struct field *fp;
	char *pp;

	{register int i;
	register char *p;

	p = pp;
	if ((i=fp->m[j]) < 0) return (large_pointer);
	while (i-- > 0)
		{if (tabchar != 0)
			{while (*p != tabchar)
				if (*p != '\n') p++;
				else goto ret;
			p++;
			}
		else
			{while (blank(*p)) p++;
			while (!blank(*p))
				if (*p != '\n') p++;
				else goto ret;
			}
		}
	if (fp->bflg) while (blank(*p)) p++;
	i = fp->n[j];
	while (i-- > 0)
		{if (*p != '\n') p++;
		else goto ret;
		} 
ret:	return (p);
	}

digit(c) {return(c <= '9' && c >= '0');}

copyproto()

	{register struct field *fp;

	fp = &fields[nfields];
	fp->code = protofield.code;
	fp->ignore = protofield.ignore;
	fp->nflg = protofield.nflg;
	fp->rflg = protofield.rflg;
	fp->bflg = protofield.bflg;
	fp->m[0] = protofield.m[0];
	fp->m[1] = protofield.m[1];
	fp->n[0] = protofield.n[0];
	fp->n[1] = protofield.n[1];
	}

cmpproto(fp)
	struct field *fp;

	{if (fp->code != protofield.code) return (0);
	if (fp->ignore != protofield.ignore) return (0);
	if (fp->nflg != protofield.nflg) return (0);
	if (fp->rflg != protofield.rflg) return (0);
	if (fp->bflg != protofield.bflg) return (0);
	return (1);
	}

get_field(s,k)
	char *s;

	{register struct field *p;
	p = &fields[nfields];
	for(; *s!=0; s++) {
		switch(*s) {
		case '\0':
			return;

		case 'a':
			p->code = nofold;
			break;

		case 'b':
			p->bflg++;
			break;

		case 'd':
			p->ignore = dict;
			break;

		case 'n':
			p->nflg++;
			break;
		case 't':
			tabchar = *++s;
			if(tabchar == 0) s--;
			break;

		case 'r':
			p->rflg = -1;
			break;

		case '0':
		case '1':
		case '2':
		case '3':
		case '4':
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			p->m[k] = number(&s);
			if(*s == '.') s++;
			p->n[k] = number(&s);
			s--;
			break;
		default:
			badopt (s);
		}
	}
}

number(ppa)
	char **ppa;

	{int n;
	register char *pa;
	pa = *ppa;
	n = 0;
	while(digit(*pa))
		n = n*10 + *pa++ - '0';
	*ppa = pa;
	return(n);
	}

blank(c)

	{if(c==' ' || c=='\t') return(1);
	return(0);
	}

# endif

int	(*qscmp)();

iqsort (a, n, fc)
	int *a;
	int n;
	int (*fc)();

	{qscmp = fc;
	qs1 (a, a+n);
	}

qs1 (a, l)
	int *a, *l;

	{register int *i, *j;
	int *lp, *hp;
	int n, c;

start:
	if ((n=l-a) <= 1) return;
	n = (n/2) & 077777;
	hp = lp = a+n;
	i = a; j = l-1;

	for (;;)
		{if (i<lp)
			{if ((c = (*qscmp)(i, lp)) == 0)
				{qsexc (i, --lp);
				continue;
				}
			else if (c < 0)
				{++i;
				continue;
				}
			}
loop:
		if (j > hp)
			{if ((c = (*qscmp)(hp, j)) == 0)
				{qsexc (++hp, j);
				goto loop;
				}
			else if (c > 0)
				{if (i == lp)
					{qstexc (i, ++hp, j);
					i = ++lp;
					goto loop;
					}
				qsexc (i, j);
				--j;
				++i;
				continue;
				}
			else
				{--j;
				goto loop;
				}
			}

		if (i == lp)
			{if (lp-a >= l-hp)
				{qs1 (hp+1, l);
				l = lp;
				}
			else
				{qs1 (a, lp);
				a = hp+1;
				}
			goto start;
			}

		qstexc (j, --lp, i);
		j = --hp;
		}
	}

qsexc (i, j)
	int *i, *j;

	{register int temp;

	temp = *i;
	*i = *j;
	*j = temp;
	}

qstexc (i, j, k)
	int *i, *j, *k;

	{register int temp;

	temp = *i;
	*i = *k;
	*k = *j;
	*j = temp;
	}

char *mk_temp ()

	{char *p;
	int fd;

	p = file;
	while (*p != 'X') p++;
	for (*p = 'a';;(*p)++)
		{if ((fd = fopen (file, 0)) <= 0)
			{fd = fopen (file, 1);
			if (fd >= 0) break;
			}
		else close (fd);
		if (*p == 'z')
			{mess ("Can't create temporary files");
			cexit (1);
			}
		}
	close (fd);
	p++;
	return (p);
	}

badopt (s)
	char *s;

	{mess ("Bad option: %s", s);
	term ();
	}

cant (f)

	{mess ("Can't open %s", f);
	term ();
	}

mess (s, a1, a2, a3)
	char *s;

	{extern int cerr;
	cprint (cerr, s, a1, a2, a3);
	cputc ('\n', cerr);
	}

