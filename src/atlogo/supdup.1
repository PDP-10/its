
;-*-MIDAS-*-


.NLIST
.ENABL	LC
;
;
; The following equates are from the ATARI 400/800 Operating System
; listing.  Probably (C) Warner Communications 1980.
;
;
;	Colleen Operating System Equate File
;

CHRORG	=	$E000	;CHARACTER SET
VECTBL	=	$E400	;VECTOR TABLE
VCTABL	=	$E480	;RAM VECTOR INITIAL VALUE TABLE
CIOORG	=	$E4A6	;CENTRAL I/O HANDLER
INTORG	=	$E6D5	;INTERRUPT HANDLER
SIOORG	=	$E944	;SERIAL I/O HANDLER
DSKORG	=	$EDEA	;DISK HANDLER
PRNORG	=	$EE7B	;PRINTER HANDLER
CASORG	=	$EF41	;CASSETTE HANDLER
MONORG	=	$F0E3	;MONITOR/POWER UP MODULE
KBDORG	=	$F3E4	;KEYBOARD/DISPLAY HANDLER
;
;
;
;
;	VECTOR TABLE
;
;	HANLDER ENTRY POINTS ARE CALLED OUT IN THE FOLLOWING VECTOR
;	TABLE.  THESE ARE THE ADDRESSES MINUS ONE.
;
;	Example for Editor
;
;	E400	Open
;	   2	Close
;	   4	Get
;	   6	Put
;	   8	Status
;	   A	Special
;	   C	Jump to Power on initialization routine
;
;
;
EDITRV	=	$E400	;EDITOR
SCRENV	=	$E410	;TELEVISION SCREEN
KEYBDV	=	$E420	;KEYBOARD
PRINTV	=	$E430	;PRINTER
CASETV	=	$E440	;CASSETTE
;
;	JUMP VECTOR TABLE
;
;THE FOLLOWING IS A TABLE OF JUMP INSTRUCTIONS
;TO VARIOUS ENTRY POINTS IN THE OPERATING SYSTEM
;
DISKIV	=	$E450	;disk initialization
DSKINV	=	$E453	;disk interface
CIOV	=	$E456	;central input output routine

ICZERO	=	$0	;proper values for X
ICONE	=	$10	;when calling CIOV for each
ICTWO	=	$20	;of the IO control Blocks
ICTHRE	=	$30
ICFOUR	=	$40
ICFIVE	=	$50
ICSIX	=	$60
ICSEVE	=	$70

SIOV	=	$E459	;serial input output routine
SETVBV	=	$E45C	;set system timers routine
; With respect to SETVBV, the call sequence is
; X - MSB of vector/timer
; Y - LSB of vector/timer
; A - # of vector to hack
SETMR1	=	1	;Timer	1
SETMR2	=	2	;	2
SETMR3	=	3	;	3
SETMR4	=	4	;	4
SETMR5	=	5	;	5
SETIMM	=	6	;Immediate VBLANK
SETDEF	=	7	;Deffered VBLANK





SYSVBV	=	$E45F	;SYSTEM VERTICAL BLANK CALCULATIONS
XITVBL	=	$E462	;EXIT VERTICAL BLANK CALCULATIONS
SIOINV	=	$E465	;SERIAL INPUT OUTPUT INITIALIZATION
SENDEV	=	$E468	;SEND ENABLE ROUTINE
INTINV	=	$E46B	;INTERRUPT HANDLER INITIALIZATION
CIOINV	=	$E46E	;CENTRAL INPUT OUTPUT INITIALIZATION
BLKBDV	=	$E471	;BLACKBOARD MODE
WARMSV	=	$E474	;WARM START ENTRY POINT
COLDSV	=	$E477	;COLD START ENTRY POINT
RBLOKV	=	$E47A	;CASSETTE READ BLOCK ENTRY POINT VECTOR
CSOPIV	=	$E47D	;CASSETTE OPEN FOR INPUT VECTOR
;VCTABL	=	$E480
;
;
;	OPERATING SYSTEM EQUATES
;
;	COMMAND CODES FOR IOCBS
OPEN	=	3	;OPEN FOR INPUT/OUTPUT
GETREC	=	5	;GET RECORD (TEXT)
GETCHR	=	7	;GET CHARACTER(S)
PUTREC	=	9	;PUT RECORD (TEXT)
PUTCHR	=	$B	;PUT CHARACTER(S)
CLOSE	=	$C	;CLOSE DEVICE
STATIS	=	$D	;STATUS REQUEST
SPECIL	=	$E	;BEGINNING OF SPECIAL ENTRY COMMANDS
;
;	SPECIAL ENTRY COMMANDS
DRAWLN	=	$11	;DRAW LINE
FILLIN	=	$12	;DRAW LINE WITH RIGHT FILL
RENAME	=	$20	;RENAME DISK FILE
DELETE	=	$21	;DELETE DISK FILE
FORMAT	=	$22	;FORMAT
LOCKFL	=	$23	;LOCK FILE TO READ ONLY
UNLOCK	=	$24	;UNLOCK LOCKED FILE
POINT	=	$25	;POINT SECTOR
NOTE	=	$26	;NOTE SECTOR
IOCFRE	=	$FF	;IOCB "FREE"
;
;	AUX1 EQUATES
;	() INDICATES WHICH DEVICES USE BIT
APPEND	=	$1	;OPEN FOR WRITE APPEND (D), OR SCREEN READ (E)
DIRECT	=	$2	;OPEN FOR DIRECTORY ACCESS (D)
OPNIN	=	$4	;OPEN FOR INPUT (ALL DEVICES)
OPNOT	=	$8	;OPEN FOR OUTPUT (ALL DEVICES)
OPNINO	=	OPNIN+OPNOT	;OPEN FOR INPUT AND OUTPUT (ALL DEVICES)
MXDMOD	=	$10	;OPEN FOR MIXED MODE (E,S)
INSCLR	=	$20	;OPEN WITHOUT CLEARING SCREEN (E,S)
;
;	DEVICE NAMES
;
SCREDT	=	'E	;SCREEN EDITOR (R/W)
KBD	=	'K	;KEYBOARD (R ONLY)
DISPLY	=	'S	;SCREEN DISPLAY (R/W)
PRINTR	=	'P	;PRINTER (W ONLY)
CASSET	=	'C	;CASSETTE
MODEM	=	'M	;MODEM
DISK	=	'D	;DISK
;
;
;
;
;	OPERATING SYSTEM STATUS CODES
;
SUCCES	=	$01	;SUCCESSFUL OPERATION
;
BRKABT	=	$80	;BREAK KEY ABORT
PRVOPN	=	$81	;IOCB ALREADY OPEN
NONDEV	=	$82	;NON-EXISTANT DEVICE
WRONLY	=	$83	;IOCB OPENED FOR WRITE ONLY
NVALID	=	$84	;INVALID COMMAND
NOTOPN	=	$85	;DEVICE OR FILE NOT OPEN
BADIOC	=	$86	;INVALID IOCB NUMBER
RDONLY	=	$87	;IOCB OPENED FOR READ ONLY
EOFERR	=	$88	;END OF FILE
TRNRCD	=	$89	;TRUNCATED RECORD
TIMOUT	=	$8A	;PERIPHERAL TIME OUT
DNACK	=	$8B	;DEVICE DOES NOT ACKNOWLEDGE COMMAND
FRMERR	=	$8C	;SERIAL BUS FRAMING ERROR
CRSROR	=	$8D	;CURSOR OVERRANGE
OVRRUN	=	$8E	;SERIAL BUS DATA OVERRUN
CHKERR	=	$8F	;SERIAL BUS CHECKSUM ERROR
;
DERRER	=	$90	;PERIPHERAL DEVICE ERROR (OPERATION NOT COMPLETED)
BADMOD	=	$91	;BAD SCREEN MODE NUMBER
FNCNOT	=	$92	;FUNCTION NOT IMPLEMENTED IN HANDLER
SCRMEM	=	$93	;INSUFICIENT MEMORY FOR SCREEN MODE
;
;
;
;
;
;	PAGE ZERO RAM ASSIGNMENTS
;
LINZBS	=	$0000	;LINBUG RAM (WILL BE REPLACED BY MONITOR RAM)
;
;	THESE LOCATIONS ARE NOT CLEARED
CASINI	=	$0002	;CASSETTE INIT LOCATION
RAMLO	=	$0004	;RAM POINTER FOR MEMORY TEST
TRAMSZ	=	$0006	;TEMPORARY REGISTER FOR RAM SIZE
TSTDAT	=	$0007	;RAM TEST DATA REGISTER
;
;	CLEARED ON COLD START ONLY
WARMST	=	$0008	;WARM START FLAG
BOOTQ	=	$0009	;SUCCESSFUL BOOT FLAG <WAS BOOT?>
DOSVEC	=	$000A	;DISK SOFTWARE START FLAG
DOSINI	=	$000C	;DISK SOFTWARE INIT ADDRESS
APPMHI	=	$000E	;APPLICATIONS MEMORY HI LIMIT
;
;	CLEARED ON A COLD OR WARM START
INTZBS	=	$0010	;INTERRUPT HANDLER
POKMSK	=	$0010	;SYSTEM MASK FOR POKEY IRQ HANDLER
BRKKEY	=	$0011	;BREAK KEY FLAG
RTCLOCK	=	$0012	;REAL TIME CLOCK (IN 16 MSEC UNITS)
;
BUFADR	=	$0015	;INDIRECT BUFFER ADDRESS REGISTER
;
ICCOMT	=	$0017	;COMMAND FOR VECTOR
;
DSKFMS	=	$0018	;DISK FILE MANAGER POINTER
;
DSKUTL	=	$001A	;DISK UTILITIES POINTER
;
PTIMOT	=	$001C	;PRINTER TIME OUT REGISTER
PBPNT	=	$001D	;PRINTER BUFFER POINTER
PBUFSZ	=	$001E	;PRINT BUFFER SIZE
PTEMP	=	$001F	;TEMPORARY REGISTER
;
ZIOCB	=	$0020	;ZERO PAGE I/O CONTROL BLOCK
IOCBSZ	=	16	;NUMBER OF BYTES PER IOCB
MAXIOC	=	8*IOCBSZ	;LENGTH OF THE IOCB AREA
IOCBAS	=	$0020
ICHIDZ	=	$0020	;HANDLER INDEX NUMBER (FF == IOCB FREE)
ICDNOZ	=	$0021	;DEVICE NUMBER (DRIVE NUMBER)
ICCOMZ	=	$0022	;COMMAND CODE
ICSTAZ	=	$0023	;STATUS OF LAST IOCB ACTION
ICBALZ	=	$0024	;BUFFER ADDRESS LOW BYTE
ICBAHZ	=	$0025	;BUFFER ADDRESS HIGH BYTE
ICPTLZ	=	$0026	;PUT BYTE ROUTINE ADDRESS - 1
ICPTHZ	=	$0027	;
ICBLLZ	=	$0028	;BUFFER LENGTH LOW BYTE
ICBLHZ	=	$0029
ICAX1Z	=	$002A	;AUXILIARY INFORMATION FIRST BYTE
ICAX2Z	=	$002B
ICSPRZ	=	$002C	;TWO SPARE BYTES (CIO LOCAL USE)
ICIDNO	=	ICSPRZ+2	;ICOB NUMBER X 16
CIOCHR	=	ICSPRZ+3	;CHARACTER BYTE FOR CURRENT OPERATION
;
STATUS	=	$0030	;INTERNAL STATUS STORAGE
CHKSUM	=	$0031	;CHECKSUM (SINGLE BYTE SUM WITH CARRY)
BUFRLO	=	$0032	;POINTER TO DATA BUFFER (LO BYTE)
BUFRHI	=	$0033	;POINTER TO DATA BUFFER (HI BYTE)
BFENLO	=	$0034	;NEXT BYTE PAST END OF DATA BUFFER (LO BYTE)
BFENHI	=	$0035	;NEXT BYTE PAST END OF DATA BUFFER (HI BYTE)
CRETRY	=	$0036	;NUMBER OF COMMAND FRAME RETRIES
DRETRY	=	$0037	;NUMBER OF DEVICE RETRIES
BUFRFL	=	$0038	;DATA BUFFER FULL FLAG
RECVDN	=	$0039	;RECIEVE DONE FLAG
XMTDON	=	$003A	;TRANSMISSION DONE FLAG
CHKSNT	=	$003B	;CHECKSUM SENT FLAG
NOCKSM	=	$003C	;NO CHECKSUM FOLLOWS DATA FLAG
;
;
BPTR	=	$003D
FTYPE	=	$003E
FEOF	=	$003F
FREQ	=	$0040
SOUNDR	=	$0041	;NOISY I/O FLAG (ZERO IS QUIET)
CRITIC	=	$0042	;DEFINES CRITICAL SECTION (CRITICAL IF NON-ZERO)
;
FMSZPG	=	$0043	;TOTAL OF 7 BYTES FOR DISK FILE MANAGER ZERO PAGE
;
;
CKEY	=	$004A	;FLAG SET WHEN GAME START PRESSED
CASSBT	=	$004B	;CASSETTE BOOT FLAG
DSTAT	=	$004C	;DISPLAY STATUS
;
ATRACT	=	$004D	;ATRACT FLAG
DRKMSK	=	$004E	;DARK ATRACT FLAG
COLRSH	=	$004F	;ATRACT COLOR SHIFTER (EOR'D WITH PLAYFIELD COLORS)
;
;LEDGE	=	2	;LMARGN'S VALUE AT COLD START
;REDGE	=	39	;
TMPCHR	=	$0050
HOLD1	=	$0051
LMARGN	=	$0052	;LEFT MARGIN (SET TO ONE AT POWER ON)
RMARGN	=	$0053	;RIGHT MARGIN (SET TO ONE AT POWER ON)
ROWCRS	=	$0054	;CURSOR COUNTERS
COLCRS	=	$0055
DINDEX	=	$0057
SAVMSC	=	$0058
OLDROW	=	$005A
OLDCOL	=	$005B
OLDCHR	=	$005D	;DATA UNDER CURSOR
OLDADR	=	$005E
NEWROW	=	$0060	;POINT DRAW GOES TO
NEWCOL	=	$0061
LOGCOL	=	$0063	;POINTS AT COLUMN IN LOGICAL LINE
ADRESS	=	$0064
MLTTMP	=	$0066
SAVADR	=	$0068
RAMTOP	=	$006A	;RAM SIZE DEFINED BY POWER ON LOGIC
BUFCNT	=	$006B	;BUFFER COUNT
BUFSTR	=	$006C	;EDITOR GETCH POINTER
BITMSK	=	$006E	;BIT MASK
; LOTS OF RANDOM TEMPS
SWPFLG	=	$007B	;NON-0 IF TXT AND REGULAR RAM IS SWAPPED
HOLDCH	=	$007C	;CH IS MOVED HERE IN KGETCH BEfore CNTL & SHIFT PROC
;
;
;
;	80 - FF ARE FOR FP, USER, FMS AND DOS
;
;
;	PAGE 1 -- STACK
;
;
;	PAGE TWO RAM ASSIGNMENTS
;
INTABS	=	$0200	;INTERRUPT RAM
VDBLST	=	$0200	;DISPLAY LIST NMI VECTOR
VPRCED	=	$0202	;PROCEED LINE IRQ VECTOR
VINTER	=	$0204	;INTERRUPT LINE IRQ VECTOR
VBREAK	=	$0206	;SOFTWARE BREAK (00) INSTRUCTION IRQ VECTOR
VKEYBD	=	$0208	;POKEY KEYBOARD IRQ VECTOR
VSERIN	=	$020A	;POKEY SERIAL INPUT READY IRQ
VSEROR	=	$020C	;POKEY SERIAL OUTPUT READY IRQ
VSEROC	=	$020E	;POKEY SERIAL OUTPUT COMPLETE IRQ
VTIMR1	=	$0210	;POKEY TIMER 1 IRQ
VTIMR2	=	$0212	;POKEY TIMER 2 IRQ
VTIMR4	=	$0214	;POKEY TIMER 4 IRQ
VIMIRQ	=	$0216	;IMMEDIATE IRQ VECTOR
CDTMV1	=	$0218	;COUNT DOWN TIMER 1
CDTMV2	=	$021A	;COUNT DOWN TIMER 2
CDTMV3	=	$021C	;COUNT DOWN TIMER 3
CDTMV4	=	$021E	;COUNT DOWN TIMER 4
CDTMV5	=	$0220	;COUNT DOWN TIMER 5
VVBLKI	=	$0222	;IMMEDIATE VERTICAL BLANK NMI VECTOR
VVBLKD	=	$0224	;DEFERRED VERTICAL BLANK NMI VECTOR
CDTMA1	=	$0226	;COUNT DOWN TIMER 1 JSR ADDRESS
CDTMA2	=	$0228	;COUNT DOWN TIMER 2 JSR ADDRESS
CDTMF3	=	$022A	;COUNT DOWN TIMER 3 FLAG
SRTIMR	=	$022B	;SOFTWARE REPEAT TIMER
CDTMF4	=	$022C	;COUNT DOWN TIMER 4 FLAG
CDTMF5	=	$022E	;COUNT DOWN TIMER 5 FLAG
SDMCTL	=	$022F	;SAVE DMACTL REGISTER
SDLSTL	=	$0230	;SAVE DISPLAY LIST LOW BYTE
SDLSTH	=	$0231	;SAVE DISPLAY LIST HIGH BYTE
SSKCTL	=	$0232	;SKCTL REGISTER RAM
;
LPENH	=	$0234	;LIGHT PEN HORIZONTAL VALUE
LPENV	=	$0235	;LIGHT PEN VERTICAL VALUE

GPRIOR	=	$26F	;Global priority cell



;
;
;	POTENTIOMETERS
;
;
PADDL0	=	$0270
PADDL1	=	$0271
PADDL2	=	$0272
PADDL3	=	$0273
PADDL4	=	$0274
PADDL5	=	$0275
PADDL6	=	$0276
PADDL7	=	$0277
;
;
;	JOYSTICKS
;
;
STICK0	=	$0278
STICK1	=	$0279
STICK2	=	$027A
STICK3	=	$027B
;
;
;	PADDLE TRIGGER
;
;
PTRIG0	=	$027C
PTRIG1 	=	$027D
PTRIG2	=	$027E
PTRIG3	=	$027F
PTRIG4	=	$0280
PTRIG5	=	$0281
PTRIG6	=	$0282
PTRIG7	=	$0283
;
;
;	JOYSTICK TRIGGER
;
;
STRIG0	=	$0284
STRIG1	=	$0285
STRIG2	=	$0286
STRIG3	=	$0287
;
;	Many random OS variables, the following were commented
;
TXTROW	=	$0290	;Text rowcrs
TXTCOL	=	$0291	;Text colcrs
TINDEX	=	$0293	;Text index
TXTMSC	=	$0294	;fools convert into new msc
TXTOLD	=	$0296	;oldrow and oldcol for text (etc.)
ESCFLG	=	$02A2	;Escape flag
LOGMAP	=	$02B2	;Logical line start bit map
INVFLAG	=	$02B6	;Inverse video flag (toggled by Atari key)
FILFLG	=	$02B7	;Fill flag for draw
SCRFLG	=	$02BB	;Set if scroll occures
SHFLOK	=	$02BE	;Shift lock
BOTSCR	=	$02BF	;Bottom of screen: 24 Norm, 4 Split.
;
;
;	COLORS
;
;
PCOLR0	=	$02C0	;P0 COLOR
PCOLR1	=	$02C1	;P1 COLOR
PCOLR2	=	$02C2	;P2 COLOR
PCOLR3	=	$02C3	;P3 COLOR
COLOR0	=	$02C4	;COLOR 0
COLOR1	=	$02C5	;COLOR 1
COLOR2	=	$02C6	;COLOR 2
COLOR3	=	$02C7	;COLOR 3
COLOR4	=	$02C8	;COLOR 4
;
;
;	GLOBAL VARIABLES
;
;
RAMSIZ	=	$02E4	;RAM SIZE (HI BYTE ONLY)
MEMTOP	=	$02E5	;TOP OF AVAILABLE USER MEMORY
MEMLO	=	$02E7	;BOTTOM OF AVAILABLE USER MEMORY
DVSTAT	=	$02EA	;STATUS BUFFER
;
CRSINH	=	$02F0	;CURSOR INHIBIT	(00 = CURSOR ON)
KEYDEL	=	$02F1	;Key delay
CHACT	=	$02F3	;CHACTL REGISTER RAM
CHBAS	=	$02F4	;CHBAS REGISTER RAM
FILDAT	=	$02FD	;RIGHT FILL DATA (DRAW)
ATACHR	=	$02FB	;Atascii character
CH	=	$02FC	;global variable for keyboard
DSPFLA	=	$02FE	;DISPLAY FLAG: DISPLAYS CNTLS IF NON ZERO;
SSFLAG	=	$02FF	;Start/stop flag for paging (CNTL 1). Cleared by Break
;
;	Page three RAM assignments
;
;
;	Device control blocks
;	(SIO)
DCB	=	$0300	;Device control block
DDEVIC	=	$0300	;Peripheral Unit 1 bus I.D. number
DUNIT	=	$0301	;Unit number
DCOMND	=	$0302	;Bus command
DSTATS	=	$0303	;Command Type/status return
DBUFLO	=	$0304	;Data buffe pointe low
DBUFHI	=	$0305
DTIMLO	=	$0306	;Device time out in 1 second units
DBYTLO	=	$0308	;Number of bytes to be transvered low byte
DBYTHI	=	$0309
DAUX1	=	$030A	;Command Aux byte 1
DAUX2	=	$030B
;
IOCB	=	$0340
ICHID	=	$0340	;Handler index number (FF = IOCB free)
ICDNO	=	$0341	;Device number (drive number)
ICCOM	=	$0342	;Command code
ICSTA	=	$0343	;Status of last IOCB action
ICBAL	=	$0344	;Buffer address low byte
ICBAH	=	$0345
ICPTL	=	$0346	;Put byte routine address - 1
ICPTH	=	$0347
ICBLL	=	$0348	;Buffer length low byte
ICBLH	=	$0349
ICAX1	=	$034A	;Auxiliary information first byte
ICAX2	=	$034B
ICSPR	=	$034C	;four spare bytes
;
PRNBUF	=	$03C0	;Printer buffer (40 bytes)
;	(21 spare bytes)
;
;	Page Four Ram Assignments
CASBUF	=	$03FD	;Cassette Buffer (131 bytes)
;
USAREA	=	$0480	; (0480 thru 05FF for the user)
;			  (except for floating point...)
;
;	FLOATING POINT ROM ROUTINES
;
;
;	IF CARRY IS USED THEN CARRY CLEAR => NO ERROR, CARRY SET => ERROR
;
AFP	=	$D800	;ASCII -> FLOATING POINT (FP)
;			INBUFF + CIX -> FRO, CIX, CARRY
FASC	=	$D8E6	;FP -> ASCII	FR0 -> FOR,FO0+1, CARRY
IFP	=	$D9AA	;INTEGER -> FP
;			0-$FFFF (LSB, MSB) IN FR0,FR0+1->FR0
FPI	=	$D92D	;FP -> INTEGER  FR0 -> FR0,FR0+1, CARRY
FSUB	=	$DA60	;FR0 <- FR0 - FR1, CARRY
FADD	=	$DA66	;FR0 <- FR0 + FR1  ,CARRY
FMUL	=	$DADB	;FR0 <- FR0 * FR1  ,CARRY
FDIV	=	$DB28	;FR0 <- FR0 / FR1  ,CARRY
FLD0R	=	$DD89	;FLOATING LOAD REG0	FR0 <- (X,Y)
FLD0P	=	$DD8D	;			FR0 <- (FLPTR)
FLD1R	=	$DD98	;			FR1 <- (X,Y)
FLD1P	=	$DD9C	;			FR1 <- (FLPTR)
FST0R	=	$DDA7	;FLOATING STORE REG0  (X,Y) <- FR0
FST0P	=	$DDAB	;		    (FLTPTR)<- FR0
FMOVE	=	$DDB6	;FR1 <- FR0
PLYEVL	=	$DD40	;FR0 <- P(Z) = SUM(I = N TO 0) (A(I) *Z**I)	CARRY
;			INPUT:  (X,Y) = A(N), A(N-1)...A(0) -> PLYARG
;				ACC   = # OF COEFFICIENTS = DEGREE + 1
;				FR0   = Z
EXP	=	$DDC0	;FR0 <- E**FR0 = EXP10(FR0 * LOG10(E))	CARRY
EXP10	=	$DDCC	;FR0 <- 10**FR0	CARRY
LOG	=	$DECD	;FR0 <- LN(FR0) = LOG10(FR0) / LOG10(E)	CARRY
LOG10	=	$DED1	;FR0 <- LOG10(FR0)	CARRY
;
;
;	THE FOLLOWING ARE IN THE BASIC CARTRIDGE:
;
;
SIN	=	$BD81	;FR0 <- SIN(FR0) DEGFLG=0 => RADS, 6=>DEG.	CARRY
COS	=	$BD73	;FR0 <- COS(FR0)	CARRY
ATAN	=	$BD43	;FR0 <- ATN(FR0)	CARRY
SQR	=	$BEB1	;FR0 <- SQUAREROOT(FR0)	CARRY
;
;
;	FLOATING POINT ROUTINES ZERO PAGE (NEEDED ONLY IF F.P.
;		ROUTINES ARE CALLED)
FR0	=	$00D4	;FP REG0
FR1	=	$00E0	;FP REG1
CIX	=	$00F2	;CURRENT INPUT INDEX
INBUFF	=	$00F3	;POINTS TO USER'S LINE INPUT BUFFER
RADFLG	=	$00FB	;0 = RADIANS, 6 = DEGREES
FLTPTR	=	$00FC	;POINTS TO USERS FLOATING POINT NUMBER
;
;
;	FLOATING POINT ROUTINES' NON-ZP RAM
;
;	(057E to 05FF)


LBUFF	=	$0580	;LINE BUFFER
PLYARG	=	LBUFF+$60	;POLYNOMILA ARGUMENTS
;
;
;
;
;
;
;
;	COLLEEN MNEMONICS
;
;
;
POKEY	=	$D200		;VBLANK ACTION:		DESCRIPTION:
POT0	=	POKEY+0		;POT0-->PADDL0		0-227 IN RAM CELL
POT1	=	POKEY+1		;POT1-->PADDL1		0-227 IN RAM CELL
POT2	=	POKEY+2		;POT2-->PADDL2		0-227 IN RAM CELL
POT3	=	POKEY+3		;POT3-->PADDL3		0-227 IN RAM CELL
POT4	=	POKEY+4		;POT4-->PADDL4		0-227 IN RAM CELL
POT5	=	POKEY+5		;POT5-->PADDL5		0-227 IN RAM CELL
POT6	=	POKEY+6		;POT6-->PADDL6		0-227 IN RAM CELL
POT7	=	POKEY+7		;POT7-->PADDL7		0-227 IN RAM CELL
ALLPOT	=	POKEY+8		;???
KBCODE	=	POKEY+9
RANDOM	=	POKEY+10
POTGO	=	POKEY+11	;Strobed
;		n/a
SERIN	=	POKEY+13
IRQST	=	POKEY+14
SKSTAT	=	POKEY+15
;
AUDF1	=	POKEY+0
AUDC1	=	POKEY+1
AUDF2	=	POKEY+2
AUDC2	=	POKEY+3
AUDF3	=	POKEY+4
AUDC3	=	POKEY+5
AUDF4	=	POKEY+6
AUDC4	=	POKEY+7
AUDCT	=	POKEY+8		;NONE			AUDCTL<--[SIO]
STIMER	=	POKEY+9
SKRES	=	POKEY+10	;NONE			SKRES<--[SIO]
POTGO	=	POKEY+11
SEROUT	=	POKEY+13	;NONE			SEROUT<--[SIO]
IRQEN	=	POKEY+14	;POKMSK-->IRQEN	(AFFECTED BY OPEN S: OR E:)
SKCTL	=	POKEY+15	;SSKCTL-->SKCTL		SSKCTL<--[SIO]
;
CTIA	=	$D000
HPOSP0	=	CTIA+0
HPOSP1	=	CTIA+1
HPOSP2	=	CTIA+2
HPOSP3	=	CTIA+3
HPOSM0	=	CTIA+4
HPOSM1	=	CTIA+5
HPOSM2	=	CTIA+6
HPOSM3	=	CTIA+7
SIZEP0	=	CTIA+8
SIZEP1	=	CTIA+9
SIZEP2	=	CTIA+10
SIZEP3	=	CTIA+11
SIZEM	=	CTIA+12
GRAFP0	=	CTIA+13
GRAFP1	=	CTIA+14
GRAFP2	=	CTIA+15
GRAFP3	=	CTIA+16
GRAFM	=	CTIA+17
COLPM0	=	CTIA+18		;PCOLR0-->COLPM0		WITH ATTRACT MODE
COLPM1	=	CTIA+19		;ETC.N
COLPM2	=	CTIA+20
COLPM3	=	CTIA+21
COLPF0	=	CTIA+22
COLPF1	=	CTIA+23
COLPF2	=	CTIA+24
COLPF3	=	CTIA+25
COLBK	=	CTIA+26
PRIOR	=	CTIA+27
VDELAY	=	CTIA+28
GRACTL	=	CTIA+29
HITCLR	=	CTIA+30
CONSOL	=	CTIA+31		;$08-->CONSOL			TURN OFF SPEAKER
;
M0PF	=	CTIA+0
M2PF	=	CTIA+2
M3PF	=	CTIA+3
P0PF	=	CTIA+4
P1PF	=	CTIA+5
P2PF	=	CTIA+6
P3PF	=	CTIA+7
M0PL	=	CTIA+8
M1PL	=	CTIA+9
M2PL	=	CTIA+10
M3PL	=	CTIA+11
P0PL	=	CTIA+12
P1PL	=	CTIA+13
P2PL	=	CTIA+14
P3PL	=	CTIA+15
TRIG0	=	CTIA+16		;TRIG0-->STRIG1
TRIG1	=	CTIA+17		;ETC.
TRIG2	=	CTIA+18
TRIG3	=	CTIA+19
PAL	=	CTIA+20
;
ANTIC	=	$D400
DMACTL	=	ANTIC+0		;DMACTL<--SDMCTL		ON OPEN S: OR E:
CHARCTL	=	ANTIC+1		;CHACTL<--CHACT			ON OPEN S: OR E:
DLISTL	=	ANTIC+2		;DLISTL<--SDLSTL		ON OPEN S: OR E:
DLISTH	=	ANTIC+3		;DLISTH<--SDLSTH		ON OPEN S: OR E:
HSCROL	=	ANTIC+4
VSCROL	=	ANTIC+5
PMBASE	=	ANTIC+7
CHBASE	=	ANTIC+9		;CHBASE<--CHBAS			ON OPEN S: OR E:
WSYNC	=	ANTIC+10
VCOUNT	=	ANTIC+11
PENH	=	ANTIC+12
PENV	=	ANTIC+13
NMIEN	=	ANTIC+14	;NMIEN<--40			POWER ON AND [SETVBV]
NMIRES	=	ANTIC+15	;STROBED
NMIST	=	ANTIC+15
;
;	Lots and lots of unofficial
;	Mnemonics for display list instructions,
;	as well as other bit patterns.
;
;	DL prefix implies display list
;	instruction, naturally
;
DLBL1	=	0	; One blank line
DLBL2	=	$10	; Two blank lines
DLBL3	=	$20	; Three
DLBL4	=	$30	; Four
DLBL5	=	$40	; Five
DLBL6	=	$50	; Six
DLBL7	=	$60	; Seven
DLBL8	=	$70	; Eight blank lines

DLINT	=	$80	; Generate Display List Interrupt when this
			; instruction is interpreted.
DLJMP	=	$1	; Tells Antic Chip to jump to contents of next two bytes
DLJVB	=	$41	; Same as DLJMP but also halts ANTIC 'till next verticle blank

DLLDM	=	$40	; Tells Antic chip to start retrieving data from memory referenced by the next two bytes
DLVSCR	=	$20	; (sort of) enables vertical scroll
DLHSCR	=	$10	; enable horizontal scroll
;
;	Playfield Instructions
;
DLPF15	=	15	; 320 dots	2 colors	1 scan line
DLPF14	=	14	; 160		4		1
DLPF13	=	13	; 160		4		2
DLPF12	=	12	; 160		2		1
DLPF11	=	11	; 160		2		2
DLPF10	=	10	; 80		4		4
DLPF9	=	9	; 80		2		4
DLPF8	=	8	; 40		4		8

; Character PF types

DLPF7	=	7	; 20 chars	5 colors	16 scan lines
DLPF6	=	6	; 20		5		8
DLPF5	=	5	; 40		5		16 (hairy 4 color characters)
DLPF4	=	4	; 40		5		8
DLPF3	=	3	; 40		2		10 (Text processing)
DLPF2	=	2	; 40		2		8  (Normal text mode)

; PF1 & PF0 are special. . . .

;
;	Player & Missile Offsets
;	Denoted by PM prefix
;
PMLF	=	$24	;Left side of screen
PMRT	=	$DD	;Right side of screen
PMDM	=	$180	;Missile offset for double line resolution
PMDP0	=	$200	;Player 0
PMDP1	=	$280	;Player 1
PMDP2	=	$300	;Player 2
PMDP3	=	$380	;Player 3
PMSM	=	2*PMDM	;Missile offset for single line resolution
PMSP0	=	2*PMDP0	;Player 0
PMSP1	=	2*PMDP1	;	1
PMSP2	=	2*PMDP2	;	2
PMSP3	=	2*PMDP3	;	3

;
;	Colors, denoted by CL
;
CLGREY	=	0	;grey
CLGOLD	=	$10	;gold
CLORNG	=	$20	;orange
CLRED	=	$30	;red-orange
CLPINK	=	$40	;pink
CLPURP	=	$50	;purple
CLPURB	=	$60	;purple blue
CLPBLU	=	$70	;blue 1
CLBLUE	=	$80	;blue 2
CLLBLU	=	$90	;light blue
CLTURQ	=	$A0	;turquoise
CLGBLU	=	$B0	;green blue
CLGREN	=	$C0	;green
CLYGRN	=	$D0	;yellow green
CLOGRN	=	$E0	;orange green
CLLTOR	=	$F0	;light orange

;
;	Bit Masks for console switches
;
SWSTRT	=	$1	;Start
SWSEL	=	$2	;Select
SWOPT	=	$4	;Option

;	Joystick bit masks

JYR	=	8	;Right
JYL	=	4	;Left
JYB	=	2	;Back
JYF	=	1	;Forward

;	IOCB offsets

IOCB0	=	0
IOCB1	=	$10
IOCB2	=	$20
IOCB3	=	$30
IOCB4	=	$40
IOCB5	=	$50
IOCB6	=	$60
IOCB7	=	$70




PIA	=	$D300
PORTA	=	PIA+0		;PORTA-->STICK0,1		X-Y CONTROLLERS
PORTB	=	PIA+1		;PORTB-->STICK2,3
PACTL	=	PIA+2		;NONE				PACTL<--3C [INIT]
PBCTL	=	PIA+3		;NONE				PBCTL<--3C [INIT]
ASCZER	=	'0	;Ascii zero
COLON	=	$3A	;Ascii Colon
EOL	=	$9B	;End of Record

;	The following are subroutines

PUTLIN	=	$F385	;X -- Lo byte
			;Y -- Hi byte
			;of line

XVB	=	$E7D1	;System VBLANK exit routine


;
;
;
;		End of Atari Equates.
.LIST
;
;
;	The rest of this source code is (C) 1980 MIT Logo Lab
;
;
;
;       L      OOO   GGG   OOO        L       A   BBBB
;       L     O   O G   G O   O       L      A A  B   B 
;       L     O   O G     O   O       L     A   A B   B
;       L     O   O G GGG O   O       L     AAAAA BBBB
;       L     O   O G   G O   O       L     A   A B   B
;       L     O   O G   G O   O       L     A   A B   B
;       LLLLL  OOO   GGG   OOO        LLLLL A   A BBBB
;
;
;

ORG	=	$6000

.NLIST


;BOOTAP	=	0	;Uncomment for Boot tape mode
DISKFI	=	0	;Uncomment for Disk file mode
;BINARY	=	0	;Uncomment for Binary mode

;
;	Boot tape writer.  Writes out a Boot tape and returns.
;

.IFDF	BOOTAP	;If we are making a Boot Cassette Tape
.IFT
.SBTTL	Boot tape

.=$600

	LDX	#ICTWO
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOV

	LDA	#CAS/256
	STA	ICBAH,X
	LDA	#CAS&$FF
	STA	ICBAL,X
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#OPNOT
	STA	ICAX1,X
	LDA	#$80	;short IRQ
	STA	ICAX2,X
	JSR	CIOV
	LDA	#PST-<PST/256*256>
	STA	ICBAL,X
	LDA	#PST/256
	STA	ICBAH,X
	LDA	#PND-PST-<PND-PST/256*256>
	STA	ICBLL,X
	LDA	#PND-PST/256
	STA	ICBLH,X
	LDA	#PUTCHR
	STA	ICCOM,X
	JSR	CIOV
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOV
	RTS
CAS:	.ASCII	'C:'
	.BYTE	EOL

.=ORG
PST=.


	.BYTE	0
	.BYTE	PND-PST+127/128
	.ADDR	PST
	.ADDR	PINIT
; ENTRY POINT FOR MULTI-STAGE BOOT PROCESS.

	CLC
	RTS


; ENTRY POINT FOR FIRST TIME INITIALIZATION
PINIT:	LDA 	#$3C
	STA	PACTL	;turn off cassete motor

	LDA	#RESTRT-<RESTRT/256*256>
	STA	DOSVEC
	LDA	#RESTRT/256
	STA	DOSVEC+1
	LDA	#$30
	STA	RAMTOP
	RTS


;	WARMSTART ENTRY POINT
;
RESTRT: JMP BEGIN

.ENDC

;
;	Write a disk Binary load file & return.
; note that Auto Start ISN'T performed, since
; I can't figure out how the heck it works.
;
;

.IFDF	DISKFI
.IFT

.=$600


	LDX	#ICTWO
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOV

	LDA	#DIS^
	STA	ICBAH,X
	LDA	#DIS&$FF
	STA	ICBAL,X
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#OPNOT
	STA	ICAX1,X
	JSR	CIOV

;
;	First, write disk header
;

	LDA	#DISKST&$FF
	STA	ICBAL,X
	LDA	#DISKSTST^
	STA	ICBAH,X
	LDA	#<DISKND-DISKST>&$FF
	STA	ICBLL,X
	LDA	#<DISKND-DISKST>^
	STA	ICBLH,X
	LDA	#PUTCHR
	STA	ICCOM,X
	JSR	CIOV

;
;	Then write the actual program
;

	LDA	#PST&$FF
	STA	ICBAL,X
	LDA	#PST^
	STA	ICBAH,X
	LDA	#<PND-PST>&$FF
	STA	ICBLL,X
	LDA	#<PND-PST>^
	STA	ICBLH,X
	LDA	#PUTCHR
	STA	ICCOM,X
	JSR	CIOV

;
;	Then close the file
;

	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOV
	RTS

DIS:	.ASCII	'D:RUN'
	.BYTE	EOL


DISKST:	.BYTE	$FF,$FF
	.ADDR	PST
	.ADDR	PND-1	;Dos software loads up to & including second address.
DISKND=.

.=ORG
PST:	JMP	BEGIN

.ENDC

;
;	Binary i.e. Testing phase where no copy is kept of the
; code, we just jump right to it.
;

.IFDF	BINARY
.IFT
.=$600
	JMP	BEGIN	;Just start execution
.=ORG
.ENDC

.LIST

;	SUPDUP equates

ONE	=	$50	;IOCB one (keyboard)
TWO	=	$60	;IOCB two (rs-232c port)
VIDEOL	=	$CC	;low byte of video routine address
VIDEOH	=	$CD	;high byte of video routine address
AL	=	$D6	;
AH	=	$D7	;
BL	=	$D8	;
BH	=	$D9	;
DL	=	$DA	;
DH	=	$DB	;
VADL	=	$CE	;low byte of memory location of video character addressed by
			;CX and CY.
VADH	=	$CF	;hi byte of VADL
JPL	=	$DF	;low byte of address to jump to for table gotos
JPH	=	$E0	;high byte of JPL
MDMA	=	$5C20	;Address of my display list
MDMAL	=	$E1	;low byte of pointer to my display list
MDMAH	=	$E2	;high byte of pointer to my display list
MSCR	=	$5000	;Address of my screen buffer (3K long)
MSLN	=	24*128
MEOS	=	MSCR+MSLN
MCHR	=	ORG+$C00 ; Character set
MPLR	=	MEOS	;Player base
MP0	=	MPLR+$200	;begining of player 0 (used as the cursor)
LINE25	=	MPLR+1	;Twenty fifth 'mode' line (20 Characters)
CX	=	$E4	;cursor's X position
CY	=	$E5	;cursor's Y position
TEMP	=	$E6
EL	=	$E7
EH	=	$E8
BLANK	=	32
DCAL	=	$E9	;TEMP FOR DCA



; KEYBOARD NAME
KEY:	.ASCII	'K:'
	.BYTE	EOL
RS:	.ASCII	'R1:'
	.BYTE	EOL
;
;	the code
;
BEGIN:	LDX	#ONE
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOV
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#KEY-<256*<KEY/256>>
	STA	ICBAL,X
	LDA	#KEY/256
	STA	ICBAH,X
	LDA	#OPNIN
	STA	ICAX1,X
	JSR	CIOV
; Open RS-232C port
	LDX	#TWO
	LDA	#CLOSE
	STA	ICCOM,X
	JSR	CIOV
	LDA	#OPEN
	STA	ICCOM,X
	LDA	#RS&$FF
	STA	ICBAL,X
	LDA	#RS/256
	STA	ICBAH,X
	LDA	#13	;concurrent
	STA	ICAX1,X
	LDA	#$34
	STA	COLOR2
	JSR	CIOV
	TYA
	STA	$9F00
	LDA	#38
	STA	ICCOM,X
	LDA	#32	;No trans.
	STA	ICAX1,X
	LDA	#64
	STA	ICAX2,X
	JSR	CIOV
	LDA	#40	;Start conc.
	STA	ICCOM,X
	LDA	#0
	STA	ICAX1,X
	STA	ICAX2,X	;Internal buffer

	JSR	CIOV
	TYA
	BPL	BEG1
	LDA	#14
	STA	COLOR2

	JMP	ERROR

BEG1:	LDA	#MDMA&$FF
	STA	SDLSTL
	STA	MDMAL
	LDA	#MDMA/256
	STA	SDLSTH
	STA	MDMAH
;	LDA	#MCHR/256
;	STA	CHBAS
	LDA	#$70	;8 blank lines
	LDY	#0
	JSR	BUILD
	JSR	BUILD
	JSR	BUILD
	LDA	#MSCR/256
	STA	TEMP
	LDX	#12	; 12*2 LINES
LOOP:	LDA	#$42
	JSR	BUILD
	LDA	#0
	JSR	BUILD
	LDA	TEMP
	JSR	BUILD
	LDA	#$42
	JSR	BUILD
	LDA	#128
	JSR	BUILD
	LDA	TEMP
	JSR	BUILD
	CLC
	ADC	#1
	STA	TEMP
	DEX
	BNE	LOOP

	LDA	#$46	;Double wide single height characters
	JSR	BUILD
	LDA	#LINE25&$FF
	JSR	BUILD
	LDA	#LINE25^
	JSR	BUILD

	LDA	#$41	; Jmp & wait
	JSR	BUILD
	LDA	#MDMA&$FF
	JSR	BUILD
	LDA	#MDMA^
	JSR	BUILD
	JMP	BEG2

BUILD:	STA	(MDMAL),Y
	INY
	RTS

BEG2:	LDA	#2	;DRK grey
	STA	COLOR2
	LDA	#0	;Zero old cursor position & horizontal ofset
	STA	OLDCR
	STA	HOFSET
	LDX	#VBLANK^
	LDY	#VBLANK&$FF
	LDA	#6	;vblank imm
	JSR	SETVBV

;
; Set up the cursor right
;

	LDA	#$92	;blue
	STA	PCOLR0

	LDA	#2
	STA	GRACTL	;Enable player graphics

	LDA	#$2A
	STA	SDMCTL

	LDY	#128	;Erase player 0's definition
	LDA	#0
INIT1:	STA	MP0-1,Y
	DEY
	BNE	INIT1

	LDA	#MPLR^	;Set player missile base
	STA	PMBASE

	LDA	#1
	STA	$26F

	JMP	BEG3

;
; definition of the cursor
;

PTABLE:	.BYTE	$FC	;******
	.BYTE	$84	;*    *
	.BYTE	$84	;*    *
	.BYTE	$84	;*    *
	.BYTE	$84	;*    *
	.BYTE	$FC	;******






;
;
;	VBlank Interrupt service routine
;
;	1)  Use paddle 0's position to update the display
; list pointers. (or, if the paddle isn't in, and the start key is pressed,
; use the state of the shift key
; to move right (no shift) or left (shift) one character position.
;
;	2) Update the magic player-0 cursor.
;
;
;
;
;

OLDCR:	.BYTE	0	;Old cursor vertical position
HOFSET:	.BYTE	0	;Horizontal offset
SOUFLG:	.BYTE	0	;Set to non zero if the Atari is making
			;a sound with its speaker.

VBLANK:	LDA	#$E6
	STA	PCOLR0	;Set the color of the cursor

	LDA	PADDL0
	AND	#$FC	;Chop bottom two bits off of paddle to get rid of jitters.
	CMP	#200	;Paddle not pluged in?
	BCS	VBL4
	CMP	#88	;Paddle in range?
	BCC	VBL1
	LDA	#88	;Pin paddle so we never scroll off the end of the line.
	JMP	VBL1
;
;	Out of compasion to those poor unfortunates without a set of paddles, if the Paddle 0 is
; not plugged in, check if start key is depressed.  If it is (bit 0 of consol = 0)
; then check if the shift key is depressed (bit 3 of SKSTAT is 0) and scroll
; left (shifted) or right (unshifted) one character position.  Note that this gives a
; maximum scrolling speed of 60cps.
;

VBL4:	LDA	SOUFLG	;Don't scroll while key clicking or bell beeping.
	BNE	CURS

	LDA	#08
	STA	CONSOL
	LDA	CONSOL	;Start key not depressed
	CMP	#06
	BNE	CURS

	LDA	SKSTAT	;Shift key not depressed?
	AND	#8
	BNE	VBL41

	LDA	HOFSET	;Scroll left one character position
	BEQ	VBL1	;Pin at zero
	SEC
	SBC	#1
	JMP	VBL1

VBL41:	LDA	HOFSET	;Scroll right one character position
	CMP	#88	;Pin at 88
	BEQ	VBL1
	CLC
	ADC	#1	;Add one and fall through to VBL1

;
;	Modify the twenty four addresses in the display list so that a particular
; 40 character band of the 128 character wide screen buffer is shown.
;

VBL1:	STA	HOFSET
	LDY	#4	;Initial index into display list.  Points to LSB of address of top line of screen
	LDX	#24

VBL2:	LDA	(MDMAL),Y
	AND	#$80
	CLC
	ADC	HOFSET
	STA	(MDMAL),Y
	INY
	INY
	INY
	DEX
	BNE	VBL2
	
;
;	Erase old box cursor and add new box cursor if
; it should be visible on the screen
;

CURS:	LDA	#0
	LDY	OLDCR
	LDX	#6
CURS1:	STA	MP0,Y
	INY
	DEX
	BNE	CURS1


	LDA	CX
	AND	#$7F	;Cursor wraps after 127 th character
	SEC
	SBC	HOFSET
	BCC	VBL3
	CMP	#40
	BCS	VBL3

	ASL	A
	ASL	A
	CLC
	ADC	#$2F
	STA	HPOSP0

	LDA	CY
	ASL	A
	ASL	A
	CLC
	ADC	#15
	TAY

	STA	OLDCR

	LDX	#6
CURS3:	LDA	PTABLE-1,X
	STA	MP0,Y
	INY
	DEX
	BNE	CURS3

VBL3:	JMP	XVB	;exit vblank

;
;	Terminal type variable
;
;

TTYPE:	.BYTE	0
CHMASK:	.BYTE	0

TTABLE:	.ADDR	GLASS	;Glass tty (vanilla CRT)
	.ADDR	SUPAI	;AI Dial Up
	.ADDR	IMLAC	;Imlac
	.ADDR	SUPAR	;Arpa Net Dial up
	.ADDR	VT52	;VT-52

MAXTTY	=	<.-TTABLE>/2	;One more than maximum number of terminals defined in TTABLE

PARTAB:	.BYTE	$7F	;Glass takes 7 bits
	.BYTE	$7F	;SUPAI takes 7
	.BYTE	$7F	;IMLAC takes 7
	.BYTE	$FF	;ARPA net supdup takes 8 bits
	.BYTE	$7F	;VT-52 takes 7 bits


TNAME:	.ASCIZ	"GLASS"
	.ASCIZ	"AI-SUPDUP"
	.ASCIZ	"IMLAC"
	.ASCIZ	"ARPA-SUPDUP"
	.ASCIZ	"VT-52"

CPMSG:	.ASCII	"(C)1981 MIT LOGO LAB"	;Due to 'cute' kludge, the messages
	.ASCII  "CHAMELEON TTY BY JHP"	;in this list are flashed on the
					;screen in reverse order.

;
;	Put copyright message on screen
; (making sure it stays there for about 8 seconds)
;

COPYRT:	LDY	#40

COPYL:	LDX	#20

COPYR1:	LDA	CPMSG-1,Y	;Put message on screen
	JSR	ASTOINT
	ORA	#$40		;Make it another color
	STA	LINE25-1,X
	DEY
	DEX
	BNE	COPYR1

	LDA	RTCLOC+1	;Time in 4 second slices
	CLC
	ADC	#1

COPYW:	CMP	RTCLOC+1
	BNE	COPYW

	CPY	#0		;Have we shown all messages?
	BNE	COPYL

	RTS

;
;	Set the 25th line and the output routines
; for the selected tty type.
;

STMODE:	LDA	TTYPE
	CMP	#MAXTTY
	BCC	STMOD1	;Good ttype
	LDA	#0
	STA	TTYPE

STMOD1: TAY		;Set up right number of bits
	LDA	PARTAB,Y
	STA	CHMASK
	TYA
	ASL	A	;Set video output vector
	TAY
	LDA	TTABLE,Y
	STA	VIDEOL
	STA	NORMLL
	LDA	TTABLE+1,Y
	STA	NORMLH
	STA	VIDEOH

	LDX	TTYPE	;Write name on screen on 25th line
	LDY	#$FF
	INX
STMOD2:	DEX
	BEQ	STMOD4	;We've indexed to the 'right' name
STMOD3:	INY
	LDA	TNAME,Y
	BNE	STMOD3
	BEQ	STMOD2

;
;	Print the who line
; X=0, Y points to name of tty string - 1

STMOD4:	INY
	LDA	TNAME,Y
	BEQ	STMOD5	;That's all, folks
	JSR	ASTOIN
	STA	LINE25,X
	INX
	BNE	STMOD4	;If X wraps, punt because the name table certainly can't wrap

; Now we clear out the rest of the who line

STMOD5:	DEX

STMOD6:	INX
	STA	LINE25,X	;By an amazing coincidence A contains Zero
	CPX	#20
	BCC	STMOD6	;Clear out rest of line

	RTS



;
;	Finish setup and go into main loop
; of program.
;

BEG3:	LDA	POKMSK	;Disable break key
	AND	#$7F	;so we don't accidentally
	STA	POKMSK	;hit it and cause the RS
	STA	IRQEN	;device to stop I/O

	JSR	COPYRT	;Display copyright
	LDA	#0
	STA	TTYPE
	JSR	STMODE	; Set Mode Line & video jump address for tty type
	LDA	#0
	STA	CX
	STA	CY
	JSR	DROPCR
	LDA	#0
	STA	SOUFLG

BEG5:	LDA	CH
	CMP	#255
	BEQ	BEG6
	LDA	#1
	STA	SOUFLG
	JSR	GETK
	JSR	PUTR
	LDA	#0
	STA	SOUFLG

BEG6:	JSR	STATR
	LDA	747	;Number of characters in RS-232C inchar buffer
	ORA	748
	BEQ	BEG7
	JSR	GETR
	JSR	PUTV
BEG7:	LDA	CONSOL
	CMP	#3	;Option key
	BEQ	DOWNL
	AND	#$02	;Select key
	BNE	BEG5
BEG8:	LDA	CONSOL
	AND	#$02
	BEQ	BEG8
	INC	TTYPE
	JSR	STMODE
	JMP	BEG5

;
;	Downloading portion.  When the unsuspecting luser
; hits the option key, we start downloading.  This is the
; T<cross line>K<ascii checksum of cross line>
; format, which is not very fast, but it gets the job
; done.  After a Q<cr> is recieved we JSR to $600, which
; normally has a $60 (RTS).  The clever programmer has,
; however, aranged it so that CROSS puts a jump to the
; start of his program in this spot, and voila, it starts
; execution.  A RTS will give control back to the chamelion
; software.
;
;	When things go wrong, the user can abort the download
; by pressing all three buttons at once.
;

VECTOR	=	$600	;256 bytes of guaranteed free space.

DOWNL:	LDA	#$60	;RTS
	STA	VECTOR

	LDA	#$12	;Change screen color
	STA	COLOR2

BADLN:	LDA	#'N
OUTREP:	JSR	PUTR
	LDA	#13
	JSR	PUTR
	LDA	#0
	STA	CX
	STA	CY

DOWNL1:	LDA	CONSOL
	CMP	#0	;All three down. Quit
	BNE	DOWNL2

;
;	Punt just restarts the main body after restoring screen color
;

PUNT:	JMP	BEGIN

;
;	Part of the downloading stuff, grab a line
;

DOWNL2:	JSR	STATR	;A character waiting?
	LDA	747
	ORA	748
	BEQ	DOWNL1

	JSR	GETR
	AND	#$7F

	CMP	#13
	BEQ	DOWNL3
	JSR	CHARP
	JMP	DOWNL1

DOWNL3:	JSR	CHARP
	LDA	#0
	STA	CX

DOWNL4:	JSR	GETV
	CMP	#13
	BNE	DOWN41
	LDA	#'c+128
	JSR	BADLN

DOWN41:	CMP	#'Q
	BNE	DOWNL5
	JSR	DOWNLJ	;Call downloaded code.
	JMP	PUNT

;
;	Before jumping to user's code,
; close RS-232C device, reset vblank interrupts.
; and restore standard character set
;

DOWNLJ:	LDA	#CLOSE
	LDX	#TWO
	STA	ICCOM,X
	JSR	CIOV

	LDX	#XVB^
	LDY	#XVB&$FF
	LDA	#6
	JSR	SETVBV

	LDA	#$E0
	STA	CHBAS

	JMP	VECTOR

DOWNL5:	CMP	#'T
	BNE	DOWNL4

	LDY	CX	;Note cursor position of the 'T' character.

	LDX	#0	;Clear checksum

DOWNL6:	JSR	GETV
	CMP	#'K
	BEQ	DOWNL7
	CMP	#13
	BNE	DOWN61
	LDA	#'2+128
	JSR	CHAR

DOWN61:	STX	AL	;Temp
	CLC
	ADC	AL	;End of use of temp.
	TAX
	JMP	DOWNL6

DOWNL7:	JSR	GBYTE	;Get checksum in data
	STX	AL	;Temp
	CMP	AL	;End of use of temp
	BEQ	DOWNL8	;Checksums match

	LDA	#'X+128
	JSR	CHAR
	JMP	BADLN

;
; Well, load the data into memory & loop.
;

DOWNL8:	STY	CX	;Point to after 'T'.
	JSR	GETV	;Get ';'
	CMP	#';
	BEQ	DOWNL9

	LDA	#';+128
	JSR	CHAR
	JMP	BADLN

DOWNL9:	JSR	GBYTE	;Get Number of bytes.
	CMP	#0
	BEQ	GOODLN

	TAY
	JSR	GBYTE	;Get msb address.
	STA	AH
	JSR	GBYTE	;Get lsb address.
	STA	AL

	LDX	#0	;Zero X for indexing.

DLOOP:	JSR	GBYTE
	STA	(AL,X)

	CLC		;Inc pointer.
	LDA	AL
	ADC	#1
	STA	AL
	LDA	AH
	ADC	#0
	STA	AH

	DEY		;Decrement # of bytes.
	BNE	DLOOP

GOODLN:	LDA	#'Y
	JMP	OUTREP

;
; GETV gets the character under the cursor to
; to the A register, increments CX, and doesn't
; mess up X or Y.
;

GETV:	TXA
	PHA
	TYA
	PHA
	LDX	CX
	LDY	CY
	JSR	SETAD
	LDY	#0
	LDA	(VADL),Y
	STA	VADL	;Use as a temp
	INC	CX	;Advance cursor
	PLA
	TAY
	PLA
	TAX
	LDA	VADL	;Stop using as a temp
	RTS

;
;	GETH Get a hex byte from the screen, smashes stack
;

GETH:	JSR	GETV
	CMP	#'0
	BCC	GETHQ
	CMP	#'A
	BCS	GETHA
	SEC
	SBC	#'0
	RTS
GETHA:	SEC
	SBC	#'A-10
	RTS
GETHQ:	LDA	#0
	RTS

;
;	GBYTE gets a byte from the screen
; to A while preserving X & Y
;

GBYTE:	TYA
	PHA
	TXA
	PHA
	JSR	GETH
	AND	#$0F
	CLC
	ASL	A
	ASL	A
	ASL	A
	ASL	A
	STA	BL	;Temp
	JSR	GETH
	AND	#$0F
	CLC
	ADC	BL
	STA	BL
	PLA
	TAX
	PLA
	TAY
	LDA	BL
	RTS

;
;	Get status of RS-232C device
;

STATR:	LDX	#TWO
	LDA	#STATIS
	STA	ICCOM,X
	JMP	CIOV

DROPCR:	RTS	; The cursor is now a Player, so it doesn't need to be dropped
;	LDX	CX
;	LDY	CY
;	JSR	SETAD
;	LDY	#0
;	LDA	(VADL),Y
;	ORA	#$80
;	STA	(VADL),Y
;	RTS

LIFTCR:	RTS	;The cursor is now a player, so we needn't lift it
;	LDX	CX
;	LDY	CY
;	JSR	SETAD
;	LDY	#0
;	LDA	(VADL),Y
;	AND	#$7F
;	STA	(VADL),Y
;	RTS

;
;	Given an x in X, a Y in Y this routine computes the memory
;	address for that character and stores it in VADL & VADH
;

SETAD:	TXA
	ASL	A
	TAX
	TYA
	LSR	A
	TAY
	TXA
	ROR	A
	STA	VADL
	TYA
	CLC
	ADC	#MSCR/256
	STA	VADH
	RTS

;
;	GETK gets a character from the keyboard, hanging untill
;	such a character is typed
;
;	ASCII code	Atari Keyboard
;
;	Carriage-Return	RETURN
;	Tab		TAB
;	Rub-out/Delete	BACK S
;	Left-Brace	CONTROL-;
;	Right-Brace	CLEAR
;	Tilde		CONTROL-DELETE
;	Grave-Accent	CONTROL-.
;	NUL		CONTROL-,
;	^\		CONTROL-UPARROW
;	^]		CONTROL-DOWNARROW
;	^^		CONTROL-LEFTARROW
;	^_		CONTROL-RIGHTARROW
;

GETK:	LDX	#ONE
	LDA	#GETCHR
	STA	ICCOM,X
	LDA	#0
	STA	ICBLL,X
	STA	ICBLH,X
	JSR	CIOV
	CMP	#155	;EOL
	BNE	GETK2
	LDA	#13	;CR
	JMP	GETK1
GETK2:	CMP	#127	;tab
	BNE	GETK3
	LDA	#9	;TAB
	JMP	GETK1
GETK3:	CMP	#126	;BACK S
	BNE	GETK1
	LDA	#127	;DEL
GETK1:	AND	#$7F
	RTS

;
;	PUTR puts a character in the A register to the RS-232C port
;

PUTR:	PHA
	LDX	#TWO
	LDA	#PUTCHR
	STA	ICCOM,X
	LDA	#0
	STA	ICBLL,X
	STA	ICBLH,X
	PLA
	JSR	CIOV
	RTS

;
;	GETR gets a character from the RS-"#"C 
GETR:	LDX	#TWO
	LDA	#GETCHR
	STA	ICCOM,X
	LDA	#0
	STA	ICBLL,X
	STA	ICBLH,X
	JMP	CIOV


PUTV:	AND	CHMASK
	PHA
	JSR	LIFTCR
	PLA
	JSR	PUTV1
	JMP	DROPCR


PUTV1:	JMP	(VIDEOL)



;
;	block move routine
;	while (D != 0) do
;		(a) --> (b)
;		c+a -->  a
;		c+b -->  b
;		d-1 -->  d
;

BMOVE:	LDA	DL
	BNE	BMOVE1
	LDA	DH
	BNE	BMOVE1
	RTS
BMOVE1:	LDY	#0
	LDA	(AL),Y
	STA	(BL),Y
	LDA	AL
	CLC
	ADC	EL
	STA	AL
	LDA	AH
	ADC	EH
	STA	AH

	CLC
	LDA	BL
	ADC	EL
	STA	BL
	LDA	BH
	ADC	EH
	STA	BH

	CLC
	LDA	DL
	ADC	#$FF
	STA	DL
	LDA	DH
	ADC	#$FF
	STA	DH
	JMP	BMOVE

;
;	BCLEAR
;	while a != b do
;		0 -> (a)
;		a+1 -> a
;
BCLR:	LDA	#0
	LDY	#0
	STA	(AL),Y
	LDA	AL
	CMP	BL
	BCC	BCLR1
	LDA	AH
	CMP	BH
	BCC	BCLR1
	RTS

BCLR1:	CLC
	LDA	AL
	ADC	#1
	STA	AL
	LDA	AH
	ADC	#0
	STA	AH
	JMP	BCLR

;
; Ascii character in A --> Screen internal character in A
; state saved and restored.
;

ASTEMP:	.BYTE	0

ASTOIN:	STY	ASTEMP
	TAY
	TXA
	PHA
	TYA

	ROL	A
	ROL	A
	ROL	A
	ROL	A
	AND	#3	;-> internal
	TAX
	TYA
	AND	#$9F
	ORA	$FEF6,X

	TAY
	PLA
	TAX
	TYA
	LDY	ASTEMP

	RTS

;
;	Video Driver Routines
;
;
;
;


NORMLL:	.BYTE	0
NORMLH:	.BYTE	0

;
; Supdup -- AI version for use over MIT-AI dial up lines
; where the X and Y coordinates have one added to them in cursor addressing modes
; and the controlling codes are escaped by rub outs
;



SUPAI:	CMP	#127
	BEQ	CTRL

CHAR:	JSR	ASTOIN

;
;	CHARP is a hack entry point for downloading
;

CHARP:	PHA

	LDX	CX
	LDY	CY
	JSR	SETAD
	PLA
	LDY	#0
	STA	(VADL),Y
	LDX	CX
	INX
	STX	CX

	RTS

CTRL:	LDY	#CTRL1^
	LDX	#CTRL1&$FF
	JMP	SETVID

CTRL1:	CMP	#30	; Just make sure that we don't jump ramdomly
	BCC	CTRL2	; Code less than 30, so it is Legal
	JMP	ENDIT


CTRL2:	ASL	A
	AND	#$FE
	TAY
	LDA	CTAB,Y
	STA	JPL
	INY
	LDA	CTAB,Y
	STA	JPH

	LDY	NORMLH
	LDX	NORMLL
	JSR	SETVID

	JMP	(JPL)


CTAB:	.ADDR	NOP	;^@
	.ADDR	DEL	;^A -- Delete Character --
	.ADDR	MOV	;^B
	.ADDR	MV1	;^C
	.ADDR	CEOS	;^D
	.ADDR	CEOL	;^E
	.ADDR	DLF	;^F
	.ADDR	NOP	;^G
	.ADDR	NOP	;^H
	.ADDR	CRL	;^I
	.ADDR	NOP	;^J
	.ADDR	BS	;^K
	.ADDR	LF	;^L
	.ADDR	CR	;^M
	.ADDR	NOP	;^N
	.ADDR	NOP	;^O
	.ADDR	FS	;^P
	.ADDR	MV0	;^Q
	.ADDR	CLR	;^R
	.ADDR	BEL	;^S
	.ADDR	NOP	;^T
	.ADDR	ILP	;^U
	.ADDR	DLP	;^V
	.ADDR	ICP	;^W
	.ADDR	DCP	;^X
	.ADDR	NOP	;^Y
	.ADDR	NOP	;^Z
	.ADDR	NOP	;^[
	.ADDR	RSU	;^\
	.ADDR	RSD	;^]
	.ADDR	NOP	;^^
	.ADDR	NOP	;^_
;
; Supdup -- EECS Imlac version -- for use with EECS as an Imlac Simulator
; where the controlling codes are escaped by rub outs
;



IMLAC:	CMP	#127
	BEQ	ECTRL
	CMP	#11	;SAIL UP ARROW
	BEQ	IMLACC
	CMP	#27	;SAIL DIAMOND
	BEQ	IMLACC

	JMP	GLASS	;If ordinary character, treat it as such

IMLACC:	JMP	CHAR


ECTRL:	LDY	#ECTRL1^
	LDX	#ECTRL1&$FF
	JMP	SETVID		;

ECTRL1:	CMP	#30	; Just make sure that we don't jump ramdomly
	BCC	ECTRL2	; Code less than 30, so it is Legal
	JMP	ENDIT


ECTRL2:	ASL	A
	AND	#$FE
	TAY
	LDA	ECTAB,Y
	STA	JPL
	INY
	LDA	ECTAB,Y
	STA	JPH

	LDY	NORMLH
	LDX	NORMLL
	JSR	SETVID

	JMP	(JPL)


;
; TDMOV = $80  Move cursor. followed by four bytes of args:
; OLDY (ignore) OLDX (ignore) CY and CX.
; remember that upon EECS lines CX & CY are not incremented
;

EMOV:	LDX	#EMOV1&$FF
	LDY	#EMOV1^
	JMP	SETVID

EMOV1:	LDX	#EMOV2&$FF	;Ignore Old Y
	LDY	#EMOV2^
	JMP	SETVID

EMOV2:	;Ignore Old X
EMV1:
EMV0:	LDX	#EMOV3&$FF
	LDY	#EMOV3^
	JMP	SETVID

EMOV3:	CMP	#23
	BCC	EMOV31	;If less than 23, goo
	LDA	#23

EMOV31:	STA	CY

	LDX	#EMOV4&$FF	;Store CY
	LDY	#EMOV4^
	JMP	SETVID

EMOV4:	CMP	#127
	BCC	EMOV41
	LDA	#127

EMOV41:	STA	CX
	JMP	ENDIT



ECTAB:	.ADDR	NOP	;^@
	.ADDR	DEL	;^A -- Delete Character --
	.ADDR	EMOV	;^B
	.ADDR	EMV1	;^C
	.ADDR	CEOS	;^D
	.ADDR	CEOL	;^E
	.ADDR	DLF	;^F
	.ADDR	NOP	;^G
	.ADDR	NOP	;^H
	.ADDR	CRL	;^I
	.ADDR	NOP	;^J
	.ADDR	BS	;^K
	.ADDR	LF	;^L
	.ADDR	CR	;^M
	.ADDR	NOP	;^N
	.ADDR	NOP	;^O
	.ADDR	FS	;^P
	.ADDR	EMV0	;^Q
	.ADDR	CLR	;^R
	.ADDR	BEL	;^S
	.ADDR	NOP	;^T
	.ADDR	ILP	;^U
	.ADDR	DLP	;^V
	.ADDR	ICP	;^W
	.ADDR	DCP	;^X
	.ADDR	NOP	;^Y
	.ADDR	NOP	;^Z
	.ADDR	NOP	;^[
	.ADDR	RSU	;^\
	.ADDR	RSD	;^]
	.ADDR	NOP	;^^
	.ADDR	NOP	;^_
;
; Supdup -- Version for ARPA dial up lines
;



SUPAR:	CMP	#128
	BCS	ACTRL
	JMP	CHAR


ACTRL:	SEC
	SBC	#126
	JMP	ECTRL1


;
;
; DEC VT-52 -- one of the oldest and most supported Video Terminals
;
;	Character Set has been expanded to have control Codes act like in Glass
;


VT52:	CMP	#27	;Escape
	BEQ	ESC
	JMP	GLASS

ESC:	LDY	#ESCA^
	LDX	#ESCA&$FF
	JMP	SETVID

ESCA:	CMP	#'A
	BCS	ESCA2	;>=A
ESCA1:	JMP	ENDIT
ESCA2:	CMP	#'Z+1
	BCS	ESCA1	;>= Z+1
	SEC
	SBC	#'A
	ASL	A	;x2
	TAY
	LDA	ESCTAB,Y
	STA	JPL
	LDA	ESCTAB+1,Y
	STA	JPH
	LDX	NORMLL
	LDY	NORMLH
	JSR	SETVID	; Make sure the next character gets treated 'normally'
	JMP	(JPL)	; Dispatch through JPL

ESCTAB:	.ADDR	CURU	;$A
	.ADDR	CURD	;$B
	.ADDR	CURR	;$C
	.ADDR	CURL	;$D
	.ADDR	NOP	;$E
	.ADDR	NOP	;$F
	.ADDR	NOP	;$G
	.ADDR	HOME	;$H
	.ADDR	RLF	;$I
	.ADDR	CEOS	;$J
	.ADDR	CEOL	;$K
	.ADDR	NOP	;$L
	.ADDR	NOP	;$M
	.ADDR	NOP	;$N
	.ADDR	NOP	;$O
	.ADDR	NOP	;$P
	.ADDR	NOP	;$Q
	.ADDR	NOP	;$R
	.ADDR	NOP	;$S
	.ADDR	NOP	;$T
	.ADDR	NOP	;$U
	.ADDR	NOP	;$V
	.ADDR	NOP	;$W
	.ADDR	NOP	;$X
	.ADDR	DCA	;$Y
	.ADDR	ID	;$Z


CURU:	LDA	CY
	BEQ	CURU1
	SEC
	SBC	#1
	STA	CY
CURU1:	RTS

CURD:	LDA	CY
	CMP	#23
	BEQ	CURD1
	CLC
	ADC	#1
	STA	CY
CURD1:	RTS

CURR:	LDA	CX
	CMP	#127
	BEQ	CURR1
	CLC
	ADC	#1
	STA	CX
CURR1:	RTS

CURL:	LDA	CX
	BEQ	CURL1
	SEC
	SBC	#1
	STA	CX
CURL1:	RTS

HOME:	LDA	#0
	STA	CX
	STA	CY
	RTS

RLF:	LDA	CY
	SEC
	SBC	#1
	BPL	RLF1
	LDA	#<MEOS-128>/256
	STA	AH
	LDA	#<MEOS-128>&$FF
	STA	AL
	LDA	#MEOS/256
	STA	BH
	LDA	#MEOS&$FF
	STA	BL
	LDA	#<MSLN-128>/256
	STA	DH
	LDA	#<MSLN-128>&$FF
	STA	DL
	LDA	#$FF
	STA	EH
	STA	EL
	JSR	BMOVE
	LDA	#MSCR/256
	STA	AH
	LDA	#MSCR&$FF
	STA	AL
	LDA	#<MSCR+127>/256
	STA	BH
	LDA	#<MSCR+127>&$FF
	STA	BL
	JSR	BCLR
	LDA	#0
RLF1:	STA	CY
	RTS

DCA:	LDY	#DCA1^
	LDX	#DCA1&$FF
	JMP	SETVID

DCA1:	SEC
	SBC	#BLANK
	STA	CY
	LDY	#DCA2^
	LDX	#DCA2&$FF
	JMP	SETVID

DCA2:	SEC
	SBC	#BLANK
	STA	CX
	JMP	ENDIT

ID:	LDA	#27
	JSR	PUTR
	LDA	#'/
	JSR	PUTR
	LDA	#'Z
	JSR	PUTR
	RTS


;
; Glass -- Knows TAB, CR, LF, BEL, BS, FF, but not much else
;

GLASS:	CMP	#32	;Space
	BCC	GLASSC
	JMP	CHAR

GLASSC:	ASL	A	;*2
	TAY
	LDA	GCTAB,Y
	STA	JPL
	LDA	GCTAB+1,Y
	STA	JPH

	JMP	(JPL)

GCTAB:	.ADDR	NOP	;^@
	.ADDR	NOP	;^A
	.ADDR	NOP	;^B
	.ADDR	NOP	;^C
	.ADDR	NOP	;^D
	.ADDR	NOP	;^E
	.ADDR	NOP	;^F
	.ADDR	BEL	;^G
	.ADDR	BS	;^H
	.ADDR	TAB	;^I
	.ADDR	LF	;^J
	.ADDR	NOP	;^K
	.ADDR	CLR	;^L	;Clear Screen i.e. Form Feed
	.ADDR	CR	;^M
	.ADDR	NOP	;^N
	.ADDR	NOP	;^O
	.ADDR	NOP	;^P
	.ADDR	NOP	;^Q
	.ADDR	NOP	;^R
	.ADDR	NOP	;^S
	.ADDR	NOP	;^T
	.ADDR	NOP	;^U
	.ADDR	NOP	;^V
	.ADDR	NOP	;^W
	.ADDR	NOP	;^X
	.ADDR	NOP	;^Y
	.ADDR	NOP	;^Z
	.ADDR	NOP	;^[
	.ADDR	NOP	;^\
	.ADDR	NOP	;^]
	.ADDR	NOP	;^^
	.ADDR	NOP	;^_

TAB:	LDA	CX
	AND	#$78	;Round down to multiple of eight
	CLC
	ADC	#8
	STA	CX
	RTS






;
; End of various terminal drivers, start of subroutines
; called by the drivers
;



NOP:	RTS

DEL:	LDA	#127	;delete
	JMP	CHAR

;
; TDMOV = $80  Move cursor. followed by four bytes of args:
; OLDY (ignore) OLDX (ignore) CY and CX.
; remember that upon dialup lines CX+1 & CY+1
;

MOV:	LDX	#MOV1&$FF
	LDY	#MOV1^
	JMP	SETVID

MOV1:	LDX	#MOV2&$FF	;Ignore Old Y
	LDY	#MOV2^
	JMP	SETVID

MOV2:	LDX	#MOV3&$FF	;Ignore Old X
	LDY	#MOV3^
	JMP	SETVID

MV1:
MV0:	LDX	#MOV3&$FF
	LDY	#MOV3^
	JMP	SETVID

MOV3:	SEC
	SBC	#1
	CMP	#23
	BCC	MOV31	;If less than 23, goo
	LDA	#23

MOV31:	STA	CY

	LDX	#MOV4&$FF	;Store CY
	LDY	#MOV4^
	JMP	SETVID

MOV4:	SEC
	SBC	#1
	CMP	#127
	BCC	MOV41
	LDA	#127

MOV41:	STA	CX

ENDIT:	LDX	NORMLL
	LDY	NORMLH
	JMP	SETVID


BEL:	LDA	#1
	STA	SOUFLG
	JSR	$F90A	;Beep
	LDA	#0
	STA	SOUFLG
	RTS

BS:	LDA	CX
	TAX
	BEQ	BS1
	DEX
BS1:	STX	CX
	RTS

CRL:	JSR	CR	;Do CR, LF.


LF:	LDA	CY
	CLC
	ADC	#1
	CMP	#24
	BCC	LF1
	LDA	#<MSLN-128>/256
	STA	DH
	LDA	#<MSLN-128>&$FF
	STA	DL
	LDA	#MSCR/256
	STA	BH
	LDA	#MSCR&$FF
	STA	BL
	LDA	#MSCR+128/256
	STA	AH
	LDA	#<MSCR+128>&$FF
	STA	AL
	LDA	#1
	STA	EL
	LDA	#0
	STA	EH
	JSR	BMOVE

	LDA	#MEOS/256
	STA	BH
	LDA	#MEOS&$FF
	STA	BL
	LDA	#<MEOS-128>/256
	STA	AH
	LDA	#<MEOS-128>&$FF
	STA	AL
	JSR	BCLR
	LDA	#23	;last line

LF1:	STA	CY
	JMP	CEOL	;ITS line feed implies clear, too.



CR:	LDA	#0
	STA	CX
	RTS

CEOS:	LDX	CX	;A=(CX, CY)
	LDY	CY
	JSR	LOADA
	LDX	#127	;B=(127, 23)
	LDY	#23
	JSR	LOADB
	JMP	BCLR	;block clear


CEOL:	LDX	CX	;A=(CX, CY)
	LDY	CY
	JSR	LOADA
	LDX	#127	;B=(127, CY)
	LDY	CY
	JSR	LOADB
	JMP	BCLR	;block clear

;
; DLF -- Delete character under cursor, don't move cursor. 
;


DLF:	LDX	CX
	LDY	CY
	JSR	SETAD
	LDY	#0
	TYA
	STA	(VADL),Y
	RTS

;
; FS -- Forward one collumn.
;

FS:	LDX	CX
	INX
	STX	CX
	RTS

;
; CLR -- Clear screen
;

CLR:	LDA	#0
	STA	CX
	STA	CY
	LDA	#MSCR/256
	STA	AH
	LDA	#MSCR&$FF
	STA	AL
	LDA	#MEOS/256
	STA	BH
	LDA	#MEOS&$FF
	STA	BL
	JMP	BCLR

;
; The following are a set of subroutines used by the various block move character
; escapes to make the code shorter & some what easier to understand.
;

;
; SETVID -- sets the vector VIDEOL (through which the main loop of this program will
; jump) to the vector MSB in Y, LSB in X.
;

SETVID:	STX	VIDEOL
	STY	VIDEOH
	RTS

;
; LOADA -- transform the screen character position in X & Y
; into a memory address, and store it in the AL block move source register
;

LOADA:	JSR	SETAD
	LDA	VADL
	STA	AL
	LDA	VADH
	STA	AH
	RTS

;
; LOADB -- transform the screen coordinates in X & Y into memory
; address, then store it in the block move destination register
;

LOADB:	JSR	SETAD
	LDA	VADL
	STA	BL
	LDA	VADH
	STA	BH
	RTS

;
; LOADD -- transform the screen coordinates in X & Y into a length,
; then store that length in the block move byte count down register.
;

LOADD:	TXA
	ASL	A
	TAX
	TYA
	LSR	A
	STA	DH
	TXA
	ROR	A
	STA	DL
	RTS

;
; BMDN -- Set the byte counter to (x, y), then set the
; block increment register to 1 and jump to the block move routine
;

BMDN:	JSR	LOADD
	LDA	#0
	STA	EH
	LDA	#1
	STA	EL
	JMP	BMOVE

;
; BMUP -- Set the byte counter to (x,y) then set the
; block increment register to -1 (FFFF) and jump to the block move routine
;

BMUP:	JSR	LOADD
	LDA	#$FF
	STA	EL
	STA	EH
	JMP	BMOVE


;
; ILP -- insert line positions
;
; Next char is the number of lines to insert
;


ILP:	LDA	#23		;Treate it like a RSD with the bottom of the screen
	STA	NLIR		; as the bottom of the region.
	LDY	#RSD2^
	LDX	#RSD2&$FF
	JMP	SETVID

N:	.BYTE	0	;Used to save the number of characters/lines to insert/delete.

NLIR:	.BYTE	0	;Used to hold Number of Lines in region


;
; DLP -- Delete line positions.  One arg is the number of lines
; to delete
;



DLP:	LDA	#23	;Treat like a region scroll up with a last line of zero
	STA	NLIR
	LDY	#RSU2^
	LDX	#RSU2&$FF
	JMP	SETVID


;
; ICP -- Insert character positions
; The one arguement is the ever popular # of characters to insert
;


ICP:	LDY	#ICP1^
	LDX	#ICP1&$FF
	JMP	SETVID

ICP1:	STA	N
	LDA	#127	;A=(127-N,CY)
	SEC
	SBC	N
	TAX
	LDY	CY
	JSR	LOADA

	LDX	#127	;B=(127, CY)
	LDY	CY
	JSR	LOADB

	LDA	#128	;D=(128-CX-N,0)
	SEC
	SBC	CX
	SBC	N
	TAX
	LDY	#0
	JSR	BMUP	;Block move up

	LDX	CX	;A=(CX,CY)
	LDY	CY
	JSR	LOADA

	LDA	CX	;B=(CX+N-1, CY)
	CLC
	ADC	N
	SEC
	SBC	#1
	TAX
	LDY	CY
	JSR	LOADB

	JSR	BCLR
	JMP	ENDIT

;
; DCP -- Delete character positions one arg, natch
;


DCP:	LDY	#DCP1^
	LDX	#DCP1&$FF
	JMP	SETVID

DCP1:	STA	N
	LDA	CX	;A=(CX+N, CY)
	CLC
	ADC	N
	TAX
	LDY	CY
	JSR	LOADA

	LDX	CX	;B=(CX,CY)
	LDY	CY
	JSR	LOADB

	LDA	#128	;D=(128-CX-N, 0)
	SEC
	SBC	CX
	SBC	N
	TAX
	LDY	#0
	JSR	BMDN	;Block move down (i.e. to the left)

	LDA	#128	;A=(127-N+1, CY)
	SEC
	SBC	N
	TAX
	LDY	CY
	JSR	LOADA

	LDX	#127	;B=(127, CY)
	LDY	CY
	JSR	LOADB
	JSR	BCLR
	JMP	ENDIT

;
;	TDRSU	Region Scroll Up
;
;	Takes two arguements -- Number of lines in region
;			and	Number of lines by which to scroll region
;

RSU:	LDX	#RSU1&$FF
	LDY	#RSU1^
	JMP	SETVID

RSU1:	CLC		;Use Number of lines in region to compute the last line
	ADC	CY	;in the region.
	SEC
	SBC	#1	;Last line in region = CY+NLIR-1
	CMP	#24
	BCC	RSU11	;Region is all on screen

	LDA	#23	;Region too big so set it to the largest possible value
RSU11:	STA	NLIR

	LDX	#RSU2&$FF
	LDY	#RSU2^
	JMP	SETVID

RSU2:	STA	N
	CLC
	ADC	CY	;acc = N+CY
	CMP	NLIR
	BCC	RSU22
	LDA	NLIR	;Number of lines to scroll > Number of lines in region
	SEC		;Ought to be NLIR - CY + 1
	SBC	CY
	CLC
	ADC	#1
	STA	N





RSU22:	LDX	#0	;A=(0,CY+N)
	LDA	CY
	CLC
	ADC	N
	TAY
	JSR	LOADA

	LDX	#0	;B=(0,CY)
	LDY	CY
	JSR	LOADB

	LDX	#0	;D=(0,NLIR+1-CY-N)
	LDA	NLIR
	CLC
	ADC	#1
	SEC
	SBC	CY
	SBC	N
	BMI	RSUBAD
	TAY
	JSR	BMDN	;Block move down (up screen.)

	LDX	#0	;A=(0,NLIR-N+1)
	LDA	NLIR
	CLC
	ADC	#1
	SEC
	SBC	N
	TAY
	JSR	LOADA

	LDX	#127	;B=(127, NLIR)
	LDY	NLIR
	JSR	LOADB

	JSR	BCLR

RSUBAD:	JMP	ENDIT


;
;	TDRSD	Region Scroll Down
;
;	Takes two arguements -- Number of lines in region
;			and	Number of lines by which to scroll region
;

RSD:	LDX	#RSD1&$FF
	LDY	#RSD1^
	JMP	SETVID


RSD1:	CLC		;Use Number of lines in region to compute the last line
	ADC	CY	;in the region.
	SEC
	SBC	#1	;Last line in region = CY+NLIR-1
	CMP	#24
	BCC	RSD11	;Region is all on screen

	LDA	#23	;Region too big so set it to the largest possible value
RSD11:	STA	NLIR

	LDX	#RSD2&$FF
	LDY	#RSD2^
	JMP	SETVID

RSD2:	STA	N
	CLC
	ADC	CY
	CMP	NLIR
	BCC	RSD22
	LDA	NLIR	;Number of lines to scroll > Number of lines in region
	SEC		; So make it  NLIR -CY + 1
	SBC	CY
	CLC
	ADC	#1
	STA	N

;
; In the equations in the following comments, NLIR == last line of region
;

RSD22:	LDX	#127	;A=(127, NLIR-N)
	LDA	NLIR
	SEC
	SBC	N
	TAY
	JSR	LOADA

	LDX	#127	;B=(127, NLIR)
	LDY	NLIR
	JSR	LOADB

	LDX	#0	;D=(0,NLIR+1-CY-N)
	LDA	NLIR
	CLC
	ADC	#1
	SEC
	SBC	CY
	SBC	N
	TAY

	JSR	BMUP	;Block move up (in RAM i.e. down on screen)

	LDX	#0	;A=(0,CY)
	LDY	CY
	JSR	LOADA

	LDX	#127	;B=(127,CY+N-1)
	LDA	CY
	CLC
	ADC	N
	TAY
	DEY
	JSR	LOADB

	JSR	BCLR	;Block clear
	JMP	ENDIT






;
; ERROR -- Error routine.  Stuffs an error byte on
; the screen and loops for ever and ever.
;


ERROR:	STA	$9E00
	JMP	ERROR



;
;	Must come at end of program!
;

PND	=	.

	.END
