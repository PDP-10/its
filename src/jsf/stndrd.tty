
		;TTY ROUTINES 8/14/72 JSF
;10/6/71 SPCCHM REPLACED BY SPCCKM
;1/26/72 A .SLEEP FLUSHED IN FORMF AND RTYI0 ADDED
;8/14/72 JCL FEATURE ADDED
	;ALSO * AT KERCHK CHANGED TO _
;8/26/72 RFDTRB PUT IN

		;STANDARDIZED FOR .INSRT DUE TO THEIR FAIR COMPLEXITY NOW (W/ HAIRY RUBOUT)
		;AND DUE TO THE OBSERVED SUDDEN CHANGES IN STANDARD TTY PROGRAMMING
		;NECESSITATED BY CHANGES IN THE SYSTEM

TYINIT:	.OPEN TYIC,[20,,SIXBIT /   TTYPROG  INPUT/]	;INPUT, CONVERT LOWER CASE TO UPPER
	.VALUE
	.OPEN TYOC,[21,,SIXBIT /   TTYPROG  OUTPUT/]	;DISPLAY MODE OUTPUT
	.VALUE
IFDEF GETTY,[.STATUS TYOC,A	;FIGURE OUT WHAT KIND OF CONSOLE
	TRNE A,77#2
	TMODF ZA,GETTY	;NOT DISPLAY CONSOLE
	SETF GETTY	;DISPLAY CONSOLE
]	POPJ P,

IFDEF SILNT,[TYICS:	CLEARF SILNT	;HERE ON CONTROL S READ, UNSILENCE TYPEOUT
IFDEF USILNC,USILNC	;MAIN PROGRAM PROVIDED THING
]TYI:	.IOT TYIC,A	;GET TYPED IN CHARACTER IN A
	JUMPE A,TYI	;IGNORE ZERO
IFDEF SILNT,[CAIN A,^S	;CONTROL S?
	JRST TYICS	;UNSILENCE TYPEOUT SILENCED AT INTERRUPT LEVEL, DON'T GIVE ^S TO PROG
]	CAIN A,^L	;FORM FEED?
	JRST FORMF	;YES, TYPE IT OUT
	POPJ P,

TYO:	IFDEF SILNT,[TESTF N,SILNT	;TYPE OUT CHAR IN A, BUT NOT IF TYPEOUT SILENCED
TYOIOT:]IFNDEF SILNT,TYOIOT::		;PC COMPARISON LOC (TO SEE IF HUNG ON TYPEOUT)
	.IOT TYOC,A	;TYPE OUT CHAR
	POPJ P,

		;IF DISPLAY CONSOLE, CLEAR SCREEN

FORMF:	IFDEF GETTY,[TESTF N,GETTY
	JRST FORMF2	;NOT DISPLAY CONSOLE, IGNORE
]IFNDEF GETTY,[.STATUS TYOC,A
	TRNE A,77#2
	JRST FORMF2	;NOT DISPLAY CONSOLE
]	PUSH P,B
	MOVEI B,[ASCIZ /îC/]	;CR, CONTROL P, C (CR TO MAKE SURE SYSTEM GETS ITS POINTERS STRAIGHT)
	PUSHJ P,ATYPE
	POP P,B
FORMF2:	MOVEI A,^L
	POPJ P,

ATYPE:	JUMPE B,CPOPJ	;IGNORE ADR OF ZERO
	HRLI B,440700	;TYPE OUT ASCIZ STRING POINTED TO BY B
ATYPEL:	IFDEF SILNT,[
	TESTF E,SILNT
	POPJ P,		;TYPEOUT SILENCED, STOP NOW
]	ILDB A,B
	JUMPE A,CPOPJ
	CAIE A,^C	;ALSO STOP ON EOFCH,
	CAIN A,^L	;OR FORM FEED
	POPJ P,
	PUSHJ P,TYO
	JRST ATYPEL

CRLF:	MOVEI A,^M	;TYPE OUT CRLF
	PUSHJ P,TYO
	MOVEI A,^J
	JRST TYO

IFDEF GETTY,[
KERCHK:	TESTF N,GETTY	;ENTRY NOT TO TYPE CRLF ON DISPLAY CONSOLE
CRRR:	PUSHJ P,CRLF
	TESTF N,GETTY
	POPJ P,		;NO DISPLAY CONSOLE, THAT'S ALL
	MOVEI A,"_	;DISPLAY CONSOLE, MAKE IT VISIBLE
	JRST TYO

		;"ECHO" CHAR IN A, CLOBBERS A

ETYO:	PUSH P,B	;SAVE B, CLOBBERED BY ATYPE
	MOVEI B,A	;DEFAULT IS CHAR ITSELF
	CAIN A,^I	;TAB?
	MOVEI B,[ASCIZ /   /]	;TAB, TYPE OUT AS THREE SPACES
	CAIN A,^P
	MOVEI B,[ASCIZ /^P/]	;AVOID DISPLAY MODE LOSSAGE
	LSH A,36.-7	;SHIFT CHAR IN CASE TYPING IT OUT
	JRST ETYO2	;TYPE OUT STUFF AND RETURN
]

		;RETURN NEXT CHAR IN TYPED IN STRING IN A
		;IF STRING EMPTY, READ NEW ONE UNTIL CR, ALLOWING RUBOUTS
		;NOTE SPECIAL INTERPRETATION OF RUBOUT, ^C AND ^L
		;ALSO NOTE THAT TYI DOESN'T INPUT ^@ OR (IF SILNT DEFINED) ^S

RTYI:	ILDB A,RTYIP'	;GET CHAR
	JUMPN A,CPOPJ	;RETURN ON NOT ZERO
RTYI0:	PUSH P,B	;SAVE B, WILL USE AS BYTE POINTER
	MOVE B,[010700,,RTYIBF-1]
	MOVEM B,RTYIP
RTYI1:	PUSHJ P,TYI	;GET CHAR
	IFDEF SPCCKM,SPCCKM	;CHECK FOR PROGRAM-DEPENDENT SPECIAL CHARACTERS
	CAIN A,^C
	JRST RTYIQT	;FLUSH LINE, START AGAIN
	CAIN A,177
	JRST RTYIRB	;RUBOUT
	CAIN A,^L
	JRST RTYIFF	;FORM FEED, RETYPE LINE SO FAR
	IDPB A,B	;LOOKS GOOD, USE IT
RTYIDL:	CAIE A,^M	;CARRIAGE RETURN?
	JRST RTYI2	;NO, GO BACK FOR NEXT
	MOVEI A,0	;CARRIAGE RETURN, INDICATE END OF LINE
	IDPB A,B	;MARK END OF LINE SO WILL RECYCLE IF NECESSARY
	POP P,B		;NOW RESTORE B
	JRST RTYI	;TRY AGAIN WITH NEW LINE

RTYI2:	CAME B,[100700,,RTYIBF+RTYIBL-1]	;BUFFER FULL?
	JRST RTYI1	;NO, BACK FOR NEXT CHAR
	MOVEI A,^G	;BUFFER FULL, FIRST GO DING
	PUSHJ P,TYO	;THEN PLAY LIKE RUBOUT
RTYIRB:	CAMN B,[010700,,RTYIBF-1]
	JRST RTYIRQ	;BACK TO BEGINNING OF LINE
	LDB A,B		;GET LAST CHAR
	PUSHJ P,IFNDEF GETTY,[TYO] IFDEF GETTY,[TYORB]	;TYPE OUT OR RUB OUT
	DBP7J B,RTYI1

RTYIRQ:	IFNDEF RTYIQM,[IFDEF GETTY,[	;RUBBED BACK TO BEGINNING OF BUFFER
	TESTF N,GETTY	;SKIP IF DISPLAY CONSOLE, DON'T BOTHER TYPING CR
]
RTYIQT:	PUSHJ P,CRLF
]IFDEF RTYIQM,RTYIQT:	RTYIQM	;MAYBE RETURN TO "MAIN COMMAND LEVEL" OR SOMETHING
RTYIQ2:	MOVE B,[010700,,RTYIBF-1]
	EXCH B,RTYIP
	JRST RTYI1

RTYIFF:	IFDEF GETTY,TESTF N,GETTY
	PUSHJ P,CRLF	;NOT GETTY, TYPE OUT CRLF
RTYIF2:	CAMN B,RTYIP	;NOW RETYPE LINE SO FAR
	JRST RTYIQ2	;DONE, RE-INITIALIZE AND FALL BACK IN
	ILDB A,RTYIP	;GET CHAR
	PUSHJ P,IFDEF GETTY,[ETYO] IFNDEF GETTY,[TYO]	;TYPE OUT
	JRST RTYIF2

IFNDEF RTYIBL,RTYIBL==20.	;LENGTH OF TYPEIN BUFFER
RTYIBF:	BLOCK RTYIBL		;TYPEIN BUFFER FOR RTYI

IFDEF GETTY,[
	;TYPE OUT A "RUBOUT"
	;ON TELETYPE, JUST TYPE OUT CHAR IN A
	;ON DISPLAY CONSOLE, UNDO EFFECT OF CHARACTER
	;DOESN'T WORK FOR CR, TYPEOUT PAST END OF LINE, FORM FEED, OR TTY TAKEN AWAY AND GIVEN BACK

TYORB:	TESTF N,GETTY
	JRST TYO	;NOT DISPLAY CONSOLE, JUST RETYPE CHAR
	PUSH P,B	;SAVE B, ASSUMED TO BE BYTE POINTER TO LAST CHAR SO FAR (USUALLY THIS)
	MOVEI B,BSSPBS
	CAIGE A,40	;NOW TO CHECK FOR SPECIAL
	MOVEI B,BSSBS2	;CONTROL CHAR, PROBABLY TYPES OUT AS TWO
	CAIN A,33
	MOVEI B,BSSPBS	;ALTMODE, TYPES OUT AS ONE CHAR
	CAIL A,^G
	CAILE A,^J
	JRST .+2
	MOVEI B,TYORBT-^G(A)	;BELL, BACKSPACE, TAB, OR LINE FEED
ETYO2:	PUSHJ P,ATYPE	;DO SOMETHING
	POP P,B
	POPJ P,

BSSPBS:	ASCIZ / /	;BACKSPACE, SPACE, BACKSPACE
BSSBS2:	ASCIZ /  /	;BS BS SP SP BS BS

TYORBT:	0		;^G, UNDO BY NO-OP'ING
	ASCIZ /F/	;^H BACKSPACE, UNDO BY MOVING FORWARD ONE
	ASCIZ //	;^I TAB, UNDO BY SPACING BACK THREE
	ASCIZ /U/	;^J LINE FEED
IFN .-TYORBT-4,PRINTB TYORBT LOSES.
]

IFDEF JCLOFS,[

JCLGET:	MOVE A,[RTYIBF+JCLOFS,,RTYIBF+JCLOFS+1]
	SETZM RTYIBF+JCLOFS
	BLT A,RTYIBF+RTYIBL-2
	HRRZM A,RTYIBF+RTYIBL-1
	MOVE A,[-JCL12L,,JCL12]
	.BREAK 12,A
	SKIPN RTYIBF+JCLOFS
	TDZA A,A
	MOVE A,[440700,,RTYIBF]
	MOVEM A,RTYIP
	POPJ P,

JCL12:	5,,RTYIBF+JCLOFS
	SIGN+5,,[0]
JCL12L==.-JCL12
]

IFDEF RFDTSW,[IFN RFDTSW,[

	;TABLE OF DEVICE NAMES (IN RH, LH ZERO) OF DEVICES THAT TAKE SYSTEM NAME
	;PLACES WHERE DIGITS ARE EXPECTED ARE REPLACED WITH ZEROS

RFDTRB:	'DSK
	'DK0
	'PK0
	'P00
	(SIXBIT /ML/)
	(SIXBIT /AI/)
	'JOB
	'CLO
	'CLU
RFDTRL==.-RFDTRB	;LENGTH OF THIS TABLE
]]
