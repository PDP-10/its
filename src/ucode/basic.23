.TOC	"THE INSTRUCTION LOOP"

;INSTRUCTION DECODE, EA COMPUTATION, AND OPERAND FETCH
;	IN GENERAL, AN INSTRUCTION IS STARTED AT XCTGO.
; AT THIS TIME THE INSTRUCTION IS IN ARX AND IR, AND PC HAS ITS ADDRESS.
; THE DRAM OUTPUTS AND "AC" BITS WILL SETTLE DURING THIS
; MICROINSTRUCTION, AND WILL BE LATCHED BY THE CLOCK WHICH ENDS
; THE CYCLE.  XCTGO DISPATCHES ON THE STATE OF THE
; INDIRECT AND INDEX BITS OF THE ARX (EA MOD DISP) TO COMPEA OR
; ONE OF THE THREE LOCATIONS FOLLOWING IT.
;	IF INDIRECT IS SPECIFIED, THE INDIRECT POINTER IS FETCHED (AT
; COMPEA+2 OR +3 DEPENDING ON WHETHER INDEXING IS ALSO SPECIFIED).
; WE WAIT FOR IT AT INDRCT, AND THEN LOOP BACK TO COMPEA.  WHEN NO
; INDIRECT IS CALLED FOR, WE COMPUTE THE INSTRUCTION'S EFFECTIVE ADDRESS
; (EA) AT COMPEA OR COMPEA+1 (DEPENDING ON WHETHER INDEXING IS CALLED
; FOR), AND PERFORM THE FUNCTION "A READ", WHOSE OPERATION DEPENDS
; ON THE DRAM A FIELD, AS FOLLOWS:
;
; MACRO	 A-FLD	MEM FUNCTION	VMA	DISPATCH
;  I	  0	NONE		AD(=EA)  DRAM J
; I-PF	  1	FETCH		PC+1	 DRAM J
;	  2	NONE		AD	   42
;  W	  3	WR TST		AD	   43
;  R	  4	READ		AD	   44
; R-PF	  5	READ		AD	   45
; RW	  6	READ/WR TST	AD	   46
; RPW	  7	RD-PSE/WR TST	AD	   47
;
;	A FIELD VALUES 0 AND 1 ARE USED FOR INSTRUCTIONS WHICH NEITHER
; READ NOR WRITE THE CONTENTS OF EA (IMMEDIATE-MODE INSTRUCTIONS,
; JUMPS, ETC).  THESE DISPATCH FROM "A READ" DIRECTLY TO THE MICROCODE
; WHICH HANDLES THE INSTRUCTION.  IF THE A FIELD CONTAINS 1, "A READ"
; CAUSES A PREFETCH (FROM PC+1), SO THAT THE MBOX CAN WORK ON GETTING
; THE NEXT INSTRUCTION INTO ARX WHILE THE EBOX PERFORMS THIS ONE.
;	IF THE A FIELD CONTAINS 3, THE MBOX PERFORMS A PAGING CHECK ON
; EA, AND CAUSES A PAGE FAIL IF THAT LOCATION IS NOT WRITABLE.
; THE MICROCODE GOES TO 43 TO WAIT FOR COMPLETION OF THE PAGE CHECK,
; AND AT THAT LOCATION LOADS AC INTO AR.  THE WRITABILITY OF EA IS
; VERIFIED AT THIS TIME TO PREVENT INCORRECTLY SETTING FLAGS OR
; THE PROCESSOR STATE IF THE INSTRUCTION WILL BE ABORTED BY PAGE
; FAILURE.  LOCATION 43 THEN DISPATCHES TO THE HANDLER FOR THE
; CURRENT INSTRUCTION.
;	A FIELD VALUES 4 TO 7 PERFORM READS FROM EA.  6 AND 7 ALSO TEST
; THE WRITABILITY OF THE LOCATION, AND 7 PERFORMS THE FIRST HALF OF
; A READ-PAUSE-WRITE CYCLE IF EA IS AN UN-CACHED ADDRESS.  THE DISPATCH
; IS TO 40+A, WHERE WE WAIT FOR MEMORY DATA TO ARRIVE IN AR.  IF THE A
; FIELD WAS 5, WE PREFETCH FROM PC+1 AS SOON AS THE DATA ARRIVES.
; IN ANY CASE, WE DISPATCH ACCORDING TO THE DRAM J FIELD TO THE
; HANDLER FOR THE INSTRUCTION.
;	IF A PAGE FAIL OCCURS AT ANY TIME (EITHER IN THIS CODE OR DURING
; INSTRUCTION EXECUTION) THE MICROPROCESSOR TRAPS TO CRAM LOCATION
; 1777, WHERE IT CAUSES A PAGE FAIL TRAP.
;	MOST INSTRUCTIONS (THE MOVE, HALFWORD, AND BOOLEAN GROUPS,
; PLUS ADD AND SUB) ARE PERFORMED BY HANDLERS CONSISTING OF ONE OR
; TWO MICROINSTRUCTIONS WHICH LEAVE THE RESULT IN AR, AND COMPLETE
; BY INVOKING THE "EXIT" MACRO.  EXIT USES THE MEM/B WRITE FUNCTION
; TO BEGIN A STORE TO MEMORY FOR THOSE MODES IN WHICH THE RESULT
; GOES TO MEMORY, AND DISP/DRAM B TO GET TO ONE OF THE MICROINSTRUCTIONS
; FOLLOWING ST0.  THIS CODE DEPENDS ON A CERTAIN AMOUNT OF CORRELATION
; BETWEEN THE DRAM A AND B FIELDS.  IN PARTICULAR, STAC (STORE AC)
; ASSUMES THAT A PREFETCH HAS OCCURRED, WHILE THE OTHERS ASSUME THAT
; NO PREFETCH HAS OCCURED.  THUS NORMAL AND IMMEDIATE MODES, WHOSE
; RESULTS GO ONLY TO AC, MUST PREFETCH IN THE DRAM A FIELD, WHILE
; MEM, BOTH, AND SELF MODES, WHOSE RESULTS GO TO MEMORY, MUST NOT.
; (THIS RESTRICTION IS AVOIDED FOR THOSE INSTRUCTIONS WHICH NEVER
; PREFETCH -- IN MUL, DIV, AND IDIV BY USE OF THE EXIT TO ST2AC,
; AND IN IMUL AND THE SINGLE PRECISION FLOATING POINT
; INSTRUCTIONS BY A RESTRICTED EXIT TO ST6.)
;	ANOTHER LARGE SET OF INSTRUCTIONS (SKIP, AOS, SOS, JUMP, AOJ,
; SOJ, AOBJ, CAI, CAM, AND THE TEST GROUP) KNOWS WHERE TO PUT THE
; RESULTS WITHOUT MODE INFORMATION, AND THEY USE THE DRAM B FIELD TO
; DETERMINE WHETHER TO SKIP OR JUMP, AS A FUNCTION OF THEIR OPERANDS.
; SKIP, AOS, AND SOS ARE CONSIDERED SELF-MODE INSTRUCTIONS,
; AND AFTER MAKING THE FETCH DECISION (AND RE-WRITING MEMORY, IN
; THE CASE OF AOS OR SOS), JUMP TO STSELF TO DECIDE WHETHER OR NOT
; TO PUT THE RESULT ALSO IN AC.  THE OTHER INSTRUCTIONS OF THIS SET
; JUMP TO STORAC OR NOP AFTER MAKING THE FETCH DECISION, DEPENDING
; ON WHETHER OR NOT THE OPCODE DEFINITION REQUIRES MODIFICATION OF AC.
; (NOTE THE DIFFERENCE BETWEEN STAC AND FINI ON THE ONE HAND,
; AND STORAC AND NOP ON THE OTHER -- STORAC AND NOP MUST BE USED WHEN
; THE NEXT INSTRUCTION FETCH OCCURS ON THE PRECEDING EBOX CYCLE, BECAUSE
; NICOND MUST NOT IMMEDIATELY FOLLOW A FETCH (ONE CYCLE REQUIRED FOR
; VMA AC REF TO MAKE IT THROUGH THE NICOND LOGIC), STAC AND FINI ARE
; USED WHEN THERE HAS BEEN AN INTERVENING CYCLE.)
.TOC	"NEXT INSTRUCTION DISPATCH"

;START BY PUTTING PC WORD IN AR, JUMP HERE
0:
START:	SET FLAGS_AR,BR/AR,J/BRJMP	;LOAD UP FLAGS
CONT:	VMA/PC,FETCH,J/XCTW		;HERE TO CONTINUE FROM PC

;	DISP/NICOND (THE "NXT INSTR" MACRO) BRINGS US TO ONE OF THE
; LOCATIONS FOLLOWING "NEXT".  PC HAS BEEN UPDATED TO ADDRESS THE NEXT
; INSTRUCTION IN THE NORMAL FLOW, AND IF IT IS FROM MEMORY
; (AS OPPOSED TO AC'S), THE INSTRUCTION IS IN ARX AND IR.
;	THE NICOND DISPATCH IS PRIORITY ENCODED, AS FOLLOWS:
; [FOR FULL DETAILS, SEE PRINT CON2]
;(1)	IF PI CYCLE IS TRUE, GO TO NEXT FOR SECOND HALF
; OF STANDARD OR VECTOR INTERRUPT.
;(2)	IF THE RUN FLOP (CON RUN) IS OFF, GO TO NEXT+2, FROM WHICH THE
; MICROCODE WILL ENTER THE HALT LOOP TO WAIT FOR THE CONSOLE TO RESTART
; INSTRUCTION PROCESSING.
;(3)	IF THE METER HAS A REQUEST, GO TO NEXT+4 (MTRINT) TO SERVE IT.
;(4)	IF THE PI SYSTEM HAS A REQUEST READY, GO TO NEXT+6 (INTRPT)
; TO START A PI CYCLE.
;(5)	IF CON UCODE STATE 05 (TRACK EN) IS SET, GO TO NEXT+10 OR 11.
; THIS FLOP IS ENTIRELY UNDER CONTROL OF THE MICROCODE, AND IS ONLY
; USED FOR THE SPECIAL STATISTICS-GATHERING MICROCODE.
;(6)	IF THE LAST INSTRUCTION SET A TRAP FLAG, GO TO NEXT+13 OR +17,
; IT DOESN'T MATTER WHICH.
;(7)	IF VMA CONTAINS AN AC ADDRESS, IMPLYING THAT THE NEXT
; INSTRUCTION IS TO COME OUT OF FAST MEMORY, GO TO NEXT+16 TO GET IT.
;(10)	--NORMAL CASE-- THE INSTRUCTION IS IN ARX, READY TO GO, GO
; TO NEXT+12 (XCTGO).

=11*0000				;USE LOC'NS INACCESSIBLE TO DRAM
NEXT:	SET PI CYCLE,GEN FE,		;2ND PART OF INTERRUPT
		BYTE DISP,J/PICYC2	;SKIP IF VECTOR INT
=0010	AR_0S,SET HALTED,J/HALT1	;HERE IF RUN FLOP OFF
=0100
MTRINT:	CLR ACCOUNT EN,J/MTRREQ		;HERE IF METER REQUEST UP
	AR_EBUS,SC_#,#/2,J/PICYC1	;HERE IF TAKE INTRPT DOESNT FIND
=0110					; A METER REQUEST
INTRPT:	AR_EBUS,SC_#,#/2,J/PICYC1	;HERE IF INTERRUPT PENDING
.IF/TRACKS
=1000	AR_TRX+1,GEN CRY18,SKP CRY0,J/TRK1	;HERE TO STORE PC BEFORE
	AR_TRX+1,GEN CRY18,SKP CRY0,J/TRK1	; EXECUTING NEXT INSTR
.ENDIF/TRACKS
.IF/OP.CNT
=1000	SC_#,#/9.,SKP USER,J/OPCT1	;COUNT THIS INSTR
	SC_#,#/9.,SKP USER,J/OPCT1
.ENDIF/OP.CNT
.IF/OP.TIME
=1000	AR_2,CLR TRK+PA EN,J/OPTM1	;TIME OUT THIS INSTR
	AR_2,CLR TRK+PA EN,J/OPTM1
.ENDIF/OP.TIME
;-- THE NICOND DISPATCH BLOCK CONTINUES ON THE NEXT PAGE --
;-- NICOND DISPATCH CONTINUED --

=1010
XCTGO:	BRX/ARX,SET ACCOUNT EN,		;SAVE INSTR, ENABLE ACCOUNTING,
	    EA MOD DISP,J/COMPEA,AR_1S	;GO CALCULATE EA, -1 FOR SOJ HACK
.IFNOT/ONE PROCEED
TRAP:	VMA_420+TRAP,J/TRAPX		;HERE IF TRAP BITS SET
.IF/ONE PROCEED
TRAP:	GET ECL EBUS,SC_1,J/TR3CHK	;TRAP, CHECK FOR ONE PROCEED
.ENDIF/ONE PROCEED
=1110	ARX_FM(VMA),TIME/3T,LOAD IR,J/XCTGO	;HERE IF INSTR IS IN FM
.IFNOT/ONE PROCEED
	VMA_420+TRAP,J/TRAPX		;HERE IF TRAP BITS SET
.IF/ONE PROCEED
	ARX_FM(VMA),TIME/3T,LOAD IR,	;HERE IF TRAP AND VMA->ACS
		J/TRAP			;FETCH THE INSTR THEN TRAP
.ENDIF/ONE PROCEED

.IF/ONE PROCEED
;HERE ON TRAPS, WITH INSTRUCTION IN ARX AND IR, 1 IN SC,
;AND ECL EBUS GRABBED.  UNFORTUNATELY THE HARDWARE CAREFULLY
;CLEARS THE TRAP BITS IN THE PC WORD ON A NICOND, BUT
;WE CAN USE A DIAGNOSTIC FUNCTION TO READ THE TRAP CYC BITS (SCD4).
;THE "ADDRESS BREAK INHIBIT" HAIR (SCD5) IS USED TO
;DETECT WHEN AN INSTRUCTION IS COMPLETED.
;IF THIS IS A TRAP 3, AND SCD ADDR BRK CYC IS TRUE, WE ARE
;IN THE MIDDLE OF A ONE-PROCEED, SO SUPPRESS THE TRAP.
;SCD ADDR BRK CYC IS ON WHEN NICOND IS DONE WITH
;ADR BRK INH SET IN THE PC FLAGS (I.E. JUST STARTING
;OR RE-STARTING THE INSTRUCTION BEING ONE-PROCEEDED.)

TR3CHK:	AR03-04_SCD TRAP CYC
	VMA_420+TRAP,SH DISP,J/TR3DSP	;VMA -> TRAP INST, CHECK TRAP NUMBER
=11100
TR3DSP:
=01
	REL ECL EBUS,J/TRAPX		;TRAP 1 - TAKE TRAP
	REL ECL EBUS,J/TRAPX		;TRAP 2 - TAKE TRAP
	AR05_SCD ADDR BRK CYC		;TRAP 3 - CHECK FOR ONE PROCEED
	GEN P AND SC,SKP SCAD NE	;SKIP IF ONE-PROCEEDING
=1***0
	REL ECL EBUS,J/TRAPX		;NO, TAKE THE TRAP
	REL ECL EBUS			;YES, DO THE INSTR THEN
	TRAP3,J/XCTGO			;ARRANGE FOR ANOTHER TRAP
					;WHEN THE INSTRUCTION COMPLETES
.ENDIF/ONE PROCEED

;HERE ON TRAPS, VMA SETUP WITH 420+TRAP CODE

TRAPX:	LOAD ARX,PT REF			;GET AND XCT TRAP INSTR
	SET PC+1 INH			;DON'T INCREMENT PC FOR THIS INSTR

;HERE AFTER FETCHING INSTR TO BE EXECUTED

XCTW:	ARX_MEM,LOAD IR,J/XCTGO		;GET INSTR TO XCT
.TOC	"EFFECTIVE ADDRESS COMPUTATION AND OPERAND FETCH"

;COME HERE WITH -1 IN AR IF YOU EXPECT SOJ TO WORK!
=11***00				;HERE WITH XR CALC IN PROG
COMPEA:	AR_ARX (AD),A READ,		;NO MOD, GET OPERAND IF ANY
		MQ_AR			;SOJ SERIES EXPECTS -1 IN MQ
	AR_ARX+XR,A READ,		;INDEXED, NO @
		MQ_AR			;SOJ SERIES EXPECTS -1 IN MQ
	GEN ARX,A INDRCT,		;DO INDIRECT, NO INDEX
		SKP INTRPT,J/INDRCT
	GEN ARX+XR,A INDRCT,		;BOTH @ AND XR
		SKP INTRPT,J/INDRCT
=11****0
INDRCT:	ARX_MEM,J/INDLP			;GET INDIRECT POINTER, EVAL
TAKINT:	ARX_MEM,TAKE INTRPT		;INTERRUPT DURING INDIRECT

;APPARENTLY  A INDRCT  AT COMPEA+2/+3 CAN
; CAUSE AR AS WELL AS ARX TO BE CLOBBERED BY ARX_MEM.
;HENCE WE MUST RESTORE THE -1 THAT THE  SOJ  SERIES DEPENDS ON.

INDLP:	EA MOD DISP,AR_1S,J/COMPEA	;EVALUATE POINTER
.TOC	"WAIT FOR (E)"

;THE EXECUTE CODE FOR EACH INSTRUCTION IS ENTERED WITH
; THE OPCODE AND AC # IN BRX AND IR, THE LAST INDIRECT WORD
; IN ARX, AND AR AND VMA SETUP AS A FUNCTION OF THE A
; FIELD OF THE DISPATCH RAM. A PREFETCH IS IN PROGRESS IF THE
; DRAM A FIELD WAS 1 OR 5 (OR IF IR CONTAINS "JRST 0,").

;ON "A READ", THE HARDWARE DISPATCHES TO THE EXECUTE CODE FOR
; THE INSTRUCTION IF THE DRAM A FIELD IS 0 OR 1.  IF THE A FIELD
; CONTAINS 2-7, THE HARDWARE DISPATCHES TO 40+A, BELOW:

;COME HERE ON "A READ" FUNCTION IF DRAM A FIELD IS 3
; A "WRITE TST" IS IN PROGRESS

43:	BR/AR,AR_AC0,MB WAIT,		;WAIT FOR PERMISSION TO WRITE
		TIME/3T,IR DISP,J/0	;AND GO TO EXECUTE CODE

;HERE ON "A READ" FUNCTION IF DRAM A FIELD IS 4
; A "LOAD AR" IS IN PROGRESS

44:	BR/AR,AR_MEM,TIME/3T,		;GET OPERAND
		IR DISP,J/0		; START EXECUTE

;HERE ON "A READ" IF A FIELD IS 5
; A "LOAD AR" IS IN PROGRESS, AND WE MUST PREFETCH WHEN IT COMPLETES

45:	BR/AR,FIN XFER,I FETCH,		;GET OPERAND, PREFETCH,
		TIME/3T,IR DISP,J/0	; & START EXECUTE

;HERE ON "A READ" IF A FIELD IS 6
; A "LOAD AR" IS IN PROGRESS, BUT PAGING IS TESTING WRITABILITY

46:	BR/AR,AR_MEM,TIME/3T,		;GET OPERAND
		IR DISP,J/0		; START EXECUTE

;HERE ON "A READ" IF A FIELD IS 7
; A "READ-PAUSE-WRITE" IS IN PROGRESS

47:	BR/AR,AR_MEM,TIME/3T,		;GET OPERAND
		IR DISP,J/0		; START EXECUTE
.TOC	"TERMINATION"

;DISPATCH HERE WITH THE "EXIT" MACRO,
; OR JUMP DIRECTLY TO ONE OF THESE LOCATIONS.

=11*000
ST0:					;BASE FOR B DISP IN EXIT MACRO
=001
ST2AC:	AC0_AR,AR_SIGN,I FETCH,J/STD1	;HERE TO STORE AC0 & AC1
	FIN STORE,EXIT DBL		;MULB, DIVB, ETC ...
	FIN STORE,I FETCH,		;SELF MODE
		SKP AC#0,J/STSELF	; RESULT TO AC TOO?
=101
STAC:	AC0_AR,NXT INSTR		;NORMAL AND IMMEDIATE MODES
ST6:
IFNOP:
STMEM:	FIN STORE,I FETCH,J/NOP		;MEM MODE
IFSTAC:
STBOTH:	FIN STORE,I FETCH,J/STORAC	;BOTH MODE
=
;HERE TO FINISH, AFTER FETCHING NEXT INSTRUCTION.
; WE MUST GUARANTEE AT LEAST ONE EBOX CYCLE BETWEEN FETCH AND NICOND,
; TO ALLOW VMA AC REF TO MAKE IT THROUGH THE NICOND LOGIC.
=11***0
STSELF:					;SKIP, AOS, SOS COME HERE
STORAC:	SR_0,J/STAC			;STORE AC, TOO
NOP:	J/FINI				;DELAY THEN NXT INSTR

.IF/JPC SUPPORT
=11*110
NJPCP:	AR_PC,SKP USER,J/JPCEX		;FOR JPC HACK - SKIP IF NOT JUMPING
.ENDIF/JPC SUPPORT
FINI:	SR_0,NXT INSTR			;GET NEXT INSTR IN ARX & IR,
					; LOAD PC, TEST PI CYCLE, RUN,
					; PI READY, TRAPS

;HERE TO STORE ARITHMETIC DOUBLE RESULTS

DSTAC:	AC0_AR,AR_SIGN			;HERE WITH FETCH STARTED
STD1:	AR_SHIFT,SR_0			;BRING IN LOW PART
STAC1:	AC1_AR,NXT INSTR AFTER AC1	;STORE AC1


;HERE TO GET MICRO-CODE VERSION #.  FIXED LOC'N SO SOFTWARE CAN FIND IT
137:
UVERS:	BR/AR,AR0-8_#,#/VERS,J/GTAR08	;COPY VERSION TO AR
.TOC	"MOVE GROUP, EXCH, BLT"

	.DCODE
200:	R-PF,	AC,	J/MOVE	;BASIC MOVE
	I-PF,	AC,	J/MOVE
.IF/WRTST
	W,	M,	J/MOVE
.IFNOT/WRTST
	I,	B/1,	J/MOVEM
.ENDIF/WRTST
	RPW,	S,	J/MOVE

204:	R-PF,	AC,	J/MOVS
	I-PF,	AC,	J/MOVS
	W,	M,	J/MOVS
	RPW,	S,	J/MOVS

210:	R-PF,	AC,	J/MOVN
	I-PF,	AC,	J/MOVN
	W,	M,	J/MOVN
	RPW,	S,	J/MOVN

214:	R-PF,	AC,	J/MOVM
	I-PF,	AC,	J/MOVM
	W,	M,	J/MOVM
	RPW,	S,	J/MOVM
	.UCODE

; ENTER WITH 0,E, (E), OR (AC) IN AR

=00****
MOVS:	AR_AR SWAP,EXIT			;ALSO USED BY HALFWORD GROUP
=
=00****
MOVM:	BR/AR,SKP AR0,J/MOVE		;FORCE POSITIVE
=
=00****
MOVN:	BR/AR,J/MOVNEG			;GET NEGATIVE
=
=00*000
MOVE:	EXIT				;STORE AS IS FROM AR
MOVNEG:	AR_-BR,AD FLAGS,FETCH WAIT,J/MOVE

;EXCH, BLT

	.DCODE
250:	RPW,	B/0,	J/EXCH
	I,		J/BLT
	.UCODE

=00***0
MOVEM:					;LIKE EXCH, EXCEPT NO STORE AC
EXCH:	ARX_AR,AR_AC0,STORE,J/STMAC	;PUT AC AT E, THEN STORE AC

BLT:	MQ_AR,ARX_AR,			;END ADDR TO MQ & ARX
		ARR_AC0,ARL_ARL,J/BLT1	;FIRST DEST ADDR TO AR
.TOC	"HALFWORD GROUP"
;	DESTINATION LEFT HALF

	.DCODE
500:	R-PF,	AC,	J/HLL
	I-PF,	AC,	J/HLL
	RPW,	M,	J/HRR		;HLLM = HRR EXCEPT FOR STORE
	RPW,	S,	J/MOVE		;HLLS = MOVES

	R-PF,	AC,	J/HRL
	I-PF,	AC,	J/HRL
	RPW,	M,	J/HRLM
	RPW,	S,	J/HRLS

510:	R-PF,	AC,	J/HLLZ
	I-PF,	AC,	J/HLLZ
	W,	M,	J/HLLZ
	RPW,	S,	J/HLLZ

	R-PF,	AC,	J/HRLZ
	I-PF,	AC,	J/HRLZ
	W,	M,	J/HRLZ
	RPW,	S,	J/HRLZ

520:	R-PF,	AC,	J/HLLO
	I-PF,	AC,	J/HLLO
	W,	M,	J/HLLO
	RPW,	S,	J/HLLO

	R-PF,	AC,	J/HRLO
	I-PF,	AC,	J/HRLO
	W,	M,	J/HRLO
	RPW,	S,	J/HRLO

530:	R-PF,	AC,	J/HLLE
	I-PF,	AC,	J/HLLE
	W,	M,	J/HLLE
	RPW,	S,	J/HLLE

	R-PF,	AC,	J/HRLE
	I-PF,	AC,	J/HRLE
	W,	M,	J/HRLE
	RPW,	S,	J/HRLE
;	DESTINATION RIGHT HALF

540:	R-PF,	AC,	J/HRR
	I-PF,	AC,	J/HRR
	RPW,	M,	J/HLL		;HRRM = HLL EXCEPT FOR STORE
	RPW,	S,	J/MOVE		;HRRS = MOVES

	R-PF,	AC,	J/HLR
	I-PF,	AC,	J/HLR
	RPW,	M,	J/HLRM
	RPW,	S,	J/HLRS

550:	R-PF,	AC,	J/HRRZ
	I-PF,	AC,	J/HRRZ
	W,	M,	J/HRRZ
	RPW,	S,	J/HRRZ

	R-PF,	AC,	J/HLRZ
	I-PF,	AC,	J/HLRZ
	W,	M,	J/HLRZ
	RPW,	S,	J/HLRZ

560:	R-PF,	AC,	J/HRRO
	I-PF,	AC,	J/HRRO
	W,	M,	J/HRRO
	RPW,	S,	J/HRRO

	R-PF,	AC,	J/HLRO
	I-PF,	AC,	J/HLRO
	W,	M,	J/HLRO
	RPW,	S,	J/HLRO

570:	R-PF,	AC,	J/HRRE
	I-PF,	AC,	J/HRRE
	W,	M,	J/HRRE
	RPW,	S,	J/HRRE

	R-PF,	AC,	J/HLRE
	I-PF,	AC,	J/HLRE
	W,	M,	J/HLRE
	RPW,	S,	J/HLRE

	.UCODE
;FIRST, THE 16 OPS WHICH DO NOT AFFECT THE "OTHER" HALF.
;THESE MUST BE TREATED SEPARATELY, BECAUSE THEY COMBINE MEMORY DATA
;IN AR WITH DATA FROM THE FM.  ENTER WITH 0,E OR (E) IN AR.

=00***0
HRR:	ARL_AC0,ARR_ARR,EXIT		;HRR, HRRI, HLLM
=00****
HLL:	ARR_AC0,ARL_ARL,EXIT		;HLL, HLLI, HRRM
=			;HRRS, HLLS ARE BOTH EQUIVALENT TO MOVES
=00****
HRL:	ARL_ARR,ARR_AC0,EXIT		;HRL, HRLI
=
=00****
HLR:	ARR_ARL,ARL_AC0,EXIT		;HLR, HLRI
=
=00***0
HRLM:	ARL_ARR,ARR_AC0,J/MOVS		;HRLM
HRLS:	ARL_ARR,ARR_ARR,EXIT		;HRLS
=
=00***0
HLRM:	ARR_ARL,ARL_AC0,J/MOVS		;HLRM
HLRS:	ARR_ARL,ARL_ARL,EXIT		;HLRS
=
;NOW THE HALFWORD OPS WHICH CONTROL THE "OTHER" HALF
; ENTER WITH 0,E, (E), OR (AC) IN AR

=00****
HRRE:	SKP AR18			;SELECT HRRZ OR HRRO ON SIGN
=
=00***0
HRRZ:	ARL_0S,ARR_ARR,EXIT
HRRO:	ARL_1S,ARR_ARR,EXIT
=
=00****
HRLE:	SKP AR18
=
=00***0
HRLZ:	ARL_ARR,ARR_0S,EXIT
HRLO:	ARL_ARR,ARR_1S,EXIT
=
=00****
HLRE:	SKP AR0
=
=00***0
HLRZ:	ARR_ARL,ARL_0S,EXIT
HLRO:	ARR_ARL,ARL_1S,EXIT
=
=00****
HLLE:	SKP AR0
=
=00***0
HLLZ:	ARR_0S,ARL_ARL,EXIT
HLLO:	ARR_1S,ARL_ARL,EXIT
=
.TOC	"DMOVE, DMOVN, DMOVEM, DMOVNM"
;DOUBLE-WORD MOVES

	.DCODE
120:	R,	B/0,	J/DMOVE
	R,	B/1,	J/DMOVN
	.UCODE

; ENTER WITH (E) IN AR
=00****
DMOVN:
DMOVE:	VMA_VMA+1,LOAD ARX,B DISP	;PICK UP (E+1)
=
=1**00
	ARX_MEM,J/STDAC			;GO STORE DOUBLE AC
	ARX_MEM,MQ_0.S,CALL.S,J/GTDBR	;LOAD BR WITH DOUBLE OPERAND
=11	AR_-BR LONG,AD FLAGS,		;NEGATE DOUBLE OPERAND
		SC_#,#/35.		;& STORE RESULT
DBLST:	AC0_AR,AR_0S,I FETCH,J/STD1	;STORE HIGH WORD, READY LOW


;DOUBLE MOVES TO MEMORY

	.DCODE
124:	W,		J/DMOVEM
	W,		J/DMOVNM
	.UCODE

;ENTER WITH (AC) IN AR
=00**00
DMOVEM:	ARX_AC1,STORE,SC_#,#/36.,J/DMVM1
DMOVNM:	ARX_AC1,MQ_0.S,CALL.S,J/GTDBR	;HIGH WORD IS ALREADY IN AR
=11	AR_-BR LONG,AD FLAGS,		;NEGATE
		STORE,SC_#,#/35.	; & STORE
=
DMVM1:	MEM_AR,VMA_VMA+1,AR_0S
	AR_SHIFT,STORE,J/STMEM

GTDBR:	ARX_ARX*2			;SHIFT OUT LOW SIGN
LDBRL:	BR_AR LONG,RETURN3		;COPY TO BR LONG
.TOC	"BOOLEAN GROUP"

	.DCODE
400:	I-PF,	AC,	J/SETZ
	I-PF,	AC,	J/SETZ
	IW,	M,	J/SETZ
	IW,	B,	J/SETZ
	.UCODE

=00****
SETZ:	AR_0S,EXIT
=
	.DCODE
404:	R-PF,	AC,	J/AND
	I-PF,	AC,	J/AND
	RPW,	M,	J/AND
	RPW,	B,	J/AND
	.UCODE

=00****
AND:	AR_AR*AC0,AD/AND,EXIT
=
	.DCODE
410:	R-PF,	AC,	J/ANDCA
	I-PF,	AC,	J/ANDCA
	RPW,	M,	J/ANDCA
	RPW,	B,	J/ANDCA
	.UCODE

=00****
ANDCA:	AR_AR*AC0,AD/ANDCB,EXIT
=
	.DCODE
414:	R-PF,	AC,	J/MOVE		;SETM = MOVE
	I-PF,	AC,	J/MOVE
	RPW,	M,	J/MOVE		;SETMM = NOP THAT WRITES MEMORY
	RPW,	B,	J/MOVE		;SETMB = MOVE THAT WRITES MEMORY

420:	R-PF,	AC,	J/ANDCM
	I-PF,	AC,	J/ANDCM
	RPW,	M,	J/ANDCM
	RPW,	B,	J/ANDCM
	.UCODE

=00****
ANDCM:	AR_AR*AC0,AD/ANDCA,EXIT
=
	.DCODE
424:	R-PF,		J/TDN
	I-PF,		J/TDN
	W,	M,	J/MOVE		;SETAM = MOVEM
	W,	M,	J/MOVE		;SETAB, TOO
	.UCODE
	.DCODE
430:	R-PF,	AC,	J/XOR
	I-PF,	AC,	J/XOR
	RPW,	M,	J/XOR
	RPW,	B,	J/XOR
	.UCODE

=00****
XOR:	AR_AR*AC0,AD/XOR,EXIT
=
	.DCODE
434:	R-PF,	AC,	J/IOR
	I-PF,	AC,	J/IOR
	RPW,	M,	J/IOR
	RPW,	B,	J/IOR
	.UCODE

=00****
IOR:	AR_AR*AC0,AD/OR,EXIT
=
	.DCODE
440:	R-PF,	AC,	J/ANDCB
	I-PF,	AC,	J/ANDCB
	RPW,	M,	J/ANDCB
	RPW,	B,	J/ANDCB
	.UCODE

=00****
ANDCB:	AR_AR*AC0,AD/ANDC,EXIT
=
	.DCODE
444:	R-PF,	AC,	J/EQV
	I-PF,	AC,	J/EQV
	RPW,	M,	J/EQV
	RPW,	B,	J/EQV
	.UCODE

=00****
EQV:	AR_AR*AC0,AD/EQV,EXIT
=
	.DCODE
450:	I-PF,	AC,	J/SETCA
	I-PF,	AC,	J/SETCA
	IW,	M,	J/SETCA
	IW,	B,	J/SETCA
	.UCODE

=00****
SETCA:	AR_AR*AC0,AD/SETCB,EXIT
=
	.DCODE
454:	R-PF,	AC,	J/ORCA
	I-PF,	AC,	J/ORCA
	RPW,	M,	J/ORCA
	RPW,	B,	J/ORCA
	.UCODE

=00****
ORCA:	AR_AR*AC0,AD/ORCB,EXIT
=
	.DCODE
460:	R-PF,	AC,	J/SETCM
	I-PF,	AC,	J/SETCM
	RPW,	M,	J/SETCM
	RPW,	B,	J/SETCM
	.UCODE

=00****
SETCM:	ADA/AR,AD/SETCA,AR/AD,EXIT
=
	.DCODE
464:	R-PF,	AC,	J/ORCM
	I-PF,	AC,	J/ORCM
	RPW,	M,	J/ORCM
	RPW,	B,	J/ORCM
	.UCODE

=00****
ORCM:	AR_AR*AC0,AD/ORCA,EXIT
=
	.DCODE
470:	R-PF,	AC,	J/ORCB
	I-PF,	AC,	J/ORCB
	RPW,	M,	J/ORCB
	RPW,	B,	J/ORCB
	.UCODE

=00****
ORCB:	AR_AR*AC0,AD/ORC,EXIT
=
	.DCODE
474:	I-PF,	AC,	J/SETO
	I-PF,	AC,	J/SETO
	IW,	M,	J/SETO
	IW,	B,	J/SETO
	.UCODE

=00****
SETO:	AR_1S,EXIT
=
