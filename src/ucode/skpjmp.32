.TOC	"TEST GROUP"

	.DCODE
600:	I-PF,		J/TDN		;TRN- IS NOP
	I-PF,		J/TDN		;SO IS TLN-
	I,	TNE,	J/TDXX
	I,	TNE,	J/TSXX
	I,	TNA,	J/TDX
	I,	TNA,	J/TSX
	I,	TNN,	J/TDXX
	I,	TNN,	J/TSXX

610:	I-PF,		J/TDN		;TDN- IS A NOP
	I-PF,		J/TDN		;TSN- ALSO
	R,	TNE,	J/TDXX
	R,	TNE,	J/TSXX
	R,	TNA,	J/TDX
	R,	TNA,	J/TSX
	R,	TNN,	J/TDXX
	R,	TNN,	J/TSXX

620:	I,	TZ-,	J/TDX
	I,	TZ-,	J/TSX
	I,	TZE,	J/TDXX
	I,	TZE,	J/TSXX
	I,	TZA,	J/TDX
	I,	TZA,	J/TSX
	I,	TZN,	J/TDXX
	I,	TZN,	J/TSXX

630:	R,	TZ-,	J/TDX
	R,	TZ-,	J/TSX
	R,	TZE,	J/TDXX
	R,	TZE,	J/TSXX
	R,	TZA,	J/TDX
	R,	TZA,	J/TSX
	R,	TZN,	J/TDXX
	R,	TZN,	J/TSXX

640:	I,	TC-,	J/TDX
	I,	TC-,	J/TSX
	I,	TCE,	J/TDXX
	I,	TCE,	J/TSXX
	I,	TCA,	J/TDX
	I,	TCA,	J/TSX
	I,	TCN,	J/TDXX
	I,	TCN,	J/TSXX

650:	R,	TC-,	J/TDX
	R,	TC-,	J/TSX
	R,	TCE,	J/TDXX
	R,	TCE,	J/TSXX
	R,	TCA,	J/TDX
	R,	TCA,	J/TSX
	R,	TCN,	J/TDXX
	R,	TCN,	J/TSXX
660:	I,	TO-,	J/TDX
	I,	TO-,	J/TSX
	I,	TOE,	J/TDXX
	I,	TOE,	J/TSXX
	I,	TOA,	J/TDX
	I,	TOA,	J/TSX
	I,	TON,	J/TDXX
	I,	TON,	J/TSXX

670:	R,	TO-,	J/TDX
	R,	TO-,	J/TSX
	R,	TOE,	J/TDXX
	R,	TOE,	J/TSXX
	R,	TOA,	J/TDX
	R,	TOA,	J/TSX
	R,	TON,	J/TDXX
	R,	TON,	J/TSXX
	.UCODE

;THESE 64 INSTRUCTIONS ARE DECODED BY MASK MODE (IMMEDIATE OR MEMORY)
; IN THE A FIELD, DISPATCH TO HERE ON THE J FIELD, AND RE-DISPATCH
; FOR THE MODIFICATION ON THE B FIELD.

; ENTER WITH 0,E OR (E) IN AR, B FIELD BITS 1 AND 2 AS FOLLOWS:
; 0 0	NO MODIFICATION
; 0 1	ZEROS
; 1 0	COMPLEMENT
; 1 1	ONES
;   THIS ORDER HAS NO SIGNIFICANCE EXCEPT THAT IT CORRESPONDS TO THE
;   ORDER OF INSTRUCTIONS AT TGROUP.

;THE HIGH ORDER BIT OF THE B FIELD (B0) IS XOR'D WITH AD CRY0 TO
;   DETERMINE THE SENSE OF THE SKIP:
; 0	SKIP IF CRY0=1 (TXX- AND TXXN)
; 1	SKIP IF CRY0=0 (TXXA AND TXXE)

=00*000
TDX:	TEST FETCH,NO CRY,		;TDXA AND TRXA
		B DISP,J/TDN

TSX:	AR_AR SWAP,TEST FETCH,NO CRY,	;TSX, TSXA, TLX, AND TLXA
		B DISP,J/TDN

TSXX:	AR_AR SWAP			;TSXE, TSXN, TLXE, AND TLXN

TDXX:	TEST AR.AC0,TEST FETCH,B DISP	;TDXE, TDXN, TRXE, AND TRXN

TDN:	J/FINI				;NO MODIFICATION
TDZ:	AR_AR*AC0,AD/ANDCA,TIME/2T,J/STAC	;ZEROS
TDC:	AR_AR*AC0,AD/XOR,TIME/2T,J/STAC		;COMP
TDO:	AR_AR*AC0,AD/OR,TIME/2T,J/STAC		;ONES
=
.TOC	"COMPARE -- CAI, CAM"

	.DCODE
300:	I,	SJC-,	J/CAIM	;CAI
	I,	SJCL,	J/CAIM
	I,	SJCE,	J/CAIM
	I,	SJCLE,	J/CAIM
	I,	SJCA,	J/CAIM
	I,	SJCGE,	J/CAIM
	I,	SJCN,	J/CAIM
	I,	SJCG,	J/CAIM

310:	R,	SJC-,	J/CAIM	;CAM
	R,	SJCL,	J/CAIM
	R,	SJCE,	J/CAIM
	R,	SJCLE,	J/CAIM
	R,	SJCA,	J/CAIM
	R,	SJCGE,	J/CAIM
	R,	SJCN,	J/CAIM
	R,	SJCG,	J/CAIM
	.UCODE

=00****
CAIM:	GEN AR*AC0,COMP FETCH,J/NOP
=
.TOC	"ARITHMETIC SKIPS -- AOS, SOS, SKIP"
;ENTER WITH (E) IN AR

	.DCODE
330:	R,	SJC-,	J/SKIP	;NOT A NOP IF AC .NE. 0
	R,	SJCL,	J/SKIP
	R,	SJCE,	J/SKIP
	R,	SJCLE,	J/SKIP
	R,	SJCA,	J/SKIP
	R,	SJCGE,	J/SKIP
	R,	SJCN,	J/SKIP
	R,	SJCG,	J/SKIP
	.UCODE

=00****
SKIP:	FIN STORE,SKIP FETCH,
		SKP AC#0,J/STSELF	;STORE IN SELF MODE
=

	.DCODE
350:	RPW,	SJC-,	J/AOS
	RPW,	SJCL,	J/AOS
	RPW,	SJCE,	J/AOS
	RPW,	SJCLE,	J/AOS
	RPW,	SJCA,	J/AOS
	RPW,	SJCGE,	J/AOS
	RPW,	SJCN,	J/AOS
	RPW,	SJCG,	J/AOS
	.UCODE

=00****
AOS:	AR_AR+1,AD FLAGS,STORE,J/SKIP
=

	.DCODE
370:	RPW,	SJC-,	J/SOS
	RPW,	SJCL,	J/SOS
	RPW,	SJCE,	J/SOS
	RPW,	SJCLE,	J/SOS
	RPW,	SJCA,	J/SOS
	RPW,	SJCGE,	J/SOS
	RPW,	SJCN,	J/SOS
	RPW,	SJCG,	J/SOS
	.UCODE

=00****
SOS:	AR_AR-1,AD FLAGS,STORE,J/SKIP
=
.TOC	"CONDITIONAL JUMPS -- JUMP, AOJ, SOJ, AOBJ"
; ENTER WITH E IN VMA

	.DCODE
320:	I,	SJC-,	J/JUMP
	I,	SJCL,	J/JUMP
	I,	SJCE,	J/JUMP
	I,	SJCLE,	J/JUMP
	I,	SJCA,	J/JUMP
	I,	SJCGE,	J/JUMP
	I,	SJCN,	J/JUMP
	I,	SJCG,	J/JUMP
	.UCODE

=00****
.IFNOT/JPC
JUMP:	AR_AC0,JUMP FETCH,J/NOP
.IF/JPC
JUMP:	AR_AC0,JUMP FETCH,B DISP,J/JMPJPC
.ENDIF/JPC
=

	.DCODE
340:	I,	SJC-,	J/AOJ
	I,	SJCL,	J/AOJ
	I,	SJCE,	J/AOJ
	I,	SJCLE,	J/AOJ
	I,	SJCA,	J/AOJ
	I,	SJCGE,	J/AOJ
	I,	SJCN,	J/AOJ
	I,	SJCG,	J/AOJ
	.UCODE

=00****
.IFNOT/JPC
AOJ:	AR_AC0+1,AD FLAGS,JUMP FETCH,J/STORAC
.IF/JPC
AOJ:	AR_AC0+1,AD FLAGS,JUMP FETCH,J/AOJJPC
.ENDIF/JPC
=

	.DCODE
360:	I,	SJC-,	J/SOJ
	I,	SJCL,	J/SOJ
	I,	SJCE,	J/SOJ
	I,	SJCLE,	J/SOJ
	I,	SJCA,	J/SOJ
	I,	SJCGE,	J/SOJ
	I,	SJCN,	J/SOJ
	I,	SJCG,	J/SOJ
	.UCODE

;THE BASIC INSTRUCTION DISPATCH LOADS MQ WITH -1
;SO THAT WHEN WE GET HERE WE CAN ADD -1 TO THE AC IN
;A SINGLE MICRO-INSTRUCTION.
=00****
.IFNOT/JPC
SOJ:	AR_MQ+AC0,AD FLAGS,JUMP FETCH,J/STORAC
.IF/JPC
SOJ:	AR_MQ+AC0,AD FLAGS,JUMP FETCH,J/SOJJPC
.ENDIF/JPC
=
	.DCODE
252:	I,	SJCGE,	J/AOBJ
	I,	SJCL,	J/AOBJ
	.UCODE

=00****
.IFNOT/JPC
AOBJ:	AR_AC0+1,GEN CRY18,JUMP FETCH,J/STORAC
.IF/JPC
AOBJ:	AR_AC0+1,GEN CRY18,JUMP FETCH,J/AOBJPC
.ENDIF/JPC
=
.TOC	"AC DECODE JUMPS -- JRST, JFCL"

	.DCODE
254:	I,	J/JRST		;DISPATCHES TO 1 OF 16 ON AC BITS
	I,TNN,	J/JFCL
	.UCODE

;A READ DETECTS JRST, AND DISPATCHES TO ONE OF 16 LOC'NS ON AC BITS

600:				;DRAM REQUIRES JRST AT MULTIPLE OF 200
.IFNOT/JPC
JRST:	J/FINI				;(0) A READ PREFETCHES ON JRST 0,
.IF/JPC
JRST:	AR_PC,SKP USER,			;(0) A READ PREFETCHES - GO STORE JPC
		SC_#,#/32.,J/JPCEX
.ENDIF/JPC
601:
.IFNOT/ITSPAGE
	PORTAL,BR/AR,J/BRJMP		;(1) PORTAL
.IF/ITSPAGE
	BR/AR,J/BRJMP			;(1) NO PUBLIC PAGES => NO PORTAL
.ENDIF/ITSPAGE
602:
JRST2:	EA MOD DISP,BR/AR,AR_ARX,	;(2) JRSTF
		SC_#,#/9,J/JRSTF
603:	J/UUO				;(3)
604:	HALT,SKP IO LEGAL,J/IHALT	;(4) HALT
605:	J/UUO				;(5)
606:	J/UUO				;(6)
607:	J/UUO				;(7)
610:	DISMISS,BR/AR,J/BRJMP		;(10)
611:	J/UUO				;(11)
612:	DISMISS,J/JRST2			;(12) JEN
613:	J/UUO				;(13)
614:	J/UUO				;(14)
615:	J/UUO				;(15)
616:	J/UUO				;(16)
617:
.IFNOT/JRSTON
	J/UUO				;(17)
.IF/JRSTON
JRST17:	BR/AR,BRX/ARX,AR_1,GEN CRY18,	;(17) JRSTON
		ARX/AD,SC_#,#/7,J/JRSTON
.ENDIF/JRSTON

;JRST AND RESTORE FLAGS HAIR

=11***0
JRSTF:	AR_PC,RSTR FLAGS_AR,J/JRSTF1	;RESTORE FROM INDIRECT WORD
	AR_XR,J/JRSTF			;INDEXED, RESTORE FROM REGISTER

;JRST AND RESTORE FLAGS HAIR - ONE-PROCEED VERSION.
;WE HAVE TO PREVENT JRSTF FROM TURNING OFF THE TRAP FLAGS.
;THIS MAKES ONE-PROCEED THROUGH JRST 2, WORK.
;IT DOESN'T HURT ANYTHING BECAUSE THE TRAP FLAGS NEVER NORMALLY
;STAY ON DURING EXECUTION OF AN INSTRUCTION.
;MUST COME TO JRSTF WITH 9 IN SC DUE TO DISP/SPEC & # CONFLICT.
;
;EVEN GROSSER HAIR- IF WE TOOK A PAGE FAULT ON THE INSTRUCTION
;FETCH AT THE NICOND, COULD DO AN ABORT INSTR AND LOSE THE
;TRAP FLAGS.  MOSTLY THIS SCREWS ONE-PROCEED, BUT IT COULD
;SCREW OVERFLOW TRAPS IF INTERRUPTED OUT OF THEN THE PAGE
;SWAPPED OUT BEFORE PROGRAM RESUMED.
;TO FIX THIS WE DO 'SR_JRSTF' AND LET THE INSTRUCTION
;CLEAN-UP HANDLER TAKE CARE OF THE FLAGS.

;YET GROSSER HAIR! IN ORDER TO STORE THE RIGHT JPC,
;JRSTF DOES AR_PC AND THEN THE USER MODE FLAG IN THERE
;IS CHECKED, SINCE THE ONE IN THE HARDWARE HAS BEEN
;CLOBBERED BY THIS TIME.  TO AVOID USING # TO DO THIS,
;JRSTF1 HAS TO PUT 1 INTO SC (USER = PC BIT 05 = LOW P BIT)

.IFNOT/ONE PROCEED
JRSTF1:	SR_JRSTF,SC_1,J/BRJRF
.IF/ONE PROCEED
JRSTF1:	SR_JRSTF,SC_1,SH DISP,J/BRJRF	;DISPATCH ON OLD TRAP BITS
=1*0011
.ENDIF/ONE PROCEED
.IFNOT/JPC
BRJRF:
BRJMP:	VMA_BR,FETCH,J/NOP
.IF/JPC
BRJRF:	VMA_BR,FETCH,GEN P AND SC,SKP SCAD NE,J/JPCEX
.ENDIF/JPC
.IF/ONE PROCEED		;DISP TABLE AFTER BRJRF
	TRAP1,J/BRJRF			;TURN TRAP 1 BACK ON
	TRAP2,J/BRJRF			;TURN TRAP 2 BACK ON
	TRAP3,J/BRJRF			;TURN TRAP 3 BACK ON
.ENDIF/ONE PROCEED
.IF/JPC
BRJMP:	VMA_BR,FETCH,J/JPCIFY
.ENDIF/JPC

.IF/JRSTON
;OKAY TO DO THIS INSTR IN USER MODE, SINCE WHEN IN
; USER MODE THE PI SYSTEM SHOULD BE ON ANYWAY.
;THIS INSTRUCTION IS USEFUL IN CONJUNCTION WITH THE
; PFAIL.PIHACK BUSINESS.
=*1**00
JRSTON:	AR_SHIFT,ARX_BRX,REQ EBUS,CALL,J/WGRANT	;GOBBLE EBUS
=11	CONO PI				;TURN ON PI SYSTEM
.IF/ONE PROCEED
	SC_#,#/9			;SET UP SC FOR JRSTF
.ENDIF/ONE PROCEED
	REL EBUS,AR_ARX,		;RELEASE EBUS, THEN
		EA MOD DISP,J/JRSTF	; GO DO A JRSTF
.ENDIF/JRSTON


700:					;JFCL MUST BE AT JRST+100
JFCL:	ARX_BRX,SC_#,#/13.		;GET BACK AC FIELD
=1***0*
	AR_SHIFT,ARX_0S,		;MOVE AC TO AR32-35
		SC_#,#/32.,CALL,J/SHIFT	;SHIFTER WILL MOVE TO 0-3
	BR/AR,AR_PC,JFCL T		;GET PC FLAGS INTO AR
.IFNOT/JPC
	TEST AR.BR,JFCL FETCH		;JUMP IF TEST SATISFIED
	AR_AR*BR,AD/ANDCB		;CLEAR TESTED FLAGS IN AR
	JFCL S,J/FINI			;SET PC FROM THEM
.IF/JPC
	ARX_AR*BR,AD/ANDCB,SC_#,#/32.	;SET UP SC FOR JPC RING
	TEST AR.BR,JFCL FETCH,AR_ARX,SKP CRY0
=*1***0
	JFCL S,J/FINI			;NO JUMP, ALL DONE
	JFCL S,AR_PC,SKP USER,J/JPCEX	;JUMP, GO RECORD JPC
.ENDIF/JPC
.TOC	"HALT LOOP"
;HERE WHILE PROCESSOR IS "HALTED"

1016:
UUO107:					;OP 107 COMES HERE
IHALT:	J/UUO				;HERE IF HALT IN USER/SUPER MODE
1017:
DHALT:	AR_0S,SET HALTED,		;KERNEL OR CONSOLE HALT
		VMA/PC,PC_VMA		; IF JRST 4, COPY EA TO PC
=1****0
HALT1:	SKP -START,TIME/3T,		;CHECK FOR CONTINUE BUTTON
		FE_AR0-8,ARX_AR,J/HALT2	;PICK UP OPCODE IN CASE XCT
	TAKE INTRPT			;HERE IF EXAMINE/DEPOSIT UP
=1****0
HALT2:	GEN FE-1,BYTE DISP,CONTINUE,J/UNHALT	;INSTR FROM SWITCHES?
	SKP INTRPT,J/HALT1
=110
UNHALT:	SET CONS XCT,J/UXCT		;XCT ONE FROM "SWITCHES"
	SKP AR EQ,J/START		;NOT AN INSTR.  START, OR CONT?


.TOC	"MAP, XCT"

	.DCODE
256:	R,		J/XCT	;OPERAND FETCHED AS DATA
.IF/MAP
	I,	AC,	J/MAP
.IFNOT/MAP
	J/UUO
.ENDIF/MAP
	.UCODE

.IF/MAP
=00***0
.IFNOT/MAP
1001:			;GET XCT NEAR UUO
.ENDIF/MAP
.IFNOT/XCTR
XCT:	SKP INTRPT,J/XCT1		;CHECK FOR XCT . LOOP
.IF/XCTR
XCT:	SKP INTRPT,J/UXCT		;CHECK FOR XCT LOOP
.ENDIF/XCTR

.IF/MAP
MAP:	MAP,BR/AR			;MAP E, GO READ BACK EBRG
=
.IF/KLPAGE				;IN KL PAGING MODE,
	SR_MAP				;MAP CAN PAGE FAIL
.ENDIF/KLPAGE
.IFNOT/MAP
.IFNOT/XCTR
=
.ENDIF/XCTR
.ENDIF/MAP
=11***0
RDEBRG:	AR_0S,SKP IO LEGAL,MB WAIT,	;FINISH READ REG FUNC
		CALL,J/GETEEB		;AND GET EBUS
	AR_EBUS REG			;READ DATA
	REL ECL EBUS,B WRITE,J/ST6	;GIVE IT TO USER
.TOC	"ITS PAGE MAP INSTRUCTIONS -- LPM, SPM"

;THE WORDS LOADED OR STORED BY LPM AND SPM ARE AS FOLLOWS:
;	(E)	JPC (OR JPC RING POINTER)
;	(E+1)	ADDRESS BREAK WORD
;	(E+2)	PFW AS OF MOST RECENT PAGE FAIL
;	(E+3)	DBR1
;	(E+4)	DBR2

.IF/LPM.SPM
=00**00
LPM:	ARX_AR,VMA_VMA+1,LOAD AR,J/LPM1	;ARX_JPC,FETCH MAR

=10
SPM:	CALL,SKP KERNEL,J/IOCHK	;SPM OKAY ONLY IN KERNEL MODE
.IFNOT/JPC SUPPORT
	VMA_VMA+1
=
.IF/JPC SUPPORT
	AR_JPC,STORE
=	MEM_AR,VMA_VMA+1
.ENDIF/JPC SUPPORT
	AR_UPFW,STORE,VMA_VMA+1
	MEM_AR,VMA_VMA+1
	AR_DBR1,STORE
	MEM_AR,VMA_VMA+1
	AR_DBR2,STORE,J/STMEM

=11***0
LPM1:	AR_MEM,CALL,SKP KERNEL,J/GETEEB	;LPM LEGAL ONLY IN KERNEL MODE
	DATAO APR
	REL ECL EBUS,AR_ARX
.IF/JPC SUPPORT
	JPC_AR
.ENDIF/JPC SUPPORT
	VMA_VMA+1,LOAD AR
	AR_MEM,VMA_VMA+1
	BAG-BITING NO-OP
	UPFW_AR,LOAD AR
	AR_MEM,VMA_VMA+1
	BAG-BITING NO-OP
	DBR1_AR,LOAD AR
	AR_MEM
	BAG-BITING NO-OP
	DBR2_AR,J/CLRPT1		;REALLY LPMR - CLEAR PAGE TABLE
.ENDIF/LPM.SPM
.TOC	"STACK INSTRUCTIONS -- PUSHJ, PUSH, POP, POPJ"

	.DCODE
260:	I,	J/PUSHJ
	R, B/0,	J/PUSH
	W,	J/POP
	I,	J/POPJ
	.UCODE

;PUSHJ
; ENTER WITH E IN AR
;PUSH
; ENTER WITH (E) IN AR

=00***0
PUSH:	ARX_AC0+1,GEN CRY18,SKP CRY0,	;BUMP BOTH HALVES OF AC,
		VMA/AD,STORE,J/STMAC	;PUT AR ONTO LIST

PUSHJ:	BR/AR,AR_PC+1			;SAVE JUMP ADDR, GET PC
=	ARX_AC0+1,GEN CRY18,SKP CRY0,	;COMPUTE STACK ADDRESS
		VMA/AD,STORE,J/JSTAC	;AND PREPARE TO STORE PC
=*1**00
JRA1:	VMA_AR,LOAD ARX,CALL,J/XFERW	;GET SAVED AC
=10
.IFNOT/JPC
JSTAC:	FIN STORE,VMA_BR,FETCH,		;STORE PC, JUMP ADDR TO VMA
		AR_ARX,J/STORAC		;PREPARE TO STORE AC VALUE
.IF/JPC
JSTAC:	FIN STORE,VMA_BR,FETCH,		;STORE AC, THEN RECORD JPC
		AR_ARX,SKP USER,J/JPCSTO
.ENDIF/JPC
	MEM_AR,TRAP2,J/JSTAC		;CAUSE PDL OVRFLO

=1****0
STMAC:	FIN STORE,I FETCH,		;STORE RESULT, GET NEXT INSTR
		AR_ARX,B DISP,J/STSELF	;STORE AC IF B=0
	MEM_AR,TRAP2,			;PDL OVFLO, CAUSE TRAP
		AR_ARX,J/IFSTAC		;UPDATE AC BEFORE TRAPPING


;POP, POPJ

=00***0
;ENTER WITH C(AC) IN AR, E IN BR, OK TO WRITE IN E
POP:	VMA_AR,LOAD ARX,J/POP1		;BEGIN DATA FETCH FROM STACK

;ENTER WITH E IN AR
POPJ:	AR_AC0,VMA/AD,LOAD ARX		;START FETCH FROM STACK
=	AR_AR-1,INH CRY18,SKP CRY0	;DECR STACK POINTER, CHECK UNDERFLOW
.IFNOT/JPC.RING
=*1***0
	ARX_MEM,TRAP2,J/POPJ1		;UNDERFLOW OCCURRED
	ARX_MEM				;GET STACK WORD
.IFNOT/JPC
POPJ1:	AC0_AR,VMA_ARX,FETCH,J/NOP	;SET NEW AC VALUE, JUMP
.IF/JPC
POPJ1:	AC0_AR,VMA_ARX,FETCH,J/JPCIFY
.ENDIF/JPC
.IF/JPC.RING
=*1***0
	ARX_MEM,TRAP2			;TWO TICKS SLOWER ON OVERFLOW, BUT WHO CARES?
	ARX_MEM,SKP USER,SC_#,#/32.	;JPC.RING NEEDS 32. IN SC
	AC0_AR,VMA_ARX,FETCH,J/JPCEX
	AC0_AR,VMA_ARX,FETCH,J/JPCUSR
.ENDIF/JPC.RING


POP1:	AR_AR-1,INH CRY18,SKP CRY0	;ADJUST POINTER, CHECK TRAP
=*1***0
	ARX_MEM,TRAP2			;PDL OVFLO, CAUSE TRAP
	ARX_MEM,SR_#,#/100		;SET DEST CONTEXT FLAG
	AR_ARX,AC0_AR,			;FIRST STORE AC
		VMA_BR,STORE,J/STMEM	;THEN MEMORY

	;PUT RESULT AWAY, THEN AC
.TOC	"SUBROUTINE CALL/RETURN -- JSR, JSP, JSA, JRA"

	.DCODE
264:	I,		J/JSR
	I,		J/JSP
	I,		J/JSA
	I,		J/JRA
	.UCODE

=00***0
.IFNOT/JPC
JSP:	AR_PC+1,FETCH,J/STORAC
.IF/JPC
JSP:	AR_PC+1,FETCH,SKP USER,J/JPCSTO
.ENDIF/JPC

JSR:	AR_PC+1,STORE
=
.IFNOT/JPC
	FIN STORE,VMA_VMA+1,FETCH,J/NOP
.IF/JPC
	FIN STORE,VMA_VMA+1,FETCH,J/JPCIFY
.ENDIF/JPC

=00***0
JSA:	ARX_AR SWAP,AR_AC0,STORE,J/JSA1	;SAVE E IN ARX LEFT, GET AC

JRA:	BR/AR,AR_AC0			;GET AC, SAVE JUMP ADDR
=	ARR_ARL,ARL_0.M,J/JRA1		;GET AC LEFT

JSA1:	FIN STORE,VMA_VMA+1,FETCH	;JUMP TO E+1
.IFNOT/JPC
	ARR_PC+1,ARL_ARXL,J/STAC	;PC+1,,E GOES TO AC
.IF/JPC
	ARR_PC+1,ARL_ARXL,SKP USER,J/JPCSTO
.ENDIF/JPC
.TOC	"UUO'S"
;LUUO'S TRAP TO CURRENT CONTEXT
; EXTENDED INSTRUCTION SET IS "HIDDEN" BENEATH LUUO OPCODES

	.DCODE
000:	I,		J/UUO
.IF/EIS
	I,	SJCL,	J/L-CMS		;CMSL HIDDEN BENEATH LUUO
	I,	SJCE,	J/L-CMS
	I,	SJCLE,	J/L-CMS
	I,	B/2,	J/L-EDIT	;EDIT HIDDEN UNDER 004
	I,	SJCGE,	J/L-CMS
	I,	SJCN,	J/L-CMS
	I,	SJCG,	J/L-CMS

.IF/DECIMAL
010:	I,	B/1,	J/L-DBIN	;CVTDBO
	I,	B/4,	J/L-DBIN	;CVTDBT
	I,	B/1,	J/L-BDEC	;CVTBDO
	I,	B/0,	J/L-BDEC	;CVTBDT
.IFNOT/DECIMAL
010:	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO
.ENDIF/DECIMAL

014:	I,	B/1,	J/L-MVS		;MOVSO
	I,	B/0,	J/L-MVS		;MOVST
	I,	B/2,	J/L-MVS		;MOVSLJ
	I,	B/3,	J/L-MVS		;MOVSRJ
.IFNOT/EIS
	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO

004:	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO

010:	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO

014:	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO
	I,		J/LUUO
.ENDIF/EIS
;USER UUO'S 20-37

020:	I,	J/LUUO
	I,	J/LUUO
	I,	J/LUUO
	I,	J/LUUO

024:	I,	J/LUUO
	I,	J/LUUO
	I,	J/LUUO
	I,	J/LUUO

030:	I,	J/LUUO
	I,	J/LUUO
	I,	J/LUUO
	I,	J/LUUO

034:	I,	J/LUUO
	I,	J/LUUO
	I,	J/LUUO
	I,	J/LUUO
;MONITOR UUO'S -- TRAP TO EXEC

040:	I,	J/MUUO		;CALL
	I,	J/MUUO		;INIT
	I,	J/MUUO
	I,	J/MUUO
	I,	J/MUUO
	I,	J/MUUO
	I,	J/MUUO
	I,	J/MUUO		;CALLI
	I,	J/MUUO		;OPEN
	I,	J/MUUO		;TTCALL
	I,	J/MUUO
	I,	J/MUUO
	I,	J/MUUO
	I,	J/MUUO		;RENAME
	I,	J/MUUO		;IN
	I,	J/MUUO		;OUT
.IFNOT/JPC TEST
	I,	J/MUUO		;SETSTS
	I,	J/MUUO		;STATO
	I,	J/MUUO		;GETSTS
	I,	J/MUUO		;STATZ
	I,	J/MUUO		;INBUF
	I,	J/MUUO		;OUTBUF
	I,	J/MUUO		;INPUT
	I,	J/MUUO		;OUTPUT
.IF/JPC TEST
	I,	SJC-,	J/TJMP
	I,	SJCL,	J/TJMP
	I,	SJCE,	J/TJMP
	I,	SJCLE,	J/TJMP
	I,	SJCA,	J/TJMP
	I,	SJCGE,	J/TJMP
	I,	SJCN,	J/TJMP
	I,	SJCG,	J/TJMP
.ENDIF/JPC TEST


.IFNOT/LISP
	I,	J/MUUO		;CLOSE
	I,	J/MUUO		;RELEAS
.IF/LISP
	I,	J/LSPGCM	;LSPGCM (OPCODE 070)
	I,	J/LSPGCS	;LSPGCS (OPCODE 071)
.ENDIF/LISP
	I,	J/MUUO		;MTAPE
	I,	J/MUUO		;UGETF
.IFNOT/XCTR
	I,	J/MUUO		;USETI
	I,	J/MUUO		;USETO
.IF/XCTR
	R,	J/PXCT		;PXCT FOR ITS (OPCODE 074)
	R,	J/PXCT		;PXCTI FOR ITS (OPCODE 075)
.ENDIF/XCTR
.IFNOT/LPM.SPM
	I,	J/MUUO		;LOOKUP
	I,	J/MUUO		;ENTER
.IF/LPM.SPM
	R,	J/LPM		;LOAD PAGE MAP (OPCODE 076)
	W,	J/SPM		;STORE PAGE MAP (OPCODE 077)
.ENDIF/LPM.SPM

;EXPANSION OPCODES

100:
.IFNOT/LISP
	I,	J/UUO		;UJEN
	I,	J/UUO
.IF/LISP
	I,	J/LSPDBG	;LSPDBG (OPCODE 100, TEMP)
	I,	J/LSP101
.ENDIF/LISP
	I,	J/UUO
	I,	J/UUO
	.UCODE
;HERE FOR UNDEFINED OPS (UUO'S) AND ILLEGAL INSTRUCTIONS
;E IS IN AR, OPCODE AND AC IN BRX

1002:					;FIXED ADDRESS TO COOPERATE
					;WITH EXTEND AND OTHER OPS
UUO:					;UNDEFINED OP'S .GE. 100
MUUO:	ARX_BRX,SC_#,#/13.,
		SKP INTRPT,CALL,J/ROTS
1003:	AR_SHIFT,VMA_#,#/424,J/MUUO1

;HERE ON LUUO'S
; E IN AR, INSTR IN BRX
1005:
.IFNOT/EIS
FIX:	FE_EXP-#,#/244,SKP SCAD0,	;GET BINARY POINT POSITION
		ARX_AR SIGN,J/FIX1	;SET ROUNDING CONSTANT, GO FIX
.IF/EIS
L-CMS:	J/LUUO				;LOC FOR HIDING STRING COMPARE
.ENDIF/EIS
1006:
.IF/EIS
L-EDIT:					;HIDE EDIT HERE
.ENDIF/EIS
LUUO:	ARX_BRX,SC_#,#/13.,
		CALL,SKP INTRPT,J/ROTS	;COMBINE E WITH UUO
1007:	AR_SHIFT,VMA_40,STORE		;STORE OPCODE ETC AT 40
	FIN STORE,VMA_41,
		LOAD ARX,J/XCTW		;GO PERFORM 41

.IF/EIS
.IF/DECIMAL
1010:
L-DBIN:	J/LUUO				;DBIN AT 2010
1011:
L-BDEC:	J/LUUO				;BDEC AT 2011
.ENDIF/DECIMAL
1012:
L-MVS:	J/LUUO				;MOVE STRING AT 2012
.ENDIF/EIS

.IF/JPC TEST
=00****
TJMP:	AR_AC0,JUMP FETCH,B DISP,J/JMPJPC
.ENDIF/JPC TEST

.IF/LISP
=00***0
LSPGCM:	BR/AR,MQ_AR,AR_GCSTBR,SKP AD NE,J/LGCM0	;START OF GC MARK INSTR
LSPGCS:	BR/AR,SC_EA,AR_GCSTBR,SKP AD NE,J/LGCS0	;START OF GC SWEEP INSTR
=
=00***0
LSPDBG:	AR_GCSTBR,J/LSPDB1
LSP101:	J/UUO
=
.ENDIF/LISP
;HERE ON MUUO'S
; E IN AR, OP AND AC IN BRX

;MUUO:	ARX_BRX,SC_#,#/13.,CALL,J/ROTS
;	AR_SHIFT,VMA_#,#/424
MUUO1:	STORE,UPT REF			;FIRST, STORE INSTRUCTION
	FIN STORE,AR_PC+1,VMA_VMA+1,STORE	;NEXT, PC
=11**00
	MEM_AR,VMA_VMA+1,SC_#,#/70,
		CALL,J/GTEEB1
	DATAI PAG(L),CALL,J/PCTXT	;GET PROCESS CONTEXT VARIABLES
=11	LD PREV CTXT			;PCS FROM PC, CWSX FROM SXCT
	AR_SHIFT,ARL_BRL.S,		;COMBINE UBR WITH AC BLKS, CWSX
		STORE,			; STORE THAT AT 426
		COND/EBUS CTL,EBUS CTL/2; & RELEASE ECL EBUS
	MEM_AR,VMA_430+MODE		;NOW READY TO GET NEW PC
	LOAD AR,UPT REF			;FETCH NEW PC
NEWPC:	AR_MEM,SR_0,J/START		;USE IT


;ROTATE SUBROUTINE

=11***0
ROTS:	AR_SHIFT,ARX_SHIFT,SC_#-SC,#/36.,RETURN3
	TAKE INTRPT		;FIXES LUUO IN USER 41 LOOP BUG
.TOC	"JSYS, ADJSP"

	.DCODE
104:
.IFNOT/MVSQZ
	I,		J/UUO		;JSYS
.IF/MVSQZ
	R,		J/MVSQZ
.ENDIF/MVSQZ
	I,	B/0,	J/ADJSP
	.UCODE

;HERE FOR ADJSP INSTRUCTION
; ENTER WITH E IN AR, PREFETCH IN PROGRESS

.IFNOT/MVSQZ
1000:					;PUT ADJSP NEXT TO UUO
.IF/MVSQZ
=00***0
MVSQZ:	FE_#,#/5,ARX_0S,MQ_MQ*.25,	;FE COUNTS LOOP, CLEAR MQ00,
		J/MVSQZ0		;ARX ACCUMULATES SQUOZE
.ENDIF/MVSQZ
ADJSP:	ARL_ARR,ARR_ARR			;PUT E IN BOTH HALVES
=	AR_AR*AC0,AD/A+B,INH CRY18,	;ADJUST POINTER,
		ARX/AD,SKP AR0		;SKIP IF NEGATIVE
=0	GEN AR*AC0,AD/ANDCA,		;TEST FOR - TO + CHANGE
		SKP AD0,J/STMAC
	GEN AR*AC0,AD/ANDCB,		;TEST FOR + TO - CHANGE
		SKP AD0,J/STMAC


.IF/MVSQZ
=1****0
MVSQZ0:	ARX_ARX*8,GEN P-#,#/41,
		SKP SCAD0,J/MVSQZ1
	AR_ARX,I FETCH,J/STORAC
=1****0
MVSQZ1:	P_P-#,#/26,ARX_ARX*5,J/MVSQZ5
	GEN P-#,#/20,ARX_ARX*5,
		SKP SCAD0
=1****0
	P_P-#,#/17,J/MVSQZ5
	GEN P-#,#/16,SKP SCAD NE
=1****0
	P_#,#/45,J/MVSQZ5
	GEN P-#,#/1,SKP SCAD0
=1****0
	P_P+#,#/42
MVSQZ5:	BR/AR,BRX/ARX,ARX_AR,AR_0S,SC_#,#/6
	ARX_SHIFT,AR_BR
	ARX_ARX+BRX,AR_SHIFT,
		FE_FE-1,SKP SCAD0,J/MVSQZ0
.ENDIF/MVSQZ
.TOC	"XCT, PXCT, SXCT"
;HERE FOR EXTENDED ADDRESSING INSTRUCTIONS

.IFNOT/XCTR
=1****0
XCT1:	SKP USER,J/PXCT			;HERE ON XCT, NO INTERRUPT
	TAKE INTRPT			;GET OUT OF LONG XCT CHAIN
=1****0
.IFNOT/XADDR
PXCT:	BR/AR,ARX_AR,SET PXCT,J/PXCTEA	;SETUP CONTROL FLOPS
.IF/XADDR
PXCT:	SET PXCT
.ENDIF/XADDR
UXCT:	ARX_AR (AD),LOAD IR,J/XCTGO,	;COPY INSTR TO ARX, IR
		TIME/3T			;MAYBE THIS WILL FIX SUSPECTED LOSSAGE?
.IF/XCTR
=00***0
PXCT:	CALL,SKP KERNEL,J/IOCHK		;XCTR OKAY ONLY IN KERNEL MODE
	SKP INTRPT,J/XCTR		;XCTR AND XCTRI

=*1***0
XCTR:	BR/AR,ARX_AR,SET PXCT,J/PXCTEA
	TAKE INTRPT
=*1***0
UXCT:	ARX_AR (AD),LOAD IR,J/XCTGO
	TAKE INTRPT
.ENDIF/XCTR

	.DCODE
.IFNOT/SXCT
106:	I,	J/UUO
	I,	J/UUO
.IF/SXCT	;NOTE: THE SXCT INSTRUCTION IS A TEMPORARY MECHANISM
106:	R,	J/SXCT		;INTENDED FOR DIAGNOSTICS ONLY
	I,	J/UUO107
.ENDIF/SXCT
	.UCODE

.IF/SXCT
1014:					;PUT NEXT TO UUO107
SXCT:	SKP KERNEL,CALL,J/IOCHK		;LEGAL IN KERNEL MODE ONLY
1015:	BR/AR,ARX_AR,AR_AC0,		;SHUFFLE INSTR TO GET BASE REG
		SET SXCT		;SETUP HARDWARE FLAGS
	SKP AC#0			;CHOOSE LOOP FOR EA CALC
=0	BR/AR,AR_BR,LOAD IR,		;AC0 IS BASE INDEX
		BRX/ARX,ARL_0.M,
		EA MOD DISP,J/SXCTB
.ENDIF/SXCT
;EXTENDED ADDRESSING CONTINUED

.IFNOT/XADDR
PXCTEA:	AR_BR,LOAD IR,ARL_0.M,		;GET EXT ADDR FROM XR OR INDRCT
		BRX/ARX,J/XIND2
=00
PXLOOP:	GEN AR,A READ			;GO DO INSTR
	AR_AR+XR,A READ
	GEN AR,A INDRCT,SKP INTRPT,J/XIND1
	GEN AR+XR,A INDRCT,SKP INTRPT

=1****0
XIND1:	AR_MEM,ARX_MEM,EA TYPE DISP,J/XIND2
	MB WAIT,TAKE INTRPT
=1***00
XIND2:	EA MOD DISP,J/PXLOOP		;CURRENT OR PREV WITHOUT CWSX
	AR_ARX (AD),A READ		;PREV AND CWSX
.IF/SXCT
	AR_ARX (AD),A READ		;SXCT 0,
	EA MOD DISP,J/SXCTB		;SXCT B,

=1***00
SXCTB:	AR_AR+BR,A READ			;GO
	AR_AR+XR,ARL_0.C,J/SXCTB	;NO MORE INDIRECTS
	GEN AR,A INDRCT,		;FOLLOW INDRCT POINTER
		SKP INTRPT,J/XIND1
	GEN AR+XR,A INDRCT,
		SKP INTRPT,J/XIND1
.ENDIF/SXCT
.ENDIF/XADDR
