.TOC	"LISP INSTRUCTIONS"

.IF/LISP
;;;	MARK:	LSPGCM A,FOO
;;; LISP GARBAGE COLLECTION MARK INSTRUCTION.
;;; IF THE GCSTBR IS NOT SET UP, BEHAVES AS A UUO (OPCODE 070).
;;; OTHERWISE, MARKS THE ITEM IN A IF POSSIBLE, THEN RETURNS
;;; TO ONE OF SEVERAL PLACES:
;;;	MARK-1	BOTH CAR AND CDR NEED MARKING (CAR IN A, CDR IN A+1)
;;;	MARK	ONE OF CAR OR CDR NEED MARKING (ITEM IN A)
;;;	MARK+1	ITEM ALREADY MARKED, OR NOT MARKABLE
;;;	FOO+N	BIT 4.8 WAS SET IN GCST TABLE (N=BITS 4.3-4.1),
;;;		INDICATING SOMETHING FUNNY LIKE A SYMBOL OR A SAR.

;TO HELP SEE WHAT'S GOING ON,			;AR	ARX	BR	BRX	MQ
; REGISTER CONTENTS AFTER EACH STEP ARE SHOWN	;------	-------	-------	-------	-------

;LSPGCM: BR/AR,MQ_AR,AR_GCSTBR,SKP AD NE,J/LGCM0	;START OF GC MARK INSTR
=0
LGCM0:	AR_BR,J/UUO			;GCSTBR NOT SET UP => UUO
	SC_#,#/44-SEGLOG,BR/AR,ARX_AC0,AR_0.C	;0	ITEM	GCSTBR		EFFADR
	ARX_SHIFT,AR_ARX (AD)			;ITEM	SEG#	GCSTBR		EFFADR
	VMA_ARX+BR,LOAD ARX,AR_SHIFT		;WD#_33	-LOAD-			EFFADR
	SC_AR0-8 AND #,#/37,BR/AR,AR_0.C	;0	-LOAD-	WD#_33		EFFADR
	ARX_MEM,AR0-8_#,#/400			;SETZ	TBLENT	WD#_33		EFFADR
	SKP ARX0,SC_#-SC,#/44,BRX/ARX		;SETZ	TBLENT	WD#_33	TBLENT	EFFADR
=0	I FETCH,J/NOP			;NOT MARKABLE => NEXT INSTRUCTION
	AR_ARX (AD),ARX_AR			;TBLENT	SETZ	WD#_33	TBLENT	EFFADR
	AR_0S,FE_AR0-8 AND #,
		#/207,SKP SCAD NE		;0	SETZ	WD#_33	TBLENT	EFFADR
;HERE FOR MARKABLE NON-FUNNY THINGS
=0	MQ_SHIFT,AR_BRX,ARX_BR,
		SC_#,#/SEGLOG-5,J/LGCM1		;TBLENT	WD#_33		TBLENT	MARKBIT
;HERE FOR MARKABLE FUNNY THINGS (SYMBOLS, ETC.)
	VMA_MQ,FE_FE-#,#/201,BYTE DISP
=110
LGCM3:	VMA_VMA+1,FE_FE-1,BYTE DISP,J/LGCM3	;LOOP TO GENERATE EFFADR+N
	FETCH,J/NOP

LGCM1:	ARX_SHIFT,AR_MQ			       ;MARKBIT	BITSADR		TBLENT
	BR/AR,VMA_ARX,LOAD AR			;-LOAD-		MARKBIT	TBLENT
	AR_MEM					;BITS		MARKBIT	TBLENT
	AD/AND,ADA/AR,ADB/BR,SKP AD NE
=0	I FETCH,J/NOP			;ALREADY MARKED
	AR_AR*BR,AD/ANDCB,STORE			;BITS\MARKBIT		TBLENT
	MEM_AR,AR_BRX				;TBLENT
	GEN # AND AR0-8,#/GCBCDR,SKP SCAD NE
=0	I FETCH,J/NOP			;DON'T MARK THROUGH
	VMA_AC0,LOAD ARX			;TBLENT	-LOAD-
	ARX_MEM,VMA/PC,GEN # AND AR0-8,
		#/GCBCAR,SKP SCAD NE		;	CARCDR
=0	ARL_0.S,ARR_ARXR,J/LGCM2		;ONLY MARK CDR
	ARL_0.S,ARR_ARXR,VMA_VMA-1		;0,,CDR	CARCDR
	ARX_AR (AD),SKP AD NE,ARR_0.S,ARL_ARXL	;0,,CAR	0,,CDR
=0	REFETCH,AR_AR SWAP,J/STAC	;CDR IS NIL => MARK ONLY CAR
	ARX_AR (AD),SKP AD NE,AR_ARX		;0,,CDR	0,,CAR
=0
LGCM2:	REFETCH,J/STAC			;CAR IS NIL => MARK ONLY CDR
	AC1_AR,AR_ARX
	AR_AR SWAP,FETCH,J/STAC		;CDR IN AC1, CAR IN AC0, RET TO INST-1

;;;	SWEEP:	LSPGCS A,N
;;; LISP GARBAGE COLLECTION SWEEP INSTRUCTION.
;;; IF THE GCSTBR IS NOT SET UP, BEHAVES AS A UUO (OPCODE 071).
;;; OTHERWISE, SWEEPS UP A SECTION OF MEMORY.
;;;	A/	AOBJN POINTER TO REGION OF MEMORY TO SWEEP: <# CELLS>,,<START ADR>
;;;		THE CELLS ARE N WORDS LONG.
;;;	A+1/	POINTER TO NEXT WORD OF MARK BITS TO USE.  A BIT=0 => MARKED.
;;;	A+2/	FREELIST (TO BE ADDED TO THE FRONT OF).
;;;	A+3/	COUNT OF RECLAIMED CELLS, TO BE INCREMENTED.
;;; THE INSTRUCTION OPERATES IN GROUPS OF 40 WORDS (ONE WORD OF MARK BITS).
;;; IT CHECKS FOR INTERRUPTS ONLY THAT OFTEN, AFTER CHECKPOINTING ITSELF
;;; BACK INTO THE FOUR AC'S.  IF A PAGE FAULT OR OTHER MEMORY ERROR OCCURS,
;;; IT WILL RESTART CORRECTLY AT THE BEGINNING OF THE GROUP OF 40 WORDS.


;LSPGCS: BR/AR,SC_EA,AR_GCSTBR,SKP AD NE,J/LGCS0	;START OF GC SWEEP INSTR

=0
LGCS0:	AR_BR,J/UUO				;MAYBE CRAP OUT AS UUO
	AR_BR+1000000				;BR GETS 1,,N (FOR BUMPING AOBJN PTR)
	ARX_AC2,BR/AR				;WE STANDARDLY KEEP THE FREELIST IN BRX,
	BRX/ARX,VMA_AC1,LOAD ARX		; THE AOBJN PTR IN ARX, THE COUNT IN MQ,
	AR_AC3,FE_SC				; AND THE MARK BITS POINTED TO BY AC1
	MQ_AR,CLR AR,SC_#,#/40,J/LGCS1	; IN AR (CONSTANTLY SHIFTED OVER).

=010
LGCS7:	NXT INSTR				;DONE, NO INTERRUPT
	NXT INSTR				;DONE, INTERRUPT PENDING
LGCS1:	ARX_MEM,J/LGCS6				;NOT DONE, NO INTERRUPT
	FIN XFER,REFETCH,J/NOP			;NOT DONE, INTERRUPT PENDING
=

LGCS6:	AR_SHIFT,ARX_AR (AD),SC_#,#/4
	ARX_AC0,AR_SHIFT,SH DISP,SC_#,#/-40,J/LGCS3

=0**0
LGCS2:	AR_AC1+1,VMA/AD,SKP ARX0,J/LGCS4
LGCS3:	AR_SHIFT,SH DISP,SC_FE+SC,SKP SCAD0,ARX_ARX+BR,J/LGCS2
	AR_AC1+1,VMA/AD,SKP ARX0,J/LGCS4
	AR_ARX (AD),ARX_AR
=	AR_BR,BR/AR
	AR_BRX,ARX_BR,VMA_BR,BR/AR,BRX/ARX,STORE
	MEM_AR,AR_MQ+1
	MQ_AR,AR_BRX,BRX/ARX,J/LGCS3

=0
LGCS4:	I FETCH,AC1_AR,AR_MQ,MQ_ARX,J/LGCS5
	LOAD ARX,AC1_AR,AR_MQ,MQ_ARX
LGCS5:	AC3_AR,AR_BRX
	AC2_AR,AR_MQ
	AC0_AR
	AD/0S,SIGNS DISP,SKP INTRPT,J/LGCS7

.ENDIF/LISP

.TOC	"LISP DEBUGGING INSTRUCTION"

;;;	LSPDBG A,
;;; PUTS STBR IN A, GCSTBR IN A+1

;LSPDBG: AR_GCSTBR,J/LSPDB1

LSPDB1:	AC1_AR,I FETCH
	AR_STBR,J/STAC
