.TOC	"SINGLE FLOATING ADD & SUB -- FAD, FADR, FSB, FSBRôCE	.DCODE
.ù1§O©/UFA.ø‘§130:	I,	J/UUO		;UFA
	I,	J/UUO		;DFN
.ENDIF/UFA.DFN

140:	R,	FL-AC,	B0/0,	J/FAD
	R,		B0/0,	J/FADL
	RW,	FL-MEM,	B0/0,	J/FAD
	RW,	FL-BOTH,B0/0,	J/FAD

	R,	FL-AC,		J/FADR
	I,	FL-AC,	B0/0,	J/FADRI
	RW,	FL-MEM,		J/FADR
	RW,	øÓÂŸTH,	J/FADR

150:	R,	FL-AC,	B0/1,	J/FSB
	R,		B0/1,	J/FSBL
	RW,	FL-MEM,	B0/1,	J/FSB
	RW,	FL-BOTH,B0/1,	J/FSB

	R,	Fù‹`ÃY		J/FSBR
	I,	Fù‹`ÃY	B0/1,	J/FSBRI
	RW,	FL-MEM,		J/FSBR
	RW,	FL-BOTH,	J/FSBR
	.UCODE

.IFNOT/FPLONG
=00**00
FAD:
FSB:	SR_#,#/1,B DISP,J/FADR		;FLAG NO ROUND, GO FAD/FSB
FMP:	SR_#,#/1,J/FMPR
FDV:	SR_#,#/1,J/FDVR
FADL:
FSBL:
FMPL:
FDVL:	AR_BR,J/UUO			;LONG MODE BECOMES UUO
=
.IF/FPLONG
=00***0
FAD:
FSB:	SR_#,#/1,B DISP,J/FADR		;FLAG TRUNCATE MODE, GO FAD
FADL:
FSBL:	SR_#,#/2,B DISP,J/FADR		;FLAG LONG MODE
.ENDIF/FPLONG
=
=00*010
FADRI:
FSBRI:	AR_AR SWAP,B DISP
FADR:	FE_EXP,EXP_SIGN,SC/SCAD,
		ARX_0S,J/FAS
=111
FSBR:	FE_EXP,SC/SCAD,EXP_SIGN,ARX_0S
=	AR_-AR,J/FAS			;NEGATE SUBTRAHEND
;FIND OPERAND WITH LARGER EXP, LEAVING IT IN BR,
; AND ITS EXP-1 IN FE.  THE SMALLER OPERAND IS LEFT IN AR,
; SHIFTED RIGHT BY THE DIFFERENCE BETWEEN THE EXPONENTS -1

FAS:	BR/AR,BRX/ARX,AR_AC0		;SAVE MEM OP IN BR, GET AC
	SC_EXP-SC,EXP_SIGN,SKP SCAD0	;FIND LARGER OPERAND
=0	FE_FE+SC,BR/AR,AR_BR*2,J/FAS1	;AC EXP .GE. MEM
	MQ_AR,SC_#+SC,#/37.,		;MEM OP LARGER, SHIFT AC OP
		SKP SCAD0,J/FAS2	;COMPUTE SHIFT AMOUNT

FAS1:	MQ_AR,SC_#-SC,#/36.,SKP SCAD0	;CHECK SHIFT AMOUNT
=0
FAS2:	MQ_SHIFT,ARX/MQ,AR_SIGN,J/FAS3	;LOW TO MQ, READY TO GET HI
	AR_SIGN,ARX_AR,			;HERE IF EXP DIFF .GT. 36
		SC_#+SC,#/36.,SKP SCAD0	; .GT. 72?
=0	ARX_SHIFT,MQ_0.M,FE_FE+1,J/FAS5
	ARX_AR,MQ_0.M,FE_FE+1,J/FAS5	;SHIFTED CLEAR OUT

FAS3:	AR_SHIFT,ARL/SH,ARX/MQ,
		MQ_0.M,FE_FE+1		;READY TO ADD

FAS5:	AR_(AR+2BR)*.25,ARX/ADX*.25,	;HERE FOR ADD OR SUB
		NORM,J/SNORM
.TOC	"SINGLE FLOATING MULTIPLY -- FMP, FMPR"

	.DCODE
160:	R,	FL-AC,	J/FMP
	R,		J/FMPL
	RW,	FL-MEM,	J/FMP
	RW,	FL-BOTH,J/FMP

	R,	FL-AC,	J/FMPR
	I,	FL-AC,	J/FMPRI
	RW,	FL-MEM,	J/FMPR
	RW,	FL-BOTH,J/FMPR
	.UCODE
.IF/FPLONG
=00***0
FMP:	SR_#,#/1,J/FMPR			;FLAG TRUNCATE MODE
FMPL:	SR_#,#/2,J/FMPR			;LONG MODE
=
.ENDIF/FPLONG
=00***0
FMPRI:	AR_AR SWAP
FMPR:	SC_EXP,EXP_SIGN,ARX_0S		;PREPARE M'IER FRACTION

=	MQ_AR,AR_AC0,FE_#,#/-14.	;M'IER TO MQ, GET M'CAND
=01*	SC_EXP+SC,EXP_SIGN,		;SEPARATE M'CAND FRACTION FROM EXP
		CALL.S,J/MULSUB		;AND BEGIN MULTIPLY
=11*	FE_#+SC,#/-200,NORM AR,J/SNORM
=
.TOC	"úrgG™E FLOø5$Î DIVIDE --ô¢VY FDVR"

	.DCODE
170:	Rõ‚cL[ø0Ö	•/FDV
	R,	FL-AC,	J/Fø•¦	RW,	FL-MEM,	J/FDV
	RW,	FL-BOTH,J/FDV

	R,	FL-AC,	J/FDVR
	I,	FL-AC,	J/FDVRI
	RW,	FL-MEM,	J/FDVR
	RW,	FL-BOTH,J/FDVR
	.UCODE
.IF/FPLONG
=00***0
FDVL:	Fø·âØ¡-1,EXP_SIGN,ARX+MQ_0.S,J/øÑ+Lcñ¢£D­:	SR_#,#/1,J/FDVR			;FLAG TRUNøpjEAMODE
=
.ø³¢I/FPLOùÑÆŠ{00***öEF‰VRI:	ø4¯Á¥ SWAP
FDVúN„Ó‡ûñlPW1,EXP_SIGN,ARX+MQ_0.S	;SETUP DIVISOR
=îñOX0a	BR/AúK!R±/ARX,ñ"D»‰IVISOúH*OABR, Cù”B¥X
		ø4¯Á‡0,FE_ôk¯e7.,	;øñj ‰IVIDEùÑ §TEP CùõgT		SKú Äa,CALLõ’—Æ‰VCHKîñCE=c0	SKPô©0YCALL,ùKâI­-		;OùkB‹GIN Dù5¤Ó“ON
	úqj L NO ø’k,•/IFNOúD»O DIVù1"¬ASORRYñ¢†ŠwRETURùÈ$E¥E WITù(ÕŸTIENTôg ƒRX.  úñPTŸOK 29ô$Ö“DE STø´)¬ATO
;ôêÁ¥ANTEEô Ö“NG A úSêÎ‰ING Bù5E­EN IFô$EAFIRSTôêE¡ GENEúPjE§
; AôjÏ©IENT øRj ŸF ZERùë ©HEREFùô¢¬ATHE MúpO QUOTù1gTAIS EIú’"Ò; INô¤ÔA7 OR ÷AD NORù¨+É™L FINøˆ$ÔAIN ONø¨)Ô‹P.
îñOX±a	AR_AúVF‹_FE+#õˆ×²Y		;NEøðjI­E QUOú’bÎ©
		SùtB¥ EQ,Jõñ¢VEG	;CùaËAFOR Mùô¢ £UO TOôçÍ‹
	ARûðiXU.25,AúV/Á¥X*.25õ“§Ò›,	;JUùÒÐI§ 36 Bù5) ƒWAY FúSæ ›SB
	ñ1¢ßE+#,#õì–J_SNORMñ.èO§ QUOTù1gTY NORMø3$Ú‹
=
;HERE IF QUOTIENT SHOULD BE NEGATIVE, WITH POSITIVE FORM INîñNÐA¥ AND ø4¬.A SKIPôc ¥EMAINø‘i QIN BRõ($ÓAZERO.ô$ÎATHIS øpiÅY
; Wø¨!Ì‹AR ARûB‹CAUSEôi ‡ONTAIùÔÐT‘E ENTù4¢ £UOTIEùÕ; IF, HOWEVER, THE REMAINDER IS NOT ZERO, WE INFER
; Tùj ƒN INFù3¤Ô‹ PRECù4äÏ DIVIúrgÎAWOULDôâÎ‹RATE ù³éEAONESîñNÐI THE ú5gÔ“ENT. ôc ©HAT Iúh*H‹ CASEõˆ+ÅALEAVEôiXAWITH ú’"; QUOTIENT, SO THE NEGATION PROCESS WILL WORK CORRECTLY TO RETURNñ¢ ©HE HIøòO¥DER Pø4ª ŸF THEôgF“NITE-ú¢Ã“SION ùÑcÁ©IVE Qú³êI‹NT.
÷¬ŠDVNEG÷BiÅ© SR1,ø4¯Á¥*.25 ù“çGYNORM,ùKéÎŸRM
	ø4¬_aS,J/Fø•§E			;Rø³`ÉDER Wø³ª ©O ZERùãEwHERE øÓé DVL
ñ¢—I/FPLOùÑÆŠ;FDVùŽ„Æ‹_EXP-ö+"Ø¡_SIGNõæRAARX+Mú#E=a00
Fø•¦1u	AR_AølVB¥_AR Lùó£¬	;SAVø¨"I­ISOR ù3B¥ LONGñ¢„‰§C_#,#õîW,‡ALL		÷t¢Á‰Y TO úr$Æ© LOW ø’kI‰END
	ARX_SHIFT,AR_AC0,		;DIVIDEND IN PLACE
		SC_FE,FE_#,#/24.,	;EXP TO SC, STEP COUNT TO FE
		SKP AD0,J/FDVCHK	;GO CHECK FOR NO DIVIø‘FŠ{010	Cø3&,§KP BRö%/DVL2	ñ.ãÏABEGINô$Ö“DE
	úqj L NO ø’k,•/IFNOúD»‡AN'T ø’kI‰E, ABùôª
=11ö`Ò¿AC0,SúWÑ¬G/5,		÷s¢ÇAQUO, øÓ ÇATRUNCø5" ›ODE
		SR DISP,J/FDVL4		; WAS IT 26 OR 27 STEPS?
	AR_AC0,SR_#,#/1,		;POS Qú³ÆŠ	SR Dù4è,•/FDVLöƒE=

;COME HERE TO START THE DIVISION.  ON THE FIRST STEP, WE CHEørÆŠw TO Sø±PW‘ETHERôP1AHAS Bø±g ENERAú‘b “N THEôjÏ©IENT.ô$ÆASO,
; 26 ADDITIONAL STEPS WILL GENERATE THE FULL 27 SIGNIFICANT BITS
; OFô$EAQUOTIø³ª.A IF Nùõ e7 STEúÐA¥E REQú²iE‰.

÷¬ŠDVL2:ñ1$Ö“DE,ARûì”A¥-BR),ø4¬/ƒDX*2,ùKãD­L3	;Fù4©ÔADIVIDø¨)Ô‹P
	Dù5¤Ä‹,AR_2(AR+BúJVA¥X/ADX*2		; DOESôj ø³¢Òƒú‘PAA1?
=öŠø•¦3u	DISP/DIV,MQ/MQ*2,		÷s§¬AúeÅAAN EXú”  ‰IVIDE STEPñ¢„‰ƒR_2(AR+BR),ARX/ø1,*e,J/DIVLP	; WITHùõj ‡OUNTING FE
	SRûìVS‡_#+SCõˆ×±YJ/DIV-		;Yø´Ö e7 STEPS WIù“NŸRMALIûQPQ«ùãE	‰ù4è/‰IV,MQõóhªeõi_eõi-…R),ARX/ADX*2,J/ø’kL¡
	SRûìVS‡_#+SCõˆ×±YùKâI­õcEwWE COù±PH‹RE AFTER DùògGATHE DIVISION, EITHERô› ŸúH7ASTEPSñ¢ ƒúh)E£ú²iE‰ TO GENERAú‘PAAùÓéMƒù’mE‰ QUOTù1gTAFROM ùÓéMƒù’mE‰
; OPERANDS.  ùÓë ù1êÒ‹ôêÔAWHAT EXPONø³ª ©ùPR‹MAINDER SHOULD HAVE.ñ¢†Š{öEF‰VL4:	SC_EXP-#,#õì›®Yñ"D»‰IVIDEND EXP-27îñBDÁ¥_BR,SùtA¥ö%/DVL6	÷qâÔAREMAIùÑ"ÒYô"Ó© D'ENøˆ)ÉN
	SøwâØ¡-#,#/öM—,		;D'END Eû²mñ¢„‰ƒúWáRYSKP AR0
îñNäE¥E WITH REMAINDEúH$ÎAAR, Iú”ÐE±P IN úpÆŠwôåÉ¡ôc ‰'END (AND THEREøÓéEAREM) NEGATIVE.îñCE=a
FDVL6:	Eû/Ó‡õ¬Ô‹ DISP,		;TEST FOR UNDERFLùõÆŠ	SKP AR EQõ’—Æ‰VL7	;ôé ¥EM =0
	AR_-BR,SKP CRY0,	ñ.çEATE REM, CHECK =0
		GEN úpÖB³ú‘PD“SP	; AND Lùóå OR EXú*Æ™ùãE=c10	EXP_-SC-1,J/øÑ+Lo		;ONE'S COMPLEù±gTAø¶(	AR_0S				;REM =0 OR EXP UFLOîñOX±a
FDVL7:	AøloÁ¥õiXWMQ_0.ù«‰wúpkEAúQfÁ“ùÑ"Ò		AR_MQ,AúSÁ‰õ’—ÓR2	;Gùè'O¥MALIZE QUOTIENT
	ARûì)¬•/FDVL7
.ENDIF/FPLONøãE
;SUBR TOôäE‡ùh#O¥ô¦OƒTING NO DIVIDE
; ENTER WITH SKP ON DIVIø‘gDASIGN, IN AR LONG, WITH
;ô$Ö“SOR EXP IN SC, ø’kI§OR IN BR

=0îñQ¢V‡HK:	SC_EXP-SC,Eû/Ó“øó–S—P BR0õ’—Æ‰VCK1
	AR_-AR LONG,J/FDVCHK		;øñj ¡OSITIúÑPD“úÒbEøƒE=añ¢£D­ørØºGEN AR-2BR,SKP øt¬°Y		;TEúuFŸúH'OADIVIDø£E	úpï£WSC,#/ö-Û¬¥ETURN2	;AND CORRECT EXP
	GEN AR+2BR,SKP CRY0,		;SAME TEST, NEG DIVISOR
		úpï£WSC,#/ö-Û¬¥øµ*Ò2	;ANøˆ)Á›E EXPôçÒ¥ø°êIŸùÃE]TOC	"ú± ¬Aø‘§,AFSC, IBP"
;ENTø´W“TH (Eõ($ÎAø4†Š]IF/UFø+¢Fñ¢„®‰øsâE130:	R,		J/UFAñ¢„Ò¡W,		J/DFN
	.UCODE
=00**õLŠ‰øÓ	ø·àÒa-8,AR0-8_#õˆ×°Yñ"]ÓƒúÑPLŸúè"Ø¡õˆ!Ì¥ SO Cø3		ARX_0S,J/DFN1		; DETECT FRACú’gÎA÷¨UFA:	FE_EXP,SC/SCAD,EXP_SIGN,AúV/°§
=
=000	BR_AR LONG,AR_AC0,CALL,J/ø¶(D=100ñ0iX¿ø4–A¥_SIGNõiL_AD,		;READû(*OAUNNORMALIZø¨)Íƒù“"ÒAOP
	ñ0àÌ™õÓVJ_úr$Æ©ñ¢„Á¥_SIGNõiX_AD			;LOSTôæÁ™LER OúU§E ITSôäÇñ¢„Á¥_AR+BúK)Ë¡ôb ø«‰wIS REúufTAúrcÎ“øÒaÁT?
		SC_Fø«$ øµ!È=
=ö`Ãc_AR,J/FINIñ"D»ùëC™ø°i ¥ESULT AC
	SKP EXP NE,BR/AR		;IS RIGHT SHIFT REQ'D?
=0ñ4åÐAø4˜,ETCH WAIT,ùKêÆƒ4	;NOõˆ$ÓARESULT NEG÷ãE	ƒúWáRU.5,GEN FE-ôk¯göíÖS—P SCAøˆ'EYFETCH WAIT
=0	øÑo­c,SET FLOV
	FE_øÑU±YSC/SCAD,SKP AR0
=0
UFA4÷B`Òa-8_SCõ’—Ó©ø0Ø‰÷t'ÓY PUT IN EXP STRø2cÈ©ñ¢„Á¥ö\_[SC-1,J/STAC1		;NEG, ú´â ‡ùóhL‹MENT OF EXúE
DFNö.„Á¥ûë`ÒYSKP CRY0			; LOW FRACTION =0?
=0	AúL¸¿FE,STùô¢¬ñ"]Ó©ORE LOW WORD BAørÐTŸ MEM
		ARX_AC0 COMP,J/STMAC	;ôâÔAøsæÐ™EMENTø±H“GH WORD
	AR0-8_FE,STORE,			;LOW WORD WAS ZERO, INSTALLôlP		ARX_-AC0,J/STMAC	÷h#Å© NEGATED HIGH WORD
.ENDIF/UFA.DFNîñCŠ.DCODE
132:	I,	FL-AC,	J/FSC
	R,		J/IBP		;ADJBP IF AC .NE. 0
	.UCODE
=00***0
.IF/ADJBP
IBP:	SKP AC#0,J/IBP1		;IS IT IBP, OR ADJBP?
.IFNOT/ADJBP
IBP:	J/IBP2
.ENDIF/ADJBP


;FSC
;ENTER WITH E IN AR
=00****
FSC:	SC_EA,ARX+MQ_0.M,
		AR_AC0,ARL/AD
=	FE_EXP+SC,EXP_SIGN,J/SNR2	;NORMALIZE SCALED RESULT
.TOC	"FIX, FIXR, FLTR, EXTEND"

	.DCODE
122:	R,		J/FIX		;UNROUNDED
.IF/EIS
	R,		J/EXTEND	;EXTENDED INSTRUCTION SET
.IFNOT/EIS
	I,		J/UUO
.ENDIF/EIS

126:	R,		J/FIXR		;ROUNDED
	R,	FL-AC,	J/FLTR
	.UCODE

;FLTR
;ENTER WITH (E) IN AR
=00***0
FLTR:	FE_#,#/277,ARX_AR,SKP AR0,	;BINARY POINT TO RIGHT OF ARX
		AR_SIGN,J/SNORM		; SIGN EXTENDED.  GO NORMALIZE

;FIX AND FIXR
;ENTER WITH (E) IN AR
;	FIX AND FIXR DIFFER ONLY IN THE ROUNDING CRITERION:
;FIXR ADDS 1 TO THE INTEGER PART IF THE FRACTION PART IS ONE-HALF
;OR GREATER.  FIX DROPS THE FRACTION PART OF POSITIVE NUMBERS, BUT ADDS
;1 TO THE INTEGER PART OF NEGATIVE NUMBERS IF THE FRACTION PART IS NOT
;ALL ZERO.
;	THIS IS IMPLEMENTED BY CHOOSING A FRACTION (THE ROUNDING
;CONSTANT) TO ADD TO THE INPUT, SUCH THAT A CARRY WILL OCCUR INTO THE
;INTEGER PART UNDER THE APPROPRIATE CONDITIONS.  FOR FIXR, THE ROUNDING
;CONSTANT IS EXACTLY ONE-HALF.  FOR FIX, IT IS ZERO ON POSITIVE INPUT,
;OR THE LARGEST POSSIBLE FRACTION (ALL 1S) ON NEGATIVE INPUT.

=00****
FIXR:	FE_EXP-#,#/244,SKP SCAD0,	;GET BINARY POINT POSITION
		ARX_1B1,J/FIX1		;GET ROUNDING CONSTANT
=
.IFNOT/EIS
;1005:		;REALLY IN SKPJMP FILE TO PREVENT 1005 BEING USED TWICE
;FIX:	FE_EXP-#,#/244,SKP SCAD0,	;GET BINARY POINT POSITION
;		ARX_AR SIGN,J/FIX1	;SET ROUNDING CONSTANT, GO FIX
.IF/EIS
=00***0
FIX:	FE_EXP-#,#/244,SKP SCAD0,	;GET BINARY POINT POSITION
		ARX_AR SIGN,J/FIX1	;SET ROUNDING CONSTANT, GO FIX
EXTEND:	FE_#+AR0-8,#/-20,SKP SCAD0,	;VALID EXTENDED OPERATION?
		ARX_AR,AR_BRX,J/EXT1	; OPR TO ARX, AC TO AR
=
.ENDIF/EIS
=0
FIX1:	SET AROV,J/IFNOP		;CAN'T DO IT, GIVE UP
	BR/AR,CLR AR,ARX_ARX*2		;ROUNDING CONSTANT READY IN ARX
	BR_AR LONG,AR_BR,CLR ARX,	;MANTISSA TO AR LONG
		SC_#,#/9.		;READY TO SHIFT OFF EXPONENT
	ARX_SHIFT,AR_SIGN,		;MANTISSA LEFT ALIGNED IN ARX
		SC_FE+#,#/36.,SKP SCAD0	;ANY INTEGER BITS?
=0	MQ_SHIFT,			;YES, PUT THEM IN MQ
		AR_ARX (ADX),CLR ARX,	;SHIFT MANTISSA LEFT 36 PLACES
		I FETCH,J/FIX2		;AND PREFETCH NEXT
	AR_0S,I FETCH,J/STORAC		;ALL SIGNIFICANCE LOST

FIX2:	ARX_SHIFT,AR_MQ			;INTEGER IN AR, FRACTION IN ARX
	AR_AR+BR,AD LONG,J/STAC		;ROUND AND STORE
.TOC	"SINGLE PRECISION FLOATING NORMALIZATION"

;HERE TO NORMALIZE SINGLE PRECISION RESULTS
;SR2-3 TELL HOW TO STORE RESULTS:
;XX00 ... ROUND, SINGLE PRECISION
;XX01 ... TRUNCATE, SINGLE PRECISION
;XX10 ... LONG MODE (IMPLIES TRUNCATION)
;IN ADDITION, THIS CODE SETS SR 1 IF ANSWER IS NEGATIVE, SO X1YZ
; CORRESPONDS TO X0YZ EXCEPT THAT THE RESULT MUST BE NEGATED.

;DISPATCH TO SNORM WITH "DISP/NORM,AR/AD*.25"
; THUS THE 8 POSSIBILITIES ARE:
;SNORM		AD=0	AR=0	EITHER ANSWER IS ZERO, OR MSB IS IN ARX
;SNORM+1	AD0	AR NEG	RESULT IS NEG.  MAKE POS, TRY AGAIN
;SNORM+2	AD1-6	AR3-8	MSB TOO FAR LEFT, SHIFT RIGHT & RETRY
;SNORM+3	AD7	AR9	RESULT IS CORRECTLY NORMALIZED
;SNORM+4	AD8	AR10	SHIFT LEFT ONCE FOR NORMALIZATION
;SNORM+5	AD9	AR11	SHIFT LEFT 2 PLACES
;SNORM+6	AD10	AR12	SHIFT LEFT THRICE
;SNORM+7	AD11-35	AR13-35	SHIFT LEFT A LOT, TRY AGAIN

=000
SNORM:	AR_ARX,ARL/SH,SKP ARX NE,	;AR IS ZERO, GET ARX
		ARX_0.M,J/SNZERO
	NORM -AR,SET SR1,J/SNORM	;REMEMBER NEGATIVE, GO POSITIVE
SNR2:	AR_AR*.25 LONG,FE_FE+#,#/2,	;SHIFT RIGHT,
		NORM,J/SNORM		;TRY AGAIN
	SR DISP,J/SROUND		;AD7 -> AR9, IS ROUND REQ'D?
	AR_AR*2 LONG,FE_FE-1,		;AD8 -> AR10, ONCE LEFT AND DONE
		SR DISP,J/SROUND
	AR_AR*4 LONG,FE_FE-#,#/2,	;AD9 -> AR11
		SR DISP,J/SROUND
	AR_AR*8 LONG,FE_FE-#,#/3,	;AD10 -> AR12
		SR DISP,J/SROUND
	ADA EN/0S,ADB/AR*4,AD/ANDCA,	;GENERATE AR*4
		AR/AD*2,ARX/ADX*2,	; AR_AR*8 LONG
		SC_#,#/12.,		;READY TO SHIFT FARTHER
		GEN CRY18,SKP CRY0	; TEST AR0-19 FOR ZERO

=0	AR_AR*8 LONG,BR_AR LONG,	;IT WAS IN AR13-19
		FE_FE-#,#/6,NORM,J/SN1	; NOW IN AR10-16, AD8-14
	MQ_SHIFT,AR_ARX (ADX),		;13-19=0, SHIFT TO TRY 20-35
		CLR ARX,SC_#,#/10.
	ARX_SHIFT,AR_MQ*.25,		;REPOSITION FRACTION IN AR LONG
		FE_FE-#,#/13.,		;COMPENSATE EXPONENT
		NORM,J/SNORM
=100
SN1:	AR_BR*2 LONG,FE_FE+#,#/2,	;MSB IN AD8, SO IN BR10
		SR DISP,J/SROUND
	AR_BR*4 LONG,FE_FE+1,		;MSB IN AD9, THUS IN BR11
		SR DISP,J/SROUND
	SR DISP,J/SROUND		;AD10 -> AR9, A LUCKY GUESS
	AR_AR*8 LONG,BR_AR LONG,	;TRY SHIFTING 3 MORE
		FE_FE-#,#/3,NORM,J/SN1
;HERE WHEN AD ENTIRELY ZERO ON NORMALIZE ATTEMPT.  SKIP IF ARX
; IS NOT ZERO, HAVING COPIED IT TO AR (IE, LEFT SHIFT 36 PLACES).
; OTHERWISE, THE ENTIRE RESULT IS ZERO, SO WE STORE THAT.
=0
SNZERO:	CLR FE,AR+ARX+MQ_0.M,		;RESULT = 0
		SR DISP,J/SRND5
	AR_AR*.25 LONG,FE_FE-#,#/34.,	;HAVE MOVED LEFT 36, GO RIGHT 2
		NORM,J/SNORM		;AND TRY THAT


;WE GET HERE WITH A NORMALIZED POSITIVE FRACTION IN AR'ARX,
; THE CORRECTED EXPONENT IN FE, AND SR INDICATES THE PROPER SIGN
; FOR THE RESULT AND WHETHER THE ANSWER SHOULD BE ROUNDED,
; TRUNCATED, OR LONG.

.IF/FPLONG
=100
.IFNOT/FPLONG
=1*0
.ENDIF/FPLONG
SROUND:	BR_AR LONG,AR_0S,J/SRND2	;PREPARE TO ROUND BY ADDING THE
					; PART OF THE FRACTION WE WILL
					; DISCARD (CARRY IF ARX0)
	BR_AR LONG,CLR AR,ARX_1S,	;TRUNCATE MODE
		SR DISP,J/STRNC		; HANDLING DEPENDS ON SIGN
.IF/FPLONG
	BR_AR LONG,CLR AR,ARX_1S,	;LONG MODE
		SC_#,#/9.
=	ARX_SHIFT,SR DISP		;MASK = 0,,000777 TO ARX
=01*
	BR_AR LONG,AR_BR LONG,J/SRND4	;POS, TRUNCATE BY ANDING
	AR_AR+BR,ARX/ADX,BR_AR LONG,	;NEG, MUST DIDDLE
		NORM,J/SRND3		; NORM FORCES LONG ARITH
.ENDIF/FPLONG
;HERE TO PERFORM ROUNDING OR TRUNCATION OF SINGLE-PRECISION RESULTS,
; AND CHECK FOR CARRY INTO EXPONENT FIELD REQUIRING RENORMALIZATION

=0*1
STRNC:	AR_BR,CLR ARX,J/SRND4		;POS TRUNCATE, GO STUFF IN EXP
SRND2:	AR_AR+BR,NORM,CLR ARX		;NORM FORCES LONG ARITH
					; SO THIS ADDS ARX TO BR'BRX
=1*0
SRND3:	AR_AR*.5,FE_FE+1		;RENORMALIZE
SRND4:	EXP_FE TST,SR DISP,		;STUFF EXP, CHECK NEG OR LONG
		ARX_ARX*BRX,AD/ANDCB	;CLEAR TRUNCATED FRACTION

;HERE TO STORE RESULT AS A FUNCTION OF SINGLE OR LONG PRECISION
; AND POSITIVE OR NEGATIVE...
.IF/FPLONG
=001
.IFNOT/FPLONG
=0*1
.ENDIF/FPLONG
SRND5:	SR_0,B WRITE,J/ST6		;POS & NOT LONG
.IF/FPLONG
SLNG3:	AC0_AR,AR_0S,SC_#,#/27.,J/SLNG4	;STORE HIGH PART OF LONG ANS
.ENDIF/FPLONG
	AR_-AR,SR_0,B WRITE,J/ST6	;NEG & NOT LONG
.IF/FPLONG
	AR_-AR LONG,J/SLNG3		;LONG NEG, MAKE IT SO

SLNG4:	AR_SHIFT,I FETCH
	AR0-8_FE-SC,BYTE DISP,		;TEST FOR EXP UNDERFLOW
		SKP AR EQ		; OR LOW WORD ZERO

=110
.ENDIF/FPLONG
STRAC1:	SR_0,J/STAC1			;PUT AWAY LOW WORD OF LONG RESULT
.IF/FPLONG
	AR_0S,SR_0,J/STAC1		;CLEAR LOW WORD IN AC1
.ENDIF/FPLONG
.TOC	"DOUBLE FLOATING ARITHMETIC -- DFAD, DFSB, DFMP, DFDV"

	.DCODE
110:	R,	B/0,	J/DFLOAT	;DFAD
	R,	B/2,	J/DFLOAT	;DFSB
	R,	B/4,	J/DFLOAT	;DFMP
	R,	B/6,	J/DFLOAT	;DFDV
	.UCODE

=00**0*
DFLOAT:	FE_EXP,EXP_SIGN,SC/SCAD,MQ_0.S,
		VMA_VMA+1,LOAD ARX,
		CALL.S,J/XFERW		;GET LOW WORD
	ARX_ARX*2,B DISP		;LOW BIT 0 IGNORED
=
=00*
DFAS:	BR_AR LONG,AR_AC1*2,J/DFAS1	;MEM OP READY, GET AC OP

	AR_-AR LONG,J/DFAS		;DFSB, NEGATE AND ADD

	AR_AC1,BR_AR LONG,		;HERE FOR DOUBLE FLOATING MUL
		FE_#,#/-18.,J/DFMP

	GEN AR*AC0,AD/XOR,SKP AD0,	;DFDV.  WILL QUO BE NEG?
		BR_AR LONG,		;SAVE D'SOR IN BR, BRX
		SC_FE-1,J/DFDV
;HERE FOR DFAD AND DFSB
; MEM OPERAND IS IN BR (NEGATED IF DFSB)
; FE AND SC HAVE ITS EXPONENT

=0*0
DFAS1:	ARX_AR,AR_AC0,CALL,J/EXPD	;AC OPERAND IN PLACE
=1*0
DFAS2:	ARX_AR,AR_SIGN,			;GET SHIFTED HIGH WORD
		GEN #+SC,#/-36.,	;IS ANY SHIFT REQUIRED?
		SKP SCAD0,J/DFAS3
	ARX_AR,AR_SIGN,			;DIFF IS > 36
		SC_#+SC,#/36.,SKP SCAD0	;CHECK FOR >72
=0	AC0_AR,MQ_SHIFT,AR_ARX (ADX),
		ARX/MQ,J/DFAS4		;36 < DIFF < 72
	AR_BR,ARL/AD,ARX_BRX,		;DIFF >72
		MQ_0.M,J/DNTRY		;NORMALIZE LARGER OP
=0
DFAS3:	AR_ARX,ARL/SH,ARX/MQ,		;NO SHIFT REQUIRED
		MQ_0.M,J/DFAS5
	AR_SHIFT			;BEGIN SHIFTING SMALLER OP
	AC0_AR,AR_ARX,ARX/MQ		;HI PART TO AC
	MQ_SHIFT,AR_ARX (ADX),		;MID PART TO MQ
		CLR ARX			;SHIFT ZEROS IN FROM RIGHT
DFAS4:	MQ_SHIFT,ARX/MQ,AR_AC0		;ALL PIECES NOW IN PLACE
DFAS5:	AR_AR+BR,ARX/ADX,SC_#,#/4,	;HERE WHEN OPERANDS ALIGNED
		NORM,J/DNORM		;ADD, AND NORMALIZE RESULT


;SUBROUTINE TO CHOOSE OPERAND WITH SMALLER EXPONENT, AND
; PREPARE FOR SHIFTING IT.
; ENTER WITH ONE OPERAND FRACTION IN BR, ITS EXPONENT IN FE & SC,
; THE OTHER OP IN AR WITH ITS EXPONENT IN AR0-8
; RETURN THE LARGER EXPONENT IN FE, AND 36-(MAGNITUDE OF DIFFERENCE)
; IN SC.  RETURN 4 IF SC POSITIVE, 5 IF NEGATIVE.

EXPD:	SC_EXP-SC,EXP_SIGN,SKP SCAD0	;COMPARE MAGNITUDES
=0	AR_BR,ARX_BRX,BR/AR,BRX/ARX,	;AC OP IS LARGER MAGNITUDE
		FE_FE+SC,J/EXPD1	;ITS EXP TO FE
	MQ_ARX,SC_#+SC,#/36.,		;CHECK FOR EXP DIFF > 36
		SKP SCAD0,RETURN4
EXPD1:	MQ_ARX,SC_#-SC,#/36.,		;AC EXP .GE. MEM
		SKP SCAD0,RETURN4	;SHIFT MEM OP
;DFMP
; GET HERE WITH MEM OPERAND (M'CAND) IN BR!BRX
; AR HAS (AC1), LOW HALF OF M'IER

=00*
DFMP:	MQ_AR,AR_0S,ARX_0S,		;SETUP LOW M'IER
		SC_#+SC,#/-200,		;CORRECT EXPONENT
		CALL,J/MULREE		;MULTIPLY BY THE LOW PART
=10*	AR_AR+BR LONG			;OOPS, LOW SIGN WAS SET
	MQ_AR,AR_AC0,FE_#,#/-14.	;READY TO CONTINUE WITH HIGH PART

;HERE TO USE HIGH MULTIPLIER

	SC_EXP+SC,EXP_SIGN.M,		;EXTRACT EXP FROM HIGH WORD
		SKP AR0			;CHECK FOR NEG M'IER
=010
DFMP2:	MQ_AR,AR_MQ,CALL,J/MULREE	;GO BACK IN FOR HIGH PART
	EXP_1,J/DFMP2			;OOPS, NEG, MOVE SIGN TO BIT 8
=110
DNTRY:	SC_#,#/4,GEN AR,NORM,J/DNORM	;NORMALIZE THE ANSWER
=


;DFDV
; GET HERE WITH DIVISOR IN BR!BRX, ITS EXP-1 IN SC
; SKIP IF D'SOR AND D'END SIGNS DIFFER

=000
DFDV:	AR_AC1*2,CALL,J/DFDV1		;GET LOW D'END, GO START DIVIDE
	SR_1,AR_AC1*2,CALL,J/DFDV1	;NOTE NEG QUO

=011	AC1_AR,AR_MQ,ARL/AD,FE_FE+1,	;HERE FROM DDVSUB. NEW STEP CNT
		MQ_0.M,CALL.M,J/DIV+	; SAVE HIGH QUO, RESUME
=101	AC1_AR,AR_MQ,ARL/AD,FE_FE+1,
		MQ_0.M,CALL.M,J/DIV-

=111	AR_AC1,ARX/MQ,SC_#,#/4,		;POSITIVE QUOTIENT TO AR LONG
		NORM,J/DNORM		;NORMALIZE AND ROUND

=00
DFDV1:	ARX_AR,AR_AC0,SKP AD0,		;TEST DIVIDEND SIGN
		FE_#,#/26.,		;SETUP COUNT FOR HIGH QUO
		CALL,J/FDVCHK		;GO CHECK DIVIDABILITY
=10	SKP BR0,J/DDVSUB		;BEGIN DIVISION (RETURN ABOVE)
	SET FL NO DIV,J/IFNOP		;ABORT THE DIVISION
.TOC	"DOUBLE PRECISION NORMALIZATION"

=000
DNORM:	SKP ARX+MQ NE,SC_#,#/35.,J/DNZERO	;AR=0
	BR/AR,BRX/ARX,AR_MQ COMP,	;RESULT NEG, MAKE POS
		SR_1,J/DNNEG		;FLAG NEGATIVE
	AR_AR*.25 LONG,MQ_MQ*.25,
		FE_FE+#,#/4,J/DNHI	;MSB IN AR 1-6
	AR_AR*.25 LONG,
		FE_FE+#,#/2,J/DROUND	;MSB IN AR7
	AR_AR*.5 LONG,FE_FE+1		;MSB IN AR8
DROUND:	AR_AR+1,ARX/ADX,NORM,		;MSB IS AR9, RIGHT ON
		SC_#,#/35.,J/DRND1
	(AR+ARX+MQ)*2,FE_FE-1,J/DROUND	;MSB IN AR10
	AR_SHIFT,FE_FE-SC		;SOMEWHERE IN AR 11-35

DNSHFT:	BR/AR,AR_ARX,ARX/MQ		;SHIFT THE WHOLE THING
	MQ_SHIFT,AR_ARX (ADX),CLR ARX
	MQ_SHIFT,ARX/MQ,AR_BR,SC_#,#/10.,
		NORM,J/DNORM		;GIVE IT ANOTHER GO

DNNEG:	AR_AR+1,SKP CRY0		;COMPLETE NEGATION OF MQ
=0	MQ_AR,AR_BR COMP,ARX_BRX COMP,
		NORM,J/DNORM		;NORMALIZE THE POS FORM
	MQ_AR,AR_-BR,ARX/ADX,NORM,J/DNORM

DNHI:	(AR+ARX+MQ)*.25,J/DNTRY		;GO TRY AGAIN

=0
DNZERO:	SR_0,AR_0S,ARX_0S,J/DBLST	;RESULT = 0, STORE THAT
	AR_SHIFT,FE_FE-SC,J/DNSHFT	;NOT ZERO, SHIFT AND TRY AGAIN

=110
DRND1:	AR_AR*.5 LONG,FE_FE+1		;ROUNDING BLEW THE NORM, GO RIGHT
	EXP_FE TST,SR DISP,CLR MQ,	;STUFF EXP IN, CHECK RESULT SIGN
		BRX/ARX,ARX_1		;READY IF NEGATION NECESSARY

=0	AC0_AR,AR_SHIFT,ARX_BRX,	;STORE HIGH WORD, READY LOW
		I FETCH,J/STD1
	ARX_ARX*BRX,AD/ANDCA,SR_0	;CLEAR ROUNDING BIT
	AR_-AR LONG,J/DBLST		;NEGATE RESULT AND STORE
