.TOC	"BLT"
; ENTER WITH 0,E IN AR

;IN THE LOOP, ARX CONTAINS THE CURRENT DESTINATION ADDRESS,
; BRX CONTAINS THE TERMINAL ADDRESS, AND BR CONTAINS THE DIFFERENCE
; BETWEEN THE SOURCE AND DESTINATION ADDRESSES.

;UNLIKE EARLIER -10 PROCESSORS, THIS CODE CHECKS FOR THE CASE IN WHICH
; THE DESTINATION ADDRESS IN RH(AC) IS GREATER THAN E, AND RATHER THAN
; STOPPING AFTER ONE WORD, COPIES DOWNWARD (EFFECTIVELY DECREMENTING
; AC BY 1,,1 ON EACH STEP, RATHER THAN INCREMENTING).

;THIS CODE ALSO PROVIDES A GUARANTEED RESULT IN AC ON COMPLETION OF
; THE TRANSFER (EXCEPT IN THE CASE AC IS PART OF BUT NOT THE LAST WORD
; OF THE DESTINATION BLOCK).  WHEN AC IS NOT PART OF THE DESTINATION
; BLOCK, IT IS LEFT CONTAINING THE ADDRESSES OF THE FIRST WORD FOLLOWING
; THE SOURCE BLOCK (IN THE LH), AND THE FIRST WORD FOLLOWING THE DEST-
; INATION BLOCK (IN THE RH).  IF AC IS THE LAST WORD OF THE DESTINATION
; BLOCK, IT WILL BE A COPY OF THE LAST WORD OF THE SOURCE BLOCK.

;IN ADDITION, A SPECIAL-CASE CHECK IS MADE FOR THE CASE IN WHICH EACH
; WORD STORED IS USED AS THE SOURCE OF THE NEXT TRANSFER.  IN THIS CASE,
; ONLY ONE READ NEED BE PERFORMED, AND THAT DATA MAY BE STORED FOR EACH
; TRANSFER.  THUS THE COMMON USE OF BLT TO CLEAR CORE IS SPEEDED UP.

;BLT:	ARX_AR,MQ_AR,ARR_AC0,ARL_ARL	;END TO ARX & MQ, DEST TO AR
BLT1:	BR/AR,ARX_AR,BRX/ARX,		;DST TO BR & ARX, END TO BRX
		AR_AC0			;SRC TO ARL
	ARR_ARL,ARL_0.M			;SRC TO ARR
	AR_AR-BR			;SRC-DST TO ARR
.IF/BACK.BLT
	BR/AR,SKP ARX LE BRX		;SRC-DST TO BR. UP OR DOWN?
=00	AR_MQ-1,CALL,J/BLTAC		;DOWN, READY WITH E-1
	AR_MQ+1,CALL,J/BLTAC		;UP, PUT E+1 IN AR FOR AC
DOWN:	VMA_ARX+BR,LOAD AR,J/DN1	;DOWN, START THE LOOP
.IFNOT/BACK.BLT
=0*	BR/AR,AR_MQ+1,CALL,J/BLTAC	;SRC-DST TO BR, E+1 IN AR
.ENDIF/BACK.BLT
	SKP BR EQ -1,J/UP		;IS THIS CORE CLEARING CASE?


;HERE TO SETUP FINAL AC

BLTAC:	ARL_ARR,AR_AR+BR		;FINAL DEST TO LH, SRC TO RH
	AR_AR SWAP,SR_BLT(SRC)		;REARRANGE
	AC0_AR,RETURN2
;HERE FOR UPWARD BLT (AC RH .LE. E)
=0
UP:	VMA_ARX+BR,LOAD AR,J/UP1	;NOT CLEAR CORE
	SKP P!S XCT,VMA_ARX+BR,LOAD AR	;DO NOT OPTIMIZE UNDER EXT ADDR

;USE EVEN LOC'NS OF THIS BLOCK OF 4 IN SPECIAL "CLEAR CORE" CASE

=00	AR_MEM,CALL,SR_BLT(DST),J/UP2	;GET THE WORD TO STORE IN ALL
UP1:	AR_MEM,CALL,SR_BLT(DST),J/UP2	;GET SOURCE WORD
	CALL,SR_BLT(DST),J/UP2		;HERE TO STORE SAME SRC AGAIN
	VMA_ARX+BR,LOAD AR,J/UP1	;HERE TO GET NEXT SRC

UP2:	VMA_ARX,STORE,SKP INTRPT	;OK, GET DST ADDRESS
=0
UP3:	SKP ARX LT BRX,J/UP4		;CHECK FOR LAST TRANSFER
	MEM_AR,J/BLTPF			;FINISH THIS, GO SERVE INTRPT
=0
UP4:	FIN STORE,I FETCH,J/NOP		;THAT'S ALL, FOLKS
	MEM_AR,ARX_ARX+1,		;STORE DST,
		SR_BLT(SRC),RETURN2	; CONTINUE

;BLT CONTINUED - HERE FOR DOWNWARD BLT (AC RH .GT. E)
.IF/BACK.BLT

DN1:	AR_MEM,SR_BLT(DST)		;WAIT FOR SOURCE DATA
	VMA_ARX,STORE,SKP INTRPT	;OK, START DST REF
=0	SKP ARX LE BRX,J/DN3		;CHECK FOR END CONDITION
	MEM_AR,J/BLTPF			;FINISH STORE, TAKE INTRPT
=0
DN3:	MEM_AR,ARX_ARX-1,		;NOT END, LOOP
		SR_BLT(SRC),J/DOWN
	FIN STORE,I FETCH,J/NOP		;END
.ENDIF/BACK.BLT
.TOC	"STORING OF JPC"

.IF/JPC SUPPORT

AOBJPC:					;HERE TO STORE JPC FOR AOBJN/AOBJP
SOJJPC:					;HERE FOR SOJ SERIES
AOJJPC:					;HERE FOR AOJ SERIES
	AC0_AR,B DISP
=*1*000					;HERE FOR JUMP SERIES
JMPJPC:	GEN AR-1,SKP AR0,SIGNS DISP,J/JPCP	;LE
	SKP AR NE,J/NJPCP			;E
	SKP AR0,J/JPCP				;L
	J/FINI					;-
	GEN AR-1,SKP AR0,SIGNS DISP,J/NJPCP	;G
	SKP AR NE,J/JPCP			;N
	SKP AR0,J/NJPCP				;GE
	AR_PC,SC_#,#/32.,SKP USER,J/JPCEX	;A

=*1*110
JPCP:	NXT INSTR				;NOT JUMPING
JPCIFY:	AR_PC,SC_#,#/32.,SKP USER,J/JPCEX	;JUMPING

;THIS IS LIKE STORAC, EXCEPT IT STORES THE JPC ALSO.
;CALLED WITH SKP USER, BECAUSE WRITING IN FM USES THE COND
;FIELD, WHICH MEANS JPCSTO CAN'T DO THE SKP USER ITSELF.

=0
JPCSTO:	AC0_AR,AR_PC,SC_#,#/32.,J/JPCEX
	AC0_AR,AR_PC,SC_#,#/32.,J/JPCUSR

.IFNOT/JPC.RING
=*1***0
JPCEX:	XJPC_AR,NXT INSTR AFTER JPC
JPCUSR:	JPC_AR,NXT INSTR AFTER JPC
.IF/JPC.RING
;COME HERE WITH:	SKP USER,SC_#,#/32.
=*1***0
JPCEX:	AR_XJPC+1,J/JPCEX1
JPCUSR:	AR_JPC+1
	JPC_AR,SH DISP,AR_PC
=*10000
	JPC0_AR,NXT INSTR AFTER JPC
	JPC1_AR,NXT INSTR AFTER JPC
	JPC2_AR,NXT INSTR AFTER JPC
	JPC3_AR,NXT INSTR AFTER JPC
	JPC4_AR,NXT INSTR AFTER JPC
	JPC5_AR,NXT INSTR AFTER JPC
	JPC6_AR,NXT INSTR AFTER JPC
	JPC7_AR,NXT INSTR AFTER JPC
	JPC10_AR,NXT INSTR AFTER JPC
	JPC11_AR,NXT INSTR AFTER JPC
	JPC12_AR,NXT INSTR AFTER JPC
	JPC13_AR,NXT INSTR AFTER JPC
	JPC14_AR,NXT INSTR AFTER JPC
	JPC15_AR,NXT INSTR AFTER JPC
	JPC16_AR,NXT INSTR AFTER JPC
	JPC17_AR,NXT INSTR AFTER JPC

JPCEX1:	XJPC_AR,SH DISP,AR_PC
=*10000
	XJPC0_AR,NXT INSTR AFTER JPC
	XJPC1_AR,NXT INSTR AFTER JPC
	XJPC2_AR,NXT INSTR AFTER JPC
	XJPC3_AR,NXT INSTR AFTER JPC
	XJPC4_AR,NXT INSTR AFTER JPC
	XJPC5_AR,NXT INSTR AFTER JPC
	XJPC6_AR,NXT INSTR AFTER JPC
	XJPC7_AR,NXT INSTR AFTER JPC
	XJPC10_AR,NXT INSTR AFTER JPC
	XJPC11_AR,NXT INSTR AFTER JPC
	XJPC12_AR,NXT INSTR AFTER JPC
	XJPC13_AR,NXT INSTR AFTER JPC
	XJPC14_AR,NXT INSTR AFTER JPC
	XJPC15_AR,NXT INSTR AFTER JPC
	XJPC16_AR,NXT INSTR AFTER JPC
	XJPC17_AR,NXT INSTR AFTER JPC
.ENDIF/JPC.RING
.ENDIF/JPC SUPPORT
