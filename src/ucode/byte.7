.TOC	"BYTE GROUP -- IBP, ILDB, LDB, IDPB, DPB"

	.DCODE
;133:	R,		J/IBP		;OR ADJBP
134:	RW,		J/ILDB		;CAN'T USE RPW BECAUSE OF FPD
	R,		J/LDB
	RW,		J/IDPB
	R,		J/DPB
	.UCODE

;ALL FIVE INSTRUCTIONS OF THIS GROUP ARE CALLED WITH THE BYTE POINTER
;IN THE AR.  ALL INSTRUCTIONS SHARE COMMON SUBROUTINES, SO THAT
;THE 10/11 INTERFACE AND STRING MAY ALSO USE THESE SUBROUTINES

;IBP OR ADJBP
;IBP IF AC#0, ADJBP OTHERWISE
; HERE WITH THE BASE POINTER IN AR

;IBP:	SKP AC#0			;IS THIS IBP OR ADJBP?
.IF/ADJBP
=1**000
IBP1:	T0_AR,BR/AR,			;SAVE POINTER FOR ADJBP
		SC_S,AR_0S,CALL,J/GETSC	; GET BYTE SIZE
.ENDIF/ADJBP
=001
IBP2:	BR/AR,P_P-S,CALL.M,		;NEW P UNLESS OVERFLOW
		SKP SCAD0,J/IBPS
.IF/ADJBP
	BR/AR,AR_BR,J/ADJBP		;HOLD S IN BR AND MQ
.ENDIF/ADJBP
=101	FIN STORE,I FETCH,J/NOP		;IBP DONE
=

=00*000
ILDB:	BR/AR,P_P-S,BYTE DISP,		;START IBP
		CALL.M,J/IBPS		;AND CALL SUBR
=100
LDB:	ARX_AR,SC_P,CALL,J/BYTEA	;BEGIN EA COMPUTATION
	SC_FE+SC,CALL,J/LDB1		;SC_P+S WHILE LOADING AR
=111	AC0_AR,CLR FPD,I FETCH,J/NOP	;DONE
=

=00*000
IDPB:	BR/AR,P_P-S,BYTE DISP,		;START IBP
		CALL.M,J/IBPS
=100
DPB:	ARX_AR,SC_P,CALL,J/BYTEA	;COMPUTE EFFECTIVE BYTE ADDR
	AR_AC0,TIME/3T,SC_#-SC,#/36.,	;COMPUTE 36-P
		CALL,SKP SCAD0,J/DPB1	;CALL DEPOSITOR
=111
BFIN:	FIN STORE,I FETCH		;DONE
=
=*1***0
CLRFPD:	CLR FPD,J/FINI			;CAN'T DO THIS UNTIL STORE COMPLETE
	J/FINI				;HERE FROM BLKO/BLKI PI
=
.TOC	"INCREMENT BYTE POINTER SUBROUTINE"

;THIS SUBROUTINE IS CALLED BY THE INSTRUCTIONS ILDB, IDPB AS
;WELL AS THE MICROCODED 10/11 INTERFACE HANDLER.
;CALL WITH BYTE DISP TESTING FPD AND SIGN OF P-S
;[TIME=2+2(BP OVFLO)]

=1**010					;BR12 IRELEVANT
IBPS:	STORE,RETURN4			;SIMPLE, NO OVERFLOW
	FE_#,#/36.,GEN AR+1,TIME/2T,	;HERE IF OVRFLO OF WORD
		ARX_AR,J/NXTWRD
	AR_BR,RETURN4			;FPD WAS SET, RESTORE AR
	AR_BR,RETURN4			; AND CONVERT TO LDB OR DPB
=					;TEST BR12 ONLY
NXTWRD:	AR_AR+1,P_FE-S,STORE,
		TIME/2T,RETURN4


.TOC	"BYTE EFFECTIVE ADDRESS EVALUATOR"

;ENTER WITH POINTER IN AR, ARX, AND BR
;RETURN1 WITH (EA) LOADING INTO AR AND ARX,
;FPD SET, P IN SC, AND S IN FE
;[TIME=4+1(INDEXED)+?(INDIRECT)]

BYTEA:	MEM_AR,FE_S,SET FPD,		;PUT AWAY UPDATED POINTER
		EA MOD DISP		;EVAL BP ADDR
=11**00
BFETCH:	VMA_ARX,BYTE READ,RETURN1	;START DATA FETCH
	VMA_ARX+XR,BYTE READ,RETURN1	;ADDRESS IS INDEXED
	GEN ARX,BYTE INDRCT,J/BYTEI	;DO INDIRECT
	GEN ARX+XR,BYTE INDRCT,J/BYTEI	;INDIRECT INDEXED!!!

BYTEI:	ARX_MEM,SKP INTRPT		;WAIT FOR INDIRECT WORD
=0	EA MOD DISP,J/BFETCH		;PROCEED IN ADDR EVAL
	SR DISP,J/CLEAN			;INTERRUPTED, CLEAN UP AS REQ'D
.TOC	"LOAD BYTE SUBROUTINE"
;ENTER WITH S IN FE, P+S IN SC, AND AR LOAD IN PROGRESS
;SKP INTERRUPT AT ENTRY IS OPTIONAL
;RETURN2 WITH BYTE RIGHT JUSTIFIED IN AR
;[TIME=7]
=1****0
LDB1:	AR_MEM,SC_#-SC,#/36.,SKP SCAD0,	;36-(P+S)
		TIME/3T,J/LDB2
	AR_MEM,SR DISP,J/CLEAN		;HERE IF INTERRUPT PENDING
=
=*1***0
LDB2:	ARX_SHIFT,AR_0S,SC_FE,J/SHIFT	;BYTE IN ARX HI, READY TO SHIFT
	ARX_AR,AR_0S,			;P+S > 36, PUT BYTE IN ARX HI
		SC_FE+SC,SKP SCAD0	;ADJUST S AND SHIFT BYTE

;PUT BYTE INTO AR RIGHT-JUSTIFIED
; THIS INSTRUCTION ALSO CALLED ALONE AS A SUBROUTINE

=1****0
SHIFT:	AR_SHIFT,RETURN2		;RETURN WITH BYTE IN AR
	RETURN2				;BYTE WAS OFF THE END, RETURN AR=0


.TOC	"DEPOSIT BYTE SUBROUTINE"
;ENTER WITH BYTE RIGHT JUSTIFIED IN AR, POINTER IN BR,
; S IN FE, 36-P IN SC, AND LOAD AR-ARX STARTED
; SKP IF P>36
;RETURN3 WITH FINAL STORE IN PROGRESS
;[TIME=11]

=1****0
DPB1:	MQ_AR,AR_MEM,ARX_MEM,		;GET WORD TO ROTATE 36-P
		GEN FE-SC,TIME/3T,	;COMPUTE S-(36-P)
		SKP SCAD0,J/DPB2	;CHECK THAT P+S<36
	MB WAIT,RETURN3			;P>36, STORE NOTHING

=*1***0
DPB2:	FE_SC				;P+S>36, S_36-P
	ARX_SHIFT,AR_MQ,SC_FE,		;ARX HAS P,X,S
		FE_#-SC,#/72.		;SC_S, FE_72-(36-P)=36+P
	SC_#-SC,#/36.			;SC_36-S (KNOWN .LE. P)
	AR_SHIFT,ARX_SHIFT,		;S,P,X
		SC_FE-SC		;SC_(36+P)-(36-S)=P+S
	AR_SHIFT,STORE,RETURN3		;DONE, STORE IT BACK
.TOC	"ADJBP"
;HERE FOR ADJUST BYTE POINTER (IBP WITH NON-ZERO AC)
; BYTE SIZE (S) IS RIGHT ADJUSTED IN BR AND MQ
; FULL POINTER IS IN AR, AND SAVED IN T0

.IF/ADJBP

ADJBP:	SC_P,AR+ARX+MQ_0.M,		;GET P
		SKP BR EQ		;CHECK SIZE IS NON-ZERO

=1***00
	BRX/ARX,P_SC,CALL.M,J/SIXDIV	;DIVIDE P BY S
	AR_T0,J/IFSTAC			;OOPS, S=0, RETURN UNALTERED POINTER
	T1_AR,AR_0S,ARX_0S,		;SAVE P/S
		SC_FE-SC		;36-P IN SC
=
=*1**0*
	P_SC,MQ_0.M,CALL.M,J/SIXDIV	;36-P IN AR0-5
	AR_AR+T1,SKP AD NE		;(P/S)+(36-P/S)=BYTES/WORD
=*1***0
	I FETCH,J/NODIVD		;ABORT, BYTES/WORD=0
	T1_AR,BR/AR,AR_ARX		;SAVE BYTES/WORD, READY TO
					; DIVIDE BY IT
	T2_AR,AR_MQ			;SAVE REMAIN(36-P/S), GET (36-P)/S
	AR_AR*AC0,AD/A+B,ARL/AD,	;ADJUSTMENT IN AR
		ARX+MQ_0.M

;COMPUTE QUOTIENT Q AND REMAINDER R OF ADJUSTMENT/(BYTES/WORD)
; SUCH THAT ADJUSTMENT=Q*(BYTES/WORD)+R, 1 .LE. R .LE. (BYTES/WORD)
; SINCE ADJUSTMENT IS CALCULATED RELATIVE TO LEFT-MOST BYTE OF
; A WORD, THIS GIVES Q AS THE NUMBER OF WORDS BY WHICH TO INDEX THE
; BYTE POINTER, AND R AS THE NUMBER OF BYTES FROM THE LEFT OF THE
; WORD.  MULTIPLYING R BY THE BYTE SIZE WILL GIVE THE NUMBER OF BITS
; FROM THE LEFTMOST BYTE, AND ADDING REMAIN(36-P/S) WILL GIVE NUMBER
; OF BITS FROM BIT 0.  FINALLY, WE MUST SUBTRACT THIS FROM 36 TO GET
; THE CORRECT P FIELD, WHICH IS ALWAYS RELATIVE TO THE RIGHT EDGE OF
; THE WORD.

=*1*100
	AC0_AR,SC_1,CALL,J/DIV2		;DO THE BASIC DIVIDE
=110	ARX_-BRX,FE_#,#/-4,J/ADJD1	;NEG QUO ==> NEG REMAIN
	ARX/MQ,SKP AR NE,FE_#,#/-4	;POS QUO.  IS REMAIN .GT. 0?
=1****0
ADJD1:	AR_AR+T1,J/ADJD2		;INCREASE REMAIN TO MEET CONSTRAINT
	BR/AR,AR_ARX (ADX),		;REMAIN IN RANGE,
		ARL+ARX_0.M,J/ADJD3	; QUOTIENT TO ARR

ADJD2:	BR/AR,AR_ARX-1,			;HOLD UPDATED REMAINDER,
		ARL+ARX_0.M		; GET CORRESPONDING QUOTIENT
ADJD3:	AR_AR+T0,INH CRY18,		;ADD Q TO Y OF POINTER,
		BRX/ARX			;CLR BRX

=1**00*
	AC0_AR,AR_0S,SC_S,CALL,J/GETSC	;SAVE UPDATED Y, GET SIZE
	MQ_AR,AR_T2,CLR ARX,		;M'IER IS S, GET REMAIN(36-P/S)
		CALL,J/MULREE		;COMPUTE (R*S)+REMAIN(36-P/S)
=11*	AR_ARX*2,I FETCH		;PUT THAT IN AR0-5
	SC_P-#,#/36.,AR_AC0
	P_-SC,J/STAC			;THAT'S NEW P, DONE

.ENDIF/ADJBP
;SUBROUTINE TO GET CONTENTS OF SC RIGHT ALIGNED IN AR
;[TIME=6]

GETSC:	AR0-8_SC			;PUT SC INTO AR
GETEXP:	ARX_AR,SC_#,#/9.,J/SHIFT	;HERE WITH DATA IN AR0-8


;SUBROUTINE FOR SHORT DIVISION, BR KNOWN POSITIVE
; CALL WITH MQ CLEAR, DIVISOR RIGHT-ALIGNED IN BR, AND DIVIDEND
;	IN AR0-5 (OR LEFT-ALIGNED IN ARX IF ENTERING AT SDIV)
; RETURN QUOTIENT IN AR AND MQ, REMAIN IN ARX
;[TIME=22+3(RESTORE REQ'D)]

;TO IMPROVE ADJBP PERFORMANCE, INSERT THE INSTRUCTION SHOWN BELOW
; (SIXDZ), AND CHANGE THE CALLS TO SIXDIV TO "SKP SCAD NE,J/SIXDZ"
;=0
;SIXDZ:	AR_0S,ARX_0S,FE_#,#/36.,RETURN2	;HERE IF DIVIDEND IS ZERO

SIXDIV:	ARX_AR,AR_0S,FE_#,#/4,J/SDIV-
=*1*0*0
SDIV:	DIVIDE,AR_2(AR+BR),ARX/ADX*2,J/SDIV
SDIV-:	DIVIDE,AR_2(AR-BR),ARX/ADX*2,J/SDIV
	DIVIDE,AR_AR+BR,J/SDIVR		;NO SHIFT ON FINAL STEP
	DIVIDE,AR_AR-BR
=1**1*0
SDIVR:	AR_AR+BR			;NO CRY0 MEANS RESTORE REQ'D
	ARX_AR,AR_MQ,			;RETURN QUO IN AR, REMAIN IN ARX
		FE_#,#/36.,RETURN2
