.TOC	"I/O INSTRUCTIONS"

; BITS 10-12 OF INSTRUCTION GET MAPPED TO IR 7-9 FOR I/O INSTRUCTIONS
; THE DEVICE ADDRESS IS BROKEN DOWN AS ONE OF THE FIRST 7, OR ALL OTHERS
	.DCODE

;DEVICE 000 (APR)

700:	W,		J/APRBI		;BLKI APR,	OPTIONS, SERIAL #
	W,	DATAI,	J/APRDI		;DATAI APR,	ADDRESS COMPARE
	I,		J/APRBO		;BLKO APR,	REFILL RAM
	R,	DATAO,	J/APRDO		;DATAO APR,	ADDRESS COMPARE
	I,	CONO,	J/APRCO		;CONO APR,	APR FLAGS
	I,	CONI,	J/APRCI		;CONI APR,
	I,	CONSZ,	J/APRCI		;CONSZ APR,
	I,	CONSO,	J/APRCI		;CONSO APR,

;DEVICE 004 (PI)

710:	W,	M,	J/PIBI		;BLKI PI,	READ ERA
	W,	B/3,	J/PIDI		;DATAI PI,	UNASSIGNED
	R,		J/PIBO		;BLKO PI,	SBUS DIAGNOSTIC
	R,	B/0,	J/PIDO		;DATAO PI,	UNASSIGNED
	I,	CONO,	J/PICO		;CONO PI,	PI SYSTEM CONTROL
	I,	CONI,	J/PICI		;CONI PI,	IN PROGRESS, ENABLE
	I,	CONSZ,	J/PICI
	I,	CONSO,	J/PICI

;DEVICE 010 (PAG)

720:	RW,	BLKI,	J/PAGBI		;BLKI PAG,	UNASSIGNED
	W,	DATAI,	J/PAGDI		;DATAI PAG,	USER CONTEXT
	I,		J/PAGBO		;BLKO PAG,	INVAL PAGE TABLE
	R,	DATAO,	J/PAGDO		;DATAO PAG,	USER CONTEXT
	I,	CONO,	J/PAGCO		;CONO PAG,	EXEC CONTEXT
	I,	CONI,	J/PAGCI		;CONI PAG,
	I,	CONSZ,	J/PAGCI
	I,	CONSO,	J/PAGCI

;DEVICE 014 (CCA)

730:	I,	J/SWEEP			;8 FUNCTIONS TO SWEEP THE CACHE
	I,	J/SWEEP	;SWPIA	INVALIDATE ALL CACHE, NO CORE UPDATE
	I,	J/SWEEP	;SWPVA	VALIDATE ALL CORE, LEAVE CACHE VALID
	I,	J/SWEEP	;SWPUA	UNLOAD ALL CACHE TO CORE, CLEAR CACHE
	I,	J/SWEEP
	I,	J/SWEEP	;SWPIO	INVALIDATE ONE PAGE
	I,	J/SWEEP	;SWPVO	VALIDATE ONE PAGE
	I,	J/SWEEP	;SWPUO	UNLOAD ONE PAGE
;I/O CONT'D

;DEVICE 020 (TIM)

740:	W,	B/1,	J/RDMTR		;BLKI TIM,	PERF CNT
	W,	B/0,	J/RDMTR		;DATAI TIM,	TIME BASE
	R,	DATAO,	J/TIMBO		;BLKO TIM,	PA ENABLES
.IFNOT/MUSIC
	R,	DATAO,	J/TIMDO		;DATAO TIM,	UNDEFINED
.IF/MUSIC
	I,	DATAO,	J/PLAY		;DATAO TIM,	MUSIC PLAYER
.ENDIF/MUSIC
	I,	CONO,	J/TIMCO		;CONO TIM,	SETUP INTERVAL TIMER
	I,	CONI,	J/TIMCI		;CONI TIM,	RD INTERVAL & PERIOD
	I,	CONSZ,	J/TIMCI
	I,	CONSO,	J/TIMCI

;DEVICE 024 (MTR)

750:	W,	B/3,	J/RDMTR		;BLKI MTR,	CACHE CNT
	W,	B/2,	J/RDMTR		;DATAI MTR,	EBOX CNT
	I,		J/UUO		;BLKO MTR,	UNDEFINED
	I,		J/UUO		;DATAO MTR,	UNDEFINED
	I,	CONO,	J/MTRCO		;CONO MTR,	ACCT & TB CTL
	I,	CONI,	J/MTRCI		;CONI MTR,	SAME
	I,	CONSZ,	J/MTRCI
	I,	CONSO,	J/MTRCI

;DEVICE 030

760:	RW,	BLKI,	J/BLKIO
	W,	DATAI,	J/IO
	RW,	BLKO,	J/BLKIO
	R,	DATAO,	J/IO
	I,	CONO,	J/CONO
	W,	CONI,	J/IO
	I,	CONSZ,	J/CONS
	I,	CONSO,	J/CONS

;DEVICES 034-774 (ALL OTHERS)

770:	RW,	BLKI,	J/BLKIO
	W,	DATAI,	J/IO
	RW,	BLKO,	J/BLKIO
	R,	DATAO,	J/IO
	I,	CONO,	J/CONO
	W,	CONI,	J/IO
	I,	CONSZ,	J/CONS
	I,	CONSO,	J/CONS

	.UCODE
.TOC	"EXTERNAL DEVICE I/O INSTRUCTIONS"

=00*000
BLKIO:	SKP IO LEGAL,CALL,J/IOCHK	;FIRST VERIFY INSTR VALIDITY
	BYTE DISP,J/BLK1		;TEST FPD
CONS:					;HERE FOR CONSO, CONSZ TO LOAD
					; BR IN CASE OF UUO
CONO:	BR/AR,ARL_ARR,ARR_ARR		;CONDITIONS TO BOTH HALVES
=10
IO:	FIN XFER,MB WAIT,		;WAIT FOR MBOX IF BLKI/O
		SKP IO LEGAL,CALL,J/GTEBUS
RELEEB:	REL ECL EBUS,B WRITE		;XFER DONE, WHAT TO DO?
=
=1*010
IOTEND:	FIN STORE,MB WAIT,J/BLK4	;BLKI/BLKO
	TEST AR.BR,TEST FETCH,J/NOP	;CONSZ
	MEM_AR,SKP PI CYCLE,J/IOFET	;DATA/CON I/O
	TEST AR.BR,TEST FETCH,J/NOP	;CONSO

;BLKO/BLKI SCREWED AROUND WITH TO TRY TO STOP PI LOSSAGE.
BLK4:	TEST BRL,TEST FETCH,SKP PI CYCLE,J/CLRFPD

=1****0
IOFET:	I FETCH,J/NOP			;HERE IF NOT PI CYCLE
	DISMISS,J/PIFET			;DISMISS INTRPT AFTER DATA/CON I/O

=1**010
BLK2:	MEM_AR,BR/AR,VMA_AR,B DISP,J/BLK3
BLK1:	AR_AR+1,GEN CRY18,STORE,J/BLK2	;UPDATE POINTER WORD
=111	SKP PI CYCLE,J/BLK2		;IF FPD & NOT PI, DON'T INCREMENT
=1*101					;DO DATAI OR DATAO
BLK3:	LOAD AR,SET FPD,J/IO		;GET DATA TO OUTPUT
	SET FPD,J/IO			;INPUT, DO IO BEFORE MEM
;NOTE NOTE NOTE SET FPD INHIBITED BY HARDWARE IF PI CYCLE (SCD5)

;SUBROUTINES TO HANDLE EBUS
;CALL WITH "SKP IO LEGAL"
;ENTER AFTER LOADING AR IF OUTPUT FUNCTION

=00
GTEBUS:	AR_BR,J/UUO			;HERE IF IO ILLEGAL IN THIS MODE
	REQ EBUS,CALL,J/WGRANT		;ASK PI SYSTEM FOR BUS
=11					;RETURN TO TRANSFER ROUTINE

;SUBROUTINE TO PERFORM EBUS TRANSFER
;SETUP CONTROLLER SELECT AND FUNCTION LINES BEFORE CALL
;IF OUTPUT, ALSO PUT AR ONTO EBUS DATA LINES

EBUSX:	GEN AR,TIME/5T,			;WAIT AFTER ASSERTING FUNCTION
		SET EBUS DEMAND,J/WXFER	; AFTER 300 NS, ASSERT DEMAND
=0
EBUSW:	AR_EBUS,GEN AR,
		CLR EBUS DEMAND,J/RELEB	;STROBE DATA AND DROP DEMAND
WXFER:	GEN AR,SKP -EBUS XFER,J/EBUSW	;WAIT FOR TRANSFER

RELEB:	GEN AR,REL EBUS,TIME/5T,	;DROP DATA, CS, AND FCN
		RETURN3			;AFTER 150 NS, THEN RELEASE BUS


;SUBROUTINE TO WAIT FOR PI SYSTEM TO GRANT EBUS
; IT WILL EITHER SEND EBUS GRANT, OR PI READY

=0
WGRANT:	SKP -EBUS GRANT,J/WGRNT1	;GOT IT?
	DROP EBUS REQ,J/TAKINT
=0
WGRNT1:	IO INIT,GEN AR,J/WGRNT2		;GOT IT, SETUP CS, FCN, AND DATA
	SKP INTRPT,J/WGRANT		;DIDN'T GET IT, TEST FOR INTERUPT
WGRNT2:	GEN AR,TIME/5T,			;JUST WAIT
		EBUS CTL/IO INIT,RETURN3

;HERE TO START PI CYCLE TRANSFER.  HOLD EBUS CTL SELECTION

EBUSI:	TIME/5T,EBUS CTL/DATAI,J/EBUSX
EBUSO:	GEN AR,TIME/5T,EBUS CTL/DATAO,J/EBUSX

;SUBROUTINES TO CHECK IO LEGALITY FOR INTERNAL I/O INSTRUCTIONS

2002:					;ACCESSIBLE ON EXTEND [0]
IOCHK:	AR_BR,J/UUO			;NAUGHTY, MUST'NT DO
2003:
RET1:	RETURN1				;ONE-CYCLE NULL ROUTINE

=0
GETEEB:	AR_BR,J/UUO			;IO ILLEGAL IN THIS MODE
GTEEB1:	GET ECL EBUS,RETURN1
.TOC	"INTERNAL DEVICE FUNCTIONS -- APR, CCA"

=00***0
SWEEP:	BR/AR,SC_#,#/9.,CALL,
		SKP IO LEGAL,J/IOCHK	;ALLOWED?
	AR_SHIFT			;MOVE PAGE # TO PLACE
=	VMA_AR,SWEEP CACHE		;START A SWEEP
MBREL:	MB WAIT,J/IFNOP			;COMPLETE REG FUNC BEFORE FETCH


=00**00
APRDO:	CALL,SKP IO LEGAL,J/GETEEB	;SET ADDR BREAK
	DATAO APR,J/RELEEB
APRBO:	BR/AR,CALL,SKP IO LEGAL,J/IOCHK	;SET CACHE REFILL ALGORITHM
	WR REFILL RAM,J/MBREL		;INFO ALREADY IN VMA
=

=00*000
APRDI:	CALL,SKP IO LEGAL,J/GETEEB	;READ ADDR BREAK
	DATAI APR(L),J/RELEEB
=010
APRBI:	CALL,SKP IO LEGAL,J/IOCHK	;RETURN MICRO VERSION, SERIAL #
	AR_SERIAL,TIME/3T,		;READ SERIAL NUMBER
		CALL,J/UVERS		;GET MICRO-CODE VERSION IN AR
=111	ARL_ARR.S,AR_BR			;COMB SERIAL WITH VERSION
=	AR0-8_#,#OPTIONS,STORE,J/STMEM	;SET OPTION FLAGS


=00**00
APRCO:	BR/AR,ARL_ARR.M,ARR_ARR,CALL.M,	;SET APR FLAGS
		SKP IO LEGAL,J/GETEEB
	CONO APR,J/RELEEB
APRCI:	BR/AR,CALL,
		SKP IO LEGAL,J/GETEEB	;READ APR FLAGS
	CONI APR(R)			;GET RIGHT HALF OF APR CONDITIONS
=	ARX_AR SWAP,CONI APR(L)		;NOW LH COND TO AR LEFT
	AR_ARX,ARL_ARL,J/RELEEB		;COMBINE HALVES
.TOC	"INTERNAL DEVICE FUNCTIONS -- PI"

=00*000
.IFNOT/INSTR.STAT
PIDO:
PIDI:	AR_BR,J/UUO			;DATAI/O PI, UNASSIGNED

.IF/INSTR.STAT
;DATAO PI, SETS UP BUFFER POINTERS FOR TRACKS
;DATAI PI, READS CURRENT BUFFER POINTER

PIDI:
PIDO:	BR/AR,ARL+ARX_0.M,CALL.M,	;CHECK IO LEGALITY
		SKP IO LEGAL,J/IOCHK
	SC_#,#/9.,B DISP,SKP BR0,J/PIDX	;NOW, WHAT TO DO?
.ENDIF/INSTR.STAT

PIBI:	READ ERA,J/RDEBRG		;GET AND STORE
=0
PIBO:	CALL,SKP IO LEGAL,J/IOCHK	;SBUS DIAGNOSTIC
	SBUS DIAG			;SEND THE DIAG FUNCTION FROM AR
=	AR/CACHE,VMA_VMA+1,
		STORE,J/STMEM		;GET AND STORE THE RESPONSE

=00*000
PICO:	BR/AR,ARL_ARR.M,ARR_ARR,
		CALL.M,SKP IO LEGAL,J/PICOM1
=11	CONO PI,J/PICOM2		;SEND THE DATA
=00*100
PICI:	BR/AR,CALL,SKP IO LEGAL,J/PICOM1
=11	CONI PI(R)			;READ RH TO AR LEFT
=	ARX_AR SWAP,			;RH COND TO ARX RH
		CONI PI(PAR)		; AND PARITY ENABLES TO RH
	BRX/ARX,ARX_AR,			;READY TO COMB RH PARTS
		CONI PI(L)		; AND LH TO AR LEFT
	AR_ARX*BRX,AD/OR,ARL_ARL	;COMBINE THEM
PICOM2:	REL EBUS,GEN AR,B WRITE,J/IOTEND

=0
PICOM1:	AR_BR,J/UUO			;LOSE
	REQ EBUS,J/WGRANT		;OK, WAIT TO GET FULL EBUS
.TOC	"TRACKS SUPPORT"

.IF/INSTR.STAT
=00
PIDX:	CLR TRACKS EN,J/IFNOP		;TURN TRACKS OFF
.IF/TRACKS
	ARX_SHIFT,ARL_BRL,ARR_0.S,J/PIDO2
.IFNOT/TRACKS
	TRX_AR,J/PIDO3			;SAVE TABLE PAGE #, TURN ON
.ENDIF/TRACKS

=11	AR_TRX				;READ BACK POINTER
	ARL_0.M				;GET INDEX PART
	AR_AR+TRB,STORE,J/STMEM		;DONE WITH DATAI

PIDO2:	TRX_AR,AR_ARX			;SET UP INDEX
	TRB_AR				;AND BASE
PIDO3:	SET TRACKS EN,J/IFNOP		;TURN TRACKS ON

.IF/TRACKS
;HERE WHEN NICOND FINDS TRACKS ENABLED
=0
TRK1:	TRX_AR,J/TRK2			;PUT BACK UPDATED INDEX
	AR_AR SWAP			;END OF BUFFER.  RESET
	AR_-AR,J/TRK1			; ORIGINAL INDEX

TRK2:	ARL_0.M
	VMA_AR+TRB			;ADDRESS TRACKS BUFFER
	AR_PC,STORE,PHYS REF		; PUT PC THERE
	MEM_AR,VMA/PC,CLR TRACKS EN	;PREVENT NICOND SEEING TRACKS
	SET TRACKS EN			;...UNTIL NEXT TIME
	DISP/NICOND,J/NEXT		;GO DO NEXT INSTR
.ENDIF/TRACKS
.IF/OP.CNT
;HERE WHEN NICOND FINDS OPCODE COUNTING ENABLED
; SKIP IF USER MODE

=0
OPCT1:	AR_TRX,SKP AC REF,J/OPCT2	;TRX HAS PAGE # FOR EXEC TABLE
	AR_TRX+1,SKP AC REF		; NEXT PAGE IS FOR USER
=0
OPCT2:	AR_SHIFT,J/OPCT3		;OPCODE INDEXES INTO TABLE
	ARX_FM(VMA),J/OPCT2		;GET INSTR FROM FM
OPCT3:	VMA_AR,LOAD AR,PHYS REF		;GET TABLE ENTRY
	AR_MEM
	AR_AR+1,STORE			;ADD THIS OCCURANCE TO IT
	MEM_AR,VMA_PC,CLR TRACKS EN
	SET TRACKS EN			;LET US GET BACK NEXT NICOND
	DISP/NICOND,J/NEXT		;GO DO INSTR IN ARX
.ENDIF/OP.CNT
.IF/OP.TIME
;HERE TO ADD UP TIME SPENT IN INSTR'S

OPTM1:	BR_AR LONG,AR_ARX,ARX_TRB,	;THIS INSTR TO AR, LAST TO ARX
		SKP AC REF
=0
OPTM2:	TRB_AR,J/OPTM3			;SAVE NEXT INSTR
	AR_FM(VMA),J/OPTM2		;GET NEXT INSTR FROM FM
OPTM3:	SC_#,#/9.,SKP USER		;WHICH TABLE SHALL WE USE?
=0	AR_TRX,J/OPTM4			;EXEC
	AR_TRX+1			;USER
OPTM4:	ARX_SHIFT,RD+CLR PA		;TABLE ADDR TO ARX, TIME TO AR
	VMA_ARX,LOAD ARX,PHYS REF	;GET TABLE ENTRY
	AR_AR-BR,ARL_0.S		;COMPENSATE TIME FOR THIS CODE
	BR/AR,AR_MEM,SKP AR18		;IF THIS WAS AN ENABLED STATE,
=0	AR_AR+BR,STORE			;WRITE IT BACK
	MEM_AR,VMA/PC			;NOW SETUP NEXT INSTR AGAIN
	ARX_BRX,SET TRK+PA EN		;RESTORE STATISTICS FLAGS
	DISP/NICOND,J/NEXT
.ENDIF/OP.TIME
.ENDIF/INSTR.STAT
.TOC	"INTERNAL DEVICE FUNCTIONS -- PAG"

=00**00
PAGBO:	BR/AR,CLR FE,CALL,		;INVALIDATE ONE PAGE TABLE LINE
		SKP IO LEGAL,J/IOCHK
PAGBO1:	PT SEL_INVAL,J/PTLOOP		;SETUP INITIAL PT WR SELECT
PAGDO:	ARX_AR (AD),ARR_ARL,ARL_ARL.M,	;SETUP USER CONTEXT
		CALL.M,SKP IO LEGAL,J/GETEEB
	DATAO PAG(L),AR_ARX		;SETUP AC BLOCKS, PREV CTXT
=	SKP AR2,SC_#,#/9.
=0
TIMCO1:	MTR CTL/CONO TIM,J/RELEEB	;DO NOT CHANGE UBR
	MQ_SHIFT,SKP AR18,AR_0S		;STORE ACCT?
=0	AR0-8_#,#/100,CALL,J/PAGD2	;YES, START WITH EBOX CNT
	VMA_MQ,LOAD UBR,J/CLRPT		;NO, JUST CLEAR PAGE TABLE
=0
PAGD2:	ARX_AR,SC_#,#/13.,CALL,J/EMTR	;UPDATE THE EBOX ACCT
	MB WAIT,AR0-8_#,#/140		;READY TO GET CACHE ACCT
	ARX_AR,SC_#,#/13.,J/CMTR	;RETURN ABOVE TO CLR PT


=00**00
PAGDI:	SC_#,#/70,SKP IO LEGAL,
		CALL,J/GETEEB
	DATAI PAG(L),CALL,J/PCTXT	;FIRST GET AC BLOCKS & CWSX
PAGBI:	AR_BR,J/UUO			;BLKI PAG, IS UNASSIGNED
	AR_SHIFT,ARL_BRL,J/RELEEB	;COMBINE UBR WITH AC BLKS, CWSX
=
PCTXT:	P_SC				;PLUG IN LOAD-ENABLE BITS
=1***0*
	BR/AR,AR_0S,READ UBR,		;ASK MBOX FOR UBR LOC'N
		CALL,J/XFERW		;NOW READ IT
	AR_EBUS REG
	ARX_AR,AR_0S,SC_#,#/27.,	;READY TO MOVE INTO POSITION
		RETURN3
=00**00
PAGCO:	BR/AR,ARL_ARR.M,ARR_ARR,ARX_0S,	;SET EXEC CONTEXT
		SKP IO LEGAL,CALL.M,J/GETEEB
	CONO PAG,J/SETEBR		;SET CACHE, SEC, TRAP EN FLAGS

PAGCI:	BR/AR,AR_0S,CALL,SKP IO LEGAL,	;READ EXEC CONTEXT
		SC_#,#/9.,J/GETEEB
	CONI PAG			;READ CACHE, SEC, TRAP EN
=
=1***0*
	ARX_AR SWAP,AR_0S,READ EBR,	;SETUP EPT LOC'N TO READ
		CALL,J/XFERW
	AR_EBUS REG,			;GET EBR IN AR
		BRX/ARX,ARX_0S		;SAVE FLAGS IN LH OF BRX
	ARX_SHIFT,REL ECL EBUS		;MOVE EBR LOC LEFT
	ARR_0.M,ADB/BR,ADA EN/EN,AD/OR,ARL/ADX	;COMBINE, THEN PUT IN RH
	AR_AR SWAP,B WRITE,J/IOTEND	;STORE THE RESULT
;HERE TO FINISH CONO PAG,

=1***0*
SETEBR:	SC_#,#/9.,CALL,J/SHIFT		;MOVE EBR LOC'N TO POSITION
	VMA_AR,LOAD EBR,J/CLRPT		;SETUP EBR

;HERE TO CLEAR HWARE PAGE TABLE
; AFTER SETTING EBR OR UBR

CLRPT:	REL ECL EBUS			;DON'T HANG UP BUS FOR THIS
=0*
CLRPT1:	AR_1,CLR ARX,MB WAIT,		;WAIT FOR U/E BR LOAD
		SC_#,#/12.,CALL,J/SHIFT	;GET 1B23
	BR/AR,AR_0S,VMA/AD,		;START CLEARING AT ZERO
		FE_#,#/63.,J/PAGBO1	;SETUP LOOP COUNT
=110
PTLOOP:	AR_AR+BR,VMA/AD,FE_FE-1,	;SELECT A LINE OF PT
		CLR PT LINE,TIME/3T,	;DO THE WORK
		BYTE DISP,J/PTLOOP	;LOOP TO CLEAR ALL
	PT SEL_NORMAL,J/IFNOP		;RESET PT WR SELECTION
.TOC	"INTERNAL DEVICE FUNCTIONS -- TIM & MTR"

=00***0
RDMTR:	AR_BR,CALL,			;GET E TO AR
		SKP IO LEGAL,J/GETEEB	;GRAB CONTROL OF EBUS
	MQ_AR,AR_0S,			;SAVE E IN MQ
		SC_#,#/13.,B DISP	;WHICH COUNTER?
=
=00	AR_TIME BASE,J/RDMTR1		;DATAI TIM,
	AR_PERF CNT,J/RDMTR1		;BLKI TIM,
	AR_EBOX CNT,J/RDMTR1		;DATAI MTR,
	AR_CACHE CNT,J/RDMTR1		;BLKI MTR,

=0
RDMTR1:	ARL+ARX_0.M,B DISP,		;SHIFT COUNT INTO POSITION
		CALL.M,J/MTRDBL		;ADD DOUBLE WORD FROM PT
	AR_AR+BR LONG,REL ECL EBUS
	VMA_MQ,STORE,SC_#,#/35.,J/DMVM1	;STORE TOTAL AT E & E+1

=00**00
TIMCO:	BR/AR,CALL,SKP IO LEGAL,J/GETEEB
	CONO TIM,J/TIMCO1
TIMCI:	BR/AR,AR_0S,CALL,
		SKP IO LEGAL,J/GETEEB
	AR_INTERVAL			;INTERVAL GOES TO LH
=	ARX_AR SWAP,AR_0S
	AR_PERIOD			;PERIOD TO RH
TIMBO1:	MTR CTL/LD PA LH,		;KEEP MTR DECODE FOR TIMBO
		ARL_ARXL,J/RELEEB	;COMBINE PERIOD WITH INTERVAL

=00**00
MTRCO:	BR/AR,ARL_ARR.M,ARR_ARR,
		CALL.M,SKP IO LEGAL,J/GETEEB
	CONO MTR,J/MTRCO1
MTRCI:	BR/AR,AR_0S,CALL,
		SKP IO LEGAL,J/GETEEB
	CONI MTR			;READ BACK CONDITIONS
=
MTRCO1:	ARL_0.S,MTR CTL/CONO MTR,J/RELEEB

=00*000		;only =00***0 needed except dram bites the bag
		;so try to hack TIMBO and TIMDO into nearby addresses
TIMBO:	ARX_AR,AR_0S,CALL,		;SAVE ENABLES, CLEAR AR
		SKP IO LEGAL,J/GETEEB	;CHECK LEGALITY, GET BUS
	BLKO TIM(L),AR_ARX		;TURN OFF BY CLEARING LH ENABLES
	BLKO TIM(R),AR_AR SWAP		;SEND RH
	BLKO TIM(L),J/TIMBO1		;SEND LH, TURNING ON AGAIN

.IFNOT/MUSIC
TIMDO:	AR_BR,J/UUO			;DATAO TIM, UNDEFINED
.IF/MUSIC
PLAY:	SKP PI CYCLE,BR/AR,AR_MUSTIM,J/PLAY0	;MUSIC PLAYER
.ENDIF/MUSIC
=
;HERE WHEN METER INCREMENT REQUEST DETECTED

MTRREQ:	GET ECL EBUS			;TAKE CONTROL OF BUS
	AR_MTR REQ			;WHAT TYPE REQUEST?
=0	MQ_AR,AR_AR*2,CALL,		;GET READY TO DISP
		VMA_#,#/514,J/MTRRQ0
	REL ECL EBUS			;DONE
	SET ACCOUNT EN,J/PIFET		;FETCH NEXT INSTR

MTRRQ0:	ARX_AR SWAP,DISP/SH0-3,AR_0S,	;DISPATCH ON REQUEST TYPE
		SC_#,#/13.
=000
	RD+CLR TB,J/TMTR1		;TIME BASE
	RD+CLR PA,J/PMTR1		;PERF ANALYSIS CNT
EMTR:	RD+CLR E CNT,J/EMTR1		;EBOX CNT
CMTR:	RD+CLR C CNT,J/CMTR1		;CACHE CNT
	REL ECL EBUS			;INTERVAL -- VECTOR INTERRUPT
=	SET PI CYCLE
	SET ACCOUNT EN,J/PIINST

TMTR1:	MTR CTL/CLR TIME,J/MTRRQ1	;HOLD SELECTS FOR
PMTR1:	MTR CTL/CLR PERF,J/MTRRQ1	;MTR CTL FUNCTION
EMTR1:	MTR CTL/CLR E CNT,J/MTRRQ1	; TO PREVENT RACE
CMTR1:	MTR CTL/CLR M CNT,J/MTRRQ1	; AND POSSIBLE GLITCHES

;HERE WITH RELEVANT COUNT IN ARR, GARBAGE IN ARL

=0
MTRRQ1:	ARL+ARX_0.M,ARX0-3 DISP,	;CLEAR GARBAGE & RE-DISPATCH
		CALL.M,J/MTRDBL		; TO ADD DOUBLE COUNTER FROM PT
	AR_AR+BR LONG,SC_#,#/35.,
		VMA_VMA-1,STORE		;STORE BACK IN PROCESS TABLE
	MEM_AR,AR_0S,ABORT INSTR	;HI PART TO MEM
	AR_SHIFT,VMA_VMA+1,STORE,RETURN1

;HERE TO PICK UP DOUBLEWORD FROM PROCESS TABLE
; AND ADD CURRENT CONTENTS OF APPROPRIATE METER

=00
MTRDBL:	AR_0S,ARX_SHIFT,
		VMA_#,#/510,J/RDEMTR	;TIME BASE IN EPT 510-511
	AR_0S,ARX_SHIFT,
		VMA_#,#/512,J/RDEMTR	;PERF CNT IN EPT 512-513
	AR_0S,ARX_SHIFT,
		VMA_#,#/504,J/RDUMTR	;EBOX ACCT IN UPT 504-505
	AR_0S,ARX_SHIFT,
		VMA_#,#/506,J/RDUMTR	;CACHE ACCT IN UPT 506-507

RDEMTR:	BR_AR LONG,			;SAVE COUNT IN BR!BRX
		LOAD AR,EPT REF,J/RDMTR2;GET HIGH WORD FROM EPT
RDUMTR:	BR_AR LONG,LOAD AR,UPT REF	; OR UPT AS APPROP
=0*
RDMTR2:	FIN XFER,VMA_VMA+1,LOAD ARX,	;NOW GET LOW WORD
		CALL,J/XFERW		;GO WAIT FOR IT
	ARX_ARX*2,RETURN1
.TOC	"PRIORITY INTERRUPT PROCESSING"
;HERE WHEN PRIORITY INTERRUPT REQUEST DETECTED
;PI LOGIC HAS DONE HANDSHAKE TO BRING FUNCTION WORD IN ON EBUS
; FUNCTION WORD IS NOW IN AR, SC=2

;THE FORMAT OF THE FUNCTION WORD IS --
;    0-2	ADDRESS SPACE FOR THE FUNCTION
;	0=EPT
;	1=EXEC VIRTUAL
;	4=PHYSICAL
;	OTHERS UNDEFINED
;    3-5	FUNCTION TO PERFORM (SEE LIST BELOW AT PIDISP)
;      6	FUNCTION QUALIFIER
;   7-10	PHYSICAL DEVICE # ON EBUS
;  11-12	UNDEFINED
;  13-35	ADDRESS FOR FUNCTION

;IN THE CASE OF A STANDARD OR A VECTOR INTERRUPT, THE 'FE'
;REGISTER, WHICH IS NOT CLOBBERED BY THE BASIC INSTRUCTION
;LOOP NOR BY BLKO/BLKI, IS USED TO REMEMBER WHETHER IT WAS
;A STANDARD OR A VECTOR INTERRUPT. (0 FOR STANDARD,
;-1 FOR VECTOR.)  IN THE CASE OF A VECTOR
;INTERRUPT, AC 'T0' IS USED TO REMEMBER THE FUNCTION WORD.
;THIS ALLOWS THE CORRECT ADDRESS FOR THE SECOND WORD OF
;A TWO-WORD INTERRUPT TO BE DETERMINED.  THIS MAKES THE
;MIT IMPTERFACE WORK.  NOTE THAT THIS HACK DOES NOT WORK
;FOR DTE20 OR RH20 VECTOR INTERRUPTS, BUT NO ONE WOULD
;EVER USE BLKO/BLKI WITH THOSE DEVICES.
;[COST = 2 WORDS]

PICYC1:	SET PI CYCLE,SH DISP		;START PI CYCLE
=1000					;3-5 IS FUNCTION TO PERFORM
PIDISP:	VMA_40+PI*2,CLR FE,J/PIINST	;(0) STANDARD INTERRUPT
	VMA_40+PI*2,CLR FE,J/PIINST	;(1) DITTO
	MQ_AR,T0_AR,J/PIVECT		;(2) VECTOR
	VMA_AR,MQ_AR,LOAD AR,J/PIINCR	;(3) INCREMENT
	VMA_AR,MQ_AR,SKP AR6,J/PIDATO	;(4) DATAO
	VMA_AR,MQ_AR,TIME/5T,J/PIDATI	;(5) DATAI
	MQ_AR,AR_AR*4,SKP AR6,J/PIBYTE	;(6) BYTE TRANSFER
	VMA_40+PI*2,CLR FE,J/PIINST	;(7) UNDEFINED

;HERE FOR 2ND INTERRUPT INSTRUCTION (PI OV)
=110
PICYC2:	VMA_41+PI*2,J/PIINST		;2ND PART OF STD INT
PICY2V:	VMA_T0+1,LOAD ARX,J/XCTW	;2ND PART OF VECTOR INT

PIINST:	EPT FETCH,J/XCTW		;SAVE INSTRUCTION ADDRESS

PIVECT:
.IF/KI INTERRUPT LOSES			;KLUDGE
;IN AC BLK 7, R4 GETS PI FCN WD, R5 GETS PI LEVEL
;(ONLY ON VECTOR INTERRUPTS)
	E0_AR,MQ_AR
	VMA_40+PI*2
	COND/LD VMA HELD
	AR_VMA HELD
	E1_AR
	AR_MQ
.ENDIF/KI INTERRUPT LOSES		;END OF KLUDGE
	AR_AR*4,SC_#,#/5		;HERE FOR VECTOR INTR
	FE_# AND S,#/30,AR_0S,SH DISP	;WHAT KIND OF DEVICE?
=0011	VMA_MQ,EPT FETCH,J/XCTW		;CHAN 0-3
	VMA_MQ,EPT FETCH,J/XCTW		;CHAN 4-7
	AR0-8_FE+#,#/142,J/DTEVEC	;DTE 0-3
.IFNOT/KI INTERRUPT LOSES
	VMA_MQ,LOAD ARX,FE_-1,J/XCTW	;EXTERNAL DEVICE
.IF/KI INTERRUPT LOSES
	AR_MQ,ARL_0S			;EXTERNAL DEVICE
	SKP AR NE			;SEE IF ADDR = 0
=0				
	DISMISS				;YES, FLUSH
	VMA_MQ,LOAD ARX,FE_-1,J/XCTW	;NO, TAKE THE INT
.ENDIF/KI INTERRUPT LOSES

=0*
DTEVEC:	ARX_AR,AR_0S,SC_#,#/9.,CALL,J/SHIFT
	VMA_AR,EPT FETCH,J/XCTW

=0101
PILD:	LOAD AR,EPT REF,J/XFERW		;GET DATUM FROM EPT
	LOAD AR,J/XFERW			; OR EXEC VIRTUAL ADDR SPACE
	VMA_AR,READ EBR,J/PIKLG1	; OR PHYSICAL MEMORY, AS REQUESTED
	J/PIDONE			;IN CASE OF EBUS PROBLEMS

;KLUDGE - NEED MEM/REG FUNC TO LOAD VMA EXT
PIKLG1:	LOAD AR,PHYS REF,J/XFERW	;NOW DO THE MEMORY CYCLE

;HERE TO PERFORM INCREMENT FUNCTION

PIINCR:	AR_MEM,SKP AR6			;GET WORD, INCR OR DECR?
=0	AR_AR+1,STORE,J/PIDONE
	AR_AR-1,STORE,J/PIDONE
;HERE FOR DATAO (EXAMINE) FUNCTION

=0000
PIDATO:	AR0-3 DISP,CALL.M,J/PILD	;GET DATA FROM REQUESTED ADR SPC
	AR_AR*4,SC_#,#/13.,
		CALL,J/RDEX		;RESTRICTED EXAMINE
PIOUT:	AR_MEM,SET DATAO,CALL,J/EBUSO	;SEND DATA
PIDONE:	MEM_AR,DISMISS			;DONE, DISMISS & RESUME NORMAL
PIFET:	VMA/PC,FETCH,J/NOP		;RESUME AS BEFORE
=0101	VMA_AR-1,CALL,J/DEXCHK		;GO PROT/RELOC THIS EXAM
=0111	VMA_AR+BR,LOAD AR,PHYS REF,J/PIOUT
=1111	J/PIOUT				;PROT VIOLATION.  SEND 0

;HERE FOR DATAI (DEPOSIT) FUNCTION

=10
PIDATI:	SET DATAI,TIME/5T,CALL,J/EBUSI	;READ THE DATA
	ARX_AR,AR_MQ			;DATUM TO ARX, GET FCN WORD
	BRX/ARX,SKP AR6			;RESTRICTED?
=0000	AR0-3 DISP,ARX_AR,J/PIST	;NO, STORE AS REQUESTED
	AR_AR*4,SC_#,#/13.,CALL,J/RDEX	;YES, GET PROT/RELOC ADDR
=0101	VMA_AR+1,CALL,J/DEXCHK		;VERIFY LEGALITY
=0111	VMA_AR+BR,J/PSTOR		;GO STORE RELOCATED
=1111	J/PIDONE			;PROT VIOLATION, STORE NOTHING

=0101
PIST:	AR_BRX,STORE,EPT REF,J/PIDONE
	AR_BRX,STORE,J/PIDONE
PSTOR:	VMA_ARX,READ EBR,J/PIKLG2	;KLUDGE TO SET VMA EXT
	J/PIDONE

PIKLG2:	AR_BRX,STORE,PHYS REF,J/PIDONE	;NOW DO THE MEM CYCLE

=10
RDEX:	FE_# AND S,#/30,AR_MQ,CLR ARX,	;DTE# *8 TO FE, ADDR TO AR
		CALL,J/ROTS
	AR_SHIFT			;ADDRESS NOW IN AR
	BR/AR,AR0-8_FE+#,#/145		;SAVE ADDR TO BR, GET EPT LOC
GTAR08:	ARX_AR,AR_0S,SC_#,#/9.
	AR_SHIFT,RETURN4

=0*
DEXCHK:	CALL,J/PILD			;PROTECTION WORD FROM EPT
	SKP AR GT BR			;ALLOWED?
=0	AR_0S,RETURN12			;NO, SEND 0, STORE NOTHING
	VMA_VMA+1,LOAD AR,EPT REF,J/XFERW	;YES, GET RELOCATION WORD
;HERE FOR BYTE TRANSFERS

=000
PIBYTE:	FE_# AND S,#/30,CALL,J/PIBPA	;OUT... GET BP ADDR
	SET DATAI,CALL,J/EBUSI		;IN ... FIRST READ THE DATA
=011	ARX_AR,AR_MQ*4,J/PIDPB		;GOT IT, GO DEPOSIT IT

=100	VMA_AR,CALL,J/PIIBP		;GO INCREMENT OUTPUT BP
	SC_FE+SC,CALL,J/LDB1		;GO LOAD BYTE FROM IT
=111	J/PIOUT				;THEN SEND BYTE

=000
PIDPB:	BRX/ARX,FE_# AND S,#/30,	;HERE WITH INPUT DATA
		CALL,J/PIBPA
=100	VMA_AR+1,CALL,J/PIIBP		;GO INCREMENT INPUT BYTE PTR
	AR_BRX,SC_#-SC,#/36.,		;STORE BYTE WITH IT
		SKP SCAD0,CALL,J/DPB1
=111	J/PIDONE

PIBPA:	AR0-8_FE+#,#/140,J/GTAR08

=00*
PIIBP:	CALL,J/PILD			;GET POINTER FROM EPT
	P_P-S,SKP SCAD0,CALL.M,J/IBPS	;INCREMENT IT
=11*	ARX_AR,SC_P,J/BYTEA		;NOW EVALUATE ITS ADDR
.TOC	"KL-MODE PAGE REFILL LOGIC"

.IF/KLPAGE
;HERE ON ANY PAGE FAILURE
;THE POSSIBLE CAUSES ARE --
;  1:	A PARITY ERROR WAS DETECTED IN AR OR ARX FOLLOWING A READ
;	REFERENCE.  IN THIS CASE WE SAVE THE BAD WORD IN A RESERVED
;	LOCATION IN FAST MEMORY BLOCK 7, AND RETURN A PAGE FAIL CODE
;	INDICATING THE ERROR.
;  2:	THE MBOX DETECTED A PROPRIETARY VIOLATION OR PAGE TABLE PARITY
;	ERROR, OR THE EBOX FOUND THE SELECTED ADDRESS BREAK CONDITION.
;	IN THIS CASE, WE RETURN THE PAGE FAIL CODE GENERATED BY THE
;	MBOX (SEE PRINT PAG4).
;  3:	A REFERENCE OCCURRED FOR A VIRTUAL PAGE FOR WHICH THE HARDWARE
;	PAGE TABLE DIRECTORY HAD NO VALID MATCH.  IN THIS CASE, WE
;	WRITE THE PAGE TABLE DIRECTORY FROM THE VMA, AND CLEAR THE
;	ACCESS BITS FOR ALL PAGE ENTRIES CONTROLLED BY THE SELECTED
;	DIRECTORY ENTRY.  WE THEN JOIN THE REFILL CODE, BELOW.
;  4:	A REFERENCE OCCURRED FOR A VIRTUAL PAGE FOR WHICH THE ACCESS BIT
;	IN THE HARDWARE PAGE TABLE WAS OFF, OR A WRITE OCCURRED TO A
;	PAGE WHOSE WRITABLE BIT WAS OFF.  IN THIS CASE, WE EVALUATE THE
;	PAGING POINTERS IN CORE TO DETERMINE WHETHER THE ACCESS SHOULD
;	BE ALLOWED, AND IF SO, THE PHYSICAL PAGE TO WHICH IT SHOULD BE
;	TRANSLATED.  WE THEN EITHER PAGE FAULT, OR WRITE A PAGE ENTRY
;	INTO THE HARDWARE PAGE TABLE AND RESTART THE REFERENCE.


2377:	CLR ACCOUNT EN,FORCE AR-ARX,J/PF1
1777:	CLR ACCOUNT EN,FORCE AR-ARX
PF1:	SV.AR_AR,AR_ARX			;SAVE CURRENT AR
	SV.ARX_AR			; AND ARX IN CASE PARITY ERROR
	GET ECL EBUS,PF DISP,J/PF2
=1100
PF2:					;ANY PARITY ERROR?
=1101	AR_SV.AR,SC_#,#/156,		;YES.  AR HAS THE BAD WORD.
		SKP RPW,J/PFPAR		;CHECK FOR MIDDLE OF RPW CYCLE
	AR_SV.ARX,SC_#,#/157,J/PFPAR	;YES.  ARX HAS THE BAD WORD.
;	BAG-BITING NO-OP		;ARX PARITY ERROR IS
;					;FRAUDULENT EVEN IN REV.7
	AR_EBUS REG,MB WAIT,J/PF3	;NO. GET PAGE FAIL WORD

;HERE ON ANY PARITY ERROR
;SKIP IF MIDDLE OF READ-PAUSE-WRITE CYCLE, IN WHICH CASE WE
; MUST WRITEBACK THE DATA TO PREVENT INCOMPLETE CYCLE
=0
PFPAR:	VMA_VMA HELD,MAP,J/PFPAR1	;GET MAP INFO ON REF
	STORE,J/PFPAR			;WRITEBACK WITH GOOD PARITY
PFPAR1:	SV.PAR_AR,MB WAIT,		;SAVE WORD WITH BAD PARITY
		SC_#+SC,#/160		;GET PF CODE 36 OR 37
	AR_EBUS REG			;READ MAP INFO
	P_P OR SC,J/PF3			;INSERT PF CODE
;HERE WITH PAGE FAIL WORD IN AR

PF3:	REL ECL EBUS,PF DISP		;EBOX HANDLING?
=0111	SV.PFW_AR,SR DISP,J/CLEAN	;NO, GO CLEAN UP
	SV.PFW_AR,AR_BR,BR/AR		;YES, GET BR TOO
	SV.BR_AR,AR_0S			;SAVE BR
	AR0-8_FE			;NOW SAVE 10-BIT REGS
	ARX_AR (AD),AR0-8_SC		;FE TO ARX, SC TO AR
	ARR_ARL,ARL_ARX (ADX),		;FE IN ARL, SC IN ARR
		ARX_VMA HELD		;GET VMA WHICH FAILED
	SV.SC_AR,AR_ARX,		;HOLD SC & FE
		GEN BR*2,SIGNS DISP	;TEST FOR PT DIR MATCH
=110
PGRF1:
.IFNOT/ITSPAGE
	SV.VMA_AR,AR_AR SWAP,		;GET SEC # TO AR32-35
		EA MOD DISP,J/PGRF2	; SEC < 20?
.IF/ITSPAGE
	SV.VMA_AR,J/PGRF2		;AR, ARX HAVE VMA; BR HAS PFW
.ENDIF/ITSPAGE

.IFNOT/PT DIR VAL BUG
;HERE TO WRITE PT DIR, & CLR 4 PAGE ENTRIES

	AR_0S,COND/MBOX CTL,MBOX CTL/2,	;READY TO CLEAR EVEN PAIR
		FE_P AND #,#/2,SC/SCAD	;GET WRITE REF BIT TO FE & SC
	COND/MBOX CTL,MBOX CTL/33,	;CLR EVEN, WR DIR, SEL ODD
		TIME/3T,FE_FE+SC,SC/SCAD; WR REF = 4 NOW
	COND/MBOX CTL,MBOX CTL/10,	;CLR ODD, RESET NORMAL SELECT
		TIME/3T,FE_FE+SC,AR_BR	;GET PFW BACK, WR REF = 10
	SC_# AND AR0-8,#/401		;GET USER & PAGED REF BITS
	AR0-8_FE OR SC			;COMBINE WITH WR REF BIT
	SV.PFW_AR,BR/AR,AR_ARX,J/PGRF1	;REJOIN MAIN PATH
.IF/PT DIR VAL BUG
;HERE IF NO PT DIR MATCH.  MUST WRITE ZEROS INTO THE PAGE TABLE
;LOCATIONS THAT COME UNDER THIS DIR ENTRY, AND WRITE THE DIR ENTRY.
;BECAUSE THE PT DIR VAL BITS COME IN PAIRS
;(ONE FOR EACH 2K), AND THERE IS A HARDWARE BUG THAT SOMETIMES CONFUSES
;THE TWO BITS IN A PAIR, WE ARRANGE FOR THE TWO BITS ALWAYS TO HAVE
;THE SAME VALUE BY CLEARING BOTH SETS OF PAGE TABLE ENTRIES.

					;FIRST CLR THE 4 P ADDRESSED
	SV.VMA_AR,AR_1 LONG		;AR := 0, ARX := 1
	COND/MBOX CTL,MBOX CTL/2,	;READY TO CLEAR EVEN PAIR
		ARX_ARX*4		;ARX := 4
	COND/MBOX CTL,MBOX CTL/33,TIME/3T, ;CLR EVEN, WR DIR, SEL ODD
		ARX_ARX*8		;ARX := 40
	COND/MBOX CTL,MBOX CTL/10,TIME/3T, ;CLR ODD, RESET NORMAL SELECT
		ARX_ARX*8		;ARX := 400
	COND/MBOX CTL,MBOX CTL/2,	;READY TO CLEAR EVEN PAIR
		ARX_ARX*8		;ARX := 4000
	GEN ARX*SV.VMA,AD/XOR,VMA/AD	;SET UP VMA TO OTHER GROUP OF 4 P
	GEN SV.PFW,SKP AD0		;COMPENSATE FOR HARDWARE BUG
=0	EXEC REF,J/PTDC1
	USER REF,J/PTDC1
PTDC1:	COND/MBOX CTL,MBOX CTL/33,TIME/3T  ;CLR EVEN, WR DIR, SEL ODD
	COND/MBOX CTL,MBOX CTL/10,TIME/3T, ;CLR ODD, RESET NORMAL SELECT
		AR_BR,FE_#,#/10		;AR GETS PFW, FE GETS WRITE REF BIT
.IFNOT/ITSPAGE				;CORRECT THE PAGE FAIL CODE
	SC_# AND AR0-8,#/401		;SC GETS USER AND PAGED REF BITS
	AR0-8_FE OR SC			;COMBINE WITH WR REF BIT
	SV.PFW_AR,BR/AR			;STORE CORRECTED PFW
	AR_SV.VMA			;NOW DO WHAT PGRF1 DOES
	ARX_AR,AR_AR SWAP,		;GET SEC # TO AR32-35
		EA MOD DISP,J/PGRF2	; SEC < 20?
.IF/ITSPAGE
	AR_SV.VMA,ARX_SV.VMA,J/PGRF2	;AR, ARX HAVE VMA; BR HAS PFW
.ENDIF/ITSPAGE

.ENDIF/PT DIR VAL BUG

.IFNOT/ITSPAGE

;HERE TO TRACE PAGE POINTERS FOR THIS ADDRESS
;VMA WHICH FAILED IS IN ARX AND IN AR WITH THE HALVES SWAPPED
;PAGE FAIL WORD IS IN BR

=01
PGRF2:	VMA_#+AR32-35,#/440,		;YES.
		SIGNS DISP,J/PGRF3	; USER REF?
	VMA_#+AR32-35,#/460,		;NO
		SIGNS DISP,J/PGRF3
=101
PGRF3:	LOAD AR,EPT REF,		;GET SEC PTR FROM EPT
		ARX_AR,FE_-1,J/SECPTR	;PAGE NO TO ARX0-8
	LOAD AR,UPT REF,ARX_AR,FE_-1	;SEC PTR FROM UPT

;HERE TO FIND PAGE MAP WITH SECTION POINTER

SECPTR:	AR_MEM,SC_#,#/9			;GET SECTION POINTER
	FE_FE AND AR0-8,BR/AR,		;COMBINE ACCESS BITS
		ARL_0.M,AR0-3 DISP	;SPT INDEX IN ARR, DISP ON TYPE
=1001	AR_SV.BR,J/PFT			;NO ACCESS TO SECTION
SECIMM:	AR_SHIFT,VMA_AR+CBR,J/PGRF5	;IMMEDIATE
LDIND:	VMA_AR+SBR,J/GTSPT		;SHARED SEC = INDRCT PAG
	VMA_AR+SBR,AR_ARX		;INDRCT SEC.  LOOK IN SPT
	BR/AR,AR_BR,LOAD AR,PHYS REF	;CALL FOR SPT ENTRY
	ARX_SHIFT,AR_MEM		;WORD IN PT TO ARX0-8
	AR_SHIFT,ARX_BR			;NEW SEC PTR ADDR TO AR
	GEN # AND AR0-8,#/77,SKP SCAD NE,
		VMA_AR
=0	LOAD AR,PHYS REF,J/SECPTR
	AR_SV.BR,J/PFT			;TRAP, SEC MAP NOT IN CORE

GTSPT:	LOAD AR,PHYS REF		;GET PAGE TABLE ADDR
	AR_MEM,J/SECIMM

;HERE WITH PAGE NO OF PAGE TABLE IN AR,
; VIRTUAL PAGE NO WITHIN SECTION IN ARX0-8

PGRF5:	GEN # AND AR0-8,#/77,		;IS PAGE TABLE IN CORE?
		SKP SCAD NE
=0	LOAD AR,PHYS REF,		;GET CST ENTRY FOR PAGE TABLE
		BR/AR,J/PGRF6		;SAVE PAGE PTR ADDR IN BR
	AR_SV.BR,J/PFT			;NOT IN CORE, PAGE FAIL TRAP
PGRF6:	AR_MEM,FE_FE AND #,#/164	;HERE IS CST FOR PAGE TABLE
	AR_AR AND CSMSK,SKP P NE	;BEGIN CST UPDATE
=0	AR_SV.BR,J/PFT			;AGE TRAP, PT BEING SWAPPED
	AR_AR OR PUR,STORE		;PUT CST WORD BACK
	MEM_AR,VMA_BR
	LOAD AR,PHYS REF		;GET PAGE MAP ENTRY
	AR_MEM,FE_FE OR #,#/100		;PAGE POINTER
;HERE WITH PAGE MAP ENTRY IN AR
;FE HAS ACCUMULATED ACCESS BITS -- APWSC*4, S HAS BEEN CLEARED
;SC CONTAINS 9.

	FE_FE AND AR0-8,AR0-3 DISP,	;COMBINE PWSC, DISP ON TYPE
		ARX_SV.VMA		;GET BACK SAVED VMA
=1001	AR_SV.BR,J/PFT			;0=NO ACCESS
LDIMM:	ARL_SHIFT,FE_FE SHRT,		;1=IMMEDIATE, LOAD PT
		ARX_ARX*2 COMP,		; GET -WR REF TO ARX03
		SC_1,J/LDPT		; READY TO TEST WR REF BIT
	VMA_AR+SBR,J/LDSHR		;2=SHARED, GET SPT ENTRY
	ARL_0.M,ARX_SHIFT,J/LDIND	;3=INDIRECT, LOOP

;HERE TO GET SHARED PAGE POINTER OUT OF SPT

LDSHR:	LOAD AR,PHYS REF
	AR_MEM,FE_FE OR #,#/100,J/LDIMM	;TREAT SPT ENTRY AS IMMED

;HERE WITH IMMEDIATE PAGE NO IN AR TO LOAD INTO PT

LDPT:	GEN # AND AR0-8,#/77,SKP SCAD NE,	;PAGE IN CORE?
		ARX_AR,AR_ARX*.25	;GET -WR REF TO AR05
=0	VMA_ARX+CBR,AR_ARX,		;PAGE IS IN CORE.  GET CST
		SC_P AND SC,J/GTCST	;-WR REF TO SC
	AR_SV.BR,J/PFT			;PAGE NOT IN CORE

;NOW GET CST ENTRY FOR THIS PAGE

GTCST:	LOAD AR,PHYS REF,ARX_AR SWAP,
		SC_-SC,AR_1		;SC=0 IF WR REF, ELSE -1
	GEN FE AND #,#/10,SKP SCAD NE,	;SKIP IF WRITABLE
		BR/AR,MB WAIT		;GET CST ENTRY & BIT FOR TESTING
=0	GEN P AND SC,SKP SCAD NE,	;FAIL IF WRITING OR AGE=0
		AR_AR AND CSMSK,J/NOTWR	;STRIP OLD AGE FROM CST
	TEST AR.BR,SKP CRY0,		;WRITABLE--SKIP IF CST WRITTEN
		GEN #-SC,#/-1,BYTE DISP	; OR THIS IS WRITE REF
=110	FE_FE-#,#/4,J/STCST		;TEMPORARILY UNWRITABLE, SET S
	AR_AR*BR,AD/OR,			;SET CST WRITTEN BIT
		FE_FE OR #,#/4		;SET SOFT BIT = WRITABLE
STCST:	AR_AR AND CSMSK,SKP P NE	;CLEAR OLD AGE, TEST IT
=0
NOTWR:	AR_SV.BR,J/PFT			;WRITE OR AGE TRAP
	AR_AR OR PUR,STORE		;SET USE BITS, STORE BACK CST
	MB WAIT,VMA_SV.VMA,		;RELOAD VMA FOR ORIGINAL REF
		AR_SV.VMA,SC_1		;READY TO TEST VMA USER
	GEN P AND SC,SKP SCAD NE,	;TEST VMA USER
		ARL_ARXL.M,ARR_0.M,	;PHYS PAGE# TO ARL, APWSC0 TO SC
		SC_FE,ARX_AR (AD)	; MAP BIT TO ARX
=0	P_P OR SC#,EXEC REF,J/WRHPT	;BUILD PT ENTRY, CLEAR VMA USER
	P_P OR SC#,USER REF		; OR SET USER, AS NECESSARY
WRHPT:	WR PT ENTRY,FE_#,#/10,AR_ARX*4	;UPDATE HARDWARE TABLE

.IF/ITSPAGE

;HERE TO START HACKING PAGE MAP
;AR, ARX HAVE VMA.  BR HAS PFW.
;AR, ARX, BR, FE, SC, SV.VMA, SV.PFW HAVE BEEN STORED.

PGRF2:	ARL_0S,SIGNS DISP		;SKIP ON PFW BIT 0 (USER MODE)
=101	AR_ARX (ADX),ARX_AR (AD),	;<AR|ARX> WILL HAVE <VMA|0,,VMA> FOR SHIFT
		SC_#,#/25.,		;SC GETS SHIFT AMOUNT FOR PG TBL INDEX
		AR18-21 DISP,J/PGEXRF	;DISPATCH ON VMA 2.9 FOR DBR SELECT
	AR_ARX (ADX),ARX_AR (AD),	;<AR|ARX> WILL HAVE <VMA|0,,VMA> FOR SHIFT
		SC_#,#/25.,		;SC GETS SHIFT AMOUNT FOR PG TBL INDEX
		AR18-21 DISP,J/PGUSRF	;DISPATCH ON VMA 2.9 FOR DBR SELECT
=0111
PGEXRF:	FE_AR0-8,AR_SHIFT,ARX_DBR4,J/RDDBR	;ARR GETS INDEX INTO ITS PAGE TABLE.
	FE_AR0-8,AR_SHIFT,ARX_DBR3,J/RDDBR0	; AR0 TELLS WHICH HALFWORD.
=0111						; FE 1.5 GETS WRITE REF BIT.
PGUSRF:	FE_AR0-8,AR_SHIFT,ARX_DBR1,J/RDDBR	; ARX GETS ONE OF FOUR DBR'S
	FE_AR0-8,AR_SHIFT,ARX_DBR2,J/RDDBR0	; DEPENDING ON EXEC/USER AND VMA 2.9.

;HERE TO PICK UP ITS PAGE TABLE ENTRY

RDDBR0:	ARX_ARX-CN100			;COMPENSATORY CROCK
RDDBR:	SC_AR0-8,AR_BR,BR/AR		;SC _ 1/2 WD BIT, BR _ PTW INDEX
	VMA_ARX+BR,SC_SC AND #,#/400	;SET UP VMA BEFORE PHYS REF
					;(BUG IN MCL BOARD: MCL USER EN)
	LOAD AR VIA RPW,BR/AR,PHYS REF,	;BR NOW HAS PFW AGAIN.
		GEN SC,SKP SCAD NE	;FETCH PTW, SKIP ON HALF.
=0
	AR_MEM,CLR ARX,SC_#,#/0,J/RDBRLH	;SC GETS 0 FOR LEFT HALF,
	AR_MEM,CLR ARX,SC_#,#/18.,J/RDBRRH	; 18. FOR RIGHT HALF
RDBRLH:	AR_AR*LH.AGE,AD/ANDCB,		;AND OUT APPROPRIATE AGE BITS,
		STORE,J/PACCDS		; AND STORE BACK
RDBRRH:	AR_AR*RH.AGE,AD/ANDCB,
		STORE,J/PACCDS

;HERE TO DETERMINE ACCESS ALLOWED BY ITS PAGE TABLE ENTRY

PACCDS:	MEM_AR,ARL_SHIFT.C,ARR_0.C,	;GET PAGE TABLE HALFWORD IN ARL,
		SC_1,SH DISP		; CLEAR ARR, DISPATCH ON ACCESS
=0011
	SC_PF.PNA,AR_BR,J/PFT69		;00	NO ACCESS
	SC_#,#/PPRO,AR_SHIFT,J/PFWLOS	;01	READ ONLY	;AR GETS SHIFTED
	SC_#,#/PPRWF,AR_SHIFT,J/PFWLOS	;10	R/W FIRST	; FOR KL-10 SIZE
	SC_#,#/PPRW,AR_SHIFT,J/PGSTO	;11	READ/WRITE	; PAGES (.5K)

PFWLOS:	GEN FE AND #,#/20,SKP SCAD NE	;LOSE IF WRITE ATTEMPT
=0
PGSTO:	SCADA/#,SCADB/AR0-8,SCAD/AND,	;CLEAR OUT ACCESS AND AGE BITS
		AR0-8_SCAD#,#/37,
		J/PGSTO1
	SC_PF.ILW,AR_BR			;WRITE INTO READ ONLY OR R/W/F LOSES
PFT69:	P_SC#,ARX_SV.BR			;SET PAGE FAIL CODE
	SV.PFW_AR,AR_ARX,J/PFT		;GO TAKE PAGE FAULT

;HERE TO WRITE TWO KI-10 PAGE MAP ENTRIES

PGSTO1:	SCADA/AR0-5,SCADB/SC,SCAD/OR,	;OR IN APPROPRIATE KI-10
		P_SCAD#,ARX_SV.VMA	; STYLE ACCESS BITS
	GEN ARX*CN1000,AD/ANDCB,VMA/AD	;VMA ADDRESS FOR LOW HALF PAGE
	GEN SV.PFW,SKP AD0		;SKIP IF USER REFERENCE
=0	EXEC REF,J/PGSTO2		;FIX IT UP (BUG IN MCL BOARD
	USER REF,J/PGSTO2		; HAVING TO DO WITH PXCT)
PGSTO2:	WR PT ENTRY,ADA/AR,AD/A+XCRY,	;WRITE IT, THEN BUMP ARL
		GEN CRY18,AR/AD		; FOR HIGH .5K ENTRY
	GEN ARX*CN1000,AD/OR,VMA/AD	;VMA ADDRESS FOR HIGH HALF PAGE
	GEN SV.PFW,SKP AD0		;SKIP IF USER REFERENCE
=0	EXEC REF,J/PGSTO3		;FIX IT UP (BUG IN MCL BOARD
	USER REF,J/PGSTO3		; HAVING TO DO WITH PXCT)
PGSTO3:	WR PT ENTRY,AR_ARX*4,FE_#,#/10	;WRITE 2ND PTW.  SET UP FE AND S
.ENDIF/ITSPAGE
;HERE WHEN MAP INFO WRITTEN INTO HARDWARE PAGE TABLE
; WE NOW NEED ONLY RESTORE THE REGISTERS WE HAVE USED, AND RESTART THE
; MEMORY REFERENCE WHICH FAILED, RETURNING TO THE MICROINSTRUCTION
; WHICH WAITS FOR ITS COMPLETION.  (EXCEPT FOR MAP)
; THIS SCREWING AROUND WITH FE_EXP,FE_-SC-1 ETC. LOOKS USELESS,
; BUT IT IS NECESSARY BECAUSE THESE KLUDGIFEROUS REGISTERS HAVE 11
; BITS, EVEN THOUGH YOU CAN ONLY READ 9 OF THEM.  THE HARDWARE FORCES
; THE TWO HIGHEST BITS TO BE IDENTICAL, BUT WE WANT TO FORCE THE THREE
; HIGHEST BITS TO BE IDENTICAL.  AS FAR AS I KNOW, THE ONLY WAY TO
; READ THOSE TWO EXTRA BITS IS VIA SKIP/SCAD0 OR SKIP/SC0.

.IF/MAP
	GEN FE AND S,SKP SCAD NE,	;TEST FOR MAP INSTR
		AR_SV.SC
=0
.IFNOT/MAP
	AR_SV.SC
.ENDIF/MAP
	SC_EXP,FE_EXP,SKP AR0,		;RESTORE FE
		AR_AR SWAP,ARX_SV.BR,J/PGRST1
.IF/MAP
	AR_SV.VMA,ARX_SV.VMA,J/COMPEA	;*MAP* RESTART FROM AREAD
.ENDIF/MAP
=0
PGRST1:	SC_EXP,SKP AR0,			;RESTORE SC
		AR_ARX,ARX_SV.AR,J/PGRST2
	FE_-SC-1,J/PGRST1		;MAKE FE NEG
=0
PGRST2:	BR/AR,AR_ARX,ARX_SV.ARX,J/PGRST3	;RESTORE BR AND AR AND ARX
	BR/AR,AR_ARX,ARX_SV.ARX,SC_-SC-1	;MAKE SC NEG

PGRST3:	REQ SV.VMA			;RESTART REQUEST THAT FAILED
	SET ACCOUNT EN,RETURN0		;RESTART MICROINSTRUCTION THAT FAILED


;HERE ON A TRAP CONDITION DETECTED BY REFILL LOGIC
;AR CONTAINS SAVED BR

;IF WE PAGE FAULTED ON THE FETCH OF THE INSTRUCTION IMMEDIATELY
;AFTER A PI CYCLE, CON INT DISABLE IS STILL ON BECAUSE THE NICOND
;THAT OUGHT TO HAVE CLEARED IT DIDN'T GET CLOCKED.  SO CLEAR IT
;NOW.  IF PFAIL.PIHACK, COULD HANG AT WGRANT BECAUSE PI BOARD
;THINKS INTERRUPTS ARE ENABLED BUT CON BOARD DOESN'T.  IF NO
;PFAIL.PIHACK, ONLY LOSS IS THAT INTERRUPT WON'T PREEMPT PG FLT.

PFT:	CLR INTRPT INH			;CLEAR CON INT DISABLE
	BR/AR,VMA_SV.VMA,		;RESTORE BR & VMA
		SR DISP,J/CLEAN		;TAKE TRAP
.IFNOT/KLPAGE
.TOC	"KI-MODE PAGE FAIL HANDLING"

2377:	CLR ACCOUNT EN,FORCE AR-ARX,J/PFSAVE
1777:	CLR ACCOUNT EN,FORCE AR-ARX	;DON'T CHARGE PAGE FAIL TO USER
PFSAVE:	SV.AR_AR,AR_ARX			;PRESERVE AR, ARX
	SV.ARX_AR,SR DISP,J/CLEAN	;NOW CHECK FOR CLEANUP REQUIRED

.ENDIF/KLPAGE
;HERE ON PAGE FAIL OR INTERRUPT WHICH REQUIRES CLEANUP IN ORDER
; TO BE CORRECTLY RESTARTABLE AFTER SERVICE...

=1*0000
CLEAN:	FE_#,#/37,SKP INTRPT,J/PGF1	;HERE FOR INTRPT OR PGF?

.IF/EIS
;(1) HERE ON EDIT SOURCE FAIL
=0001	AR_SRCP,SR_0,J/BACKS		;BACK UP SRC POINTER
.IF/DECIMAL
;(2) HERE ON ANY FAILURE IN DECIMAL TO BINARY
=0010	AR_BR LONG,SR_1,J/D2BPF		;GET ACCUMULATED BINARY

;(3) HERE ON DST FAIL IN BINARY TO DECIMAL FILL
=0011	AR_DLEN COMP,SR_#,#/4,J/B2DFPF
.ENDIF/DECIMAL
;(4) HERE ON EDIT DST FAIL WITH NO SRC POINTER UPDATE
=0100	AR_DSTP,SR_0,J/BACKD		;BACK UP DST POINTER ONLY

;(5) HERE ON EDIT DST FAIL AFTER UPDATING SRC POINTER
=0101	AR_DSTP,SR_1,J/BACKD		;BACK UP DST, THEN SRC
.IF/DECIMAL
;(6) HERE ON DESTINATION FAILURE IN BINARY TO DECIMAL
=0110	AR_DSTP,SR_BDT,J/BACKD		;BACK UP DST, THEN SAVE FRACTION
.ENDIF/DECIMAL
.ENDIF/EIS
;(7) HERE ON BLT FAILURE
=0111
.IF/KLPAGE
	ARX_SV.ARX,J/BLTPF		;GET DEST ADDR AGAIN
.IFNOT/KLPAGE
BLTPF:	AR_ARX+BR,SR_0,J/BLTPF1		;CURRENT SRC ADDR
.ENDIF/KLPAGE
.IF/EIS
.IF/DECIMAL
;(10) HERE ON TRANSLATION FAILURE IN BINARY TO DECIMAL
=1000	AR_BR LONG,SR_0,J/B2DPF		;GET BINARY FRACTION
.ENDIF/DECIMAL

;(11) HERE ON SRC FAILURE IN COMPARE OR MOVE STRING
=1001	AR_DLEN,SR_1,J/STRPF		;PUT LENGTHS BACK, THEN BACK SRC

;(12) HERE ON DST FAILURE IN COMPARE OR MOVE STRING
=1010	AR_DLEN,SR_#,#/4,J/STRPF

;(13) HERE ON DST FAILURE AFTER UPDATING SRC IN COMPARE OR MOVE
=1011	AR_DSTP,SR_SRC,J/BACKD		;BACK DST, THEN HANDLE AS SRC FAIL

;(14) HERE ON DST FILL FAILURE IN MOVRJ
=1100	AR_DLEN,SR_#,#/4,J/STRPF4
.ENDIF/EIS
.IF/KLPAGE
.IF/MAP
;(15) HERE ON PAGE FAILURE IN MAP INSTRUCTION.  RETURN PAGE FAIL WORD
=1101	AR_SV.PFW,J/IFSTAC		;RETURN PFW IN AC
.ENDIF/MAP
.ENDIF/KLPAGE

;(16) LISP??

;(17) HERE ON PAGE FAIL ON FETCH OF INSTRUCTION AFTER A JRSTF.
;     DOING AN ABORT INSTR WOULD SCREW UP THE FLAGS, BECAUSE
;     THE NICOND THAT ADVANCES THE FLAGS (CYC_REQ, REQ_0)
;     WAS NOT CLOCKED.  SO WE FAKE ONE UP NOW.
=1111	VMA/PC,DISP/NICOND,#/0,J/JRSTFC
=		;END OF 'CLEAN' DISPATCH TABLE

;SECOND INST FOR JRSTF CLEANUP
=1111
JRSTFC:	PC_VMA,SR_0,J/CLEAN		;DISP/NICOND CLOBBERED PC
;HERE ON ANY PAGE FAILURE OR PI REQUEST IN LONG INSTRUCTIONS
; SKIP IF PI REQUEST, WHICH TAKES PRIORITY

.IF/KLPAGE
=0
PGF1:	MB WAIT,VMA_#,#/500,J/PGF2
	SET ACCOUNT EN,J/TAKINT		;CLEANUP DONE, SERVE INTRPT
PGF2:	AR_SV.PFW,SKP PI CYCLE,J/PGF4	;GET BACK PAGE FAIL WORD
.IFNOT/KLPAGE
=0
PGF1:	GET ECL EBUS,CLR SC,
		PF DISP,J/PGF2
	SET ACCOUNT EN,J/TAKINT		;HERE TO SERVE INTRPT, DO IT
=1100
PGF2:
=01	AR_SV.AR,FE_FE-1,		;AR PARITY ERROR
		SKP RPW,J/PGF6		;DO WE NEED TO RESTART RPW?
=10	VMA_VMA HELD,MAP,SC_FE		;ARX PARITY ERROR, PF CODE 37
PGF3:	MB WAIT,VMA_#,#/500
	AR_EBUS REG			;READ PAGE FAIL WORD
	REL ECL EBUS
	P_P OR SC,SKP PI CYCLE		;STUFF ERROR CODE IF PARITY
.ENDIF/KLPAGE
=00
PGF4:	ARX_AR,AR_VMA HELD,SC_#,#/13.,	;READY TO COMBINE PF WORD
		CALL,J/ROTS		; WITH ADDRESS
	SV.IOPF_AR,J/IOPGF		;SAVE IO PG FAIL WORD
=11
.IFNOT/PFAIL.PIHACK
.IFNOT/LPM.SPM
	AR_SHIFT,STORE,UPT REF		;PUT PAGE FAIL WORD AT 500
.IF/LPM.SPM
	AR_SHIFT,STORE,EPT REF		;STORE PFW AT 500
	UPFW_AR				;ALSO IN LPM/SPM VARIABLES
.ENDIF/LPM.SPM
.IF/PFAIL.PIHACK
	MQ_SHIFT,AR_1,GEN CRY18,	;SAVE PAGE FAIL WORD IN MQ
		ARX/AD,SC_#,#/8		; AND GENERATE MAGIC BITS
=00	AR_SHIFT,REQ EBUS,CALL,J/WGRANT	;GOBBLE DOWN EBUS
=11	CONO PI				;TURN OFF PI SYSTEM
	REL EBUS			;RELEASE EBUS
.IFNOT/LPM.SPM
	AR_MQ,STORE,UPT REF
.IF/LPM.SPM
	AR_MQ,STORE,EPT REF		;STORE PFW AT 500
	UPFW_AR				;AND IN LPM/SPM VARIABLES
.ENDIF/LPM.SPM
.ENDIF/PFAIL.PIHACK
	ABORT INSTR			;RECOVER TRAP FLAGS, IF ANY
	FIN STORE,AR_PC,
		VMA_VMA+1,STORE		;STORE OLD PC AT 501
.IFNOT/KLPAGE
	REL ECL EBUS
.ENDIF/KLPAGE
.IFNOT/LPM.SPM
	FIN STORE,VMA_VMA+1,LOAD AR	;GET NEW PC FROM 502
.IF/LPM.SPM
	MEM_AR,VMA_VMA+1		;DON'T CHANGE TO FIN STORE!
	LOAD AR,EPT REF
.ENDIF/LPM.SPM
	SET ACCOUNT EN,J/NEWPC

;HERE ON PAGE FAIL DURING PI CYCLE

IOPGF:	SET IO PF			;TROUBLE...
	SET ACCOUNT EN,J/PIDONE

.IFNOT/KLPAGE
;HERE ON PARITY ERROR IN AR.  SKIP IF READ-PAUSE-WRITE IN PROGRESS
=0
PGF6:	VMA_VMA HELD,MAP,		;AR PARITY ERROR
		SC_FE,J/PGF3		;PF CODE 36
	STORE,J/PGF6			;COMPLETE CYCLE, WITH GOOD PAR
.ENDIF/KLPAGE
.TOC	"PAGE FAIL/INTERRUPT CLEANUP FOR SPECIAL INSTRUCTIONS"

;HERE ON BLT PAGE FAIL

.IF/KLPAGE
BLTPF:	AR_ARX+BR,SR_0			;CURRENT SRC ADDR
.ENDIF/KLPAGE
BLTPF1:	AR_ARX (AD),ARL_ARR
PGFAC0:	AC0_AR,SR DISP,J/CLEAN		;BEGIN NORMAL PF WORK

.IF/EIS
;HERE ON VARIOUS CASES OF STRING/EDIT FAILURE

BACKS:	P_P+S
	SRCP_AR,SR DISP,J/CLEAN		;RE-DISPATCH FOR MORE

BACKD:	P_P+S
	DSTP_AR,SR DISP,J/CLEAN

.IF/DECIMAL
D2BPF:	AC3_AR,AR_0S,SC_#,#/35.		;PUT AWAY HIGH BINARY
	AR_SHIFT,ARX_-SLEN		;LOW TO AR, REMAINING LEN TO ARX
	AC4_AR,AR_ARX,J/STRPF2		;PUT LOW AWAY

B2DFPF:	AR_AR*T0,AD/OR,J/B2DPF2

B2DPF:	AC0_AR,AR_ARX			;HIGH FRACTION TO AC
	AC1_AR				;LOW TO AC1
	AR_AC3				;GET FLAGS
B2DPF2:	AR_AR*SLEN,AD/A-B,J/STRPF3	;REBUILD FLAGS+LEN
.ENDIF/DECIMAL

STRPF:	BR/AR,AR_-SLEN,SKP AR0		;WHICH IS LONGER?
=0
STRPF1:	AC3_AR,AR_AR+BR,J/STRPF2	;SRC LONGER
	ARX_AR,AR_AR*SFLGS,AD/OR	;DST.  BUILD SRC LEN+FLAGS
	AC0_AR,AR_ARX-BR		;THAT'S AWAY, MAKE DST LEN
STRPF3:	AC3_AR,SR DISP,J/CLEAN		;OK, NOW BACK UP SRC IF REQ'D

STRPF2:	AR_AR*SFLGS,AD/OR,J/PGFAC0

STRPF4:	BR/AR,AR_SLEN COMP,SKP AR0,J/STRPF1
.ENDIF/EIS
