;<WIRELIST>WLOUT2.FAI.346, 17-NOV-75 09:49:18, EDIT BY HELLIWELL
SUBTTL	<CTRL><META>U	COPY DIP ASSIGNMENTS FROM D WIRE LIST TO PC WIRE LIST
DTOPC:	MOVE L,DEFLST
	FETCH(W,L,WIRL)
	PUSHJ P,LSTGT0		;GET A CARD NAME
	POPJ P,
	HRRM W,GOODW
	FETCH(W,L,PCWL)		;GET POINTER TO FIRST CARD BLOCK
	JUMPE W,NXCRD1		;IS THERE ONE?
	PUSHJ P,GETLOP		;LOOKUP SAME CARD
	JRST NXCRD1
	HRRM W,BADW
	OUTSTR[ASCIZ/
/]
FIXDIP:	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	HRRZ H,GOODW
	MOVEI H,RADDR(H,WBDY,NXTB);POINT TO BODY LIST LINK
	SETZM LETTER
	SETZM SLICEL
	JRST DTOPC1

DTOPC2:	FETCH(T,H,BLOC)
	JUMPE T,DTOPC1		;ANY LOC?
	CAMN T,SLICEL		;DIFFERENT FROM LAST?
	JRST DTOPC1		;NO, SKIP IT
	MOVEM T,SLICEL		;REMEMBER LAST
	FETCH(TT,H,DIPT)	;DIP TYPE POINTER
	JUMPE TT,DTOPC1
	MOVEM T,LETTER
	MOVEM TT,DIPPNT
	HRRZ C,BADW
	MOVEI C,RADDR(C,WBDY,NXTB)
	PUSHJ P,BDLNXT		;FIND AND MAP ALL SUCH LOCS IN PC LIST!
	TRNE FLAG
	 JRST DTOPC1
	MOVE A,LETTER
	PUSHJ P,LOCOUT
	OUTSTR[ASCIZ/ NOT FOUND IN "OTHER" LIST!
/]
DTOPC1:	FETCH(H,H,NXTB)
	JUMPN H,DTOPC2
	POPJ P,

NXCRD1:	OUTSTR[ASCIZ/SAME CARD DOESN'T EXIST IN "OTHER" WIRE LIST!
/]
	POPJ P,

;BDLNXT - LINK ALL BODIES IN SAME LOC TO SAME DIPTYPE
; (Also update PTYP links for all the body pins)
;C = BODY LIST
;DIPPNT = DIPTYPE
;FLAG = Body was found

BDLNXT:	PUSHJ P,FN2BOD		;FIND BODY BY LOC IN LETTER
	POPJ P,			;NO MORE
	TRO FLAG
	FETCH(T,C,DIPT)		;DIP TYPE POINTER
	JUMPN T,BDLNXT		;ALREADY LINKED?
	PUSHJ P,LNKDIP
	JRST BDLNXT

FN2BOD:	FETCH(C,C,NXTB)
	JUMPE C,CPOPJ
	FETCH(TT,C,BLOC)
	CAME TT,LETTER
	JRST FN2BOD
	JRST CPOPJ1

LNKDIP:	MOVE A,DIPPNT
	STORE(A,C,DIPT)		;STORE DIP POINTER
	FETCH(E,C,BPIN)
	JUMPE E,CPOPJ		;SKIP THIS IF NO PINS
	PUSH P,C
LNKDP1:	FETCH(F,E,PBDY)		;SETUP BODY POINTER
	FETCH(G,E,HPNT)		;WIRE HEADER
	FETCH(T,E,PINN)		;PIN #
	MOVEM T,PINNUM
	PUSHJ P,PTLINK		;LINK UP PIN TO TYPE
	JUMPE T,LNKDP2		;THIS IS 0 IF NO LINKUP
	PUSHJ P,LBCOPY		;DO LOADING AND SHARE CHECK
LNKDP2:	FETCH(E,E,NXBP)
	JUMPN E,LNKDP1		;LOOP FOR THEM ALL
	POP P,C			;RESTORE BODY POINTER
	POPJ P,
SUBTTL	'UML'		REPLACE REAL PIN NAMES WITH "U" PIN NAMES
DEC,<
UMLOUT:	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	MOVSI T,'UML'		;STUFFING EXT
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	PUSHJ P,UGINSET
	PUTSTR[ASCIZ/PINS
/]
	FETCH(H,W,WBDY)		;NOW GO DOWN BODY LIST
	JUMPE H,UMLBNX		;JUMP IF NONE
UMLO1:	FETCH(T,H,BBIT)
	TRNN T,CBODY		;CONNECTOR?
	JRST UMLO2		;NO
	FETCH(G,H,BPIN)		;YES, GET FIRST PIN
UMLO3:	FETCH(T,G,PBIT)
	TRNE T,DUP			;DON'T DO DUPLICATES
	JRST UMLO4
	FETCH(A,G,HPNT)
	FETCH(A,A,TBIT)		;GET WIRE TYPE BITS
	PUSHJ P,UGIN
	JRST UMLO4
	PUSH P,A
	FETCH(A,H,BLOC)
	FETCH(T,G,PINN)
	HRL A,T
	PUSHJ P,LOCPNC
	PUTBYT 11
	POP P,A
	PUSHJ P,LOCPNC
	CRLF
UMLO4:	FETCH(G,G,NXBP)
	JUMPN G,UMLO3
UMLO2:	FETCH(H,H,NXTB)
	JUMPN H,UMLO1
UMLBNX:	PUTSTR[ASCIZ/END
/]
	RELEASE LST,
	POPJ P,
SUBTTL	'CPN' ADD CONNECTOR PIN DESIGNATION TO EACH SIGNAL NAME IN DRW FILE
CPNOUT:	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	MOVSI T,'CPN'		;CON PIN EXT
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	PUSHJ P,CLEARW		;CLEAR WIRE MARK BITS
	TLZ TFLG		;FLAG NOTHING TYPED YET
	MOVEI H,RADDR(W,WIRES,ALPH)
	JRST CPNC1

CPNC2:	FETCH(T,H,WBIT)
	TRNE T,NAM2ND!WNULL!WSINGL	;SKIP FAKES, NULLS, AND SINGLES
	JRST CPNC1
	SETO TT,
	MOVEI G,RADDR(H,WPIN,NXTP)
	JRST CPNC3

CPNC4:	FETCH(T,G,PBIT)
	TRNE T,DUP
	JRST CPNC3
	FETCH(T,G,PBDY)
	FETCH(T,T,BBIT)
	TRNE T,CBODY
	AOJG TT,CPNC5		;JUMP IF SECOND PIN
CPNC3:	FETCH(G,G,NXTP)
	JUMPN G,CPNC4
	JRST CPNC1

CPNC5:	FETCH(T,H,WBIT)
	TRO T,WTMP1
	STORE(T,H,WBIT)
	TRNE T,SPWR!SGND!SHI!SNC	;DON'T PRINT THESE
	JRST CPNC1
	TLON TFLG		;HEADING PRINTED?
	OUTSTR[ASCIZ/THE FOLLOWING MULTI-EDGE-PIN RUNS WILL BE SKIPPED:
/]
	MOVE G,H
CPNC6:	OUTSIG ADDR(G,SPNT)
	OUTSTR[ASCIZ/
/]
	FETCH(G,G,NNAM)
	JUMPN G,CPNC6
CPNC1:	FETCH(H,H,ALPH)
	JUMPN H,CPNC2
	FETCH(H,W,WBDY)		;NOW GO DOWN BODY LIST
	JUMPE H,CPNBNX		;JUMP IF NONE
CPNO1:	FETCH(T,H,BBIT)
	TRNN T,CBODY		;CONNECTOR?
	JRST CPNO2		;NO
	FETCH(G,H,BPIN)		;YES, GET FIRST PIN
CPNO3:	FETCH(T,G,PBIT)
	TRNE T,DUP			;DON'T DO DUPLICATES
	JRST CPNO4
	FETCH(F,G,HPNT)
	FETCH(T,F,WBIT)			;GET WIRE TYPE BITS
	TRNE T,SPWR!SGND!SNC!SHI!WTMP1	;NOT FOR THESE
	JRST CPNO4
CPNO5:	FETCH(A,H,BLOC)
	FETCH(T,G,PINN)
	HRL A,T
	PUSHJ P,LOCPNC
	PUTBYT 11
	PUTSIG ADDR(F,SPNT)
	CRLF
	FETCH(F,F,NNAM)
	JUMPN F,CPNO5
CPNO4:	FETCH(G,G,NXBP)
	JUMPN G,CPNO3
CPNO2:	FETCH(H,H,NXTB)
	JUMPN H,CPNO1
CPNBNX:	RELEASE LST,
	POPJ P,
SUBTTL	'SPI' ADD CONNECTOR PIN DESIGNATION TO EACH SIGNAL NAME IN DRW FILE
SPIOUT:	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	MOVSI T,'SPI'		;CON PIN EXT
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	TLO SIMTAB		;SIMULATE TABS, THIS IS FOR COBOL
	PUSHJ P,CLEARW		;CLEAR WIRE MARK BITS
	FETCH(H,W,WBDY)		;NOW GO DOWN BODY LIST
	JUMPE H,SPIBNX		;JUMP IF NONE
SPIO1:	FETCH(T,H,BBIT)
	TRNN T,CBODY		;CONNECTOR?
	JRST SPIO2		;NO
	FETCH(G,H,BPIN)		;YES, GET FIRST PIN
SPIO3:	FETCH(T,G,PBIT)
	TRNE T,DUP			;DON'T DO DUPLICATES
	JRST SPIO4
	FETCH(F,G,HPNT)
	FETCH(T,F,WBIT)
	TRNE T,SPWR!SGND!SNC!SHI	;SKIP THESE
	JRST SPIO4
	FETCH(A,H,BLOC)
	FETCH(T,G,PINN)
	HRL A,T
	PUSHJ P,LOCPNC
	PUTBYT 11
	FETCH(T,F,WBIT)
	MOVEI E,"0"		;CODE 0 FOR FIRST SIGNAL LINE
	TROE T,WTMP1		;MARK RUN OUT
	MOVEI E,"1"		;CODE 1 FOR REPEATED SIGNAL LINE
	STORE(T,F,WBIT)
	PUSHJ P,SPIO5
SPIO4:	FETCH(G,G,NXBP)
	JUMPN G,SPIO3
SPIO2:	FETCH(H,H,NXTB)
	JUMPN H,SPIO1
SPIBNX:	FETCH(F,W,WIRES)
	JUMPE F,SPIWNX
SPIW1:	FETCH(T,F,WBIT)
	TRNE T,WTMP1!NAM2ND!WNULL!GENSIG!SPWR!SGND!SNC!SHI	;DON'T DO ANY OF THESE
	JRST SPIW2
	MOVEI E,"3"			;CODE 3 FOR NON-EDGE SIGNAL
	PUSHJ P,SPIO5
SPIW2:	FETCH(F,F,ALPH)
	JUMPN F,SPIW1
SPIWNX:	RELEASE LST,
	POPJ P,

SPIO5:	PUSH P,F
SPIO5A:	MOVEI A,=8
	PUSHJ P,SPFILL
	FETCH(D,F,WPIN)
	SETZ C,
SPIO6:	FETCH(T,D,PTYP)
	JUMPE T,SPIO7
	FETCH(T,T,DPBIT)
	TRNN T,OUTLD
	JRST SPIO7
	JUMPN C,SPIO8
	MOVE C,D
SPIO7:	FETCH(D,D,NXTP)
	JUMPN D,SPIO6
	JUMPE C,SPIO8
	FETCH(A,C,FILP)
	FETCH(A,A,FPRF)
	PUSHJ P,PRINT4		;ONLY 4 CHARS
SPIO8:	MOVEI A,=16
	PUSHJ P,SPFILL
	PUTBYT (E)
	MOVEI E,"2"		;CODE 2 FOR MULTIPLE SIGNAL NAMES
	PUTBYT " "
	MOVEI T,ADDR(F,SPNT)
	MOVE TT,[=64,,=64]
	PUSHJ P,SMPPUT		;64 CHARS SIGNAL NAME, ASSERTION/POLARITY
	SKIPE OVRFLW			;OVERFLOW?
	PUTSTR[ASCIZ/ */]		;YES, FLAG IT
	CRLF
	FETCH(F,F,NNAM)
	JUMPN F,SPIO5A
	POP P,F
	POPJ P,
>;DEC
SUBTTL	'STF' AND 'PRT'	DIP STUFFING AND PARTS LISTS
PRTLST:	TROA DOPRTL
STFLST:	TRZ DOPRTL
	SETZM ALLNAM
	SETZM ALLCRD
ALLSTF:	MOVE L,DEFLST
	SKIPE T,ALLCRD
	JRST [	MOVEM T,SLICEL
		JRST GALSTF]
	PUSHJ P,LSTGET
	POPJ P,
GALSTF:	FETCH(H,W,WBDY)
	JUMPE H,[OUTSTR[ASCIZ/NO BODIES AT ALL!
/]
		POPJ P,]	;SKIP IF NO BODIES
	TRNE DOPRTL
	SKIPA T,['PRT   ']
	MOVSI T,'STF'		;STUFFING EXT
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,ALLSET
	POPJ P,
	PUSHJ P,FILLST
	 PUTHDR
	TRNE DOPRTL
	JRST PRT1
	MOVEI T,[ASCIZ/PART NUMBER	DIPTYPE		LOC	BODY	FILE	POS/]
	MOVEM T,HEADER
	MOVEI T,STFMAR
	MOVEM T,MARGIN
	SETZM LINCNT
	PUSHJ P,CLEARB
	SETZM CDSKPC		;COUNT OF NUMBER OF BODIES WITHOUT DIPS
	MOVEI H,RADDR(W,WBDY,NXTB);GO MARK ALL BODIES WITHOUT LOCS
	JRST STFC2

STFC1:	FETCH(T,H,BLOC)
	JUMPN T,STFC2
	AOS CDSKPC
	FETCH(T,H,BBIT)
	TRO T,BTMP1
	STORE(T,H,BBIT)
STFC2:	FETCH(H,H,NXTB)
	JUMPN H,STFC1
	MOVEI T,PARTLIST-ADDR(0,NXPL)
	MOVEM T,LSTPART		;SET PARTLIST AS LAST PART
STFA0:	SKIPN T,LSTPART
	JRST STFDON
	JRST STFA1

STFA2:	FETCH(TT,T,PLPT)
	FETCH(TT,TT,PRBT)
	TRNE TT,PNUSED
	JRST STFA3
STFA1:	FETCH(T,T,NXPL)
	JUMPN T,STFA2
STFA3:	MOVEM T,LSTPART
	PUSHJ P,STFADO
	JRST STFA0


STFADO:	TRZ FLAG		;FLAG PART NUMBER NOT PRINTED YET
	MOVEI H,RADDR(W,WBDY,NXTB);GOING DOWN BODY LIST
	CAIA			;SKIP CRLF INITIALLY
STF1:	CRLF
	SETZM LSLOT		;FORGET LAST SLOT
	SETOM LSTDIP		;AND DIP TYPE
STF3:	FETCH(H,H,NXTB)		;NEXT BODY
	JUMPE H,CPOPJ
	FETCH(TTT,H,BBIT)
	TRNE TTT,CBODY!BTMP1		;CONNECTOR BODY?
	JRST STF3		;YES, SKIP
	FETCH(T,H,PRTN)
	PUSHJ P,PNCHK		;CORRECT PART NUMBER?
	JRST STF3		;NO
	FETCH(TTT,H,BBIT)
	TRO TTT,BTMP1
	STORE(TTT,H,BBIT)
	FETCH(T,H,DIPT)		;GET DIP TYPE
	MOVEM T,LSTDIP
	FETCH(TT,H,BLOC)
	MOVEM TT,LSLOT
	SKIPL LINCNT
	PUSHJ P,PUTHDR
	TROE FLAG
	JRST STF8
	SKIPN A,LSTPART
	JRST STF8B
	FETCH(A,A,PLPT)
	FETCH(A,A,PRVS)
	PUSHJ P,STROUT
	JRST STF8

STF8B:	PUTSTR[ASCIZ\N/A\]
STF8:	MOVEI A,=16
	PUSHJ P,FILL
	SKIPN A,LSTDIP
	JRST [	PUTSTR[ASCIZ\N/A\]
		JRST STF8A]
	FETCH(A,A,DNAM)
	PUSHJ P,STROUT		;DIP NAME
STF8A:	MOVE G,H		;START WITH CURRENT BODY
STF4:	MOVEI A,=32
	PUSHJ P,FILL
	FETCH(A,G,BLOC)
	FETCH(T,G,BBIT)
	PUSHJ P,WLOCOUT
	PUTSTR[ASCIZ/( )/]
STF5:	MOVEI A,=40
	PUSHJ P,FILL
	PUTSTR ADDR(G,BNAM)
	PUTBYT 11
	FETCH(A,G,FILB)
	PUTSIX ADDR(A,FILN)
	PUTBYT 11
	FETCH(A,G,BBIT)
	PUSHJ P,BPPNT
	CRLF
STF7:	FETCH(G,G,NXTB)
	JUMPE G,STF1		;TRY ANOTHER DIP YET?
	FETCH(T,G,DIPT)
	CAME T,LSTDIP
	JRST STF7
	FETCH(T,G,PRTN)
	PUSHJ P,PNCHK
	JRST STF7
	FETCH(T,G,BBIT)
	TRO T,BTMP1
	STORE(T,G,BBIT)
	FETCH(T,G,BLOC)
	CAMN T,LSLOT
	JRST STF5
	MOVEM T,LSLOT
	JRST STF4

STFDON:	SKIPN T,CDSKPC
	JRST STFDN1
	CRLF
	PUTSTR[ASCIZ/NUMBER OF BODIES WITH NO LOCATION SET = /]
	PUSHJ P,DECOUT
	CRLF
STFDN1:	RELEASE LST,
	POPJ P,

PNCHK:	SKIPN TT,LSTPART
	JRST [	JUMPN T,CPOPJ	;NOT NOW
		JRST CPOPJ1]
PNCHK2:	FETCH(TTT,TT,PLPT)
	CAMN TTT,T
	JRST CPOPJ1
	FETCH(TT,TT,NXPL)
	JUMPE TT,CPOPJ
	FETCH(TTT,TT,PLBT)
	TRNE TTT,PL2ND
	JRST PNCHK2
	POPJ P,


PRT1:	MOVEI T,[ASCIZ/
PART NUMBER	DIPTYPE		COUNT	DESCRIPTION				LOCATIONS/]
	MOVEM T,HEADER
	MOVEI T,PRTMAR
	MOVEM T,MARGIN
	SETZM LINCNT
	PUSHJ P,CLEARB
	SETOM NBODS
	MOVEI T,PARTLIST-ADDR(0,NXPL)
	MOVEM T,LSTPART		;SET PARTLIST AS LAST PART
PRTA0:	SKIPN T,LSTPART
	JRST STFDN1		;DONE, DON'T DUMP TOTALS FOR N/A
	JRST PRTA1

PRTA2:	FETCH(TT,T,PLPT)
	FETCH(TT,TT,PRBT)
	TRNE TT,PNUSED
	JRST PRTA3
PRTA1:	FETCH(T,T,NXPL)
	JUMPN T,PRTA2
PRTA3:	PUSH P,T
	SKIPLE NBODS
	PUSHJ P,PRTDMP		;DUMP OUT TOTALS OF LAST PART NUMBER
	TRZ FLAG
	SETOM NBODS
	SETZM TMPCN1
	SETZM TMPCN2
	POP P,T
PRTA6:	MOVEM T,LSTPART
	PUSHJ P,PRTADO
	TRNN FLAG		;DID WE PRINT ANY YET?
	JRST PRTA0		;NO, JUST LOOP BACK
	SKIPN T,LSTPART
	JRST STFDN1
PRTA4:	FETCH(T,T,NXPL)
	JUMPE T,PRTA3
	FETCH(TT,T,PLBT)
	TRNN TT,PL2ND
	JRST PRTA2		;JUMP INTO NORMAL LOOP IF NOT SAME NUMBER
	FETCH(TT,T,PLPT)
	FETCH(TT,TT,PRBT)
	TRNN TT,PNUSED
	JRST PRTA4
	JRST PRTA6


PRTADO:	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST PRT2

PRT3:	FETCH(TTT,H,BBIT)
	TRNE TTT,CBODY!BTMP1	;SKIP CONS
	JRST PRT2
	FETCH(T,H,PRTN)
	SKIPE TT,LSTPART
	FETCH(TT,TT,PLPT)
	CAME TT,T
	JRST PRT2
	HRLZM T,LSTDIP
	FETCH(T,H,BBIT)
	TRO T,BTMP1
	STORE(T,H,BBIT)
	FETCH(T,H,DIPT)
	HRRM T,LSTDIP
	FETCH(T,H,PRPX)
	MOVEM T,LPRPX
	SETZM LSLOT		;NO LOC COUNTED YET
	SKIPL LINCNT
	PUSHJ P,PUTHDR
	SETZM NDIPS
	SETZM TOTDIP
	MOVE G,H		;START WITH THIS BODY
PRT4:	FETCH(TTT,G,BBIT)
	TRNE TTT,CBODY
	JRST PRT6
	FETCH(T,G,DIPT)
	FETCH(TT,G,PRTN)
	HRL T,TT
	CAME T,LSTDIP
	JRST PRT6
	FETCH(T,G,PRPX)
	CAME T,LPRPX
	JRST PRT6
	TRO TTT,BTMP1
	STORE(TTT,G,BBIT)
	FETCH(T,G,BLOC)
	JUMPN T,PRT5
	MOVSI T,1
	ADDM T,TOTDIP
	JRST PRT6

PRT5:	AOS TOTDIP
	CAME T,LSLOT
	AOS NDIPS
	MOVEM T,LSLOT
PRT6:	FETCH(G,G,NXTB)
	JUMPN G,PRT4
	AOS NBODS		;COUNT ANOTHER LINE PRINTED
	TROE FLAG
	JRST PRT9
	SKIPN A,LSTPART
	JRST PRT9B
	FETCH(A,A,PLPT)
	FETCH(A,A,PRVS)
	PUSHJ P,STROUT
	JRST PRT9

PRT9B:	PUTSTR[ASCIZ\N/A\]
PRT9:	MOVEI A,=16
	PUSHJ P,FILL
	HRRZ G,LSTDIP
	JUMPE G,[PUTSTR[ASCIZ\N/A\]
		JRST PRT9A]
	FETCH(A,G,DNAM)
	PUSHJ P,STROUT
PRT9A:	MOVEI A,=32
	PUSHJ P,FILL
	MOVE T,NDIPS
	ADDM T,TMPCN1
	PUSHJ P,DECOUT
	MOVE T,TOTDIP
	ADDM T,TMPCN2
	SKIPN T,LSTPART
	JRST PRT8
	FETCH(T,T,PLPT)
	FETCH(T,T,PRPP)		;SKIP PART NUMBER
PRT8:	MOVEM T,PRPPTR
	MOVE T,LPRPX
	MOVEM T,PRXPTR
	MOVE G,H
	SETZM FSLOT
	SETZM LSLOT
PRT7:	PUSHJ P,PRPLIN		;ONE LINE OF PROPERTIES
	JRST PRT7A		;NO MORE PROPERTIES
	PUSHJ P,LOCLIN
	JFCL
	CRLF
	JRST PRT7

PRT7A:	PUSHJ P,LOCLIN
	JRST PRT7B
	CRLF
	JRST PRT7A		;LOOP TILL DONE

PRT7B:	SKIPE LCOUNT
	CRLF
PRT2:	FETCH(H,H,NXTB)
	JUMPN H,PRT3
	POPJ P,


PRPLIN:	SKIPN B,PRPPTR
	JRST PRPLX1
PRPL0:	FETCH(T,B,PRBT)
	TRNN T,NULVAL
	JRST PRPL0A
	FETCH(B,B,PRPP)
	JUMPN B,PRPL0
	MOVEM B,PRPPTR
	JRST PRPLX1

PRPL0A:	MOVEI A,=40
	PUSHJ P,FILL
PRPL1:	MOVE T,LCOUNT
	CAIG T,=40
	JRST PRPL2
	SUBI T,=78+2		;COUNT DELIMITERS HERE
	MOVEM T,TCOUNT
	PUSH P,PUTCHR
	MOVE T,[PUSHJ P,TAOS]
	MOVEM T,PUTCHR
	FETCH(A,B,PRVS)
	PUSHJ P,STROUT
	POP P,PUTCHR
	SKIPLE TCOUNT
	JRST CPOPJ1		;END THIS LINE
	PUTSTR[ASCIZ/, /]
PRPL2:	FETCH(A,B,PRVS)
	PUSHJ P,STROUT
PRPL3:	FETCH(B,B,PRPP)
	MOVEM B,PRPPTR
	JUMPE B,CPOPJ1
	FETCH(T,B,PRBT)
	TRNE T,NULVAL
	JRST PRPL3
	JRST PRPL1

PRPLX1:	SKIPN B,PRXPTR
	POPJ P,
	MOVEI A,=40
	PUSHJ P,FILL
PRPLX2:	MOVE T,LCOUNT
	CAIG T,=40
	JRST PRPLX3
	SUBI T,=78-3		;COUNT DELIMITERS HERE
	MOVEM T,TCOUNT
	PUSH P,PUTCHR
	MOVE T,[PUSHJ P,TAOS]
	MOVEM T,PUTCHR
	FETCH(A,B,TLFT)
	PUSHJ P,STROUT
	FETCH(A,B,TRHT)
	PUSHJ P,STROUT
	POP P,PUTCHR
	SKIPLE TCOUNT
	JRST CPOPJ1		;END THIS LINE
	PUTSTR[ASCIZ/, /]
PRPLX3:	FETCH(A,B,TLFT)
	PUSHJ P,STROUT
	PUTBYT ":"
	FETCH(A,B,TRHT)
	PUSHJ P,STROUT
	FETCH(B,B,NXTT)
	MOVEM B,PRXPTR
	JUMPN B,PRPLX2
	JRST CPOPJ1


LOCLIN:	HLRZ T,TOTDIP
	JUMPN T,LOCLN0
	JUMPE G,LOCLN7
LOCLN1:	FETCH(T,G,BBIT)
	TRNE T,CBODY
	JRST LOCLN2
	FETCH(T,G,DIPT)
	FETCH(TT,G,PRTN)
	HRL T,TT
	CAME T,LSTDIP
	JRST LOCLN2
	FETCH(T,G,PRPX)
	CAME T,LPRPX
	JRST LOCLN2
	FETCH(A,G,BLOC)
	JUMPE A,LOCLN2
	CAMN A,LSLOT
	JRST LOCLN2
	SKIPN FSLOT
	JRST [	MOVEM A,FSLOT
		MOVEM A,LSLOT
		JRST LOCLN2]
	MOVE T,LSLOT
	MOVE TT,A
	PUSHJ P,SEQLOC
	CAIA
	JRST [	MOVEM A,LSLOT
		JRST LOCLN2]
LOCLN8:	PUSHJ P,LOCLPN
	JRST CPOPJ1
	MOVE T,FSLOT
	CAMN T,LSLOT
	JRST LOCLN6
	MOVE TT,LSLOT
	PUSHJ P,SEQLOC
	JRST LOCLN6
	MOVE T,LSLOT
	MOVEM T,FSLOT
	PUSHJ P,LOCLPN
	JRST CPOPJ1
LOCLN6:	JUMPE G,[SETZM FSLOT
		POPJ P,]
	FETCH(A,G,BLOC)
	MOVEM A,FSLOT
	MOVEM A,LSLOT
LOCLN2:	FETCH(G,G,NXTB)
	JUMPN G,LOCLN1
LOCLN7:	SKIPE FSLOT
	JRST LOCLN8
	POPJ P,


LOCLPN:	TLZ TFLG
	MOVE T,FSLOT
	CAMN T,LSLOT
	JRST LOCLN4
	MOVE TT,LSLOT
	PUSHJ P,SEQLOC
	TLO TFLG
LOCLN4:	MOVE T,LCOUNT
	CAIGE T,=80
	JRST [	MOVEI A,=80
		PUSHJ P,FILL
		JRST LOCLN3]
	SUB T,LWIDTH
	ADDI T,2			;COUNT DELIMITERS HERE
	MOVEM T,TCOUNT
	PUSH P,PUTCHR
	MOVE T,[PUSHJ P,TAOS]
	MOVEM T,PUTCHR
	MOVE A,FSLOT
	FETCH(T,G,BBIT)
	PUSHJ P,WLOCOUT
	TLNN TFLG
	JRST LOCLN5
	AOS TCOUNT		;ONE CHARACTER FOR DASH BETWEEN LOCS
	MOVE A,LSLOT
	FETCH(T,G,BBIT)
	PUSHJ P,WLOCOUT
LOCLN5:	POP P,PUTCHR
	SKIPLE TCOUNT
	POPJ P,
	PUTSTR[ASCIZ/, /]
LOCLN3:	AOS (P)		;WILL PRINT, SKIP
	MOVE A,FSLOT
	FETCH(T,G,BBIT)
	PUSHJ P,WLOCOUT
	TLNN TFLG
	POPJ P,
	PUTBYT "-"
	MOVE A,LSLOT
	FETCH(T,G,BBIT)
	JRST WLOCOUT

LOCLN0:	MOVEI A,=80
	PUSHJ P,FILL
	PUTSTR[ASCIZ/NO. OF GATES WITH NO REF. DES. = /]
	HLRZ T,TOTDIP
	PUSHJ P,DECOUT
	HRRZS TOTDIP
	JRST CPOPJ1

PRTDMP:	MOVEI A,=24
	PUSHJ P,FILL
	PUTSTR[ASCIZ/TOTAL = /]
	MOVE T,TMPCN1
	PUSHJ P,DECOUT
	HLRZ T,TMPCN2
	JUMPE T,PRTDM1
	PUTSTR[ASCIZ/	NO. OF GATES WITH NO REF. DES. = /]
	HLRZ T,TMPCN2
	PUSHJ P,DECOUT
PRTDM1:	CRLF
	POPJ P,

TAOS:	SKIPE TTT
	AOS TCOUNT
	POPJ P,
SUBTTL	'OTS'		OUTPUT TERMINATION SUMMARY
OUTSUM:	SKIPN DIPLST
	JRST [	OUTSTR[ASCIZ/SORRY, NO DIPS.
/]
		POPJ P,]
	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	FETCH(H,W,WBDY)
	JUMPE H,[OUTSTR[ASCIZ/NO BODIES AT ALL!
/]
		POPJ P,]	;SKIP IF NO BODIES
	MOVSI T,'OTS'		;OUTPUT TERMINATION SUMMARY EXT
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	PUSHJ P,FILLST
	 PUTHDR
	MOVEI T,[ASCIZ/DIPTYPE		PIN #	OFF	ON	TOTAL
			   BOARD/]
	MOVEM T,HEADER
	MOVEI T,OTSMAR
	MOVEM T,MARGIN
	SETZM LINCNT
	PUSHJ P,DCLEAR		;CLEAR DIP TEMP CELL
	SETZM CDSKPC
	MOVEI H,RADDR(W,WBDY,NXTB);GOING DOWN BODY LIST
OTS1:	SETZM LSLOT		;FORGET LAST SLOT
	SETZM LSTDIP		;AND DIP TYPE
OTS2:	FETCH(H,H,NXTB)		;NEXT BODY
	JUMPE H,OTSDON
	FETCH(TTT,H,BBIT)
	TRNE TTT,CBODY		;CONNECTOR BODY?
	JRST OTS2		;YES, SKIP
	FETCH(G,H,DIPT)		;GET DIP TYPE
	JUMPE G,[AOS CDSKPC
		JRST OTS2]
	FETCH(TTT,G,DTMP)
	TROE TTT,1		;THIS DIP DONE YET?
	JRST OTS2		;YES
	STORE(TTT,G,DTMP)	;NO, STORE BIT ON
	MOVEM G,LSTDIP
	TLZ TFLG		;FLAG DIPTYPE NOT PRINTED YET
	MOVEI G,RADDR(G,DPIN,DPNXT)
	JRST OTS4

OTS3:	FETCH(E,G,DPNM)
	FETCH(T,G,DPBIT)	;GET PIN TYPE BITS
	TRNN T,OUTLD		;OUTPUT?
	JRST OTS4		;NO, TRY NEXT ONE
	MOVE F,H		;GOT ONE, START WITH FIRST BODY
	SETZ D,			;CLEAR COUNTS
	JRST OTS5

OTS6:	FETCH(T,F,DIPT)		;GET DIP TYPE
	CAMN T,LSTDIP		;SAME DIP?
	JRST OTS5		;YES
OTS7:	FETCH(F,F,NXTB)		;LOOK FOR ANOTHER BODY OF THIS DIP TYPE
	JUMPN F,OTS6
	JUMPE D,OTS4		;IF NO COUNT, GO STRAIGHT TO NEXT PIN
	TLOE TFLG		;DIP NAME OUT YET?
	JRST OTS10		;YES
	SKIPL LINCNT
	PUSHJ P,PUTHDR
	MOVE A,LSTDIP
	FETCH(A,A,DNAM)
	PUSHJ P,STROUT		;PRINT DIP NAME
	MOVE T,LCOUNT
	CAIGE T,8
	PUTBYT 11
	CAIA
OTS10:	PUTBYT 11
	PUTBYT 11
	MOVE T,E
	PUSHJ P,DECOUT		;PIN #
	PUTBYT 11
	HLRZ T,D
	PUSHJ P,DECOUT		;# OFF BOARD
	PUTBYT 11
	HRRZ T,D
	PUSHJ P,DECOUT		;# ON BOARD
	PUTBYT 11
	HLRZ T,D
	ADDI T,(D)
	PUSHJ P,DECOUT		;TOTAL
	CRLF
	JRST OTS4		;TRY ANOTHER DIP PIN

OTS5:	FETCH(C,F,BPIN)		;GET BODY PIN LIST
	JUMPE C,OTS7		;IF NONE, LOOP BACK FOR ANOTHER BODY
OTS8:	FETCH(T,C,PBIT)
	TRNE T,DUP		;SKIP DUP'S
	JRST OTS9
	FETCH(T,C,PINN)		;GET PIN #
	CAME T,E		;SAME AS ONE WE ARE DOING?
	JRST OTS9
	FETCH(TT,C,HPNT)		;GET WIRE HEADER POINTER
	FETCH(T,TT,WBIT)	;WIRE TYPE BITS
	TRNE T,WNULL!WSINGL	;IGNORE THESE PINS
	JRST OTS9
	FETCH(T,TT,TBIT)	;GET ACCUMULATED TYPE BITS
	TRNN T,ANYCON		;IS THERE A TERMINATOR ON THIS RUN?
	AOJA D,OTS9		;NO, COUNT UNTERMINATED
	ADD D,[1,,0]		;YES, COUNT AS TERMINATED
OTS9:	FETCH(C,C,NXBP)		;NEXT BODY PIN
	JUMPN C,OTS8
	JRST OTS7		;GET ANOTHER BODY

OTS4:	FETCH(G,G,DPNXT)	;NEXT DIP PIN
	JUMPN G,OTS3
	JRST OTS1		;TRY FOR ANOTHER DIP

OTSDON:	SKIPN T,CDSKPC
	JRST OTSDN1
	CRLF
	PUTSTR[ASCIZ/NUMBER OF BODIES WITH NO DIP TYPE = /]
	PUSHJ P,DECOUT
	CRLF
OTSDN1:	RELEASE LST,
	POPJ P,
SUBTTL	'OTL'		OUTPUT TERMINATION LISTING
TRMLST:	SKIPN DIPLST
	JRST [	OUTSTR[ASCIZ/SORRY, NO DIPS.
/]
		POPJ P,]
	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	FETCH(H,W,WBDY)
	JUMPE H,[OUTSTR[ASCIZ/NO BODIES AT ALL!
/]
		POPJ P,]	;SKIP IF NO BODIES
	MOVSI T,'OTL'		;OUTPUT TERMINATION LIST EXT
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	PUSHJ P,FILLST
	 PUTHDR
	PUSHJ P,CLEARP		;CLEAR PIN MARK BITS
	MOVEI H,RADDR(W,WIRES,ALPH)
	JRST TRML1

TRML2:	FETCH(T,H,WBIT)
	TRNE T,NAM2ND!WNULL!WSINGL!SNC!SHI!SPWR!SGND	;INTERESTING RUN?
	JRST TRML1		;NO, SKIP IT
	FETCH(G,H,WPIN)
	SETZB F,E		;NO CON FOUND YET
TRML3:	FETCH(T,G,PTYP)
	JUMPE T,TRML6
	FETCH(T,T,DPBIT)
	TRNE T,OUTLD		;FOUND OUTPUT?
	JRST TRML5		;YES, WIN IMMEDIATELY
	JUMPN F,TRML4		;LOOK NO FURTHER IF WE HAVE CON
TRML6:	FETCH(T,G,PBDY)
	FETCH(T,T,BBIT)
	TRNE T,CBODY
	JRST [	MOVE F,G		;REMEMBER CON
		JRST TRML4]
	JUMPN E,TRML4
	FETCH(T,G,PTYP)
	JUMPE T,TRML4
	FETCH(T,T,DPBIT)
	TRNN T,TERM		;DON'T REMEMBER TERM
	MOVE E,G
TRML4:	FETCH(G,G,NXTP)
	JUMPN G,TRML3
	SKIPE G,F
	JRST TRML5		;WE HAVE CON
	SKIPN G,E		;NO CON, DO WE HAVE NON TERM?
	FETCH(G,H,WPIN)		;NO, USE FIRST PIN OF RUN
TRML5:	FETCH(T,G,PBIT)
	TRO T,PTMP1
	STORE(T,G,PBIT)
TRML1:	FETCH(H,H,ALPH)
	JUMPN H,TRML2
	TRZ CONLY
TRMLB0:	TRNE CONLY
	SKIPA T,[[ASCIZ/UNTERMINATED RUNS
TEST PIN	DIPTYPE		SIGNAL/]]
	MOVEI T,[ASCIZ/TERMINATED RUNS
TEST PIN	DIPTYPE		TERM PIN	VALUE		SIGNAL/]
	MOVEM T,HEADER
	MOVEI T,OTLMAR
	MOVEM T,MARGIN
	SETZM LINCNT
	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST TRMLB1

TRMLB2:	FETCH(G,H,BPIN)
TRMLB4:	FETCH(T,G,PBIT)
	TRNN T,PTMP1
	JRST TRMLB3
	FETCH(T,G,HPNT)
	FETCH(T,T,TBIT)
	TRNE CONLY
	TRC T,TERM		;INVERT TEST ON SECOND PASS
	TRNN T,TERM
	JRST TRMLB3
	SKIPL LINCNT
	PUSHJ P,PUTHDR
	FETCH(A,H,BLOC)
	FETCH(T,G,PINN)
	HRL A,T
	FETCH(T,H,BBIT)
	TRNN T,CBODY
	JRST TRMLB5
	PUSHJ P,LOCPNW
	JRST TRMLB6

TRMLB5:	FETCH(B,H,BPAK)
	PUSHJ P,LOCPNP
TRMLB6:	MOVEI A,=16
	PUSHJ P,FILL
	FETCH(T,H,BBIT)
	TRNN T,CBODY
	JRST TRMLB7
	PUTSTR[ASCIZ/CON/]
	JRST TRMLB8

TRMLB7:	FETCH(A,H,DIPT)
	JUMPE A,TRMLB8
	FETCH(A,A,DNAM)
	PUSHJ P,STROUT
TRMLB8:	FETCH(F,G,HPNT)
	TRNE CONLY
	JRST TRMLC1
	FETCH(E,F,WPIN)
	PUSHJ P,TRMPNT
	JFCL
	MOVEI A,=64
	PUSHJ P,FILL
	FETCH(F,G,HPNT)
	PUTSIG ADDR(F,SPNT)
	CRLF
TRMLB9:	PUSHJ P,TRMPNT
	JRST TRMLB3
	CRLF
	JRST TRMLB9

TRMLC1:	MOVEI A,=32
	PUSHJ P,FILL
	PUTSIG ADDR(F,SPNT)
	CRLF
TRMLB3:	FETCH(G,G,NXBP)
	JUMPN G,TRMLB4
TRMLB1:	FETCH(H,H,NXTB)
	JUMPN H,TRMLB2
	TRON CONLY		;SECOND PASS YET?
	JRST TRMLB0		;NO, DO IT
	RELEASE LST,
	POPJ P,

TRMPN1:	FETCH(T,E,PTYP)
	JUMPE T,TRMPN2
	FETCH(T,T,DPBIT)
	TRNE T,TERM
	JRST TRMPN3
TRMPN2:	FETCH(E,E,NXTP)
TRMPNT:	JUMPN E,TRMPN1
	POPJ P,

TRMPN3:	MOVEI A,=32
	PUSHJ P,FILL
	PUSH P,F
	FETCH(F,E,PBDY)
	FETCH(T,F,BBIT)
	FETCH(A,F,BLOC)
	FETCH(TT,E,PINN)
	HRL A,TT
	FETCH(B,F,BPAK)
	PUSHJ P,LOCPNP
	MOVEI A,=48
	PUSHJ P,FILL
	PUSH P,E
	PUSHJ P,VALPNT		;PRINT VALUE OF TERM
	POP P,E
	POP P,F
	FETCH(E,E,NXTP)
	JRST CPOPJ1
SUBTTL	'RES'		FILE FOR RESISTOR DRAWING
DEC,<
RESFIL:	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	MOVSI T,'RES'		;RESISTOR FILE
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	TLO SIMTAB		;ALWAYS SIMULATE TABS
	MOVEI H,RADDR(W,WIRES,ALPH)
	JRST RESFL1

RESFL2:	FETCH(T,H,WBIT)
	TRNE T,NAM2ND
	JRST RESFL1		;ONLY LOOK AT REAL WIRES
	FETCH(T,H,TBIT)
	TRC T,ECL!TERM
	TRCE T,ECL!TERM		;ANY ECL TERMS ON THIS WIRE?
	JRST RESFL1
	MOVEI G,RADDR(H,WPIN,NXTP)
	JRST RESFL3

RESFL4:	FETCH(T,G,PTYP)
	JUMPE T,RESFL3
	FETCH(T,T,DPBIT)
	TRC T,ECL!TERM
	TRCE T,ECL!TERM
	JRST RESFL3
	FETCH(T,G,PBIT)
	FETCH(F,G,PBDY)
	TRNE T,DUP		;DON'T REPEAT LOC IF DUP
	JRST RESFL5
	FETCH(A,F,BLOC)
	FETCH(T,G,PINN)
	HRL A,T
	FETCH(B,F,BPAK)
	PUSHJ P,LOCPNP		;PUT OUT LOC
RESFL5:	MOVEI A,=16
	PUSHJ P,FILL
	FETCH(A,G,FILP)
	PUTSIX ADDR(A,FILN)
	PUTBYT 11
	FETCH(A,F,BBIT)
	PUSHJ P,BPPNT		;DWG POS
	PUTBYT 11
	PUSHJ P,VALPNT
	MOVEI A,=48
	PUSHJ P,FILL
	FETCH(A,G,HPNT)
	PUTSIG ADDR(A,SPNT)
	CRLF
RESFL3:	FETCH(G,G,NXTP)
	JUMPN G,RESFL4
RESFL1:	FETCH(H,H,ALPH)
	JUMPN H,RESFL2
	RELEASE LST,
	POPJ P,
>;DEC

;VALPNT -PRINT "VALUE" PROPERTY OF RESISTOR
;CALL WITH F:POINTER TO BODY
;CLOBBERS E, A, T, TT, TTT
VALPNT:	FETCH(E,F,PRTN)
	JUMPE E,RESFL6
RESFL7:	FETCH(T,E,PRNB)
	FETCH(T,T,PRNS)
	MOVEI TT,[ASCIZ/VALUE/]
	PUSHJ P,ASCPAR		;IS THIS VALUE PROPERTY?
	JRST RESFL8
	JRST RESFL8
	FETCH(A,E,PRVS)
	JRST STROUT

RESFL8:	FETCH(E,E,PRPP)
	JUMPN E,RESFL7
RESFL6:	PUTSTR[ASCIZ\N/A\]
	POPJ P,
SUBTTL	'MPL'		MASTER PARTS LIST - READ COUNTS
MPART:	SKIPN H,MODLST
	JRST [	OUTSTR[ASCIZ/NO MODULES.
/]
		POPJ P,]
CLMCNT:	CLEAR(H,MNUM)
	FETCH(H,H,MNXT)
	JUMPN H,CLMCNT
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE T,[PUSHJ P,TTYOUT]
	MOVEM T,PUTCHR
	MOVSI T,'MCF'
	MOVEM T,DEFEXT
	TLZ ASKHIM		;ASSUME WILL NOT READ FILE
	PUSHJ P,SETFIL
	JRST NOMODC
	TLO ASKHIM		;WE ARE READING FILE
	PUSHJ P,IN0		;READ IN TEXT MODE
	POPJ P,			;FOO
	LOOKUP DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/LOOKUP FAILED, CODE= /]
		HRRZ T,FILEXT
		PUSHJ P,DECOUT
		OUTSTR[ASCIZ/
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
	MOVE T,[PUSHJ P,BYTIN]
	MOVEM T,GETCHR
	SKIPE B,MPLTIT
	PUSHJ P,PUTFS
	SETZM MPLTIT
	PUSHJ P,ISTR
	JRST IMCFE
	JFCL			;ALTMODE FROM FILE, IGNORE IT
	SETZ B,			;NULL, STORE NULL
	MOVEM B,MPLTIT
	CAIN TTT,12
	JRST IMCF1
	PUTSTR[ASCIZ/ILLEGAL TAB OR ALTMODE IN TITLE LINE:
/]
	SKIPE A,MPLTIT
	PUSHJ P,STROUT
	PUTBYT 11
	JRST ILLLN3

IMCF1:	PUSHJ P,ISTR
	JRST IMCFE		;END OF FILE HERE OK
	JRST ILLLIN		;ALTMODE ILLEGAL
	JRST ILLLIN		;ILLEGAL LINE, SKIP IT
	MOVEM B,STRING
	SETZ B,
	CAIE TTT,11
	JRST IMCF2
	PUSHJ P,DECIN
	JRST MCFEOB
	MOVE B,A
IMCF2:	CAIE TTT,12
	JRST ILLLN1		;ILLEGAL FORMAT LINE
	MOVE A,MODLST
IMCF3:	FETCH(T,A,MNAM)
	MOVE TT,STRING
	PUSHJ P,TXTMAT
	JRST IMCF4
	JRST IMCF5
	FETCH(T,A,MNUM)
	JUMPE T,IMCFOK
	PUTSTR[ASCIZ/COUNT FOR MODULE APPEARS MORE THAN ONCE:
/]
	PUSH P,A
	FETCH(A,A,MNAM)
	PUSHJ P,STROUT
	POP P,A
	PUTBYT 11
	FETCH(T,A,MNUM)
	PUSHJ P,DECOUT
	PUTSTR[ASCIZ/ OLD	/]
	MOVE T,B
	PUSHJ P,DECOUT
	PUTSTR[ASCIZ/ NEW
/]
IMCFOK:	STORE(B,A,MNUM)
	MOVE B,STRING
	PUSHJ P,PUTFS
	JRST IMCF1

IMCF4:	FETCH(A,A,MNXT)
	JUMPN A,IMCF3
IMCF5:	PUTSTR[ASCIZ/MODULE NOT FOUND:
/]
	MOVE A,STRING
	PUSHJ P,STROUT
	PUTSTR[ASCIZ/
/]
	MOVE B,STRING
	PUSHJ P,PUTFS
	JRST IMCF1

ILLLN1:	PUTSTR[ASCIZ/FORMAT ERROR IN LINE STARTING:
/]
	MOVE A,STRING
	PUSHJ P,STROUT
	PUTSTR[ASCIZ/
/]
	MOVE B,STRING
	PUSHJ P,PUTFS
ILLLN2:	XCT GETCHR
	JRST MCFEOF
	CAIE TTT,12
	JRST ILLLN2
	JRST IMCF1

ILLLIN:	CAIN TTT,12
	JRST IMCF1		;JUST SKIP BLANK LINES
	PUTSTR[ASCIZ/NULL MODULE NAME ON LINE:
	/]
ILLLN3:	XCT GETCHR
	JRST [	PUTSTR[ASCIZ/
/]
		JRST MCFEOF]
	CAIN TTT,12
	JRST [	PUTSTR[ASCIZ/
/]
		JRST IMCF1]
	PUTBYT (TTT)
	JRST ILLLN3

MCFEOB:	MOVE B,STRING
	PUSHJ P,PUTFS
MCFEOF:	PUTSTR[ASCIZ/END OF FILE IN MID-LINE.
/]
IMCFE:	RELEASE DAT,
NOMODS:	OUTSTR[ASCIZ/% SPARES? /]
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,DECIN
	JFCL
	CAIE TTT,12
	JRST [	PUSHJ P,IERR
		OUTSTR[ASCIZ/INPUT ERROR.
/]
		JRST NOMODS]
	MOVEM A,FACTR1
;		MASTER PARTS LIST - LISTING
NOMODC:	MOVSI T,'MPL'		;MASTER PARTS LIST EXT
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	PUSHJ P,FILLST
	 MHDRA
	MOVEI T,MPMMAR
	MOVEM T,MARGIN
	SETZM LINCNT
	MOVEI T,[ASCIZ/MODULE	COUNT/]
	MOVEM T,HEADER
	MOVE H,MODLST
MODPN1:	SKIPL LINCNT
	PUSHJ P,MHDRA
	FETCH(A,H,MNAM)
	PUSHJ P,STROUT
	PUTBYT 11
	FETCH(T,H,MNUM)
	PUSHJ P,DECOUT
	CRLF
	FETCH(H,H,MNXT)
	JUMPN H,MODPN1
	MOVEI T,MPLMAR
	MOVEM T,MARGIN
	SETZM LINCNT
	SKIPN H,PARTLIST
	JRST MPART2
MPART1:	FETCH(G,H,MDCN)
	SKIPE G
	PUSHJ P,MPRTDO
	FETCH(H,H,NXPL)
	JUMPN H,MPART1
MPART2:	SKIPE G,NULPART
	PUSHJ P,MPRTDO
	JRST MPARTE

MPRTDO:	;CLEAR SUBTOTAL COUNTS HERE
MPRTD1:	FETCH(F,G,MXPT)
MPRTD2:	FETCH(E,F,MCPT)
	SETZM LSTDIP
	SETZM NDIPS
	SETZM CONFLG
	TLZ TFLG
MPRTD3:	FETCH(D,E,MODC)
	FETCH(T,D,MNUM)
	TLNE ASKHIM
	JUMPE T,MPRTD4
	TLOE TFLG
	JRST MPRTD5
	SKIPL LINCNT
	PUSHJ P,MHDR
	JUMPE H,MPRTE0
	FETCH(A,H,PLPT)
	FETCH(A,A,PRVS)
	PUSHJ P,STROUT
	JRST MPRTE1

MPRTE0:	PUTSTR[ASCIZ\N/A\]
MPRTE1:	MOVEI A,=16
	PUSHJ P,FILL
	FETCH(A,G,MDIP)
	JUMPE A,[PUTSTR[ASCIZ\N/A\]
		JRST MPRTE2]
	FETCH(A,A,DNAM)
	PUSHJ P,STROUT
MPRTE2:	JUMPE H,MPRTE3
	FETCH(C,H,PLPT)
	JRST MPRTE4

MPRTE5:	FETCH(T,C,PRBT)
	TRNE T,NULVAL
	JRST MPRTE4
	MOVE T,LWIDTH
	SUB T,LCOUNT
	CAIGE T,=16		;AT LEAST 2 TABS STOPS LEFT?
	CRLF			;NO, NEW LINE
	MOVEI A,=32
	CAML A,LCOUNT
	JRST [	PUSHJ P,FILL
		JRST MPRTE6]
	PUTSTR[ASCIZ/, /]
MPRTE6:	FETCH(A,C,PRVS)
	PUSHJ P,STROUT
MPRTE4:	FETCH(C,C,PRPP)
	JUMPN C,MPRTE5
	CRLF
MPRTE3:	FETCH(C,F,MPRX)
	JUMPE C,MPRTF1
MPRTF2:	MOVE T,LWIDTH
	SUB T,LCOUNT
	CAIGE T,=24
	CRLF
	MOVEI A,=32
	CAML A,LCOUNT
	JRST [	PUSHJ P,FILL
		JRST MPRTF3]
	PUTSTR[ASCIZ/, /]
MPRTF3:	FETCH(A,C,TLFT)
	PUSHJ P,STROUT
	PUTBYT ":"
	FETCH(A,C,TRHT)
	PUSHJ P,STROUT
	FETCH(C,C,NXTT)
	JUMPN C,MPRTF2
MPRTF1:	SKIPE LCOUNT
	CRLF
MPRTD5:	HRRZS CONFLG		;HAVEN'T USED APPROX COUNT ON THIS MODULE YET
	PUTBYT 11
	FETCH(A,D,MNAM)
	PUSHJ P,STROUT
	PUTBYT 11
	FETCH(A,D,MNUM)
	SKIPE T,A
	PUSHJ P,DECOU5
	PUTBYT 11
	FETCH(T,E,MAPP)
	JUMPN T,[SETOM CONFLG
		JRST MPRTD6]
	FETCH(T,E,MREA)
MPRTD6:	IMUL A,T
	ADDM T,LSTDIP
	ADDM A,NDIPS
	PUSHJ P,DECOU5
	SKIPGE CONFLG		;IS THIS APPROX NUMBER?
	PUTBYT "A"		;YES
	TLNN ASKHIM		;DO WE HAVE MODULE COUNT?
	JRST MPRTD7		;NO, SO NO TOTAL FOR MODULE TYPE
	PUTBYT 11
	MOVE T,A
	PUSHJ P,DECOU5
	SKIPGE CONFLG
	PUTBYT "A"
MPRTD7:	CRLF
MPRTD4:	FETCH(E,E,MCNX)
	JUMPN E,MPRTD3
	TLNE ASKHIM		;SKIP SUMMARY IF MODULE COUNTS ONLY
	SKIPN H			;SKIP ALSO IF NO PART NUMBER
	JRST MPRTD9
	MOVEI A,=24
	PUSHJ P,FILL
	MOVE T,LSTDIP
	PUSHJ P,DECOU5
	SKIPE CONFLG
	PUTBYT "A"
	SKIPN T,NDIPS
	JRST MPRTD8
	PUTBYT 11
	PUSHJ P,DECOU5
	SKIPE CONFLG
	PUTBYT "A"
	PUTBYT 11
	MOVE A,NDIPS
	IMUL A,FACTR1
	IDIVI A,=100
	CAIL B,=50
	ADDI A,1
	SKIPN A
	MOVEI A,1
	MOVE T,A
	PUSHJ P,DECOU5
	SKIPE CONFLG
	PUTBYT "A"
	PUTBYT 11
	ADD A,NDIPS
	MOVE T,A
	PUSHJ P,DECOU5
	SKIPE CONFLG
	PUTBYT "A"
MPRTD8:	CRLF
MPRTD9:	FETCH(F,F,MXNX)
	JUMPN F,MPRTD2
	FETCH(G,G,MDNX)
	JUMPN G,MPRTD1
;SUBTOTALS HERE?
	POPJ P,

MPARTE:	SKIPE B,MPLTIT
	PUSHJ P,PUTFS
	SETZM MPLTIT
	RELEASE LST,
	POPJ P,

MHDR0:	TLZN NOFF
	PUTSTR[BYTE(7)15,14]
	PUSH P,A
	MOVN TTT,PAGLEN
	ADD TTT,MARGIN
	MOVEM TTT,LINCNT
	SETZM TCOUNT
	SKIPE A,MPLTIT
	PUSHJ P,STROUT
	PUSHJ P,PNTFDT
	CRLF
	POP P,A
	POPJ P,

MHDRA:	PUSHJ P,MHDR0
	PUTSTR @HEADER
	PUTSTR[ASCIZ/
/]
	POPJ P,


MHDR:	PUSHJ P,MHDR0
	PUTSTR [ASCIZ/PART NUMBER	DIPTYPE		DESCRIPTION
	MODULE	# OF	# OF	# OF	/]
	MOVE T,FACTR1
	PUSHJ P,DECOUT
	PUTSTR[ASCIZ\ %	TOTAL
	 NAME	MODULES	PARTS/	PARTS	SPARE	# OF
			MODULE	* # OF	PARTS	PARTS
				MODULES

\]
	POPJ P,
SUBTTL	'TTY'		PIN/SIGNAL/BODY FOR ONE LOC
TTYUSE:	MOVE L,DEFLST
	PUSHJ P,LSTGET
	 POPJ P,
	OUTSTR[ASCIZ/DIP(/]
	OUTSTR @WBDCUE
	OUTSTR[ASCIZ/) OR CONNECTOR(/]
	OUTSTR @CBCUE
	OUTSTR[ASCIZ/) LOCATION?/]
	PUSHJ P,GETLOC
	 JRST ERRET
	CAIE TTT,12
	 JRST ERRET
	HRRZM TT,LETTER
	HRRZM TT,SAVET
	HLLZM TT,NUMBER		;SAVE MAPCON BIT
	MOVEI H,RADDR(W,WBDY,NXTB)
TTYULP:	PUSHJ P,SERLOC		;Find loc in LETTER
	 JRST [	OUTSTR[ASCIZ/NO SUCH LOC!
/]
		POPJ P,]
	MOVEM H,FSTBOD
	MOVE T,[PUSHJ P,TTYOUT]
	MOVEM T,PUTCHR
	SETOM TTYFLG
	SETZM LCOUNT
	FETCH(T,H,BBIT)
	TRNE T,CBODY
	 JRST TTYCUS		;YES
	SKIPGE NUMBER		;DOUBLE CHECK THAT WE WEREN'T LOOKING FOR CONN
	 JRST TTYULP
	OUTSTR[ASCIZ/LOC	DIPTYPE	BODY	POS	FILE
	PIN #	TYPE	HI	LOW	USE	SIGNAL NAME

/]
TTYUS2:	PUSHJ P,USEP3		;PRINT LINE FOR THIS BODY
	PUSHJ P,SERLOC
	 CAIA
	 JRST TTYUS2		;Print any others in same loc (LETTER)
	SKIPN ISWW
	 POPJ P,
	PUTBYT 11
	PUTSTR [ASCIZ /AT X,Y= /]
	MOVE A,FSTBOD
	FETCH(B,A,BPAK)
	FETCH(A,A,BLOC)
	PUSHJ P,PAKSIZ
	 JFCL
	PUSH P,T		;MIN X,,Y
	PUSH P,TT
	HLRE T,T		;MIN X
	PUSHJ P,DECOUT
	PUTBYT "/"
	HLRE T,(P)
	PUSHJ P,DECOUT
	PUTSTR [ASCIZ /, /]
	HRRE T,-1(P)
	PUSHJ P,DECOUT
	PUTBYT "/"
	HRRE T,(P)
	PUSHJ P,DECOUT
	CRLF
	SUB P,[2,,2]
	POPJ P,

TTYCUS:	SKIPL NUMBER		;WE WERE REALLY LOOKING FOR A BODY
	 JRST TTYULP
	OUTSTR[ASCIZ/CONNECTORS
PIN	FILE	POS	TYPES	SIGNAL NAME

/]
	MOVNI T,10000		;SUPPRESS NEW PAGE
	MOVEM T,LINCNT
	JRST USEC3A		;PRINT CONNECTOR LINES

;SERLOC - Search for a body (or connector body) in location (LETTER)
;   ignore any DIP location within-socket-offset
;H - locative to body list 
;  skip if found

SERLOC:	FETCH(H,H,NXTB)
	JUMPE H,CPOPJ
	FETCH(A,H,BLOC)
	SKIPE ISWW
	 PUSHJ P,MAPOST		;remove any DIP offset
	 CAI
	HRRZS A
	CAME A,LETTER
	 JRST SERLOC
	JRST CPOPJ1
SUBTTL	'WLU'		BODY/PIN/SIGNAL
USEPIN:	SETZM ALLNAM
	SETZM ALLCRD
ALLUSE:	MOVE L,DEFLST
	SKIPE T,ALLCRD
	JRST [	MOVEM T,SLICEL
		JRST GALCD1]
	PUSHJ P,LSTGET
	POPJ P,
GALCD1:	FETCH(H,W,WBDY)
	JUMPE H,[OUTSTR[ASCIZ/NO BODIES AT ALL!
/]
		POPJ P,]	;SKIP IF NO BODIES
	MOVSI T,'WLU'		;WIRE LIST VERIFY FILE EXTENSION
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,ALLSET
	POPJ P,
	PUSHJ P,FILLST
	 PUTHDR
	MOVEI T,[ASCIZ/LOC	DIPTYPE	BODY	POS	FILE
	PIN #	TYPE	HI	LOW	USE	SIGNAL NAME/]
	MOVEM T,HEADER
	MOVEI T,WUPMAR
	MOVEM T,MARGIN
	SETZM LINCNT
	SETOM SAVET
USEP2:	FETCH(T,H,BBIT)
	TRNE T,CBODY		;CON?
	JRST USEC1		;YES, DO IT DIFFERENTLY
	FETCH(T,H,BLOC)
	JUMPE T,USENLC
	CAMN T,SAVET
	JRST USEP3X
USENLC:	MOVEM T,SAVET
	SKIPL LINCNT		;NEED A HEADER?
	PUSHJ P,PUTHDR		;WE ALWAYS GET A HEADER HERE
USEP3X:	PUSHJ P,USEP3		;POOT OUT THIS BODY
	FETCH(H,H,NXTB)
	JUMPN H,USEP2
USE0:	RELEASE LST,
	POPJ P,

USEP3:	FETCH(A,H,BLOC)
	FETCH(T,H,BBIT)
	PUSHJ P,WLOCOUT		;OUT OUT DAMN LOC
	PUTBYT 11
	FETCH(A,H,DIPT)
	JUMPE A,[PUTSTR[ASCIZ/NONE/]
		JRST USEP4]
	FETCH(A,A,DNAM)
	PUSHJ P,STROUT		;DIPTYPE
USEP4:	PUTBYT 11
	SKIPN ADDR(H,BNAM)
	PUTSTR[ASCIZ/NONE/]
	PUTSTR ADDR(H,BNAM)
	PUTBYT 11
	FETCH(A,H,BBIT)
	PUSHJ P,BPPNT
	PUTBYT 11
	FETCH(A,H,FILB)
	PUTSIX ADDR(A,FILN)	;FILENAME
	FETCH(F,H,BPIN)
	JUMPN F,USEP8A
	PUTSTR[ASCIZ/	NO PINS/]
	CRLF
	POPJ P,			;JUST GET ANOTHER BODY

USEP8A:	CRLF
USEP8:	PUTSTR[ASCIZ/	/]
	FETCH(T,F,PINN)
	SETZM TCOUNT
	PUSHJ P,DECOUT		;PIN #
	FETCH(T,F,PBIT)
	TRNN T,PIDPIN
	JRST USEP80
	MOVE TT,TCOUNT
	SUBI TT,7
	PUTBYT " "
	AOJL TT,.-1
	PUTBYT "*"
	JRST USEP81

USEP80:	PUTBYT 11
USEP81:	FETCH(G,F,PTYP)
	JUMPN G,USEP82
	PUTSTR[ASCIZ/UN			/]
	JRST USEP83

USEP82:	PUSHJ P,PNTTYP
	PUTBYT 11
	PUSHJ P,PNTLOD		;THERE'S A TAB IN HERE
	PUTBYT 11
	FETCH(A,G,DUSE)
	PUTSIX A
USEP83:	FETCH(B,F,HPNT)
;Print signal on pin, and all its synonyms
USEP9:	PUTBYT 11
	FETCH(TT,B,WBIT)
	TRNE TT,SPWR!SGND	;Print GND as simple name
	 JRST [	MOVE A,B
		PUSHJ P,GCANON
		PUTSIG ADDR(A,SPNT)
		CRLF
		JRST USEP10]
	PUTSIG ADDR(B,SPNT)
	CRLF
	FETCH(B,B,NNAM)
	JUMPE B,USEP10
	PUTSTR[ASCIZ/					/]
	JRST USEP9

USEP10:	FETCH(F,F,NXBP)		;NEXT PIN OF BODY
	JUMPN F,USEP8
	POPJ P,

USEC1:	SETZM LINCNT
	MOVEI T,WUCMAR
	MOVEM T,MARGIN
	MOVEI T,[ASCIZ/CONNECTORS
PIN	FILE	POS TYPES	SIGNAL NAME/]
	MOVEM T,HEADER
	SETZM SAVET
USEC2:	FETCH(T,H,BLOC)
	CAMN T,SAVET		;NEW LOC?
	JRST USEC3X
	MOVEM T,SAVET
	PUSHJ P,PUTHDR		;YES, NEW PAGE
USEC3X:	PUSHJ P,USEC3A
	FETCH(H,H,NXTB)
	JUMPN H,USEC2
	JRST USE0

USEC3A:	FETCH(G,H,BPIN)
USEC3:	SKIPL LINCNT
	PUSHJ P,PUTHDR		;NEW HEADER
	MOVE A,SAVET
	FETCH(T,G,PINN)
	HRLI A,(T)
	FETCH(T,H,BBIT)
	PUSHJ P,LOCPNW
	PUTBYT 11
	FETCH(A,G,FILP)
	SETZM TCOUNT
	PUTSIX ADDR(A,FILN)	;FILENAME
	PUTBYT 11
	FETCH(A,G,PBIT)
	PUSHJ P,CNPNT
	MOVEI A,=20
	PUSHJ P,SPFILL		;FILL WITH SPACES TO TYPE BITS
	FETCH(B,G,HPNT)
	FETCH(A,B,TBIT)		;WIRE TYPE BITS
	PUSHJ P,PNTYPE
	FETCH(T,G,PBIT)			;GET PIN BITS
	TRNN T,TRMBTS			;ANY TERMINATOR RULE?
	JRST USEC4			;NO
	PUTBYT "("
	LDB T,[POINT TRMBSZ,T,TRMBPS+=18]
	PUSHJ P,DECOUT
	PUTBYT ")"
USEC4:	MOVEI A,=32
	PUSHJ P,FILL		;FILL WITH TABS
	PUTSIG ADDR(B,SPNT)
	CRLF
	FETCH(B,B,NNAM)
	JUMPE B,USEC5
	JRST USEC4

USEC5:	FETCH(G,G,NXBP)		;NEXT PIN
	JUMPN G,USEC3
	POPJ P,
SUBTTL	'UML'		UTILIZATION FILE - DIPS
DIPBOX__=12			;WIDTH OF BOX FOR 1 DIP
UMLINE:	BYTE(7)UBAR,UBAR,UBAR,UBAR,UBAR,UBAR,UBAR,UBAR,UBAR,UBAR,UBAR,UBAR,0
	;Yes Virginia, there are 12. of them
MTDIP:	[ASCIZ /|        |/]	;8 SPACES + 2BARS
MTDIP1:	[ASCIZ /|--------|/]	;8 SPACES + 2BARS

PNTUML:	SKIPN ISWW
	 JRST NXWW
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE L,DEFLST
	PUSHJ P,LSTGET
	JRST [	OUTSTR[ASCIZ/YOU GET A BLANK UML!
/]
		SETZ W,
		JRST .+1]
	MOVSI T,'UML'		;WIRE LIST UML FILE EXTENSION
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	 POPJ P,
NOITS,<	JUMPE W,PNTUM1	>
ITS,<
	JUMPE W,[SKIPE XGP	;BETTER NOT CALL FILLST OR CONFUSION WILL REIGN
		PUSHJ P,XGPSTR
		JRST PNTUM1]
>;ITS
	PUSHJ P,FILLST
	 PUTHDR
PNTUM1:	MOVEI T,[ASCIZ/			*******	DIP MAP *******/]
	MOVEM T,HEADER
	MOVEI T,UMLMAR
	MOVEM T,MARGIN
	SETZM LINCNT		;FORCE HEADER FIRST TIME
	MOVE T,NCOLS
	MOVEM T,MCOL

;The board type specifies how many rows/cols of DIP boxes
; make the UML map.
;This stuff decides if that map overflows a page horiz. or
; verticaly, and if so breaks it up into more than one page

UML3:	SKIPLE TT,NCLPRG	;NO COLS TO PRINT ON PAGE
	 CAILE TT,=8		;DEFAULT IS 8
	 MOVEI TT,=8
;Number of columns is MIN(8, cols-to-go)
	MOVE T,MCOL
	SUB T,TT
	JUMPGE T,UML3A		;ALL COLS FIT ON THIS PAGE?
	ADD TT,T		;YES
	SETZ T,
UML3A:	ADDI T,1
	MOVEM T,MCOL
	MOVNS TT
	HRLZS TT		;AOBJN POINTER
	MOVEM TT,COLLOP		;-#COLS TO PRINT,,
	MOVE T,NROWS		;NUMBER OF ROWS FROM CARD DEF
	MOVEM T,MROW
	MOVEI G,1		;START WITH UML ROW 1
	SETZM MROWPP		;NO ROWS YET, (FOR TOP TESTED LOOP)

UML4:	MOVN T,MROWPP		;REDUCE COUNT BY # ROWS PRINTED
	ADDB T,MROW
	JUMPLE T,UML16		;DONE WITH THIS SET OF UMLCOLS
	SKIPL LINCNT		;PREVIOUS PAGE PRINTED?
	 PUSHJ P,PUTHDR
	MOVM T,LINCNT		;# LINES LEFT TO PRINT
	ADDI T,UMLMAR		;(PUTHDR SUBS OFF MARGIN)
	IDIVI T,UMLMAR		;HOW MANY UML ROWS MAX PER PAGE?
	SKIPLE TT,NRWPRP	;SPECIFIED NUMBER OF ROWS PER PAGE?
	CAML TT,T		;MIN
	 CAIA
	 MOVE T,TT
	CAMLE T,MROW		;MORE THAN ARE LEFT?
	 MOVE T,MROW
	MOVEM T,MROWPP		;# ROWS OF DIPS TO PRINT ON NEXT PAGE
	MOVNS T
	HRL G,T
	MOVEM G,GSAVE
	PUSHJ P,ANYUML		;ANY UML ON THIS PAGE?
	 AOBJN G,.-1
	JUMPGE G,UML4		;NO DIPS, SKIP THIS PAGE
	SETZM LINCNT		;WE'LL PRINT THIS PAGE, FORCE NEW HEADER NEXT TIME
	MOVE G,GSAVE
UML4A:	PUSHJ P,UMBORD		;DO THE TOP LINE OF DIP BOXES
	CRLF
	PUSHJ P,UMLDIP		;DO DIP NAMES
	CRLF
	PUSHJ P,UMLFIL		;Drawing file name that uses this slot
;	PUSHJ P,UMLBLK		;BLANK LINE
	CRLF
	PUSHJ P,UMSECS		;SECTION USAGE
	PUTBYT 15		;CARRIAGE RETURN ONLY
	PUSHJ P,UMBORD
	CRLF
	PUSHJ P,UMLOCS		;UML DIP LOCATIONS
	CRLF
	AOBJP G,UML4		;NO CR AT END OF LOOP
	CRLF
	JRST UML4A

UML16:
	SOSLE MCOL		;COLS LEFT OVER THAT DIDN'T FIT ON PAGE?
	 JRST UML3
	JRST UMLEDG		;DO THE EDGE CONNECTORS NOW

;G = -#,,ROW
ANYUML:	MOVE E,COLLOP		;WILL ANY DIPS BE FOUND ON THIS ROW?
ANYUM1:	PUSHJ P,LOCFND
	CAIA
	 JRST CPOPJ1
	AOBJN E,ANYUM1
	POPJ P,

;HERE TO PRINT DIP TYPES FOR A ROW OF UML

UMLDIP:	MOVE E,COLLOP		;ITERATION COUNT
UML7:	SETZM TCOUNT
	PUTSTR[ASCIZ/|/]
	PUSHJ P,LOCFND
	 JRST [	PUTSTR @MTDIP1
		JRST UML8A]
	PUTBYT 40
	FETCH(A,H,DIPT)		;DIP POINTER
	JUMPE A,[PUTSTR[ASCIZ/?NONE?/]
		JRST UML8]
	FETCH(A,A,DNAM)		;DIP NAME
	PUSHJ P,PRINT8
UML8:	MOVEI A,DIPBOX-1
	PUSHJ P,TFILL
UML8A:	PUTBYT "|"
	AOBJP E,CPOPJ		;THATS ALL FOR DIP NAMES
	PUTSTR SPACING
	JRST UML7

;HERE TO PRINT DIP LOCS FOR A ROW OF UML

UMLOCS:	MOVE E,COLLOP
UML10:	SETZM TCOUNT
	PUTSTR[ASCIZ/  /]
	PUSHJ P,MAPRCU
	 JRST UML10B
	MOVE A,T
	PUSHJ P,LOCOUT
UML10B:	MOVEI A,DIPBOX
	PUSHJ P,TFILL
	AOBJP E,CPOPJ		;THATS ALL FOR UML DIP LOCS
	PUTSTR SPACING
	JRST UML10

UMBORD:	MOVE E,COLLOP		;DO THE UML TOP OR BOTTOM LINE
UMBOR0:	PUTSTR UMLINE
	AOBJP E,CPOPJ
	PUTSTR SPACING
	JRST UMBOR0

UMLFIL:
UMLBLK:	MOVE E,COLLOP		;ITERATION COUNT
UMBLK0:	SETZM TCOUNT
	PUTBYT "|"
	PUSHJ P,LOCFND
	 JRST [	PUTSTR @MTDIP	;NO DIP IN THIS SLOT, CAUSE DOUBLE BOX
		JRST UMBLK2]
;Draw attention to this slot, DIP type not defined
	MOVEI B,"|"
	FETCH(A,H,DIPT)		;DIP POINTER
	JUMPE A,UMBLK1
;Print file name of user
	FETCH(A,H,FILB)		;GET FILE BLOCK
	PUTSIX ADDR(A,FILN)
	MOVEI B,40
UMBLK1:	MOVE A,TCOUNT
	SUBI A,DIPBOX-1
	PUTBYT (B)
	AOJL A,.-1
UMBLK2:	PUTBYT "|"
	AOBJP E,CPOPJ		;THATS ALL FOR DIP NAMES
	PUTSTR SPACING
	JRST UMBLK0
;HERE FOR A ROW OF SECTION USAGE IN UML

UMSECS:	MOVE E,COLLOP
UML12:	SETZM TCOUNT
	PUTBYT "|"
	PUSHJ P,LOCFND			;FIND LOC - sets DIP location into PINLOC
	JRST [	PUTSTR @MTDIP1		;NO LOC NO NOTHING
		JRST UML20]
	PUTBYT 40
	FETCH(A,H,DIPT)			;DIP TYPE
	JUMPE A,[MOVEI A,1		;IF NO DIP TYPE, INDICATE 1 SECTION
		MOVEM A,FACTR1		;LOOK LIKE 1 SECT DIP
		SETOM FACTR2		;SEC USED
		JRST UML27]

;Count # sections in DIPtype
	SETZM FACTR1			;INIT BIGGEST SECT #
	FETCH(A,A,DPIN)			;FIRST PIN OF DIP DEF
UML21:	FETCH(T,A,DPBIT)		;PIN TYPE BITS
	TRNN T,INLD!OUTLD!TERM
	 JRST UML22
	FETCH(T,A,SCTB)			;SECTION BITS
	MOVS T,T
	JFFO T,.+2
	 JRST UML22
	AOS TT
	CAMLE TT,FACTR1
	 MOVEM TT,FACTR1
UML22:	FETCH(A,A,DPNXT)
	JUMPN A,UML21

;Now flag which sections used
	SETZM FACTR2			;INIT SECT USE BITS
UML26:	MOVEI A,RADDR(H,BPIN,NXBP)	;NOW CALC SECTION USAGE
	JRST UML23

UML24:	FETCH(TTT,A,PTYP)
	JUMPE TTT,UML23
	FETCH(T,TTT,DPBIT)		;PIN TYPE BITS
	TRNN T,INLD!OUTLD!TERM
	 JRST UML23
	FETCH(T,TTT,SCTB)		;SECTION BITS
	MOVS T,T
	JFFO T,.+1
	MOVE TT,SCTTAB(TT)		;PICKUP CORRESPONDING BIT
	IORM TT,FACTR2			;MARK BIT FOR SECTION
UML23:	FETCH(A,A,NXBP)
	JUMPN A,UML24
;Continue with other bodies in same DIP location
	FETCH(H,H,NXTB)			;NEXT BODY
	FETCH(A,H,BLOC)		;LOC
	PUSHJ P,MAPOST		;Strip away any socket offset
	 SETZ A,
	HRRZS A
	FETCH(TT,H,BBIT)
	TRNN TT,CBODY		;YES, IS THIS CONN THO?
	CAME A,PINLOC		;IS THIS IT?
	 CAIA
	 JRST UML26			;YES, LOOP BACK

;Print section usage - ooxo
UML27:	MOVEI A,DIPBOX-1
	SUB A,TCOUNT			;ROOM LEFT FOR SECTION BITS
	CAMGE A,FACTR1
	 MOVEM A,FACTR1
	SUB A,FACTR1
	CAIA
	 PUTBYT " "
	SOJGE A,.-1
	MOVSI A,400000
UML25:	TDNN A,FACTR2
	JRST [	PUTBYT "o"
		JRST .+2]
	PUTBYT "x"
	LSH A,-1
	SOSLE FACTR1
	 JRST UML25
UML20:	PUTBYT "|"
	AOBJP E,CPOPJ		;THAT ALL FOR SECTION USAGE
	PUTSTR SPACING
	JRST UML12
;		UTILIZATION FILE - PADDLES
CONBOX__=29			;SIZE OF COLUMN FOR ONE CONN

UMLEDG:	SETZM UMLEHT		;UML EDGE HEIGHT, HACK TO FIT MORE THAT ONE PER PAGE
	SETOM UMLPGF		;MAKE THE FIRST PAGE HAPPEN
	MOVEI T,[ASCIZ/   ******* EDGE CONNECTIONS  Flags: (# Output, @ Terminator, ---- Dedicated ground, ++++ Dedicated power)  *******/]
	MOVEM T,HEADER
	MOVN G,NPADS
	HRLZ G,G
UMLC0:	MOVEM G,MROW
	HLLZ G,G
III,<	CAMG G,[-3,,0]		;IF MORE THAN 4 TO GO
	MOVSI G,-3		;ONLY DO 4 NOW
>;III
NOIII,<	CAMG G,[-4,,0]		;IF MORE THAN 4 TO GO
	MOVSI G,-4		;ONLY DO 4 NOW
>;NOIII
	HRR G,MROW
	MOVEM G,MCOL
UMLC1:	PUSHJ P,LOCFNC		;Is there a paddle[i] ?
	 TDZA H,H		;None, make a 0
	FETCH(H,H,BPIN)		;PIN LIST
	MOVEM H,PADDLE(G)
	AOBJN G,UMLC1
	AOSN UMLPGF		;UML PAGE FLAG
	 PUSHJ P,PUTHDR
	MOVE T,LINCNT
	SKIPN UMLEHT		;DO WE WANT TO KNOW THE # LINES IN THE HEADER?
	 MOVEM T,UMLEHT		;YES, NEGATIVE MEANS WE ARE DOING FIRST GROUP

;Label the 4 columns with the paddle name
	MOVE G,MCOL
UMLL1:	SETZM TCOUNT
	MOVEI A,CONBOX/2-3	;APPROX CENTERED
	PUSHJ P,TFILL
	MOVEI T,1(G)
	HRRZ TT,PADLET		;FIRST PIN
	HRRZ TTT,PADPIN
	PUSHJ P,MAPPAD
	MOVE A,T
	SKIPE A			;NO PADDLE THERE
	 PUSHJ P,PADPRT
	MOVEI A,CONBOX
	PUSHJ P,TFILL
	AOBJN G,UMLL1
	CRLF
;Now print the connector "groups", fitting them onto the same page if possible.
	MOVE F,MCOL
	PUSHJ P,UMLCP
	MOVE G,MROW
NOIII,<	ADD G,[4,,4] >		;ADVANCE BY 4
III,<	ADD G,[3,,3] >		;ADVANCE BY 3
	SKIPL T,UMLEHT		;SKIP IF THIS IS FIRST GROUP
	 JRST UMLL2		;   NOT FIRST, DECIDE IF MORE WILL FIT ON THE PAGE
	SUB T,LINCNT
	SUBI T,1		;ONE BLANK LINE BETWEEN GROUPS
	MOVNM T,UMLEHT
	MOVNS T
UMLL2:	ADD T,LINCNT		;WILL NEXT GROUP OVERFLOW PAGE?
	JUMPG T,[SETOM UMLPGF	;    NO, CAUSE A CALL TO PUTHDR
		JRST UMLL3]
	CRLF			;PUT IN BLANK LINE BETWEEN GROUPS
UMLL3:	JUMPL G,UMLC0		;ANY MORE?
	RELEASE LST,
	POPJ P,


;PRINT CONNECTOR TABLES
UMLCP:	MOVEM F,COLLOP		;-COL#,,PADDLE#
	MOVE G,PADLET		;-#PADDLE-LETTERS,,FIRST LETTER#
;"____________________" on first line.
UMLC2:	HLRE A,COLLOP
	IMULI A,CONBOX		;PAGE WIDTH
	PUTBYT UBAR
	AOJLE A,.-1
;Now print row for all pins with this same leading letter.
UMLC2A:	MOVE E,PADPIN		;-#PINS-WITHIN-LETTER,,FIRST PIN#
UMLC2B:	PUSHJ P,UMLCS
	AOBJN E,.-1
ITS,<	SKIPE XGP
	 JRST [	PUTXGP [BYTE(7)177,1,47,1]	;STOP UNDERBAR
		AOBJN G,UMLC2A
		JRST UMLC2C]
>;ITS
	PUTBYT 15
	AOBJN G,UMLC2
	HLRE A,COLLOP
	IMULI A,CONBOX
	PUTBYT UBAR
	AOJLE A,.-1
UMLC2C:	PUTSTR[ASCIZ/
/]
	POPJ P,

;Print one line of connector info
UMLCS:	PUTSTR[ASCIZ/
|/]				;FINISH THE PREVIOUS ROW
;(On XGP, use underline featrure on last row of box)
	HLRE T,E
	AOJN T,UMLC3A		;LAST LINE OF GROUP?
ITS,<	SKIPN XGP		;AND ON XGP
	 JRST UMLC3A
	PUTXGP [BYTE(7)177,1,46]	;START UNDERBAR
>;ITS
UMLC3A:	MOVE F,COLLOP
UMLC3:	SETZM TCOUNT
	MOVEI A,40		;FLAG CHAR
	HRLM A,(P)
	MOVEI T,1(F)		;PADDLE#
	MOVEI TT,(G)		;LETTER#
	MOVEI TTT,(E)		;PIN#
	PUSHJ P,MAPPAD
	JUMPE T,UMLC6A		;NO SUCH PIN
	MOVEM T,LSTPIN
	MOVE A,T
	PUSHJ P,PRNPIN
	LDB T,[%%PINN,,A]	;JUST THE PIN #
	PUTBYT 40
	SKIPN TT,PADDLE(F)	;PIN LIST FOR THIS PADDLE
	 JRST UMLC6
UMLC4:	FETCH(TTT,TT,PINN)
	CAME TTT,T
	 JRST [	FETCH(TT,TT,NXBP)	;NEXT PIN ON CONNECTOR
		JUMPN TT,UMLC4
		JRST UMLC6]
	FETCH(A,TT,HPNT)
	FETCH(T,A,TBIT)
	MOVEI TT,"@"
	TRNE T,TERM
	 HRLM TT,(P)
	MOVEI TT,"#"
	TRNE T,OUTLD
	 HRLM TT,(P)
	MOVEI A,ADDR(A,SPNT)
	PUSHJ P,PRNTCS
UMLC6:	MOVE A,LSTPIN
	PUSHJ P,PINBIT		;CHECK FOR PWR OR GND
	MOVEI A," "
	TLNE TT,PWR
	 MOVEI A,"+"
	TLNE TT,GND
	 MOVEI A,"-"
UMLC6A:	MOVE T,TCOUNT
	SUBI T,CONBOX-3		;SPACE, FLAG, AND V-BAR
	SKIPGE T
	 PUTBYT (A)
	AOJL T,.-1
	PUTBYT " "
	HLRZ A,(P)
	PUTBYT (A)
	PUTBYT "|"
	AOBJN F,UMLC3
	POPJ P,
;		UTILIZATION FILE - SUBRS
;Print signal name within space allowed.
PRNTCS:	ADD A,[POINT 7,0]
	MOVEI T,CONBOX-3
	SUB T,TCOUNT
PRNTCT:	ILDB TTT,A
	JUMPE TTT,CPOPJ
	CAIN TTT,11		;Flush tabs that appear because of H,L hack
	 MOVEI TTT,40
	XCT PUTCHR
	SOJG T,PRNTCT
	POPJ P,

MAPRCU:	HRRZ T,E
	ADD T,MCOL		;UML COL
	HRL T,G			;UML ROW
	PUSHJ P,MAPRC		;T = UML ROW,,UML COL
	 POPJ P,
	JRST CPOPJ1

LOCFNC:	HRRZ TT,PADLET		;First pin on this paddle, from board definition
	HRRZ TTT,PADPIN
	MOVEI T,1(G)		;PADDLE#
	PUSHJ P,MAPPAD
	HRRZM T,PINLOC		;The paddle "body" location
	JUMPE W,CPOPJ
	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST LOCFCA

LOCFC1:	FETCH(A,H,BLOC)
	CAME A,PINLOC
	 JRST LOCFCA
	FETCH(TT,H,BBIT)
	TRNE TT,CBODY
	 JRST CPOPJ1
LOCFCA:	FETCH(H,H,NXTB)
	JUMPN H,LOCFC1
	POPJ P,

;FIND FIRST BODY IN LOC
; G = -#,,ROW
; E = -#,,column-within-page (add MCOL)
;Return pointer to Body in H
LOCFND:	PUSHJ P,MAPRCU
	 POPJ P,
	HRRZM T,PINLOC		;LOC TO FIND
	JUMPE W,CPOPJ
	SETZM BESLOC		;Best body found in this location
	SETZM BESPIN		;DIP size for that body
	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST LOCFNA

LOCFN1:	FETCH(A,H,BLOC)		;LOC
	PUSHJ P,MAPOST		;Strip away any socket offset
	 SETZ A,
	HRRZS A
	CAME A,PINLOC		;IS THIS IT?
	 JRST LOCFNA		;NO
	FETCH(TT,H,BBIT)
	TRNE TT,CBODY		;YES, IS THIS CONN THO?
	 JRST LOCFNA
	FETCH(TT,H,BPAK)	;How many pins on package?
	HRRZ TT,PACKPN(TT)
	CAMG TT,BESPIN		;Only find the biggest package in this slot
	 JRST LOCFNA
	MOVEM TT,BESPIN
	MOVEM H,BESLOC
LOCFNA:	FETCH(H,H,NXTB)
	JUMPN H,LOCFN1
	SKIPE H,BESLOC		;Any body found?
	 AOS (P)
	POPJ P,
	
SPACING:ASCIZ/   /		;3 SPACES FOR NOW

UMLBRS:	PUSHJ P,PNTBRW
	PUTSTR[ASCIZ/

/]
	POPJ P,

PRINT4:	JUMPE A,CPOPJ
	MOVEI T,4
	JRST PRINTN

PRINT8:	JUMPE A,CPOPJ
	MOVEI T,8
	JRST PRINTN

PRINT5:	JUMPE A,CPOPJ
	SKIPA T,[5]
PRINT7:	MOVEI T,7
PRINTN:	ADD A,[POINT 7,1]
PRINTQ:	TLNE A,760000
	JRST PRINTZ
	HRR A,-1(A)
	TRNN A,-1
	POPJ P,
PRINTZ:	ILDB TTT,A
	JUMPE TTT,CPOPJ
	XCT PUTCHR
	SOJG T,PRINTQ
	POPJ P,
SUBTTL	'TST'		BINARY WIRE LIST TO SIMULATOR
;THIS OUTPUT IS COURRENTLY INTENDED FOR RUBIN'S SIMULATOR

TSTWRT:	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	MOVSI T,'TST'		;CARD TESTER FILE EXTENSION
	MOVEI TT,10		;FULL WORDS
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET		;SETUP OUTPUT STUFF
	POPJ P,			;LET HIM OUT HERE
	MOVEI A,RADDR(W,WBDY,NXTB)
	JRST TSTB1

TSTB2:	FETCH(T,A,DIPT)		;DIP TYPE
	JUMPE T,[PUSH P,A
		FETCH(T,A,BBIT)
		TRNE T,CBODY
		JRST ISCON
		SKIPN ADDR(A,BNAM)
		OUTSTR[ASCIZ/UNNAMED BODY/]
		OUTSTR ADDR(A,BNAM)
		OUTSTR[ASCIZ/ HAS NO DIP TYPE!
/]
	ISCON:	POP P,A
		JRST TSTB1]
	FETCH(T,T,DNAM)		;DIP NAME
	PUSHJ P,WSTR
	MOVE TTT,A
	PUSHJ P,WORDOUT
	FETCH(TTT,A,BLOC)
	PUSHJ P,WORDOUT
TSTB1:	FETCH(A,A,NXTB)
	JUMPN A,TSTB2
	PUSHJ P,WRTZERO		;TERMINATE NAMES
	MOVEI A,RADDR(W,WIRES,ALPH)
	JRST TSTP1

TSTP2:	FETCH(B,A,WBIT)
	TRNE B,NAM2ND
	JRST TSTP1		;ONLY REAL WIRES
	SETZ C,
	TRNE B,SPWR
	AOSA C			;CODE = 3
	TRNE B,SHI
	AOSA C			;CODE = 2
	TRNE B,SGND
	AOJA C,TSTTX4		;CODE = 1
;	TRNE B,WSINGL		;DON'T SEND NON-SPECIAL SINGLE PIN RUNS
;	JRST TSTP1
TSTTX4:	MOVE B,A		;START WITH THIS ONE
TSTTX0:	BINSIG ADDR(B,SPNT)	;PUT OUT SIGNAL NAME
	FETCH(B,B,NNAM)		;NEXT NAME BLOCK
	JUMPN B,TSTTX0
	MOVE TTT,C
	PUSHJ P,WORDOUT		;SEND CODE FOR STRING
	FETCH(B,A,WPIN)		;GET FIRST PIN
	JUMPE B,TSTPZ		;ANY PINS AT ALL?
TSTP3:	FETCH(TT,B,PBIT)
	TRNE TT,DUP
	JRST TSTP5
	FETCH(TTT,B,PINN)	;PIN #
	FETCH(T,B,PBDY)
	FETCH(TT,T,BBIT)
	TRNE TT,CBODY
	JRST [	FETCH(T,T,BLOC)
		MOVE TT,TTT
		PUSHJ P,CPNMER
		MOVE TTT,T
		JRST TSTP4]
	HRL TTT,T			;USE BODY CORE LOC AS UNIQUE #
TSTP4:	PUSHJ P,WORDOUT
TSTP5:	FETCH(B,B,NXTP)
	JUMPN B,TSTP3
TSTPZ:	PUSHJ P,WRTZERO
TSTP1:	FETCH(A,A,ALPH)
	JUMPN A,TSTP2
	PUSHJ P,WRTZERO
	RELEASE LST,
	POPJ P,

WASCIZ:	MOVE TTT,(T)
	PUSHJ P,WORDOUT
	TRNE TTT,376
	AOJA T,WASCIZ
	POPJ P,

WSTR1:	MOVE TTT,1(T)
	PUSHJ P,WORDOUT
	TRNN TTT,376		;END?
	POPJ P,			;YES
	HRRZ T,(T)
WSTR:	JUMPN T,WSTR1
WRTZERO:TDZA TTT,TTT
WRTMARK:MOVEI TTT,400000
WORDOUT:SOSG LSTHD+2
	OUT LST,
	CAIA
	OUTSTR[ASCIZ/OUTPUT ERROR!
/]
	IDPB TTT,LSTHD+1
	POPJ P,
SUBTTL	'TP8'		OUTPUT TO TAPR-8 WIRE WRAP SYSTEM
DEC,<
TP8WRT:	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	MOVSI T,'TP8'		;TAPR-8 EXTENSION
	MOVEI TT,0		;TEXT FILE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET		;SETUP OUTPUT STUFF
	POPJ P,			;LET HIM OUT HERE
	SETZM CDSKPC
	SETZM NDIPS
	SETZM NBODS
	MOVEI H,RADDR(W,WIRES,ALPH)
	JRST TP8R1

TP8R2:	FETCH(T,H,WBIT)
	TRNE T,NAM2ND!WNULL!WSINGL!SNC
	JRST TP8R1
	MOVEI G,RADDR(H,WPIN,NXTP)
	TRZ FLAG		;FLAG NO PINS OUT YET
	SETZ F,			;HOLDS FIRST PIN
	JRST TP8R3

TP8R4:	FETCH(T,G,PBIT)
	TRNE T,DUP
	JRST TP8R3		;SKIP DUPLICATES
	FETCH(B,G,PBDY)
	FETCH(T,B,BLOC)
	JUMPE T,[AOS NBODS
		JRST TP8R3]
	FETCH(T,B,BBIT)
	TRNE T,CBODY
	JRST TP8R5
	FETCH(T,B,DIPT)
	JUMPE T,[AOS NDIPS	;COUNT PIN WITHOUT DIPTYPE
		JRST TP8R5]
	FETCH(T,T,DPNN)
	CAIE T,=14
	CAIN T,=16
	JRST TP8R5
	CAIE T,=24
	AOS CDSKPC
TP8R5:	JUMPE F,[MOVE F,G
		JRST TP8R3]
	TROE FLAG
	JRST TP8R6
	PUTSTR ADDR(H,SPNT)
	CRLF
	EXCH F,G
	PUSHJ P,TP8PIN
	EXCH F,G
TP8R6:	PUSHJ P,TP8PIN
TP8R3:	FETCH(G,G,NXTP)
	JUMPN G,TP8R4
	TRNE FLAG		;ANY PINS PUT OUT?
	CRLF
TP8R1:	FETCH(H,H,ALPH)
	JUMPN H,TP8R2
	CRLF
	RELEASE LST,
	SKIPN T,NDIPS
	JRST TP8E1
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ PINS OUTPUT WITH NO DIP TYPE.
/]
TP8E1:	SKIPN T,NBODS
	JRST TP8E2
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ PINS SKIPPED DUE TO NO BODY LOC.
/]
TP8E2:	SKIPN T,CDSKPC
	POPJ P,
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ PINS OUTPUT WHICH WEREN'T 14, 16, OR 24 PIN DIPS.
/]
	POPJ P,

TP8PIN:	FETCH(A,G,PINN)
	FETCH(B,G,PBDY)
	FETCH(T,B,BLOC)
	HRL A,T
	FETCH(TT,B,BBIT)
	FETCH(T,B,DIPT)
	SKIPE T
	FETCH(T,T,DPNN)
	PUSHJ P,TP8LOC
	CRLF
	POPJ P,
>;DEC
SUBTTL	'SMP'		BACK PANEL OUTPUT TO DEC SYSTEM
;DEC WIRE LIST OUTPUT

;SELECT MODE
SSIMPLE:TRZ DOGIN!DOPWR!CONLY	;ASSUME ALL OFF
	SETZM OFFSET		;IN CASE NO OFFSET
	ASK [ASCIZ /INVENT NAMES FOR "U" PINS?/]
	 POPJ P,
	 CAIA
	TRO DOGIN
	ASK [ASCIZ /OUTPUT POWER PINS?/]
	 POPJ P,
	 JRST SSIMP1
	TRO DOPWR
	ASK [ASCIZ /OUTPUT ONLY POWER PINS?/]
	 POPJ P,
	 JRST SSIMP1
	TRO CONLY
SSIMP1:	ASK [ASCIZ /OFFSET SLOTS?/]
	 POPJ P,
	 JRST OSIMP1
	CAIA
OSIMPLE:TRZ DOGIN!DOPWR!CONLY
	OUTSTR[ASCIZ/TYPE OFFSET FOR SLOTS (N OR -N)? /]
	MOVE TTT,[PUSHJ P,TTYIN]
	MOVEM TTT,GETCHR
	PUSHJ P,SDECIN
	JFCL
	CAIE TTT,12
	JRST ERRET
	MOVEM A,OFFSET		;SAVE OFFSET
	JRST OSIMP1

BSIMPLE:TRZ DOGIN!CONLY
	TRO DOPWR
	JRST BSIMP1

PSIMPLE:TRO DOPWR!CONLY
	TRZ DOGIN
	JRST BSIMP1

ASIMPLE:TROA DOGIN
WIRWRT:	TRZ DOGIN
	TRZ DOPWR!CONLY
BSIMP1:	SETZM OFFSET		;NO OFFSET NORMALLY
OSIMP1:	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE L,DEFLST
	FETCH(W,L,BLST)
	JUMPE W,XBAK		;ANY BACK PANEL STUFF?
	MOVSI T,'SMP'		;IT'S SIMPLE!
	MOVEI TT,0		;MODE 0
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	SKIPN ISWW
	JRST SMPVG5
	MOVEI H,RADDR(W,WBDY,NXTB)	;GO DOWN BODY LIST (CARDS)
	JRST SMPVG1

SMPVG2:	FETCH(G,H,BLOC)			;GET CARD LOC
	MOVEM G,SLICEL			;SAVE CARD HERE FOR PRINT OUT
	MOVN G,NPADS
	MOVS G,G
	HRRI G,1			;START WITH PADDLE 1
SMPVG3:	MOVE F,PADLET
SMPVG4:	MOVE E,PADPIN
SMPVG6:	MOVEI T,(G)
	MOVEI TT,(F)
	MOVEI TTT,(E)
	PUSHJ P,MAPPAD
	MOVE A,T
	PUSHJ P,SMPVG			;SIDE 2 ALSO
	AOBJN E,SMPVG6
	AOBJN F,SMPVG4
	AOBJN G,SMPVG3
SMPVG1:	FETCH(H,H,NXTB)
	JUMPN H,SMPVG2
SMPVG5:	MOVEI B,RADDR(W,WBDY,NXTB)	;GO DOWN BODY LIST
	SETZM FACTR1			;CLEAR COUNT OF NX PINS SKIPPED
	SETZM FACTR2			;****** TEMPRORARY FIX ******* CLEAR COUNT OF POWER PINS SKIPPED
	SETOM CDSKPC
	JRST WIRW1

WIRW2:	AOS T,CDSKPC
	CAILE T,7
	JRST [	OUTSTR[ASCIZ/
/]
		SETZM CDSKPC
		JRST WIRPN1]
	SKIPE CDSKPC
	OUTCHR[11]
WIRPN1:	FETCH(A,B,BLOC)
	PUSH P,PUTCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUSHJ P,SLTOUT
	POP P,PUTCHR
	SETZM GINPIN			;START INVENTED PINS OVER
	MOVEI D,RADDR(B,BPIN,NXBP)	;NOW DO EACH PIN OF SLOT
	PUSH P,B
	JRST WIRW3

WIRW4:	FETCH(E,D,PINN)		;PADDLE PIN SIDE
	FETCH(B,D,HPNT)
	FETCH(F,B,WBIT)
	FETCH(TTT,D,PBIT)
	TRNE TTT,DUP
	JRST WIRW3
	TRNN F,SPWR		;IS IT A POWER PIN
	JRST CKCNLY
	TRNN DOPWR		;DON'T SEND POWER PINS UNLESS SPECIAL MODE
	JRST SKPVLT
	JRST SNDPIN

CKCNLY:	TRNE CONLY
	JRST WIRW3		;SKIP REGULAR PINS FOR PSIMPLE
SNDPIN:	FETCH(TTT,D,PBDY)
	FETCH(TTT,TTT,BBIT)
	TRNE TTT,BWILD		;SKIP "U" PINS
	JRST CHKGIN
GOTGIN:	SETZM LOUTL
	SETZM LOUTH
	TRNE F,SGND		;AVOID SETTING LOADING FOR GROUND
	JRST PIKSMP		;PICK GROUND SIGNAL NAME TO PRINT
	FETCH(TTT,D,CBIT)
	JUMPE TTT,NOLOAD	;REAL ONE?
	FETCH(T,D,HOLD)
	MOVM T,T
	MOVNM T,LOUTH
	FETCH(T,D,LOLD)
	MOVM T,T
	MOVNM T,LOUTL
	FETCH(T,D,HILD)
	MOVM T,T
	ADDM T,LOUTH
	FETCH(T,D,LILD)
	MOVM T,T
	ADDM T,LOUTL
NOLOAD:	TRNE F,SHI		;HI RUN?
	JRST [	FETCH(T,B,TBIT)
		TRNE T,ECL
		JRST .+1
		FETCH(T,B,WRN)		;GET WIRE RULE NUMBER
		CAIE T,=19
		CAIN T,=20
		JRST .+1		;NO +3 IF ECL
		CAIN T,=21
		JRST .+1
		PUTSTR[ASCIZ/+3			  /]
		JRST WASHIR]
	TRNN F,SNC
	JRST PIKSMP
	PUTSTR[ASCIZ/NC /]
	FETCH(C,D,PBDY)
	FETCH(C,C,BLOC)
	MOVE A,E
	HRL A,C
	MOVE T,OFFSET
	PUSHJ P,BPNPIN	;MAKE NC RUN UNIQUE BY ADDING PIN NAME
	MOVEI A,=24
	PUSHJ P,FILL
	PUTSTR[ASCIZ/  /];NO ASSERTION POLARITY
	JRST WASHIR

PIKSMP:	PUSHJ P,SMPSIG		;WIRE HEAD IN B, PICK RIGHT SIGNAL
WASHIR:	PUTBYT " "
	FETCH(C,D,PBDY)
	FETCH(C,C,BLOC)
	MOVE A,E
	HRL A,C
	MOVE T,OFFSET
	PUSHJ P,BPNPIN
	MOVEI A,=40
	PUSHJ P,FILL
	FETCH(T,D,FILO)		;GET SOURCE FILE BLOCK POINTER
	SKIPN T			;USE IT IF THERE
	FETCH(T,D,FILP)
	FETCH(A,T,FPRF)		;GET PREFIX STRING
	PUSHJ P,PRINT4		;ONLY 4 CHARS ALLOWED
	MOVEI A,=48
	PUSHJ P,FILL
	FETCH(A,D,FILP)
	FETCH(A,A,FMOD)
	PUSHJ P,PRINT5		;MODULE NAME (ONLY 5 CHARS)
	FETCH(A,D,PBIT)
	ANDI A,QBITS
	JUMPE A,NOQBIT
	MOVE A,QN2L(A)
	JRST GOTQ

NOQBIT:	FETCH(T,D,CBIT)
	TRNE T,TERM
	JRST [	MOVEI A,"T"
		JRST GOTQ]
	TRNN T,OUTLD		;OUTPUTS?
	JRST NSMPO
	FETCH(A,B,TBIT)
	TRNE A,ECL
	JRST NOTSHI
	FETCH(A,B,WRN)
	CAIE A,=19
	CAIN A,=20
	JRST NOTSHI		;NOT +3 IF ECL
	CAIN A,=21
	JRST NOTSHI
	TRNE F,SHI
	SKIPA A,["+"]
NOTSHI:
NODEC,<	MOVEI A,"S"	>
DEC,<	MOVEI A,"O"	>
GOTQ:	PUTBYT " "
	PUTBYT @A
	CAIN A,"C"		;CABLE?
	TLOA TFLG		;YES
NSMPO:	TLZ TFLG		;NO
	MOVEI A,=56
	PUSHJ P,FILL
	MOVE T,LOUTH
	PUSHJ P,DECOUT
	PUTBYT ","
	MOVE T,LOUTL
	IDIVI T,=10		;DIFFERENT UNITS
	PUSHJ P,DECOUT
	FETCH(TT,B,TBIT)	;WIRE TYPE BITS
	SETZ TTT,		;ZERO WIRE RULE NUMBER
	FETCH(T,B,WBIT)
	TRNN T,SPWR!SGND!SHI!SNC;DON'T CHECK FOR CLK ON THESE RUNS
	TRNN TT,CLK		;CLOCK LINE?
	TLNE TFLG		;IS IT CABLE?
	MOVEI TTT,5		;YES, FORCE TWISTED PAIR
	TRNN TT,ECL		;ECL ON WIRE?
	JRST NSMPO1
	MOVEI TTT,=19		;WIRE RULE 19
	FETCH(TT,D,CBIT)	;GET BITS FOR THIS PIN
	TRNE TT,FFOUT		;UNLESS FF OUTPUT
	MOVEI TTT,=21		;THEN ITS 21
NSMPO1:	FETCH(T,B,WRN)
	IDIVI T,=100
	SKIPN TT		;IS THERE A NUMBER PART FROM DRAWING?
	MOVE TT,TTT		;NO, USE POSSIBLE GENERATED ONE
	FETCH(TTT,B,WBIT)	;GET WIRE TYPE BITS
	TRNE TTT,SNC		;IS IT AN NC (NO CONNECTION)
	TRO T,4			;YES, TURN ON WIRE TYPE 400 TO SIMPLE FILE
	IMULI T,=100
	ADD T,TT
	JUMPE T,NOWRN		;DON'T PRINT 0
	PUSH P,T
	PUTSTR[ASCIZ/ */]
	POP P,T
	PUSHJ P,DECOUT
NOWRN:	CRLF
WIRW3:	FETCH(D,D,NXBP)
	JUMPN D,WIRW4
	POP P,B
WIRW1:	FETCH(B,B,NXTB)		;DO EACH SLOT
	JUMPN B,WIRW2
	OUTSTR[ASCIZ/
/]
	RELEASE LST,
	SKIPN T,FACTR2
	JRST CKNX
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ POWER PINS SKIPPED.
/]
CKNX:	SKIPN T,FACTR1
	POPJ P,
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ WILD PINS SKIPPED.
/]
	POPJ P,

SKPNX:	AOS FACTR1
	JRST WIRW3

SKPVLT:	AOS FACTR2
	JRST WIRW3

CHKGIN:	SKIPL GINPIN			;DID WE RUN OUT OF NAMES?
	TRNN DOGIN			;NO, ARE WE INVENTING THEM?
	JRST SKPNX			;NO, SKIP PIN
NEWGIN:	MOVE A,GINPIN
	FETCH(T,D,PBDY)
	FETCH(T,T,BLOC)
	HRL A,T				;NEEDS CARD LOC FOR EXTENT
	PUSHJ P,CONGIN			;INVENT NEXT NAME
	JRST [	SETOM GINPIN
		OUTSTR[ASCIZ/
RAN OUT OF REAL PIN NAMES TO REPLACE "U" PIN NAMES.
/]
		JRST SKPNX]
	HRRZM A,GINPIN
	MOVE A,(P)			;GET POINTER TO CARD BODY HEADER
	FETCH(A,A,BPIN)			;START LOOKING AT PINS
NEWGN1:	FETCH(T,A,PINN)
	CAMN T,GINPIN			;THIS PIN IN USE ALREADY?
	JRST NEWGIN			;YES, INVENT ANOTHER
	FETCH(A,A,NXBP)			;LOOK AT NEXT
	CAMG T,GINPIN			;HAVE WE PASSED THIS PIN'S PLACE?
	JUMPN A,NEWGN1			;NO, KEEP LOOKING
NEWGN2:	MOVE E,GINPIN			;USE NEW NAME
	JRST GOTGIN

SMPSIG:	SETZ C,
	MOVE A,B
SMPSG1:	FETCH(T,A,WBIT)
	TRNN T,GLB2
	JRST SMPSG2
	JUMPE C,SMPSG3
	OUTSTR[ASCIZ/
MULTIPLE SIGNALS REQUESTED TO GO TO SIMPLE FILE:
/]
	OUTSIG ADDR(C,SPNT)
	OUTSTR[ASCIZ/
/]
	OUTSIG ADDR(A,SPNT)
	OUTSTR[ASCIZ/
/]
SMPSG3:	MOVE C,A
SMPSG2:	FETCH(A,A,NNAM)
	JUMPN A,SMPSG1
	SKIPN A,C
	MOVE A,B
	MOVEI T,ADDR(A,SPNT)
	MOVE TT,[=22,,=24]	;22 CHARS IN NAME, USING 24 COLUMNS
	TRNE F,SGND		;GROUND IS SPECIAL
	JRST GNDPUT
	JRST SMPPUT		;PLUS ASSERTION/POLARITY

DIG3:	SKIPGE T
	PUTBYT "-"
	MOVM T,T
	MOVEI TT,3
	MOVEM TT,NDIG
	JRST NDECOUT

SMPVG:	PUSH P,A
	PUSHJ P,PINBIT		;MAP IT
	TLNN TT,GND		;GROUND PIN?
	JRST SMPVGE		;NO
	PUTSTR[ASCIZ/			G  /]
	MOVE A,(P)
	PUSHJ P,MAKCPN		;CONVERT TO 18 BIT FORMAT
	HRL A,SLICEL
	MOVE T,OFFSET
	PUSHJ P,BPNPIN
	MOVEI A,=40
	PUSHJ P,FILL
	PUTSTR[ASCIZ/	 G	
/]
SMPVGE:	POP P,A
	POPJ P,
SUBTTL	'WDR'	'BAC'	WIRE LIST BACK TO PC PROG
;WRITE ROUTER WIRE LIST FILE FOR INPUT TO PC PROG
BAKOUT:	TROA ISBACK
PUTOUT:	TRZ ISBACK
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE L,DEFLST
	TRNE ISBACK
	JRST [	FETCH(W,L,WIRL)		;ALL LISTS FOR BACKOUT
		JUMPE W,[OUTSTR[ASCIZ/NO CARDS AT ALL!
/]
			POPJ P,]
		MOVSI T,'BAC'
		JRST SETWNM]
	PUSHJ P,LSTGET
	POPJ P,
	MOVSI T,'WDR'		;EXTENSION FOR ROUTER WIRE LIST
SETWNM:	MOVEI TT,10		;FULL WORDS
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET		;SETUP OUTPUT STUFF
	POPJ P,			;LET HIM OUT HERE
	TRNE ISBACK
	JRST BAKOU0
	MOVEI TTT,WDRVER	;FIRST IDENTIFY US
	PUSHJ P,WORDOUT
	PUSHJ P,WLOUT
	PUSHJ P,WRTZERO		;MARK END OF IT ALL
	PUSHJ P,WRTZERO		;ONE MORE FOR GOOD MEASURE
	RELEASE LST,
	POPJ P,

BAKOU0:	MOVEI TTT,BACVER
	PUSHJ P,WORDOUT
BAKFO1:	FETCH(TTT,W,FCRD)
	PUSHJ P,WORDOUT
	FETCH(T,W,FCRD)		;CARD LOC
	JUMPE T,[OUTSTR[ASCIZ/NONE/]
		JRST BAKOUZ]
	PUSHJ P,BRS1W
BAKOUZ:	MOVEI H,RADDR(W,FILS,FNXT)
	JRST BAKFO2
BAKFO3:	FETCH(TTT,H,FILN)
	PUSHJ P,WORDOUT
	FETCH(TTT,H,FEXT)
	HRLZ TTT,TTT
	PUSHJ P,WORDOUT
FOR I IN(FPPN,FDAT)
<	FETCH(TTT,H,I)
	PUSHJ P,WORDOUT
>
FOR I IN(FREV,FMOD,FVAR,FPRF,AUTHOR,TIT1,TIT2,FPROJ,FPAGE,FOF,FNXH)
<	FETCH(T,H,I)
	PUSHJ P,WSTR
>
	FETCH(T,H,FNOM)
	PUSHJ P,WSTR		;WRITE NOMENCLATURE TYPE
	FETCH(T,H,FWWT)
	PUSHJ P,WSTR		;WRITE BOARD TYPE
BAKFO2:	FETCH(H,H,FNXT)
	JUMPN H,BAKFO3
	PUSHJ P,WRTZERO		;END NAME BLOCKS
	PUSHJ P,WLOUT
	PUSHJ P,WRTZERO		;END OF RUNS
	PUSHJ P,DPRINT		;COUNT PARTS AND OUTPUT COUNTS
	SKIPN T,CDSKPC
	JRST ALLDOK
	OUTSTR[ASCIZ/, /]
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ BODIES WITH NO LOCS./]
ALLDOK:	OUTSTR[ASCIZ/
/]
	FETCH(W,W,NXTWL)
	JUMPN W,BAKFO1
	MOVSI TTT,400000
	PUSHJ P,WORDOUT
	RELEASE LST,
	POPJ P,

WLOUT:	MOVEI H,RADDR(W,WIRES,ALPH)
	JRST WLOUT1

WLOUT2:	FETCH(TT,H,WBIT)
	TRNE TT,NAM2ND
	JRST WLOUT1		;SKIP FAKE WIRES
	TRNN ISBACK
	JRST WLOUTB
	FETCH(TT,H,TBIT)
	TRNN TT,ANYCON		;GET TO BACK PANEL?
	JRST WLOUT1		;SKIP RUNS WHICH DON'T MAKE IT TO BACK PANEL
	TLO DOLC
	TLZ BAKGAT
	MOVE G,H
	SETZB A,CNTTAB
	MOVE T,[CNTTAB,,CNTTAB+1]
	BLT T,LODTAB+LODLEN-1
	PUSHJ P,GATHER		;ACCUMULATE LOADING
	PUSHJ P,LODMER		;CALC PROPER LOADING
	MOVE TTT,A		;WRITE WBIT, TBIT
	PUSHJ P,WORDOUT
	MOVE TTT,LINL
	HRL TTT,LINH
	PUSHJ P,WORDOUT		;INPUT LOADING
	MOVE TTT,LOUTL
	HRL TTT,LOUTH
	PUSHJ P,WORDOUT		;OUTPUT LOADING
	FETCH(G,H,WPIN)		;GET FIRST PIN
	JUMPE G,BACO1		;SKIP IF NO PINS
	FETCH(T,H,TBIT)		;TYPE BITS
	TRNN T,OUTLD		;ANY OUTPUTS?
	JRST BACO1		;NO
BACO3:	FETCH(T,G,PTYP)		;GET TYPE POINTER
	JUMPE T,BACO4
	FETCH(T,T,DPBIT)	;GET TYPE BITS
	TRNE T,OUTLD		;IS THIS AN OUTPUT
	JRST [	FETCH(TT,G,FILP) ;YES, OUTPUT SOURCE PRINT
		FETCH(TTT,TT,FILN)
		PUSHJ P,WORDOUT		;FILENAME
		FETCH(TTT,TT,FEXT)
		HRLZ TTT,TTT
		PUSHJ P,WORDOUT
		FETCH(TTT,TT,FPPN)
		PUSHJ P,WORDOUT		;PPN
		JRST BACO2]
BACO4:	FETCH(G,G,NXTP)
	JUMPN G,BACO3
BACO1:	PUSHJ P,WRTZERO		;NO OUTPUTS, OUTPUT 0
BACO2:	TLZ TFLG		;NO GLOBALS OUT YET
	MOVE G,H
	FETCH(T,H,WBIT)
	TRNE T,GENSIG		;IS THIS EDGE RUN UNNAMED (I.E. GENERATED NAME)
	JRST WLOUTZ		;YES, WRITE NO SIGNAL NAME SO IT
				;WILL BE REGENERATED LATER WITH CARD LOC IN IT
WLOUTG:	FETCH(T,G,WBIT)
	TRNN T,GLB1		;GLOBAL NAME?
	JRST WLOUTH
	TLO TFLG
	PUSHJ P,BACSTR
WLOUTH:	FETCH(G,G,NNAM)
	JUMPN G,WLOUTG
	TLNE TFLG
	JRST WLOUTZ			;GLOBALS OUT!
	JRST WLOUTC			;NO GLOBALS, OUT ALL.

WLOUTB:	FETCH(G,H,WPIN)
	JUMPE G,WLOUT1			;FLUSH NULL WIRES!
WLOUTC:	MOVE G,H
WLOUT3:	PUSHJ P,BACSTR
	FETCH(G,G,NNAM)
	JUMPN G,WLOUT3
WLOUTZ:	PUSHJ P,WRTZERO
	FETCH(G,H,WPIN)		;FIRST PIN
WLOUT5:	FETCH(A,G,PBDY)		;BODY POINTER
	FETCH(B,A,BLOC)		;BODY LOC
	FETCH(T,A,BBIT)
	TRNN ISBACK
	JRST WLOUTW
	TRNN T,CBODY
	JRST WLOUT6
	MOVE T,B
	FETCH(TT,G,PINN)
	PUSHJ P,CPNMER
	FETCH(TTT,G,PID)	;CPIN ID
	HRL TTT,T
	PUSHJ P,WORDOUT		;PPS,,CPID
	FETCH(TT,G,PBIT)
	LDB TTT,[POINT CXPOSL,TT,35-CXPOSB]
	LDB TT,[POINT CYPOSL,TT,35-CYPOSB]
	DPB TT,[POINT 9,TTT,35-9]
	ADDI TTT,1001
	PUSHJ P,WORDOUT
	FETCH(TT,G,FILP)
	FETCH(TTT,TT,FILN)
	PUSHJ P,WORDOUT		;FILENAME
	FETCH(TTT,TT,FEXT)
	HRLZ TTT,TTT
	PUSHJ P,WORDOUT
	FETCH(TTT,TT,FPPN)
	PUSHJ P,WORDOUT		;PPN
	JRST WLOUT6

WLOUTW:	TRNN T,CBODY		;CONNECTOR?
	JRST WLOUTV		;NO
	MOVE T,B
	FETCH(TT,G,PINN)
	PUSHJ P,CPNMER
	FETCH(TTT,W,FCRD)
	HRL TTT,T
	PUSHJ P,WORDOUT	;WRITE IT
	JRST WLOUT6

WLOUTV:	FETCH(TTT,A,BID)
	PUSHJ P,WORDOUT		;WRITE BODY ID
	FETCH(TTT,G,PINN)	;PIN #
NIL,<				;IS THIS REALLY RIGHT?? **BUG**
	PUSH P,A
	PUSH P,B
	FETCH(B,A,BPAK)		;MAP TO REAL PIN#
	FETCH(A,A,BLOC)
	HRL A,TTT		;PIN#,,LOC
	PUSHJ P,MAPOST
	 JFCL
	LDB TTT,[%%PINN,,A]
	POP P,B
	POP P,A
>;NIL
	FETCH(TT,G,PTYP)	;TYPE POINTER
WLOUTX:	JUMPE TT,.+3		;WAS THERE A TYPE POINTER?
	FETCH(TT,TT,DPBIT)	;TYPE BITS
	HRL TTT,TT
	PUSHJ P,WORDOUT		;WRITE IT
	MOVE TTT,B
	PUSHJ P,WORDOUT		;NLNLN
WLOUT6:	FETCH(G,G,NXTP)
	JUMPN G,WLOUT5
WLOUT4:	PUSHJ P,WRTZERO		;MARK END OF WIRE
WLOUT1:	FETCH(H,H,ALPH)		;FOLLOW LIST
	JUMPN H,WLOUT2
	POPJ P,

BACSTR:	FETCH(T,G,WBIT)
	TRNN T,GLB2		;NEED UP ARROW IN BAC FILE?
	JRST [	BINSIG ADDR(G,SPNT)	;NO
		POPJ P,]
	BINSGU ADDR(G,SPNT)
	POPJ P,
;OUTPUT PART COUNTS TO BAC FILE
DPRINT:	PUSHJ P,CLEARB
	SETZM CDSKPC
	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST DPRNT1

DPRNT2:	FETCH(T,H,BBIT)
	TRNN T,CBODY		;DON'T DO CONNECTORS
	TROE T,BTMP1
	JRST DPRNT1
	MOVEM H,NBODS
	STORE(T,H,BBIT)
	FETCH(T,H,DIPT)
	MOVEM T,LSTDIP
	TRZ FLAG		;FLAG DIPTYPE NOT OUT YET
DPRNT3:	MOVEM H,RBODS
	FETCH(T,H,PRTN)
	MOVEM T,LSTPART
	FETCH(T,H,PRPX)
	MOVEM T,LPRPX
	SETZM TMPCN1
	SETZM TMPCN2
	SETZM LSLOT
	TLZ TFLG		;FLAG NO 0 LOCS YET
DPRNT4:	PUSHJ P,ACOUNT
DPRNT7:	FETCH(H,H,NXTB)
	JUMPE H,DPRNT6
	FETCH(T,H,BBIT)
	TRNN T,CBODY
	TROE T,BTMP1
	JRST DPRNT7
	FETCH(TT,H,DIPT)
	CAME TT,LSTDIP
	JRST DPRNT7
	FETCH(TT,H,PRTN)
	CAME TT,LSTPART
	JRST DPRNT7
	FETCH(TT,H,PRPX)
	CAME TT,LPRPX
	JRST DPRNT7
	STORE(T,H,BBIT)
	JRST DPRNT4

DPRNT6:	PUSHJ P,ACNT7		;FIX SECTION COUNT TO APPROX DIP COUNT
	TROE FLAG
	JRST DPRNP1
	SKIPN T,LSTDIP
	JRST [	MOVEI T,[0
			ASCIZ\N/A\]
		JRST .+2]
	FETCH(T,T,DNAM)
	PUSHJ P,WSTR		;WRITE STRING
DPRNP1:	TLNN TFLG
	TDZA TTT,TTT
	MOVE TTT,TMPCN2
	PUSHJ P,WORDOUT
	MOVE TTT,TMPCN1
	PUSHJ P,WORDOUT
	SKIPN H,LSTPART
	JRST DPRNP3
;NOTE, HERE WE WRITE ACTUAL PART NUMBER SO ERROR WILL OCCUR IF CHANGED
DPRNP2:	FETCH(T,H,PRNB)
	FETCH(T,T,PRNS)
	PUSHJ P,WSTR
	FETCH(T,H,PRVS)
	PUSHJ P,WSTR
	FETCH(H,H,PRPP)
	JUMPN H,DPRNP2
DPRNP3:	SKIPN H,LPRPX
	JRST DPRNP5
DPRNP4:	FETCH(T,H,TLFT)
	PUSHJ P,WSTR
	FETCH(T,H,TRHT)
	PUSHJ P,WSTR
	FETCH(H,H,NXTT)
	JUMPN H,DPRNP4
DPRNP5:	PUSHJ P,WRTZERO
	MOVE H,RBODS
DPRNT8:	FETCH(H,H,NXTB)
	JUMPE H,DPRNT5
	FETCH(T,H,BBIT)
	TRNN T,CBODY
	TROE T,BTMP1
	JRST DPRNT8
	FETCH(TT,H,DIPT)
	CAME TT,LSTDIP
	JRST DPRNT8
	STORE(T,H,BBIT)
	JRST DPRNT3

DPRNT5:	MOVNI TTT,1
	TRNE FLAG
	PUSHJ P,WORDOUT		;MARK END OF DIPTYPE
	MOVE H,NBODS
DPRNT1:	FETCH(H,H,NXTB)
	JUMPN H,DPRNT2
	JRST WRTZERO

ACOUNT:	FETCH(T,H,BLOC)
	JUMPE T,[TLO TFLG	;FLAG NO LOC FOR SOME BODIES
		AOS CDSKPC	;AND COUNT EACH ONE
		JRST ACNT1]
	CAME T,LSLOT
	AOS TMPCN1		;COUNT EACH LOC ONCE
	MOVEM T,LSLOT
ACNT1:	SETZB F,FACTR1		;ACCUMULATE COUNT AND SECT BITS HERE
	MOVEI G,RADDR(H,BPIN,NXBP)
	JRST ACNT5

ACNT6:	FETCH(TT,G,PTYP)	;TYPE POINTER
	JUMPE TT,ACNT5
	FETCH(TTT,TT,DPBIT)	;BITS
	TRNN TTT,INLD!OUTLD!TERM	;ONLY INPUTS OR OUTPUTS
	JRST ACNT5
	FETCH(TT,TT,SCTB)	;SECTION BITS
	MOVS TT,TT		;TO LEFT HALF
	JFFO TT,.+2		;(1 SEC/DIP WORKS RIGHT)
	JRST ACNT5
	MOVE TTT,SCTTAB(TTT)	;GET THE BIT
	TDOE TTT,FACTR1		;TURN ON NEW BIT AND TEST
	JRST ACNT5		;ALREADY ON, DON'T COUNT AGAIN
	MOVEM TTT,FACTR1
	ADDI F,1		;INC COUNT
ACNT5:	FETCH(G,G,NXBP)
	JUMPN G,ACNT6
	ADDM F,TMPCN2
	POPJ P,

ACNT7:	SKIPE A,TMPCN2
	SKIPN H,LSTDIP
	POPJ P,
	PUSHJ P,SECCAL		;CALC SEC/DIP (RETURNS IN F)
	ADDI A,(F)
	IDIVI A,1(F)		;CALC DIPS
	MOVEM A,TMPCN2
	POPJ P,
SUBTTL	'WSS'	'WCS'	REFERENCE LISTINGS
SIGCOM:	TROA CONLY
DOREF:	TRZ CONLY
	TRZ ISBACK
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE L,DEFLST
	FETCH(E,L,WIRL)
	JUMPE E,[NCRDS:OUTSTR[ASCIZ/NO CARDS, YOU DUMMY!
/]
		POPJ P,]
	TRNE CONLY
	JRST [CRDS1:FETCH(T,E,NXTWL)
		JUMPE T,[OUTSTR[ASCIZ/HOW MANY INTERCONNECTIONS DO YOU EXPECT BETWEEN ONE CARD?
/]
			POPJ P,]
		MOVSI T,'WCS'	;CONNECTOR NEEDED LISTING
		JRST .+2]
	MOVSI T,'WSS'		;REFERENCE LISTING
	MOVEI TT,0		;DATA MODE 0
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	MOVEI T,WSSMAR
	MOVEM T,MARGIN
	SETZM REFLST
	HRROS REFLST
DOREF1:	FETCH(F,E,HASHTB)	;GENLAST
	FETCH(F,F,ALPH)		;FIRST REAL NAME (NOTE WE ASSUME FIRST NAME IN LIST HAS SIG1 ON)
	JUMPE F,DOREF0
	GETFS(G,TBLK)
	STORE(F,G,TRHT)		;STORE SIGNAL NAME BLOCK POINTER HERE
	FETCH(T,E,FCRD)		;CARD LOC
	STORE(T,G,TLFT)
	PUSHJ P,SORTIN
	JFCL
	JFCL
DOREF0:	FETCH(E,E,NXTWL)	;NEXT CARD
	JUMPN E,DOREF1		;SORT THEM ALL IN
DOREF2:	HRRZ H,REFLST		;FIRST NAME
	JUMPE H,DOREFE		;DONE?
	HLLZS REFLST		;CLEAR LIST
	TRNN CONLY		;ONLY SOME SIGNALS?
	JRST NCONLY
	MOVE G,H
	SETZ TT,		;CLEAR BIT HOLDERS
CSET1:	FETCH(T,G,TVAL)		;ORDER #
	JUMPN T,CSET3		;NO CONNECTIONS FOUND YET, I GIVE UP
	FETCH(TTT,G,TRHT)	;WIRE HEAD POINTER
	FETCH(T,TTT,WBIT)	;WIRE BITS
	TRNE T,NAM2ND
	FETCH(TTT,TTT,WPIN)
	FETCH(T,TTT,TBIT)
	TRNN T,ANYCON		;DOES IT GET TO BACK PANEL
	JRST [	TRNN T,OUTLD
		JRST [	TRNN T,INLD
			JRST CSET2	;NO IN, OUT, OR CONS
			TLNN TT,OUTLD	;ANY OUTPUTS ON OTHER CARDS?
			TRNE TT,OUTLD	;OR BACK PANEL
			JRST NCONLY	;YES, DO IT
			TLO TT,INLD	;INPUT ONLY ON CARD
			JRST CSET2]
		TLNE TT,INLD
		JRST NCONLY
		TLO TT,OUTLD		;HAVE OUTPUT ON CARD
		JRST CSET2]
	TRNN T,OUTLD
	JRST [	TRNE T,INLD
		TRO TT,INLD		;INPUT ON BACKPANEL
		JRST CSET2]
	TRO TT,OUTLD
	TLNE TT,INLD			;INPUT ON CARD?
	JRST NCONLY			;YES, PRINT
CSET2:	FETCH(G,G,NXTT)
	JUMPN G,CSET1
CSET3:	TRNE TT,INLD			;INPUT ON BACKPANEL?
	TRNE TT,OUTLD			;AND NO OUTPUT
	JRST CRFSKP			;NO
	TLNN TT,OUTLD			;AND OUTPUT ON CARD?
	JRST CRFSKP			;NO
NCONLY:	SKIPL LINCNT
	PUSHJ P,RHDR
	FETCH(A,H,TRHT)		;SIGNAL NAME BLOCK
	SETZM TCOUNT
	PUTSIG ADDR(A,SPNT)	;PRINT SIGNAL NAME
	MOVE G,H
	JRST DOREFW		;DO REST OF EQUIVALENTS FOR THIS WIRE, THEN REST OF CARDS

DOREFY:	FETCH(T,G,TVAL)		;ORDER #
	JUMPN T,DOREF3
	FETCH(A,G,TRHT)		;SIGNAL NAME BLOCK
DOREFZ:	PUTCOM ADDR(A,SPNT)	;PUT OUT COMMENT AT END OF NAME
DOREFW:	FETCH(A,A,NNAM)
	JUMPE A,DOREFX		;QUIT IF END THIS WIRE
	FETCH(T,A,WBIT)
	TRNN T,SIG1		;ALSO IF WE GET TO NEW FIRST NAME (CAN'T BE EQUIVALENT)
	JRST DOREFZ
DOREFX:	FETCH(G,G,NXTT)
	JUMPN G,DOREFY
DOREF3:	MOVE T,TCOUNT
	CAIL T,=16
	JRST [	CRLF
		PUTSTR[ASCIZ/		/]
		JRST WASSIG]
	PUTBYT 11
	CAIGE T,8
	PUTBYT 11
WASSIG:	FETCH(T,H,TLFT)			;BAY-RACK-SLOT
	HRLZM T,SLICEL
	SKIPE SLICEL
	PUSHJ P,PSLICL
	PUTBYT 11
	FETCH(G,H,TRHT)			;SIGNAL NAME BLOCK
	SETZM TCOUNT
	PUSHJ P,ONECRD			;PUT OUT LINE(S) FOR ONE CARD
	SETZM TCOUNT			;FLAG AT LEFT MARGIN
	PUSHJ P,REFRET
	JUMPE H,DOREF2			;ALL GONE, GO AGAIN
	FETCH(T,H,TVAL)
	JUMPE T,DOREF3
DOREF6:	MOVEI B,REFLST			;ALL 0'S GONE, RE-SORT THE REST
	HRRZ C,REFLST
DOREF5:	MOVE G,H
	FETCH(H,H,NXTT)
	PUSHJ P,MERGIN			;MERGE INTO LIST
	JRST CPYRST			;WENT AT END, COPY THE REST
	JRST MERNUM			;EQV, DO REST

CRFSKP:	PUSHJ P,REFRET
	JUMPE H,DOREF2
	FETCH(T,H,TVAL)
	JUMPE T,CRFSKP
	JRST DOREF6

DOREFE:	RELEASE LST,
	POPJ P,

ONECRD:	FETCH(E,G,WBIT)
	TRNE E,NAM2ND
	FETCH(G,G,WPIN)
	FETCH(E,G,TBIT)
	SETZB A,LODTAB
	MOVE T,[LODTAB,,LODTAB+1]
	BLT T,LODTAB+LODLEN-1
	TLO DOLC
	TLZ BAKGAT
	PUSH P,G
	PUSHJ P,GATHER
	PUSHJ P,LODMER			;CALC PROPER LOADING
	POP P,G
	MOVE T,LINL
	PUSHJ P,LDOUT
	PUTBYT 11
	MOVE T,LINH
	PUSHJ P,LDOUT
	PUTBYT 11
	SKIPN NOUT
	JRST [	TRNE E,GND
		JRST [	PUTSTR[ASCIZ/GND	/]
			JRST NTOUT]
		TRNN E,PWR
		JRST .+1
		SKIPLE T,PVOLTS
		PUTBYT "+"
		PUSHJ P,LDOUT
		PUTSTR[ASCIZ/	VOLTS/]
		JRST NTOUT]
	MOVE T,LOUTL
	PUSHJ P,LDOUT
	PUTBYT 11
	MOVE T,LOUTH
	PUSHJ P,LDOUT
NTOUT:	FETCH(G,G,WPIN)			;FIRST PIN
	JUMPE G,[PUTSTR[ASCIZ/	NO PINS/]
		JRST NTPINS]
	SETZ F,				;CLEAR FILE LIST
FSET1:	FETCH(D,G,PBDY)
	FETCH(D,D,BBIT)			;BODY BITS
	FETCH(T,G,FILP)			;FILE NAME POINTER
	MOVEI B,F+ADDR(0,NXTC)
	JRST FSET2

FSET3:	FETCH(TTT,B,CFIL)
	FETCH(TTT,TTT,FILN)
	CAMG TTT,ADDR(T,FILN)
	JRST [	CAME TTT,ADDR(T,FILN)
		JRST FSET4
		MOVE C,B
		JRST FSET5]
FSET2:	MOVE A,B
	FETCH(B,B,NXTC)
	JUMPN B,FSET3
FSET4:	GETFS(C,CBLK)
	BCLEAR(TT,C,CBLK)
	STORE(C,A,NXTC)
	STORE(B,C,NXTC)
	STORE(T,C,CFIL)
FSET5:	TRNN ISBACK			;BACK PANEL?
	JRST FSET7			;NO
	FETCH(TT,C,ICNT)
	ADDI TT,1			;COUNT A PIN
	STORE(TT,C,ICNT)
	JRST FSETE

FSET7:	TRNN D,CBODY			;CON?
	JRST FSET6
	FETCH(TT,C,CCNT)
	ADDI TT,1
	TRNN D,BWILD		;FRONT?
	TROA TT,400000		;YES
	TRO TT,200000		;NO
	STORE(TT,C,CCNT)
	JRST FSETE

FSET6:	FETCH(T,G,PTYP)
	JUMPE T,FSETE
	FETCH(T,T,DPBIT)
	TRNE T,OUTLD
	JRST [	FETCH(T,C,OCNT)
		ADDI T,1
		STORE(T,C,OCNT)
		JRST FSETE]
	TRNE T,TERM
	JRST [	FETCH(TT,C,ZCNT)
		ADDI TT,1
		STORE(TT,C,ZCNT)
		JRST FSETE]
	FETCH(T,C,ICNT)
	ADDI T,1
	STORE(T,C,ICNT)
FSETE:	FETCH(G,G,NXTP)			;NEXT PIN OF WIRE
	JUMPN G,FSET1
	SETOM FACTR1
	MOVE G,F
	TRNE ISBACK
	JRST NTABB
NTABA:	FETCH(T,G,OCNT)
	SKIPE T			;FIRST PRINT DRAWING NAMES WITH OUTPUTS
	PUSHJ P,NTAB
	FETCH(G,G,NXTC)
	JUMPN G,NTABA
NTABB:	MOVE G,F
NTABC:	FETCH(T,G,OCNT)
	TRNN ISBACK		;THIS IS ONLY LOOP FOR BACK PANEL
	SKIPN T			;FOR CARDS NOW WE DO ONES WITHOUT OUTPUTS
	PUSHJ P,NTAB
	MOVE A,G
	FETCH(G,G,NXTC)
	FSTRET(A,CBLK)
	JUMPN G,NTABC
NTPINS:	CRLF
	POPJ P,

NTAB:	AOS T,FACTR1
	CAIGE T,4
	JRST NTAB1
	SETZM FACTR1
	CRLF
	PUTSTR[ASCIZ/						/]
NTAB1:	PUTBYT 11
	FETCH(A,G,CFIL)
	SETZM TCOUNT
	PUTSIX ADDR(A,FILN)
	TRNN ISBACK
	JRST NTAB2
	PUTBYT 11
	FETCH(T,G,ICNT)
	JRST DECOUT

NTAB2:	MOVE T,TCOUNT
	SUBI T,6
	PUTBYT " "
	AOJLE T,.-1
	FETCH(T,G,ICNT)
	PUSHJ P,DECOUT
	PUTBYT ","
	FETCH(T,G,OCNT)
	PUSHJ P,DECOUT
	FETCH(T,G,ZCNT)
	JUMPE T,NOZPNT
	PUTBYT "Z"
	CAIE T,1
	PUSHJ P,DECOUT
NOZPNT:	FETCH(T,G,CCNT)
	TRZE T,200000			;WILD?
	JRST [	TRZE T,400000
		JRST [	PUTBYT BWAROW
			CAILE T,2
			JRST DECOUT
			POPJ P,]
		PUTBYT WLDCHR
		JRST ISBCON]
	TRZN T,400000			;FRONT?
	POPJ P,
	PUTBYT "_"
ISBCON:	CAIE T,1			;DON'T PRINT IN THIS CASE
	JRST DECOUT
	POPJ P,

REFRET:	MOVE G,H
	FETCH(H,H,NXTT)
	FETCH(T,G,TRHT)			;SIGNAL BLOCK POINTER
REFRT1:	FETCH(T,T,ALPH)
	JUMPE T,[FSTRET(G,TBLK)		;END OF LIST, GIVE BACK BLOCK
		POPJ P,]
	FETCH(TT,T,WBIT)
	TRNN TT,SIG1			;FIRST EQUIVALENT SIGNAL?
	JRST REFRT1			;NO, TRY ANOTHER
	STORE(T,G,TRHT)
	PUSHJ P,SORTIN			;SORT NEXT STRING INTO NEW LIST
	JFCL
	POPJ P,
;		SORT SUBRS
MERNM1:	FETCH(T,H,TVAL)
	CAME T,FACTR1			;STILL SAME OLD ORDER #?
	JRST DOREF5
	MOVE T,FACTR2
	STORE(T,H,TVAL)
	MOVE G,H
	FETCH(H,H,NXTT)
	FETCH(TTT,G,TLFT)
MERNM2:	JUMPE C,MERNM3
	FETCH(T,C,TVAL)			;ORDER #
	CAME T,FACTR2			;ONE OF THIS GROUP?
	JRST MERNM3			;NO
	FETCH(T,C,TLFT)
	CAML T,TTT
	JRST MERNM3
	MOVE B,C
	FETCH(C,C,NXTT)
	JUMPN C,MERNM2
MERNM3:	STORE(C,G,NXTT)
	STORE(G,B,NXTT)
	MOVE B,G
MERNUM:	JUMPN H,MERNM1
	JRST DOREF2

CPYRST:	STORE(H,G,NXTT)			;LINK REST ONTO END
	JUMPE H,DOREF2
DOREF7:	FETCH(T,H,TVAL)			;NOW SET NEW ORDER #'S
	CAMN T,FACTR1
	JRST DOREF8
	MOVEM T,FACTR1
	AOSA T,FACTR2
DOREF8:	MOVE T,FACTR2
	STORE(T,H,TVAL)
	FETCH(H,H,NXTT)
	JUMPN H,DOREF7
	JRST DOREF2

MERGIN:	FETCH(T,G,TVAL)
	MOVEM T,FACTR1
	JRST SORTN2

SORTIN:	MOVEI C,REFLST
	FETCH(T,G,TVAL)
	MOVEM T,FACTR1
SORTN1:	MOVE B,C
	FETCH(C,C,NXTT)
SORTN2:	JUMPE C,PUTHER
	FETCH(TT,C,TRHT)
	MOVEI TT,ADDR(TT,SCMP)
	FETCH(T,G,TRHT)
	MOVEI T,ADDR(T,SCMP)
	PUSHJ P,ALPHA
	JRST PUTHER
	JRST SORTN1			;NOT THERE YET
	JFCL				;EQUIVALENT
	JFCL				;EQUIVALENT
	FETCH(T,C,TVAL)			;EQUAL
	MOVEM T,FACTR2
	STORE(T,G,TVAL)
	FETCH(TTT,G,TLFT)
	JRST SORTN9

SORTN3:	MOVE B,C
	FETCH(C,C,NXTT)
SORTN9:	JUMPE C,SORTN8
	FETCH(TT,C,TVAL)
	CAME TT,T
	JRST SORTN8
	FETCH(TT,C,TLFT)
	CAMGE TT,TTT
	JRST SORTN3
	STORE(G,B,NXTT)
	STORE(C,G,NXTT)
	MOVE B,G
	JRST CPOPJ1

SORTN8:	STORE(G,B,NXTT)
	STORE(C,G,NXTT)
	MOVE B,G
	SKIPN C				;IF THIS IS 0
	POPJ P,				;THEN WE ARE AT REAL END
	JRST CPOPJ1

PUTHER:	FETCH(T,B,TVAL)
	ADDI T,1
	MOVEM T,FACTR2
	STORE(T,G,TVAL)
	STORE(G,B,NXTT)
	STORE(C,G,NXTT)
	MOVE B,G
	JUMPE C,CPOPJ			;AT END
	MOVE A,C
SORTN5:	FETCH(T,A,TVAL)
	ADDI T,1
	STORE(T,A,TVAL)
	FETCH(A,A,NXTT)
	JUMPN A,SORTN5
	JRST CPOPJ1

RHDR:	TLZN NOFF
	PUTSTR[BYTE(7)15,14]
	MOVN TTT,PAGLEN
	ADD TTT,MARGIN
	MOVEM TTT,LINCNT
	TRNE CONLY
	JRST RHDR3
	PUTSTR[ASCIZ/REF LISTING/]
	JRST RHDR2

RHDR3:	PUTSTR[ASCIZ/CONNECTORS NEEDED/]
RHDR2:	FETCH(A,L,WLNM)
	JUMPE A,RHDR1
	PUTSTR[ASCIZ/ FOR /]
	PUSHJ P,STROUT			;PRINT WIRE LIST NAME
RHDR1:	PUSHJ P,PNTFDT
	PUTSTR[ASCIZ/
SIGNAL NAME
		CARD	LOW IN	HI IN	LOW OUT	HI OUT	FILNAM	#I,#O Z# C#

/]
	POPJ P,
SUBTTL	'WLC'		COMPARE 2 WIRE LISTS
WDECO:	TRZ PCNOTD
	OUTSTR[ASCIZ/ID OF "OLD" WIRELIST?/]
	PUSHJ P,FNDID
	POPJ P,
	JRST NOID
	HRLZM L,GOODW
	OUTSTR[ASCIZ/ID OF "NEW" WIRELIST?/]
	PUSHJ P,FNDID
	POPJ P,
	JRST NOID
	HRLZM L,BADW
	MOVE L,BADW
	CAME L,GOODW
	JRST WDECOA
	OUTSTR [ASCIZ /SORRY, CAN'T COMPARE A WIRELIST TO ITSELF.
/]
	POPJ P,

WIRCOM:	TRO PCNOTD
	MOVE L,DEFLST
	HRLZM L,GOODW
	HRLZM L,BADW
WDECOA:	HLRZ L,GOODW
	FETCH(W,L,WIRL)
	PUSHJ P,LSTGT0
	POPJ P,
	HRRM W,GOODW
	HLRZ L,BADW
	FETCH(W,L,WIRL)
	TRNE PCNOTD
	FETCH(W,L,PCWL)
	JUMPE W,NXCRD1
	HRLM W,(P)
	PUSHJ P,GETLOP		;TRY TO FIND SAME CARD IN OTHER WIRELIST
	CAIA
	JRST WDECOK
	OUTSTR[ASCIZ/SAME CARD NOT FOUND IN /]
	TRNE PCNOTD
	OUTSTR[ASCIZ/PC/]
	FETCH(A,L,WLID)
	TRNN PCNOTD
	JRST [	OUTCHR [42]
		PUSHJ P,STRTTY
		OUTCHR[42]
		JRST .+1]
	OUTSTR[ASCIZ/ WIRELIST.
/]
	HLRZ W,(P)
	PUSHJ P,LSTGT0
	JRST NXCRD1
WDECOK:	HRRM W,BADW
	TRNN PCNOTD
	JRST [	MOVSI T,'WDC'
		JRST WDECO1]
	PUSHJ P,FIXDIP		;TRY TO COPY DIP TYPES ACROSS
	MOVSI T,'WLC'		;ERROR LISTING FOR WIRE LIST COMPARISON
WDECO1:	MOVEI TT,0		;DATA MODE 0
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	TRNN PCNOTD		;FOR PC CARDS
	JRST WDECO2
	HRRZ W,GOODW
	PUSHJ P,FILLST		;PUT OUT DRAWING FILE HEADER
	 CHDR
	PUSHJ P,DOWLD		;PUT A WLD IN THE FRONT OF THIS FILE
	JRST WDECO3

WDECO2:	HRRZ W,GOODW		;FOR D, PUT OUT BOTH FILE HEADERS
	PUSHJ P,FILLST
	 CHDRO
	HRRZ W,BADW
	PUSHJ P,FILLST
	 CHDRN
WDECO3:	HRRZ W,GOODW
	PUSHJ P,CLEARW
	HRRZ W,BADW
	PUSHJ P,CLEARW
	TRNN PCNOTD
	SKIPA T,[[ASCIZ/	RUNS WITH CHANGES
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS	ADD	DELETE/]]
	MOVEI T,[ASCIZ/	WIRES WITH SHORTS OR OPENS
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS	SHORT	OPEN/]
	MOVEM T,HEADER
	SETZM LINCNT
	MOVEI T,WCIMAR
	MOVEM T,MARGIN
	HRRZ W,GOODW
	MOVEI W,RADDR(W,WIRES,ALPH);WIRES
	JRST WIRCM2

WIRCM3:	FETCH(T,W,WBIT)
	TRNE T,NAM2ND!WNULL	;WNULL WILL BE HONEST IF NAM2ND IS OFF
	JRST WIRCM2		;SKIP FAKE WIRES
	SETZM MSINGL		;CLEAR 1 PIN RUN MATCH
	FETCH(T,W,TBIT)
	FETCH(H,W,WPIN)
	TRNN T,OUTLD		;ANY OUTPUTS
	JRST CONFN0
OUTFN2:	FETCH(T,H,PBIT)
	TRNE T,DUP
	JRST OUTFN1
	FETCH(T,H,PTYP)
	JUMPE T,OUTFN1
	FETCH(T,T,DPBIT)
	TRNE T,OUTLD		;OUTPUT PIN?
	PUSHJ P,PINFNH		;TRY TO FIND IN BADW
	JRST OUTFN1		;LOSE
	JRST ISLINK		;THIS IS IT

OUTFN1:	FETCH(H,H,NXTP)
	JUMPN H,OUTFN2
	FETCH(H,W,WPIN)
	FETCH(T,W,TBIT)
CONFN0:	TRNN T,ANYCON
	JRST INFN0
FNCON2:	FETCH(T,H,PBIT)
	TRNE T,DUP
	JRST FNCON1
	FETCH(T,H,PBDY)
	FETCH(T,T,BBIT)
	TRNN T,BWILD
	TRNN T,CBODY
	JRST FNCON1
	PUSHJ P,PINFNH
	JRST FNCON1
	JRST ISLINK

FNCON1:	FETCH(H,H,NXTP)
	JUMPN H,FNCON2
	FETCH(H,W,WPIN)
	FETCH(T,W,TBIT)
INFN0:	TRNN T,INLD
	JRST UNFN2
INFN2:	FETCH(T,H,PBIT)
	TRNE T,DUP
	JRST INFN1
	FETCH(T,H,PTYP)
	JUMPE T,INFN1
	FETCH(T,T,DPBIT)
	TRNE T,INLD
	PUSHJ P,PINFNH
	JRST INFN1
	JRST ISLINK

INFN1:	FETCH(H,H,NXTP)
	JUMPN H,INFN2
	FETCH(H,W,WPIN)
UNFN2:	FETCH(T,H,PBIT)
	TRNE T,DUP
	JRST UNFN1
	PUSHJ P,PINFNH
	JRST UNFN1
	JRST ISLINK

UNFN1:	FETCH(H,H,NXTP)
	JUMPN H,UNFN2
	TRNE PCNOTD		;IF COMPARING PC TO DRW,
	JRST WIRCM2		;THEN ONLY SEE WIRES
	SKIPE MSINGL		;DID WE FIND SINGLE PIN MATCH?
	JRST ISLNKS		;YES, GO USE IT
WIRCM2:	FETCH(W,W,ALPH)
	JUMPN W,WIRCM3
	HRRZ W,GOODW
	MOVEI G,RADDR(W,WIRES,ALPH)
	TRNN PCNOTD
	SKIPA T,[[ASCIZ/	DELETED RUNS
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS/]]
	MOVEI T,[ASCIZ/	MISSING WIRES
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS/]
	MOVEM T,HEADER
	SETZM LINCNT
	MOVEI T,WCWMAR
	MOVEM T,MARGIN
	JRST WIRCM6

WIRCM4:	FETCH(F,G,WBIT)
	TRNE F,NAM2ND!WNULL!WSINGL
	JRST WIRCM6		;ALWAYS SKIP FAKE HEADERS, NULLS, AND SINGLES
	TROE F,WTMP1		;RUN COMPARED YET?
	JRST WIRCM6		;YES
	STORE(F,G,WBIT)		;STORE WITH BIT SET
	PUSHJ P,CCHK
	PUTSIG ADDR(G,SPNT)
	FETCH(E,G,WPIN)
WIRCM8:	PUSHJ P,PINPNT
	CRLF
	FETCH(E,E,NXTP)
	JUMPN E,WIRCM8
WIRCM6:	FETCH(G,G,ALPH)
	JUMPN G,WIRCM4
	HRRZ W,BADW
	MOVEI G,RADDR(W,WIRES,ALPH)
	TRNN PCNOTD
	SKIPA T,[[ASCIZ/	ADDED RUNS
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS/]]
	MOVEI T,[ASCIZ/	EXTRA WIRES
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS/]
	MOVEM T,HEADER
	SETZM LINCNT
	MOVEI T,WCWMAR
	MOVEM T,MARGIN
	JRST WIRCN6

WIRX2:	TLO TFLG		;NAME NOT OUT YET
	PUSHJ P,ISLNKX
	JRST WIRCN6

WIRCN4:	FETCH(A,G,WBIT)
	TRNE A,NAM2ND!WNULL!WSINGL
	JRST WIRCN6		;ALWAYS SKIP FAKE HEADERS, NULLS, AND SINGLES
	TRNN PCNOTD
	JRST WIRCN7		;SKIP TESTS IF BOTH WD FILES
	TRNE A,SPWR!SGND
	JRST WIRX2			;IS GND OR PWR
WIRCN7:	TROE A,WTMP1		;MATCHED ALREADY?
	JRST WIRCN6		;YES
	STORE(A,G,WBIT)
	pushj p,cchk
	PUTSIG ADDR(G,SPNT)
	FETCH(E,G,WPIN)
WIRCN8:	PUSHJ P,PINPNT
	CRLF
	FETCH(E,E,NXTP)
	JUMPN E,WIRCN8
WIRCN6:	FETCH(G,G,ALPH)
	JUMPN G,WIRCN4
	HRRZ W,GOODW
	MOVEI G,RADDR(W,WIRES,ALPH)
	TRNN PCNOTD
	SKIPA T,[[ASCIZ/	DELETED PINS
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS/]]
	MOVEI T,[ASCIZ/	LONESOME PINS FROM LOGIC DRAWING
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS/]
	MOVEM T,HEADER
	SETZM LINCNT
	MOVEI T,WCLMAR
	MOVEM T,MARGIN
	JRST WIRCO6

WIRCO4:	FETCH(F,G,WBIT)
	TRNE F,WSINGL
	TRNE F,NAM2ND!WNULL
	JRST WIRCO6		;SKIP FAKE WIRES AND NULLS AND NON SINGLES
	TROE F,WTMP1
	JRST WIRCO6		;DONE ALREADY
	STORE(F,G,WBIT)
	pushj p,cchk
	PUTSIG ADDR(G,SPNT)
	FETCH(E,G,WPIN)
	PUSHJ P,PINPNT
	CRLF
WIRCO6:	FETCH(G,G,ALPH)
	JUMPN G,WIRCO4
	TRNE PCNOTD
	JRST WDECON
	HRRZ W,BADW
	MOVEI G,RADDR(W,WIRES,ALPH)
	MOVEI T,[ASCIZ/	ADDED PINS
SIGNAL NAME
	LOC(PIN#) TYPE	USE	DIPTYPE	BODY	FILE	POS/]
	MOVEM T,HEADER
	SETZM LINCNT
	MOVEI T,WCLMAR
	MOVEM T,MARGIN
	JRST WIRCP6

WIRCP4:	FETCH(F,G,WBIT)
	TRNE F,WSINGL
	TRNE F,NAM2ND!WNULL
	JRST WIRCP6		;SKIP FAKE WIRES AND NULLS AND NON SINGLES
	TROE F,WTMP1
	JRST WIRCP6		;DONE ALREADY
	STORE(F,G,WBIT)
	pushj p,cchk
	PUTSIG ADDR(G,SPNT)
	FETCH(E,G,WPIN)
	PUSHJ P,PINPNT
	CRLF
WIRCP6:	FETCH(G,G,ALPH)
	JUMPN G,WIRCP4
	JRST WDECOE

WDECON:	MOVEI T,[ASCIZ/PWR OR GND PINS NOT WIRED TO PWR OR GND ON PC CARD
LOC(PIN#) TYPE	USE	DIPTYPE		FILE		SIGNAL/]
	MOVEM T,HEADER
	SETZM LINCNT
	MOVEI T,WCLMAR
	MOVEM T,MARGIN
	HRRZ W,BADW
	MOVEI W,RADDR(W,WBDY,NXTB)
	JRST WIRVG1

WIRVG2:	FETCH(T,W,DIPT)
	JUMPE T,WIRVGA			;ANY DIP TYPE?
	MOVEI E,RADDR(W,BPIN,NXBP)
	JRST WIRVG3

WIRVG4:	FETCH(A,E,PTYP)
	JUMPE A,WIRVG3
	FETCH(TT,A,DPBIT)
	TRNE TT,PWR!GND
	JRST WIRVGC
WIRVG3:	FETCH(E,E,NXBP)
	JUMPN E,WIRVG4
	JRST WIRVG1

WIRVGE:	PUSHJ P,PINVG
	JRST WIRVG3

PINVG:	PUSHJ P,CCHK
	PUSHJ P,PINVGP
PINVGC:	PUTBYT 11
	FETCH(A,E,HPNT)
	PUTSIG ADDR(A,SPNT)
	CRLF
	POPJ P,

WIRVGC:	FETCH(T,E,HPNT)
	FETCH(T,T,WBIT)
	TRNN T,SPWR!SGND
	JRST WIRVGE
	TRNN TT,PWR
	JRST WIRVGD
	TRNN T,SPWR
	JRST WIRVGE
	JRST WIRVG3

WIRVGD:	TRNN T,SGND
	JRST WIRVGE
	JRST WIRVG3

WIRVGA:
	SKIPN ISWW
	JRST WIRVG1
	FETCH(T,W,BBIT)
	TRNN T,BWILD
	TRNN T,CBODY
	JRST WIRVG1			;NO
	FETCH(F,W,BLOC)
	TLO F,MAPCON
	MOVEI E,RADDR(W,BPIN,NXBP)
	JRST WIRVGX

WIRVGY:	MOVE A,F
	FETCH(TT,E,PINN)
	HRLI A,MAPCON(TT)
	PUSHJ P,PINBIT
	TLNN TT,PWR!GND
	 JRST WIRVGX
	FETCH(T,E,HPNT)
	FETCH(T,T,WBIT)
	TRNN T,SPWR
	 JRST WIRVGW
	TLNE TT,PWR
	 JRST WIRVGX
	JRST WIRVGZ

WIRVGW:	TRNE T,SGND
	TLNE TT,GND
	 JRST WIRVGX
WIRVGZ:	HLLM TT,(P)
	PUSHJ P,CCHK
	PUSHJ P,PINPNF
	HLRZ TT,(P)
	TRNE TT,PWR
	PUTBYT PWRCHR
	TRNE TT,GND
	PUTBYT GNDCHR
	PUSHJ P,WASCON
	PUSHJ P,PINVGC
WIRVGX:	FETCH(E,E,NXBP)
	JUMPN E,WIRVGY
WIRVG1:	FETCH(W,W,NXTB)
	JUMPN W,WIRVG2
WDECOE:	RELEASE LST,
	POPJ P,

ISLNKS:	HLRZ H,MSINGL		;GET PIN WE MATCHED
	HRRZ F,MSINGL		;GET ITS MATCH
	FETCH(G,F,HPNT)		;GET ITS WIRE HEADER
ISLINK:	FETCH(T,W,WBIT)
	TRO T,WTMP1		;MARK RUN MATCHED
	STORE(T,W,WBIT)
	TRC T,WSINGL!GENSIG
	TRCE T,WSINGL!GENSIG	;BUT DON'T MARK NEW RUN IF OLD IS SINGLE GENSIG
	JRST ISLNK6
	FETCH(TT,G,WBIT)
	TRNN TT,WSINGL		;GO AHEAD WITH SINGLES
	JRST WIRCM2		;MULTIPLE PIN RUNS WILL MATCH OTHER RUNS, OR BE ADDS LATER
ISLNK6:	TLO TFLG		;NO SIGNAL NAME OUT YET
	MOVE A,W
	PUSHJ P,CLEARA		;CLEAR PRINT BITS
	MOVE A,G
	PUSHJ P,CLEARA		;ON BOTH WIRES
	MOVE TT,H
	PUSHJ P,PTSETA		;MARK AS MATCHED, BUT NOT PRINTED
	MOVE TT,F
	PUSHJ P,PTSETB		;MARK AS PRINTED AND MATCHED ALREADY
	TRNE PCNOTD
	JRST ISLNK0
	FETCH(T,W,WBIT)
	TRNE T,GENSIG
	JRST [	FETCH(T,G,WBIT)
		TRNN T,GENSIG
		JRST .+1
		JRST ISLNK0]	;DON'T COMPARE SIGNAL NAMES IF BOTH GENERATED
	MOVE H,W
	MOVE F,G
ECOSIG:	JUMPE H,[JUMPE F,ECOSG1
		JRST CKADD]
	JUMPE F,CKDEL
	MOVEI T,ADDR(H,SCMP)
	MOVEI TT,ADDR(F,SCMP)
	PUSHJ P,ALPHA
	JRST CKDEL
	JRST CKADD
	JRST CKDEL
	JRST CKADD
	FETCH(T,H,WBIT)
	TRO T,WTMP1
	STORE(T,H,WBIT)
	FETCH(H,H,NNAM)
	FETCH(T,F,WBIT)
	TRO T,WTMP1
	STORE(T,F,WBIT)
	FETCH(F,F,NNAM)
	JRST ECOSIG

CKADD:	FETCH(T,F,WBIT)
	TRZ T,WTMP1		;CLEAR BIT IN CASE WE HAVE BEEN THROUGH HERE BEFORE
	STORE(T,F,WBIT)
	FETCH(F,F,NNAM)
	JRST ECOSIG

CKDEL:	TLZN TFLG
	JRST CKDEL1
	pushj p,cchk
CKDEL1:	PUTSIG ADDR(H,SPNT)
	MOVEI A,=72
	PUSHJ P,FILL
	PUTSTR[ASCIZ/  D/]
	CRLF
	FETCH(T,H,WBIT)
	TRO T,WTMP1
	STORE(T,H,WBIT)
	FETCH(H,H,NNAM)
	JRST ECOSIG

ECOSG1:	MOVE F,G
ECOSG2:	FETCH(T,F,WBIT)
	TROE T,WTMP1
	JRST ECOSG3
	STORE(T,F,WBIT)
	TLZN TFLG
	JRST ECOSG4
	pushj p,cchk
ECOSG4:	PUTSIG ADDR(F,SPNT)
	MOVEI A,=64
	PUSHJ P,FILL
	PUTSTR[ASCIZ/ A/]
	CRLF
ECOSG3:	FETCH(F,F,NNAM)
	JUMPN F,ECOSG2
ISLNK0:	FETCH(T,W,WBIT)
	TRO T,WTMP1
	STORE(T,W,WBIT)
	FETCH(T,G,WBIT)
	TRO T,WTMP1
	STORE(T,G,WBIT)
	MOVEI H,RADDR(W,WPIN,NXTP)
	JRST ISLNK1

ISLNK2:	FETCH(T,H,PBIT)
	TRNE T,PTMP2		;MATCHED ALREADY?
	JRST ISLNK1
	PUSHJ P,PINFNG		;NO, FIND MATCH
	JRST MISING		;DELETED
	MOVE TT,H
	PUSHJ P,PTSETA		;MARK AS MATCHED, BUT NOT PRINTED
	MOVE TT,F
	PUSHJ P,PTSETB		;MARK AS MATCHED AND PRINTED
ISLNK1:	FETCH(H,H,NXTP)
	JUMPN H,ISLNK2
	PUSHJ P,ISLNKX		;NOW DO ADDED PINS
	TLNE TFLG		;ANYTHING PRINTED
	JRST WIRCM2		;NO
	MOVEI H,RADDR(W,WPIN,NXTP) ;YES, PRINTED MATCHED PINS ALSO
	JRST MDUMP1

MDUMP2:	FETCH(T,H,PBIT)
	TRNE T,PTMP1		;PRINTED YET?
	JRST MDUMP1		;YES
	MOVE E,H
	PUSH P,W
	HRRZ W,GOODW
	PUSHJ P,PINPNT
	CRLF
	POP P,W
MDUMP1:	FETCH(H,H,NXTP)
	JUMPN H,MDUMP2
	JRST WIRCM2

ISLNKX:	MOVEI F,RADDR(G,WPIN,NXTP)
	JRST ISLNK3

ISLNK4:	FETCH(T,F,PBIT)
	TRNE T,PTMP1		;PRINTED YET?
	JRST ISLNK3		;YES
	MOVE TT,F
	PUSHJ P,PTSET
	FETCH(A,G,WBIT)
	TRNN A,SPWR!SGND
	JRST ISNTPG
	FETCH(T,F,PBDY)
	FETCH(T,T,BBIT)
	TRNN T,CBODY		;CONNECTOR?
	JRST ISNTC		;NO
	SKIPN ISWW
	JRST ISNTPG
	TRNE T,BWILD		;ONLY REAL ONES
	JRST ISNTPG
	FETCH(TT,F,PINN)
	FETCH(T,F,PBDY)
	FETCH(T,T,BLOC)
	PUSHJ P,CPNMER
	MOVE A,T
	TLO A,MAPCON
	PUSHJ P,PINBIT
	JUMPE TT,ISNTPG
	MOVS TT,TT
	FETCH(A,G,WBIT)
	JRST VPCHK0

ISNTC:	FETCH(TT,F,PTYP)
	JUMPE TT,ISNTPG
	FETCH(TT,TT,DPBIT)
VPCHK0:	TRNN TT,PWR
	JRST ISNTP
	TRNN A,SPWR
	JRST ISNTPG
	JRST ISLNK3		;IS PWR ON PWR, SKIP IT

ISNTP:	TRNN TT,GND
	JRST ISNTPG
	TRNE A,SGND
	JRST ISLNK3
	JRST ISNTPG
ISNTPG:	TLZN TFLG		;SIGNAL NAME OUT YET?
	JRST ISLNK5		;YES
	pushj p,cchk
	PUTSIG ADDR(W,SPNT)
	TRNN PCNOTD
	JRST ISLNK5
	CRLF
	PUTSIG ADDR(G,SPNT)
ISLNK5:	MOVE E,F
	PUSH P,W
	HRRZ W,BADW
	PUSHJ P,PINPNT
	POP P,W
	MOVEI A,=64
	PUSHJ P,FILL
	TRNN PCNOTD
	PUTSTR[ASCIZ/ A/]
	TRNE PCNOTD
	PUTSTR[ASCIZ/ S/]
	CRLF
ISLNK3:	FETCH(F,F,NXTP)
	JUMPN F,ISLNK4
	POPJ P,

MISING:	MOVE TT,H
	PUSHJ P,PTSET
	TLZN TFLG		;NAME OUT YET?
	JRST MISNG1
	pushj p,cchk
	PUTSIG ADDR(W,SPNT)
	TRNN PCNOTD
	JRST MISNG1
	CRLF
	PUTSIG ADDR(G,SPNT)
MISNG1:	MOVE E,H
	PUSH P,W
	HRRZ W,GOODW
	PUSHJ P,PINPNT
	MOVEI A,=72
	PUSHJ P,FILL
	TRNN PCNOTD
	PUTSTR[ASCIZ/  D/]
	TRNE PCNOTD
	PUTSTR[ASCIZ/  O/]
	CRLF
	POP P,W
	JRST ISLNK1
;		SUBRS FOR WIRCOM
PTSETB:	PUSH P,[PTMP1!PTMP2]
	JRST PTSET0

PTSETA:	PUSH P,[PTMP2]
	JRST PTSET0

PTSET:	PUSH P,[PTMP1]
PTSET0:	FETCH(T,TT,PBIT)
PTSET1:	IOR T,(P)
	STORE(T,TT,PBIT)
	FETCH(TT,TT,NXTP)
	JUMPE TT,PTSET2
	FETCH(T,TT,PBIT)
	TRNE T,DUP
	JRST PTSET1
PTSET2:	POP P,(P)
	POPJ P,

CLEARP:	HLRZ A,1(W)
	MOVEI A,RADDR(W,WIRES,ALPH)
	JRST CLEAR1

CLEAR2:	PUSHJ P,CLEARA
CLEAR1:	FETCH(A,A,ALPH)
	JUMPN A,CLEAR2
	POPJ P,

CLEARA:	FETCH(B,A,WBIT)
	TRNE B,NAM2ND
	POPJ P,			;SKIP FAKE WIRES
	MOVEI B,RADDR(A,WPIN,NXTP)
	JRST CLEAR3

CLEAR4:	FETCH(T,B,PBIT)
	TRZ T,PTMP1!PTMP2
	STORE(T,B,PBIT)
CLEAR3:	FETCH(B,B,NXTP)
	JUMPN B,CLEAR4
	POPJ P,

;HERE TO PUT OUT HEADER FOR OLD FILE ONLY
CHDRO:	PUSHJ P,CHDR
	PUTSTR[ASCIZ/"OLD" WIRE LIST:

/]
	POPJ P,

;HERE TO PUT OUT HEADER FOR NEW FILE ONLY
CHDRN:	PUSHJ P,CHDR
	PUTSTR[ASCIZ/"NEW" WIRE LIST:

/]
	POPJ P,

CCHK:	SKIPGE LINCNT
	JRST [	CRLF
		POPJ P,]
CHDR:	TLZN NOFF
	PUTSTR[BYTE(7)15,14]
	PUSH P,A
	MOVN A,PAGLEN		;INIT COUNT TO TOP OF PAGE
	ADD A,MARGIN
	MOVEM A,LINCNT
	HLRZ A,GOODW
	FETCH(A,A,WLNM)
	JUMPE A,[HLRZ A,BADW
		FETCH(A,A,WLNM)
		JUMPE A,BTHBNK
		PUTSTR[ASCIZ/Unnamed wire list/]
		JRST .+2]
	PUSHJ P,STROUT
	PUTSTR[ASCIZ/  - vs -  /]
	HLRZ A,BADW
	FETCH(A,A,WLNM)
	JUMPE A,[PUTSTR[ASCIZ/Unnamed wire list/]
		JRST ONEBNK]
	PUSHJ P,STROUT
ONEBNK:	CRLF
BTHBNK:	HRRZ A,GOODW
	FETCH(A,A,FCRD)
	PUSHJ P,PNTBRS
	CRLF
	PUTSTR @HEADER
	PUTSTR[ASCIZ/

/]
	POP P,A
	POPJ P,

PINPNX:	FETCH(D,E,PBDY)
	JRST PINPNY

PINPNT:	MOVE T,LCOUNT
	CAIL T,8		;PUT ON SAME LINE IF ROOM
	CRLF
	PUTBYT 11
PINVGP:	PUSHJ P,PINPNF
WASCON:	PUTBYT 11
	JUMPE B,WASNCN
	FETCH(A,B,DUSE)
	PUTSIX A
WASNCN:	PUTBYT 11
	FETCH(T,D,DIPT)		;DIP POINTER
	SETZM TCOUNT
	JUMPE T,[FETCH(T,D,BBIT)
		TRNE T,CBODY
		PUTSTR[ASCIZ/CON/]
		JRST WNONM1]
	FETCH(A,T,DNAM)
	PUSHJ P,STROUT
WNONM1:	PUTBYT 11
	PUTSTR ADDR(D,BNAM)
	PUTBYT 11
	FETCH(A,E,FILP)
	PUTSIX ADDR(A,FILN)
	PUTBYT 11
	FETCH(A,D,BBIT)
	TRNN A,CBODY
	JRST BPPNT
	FETCH(A,E,PBIT)
	JRST CNPNT

PINPNF:	FETCH(D,E,PBDY)
	FETCH(A,D,BLOC)
	SETZM TCOUNT
	FETCH(T,E,PINN)
	HRL A,T
	FETCH(T,D,BBIT)
	TRNN T,CBODY
	JRST PNNC
	PUSHJ P,LOCPNW
	FETCH(T,E,PBIT)
	PUSHJ P,PTAB
	SETZ B,		;FLAG TO WASCON NOT TO PRINT USE
	POPJ P,

PNNC:	FETCH(B,D,BPAK)
	PUSHJ P,LOCPNP
	FETCH(T,E,PBIT)
	PUSHJ P,PTAB
PINPNY:	FETCH(B,E,PTYP)
	JUMPE B,[PUTSTR[ASCIZ/UN/]
		POPJ P,]
	FETCH(A,B,DPBIT)
	PUSHJ P,PNTYPE
	POPJ P,

;ENTER WITH LOGIC PIN TO FIND IN H
PINFNH:	FETCH(A,H,PBDY)		;BODY POINTER
	FETCH(A,A,BLOC)		;LOC OF BODY
	JUMPE A,CPOPJ		;CAN'T FIND IF NO LOC!!!!!!
	FETCH(B,H,PINN)		;PIN #
	HRRZ G,BADW
	MOVEI G,RADDR(G,WBDY,NXTB)
	JRST BDFNH1

BDFNH2:	FETCH(C,G,BLOC)		;LOC
	CAMN A,C		;SAME LOC?
	JRST BDFNH3
BDFNH1:	FETCH(G,G,NXTB)
	JUMPN G,BDFNH2
	POPJ P,			;LOSE

BDFNH3:	MOVEI F,RADDR(G,BPIN,NXBP)
	JRST PNFNH1

PNFNH2:	FETCH(T,F,PBIT)
	TRNE T,DUP
	JRST PNFNH1
	FETCH(T,F,PINN)
	CAME T,B		;PIN #
	JRST PNFNH1
	FETCH(C,F,HPNT)		;WIRE POINTER
	FETCH(T,C,WBIT)
	TRNE T,WTMP1		;DON'T FIND PREVIOUSLY MATCHED PINS
	JRST PNFNH1		;BUT KEEP TRYING
	TRNN T,WSINGL		;DON'T FIND SINGLES
	JRST [	MOVE G,C	;RETURN WIRE HEADER IN G
		JRST CPOPJ1]
	SKIPE MSINGL		;ALREADY GOT BEST SINGLE?
	JRST PNFNH1
	MOVEM F,MSINGL		;NO, SAVE THIS ONE
	HRLM H,MSINGL
;CONTINUE TO SEARCH FOR NON-SINGLE OR UNMATCHED PIN
PNFNH1:	FETCH(F,F,NXBP)
	JUMPN F,PNFNH2
	JRST BDFNH1

;ENTER WITH LOGIC PIN IN H, PC WIRE IN G
PINFNG:	MOVEI F,RADDR(G,WPIN,NXTP)
	FETCH(A,H,PBDY)
	FETCH(A,A,BLOC)		;LOC
	FETCH(B,H,PINN)		;PIN #
	JRST PINFN1

PINFN2:	FETCH(T,F,PINN)		;PIN #
	CAME T,B
	JRST PINFN1
	FETCH(T,F,PBDY)		;BODY POINTER
	FETCH(T,T,BLOC)		;LOC
	CAMN A,T
	JRST CPOPJ1
PINFN1:	FETCH(F,F,NXTP)
	JUMPN F,PINFN2
	POPJ P,
SUBTTL	'WLD'		DIP LOC CHECK
DIPCOM:	MOVE L,DEFLST
	HRLZM L,GOODW
	HRLZM L,BADW
	FETCH(W,L,WIRL)
	PUSHJ P,LSTGT0
	POPJ P,
	HRRM W,GOODW
	HLRZ L,BADW
	FETCH(W,L,PCWL)
	JUMPE W,NXCRD1
	PUSHJ P,GETLOP
	JRST NXCRD1
	HRRM W,BADW
	MOVSI T,'WLD'		;ERROR LISTING FOR WIRE LIST COMPARISON
	MOVEI TT,0		;DATA MODE 0
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	HRRZ W,GOODW
	PUSHJ P,FILLST
	 CHDR
	PUSHJ P,DOWLD
	RELEASE LST,
	POPJ P,


DOWLD:	PUSHJ P,CLEARB
	MOVEI T,[ASCIZ\DIP TYPE/SOCKET MIS-MATCHING
LOC	BODY	FILE	POS	DIPTYPE	PINS	PC PINS\]
	MOVEM T,HEADER
	MOVEI T,WLDMAR
	MOVEM T,MARGIN
	SETZM LINCNT
	HRRZ W,GOODW
	MOVEI H,RADDR(W,WBDY,NXTB)
	SETZM LETTER
	JRST DIPC1Z

DIPC2Z:	FETCH(TT,H,BBIT)
	FETCH(T,H,BLOC)
	TRNE TT,CBODY		;CON?
	 JRST DIPC1X		;YES, DO DIFFERENTLY
	JUMPE T,[MOVEM T,LETTER		;BLANK LOC
		SETZM PINNUM
		PUSHJ P,BDPNTA
		ERRSTR 0,[ASCIZ/NO LOCATION IN LOGIC DRAWING/]
		JRST DIPC1Z]
	CAMN T,LETTER		;NEW LOC?
	 JRST DIPC1Z		;NO, GET ANOTHER
	MOVEM T,LETTER
	MOVE C,BADW
	MOVEI C,RADDR(C,WBDY,NXTB)
	PUSHJ P,FN2BOD		;FIND THE LOC
	 JRST [	SETZM PINNUM
		PUSHJ P,BDPNTA
		ERRSTR 1,[ASCIZ/NO SUCH LOCATION ON PC CARD/]
		JRST DIPC1Z]
	FETCH(T,C,BBIT)
	TRO T,BTMP1
	STORE(T,C,BBIT)
	PUSHJ P,DIPMAX		;FIND MAX PIN # OF SOCKET
	FETCH(TTT,H,DIPT)	;DIPTYPE
	JUMPE TTT,[PUSHJ P,BDPNTA
		ERRSTR 0,[ASCIZ/NO DIP TYPE/]
		JRST DIPC1A]
	FETCH(TTT,TTT,DPNN)	;# OF PINS
	CAME TTT,PINNUM		;SAME # OF PINS?, NO ERROR
	 JRST [	HRLM TTT,PINNUM		;STORE # OF PINS FOR PRINTING
		PUSHJ P,BDPNT
		ERRSTR 2,[ASCIZ/WRONG NUMBER OF PINS FOR DIP/]
		JRST DIPC1A]
	HRLM C,(P)
	PUSHJ P,FN2BOD		;SEE IF THERE IS ANOTHER
	 JRST DIPC1Z		;NO, OK
	SKIPL LINCNT
	PUSHJ P,CHDR
	CRLF
	MOVE T,C
	HLRZ C,(P)
	HRLM T,(P)
	MOVE A,LETTER
	FETCH(T,C,BBIT)		;BODY BITS
	PUSHJ P,WLOCOUT
	PUSHJ P,DIPC1C		;REST OF LINE
	HLRZ C,(P)
	JRST DIPC1B

DIPC1A:	PUSHJ P,FN2BOD		;TRY TO FIND ANOTHER SUCH LOC
	 JRST DIPC1Z
DIPC1B:	PUSHJ P,DIPC1C
	JRST DIPC1A

DIPC1C:	PUTSTR[ASCIZ/				/]
	PUSHJ P,DIPMAX		;GET MAX PINS
	MOVE T,PINNUM
	PUSHJ P,DECOUT
	ERRSTR 3,[ASCIZ/MULTIPLE DIPS WITH SAME LOC/]
	POPJ P,

DIPC1X:	FETCH(TT,H,BBIT)
	TRNE TT,BWILD		;SKIP WILD CARD CPINS
	 JRST DIPC1Z
	MOVEM T,LETTER		;STORE LOC
	MOVE C,BADW
	MOVEI C,RADDR(C,WBDY,NXTB)
	PUSHJ P,FN2BOD		;FIND CON ON PC CARD
	 JRST DIPC1N		;NO SUCH PADDLE
	FETCH(F,C,BPIN)		;FIRST PIN ON PC CARD
	FETCH(G,H,BPIN)		;FIRST PIN
	TLZ TFLG		;NO LOC OUT YET
DIPC1Y:	FETCH(T,G,PINN)
DIPC2Y:	JUMPE F,DIPC1M		;IF NO MORE PC PINS, THEN ERROR
	FETCH(TT,F,PINN)	;PIN #
	CAMGE T,TT		;PAST RIGHT PLACE YET?
	 JRST DIPC1M		;YES, ERROR
	CAMN T,TT		;IS THIS IT?
	 JRST DIPC1W		;YES, NEXT
	FETCH(F,F,NXBP)
	JRST DIPC2Y		;NEXT PC PIN

DIPC1W:	FETCH(G,G,NXBP)
	JUMPN G,DIPC1Y
	JRST DIPC1Z

DIPC1M:	SKIPGE LINCNT
	 JRST DIPC0L
	PUSHJ P,CHDR
	TLZ TFLG		;NEED LOC AGAIN
DIPC0L:	TLOE TFLG		;LOC NEEDED?
	JRST DIPC1L		;NO
	MOVE A,LETTER
	FETCH(T,H,BBIT)
	PUSHJ P,WLOCOUT
DIPC1L:	PUSHJ P,CPINPN
	ERRSTR 2,[ASCIZ/NON EX PIN ON PADDLE/]
	JRST DIPC1W

CPINPN:	PUTSTR[ASCIZ/		/]		;NO BODY
	FETCH(A,G,FILP)
	PUTSIX ADDR(A,FILN)			;FILE NAME
	PUTSTR[ASCIZ/		CON	/]		;DIP TYPE
	HRRZ A,LETTER
	FETCH(T,G,PINN)
	PUSHJ P,PRCNPN
	PUTBYT 11
	SKIPN T,PINNUM
	POPJ P,
	JRST PRCNPN

DIPC1N:	TLZ TFLG
DIPC2N:	SKIPGE LINCNT
	JRST DIPC3N
	PUSHJ P,CHDR
	TLZ TFLG
DIPC3N:	TLOE TFLG
	JRST DIPC4N
	MOVE A,LETTER
	FETCH(T,H,BBIT)
	PUSHJ P,WLOCOUT
	FETCH(G,H,BPIN)
DIPC4N:	PUSHJ P,CPINPN
	ERRSTR 2,[ASCIZ/NO SUCH PADDLE ON PC CARD/]
	FETCH(G,G,NXBP)
	JUMPN G,DIPC2N
DIPC1Z:	FETCH(H,H,NXTB)
	JUMPN H,DIPC2Z
	MOVEI T,[ASCIZ/DIP SOCKETS NOT USED IN LOGIC DRAWING
LOC	PINS/]
	MOVEM T,HEADER
	SETZM LINCNT
	MOVE C,BADW
	MOVEI C,RADDR(C,WBDY,NXTB)		;NOW FIND THE SLACKERS
	JRST DIPC8

DIPC7:	FETCH(T,C,BBIT)
	TRNE T,BTMP1!CBODY
	JRST DIPC8		;ALREADY SEEN, OK
	SKIPL LINCNT
	PUSHJ P,CHDR
	FETCH(T,C,BBIT)
	FETCH(A,C,BLOC)
	PUSHJ P,WLOCOUT
	PUTBYT 11
	PUSHJ P,DIPMAX
	MOVE T,PINNUM
	PUSHJ P,DECOUT
	CRLF
DIPC8:	FETCH(C,C,NXTB)
	JUMPN C,DIPC7
	POPJ P,

DIPMAX:	SETZ TTT,		;MAX PC PIN SO FAR
	MOVEI A,RADDR(C,BPIN,NXBP)
	JRST DIPC2A

DIPC2B:	FETCH(TT,A,PINN)	;PIN #
	CAMLE TT,TTT
	MOVE TTT,TT
DIPC2A:	FETCH(A,A,NXBP)
	JUMPN A,DIPC2B
	MOVEM TTT,PINNUM
	POPJ P,

BDPNTA:	FETCH(T,H,DIPT)		;DIP POINTER
	SKIPE T			;ANY DIP TYPE?
	FETCH(T,T,DPNN)		;YES, GET NUMBER OF PINS
	HRLM T,PINNUM		;NUMBER OF PINS ON DIP
BDPNT:	SKIPL LINCNT
	PUSHJ P,CHDR
	CRLF
	MOVE A,LETTER
	FETCH(T,H,BBIT)
	PUSHJ P,WLOCOUT		;PRINT LOC
	PUTBYT 11
	SKIPN ADDR(H,BNAM)
	PUTSTR[ASCIZ/NONE/]
	PUTSTR ADDR(H,BNAM)
	PUTBYT 11
	FETCH(A,H,FILB)
	PUTSIX ADDR(A,FILN)
	PUTBYT 11
	FETCH(A,H,BBIT)
	PUSHJ P,BPPNT
	PUTBYT 11
	FETCH(A,H,DIPT)
	JUMPE A,[PUTSTR[ASCIZ/NONE/]
		JRST BDPNT2]
	FETCH(A,A,DNAM)
	PUSHJ P,STROUT
BDPNT2:	PUTBYT 11
	HLRZ T,PINNUM
	SKIPE T
	PUSHJ P,DECOUT
	PUTBYT 11
	HRRZ T,PINNUM
	JUMPE T,CPOPJ
	JRST DECOUT

CLEARB:	MOVEI TT,RADDR(W,WBDY,NXTB)
	JRST CLRB1

CLRB2:	FETCH(TTT,TT,BBIT)
	TRZ TTT,BTMP1
	STORE(TTT,TT,BBIT)
CLRB1:	FETCH(TT,TT,NXTB)
	JUMPN TT,CLRB2
	POPJ P,

CLEARW:	MOVEI T,RADDR(W,WIRES,ALPH)
	JRST CLRW1

CLRW2:	FETCH(TT,T,WBIT)
	TRZ TT,WTMP1
	STORE(TT,T,WBIT)
CLRW1:	FETCH(T,T,ALPH)
	JUMPN T,CLRW2
	POPJ P,
SUBTTL	'DAT'		PARTITION FILE OUTPUT
DOPART:	MOVE L,DEFLST
	PUSHJ P,LSTGET
	POPJ P,
	PUSHJ P,DIPCHK
	JRST [	OUTSTR[ASCIZ/SORRY, COULDN'T GET DIPS IN!
/]
		POPJ P,]
	PUSH P,LSTNAM		;SAVE DEFAULT NAME
	MOVE T,[DATNAM]
	MOVEM T,LSTNAM		;SET TO THIS FOR NOW
	MOVSI T,'DAT'		;PARTITION FILE EXTENSION
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	JRST [	POP P,LSTNAM
		POPJ P,]	;HE GAVE UP!
	POP P,LSTNAM
	ASK[ASCIZ/PASS PRE-PLACED DIP LOCATIONS?/]
	JRST PARTQT
	TRZA FLAG
	TRO FLAG
	PUSHJ P,PARDEF		;PUT OUT BODY DEFS IN FRONT OF FILE
	MOVEI T,3		;AVOID SPECIAL SIGS
	MOVEM T,FACTR1		;INIT SIGNAL # COUNTER
	MOVEI H,RADDR(W,WIRES,ALPH)
	JRST PART1

PART2:	FETCH(B,H,WBIT)
	TRNE B,NAM2ND!WNULL
	JRST PART1		;SKIP FAKE WIRES
	MOVEI T,2
	TRNE B,SPWR
	JRST PARTGS		;2 = CODE FOR PWR
	TRNN B,WSINGL		;SINGLE OR
	TRNE B,SNC		;NAME NC
	SOJA T,PARTGS		;1 = CODE FOR NC
	TRNE B,SGND
	AOJA T,PARTGS		;3 = CODE FOR GND
	AOS T,FACTR1		;NOT PWR OR GND, GENERATE A NEW NUMBER
PARTGS:	STORE(T,H,WTMP)		;STORE SEQ. # IN LH OF WIRE HEAD WORDS
PART1:	FETCH(H,H,ALPH)		;NEXT WIRE
	JUMPN H,PART2
	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST BPART1

BPART2:	FETCH(T,H,DIPT)		;DIP TYPE
	JUMPE T,BPART1		;LOSER
	FETCH(T,T,DTMP)		;GET DIP # (GENERATED BY PARDEF)
	JUMPE T,BPART1		;SKIP ONES WITH NO DIP #! (THEY WEREN'T 14 OR 16 PIN DIPS)
	FETCH(T,H,BPIN)
	JUMPE T,BPART1		;SKIP ONES WITH NO PINS!
	PUSHJ P,MAXSET		;CALC MAX SECT PIN #
	SETOM FACTR1		;SET LAST SEC #
	PUSHJ P,NXTSEC		;FIND FIRST
	JRST [	OUTSTR[ASCIZ/GROSS LOSSAGE AT BPART, NO SECTIONS FOUND FOR BODY /]
		OUTSTR ADDR(H,BNAM)
		OUTSTR[ASCIZ/
/]
		JRST BPART1]
BPART3:	MOVEM T,FACTR1		;MAKE IT THE ONE
	PUSHJ P,BHPNT		;PRINT BODY HEADER
	PUSHJ P,F4CRLF
	SETZ G,
	MOVEI F,G		;START HERE FOR ID LIST
	MOVE D,FACTR2		;THIS IS SETUP TO AOBJN POINTER
SPART0:	PUSHJ P,PNFND		;PIN FOR PIN# IN D AND SECT # IN FACTR1
	JRST [	PUSHJ P,PINID0	;PIN ID FOR NO PIN
		MOVEI T,1	;THIS SIGNAL #
		JRST SPART1]
	PUSHJ P,PHPNT		;PRINT SIGNAL # AND LINK ID INTO LIST
SPART1:	PUSHJ P,DEC5
	AOBJN D,SPART0		;DO THEM ALL
BPART4:	PUSHJ P,F4CRLF		;END OF SIGNAL #'S
	PUSHJ P,PIDPNT		;POOT OUT ID'S
	PUSHJ P,NXTSEC		;TRY FOR ANOTHER SECTION
	CAIA
	JRST BPART3		;GOT ANOTHER, LOOP BACK
BPART1:	FETCH(H,H,NXTB)		;ANOTHER BODY
	JUMPN H,BPART2
	PUTSTR[ASCIZ/           0/]	;END BODIES
	PUSHJ P,F4CRLF
	SKIPE ISWW
	PUSHJ P,WAGGND		;PUT OUT GND AND PWR FIRST
	SKIPN ISWW
	OUTSTR[ASCIZ/SINCE THIS IS NOT A WIRE WRAP BOARD
I CAN'T PASS PWR AND GND EDGE CONNECTIONS!
/]
	MOVEI H,RADDR(W,WBDY,NXTB)	;BACK TO BODY LIST
	JRST CPART1

CPART2:	FETCH(T,H,BBIT)			;LOC
	TRNN T,CBODY			;CONNECTOR?
	JRST CPART1			;NO, SKIP IT
	FETCH(T,H,BLOC)
	MOVEM T,FACTR1
	MOVEI G,RADDR(H,BPIN,NXBP)
	JRST CPART3

CPART4:	FETCH(T,G,PID)			;PIN ID
	PUSHJ P,OCT6			;PRINT IT
	FETCH(D,G,FILP)
	FETCH(D,D,FILN)
	HLRZ T,D
	PUSHJ P,OCT6			;LH FILENAME
	HRRZ T,D
	PUSHJ P,OCT6			;RH FILENAME
	FETCH(TT,G,PBDY)
	FETCH(TT,TT,BBIT)
	TRNE TT,BWILD
	TDZA TT,TT
	FETCH(TT,G,PINN)
	MOVE T,FACTR1
	PUSHJ P,CPARTP
	FETCH(T,G,HPNT)
	FETCH(T,T,WTMP)			;SIGNAL #
	PUSHJ P,DEC5
	PUSHJ P, F4CRLF			;THAT'S ALL
CPART3:	FETCH(G,G,NXBP)			;LOOP THROUGH PINS
	JUMPN G,CPART4
CPART1:	FETCH(H,H,NXTB)			;NEXT BODY
	JUMPN H,CPART2
	PUTSTR[ASCIZ/     0/]		;END OF CONNECTOR PINS
	PUSHJ P,F4CRLF
PARTQT:	RELEASE LST,			;FINI
	POPJ P,

PIDPNT:	JUMPE G,F4CRLF		;ANY LIST AT ALL?
PIDPN1:	MOVE F,G
	FETCH(T,F,TRHT)		;PIN ID
	PUSHJ P,OCT6		;PRINT IT
	FETCH(G,G,NXTT)
	FSTRET(F,TBLK)
	JUMPN G,PIDPN1
	JRST F4CRLF		;DO CRLF


PHPNT:	FETCH(T,A,PID)
	GETFS(TT,TBLK)
	STORE(T,TT,TRHT)
	CLEAR(TT,NXTT)
	STORE(TT,F,NXTT)
	MOVE F,TT		;NEW END
	FETCH(T,A,HPNT)
	FETCH(T,T,WTMP)
	POPJ P,			;RETURN SIGNAL # IN T

PINID0:	GETFS(TT,TBLK)		;STORE A 0 ID IN ID LIST
	CLEAR(TT,NXTT)
	CLEAR(TT,TRHT)
	STORE(TT,F,NXTT)
	MOVE F,TT
	POPJ P,

BHPNT:	FETCH(T,H,FILB)		;OH WELL, THIS IS UNIQUE FOR THE SLICE
	PUSHJ P,OCT6
	FETCH(T,H,BID)
	PUSHJ P,OCT6		;BODY ID
	FETCH(B,H,FILB)
	FETCH(B,B,FILN)
	HLRZ T,B
	PUSHJ P,OCT6		;LH FILENAME
	HRRZ T,B
	PUSHJ P,OCT6		;RH FILENAME
	FETCH(T,H,DIPT)
	FETCH(T,T,DTMP)
	PUSHJ P,DEC5		;DIP #
	TRNN FLAG		;PASSING LOCS?
	POPJ P,			;NO, QUIT
	FETCH(A,H,BLOC)
; This is really only right for DEC nomenclature.... **BUG**
	LDB T,[POINT 12,A,35]
	PUSHJ P,DEC5		;THIS IS X
	LDB T,[POINT 6,A,23]
	JRST DEC5		;THIS IS Y

NXTSEC:	MOVEI T,100		;PICK ULTRA GROSS SEC # (.GE. 18)
	FETCH(TT,H,BPIN)
NXTSC2:	HRLM TT,(P)
	FETCH(TTT,TT,PTYP)	;TYPE POINTER
	JUMPE TTT,NXTSC1	;UGH!
	FETCH(TT,TTT,DPBIT)
	TRNN TT,INLD!OUTLD!TERM
	JRST NXTSC1
	FETCH(TT,TTT,SCTB)
	MOVS TT,TT
	JFFO TT,.+2		;CALC SECT #
	JRST NXTSC1
	CAMLE T,TTT		;SMALLER THAN SMALLEST?
	CAMG TTT,FACTR1		;YES, LARGER THAN LAST?
	JRST NXTSC1		;NO
	MOVE T,TTT		;YES, SAVE IT
NXTSC1:	HLRZ TT,(P)
	FETCH(TT,TT,NXBP)
	JUMPN TT,NXTSC2
	CAIE T,100		;THIS TELLS US IF WE FOUND ANOTHER
	AOS (P)			;FOUND ANOTHER, SKIP
	POPJ P,

MAXSET:	FETCH(T,H,DIPT)		;DIP POINTER
	SETZM FACTR2		;MAX PIN #
	MOVEI T,RADDR(T,DPIN,DPNXT)
	JRST MAXPN2

MAXPN1:	FETCH(TT,T,DPBIT)
	TRNN TT,INLD!OUTLD!TERM
	JRST MAXPN2
	FETCH(TTT,T,SCTP)
	CAMLE TTT,FACTR2	;BIGGER THAN MAX SO FAR?
	MOVEM TTT,FACTR2	;YES, STORE
MAXPN2:	FETCH(T,T,DPNXT)
	JUMPN T,MAXPN1
	MOVN T,FACTR2
	HRLZM T,FACTR2
	AOS FACTR2		;THIS IS NOW A STARTING POINTER
	POPJ P,

PNFND:	MOVEI A,RADDR(H,BPIN,NXBP);START HERE
	JRST PNFND1

PNFND2:	FETCH(TT,A,PTYP)
	JUMPE TT,PNFND1		;ANY TYPE POINTER?
	FETCH(T,TT,DPBIT)
	TRNN T,INLD!OUTLD!TERM
	JRST PNFND1
	FETCH(T,TT,SCTP)
	CAIE T,(D)		;SAME SECT PIN #?
	JRST PNFND1		;NO
	FETCH(T,TT,SCTB)
	MOVS T,T
	JFFO T,.+1		;CALC SECT #
	CAMN TT,FACTR1		;SAME?
	JRST CPOPJ1		;YES, RETURN
PNFND1:	FETCH(A,A,NXBP)		;NO, LOOK FORWARD
	JUMPN A,PNFND2
	POPJ P,

OCT6:	MOVEI TTT,6
OCT6A:	IDIVI T,10
	HRLM TT,(P)
	SOJLE TTT,.+2
	PUSHJ P,OCT6A
	HLRZ TTT,(P)
	ADDI TTT,60
	XCT PUTCHR
	POPJ P,
;		PARTITION DIP DEFINITION OUTPUT
PARDEF:	SETZM FACTR1		;INITIALIZE DIP #'S
	PUSHJ P,DCLEAR
	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST DBPRT1

DBPRT2:	PUSH P,H
	MOVE A,H	;SAVE BODY POINTER FOR ERROR PRINTOUT
	FETCH(H,H,DIPT)
	JUMPE H,[FETCH(T,A,BBIT)
		TRNE T,CBODY	;CONNECTOR BODY?
		JRST .+2	;YES, PROCEED
		OUTSTR[ASCIZ/NO DIP TYPE FOR /]
		PUSHJ P,DEFLOS
		JRST .+2]
	PUSHJ P,DIPDEF
	POP P,H
DBPRT1:	FETCH(H,H,NXTB)
	JUMPN H,DBPRT2
NPARDP:	PUTSTR[ASCIZ/    0/]
	JRST F4CRLF

DEFLOS:	SKIPN ADDR(A,BNAM)
	JRST [	OUTSTR[ASCIZ/UNNAMED BODY/]
		JRST UNNDEF]
	OUTSTR ADDR(A,BNAM)
UNNDEF:	HRLM A,(P)
	FETCH(A,A,DIPT)
	JUMPE A,DEFLSD
	OUTSTR[ASCIZ/, DIP TYPE IS /]
	FETCH(A,A,DNAM)
	PUSHJ P,STRTTY
DEFLSD:	HLRZ A,(P)
	OUTSTR[ASCIZ/, YOU ARE LOSING!
/]
	POPJ P,


;POOT OUT 1 DIP DEF
DIPDEF:	FETCH(T,H,DPNN)		;# OF PINS
	CAIE T,=14
	CAIN T,=16
	CAIA
	JRST [	OUTSTR[ASCIZ/DIP TYPE NOT 14 OR 16 PINS FOR /]
		JRST DEFLOS]
	FETCH(T,H,DTMP)
	JUMPN T,CPOPJ		;ALREADY OUT!
	AOS T,FACTR1
	STORE(T,H,DTMP)
	PUSHJ P,SECCAL		;CALC DIP DIVISION
	FETCH(T,H,DTMP)
	PUSHJ P,DEC5		;THEN PRINT DIP #
	MOVE T,G		;PINS/UNIT
	PUSHJ P,DEC5
	MOVEI T,1(F)		;UNITS/PKG
	PUSHJ P,DEC5
	FETCH(T,H,DPNN)		;PINS/PKG
	PUSHJ P,DEC5
	MOVEI TTT,PWR
	PUSHJ P,PG5		;FIND AND PRINT PWR PIN
	MOVEI TTT,GND
	PUSHJ P,PG5		;FIND AND PRINT GND PIN
	FETCH(A,H,DNAM)
	PUSHJ P,STROUT		;PRINT DIP NAME
	PUSHJ P,F4CRLF
DPART7:	HRLZ G,G		;G HAS # OF PINS/SEC
	TLC G,-1
	AOBJN G,.+1		;NOW HAS -COUNT,,PIN #
	MOVNI F,1(F)		;INC BY 1 FOR COUNT
	HRLZ F,F		;NOW HAS -COUNT,,SEC #
DPRT7A:	MOVE E,G		;INIT E FROM G
	HRRZ D,F		;INTI RH OF D TO SEC #
DPRT7B:	HRL D,E			;SET LEFT HALF TO PIN #
	PUSHJ P,PPNT5		;FIND AND PRINT PIN
	AOBJN E,DPRT7B		;LOOP FOR ALL PINS
	AOBJN F,DPRT7A		;LOOP FOR ALL SECTIONS
	JRST F4CRLF		;END WITH A CRLF

;FIND A PWR OR GND PIN AND PRINT IT
PG5:	MOVEI T,1
	MOVEM TTT,1(P)
	MOVEI TT,RADDR(H,DPIN,DPNXT)
	JRST PG5B

PG5A:	FETCH(TTT,TT,DPBIT)
	TDNE TTT,1(P)
	JRST DEC5
	ADDI T,1
PG5B:	FETCH(TT,TT,DPNXT)
	JUMPN TT,PG5A
	SETZ T,
	OUTSTR[ASCIZ/PWR OR GND NOT FOUND ON DIP /]
	FETCH(A,H,DNAM)
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/, WILL PASS 0!
/]
DEC5:	MOVEI TT,5
	MOVEM TT,NDIG
	JRST NDECOUT

;ENTER WITH H=DIP DEF POINTER  D=PIN#,,SEC#
PPNT5:	MOVEI T,1
	MOVEI TT,RADDR(H,DPIN,DPNXT)
	JRST PPNT5B

PPNT5A:	FETCH(TTT,TT,DPBIT)
	TRNN TTT,INLD!OUTLD!TERM
	JRST PPNT5B
	FETCH(TTT,TT,SCTP)
	HRLZ TTT,TTT		;PICK UP PIN #
	XOR TTT,D
	TLNE TTT,-1		;SAME?
	JRST PPNT5B		;NO
	HRLM TT,(P)
	FETCH(TT,TT,SCTB)
	MOVS TT,TT
	JFFO TT,.+2
	JRST PPNT5B
	CAIN TTT,(D)		;SAME SEC #?
	JRST DEC5		;YES, PHY PIN # IN T, PRINT IT
	HLRZ TT,(P)		;RESTORE TT
PPNT5B:	ADDI T,1
	FETCH(TT,TT,DPNXT)
	JUMPN TT,PPNT5A
	OUTSTR[ASCIZ/PIN /]
	HLRZ T,D
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ OF SECTION /]
	HRRZ T,D
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ NOT FOUND ON DIP /]
	FETCH(A,H,DNAM)
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/, WILL PASS 0!
/]
	SETZ T,
	JRST DEC5

;SECCAL - CALL WITH DIP POINTER IN H, RETURN WITH PINS/SEC IN G, SEC/DIP IN F
SECCAL:	SETOB G,F		;START THEM OUT AS 0
	MOVEI TTT,RADDR(H,DPIN,DPNXT)
	JRST DPART0

DPART3:	FETCH(TT,TTT,DPBIT)
	TRNN TT,INLD!OUTLD!TERM	;INPUT OR OUTPUT PIN?
	JRST DPART0
	FETCH(T,TTT,SCTP)	;SECT PIN #
	CAMLE T,G		;LARGER?
	MOVE G,T		;NEW LARGEST
	FETCH(T,TTT,SCTB)
	MOVS T,T
	JFFO T,.+2
	JRST DPART0
	CAMLE TT,F		;LARGER SECT #?
	MOVE F,TT		;YES
DPART0:	FETCH(TTT,TTT,DPNXT)
	JUMPN TTT,DPART3
	POPJ P,

DCLEAR:	SKIPN H,DIPLST
	POPJ P,
DPART1:	CLEAR(H,DTMP)
	FETCH(H,H,NXTD)
	JUMPN H,DPART1
	POPJ P,
SUBTTL	OUTSET
;SETUP DEVICE AND NAME FOR OUTPUT
OUTSET:	SETZM ALLNAM
ALLSET:	MOVEM T,DEFEXT		;DEFAULT EXTENSION
	HRRM TT,OUTMOD		;SET DATA MODE
	MOVEM TTT,OUTDEV
NOITS,<
	JUMPN TT,OUTMOD		;FOR FULL WORD MODE NO OTHER DEVICE
	MOVSI TTT,'LST'
	DEVCHR TTT,
	JUMPE TTT,OUTMOD
	MOVSI TTT,'LST'
	MOVEM TTT,OUTDEV
>;NOITS
OUTMOD:	INIT LST,10
OUTDEV:	'DSK   '		;ALWAYS USE DISK!
	XWD LSTHD,0
	JRST [	OUTSTR[ASCIZ/INIT FAILED ON OUTPUT DEVICE!
/]
		JRST ERRET]
	SETZM LCOUNT		;START AT LEFT MARGIN
	SETZM LINCNT		;NEED HEADER
	TLO NOFF		;BUT ALREADY AT TOP!
	MOVEI T,LSTBUF
	EXCH T,.JBFF
	OUTBUF LST,2
	MOVEM T,.JBFF
	MOVE T,[PUSHJ P,BYTOUT]	;SETUP OUTPUT ROUTINE (EVEN FOR BINARY)
	MOVEM T,PUTCHR
	SETZM TTYFLG		;ASSUME NOT OUT TO TTY
	TLZ DEC,<COMLIN!>SIMTAB	;NOT SIMULATING TABS NORMALLY OR COMMENTING
	SETZM PNTNAM		;NO NAME TO PRINT YET
NOITS,<
	MOVE T,OUTDEV
	DEVCHR T,		;CHECK IF HE REASSIGNED THE DISK
	TLNE T,10		;TTY?
	SETOM TTYFLG		;YES
	TLNN T,4		;DOES IT STILL HAVE A DIRECTORY?
	JRST CPOPJ1		;NON-DIRECTORY DEVICE, QUIT NOW
>;NOITS
	SKIPN T,ALLNAM
	JRST NOALLF
	MOVEM T,FILNAM
	MOVE T,ALLPPN
	MOVEM T,FILPPN
	MOVE T,DEFEXT
	MOVEM T,FILEXT
	SETZM FILDAT
	PUSH P,A
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	MOVEI A,FILNAM
	PUSHJ P,FILPNT
	POP P,A
	JRST GOTALL

NOALLF:	PUSHJ P,SETFIL
	POPJ P,
GOTALL:	MOVE T,[PUSHJ P,BYTOUT]	;LOSING SETFIL CLOBBERED THIS
	MOVEM T,PUTCHR
	MOVE T,FILPPN
	LOOKUP LST,FILNAM
	SKIPA TT,FILEXT
	SETO TT,
	MOVEM T,FILPPN
	CLOSE LST,			;DON'T GET INTO ALTER MODE!!!
	TRNN TT,-1
	JRST NOEXST
IFN 0,<	ASK[ASCIZ/ ALREADY EXISTS, REPLACE?/]
	POPJ P,
	POPJ P,
;>	OUTSTR[ASCIZ/, BEING REPLACED/]
NOEXST:	HLLZS FILEXT
	SETZM FILDAT
	ENTER LST,FILNAM
	JRST [	OUTSTR[ASCIZ/ ENTER FAILED, CODE= /]
		HRRZ T,FILEXT
		PUSHJ P,TTYDEC
		OUTSTR[ASCIZ/
/]
		POPJ P,]
	OUTSTR[ASCIZ/
/]
	MOVE T,FILNAM
	MOVEM T,LSTNAM
	MOVEM T,PNTNAM
	MOVEM T,ALLNAM
	HLLZ T,FILEXT
	MOVEM T,PNTEXT
	SKIPN T,FILPPN
	DSKPPN T,
	MOVEM T,PNTPPN
	MOVEM T,ALLPPN
	JRST CPOPJ1
