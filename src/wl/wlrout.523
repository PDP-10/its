;<WIRELIST>WLROUT.FAI.16,  6-NOV-75 17:35:06, EDIT BY HELLIWELL -*- MODE:MIDAS -*-
SUBTTL	DEC ROUTER SUBRS
;ROUTER		PINSIN
;PINSIN - PINS READ IN
;READS IN THE PINS FOR ONE RUN AND COMPUTES THE DISTANCES
;BETWEEN EACH PAIR OF PINS.

ROUTE,<
PINSIN:	SETZM SCTR		;SET TO LOOK FOR SOURCE AND CABLE PINS
	SETZM HNDOSW		;CLEAR THE HAND ORDERING SWITCH
	SKIPLE	ORDFLG		;HAND ORDERING BY NUMBER?
	SETOM	HNDOSW		;YES, FLAG IT

PINSI2:	MOVEI B,1		;INDEX FOR MAKING DISTANCE TABLE
PINSI3:	SETZ C,			;COMPUTE DISTANCES TO PIN C(B)
				;FOR PINS 0 .LE. N .LE. C(B)-1
PINSI4:	MOVE A,B
	PUSH P,B
	PUSH P,C
	MOVSI T,RERPIN		;CHECK FOR PIN IN ERROR
	TDNN T,PNTBL(B)
	TDNE T,PNTBL(C)
	 JRST PINSIL		;Route pin at far end of run
	MOVE A,PNTBL1(B)
	MOVE C,PNTBL1(C)
	PUSHJ P,DSTCLC		;CALCULATE DISTANCE (IN WW FILE)
PINSIM:	POP P,C
	POP P,B
	PUSHJ P,MAKDST
	CAILE B,1(C)		;DONE THIS ROW?
	 AOJA C,PINSI4		;NO, GET NEXT DISTANCE
	MOVE C,NUMPIN
	CAILE C,(B)		;DONE THIS TABLE?
	 AOJA B,PINSI3		;NO, MAKE NEXT ROW LONGER
	POPJ P,

MAKDST:	MOVE E,C		;GET S/C COLUMNS FOR BOTH PINS
	LDB TTTT,ORDPTR		;SAVE THE ORDER CODE
	LDB TTT,SCPTR
	MOVE E,B
	LDB D,ORDPTR		;GET THE ORDER CODE FOR THE OTHER PIN
	SUB TTTT,D		;AND SAVE THE DIFFERENCE
	LDB D,SCPTR
	CAMN D,TTT		;LETTERS THE SAME?
	 JRST SCHECK		;YES, CHECK IF LEGAL
	ADD D,TTT		;NO, ADD IN FUDGE FACTOR
	ADD G,FUDGE(D)
PINSI5:	MOVMS TTTT		;GET MAGNITUDE OF ORDER CODE DELTA
	SKIPE NOHND
	 JRST PINSIG
	SKIPE HNDOSW		;HAND ORDERING?
	 HRL G,TTTT		;YES, USE HAND ORDER DELTA
PINSIG:	MOVEM G,@PTRTBL-1(B)	;DEPOSIT IN TRIANGULAR TABLE
	POPJ P,			;VIA PHANTOM DOUBLE INDEX

SCHECK:	CAIN D,4		;CHECK FOR MULTIPLE Sources'S
	 SETOM SCTR		;SET ERROR FLAG
	CAIN D,1		;CHECK FOR MULTIPLE Term'S
	 ADD G,[XWD 700,0]	;YES, ADD IN T-TO-T FUDGE FACTOR
	JRST PINSI5		;SAVE DISTANCE

FUDGE_.-1			;TABLE OF DISTANCE FUDGE FACTORS
				;SO THAT SELECTED PINS GO TO THE ENDS
	XWD 400,0		;T TO ORDINARY
	XWD 100,0		;C TO ORDINARY
	XWD 400,0		;C TO T
	XWD 100,0		;S TO ORDINARY
	XWD 400,0		;S TO T
	XWD 300,0		;S TO C

PINSIL:	MOVSI G,10000		;KLUDGE A LARGE DISTANCE ON ERROR
	JRST PINSIM
;		TOP LEVEL
ROUTER:	PUSHJ	P,PINSIN	;MAKE DISTANCE TABLE
IFN 0,<	MOVE	A,BAYNUM
	SKIPG	B,IBWLNK(A)	;CHECK FOR ANOTHER BAY TO BE ROUTED
	JRST	ROUTR1		;NONE, GO ROUTE THIS ONE
	PUSH	P,SCTR		;SAVE FLAGS
	PUSH	P,NUMPIN
	PUSH	P,BAYNUM
	PUSHJ	P,LINKER	;INITIALIZE THE OTHER BAY
	PUSHJ	P,PINSIN
	POP	P,BAYNUM
	POP	P,A		;MERGE THE 2 PIN COUNTS
	POP	P,B		;MERGE THE 2 SCTR FLAGS
	IORM	B,SCTR
	JUMPL	A,ROUTR1	;CHECK FOR FIRST BAY EMPTY
	SETCMM	A
	ADDM	A,RUNPTR	;RESTORE ORIGINAL RUN POINTER
	MOVNS	A
	ADDM	A,NUMPIN
	CAMLE	A,NUMPIN	;CHECK FOR SECOND BAY EMPTY
	JRST	ROUTR1
	MOVE	B,CBDELT	;ADJUST BOUNDRIES OF SECOND BAY
	ASH	B,-11
	ADDM	B,BNDRY1
	ADDM	B,BNDRY3
	ADD	A,RUNPTR	;COMPUTE CROSS-BAY DISTANCES
	MOVE	B,A

ROUTR2:	MOVE	C,RUNPTR
	HLRZ	T,PNTBL(B)	;GET COORD OF PIN IN SECOND BAY
	ADD	T,CBDELT	;ADJUST RELATIVE TO THE FIRST BAY

ROUTR3:	HLRZ	TT,PNTBL(C)	;GET COORD OF PIN IN FIRST BAY
	PUSHJ	P,CBDST		;GET WIRING DISTANCE
	PUSHJ	P,MAKDST	;ADJUST AND SAVE
	CAILE	A,1(C)
	AOJA	C,ROUTR3
	MOVE	C,NUMPIN
	ADD	C,RUNPTR
	CAMLE	C,B
	AOJA	B,ROUTR2
>;END IFN 0
ROUTR1:	SKIPG	A,NUMPIN	;DETECT 0 AND 1 PIN RUNS
	 POPJ P,		;JRST	RUNERR
	AOS (P)			;SKIP TO INDICATE WINNING RUN
	AOS	A
	SKIPL	ORDFLG		;HAND ORDERING BY ORDER PIN?
	JRST	PHS1		;NO,ENTER ROUTING ALGORITHMS.
;		BY ORDER PIN
;	THE FOLLOWING ROUTINE ORDERS THE RUN BY ORDER PIN ENTRIES.THE
;WIRING PATH IS DEFINED BY THE POINTER TABLE-RUNLST AND POINTERS
;CORRESPONDING TO THE END PINS OF THE RUN ARE SAVED IN 'ENDS',THUS
;DEFINING THE WIRE PATH IN THE SAME MANNER AS THE ROUTING ALGORITHMS.
;AFTER DEFINING THE PATH,A POPJ IS EXECUTED TO BY PASS THE REST OF THE ROUTER.
;	IF THE RUN IS NOT WELL DEFINED BY THE ORDER PINS,HAND ORDERING IS IGNORED
;AND THE RUN IS GIVEN TO THE ROUTING ALGORITHMS FOR PATH DEFINITION.

IFN 0,<
ILOOP0:	SETCM	B,NUMPIN	;INIT THE ORDER PIN ROUTING LOOPS.
	HRLZS	B		;B IS THE OUTER LOOP INDEX.
	HRR	B,RUNPTR
	MOVEM	B,INITLP	;SAVE FOR INIT OF INNER LOOPS.
	SETOM	F		;BLANK ORDER PIN FLAG.
ILOOP1:	MOVE	D,PNTBL(B)	;GET PINTBL INDEX FOR PIN I.
	MOVE	T,PINTBL(D)	;SAVE PIN NAME FOR PIN I.
	SKIPE	D,PINTB1(D)	;IS THERE AN ORDER PIN ENTRY?
	JRST	JLOOP0		;YES,MOVE ON TO THE NEXT LOOP.
	AOJG	F,PHS1		;NO,THIS CAN HAPPEN ONLY ONCE.
				;HOWEVER THERE MUST BE ONE BLANK.
	HRROS	RUNLST(B)	;1ST BLANK ORDER PIN,THIS IS AN END.
	HRLM	B,ENDS		;PLACE POINTER 'I' IN ENDS.
	JRST	KLOOP0		;BYPASS J LOOP.
JLOOP0:	MOVE	E,INITLP	;INIT LOOP TO SEARCH FOR PIN 'J',
				;A PIN NAME MATCHING THE ORDER PIN.
JLOOP1:	CAMN	E,B		;IS PIN J REALLY PIN I?
	JRST	JLOOP2		;YES,BYPASS.
	HRRZ	C,PNTBL(E)	;GET THE PIN NAME FOR J.
	CAMN	D,PINTBL(C)	;IS PIN J ORDER PIN I?
	JRST	JLOOP3		;YES,TERMINATE SEARCH.
JLOOP2:	AOBJN	E,JLOOP1	;NO,SET UP INDEX FOR NEW PIN J.
	JRST	PHS1		;NOMATCHES,IGNORE HAND ORDERING.
JLOOP3:	HRLM	E,RUNLST(B)	;SAVE J AS I'S NEIGHBOR.
	HRRM	B,RUNLST(E)	;SAVE I AS J'S NEIGHBOR.
KLOOP0:	MOVE	E,INITLP	;INIT LOOP TO SEARCH FOR ORDER PIN K.
KLOOP1:	CAMN	E,B		;IS PIN K REALLY PIN I?
	JRST	KLOOP2		;YES,BYPASS.
	HRRZ	C,PNTBL(E)	;NO,GET INDEX FOR PIN K.
	CAMN	D,PINTB1(C)	;IS ORDER PIN I ORDER PIN K?
	JRST	PHS1		;YES,DUPLICATE ORDER PINS,IGNORE HND ORDER.
	CAMN	T,PINTB1(C)	;IS PIN I THE SAME AS ORDER PIN K?
	JRST	ILOOP2		;YES,TERMINATE SEARCH.
KLOOP2:	AOBJN	E,KLOOP1	;SET INDEX FOR NEXT ORDER PIN.
	MOVE	D,RUNLST(B)	;NO MATCHES FOUND,CAN ONLY HAPPEN ONCE.
	TRNE	D,777777	;IS THIS THE FIRST TIME?
	JRST	PHS1		;NO,TERMINATE HAND ORDERING.
	HRRM	B,ENDS		;YES,THIS MUST BE AN END PIN.
	HLLOS	RUNLST(B)	;DESIGNATE AS AND END PIN.
ILOOP2:	AOBJN	B,ILOOP1	;TRY NEXT PIN AS THE I PIN.
	SKIPGE	F		;ALL DONE WITH APPARENT SUCCESS.
	JRST	PHS1		;NO END PINS?-FORGET IT!
	SETOM	HNDOSW		;RUN OK ACCEPT AS HAND ORDERED.
	POPJ	P,		;EXIT TO BYPASS ROUTING ALGORITHMS.
>;IFN 0
;		PHS1
;PHS1 - PHASE ONE OF RUN OPTIMIZING
;PUTS PIN 0 INTO THE RUN, THEN FINDS THE PIN NEAREST PIN 0 AND
;PUTS THAT INTO THE RUN. FROM THEN ON, IT KEEPS TRACK OF THE TWO
;END PINS OF THE RUN. THE PIN NEAREST EITHER OF THE TWO END PINS
;IS ALWAYS THE NEXT PIN PUT INTO THE RUN. THE PROCESS CONTINUES
;UNTIL THE RUN INCLUDES ALL THE PINS. THIS RUN FORMS THE FIRST
;APPROXIMATION FOR PHASE TWO WHICH FOLLOWS.

;THE RUN TABLE HAS ONE WORD FOR EACH PIN IN THE RUN. THE RIGHT
;AND LEFT HALVES OF THIS WORD HAS THE PIN NUMBERS OF THE TWO
;NEIGHBORING PINS. -1 MEANS THE END OF THE RUN.

PHS1:	SETZM	ENDS		;SET BOTH ENDS OF RUN TO FIRST PIN
	SETOM	RUNLST		;SET BOTH NEIGHBORS OF FIRST PIN TO ENDS
	MOVE	B,[XWD RUNLST,RUNLST+1]	;WIPE OUT THE WHOLE RUN TABLE
	BLT B,RUNLST+MAXP-1
	SETZM TOTDST		;SET CUMULATIVE DISTANCE TO 0
	SETZM LSTLNG		;CLEAR COUNT OF NO. PINS IN RUN
	SETOM PHSSW		;SET SWITCH TO EXAMINE 1 END
	MOVSI TTT,ROUMRK	;BIT FOR MARKING PINS IN THE RUN
	ORM	TTT,PNTBL	;MARK FIRST PIN

PHS10:	HRLOI T,377777	;SET MIN LENGTH TO INFINITY
	MOVEM T,LNGMIN
	HRRZ T,ENDS		;GET ONE END OF THE RUN

PHS11:	MOVEI TT,-1(A)	;INDEX THROUGH ALL PINS
PHS13:	TDNE TTT,PNTBL(TT)	;THIS PIN MARKED YET?
	JRST PHS12		;YES, SKIP TO NEXT PIN
	MOVE B,T		;GET THE TWO INDICES
	MOVE C,TT
	CAMG B,C		;SMALLER INDEX MUST BE IN C
	EXCH B,C
	MOVE B,@PTRTBL-1(B)	;GET DISTANCE BETWEEN PINS
	CAML B,LNGMIN		;IS IT SHORTER?
	JRST PHS12		;NO, TRY ELSEWHERE
	SETZM	LSTEMP		;FLAG NEW WINNER FOUND
	MOVEM B,LNGMIN		;YES, SAVE NEW RECORD
	MOVEM TT,LSTCND		;SAVE CANDIDATE FOR INCLUSION

PHS12:	SOJGE	TT,PHS13	;TRY NEXT PIN (DONE?)
	SOS B,PHSSW		;PERHAPS, CHECK SWITCH
	AOJN B,PHS14		;DONE THIS PASS?
	SETOM	LSTEMP		;NO, HALF DONE. FLAG 1ST HALF
	HLRZ T,ENDS		;GET OTHER END OF LIST
	JRST PHS11		;REPEAT

PHS14:	MOVE T,LSTCND	;GET THE WINNER
	ORM TTT,PNTBL(T)	;MARK IT
	SKIPL	LSTEMP		;WINNER CONNECTED TO RIGHT END?
	MOVSS ENDS		;NO, MAKE IT THE RIGHT END
	HRL T,ENDS		;GET OLD END
	HRRM T,ENDS		;SAVE NEW END
	PUSHJ P,CNEND		;CONNECT POINTERS TO NEIGHBORS
	MOVE B,LNGMIN		;ADD LENGTH INTO CUMULATIVE TOT
	ADDM B,TOTDST
	SETZM PHSSW		;RESET SWITCH
	AOS B,LSTLNG		;COUNT PINS IN RUN
	CAILE A,1(B)		;DONE PHASE 1?
	JRST PHS10		;NO, REPEAT AD INFINITUM
	SKIPN FASRAY		;CHEAT, DON'T DO FULL ROUTING
	CAIG A,3		;FILTER OUT 2 &3 PIN RUNS.
	 POPJ P,
;		PHS2
;PHS2 - PHASE TWO
;EACH PIN, STARTING WITH PIN 0, IS IN TURN TAKEN OUT OF
;THE RUN THUS LEAVING TWO DISCONNECTED PIECES IN GENERAL.
; FIRST A NEW SITE FOR THE CHOSEN PIN IS LOOKED FOR BY
;SQUEEZING THE PIN BETWEEN EACH OF THE REMAINING PAIRS
;OF PINS. THEN THE TWELVE WAYS OF RECONNECTING THE PIN
;AND THE TWO PIECES ARE TRIED. OF ALL THESE, THE MINIMUM
;CONFIGURATION IS PRESERVED AND THE PROCESS IS REPEATED
;ON PIN N+1. A PASS TERMINATES WHEN ALL PINS HAVE BEEN
;THUS EXAMINED. IF ANY IMPROVEMENTS WERE DISCOVERED,
;ANOTHER PASS IS MADE.

PHS2:	SETOM IMPRV3		;SET FLAG TO GO THRU PHASE 3
PHS2A:	MOVE A,NUMPIN		;START THE PASS WITH HIGHEST PIN
	SETZM IMPRV		;CLEAR THE IMPROVEMENT FLAG

PHS29:	HRRZ T,ENDS		;START AT ONE END OF THE RUN
	CAMN T,A		;ALREADY FOUND THE REMOVED PIN?
	HLRZ T,ENDS		;YES, SO START AT THE OTHER END
	HRLOI B,77777		;SET BEST DISTANCE TO INFINITY
	MOVEM B,MINLNG
	MOVNI TTT,1		;T HAS THIS PIN - TT HAS
				;NEXT PIN - TTT HAS PREVIOUS PIN

PHS26:	HRRE TT,RUNLST(T)	;FIND NEXT PIN
	CAMN TT,TTT		;FOUND PREV. PIN INSTEAD?
	HLRE TT,RUNLST(T)	;YES, SO TAKE OTHER PIN
	CAMN TT,A		;FOUND THE REMOVED PIN?
	JRST PHS20		;YES, THE ENDS OF THE 2 PIECES
				;ARE NOW IDENTIFIABLE
	SKIPGE C,TT		;FOUND THE FAR END OF THE RUN?
	JRST PHS21		;YES, GO CLEAN UP
	MOVE B,T		;COMPUTE DISTANCE COST IF PIN
				;SQUEEZED IN HERE
	CAMG B,C
	EXCH B,C
	MOVN D,@PTRTBL-1(B)	;DISTANCE SAVED BY BREAKING
				;CONNECTION BETWEEN NEIGHBORS
	PUSHJ P,PHS22		;ADD IN 2 NEW LEGS GENERATED
	CAML D,MINLNG		;MORE BETTERER??
	JRST PHS24		;NO, GO TO NEXT PAIR
	MOVEM D,MINLNG		;YES, SAVE NEW RECORD
	HRRM T,BSTSPT	;SAVE THIS PAIR
	HRLM TT,BSTSPT

PHS24:	MOVE TTT,T		;THIS PIN BECOMES PREV. PIN
	MOVE T,TT		;NEXT PIN BECOMES THIS PIN
	JRST PHS26		;REPEAT
;		PHS22, PHS20
;PHS22 - SUBROUTINE FOR PHASE 2
;ADDS UP THE DISTANCES FOR THE TWO LEGS PUT IN WHEN A PIN
;IS SQUEEZED IN BETWEEN TWO NEIGHBORING PINS

PHS22:	MOVE C,T		;ADD IN LEG FROM THIS PIN
	PUSHJ P,PHS221
	MOVE C,TT		;ADD IN LEG FROM NEXT PIN
PHS221:	MOVE B,A		;GET OTHER INDEX
	CAMG B,C
	EXCH B,C
	ADD D,@PTRTBL-1(B)	;ADD IN APPROPRIATE DISTANCE
	POPJ P,			;RETURN

;PHS20 - A PIECE OF PHASE 2 LOGIC
;COMES HERE WHEN THE FIRST OF THE TWO DISCONNECTED PIECES IS
;SCANNED. AT THIS POINT, BUT NOT BEFORE, THE FOUR ENDS OF THE
;TWO PIECES ARE IDENTIFIABLE. THE MINIMUM WAY TO HOOK
;UP THE TWO PIECES WITHOUT INVOLVING THE REMOVED PIN IS FOUND

PHS20:	MOVE TT,RUNLST(A)	;THE NEIGHBORS OF THE REMOVED PIN
				;ARE THE CUT ENDS OF THE 2 PIECES
	CAIN T,(TT)	;MAKE THE END ALREADY FOUND
				;BE IN THE LEFT HALF
	MOVSS TT
	TRNE TT,400000	;IS THE SELECTED PIN AN END?
	JRST PHS201		;YES, WE ARE DONE
	MOVE TTT,ENDS		;GET THE REAL ENDS
	ROTC TT,22		;PUT APPROPRIATE ENDS TOGETHER
	MOVEM TT,SEG1		;SAVE ENDS OF 1ST SEGMENT
	MOVEM TTT,SEG2		;LIKEWISE THE 2ND SEGMENT
	PUSHJ P,PHS25		;FIND THE MINIMUM LINK TO
				;HOOK UP THE TWO PIECES
	MOVEM D,LNKDST		;SAVE THE RESULT
	MOVEI D,0
	PUSHJ P,PHS23		;FIND THE DISTANCE SAVED BY
				;CUTTING THE CHOSEN PIN OUT OF
				;THE RUN
	MOVEM D,SUBTOT		;SAVE THIS RESULT
	HRRZ T,TT		;CONTINUE TO THE OTHER SEGMENT
	MOVE TTT,A
	JRST PHS26
;		PHS201
;PHS201 - A PIECE OF PHASE 2 LOGIC
;COME HERE WHEN THE SELECTED PIN IS AT AN END

PHS201:	SETZB D,LNKDST		;REMOVING SELECTED PIN FORM 1 PIECE
	PUSHJ P,PHS23		;FIND DISTANCE SAVED BY REMOVAL
	MOVEM D,SUBTOT		;SAVE THE GAIN
	HRRZ B,ENDS		;TRY THIS PIN AT THE OTHER END
	CAMN B,A		;OTHER END FOUND?
	MOVSS ENDS		;NO, SO SWAP
	HRRZ B,ENDS		;GET THE OTHER END
	MOVE C,A		;GET THE LENGTH
	CAMG B,C
	EXCH B,C
	MOVE D,@PTRTBL-1(B)
	CAML D,MINLNG		;IS THIS THE LOWEST COST?
	JRST PHS202		;NO, GO FINISH UP
	MOVEM D,MINLNG		;YES, SAVE NEW PARAMS
	MOVSS D,ENDS		;MAKE IT EASY TO UPDATE ENDS
	HLROM D,BSTSPT		;SAVE NEW LOCATION FOR THE PIN

PHS202:	MOVE D,MINLNG		;HAVE WE FOUND A REAL IMPROVEMENT?
	CAML D,SUBTOT
	JRST PHS28		;NO, TRY THE NEXT PIN
	SUB D,SUBTOT		;COMPUTE NEW RUN LENGTH
	ADDM D,TOTDST
	PUSHJ P,TKOUT		;RECONNECT THE RUN
	MOVE B,BSTSPT
	EXCH B,RUNLST(A)
	SKIPL B
	MOVSS B
	HRLM B,ENDS		;UPDATE THE NEW END
	JRST PHS212		;FINISH UP AND TRY THE NEXT PIN
;		PHS25, PHS23
;PHS25 - SUBROUTINE FOR PHASE 2
;FINDS THE MINIMUM PATH FOR CONNECTING THE TWO
;DISCONNECTED PIECES OF THE RUN

PHS25:	HRLOI D,377777		;SET MIN DISTANCE TO INFINITY
	PUSHJ P,PHS252		;TRY TWO OF THE WAYS TO HOOK UP
	MOVSS TT		;TRY THE OTHER TWO WAYS
PHS252:	PUSHJ P,PHS251		;HOOK UP ENDS AS THEY STAND
	MOVSS TTT		;TURN SEGMENT 2 AND TRY AGAIN

PHS251:	HLRZ B,TT		;GET ONE END
	HLRZ C,TTT		;AND THE OTHER
	CAMG B,C
	EXCH B,C
	CAMG D,@PTRTBL-1(B)	;IS THIS LEG SHORTER?
	POPJ P,			;NO, SO RETURN
	MOVE D,@PTRTBL-1(B)	;SAVE THIS DISTANCE
	HRRM B,ENDCON		;SAVE WHICH LINK TO MAKE
	HRLM C,ENDCON
	POPJ P,			;RETURN

;PHS23 - SUBROUTINE FOR PHASE 2
;FINDS THE DISTANCE SAVED BY CUTTING THE SELECTED PIN OUT
;OF THE RUN

PHS23:	HLRE C,RUNLST(A)	;GET ONE NEIGHBOR
	SKIPL C			;IGNORE IF IT IS AN END
	PUSHJ P,PHS221		;GET THAT DISTANCE
	HRRE C,RUNLST(A)	;GET THE OTHER
	JUMPGE C,PHS221		;GET THAT DISTANCE AND RETURN
	POPJ P,			;UNLESS IT IS AN END
;		PHS21
;PHS21 - A PIECE OF PHASE 2 LOGIC
;COME HERE WHEN ALL WAYS TO SQUEEZE BACK THE SELECTED PIN
;HAVE BEEN TRIED. PHS21 TRIES THE 12 WAYS TO RECONNECT THE
;TWO PIECES AND THE SELECTED PIN WITHOUT SQUEEZING BETWEEN
;ALREADY CONNECTED PINS.

PHS21:	MOVE D,LNKDST		;COMPUTE REAL DISTANCE TO BEAT
	ADDM D,MINLNG
	PUSHJ P,PHS27		;TRY THE 12 REMAINING PATTERNS
	MOVE D,MINLNG		;GET THE MINIMUM COST
	CAML D,SUBTOT		;COMPARE WITH THE SAVINGS
	JRST PHS28		;NOT GOOD ENOUGH, TRY AGAIN
	SUB D,SUBTOT		;COMPUTE THE NEW TOTAL LENGTH
	ADDM D,TOTDST
	PUSHJ P,TKOUT		;TAKE OUT THE SELECTED PIN
	MOVE T,ENDCON	;MAKE THE SELECTED BRIDGE
	PUSHJ P,CNEND
	MOVE B,BSTSPT		;SQUEEZE THE PIN BACK IN
	EXCH B,RUNLST(A)
	PUSHJ P,UPDEND		;UPDATE THE NEW ENDS
	SKIPL	E,RUNLST(A)	;IS THE NEW CANDIDATE AN END?
	JRST	PHS212		;N0.
	HRRZ	D,ENDS		;YES,ADJUST ENDS.
	CAIE	D,(E)
	HRLM	A,ENDS
	CAIN	D,(E)
	HRRM	A,ENDS
PHS212:	PUSHJ P,PUTIN
	SETOM IMPRV		;FLAG AN IMPROVEMENT
;		PHS28, UPDEND
PHS28:	SOJGE A,PHS29		;STEP TO NEXT PIN (DONE?)
	SKIPGE IMPRV		;YES, ANY IMPROVEMENTS?
	JRST PHS2		;YES, REPEAT THIS PHASE
	SKIPGE IMPRV3		;SKIP PHASE 3 FOR 2 FAILURES
	PUSHJ P,PHS3		;NOW SEE WHAT PHASE 3 CAN DO
	AOSN IMPRV3		;DID PHASE 3 DO ANY GOOD?
	JRST PHS2A		;YES, REDO PHASE 2
	POPJ P,			;DONE, RETURN FOR FINAL OUTPUT

;UPDEND - UPDATE ENDS
;CHECKS THAT THE OLD ENDS OF THE RUN ARE STILL ENDS. IF NOT,
;IT LOOKS FOR NEWLY GENERATED ENDS IN THE 2 HALVES OF B.

UPDEND:	MOVE C,[XWD 400000,400000]	;CODE FOR TESTING SIGN
				;BITS OF BOTH HALVES
	PUSHJ P,.+2		;CHECK ONE OLD END
	MOVSS ENDS		;SWAP ENDS
	HRRZ D,ENDS		;GET ONE END
	TDNE C,RUNLST(D)	;EITHER SIGN BIT ON? IE. IS=END?
	POPJ P,			;YES, RETURN
UPDEN1:	MOVSS B			;NO, CHECK ONE HALF OF B, SWAP
				;TO CHECK OTHER HALF NEXT TIME
	HLRZ E,ENDS		;DONT LET BOTH ENDS BE EQUAL
	CAIE E,(B)
	TDNN C,RUNLST(B)	;IS THIS THE REAL NEW END?
	JRST UPDEN1		;NO, IT MUST BE THE OTHER HALF
	HRRM B,ENDS		;REPLACE WITH THE NEW END
	POPJ P,			;RETURN
;		PHS27
;PHS27 - SUBROUTINE FOR PHASE 2
;IN EFFECT, PHS27 TAKES THE TWO SEGMENTS IN SOME PARTICULAR
;ORIENTATION, CONNECTS THE TWO PIECES AND THE SINGLE PIN
;INTO A LOOP, AND THROWS OUT THE LONGEST LINK IN THE LOOP. THEN
;THE ORIENTATION OF ONE OF THE PIECES IS SWITCHED AND THE PROCESS
;REPEATED. THE SMALLEST RESULT IS KEPT.

PHS27:	PUSHJ P,PHS274		;TRY 2 OF THE 4 ORIENTATIONS
	MOVSS SEG2		;TRY THE OTHER 2
PHS274:	PUSHJ P,PHS271		;TRY THIS ORIENTATION
	MOVSS SEG1		;THEN TRY ANOTHER

PHS271:	SETZB D,T		;CLR TOT DISTANCE AND MAX
	HLR TT,SEG1		;CALCULATE FINAL RESULTS IN
				;CASE THIS LINK IS LONGEST
	HLL TT,SEG2
	HRRO TTT,SEG2
	HRRZ C,SEG1		;CONNECT PIN TO THIS END
	PUSHJ P,PHS272		;GET DISTANCE AND COMPARE
	HRRZ C,SEG2		;CONNECT PIN TO OTHER END
	HRRO TTT,SEG1		;FINAL RESULT IF ...
	PUSHJ P,PHS272		;GET DISTANCE AND COMPARE
	HLRZ B,SEG1		;CONNECT 2 ENDS TOGETHER
	HLRZ C,SEG2
	HRR TT,SEG1		;FINAL RESULTS IF ...
	HRL TT,SEG2
	MOVE TTT,TT
	PUSHJ P,PHS273		;GET DISTANCE AND COMPARE
	SUB D,T		;SUBTRACT OFF BIGGEST LINK
	CAML D,MINLNG		;IS THIS THE BEST SO FAR?
	POPJ P,			;NO, RETURN
	MOVEM D,MINLNG		;YES, SO SAVE RESULTS
	MOVEM TTTT,ENDCON
	MOVEM G,BSTSPT
	POPJ P,			;RETURN

PHS272:	MOVE B,A		;PICK UP OTHER INDEX
PHS273:	CAMG B,C		;GET DISTANCE
	EXCH B,C
	ADD D,@PTRTBL-1(B)	;ADD INTO TOTAL
	CAML T,@PTRTBL-1(B)	;BIGGEST SO FAR?
	POPJ P,			;NO SO RETURN
	MOVE T,@PTRTBL-1(B)	;YES, SO SAVE THIS DISTANCE
	MOVEM TT,TTTT		;SAVE RESULT
	MOVEM TTT,G
	POPJ P,			;RETURN
;		TKOUT, PUTIN, CNEND
;TKOUT - TAKE OUT
;SUBROUTINE TO CUT A PIN OUT OF THE RUN

TKOUT:	HLRE B,RUNLST(A)	;PICK UP ONE NEIGHBOR TO CUT OUT
	PUSHJ P,.+2		;DO IT
	HRRE B,RUNLST(A)	;PICK UP THE OTHER
	JUMPL B,CPOPJ		;DO NOTHING AT AN END
	HRRZ C,RUNLST(B)	;CLOBBER RIGHT HALF?
	CAMN C,A
	HLLOS RUNLST(B)		;YES
	CAME C,A		;CLOBBER LEFT HALF?
	HRROS RUNLST(B)		;YES
	POPJ P,			;RETURN

;PUTIN - PUT A PIN BACK IN

PUTIN:	HLRE B,RUNLST(A)	;GET THE COMPONENTS OF THE
				;BRIDGE TO BREAK
	HRRE C,RUNLST(A)
	PUSHJ P,.+2		;RECONNECT ONE NEIGHBOR
	EXCH B,C		;DO SAME FOR OTHER NEIGHBOR
	JUMPL B,CPOPJ		;DO NOTHING IF NEIGHBOR IS END
	HRRE D,RUNLST(B)	;CLOBBER RIGHT HALF?
	CAMN C,D
	HRRM A,RUNLST(B)	;YES, SO DO IT
	CAME C,D		;CLOBBER LEFT HALF?
	HRLM A,RUNLST(B)	;YES, SO DO IT
	POPJ P,			;RETURN

;CNEND - CONNECT ENDS

CNEND:	PUSHJ P,CNEND1		;CONNECT ONE LINK
	MOVSS T		;CONNECT THE OTHER WAY
CNEND1:	SKIPL RUNLST(T)	;END MARKED IN LEFT HALF?
	HLRM T,RUNLST(T)	;NO, SO CLOBBER RIGHT HALF
	SKIPGE RUNLST(T)	;END MARKED IN LEFT HALF?
	HLLM T,RUNLST(T)	;YES, SO CLOBBER IT
	POPJ P,			;RETURN
;		PHS3
;PHS3 - PHASE 3
;THE RUN IS BROKEN IN TWO PLACES TO FORM THREE PIECES. THE
;THREE PIECES ARE THEN RECONNECTED IN ALL 24 POSSIBLE WAYS.
;ANY WAY THAT PROVIDES A REDUCTION IN RUN LENGTH IS KEPT.
;THE PROGRAM KEEPS TRACK OF THE ENDS OF THE THREE PIECES
;AND ONLY CLOBBERS POINTERS WHEN AN IMPROVEMENT IS FOUND.

PHS3:	SETZM IMPRV3		;CLEAR THE IMPROVEMENT FLAG
PHS300:	MOVE A,ENDS		;SET UP THE INITIAL 3 SEGMENTS
	HRLM A,SEG1		;SEG1 IS THE "LEFTMOST" PIN
	HLLM A,SEG3		;SEG3 CONTAINS THE "RIGHTMOST" PINS
	SETOM C			;DUMMY UP A POINTER FOR THE
				;FIRST ADVANCE
	SETZM MINLNG		;SET NET IMPROVEMENT TO 0
	PUSHJ P,PHS30		;GO DO ALL THE WORK
	SKIPL A,MINLNG		;WAS AN IMPROVEMENT FOUND?
	POPJ P,			;NO, SO QUIT
	ADDM A,TOTDST		;UPDATE THE TOTAL DISTANCE
	HRRZ B,SEG1		;REALLY BREAK THE RUN INTO 3
	HLRZ C,SEG2		;MAKE THE FIRST CUT
	PUSHJ P,DCON
	HRRZ B,SEG2		;MAKE THE OTHER CUT
	HRRZ C,SEG3
	PUSHJ P,DCON
	MOVE T,LSEG1		;RECONNECT THE PIECES INTO A LOOP
	HLL T,LSEG2
	PUSHJ P,CNEND
	MOVE T,LSEG2
	HLL T,LSEG3
	PUSHJ P,CNEND		;MAKE THE SECOND LINK
	MOVE T,LSEG3
	HLL T,LSEG1
	PUSHJ P,CNEND		;CLOSE THE LOOP
	MOVE B,DCNECT		;NOW BREAK THE APPROPRIATE LINK
	HRRZ C,ENDS		;START AT A DIFFERENT END NEXT TIME
	CAIN C,(B)
	MOVSS B
	MOVEM B,ENDS		;THIS BREAK FORMS THE NEW ENDS
	HLRZ C,B
	HRRZS B
	PUSHJ P,DCON
	SETOM IMPRV3		;TELL THE WORLD THE GOOD NEWS
	JRST PHS300
;		PHS32, PHS30
;PHS32 - A WRAPPED LOOP FOR PHS30
;PHS30 - A SUBROUTINE FOR PHASE 3
;PHS30 CYCLES THROUGH A POSSIBLE PAIRS OF PLACES TO BREAK THE
;RUN. PHS31 IS CALLED TO TRY THE WAYS TO RECONNECT THE PIECES.
;AS SOON AS PHS31 FINDS AN IMPROVEMENT, PHS30 RETURNS
;TO THE TOP LEVEL.

PHS32:	HRRM B,SEG2		;UPDATE THE END OF SEGMENT 2
	HRRM C,SEG3		;LIKEWISE SEG3
	CAMG B,C		;FIND THE DISTANCE SAVED BY
	EXCH B,C		;MAKING THE TWO CUTS
	MOVE D,@PTRTBL-1(B)
	HRRZ B,SEG1
	HLRZ C,SEG2
	CAMG B,C
	EXCH B,C
	ADD D,@PTRTBL-1(B)
	MOVEM D,SUBTOT		;SAVE THE SAVINGS
	PUSHJ P,PHS31		;TRY RECONNECTING
	SKIPGE MINLNG		;IMPROVEMENTS?
	POPJ P,			;YES!
	MOVE A,SEG2		;SHRINK SEG3, EXPAND SEG2
	HRRZ B,SEG3
PHS33:	HRRE C,RUNLST(B)	;GET THE NEW END FOR SEG3
	CAIN C,(A)		;GOT THE WRONG LINK?
	HLRE C,RUNLST(B)	;YES, GET THE OTHER
	JUMPGE C,PHS32		;SEG3 SQUEEZED OFF THE END?
	MOVE C,SEG1		;YES, SO EXPAND SEG1, MAKE SEG2
	MOVS A,SEG2		;BE EXACTLY 1 PIN, SEG3 BE THE
				;REST
PHS30:	HRRZ B,RUNLST(A)	;GET THE NEW END FOR SEG2
	CAIN B,(C)		;GOT THE WRONG LINK?
	HLRZ B,RUNLST(A)	;YES, GET THE OTHER
	MOVS C,ENDS		;IS SEG2 SHOVED ONTO THE END PIN?
	CAIN B,(C)
	POPJ P,			;YES, SO WE ARE DONE
	HRRM A,SEG1		;UPDATE THE NEW END OF SEG1
	HRLM B,SEG2		;LIKEWISE SEG2
	JRST PHS33		;TIE DOWN THE LOOSE ENDS
;		PHS31
;PHS31 - SUBROUTINE FOR PHASE 3
;PHS31 CYCLES THROUGH THE 8 PERMUTATIONS OF THE THREE
;SEGMENTS BY FLIPPING EACH SEGMENT IN TURN IN A BINARY
;SEQUENCE. IF A SEGMENT CONTAINS ONLY 1 PIN, THE SEQUENCE
;IS SHORTENED BY NOT FLIPPING THAT SEGMENT.
;PHS313 CONNECTS THE RESULTING PERMUTATION INTO A LOOP ANDS
;FINDS AND THROWS AWAY THE LONGEST LINK.

PHS31:	MOVE T,SEG1		;TRY SEG1 UNFLIPPED
	PUSHJ P,PHS311
	MOVSS T		;FLIP SEG1 AND TRY AGAIN
	CAMN T,SEG1		;BUT NOT IF SEG1 HAS 1 PIN
	POPJ P,
PHS311:	MOVE TT,SEG2		;TRY SEG2 UNFLIPPED
	PUSHJ P,PHS312
	MOVSS TT		;FLIP SEG2 AND TRY AGAIN
	CAMN TT,SEG2		;BUT NOT IF SEG2 HAS 1 PIN
	POPJ P,
PHS312:	MOVE TTT,SEG3		;TRY SEG3 UNFLIPPED
	PUSHJ P,PHS313
	MOVSS TTT		;FLIP SEG3 AND TRY AGAIN
	CAMN TTT,SEG3		;BUT NOT IF SEG3 HAS 1 PIN
	POPJ P,

PHS313:	MOVNI E,1		;SET LONGEST LINK NEGATIVE
	MOVN A,SUBTOT		;START COMPUTING NET GAIN
	MOVEI B,(T)		;GET LENGTH OF 1ST LINK
	HLRZ C,TT
	PUSHJ P,PHS34
	MOVEI B,(TT)		;REPEAT FOR SECOND LINK
	HLRZ C,TTT
	PUSHJ P,PHS34
	MOVEI B,(TTT)		;REPEAT FOR THIRD LINK
	HLRZ C,T
	PUSHJ P,PHS34
	SUB A,E			;THROW AWAY THE LONGEST LINK
	CAML A,MINLNG		;IS THE IMPROVEMENT REALLY?
	POPJ P,			;NO, TRY AGAIN
	MOVEM A,MINLNG		;SAVE THE SAVING
	MOVE A,[XWD T,LSEG1]	;SAVE POINTERS FOR RECONSTRUCTING
	BLT A,DCNECT		;THIS SOLUTION
	POPJ P,			;TRY AGAIN
;		PHS34, DCON
;PHS34 - SUBROUTINE FOR PHASE 3
;PHS34 FINDS THE MAXIMUM LINK FOR PHS31 AND ADDS UP THE
;LINKS AS IT GOES ALONG.

PHS34:	CAMG B,C		;GET LENGTH OF THE SELECTED LINK
	EXCH B,C
	MOVE D,@PTRTBL-1(B)
	ADD A,D			;CUMULATE THE DISTANCES
	CAMG D,E		;IS THIS THE LONGEST?
	POPJ P,			;NO, DO NOTHING
	MOVE E,D		;YES, SAVE THIS LENGTH
	HRL C,B			;SAVE POINTERS FOR THROWING
	MOVE TTTT,C		;THIS LINK AWAY
	POPJ P,

;DCON - DISCONNECT
;BREAKS THE CONNECTION BETWEEN TWO PINS BY CHANGING THE LINKS
;TO END POINTERS

DCON:	PUSHJ P,DCON1		;BREAK ONE POINTER
	EXCH B,C		;BREAK THE OTHER
DCON1:	HRRZ A,RUNLST(B)	;IS THE LEFT HALF THE VICTIM?
	CAMN A,C
	HLLOS RUNLST(B)		;NO, CLOBBER THE RIGHT HALF
	CAME A,C
	HRROS RUNLST(B)		;YES, CLOBBER THE LEFT HALF
	POPJ P,			;RETURN
;		STORAGE
;TEMPORARY STORAGE

NUMPIN:	0			;THE HIGHEST PIN NUMBER READ IN
ENDS:	0			;LEFT AND RIGHT HALVES CONTAIN
				;THE TWO ENDS OF THE RUN
TOTDST:	0			;THE CURRENT LENGTH OF THE RUN
LSTLNG:	0			;THE NUMBER OF PINS INCLUDED
PHSSW:	0			;A FLAG FOR PHASE 1
LNGMIN:	0			;SHORTEST LINK FOUND IN PHASE 1
LSTCND:	0			;CURRENT CANDIDATE TO GO NEXT
				;INTO THE RUN
LSTEMP:	0			;TEMPORARY FOR LSTCND DURING
				;THE SECOND HALF OF PHASE 1
IMPRV_PHSSW			;A FLAG FOR PHASE 2
MINLNG_LNGMIN			;SHORTEST ADDITION TO THE LENGTH
				;OF THE RUN FOUND IN PHASE 2
BSTSPT_LSTCND			;BEST PLACE TO SQUEEZE IN THE
				;SELECTED PIN
LNKDST_LSTLNG			;LENGTH ADDED BY BRIDGING
				;ACROSS CUT ENDS
ENDCON_LSTEMP			;THE TWO ENDS TO BRIDGE ACROSS
SUBTOT:	0			;DISTANCE SAVED BY CUTTING THE
				;SELECTED PIN OUT OF THE RUN
SEG1:	0			;THE TWO ENDS OF ONE OF THE CUT
				;PIECES
SEG2:	0			;THE TWO ENDS OF THE OTHER PIECE
SEG3_BSTSPT			;THE 3RD SEGMENT FOR PHASE 3
LSEG1:	0			;THE RECOMMENDED PERMUTATION
LSEG2:	0			;FOR PHASE 3
LSEG3:	0			;...
DCNECT:	0			;THE UNRECOMMENDED CONNECTION
IMPRV3:	0			;IMPROVEMENT FLAG FOR PHASE 3
INITLP_SUBTOT			;TEMP LOC USED FOR LOOP INIT.

SCTR:	0			;COUNTER FOR NUMBER OF S-PINS
HNDOSW:	0			;FLAG FOR HAND ORDERED RUNS
SCPTR:	POINT 3,PNTBL(E),17	;BYTE PTR TO S/C NUMBER
ORDPTR:	POINT 10,PNTBL(E),14	;POINTER TO ORDER CODE
;		TABLES

;PTRTBL - POINTER TABLE
;TABLE OF POINTERS FOR PHANTOM DOUBLE INDEXING ON THE
;TRIANGULAR DISTANCE MATRIX. ACCUMULATOR C MUST HAVE THE
;SMALLER PIN NUMBER. IF AC HAS THE OTHER PIN NUMBER, REFER
;TO THE DISTANCE TABLE BY - MOVE X,@PTRTBL-1(AC).

PTRTBL:	FOR I_0,MAXP-1
	<C,,DISTBL+I*(I+1)/2
>
PTRTB1_PTRTBL-1

;DISTBL - DISTANCE TABLE
;A TRIANGULAR MATRIX OF THE LENGTH OF WIRE REQUIRED
;TO CONNECT ALL POSSIBLE PAIRS OF PINS. ROW 1 HAS DISTANCE
;BETWEEN PINS 1-0, ROW 2 HAS DISTANCE BETWEEN PINS 2-0, 2-1,
;ROW 3 HAS 3-0, 3-1, 3-2, ETC.
;DISTBL SPACE IS TAKEN FROM THE FREE SPACE AT JOBFF.

DISTBL:	BLOCK MAXP*(MAXP+1)/2	;ASSEMBLE IN FOR NOW

;PNTBL - PIN TABLE
;CONTAINS PIN POINTERS, "SCT" INFO, ORDER #, AND MARK BIT
;BITS IN PNTBL WORD USED BY ROUTER
;RPGPIN__400000		;THIS IS A POWER OR GROUND PIN, IT IS NOT IN WIRE LIST
;RERPIN__200000		;THIS PIN IS IN ERROR IN SOME WAY, DON'T WIRE IT!
;ROUMRK__100000		;MARK BIT FOR ROUTER
;BITS 5-14 ORDER #
;BITS 15-17 "SCT" CHARS
;BITS 18-35 PIN POINTER

;SCT "CHARS" USED TO FORCE A PIN TO END OF RUN
; 1 -	TERMINATOR PIN
; 2 -	CONNECTOR
; 4 -	SOURCE

PNTBL:	BLOCK MAXP		;PIN POINTER
PNTBL1:	BLOCK MAXP		;PIN-SPEC (FLAGS+PIN#,,SLOT#)

COMMENT 
;BITS USED IN PNTBL1 FOR PIN IDENTIFICATION
MAPCON__400000		;THIS IS A CON (MUST BE SIGN BIT)
MAPSOC__40000		;THIS IS NOW A POST-LOC, HAS BEEN MAPPED ONTO BOARD
;777			;PIN # FOR BODIES IN LEFT HALF
%%PINN__221100
$$PINN__777
;( In some board types, the format for V or G pins is pin# 0, with MAPPWR or MAPGND set.)
	

;RUNLST - RUN LIST
;A table of pointers representing the order in which to wire
;a run.  The n'th entry has the two neighbors of pin n (as indices into PNTBL) in
;the right and left halves. -1 means the end of run.

RUNLST:	BLOCK MAXP+1
SUBTTL	ROUTER INTERFACE SUBRS
;SUBROUTINES TO INTERFACE WL WITH ROUTER

;WIRSET - ROUTINE TO FILL PNTBL WITH PROPER ENTRIES FOR ROUTING
;CALL WITH POINTER TO WIRE IN W, FIRST PIN IN H
;RETURNS
;	ILLEGAL (1 PIN RUN)
;	TOO MANY PINS IN RUN (H IS CURRENT POINT IN PIN LIST)

WIRSET:	MOVEI G,PNTBL-1		;PUSHDOWN POINTER FOR PINS
	MOVEI F,MAXP
WIRST1:	FETCH(TTT,H,PBIT)
	TRNE TTT,DUP
	 JRST WIRSTD
	PUSHJ P,WIRSTP		;GRONK ONE PIN
	 JRST CPOPJ1		;TABLE FULL
WIRSTD:	FETCH(H,H,NXTP)
	JUMPN H,WIRST1
WIRSTE:	HLRZ G,G
	SOJLE G,CPOPJ		;SKIP TRIVIAL RUNS
	MOVEM G,NUMPIN
	AOS (P)
	JRST CPOPJ1

WIRSTP:	SOJL F,CPOPJ		;LOSE IF RUN OUT OF SPACE
	PUSHJ P,NAMMAP		;FLAG AND MAP PIN!
	 JRST [	TLO TTT,RERPIN		;MARK AS ERROR
		MOVEI T,RFBAD
		MOVEM T,LOSFLG
		JRST .+1]
	PUSH G,TTT		;STORE FLAGS AND PIN POINTER IN SECONDARY TABLE
	MOVEM A,PNTBL1-PNTBL(G)
	JRST CPOPJ1


;NAMMAP - CONVERT A PIN# AND DIP LOCN INTO ACTUAL SOCKET POST
;NAMMAP - H = PIN
;PNAMEP - B = BODY, TT = PINN
;SKIPS IF GOOD PIN
;A = PIN SPEC (MBIT+PINN,,LOC) OF SOCKET PIN
;TTT(LH) = ROUTER FLAGS (NONE FOR NOW)
;TTT(RH) = PTR TO PIN BLOCK

NAMMAP:	HRRZ TTT,H
IFN 0,<				;DISABLE FEATURE FOR PUTTING CONNECTORS
				; OR OUTPUTS AT END OF RUN
	FETCH(T,H,PTYP)
	JUMPE T,[FETCH(T,H,PBDY)
		FETCH(T,T,BBIT)
		TRNE T,CBODY
		 TLO TTT,2	;YES
		JRST PNAME]
	FETCH(T,T,DPBIT)
	TRNE T,OUTLD
	TLO TTT,4		;YES, MARK AS SOURCE
PNAME:
>;IFN 0
	FETCH(B,H,PBDY)		;BODY POINTER
	FETCH(TT,H,PINN)
PNAMEP:	FETCH(A,B,BLOC)
	FETCH(T,B,BBIT)
	JUMPE A,CPOPJ		;ANY LOC?
	TRNE T,BWILD		;WILD CONNECTOR?
	 POPJ P,		;YES, CAN'T ROUTE
	HRL A,TT
	TRNE T,CBODY		;CON?
	 TLO A,MAPCON
	FETCH(B,B,BPAK)		;GET PACKAGE CODE
	PUSH P,TTT		;REMEMBER ROUTER FLAGS, IF ANY
	PUSHJ P,MAPOST		;SKIPS IF SUCCESSFUL
	 CAIA
	 AOS -1(P)
	POP P,TTT
	POPJ P,

RUNFIX:	MOVEI A,-1
	HRRZ B,ENDS
RUNFX1:	HLRZ C,RUNLST(B)
	CAME C,A		;DOES LEFT HALF POINT TO LAST?
	MOVSS RUNLST(B)		;NO, SWAP
	MOVE A,B
	HRRE B,RUNLST(B)
	JUMPGE B,RUNFX1		;CONTINUE TO OTHER END OF RUN
	POPJ P,

NOHND:	0
ORDFLG:	0			;< 0	BY ORDER PIN
				;= 0	ROUTE
				;> 0	BY ORDER #

ZLEVN:	0			;Z LEVEL FOR RUN
RAYLVL:	0			;Z LEVEL USED BY RATHEON ROUTINES
INCHES:	0			;TOTAL WIRE LENGTH ACCUMULATED HERE
WIRELN:	0			;LENGTH OF WIRE FROM THIS PIN TO NEXT
NWIRES:	0			;NUMBER OF WIRES
NRUNS:	0			;NUMBER OF WIRES
TINCHS:	0			;TOTAL NUMBER OF INCHES OF WIRE

WINDSP:	0			;PLACE TO GO FROM ROUWIR ON WIN
LOSDSP:	0			;	"		    LOSE
FASRAY:	0			;-1, don't actually run the router
AUGFORM: 0			;Print AUGAT card format
ISRAY:	0			;INHIBIT PRINTING FOR RAY FILE OUTPUT
FDSP:	0			;PLACE TO GO TO FIND PWR OR GND
FBIT:	0			;BIT TO TEST IN PIN TYPE BITS OF DIP DEF FOR PWR OR GND
SOURCE:	0			;THE CARD PIN FOR THIS ELEM ON CPGLST

NOTDON:	0			; NOT DONE WITH RUN, RUN TOO LONG
ROUSVH:	0			;TEMP PLACE IN RUN, IF RUN TOO LONG
SAVH:	0
SAVW:	0

PGDSP:	0			;PLACE TO DISPATCH TO FROM PGSPEC
PGBIT:	0			;BIT WE ARE TESTING IN PGSPEC

CPGLST:	0			;LIST OF CARD POWER OR GROUNDS WE WILL USE
LOSFLG:	0			;THIS RUN IS LOSING, KEEP COLLECTING BUT PRINT AS LOSER
;		ROUTER SETUP, NORMAL RUN
;ROUWIR - ROUTE AND LIST A WIRE
;W = WIRE LIST HEADER
;H = WIRE
;T = Success-printer
;TT = Failure-printer
; T has code for failure
; 0	Success
; 1	Run was too long
; 2	Run was single pin
;If the run is too long, it is broken into separately routed pieces,
; and several call to the failure printer are made.
RFTOOL__1
RFSING__2
RFBAD__3
RFMAX__3
RFUCK__<1RFSING>+1		;INTERNAL ERRORS

RFERR:	[ASCIZ /WIRELISTER BUG/]
	[ASCIZ /RUN TOO LONG/]
	[ASCIZ /SINGLE PIN RUN/]
	[ASCIZ /BAD PINS ON RUN/]
CHECK RFERR,RFMAX
 
PGZY:
ROUWR2:	MOVEI T,ZLEVPW		;FOR 'WLZ'
	MOVEI TT,ROUNPN		;ERROR MESSAGE
	SETZM FASRAY
	JRST ROUWIR

RPGY:
ROUWR1:	MOVEI T,ROUPNT		;FOR 'WLR'
	MOVEI TT,ROUNPN		; ERROR "CAN'T ROUTE RUN"
	SETZM FASRAY
ROUWIR:	MOVEM T,WINDSP
	MOVEM TT,LOSDSP
	MOVEM W,SAVW		;W= "WIRE LIST HEADER"
	MOVEM H,SAVH		;H=WIRE
	FETCH(T,H,WBIT)		;GET WIRE BITS
	TRNE T,SPWR!SGND	;PWR OR GND RUN?
	 JRST ROUPG		;YES, ROUTE DIFFERENTLY
	SETZM FBIT		;CLEAR THIS FOR PRINT ROUTINE
	FETCH(H,H,WPIN)		;SET H TO FIRST PIN OF RUN FOR WIRSET
	SETZM LOSFLG
ROUWR3:	SETZM NOTDON
	PUSHJ P,WIRSET
	 JRST ROUWR4		;1 PIN RUN
	 JRST [	SETOM NOTDON	;TOO MANY PINS IN RUN
		MOVEI T,RFTOOL
		MOVEM T,LOSFLG
		JRST .+1]
	MOVEM H,ROUSVH		;TAIL OF PIN LIST, IF OVERLEW TABLE SIZE
	PUSHJ P,ROUTER
	 JRST [	OUTSTR[ASCIZ/BARF, SOMEONE CALLED ROUWIR WITH SINGLE PIN RUN!
/]
		JRST ROUWR4]	;IGNORE 1 PIN RUNS
	AOS NRUNS		;COUNT A RUN ROUTED
	PUSHJ P,RUNFIX		;NOW FIX RUNLST POINTERS
	SKIPN T,LOSFLG
	 JRST ROUWIN
	PUSHJ P,ROULEV		;GIVE IT TO APPROPRIATE OUTPUT
	MOVE H,ROUSVH
	SKIPE NOTDON
	 JRST ROUWR3
	POPJ P,

ROUWIN:	MOVE H,SAVH
	MOVE W,SAVW
	JRST @WINDSP

ROUWR4:	MOVEI T,RFSING		;SINGLE WIRE RUN
ROULEV:	MOVE H,SAVH
	MOVE W,SAVW
	JRST @LOSDSP
;		ROUTER SETUP, POWER OR GROUND RUN
;DO PWR, GND ON DIPS ONLY, NO RUN EXISTS
;PGBIT = SPWR or SGND

ROUPG:	TRNN T,SPWR		;WHICH?
	JRST [	MOVE T,[GND,,FGND]	;DPBIT,,ROUTINE TO FIND CLOSEST G PIN ON BOARD
		SKIPN WIRGND
		TLZ T,GND		;NO BITS IF NOT WIRING
		JRST ROUPGF]
	MOVE T,[PWR,,FPWR]
ROUPGF:	HRRZM T,FDSP
	HLRZM T,FBIT
	SKIPE B,CPGLST			;Reclaim old list of GND sources
	 PUSHJ P,PUTFS
	SETZM CPGLST
	HRRZ A,H
	PUSHJ P,CLEARA			;CLEAR PIN MARK BITS IN RUN

;First, find set of card PWR/GND pins that this run will be split up on.
	PUSHJ P,FNDONE			;FIND A CARD PWR OR GND WE WILL NEED
       JRST FNDALL			;FOUND ALL
	MOVEI T,CPGLST
	JRST FPGLP1

FPGLP2:	CAMN A,ADDR(T,PNAM)		;DO WE HAVE THIS ONE ALREADY?
	 POPJ P,			;YES, CO-ROUTINE RETURN TO FNDONE
FPGLP1:	MOVE TT,T
	FETCH(T,T,NWRD)
	JUMPN T,FPGLP2
	GETFS(T,WBLK)
	STORE(A,T,PNAM)			;STORE PIN NAME
	CLEAR(T,NWRD)			;CLEAR OUR LINK OUT
	STORE(T,TT,NWRD)		;STORE US AS LAST LINK OUT
	POPJ P,				;CO-ROUTINE RETURN TO FNDONE


;Next, map down card P/G pins, finding all pins on run that are connected on that P/G pin
FNDALL:	SKIPN T,CPGLST			;ANY CARD PINS LEFT?
	 JRST ROUSOM			;NO, NOW CATCH ALL THE UNROUTED PINS IN RUN
	FETCH(TT,T,NWRD)
	MOVEM TT,CPGLST			;TAKE US OFF LIST
	FETCH(TT,T,PNAM)
	FSTRET(T,WBLK)			;RETURN FREE BLOCK
	MOVSI T,RPGPIN			;MARK AS GENERATED PIN
	MOVEM T,PNTBL			;PUT CARD PIN IN TABLE FIRST
	MOVEM TT,PNTBL1
	MOVEM TT,SOURCE
	MOVE G,[1,,PNTBL]		;ALREADY STORED FIRST ENTRY
	MOVEI F,MAXP-1			;COUNT DOWN NUMBER OF PINS (DON'T COUNT CARD PIN)
	SETZM LOSFLG			;LOSFLG IF WE OVERFLOW ROUTER TABLE
	PUSHJ P,FNDONE			;NOW FIND THEM AGAIN
       JRST RUNEND			;DONE, NOW ROUTE IT
	CAME A,SOURCE			;This pin connects to the card-pin were wiring now?
	 POPJ P,			;NO
	FETCH(T,H,PBIT)
	TRO T,PTMP1			;MARK SO WON'T BE DONE LATER
	STORE(T,H,PBIT)			;MARK AS DONE
	CAMN A,C			;IS THE PIN DEDICATED ON THE BOARD?
	 POPJ P,			;YES, DOESN'T NEED WIRING THEN
	PUSHJ P,ADDPIN			;ADD TO PNTBL, CHECK FOR OVERFLOW
	POPJ P,				;CO-RETURN

ADDPIN:	PUSH G,TTT			;STORE FLAGS,,POINTER TO PIN BLOCK
	MOVEM C,PNTBL1-PNTBL(G)		;STORE PIN NAME
	SOSLE F				;FILLED TABLE?
	 POPJ P,			;CO-ROUTINE RETURN, FIND ANOTHER
	MOVEI T,RFTOOL
	MOVEM T,LOSFLG			;RUN TOO LONG
	PUSHJ P,DUMPIT
	POPJ P,				;CO-ROUTINE RETURN, FIND ANOTHER

DUMPIT:	HLRZ T,G
	SKIPN LOSFLG			;Second chunk of one run?
	 CAILE T,1
	 CAIA
	  POPJ P,			;FLUSH NULL OR SINGLE RUNS
	JUMPE T,CPOPJ			;NO PINS
	SOJLE T,[SETZM NUMPIN		;ONE PIN RUN
		PUSHJ P,ROUEST		;FIXUP RUNLST POINTERS
		MOVEI T,RFSING
		JRST ROUPG1]
	MOVEM T,NUMPIN
	PUSHJ P,ROUTER			;NOW ROUTE IT
	 PUSHJ P,FUCKUP			;LOSE (ONE PIN RUN, CAN'T HAPPEN)
	PUSHJ P,RUNFIX
	SKIPN T,LOSFLG
	 JRST ROUWIN			;SUCCESS CALL FOR OUTPUT
ROUPG1:	PUSH P,H
	PUSH P,W
	PUSHJ P,ROULEV			;RETURN THESE PINS IN ERROR
	POP P,W
	POP P,H
	MOVEI G,PNTBL-1			;MORE PINS ON THIS RUN, BUT BROKEN OFF
	MOVEI F,MAXP
	POPJ P,				;CO-ROUTINE RETURN

RUNEND:	PUSHJ P,DUMPIT
	JRST FNDALL			;GET RUN FOR NEXT CARD PIN
;ROUSOM - catch all pins that we couldn't find a P/G pin for.
; (Only if we were trying to route a signal SPWR or SGND)
ROUSOM:	SETOM NUMPIN
	SKIPN H,SAVH		;WAS THIS A NAMED RUN
	 PUSHJ P,FUCKUP		;BETTER BE
	SETZM LOSFLG
	MOVEI G,PNTBL-1
	MOVEI F,MAXP
	FETCH(H,H,WPIN)
	JUMPE H,ROUPGW
ROUPG5:	FETCH(T,H,PBIT)
	TRNN T,DUP
	TROE T,PTMP1
	 JRST ROUPG6
	STORE(T,H,PBIT)
	PUSHJ P,NAMMAP			;MAP INTO SOCKET PIN
	 JRST [	TLO TTT,RERPIN
		MOVEI T,RFBAD
		MOVEM T,LOSFLG
		JRST .+1]
	MOVE C,A
	PUSHJ P,ADDPIN
ROUPG6:	FETCH(H,H,NXTP)
	JUMPN H,ROUPG5
	PUSHJ P,DUMPIT
ROUPGW:	MOVE H,SAVH
	MOVE W,SAVW
	POPJ P,

ROUEST:	MOVEI T,-PNTBL(G)
	HRLZM T,ENDS
ROUES1:	HRLI TT,-1(T)
	HRRI TT,1(T)
	MOVEM TT,RUNLST(T)
	MOVSI TT,RERPIN
	IORM TT,PNTBL(T)	;FLAG ALL PINS AS ERRORS
	SOJGE T,ROUES1
	HLLOS RUNLST-PNTBL(G)
	POPJ P,

ROUPGE:	OUTSTR[ASCIZ/ERROR RETURN FROM WIRSTP OR WIRSTE AT ROUPG!
/]
	POPJ P,

;FNDONE - coroutine to generate all pins connecting to pwr or gnd
;	IFN 0,<first searches all DIP definitions for P/G pins >
;	then searches the wire (H) which should be GND, +5.0V, etc.
;	returns:
;	  A=	card pin-spec to wire pin to (flags+pin#,,slot#)
;	  TTT=	Router flags (RPGPIN,...)
;	  C=	pin-spec that needs to be wired to PWR/GND
;	  H =	Pin that got this PWR,GND pin (Dip pin if RPGPIN)

FNDONE:	AOS (P)
IFN 0,<				;SINCE THE ADVENT OF INVENTED SIGNAL NAMES FOR PWR,GND
				;WE SHOULDN'T NEED THIS FIRST PART
	SKIPN FBIT
	 JRST FNDRUN		;NO DIP PINS, JUST DO RUN
	MOVE W,SAVW		;GET WIRE LIST HEADER POINTER
	FETCH(W,W,WBDY)		;BODY POINTER - search occupied DIP slots
	JUMPE W,FNDRUN		;ANY?
	SETZM LSLOT		;NO LAST SLOT YET
ROUP12:	FETCH(T,W,BLOC)		;BODY LOCATION
	JUMPE T,ROUPG9		;ANY?
	CAMN T,LSLOT
	 JRST ROUPG9
	FETCH(H,W,DIPT)		;GET DIP TYPE
	JUMPE H,ROUPG9
	MOVEM T,LSLOT		;NEW LOCATION
	MOVEI H,RADDR(H,DPIN,DPNXT)
	JRST ROUP11

ROUP10:	FETCH(T,H,DPBIT)	;GET TYPE BITS
	TDNN T,FBIT		;IS IT ONE WE WANT?
	 JRST ROUP11
	FETCH(TT,H,DPNM)
	MOVE B,W		;BODY POINTER
	PUSHJ P,PNAMEP
	 JRST ROUP11		;NEXT PIN
	MOVE C,A
	FETCH(B,H,LLOW)		;IN CASE THIS IS PWR PIN, WE NEED VOLTAGE
	PUSHJ P,@FDSP		;FIND THE CARD PIN
	JUMPE A,ROUP11		; NONE!!
	MOVSI TTT,RPGPIN	;MARK AS GENERATED PIN
	PUSHJ P,@(P)		;CALL AS CO-ROUTINE
ROUP11:	FETCH(H,H,DPNXT)	;CHECK ALL PINS
	JUMPN H,ROUP10
ROUPG9:	FETCH(W,W,NXTB)		;CHECK ALL BODIES
	JUMPN W,ROUP12
>;IFN 0

FNDRUN:	SKIPN H,SAVH		;GET RUN POINTER
	 JRST FNDNRN		;NONE
	FETCH(H,H,WPIN)
	JUMPE H,FNDNRN
FNDRN2:	FETCH(TTT,H,PBIT)
	TRNE TTT,DUP
	 JRST FNDRN1
	PUSHJ P,NAMMAP		;TRY NAMING IT
	 JRST FNDRN1		;NO
	MOVE E,TTT		;SAVE ROUTE FLAGS
	MOVE C,A
	MOVE B,SAVH		;GET SIGNAL NAME
	FETCH(B,B,WVOL)		;GET VOLTS IN CASE WE'RE LOOKING FOR PWR PIN
	PUSHJ P,@FDSP		;FIND ITS CARD PIN
	JUMPE A,FNDRN1		;DIDN'T GET ONE
	MOVE TTT,E
	PUSHJ P,@(P)
FNDRN1:	FETCH(H,H,NXTP)
	JUMPN H,FNDRN2
FNDNRN:	SOS (P)			;TAKE OFF SKIP RETURN
	POPJ P,			;NO MORE

;		SUBR TO DO PWR AND GND RUNS FIRST
;Looks for all signals that are SPWR or SGND.
PGSPEC:	MOVEM T,PGDSP
	MOVEI T,SGND
	PUSHJ P,PGSPC1
	MOVEI T,SPWR
PGSPC1:	MOVEM T,PGBIT
	MOVEI H,RADDR(W,WIRES,ALPH)
	JRST PGSPC2

PGSPC3:	FETCH(T,H,WBIT)
	TRNN T,NAM2ND		;ONLY HEADER BLOCK PLEASE
	TDNN T,PGBIT		;FOUND ONE?
	 JRST PGSPC2
	SKIPN ISRAY
	 JRST [	SKIPL LINCNT
		 PUSHJ P,PUTHDR
		MOVE A,H
		PUSHJ P,GCANON
		PUTSIG ADDR(A,SPNT)
		JRST .+1]
	PUSH P,H
	HLRZ T,PGDSP
	PUSHJ P,(T)		;ROUTE ALL THESE
	POP P,H
PGSPC2:	FETCH(H,H,ALPH)
	JUMPN H,PGSPC3
IFN 0,<				;ALL DIP PWR REQUIREMENTS SHOULD BE ON SIGNAL NAMES
	HRRZ T,PGDSP
	JRST (T)		;DISPATCH TO NOT FOUND ROUTINE
>;IFN 0
	POPJ P,

IFN 0,<
PGSIG:	SKIPL LINCNT
	PUSHJ P,PUTHDR
PGSIG0:	MOVE T,PGBIT
	TRNN T,SPWR
	JRST [	PUTSTR[ASCIZ/GND/]
		POPJ P,]
	PUTSTR[ASCIZ/PWR/]
	POPJ P,
>;IFN 0
SUBTTL	'WLR'		ROUTING SUBR FOR WIRE LIST OUTPUT

;HERE TO PRINT ERROR MESSAGE ON TTY IF RUN NOT ROUTED FOR SOME REASON

ROUNPN:	PUSHJ P,RAYRNR
	ERRSTR 0,@RFERR(T)
	POPJ P,

RAYRNR:	OUTSTR ADDR(H,SPNT)
	OUTSTR [ASCIZ / RUN NOT ROUTED! - /]
	OUTSTR @RFERR(T)
	OUTSTR [ASCIZ /
/]
	MOVEI TT,1
	LSH TT,(T)
	TDNE TT,[RFUCK]		;INTERNAL ROUTER ERROR?
	 PUSHJ P,FUCKUP
	PUSH P,T		;ERROR CODE
	PUSHJ P,@WINDSP		;PRINT RUN
	POP P,T
	POPJ P,

ROUPNT:	MOVE G,H
	PUSHJ P,LOPSET		;SETUP FOR WIRE PRINT
	MOVE T,FBIT
	TRNE T,PWR
	 AOS NPWR		;MAKE THIS RUN PRINT
	TRNE T,GND
	 AOS NGND		;ALSO THIS ONE
	SETZM INCHES		;CLEAR TOTAL WIRE LENGTH
	MOVE T,NUMPIN		;GET NUMBER OF PINS IN RUN
	TRNE T,1		;ODD OR EVEN? (0 IS ODD!)
	 SKIPA T,[3]		;EVEN, START AT 3 (Z 1)
	MOVEI T,2		;ODD, START AT 2 (Z 2)
	MOVEM T,ZLEVN
	HRRZ G,ENDS		;START AT THIS END
ROUTIO:	HRLM G,(P)		;SAVE INDEX INTO PNTBL
	MOVEI T,4
	SOSGE NUMPIN		;LAST PIN?
	 MOVEM T,ZLEVN		;SET END Z LEVEL CODE
	HLRZ T,(P)
	HLRE B,RUNLST(T)	;GET LAST PIN
	JUMPL B,[SETZM WIRELN	;NO WIRE LENGTH ON FIRST PIN
		JRST ROUTDO]	;AND PRINT LAST PIN
	HRRZ C,G
	PUSHJ P,DSTSTR		;CALC AND STORE DIST IN WIRELN
ROUTDO:	MOVSI T,RPGPIN
	TDNE T,PNTBL(G)		;CHECK IF PIN HAS PIN BLOCK
	 JRST RPGPNT		;NO, GENERATED FROM DIP DEF
	HRRZ G,PNTBL(G)
	PUSHJ P,WIRLP0
ROUTDN:	HLRZ G,(P)
	HRRE G,RUNLST(G)
	JUMPGE G,ROUTIO
	SKIPE G,SAVH
	 JRST FINWIR
	SKIPE LCOUNT
	 CRLF
	SKIPE T,INCHES
	CAMN T,WIRELN
	 JRST NONWLN
	MOVEM T,WIRELN
	MOVEI A,=48
	PUSHJ P,FILL
	PUSHJ P,DOWLEN
NONWLN:	CRLF
	POPJ P,

; Print pin, but it is without signal name, a PWR pin on DIP
RPGPNT:	MOVE T,LCOUNT
	CAIL T,8
	 CRLF
	PUTBYT 11
	MOVE A,PNTBL1(G)
	PUSHJ P,PINBIT
	TLNE A,PWR		;IS THIS A PWR PIN?
	 AOS NPWR
	TLNE A,GND		;HOW ABOUT GROUND?
	 AOS NGND
	SETZM TCOUNT
	PUSHJ P,LOCPIN		;CALL CARD SUBR TO PRINT
	SETZ T,			;AVOID STAR
	PUSHJ P,PTAB
	SKIPN WIRELN
	 JRST ROUTDN
	MOVEI A,=48
	PUSHJ P,FILL
	PUSHJ P,DOWLEN
	JRST ROUTDN


DSTSTR:	CAMG B,C
	EXCH B,C
	HRRZ T,@PTRTB1(B)	;GET DISTANCE FROM THIS PIN TO NEXT
	MOVEM T,WIRELN		;AND STORE HERE FOR PRINT
	JUMPE T,CPOPJ
	MOVSI TT,RERPIN		;ERROR BIT
	TDNN TT,PNTBL(B)
	TDNE TT,PNTBL(C)
	JRST [	SETZM WIRELN	;IF ONE IN ERROR, FLUSH THIS WIRE
		POPJ P,]
	ADDM T,INCHES
	ADDM T,TINCHS
	AOS NWIRES		;COUNT ANOTHER WIRE
	POPJ P,

NOITS,<
DOWLEN:	MOVE T,WIRELN			;YES, ANY WIRE?
	IDIV T,FRACTN			;MAKE IT INCHES
	PUSH P,TT			;SAVE THE FRACTION
	PUSHJ P,DECOUT			;AND PRINT
	POP P,T
	MOVE TT,FRACTN
	CAIN TT,=10
	JRST [	PUTBYT "."
		PUTBYT "0"(T)
		POPJ P,]
	CAIN TT,=100
	JRST [	PUTBYT "."
		IDIVI T,=10
		PUTBYT "0"(T)
		PUTBYT "0"(TT)
		POPJ P,]
	JUMPE T,CPOPJ
	PUTBYT "+"
	PUSHJ P,DECOUT
	PUTBYT "/"
	MOVE T,FRACTN
	JRST DECOUT
>;NOITS
ITS,<
DOWLEN:	MOVEI T,=1000
	IDIV T,FRACTN
	MOVE TTT,T		;YES, I KNOW ITS A CONSTANT
	IMUL T,WIRELN		;DO THE FIGURING IN THOUSANDTHS OF INCHES
	SUB T,POSTMG		;SUBTRACT OFF POST MARGIN
	MOVE TT,T
	SUB TT,WRAPMG		;THE REAL DISTANCE BETWEEN PINS
	CAMG TT,TTT		;ARE PINS NEXT TO EACH OTHER?
	JRST [	PUTSTR [ASCIZ /BARE/]
		POPJ P,]
	IDIVI T,=1000		;LENGTH IN INCHES
	PUSH P,TT
	SKIPE T
	PUSHJ P,DECOUT		;PRINT INCHES
	PUTBYT "."
	POP P,T
	IDIVI T,=100		;PRINT TENTH
	PUTBYT "0"(T)
	POPJ P,
>;ITS
SUBTTL	'WLZ'		ROUTER Z LEVEL OUTPUT SETUP
ZLEVP:	SKIPN ISWW
	 JRST NXWW
	MOVE L,DEFLST
	PUSHJ P,LSTGET		;NOW ASK FOR PARTICULAR CARD!
	POPJ P,
	FETCH(T,W,WIRES)
	JUMPE T,[OUTSTR[ASCIZ/NO WIRES!
/]
		POPJ P,]
	MOVSI T,'WLZ'		;WIRE LIST Z LEVEL FILE EXTENSION
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	POPJ P,
	PUSHJ P,FILLST
	PUTHDR
	SETZM NWIRES
	SETZM TINCHS
	SETZM ISRAY
	MOVEI T,WLZMAR
	MOVEM T,MARGIN
	MOVEI T,[ASCIZ/	WRAP LIST -- PWR AND GND -- Z LEVEL 1
FROM........TO..........WIRE...CHECK...LENGTH....SIGNAL NAME/]
	MOVEM T,HEADER
	SETZM LINCNT
	TLZ TFLG
	MOVE T,[PGZY,,FUCKUP]
	PUSHJ P,PGSPEC
	MOVEI T,[ASCIZ/	WRAP LIST -- PWR AND GND -- Z LEVEL 2
FROM........TO..........WIRE...CHECK...LENGTH....SIGNAL NAME/]
	MOVEM T,HEADER
	SETZM LINCNT
	TLO TFLG
	MOVE T,[PGZY,,FUCKUP]
	PUSHJ P,PGSPEC
	MOVEI T,[ASCIZ/		WRAP LIST -- Z LEVEL 1
FROM........TO..........WIRE...CHECK...LENGTH....SIGNAL NAME/]
	MOVEM T,HEADER
	SETZM PGBIT
	SETZM LINCNT
	TLZ TFLG		;FLAG TO DO Z LEVEL 1
ZLEVPN:	FETCH(H,W,WIRES)
ZLEVP0:	FETCH(T,H,WBIT)
	TRNE T,NAM2ND!WNULL!WSINGL!SNC!SPWR!SGND
	 JRST ZLEVP1
	FETCH(G,H,WPIN)
	PUSHJ P,ROUWR2		;Route, but don't print router errors
ZLEVP1:	FETCH(H,H,ALPH)
	JUMPN H,ZLEVP0
	TLOE TFLG
	 JRST ZLEVPE
	MOVEI T,[ASCIZ/		WRAP LIST -- Z LEVEL 2
FROM........TO..........WIRE...CHECK...LENGTH....SIGNAL NAME/]
	MOVEM T,HEADER
	SETZM LINCNT
	SETZM NRUNS		;COUNT RUNS ONLY ON Z 2
	JRST ZLEVPN

ZLEVPE:	RELEAS LST,
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUSHJ P,PTOTS		;PRINT TOTALS ON TTY
	POPJ P,
;		Z LEVEL PRINT ROUTINE
ZLEVPW:	SETZM INCHES
	HRRZ G,ENDS		;GET AN END
	MOVE T,NUMPIN		;GET NUMBER OF PINS -1
	TRNN T,1		;SKIP IF EVEN NUMBER OF PINS
	TLOA SEMFLG		;FIRST IS 1-2
	TLZ SEMFLG		;FIRST IS NOT 1-2
	TLNE TFLG		;LEVEL 1 OR 2? (OFF FOR 1)
	TRCA T,1		;LEVEL 2, INVERT SENSE OF TEST
	TLZ SEMFLG		;LEVEL 1, CAN'T BE 1-2
	TRNN T,1		;EVEN OR ODD (0 IS ODD)
	HRRE G,RUNLST(G)	;ODD, START WITH NEXT PIN IN RUN
	TRZ FLAG		;NOTE FIRST PIN OF RUN
ZLEVPA:	HRRE F,RUNLST(G)	;GET ONE FOLLOWING US
	JUMPL F,CPOPJ		;QUIT IF NO NEXT
	MOVE B,G
	MOVE C,F
	PUSHJ P,DSTSTR
	SKIPN WIRELN		;ANY WIRE HERE?
	JRST ZLEVPD
	TROE FLAG		;ANY PINS OF THIS WIRE OUT YET?
	JRST ZLEVPB
	SKIPL LINCNT
	PUSHJ P,PUTHDR
ZLEVPB:	CRLF			;KEEP THEM SEPERATED
	MOVE E,G
	PUSHJ P,PLCPNT
	MOVE E,F
	PUSHJ P,PLCPNT
	PUTSTR[ASCIZ/( )....( )     /]
	SETZM TCOUNT
	PUSHJ P,DOWLEN
	MOVEI A,=12
	SUB A,TCOUNT
	PUTBYT "."
	SOJG A,.-1
	PUTSIG ADDR(H,SPNT)
	CRLF
ZLEVPD:	HRRE G,RUNLST(F)
	JUMPGE G,ZLEVPA
	POPJ P,

;PLCPNT - PRINT PIN LOCATION
PLCPNT:	SETZM TCOUNT
	MOVSI T,RPGPIN
	TDNE T,PNTBL(E)
	 JRST [	MOVE A,PNTBL1(E)	;A SOCKET PIN GENERATED TO WIRE TO
		PUSHJ P,LOCPIN
		JRST PLCPN3]
	HRRZ E,PNTBL(E)
	FETCH(D,E,PBDY)		;D GETS BODY POINTER
	FETCH(A,D,BLOC)
	FETCH(T,E,PINN)
	HRLI A,(T)
	FETCH(T,D,BBIT)
	TRNN T,CBODY
	 JRST PLCPN1
	AOS NCONS
	PUSHJ P,LOCPNW
	JRST PLCPN3

PLCPN1:	PUSH P,B
	FETCH(B,D,BPAK)
	PUSHJ P,LOCPNM
	POP P,B
PLCPN3:	TLZE SEMFLG
STAN,<	PUTBYT "" >
NOSTAN,<PUTBYT "\" >
	MOVEI A,=12
	SUB A,TCOUNT
	PUTBYT "."
	SOJG A,.-1
	POPJ P,

;SUBTTL RAYTHEON OUTPUT STUFF

SUBTTL	'RAY'		ROUTER RAYTHEON WIRE WRAP OUTPUT "TO-TO" FORMAT
RAYTT:	SETZM AUGFORM		;Not AUGAT format file
	MOVE L,DEFLST
	PUSHJ P,LSTGET		;NOW ASK FOR PARTICULAR CARD!
	POPJ P,
	FETCH(T,W,WIRES)
	JUMPE T,[OUTSTR[ASCIZ/NO WIRES!
/]
		POPJ P,]
	MOVSI T,'WTT'		;RAYTHEON WIRE WRAP EXTENSION
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	 POPJ P,
	MOVE T,[PUSHJ P,F4OUT]	;FLUSH TABS, SPECIAL CHARS
	MOVEM T,PUTCHR
	SETZM NRUNS
	SETZM NWIRES
	SETZM TINCHS
	SETZM MARGIN		;NO MARGIN
	SETZM LINCNT
	SETOM ISRAY
	MOVE T,[PGRAYY,,FUCKUP]	;ROUTE AND PRINT POWER AND GROUND
	PUSHJ P,PGSPEC
	SETZM PGBIT		;PRINT SIGNAL NAMES WHERE POSSIBLE
	FETCH(H,W,WIRES)
RAYP0:	FETCH(T,H,WBIT)
	TRNE T,NAM2ND!WNULL!WSINGL!SNC!SPWR!SGND
	JRST RAYP1
	FETCH(G,H,WPIN)
	PUSHJ P,PGRAYY		;ROUTE AND PRINT NORMAL RUN
RAYP1:	FETCH(H,H,ALPH)
	JUMPN H,RAYP0
	RELEAS LST,		;THAT'S ALL FOLKS!
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUSHJ P,PTOTS		;PRINT TOTALS ON TTY
	POPJ P,

;RAYTHEON NORMAL ROUTER SETUP

PGRAYY:	MOVEI T,RAYPW
	MOVEI TT,RAYRNR		;PRINT RUN NOT ROUTED ON TTY
	SETZM FASRAY
	JRST ROUWIR

;SUBTTL RAYTHEON OUTPUT STUFF

SUBTTL	'RAY'		ROUTER RAYTHEON WIRE WRAP OUTPUT "FROM-TO" FORMAT

AUGP:	SETOM AUGFORM
	JRST RAYP10

RAYP:	SETZM AUGFORM
RAYP10:	MOVE L,DEFLST
	PUSHJ P,LSTGET		;NOW ASK FOR PARTICULAR CARD!
	POPJ P,
	FETCH(T,W,WIRES)
	JUMPE T,[OUTSTR[ASCIZ/NO WIRES!
/]
		POPJ P,]
	MOVSI T,'RAY'		;RAYTHEON WIRE WRAP EXTENSION
	SKIPE AUGFORM	
	 MOVSI T,'AUG'
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	 POPJ P,
	MOVE T,[PUSHJ P,F4OUT]	;FLUSH TABS, SPECIAL CHARS
	MOVEM T,PUTCHR
	SETZM NRUNS
	SETZM NWIRES
	SETZM TINCHS
	SETZM MARGIN		;NO MARGIN
	SETZM LINCNT
	SETOM ISRAY
	MOVE T,[PGWFTY,,FUCKUP]	;ROUTE AND PRINT POWER AND GROUND
	PUSHJ P,PGSPEC
	SETZM PGBIT		;PRINT SIGNAL NAMES WHERE POSSIBLE
	FETCH(H,W,WIRES)
RAYFT0:	FETCH(T,H,WBIT)
	TRNE T,NAM2ND!WNULL!WSINGL!SNC!SPWR!SGND
	JRST RAYFT1
	FETCH(G,H,WPIN)
	PUSHJ P,PGWFTY		;ROUTE AND PRINT NORMAL RUN
RAYFT1:	FETCH(H,H,ALPH)
	JUMPN H,RAYFT0
	RELEAS LST,		;THAT'S ALL FOLKS!
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUSHJ P,PTOTS		;PRINT TOTALS ON TTY
	POPJ P,

;RAYTHEON NORMAL ROUTER SETUP

PGWFTY:	MOVEI T,RAYFW
	MOVEI TT,RAYRNR
	SETZM FASRAY
	JRST ROUWIR

;PRINT RUN IN CARD IMAGE FORMAT

LVLCOL__=68	;THE COLUMN USED TO INDICATE LEVEL OF WRAP
LVLAUG__=55	;  " FOR AUGAT FORMAT

RAYMAX__=17	;LONGEST WIRE RAYTHEON MACHINE CAN WRAP IS 24" (CITY BLOCK DISTANCE)
		;16.97=24*(SQRT(2)/2)
RAYNCH__=12	;MAX OF 12. CHARS IN SIGNAL NAME

;TABS TO CARD COLUMN

DEFINE RAYTAB (COLUM)
<	MOVEI A,COLUM-1
	CAMG A,LCOUNT
	JRST .+3
	PUTBYT " "
	JRST .-3
>

RAYFW:	SETZM LCOUNT
	SETZM INCHES
	SETZM RAYLVL		;KEEP TRACK OF LEVEL OF WIRE
	AOS RAYLVL		;    AND START WIRING ON LEVEL 1
	HRRZ G,ENDS		;THE BEGINING OF THE RUN
	MOVE T,NUMPIN		;GET NUMBER OF PINS -1
	TRNN T,1		;IS NUMBER OF PINS EVEN OR ODD (ODD IS 0)
	 JRST [	HRRE G,RUNLST(G)	;ODD, START WITH NEXT PIN IN RUN
		PUSHJ P,RAYPA
		HRRE G,ENDS		;END OF WIRE
		HRRE F,RUNLST(G)	;OTHER END OF WIRE
		MOVEI B,2		;THIS WIRE IS ON LEVEL 2
		MOVEM B,RAYLVL
		JRST RAYFRM]
RAYPA:	HRRE F,RUNLST(G)	;GET ONE FOLLOWING US
	JUMPL F,CPOPJ		;QUIT IF NO NEXT
	PUSHJ P,RAYFRM		;PRINT LINE FOR THIS WIRE
RAYPB:	HRRE G,RUNLST(F)	;Two pins later, the first pin of next level 1 wire
	JUMPL G,CPOPJ		;JUMP IF NONE THERE
	HRRE F,RUNLST(G)	;OTHER END OF NEXT LEVEL 1 WIRE
	JUMPL F,[JRST 4,.]	;ERROR, LAST WIRE ON RUN SHOULD ALWAYS BE LEVEL 1
	PUSHJ P,RAYFRM
	HLRE F,RUNLST(G)	;Back one pin, the level two wire
	AOS RAYLVL
	PUSHJ P,RAYFRM
	SOS RAYLVL		;THE NEXT WIRE IS PROBABLY LEVEL 1
	HRRE F,RUNLST(G)	;GET F BACK
	JRST RAYPB

;RAYFRM - from,to pins
;G = RUNLST index for first pin of wire
;F = RUNLST index for second pin of wire

RAYFRM:	PUSHJ P,RAYDST		;KEEP TRACK OF RUN LENGTHS
	SKIPE AUGFORM
	 JRST AUGFRM
	RAYTAB (=15)
	MOVE E,G		;ONE END OF THE WIRE
	PUSHJ P,RAYPNT
	MOVE E,F		;THE OTHER END OF THE WIRE
	PUSHJ P,RAYPNT		;PRINT PIN SPECIFICATION
	RAYTAB (=31)
	PUSHJ P,RAYSIG		;PRINT SIGNAL NAME AND RETURN
	RAYTAB (LVLCOL)		;PRINT LEVEL OF WIRE
	MOVE T,RAYLVL
	PUSHJ P,DECOUT
	RAYTAB (=72)
	JRST RAYSEQ		;PRINT CARD SEQUENCE # AND RETURN

AUGFRM:	RAYTAB(=2)
	PUSHJ P,RAYSIG
	RAYTAB(=20)
	MOVE E,G
	PUSHJ P,RAYPNT
	RAYTAB(=40)
	MOVE E,F
	PUSHJ P,RAYPNT
	RAYTAB(LVLAUG)
	MOVE T,RAYLVL
	PUSHJ P,DECOUT
	RAYTAB(=72)
	JRST RAYSEQ

RAYPNT:	MOVE A,PNTBL1(E)	;SOCKET POST LOC
	MOVSI T,RPGPIN		;Count # conn pins,
	TDNE T,PNTBL(E)
	 JRST RAYPN1		; can't be if was a generated pin
	HRRZ E,PNTBL(E)
	FETCH(D,E,PBDY)
	FETCH(T,D,BBIT)
	TRNE T,CBODY		;CONNECTOR PIN?
	 AOS NCONS		;COUNT CONNECTOR PINS ON RUN
RAYPN1:	SKIPE AUGFORM
	 JRST AUGDIP
	JRST RAYDIP		;PRINT PIN IN FORTRAN FORMAT

;Print signal name, truncating to 12 characters if necessary
RAYSIG: MOVEI TTT,ADDR(H,SPNT)		;PRINT THIS SIGNAL NAME
	HRLI TTT,440700			;MAKE IT A BYTE POINTER
	SETZ T,
RAYS2:	ILDB TT,TTT
	SKIPE TT
	 AOJA T,RAYS2
	CAILE T,RAYNCH
	 JRST [
;		OUTSTR ADDR(H,SPNT)
;		OUTSTR [ASCIZ / LONGER THAN 12 CHARACTERS
;/]
		PUTBYT GENCHR		;PRINT "SERIAL NUMBER" INSTEAD OF NAME
		PUTBYT GENCHR		;UNIQUE FROM ANY UNAMED RUNS
		MOVE A,PNTBL1		;USE PIN NAME AS GENERATED SIGNAL NAME
		PUSHJ P,LOCPIN
		JRST RAYFR2]
	SKIPN PGBIT		;IS IT A SIGNAL THAT IS SPLIT UP?
	 JRST RAYFR3
;Print signal as GND1A01 - unique version of GND name
	MOVE A,H
	PUSHJ P,GCANON		;get canonical version of name
	PUTSTR ADDR(A,SPNT)
	MOVE A,PNTBL1		;YES, THEN ADD SOMETHING TO MAKE EACH UNIQUE
	PUSHJ P,LOCPIN
	JRST RAYFR2

RAYFR3:	PUTSTR ADDR(H,SPNT)
RAYFR2:	SKIPN WIRELN		;WIRE IN ERROR?
	 PUTSTR [ASCIZ / **** WIRE IN ERROR/]
	POPJ P,

;GCANON - Get canonical name of wire
;A = wire

GCANON:	FETCH(TT,A,WBIT)
	TRNE TT,NAM2ND
	 FETCH(A,A,WPIN)	;GET REAL HEADER
	MOVE T,A
GCANO1:	FETCH(TT,T,WBIT)
	TRNE TT,SCANON		;Is this the canonical name?
	 JRST [	MOVE A,T
		POPJ P,]
	FETCH(T,T,NNAM)
	JUMPN T,GCANO1
	POPJ P,

;PRINT THE SEQUENCE # OF THE CARD
RAYSEQ:
ITS,<	PUTSTR [ASCIZ /MIT/]	>
CMU,<	PUTSTR [ASCIZ /CMU/]	>
	MOVEI A,5
	MOVEM A,NDIG
	MOVE T,LINCNT
	AOJ T,
	PUSHJ P,NDECOUT
	RAYTAB(=80)
	CRLF
	SETZM TCOUNT		;COUNT CHARACTERS ON LINE
	SETZM LCOUNT
	POPJ P,

;		RAYTHEON WIRE WRAP TO-TO FORMAT PRINTER

RAYPW:	SETZM INCHES
	SETZM LCOUNT		;YOU CAN'T BE TOO CAREFUL
	HRRZ G,ENDS		;GET AN END
RAYPT1:	RAYTAB (=15)
	MOVE E,G
	PUSHJ P,RAYPNT		;PRINT THIS PIN
	PUSHJ P,RAYSIG		;PRINT THE SIGNAL NAME
	PUSHJ P,RAYSEQ		;PRINT THE CARD SEQUENCE #
	HRRE F,RUNLST(G)
	JUMPL F,CPOPJ		;END OF RUN
	PUSHJ P,RAYDST		;LOG THIS WIRE AND TOTAL UP WIRE LENGTH
	MOVE G,F		;ADVANCE TO NEXT PIN
	JRST RAYPT1		;GET NEXT PIN ON RUN

RAYDST:	MOVE B,G		;COMPUTE LENGTH OF WIRE
	MOVE C,F
	PUSHJ P,DSTSTR
	MOVE T,WIRELN
	IDIV T,FRACTN
	SKIPE T			;ANY WIRE HERE?
	CAILE T,RAYMAX		;INSURE THAT WIRE DOES NOT EXCEED MAXIMUM LENGTH
	 CAIA
	  POPJ P,
	;;Run too long, or failed somehow.
	OUTSTR [ASCIZ /LINE #/]
	PUSH P,T
	PUSH P,PUTCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	MOVE T,LINCNT
	SUBI T,1
	PUSHJ P,DECOUT
	POP P,PUTCHR
	POP P,T
	OUTCHR [40]		;THROW IN A SPACE
	OUTSTR ADDR(H,SPNT)	;PRINT SIGNAL NAME
	SKIPN T
	 OUTSTR [ASCIZ / WIRE IN ERROR
/]
	SKIPE T
	 OUTSTR [ASCIZ / POINT TO POINT DISTANCE EXCEEDS 17"
/]
	POPJ P,

SUBTTL	'ANADU'		ROUTER TEXT OUTPUT

ANANO:	SETOM FASRAY		;Quickie, don't actually route the wires
	JRST ANADU9
ANADU:	SETZM FASRAY
ANADU9:	MOVE L,DEFLST
	PUSHJ P,LSTGET		;NOW ASK FOR PARTICULAR CARD!
	 POPJ P,
	FETCH(T,W,WIRES)
	JUMPE T,[OUTSTR[ASCIZ/NO WIRES!
/]
		POPJ P,]
	MOVSI T,'XAN'		;RAYTHEON WIRE WRAP EXTENSION
	MOVEI TT,0		;DATA MODE
	MOVSI TTT,'DSK'
	PUSHJ P,OUTSET
	 POPJ P,
	MOVE T,[PUSHJ P,F4OUT]	;FLUSH TABS, SPECIAL CHARS
	MOVEM T,PUTCHR
	SETZM NRUNS
	SETZM NWIRES
	SETZM TINCHS
	SETZM MARGIN		;NO MARGIN
	SETZM LINCNT
	SETOM ISRAY
	MOVE T,[ANAFTY,,FUCKUP]	;ROUTE AND PRINT POWER AND GROUND
	PUSHJ P,PGSPEC
	SETZM PGBIT		;PRINT SIGNAL NAMES WHERE POSSIBLE
	FETCH(H,W,WIRES)
ANAFT0:	FETCH(T,H,WBIT)
	TRNE T,NAM2ND!WNULL!WSINGL!SNC!SPWR!SGND
	 JRST ANAFT1
	FETCH(G,H,WPIN)
	PUSHJ P,ANAFTY		;ROUTE AND PRINT NORMAL RUN
ANAFT1:	FETCH(H,H,ALPH)
	JUMPN H,ANAFT0
	RELEAS LST,		;THAT'S ALL FOLKS!
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUSHJ P,PTOTS		;PRINT TOTALS ON TTY
	POPJ P,

;RAYTHEON NORMAL ROUTER SETUP

ANAFTY:	MOVEI T,ANAPNT
	MOVEI TT,RAYRNR
	JRST ROUWIR

ANAPNT:	SETZM INCHES
	HRRZ G,ENDS		;GET AN END
	PUTSTR ADDR(H,SPNT)	;PRINT SIGNAL NAME
	SKIPN PGBIT		;IS IT GND OR VCC?
	 JRST ANAPT3
	PUTBYT "-"
	MOVE A,PNTBL1
	PUSHJ P,LOCPIN		;ADD SOMETHING TO MAKE IT UNIQUE
ANAPT3:	PUTSTR [ASCIZ / \ /]	;SEPARATE SIGNAL FROM PINS
ANAPT1:	MOVE A,PNTBL1(G)
	PUSHJ P,LOCPIN		;PRINT PIN NAME
	HRRE F,RUNLST(G)
	JUMPL F,ANAPT2		;END OF RUN
	PUTBYT ","
	PUSHJ P,RAYDST		;LOG THIS WIRE AND TOTAL UP WIRE LENGTH
	MOVE G,F		;ADVANCE TO NEXT PIN
	JRST ANAPT1		;GET NEXT PIN ON RUN

ANAPT2:	CRLF
	POPJ P,

>;ROUTE
