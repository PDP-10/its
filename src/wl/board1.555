;<WIRELIST>BOARD1.FAI.28, 20-NOV-75 11:26:44, EDIT BY HELLIWELL  -*-Midas-*-

MD,<DEFINE MDWL <IFE 0>>
MPC,<DEFINE MDWL <IFN 0>>
MWL,<DEFINE MDWL <IFE 0>>

MWL,<DEFINE STORAGE(A)<>>

MDPC,<	VERSION(LOCS,4)	>

MDPC,<
NOLAY,<
INTERNAL MAPCON,MAPSOC,%%PINN,$$PINN
INTERNAL LCINIT,GETSLT,SLTOUT,GTSLTL,PRNLOC,PRNPIN
INTERNAL CPNMER,CPNSEP,CPNMAP,QUPIN,PINCUE,SLTCUE,BODCUE,CPCUE,PROTOB
INTERNAL BPINPN,PINPLS,RPNAM,CSLTLP,SLTLPN,LOCOUT
INTERNAL GETNOM,CLRNOM,SETNOM,FNDNOM,AVAIL
INTERNAL DEFNOM,LOCTVV,NOMTYP
INTERNAL N2L,L2N,LNAMES,PUTDEC,MAXN2L

MD,<
INTERNAL DEFWW,CLRWW,FNDWW,SETWW,WWTYP,WNAMES
INTERNAL GETBRD,MAPOST,GTCONP,LOCFUK
INTERNAL APACK,PACKNM,CLRPAK,CMPPAK,MATPAK
>;MD
EXTERNAL CPOPJ,CPOPJ1,CPOPJ2,CPOPJ3,POPAJ
EXTERNAL TREADU,PUTFS,GTCHRX, LETTER, FORSOC, FUCKUP,NDIG
ITS,< EXTERNAL .TVOFF,TVMORE >
>;NOLAY
>;MDPC
MWL,<
INTERNAL MAPOST,MAPCON,MAPSOC,%%PINN,$$PINN
INTERNAL LCINIT,GETSLT,SLTOUT,PRNLOC,PRNPIN
INTERNAL CPNMER,CPNSEP,CPNMAP,QUPIN
INTERNAL PINCUE,SLTCUE
INTERNAL BPINPN,RPNAM,LOCOUT
INTERNAL GETNOM,CLRNOM,SETNOM,FNDNOM,AVAIL
INTERNAL DEFNOM,LOCTVV,NOMTYP
INTERNAL N2L,L2N,LNAMES,PUTDEC,MAXN2L

INTERNAL GETLOC,RAYDIP,AUGDIP,CPARTP,SEQLOC,CONGIN,GTSLTT
INTERNAL WBDCUE,CBCUE
INTERNAL DEFWW,CLRWW,FNDWW,SETWW,WWTYP,WNAMES
INTERNAL GETBRD,MAPOST
INTERNAL APACK,PACKNM,MATPAK
INTERNAL PINMAP,PINBIT,BPNPIN,PRBCN,PRCNPN,LOCPNW
INTERNAL LOCPNC,PADPRT,WLOCOUT,LOCPNM,LOCPNP

INTERNAL NROWS,NCOLS,NCLPRG,NRWPRP,DIPSLT,NPADS,PADLET
INTERNAL PADPIN,FRACTN,WRAPMG,POSTMG,NEXTR
INTERNAL MAPRC,WAGGND,ISWW,FGND,FPWR,RPNAMA
INTERNAL WWINIT,MAPPAD,DSTCLC,MAPIT,PAKSIZ,GNDCLR
INTERNAL GNDOUT,VCCOUT

INTERNAL NPACK,PACKPN,PAKSIZ,MAKCPN,WIRGND,LNGRID
INTERNAL LOCPIN,DECOUT,NDECOU,TRPNAM

EXTERNAL CPOPJ,CPOPJ1,CPOPJ2,CPOPJ3,POPAJ
EXTERNAL SLICEL,DECIN,TDECIN,TCOUNT,TFILL,TTFILL
EXTERNAL TREADU,PUTFS,GETCHR, FUCKUP,NDIG

>;MWL


;GENERAL USE MACROS AND DEFINITIONS

DEFINE CHECK(TAG,LENGTH)<
IFN .-TAG-LENGTH,<PRINTS /TAG LOSES
/>
>;CHECK

DEFINE NOTYET(NAME)
<NAME	OUTSTR [ASCIZ /NAME NOT IMPLEMENTED FOR THIS BOARD TYPE!!
/]
	POPJ P,
>

;CONCATINATION
	DEFINE CAT $ (A,B)
<	A$B
>

;HERE WE DEFINE MACROS SO EACH BOARD AND NOMENCLATURE FILE DEFINES ITSELF

DEFINE ALLWW
<0,<>>

DEFINE ALLLOCS
<0,<>>

DEFINE .ADD(MACRO,NAME,TABLE)<.ADD1(MACRO,\MACRO,NAME,TABLE)>
;NOTE!! THIS MACRO CAN'T BE IMBEDDED INSIDE BLOCK STRUCTURE,
; BECAUSE IT DOES REDEFINES

DEFINE .ADD1(MACRO,DUMMY,BODY,NAME,TABLE)
<	DEFINE MACRO
<DUMMY,<BODY
	BRDNAM(NAME,TABLE)>>;MACRO
>;ADD1

DEFINE .DONE(MACRO)<.DONE1(MACRO,\MACRO)>

DEFINE .DONE1(MACRO,DUMMY,BODY)
<	DEFINE MACRO
<BODY
>;MACRO
>;DONE1
SUBTTL OVERVIEW
COMMENT 

THIS SOURCE FILE CONTAINS ALL ROUTINES WITH KNOWLEDGE OF
THE EXTERNAL (PRINTED) REPRESENTATION OF LOCATIONS.

THE FOLLOWING ARE THE ONLY CONSTRAINTS ON PICKING LOCATION FORMATS

1)	A BOARD LOCATION (BAY/RACK/SLOT # FOR DEC PDP-10 LIKE STUFF)
	IS 18 BITS (LH), NON-ZERO

2)	A DIP LOCATION IS 18 BITS (RH)
	It used be that at least the low order 12 bits had to be
	non-zero (THE WIRE LISTER USES A DIP LOCATION WITH THESE 12
	BITS ZERO AS A CONNECTOR BODY.  THIS HACK ASSOCIATES
	CONNECTOR PINS ON THE SAME PADDLE OR JACK)
	Now the MAPCON bit in the LH is used to signify a connector pin

3)	A DIP PIN # IS 9 BITS, NON-ZERO. ($$PINN)

4)	A CONNECTOR PIN IS ACTUALLY REPRESENTED TWO WAYS:
	   1)	As a combined 18 bit quantity, representing
		both the jack location and the pin within the
		jack.
	   2)	In a 36 bit form similar to body pins, the connector
		pin# in the LH. MAKCPN can be used to combine
		the conn-jack-locn with the conn-pin# into
		the 18 bit form
		This is the standard form for most of the board specific
		interfaces.
		UMKCPN converts from 18 bit merged form to MAPCON+PINN#,,CPIN-LOC
		Note: UMKCPN and  MAKCPN call board routines CPNSEP, CPNMER.
	Note: The RH of either the 36 or 18 bit format contains the LOC
		information in the same form. I.E. CPNSEP of either RH
		should yield the same LOC, but not necessarily the same
		PIN# (probably 0).
MWL,<
**** PIN-SPEC format ****
	A DIP pin is usually represented by a pair of words:
A:	BITS+PIN#,,DIP-LOCATION
B:	(PACKAGE CODE IF DIP PIN)

	 where DIP-location format is determined by routines in nomenclature type
	 (E.G. MPG21 format is BYTE(3)<panel>(3)<group>(12)<slot> )

**********************************
>;MWL

;BITS IN LH FOR PIN-SPEC
MAPCON__400000		;THIS IS A CON (MUST BE SIGN BIT)
MAPGND__200000		;THIS IS NOW A "G" PIN (for board routines)
MAPPWR__100000		;THIS IS NOW A "V" PIN (for board routines)
CRDPIN__MAPGND!MAPPWR	;THIS IS A SPECIAL PIN ON THE CARD (for board routines)
MAPSOC__40000		;THIS IS NOW A POST-LOC, HAS BEEN MAPPED ONTO BOARD
;777			;PIN # FOR BODIES IN LEFT HALF
%%PINN__221100
$$PINN__777

;KLUDGE!! - The format for V or G pins (on some boards)
;   is pin# 0, with MAPPWR or MAPGND set.  This is ignored
;   outside the board routines themselves.

SUBTTL ROUTINES WHICH ARE A FUNCTION OF THE BOARD TYPE
COMMENT 

LCINIT		BOARD INITIALIZATION
WWINIT	WW	INITIALIZE, IF NECESSARY

GETSLT		READS CARD SPEC (BAY/RACK/SLOT)
GTSLTT	WL	LIKE GETSLT, WITH CHARACTER ALREADY IN CHRREG
SLTOUT		PRINTS CARD SPEC (BAY/RACK/SLOT)

GTSLTL	DPC	READS B-R-S (IF SPECIFIED) AND DIP LOC SPEC (INTO DESTIN)
GETLOC	WL	READS DIP OR CONNECTOR JACK LOC
GTCONP	D	READS CARD SPEC (IF SPECIFIED) AND CONNECTOR PIN
LOCFUK	D	PATCHES UP OLD FORMAT NOMENCLATURE

RAYDIP	WL	PRINTS DIP LOC FOR RAYTHEON OUTPUT (FORTRAN STYLE I8)
PRNLOC		PRINTS SOCKET OR DIP LOC
PRNPIN		PRINTS PIN#
MAPOST	DWL	CONVERTS FROM DIP-PIN-LOC INTO SOCKET PIN LOC (INCLUDING ADAPTOR MAPPING)
MAPIT	WL	CONVERTS POST INTO X,Y,BITS
PAKSIZ	WL	GIVES DIMENSIONS OF PHYSICAL DIP ON THE BOARD, FOR ERROR CHECKING
FPWR	WW	FIND PWR PIN
FGND	WW	FIND GND PIN

CPNMER		MERGE CONNECTOR PIN BODY LOC, WITH PIN #
CPNSEP		SEPARATE CONNECTOR PIN BODY LOC, FROM PIN #
CPNMAP		MAPS CPIN AND CARD-LOC INTO BACKPANEL PIN

QUPIN		CHECKS FOR WILD CONNECTOR BODIES
CONGIN	WL	GENERATE NEXT INVENTED PIN TO REPLACE "U" PINS
SEQLOC	WL	CHECKS FOR SEQUENTIAL LOCATIONS
MAPRC	WW	MAP ROW,COLUMN INTO GENERATED BLOC
MAPPAD	WW	MAP NUMBERS IN T, TT, AND TTT INTO EDGE PIN NAME

CPARTP	WL	PRINTS EDGE PIN TO PARTITION FILE AS NUMBER

DSTCLC	WW	DISTANCE (CITY BLOCK, ...)

GNDCLR	WW	;THESE ARE RANDOM
WAGGND	WW	WAGNER GROUND PIN
GNDOUT	WW	PRINT GROUND PINS
VCCOUT	WW	PRINT POWER PINS

PINCUE		BODY PIN CUE
SLTCUE		BODY SLOT CUE

BODCUE	DPC	BODY LOC CUE
CPCUE	DPC	CONNECTOR PIN CUE
PROTOB	DPC	PROTOTYPE BODY CUE

CBCUE	WL	WIRELISTER CONNECTOR BODY CUE
WBDCUE	WL	WIRELISTER BODY LOC CUE

;ROUTINES NOW IN BOARD1
BPINPN		PRINTS BODY PIN #
PINPLS	DPC	PRINTS DIP PIN # (MAPPED BY PACKAGE NUMBER INTO SOCKET PIN)
RPNAM		READS DEFAULT PIN NAME
CSLTLP	DPC	PRINTS CARD SPEC (IF SPECIFIED) AND CONNECTOR PIN
SLTLPN	DPC	PRINTS CARD SPEC FOLLOWED BY BODY LOC
LOCOUT		PRINTS DIP LOC ON CARD, CHECKS FOR CONN BODIES

BPNPIN	WL	PRINTS CONNECTOR PIN NAME AS SEEN FROM BACKPANEL
RPNAMA	WL	READS PIN ID, IF NUMBER FOLLOWS IMMEDIATELY
TRPNAM	WL	READS DEFAULT PIN ID, FLUSHING LEADING SPACES
WLOCOUT	WL	PRINTS WILD/FRONT/BACK CONNECTOR (IF SPECIFIED) AND DIP LOC
PINMAP	WW	MAP PIN-SPEC(A,B) INTO T=X,,Y
		 POSSIBLY RETURNS NEW PIN-TYPE-BITS IN TT
		 ALSO MAY RETURN DISTANCE TO END OF DIP IN TTT FOR
		 FORCED U FUDGING
PINBIT	WW	

SUBTTL BOARD SPECIFIC TRANSFER VECTOR
;THIS IS THE TRANSFER VECTOR WHICH IS SETUP BY THE BOARD TYPE SETTING COMAND
;THERE IS A SIMILAR OBJECT IN WWC

STORAGE(IMPURE)

LOCSTV__.

LCINIT:	JRST NNOMEN
QUPIN:	JRST NNOMEN
SLTOUT:	JRST NNOMEN
GETSLT:	JRST NNOMEN
PRNLOC:	JRST NNOMEN
PRNPIN:	JRST NNOMEN
CPNSEP:	JRST NNOMEN
CPNMER:	JRST NNOMEN
CPNMAP:	JRST NNOMEN
MDWL,<
MAPOST:	JRST CPOPJ1		;CONVERT FROM DIP-LOC/PIN TO POST
>;MDWL
MDPC,<
GTSLTL:	JRST NNOMEN
MD,<
GTCONP:	JRST NNOMEN
LOCFUK:	JRST NNOMEN
>;MD
>;MDPC

MWL,<
GETLOC:	JRST NNOMEN
RAYDIP:	JRST NNOMEN
CPARTP:	JRST NNOMEN
SEQLOC:	JRST NNOMEN
CONGIN:	JRST NNOMEN
GTSLTT:	JRST NNOMEN
AUGDIP:	JRST NNOMEN
>;MWL
LTVLNJ__.-LOCSTV		;LENGTH OF PART WITH JRST'S
SLTCUE:	[0]			; CUE FOR BOARD SLOT
PINCUE:	[0]			; CUE FOR BOARD PIN
MDPC,<
CPCUE:	[0]			;CUE FOR CONNECTOR PIN
BODCUE:	[0]			;CUE FOR BODY LOC
PROTOB:	[ASCID /LOC/]		;PROTOTYPE FOR BODY LOC
>;MDPC
MWL,<
WBDCUE:	[0]
CBCUE:	[0]
>;MWL

LTVLEN__.-LOCSTV
LTVLEN__LTVLEN

NOMTYP:	ININOM			;INDEX INTO NOMENCLATURE TABLES
MDWL,<
WWTYP:	INIWW			;INDEX INTO BOARD TABLES
>;MDWL

FNDTMP:	0			;FLAG USED IN BOARD NAME SEARCH
SMALL:	0			;SMALLEST DISTANCE BETWEEN WW PINS

STORAGE(PURE)

NNOMEN:	OUTSTR [ASCIZ /SORRY - NO NOMENCLATURE TYPE
/]
	POPJ P,

;TRANSFER VECTOR FOR UNSPECIFIED BOARD

LNOBRD:	REPEAT LTVLNJ
<	JRST NNOMEN
>
	REPEAT LTVLEN-LTVLNJ
<	[0]
>
IFN 0,<				;THIS LOSES???
MDPC,<	ORG LNOBRD+PROTOB-LOCSTV
	[ASCID /LOC/]
>;MDPC
>;IFN 0
	ORG LNOBRD+LTVLEN




SUBTTL	L2N,N2L -- LETTER/NUMBER CONVERSION TABLES

STORAGE(IMPURE)

L2NLEN__200	;LETTER/NUMBER CONVERSION TABLE LENGTHS
N2LLEN__200

;These tables are initialized from the board type.  They
; specify which letters are legal, and what the code stored in
; the packed location word is for the letter.
; Note: This is typically used for both the slot and connector nomenclatures.

L2N:	BLOCK L2NLEN		;LEAVE CONTIGUOUS AND IN THIS ORDER
N2L:	BLOCK N2LLEN
MAXN2L:	0

DEFINE L2N2L (I,J) <
	ORG L2NSUB+"I"
	MDPC,<J+>NNN
IFGE "I"-"A",<
IFLE "I"-"Z",<
;IF LETTER, SET LOWER CASE THE SAME
	ORG L2NSUB+"I"+40
	MDPC,<J+>NNN
>>
	ORG N2LSUB+NNN
	"I"
NNN__NNN+1
>
STORAGE(PURE)
SUBTTL PACKAGE ROUTINES

MDWL,<
;Add strange package types at end,  DIPMODE defaults the package type to
;	the first package found with the right number of pins
;Board routines must also be updated to make package legal in PAKSIZ.
;NOTE!! - When adding new packages, probably you have to change LGLPAK tables
;in board types.

;Fields are:
;	# Pins in dip/sip
;	Package I/O name
;	K. name, if not just K.#pins
;	table pointer,,routine to map pin into post


DEFINE PACKAGES
<	PACK1(0,Null)
	PACK1(2,2 Pin)
	PACK1(4,4 Pin)
	PACK1(6,6 Pin)
	PACK1(8,8 Pin)
	PACK1(10,10 Pin)
	PACK1(12,12 Pin)
	PACK1(14,14 Pin)
	PACK1(16,16 Pin)
	PACK1(18,18 Pin)
	PACK1(20,20 Pin)
	PACK1(22,22 Pin)
	PACK1(24,24 Pin,,BDIP)	;.600 spacing
	PACK1(28,28 Pin,,BDIP)
	PACK1(36,36 Pin,,BDIP)
	PACK1(40,40 Pin,,BDIP)
	PACK1(48,48 Pin,,BDIP)
	PACK1(64,64 Pin,,BDIP)
	PACK1(8,<8 Pin SIP>,8SIP,SIP)
	PACK1(10,<10 Pin SIP>,10SIP,SIP)
	PACK1(22,<22 Pin 622-HG16 Augat adaptor>,622AUG,cpopj)
		;Adaptor for universal boards, which we don't have
	PACK1(24,<24 Pin 624-HG16 Augat adaptor, pin 1 upper-right>,624AUG,<M.624A,,ADAPT>)
	PACK1(24,<24 Pin 624-HG16 pin 1 lower-left>,624XUG,<M.624X,,ADAPT>)
	PACK1(40,<40 Pin 640-HG16 Augat adaptor, pin 1 upper-left>,640AUG,<M.640A,,ADAPT>)
III,<	PACK1(20,<S.GRAY 20 pin to .2" adaptor>,SGR1,cpopj)
	PACK1(24,<S.GRAY 24 pin MUPAC adaptor>,SGR2,<M.SGR2,,ADAPT>)
;	PACK1(24,<24 Pin in 2 vertical sockets>,24iii,<m.24iii,,adapt>)
>;III
;MIT uses home brew adaptors that are different from Augats
ITS,<	PACK1(24,<24 Pin, MIT Adaptor>,24MIT,<MAP24,,ADAPT>)
	PACK1(28,<28 Pin, MIT Adaptor>,28MIT,<MAP28,,ADAPT>)
	PACK1(40,<40 Pin, MIT Adaptor>,40MIT,<MAP40,,ADAPT>)
	PACK1(40,<New 40 Pin, MIT Adaptor>,40NIT,<MAN40,,ADAPT>)
	PACK1(48,<48 Pin, MIT Adaptor>,48MIT,<MAP48,,ADAPT>)
	PACK1(40,<PTTLDL, Vertical Pair Dips, .2" gap>,PTTLDL,<MAP2H,,ADAPT>)
	PACK1(64,<64 Pin, 3x3 Adaptor>,64MIT,<MAP64,,ADAPT>)
>;ITS
>

;Some additional information on adaptor packages..
;1)	minX,minY,maxX,maxY
;	NOTE: Package dimensions are relative to where pin 1 of DIP is mapped to.
;	 as viewed from the DIP side, +Y is UP, +X is right
;	 The outline dimensions are the upper-left, lower right corners of the outline 
;2)	Equivalent # pins of dip adaptor (i.e. what size dip sockets it's made of)
;3)	Horizontal size of dip adaptor (how many more slots it needs)
;4)	Verical size of dip adaptor		"

DEFINE	ADDSOME (LABEL)
<
;;14 pin DIP is slightly longer than rule??
ORG LABEL+K.14			ADDIT(<-=40,=70,=340,-=670>)
;;Weird .400 spacing DIP
ORG LABEL+K.22			ADDIT(<-=40,=40,=440,-=1040>)

ORG LABEL+K.622aug 		ADDIT(<-=40,=40,=340,-=1140>,16)
ORG LABEL+K.624aug 		ADDIT(<-=1340,=180,=180,-=580>,14,3,1)
ORG LABEL+K.624xug 		ADDIT(<-=40,=680,=1380,-=180>,14,3,1)
ORG LABEL+K.640aug 		ADDIT(<-=340,=340,=540,-=1740>,16,2,2)

III,<
ORG LABEL+K.SGR1 		ADDIT(<-=100,=40,=300,-=1140>,16)
ORG LABEL+K.SGR2 		ADDIT(<-=340,=340,=440,-=940>,16)
;ORG LABEL+K.24III 		ADDIT(<-=240,=340,=440,-=1440>,16,1,2)

>;III

ITS,<
		;PIN1 IS MAPPED TO 1ST SOCKET, PIN15 of 16
ORG LABEL+K.24MIT 		ADDIT(<-=1340,=100,=40,-=800>,16,2)
ORG LABEL+K.28MIT 		ADDIT(<-=1340,=100,=40,-=800>,16,2)
ORG LABEL+K.40MIT 		ADDIT(<-=1340,=100,=40,-=800>,16,3)
ORG LABEL+K.40NIT 		ADDIT(<-=1340,=100,=40,-=800>,16,3)
ORG LABEL+K.48MIT 		ADDIT(<-=1340,=100,=40,-=800>,16,4)
		;DIP POSITION IS GIVEN BY PIN 1 OF TOP SOCKET
		;PTTLDL'S FIRST PIN IS PIN4, TOP SOCKET
ORG LABEL+K.PTTLDL 		ADDIT(<-=40,-=300,=340,-=1840>,20,0,1)
		;DIP'S FIRST PIN IS PIN1, 1ST SOCKET
ORG LABEL+K.64MIT 		ADDIT(<-=140,=340,=1440,-=3340>,20,2,2)
>;ITS

ORG LABEL+NPACK
>

;*********  Package names  *********

PACKNM:

INDEX__0
	DEFINE PACK1 $ (PINS,NAME,SNAME)
<	[ASCIZ \NAME\]
	IFIDN <SNAME><><K.$PINS__INDEX;> K.$SNAME__INDEX
	INDEX__INDEX+1
>

	PACKAGES		;RECOGNITION NAME
NPACK__INDEX


;*********  Package # of pins  *********

PACKPN:

	DEFINE PACK1(PINS)
<	=PINS
>

	PACKAGES		;# PINS IN PACKAGE
CHECK PACKPN,NPACK


;********  Package DIP to Socket mapper  *********
MAPDSP:

DEFINE PACK1(PINS,NAME,SNAME,MAPPER)
<IFDIF <MAPPER><><	MAPPER;>DIP
>
	PACKAGES
CHECK MAPDSP,NPACK

;*********  Package outline dimensions  *********
;From pin 1 of DIP/SIP, viewed from DIP side of board.
;Assume most DIP's will butt together without extra .1" gap
;This isn't true of 14 pin DIP's - they overhang about 70 mils,
; and it isn't true of some old 16 pin's.

SIZES:

DEFINE PACK1(PINS,NAME,SNAME,MAPPER)
<..TEM__.
 IFIDN <MAPPER><><FOO(-=40,=40,=340,-<<=PINS/2-1>*=100+=40>)>
 IFIDN <MAPPER><DIP><FOO(-=40,=40,=340,-<<=PINS/2-1>*=100+=40>)>
 IFIDN <MAPPER><BDIP><FOO(-=40,=40,=640,-<<=PINS/2-1>*=100+=40>)>
 IFIDN <MAPPER><SIP><FOO(-=40,=40,=40,-<<=PINS-1>*=100+=40>)>
 IFE ..TEM-.,<0
>
>

DEFINE FOO(X1,Y1,X2,Y2)
< 	[X1,,Y1  X2,,Y2]
>

DEFINE ADDIT (SIZE)
<IFDIF <SIZE><><	FOO(SIZE) >
>

	PACKAGES
	ADDSOME(SIZES)
CHECK SIZES,NPACK

;*********  Package equivalent #PINS DIP size  *********

ADAPSZ:

DEFINE	ADDIT(SIZE,EQV)
<IFDIF <EQV><><	=EQV/2>
>

	BLOCK NPACK
	ADDSOME(ADAPSZ)
CHECK ADAPSZ,NPACK

;*********  Package horizontal DIP size  *********

;The horizontal adder to get the far socket used
; (0 if single socket, + is right from DIP side)

PAKWID:

DEFINE	ADDIT(SIZE,EQV,WIDTH)
<IFDIF <WIDTH><><	=WIDTH>
>
	BLOCK NPACK
	ADDSOME(PAKWID)
CHECK PAKWID,NPACK

;*********  Package vertical DIP size  *********

; (0 if single socket, + is up from DIP side)

PAKHGT:

DEFINE	ADDIT(SIZE,EQV,WIDTH,HEIGHT)
<IFDIF<HEIGHT><><	=HEIGHT>
>
	BLOCK NPACK
	ADDSOME(PAKHGT)
CHECK PAKHGT,NPACK

;*********  Package leg separation (assuming DIP) *********

DIPLEG:	FOR I_1,NPACK
	<=300 >

DEFINE FOO(PAK,SPACING)
<ORG DIPLEG+PAK 	=SPACING
>

	FOR I IN (K.22)
	<FOO(I,400)>

	FOR I IN (K.24,K.28,K.36,K.40,K.48,K.64)
	<FOO(I,600)>

ORG DIPLEG+NPACK

;MATPAK - MATCH PACKAGE NAMES
;T = STRING
;RETURNS
;A = PACKAGE CODE (SKIPS)

MATPAK:	PUSH P,T
	PUSH P,TT
	MOVSI A,-NPACK
MATPA1:	HRRZ TT,PACKNM(A)
	MOVE T,-1(P)
	PUSHJ P,MATONE
	 JRST [AOBJN A,MATPA1		;NO MATCH
		SETZ A,
		JRST MATPOK]
	 JFCL				;NEAR MATCH
	AOS -2(P)
MATPOK:	HRRZS A
	POP P,TT
	POP P,T
	POPJ P,

;MATONE - MATCH STRINGS, IGNORING SPACES, PUNCTUATION
;T = STRING
;TT = ASCIZ
;RETURNS
;	NO MATCH
;	SUBSTRING MATCH
;	EXACT MATCH

MATONE:	HRLI TT,440700
	HRLI T,440700
	AOS T
	PUSH P,A
	PUSH P,B
MATON1:	PUSHJ P,SLRPT
	MOVE B,A
	PUSHJ P,SLRPTT
	JUMPE B,[SKIPN A
		 AOS -2(P)		;EXACT MATCH
		AOS -2(P)		;CLOSE MATCH
		JRST MATOX]
	CAMN A,B
	 JUMPN A,MATON1
MATOX:	POP P,B
	POP P,A
	POPJ P,

SLRPT:	TLNE T,760000
	 JRST SLRPT1
	SETZ A,
	HRR T,-1(T)
	TRNN T,-1
	 POPJ P,
SLRPT1:	ILDB A,T
SLRPN:	JUMPE A,CPOPJ
	CAIL A,"a"
	CAILE A,"z"
	 CAIA
	SUBI A,"a"-"A"
	CAIG A,40
	 SOS (P)			;TRY AGAIN
	CAIN A,","
	 SOS (P)
	POPJ P,

SLRPTT:	ILDB A,TT
	JRST SLRPN




;CMPPAK, CLRPAK, APACK
;A = BODY (0 LH), TYPE (-1 LH)
;B = PROP BLOCK
;C = VALUE OF "PACKAGE"

MD,<
CMPPAK:	PUSH P,A
	PUSH P,T
	MOVE T,C
	PUSHJ P,MATPAK
	 JRST CMPPA1
	AOS -2(P)
	MOVE T,-1(P)
	SKIPL T
	 STORE(A,T,BPAK)
	SKIPGE T
	 STORE(A,T,TPAK)
CMPPA1:	POP P,T
	POP P,A
	POPJ P,

CLRPAK:	SKIPL A
	 CLEAR(A,BPAK)
	SKIPGE A
	 CLEAR(A,TPAK)
	POPJ P,
>;MD

APACK:	MOVSI A,-NPACK
MDPC,<	TVOFF >
APACKL:	OUTSTR @PACKNM(A)
	OUTSTR [ASCIZ /
/]
	AOBJN A,APACKL
MDPC,<	TVON >
	POPJ P,
>;MDWL

SUBTTL	PROGRAM DEPENDENT IO CONTROL

MWL,<
	CHRREG__TTT
	NUMREG__A
	DEFINE DESTIN<SLICEL>
	DEFINE GETCH <	XCT GETCHR
			 JFCL
>
	DEFINE GETNUM <	PUSHJ P,DECIN
			 JFCL
>				;READ NUMBER INTO A, TTT RETURNS LAST CHAR
	DEFINE TGETNUM < PUSHJ P,TDECIN
			  JFCL
>				;READ NUMBER, FIRST CHAR ALREADY IN TTT
>;MWL

MDPC,<	CHRREG__C
	NUMREG__T
	DEFINE DESTIN<LETTER>

DEFINE GETCH <	XCT GTCHRX
>

DEFINE GETNUM <	PUSHJ P,GETDEC
>

DEFINE TGETNUM < PUSHJ P,TGETDC
>

TGETDC:	SETZ NUMREG,
	JRST GTDEC2

GETDEC:	SETZ NUMREG,
GTDEC1:	GETCH
GTDEC2:	CAIL CHRREG,"0"
	CAILE CHRREG,"9"
	POPJ P,
	IMULI NUMREG,=10
	ADDI NUMREG,-"0"(CHRREG)
	JRST GTDEC1
>;MDPC
SUBTTL ROUTINES KNOWN TO THE OUTSIDE WORLD

COMMENT 

FNDWW		FIND BOARD TYPE FOR WIRELISTER
FNDNOM		FIND NOMENCLATURE TYPE
GETBRD		SET BOARD TYPE FROM TTY
GETNOM		SET NOMENCLATURE FROM TTY
CLRNOM		CLEAR NOMEN
SETNOM		SETUP TRANSFER VECTORS AND CONVERSION TABLES
AVAIL		LIST AVAILABLE NOMENCLATURES


; ROUTINES TO SET UP THE BOARD TYPE

;TAKES POINTER TO STRING IN FREE STORAGE IN B
;XWD -LENGTH,NAME TABLE IN C

MDWL,<
FNDWW:	SKIPA C,[XWD -NWW,WNAMES]
>;MDWL
FNDNOM:	MOVE C,[XWD -NLOCS,LNAMES]
	PUSH P,B
	SETOM FNDTMP		;CLEAR PARTIAL MATCH STORAGE
	JUMPGE C,FNDBR8		;IN CASE OF EMPTY TABLE
FNDBR1:	MOVE T,(C)		;GET BYTE POINTER
	MOVE B,(P)		;AND POINTER TO STRING
	ADD B,[POINT 7,1]
FNDBR2:	ILDB TT,T		;NEXT CHAR OF BOARD NAME
	TLNE B,760000		;END OF WORD?
	 JRST FNDBR3		;NO
	HRR B,-1(B)
	TRNN B,-1
	 JRST FNDBR4		;END OF SOURCE STRING
FNDBR3:	ILDB TTT,B		;NEXT CHAR OF SOURCE STRING
	JUMPE TTT,FNDBR4	;END OF SOURCE STRING?
	CAMN TTT,TT		;STILL MATCH?
	 JRST FNDBR2		;YES, CONTINUE
FNDBR5:	AOBJN C,FNDBR1		;NO, TRY NEXT BOARD
FNDBR8:	HRRE C,FNDTMP
	SKIPL C
FNDBR7:	 AOS -1(P)
FNDBR6:	POP P,B
	POPJ P,

FNDBR4:	JUMPE TT,[HRRZ C,C
		JRST FNDBR7]	;EXACT MATCH
	SKIPL FNDTMP		;PREVIOUS PARTIAL MATCH?
	 JRST [	SETOM FNDTMP
		HRRZS FNDTMP	;FLAG MULTIPLE PARTIAL MATCHES
		JRST FNDBR5]	;TRY FOR EXACT MATCH
	HRRZM C,FNDTMP
	JRST FNDBR5

;GETS BOARD NAME FROM TTY, LOOKS IT UP, AND SETS IT UP

MDWL,<
GETBRD:
MDPC,<	TLNN M,DSKACT!MACACT	>
	OUTSTR [ASCIZ /BOARD TYPE?/]
	PUSHJ P,TREADU			;DOES CASE CONVERSION
	 POPJ P,			;ALTMODE
MDPC,<	 JRST [	MOVE B,WWTYP		;NULL
		OUTSTR @WNAMES(B)
		POPJ P,]
>;MDPC
MWL,<	 POPJ P,	>
	PUSHJ P,FNDWW				;FIND THAT BOARD TYPE
	 JRST [	PUSHJ P,PUTFS
		OUTSTR [ASCIZ /BOARD NOT FOUND
/]
		POPJ P,]
	PUSHJ P,PUTFS
	MOVEI C,-WNAMES(C)
	HRRZM C,WWTYP
MDPC,<	TLNN M,DSKACT!MACACT	>
	OUTSTR @WNAMES(C)		;TYPE THE BOARD NAME FOR THE PEOPLE
	OUTSTR[ASCIZ/
/]
	PUSHJ P,SETWW		;INITIALIZE W/W STUFF
;Now try to default the Nomenclature from the board type
	MOVSI B,-NLOCS
GETBR1:	HRRZ C,WWTYP
	HRRZ C,WNAMES(C)	;PTR TO BOARD NAME
	HRRZ D,LNAMES(B)	;THIS NOMEN THE SAME?
GETBR2:	MOVE T,(C)
	MOVE TT,(D)
	CAME T,TT
	 JRST [	AOBJN B,GETBR1
		POPJ P,]
	TRNE T,376		;END OF ASCII?
	 AOJA C,[AOJA D,GETBR2]	
	HRRZM B,NOMTYP
	JRST SETNOM

>;MDWL

GETNOM:
MDPC,<	TLNN M,DSKACT!MACACT	>
	OUTSTR [ASCIZ /NOMENCLATURE TYPE?/]
	PUSHJ P,TREADU			;DOES CASE CONVERSION
	 POPJ P,			;ALTMODE
MDPC,<	 JRST [	MOVE B,NOMTYP		;NULL
		OUTSTR @LNAMES(B)
		POPJ P,]
>;MDPC
MWL,<	 POPJ P,	>
	PUSHJ P,FNDNOM			;FIND THAT BOARD TYPE
	 JRST [	PUSHJ P,PUTFS
		OUTSTR [ASCIZ /NOMENCLATURE NOT FOUND
/]
		POPJ P,]
	PUSHJ P,PUTFS
	MOVEI C,-LNAMES(C)
	HRRZM C,NOMTYP
MDPC,<	TLNN M,DSKACT!MACACT	>
	OUTSTR @LNAMES(C)		;TYPE THE BOARD NAME FOR THE PEOPLE
MWL,<	OUTSTR[ASCIZ/
/]
>;MWL
	JRST SETNOM






;GIVEN THE BOARD TYPE IN NOMTYP, SETS UP TRANSFER VECTORS AND CONVERSION TABLES

CLRNOM:	MOVE B,[ININOM]
	MOVEM B,NOMTYP
SETNOM:	MOVE B,NOMTYP
	HRL C,LOCTVV(B)		;SET UP LOCS TRANSFER VECTOR
	HRRI C,LOCSTV
	BLT C,LOCSTV+LTVLEN-1
	SKIPL NOMTYP		;NO SPECIFIC BOARD?
	PUSHJ P,LCINIT		;SET UP LETTER/NUMBER CONVERSION TABLES
	POPJ P,

MDWL,<
CLRWW:	MOVE B,[INIWW]
	MOVEM B,WWTYP
SETWW:
MWL,<	MOVE B,WWTYP
	HRL C,WWCTVV(B)		;SET UP WWC TRANSFER VECTOR
	HRRI C,WWCTV
	BLT C,WWCTV+WTVLEN-1
	SKIPN ISWW		;ONLY WIRE WRAP BOARDS HAVE WWINIT
	POPJ P,
	MOVEI T,=1000
	IDIV T,FRACTN		;CALCULATE SMALLEST POSSIBLE DISTANCE BETWEEN WW PINS
	MOVEM T,SMALL
	PUSHJ P,WWINIT		;WIRE WRAP INITIALIZATION
>;MWL
	POPJ P,
>;MDWL

AVAIL:	MOVSI A,-NLOCS
MDPC,<	TVOFF >
	OUTSTR [ASCIZ /NOMENCLATURE TYPES:
/]
AVAIL1:	OUTSTR @LNAMES(A)
	OUTSTR [ASCIZ /
/]
	AOBJN A,AVAIL1
MDWL,<	MOVSI A,-NWW
	JUMPGE A,CPOPJ		;DONE IF NO BOARDS
	OUTSTR [ASCIZ /

BOARD TYPES:
/]
AVAIL2:	OUTSTR @WNAMES(A)
	OUTSTR [ASCIZ /
/]
	AOBJN A,AVAIL2
>;MDWL
MDPC,<	TVON >
	POPJ P,




SUBTTL	PUTDEC,NPUTDEC -- DECIMAL OUTPUT ROUTINES

MWL,<DECOUT:>
PUTDEC:	SETZM NDIG
MWL,<NDECOUT:>
NPUTDEC:SKIPGE T
	PUTBYT "-"
	MOVM T,T
PUTDC1:	IDIVI T,=10
	HRLM TT,(P)
	SOSG NDIG
	JUMPE T,.+2
	PUSHJ P,PUTDC1
	HLRZ TT,(P)
	PUTBYT "0"(TT)
	POPJ P,


SUBTTL WIRE WRAP BOARD ROUTINES

MWL,<

DEFINE SETPAD(NPADS)
<	IFL MAXPAD-<NPADS>,<PRINTS /MAXPAD NOT LARGE ENOUGH.
/>
	NPADS
>

DEFINE CHECK(TAG,LENGTH)<
IFN .-TAG-LENGTH,<PRINTS /TAG LOSES
/>
>;CHECK

WIRGND:	-1		;DEFAULT WIRE GROUNDS FOR DEC BOARDS
LNGRID:	0		;-1 ENABLES LETTER NUMBER GRID

WWCTV:

ISWW:	0			;FLAGS IF WIRE WRAP OR PC BOARD
WWINIT:	JRST NBOARD		;THE WIRE WRAP TRANSFER VECTOR
MAPRC:	JRST NBOARD		;MAP ROW/COLS INTO GENERATED LOCS
MAPPAD:	JRST NBOARD		;MAP PADDLE/LETTER/SIDE INTO CONN LOCS
DSTCLC:	JRST NBOARD		;DISTANCE CALC ROUTINE
FPWR:	JRST NBOARD		;FIND A POST WITH POWER
FGND:	JRST NBOARD		;FIND A POST WITH GND
MAPIT:	JRST NBOARD		;CONVERT POST INTO X,Y,BITS
PAKSIZ:	JRST NBOARD		;FIND DIMENSION OF DIP OUTLINE
GNDCLR:	JRST NBOARD		;?
WAGGND:	JRST NBOARD		;?
GNDOUT:	JRST NBOARD		;?
VCCOUT:	JRST NBOARD		;?
	NWBLEN__.-WWINIT
NROWS:	0			;# OF ROWS FOR UML
NCOLS:	0			;NO OF COLS "
NCLPRG:	0			;NO COLS PER GROUP ", # UMLCOLS TO PRINT AT ONCE
NRWPRP:	0			;NO ROWS PER PAGE (0 IS DEFAULT MAX)
DIPSLT:	0			;TOTAL # OF DIPS TO PRINT UML
NPADS:	0			;NO OF PADDLES (UML)
PADLET:	0			;NO OF LETTERS PER PADDLE (UML)
PADPIN:	0			;NO OF PINS PER LETTER (UML)
FRACTN: 0			;WIRE LENGTH FRACTION
WRAPMG:	0			;ADDITIONAL WIRE LENGTH FOR INSULATION AROUND POST
POSTMG:	0			;ADDITIONAL WIRE LENGTH FOR BARE WIRE  AROUND POST
NEXTR:	0			;CLEARANCE BETWEEN PINS IN ADJACENT SOCKET ROWS
	NW0LEN__.-WWINIT-NWBLEN
WTVLEN__.-WWCTV
WTVLEN__WTVLEN

WNOBRD:	0
	REPEAT NWBLEN
<	JRST NBOARD
>
	REPEAT NW0LEN
<	0
>
	CHECK(WNOBRD,WTVLEN)

NBOARD:	OUTSTR [ASCIZ /SORRY - NO BOARD TYPE
/]
	POPJ P,




SUBTTL SOME HANDY BYTE POINTERS, SQRT, NUMPNT

DEFINE LOW12<[POINT 12,A,35]>		;LOW ORDER 12 BITS OF A
DEFINE B6AT23<[POINT 6,A,23]>
DEFINE B6AT17<[POINT 6,A,17]>
DEFINE B6AT29<[POINT 6,A,29]>

SQRT:	JFFO T,.+2		;GET LOC OF FIRST BIT
	POPJ P,
	MOVNI TTT,(TT)
	ADDI TTT,=35
	ASH TTT,-1
	MOVEI TT,1
	ASH TT,(TTT)
	MOVEI TTT,=3		;3 ITERATIONS FOR NOW
SQRTLP:	MOVE TTTT,TT
	IDIVM T,TTTT
	ADD TT,TTTT
	ASH TT,-1
	SOJG TTT,SQRTLP
	MOVE T,TT
	POPJ P,

NUMPNT:	IDIVI T,=10
	ADDI TT,60
	JUMPE T,.+3
	ADDI T,60
	OUTCHR T
	OUTCHR TT
	POPJ P,
SUBTTL DISTANCE CALCULATOR FOR ROUTER STUFF
;CALLS WITH ONE PIN IN A OTHER IN C RETURNS DISTANCE IN G

;CITY BLOCK DISTANCE FOR W940 STUFF

DISTCB:PUSHJ P,PINMAP		;MAP ONE OF THEM
	 JRST DSTERR
	HRLM A,(P)
	MOVE A,C		;MOVE IN OTHER POINT
	MOVE C,T		;SAVE X,Y
	MOVE D,TTT		;AND DIST
	PUSHJ P,PINMAP
	JRST DSTERR
	CAMLE TTT,D
	SKIPA G,D
	MOVE G,TTT
	ASH G,1			;DOUBLE IT (MUST GO TO END AND BACK!)
	HLRE TT,T
	HLRE TTT,C
	SUB TT,TTT
	MOVM TT,TT
	HRRE T,T
	HRRE C,C
	SUB T,C
	MOVM T,T		;THIS IS Y PART
	JUMPE G,DSTCLX
	CAMG T,NEXTR		;OR IF PINS ARE ALONG A ROW BORDER
	JRST DSTCLX		;THEN END-AROUND FUDGE ISN'T NEEDED
;This is completely random, only works for DEC NOMEN.
	SKIPE LNGRID		;WE HAVE TO DO EAF DIFFERENTLY IF LNGRID IS TRUE
	JRST [	LDB C,[POINT 6,(P),5]	;GET ONE COLUMN LETTER
		LDB D,[POINT 6,A,23]	;GET OTHER COLUMN LETTER
		CAMN C,D		;SAME COLUMN?
		ADD T,G			;YES, FUDGE
		JRST DSTCLX]
	LDB C,[POINT 12,(P),17]
	LDB D,[POINT 12,A,35]
	SUB C,D
	IDIV C,NCOLS
	JUMPN D,DSTCLX		;IF REMAINDER, THEN DIF COLUMNS, AND NO FUDGE
	ADD T,G			;SAME COLUMN, BUT NOT CLOSE ENOUGH, FUDGE AROUND END OF DIP
DSTCLX:	ADD T,TT		;ADD IN X PART
	CAIN T,0		;0 LENGTH RUN?
	JRST DSTERR		;THEN DON'T ADD MARGINS
	CAILE T,=8000		;LONGER THAN 8 INCHES?
	ADDI T,=250		;YES, ADD 1/4 INCH
	CAME T,SMALL		;DON'T ADD WRAPMG IF PINS ARE ADJACENT
	ADD T,WRAPMG		;INSULATED WIRE TO WRAP AROUND POST
	ADD T,POSTMG		;BARE WIRE TO WRAP AROUND POST
	IDIV T,SMALL		;MODULO SMALLEST POSSIBLE SPACING
ITS,<	ASH TT,1
	CAML TT,SMALL
>;ITS
NOITS,<	SKIPE TT	>
	ADDI T,1		;YES, ADD 1
	MOVE G,T
	POPJ P,

DSTERR:	SETZ G,
	POPJ P,

;CALCULATE POINT TO POINT DISTANCE

DISTPP:
	PUSHJ P,PINMAP		;MAP ONE OF THEM
	JRST DSTERR
	MOVE A,C		;GET OTHER POINT
	MOVE C,T		;SAVE X,Y
	PUSHJ P,PINMAP
	JRST DSTERR
	HLRE TT,T
	HLRE TTT,C
	SUB TT,TTT		;GET VERTICAL DISTANCE
	IMUL TT,TT		;SQUARE IT
	HRRE T,T
	HRRE C,C
	SUB T,C			;HORIZONTAL DISTANCE
	IMUL T,T		;SQUARE IT
	ADD T,TT
	JUMPE T,DSTIS0		;DON'T WASTE TIME ON 0 LENGH RUNS
	PUSHJ P,SQRT		;SQUARE ROOT = HYPOTENEUSE (?SP?)
	CAILE T,=8000		;LONGER THAN 8 INCHES?
	ADDI T,=250		;YES, ADD 1/4 INCH
NOSTAN,<CAME T,SMALL
	ADD T,WRAPMG		;ADD SOME TO GO AROUND THE PINS
	ADD T,POSTMG		;ADD 1.5" FOR WRAPPING AROUND POSTS
>;NOSTAN
STANFO,<	;QUANTIZE FOR PRECUT WIRES
	CAMN T,SMALL		;ADJACENT PINS?
	JRST [	ADD T,POSTMG	;YES, ADD BARD WRAP ONLY
		JRST DSTIS1	]
	ADD T,POSTMG
	ADD T,WRAPMG
	MOVEI TTT,=500		;SET TTT TO INCREMENT FOR WIRRES FROM 3 TO 8 INCHES
	CAILE T,=8000		;OVER 8" ?
	MOVEI TTT,=1000		;YES, SET TTT TO INCREMENT FOR WIRES OVER 8 INCHES
	IDIV T,TTT
	SKIPE TT
	ADDI T,1
	IMUL T,TTT		;ROUND UP TO APPROPRIATE INCREMENT
DSTIS1:
>;STANFO
	IDIV T,SMALL		;MODULO SMALLEST POSSIBLE DISTANCE BETWEEN PINS
	SKIPE TT		;REMAINDER?
	ADDI T,1		;YES, ROUND UP
DSTIS0:	MOVE G,T
	POPJ P,
SUBTTL SPECIAL DEC ROUTINES FOR WIRELISTER

DEFINE CHKBRD
<	SKIPGE NOMTYP
	JRST NBOARD
>

DEC,<
;PRINTS LOCATION AND PIN # FOR TAPR-8 OUTPUT
;NUMBER OF PIN ON DIP IN T
;BODY BITS IN TT
;LOCATION (DIP,,PIN) IN A
TP8LOC:	CHKBRD
	TRNE TT,CBODY		;CONNECTOR?
	JRST TP8CON		;YES
	LDB TT,[POINT 6,A,5]
	MOVE TT,N2L(TT)		;GET LOC LETTER IN CASE NON-STANDARD
	CAIN T,=14
	MOVEI TT,"E"		;STANDARD FOR 14 PIN
	CAIN T,=16
	MOVEI TT,"F"		;16 PIN
	CAIN T,=24
	MOVEI TT,"G"		;24 PIN
	PUTBYT (TT)
	LDB T,[POINT 12,A,17]
	CAILE T,=99
	JRST TP8ERR
	MOVEI TT,2
	MOVEM TT,NDIG
	PUSHJ P,NPUTDEC
	HRRZ T,A
	CAILE T,=99
	JRST TP8ERR
	MOVEI TT,2
	MOVEM TT,NDIG
	JRST NPUTDEC

TP8CON:	LDB T,[POINT 6,A,5]
	PUTBYT @N2L(T)
	LDB T,[POINT 6,A,29]
	PUTBYT @N2L(T)
	MOVEI T,2
	MOVEM T,NDIG
	LDB T,[POINT 6,A,35]
	JRST NPUTDEC

TP8ERR:	OUTSTR[ASCIZ\ILLEGAL DIP AND/OR PIN #
\]
	POPJ P,

;PRINT PIN NUMBER FOR CS FILE
NETPIN:	MOVE T,A
	JRST DECOUT

;PRINT BP PIN FOR CS
PRCSBP:	LDB T,[POINT 5,A,26]
	LDB TT,[POINT 6,A,5]
	ADDI T,-1(TT)
	PUTBYT @N2L(T)
	LDB T,[POINT 6,A,35]
	MOVEI TT,2
	MOVEM TT,NDIG
	PUSHJ P,NDECOUT
	PUTBYT 40
	LDB T,[POINT 6,A,17]
	SUBI T,1
	IMULI T,=18
	LDB TT,[POINT 6,A,11]
	ADD T,TT
	MOVEI TT,2
	MOVEM TT,NDIG
	JRST NDECOUT

;PRINT PIN NUMBER FOR REDAC
RDCBPN:	CHKBRD
	HLRZ T,A
	JRST DECOUT

;PRINT PIN(A-V) AS NUMBER FOR REDAC
RDCCPN:	CHKBRD
	LDB T,[POINT 6,A,11]
	HLRZ TT,B
	CAILE TT,3
	SETZ TT,
	ADD T,(TT)[	0		;CASE 0 (??)
			0		;CASE 1 (1-18)
			=18		;CASE 2 (19-36)
			2*=18]		;CASE 3 (37-54)
	JRST DECOUT

;PRINT PADDLE ("U") AND NUMBER FOR WILD PIN
RDCUCN:	CHKBRD
	LDB T,[POINT 5,A,23]
	PUTBYT @N2L(T)
	LDB T,[POINT 11,A,17]
	JRST DECOUT

;PRINT CONNECTOR PADDLE AND SIDE
RDCCPD:	CHKBRD
	LDB T,[POINT 5,A,23]
	PUTBYT @N2L(T)
	LDB T,[POINT 6,A,17]
	JRST DECOUT

;PRINT NUMBER FOR CONNECTOR IN A FOR SR FILE
SRCPNM:	CHKBRD
	LDB T,[POINT 6,A,23]
	SUBI T,1
	TLNN A,4000	;WILD PIN?
	CAILE T,5	;OR ILLEGAL PADDLE?
	JRST SRCPER
	LDB TT,[POINT 6,A,17]
	CAIL TT,1
	CAILE TT,2
	JRST SRCPER
	SUBI TT,1
	LDB TTT,[POINT 5,A,11]
	SUBI TTT,1
	TRNE TT,1		;SIDE 2?
	TRO TTT,40		;YES, LOOK THERE
	SKIPGE SRPTAB(TTT)
	JRST SRCPER
	IMULI T,=33
	ADD T,SRPTAB(TTT)
	JRST PUTDEC

SRPTAB:
FOR I_4,=18
<	I		;A1-S1
>
	-1		;T1
FOR I_=19,=20
<	I		;U1-V1
>
REPEAT 40-<.-SRPTAB>,<-1>
	-1		;A2
	=21		;B2
	-1		;C2
FOR I_=22,=36		;D2-V2
<	I
>
REPEAT 100-<.-SRPTAB>,<-1>

SRCPER:	PUTSTR[ASCIZ/***/]
	POPJ P,

;GENERATE U PINS
;CALL WITH C(A) POINTER TO LAST PIN GENERATED
UGIN:	CHKBRD
	TRNE A,OUTLD
	JRST [	MOVEI A,UGINP2
		JRST UGIN1]
	TRNE A,TERM
	JRST [	MOVEI A,UGINP3
		JRST UGIN1]
	MOVEI A,UGINP1
UGIN1:	SKIPGE (A)
	POPJ P,			;RAN OUT
	PUSH P,T
	HLRZ T,(A)
	ADDI T,1
	CAMLE T,1(A)			;OVERFLOW?
	JRST UGINER
	HRLM T,(A)
	POP P,T
	MOVE A,(A)
	JRST CPOPJ1

UGINER:	POP P,T
	SETOM (A)
	OUTSTR[ASCIZ/RAN OUT OF GENERATED "U" PINS IN THE RANGE /]
	OUTSTR 2(A)
	OUTSTR[ASCIZ/.
NO MORE PINS WILL BE GENERATED IN THIS RANGE.
/]
	POPJ P,

UGINSET:CHKBRD
	HRRZ T,L2N+"U"
	LSH T,14
	HRLI T,4000+0
	MOVEM T,UGINP1
	HRLI T,4000+=199
	MOVEM T,UGINP2
	HRLI T,4000+=399
	MOVEM T,UGINP3
	POPJ P,

UGINP1:	0
	4000+=199
	ASCIZ/U100-U199/

UGINP2:	0
	4000+=399
	ASCIZ/U200-U399/

UGINP3:	0
	4000+=599
	ASCIZ/U400-U599/
>;DEC
>;MWL
SUBTTL UTILITY SUBRS

;CHKLET - ALPHA-LETTER-P
;CHECK TO MAKE SURE CHRREG IS A LETTER (CONVERTS LOWER CASE)

CHKLET:CAIL CHRREG,"a"		;CHECK FOR LOWER CASE
	CAILE CHRREG,"z"
	CAIA			;NOT LOWER CASE
	SUBI CHRREG,<"a"-"A">	;CONVERT TO UPPER CASE
	CAIL CHRREG,"A"
	CAILE CHRREG,"Z"
	POPJ P,
	JRST CPOPJ1		;ITS LEGAL

TWOLET:ROT CHRREG,-7*2	;MAKE IT ASCII
	MOVSI NUMREG,-TWOLEN
TWOLT1:	CAME CHRREG,TWOTAB(NUMREG)
	AOBJN NUMREG,TWOLT1
	JUMPGE NUMREG,CPOPJ
	MOVEI NUMREG,40(NUMREG)
	JRST CPOPJ1

TWOTAB:	ASCII/BT/
	ASCII/CB/
	ASCII/CR/
	ASCII/DL/
	ASCII/FC/
	ASCII/TP/
REPEAT 40-<.-TWOTAB>,<ASCII/??/>
TWOLEN__.-TWOTAB

;UMKCPN - CONVERT FROM 18 BIT FORM CPIN-LOC TO STANDARD PIN SPEC
;A = ,,CPIN-LOC(18 BIT FORM)
;RETURNS
;A = MAPCON+PINN,,CPIN-LOC

UMKCPN:	MOVE T,A
	PUSHJ P,CPNSEP
	MOVE A,T
	HRL A,TT
	TLO A,MAPCON
	POPJ P,

;MAKCPN - Convert from 36 bit CPIN#,,LOC into 18 bit MAPCON,,CPIN-LOC
;A = PIN#,,LOC
;RETURNS
;A = MAPCON,,CPIN-LOC
MAKCPN:	HLRZ TT,A
	HRRZ T,A
	PUSHJ P,CPNMER
	MOVE A,T
	HRLI A,MAPCON
	POPJ P,

;LNPARSE - KLUDGEY LETTER-NUMBER READER FOR SLOT INPUT
;A = SYNTAX LIST (ASCIZ STRINGS)
;REREAD = FLAG AND CHR ALREADY READ
;SKIPS IF SOME MATCH FOUND
;	- FAILS
;	- NULL INPUT OR (TEXISTS CHAR IF LAY)
;	- OK
;A = # OF ASCIZ THAT MATCHED (0 first, 1 etc.)
;ARGLST = SERIES OF NUMBER VALUES, OR CONVERTED LETTERS
;ARGS RETURNED IN ARG1,ARG2,ARG3,...
;MEANING OF CHARACTERS IN ASCIZ:
;	# - 	Number matches here (ARG)
;	L -	Some legal letter ok here (L2N  ARG)
;	<chr>	This character exactly (Returned as ARG!)
;	. -	Return this as success, even if input string isn't ended. 
;In the case of multiple matches, the first ASCIZ in the list that
; matches will take precedence.

LNPARS:SETZM REREAD
LNPART:PUSH P,B
	SETZ B,
	SETZ TT,
LNPAR1:	SKIPN T,(A)		;SETUP BYTE POINTERS TO SYNS
	 JRST [	HLLZS A
		MOVNS A
		HLLZM A,LNARP
		JRST LNPARL]
	CAIL TT,NSYNS
	 JRST LNPARZ
	HRLI T,440700
	MOVEM T,LNPTR(TT)
	AOS TT
	AOBJP A,LNPAR1

; Main loop, first check to see if any string immediately succeeds
LNPARL:	CAIL B,NARGS
	 JRST LNPARZ
	HLLZ A,LNARP
LNPRL2:	ILDB T,LNPTR(A)
	CAIN T,"."
	 JRST LNPARX
	AOBJN A,LNPRL2
; Now check numbers
	SKIPE CHRREG,REREAD
	 JRST [	TGETNUM
		JRST LNPRL1]
	GETNUM
LNPRL1:	JUMPE NUMREG,LNPAR2
	MOVEM NUMREG,ARGLST(B)
	AOS B
	HLLZ A,LNARP		;(A MIGHT BE NUMREG)
LNPAR3:	LDB T,LNPTR(A)
	CAIE T,"#"
	 SETZM LNPTR(A)
	AOBJN A,LNPAR3
	CAIL B,NARGS
	 JRST LNPARZ
	HLLZ A,LNARP
LNPRL3:	ILDB T,LNPTR(A)
	CAIN T,"."
	 JRST LNPARX
	AOBJN A,LNPRL3
; Check SYN for the letter
LNPAR2:	HLLZ A,LNARP
	PUSHJ P,CHKLET		;A LEGAL LETTER?
	 JRST LNPAR4
	SKIPG T,L2N(CHRREG)
	 JRST LNPAR4
	MOVEM T,ARGLST(B)
LNPAR5:	LDB TT,LNPTR(A)		;ANYBODY LOOKING FOR THIS LETTER, OR ANY LETTER?
	CAIN TT,"L"
	 JRST LNPAR6
	MOVE TT,L2N(TT)
	CAME TT,T
	 SETZM LNPTR(A)
LNPAR6:	AOBJN A,LNPAR5
	AOJA B,LNPARL

LNPAR4:	CAIL CHRREG,40
	 JRST LNPAR7
LNPAR8:	LDB T,LNPTR(A)		;INPUT TERMINATED, SEE IF ANY SYN MADE IT
	SKIPE LNPTR(A)
	 SKIPE T		;THIS GUY MADE IT
	AOBJN A,LNPAR8
	JUMPL A,LNPARX
	SKIPE B			;NO. OF ARGS READ = 0?
	 JRST LNPARZ
	CAIA			;NULL INPUT
LNPARX:	 AOS -1(P)
	AOS -1(P)
LNPARZ:	POP P,B
	HRRZS A
	POPJ P,

LNPAR7:	CAIL CHRREG,"a"
	CAILE CHRREG,"z"
	 CAIA
	SUBI CHRREG,40
	LDB T,LNPTR(A)		;SOME RANDOM CHARACTER, ALLOW ONLY EXACT MATCH
	CAIN T,"l"		;LOWER CASE L
	 MOVEI T,"L"		;KLUDGE
	CAME T,CHRREG
	 SETZM LNPTR(A)
	AOBJN A,LNPAR7
	AOJA B,LNPARL

STORAGE(IMPURE)
NARGS__=20			;MAX # OF FIELDS PARSED
NSYNS__=20			;MAX # OF SYNTAX STRINGS
LNARP:	0			;-# OF SYNS,,
ARGLST:
FOR @' I_1,NARGS+1
<ARG'I:	0
>
LNPTR:	BLOCK NSYNS		;BYTE POINTERS TO SYN STRINGS
REREAD:	0			;NON-ZERO, READ THIS CHAR AGAIN
STORAGE(PURE)


MDWL,<
;MAPPER - Logic for converting pins to posts within DIP socket 
;A = PIN#
;B = PACKAGE CODE
;C = DIP SOCKET SIZE (H) (# of pins in socket)
;D = VERTICAL OFFSET WITHIN SOCKET (0 = DEFAULT, ELSE IS WHERE PIN 1 GOES)
;SKIPS IF LEGAL MAPPING
;A = NEW PIN#
;B = FLAGS,,
;C = HORIZONTAL SOCKET OFFSET (+ is right on DIP side)
;D = VERTICAL SOCKET OFFSET (+ is down viewed fom DIP side)
;The adaptor mapping assumes that the location is the upper-left
;of an array of "dips" that pins get mapped into

;BITS RETURNED BY MAPPER
%MPLOC__400000			;Location was changed during conversion to post
%MPPIN__200000			;pin number was changed  "	"
%MPFOR__100000			;Force full printout if pin number changed
				; prevent some pins from printing in spchtb format
%MPUNI__40000			;Mapped to universal board pin, doesn't need pin #
				; just print the "location" which specifies pin
%MPROT__20000			;Kludge! DIP is rotated in socket, pin 1 is in
				;lower left corner now.

MAPPER:
	HRRZ T,PACKPN(B)	;NUMBER OF PINS ON PACKAGE
	CAMLE A,T		;PIN# TOO BIG?
	 POPJ P,
	LSH C,-1
	MOVEM C,SOCSZ2		;Socket, # pins on one side (H)
	HRRZ TT,MAPDSP(B)	;SPECIAL CHECK FOR SIP'S
	PUSH P,TT		;SAVE DISPATCH FOR LATER
	CAIE TT,SIP
	 LSH T,-1		;DIP, # PINS ON SIDE (h)
	MOVEM T,ICSIZ2
	MOVE TT,SOCSZ2
	SUB TT,T		;H-h, THE DISPARITY BETWEEN DIP AND SOCKET
	SOS D			;SOCKET OFFSET, 0 IS DEFAULT
	MOVEM D,SOCKOF
	MOVEM B,ADAPPK
	SKIPGE D
	 MOVE D,TT		;PUT DIP AT BOTTOM OF SOCKET
	HLRZ TTT,MAPDSP(B)	;MIGHT BE TABLE FOR ADAPTOR CODE
	SETZ B,			;INITIALIZE MAPPER FLAGS TO 0
	POPJ P,			;DISPATCH

;D = Vertical pin Offset within socket
;C = H		;SOCKET, # pins in a single column. (for SIPs)
;T = h		;IC, # pins along one column.
;TT = H-h	;vertical disparity between IC and socket

BDIP:				;SIZES defaults to .600 spacing for BDIP
DIP:	JUMPL TT,CPOPJ		;DIP IS BIGGER THAN SOCKET,LOSE
	CAILE D,-1(C)		;As a hack, "offsets" into 2nd column
				; put dip in socket rotated 180
	 JRST DIPDWN
	CAMLE D,TT		;VERTICAL OFFSET TOO BIG? 
	 POPJ P,		; YES, OFF END OF SOCKET
	CAMLE A,T		;PIN IS IN FIRST ROW OF DIP?
	 JRST DIP2
	JUMPE D,DIP1A		;NO OFFSET, IT FITS EXACTLY
	ADD A,D
DIP3A:	TLO B,%MPPIN
DIP1A:	SETZB C,D		;WILL FIT, NO SLOT OFFSET NEEDED
	JRST CPOPJ1

DIP2:	ADD TT,TT		;2*(H-h)
	SUB TT,D		;We move pin up 2* diff in rows, less offset
	JUMPE TT,DIP1A		;NO CHANGE
	TLO B,%MPPIN
	ADD A,TT
	JRST DIP1A

;Offset is onto 2nd socket column, rotate dip and the offset is still
; where pin 1 goes.
DIPDWN:	ADDI T,1(D)		;Offset + h, where the highest pin will go.
	LSH C,1			;2*H, the max pin on socket
	CAMLE T,C		;Off top of socket?
	 POPJ P,
	TLO B,%MPROT		;Tell the geometry stuff DIP is rotated 180
	CAMLE A,ICSIZ2		;Pin is in 1st column of DIP?
	 JRST [	LSH TT,1	;2*(H-h)
		ADD A,TT
		SUB A,SOCKOF
		JRST DIP3A]
	ADD A,D
	JRST DIP3A






; Now offsets for SIP packages
; If offset is within left row of socket, SIP pin#s go opposite socket pin#s
SIP:	CAMLE D,SOCSZ2		;OFFSET SAYS IN FIRST ROW?
	 JRST SIP2		;NO, SWOP SIP OVER ON OTHER ROW
	CAMLE D,TT		;OFFSET OFF BOTTOM?
	 POPJ P,
	TLO B,%MPPIN
	ADD A,D
SIP1A:	SETZB C,D		;RETURN NO SLOT OFFSET
	JRST CPOPJ1

SIP2:	AOS D			;ORIG OFFSET IS TOP PIN#
	ADD T,SOCSZ2		;H+h
	ASH C,1			;2H  BIGGEST PIN # IN SOCKET
	CAMLE D,C		;CAN'T GO HIGHER THAN THAT
	 POPJ P,
	CAMGE D,T
	 POPJ P,		;AND CAN'T GO LOWER THAN THIS
	SUBI D,-1(A)
	MOVE A,D
	TLO B,%MPPIN!%MPFOR	;PIN #'S ARE REVERSED, DON'T TRY + TYPE PRINT
	JRST SIP1A

;Mapping routines for universal boards.
;A = PIN#
;B = PACKAGE CODE
;C = COLUMN (Note! Column #'s increase to right from DIP side.)
;D = "Row", DIP's pin 1 within column (increasing #s as first row of DIP pins)
;SKIPS IF LEGAL MAPPING
;B = FLAGS,,
;C = NEW COLUMN #
;D = NEW ROW #
;Check for legal packages, then make new location,
; with pin# equal to 0, the post location is entirely
; specified by DIP column and row. 
;Caller must check for legal col and row numbers.

;Note! This assumes the spacing of columns is .300"

;*** should eventually check for adaptors (for instance the .400-.300 adaptor) ***

MAPUNI:
	HRRZ T,MAPDSP(B)	;WHAT TYPE OF PACKAGE?
	CAIN T,SIP
	 JRST MAP1ST		;LIKE 1ST ROW OF DIP
	CAIE T,DIP		;IS DIP?
	 POPJ P,		; NO, ILLEGAL THEN
;Is a DIP, check for legal columns depending on DIP leg spacing,
; then map column if pin is in 2nd row of DIP pins
	HRRZ TT,PACKPN(B)
	ASH TT,-1		;# PINS ON ONE SIDE OF DIP
	HRRZ T,DIPLEG(B)	;HOW FAR APART DIP legs?
	CAIN T,=600
	 JRST [	CAMG A,TT	;FIRST ROW OF PINS?
		 JRST MAP1ST
		AOJA C,MAP2ND]	;EXTRA COLUMN OVER
	CAIE T,=300		; .3" SPACING?
	 POPJ P,		;NO, LOSE
;Standard .3" DIP
	CAMG A,TT		;WHICH ROW OF DIP PINS?
	 JRST MAP1ST		; FIRST
MAP2ND:	SUB A,PACKPN(B)
	SUB D,A			; ROW-PIN#+#PINS is displacement
	AOS C			;IN NEXT COLUMN OVER.
	CAIA
MAP1ST:	 ADDI D,-1(A)		;OFFSET ROW BY PIN#
	SETZ A,			;NULL PIN #, ALL IS IN LOC
	MOVSI B,%MPLOC!%MPUNI	;UNIVERSAL LOC INCLUDES PIN#
	JRST CPOPJ1

;Kludgey routines for adaptors that span more than 1 socket
;C = Board socket size (16,20,...)
;ADAPPK = index into package descriptor tables
;SOCKOF =  offset of pin 1 within socket (1A31@2 notation)
;TTT = Pin mapping table for this adaptor type
; sets up call to DIP
;D = Pin Offset within socket
;;C = H		;SOCKET ROW HEIGHT
;T = h		;DIP ROW HEIGHT
;TT = H-h	;BOARD SOCKET ROW HEIGHT

%pkhor==331100		;Table has horz, vertical socket offset (signed)
%pkver==221100
$pkhor==33
$pkver==22
$$pkhv==11		;size of field

ADAPT:	MOVE T,ADAPPK		;ORIGINAL PACKAGE INDEX
	HRRZ T,ADAPSZ(T)	;DIP ADAPTORS IS A SET OF DIPS, GET h
	MOVE TT,C
	SUB TT,T		;H-h
	ADDI A,-1(TTT)		;TABLE ENTRY FOR PIN
	PUSH P,(A)		;save dip socket offset info
	HRRZ A,(A)		;NEW PIN #, WITHIN GHOST DIPS
	SKIPGE D,SOCKOF
	 MOVE D,TT		;DEFAULT VERTICAL OFFSET
	PUSHJ P,DIP		;NOW GO DO OFFSET STUFF
	 CAIA			; failed to map??
	 AOS -1(P)		;A has new pin #
;Extract horiz, vertical socket offsets
	LDB C,[%PKHOR,,(P)]	;HORIZ SOCKET OFFSET
	SKIPE C
	 TLO B,%MPLOC		;LOCATION CHANGED
	TRNE C,1<$$PKHV-1>	;NEGATIVE?
	ORCMI C,1$$PKHV-1
	LDB D,[%PKVER,,(P)]	;HORIZ SOCKET OFFSET
	SKIPE D
	 TLO B,%MPLOC		;LOCATION CHANGED
	TRNE D,1<$$PKHV-1>	;NEGATIVE?
	ORCMI D,1$$PKHV-1
	TLO B,%MPPIN+%MPFOR	;SIGNAL MAPPED PIN #, DON'T TRY +,: HACK
	SUB P,[1,,1]
	POPJ P,

STORAGE(IMPURE)
SOCKOF:	0			;VERTICAL OFFSET WITHIN SOCKET
ICSIZ2:	0			;# pins along one side of DIP
SOCSZ2:	0			;Socket, # pins on one side (H)
ADAPPK:	0			;PACKAGE CODE FOR THIS ADAPTOR
LLCOOR:	0			;-1 IF LOWER LEFT IS 0, ELSE UPPER LEFT IS 0
PAKROT:	0			;-1, Package was rotated 180
STORAGE(PURE)


;PAKDIM - COMPUTE X,Y OF PACKAGE OUTLINE
;A = MBIT+PIN#,,LOC
;B = PACKAGE CODE
;SKIPS IF LOCATION IS LEGAL FOR THIS PACKAGE TYPE
;T = Xmin,,Ymin
;TT = Xmax,,Ymax

MWL,<
;PAKDIM ASSUMES 0,0 IS IN LOWER-LEFT VIEWED FROM DIP SIDE
PAKDUL:	SETZM LLCOOR		;0,0 IS UPPER LEFT (DIP SIDE)
	CAIA			;Used by some old board routines
PAKDIM:	 SETOM LLCOOR		;0,0 IS LOWER LEFT (DIP SIDE)
	PUSH P,A
	PUSH P,B		;PACKAGE CODE
;Find X,Y of pin 1
	MOVEI T,1
	DPB T,[%%PINN,,A]
	PUSHJ P,MAPOST		;CONVERT TO POST
	 JRST PAKDMX
	SETZM PAKROT
	TLNE B,%MPROT
	 SETOM PAKROT
	PUSHJ P,MAPIT		;GET X,Y
	 JRST PAKDMX		;LOSE BIG
	MOVE TT,T		;GET X,Y IN BOTH
	HRRZ B,(P)		;PACKAGE CODE
	HRRZ B,SIZES(B)		;Package dimensions [minX,,minY  maxX,,maxY]
	HLLZ TTT,(B)
	SKIPE PAKROT
	 MOVNS TTT
	ADD T,TTT
	HRRZ TTT,(B)		;Y (+ IS UP)
	SKIPE PAKROT
	 MOVNS TTT
	SKIPN LLCOOR		;0 IN UPPER LEFT?
	 MOVNS TTT		;YES, REVERSE PACKAGE Y
	ADD TTT,T
	HRR T,TTT
	HLLZ TTT,1(B)		;X OF PACKAGE
	SKIPE PAKROT
	 MOVNS TTT
	ADD TT,TTT
	HRRZ TTT,1(B)
	SKIPE PAKROT
	 MOVNS TTT
	SKIPN LLCOOR
	 MOVNS TTT
	ADD TTT,TT
	HRR TT,TTT
	AOS -2(P)
PAKDMX:	POP P,B
	POP P,A
	POPJ P,

SUBTTL FINDCLOSEST SCANNER - CLOSES IN A SET OF PINS
;SEARCH FOR CLOSEST BOARD PIN TO WIRE TO
;A = PIN
;Call sequence:
;	PUSHJ P,FINDLOSEST
;	  exit with new pin in A
;	co-routine to generate candidates
;	....
;	JRST CPOPJ1	;return with possibility in A
;	POPJ P,		;no more possibilities


FINDCLOSEST:
	PUSHJ P,MAPIT		;GET X,Y OF FIRST PIN
	 SETZ T,		;???
	PUSH P,[0]		;-4(P)	TEMP
	HLRE TT,T		;X
	HRRES T
	PUSH P,TT		;-3(P)	X
	PUSH P,T		;-2(P)	Y
	PUSH P,[0]		;-1(P)	BEST SO FAR
	PUSH P,[377777,,-1]	;0(P)	DISTANCE BEST SO FAR
	AOS -5(P)		;POINT TO COROUTINE
FINDCA:	PUSHJ P,@-5(P)		;GET A CANDIDATE
	 JRST FINDCE		;LAST
	MOVEM A,-4(P)		;SAVE CANDIDATE
	PUSHJ P,MAPIT
	 SETZ T,
	HLRE TT,T
	SUB TT,-3(P)
	IMUL TT,TT
	HRRES T
	SUB T,-2(P)
	IMUL T,T
	ADD T,TT
	CAML T,0(P)		;BETTER THAN PREVIOUS?
	 JRST FINDCA
	MOVEM T,0(P)
	MOVE A,-4(P)
	MOVEM A,-1(P)
	JRST FINDCA

FINDCE:	SOS -5(P)
	MOVE A,-1(P)
	SUB P,[5,,5]
	POPJ P,

>;MWL
SUBTTL ADAPTOR MAPPING TABLES

;MAPPING TABLES FOR DIP ADAPTORS
RADIX =10
DEFINE MAP(HSLOT,PIN)
<	<HSLOT-1>$PKHOR+PIN
>
DEFINE MAP2(HSLOT,VSLOT,PIN)
<	<HSLOT-1>$PKHOR+<VSLOT-1>$PKVER+PIN
>
;Each table is a function that transforms a DIP pin # into
; a pin on a board socket, plus a signed Horz,Vert socket offset
;The socket offset is from the adaptor location, assumed to
;be the upper-left of an array of pseudo dips, where +horiz offset
;is to the right, + vertical offset is down
;All directions are from the DIP side of the board.



;624 augat 24 pin adaptor, fits in 3 sockets horizontally
; NOTE: this map is for pin 1 in upper right (DIP side)
; (assumes the adaptor consists of 3 14 pin "DIPs")

M.624AUG:
	MAP(3,13)		;Pin 1
	MAP(3,12)		;Pin 2
	MAP(3,2)		;Pin 3
	MAP(3,3)		;Pin 4
	MAP(2,13)		;Pin 5
	MAP(2,12)		;Pin 6
	MAP(2,3)		;Pin 7
	MAP(2,2)		;Pin 8
	MAP(1,12)		;Pin 9
	MAP(1,13)		;Pin 10
	MAP(1,3)		;Pin 11
	MAP(1,2)		;Pin 12
	MAP(1,6)		;Pin 13
	MAP(1,5)		;Pin 14
	MAP(1,9)		;Pin 15
	MAP(1,10)		;Pin 16
	MAP(2,6)		;Pin 17
	MAP(2,5)		;Pin 18
	MAP(2,10)		;Pin 19
	MAP(2,9)		;Pin 20
	MAP(3,5)		;Pin 21
	MAP(3,6)		;Pin 22
	MAP(3,10)		;Pin 23
	MAP(3,9)		;Pin 24
CHECK(M.624AUG,=24)

;624 augat 24 pin adaptor, lower left, fits in 3 sockets horizontally
; NOTE: this map is for pin 1 in lower left (DIP side)
; (assumes the adaptor consists of 3 14 pin "DIPs")

M.624XUG:
	MAP(1,6)		;Pin 13
	MAP(1,5)		;Pin 14
	MAP(1,9)		;Pin 15
	MAP(1,10)		;Pin 16
	MAP(2,6)		;Pin 17
	MAP(2,5)		;Pin 18
	MAP(2,10)		;Pin 19
	MAP(2,9)		;Pin 20
	MAP(3,5)		;Pin 21
	MAP(3,6)		;Pin 22
	MAP(3,10)		;Pin 23
	MAP(3,9)		;Pin 24
	MAP(3,13)		;Pin 1
	MAP(3,12)		;Pin 2
	MAP(3,2)		;Pin 3
	MAP(3,3)		;Pin 4
	MAP(2,13)		;Pin 5
	MAP(2,12)		;Pin 6
	MAP(2,3)		;Pin 7
	MAP(2,2)		;Pin 8
	MAP(1,12)		;Pin 9
	MAP(1,13)		;Pin 10
	MAP(1,3)		;Pin 11
	MAP(1,2)		;Pin 12
CHECK(M.624XUG,=24)

;Map for Augat 40 pin adaptor - 640-HG16
; Pin1 is in upper left (from DIP side)
; The adaptor looks like a 2x2 array of 14 pin DIPs,
; .2" apart horizontally, and .3" between pin 8/pin 1

;The slots are numbered: (as seen from DIP side)
;
;     (pin 1)
;	1,1   2,1
;	1,2   2,2


M.640AUG:
	MAP2(1,1,14)		;Pin 1
	MAP2(1,1,13)		;Pin 2
	MAP2(1,1,2)		;Pin 3
	MAP2(1,1,3)		;Pin 4
	MAP2(1,1,4)		;Pin 5
	MAP2(1,1,5)		;Pin 6
	MAP2(1,1,6)		;Pin 7
	MAP2(1,1,7)		;Pin 8
	MAP2(1,1,10)		;Pin 9
	MAP2(1,1,9)		;Pin 10
	MAP2(1,2,16)		;Pin 11
	MAP2(1,2,1)		;Pin 12
	MAP2(1,2,2)		;Pin 13
	MAP2(1,2,3)		;Pin 14
	MAP2(1,2,4)		;Pin 15
	MAP2(1,2,5)		;Pin 16
	MAP2(1,2,14)		;Pin 17
	MAP2(1,2,13)		;Pin 18
	MAP2(1,2,12)		;Pin 19
	MAP2(1,2,11)		;Pin 20
	MAP2(2,2,5)		;Pin 21
	MAP2(2,2,4)		;Pin 22
	MAP2(2,2,3)		;Pin 23
	MAP2(2,2,11)		;Pin 24
	MAP2(2,2,12)		;Pin 25
	MAP2(2,2,13)		;Pin 26
	MAP2(2,2,14)		;Pin 27
	MAP2(2,2,15)		;Pin 28
	MAP2(2,2,16)		;Pin 29
	MAP2(2,2,1)		;Pin 30
	MAP2(2,1,7)		;Pin 31
	MAP2(2,1,9)		;Pin 32
	MAP2(2,1,10)		;Pin 33
	MAP2(2,1,11)		;Pin 34
	MAP2(2,1,12)		;Pin 35
	MAP2(2,1,13)		;Pin 36
	MAP2(2,1,14)		;Pin 37
	MAP2(2,1,4)		;Pin 38
	MAP2(2,1,3)		;Pin 39
	MAP2(2,1,2)		;Pin 40
CHECK M.640AUG,=40





 ;Adaptors special for III

;the S.Gray memorial 24 pin dip adaptor
;Adapts 24 pin dip into 2 16 pin sockets .1" horiz apart.
;Hangs down below dip sockets.
;also plugs into V,G pins on board, and pin 24,12 of dip
;are therefore wired to pwr/gnd

M.SGR2:
	MAP(1,15)
	MAP(1,1)
	MAP(1,2)
	MAP(1,3)
	MAP(1,4)
	MAP(1,5)
	MAP(1,6)
	MAP(1,7)
	MAP(1,11)
	MAP(1,10)
	MAP(1,9)
	MAP(2,0)	;G PIN
	MAP(2,7)
	MAP(2,6)
	MAP(2,5)
	MAP(2,9)
	MAP(2,10)
	MAP(2,11)
	MAP(2,12)
	MAP(2,13)
	MAP(2,14)
	MAP(2,15)
	MAP(2,16)
	MAP(2,17)	;V PIN	
CHECK M.SGR2,=24


 ;More adaptor mapping
ITS,<

;e.g. - Pin 1 maps to 3rd socket, pin 15 (of 16) as viewed from DIP side.

;MIT 24 Pin dip adaptor
MAP24:	MAP(3,15)	;1
	MAP(3,14)	;2
	MAP(3,13)	;3
	MAP(3,2)	;4
	MAP(3,3)	;5
	MAP(2,15)	;6
	MAP(2,14)	;7
	MAP(2,3)	;8
	MAP(2,2)	;9
	MAP(2,4)	;10
	MAP(1,15)	;11
	MAP(1,14)	;12
	MAP(1,4)	;13
	MAP(1,11)	;14
	MAP(1,12)	;15
	MAP(2,6)	;16
	MAP(2,5)	;17
	MAP(2,12)	;18
	MAP(2,11)	;19
	MAP(2,13)	;20
	MAP(3,6)	;21
	MAP(3,5)	;22
	MAP(3,12)	;23
	MAP(3,11)	;24
CHECK MAP24,=24

;MIT 28 Pin DIP adaptor
MAP28:	MAP(3,15)	;1
	MAP(3,14)	;2
	MAP(3,13)	;3
	MAP(3,2)	;4
	MAP(3,3)	;5
	MAP(2,15)	;6
	MAP(2,14)	;7
	MAP(2,3)	;8
	MAP(2,2)	;9
	MAP(2,4)	;10
	MAP(1,15)	;11
	MAP(1,14)	;12
	MAP(1,3)	;13
	MAP(1,2)	;14

	MAP(1,6)	;15
	MAP(1,5)	;16
	MAP(1,4)	;17
	MAP(1,11)	;18
	MAP(1,12)	;19
	MAP(2,6)	;20
	MAP(2,5)	;21
	MAP(2,12)	;22
	MAP(2,11)	;23
	MAP(2,13)	;24
	MAP(3,6)	;25
	MAP(3,5)	;26
	MAP(3,12)	;27
	MAP(3,11)	;28
CHECK MAP28,=28

;MIT 40 Pin DIP adaptor - old style
MAP40:	MAP(4,15)	;1
	MAP(4,14)	;2
	MAP(4,4)	;3
	MAP(4,2)	;4
	MAP(4,3)	;5
	MAP(3,15)	;6
	MAP(3,14)	;7
	MAP(3,4)	;8
	MAP(3,2)	;9
	MAP(3,3)	;10
	MAP(2,15)	;11
	MAP(2,14)	;12
	MAP(2,4)	;13
	MAP(2,2)	;14
	MAP(2,3)	;15
	MAP(1,15)	;16
	MAP(1,14)	;17
	MAP(1,4)	;18
	MAP(1,2)	;19
	MAP(1,3)	;20

	MAP(1,5)	;21
	MAP(1,6)	;22
	MAP(1,13)	;23
	MAP(1,12)	;24
	MAP(1,11)	;25
	MAP(2,5)	;26
	MAP(2,6)	;27
	MAP(2,13)	;28
	MAP(2,12)	;29
	MAP(2,11)	;30
	MAP(3,5)	;31
	MAP(3,6)	;32
	MAP(3,13)	;33
	MAP(3,12)	;34
	MAP(3,11)	;35
	MAP(4,5)	;36
	MAP(4,6)	;37
	MAP(4,13)	;38
	MAP(4,12)	;39
	MAP(4,11)	;40
CHECK MAP40,=40

MAN40:	MAP(4,14)	;1
	MAP(4,15)	;2
	MAP(4,13)	;3
	MAP(4,3)	;4
	MAP(4,2)	;5
	MAP(3,14)	;6
	MAP(3,15)	;7
	MAP(3,13)	;8
	MAP(3,3)	;9
	MAP(3,2)	;10
	MAP(2,14)	;11
	MAP(2,15)	;12
	MAP(2,13)	;13
	MAP(2,3)	;14
	MAP(2,2)	;15
	MAP(1,14)	;16
	MAP(1,15)	;17
	MAP(1,13)	;18
	MAP(1,3)	;19
	MAP(1,2)	;20

	MAP(1,5)	;21
	MAP(1,6)	;22
	MAP(1,4)	;23
	MAP(1,12)	;24
	MAP(1,11)	;25
	MAP(2,5)	;26
	MAP(2,6)	;27
	MAP(2,4)	;28
	MAP(2,12)	;29
	MAP(2,11)	;30
	MAP(3,5)	;31
	MAP(3,6)	;32
	MAP(3,4)	;33
	MAP(3,12)	;34
	MAP(3,11)	;35
	MAP(4,5)	;36
	MAP(4,6)	;37
	MAP(4,4)	;38
	MAP(4,12)	;39
	MAP(4,11)	;40
CHECK MAN40,=40

;MIT 48 Pin DIP adaptor
MAP48:
	MAP(5,15)	;1
	MAP(5,14)	;2
	MAP(5,3)	;3
	MAP(5,2)	;4
	MAP(5,4)	;5
	MAP(4,15)	;6
	MAP(4,14)	;7
	MAP(4,13)	;8
	MAP(4,2)	;9
	MAP(4,3)	;10
	MAP(3,15)	;11
	MAP(3,14)	;12
	MAP(3,3)	;13
	MAP(3,2)	;14
	MAP(3,4)	;15
	MAP(2,15)	;16
	MAP(2,14)	;17
	MAP(2,3)	;18
	MAP(2,2)	;19
	MAP(1,14)	;20
	MAP(1,15)	;21
	MAP(1,4)	;22
	MAP(1,3)	;23
	MAP(1,2)	;24
	MAP(1,6)	;25
	MAP(1,5)	;26
	MAP(1,12)	;27
	MAP(1,11)	;28
	MAP(1,13)	;29
	MAP(2,6)	;30
	MAP(2,5)	;31
	MAP(2,4)	;32
	MAP(2,11)	;33
	MAP(2,12)	;34
	MAP(3,6)	;35
	MAP(3,5)	;36
	MAP(3,12)	;37
	MAP(3,11)	;38
	MAP(3,13)	;39
	MAP(4,6)	;40
	MAP(4,5)	;41
	MAP(4,12)	;42
	MAP(4,11)	;43
	MAP(5,5)	;44
	MAP(5,6)	;45
	MAP(5,13)	;46
	MAP(5,12)	;47
	MAP(5,11)	;48
CHECK MAP48,=48

;MAP2 <horiz-offset, vertical-offset, new-pin-#>
MAP2H:	MAP2(1,1,1)		;DIP OCCUPIES 2 VERT SLOTS
	MAP2(1,1,2)
	MAP2(1,1,3)
	MAP2(1,1,4)
	MAP2(1,1,5)
	MAP2(1,1,6)
	MAP2(1,1,7)
	MAP2(1,1,8)
	MAP2(1,1,9)
	MAP2(1,1,10)

	MAP2(1,2,1)
	MAP2(1,2,2)
	MAP2(1,2,3)
	MAP2(1,2,4)
	MAP2(1,2,5)
	MAP2(1,2,6)
	MAP2(1,2,7)
	MAP2(1,2,8)
	MAP2(1,2,9)
	MAP2(1,2,10)

	MAP2(1,2,11)
	MAP2(1,2,12)
	MAP2(1,2,13)
	MAP2(1,2,14)
	MAP2(1,2,15)
	MAP2(1,2,16)
	MAP2(1,2,17)
	MAP2(1,2,18)
	MAP2(1,2,19)
	MAP2(1,2,20)

	MAP2(1,1,11)
	MAP2(1,1,12)
	MAP2(1,1,13)
	MAP2(1,1,14)
	MAP2(1,1,15)
	MAP2(1,1,16)
	MAP2(1,1,17)
	MAP2(1,1,18)
	MAP2(1,1,19)
	MAP2(1,1,20)
CHECK MAP2H,=40

;64 Pin adaptor that uses 3x3 group of sockets on LG684 board.
;(Made for TRW multiplier chip)
MAP64:	MAP2(1,3,1)		;1
	MAP2(1,3,19)		;2
	MAP2(1,3,18)		;3
	MAP2(1,3,17)		;4
	MAP2(1,3,16)		;5
	MAP2(1,3,15)		;6
	MAP2(1,3,14)		;7
	MAP2(1,3,13)		;8
	MAP2(1,3,12)		;9
	MAP2(1,3,11)		;10
	MAP2(1,3,9)		;11

	MAP2(1,2,1)		;12
	MAP2(1,2,19)		;13
	MAP2(1,2,18)		;14
	MAP2(1,2,17)		;15
	MAP2(1,2,16)		;16
	MAP2(1,2,15)		;17
	MAP2(1,2,14)		;18
	MAP2(1,2,13)		;19
	MAP2(1,2,12)		;20
	MAP2(1,2,11)		;21
	MAP2(1,2,9)		;22

	MAP2(1,1,1)		;23
	MAP2(1,1,19)		;24
	MAP2(1,1,18)		;25
	MAP2(1,1,17)		;26
	MAP2(1,1,16)		;27
	MAP2(1,1,15)		;28
	MAP2(1,1,14)		;29
	MAP2(1,1,13)		;30
	MAP2(1,1,12)		;31
	MAP2(1,1,11)		;32

	MAP2(3,1,11)
	MAP2(3,1,9)
	MAP2(3,1,8)
	MAP2(3,1,7)
	MAP2(3,1,6)
	MAP2(3,1,5)
	MAP2(3,1,4)
	MAP2(3,1,3)
	MAP2(3,1,2)
	MAP2(3,1,1)

	MAP2(3,2,11)
	MAP2(3,2,12)
	MAP2(3,2,9)
	MAP2(3,2,8)
	MAP2(3,2,7)
	MAP2(3,2,6)
	MAP2(3,2,5)
	MAP2(3,2,4)
	MAP2(3,2,3)
	MAP2(3,2,2)
	MAP2(3,2,1)

	MAP2(3,3,11)
	MAP2(3,3,12)
	MAP2(3,3,9)
	MAP2(3,3,8)
	MAP2(3,3,7)
	MAP2(3,3,6)
	MAP2(3,3,5)
	MAP2(3,3,4)
	MAP2(3,3,3)
	MAP2(3,3,2)
	MAP2(3,3,1)
CHECK MAP64,=64
>;ITS

RADIX 8
>;MDWL
SUBTTL INTERFACE TO BOARD SPECIFIC ROUTINES

;THESE USED TO BE IN BOARD FILES, BUT WERE MOVED
;IT IS POSSIBLE THAT SOME FUTURE BOARD TYPE MAY WANT
;TO MOVE THESE BACK, BUT IT WOULD BE NICER TO JUST
;ADD FEATURES TO THE EXISTING INTERFACE


;RPNAM - READS PIN # INTO A
;RPNAMA - CHECKS IF NUMBER FOLLOWS
;TRPNAM - CHAR ALREADY IN CHRREG

MWL,<
;READ DEC #, FIRST CHAR ALREADY IN TTT
TRPNAM:	TGETNUM
	JRST CPOPJ1

;READ NUMBER, 0 IF NUMBER DOESN'T START RIGHT AWAY
RPNAMA:	GETCH
	CAIL CHRREG,"0"
	CAILE CHRREG,"9"
	TDZA A,A
	PUSHJ P,TRPNAM
	JFCL
	JRST CPOPJ1
>;MWL

RPNAM:	GETNUM
	JRST CPOPJ1



;BPINPN - PRINT SIMPLE PIN#
; (For now is just #, but might want to allow letters later???)
;A = PIN#
BPINPN:	PUSH P,A
	PUSH P,T
;	HRLZS A
;	PUSHJ P,PRNPIN
	HRRZ T,A
	PUSHJ P,PUTDEC
	POP P,T
	JRST POPAJ

MWL,<
;PINMAP (WL) - GET X,Y OF PIN, AND FLAG BITS TO IDENTIFY PWR/GND PINS
;A = MBIT!MAPSOC+PIN#,,LOC
;RETURNS
;T =X,Y
;TT = BITS
PINMAP:	PUSH P,A
	PUSHJ P,MAPIT		;GET X,Y, AND BITS
	 SOS -1(P)		;DON' SKIP
POPAJ1:	POP P,A
	JRST CPOPJ1

;PINBIT (WL) - GET X,Y,BITS BUT IGNORE ERROR
;A = MBIT!MAPSOC+PIN#,,LOC
PINBIT:	PUSHJ P,MAPIT
	 SETZ TT,		;SOME ERROR, DON'T RETURN ANY BITS
	POPJ P,
>;MWL

IFN 0,<
;CSLTLT (D) - PRINT CONNECTOR PIN NAME, (POSSIBLY WITH B-R-S)
;A = B-R-S,,CPIN-LOC		;CONVERT FROM MOVS
CSLTLT:	PUSH P,A
	HLRZS A
	PUSHJ P,SLTOUT
	SKIPE TT		;SEPARATOR CHAR SUGGESTED?
	 PUTBYT (TT)
	HRRZ A,(P)
	PUSHJ P,UMKCPN		;CONVERT FROM 18 BIT FORM
	PUSHJ P,LOCPIN
	JRST POPAJ
>;IFN 0

;CSLTLP (DPC) - PRINT CONNECTOR PIN, AS BACKPANEL PIN
;A = B-R-S,,CPIN-LOC		;CONVERT FROM MOVS
MDPC,<
CSLTLP:	MOVEI T,0
>;MDPC
	;FALL THRU
;BPNPIN (WL) - PRINT AS BACKPANEL PIN
;A = B-R-S,,CPIN-LOC
;T = SLOT OFFSET
MWL,<
BPNPIN:
>;MWL
	PUSH P,A
	PUSH P,B
	TLNE A,-1		;ANY B-R-S
	PUSHJ P,CPNMAP		;YES, TRY TO MAP TO BACKPANEL PIN
	TDZA B,B
	 TLO B,400000
	PUSH P,A
	HLRZS A
	PUSHJ P,SLTOUT
	SKIPE TT
	 PUTBYT (TT)
	POP P,A
	PUSHJ P,UMKCPN
	SKIPL B
	 JRST [ PUSHJ P,PRNLOC		;B-R-S WAS CONVERTED, DON'T NEED CPIN-LOC
		SKIPE TT
		PUTBYT (TT)
		JRST .+1]
	PUSHJ P,PRNPIN
	POP P,B
	POP P,A
	POPJ P,

MWL,<
;PRBCN (WL) - PRINT CONNECTOR PIN WITH BOARD LOC
;A = ,,CPIN-LOC
PRBCN:	PUSH P,A
	PUSHJ P,UMKCPN
	PUSHJ P,LOCPIN
	JRST POPAJ

;PRCNPN (WL) - PRINT PIN PART OF CPIN
;A = ,,CONN-LOC#
;T = PINN#
PRCNPN:	PUSH P,A
	HRLI A,MAPCON(T)
	PUSHJ P,PRNPIN
	JRST POPAJ

;LOCPNW (WL) - PRINT CONNECTOR WITH WILD CHAR
;A = CPIN#,,CPIN-LOC
;T = BODY BITS
LOCPNW:
DEC,<	TRNE T,BWILD
	 PUTBYT WLDCHR
>;DEC
	;FALLS THRU
;LOCPNC (WL) - PRINT CONNECTOR
;A = CPIN#,,CPIN-LOC
LOCPNC:	TLO A,MAPCON
	JRST LOCPIN

;PADPRT (WL) - PRINT PADDLE (OR JACK) LOCN
;A = ,,CPIN
PADPRT:	PUTBYT "-"
	HRLI A,MAPCON
	PUSHJ P,PRNLOC
	PUTBYT "-"
	POPJ P,
>;MWL

MWL,<
;WLOCOUT (WL) - TEST BODY FLAGS FOR WILD CONNECTOR
;A = ,,CPIN-LOC
;T = BODY BITS
WLOCOUT:
DEC,<	TRNE T,BWILD
	 PUTBYT WLDCHR
>;DEC
	TRNE T,CBODY
	 HRLI A,MAPCON
	JRST PRNLOC
>;MWL

;LOCOUT - PRINT BODY LOCS
;A = ...,,LOC
LOCOUT:	HRRZS A
	JRST PRNLOC

MDPC,<
;SLTLPN (DPC) - PRINT BODY LOCN (POSSIBLY WITH B-R-S)
				;CONVERT CALLS FROM MOVS
;A = B-R-S,,BODY-LOC
SLTLPN:	PUSH P,A
	PUSH P,T
	PUSH P,TT
	HLRZS A
	PUSHJ P,SLTOUT
	SKIPE TT
	 PUTBYT (TT)
	HRRZ A,-2(P)
	PUSHJ P,PRNLOC
	POP P,TT
	POP P,T
	JRST POPAJ
>;MDPC


MDPC,<

;PINPLS (DPC) - PRINT "pin#" with perhaps additional pin loc info if mapped
;A = PIN#
;B = ,,BODY-LOC
;C = PACKAGE TYPE
MPC,<
PINPLS:	JRST BPINPN
>;MPC

MD,<
MXSPCH__8			;ROOM FOR SOME TRIAL PATCHES
DEFINE FOO(DELTA,CHAR)
<ORG SPCHTB+DELTA  "CHAR"
IFG <DELTA-MXSPCH>,<MXSPCH__DELTA>
>
SPCHTB:	FOO(1,+)
	FOO(2,:)
ITS,<	FOO(3,)	>
NOITS,<	FOO(3,#)	>
ORG SPCHTB+MXSPCH

PINPLS:	SKIPE FORSOC		;FORCE THE SOCKET PIN #?
	 SKIPN B		;AND HAS A SOCKET?
	  JRST PINPL9		;NO, DO STANDARD
	HRLZS A			;PIN# IN LH
	HRR A,B			;PIN#,,LOC
	MOVE B,C
	PUSHJ P,MAPOST		;CONVERT TO SOCKET POST ON BOARD
	 JRST [	PUTSTR [ASCIZ /?/]	;ILLEGAL SOCKET
		POPJ P,]
	TLNE B,%MPLOC!%MPUNI	;POST IS WAY IN ANOTHER SOCKET!
	 JRST LOCPIN		;PRINT "<new loc>"
	JRST PRNPIN

PINPL9:	PUSHJ P,BPINPN		;Print bare pin number "#"
	JUMPE B,CPOPJ		;NO LOC NOW, JUST BODY PIN#
	HRRZM A,ORIGPN#
	HRLZS A			;PIN# IN LH
	HRR A,B			;PIN#,,LOC
	MOVE B,C
	PUSHJ P,MAPOST		;CONVERT TO SOCKET POST ON BOARD
	 JRST [	PUTSTR [ASCIZ /(??)/]
		POPJ P,]
	;;Pin got mapped to completely new socket, print in fulll
	TLNE B,%MPLOC!%MPUNI	;POST IS WAY IN ANOTHER SOCKET!
	 JRST [	PUTBYT "("	;PRINT "#(<new loc>)"
		PUSHJ P,LOCPIN
		PUTBYT ")"
		POPJ P,]
	TLNN B,%MPPIN		;POST IS SOME OTHER PIN IN SAME SOCKET
	 POPJ P,
	;;Pin got mapped to some other pin in same socket, print as "(#)" or "+"
	TLNE B,%MPFOR		;FORCE FULL PIN PRINTOUT?
	 JRST PINPL2		; (if some pins are full, all are)
	LDB T,[%%PINN,,A]	;THE MAPPED PIN #
	SUB T,ORIGPN		;HOW MUCH DID IT CHANGE BY?
	SKIPLE T
	CAIL T,MXSPCH
	 JRST PINPL2
	SKIPE T,SPCHTB(T)	;SPECIAL CHAR FLAG?
	 JRST [ PUTBYT (T) 	POPJ P,]
PINPL2:	PUTBYT "("		; PRINT "#(#)"
	PUSHJ P,PRNPIN
	PUTBYT ")"
	POPJ P,
>;MD
>;MDPC

MWL,<
;LOCPNM (WL) - PRINTS "post-name(pin-name)" - USED FOR WLZ
;LOCPNP (WL) - PRINTS "pin-name(post-name)" - USED FOR WLR
;A = MBITS+PIN#,,LOC
;B = PACKAGE CODE
LOCPNM:	AOSA POSPIN#
LOCPNP:	 SETZM POSPIN
LOCPNX:	PUSH P,A
	PUSHJ P,MAPOST
	 JRST [	POP P,A		;Mapping error
		PUSHJ P,LOCPIN	;PRINT "<pin-loc>(?)"
		PUTSTR [ASCIZ\(?)\]
		POPJ P,]
	SKIPN POSPIN
	 EXCH A,(P)		;PRINT <pin-loc> first
	PUSHJ P,LOCPIN
	POP P,A
	TLNE B,%MPLOC!%MPUNI
	 JRST [	PUTBYT "("
		PUSHJ P,LOCPIN
		PUTBYT ")"
		POPJ P,]
	TLNN B,%MPPIN
	 POPJ P,
	PUTBYT "("
	PUSHJ P,PRNPIN
	PUTBYT ")"
	POPJ P,
>;MWL

;LOCPIN - PRINT BODY LOC, THEN DIP PIN#
;A = MBIT+PIN#,,LOC

LOCPIN:	PUSHJ P,PRNLOC
	LDB T,[%%PINN,,A]	;No pin specified??
	JUMPE T,CPOPJ
	SKIPE TT		;Separator needed?
	 PUTBYT (TT)
	JRST PRNPIN

IFN 0,<
;CSLTOUT - PRINTS CONNECTOR SLOT (AS PADDLE SLOT)
;A = B-R-S,,CPIN-LOC		;FIX
CSLTOUT:
	MOVEI T,0
	PUSHJ P,CPNMAP		;CONVERT TO POST ON BACKPANEL
	 JFCL
	JRST SLTOUT
>;IFN 0


SUBTTL DESCRIPTION OF BOARD SPECIFIC ROUTINES

COMMENT 
                                      _________
                                      | BOARD |
                                      ---------

		LOCPNP		LOCPNM			RAYDIP
DISPLAY		WLZ		WLR			RAY
1(3)		1A29-3(1+)	1A29-1(3)		1A29(3)
1+		1A29-2(1+)	1A29-1(2)		1A29(2)
1(1A30-7)	1A30-7(1A29-1)	1A29-1(1A30-7)		1A30(7)
1(4)		1A29-4(1)	1A29@3-1(1A29-4)	1A29(4)


;GETSLT - READ B-R-S SPEC
;(SKIPS IF OK)
;DESTIN = B-R-S  (NUMREG = 0 MEANS CRLF ONLY)

;GTSLTT (WL) - (FIRST CHAR ALREADY IN CHRREG)


;SLTOUT - PRINT B-R-S
;A = ,,B-R-S  (With extent)
; (Check for 0)
; (Allows null Bay, Extent)
; (Returns separator char in TT, if not null)

;GTSLTL (DPC) - Read a BODY locn
;RETURNS:
;	- FAIL
;	- CRLF ONLY
;	- OK
;MD,<	- B-R-S, TOO  >
; (Note: Legal to have string following location - might be section)

;GTCONP (D) - READ AN 18 BIT CONNECTOR LOC (Possibly with B-R-S)
; (Hair for U-pins)
;DESTIN = (B-R-S),,CPIN-LOC

;GETLOC (WL) - READS EITHER BODY LOC, OR CONNECTOR LOC, YOUR GUESS
;SKIPS IF LEGAL
;TT = LOC (If connector, set MAPCON and only loc, not pin part)
; (TTT = LAST CHAR)

;LOCFUK (D) - CORRECTS OLD VERSION NOMEN ON BODY SLOTS
;T = ,,SLOT
;TT = RDVER
;RETURNS CORRECT SLOT SPEC IN T




                                      _________
                                      | BOARD |
                                      ---------

;PRNLOC - PRINTS SOCKET OR DIP LOC (POST IF UNIVERSAL BOARD)
;A = MBIT+... ,, LOC
;(CHECKS MAPCON)
;RETURNS: TT = SUGGESTED SEPARATOR CHAR BETWEEN LOC,PIN (0 IF NONE)

;PRNPIN - PRINTS PIN#
;A = MBIT+PIN#,,LOC
; (CHECKS MAPCON,MAPPWR,MAPGND) - WILD CPINS?

;RAYDIP (WL) - FORTRAN FORMAT PRINT
;A = MBIT+PIN#,,LOC
	 check for MAPCON
	PRINTS IN RAYTHEON FORMAT (I8)

;MAPIT (WL) - CONVERT POST INTO X,Y AND BITS
;NOTE!! X,Y are viewed from DIP side, usually with X+ = right, Y+ = up
;A = MBIT+PIN#,,LOC
;SKIPS IF LEGAL POST
;T = X,,Y
;TT = PWR!GND,,VOLTAGE (If dedicated pin on board)
;TTT = (DISTANCE TO END OF ROW - FOR FUDGING CITY-BLOCK STUFF)

;MAPOST (DWL) - CONVERT FROM DIP-LOC,PIN# TO SOCKET-LOC, PIN#
;  A = MBIT+PIN#,,LOC
;  B = PACKAGE
;Skips if can map, with MAPSOC set.
;  A = New MBIT+PIN#,,LOC
;  B = FLAGS,,
;	%MPLOC	;LOC WAS CHANGED
;	%MPPIN	;PIN WAS CHANGED, DIFFERENCE IN RH (TO CHECK FOR +1)
;	%MPUNI
;	%MPROT  etc.
;(Note: Pin 0 has a special hack just removes the within-socket offset, if any.)

;FGND (WL) - FIND GROUND PIN
;A = MBIT+PIN#,,LOC	;A Socket pin (MAPSOC)
;RETURNS A=0 IF FAILS
;A = New MBIT+PIN#,,LOC

;FPWR (WL) - FIND POWER PIN
;A = MBIT+PIN#,,LOC	;A Socket pin (MAPSOC)
;B = VOLTAGE (10 mV UNITS)
;RETURNS A=0 IF FAILS
;A = New MBIT+PIN#,,LOC

;PAKSIZ (WL) - GET DIMENSIONS OF PACKAGE ON BOARD
;A = MBIT+PIN#,,LOC
;B = PACKAGE CODE
;SKIPS IF LOCATION IS LEGAL FOR THIS PACKAGE TYPE
;T = Xmin,,Ymin
;TT = Xmax,,Ymax




                                      _________
                                      | BOARD |
                                      ---------

;CPNMER - MERGE CONNECTOR LOC, PIN# INTO 18 BITS
;T = CPIN JACK LOC
;TT = CPIN PIN#
;RETURNS: T = MAPCON,,CPIN-LOC
; (INITIALIZE TO FIRST IF T=0, CARRIES IF CPIN# TOO BIG)

;CPNSEP  - SEPARATE OUT LOC,PIN#
;T = ,,CPIN-LOC			;MAY BE 0 ?
;RETURNS:
;T = CPIN JACK LOC 	;Such that T = CPNSEP(T) = CPNSEP(CPNSEP(T)) = ...
;TT = CPIN PIN#

;CPNMAP - MAPS CARD, CPIN-LOC TO BACKPANEL PIN
;A = B-R-S,,CPIN-LOC
;T = SLOT OFFSET
;SKIPS IF SUCCESSFUL (FAILS IF B-R-S IS NULL)
;A = B-R'-S',,CPIN-LOC
; (CHECKS IF CPIN PADDLE WITHIN EXTENT)
; (ADDS SLOT OFFSET, CHECK IF WITHIN CARD CAGE)


                                      _________
                                      | BOARD |
                                      ---------

;SEQLOC (WL) - TEST IF BODY LOCS ARE "SEQUENTIAL"
; (USED BY 'STF' FOR PRODUCING FIRST-LAST SLOT RANGES)
;T = FIRST SLOT
;TT = SECOND SLOT
;SKIPS IF SEQUENTIAL

;QUPIN (DPCWL) - TEST IF LOC IS WILD LOC
;A = ,,CPIN-LOC
;SKIPS IF WILD
;A = RULE # (1,2,3  100'S DIGIT OF PIN #)

;CONGIN (WL) - GENERATE NEXT CPIN
; (USED BY 'SMP' ROUTINES - DEC)
;A = B-R-S,,CPIN-LOC
;SKIPS IF OK
	CPNSEP
	 AOS TT
	CPNMER
	CPNMAP
	 FAILS:	DON'T SKIP, PAST VALID PADDLE
	 OK:	SKIP, LEGAL CPIN THIS B-R-S

;MAPRC (WL) - MAP SEQUENTIAL INDEX INTO DIP LOC
;Given the UML X,,Y index, produce the DIP location
; that appears in that UML box.
;  NOTE!! The "row" and "col" are those on the UML page,
;	they AREN'T rows and cols on the board. Beware!

;T = ROW,,COL
;SKIPS IF OK
;T = ,,BODY-LOC
	USES:	NROWS
		NCOLS
		NCLPRG
		DIPSLT

;MAPPAD (WL) - MAP INDICES INTO CPIN
;T = PADDLE (OR JACK)
;TT = PADDLE LETTER (OR PIN IN JACK)
;TTT = PIN SIDE (For DEC AA1,AA2 pins)
;Returns
;T = MAPCON+PINN#,,CPIN-LOC
;(T = 0 IF ILLEGAL OR NON-EX)

;GNDCLR (WL) - Random, not used.
;GNDOUT (WL) - Random, not used.
;VCCOUT (WL) - Random, not used.
;WAGGND (WL) - Random
;CPARTP (WL) - Random



SUBTTL DEFAULT ROUTINES FOR BOARD TYPES TO USE
BEGIN DEFAULT
comment 

This block hides some routines that are shared among many board types.
Each label is prefixed with "$" and is made available in the outer block.


MWL,<
;SEPARATE CONNECTOR PIN BODY LOC (PADDLE) FROM PIN # (PIN, SIDE)
; For the purpose of grouping connector pins into bodies.
^$CPNSEP:
	MOVE TT,T		;FOR DEC NOMEN
	ANDI T,770000
	ANDI TT,7777
	POPJ P,

;MERGE CONNECTOR PIN BODY LOC WITH PIN #
^$CPNMER:
	DPB TT,[POINT 12,T,35]
	POPJ P,

>;MWL

;QUPIN	DETECT IF THIS PIN NAME IS "WILD" - ON THE "U" PADDLE
;CALL WITH PIN NAME IN RH(A) - BYTE(6)conn-body-locn(12)conn-pin-#
;RETURN "RULE" IN A (1,2,3)
^$QUPIN:
	PUSH P,A
	LSH A,-14
	ANDI A,77
	MOVE A,N2L(A)
	CAIE A,"U"
	JRST [	POP P,A
		POPJ P,]
	POP P,A
	ANDI A,3777
	PUSH P,B
	IDIVI A,=200
	POP P,B
	CAILE A,2
	TDZA A,A
	ADDI A,1
	JRST CPOPJ1
SUBTTL SEQLOC,CONGIN,..
MWL,<

;CALL WITH LESSER OF TWO LOCS IN T
;GREATER IN TT
^$SEQLOC:
	XOR T,TT
	TRNE T,770000		;LETTERS SHOULD BE THE SAME
	POPJ P,			;ELSE NOT IN SEQUENCE
	XOR T,TT
	SUB TT,T
	CAIN TT,1
	AOS (P)
	POPJ P,

^$CONGIN:
	PUSH P,A
	HRRZ A,A
	JUMPE A,CONG1
	TRNN A,2
	JRST [	TRC A,3
		JRST CONG3]
	LSH A,-6
	ANDI A,77
	ADDI A,1
	CAIG A,=18
	JRST [	LSH A,6
		TRO A,1
		DPB A,[POINT 12,(P),35]
		POP P,A
		JRST CPOPJ1]
	LDB A,[POINT 6,(P),23]
	ADDI A,1
	PUSH P,T
	LDB T,[POINT 3,-1(P),11]		;GET EXTENT
	CAIG A,1(T)			;DOES THIS PADDLE EXIST?
	JRST [	POP P,T
		JRST CONG2]
	POP P,T
	POP P,A
	POPJ P,

;VARIOUS FLAVORS OF RETURN FOR CONGIN

CONG1:	HRRZ A,L2N+"A"
CONG2:	LSH A,6
	IOR A,L2N+"A"
	HRRZ A,A		;CLEAR ANY LH GARBAGE
	LSH A,6
	TRO A,1
CONG3:	HRRM A,(P)
	POP P,A
	JRST CPOPJ1
>;MWL
SUBTTL	SLTOUT -- PRINTS DIP BAY/RACK/SLOT #

COMMENT 

|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|_____|
|				   18      21        26    29          35
|                 18		    |   4   |    5    |  3  |     6     |
|___________________________________|_______|_________|_____|___________|
		  |			|	 |	 |	  |
<		  |			|	 |	 |	  |------># SLOT
		  |			|	 |	 |
<		  |			|	 |	 |--------------->L +RACK
		  |			|	 |
<		  |			|	 |----------------------->L RACK
		  |			|
<		  |			|--------------------------------># BAY
		  |
<		  |------------------------------------------------------>NOT USED

;SLTOUT - PRINT B-R-S
;A = 0,,B-R-S

^$SLTOUT:
	LDB T,[POINT 4,A,21]
	JUMPE T,.+2
	PUSHJ P,PUTDEC
	LDB TT,[POINT 5,A,26]
MDPC,<	JUMPE TT,CPOPJ	>
	PUTBYT @N2L(TT)
	LDB TTT,[POINT 3,A,29]
	JUMPE TTT,SLTOU1
	ADD TT,TTT
	PUTBYT @N2L(TT)
SLTOU1:	MOVEI T,2
	MOVEM T,NDIG
	LDB T,[POINT 6,A,35]
	PUSHJ P,NPUTDEC
	SETZ TT,		;NO SEP CHAR SUGGESTED
	POPJ P,

SUBTTL SLTLN - DIP LOC READER
MDPC,<
;THE CANONICAL DIP LOC READER WHERE DIP LOC IS OF FORM L#
;SLTLN -- READS A BAY/RACK/SLOT/DIPLOC OR JUST A DIPLOC
;CALL IS:
;	PUSHJ P,SLTLN
;	JRST ERROR
;	JRST CRLF.ONLY
;MD,<	JFCL	>	;LOC ONLY
;	(BRS,,LOC IN DESTIN)

^$SLTLN:
SLTLN:	SETZM DESTIN
MPC,<	GETCH	>
MD,<	GETNUM
	CAIL NUMREG,20
	POPJ P,
	DPB NUMREG,[POINT 4,DESTIN,3]
>;MD
	CAIN CHRREG,12
	JUMPE NUMREG,CPOPJ1
	PUSHJ P,CHKLET
	POPJ P,
MD,<	PUSH P,D
	SKIPN D,L2N(CHRREG)
	JRST POPDJ
	DPB D,[POINT 5,DESTIN,8]
	GETNUM
	PUSHJ P,CHKLET
	JRST SLTLN1
	JUMPL D,SLTLN3		;GIOQ ILLEGAL FOR BRS
	POP P,D
	JUMPN NUMREG,SLTLN2
	LDB NUMREG,[POINT 5,DESTIN,8]
	SKIPN CHRREG,L2N(CHRREG)
	POPJ P,
	JUMPL CHRREG,[SUB CHRREG,NUMREG
		JRST SLTLN4]
	SUB CHRREG,NUMREG
	JUMPLE CHRREG,SLTLN4
	CAILE CHRREG,7	
	JRST SLTLN4
	DPB CHRREG,[POINT 3,DESTIN,11]
	GETNUM
	JUMPE NUMREG,CPOPJ
	PUSHJ P,CHKLET
	JRST SLTLN8
SLTLN2:	CAILE NUMREG,77
	POPJ P,
	DPB NUMREG,[POINT 6,DESTIN,17]
>;MD
	SKIPN CHRREG,L2N(CHRREG)
	POPJ P,
	DPB CHRREG,[POINT 6,DESTIN,23]
	GETNUM
	JUMPE NUMREG,SLTLN5
SLTLN7:	CAILE NUMREG,7777
	POPJ P,
	DPB NUMREG,[POINT 12,DESTIN,35]
MD,<	HLRZ NUMREG,DESTIN
	JUMPN NUMREG,CPOPJ3	;THIS RETURN IF BRS TYPED
>;MD
	JRST CPOPJ2		;THIS RETURN IF PC OR NO BRS

SLTLN5:	LDB NUMREG,[POINT 6,DESTIN,23]
	MOVE NUMREG,N2L(NUMREG)
	LSH NUMREG,7
	IOR CHRREG,NUMREG
	PUSHJ P,TWOLET
	POPJ P,
	DPB NUMREG,[POINT 6,DESTIN,23]
	GETNUM
	JUMPN NUMREG,SLTLN7
	POPJ P,

MD,<
SLTLN1:	POP P,D
	JUMPE NUMREG,CPOPJ
	CAILE NUMREG,7777
	POPJ P,
	DPB NUMREG,[POINT 12,DESTIN,35]
	LDB NUMREG,[POINT 9,DESTIN,8]
	CAIL NUMREG,40
	POPJ P,
	DPB NUMREG,[POINT 24,DESTIN,23]
	JRST CPOPJ2

SLTLN3:	MOVE D,N2L(D)		;GET LETTER BACK
	LSH D,7
	IOR CHRREG,D		;PUT 2 LETTERS IN CHRREG
	POP P,D			;RESTORE D
	PUSHJ P,SLTLN6
	POPJ P,
	JRST SLTLN9

SLTLN4:	PUSHJ P,SLTLN0
	POPJ P,
SLTLN9:	GETNUM
	JUMPN NUMREG,SLTLN7
	POPJ P,

SLTLN8:	PUSH P,NUMREG
	PUSH P,CHRREG
	LDB NUMREG,[POINT 5,DESTIN,8]
	LDB CHRREG,[POINT 3,DESTIN,11]
	PUSHJ P,SLTLN0
	JRST [	POP P,CHRREG
		POP P,NUMREG
		POPJ P,]
	POP P,CHRREG
	POP P,NUMREG
	JRST SLTLN7

SLTLN0:	ADD CHRREG,NUMREG	;GET NUMBER BACK
	MOVE NUMREG,N2L(NUMREG)	;GET FIRST LETTER BACK
	MOVE CHRREG,N2L(CHRREG)	;GET SECOND LETTER BACK
	LSH NUMREG,7
	IOR CHRREG,NUMREG
SLTLN6:	LDB NUMREG,[POINT 4,DESTIN,3]
	JUMPN NUMREG,CPOPJ
	PUSHJ P,TWOLET
	POPJ P,
	DPB NUMREG,[POINT 24,DESTIN,23]
	JRST CPOPJ1

POPDJ:	POP P,D
	POPJ P,
>;MD
>;MDPC




SUBTTL GETSLT -- READS A BAY/RACK/SLOT #

;CALL IS:
;	PUSHJ P,GETSLT
;	JRST ERROR
;	JUMPE TT,CRLF.ONLY	;THIS IS OPTIONAL, OBVIOUSLY
;	MOVEM TT,BRS

MWL,<
^$GTSLTT:
	SETZM DESTIN
	TGETNUM
	JRST GTSLT1
>;MWL

^$GETSLT:
	SETZM DESTIN
	GETNUM
GTSLT1:	DPB NUMREG,[POINT 4,DESTIN,3]
	PUSHJ P,CHKLET
	JRST [	JUMPE NUMREG,CPOPJ1
		POPJ P,]
	SKIPG CHRREG,L2N(CHRREG)
	POPJ P,
	DPB CHRREG,[POINT 5,DESTIN,8]
	GETNUM
	JUMPN NUMREG,GTSLT2
	PUSHJ P,CHKLET
	POPJ P,
	SKIPG CHRREG,L2N(CHRREG)
	POPJ P,
	LDB NUMREG,[POINT 5,DESTIN,8]
	SUB CHRREG,NUMREG
	JUMPL CHRREG,CPOPJ
	CAILE CHRREG,7
	POPJ P,
	DPB CHRREG,[POINT 3,DESTIN,11]
	GETNUM
GTSLT2:	DPB NUMREG,[POINT 6,DESTIN,17]
	JRST CPOPJ1
SUBTTL RDLLN - READ LETTER,LETTER, NUMBER

MD,<
;RDLLN - LOOK FOR "LL#" OR "U#"
;RETURN LL#	BYTE(6)L,L,#
;	U#	BYTE(6)U(12)4000+#
;	PUSHJ P,RDLLN
;	    ERROR RETURN
;	    SUCCESS RETURN

^$RDLLN:
RDLLN:	PUSHJ P,CHKLET
	POPJ P,
	SKIPG CHRREG,L2N(CHRREG)
	POPJ P,
	DPB CHRREG,[POINT 12,DESTIN,29]
	GETNUM
	JUMPN NUMREG,CKCR
	PUSHJ P,CHKLET
	POPJ P,
	LDB TT,[POINT 6,DESTIN,29]
	DPB TT,[POINT 6,DESTIN,23]
	SKIPG CHRREG,L2N(CHRREG)
	POPJ P,
	DPB CHRREG,[POINT 6,DESTIN,29]
	GETNUM
	JUMPE NUMREG,CPOPJ
CKCR:	LDB TT,[POINT 12,DESTIN,29]
	XOR TT,L2N+"U"
	TRNN TT,-1			;SAME LETTER?
	JRST [	CAILE NUMREG,3777	;YES, LEGAL NUMBER?
		POPJ P,			;NO
		HRRZ TT,L2N+"U"
		DPB TT,[POINT 6,DESTIN,23]
		TRO NUMREG,4000
		DPB NUMREG,[POINT 12,DESTIN,35]
		JRST CPOPJ1]
	CAILE NUMREG,77
	POPJ P,
	DPB NUMREG,[POINT 6,DESTIN,35]
	JRST CPOPJ1
>;MD
BEND DEFAULT
