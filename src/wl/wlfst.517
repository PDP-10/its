;<WIRELIST>WLFST.FAI.328, 29-NOV-75 17:58:36, EDIT BY HELLIWELL
TITLE WL

XALLNOLIT

EXTERNAL MAPOST,MAPCON,MAPSOC,%%PINN,$$PINN
EXTERNAL LCINIT,GETSLT,SLTOUT,PRNLOC,PRNPIN
EXTERNAL CPNMER,CPNSEP,CPNMAP,QUPIN
EXTERNAL PINCUE,SLTCUE
EXTERNAL BPINPN,RPNAM,LOCOUT
EXTERNAL GETNOM,CLRNOM,SETNOM,FNDNOM,AVAIL
EXTERNAL DEFNOM,LOCTVV,NOMTYP
EXTERNAL N2L,L2N,LNAMES,PUTDEC,MAXN2L

EXTERNAL GETLOC,RAYDIP,AUGDIP,CPARTP,SEQLOC,CONGIN,GTSLTT
EXTERNAL WBDCUE,CBCUE
EXTERNAL DEFWW,CLRWW,FNDWW,SETWW,WWTYP,WNAMES
EXTERNAL GETBRD,MAPOST
EXTERNAL APACK,PACKNM,MATPAK
EXTERNAL PINMAP,PINBIT,BPNPIN,PRBCN,PRCNPN,LOCPNW
EXTERNAL LOCPNC,PADPRT,WLOCOUT,LOCPNM,LOCPNP

EXTERNAL NROWS,NCOLS,NCLPRG,NRWPRP,DIPSLT,NPADS,PADLET
EXTERNAL PADPIN,FRACTN,WRAPMG,POSTMG,NEXTR
EXTERNAL MAPRC,WAGGND,ISWW,FGND,FPWR,RPNAMA
EXTERNAL WWINIT,MAPPAD,DSTCLC,MAPIT,PAKSIZ,GNDCLR
EXTERNAL GNDOUT,VCCOUT

EXTERNAL NPACK,PACKPN,PAKSIZ,MAKCPN,WIRGND,LNGRID
EXTERNAL LOCPIN,DECOUT,NDECOU,TRPNAM

INTERNAL CPOPJ,CPOPJ1,CPOPJ2,CPOPJ3,POPAJ
INTERNAL SLICEL,DECIN,TDECIN,TCOUNT,TFILL,TTFILL,NDIG
INTERNAL TREADU,PUTFS,GETCHR, FUCKUP

VMAJOR__8	;MAJOR VERSION #
VMINOR__0	;MINOR VERSION LETTER
VGROUP__2	;MODIFYING GROUP
VEDIT__30	;EDIT NUMBER

ORG	137
	<BYTE (3) VGROUP (9) VMAJOR (6) VMINOR>+VEDIT
ORG
;IO CHANNELS, IOVERSIONS, FLAG BITS, ACS
;IO CHANNEL ASSIGNMENTS
DAT__0
LST__1
IDSK__2
DECOS,<TTYCHN__3>

ITS,<FONTCH__4>

;SOME FILE EXTENSIONS AND VERSION STUFF
NODEC,<
NOIII,<
CMU,<	EXTSAV__'SAV'	>
NOCMU,<	EXTSAV__'DMP'	>
ITS,<	EXTSAV__'BIN'	>
>;NOIII
>;NODEC

;IO VERSION #'S
WDVER__15
WPCVER__400002
WDRVER__1
BACVER__13
LESVER__1
DIPVER__5

COMMENT 
;WDVER CHANGES
14	??
15	Package info in bodies.

;DIPVER changes
4	??
5	Package name string in DIP


;DEFINITIONS

;SPECIAL CHARACTER DEFS
	GENCHR__"%"	;FIRST CHAR OF GENERATED NAMES
	GENLEN__=20	;MAX LENGTH OF PIN NAME
			;BBRRSS LNNNN(PPPPPP)
	GNPCLN__GENLEN-7	;NEVER NEED BBRRSS FOR PC
	FORALL__""	;"BOTH" CHAR FOR P COMMANDS
NOSKEY,<NOTCHR__"">	;NOT AT STANFORD
SKEY,<	NOTCHR__"-">	;MINUS AT DEC
ITS,<	NOTCHR__"-">	;ALSO MIT
STANFO,<ALTMOD__175	>
NOSTANFO,<ALTMOD__33		>
	ALTCHR__33	;ALTMODE FROM DSKIN IF ALTMOD IS NOT EQUAL TO 33
NOSKEY,<CBCHR__"'">	;CHAR WHICH INCREMENTS CONTROL BITS FOR TTY
SKEY,<	TEXIST__"">	;THERE EXISTS CHARACTER FOR FILENAME
NOSKEY,<TEXIST__25>
	WLDCHR__"*"
NOSKEY,<BWAROW__"">
SKEY,<	BWAROW__"@">
NOSTANFO,<UBAR__"_">
STANFO,<UBAR__"">
NOSKEY,<
	CTRL__""	;CONTROL
	META__3		;META
	CTLMTA__""	;BOTH
INTERNAL CTRL,META,CTLMTA
>;NOSKEY


;SPECIAL TYPE CHARACTERS
PWRCHR__"V"
GNDCHR__"G"

;CONTROL CODES FOR 'LES' FILE
LESWIR__1		;THE FOLLOWING IS A WIRE

;DAT FILE OUTPUT NAME (TO FORTRAN)
DATNAM__<'FOR20 '>

;MAX PINS IN RUN FOR ROUTER
MAXP__=64	;NUMBER PINS/RUN MAX.

;MAX # OF PINS FOR VERIFY STUFF (TABLE LIMITATION) - BODY/DIP MATCHING ERRORS
MAXPIN__=64	;ALLOW 64 PIN IC'S

;# OF BITS OF HASH FOR SIGNAL NAMES
HASHB__=9	;TRY 9 FOR NOW
HASHL__1HASHB	;SIZE OF TABLE

;MAX LENGTH OF SIGNAL OR BODY NAME IN WORDS
MXSTLN__=500/5	;WHAT ABOUT [<><><><><>]

PDLLEN__1000	;OH WELL, THIS IS THE PRICE YOU PAY FOR RECURSIVE ROUTINES

RADIX =10
;BOTTOM PAGE MARGINS FOR VARIOUS OUTPUT STUFF
FILMAR__4		;FILLST OUTPUT AT FRONT OF MOST FILES
WLBMAR__7		;'WL' BODIES
WLWMAR__10		;'WL' WIRES
WLZMAR__10		;'WLZ' WIRES
WDCMAR__4		;'BL' DIP COUNTS
WSBMAR__15		;'WLS' BODIES
PREMAR__3		;'WLS' PART NUMBER ERRORS
BVMAR__20		;'WLS' VERIFY CONNECTOR PIN USAGE
TRCMAR__20		;'WLS' CHECK FOR TERMINATOR RULES
POLMAR__2		;'WLS' POLARITY ERRORS
WSWMAR__8		;'WLS' SIGNAL NAMES
STFMAR__3		;'STF' DIP STUFFING LIST
PRTMAR__2		;'PRT' PARTS LIST
OTSMAR__6		;'OTS' OUTPUT TERMINATION SUMMARY
OTLMAR__2		;'OTL' TERMINATION TEST POINT LIST
MPLMAR__20		;'MPL' MASTER PARTS LIST
MPMMAR__2		;'MPL' MODULE COUNT LIST
WUPMAR__20		;'WLU' BODY/PIN/SIGNAL
WUCMAR__3		;'WLU' CON PIN/SIGNAL
WVMAR__15		;'WLV' VERIFY BODIES AND PINS
WSSMAR__4		;'WSS' SIGNAL SUMMARY
WCIMAR__15		;'WLC' INCORRECT WIRES
WLDMAR__5		;'WLD' INCORRECT PINS/SOCKET
WCWMAR__20		;'WLC' WHOLE WRONG WIRES
WCLMAR__5		;'WLC' SINGLE PINS
WWPMAR__15		;'WWC' WIRE WRAP OUTPUT
DIPMAR__5		;'LSD' DIP LIST
UMLMAR__6		;'UML' 6 LINES PER ROW OF DIPS
DEC,<
SREMAR__2		;'SR' EDGE PIN LIST
SRDMAR__2		;'SR' DIPTYPE LIST
SRNMAR__5		;'SR' NODE LIST
>;DEC

RADIX 8

;PAGE SIZE FOR OUTPUT STUFF
NODECOS,<
STDPAG__=52
STDWID__=120
>;NODECOS
DECOS,<
STDPAG__=60
STDWID__=132
>;DECOS
ITS,<
STDPAG__=60
STDWID__=132
XGPHBI__=192		;XGP HORIZONTAL BITS PER INCH
XGPVBI__=192		;XGP VERTICAL BITS PER INCH
>;ITS
;MACROS
	DEFINE GETFS $ (A,BLK)
<%%BLK__IFDIF<BLK><><V.$BLK;>1
	SKIPN A,@FSTPNT+%%BLK
	JSR NOFST
	EXCH A,FSTPNT+%%BLK
>

	DEFINE FSTRET $ (A,BLK)
<%%BLK__IFDIF<BLK><><V.$BLK;>1
	HLLI A,
	EXCH A,FSTPNT+%%BLK
	HRRZM A,@FSTPNT+%%BLK
>

	DEFINE PGETFS $ (A,BLK)
<%%BLK__IFDIF<BLK><><V.$BLK;>1
	MOVEI A,%%BLK+1
	ADD A,FSTOP
	CAMLE A,.JBREL
	JSR MORCOR
	EXCH A,FSTOP
USAGE,<AOS FSTCNT+%%BLK>
>
SUBTTL	STRUCTURE MACROS
;THE FOLLOWING NAMES ARE USED IN STRUCTURE POINTER DEFINITIONS
;F.XXX		INSTRUCTION TO FETCH VALUE
;S.XXX			"	STORE   "
;V.XXX		VALUE OF INDEX INTO BLOCK
;		OR LENGTH OF A BLOCK-1
;C.XXX		INSTRUCTION TO CLEAR CELL

DEFINE CAT $ (A,B)<A$B>

DEFINE FETCH $ (AC1,AC2,INDEX)
<	F.$INDEX	AC1,V.$INDEX(AC2)
>

DEFINE STORE $ (AC1,AC2,INDEX)
<	S.$INDEX	AC1,V.$INDEX(AC2)
>

DEFINE CLEAR $ (AC1,INDEX)
<	C.$INDEX	V.$INDEX(AC1)
>

DEFINE BCLEAR $ (AC1,AC2,INDEX)
<	SETZM (AC2)
IFG V.$INDEX,<
	MOVSI AC1,(AC2)
	HRRI AC1,1(AC2)
	BLT AC1,ADDR(AC2,INDEX)
    >
>

DEFINE SBLOCK
<	INDEX__0
>

DEFINE EBLOCK $ (NAME)
<	V.$NAME__INDEX-1
IFG INDEX-FSTLEN<FSTLEN__INDEX>
>

DEFINE ADDR $ (AC1,INDEX)<V.$INDEX(AC1)>

DEFINE RADDR $ (AC1,INDEX1,INDEX2)<V.$INDEX1-V.$INDEX2(AC1)>

DEFINE HWDS $ (LEFT,RIGHT,LE,RE)
<
IFDIF<LEFT><><
IFDIF<LE><E><DEFINE F.$LEFT <HLRZ >>
IFIDN<LE><E><DEFINE F.$LEFT <HLRE >>
DEFINE S.$LEFT <HRLM >
DEFINE C.$LEFT <HRRZS >
V.$LEFT__INDEX
>
IFDIF<RIGHT><><
IFDIF<RE><E><DEFINE F.$RIGHT <HRRZ >>
IFIDN<RE><E><DEFINE F.$RIGHT <HRRE >>
DEFINE S.$RIGHT <HRRM >
DEFINE C.$RIGHT <HLLZS >
V.$RIGHT__INDEX
>
INDEX__INDEX+1
>

DEFINE FWD $ (WORD)
<
IFDIF<WORD><><
DEFINE F.$WORD <MOVE >
DEFINE S.$WORD <MOVEM >
DEFINE C.$WORD <SETZM >
V.$WORD__INDEX
>
INDEX__INDEX+1
>
SUBTTL NOTES

COMMENT 
NOTES:
--------------------------------------------------------------------------------
WIRE FORMAT:

                       (ALPH)                      (ALPH)   
WIRES --- <HEADER> ------------- <EQUIVALENTS> --------- ... other signals ...
             SIG1    - \             -SIG1                 
              |           \                                 
              | (NNAM)    |                                 
                         |                                
           <OTHER NAME>   |                                
             NAM2ND       |                                 
             (WPIN) ------                               
              |                                             
              | (NNAM)                                
                                                          

Note: Only the "header" signal has the wire. The equivalents are alpha sorted
	after the header, as is the NAM2ND list.

---------------------------------------------------------------------------

Body list:
	Bodies are in list (WBDY) sorted by BLOC, BID, and containing file.
	Bodies with the same slot locn, but different BIDs are stored
	separately.

	After all the normal bodies, there are "connector bodies" which
	bundle all the pins for one paddle together. 

Locations: 
	The board slot is given by FCRD in the wirelist header. 
	For normal bodies the slot specification is stored in BLOC. 
	The pin location is found in PINN.

	For connector bodies the BLOC gives the paddle (or jack locn) and
	the pin# is the pin locn within the jack. 
	However there is also an 18 bit format that combines the loc and pin#.
	There exist routines, CPNMRG and CPNSEP to convert both ways.
	The main reason this is different from DIPs is:
	  o  In the drawing program, only 18 bits are allocated for
		CPIN location on the board. Therefore the "dip location"
		and pin name must fit in one halfword.
	  o  For backpanel wirelists, the "body loc" is the card B-R-S,
		and the PINN is the CPIN loc.

---------------------------------------------------------------------------

HASHTB:
All the signals are strung onto one list, however segments are pointed to by
buckets in the hash table.
Each entry is:
	Previous(List),, end of list

(The first bucket is used for generated signal names.)
The first bucket is initialized to point to the wire header "WIRES" slot.

---------------------------------------------------------------------------
Invented PWR/GND signals.

When the bodies are read in from a WD file, any DIPTYPE that has pins
marked as type PWR or GND will have a signal created for it, marked
by the INVENT bit. The Volts column of the DIP definition is used to
create a signal called "+5.0V" for example.

When signal names are read-in, GND, VCC, HI, NC, and all forms like +5.0V
are checked for, and appropriate bits set in the signals flags.

When a DIP pin that was V or G is explicitly wired in the input file,
the invented pin is found and deleted. This allows user wiring of DIP pins that
normally get automatically connected to power or ground.
---------------------------------------------------------------------------

SUBTTL	DATA STRUCTURES
;		STRUCTURE DEFINTIONS

FSTLEN__2			;THIS WILL ACCUMULATE LONGEST BLOCK


;PC OR D LIST HEADERS

SBLOCK
HWDS	(BKNM,BLST)		;BACK PANEL FILENAME LIST AND WIRE LIST
				;BKNM MUST BE LEFT HALF POINTER
HWDS	(WLNM,WIRL)		;TITLE STRING AND D WIRELIST POINTER
				;WIRL MUST BE RIGHT HALF
HWDS	(WLID,PCWL)		;ID STRING AND PC WIRELIST POINTER
				;PCWL MUST BE RIGHT HALF
HWDS	(,INXT)			;NEXT WIRE LIST (ID)
EBLOCK	LSTHEAD
NIL,<BKNM#,BLST#,WLNM#,WIRL#,WLID#,PCWL#,INXT#,LSTHEAD#,>

;FILENAME BLOCK FOR LIST OF FILENAMES FOR BACK PANEL LIST
;AND SINGLE CARD WIRE LISTS

SBLOCK
FWD	(FILN)			;FILENAME
HWDS	(FEXT,)			;EXT AND UNUSED
FWD	(FPPN)			;PPN
FWD	(FDAT)			;DATE AND TIME FROM LOOKUP OF DRW FILE
FWD	(FPOL)			;NUMBER OF POLARITY CHECK ERRORS FOUND BY DWG PROG
HWDS	(FNXT,FMOD)		;NEXT FILENAME LINK AND MODULE NAME POINTER
				;FNXT MUST BE LEFT HALF POINTER
HWDS	(FVAR,FPRF)		;VARIABLE AND PREFIX
HWDS	(TIT1,TIT2)		;TITLE LINES 1 AND 2
HWDS	(FREV,AUTHOR)		;REVISION STRING AND AUTHOR
HWDS	(FPROJ,FPAGE)		;PROJECT AND PAGE STRINGS
HWDS	(FOF,FNXH)		;OF STRING AND NEXT HIGHER ASSEMBLY STRING
HWDS	(FWWT,FNOM)		;BOARD TYPE STRING AND NOMENCLATURE TYPE STRING
HWDS	(MUBN,MLBN,E,E)		;VARIABLE UPPER, LOWER BOUNDS FROM INPUT TERM
HWDS	(MCRD,MVLS)		;CARD LOC, VARIABLE LIST FROM INPUT TERM
EBLOCK	FBLK
NIL,<FILN#,FEXT#,FPPN#,FDAT#,FPOL#,FNXT#,FMOD#,FVAR#,FPRF#,TIT1#,TIT2#,FREV#,
AUTHOR#,FPROJ#,FPAGE#,FOF#,FNXH#,FWWT#,FNOM#,MUBN#,MLBN#,MCRD#,MVLS#,FBLK#,>


;NORMAL WIRE LIST HEADER UNIT (ONE CARD)

SBLOCK
HWDS	(NGEN,NXTWL)		;GEN NUMBER AND NEXT WLBLOCK
				;NXTWL MUST BE RIGHT HALFWORD
HWDS	(FILS,WIRES)		;FILENAME LIST AND SIGNAL LIST
				;WIRES MUST BE RIGHT HALFWORD
HWDS	(FCRD,WBDY)		;LAST CARD AND LOC BLOCKS
				;WBDY MUST BE RIGHT HALFWORD
FWD(HASHTB)			;FIRST WORD OF HASH TABLE
INDEX__INDEX+HASHL-1		;REST OF TABLE
EBLOCK	WLBLOCK
NIL,<NGEN#,NXTWL#,FILS#,WIRES#,FCRD#,WBDY#,HASHTB#,WLBLOCK#,>


;BODY BLOCK

SBLOCK
HWDS	(DIPT,NXTB)		;DIPTYPE POINTER AND NEXT BODY
HWDS	(BID,BPIN)		;BODY ID AND BODY PIN LIST
				;BPIN MUST BE RIGHT HALF POINTER
HWDS	(BBIT,BPAK)		;BODY BITS,,	PACKAGE CODE FROM D
HWDS	(PRPX,PRTN)		;EXTRA PROPERTIES LIST AND PART NUMBER BLOCK POINTER
HWDS	(BLOC,FILB)		;BODY LOC AND FILENAME POINTER
FWD	(BNAM)			;FIRST WORD OF BODY NAME (THE REST FOLLOW SEQUENTIALLY)
EBLOCK	BHEAD
NIL,<DIPT#,NXTB#,BID#,BPIN#,BBIT#,BPAK#,PRPX#,PRTN#,BLOC#,FILB#,BNAM#,BHEAD#,>

;WIRE HEADER

SBLOCK
HWDS	(WBIT,ALPH)		;WIRE BITS AND TEXT LINK
				;ALPH MUST BE RIGHT HALF POINTER
HWDS	(TBIT,WPIN)		;TYPE BITS AND PIN LIST
				;WPIN MUST BE RIGHT HALF POINTER
HWDS	(NNAM,WTMP)		;NEXT NAME FOR WIRE AND TMP STORE
HWDS	(WVOL,WRN,E,)		;VOLTAGE (SPWR) AND WIRE RULE NUMBER (BP ONLY)
FWD	(SCMP)			;COMPARE WORD
FWD	(SPNT)			;PRINT NAME (MUST FOLLOW SCMP)
EBLOCK	WHEAD
NIL,<WBIT#,ALPH#,TBIT#,WPIN#,NNAM#,WTMP#,WVOL#,WRN#,SCMP#,SPNT#,WHEAD#,>
;WBIT - type bits for signal (SNC, etc.)
;TBIT - combined type bits for pins on this wire

;PIN BLOCK

SBLOCK
HWDS	(PBDY,NXTP)		;BODY POINTER AND NEXT PIN
				;NXTP MUST BE RIGHT HALF POINTER
HWDS	(HPNT,NXBP)		;POINTER TO WHEAD AND BODY PIN LINK
HWDS	(PID,PINN)		;POINT ID AND PIN #
INDEX__INDEX-1
HWDS	(CBIT,)			;FOR BACK PANEL, PID IS REALLY CBIT
HWDS	(PBIT,FILP)		;PIN BITS AND FILENAME POINTER
HWDS	(PTYP,RDCN)		;TYPE POINTER AND REDAC LIBRARY NUMBER
INDEX__INDEX-1
HWDS	(HILD,LILD,E,E)		;HI LOADING FOR BP PIN, NOT PTYP, RDCN
EBLOCK	PHEAD
HWDS	(HOLD,LOLD,E,E)		;LOW LOADING FOR BP PIN.
HWDS	(FILO,)			;SOURCE FILE BLOCK POINTER AND UNUSED
EBLOCK	BPHEAD
NIL,<PBDY#,NXTP#,HPNT#,NXBP#,PID#,PINN#,CBIT#,PBIT#,FILP#,PTYP#,RDCN#,
HILD#,LILD#,HOLD#,LOLD#,FILO#,BPHEAD#,>

;DIP TYPE HEADER BLOCK

SBLOCK
HWDS	(DNAM,NXTD)		;DIPNAME AND NEXT POINTER
HWDS	(DPNN,DPIN)		;NUMBER OF PINS ACTUALLY DEFINED ON DIP, DIP PIN LIST
FWD	(DTMP)			;TMP CELL FOR DIP COUNTS
HWDS	(PRPN,PRPV)		;PROPERTY NAME LIST, PROPERTY VALUE LIST
HWDS	(DPAK,)			;PACKAGE CODE FOR DIP
EBLOCK	DHEAD
NIL,<DNAM#,NXTD#,DPNN#,DPIN#,DTMP#,PRPN#,PRPV#,DPAK#,DHEAD#,>

;DIP PIN BLOCK

SBLOCK
HWDS	(DPBIT,DPNXT)		;BITS AND NEXT
FWD	(DUSE)			;SIXBIT USE FIELD
HWDS	(LHI,LLOW,E,E)		;HI AND LOW LOADING
HWDS	(SCTB,SCTP)		;SECT BITS AND SECT PIN #
HWDS	(PSWP,DPNM)		;PIN SWAPPING/SHARING # AND PIN NAME
EBLOCK	DPHEAD
NIL,<DPBIT#,DPNXT#,DUSE#,LHI#,LLOW#,SCTB#,SCTP#,PSWP#,DPNM#,DPHEAD#,>

;PROPERTY NAME BLOCK

SBLOCK
HWDS	(PRNN,PRNS)		;NEXT PROPERTY NAME BLOCK AND PROPERTY NAME STRING
EBLOCK	PNBK
NIL,<PRNN#,PRNS#,PNBK#,>

;PROPERTY VALUE BLOCK

SBLOCK
HWDS	(PRBT,PRNV)		;PROPERTY VALUE BITS AND NEXT PROPERTY VALUE BLOCK
HWDS	(PRPP,PRNP)		;PREVIOUS PROPERTY VALUE (UP TREE) AND NEXT PROPERTY VALUE (DOWN TREE)
HWDS	(PRNB,PRVS)		;PROPERTY NAME BLOCK AND PROPERTY VALUE STRING
EBLOCK	PVBK
NIL,<PRBT#,PRNV#,PRPP#,PRNP#,PRNB#,PRVS#,PVBK#,>

;BACK PANEL MODULE INFO BLOCK

SBLOCK
HWDS	(MNUM,MNXT)		;MODULES PER MACHINE, NEXT MODULE BLOCK
HWDS	(MNAM,)			;MODULE NAME STRING
EBLOCK	BMOD
NIL,<MNUM#,MNXT#,MNAM#,BMOD#,>

;PARTS LIST THREAD BLOCK

SBLOCK
HWDS	(PLBT,NXPL)		;PLBK BITS, NEXT PLBK
HWDS	(PLPT,MDCN)		;POINTER TO PVBK OF PART NUMBER, MASTER PART COUNT LIST(MDBLOCK)
EBLOCK	PLBK
NIL,<PLBT#,NXPL#,PLPT#,MDCN#,PLBK#,>

;MASTER COUNT DIPTYPE BLOCK

SBLOCK
HWDS	(MDIP,MDNX)		;DIPTYPE, NEXT (MDBLOCK)
HWDS	(,MXPT)			;POINTER TO EXTRA PART BLOCK (MXBLOCK)
EBLOCK	MDBLOCK
NIL,<MDIP#,MDNX#,MXPT#,MDBLOCK#,>

;MASTER COUNT EXTRA PROPERTY BLOCK

SBLOCK
HWDS	(MPRX,MXNX)		;EXTRA PROPERTY LIST, NEXT (MXBLOCK)
HWDS	(,MCPT)			;PART COUNT BLOCK POINTER
EBLOCK	MXBLOCK
NIL,<MPRX#,MXNX#,MCPT#,MXBLOCK#,>


;MASTER COUNT PART COUNT BLOCK

SBLOCK
HWDS	(MODC,MCNX)		;MODULE COUNT BLOCK POINTER (BMOD), NEXT (MCBLOCK)
FWD	(MAPP)			;APPROXIMATE COUNT
FWD	(MREA)			;REAL COUNT
EBLOCK	MCBLOCK
NIL,<MODC#,MCNX#,MAPP#,MREA#,MCBLOCK#,>


;DIRECTORY LIST BLOCK

SBLOCK
HWDS	(DEXT,DIRNXT)
FWD	(DFIL)
FWD	(DPPN)
HWDS	(,CVAR)			;CARD AND VARIABLE LIST POINTER (MUST BE RIGHT HALF)
EBLOCK	DIRHEAD
NIL,<DEXT#,DIRNXT#,DFIL#,DPPN#,CVAR#,DIRHEAD#,>


;CARD LOC AND BOUND BLOCK

SBLOCK
HWDS	(,NSLC)			;NEXT SLICE
HWDS	(CDLC,VLST)		;CARD LOC AND VARIABLE LIST POINTER
HWDS	(LBND,UBND,E,E)		;UPPER AND LOWER BOUNDS (EXTEND SIGN ON FETCH)
EBLOCK	CBND
NIL,<NSLC#,CDLC#,VLST#,LBND#,UBND#,CBND#,>


;VARIABLE BLOCK IN VARLIST

SBLOCK
HWDS	(VAL,NVAR,E)		;VALUE(EXTEND SIGN ON FETCH) AND NEXT
HWDS	(WID,LET)			;WIDTH,,LETTER
EBLOCK	VBLK
NIL,<VAL#,NVAR#,WID#,LET#,VBLK#,>


;GND AND VCC PIN BLOCKS FOR ROUTER

ROUTE,<
SBLOCK
HWDS	(PNTR,NWRD)			;PIN POINTER,,NEXT BLOCK
FWD	(PNAM)				;PIN NAME
EBLOCK	WBLK
>;ROUTE
NIL,<PNTR#,NWRD#,PNAM#,WBLK#,>


;CURRENT@VOLTAGE LIST FOR WLS FILE

SBLOCK
HWDS	(VLTS,NXTM,E)		;VOLTS (W/SIGN) AND NEXT BLOCK POINTER
FWD	(MAMP)			;# OF MILLIAMPS AT VOLTS
EBLOCK	MABLK
NIL,<VLTS#,NXTM#,MAMP#,MABLK#,>


;2 WORD TMP LIST BLOCK

SBLOCK
HWDS	(TVAL,NXTT)		;FLAG,,		LINK
HWDS	(TLFT,TRHT)		;LEFT AND RIGHT TEMP CELLS
EBLOCK	TBLK
NIL,<TVAL#,NXTT#,TLFT#,TRHT#,TBLK#,>


;COUNT BLOCK FOR WSS, WCS, AND WLS PRINT SUBR
SBLOCK
HWDS	(CFIL,NXTC)		;FILE POINTER AND NEXT
HWDS	(ICNT,OCNT)		;# INPUTS, #OUTPUTS
HWDS	(CCNT,ZCNT)		;# CONNECTORS+BITS, # TERMINATORS
EBLOCK	CBLK
NIL,<CFIL#,NXTC#,ICNT#,OCNT#,CCNT#,ZCNT#,CBLK#,>
SUBTTL	DATA
DEFINE DATA(LABEL,SIZE)
<
LABEL
IFIDN <SIZE><><BLOCK 1>
IFDIF <SIZE><><BLOCK SIZE>
>;END DATA

SAVEXT__'DMP'
CMU,<SAVEXT__'SAV'>

ITS,<	VALBFL__=80/5	>	;SIZE OF ITS VALRET BUFFER, 80 CHARACTERS

	LIBPPN_'DATDRW'
CMU,<	LIBPPN_<10053,,473002>>	;E130RG02
DEC,<
NOVIROS,<	LIBPPN__0	>
VIROS,<	LIBPPN__<4,,253>	>
>;DEC
III,<LIBPPN__<10,,76>>

DIPPPN:	LIBPPN

ZEROBEGIN:
ITS,<
	DATA	XGP:
	DATA	XGPVSP:
	DATA	XGPFNT:
	DATA	XGPEXT:
	DATA	XGPPPN:
	DATA	VALBUF:,VALBFL
	DATA	IMAGE:
>;ITS
	DATA	LOADMG:
	DATA	GNDFLG:
	DATA	OFFSET:
	DATA	MSINGL:
	DATA	USEDWL:
	DATA	CURDIP:
	DATA	DEPTH:
	DATA	VARERR:
	DATA	SIGCHR:
	DATA	EXPER2:
	DATA	DVER:
	DATA	LOW2UP:
	DATA	LOSBIT:
	DATA	LOSNAM:
	DATA	CONFLG:
	DATA	WWPBDY:
	DATA	WWPBIT:
	DATA	WWPTYP:
	DATA	WWFILN:
	DATA	WWPINN:
	DATA	UPINS:,MAXPIN
	DATA	STRTAB:,MXSTLN
	DATA	TPTRP:
	DATA	TTPTRP:
	DATA	ANYOVR:
	DATA	TTYFLG:
	DATA	SECTMP:
	DATA	LSTDIP:
	DATA	LSTBOD:
	DATA	FSTBOD:
	DATA	DOOVLP:
	DATA	NEEDER:
	DATA	DIDERR:
	DATA	PRPPTR:
	DATA	PRXPTR:
	DATA	PININC:
	DATA	BSLOT:
	DATA	BAKBIT:
	DATA	BAKILD:
	DATA	BAKOLD:
	DATA	BAKSFL:
	DATA	CDSKPC:
	DATA	GINPIN:
	DATA	LSLOT:
	DATA	FSLOT:
	DATA	TOTDIP:
	DATA	REALDV:
	DATA	WLLIST:
	DATA	REFLST:
	DATA	PRPLST:
	DATA	PID:
	DATA	WIRTMP:
	DATA	SHRNUM:
	DATA	PADDLE:,MAXPAD
	DATA	MROW:
	DATA	MROWPP:
	DATA	GSAVE:
	DATA	UMLEHT:
	DATA	UMLPGF:
	DATA	MCOL:
	DATA	COLLOP:
	DATA	LSTPIN:
	DATA	DEFLST:
	DATA	ERRP:
	DATA	FACTR1:
	DATA	FACTR2:
	DATA	DISPWD:
	DATA	PROMPT:
	DATA	DOOXWD:
	DATA	FSTPNT:,FSTLEN
USAGE,<	DATA	FSTCNT:,FSTLEN
	DATA	FSTTMP:,FSTLEN
>;USAGE
	DATA	FSTOP:
	DATA	SHIFT:
	DATA	GOODW:
	DATA	BADW:
	DATA	LAST:
	DATA	SIGN:
	DATA	SAVEA:
	DATA	SAVEB:
	DATA	SAVET:
	DATA	UUOSAV:
	DATA	MIN:
	DATA	DIPLST:
	DATA	PARTLIST:
	DATA	NULPART:
	DATA	LSTPART:
	DATA	LPRPX:
	DATA	DIRLST:
	DATA	IDRLST:
	DATA	STRING:
	DATA	DSTRNG:
	DATA	NEWPNT:
	DATA	GETCHR:
	DATA	PUTCHR:
	DATA	SVPTCH:
	DATA	SLICE:
	DATA	SLICEL:
	DATA	LOWER:
	DATA	UPPER:
	DATA	WIDTH:
	DATA	VARLST:
	DATA	BESLOC:
	DATA	BESPIN:
	DATA	PINLOC:
	DATA	PINNUM:
	DATA	PINTMP:
	DATA	BID:
	DATA	DEFEXT:
	DATA	THSFIL:
	DATA	OLDBOD:
	DATA	DIPPNT:
	DATA	LETTER:
	DATA	NUMBER:
	DATA	HEADER:
	DATA	LINCNT:
	DATA	PAGLEN:
	DATA	LWIDTH:
	DATA	MARGIN:
	DATA	OVRFLW:
	DATA	SMPCNT:
	DATA	TCOUNT:
	DATA	LCOUNT:
	DATA	NBODS:
	DATA	RBODS:
	DATA	NDIPS:
	DATA	TMPCN1:
	DATA	TMPCN2:
	DATA	AMPLST:
	DATA	LSTHD:,3
	DATA	LSTBUF:,210*2
	DATA	DATHD:,3
	DATA	DATBUF:,210
	DATA	LSTNAM:
NODEC,<
NOIII,<	DATA	(SAVBLK:)	;THIS MUST PRECEDE FILNAM FOR SWAP UUO
>;NOIII
>;NODEC
	DATA	FILNAM:
	DATA	FILEXT:
	DATA	FILDAT:
	DATA	FILPPN:
	DATA	ATPPN:
CMU,<	DATA	PPNBUF:,3 >	;FOR CONVERTING PPN'S
	DATA	PNTNAM:
	DATA	PNTEXT:
	DATA	PNTDAT:
	DATA	PNTPPN:
	DATA	ALLNAM:
	DATA	ALLPPN:
	DATA	ALLCRD:
	DATA	SAVFLG:
	DATA	DEFECL:
	DATA	ECLBIT:
	DATA	SAVEP:
	DATA	NDIG:
	DATA	MODULE:
	DATA	MODLST:
	DATA	MPLTIT:
DEC,<	DATA	RDCSAV:
	DATA	RDCSVB:
	DATA	RDCLIB:
	DATA	IGNTRM:
>;DEC
NOTTYBT,<
	DATA	SAVLIN:
	DATA	BUFPTR:
	DATA	TTBUF:,=75/5
	TTBEND_.-1
>;NOTTYBT
ZEROEND__.-1
	DATA	PDL:,PDLLEN
	DATA	PATCH:,100
	DATA	ZPPN:
DIPNAM:	'NDIPS '
	'DIP   '
	0
	0

; ERROR COUNTS FOR WLS SUMMARY, CLEARED BY BLT (LOPSET)
CNTTAB:	DATA	ANYOUT:
	DATA	NIN:
	DATA	NOUT:
	DATA	NINOUT:
	DATA	NTRI:
	DATA	NOC:
	DATA	NPULL:
	DATA	NTERM:
	DATA	NTRMOUT:
	DATA	NTRMIN:
	DATA	NULLS:
	DATA	NCONS:
	DATA	NGND:
	DATA	NPWR:
	DATA	PVOLTS:
	DATA	ILVOLT:
	DATA	PMAMPS:
LODTAB:	DATA	LINL:
	DATA	LINH:
	DATA	LOUTL:
	DATA	LOUTH:
	DATA	LOCL:
	DATA	LPULLH:
	DATA	LTRIL:
	DATA	LTRIH:
LODLEN__.-LODTAB

LODSAV:	BLOCK LODLEN

RESIDENT:	0		;IF SET THIS IS PERMANENT RESIDENT DIPLST
OLDFF:		0		;SAVED .JBFF

DATA	DSKCNT:
DATA	DSKNAM:
DATA	DSKEXT:
DATA	DSKDAT:
DATA	DSKPP:
DATA	DSKFLG:
DATA	DSKACT:
DATA	CBITS:
DATA	IDSKHD:,3
DATA	IDSKBF:,203

;R$G	TO GET BACK AFTER ^C DD.
R:	JRST @130
CPOPJ3:AOS (P)
CPOPJ2:AOS (P)
CPOPJ1:AOS(P)
CPOPJ:	POPJ P,
SUBTTL	DUMP FILE
;HERE WE SAVE A DUMP FILE OF THIS WIRE LISTER
SAVE:
NODEC,<
NOIII,<
	MOVSI T,EXTSAV
	MOVEM T,DEFEXT
	PUSHJ P,SETFIL
	POPJ P,
	MOVE T,.JBREL
NOITS,<
NOCMU,<	LSH T,-12
	ADDI T,1
	HRLI T,CONT		;STARTUP LOC
	MOVSM T,FILDAT
>;NOCMU
>;NOITS
CMU,<	PUSH P,.JBSA
	HRLM T,.JBSA
	PUSH P,FILPPN
	SETZM FILPPN	;AT CMU IT'S A NOT A PPN IN THIS ARG!
>;CMU
	MOVSI T,'DSK'
	MOVEM T,SAVBLK
>;NOIII
>;NODEC
	MOVEI T,1(P)
	BLT T,17(P)		;BLT 17 AC'S ONTO STACK
	MOVEM P,SAVEP
NODEC,<
NOIII,<	ADD P,[17,,17]
	MOVSI T,SAVBLK
	PUSH P,DSKACT		;SAVE OLD STATE
	SETZM DSKACT		;HOLD DISK INPUT
ITS,<	JRST ITSAVE	>	;ITS IS DIFFERENT - PJ
NOITS,<
NOCMU,<	SWAP T, >
CMU,<	MOVSM T,DMPARG
	RESET
EXTERNAL SAVJOB
	JSR SAVJOB
DMPARG:	0
	JRST [	HRRE T,FILEXT
		JUMPE T,CONT
		HALT . ]
>;CMU
	POP P,T			;GET OLD STATE
	JUMPE T,CONT		;IF ALREADY OFF, JUST CONT
	PUSHJ P,DSKCON		;ELSE THIS WILL RESET DSKIN FILE (WE REALLY HAVE A STACK)
>;NOITS
>;NOIII
>;NODEC
IFN DECSW!IIISW,<
	SETZM DSKACT
	OUTSTR[ASCIZ/SAVE CORE IMAGE WITH "SAVE" COMMAND.
THEN TYPE "START" OR "RUN".
/]
	MOVEI T,CONT
	HRRM T,.JBSA
	EXIT 1,
>;IFN DECSW!IIISW
CONT:	OUTSTR[ASCIZ/
/]
IFN DECSW!IIISW,<
	SKIPE DSKFLG
	OUTSTR[ASCIZ/DISK INPUT HOLDING, TYPE "XDSKCON" TO CONTINUE IT.
/]
>;IFN DECSW!IIISW
NOCMU,<	MOVEI T,STRT
	HRRM T,.JBSA		;RESTORE START-UP
>;NOCMU
	MOVE P,SAVEP
	MOVSI T,1(P)
	BLT T,16		;GET BACK AC'S
CMU,<	POP P,FILPPN
	POP P,.JBSA
>;CMU
	POPJ P,

ITS,<
ITSAVE:	MOVEI T,CONT
	HRL T,FSTOP
	MOVEM T,.JBSA
	PUSHJ P,VALINI		;FLUSH CORE SET POINTERS, ETC.
	MOVEI TT,[ASCIZ /Y /]
	PUSHJ P,DDTSTR
	MOVE TT,FILPPN
	PUSHJ P,DDTSIX
	MOVEI T,";"
	PUSHJ P,DDTPUT
	MOVE TT,FILNAM
	PUSHJ P,DDTSIX
	MOVEI T,40
	PUSHJ P,DDTPUT
	MOVE TT,FILEXT
	PUSHJ P,DDTSIX
	JRST VALRET

VALINI:	HLRZ T,.JBSA		;CORE SIZE
	LSH T,-12		;PAGE # OF HIGHEST LOW PAGE
	MOVSI TT,-377(T)	;-# PAGES TO FLUSH
	HRRI TT,1(T)		;STARTING 1 PAST LAST PAGE
	.CALL [	SETZ		;FLUSH THE DEC COMPATIBLITIY ROUTINES
		SIXBIT /CORBLK/
		1000,,0		;FLUSH PAGES
		1000,,-1	;FROM SELF
		SETZ TT]
	.VALUE
	SETZM VALBUF
	MOVE TT,[VALBUF,,VALBUF+1]
	BLT TT,VALBUF+VALBFL-1
	MOVEI TT,[ASCIZ /: TYPE <cr> TO DUMP ME OUT, OR <control>D TO ABORT 
/]
	MOVE TTT,[440700,,VALBUF]
DDTSTR:	HRLI TT,440700
DDTST1:	ILDB T,TT
	JUMPE T,CPOPJ
	PUSHJ P,DDTPUT
	JRST DDTST1

DDTPUT:	IDPB T,TTT
	POPJ P,

DDTSIX:	JUMPE TT,CPOPJ
	MOVEI T,0
	LSHC T,6
	ADDI T,40
	PUSHJ P,DDTPUT
	JRST DDTSIX
>;ITS
SUBTTL	IOPAC-UUOCON

LOC 41
PUSHJ P,$UUOCON
RELOC

^$UUOCON:MOVEM T,UUOSAV
	LDB T,[POINT 9,40,8]
	CAILE T,5
	MOVEI T,0
	MOVE T,(T)[[HALT CPOPJ]
		STRPUT
		SIXPUT
		OUTBYT
		.ASK
		STRERR]
	EXCH T,UUOSAV
	JRST 2,@UUOSAV
SUBTTL	IOPAC-OUTPUT SUBRS
.ASK:	OUTSTR @40
	PUSH P,TTT
	PUSHJ P,TTYIN
	JFCL
	HRRZS -1(P)
	CAIE TTT,"Y"
	CAIN TTT,"y"
	HRROS -1(P)
.ASK1:	CAIN TTT,ALTMOD
	JRST [	OUTSTR[ASCIZ/
/]
		POP P,TTT
		POPJ P,]
	CAIN TTT,12
	JRST .ASK2
	PUSHJ P,TTYIN
	JFCL
	JRST .ASK1

.ASK2:	POP P,TTT
	SKIPGE (P)
	AOS (P)
	JRST CPOPJ1

;ERRSTR AC,[ASCIZ//]
;PRINT ERROR MESSAGE AT RIGHT SIDE OF PAGE, WITH AC="SERIOUSNESS NUMBER"
STRERR:	PUSH P,T
	PUSH P,TT
	PUSH P,TTT
	PUSH P,40			;SAVE ARGS HERE
	SKIPE TTYFLG			;TTY?
NOSKEY,<	SKIPA TT,[9*8-2]	>	;YES, 8 TABS WORTH
SKEY,<	SKIPA TT,[8*8-2]	>
	MOVEI TT,=13*8-2		;NO, 13
	HRRZ T,(P)			;START OF STRING
	TLOA T,(<POINT 7,0>)		;MAKE IT BYTE POINTER
	SUBI TT,1
	ILDB TTT,T
	JUMPN TTT,.-2
	PUSH P,TT
	CAMG TT,LCOUNT			;AT LEAST ONE BETWEEN US AND LAST THING?
	 CRLF				;NO, RETURN
	MOVE TT,(P)
	LSH TT,-3			;LAST TAB STOP BEFORE OUR STRING
	MOVE T,LCOUNT			;GET CURRENT LINE POSITION
	LSH T,-3			;CONVERT BOTH TO TABS
	SUB TT,T			;THIS IS HOW MANY TABS WE CAN DO
	SKIPA TTT,[11]
	 XCT PUTCHR
	SOJGE TT,.-1
	POP P,T
	SUB T,LCOUNT
	SKIPA TTT,[40]			;NOW SPACES TO START OF STRING
	 XCT PUTCHR
	SOJGE T,.-1
	HRRZ T,(P)			;START OF STRING
	PUSHJ P,STRPT1			;PRINT ROUTINE
	PUTSTR[ASCIZ/	____ /]
	POP P,T			;NOW THE #
	LSH T,-=18-5
	ANDI T,17
	PUSHJ P,DECOUT
	CRLF
	POP P,TTT
	POP P,TT
	POP P,T
	POPJ P,

;SIXPUT - OUTPUT ONE WORD OF SIXBIT
SIXPUT:	PUSH P,T
	PUSH P,TT
	PUSH P,TTT
	MOVE TT,@40
	PUSHJ P,SIXLOP
	POP P,TTT
	POP P,TT
	POP P,T
	POPJ P,

SIXLOP:	JUMPE TT,CPOPJ
	SETZ T,
	LSHC T,6
	MOVEI TTT,40(T)
	XCT PUTCHR
	JRST SIXLOP

OUTBYT:	PUSH P,TTT
	MOVEI TTT,@40
	XCT PUTCHR
	POP P,TTT
	POPJ P,

;BYTOUT - OUTPUT CHARACTER TO FILE
^F4OUT:	CAIN TTT,11		;CHECK FOR ILLEGAL CHARS, ETC.?
	 MOVEI TTT,40
	JRST BYTOUT

^F4CRLF:MOVE TTT,LSTHD+2
	CAIG TTT,2		;IF NO ROOM FOR LF, THEN
	SETZM LSTHD+2		;FORCE OUTPUT
	MOVEI TTT,15
	PUSHJ P,BYTOUT
	MOVEI TTT,12
;FALL INTO BYTOUT
^BYTOUT:
ITS,<	SKIPE IMAGE
	 JRST NOSIMB
>;ITS
	JUMPE TTT,CPOPJ
DEC,<	TLNE COMLIN		;COMMENT LINE?
	SKIPE LCOUNT		;YES, BEGIN LINE?
	 JRST NOCOML		;NO
	CAIE TTT,15
	CAIN TTT,12
	 JRST NOCOML		;NOT BEFORE VERTICAL POSITIONING
	CAIN TTT,14
	 JRST NOCOML
	PUSH P,TTT
	MOVEI TTT,"/"
	PUSHJ P,NOCOML		;PUT OUT COMMENT CHAR
	POP P,TTT
NOCOML:
>;DEC
	CAIN TTT,11
	 JRST BYTTAB
NOSIMB:	SOSG LSTHD+2
	OUT LST,
	CAIA
	JRST [	OUTSTR[ASCIZ/OUTPUT ERROR!
/]
		EXIT 1,
		POPJ P,]
	IDPB TTT,LSTHD+1
ITS,<	SKIPE IMAGE
	 POPJ P,
>;ITS
.COUNT:	CAIN TTT,12
	JRST [	AOS LINCNT	;COUNT ANOTHER LINE
		POPJ P,]
	CAIN TTT,14
	JRST [	SETZM LINCNT		;JUST IN CASE
		POPJ P,]		;FORM FEED DOES NOTHING FOR NOW
	CAIN TTT,15
	JRST [	SETZM LCOUNT
		POPJ P,]
	CAIN TTT,11
	 JRST TABCNT
	AOS LCOUNT
	AOS TCOUNT
	POPJ P,

BYTTAB:	TLNN SIMTAB		;MUST WE SIMULATE?
	 JRST NOSIMB		;NO
	PUSH P,TTT
BYTTB1:	MOVEI TTT,40
	PUSHJ P,BYTOUT
	MOVE TTT,LCOUNT
	TRNE TTT,7		;AT TAB STOP YET?
	JRST BYTTB1
	POP P,TTT
	POPJ P,

TABCNT:	PUSH P,TTT
	MOVE TTT,LCOUNT
	ADDI TTT,10
	ANDCMI TTT,7
	EXCH TTT,LCOUNT
	SUB TTT,LCOUNT
	MOVNS TTT		;HOW MUCH DID TAB MOVE?
	ADDM TTT,TCOUNT
	POP P,TTT
	POPJ P,

;FILL, SPFILL, TTYOUT - OUTPUT CHAR TO TTY
FILL:	PUTBYT 11
	CAMLE A,LCOUNT		;THERE YET?
	JRST FILL
	POPJ P,

SPFILL:	PUSH P,A
	TRZ A,7
	CAMLE A,LCOUNT
	PUSHJ P,FILL
	POP P,A
	SUB A,LCOUNT
	JUMPLE A,CPOPJ
	PUTBYT 40
	SOJG A,.-1
	POPJ P,

TTFILL:	PUSH P,A
	MOVE A,T
	PUSHJ P,TFILL
	POP P,A
	POPJ P,

TFILL:	SUB A,TCOUNT
	JUMPLE A,CPOPJ
	PUTBYT 40
	SOJG A,.-1
	POPJ P,

^TTYOUT:JUMPE TTT,CPOPJ
DEC,<	TLNE COMLIN		;COMMENT LINE?
	SKIPE LCOUNT		;YES, BEGIN LINE?
	JRST NOCOMT		;NO
	CAIE TTT,15
	CAIN TTT,12
	JRST NOCOMT		;NOT BEFORE VERTICAL POSITIONING
	CAIN TTT,14
	JRST NOCOMT
	PUSH P,TTT
	MOVEI TTT,"/"
	PUSHJ P,NOCOMT		;PUT OUT COMMENT CHAR
	POP P,TTT
NOCOMT:
>;DEC
	CAIN TTT,11
	JRST TTYTAB
NOSIMT:	OUTCHR TTT
	JRST .COUNT

TTYTAB:	TLNN SIMTAB		;DO WE HAVE TO SIMULATE TAB?
	JRST NOSIMT		;NO
	PUSH P,TTT
TTYTB1:	MOVEI TTT,40
	PUSHJ P,TTYOUT
	MOVE TTT,LCOUNT
	TRNE TTT,7		;ARE WE AT A TAB STOP YET?
	JRST TTYTB1		;NO
	POP P,TTT
	POPJ P,

;FILPNT - PRINT FILE NAME (AT A)
^FILPNT:
NOITS,<
	PUTSIX (A)
	PUTBYT "."
	HLLZ TT,1(A)
	PUTSIX TT
DECOS,<	SKIPN 3(A)
	POPJ P,
>;DECOS
	PUTBYT "["
NOCMU,<	HLLZ TT,3(A)
	PUSHJ P,LSIXOUT
	PUTBYT ","
	HRLZ TT,3(A)
	PUSHJ P,LSIXOUT
>;NOCMU
CMU,<	SKIPN TTT,3(A)
	DSKPPN TTT,
	MOVE TT,[TTT,,PPNBUF]
	DECCMU TT,		;CONVERT DEC PPN TO CMU PPN (ASCIZ)
	JRST [	PUTSIX 3(A)	;IF NOT A CMU PPN, PUT IT OUT IN SIXBIT
		JRST .+2]
	PUTSTR PPNBUF
>;CMU
	PUTBYT "]"
	POPJ P,
>;NOITS
ITS,<
	PUTSIX 3(A)
	PUTBYT ";"
	PUTSIX (A)
	PUTBYT 40
	PUTSIX 1(A)
	POPJ P,
>;ITS

;LSIXOUT, LOCT, STRPUT
NOCMU,<
^LSIXOUT:
NODEC,<
NOIII,<	TLNN TT,777700
	LSH TT,14
	TLNN TT,770000
	LSH TT,6
	JRST SIXLOP		;JUMP INTO PRINT ROUTINE
>;NOIII
>;NODEC
IFN DECSW!IIISW,<	HLRZ T,TT
LOCT:	IDIVI T,10
	HRLM TT,(P)
	JUMPE T,.+2
	PUSHJ P,LOCT
	HLRZ TTT,(P)
	ADDI TTT,60
	XCT PUTCHR
	POPJ P,
>;IFN DECSW!IIISW
>;NOCMU

;STRPUT - PUT STRING ROUTINES
STRPUT:	PUSH P,T
	PUSH P,TT
	PUSH P,TTT
	MOVEI T,@40		;SETUP FOR ROUTINES
	LDB TT,[POINT 4,40,12]
	CAILE TT,MAXSAC
	 SETZ TT,
	PUSHJ P,@SUUOTB(TT)
	POP P,TTT
	POP P,TT
	POP P,T
	POPJ P,

SUUOTB:	STRPT1			;ASCIZ STRING
	SIGPUT			;  "  (BUT DIFFERENT AT DEC)
	COMPUT			;OUTPUT COMMENT ONLY
	STRBIN			;OUTPUT ASCII TO BINARY MODE FILE
	SIGBIN			; "  (BUT SIGNAL STUFF AT DEC)
	SGUBIN			;  "   "  (PREFIX WITH GLOBAL CHAR)
DEC,<	SIGOUT	>		;OUTPUT SIGNAL TO TTY
ITS,<	STRXGP	>		;IMAGE OUTPUT FOR XGP (DON'T COUNT CHARS)
MAXSAC__.-SUUOTB-1

ITS,<
STRXGP:	SETOM IMAGE
	PUSHJ P,STRPT1
	SETZM IMAGE
	POPJ P,
>;ITS

NODEC,<SIGPUT:	>
STRPT1:	HRLI T,(<POINT 7,0>)
STRPT3:	ILDB TTT,T
	JUMPE TTT,CPOPJ
STRPT2:	XCT PUTCHR
	JRST STRPT3

;GNDPUT, SMPPUT - OUTPUT NAME AT LEFT PART OF MARGIN
;T = STRING
;TT = MAX LENGTH,, INDENT COLUMN (?)
^GNDPUT:SETOM GNDFLG
	CAIA
^SMPPUT:SETZM GNDFLG
	MOVEM TT,SMPCNT		;SAVE LENGTH,,SPACING
	SETZM OVRFLW		;NO OVERFLOW YET
	HRLI T,(<POINT 7,0>)
	SETZM TCOUNT		;CLEAR TMP COUNT
	HLRZ TT,SMPCNT		;GET LENGTH
	ILDB TTT,T
	CAIN TTT,NOTCHR
	TLOA NOT
	TLZA NOT
	ILDB TTT,T
	JRST DSTRO4

DSTRO0:	XCT PUTCHR
	ILDB TTT,T
DSTRO4:	JUMPE TTT,DSTRO1
DEC,<	CAIE TTT,11	>	;ARE WE AT AP STUFF?
	CAIN TTT,";"		;DON'T CONFUSE DAVE WITH COMMENTS
	JRST DSTRO1
	SOJGE TT,DSTRO0
	SETOM OVRFLW		;SIGNAL OVERFLOW
DSTRO1:	PUSH P,A
	HRRZ A,SMPCNT
	SUB A,TCOUNT
	ADD A,LCOUNT
	PUSHJ P,SPFILL
	POP P,A
	SKIPE GNDFLG
	JRST [	PUTSTR [ASCIZ/G /]
		POPJ P,]
NODEC,<	TLNN NOT
	SKIPA TTT,[40]
	MOVEI TTT,"-"
	XCT PUTCHR
	MOVEI TTT,40
	XCT PUTCHR
	POPJ P,
>;NODEC
DEC,<	LDB TTT,T
	CAIA
DSTRO2:	ILDB TTT,T
	JUMPE TTT,DSTRO3
	CAIN TTT,";"
	JRST DSTRO3
	CAIE TTT,11
	JRST DSTRO2
	ILDB TTT,T
	TLNE NOT
	MOVEI TTT,"-"
	XCT PUTCHR		;ASSERTION
	ILDB TTT,T
	XCT PUTCHR		;POLARITY
	POPJ P,

DSTRO3:	MOVEI TTT," "
	TLNE NOT
	MOVEI TTT,"-"
	XCT PUTCHR
	MOVEI TTT," "
	XCT PUTCHR
	POPJ P,
>;DEC
;SIGOUT, SIGPUT

DEC,<
;SIGNAL OUT TO TTY
SIGOUT:	PUSH P,PUTCHR		;SAVE CURRENT OUTPUT CALL
	MOVE TTT,[OUTCHR TTT]
	MOVEM TTT,PUTCHR
	PUSHJ P,SIGPUT		;PRINT SIGNAL
	POP P,PUTCHR
	POPJ P,

SIGPUT:	HRLI T,(<POINT 7,0>)
SIGPT0:	ILDB TTT,T
	JUMPE TTT,CPOPJ
	CAIN TTT,";"
	JRST STRPT2		;NO A/P, JUST PRINT REST OF STRING
	CAIN TTT,11
	JRST SIGPT1
	XCT PUTCHR
	JRST SIGPT0

SIGPT1:	MOVEI TTT,40
	XCT PUTCHR
	ILDB TTT,T
	CAIN TTT,40
	JRST STRPT3
	MOVEI TTT,"("
	XCT PUTCHR
	LDB TTT,T
	XCT PUTCHR
	MOVEI TTT,")"
	JRST STRPT2
>;DEC

STRBIN:	PUSHJ P,SETBIN
	PUSHJ P,STRPT1
CLRBIN:	PUSHJ P,WRTZERO
	SOS TT,LSTHD+2
	IDIVI TT,5
	ADDI TT,1
	MOVEM TT,LSTHD+2
	MOVEI TT,(<POINT 36,0,35>)
	HRLM TT,LSTHD+1
	POPJ P,

SETBIN:	SOS TT,LSTHD+2
	IMULI TT,5
	ADDI TT,1
	MOVEM TT,LSTHD+2
	MOVEI TT,(<POINT 7,0,34>)
	HRLM TT,LSTHD+1
	POPJ P,

SIGBIN:	PUSHJ P,SETBIN
SIGBN1:	PUSHJ P,SIGPUT
	JRST CLRBIN

SGUBIN:	PUSHJ P,SETBIN
	MOVEI TTT,GLBCHR
	XCT PUTCHR
	JRST SIGBN1

;COMPUT - OUTPUT COMMENT PART ONLY
COMPUT:	MOVEI T,@40
	HRLI T,(<POINT 7,0>)
COMOU1:	ILDB TTT,T
	JUMPE TTT,CPOPJ
	CAIE TTT,";"
	JRST COMOU1
	JRST STRPT3

^STRTTY:PUSH P,PUTCHR
	MOVE TTT,[OUTCHR TTT]
	MOVEM TTT,PUTCHR
	PUSHJ P,STROUT
	POP P,PUTCHR
	POPJ P,

;STROUT - PRINT STRING
;A = STRING

^STROUT:JUMPE A,CPOPJ
STROU2:	HRLI A,(<POINT 7,0,35>)
STROU1:	ILDB TTT,A
	XCT PUTCHR
	TLNE A,760000
	JRST STROU1
	HRR A,-1(A)
	TRNE A,-1
	JRST STROU1
	POPJ P,

^MILOUT:IDIVI T,=1000
	PUSH P,TT
	PUSHJ P,DECOUT
	PUTBYT "."
	MOVEI T,3
	MOVEM T,NDIG
	POP P,T
	JRST NDECOUT

^LDOUT:	SKIPGE T
	PUTBYT "-"
	MOVM T,T
	IDIVI T,=100
	PUSH P,TT
	PUSHJ P,DECOUT
	PUTBYT "."
	MOVEI T,2
	MOVEM T,NDIG
	POP P,T
	JRST NDECOUT

^TTYDEC:IDIVI T,=10
	HRLM TT,(P)
	JUMPE T,.+2
	PUSHJ P,TTYDEC
	HLRZ TT,(P)
	ADDI TT,60
	OUTCHR TT
	POPJ P,

^DECOU4:SKIPA TT,[4]
^DECOU5:MOVEI TT,5
	MOVEM TT,NDIG
DECOU6:	IDIVI T,=10
	ADDI TT,60
	JUMPN T,DECOU7
	CAIE TT,60
	JRST DECOU7
	MOVE T,NDIG
	CAIE T,5
	SUBI TT,20
	SETZ T,
DECOU7:	HRLM TT,(P)
	SOSG NDIG
	JUMPE T,.+2
	PUSHJ P,DECOU6
	HLRZ TT,(P)
	PUTBYT (TT)
	POPJ P,
SUBTTL	IOPAC-INPUT SUBRS
^BYTIN:	SOSG DAT,DATHD+2
	IN DAT,
	 CAIA
	 JRST [	STATO DAT,1B22
		OUTSTR[ASCIZ/INPUT ERROR!
/]
		SETZ TTT,
		JRST CPOPJ]
	ILDB TTT,DATHD+1
	TRNN ASCFLG
	 JRST CPOPJ1
	MOVE TTT,@DATHD+1
	TRNN TTT,1		;FLUSH LINE NUMBERS!
	 JRST GOTIT
	MOVNI TTT,5
	ADDM TTT,DATHD+2
	AOS DATHD+1
	JRST BYTIN
GOTIT:	LDB TTT,DATHD+1
	TRNN ASCFLG
	JRST CPOPJ1
	CAIE TTT,15
	CAIN TTT,14
	JRST BYTIN
	JUMPE TTT,BYTIN
	CAIL TTT,"a"
	CAILE TTT,"z"
	CAIA
	SUBI TTT,40
	JRST CPOPJ1

^INDCHR:PUSHJ P,BYTIN
	POPJ P,
IFN ALTMOD-ALTCHR,<
	CAIN TTT,ALTCHR
	MOVEI TTT,ALTMOD
>;ALTMOD-ALTCHR
	JRST CPOPJ1

^TTYINC:SETZM CBITS
	SKIPE DSKACT
	PUSHJ P,DSKINC
	JRST TTYINQ
	POPJ P,

^LETCHK:CAIL TTT,"A"
	CAILE TTT,"Z"
	CAIA
	JRST CPOPJ1
	CAIL TTT,"A"+40
	CAILE TTT,"Z"+40
	POPJ P,
	SUBI TTT,40
	JRST CPOPJ1

^TTYINB:SETZM CBITS
	SKIPE DSKACT
	PUSHJ P,DSKINC
	JRST TTYINY
	POPJ P,

TTYINY:
NOTTYBT,<
	SKIPE SAVLIN		;DO WE NEED SPECIAL CODE?
	JRST TTYIN1		;YES
>;NOTTYBT
	INCHWL TTT
TTYINX:	CAIN TTT,15
	JRST .-2
NOSKEY,<	CAIN TTT,CBCHR		;CONTROL BIT CHAR?
	JRST TTYINZ
	CAIN TTT,CTRL
	JRST [	MOVEI TTT,200
		IORM TTT,CBITS
		JRST TTYINQ]
	CAIN TTT,META
	JRST [	MOVEI TTT,400
		IORM TTT,CBITS
		JRST TTYINQ]
	CAIN TTT,CTLMTA
	JRST [	MOVEI TTT,600
		IORM TTT,CBITS
		JRST TTYINQ]
>;NOSKEY
ESCMP,<	CAIL TTT,175
	CAILE TTT,176
	CAIN TTT,33
	JRST TTYINZ		;ALTMODE HACK
	CAIN TTT,177		;RUBOUT?
	JRST [	SKIPN CBITS		;IF ALTMODES TYPED?
		JRST .+1
		OUTSTR[ASCIZ/ XXX /]
		JRST TTYINB]		;THEN FLUSH THEM AND START AGAIN
>;ESCMP
	IOR TTT,CBITS
	POPJ P,

TTYINZ:	MOVEI TTT,200
	ADD TTT,CBITS
	ANDI TTT,600
	MOVEM TTT,CBITS
SKEY,<	JUMPE TTT,[MOVEI TTT,ALTMOD
		POPJ P,]
>;SKEY
TTYINQ:	INCHRW TTT
	JRST TTYINX

NOTTYBT,<
^LINCLR:PUSH P,BUFPTR
	SETZ TTT,
	IDPB TTT,BUFPTR
	POP P,BUFPTR
	POPJ P,

TTYIN2:	MOVEI TTT,0
	IDPB TTT,BUFPTR
	MOVE TTT,[POINT 7,TTBUF]
	MOVEM TTT,BUFPTR
TTYIN1:	ILDB TTT,BUFPTR
	JUMPN TTT,CPOPJ
TTYIN4:	MOVE TTT,[POINT 7,TTBUF]
	MOVEM TTT,BUFPTR
	SETZM TTBEND
TTYIN5:	INCHRW TTT
	JUMPE TTT,TTYIN5
	CAIN TTT,15
	JRST TTYIN5
	CAIN TTT,177
	JRST TTYIN3
	CAIN TTT,""
	JRST TTYIN4
	CAIGE TTT,175
	CAIN TTT,33
	MOVEI TTT,ALTMOD
	IDPB TTT,BUFPTR
	CAIE TTT,11
	CAIN TTT,12
	JRST TTYIN2
	CAIE TTT,ALTMOD
	SKIPE TTBEND
	JRST TTYIN2
	JRST TTYIN5

TTYIN3:	REPEAT 4,<	IBP BUFPTR	>
	SOS TTT,BUFPTR
	CAMN TTT,[POINT 7,TTBUF-1,27]
	JRST TTYIN4
	JRST TTYIN5
>;NOTTYBT
^TTYIN:	PUSHJ P,TTYINB
STANFO,<CAIN TTT,612		;THIS IS SPECIAL
	POPJ P,			;GIVE EOF RETURN
>;STANFO
	ANDI TTT,177
	CAIN TTT,15		;IGNORE CR'S HERE
	JRST TTYIN
	JRST CPOPJ1

^DSKINC:SOSG IDSKHD+2
	IN IDSK,
	CAIA
	JRST [	STATO IDSK,1B22
		OUTSTR[ASCIZ/
INPUT ERROR ON INDIRECT FILE!/]
		OUTSTR[ASCIZ/
END OF INDIRECT FILE!
/]
		SETZM DSKFLG
		SETZM DSKACT
		RELEASE IDSK,
		POPJ P,]
	AOS DSKCNT			;COUNT CHAR (REGARDLESS OF WHAT IT IS)
	IBP IDSKHD+1
	MOVE TTT,@IDSKHD+1
	TRNN TTT,1
	JRST DSKIND
	MOVNI TTT,5
	ADDM TTT,IDSKHD+2
	AOS IDSKHD+1
	JRST DSKINC

DSKIND:	LDB TTT,IDSKHD+1
	JUMPE TTT,DSKINC
NOSKEY,<	CAIN TTT,CBCHR
	JRST [	MOVEI TTT,200
		ADD TTT,CBITS
		ANDI TTT,600
		MOVEM TTT,CBITS
		SKIPE DSKACT
		OUTCHR [CBCHR]
		JRST DSKINC ]
	CAIN TTT,CTRL
	JRST [	MOVEI TTT,200
		IORM TTT,CBITS
		SKIPE DSKACT
		OUTCHR[CTRL]
		JRST DSKINC]
	CAIN TTT,META
	JRST [	MOVEI TTT,400
		IORM TTT,CBITS
		SKIPE DSKACT
		OUTCHR[META]
		JRST DSKINC]
	CAIN TTT,CTLMTA
	JRST [	MOVEI TTT,600
		IORM TTT,CBITS
		SKIPE DSKACT
		OUTCHR[CTLMTA]
		JRST DSKINC]
>;NOSKEY
SKEY,<	CAIN TTT,33
	JRST [	SKIPE DSKACT
		OUTCHR["$"]
		MOVEI TTT,200
		ADD TTT,CBITS
		ANDI TTT,600
		MOVEM TTT,CBITS
		JUMPN TTT,DSKINC
		MOVEI TTT,ALTMOD
		JRST NXDACT]
>;SKEY
	CAIE TTT,14
	CAIN TTT,15
	JRST DSKINC
IFN ALTMOD-ALTCHR,<
	CAIN TTT,ALTCHR
	MOVEI TTT,ALTMOD
>;ALTMOD-ALTCHR
	SKIPN DSKACT
	JRST NXDACT
	CAIN TTT,12
	OUTCHR[15]
DECOS,<	CAIGE TTT,40
	JRST [	CAIE TTT,11
		CAIN TTT,12
		JRST .+1
		OUTCHR["^"]
		ADDI TTT,100
		OUTCHR TTT
		SUBI TTT,100
		JRST NXDACT]
>;DECOS
	OUTCHR TTT
NXDACT:	IOR TTT,CBITS
	SETZM CBITS
	JRST CPOPJ1

^IN0:	INIT DAT,0
	'DSK   '
	DATHD
	JRST [LOSIN:	OUTSTR[ASCIZ/INIT FAILED OF DSK!
/]
		EXIT 1,
		POPJ P,]
	TRO ASCFLG
SETIN:	MOVEI T,DATBUF
	EXCH T,.JBFF
	INBUF DAT,1
	MOVEM T,.JBFF
	JRST CPOPJ1

^IN10:	INIT DAT,10
	'DSK   '
	DATHD
	JRST LOSIN
	TRZ ASCFLG
	JRST SETIN

^GETWRT:SETZ A,
	MOVE T,[POINT 6,A]
GETWR1:	CAIE TTT,ALTMOD
	CAIGE TTT,40
	JRST CPOPJ1
	CAIL TTT,140
	SUBI TTT,40
	SUBI TTT,40
	TLNE T,770000
	IDPB TTT,T
GETWR2:	XCT GETCHR
	POPJ P,
	CAIE TTT,14
	CAIN TTT,15
	JRST GETWR2
	JRST GETWR1

^GETWRN:SETZ A,
	MOVE T,[POINT 6,A]
	PUSHJ P,CHRCK1
	POPJ P,
	JRST CKSPC
	JRST CHROK

ITS,<
^FILWRD:
	SETZ A,
	MOVE T,[POINT 6,A]
FILW1:	XCT GETCHR
	POPJ P,
FILW2:	CAIE TTT,11
	CAIN TTT,40
	JRST FILW1
	JRST FILW4
FILW3:	XCT GETCHR
	POPJ P,
FILW4:	CAIE TTT,14
	CAIN TTT,15
	JRST FILW3
	CAIL TTT,"a"
	CAILE TTT,"z"
	CAIA
	SUBI TTT,40	;LOWER CASE
	CAIL TTT,40
	CAILE TTT,"_"
	JRST CPOPJ1	;NOT SIXBIT
	CAIE TTT,11
	CAIN TTT,40
	JRST CPOPJ1
	CAIN TTT,";"
	JRST CPOPJ1
	SUBI TTT,40
	TLNE T,770000
	IDPB TTT,T
	JRST FILW3
>;ITS

NOCMU,<
^RDPPN:
IFN DECSW!IIISW,<
	SETZ A,
OCTSPC:	XCT GETCHR
	POPJ P,
	CAIE TTT,11
	CAIN TTT,40
	JRST OCTSPC
GETOCT:	CAIL TTT,"0"
	CAILE TTT,"7"
	JRST CPOPJ1
	ASH A,3
	ADDI A,-60(TTT)
	XCT GETCHR
	POPJ P,
	JRST GETOCT
>;IFN DECSW!IIISW
NODEC,<
NOIII,<	PUSHJ P,GETWRD
	POPJ P,
	HLRZ A,A
	TRNN A,7777
	LSH A,-14
	TRNN A,77
	LSH A,-6
	JRST CPOPJ1
>;NOIII
>;NODEC
>;NOCMU

^GETWRD:
	SETZ A,
	MOVE T,[POINT 6,A]
SKPSPC:	PUSHJ P,CHRCHK
	POPJ P,			;EOF
	JRST CKSPC		;BREAK CHAR.
	JRST CHROK

CKSPC:	CAIE TTT,11
	CAIN TTT,40
	JRST SKPSPC
	JRST CPOPJ1		;BREAK ALREADY

CHRGET:	PUSHJ P,CHRCHK
	POPJ P,			;EOF
	JRST CPOPJ1		;BREAK CHARACTER
CHROK:	SUBI TTT,40
	TLNE T,770000		;END OF WORD?
	IDPB TTT,T		;NO
	JRST CHRGET

CHRCHK:	XCT GETCHR
	POPJ P,
CHRCK1:	CAIE TTT,14
	CAIN TTT,15
	JRST CHRCHK
	CAIL TTT,"0"
	CAILE TTT,"9"
	CAIA
	JRST CPOPJ2
	CAIL TTT,"a"
	CAILE TTT,"z"
	CAIA
	SUBI TTT,40		;CHANGE UPPER TO LOWER
	CAIL TTT,"A"
	CAILE TTT,"Z"
	JRST CPOPJ1
	JRST CPOPJ2

^SLDECIN:CAIE TTT,"-"
	JRST LDECIN
	XCT GETCHR
	POPJ P,
	PUSHJ P,LDECIN
	POPJ P,
	MOVN A,A
	JRST CPOPJ1

^LDECIN:PUSHJ P,TDECIN
	POPJ P,
	IMULI A,=100
	CAIE TTT,"."
	JRST CPOPJ1
	PUSH P,B
	MOVEI B,=10		;MULTIPLIER
LDEC1:	XCT GETCHR
	JRST [	POP P,B
		POPJ P,]
	CAIG TTT,"9"
	CAIGE TTT,"0"
	JRST [	POP P,B
		JRST CPOPJ1]
	SUBI TTT,60
	IMUL TTT,B
	ADD A,TTT
	IDIVI B,=10
	JRST LDEC1

^SDECIN:XCT GETCHR
	JRST [	SETZ A,
		POPJ P,]
	CAIE TTT,"-"
	JRST TDECIN
	PUSHJ P,DECIN
	SOS (P)			;FLAG EOF, BUT NEGATE ANYWAY
	MOVN A,A
	JRST CPOPJ1

^DECIN:	XCT GETCHR
	JRST [	SETZ A,
		POPJ P,]
^TDECIN:CAIE TTT,11
	CAIN TTT,40
	JRST DECIN
	SETZ A,
	JRST DECLP1
DECLOP:	XCT GETCHR
	POPJ P,
DECLP1:	CAIL TTT,"0"
	CAILE TTT,"9"
	JRST CPOPJ1
	IMULI A,=10
	ADDI A,-60(TTT)
	AOS NDIG
	JRST DECLOP

^O6IN:	MOVEI T,6
	SETZ A,
OIN:	XCT GETCHR
	POPJ P,
	ANDI TTT,7
	LSH A,3
	IOR A,TTT
	SOJG T,OIN
	JRST CPOPJ1

^I3IN:	SKIPA T,[3]
^I5IN:	MOVEI T,5
	SETZ A,
	XCT GETCHR
	POPJ P,
	CAIN TTT,12
	JRST CPOPJ1
	JRST IIN1

IIN:	XCT GETCHR
	POPJ P,
IIN1:	IMULI A,=10
	ANDI TTT,17
	ADD A,TTT
	SOJG T,IIN
	JRST CPOPJ2

SUBTTL	SUBRS CALLED BY PERMUT
^^SIGGET:ILDB TTT,A
	POPJ P,

^^GETVAR:MOVE TT,VARLST
	PUSH P,TTT
GETVR1:	FETCH(TTT,TT,LET)
	CAMN TTT,(P)
	JRST ISVAR		;YES
	FETCH(TT,TT,NVAR)
	JUMPN TT,GETVR1
	POP P,TTT
	SETOM EXPER2		;VARIABLE ERROR
	MOVEI TT,1
	LSH TT,-"A"(TTT)
	TDNE TT,VARERR		;HAVE WE HAD THIS ERROR ALREADY?
	JRST GETVR2
	IORM TT,VARERR		;NO, SAVE IT
	PUTSTR[ASCIZ/NO VALUE FOR VARIABLE "/]
	PUTBYT (TTT)
	PUTSTR[ASCIZ/".
/]
	POPJ P,			;ERROR RETURN SO SIGNAL WILL PRINT

GETVR2:	SETZ TT,		;IF NO VAR ERROR PRINT, THE GIVE OK RETURN
	JRST CPOPJ1

ISVAR:	FETCH(TTT,TT,WID)
	CAMLE TTT,NDIG
	MOVEM TTT,NDIG
	FETCH(TT,TT,VAL)	;RETURN VALUE
	POP P,TTT
	JRST CPOPJ1

WHERRP:	PUTSTR[ASCIZ/CAUSED BY SIGNAL - /]
	PUTSIG ADDR(G,SPNT)
	PUTSTR[ASCIZ/
/]
	POPJ P,
SUBTTL	RSTR, TRSTR
;RSTR - READ STRING
;SKIPS IF GOT STRING
;T = STRING

^RSTR:	XCT GETCHR
	 SETZ TTT,
	JUMPE TTT,CPOPJ
	GETFS (T)
	SETZM (T)
	HRLM T,(P)
	JRST RSTR2

RSTR1:	GETFS (TT)
	SETZM (TT)
	HRRM TT,(T)
	MOVE T,TT
RSTR2:	MOVEM TTT,1(T)
	TRNE TTT,377
	XCT GETCHR
	 JRST RSTR3
	JUMPN TTT,RSTR1
RSTR3:	HLRZ T,(P)
	JRST CPOPJ1

^TISTRU:	SETOM LOW2UP
	JRST ISTR0

^ISTR:	SETZM LOW2UP
	XCT GETCHR
	POPJ P,
ISTR0:	CAIN TTT,ALTMOD
	JRST CPOPJ1
	CAIE TTT,11
	CAIN TTT,12
	JRST CPOPJ2
	GETFS(B)
	SETZM (B)
	SETZM 1(B)
	MOVSI TT,(<POINT 7,0>)
	HRRI TT,1(B)
ISTR1:	TLNE TT,760000
	JRST ISTR2
	PUSH P,TTT
	GETFS(TTT)
	SETZM (TTT)
	SETZM 1(TTT)
	HRRM TTT,-1(TT)
	HRR TT,TTT
	POP P,TTT
ISTR2:	SKIPN LOW2UP
	JRST ISTR3
	CAIL TTT,"A"+40
	CAILE TTT,"Z"+40
	CAIA
	SUBI TTT,40
ISTR3:	IDPB TTT,TT
	XCT GETCHR
	POPJ P,
	CAIN TTT,ALTMOD
	JRST [	PUSHJ P,PUTFS
		JRST CPOPJ1]
	CAIE TTT,11
	CAIN TTT,12
	JRST CPOPJ3
	JRST ISTR1


;TRSTR - READ INTO STRTAB, CHECK FOR SIZE OVERFLOW, NULL STRING
^TRSTR:	MOVE T,[-MXSTLN,,STRTAB]
TRSTR1:	XCT GETCHR
	 POPJ P,
	MOVEM TTT,(T)
	TRNE TTT,376		;END OF ASCIZ?
	AOBJN T,TRSTR1
	JUMPL T,TRSTR3		;END OK?
	TRZ TTT,377
	MOVEM TTT,(T)		;STORE WORD WITH ONE CHAR ZEROED
	OUTSTR[ASCIZ/STRING TOO LONG, TRUNCATED TO:
/]
	OUTSTR STRTAB
	OUTSTR[ASCIZ/
/]
TRSTR2:	XCT GETCHR
	POPJ P,
	TRNE TTT,376
	JRST TRSTR2
TRSTR3:	SKIPE STRTAB
	AOS (P)
	JRST CPOPJ1

^TTYSIG:PUSHJ P,SIGIN
	JFCL				;EOF RETURN
	SKIPE STRTAB
	CAIN TTT,ALTMOD
	POPJ P,				;NULL RETURN ON ALTMODE
	CAIE TTT,11
	JRST CPOPJ1
TTYSKP:	XCT GETCHR
	JRST TTYSK1
	CAIE TTT,12
	CAIN TTT,ALTMOD
	JRST TTYSK1
	JRST TTYSKP

TTYSK1:	OUTSTR[ASCIZ/ILLEGAL TAB IN SIGNAL NAME!
/]
	POPJ P,

^SIGIN:	MOVE T,[POINT 7,STRTAB]
	SETZM STRTAB			;FOR TEST LATER
TTYSG1:	XCT GETCHR
	JRST [	SKIPN STRTAB
		POPJ P,			;GIVE EOF RETURN IF NO STRING
		MOVEI TTT,12
		JRST TTYSG3]
	CAIN TTT,ALTMOD
	POPJ P,
	CAIE TTT,11
	CAIN TTT,12
	JRST TTYSG3
	CAMN T,[POINT 7,STRTAB+MXSTLN-1,27]
	JRST [	OUTSTR[ASCIZ/STRING TOO LONG, TRUNCATING!
/]
	TTYSG2:	XCT GETCHR
		MOVEI TTT,12
		CAIE TTT,12
		CAIN TTT,ALTMOD
		POPJ P,
		JRST TTYSG2]
	IDPB TTT,T
	JRST TTYSG1

TTYSG3:	SETZ TT,			;END FINISH OUT
	IDPB TT,T
	TLNE T,760000
	JRST .-2
	JRST CPOPJ1
SUBTTL	FREE STORAGE ROUTINES

^FSTINI:MOVEI T,[0]		;GET A POINTER TO A 0
	MOVEM T,FSTPNT
	MOVE T,[FSTPNT,,FSTPNT+1]
	BLT T,FSTPNT+FSTLEN-1	;FILL TABLE
	MOVE T,.JBFF
	MOVEM T,FSTOP		;SET AS TOP OF DIVIDED CORE
	CORE T,			;MAYBE CORE DOWN
	JFCL			;IGNORE ERROR
	POPJ P,


^NOFST:	0
	MOVEM A,SAVEA
	MOVEM B,SAVEB
	MOVE B,@NOFST		;GET POINTER INTO FS TABLE
CHKFST:
III,<	SKIPN A,.JBHRL  >
	 MOVE A,.JBREL
	SUB A,FSTOP
	CAIL A,-FSTPNT(B)	;ENOUGH?
	JRST ISFST1		;YES
NOFST3:
III,<	SKIPN A,.JBHRL  >
	 MOVE A,.JBREL
	ADDI A,2000		;ANOTHER K
III,<	TRNE A,400000	;OVER 128K?
	 JRST [	MOVSS A		;YES, SPLIT INTO TWO SEGS
		HRRI A,377777
		JRST .+1]
>;III
	CORE A,
	 JRST [	OUTSTR[ASCIZ/CORE UUO FAILED AT NOFST!
/]
		EXIT 1,
		JRST NOFST3]
III,<	SKIPE .JBHRL		;USING 2 SEGS?
	 PUSHJ P,TRYUWP
>;III
	JRST CHKFST


III,<
TRYUWP:	MOVEI A,0		;WRITE PERMIT THE UPPER
	SETUWP A,
	 CAIA
	 POPJ P,
	OUTSTR [ASCIZ /
 ## LOSE BIG - CAN'T WRITE PERMIT THE UPPER SEGMENT ##
/]
	EXIT 1,
	JRST TRYUWP
>;III

ISFST1:	MOVE A,FSTOP
	EXCH A,(B)
	HRRZM A,@(B)
USAGE,<	AOS FSTCNT-FSTPNT(B)	;INC COUNT>
	MOVEI A,-FSTPNT+1(B)	;THIS IS LENGTH OF NEW BLOCK
	ADDM A,FSTOP		;ADVANCE FSTOP
	MOVE B,SAVEB
	MOVE A,SAVEA
	SOS NOFST
	SOS NOFST		;RETURN TO SKIPN
	JRST @NOFST

^MORCOR: 0
	MOVEM A,SAVEA
NOIII,<	AOS A,.JBREL  >
III,<	MOVE A,MORCOR
	LDB A,[POINT 4,-2(A),12]	;AC FIELD OF COMPARE
	CAIE A,A
	 SKIPA A,(A)
	 MOVE A,SAVEA
	CAMG A,.JBHRL
	 JRST MRCRE2
	SKIPN .JBHRL
	 AOSA A,.JBREL
	 AOS A,.JBHRL
	TRNE A,400000		;OVER128K?
	 JRST [	MOVSS A		;SPLIT INTO 2 SEGS
		HRRI A,377777
		JRST .+1]
>;III
	PUSH P,A
	CORE A,
	JRST [	OUTSTR[ASCIZ/CORE UUO FAILED AT MORCOR!
/]
		EXIT 1,
		MOVE A,(P)
		JRST .-2]
	POP P,A
III,<	SKIPE .JBHRL		;USING TWO SEGS?
	 PUSHJ P,TRYUWP
>;III
	MOVNI A,2
	ADDM A,MORCOR			;RETURN TO TEST INSTRUCTION
MRCRE2:	MOVE A,SAVEA
	JRST @MORCOR

^TPUTFS:MOVE B,T
^PUTFS:	HLLI B,
	JUMPE B,CPOPJ
	PUSH P,T
	MOVS T,FSTPNT+1
	HRRZM B,FSTPNT+1
PUTFS1:	HRR T,B
	HRRZS B,(B)	;PICKUP LINK, CLEAR LH
	JUMPN B,PUTFS1
	HLRZM T,(T)	;LINK END TO OLD FS LIST
	POP P,T
	POPJ P,

SUBTTL TEXT ROUTINES
;CALL WITH POINTER TO ASCIZ STRING IN TT
;RETURNS WITH FS STRING IN T
;CLOBBERS TT AND TTT
ASCCOP:	GETFS(T)
	PUSH P,T
ASCCP1:	MOVE TTT,(TT)
	MOVEM TTT,1(T)
	TRNN TTT,376
	JRST ASCCP2
	SKIPN 1(TT)
	JRST ASCCP2
	GETFS(TTT)
	HRRZM TTT,(T)
	MOVE T,TTT
	AOJA TT,ASCCP1

ASCCP2:	SETZM (T)
	POP P,T
	POPJ P,

;CALL WITH POINTER TO FS STRING IN TT
;RETURNS WITH COPY OF STRING IN T
;CLOBBERS TT AND TTT
LSTCOP:	GETFS(T)
	HRLM T,(P)
	JRST LSTCP1

LSTCP2:	GETFS(TTT)
	MOVEM TTT,(T)
	MOVE T,TTT
LSTCP1:	MOVE TTT,1(TT)
	MOVEM TTT,1(T)
	HRRZ TT,(TT)
	JUMPN TT,LSTCP2
	SETZM (T)
	HLRZ T,(P)
	POPJ P,
;TXTMAT - MATCH TEXT STRINGS
;T = STRING 1
;TT = STRING 2
;RETURNS
;	UNEQUAL, T .LT. TT
;	UNEQUAL, T .GT. TT
;	EQUAL

;TXTPAR - ACCEPT PARTIAL MATCH
;RETURNS
;	NO MATCH
;	T .GT. TT
;	PARTIAL MATCH, T SUBSTRING OF TT
;	EXACT MATCH, T = TT

^TXTPAR:PUSHJ P,TXTMAT
	JRST TXTPR1
	JRST CPOPJ1			;TT LESS THAN T, JUST INDICATE THIS
	JRST CPOPJ3			;EXACT

TXTPR1:	JUMPE T,CPOPJ2			;IF T ENDS, THEN PARTIAL MATCH
	ADD TT,[POINT 7,1]
	PUSHJ P,ASCPR0
	POPJ P,
	JRST CPOPJ2			;PARTIAL MATCH

TXTMA2:	MOVE TTT,1(T)
	CAME TTT,1(TT)
	JRST TXTMA1
	HRRZ T,(T)
	HRRZ TT,(TT)
^TXTMAT:JUMPE T,[JUMPE TT,CPOPJ2	;EQUAL
		POPJ P,]		;UNEQUAL T LESS THAN TT
	JUMPN TT,TXTMA2
	JRST CPOPJ1			;UNEQUAL TT LESS THAN T

TXTMA1:	LSH TTT,-1
	PUSH P,TT
	MOVE TT,1(TT)
	LSH TT,-1
	CAML TTT,TT
	AOS -1(P)			;UNEQUAL TT LESS THAN T
	POP P,TT
	POPJ P,				;UNEQUAL T LESS THAN TT

;TEXT MATCHING ROUTINES
;ASCPAR - PARTIAL MATCH
;T = STRING
;TT = ASCIZ
;RETURNS
;	UNEQUAL
;	PARTIAL MATCH, T SUBSTRING OF TT
;	EXACT MATCH

^ASCPAR:PUSHJ P,ASCMAT
	CAIA
	JRST CPOPJ2			;DOUBLE SKIP FOR EXACT MATCH
	JUMPE T,CPOPJ1			;IF FS STRING ENDS, THEN PARTIAL MATCH
	HRLI TT,(<POINT 7,0>)
ASCPR0:	ADD T,[POINT 7,1]
	PUSH P,A
ASCPR1:	ILDB TTT,T
	JUMPE TTT,[POP P,A
		JRST CPOPJ1]		;IF FS STRING ENDS, THEN PARTIAL MATCH
	ILDB A,TT
	CAMN A,TTT
	JRST ASCPR1
	POP P,A
	POPJ P,				;NO MATCH AT ALL

;ASCMAT - MATCH STRING AGAINST ASCIZ
;T = STRING
;TT = ASCIZ
;RETURNS
;	UNEQUAL
;	MATCH

^ASCMAT:MOVE TTT,(TT)
	CAME TTT,1(T)
	POPJ P,
	ADDI TT,1
	HRRZ T,(T)
	JUMPN T,ASCMAT
	TRNE TTT,376
	SKIPN (TT)
	AOS (P)
	POPJ P,

;SEQMAT - COMPARE STRING AGAINST ASCIZ
;T = STRING
;TT = ASCIZ
;RETURNS
;	T .LT. TT
;	T .GT. TT
;	T EQUAL TT

^SEQMAT:MOVE TTT,(TT)
	CAME TTT,(T)
	JRST SEQMT1
	TRNN TTT,376
	JRST [	AOS (P)
		MOVE TTT,(T)
		TRNN TTT,376
		AOS (P)		;T=TT
		POPJ P,]	;TT LESS THAN T
	MOVE TTT,(T)
	TRNN TTT,376
	POPJ P,			;T LESS THAN TT
	ADDI TT,1
	AOJA T,SEQMAT

SEQMT1:	LSH TTT,-1
	MOVE TT,(T)
	LSH TT,-1
	CAML TT,TTT
	AOS (P)			;TT LESS THAN T
	POPJ P,			;T LESS THAN TT
SUBTTL	TOP LEVEL

CLEARS:	SETZ
	SETZM ZEROBEGIN
	MOVE T,[XWD ZEROBEGIN,ZEROBEGIN+1]
	BLT T,ZEROEND
	MOVSI T,DIRLST
	MOVEM T,DIRLST
	PUSHJ P,CLPAGE		;INIT PAGE LENGTH
	PUSHJ P,CLRWID		;INIT LINE LENGTH
	PUSHJ P,CLRNOM		;INITIALIZE BOARD TYPE POINTERS
	PUSHJ P,CLRWW
	PUSHJ P,CLOADM		;RESET LOAD MARGIN TO 100%
	JRST FSTINI		;INITIALIZE FREE STORAGE!

UNRESI:	SKIPN RESIDENT
	POPJ P,
	SETZM RESIDENT
	MOVE T,OLDFF
	HRLM T,.JBSA
	MOVEM T,.JBFF
	POPJ P,

STRESI:	ASK [ASCIZ /THIS WILL FLUSH ALL WIRELISTS,
READ IN DIP DEFINITIONS,
AND LOCK THEM DOWN. TYPE "Y" TO GO ON. /]
	 POPJ P,		;LET HIM OUT
	 POPJ P,		;LET HIM OUT
REE:	MOVE P,[IOWD PDLLEN,PDL]
	PUSHJ P,UNRESI
	RESET
	PUSHJ P,CLEARS
	PUSHJ P,DIPCHK
	OUTSTR[ASCIZ/MOBY LOSSAGE FROM DIPCHK AT RESIDENT DIPLST CODE!
/]
	MOVE T,DIPLST
	JUMPE T,STRT
	MOVEM T,RESIDENT
	HLRZ T,.JBSA
	MOVEM T,OLDFF		;REMEMBER OLD .JBFF
	MOVE T,FSTOP		;THIS IS FIRST WORD WE AREN'T USING
	HRLM T,.JBSA
ITS,<
	PUSHJ P,VALINI		;FLUSH ALL EXTRA CORE, AND THE SIMULATOR
	MOVEI TT,[ASCIZ /Y DATDRW;WL BIN/]
	PUSHJ P,DDTSTR		;PUT OUT FINAL STRING
VALRET:	MOVEI T,0
	PUSHJ P,DDTPUT		;AND A NULL FOR GOOD MEASURE
	MOVEI T,VALBUF+VALBFL
	SUBI T,(TTT)
	SKIPG T
	.VALUE [ASCIZ /: VALRET BUFFER OVERFLOW, PROCEED AT YOUR OWN RISK 
/]	
	.VALUE VALBUF
	.BREAK 16,60000		;AUTO EXPUNGE
>;ITS
STRT:	MOVE P,[IOWD PDLLEN,PDL]
	RESET
	SETZM DSKFLG		;CLEAR DSKIN
	SETZM DSKACT		;AND ACTIVE
	SETZM ZPPN		;INITIALIZE DEFAULT INPUT PPN
STRTC:	PUSHJ P,CLEARS		;CLEAR TABLES
	MOVE T,RESIDENT		;RESIDENT DIPS?
	MOVEM T,DIPLST		;STORE POINTER
	PUSHJ P,THREAD		;THREAD ANY PART NUMBERS WE HAVE NOW
	PUSHJ P,TOPMOD		;TOP MODE
	PUSHJ P,WIRINI		;SET DEFAULT WIRE LIST
MAIN:	HRRZ T,DIRLST
	SKIPE T			;EMPTY LIST?
	PUSHJ P,DIRRET		;NO, RETURN LIST FROM LAST LOSER
	SKIPE B,IDRLST
	PUSHJ P,IDRRET		;NO, RETURN LIST FROM LAST LOSER
	SETZM VARLST		;NO VARS NOW
	RELEASE DAT,		;FLUSH ANY IO THAT WAS GOING ON
	RELEASE LST,		;POSSIBLE IERROR FILE ALSO
	OUTSTR @PROMPT		;PRINT APPROPRIATE PROMPT
CMU,<	PUSHJ P,TTYINC	>	;READ TTY IN CHAR MODE TO GOBBLE CBCHR
NOCMU,<	PUSHJ P,TTYINB	>	;ITS A LOSER WHEN I CHANGE MY MIND ABOUT WHAT I TYPED
	MOVE A,TTT
	LDB B,[POINT 2,A,28]
	ANDI A,177
	CAIL A,"a"
	CAILE A,"z"
	CAIA
	SUBI A,40
	XCT @DISPWD
	JRST MAIN
	JRST ERRET

CERRET:SKIPE DSKACT
	JRST IERRET
	OUTSTR[ASCIZ/???
/]
	JRST GOMAIN

NERRET:SKIPE DSKACT
	JRST IERRET
	JRST ERRET1

FUCKUP:	OUTSTR [ASCIZ /
Ghastly internal error, fetch a wizard, quick!
/]
	HALT .+1
	POPJ P,

ERRET:	SKIPE DSKACT
	JRST IERRET
	OUTSTR[ASCIZ/???
/]
	JRST ERRET1

IERRET:	RELEASE IDSK,
	SETZM DSKACT
	OUTSTR[ASCIZ/ERROR IN DSKIN FILE, DSKHLD DONE!
/]
ERRET1:	INCHSL A			;NOW FLUSH ANY INPUT
	JRST GOMAIN
	CAIE T,12
	CAIN T,ALTMOD
	JRST GOMAIN
	JRST ERRET1

GOMAIN:	MOVE P,[IOWD PDLLEN,PDL]
	JRST MAIN

DDTCAL:	SKIPN TT,.JBDDT
	JRST [	OUTSTR[ASCIZ/SORRY, NO DDT!
/]
		POPJ P,]
	MOVE T,[10000,,CPOPJ]
	MOVEM T,.JBOPC
	JRST (TT)

DOEXIT:	EXIT 1,
	JRST STRT


;dtb:,command,com:
TOPTAB:	CAIA
FOR I_1,11
<	CAIA
>
	OUTCHR[15]
FOR I_13,77
<	CAIA
>
	PUSHJ P,DSKIN			; @
	CAIA				; A
	XCT (B)[JRST ERRET		; B
		PUSHJ P,BREADD
		PUSHJ P,RDPART
		PUSHJ P,READEQ]
	XCT (B)[JRST ERRET		; C
		PUSHJ P,WIRCOM
		PUSHJ P,DIPCOM
		PUSHJ P,WDECO]
	XCT (B)[JRST ERRET		; D
		JRST ERRET
		JRST ERRET
		PUSHJ P,DIPMOD]
	JRST DOEXIT			;E
	CAIA				;F
	CAIA				;G
	CAIA				;H
	XCT (B)[JRST ERRET		;I
		PUSHJ P,WREADD
		PUSHJ P,WREADP
		PUSHJ P,RDWEQ]
	CAIA				;J
	CAIA				;K
	XCT (B)[JRST ERRET		;L
		PUSHJ P,LIST
		PUSHJ P,SUMLST
		PUSHJ P,USEPIN]
	CAIA				;M
	XCT (B)[JRST ERRET		;N
		PUSHJ P,NTITLE
		JRST ERRET
		JRST ERRET]
	CAIA				;O
	XCT (B)[PUSHJ P,TLIST		;P
		PUSHJ P,TLISTB
		PUSHJ P,TTYUSE
		PUSHJ P,TLISTA]
FOR I_"Q","T"
<	CAIA
>
	XCT (B)[JRST ERRET		;U
		JRST ERRET
		JRST ERRET
		PUSHJ P,DTOPC]
	CAIA				;V
	XCT (B)[JRST ERRET		;W
		PUSHJ P,PUTOUT		;WRITE WDR FILE
		PUSHJ P,BAKOUT		;WRITE BAC FILE
		JRST ERRET]
	XCT (B)[PUSHJ P,DOOX		;X
		PUSHJ P,DOOXA
		PUSHJ P,DOOXA
		PUSHJ P,DOOXA]
FOR I_"Y",136
<	CAIA
>
	XCT (B)[PUSHJ P,WIRGET		;Z
		PUSHJ P,WIRFOR
		PUSHJ P,WIRBAK
		PUSHJ P,WIRPNT]
FOR I_140,200
<	CAIA
>
;END OF TOPTAB



DIPTAB:	CAIA
FOR I_1,11
<	CAIA
>
	OUTCHR[15]
FOR I_13,77
<	CAIA
>
	PUSHJ P,DSKIN
	PUSHJ P,DIPPRP		;ALTER PROPERTY TREE
	CAIA
	PUSHJ P,DIPCOP		;COPY DIP DEF
	PUSHJ P,DIPDEL		;DELETE DIP DEF
	PUSHJ P,TOPMOD		;GO BACK TO MAIN LOOP
FOR I_"F","H"
<	CAIA
>
	PUSHJ P,DIPIN		;READ DIP FILE
FOR I_"J","K"
<	CAIA
>
	PUSHJ P,DIPPRA		;LIST ALL DEF'S
	PUSHJ P,MODIFY		;MODIFY DIP DEFINITION
	PUSHJ P,NDNAME		;NEW DIP FILE NAME OR JUST PRINT
	CAIA			;O
	PUSHJ P,DIPPRN		;PRINT DIP DEFINITION
	CAIA
	PUSHJ P,DIPREN		;RENAME A DIP NAME
	PUSHJ P,SETPAK		;SET PACKAGE TYPE
FOR I_"T","V"
<	CAIA
>
	PUSHJ P,DIPWRT		;WRITE DIP FILE
	XCT (B)[PUSHJ P,DDOOX
		PUSHJ P,DDOOXA
		PUSHJ P,DDOOXA
		PUSHJ P,DDOOXA]
FOR I_"Y",177
<	CAIA
>
	CAIA

TOPMOD:	MOVE T,[TOPTAB(A)]
	MOVEM T,DISPWD
	MOVEI T,[ASCIZ/*/]
	MOVEM T,PROMPT
	OUTSTR[ASCIZ/TOP MODE!
/]
	POPJ P,

DIPMOD:	MOVE T,[DIPTAB(A)]
	MOVEM T,DISPWD
	MOVEI T,[ASCIZ/*/]
	MOVEM T,PROMPT
	OUTSTR[ASCIZ/DIP SUB-MODE!
/]
	POPJ P,

SUBTTL	X SCANNER
DOOXA:	OUTSTR[ASCIZ/
Si?/]
	JRST DOOX
DDOOXA:	OUTSTR[ASCIZ/
Si?/]
DDOOX:	SKIPA T,[-DTBLEN,,DXTAB]
DOOX:	MOVE T,[-TABLEN,,XTAB]
	MOVEM T,DOOXWD
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
IGNSP1:	XCT GETCHR
	JFCL
	CAIE TTT,40		;IGNORE LEADING BLANKS
	CAIN TTT,11
	JRST IGNSP1
	CAIN TTT,"?"
	JRST PUSE		;PRINT USE TABLE
	CAIN TTT,"-"
	TLOA TFLG
	TLZA TFLG
	MOVEI TTT,40		;SKIP ANY SPACES
	PUSHJ P,GETWRN		;FIRST CHAR IN T
	JFCL
	PUSHJ P,CHRCK1		;SKIP BLANKS
	JFCL			;IGNORE EOF
	JFCL			;IGNORE KIND OF CHAR
	CAIE TTT,12		;EOL?
	JRST ERRET
	JUMPE A,CPOPJ		;NULL COMMAND?
	MOVSI TTT,770000
	SETZ TT,		;CLEAR MASK
	TDNE A,TTT
	TDO TT,TTT
	LSH TTT,-6
	JUMPN TTT,.-3
	SETZ T,		;NO PARTIAL MATCH FOUND YET!
	MOVE D,DOOXWD
XLOP:	CAMN A,(D)
	JRST EXACT
	MOVE TTT,TT
	AND TTT,(D)
	CAMN TTT,A
	JRST [	JUMPN T,XAMBIG	;TOO MANY MATCHES?
		MOVE T,D
		JRST .+1]
	AOBJN D,XLOP
	JUMPE T,CERRET	;ANY MATCH?
	MOVE D,T	;YES, CALL IT
	TLNE TFLG
	OUTCHR["-"]
	PUTSIX (D)
	OUTSTR[ASCIZ/
/]
EXACT:	ADDI D,XDIS-XTAB
	TLNN TFLG	;IS THIS A NOT
	SKIPA A,(D)	;NO
	MOVS A,(D)	;YES
	TRNN A,-1	;ANY DISPATCH FOR THIS FLAVOR?
	JRST CERRET
	JRST (A)	;YES

XAMBIG:	OUTSTR[ASCIZ/SORRY, AMBIGUOUS
/]
	POPJ P,
SUBTTL	X TABLES
;COMMANDS FOR TOP MODE
DEFINE XARGS
<	XMAC	SPACES,SETSPC,CLRSPC,<SEE SPACES IN SIGNAL NAMES>
	XMAC	REFERENCES,SETREF,CLRREF,<ENABLE MULTIPLE SIGNAL NAME REFERENCES>
	XMAC	STATUS,PSTATE,,<PRINT CURRENT STATUS>
	XMAC	DEFPPN,STZPPN,CLZPPN,<SET DEFAULT PPN FOR INPUT ONLY>
	XMAC	USED,USED,USEPC,<USE D WIRELIST>
	XMAC	USEPC,USEPC,USED,<USE PC WIRELIST>
	XMAC	WLID,WIRID,,<CHANGE WIRELIST ID>
	XMAC	FILES,PFILES,,<PRINT FILE LIST FOR CARD>
	XMAC	BFILES,BFILES,,<PINT FILE LIST FOR BACKPANEL>
	XMAC	WLSSEL,WLSSEL,,<WRITE 'WLS' FILE AND SELECT CATEGORY(S)>
	XMAC	BSSEL,BSSEL,,<WRITE 'BS' FILE AND SELECT CATEGORY(S)>
	XMAC	MAKALL,MAKALL,,<WRITE 'WL', 'WLS', AND 'WLU' FILES>
	XMAC	BMAKALL,BMAKAL,,<WRITE 'BL', AND 'BLS' FILES>
	XMAC	PART,DOPART,,<WRITE WAGNER PARTITION FILE>
	XMAC	UML,PNTUML,,<MAKE UML LISTING>
	XMAC	SIGSUM,DOREF,,<MAKE SIGNAL SUMMARY>
	XMAC	CONSUM,SIGCOM,,<MAKE CONNECTORS NEEDED SUMMARY>
DEC,<	XMAC	UMAKE,UMLOUT,,<MAKE 'UML' FILE FOR SETTING "U" NUMBERS FROM REAL PINS>
	XMAC	FIXCON,CPNOUT,,<OUTPUT LIST OF CONNECTOR PINS FOR UPDATING DRAWINGS>
	XMAC	SPREFIX,SPIOUT,,<OUTPUT SIGNAL LIST FOR "GREAT SIGNAL NAME CHANGE">
>;dec
	XMAC	STUFF,STFLST,,<MAKE DIP STUFFING LIST FOR CARD>
	XMAC	LPART,PRTLST,,<MAKE PARTS LIST>
	XMAC	MPART,MPART,,<MAKE MASTER PARTS LIST (FROM BAC FILES)>
	XMAC	OUTSUM,OUTSUM,,<WRITE OUTPUT PIN TERMINATION SUMMARY>
	XMAC	TERMLIST,TRMLST,,<WRITE TERMINATOR TEST POINT LIST>
	XMAC	TEST,TSTWRT,,<WRITE CARD TESTER FILE>
	XMAC	SIMPLE,WIRWRT,,<OUTPUT BACK PANEL TO DEC WIRELISTER>
	XMAC	ASIMPLE,ASIMPLE,,<WRITE 'SMP' FILE, BUT ASSIGN REAL PIN NAMES IN PLACE OF "U" PIN NAMES>
	XMAC	BSIMPLE,BSIMPLE,,<WRITE 'SMP' FILE INCLUDING ALL PWR PINS>
	XMAC	OSIMPLE,OSIMPLE,,<WRITE 'SMP' FILE OFFSETTING SLOT NUMBERS>
	XMAC	PSIMPLE,PSIMPLE,,<WRITE 'SMP' FILE WITH ONLY POWER PINS IN IT>
	XMAC	SSIMPLE,SSIMPLE,,<WRITE 'SMP' FILE, ASK ABOUT SPECIFIC FEATURES>
DEC,<	XMAC	REDAC,REDAC,,<OUTPUT REDAC CONNECTION LIST>
	XMAC	CALDEC,REDAC,,<OUTPUT CALDEC CONNECTION LIST>
	XMAC	CS,CSWRT,,<OUTPUT 'CS' CIRCUIT SCHEMATIC NETWORK FILE FOR WRLCOM (BOARD)>
	XMAC	BCS,BCSWRT,,<OUTPUT 'CS' CIRCUIT SCHEMATIC NETWORK FILE FOR WRLCOM (BACKPANEL)>
	XMAC	SR,SRWRT,,<OUTPUT 'SR' SCHEMATIC REPRESENTATION FOR MODULE TEST GENERATOR>
	XMAC	WRESISTOR,RESFIL,,<OUTPUT FILE FOR RESISTOR DRAWING>
	XMAC	TAPR8,TP8WRT,,<OUTPUT TAPR-8 CONNECTION FILE>
>;DEC
	XMAC	ERRSUM,ERRSUM,,<LOGIC ERROR SUMMARY BACK TO D>
	XMAC	BLIST,BAKLST,,<BACK PANEL WIRE LIST>
	XMAC	BSUM,BACSUM,,<BACK PANEL SUMMARY>
	XMAC	BPRINT,TLSTBP,,<PRINT BACK PANEL SIGNAL>
	XMAC	IERROR,SETWIE,CLRWIE,<ENABLE WIRE LIST INPUT ERRORS TO GO TO FILE>
USAGE,<	XMAC	USAGE,UCOUNT,,<COUNT FREE STORAGE USAGE>	>
	XMAC	WIREGND,STWGND,CLWGND,<ENABLE WIRING OF GROUND PINS ON DIPS>
	XMAC	LNGRID,SETLNG,CLRLNG,<SWITCH DEC CARD TO A LETTER NUMBER GRID>
	XMAC	MARGIN,SLOADM,CLOADM,<SET MARGIN FOR RUN OVERLOAD ERROR>
ROUTE,<	XMAC	ROUTE,ROUTIT,,<ROUTED WIRE LIST>
	XMAC	ZLEVEL,ZLEVP,,<MAKE Z LEVEL WRAP LIST>
	XMAC	RAYTHEON,RAYP,,<RATHEON WIRE WRAP LIST "FROM-TO" FORMAT>
	XMAC	AUGAT,AUGP,,<AUGAT WIRE WRAP LIST "FROM-TO" FORMAT>
	XMAC	RAY,RAYP,,<RATHEON WIRE WRAP LIST "FROM-TO" FORMAT>
	XMAC	RAYTT,RAYTT,,<RATHEON WIRE WRAP LIST "TO-TO" FORMAT>
	XMAC	ANADU,ANADU,anano,<ROUTED WIRE LIST FOR POST-PROCESSOR>
>;ROUTE
>;XARGS

;COMMANDS FOR BOTH MODES
DEFINE BXARGS
<	XMAC	BOARD,WWSET,CLRWW,<SELECT WIREWRAP BOARD TYPE>
	XMAC	NOMENCLATURE,NOMSET,CLRNOM,<SELECT NOMENCLATURE>
	XMAC	AVAILABLE,AVAIL,,<LIST AVAILABLE NOMENCLATURE AND BOARD TYPES>
	XMAC	DDT,DDTCAL,,<CALL DDT>
	XMAC	SAVE,SAVE,,<SAVE A DUMP FILE>
	XMAC	ECL,SETECL,CLRECL
	XMAC	TTL,SETTTL,CLRECL
	XMAC	RESIDENT,STRESI,UNRESI,<MAKE DIP DEFS RESIDENT>
	XMAC	CLEAR,STRTC,,<CLEAR CORE EXCEPT FOR RESIDENT DIP DEFS>
	XMAC	DSKIN,DSKIN,,<ACCEPT TTY INPUT FROM DISK>
	XMAC	DSKHLD,DSKHLD,,<HOLD DISK INPUT(CLOSES FILE)>
	XMAC	DSKCON,DSKCON,,<CONTINUE DISK INPUT(REOPENS FILE, READS TO LAST POSITION)>
	XMAC	DSKSKP,DSKSKP,,<SKIP OVER LINES IN DSKIN FILE>
	XMAC	PAGE,STPAGE,CLPAGE,<SET LINES PER PAGE (FOR LISTINGS)>
	XMAC	WIDTH,SETWID,CLRWID,<SET CHARACTERS PER LINE (FOR LISTINGS)>
ITS,<	XMAC	XGP,SETXGP,CLRXGP,<PRODUCE XGP OUTPUT>   >
>

;COMMANDS FOR DIP MODE
DEFINE DXARGS
<
	XMAC	APACK,APACK,,<LIST AVAILABLE PACKAGE TYPES>
>

DEFINE XMAC(A,B,C,D)
<	<SIXBIT/A/>
>

XTAB:	XARGS
DXTAB:	BXARGS
TABLEN__.-XTAB
	DXARGS
DTBLEN__.-DXTAB

DEFINE XMAC(A,B,C,D)
<	IFIDN<C><><0>C,,B
>

XDIS:	XARGS
DXDIS:	BXARGS
	DXARGS

DEFINE XMAC(A,B,C,D)
<	[ASCIZ/D/]
>

UTAB:	XARGS
BUTAB:	BXARGS
DUTAB:	DXARGS
DUEND__.
SUBTTL	USAGE COUNTERS
USAGE,<
UCOUNT:
	SETZM FSTTMP
	MOVE T,[FSTTMP,,FSTTMP+1]
	BLT T,FSTTMP+FSTLEN-1		;CLEAR OUT TMP TABLE
	SETZB D,E
	MOVE L,DEFLST
	PUSHJ P,DODCNT
	FETCH(W,L,PCWL)
	JRST DOPCCN

DODCNT:	FETCH(W,L,BLST)
	JUMPE W,NOUBAK
	OUTSTR[ASCIZ/
BACK PANEL LIST:
/]
	SETZB A,D
	FETCH(H,L,BKNM)
	JUMPE H,NXBKNM
BKNMCT:	ADDI A,1
	FETCH(H,H,FNXT)
	JUMPN H,BKNMCT
	MOVEI T,1+ADDR(0,FBLK)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,A
	ADDM T,FSTTMP+ADDR(0,FBLK)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,A
	IMULI T,1+ADDR(0,FBLK)
	MOVE D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	FILENAME BLOCKS
/]
NXBKNM:	TRO ISBACK
	PUSHJ P,WCNT
NOUBAK:	FETCH(W,L,WIRL)
DOPCCN:	JUMPE W,NOUCNT
	TRZ ISBACK
	OUTSTR[ASCIZ/
CARD(S):
/]
UCNT3:	OUTSTR[ASCIZ/
/]
	FETCH(T,W,FCRD)
	HRLZM T,SLICEL
	JUMPE T,.+2
	PUSHJ P,PSLICL
	OUTSTR[ASCIZ/
/]
	SETZ D,
	PUSHJ P,WCNT
	FETCH(W,W,NXTWL)
	JUMPN W,UCNT3
NOUCNT:	CAMN E,D
	JRST NOTOT
	OUTSTR[ASCIZ/GRAND TOTAL =	/]
	MOVE T,E
	PUSHJ P,TTYDEC
NOTOT:	OUTSTR[ASCIZ/

/]
	MOVE A,[-FSTLEN,,1]
	OUTSTR[ASCIZ/SIZE	COUNT	TOTAL
/]
	SETZB D,E
UCNT1:	SKIPN FSTCNT-1(A)
	JRST NALLOC
	MOVEI T,(A)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,FSTCNT-1(A)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVEI T,(A)
	IMUL T,FSTCNT-1(A)
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	ALLOCATED
/]
	MOVE C,FSTPNT-1(A)
	SETZ B,
	SKIPE C,(C)
	AOJA B,.-1
	JUMPE B,NFREE
	OUTCHR[11]
	MOVE T,B
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,B
	IMULI T,(A)
	SUB D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	FREE
/]
NFREE:	SKIPN T,FSTTMP-1(A)
	JRST NALLOC
	OUTCHR[11]
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,FSTTMP-1(A)
	IMULI T,(A)
	ADD E,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	IN USE
/]
NALLOC:	AOBJN A,UCNT1
	JUMPE D,CPOPJ
	OUTSTR[ASCIZ/TOTAL ALLOCATED - FREE =	/]
	MOVE T,D
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	OUTSTR[ASCIZ/          TOTAL IN USE =	/]
	MOVE T,E
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	MOVE T,D
	SUB T,E
	JUMPE T,CPOPJ
	OUTSTR[ASCIZ/            TOTAL LOST =	/]
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	POPJ P,

WCNT:	AOS FSTTMP+ADDR(0,WLBLOCK)
	SETZB A,B
	MOVEI H,RADDR(W,WBDY,NXTB)
	JRST WCNT1

WCNT2:	ADDI A,1
	MOVEI G,ADDR(H,BNAM)
	MOVE B,G
BCNT1:	MOVE T,(G)
	TRNE T,376
	AOJA G,BCNT1
	SUBM G,B
WCNT1:	FETCH(H,H,NXTB)
	JUMPN H,WCNT2
	MOVEI T,1+ADDR(0,BHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,A
	ADDM T,FSTTMP+ADDR(0,BHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVEI T,1+ADDR(0,BHEAD)
	IMUL T,A
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	BODIES
1	/]
	MOVE T,B
	ADDM T,FSTTMP
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,B
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	BODY NAMES-1
/]
	MOVEI H,RADDR(W,WIRES,ALPH)
	SETZB A,B
	SETZB C,F
	SETZ TT,
	JRST WCNT3

WCNT4:	ADDI B,1
	MOVEI G,ADDR(H,SPNT)
	MOVE T,G
WCNTS:	MOVE TTT,(G)
	TRNE TTT,376
	AOJA G,WCNTS
	SUB G,T
	ADD F,G
	FETCH(T,H,WBIT)
	TRNE T,NAM2ND
	JRST WCNT3
	ADDI A,1
	SETZM LSLOT
	MOVEI G,RADDR(H,WPIN,NXTP)
	JRST WCNT5

WCNT6:	ADDI C,1
WCNT5:	FETCH(G,G,NXTP)
	JUMPN G,WCNT6
WCNT3:	FETCH(H,H,ALPH)
	JUMPN H,WCNT4
	OUTCHR[11]
	MOVE T,A
	PUSHJ P,TTYDEC
	OUTCHR[11]
	OUTSTR[ASCIZ/	WIRES
/]
	MOVEI T,1+ADDR(0,WHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,B
	ADDM T,FSTTMP+ADDR(0,WHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVEI T,1+ADDR(0,WHEAD)
	IMUL T,B
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	SIGNAL BLOCKS
1	/]
	MOVE T,F
	ADDM T,FSTTMP
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,F
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	SIGNAL NAMES-1
/]
	MOVEI T,1+ADDR(0,PHEAD)
	TRNE ISBACK
	MOVEI T,1+ADDR(0,BPHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVE T,C
	TRNN ISBACK
	ADDM T,FSTTMP+ADDR(0,PHEAD)
	TRNE ISBACK
	ADDM T,FSTTMP+ADDR(0,BPHEAD)
	PUSHJ P,TTYDEC
	OUTCHR[11]
	MOVEI T,1+ADDR(0,PHEAD)
	TRNE ISBACK
	MOVEI T,1+ADDR(0,BPHEAD)
	IMUL T,C
	ADD D,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/	PINS
/]
	OUTSTR[ASCIZ/	TOTAL =	/]
	MOVE T,D
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	ADD E,D
	POPJ P,
>;USAGE
SUBTTL	MORE EXTENDED SUBRS
MAKALL:	SETZM ALLNAM
	SETZM ALLCRD
	PUSHJ P,LIST
	PUSHJ P,ALLWLS
	PUSHJ P,ALLUSE
ITS,<	TRZ DOPRTL
	PUSHJ P,ALLSTF
>;ITS				; STF LISTS WERE FLUSHED FROM DEC VERSION
NODEC,<	POPJ P,>
DEC,<	TRO DOPRTL		;DO PARTS LIST
	JRST ALLSTF
>;DEC

BMAKAL:	MOVE L,DEFLST
	FETCH(W,L,BLST)
	JUMPE W,[OUTSTR[ASCIZ/NO BACK PANEL WIRELIST.
/]
		POPJ P,]
	PUSHJ P,BAKLST
	JRST ALLBS

PUSE:	XCT GETCHR
	JFCL
	CAIE TTT,12
	JRST ERRET
	OUTSTR[ASCIZ/COMMAND	 ********* MEANING *******************
?	PRINT THIS LIST
/]
	MOVE A,[UTAB-BUTAB,,0]
	OUTSTR[ASCIZ/
TOP MODE:
/]
	PUSHJ P,PUSE1
	MOVE A,[BUTAB-DUTAB,,BUTAB-UTAB]
	OUTSTR[ASCIZ/
TOP MODE OR DIP SUB-MODE:
/]
	PUSHJ P,PUSE1
	MOVE A,[DUTAB-DUEND,,DUTAB-UTAB]
	OUTSTR[ASCIZ/
DIP SUB-MODE:
/]
PUSE1:	PUTSIX XTAB(A)		;SIXBIT COMMAND NAME
	HLRZ T,XDIS(A)
	SKIPE T			;-?
	OUTCHR["-"]		;YES
	OUTCHR[11]
	PUTSTR @UTAB(A)
	OUTSTR[ASCIZ/
/]
	AOBJN A,PUSE1
	POPJ P,

WWSET:	SKIPGE A,WWTYP
	JRST GETBRD
	OUTSTR[ASCIZ/BOARD TYPE IS: /]
	OUTSTR @WNAMES(A)
	OUTSTR[ASCIZ/
/]
	JRST GETBRD

NOMSET:	SKIPGE A,NOMTYP
	JRST GETNOM
	OUTSTR[ASCIZ/NOMENCLATURE TYPE IS: /]
	OUTSTR @LNAMES(A)
	OUTSTR[ASCIZ/
/]
	JRST GETNOM

PFILES:	TRZA ISBACK
BFILES:	TRO ISBACK
	MOVE TTT,[PUSHJ P,TTYOUT]
	MOVEM TTT,PUTCHR
	SETOM TTYFLG
	SETZM LCOUNT
	SETZM LINCNT
	TLO NOFF
	MOVE L,DEFLST
	TRNE ISBACK
	JRST [	FETCH(W,L,BLST)
		JRST AFILES]
	PUSHJ P,LSTGET
	POPJ P,
AFILES:	PUSHJ P,TFILES
	 PUTHDR
	POPJ P,

SETECL:	SKIPA T,[ECL]
SETTTL:	MOVEI T,TTL
	MOVEM T,DEFECL
	POPJ P,

CLRECL:	SETZM DEFECL
	POPJ P,

SETLNG:	SKIPN ISWW
	JRST NXWW
	SETOM LNGRID
	POPJ P,

NXWW:	OUTSTR[ASCIZ/SORRY, COMMAND VALID FOR WIRE WRAP BOARDS ONLY.
/]
	POPJ P,

CLRLNG:	SKIPN ISWW
	JRST NXWW
	SETZM LNGRID
	POPJ P,

STWGND:	SKIPN ISWW
	JRST NXWW
	SETOM WIRGND
	POPJ P,

CLWGND:	SKIPN ISWW
	JRST NXWW
	SETZM WIRGND
	POPJ P,

STPAGE:	OUTSTR[ASCIZ/LINES PER PAGE = /]
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,DECIN
	JFCL
	CAIE TTT,12
	JRST ERRET
	JUMPE A,ERRET
	MOVEM A,PAGLEN
	POPJ P,

CLPAGE:	MOVEI TTT,STDPAG
	MOVEM TTT,PAGLEN
	POPJ P,

SETWID:	OUTSTR[ASCIZ/CHARACTERS PER LINE = /]
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,DECIN
	JFCL
	CAIE TTT,12
	JRST ERRET
	JUMPE A,ERRET
	MOVEM A,LWIDTH
	POPJ P,

CLRWID:	MOVEI TTT,STDWID
	MOVEM TTT,LWIDTH
	POPJ P,

SLOADM:	OUTSTR[ASCIZ/% OF MAXIMUM = /]
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,DECIN
	JFCL
	CAIE TTT,12
	JUMPLE A,ERRET
	MOVEM A,LOADMG
	POPJ P,

CLOADM:	MOVEI TTT,=100
	MOVEM TTT,LOADMG
	POPJ P,
SUBTTL XGP ROUTINES FOR ITS
ITS,<
CLRXGP:	SETZM XGP
	MOVEI T,STDPAG
	MOVEM T,PAGLEN
	POPJ P,

FONTI:	.CALL [	SETZ
		SIXBIT /IOT/
		1000,,FONTCH
		SETZ T]
	JRST ERRET
	POPJ P,

SETXGP:	SETZM XGP
	MOVE T,[SIXBIT /KST/]
	MOVEM T,DEFEXT
	MOVEI T,0		;ALL KINDS OF KLUDGERY TO DEFAULT PPN CORRECTLY
	DSKPPN T,
	PUSH P,T
	MOVE T,[SIXBIT /FONTS/]
	DSKPPN T,
	PUSHJ P,SETFIL
	CAIA
	JRST SETXG1		;RESTORE DSKPPN AND OPEN FONT
	MOVE T,[SIXBIT /20FG/]	;GIVE HIM FIX20
	MOVEM T,FILNAM
	MOVE T,[SIXBIT /KST/]
	MOVEM T,FILEXT
	MOVE T,[SIXBIT /FONTS/]
	MOVEM T,FILPPN
	PUSH P,A
	MOVEI A,FILNAM
	PUSHJ P,FILPNT
	POP P,A
SETXG1:	POP P,T
	DSKPPN T,
	.CALL [	SETZ
		SIXBIT /OPEN/
		1000,,FONTCH
		[SIXBIT /DSK/]
		FILNAM
		FILEXT
		FILPPN
		405000,,4]	;IMAGE, UNIT, INPUT
	JRST ERRET
	PUSHJ P,FONTI		;IGNORE KSTID
	PUSHJ P,FONTI		;BYTE (9) CPA, BASE_LINE (18) HEIGHT
	.CALL [	SETZ
		SIXBIT /CLOSE/
		SETZI FONTCH]
	JRST ERRET
	HRRZS T
	MOVEM T,XGPFNT		;HEIGHT
	IDIVI T,5		;VSP
	MOVEM T,XGPVSP
	ADDM T,XGPFNT
	MOVEI T,=11*XGPVBI-=256	;11"-TOP AND BOTTOM MARGINS
	IDIV T,XGPFNT
	MOVEI T,1(T)		;FIRST LINE GOES IN TOP MARGIN
	MOVEM T,PAGLEN		;THATS THE PAGE LENGTH
	OUTSTR [BYTE (7) 15, 12]
	OUTSTR [ASCIZ /LINES PER PAGE = /]
	PUSHJ P,DECOUT
	OUTSTR [BYTE (7) 15, 12]
	MOVE T,FILNAM
	MOVEM T,XGPFNT
	MOVE T,FILEXT
	MOVEM T,XGPEXT
	MOVE T,FILPPN
	MOVEM T,XGPPPN
	SETOM XGP
	POPJ P,
>;ITS
SUBTTL EXTENDED SUBRS
SETSPC:	TRO PETIT		;SPACES ARE SIGNIFICANT
	POPJ P,

CLRSPC:	TRZ PETIT		;SPACES AREN'T SIGNIFICANT
	POPJ P,

SETREF:	TRO REFLAG		;ENABLE REFERENCE HACK
	POPJ P,

CLRREF:	TRZ REFLAG		;DISABLE REFERENCE HACK
	POPJ P,

SETWIE:	TRO DOWIE
	POPJ P,

CLRWIE:	TRZ DOWIE
	POPJ P,

USED:	SETOM USEDWL
	POPJ P,

USEPC:	SETZM USEDWL
	POPJ P,

STZPPN:
NOCMU,<
NOITS,<	OUTSTR [ASCIZ/DEFAULT INPUT P,PN? /]
	PUSHJ P,RDPPN
	JRST ERRET
	JUMPE A,[CAIE TTT,12
		JRST ERRET
		JRST CLZPPN]
	HRLM A,(P)
	CAIN TTT,12
	JRST [	SETZ A,
		DSKPPN A,
NOSTAN,<	HLR A,(P)	>
STAN,<		HLL A,(P)	>
		JRST GOTPN]
	CAIN TTT,","
	PUSHJ P,RDPPN
	JRST ERRET
	JUMPE A,ERRET
	CAIE TTT,12
	JRST ERRET
	HLL A,(P)
GOTPN:
>;NOITS
>;NOCMU
ITS,<	OUTSTR[ASCIZ/DEFAULT INPUT PPN? /]
	PUSHJ P,FILWRD
	JRST ERRET
	CAIE TTT,12
	JRST ERRET
>;ITS
CMU,<	OUTSTR [ASCIZ/DEFAULT INPUT PPN? /]
	SETZM PPNBUF		;CLEAR OUT A BUFFER FOR THE PPN
	SETZM PPNBUF+1
	SETZM PPNBUF+2
	MOVE A,[POINT 7,PPNBUF]
	MOVEI T,=13		;13 CHARACTERS AT MOST!
CMUPP1:	XCT GETCHR		;GET A CHAR
	JRST CMUPP3
	CAIE TTT,15		;IGNORE CR
	CAIN TTT,40		;AND SPACE
	JRST CMUPP1
	CAIN TTT,12		;LF
	JRST CMUPP3		;YES, THAT'S ALL FOLKS.
	CAIE TTT,"["		;IGNORE [
	CAIN TTT,"]"		;AND ]
	JRST CMUPP1
	CAIL TTT,"a"		;CONVERT LOWER CASE TO UPPER CASE
	CAILE TTT,"z"
	JRST .+2
	SUBI TTT,40		;CONVERT IT
CMUPP2:	IDPB TTT,A
	SOJGE T,CMUPP1		;AND GO GET ANOTHER CHAR UNLES WE HAVE 13+1
	JRST ERRET	;FUNNY, WE DIDN'T GET THERE IN 13 CHARACTERS!
CMUPP3:	MOVE T,[XWD A,PPNBUF]
	CMUDEC T,		;CONVERT THE PPN TO DEC FORMAT
	JRST ERRET		;WHOOPS, BAD PPN
>;CMU
	MOVEM A,ZPPN
	POPJ P,

CLZPPN:	SETZM ZPPN
	POPJ P,


PSTATE:	OUTSTR[ASCIZ/SPACES ARE/]
	TRNN PETIT
	OUTSTR[ASCIZ/N'T/]
	OUTSTR[ASCIZ/ SIGNIFICANT.
REFERENCE HACK IS/]
	TRNN REFLAG
	OUTSTR[ASCIZ/N'T/]
	OUTSTR[ASCIZ/ ENABLED.
/]
	OUTSTR[ASCIZ/DEFAULT WIRE LIST = /]
	MOVE T,DEFLST
	FETCH(A,T,WLID)
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/ (/]
	SKIPE USEDWL
	OUTCHR["D"]
	SKIPN USEDWL
	OUTSTR[ASCIZ/PC/]
	OUTCHR[")"]
	FETCH(A,L,WLNM)
	JUMPE A,NOWLNM
	OUTCHR[" "]
	PUSHJ P,STRTTY
NOWLNM:	OUTSTR[ASCIZ/
/]
	OUTSTR[ASCIZ/LINES PER PAGE = /]
	MOVE T,PAGLEN
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	OUTSTR[ASCIZ/CHARACTERS PER LINE = /]
	MOVE T,LWIDTH
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/
/]
	SKIPN ISWW
	JRST NXWW1
	SKIPN WIRGND
	OUTSTR[ASCIZ/NOT /]
	OUTSTR[ASCIZ/WIRING GROUNDS.
/]
NXWW1:	SKIPN ZPPN
	JRST NOZPPN
	OUTSTR[ASCIZ/DEFAULT INPUT P,PN = /]
NOCMU,<	HLLZ TT,ZPPN
	PUSHJ P,LSIXOUT
	OUTCHR[","]
	HRLZ TT,ZPPN
	PUSHJ P,LSIXOUT
>;NOCMU
CMU,<	MOVE TT,[ZPPN,PPNBUF]
	DECCMU TT,
	JRST [	PUTSIX ZPPN
		JRST .+2]
	OUTSTR PPNBUF
>;CMU
	OUTSTR[ASCIZ/
/]
NOZPPN:	MOVE T,DEFECL
	TRNE T,ECL
	OUTSTR[ASCIZ/DIP-MODE, DEFAULT ECL PINS.
/]
	TRNE T,TTL
	OUTSTR[ASCIZ/DIP-MODE, DEFAULT TTL PINS.
/]
	SKIPN DIPLST
	JRST DSKICK
	OUTSTR[ASCIZ/DIPS ARE IN/]
	SKIPE RESIDENT
	OUTSTR[ASCIZ/ AND PERMANENTLY CORE RESIDENT/]
	OUTSTR[ASCIZ/.
/]
DSKICK:	SKIPN DSKFLG
	JRST CKWWT
	OUTSTR[ASCIZ/DSKIN:	/]
	MOVEI A,DSKNAM
	PUSHJ P,FILPNT
	SKIPN DSKACT
	JRST [	OUTSTR[ASCIZ/HOLDING
/]
		JRST CKWWT]
	OUTSTR[ASCIZ/ACTIVE
/]
CKWWT:	SKIPGE T,WWTYP
	JRST CKNOMT
	OUTSTR[ASCIZ/BOARD TYPE: /]
	OUTSTR @WNAMES(T)
	OUTSTR[ASCIZ/
/]
CKNOMT:	SKIPGE T,NOMTYP
	POPJ P,
	OUTSTR[ASCIZ/NOMENCLATURE TYPE: /]
	OUTSTR @LNAMES(T)
	OUTSTR [ASCIZ/
/]
	POPJ P,

DSKIN:	PUSHJ P,DSKINB
	JFCL
	POPJ P,

DSKINB:	MOVSI T,'TXT'
	MOVEM T,DEFEXT
	PUSHJ P,SETFIL		;GET A FILE NAME
	POPJ P,			;QUIT
DSKINA:	INIT IDSK,0
	'DSK   '
	IDSKHD
	JRST [	OUTSTR[ASCIZ/CAN'T GET DISK!
/]
		SETZM DSKFLG
		SETZM DSKACT
		POPJ P,]
	MOVEI T,IDSKBF
	EXCH T,.JBFF
	INBUF IDSK,1
	MOVEM T,.JBFF
	MOVE T,FILPPN
	LOOKUP IDSK,FILNAM
	JRST [	MOVE T,[OUTCHR TTT]
		MOVEM T,PUTCHR
		OUTSTR[ASCIZ/ LOOKUP FAILED, CODE = /]
		HRRZ T,FILEXT
		PUSHJ P,DECOUT
		OUTSTR[ASCIZ/
/]
		SETZM DSKFLG
		SETZM DSKACT
		RELEASE IDSK,
		POPJ P,]
	MOVEM T,DSKPP
	MOVE T,FILNAM
	MOVEM T,DSKNAM
	HLLZ T,FILEXT
	MOVEM T,DSKEXT
	SETZM DSKCNT		;NO CHARS READ YET!
	SETOM DSKFLG		;NOW READING INDIRECT FILE
	SETOM DSKACT		;ACTIVATE IT
	SETZM CBITS
	OUTSTR[ASCIZ/
/]
	JRST CPOPJ1

DSKHLD:	SKIPE DSKFLG
	JRST DSKHL1
	OUTSTR[ASCIZ/NO FILE OPEN YET.
/]
	PUSHJ P,DSKINB
	POPJ P,			;LOSE
DSKHL1:	SKIPN DSKACT
	JRST [	OUTSTR[ASCIZ/ALREADY HOLDING!
/]
		POPJ P,]
	SETZM DSKACT
	RELEASE IDSK,		;JUST FOR FUN, RELEASE IT
	POPJ P,

DSKCON:	SKIPN DSKFLG
	JRST ERRET
	SKIPE DSKACT
	POPJ P,
	PUSHJ P,DSKCN0
	POPJ P,
	POPJ P,

DSKCN0:	MOVE T,DSKNAM
	MOVEM T,FILNAM
	MOVE T,DSKEXT
	MOVEM T,FILEXT
	MOVE T,DSKPP
	MOVEM T,FILPPN
	SETZM FILDAT
	PUSH P,DSKCNT
	PUSHJ P,DSKINA
	JRST [	POP P,(P)
		POPJ P,]
	POP P,A
	SETZM DSKACT		;DEACTIVATE SO WON'T ECHO
DSKCN1:	CAMG A,DSKCNT		;THERE YET?
	JRST DSKCN2		;YES
	PUSHJ P,DSKINC		;NO, READ SOME MORE
	POPJ P,			;RAN OUT??????
	JRST DSKCN1

DSKCN2:	SKIPN DSKFLG		;STILL IN FILE?
	POPJ P,
	SETOM DSKACT		;YES, ACTIVATE INPUT AGAIN
	JRST CPOPJ1

DSKSKP:	SKIPE DSKFLG
	JRST DSKSK0
	OUTSTR[ASCIZ/NO FILE OPEN YET.
/]
	PUSHJ P,DSKINB
	POPJ P,
	PUSH P,[0]
	JRST DSKSK1

DSKSK0:	PUSH P,DSKACT
	SKIPE DSKACT
	JRST DSKSK1
	PUSHJ P,DSKCN0
	POPJ P,
DSKSK1:	SETOM DSKACT
	PUSHJ P,DSKINC
	JRST DSKSK2
	CAIE TTT,12
	JRST DSKSK1
	SETZM DSKACT		;NOW GET FROM TTY
	ASK[ASCIZ/STOP?/]
	JRST DSKSK2
	JRST DSKSK1
	POP P,DSKACT
	POPJ P,

DSKSK2:	POP P,(P)
	SETZM DSKACT
	POPJ P,

IERR:	SKIPN DSKACT		;DOING DISK INPUT?
	JRST [	CLRBFI		;NO
		POPJ P,]
	OUTSTR[ASCIZ/
MANUAL INTERVENTION REQUIRED, DSKHLD DONE.
/]
	SETZM DSKACT
	RELEASE IDSK,
	POPJ P,
SUBTTL	MAKLST
;READ A FILENAME AND GO INDIRECT IF NECESSARY!

MAKLST:	SETZM VARLST		;CLEAR THESE
	SETZM SLICEL
	SKIPN T,ZPPN
	DSKPPN T,
	MOVEM T,ATPPN		;SET DEFAULT PPN
	TLZ TFLG		;FLAG NO VAR LIST YET
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUSHJ P,GETWRD
	JRST TTYEOF
	CAIN TTT,"@"
	JUMPE A,INDIR
	PUSHJ P,TERMA
	JRST TTYEOF		;EOF?????
	POPJ P,
	MOVE T,FILNAM
	MOVEM T,LSTNAM		;REMEMBER NAME FOR ^E
	POPJ P,

TTYEOF:	OUTSTR[ASCIZ/UNEXPECTED EOF FROM TTY.
/]
	JRST NERRET

NONAME:	OUTSTR[ASCIZ/NO FILESPEC AFTER @.
/]
	JRST NERRET

INDIR:	MOVE T,DEFEXT
	HLLM T,(P)		;SAVE OLD EXT
	MOVSI T,'DIR'
	MOVEM T,DEFEXT		;SET DEFAULT FOR @FILE
	PUSHJ P,GTERM		;READ INDIRECT FILESPEC
	JRST TTYEOF		;EOF??????
	JRST NONAME		;@ WITH NO NAME??
	HLLZ T,(P)
	MOVEM T,DEFEXT		;RESET DEFAULT EXT
	HRRZ T,DIRLST
	MOVEM T,IDRLST
	MOVEI T,DIRLST
	HRLZM T,DIRLST
	PUSHJ P,IN0		;SETUP FOR TEXT INPUT
	POPJ P,			;GIVE UP
	MOVE T,[PUSHJ P,INDCHR]
	MOVEM T,GETCHR
	MOVE E,IDRLST
	FETCH(E,E,CVAR)		;GET VAR POINTER
INDIRA:	MOVE A,IDRLST
	FETCH(T,A,DFIL)
	MOVEM T,FILNAM
	FETCH(T,A,DEXT)
	HRLZM T,FILEXT
	FETCH(T,A,DPPN)
	MOVEM T,FILPPN
	SKIPN T,ZPPN
	MOVE T,FILPPN
	MOVEM T,ATPPN		;USE AS DEFAULT PPN ALSO
	SETZM VARLST		;ASSUME NO VARS
	JUMPE E,NOCLVR		;ANY CARD OR VAR LIST?
	TLO TFLG		;FLAG VARS AND OR BOUNDS AND OR CARD LOC
	FETCH(T,E,CDLC)		;CARD LOC
	HRLZM T,SLICEL		;SETUP INFO TO COPY
	FETCH(T,E,LBND)		;LOWER BOUND
	MOVEM T,LOWER
	FETCH(T,E,UBND)		;UPPER BOUND
	MOVEM T,UPPER
	FETCH(T,E,VLST)		;VARIABLE LIST
	MOVEM T,VARLST
NOCLVR:	OUTCHR ["@"]
	PUSH P,A
	MOVEI A,FILNAM
	PUSHJ P,FILPNT
	POP P,A
	LOOKUP DAT,FILNAM
	JRST [	OUTSTR[ASCIZ/ LOOKUP FAILED, CODE = /]
		HRRZ T,FILEXT+1
		PUSHJ P,DECOUT
		OUTSTR[ASCIZ/
/]
		JUMPE E,CPOPJ
		ASK[ASCIZ/TYPE Y TO GO ON?/]
		POPJ P,
		POPJ P,
		JRST INDIRB]
	MOVE T,FILNAM
	MOVEM T,LSTNAM		;REMEMBER @NAME FOR OUTPUT
	SKIPN SLICEL
	JRST NDISLC
	OUTCHR[11]
	PUSHJ P,PSLICL
NDISLC:	SKIPN VARLST
	JRST INDIRC
	SKIPN SLICEL
	OUTCHR[11]
	OUTCHR["("]
	MOVE T,LOWER
	CAMN T,[-400000]
	JRST NPLWR
	PUSHJ P,DECOUT
	OUTCHR[74]
NPLWR:	MOVE T,UPPER
	CAIN T,377777
	JRST NPUPR
	PUSHJ P,DECOUT
	OUTCHR[76]
NPUPR:	SKIPN A,VARLST
	JRST VARDNI
	CAIA
VARLPI:	OUTCHR[","]
	FETCH(T,A,LET)
	OUTCHR T
	OUTCHR["="]
	FETCH(T,A,VAL)
	FETCH(TT,A,WID)
	MOVEM TT,NDIG
	PUSHJ P,NDECOUT
	FETCH(A,A,NVAR)
	JUMPN A,VARLPI
VARDNI:	OUTCHR[")"]
INDIRC:	PUSH P,VARLST
	PUSH P,SLICEL
	PUSHJ P,GTERM
	JRST [	POP P,SLICEL
		POP P,VARLST
		JRST INDIRB]
	JFCL			;IGNORE NULL
	POP P,SLICEL
	POP P,VARLST		;RESTORE INDIRECT VARLST
	JRST INDIRC

INDIRB:	OUTSTR[ASCIZ/
/]
	JUMPE E,CPOPJ
	FETCH(E,E,NSLC)
	JUMPN E,INDIRA
	POPJ P,

DIRRET:	HRRZ B,DIRLST
	MOVSI T,DIRLST
	MOVEM T,DIRLST		;POINT DIRLST TO ITSELF
RETIT:	MOVE A,B
	FETCH(B,B,DIRNXT)	;GET NEXT POINTER NOW
	FETCH(C,A,CVAR)		;GET CARD AND VAR HEADER
	FSTRET(A,DIRHEAD)	;RETURN HEAD
	JUMPE C,RETIT1		;LEAVE IF NO VARLIST
RETIT2:	FETCH(D,C,VLST)		;VAR LIST POINTER
	JUMPE D,RETIT3
RETIT4:	MOVE A,D
	FETCH(D,D,NVAR)
	FSTRET(A,VBLK)
	JUMPN D,RETIT4
RETIT3:	MOVE A,C
	FETCH(C,C,NSLC)
	FSTRET(A,CBND)
	JUMPN C,RETIT2
RETIT1:	JUMPN B,RETIT
	POPJ P,

IDRRET:	SETZM IDRLST
	JRST RETIT
SUBTTL	GTERM
;READ ONE TERM FOR MAKLST

GTERM:	PUSHJ P,GETWRD		;READ WORD
	JRST [	JUMPN A,MIDEOF	;ERROR IF NOT NULL WORD
		POPJ P,]	;EOF
TERMA:	PUSHJ P,FTERM0
	JRST MIDEOF		;TOO LATE FOR EOF, ERROR
	JRST [	SKIPN FILNAM	;NO LF, NULL NAME ILLEGAL
		JRST NOFNAM
		JRST TERM1]
	SKIPN FILNAM	;NO LF SEEN
	JRST CPOPJ1	;NULL NAME RETURN
TERM1:	GETFS(T,DIRHEAD)
	HLRZ TT,DIRLST
	STORE(T,TT,DIRNXT)
	HRLM T,DIRLST
	CLEAR(T,DIRNXT)
	MOVE TT,FILNAM
	STORE(TT,T,DFIL)	;STORE FILENAME
	HLRZ TT,FILEXT
	STORE(TT,T,DEXT)	;STORE EXT
	MOVE TT,FILPPN
	STORE(TT,T,DPPN)	;STORE PPN
	CLEAR(T,CVAR)		;CLEAR CVAR POINTER
	MOVEI B,RADDR(T,CVAR,NSLC)	;THIS WILL LOOK LIKE AN NSLC POINTER
	JRST TERM4

TERM3:	XCT GETCHR
	JRST MIDEOF		;ILLEGAL EOF
TERM4:	CAIN TTT,","
	JRST TERM3		;SKIP COMMAS LIKE SPACES
	CAIE TTT,40
	CAIN TTT,11
	JRST TERM3
	CAIN TTT,12
	JRST TERME
	GETFS(T,CBND)		;EITHER NEED BLOCK OR ERROR
	STORE(T,B,NSLC)		;STORE AS HIS NEXT SLICE BLOCK
	MOVE B,T
	BCLEAR(T,B,CBND)	;CLEAR OUT BLOCK
	PUSHJ P,GTSLTT		;TRY TO READ SLOT
	JRST ILLSLT		;APPEARED TO BE THERE, BUT WRONG FORMAT
	HLRZ A,SLICEL
	STORE(A,B,CDLC)		;STORE CARD LOC
	CAIE TTT,"("
	JRST [	JUMPE A,ILLSLT
		CAIE TTT,12
		CAIN TTT," "
		JRST TERM4	;SPACE AND LF ARE OK
		CAIE TTT,","	;AND COMMA
		CAIN TTT,11	;AND TAB
		JRST TERM4
		JRST ILLSLT]
;HERE WE ARE READING A VARIABLE LIST
	MOVNI T,400000
	STORE(T,B,LBND)
	MOVEI T,377777
	STORE(T,B,UBND)
	PUSHJ P,VCOPY		;COPY ANY VARS FROM HIGHER UP
	MOVEI C,RADDR(B,VLST,NVAR);MAKE IT LOOK LIKE AN NVAR POINTER
GOTULB:	PUSHJ P,SDECIN
	JRST MIDEOF
	CAIE TTT,74
	JRST CKUPR
	HRLM A,1(C)
	PUSHJ P,SDECIN
	JRST MIDEOF
CKUPR:	CAIE TTT,76
	JRST [	JUMPN A,ILLBND
		JRST GOTLET]
	HRRM A,1(C)
	HLRE T,1(C)
	CAMLE T,A
	JRST ILLBND
RVARS1:	XCT GETCHR
	JRST MIDEOF
GOTLET:	PUSHJ P,LETCHK
	JRST ILLVAR
	MOVEM TTT,LETTER
	SETZM NDIG
	PUSHJ P,SDECIN
	JRST MIDEOF
	CAIN TTT,"="
	JUMPE A,[SETZM NDIG
		PUSHJ P,SDECIN
		JRST MIDEOF
		JRST .+1]
	MOVEM A,WIDTH
	MOVEI C,RADDR(B,VLST,NVAR)
	MOVE T,LETTER
	JRST CKVAR1

CKVAR2:	FETCH(TT,C,LET)
	CAMN T,TT
	JRST [	FETCH(D,D,NVAR)
		JRST CKVAR3]
CKVAR1:	MOVE D,C
	FETCH(C,C,NVAR)
	JUMPN C,CKVAR2
	GETFS(C,VBLK)
	CLEAR(C,NVAR)
	STORE(C,D,NVAR)
CKVAR3:	MOVE T,LETTER
	STORE(T,C,LET)
	MOVE T,WIDTH
	STORE(T,C,VAL)
	MOVE T,NDIG
	STORE(T,C,WID)
	CAIN TTT,","
	JRST RVARS1		;MORE VARS
	CAIE TTT,")"
	JRST ILLVAR
	JRST TERM3

MIDEOF:	OUTSTR[ASCIZ/EOF IN MIDDLE OF TERM.
/]
	JRST NERRET

NOFNAM:	OUTSTR[ASCIZ/NO FILENAME SEEN IN FILESPEC.
/]
	JRST NERRET

ILLSLT:	OUTSTR[ASCIZ/ILLEGAL BOARD LOCATION.
/]
	JRST NERRET

ILLBND:	OUTSTR[ASCIZ/ERROR IN BOUNDS ARGS.
/]
	JRST NERRET

ILLVAR:	OUTSTR[ASCIZ/ERROR IN VARIABLE SPECIFICATION.
/]
	JRST NERRET

TERME:	HLRZ B,DIRLST
	FETCH(T,B,CVAR)		;CARD VAR LIST
	JUMPN T,TERMF1
	SKIPN SLICEL		;ANY CRDLOC
	SKIPE VARLST		;OR VARS?
	CAIA			;YES, COPY THEM
	JRST CPOPJ2		;NO, THAT'S ALL
	GETFS(T,CBND)
	STORE(T,B,CVAR)
	MOVE B,T
	CLEAR(B,NSLC)
	CLEAR(B,VLST)
	HLRZ T,SLICEL
	STORE(T,B,CDLC)
	PUSHJ P,VCOPY
	JRST CPOPJ2

;SET SLICE FROM I FILE
TERMF1:	FETCH(B,B,CVAR)		;DO EACH
TERMG:	FETCH(T,B,CDLC)
	JUMPN T,TERMF		;ALREADY GOT ONE?
	MOVE T,SLICEL
	STORE(T,B,CDLC)		;STORE ONE FROM I FILE
TERMF:	FETCH(B,B,NSLC)
	JUMPN B,TERMG
	JRST CPOPJ2

VCOPY:	TLNN TFLG		;ANYTHING FROM INDIRECT TERM?
	POPJ P,			;NO, RETURN IMMEDIATELY
	MOVE T,UPPER
	STORE(T,B,UBND)
	MOVE T,LOWER
	STORE(T,B,LBND)
	SKIPN D,VARLST		;ANY VARS?
	POPJ P,			;NO, THATS ALL
	MOVEI C,RADDR(B,VLST,NVAR)
VCOPY1:	GETFS(T,VBLK)
	STORE(T,C,NVAR)
	MOVE C,T
	FETCH(T,D,VAL)
	STORE(T,C,VAL)
	FETCH(T,D,LET)
	STORE(T,C,LET)
	FETCH(T,D,WID)
	STORE(T,C,WID)
	FETCH(D,D,NVAR)
	JUMPN D,VCOPY1
	CLEAR(C,NVAR)		;CLEAR LAST LINK
	POPJ P,

FVCOPY:	HRRZ T,PINLOC
	STORE(T,B,MCRD)
	MOVE T,UPPER
	STORE(T,B,MUBN)
	MOVE T,LOWER
	STORE(T,B,MLBN)
	SKIPN D,VARLST
	POPJ P,
	MOVEI C,RADDR(B,MVLS,NVAR)
	JRST VCOPY1
SUBTTL	FILENAME SCANNER
FTERM0:	MOVE T,ATPPN
	JRST FTERM1

FTERM:	PUSHJ P,GETWRD
	POPJ P,
	SETZ T,
NODECOS,<	DSKPPN T,>
FTERM1:	MOVEM T,FILPPN
	MOVE T,DEFEXT
	MOVEM T,FILEXT
	SETZM FILDAT
NOITS,<
	JUMPN A,NEXIST
	CAIE TTT,TEXIST
	JRST NEXIST
	PUSHJ P,CHRCHK
	POPJ P,
	CAIA			;DELIMITER AS EXPECTED
	JRST CPOPJ1
	SKIPN A,LSTNAM
	JRST CPOPJ1
NEXIST:	MOVEM A,FILNAM
	CAIE TTT,"."
	JRST FTERM2
	PUSHJ P,GETWRD
	POPJ P,
	HLLZM A,FILEXT
FTERM2:	CAIE TTT,"["
	JRST FTERM3
NOCMU,<
	PUSHJ P,RDPPN
	POPJ P,
	HRLM A,FILPPN
	CAIE TTT,","
	JRST NOPRG
	PUSHJ P,RDPPN
	POPJ P,
	HRRM A,FILPPN
NOPRG:	CAIN TTT,12
	JRST CPOPJ2
>;NOCMU
CMU,<	SETZM PPNBUF		;CLEAR OUT A BUFFER FOR THE PPN
	SETZM PPNBUF+1
	SETZM PPNBUF+2
	MOVE A,[POINT 7,PPNBUF]
	MOVEI T,=13		;13 CHARACTERS AT MOST!
CMUPP4:	XCT GETCHR		;GET A CHAR
	POPJ P,
	CAIL TTT,"0"		;0-9 ARE LEGAL IN PPN'S
	CAILE TTT,"9"
	CAIN TTT,","		;SO IS COMMA
	JRST CMUPP5		;SO GO STORE IT
	PUSHJ P,LETCHK
	JRST CMUPP6		;NO, MUST BE THE END
CMUPP5:	IDPB TTT,A
	SOJG T,CMUPP4		;AND GO GET ANOTHER CHAR UNLES WE HAVE 13
	XCT GETCHR		;IN WHICH CASE WE GET THE "]" (WE HOPE!)
	POPJ P,
CMUPP6:	MOVE T,[XWD FILPPN,PPNBUF]
	CMUDEC T,		;CONVERT THE PPN TO DEC FORMAT
	POPJ P,			;WHOOPS, BAD PPN
>;CMU
	CAIE TTT,"]"
	POPJ P,
	XCT GETCHR
	POPJ P,
FTERM3:	CAIN TTT,12
	AOS (P)
	JRST CPOPJ1
>;NOITS
ITS,<
	CAIE TTT,";"
	JRST FTERM2
	MOVEM A,FILPPN
	PUSHJ P,FILWRD
	POPJ P,
FTERM2:	JUMPN A,NEXIST
	CAIE TTT,TEXIST
	JRST NEXIST
	PUSHJ P,CHRCHK
	POPJ P,			;EOF
	CAIA			;DELIMITER
	JRST CPOPJ1		;ERROR
	SKIPN A,LSTNAM
	JRST CPOPJ1
NEXIST:	MOVEM A,FILNAM
	CAIE TTT,40
	CAIN TTT,11
	JRST [	PUSHJ P,FILWRD
		POPJ P,
		JUMPE A,.+1
		MOVEM A,FILEXT
		JRST .+1]
FTERM3:	CAIN TTT,12
	JRST CPOPJ2
	CAIN TTT,"|"		;ALLOW CARD SPEC IN ITS FILE NAME
	 JRST [	MOVEI TT,40	;SNAME;NAME1 NAME2|<CARD SPEC>
		JRST CPOPJ2]
	CAIN TTT,ALTMOD
	JRST [	MOVEI TTT,40
		JRST CPOPJ1]
	PUSHJ P,FILWRD
	JRST FTERM3
>;ITS


;STANDARD FILENAME SETUP (SINGLE FILENAME)
SETFIL:	MOVE T,[OUTCHR TTT]
	MOVEM T,PUTCHR
	PUTSIX DEFEXT
	OUTSTR[ASCIZ/ FILENAME?/]
	PUSHJ P,CFILE
	POPJ P,
	AOS (P)
	PUSH P,A
	MOVEI A,FILNAM
	PUSHJ P,FILPNT
	POP P,A
	POPJ P,

CFILE:	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,FTERM
	JRST ERRET
	JRST ERRET
	SKIPE FILNAM
	AOS (P)
	POPJ P,
SUBTTL	WIRINI, WIRGET, LSTGET, NTITLE, BRS1W, TREAD, TREADU
WIRINI:	GETFS(L,LSTHEAD)
	BCLEAR(T,L,LSTHEAD)
	MOVEM L,WLLIST
	MOVEM L,DEFLST
	MOVEI TT,[ASCIZ/NIL/]
	PUSHJ P,ASCCOP
	STORE(T,L,WLID)		;NULL ID
	PUSHJ P,USED		;USE D WIRELIST
DEC,<	TRO PETIT!REFLAG	>
	POPJ P,

WIRFOR:	MOVE L,DEFLST
	FETCH(L,L,INXT)
	SKIPN L
	MOVE L,WLLIST
WIRBK2:	MOVEM L,DEFLST
	FETCH(A,L,WLID)
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/
/]
	POPJ P,

WIRBAK:	MOVE W,DEFLST
	CAMN W,WLLIST		;IF THIS IS FRONT,
	SETZ W,			;THEN SEARCH FOR END
	MOVE L,WLLIST
WIRBK1:	FETCH(T,L,INXT)
	CAMN T,W
	JRST WIRBK2
	FETCH(L,L,INXT)
	JUMPN L,WIRBK1
	JRST CPOPJ1		;LOSE!

WIRGET:	PUSHJ P,FNDID
	POPJ P,
	JRST WIRGT1
	MOVEM L,DEFLST
	JRST PUTFS

WIRGT1:	GETFS(L,LSTHEAD)
	BCLEAR(T,L,LSTHEAD)
	MOVE T,STRING
	STORE(T,L,WLID)
	MOVE W,DEFLST
	FETCH(T,W,INXT)
	STORE(T,L,INXT)
	STORE(L,W,INXT)
	MOVEM L,DEFLST
	OUTSTR[ASCIZ/NEW WIRELIST.
/]
	POPJ P,

NOID:	OUTSTR[ASCIZ/NO SUCH WIRELIST ID.
/]
	MOVE B,STRING
	JRST PUTFS

FNDID:	PUSHJ P,TREADU
	POPJ P,
	POPJ P,
	MOVEM B,STRING
	MOVE L,WLLIST
FNDID1:	FETCH(T,L,WLID)
	MOVE TT,STRING
	PUSHJ P,TXTMAT
	JRST FNDID2
	JRST FNDID2
	JRST CPOPJ2

FNDID2:	FETCH(L,L,INXT)
	JUMPN L,FNDID1
	JRST CPOPJ1


WIRID:	MOVE L,DEFLST
	OUTSTR[ASCIZ/CURRENT WIRELIST ID IS /]
	FETCH(A,L,WLID)
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/
WIRELIST ID? /]
	PUSHJ P,TREADU
	POPJ P,
	POPJ P,
	FETCH(T,L,WLID)
	STORE(B,L,WLID)
	MOVE B,T
	JRST PUTFS

WIRPNT:	OUTSTR[ASCIZ/
/]
	MOVE L,DEFLST
WIRPT1:	FETCH(A,L,WLID)
	PUSHJ P,STRTTY
	FETCH(A,L,WLNM)
	JUMPE A,WIRPT2
	OUTCHR[11]
	PUSHJ P,STRTTY
WIRPT2:	OUTSTR[ASCIZ/
/]
	FETCH(W,L,BLST)
	JUMPE W,WIRPT3
	FETCH(W,W,WBDY)
	JUMPE W,WIRPT3
	OUTSTR[ASCIZ/	BP	/]
	SETZ T,
WIRBP1:	ADDI T,1
	FETCH(W,W,NXTB)
	JUMPN W,WIRBP1
	PUSHJ P,WIRPT9
WIRPT3:	ADDI T,1
	FETCH(W,L,WIRL)
	JUMPE W,WIRPT4
	OUTSTR[ASCIZ/	D	/]
	SETZ T,
WIRD1:	ADDI T,1
	FETCH(W,W,NXTWL)
	JUMPN W,WIRD1
	PUSHJ P,WIRPT9
WIRPT4:	FETCH(W,L,PCWL)
	JUMPE W,WIRPT5
	OUTSTR[ASCIZ/	PC	/]
	SETZ T,
WIRPC1:	ADDI T,1
	FETCH(W,W,NXTWL)
	JUMPN W,WIRPC1
	PUSHJ P,WIRPT9
WIRPT5:	FETCH(L,L,INXT)
	SKIPN L
	MOVE L,WLLIST
	CAME L,DEFLST
	JRST WIRPT1
	POPJ P,

WIRPT9:	PUSH P,T
	PUSHJ P,TTYDEC
	OUTSTR[ASCIZ/ BOARD/]
	POP P,T
	CAIE T,1
	OUTCHR["S"]
	OUTSTR[ASCIZ/
/]
	POPJ P,


NTITLE:	MOVE L,DEFLST
	FETCH(A,L,WLNM)
	JUMPE A,NTITL1
	OUTSTR[ASCIZ/CURRENT TITLE IS /]
	PUSHJ P,STRTTY
	OUTSTR[ASCIZ/
/]
NTITL1:	OUTSTR[ASCIZ/WIRE LIST TITLE?/]
	PUSHJ P,TREAD
	POPJ P,
	SETZ B,				;STORE 0 FOR BLANK LINE
	FETCH(T,L,WLNM)			;GET WIRE LIST NAME POINTER
	STORE(B,L,WLNM)
	JUMPE T,CPOPJ
	MOVE B,T
	JRST PUTFS

LSTGET:	FETCH(W,L,WIRL)
	SKIPN USEDWL
	FETCH(W,L,PCWL)
LSTGT0:	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	JUMPE W,NXCARD
	FETCH(T,W,NXTWL)
	JUMPE T,[FETCH(T,W,FCRD)
		HRLZM T,SLICEL		;SAVE FOR FURTHER REFERENCES
		HRLZM T,ALLCRD
		JUMPE T,BLANKL		;DON'T PRINT BLANK
		OUTCHR[11]
		PUSHJ P,BRS1W
	BLANKL:	OUTSTR[ASCIZ/
/]
		JRST CPOPJ1]		;IF ONLY ONE, JUST RETURN IT!
	OUTSTR[ASCIZ/CARD LIST (/]
	OUTSTR @SLTCUE			;PRINT CUE MESSAGE HERE
	OUTSTR[ASCIZ/)?/]
	MOVE T,[PUSHJ P,TTYIN]
	MOVEM T,GETCHR
	PUSHJ P,GETSLT
	JRST LSTERR
	CAIE TTT,12
	JRST LSTERR
GETLOP:	FETCH(T,W,FCRD)			;GET CARD SPEC
	HRLZ T,T
	CAMN T,SLICEL
	JRST [	MOVEM T,ALLCRD
		JRST CPOPJ1]
	FETCH(W,W,NXTWL)
	JUMPN W,GETLOP
NXCARD:	OUTSTR[ASCIZ/NO SUCH CARD!
/]
	POPJ P,

BRS1W:	PUSH P,A
	FETCH(A,W,FCRD)
	PUSH P,TTT
	PUSH P,PUTCHR
	MOVE TTT,[OUTCHR TTT]
	MOVEM TTT,PUTCHR
	PUSHJ P,SLTOUT
	POP P,PUTCHR
	POP P,TTT
	POP P,A
	POPJ P,

LSTERR:	SETZ W,				;RETURN NULL POINTER
	CAIN TTT,ALTMOD
	POPJ P,
	OUTSTR[ASCIZ/INPUT ERROR!
/]
	CAIE TTT,12
	PUSHJ P,TREAD			;GOBBLE REST OF LINE
	POPJ P,
	POPJ P,
	JRST PUTFS

;TREAD - READ TEXT STRING
; (TREADU CONVERTS TO UPPER CASE)
;RETURNS, +1 - ALTMODE, +2 - NULL STRING, +3 - else
;B = STRING
TREADU:	SETOM LOW2UP
	CAIA
TREAD:	SETZM LOW2UP
	GETFS (B)
	HRRZ T,B
	ADD T,[POINT 7,1]
	SETZM -1(T)
	SETZM (T)
TREAD2:	PUSHJ P,TTYIN
	JFCL
	CAIN TTT,ALTMOD		;LET HIM OUT ON ALTMODE AND
	JRST [	OUTSTR[ASCIZ/
/]
		JRST PUTFS]		;RETURN STRING
	CAIN TTT,12		;ON LF
	JRST [	AOS (P)
		SKIPE 1(B)
		JRST CPOPJ1
		JRST PUTFS]
	TLNE T,760000		;END OF WORD?
	JRST TREAD1		;NO
	GETFS (TT)
	HRRM TT,-1(T)
	HRR T,TT
	SETZM (T)
	SETZM 1(T)
TREAD1:	SKIPN LOW2UP
	JRST TREAD3
	CAIL TTT,"A"+40
	CAILE TTT,"Z"+40
	CAIA
	SUBI TTT,40			;CONVERT LC TO UC
TREAD3:	IDPB TTT,T
	JRST TREAD2
