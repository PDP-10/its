	TITLE MONIT 200 for paging ai sys, 12/21/72  mb

SHARE==0	; 0 for 1 segment monit, 1 for 2 segment shareable monit

		; ACCUMULATOR DEFS

FF==0		; FLAG AC
A=1
B=2
C=3
D=4
COMPTR=5	; COMMAND BYTE POINTER
USRF=6		; FILE NAME FOR USR DEVICE
USRN1=USRF+1
USRN2=USRF+2
PRTF=11		; PRINT FILE NAMES
PRTN1=PRTF+1	; NAME 1
PRTN2=PRTF+2
COMSAV=15	; AC TO HOLD SAVED COMPTR FOR INFERIOR START (GOES TO A)
XCTINS=16	; AC TO XCT AN INSTR, FOR PURITY
P=17		; PUSH DOWN POINTER

		; FLAG DEFINITIONS

		; FLAGS FOR FF REG
USRUN==1	; INFERIOR EXISTS
		; FATAL==2
LOGFLG==2	; FLAG DURING LOGOUT, LOGOUT IF NO CORE
		; NEG==4
VALCOM==10	; LOOKING AT .VALUE FROM INFERIOR
LOGF==20	; DOING 'LOGIN COMMAND'
CRLF==40	; CR WAS LAST CHARACTER OUTPUT TO TTY
		; JOBF==100
		; RDF==200	; READING COMMANDS FROM FILE
ECHF==400	; ECHO TYPING
TTYGON==1000	; TTY GIVEN AWAY
SILENC==2000	; PRINTING BEING FLUSHED
		; NVALUE==4000	; 0=DO NOT INTERPRET VALRET STRING
RUNF==10000	; 1=START UP INFERIOR
		; MTTYF==20000	; 1=KEEP TTY FROM INFERIOR
WASGON==40000	; TTY WAS SNATCHED FROM INFERIOR (MONIT INTERRUPT)
SRCHF==100000	; 1=DO SEARCH WHEN LOADING, SET BY FOO FOR TS FOO
IMLACF==200000	; DEVICE TTY IS AN IMLAC

BRKFLG==400000	; DOING MULTIPLE .BREAK 12,

	; CHANNELS FOR I/O

TYIC==1	; TTY INPUT
TYOC==2	; TTY OUTPUT
SYSI==3	; INPUT FROM SYS: OR USR:
USRO==4	; OUTPUT TO INFERIOR
PRTC==5	; PRINT AND LISTF INPUT ANDERROR DEVICE

	LOC 20
	PDLLNG==20	; FROM 20 TO 37
PDL:	BLOCK	PDLLNG

	LOC 40
	0		; UUO DEPOSITED HERE BY HARDWRE
	JSR UUOH	; HANDLER FOR UUOS
	JSR TSINT	; HANDLER FOR TS INTERRUPTS
	0		; STRING PASS PNTR FOR INFERIOR

	DEFINE FATAL MESS
	JSP A,XFATAL
	INFORM \.,ERROR MESS
	TERMIN

	DEFINE INFORM N,MESS
	IF1,[PRINTC /N	MESSÓ/]	TERMIN

	PURITY==0
	%HI==400000

	DEFINE PURE
	IFN PURITY,INFORM \.,EXTRA PURE
	IFN SHARE,[IFE PURITY,[%LO==.
	LOC %HI
]]	PURITY==1
	TERMIN

	DEFINE IMPURE
	IFE PURITY,INFORM \.,EXTRA IMPURE
	IFN SHARE,[IFN PURITY,[%HI==.
	LOC %LO
]]	PURITY==0
	TERMIN
	; BEG. MAIN COMMAND SCAN LOOP

	PURE
BEG:	TLNE	FF,VALCOM	; VALRET IN PROGRESS?

	JRST	BEGS		; YES, GO AHEAD

	TLZ	FF,SILENC	; UNSILENCE TTY

	PASCI	^M		; CLEAR LINE

	JRST	BEGS		; GET COMMAND LINE AND PROCESS


BEGFND:	MOVE	B,(A)		; EXPAND ABREV TO ACTUAL

	MOVEM	B,SYSF+2

	MOVEM	B,USRF+2

	HRRZ	A,1(A)		; GET LOCAL COMMAND ADDRESS FROM BEGLOP

	JRST	(A)		; DISPATCH TO COMMAND


CANNOT:	PSIX	[SIXBIT / CAN'T/]


QBEG:	PASCR	[ASCIZ /?/]

	.CLOSE	SYSI,

	TLZ	FF,VALCOM		; RESET READING FROM VALRET STRING


	; FALL THROUGH TO BEGS


BEGS:	.SUSET [.SPICL,,[-1]]	; MAKE ME INTERUPT-PRONE
	MOVE P,[-PDLLNG,,PDL-1]	; FLUSH OUT PDL
BEGR:	TLNN FF,VALCOM		; VALRETED FROM PREV
	PUSHJ P,RCMD		; READ STRING IN
	PUSHJ P,SCMD		; SCAN COMMAND
	JUMPE B,BEG		; COMMAND BLANK, TRY AGAIN
	TLZA FF,LOGF+SRCHF+LOGFLG  	; RESET LOGIN, KILL SEARCH
BEGA:	SKIPA	b,sysf+2	; USE LAST COMMAND AGAIN
	movem	b,sysf+2
	movem	b,usrf+2
	MOVE A,[-NUMCOM,,MYCOM]

BEGLOP:	HLLZ	C,1(A)		; FETCH ABBREV
	CAME	B,(A)		; CHECK FOR LOCAL COMMANDS
	CAMN	B,C		; ABBREV?
	JRST	BEGFND		; FOUND
	AOS	A
	AOBJN	A,BEGLOP	; GET ANOTHER
	PUSHJ P,CKLOG		; MUST BE LOGGED IN HERE
	TLO FF,RUNF+SRCHF	; SET TO RUN PROG AND SEARCH USER
SYSLG2:	MOVEI A,SYSF		; SET FOR SYS FILES
	; UOPEN. LOAD INFERIOR AND GO

UOPEN:	PASCI	^M	; CLEAR LINE FOR LOSER
	PUSHJ P,ALD	; LOAD THE FILE
	TLNN FF,RUNF
	JRST BEG	; WAIT IF NOT TO RUN

USTART:	PUSHJ P,ATTY	; GIVE HIM THE CONSOLE
	.USET USRO,[.SUSTP,,[0]]	; START INF
	MOVSI D,200000
	.SLEEP D,	; RIP VAN WINKLE
;******	JRST .-2	; IN CASE 40 YRS PASS
	; SCMD - SCAN COMMAND LINE FOR SOMETHING TO DO

SCMDL:	IBP	COMPTR		; SKIP OVER LEADING JUNK
SCMD:	MOVE	A,COMPTR	; ENTRY: LOOK AHEAD
	ILDB	A,A		; GET NEXT CHAR
;******	CAIE	A,11		; TAB IN LEAD IS IGNORED
;******	CAIN	A,40		; DITTO FOR SPACES
;******	JRST	SCMDL		; PEEEL IT OFF
	CAIE	A,^J		; LINE FEEDS CHUCKED TOO
	CAIN	A,":		; STRIP LEADING COLONS
	JRST	SCMDL		; IGNORE LOSER
;******	CAIE	A,^V		; VIEW?
;******	JRST	.+3		; NO, SKIP
;******	TLZ	FF,SILENC	; YES, UNSILENCE
;******	JRST	SCMDL		; IGNORE
	CAIE	A,^W		; WIPE?
	JRST	.+3		; NO, SKIP
	TLO	FF,SILENC	; YES, SILENCE
	JRST	SCMDL		; IGNORE NOW

	MOVEM	COMPTR,43	;SAVE FOR OLD STYLE LEECH
	PUSHJ	P,GETSYL	;GET COMMAND ARG
	SKIPE	A		;SKIP IF COMMAND TERMINATES WITH SPACE
	TDZA	COMSAV,COMSAV	;SET TO 0
	MOVEM	COMPTR,COMSAV	;SAVE CURRENT COMMAND LOC
	POPJ	P,		;RETURN FROM SCMD
	; comment in valret, typed but ignored

GETCCC:	PUSHJ	P,GETCAT	; ECHO IF APPROPRIATE
GETCCS:	ildb	a,comptr	; get next command char
	CAIE	A,33		; ALTMODE IS END OF COMMENT TOO
	SKIPN	A		; SO IS END OF VALRET
	jrst	getccz		; end
	CAIE	A,15		; TERMINATING CR?
	JRST	GETCCC		; NO
	PUSHJ	P,GETCAT	; YES, ECHO

	; GET CHAR FROM COMMAND BUFFER (FILTERING)

GETCCA:	ILDB A,COMPTR	; FETCH COMM CHAR TO A
	cain	a,33	; VALRET COMMENT STARTED WITH ALTMODE ":$"
	jrst	GETCCS	; ignore text to end-of-line
	caie	a,^C	; end-of-file?
	skipn	a	; null terminate strings
GETCCZ:	TLZ	FF,VALCOM+ECHF+SILENC	; END OF VALRET
	caie	a,^L	; flush formfeed
	CAIN	A,^J	; FLUSH LF
	JRST	GETCCA

GETCAT:	TLNE FF,VALCOM+ECHF
	JRST IOTA	; ECHO IF VALRET OR ECHO FLAG
	POPJ P,		; ELSE JUST RETURN
	; RCMD.  READ COMMAND LINE INTO BUFFER

RCMD:	PASCI	";	; PROMPT WITH ;
	MOVE COMPTR,[440700,,COMMND]	; BEG INPUT
	SETZB C,COMMND	; COUNTER AND COMMAND BUFFER
	MOVE	B,[COMMND,,COMMND+1]
	BLT	B,COMMND+COMLNG-1	;ZERO OUT COMMAND BUFFER
	MOVE B,COMPTR

RCMD1:	.IOT TYIC,A	; GET CHAR
	CAIN A,"?
	JUMPE C,PHELP	; INIT ? MEANS HELP
	CAIN A,""	; DOUBLE QUOTE WORKS IMMEDIATE
	JUMPE C,BEGA	; NOW! DO SAME COMMAND AGAIN
	CAIE A,^G	; CTL G IGNORED
	CAIN A,^S	; CTL S IGNORED
	JRST KLINE	; YES
	CAIN A,177	; RUBOUT
	JRST RUB
	CAIN	A,^L
	PIMAGE	[ASCIZ /C/]		;CLEAR SCREEN ON FF

	CAIG	A,^L	; SKIP IF GREATER THAN FF, NOT FUNNY CTL CHAR
	JRST	RCMDX	; JUMP TO END LINE ON FUNNY CTL CHAR
	CAIN	A,^M	; SKIP IF NOT CR
	JRST	RCMDY	; JUMP TO END LINE WITH CR
	CAIL	C,5*COMLNG-2	; SKIP IF CHAR FITS IN BUFFER
	JRST	RCMD1		; JUMP TO IGNORE OVERFLOW CHARACTER
	IDPB	A,B		; STORE CHAR AWAY
	AOJA	C,RCMD1		; BACK FOR MORE

RCMDX:	MOVEI A,^M	; CLEAR LINE WITH RETURN
	PUSHJ P,IOTA

RCMDY:	IDPB	A,B	; STORE CHAR (CR)
	MOVEI A,0	; TERM WITH NULL FOR TYPE
	IDPB A,B
	TLO FF,CRLF	; MARK AS HAVING CLEARED LINE
	POPJ P,

RUB:	SOJL C,KLINE
	LDB A,B			; GET LAST INSERTED
	ADD B,[070000,,]	; BUMP CH POINTER
	TLNE B,400000		; AT WORD BOUND
	ADD B,[347777777777]
	tlne	ff,imlacf	; imlac?
	jrst	rubiml		; yes
	PUSHJ	P,IOTA		; ECHO OUT RUBBED CHAR
	JRST RCMD1

RUBIML:	CAIGE	A,33'		; WAS IT A CONTROL (^CHAR)
	PIMAGE	DELCH	;DELETE 2 IF CTL CHAR
	PIMAGE	DELCH	;DELETE CHAR
	jrst	rcmd1		; next?

KLINE:	TLZ	FF,SILENC	; UNSILENCE AFTER CLEARING
	tlnn	ff,imlacf	; imlac?
	jrst	qbeg		; start over if just tty
	PIMAGE	DELIN	; KILL A  LINE
	JRST	RCMD		; PROMPT WITH ";

;****** SCNAME - ROUTINE TO SCAN COMMAND LINE FROM CURRENT POSITION
;******	RETURNS A FILE NAME. A,B,C,D <= NAME1,NAME2,DEVICE,USER
;******	USING "[DEV:][USR;]NAME1 NAME2" OR "NAME1 NAME2 [DEV [USR]]"
;****** USING [USR;] WILL CAUSE DEVICE TO BE DSK.

SCNAME:	SETZM SCN1	;ZERO NAMES &C
	SETZM SCN2
	SKIPA C,[-4,,SCN1]
SCNDEV:	MOVE C,[-2,,SCDEV]
	SETZM SCDEV
	SETZM SCUSR
SCNGET:	PUSHJ P,GETSYL	;RET A,B <= BRKCHR,6BIT SYL
	JUMPE B,SCNX	;NO MORE SYLS HERE
	CAIN A,':	;CHECK WHICH BREAK
SCNPDV:	MOVEM B,SCDEV	;MOVE :SYL TO DEVICE
	CAIN A,';	;MOVE SYL; TO USR
	JRST SCNUSR	; SYL; BECOMES USR AND DEV DSK:
SCNCON:	JUMPG A,SCNGET	;NOT SPACE, GET MORE SYL(NOT CTL EITHER)
	MOVEM B,(C)
	JUMPL A,SCNX	;CTL TERMINATES
	AOBJN C,SCNGET	;UP PTR, GET MORE

SCNX:	SKIPE SCUSR	;USR; SPECIFIED?
	.SUSET [.SSNAM,,SCUSR]	;YES, SET IT
	SKIPE A,SCDEV	;DEV:?
	HLRZM A,PRTF	;Y, SET IT, ALSO OPEN MODE UNIT ASC@IN
	TLZ PRTF,-1	;SET TO ASCII UNIT INPUT ANYWAY
	SKIPE A,SCN1
	MOVEM A,PRTF+1	;SET N1 IF GEVEN
	SKIPE A,SCN2
	MOVEM A,PRTF+2	;SET N2 IF GIVYN
	POPJ P,

SCNUSR:	MOVEM B,SCUSR
	HRLI B,(SIXBIT /DSK/)	; MAKE DEVICE DSK
	SKIPN SCDEV	;DO NOT SET DEV TO DSK IF ALREADY SPECED
	MOVEM B,SCDEV
	JRST SCNCON		; CONTINUE SCAN

	IMPURE

SCN1:	0
SCN2:	0
SCDEV:	0
SCUSR:	0

	PURE
;GETSYL - ROUTINE TO GET SINGLE WORD OFF COMMAND LINE
;******	ONLY BRK CHAR ARE : ; SPACE AND CONTROLS EXCEPT ^Q WHICH
;******	QUOTES THE NEXT NON CTL CHAR (: ; SP)

GETSYL:	PUSH P,[0]	;INIT SYL ON STACK
	MOVE B,[440600,,0(P)]	;BYT PTR TO STACK
GETSLP:	PUSHJ P,GETCCA	;GET CHAR
	CAIN A,^Q	;IS IT "QUOTE"
	JRST GETQOT	;YES
	SUBI A,40	;MAKE SIXBIT
	JUMPL A,GETSX	;CTL=EXIT
	JUMPE A,GETSP	;INIT SPACES FLUSHED
	CAIE A,':
	CAIN A,';
	JRST GETSX	; ; OR : TERM
GETSPT:	CAIL A,100	;LC?
	SUBI A,40	;MAKE UC
	TLNE B,770000	;CHECK FIT
	IDPB A,B	;STORE CHAR
	JRST GETSLP

GETQOT:	PUSHJ P,GETCCA	;GET CHAR TO QUOTE
	SUBI A,40	;6BIT
	JUMPGE A,GETSPT	;CAN'T ^Q A CTL
	JRST GETSX

GETSP:	TLNE B,400000	;IF NONE YET PUT IN
	JRST GETSLP	;SPACE IGNORED
GETSX:	POP P,B		;ASSEMBLED SYL TO B
	POPJ P,		;BRK IS LEFT IN A
	; LOAD LOSER

ALD:	HRRM A,XCTINS	;STORE ADDRESS FOR LOAD OPEN
	SETZM USRN1	;WIPE ANY PREVIOUS USERNAME (FROM 'USER')
	HRLI USRF,5	;SET USER OPEN TO IMAGE UNIT OUTPUT
ALD6:	TLNN FF,SRCHF	;SKIP IF SEARCH FLAG ON
	JRST ALD7	;ELSE GO LOAD REGULAR
	MOVEI A,(SIXBIT /DSK/)
	HRRM A,SYSF	;SET FOR USER FIRST
	.SUSET	[.RSNAM,,A]	;SAVE SNAME
	.SUSET	[.SSNAM,,DSKNAM]	;SET FOR SEARCH OF "USER" DIR
	.OPEN SYSI,(XCTINS)	;MAY ACTUALLY BE SYSF
	JRST	.+3	;FAIL, SET SYSF TO SYS
	.SUSET	[.SSNAM,,A]	;RESTORE SNAME
	JRST ALD5	;FOUND USER, LOAD IT
	.SUSET	[.SSNAM,,A]	;RESTORE SNAME
	MOVEI A,(SIXBIT /SYS/)
	HRRM A,SYSF	;FOO, SET SYS TO SYS
ALD7:	.OPEN SYSI,(XCTINS)	;FILLED IN ADDRESS
	JSP A,ANALER
ALD5:	PUSHJ	P,USRCLOSE

	PUSHJ	P,USROPEN	;FILE FOUND, OPEN USER INFERIOR
	.RESET	USRO,		; MAKE IMAGE FRESH, IF WAS REOWNED
	.uset	usro,[.ssnam,,dsknam]	;carry dsk to inferior

PLOAD:	MOVE A,[USRO,,SYSI]
	.CALL LDBLK
	JRST PLOADR
	.IOT SYSI,B	;READ START ADDRESS
ALDJ:	HRRZM	B,STARTA
	.USET	USRO,[.SUPC,,STARTA]
	.CLOSE SYSI,
	POPJ P,		;RETURN

PLOADR:	PSIXI	(SIXBIT /PLD/)	; ERROR ON PLOAD
	.CLOSE SYSI,
	PUSHJ P,USRCLOSE	;FLUSH OUT JOB
	JRST QBEG		;WILL SCRATCH PDL


LDBLK:	SETZ
	SIXBIT /LOAD/
		[USRO]
	SETZ	[SYSI]
	; XFATAL AND ANALER  ERROR HANDLERS

XFATAL:	MOVE P,[-PDLLNG,,PDL-1]	; RESET PDL FOR WORKING ROOM
	POCTI (A)
	PASCR [ASCIZ / MONIT error/]
	.VALUE

DANERR:	.STATUS ERRF+2	;GET STATUS FOR DELETE
	JRST ANAL1
ANALER:	HLLZ B,-2(A)
	TLZ B,777037	;SAVE ONLY AC FIELD
	IOR B,DANERR	;GET .STATUS
	XCT B	;DO IT,

ANAL1:	TLZ FF,ECHF+VALCOM	;ERROR => NO TAPE IN OR VALRET
	MOVEI A,@-2(A)
	PSIX (A)	;POINTS TO OPEN BLOCK
	PASCI ":
	.SUSET [.RSNAM,,SCUSR]	;GET USERS SNAME
	PSIX SCUSR
	PASCI ";
	PSIX 1(A)
	PASCI " 	;SPACE
	PSIX 2(A)	;NAME2
	PASCI 40	;SP

	.OPEN PRTC,ERRF	;OPEN ERROR COMMENT
	FATAL CANT OPEN ERROR DEVICE (ANALYSE ERROR)

		; (FALL THROUGH)

XPRINT:	.IOT PRTC,A
	TLNN A,-1	;MAGIC EOF?
	CAIN A,^C
	JRST CLPRT	;YES, FINISHED
	CAIE A,^L	;IGNORE FF
	PUSHJ P,IOTA	;PRINT SYSTEM COMMENT
	TLNN FF,SILENC
	JRST XPRINT
CLPRT:	.CLOSE PRTC,
	JRST BEG	;KILLED BY ^S

USROPE:.OPEN USRO,USRF	;useropen (as it is affectionately called)
	JSP A,ANALER	;YOU LOST
	.USET USRO,[.RINTB,,A]
	TLNN A,1	;CHECK INTB IF THE RIGHT INFERIOR
	FATAL OPENED SECOND INFERIOR (USEROPEN)
	TLO FF,USRUN	;SET OPEN FLAG
	POPJ P,

USRCLOSE: PUSHJ P,DTTY	;MAKE SURE TTY IS UP
	TLNE FF,USRUN	;CHECK IF ACTUALLY OPEN
	.UCLOSE USRO,	;YES, WIPE IT OUT
	.CLOSE USRO,
	TLZ FF,USRUN	;NOW RESET FLAG - IF KILL HANGS, IT WILL NOT BE FLAGGED YET
	POPJ P,

ATTY:
;******	TLNE FF,USRUN	;CANT IF NO USR OPEN
	.ATTY USRO,	;TRY TO GIVE IT UP
	FATAL ATTY WITH NO INF OPEN (ATTY)
	TLO FF,TTYGON	;FLAG TTY GONE
	POPJ P,

DTTY:	TLZ FF,WASGON	;SAVE STATE OF TTYGON HERE
	TLZN FF,TTYGON	;SEE IF TTY GIVEN AWAY
	POPJ P,		;I GOT IT ALREADY
	.DTTY USRO,	;GOBBLE IT  BACK
	FATAL CAN'T GET TTY BACK FROM INF (DTTY)
	TLO FF,WASGON	;MARK THAT TTY WAS GOTTEN FROM INF
	POPJ P,
	; LISTF PRINT RUN DELETE PCORE

SYSTAT:	.OPEN	PRTC,[SIXBIT /   TTY.FILE.(DIR)/]
	JSP	A,ANALER
	JRST	XPRINT

LISTF:	PUSHJ P,SCNDEV	;OUTPUT FILE DIRECTORY
	SETOM	B
LISTFM:	MOVEM PRTF,LSTF
	.OPEN PRTC,LSTF
	JSP A,LISTFU
	JRST XPRINT

LISTFU:	AOJG	B,ANALER	;A SET ALREADY, CHECK ONCE FLAG(B)
	.SUSET	[.SSNAM,,SCDEV]	;DEV NOT FOUND, SET USER TO DEV, DEV TO DSK
	MOVEI	PRTF,(SIXBIT /DSK/)
	JRST	LISTFM

PRINT:	PUSHJ P,SCNAME	;GET A,B,C,D = N1,N2,DEV,USR
	CAIN PRTF,(SIXBIT/TTY/)	; TTY?
	MOVEI PRTF,(SIXBIT /DSK/)	; TTY GOES TO DSK
	.OPEN PRTC,PRTF
	JSP A,ANALER
	JRST XPRINT

RUN:	TLOA FF,RUNF	;SET TO RUN
LOAD:	TLZ FF,RUNF	;SET TO NOT RUN
	PUSHJ P,CKLOG
	PUSHJ P,SCNAME	;GET FILE NAME
	MOVEM PRTN1,USRF+2	;JOBNAME=FILENAME
	CAME PRTN1,SYSF+1	;SKIP IF N1=TS
	CAMN PRTN1,[SIXBIT /@/]	;SKIP IF NOT @
	MOVEM PRTN2,USRF+2	;USE JOBNAME=FILE NAME 2
	CAIE PRTF,(SIXBIT /USR/)	;BAD DEVICES FOR LOADING
	CAIN PRTF,(SIXBIT /TTY/)
	MOVEI PRTF,(SIXBIT /DSK/)	; IF USR OR TTY MAKE DSK
	HRLI PRTF,4	;MODE IS IMAGE UNIT INPUT
	MOVEI A,PRTF
	TLZ	FF,SRCHF		;OMIT SEARCH (REDUNDANT OPEN)
	JRST UOPEN

DELETE:	PUSHJ P,SCNAME	;GET FILE NAME
	MOVEI PRTF+3,0	;SET ARG FOR DELETE
	.FDELE PRTF	;SYS CALL DELETE
	JSP A,DANERR	;HMM ERROR
	JRST BEG	;OK

	; OWN. OWN A DISOWNED JOB

OWN:	PUSHJ P,CKLOG	;MUST BE LOGGED IN
	PUSHJ P,USRCLOSE
	PUSHJ P,GETSYL	;GET FIRST NAME
	JUMPE B,NLOG3	;TYPE NAME? IF NOT GIVEN
	MOVEM B,USRN2	;STORE
	PUSHJ P,GETSYL	;GET SECOND NAME IF ANY
	SKIPE USRN1,B	;SKIP IF NO SECOND, MOVE TO FIRST
	EXCH USRN1,USRN2	;SWAP SECOND TO FIRST, V-V
	HRLI USRF,16	;IMAGE BLOCK INPUT, FAIL IF NOT FOUND
	PUSHJ P,USROPEN
	HRLI USRF,6	;NOW SET TO IMAGE BLOCK INPUT ONLY
	PUSHJ P,USROPEN	;TRY FOR REAL
	.STATUS USRO,A
	ANDI A,77	;GET 'DEVICE' CODE
	CAIE A,61	;SKIP IF 'IMMEDIATE INFERIOR'
	PASCR [ASCIZ /inf?/]
	.USET USRO,[.RJNAM,,B]	;GET ACTUAL JNAME
	CAMN B,USRN2	;SKIP IF NAME ALTERED BY SYSTEM TO AVOID CONFLICT
	JRST BEG	;NAME OK, RETURN
	MOVEM B,USRN2	;STORE NEW NAME
	PSIX USRN2	;PRINT IT
	PASCR [ASCIZ / new name/]
	JRST QBEG

USER:	PUSHJ P,GETSYL	;GET AN ARG
	MOVEM B,DSKNAM	;STORE AS DISK DIR NAME
	.SUSET	[.SSNAM,,DSKNAM]	; SET IT NOW
	JRST BEG
LOGIN:	.OPEN	SYSI,SYSF	; LOOK FOR TS LOGIN
	SKIPA			; OOPS, NOT FOUND
	JRST	SYSLG1		; USE IT
STRLOG:	PUSHJ P,GETSYL
	SKIPE LOGNAM
	JRST NLOG1	;ALREADY LOGGED IN
	JUMPE B,NLOG3	;NO NAME GIVEN
	.CALL	LOGBLK
	JRST NLOG2		; FAIL, NAME ON ANOTHER TTY
	MOVEM B,LOGNAM
	MOVEM	B,DSKNAM	;STORE FOR COMMAND LOAD SEARCH RULE
	JRST BEG

NLOG1:	PSIX LOGNAM
	PASCR [ASCIZ / is here./]
	JRST BEG

NLOG2:	PASCR [ASCIZ /On another console./]
	JRST BEG

NLOG3:	PASC [ASCIZ /Name/]
	JRST QBEG

LOGBLK:	SETZ
	SIXBIT /LOGIN/
		B
	SETZ	[SIXBIT /MONIT/]

DISOWN:	PUSHJ P,CKRUN
	.DISOWN USRO,
	FATAL WONT DISOWN INFERIOR (DISOWN)
	.CLOSE USRO,	;FORGET, BUT DONT DESTROY
	TLZ FF,USRUN
	JRST BEG
	; CONTIN START STOP PROCEED KILL

CONTIN:	PUSHJ P,CKRUN	; RUNABLE?
	JRST STARTP	; GO START IT

START:	PUSHJ P,CKRUN
	.USET USRO,[.SUPC,,STARTA]	; SET HIS START ADDRESS
STARTP:	TLO FF,RUNF	; SET TO RUN
	JRST USTART

STOP:	PUSHJ P,CKRUN
	.USET USRO,[.SUSTP,,[-1]]
	JRST BEG

PROCEE:
PROCED:	PUSHJ P,CKRUN
	.USET USRO,[.SUSTP,,[0]]	; SEE HIM RUN !
	JRST BEG

KILL:	PUSHJ P,USRCLOSE	; FLUSH JOB IF ANY
	JRST BEG

	; CHECK TO SEE IF LOSER IS LOGGED IN.

CKLOG:	SKIPE	LOGNAM		; SKIP IF LOSER NOT LOGGED IN
	POPJ	P,			; RETURN, LOGGED IN, OK
	PASC	[ASCIZ/Login/]		; ASK FOR LOGIN
	JRST	QBEG

CKRUN:	TLNE FF,USRUN	; CHECK IF JOB CURRENTLY EXISTS
	POPJ P,
	PASC [ASCIZ /No program/]
	JRST QBEG
	; TRANS UNTRAN

TRANS:	SKIPA XCTINS,[.TRANAD TBLOCK]
UNTRAN:	MOVE XCTINS,[.TRANDL TBLOCK]
	PUSHJ P,CKLOG	; LOGGED IN?
	MOVSI C,-8	; COUNT OF ARGS
TARGS:	PUSHJ P,GETSYL
	JUMPE B,QBEG	;? IF NOT ENOUGH ARGS
	MOVEM B,TBLOCK(C)	; STORE RAW ARG WORDDS
	AOBJN C,TARGS

	MOVE B,[440600,,TBLOCK]	; FIRST ARG, "AIO"
	HLRZ C,TBLOCK+2
TMODE:	ILDB A,B	; GET CHARS
	CAIN A,'A	; IS IT "ATOMIC"
	TLO C,400000	; YES, SET BIT
	CAIN A,'I	; IS IT INPUT
	TLO C,1	; SET INPUT BIT
	CAIN A,'O	; IS IT OUTPUT
	TLO C,2	; SET OUTPUT BIT
	TLNE B,770000	; SKIP IF DONE WORD
	JRST TMODE	; JUMP BACK IF NOT DONE

	MOVEM C,TBLOCK+2
	HLRZS TBLOCK+5
	MOVE	A,LOGNAM
	MOVEM	A,TBLOCK	; SET UNAME = MINE
	XCT XCTINS
	JRST CANNOT
	JRST BEG
;	---------------------
;	I    command        I
;	I-------------------I
;	I  abbrev I  ptr    I
;	---------------------

	DEFINE COMTAB COMMND,ABREV 
	SIXBIT /COMMND/
	<<SIXBIT/ABREV/>&<777777000000>>+<<COMMND>&<000000777777>>
	TERMIN

MYCOM:	COMTAB ASSIGN,ASN
	COMTAB CONTIN,CON
	COMTAB DELETE,DEL
	COMTAB DESIGN,DES
	COMTAB DISOWN,DIS
;******	COMTAB ECHO
	COMTAB FLAP
	COMTAB FLUSH
	COMTAB HELP,HOW
;******	COMTAB JOB
	COMTAB KILL,K
	COMTAB LISTF,LF
	COMTAB LOAD,GET
	COMTAB LOGIN,LOG
	COMTAB LOGOUT,BYE
;******	COMTAB MONTTY
	COMTAB OWN,JOB
	COMTAB PRINT,TYP
	COMTAB PROCED,P
	COMTAB RUN,R
	COMTAB START,GO
	COMTAB STOP
	COMTAB SYSTAT,WHO
	COMTAB TIME,TI
	COMTAB TRANS
	COMTAB UINIT
	COMTAB UNTRAN
	COMTAB USER
;******	COMTAB VALUE
;******	COMTAB XFILE

NUMCOP==<.-MYCOM>/2		; COUNT FOR PRINTING, FOLLOWING ARE INTERNAL

	COMTAB ENDLOG
	COMTAB STRLOG

NUMCOM==<.-MYCOM>/2		;COUNT FOR TABLE USES

IFN NUMCOM*2+MYCOM-.,PRINTC / * * * COMMAND TABLE ODD
/
	; HELP COMMAND

PHELP:	PASCI ^M	; CLEAN LINE

HELP:	PASCR [ASCIZ /Commands/]
	MOVE A,[-NUMCOP,,MYCOM]	; do not give them endlog or strlog

HELPL:	PSIX (A)	; TABLE ENTRY
	HLLZ D,1(A)	; GET ABBREV
	JUMPE	D,HELPX	; JUMP IF NO ABBREV TO PRINT
	PASCI ^I	; TAB FOR ABBREV
	PSIX D

HELPX:	PASCI ^M	; CR TO END IT
	AOS A
	AOBJN A,HELPL
	JRST BEG

	; LOGOUT DESIGN ASSIGN FLUSH ENDLOG

LOGOUT:	SKIPN	LOGNAM		; DONE A LOGIN?
	JRST	ENDLOG		; NO, JUST LOGEM OUT NOW
	tlo	ff,logflg	; set logout flag in case no core
	.open	sysi,sysf	; ts logout?
	jrst	endlog		; just logout
SYSLG1:	TLZ	FF,SRCHF	; NO SEARCH RULE
	tlo	ff,runf		; runit
	jrst	syslg2		; runit

endlog:	.LOGOUT
FLUSH:	.VALUE

DESIGN:	SKIPA XCTINS,[.DESIGN A,]
ASSIGN:	MOVE XCTINS,[.ASSIGN A,]
	PUSHJ P,CKLOG	; MUST BE LOGGED IN FOR THESE
ACOMM:	PUSHJ P,GETSYL	; GET A SYL
	MOVEI A,0
	LSHC A,6
	JUMPN B,.-2	; GET ONLY TRAILING CHAR
	SUBI A,'0	; MAKE A DIGIT
	JUMPLE A,CANNOT	; CHECK FOR VALID
	CAIG A,8
	XCT XCTINS		; DO IT
	JRST CANNOT		; HMM!
	JRST BEG

UINIT:	SKIPA XCTINS,[.UINIT A,]
FLAP:	MOVE XCTINS,[.UDISMT A,]
	JRST ACOMM

UUOCT==0
UUOTAB:	JRST ILUUO
	IRPS X,,[PDEC PDECI POCT POCTI PSIX PSIXI PASC PASCI PASCR PIMAGE]
	UUOCT==UUOCT+1
	X=UUOCT_33
	JRST U!X
	TERMIN

UUOMAX==.-UUOTAB

UUOH:	0
	PUSH P,A
	PUSH P,B
	PUSH P,C
	LDB A,[270400,,40]	;GET UUO AC,
	HRRZ B,40	;AND ADR
	CAIG B,C	;SKIP IF ADR > AC C
	MOVEI B,-2(P)	;ALLOW ARG IN ACS (EXCEPT 0)
	LDB C,[330600,,40]	;OP CODE
	CAIL C,UUOMAX
	MOVEI C,0	;GRT=>ILLEGAL
	JRST @UUOTAB(C)	;GO TO PROPER ROUT

ILUUO:	MOVEI B,[ASCIZ /Illegal UUO/]
	MOVEI A,QBEG	; RECOVER FROM ILLUUO AT QBEG
	HRRM A,UUOH	; SETUP FOR UUORET
UPASC:	SKIPA C,[0]	; NO RETURN
UPASCR:	MOVEI C,15	; RETURN
	HRLI B,440700	; MAKE ASCII POINTER
	ILDB A,B	; GET CHAR
	JUMPE A,.+3	; FINISH?
	PUSHJ P,IOTA	; TYPE "A"
	JRST .-3	; AND GET ANOTHER
	SKIPE A,C	; GET SAVED CR?
	PUSHJ P,IOTA
	JRST UUORET

UPIMAGE: HRLI	B,440700
	ILDB	A,B
	JUMPE	A,UUORET
	.IOT	TYOC,A
	JRST	.-3

UPASCI:	MOVE A,B	; PRT ASCII IMMEDIATE
	PUSHJ P,IOTA
UUORET:	POP P,C
	POP P,B
	POP P,A		; RESTORE AC'S
	JRST 2,@UUOH

UPSIX:	SKIPA A,[440600,,0(B)]	;PRINT A SIXBIT WORD
UPSIXI:	MOVE A,[220600,,40]	;PRT SIXBIT IMMEDIATE
UPSLA:	ILDB C,A
	ADDI C,40	;MAKE TO ASCII(+40)
	CAIE C,40	;BUT SKIP IF SPACE
	PUSHJ P,IOTC
	TLNE A,770000	;SEE IF FINISH
	JRST UPSLA	;NOPE, MORE
	JRST UUORET

UPDEC:	SKIPA C,[10.]	;GET BASE FOR DECIMAL
UPOCT:	MOVEI C,8.	;OCTAL BASE
	MOVE B,(B)	;GET ACTUAL WORD TO PRT
	JRST .+3	;JOIN CODE
UPDECI:	SKIPA C,[10.]	;DECIMAL
UPOCTI:	MOVEI C,8.
	MOVEM C,BASE'
	SKIPN A
	HRREI A,-1	;A=DIGIT COUNT
	PUSHJ P,UPNUM	;PRINT NUMBR
	JRST UUORET

UPNUM:	IDIV B,BASE
	HRLM C,(P)	;SAVE DIGIT
	SOJE A,UPNUM1	;DONE IF 0
	SKIPG A		;+ => MORE
	SKIPE B		;- => B=0 => DONE
	PUSHJ P,UPNUM	;ELSE MORE
UPNUM1:	HLRZ C,(P)	;RETREIVE DIGITS
	ADDI C,"0	;MAKE TO ASCII
;	CAILE C,"9	;IS IT GOOD DIG
;	ADDI C,"A-"9-1	;MAKE HEX DIGIT

;	FALL THROUGH

IOTC:	EXCH A,C
	PUSHJ P,IOTA
	EXCH A,C
	POPJ P,	;RET
	; IOTA.  CHAR TO TTY FROM A

IOTA:	TLNE FF,SILENC	; IS SHUTUP FLAG ON?
	POPJ P,		; YES, EXIT
	caige	a,40	; control char?
	JRST	IOTAC	; PUT OUT UPARROW CHAR
IOTAA:	.IOT TYOC,A	; TYPE OUT A
IOTAB:	TLZ FF,CRLF	; MARK LINE UNCLEAR
IOUPAR:	POPJ P,"^

IOTLF:	TLZN FF,CRLF
	.IOT TYOC,A
	POPJ P,

IOTCR:	TLON FF,CRLF	; AND FLG
	.IOT TYOC,A	; OUT WITH CR
IOP:	POPJ P,"P

IOTAC:	CAIN	A,^M		; SKIP IF NOT CARR RET
	JRST	IOTCR		; PUT OUT CARR RET, FLAG
	CAIN A,^J		;SKIP IF NOT LF
	JRST IOTLF
	CAIE	A,^P		; CTRL P IS MAGIC OUTPUT ESCAPE, MUST WATCH
	JRST	IOTAA		; NOT ^P, JUST OUTPUT
	.IOT	TYOC,IOUPAR	; OUTPUT UPARROW ^
	.IOT	TYOC,IOP		; OUTPUT LETTER P
	JRST	IOTAB		; EXIT FLAGGING NOISE
	; TSINT - HANDLE THE INTERRUPTS

TSINT:	0		; MASK WD HERE
	0		; RETURN LOC
	EXCH	A,TSINT	; SWAP AC AND FLAGS
	CAIN	A,200000	; SKIP IF NOT PDL OVERFLOW
	MOVE	P,[-PDLLNG,,PDL-1] ; REINITIIALIZE PDL ON OVERFLOW
	PUSHJ P,DTTY	; GET TTY IF GIVEN AWAY
	JUMPGE	A,MONINZ	; JUMP FOR OWN INTERRUPT IF 4.9 BIT OFF
	.USET USRO,[.RPIRQ,,A]	; GET USER INT BITS
	.USET USRO,[.SAPIRQ,,A]	; RESET THOSE READ
	TRZE A,2	; ^Z TYPED at INFERIOR
	JRST CTLZEE
	TRZE A,4
	PSIXI (SIXBIT /B42/)	; BAD LOC 42
	TRZE A,20
	PSIXI (SIXBIT /DPY/)	; DISPLAY INTERRUPT
	TRZE A,40	; ILL INS
	PSIXI (SIXBIT /ILL/)
	TRZE A,200
	.DISMISS [VALRET]	; READ HIS STRING
	TRZE A,400
	PSIXI (SIXBIT /IOC/)	; IOCHANNEL ERROR
	TRZE A,2000	; .BREAK
	JRST	BRKINT
	TRZE A,20000
	PSIXI (SIXBIT /MPV/)
	SKIPE A
	POCT A	; PRT REST OF BITS
PRTPC:	PASC [ASCIZ / in /]
	.USET USRO,[.RJNAME,,USRN2]	; GET INF JOB NAME
	PSIX USRN2			; PRINT IT
	PASC [ASCIZ / pc=/]
	.USET USRO,[.RUPC,,A]	; FETCH PC
	POCTI (A)
IFLUSH:	JRST	FLSHI	; FLUSH INPUT AND DISMISS TO QBEG
BRKINT:	.USET	USRO,[.RJNAME,,USRF+2]	;GET REAL JNAME
	HRLI	USRF,5			;IMAGE UNIT OUTPUT FOR USER DEV
	.OPEN	USRO,USRF		;OPEN FOR OUTPUT
	FATAL	Cant open INF output on .BREAK 12
	HRLI	USRF,4			;IMAGE UNIT INPUT
	.OPEN	SYSI,USRF		;OPEN FOR INPUT
	FATAL	Cant open INF input on .BREAK 12

BRKIN1:	.USET	USRO,[.RSV40,,A]	;GET .BREAK INSTR
	HLRZ	B,A
	CAIN	B,(.BREAK 16,)	;SKIP IF NOT 16
	JRST	BRK16		;JUMP TO HANDLE BREAK 16
	CAIE	B,(.BREAK 12,)		;SKIP IF .BREAK 12
	JRST	BRKERR			;ERROR, JUST SAY .BREAK
	HRRZS	A

;	CHECK MEMORY ADR HERE

	.ACCESS	USRO,A		;FOR POSSIBLE REWRITE
	.ACCESS	SYSI,A			;ADDRESS THE POINTER
	.IOT	SYSI,A			;FETCH IT
	TLNN	A,200000	;SKIP IF 4.8 ON, MAY BE AOBJN POINTER
	JRST	BRKONE		;ONLY ONE COMMAND, DO IT
	JUMPGE	A,BRKERR	;SIGN BIT NOT ON, ERROR NOT AOBJN PTR
	AOBJP	A,.+2		;BUMP POINTER, SKIP IF COUNTS OUT
	TRO	FF,BRKFLG	;SET, IN AOBJN LOOP FOR .BREAK
	.IOT	USRO,A		;STORE BUMPED PTR BACK
	MOVEI	A,-1(A)		;GET PREVIOUS ADR
	.ACCESS	SYSI,A		;SET ADDRESS
	.IOT	SYSI,A		;FETCH COMMAND WORD

BRKONE:	HRRZ	B,A		;GET ADDRESS OF CMMMAND
	.ACCESS	SYSI,B		;INPUT ADDRESS
	.ACCESS	USRO,B		;OUTPUT ADDRESS SET TOO
	LDB	B,[222100,,A]	;GET CODE
	CAIL	B,NBRKS		;SKIP IF IN RANGE
	MOVEI	B,0		;SET TO ERROR IF NOT
	XCT	BRKTBL(B)	;DO THING

BRKTBL:	JRST	BRKERR		;IF RETURN, IS ERROR
	JRST	BRKSA		;1 START ADR
	JUMPGE	A,BRKFN		;2 FILE NAME (READ ONLY)
	JUMPGE	A,BRKSMT	;3 SYMTAB PTR (READ ONLY)
	JRST	BRKSYM		;4 SYMBOL, READ OR WRITE
	JRST	BRKCOM		;5 COMMAND READ OR WRITE
NBRKS==.-BRKTBL

BRKSA:	JUMPL	A,BRKSAW	;WRITE IF 4.9 BIT
	.IOT	USRO,STARTA	;READ MY START ADR
	JRST	BRKXX		;OK, EXIT (OR LOOP)
BRKSAW:	.IOT	SYSI,STARTA	;WRITE MY START ADR
	HRRZS	STARTA		; FLUSH FLAG BITS
	JRST	BRKXX		;EXIT

BRKCOM:	JUMPL	A,BRKCMW		;TO FETCH COMMAND BACK FROM INF
	JUMPE	COMSAV,BRKNUL	;NONE TO SEND
	MOVE	B,[440700,,COMMND]
	ILDB	A,COMSAV
	IDPB	A,B
	JUMPN	A,.-2
	MOVE	COMSAV,[440700,,COMMND]	;REFLECT FACT THAT COMMAND MOVED

	.IOT	SYSI,A		;DUMMY, TO ADVANCE ACCESS FOR READ
	MOVSI	B,-COMLNG
	.IOT	USRO,COMMND(B)
	.IOT	SYSI,A
	JUMPN	A,.+3		;END IF NEXT WORD IN INF NOT 0
	SKIPE	COMMND(B)	;END IF WORD JUST SENT WAS 0
	AOBJN	B,.-4		;LOOP FOR NEXT WORD

BRKXX:	TRZE	FF,BRKFLG	;SKIP IF LOOP FLAG NOT SET
	JRST	BRKIN1		;ELSE LOOP
	.CLOSE	SYSI,
	.USET	USRO,[.SUSTP,,[0]]	;ALLOW HIM TO RUN AGAIN
	JRST	MONO

BRKERR:	PSIXI	(SIXBIT /BRK/)
	JRST	PRTPC

BRKCMW:	SETZM	COMSAV		;CLEAR OUT COMMAND SAVER
BRKSYM:	JUMPL	A,BRKXX		;SYMBOL WRITE IS NOP
BRKSMT:				;SYMTAB, WRITE IS ERROR, READ 0
BRKFN:	JUMPL	A,BRKERR	;FILE NAME DITTO
BRKNUL:	.IOT	USRO,[0]	;SET ONE WORD OF ZERO
	JRST	BRKXX	;NOW RETURN

BRK16:	TRNE	A,-1#140000
	JRST	BRKERR		;ERROR IF ANY OTHER BITS
	TRNN	A,100000	;BIT SAYS DONT RESET TYI
	.RESET	TYIC,
	TRNN	A,40000		;BIT SAYS DO :KILL
	.DISMISS [BEG]		;ELSE JUST RETURN TO SUP
	.DISMISS [KILL]
	; HANDLE INTS TO MONIT (NOT INF)

MONINT:	POP P,A		; RESTORE FLAGS AFTER TYILK
MONINZ:	TRZE A,1
	JRST TYILK
	TRZE A,100	; FIVE MINUTES
	PASCR [ASCIZ /ÓSystem going down./]
	TRNN A,-1	; ANY LEFT?
	JRST MONO
	POCTI 6,(A)	; PRINT BITS
	PSIXI	(SIXBIT /INT/)
	MOVE	A,TSINT+1
	JRST	XFATAL
;*****		FATAL. UFO INT IN MONIT

MONO:	TLNE FF,WASGON	; SKIP ATTY IF TTY WAS NOT GOBBLED FROM INF
	PUSHJ P,ATTY	; GIVE TTY BACK TO INF
	MOVE	A,TSINT	; RESTORE AC STORED HERE
	.DISMISS TSINT+1

TYILK:	PUSH P,A	; STORE FLAGS
TYILK1:	MOVEI	A,PRTC		; CHECK CHARS FOR INPUT TTY
	.ITYIC	A,
	SKIPA	A,[TYIC]
	JRST	.-3
	.ITYIC	A,
	JRST MONINT
	CAIN A,^Z
	JRST flshio	; cause question and command fetch
	CAIE A,^G
	CAIN A,^S	; ^S AND ^G THE SAME
	TLOA	FF,SILENC	; SET SILENCE FLAG
	JRST TYILK1	;GO BACK, SEE IF ANY MORE
	.RESET TYOC,	; HERE ^S TO SHUT UP OUTPUT ONLY
	JRST	TYILK1

FLSHIO:	.reset	tyoc,	; empty output buffer
FLSHI:	.reset	tyic,	; likewise for input
	.dismiss [qbeg]	; away from in level to reinit

	; VALRET - HANDLE VALUE RETURN FROM INFEERIOR
VALRET:	.USET	USRO,[.RSV40,,A]	; GET ACTUAL .VALUE UUO FROM USERS 40
	HRRZS A
	JUMPE A,VALRE1
	HRLI USRF,6	;SET USRF FOR IMAGE BLOCK INPUT
	.USET USRO,[.RJNAME,,USRF+2]	; GET LOSERS JNAME
	.OPEN SYSI,USRF
	FATAL VALRET OPEN OF INF FAILED (VALRET)
	TLZ A,-1	;ZERO LEFT HALF FOR ACCESSING
	.ACCES SYSI,A	;SET ADDRESS TO READ VALRET STRING
	.USET SYSI,[.RMEMT,,B]	; GET TOP OF INF CORE
	SUB A,B			; GET -DIST FROM VAL TO TOP
	CAMG A,[-COMLNG]	; KEEP LESSER OF THAT AND BUFLEN
	MOVEI A,-COMLNG		; FORCE TO BUFFER SIZE
	HRL B,A		; PUT IN LEFT HALF
	HRRI B,COMMND		; POINT TO COMMAND BUFFER
	.IOT SYSI,B	;MOVE STRING OVER
	TLO FF,VALCOM	;SET TO SCAN
	MOVE COMPTR,[440700,,COMMND]	;RESET COMMAND SCANNER
	.CLOSE SYSI,
;******	.LISTEN TYIC,	;WAIT FOR TTY QUIET
;******	TLNN FF,RDF	;DO NOT RESET IF READING ILE
	.RESET TYIC,
	TLZ FF,CRLF	; MAKE NO ASSUMPTIONS
	JRST BEG

VALRE1:	PSIX [SIXBIT /.VALUE/]
	JRST PRTPC

CTLZEE:	TLZ FF,SILENC
	PASC [ASCIZ / back to MONIT/]
	JRST FLSHI		; FLUSH INPUT AND TYPE ?
CKDIE:	.DIETIM A,	;GET TIME TIL SYS DOWN
	JUMPL A,.+3	;NO DYING NOW
	pushj	p,ptime	;convert and print time period
	PASCR [ASCIZ / 'til sys down./]
	POPJ P,

time:	pasc	[asciz /Today is /]
	.rdate	d,
	psix	d
	pasc	[asciz /ÓIt is now /]
	.rtime	d,
	psix	d
	pasci	^M
	.rdtime	a,
	pushj	p,ptime
	pascr	[asciz / since sys up'd./]
	pushj	p,ckdie
	jrst	beg
ptime:	IDIVI A,30.*60.*60.	;HOURS IN A
	IDIVI A+1,30.*60.	;MINS IN A+1
	IDIVI A+2,30.	;SEC IN A+2
	PDECI (A)	;PRT HRS
	PASCI ":
	PDECI 2,(A+1)	;PRT MINS
	PASCI ":
	PDECI 2,(A+2)	;PRT SECS
	popj	p,

	CONSTANTS

	INFORM \.,TOP OF PURE

	IMPURE
DELCH:	ASCIZ / /
DELIN:	ASCIZ /H]/
STARTA:	0
LOGNAM:	0
DSKNAM:	0		;CURRENT USER FOR LOGIN, "USER"
SYSF:	SIXBIT /  $SYSTS          /
LSTF:	SIXBIT /   DSK.FILE.(DIR) /
ERRF:	SIXBIT /   ERR     #      /

	VARIABLES

COMMND:		;HERE STARTS COMMND,IO BUFFER
COMLNG==30	;WDS FOR COMMAND

STARTU:	MOVE	P,[-PDLLNG,,PDL-1]
	.OPEN TYOC,[SIXBIT /  1TTYMONITRTTYOUT/]	; DISPLAY, UNIT ASCII OUT
	JRST ENDLOG	; NO TTY, LOGOUT IMMEDIATE
	.OPEN TYIC,[SIXBIT /   TTYMONITRTTYIN/]
	FATAL CANT OPEN TTY INPUT (STARTUP)
	MOVEI FF,0	;RESET ALL FLAGS
	.STATUS TYIC,A
	TRNE A,2	;IS IT GE-BITER ? (DISPLAY)
	TLO	FF,IMLACF	; SET CONSOLE AS IMLAC, FOR SEXY RUBOUT (SEE "RUB")
	PASCI ^M	;CLEAR LINE
	PSIX [SIXBIT /MONIT./]
	PSIX [.FNAM2]
	PASCI ^M	;CR
	PUSHJ P,CKDIE	;CHECK IF SYS GOING DOWN
	MOVEI A,221561	;MASK WORDS FOR INTERRUPTS
;****** CHRTYP DPMPV ILLINS SYSDIE IOCHNER MPVINF MPV PDLOV + BAD42 _Z .VALUE .BREAK _N
	MOVSI A+1,1	;BIT FOR INFERIOR
	.SETM2 A,	;SET MASKWDs
	MOVEI USRF,(SIXBIT /USR/)
	MOVEI PRTF,(SIXBIT /DSK/)	; SET UP INIT DEVICE
	MOVSI	PRTN1,(SIXBIT /@/)
	MOVSI	PRTN2,(SIXBIT /</)
	.SUSET [.RUNAM,,LOGNAM]	; GET USER NAME
	AOSE LOGNAM			; -1 NOT IN, SET TO ZERO
	SOSA LOGNAM		; HERE IF LOGGED IN, RESTORE NAME, SKIP TO BEG
	.OPEN PRTC,[SIXBIT /   SYSSYSTEMMAIL/]
	JRST BEG	; NO SYS MAIL
	JRST XPRINT	; YES, THERE IS, PRINT IT

	CONSTANTS
	VARIABLES

TBLOCK=COMMND+COMLNG	; LEAVE COMMAND BUFF SEPARATE
IFL .-TBLOCK-8,LOC TBLOCK+8


	INFORM \.,TOP OF IMPURE

	END STARTU
