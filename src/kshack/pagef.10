;;;-*-Fundamental-*-

	.NOBIN
.TOC	"PAGE FAIL REFIL LOGIC"

.IFNOT/ITS

;WHEN THE CPU CAN NOT COMPLETE A MEMORY REFERENCE BECAUSE THE PAGE
; TABLE DOES NOT CONTAIN VALID INFORMATION FOR THE VIRTUAL PAGE INVOLVED
; THE HARDWARE CALLS THIS ROUTINE TO RELOAD THE HARDWARE PAGE TABLE.
;
;THIS CODE WILL EITHER DO THE RELOAD OR GENERATE A PAGE FAIL FOR THE
; SOFTWARE. THE INFORMATION LOADED CONSISTS OF THE PHYSICAL PAGE NUMBER,
; THE CACHE ENABLE BIT AND THE WRITE ENABLE BIT.

;THIS LOGIC USES MANY VARIABLES. THEY ARE DESCRIBED BRIEFLY HERE:

;THING			WHERE KEPT			USE
;OLD VMA		WORKSPACE WORD 210		SAVES VMA
;OLD AR 		WORKSPACE WORD 211		SAVES AR
;OLD ARX		WORKSPACE WORD 212		SAVES ARX
;OLD BR 		WORKSPACE WORD 213		SAVES BR
;OLD BRX		WORKSPACE WORD 214		SAVES BRX
;KL PAGING BIT		EBR BIT 1 (IN 2901)		INDICATES KL STYLE (TOPS-20) PAGING
;							INSTEAD OF KI STYLE (TOPS-10 AND DIAGNOSTIC)
;							MODE PAGING
;W BIT			FLG BIT 4			PAGE CAN BE WRITTEN
;C BIT			FLG BIT 6			DATA IN THIS PAGE MAY BE PUT
;							INTO CACHE
;PI CYCLE		FLG BIT 5			STORING OLD PC DURING PI
;MAP FLAG		FLG BIT 18			MAP INSTRUCTION IN PROGRESS
;CLEANUP CODE		FLG BITS 32-35			WHAT TO DO SO INSTRUCTION MAY BE
;							RESTARTED
;SPT BASE		WORKSPACE WORD 215		ADDRESS OF SHARED-POINTER-TABLE
;CST BASE		WORKSPACE WORD 216		ADDRESS OF CORE-STATUS-TABLE
;CST MASK		WORKSPACE WORD 217		BITS TO KEEP ON CST UPDATE
;CST DATA (PUR) 	WORKSPACE WORD 220		BITS TO SET ON CST UPDATE
;PAGE TABLE ADDRESS	AR				WHERE THIS PAGE TABLE IS LOCATED
;PHYSICAL PAGE # (PPN)	AR				RESULT OF THIS PROCESS
;CST ENTRY		AR				CORE STATUS TABLE ENTRY
;SPT ENTRY		AR				WORD FROM SPT
;PAGE TABLE ENTRY	AR				WORD FROM PT
;PAGE NUMBER		BR				INDEX INTO CURENT PAGE TABLE
;PAGE FAIL WORD 	BRX				WHAT HAPPENED (ALSO MAP RESULT)

;
;
;
;		   KL10 PAGING - WORD FORMATS
;
;Section Pointer
;
;The section pointer is found in the user or exec section table.
;(Part of UPT or EPT.)
;
;Section pointer provides (via the SPT) the physical address  of
;the PAGE TABLE for the given section.
;
;	 Code:	 0	 No-access (trap)
;		 1	 Immediate
;		 2	 Share
;		 3	 Indirect
;		 4-7	 Unused, reserved
;
;	 0 1 2 3 4 5 6		 18			 35
;	 +----+-+-+-+-+---------+-------------------------+	
;	 !CODE!P!W! !C!/////////!  PAGE TABLE IDENTIFIER  !
;	 !010 ! ! ! ! !/////////!	 (SPT INDEX)	  !
;	 +----+-+-+-+-+---------+-------------------------+
;
;		NORMAL SECTION POINTER (Code = 2)
;
;	 0   2 3 4 5 6	   9	       18		      35
;	 +----+-+-+-+-+---+-----------+------------------------+
;	 !CODE!P!W! !C!///!SECTION    !SECTION TABLE IDENTIFIER!
;	 !011 ! ! ! ! !///!TABLE INDEX!       (SPT INDEX)      !
;	 +----+-+-+-+-+---+-----------+------------------------+
;
;	       INDIRECT SECTION POINTER (Code = 3)

;PAGE POINTERS
;
;FOUND IN PAGE TABLES
;
;	 0 1 2 3 4 5 6	    12				 35
;	 +----+-+-+-+-+----+------------------------------+
;	 !CODE!P!W! !C!////!   PHYSICAL ADDRESS OF PAGE   !
;	 !001 ! ! ! ! !////!				  !
;	 +----+-+-+-+-+----+------------------------------+
;
;		 IMMEDIATE POINTER (code field = 1)
;
;	 B12-35  give PHYSICAL ADDRESS OF PAGE
;	     if  B12-17 >< 0, page not in core-trap
;	     if  B12-17 =  0, B23-35 give CORE PAGE
;			      NUMBER of page, B18-22 MBZ
;
;
;
;
;
;	 0    2 3     6 	  18			 35
;	 +-----+-------+---------+------------------------+
;	 !CODE !SAME AS!/////////!	  SPT INDEX	  !
;	 !010  ! IMMED.!/////////!			  !
;	 +-----+-------+---------+------------------------+
;
;		 SHARED POINTER (code field = 2)
;
;	 B18-35  Give SPT INDEX (SPTX).  SPTX + SPT BASE
;		 ADDRESS = physical core address of word
;		 holding physical address of page.

;	 0 1 2 3      6     9	 17 18			 35
;	 +----+--------+---+-------+----------------------+
;	 !CODE!SAME AS !///! PAGE  ! PAGE TABLE IDENTIFIER!	
;	 !011 ! IMMED. !///!NUMBER !	 (SPT INDEX)	  !
;	 +----+--------+---+-------+----------------------+
;
;		 INDIRECT POINTER (code field = 3)
;
;	 This pointer type causes another pointer to be  fetched
;	 and  interpreted.   The  new pointer is found in word N
;	 (B9-17) of the page addressed by C(SPT + SPTX).
;
;
;
;	 SPT ENTRY
;
;	 Found in the SPT, i.e., when fetching C(SPT +SPTX)
;
;			       12			 35
;	 +--------------------+---------------------------+
;	 !////////////////////!  PHYSICAL ADDRESS OF PAGE !
;	 !////////////////////! 	 OR PAGE TABLE	  !
;	 +--------------------+---------------------------+
;
;		 B12-35  Give PHYSICAL ADDRESS of page.
;
;	 The base address (physical core  address)  of	the  SPT
;	 resides in one AC of the reserved AC block.

;PHYSICAL STORAGE ADDRESS
;
;Found in B12-35 of IMMEDIATE POINTERS and SPT ENTRIES.
;
;			 12	 17 18	 23		 35
;			 +---------+----+-----------------+
;			 !	   !MBZ ! CORE PAGE NUMBER!
;			 !	   !	!   IF B12-17 = 0 !
;			 +---------+----+-----------------+
;
;	 If B12-17 = 0, then B23-35 are CORE PAGE NUMBER  (i.e.,
;	 B14-26  of  physical  core  address) of page and B18-22
;	 MBZ.  If B12-17 >< 0, then  address  is  not  core  and
;	 pager traps.
;
;
;
;CORE STATUS TABLE ENTRY
;
;Found when fetching C(CBR + CORE PAGENO)
;
;	 0	5				  32  34 35
;	 +-------+-------------------------------+------+-+
;	 !  CODE !				 !	!M!
;	 +-------+-------------------------------+------+-+
;
;	 B0-5	 are code field:
;
;		 0 - unavailable, trap
;
;		 1-77 - available
;
;
;
;	 B32-34 reserved for future hardware specification.
;
;	 B35 is "modified" bit, set on any write ref to page.

;QUANTITIES IN HARDWARE REGISTERS
;
;SPT	 SPT Base Register
;
;			 14				 35
;			 +--------------------------------+
;			 !   PHYSICAL CORE WORD ADDRESS   !
;			 +--------------------------------+
;
;CBR	 CST Base Register
;
;			 14				 35
;			 +--------------------------------+
;			 !   PHYSICAL CORE WORD ADDRESS   !
;			 +--------------------------------+
;
;CSTMSK  CST Update Mask
;
;	 0					     32  35
;	 +------------------------------------------+---+-+
;	 !			 MASK		    !111!1!
;	 +------------------------------------------+---+-+
;
;		 ANDed with CST word during update
;
;(B32-35 must be all 1's to preserve existing CST information)
;
;CSTDATA CST Update Data
;
;	 0				      32 34 35	
;	 +------------------------------------------+---+-+
;	 !			 DATA		    !000!0!
;	 +------------------------------------------+---+-+
;
;		 IORed with CST word during update
;
;(B32-35 must be all 0's to preserve existing CST information)
;
;All  unspecified  bits  and  fields  are  reserved  for  future
;specification by DEC.
;

	.BIN

	.DCODE
257:	IOT,	AC,	J/MAP
	.UCODE

1553:
MAP:	[AR]_[AR].OR.#,		;ASSUME PHYSICAL REF
	 #/160000,		;FAKE ANSWER (Set Accessible, Writable,
	 HOLD RIGHT		;and "Software".)
	[BRX]_VMA		;PUT VMA AND FLAGS IN BRX
	[BRX]_[BRX].AND.#,	;JUST KEEP USER BIT
	 #/400000, HOLD RIGHT	; ..
	WORK[SV.VMA]_[BRX]	;SAVE IN WORKSPACE
	[BR]_WORK[APR]		;GET APR FLAGS
	TR [BR], #/030000	;PAGING ENABLED?
=0	STATE_[MAP], J/PFMAP	;YES--DO REAL MAP
	AC_[AR], NEXT INST	;NO--RETURN VIRTUAL ADDRESS
;HARDWARE COMES HERE ON PAGE TABLE NOT VALID (OR INTERRUPT) WHEN
; STARTING A MEMORY REFERENCE. MICOWORD ADDRESS OF INSTRUCTION DOING
; MEM WAIT IS SAVED ON THE STACK.
3777:
PAGE-FAIL:
	WORK[SV.AR]_[AR]
ITRAP:	WORK[SV.BRX]_[BRX]
	[BRX]_VMA
	WORK[SV.VMA]_[BRX]
	WORK[SV.ARX]_[ARX],
	 SKIP IRPT		;SEE IF INTERRUPT (SAVE DISPATCH)
=0000
PFD:	DBM/PF DISP, DBUS/DBM,	;BRING CODE TO 2901'S
	 AD/D, DEST/PASS, 4T,	;PUT ON DP 18-21
	 DISP/DP LEFT, J/PFD	;DISPATCH ON IT
=0001				;(1) INTERRUPT
	WORK[SV.BR]_[BR], J/PFPI1
=0011				;(3) BAD DATA FROM MEMORY
	[BRX]_IO DATA,		;GET THE BAD DATA
	 AD PARITY OK/0,	; DO NOT LOOK AT PARITY
	 J/BADDATA		;SAVE IN AC BLK 7
=0101				;(5) NXM ERROR
	[BRX]_[370000] XWD 0, J/HARD
=0111				;(7) NXM & BAD DATA
	[BRX]_[370000] XWD 0, J/HARD
=1000				;(10) WRITE VIOLATION
	WORK[SV.BR]_[BR], J/PFMAP
=1010				;(12) PAGE NOT VALID
	WORK[SV.BR]_[BR], J/PFMAP
=1011				;(13) EXEC/USER MISMATCH
	WORK[SV.BR]_[BR], J/PFMAP
=

BADDATA:
	WORK[BADW0]_[BRX]	;SAVE BAD WORD
	WORK[BADW1]_[BRX]	;AGAIN
	[BRX]_[360000] XWD 0, J/HARD

;WE HAVE SAVED AR, ARX, BR AND BRX. WE MERGE IN HERE FROM MAP
; INSTRUCTION, SAVE THE VMA AND START THE PAGE FAIL WORD.
PFMAP:	ABORT MEM CYCLE		;CLEAR PAGE FAIL
	[FLG]_[FLG].OR.#,	;PRESET W AND C TO 1
	 FLG.W/1, FLG.C/1,	;BITS INVOLVED
	 HOLD RIGHT		;LEAVE RH ALONE
	TL [BRX], WRITE TEST/1	;IS THIS A WRITE TEST?
=0	[BRX]_[BRX].OR.#,
	 #/10000,
	 HOLD RIGHT		;YES--TURN INTO WRITE REF
	[BRX]_[BRX].AND.#,	;START PAGE FAIL WORD
	 #/411000,		;SAVE 3 INTERESTING BITS
	 HOLD RIGHT		;SAVE VIRTUAL ADDRESS
				;USER ADDR (400000)
				;WRITE REF (010000)
				;PAGED REF (001000)
	[BRX]_[BRX].XOR.#,	;FIX BIT 8
	 #/1000, HOLD RIGHT
	[BR]_[BRX],		;COPY VIRTUAL ADDRESS
	 SC_7			;PREPARE TO SHIFT 9 PLACES
=0
PF25:	[BR]_[BR]*.5,		;RIGHT ADJUST PAGE #
	 STEP SC,		;COUNT SHIFT STEPS
	 J/PF25			;LOOP FOR 9
	[BR]_[BR].AND.# CLR LH,	;MASK TO 9 BITS
	 #/777			; ..
	TL [EBR],		;KI MODE REFILL?
	 #/40			;FLAG BIT
=0	READ [BRX],		;USER REF? (KL MODE)
	 SKIP DP0,		; ..
	 J/PF30			;CONTINUE AT PF30
	[ARX]_[BR]*.5,		;KI10 MODE REFILL
	 J/KIFILL		;GO HANDLE EASY CASE

;HERE IN TOPS-20 MODE
;PICK UP CORRECT SECTION POINTER
=0
PF30:	[ARX]_WORK[PTA.E],	;EXEC MODE
	 SKIP AD.EQ.0, 4T,	;SEE IF VALID
	 J/PF35			;CONTINUE BELOW
	[ARX]_WORK[PTA.U],	;USER MODE
	 SKIP AD.EQ.0, 4T	;SEE IF VALID
=0	VMA_[ARX]+[BR],		;POINTER VALID
	 VMA PHYSICAL READ,	;START MEMORY
	 J/PF77			;CONTINUE BELOW
	[AR]_[UBR]+#, 3T,	;USER MODE
	 #/540,			;OFFSET TO UPT
	 J/PF40			;GO GET POINTER

=0
PF35:	VMA_[ARX]+[BR],		;POINTER VALID
	 VMA PHYSICAL READ,	;START MEMORY
	 J/PF77			;CONTINUE BELOW
	[AR]_[EBR]+#, 3T,	;EXEC MODE
	 #/540			;OFFSET TO EPT
PF40:	VMA_[AR],		;LOAD THE VMA
	 START READ,		;START THE MEMORY CRANKING
	 VMA PHYSICAL		;ABSOLUTE ADDRESS
	MEM READ,		;WAIT FOR MEMORY
	 [AR]_MEM		;POINT POINTER IN AR
;LOOK AT SECTION POINTER AND DISPATCH ON TYPE
=000
PF45:	SC_7,			;FETCH SECTION 0 POINTER
	 CALL [SETPTR]		;FIGURE OUT POINTER TYPE
SECIMM:	TL [AR],		;IMMEDIATE POINTER
	 #/77,			;TEST FOR 12-17 = 0
	 J/PF50			;CONTINUE AT PF50
	[AR]_[AR]+WORK[SBR],	;SHARED SECTION
	 J/SECSHR		;GO FETCH POINTER FROM SPT
	[AR]_[AR]+WORK[SBR],	;INDIRECT SECTION POINTER
	 CALL [RDPT]		;GO FETCH SPT ENTRY
=111	TL [AR],		;12 TO 17 = 0?
	 #/77			; ..
=
=0	PAGE FAIL TRAP		;NO
	[AR]_[AR]*2,		;FIRST SHIFT
	 STEP SC		;SC WAS LOADED AT PF45
=0*0
PF60:	[AR]_[AR]*2,		;CONVERT TO ADDRESS OF
	 STEP SC,		; SECTION TABLE
	 J/PF60
	CALL [RDPT]		;READ SECTION TABLE
=1*1	J/PF45			;TRY AGAIN
=

;HERE FOR SHARED SECTION. AR GETS THE ADDRESS OF PAGE TABLE
=0**
SECSHR:	CALL [RDPT]		;READ WORD FROM SPT
	TL [AR], #/77		;TEST FOR BITS 12-17 = 0

;HERE WITH ADDRESS OF PAGE TABLE IN AR AND SKIP ON
; BITS 12 THRU 17 EQUAL TO ZERO
=0
PF50:	PAGE FAIL TRAP		;BITS 12-17 .NE. 0
	[ARX]_[AR].AND.# CLR LH, ;PAGE NUMBER OF PAGE TABLE
	 #/3777			;11 BIT PHYSICAL PAGE #
=0*	[AR]_[ARX],		;COPY ADDRESS
	 CALL [UPCST]		;UPDATE CST0
PF70:	[AR]_[AR].OR.WORK[PUR]	;PUT IN NEW AGE AND
				; USE BITS
=0**	START NO TEST WRITE,	;START MEMORY WRITE
	 CALL [IBPX]		;GO STORE IN MEMORY
	SC_7			;THIS CAN BE BUMMED
=0
PF75:	[ARX]_[ARX]*2,		;CONVERT PAGE NUMBER TO
	 STEP SC,		; PAGE ADDRESS
	 J/PF75			;LOOP OVER 9 STEPS

;WE NOW HAVE THE ADDRESS OF THE PAGE TABLE ENTRY. GO
; READ IT AND START ANALYSIS

;IF WE ARE HERE FOR THE FIRST TIME FOR THE USER OR EXEC SAVE THE
; ADDRESS OF THE PAGE TABLE IN PTA.E OR PTA.U SO THAT WE DO NOT
; HAVE TO DO THE SECTION LOOKUP EVERY TIME.
	READ [BRX], SKIP DP0	;USER OR EXEC REF?
=000	[AR]_WORK[PTA.E],	;EXEC MODE
	 SKIP AD.EQ.0, 4T,	;SEE IF SET YET
	 CALL [SHDREM]		;SHOULD WE REMEMBER PTR
	[AR]_WORK[PTA.U],	;USER MODE
	 SKIP AD.EQ.0, 4T,	;SEE IF SET YET
	 CALL [SHDREM]		;SHOULD WE REMEMBER PTR
	WORK[PTA.E]_[ARX],	;SAVE FOR EXEC
	 J/PF76			;CONTINUE BELOW
	WORK[PTA.U]_[ARX],	;SAVE FOR USER
	 J/PF76			;CONTINUE BELOW
=111
PF76:	VMA_[ARX]+[BR], 	;READ PAGE POINTER
	 START READ,
	 VMA PHYSICAL
=
=00
PF77:	MEM READ,		;START ANALYSIS OF POINTER
	 [AR]_MEM,
	 CALL [SETPTR]
PTRIMM:	TL [AR],		;IMMEDIATE POINTER
	 #/77,			;CHECK FOR BITS 0-5
	 J/PF80			;GO TO PF80
	[AR]_[AR]+WORK[SBR],	;SHARED POINTER
	 J/PTRSHR		;GO TO READ SPT

;INDIRECT POINTER. CHANGE PAGE # AND LOOK FOR PAGE TABLE
PTRIND:	[BR]_[AR] SWAP, 	;PUT IN RIGHT HALF
	 SKIP/-1 MS		;DID CLOCK GO OFF
=0	WORK[SV.AR1]_[AR],	;YES--UPDATE CLOCK
	 J/PFTICK		; ..
	[BR]_[BR].AND.# CLR LH,	;UPDATE PAGE # AND RESTART
	 #/777,			;MASK FOR PAGE #
	 SKIP IRPT		;SEE IF THIS IS A LOOP
=0	[AR]_[AR].AND.#,	;CHANGE INDIRECT POINTER
	 #/277000,		; INTO SHARE POINTER
	 HOLD RIGHT,		; ..
	 J/PF45			;GO BACK AND TRY AGAIN
	PAGE FAIL TRAP		;POINTER LOOP

=0**
PTRSHR:	CALL [RDPT]		;GO LOOK AT POINTER
	TL [AR],		;BITS 12-17 .EQ. 0?
	 #/77

;HERE WITH FINAL POINTER. SKIP IF 12-17 NOT EQUAL TO ZERO
=00
PF80:	PAGE FAIL TRAP		;NO--TAKE A TRAP
	[ARX]_[AR].AND.# CLR LH,;SAVE PHYSICAL PAGE #
	 #/3777,		;MASK TO 13 BITS
	 CALL [UPCST]		;UPDATE CST0
;HERE WE HAVE CST ENTRY IN AR, PAGE FAIL WORD IN BRX. GO LOOK
; AT WRITABLE AND WRITTEN BITS
=11
PF90:	[BRX]_[BRX].OR.#,	;TRANSLATION IS VALID
	 #/100000, HOLD RIGHT	; ..
	TL [FLG], FLG.W/1	;IS THIS PAGE WRITABLE?
=0	[BRX]_[BRX].OR.#,	;YES--INDICATE THAT IN PFW
	 #/020000,
	 J/PF100		;NOT WRITE VIOLATION
	TL [BRX],		;IS THIS A WRITE REF?
	 WRITE TEST/1, WRITE CYCLE/1
=0	PAGE FAIL TRAP		;WRITE VIOLATION
PF107:	[AR]_[AR].OR.WORK[PUR],	;PUT IN NEW AGE
	 J/PF110		;GO TO STORE CST ENTRY

=0*
PFTICK:	[AR]_WORK[TIME1],	;UPDATE TIMER
	 SPEC/CLRCLK, CALL [TOCK]
	[AR]_WORK[SV.AR1],	;RESTORE AR
	 J/PTRIND		;GO TRY AGAIN

;HERE IF PAGE IS WRITABLE
PF100:	TL [BRX], WRITE CYCLE/1	;IS THIS A WRITE REF?
=0	[AR]_[AR].OR.#, 	;YES--SET WRITTEN BIT
	 #/1,
	 HOLD LEFT,
	 J/PF105
	TR [AR],		;NOT WRITE, ALREADY WRITTEN?
	 #/1
=0
PF105:	[BRX]_[BRX].OR.#,	;WRITTEN SET BIT
	 #/040000,		;MARK PAGE AS
	 HOLD RIGHT,		;WRITABLE
	 J/PF107		;STORE CST WORD
	[FLG]_[FLG].AND.NOT.#,	;NOT WRITTEN, CAUSE TRAP ON
	 FLG.W/1,		; WRITE ATTEMPT
	 HOLD RIGHT,		;ONLY CLEAR LH
	 J/PF107
=0**
PF110:	START NO TEST WRITE,
	 CALL [IBPX]		;STORE CST ENTRY

;HERE WHEN WE HAVE FIGURED OUT PHYSICAL ADDRESS (IN ARX) AND FLAGS
; (IN BRX) RELOAD PAGE TABLE.
PFDONE:	TR [FLG],		;MAP INSTRUCTION?
	 #/400000
=0	[AR]_[ARX],		;GET PHYSCIAL PAGE #
	 SC_7,			;PREPARE TO CONVERT TO
	 J/PF130		; WORD ADDRESS
	[AR]_WORK[SV.VMA],;RESTORE VMA
	 J/PF120
=0
PF130:	[AR]_[AR]*2,		;CONVERT TO WORD #
	 STEP SC,
	 J/PF130
	[AR]_[AR].AND.#,	;JUST ADDRESS BITS
	 #/3,
	 HOLD RIGHT
	END MAP 		;CLEAR MAP FLAGS
	[BRX]_[BRX].OR.#,	;TURN ON THE TRANSLATION
	 #/100000,		; VALID BIT
	 HOLD RIGHT		; IN LEFT HALF ONLY
	TL [FLG], FLG.C/1	;CACHE BIT SET?
=0	[BRX]_[BRX].OR.#,	;YES--SET IN MAP WORD
	 #/002000, HOLD RIGHT	; ..
	[BRX]_[BRX].AND.#,	;PRESERVE WORD #
	 #/777, HOLD LEFT	; IN PAGE FAIL WORD
	[AR]_[AR].OR.[BRX],	;COMPLETE MAP INSTRUCTION
	 EXIT

PF120:	[BR]_[AR]		;COPY PAGE FAIL WORD
	[BR]_[AR].AND.NOT.#,	;CLEAR BITS WHICH START A CYCLE
	 READ CYCLE/1,		; ..
	 WRITE CYCLE/1,		; ..
	 WRITE TEST/1,		; ..
	 HOLD RIGHT		;JUST DO LEFT HALF
	VMA_[BR], 3T,		;RESTORE VMA
	 DP FUNC/1		;SET USER ACCORDING TO WHAT IT WAS
	[ARX]_[ARX].AND.# CLR LH, ;JUST KEEP PAGE #
	 #/3777			; ..
	[BRX]_[ARX].OR.#, #/400000 ;SET VALID BITS
	TL [FLG], FLG.W/1	;WANT WRITE SET?
=0	[BRX]_[BRX].OR.#, #/040000 ;SET WRITE BIT
	TL [FLG], FLG.C/1,	;WANT CACHE SET?
	 LOAD PAGE TABLE	;LOAD PAGE TABLE ON NEXT
				; MICRO INSTRUCTION
=0	[BRX]_[BRX].OR.#,	;SET CACHE BIT
	 #/020000, J/PF125	;CACHE BIT
	READ [BRX]		;LOAD PAGE TABLE
PF125:	[ARX]_WORK[SV.ARX]
	[BR]_WORK[SV.BR]
	[BRX]_WORK[SV.BRX]
	VMA_[AR],		;MAKE MEM REQUEST
	 DP FUNC/1, 3T,		;FROM DATA PATH
	 WAIT/1			;WAIT FOR PREVIOUS CYCLE TO
				; COMPLETE. (NEED THIS TO 
				; START ANOTHER CYCLE)
	[AR]_WORK[SV.AR],
	 RETURN [0]
;SUBROUTINE TO START CST UPDATE
;CALL WITH:
;	AR/ PHYSICAL PAGE NUMBER
;RETURN 2 WITH ENTRY IN AR, PAGE FAIL IF AGE TOO SMALL
=0**
UPCST:	[AR]_[AR]+WORK[CBR],	;ADDRESS OF CST0 ENTRY
	 CALL [RDPT]		;READ OLD VALUE
	TL [AR],		;0 - 5 = 0?
	 #/770000		; ..
=0	[AR]_[AR].AND.WORK[CSTM],	;CLEAR AGE FIELD
	 RETURN [2]		;AGE IS NOT ZERO
	PAGE FAIL TRAP		;AGE TOO SMALL

;SUBROUTINE TO LOOK AT PAGE POINTER
;CALL WITH POINTER IN AR
;RETURNS 1 IF TYPE 1
;RETURNS 2 IF TYPE 2
;RETURNS 3 IF TYPE 3
;GOES TO PFT IF TYPE 0 OR 4 THRU 7
SETPTR:	[ARX]_[AR].OR.#,	;AND C AND W BITS
	 #/753777		; OF ALL POINTERS
	[FLG]_[FLG].AND.[ARX],	; ..
	 HOLD RIGHT		;KEEP IN LH OF FLG
	READ [AR],		;TYPE 4,5,6 OR 7?
	 SKIP DP0		; ..
=0	TL [AR],		;HERE WE TEST FOR TYPE
	 #/300000,		; ZERO POINTER
	 J/STPTR1		;CHECK AT STPTR1
	PAGE FAIL TRAP		;BAD TYPE
=0
STPTR1:	TL [AR],		;NOT ZERO
	 #/100000,		;SEPERATE TYPE 2
	 J/STPTR2		; ..
	PAGE FAIL TRAP		;TYPE 0

=0
STPTR2:	TL [AR],		;SEPERATE TYPE 1
	 #/200000,		; AND 3
	 J/STPTR3		; ..
	RETURN [2]		;TYPE 2

=0
STPTR3:	RETURN [3]		;TYPE 3
	RETURN [1]		;TYPE 1

;SUBROUTINE TO FETCH A PAGE POINTER OR CST ENTRY
;CALL WITH ADDRESS IN AR
;RETURN 4 WITH WORD IN AR
;
RDPT:	VMA_[AR],		;LOAD THE VMA
	 START READ,		;START MEM CYCLE
	 VMA PHYSICAL,		;ABSOLUTE ADDRESS
	 SKIP IRPT		;CHECK FOR INTERRUPTS
=0	MEM READ,		;NO INTERRUPTS
	 [AR]_MEM,		;PUT THE DATA INTO AR
	 RETURN [4]		;AND RETURN
	PAGE FAIL TRAP		;INTERRUPT


;SUBROUTINE TO SEE IF WE SHOULD REMEMBER AN EXEC SECTION PTR
;CALL WITH SKIP ON ADR.EQ.0
;RETURNS 2 IF WE SHOULD STORE AND 7 IF WE SHOULD NOT
;
=0
SHDREM:	RETURN [7]		;INDIRECT PTR
	[AR]_.NOT.[FLG]		;FLIP BITS
	TL [AR], FLG.W/1, FLG.C/1 ;BOTH BITS SET
=0	RETURN [7]		;NO--DON'T STORE
	RETURN [2]		;STORE

;HERE IN KI10 MODE
;BR CONTAINS PAGE # AND ARX CONTAINS PAGE #/2

KIFILL:	READ [BRX],		;USER REF?
	 SKIP DP0		; ..
=0	[BR]-#, 		;EXEC--LESS THAN 340?
	 #/340,			; ..
	 SKIP DP18, 4T,		; ..
	 J/KIF10		;FOLLOW EXEC PATH
KIUPT:	[ARX]_[ARX]+[UBR],	;POINTER TO PAGE MAP ENTRY
	 LOAD VMA,		;PUT ADDRESS IN VMA
	 VMA PHYSICAL,		;ABSOLUTE ADDRESS
	 START READ,		;FETCH UPT WORD
	 J/KIF30		;JOIN COMMON CODE
=0
KIF10:	[BR]-#, 		;EXEC ADDRESS .GE. 340
	 #/400,			; SEE IF .GT. 400
	 SKIP DP18, 4T,		; ..
	 J/KIEPT		;LOOK AT KIF20
	[ARX]_[ARX]+#, 3T,	;EXEC ADDRESS .LT. 340
	 #/600,			;IN EBR+600
	 J/KIEPT		;JOIN COMMON CODE

=0
KIEPT:	[ARX]_[ARX]+[EBR],	;ADD OFFSET TO
	 LOAD VMA,		; EPT
	 START READ,		;START FETCH
	 VMA PHYSICAL,		;ABSOLUTE ADDRESS
	 J/KIF30		;GO GET POINTER
	[ARX]_[ARX]+#,		;PER PROCESS PAGE
	 #/220, 3T,		; IS IN UPT + 400
	 J/KIUPT		;JOIN COMMON CODE
KIF30:	MEM READ,		;WAIT FOR DATA
	 [ARX]_MEM		;PLACE IT IN ARX
	TR [BR],		;SEE IF EVEN OR ODD
	 #/1			; ..

=0
KIF40:	READ [ARX],		;ODD
	 SKIP DP18,		;SEE IF VALID
	 J/KIF50		;JOIN COMMON CODE
	[ARX]_[ARX] SWAP,	;EVEN--FLIP AROUND
	 J/KIF40		; AND CONTINUE

=0
KIF50:	PAGE FAIL TRAP
;AT THIS POINT WE HAVE THE PAGE MAP ENTRY IN RH OF AR
	[FLG]_[FLG].AND.NOT.#,	;CLEAR W AND C
	 FLG.W/1, FLG.C/1	; FLAGS
	TR [ARX], #/020000	;CACHE ENABLED?
=0	[FLG]_[FLG].OR.#,	;SET CACHE BITS
	 FLG.C/1, HOLD RIGHT	; ..
	TR [ARX], #/040000	;DO NOT CACHE
				;SEE IF CACHE BIT SET
=0	[BRX]_[BRX].OR.#,	;COPY BITS TO BRX
	 #/020000,
	 HOLD RIGHT
	TR [ARX],		; ..
	 #/100000
=0	[FLG]_[FLG].OR.#,	;SAVE W
	 FLG.W/1,		; ..
	 HOLD RIGHT,		; ..
	 J/KIF90		;ALL DONE
	TL [BRX],		;W=0, WRITE REF?
	 WRITE CYCLE/1
=0
KIF80:	[BRX]_[BRX].OR.#,	;WRITE FAILURE
	 #/100000, HOLD RIGHT,	;INDICATE THAT ACCESS WAS ON
	 J/KIF50		;GO PAGE FAIL
	J/PFDONE		;ALL DONE

KIF90:	[BRX]_[BRX].OR.#,	;PAGE IS WRITABLE
	 #/40000,		;TURN ON IN BRX
	 J/PFDONE		;ALL SET

;HERE ON HARD PAGE FAILURES
HARD:	WORK[SV.BR]_[BR]	;SAVE BR (CLEANUP MAY NEED IT)
=0	[BR]_VMA,		;BUILD PAGE FAIL WORD
	 CALL [ABORT]		;CLEAR ERROR
	[BR]_[BR].AND.#,	;SAVE THE FLAGS
	 #/401237,		; ..
	 HOLD RIGHT		; ..
	[BRX]_[BRX].OR.[BR],	;COMPLETE PAGE FAIL WORD
	 J/KIF50		;GO TRAP

PFPI1:	SKIP IRPT		;TIMER TRAP?
=00
	[AR]_WORK[TIME1],	;YES--GET LOW WORD
	 SPEC/CLRCLK,		;CLEAR CLOCK FLAG
	 CALL [TOCK]		;DO THE UPDATE
	J/PFT1			;EXTERNAL INTERRUPT
	ABORT MEM CYCLE		;CLEAR 1MS FLAGS
=
PFPI2:	[AR]_WORK[SV.VMA],	;RESTORE VMA
	 J/PF125


;HERE ON PAGE FAIL TRAP
=0
PFT:	HALT [IOPF]		;IO PAGE FAILURE
PFT1:	[AR]_WORK[SV.VMA],
	 SKIP/TRAP CYCLE	;SEE IF TRAP CYCLE
=0	TL [AR], FETCH/1,	;IS THIS AN INSTRUCTION FETCH
	 J/PFT1A		;GO LOOK BELOW
	[AR]_WORK[TRAPPC]	;RESTORE PC
	READ [AR], LOAD FLAGS, J/CLDISP
=0
PFT1A:	J/CLEANED		;YES--NO PC TO BACK UP
FIXPC:	[PC]_[PC]-1, HOLD LEFT	;DATA FAILURE--BACKUP PC
=0
CLDISP:	CLEANUP DISP		;GO CLEANUP AFTER PAGE FAIL
=0000
CLEANUP:
CLEANED:			;(0) NORMAL CASE
	END STATE, SKIP IRPT,	;NO MORE CLEANUP NEEDED
	 J/PFT2			;HANDLE PAGE FAIL OR INTERRUPT
	[AR]_WORK[SV.ARX],	;(1) BLT
	 J/BLT-CLEANUP
	[PC]_[PC]+1,		;(2) MAP
	 J/MAPDON
	STATE_[EDIT-SRC],	;(3) SRC IN STRING MOVE
	 J/STRPF
	STATE_[EDIT-DST],	;(4) DST IN STRING MOVE
	 J/STRPF
	STATE_[SRC],		;(5) SRC+DST IN STRING MOVE
	 J/BACKD
	STATE_[EDIT-DST],	;(6) FILL IN MOVSRJ
	 J/STRPF4
	STATE_[EDIT-SRC],	;(7) DEC TO BIN
	 J/PFDBIN
	STATE_[EDIT-SRC],	;(10) SRC+DST IN COMP
	 J/CMSDST
	END STATE, J/BACKS	;(11) EDIT SRC FAIL
	END STATE, J/BACKD	;(12) EDIT DST FAIL
	STATE_[EDIT-SRC],	;(13) SRC+DST IN EDIT
	 J/BACKD
=

=0
PFT2:	[AR]_[UBR]+#,		;PREPARE TO STORE PFW
	 #/500, 3T,
	 J/PFT10
PFT3:	TAKE INTERRUPT		;PROCESS INTERRUPT
PFT10:	VMA_[AR],		;WHERE TO STORE PFW
	 VMA PHYSICAL WRITE
=0	MEM WRITE,		;STORE PFW
	 MEM_[BRX],
	 CALL [NEXTAR]		;ADVANCE POINTER TO
				;PREPARE TO STORE PC
	TL [EBR], #/400000	;KL PAGING?
=0	[BR]_FLAGS,J/EAPF	;YES--DO EXTENDED THING
	[BR]_PC WITH FLAGS	;GET OLD PC
	MEM WRITE,		;STORE OLD PC
	 MEM_[BR],
	 J/EAPF1

MAPDON:	END STATE,		;CLEAR MAP BIT
	 SKIP IRPT		;ANY INTERRUPT?
=0	[AR]_[BRX],		;RETURN PAGE FAIL WORD
	 EXIT
	[PC]_[PC]-1, J/PFT3	;INTERRUPTED OUT OF MAP
				; RETRY INSTRUCTION


=0
EAPF:	MEM WRITE, MEM_[BR],	;STORE FLAGS
	 CALL [NEXTAR]		;STORE PC WORD
	MEM WRITE, MEM_[PC]	; ..
EAPF1:	[AR]_[AR]+1,
	 VMA PHYSICAL READ,
	 J/GOEXEC
	
NEXTAR:	NEXT [AR] PHYSICAL WRITE, RETURN [1]

.ENDIF/ITS
