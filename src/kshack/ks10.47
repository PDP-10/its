;;;-*-Fundamental-*-

	.NOBIN
.TITLE	"KS10 MICROCODE FOR ITS"
	;FROM KS10 MICROCODE V117, 12 JANUARY 1979 -- DON LEWINE

.TOC	"MIT REVISION HISTORY"

;;; 1/16/87	Merge in DEC versions 120-130 inclusive (see comments below)
;;;		Change floating-point code to keep its hands off flag bits
;;;		other than FLG.SN, so it doesn't interfere with one-proceed.
;;; 8/1/86      262.  Try T/4T at XCTGO, see if one-proc in ACs works.
;;;		      Afraid not, foo.  Took T/4T back out.
;;; +++ microcode 261 released +++
;;; 6/8/86	Still 261.  Fix XCTR BLT bug, addresses same, spaces different.
;;; 5/86        261.  One-proceed more or less works, fix page age bug.
;;; 5/28/85	Version 261.  Started on one-proceed feature.
;;; 5/4/85	Version 260.  Added ITS I/O instructions.
;;; 11/24/84	Flushed PCLSRing hack.  More trouble than it was worth.
;;;		Also moved main program level page fail words back to the
;;;		EPT.
;;; 11/21/84	Fixed last bug in PCLSRing hack:  The PC stored in the MUUO
;;;		old PC location needed to be incremented.
;;; 11/20/84	OK, I gave in and made the PCLSRing hack obtain the new PC
;;;		from a new location as well.
;;; 11/19/84	Fixed PCLSRing hack to also store context word.  Fixed
;;;		RDUBR and WRUBR to deal in addresses rather than in page
;;;		numbers. 
;;; 11/16/84	Added special PCLSRing hack to page fail trapping.  When
;;;		page fault occurs in user mode, a duplicate copy of the old
;;;		PC is stashed in the MUUO old PC location.
;;; 11/2/84	Fixed quantum counter to count in same units as other
;;;		timers.  Time spent at PI level is only approximately
;;;		accounted for.
;;; 10/25/84	Added quantum counter.  Moved main program level page
;;;		fail words back to UPT.  Moved all page fail words down
;;;		to 440 to compact UPT and EPT.
;;; 10/18/84	Fixed interval timer to keep more accurate time on the
;;;		average. 
;;; 10/17/84	Finishing touches on ITS paging.
;;; 9/29/84	CIRC instruction.  Version 259.

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;                                                           ;;;
;;;                                                           ;;;
;;;     COPYRIGHT (C) 1976, 1977,  1978, 1979, DIGITAL        ;;;
;;;      EQUIPMENT CORP., MAYNARD, MASS.                      ;;;
;;;                                                           ;;;
;;;     THIS SOFTWARE IS FURNISHED UNDER A LICENSE  FOR  USE  ;;;
;;;     ONLY  ON  A SINGLE COMPUTER SYSTEM AND MAY BE COPIED  ;;;
;;;     ONLY WITH  THE  INCLUSION  OF  THE  ABOVE  COPYRIGHT  ;;;
;;;     NOTICE.  THIS SOFTWARE, OR ANY OTHER COPIES THEREOF,  ;;;
;;;     MAY NOT BE PROVIDED OR OTHERWISE MADE  AVAILABLE  TO  ;;;
;;;     ANY  OTHER  PERSON EXCEPT FOR USE ON SUCH SYSTEM AND  ;;;
;;;     TO ONE WHO AGREES TO THESE LICENSE TERMS.  TITLE  TO  ;;;
;;;     AND  OWNERSHIP  OF  THE  SOFTWARE SHALL AT ALL TIMES  ;;;
;;;     REMAIN IN DEC.                                        ;;;
;;;                                                           ;;;
;;;     THE INFORMATION  IN  THIS  DOCUMENT  IS  SUBJECT  TO  ;;;
;;;     CHANGE WITHOUT NOTICE AND SHOULD NOT BE CONSTRUED AS  ;;;
;;;     A COMMITMENT BY DIGITAL EQUIPMENT CORPORATION.        ;;;
;;;                                                           ;;;
;;;     DEC  ASSUMES  NO  RESPONSIBILITY  FOR  THE  USE   OR  ;;;
;;;     RELIABILITY  OF  ITS  SOFTWARE IN EQUIPMENT WHICH IS  ;;;
;;;     NOT SUPPLIED BY DEC.                                  ;;;
;;;                                                           ;;;
;;;     DESIGNED AND WRITTEN BY:                              ;;;
;;;             DONALD A. LEWINE                              ;;;
;;;             DIGITAL EQUIPMENT CORP.                       ;;;
;;;             MARLBORO, MASS.                               ;;;
;;;             MR1-2/E47  X6430                              ;;;
;;;                                                           ;;;
;;;     MAINTAINED BY:                                        ;;;
;;;             DONALD A. LEWINE                              ;;;
;;;             DIGITAL EQUIPMENT CORP.                       ;;;
;;;             MARLBORO, MASS.                               ;;;
;;;             MR1-2/E47  X6430                              ;;;
;;;                                                           ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

.TOC	"DEC REVISION HISTORY"

;REV	WHY
;1	START KS10 MICROCODE BASED ON SM10 MICROCODE VERSION 510
;2	UPDATE TO KS10 VERSION 512
;3	FIX SOME DEFAULTS
;4	CHANGE HARDWARE TO MATCH ECO #215
;5	START TO UPDATE IO MICROCODE
;6	MORE WORK ON IO
;7	MAKE INTERRUPT THE 8080 BE A PULSE.
;10	ADD NEW RDIO AND WRIO
;11	FIX PROBLEMS IN MUUO CODE & CORRECT T-FIELDS
;12	FIX PROBLEMS IN DDIV
;13	FIX UP PROBLEMS IN PI
;14	TURN ON WRITE FOR FL-EXIT
;15	FIX UP MAP INSTRUCTION
;16	MORE WORK ON KI-STYLE MAP
;17	INVERT HOLD RIGHT AND HOLD LEFT BITS
;20	FIXUP WRIO & RDIO EFFECTIVE ADDRESS CALC.
;21	FIX EDIT 15
;22	HAVE LSH USE FAST SHIFT HARDWARE
;23	FIX T-FIELD VALUES FOR PRODUCTION HARDWARE
;24	REMOVE WRITE TEST FROM IO READS & WRITES
;25	REWRITE MUL & MULI TO BE FASTER AND SMALLER. ALSO MAKE ADJBP
;	USE NEW MULSUB
;26	MAKE BYTES USE FAST SHIFT ECO.
;27	MAKE SURE VMA FETCH IS CORRECT
;30	MORE OF 25 (FORGOT FMP)
;31	FIX SOME PROBLEMS WITH TRAPS
;32	SPEED UP EFFECTIVE ADDRESS CALCULATION
;33	MORE OF 32
;34	SPEED UP ASH & ROT
;35	FIX UP RDTIM SO THAT TIME DOES NOT GO BACKWARDS
;36	MORE OF 35
;37	FIX UP PROBLEMS WITH INTERRUPTS AND DOUBLE F.P.
;40	IMPROVE LISTING FORMAT
;41	SPEEDUP KL-MODE PAGE REFILL
;42	FIX UP DDIV
;43	STILL MORE DDIV STUFF
;44	CORRECT PROBLEMS IN D.P. PARITY STUFF
;45	CORRECT THE BLT CLEAR-CORE CASE TO INTERRUPT CORRECTLY
;46	MORE OF 45
;47	DO NOT ALLOW SOFTWARE INTERRUPTS IF THE PI LEVEL IS NOT
;	ACTIVE.
;50	MAKE FDV WORK THE SAME AS THE KL10
;51	FIX INTERRUPT IN CVTBDX. MAKE ABORT WORK LIKE SPEC.
;52	FIX BUG IN HALT LOOP
;53	FIX IOEA TO WORK IF NO @ OR INDEXING
;54	EDIT 47 BROKE JEN
;55	FIX FLAGS IN MULTIPLY. ALSO CODE BUMS
;56	MORE CODE BUMS
;57	CORRECT OVERFLOW TRAPS WHICH DO MUUOS TO NOT STORE
;	THE TRAP FLAGS.

;60	CORRECT TRAPS SO THAT DSKEA RUNS RIGHT
;61	MORE OF 60. NOTE: MICROCODE REQUIRES ECO #299!!
;62	ONE MORE TRY AT EDIT 60.
;63	CORRECT TOPS-10 STYLE PAGING SO THAT A WRITE VIOLATION SETS
;	BIT 2 IN THE PAGE FAIL WORD (ACCESS ALLOWED).
;64	EDIT 63 BROKE HARD PAGE FAILS. (NXM, BAD DATA, AND IO NXM)
;65	INTERRUPTS OUT OF MOVSRJ INSTRUCTIONS DO STRANGE THINGS.
;66	IO NXM PAGE FAIL FOR MISSING UBA GIVES PC+1 IN PAGE FAIL BLOCK.
;67	ON A BAD DATA ERROR, STORE THE BAD WORD IN AC BLOCK 7 WORD 0 AND
;	1
;70	FIX A BUG WHICH CAUSED INTERRUPTS OUT OF CVTBDT TO GENERATE A BAD
;	ANSWER.
;71	CLEANUP SOME THINGS TO MAKE LIFE EASIER FOR FIELD SERVICE
;72	LOOK FOR 1-MS TRAP ON @ PAGE POINTERS AND ABORT REFILL IF
;	SET.
;73	CORRECT EDIT 72.
;74	EDIT 67 GENERATES A DATA PATH PARITY ERROR BECAUSE OF THE BAD
;	DATA. CORRECT TO NOT CHECK PARITY.
;	ALSO CHANGE POP TO TIE UP BUS LESS.
;75	EDIT 60 BROKE TRAPS. MISSING =0 AT TRAP:. 
;76	CORRECT BUG IN DFAD AND DFSB
;77	FIX PROBLEM SEEN IN SOME (ALL BUT ENGINEERING?) MACHINES CAUSED
;	BY EDIT 76
;100	CHANGE DFAD/DFSB TO HAVE 2 MORE GUARD BITS. THIS SHOULD PRODUCE
;	KL10 ANSWERS FOR ALL NORMALIZED INPUTS
;	ALSO FIX A BUG IN CVTBDX PAGE FAIL LOGIC.
;101	DFDV OF 0.0 / -0.5 HANGS THE MACHINE
;102	FIX CHOPPED FLOATING POINT INSTRUCTIONS
;103	CORRECT DFDV ROUNDING BUG.
;104	CORRECT PROBLEMS IN DFMP
;105	RDTIME SOMETIMES GIVES WRONG ANSWER. CARRY BETWEEN
;	WORDS GETS LOST SOMETIME.
;106	MOVEM (ALSO, SETZM, SETOM, ETC.) SOMETIMES DOES NOT GENERATE
;	A WRITE-TRAP IN 100% OF THE CASES THAT IT SHOULD.
;107	PXCT 14, DOES NOT GET THE INDEX REGISTER IN THE PREVIOUS
;	CONTEXT ALL THE TIME.
;110	FIX TYPO IN EDIT 103
;111	63. BIT BYTES DO NOT WORK CORRECTLY. DSKDA FAILS BECAUSE OF THIS
;	PROBLEM.
;******* VERSION 111 WENT OUT WITH SYSTEM REV 2 *******

;112	FIX COMMENT IN TEST INSTRUCTIONS
;113	CORRECT IOEA TO COMPUTE CORRECT ADDRESS IF JUST LOCAL INDEXING
;	IS USED.
;114	CORRECT INTERRUPT BUG IN DMUL
;115	CORRECT COMMENTS HALT STATUS BLOCK
;116	CORRECT PROBLEM WHERE CST MODIFIED BIT GETS SET BY MISTAKE.
;117	RDINT INSTRUCTION DOES NOT WORK AT ALL. IT STORES RANDOM TRASH
;	IN THE WRONG PLACE. NEED TO LOAD BR NOT AR.

;DEC changes after MIT version 261, merged in where relevant

;120	FLOATING POINT OPERATIONS SOMETIMES GET THE WRONG RESULT WITH
;	INPUTS OF UNNORMALIZED ZEROS. THIS SHOULD NEVER HAPPEN WITH
;	FORTRAN OR ANY OTHER DEC LANGUAGE.
;121	PREVENT KEEP-ALIVE CRASHES FROM OCCURRING BECAUSE THE MOVSRJ
;	INSTRUCTION CAN LOCK OUT THE 1MS TIMER INTERRUPTS FROM BEING
;	HANDLED. THIS CAUSES THE OPERATING SYSTEM TO LOSE TRACK OF THE
;	PASSAGE OF TIME.
;122	DFAD FOLLOWED BY A FSC OF -5 CAUSES THE FSC TO GET WRONG
;	ANSWER. HAD TO CLEAR FLAG WORD AT EXIT OF DFAD TO FIX PROBLEM
;123	MORE CODE FOR EDIT 121. ADDED ANOTHER DISPATCH ADDRESS FOR
;	PAGE FAIL CODE AT PFD:.
;124	ADD ASSEMBLY OPTIONS FOR NOCST AND INHIBIT CST UPDATE. (not in MIT ucode)
;	ADD BLTUB/BLTBU TO GET UBA STYLE BYTES SWAPPED TO/FROM ILDB FORM.
;	ADD ASSEMBLY OPTIONS FOR KI/KL PAGE.  NEED THE SPACE FOR BLTUB/BU. (not in MIT ucode)
;125	SUPPORT THE "MAJOR/MINOR VERSION IN 136" UCODE STANDARD. (not in MIT ucode)
;	FIX BAD CONSTRAINT FOR INHCST ASSEMBLIES (NOT CURRENTLY USED) (not in MIT ucode)
;126	FIX NON-TRIVIAL CASES OF RDUBR,WRUBR, AND PROCESS CONTEXT WORD. (not in MIT ucode)
;127	JSR IN A TRAP CYCLE STORES E+1 SOMETIMES.  TRAP CYCLE WAS NOT BEING
;	CLEARED (BY NICOND) BEFORE STARTING THE NEXT MEMORY READ.  
;130	FIX UCODE HANG WITH STOPPPED CLOCKS ON WR (KL-PAGING REGISTER) IF (not in MIT ucode)
;	PAGING IS ON.  IDEALLY, WE WOULD REMOVE WRITE TEST FROM THE DROM
;	FIELD, BUT IT'S TOO LATE TO ECO THE ROMS.  
;	RESTRICTION:  WRITE KLPAGE REGISTER LOCATION MUST BE WRITABLE.
.TOC	"HOW TO READ THE MICROCODE"

;		
;		
;		1.0 FIELD DEFINITIONS
;		
;		THESE OCCUR AT THE BEGINNING  OF  THE  LISTING,  IN  THE  SOURCE  FILE  KS10.MIC
;		(CONTROL AND DISPATCH RAM DEFINITIONS).  THEY HAVE THE FORM:
;		
;		        SYMBOL/=<L:R>M,J
;		
;		THE PARAMETER (J) IS MEANINGFUL WHEN "D" IS SPECIFIED AS THE DEFAULT  MECHANISM,
;		AND  IN  THAT  CASE, GIVES THE DEFAULT VALUE OF THE FIELD IN OCTAL.  WHEN "F" IS
;		SPECIFIED AS THE DEFAULT MECHANISM, (J) IS THE NAME OF A  FIELD  WHICH  CONTAINS
;		THE DEFAULT VALUE FOR THIS FIELD.
;		
;		THE PARAMETER (L) GIVES THE BIT POSITION OF THE LEFTMOST BIT IN THE FIELD.   THE
;		SAME METHOD IS USED AS FOR (R) BELOW.
;		
;		THE PARAMETER (R) GIVES THE FIELD POSITION IN DECIMAL AS THE BIT NUMBER  OF  THE
;		RIGHTMOST  BIT  OF  THE FIELD.  BITS ARE NUMBERED FROM 0 ON THE LEFT.  NOTE THAT
;		THE POSITION OF BITS IN THE MICROWORD SHOWN IN THE LISTING BEARS NO RELATION  TO
;		THE ORDERING OF BITS IN THE HARDWARE MICROWORD, WHERE FIELDS ARE OFTEN BROKEN UP
;		AND SCATTERED.
;		
;		THE PARAMETER (M) IS OPTIONAL, AND SELECTS A DEFAULT MECHANISM  FOR  THE  FIELD.
;		THE  LEGAL  VALUES  OF  THIS PARAMETER ARE THE CHARACTERS "D", "F", "T", "P", OR
;		"+".
;		
;		        "D" MEANS (J) IS THE DEFAULT VALUE OF THE FIELD IF NO EXPLICIT VALUE  IS
;		        SPECIFIED.
;		
;		        "F" IS USED TO CAUSE THIS FIELD TO DEFAULT TO SOME OTHER FIELD.
;		
;		        "T" IS USED ON THE TIME FIELD TO SPECIFY THAT THE  VALUE  OF  THE  FIELD
;		        DEPENDS  ON  THE  TIME PARAMETERS SELECTED FOR OTHER FIELDS.  "T" IS NOT
;		        USED IN THE KS10.
;		
;		        "P" IS USED ON THE PARITY FIELD TO SPECIFY THAT THE VALUE OF  THE  FIELD
;		        SHOULD  DEFAULT  SUCH THAT PARITY OF THE ENTIRE WORD IS ODD.  "P" IS NOT
;		        USED ON THE KS10.
;		
;		        "+" IS USED ON THE JUMP ADDRESS FIELD TO SPECIFY THAT THE  DEFAULT  JUMP
;		        ADDRESS  IS  THE  ADDRESS  OF  THE  NEXT  INSTRUCTION ASSEMBLED (NOT, IN
;		        GENERAL, THE CURRENT LOCATION +1).
;		
;		IN GENERAL, A FIELD CORRESPONDS TO THE SET OF BITS WHICH PROVIDE  SELECT  INPUTS
;		FOR MIXERS OR DECODERS, OR CONTROLS FOR ALU'S.
;		
;		

;		2.0 VALUE DEFINITIONS
;		
;		FOLLOWING A FIELD DEFINITION, SYMBOLS MAY BE CREATED IN THAT FIELD TO CORRESPOND
;		TO VALUES OF THE FIELD.  THE FORM IS:
;		
;		        SYMBOL=N
;		
;		"N" IS, IN OCTAL, THE VALUE OF SYMBOL WHEN USED IN THE FIELD.
;		
;		
;		
;		3.0 LABEL DEFINITIONS
;		
;		A MICRO INSTRUCTION MAY BE LABELLED BY A SYMBOL FOLLOWED BY COLON PRECEDING  THE
;		MICROINSTRUCTION  DEFINITION.   THE  ADDRESS OF THE MICROINSTRUCTION BECOMES THE
;		VALUE OF THE SYMBOL IN THE FIELD NAMED "J".  EXAMPLE:
;		
;		        FOO:  J/FOO
;		
;		THIS IS A MICROINSTRUCTION WHOSE "J" FIELD (JUMP  ADDRESS)  CONTAINS  THE  VALUE
;		"FOO".   IT  ALSO  DEFINES  THE  SYMBOL  "FOO"  TO  BE  THE  ADDRESS  OF ITSELF.
;		THEREFORE, IF EXECUTED BY THE MICROPROCESSOR, IT WOULD LOOP ON ITSELF.
;		
;		
;		
;		4.0 COMMENTS
;		
;		A SEMICOLON ANYWHERE ON A LINE CAUSES THE REST OF THE LINE TO BE IGNORED BY  THE
;		ASSEMBLER.  THIS TEXT IS AN EXAMPLE OF COMMENTS.
;		
;		
;		
;		5.0 MICROINSTRUCTION DEFINITION
;		
;		A WORD OF MICROCODE IS DEFINED BY SPECIFYING A FIELD  NAME,  FOLLOWED  BY  SLASH
;		(/),  FOLLOWED BY A VALUE.  THE VALUE MAY BE A SYMBOL DEFINED FOR THAT FIELD, AN
;		OCTAL DIGIT STRING, OR A DECIMAL DIGIT STRING (DISTINGUISHED BY THE FACT THAT IT
;		CONTAINS  "8"  AND/OR "9" AND/OR IS TERMINATED BY A PERIOD).  SEVERAL FIELDS MAY
;		BE SPECIFIED IN ONE MICROINSTRUCTION BY  SEPARATING  FIELD/VALUE  SPECIFICATIONS
;		WITH COMMAS.  EXAMPLE:
;		
;		        AD/ZERO,RAMADR/AC*#,ACALU/AC+N,ACN/1,DBUS/DP
;		
;		
;		6.0 CONTINUATION
;		
;		THE DEFINITION OF A MICROINSTRUCTION MAY CONTINUED ONTO TWO  OR  MORE  LINES  BY
;		BREAKING IT AFTER ANY COMMA.  IN OTHER WORDS, IF THE LAST NON-BLANK, NON-COMMENT
;		CHARACTER ON A LINE IS A COMMA, THE INSTRUCTION SPECIFICATION  IS  CONTINUED  ON

;		THE FOLLOWING LINE.  EXAMPLE:
;		        READ [AR],              ;LOOK AT EFFECTIVE ADDRESS
;		        SKIP DP18,              ;SEE IF RIGHT OR LEFT SHIFT
;		        SC_SHIFT-1,              ;PUT NUMBER OF PLACE TO
;		                                ;SHIFT IN SC
;		        LOAD FE,                ; AND IN FE
;		        INST DISP               ;GO DO THE SHIFT
;		
;		
;		
;		7.0 MACROS
;		
;		A MACRO IS A SYMBOL WHOSE VALUE IS ONE OR MORE FIELD/VALUE SPECIFICATIONS AND/OR
;		MACROS.   A  MACRO  DEFINITION IS A LINE CONTAINING THE MACRO NAME FOLLOWED BY A
;		QUOTED STRING WHICH IS THE VALUE OF THE MACRO.  EXAMPLE:
;		
;		        LOAD VMA "MEM/1, LDVMA/1
;		
;		THE APPEARANCE OF A MACRO IN A MICROINSTRUCTION DEFINITION IS EQUIVALENT TO  THE
;		APPEARANCE OF ITS VALUE.
;		
;		MACRO MAY HAVE PARAMETERS ENCLOSED IN [].  FOR EXAMPLE,
;		
;		        []_[] "AD/A,A/@2,DEST/AD,B/@1"
;		
;		THE @1 GETS REPLACED BY WHAT IS WRITTEN IN  THE  FIRST  SET  OF  []  AND  @2  IS
;		REPLACED BY WHAT IS WRITTEN IN THE SECOND SET OF [].  THUS
;		
;		        [AR]_[ARX]
;		
;		HAS THE SAME EFFECT AS SAYING
;		
;		        AD/A,A/ARX,DEST/AD,B/AR
;		
;		
;		        SEE DESCRIPTION OF RULES FOR MACRO NAMES.
;		
;		8.0 PSEUDO OPS
;		
;		        THE MICRO ASSEMBLER HAS 13 PSEUDO-OPERATORS:
;		
;		        .DCODE AND .UCODE SELECT THE RAM INTO WHICH SUBSEQUENT MICROCODE WILL BE
;		        LOADED,  AND  THEREFORE  THE  FIELD  DEFINITIONS  AND  MACROS  WHICH ARE
;		        MEANINGFUL IN SUBSEQUENT MICROCODE
;		        .TITLE DEFINES A STRING OF TEXT TO APPEAR IN THE PAGE HEADER, AND
;		        .TOC DEFINES AN ENTRY FOR THE TABLE OF CONTENTS AT THE BEGINNING.
;		        .SET DEFINES THE VALUE OF A CONDITIONAL ASSEMBLY PARAMETER,
;		        .CHANGE REDEFINES A CONDITIONAL ASSEMBLY PARAMETER,
;		        .DEFAULT ASSIGNS A VALUE TO AN UNDEFINED PARAMETER.
;		        .IF ENABLES ASSEMBLY IF THE VALUE OF THE PARAMETER IS NOT ZERO,
;		        .IFNOT ENABLES ASSEMBLY IF THE PARAMETER VALUE IS ZERO, AND
;		        .ENDIF RE-ENABLES ASSEMBLY IF SUPPRESSED BY THE PARAMETER NAMED.
;		        .NOBIN TURNS OFF THE BINARY A GETS RID OF THE SPACE USED TO LIST IT,
;		        .BIN TURN BINARY BACK ON AGAIN.
;		        .WIDTH CONTROLS THE NUMBER OF BITS IN THE CRAM

;		9.0 LOCATION CONTROL
;		
;		A MICROINSTRUCTION "LABELLED" WITH A NUMBER IS ASSIGNED TO THAT ADDRESS.
;		
;		THE CHARACTER "=" AT THE BEGINNING OF A LINE, FOLLOWED BY A STRING OF 0'S,  1'S,
;		AND/OR   *'S,   SPECIFIES   A   CONSTRAINT   ON   THE   ADDRESS   OF   FOLLOWING
;		MICROINSTRUCTIONS.  THE NUMBER OF CHARACTERS IN THE CONSTRAINT STRING (EXCLUDING
;		THE  "=")  IS  THE  NUMBER  OF  LOW-ORDER  BITS CONSTRAINED IN THE ADDRESS.  THE
;		MICROASSEMBLER ATTEMPTS TO FIND AN UNUSED LOCATION WHOSE ADDRESS HAS 0  BITS  IN
;		THE POSITIONS CORRESPONDING TO 0'S IN THE CONSTRAINT STRING AND 1 BITS WHERE THE
;		CONSTRAINT HAS 1'S.  ASTERISKS DENOTE "DON'T CARE" BIT POSITIONS.
;		
;		IF THERE ARE ANY 0'S IN THE CONSTRAINT STRING, THE CONSTRAINT IMPLIES A BLOCK OF
;		<2**N> MICROWORDS, WHERE N IS THE NUMBER OF 0'S IN THE STRING.  ALL LOCATIONS IN
;		THE BLOCK WILL HAVE 1'S IN THE ADDRESS BITS CORRESPONDING TO 1'S IN THE  STRING,
;		AND BIT POSITIONS DENOTED BY *'S WILL BE THE SAME IN ALL LOCATIONS OF THE BLOCK.
;		
;		IN SUCH A CONSTRAINT BLOCK, THE DEFAULT ADDRESS PROGRESSION IS COUNTING  IN  THE
;		"0"  POSITIONS  OF  THE  CONSTRAINT STRING, BUT A NEW CONSTRAINT STRING OCCURING
;		WITHIN A BLOCK MAY FORCE SKIPPING OVER SOME LOCATIONS OF THE  BLOCK.   WITHIN  A
;		BLOCK,  A  NEW  CONSTRAINT STRING DOES NOT CHANGE THE PATTERN OF DEFAULT ADDRESS
;		PROGRESSION, IT MERELY ADVANCES THE LOCATION COUNTER OVER THOSE LOCATIONS.   THE
;		MICROASSEMBLER WILL LATER FILL THEM IN.
;		
;		A NULL CONSTRAINT STRING ("=" FOLLOWED BY ANYTHING BUT "0", "1", OR "*")  SERVES
;		TO TERMINATE A CONSTRAINT BLOCK.  EXAMPLES:
;		
;		        =0 
;		
;		THIS SPECIFIES THAT THE LOW-ORDER ADDRESS BIT MUST BE ZERO-- THE  MICROASSEMBLER
;		FINDS  AN  EVEN-ODD  PAIR  OF LOCATIONS, AND PUTS THE NEXT TWO MICROINSTRUCTIONS
;		INTO THEM.
;		
;		        =11
;		THIS SPECIFIES THAT THE TWO LOW-ORDER BITS OF THE ADDRESS  MUST  BOTH  BE  ONES.
;		SINCE THERE ARE NO 0'S IN THIS CONSTRAINT, THE ASSEMBLER FINDS ONLY ONE LOCATION
;		MEETING THE CONSTRAINT.
;		
;		        =0*****
;		
;		THIS SPECIFIES  AN  ADDRESS  IN  WHICH  THE  "40"  BIT  IS  ZERO.   DUE  TO  THE
;		IMPLEMENTATION OF THIS FEATURE IN THE ASSEMBLER, THE DEFAULT ADDRESS PROGRESSION
;		APPLIES ONLY TO THE LOW-ORDER 5 BITS, SO THIS CONSTRAINT FINDS ONE WORD IN WHICH
;		THE  "40"  BIT  IS ZERO, AND DOES NOT ATTEMPT TO FIND ONE IN WHICH THAT BIT IS A
;		ONE.  THIS LIMITATION HAS BEEN CHANGED WITH NEWER ASSEMBLER  VERSIONS.   HOWEVER
;		NONE  OF  THE  LOCATIONS  IN  THE  MICROCODE REQUIRE ANYTHING BUT THE CONSTRAINT
;		MENTIONED ABOVE.

.TOC	"CONDITIONAL ASSEMBLY DEFINITIONS"

.DEFAULT/SIM=0		;0=RUN ON REAL HARDWARE
			;1=RUN UNDER SIMULATOR

.DEFAULT/FULL=1		;0=INCLUDE ONLY BASIC INSTRUCTIONS
			;1=INCLUDE FULL INSTRUCTION SET

.DEFAULT/CIRC=0		;1=Assemble the CIRC instruction.

.DEFAULT/ITS=0		;0=DEC style microcode.
			;1=ITS style microcode.

.DEFAULT/JPC=0		;1=Assemble JPC feature.

.DEFAULT/1PROC=0	;1=Assemble one-proceed feature.

.DEFAULT/PCST=0		;1=Assemble PC sampling feature.

.DEFAULT/ITSIO=0	;1=Assemble ITS I/O instructions.

.DEFAULT/TEST=0		;1=Assemble some temporary experimental feature.

.WIDTH/108		;ONLY FIELDS BETWEEN BITS 0 AND 107 EVER
			; GET LOADED INTO THE CRAM. OTHER FIELDS
			; ARE USED FOR DEFAULTING PROCESS.

;THIS IS USELESS AND BRAIN DAMAGED
;STUFF IS KEPT OUT OF DROM SPACE BY MORE GENERAL MECHANISMS
;.REGION/0,1377/2000,3777/1400,1777
;			;TRY AND KEEP STUFF OUT OF DROM SPACE

;WRITE A RAM FILE WITH THE FIELDS REARRANGED SO THE 8080 CAN HACK THEM
;The RAM file format appears to be:
;
;4000 sequential CRAM locations starting at 0.
;Each location is 96 bits expressed as 8 12-bit bytes and one
;padding byte packed into three words.  Bytes are in right to
;left order within 36-bit words, and also within the 96-bit
;words.  Thus RAM SRC through MARK are in the right 12 bits of
;the first 36-bit word and J is in the middle 12 bits of the
;third 36-bit word.  Parity is even parity, computed separately
;for the two halves of the word packaged on different boards.
;
;.RAMFILE takes the fields in left-to-right (pdp10) order,
;thus the 8080's eight 12-bit bytes are given in order 2,1,0,5,4,3,pad,7,6
;One parity bit is for 0-4, the other is for 5-7.

.RAMFILE/	AD,RSRC,DBM,DBUS,A,CLKL,CLKR,B,			;WORDS 2-1
		RAMADR,DEST,LOADSC,LOADFE,CHKL,CHKR,
		  ODD PARITY<0:35,48:71>,0,			;WORD 0
		ODD PARITY<36:47,84:107>,CRY38,MEM,
		  DISP LOW,SPEC LOW,SKIP LOW,			;WORD 5
		# LOW,						;WORD 4
		FMWRITE,MULTI SHIFT,GENL,GENR,DIVIDE,MULTI PREC,# HIGH,	;WORD 3
		12/0,						;PAD
		J,						;WORD 7
		T,CALL,SKIP HIGH,SPEC HIGH,DISP HIGH		;WORD 6
.TOC	"2901 REGISTER USAGE"

;	!=========================================================================!
;0:	!                   MAG (ONES IN BITS 1-36, REST ZERO)                    !
;	!-------------------------------------------------------------------------!
;1:	!                 PC (ADDRESS OF CURRENT INSTRUCTION + 1)                 !
;	!-------------------------------------------------------------------------!
;2:	!                        HR (CURRENT INSTRUCTION)                         !
;	!-------------------------------------------------------------------------!
;3:	!                    AR (TEMP -- MEM OP AT INST START)                    !
;	!-------------------------------------------------------------------------!
;4:	!               ARX (TEMP -- LOW ORDER HALF OF DOUBLE PREC)               !
;	!-------------------------------------------------------------------------!
;5:	!                                BR (TEMP)                                !
;	!-------------------------------------------------------------------------!
;6:	!           BRX (TEMP -- LOW ORDER HALF OF DOUBLE PREC BR!BRX)            !
;	!-------------------------------------------------------------------------!
;7:	!                          ONE (THE CONSTANT 1)                           !
;	!-------------------------------------------------------------------------!
;10:	!                        EBR (EXEC BASE REGISTER)                         !
;	!-------------------------------------------------------------------------!
;11:	!                        UBR (USER BASE REGISTER)                         !
;	!-------------------------------------------------------------------------!
;12:	!           MASK (ONES IN BITS 0-35, ZERO IN -1, -2, 36 AND 37)           !
;	!-------------------------------------------------------------------------!
;13:	!          FLG (FLAG BITS)           !           PAGE FAIL CODE           !
;	!-------------------------------------------------------------------------!
;14:	!                  PI (PI SYSTEM STATUS REGISTER [RDPI])                  !
;	!-------------------------------------------------------------------------!
;15:	!                       XWD1 (1 IN EACH HALF WORD)                        !
;	!-------------------------------------------------------------------------!
;16:	!                                T0 (TEMP)                                !
;	!-------------------------------------------------------------------------!
;17:	!                                T1 (TEMP)                                !
;	!=========================================================================!

.TOC	"MICROCODE FIELDS -- LISTING FORMAT"

;								; 3633	1561:
;								; 3634	SUB:	[AR]_AC-[AR],
;								; 3635		AD FLAGS, 3T,
;	U 1561, 1500,2551,0303,0274,4463,7701,4200,0001,0001	; 3636		EXIT
;	  [--]  [--] !!!! [][] !!![-][][-][]! !!!     [----]
;	  !     !    !!!! ! !  !!!!  ! !  ! ! !!!        !
;	  !     !    !!!! ! !  !!!!  ! !  ! ! !!!        +---- # (MAGIC NUMBER)
;	  !     !    !!!! ! !  !!!!  ! !  ! ! !!!      
;	  !     !    !!!! ! !  !!!!  ! !  ! ! !!+------------- MULTI PREC, MULTI SHIFT, CALL
;	  !     !    !!!! ! !  !!!!  ! !  ! ! !!		(4S, 2S, 1S)
;	  !     !    !!!! ! !  !!!!  ! !  ! ! !+-------------- FM WRITE, MEM, DIVIDE
;	  !     !    !!!! ! !  !!!!  ! !  ! ! !			(4S, 2S, 1S)
;	  !     !    !!!! ! !  !!!!  ! !  ! ! +--------------- CRY38, LOAD SC, LOAD FE
;	  !     !    !!!! ! !  !!!!  ! !  ! !			(4S, 2S, 1S)
;	  !     !    !!!! ! !  !!!!  ! !  ! +----------------- T
;	  !     !    !!!! ! !  !!!!  ! !  !
;	  !     !    !!!! ! !  !!!!  ! !  +------------------- SKIP
;	  !     !    !!!! ! !  !!!!  ! !
;	  !     !    !!!! ! !  !!!!  ! +---------------------- DISP
;	  !     !    !!!! ! !  !!!!  !
;	  !     !    !!!! ! !  !!!!  +------------------------ SPEC
;	  !     !    !!!! ! !  !!!!
;	  !     !    !!!! ! !  !!!+--------------------------- CLOCKS & PARITY
;	  !     !    !!!! ! !  !!!			(CLKR, GENR, CHKR, CLKL, GENL, CHKL)
;	  !     !    !!!! ! !  !!+---------------------------- DBM
;	  !     !    !!!! ! !  !!
;	  !     !    !!!! ! !  !+----------------------------- DBUS
;	  !     !    !!!! ! !  !
;	  !     !    !!!! ! !  +------------------------------ RAM ADDRESS
;	  !     !    !!!! ! !
;	  !     !    !!!! ! +--------------------------------- B
;	  !     !    !!!! !
;	  !     !    !!!! +----------------------------------- A
;	  !     !    !!!!
;	  !     !    !!!+------------------------------------- DEST
;	  !     !    !!!
;	  !     !    !!+-------------------------------------- RSRC
;	  !     !    !!
;	  !     !    !+--------------------------------------- LSRC   ]
;	  !     !    !                                                ] - AD
;	  !     !    +---------------------------------------- ALU    ]
;	  !     !
;	  !     +--------------------------------------------- J
;	  !
;	  LOCATION OF THIS MICRO WORD

.TOC	"MICROCODE FIELDS -- DATAPATH CHIP"

J/=<0:11>+              ;CRA1
			;NEXT MICROCODE ADDRESS

;ALU FUNCTIONS

;NOTE: THE AD FIELD IS A 2 DIGIT FIELD. THE LEFT DIGIT IS THE
; 2901 ALU FUNCTION. THE RIGHT DIGIT IS THE 2901 SRC CODE FOR
; THE LEFT HALF. NORMALY THE RIGHT HALF SRC CODE IS THE SAME AS
; THE LEFT HALF.
AD/=<12:17>D,44       ;DPE1 & DPE2
	A+Q=00
	A+B=01
	0+Q=02
	0+B=03
	0+A=04
	D+A=05
	D+Q=06
	0+D=07
	Q-A-.25=10
	B-A-.25=11
	Q-.25=12
	B-.25=13
	A-.25=14
	A-D-.25=15
	Q-D-.25=16
	-D-.25=17
	A-Q-.25=20
	A-B-.25=21
	-Q-.25=22
	-B-.25=23
	-A-.25=24
	D-A-.25=25
	D-Q-.25=26
	D-.25=27
	A.OR.Q=30
	A.OR.B=31
	Q=32
	B=33
	A=34
	D.OR.A=35
	D.OR.Q=36
	D=37
	A.AND.Q=40
	A.AND.B=41

;MORE ALU FUNCTIONS

	ZERO=42
;	ZERO=43
;	ZERO=44
	D.AND.A=45
	D.AND.Q=46
;	ZERO=47
	.NOT.A.AND.Q=50
	.NOT.A.AND.B=51
;	Q=52
;	B=53
;	A=54
	.NOT.D.AND.A=55
	.NOT.D.AND.Q=56
;	ZERO=57
	A.XOR.Q=60
	A.XOR.B=61
;	Q=62
;	B=63
;	A=64
	D.XOR.A=65
	D.XOR.Q=66
;	D=67
	A.EQV.Q=70
	A.EQV.B=71
	.NOT.Q=72
	.NOT.B=73
	.NOT.A=74
	D.EQV.A=75
	D.EQV.Q=76
	.NOT.D=77

;THIS FIELD IS THE RIGHTMOST 3 BITS OF THE
; AD FIELD. IT IS USED ONLY TO DEFAULT THE RSRC 
; FIELD.
LSRC/=<15:17>         ;DPE1

;THIS IS THE SOURCE FOR THE RIGHT HALF OF THE
; DATA PATH. IT LETS US MAKE THE RIGHT AND LEFT
; HALF WORDS DO SLIGHTLY DIFFERENT THINGS.
RSRC/=<18:20>F,LSRC	;DPE2
	AQ=0		;A  Q
	AB=1		;A  B
	0Q=2		;0  Q
	0B=3		;0  B
	0A=4		;0  A
	DA=5		;D  A
	DQ=6		;D  Q
	D0=7		;D  0

;DESTINATION CONTROL
;SEE DPE1 AND DPE2 (2'S WEIGHT IS INVERTED ON DPE5)
DEST/=<21:23>D,3      ;DPE1 & DPE2
	A=0		;A REG IS CHIP OUTPUT, AD IS WRITTEN
			; INTO REG FILE
	AD=1		;REG FILE GETS AD
	Q_AD=2		;REG FILE IS NOT LOADED
	PASS=3		;AD OUTPUT IS CHIP OUTPUT
			; Q AND REG FILE LEFT ALONE
	Q_Q*2=4		;ALSO REG FILE GETS AD*2
	AD*2=5		;AND Q IS LEFT ALONE
	Q_Q*.5=6	;ALSO REG FILE GETS AD*.5
	AD*.5=7		;AND Q IS LEFT ALONE

;	<24:25>		;UNUSED

A/=<26:29>            	;DPE1 & DPE2
	MAG=0
	PC=1
	HR=2
	AR=3
	ARX=4
	BR=5
	BRX=6
	ONE=7
	EBR=10
	UBR=11
	MASK=12
	FLG=13
	PI=14
	XWD1=15
	T0=16
	T1=17

;	<30:31>		;UNUSED

B/=<32:35>D,0         ;DPE1 & DPE2
	MAG=0
	PC=1
	HR=2
	AR=3
	ARX=4
	BR=5
	BRX=6
	ONE=7
	EBR=10
	UBR=11
	MASK=12
	FLG=13
	PI=14
	XWD1=15
	T0=16
	T1=17

.TOC	"MICROCODE FIELDS -- RAM FILE ADDRESS AND D-BUS"

RAMADR/=<36:38>D,4	;DPE6
	AC#=0		;AC NUMBER
	AC*#=1		;AC .FN. #
	XR#=2		;INDEX REGISTER
	VMA=4		;VIRTUAL MEMORY REFERENCE
	RAM=6		;VMA SUPPLIES 10-BIT RAM ADDRESS
	#=7		;ABSOLUTE RAM FILE REFERENCE

;	<39:39>

;LEFT HALF ON DPE3 AND RIGHT HALF ON DPE4
DBUS/=<40:41>D,1      	;DPE3 & DPE4
	PC FLAGS=0	;PC FLAGS IN LEFT HALF
	PI NEW=0	;NEW PI LEVEL IN BITS 19-21
;	VMA=0		;VMA IN BITS 27-35
	DP=1		;DATA PATH
	RAM=2		;CACHE, AC'S AND WORKSPACE
	DBM=3		;DBM MIXER

;LEFT HALF ON DPM1 AND RIGHT HALF ON DPM2
DBM/=<42:44>D,7       	;DPM1 & DPM2
	SCAD DIAG=0	;(LH) SCAD DIAGNOSTIC
	PF DISP=0	;PAGE FAIL DISP IN BITS 18-21
	APR FLAGS=0	;APR FLAGS IN BITS 22-35
	BYTES=1		;5 COPIES OF SCAD 1-7
	EXP=2		;LH=EXPONENT, RH=TIME FRACTION
	DP=3		;DATA PATH
	DP SWAP=4	;DATA PATH SWAPPED
	VMA=5		;VMA FLAGS,,VMA
	MEM=6		;MEMORY BUFFER
	#=7		;NUMBER FIELD IN BOTH HALVES

.TOC	"MICROCODE FIELDS -- PARITY GENERATION & HALF WORD CONTROL"

AD PARITY OK/=<108>D,0  ;**NOT STORED IN CRAM**
			;THIS BIT IS A 1 IF THE ALU IS DOING
				; SOMETHING WHICH DOES NOT INVALIDATE
				; PARITY. IT DOES NOT APPEAR IN THE
				; REAL MACHINE. WE JUST USE IT TO SET
				; THE DEFAULT FOR GENR & GENL

CLKL/=<45:45>D,1        ;DPE5
			;CLOCK THE LEFT HALF OF THE MACHINE
GENL/=<46:46>F,AD PARITY OK ;DPE4 FROM CRM2 PARITY EN LEFT H
			;STORE PARITY FOR 2901 LEFT
CHKL/=<47:47>           ;DPE4 FROM CRM2 PARITY CHK LEFT H
			;CHECK LEFT HALF DBUS PARITY

CLKR/=<48:48>D,1        ;DPE5
			;CLOCK THE RIGHT HALF OF THE MACHINE
GENR/=<49:49>F,AD PARITY OK ;DPE4 FROM CRM2 PARITY EN RIGHT H
			;STORE PARITY FOR 2901 RIGHT
CHKR/=<50:50>           ;DPE4 FROM CRM2 PARITY CHK RIGHT H
			;CHECK RIGHT HALF DBUS PARITY

.TOC	"MICROCODE FIELDS -- SPEC"


;
;THE FOLLOWING SPECIAL FUNCTION ARE DECODED ON DPE1, DPE5, AND DPMA:
;	!=========================================================================!
;	!S!     EFFECT      !    CRA6 SPEC    !    CRA6 SPEC    !    CRA6 SPEC    !
;	!P!    ON SHIFT     !      EN 40      !      EN 20      !      EN 10      !
;	!E!      PATHS      !  E102 ON DPE5   !  E101 ON DPE5   !  E410 ON DPMA   !
;	!C!   (SEE DPE1)    !                 !  E411 ON DPMA   !  E113 ON CRA2   !
;	!=========================================================================!
;	!0!     NORMAL      !   CRY 18 INH    !    PREVIOUS     !        #        !
;	!-------------------------------------------------------------------------!
;	!1!      ZERO       !     IR LOAD     !     XR LOAD     !   CLR 1 MSEC    !
;	!-------------------------------------------------------------------------!
;	!2!      ONES       !     <SPARE>     !     <SPARE>     !  CLR IO LATCH   !
;	!-------------------------------------------------------------------------!
;	!3!       ROT       !     PI LOAD     !    APR FLAGS    !   CLR IO BUSY   !
;	!-------------------------------------------------------------------------!
;	!4!      ASHC       !    ASH TEST     !    SET SWEEP    !   PAGE WRITE    !
;	!-------------------------------------------------------------------------!
;	!5!      LSHC       !    EXP TEST     !     APR EN      !     NICOND      !
;	!-------------------------------------------------------------------------!
;	!6!       DIV       !    PC FLAGS     !    PXCT OFF     !     PXCT EN     !
;	!-------------------------------------------------------------------------!
;	!7!      ROTC       !  AC BLOCKS EN   !     MEM CLR     !    MEM WAIT     !
;	!=========================================================================!
; THE DPM BOARD USES THE SPEC FIELD TO CONTROL THE
;  DBM MIXER, AS FOLLOWS:
;
;	!=====================================!
;	!  S  !                               !
;	!  P  !        ACTION WHEN DBM        !
;	!  E  !          SELECTS DP           !
;	!  C  ! GET DP BITS  !  GET SCAD 1-7  !
;	!=====================================!
;	!  0  !     ALL      !      NONE      !
;	!-------------------------------------!
;	!  1  !     7-35     !      0-6       !
;	!-------------------------------------!
;	!  2  !0-6 AND 14-35 !      7-13      !
;	!-------------------------------------!
;	!  3  !0-13 AND 21-35!     14-20      !
;	!-------------------------------------!
;	!  4  !0-20 AND 28-35!     21-27      !
;	!-------------------------------------!
;	!  5  ! 0-27 AND 35  !     28-34      !
;	!-------------------------------------!
;	!  6  !         SAME AS ZERO          !
;	!-------------------------------------!
;	!  7  !         SAME AS ZERO          !
;	!=====================================!

;THE SPEC FIELD IS DEFINED AS A 6-BIT FIELD. THE TOP 3 BITS
; ARE SPEC SEL A, SPEC SEL B, AND SPEC SEL C. THE LOW 3 BITS ARE
; THE SELECT CODE.

SPEC/=<51:56>D,0      	;DPE1 & DPE5 & DPM1 & DPMA
	#=10		;DECODE # BITS 
	CLRCLK=11	;CLEAR 1MS NICOND FLAG
	CLR IO LATCH=12	;CLEAR IO LATCH
	CLR IO BUSY=13	;CLEAR IO BUSY
	LDPAGE=14	;WRITE PAGE TABLE
	NICOND=15	;DOING NICOND DISPATCH
	LDPXCT=16	;LOAD PXCT FLAGS
	WAIT=17		;MEM WAIT
	PREV=20		;FORCE PREVIOUS CONTEXT
	LOADXR=21	;LOAD XR #, USES PXCT FIELD TO SELECT 
			; CORRECT AC BLOCK
	APR FLAGS=23	;LOAD APR FLAGS
	CLRCSH=24	;CLEAR CACHE
	APR EN=25	;SET APR ENABLES
	MEMCLR=27	;CLEAR PAGE FAULT CONDITION
	SWEEP=34	;SET SWEEP
	PXCT OFF=36	;TURN OFF THE EFFECT OF PXCT
	INHCRY18=40	;INHIBIT CARRY INTO LEFT HALF
	LOADIR=41	;LOAD THE IR
	LDPI=43		;LOAD PI SYSTEM
	ASHOV=44	;TEST RESULT OF ASH
	EXPTST=45	;TEST RESULT OF FLOATING POINT
	FLAGS=46	;CHANGE PC FLAGS
	LDACBLK=47	;LOAD AC BLOCK NUMBERS
	LDINST=61	;LOAD INSTRUCTION

;THE SPEC FIELD IS REDEFINED WHEN USED FOR BYTE MODE STUFF
BYTE/=<54:56>         	;DPM1 (SPEC SEL)
	BYTE1=1
	BYTE2=2
	BYTE3=3
	BYTE4=4
	BYTE5=5

;THE SPEC FIELD IS REDEFINED WHEN USED TO CONTROL SHIFT PATHS
SHSTYLE/=<54:56>      	;DPE1 (SPEC SEL)
	NORM=0		;2 40-BIT REGISTERS
	ZERO=1		;SHIFT ZERO INTO 36 BITS (ASH TOP 2901)
	ONES=2		;SHIFT IN ONES
	ROT=3		;ROTATE
	ASHC=4		;ASHC
	LSHC=5		;LSHC
	DIV=6		;SPECIAL DIVIDE
	ROTC=7		;ROTATE DOUBLE

.TOC	"MICROCODE FIELDS -- DISPATCH"
;	!=======================================================!
;	! D !      CRA1      !      CRA1      !      DPEA       !
;	! I !      DISP      !      DISP      !      DISP       !
;	! S !       10       !       20       !       40        !
;	! P !                !                !                 !
;	!=======================================================!
;	! 0 !    DIAG ADR    !    DIAG ADR    !        0        !
;	!-------------------------------------------------------!
;	! 1 !     RETURN     !     RETURN     !    DP 18-21     !
;	!-------------------------------------------------------!
;	! 2 !    MULTIPLY    !       J        !        J        !
;	!-------------------------------------------------------!
;	! 3 !   PAGE FAIL    !     AREAD     !     AREAD      !
;	!-------------------------------------------------------!
;	! 4 !     NICOND     !   NOT USABLE   !      NORM       !
;	!-------------------------------------------------------!
;	! 5 !      BYTE      !   NOT USABLE   !    DP 32-35     !
;	!-------------------------------------------------------!
;	! 6 !    EA MODE     !   NOT USABLE   !     DROM A      !
;	!-------------------------------------------------------!
;	! 7 !      SCAD      !   NOT USABLE   !     DROM B      !
;	!=======================================================!
;NOTE:	DISP EN 40 & DISP EN 10 ONLY CONTROL THE LOW 4 BITS OF THE
;	JUMP ADDRESS. DISP EN 20 ONLY CONTROLS THE HI 7 BITS. TO DO
;	SOMETHING TO ALL 11 BITS BOTH 20 & 40 OR 20 & 10 MUST BE ENABLED.

DISP/=<57:62>D,70     	;CRA1 & DPEA
	CONSOLE=00	;CONSOLE DISPATCH
	DROM=12		;DROM
	AREAD=13	;AREAD
	DP LEFT=31	;DP 18-21
	NORM=34		;NORMALIZE
	DP=35		;DP 32-35
	ADISP=36	;DROM A FIELD
	BDISP=37	;DROM B FIELD
	RETURN=41	;RETURN
	MUL=62		;MULTIPLY
	PAGE FAIL=63	;PAGE FAIL
	NICOND=64	;NEXT INSTRUCTION DISPATCH
	BYTE=65		;BYTE SIZE AND POSITION
	EAMODE=66	;EFFECTIVE ADDRESS MODE
	SCAD0=67	;J!2 IF SCAD BIT 0 = 1

.TOC	"MICROCODE FIELDS -- SKIP"
;	!=======================================================!
;	! S !      CRA2      !      DPEA      !      DPEA       !
;	! K !      SKIP      !      SKIP      !      SKIP       !
;	! I !       10       !       20       !       40        !
;	! P !                !                !                 !
;	!=======================================================!
;	! 0 !       0        !       0        !        0        !
;	!-------------------------------------------------------!
;	! 1 !   TRAP CYCLE   !     CRY 02     !    CARRY OUT    !
;	!-------------------------------------------------------!
;	! 2 !      AD=0      !    ADL SIGN    !      ADL=0      !
;	!-------------------------------------------------------!
;	! 3 !    SC SIGN     !    ADR SIGN    !      ADR=0      !
;	!-------------------------------------------------------!
;	! 4 !    EXECUTE     !    USER IOT    !      -USER      !
;	!-------------------------------------------------------!
;	! 5 !  -BUS IO BUSY  !   JFCL SKIP    !    FPD FLAG     !
;	!-------------------------------------------------------!
;	! 6 !   -CONTINUE    !     CRY 01     !  AC # IS ZERO   !
;	!-------------------------------------------------------!
;	! 7 !    -1 MSEC     !      TXXX      !  INTERRUPT REQ  !
;	!=======================================================!

SKIP/=<63:68>D,70     	;CRA2 & DPEA
	IOLGL=04	;(.NOT.USER)!(USER IOT)!(CONSOLE EXECUTE MODE)
	LLE=12		;AD LEFT .LE. 0
	CRY0=31		;AD CRY -2
	ADLEQ0=32	;ADDER LEFT = 0
	ADREQ0=33	;ADDER RIGHT = 0
	KERNEL=34	;.NOT. USER
	FPD=35		;FIRST PART DONE
	AC0=36		;AC NUMBER IS ZERO
	INT=37		;INTERRUPT REQUEST
	LE=42		;(AD SIGN)!(AD.EQ.0)
	CRY2=51		;AD CRY 02
	DP0=52		;AD SIGN
	DP18=53		;AD BIT 18
	IOT=54		;USER IOT
	JFCL=55		;JFCL SKIP
	CRY1=56		;AD CRY 1
	TXXX=57		;TEST INSTRUCTION SHOULD SKIP
	TRAP CYCLE=61	;THIS INSTRUCTION IS THE RESULT OF A
			; TRAP 1, 2, OR 3
	ADEQ0=62	;AD.EQ.0
	SC=63		;SC SIGN BIT
	EXECUTE=64	;CONSOLE EXECUTE MODE
	-IO BUSY=65	;.NOT. I/O LATCH
	-CONTINUE=66	;.NOT. CONTINUE
	-1 MS=67	;.NOT. 1 MS. TIMER

.TOC	"MICROCODE FIELDS -- TIME CONTROL"

DT/=<109:111>D,0        ;**NOT STORED IN CRAM**
			;DEFAULT TIME FIELD (USED IN MACROS)
			; CAN BE OVERRIDDEN IN MACRO CALL
	2T=0
	3T=1
	4T=2
	5T=3


T/=<70:71>F,DT          ;CSL5 (E601)
			;CLOCK TICKS MINUS TWO REQUIRED TO
			; DO A MICRO INSTRUCTION
	2T=0		;TWO TICKS
	3T=1		;THREE TICKS
	4T=2		;FOUR TICKS
	5T=3		;FIVE TICKS


.TOC	"MICROCODE FIELDS -- RANDOM CONTROL BITS"

CRY38/=<72>             ;DPE5
			;INJECT A CARRY INTO THE 2901 ADDER
LOADSC/=<73>            ;DPM4
			;LOAD THE STEP COUNTER FROM THE SCAD
LOADFE/=<74>            ;DPM4
			;LOAD THE FE REGISTER FROM THE SCAD
FMWRITE/=<75>           ;DPE5 (E302)
			;WRITE THE RAM FILE.
MEM/=<76>               ;DPM5 (E612) & DPE5 (E205)
			;START (OR COMPLETE) A MEMORY OR I/O CYCLE UNDER
			; CONTROL OF THE NUMBER FIELD.
DIVIDE/=<77>            ;DPE5
			;THIS MICROINSTRUCTION IS DOING A DIVIDE
MULTI PREC/=<78>        ;DPE5
			;MULTIPRECISION STEP IN DIVIDE, DFAD, DFSB
MULTI SHIFT/=<79>       ;CSL5 (HAS NOTHING TO DO WITH DPE5 MULTI SHIFT)
			;FAST SHIFT
CALL/=<80>              ;CRA2 (STACK IS ON CRA3)
			;THIS IS A CALL

.TOC	"MICROCODE FIELDS -- NUMBER FIELD"

;HERE IS THE GENERAL FIELD
#/=<90:107>           	;MANY PLACES

;# REDEFINED WHEN USED AS SCAD CONTROL:
SCAD/=<90:92>         	;DPM3
	A*2=0
	A.OR.B=1
	A-B-1=2
	A-B=3
	A+B=4
	A.AND.B=5
	A-1=6
	A=7
SCADA/=<93:95>        	;DPM3
	SC=0
	S#=1
	PTR44=2	;44 AND BIT 6 (SEE DPM3)
	BYTE1=3
	BYTE2=4
	BYTE3=5
	BYTE4=6
	BYTE5=7
SCADB/=<96:97>        	;DPM3
	FE=0
	EXP=1
	SHIFT=2
	SIZE=3
S#/=<98:107>          	;DPM3

;# REDEFINED WHEN USED AS STATE REGISTER CONTROL:
STATE/=<90:107>         ;NOT USED BY HARDWARE
	SIMPLE=0	;SIMPLE INSTRUCTIONS
	BLT=1		;BLT IN PROGRESS
.IFNOT/ITS
	MAP=400002	;MAP IN PROGRESS
.ENDIF/ITS
	SRC=3		;MOVE STRING SOURCE IN PROGRESS
	DST=4		;MOVE STRING FILL IN PROGRESS
	SRC+DST=5	;MOVE STRING DEST IN PROGRESS
	DSTF=6		;FILLING DEST
	CVTDB=7		;CONVERT DEC TO BIN
	COMP-DST=10	;COMPARE DEST
	EDIT-SRC=11	;EDIT SOURCE
	EDIT-DST=12	;EDIT DEST
	EDIT-S+D=13	;BOTH SRC AND DST POINTERS

.IF/1PROC
;# AS PC FLAGS
OIPBIT/=<98>		;BIT 8 OF PC IS ONE-PROCEED ON KS (NOT IN HARDWARE)
.ENDIF/1PROC

;# REDEFINED WHEN USED AS WORSPACE ADDRESS

WORK/=<98:107>        	;DPE6
	BADW0=160	;AC BLK 7 WORD 0 (BAD DATA FROM MEMORY)
.IFNOT/ITS
	BADW1=161	;AC BLK 7 WORD 1 (BAD DATA FROM MEMORY)
.ENDIF/ITS
	MUL=200		;TEMP FOR MULTIPLY
	DIV=201		;TEMP FOR DIVIDE
	SV.VMA=210	;SAVE VMA
	SV.AR=211	;SAVE AR
	SV.ARX=212	;SAVE ARX
	SV.BR=213	;SAVE BR
	SV.BRX=214	;SAVE BRX
.IF/ITS
	DBR1=215	;Pointer to page table for user low addresses.
	DBR2=216	;Pointer to page table for user high addresses.
	DBR3=217	;Pointer to page table for exec high addresses.
	DBR4=220	;Pointer to page table for exec low addresses.
.IFNOT/ITS
	SBR=215		;SPT BASE REGISTER
	CBR=216		;CST BASE ADDRESS
	CSTM=217	;CST MASK
	PUR=220		;PROCESS USE REGISTER
.ENDIF/ITS
	ADJP=221	;"P" FOR ADJBP
	ADJS=222	;"S" FOR ADJBP
	ADJPTR=223	;BYTE POINTER FOR ADJBP
	ADJQ1=224	;TEMP FOR ADJBP
	ADJR2=225	;TEMP FOR ADJBP
	ADJBPW=226	;(BYTES/WORD) FOR ADJBP
	HSBADR=227	;ADDRESS OF HALT STATUS BLOCK
	APR=230		;APR ENABLES
			; 2.5 - 2.4 Both set if paging enabled.
			; 2.3 - 1.5 Flags enabled
			; 1.3 - 1.1 PI level
			;More APR status is kept in APR FLAGS hardware:
			; 2.3 - 1.5 Flags set
			; 1.4 Some flag is interrupting
.IF/JPC
	U.JPC=231	;User mode JPC
	E.JPC=232	;Exec mode JPC
.ENDIF/JPC
.IF/PCST
	PCST=233	;AOBJN pointer to PC Sample Table
.ENDIF/PCST

;THE FOLLOWING WORDS ARE USED BY EXTEND INSTRUCTION
	E0=240		;ORIGINAL EFFECTIVE ADDRESS
	E1=241		;EFFECTIVE ADDRESS OF WORD AT E0
	SLEN=242	;SOURCE LENGTH
	MSK=243		;BYTE MASK
	FILL=244	;FILL BYTE
	CMS=245		;SRC BYTE IN STRING COMPARE
	FSIG=246	;PLACE TO SAVE ARX WHILE STORING
			; THE FLOAT CHAR
	BDH=247		;BINARY BEING CONVERTED TO
	BDL=250		; DECIMAL

;TIMER STUFF
	TIME0=300	;HIGH ORDER 36 BITS OF TIME
	TIME1=301	;LOW ORDER 36 BITS OF TIME
	PERIOD=302	;INTERRUPT PERIOD
	TTG=303		;TIME TO GO TO NEXT INTERRUPT
.IF/ITS
	QUAN=304	;Quantum counter incremented by TOCK except
			;when PI in progress.
.ENDIF/ITS

;DDIV STUFF
	AC0=314
	AC1=315
	AC2=316
	AC3=317
	DDIV SGN=320
	DVSOR H=321
	DVSOR L=322
;POWERS OF TEN
	DECLO=344	;LOW WORD
	DECHI=373	;HIGH WORD

	YSAVE=422	;Y OF LAST INDIRECT POINTER
.IFNOT/ITS
	PTA.E=423	;ADDRESS OF EXEC PAGE MAP (NOT PROCESS TABLE)
	PTA.U=424	;ADDRESS OF USER PAGE MAP
.ENDIF/ITS
	TRAPPC=425	;SAVED PC FROM TRAP CYCLE
	SV.AR1=426	;ANOTHER PLACE TO SAVE AR

;# REDEFINED WHEN USED AS PC FLAG CONTROL (ALL ON DPE9)

SETOV/=<90>             ;DPE9
			;SET ARITHMETIC OVERFLOW
SETFOV/=<91>            ;SET FLOATING OVERFLOW
SETNDV/=<92>            ;SET NO DIVIDE

;---------------------------------------------------------------------

CLRFPD/=<93>            ;CLEAR FIRST PART DONE
SETFPD/=<94>            ;SET FIRST PART DONE
HOLD USER/=<95>         ;WHEN THIS BIT IS SET IT:
			; 1. PREVENTS SETTING USER IOT IN USER MODE
			; 2. PREVENTS CLEARING USER IN USER MODE

;---------------------------------------------------------------------

;	<96>		;SPARE
TRAP2/=<97>             ;SET TRAP 2
TRAP1/=<98>             ;SET TRAP 1

;---------------------------------------------------------------------

LD PCU/=<99>            ;LOAD PCU FROM USER
;	<100>		;SPARE
;	<101>		;SPARE

;---------------------------------------------------------------------

;	<102>		;SPARE
;	<103>		;SPARE
JFCLFLG/=<104>          ;DO A JFCL INSTRUCTION

;---------------------------------------------------------------------

LD FLAGS/=<105>         ;LOAD FLAGS FROM DP
;	<106>
ADFLGS/=<107>           ;UPDATE CARRY FLAGS

;# REDEFINED WHEN USED AS MEMORY CYCLE CONTROL

FORCE USER/=<90>        ;FORCE USER MODE REFERENCE
FORCE EXEC/=<91>        ;FORCE EXEC MODE REFERENCE
			; (DOES NOT WORK UNDER PXCT)
FETCH/=<92>             ;THIS IS AN INSTRUCTION FETCH

;---------------------------------------------------------------------

READ CYCLE/=<93>        ;SELECT A READ CYCLE
WRITE TEST/=<94>        ;PAGE FAILE IF NOT WRITTEN
WRITE CYCLE/=<95>       ;SELECT A MEMORY WRITE CYCLE

;---------------------------------------------------------------------

;	<96>		;SPARE BIT
DONT CACHE/=<97>        ;DO NOT LOOK IN CACHE
PHYSICAL/=<98>          ;DO NOT INVOKE PAGING HARDWARE

;---------------------------------------------------------------------

PXCT/=<99:101>          ;WHICH PXCT BITS TO LOOK AT
	CURRENT=0
	E1=1
	D1=3
	BIS-SRC-EA=4
	E2=5
	BIS-DST-EA=6
	D2=7

;---------------------------------------------------------------------

AREAD/=<102>            ;LET DROM SELECT SYSLE TYPE AND VMA LOAD
DP FUNC/=<103>          ;IGNORE # BITS 0-11 AND USE DP 0-13 INSTEAD
			; DP9 MEANS "FORCE PREVIOUS"
LDVMA/=<104>            ;LOAD THE VMA

;---------------------------------------------------------------------

EXT ADR/=<105>          ;PUT VMA BITS 14-17 ONTO BUS
WAIT/=<106>             ;START A MEMORY OR I/O CYCLE
BWRITE/=<107>           ;START A MEMORY CYCLE IF DROM ASKS FOR IT

;THESE BITS ARE USED ONLY TO SETUP DP FOR A DP FUNCTION

;	<99>		;PREVIOUS
IO CYCLE/=<100>         ;THIS IS AN I/O CYCLE
WRU CYCLE/=<101>        ;WHO ARE YOU CYCLE

;---------------------------------------------------------------------

VECTOR CYCLE/=<102>     ;READ INTERRUPT VECTOR
IO BYTE/=<103>          ;BYTE CYCLE
;	<104>

;# REDEFINED WHEN USED AS PI RIGHT BITS
PI.ZER/=<90:92>         ;ZEROS
PI.IP1/=<93>            ;PI 1 IN PROG
PI.IP2/=<94>
PI.IP3/=<95>
PI.IP4/=<96>
PI.IP5/=<97>
PI.IP6/=<98>
PI.IP7/=<99>
PI.ON/=<100>            ;SYSTEM IS ON
PI.CO1/=<101>           ;CHAN 1 IS ON
PI.CO2/=<102>
I.CO3/=<103>
I.CO4/=<104>
I.CO5/=<105>
I.CO6/=<106>
I.CO7/=<107>

;# REDEFINED WHEN USED AS WRPI DATA
PI.MBZ/=<90:93>         ;MUST BE ZERO
PI.DIR/=<94>            ;DROP INTERRUPT REQUESTS
PI.CLR/=<95>            ;CLEAR SYSTEM
PI.REQ/=<96>            ;REQUEST INTERRUPT
PI.TCN/=<97>            ;TURN CHANNEL ON
PI.TCF/=<98>            ;TURN CHANNEL OFF
PI.TSF/=<99>            ;TURN SYSTEM OFF
PI.TSN/=<100>           ;TURN SYSTEM ON
PI.SC1/=<101>           ;SELECT CHANNEL 1
PI.SC2/=<102>
PI.SC3/=<103>
PI.SC4/=<104>
PI.SC5/=<105>
PI.SC6/=<106>
PI.SC7/=<107>

;# REDEFINED WHEN USED AS AC CONTROL


;THIS FIELD CONTROLS THE INPUT TO A 74LS181 ON DPE6. THE NUMBER
; FIELD HAS THIS FORMAT IN <98:107>:
;
;	!-----!-----!-----!-----!-----!-----!-----!-----!-----!-----!
;	!CARRY! S8  !  S4 ! S2  !  S1 ! MODE! B8  ! B4  !  B2 ! B1  !
;	!  IN !       FUNCTION        !     !      DATA INPUTS      !
;	!-----!-----------------------!-----!-----------------------!
;

ACALU/=<98:103>       	
	B=25
	AC+N=62
ACN/=<104:107>
			;AC NAMES FOR STRING INSTRUCTIONS
	SRCLEN=0	;SOURCE LENGTH
	SRCP=1		;SOURCE POINTER
	DLEN=3		;DEST LENGTH
	DSTP=4		;DEST POINTER
	MARK=3		;POINTER TO MARK
	BIN0=3		;HIGH WORD OF BINARY
	BIN1=4		;LOW WORD OF BINARY


;# FIELD REDEFINED WHEN USE AS APRID DATA

MICROCODE OPTIONS/=<90:98>
.IF/ITS
	OPT=020			;4.5 Indicates ITS ucode, just like on KL.
.IFNOT/ITS
	OPT=000
.ENDIF/ITS

;Actually defined in configuration file:
;
; MICROCODE VERSION/=<99:107>
;	UCV=259.
;
; HARDWARE OPTIONS/=<90:92>
;	HWOPT=0
;
; HARDWARE SERIAL NUMBER/=<93:107>
;	HWSER=4097.

;# FIELD REDEFINED WHEN USED AS A HALT CODE

HALT/=<90:107>
			;CODES 0 TO 77 ARE "NORMAL" HALTS
	POWER=0		;POWER UP
	HALT=1		;HALT INSTRUCTION
	CSL=2		;CONSOLE HALT
			;CODES 100 TO 777 ARE SOFTWARE ERRORS
	IOPF=100	;I/O PAGE FAIL
	ILLII=101	;ILLEGAL INTERRUPT INSTRUCTION
	ILLINT=102	;BAD POINTER TO UNIBUS INTERRUPT VECTOR
			;CODES 1000 TO 1777 ARE HARDWARE ERRORS
	BW14=1000	;ILLEGAL BWRITE FUNCTION (BAD DROM)
	NICOND 5=1004	;ILLEGAL NICOND DISPATCH
	MULERR=1005	;VALUE COMPUTED FOR 10**21 WAS WRONG
.IFNOT/FULL
	PAGEF=1777	;PAGE FAIL IN SMALL MICROCODE
.ENDIF/FULL



;# FIELD REDEFINED WHEN USED AS FLG BITS

FLG.W/=<94>             ;W BIT FROM PAGE MAP
FLG.PI/=<95>            ;PI CYCLE
FLG.C/=<96>             ;CACHE BIT FROM PAGE MAP
FLG.SN/=<97>		;SPECIAL NEGATE IN FDV & DFDV
.IF/1PROC
FLG.1PROC/=<98>		;1-PROCEED IN PROGRESS
FLG.2PROC/=<100>	;INSTRUCTION ACTUALLY RUNNING IF THIS IS SET TOO
;<99> RESERVED FOR JPC MODE
.ENDIF/1PROC

;RIGHT HALF OF FLG USED TO RECOVER FROM PAGE FAILS

.TOC	"SUBFIELD DEFINITIONS FOR .RAMFILE"

SPEC HIGH/=<51:53>
SPEC LOW/=<54:56>

DISP HIGH/=<57:59>
DISP LOW/=<60:62>

SKIP HIGH/=<63:65>
SKIP LOW/=<66:68>

# HIGH/=<90:95>
# LOW/=<96:107>

.TOC	"DISPATCH ROM DEFINITIONS"

;ALL ON DPEA

	.DCODE
A/=<2:5>                ;OPERAND FETCH MODE
	READ=0		;READ
	WRITE=1		;WRITE
	DREAD=2		;DOUBLE READ
	DBLAC=3		;DOUBLE AC
	SHIFT=4		;SIMPLE SHIFT
	DSHIFT=5	;DOUBLE SHIFT
	FPI=6		;FLOATING POINT IMMEDIATE
	FP=7		;FLOATING POINT
	RD-PF=10	;READ, THEN START PREFETCH
	DFP=11		;DOUBLE FLOATING POINT
	IOT=12		;CHECK FOR IO LEGAL THEN SAME AS I

B/=<8:11>               ;STORE RESULTS AS
	SELF=4		;SELF
	DBLAC=5		;DOUBLE AC
	DBLB=6		;DOUBLE BOTH
	AC=15		;AC
	MEM=16		;MEMORY
	BOTH=17		;BOTH

;B-FIELD WHEN USED IN FLOATING POINT OPERATIONS
ROUND/=<8>              ;ROUND THE RESULT
MODE/=<9>               ;SEPARATE ADD/SUB & MUL/DIV ETC.
FL-B/=<10:11>           ;STORE RESULTS AS
	AC=1		;AC
	MEM=2		;MEMORY
	BOTH=3		;BOTH

J/=<12:23>              ;DISPATCH ADDRESS (MUST BE 1400 TO 1777)

ACDISP/=<24>            ;DISPATCH ON AC FIELD
I/=<25>                 ;IMMEDIATE DISPATCH. DISP/AREAD DOES A DISP/DROM
			; IF THIS BIT IS SET.
READ/=<26>              ;START A READ AT AREAD
TEST/=<27>              ;START A WRITE TEST  AT AREAD
COND FUNC/=<28>       	;START A MEMORY CYCLE ON BWRITE
VMA/=<29>D,1            ;LOAD THE VMA ON AREAD
WRITE/=<30>           	;START A WRITE ON AREAD
	.UCODE

.TOC	"HOW TO READ MACROS"
;		
;		1.0  REGISTER TRANSFER MACROS
;		
;		MOST MACROS USED IN THE KS10 ARE USED TO OPERATE ON DATA IN  (OR  FROM/TO)  2901
;		REGISTERS.   THE  NAMES  OF  THE  2901  REGISTERS  ARE  MACRO PARAMETERS AND ARE
;		ENCLOSED IN [].  A TYPICAL MACRO IS:
;		
;		        [AR]_[AR]+[BR]
;		
;		THE SYMBOL _ IS PRONOUNCED "GETS".  THE ABOVE MACRO WOULD BE READ "THE  AR  GETS
;		THE AR PLUS THE BR".
;		
;		IF A MACRO DOES NOT HAVE A _ IN IT, THERE IS NO RESULT STORED.  THUS,  [AR]-[BR]
;		JUST COMPARES THE AR AND THE BR AND ALLOWS FOR SKIPS ON THE VARIOUS ALU BITS.
;		
;		
;		
;		1.1  SPECIAL SYMBOLS
;		
;		THERE ARE A BUNCH OF SYMBOLS USED IN THE MACROS WHICH ARE  NOT  2901  REGISTERS.
;		THEY ARE DEFINED HERE:
;		
;		     1.  AC -- THE AC SELECTED BY THE CURRENT INSTRUCTION.  SEE DPEA
;		
;		     2.  AC[] -- AC+N.  AC[1] IS AC+1, AC[2] IS AC+2, ETC.
;		
;		     3.  APR -- THE APR FLAGS FROM DPMA
;		
;		     4.  EA -- THE EFFECTIVE ADDRESS.  THAT IS, 0  IN  THE  LEFT  HALF  AND  THE
;		         CONTENTS OF THE HR IN THE RIGHT HALF.
;		
;		     5.  EXP -- THE F.P.  EXPONENT  FROM  THE  SCAD.   [AR]_EXP  WILL  TAKE  THE
;		         EXPONENT OUT OF THE FE AND PUT IT BACK INTO THE NUMBER IN THE AR.
;		
;		     6.  FE -- THE FE REGISTER
;		
;		     7.  FLAGS -- THE PC FLAGS (FROM DPE9) IN THE LEFT HALF.
;		
;		     8.  Q -- THE Q REGISTER
;		
;		     9.  RAM -- THE RAM FILE, RAM ADDRESS IS IN THE VMA.
;		
;		    10.  P -- THE P FIELD OF THE BYTE POINTER.  SAME IDEA AS EXP.
;		
;		    11.  TIME -- THE 1MS.  TIMER
;		
;		    12.  VMA -- THE VMA.  WHEN READ IT INCLUDES THE VMA FLAGS
;		
;		    13.  XR -- INDEX REGISTER

;		    14.  XWD -- HALF WORD.  USED TO GENERATE CONSTANTS.  FOR EXAMPLE, [AR]_0 XWD
;		         [40] WOULD LOAD THE CONSTANT 40 (OCTAL) INTO THE AR.
;		
;		    15.  +SIGN AND -SIGN -- SIGN BITS USED TO SIGN  SMEAR  F.P.   NUMBERS.   FOR
;		         EXAMPLE, [AR]_+SIGN WOULD CLEAR AR BITS 0 TO 8.
;		
;		    16.  WORK[] -- LOCATIONS IN  THE  WORKSPACE  USED  AS  SCRATCH  SPACE.   FOR
;		         EXAMPLE,  [AR]_WORK[CSTM]  WOULD LOAD THE AR WITH THE CST MASK FROM THE
;		         RAM.  CSTM IS A SYMBOL DEFINED IN THE WORK FIELD.
;		
;		
;		
;		
;		1.2  LONG
;		
;		LONG IS USED ON SHIFT OPERATIONS  TO  INDICATE  THAT  THE  Q  REGISTER  IS  ALSO
;		SHIFTED.  THIS SAYS NOTHING ABOUT HOW THE SHIFT PATHS ARE CONNECTED UP.
;		
;		
;		
;		2.0  MEMORY MACROS
;		
;		MEMORY IS INDICATED BY THE SYMBOL "MEM".  WHEN WE  ARE  WAITING  FOR  DATA  FROM
;		MEMORY  THE  "MEM  READ" MACRO IS USED.  WHEN WE ARE SENDING DATA TO MEMORY, THE
;		"MEM WRITE" MACRO IS USED.  EXAMPLE,
;		        MEM READ,               ;WAIT FOR MEMORY
;		        [AR]_MEM                ;LOAD DATA INTO AR
;		VMA_ IS USED THE LOAD THE VMA.  THUS, VMA_[PC] LOADS THE VMA FROM THE PC.
;		
;		
;		
;		3.0  TIME CONTROL
;		
;		THERE ARE 2 SETS OF MACROS USED FOR TIME CONTROL.  THE FIRST,  SELECTS  THE  RAM
;		ADDRESS  TO  SPEED UP THE NEXT INSTRUCTION.  THESE MACROS ARE AC, AC[], XR, VMA,
;		WORK[].  THE SECOND, SETS THE TIME FIELD.  THESE ARE  2T,  3T,  4T,  AND  5T  TO
;		SELECT 2, 3, 4, OR 5 TICKS.
;		
;		
;		
;		4.0  SCAD MACROS
;		
;		THE SCAD MACROS LOOK LIKE THE 2901 MACROS EXECPT NO [] ARE REQUIRED.  THERE  ARE
;		ONLY A FEW SYMBOLS USED.
;		
;		     1.  FE -- THE FE REGISTER
;		
;		     2.  SC -- THE SC REGISTER

;		     3.  EXP -- THE EXPONENT FROM A F.P.  NUMBER.  FOR EXAMPLE FE_EXP LOADS  THE
;		         FE FROM DP BITS 1-8.
;		
;		     4.  SHIFT -- THE SHIFT COUNT FROM SHIFT INSTRUCTIONS.  THAT IS DP  BITS  18
;		         AND 28-35.
;		
;		     5.  S# -- THE SMALL NUMBER.  THE 10 BIT MAGIC NUMBER  INPUT  TO  THE  SCADA
;		         MIXER.
;		
;		
;		
;		
;		5.0  CONTROL MACROS
;		
;		ALL CONTROL MACROS LOOK LIKE ENGLISH COMMANDS.  SOME EXAMPLES,
;		        HOLD LEFT               ;DO NOT CLOCK LEFT HALF OF DP
;		        SET APR ENABLES         ;LOAD APR ENABLES FROM DP
;		        SET NO DIVIDE           ;SET NO DIVIDE PC FLAG
;		
;		
;		
;		6.0  SKIPS
;		
;		ALL SKIPS CAUSE THE NEXT MICRO INSTRUCTION TO COME  FROM  THE  ODD  WORD  OF  AN
;		EVEN/ODD PAIR.  THE MACROS HAVE THE FORMAT OF SKIP COND.  THEY SKIP IF CONDITION
;		IS TRUE.  SOME EXAMPLES,
;		        SKIP AD.EQ.0            ;SKIP IF ADDER OUTPUT IS ZERO
;		        SKIP IRPT               ;SKIP IF INTERRUPT IS PENDING
;		
;		
;		
;		7.0  DISPATCH MACROS
;		
;		DISPATCH MACROS CAUSE THE MACHINE TO GO TO ONE OF MANY PLACES.   IN  MOST  CASES
;		THEY HAVE THE WORD "DISP" IN THE NAME OF THE MACRO.  FOR EXAMPLE, MUL DISP, BYTE
;		DISP.
;		
;		
;		
;		8.0  SUPER MACROS
;		
;		THERE ARE PLACES WHERE ONE MICRO  INSTRUCTION  IS  USED  IN  MANY  PLACES.   FOR
;		EXAMPLE,  MANY  PLACES  DETECT ILLEGAL OPERATIONS AND WANT TO GENERATE A TRAP TO
;		THE MONITOR.  WE COULD WRITE
;		        J/UUO
;		BUT THIS WASTES A MICRO STEP DOING A USELESS JUMP.  INSTEAD WE WRITE,
;		        UUO
;		THIS MACRO IS THE FIRST STEP  OF  THE  UUO  ROUTINE  AND  JUMPS  TO  THE  SECOND
;		INSTRUCTION.   WE  WRITE THE EXPANSION OF THE UUO MACRO AS THE FIRST INSTRUCTION
;		OF THE UUO ROUTINE SO THAT THE READER CAN SEE WHAT IT DOES.   SOME  EXAMPLES  OF

;		SUPER MACROS ARE:
;		        PAGE FAIL TRAP          ;GENERATE A PAGE FAIL TRAP
;		        DONE                    ;THIS INSTRUCTION IS NOW COMPLETE
;		                                ; USED WITH A SKIP OR DISP WHERE
;		                                ; SOME PATHS ARE NOP'S
;		        HALT []                 ;JUMP TO HALT LOOP. ARGUMENT IS A
;		                                ; CODE

.TOC	"MACROS -- DATA PATH CHIP -- GENERAL"

.NOT.[] 	"AD/.NOT.A,A/@1"
[]+[]		"AD/A+B,A/@1,B/@2"
[]-[]		"AD/A-B-.25,A/@1,B/@2,ADD .25"
[]-#		"AD/A-D-.25,DBUS/DBM,DBM/#,A/@1,ADD .25"
[].AND.#	"AD/D.AND.A,DBUS/DBM,DBM/#,A/@1"
[].AND.Q	"AD/A.AND.Q,A/@1,DEST/PASS"
[].AND.[]	"AD/A.AND.B,A/@2,B/@1,DEST/PASS"
[].AND.NOT.[]	"AD/.NOT.A.AND.B,A/@2,B/@1,DEST/PASS"
[].OR.[]	"AD/A.OR.B,A/@2,B/@1,DEST/PASS"
[].XOR.#	"AD/D.XOR.A,DBUS/DBM,DBM/#,A/@1"
[].XOR.VMA	"AD/D.XOR.A,DBUS/DBM,DBM/VMA,A/@1"
[].XOR.[]	"AD/A.XOR.B,A/@2,B/@1,DEST/PASS"
[]_#-[]		"AD/D-A-.25,DEST/AD,A/@2,B/@1,DBUS/DBM,DBM/#,ADD .25"
[]_#		"AD/D,DBUS/DBM,DBM/#,DEST/AD,B/@1"
[]_-1		"AD/-A-.25,A/ONE,DEST/AD,B/@1,ADD .25"
[]_-2		"AD/-A-.25,DEST/AD*2,A/ONE,B/@1,ADD .25"
[]_-Q		"AD/-Q-.25,DEST/AD,B/@1,ADD .25"
[]_-Q*2		"AD/-Q-.25,DEST/AD*2,B/@1,ADD .25"
[]_-Q*.5	"AD/-Q-.25,DEST/AD*.5,B/@1,ADD .25"
[]_-[]		"AD/-A-.25,A/@2,DEST/AD,B/@1,ADD .25"
[]_-[]-.25	"AD/-A-.25,A/@2,DEST/AD,B/@1"
[]_-[]*2	"AD/-A-.25,A/@2,DEST/AD*2,B/@1,ADD .25"
[]_.NOT.AC	"AD/.NOT.D,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1"
[]_.NOT.AC[]	"AD/.NOT.D,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@2,DEST/AD,B/@1,DT/3T"
[]_.NOT.Q	"AD/.NOT.Q,DEST/AD,B/@1"
[]_.NOT.[]	"AD/.NOT.A,A/@2,DEST/AD,B/@1"
[]_0		"AD/ZERO,DEST/AD,B/@1"
[]_0*.5 LONG	"AD/ZERO,DEST/Q_Q*.5,B/@1"
[]_0 XWD []	"AD/47,DEST/AD,B/@1,DBM/#,DBUS/DBM,#/@2,RSRC/DA,A/MASK"
[]_AC		"AD/D,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1,AD PARITY"
[]_-AC		"AD/-D-.25,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1,ADD .25"
[]_-AC[]	"AD/-D-.25,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@2,DEST/AD,B/@1,ADD .25,DT/3T"
[]_AC*.5	"AD/D,DBUS/RAM,RAMADR/AC#,DEST/AD*.5,B/@1,DT/3T"
[]_AC*.5 LONG	"AD/D,DBUS/RAM,RAMADR/AC#,DEST/Q_Q*.5,B/@1,DT/3T"
[]_AC*2 	"AD/D,DBUS/RAM,RAMADR/AC#,DEST/AD*2,B/@1,DT/3T"
[]_AC+1 	"AD/D+A,DBUS/RAM,RAMADR/AC#,A/ONE,DEST/AD,B/@1"
[]_AC+1000001	"AD/D+A,DBUS/RAM,RAMADR/AC#,A/XWD1,DEST/AD,B/@1"
[]_AC+[]	"AD/D+A,A/@2,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1,DT/3T"
[]_AC-1 	"AD/D-A-.25,DBUS/RAM,RAMADR/AC#,A/ONE,DEST/AD,B/@1,ADD .25"
[]_AC-[]	"AD/D-A-.25,A/@2,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1,ADD .25"
[]_AC-[]-.25	"AD/D-A-.25,A/@2,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1"
[]_AC[]-[]	"AD/D-A-.25,A/@3,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@2,DEST/AD,B/@1,ADD .25,DT/3T"
[]_AC[]-1	"AD/D-A-.25,A/ONE,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@2,DEST/AD,B/@1,ADD .25,DT/3T"
[]_AC[].AND.[]	"AD/D.AND.A,A/@3,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@2,DEST/AD,B/@1,DT/3T"
[]_AC.AND.MASK	"AD/D.AND.A,A/MASK,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1,AD PARITY"
[]_AC[]		"AD/D,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@2,DEST/AD,B/@1,AD PARITY,DT/3T"
[]_AC[]*2	"AD/D,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@2,DEST/AD*2,B/@1,AD PARITY,DT/3T"
[]_AC[]*.5	"AD/D,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@2,DEST/AD*.5,B/@1,AD PARITY,DT/3T"
[]_APR		"AD/D,DBUS/DBM,DBM/APR FLAGS,DEST/AD,B/@1,DT/3T"
[]_CURRENT AC [] "AD/D,DBUS/RAM,RAMADR/#,ACALU/B,ACN/@2,DEST/AD,B/@1,AD PARITY,DT/3T"
[]_EA FROM []	"AD/57,RSRC/0A,A/@2,DEST/AD,B/@1"

[]_EA		"AD/57,RSRC/0A,A/HR,DEST/AD,B/@1"
[]_EXP		"AD/D,DBUS/DBM,DBM/EXP,A/@1,B/@1,DEST/A,SCAD/A+B,SCADA/S#,S#/0,SCADB/FE,HOLD RIGHT,EXP TEST"
[]_FE		"AD/D,DEST/AD*.5,B/@1,DBUS/DBM,DBM/DP,SCAD/A+B,SCADA/S#,S#/0,SCADB/FE,BYTE/BYTE5"
[]_FLAGS	"AD/D.AND.A,DBUS/PC FLAGS,A/MASK,DEST/AD,B/@1,RSRC/0Q"
[]_P		"AD/D,DEST/A,A/@1,B/@1,DBUS/DBM,DBM/DP,BYTE/BYTE1,SCAD/A+B,SCADA/S#,S#/0,SCADB/FE"
[]_PC WITH FLAGS "AD/D,DBUS/PC FLAGS,RSRC/0A,A/PC,DEST/AD,B/@1"
[]_Q		"AD/Q,DEST/AD,B/@1"
[]_Q*.5		"AD/Q,DEST/AD*.5,B/@1"
[]_Q*2		"AD/Q,DEST/AD*2,B/@1"
[]_Q*2 LONG	"AD/Q,DEST/Q_Q*2,B/@1"
[]_Q+1		"AD/A+Q,A/ONE,DEST/AD,B/@1"
[]_RAM		"AD/D,DBUS/RAM,RAMADR/RAM,DEST/AD,B/@1,AD PARITY"
[]_TIME		"AD/44,RSRC/DA,A/MASK,DBUS/DBM,DBM/EXP,DEST/AD,B/@1"
[]_VMA		"AD/D,DEST/AD,B/@1,DBUS/DBM,DBM/VMA"
[]_XR		"AD/D,DBUS/RAM,RAMADR/XR#,DEST/AD,B/@1"
[]_[]		"AD/A,A/@2,DEST/AD,B/@1"
[]_[] SWAP	"AD/D,DBUS/DBM,DBM/DP SWAP,DEST/A,A/@2,B/@1"
[]_[] XWD 0	"AD/45,DEST/AD,B/@1,DBM/#,DBUS/DBM,#/@2,RSRC/D0,A/MASK"
[]_[]*.5	"AD/A,A/@2,DEST/AD*.5,B/@1"
[]_[]*.5 LONG	"AD/A,A/@2,DEST/Q_Q*.5,B/@1"
[]_[]*2 	"AD/A,A/@2,DEST/AD*2,B/@1"
[]_[]*2 LONG	"AD/A,A/@2,DEST/Q_Q*2,B/@1"
[]_[]*4 	"AD/A+B,A/@2,B/@1,DEST/AD*2"
[]_[]+# 	"AD/D+A,DBUS/DBM,DBM/#,A/@2,DEST/AD,B/@1"
[]_[]+.25	"AD/0+A,A/@2,DEST/AD,B/@1, ADD .25"
[]_[]+0		"AD/0+A,A/@2,DEST/AD,B/@1"
[]_[]+1 	"AD/A+B,A/ONE,B/@1,B/@2,DEST/AD"
[]_[]+1000001	"AD/D+A,A/@2,DBUS/DBM,DBM/#,#/1,DEST/AD,B/@1"
[]_[]+AC	"AD/D+A,A/@2,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1"
[]_[]+AC[]	"AD/D+A,A/@2,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@3,DEST/AD,B/@1,DT/3T"
[]_[]+Q		"AD/A+Q,A/@2,DEST/AD,B/@1"
[]_[]+RAM	"AD/D+A,A/@2,DBUS/RAM,RAMADR/RAM,DEST/AD,B/@1"
[]_[]+XR	"AD/D+A,DBUS/RAM,RAMADR/XR#,A/@2,DEST/AD,B/@1,HOLD LEFT"
[]_[]+[]	"AD/A+B,A/@3,B/@1,B/@2,DEST/AD"
[]_[]+[]+.25	"AD/A+B,A/@3,B/@1,B/@2,DEST/AD, ADD .25"
[]_[]-# 	"AD/A-D-.25,DBUS/DBM,DBM/#,A/@2,DEST/AD,B/@1, ADD .25"
[]_[]-1 	"AD/B-A-.25,B/@1,A/ONE,DEST/AD,ADD .25"
[]_[]-1000001	"AD/A-D-.25,A/@2,DBUS/DBM,DBM/#,#/1,DEST/AD,B/@1,ADD .25"
[]_[]-AC	"AD/A-D-.25,A/@2,DBUS/RAM,RAMADR/AC#,DEST/AD,B/@1,ADD .25"
[]_[]-RAM	"AD/A-D-.25,A/@2,DBUS/RAM,RAMADR/RAM,DEST/AD,B/@1,ADD .25"
[]_[]-[]	"AD/B-A-.25,B/@1,B/@2,A/@3,DEST/AD,ADD .25"
[]_[]-[] REV	"AD/A-B-.25,B/@1,B/@3,A/@2,DEST/AD,ADD .25"
[]_[].AND.#	"AD/D.AND.A,DBUS/DBM,DBM/#,DEST/AD,A/@2,B/@1"
[]_[].AND.# CLR LH "AD/ZERO,RSRC/DA,DBUS/DBM,DBM/#,DEST/AD,A/@2,B/@1"
[]_[].AND.# CLR RH "AD/D.AND.A,RSRC/0Q,DBUS/DBM,DBM/#,DEST/AD,A/@2,B/@1"
[]_(AC[].AND.[])*.5 "AD/D.AND.A,DEST/AD*.5,A/@3,B/@1,RAMADR/AC*#,DBUS/RAM,ACALU/AC+N,ACN/@2"
[]_(Q+1)*.5	"AD/A+Q,A/ONE,DEST/AD*.5,B/@1"
[]_(#-[])*2	"AD/D-A-.25,DEST/AD*2,A/@2,B/@1,DBUS/DBM,DBM/#,ADD .25"
[]_(-[])*.5	"AD/-A-.25,A/@2,DEST/AD*.5,B/@1,ADD .25"
[]_(-[]-.25)*.5 LONG "AD/-A-.25,A/@2,DEST/Q_Q*.5,B/@1"
[]_(-[]-.25)*2 LONG "AD/-A-.25,A/@2,DEST/Q_Q*2,B/@1"

[]_([].AND.#)*.5 "AD/D.AND.A,DBUS/DBM,DBM/#,DEST/AD*.5,A/@2,B/@1"
[]_([].AND.#)*2	"AD/D.AND.A,DBUS/DBM,DBM/#,DEST/AD*2,A/@2,B/@1"
[]_([].AND.NOT.#)*.5 "AD/.NOT.D.AND.A,DBUS/DBM,DBM/#,DEST/AD*.5,A/@2,B/@1"
[]_([].AND.NOT.#)*2	"AD/.NOT.D.AND.A,DBUS/DBM,DBM/#,DEST/AD*2,A/@2,B/@1"
[]_([].AND.[])*.5 "AD/A.AND.B,DEST/AD*.5,A/@3,B/@1,B/@2"
[]_([].AND.[])*2 "AD/A.AND.B,DEST/AD*2,A/@3,B/@1,B/@2"
[]_([].OR.#)*.5 "AD/D.OR.A,DBUS/DBM,DBM/#,DEST/AD*.5,A/@2,B/@1"
[]_([].OR.#)*2	"AD/D.OR.A,DBUS/DBM,DBM/#,DEST/AD*2,A/@2,B/@1"
[]_([]+#)*2	"AD/D+A,DBUS/DBM,DBM/#,DEST/AD*2,A/@2,B/@1"
[]_([]+1)*2 	"AD/A+B,A/ONE,B/@1,B/@2,DEST/AD*2"
[]_([]+[])*.5 LONG	"AD/A+B,A/@3,B/@1,B/@2,DEST/Q_Q*.5"
[]_([]+[])*2 LONG	"AD/A+B,A/@3,B/@1,B/@2,DEST/Q_Q*2"
[]_([]-[])*.5 LONG	"AD/B-A-.25,A/@3,B/@1,B/@2,DEST/Q_Q*.5, ADD .25"
[]_([]-[])*2 LONG	"AD/B-A-.25,A/@3,B/@1,B/@2,DEST/Q_Q*2, ADD .25"
[]_([]+[]+.25)*.5 LONG	"AD/A+B,A/@3,B/@1,B/@2,DEST/Q_Q*.5, ADD .25"
[]_[].AND.AC	"AD/D.AND.A,DBUS/RAM,RAMADR/AC#,A/@2,DEST/AD,B/@1"
[]_[].AND.NOT.# "AD/.NOT.D.AND.A,DBUS/DBM,DBM/#,A/@2,DEST/AD,B/@1"
[]_[].AND.NOT.[] "AD/.NOT.A.AND.B,DEST/AD,B/@1,B/@2,A/@3"
[]_[].AND.NOT.AC "AD/.NOT.D.AND.A,DBUS/RAM,RAMADR/AC#,A/@2,DEST/AD,B/@1"
[]_[].AND.Q	"AD/A.AND.Q,A/@2,DEST/AD,B/@1"
[]_[].AND.[]	"AD/A.AND.B,A/@3,B/@1,B/@2,DEST/AD"
[]_[].EQV.AC	"AD/D.EQV.A,DBUS/RAM,RAMADR/AC#,A/@2,DEST/AD,B/@1"
[]_[].EQV.Q	"AD/A.EQV.Q,A/@2,DEST/AD,B/@1"
[]_[].OR.#	"AD/D.OR.A,DBUS/DBM,DBM/#,A/@2,DEST/AD,B/@1"
[]_[].OR.AC	"AD/D.OR.A,DBUS/RAM,RAMADR/AC#,A/@2,DEST/AD,B/@1"
[]_[].OR.FLAGS	"AD/D.OR.A,DBUS/PC FLAGS,RSRC/0A,A/@1,DEST/AD,B/@1"
[]_[].OR.[]	"AD/A.OR.B,A/@3,B/@2,B/@1,DEST/AD"
[]_[].XOR.#	"AD/D.XOR.A,DBUS/DBM,DBM/#,DEST/AD,A/@2,B/@1"
[]_[].XOR.AC	"AD/D.XOR.A,DBUS/RAM,RAMADR/AC#,A/@1,DEST/AD,B/@2"
[]_[].XOR.[]	"AD/A.XOR.B,A/@3,B/@1,B/@2,DEST/AD"

[] LEFT_0	"AD/57,RSRC/0B,DEST/AD,B/@1"
[] RIGHT_0	"AD/53,RSRC/D0,DEST/AD,B/@1"
[] LEFT_-1	"AD/54,RSRC/0B,DEST/AD,A/MASK,B/@1"
[] RIGHT_-1	"AD/53,RSRC/0A,DEST/AD,A/MASK,B/@1"


[]_+SIGN	"[@1]_[@1].AND.#, #/777, HOLD RIGHT"
[]_-SIGN	"[@1]_[@1].OR.#, #/777000, HOLD RIGHT"
;THE FOLLOWING 2 MACROS ARE USED IN DOUBLE FLOATING STUFF
; THEY ASSUME THAT THE OPERAND HAS BEEN SHIFTED RIGHT 1 PLACE.
; THEY SHIFT 1 MORE PLACE
[]_+SIGN*.5	"AD/.NOT.D.AND.A,A/@1,B/@1,DEST/AD*.5,DBUS/DBM,DBM/#,#/777400,RSRC/0A"
[]_-SIGN*.5	"AD/D.OR.A,A/@1,B/@1,DEST/AD*.5,DBUS/DBM,DBM/#,#/777400,RSRC/0A"

.TOC	"MACROS -- DATA PATH CHIP -- Q"

Q-[]		"AD/Q-A-.25,A/@1,ADD .25"
Q.AND.NOT.[]	"AD/.NOT.A.AND.Q,A/@1,DEST/PASS"
Q_[]		"AD/A,DEST/Q_AD,A/@1"
Q_[]-[] 	"AD/A-B-.25,A/@1,B/@2,DEST/Q_AD,ADD .25"
Q_[]+[] 	"AD/A+B,A/@1,B/@2,DEST/Q_AD"
Q_[].AND.[]	"AD/A.AND.B,A/@1,B/@2,DEST/Q_AD"
Q_.NOT.AC[]	"AD/.NOT.D,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DEST/Q_AD,DT/3T"
Q_-[]		"AD/-A-.25,DEST/Q_AD,A/@1, ADD .25"
Q_-1		"Q_-[ONE]"
Q_-AC[]	"AD/-D-.25,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DEST/Q_AD,ADD .25,DT/3T"
Q_-Q		"AD/-Q-.25,ADD .25,DEST/Q_AD"
Q_AC		"AD/D,DBUS/RAM,RAMADR/AC#,DEST/Q_AD,CHK PARITY"
Q_AC[]		"AD/D,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DEST/Q_AD,CHK PARITY,DT/3T"
Q_AC[].AND.MASK	"AD/D.AND.A,A/MASK,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DEST/Q_AD,CHK PARITY,DT/3T"
Q_AC[].AND.[]	"AD/D.AND.A,A/@2,DBUS/RAM,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DEST/Q_AD,CHK PARITY,DT/3T"
Q_.NOT.Q		"AD/.NOT.Q,DEST/Q_AD"
Q_#		"AD/D,DBUS/DBM,DBM/#,DEST/Q_AD"
Q_0		"AD/ZERO,DEST/Q_AD"
Q_0 XWD []	"AD/47,DEST/Q_AD,DBM/#,DBUS/DBM,#/@1,RSRC/DA,A/MASK"
Q_Q+.25		"AD/0+Q,DEST/Q_AD,ADD .25"
Q_Q+1		"AD/A+Q,A/ONE,DEST/Q_AD"
Q_Q-1		"AD/Q-A-.25,A/ONE,DEST/Q_AD, ADD .25"
Q_Q+AC		"AD/D+Q,DBUS/RAM,RAMADR/AC#,DEST/Q_AD"
Q_Q*.5		"[MAG]_[MASK]*.5 LONG, SHSTYLE/NORM"
Q_Q*2		"[MASK]_[MAG]*2 LONG, SHSTYLE/NORM"
Q_Q.OR.#	"AD/D.OR.Q,DBUS/DBM,DBM/#,DEST/Q_AD"
Q_Q.AND.#	"AD/D.AND.Q,DBUS/DBM,DBM/#,DEST/Q_AD"
Q_Q.AND.[]	"AD/A.AND.Q,A/@1,DEST/Q_AD"
Q_Q.AND.NOT.[]	"AD/.NOT.A.AND.Q,A/@1,DEST/Q_AD"
Q_Q+[]		"AD/A+Q,A/@1,DEST/Q_AD"
Q_[].AND.Q	"AD/A.AND.Q,A/@1,DEST/Q_AD"
Q_[].OR.Q	"AD/A.OR.Q,A/@1,DEST/Q_AD"

.TOC	"MACROS -- DATA PATH CHIP -- MISC."

CLEAR []0	"AD/D.AND.A,A/@1,DBUS/DBM,DBM/#,#/377777,DEST/AD,B/@1,HOLD RIGHT"
CLEAR ARX0	"CLEAR [ARX]0"

;CYCLE CHIP REGISTERS THRU AD SO WE CAN TEST BITS
READ XR		"AD/D,DBUS/RAM,RAMADR/XR#"
READ [] 	"AD/B,B/@1"
READ Q		"AD/Q"

;TEST BITS IN REGISTERS (SKIP IF ZERO)
TR []		"AD/D.AND.A,DBUS/DBM,DBM/#,A/@1,SKIP ADR.EQ.0,DT/3T"
TL []		"AD/D.AND.A,DBUS/DBM,DBM/#,A/@1,SKIP ADL.EQ.0,DT/3T"


;CAUSE BITS -2 AND -1 TO MATCH BIT 0. 
FIX [] SIGN	"AD/D,DEST/A,A/@1,B/@1,DBUS/DP,HOLD RIGHT"

;GENERATE A MASK IN Q AND ZERO A 2901 REGISTER
GEN MSK []	"AD/ZERO,DEST/Q_Q*2,B/@1,ONES"

.TOC	"MACROS -- STORE IN AC"

FM WRITE	"FMWRITE/1"

AC[]_[] VIA AD	"AD/B,DEST/PASS,B/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE,CHK PARITY"
AC_[] VIA AD	"AD/B,DEST/PASS,B/@1,RAMADR/AC#,DBUS/DP,FM WRITE,CHK PARITY"
AC[]_[]		"AD/A,DEST/A,B/@2,A/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP, FM WRITE"
AC[]_[] TEST	"AD/D,DBUS/DP,DEST/A,B/@2,A/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP, FM WRITE"
AC[]_[]+1	"AD/A+B,DEST/PASS,A/ONE,B/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE"
AC[]_[]*2	"AD/A+B,DEST/PASS,A/@2,B/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE"
AC_[]		"AD/A,DEST/A,B/@1,A/@1,RAMADR/AC#,DBUS/DP, FM WRITE"
AC_[] TEST	"AD/D,DBUS/DP,DEST/A,B/@1,A/@1,RAMADR/AC#,DBUS/DP, FM WRITE"
AC_[]+1		"AD/A+B,DEST/PASS,A/ONE,B/@1,RAMADR/AC#, FM WRITE"
AC_[]+Q		"AD/A+Q,DEST/PASS,A/@1,B/@1,RAMADR/AC#, FM WRITE"
AC[]_[]+Q	"AD/A+Q,DEST/PASS,A/@2,B/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1, FM WRITE"
AC[]_[]-[]	"AD/A-B-.25,DEST/PASS,B/@3,A/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE,ADD .25"
AC[]_[]+[]	"AD/A+B,DEST/PASS,B/@3,A/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE"
AC_[]+[]	"AD/A+B,DEST/PASS,B/@2,A/@1,RAMADR/AC#,DBUS/DP,FM WRITE"
AC_[]-[]	"AD/A-B-.25,DEST/PASS,B/@2,A/@1,RAMADR/AC#,DBUS/DP,FM WRITE,ADD .25"
AC[]_[].AND.[]	"AD/A.AND.B,DEST/PASS,B/@3,A/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE"
AC[]_Q.AND.[]	"AD/A.AND.Q,DEST/PASS,A/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE"
AC[]_[].EQV.Q	"AD/A.EQV.Q,DEST/PASS,A/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE"
AC[]_-[]	"AD/-B-.25,DEST/PASS,B/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE,ADD .25"
AC_-[]		"AD/-A-.25,DEST/PASS,A/@1,RAMADR/AC#,DBUS/DP, ADD .25,FM WRITE"
AC_[].OR.[]	"AD/A.OR.B,A/@1,B/@2,RAMADR/AC#,DBUS/DP, FM WRITE"
AC[]_.NOT.[]	"AD/.NOT.B,DEST/PASS,B/@2,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE"
AC_.NOT.[]	"AD/.NOT.B,DEST/PASS,B/@1,RAMADR/AC#,DBUS/DP,FM WRITE"
AC[]_-Q		"AD/-Q-.25,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE,ADD .25"
AC_Q		"AD/Q,RAMADR/AC#,DBUS/DP, FM WRITE"
AC[]_0		"AD/ZERO,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP, FM WRITE"
AC[]_1		"AD/B,DEST/PASS,B/ONE,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP,FM WRITE"
AC[]_Q		"AD/Q,RAMADR/AC*#,ACALU/AC+N,ACN/@1,DBUS/DP, FM WRITE"

.TOC	"MACROS -- MICROCODE WORK SPACE"


WORK[]_Q	"AD/Q,DEST/PASS,RAMADR/#,WORK/@1,FM WRITE"
Q_WORK[]	"AD/D,DEST/Q_AD,RAMADR/#,DBUS/RAM,WORK/@1,DT/3T"
WORK[]_0	"AD/ZERO,DEST/PASS,RAMADR/#,WORK/@1,FM WRITE"
WORK[]_1	"AD/B,DEST/PASS,RAMADR/#,WORK/@1,B/ONE,FM WRITE"
WORK[]_[]	"AD/B,DEST/PASS,RAMADR/#,WORK/@1,B/@2,FM WRITE"
WORK[]_[] CLR LH "AD/47,RSRC/AB,DEST/PASS,RAMADR/#,WORK/@1,B/@2,A/MASK,FM WRITE"
WORK[]_[]-1	"AD/A-B-.25,A/@2,B/ONE,DEST/PASS,RAMADR/#,WORK/@1,FM WRITE, ADD .25"
WORK[]_.NOT.[]	"AD/.NOT.B,DEST/PASS,RAMADR/#,WORK/@1,B/@2,FM WRITE"
WORK[]_[].AND.[] "AD/A.AND.B,DEST/PASS,RAMADR/#,WORK/@1,A/@2,B/@3,FM WRITE"
WORK[]_[]+[]	"AD/A+B,DEST/PASS,RAMADR/#,WORK/@1,A/@2,B/@3,FM WRITE"
[].AND.NOT.WORK[] "AD/.NOT.D.AND.A,A/@1,DBUS/RAM,RAMADR/#,WORK/@2,DT/3T"
[].AND.WORK[]	"AD/D.AND.A,A/@1,DBUS/RAM,RAMADR/#,WORK/@2,DT/3T"
[]_[]+WORK[]	"AD/D+A,A/@2,DEST/AD,B/@1,DBUS/RAM,RAMADR/#,WORK/@3,DT/3T"
[]_[].AND.WORK[] "AD/D.AND.A,A/@2,DEST/AD,B/@1,DBUS/RAM,RAMADR/#,WORK/@3,DT/3T"
[]_[].AND.NOT.WORK[] "AD/.NOT.D.AND.A,A/@2,DEST/AD,B/@1,DBUS/RAM,RAMADR/#,WORK/@3,DT/3T"
[]_[].OR.WORK[]	"AD/D.OR.A,A/@2,DEST/AD,B/@1,DBUS/RAM,RAMADR/#,WORK/@3,DT/3T"
[]_WORK[]	"AD/D,DEST/AD,B/@1,DBUS/RAM,RAMADR/#,WORK/@2,DT/3T"
[]_.NOT.WORK[]	"AD/.NOT.D,DEST/AD,B/@1,DBUS/RAM,RAMADR/#,WORK/@2,DT/3T"
[]_-WORK[]	"AD/-D-.25,ADD .25,DEST/AD,B/@1,DBUS/RAM,RAMADR/#,WORK/@2,DT/3T"
[]_WORK[]+1	"AD/D+A,A/ONE,DEST/AD,B/@1,DBUS/RAM,RAMADR/#,WORK/@2,DT/3T"
Q_Q-WORK[]	"AD/Q-D-.25,DEST/Q_AD,DBUS/RAM,RAMADR/#,WORK/@1,ADD .25,DT/3T"
[]_[]-WORK[]	"AD/A-D-.25,DEST/AD,A/@2,B/@1,DBUS/RAM,RAMADR/#,WORK/@3,ADD .25,DT/3T"

RAM_[]		"AD/B,DEST/PASS,RAMADR/RAM,B/@1,FM WRITE"

.TOC		"MACROS -- MEMORY CONTROL"

MEM CYCLE		"MEM/1"

;THE FOLLOWING MACROS CONTROL MEMORY ADDRESS
LOAD VMA		"MEM CYCLE,LDVMA/1"
FORCE EXEC		"FORCE EXEC/1"
VMA PHYSICAL		"PHYSICAL/1,FORCE EXEC/1,FORCE USER/0,EXT ADR/1,LOAD VMA"
VMA PHYSICAL WRITE	"LOAD VMA,VMA PHYSICAL,WAIT/1,MEM/1,WRITE CYCLE/1,WRITE TEST/0"
VMA PHYSICAL READ	"LOAD VMA,VMA PHYSICAL,WAIT/1,MEM/1,READ CYCLE/1,WRITE TEST/0"
VMA EXTENDED		"EXT ADR/1"

PXCT EA			"PXCT/E1"
PXCT DATA		"PXCT/D1"
PXCT BLT DEST		"PXCT/D1"
PXCT BYTE PTR EA 	"PXCT/E2"
PXCT BYTE DATA		"PXCT/D2"
PXCT STACK WORD		"PXCT/D2"
PXCT BLT SRC		"PXCT/D2"
PXCT EXTEND EA		"PXCT/E2"

;THE FOLLOWING MACROS GET MEMORY CYCLES STARTED
WRITE TEST		"WRITE TEST/1,WAIT/1"
START READ		"MEM CYCLE,READ CYCLE/1,WAIT/1"
START WRITE		"MEM CYCLE,WRITE TEST,WRITE CYCLE/1,WAIT/1"
START NO TEST WRITE	"MEM CYCLE,WRITE CYCLE/1,WAIT/1"
FETCH			"START READ,FETCH/1,PXCT/CURRENT,WAIT/1"

;THE FOLLOWING MACROS COMPLETE MEMORY CYCLES
MEM WAIT		"MEM CYCLE,WAIT/1"
MEM READ		"MEM WAIT,DBUS/DBM,DBM/MEM"
MEM WRITE		"MEM WAIT,DT/3T"
SPEC MEM READ		"SPEC/WAIT,DBUS/DBM,DBM/MEM"
SPEC MEM WRITE		"SPEC/WAIT,DT/3T"


;THINGS WHICH WRITE MEMORY
MEM_[]			"AD/B,DEST/PASS,B/@1,DBUS/DP,RAMADR/VMA,CHK PARITY"
MEM_Q			"AD/Q,DBUS/DP,RAMADR/VMA"


;THINGS WHICH READ MEMORY
[]_IO DATA		"AD/D,DBUS/DBM,RAMADR/VMA,DEST/AD,B/@1"
[]_MEM			"AD/D,DBUS/DBM,RAMADR/VMA,DEST/AD,B/@1,CHK PARITY"
[]_MEM THEN FETCH	"AD/D,DBUS/DBM,RAMADR/VMA,DEST/A,A/PC,B/@1,CHK PARITY, FETCH, LOAD VMA"
[]_MEM*.5		"AD/D,DBUS/DBM,RAMADR/VMA,DEST/AD*.5,B/@1,CHK PARITY"
[]_MEM.AND.MASK		"AD/D.AND.A,A/MASK,DBUS/DBM,RAMADR/VMA,DEST/AD,B/@1,CHK PARITY"
[]_(MEM.AND.[])*.5	"AD/D.AND.A,A/@2,DBUS/DBM,RAMADR/VMA,DEST/AD*.5,B/@1,CHK PARITY"
Q_MEM			"AD/D,DBUS/DBM,RAMADR/VMA,DEST/Q_AD,CHK PARITY"
[]_MEM AND READ []	"AD/D,DBUS/DBM,RAMADR/VMA,DEST/A,B/@1,A/@2,CHK PARITY"
.TOC	"MACROS -- VMA"

VMA_[]			"AD/A,A/@1,DEST/PASS,LOAD VMA"
VMA_[] WITH FLAGS	"AD/A,A/@1,DEST/PASS,LOAD VMA,WAIT/1, MEM/1, EXT ADR/1, DP FUNC/1, DT/3T"
VMA_[].OR.[] WITH FLAGS	"AD/A.OR.B,A/@1,B/@2,DEST/PASS,LOAD VMA,WAIT/1, MEM/1, EXT ADR/1, DP FUNC/1, DT/3T"
VMA_[]+1		"AD/A+B,A/ONE,B/@1,DEST/AD,HOLD LEFT,LOAD VMA"
VMA_[]-1		"AD/B-A-.25,A/ONE,B/@1,ADD .25,HOLD LEFT,LOAD VMA"
VMA_[]+XR		"AD/D+A,DBUS/RAM,RAMADR/XR#,A/@1,LOAD VMA"
VMA_[]+[]		"AD/A+B,DEST/PASS,A/@1,B/@2,LOAD VMA"

NEXT [] PHYSICAL WRITE "AD/A+B,A/ONE,B/@1,DEST/AD,HOLD LEFT,LOAD VMA, VMA PHYSICAL, START WRITE"

;MACROS TO LOAD A 2901 REGISTER WITH VMA FLAG BITS
[]_VMA FLAGS	"AD/45,DEST/AD,B/@1,DBM/#,DBUS/DBM,RSRC/D0,A/MASK"
[]_VMA IO READ	"[@1]_VMA FLAGS,READ CYCLE/1,IO CYCLE/1,WRITE TEST/0, PHYSICAL/1, FORCE EXEC/1, FORCE USER/0"
[]_VMA IO WRITE	"[@1]_VMA FLAGS,WRITE CYCLE/1,IO CYCLE/1,WRITE TEST/0, PHYSICAL/1, FORCE EXEC/1, FORCE USER/0"

.TOC	"MACROS -- TIME CONTROL"

AC		"RAMADR/AC#"
AC[]		"RAMADR/AC*#,ACALU/AC+N,ACN/@1"
XR		"RAMADR/XR#"
VMA		"RAMADR/VMA"
WORK[]		"RAMADR/#, WORK/@1"

2T		"T/2T"
3T		"T/3T"
4T		"T/4T"
5T		"T/5T"

.TOC	"MACROS -- SCAD, SC, FE LOGIC"

LOAD SC		"LOADSC/1"
LOAD FE		"LOADFE/1"
STEP SC		"SCAD/A-1,SCADA/SC,LOAD SC,SKIP/SC"
SHIFT		"SCAD/A+B,SCADA/S#,SCADB/FE,S#/1, LOAD FE, MULTI SHIFT/1"

SC_SC-1		"SCAD/A-1,SCADA/SC,LOAD SC"
SC_SHIFT	"SCAD/A+B,SCADA/S#,S#/0,SCADB/SHIFT,LOAD SC"
SC_SHIFT-1	"SCAD/A+B,SCADA/S#,S#/1777,SCADB/SHIFT,LOAD SC"
SC_SHIFT-2	"SCAD/A+B,SCADA/S#,S#/1776,SCADB/SHIFT,LOAD SC"
SC_-SHIFT	"SCAD/A-B,SCADA/S#,S#/0000,SCADB/SHIFT,LOAD SC"
SC_-SHIFT-1	"SCAD/A-B,SCADA/S#,SCADB/SHIFT,S#/1777,LOAD SC"
SC_-SHIFT-2	"SCAD/A-B,SCADA/S#,SCADB/SHIFT,S#/1776,LOAD SC"
SC_SC-EXP	"SCAD/A-B,SCADA/SC,SCADB/EXP,LOAD SC"
SC_SC-EXP-1	"SCAD/A-B-1,SCADA/SC,SCADB/EXP,LOAD SC"
SC_SC-FE-1	"SCAD/A-B-1,SCADA/SC,SCADB/FE,LOAD SC"
SC_SC-FE	"SCAD/A-B,SCADA/SC,SCADB/FE,LOAD SC"
SC_EXP		"SCAD/A+B,SCADA/S#,S#/0,SCADB/EXP,LOAD SC"
SC_S#-FE	"SCAD/A-B,SCADA/S#,SCADB/FE,LOAD SC"
SC_FE+S#	"SCAD/A+B,SCADA/S#,SCADB/FE,LOAD SC"
SC_FE		"SCAD/A.OR.B,SCADA/S#,S#/0,SCADB/FE,LOAD SC"
SC_S#		"SCAD/A,SCADA/S#,LOAD SC"


SC_36.		"SC_S#,S#/36."
SC_35.		"SC_S#,S#/35."
SC_34.		"SC_S#,S#/34."
SC_28.		"SC_S#,S#/28."
SC_27.		"SC_S#,S#/27."
SC_26.		"SC_S#,S#/26."
SC_24.		"SC_S#,S#/24."
SC_22.		"SC_S#,S#/22."
SC_20.		"SC_S#,S#/20."
SC_19.		"SC_S#,S#/19."
SC_14.		"SC_S#,S#/14."
SC_11.		"SC_S#,S#/11."
SC_9.		"SC_S#,S#/9."
SC_8.		"SC_S#,S#/8."
SC_7		"SC_S#,S#/7"
SC_6		"SC_S#,S#/6"
SC_5		"SC_S#,S#/5"
SC_4		"SC_S#,S#/4"
SC_3		"SC_S#,S#/3"
SC_2		"SC_S#,S#/2"
SC_1		"SC_S#,S#/1"
SC_0		"SC_S#,S#/0."
SC_-1		"SC_S#,S#/1777"
SC_-2		"SC_S#,S#/1776"

FE_-FE		"SCAD/A-B,SCADA/S#,S#/0,SCADB/FE,LOAD FE"
FE_-FE-1	"SCAD/A-B,SCADA/S#,S#/1777,SCADB/FE,LOAD FE"
FE_FE-19	"SCAD/A+B,SCADB/FE,SCADA/S#,S#/1550,LOAD FE"
FE_-FE+S#	"SCAD/A-B,SCADA/S#,SCADB/FE,LOAD FE"
FE_FE+SC	"SCAD/A+B,SCADA/SC,SCADB/FE, LOAD FE"
FE_FE.AND.S#	"SCAD/A.AND.B,SCADA/S#,SCADB/FE, LOAD FE"
FE_P		"SCAD/A,SCADA/BYTE1, LOAD FE"
FE_S		"SCAD/A+B, SCADA/S#, S#/0 ,SCADB/SIZE, LOAD FE"
FE_S+2		"SCAD/A+B, SCADA/S#, S#/20, SCADB/SIZE, LOAD FE"
FE_-S-20	"SCAD/A-B,SCADA/S#,S#/1760,SCADB/SIZE, LOAD FE"
FE_-S-10	"SCAD/A-B,SCADA/S#,S#/1770,SCADB/SIZE, LOAD FE"
FE_S#		"SCAD/A,SCADA/S#,LOAD FE"
FE_S#-FE	"SCAD/A-B,SCADA/S#,SCADB/FE,LOAD FE"
FE_-2		"FE_S#,S#/1776"
FE_-12.		"FE_S#,S#/1764"
FE_0		"FE_S#,S#/0"
FE_-1		"FE_S#,S#/1777"
FE_FE+1		"SCAD/A+B,SCADA/S#,SCADB/FE,S#/1,LOAD FE"
FE_FE+2		"SCAD/A+B,SCADA/S#,SCADB/FE,S#/2,LOAD FE"
FE_FE+10		"SCAD/A+B,SCADA/S#,SCADB/FE,S#/10,LOAD FE"
FE_FE-1		"SCAD/A+B,SCADA/S#,SCADB/FE,S#/1777,LOAD FE"
FE_FE+4		"SCAD/A+B,SCADA/S#,SCADB/FE,S#/4,LOAD FE"
FE_EXP		"SCAD/A+B,SCADA/S#,S#/0,SCADB/EXP,LOAD FE"
FE_SC+EXP	"SCAD/A+B,SCADA/SC,SCADB/EXP,LOAD FE"
FE_SC-EXP	"SCAD/A-B,SCADA/SC,SCADB/EXP,LOAD FE"
FE_FE+P		"SCAD/A+B,SCADA/BYTE1,SCADB/FE, LOAD FE"
FE_FE-200	"SCAD/A+B,SCADA/S#,S#/1600,SCADB/FE,LOAD FE"
FE_-FE+200	"SCAD/A-B,SCADA/S#,S#/200,SCADB/FE,LOAD FE"
FE_FE+S#	"SCAD/A+B,SCADA/S#,SCADB/FE,LOAD FE"


GEN 17-FE	"SCAD/A-B,SCADA/S#,S#/210,SCADB/FE"

.TOC	"MACROS -- DATA PATH FIELD CONTROL"

HOLD LEFT	"CLKL/0,GENL/0"
ADL PARITY	"GENL/1"
CHK PARITY L	"CHKL/1"

HOLD RIGHT	"CLKR/0,GENR/0"
ADR PARITY	"GENR/1"
CHK PARITY R	"CHKR/1"

AD PARITY	"AD PARITY OK/1"
CHK PARITY	"CHKL/1,CHKR/1"
BAD PARITY	"CHKL/0,CHKR/0"

INH CRY18	"SPEC/INHCRY18"

.TOC	"MACROS -- SHIFT PATH CONTROL"

ASH		"SHSTYLE/NORM"	;ASH SHIFT
LSH		"SHSTYLE/NORM"	;LSH SHIFT (SAME HARDWARE AS ASH BUT
				; BITS -2 AND -1 ARE PRESET TO ZERO)
ROT		"SHSTYLE/ROT"
LSHC		"SHSTYLE/LSHC"
ASHC		"SHSTYLE/ASHC"
ROTC		"SHSTYLE/ROTC"
ONES		"SHSTYLE/ONES"	;SHIFT IN 1 BITS
DIV		"SHSTYLE/DIV"	;SPECIAL PATH FOR DIVIDE (LIKE ROTC BUT
				; COMPLEMENT BIT AS IT GOES AROUND)

.TOC	"MACROS -- SPECIAL FUNCTIONS"

LOAD IR		"SPEC/LOADIR"	;LOAD INSTRUCTION REG FROM
				; DBUS0-DBUS8, LOAD AC# FROM
				; DBUS9-DBUS12
				; UPDATE LAST-INST-PUBLIC PC FLAG
LOAD INST	"SPEC/LDINST"
LOAD INST EA	"SPEC/LOADXR,PXCT/CURRENT"
LOAD BYTE EA	"SPEC/LOADXR,PXCT/E2"
LOAD IND EA	"SPEC/LOADXR,PXCT/E1"
LOAD SRC EA	"SPEC/LOADXR,PXCT/BIS-SRC-EA"
LOAD DST EA	"SPEC/LOADXR,PXCT/BIS-DST-EA"
ADD .25		"CRY38/1"	;GENERATE CARRY IN TO BIT 37
CALL []		"CALL/1,J/@1"	;CALL A SUBROUTINE
LOAD PXCT	"SPEC/LDPXCT"	;LOAD PXCT FLAGS IF EXEC MODE
TURN OFF PXCT	"SPEC/PXCT OFF"
LOAD PAGE TABLE	"SPEC/LDPAGE"
LOAD AC BLOCKS	"SPEC/LDACBLK"
SWEEP		"SPEC/SWEEP,PHYSICAL/1"
CLRCSH		"SPEC/CLRCSH,PHYSICAL/1"
LOAD PI		"SPEC/LDPI"
SET HALT	"SPEC/#,#/74"
CLEAR CONTINUE	"SPEC/#,#/40"
CLEAR EXECUTE	"SPEC/#,#/20"
CLEAR RUN	"SPEC/#,#/10"
UNHALT		"SPEC/#,#/62"
SET APR ENABLES	"SPEC/APR EN"
ABORT MEM CYCLE	"DBUS/DBM,RAMADR/VMA,DBM/MEM,AD/ZERO,SPEC/MEMCLR,LOAD VMA"
CLR IO BUSY	"SPEC/CLR IO BUSY"
CLR IO LATCH	"SPEC/CLR IO LATCH"

.TOC	"MACROS -- PC FLAGS"

CHANGE FLAGS	"SPEC/FLAGS"

SET AROV	"CHANGE FLAGS, HOLD USER/1, SETOV/1, TRAP1/1"
SET FOV		"CHANGE FLAGS, HOLD USER/1, SETFOV/1, TRAP1/1"
SET NO DIVIDE	"CHANGE FLAGS, HOLD USER/1, SETOV/1, SETNDV/1, TRAP1/1"
SET FL NO DIVIDE "SET NO DIVIDE, SETFOV/1"

ASH AROV	"SPEC/ASHOV"
SET FPD		"CHANGE FLAGS, HOLD USER/1, SETFPD/1"
CLR FPD		"CHANGE FLAGS, HOLD USER/1, CLRFPD/1"

SET PDL OV	"CHANGE FLAGS, HOLD USER/1, TRAP2/1"
SET TRAP1	"CHANGE FLAGS, HOLD USER/1, TRAP1/1"
SET TRAP3	"CHANGE FLAGS, HOLD USER/1, TRAP1/1, TRAP2/1"

LOAD PCU	"CHANGE FLAGS, LD PCU/1"
UPDATE USER	"CHANGE FLAGS, HOLD USER/1"
LEAVE USER	"CHANGE FLAGS, HOLD USER/0"

JFCL FLAGS	"CHANGE FLAGS, HOLD USER/1, JFCLFLG/1"

LOAD FLAGS	"CHANGE FLAGS, LD FLAGS/1"
EXP TEST	"SPEC/EXPTST"
AD FLAGS	"CHANGE FLAGS, ADFLGS/1, HOLD USER/1"

NO DIVIDE	"SET NO DIVIDE, J/NIDISP"
FL NO DIVIDE	"SET FL NO DIVIDE, J/NIDISP"

.TOC	"MACROS -- PAGE FAIL FLAGS"

STATE_[]	"[FLG]_#,STATE/@1,HOLD LEFT"
END STATE	"[FLG]_0, HOLD LEFT"

END BLT		"END STATE"
END MAP		"END STATE"

.TOC	"MACROS -- SINGLE SKIPS"
				;SKIPS IF:
SKIP IF AC0	"SKIP/AC0"	;THE AC NUMBER IS ZERO
SKIP DP0	"SKIP/DP0"	;DP BIT 0=1
SKIP DP18	"SKIP/DP18"	;DP BIT 18=1
SKIP AD.EQ.0	"SKIP/ADEQ0,DT/3T" ;ADDER OUTPUT IS ZERO
SKIP AD.LE.0	"SKIP/LE,DT/3T" ;ADDER OUTPUT IS LESS THAN OR EQUAL
				; TO ZERO.
SKIP ADL.LE.0	"SKIP/LLE,DT/3T" ;ADDER LEFT IS LESS THAN OR EQUAL
				; TO ZERO.
SKIP FPD	"SKIP/FPD"	;FIRST-PART-DONE PC FLAG IS SET
SKIP KERNEL	"SKIP/KERNEL"	;USER=0
SKIP IO LEGAL	"SKIP/IOLGL"	;USER=0 OR USER IOT=1
SKIP CRY0	"SKIP/CRY0"	;ADDER BIT CRY0=1 (NOT PC FLAG BIT)
SKIP CRY1	"SKIP/CRY1"	;ADDER BIT CRY1=1 (NOT PC FLAG BIT)
SKIP CRY2	"SKIP/CRY2,DT/3T"	;ADDER BIT CRY2=1
SKIP JFCL	"SKIP/JFCL"	;IF JFCL SHOULD JUMP
SKIP ADL.EQ.0	"SKIP/ADLEQ0"	;ALU BITS -2 TO 17 = 0
SKIP ADR.EQ.0	"SKIP/ADREQ0"	;ALU BITS 18-35 = 0
SKIP IRPT	"SKIP/INT"	;INTERRUPT IS PENDING
SKIP -1MS	"SKIP/-1 MS"	;DON'T SKIP IF 1MS TIMER HAS EXPIRED.
SKIP AC REF	"SKIP/ACREF"	;VMA IS 0-17
SKIP EXECUTE	"SKIP/EXECUTE"	;CONSOLE EXECUTE
TXXX TEST	"SKIP/TXXX"	;TEST INSTRUCTION SHOULD SKIP

.TOC		"MACROS -- SPECIAL DISPATCH MACROS"

NEXT INST	"DISP/NICOND,SPEC/NICOND,J/NICOND"
NEXT INST FETCH	"DISP/NICOND,SPEC/NICOND,J/NICOND-FETCH"
EA MODE DISP	"DISP/EAMODE,RAMADR/XR#"
AREAD		"DISP/AREAD,WAIT/1,AREAD/1,MEM/1,J/0"
B DISP		"DISP/BDISP"
BWRITE DISP	"B DISP,MEM/1,BWRITE/1,WRITE CYCLE/1,J/BWRITE"
INST DISP	"DISP/DROM,J/0"
EXIT		"BWRITE DISP,SPEC/0, WRITE TEST/1"
AD FLAGS EXIT	"BWRITE DISP, WRITE TEST/0, AD FLAGS"
FL-EXIT		"WRITE CYCLE/1,WRITE TEST/1,MEM/1,BWRITE/1,B DISP,J/FL-BWRITE"
TEST DISP	"B DISP,J/TEST-TABLE"
SKIP-COMP DISP	"B DISP,J/SKIP-COMP-TABLE"
JUMP DISP	"B DISP,J/JUMP-TABLE"
DONE		"VMA_[PC],LOAD VMA, FETCH, NEXT INST FETCH"
JUMPA		"[PC]_[AR],HOLD LEFT,LOAD VMA,FETCH,NEXT INST FETCH"
UUO		"[HR]_[HR].AND.#,#/777740,HOLD RIGHT,J/UUOGO"
LUUO		"[AR]_0 XWD [40], J/LUUO1"
PAGE FAIL TRAP	"TL [FLG], FLG.PI/1, J/PFT"
TAKE INTERRUPT	"[FLG]_[FLG].OR.#,FLG.PI/1,HOLD RIGHT,J/PI"
TAKE 1-PROCEED TRAP "[FLG]_[FLG].AND.NOT.#,FLG.1PROC/1,FLG.2PROC/1,HOLD RIGHT,J/1PROC-TRAP"
INTERRUPT TRAP	"WORK[SV.AR]_[AR], J/ITRAP"
MUL DISP	"DISP/MUL"
DIV DISP	"DISP/DIV"
BYTE DISP	"DISP/BYTE, DT/3T"
SCAD DISP	"DISP/SCAD0"	;SKIP (2'S WEIGHT) IS SCAD IS MINUS
RETURN []	"DISP/RETURN,J/@1"
PI DISP		"DISP/PI"
NORM DISP	"DISP/NORM,DT/3T"
DISMISS		"TR [PI], #/077400, CALL [JEN1],DT/3T"
CALL LOAD PI	"[T0]_[PI] SWAP, CALL [LDPI2]"
HALT []		"AD/47,DEST/AD,B/T1,DBM/#,DBUS/DBM,HALT/@1,RSRC/DA,A/MASK, J/HALTED"
CLEANUP DISP	"READ [FLG], DBUS/DP, DISP/DP, 3T, J/CLEANUP"

.TOC		"DISPATCH ROM MACROS"
	.DCODE

;"A FIELD" MACROS SAY HOW TO FETCH ARGUMENTS

I	"I/1"
I-PF	"I/1,VMA/0,READ/1"
R	"A/READ,READ/1"
R-PF	"A/RD-PF,READ/1"
W	"A/WRITE,TEST/1"
RW	"A/READ,TEST/1,READ/1"
IW	"I/1,TEST/1"	;IMMED WHICH STORE IN E. (SETZM, ETC.)
IR	"I/1,READ/1"	;START READ A GO TO EXECUTE CODE
DBL R	"A/DREAD,READ/1"	;AR!ARX _ E!E+1
DBL AC	"A/DBLAC"
SH	"A/SHIFT,VMA/0,READ/1"
SHC	"A/DSHIFT,VMA/0,READ/1"
FL-R	"A/FP,READ/1"	;FLOATING POINT READ
FL-RW	"A/FP,READ/1,TEST/1"
FL-I	"A/FPI,READ/0"	;FLOATING POINT IMMEDIATE
DBL FL-R "A/DFP,READ/1"
IOT	"A/IOT"		;CHECK FOR IO LEGAL

;"B FIELD" MACROS SAY HOW TO STORE RESULTS

AC	"B/AC"
M	"B/MEM,TEST/1,COND FUNC/1"
B	"B/BOTH,TEST/1,COND FUNC/1"
S	"B/SELF,TEST/1,COND FUNC/1"
DAC	"B/DBLAC"
DBL B	"B/DBLB,TEST/1,COND FUNC/1"
FL-AC	"FL-B/AC"			;FLOATING POINT
FL-MEM	"FL-B/MEM,TEST/1,COND FUNC/1"	;FLOATING POINT TO MEMORY
FL-BOTH	"FL-B/BOTH,TEST/1,COND FUNC/1"	;FLOATING POINT TO BOTH
ROUND	"ROUND/1"			;FLOATING POINT ROUNDED


;CONTROL BITS
W TEST	"TEST/1"
AC DISP	"ACDISP/1"
	.UCODE
