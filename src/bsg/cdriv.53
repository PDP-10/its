;;; BSG 3/30/80 - his first ITS lisp program    -*-LISP-*-
(array screeni t  24. 80.) ;yes folks this will work in general.
(declare (special cube-lineno cube-xpos cube-curface have-slain))
(declare (special ttyopt creadtable %toovr fasload overstrike-availablep solving))
(declare (eval (read)))(setsyntax '/# 'splicing '+internal-/#-macro)

(defun make-cube ()
       (setq fasload nil)				;suppress diagnostics
       (load '|bsg;cube fasl|)
       (load '|bsg;cutils fasl|)
       (load '|bsg;csolve fasl|)
       (load '|bsg;cinput fasl|)
       (load '|bsg;cxfrm fasl|)
       (let ((readtable (setq creadtable (get (*array 'creadtable 'readtable nil) 'array))))
	    (mapc '(lambda (x)(setsyntax x 2 nil))
		  (explodec '/0123456789)))
       (setq errlist '((run-cube)))
       (suspend)
       (run-cube))

(defun run-cube ()
       (setq %toovr (lsh (getddtsym '%toovr) 18.)
	     ttyopt (car (syscall 1 'ttyvar tyo (car (pnget 'ttyopt 6)))))
       (setq overstrike-availablep (not (zerop (boole 1 ttyopt %toovr))))
       (setq solving nil)
       (setq tty-return 'tty-return-handler)
       (setq cube-curface 1)
       (clean-cube-redisplay)
       (do ()(nil)
	   (cursorpos 20. 9.)
	   (cursorpos 'l)
	   (interpret-cube-command (tyi))
	   (redisplay-cube)))

(defun cube-displaypos (x)
       (setq cube-xpos x))

(defun cube-terpri ()
       (setq cube-xpos 0)
       (setq cube-lineno (+ 1 cube-lineno)))

(defun cube-princ (s)
       (let ((there (screeni cube-lineno cube-xpos)))
	    (cond ((and (not have-slain)(eq s there)))
		  (t (store (screeni cube-lineno cube-xpos) s)
		     (cursorpos cube-lineno cube-xpos)
		     (redisplay-princ cube-xpos s there)))
	    (setq cube-xpos (+ (flatc s) cube-xpos))))
		     
(defun redisplay-cube ()
       (setq cube-lineno 0 cube-xpos 0 have-slain nil)
       (display-cube))

(defun display-cube-repertoire ()
       (cursorpos 16. 0)
       (cursorpos 'l)
       (princ '|Selected: |)
       (cursorpos 17. 0)
       (cursorpos 'l)
       (princ '|Cube cmds:  f = randomize, s = solve, i = initialize, SPACE = pick new face|)
       (cursorpos  18. 0)
       (cursorpos 'l)
       (princ '|r = re-solve, c = cw, a = ccw, 8 = 180, ^L = redisp, ^F = read cube, ^G =stop|)
       (cursorpos  19. 0)
       (cursorpos 'l)
       (princ '|^R = read twists, x = execute transform|)
       (cursorpos 20. 0)
       (cursorpos 'l)
       (princ '|Command: |))

(defun display-face-choice ()
       (cursorpos 16. 10.)
       (cursorpos 'l)
       (princ cube-curface)
       (princ '| (|)
       (princ (face-names cube-curface))
       (princ '|)|))

(defun interpret-cube-command (c)
       (and (< c (1+ #/z))(> c (1- #/a))(setq c (- c 40)))
       (cond ((= c #^M))
	     ((= c #^J))
	     ((= c #/I)(init-cube))
	     ((= c #/Q)(quit))
	     ((= c 40)(cube-select-face))
	     ((= c #/R)(set-for-solve 'resolve-cube))
	     ((= c #/S)(set-for-solve 'solve-cube))
	     ((= c #/C)(rotate-face cube-curface 'right))
	     ((= c #/A)(rotate-face cube-curface 'left))
	     ((= c #/8)(rotate-face cube-curface 180.))
	     ((= c #/F)(randomize-cube))
	     ((= c #^F)(cube-input))
	     ((= c #^R)(read-cube-commands-from-file))
	     ((= c #^L)(clean-cube-redisplay))
	     ((= c #/X)(execute-stored-transform))
	     ((= c #/L)(clean-cube-redisplay))
	     (t (tyo #^G))))))

(defun execute-stored-transform ()
       (cursorpos 21. 5)
       (princ '|Type transform name, end by CR.. |)
       (let ((fresult (errset (read)))
	     (xf)(prop))
	    (cursorpos 21. 5)
	    (cursorpos 'l)
	    (and fresult
		 (setq xf (car fresult))
		 (cond ((get xf 'cube-transform)
			(run-xform xf))
		       (t (error '| - not a transform| xf))))))

(defun cube-select-face ()
       (cond ((= cube-curface 6)(setq cube-curface 1))
	     (t (setq cube-curface (+ 1 cube-curface))))
       (display-face-choice))

(defun clean-cube-redisplay ()
       (cursorpos 'c)
       (cursorpos 't)
       (fillarray 'screeni '(nil))
       (redisplay-cube)
       (display-cube-repertoire)
       (display-face-choice))


(defun cube-trace n
       (redisplay-cube)
       (cursorpos 21. 5.)
       (cursorpos 'l)
       (let ((solving (listify n)))
	 (mapc 'princ solving)
	 (do ((c (tyi)(tyi)))
	     (nil)
	     (and (< c (1+ #/z))(> c (1- #/a))(setq c (- c 40)))
	     (cond ((= c #^L)
		    (tty-return-handler 'in))
		   ((= c #^G)(^g))
		   ((= c 40)(return nil))
		   ((= c #/Q)(quit))
		   (t (tyo #^G))))))

(setq tracing-cube t)

(defun set-for-solve (fn)
       (let ((solving t))
	    (solving-msgs)
	    (funcall fn)
	    (display-cube-repertoire)
	    (display-face-choice)))

(defun solving-msgs ()
       (cursorpos 16. 0)(cursorpos 'l)
       (cursorpos 17. 0)(cursorpos 'l)
       (cursorpos 18. 0)(cursorpos 'l)
       (cursorpos 20. 0)(cursorpos 'l)
       (princ '|Solution in progress: type SPACE for each step, ^G to stop solving.|))


(defun redisplay-princ (pos new old)
       (let ((oldl (cond ((null old) 0)(t (flatc old))))
	     (newl (flatc new)))
	    (cond (overstrike-availablep
		   (do i 1 (1+ i) (> i oldl)
		       (cursorpos 'k)
		       (cursorpos 'f))
		   (cursorpos cube-lineno pos)))
	    (princ new)
	    (cond ((not overstrike-availablep)
		   (and (> oldl newl)
			(do i newl (1+ i)(= i oldl)(tyo 40)))))))

(defun tty-return-handler (arg)
       (cond ((eq solving nil)
	      (cond ((eq arg 'in)
		     (clean-cube-redisplay)
		     (cursorpos 20. 9.))
		    (t (fillarray 'screeni '(nil))
		       (cursorpos 'c)
		       (display-cube-repertoire)
		       (display-face-choice))))
	     (t
	      (cursorpos 'c)
	      (fillarray 'screeni '(nil))
	      (redisplay-cube)
	      (solving-msgs)
	      (cond ((eq arg 'in)
		     (cursorpos 21. 5.)
		     (mapc 'princ solving))))))

;;;features 21 June 1980 -BSG

(defun read-cube-commands-from-file ()
       (cursorpos 21. 5)
       (princ '|Type file name for commands, end by CR.. |)
       (let ((fresult (errset (readline))))
	    (cursorpos 21. 5)
	    (cursorpos 'l)
	    (cond ((null fresult)
		   (tyo 7))
		  (t (let ((file (errset (open (car fresult) 'in)))
			   (eof (gensym)))
			  (cond ((null file)(tyo 7))
				(t (let ((readtable creadtable))
					(interpret-filed-cube-commands (car file) eof))
				   (close (car file)))))))))

(defun interpret-filed-cube-commands (file eof)
       (errset
	(do atom (read file eof)(read file eof)(eq atom eof)
	    (mapc 'interpret-filed-cube-command (explodec atom)))))


(defun interpret-filed-cube-command (c)
       (let ((n (getcharn c 1)))
	    (cond ((memq c '(/1 /2 /3 /4 /5 /6))
		   (setq cube-curface (- n 60)))
		  (t (interpret-cube-command n)))))