;;; -*- Mode: LISP;  Package: CUBE -*-
(defun multicsp macro (x) nil)

(defun itsp macro (x) nil)

(defmacro array* (&rest ignore) nil)

(defun fillarray (a l &aux dims)
  (and (symbolp a) (setq a (fsymeval a)))
  (cond ((= (setq dims (array-#-dims a)) 1)
	 (dotimes (x (array-dimension-n 1 a))
	   (aset (car l) a x)
	   (and (cdr l)(setq l (cdr l)))))
	((= dims 3)
	 (dotimes (x (array-dimension-n 1 a))
	   (dotimes (y (array-dimension-n 2 a))
	     (dotimes (z (array-dimension-n 3 a))
	       (aset (car l) a x y z)
	       (and (cdr l) (setq l (cdr l)))))))
	((= dims 2)
	 (dotimes (x (array-dimension-n 1 a))
	   (dotimes (y (array-dimension-n 2 a))
	     (aset (car l) a x y)
	     (and (cdr l) (setq l (cdr l))))))))


(defun listarray (a &aux dims answer)
  (and (symbolp a) (setq a (fsymeval a)))
  (cond ((= (setq dims (array-#-dims a)) 1)
	 (dotimes (x (array-dimension-n 1 a))
	   (setq answer (cons (aref a x) answer)))
	 (nreverse answer))
	((= dims 3)
	 (dotimes (x (array-dimension-n 1 a))
	   (dotimes (y (array-dimension-n 2 a))
	     (dotimes (z (array-dimension-n 3 a))
	       (setq answer (cons (aref a x y z) answer)))))
	 (nreverse answer))
	((= dims 2)
	 (dotimes (x (array-dimension-n 1 a))
	   (dotimes (y (array-dimension-n 2 a))
	     (setq answer (cons (aref a x y) answer))))
	 (nreverse answer)))) 


(DEFUN ARRAY (&QUOTE X TYPE &EVAL &REST DIMLIST)
    (APPLY (FUNCTION *ARRAY) (CONS X (CONS TYPE DIMLIST))))

(DEFUN *ARRAY (X TYPE &REST DIMLIST &AUX ARRAY)
    (AND (MEMQ TYPE '(READTABLE OBARRAY))
	 (FERROR NIL "The array type ~S is not yet in" TYPE))
    (SETQ ARRAY
	  (MAKE-ARRAY NIL 'ART-Q DIMLIST))
    (COND ((EQ TYPE 'FIXNUM) (FILLARRAY ARRAY '(0)))
	  ((EQ TYPE 'FLONUM) (FILLARRAY ARRAY '(0.0))))
    (COND ((NULL X)
	   ARRAY)
	  ((SYMBOLP X)
	   (RPLACA (FUNCTION-CELL-LOCATION X) ARRAY)
	   X)
	  (T (FERROR NIL "~S is not a legal first arg for *ARRAY" X))))

