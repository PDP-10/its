IFN ARRALL,[

DSPMSK==1777	;MASK FOR DISPLAY COORDINATES

LPROPD==10	;LENGTH OF PROTECTED PDL

IFNDEF MXARS,[MXARS==20]	;FIXED MAX NUMBER DYNAMIC ARRAYS
IFNDEF NDSPI,[NDSPI==4]	;NO OF DISPLAYS CONCURRENTLY FILLING

;ARRAY ALLOCATOR

BXDARY:	-1	;CURRENT BOXED ARRAY

ARYORG:	REPEAT MXARS,-1	;-1 OR CURRENT ARY ORG
ARYL:	BLOCK MXARS	;CURRENT LENGTH
ARYF:	REPEAT MXARS, ,-1	;INDICATOR FLAGS 4.9 STOP DIS WHILE RELOCATING
			;4.8 NO NEED TO CLEAR CORE
		;RH ARY # OF NEXT HIGHER ARRAY -1 IF NONE

BDISB==400000	;STOP DISPLAY BIT
BGRBG==200000	;GARBAGE OK

ARYNAM:	BLOCK MXARS	;NAME FOR USE WITH BOX HACK
ARYD1:	BLOCK MXARS	;DIM 1 OF ARRY MOST RAPIDLY VARING (USUALLY X)
ARYD2:	BLOCK MXARS	;DIM 2 (USUALLY Y)
ARYMT:	BLOCK MXARS	;LINKS TO ARRAYS THAT ARE MARGIN TBLS FOR THIS ONE
			;4.9=1 OTHER ARRAYS POINT AT ME =0 I POINT AT HIM
			;IF I AM MARGIN ARRY THEN 3.4-3.1 =MARGIN INDEX IN ARRY
			;RH LINK OR -1 IF NONE
;ARYXOF:	BLOCK MXARS	;X ORIGIN OF 0,0 ENTRY IN BAT COORD
;ARYYOF:	BLOCK MXARS
;ARYSCL:	BLOCK MXARS	;BAT PTS/ARRY PT _18.
ARYMPP:	BLOCK MXARS	;MAIN PROTECTED PTR,BLKO PTR FOR DIS
AFRNDS:	BLOCK MXARS	;USED TO LINK FRIENDS IE RAW AND PROCESSED FORMS
			;OF SAME BASIC DATA RH CIRCULAR LINK LH DATA TYPE
			;1 STORED PICTURE 2 GRAD 3 SHOW
ARYPNM:	BLOCK MXARS	;"PRIMARY NAME"

ARYHP:	,-1	;PNTR TO HIGHEST ARRAY
ARYLP:	,-1	;PNTR TO LOWEST ARRAY

PROSTG:	;BEGINNING PROTECTED STORAGE

BYTPNT:	0	;PNTR INTO DISPLAY BUFFER
BYTPNS:	0	;PNTR TO DISPLAY BUFF WHERE ENTERED INCR OR VECTOR MODE
DSPLIM:	0	;END OF BUFFER
LDSPI==.-BYTPNT	;LENGTH OF PROTECTED DISPLAY BLOCK

DSPI:	BLOCK NDSPI*LDSPI	;STG OF PRECEDING DISPLAY INFO WHEN DORMANT

GRADY:	@(Z)	;REF TO GRAD ARRY

PROPDL:	BLOCK LPROPDL	;PROTECTED PDL

;PROTECTED WORDS FOR VARIOUS SUPPRT USERS
PRT0:		0
PRT1:FOOADD:	0	;USED IN CONVEX
PRT2:SRTADD:	0	;USED BY CONVEX
PRT3:SECRT:	0	;SECRET PLACE FOR IMMEDIATE DISPLAY OF POINT IN LINES
PRT4:DATAR:	0	;ADDRESS OF MAIN DATA ARRAY IN SAHDE
PRT5:DATLIM:	0	;LAST WORD OF SAME
PRT6:		0
PRT7:		0
PRT8:		0
PRT9:		0
LPROSTG==.-PROSTG	;LENGTH PROTECTED STORAGE
PRPDLP:	-LPROPDL,,PROPDL-1

ARYROT:	0	;ROUTINE CALLED FOR EACH RESHUFFLE
;FOR MAINTAINING UNFRIENDLY MARGIN ARRAYS FOR EXAMPLE

ARYDEL:	JUMPL A,CPOPJ
	MOVEI B,0	;DELETE ARRY IN A
ARYALS:	MOVEM 16,ARYAC+16	;OR GENERATE A NEW ONE
	MOVE 16,[C,,ARYAC+C]
	BLT 16,ARYAC+15
	PUSHJ P,ARYAL
	PUSH P,A
	PUSH P,B
	SKIPLE A,ARYROT
	PUSHJ P,(A)
	POP P,B
	POP P,A
	MOVS 16,[C,,ARYAC+C]
	BLT 16,16
	POPJ P,

ARYAC:	BLOCK 17	;SAVED ACS WHILE ARRAYING

ARYAL:	JUMPGE A,ARYA1	;A -1 GENERATE NEW ARRAY ELSE ARRAY NUMBER
	MOVSI F,-MXARS	;B DESIRED LENGTH FLAGS LH IF NEW
	SKIPGE ARYORG(F)
	JRST ARYAL2
	AOBJN F,.-2
	STOP _TOO MANY ARRAYS-ARYAL

ARYAL2:	HLLM B,ARYF(F)	;STORE FLAGS
	CLEARM ARYMT(F)
	HLLOS ARYMT(F)
	CLEARM ARYNAM(F)
	MOVEI D,AFRNDS(F)
	MOVEM D,AFRNDS(F)	;INITIALIZE FRIENDS PNTR-NO FRIENDS
	CLEARM ARYPNM(F)
	HRRZS B
	MOVEI D,FS	;LOOK FOR HOLE
	HRRE C,ARYLP
	MOVEI W,ARYLP
	JUMPL C,ARYAL8	;NO ACTIVE ARRAYS
ARYAL5:	MOVN X,D
	ADD X,ARYORG(C)
	CAIL X,(B)
	JRST ARYAL4	;FOUND BIG ENUF HOLE
	MOVE D,ARYORG(C)
	ADD D,ARYL(C)
	MOVEI W,ARYF(C)	;SAVE PTR TO CURRENT LINK WD
	HRRE C,ARYF(C)
	JUMPGE C,ARYAL5
ARYAL3:	HRRZ C,FSP	;NO HOLE ADD ARRAY TO TOP
	ADDI C,(B)
	PUSHJ P,MEMGT	;GET MEMORY
	HRRZ A,F
	HLLOS ARYF(A)	;ARY ON TOP
	HRRE F,ARYHP
	MOVEM A,ARYHP	;NOW HIGHEST
	JUMPL F,ARYAL6	;FIRST ARRAY
	HRRM A,ARYF(F)	;PATCH PREVIOUS HIGHEST TO POINT TO ME
ARYAL7:	MOVE C,FSP
ARYSX2:	MOVEI X,0
ARYSX:	MOVEM C,ARYORG(A)	;STORE ARRAY IN A LOCN IN C
	MOVEI F,-1(C)
	HRRM F,ARYMPP(A)	;SET ADR OF DIS PNTR
	ADD X,C		;CLEAR ALL BUT FIRST X REG
	ADDI C,(B)	;LENGTH IN B
	CAMLE C,FSP
	MOVEM C,FSP
	MOVE F,ARYF(A)
	TLNN F,BGRBG	;DONT NEED TO CLEAR CORE
	CAML X,C
	JRST ARYSX1
	MOVEI F,0
	SKIPGE ARYF(A)
	MOVE F,[403737,,403737]	;DISPLAY ARRY
	MOVEM F,(X)
	HRLS X
	AOS X
	CAILE C,(X)
	BLT X,-1(C)
ARYSX1:	HRRZM B,ARYL(A)
	HRRE F,ARYF(A)	;ERROR CHECK
	HRRZ X,B
	ADD X,ARYORG(A)
	JUMPL F,ARYCH1
	CAMLE X,ARYORG(F)
	.VALUE		;TOP OF THIS ARRAY HIGHER THAN START OF NEXT - BUG !
ARYCH2:	SKIPL ARYF(A)
	POPJ P,
	MOVN X,ARYL(A)
	HRLM X,ARYMPP(A)	;LENGTH OF DIS PNTR
	POPJ P,

ARYAL8:	MOVEI C,FS
	MOVEM C,FSP
	JRST ARYAL3

ARYCH1:	CAMLE X,FSP
	.VALUE		;TOP OF THIS ARRAY HIGHER THAN CURRENT FREE SPACE - BUG !
	JRST ARYCH2


ARYAL6:	MOVEM A,ARYLP
	JRST ARYAL7

ARYAL4:	HRRZ A,F
	HRRZ C,(W)	;PICK UP PNTR THAT PNTED TO FROB WE ARE INSERTING IN FRONT OF
	HRRM C,ARYF(A)
	HRRM A,(W)	;MAKE HIM POINT AT ME
	MOVE C,D
	JRST ARYSX2

MEMGT:	CAMGE C,CORTOP	;INCREASE MEM SIZ TO AT LEAST VALUE IN C
	POPJ P,
	MOVE D,CRSZ
NOCRER:	CAMGE D,CRLM	;IN CASE WE RETAINED IT
	JRST AOCRSE
	.CORE 1(D)
	JRST NOCRW
	AOS CRLM
AOCRSE:	AOS CRSZ
	MOVEI D,2000
	ADDM D,CORTOP
	JRST MEMGT

NOCRW:	STRIKE _CORE ?
	PUSH P,A
	MOVEI A,300.	;WAIT 10 SECONDS AND TRY AGAIN
	.SLEEP A,
	POP P,A
	JRST NOCRER

ARYA1:	SKIPGE ARYORG(A)
	JRST ARYA1L
	HRRZS B
	CAMN B,ARYL(A)
	POPJ P,		;CORRECT SIZE ALREADY
	CAML B,ARYL(A)
	JRST ARYEX	;EXPANDING EXISTING ARRAY
	EXCH B,ARYL(A)
	SUB B,ARYL(A)	;COMPUTE # REG VACATED
	MOVN F,ARYL(A)
	HRLM F,ARYMPP(A);STORE NEW LENGTH IN DIS PNTR
	SKIPN F
	CLEARM ARYMPP(A)
IFN DISALL,[
	SKIPGE ARYF(A)
	PUSHJ P,ADISON	;MAKE SURE DISPLAY NOT IN FLUSHED CRUFT
]
	SKIPN ARYL(A)
	JRST ARYA6	;FLUSHING ARRAY
ARY8A:	HRRE F,ARYHP
	JUMPL F,CPOPJ
	HRRZ B,ARYORG(F)
	ADD B,ARYL(F)
	MOVEM B,FSP
	MOVEI F,3*2000(B)
	CAML F,CORTOP
	POPJ P,		;HAVE ONLY A COUPLE EXTRA BLOCKS
ARYFM:	MOVE B,CORTOP
	SUBI B,2000
	CAMG B,FSP
	POPJ P,
	SOS CRSZ
	MOVEM B,CORTOP
	SKIPE HOARD	;DON'T RELEASE CORE IF HOARD IS ON
	JRST ARYFM
	.CORE @CRSZ
	.VALUE 		;LOST TRYING TO FLUSH MEM - BUG !
	SOS CRLM
	JRST ARYFM
HOARD:	0	;SET NON-ZERO TO STOP RELEASING CORE

ARYA1L:	STRIKE _ARRAY #1 DOESNT EXCIST-ARYA1
	MOVNI A,1
	JRST ARYAL

ARYA6:	CAMN A,BXDARY
	SETOM BXDARY
	SKIPL ARYF(A)
	JRST ARYA6E	;NOT DIS ARRY
	MOVEI F,DISLIST	;?+1
ARYA6F:	HLRZ D,(F)	;FLUSH ARRY FROM DISLIST
	CAIN D,ARYMPP(A)
	HRRZS (F)
	HRRZ F,(F)
	JUMPN F,ARYA6F
ARYA6E:	MOVEI D,AFRNDS(A)
	HRRZ W,AFRNDS(A)
ARYA6D:	CAIN W,AFRNDS(A)
	JRST ARYA6C
	MOVE D,W
	HRRZ W,(W)
	JRST ARYA6D
ARYA6C:	HRRZ W,AFRNDS(A);FIX UP FRIENDS PNTR
	HRRM W,(D)
	MOVEI W,ARYLP-ARYF
	HRRZ F,ARYLP
ARYA6A:	CAMN F,A
	JRST ARYA6B	;FOUND WHAT PNTS TO ME
	MOVE W,F
	HRRE F,ARYF(F)
	JUMPGE F,ARYA6A
	.VALUE		;ARRAY LIST FOULED UP - BUG !

ARYA6B:	SETOM ARYORG(A)	;FLUSH ARRAY
	HRRZ D,ARYF(A)
	HRRM D,ARYF(W)	;MAKE HIM PNT TO WHAT I POINTED TO
	CAIN W,ARYLP-ARYF
	MOVEI W,-1	;IF I AM HIGHEST ARRAY I AM LAST ONE
	CAMN A,ARYHP
	HRRM W,ARYHP	;I WAS HIGHEST ARY SO HE IS NOW
	SKIPGE W,ARYMT(A)
	JRST ARY6E	;I AM DATA ARRAY WHICH OTHERS MAY POINT TO
	MOVSI W,-MXARS
ARY6D:	SKIPGE ARYORG(W)
	JRST ARY6C
	HRRZ X,ARYMT(W)
	CAME X,A
	JRST ARY6C
	HRRZ X,ARYMT(A)	;YES MAKE HIM POINT TO WHAT I POINTED TO
	HRRM X,ARYMT(W)
	JRST ARY8A

ARY6C:	AOBJN W,ARY6D
	JRST ARY8A

ACORE:	PUSH P,A	;FLUSH ALL EXCESS CORE
	.CORE @CRSZ
	.VALUE
	MOVE A,CRSZ
	MOVEM A,CRLM
	JRST POPAJ

AKILL:	PUSH P,A	;KILL ALL ARRAYS !
	PUSH P,B
	MOVEI A,MXARS-1
	SKIPL ARYORG(A)
	PUSHJ P,ARYDEL
	SOJGE A,.-2
	JRST POPBJ

ARY6E:	HRRE A,W	;FLUSH OTHER ARRAYS THAT MAY POINT AT ME
	JUMPL A,ARY8A
ARY6F:	MOVEI B,0
	PUSHJ P,ARYAL
	HRRE A,ARYMT(A)
	JUMPGE A,ARY6F
	POPJ P,
	

ARYEX:	CAMN A,ARYHP
	JRST ARYEX3	;TOP MOST ARRAY
	HRRZ F,ARYF(A)	;COMPUTE BEG OF NEXT ARRAY
	MOVE C,ARYORG(F)
	SUB C,B		;B HAS DESIRED NEW SIZE
	CAMG C,ARYORG(A)
	JRST ARYSHF	;SHUFFLE NECCESSARY
			;DROP THRU ON CAN EXPAND INTO HOLE
ARYEX4:	MOVE X,ARYL(A)	;DONT CLEAR OLD PART OF ARRAY
	MOVE C,ARYORG(A)
	JRST ARYSX

ARYEX3:	MOVE C,B
	ADD C,ARYORG(A)
	PUSHJ P,MEMGT
	JRST ARYEX4

ARYSHF:	MOVEI C,FS	;WRITE PNTR
	HRRZ F,ARYLP
ARYSH3:	CAME C,ARYORG(F)
	PUSHJ P,ARYMVD
	CAIN A,(F)
	JRST ARYSH1	;FOUND ARRAY WANT TO MAKE BIGGER
	ADD C,ARYL(F)
	HRRE F,ARYF(F)
	JUMPGE F,ARYSH3
ARYGCL:	.VALUE		;GC LOST-BUG !

ARYSH1:	HRRE F,ARYF(F)
	JUMPL F,ARYGCL
	ADD C,B		;END AFTER EXPANSION
	CAMGE C,ARYORG(F)
	JRST ARYEX4	;WILL FIT NOW
ARYSH4:	ADD C,ARYL(F)	;START FROM TOP AND SHUFFLE UP
	HRRE F,ARYF(F)	;COMPUTE EVENTUAL TOP ADDRESS
	JUMPGE F,ARYSH4
	PUSHJ P,MEMGT	;MAKE SURE HAVE ENUF MEMORY
	CAMLE C,FSP
	MOVEM C,FSP
	HRRZ F,ARYHP
ARYSH7:	SUB C,ARYL(F)	;DECREMENT WRITING PNTR BY SIZE THIS ARRAY
	CAMLE C,ARYORG(F);EITHER HIGH ENUF OR NO CHANGE
	PUSHJ P,ARYMVU
	HRRZ X,ARYLP
	MOVNI D,1	;FIND ARRAY BELOW THIS
ARYSH5:	CAMN X,F
	JRST ARYSH6
	MOVE D,X
	HRRE X,ARYF(X)
	JUMPGE X,ARYSH5
	JRST ARYGCL

ARYSH6:	JUMPL D,ARYGCL
	MOVE F,D
	CAME F,A	;FOUND ARRAY MAKING ROOM FOR
	JRST ARYSH7
	MOVE X,ARYORG(A);ERROR CHECK
	ADD X,B
	HRRE F,ARYF(A)
	SKIPL F
	CAMLE X,ARYORG(F)
	.VALUE		;BUG !
	JRST ARYEX4

ARYMVD:	CAML C,ARYORG(F);MOVE ARRAY IN F FROM CURRENT LOCN TO START IN LOCN C
	.VALUE		;BUG !
	PUSHJ P,ARYRL	;RELOCATED PNTRS TO ARRAY
	HRRZ D,C
	HRL D,ARYORG(F)
	MOVE X,D
	ADD X,ARYL(F)
	BLT D,-1(X)
ARYRST:	HRRZM C,ARYORG(F)
	HLLZ X,ARYF(F)
IFN DISALL,[
	TLNE X,BDISB
	PUSHJ P,ADISON
]
	MOVE X,ARYORG(F)
	ADD X,ARYL(F)
	HRRE D,ARYF(F)
	JUMPL D,ARYCH3
	CAMLE X,ARYORG(D)
	.VALUE		;BUG !
	POPJ P,

ARYCH3:	CAMLE X,FSP
	.VALUE		;BUG !
	POPJ P,

ESCSTP:	403737,,403737
ARYMVU:	PUSHJ P,ARYRL
	MOVE D,C	;NEW ADDRESS
	MOVE X,ARYORG(F)	;OLD ADDRESS
	ADD D,ARYL(F)	;LAST NEW ADR+1
	ADD X,ARYL(F)	;LAST OLD ADR+1
ARYMV1:	MOVE W,-1(X)
	MOVEM W,-1(D)
	SOS X
	CAML X,ARYORG(F)
	SOJA D,ARYMV1
	JRST ARYRST

ARYRL:	HLLZ X,ARYF(F)	;RELOC PNTRS TO ARRY IN F
	TLNE X,BDISB
	.DSTOP
	HRRZ D,ARYORG(F)	;OLD LOWER RANGE
	MOVE X,D
	ADD X,ARYL(F)	;OLD UPPER LIMIT
	MOVE W,C
	SUB W,ARYORG(F)	;CHANGE
	HRRZ U,ARYMPP(F)	;RELOCATE EVEN IF DOESNT POINT INTO ARRAY
	ADD U,W
	HRRM U,ARYMPP(F)
	SKIPL U,ARYMT(F)
	JRST ARYRL3	;OTHER ARRAYS DONT POINT AT THIS ONE
ARYRL4:	PUSH P,U
	MOVN T,ARYL(U)
	HRLS T
	HRR T,ARYORG(U)
	PUSHJ P,ARYRLR
	POP P,U
	HRRE U,ARYMT(U)
	JUMPGE U,ARYRL4
ARYRL3:	MOVE T,[-LPROSTG,,PROSTG]
ARYRLR:ARYRL1:	HRRZ U,(T)
	CAML U,D
	CAML U,X
	JRST ARYRL2
	ADD U,W
	HRRM U,(T)
ARYRL2:	AOBJN T,ARYRL1
	POPJ P,

ARYCLR:	SKIPG ARYF(A)
	.DSTOP
	PUSH P,X
	PUSH P,W
	HRRZ W,ARYORG(A)	;'CLEAR' ARRY IN A WITH (B)
	MOVEM B,(W)
	HRRZ X,W
	ADD X,ARYL(A)
	HRLS W
	AOS W
	BLT W,-1(X)
	POP P,W
	POP P,X
IFN DISALL,[
	SKIPG ARYF(A)
	JRST ADISON
]
	POPJ P,
]
IFN MARARR,[

MARG:	HRRE X,ARYMT(A)	;CREATE MARG TABLE FOR ARY IN A ON AC IN B
	JUMPL X,MARG2
MARG4:	LDB D,[220400,,ARYMT(X)]	;SEE IF DESIRED MARGIN TBL ALREADY EXISTS
	CAMN D,B
	JRST MARG3	;YES
	HRRE X,ARYMT(X)
	JUMPGE X,MARG4
MARG2:	PUSH P,B	;GENERATE MARGIN TABLE FOR ARRAY IN A
			;AC DESIRED IN INDEX IN B
	MOVE B,ARYD2(A)	;LENGTH OF MARGIN TABLE REQD
	PUSH P,A
	MOVNI A,1
	PUSHJ P,ARYALS
	POP P,C
	POP P,D
	MOVE B,ARYD2(C)
	MOVE X,ARYORG(A)
	MOVE W,ARYORG(C)
	HRL W,D
MARG1:	MOVEM W,(X)
	ADD W,ARYD1(C)
	AOS X
	SOJG B,MARG1
	MOVE W,ARYMT(C)
	HRL W,D		;SAVE MARGIN INDEX
	MOVEM W,ARYMT(A)
	TLO A,400000	;INDICATE I AM DATA ARRAY
	MOVEM A,ARYMT(C)
	POPJ P,		;RETURN RESULT ARRAY IN A

MARG3:	HRRZ A,X	;RETURN MARGIN ARRY
	POPJ P,

GRADYS:	MOVEI B,Y
	MOVEI C,GRADY
MARGST:	PUSH P,A	;SET LCN IN C TO POINT TO MARG ARRY FOR ARRY IN A ON AC IN B
	PUSH P,C
	PUSHJ P,MARG
	POP P,C
	HRRZ B,ARYORG(A)
	HRRM B,(C)
	JRST POPAJ

INTRO:	HRL X,AFRNDS(B)	;MAKE ARRY IN A FRIEND OF ONE IN B
	MOVSM X,AFRNDS(A)	;DATA TYPE OF ARY A IN X
	MOVEI X,AFRNDS(A)
	HRRM X,AFRNDS(B)
	POPJ P,

]
IFN DISALL,[


;MACRO USED IN DISPLAYAGE

;A1 IS MASK OF ALLOWED BITS, A2 IS CURENT VALUE, A3 IS CHANGE-ENABLE BIT

DEFINE PARAM A1,A2,A3
	ANDI W,A1
	CAMN W,A2
	POPJ P,
	MOVEM W,A2
	IORI W,A3
TERMIN

DKILL:	PUSH P,A
	PUSH P,B	;KILL ALL ARRAYS USED AS DISPLAY ARRAYS
	MOVEI A,MXARS-1
DKILLP:	SKIPG ARYORG(A)
	JRST DKILLN
	SKIPGE ARYF(A)
	PUSHJ P,ARYDEL
DKILLN:	SOJGE A,DKILLP
	JRST POPBJ

DLAST:	PUSH P,A	;KILL CURRENT DSPARY
	PUSH P,B
	MOVE A,DSPARY
	PUSHJ P,ARYDEL
	SETOM DSPARY
	JRST POPBJ

WALZ:	MOVEI C,DISLIS	;SEE WHICH IS WHICH ON DISLIS
WALZ1:	MOVE B,(C)
	HLRZ A,B
	JUMPE A,REVIVM
	SUBI A,ARYMPP
	HRRZS (C)
	STRIKE  KILL #1 ? 
	PUSHJ P,SKPYES
REVIVM:	MOVEM B,(C)
	HRRZ C,B
	JUMPN C,WALZ1
	POPJ P,

FLSNDS:	MOVEI B,NDSPI-1
	SETZM C
	SETOM DSPARY-YDISP+DSPIB(C)	;RESET ALL DSPARY'S TO -1
	ADDI C,LDSPIB
	SOJGE B,.-2
	POPJ P,
MESAX:	125.	;SIMILAR TO MESSX

DOTS:	PUSH P,DSPARY	;PUT IN DOTS TO LINE UP 8.5" * 11" PAPER WITH MARGINS
	SETOM DSPARY
	PUSHJ P,DISINS
.I DSPPNI<,MESAX-125.,0>
.I DSPPNI<,MESAX,62.>
.I DSPPNI<,MESAX,962.>
.I DSPPNI<,MESAX-125.,1023.>
.I DSPPNI<,MESAX+725.,1023.>
.I DSPPNI<,MESAX+625.,962.>
.I DSPPNI<,MESAX+625.,62.>
.I DSPPNI<,MESAX+725.,0>
	PUSHJ P,DISGO
	POP P,DSPARY
	POPJ P,


;DISPLAY ROUTINES - USE A,B,C,D,E  AND W,X  INDISCRIMINATLY

DSPCRI:	0	;INDEX OF CURRENT DSP ACTIVE
YDISP:	0	;CURRENT Y COORD
XDISP:	0
DSPSCL:	0	;" SCALE_4
DSPINT:	0	;"  INTENSITY
DSPSC:	0	;CURRENT SCALE NOT SHIFTED
DSPMOD:	0	;CURRENT MODE
DSPARY:	-1	;CURRENT ARRAY FOR DISPLAY
DINCNR:	-1	;NUMBER INCREMENTS STORED IN CURRENT BYTE -1 MAKE NEW BYTE
LDSPIB==.-YDISP

DSPIB:	BLOCK NDSPI*LDSPIB

DSPPNZ:	TDZA D,D	;NO INTENSIFY
DSPPNI:	MOVEI D,2000	;INTENSIFY
DSPPNT:	PUSHJ P,MODPNT	; MAKE SURE THE DISPLAY IS IN POINT MODE
DSPPTU:	ANDI B,DSPMSK	; EXTRACT  COORDINATE VALUES
	ANDI C,DSPMSK
	CAME C,YDISP	; CHECK TO SEE IF Y VALUES COMPARE
	JRST DSPINC
	CAMN B,XDISP
	POPJ P,		;SAME AS LAST POINT
DSPINA:	MOVE W,B
	MOVEM B,XDISP	; X VALUES EQUAL OR BOTH VALUES DIFFERENT
DSPINB:	IORI W,(D)	; MERGE IN INTENSIFY BIT IF IT EXISTS
	JRST DSPPUP	; PUT VALUE IN BUFFER AND RETURN

DSPINC:	MOVE W,C
	MOVEM C,YDISP	; UPDATE VALUE OF Y COORDINATE
	IORI W,200000	; BIT USED TO INDICATE Y VALUE
	CAMN B,XDISP	; CHECK TO SEE IF X VALUES COMPARE
	JRST DSPINB	; THEY COMPARE - UPDATE Y VALUE ONLY
	PUSHJ P,DSPPUP	; PUT Y VALUE IN BUFFER
	JRST DSPINA	; GO RESET X COORDINATE

DSPSEL:	CAMN A,DSPCRI		;CALL WITH DSP # IN A, SWITCHES DISPLAY STATE
	POPJ P,
	CAIL A,NDSPI
	STOP _INVALID SECTION-DSPSEL
	SKIPGE A
	MOVEI A,0
	MOVE B,DSPCRI
	IMULI B,LDSPIB
	HRLI C,YDISP
	HRRI C,DSPIB(B)		;INFO ON THIS PAGE
	BLT C,DSPIB+LDSPIB-1(B)
	MOVE B,DSPCRI
	IMULI B,LDSPI
	HRLI C,BYTPNT
	HRRI C,DSPI(B)
	BLT C,DSPI+LDSPI-1(B)	;SAVE CURRENT INFO IN PROTECTED STORE
	MOVEM A,DSPCRI
	IMULI A,LDSPIB
	HRLI B,DSPIB(A)
	HRRI B,YDISP
	BLT B,YDISP+LDSPIB-1	;RESTORE CRUFT ON THIS PAGE
	MOVE A,DSPCRI
	IMULI A,LDSPI
	HRLI B,DSPI(A)
	HRRI B,BYTPNT
	BLT B,BYTPNT+LDSPI-1	;RESTORE SAVED CRUFT
	POPJ P,


; ROUTINE TO PUT A CHARACTER IN THE DISPLAY LIST

DTYOA:	CAIN A,15
	JRST DTYCR	;HANDLE CR
	CAIN A,12
	MOVEI A,33	;LF
	MOVE W,A	;TAKE OUT CHR FROM A
DSPCHR:	PUSHJ P,MODCHR	; PUT DISPLAY IN CHARACTER MODE
	JRST DSPPUT	; PUT CHARACTER INTO THE BUFFER AND RETURN

DTYCR:	PUSHJ P,MODPNT	;PUT IN POINT MODE
	MOVE W,MESSX
	ANDI W,DSPMSK
	JRST DSPPUP

; ROUTINE TO DISPLAY A MESSAGE
;   DSPMSG POSITIONS THE DISPLAY
;   DSPTXT JUST PUTS THE MESSAGE IN THE BUFFER
; PARAMETERS
;   (A)=MESSAGE POINTER
;   (B)=X COORD
;   (C)=Y COORD

DSPMSG:	PUSHJ P,DSPPNZ	; POSITION DISPLAY
DSPTXT:	PUSHJ P,MODCHR	; PUT DISPLAY IN CHARACTER MODE
	HRLI A,440700	; CONSTRUCT BYTE POINTER TO TEXT ARRAY
DSPTXM:	ILDB W,A	; GET A CHARACTER
	JUMPE W,CPOPJ	; NO MORE CHARACTERS - RETURN
	PUSHJ P,DSPPUT	; PUT CHARACTER INTO THE BUFFER
	JRST DSPTXM

;STEP DIR 567
;	  4 0
;	  321

DISTAP:	SKIPA C,DINCT1(C)	;ENTRY WHICH CHECKS MODE
DISTP:	SKIPA C,DINCT1(C)	;DISPLAY STEP IN C
DINC1:	PUSHJ P,MODINC	;DISPLAY TO INC MODE
DINC:	AOSE D,DINCNR	;DISPLAY INCREMENT IN C
	JRST DINC2
	MOVEI W,200000	;INTENSIFY
	PUSHJ P,DSPPUT	;TIME FOR A NEW BITE
DINC2:	MOVE W,BYTPNT
	TLZ W,2200	;FLUSH OLD SIZ FLD
	ADD W,DINCT(D)
	DPB C,W		;STORE AWAY
	CAIL D,3
	SETOM DINCNR	;THIS BYTE FULL
	POPJ P,

DINCT:	140400,,	;PNTRS TO INCREMENT SUB BYTES
	100400,,
	40400,,
	400,,

DINCT1:	10		;STEP TO 340 INCR
	13
	3
	17
	14
	16
	2
	12

;ROUTINE FOR VECTOR CONTINUE

DSPVCC:	PUSHJ P,MODVCC
	JRST DSPLNE

; ROUTINE TO HANDLE THE PLACING OF VECTORS INTO THE DISPLAY LIST

DSPVEC:	PUSHJ P,MODVEC	; SPECIAL ENTRY TO MAKE SURE DISPLAY IS IN VECTOR MODE
DSPLNE:	MOVEI D,200000	;INTENSIFY
DSPLIN:	LDB A,[430100,,B]	;CLOBBERS A,B,C,D,E,W,X
	LDB W,[430100,,C]
	DPB W,[10100,,A]	;SAVE SIGN BITS
	MOVMS B
	MOVMS C
	MOVN X,DSPSC
	LSH B,(X)
	LSH C,(X)	;COMP FOR SCALE
	CAIGE B,4000
	CAIL C,4000
	JRST VPLOT4
VPLOT3:	SKIPN B		;SEE IF ZERO LENGTH VECTOR
	JUMPE C,CPOPJ
	CAIGE B,200
	CAIL C,200
	JRST VPLOT1
VPLOT2:	MOVEI W,@VECTBL(A)
	DPB C,[80700,,W]
	IOR W,D		;INTENSIFY BIT
	JRST DSPPUT

VPLOT4:	PRINT _MOBY VECTOR-DSPVEC
VPLOT1:	PUSH P,B
	PUSH P,C
	CAMLE B,C
	TLOA A,400000
	EXCH B,C
	IMULI C,177
	IDIVM C,B
	MOVEI C,177
	TLZE A,400000
	EXCH B,C
	PUSHJ P,VPLOT2
	POP P,W
	SUBM W,C
	POP P,W
	SUBM W,B
	JRST VPLOT3

VECTBL:	000000(B)
	000200(B)
	100000(B)
	100200(B)

DSPVVP:	AOSN VECONN
	JRST DSPPNI	;FIRST TIME GO INTO POINT MODE
DSPVCA:	SKIPGE XDISP
	STOP ILLEGAL RELATIVE VECTOR
	SUB B,XDISP	;CONNECT POINT BY INTENSIFIED VECTOR WITH LAST PNT
	SUB C,YDISP
	ADDM B,XDISP
	ADDM C,YDISP
	PUSH P,XDISP
	PUSH P,YDISP
	PUSHJ P,DSPVEC
	POP P,YDISP
	POP P,XDISP
	POPJ P,

DSPVOP:	AOSN VECONN
	JRST DSPPNZ	;FIRST TIME GO INTO POINT MODE
DSPVOC:	SKIPGE XDISP
	STOP ILLEGAL RELATIVE VECTOR
	SUB B,XDISP	;CONNECT POINT BY BLANK VECTOR WITH LAST PNT
	SUB C,YDISP
	ADDM B,XDISP
	ADDM C,YDISP
	PUSH P,XDISP
	PUSH P,YDISP
	PUSHJ P,DSPVCO
	POP P,YDISP
	POP P,XDISP
	POPJ P,

PUTCLL:	0	;ROUTINE CALLED AFTER UPDATING DISPLAY LIST
VECONN:	-1	;-1 TO DO FIRST IN POINT MODE

DSPVCO:	PUSHJ P,MODVEC
DSPVC0:	MOVEI D,0	;VECTOR NOT INTENSIFIED
	JRST DSPLIN

;  ROUTINE TO HANDLE SIZE CHANGES
DSIZG:	MOVE W,B	;ENTER WITH SCALE IN B (0-3)
	JRST DSIZ2

;DSIZST:	HLRZ B,ARYSCL(B)	;SET SIZE TO CORRESP TO ARRY IN B
;	ASH B,-4	;CONVERT SCALE TO  DISPLAY COORD
;	CAIL B,8
;	MOVEI B,8

DSIZA:	MOVEI W,0	;ENTER HERE WITH SIZE IN B (1,2,4,8)
DSIZ1:	CAIG B,1
	JRST DSIZ2
	LSH B,-1
	AOJA W,DSIZ1

DSIZ2:	LSH W,4
DSPSIZ:	PARAM 60,DSPSCL,100
	LDB X,[40200,,W]
	MOVEM X,DSPSC
	PUSHJ P,MODPRM
	LDB X,BYTPNT
	ANDCMI X,60
	JRST DSPBTH	; GO FINISH UP

; ROUTINE TO HANDLE INTENSITY CHANGES
DSPBRG:	MOVE W,B	;ENTER HERE WITH INTENISTY IN B (0-7)
DSPBRT:	PARAM 7,DSPINT,10
	PUSHJ P,MODPRM	; PUT DISPLAY IN PARAMETER MODE
	LDB X,BYTPNT
	ANDCMI X,7
DSPBTH:	IOR W,X
	DPB W,BYTPNT	;CLOBBER ON TOP OF SKEL
	POPJ P,

; ROUTINE TO PUT A COMMAND INTO THE DISPLAY ARRAY
DSPPUP:	IOR W,DSPMOD	; MERGE IN THE MODE BITS
DSPPUT:	HRRZ X,BYTPNT	; GET CURRENT VALUE OF ARRAY POINTER
	CAML X,DSPLIM	; CHECK TO SEE IF THE ARRAY IS FULL
	JRST DSPFUL	; FULL - BETTER CHECK STATUS
DSPPTZ:	IDPB W,BYTPNT	; ROOM EXISTS - PLACE COMMAND IN ARRAY
	SKIPN PUTCLL
	POPJ P,		; RETURN
	JRST PUTCLL@

; ROUTINE TO HANDLE THE BUFFER FULL CONDITION
DSPFUL:	PUSH P,A
	PUSH P,B
	SKIPGE A,DSPARY
	STOP _NON-EXCISTANT DISPLAY ARRAY-DSPFUL
	MOVEI B,2000
	ADD B,ARYL(A)	;TRY MORE ROOM
	PUSHJ P,ARYALS
	MOVEI B,2000
	ADDM B,DSPLIM	;MUST BE AFTER ARYALS TO RELOC IF ARRY MOVED
	POP P,B
	POP P,A
	JRST DSPPTZ
; ROUTINE WHICH PUTS THE DISPLAY INTO THE PROPER MODE

MODPRM:	TDZA E,E	; ENTRY FOR PARAMETER MODE
MODCHR:	MOVEI E,60000	; ENTRY FOR CHARACTER MODE
	JRST MODCHK

MODVCC:	SKIPA E,[120000]	; ENTRY FOR VECTOR CONTINUE
MODVEC:	MOVEI E,100000	; ENTRY FOR VECTOR MODE
	JRST MODCHK

MODINC:	SKIPA E,[140000]	; ENTRY FOR INCREMENT
MODPNT:	MOVEI E,20000	; ENTRY FOR POINT MODE

MODCHK:	CAMN E,DSPMOD	; COMPARE THE TWO VALUES
	POPJ P,		; RETURN - NO CHANGE
	SKIPGE DSPARY	; ARE WE REALLY WINNING?
	STOP _NON-EXCISTANT DISPLAY ARRAY-MODCHK
	MOVEM W,DSPTMP'	; SAVE WORKING REGISTER
	MOVE X,DSPMOD	; GET CURRENT VALUE OF MODE TYPE
	CAIGE X,40000	; CHECK CURRENT MODE TYPE
	JRST MODFNX	; TYPE 0 OR 1 NEED NO SPECIAL HANDLING
	CAIE X,60000	; CHECK FOR BEING IN CHARACTER MODE
	JRST MODSPC	; NO - MUST BE MODE TYPE 4, 5, OR 6
	MOVEI W,37	; PUT TERMINATION CHARACTER INTO THE BUFFER
	PUSHJ P,DSPPUT
	MOVE W,BYTPNT	; GET BYTE POINTER
	TLZ W,177700	; SET BIT POINTER TO NEXT HALFWORD
	TLNE W,200000
	TLO W,20000
	TLO W,2200	; SET BYTE SIZE BACK TO HALFWORD
	MOVEM W,BYTPNT
	JRST MODFIN

MODSPC:	MOVE W,BYTPNS
	CAMN W,BYTPNT
	JRST MODFNW	;HAVENT REALLY STORED ANY OF THIS FLAVOR
	LDB W,BYTPNT	; GET MOST RECENT HALFWORD
	IORI W,400000	; SET PROPER ESCAPE BIT
	DPB W,BYTPNT
MODFIN:	SETZM DSPMOD	; MAKE SYSTEM THINK IT IS IN PARAMETER MODE
	MOVEI W,(E)	; GET NEW VALUE OF MODE TYPE
	PUSHJ P,DSPPUT	; PUT SKELETON TYPE 0 COMMAND INTO THE BUFFER
	MOVE W,DSPTMP	; RESTORE WORKING REGISTER
	JRST MODFNY	; CHECK TO SEE IF NEW MODE NEEDS SPECIAL HANDLING

MODFNW:	MOVE W,DSPTMP	;PREV WORD IS REALLY PNT OR PARAM
MODFNX:	LDB X,BYTPNT	; GET LAST COMMAND FROM THE ARRAY
	ANDCMI X,160000; INSERT NEW MODE BITS
	IORI X,(E)	
	DPB X,BYTPNT	; PUT COMMAND BACK INTO THE ARRAY
	JUMPE E,MODFIN	;INSERT SKEL TYPE 0 COMM
MODFNY:	MOVEM E,DSPMOD	; UPDATE MODE VALUE
	CAIGE E,60000	; CHECK NEW MODE VALUE
	POPJ P,		; RETURN - NEEDS NO SPECIAL HANDLING
	CAIN E,120000
	SETZM DSPMOD	; CAUSE IT WILL RETURN TO PARM MODE WHEN DONE WITH VECTOR CONTINUE
	SETOM DINCNR	; REST INCREMENT STATE CNTR
	MOVE X,BYTPNT	; SAVE SO CAN TELL IF ANY WDS IN THIS MODE REALLY STORED
	MOVEM X,BYTPNS
	CAIE E,60000	; CHECK FOR NEW MODE BEING CHARACTER MODE
	JRST MODFNZ	; NOT CHARACTER - BETTER CHECK SOME MORE
	MOVSI X,2400	; SET BYTE POINTER TO HANDLE CHARACTERS
	XORM X,BYTPNT
MODFNZ:	SETOM XDISP	; X AND Y VALUES ARE UNDEFINED - TELL THE SYSTEM
	SETOM YDISP
	POPJ P,		; RETURN

DCROSS:	PUSHJ P,OUTSID
	POPJ P,
	PUSH P,DSPSCL	;SAVE SIZE	DISPLAY A CROSS
	MOVEI W,0
	PUSHJ P,DSPSIZ	;SET SIZE TO 0
	SUB B,CROSSZ
	PUSHJ P,DSPPNZ	;WEST
	SKIPA
DCROST:	PUSH P,DSPSCL
	MOVE B,CROSSZ
	LSH B,1
	MOVEI C,0
	PUSHJ P,DSPVEC	;EAST
	MOVN C,CROSSZ
	MOVE B,C
	PUSHJ P,DSPVC0	;SOUTH
	MOVEI B,0
	MOVE C,CROSSZ
	LSH C,1
	PUSHJ P,DSPLNE	;NORTH
	POP P,W
	JRST DSPSIZ	;RESTORE SIZE

CROSSZ:	5		;LENGTH OF ARM OF CROSS

;ACDISC:	IMUL B,ARYSCL(A)	;CONVRT ARY COORDS IN B,C TO 340 COORDS
;	IMUL C,ARYSCL(A)
;	TRNE B,400000
;	ADD B,[1,,]
;	TRNE C,400000
;	ADD C,[1,,]
;	HLRZS B
;	HLRZS C
;	ADD B,ARYXOF(A)
;	ADD C,ARYYOF(A)
;	ASH B,-4
;	ASH C,-4
;	POPJ P,

IFN LIBRAR,[

ARROW:	;X1, Y1, X2, Y2 FIXED - GENERATE ARROW
.I ,XQA'=,XQB'=,XQC'=,XQD'=
	PUSHJ P,DSPPNI
ARROWT:
.I DSPVCA<,XQC,XQD>	;DRAW SHAFT
.I FEATH'=MIN<LENTF'=FFIX<SQRT<FFLOAT<(XQC-XQA)^2 +(XQD-XQB)^2 >>>,LNMIN>*FTHFRC/100.
.I DXRW'=(XQC-XQA)*FEATH/LENTF, DYRW'=(XQD-XQB)*FEATH/LENTF
.I DXRW=DXRW-DYRW, DYRW=DXRW+DYRW
.I DSPLNE<,-DXRW,-DYRW>
.I DSPVC0<,DXRW,DYRW>
.I DSPLNE<,-DYRW,+DXRW>
	POPJ P,


FTHFRC:	30.	;ARM FRACTION OF SHAFT
LNMIN:	20.	;MAX SIZE OF PROPOR

]

DSPWHR:	PUSHJ P,MODPNT	;PREPARE A JOINT
	SETOM XDISP
	SETOM YDISP
	MOVE A,BYTPNT
	POPJ P,		;HE NEEDS TO PROTECT THIS ADDRESS


DSPSHM:	ANDI C,DSPMSK
	ILDB W,A
	ANDCMI W,DSPMSK
	IOR W,C
	DPB W,A
	ANDI B,DSPMSK
	ILDB W,A
	ANDCMI W,DSPMSK
	IOR W,B
	DPB W,A
	POPJ P,
DSTUP:	SKIPL A,DSPARY	;INITIALISE DISPLAY ARRAY AND PUT ON DISPLAY LIST
	PUSHJ P,ARYDEL
	SETOM DSPARY
	PUSHJ P,DISINS
	JRST DISAAD

DISIN:	TLOA A,-1	;GET NEW DISPLAY ARRAY
DISINS:	MOVE A,DSPARY	;INITIALISE POSSIBLY EXCISTING DISPLAY ARRAY
	MOVEI B,2000	;INITIAL BUFFER LENGTH
DISNAS:	TLO B,BDISB	;STOP DISPLAY IF BUFFER RELOC
	JUMPL A,DISIN1
	PUSH P,A
	PUSHJ P,DISAFL	;REMOVE OLD ARRAY FROM DISLIS
	POP P,A
DISIN1:	PUSHJ P,ARYALS	;GET ARRAY
	MOVEM A,DSPARY	;REMEMBER FOR DISGO
DISIN2:	MOVE B,ARYORG(A);UNLIKE DISINS THIS DOES NOT CHANGE ARYL TO 2000
	HRLI B,442200
	MOVEM B,BYTPNT	;BYTE POINTER INTO DISPLAY ARRAY
	SOS B
	ADD B,ARYL(A)
	HRRZM B,DSPLIM	;UPPER LIMIT, LAST WORD
	SETOM XDISP
	SETOM YDISP
	CLEARM DSPMOD
	MOVEI A,7
	MOVEM A,DSPINT
	CLEARM DSPSCL
	CLEARM DSPSC
	MOVE A,DSPARY
	MOVEI W,117	;SCALE 0, INT 7-MAY LOOSE IF TRY TO IMMEDIATLY CHANGE INT
	JRST DSPPTZ

DISAFL:	MOVEI A,ARYMPP(A)	;FLUSH ARRAY FROM DISLIST
DISFLS:	PUSH P,B
	PUSH P,C
	MOVEI C,DISLIST
DISFL1:	HLRZ B,(C)
	CAIN B,(A)
	HRRZS (C)	;FLUSH THIS ENTRY
	HRRZ C,(C)
	JUMPN C,DISFL1
	POP P,C
	POP P,B
	POPJ P,

LDISGO:	STRIKE _NON-EXCISTANT DISPLAY ARRAY-DISGO
	POPJ P,

DISGO:	PUSHJ P,MODPRM	;FINISH OFF ARRAY AND PUT ON DISLIST
	MOVEI W,3000
	IDPB W,BYTPNT
	SKIPGE A,DSPARY
	JRST LDISGO
	HRRZ B,BYTPNT
	SUB B,ARYORG(A)
	MOVEI B,5(B)
	PUSHJ P,ARYALS	;FLUSH ANY UNUSED DISPLAY ARRAY SPACE

DISAD1:			;ADD ARRAY TO DISLIST
DISAAD:	JUMPL A,POPJP
	MOVEI A,ARYMPP(A)
DISAD:	MOVEI C,DISLIST
DISA3:	HLRZ B,(C)	;SEE IF ALREADY THERE
	CAMN B,A
	POPJ P,		;YES
	HRRZ C,(C)
	JUMPN C,DISA3
	MOVEI C,DISLIST
DISA2:	HLRZ B,(C)	;LOOK FOR HOLE TO PUT IT IN
	JUMPE B,DISA1
	HRRZ C,(C)
	JUMPN C,DISA2
	STRIKE _DISLIST FULL-DISAD
	POPJ P,

DISA1:	HRLM A,(C)
	POPJ P,

DARYF:	SKIPGE A,DSPARY	;FLUSH DSPARY
	STRIKE _NON-EXCISTANT DISPLAY ARRAY-DARYF
	SETOM DSPARY
	JRST ARYDEL

GRBDIS:	.DSTAR DISLIS	;GRAB DISPLAY
	JRST .-1
	POPJ P,

ADISON:	PUSHJ P,OPNDIS
	POPJ P,
	POPJ P,

ADISOF:	JRST CLODIS

MESSX:	0
MESSY:	1750		;PLACE TO PUT COMMENTS
HEADSW:	1		;NON-0 FOR HEADING
FRAMSW:	0		;NON-0 FOR FRAME
REPET:	60		;CAMERA REPEAT

XBTT:	0		;WINDOW EDGES
XTOP:	1777
YBTT:	0
YTOP:	1777


SCPTTY:	PUSHJ P,TYI	;READ TTY AND PUT CHRS ON SCOPE
	CAIN A,^C
	POPJ P,
	CAIN A,177
	JRST SCPRUB
	CAIN A,15
	MOVEI A,34
	PUSHJ P,DTYOA
	JRST SCPTTY

SCPRUB:	LDB A,BYTPNT
	MOVEI A,100
	PUSHJ P,TYO
	MOVEI A,40
	DPB A,BYTPNT	;CHANGE CHARACTER TO SPACE
	MOVE A,BYTPNT
	CAML A,[360600,,0]
	JRST WRDBRK
	ADD A,[060000,,0]
	MOVEM A,BYTPNT
	JRST SCPTTY

WRDBRK:	PUSH P,B
	SUB A,[360000,,1]
	HRRZ B,BYTPNS
	SUB B,A
	TRNN B,-1
	JRST PSSBEG
	MOVEM A,BYTPNT
	MOVE B,[403737,,403737]
	MOVEM B,1(A)
	POP P,B
	JRST SCPTTY

PSSBEG:	POP P,B
	MOVEI A,"?
	PUSHJ P,TYO
	JRST SCPTTY

SCPPLC:	GET X,Y,SCC,BRT
	MOVEM X,MESAX	;READ PLACE, SCALE, INTENSITY BEFORE SCPTTY
	MOVEI B,1
	PUSHJ P,DSIZA
	MOVE W,BRT
	PUSHJ P,DSPBRT
.I DSPPNZ<,X,Y>
	MOVE B,SCC
	PUSHJ P,DSIZA
	POPJ P,

SCC:	0
BRT:	0

OUTSID:	CAMG B,XTOP	;SKIPS IF POINT INSIDE
	CAMLE C,YTOP
	POPJ P,		;OUTSIDE
	CAML B,XBTT
	CAMGE C,YBTT
	POPJ P,
	AOS (P)		;INSIDE
	POPJ P,

CHRSCL:	2	;CHRACTER SCALE IN TALK

TALK:	MOVEM A,ROTTLK'
	PUSHJ P,OUTSID	;IS INSIDE SCOPE FACE
	POPJ P,		;NO
	PUSHJ P,DSPPNZ	;GO TO MESSAGE PLACE
	PUSH P,DSPSCL
.I DSIZA<,CHRSCL>		;CHANGE SCALE FOR CHARACTERS
	TRO ZR,DISCHR
	PUSHJ P,@ROTTLK	;PRINT
	TRZ ZR,DISCHR
	POP P,W
	JRST DSPSIZ

FRAME:	SKIPN FRAMSW
	POPJ P,
.I DSPPNI<,XBTT,YBTT>	;ORIGIN
.I DSPVCA<,XTOP,YBTT>	;BOTTOM LINE
.I DSPVCA<,XTOP,YTOP>	;RIGHT EDGE
.I DSPVCA<,XBTT,YTOP>	;TOP EDGE
.I DSPVCA<,XBTT,YBTT>	;BACK TO ORG
	POPJ P,

STRSWD:	.DSTOP
.I DISINS<DSPSEL<1>>	;GET REQUIRED DISPLAY ARRAYS
.I DISINS<DSPSEL<0>>
	JRST ADISON	;SWITCH ON DISPLAY

DCLEAR:	.DSTOP
.I DSPCFT'=#NDSPI-1
DPLPCR:	PUSHJ P,DSPSEL
	SKIPL A,DSPARY
	PUSHJ P,ARYDEL
	SETOM DSPARY
	SOSL A,DSPCFT
	JRST DPLPCR
	MOVEI C,DISLIST
DCLR1:	HLRZ A,(C)
	SUBI A,ARYMPP	;CALCULATE ARRAY NUMBER
	SKIPL A
	PUSHJ P,ARYDEL
	HRRZS (C)	;WIPE POINTER
	HRRZ C,(C)	;GROVEL ALONG LIST
	JUMPN C,DCLR1
	JRST ADISON	;START UP DISPLAY AGAIN



;PLOTTER OUTPUT GOODIES

PLOT1:	.OPEN IPLC,IPLOP
	STOP _PLOTTER WON'T OPEN
	POPJ P,

PLOT2:	MOVE A,IPLIO0
	.IOT IPLC,A
	POPJ P,

PLOTA:	PUSHJ P,PLOT1
	PUSHJ P,PLOT2
PLOT3:	MOVE A,DISLIS
DETA:	PUSHJ P,COUP
	TRNN A,-1
	POPJ P,		;END OF DISLIS
	MOVE A,(A)
	JRST DETA

COUP:	MOVE B,A
	HRRI B,747
	TLNE B,-1	;IF NULL ADDRESS IGNORE
	.IOT IPLC,B
	POPJ P,

PLOT:	PUSHJ P,PLOTA
	PUSHJ P,PLOT4
PLOT5:	.CLOSE IPLC,
	POPJ P,

PLOT4:	MOVE A,IPLIO2
	.IOT IPLC,A
	POPJ P,

IPLIO0:	-1		;RESET THE WORLD
IPLIO2:	22001,,1	;GO TO X=11", Y=0"

IPLOP:	5,,(SIXBIT/IPL/)
	0
	0

]
IFN STEREO,[

INSID:	0	;NON-0 WHEN INSIDE WINDOW
XLST:	0	;LAST X
YLST:	0	;LAST Y

XNEW:	0	;END POINTS OF LINE INTERSECTING FRAME
YNEW:	0
XOLD:	0
YOLD:	0

DPOIN:	CAMN B,XLST	;GO TO A POINT
	CAME C,YLST	;FIXED COORDS IN B,C
	JRST .+2	;SKIPA
	POPJ P,		;SAME POINT SO IGNORE
.F ,XLST=,YLST=		;UPDATE LAST POINT
	SETZM INSID
	PUSHJ P,OUTSID	;SEE IF INSIDE FRAME
	POPJ P,		;NO
	SETOM INSID	;YES
	JRST DSPPNI	;SO GENERATE A POINT THERE

DVOIN:	AOSN VECONN
	JRST DPOIN	;POINT FIRST TIME
DVECT:	CAMN B,XLST	;DRAW VECTOR TO THIS POINT
	CAME C,YLST	;FIXED COORDS IN B,C
	JRST .+2	;SKIPA
	POPJ P,		;SAME POINT SO IGNORE
	SKIPN INSID	;WAS LAST POINT INSIDE
	JRST OLSID	;NO
	PUSHJ P,OUTSID	;IS NEW POINT INSIDE
	JRST NLSID	;NO
.I ,XLST=,YLST=		;BOTH INSIDE IT SEEMS
	JRST DSPVCA	;SO DRAW A VECTOR

OLSID:	PUSHJ P,OUTSID	;IS NEW POINT INSIDE
	JRST BTSID	;NEITHER INSIDE
.I ,XOLD=,YOLD=
.I ,XNEW=XLST,YNEW=YLST
	PUSHJ P,SWPLPA	;FIND POINT ON FRAME-EDGE
	PUSHJ P,DSPPNI	;GO TO POINT ON EDGE
	SETOM INSID
.I ,XLST=XOLD,YLST=YOLD
	JRST DSPVCA	;DRAW CONNECTING VECTOR FROM EDGE

SVCRDS:
.I ,XNEW=,YNEW=
.I ,XOLD=XLST,YOLD=YLST
.I ,XLST=XNEW,YLST=YNEW
	POPJ P,

NLSID:	PUSHJ P,SVCRDS	;EXCHANGE SOME POINTS
	PUSHJ P,SWPLPA	;FIND POINT ON FRAME-EDGE
	SETZM INSID
	JRST DSPVCA	;DRAW VECTOR TO EDGE

BTSID:	PUSHJ P,SVCRDS	;BOTH POINTS OUTSIDE
	SETOM GNPNT'
	MOVEI Z,3
	MOVEM Z,ZSVD'
BTTLP:	PUSHJ P,BTTMC	;TEST IF POSSIBLE
	SOSL Z,ZSVD
	JRST BTTLP
	POPJ P,		;ALL FOUR LOST

BTTMC:
.I ,XYCR1@(Z),XYCR2@(Z),XYLVL@(Z)
	CAML B,C
	EXCH B,C
	CAMG B,D
	CAMG C,D
	POPJ P,		;FORGET IT
	PUSHJ P,ROTINZ	;CALL CALCULATOR FOR THIS EDGE
	PUSHJ P,OUTSID	;IS INTERSECTION INSIDE
	POPJ P,		;NO
	AOSN GNPNT	;IS THIS THE FIRST CALL
	JRST DSPPNI	;YES, GO TO POINT
	SUB P,[1,,1]	;POP UP AN EXTRA LEVEL ON RETURN
	JRST DSPVCA	;CONNECT BY VECTOR


XYCR1:	YOLD?XOLD?YOLD?XOLD
XYCR2:	YNEW?XNEW?YNEW?XNEW
XYLVL:	YBTT?XTOP?YTOP?XBTT
SWPLPA:	SETZM D		;WINDOW FUNCTION
	CAML B,XTOP	;FIND WHICH EDGE IT CROSSES
	ADDI D,1+5
	CAML C,YTOP
	ADDI D,2+5
	CAMGE B,XBTT
	ADDI D,4+5
	CAMGE C,YBTT
	ADDI D,0+5
	MOVE Z,D
	SUBI Z,5
	SKIPGE Z
	.VALUE		;CROSSES NO EDGE ! - PROGRAM ERROR
	CAIN Z,4
	MOVEI Z,3
	CAIGE Z,5	;'CROSSES' ONE OR TWO LINES ?
	JRST EDGCRP	;ONLY ONE SO ITS EASY
	SUBI Z,6
	CAIN Z,3
	MOVEI Z,6	;	CAIN Z,5;	MOVEI Z,4
	LSH Z,-1
.I ,(XNEW-XOLD)*(@YCRN(Z)-YOLD)-(YNEW-YOLD)*(@XCRN(Z)-XOLD)	;CROSS PRODUCT
	SKIPGE B	;DECIDE WHICH IT ACTUALLY CROSSES
	AOS Z		;ONE EDGE FURTHER ON
	CAIN Z,4
	MOVEI Z,0
EDGCRP:
ROTINZ:	MOVE D,@XYLVL(Z)
.I ,,,,XNEW-XOLD,YNEW-YOLD
	JRST @ROUTF(Z)	;SELECT ROUTINE TO FIND POINT ON EDGE

ROUTF:	BTTM?RGHT?TOPE?LEFE
XCRN:	XTOP?XTOP?XBTT?XBTT
YCRN:	YBTT?YTOP?YTOP?YBTT

TOPE:BTTM:	SKIPN F
	AOS F		;AVOID ZERO DENOM
.I ,(D-YOLD)*E/F+XOLD,D
	POPJ P,

LEFE:RGHT:	SKIPN E
	AOS E		;AVOID ZERO DENOM
.I ,D,(D-XOLD)*F/E+YOLD
	POPJ P,

CAMERR:	1.0	;-1.0 FOR LEFT, 1.0 FOR RIGHT, 0 NORMALLY
LFTRGH:	0	;-1.0 FOR LEFT, 1.0 FOR RIGHT

HEADF:	0	;ROUTINE TO GEN HEADING
CALLF:	0	;ROUTINE TO GEN DISPLAYAGE

XDCN:	1000	;ASSUMED CENTRE OF SCREEN
YDCN:	1000

CAMMAG:	3.6	;CAMERA DE-MAGNIFICATION (FOR POLAROID ON BOX)

DOBJ:	1000.0	;OPTICAL SYSTEM SPECS, CHANGED BY POT READ IN
DSEY:	70.0
FDIS:	140.0
SIZEC:	1.0
CRAT:	0	;X PERSPECTIVE OFFSET
PROJR:	0	;PROJECTION RATIO
BEHND:	0	;NON 0 WHEN POINT BEHIND CAMERA
ORTHG:	0	;1 FOR 'ORTHOGONAL' PROJECTION

MINSR:	1.0
MINST:	-1.0

DSPSCQ:	4.6	;UNITS PER MM (4.1 FOR PLOTTER)

AVCT:	BLOCK 3	;WORK VECTORS
;RVCT:	BLOCK 3
ROTER:	BLOCK 9	;OBJECT ROTATION MATRIX
ADSM:	BLOCK 3	;OBJECT OFFSET VECTOR

EYEPRJ:	;X,Y,Z, FLOATING, BEHND IS NON 0 IF BEHIND CAMERA
	SETZM BEHND
	SKIPE ORTHG
	SETZM C
	FADR C,DOBJ		;CALCULATE TOTAL Z
	PUSHJ P,REHIR		;TO MAKE SURE ITS NOT 0
	SKIPG C
	SETOM BEHND		;POINT BEHIND CAMERA
.F ,,,(1.0-PROJR=FDIS/C)*(CRAT=DSEY/2.0*LFTRGH)
	FMPR A,PROJR
	FMPR B,PROJR
	FADR A,D		;X OFFSET DUE TO EYE POSITION
	SKIPN CAMERR
	JRST NDFXSC		;CAMERA NOT USED NOW
.F ,,,(1.0-FDIS/DOBJ)*CRAT
	FSBR A,D
	FMPR A,CAMMAG
	FMPR B,CAMMAG
NDFXSC:	FMPR A,DSPSCQ		;CONVERT MM TO SCOPE UNITS
	FMPR B,DSPSCQ
	FIX B
	FIX A
	ADD B,XDCN		;ADD TO CENTRE OF SCREEN
	ADD C,YDCN
	SKIPN MVRFLG
	POPJ P,
	MOVE A,POTDAT+7		;OFFSET BY AMOUNT INDICATED BY POT(7)
	LSH A,-2
	SUBI A,1000
	ADD B,A
	POPJ P,

MVRFLG:	0	;OFFSET BY POTDAT+7 IF ON


REHIR:	CAML C,MINSR
	POPJ P,
	CAMG C,MINST
	POPJ P,
	SKIPL C
	MOVE C,MINSR
	SKIPG C
	MOVE C,MINST
	POPJ P,

CHNAPR:	;CHANGE APPEARANCE OF OBJECT ROTATE, ENLARGE ,MOVE
.F AVCT(0)=,AVCT(1)=,AVCT(2)=
.F (ROTER(0)*AVCT(0)+ROTER(1)*AVCT(1)+ROTER(2)*AVCT(2))*SIZEC+ADSM(0),$
.F (ROTER(3)*AVCT(0)+ROTER(4)*AVCT(1)+ROTER(5)*AVCT(2))*SIZEC+ADSM(1),$
.F (ROTER(6)*AVCT(0)+ROTER(7)*AVCT(1)+ROTER(8)*AVCT(2))*SIZEC+ADSM(2)
	POPJ P,î

RPPS:	60.	;REPEAT SLEEP IF NOTHING HAPPENS
PAUSE:	8	;SLEEP PERIOD
NOCMRS:	1	;NON-ZERO TO AVOID RESETTING CAMERA HACK

;DSPCRI IS 0 AND 1 FOR ALTERNATE OUTPUT DISPLAYS, 2 FOR HEADINGS

GANDRV:	SETOM IGNPOT	;IGNORE POTS
GUNDRV:	SETOM TYPED	;DO A SINGLE DISPLAY
	JRST .+2
GENDRV:	SETZM TYPED
.I QITADR=#GANDON
	SETZM POTFLS
	SKIPN NOCMRS	;
	SETZM CAMERR
GENDR1:	PUSHJ P,STRSWD	;GENERATE THE TWO DISPLAY ARRAYS
	PUSHJ P,OPNPOT	;OPEN POTS
	MOVEI Z,0
.I ARYCLR<DSPARY,ESCSTP>
	Q DISIN2
.I DISAAD<DSPARY>
	JRST UNCHN1

RADPOT:	MOVE Z,RPPS	;REPEAT SLEEPING
UNCHND:	MOVE A,PAUSE
	SKIPE FAST
	MOVEI A,1
	SKIPN TYPED
	.SLEEP A,
	SETZM IGNPOT
	SKIPE TYPED
	JRST GANDON
UNCHN1:	SKIPE IGNPOT
	JRST UNAGN
	PUSHJ P,REDPOT	;READ POTS - SKIPS IF CHANGED
	SOJGE Z,UNCHND	;NOTHING HAPPENED, SLEEP AGAIN
	SKIPE CARDAT
	PUSHJ P,HNGINT	;WAIT FOR POTS TO SETTLE
UNAGN:	PUSHJ P,RAUS
	JRST RADPOT	;GO IT AGAIN

GANDON:	SETZM QITADR
	PUSHJ P,CLOPOT
.I ARYDEL<DSPARY>
	SO DSPARY
.I DSPSEL<1-DSPCRI>
	POPJ P,

HNGINT:	PUSHJ P,@HEADF	;REPEAT HEADING
	MOVE A,PAUSE
	SKIPE FAST
	MOVEI A,1
	.SLEEP A,
	PUSHJ P,REDPOT
	POPJ P,		;UNCHANGED
	SKIPE TYPED
	POPJ P,
	JRST HNGINT

CARDAT:	0	;WAIT FOR POTS TO SETTLE IF ON
IGNPOT:	0	;IGNORE POTS IF ON

RAUS:	PUSHJ P,EYESTP	;CHANGE ROTATION MATRIX
	PUSHJ P,@HEADF	;GENERATE HEADINGS, FRAMES ETC
	PUSHJ P,@CALLF	;GENERATE GRAPH
SWPSWD:	PUSHJ P,DISGO	;COMPLETE AND PUT ON DISPLAY LIST
.I DSPSEL<1-DSPCRI>	;SWITCH TO OTHER DATA
.I DISIN2<DSPARY>	;REINITIALISE
	MOVE A,DSPARY
	JRST DISAFL	;REMOVE ONE FROM DISLIS

POTTER:	PUSHJ P,DCLEAR
.I DISINS<DSPARY>
	SETZM TYPED
	PUSHJ P,OPNPOT
	PUSHJ P,ADISON
RAVAG:	PUSHJ P,REDPOT
	SKIPA
	PUSHJ P,DISGRL
	SKIPN TYPED
	JRST RAVAG
	JRST CLOPOT

HEDBRT:	7	;HEADING BRIGHTNESS

DISGRL:	PUSH P,DSPCRI	;ONE TYPE OF HEADING
.I DSPSEL<2>
	SKIPGE A,DSPARY
	PUSHJ P,DISINS
	PUSHJ P,DISIN2
.I DSPPNZ<,0,0>
	MOVE W,HEDBRT
	PUSHJ P,DSPBRT
	SKIPE FRAMSW
	PUSHJ P,FRAME	;GENERATE FRAME
	SKIPE HEADSW
	PUSHJ P,TLKPOT
	PUSHJ P,DISGO
	POP P,A
	JRST DSPSEL

TLKPOT:
.I TALK<#POTPNT,MESSX,MESSY>
	POPJ P,

RGHEYE:	MOVE A,[1.0]
	JRST .+2	;SKIPA
LFTEYE:	MOVE A,[-1.0]
.I CAMERR=LFTRGH=
	SETZM TYPED
	PUSHJ P,RAUS
.I LFTRGH=CAMERR
	QUERY OK
	PUSHJ P,GENDR1
PHOTO:	MOVEI A,1
BLTPHO:	.NDIS A,
	JFCL
	MOVNI A,1
	.NDIS A,	;WAIT FOR IT
	QUERY READY
	JRST OPNDIS	;RETURN TO TOP LEVEL
	SKIPE HEADF
	PUSHJ P,HEADF@	;REDO HEADING
	MOVE A,REPET
	JRST BLTPHO	;DO ANOTHER EXPOSURE

DLTCRN:	20.	;CORNER SIZE

LFTFRM:
.I DSPPNI<,DLTCRN,0>
.I DSPVCA<,0,0>
.I DSPVCA<,0,DLTCRN>
.I DSPPNI<,0,1777-DLTCRN>
.I DSPVCA<,0,1777>
.I DSPVCA<,DLTCRN,1777>
	POPJ P,

RGHFRM:
.I DSPPNI<,1777,1777-DLTCRN>
.I DSPVCA<,1777,1777>
.I DSPVCA<,1777-DLTCRN,1777>
.I DSPPNI<,1777-DLTCRN,0>
.I DSPVCA<,1777,0>
.I DSPVCA<,1777,DLTCRN>
	POPJ P,

POTTRK:	PUSHJ P,OPNPOT
	SETZM TYPED
MUMPOT:	PUSHJ P,REDPOT
	PUSHJ P,DISGRL
	SKIPE TYPED
	JRST CLOPOT
	MOVEI A,3
	.SLEEP A,
	JRST MUMPOT

IDENTY:	1.0?0?0?0?1.0?0?0?0?1.0	;IDENTITY MATRIX

PITCH:	0	;OMEGA	-RED FROM POTS
YAW:	0	;PHI
ROLL:	0	;KAPPA


SETROT:	MOVE A,[IDENTY,,ROTER]	;RESET OBJECT ROTATION TO NOTHING
	BLT A,ROTER+8.
.F PITCH=ROLL=YAW=0
.F DSEY=0
	POPJ P,

EYESTP:
IFN LIBRAR,[
ROTCHN:		;ALTERNATE OBJECT ROTATION GENERATOR
;	PITCH FIRST (X-AXIS),THEN YAW (Y-AXIS), THEN ROLL (Z-AXIS)
.F CPIT'=COS<PITCH>, SPIT'=SIN<PITCH>
.F CYAW'=COS<YAW>,   SYAW'=SIN<YAW>
.F CROL'=COS<ROLL>,  SROL'=SIN<ROLL>

.F ROTER(0)=CROL*CYAW
.F ROTER(1)=CROL*SYAW*SPIT-SROL*CPIT
.F ROTER(2)=CROL*SYAW*CPIT+SROL*SPIT

.F ROTER(3)=SROL*CYAW
.F ROTER(4)=SROL*SYAW*SPIT+CROL*CPIT
.F ROTER(5)=SROL*SYAW*CPIT-CROL*SPIT

.F ROTER(6)=-SYAW
.F ROTER(7)=CYAW*SPIT
.F ROTER(8)=CYAW*CPIT

	POPJ P,
]
	.VALUE	;ROTCHN WAS NOT ASSEMBLED IN

OPNPOT:	JFCL		;UNTIL ITS FIXED ?#?
	.OPEN IMPC,IMPOPN	;OPEN INPUT MULTIPLEXOR
	STOP _POTS WON'T OPEN
	WIPE POTSAV,POTNMB
	POPJ P,

CLOPOT:	JFCL		;UNTIL ITS FIXED ?#?
	.CLOSE IMPC,
	POPJ P,

IMPOPN:	2,,(SIXBIT/IMX/)
	0
	0

OFSAT:	0	;RANDOM PLACE FOR LAST POT
POTSNM:	36?37?24?23?25?26?27?22
POTNMB:	.-POTSNM	;USUAL NUMBER OF POTS
FSTNMB:	4		;NUMBER READ IN FAST MODE
POTSAV:	BLOCK 10	;SAVED POT-READINGS
POTDAT:	BLOCK 10	;INPUT DATA
FAST:	0	;NON-ZERO FOR FAST DISPLAYING
FINEP:	0	;NON-ZERO FOR FINE POT CONTROL
PTNISE:	12	;ACCEPTABLE POT NOISE
FREEZE:	0	;NON-ZERO TO DISALLOW POTS TO VARY

TWPP=4.0
TWPN=-TWPP
POTMN:	TWPN?TWPN?TWPN?-1.0?-1.0?-1.0?-1.0?-128.0
POTMX:	TWPP?TWPP?TWPP?100.0?300.0?1200.0?120.0?128.0

TWPF=1.5
TWNF=-TWPF

POTFMN:	TWNF?TWNF?TWNF?50.0?100.0?500.0?50.0?-64.0	
POTFMX:	TWPF?TWPF?TWPF?200.0?200.0?1000.0?75.0?64.0

POTADD:	PITCH?YAW?ROLL?SIZEC?FDIS?DOBJ?DSEY?OFSAT

REDPOT:	JFCL		;UNTIL ITS FIXED ?#?
	SKIPE FREEZE	;FREEZE MEANS IGNORE POTS
	JRST APOPJP
	SETZM POTCHN'
	COPY POTDAT,POTSNM,POTNMB
	MOVEI A,POTDAT
	MOVN B,POTNMB
	SKIPE FAST	;DO NOT READ ALL POTS IN FAST MODE
	MOVN B,FSTNMB
	HRL A,B
	.IOT IMPC,A

	MOVE G,POTNMB
	SKIPE FAST
	MOVE G,FSTNMB
	SOS G
LPDPO:	SKIPG POTDAT(G)	;-1 IF HARDWARE OR SYSTEM LOST
	JRST NLDPA
.I ABS<POTDAT(G)-POTSAV(G)>-PTNISE
	JUMPG A,VALCHP
NLDPA:
.I POTDAT(G)=POTSAV(G)
	JRST NLDPO
VALCHP:	AOS POTCHN
	SKIPN FINEP
	JRST COARSE
.F POTADD@(G)=FFLOAT<POTDAT(G)>/4096.0*(POTFMX(G)-POTFMN(G))+POTFMN(G)
	JRST NLDPO
COARSE:
.F POTADD@(G)=FFLOAT<POTDAT(G)>/4096.0*(POTMX(G)-POTMN(G))+POTMN(G)
NLDPO:	SOJGE G,LPDPO
	COPY POTSAV,POTDAT,POTNMB
	SKIPE POTCHN
APOPJP:	AOS (P)
	POPJ P,
	
POTFLS:	0	;ONE TO FLUSH ROTATION PARAMETERS

POTPNT:	PRINT  
IFN STMPIT,[
	PUSHJ P,STAMP		;DISPLAY PARAMETERS
]
	SKIPE HEADIN
	PUSHJ P,@HEADIN
	SKIPE POTFLS
	POPJ P,
.F PITCH,YAW,ROLL,SIZEC
	PRINT _ PITCH=%1F2.3  YAW=%2F2.3  ROLL=%3F2.3 MAG=%4F3.1
.F FDIS,DOBJ,DSEY
	PRINT _ DIMG=%1F4.1  DOBJ=%2F4.1  EYES=%3F4.1_
	POPJ P,
]
IFN MOVFLG,[

FRAMEN:	PUSHJ P,FRAME	;EXPOSE C(A) FRAMES
	SOJG A,.-1
	POPJ P,

FRAME:	PUSHJ P,OPEN	;EXPOSE ONE FRAME
	PUSH P,A
	MOVE A,REPAT
	.NDIS A,	;DISPLAY REPEAT TIMES
	JRST .-1	;IN CASE NDIS DIDN'T WIN
	MOVNI A,1
	.NDIS A,	;HANG UNTIL DONE
	POP P,A
CLOSE:	SKIPN SHUTTR
	POPJ P,		;ALREADY CLOSED
	SETZM SHUTTR
	JRST OPNCLS

OPEN:	SKIPN STOPPE
	SKIPE SHUTTR
	POPJ P,		;ALREADY OPEN OR STOPPED SET
	SETOM SHUTTR
OPNCLS:	PUSH P,A
	PUSH P,B
	MOVEI A,50.	;25. COMPLETE 4 STEP CYCLES = 1/2 REVOLUTION
	SETZM MOTOR	;TO AVOID REVERSING ON QUIT
OPCLLP:	MOVEI B,100
	PUSHJ P,YANKM
	MOVEI B,200
	PUSHJ P,YANKM
	SOJG A,OPCLLP
	AOS NHREVS	;INCREMENT HAL-REV COUNTER
	JRST POPBJ

YANKM:	XORB B,MOTOR
	DATAO 760,B	;OUTPUT GREY CODE TO MOTOR
	MOVE B,TIMSUP
	SOJG B,.	;WAIT APPROPRIATE TIME FOR DATAO TO SETTLE
	POPJ P,

SHUTTR:	0	;0 = SHUTTR CLOSED, -1 = SHUTTER OPEN
MOTOR:	0	;LAST DATAO TO MOTOR
NHREVS:	0	;NUMBER OF HALF REVOLUTIONS SINCE START
STOPPE:	0	;NON-ZERO = NO MORE EXPOSURES
TIMSUP:	1000	;1000 FOR PDP-10, 440 FOR PDP-6
REPAT:	1	;HOW MANY TIMES DISLIS IS DISPLAYED

]
IFN GPHFLG,[

;;DPNT

DOPT:	SKIPA C,[10]	;OUTPUT AN OCTAL NUMBER
DDPT:	MOVEI C,10.	;OUTPUT A DECIMAL NUMBER
ANPNT:	CAIE C,10.	;OUTPUT A NUMBER
	JRST DOPT3
	PUSHJ P,DOPT3
	MOVEI A,".	;DECIMAL POINT
	JRST (U)	;CALL HIS OUTPUT ROUTINE

DOPT3:	JUMPGE A,DOPT1	;JUMP IF POSITIVE, ELSE OUTPUT -
	PUSH P,A
	MOVEI A,"-
	PUSHJ P,(U)
	POP P,A
	MOVNS A
DOPT1:	IDIVI A,(C)
	HRLM B,(P)	;SQUEZE A DIGIT ONTO PDL
	SKIPE A
	PUSHJ P,DOPT1	;RECURSIVE CALL TO STACK MORE DIGITS ON PDL
	HLRZ A,(P)	;DROP A DIGIT OFF PDL
	ADDI A,"0
	JRST (U)	;CALL HIS OUTPUT ROUTINE


LHINT:	TLC A,<233-1-18.>*1000	;CONVERT TO FLOATING FOR PRINTOUT
	FAD A,A
	JRST FPFP

;;FP

FPFP:	MOVE V,A	;OUTPUT A FLOATING POINT NUMBER
	CLEARB W,C	;W 0 ->E- 1 ->E+
	JUMPG V,FPFP1
	JUMPE V,FPFP3
	MOVNS V
	MOVEI A,"-
	TLZE V,400000
	JRST FPFP3
FPOUT:	PUSHJ P,(U)
FPFP1:	MOVEI A,"#
	TLNN V,400	;NORMALISED ?
	XCT FPOUT	;NO, TYPE # FIRST
	CAMGE V,FPFT01
	JRST FPFP4	;<.1
	CAML V,FPFT8
	AOJA W,FPFP4	;>=10^8

;DROP THRU ON DIGIT NEXT TO DECIMAL PT SIG PRNT # W/O E

FPFP3:	CLEARB D,X	;CLEAR DIGIT CNTR, X TO RECEIVE FRAC
	MULI V,400	;MANTISSA TO W
	ASHC W,-243(V)	;FRACTION PART IN X
	MOVE V,W
	PUSHJ P,FPFP7	;PRINT INTEGER PART
	MOVEI A,".	;# DIGITS OUTPUT IN D
	XCT FPOUT
	MOVNI C,10
	ADD C,D
	MOVE W,X

FPFP3A:	MOVE V,W	;PRINT FRACTION PART
	MULI V,12
	MOVE A,V
	PUSHJ P,FPFP7B
	SKIPE W
	AOJL C,FPFP3A
	POPJ P,

FPFP4:	MOVNI X,6	;DIGIT NEXT TO DECIMAL NOT SIG PRINT WITH E
	MOVEI B,0	;W 0 GENERATE E- 1 E+
FPFP4A:	ADDI B,1(B)
	XCT FPFCP(W)
	TRZA B,1
	FMPR V,@FPFCP+1(W)
FPFP4B:	AOJN X,FPFP4A
	PUSH P,B
	PUSH P,EXPSGN(W)
	PUSHJ P,FPFP3	;# NORMALIZED
	MOVEI A,"E
	XCT FPOUT
	POP P,A
	XCT FPOUT
	POP P,V		;DROP THRU AND PRINT EXPONENT
FPFP7:	JUMPE V,FPFP71	;AVOID INCR D, NOT SIGNIFICANT DIGIT
	IDIVI V,12
	AOS D
FPFP7A:	HRLM W,(P)
	JUMPE V,FPFP71
	PUSHJ P,FPFP7

FPFP71:	HLRE A,(P)
FPFP7B:	ADDI A,60
	XCT FPOUT
	POPJ P,

;ALL THOSE XCT FPOUT'S SEEM TO BE LOSS

	1.0^32.
	1.0^16.
FPFT8:	1.0^8
	1.0^4
	1.0^2
	1.0^1
FPFT:	1.0^0
	1.0^-32.
	1.0^-16.
	1.0^-8
	1.0^-4
	1.0^-2
FPFT01:	1.0^-1
FPFT0:
FPFCP:	CAMLE V,FPFT0(X)
	CAMGE V,FPFT(X)
	X,,FPFT0

EXPSGN:	"-
	"+

;;;LNDV

;GHXOR:	1740	;RH ORG FOR GRAPH
;GHYOR:	40	; " "
;GHDSP:	40	;V SPACE BETWEEN LINK LINE + GRAPH Y AXIS
;LNGHH:	300	;HEIGHT OF GRAPH
;FLNGHH:	300.0'	;SAME F.P.
;LNGHS:	400	;SPACING OF GRAPHS
;GHSCL:	0	;0 AUTO .NE. 0 AUTO SCALE FOR GRAPHS L.H. INTEGER POTTED
;GHSCLE:	0	;EFFECTIVE SCALE
;GHLXR:	0	;COMPUTED Y OF GRPH ORG
FPNBF:	BLOCK 5	;BUFFER FOR FLOATING PT NOS
FPNBFP:	0	;BYTE POINTER INTO FPNBF
DFPCNT:	0	;COUNT OF ...
;DGYOR:	0	;Z ORG OF DOT GRAPH

DPTDS:	MOVEI D,1	;DECIMAL RIGHT ADJUST
	JRST DPTDS1

OCTDS:	TDZA D,D	;OCTAL
FPDIS:	MOVEI D,2	;FLOATING
DPTDS1:	TDZA U,U	;RIGHT ADJUST
DPTS2:	MOVNI U,1	;NO RIGHT ADJ JUST KEEP TRACK OF CHRS
	MOVEM U,RADJSW	;SAVE ADJUST OR NOT FLAG
	MOVE D,FPDTB(D)
	MOVEM D,FPDSW	;REMEMBER FLAVOUR OF NUMBER
	MOVE D,[440700,,FPNBF]	;DISPLAY FLT PT NO IN A SO IT IS RIGHT ADJ AT COORDS
	MOVEM D,FPNBFP	;IN B AND C
	PUSH P,C
	PUSH P,B
	MOVEI U,DFPST1
	CLEARM DFPCNT
	PUSHJ P,@FPDSW
	POP P,B
	POP P,C
	MOVNI A,6*2	;SCALE *6PTS/CHR
	IMUL A,DFPCNT
	SKIPGE RADJSW
	JRST DFPST2
	ADD B,A
	MOVEM B,DFPXCR	;SAVE MIN X COORD ACTUALLY USED
DFPST3:	MOVEI A,0
	IDPB A,FPNBFP
	MOVEI A,FPNBF
	JRST DSPMSG	;OUTPUT ON DISPLAY USING MESSAGE ROUTINE

DFPST2:	SUB A,B
	MOVMM A,DFPXCR
	JRST DFPST3

DFPST1:	IDPB A,FPNBFP
	AOS DFPCNT
	POPJ P,

FPDSW:	0	;ENTRY TO PRINT ROUTINE

FPDTB:	DOPT	;OCTAL		0
	DDPT	;DECIMAL	1
	FPFP	;F.P.		2
	LHINT	;LEFT HAND INT	3

DFPXCR:	0	;MIN X COORD ACTUALLY USED OR MAX IF NOT RIGHT ADJ
RADJSW:	0	;RIGHT ADJ IF -1

;;GPH

;CALL TO GPHMK

;;JSP T,PHMK

;WD0  ORG Y,,ORG X - 4.9, 2.9 =0 ABSOLUTE, =1 MEAN RELATIVE TO MAX X, Y
	;4.8 =0 USE DOTS, =1 CONNECT POINTS WITH LINES

;WD1 MAX X, OR IF 4.9 =1 ADR OF ROUTINE TO GET MAX X (RET IN A)
	;4.8 =0 ABSOLUTE, =1 RELATIVE TO ORG X
	;4.7 =0 DATA DIRECT, =1 DATA IMMEDIATE
	;4.6-4.4 DATA TYPE: 0 FIXED OCTAL, 1 FIXED DECIMAL, 2 F.P., 3 LH INT
	;4.3 =0 ORG IS 0,  =1 ORG IS MIN OF DATA
;WD2 MAX Y ETC

;WD3 AOBJN PTR TO HORIZ DATA (IMMEDIATE OR NOT AS PER 4.7 WD2)
;WD4 AOBJN PTR TO VERTL DATA

;WD5 HORIZ LIMIT LABELLING
	;4.9 =1 ADD OF ROUTINE WHICH RETURNS MIN, MAX IN A, B
	;4.8 =1 NORMAL LABELING
	;WHOLE WD=0 NO LABELLING
;WD6 VERTL LIMIT LABELLING

;WD7  HORZ AXIS LABEL (PNTR TO ASCIZ) OR 0 IF NONE
;WD10 VERT AXIS LABEL

;WD11 HORIZ TRANSF FUNCTN (DATA IN AND OUT IN A), 0 IF NONE
;WD12 VERTL TRANSF FUCNTN

GPHMK:	SKIPGE 3(T)
	SKIPL 4(T)
	JRST 13(T)	;ONE AXIS NULL
	MOVEM Z,GPHAC+Z
	MOVEI Z,GPHAC
	BLT Z,GPHAC+Z-1	;SAVE ALL ACS

	MOVEI W,0
	PUSHJ P,DSPSIZ	;SIZE 0 FOR AXIS

	SKIPGE A,1(T)	;COMPUTE XMAX
	PUSHJ P,(A)
	MOVE Y,1(T)
	TLNE Y,200000
	ADD A,(T)	;RELATIVE TO X-ORG
	ANDI A,1777	;LIMIT IT
	HRRZM A,GPHMX	;X COORD OF + END X AXIS

	SKIPGE A,2(T)	;COMPUTE YMAX
	PUSHJ P,(A)
	MOVE Y,2(T)
	TLNN Y,200000
	JRST GPH1
	HLRZ Z,(T)
	ADD A,Z		;RELATIVE TO Y-ORG
GPH1:	ANDI A,1777	;LIMIT IT
	HRRZM A,GPHMY	;Y COORD OF + END OF Y-AXIS

	MOVE Y,(T)
	LDB A,[1300,,Y]	;EXTRACT PURE X ORG
	TRNE A,2000
	ORCMI A,1777	;EXTEND SIGN
	TRNE Y,400000
	ADD A,GPHMX	;ORG WAS RELATIVE TO X-MAX
	ANDI A,1777	;LIMIT IT
	MOVEM A,GPHXO	;X COORD OF ORIG

	LDB A,[221300,,Y]	;EXTRACT PURE Y ORG
	TRNE A,2000
	ORCMI A,1777	;EXTEND SIGN
	TLNE Y,400000
	ADD A,GPHMY	;ORG WAS RELATIVE TO Y-MAX
	ANDI A,1777	;LIMIT IT
	MOVEM A,GPHYO	;Y COORD OF ORIG

.I DSPPNI<,GPHMX,GPHYO>	;TIP OF X-AXIS
.I DSPVCA<,GPHXO,GPHYO>	;TO ORIGIN
.I DSPVCA<,GPHXO,GPHMY>	;TO TIP OF Y-AXIS

	MOVEI W,20
	PUSHJ P,DSPSIZ	;SIZE 1 CHRS FOR LABELS

	HLLZ V,5(T)	;MASK OUT ROUTINE ADR TO GET 0 IF NO LABELLING
	MOVE W,1(T)
	CLEARM GPHHBF	;HORZ DATA BACKWARDS FLAG
	JUMPL V,GPH3	;TRANSFER TO FUNCT ARG
	TLNE W,100000
	JRST GPH3B	;DATA IMMEDIATE
	PUSHJ P,GPHDDS	;DATA DIRECT FIND MAX AND MIN RET IN B,A
GPH3A:	TLNN W,4000
	MOVEI A,0	;SET ORG VAL TO 0
	MOVEM A,GXDMIN	;DATA VALUE OF ORG
	MOVEM B,GXDMAX	;DATA VALUE OF FULL Y DEFLECTION

	MOVE A,GPHMX
	MOVE B,GPHXO
	JUMPE V,GPH2A	;NO HORZ LIMIT LABELS

.I DSPPNZ<,GPHXO+GPHCHS,GPHYO-21.>	;POSITION FOR LOW HORZ LABEL
	PUSHJ P,MODCHR
	LDB D,[360300,,1(T)]	;DATA TYPE
.I DPTS2<GXDMIN>
.I GXLLR=DFPXCR			;X COORD OF HIGH END OF LABEL
	LDB D,[360300,,1(T)]	;DATA TYPE
.I DPTDS1<GXDMAX,GPHMX,GPHYO-21.>	;HIGH HORIZ LABEL - RIGHT ADJ
	SKIPA A,DFPXCR
GPH2A:	MOVEM B,GXLLR
	MOVEM A,GXULL	;LEFT COORD OF LABEL

	MOVE A,GPHYO	;WHAT ? B ?
	MOVE A,GPHXO	;SET COORD IN CASE NO Y LBL

	HLLZ V,6(T)	;MASK OUT ROUTINE ADDRESS TO GET 0 IF NO LABELLING
	MOVE W,2(T)
	CLEARM GPHVBF	;VERT DATA BACKWARDS FLAG
	JUMPL V,GPH5	;TRANSFER TO FUNCT ARG
	TLNE W,100000
	JRST GPH5B	;DATA IMMEDIATE
	AOS T		;SWITCH TO Y
	PUSHJ P,GPHDDS
	SOS T		;RESTORE T
GPH5A:	TLNN W,4000
	MOVEI A,0	;SET ORG VALUE TO 0
	MOVEM A,GYDMIN
	MOVEM B,GYDMAX

	MOVE A,GPHXO
	JUMPE V,GPH4A
	LDB D,[360300,,2(T)]	;DATA TYPE
.I DPTDS1<GYDMIN,GPHXO,GPHYO+GPHCHS>
.I ,,,GPHXLO=DFPXCR
	LDB D,[360300,,2(T)]	;DATA TYPE
.I DPTDS1<GYDMAX,GPHXO,GPHMY>
	MOVE A,DFPXCR
	CAMGE A,GPHXLO	;SELECT MAX EXCURSION IN -Y DIR
GPH4A:	MOVEM A,GPHXLO	;Y ORG OF AXIS LABEL IF WONT FIT BETWEEN LIMIT LABELS

	SKIPN A,7(T)
	JRST GPH6	;NO HORIZ LABEL
	PUSHJ P,GHPCHC	;COUNT CHRS IN LABEL
.I ,,GXULL-GXLLR-B	;B HAS REQUIRED SPACE
	JUMPGE C,GPH4C	;WILL FIT ?
	MOVE C,GPHMX	;TRY TO CENTER BETWEEN ENDS OF AXIS AND DOWN
	SUB C,GPHXO
	SUBM C,B
GPH4D:	ASH B,-1
	SKIPGE B
	MOVEI B,0
	ADD B,GPHXO
	ADDI B,6*2*2
	MOVE C,GPHYO
	SUBI C,30.
	HRRZ A,7(T)
	PUSHJ P,DSPMSG	;OUTPUT X-LABEL VIA MESSAGE ROUTINE

GPH6:	SKIPN A,10(T)
	JRST GPHP	;NO VERT LABEL
	PUSHJ P,GHPCHC
.I ,,GPHMY-GPHYO-B
	SKIPL C
	SKIPA B,GPHXO	;IT FITS
	MOVE B,GPHXLO
	ASH C,-1
	SKIPGE C
	MOVEI C,0
	ADD C,GPHYO
	SUB B,GPHCHS
	ADDI C,30.
	PUSHJ P,DSPPNZ
	PUSHJ P,MODCHR
.I DTYOA<36>	;GO OUT
.I DTYOA<76>	;CHANGE TO VERTICAL CHARACTERS
.I DTYOA<35>	;GO IN
	HRRZ A,10(T)
	PUSHJ P,DSPTXT	;OUTPUT Y LABEL VIA TEXT ROUTINE
.I DTYOA<36>	;GO OUT
.I DTYOA<74>	;CHANGE BACK TO HORIZONTAL CHARACTERS
.I DTYOA<35>	;GO IN

GPHP:	SETOM VECONN	;FIRST PNT FLAG
	LDB F,[360300,,1(T)]	;DATA TYPE
.I GXDMIN=GPHFPC<GXDMIN>	;CONVERT DATA MIN TO FLOATING IF NECC
.F GPHFPC<GXDMAX>-GXDMIN
	MOVE W,1(T)
	TLNN W,100000
	JRST GPHPA	;DATA DIRECT
	CLEARM GXDMIN
	HLRO A,3(T)	;GET COUNT FROM AOBJN
	MOVMS A
	SOS A		;N-1 PIECES
	FLOAT A
GPHPA:	MOVE C,GPHMX
	SUB C,GPHXO
	FLOAT C
	FDVR C,A
	MOVEM C,GPHHI	;HORIZ INCR PER DATA UNIT

	LDB F,[360300,,2(T)]	;DATA TYPE
.I GYDMIN=GPHFPC<GYDMIN>	;CONVERT DATA TO FLOATING IF NECC
.F GPHFPC<GYDMAX>-GYDMIN
	MOVE W,2(T)
	TLNN W,100000
	JRST GPHPB	;DATA DIRECT
	CLEARM GYDMIN
	HLRO A,4(T)	;GET COUNT FROM AOBJN
	MOVMS A
	SOS A		;N-1 PIECES
	FLOAT A
GPHPB:	MOVE C,GPHMY
	SUB C,GPHYO
	FLOAT C
	FDVR C,A
	MOVEM C,GPHVI	;VERTICAL INCR PER DATA UNIT

	MOVE Y,3(T)	;HORZ AOBJN PTR
	MOVE Z,4(T)	;VERT AOBJN PTR
	HLRO A,Y	;X-COUNT
	HLRO B,Z	;Y-COUNT
	CAML A,B
	MOVE A,B	;A GETS - # PTS TO BE PLOTTED
	MOVNS A
	SKIPL GPHHBF
	JRST GPHPC
	ADDI Y,-1(A)	;MUST REF HORZ DATA BACKWARDS
	HRL Y,A		;STORE + COUNT
GPHPC:	SKIPL GPHVBF
	JRST GPHPD
	ADDI Z,-1(A)
	HRL Z,A
GPHPD:

GPHPL:	MOVE W,1(T)
	TLNE W,100000
	JRST GPHP1	;IMMED DATA
	MOVE A,(Y)	;DIRECT DATA
	SKIPE 11(T)
	PUSHJ P,@11(T)	;CONVERT DATA IF NECC (X-TRANSF)
GPHP2B:	LDB F,[360300,,1(T)]	;DATA TYPE
.F (GPHFPC<>-GXDMIN)*GPHHI
	FIX A
	ADD B,GPHXO
	PUSH P,B	;SAVE X COORD

	MOVE W,2(T)
	TLNE W,100000
	JRST GPHP4	;IMMED DATA
	MOVE A,(Z)	;DIRECT DATA
	SKIPE 12(T)
	PUSHJ P,@12(T)	;CONVERT DATA IF NECC (Y-TRANSF)
	LDB F,[360300,,2(T)]	;DATA TYPE
GPHP4B:
.F (GPHFPC<>-GYDMIN)*GPHVI
	FIX A
	ADD B,GPHYO
	MOVE C,B
	POP P,B		;SAVED X COORD

	MOVE W,(T)
	TLNE W,200000
	JRST GPHPL1	;USE LINES
	PUSHJ P,DSPPNI
GPHPL3:	SKIPGE GPHHBF
	JRST GPHPL5
	AOBJP Y,GPHPE

GPHPL4:	SKIPGE GPHVBF
	JRST GPHPL6
	AOBJN Z,GPHPL

GPHPE:	MOVSI Z,GPHAC
	BLT Z,Z		;RESTORE ACS - TIME TO GO HOME!
	JRST 13(T)

GPHPL5:	SUB Y,[1,,1]
	JUMPGE Y,GPHPL4
	JRST GPHPE

GPHPL6:	SUB Z,[1,,1]
	JUMPGE Z,GPHPL
	JRST GPHPE

GPH4C:	MOVE B,C
	JRST GPH4D


GPHP1:	HRRZ A,Y
	JRST GPHP2B

GPHP4:	HRRZ A,Z
	JRST GPHP4B

GPHPL1:	PUSHJ P,DSPVVP
	JRST GPHPL3


GPHFPC:	CAIN F,2
	POPJ P,		;ALREADY FLOATING
	CAIE F,3
	TLCA A,232000
	TLC A,<233-1-18.>*1000
	FAD A,A
	POPJ P,

GPH3:	PUSHJ P,@5(T)	;GO TO X-LABELLING ROUTINE MIN,MAX IN A,B
	CAMG A,B
	JRST GPH3A
	SETOM GPHHBF	;SET BACKWARD HORIZONTAL
	EXCH A,B
	JRST GPH3A

GPH3B:	HRRZ A,3(T)	;IMMEDIATE DATA FINDER
	HLRE B,3(T)
	MOVNS B
	ADD B,A
	JRST GPH3A

GPH5:	PUSHJ P,@6(T)	;GO TO Y-LABELLING ROUTINE MIN,MAX A,B
	CAMG A,B
	JRST GPH5A
	SETOM GPHVBF	;SET BACKWARD VERTICAL
	EXCH A,B
	JRST GPH5A

GPHDDS:	MOVSI B,(SETZ)
	HRLOI D,377777
	MOVE C,3(T)	;PICK UP AOBJN PTR
GPHDD1:	MOVE A,(C)	;FIND MAX AND MIN IN DATA
	SKIPE 11(T)
	PUSHJ P,@11(T)	;CALL DATA CONVERT ROUTINE IF ANY
	CAMLE D,A
	MOVE D,A
	CAMGE B,A
	MOVE B,A
	AOBJN C,GPHDD1
	MOVE A,D
	POPJ P,

GPH5B:	HRRZ A,4(T)
	HLRE B,4(T)
	MOVNS B
	ADD B,A
	JRST GPH5A

GHPCHC:	MOVEI B,4	;MUST HAVE AT LEAST 4 CHRS EXTRA ROOM
	HRLI A,440700
GHPCH1:	ILDB C,A
	JUMPE C,GHPCH2
	AOJA B,GHPCH1	;COUNT CHARACTERS IN LABEL
GHPCH2:	IMULI B,6*2	;SIZE OF CHR
	POPJ P,

GXDMIN:	0	;MIN DATA IN X DIR
GXDMAX:	0	;MAX
GYDMIN:	0	;MIN DATA IN Y DIR
GYDMAX:	0	;MAX
GPHXO:	0	;X COORD OF ORG
GPHYO:	0	;Y COORD OF ORG
GPHMX:	0	;X COORD OF + END X AXIS
GPHMY:	0	;Y COORD OF + END Y AXIS
;GPHT1:	0	;TEMP
GPHCHS:	7*2	;CHR SIZ
GPHXLO:	0	;LOWEST X-COORD USED BY Y LIMIT LABELS
GXLLR:	0	;FARTHEST EXCURSION IN +X DIR BY LOWER X LABEL
GXULL:	0	;FARTHEST EXCURSION IN -X DIR BX UPPER X LABEL
GPHAC:	BLOCK Z+1	;SAVE AREA FOR ACS
;GPHFPF:	0	;-1 ON FIRST PNT
GPHHI:	0	;HORZ INCR PER DATA UNIT
GPHVI:	0	;VERT INCR PER DATA UNIT
GPHHBF:	0	;HORZ BACKWARD FLAG
GPHVBF:	0	;VERT 

]
