
	.title	MINITS -- a mini ITS for throwing together hardware
	.sbttl	MINITS -- a mini ITS for throwing together hardware
minvrs==%fnam2

;;; ;;; General info:
;;; ;;; 	The core system.  Not much here, just gets everything going and
;;; ;;; 	calls the scheduler. 

;;; major prefixes used in the module

	.sbttl	Initial code that should go first

;;; Install NULL trap vectors (in the hope that interrupts are edge triggered
;;; and  enough initial instructions will be executed to lock everybody out.
;;; Eventually, the default interrupt table will look like this (assuming the
;;; same repeat).
;;;   .word trptbl+<<.rpcnt/16.>*2>
;;;   .word 340+<.rpcnt&17>

.=0
.rept 1000/4
  .+2
  rti
.endr

.=400				;for those that remember old systems
	jmp minits

.=1000				;and even more recent systems
	jmp minits

.=1200				;before intstk was made to work.
	jmp minits		;Unfortunately, this does not give enough
				;of an interrupt stack, two frames are
				;enough to cause it to scribble over the
				;interrupt vectors

.=2200				;real starting address allows interrupt
				;vectors up to 776 and a large interrupt
				;stack

start:: go:: begin::		;make everybody happy
minits:	jmp minit1

pdl=minits-20

;;; How the trap table works, by PGA and AGRE: The trap table is
;;; initialized here to have 8 entries.  Each entry contains a trap
;;; instruction.  Practically the first thing the system does upon
;;; initialization is run the MINIT1 routine, which sets the interrupt
;;; vectors from 0 to 376 such that they point to one of the eight trap
;;; instructions in the trap table.  The interrupt vectors are initialized
;;; in blocks of 16.  Each vector in the nth block of 16 points to the nth
;;; word in the trap table.  The 4 condition bits in the processor status
;;; word associated with each interrupt vector in a particular block
;;; represent the location (0,1,2,...,15) of the interrupt vector and ps
;;; within that block.  (Actually, the original core image produced by the
;;; assembler follows this scheme from locations 0 to 776 by virtue of the
;;; first lines of the MINITS file (this file).  It would seem that the
;;; loader has its own ideas about some of the vectors below 400.  Thus the
;;; initialization routine resets them at runtime.)  Suppose a random
;;; interrupt is generated by the system (which is known to happen now and
;;; then on the unibus or q-bus). The system jumps to the appropriate
;;; interrupt vector, pushes the pc and the ps on the stack (old_pc,
;;; old_ps) and jumps to the trap table with the low four bits of the
;;; processor status set to the low four bits of the interrupt vector
;;; location.  The PC will contain the address+2 of the trap instruction in
;;; the trap table.  The low 3 bits of this address are used to indicate
;;; which interrupt vector block the interrupt fell in.  The trap
;;; instruction in the trap table is now executed, pushing pc and ps
;;; (magic_pc, magic_ps) on the stack.  The trap instruction traps to
;;; location 34 where the address of TRPBRK is placed in the pc and a
;;; priority of 6 is placed in the PS.  TRPBRK recovers the original
;;; interrupt vector from the stack (magic_pc, magic_ps).  Then it jumps to
;;; the debugger, if any (halts otherwise), and if the debugger should
;;; return, pops the original vector, and returns from the random
;;; interrupt.  Note that the configuration file often sets the "debugger"
;;; for the particular system being assembled to be the boot rom.


trptbl:	.rept 1000/4/16.
	trap
	.endr

;;; stack structure:
;;; 	old_ps
;;; 	old_pc
;;; 	magic_ps
;;; sp>	magic_pc

trpbrk:
	sub #trptbl+2,(sp)
	.rept 6-1
	asl (sp)
	.endr
	bic #mask4,2(sp)
	asl 2(sp)
	asl 2(sp)
	bis (sp)+,(sp)		;Never need to look at whats left of magic_pc.

;;; stack_structure:
;;; 	old_ps
;;; 	old_pc
;;; sp>	vector_interrupted_through

	mov r0,@#500		;Interlan debuggers don't have enough room
	mov r1,@#502		;to save the registers themselves.
	mov r2,@#504
	mov r3,@#506
	mov r4,@#510
	mov r5,@#512
	mov sp,@#514	

.if ndf dbugad
	jmp @#dbugad		;user defined it, but it isn't real yet
.iff
  .if z dbugad+1
	halt
  .iff
	jmp @#dbugad
  .endc
.endc
	pop *			;vector interrupted through
	rti

;;; Switch to interrupt stack if not already there.  Called by an
;;; interupt routine to start coroutining.  Interrupt routine exits
;;; by coroutining out.

.macro .intstk code
	call intstk
	code
	call @(sp)+
.endm

.wscalar $intstk

intstk:	tst $intstk		;already there?
	if ne,<			;yup
	  call @(sp)+
	  return
	  >
	lock 7			;nobody can stop us now
	  pop $intstk		;get old PSW here (everything masked, so safe)
	  mov sp,@#pdl-2	;save old stack
	  mov #pdl-2,sp		;and setup the interrupt stack
	  push $intstk		;reset PSW so we can unlock
	  mov #1,$intstk	;declare interrupt stack in use
	unlock			;interrupt can happen now
	push @pdl-2		;get caller's address from old stack
	call @(sp)+		;coroutine to it
	pop @pdl-2		;put caller's address in old stack
	lock 7			;about to switch out of interrupt stack
	  pop $intstk		;put old PSW here (everything masked, so safe)
	  pop sp		;get back old stack
	  push $intstk		;reset PSW for UNLOCKing
	  clr $intstk		;no longer in interrupt stack
	unlock
	return			;and finish this side of the coroutine


;;; Trap routine to handle bad memory references

.wscalar nxmadr
.wscalar old4
.wscalar old6

nxmcat:	mov @(sp),nxmadr
	add #2,(sp)
	mov @#4,old4
	mov @#6,old6
	mov #nxmtrp,@#4
	mov #pr7,@#6
	return

nxmtrp:	mov nxmadr,(sp)
	call nxmclr
	rti

nxmclr:	mov old4,@#4
	mov old6,@#6
	return

.wvector clock,2
time=clock
.wvector arptim,2		;arpa time (seconds since 01/01/00)
.wscalar arp60th		;sixtieths
.wscalar l2rqst			;somebody wants the low priority clock
				;queue run

.wscalar lkisup
lkini:	clr clock+0		;t0 and counting
	clr clock+2
	mov #60.,arp60th
	clr arptim+0
	clr arptim+2
	clr l2rqst
lkpwu:	mov #lkint,@#lkvec+0	;set the interrupt pc
	mov #pr6,@#lkvec+2	;priority 6 for interrupts
	call nxmcat
	 .word lknxm
	bis #lk.ien,@#lkcsr	;punch the CSR in the face
	call nxmclr
	mov #-1,lkisup		;declare CSR there
	return

lknxm:	clr lkisup		;declare CSR absent (and hope)
	return

lkint:	inc clock+0		;increment 32 bit number
	if eq,<inc clock+2>	;...
	dec arp60th
	if eq,<
	  mov #60.,arp60th
	  inc arptim+0
	  if eq,<inc arptim+2>>
	call sysclk		;tell the system the clock is ticking
	tst lkisup
	if ne,<			;only if CSR is really there
	  bis #lk.ien,@#lkcsr	;punch the CSR in the face (it's face is
				;going to hurt soon if he gets punched 60
				;times a second!!)
	  >

	push #lk.nxt
	call dolist		;do the high priority list
	
	bit #pr7,2(sp)		;did we interrupt somebody at priority zero?
	if eq,<			;yup, so do the lower priority queue
	  tst l2rqst
	  if ne,<
	    clr l2rqst		;clear the request flag
	    .intstk <		;while on the interrupt stack
	      lock 1		;drop priority to 1 (not zero)
	      push #l2.nxt
	      call dolist	;actually do the queue
	      unlock
	      >
	  > >

	rti

dolist:	push r5
	loop <
	  mov 4(sp),r5
	  exitl eq
	  call @2(r5)
	  mov @4(sp),4(sp)
	  rptl ne
	  >
	pop r5,(sp)
	return

lk.nxt==0
.macro .syclk name
	.word lk.nxt,name
	lk.nxt==.-4
.endm

l2.nxt==0			;this is the lower priority clock queue
.macro .sycl2 name
	.word l2.nxt,name
	l2.nxt==.-4
.endm

	.sbttl	Support inclusion

.wscalar junk			;random thinks can point here

;;; define the free storage manager
	$insrt fsm
;;; define the USER support routines
	$insrt user
;;; define system call support routines
	$insrt uuo
;;; define channel info
	$insrt channl

	.sbttl Real starting code

.wscalar sysup			;-1 <==> system is up and tasking

minit1:	reset			;BANG, kick everybody in the *ss
	spl 7			;and don't let them kick back
	clr sysup		;system is not, repeat NOT up yet
	mov #pdl,sp		;set up the stack pointer
	mov #1,$intstk		;running in the interrupt stack

	;;; initialize interrupt vectors to go through the bad interrupt
	;;; routine
	clr r0
	mov #trptbl,r1
	mov #1000/4/16.,r2
	loop <
	  mov #16.,r3
	  mov #340,r4
	  loop <
	    mov r1,(r0)+
	    mov r4,(r0)+
	    inc r4
	    sorl r3
	    >
	  add #2,r1
	  sorl r2
	  >

	mov #trpbrk,@#034	;initialize trap vector
	mov #pr6,@#034+2	;...

	push #fs$beg,#fs$end	;start and end of free storage
	call fsmini		;initialize the Free Storage Manager

	call uuoini		;initialize the system call handler
	call usrini		;initialize the user routines

	devini			;initialize devices

	mov #-1,sysup		;system now up and running
	jmp schnxt

.deshed==iot			;descheduling instruction

strlen:	push r0,r1
	mov 6(sp),r0
	mov #-1,r1
	loop <
	  inc r1
	  tstb (r0)+
	  rptl ne
	  >
	mov r1,6(sp)
	pop r1,r0
cpopj::
nopsub:	return			;no operation subroutine
	
upcase:	bic #mask7,2(sp)
	cmpb 2(sp),#'a
	if ge,<
	  cmpb 2(sp),#'z
	  if le,<
	    sub #<'a-'A>,2(sp)
	  > >
	return


.if g ntty
;;; define tty support
	$insrt tty
;;; and a command processor for the tty
	$insrt compro
.endc

;;; include support for the defined devices
	devfil

.iif nz %muldv, $insrt muldiv



;;; define the host string

hststr:	$host$

con...:	constants
con..e::
var...:	variables
var..e::

patch:	.pat:
	.blkw 40

fs$beg:


.if p2
.irp con...,\con...
.irp var...,\var...
.irp %patch,\patch
.irp %frees,\fs$beg
.irp %top,\fs$end
.irp %k,\<<<%top-%frees>/2>&077777>/2000
.print /
Constants area from con... to var...
Variables area from var... to %patch
Patch     area from %patch to %frees
Free Stor area from %frees to %top = %K (octal) K
/
.endm
.endm
.endm
.endm
.endm
.endm
.endc

.end minits

;;; local modes:
;;; mode:midas
;;; auto fill mode:
;;; fill column:75
;;; comment column:32
;;; end:
