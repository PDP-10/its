<PACKAGE "TASKM">

<ENTRY	ACKNOWLEDGE DEBUG-MODE NORMAL-MODE LIGHT-MODE
	RESCHEDULE-DEMON SETUP-INTERRUPT-HANDLERS
	SETUP-ERROR-INTERRUPT-HANDLER SETUP-SYSTEM-LOCATIONS
	START-RUNNING TASK-ABORT

	HELP-BOXES IN-DEBUG-MODE MY-USER-INDEX NQUEUES>

<USE	"BATCHN"	;"BATCH-SCRIPT BATCHQ-OBL FIND-NEXT-TASK INSERT-TASK
			  NAME-OF-SCRIPT READ-TASK-ACT REMOVE-TASK SOONEST-TIME
			  TASK-DESCRIPTOR UPDATE-QUEUE WRITE-TASK"
	"BATCHQ"	;"task descriptor atom names"

	"CHARAP"	;"CHARAPPEND CR"
	"DEMCLS"	;"SET-DEMON-STATUS"
	"DIR"		;"DISK-DATE"
	"ITS"		;"ITS-CALL ITS-EVAL ITS-GETLOC USET"
	"JOBASS"	;"JOB-GET-NUM"
	"JOBS"		;"JOB-KILL JOB-LOAD JOB-START JOB-STATUS JOB-STOP PASS-JCL-DOWN"
	"LSRHIL"	;"FULLNAME"
	"NOW"		;"NOW"
	"SQUOZE"	;"SQUOZE"
	"STR"		;"SIXTOS STRTOX"
	"TIMFCN"	;"BEFORE? DTADD DTDIFF DTNORM DTNOW HOLIDAY? PAST?"
	"TRANSL"	;"TRANSLATE TRANSLATE-CLEAR TRANSLATE-STY">

<GDECL	(HELP-BOXES) <VECTOR [REST STRING]>
	(OUR-PGFLTS SYS-PGFLTS LAST-CHECKED-TIME MY-USER-INDEX T-INF-PAGES
	 MY-INIT-PAGES SYS-INIT-PAGES N-RUNS				) FIX
	(*L *USIPRQ *USRTIM *USRTM1 *NSWXFR *NSRXFR *AUSOPG
	 *NFSTTY *NSTTYS *JNAME						) <OR FIX FALSE>
	(LAST-CHECK LOAD-REF1 LOAD-REF2 LOAD-REF3 LOAD-REF4 LOAD-REF5
	 T-INF-CPU T-INF-REAL MY-INIT-CPU-TIME SYS-INIT-CPU-TIME	) FLOAT
	(MY-INIT-REAL-TIME) LIST
	(STY-OPEN-FAIL) <OR FALSE <LIST FIX LIST>>>

<COND (<NOT <GASSIGNED? HELP-BOXES>>
       <SETG HELP-BOXES '[".BATCH"]>)>

;<'PACKAGE "TASKV">

;<ENTRY	INPUT-STRINGS OUTPUT-SCRIPTS OUTPUT-FILES
	JOB-CHANNELS JOB-ID-NUMBERS INFERIOR-NUMBERS
	JOB-SYSTEM-INDEXES STY-NUMBERS STY-INPUT-CHANNELS
	STY-OUTPUT-CHANNELS STY-INPUT-IHEADERS STY-OUTPUT-IHEADERS
	JCL-LINES DELIMITER-STRINGS SLEEP-INTERVAL
	SPECS-OF-JOBS HANG-COUNTS LAST-CPU-CHECKS
	OVERHD-REFS>

<GDECL	(INPUT-STRINGS)		<VECTOR [REST <OR FALSE STRING>]>
	(DELIMITER-STRINGS
	 JCL-LINES)		<VECTOR [REST STRING]>
	(HANG-COUNTS
	 STY-NUMBERS)		<UVECTOR [REST FIX]>
	(JOB-CHANNELS
	 STY-INPUT-CHANNELS
	 STY-OUTPUT-CHANNELS)	<VECTOR [REST <OR FALSE CHANNEL>]>
	(INFERIOR-NUMBERS
	 JOB-ID-NUMBERS
	 JOB-SYSTEM-INDEXES)	<VECTOR [REST <OR FALSE FIX>]>
	(LAST-CPU-CHECKS
	 OVERHD-REFS)		<UVECTOR [REST FLOAT]>
	(OUTPUT-FILES)		<VECTOR [REST <OR FALSE STRING CHANNEL>]>
	(OUTPUT-SCRIPTS)	<UVECTOR [REST <LIST FIX STRING STRING>]>
	(SPECS-OF-JOBS)		<VECTOR [REST <OR FALSE VECTOR>]>
	(STY-INPUT-IHEADERS
	 STY-OUTPUT-IHEADERS)	<VECTOR [REST <OR FALSE IHEADER>]>>

<GDECL (SLEEP-INTERVAL) FIX>

<SETG NQUEUES 2>
<MANIFEST NQUEUES>

<SETG INPUT-STRINGS
   <IVECTOR ,NQUEUES <>>>

<SETG OUTPUT-SCRIPTS
      <IUVECTOR ,NQUEUES
		'<LIST 0		;"count of output (script) chars"
		       <ISTRING 640 !\_>;"buffer of 640 chars (dump every 320)"
		       <ISTRING 0>	;"overflow string buffer">>>

<SETG OUTPUT-FILES
   <IVECTOR ,NQUEUES <>>>

<SETG JOB-CHANNELS
   <IVECTOR ,NQUEUES <>>>

<SETG JOB-ID-NUMBERS
   <IVECTOR ,NQUEUES <>>>

<SETG INFERIOR-NUMBERS
   <IVECTOR ,NQUEUES <> >>

<SETG JOB-SYSTEM-INDEXES
   <IVECTOR ,NQUEUES 0>>

<SETG STY-NUMBERS
   <IUVECTOR ,NQUEUES 0>>

<SETG STY-INPUT-CHANNELS
   <IVECTOR ,NQUEUES <>>>

<SETG STY-OUTPUT-CHANNELS
   <IVECTOR ,NQUEUES <>>>

<SETG STY-INPUT-IHEADERS
   <IVECTOR ,NQUEUES <>>>

<SETG STY-OUTPUT-IHEADERS
   <IVECTOR ,NQUEUES <>>>

<SETG JCL-LINES
   <IVECTOR ,NQUEUES "">>

<SETG DELIMITER-STRINGS
   <IVECTOR ,NQUEUES "">>

<SETG SLEEP-INTERVAL 60>

<SETG SPECS-OF-JOBS
   <IVECTOR ,NQUEUES <>>>

<SETG HANG-COUNTS
   <IUVECTOR ,NQUEUES 0>>

<SETG LAST-CPU-CHECKS
   <IUVECTOR ,NQUEUES 0.0>>

<SETG OVERHD-REFS
   <IUVECTOR ,NQUEUES 0.0>>

;<ENDPACKAGE>


;"This is the main entry to the task manager (top level function).  After
initializing the queue, batch calls START-RUNNING, which handles all task-
managing, then resets the wakeup time for the demon, and returns.

START-RUNNING initializes some data bases, starts jobs running in each
run-slot, then enters a loop, seeing that all run-slots are checked on
once per minute.  When there is nothing left to do, it waits for a short
time (in case something comes along) and quits."

<DEFINE START-RUNNING ("AUX" NEXT-TIME TDIFF TIME-TILL-SYSDOWN
			     C (U '![0]))
	#DECL ((VALUE) ANY
	       (NEXT-TIME) LIST (TDIFF) FLOAT (C) CHANNEL
	       ;(STY-OPEN-FAIL) ;<SPECIAL <OR FALSE <LIST FIX LIST>>>
	       (TIME-TILL-SYSDOWN) FIX (U) <UVECTOR FIX>)

	<SCRIPT-START-STATS>
	<ITS-CALL "SSTATU" .U>
	<COND (<G? <SET TIME-TILL-SYSDOWN <1 .U>> 0>	;"SYSTEM GOING DOWN?"
	       <BATCH-SCRIPT "At " <NOW>
			     " initializing, but system going down at "
			     <SETG SYSTEM-GOING-DOWN
				   <DTADD <DTNOW>
					  ('(0 0 0) (0 0 </ .TIME-TILL-SYSDOWN 30>)) >>
			     CR "     No jobs will be started." CR>)
	      (ELSE <SETG SYSTEM-GOING-DOWN %<>>)>

	<BATCH-SCRIPT 50 "Initializing " ,NQUEUES " run slots." >
	<MAPR <> <FUNCTION (V) #DECL ((V) VECTOR) <PUT .V 1 <>>> ,JOB-CHANNELS>
	<MAPR <> <FUNCTION (V) #DECL ((V)UVECTOR) <PUT .V 1 0 >> ,STY-NUMBERS>
	<MAPR <> <FUNCTION (V) #DECL ((V) VECTOR) <PUT .V 1 <>>> ,INFERIOR-NUMBERS>
	<MAPR <> <FUNCTION (V) #DECL ((V) VECTOR) <PUT .V 1 <>>> ,JOB-ID-NUMBERS>
					;"STD FOR 'THERE IS A JOB IN THIS Q SLOT NOW'"
	<SETG STY-OPEN-FAIL %<>>			;"RECORD OF LAST STY HASSLE"
	<KILL-OLD-MARKERS>		;"KILL MARKERS LEFT FROM BATCH/SYSTEM CRASH"
	<ALLOW-A-SYS-LOAD>

	<PROG () 					;"OUTER LOOP"
					;"NO JOBS CURRENTLY RUNNING"
	      <COND (,SYSTEM-GOING-DOWN
		     <SET NEXT-TIME <DTADD ,SYSTEM-GOING-DOWN
					   '((0 0 0) (0 2 0))>>
		     <SET TDIFF <DTDIFF .NEXT-TIME <DTNOW>>>
		     <RETURN T>)>
	      <START-RUN-SLOTS>

			;"MAIN LOOP, CHECKS ON ALL RUN SLOTS AND WATCHES SYSTEM LOAD"
	      <PROG ()
		    <CHECK-RUN-SLOTS>
		    <COND (<ANY-JOBS-AROUND?>		;"ANYBODY HERE?"
			   <SLEEP <* <COND (<G? ,OLD-LOAD ,LOAD-REF5> 5) (T 1)>
				  ,SLEEP-INTERVAL>>	;"YES, SLEEP A BIT &"
			   <AGAIN>)>>			;"   GO CHECK AGAIN"

							;"NO JOBS NOW - START MORE?"
	      <COND (,SYSTEM-GOING-DOWN			;"NOT IF SYSTEM GOING DOWN"
		     <SET NEXT-TIME <DTADD ,SYSTEM-GOING-DOWN
					   '((0 0 0) (0 2 0))>>
		     <SET TDIFF <DTDIFF .NEXT-TIME <DTNOW>>>)

							;"YES, IF ANYTHING TO RUN"
		    (<AND <SET NEXT-TIME <SOONEST-TIME>>
			  <L=? <SET TDIFF <DTDIFF .NEXT-TIME <DTNOW>>>
			       5.0>>			;" (IN NEXT 5 MINS)"
					;"NOTE THAT THIS IS NEGATIVE IF
					   THERE IS ALREADY SOMETHING WAITING,
					   E.G., IF THE SYSTEM IS LOADED"
		     <SLEEP <MAX <* 60.0 .TDIFF> 60.0>>	;"SLEEP TILL THEN"
		     <AGAIN>)>>				;"OUTER LOOP AGAIN"

	<SCRIPT-END-STATS>
	<COND (<N=? <UNAME> ".BATCH">)
	      (<RESCHEDULE-DEMON .TDIFF>
	       <BATCH-SCRIPT 100 "Demon rescheduled for " .NEXT-TIME>
	       <SET C <OPEN "PRINT" "BATCHN NEXTUP">>	;"just public info"
	       <ITS-CALL "SFDATE" '![] .C <DISK-DATE .NEXT-TIME>>
	       <ITS-CALL "SDMPBT" '![] .C 1>
	       <CLOSE .C>)
	      (<AND <DEMSIG "BATCHN"> <RESCHEDULE-DEMON .TDIFF>>
	       <BATCH-SCRIPT 200
			"Entry in demon table was deleted, has been corrected."
			CR "Rescheduled for " .NEXT-TIME>)
	      (ELSE <BATCH-SCRIPT 300 "**** Cannot reschedule ****">)>>


;"START-RUN-SLOTS simply starts a job running in each possible run-slot"

<DEFINE START-RUN-SLOTS ("AUX" THE-JOB (THE-Q ,NQUEUES))
   #DECL ((VALUE) ANY (THE-JOB) <OR VECTOR FALSE> (THE-Q) FIX)
   <REPEAT ()
	   <COND (<L=? .THE-Q 0> <RETURN T>)
		 (<AND <SET THE-JOB <FIND-NEXT-TASK .THE-Q>>
		       <OK-TO-LOAD-A-JOB? .THE-JOB>>
		  <START-Q-SLOT .THE-Q .THE-JOB>)>
	   <SET THE-Q <- .THE-Q 1>> >>

;"CHECK-RUN-SLOTS is called upon once per minute while the task manager is
running to see that all run-slots are running smoothly.  Running jobs are
checked for cpu usage over their limit and for no cpu usage,  empty run-slots
are checked to see if they can start running jobs"

<DEFINE CHECK-RUN-SLOTS ("AUX" (SLOT ,NQUEUES))
   #DECL ((VALUE) ANY (SLOT) FIX)
   <REPEAT ()
	<COND (<L=? .SLOT 0> <RETURN T>)>
	<CHECK-Q-SLOT .SLOT>
	<SET SLOT <- .SLOT 1>> >>

;"SCRIPT-START-STATS makes some statistical notes in the batch log about
starting up the demon (from login to start of task manager)"

<DEFINE SCRIPT-START-STATS ("AUX" (Q-CPU-T ,MY-INIT-CPU-TIME)
				  (Q-PAGES ,MY-INIT-PAGES)
				  (Q-REAL-T ,MY-INIT-REAL-TIME))
   #DECL ((VALUE) ANY (Q-CPU-T) FLOAT (Q-PAGES) FIX (Q-REAL-T) LIST)
   <BATCH-SCRIPT 50
		 "Login used" <FIX3-FMT .Q-CPU-T>
		 " cpu mins, " .Q-PAGES " pages" CR
		 "Queue start used"
		 <FIX3-FMT <- <SETG MY-INIT-CPU-TIME <RUN-TIME>>
			      .Q-CPU-T>>
		 " cpu mins in"
		 <FIX3-FMT <DTDIFF <SETG MY-INIT-REAL-TIME <DTNOW>>
				   .Q-REAL-T>>
		 " mins, "
		 <- <SETG MY-INIT-PAGES
			  <ITS-GETLOC <+ ,MY-USER-INDEX ,*USIPRQ>>>
		    .Q-PAGES>
		 " pages">
   <SETG SYS-INIT-CPU-TIME </ <+ <ITS-GETLOC ,*USRTIM>
				 <* <ITS-GETLOC ,*USRTM1> 4.0E-6>>
			      60.0>>
   <SETG SYS-INIT-PAGES <+ <ITS-GETLOC ,*NSWXFR> <ITS-GETLOC ,*NSRXFR>>>>


;"SCRIPT-END-STATS does the analogous thing when the task manager
finishes everything, and the demon is ready to logout"


<DEFINE SCRIPT-END-STATS ("AUX" CPU PAGES REAL PCT-CPU PCT-USER-CPU
				PCT-PGFLTS PCT-OVERHD)
   #DECL ((VALUE) ANY
	  (CPU REAL PCT-CPU PCT-USER-CPU PCT-PGFLTS PCT-OVERHD) FLOAT
	  (PAGES) FIX)

   <SET REAL <DTDIFF <DTNOW> ,MY-INIT-REAL-TIME>>			;"REAL MINUTES"
   <SET CPU <- <RUN-TIME> ,MY-INIT-CPU-TIME>>				;"RUN TIME"
   <SET PAGES <- <ITS-GETLOC <+ ,MY-USER-INDEX ,*USIPRQ>>	;"PAGE FAULTS"
		 ,MY-INIT-PAGES>>
   <SET PCT-CPU </ .CPU <MAX .REAL 0.001> 0.01>>			;"AVG % OF CPU"
   <SET PCT-USER-CPU </ .CPU				;"AVG % OF USER CPU TIME"
			<MAX <- </ <+ <ITS-GETLOC ,*USRTIM>
				      <* <ITS-GETLOC ,*USRTM1> 4.0E-6>>
				   60.0>
				,SYS-INIT-CPU-TIME>
			     0.001>
			%</ 1.0 6000.0>>>		;"SYS IN SECS, MINE IN MINS"
   <SET PCT-PGFLTS </ <FLOAT .PAGES>			;"% OF PGFLTS"
		      <MAX <FLOAT <- <+ <ITS-GETLOC ,*NSWXFR> <ITS-GETLOC ,*NSRXFR>>
				     ,SYS-INIT-PAGES>>
			   0.001>
		      0.01>>
   <SET PCT-OVERHD </ .CPU <+ .CPU ,T-INF-CPU> 0.01>>
				;"% TOTAL DEMON CPU TIME TO TASK MANAGER"
				;"  (AS OPPOSED TO INFERIORS)  "

   <BATCH-SCRIPT  200 CR "**** STATS FOR TASK MANAGER ****" CR
							;"WRITE OUT SOME STATISTICS"
	"  real mins" <FIX3-FMT .REAL> ", inferiors" <FIX3-FMT ,T-INF-REAL>
	" in " ,N-RUNS " runs" CR
	"  cpu mins" <FIX3-FMT .CPU> "," <FIX3-FMT .PCT-CPU>
	"%," <FIX3-FMT .PCT-USER-CPU>
	"% of user time, inferiors" <FIX3-FMT ,T-INF-CPU> CR
	"  page faults " .PAGES "," <FIX3-FMT .PCT-PGFLTS>
	"%, inferiors " ,T-INF-PAGES CR
	"  cpu overhead" <FIX3-FMT .PCT-OVERHD> "%" CR
	"********************************" CR>>


;"ALLOW-A-SYS-LOAD causes a normal demon to sleep long enough to get
a measurement of the system load (only really measured once per minute).
When debugging, the measurement is punted for speed"

<DEFINE ALLOW-A-SYS-LOAD ("AUX" (SINCE <- <SYS-SECS> ,LAST-CHECKED-TIME>))
   #DECL ((VALUE) ANY (SINCE) FIX)
   <COND (,IN-DEBUG-MODE)			;"PUNT IF DEBUGGING"
	 (<L? .SINCE 60>	;"SLEEP ENOUGH SO SYS-LOAD WILL DO SOMETHING"
	  <SLEEP <- 60 .SINCE>>)>>


;"SETUP-INPUT-STRING sets up the input to be given to a task.
This must be gotten from the task descriptor, or read from a file
before the job is started"

<DEFINE SETUP-INPUT-STRING (INPUT QN)
   #DECL ((VALUE INPUT) ANY (QN) FIX)
   <COND (<DECL? .INPUT
		 '<VECTOR STRING STRING STRING [REST STRING]>>
          <COND (<SET INPUT <OPEN "READ" !<FN-REORDER .INPUT>>>
                 <PUT ,INPUT-STRINGS
                      .QN
                      <NO-LFS <READ-FILE .INPUT>>>)
                (ELSE				;"RETURN FALSE FROM OPEN"
		 <PUT ,INPUT-STRINGS .QN "">
		 .INPUT)>)
         (<TYPE? .INPUT STRING>
          <PUT ,INPUT-STRINGS .QN <NO-LFS .INPUT>>)
         (<TYPE? .INPUT CHARACTER>
          <PUT ,INPUT-STRINGS .QN <STRING .INPUT>>)
         (ELSE <PUT ,INPUT-STRINGS .QN "">)> >

<DEFINE READ-FILE (CHAN "AUX" (S <ISTRING <FILE-LENGTH .CHAN>>))
   #DECL ((VALUE S) STRING (CHAN) CHANNEL)
   <SET S <SUBSTRUC .S 0 <READSTRING .S .CHAN>>>
   <CLOSE .CHAN>
   .S>

;"NO-LFS punts line feeds immediately following carriage returns"

<DEFINE NO-LFS (CSTRING "AUX" (CHR %<ASCII 0>))
   #DECL((VALUE CSTRING) STRING (CHR) CHARACTER)

   <COND (<NOT <MEMQ %<ASCII 10> .CSTRING>> .CSTRING)
	 (ELSE
	  <MAPF ,STRING
		#FUNCTION ((C)
			   #DECL ((VALUE C) CHARACTER)
			   <COND (<AND <==? .C %<ASCII 10>>
				       <==? .CHR %<ASCII 13>>>
				  <SET CHR .C>
				  <MAPRET>)>
			   <SET CHR .C>)
		.CSTRING>)>>

;"ANY-JOBS-AROUND? decides if there are any jobs considered
'RUNNING', ie, if any of the run-slots are non-empty"

<DEFINE ANY-JOBS-AROUND? ()
   #DECL ((VALUE) ANY)
   <G? <NUMBER-OF-NON-FALSES ,JOB-ID-NUMBERS> 0>>

;"RESCHEDULE-DEMON is an auxilliary function for setting the restart
time for the batch demon"

<DEFINE RESCHEDULE-DEMON (MINUTES "AUX" (MINS <FIX .MINUTES>))
   #DECL ((VALUE) ANY (MINUTES) <OR FIX FLOAT> (MINS) FIX)
   <SET-DEMON-STATUS "BATCHN" 30 0 .MINS>>

;"SETUP-SYSTEM-LOCATIONS does an ITS-EVAL on several needed symbols in
ITS' symbol table.  This must be done every login, since new versions of
ITS will affect these locations.  This function will report on any symbols
that have been outdated and removed from ITS"

<DEFINE SETUP-SYSTEM-LOCATIONS ("AUX" BADDIES)	;"LOCATES SOME SYSTEM VARIABLES"
   #DECL ((VALUE) FLOAT (BADDIES) LIST)

   <SETG *L      <ITS-EVAL <SQUOZE "L">>>	;"LENGTH OF SYSTEM USER TABLE"
   <SETG *USIPRQ <ITS-EVAL <SQUOZE "USIPRQ">>>	;"PAGE FAULTS FOR ONE USER"
   <SETG *USRTIM <ITS-EVAL <SQUOZE "USRTIM">>>	;"CPU SECS____ FOR ALL USERS"
   <SETG *USRTM1 <ITS-EVAL <SQUOZE "USRTM1">>>	;"EXTRA 4.0uSECS FOR USRTIM"
   <SETG *AUSOPG <ITS-EVAL <SQUOZE "AUSOPG">>>	;"ACTIVE JOB SWAPPED OUT PAGES"
   <SETG *NSWXFR <ITS-EVAL <SQUOZE "NSWXFR">>>	;"SYSTEM WRITE PAGE FAULTS"
   <SETG *NSRXFR <ITS-EVAL <SQUOZE "NSRXFR">>>	;"SYSTEM READ PAGE FAULTS"
   <SETG *NFSTTY <ITS-EVAL <SQUOZE "NFSTTY">>>	;"NO. OF FIRST PSEUDO-TTY"
   <SETG *NSTTYS <ITS-EVAL <SQUOZE "NSTTYS">>>	;"NO. OF PSEUDO-TTYS"
   <SETG *JNAME  <ITS-EVAL <SQUOZE "JNAME">>>	;"LOCN OF JNAME FOR JOB 0"

   <SET BADDIES <MAPF ,LIST
		      #FUNCTION ((A) #DECL ((A) ATOM)
			  <COND (,.A <MAPRET>)
				(<SETG .A 0>
				 <BATCH-SCRIPT 300 "*** ERROR *** " .A
					       " is no longer an ITS symbol">
				 <SPNAME .A>)>)
		      '![*L *USIPRQ *USRTIM *USRTM1 *AUSOPG *NSWXFR *NSRXFR]>>

   <COND (<NOT <EMPTY? .BADDIES>>
	  <HELP-ME ,HELP-BOXES
	    " I'm getting old." ,CR
	    " The ITS symbols " !.BADDIES
	    " no longer exist" ,CR>
	  <SETG CANT-MEASURE-SYS-LOAD T>)
	 (T <SETG CANT-MEASURE-SYS-LOAD %<>>)>


   <SETG OUR-PGFLTS <SETG SYS-PGFLTS <SETG T-INF-PAGES <SETG N-RUNS 0>>>>
   <SETG LAST-CHECK <SETG T-INF-REAL <SETG T-INF-CPU 0.0>>>
   <SETG LAST-CHECKED-TIME -61>
   <SETG MY-USER-INDEX <* <CHTYPE <USET %<> "UIND"> FIX> ,*L>>

   <SETG MY-INIT-REAL-TIME <DTNOW>>
   <SETG MY-INIT-PAGES <ITS-GETLOC <+ ,MY-USER-INDEX ,*USIPRQ>>>
   <SETG MY-INIT-CPU-TIME <RUN-TIME>>
   <SYS-LOAD>>

;"SYS-LOAD returns the 'loadage' of the system, by the current algorithm.
This is measured no more often than once per minute."

<DEFINE SYS-LOAD ("AUX" ;(OUR-PGFLTS-LAST ,OUR-PGFLTS)
			;(SYS-PGFLTS-LAST ,SYS-PGFLTS)
			(OLD-INT-LEVEL <INT-LEVEL 100>)
			;(PGFLTS <ITS-GETLOC <+ ,MY-USER-INDEX ,*USIPRQ>>)
			CHECK SS)

   #DECL  ((VALUE CHECK) FLOAT
	   (OLD-INT-LEVEL ;OUR-PGFLTS-LAST ;SYS-PGFLTS-LAST
	    ;PGFLTS SS) FIX)

   <COND (,CANT-MEASURE-SYS-LOAD 0)
	 (<L? <SET SS <SYS-SECS>> <+ ,LAST-CHECKED-TIME 60>>	;"ONLY CHECK SYS 1/MIN"
	  <INT-LEVEL .OLD-INT-LEVEL>
	  ,LAST-CHECK)

	 (ELSE
	  ;<REPEAT ((Q ,NQUEUES))	;"SUM PAGE FAULTS FOR ENTIRE DEMON"
		  #DECL ((Q) FIX)
		  <COND (<0? .Q>
			 <RETURN T>)
		        (<NTH ,JOB-ID-NUMBERS .Q>
			 <SET PGFLTS <+ <ITS-GETLOC <+ <NTH ,JOB-SYSTEM-INDEXES .Q>
						       ,*USIPRQ>>
					.PGFLTS>>)>
		  <SET Q <- .Q 1>> >

	  ;<SETG OUR-PGFLTS .PGFLTS>
	  ;<SETG SYS-PGFLTS <+ <ITS-GETLOC ,*NSWXFR> <ITS-GETLOC ,*NSRXFR>>>

	  ;<SET CHECK </ <FLOAT <- <- ,SYS-PGFLTS .SYS-PGFLTS-LAST>
				  <- ,OUR-PGFLTS .OUR-PGFLTS-LAST>>>
			<FLOAT <- .SS ,LAST-CHECKED-TIME>> > >

	  <SET CHECK <FLOAT <ITS-GETLOC ,*AUSOPG>>>
	  <SETG LAST-CHECKED-TIME .SS>
	  <INT-LEVEL .OLD-INT-LEVEL>
	  <SETG LAST-CHECK .CHECK>)> >

;"RUN-TIME computes the cpu time useage for some job -- either an
inferior or 'myself'"

<DEFINE RUN-TIME ("OPTIONAL" (JB %<>))
   #DECL ((VALUE) FLOAT (JB) <OR FALSE CHANNEL FIX>)
   <* <CHTYPE <USET .JB "RUNT"> FIX>
      %</ 4.0E-6 60.0>>>

;"SCRIPTOR-INTERRUPT-ROUTINE is signalled (by <INTERRUPT \"SCRIPTOR\">)
to happen at level 5; to output the internal buffer for a job; whenever
it fills up, and a few other times.  This must happen at INT-LEVEL 5,
due to channel utilization problems"

<DEFINE SCRIPTOR-INTERRUPT-ROUTINE (Q-SLOT "AUX"
				    (FILE <NTH ,OUTPUT-FILES .Q-SLOT>)
				    (JOB-CH <NTH ,JOB-CHANNELS .Q-SLOT>)
				    (CLOSE-SW <MAKE-SURE-OPEN .JOB-CH>))
   #DECL ((VALUE) ANY (Q-SLOT) FIX (FILE) <OR FALSE STRING CHANNEL>
	  (JOB-CH) <OR FALSE CHANNEL> (CLOSE-SW) <OR CHANNEL FALSE>)

   <COND (.FILE
	  <COND (.JOB-CH
		 <JOB-STOP .JOB-CH>)>
	  <SCRIPT-OUTPUT-BUFFER <NTH ,OUTPUT-SCRIPTS .Q-SLOT> .FILE>
	  <COND (.JOB-CH
		 <JOB-RESTART .JOB-CH .Q-SLOT>
		 <COND (.CLOSE-SW
			<CLOSE .JOB-CH>)> )>  )> >

;"SCRIPT-OUTPUT-BUFFER does the dirty work for the SCRIPTOR-INTERRUPT-ROUTINE.
It can be called directly at INT-LEVEL 5, or thru the \"SCRIPTOR\" interrupt"

<DEFINE SCRIPT-OUTPUT-BUFFER (SCRIPT FILE "AUX"		;"CALLED FROM INT LEVEL 5"
			      (LEN <1 .SCRIPT>) (OLD-INT-LEV <INT-LEVEL 15>))
   #DECL ((VALUE FILE) ANY
	  (SCRIPT) <LIST FIX STRING STRING>
	  (LEN OLD-INT-LEV) FIX)

   <COND (<L? .LEN 1>)
	 (<NOT .FILE>
	  <PUT .SCRIPT 1 0>
	  <PUT .SCRIPT 3 "">)
	 (<SCRIPTOR-WITH-ACT .FILE
			     <COND (<L? .LEN 640> <SUBSTRUC <2 .SCRIPT> 0 .LEN>)
				   (ELSE <2 .SCRIPT>)>
			     <3 .SCRIPT>>
	  <PUT .SCRIPT 1 0>
	  <PUT .SCRIPT 3 "">)
	(<G? .LEN 640> <PUT .SCRIPT 3 "
>>>DEVICE FULL: THIS PART OF TRANSCRIPT LOST!<<<
">)>
   <INT-LEVEL .OLD-INT-LEV> >

<DEFINE SCRIPTOR-WITH-ACT SCRIPTOR-ACT (X Y Z)
	#DECL ((SCRIPTOR-ACT) <SPECIAL ACTIVATION> (X) ANY (Y Z) STRING)
	<CHARAPPEND .X 0 T .Y .Z>>

;"SETUP-STYS (trys to) open the needed STY channels for a job in-loading.
If there is a free STY, it must open 2 channels to it, translate the
inferiors job into the other end of it, etc."

<DEFINE SETUP-STYS (JOB-CH Q "AUX" (WIDTH 88)		;"CALLED AT INT LEVEL 5"
		    IN-CH OUT-CH STY-NAME INT-HEADER)
   #DECL ((VALUE) ANY (JOB-CH IN-CH OUT-CH) <OR CHANNEL FALSE>
	  (Q WIDTH) FIX (STY-NAME) STRING (INT-HEADER) IHEADER
	  ;(STY-OPEN-FAIL) ;<OR FALSE <LIST FIX LIST>>)

   <REPEAT ((N ,NQUEUES))	;"ZERO AND CLOSE UNUSED STY CHANNELS (JUST IN CASE)"
	#DECL ((N) FIX)
	<COND (<0? .N>
	       <RETURN T>)
	      (<OR <NOT <NTH ,JOB-ID-NUMBERS .N>>
		   <==? .N .Q>>
	       <PUT ,STY-NUMBERS .N 0>
	       <COND (<AND <TYPE? <SET IN-CH <NTH ,STY-INPUT-CHANNELS .Q>> CHANNEL>
			   <G? <1 .IN-CH> 0>>
			<OFF <NTH ,STY-INPUT-IHEADERS .Q>>
			<CLOSE .IN-CH>)>
	       <COND (<AND <TYPE? <SET OUT-CH <NTH ,STY-OUTPUT-CHANNELS .Q>> CHANNEL>
			   <G? <1 .OUT-CH> 0>>
			<OFF <NTH ,STY-OUTPUT-IHEADERS .Q>>
			<CLOSE .OUT-CH>)> )>
	<SET N <- .N 1>> >

   <PROG ((N 1))			;"FIND FIRST AVAILABLE STY NUMBER"
	 #DECL ((N) FIX)
	 <COND (<G? .N <OR ,*NSTTYS 8>>
		<NOTIFY-STY-USERS>
		<SETG STY-OPEN-FAIL (<- <NUMBER-OF-NON-FALSES ,JOB-ID-NUMBERS>
					1>
				     <DTNOW>)>
		<RETURN #FALSE ("NO FREE STYS")>)
	       (<MEMQ .N ,STY-NUMBERS>
		<SET N <+ .N 1>>
		<AGAIN>)
	       (<NOT <SET OUT-CH <OPEN "PRINT"
				       <SET STY-NAME <STRING "ST"
							     <UNPARSE .N>
							     ":">> >>>
		<SET N <+ .N 1>>
		<AGAIN>)>			;"TRY FOR ANOTHER STY NUMBER"

	 <PUT ,STY-NUMBERS .Q .N>
	 <PUT ,STY-OUTPUT-CHANNELS .Q .OUT-CH>
	 <HANDLER <SET INT-HEADER <EVENT "CHAR" 10 .OUT-CH>>	;"GOT AN OUTPUT STY"
		  ,STY-OUTPUT-INTERRUPT-ROUTINE			;"GET IHEADER"
		  <MAIN>>					;"SAVE RELEVENT INFO"
	 <PUT ,STY-OUTPUT-IHEADERS .Q .INT-HEADER>
	 <SETG STY-OPEN-FAIL %<>>
	 <COND (<NOT <SET IN-CH <OPEN "READ" .STY-NAME>>>	;"OPEN INPUT; FAILED?"
		<PUT ,STY-NUMBERS .Q 0>		;"YEP, SO RESET CRAP AND NOTE FAILRURE"
		<OFF .INT-HEADER>
		<CLOSE .OUT-CH>
		<SETG STY-OPEN-FAIL (<- <NUMBER-OF-NON-FALSES ,JOB-ID-NUMBERS> 1>
				     <DTNOW>)>
		<RETURN .IN-CH>)>			;"RETURN FALSE FROM OPEN"

	 <PUT ,STY-INPUT-CHANNELS .Q .IN-CH>
	 <HANDLER <SET INT-HEADER <EVENT "CHAR" 15 .IN-CH>>
		  ,STY-INPUT-INTERRUPT-ROUTINE
		  <MAIN>>
	 <PUT ,STY-INPUT-IHEADERS .Q .INT-HEADER>

	 <COND (<TRANSLATE-STY .OUT-CH .JOB-CH>)	;"NOW TRANSLATE STY TO LOOK LIKE"
							;"    A TTY FOR THE JOB"
	       (ELSE
		<OFF <NTH ,STY-INPUT-IHEADERS .Q>>
		<OFF <NTH ,STY-OUTPUT-IHEADERS .Q>>
		<CLOSE .IN-CH>
		<CLOSE .OUT-CH>
		<SETG STY-OPEN-FAIL (<- <NUMBER-OF-NON-FALSES ,JOB-ID-NUMBERS> 1>
				     <DTNOW>)>
		<RETURN #FALSE ("Couldn't translate STYs for job.")> )>
	 <ITS-CALL "CNSSET" '![] .OUT-CH -1 .WIDTH>
	 <TERPRI .OUT-CH>			;"FLUSH ANYTHING SITTING IN STY NOW"
	 <REPEAT ()
		 <COND (<==? <READCHR .IN-CH> -1>
			<RETURN T>)>>
	 T>>

<DEFINE NOTIFY-STY-USERS ("AUX" C FI)
   #DECL ((C) <OR FALSE CHANNEL> (FI) FIX)
   <COND
    (<AND <MAPF ,AND? ,0? ,STY-NUMBERS>
	  <SET C <OPEN "READ" "TTY:.FILE. (DIR)">>>
     <REPEAT (TTY UNM JNM CLI (FIRSTY <UNPARSE <OR ,*NFSTTY *21*> 8>)
	      (LASTY <UNPARSE <+ <OR ,*NFSTTY *21*> <OR ,*NSTTYS 6> -1> 8>)
	      (CR <STRING <ASCII 13>>) (TBUF <ISTRING 41>))
       #DECL ((TTY UNM JNM FIRSTY LASTY CR TBUF) STRING (CLI) <OR CHANNEL FALSE>)
       <READCHR .C '<RETURN>>					 ;"GOBBLE UP CR"
       <COND
	(<0? <SET FI <READSTRING .TBUF .C .CR>>> <RETURN>)
	(<AND <G=? <STRCOMP <SET TTY <SUBSTRUC .TBUF 2 2>> .FIRSTY> 0>
	      <L=? <STRCOMP .TTY .LASTY> 0>>
	 <SET UNM <SUBSTRUC .TBUF 5 6>>
	 <SET JNM
	      <COND ;(,*JNAME
		  <SIXTOS <ITS-GETLOC <+ ,*JNAME
					 <* ,*L
					    <SET FI <PARSE <SUBSTRUC .TBUF 30 2> 8>>>>>>)
		    (T "HACTRN")>>
	 <COND (<SET CLI <OPEN "PRINT" .UNM .JNM "CLI">>
		<PRINC 
"
Please excuse the interruption, but the Batch system needs a pseudo-terminal,
and all of them are in use, including yours.  If you are not doing sponsored
research for M.I.T., please finish up and log out.  Thank you.
"
		       .CLI>
		<BATCH-SCRIPT "Requested " .UNM " " .JNM " to leave.">
		<CLOSE .CLI>)>)>>)>>

;"STY-INPUT-INTERRUPT-ROUTINE gets signalled every time an inferior
outputs something to its TTY.  It does a GET-OUTPUT-OF-TASK"

<DEFINE STY-INPUT-INTERRUPT-ROUTINE (CHAN "AUX" Q)	;"INT LEVEL 15"
   	#DECL ((VALUE) ANY (CHAN) CHANNEL
	       (Q) <OR FALSE FIX>)

	 <COND (<SET Q <INDEX .CHAN ,STY-INPUT-CHANNELS>>
		<GET-OUTPUT-OF-TASK .Q .CHAN>)
	       (ELSE <BATCH-SCRIPT 200 "Input interrupt from channel "
				   "not in STY-INPUT-CHANNELS:  " CR .CHAN CR
				   "closing offending channel if not to a tty">
		<COND (<N=? <9 .CHAN> "TTY">
			<CLOSE .CHAN>)>)>>

;"GET-OUTPUT-OF-TASK soaks up any characters an inferior has output to
its TTY"

<DEFINE GET-OUTPUT-OF-TASK (Q
			    "OPTIONAL" (CHAN <NTH ,STY-INPUT-CHANNELS .Q>)
			    "AUX" (SCRIPT <NTH ,OUTPUT-SCRIPTS .Q>)
				  (SOFAR <1 .SCRIPT>)
				  (ALREADY <G=? .SOFAR 320>) INF SW)
   #DECL ((VALUE) ANY (Q SOFAR) FIX
	  (CHAN INF SW) <OR CHANNEL FALSE>
	  (SCRIPT) <LIST FIX STRING STRING> (ALREADY) <OR ATOM FALSE>)

   <COND (.CHAN
	  <COND (<L? .SOFAR 640>
		 <PUT .SCRIPT 1 <SET SOFAR <+ <READSTRING <REST <2 .SCRIPT> .SOFAR>
							  .CHAN
							  <- 640 .SOFAR> >
					      .SOFAR>> >)>
	  <COND (<AND <G=? .SOFAR 600>			;"THIS GUY IS OUTPUTTING A LOT"
		      <SET INF <NTH ,JOB-CHANNELS .Q>>>	;"STOP HIM TEMPORARILY"
		 <SET SW <MAKE-SURE-OPEN .INF>>
		 <JOB-STOP .INF>
		 <AND .SW <CLOSE .INF>>)>

	  <COND (<G=? .SOFAR 640>
		 <PUT .SCRIPT
		      3
		      <STRING <3 .SCRIPT>
			      <MAPF ,STRING
				    <FUNCTION ()
				     <COND (<TYPE? <NEXTCHR .CHAN -1> CHARACTER>
					    <READCHR .CHAN>)
					   (T <MAPSTOP>)>>>>>
		 <PUT .SCRIPT 1 <SET SOFAR <+ <LENGTH <3 .SCRIPT>> 640>>>)>

	  <COND (.ALREADY
		 <AND <G=? .SOFAR 640> <INTERRUPT "SCRIPTOR" .Q>>)
		(<G=? .SOFAR 320>
		 <INTERRUPT "SCRIPTOR" .Q>)>  )>  >

;"TERMINATE-TASK is called at INT-LEVEL 5 to end a task's execution, for
any reason except (sometimes) early abort in START-RUNNING"

<DEFINE TERMINATE-TASK (Q TASK
			"OPTIONAL" (ACKN1 %<>)	;"CALLED AT INT LEVEL 5"
				   (ACKN2 "unknown")
			"AUX" (REAL 0.0) (CPU 0.0) (PAGES 0) (OVERHD 0.0)
			      (JOB-CH <NTH ,JOB-CHANNELS .Q>)
			      (OLD-INT-LEVEL <INT-LEVEL 5>) TEMP FI FL OF F L)

   #DECL ((Q OLD-INT-LEVEL PAGES FI) FIX
	  (ACKN1 TEMP VALUE) ANY
	  (CPU REAL OVERHD FL) FLOAT
	  (JOB-CH) <OR CHANNEL FALSE>
	  (ACKN2 OF) STRING
	  (F) <OR STRING FALSE>
	  (TASK) <OR VECTOR FALSE> (L) LIST)

   <PROG ()
	<COND (<NOT .TASK> <RETURN %<>>)      ;"MAKE SURE THERE IS A TASK HERE"
	      (<N=? .TASK <NTH ,SPECS-OF-JOBS .Q>>   ;"AND IT IS THE RIGHT ONE"
	       <RETURN %<>>)>

	<COND (.JOB-CH
	       <MAKE-SURE-OPEN .JOB-CH>
	       <JOB-STOP .JOB-CH>
	       <GET-OUTPUT-OF-TASK .Q>)>

	<COND (<SET TEMP <NTH ,STY-INPUT-IHEADERS .Q>>
	       <OFF .TEMP>)>
	<COND (<TYPE? <SET TEMP <NTH ,STY-INPUT-CHANNELS .Q>> CHANNEL>
	       <CLOSE .TEMP>
	       <PUT ,STY-INPUT-CHANNELS .Q %<>>)>
	<COND (<SET TEMP <NTH ,STY-OUTPUT-IHEADERS .Q>>
	       <OFF .TEMP>)>
	<COND (<TYPE? <SET TEMP <NTH ,STY-OUTPUT-CHANNELS .Q>> CHANNEL>
	       <CLOSE .TEMP>
	       <PUT ,STY-OUTPUT-CHANNELS .Q %<>>)>
	<PUT ,STY-NUMBERS .Q 0>

	<COND (.JOB-CH
	       <COND (<N==? <1 .JOB-CH> 0>
		    <SET CPU <RUN-TIME .JOB-CH>>		 ;"CPU MINS"
		    <SET PAGES <ITS-GETLOC <+ <SET FI
						  <NTH ,JOB-SYSTEM-INDEXES .Q>>
					      ,*USIPRQ>>>;"PAGE FAULTS FOR JOB"
		    <CLOSE <JOB-KILL .JOB-CH>>)>
	       <COND (<==? .ACKN1 ON-DELAY>)
		     (<OR <==? .ACKN1 ON-COMPLETION:ERROR-IN-STARTING>
			  <==? .ACKN1 ON-COMPLETION:RUN-TEST-FALSE>
			  <AND <==? .ACKN1 IF-MADE-UNRUNNABLE>
			       <=? .ACKN2 "ERROR in run test" >> >
		      <JOB-SCRIPT .Q ,CR "Task terminated because:  "
				  .ACKN2 ,CR>)
		     (ELSE
		      <SET FL <- <RUN-TIME> <SET FL <NTH ,OVERHD-REFS .Q>>>>
		      <JOB-SCRIPT .Q ,CR
		 "^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"
				,CR ,CR "Task terminated at " <TIME-NOW> ,CR
				"Reason:  " .ACKN2
				<FIX3-FMT .CPU> "/"
				<FIX3-FMT <SET REAL
				  <DTDIFF <DTNOW> <LAST-STARTING-TIME .TASK>>>>
				" CPU/Real minutes used ("
				<FIX3-FMT </ .CPU <MAX .REAL 0.001> 0.01>>
				"%), " <UNPARSE .PAGES> " Page faults" ,CR
				" Uncompensated cpu overhead "
				<FIX3-FMT <SET OVERHD </ .FL
						       <MAX <+ .FL .CPU> 0.001>
						       0.01>>>
				"%" ,CR>)> )
	      (ELSE
	       <JOB-SCRIPT .Q ,CR "Task terminated because:  " .ACKN2 ,CR>)>

	<BATCH-SCRIPT "Done with " <ORIGINATOR .TASK> !\. <TASK-NAME .TASK> !\.
		      <TASK-ID-NUMBER .TASK> ", reason:  " .ACKN2
		      "     used" <FIX3-FMT .CPU>
		      " in" <FIX3-FMT .REAL> ", pages " .PAGES
		      ", comp. ovrhd=" <FIX3-FMT .OVERHD> "%">
	<SETG T-INF-CPU <+ ,T-INF-CPU .CPU>>
	<SETG T-INF-REAL <+ ,T-INF-REAL .REAL>>
	<SETG T-INF-PAGES <+ ,T-INF-PAGES .PAGES>>
	<PUT ,JOB-ID-NUMBERS .Q %<>>
	<PUT ,JOB-CHANNELS .Q %<>>
	<PUT ,INFERIOR-NUMBERS .Q %<>>
	<PUT ,SPECS-OF-JOBS .Q %<>>
	<COND (<N==? .ACKN1 ON-DELAY>
	       <PUT .TASK ,LAST-COMPLETION-TIME <DTNOW>>
	       <PUT .TASK ,LAST-CPU-TIME-USED .CPU>
	       <PUT .TASK ,ACCUMULATED-CPU-TIME
		    <+ <SET FL <ACCUMULATED-CPU-TIME .TASK>> .CPU>>
	       <PUT .TASK ,NUMBER-OF-TIMES-RUN
					;"STATE 'UNRUNNABLE' IF UNFORGIVABLE"
		    <+ <SET FI <NUMBER-OF-TIMES-RUN .TASK>> 1>>)>
					;"   ERROR"
	<COND (.ACKN1			;"STATE MAY BE MADE 'UNRUNNABLE' (IF"
	       <ACKNOWLEDGE .TASK .ACKN1 .ACKN2>)>
					;"   ACKNOWLEDGEMENT REQUESTED"

	<COND (<N==? .ACKN1 ON-DELAY>
	       <COND (<NOT <LENGTH? <SET L <WHEN-ORIGINATED .TASK>> 3>>
		      <PUT .TASK ,TIME-OF-NEXT-RUN <REST .L 3>>
		      <PUTREST <REST .L 2> ()>)>
	       <RESCHEDULE-TASK .TASK .Q>)	;"STATE MAY BECOME 'REMOVED'"
					;"RESCHEDULE-TASK UPDATES DISK Q"
	      (T
	       <OR <NOT <LENGTH? <SET L <WHEN-ORIGINATED .TASK>> 3>>
		   <PUTREST <REST .L 2> <TIME-OF-NEXT-RUN .TASK>>>
	       <RESCHEDULE-TASK .TASK .Q 20>)>
	<JOB-SCRIPT .Q %<STRING <ASCII 12>>>
	<SCRIPT-OUTPUT-BUFFER <NTH ,OUTPUT-SCRIPTS .Q>
			      <SET TEMP <NTH ,OUTPUT-FILES .Q>> >
	<COND (<TYPE? .TEMP CHANNEL>
	       <CLOSE .TEMP>)>
	<COND (<=? <NTH ,OUTPUT-FILES .Q>
		   <SET OF <STRING "DSK:.BATCH;_MSG "
				   <UNPARSE <TASK-ID-NUMBER .TASK>>>>>
	       <COND (<AND <TYPE? <SET TEMP <OPEN "READ" .OF>> CHANNEL>
			   <SET F <MEMBER "MSG:" <OUTPUT-FILE .TASK>>>>
		      <MAIL <REST .F 4> <READ-FILE .TEMP>>
		      <RENAME .OF>)>)>
	<PUT ,OUTPUT-FILES .Q %<>>
	<COND (<AND <==? .ACKN1 ON-DELAY>
		    <=? .ACKN2 "user device full">>
	       <STOP-ALL-JOBS>
	       <BATCH-SCRIPT "USER DEVICE FULL, AT " <NOW>
			     " SLEEPING FOR 30 MINS">
	       <SLEEP %<* 30 60>>)>
	<COND (<BATCH-QUEUE-CHECK-SWITCH .TASK>
	       <UPDATE-QUEUE>)>
	<RENAME <STRING ".BATCH;#Q" <UNPARSE .Q> " >">>
	<INT-LEVEL .OLD-INT-LEVEL>>>

;"KILLER-INTERRUPT-ROUTINE is TERMINATE-TASK's alias, for the
\"KILLER\" interrupt; which is signalled when a task's termination
is determined at some other interrupt level"

<SETG KILLER-INTERRUPT-ROUTINE ,TERMINATE-TASK>		;"AT INT-LEVEL 5"

;"STOP-ALL-JOBS will put any running inferiors into 10!0 mode"

<DEFINE STOP-ALL-JOBS ("AUX" (QN ,NQUEUES) JC)
   #DECL ((VALUE) ANY (JC) <OR FALSE CHANNEL> (QN) FIX)
   <REPEAT ()
	   <COND (<0? .QN> <RETURN T>)
		 (<AND <NTH ,JOB-ID-NUMBERS .QN>
		       <SET JC <NTH ,JOB-CHANNELS .QN>> >
		  <JOB-STOP .JC>)> >>

;"IPC-INTERRUPT-ROUTINE handles any info coming in on the IPC
device.  Possible (understood) are the following message types:
	(1) 'send this back to me' -- tells you that the demon
		is alive and well
	(2) 'immediate task abort' -- the message itself must be
		a uvector of 1 fix, that task will be aborted
	(10) 'evaluate this' -- will batch-script and then evaluate
		a random form
	(else) 'look at the disk queue' -- someone says they have
		written new data out on the disk"

<DEFINE IPC-INTERRUPT-ROUTINE (MSG MSG-TYPE "TUPLE"		;"AT INT LEVEL 20"
			       TUP "AUX" (BORROWED <GRAB-A-CHANNEL>))
   #DECL ((VALUE MSG MSG-TYPE) ANY (TUP) TUPLE
	  (BORROWED) <OR FALSE <VECTOR CHANNEL IHEADER>>)

   <COND (<AND	<==? .MSG-TYPE 1>			;"SOME PROTECTION AGAINST"
		<TYPE? .MSG STRING>		;"  IPC MESSAGES 'TO EVAL' "
		<G? <LENGTH .TUP> 1> >
	  <SEND <1 .TUP> <2 .TUP>
		<STRING "<AND <PRINC \"SAME TO YOU!\"> "
			      .MSG " >">		      
		1>
	  <BATCH-SCRIPT 200 "IPC MSG TYPE 1 FROM " .TUP
			CR "     MSG: '" .MSG "'; (MSG returned)">)

	 (<AND <==? .MSG-TYPE 2>
	       <TYPE? .MSG UVECTOR>>
	  <BATCH-SCRIPT 100 "Immediate abort of task " <1 .MSG>
			" by " .TUP>
	  <TASK-ABORT <TASK-DESCRIPTOR <1 .MSG>> <1 .TUP>>)

	 (<AND <==? .MSG-TYPE 10>
	       <TYPE? .MSG STRING>>
	  <BATCH-SCRIPT 100 "IPC MSG TYPE 10 FROM " .TUP
			CR "MSG:  '" .MSG "'; EVALling now">
	  <EVAL <PARSE .MSG>>)

	 (ELSE
	  <BATCH-SCRIPT 20 "UPDATING QUEUE AT REQUEST OF " .TUP>
						;"READ IN ANY NEW TASK SPECS FROM DISK"
	  <UPDATE-QUEUE>)>			;"MODS -- MIGHT CALL TASK-ABORT"
   <RETURN-CHANNEL .BORROWED> >			;"GIVE THE CHANNEL BACK"


;"GRAB-A-CHANNEL is a hack to allow 3 jobs to be run simultaneously.
It is supposed to temporarily close a channel not needed at a lower
interrupt level (stopping the appropriate job) so that the IPC interrupt
can have an extra channel to play with"

<DEFINE GRAB-A-CHANNEL ()				;"CALLED AT INT LEVEL 20"
   #DECL ((VALUE) <OR FALSE <VECTOR CHANNEL IHEADER>>)
		;"CLOSES A CHANNEL NOT NEEDED BY STY-OUTPUT-INTERRUPT-ROUTINE"

   <NOT <L? <NUMBER-OF-NON-FALSES ,JOB-CHANNELS> 3>>	;"NO NEED TO IF < 3 JOBS GOING">

;"RETURN-CHANNEL resets the mischief of GRAB-A-CHANNEL"

<DEFINE RETURN-CHANNEL (BORROWED)			;"CALLED AT INT LEVEL 20"
   #DECL ((BORROWED) <OR FALSE <VECTOR CHANNEL IHEADER>>
	  (VALUE) ANY)
   <COND (.BORROWED
	  <RESET <1 .BORROWED>>			;"RESET CHANNEL AND INTERRUPT HANDLER"
	  <EVENT <2 .BORROWED>>)>>

;"TASK-ABORT is called during disk-queue update, to cause a running
task to be aborted.  This is called at INT-LEVEL 20 during IPC-driven
queue update, at INT-LEVEL 0 during initial queue starting"

<DEFINE TASK-ABORT (TASK "OPTIONAL" (USER "UNKNOWN")	;"CALLED AT INT LEVEL 20"
				    (NEW-STATE "ABORTED")
		    "AUX" (Q <INDEX <TASK-ID-NUMBER .TASK>
				    ,JOB-ID-NUMBERS>))
   #DECL ((VALUE) ANY (TASK) VECTOR
	  (Q) <OR FIX FALSE> (USER NEW-STATE) STRING)

   <PUT .TASK ,TASK-STATE .NEW-STATE>
   <COND (.Q
	  <INTERRUPT "KILLER"
		     .Q
		     .TASK
		     IF-ABORTED
		     <COND (<=? .USER "UNKNOWN">
			    "Manual abort
"					 )
			   (ELSE <STRING "Manual abort by "
					 .USER ,CR>)> >)> >
							;"GET LEVEL 5 TO KILL THE JOB"

;"SYSDOWN-INTERRUPT-ROUTINE gets signalled whenever the system tells
everyone that it has been set to go down.  A note is put in the batch log
as well as the output script of every running job"

<DEFINE SYSDOWN-INTERRUPT-ROUTINE (TIME-LEFT "AUX"	;"AT INT LEVEL 25"
				   (TIME-NOW <NOW>) LEFT)
   #DECL ((VALUE) ANY (TIME-LEFT) FIX
	  (TIME-NOW LEFT) STRING (Q) FIX)

   <COND (<=? .TIME-LEFT -1>
	  T)
	 (T 
	   <SETG SYSTEM-GOING-DOWN				;"CONVERT TO ABSOLUTE TIME"
		 <DTADD <DTNOW>
			('(0 0 0) (0 0 <SET TIME-LEFT <FIX </ .TIME-LEFT 30.0>>>))>>
	   <SET LEFT <FIX3-FMT </ .TIME-LEFT 60.0>>>
	   <BATCH-SCRIPT " ITS is going down in " .LEFT " mins.">
	   <REPEAT ((Q ,NQUEUES))
		   #DECL ((Q) FIX)
		   <COND (<0? .Q>
			  <RETURN T>)
			 (<NTH ,JOB-ID-NUMBERS .Q>		;"TELL ALL THE CURRENT JOBS"
			  <JOB-SCRIPT .Q ,CR "**** FROM BATCH: At " .TIME-NOW ,CR
				      "     ITS is going down in "
				      .LEFT " minutes. ****" ,CR>
			  <INTERRUPT "SCRIPTOR" .Q>)>		;"AND SPEED MSGS TO OUTPUT FILE"
		<SET Q <- .Q 1>> >)>>

;"CLOSE-A-CHANNEL is part of the ERROR handling scheme.  The idea is to
get a channel from somewhere to allow scripting of error messages, and
to FSAVE the losing demon"

<DEFINE CLOSE-A-CHANNEL ("AUX" (C-LIST <CHANLIST>))
   #DECL ((VALUE) <OR FALSE CHANNEL> (C-LIST) LIST)
   <MAPF <>
	 <FUNCTION (CHAN)
		   #DECL ((CHAN) CHANNEL)
		   <AND <G?  <1 .CHAN> 0>
			<N=? <9 .CHAN> "TTY">
			<MAPLEAVE <CLOSE .CHAN>>>>
	 .C-LIST>>

;"ERROR-INTERRUPT-ROUTINE happens at INT-LEVEL 50 whenever an error occurs.
It tries to be smart about a few types of errors, especially errors happening
while evaluating a user form (run-test or rescheduler).  It also tries to
signal some help."

<DEFINE ERROR-INTERRUPT-ROUTINE ("TUPLE" TUP
				 "AUX" SAVED JHM X NOMORE (OUTCHAN .OUTCHAN))
							     ;"AT INT LEVEL 50"
   #DECL ((VALUE SAVED) ANY (TUP) TUPLE (NOMORE OUTCHAN) CHANNEL
	  (JHM) <OR CHANNEL FALSE> (X) STRING)

 <PROG ACT () #DECL ((ACT) ACTIVATION)
   <COND (<AND	<ASSIGNED? user-test-activation> ;"ERROR IN A USER TEST?"
		<LEGAL? .user-test-activation>>
	   <DISMISS <CHTYPE ("***ERROR CAUSED***" !<REST .TUP>) FALSE>
		    .user-test-activation>)

	 (<AND <ASSIGNED? READ-TASK-ACT> <LEGAL? .READ-TASK-ACT>>
		<BATCH-SCRIPT "ERROR in READ-TASK: flushing task.">
		<DISMISS %<> .READ-TASK-ACT>)
	 (<AND <ASSIGNED? SCRIPTOR-ACT> <LEGAL? .SCRIPTOR-ACT>>
		;<BATCH-SCRIPT "ERROR in SCRIPTOR: flushing script.">
		<DISMISS %<> .SCRIPTOR-ACT>)
	(<TTY?>	;"IF DEBUGGING, LET ,ERROR DO ITS THING"
	  <PRINC %<ASCII 7>>
	  <SLEEP 0.4>
	  <PRINC %<ASCII 7>>
	  <RETURN T>)

	(<==? <2 .TUP> READER-SYNTAX-ERROR-ERRET-ANYTHING-TO-GO-ON!-ERRORS!- >
	  <BATCH-SCRIPT CR "***ERROR*** " <NOW> CR
			<UNPARSE .TUP> CR "ERRETting T" CR>
	  <DISMISS T>)
	 (<==? <2 .TUP> END-OF-FILE!-ERRORS!- >
	  <BATCH-SCRIPT CR "***ERROR*** " <NOW> CR
			<UNPARSE .TUP> CR "ERRETting []" CR>
	  <DISMISS '[]>)
	 (<==? <2 .TUP> NO-ITS-CHANNELS-FREE!-ERRORS!- >
	  <SET NOMORE <CLOSE-A-CHANNEL>>
	  <BATCH-SCRIPT CR "***ERROR*** " <NOW> CR
			<UNPARSE .TUP> CR
			"channel " .NOMORE " closed (in .NOMORE)" CR>)
	 (ELSE
	  <BATCH-SCRIPT CR "***ERROR*** " <NOW> CR
			<UNPARSE .TUP> CR>)>

   <COND (<SET JHM <OPEN "PRINT" "CLI:SWG HACTRN">> ;"TRY AND FLAG SOME HELP"
	  <PRINC "Uh, help?" .JHM>			;"AHA! "
	  <CLOSE .JHM>)>

   <COND (<NOT <RESCHEDULE-DEMON <* 60 3>>>		;"three hours from now"
	   <DEMSIG "BATCHN">
	   <COND (<RESCHEDULE-DEMON <* 60 3>>
		  <BATCH-SCRIPT 200
			     "Trouble rescheduling --- wasn't in demon table">)
		 (ELSE <BATCH-SCRIPT 300 "Cannot reschedule!! ">)>)>
  <PROG ()
   <COND (<OR <==? <2 .TUP> NO-ITS-CHANNELS-FREE!-ERRORS!- >
	      <AND <==? <2 .TUP> DANGEROUS-INTERRUPT-NOT-HANDLED!-ERRORS!->
		   <==? <3 .TUP> PARITY!-INTERRUPTS!->> 
	      <AND <G=? <LENGTH .TUP> 4>
		   <==? <2 .TUP> FILE-SYSTEM-ERROR!-ERRORS!- >
		   <==? <4 .TUP> #FALSE ("DEVICE FULL")>>>
	  <RETURN <BATCH-SCRIPT "No attempt to save">>)>
   <BATCH-SCRIPT "Saving into .BATCH;SKROD nnn">
   <COND (<=? <SET SAVED <FSAVE ".BATCH;SKROD >" T>> "RESTORED">
	  <DEBUG-MODE>
	  <PRINC "
**** RESTORED AMIDST TURMOIL ****">
	  <RETURN T .ACT>)			;"LET ,ERROR HANDLE IT NOW"

	 (<AND .JHM <SLEEP <* 10 60>> <TTY?>>
					;"GIVE SOMEONE A CHANCE TO GRAB ME"
	  <DEBUG-MODE>
	  <RESET .OUTCHAN>
	  <PRINC "
**** YOU PICKED ME UP FAST ****">
	  <RETURN T .ACT>)				;"MAKE WAY FOR ,ERROR"
	 (<=? .SAVED "SAVED">
	  <COND (<SET JHM <OPEN "READ" ".BATCH;SKROD >">>
		 <SET X <8 .JHM>>
	         <BATCH-SCRIPT "SKROD file " .X " created">
		 <HELP-ME ,HELP-BOXES
			  " Batch demon died!! Save file is  .BATCH;SKROD "
			  .X ,CR
			  "Demon may try again in three hours if no signals"
			  ,CR>)
		(T
		 <SET X <1 .JHM>>
		 <BATCH-SCRIPT "Can't find save file: " .X>
		 <HELP-ME ,HELP-BOXES
			  " Batch demon died!! Save won but: " .X ,CR>)>)

	 (ELSE
	  <CLOSE-A-CHANNEL>
	  <BATCH-SCRIPT "Save failed!!! ">
	  <HELP-ME ,HELP-BOXES
		   " Batch demon died!!
Save also failed!!!
Demon may try again in three hours if no signals." ,CR>)>>

   <COND (<N=? .SAVED "RESTORED">
	  <BATCH-SCRIPT CR "Dying demon going down at " <NOW> " ]" CR>
	  <ITS-CALL "LOGOUT" '![] 0>	;"MUDDLE LOGOUT MAY GET ANOTHER ERROR."
	  <PRINT "hanging ...  ">
	  <HANG>)> >>


;"HELP-ME sends mail to everyone listed in .BOXES"

<DEFINE HELP-ME (BOXES "TUPLE" MSGS "AUX" (M <STRING !.MSGS>))
   #DECL ((VALUE) ANY (BOXES) <VECTOR [REST STRING]> (MSGS) <TUPLE [REST STRING]>
	  (M) STRING)
   <MAPF <> <FUNCTION (B) <MAIL .B .M>> .BOXES>>

;"DEBUG-MODE sets things up for debugging the demon.  Usually debugging
is done with a local (not the main system) queue of tasks, and with less
discriminating system load allowances."

<DEFINE DEBUG-MODE ("OPTIONAL" (TRANS? T))
   #DECL ((VALUE TRANS?) ANY)
   <COND (<OR <NOT <GASSIGNED? NAME-OF-SCRIPT>>
	      <NOT <MEMBER "TTY:" ,NAME-OF-SCRIPT>>>
	  <SETG NAME-OF-SCRIPT ["TTY:" !,NAME-OF-SCRIPT]>)>
   <COND (.TRANS?
	  <TRANSLATE-DEVICE %<>
			    '["DSK" "*" "*" ".BATCH"]
			     ["DSK" "*" "*" <MSNAME>]
			    "INPUT" "OUTPUT" %<> %<>  >)>
   <SETG LOAD-REF1 400.0>
   <SETG LOAD-REF2 430.0>
   <SETG LOAD-REF3 470.0>
   <SETG LOAD-REF4 500.0>
   <SETG LOAD-REF5 560.0>
   <SETG IN-DEBUG-MODE T>>

;"NORMAL-MODE is just the opposite of DEBUG-MODE"

<DEFINE NORMAL-MODE ()
   #DECL ((VALUE) ANY)
   <COND (<OR <NOT <GASSIGNED? NAME-OF-SCRIPT>>
	      <MEMBER "TTY:" ,NAME-OF-SCRIPT>>
	  <SETG NAME-OF-SCRIPT '[".BATCH;NBATCH LOG"]>)>
   <TRANSLATE-CLEAR %<> "ME" %<>>
   <SETG LOAD-REF1 300.0>
   <SETG LOAD-REF2 330.0>
   <SETG LOAD-REF3 370.0>
   <SETG LOAD-REF4 400.0>
   <SETG LOAD-REF5 460.0>
   <SETG IN-DEBUG-MODE %<>>>

;"LIGHT-MODE is special -- intended to get the demon to work
slower should it be bothering online users"

<DEFINE LIGHT-MODE ()
   #DECL ((VALUE) ANY)
   <SETG LOAD-REF1 200.0>
   <SETG LOAD-REF2 230.0>
   <SETG LOAD-REF3 270.0>
   <SETG LOAD-REF4 300.0>
   <SETG LOAD-REF5 360.0>>

;"MSNAME tries to decide the debugger's master sname; like DDT"

<DEFINE MSNAME ("AUX" (U <UNAME>))
   #DECL ((U) STRING)
   <MAPF ,STRING
	 #FUNCTION ((C)
		    #DECL ((C) CHARACTER)
		    <COND (<MEMQ .C "0123456789"> <MAPSTOP> T)
			  (.C)>)
	 .U>>

;"STY-OUTPUT-INTERRUPT-ROUTINE feeds characters to a
task that asks for some"

<DEFINE STY-OUTPUT-INTERRUPT-ROUTINE (CHAN	;"AT INT LEVEL 10"
				      "AUX" (Q-SLOT <INDEX .CHAN ,STY-OUTPUT-CHANNELS>)
					    FEED NUMBER
					    JOB-CH CLOSE-SW)	;"SEND CHARS TO A JOB"
   #DECL ((VALUE) ANY (CHAN) CHANNEL
	  (Q-SLOT) <OR FALSE FIX> (FEED) STRING (NUMBER) FIX
	  (JOB-CH CLOSE-SW) <OR CHANNEL FALSE>)

   <COND (<NOT .Q-SLOT>
	  <BATCH-SCRIPT 200
			"STY output interrupt on a channel not in STY-OUTPUT-CHANNELS: "
			CR .CHAN CR "closing the offending channel if not to a tty">
	  <COND (<N=? <9 .CHAN> "TTY">
		      <CLOSE .CHAN>)>  )
	 (<EMPTY? <SET FEED <NTH ,INPUT-STRINGS .Q-SLOT>>>
	  <INTERRUPT "KILLER"			;"JOB HAS RUN OUT OF INPUT -- KILL IT"
		     .Q-SLOT
		     <NTH ,SPECS-OF-JOBS .Q-SLOT>
		     ON-COMPLETION:OUT-OF-INPUT
		     "Input requested when none was left
"							>
	  T)
	 (<SET JOB-CH <NTH ,JOB-CHANNELS .Q-SLOT>>
	  <SET CLOSE-SW <MAKE-SURE-OPEN .JOB-CH>>
	  <JOB-STOP .JOB-CH>
	  <SET NUMBER <MIN 51 <FIRST-INDEX <NTH ,DELIMITER-STRINGS .Q-SLOT> .FEED>>>
	  ;<SET NUMBER 1>
	  <PRINTSTRING .FEED .CHAN <- .NUMBER 1>>
	  <PRINC <CHTYPE <+ *20000* <ASCII <NTH .FEED .NUMBER>>>
			 CHARACTER> .CHAN>	;"FORCE LAST TO BE AN ACTIVATION CHAR"
	  <PUT ,INPUT-STRINGS .Q-SLOT <REST .FEED .NUMBER>>
	  <COND (<OK-TO-START-RUNNING? <NTH ,SPECS-OF-JOBS .Q-SLOT>>
		 <JOB-RESTART .JOB-CH .Q-SLOT>)>
	  <COND (.CLOSE-SW <CLOSE .JOB-CH>)> )> >

<DEFINE FIRST-INDEX (THINGS OBJECT "AUX" (LEN <LENGTH .OBJECT>))
   #DECL ((VALUE LEN) FIX (THINGS OBJECT) STRING
			 ;(THINGS) ;ANY ;(OBJECT) ;STRUCTURED)
   ;<COND (<NOT .OBJECT>
	  <SET OBJECT <CHTYPE .OBJECT LIST>>)>
   <COND ;(<MONAD? .THINGS>
	  <INDEX .THINGS .OBJECT .LEN>)
	 (ELSE
	  <MAPF ,MIN
		#FUNCTION ((X "AUX" MEM)
			   #DECL ((VALUE) FIX (X) CHARACTER (MEM) <OR STRING FALSE>)
			   <COND (<SET MEM <MEMQ .X .OBJECT>>
				  <- <LENGTH .OBJECT> <LENGTH .MEM> -1>)
				 (T .LEN)>)
		.THINGS>)>>

<DEFINE LOAD-SCRIPT (LD STR)
	#DECL ((VALUE) FALSE (LD) FLOAT (STR) STRING)
	<BATCH-SCRIPT 9 "AUSOPG=" <FIX .LD> ": " .STR>
	%<>>

;"OK-TO-LOAD-A-JOB? decides if the system is lightly loaded enough to
support another batch task.  It also watches for STY-OPEN-FAIL, which gets
set whenever the system was known to run out of STYs."

<DEFINE OK-TO-LOAD-A-JOB? ("OPTIONAL" (TASK %<>) "AUX" TLIM LD STOF)
   #DECL ((VALUE) ANY
	  ;(STY-OPEN-FAIL) ;<OR FALSE <LIST FIX LIST>> (STOF) <LIST FIX LIST>
	  (TASK) <OR FALSE VECTOR>
	  (TLIM) <OR FALSE FLOAT> (LD) FLOAT)

   <COND (,SYSTEM-GOING-DOWN %<>)
	 (<AND .TASK
	       <SET TLIM <COND (<SET TLIM <TIME-LIMIT .TASK>> <FLOAT .TLIM>)>>
	       <OR <L=? .TLIM %</ 2.0 60.0>>	;"QUICKIE OR TLIM < 5*EXP(1-LOAD/REF)"
		   <L=? .TLIM <* 5 <EXP <- 1 </ <SET LD <SYS-LOAD>> ,LOAD-REF1>>>>>>>)
	 (<L=? <SET LD <SYS-LOAD>> ,LOAD-REF1>
	  <OR <NOT ,STY-OPEN-FAIL>
	      <L? <NUMBER-OF-NON-FALSES ,JOB-ID-NUMBERS>
		  <1 <SET STOF ,STY-OPEN-FAIL>>>
	      <G? <DTDIFF <DTNOW> <2 .STOF>>
		    20.0> >)
	 (T <LOAD-SCRIPT .LD "not loading another task"> %<>)> >

<SETG OLD-LOAD 0.0>	;"initial value to remember"
<GDECL (OLD-LOAD) FLOAT>

;"OK-TO-START-RUNNING? decides if the system is lightly loaded enough to
support one more active job"

<DEFINE OK-TO-START-RUNNING? (TASK)
	#DECL ((VALUE) ANY (TASK) VECTOR)
	<OK-TO-X-RUNNING? .TASK ,LOAD-REF3 "not (re)starting any job"
				,LOAD-REF2 "(re)starting all jobs"
				"(re)starting short job" "not (re)starting long job">>

;"OK-TO-KEEP-RUNNING? decides if a task should be left running 
now, or stopped temporarily"

<DEFINE OK-TO-KEEP-RUNNING? (TASK)
	#DECL ((VALUE) ANY (TASK) VECTOR)
	<OK-TO-X-RUNNING? .TASK ,LOAD-REF5 "all jobs stopped"
				,LOAD-REF4 "all jobs started"
				"short job started" "long job stopped">>

;"Here is common code for previous 2 functions."

<DEFINE OK-TO-X-RUNNING? (TASK LR3/5 S3/5 LR2/4 S2/4 SS SL "AUX" TLIM QN CH SW LD)
   #DECL ((VALUE) ANY (TASK) VECTOR (LR3/5 LR2/4) FLOAT (S3/5 S2/4 SS SL) STRING
	  (TLIM) <OR FALSE FLOAT> (QN) FIX (CH SW) <OR CHANNEL FALSE>
	  (LD) FLOAT)
   <SET TLIM <COND (<SET TLIM <TIME-LIMIT .TASK>> <FLOAT .TLIM>)>>
   <PROG ()
	  <AND .TLIM
	       <L=? .TLIM %</ 2.0 60.0>>
	       <RETURN T>>
	  <SET QN <INDEX .TASK ,SPECS-OF-JOBS>>
	  <SET CH <NTH ,JOB-CHANNELS .QN>>
	  <SET SW <MAKE-SURE-OPEN .CH>>
	  <COND (<NOT .CH> <RETURN T>)
		(<G? <* <RUN-TIME .CH> 0.95> .TLIM>
		 <INTERRUPT "KILLER"
			    .QN
			    .TASK
			    ON-COMPLETION:TIME-LIMIT-EXPIRED
			    "Time limit expired
"					>
		 <RETURN %<>>)
		(.SW <CLOSE .CH>)>
	 <COND
	 (<G? <SET LD <SYS-LOAD>> .LR3/5>
	  <COND (<L=? ,OLD-LOAD .LR3/5>
		 <SETG OLD-LOAD .LD> <LOAD-SCRIPT .LD .S3/5>)>
	  %<>)
	 (<L=? .LD .LR2/4>
	  <COND (<G? ,OLD-LOAD .LR2/4>
		 <SETG OLD-LOAD .LD> <LOAD-SCRIPT .LD .S2/4>)>
	  T)
	 (<=? <TASK-TYPE .TASK> "SHORT">
	  <COND (<G? ,OLD-LOAD .LR3/5>
		 <SETG OLD-LOAD .LD> <LOAD-SCRIPT .LD .SS>)>
	  T)
	 (<L=? ,OLD-LOAD .LR2/4>
	  <SETG OLD-LOAD .LD> <LOAD-SCRIPT .LD .SL>
	  %<>)>>>

;"CHECK-Q-SLOT checks up on a q-slot (run-slot).  Sees if there is a task
in that slot (if not, ok to start one?), and decides if it should be started/
stopped/killed..."

<DEFINE CHECK-Q-SLOT (Q "AUX" (OLD-INT-LEVEL <INT-LEVEL 5>)	;"ASSURED INT LEVEL 5"
			      (TASK <NTH ,SPECS-OF-JOBS .Q>)
			      (CLOSE-SW %<>)
			      CH STATUS JCODE RUNT JOB2 TSK FL FI)
   #DECL ((VALUE) ANY (CLOSE-SW) <OR CHANNEL FALSE>
	  (Q OLD-INT-LEVEL JCODE FI) FIX
	  (CH) <OR CHANNEL FALSE> (TASK JOB2) <OR FALSE VECTOR> (TSK) VECTOR
	  (STATUS) <VECTOR FIX ANY [REST ANY]>
	  (RUNT FL) FLOAT)

   <COND (<NOT <NTH ,JOB-ID-NUMBERS .Q>>
	  <COND (<OK-TO-LOAD-A-JOB? <SET JOB2 <FIND-NEXT-TASK .Q>>>
		 <START-Q-SLOT .Q .JOB2>)> )
	 (<COND (<SET CH <NTH ,JOB-CHANNELS .Q>>
		 <SET CLOSE-SW <MAKE-SURE-OPEN .CH>>
		 <SET JCODE <1 <SET STATUS <JOB-STATUS .CH>>>>
		 <SET TSK .TASK>
		 %<>)
		(T)>)
	 (<G? <* <SET RUNT <RUN-TIME .CH>> .95>	;"5% LEEWAY AT THESE ONCE/MIN CHECKS"
	      <SET FL <COND (<TIME-LIMIT .TSK>)
			    (<=? <TASK-TYPE .TSK> "SHORT">
			     5.0)
			    (30.0)>>>

	  <TERMINATE-TASK .Q .TSK ON-COMPLETION:TIME-LIMIT-EXPIRED
			  "Time limit expired.
"					>
	  <START-Q-SLOT .Q>)
								;"SEE IF IDLE"
	 (<COND (<OR <==? 5 .JCODE>		;"STOPPED (BY ME?), DON'T COUNT"
		     <==? 8 .JCODE>>		;"   OR NEVER STARTED"
		 %<>)
		(<==? <NTH ,LAST-CPU-CHECKS .Q> .RUNT>		;"HASN'T USED ANY TIME"
		 <PUT ,HANG-COUNTS .Q <+ <NTH ,HANG-COUNTS .Q> 1>>
		 <COND (<G=? <NTH ,HANG-COUNTS .Q>
			     <* <SET FI <COND (<HANG-LIMIT .TSK>)
					      (3)>>
				%<FIX <+ </ 60.0 ,SLEEP-INTERVAL> 0.5>> >>
			<TERMINATE-TASK .Q .TSK ON-COMPLETION:JOB-HUNG
				<STRING <UNPARSE <COND (<HANG-LIMIT .TSK>)
						       (3)>>
				       " minutes elapsed with no CPU time used.
"						>>
			<START-Q-SLOT .Q>
			T)> )
		 (ELSE
		  <PUT ,HANG-COUNTS .Q 0>
		  <PUT ,LAST-CPU-CHECKS .Q .RUNT>
		  %<>)> )

	 (<L=? .JCODE 4>			;"SHOULD HAVE GENERATED AN INTERRUPT"
	  ;<INTERRUPT "INFERIOR" <NTH ,INFERIOR-NUMBERS .Q>>	;"QUESTIONABLE"
	  <COND (<AND .CLOSE-SW .CH>
		 <CLOSE .CH>)> )
	 (<==? 5 .JCODE>		;"IF JOB STOPPED (SUPPOSEDLY BY ME)"
	  ;"ASSUMES HERE THAT NOBODY WILL WANT INPUT WITHOUT INTERRUPTING FOR IT"
	  <COND (<OK-TO-START-RUNNING? .TSK>
		 <JOB-RESTART .CH .Q>)>
	  <COND (.CLOSE-SW <CLOSE .CH>)> )
	 (<==? 6 .JCODE>			;"JOB MAY BE .HANGing FOR INPUT"
	  <COND (.CLOSE-SW <CLOSE .CH>)> )
	 (<==? 7 .JCODE>				;"JOB IS RUNNING"
	  <COND (<NOT <OK-TO-KEEP-RUNNING? .TSK>>
		 <JOB-STOP .CH>)>
	  <COND (.CLOSE-SW <CLOSE .CH>)> )
	 (.CLOSE-SW <CLOSE .CH>)>
   <INT-LEVEL .OLD-INT-LEVEL>>

;"JOB-RESTART simply continues a job, while resetting the HANG-COUNTS
(count of how long the job has been considered 'dead')"

<DEFINE JOB-RESTART (JOB-CHA "OPTIONAL" (R-Q <INDEX .JOB-CHA ,JOB-CHANNELS>))
   #DECL ((VALUE) ANY (JOB-CHA) CHANNEL (R-Q) <OR FALSE FIX>)
   <AND <N==? <1 .JOB-CHA> 0> <JOB-START .JOB-CHA>>
   <AND .R-Q <PUT ,HANG-COUNTS .R-Q 0>>>

;"JOB-SCRIPT puts batch messages in a job's output script file, as if
they were output by the job itself"

<DEFINE JOB-SCRIPT (Q-SLOT "TUPLE" THINGS "AUX" (OLD-INT-LEVEL <INT-LEVEL 15>))
   #DECL ((VALUE) ANY (Q-SLOT OLD-INT-LEVEL) FIX (THINGS) <TUPLE [REST STRING]>)
   <COND (<G? <LENGTH .THINGS> 1>
	  <JOB-SCRIPT-1 .Q-SLOT <STRING !.THINGS>>)
	 (ELSE <JOB-SCRIPT-1 .Q-SLOT <1 .THINGS>>)>
   <INT-LEVEL .OLD-INT-LEVEL>>

;"JOB-SCRIPT-1 does the dirty work for the previous fcn"

<DEFINE JOB-SCRIPT-1 (Q-SLOT MSG-STRING
		      "AUX" (SCRIPT <NTH ,OUTPUT-SCRIPTS .Q-SLOT>)
			    (COUNT <1 .SCRIPT>)
			    (C <+ .COUNT <LENGTH .MSG-STRING>>))
   #DECL ((VALUE) ANY (MSG-STRING) STRING (Q-SLOT COUNT C) FIX
	  (SCRIPT) <LIST FIX STRING STRING>)

   <COND (<L=? .C 640>
	  <COPY-STRING <REST <2 .SCRIPT> .COUNT> .MSG-STRING>)
	 (<==? .COUNT 640>
	  <PUT .SCRIPT 3 .MSG-STRING>)
	 (<L? .COUNT 640>
	  <COPY-STRING <REST <2 .SCRIPT> .COUNT> .MSG-STRING>
	  <PUT .SCRIPT 3 <REST .MSG-STRING <- 640 .COUNT>> >)
	 (ELSE
	  <PUT .SCRIPT 3 <STRING <3 .SCRIPT> .MSG-STRING> >)>
   <PUT .SCRIPT 1 .C>
   <COND (<AND <G=? .C 320>
	       <NTH ,JOB-ID-NUMBERS .Q-SLOT>	;"MAKE SURE THERE IS A JOB"
	       <NTH ,JOB-CHANNELS .Q-SLOT>>	;"   AND JOB HAS BEEN LOADED"
	  <INTERRUPT "SCRIPTOR" .Q-SLOT>)> >	;"   BEFORE ASKING FOR SCRIPT
					TO OUTPUT FILE (WHICH HAPPENS AT INT-LEVEL 5)"

<DEFINE COPY-STRING (TARGET SOURCE "OPTIONAL" (MOST %<>))
   #DECL ((VALUE TARGET SOURCE) STRING
	  (MOST) <OR FIX FALSE>)
   <REPEAT ()
	<COND (<AND .MOST <L=? .MOST 0>>
	       <RETURN .TARGET>)
	      (<OR <EMPTY? .TARGET> <EMPTY? .SOURCE>>
	       <RETURN .TARGET>)>
	<PUT .TARGET 1 <1 .SOURCE>>
	<SET TARGET <REST .TARGET>>
	<SET SOURCE <REST .SOURCE>>
	<AND .MOST <SET MOST <- .MOST 1>>> >>

;"START-Q-SLOT starts something running in a given run-slot, assuming
there is nothing already running in that slot"

<DEFINE START-Q-SLOT (Q "OPTIONAL" (TASK <FIND-NEXT-TASK .Q>)	;"ASSURED INT LEVEL 5"
			"AUX" ID TEMP NUM JOB-CH H STR (OLD-INT-LEVEL <INT-LEVEL 5>) S V)
		;"RETURNS FALSE IF CALLER SHOULD TRY ANOTHER IN THIS
			SLOT IMMEDIATELY (I.E., THIS ONE LOST)"

   #DECL ((VALUE TEMP) ANY
	  (CR STR) STRING (H) <OR STRING FALSE>
	  (Q ID NUM OLD-INT-LEVEL) FIX
	  (JOB-CH) <OR CHANNEL FALSE>
	  (TASK) <OR VECTOR FALSE>
	  (S) <OR FALSE STRING>
	  (V) VECTOR)
  <PROG ()
   <COND (<OR <NTH ,JOB-ID-NUMBERS .Q>	;"DO NOTHING IF THAT SUB-QUEUE IN USE"
	      <NOT .TASK>>		;"OR NOTHING TO START"
	  <RETURN T>)>
   <INT-LEVEL 4>		;"ALLOW ANY INFERIOR INTERRUPTS (ETC) TO RUN"
   <INT-LEVEL 5>
   <PUT ,OVERHD-REFS .Q <RUN-TIME>>			;"MY CPU TIME"
   <PUT ,SPECS-OF-JOBS .Q .TASK>
   <PUT ,JOB-ID-NUMBERS .Q <SET ID <TASK-ID-NUMBER .TASK>>>
   <NOTE <STRING ".BATCH;#Q" <UNPARSE .Q> " " <TASK-NAME .TASK>>
	 <ORIGINATOR .TASK>		;"LEAVE A NOTE IN .BATCH DIR"
	 " task # "				;"FOR EASY CHECK ON HAPPENINGS"
	 .ID>
   <SETG N-RUNS <+ ,N-RUNS 1>>
   <PUT <NTH ,OUTPUT-SCRIPTS .Q> 1 0>
   <PUT <NTH ,OUTPUT-SCRIPTS .Q> 3 "">
   <BATCH-SCRIPT "Ready for " <ORIGINATOR .TASK> !\. <TASK-NAME .TASK> !\. .ID
		 ", run " <SET NUM <+ <NUMBER-OF-TIMES-RUN .TASK> 1>> 
		 ", run-slot " .Q>
   <PUT .TASK ,LAST-STARTING-TIME <DTNOW>>
   <SETUP-OUTPUT-FILE .TASK .Q>
   <JOB-SCRIPT .Q ,CR ,CR	;"START THE BULLSHIT IN THE OUTPUT FILE"
	       "Task " <TASK-NAME .TASK>
	       " for " <ORIGINATOR .TASK>
	       ", ID " <UNPARSE .ID> ", ready for run " <UNPARSE .NUM> ,CR
	       "It is now " <NOW>
	       <COND (<SET H <HOLIDAY?>> <STRING ", " .H ,CR>) (,CR)>>
   <PUT .TASK ,TASK-STATE "RUNNING">
   <WRITE-TASK .TASK>
   <COND (<NOT <SET TEMP <EVAL-RUN-TEST .TASK .Q>>>
	  <COND (<=? .TEMP #FALSE ("ERROR in run test")>
		 <PUT .TASK ,TASK-STATE "UNRUNNABLE">
		 <TERMINATE-TASK .Q .TASK IF-MADE-UNRUNNABLE "ERROR in run test
"			>)
		(ELSE
		 <TERMINATE-TASK .Q .TASK ON-COMPLETION:RUN-TEST-FALSE
				 "Run test returned a FALSE.
"					>)>
	   %<>)

	 (<NOT <SET JOB-CH <JOB-LOAD !<FN-REORDER <FILE-TO-RUN .TASK>> >>>
	  <COND (<=? .JOB-CH #FALSE ("DEVICE FULL")>
		 <BATCH-SCRIPT "USER DEVICE FULL! ">
		 <JOB-SCRIPT .Q "**** Cannot load file into job -- USR device is full."
			     ,CR "Will try again later. ****">
		 <TERMINATE-TASK .Q .TASK ON-DELAY "Batch daemon could not create a process.
"			>
		 T)
		(ELSE
		 <JOB-SCRIPT .Q "**** ERROR in loading file "
			     <UNPARSE <FILE-TO-RUN .TASK>>
			     " into job:" ,CR "  "
			     <UNPARSE <CHTYPE .JOB-CH LIST>>
			     "  ****">
		  <TERMINATE-TASK .Q .TASK ON-COMPLETION:ERROR-IN-STARTING
				  "Error occurred in loading program file into a process.
"					>
		  %<>)>)

	 (<NOT <SET TEMP <SETUP-INPUT-STRING <INPUT-STREAM .TASK> .Q>>>
	  <JOB-SCRIPT .Q "*** ERROR in reading input file:  "
		<UNPARSE <CHTYPE .TEMP LIST>>
		"  ***">
	  <TERMINATE-TASK .Q .TASK ON-COMPLETION:ERROR-IN-STARTING
			  "Error occurred in reading input file.
"				>
	  %<>)

	 (<AND <OR <AND <SET S <NTH ,INPUT-STRINGS .Q>>
			<NOT <EMPTY? .S>>>
		   <NTH ,OUTPUT-FILES .Q>>
	       <=? <SET TEMP <SETUP-STYS .JOB-CH .Q>>	;"NO STYS, AND SOME NEEDED"
		   #FALSE ("NO FREE STYS")>>
	  <BATCH-SCRIPT 200 "STY LOSSAGE on Q " .Q ", task " .ID
			": " <CHTYPE .TEMP LIST>>
	  <JOB-SCRIPT .Q "**** STY LOSSAGE:  "
		      <UNPARSE <CHTYPE .TEMP LIST>> ,CR
		      "Will try again in 20 minutes****">
	  <TERMINATE-TASK .Q .TASK ON-DELAY "No pseudo-terminals (STYs) were available.
"			>)

	 (ELSE
	  <PUT ,JOB-CHANNELS .Q .JOB-CH>
	  <PUT ,INFERIOR-NUMBERS .Q
		<JOB-GET-NUM .JOB-CH>>
	  <PUT ,JOB-SYSTEM-INDEXES .Q
		<* <CHTYPE <USET .JOB-CH "UIND"> FIX> ,*L>>
	  <USET .JOB-CH "XUNAME" <STRTOX <ORIGINATOR .TASK>>>
	  <USET .JOB-CH "XJNAME" <STRTOX <4 <SET V <FILE-TO-RUN .TASK>>>>>
	  <USET .JOB-CH "SNAME"
		<STRTOX <COND (<WORKING-DIRECTORY .TASK>)
			      (ELSE <ORIGINATOR .TASK>)>> >
	  <PUT ,JCL-LINES .Q
		<COND (<JCL-LINE .TASK>)
		      (ELSE "")> >
	  <COND (<NOT <EMPTY? <SET STR <NTH ,JCL-LINES .Q>>>>
		 <USET .JOB-CH "OPTIO" *040000000000*>		;"TELL IT THERE IS JCL"
		 <JOB-SCRIPT .Q "Job control line: "
			     .STR ,CR>)>
	  <PUT ,DELIMITER-STRINGS .Q
		<DELIMITER-STRING .TASK>>
	  <TRANSLATE-DEVICE .JOB-CH
			    '["TPL"]
			    ["DSK" ">" <ORIGINATOR .TASK> ".LPTR."]
			    %<> "OUTPUT" "INFERIORS">
	  <PUT ,HANG-COUNTS .Q 0>
	  <PUT ,LAST-CPU-CHECKS .Q 0.0>
	  <JOB-SCRIPT .Q ,CR
		    "vvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvv"
		    ,CR>
	  <COND (<OK-TO-START-RUNNING? .TASK>
	         <JOB-RESTART .JOB-CH .Q>)>
	  <CLOSE .JOB-CH>
	  T)>>
   <INT-LEVEL .OLD-INT-LEVEL> >

;"EVAL-RUN-TEST will evaluate the RUN-TEST for a task"

<DEFINE EVAL-RUN-TEST (TASK Q "AUX" (TEST <RUN-TEST .TASK>)
				    (R-T-INFO <RUN-TEST-INFO .TASK>)
				    (OLD-CHANLIST <CHANLIST>)
				    CHANNELS-LEFT-OPEN FILE
				    (WHO <ORIGINATOR .TASK>)
				    ANSWER
				    (MY-TASK .TASK)
				    (INFO-FIELD .R-T-INFO))
   #DECL ((VALUE TEST ANSWER R-T-INFO) ANY (INFO-FIELD) <SPECIAL ANY>
	  (TASK) VECTOR (MY-TASK) <SPECIAL VECTOR> (OLD-CHANLIST) LIST
	  (Q CHANNELS-LEFT-OPEN) FIX
	  (CR WHO FILE) STRING)
   <PROG ()
	 <COND (<NOT .TEST> <RETURN T>)>
	 <JOB-SCRIPT .Q ,CR "EVALing run test." ,CR>
	 <BATCH-SCRIPT 100 "EVALing run test for " .WHO
		       ", task " <TASK-ID-NUMBER .TASK>>
	 <NOTE <SET FILE <STRING ".BATCH;#Q" <UNPARSE .Q> " " <TASK-NAME .TASK> >>
	       "EVALing RUN TEST for "
	       .WHO
	       " task # "
	       <TASK-ID-NUMBER .TASK>>
	 <SET ANSWER <EVAL-WITH-ACT .TEST>>
	 <SET CHANNELS-LEFT-OPEN <CLOSE-LITTERED-CHANNELS .OLD-CHANLIST>>
	 <COND (<N==? .INFO-FIELD .R-T-INFO>
		<PUT .TASK ,RUN-TEST-INFO .INFO-FIELD>)>
	 <NOTE .FILE
	       .WHO
	       " task # "
	       <TASK-ID-NUMBER .TASK>>
	 <COND
	  (<AND	<TYPE? .ANSWER FALSE>
		<G=? <LENGTH .ANSWER> 1>
		<=? <1 .ANSWER> "***ERROR CAUSED***">>
	   <PUT .TASK ,TASK-STATE "UNRUNNABLE">
	   <JOB-SCRIPT .Q "
	***          HOLD EVERYTHING!           ***
	*** your run-test just caused an error! ***
	***      Fix it and try again, ok?      ***

	Args to error routine were these: " ,CR
		      <PROG ((OBLIST ())) #DECL ((OBLIST) <SPECIAL LIST>)
			    <UNPARSE <CHTYPE <REST .ANSWER> LIST>>>
		      ,CR
		      <COND (<G? .CHANNELS-LEFT-OPEN 0>
			     <STRING "You also left "
				     <UNPARSE .CHANNELS-LEFT-OPEN>
				     " channel(s) open! "
				     ,CR>)
			    (ELSE "")>>
	   <BATCH-SCRIPT <MAPF ,LIST
			       <FUNCTION (O) #DECL ((O) ATOM) <GET .O OBLIST>>
			       ,BATCHQ-OBL>>
	   <MAIL .WHO <STRING
"  Uh, excuse the interruption, " <FULLNAME <ORIGINATOR .TASK>> ",
but your run-test for task " <TASK-NAME .TASK> ", ID " <TASK-ID-NUMBER .TASK> ",
caused an error when evaluated.  The task has been made
unrunnable.  Please be more careful when you try again.
"
!<COND (<G? .CHANNELS-LEFT-OPEN 0>
	("You also left " <UNPARSE .CHANNELS-LEFT-OPEN> " channel(s) open."))
       (T '(""))>
"
		Love and kisses,
		Batch N. Demon">>
	   <BATCH-SCRIPT .WHO "'s RUN TEST for task " <TASK-ID-NUMBER .TASK>
			 " " <TASK-NAME .TASK> " returned:"
			 CR .ANSWER>
	   #FALSE ("ERROR in run test") )
	 (<G? .CHANNELS-LEFT-OPEN 0>
	  <JOB-SCRIPT	.Q "Run test returned:  "
			<UNPARSE .ANSWER>
			,CR
			<COND (.ANSWER "and left ")
			      (ELSE "Task not started.  Run test left ")>
			<UNPARSE .CHANNELS-LEFT-OPEN>
			" channel(s) open.  PLEASE DON'T DO IT AGAIN! " ,CR>
	  .ANSWER)
	 (.ANSWER
	  <JOB-SCRIPT	.Q "Run test returned:  "
			<UNPARSE .ANSWER> ,CR>
	  .ANSWER)
	 (ELSE
	  <JOB-SCRIPT	.Q "Run test returned:  "
			<UNPARSE .ANSWER> ,CR
			"Task not started" ,CR>
	  .ANSWER)>>>

<DEFINE EVAL-WITH-ACT user-test-activation (TEST)      ;"Let compiler reset stack model."
	#DECL ((VALUE TEST) ANY (user-test-activation) <SPECIAL ACTIVATION>)
	<EVAL .TEST>>

;"SETUP-OUTPUT-FILE sets-up the output-file for a task, just
before the run.  If it is impossible to open one, It is assumed
that this will remain the case, and information will be kept such
that the job-output will be (partly) ignored"

<DEFINE SETUP-OUTPUT-FILE (TASK Q "AUX" (FILE <OUTPUT-FILE .TASK>) C F R N)
   #DECL ((VALUE FILE) ANY (TASK) VECTOR (Q N) FIX
	  (C) <OR CHANNEL FALSE> (F R) <OR STRING FALSE>)
	<SET F <COND (<=? .FILE ""> %<>)
		     (<TYPE? .FILE VECTOR>
		      <STRING	<1 .FILE>
				!\:
				<2 .FILE>
				!\;
				<3 .FILE>
				!\  
				<4 .FILE> >)
		     (<TYPE? .FILE STRING>
		      .FILE)
		     (ELSE
		      <STRING	<ORIGINATOR .TASK>
				";DSK:"
				<TASK-NAME .TASK>
				" OUTPUT">)> >
   <COND (.F
	  <COND (<SET R <MEMBER "RUN_#" .F>>
		 <SUBSTRUC <UNPARSE <+ 100001
				       <SET N <NUMBER-OF-TIMES-RUN .TASK>>>>
			   1 5 .R>)
		(<SET R <MEMBER "MSG:" .F>>
		 <SET F <STRING "DSK:.BATCH;_MSG "
				<UNPARSE <TASK-ID-NUMBER .TASK>>>>)>)>
   <PUT ,OUTPUT-FILES .Q .F>
   <COND (<NOT .F> %<>)
	 (<AND <MEMQ !\> .F> <SET C <OPEN "PRINT" .F>>>
	  <PRINC !\  .C>	;"So CHARAPPEND will use it."
	  <CLOSE .C>
	  T)
	 (<SET C <OR <OPEN "READ" .F> <OPEN "PRINT" .F>>>
	  <CLOSE .C>
	  T)
	 (ELSE
	  <PUT ,OUTPUT-FILES .Q %<>>
	  %<>)>>

;"RESCHEDULE-TASK determines when a task should next be run (if ever).
This may involve evaluating an arbitrary form"

<DEFINE RESCHEDULE-TASK (TASK JOB-Q "OPTIONAL" (DELAY <>)
			 "AUX" (RESCHEDULER <SCHEDULER .TASK>)
			       (RESCHED-INFO <RESCHEDULE-INFO .TASK>)
			       (THIS-TIME <TIME-OF-NEXT-RUN .TASK>)
			       NEXT-TIME F)
   #DECL ((VALUE RESCHEDULER RESCHED-INFO) ANY
	  (TASK) VECTOR
	  (JOB-Q F) FIX
	  (DELAY) <OR FALSE FIX>
	  (THIS-TIME NEXT-TIME) <OR LIST FALSE>)

   <SET NEXT-TIME
	<COND (.DELAY <DTADD <DTNOW> (()(0 .DELAY))>)
	      (.RESCHEDULER
		<EVAL-RESCHEDULER .TASK .JOB-Q .RESCHEDULER>)
	      (<TYPE? .RESCHED-INFO LIST>
		<REL-RESCHED <TIME-OF-NEXT-RUN .TASK> .RESCHED-INFO>)
	      (<TYPE? .RESCHED-INFO VECTOR>
		<COND (<EMPTY? .RESCHED-INFO> %<>)
		      (ELSE
			<PUT .TASK ,RESCHEDULE-INFO <REST .RESCHED-INFO>>
			<1 .RESCHED-INFO>)>)
	      (<MEMBER <TASK-STATE .TASK> '["UNRUNNABLE" "ABORTED"]>
	       .THIS-TIME)> >

   <COND (<=? .NEXT-TIME #FALSE ("ERROR in rescheduler")>
	  <WRITE-TASK .TASK>)
	 (<NOT .NEXT-TIME>				;"NOT RESCHEDULED"
	  <PUT .TASK ,TASK-STATE "REMOVED">
	  <WRITE-TASK .TASK>
	  <ACKNOWLEDGE .TASK IF-REMOVED-FROM-QUEUE
		"Not rescheduled">)
	 (<AND <WHEN-TO-STOP-RESCHEDULING .TASK>;"IF PAST LAST RESCHEDULE DATE"
	       <G? <DTDIFF .NEXT-TIME <WHEN-TO-STOP-RESCHEDULING .TASK>> 0.0>>
	  <PUT .TASK ,TASK-STATE "REMOVED">
	  <WRITE-TASK .TASK>
	  <ACKNOWLEDGE .TASK IF-REMOVED-FROM-QUEUE
		"Rescheduled past last possible date">)
	 (<AND <MAXIMUM-NUMBER-OF-RUNS .TASK>
					;"ALREADY UPDATED BY TERMINATE-TASK"
	       <G=? <SET F <NUMBER-OF-TIMES-RUN .TASK>>
		    <SET F <MAXIMUM-NUMBER-OF-RUNS .TASK>>>>
	  <PUT .TASK ,TASK-STATE "REMOVED">
	  <WRITE-TASK .TASK>
	  <ACKNOWLEDGE .TASK IF-REMOVED-FROM-QUEUE
		"Maximum number of runs reached">)

	 (<MEMBER <TASK-STATE .TASK>
		  '["RUNNING" "UNRUNNABLE"]>
	  <AND <=? <TASK-STATE .TASK> "RUNNING">
	       <PUT .TASK ,TASK-STATE "RUNNABLE">>
	  <PUT .TASK ,TIME-OF-NEXT-RUN .NEXT-TIME>
	  <COND (<N=? .THIS-TIME .NEXT-TIME>
		 <REMOVE-TASK .TASK>   ;"PUT INTO THE RIGHT PLACE IN THE QUEUE"
		 <INSERT-TASK .TASK>)>
	  <WRITE-TASK .TASK>)
	 (ELSE
	  <WRITE-TASK .TASK>)> >

;"REL-RESCHED determines new time-of-next-run by 'add increment' method;
increment is added until the new time computed has past."

<DEFINE REL-RESCHED (OLD-TIME RESCHED-INC)
   #DECL ((VALUE OLD-TIME RESCHED-INC) LIST)
   <REPEAT ()
	<COND (<NOT <BEFORE? .OLD-TIME <SET OLD-TIME <DTADD .OLD-TIME .RESCHED-INC>>>>
	       <RETURN '((199 9 9) (9 9 9) "EST")>)
	      (<PAST? .OLD-TIME>)
	      (<RETURN .OLD-TIME>)> >>

;"EVAL-RESCHEDULER will evaluate a user's rescheduler form.  It tries
to protect the demon against nastiness, but the protection is quite limited"

<DEFINE EVAL-RESCHEDULER (TASK JOB-Q
			  "OPTIONAL" (RESCHEDULER <SCHEDULER .TASK>)
			  "AUX" (OLD-CHANLIST <CHANLIST>)
				CHANNELS-LEFT-OPEN RESULT
				(R-INFO <RESCHEDULE-INFO .TASK>)
				(WHO <ORIGINATOR .TASK>)
				(MY-TASK .TASK)
				(INFO-FIELD .R-INFO)
				FILE)
   #DECL ((VALUE RESULT RESCHEDULER R-INFO) ANY (INFO-FIELD) <SPECIAL ANY>
	  (TASK) VECTOR (MY-TASK) <SPECIAL VECTOR>
	  (JOB-Q CHANNELS-LEFT-OPEN) FIX
	  (CR WHO FILE) STRING
	  (OLD-CHANLIST) LIST)
   
   <BATCH-SCRIPT 100 "EVALing rescheduler for " .WHO ", task " <TASK-ID-NUMBER .TASK>>
   <NOTE <SET FILE <STRING ".BATCH;#Q" <UNPARSE .JOB-Q> " " <TASK-NAME .TASK> >>
	 "EVALing RESCHEDULER for " .WHO " task # " <TASK-ID-NUMBER .TASK>>
   <SET RESULT
	<COND (<TYPE? <SET RESULT <EVAL-WITH-ACT .RESCHEDULER>> LIST>
	       <DTNORM .RESULT>)
	      (<OR <TYPE? .RESULT FIX> <TYPE? .RESULT FLOAT>>
	       <DTADD <DTNOW> ('(0 0 0) (0 <FIX .RESULT> 0))>)
	      (<NOT .RESULT>
	       .RESULT)>>

   <SET CHANNELS-LEFT-OPEN <CLOSE-LITTERED-CHANNELS .OLD-CHANLIST>>

   <COND (<N==? .R-INFO .INFO-FIELD>
	  <PUT .TASK ,RESCHEDULE-INFO .INFO-FIELD>)>

   <COND (<ASSIGNED? FILE>
	  <NOTE .FILE
		.WHO
		" task # "
		<TASK-ID-NUMBER .TASK>>)>

   <COND (<AND	<NOT .RESULT>
		<G? <LENGTH .RESULT> 1>
		<=? <1 .RESULT> "***ERROR CAUSED***">>

	  <PUT .TASK ,TASK-STATE "UNRUNNABLE">
	  <JOB-SCRIPT .JOB-Q "
	***		        OOUCH!!				***
	***   THE RESCHEDULER JUST GAVE THE DAEMON HEARTBURN!	***
	***		TIME TO FIX IT AND TRY AGAIN.		***
	***		YOUR TASK IS NOW \"UNRUNNABLE\".		***
"		<COND (<G? .CHANNELS-LEFT-OPEN 0>
		       <STRING "IT ALSO LEFT "
				<UNPARSE .CHANNELS-LEFT-OPEN>
				" CHANNEL(S) OPEN! " ,CR>)
		      (ELSE "")>>
	  <MAIL <ORIGINATOR .TASK> <STRING
"  Hello there," <FULLNAME <ORIGINATOR .TASK>> ".
Your rescheduler for task " <TASK-NAME .TASK> ", ID " <TASK-ID-NUMBER .TASK> ",
is faulty.  Please repair it.
"
!<COND (<G? .CHANNELS-LEFT-OPEN 0>
	("It also left " <UNPARSE .CHANNELS-LEFT-OPEN> " channel(s) open."))
       (T '(""))>
"
		Sincerely,
		Your loving Batch Daemon">>

	  <ACKNOWLEDGE .TASK IF-MADE-UNRUNNABLE "ERROR in rescheduler">
	  #FALSE ("ERROR in rescheduler"))
	 (<G? .CHANNELS-LEFT-OPEN 0>
	  <JOB-SCRIPT .JOB-Q ,CR "RESCHEDULER LEFT "
		      <UNPARSE .CHANNELS-LEFT-OPEN>
		      " CHANNEL(S) OPEN! " ,CR>
	  .RESULT)
	 (ELSE .RESULT)>>

;"CLOSE-LITTERED-CHANNELS closes any channels a user form may have left open"

<DEFINE CLOSE-LITTERED-CHANNELS (OLD-CHANLIST "AUX" (CHANNELS-LEFT-OPEN 0)
				 (CLIST <CHANLIST>))
   #DECL ((VALUE CHANNELS-LEFT-OPEN) FIX
	  (CLIST OLD-CHANLIST) <LIST [REST CHANNEL]>)

   <REPEAT ()
	<COND (<EMPTY? .CLIST>
	       <RETURN .CHANNELS-LEFT-OPEN>)
	      (<MEMQ <1 .CLIST> .OLD-CHANLIST>
	       <SET CLIST <REST .CLIST>>)
	      (ELSE <CLOSE <1 .CLIST>>
	       <SET CHANNELS-LEFT-OPEN <+ .CHANNELS-LEFT-OPEN 1>>
	       <SET CLIST <CHANLIST>>)>>>

;"ACKNOWLEDGE handles acknowledgements for all tasks."

;<'PACKAGE "ACKN">

;<ENTRY ACKNOWLEDGE>

;<USE	;"TASKV"			; "STATES-AFTER-RUN"
	"BATCHQ"			; "task descriptor names"
	"BATCHN"			; "TASK-DESCRIPTOR"
	"CHARAP"			; "CHARAPPEND"
	"NOW"				; "NOW">

; "ACKNOWLEDGE will modify task STATEs and send messages to users
   according to the ACKNOWLEDGEMENT-INFO field of a task at any
   predefined condition"

;<SET A-NOTES ()>	;"added by SWG 10/26/78 -- what's it for?"

<DEFINE ACKNOWLEDGE (TASK-D CONDITION
		     "OPTIONAL" (REASON %<>)
		     "AUX" (A-INFO <ACKNOWLEDGEMENT-INFO .TASK-D>)
			   A-GUTS NOTICE)
   #DECL ((VALUE) ANY (TASK-D) VECTOR
	  (CONDITION) ATOM (REASON) <OR FALSE STRING>
	  (A-INFO A-GUTS) <OR FALSE VECTOR>
	  (NOTICE) STRING)

   <COND (<AND .A-INFO
	       <SET A-GUTS <DIRECT-ACKNS .A-INFO .CONDITION>>>
	  <BATCH-SCRIPT 100
			"ACKNOWLEDGEMENT for "
			<ORIGINATOR .TASK-D> !\.
			<TASK-NAME .TASK-D> !\.
			<UNPARSE <TASK-ID-NUMBER .TASK-D>>
			" condition:  "
			.CONDITION !\, CR
			"      reason:  "
			.REASON
			"      to do: "
			.A-GUTS>

	 <SET NOTICE <STRING "
As requested, this message acknowledges that DM Batch task #"
	<UNPARSE <TASK-ID-NUMBER .TASK-D>> " (named
'" <TASK-NAME .TASK-D> "' for user '" <ORIGINATOR .TASK-D>
"') encountered the condition " <SPNAME .CONDITION> "
on run #" <UNPARSE <NUMBER-OF-TIMES-RUN .TASK-D>> " on " <NOW>
	!<COND (.REASON (", because:
" .REASON))
	       (T '("."))>>>

	 <MAPF	%<>
		#FUNCTION ((P)
			   #DECL ((P VALUE) ANY)
			   <COND (<TYPE? .P STRING>
				  <MAIL .P .NOTICE>)
				 (<TYPE? .P FIX>
				  <ACKN-TO-TASK .P .NOTICE>)
				 ;(ELSE
				  <SET A-NOTES
			      ("Invalid acknowledgement element" !.A-NOTES)>)>)
		.A-GUTS>)>>

; "DIRECT-ACKNS looks in the ACKNOWLEDGEMENT-INFO field of a task
   and determines what actions (or, if any) are to be performed given
   the current 'condition'.  There are 3 'catch-alls' for ease in use"

<DEFINE DIRECT-ACKNS (ACKN-INFO CONDIT "AUX" X)
   #DECL ((VALUE X) <OR FALSE VECTOR> (ACKN-INFO) VECTOR (CONDIT) ATOM)
  <AND <SET X
   <COND (<SET X <MEMQ .CONDIT .ACKN-INFO>>	;"LOOK FOR THIS CONDITION"
	  <REST .X>)
	 (<AND <MEMQ .CONDIT			;"OR 'IF-MODIFIED' GROUP"
		     '![IF-MADE-UNRUNNABLE
			IF-MADE-RUNNABLE
			IF-ABORTED
			IF-REMOVED-FROM-QUEUE]>
	       <SET X <MEMQ IF-MODIFIED .ACKN-INFO>>>
	  <REST .X>)
	 (<AND <MEMQ .CONDIT				; "OR 'ON-COMPLETION' GROUP"
		     '![ON-COMPLETION:ERROR-IN-STARTING
			ON-COMPLETION:RUN-TEST-FALSE
			ON-COMPLETION:TIME-LIMIT-EXPIRED
			ON-COMPLETION:JOB-HUNG
			ON-COMPLETION:NORMAL
			ON-COMPLETION:NOT-CONTINUABLE
			ON-COMPLETION:CONTINUABLE-INTERRUPT
			ON-COMPLETION:OUT-OF-INPUT
			ON-COMPLETION:SYSTEM-CRASH]>
	       <SET X <MEMQ ON-COMPLETION .ACKN-INFO>>>
	  <REST .X>)
	 (<SET X <MEMQ ON-ANY-OTHER .ACKN-INFO>>	; "OR 'ON-ANY-OTHER'"
	  <REST .X>)
	 (ELSE %<>)>>
   <MAPF <>
	 <FUNCTION (Y) #DECL ((Y) <OR ATOM VECTOR>)
		   <COND (<TYPE? .Y VECTOR> <MAPLEAVE .Y>)>>
	 .X>>>


; "ACKN-TO-TASK changes a task's state when requested by
   an acknowledgement.  For the sake of timing problems,
   changes to 'UNRUNNABLE' will not abort 'RUNNING' tasks,
   but changes to 'ABORTED' will."

<DEFINE ACKN-TO-TASK (NUM NOTICE "AUX" (TASK <TASK-DESCRIPTOR <ABS .NUM>>))
   #DECL ((VALUE) ANY (NUM) FIX (NOTICE) STRING (TASK) <OR FALSE VECTOR>)
   <COND (.TASK
	  <COND (<G? .NUM 0> <C-STATE .TASK   "RUNNABLE" .NOTICE>)
		(T	     <C-STATE .TASK "UNRUNNABLE" .NOTICE>)>)>>

;"<DEFINE ACKN-TO-TASK (TASKS-AND-STATE NOTICE \"AUX\" NEW-STATE)
   #DECL ((VALUE TASKS-AND-STATE NEW-STATE) ANY
	  (NOTICE) STRING)

   <COND (<NOT <TYPE? .TASKS-AND-STATE LIST VECTOR>>)
	 (<EMPTY? .TASKS-AND-STATE>)
	 (<NOT <TYPE? <SET NEW-STATE <1 .TASKS-AND-STATE>> STRING>>)
	 (ELSE
	  <MAPF	%<>
		#FUNCTION ((TID \"AUX\" TASKO)
			   #DECL ((VALUE TID) ANY (TASKO) <OR FALSE VECTOR>)
			   <AND <DECL? .TID '<OR <LIST STRING STRING> FIX>>
				<SET TASKO <TASK-DESCRIPTOR .TID>>
				<C-STATE .TASKO .NEW-STATE .NOTICE>>)
		<REST .TASKS-AND-STATE>>)>>"

; "C-STATE changes the STATE of a single task.  Only a change to
   'ABORTED' is allowed to stop a running task"

<DEFINE C-STATE (THE-TASK TO-STATE NOTICE)
   #DECL ((VALUE) ANY (THE-TASK) VECTOR (TO-STATE NOTICE) STRING)
   <COND (<=? .TO-STATE "RUNNING">)
	 (<=? .TO-STATE <TASK-STATE .THE-TASK>>)
	 (<=? <TASK-STATE .THE-TASK> "RUNNING">
	  <AND <=? .TO-STATE "ABORTED">
	       <TASK-ABORT .THE-TASK .NOTICE>>)
	 (<PUT .THE-TASK ,TASK-STATE .TO-STATE>
	  <NOTIFY-TASK .THE-TASK .TO-STATE .NOTICE>)> >

; "NOTIFY-TASK puts a note in a task's output-file if
   an acknowledgement changes its state"

<DEFINE NOTIFY-TASK (TTASK NSTATE NOTE "AUX" (OUTF <OUTPUT-FILE .TTASK>))
   #DECL ((VALUE OUTF) ANY (TTASK) VECTOR (NSTATE NOTE) STRING)
   <COND (<NOT .OUTF>
	  <SET OUTF <STRING <ORIGINATOR .TTASK>
			    ";DSK:"
			    <TASK-NAME .TTASK>
			    " OUTPUT">>)
	 (<TYPE? .OUTF VECTOR>
	  <SET OUTF <STRING <1 .OUTF> !\:
			    <2 .OUTF> !\;
			    <3 .OUTF> !\ 
			    <4 .OUTF>>>)
	 (ELSE <SET OUTF %<>>)>

   <AND .OUTF
	<CHARAPPEND .OUTF 0 T CR CR <NOW> CR
		    "Task state changed to "
		    .NSTATE
		    " by "
		    .NOTE>>>


; "ACKN-TO-USER sends a note to some luser about a task.  It tries
   a :SEND first; if that fails, sends DDT style mail."

;<DEFINE ACKN-TO-USER (PERSON NOTICE "AUX" OUTCHAN)
   #DECL ((VALUE) ANY (NOTICE PERSON) STRING (OUTCHAN) <OR CHANNEL FALSE>)
   <COND (<SET OUTCHAN <OPEN "READ" .PERSON "HACTRN" "CLI">>
	  <PRINC ".BATCH ">
	  <PRINC <NOW>>
	  <PRINC ,CR>
	  <PRINC .NOTICE>
	  <PRINC ,CR>
	  <CLOSE .OUTCHAN>)
	 (T <MAIL .PERSON .NOTICE>)>>

;<ENDPACKAGE>

;"INFERIOR-INTERRUPT-ROUTINE catches inferior interrupts: requests for
JCL, suicide, valrets, etc."

<DEFINE INFERIOR-INTERRUPT-ROUTINE (JOB-NUM		;"AT INT LEVEL 5"
				    "AUX" (Q <INDEX .JOB-NUM ,INFERIOR-NUMBERS>)
					  ITASK JOB-CH CLOSE-SW STATUS JCODE)
   #DECL ((VALUE) ANY
	  (JOB-NUM JCODE) FIX
	  (Q) <OR FIX FALSE>
	  (JOB-CH) <OR CHANNEL FALSE> (CLOSE-SW) <OR CHANNEL FALSE>
	  (STATUS) <VECTOR FIX ANY [REST ANY]>
	  (ITASK) <OR FALSE VECTOR>
	  (CR) STRING)

   <COND (<AND .Q <NTH ,JOB-ID-NUMBERS .Q> <SET ITASK <NTH ,SPECS-OF-JOBS .Q>>>
	  <SET JOB-CH <NTH ,JOB-CHANNELS .Q>>
	  <SET CLOSE-SW <MAKE-SURE-OPEN .JOB-CH>>
	  <SET STATUS <JOB-STATUS .JOB-CH>>
	  <SET JCODE <1 .STATUS>>
	  <COND (<L=? .JCODE 0>			;"JOB-STATUS PROBLEM, BAD CHANNEL/JOB"
		 <BATCH-SCRIPT 300 "For task " <NTH ,JOB-ID-NUMBERS .Q>
			", inferior " .JOB-NUM
			" JOB-STATUS reports:  " .STATUS CR
			"     for channel " .JOB-CH>
		 <TERMINATE-TASK .Q .ITASK ON-COMPLETION:NOT-CONTINUABLE <2 .STATUS>>)
		(<==? 1 .JCODE>			;"SUICIDE REQUESTED"
		 <TERMINATE-TASK .Q .ITASK ON-COMPLETION:NORMAL <2 .STATUS>>)
		(<==? 2 .JCODE>			;"NOT CONTINUABLE"
		 <TERMINATE-TASK .Q .ITASK ON-COMPLETION:NOT-CONTINUABLE <2 .STATUS>>)
		(<==? 3 .JCODE>			;".VALRET"
		 <TERMINATE-TASK .Q .ITASK ON-VALRET
				    <STRING !\' <2 .STATUS> "'
 was .VALUEd.
"> >)
		(<==? 4 .JCODE>			;".BREAK 12,"
		 <BREAK-12-CHECKER .Q <2 .STATUS> .JOB-CH>
		 <COND (.CLOSE-SW
			<CLOSE .JOB-CH>)> )
		(<==? 5 .JCODE>
		 <TERMINATE-TASK .Q .ITASK ON-COMPLETION:CONTINUABLE-INTERRUPT
				 <2 .STATUS>>)
		(.CLOSE-SW <CLOSE .JOB-CH>)> )> >

;"VALRET-CHECKER is a questionable processor for handleing valrets from
an inferior.  Currently, all valrets will cause scripting and termination
of the run, as the demon cannot parse arbitrary ddt-like commands"

;<DEFINE VALRET-CHECKER (Q VALRET-STRING JOB-CH "AUX" TSK)
   #DECL ((VALUE) ANY (Q) FIX
	  (VALRET-STRING CR) STRING (JOB-CH) CHANNEL
	  (TSK) VECTOR)

   <JOB-STOP .JOB-CH>
   <JOB-SCRIPT .Q ,CR "**** FROM BATCH:  '"  .VALRET-STRING
		 "' was valretted, run continues ****" ,CR>
   <ACKNOWLEDGE <SET TSK <NTH ,SPECS-OF-JOBS .Q>> ON-VALRET .VALRET-STRING>
   <USET .JOB-CH "APIRQ" *200*>
   <COND (<OK-TO-START-RUNNING? .TSK>
	  <JOB-RESTART .JOB-CH .Q>)> >

;"PROCED-DISOWN decides if a job has valretted something equivalent.
This may be caught specially in the future -- the demon could actually
disown the inferior"

;<DEFINE PROCED-DISOWN (VALRETTED "AUX" V)
   #DECL ((VALRETTED) STRING (V) <OR STRING FALSE>)
   <AND <SET V <MEMBER ":PROCED" .VALRETTED>>
	<MEMBER ":DISOWN" .V>>>

;"BREAK-12-CHECKER handles all .BREAK 12, 's from inferiors.  Only
cases usefully handled are requests to pass/clear JCL"

<DEFINE BREAK-12-CHECKER (Q REQUESTS JOB-CH
			  "AUX" REQ P
				(THE-LINE <NTH ,JCL-LINES .Q>))
   #DECL ((VALUE) ANY (Q) FIX
	  (REQUESTS) <UVECTOR [REST WORD]>
	  (JOB-CH) CHANNEL (REQ) WORD
	  (THE-LINE) STRING
	  (P) <OR FALSE FIX>)
   <MAPF <>
	 <FUNCTION (REQ) #DECL ((REQ) WORD)
	 <COND (<==? <GETBITS .REQ %<BITS 18 18>>
		     #WORD *5*>			;"JOB WANTS A JCL-LINE"

		<COND (<=? .THE-LINE "">)	;"OOPS -- NONE THERE"
		      (<SET P <PASS-JCL-DOWN .THE-LINE .JOB-CH
				      <CHTYPE <GETBITS .REQ %<BITS 18>>
					      FIX>> >)
		      (ELSE
		       <JOB-SCRIPT .Q ,CR
				   "****FROM BATCH: JCL LINE LOSSAGE -- "
				   <2 .P>
				   " ****" ,CR>)>)
	       (<==? <GETBITS .REQ %<BITS 18 18>>
		     #WORD *400005*>
		<PUT ,JCL-LINES .Q "">)>>
	 .REQUESTS>
   <USET .JOB-CH "APIRQ" *2000*>				;"CLEAR THE .BREAK"
   <COND (<OK-TO-START-RUNNING? <NTH ,SPECS-OF-JOBS .Q>>	;"& MAYBE RESTART JOB"
	  <JOB-RESTART .JOB-CH .Q>)> >

;"GC-INTERRUPT-ROUTINE makes a log note of Garbage Collections"

<DEFINE GC-INTERRUPT-ROUTINE (TIM CODE NAME)
   #DECL ((TIM) FLOAT (CODE) FIX (NAME) ATOM)
   <BATCH-SCRIPT 30 "GC:" <FIX3-FMT .TIM> " sec, "
		 <NTH '["Call to GC from "
			"Free space for "
			"Control stack for "
			"Top-level LVALs for "
			"Global vector for "
			"TYPE vector for "
			"Immovable impure storage for "
			"Internal stack for "
			"Control and internal stacks for "
			"Pure storage for "
			"Second, exhaustive GC from "]
		      <+ .CODE 1>>
		 .NAME>>

;"TIME-NOW returns a string for the current time, like HH:MM ZONE "

<DEFINE TIME-NOW ("AUX" (TN <DTNOW>) (TN2 <2 .TN>))
   #DECL ((VALUE) STRING (TN) <LIST LIST LIST STRING>
	  (TN2) <LIST FIX FIX FIX>)
   <STRING <UNPARSE <1 .TN2>> !\:
	   <REST <UNPARSE <+ <2 .TN2> 100>>> !\ 
	   <3 .TN>>>


;"KILL-OLD-MARKERS wipes out old .BATCH;#Qn xxxxxx  files.  It should also
check for any that might point to jobs that have killed the demon with a
bad rescheduler/run-test."

<DEFINE KILL-OLD-MARKERS ("AUX" (QN ,NQUEUES))
   #DECL ((VALUE) ANY (QN) FIX)

   ;"SHOULD CHECK FOR FILES STARTING WITH 'EVALing run test' OR
	'EVALing rescheduler'; IF ANY, BATCH-SCRIPT, MAKE IT UNRUNNABLE,
	SEND MAIL, AND ACKNOWLEDGE IT"

   <PROG ()
	<COND (<RENAME <STRING ".BATCH;#Q"
			       <UNPARSE .QN>
			       " >" >>
	       <AGAIN>)
	      (<G? <SET QN <- .QN 1>> 0>
	       <AGAIN>)>> >

<SETG INTS-SETUP <SETG ERROR-INT-SETUP %<>>>


;"SETUP-ERROR-INTERRUPT-HANDLER ON's the error handler, ONCE."

<DEFINE SETUP-ERROR-INTERRUPT-HANDLER ()
   <COND (<NOT ,ERROR-INT-SETUP>
	  <ON "ERROR" ,ERROR-INTERRUPT-ROUTINE 50>	;"SETUP THE INTERRUPT HANDLER"
	  <IPC-OFF>					;"RESET IPC WITH PROPER NAMES"
	  <OFF "IPC">					;"GET RID OF DEFAULT HANDLER"
	  <SETG ERROR-INT-SETUP T>)>>


;"SETUP-INTERRUPT-HANDLERS ON's all the appropriate handlers, ONCE."

<DEFINE SETUP-INTERRUPT-HANDLERS ()
   <COND (<NOT ,INTS-SETUP>				;"IF NOT ALREADY ..."
	  <ON "SYSDOWN" ,SYSDOWN-INTERRUPT-ROUTINE 25>	;"SETUP THE OTHER HANDLERS"
	  <ON "IPC" ,IPC-INTERRUPT-ROUTINE 20>
	  <IPC-ON>
	  <ON "INFERIOR" ,INFERIOR-INTERRUPT-ROUTINE 5>
	  <ON "KILLER" ,KILLER-INTERRUPT-ROUTINE 5>
	  <ON "SCRIPTOR" ,SCRIPTOR-INTERRUPT-ROUTINE 5>
	  <ON "GC" ,GC-INTERRUPT-ROUTINE 16>
	  <SETG INTS-SETUP T>)
	 (T <IPC-OFF> <IPC-ON>)>>

<DEFINE FIX3-FMT (NUM "AUX" (LEFT <FIX1 .NUM>)
			    (RIGHT <FIX <+ <* <ABS <- .NUM .LEFT>> 1000> 1000.5>>))
   #DECL ((VALUE) STRING (LEFT RIGHT) FIX (NUM) FLOAT)
   <STRING !\  <UNPARSE .LEFT> !\. <REST <UNPARSE .RIGHT>>>>

;<DEFINE $-FMT (NUM "AUX" (LEFT <FIX1 .NUM>)
			 (RIGHT <FIX <+ <* <ABS <- .NUM .LEFT>> 100> 100.5>>))
   #DECL ((VALUE) STRING (LEFT RIGHT) FIX (NUM) FLOAT)
   <STRING !\$ <UNPARSE .LEFT> !\. <REST <UNPARSE .RIGHT>>>>

<DEFINE FIX1 (X "AUX" (FX <FIX .X>))
   #DECL ((VALUE FX) FIX (X) FLOAT)
   <COND (<G=? .X 0.0> .FX)
	 (<=? .X .FX> .FX)
	 (<FIX <+ .X 1.0>>)>>

<DEFINE MAKE-SURE-OPEN (CH)
   #DECL ((VALUE) ANY (CH) <OR CHANNEL FALSE>)
   <AND .CH <0? <1 .CH>> <RESET .CH>>>

<DEFINE NUMBER-OF-NON-FALSES (OBJECT)
   #DECL ((VALUE) FIX (OBJECT) VECTOR)
   <MAPF ,+
	 <FUNCTION (X) #DECL ((X) ANY) <COND (.X 1) (0)>>
	 .OBJECT>>

<DEFINE INDEX (THING OBJECT "OPTIONAL" (ELSE %<>)
	"AUX" (MEM <MEMBER .THING .OBJECT>))
   #DECL ((VALUE ELSE THING) ANY (OBJECT) VECTOR (MEM) <OR VECTOR FALSE>)
   <COND (.MEM
	  <- <LENGTH .OBJECT> <LENGTH .MEM> -1>)
	 (ELSE .ELSE)>>

<DEFINE NOTE (FILE "TUPLE" THINGS "AUX" (CH <OPEN "PRINT" .FILE>))
   #DECL ((VALUE) ANY (FILE) STRING (THINGS) TUPLE (CH) <OR CHANNEL FALSE>)
   <COND (.CH
	  <MAPF	%<>
		#FUNCTION ((YOU) #DECL ((YOU) ANY) <PRINC .YOU .CH>)
		.THINGS>
	  <CLOSE .CH>)>>

<DEFINE SYS-SECS ("AUX" (U '![0 0 0 0 0]))
   #DECL ((VALUE) FIX (U) <UVECTOR [REST FIX]>)
   <ITS-CALL "SSTATU" .U>
   </ <5 .U> 30>>

<DEFINE TTY? ("AUX" TTYSTATUS)
   #DECL ((VALUE) <OR FALSE FIX> (TTYSTATUS) FIX)
   <SET TTYSTATUS <CHTYPE <USET %<> *2*> FIX>>		;"SUSET .RTTY "
   <COND (<G=? .TTYSTATUS 0>
	  .TTYSTATUS)>>

<DEFINE FN-REORDER (FILESPEC)
   #DECL ((VALUE FILESPEC) <VECTOR STRING STRING STRING [REST STRING]>)
   <COND (<G=? <LENGTH .FILESPEC> 4>
	  [<3 .FILESPEC> <4 .FILESPEC> <1 .FILESPEC> <2 .FILESPEC>])
	 (ELSE
	  [<3 .FILESPEC> "COMMON" <1 .FILESPEC> <2 .FILESPEC>])>>

<DEFINE MAIL (TO MSG "AUX" C OUTCHAN)
   	  #DECL ((TO MSG) STRING
		 (C) <OR FALSE CHANNEL> (OUTCHAN) <SPECIAL CHANNEL>)
	  <COND (<SET C <OPEN "PRINT" ".MAIL.;MAIL >">>
		 <SET OUTCHAN .C>
		 <MAPF <>
		       ,PRINTSTRING
		       (
"FROM-JOB:"	<JNAME> "
SENT-BY:"	<UNAME> "
RCPT:("		  .TO   ")
RCPT:(.BATCH (R-OPTION CC))
TEXT;-1
"		  .MSG)>
		  <CLOSE .C>)>>

<ENDPACKAGE>
