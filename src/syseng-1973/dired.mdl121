TITLE DIRED MDL001  P. D. LEBLING (PDL)  28 FEB 72  RVSD 5 APR 72 

	RELOCATABLE

;-------------------------------------------------------
; ASSEMBLY SWITCHES
;-------------------------------------------------------

CARESW==0	; this switch controls whether the resulting
		; DIRED will work under CARE.  Zero implies a
		; MONIT version, one a CARE version.

;-------------------------------------------------------
; ACCUMULATORS, OUTPUT TO TTY, ETC.
;-------------------------------------------------------

; ACS AND UUOS NEED ONLY BE DEFINED IF WE ARE NOT IN "CARE" MODE
; IN THAT MODE THEY ARE ALREADY DEFINED

IFE CARESW,[

A=1
B=2
C=3
D=4
E=5
F=6
G=7
H=10
I=11
J=12
K=13
L=14
M=15
N=16
ARGP=16
P=17

; GETS A PDL OF A GIVEN SIZE

DEFINE	GETPDL SIZE
	MOVE	P,[-5,,50]
	PUSH	P,A
	MOVEI	A,SIZE
	PUSHJ	P,AFREE
	MOVE	P,A
	MOVNI	A,SIZE
	HRL	P,A
	POP	P,A
TERMIN

; TYPING MACROS

DEFINE	TYPE ARG
	OASC	[ASCIZ /!ARG!/]
TERMIN

DEFINE	TYPECR ARG
	OASCR	[ASCIZ /!ARG!/]
TERMIN

DEFINE	PRCR ARG
	OASCR	[ASCIZ //]
TERMIN

; IF IN NON "CARE" MODE CALLSR == PUSHJ P,

CALLSR=PUSHJ P,

;-----------------------------------------------
; TYPEOUT UUOS
;-----------------------------------------------

ZZZ==.
        LOC 40
        0
        JSR UUOH
        LOC ZZZ
UUOCT==0
UUOTAB:	JRST ILUUO
	IRPS X,,[PDEC PDECI POCT POCTI OSIX OSIXI OASC OASCI OASCR]
	UUOCT==UUOCT+1
	X=UUOCT_33
	JRST U!X
	TERMIN

UUOMAX==.-UUOTAB


UUOH:	0
	PUSH P,A
	PUSH P,B
	PUSH P,C
	LDB A,[270400,,40]	;GET UUO AC,
	HRRZ B,40	;AND ADR
	LDB C,[330600,,40]	;OP CODE
	CAIL C,UUOMAX
	MOVEI C,0	;GRT=>ILLEGAL
	JRST @UUOTAB(C)	;GO TO PROPER ROUT

UUORET:	POP P,C
	POP P,B
	POP P,A		;RESTORE AC'S
	JRST 2,@UUOH

ILUUO:	MOVEI B,[ASCIZ /ILLEGAL UUO/]
UOASCR:	SKIPA C,[15]	;CR FOR END OF TYPE
UOASC:	MOVEI C,0	;NO CR
	HRLI B,440700	;MAKE ASCII POINTER
	ILDB A,B	;GET CHAR
	JUMPE A,.+3	;FINISH?
	PUSHJ P,IOTA	;TYPE "A"
	JRST .-3	;AND GET ANOTHER
	SKIPE A,C	;GET SAVED CR?
	PUSHJ P,IOTA
	JRST UUORET

UOASCI:	MOVE A,B	;PRT ASCII IMMEDIATE
	PUSHJ P,IOTA
	JRST UUORET


UOSIX:	SKIPA A,[440600,,0(B)]	;PRINT A SIXBIT WORD
UOSIXI:	MOVE A,[220600,,40]	;PRT SIXBIT IMMEDIATE
UPSLA:	ILDB C,A
	ADDI C,40	;MAKE TO ASCII(+40)
	CAIE C,40	;BUT SKIP IF SPACE
	PUSHJ	P,IOTC
	TLNE	A,770000
	JRST	UPSLA
	JRST	UUORET

UPDEC:	SKIPA C,[10.]	;GET BASE FOR DECIMAL
UPOCT:	MOVEI C,8.	;OCTAL BASE
	MOVE B,(B)	;GET ACTUAL WORD TO PRT
	JRST .+3	;JOIN CODE
UPDECI:	SKIPA C,[10.]	;DECIMAL
UPOCTI:	MOVEI C,8.
	MOVEM C,BASE'
	SKIPN A
	HRREI A,-1	;A=DIGIT COUNT
	PUSHJ P,UPNUM	;PRINT NUMBR
	JRST UUORET

UPNUM:	IDIV B,BASE
	HRLM C,(P)	;SAVE DIGIT
	SOJE A,UPNUM1	;DONE IF 0
	SKIPG A		;+ => MORE
	SKIPE B		;- => B=0 => DONE
	PUSHJ P,UPNUM	;ELSE MORE
UPNUM1:	HLRZ C,(P)	;RETREIVE DIGITS
	ADDI C,"0	;MAKE TO ASCII
	CAILE C,"9	;IS IT GOOD DIG
	ADDI C,"A-"9-1	;MAKE HEX DIGIT
	PUSHJ P,IOTC
	POPJ P,	;RET

IOTA:   .IOT	TYOC,A
        CAIE A,^M       ;TYPE CR?
        POPJ P,
        .IOT TYOC,[^J]  ;PUT OUT LF FOR CR
        POPJ P,


IOTC:	EXCH	A,C
	PUSHJ	P,IOTA
	EXCH	A,C
	POPJ	P,

]

;----------------------------------------------------
; USEFUL MACROS
;----------------------------------------------------

; MACROS TO ZERO OPEN BLOCKS AND DELETE BLOCKS.
	
DEFINE	ZFBLK	A
	SETZM	A
	SETZM	A+1
	SETZM	A+2
TERMIN

DEFINE	ZFDBLK	A
	ZFBLK	A
	SETZM	A+3

	SETZM	A+4
TERMIN

;--------------------------------------------------
; MACROS TO MOVE A NAME BLOCK OR AN OPEN BLOCK.
;--------------------------------------------------

DEFINE	FNMOVE	A,B
	MOVE	0,[A+1,,B+1]
	BLT	0,B+2
TERMIN

DEFINE	FBLKMV	A,B
	MOVE	0,[A,,B]
	BLT	0,B+2
TERMIN

;------------------------------------------------
; MACRO TO ZERO CORE FOR N LOCATIONS.
;-------------------------------------------------

DEFINE	ZBLK	N,LOC
	PUSH	P,A
	MOVE	A,[LOC,,LOC+1]
	SETZM	LOC
	BLT	A,N-1+LOC
	POP	P,A
TERMIN


;-----------------------------------------------
; TYPES OUT THE NAME PART OF AN OPEN BLOCK
;-----------------------------------------------

DEFINE FNTYPE BLOCK
	OSIX	BLOCK+1
	OASC	[ASCIZ /	/]
	OSIX	BLOCK+2
	OASCR	[ASCIZ //]
TERMIN

DEFINE	STAK	NUM,LOC
	MOVEM	A,0
	MOVNI	A,NUM
	HRLS	A
	HRRI	A,LOC
	PUSH	P,(A)
	AOBJN	A,.-1
	MOVE	A,0
TERMIN

;-----------------------------------------
; STACKING AND UNSTACKING LARGE BLOCKS
;--------------------------------------------

DEFINE	UNSTAK	NUM,LOC
	MOVEM	A,0
	MOVNI	A,NUM
	HRLS	A
	HRRI	A,LOC
	ADDI	A,NUM+1
	SUBI	A,2
	POP	P,(A)
	AOBJN	A,.-2
	MOVE	A,0
TERMIN
;-------------------------------------------------------
; EXTERNALS
;-------------------------------------------------------

; HERE ARE DEFINITIONS FOR WHEN WE ARE IN "CARE" MODE

IFN CARESW,[
ALLMAC==0
.SWACS==1
.SWEXT==1
.SWHDR==1
.SWSTK==1
.INSRT DSK:CAREDL;MACRO TS

EXTERN	[RDFLNM SCNAME RCMD SCMD RDSDIR]
EXTERN	[TYO TYI OPEN IOT CLOSE LINAOU LINACR AFRET AFREE]
EXTERN	[ARCA,ARCI,ARCE,ARCD,ARCL]
STACK	[PRTF,PRTF1,PRTF2,USRSAV,SCDEV,SCN1,SCN2,SCUSR,COMPTR,COMMND] M
.GLOBA OASC OASCR OSIX
]

IFE CARESW,[
.GLOBAL LINAOU LINACR TYO TYI USRSAV
.GLOBAL RDFLNM SCNAME RCMD SCMD IOT
.GLOBAL OPEN CLOSE PRTF RDSDIR AFRET
.GLOBAL AFREE COMMND COMPTR
]

;------------------------------------------------------
; CHANNEL DEFS
;------------------------------------------------------

TYIC==2
TYOC==1
TYOC1==1
IC==3
OC==4
CC==5
PRINTC/DIRINT MDL001  P. D. LEBLING (PDL) 7 JUN 72
/
;------------------------------------------------------
; DIRED INTERRUPT CRUFT
;----------------------------------------------------

TTYINT==1
IOCINT==400

; TEST IF INTERRUPT WAS DONE LATELY

DEFINE	INTEST LOC
	PUSHJ	P,.INTES
	JRST	LOC
TERMIN

.INTES:	SKIPL	INTFLG
	JRST	.+4
	SETZM	INTFLG
	OASCR	[ASCIZ //]
	POPJ	P,
	AOS	(P)
	POPJ	P,

; CLEAR INTERRUPTS

DEFINE	CLRINT
	PUSHJ	P,.CLRIN
TERMIN

.CLRIN:	PUSH	P,A
	PUSH	P,B
	SETZM	42
	SETZB	A,B
	.SETM2	A,
	.SUSET	[.SPICLR,,[0]]
	POP	P,B
	POP	P,A
	POPJ	P,

DEFINE	ENAINT	ITYPE,LOCN
	PUSH	P,A
	PUSH	P,B
	MOVEI	A,ITYPE
	MOVE	B,[JSR LOCN]
	PUSHJ	P,.ENAIN
	POP	P,B
	POP	P,A
TERMIN

.ENAIN:	PUSH	P,A
	PUSH	P,B
	MOVEM	B,42
	SETZM	B
	.SETM2	A,
	.SUSET	[.SPICLR,,[-1]]
	POP	P,B
	POP	P,A
	POPJ	P,


;----------------------------------------------------
; TTY INTERRUPT ROUTINE
;----------------------------------------------------

.GLOBA	INCHN OUTCHN

INTFLG:	0

TTYCHK:	0
	0
	PUSH	P,A
	PUSH	P,B
	MOVE	A,INCHN
	.ITYIC	A,
	JRST	TTYDIS
	CAIE	A,7
	JRST	TTYDIS
	MOVE	B,INCHN
	LSH	B,27
	IOR	B,[.RESET]
	XCT	B
	MOVE	B,OUTCHN
	LSH	B,27
	IOR	B,[.RESET]
	XCT	B
	SETOM	INTFLG
TTYDIS:	POP	P,B
	POP	P,A
	.DISMIS	TTYCHK+1
;------------------------------------------------
; STARTS, PRINTS MESSAGE, INITIALIZES STACK
;------------------------------------------------

IFN CARESW,[
MAKPRO	ACS,[A,B,C,D,E,F,G,H,I,J,K,L,M]
ENTRY	[DIRED]
ISR	DIRED
START:	STOACS	ACS
]
IFE CARESW,[
START:	GETPDL	100
	.OPEN	TYIC,[SIXBIT /   TTYDIRED TTYIN/]
	.VALUE
	.OPEN	TYOC,[SIXBIT /  !TTYDIRED TTYOUT/]
	.VALUE
]
	OASC	[ASCIZ /DIRED /]		; type name of prog
	OSIX	[.FNAM2]
	OASCR	[ASCIZ //]
	OASCR	[ASCIZ //]
IFN CARESW,[
	MOVEI	A,30.
	CALLSR	AFREE
	MOVEM	A,RDFLIM
]
	.SUSET	[.RUNAM,,RSYSNM]	; initialize 'real' system name
	MOVE	A,RSYSNM		;   to UNAME.
	MOVEM	A,OPNFIL+3		;   also init. .F's sname
	MOVEM	A,LSYSNM		;   and listing sname
	MOVE	A,[SIXBIT /   DSK/]	; initialize defaults for OPNFIL
	MOVEM	A,OPNFIL		;   to DSK:
	.SUSET	[.SSNAM,,MESSNM]	; prepare to print DIRED RECENT
	MOVEI	A,MESFIL		; open to DSK:.INFO.;DIRED RECENT
	PUSHJ	P,PRNTFL
	JRST	INSTAK			; if no such file, who cares?

INSTAK:	STAK	4,FONE			; initialize stack
	STAK	4,FTWO
	JRST	GETCOM			; go get a command
;-------------------------------------------------
; PRINT -- PRINT CONTENTS OF A FILE BY SCREENFULS
;-------------------------------------------------
; A/ ptr to open block
;-------------------------------------------------

PRNTFL:	ENAINT	TTYINT,TTYCHK
	PUSH	P,A			; save acs
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	MOVEM	A,OPNLOC
	CALLSR	OPEN			; open to file pointed to in A
	JRST	PRNTX			; if can't then simply go exit
	MOVEM	A,D			; save message channel
	MOVNI	C,SCRSIZ			; initialize "screen size"
MESSAG:	INTEST	EOFM
	MOVE	A,D			; print out message
	CALLSR	IOT
	MOVE	A,B
	JUMPL	B,EOFM			; if < 0, then EOF reached
	CAIN	B,3			; ==> EOF
	JRST	EOFM
	CAIN	B,14
	JRST	MESSAG			; if FF, don't print him
	CAIE	B,15			; if a PRCR, then see if we have a screenful
	JRST	DOTYO
	SKIPN	TTYFLG
	AOJE	C,PSCR
DOTYO:	CALLSR	TYO			; output char to user
	JRST	MESSAG
EOFM:	MOVE	A,D
	CALLSR	CLOSE			; close input channel
	OASCR	[ASCIZ //]
	AOS	-4(P)			; skip return, since we won
PRNTX:	POP	P,D			; restore acs
	POP	P,C
	POP	P,B
	POP	P,A
	POPJ	P,
;----------------------------------------------
; WAITS FOR SIGNAL TO CONTINUE A END OF SCREEN
;----------------------------------------------

PSCR:	CLRINT
	PUSH	P,A
	MOVNI	C,SCRSIZ			; reset counter to a screenful
	OASC	[ASCIZ /
--MORE--/]
	CALLSR	TYI			; get a char and echo it
	CAIN	A,7			; if its ^g, then exit
	JRST	PRNTX1
	OASCR	[ASCIZ //]			; else type a PRCR and go type more
	POP	P,A
	ENAINT	TTYINT,TTYCHK
	JRST	MESSAG

PRNTX1:	OASCR	[ASCIZ /FLUSHED/]
	POP	P,A
	OASCR	[ASCIZ //]
	JRST	EOFM			; EOFM implies end of message
;----------------------------------------------------
; GETCOM -- GOBBLES A COMMAND FROM TTY AND PARSES IT
;----------------------------------------------------

GETCOM:	.SUSET	[.SSNAM,,RSYSNM]	; make sure we have right sys name.
IFN CARESW,	MOVE	M,RDFLIM
	SKIPE	DPTSAV			; if no saved ptr, then can't have a dir
	SETZM	ODIR			;   therefore set flag to 0 if we have one
	SETZM	PFFLAG
	SETOM	MASK+1			; set masks for first arg to "no masking"
	SETOM	MASK+2
	AOSN	ITRATE			; if =0, then we are at end of iteration loop
	JRST	GRESET			;   which means go off for a new command
	UNSTAK	4,FTWO
	UNSTAK	4,FONE			; peel off file spec stack
	STAK	4,FONE			; sink it again,
	STAK	4,FTWO
	JRST	@CLCSAV			; and go off to saved command.

GRESET:	UNSTAK	4,FTWO
	UNSTAK	4,FONE			; peel file specs off stack
	CLRINT
	MOVEI	A,1			; reset iteration counter to minus one
	MOVNM	A,ITRATE		;   => only do command once next time.
	OASC	[ASCIZ /*/]			; type prompt character.
	SKIPL	XFILF			; if we are xfiling, then get from there
	JRST	RDEX
	PUSHJ	P,GETLIN		; GETLIN reads one line from XFILE
	JRST	RDSKIP			;   then skips normal read in
RDEX:
IFN CARESW,	MOVE	A,RDFLIM
	SETZM	B
IFE CARESW,
	CALLSR	RCMD			; gobble command line.
RDSKIP:	MOVEI	ARGP,1
	MOVNM	ARGP,ITRATE		; assume only one iteration for now.
IFN CARESW,	MOVE	A,RDFLIM
	CALLSR	SCMD			; parse for command word.
	MOVE	ARGP,B
	MOVEM	B,NUMSAV		; save command word in case it actually isn't number
	PUSHJ	P,XNUM			; try to extract a number from command word
	JRST	DOONCE			;   if can't, then only one iteration
	SKIPL	ARGP			; iteration can't be negative!
	MOVNM	ARGP,ITRATE		;   if was a number then save it as iteration.
IFN CARESW,	MOVE	A,RDFLIM
	CALLSR	SCMD			; get next command word (real one this time) 
	JRST	.+2			;   and skip to avoid losing iteration count.
DOONCE:	MOVE	B,NUMSAV		; if was not number, then assume it was command.
	MOVEM	B,CMDSAV		; and save it
	PUSHJ	P,SRCDST		; gobbles two file names if can.
	STAK	4,FONE			; sink new file names onto stack
	STAK	4,FTWO
	MOVEI	A,COMLST		; A/ pointer to command list 
	MOVE	B,CMDSAV		; get the command
NXTCOM:	CAME	B,@A			; is our command this one?
	JRST	.+4			;   if not, skip next 3 inst.
	MOVE	B,1(A)			;   if so, get loc to jump to
	MOVEM	B,CLCSAV		; remember where you jumped to.
	JRST	@1(A)			; and jump!
	ADDI	A,2			; here for no match, and inc. to next try.
	CAIE	A,COMLND		; at end of command list?
	JRST	NXTCOM			;   if not, try for another command.

NXIT:	OASCR	[ASCIZ /HUH?/]			; if couldn't find command, then say so
	JRST	GETCOM			;   and return for another command
;------------------------------------------------
; GETLIN -- READS ONE LINE FROM CURRENT XFILE
;   INTO RDFLNM'S INPUT BUFFER
;------------------------------------------------

GETLIN:	MOVEI	C,COMMND
	HRLI	C,440700	; set command pointer
	MOVEM	C,COMPTR		; to start of input buffer
GETCHR:	MOVE	A,XCS			; set up call to IOT
	CALLSR	IOT			; gobble down one char
	JUMPL	B,GETLX			; if its an EOF, then exit
	CAIN	B,15			; if its an PRCR, then done
	JRST	GETLND			; here for end of line
	IDPB	B,C			; put char in input buffer
	JRST	GETCHR			; get another char

GETLND:	MOVE	A,XCS			; get one more char --
	CALLSR	IOT			; its a LF
	MOVEI	B,12
	IDPB	B,C
	SETZM	B			; set up a nul char
	IDPB	B,C			; put it in buffer
	IDPB	B,C
	IDPB	B,C
	MOVEI	A,COMMND		; set up pointer to buffer
	CALLSR	LINACR			; and type out command line
	POPJ	P,			; return to GETCOM

GETLX:	SKIPE	A,XCS			; recover xfile channel
	CALLSR	CLOSE			; close xfiling channel
	SETZM	XCS			; set channel to zero
	SETZM	XFILF			; 0 => no current xfile
	JRST	GETCOM			; get another command

;-----------------------------------------------
; SRCDST -- GETS TWO FILE SPECS FROM TTY
;-----------------------------------------------

SRCDST:	PUSH	P,A			; save A
	PUSH	P,B			; save B
IFN CARESW,	MOVE	M,RDFLIM
	ZBLK	4,FONE			; zero buffer for first arg
	ZBLK	4,FTWO			; zero buffer for second arg
SRC0:	ZBLK	4,PRTF
IFN CARESW,	MOVE	A,RDFLIM
	CALLSR	SCNAME			; gobble down a file name
	SKIPE	PRTF			; if first word (DEV:)
	JRST	SRC1   
	SKIPE	USRSAV			;   and (USR;)
	JRST	SRC1
	SKIPE	PRTF+1			;   and second   (NAM1)
	JRST	SRC1
	SETOM	FONE			; are all zero, then mark block
	JRST	DST0			;   and go to next arg

SRC1:	MOVE	0,[OPNFIL,,FONE]	; here we update arg1 onto current file 
	BLT	0,FONE+3		; blt in current file-spec
	HRLI	A,PRTF
	HRRI	A,FONE
	MOVNI	B,3
	PUSHJ	P,SPECUD		; update arg1 onto current file
DST0:	MOVE	0,[FONE,,FTWO]
	BLT	0,FTWO+3		; copy arg1 into arg2 for possible default
	SETZM	PRTF			; zero input buffer
	SETZM	PRTF+1
	SETZM	PRTF+2
	SETZM	USRSAV
IFN CARESW,	MOVE	A,RDFLIM
	CALLSR	SCNAME			; get another file spec
	SKIPE	PRTF			; and check to see if zero as above
	JRST	DST1
	SKIPE	USRSAV
	JRST	DST1
	SKIPE	PRTF+1
	JRST	DST1
	SETOM	FTWO			; if no arg2, then mark it
	JRST	SDXIT			; and go to exit

DST1:	MOVE	0,[OUTDEV,,FTWO]	; update arg2 onto outdev
	BLT	0,FTWO+3		; blt in outdev's DEV:USR;
	MOVE	0,[FONE+1,,FTWO+1]
	BLT	0,FTWO+2		; copy in file part of arg1
	HRLI	A,PRTF
	HRRI	A,FTWO
	MOVNI	B,3
	PUSHJ	P,SPECUD		; update arg2 onto result
SDXIT:	POP	P,B
	POP	P,A			; restore A and B
	POPJ	P,			; and return
;--------------------------------------------------------
; A
;--------------------------------------------------------
; NEWDEV -- GET A NEW DIRECTORY, PARSE IT, ETC.
;--------------------------------------------------------
 
NEWDEV:	SKIPGE	FONE			; if FONE = -1, no new source dir
	JRST	NEWBKP
	PUSHJ	P,FREDIR		; flush old vector of names
	MOVE	A,[FONE,,INDEV]		; set up call to SPECUD
	MOVNI	B,2
	PUSHJ	P,SPECUD		; use what RDFLNM got to update DEV:USR;
	HRLI	0,2
	HLLM	0,INDEV			; give a good mode to RDSDIR
	.SUSET	[.SSNAM,,RSYSNM]	; set system name appropriately
	MOVEI	A,INDEV			; get pointer to open block for RDSDIR
	CALLSR	RDSDIR		; read and parse to asciz the dir
IFN CARESW,[
	JUMPE	A,BADDEV
	MOVE	A,(A)
]
IFE CARESW,	JUMPGE	A,BADDEV		; if not negative, then lost
	SETZM	ODIR			; we now have a dir
	MOVEM	A,DPTSAV		; save AOBJN pointer to it
	HRRZM	A,DIRPTR		; gobble pointer half
	HLROM	A,B			; set up arg to TRFVCT
	PUSHJ	P,TRFVCT		; make vector names SIXBIT
	MOVE	A,DIRPTR
	MOVEM	A,DIRTOP		; save pointer to top of dir. 
	SUB	A,B			; DIREND = DIRTOP - (-COUNT)
	SOS	A
	MOVEM	A,DIREND		; save pointer to end of dir.
	SKIPE	UPFLG			; if going up we will want to start at end 
	MOVEM	A,DIRPTR		; so save pointer to bottom as current pointer
NEWBKP:	SKIPGE	FTWO
	JRST	NEWDEF			; default is DSK:<UNAME>
	MOVE	A,[FTWO,,OUTDEV]
	MOVNI	B,2
	PUSHJ	P,SPECUD		; update the DEV:USR; of OUTDEV.
NOUTDV:	.SUSET	[.SSNAM,,RSYSNM]	; reset to real sys name
	JRST	GETAFL			; get file pointed to by DIRPTR.

NEWDEF:	SKIPL	FONE
	JRST	NOUTDV
	MOVE	A,[SIXBIT /   DSK/]	; sets up defaults for lazy user
	MOVEM	A,FONE
	MOVE	A,RSYSNM
	MOVEM	A,FONE+3
	JRST	NEWDEV
;-----------------------------------------------------
; GOJUMP ENDS UP HERE IF ARG WAS EITHER 'T' OR 'B'
;-----------------------------------------------------

GOTOP:	MOVE	A,DIRTOP		; get pointer to top file
GOTOP1:	SKIPE	(A)			; is it =0 (ie: file deleted) 
	JRST	ATTOP			;   if not 0, then we're winners.
	AOS	A			;   otherwise, we got to find one
	CAMN	A,DIREND		;   non-zero.
	JRST	EMPTY			; if at bottom and no non-zero, we lose
	JRST	GOTOP1			; if not at bottom yet, try again
ATTOP:	MOVEM	A,DIRTOP		; save possibly updated top pointer.
	MOVEM	A,DIRPTR		;   make it current pointer
	SETOM	B			;   and set flag appropriately for top.
	JRST	GETAFL			; go get what we're now pointing at. 

GOEND:	MOVE	A,DIREND		; works exactly like GOTOP except heads
GOEND1:	SKIPE	(A)			; for end instead of beginning
	JRST	ATEND
	SOS	A
	CAMN	A,DIRTOP
	JRST	EMPTY
	JRST	GOEND1
ATEND:	MOVEM	A,DIREND
	MOVEM	A,DIRPTR
	MOVEI	B,1
	JRST	GETAFL

;-------------------------------------------------
; THIS TYPES OUT ERROR MESSAGE IF YOU TRY TO DO ANYTHING 
; THAT REQUIRES A DIR. BUT YOU DON'T HAVE ONE.
;-------------------------------------------------

EMPTY:	OASCR	[ASCIZ //]
	OASCR	[ASCIZ /*EMPTY DIRECTORY*/]	; type error message
	OASCR	[ASCIZ //]
	SETOM	ODIR			; set no dir. flag
	JRST	GETCOM			; go get another command 
;-----------------------------------------------
; J,U,<PRCR> [number] or [name] or [T] or [B]
;-----------------------------------------------
; GOJUMP -- PARSES ANY JUMP-TYPE COMMAND
;-----------------------------------------------
GOJUMP:	SKIPE	ODIR			; if no dir, return
	JRST	EMPTY
	SKIPGE	FONE			; is there an arg? 
	JRST	GOONE			;   if not, assume arg of '1'
	MOVE	ARGP,FONE+1		;   if so, set up call to XNUM
TOPEND:	CAMN	ARGP,[SIXBIT /T/]	; if arg is 'T', then jump there
	JRST	GOTOP
	CAMN	ARGP,[SIXBIT /B/]	; if arg is 'B', then jump there
	JRST	GOEND
	PUSHJ	P,XNUM			; XNUM extracts octal number from SIXBIT
	JRST	JFNAME			;   failure: not a number, so assume fname 
	JRST	.+2			; if get to here, we have a number, so skip
GOONE:	MOVEI	ARGP,1			; here for number = 1
	MOVE	A,CMDSAV		; was it UP or JUMP?
	CAME	A,[SIXBIT /U/]		; if was UP, then complement argument
	CAMN	A,[SIXBIT /UP/]
	MOVNS	ARGP
	SKIPG	ARGP			; if arg now positive, means go down
	JRST	GETLST			; if arg now negative, go up
	MOVNS	ARGP			; must complement again, so will be negative
	JRST	GETNXT

;-------------------------------------------------
; JFNAME --JUMPS TO FILE NAMED AS ARG
;-------------------------------------------------
; GOJUMP ends up here if arg was not a number.
;-------------------------------------------------

JFNAME:	PUSHJ	P,PARSNM		; parse the name passed in PRTF
	JRST	EMPTY			;   failure return, no dir
	PUSHJ	P,SEARCH			; go find a match
	JRST	JFAIL			;   lose, so go say so
	MOVEM	C,DIRPTR		;   got a match, so set pointer to it
	JRST	GETAFL

JFAIL:	OASCR	[ASCIZ//]
	OASCR	[ASCIZ /NO SUCH FILE!/]
	OASCR	[ASCIZ //]
	JRST	GETCOM			; types error message and returns to command
;--------------------------------------------------
; GETLST, GETNXT -- SETS POINTER TO 'N' FILES FROM
;   CURRENT ONE, IN EITHER UP OR DOWN DIRECTION.
;--------------------------------------------------
; GOJUMP ends up here if arg was a number.  The two
;   routines do exactly the same things but for opp-
;   osite directions.
;--------------------------------------------------
; call: ARGP/ -<count of files to move over>
;-------------------------------------------------- 

GETLST:	MOVE	A,DIRPTR		; gobble pointer.
	CAMN	A,DIRTOP
	JRST	GETTOP			;   of dir and can't go higher.
GETL1:	SOS	A			; go to last file
	CAMG	A,DIRTOP		;   if its the top, then done.
	JRST	GETTOP
	SKIPE	(A)			; if not top, skip if a zeroed file
	AOSE	ARGP			; update count
	JRST	GETL1			; loop until count is zero
	MOVEM	A,DIRPTR		; set DIRPTR to file we have reached
	JRST	GETAFL			; exit
GETTOP:	PUSHJ	P,EMPDIR		; is dir empty? EMPDIR does not skip if it is. 
	JRST	EMPTY			;   if empty, go say so.
	SKIPE	(A)			;   if not empty, is file zeroed? 
	JRST	.+3
	MOVE	A,DIREND		;   if file is zeroed, try again from the end.
	JRST	GETL1
	MOVEM	A,DIRPTR		; set DIRPTR to file we are at.
	JRST	GETAFL			; exit

GETNXT:	MOVE	A,DIRPTR
	SKIPE	ODIR
	JRST	EMPTY
	CAMN	A,DIREND
	JRST	GETEND
GETN1:	AOS	A
	CAML	A,DIREND
	JRST	GETEND
	SKIPE	(A)
	AOSE	ARGP
	JRST	GETN1
	MOVEM	A,DIRPTR
	JRST	GETAFL
GETEND:	PUSHJ	P,EMPDIR
	JRST	EMPTY
	SKIPE	(A)
	JRST	.+3
	MOVE	A,DIRTOP
	JRST	GETN1
	MOVEM	A,DIRPTR
	JRST	GETAFL
;-----------------------------------------------------
; EMPDIR -- IS THE VECTOR EMPTY
;-----------------------------------------------------

EMPDIR:	PUSH	P,A			; save A
	MOVE	A,DPTSAV		; gobble AOBJN pointer
	SKIPE	(A)			; if any entry non-zero, we win
	JRST	EMPWIN
	AOBJN	A,.-2			; if entry zero, try next one
	POP	P,A			; restore A
	POPJ	P,
EMPWIN:	MOVE	A,DIRTOP		; get ready to update DIRTOP and DIREND
	SKIPN	(A)			; found a non zero entry?
	AOJA	A,.-1
	MOVEM	A,DIRTOP		; when a non zero is found, use as new top
	MOVE	A,DIREND		; repeat process with DIREND
	SKIPN	(A)
	SOJA	A,.-1
	MOVEM	A,DIREND
	MOVE	A,DIRPTR		; now, is pointer between these two?
	CAML	A,DIRTOP
	CAMLE	A,DIREND
	JRST	EMPNT			; if not, then go to EMPNT
	JRST	EMPSKP			;   otherwise, go to EMPSKP
EMPNT:	SKIPN	UPFLG
	JRST	.+3
	MOVE	A,DIREND
	JRST	.+2
	MOVE	A,DIRTOP		; make DIRTOP new DIRPTR 
	MOVEM	A,DIRPTR
EMPSKP:	POP	P,A			; restore A
	AOS	(P)			; won, so make it skip
	POPJ	P,
;----------------------------------------------------
; GETAFL -- MAKES THE CURRENT FILE ACCESSABLE
;----------------------------------------------------

GETAFL:	MOVE	A,ICS			; get current input channel
	SKIPE	A			; if zero (=> no channel), skip
	CALLSR	CLOSE			; close current input channel
	SETZM	ICS
	MOVE	A,OCS			;   do the same for output channel
	SKIPE	A
	CALLSR	CLOSE
	SETZM	OCS
	.SUSET	[.SSNAM,,RSYSNM]	; get back right sys name.
	AOSE	ITRATE			; if this is last iteration
	JRST	ITRST			;   then don't skip but instead
	OASCR	[ASCIZ //]			;   type a PRCR to indicate that this
ITRST:	SOS	ITRATE			;   CURRFL was not oper'd, then restore count
	MOVE	A,DIRPTR		; get and check DIRPTR
	CAMN	A,DIRTOP
	OASCR	[ASCIZ /=TOP=/]		;   if top file, say so
	MOVE	N,DIRPTR		; for print out of name
	MOVE	N,(N)
	OSIX	(N)			; type out its nam1
	OASC	[ASCIZ /	/]			;   type out a tab
	OSIX	1(N)			;   type out nam2
	OASCR	[ASCIZ //]			; type a cr-lf
	MOVE	A,DIRPTR		; get and check DIRPTR
	CAMN	A,DIREND
	OASCR	[ASCIZ /=END=/]		;   if file is end one, say so
	HRL	0,@DIRPTR		; set up a BLT pointer
	HRRI	0,OPNFIL+1		;  [<stored fnams>,,<open block>]
	BLT	0,OPNFIL+2		; do the BLT
	HRR	A,INDEV			; get the device spec.
	HRRM	A,OPNFIL		; and put it in the open block
	MOVE	A,RSYSNM
	MOVEM	A,OPNFIL+3		; get the system name
	MOVE	B,TYPOUT
	JUMPE	B,GETCOM
	MOVEI	A,OPNFIL
	MOVEM	A,OPNLOC
	CALLSR	OPEN
	JRST	NOPEN1
	MOVEM	A,ICS
	MOVE	ARGP,LINTYP		; otherwise, get a number of lines to type
	SETZM	A			; A=0 => don't just move typeout ptr, type!
	PUSHJ	P,TYPNL			; go type 'n' lines
	JFCL				; returns without skipping if EOF found
	JRST	GETCOM			; return and get a command
;----------------------------------------------------
; FREDIR -- RETURNS SPACE USED BY DIR TO FREE AREA
;----------------------------------------------------

FREDIR:	MOVE	A,DPTSAV		; get pointer to dir
	JUMPE	A,FREX			; go to return if no dir
	PUSH	P,A			; save cptr since it gets munged
	MOVE	C,A
FREDR1:	MOVEI	A,3			; each dir entry is three words
	SKIPN	(C)			; if zero, then entry is for open file
	JRST	FREDR2		;   and we don't want to try and fret it
	HRRZ	B,(C)			; pointer is in right half of C
	CALLSR	AFRET			; return it
FREDR2:	AOBJN	C,FREDR1		; continue until we run out of dir
	POP	P,A			; restore cptr
	HRRZ	B,A			; put dptr to table in B
	HLRES	A			; get count (negative) in right half of A
	MOVMS	A			; make it the magnitude
	CALLSR	AFRET			; finally call AFRET to return entire table
FREX:	SETZM	DPTSAV			; we now have no dir
	SETOM	ODIR
	SETZM	DIRPTR
	POPJ	P,			; return
;-----------------------------------------------------
; ASCSIX -- TRANSLATES ASCIZ FNAM TO SIXBIT OPEN BLOCK
;-----------------------------------------------------

ASCSIX:
IFE CARESW,	PUSH	P,A			; saves ac A thru F
	PUSH	P,B
	PUSH	P,C
	PUSH	P,D
	PUSH	P,E
	PUSH	P,F
IFN CARESW,	MOVE	B,1(A)
IFE CARESW,[
	MOVE	B,A			; X is ptr to ascii string
	HRLI	B,440700
]
	MOVE	C,[440600,,D]		; set up bptr
	CAMN	C,[600,,D]		; dont skip if we are at 7th char
	IBP	B			;   and inc over the space
	ILDB	F,B			; get a char 
	SUBI	F,40			;   and convert it to sixbit
	CAIL	F,100
	JRST	.-2
	IDPB	F,C			; deposit it back
	CAME	C,[600,,E]		; skip if finished
	JRST	.-10			; else jump back to compare
IFN CARESW,[
	SETZM	1(A)
	MOVEI	A,3
	CALLSR	AFREZ
]
	MOVEM	D,(A)			; put first word back into loc
IFE CARESW,[	AOS	A
	MOVEM	E,(A)			; put second word back
]
IFN CARESW,	MOVEM	E,1(A)
	POP	P,F			; restore A thru F
	POP	P,E
	POP	P,D
	POP	P,C
	POP	P,B
IFE CARESW,	POP	P,A
	POPJ	P,


;------------------------------------------------------
; TRFVCT -- TRANSLATES A VECTOR OF NAMES IN ASCIZ TO 
;   ONE OF SIXBIT OPEN BLOCKS
;-----------------------------------------------------
; call: A/ AOBJN pointer to vectors
;-----------------------------------------------------

TRFVCT:	PUSH	P,A
	PUSH	P,B			; save A and B
	MOVE	B,A			; put cptr in b
TRVCTL:	MOVE	A,(B)			; get ptr to ascii string
	PUSHJ	P,ASCSIX		; convert to sixbit
IFN CARESW,	MOVEM	A,(B)
	AOBJN	B,TRVCTL		; loop if not at end of vector
	POP	P,B			; restore A and B
	POP	P,A
	POPJ	P,
;-----------------------------------------------------
; COMTAB -- SET-UP FOR COMMAND LIST
;-----------------------------------------------------

DEFINE	COMTAB	A,B
	SIXBIT /A/
	B
TERMIN

;-----------------------------------------------------
; COMLST -- LIST OF COMMANDS AND WHERE THEY GO TO
;-----------------------------------------------------

COMLST:	COMTAB	",TYPEL
	COMTAB	,GOCR
	COMTAB	?,COMMDS
	COMTAB	A,NEWDEV
IFN CARESW,[
	COMTAB	AA,ACTARC
	COMTAB	AR,INSARC
]
	COMTAB	AUTO,AUTO
	COMTAB	B,FILCPY
	COMTAB	BACKUP,FILCPY
IFN CARESW,[
	COMTAB	CLA,CLSARC
	COMTAB	CLOSE,CLSARC
]
	COMTAB	COPY,FILCPY
	COMTAB	D,DELETE
IFN CARESW,	COMTAB	DA,DELARC
	COMTAB	DEL,DELETE
	COMTAB	DELETE,DELETE
	COMTAB	ER,ERASE
	COMTAB	ERASE,ERASE
IFN CARESW,	COMTAB	EX,EXARC
	COMTAB	F,PFNMS
	COMTAB	FL,FLAPUT
	COMTAB	FLAP,FLAPUT
	COMTAB	J,GOJUMP
	COMTAB	JUMP,GOJUMP
IFE CARESW,		COMTAB	K,CTLK
	COMTAB	L,LISTME
IFN CARESW,	COMTAB	LA,LISARC
	COMTAB	LF,LISTME
	COMTAB	LINK,LINK
	COMTAB	LISTF,LISTME
	COMTAB	LK,LINK
	COMTAB	P,PRINT
	COMTAB	PR,PRINT
	COMTAB	PRINT,PRINT
	COMTAB	Q,CTLQ
	COMTAB	QUIT,CTLQ
	COMTAB	R,RENAME
	COMTAB	RENAME,RENAME
	COMTAB	S,FILCPY
	COMTAB	SAFE!,SAFEX
	COMTAB	SAFE,SAFE
	COMTAB	SAVE,FILCPY
	COMTAB	SORRY,SORRY
	COMTAB	ST,STATUS
	COMTAB	STATUS,STATUS
	COMTAB	TTYMOD,TTYMOD
	COMTAB	T,TYPST
	COMTAB	TR,TRAVEL
	COMTAB	TRAVEL,TRAVEL
	COMTAB	TYPE,TYPST
	COMTAB	U,GOJUMP
	COMTAB	UP,GOJUMP
	COMTAB	V,VECTOR
	COMTAB	VECTOR,VECTOR
	COMTAB	X,XFILE
	COMTAB	XF,XFILE
	COMTAB	Y,TYPE1
	COMTAB	YANK,TYPE1
COMLND==.

;--------------------------------------------------
; GOCR -- HERE IF PRCR WAS COMMAND
;--------------------------------------------------

GOCR:	MOVNI	ARGP,1			; set up argp for move of one
	SKIPN	UPFLG			; go to place associated with current
	JRST	GETNXT			;   direction of travel:  here for down
	JRST	GETLST			;   here for up

;--------------------------------------------------
; SPECUD -- SELECTIVE FILE SPEC UPDATE
;--------------------------------------------------
; call: A/ <source block>,,<destination block>
;       B/ -<count of locs updated>
;--------------------------------------------------

SPECUD:	PUSH	P,C
	PUSH	P,D
	HLRZM	A,D			; put ptr to source block in D
	HRRZS	A			; ptr to destination in A
	MOVE	C,3(D)			; sysnam of input block
	SKIPE	C			; if zero, assume no input and dont update
	MOVEM	C,3(A)			; move new sysnam to block
	AOSN	B			; if only one update, return
	JRST	SPXIT
	MOVE	C,(D)			; get DEV: word
	SKIPE	C
	MOVEM	C,(A)
	AOSN	B
	JRST	SPXIT
	MOVE	C,1(D)			; get first fnam
	SKIPE	C
	MOVEM	C,1(A)
	MOVE	C,2(D)			; get second fnam
	SKIPE	C
	MOVEM	C,2(A)
SPXIT:	POP	P,D
	POP	P,C
	POPJ	P,			; always return if reach here 

;----------------------------------------------------------
; ON,OFF
;----------------------------------------------------------
; TYPRES, TYPSUP -- RESTORATION AND SUPPRESSION OF TYPEOUT
;----------------------------------------------------------

AUTO:	SETCMM	TYPOUT			; complement typing flag
	JRST	GETCOM

;--------------------------------------------
; SAFE, SORRY, SAFE!
;--------------------------------------------

SAFE:	SETOM	SAFETY			; safe ==> -1
	JRST	GETCOM

SORRY:	SETZM	SAFETY			; sorry ==> 0
	JRST	GETCOM

SAFEX:	SETZM	SAFETY
	AOS	SAFETY			; safe! ==> 1
	JRST	GETCOM

TTYMOD:	SETCMM	TTYFLG
	JRST	GETCOM
;--------------------------------------------------
; ?
;--------------------------------------------------
; COMMNDS -- PRINTS OUT COMMAND FILE
;--------------------------------------------------
; file is currently DSK:PDL;DIRED COMMND
;--------------------------------------------------

COMMDS:	.SUSET	[.SSNAM,,COMSNM]	; set sysnam to one where command file is
	MOVEI	A,CMDFIL
	PUSHJ	P,PRNTFL			; open to command file
	JRST	NOPEN1			; if fails, say so
	JRST	GETCOM			; return

;---------------------------------------------------
; F
;---------------------------------------------------
; PFNMS -- PRINTS OUT CURRENT FILE NAME
;---------------------------------------------------

PFNMS:	SKIPE	ODIR			; if no dir, can't win 
	JRST	EMPTY
	OASCR	[ASCIZ //]
	MOVE	A,DIRPTR
	CAMN	A,DIRTOP		; if top file, say so
	OASCR	[ASCIZ /=TOP=/]
	OSIX	OPNFIL+1		; type nam1
	OASC	[ASCIZ / /]
	OSIX	OPNFIL+2		; type nam2
	OASCR	[ASCIZ //]
	MOVE	A,DIRPTR
	CAMN	A,DIREND		; if end file, say so
	OASCR	[ASCIZ /=END=/]
	OASC	[ASCIZ //]
	JRST	GETCOM			; return

;-------------------------------------------
; BROKEN
;-------------------------------------------

BROKEN:	OASCR	[ASCIZ /This command is broken. Sorry./]
	JRST	GETCOM
ERASE:	SETOM	ERSFLG
	JRST	VECTO1

;------------------------------------------------------
; V
;------------------------------------------------------
; VECTOR -- PRINT THE CURRENT VECTOR OF NAMES
;------------------------------------------------------

VECTOR:	SETZM	ERSFLG
VECTO1:	ENAINT	TTYINT,TTYCHK
	SKIPE	ODIR			; if no dir, then return
	JRST	EMPTY
	SKIPL	FONE			; if no arg, simply print whole list
	JRST	VSOME			;   else go off for selective print
	SKIPE	ERSFLG
	JRST	VSOME
	MOVE	A,DIRTOP		; get pointer to top
	SOS	A			; point to just before it
	MOVNI	C,SCRSIZ			; type only a screen at a time
	OASCR	[ASCIZ //]
	OASCR	[ASCIZ / =TOP=/]		; we are at top, so say so
VECNXT:	AOS	A			; go to next file
VECTYP:	INTEST	GETCOM
	CAMLE	A,DIREND		; if past end, 
	JRST	VECEND			;   then leave
	SKIPN	(A)			; if zero, dont print it
	JRST	VECNXT
	SKIPE	TTYFLG
	JRST	.+3
	AOSN	C			; have we filled a screen?
	JRST	SCREEN			; if so, go off to wait for a char
	CAME	A,DIRPTR		; if this is the .F, then indicate it
	JRST	VSP
	OASC	[ASCIZ /*/]			; "*" indicates the .F
	JRST	VNM
VSP:	OASC	[ASCIZ / /]
VNM:	MOVE	B,(A)			;   if non-zero, get pointer to actual name
	SKIPE	ERSFLG
	SETZM	(A)
	OSIX	(B)			; print the name, followed by a <cr>
	OASC	[ASCIZ /	/]
	OSIX	1(B)
	OASCR	[ASCIZ //]
	JRST	VECNXT			; return to top of the loop

VSOME:	PUSH	P,DIRPTR		; save DIRPTR
	PUSHJ	P,PARSNM		; parse the argument
	JRST	VSOMEX			; if not parseable, exit
VSOME1:	INTEST	VSOMEX
	PUSHJ	P,SEARCH			; get a ptr to a file that matches
	JRST	VSOMEX			; if none, exit
	PUSH	P,B
	PUSH	P,C			; save search ptr
	MOVE	B,(C)
	SKIPE	ERSFLG
	SETZM	(C)
	SKIPE	ERSFLG
	OASC	[ASCIZ /-/]
	OSIX	(B)			; type file name followed by PRCR
	OASC	[ASCIZ /	/]
	OSIX	1(B)
	OASCR	[ASCIZ //]
	POP	P,C			; restore search ptr
	POP	P,B
	JRST	VSOME1			; loop for another name
VSOMEX:	POP	P,DIRPTR		; restore DIRPTR
	SKIPL	ERSFLG
	OASCR	[ASCIZ //]
	SKIPE	ERSFLG
	JRST	NXTFIL
	JRST	GETCOM

SCREEN:	CLRINT
	MOVNI	C,SCRSIZ			; restore line count
	PUSH	P,A
	OASC	[ASCIZ /--MORE--/]
	CALLSR	TYI			; get a char from user
	CAIN	A,7			; if its a ^G, exit
	JRST	CTLGX
	POP	P,A			; if not, continue
	OASCR	[ASCIZ //]
	ENAINT	TTYINT,TTYCHK
	JRST	VECTYP

VECEND:	OASCR	[ASCIZ / =END=/]		; here is end, so say so
	OASCR	[ASCIZ //]
	JRST	GETCOM			; return

CTLGX:	POP	P,A			; here for exit without finishing typeout
	OASCR	[ASCIZ /FLUSHED/]
	JRST	GETCOM
;--------------------------------------------------------
; K [arg]
;--------------------------------------------------------
; CTLH -- EXIT FROM DIRED AND PASS ARG TO SUPERIOR
;--------------------------------------------------------

IFE CARESW,[
CTLK:	MOVEI	A,COMMND
	HRLI	A,440700	; set up bptr to command line
	MOVE	B,A
CTLH1:	ILDB	C,A			; get a character
	CAIN	C,15			; first char may be PRCR
	JRST	CTLCR
	CAIE	C,40			; ignore everything until after first space.
	JRST	CTLH1
	ILDB	C,A			; get chars and then
CTLCR:	IDPB	C,B			;   return them, writing over stuff up to space
	CAIE	C,15			; if char is a cr, we are done
	JRST	.-3
	MOVEI	C,0			; deposit a zero to signal the end
	IDPB	C,B
	SKIPE	A,ICS
	CALLSR	CLOSE			; close input channel
	SETZM	ICS
	SKIPE	A,OCS			; and output channel
	CALLSR	CLOSE
	SETZM	OCS
	.SUSET	[.RUNAM,,A]		; reset user to his UNAME
	.SUSET	[.SSNAM,,A]
	.VALUE	COMMND			
	JRST	GETCOM			; if continued, want to win
]
;------------------------------------------
; F, FLAP
;------------------------------------------
; HERE TO FLAP MICROTAPES
;------------------------------------------

FLAPUT:	MOVE	A,FONE			; get the argument
	ANDI	A,777700
	CAME	A,[SIXBIT /   UT /]	; is it "UTn"?
	JRST	FLAP2			; if not, maybe arg is just a number
FLAP1:	MOVE	A,FONE			; if is, then get it in A and B
	MOVE	B,FONE			; in B for error typeout if needed
	JRST	FGETDR			; go convert into a drive number

FLAP2:	MOVE	A,FONE+1		; maybe lazy user forgot the colon
	ANDI	A,777700		; repeat test as above
	CAMN	A,[SIXBIT /   UT /]
	JRST	FLAP1			; if won, go set up A and B
JUSTNM:	MOVE	A,FONE+1		; here we gobble down other possibility
	MOVE	B,FONE+1
	LSH	A,-30.			; get first char in it
FGETDR:	ANDI	A,77
	SUBI	A,20			; convert to a number
	SKIPN	A			; better be non-zero!
	JRST	CNTFLP
	CAILE	A,10			; better be < 8.
	JRST	CNTFLP
	.UDISMT	A,			; flap him
	JRST	CNTFLP			; lost.  go say so
	JRST	GETCOM			; return

CNTFLP:	OASCR	[ASCIZ //]			; here we type the error message
	OASC	[ASCIZ /CAN'T FLAP /]
	OSIX	B
	OASCR	[ASCIZ /!/]
	JRST	GETCOM

;--------------------------------------------
; LINK
;--------------------------------------------
; LINKS BETWEEN DISK FILES
;--------------------------------------------

LINK:	SKIPL	FTWO			; do we have a "to" argument?
	JRST	LINK2			; if so, go check "from" argument
	MOVE	0,[OPNFIL,,FTWO]	; if no "to" arg, then get OPNFIL as def.
	BLT	0,FTWO+3
LINK2:	SKIPE	FTWO+3
	JRST	.+3
	MOVE	A,RSYSNM
	MOVEM	A,FTWO+3
	SKIPGE	FONE			; got a "from" argument?
	JRST	LNKERR			; if not, we lose
	.SUSET	[.SSNAM,,FONE+3]	; if we do have one, set SNAME to its
	MOVEI	A,FONE
	PUSHJ	P,FILEX
	JRST	LINK3
	OASCR	[ASCIZ /File with link name already exists./]
	OASC	[ASCIZ /Delete it?/]
	PUSHJ	P,DECIDE
	JRST	GETCOM
LINK3:	MOVE	0,FTWO+1		; set up .OPEN block for link
	MOVEM	0,FONE+3
	MOVE	0,FTWO+2
	MOVEM	0,FONE+4
	MOVE	0,FTWO+3
	MOVEM	0,FONE+5
	MOVE	0,[SIXBIT /0  DSK/]	; set up first word to mean link
	MOVEM	0,FONE
	.OPEN	FONE			; do link
	JRST	LNKERR			; failed, so go say so
	JRST	GETCOM			; return

LNKERR:	OASCR	[ASCIZ //]			; type error message
	OASCR	[ASCIZ /LINK FAILED!/]
	JRST	GETCOM
;----------------------------------------------
; XF, XFILE
;----------------------------------------------
; INITIALIZES AN XFILE TO USE FOR INPUT
;----------------------------------------------

XFILE:	SKIPGE	FONE			; better be an argument
	JRST	XFXIT			; if not, exit
	HRRI	A,0			; set up for ascii unit input
	HRLM	A,FONE			;   on file pointed to by FONE
	SKIPE	FONE+3
	.SUSET	[.SSNAM,,FONE+3]	; if an SNAME given, set to it
	MOVEI	A,FONE			; open to file of commands
	MOVEM	A,OPNLOC
	CALLSR	OPEN
	JRST	NOPEN1
	MOVEM	A,XCS			; save channel number
	SETOM	XFILF			; flag now says we are xfiling
XFXIT:	JRST	GETCOM

IFN CARESW,[
;--------------------------------
; ACTIVATE ARCHIVE
;--------------------------------

ACTARC:	SKIPGE	FONE
	JRST	NOARC
	MOVE	0,[FONE,,ARCFIL]
	BLT	0,ARCFIL+3
	MOVEI	A,FONE
	MOVE	B,ARCBF
	CALLSR	ARCA
	MOVEM	B,ARCBF
	JRST	GETCOM

NOARC:	OASCR	[ASCIZ //]
	OASCR	[ASCIZ /No ARCHIVE file?/]
	OASCR	[ASCIZ //]
	JRST	GETCOM

;-------------------------------
; INSERT INTO ARCHIVE
;-------------------------------

INSARC:	PUSHJ	P,PARSNM
	JRST	INSAR3
	SKIPN	ARCBF
	JRST	NOARC
INSAR1:	PUSH	P,A
	PUSH	P,B
	STAK	20,FONE
	PUSHJ	P,SEARCH
	JRST	INSARX
INSAR3:	MOVEI	A,SCHBLK
	MOVE	B,ARCBF
	CALLSR	ARCI
	OASC	[ASCIZ /-/]
	FNTYPE	SCHBLK
INSAR2:	SKIPE	ODIR
	JRST	GETCOM
	UNSTAK	20,FONE
	POP	P,B
	POP	P,A
	JRST	INSAR1
INSARX:	UNSTAK	20,FONE
	POP	P,B
	POP	P,A
	JRST	GETCOM
;--------------------------------------------
; DELETE FROM ARCHIVE
;--------------------------------------------

DELARC:	MOVEI	A,FONE
	MOVE	B,ARCBF
	JUMPE	B,NOARC
	CALLSR	ARCD
	OASC	[ASCIZ /-/]
	FNTYPE	FONE
	JRST	GETCOM

;--------------------------------------------
; EXTRACT FROM AN ARCHIVE
;--------------------------------------------

EXARC:	MOVEI	A,FONE
	MOVEI	C,FTWO
	MOVE	B,ARCBF
	JUMPE	B,NOARC
	CALLSR	ARCE
	OASC	[ASCIZ /-/]
	FNTYPE	FONE
	JRST	GETCOM

;--------------------------------------------
; LIST ARCHIVE DIRECTORY
;--------------------------------------------

LISARC:	MOVE	B,ARCBF
	JUMPE	B,NOARC
	CALLSR	ARCL
	JRST	GETCOM

;-------------------------------------
; CLOSE ARCHIVE
;-------------------------------------

CLSARC:	SETOM	FONE
	MOVEI	A,FONE
	MOVE	B,ARCBF
	SKIPE	B
	CALLSR	ARCA
	SETZM	ARCBF
	JRST	GETCOM
]

;--------------------------------------------
; T
;--------------------------------------------
; OPENS A FILE FOR TYPEOUT
;--------------------------------------------

TYPST:	SKIPE	ODIR			; if no dir can't type out
	JRST	EMPTY
	SETZM	LINSAV			; haven't typed anything, so
	SETZM	LINSV1			;   set record to zero
	SKIPE	A,ICS			; close input channel if there is one
	CALLSR	CLOSE
	SETZM	ICS
	MOVEI	A,OPNFIL		; open to file we are pointing to
	MOVEM	A,OPNLOC
	CALLSR	OPEN
	JRST	NOPEN1			; if fails, go say so
	MOVEM	A,ICS			; if succeeds, save channel
	JRST	TYPE1			; go type some lines

;----------------------------------------------
; "
;----------------------------------------------
; HERE WE REPEAT LAST TYPEOUT 
;----------------------------------------------

TYPEL:	SKIPE	ODIR			; better be something to type
	JRST	EMPTY
	SKIPE	A,ICS			; close input channel
	CALLSR	CLOSE
	MOVEI	A,OPNFIL		; open to .F
	MOVEM	A,OPNLOC
	CALLSR	OPEN
	JRST	NOPEN1			; exit if open fails
	MOVEM	A,ICS			; save channel open on
	MOVE	ARGP,LINSV1		; ARGP/ # of lines to skip
	SETOM	A			; A/ -1 ==> skip lines passed in ARGP
	PUSHJ	P,TYPNL			; type/skip lines as above
	JRST	EOFR			; reached EOF, so exit
	MOVE	ARGP,LINSAV
	SUB	ARGP,LINSV1		; ARGP/ number of lines typed on last typeout
	SETZM	A			; A/ 0 ==> actually type these lines
	PUSHJ	P,TYPNL			; type
	JFCL				; can't get EOF since only repeating last typeout
	JRST	GETCOM			; return
;-----------------------------------------
; Y
;-----------------------------------------
; HERE WE MOVE FURTHER IN A FILE
; (ALSO CALLED AFTER OPEN FROM TYPST)
;-----------------------------------------

TYPE1:	SKIPE	ODIR			; if no dir, no typeout
	JRST	EMPTY
	SKIPGE	FONE			; was there an argument passed?
	JRST	TYPARG			; if not, then go on and type default
	MOVE	ARGP,FONE+1		; if was argument, then get it
	PUSHJ	P,XNUM			;   and extract a number from it
	JRST	BADNUM			; couldn't extract a number, so exit
	MOVEM	ARGP,LINTYP		; got a number.  make it new default
TYPARG:	MOVE	ARGP,LINTYP		; get number of lines to type
	SETZM	A			; actually type them
	PUSHJ	P,TYPNL			; type
	JRST	EOFR			; got an EOF
	PUSHJ	P,LUPDAT		; update record of lines typed
	OASCR	[ASCIZ //]			; PRCR ==> more file typeable
	JRST	GETCOM

EOFR:	PUSHJ	P,LUPDAT		; update record of lines typed
	JRST	GETCOM

;-----------------------------------------------
; TYPES OR SKIPS LINES OF A FILE
;-----------------------------------------------
;  ARGP/ # OF LINES TO TYPE, # TYPED ON RETURN
;  A/ 0 ==> TYPE, -1 ==> SKIP
;  SKIP RETURN IF NO EOF ENCOUNTERED
;-----------------------------------------------

TYPNL:	ENAINT	TTYINT,TTYCHK
	MOVNM	ARGP,LINCNT		; put -# of lines in counter
	SETZM	ARGP			; ARGP becomes counter of actual typeout
TYPN1:	AOSLE	LINCNT			; finished typing?
	JRST	EOFX2			; if so, exit
TYPN2:	INTEST	EOFX
	SKIPN	ICS			; if not, check for actual winning channel
	JRST	EOFX			; if channel not open, exit
	PUSH	P,A			; save type/skip
	MOVE	A,ICS
	CALLSR	IOT			; iot a char
	POP	P,A			; restore type/skip
	JUMPL	B,EOFX1			; if EOF, go housekeep
	JUMPL	A,TYPN3			; if A < 0, we are skipping
	MOVE	A,B			; if A = 0, get char iot'ed
	CAIN	A,14
	JRST	TYPN3
	CALLSR	TYO			; and output it to TTY
TYPN3:	CAIE	B,12			; is char a LF?
	JRST	TYPN2			; if not, go get another char
	AOS	ARGP			; if was, aos number of lines typed
	JRST	TYPN1			;   and loop through counter

EOFX2:	AOS	(P)			; here we exit without EOF
EOFX:	OASCR	[ASCIZ //]			; here we exit because of some sort of lose
	.SUSET	[.SSNAM,,RSYSNM]	; set SNAME to real SNAME 
	POPJ	P,			; return, no skip

EOFX1:	SKIPE	A,ICS			; here on EOF
	CALLSR	CLOSE			; close channel
	SETZM	ICS
	JRST	EOFX			; go to normal return, no skip

;-------------------------------------------
; UPDATES LINE COUNTERS
;   LINSAV IS RECENTEST, LINSV1 FOR T-1
;-------------------------------------------

LUPDAT:	MOVE	A,LINSAV		; get time T
	MOVEM	A,LINSV1		; make it T-1
	ADDM	ARGP,LINSAV		; update it for new T
	POPJ	P,
;--------------------------------------------
; XNUM -- EXTRACTS NUMBER FROM ASCII STRING
;--------------------------------------------

XNUM:	MOVE	A,[440600,,ARGP]	; bptr to ARGP
	SETZM	B
	SETZM	C
	SETZM	D
	ILDB	B,A			; get a char
	CAIE	B,15			; is it a "-"
	JRST	XNUM1+1
	SETOM	D			; if was "-", then set flag
XNUM1:	ILDB	B,A			; get a char
	SKIPN	B			; if 0, then exit
	JRST	XNUM2
	CAIL	B,20
	CAIL	B,32			; is it a number?
	POPJ	P,			; if not a number, then return w. no skip
	ANDI	B,7			; if is a number, get number part
	ASH	C,3			; shift old number left
	ADDM	B,C			; add next digit
	JRST	XNUM1			; return for another

XNUM2:	EXCH	C,ARGP			; put number back in ARGP
	CAMN	D,[-1]			; was it a negative?
	MOVNS	ARGP			; if so, negate it
	SKIPE	ARGP			; if number is =0, then don't skip
	AOS	(P)			; else skip
	POPJ	P,			; and return
;----------------------------------------------
; DECIDE -- GET A YES OR NO ANSWER FROM TTY
;----------------------------------------------

DECIDE:	PUSH	P,A
	OASC	[ASCIZ / (Y or N): /]		; type question
	CALLSR	TYI			; get char
	OASCR	[ASCIZ //]
	CAIE	A,"Y
	CAIN	A,"y
	AOS	-1(P)			; if its a "Y", then skip
	POP	P,A			; else no skip
	POPJ	P,
;----------------------------------------
; DELETE
;----------------------------------------
	
DELETE:	SKIPE	A,ICS
	CALLSR	CLOSE			; close input channel
	SETZM	ICS			; set channel saved to zero
	PUSHJ	P,PARSNM		; parse the argument to DELETE
	JRST	DELX2			;   no skip if different or no dir
	SKIPL	SAFETY			; if SAFE, then ask user permission
	JRST	DELSTS			;   else go on
	OASC	[ASCIZ /Are you sure?/]		; ask question
	PUSHJ	P,DECIDE		;   get answer
	JRST	GETCOM			;   no skip means abort DELETE
DELSTS:	SKIPE	MASK+1			; here we check to see if masks are
	JRST	DELET1			;   both =0, which would mean that
	SKIPE	MASK+2			;   command was "D * *"
	JRST	DELET1			; if wasn't, then skip question
USRLOS:	OASCR	[ASCIZ //]			; ask user if he really meant that
	OASCR	[ASCIZ /Are you SURE you want to delete/]
	OASC	[ASCIZ /your ENTIRE "/]
	HRRZ	N,INDEV
	OSIX	N			;   all this is to type out DEV:USR;
	OASC	[ASCIZ /:/]
	OSIX	RSYSNM
	OASC	[ASCIZ /;"/]
	OASCR	[ASCIZ / DIRECTORY?/]
	PUSHJ	P,DECIDE		;   finally let him decide
	JRST	GETCOM			;   if decides no, then abort
DELET1:	PUSHJ	P,SEARCH		; start of deletion loop -- search for match to arg
	JRST	DELXIT			; lose, no match found
	SETZM	SCHBLK+3		; found a match, so set location for deletion
	SKIPG	SAFETY			; before deleting, ask again
	JRST	DELX3			;   if SAFE!
	OASC	[ASCIZ /DELETE /]
	FNTYPE	SCHBLK
	OASC	[ASCIZ /Are you sure?/]		; types question, specifying file to be
	PUSHJ	P,DECIDE		;   deleted, and asks for answer
	JRST	DELET1			;   if answer no, don't delete this file
DELX3:	.FDELE	SCHBLK			; delete file (was in vector so should work)
	JRST	DELET2			;   if can't, then say so (should not often happen)
	SETZM	(C)			; zero vector entry for this file 
	OASC	[ASCIZ /-/]			; type its name so user can keep track
	FNTYPE	SCHBLK
	JRST	DELET1			; and loop

DELET2:	OASC	[ASCIZ /Can't DELETE /]		; here if can't delete
	FNTYPE	SCHBLK			; type dismal message
	JRST	DELET1

DELXIT:	JRST	NXTFIL			; go houseclean before returning to command level

DELX2:	SETZM	SCHBLK+3		; here for deletion outside active dir
	SKIPN	SAFETY			; on SORRY, ask if he is sure
	JRST	DELX4			;   else go do it
	OASC	[ASCIZ /DELETE /]
	FNTYPE	SCHBLK
	OASC	[ASCIZ /Are you sure?/]
	PUSHJ	P,DECIDE		; type question and let him decide
	JRST	GETCOM			;   answer was no, so return
DELX4:	MOVEI	A,SCHBLK
	MOVEM	A,OPNLOC
	.FDELE	SCHBLK			; delete exact argument
	JRST	NODEL			;   if lose, type message
	OASC	[ASCIZ /-/]
	FNTYPE	SCHBLK
	JRST	GETCOM			; return to command level
;-------------------------------------------
; DIRECTORY SEARCH ROUTINES
;-------------------------------------------
; 1. PARSNM -- PARSES COMPLEX ARGUMENTS
;-------------------------------------------
;    RETURNS RESULTS IN A/,B/, AND SCHBLK
;    A/ FNAM1
;    B/ FNAM2
;    SCHBLK/ FILE SPECN 
;-------------------------------------------

PARSNM:	ZFBLK	SCHBLK			; zero argument block
	SETOM	MASK+1			; set masks to initial state of no mask
	SETOM	MASK+2
	SETOM	MASK2+1
	SETOM	MASK2+2
	SETZM	LESFLG			; set >,< flag to no >,<
	MOVE	0,[FONE,,SCHBLK]
	BLT	0,SCHBLK+3		; get actual argument
	.SUSET	[.SSNAM,,SCHBLK+3]	; set SNAME to that of argument
	SKIPE	ODIR			; if in another (or no) dir, then go leave
	JRST	POUT
PDEV:	SETZM	C			; C will be flag for operations in other dir
	SKIPGE	FONE			; we better have an argument to parse
	JRST	PFSET			; if not, then go parse second argument 
	HRRZ	A,INDEV			; DEV: of current active dir
	HRRZ	B,FONE			; DEV: of argument
	JUMPE	B,PDEV1			; if none in arg, then use other
	CAMN	A,B			; are they the same?
	JRST	PDEV1			;   if they are, then don't worry
	MOVEM	B,SCHBLK		;   if not, put one from arg in output
	SETOM	C			; and set difference flag
	JRST	PUSR			; go check USR:
PDEV1:	MOVEM	A,SCHBLK		; here if DEV: same or not there in arg
PUSR:	MOVE	A,RSYSNM		; get USR: of active dir
	MOVE	B,FONE+3		; get USR: of argument
	JUMPE	B,PUSR1		; is there one for argument
	CAMN	A,B			; if there is, is it same as real one?
	JRST	PUSR1			; if same, go use it
	.SUSET	[.SSNAM,,B]		; if not same, then set SNAME to arg's
	MOVEM	B,SCHBLK+3		; and put it in output block
	SETOM	C			; and set flag indicating difference 
	JRST	PDUDIF
PUSR1:	MOVEM	A,SCHBLK+3		; here if same or no USR: in arg

PDUDIF:	SKIPE	C			; if not in active dir, no reason to parse
	JRST	POUT			;   as can only search active dir

PFSET:	MOVEI	A,FTWO			; parse second argument
	PUSHJ	P,PARGN			; (done first as want results from other in SCHBLK)
	MOVEI	A,FONE			; parse first argument
	PUSHJ	P,PARGN

PXIT:	AOS	(P)			; skip return implies in active dir
	SETZM	ODIR			; make sure set that way for later tests
	JRST	.+2
POUT:	SETOM	ODIR			; set to say other dir here
	MOVE	A,SCHBLK+1		; result of parse of first argument
	MOVE	B,SCHBLK+2		;   goes in A and B
	SKIPE	LESFLG			; direction of search depends on whether there
	JRST	PUP			; was a > or a < as argument, as dirs are alphabetical
PDN:	MOVE	E,DIRTOP		; here arg has a >, or neither
	POPJ	P,
PUP:	MOVE	E,DIREND		; here arg has a <
	POPJ	P,
;-----------------------------------------
; ACTUAL ARGUMENT PARSE
;  LEAVES RESULTS IN SCHBLK
;-----------------------------------------

PARGN:	MOVE	H,A			; save pointer to file spec
	SETZM	A			; A is index for two words of a name
PFNAMN:	AOS	A			; move to first word
	AOS	H			; move to first word in name pointer
	CAIN	A,3			; at end?
	JRST	PARGX			; if so, go exit
	SKIPE	(H)			; if no arg at all, assume .F
	JRST	PEQUAL			; if is an argument, go start parse
	MOVE	0,[OPNFIL+1,,SCHBLK+1]	; here for BLT of .F into block
	BLT	0,SCHBLK+2
	JRST	PARGX			; and then exit

PEQUAL:	MOVE	B,(H)			; get word of argument
	CAME	B,[SIXBIT /=/]		; is it an "="?
	JRST	PLEGR			;   if not, go on
	MOVE	B,OPNFIL(A)		;   if is, get word from .F
	MOVEM	B,SCHBLK(A)		; put it in SCHBLK
	MOVEM	B,(H)
	JRST	PFNAMN			; and loop

PLEGR:	CAME	B,[SIXBIT />/]		; is name a greater than?
	JRST	.+3
	MOVEM	B,SCHBLK(A)		;   if is, then simply pass it on
	JRST	PFNAMN			;   and loop
	CAME	B,[SIXBIT /</]		; is name a less than? 
	JRST	PSTAR			;   if not, go on
	MOVEM	B,SCHBLK(A)		; else pass it on
	SETOM	LESFLG			;   and set flag for direction of search 
	JRST	PFNAMN			;   and loop

PSTAR:	CAME	B,[SIXBIT /*/]		; is name a "*"?
	JRST	PQUEST			;   if not, go on
	SETZM	4(H)			; if is a star, then zero mask (loc + 4)
	MOVEM	B,SCHBLK(A)		; and save name
	JRST	PFNAMN			; and loop

PQUEST:	SETZM	F			; individual chars as stars
	SETOM	G			; output starts as unmasked
	MOVE	C,[440600,,B]		; byte pointers to input and output
	MOVE	E,[440600,,G]
PNEXT6:	ILDB	D,C			; get a char
	CAMN	C,[360600,,C]		; finished?
	JRST	PQXIT			; if so exit
	CAIN	D,12			; if not, is char a *
	JRST	.+3			; if is, jrst
	IBP	E			; if not, inc bptr without outputting
	JRST	PNEXT6			; and loop
	IDPB	F,E			; was a star, so output
	JRST	PNEXT6			; and loop
PQXIT:	MOVEM	G,4(H)			; put completed mask in mask word
	JRST	PFNAMN			; and loop

PARGX:	POPJ	P,			; return
;---------------------------------------------
; 2. SEARCH -- LINEAR SEARCH OF DIR VECTOR
;---------------------------------------------
; CALL: E/ PTR TO DIR VECTOR
;       A/ FNAM1 to match
;       B/ FNAM2 to match
; RETURN: E/ PTR TO NEXT FILE IN VECTOR
;         C/ PTR TO A MATCH
;         SCHBLK/ SPECN OF MATCH
; NO SKIP IF CAN'T FIND MATCH
;-------------------------------------------- 

SEARCH:	PUSH	P,A			; save fnames we want to match
	PUSH	P,B
NSRCH:	PUSHJ	P,GRELES		; if file is a >,<, this will find real name
	JRST	DSRCH			;   not a greater than or less than in name
	JRST	SFAIL			;   had one, but search failed for some reason
DSRCH:	PUSHJ	P,GETNAM		;   search vector for name in A and B
	JRST	SFAIL			; can't find match
	MOVE	C,(E)			; found match, so get ptr to actual specn
	MOVE	A,(C)			; get FNAM1
	MOVEM	A,SCHBLK+1		; and put in SCHBLK
	MOVE	A,1(C)			; get FNAM2
	MOVEM	A,SCHBLK+2		; and put in SCHBLK
	MOVE	A,INDEV			; get current DEV:
	MOVEM	A,SCHBLK		; and put it in output
	MOVE	C,E			; put ptr to vector entry in C 
	CAMN	C,DIRPTR
	SETOM	PFFLAG
	SKIPN	LESFLG			; which direction are we searching in
PTRAOS:	AOJA	E,.+2			; if down, aos pointer
PTRSOS:	SOS	E			; if up, sos pointer
	POP	P,B			;   restore fnames
	POP	P,A
	AOS	(P)			; skip return
	POPJ	P,

SFAIL:	POP	P,B			; search failed
	POP	P,A
	POPJ	P,			; no skip return

;--------------------------------------------
; GRELES -- FINDS REAL NAME OF > OR <
;--------------------------------------------
; THIS ROUTINE IS A HORRIBLE KLUDGE!
;--------------------------------------------

GRELES:	SETZM	SRCHSV
	SETZM	SRCHSV+1
GRELET:	PUSH	P,A				; save names
	PUSH	P,B
	CAME	A,[SIXBIT /</]			; is there a > or < in A?
	CAMN	A,[SIXBIT />/]
	JRST	AGLSET				;   if so, jump
	CAME	B,[SIXBIT /</]			; is there a > or < in B?
	CAMN	B,[SIXBIT />/]
	JRST	BGLSET				;   if so, jump
	JRST	GLNGL				; no > or <, so exit

AGLSET:	SETZM	MASK+1				; set mask for FNAM1
	JRST	GREGET
BGLSET:	SETZM	MASK+2				; set mask for FNAM2

GREGET:	PUSHJ	P,GETNAM			; search for "mumble *"
	JRST	GLFAIL				; no match, so exit
	MOVE	A,-1(P)				; recover FNAM1
	MOVE	B,(P)				; recover FNAM2
	CAME	A,[SIXBIT /</]			; was the > or < in FNAM1?
	CAMN	A,[SIXBIT />/]
	JRST	ANWSET				; if so, jump
	CAME	B,[SIXBIT /</]			; was the > or < in FNAM2?
	CAMN	B,[SIXBIT />/]
	JRST	BNWSET				; if so, jump
	.VALUE	GROLOS				; better have been in one of them!

ANWSET:	SETOM	MASK+1				; set mask back to no mask
	MOVE	A,-1(P)				; use old name (> or <) from arg
	MOVE	B,1(C)				; and new name found by search
	JRST	NAMCHK				; and go
BNWSET:	SETOM	MASK+2				; reset mask
	MOVE	A,(C)				; get nam1 from result of search
	MOVE	B,(P)				; get nam2 (> or <) from saved arg

NAMCHK:	CAMN	A,SRCHSV			; have we already done this one?
	CAME	B,SRCHSV+1
	JRST	OPNSET				; if not, jump
RESTOR:	SKIPN	LESFLG				; else increment ptr to point to next
	AOJA	E,.+2
	SOS	E
	POP	P,B				; restore args
	POP	P,A
	JRST	GRELET				; and loop

OPNSET:	MOVEM	A,SRCHSV			; save name so we won't do him twice
	MOVEM	B,SRCHSV+1
	MOVEM	A,SCHBLK+1			; put in SCHBLK the name we have found
	MOVEM	B,SCHBLK+2
	HRRZ	A,INDEV
	MOVEM	A,SCHBLK			; put device spec in SCHBLK
	.SUSET	[.RSNAM,,N]			; read current SNAME
	.SUSET	[.SSNAM,,SCHBLK+3]		; set SNAME to one in arg 
	MOVEI	A,SCHBLK			; set up and
	MOVEM	A,OPNLOC
	CALLSR	OPEN				;   open to arg
	JRST	NAMOUT				; if loser go say so
	.SUSET	[.SSNAM,,N]			; restore saved system name
	MOVEM	A,TCS				; save channel we opened
RCHNAM:	HRLI	A,RCHLOC			; set up a .RCHST
	MOVSS	A
	.RCHST	A,				; read status of channel we opened
	SKIPE	A,TCS
	CALLSR	CLOSE				; close channel
	SETZM	TCS				; record the close
	MOVE	A,RCHLOC+3			; SNAME of file open to
	CAMN	A,RSYSNM			; is it same a active dir?
	JRST	GOTNAM				; if it is, we have a winner!
NAMOUT:	OASC	[ASCIZ /Can't get /]			; confess that we lost
	FNTYPE	SCHBLK
	JRST	RESTOR				; and go try for another one

GOTNAM:	MOVE	A,RCHLOC+1			; get resulting names into A
	MOVE	B,RCHLOC+2			;   and B, from winning search
GLWIN:	AOS	-2(P)				; skip twice, as we won totally
	AOS	-2(P)
	POP	P,0				; and don't restore old names
	POP	P,0
	POPJ	P,				; return

GLFAIL:	AOS	-2(P)				; here for intermediate lossage
GLNGL:	POP	P,B				; here for not a > or <
	POP	P,A
	POPJ	P,				; return

;--------------------------------------------------
; NWFTWO -- CREATES NEW SECOND ARG WITH MASKS
;   AND FIRST ARG, ETC.
;   NAME2 <-- (NAME1 & MASK2) \ (NAME2 & MASK2)
;--------------------------------------------------

NWFTWO:	PUSH	P,A
	PUSH	P,B				; save acs we will use
	MOVE	A,SCHBLK+1			; get parsed etc., FNAM1 of first arg
	ANDCM	A,MASK2+1			; kill chars usually not masked
	MOVE	B,FTWO+1			; get FNAM1 of second arg
	AND	B,MASK2+1			; kill masked chars
	IOR	A,B				; or them together to get result
	MOVEM	A,FTWO+1			; and put in as new FTWO
	MOVE	A,SCHBLK+2			; do same as above for FNAM2
	ANDCM	A,MASK2+2
	MOVE	B,FTWO+2
	AND	B,MASK2+2
	IOR	A,B
	MOVEM	A,FTWO+2
	POP	P,B				; restore acs
	POP	P,A
	POPJ	P,				; return
;----------------------------------------
; GETNAM -- ACTUAL SEARCH ROUTINE
;----------------------------------------
; CALL: A/ FNAM1
;       B/ FNAM2
;       E/ PTR TO FIRST POSSIBLE MATCH
; RETURN: C/ PTR TO ACTUAL NAME OF MATCH
;       E/ PTR TO MATCH'S ENTRY IN VECTOR
;----------------------------------------

GETNAM:	PUSH	P,A				; save acs
	PUSH	P,B
	SKIPN	LESFLG				; depending on whether
	CAMG	E,DIREND			; search direction is up or
	CAMGE	E,DIRTOP			; down, check if past end
	JRST	GETXIT				; if are, then exit
	SKIPN	(E)				; is vector entry null?
	JRST	GETLOS				; if so, attempt at match fails
	AND	A,MASK+1			; kill masked chars in FNAM1
	MOVE	C,(E)
	MOVE	C,(C)				; get possible match word
	AND	C,MASK+1			; kill mask chars in it
	CAME	A,C				; are they the same?
	JRST	GETLOS				; if not, try at match fails
	MOVE	A,(P)				; if they are, get FNAM2
	AND	A,MASK+2			; kill masked chars
	MOVE	C,(E)
	MOVE	C,1(C)				; get possible match word
	AND	C,MASK+2			; kill masked chars in it
	CAME	A,C				; are they the same?
	JRST	GETLOS				; if not, try at match fails
	JRST	GOTCHA				; if they are, we have a match!

GETLOS:	SKIPN	LESFLG				; skip if searching upwards
	JRST	GETDN				; searching downwards
GETUP:	SOS	E				; searching upwards, so SOS 
	CAMGE	E,DIRTOP			; gone past top?
	JRST	GETXIT				; if have, then exit
	SKIPN	(E)				; is vector entry null
	JRST	GETUP				; if is, try again
	JRST	GETLUP				; if not, go to search loop
GETDN:	AOS	E				; going downwards, so AOS
	CAMLE	E,DIREND			; gone past end?
	JRST	GETXIT				; if have, then exit
	SKIPN	(E)				; entry null?
	JRST	GETDN				; if is, try again

GETLUP:	POP	P,B				; restore acs and then
	POP	P,A				; go to GETNAM to simulate a fresh
	JRST	GETNAM				; call

GOTCHA:	AOS	-2(P)				; skip return
	MOVE	C,(E)				; get ptr to actual names into C
GETXIT:	POP	P,B				; restore acs
	POP	P,A
	POPJ	P,				; and return

;--------------------------------------
; NXTFIL -- SET POINTER TO "NEXT FILE"
;--------------------------------------

NXTFIL:	PUSHJ	P,EMPDIR			; houseclean vector
	JRST	EMPTY				;   vector is now empty
	SKIPE	@DIRPTR				; is next file null?
	JRST	GETAFL				; if not, then go make it .F
NXTFL1:	MOVNI	N,1				; if is, then get next real file
	SKIPE	UPFLG
	JRST	GETLST				; go to next file in appropriate
	JRST	GETNXT				; direction
;-------------------------------------
; LISTF -- LISTING OF VARIOUS DIRS
;-------------------------------------

LISTME:	ENAINT	TTYINT,TTYCHK
	SKIPG	FONE				; does it have an argument?
	JRST	LIST0				; if not, use default
	MOVE	A,[FONE,,LISDEV]		; if does, update default with argument
	MOVNI	B,2				; only update DEV:USR;
	PUSHJ	P,SPECUD			; do update
LIST0:	.SUSET	[.SSNAM,,LSYSNM]		; set SNAME appropriately
	MOVEI	A,LISDEV			; get ptr to open block
	PUSHJ	P,PRNTFL			; and print file
	JRST	NOPEN1				; open failed
	JRST	GETCOM				; return to command level

;------------------------------------
; PRINT -- PRINTS CONTENTS OF FILES
;------------------------------------

PRINT:	SKIPL	FONE				; has it got an argument?
	JRST	.+3
	MOVE	0,[OPNFIL,,FONE]		; if not, then BLT
	BLT	0,FONE+3			; in .F
	.SUSET	[.SSNAM,,FONE+3]		; and set SNAME appropriately
	OASCR	[ASCIZ//]					; type a CRLF
	MOVEI	A,FONE				; ptr to open block
	PUSHJ	P,PRNTFL			; type out file
	JRST	NOPEN1				; open failed
	OASCR	[ASCIZ//]					; type a CRLF
	JRST	GETCOM				; return to command level
;---------------------------------------
; STATUS -- CURRENT STATUS OF DIRED
;---------------------------------------

STATUS:	OASCR	[ASCIZ//]					; type a CRLF
	OASC	[ASCIZ /Source:	/]		; source
	MOVEI	A,INDEV				; print out DEV:USR;
	PUSHJ	P,PRNTSP			; of INDEV
	MOVE	A,ODIR				; get active flag
	JUMPL	A,.+3				; if no dir, say so
	OASC	[ASCIZ / (activated)/]		; else say dir is active
	SKIPA	A
	OASC	[ASCIZ / (not activated)/]
	OASCR	[ASCIZ//]
	OASC	[ASCIZ /Backup:	/]		; backup
	MOVEI	A,OUTDEV
	PUSHJ	P,PRNTSP			; print DEV:USR;
	OASCR	[ASCIZ//]
IFN CARESW,[
	OASC	[ASCIZ /Archiv:	/]	; archive
	SKIPN	ARCBF
	JRST	ST1
	MOVEI	A,ARCFIL
	PUSHJ	P,PRNTSP
	PUSHJ	P,PRNTNM
ST1:	OASCR	[ASCIZ//]
]
	OASC	[ASCIZ /Safety:	/]		; level of safety
	PUSHJ	P,PSAFE				; print value of SAFETY/
	OASCR	[ASCIZ//]
	OASC	[ASCIZ /.FILE:	/]		; current .file
	MOVEI	A,OPNFIL
	PUSHJ	P,PRNTNM
	OASCR	[ASCIZ//]
	OASCR	[ASCIZ//]
	JRST	GETCOM				; return to command level

;----------------------------------------------------
; PRNTSP and PRNTNM -- PRINT "DEV:USR;" or "N1 N2"
;----------------------------------------------------
; A/ PTR TO OPEN BLOCK
;----------------------------------------------------

PRNTSP:	PUSH	P,N				; save N
	HRRZ	N,(A)				; get DEV
	JUMPE	N,.+3				; if none, don't print it
	OSIX	N				; print it
	OSIX	[SIXBIT /:/]
	SKIPN	3(A)				; is there an SNAME
	JRST	.+3				; if not, don't print
	OSIX	3(A)				; print it
	OSIX	[SIXBIT /;/]
	POP	P,N				; restore N
	POPJ	P,				; return

PRNTNM:	SKIPE	1(A)				; don't print if no name
	OSIX	1(A)				; print
	OASC	[ASCIZ / /]			; space in between
	SKIPE	2(A)				; if no nam2 don't print
	OSIX	2(A)				; print
	POPJ	P,				; return

;----------------------------------------------------
; PSAFE -- PRINT CURRENT VALUE OF SAFETY
;----------------------------------------------------

PSAFE:	SKIPN	SAFETY				; if not zero is either SAFE or SAFE!
	JRST	.+5				; otherwise must be SORRY
	OSIX	[SIXBIT /SAFE/]			; so print that part
	SKIPLE	SAFETY				; skip if it is SAFE
	OSIX	[SIXBIT /!/]			; print ! to complete SAFE!
	POPJ	P,				; return
	OSIX	[SIXBIT /SORRY/]		; print SORRY
	POPJ	P,				; return
;-------------------------------------------
; RENAME ARG1$ARG2
;-------------------------------------------

RENAME:	SKIPGE	FONE			; is there an arg1?
	JRST	RNAMB			; if not, go see about arg2
	SKIPL	FTWO			; if arg1, is there an arg2?
	JRST	RNAM0			; if arg2, then we have two
	MOVE	0,[FONE,,FTWO]		; if not, arg1 ==> arg2
	BLT	0,FTWO+3
	MOVE	0,[OPNFIL,,FONE]	; and opnfil ==> arg1
	BLT	0,FONE+3
	JRST	RNAM0			; start actual execution

RNAMB:	SKIPGE	FTWO			; is there an arg2?
	JRST	NONNAM			; here means no arg at all, so error
	MOVE	0,[OPNFIL,,FONE]	; is an arg2, but no arg1, so
	BLT	0,FONE+3		; opnfil ==> arg1

RNAM0:	PUSHJ	P,PARSNM		; parse arguments
	JRST	RNAMA			; no dir or diff. dir, so skip searching
RNAMLP:	PUSH	P,A			; save result of parse
	PUSH	P,B
	STAK	20,FONE			; save argument/mask blocks
	PUSHJ	P,SEARCH		; get a match
	JRST	RNAMX			; no match, so exit
	MOVE	0,[SCHBLK,,FONE]	; put result of search into arg1
	BLT	0,FONE+4
	MOVEM	C,L			; save pointer to match
RNAMA:	SKIPE	A,ICS			; close input channel if its open
	CALLSR	CLOSE
	SETZM	ICS			; record close
	.SUSET	[.SSNAM,,FONE+3]	; set to SNAME of arg1
	MOVEI	A,FONE
	PUSHJ	P,FILEX			; find out if arg1 exists
	JRST	RNERR			; doesn't exist, so error
	MOVE	A,FONE			; must be same dir, so see to it
	MOVEM	A,FTWO
	PUSHJ	P,NWFTWO		; create new second arg
	SKIPN	SAFETY			; if safety, then skip
	JRST	REDELC			; if SORRY, then jrst off
	MOVEI	A,FTWO
	PUSHJ	P,FILEX			; does new name already exist?
	JRST	REDELC			; if not, then no problem
	OASCR	[ASCIZ /File with new name already exists./]
	OASC	[ASCIZ /Delete it?/]
	PUSHJ	P,DECIDE		; otherwise user must decide
	JRST	RNRST			; if answer is no, then go to loop
REDELC:	SETZM	FTWO+3			; delete any file with new name
	.FDELE	FTWO
	JRST	RNAM1			; if failed, no housekeeping necessary
	SKIPE	ODIR			; ditto if in another dir
	JRST	RNAM1
	MOVE	A,FTWO+1		; otherwise, must housekeep vector
	MOVE	B,FTWO+2
	PUSH	P,E			; save ptr
	MOVE	E,DIRTOP
	PUSHJ	P,GETNAM		; get match to second name
	SKIPA	E			; if none, who cares?
	SETZM	(E)			; delete it
	POP	P,E			; restore pointer
RNAM1:	MOVE	0,[FTWO+1,,FONE+3]	; set up BLT
	BLT	0,FONE+4		; to create .RENAME block
	SKIPN	FONE+3			; better not be zero == .FDELE !
	.VALUE	GROLOS			; if zero, gross lossage
	MOVEI	A,FONE
	MOVEM	A,OPNLOC
	.FDELE	FONE			; rename
	JRST	NORNM			; rename failed, so say so
	MOVE	C,L			; restore pointer to match
	MOVE	C,(C)			; get ptr to actual names
	MOVE	A,FTWO+1		; get new names
	MOVE	B,FTWO+2
	MOVEM	A,(C)			; and put them in vector
	MOVEM	B,1(C)
	CAME	L,DIRPTR		; was this also .File ?
	JRST	RNRST1
	MOVE	0,[FTWO+1,,OPNFIL+1]	; if so, BLT names in OPNFIL too
	BLT	0,OPNFIL+2
RNRST1:	OASC	[ASCIZ /-/]			; type name of file we renamed
	FNTYPE	FONE
RNRST:	SKIPE	ODIR			; if in another dir, no stack restoration
	JRST	GETCOM			;   so simply return
	UNSTAK	20,FONE			; restore arguments
	POP	P,B			; restore parsed names
	POP	P,A
	JRST	RNAMLP			; loop for another match

RNAMX:	UNSTAK	20,FONE
	POP	P,B
	POP	P,A
	JRST	GETCOM

NORNM:	OASCR	[ASCIZ //]			; here if RENAME failed
	OASC	[ASCIZ /RENAME OF /]
	PUSHJ	P,ERROR
	JRST	RNRST			; and exit

RNERR:	OASCR	[ASCIZ //]			; here if file to be renamed doesn't exist
	OASCR	[ASCIZ /NO SUCH FILE?/]
	JRST	RNRST			; and exit
;----------------------------------------
; COPY, SAVE, BACKUP  arg1$arg2
;----------------------------------------

FILCPY:	SKIPE	A,ICS
	CALLSR	CLOSE			; close current open file
	SETZM	ICS
	MOVE	A,FTWO			; get DEV: part of arg2
	MOVEM	A,BUF			; and save it
	PUSHJ	P,PARSNM		; parse name
	JRST	FILOPN			; if no dir, assume both correct
FILCP0:	PUSH	P,A			; save parsed names
	PUSH	P,B
	STAK	20,FONE			; save argument blocks
FILCP3:	PUSHJ	P,SEARCH		; gets a name
	JRST	FILX1			;   no skip if fails
	MOVE	A,SCHBLK+1		; get name, result of search
	MOVE	B,SCHBLK+2
	SKIPN	FTWO+1			; if no name1 in arg2
	MOVEM	A,FTWO+1		;   then use name1 from arg1
	SKIPN	FTWO+2			;   same for name2
	MOVEM	B,FTWO+2
	SKIPL	FONE			; if no FONE, gobble OPNFIL
	JRST	FILGET
	MOVE	0,[OPNFIL,,FONE]	; if nothing in FONE, then get from OPNFIL 
	BLT	0,FONE+3
	JRST	FILOPN
FILGET:	MOVE	0,[SCHBLK,,FONE]	; if something in FONE, get from SCHBLK
	BLT	0,FONE+3
FILOPN:	SKIPGE	BUF			; BUF is saved FTWO
	JRST	FBKUP			; jump if no FTWO
	MOVE	A,[FTWO,,OUTDEV]	; update DEV:USR; of OUTDEV
	MOVNI	B,2
	PUSHJ	P,SPECUD
	JRST	FSTART
FBKUP:	MOVE	0,[FONE,,FTWO]		; here for no FTWO
	BLT	0,FTWO+3
	MOVE	A,[OUTDEV,,FTWO]	; update FTWO with OUTDEV
	MOVNI	B,2
	PUSHJ	P,SPECUD
FSTART:	PUSHJ	P,LPTCHK		; sets flag if copied to TPL: ?
	PUSHJ	P,NWFTWO		; create new FTWO
	SKIPE	FONE+3			; if no FTWO SNAME, use RSYSNM
	JRST	.+3			; else use new one
	.SUSET	[.SSNAM,,RSYSNM]
	JRST	.+2
	.SUSET	[.SSNAM,,FONE+3]	; New sname always gets priority
	HRLI	A,3			; ==> open in BLK IMAGE OUTPUT
	HLLM	A,FTWO
	MOVEI	A,2			; ==> open in BLK IMAGE INPUT
	HRLM	A,FONE
	MOVEI	A,FONE
	MOVEM	A,OPNLOC
	CALLSR	OPEN			; open for input
	JRST	FCERR			;   open failed, so error
	MOVEM	A,ICS			; remember channel open on
	SKIPE	OUTDEV			; if no backup DEV:
	JRST	.+3
	SKIPN	BSYSNM			; and USR; then error
	JRST	NOBKUP
	.SUSET	[.SSNAM,,BSYSNM]	; else set to backup SNAME
	SKIPN	SAFETY			; are we in a SAFE mode?
	JRST	FSTAR2			;   if not, barge ahead
	MOVEI	A,FTWO
	PUSHJ	P,FILEX			;   if so, then does backup file exist ?
	JRST	FSTAR2			; if not, go on
	OASC	[ASCIZ /COPY TO /]
	FNTYPE	FTWO
	OASCR	[ASCIZ /File already exists on backup./]
	OASC	[ASCIZ /Delete it?/]
	PUSHJ	P,DECIDE			; if does, user must decide
	JRST	FCLOOP				; if answer no, then go loop
FSTAR2:	SKIPL	LPTFLG				; if yes, are we copying to TPL:
	JRST	NOLPT1
	.FDELE	FTWO				; if we are, delete backup name
	JFCL
	MOVEI	A,FTWO				;   and set up call to OPEN
	JRST	OPNCPY
NOLPT1:	MOVE	A,FTWO				; here if not TPL:
	MOVEM	A,FCTEMP			; delete temp file name 
	SETZM	FCTEMP+3
	.FDELE	FCTEMP				; delete any 'FTWO' in the destination
	JFCL					;   if there isn't one, so wht?
	MOVEI	A,FCTEMP			; set up call to OPEN
OPNCPY:	MOVEM	A,OPNLOC
	CALLSR	OPEN				; open for output
	JRST	FCERR				; if can't, then error
	MOVEM	A,OCS				; save channel open on
GETBUF:	MOVE	A,BUFLTH
	CALLSR	AFREE				; get a buffer for IOTing
	MOVEM	A,BUFPTR			; save it
	MOVEM	A,IOPTR
	MOVN	A,BUFLTH
	HRLM	A,IOPTR				; set up IOT pointer
	SETZ	L,				; number of IOTs
FILCP2:	MOVE	B,IOPTR
	MOVE	A,ICS
	CALLSR	IOT				; input a chunk
	JUMPL	B,FILCP1			; complete block input?
	PUSHJ	P,CHKER				; calculate checksum, set up output
	MOVE	A,OCS
	CALLSR	IOT				; output the block
	AOS	L				; count of IOTs
	JRST	FILCP2				; loop

FILCP1:	SKIPE	A,ICS
	CALLSR	CLOSE				; close input channel
	SETZM	ICS				; record close
	MOVEM	B,M				; remember last IOT ptr
	PUSHJ	P,CHKER				; checksum last block
	MOVE	A,OCS
	CALLSR	IOT				; output it
	CALLSR	CLOSE				; close output channel
	SETZM	OCS				; record close
	OASC	[ASCIZ /-/]
	FNTYPE	FONE				; type file name
	MOVE	A,BUFLTH
	MOVE	B,BUFPTR
	CALLSR	AFRET				; return buffer
	SKIPE	LPTFLG				; TPL files are not checksummed!
	JRST	FCLOOP				; so they simply loop
	PUSHJ	P,CHKFIL			; else do checksum
	JRST	FCLOOP				; no skip ==> couldn't checksum
	JRST	CHKSER				;   skip ==> checksums different
	SETZM	CHKSUM				;   two skips ==> checksums match
	.SUSET	[.SSNAM,,BSYSNM]		; set to backup name
	SKIPE	LPTFLG				; maybe TPL: files cks someday?
	JRST	FCLOOP
	SETZM	FTWO+3
	.FDELE	FTWO				; delete any new name file
	JFCL
	PUSH	P,FCTEMP+3			; save as will be munged in rename
	MOVE	A,FTWO+1
	MOVEM	A,FCTEMP+3
	MOVE	A,FTWO+2
	MOVEM	A,FCTEMP+4			; set up a .RENAME block
	SKIPN	FCTEMP+3			; better not be a .DELETE block !
	.VALUE	GROLOS
	.FDELE	FCTEMP				; rename temp to real backup name
	.VALUE	GROLOS				; better work, too!
	POP	P,FCTEMP+3			; restore temp location
FCLOOP:	SKIPE	ODIR				; if in another dir, simply return
	JRST	GETCOM
	UNSTAK	20,FONE				; else restore arguments
	POP	P,B				; and parse of first argument
	POP	P,A
	JRST	FILCP0				; and then loop

FILX1:	SKIPE	ODIR
	JRST	FILCPX
	UNSTAK	20,FONE				; here for exit at end. restore
	POP	P,B
	POP	P,A
FILCPX:	.SUSET	[.SSNAM,,RSYSNM]		; set SNAME to real SNAME
	SETZM	CHKSUM
	MOVE	A,CMDSAV			; check to see if we were a SAVE
	CAME	A,[SIXBIT /S/]
	CAMN	A,[SIXBIT /SAVE/]
	JRST	DELETE				; if we were, then we delete this cruft, too
	SKIPN	PFFLAG
	JRST	GETCOM
	JRST	NXTFL1				; if weren't, then simply go to next file

FCERR:	OASCR	[ASCIZ //]				; here if opens during copy fail
	OASC	[ASCIZ /OPEN OF /]
	PUSHJ	P,ERROR
	JRST	FILX1

;-------------------------------------------
; CHKSUM ERRORS
;-------------------------------------------

CHKSER:	SETZM	CHKSUM				; here if checksum error found
	OASCR	[ASCIZ //]
	OASCR	[ASCIZ /CHECKSUM ERROR IN COPY./]
	OASC	[ASCIZ /TRY AGAIN?/]
	PUSHJ	P,DECIDE			; user may try again if he wishes
	JRST	.+2
	JRST	FSTART				; if yes, can simply loop
	PUSH	P,FCTEMP+3
	SETZM	FCTEMP+3
	.FDELE	FCTEMP				; if no, delete output
	JFCL
	POP	P,FCTEMP+3
	JRST	FCLOOP				; and simply loop

;--------------------------------------------
; COPYING TO TPL: OR DSK:.LPTR.;
;--------------------------------------------

LPTCHK:	PUSH	P,A
	HRRZ	A,FTWO
	CAMN	A,[SIXBIT/   TPL/]		; is device TPL ?
	JRST	LPTWIN
	CAME	A,[SIXBIT/   DSK/]
	JRST	LPTLOS
	MOVE	A,BSYSNM
	CAME	A,[SIXBIT/.LPTR./]		; or are we copying to DSK:.LPTR.;
	JRST	LPTLOS
LPTWIN:	SETOM	LPTFLG				; if we are, set flag
	JRST	LPTXIT
LPTLOS:	SETZM	LPTFLG				; if we aren't, clear flag
LPTXIT:	POP	P,A
	POPJ	P,				; return
;------------------------------------------
; CHKSUM CALCULATOR
;------------------------------------------

CHKER:	PUSH	P,A
	HLRE	A,B
	MOVNS	A
	SUB	A,BUFLTH
	MOVSS	A
	HRR	A,IOPTR			; create cptr to buffer
	MOVE	B,A
	PUSH	P,B
	MOVE	A,CHKSUM
	ADD	A,(B)			; add value of each word to chksum
	AOBJN	B,.-1
	MOVEM	A,CHKSUM		; new chksum
	POP	P,B
	POP	P,A
	POPJ	P,			; return

;------------------------------------------
; CHKSUM A WHOLE FILE
;------------------------------------------
; NO SKIP -- COULDN'T CHECKSUM
; ONE SKIP -- CHECKSUMS DON'T MATCH
; TWO SKIPS -- WON TOTALLY
;------------------------------------------

CHKFIL:	.SUSET	[.SSNAM,,BSYSNM]	; set to its SNAME
	SKIPN	LPTFLG			; if TPL: must do real second name
	JRST	CNOLPT
	HLR	A,FONE
	HLRM	A,FTWO
	MOVEI	A,FTWO			; set up for OPEN
	JRST	CHKCPY
CNOLPT:	HLR	A,FONE			; not TPL: ==> temp file name
	HRLM	A,FCTEMP
	MOVEI	A,FCTEMP		; set up for OPEN
CHKCPY:	MOVEM	A,OPNLOC
	CALLSR	OPEN			; open
	JRST	CHKWHY			; if failed, find out why
	MOVEM	A,ICS			; save channel
	MOVE	A,BUFLTH
	CALLSR	AFREE			; get a buffer to IOT with
	MOVEM	A,BUFPTR
	MOVEM	A,IOPTR
	MOVN	A,BUFLTH
	HRLM	A,IOPTR
	PUSH	P,CHKSUM		; save old checksum
	SETZM	CHKSUM
FILCHK:	MOVE	B,IOPTR
	MOVE	A,ICS
	CALLSR	IOT			; IOT loop as above
	JUMPE	L,FILCK1		; use L to say how many IOTs
	PUSHJ	P,CHKER
	SOJGE	L,FILCHK
FILCK1:	MOVE	B,M			; last IOT, using saved pointer
	PUSHJ	P,CHKER
	SKIPE	A,ICS
	CALLSR	CLOSE			; close channel
	MOVE	A,BUFLTH
	MOVE	B,BUFPTR
	CALLSR	AFRET			; return buffer
	POP	P,A			; recover old checksum
	EXCH	A,CHKSUM		; are old and new same?
	CAMN	A,CHKSUM
	AOS	(P)			; if are, two skips
	AOS	(P)			; not, one skip
	POPJ	P,
;-------------------------------------------
; CHKWHY -- OPEN FAILED FOR WRONG DIRECTION?
;-------------------------------------------

CHKWHY:	.STATUS	A,B
	HLRS	B
	ANDI	B,77
	CAIE	B,2
	JRST	NWRDIR				; open lost normally, so say so
	OASC	[ASCIZ /Can't checksum /]		; open lost because of direction
	HRL	A,FCTEMP
	OSIX	A
	OASCR	[ASCIZ /./]
	JRST	WHYX
NWRDIR:	OASCR	[ASCIZ /Open for checksum failed! Command execution aborted./]
WHYX:	POPJ	P,				; no skip return from CHKFIL

;------------------------------------------
; FILEX -- FILE EXISTS?
;------------------------------------------

FILEX:	PUSH	P,(A)
	PUSH	P,A
	PUSH	P,B
	HRRI	B,0
	HRLM	B,(A)
	MOVEM	A,OPNLOC
	CALLSR	OPEN				; open file in ASC UNIT INPUT
	JRST	FILEXX
	CALLSR	CLOSE
	AOS	-3(P)				; file exists, so skip
FILEXX:	POP	P,B				; file doesn't exist
	POP	P,A
	POP	P,(A)
	POPJ	P,
;------------------------------------------
; Q -- SIMPLE QUIT COMMAND
;------------------------------------------

CTLQ:	.SUSET	[.RUNAM,,A]
	.SUSET	[.SSNAM,,A]
	SETOM	FONE
	MOVEI	A,FONE
IFN CARESW,[
	MOVE	B,ARCBF
	SKIPE	B
	CALLSR	ARCA
	SETZM	ARCBF
	MOVEI	A,30.
	MOVE	B,RDFLIM
	CALLSR	AFRET
	UNSTAK	4,FTWO
	UNSTAK	4,FONE
	PUSHJ	P,INIT
	RSTACS
	RETURN
]
IFE CARESW,[	.VALUE	[ASCIZ/:KILL
/]
	JRST	GETCOM			; if by some mischance cont., we win
]

;-----------------------------------------
; INITIALIZE STATIC IMPURE VARS
;-----------------------------------------

IFN CARESW,[
INIT:	MOVE	A,[SIXBIT /   DSK/]
	MOVEM	A,INDEV
	MOVEM	A,OUTDEV
	MOVEM	A,LISDEV
	ZBLK	5,ARCFIL		; zero achive block
	ZBLK	26,FONE			; zero default blocks
	ZBLK	20,SCHBLK		; zero search blocks
	ZBLK	6,ICS			; zero out channels
	ZBLK	5,DPTSAV		; zero dir info
	SETOM	ODIR
IMPAR==ITRATE-TTYFLG
	ZBLK	IMPAR,TTYFLG
	SETOM	SAFETY
	SETOM	CLCSAV
	SETOM	ITRATE
	MOVEI	A,20
	MOVEM	A,LINTYP
	POPJ	P,
]

;-----------------------------------------
; TR -- COMPLEMENT DIRECTION OF TRAVEL
;-----------------------------------------

TRAVEL:	SETCMM	UPFLG			; complement travel flag
	JRST	GETCOM
;--------------------------------------------
; ERROR MESSAGES
;--------------------------------------------

NONNAM:	OASCR	[ASCIZ //]
	OASCR	[ASCIZ /NO NEW NAME SPECIFIED!/]
	OASCR	[ASCIZ //]
	JRST	GETCOM

BADDEV:	OASCR	[ASCIZ //]
	OASCR	[ASCIZ /LOSING DEV/]
	OASCR	[ASCIZ //]
	SETOM	ODIR
	JRST	GETCOM

BADNUM:	OASCR	[ASCIZ //]
	OASCR	[ASCIZ /ARG NOT A NUMBER/]
	OASCR	[ASCIZ //]
	JRST	GETCOM

NOPEN1:	OASCR	[ASCIZ //]
	OASC	[ASCIZ /OPEN OF /]
	PUSHJ	P,ERROR
	OASCR	[ASCIZ //]
	JRST	GETCOM

NODEL:	OASCR	[ASCIZ //]
	OASC	[ASCIZ /DELETE OF /]
	PUSHJ	P,ERROR
	OASCR	[ASCIZ //]
	JRST	GETCOM

NOBKUP:	OASCR	[ASCIZ //]
	OASCR	[ASCIZ /NO BACKUP DEV!/]
	OASCR	[ASCIZ //]
	JRST	GETCOM

;----------------------------------------
; ERROR MESSAGE FOR ERRORS THAT SHOULD
;   NEVER OCCUR.
;----------------------------------------

GROLOS:	ASCIZ /:Internal_error_in_DIRED!/

ERROR:	PUSH	P,A
	MOVE	A,OPNLOC
	PUSHJ	P,PRNTSP
	PUSHJ	P,PRNTNM
	OASCR	[ASCIZ / FAILED!/]
	POP	P,A
	POPJ	P,
;----------------------------------------------
; current active dir (source dir)
;----------------------------------------------

INDEV:	SIXBIT /   DSK/
	SIXBIT /.FILE.(DIR) /
RSYSNM:	0

;----------------------------------------------
; current backup dir
;----------------------------------------------

OUTDEV:	SIXBIT /   DSK/
	SIXBIT /.FILE.(DIR) /
BSYSNM:	0

;----------------------------------------------
; current listing dir
;----------------------------------------------

LISDEV:	SIXBIT /   DSK/
	SIXBIT /.FILE.(DIR)/
LSYSNM:	0

;-------------------------------------------
; archiver cruft
;-------------------------------------------

IFN CARESW,[
ARCFIL:	BLOCK	4
ARCBF:	0
]

;-------------------------------------------
; arguments to commands
;-------------------------------------------

FONE:	BLOCK 4					; first argument
MASK:	BLOCK 4					; first argument masks

FTWO:	BLOCK 4					; second argument
MASK2:	BLOCK 4					; second argument masks

;-------------------------------------------
; current point file
;-------------------------------------------

OPNFIL:	BLOCK 6

;-------------------------------------------
; temporary name for copying to
;-------------------------------------------

FCTEMP:	SIXBIT /      _COPY_OUTPUT/
FCTNAM: 0

;-------------------------------------------
; pointers to COMMAND LIST and MESSAGE files
;-------------------------------------------

MESFIL:	SIXBIT /   DSKDIRED RECENT/
MESSNM:	SIXBIT /.INFO./

CMDFIL:	SIXBIT /   DSKDIRED ORDER/
COMSNM:	SIXBIT /.INFO./
;--------------------------------------------
; directory information
;-------------------------------------------

DPTSAV:	0	; saved cptr to dir vector
DIRSAV:	0
DIRPTR:	0	; ptr to entry in vector we are interested in now

DIRTOP:	0	; ptr to top entry in vector
DIREND:	0	; ptr to last entry in vector

ODIR:	-1	; =0 => dir in core. -1 => no dir or (in SEARCH) not source dir

;-------------------------------------------
; global information
;-------------------------------------------

SCRSIZ==35.	; number of lines to print before interupting
ERSFLG:	0
TTYFLG:	-1	; typeout stop flag, -1 for new tty code.
SAFETY:	-1	; safety level: -1 = SAFE, 1 = SAFE!, 0 = SORRY

IFN CARESW,RDFLIM:	0	; loc of impure area for rdflnm

LINSAV:	0	; most recent line count for typeout
LINSV1:	0	; most recent -1 " " "
LINTYP:	20	; current typeout default
LINCNT:	0	; current number of lines typed (during actual typeout)

XFILF:	0	; are we currently XFILEing ?
LPTFLG:	0	; is current output to TPL: ?

UPFLG:	0	; direction of travel, 0 = down, -1 = up
TYPOUT:	0	; automatic typeout. 0 = off, -1 = on

OPNLOC:	0
CMDSAV:	0	; most recent command typed
CLCSAV:	-1	; location of most recent command
NUMSAV:	0	; temp save for iteration count
ITRATE:	-1	; iteration count

;------------------------------------------
; channel numbers
;------------------------------------------

ICS:	0	; input channel
OCS:	0	; output channel
CCS:	0	; command channel
LSS:	0	; listing channel
TCS:	0	; temporary channel
XCS:	0	; xfile channel

;------------------------------------------
; temp locations used during searching
;------------------------------------------

SCHBLK:	BLOCK	6		; arguments are parsed into here

RCHLOC:	BLOCK	6	; used for finding real name of a > or <
SRCHSV:	BLOCK	2	; last > or < saved here
LESFLG:	0		; is the > or < a > ?, -1 = yes 
PFFLAG:	0

PAT:	BLOCK	10	; patch area
;--------------------------------------------------
; copy locations
;--------------------------------------------------

BUFPTR:	0		; pointer into copy buffer
IOPTR:	0		; iot pointer for copy
CHKSUM:	0		; checksum for copy
BUF:	BLOCK	5	; temp copy buffer
BUFLTH:	200		; length of copy buffer

	END	START
`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````