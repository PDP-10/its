
TITLE PFTHMG DRAGON
SWRQ==1	;REQUEST TYPEIN OF SWITCHES (OR "NO")
IF1,.INSRT JSF;DSK:STNDRD MACROS
IFNDEF TUTBYT,.INSRT SYSENG;DSK:FSDEFS >

	;AC DEFINITIONS

A=1	;A THROUGH E SAME AS IN SYSTEM
B=2
C=3
D=4
E=5
SYSTT==6	;SYSTEM'S TT
F=6
G=7	;USED BY TSINT FOR INTERRUPT MASK
Q=10	;SAME AS IN SYS
T=11
TT=12
P=15	;SAME AS IN SYS
ST=16	;SYSTEM'S T
U=17	;SAME AS IN SYS

DSKCH==0
TTYOCH==1
UTYIC==3	;IO CHANNEL FOR INPUT
UTYOC==4	;IO CHANNEL FOR OUTPUT
CLIC==7		;CLI CHANNEL, USED TO SIGNAL ATTACHERS WHEN DISOWNED (IF CLISW .NE. 0)

IFNDEF CLISW,CLISW==0	;NON-ZERO TO WARN ATTACHERS OF DISOWNED JOB (FOR DEBUGGING)

IFNDEF DDPTR,DDPTR==774000-2	;AOBJN POINTER TO SYSTEM DDT'S SYMBOL TABLE FOR SYSTEM
IFNDEF LGNM,LGNM==SIXBIT /PFTHMG/	;LOGIN NAME
IFNDEF DFSNAM,DFSNAM==SIXBIT /DRAGON/	;DEFAULT SYSTEM NAME (IF TOP LEVEL)(ALSO JOB NAME)
IFNDEF FMT,FMT==3	;ASCENDING FORMAT NUMBER, SHOULD BE INCREMENTED
		;WHENEVER ZUSERS FILE FORMAT CHANGES OTHER THAN SIMPLE APPEND
		;TO END
IFNDEF DMNSZ,DMNSZ==15.	;MAX # ENTRIES IN (LOCAL) DMNBF
IFNDEF DMNRM,DMNRM==10.	;NUMBER OF SPARE ENTRIES IN DMNBF
IFNDEF SPLIT,SPLIT==1	;NON-ZERO TO SEPARATE LOW CODE FROM HIGH CODE
IFNDEF SYPDMP,SYPDMP==0	;NON-ZERO TO USE SYSTEM'S PDUMP TO DUMP SELF AT QUIT
IFNDEF NTRIES,NTRIES==5	;# TIMES TO TRY RELOADING RATHER THAN LOGGING OUT
IFNDEF LPDL,LPDL==100	;BIG PDL FOR GROSS AC SAVES AND RECURSIVE INTERRUPT ROUTINE


;THIS PROGRAM LIKES TO HACK THE FOLLOWING FILES, SO BE CAREFUL WHEN DEBUGGING:
;ZUSERS >, >-1, >-2
;DRDMP FILES GET RENAMED DRDOMP IF SYSTEM NEW; ON QUIT, PROG DUMPS SELF OUT AS DRDMP >
;IT MAY ALSO EVENTUALLY DELETE OLD DRDOMP FILES

		;MEMORY ORGANIZATION

;ONE BLOCK IN LOW CORE (.LT. 400000), USUALLY ONLY ONE THAT NEED BE IN CORE
	;MUST BE BLOCK ZERO
	;END OF PERMANENT LOW CODING AT LICOD-1
	;THEN SOME STORAGE ALLOCATED AT EXECUTION TIME
		;EDLCOD CONTAINS ADR OF FIRST WORD NOT ALLOCATED
	;ALLOCATED AREA INITIALLY OCCUPIED BY INITIALIZATION CODING INTIL ELICOD
		;CLEARED OUT AT ICLR
;HIGH CODE, AN ARBITRARY NUMBER OF BLOCKS
	;BEGINS AT LOCATION HIBEG, BUT ASSEMBLED INTO LOW CORE WITH OFFSET
		;SO NEED NOT GOBBLE GROSS AMOUNTS DURING INITIAL LOAD
	;CODING UNTIL LOCATION ICOD FIRST WIPED OUT DURING INITIALIZATION
		;AND ALLOCATED FOR STORAGE
	;INITIALIZATION CODING ENDS AT EICOD-1
	;EDNCOD HAS ADR FIRST AFTER LAST ALLOCATED

TMPLOC 42,JSR INTPRQ	;INTERRUPT HANDLER

IFNDEF SYSLOR,SYSLOR==SIGN	;VIRTUAL ADR OF SYSTEM'S PAGE 0
IFNDEF UFD,UFD==SYSLOR+2000	;UFD BLOCK, ALLOCATED AS NEEDED (SEE GETUFD, FLSUFD)
IFNDEF PDMBLK,PDMBLK==UFD+2000	;(FLUSH THIS IF SYPDMP SET TO 0 PERMANENTLY)
IFNDEF HIBEG,HIBEG==PDMBLK+2000	;ADR OF BEGINNING OF HIGH CODING

	;HAS VALUE OF ITS SYM OF SAME NAME
	;USE ONLY AS RIGHT HALF OF STORAGE WORD
	;DON'T USE IN CONSTANTS EITHER
	;SHOULD BE LAST CODING (EXCEPT COMMENT) IN THE LINE,
		;SO BEWARE OF INDEX REGISTERS!
	;IF NAME IS THE REQUESTED SYM, DEFINES NAME%; TRY TO AVOID CONFLICTS

DEFINE S NAM
IRPS %%NM,,[NAM]
IFDEF %%NM!%,%%NM!%
IFNDEF %%NM!%,SNMDF %%NM
%%NM!%==.-1
.ISTOP
TERMIN
TERMIN

	;AUXILIARY MACROS FOR S MACRO

	;FOLLOWING MACRO ACCUMULATES SYMBOL REQUESTS

DEFINE SMTBM A
A
TERMIN

	;FOLLOWING MACRO REDEFINES SMTBM, ADDS REQUEST FOR ANOTHER SYMBOL

DEFINE SNMDF SYM

SMTBM [DEFINE SMTBM %%A
%%A]SQUOZE 4,SYM
SETZ SYM!%
EXPUNGE SYM!%
TERMIN
TERMIN

SYSGWS==2	;NUMBER OF WORDS PER SYSST ENTRY (DUMPED OUT BY SMM MACRO)

	;THE ABOVE MACROS SET UP LISTS THROUGH RIGHT HALVES OF
	;STORAGE WORDS (BUT NOT CONSTANTS!) INTO WHICH SYM IS TO BE INSERTED

		;FOLLOWING MACRO FOR SYMS TO BE DEFINED LOCALLY
		;RESTRICTIONS SIMILAR TO S

IF1,LSYCT==0		;COUNT OF # LS SYMS
LSYCU==0		;ANOTHER COUNT, SHOULD BE 0 AT END OF ASSEMBLY

DEFINE LS NAM
IRPS %%NM,,[NAM]
IFDEF %%NM,%%NM
IFNDEF %%NM,[
IF1,LSYCT==LSYCT+1
LSYCU==LSYCU+1
SLLOR %%NM
]%%NM==.-1
.ISTOP
TERMIN
TERMIN

		;DEFINE LS SYM "NAM" AS VALUE IN A, GENERATES 2 STORAGE WORDS, CLOBBERS T,TT

DEFINE DEFSYM NAM
	JSP T,DFSLST
	SETZ NAM
	EXPUNGE NAM
LSYCU==LSYCU-1
TERMIN

DEFINE SLLOS A
A
TERMIN

DEFINE SLLOR NAM
SLLOS [DEFINE SLLOS %%A
%%A]SLLOP NAM
TERMIN
TERMIN

DEFINE SLLOP NAM
IFDEF NAM,PRINTA NAM NEEDED AT ,\NAM,
TERMIN

	;I HAVE IBM DISEASE
	;FOLLOWING MACRO SAVES LOAC THROUGH HIGHAC INCLUSIVE ON PDL
	;P MAY BE AMONG THOSE SAVED, BUT MUST BE NEITHER LOWAC NOR HIGHAC
	;CLOBBERS LOWAC

DEFINE SAVE LOWAC,HIGHAC
	PUSH P,<LOWAC>
	MOVSI <LOWAC>,<LOWAC>+1
	HRRI <LOWAC>,1(P)
	ADD P,[<HIGHAC>-<LOWAC>,,<HIGHAC>-<LOWAC>]
	SKIPL P
	JSR QUIT	;PDL OV
	BLT <LOWAC>,(P)
TERMIN

		;UNDO A SAVE (THIS IS WHY HIGHAC SHOULD NOT BE P)

DEFINE RESTOR LOWAC,HIGHAC
	MOVSI <HIGHAC>,-<<HIGHAC>-<LOWAC>>(P)
	HRRI <HIGHAC>,<LOWAC>
	BLT <HIGHAC>,<HIGHAC>
	SUB P,[<HIGHAC>-<LOWAC>+1,,<HIGHAC>-<LOWAC>+1]
TERMIN

		;ASSEMBLE INTO LOW BLOCK

CKPAR==0	;0 => LOW, 1 => HIGH
HI.LC==2000	;HIGH LOCATION COUNTER

DEFINE LBLK
IFE CKPAR,PRINTA LOSSAGE AT LBLK = ,\.
CKPAR==0
OFFSET 0
HI.LC==.
LOC LO.LC
TERMIN

		;ASSEMBLE INTO HIGH BLOCK
		;HBLK CONSIDERED NORMAL MODE, LBLK CODING SHOULD BE BRACKETED BY MACROS

DEFINE HBLK
IFN CKPAR,PRINTA LOSSAGE AT HBLK = ,\.
CKPAR==1
LO.LC==.
LOC HI.LC
OFFSET HIBEG-2000
TERMIN

LOC 340		;SKIP OVER SYSTEM PATCH AREA, MAY BE CALLING PATCHED ROUTINES IN SYSTEM
ESYSP::	;END OF SYSTEM PATCH AREA BLTED INTO
.AOP .OPER@ <SQUOZE 0,CLKBRK>,.EVAL
IFN .-.AVAL1,PRINTA INITIAL LOW LOCATION OF ,\., MAY DISAGREE WITH SYSTEM'S CLKBRK.
HBLK		;HBLK CONSIDERED NORMAL MODE

		;INTERRUPT BITS IN PIRQC

BILLOP==40	;ILLEGAL OPERATION
BIOCER==400	;IO CHANNEL ERROR
BMPV==20000	;MEMORY PROTECTION VIOLATION
BPDLOV==200000	;PDL OVERFLOW
BWIRO==200,,	;ATTEMPTED WRITE INTO READ ONLY

		;BITS NOT CONSIDERED BAD

BSYSDN==100	;SYSTEM GOING DOWN OR REVIVED
BSCLK==10000	;SLOW CLOCK BREAK
BCLI==400000	;CORE LINK INTERRUPT
BREALT==200000,,	;SYSTEM HAS TIMED OUT .REALT

BADBTS:	BWIRO\BPDLOV\BMPV\BIOCER\BILLOP	;INTERRUPT MASK FOR BAD BITS

		;JSP Q,BADPSH	;SET UP DISMISS ON NORMALLY BAD INTERRUPT
		 ;INTERRUPT MASK
		 ;DISMISS PC,,PC TO COMPARE TSINT WITH; OR 0,,PC TO GO TO AT INTERRUPT LEVEL
		;RETURNS TO HERE

BADPSH:	MOVE F,[2,,2]
	ADDB F,BADP1E	;UPDATE "FIRST EMPTY" POINTER
	SUB F,[2,,2]	;BACK UP FOR ACTUAL PUSH'ES
	PUSH F,(Q)	;INTERRUPT BIT(S)
	PUSH F,1(Q)	;DISMISS ADR,,COMPARISON PC
	MOVEM F,BADPNF	;STORE POINTER TO FIRST NOT FULL
	JRST 2(Q)	;ON RETURN, F POINTS TO PC WORD, WHICH MAY BE REFERENCED ON PDL

BADPJ1:	AOS (P)		;LIKE BADPOP BUT DOES POPJ1
BADPOP:	MOVN F,[2,,2]	;PUSHJ P,BADPOP UNDO BADPSH
	ADDB F,BADPNF
	MOVEM F,BADP1E
	POPJ P,

		;JSP Q,SPJSET	;SET UP FOR PUSHJ INTO SYSTEM
		;A SHOULD HAVE ADR TO DISMISS TO ON BAD BREAK

SPJSET:	PUSH P,SPJSVP	;SAVE LAST
	MOVEM P,SPJSVP'	;STORE P IN CASE GETS CLOBBERED
	PUSH P,Q	;SAVE RETURN POINT ON PDL FOR POPJ OUT
	HRLM A,.+3	;STORE DISMISS POINT
	JSP Q,BADPSH
	 0		;0 TO MATCH EVERYTHING, CAUSE DISPATCH TO "COMPARISON PC" AT INTERRUPT LEVEL
	 SPJSTI		;(LH SET TO DISMISS PC)
	MOVE A,[SYSLOR+20,,20]	;NOW TO BLT IN SYSTEM PATCH AREA
	BLT A,37	;BLT IN 20 THROUGH 37, SOMETIMES USED AS PATCH AREA
	MOVE A,[SYSLOR+50,,50]
	BLT A,ESYSP-1	;BLT IN REST OF PATCH AREA
	POPJ P,

		;UNDO AN SPJSET, CALLED W/ JSP Q,

SPJCLR:	POP P,SPJSVP
	PUSH P,Q	;SAVE RETURN POINT FOR RETURN FROM BADPOP
	JRST BADPOP

		;VARIABLE AREA FOR DISMISSING FROM BADBRK

IFNDEF LBDPDL,LBDPDL==2*6	;LENGTH OF BADPDL, 2 IS LENGTH PER ENTRY

BADPLA:	-LBDPDL,,BADPDL-1	;POINTER TO LOWEST ACTIVE
BADPNF:	-LBDPDL,,BADPDL-1	;POINTER TO FIRST NOT FULL
BADP1E:	-LBDPDL,,BADPDL-1	;POINTER TO FIRST EMPTY

BADPDL:	0		;INITIAL MASK ZERO => TAKE ERROR
	BLOCK LBDPDL+1	;PDL AND ONE EXTRA WORD SLOT FOR PCS FOR FIRST ENTRY

BADACS:	BLOCK D-A+1	;AC STORAGE DURING BADBRK, IN CASE P CLOBBERED

BADBRK:	REPEAT D-A+1,MOVEM A+.RPCNT,BADACS+.RPCNT	;STORE ACS
	HRRZ A,TSINT	;GET STORED PC
	MOVE B,BADPNF
BADBK1:	CAMN B,BADPLA
	JSR QUIT	;BADPDL EXHAUSTED WITHOUT FINDING MATCHING ENTRY, QUIT NOW
	POP B,D		;DISMISS PC,,COMPARISON PC
	POP B,C		;INTERRUPT BITS MASKED
	JUMPE C,(D)	;JUMP NOW ON COMPARISON PIRQC 0
	CAIN A,1(D)	;COMPARE WITH PC'S, OFFSET OF 1 SINCE THAT STORED NEEDS SOS TO GUILTY INSTR
	TDZN G,C	;CHECK FOR THESE BITS ACTIVE
	JRST BADBK1	;PC'S DON'T MATCH, OR NO PIRQC BITS MATCH
	TDNE G,BADBTS
	JSR QUIT	;BITS LEFT OVER
BADBK2:	INSIRP MOVEM B,[BADP1E BADPNF]	;FOUND MATCHING ENTRY, DELETE IT AND ALL ABOVE FROM BADPDL
	HLRM D,TSINT	;STORE DISMISS PC
BADPRC:	MOVE D,[BADACS,,A]	;PROCEDE HERE FROM BAD BREAK WHEN DEBUGGING (AFTER MUNGING VARIABLES)
	BLT D,D
	JRST BDBKRT

		;SPJSET ROUTINE TRANSFERRED TO FROM BADBRK WITH INTERRUPT IN PROGRESS
		;NOTE THAT AT BADBRK, NOTHING HAS BEEN PUSHED

SPJSTI:	MOVE P,SPJSVP	;RESTORE P FROM THAT SAVED
	POP P,SPJSVP	;RESTORE FORMER, THUS EFFECTIVELY DOING AN SPJCLR
	JRST BADBK2	;DELETE ENTRY FROM BADPDL AND RETURN

		;CLOCK QUEUE ROUTINES

IFNDEF CKQSIZ,CKQSIZ==5	;MAXIMUM NUMBER OF CLOCK QUEUE ENTRIES
LBLK	;PUT ACTUAL CLOCK QUEUE TABLE IN LOW CORE

CKQBUF:	REPEAT CKQSIZ+1,[SETZ-1
	CKQQT
]
CKQBFL==.-CKQBUF	;BUFFER LENGTH (INCLUDING TOP ENTRY)
HBLK

CKQQT:	JSR QUIT	;DUMMY CLOCK QUEUE ENTRY GOT RUN

		;ROUTINE (WITH VARIOUS ENTRIES) TO ADD AN ENTRY TO CLOCK QUEUE
		;A HAS TIME FOR BREAK (ENTRY DEPENDENT), B DISPATCH, ADR OF ROUTINE
		;CLOBBERS U TO USER, DOESN'T TOUCH ANYTHING ELSE

CKQADI:	.SUSET INTOFF	;ENTRY FOR INTERRUPTS INITIALLY ENABLED, DISABLE THEM
		;(WILL RETURN WITH THEM STILL OFF)
CKQADD:	IMULI A,30.	;NORMAL ENTRY, FOR TIME IN SECONDS TILL BREAK
CKQA3D:	ADD A,S TIME	;ENTRY FOR TIME IN THIRTIETHS
CKQADR:	MOVE U,S USER	;ENTRY FOR TIME IS .RDTIME OF BREAK
	SKIPE (U)S PICLR	;THIS ROUTINE SHOULD BE CALLED ONLY WITH INTERRUPTS DISABLED
	JSR QUIT	;CKQADD (OR SOME VARIATION THEREOF OTHER THAN CKQADI) GOT
		;CALLED WITH INTERRUPTS ENABLED
	PUSH P,T
	MOVSI T,-CKQBFL+2
CKQAD1:	CAMG A,CKQBUF(T)
	JRST CKQAD2	;FOUND SLOT
	AOBJN T,.+2
	JSR QUIT	;TABLE ODD NUMBER OF WORDS LONG?
	AOBJN T,CKQAD1
	JSR QUIT	;TRYING TO ADD TO FULL TABLE

		;FOUND PROPER PLACE FOR ENTRY ON CLOCK QUEUE, PUT IT THERE

CKQAD2:	AOSL CKQBUF+CKQBFL-4	;IN ORDER FOR THERE TO BE ROOM FOR ENTRY, HIGHEST REAL ENTRY MUST BE DUMMY
	JSR QUIT	;IT ISN'T
	SOSG CKQBUF+CKQBFL-4
	JSR QUIT	;????
	TRZ T,-1
	MOVNS T		;T := # ENTRIES LEFT (NOT INCLUDING TOP)
	ADD T,[SIGN-3,,CKQBUF+CKQBFL-5]
	JUMPGE T,.+3	;JUMP IF NEW ENTRY TO BE AT END (LATEST ENTRY) OF LIST
	POP T,2(T)
	JUMPL T,.-1	;REVERSE BLT UPPER ENTRIES UP TO MAKE ROOM FOR THIS ONE
	MOVEM A,1(T)	;STORE TIME
	MOVEM B,2(T)	;STORE DISPATCH
	POP P,T
	POPJ P,

		;B HAS DISPATCH WORD, FIND IT ON CLOCK QUEUE, SKIP IF FOUND
		;IF FOUND, RH(C) POINTS TO ENTRY

CKQFND:	MOVE C,[-CKQBFL-2,,CKQBUF]
CKQFN2:	CAMN B,1(C)
	JRST POPJ1	;THIS IS THE ENTRY
	AOBJN C,.+2	;NOT THIS ONE, TRY NEXT
	JSR QUIT	;OOPS! TABLE OF ODD LENGTH???
	AOBJN C,CKQFN2
	POPJ P,		;NOT FOUND

		;RH(C) POINTS TO ENTRY ON CLOCK QUEUE, DELETE ENTRY

CKQDEL:	MOVE U,S USER	;CLOBBER U TO USER, ABOUT TO HELP DEBUG
	SKIPE (U)S PICLR
	JSR QUIT	;CKQDEL SHOULD BE CALLED ONLY WITH INTERRUPTS OFF
	AOSG (C)
	JSR QUIT	;ENTRY BEING DELETED WAS NEGATIVE OR SETZ-1
	HRLI C,2(C)
	BLT C,CKQBUF+CKQBFL-3
	POPJ P,

LBLK
		;INTERRUPT ROUTINE
		;SUPERLY COMMON SO SHOULD BE IN LOW BLOCK

TBGCB:	15.*60.		;TIME BETWEEN GROSS CLOCK BREAKS (IN SECONDS)
INTON:	.SPICL,,[-1]	;DO .SUSET INTON TO ENABLE INTERRUPTS
INTOFF:	.SPICL,,[0]	;DO .SUSET INTOFF TO DISABLE INTERRUPTS
IMSK:	BREALT		;INTERRUPT MASK

INTPRQ:	0		;PIRQC STORED HERE
TSINT:	0		;INTERRUPT HANDLER, PC STORED HERE
	CAML P,[-10.,,]
	JSR QUIT	;CALL IT PDL OVERFLOW
	MOVEM G,INTSVG'	;SAVE G (DON'T USE P YET, IT MAY BE CLOBBERED)
	SKIPGE G,INTPRQ	;GET PIRQC
	JSR QUIT	;OTHER WORD
	TDNE G,BADBTS
	JRST BADBRK	;BAD BREAK
BDBKRT:	PUSH P,INTSVG
	PUSH P,A
	MOVE A,S SHUTDN
	MOVEM A,BLK1+3	;STORE TIME TILL SYSTEM DOWN ON EVERY BREAK (MAY AS WELL)
DEADP:	SKIPGE S DEDTIM	;CHECK FOR SYSTEM DOWN NOW (DEADP ONLY PLACE S DEDTIM POINTED TO)
	PUSHJ P,DEATH
	MOVE A,DMNBB
	CAMGE A,S DMNBD
	PUSHJ P,DMNBRK	;SYSTEM WANTS SOME STUFF PROCESSED
IFN CLISW,[DSNTX:	SKIPGE LS UAPRC	;(OR SKIPL) SKIP UNLESS DISOWN STATUS HAS COMPLEMENTED
	PUSHJ P,DSNCMP	;MAYBE SHOW ATTACHER SIGNS OF LIFE
]	MOVE A,CKQBUF
	CAMGE A,S TIME
	JRST CLKBRK	;TAKE CLOCK BREAK
CLKBRT:	POP P,A		;RESTORE A, SAVED BEFORE CHECK FOR SLOW CLOCK BIT
	POP P,G		;RETURN POINT FROM CLOCK BREAK
	.DISMIS TSINT

		;PUSHJ P,XCTINT	;EXECUTE .+1 WITH INTERRUPTS ENABLED

XCTINT:	INSIRP PUSH P,[TSINT BADPLA BADPNF]
		;MAYBE ADD MORE PUSH'S, ESPECIALLY IF UUOS ADDED
XCTINL==.-XCTINT		;# WORDS PUSHED
	EXCH A,BADP1E
	INSIRP MOVEM A,[BADPLA BADPNF]
	EXCH A,BADP1E
	.SUSET INTON	;ENABLE INTERRUPTS
	XCT @-XCTINL(P)	;EXECUTE THE INSTRUCTION, USUALLY A PUSHJ
	JRST .+2	;INSTRUCTION DIDN'T SKIP
	AOS -XCTINL(P)	;SKIPPED, AOS RETURN POINT
	.SUSET INTOFF	;DISABLE INTERRUPTS AGAIN
		;NOW POP BACK THE STUFF PUSHED AT XCTINT
	EXCH A,BADP1E
	CAMN A,BADPNF
	CAME A,BADPLA
	JSR QUIT	;THINGS OVERPUSHED ONTO OR OVERPOPPED FROM BADPDL
	EXCH A,BADP1E
	INSIRP POP P,[BADPNF BADPLA TSINT]
POPJ1:	AOS (P)		;CAUSE RETURN TO SKIP OVER ARG
CPOPJ:	POPJ P,

		;TIME TO RETURN TO CLOCK QUEUE ENTRY

CLKBRK:	SAVE B,17	;SAVE MOST AC'S (A ALREADY PUSHED)
	MOVE B,CKQBUF+1	;GET DISPATCH
	MOVEI C,CKQBUF
	PUSHJ P,CKQDEL	;DELETE ENTRY ABOUT TO DISPATCH ON
	PUSHJ P,XCTINT	;MAY AS WELL CALL IT WITH INTERRUPTS ENABLED
	 PUSHJ P,(B)	;TAKE BREAK, SHOULD RETURN TIME TO NEXT (IN SECS) IN A, DSP IN B
		;OR SKIP => ALREADY TAKEN CARE OF PROPERLY
	PUSHJ P,CKQADD	;RE-ENTER REQUEST
	RESTOR B,17
	JRST CLKBRT

		;RANDOM DATA FOR DMNBRK

DMNBB:	0	;NUMBER OF LOGOUTS HANDLED
DMNBP:	-DMNSZ	;NUMBER OF ENTRIES ACTIVE IN DMNBF - DMNSZ
IFN 0,[		;ALLOCATED AT EXECUTION TIME
DMNBF:	BLOCK DMNSZ*S DMNBEL	;LOGOUTS TAKEN FROM SYSTEM BUT NOT YET OUTPUT
]

		;PROCESS AN ENTRY SUPPLIED BY THE DEMON INTERFACE ROUTINES IN THE SYSTEM (LOGOUT, ETC.)

DMNBRK:	INSIRP PUSH P,[B C D U]	;SAVE APPROPRIATE AC'S
DMNBR1:	AOSGE D,DMNBP	;LOOP POINT FOR MORE ENTRIES TO PROCESS
	JRST DMNBR2	;BUFFER NOT FULL YET
	MOVEI B,CLKBR1	;BUFFER FULL, WANT TO CAUSE CLKBR1 TO BE RUN VERY SOON
	PUSHJ P,CKQFND	;FIND CLKBR1 ENTRY
	JRST DMNBR2	;IN CLKBR1 NOW
	SKIPN (C)
	JRST DMNBR2	;ALREADY SET TO RUN CLKBR1 SOON
	PUSHJ P,CKQDEL	;NOT YET, DELETE ENTRY
	MOVEI A,0
	PUSHJ P,CKQADR	;RE-ENTER ENTRY TO RUN SOON
DMNBR2:	ADDI D,DMNSZ-1	;CONVERT TO NUMBER OF ENTRIES NOW IN BUFFER
	IMULI D,S DMNBEL	;CONVERT TO INDEX INTO DMNBF
	ADDI D,LS DMNBF		;CONVERT TO FIRST LOCATION TO BLT INTO
	MOVEI C,(D)S DMNBEL	;GET LAST LOC TO BLT INTO + 1
			;NOW SET UP LH OF BLT POINTER IN D
	MOVE A,DMNBB		;GET NUMBER OF LOGOUTS HANDLED SO FAR
	IDIVI A,S DMNSZ		;REMAINDER IS ENTRY NUMBER IN S DMNBF
	IMULI B,S DMNBEL	;CONVERT TO INDEX INTO SYSTEM DMNBF
	HRLI D,(B)S DMNBF	;FINISH SETTING UP LH
	BLT D,-1(C)	;BLT IN NEW ENTRY
	AOS A,DMNBB	;ANOTHER LOGOUT HANDLED
	CAMGE A,S DMNBD	;MORE?
	JRST DMNBR1	;YES
PPUDCB:	INSIRP POP P,[U D C B]
	POPJ P,

HBLK

		;SYSTEM DEAD

DEADCT:	5		;COUNT DOWN AT DEATH, WAIT FIVE SECONDS BEFORE FINISHING
DEDF:	-1		;FLAG, 0 => HAVE ALREADY BEEN TO DEATH, 1 => CLKBR1 SHOULD LOG OUT

DEATH:	SOSGE DEADCT
	SKIPL DEDF
	POPJ P,		;HAVEN'T COUNTED DOWN YET, OR ALREADY WORKING ON IT
	INSIRP PUSH P,[B C D U]
	MOVEI B,CLKBR1
	PUSHJ P,CKQFND
	JRST PPUDCB	;IN CLKBR1 NOW, DON'T PLAY NOW, MAY BE PSEUDO-TIMING ERROR
	AOS DEDF	;ENTRY THERE, GRAB SWITCH
	PUSHJ P,CKQDEL	;DELETE ENTRY (WILL RE-ENTER LATER)
	PUSHJ P,XCTINT
	 PUSHJ P,DEATH5	;"LOG OUT" CORE JOB, SYSTEM JOB, SELF
	SOS DMNBP	;DIDN'T MAKE IT
	MOVEI A,0
	MOVEI B,CLKBR1
	PUSHJ P,CKQADR	;ENTER REQUEST FOR CLKBR1 SOON
	AOS DEDF	;MAKE SWITCH POSITIVE, SIGNAL CLKBR1 TO LOG OUT
	JRST PPUDCB

DEATH5:	MOVEI A,CPOPJ
	JSP Q,SPJSET	;NON-SKIP RETURN ON LOSSAGE WHILE IN SYSTEM
	MOVEI U,S L
	PUSHJ P,SYSLGO	;"LOG OUT" CORE JOB
	MOVEI U,0
	PUSHJ P,SYSLGO	;SYSTEM JOB
	MOVEI A,2
	.SLEEP A,
	MOVE U,S USER
	PUSHJ P,SYSLGO	;SELF
	JSP Q,SPJCLR	;SURVIVED, DELETE ENTRY
	JRST POPJ1	;SKIP-RETURN

SYSLGO:	AOS D,DMNBP
	ADDI D,DMNSZ-1
	IMULI D,S DMNBEL
	ADDI D,LS DMNBF
	SOJ D,		;FOR PUSHES
	PUSHJ P,S DMNP0
	JRST S DMNPL0

IFN CLISW,[		;CODING TO WATCH FOR RANDOM ATTACHERS
		;FOR USE WHEN LEAVING DISOWNED DRAGON AROUND FOR DEBUGGING

DSNCMP:	MOVSI A,(SKIPGE#SKIPL)	;HERE FROM TSINT
	XORM A,DSNTX	;CHANGE TEST INSTR TO CHECK FOR RE-COMPLEMENT
	MOVE A,LS UNAME	;GET USER NAME
	SKIPL LS UAPRC	;SKIP IF BECAME DISOWNED
	CAMN A,IUNAM'	;ATTACHED, COMPARE UNAME WITH INITIAL ONE
	POPJ P,		;DISOWNED, OR ATTACHED BY ORIGINAL USER
	EXCH A,CLIOPN+1
	.OPEN CLIC,CLIOPN	;ATTACHED BY SOMEONE ELSE, TRY GIVING HIM MESSAGE
	JRST DSNCM2	;DOESN'T HAVE CLI INTERRUPTS ENABLED
	PUSH P,T
	MOVE T,[-LCLIMS,,CLIMSG]
	.IOT CLIC,T	;GIVE HIM THE MESSAGE
	.CLOSE CLIC,
	POP P,T
DSNCM2:	CAMN A,CLIMSG+1	;ALREADY OUTPUT ZUSERS FILE ABOUT HIM?
	POPJ P,		;YES (OR RATHER PROBABLY, SINCE THERE ARE TIMING ERRORS IN THIS CODING)
	INSIRP PUSH P,[B C D U]	;NO, SAVE STUFF
	MOVE A,CLIMSG+1	;GET NEW UNAME
	MOVEM A,BLK1+7	;STORE IN BLK1 OF ZUSERS FILE
	MOVEI B,CLKBR1
	PUSHJ P,CKQFND
	JRST PPUDCB	;ALREADY IN CLKBR1, HOPE FOR THE BEST
	PUSHJ P,CKQDEL	;ENTRY THERE, DELETE
	MOVEI A,0
	PUSHJ P,CKQADR	;RE-ENTER TO RUN SOON
	JRST PPUDCB

CLIOPN:	3,,(SIXBIT /CLI/)	;CLI .OPEN BLOCK
	0			;UNAME OF HACTRN TO SIGNAL
	SIXBIT /HACTRN/

CLIMSG:	.BYTE 7
IRPC CH,,[
PLEASE DON'T DESTROY ME!
]
	"CH
TERMIN
	^C
	.BYTE
LCLIMS==.-CLIMSG	;LENGTH OF MESSAGE .IOT
]	;END CLISW CONDITIONAL

;FORMAT OF ZUSERS FILE
;FILE IS ORGANIZED INTO BLOCKS

;BLOCK 0 TABLE OF CONTENTS, CONTAINS .ACCESS POINTERS FOR EACH BLOCK (INCLUDING ITSELF),
	;POINTERS MUST BE IN ORDER. ALSO HAS AN EXTRA POINTER AT END SO LENGTH OF
	;LAST BLOCK IS KNOWN

;BLOCK 1 RANDOM CRUFT, LENGTH IS FIXED AT ASSEMBLY TIME OF DRAGON
	IFN 0,BLK1	;BLK1 IS WHERE IT COMES FROM, COMMENTED THERE

;BLOCK 2 HISTORY, ORGANIZED INTO SUB-BLOCKS
	;APPROXIMATELY ONE SUB-BLOCK PER REQUEST FROM THE SYSTEM
	;SUB-BLOCK HAS HEADER, AS FOLLOWS:
	TYPBP==360600	;BYTE POINTER TO TYPE FIELD
	IFN 0,BK2TPT	;BK2TPT LIST OF TYPES
	CNTBP==220700	;# WORDS IN SUB-BLOCK, NOT COUNTING HEADER
	INDXBP==1000	;INDEX OF RELEVANT USER, SOMETIMES NON-ZERO EVEN IF IRRELEVANT
	TTYOBP==110600	;1 + TTY # OF USER (LOGOUT BLOCK ONLY)
	TTYIBP==220600	;SAME FROM SYSTEM

	;REST OF BLOCK DEPENDENT ON HEADER, SEE AGAIN BK2TPT DISPATCHING TO RELEVANT ROUTINES

;FORMAT HISTORY:
;1 -> 2 7/21/71 LOGOUT BLOCK DEBUGGED TO GIVE UNAME, JNAME, TUSED INSTEAD OF <20000,,UIND>,UNAME,JNAME
;2 -> 3 8/12/71 BLOCK 1 THOROUGHLY REORGANIZED FOR COMPATIBILITY WITH ACCOUNTING FILES
	;(IDENTIFIER INTRODUCED)

		;ROUTINE TO TAKE GROSS CLOCK BREAK
		;CALLED WITH PUSHJ, INTERRUPTS ENABLED, AC'S SAVED (EXCEPT P AND ZZZZZ)

		;WITHIN CLKBR1, D CONTAINS BLOCK # OF FILE(S)
		;F CONTAINS S DMNFMT (FOR CAIX'S)

CLKBR1:	.SUSET INTON	;MAYBE HERE ON LOOP SO BE SURE INTERRUPTS ENABLED
	MOVEI A,FDLB3
	MOVSI T,7	;BLOCK IMAGE OUTPUT
	PUSHJ P,BUFOPN	;OPEN FILE FOR OUTPUT
	 JSR QUIT	;CAN'T OPEN FILE?
	MOVEI D,0	;INITIALIZE D TO POINT TO BLOCK 0
	MOVEI F,S DMNFMT	;SET UP SYSTEM FORMAT # IN F, STAYS THERE
	PUSHJ P,BK01C	;"COPY" BLOCKS 0 AND 1
	PUSHJ P,BK2C	;COPY BLOCK 2
	MOVEI E,0	;CLEAR OUT WORD COUNT THIS BLOCK
	SKIPGE BUF1SW	;SKIP UNLESS THIS IS FIRST TIME HERE
	PUSHJ P,UNDDOC	;DOCUMENT NEEDED SYMS, IF ANY
	PUSHJ P,BK2A	;ADD TO BLOCK 2
		; ^ INSERT MORE BLOCKS HERE AS NEEDED
	MOVEI D,0	;NOW RE-INITIALIZE D
	PUSHJ P,BK0R	;REWRITE BLOCK 0
	MOVEI A,UTYIC
	PUSHJ P,FILBUF	;FILE THE OUTPUT, RE-OPEN FOR INPUT
	SKIPN BUF1SW
	PUSHJ P,CNCFIL	;FIRST TIME THROUGH, CONCATENATE LAST TWO ZUSERS FILES SO WON'T FILL UP DIRECTORY
	.SUSET INTOFF
	SKIPL DMNBP
	JRST CLKBR1	;BUFFER FULL ALREADY AGAIN
	SKIPLE DEDF
DONE:	JSR INITX	;ALL DONE, LOG OUT
	MOVE A,TBGCB	;GET TIME IN SECS TILL NEXT GROSS BREAK
	MOVEI B,CLKBR1
	POPJ P,

		;DATA AREA FOR CLKBR1

DEFINE AD A
FOO
IF2,FOO==FOO+A
TERMIN
FOO==0

		;BLOCK 0 TO OUTPUT

BLK0:	AD NWB0	;BLOCK 0 (TABLE OF CONTENTS) ALWAYS NWB0 WORDS LONG
	AD NWB1	;BLOCK 1 (RANDOM PRE-DETERMINED CRUD) ALWAYS NWB1 WORDS LONG
	AD 0	;BLOCK 2 (SYSTEM HISTORY) VARIABLE
	   ;^ INSERT MORE AS NEEDED
	FOO	;FINAL FICTICIOUS BLOCK MARKS END OF LAST REAL ONE
NWB0==.-BLK0	;# WORDS IN BLOCK 0

FBLK0:	BLOCK NWB0	;BLOCK 0 BEING READ IN

		;BLOCK 1 TO OUTPUT

BLK1:	SIXBIT /DRAGON/	;WORD 0 FILE TYPE NAME
	FMT,,S DMNFMT	;1 FORMAT NUMBERS
	0		;2 ALWAYS ZERO IN FILE OUTPUT, .GT. 0 => .ACCESS POINTER TO REAL EOF
	-1		;3 .RDTIME SYSTEM TO GO DOWN
	0		;4 FN2 OF ORIGINAL ZUSERS FILE (SO CAN IDENTIFY AFTER CONCATENATION)
	.FNAM2		;5 DRAGON .FNAM2
	0		;6 .RSYSI THIS SYSTEM
	0		;7 UNAME OF DRAGON
NWB1==.-BLK1	;# WORDS IN BLOCK 1

BKBF:	BLOCK 130.	;SUB-BLOCK BEING OUTPUT
BKBFL==.-BKBF	;SYMBOLIC VERSION OF LENGTH OF BKBF

		;RANDOM ROUTINES FOR CLKBR1, MAYBE ALSO OTHER STUFF

OUTBLK:	MOVE T,BLK0(D)	;OUTPUT AREA STARTING WITH ADR IN RH(A) ACCORDING TO BLK0 TABLE
	SUB T,BLK0+1(D)	;GET -LENGTH OF BLOCK
	HRL T,A		;GET RH OF BLOCK .IOT POINTER IN LH(T)
	MOVSS T		;TURN IT AROUND RIGHT
	PUSHJ P,SBOUT	;OUT IT GOES
	AOJA D,CPOPJ	;RETURN PREPARING TO READ NEW BLOCK

		;UPDATE ALL BLK0 ACCESS POINTERS STARTING AT BEGINNING OF CURRENT BLOCK
		;A HAS # WORDS TO ADD TO THEM ALL

UPDPLL:	POP P,A		;ENTRY FOR # ADDITIONAL ON TOP OF PDL
UPDALL:	MOVE T,D	;MAIN ENTRY, GET INDEX INTO BLK0
UPDAL1:	CAIL T,NWB0	;DONE?
	POPJ P,
	ADDM A,BLK0(T)	;NO, UPDATE THIS ENTRY
	AOJA T,UPDAL1

		;INPUT ROUTINES, DON'T DO ANYTHING IF NOT READING

RSBLK:	SKIPGE BUF1SW	;DO BLOCK .IOT, POINTER IN T
	POPJ P,
	.IOT UTYIC,T
	JUMPGE T,CPOPJ
	JSR QUIT	;EOF

ACCESS:	SKIPGE BUF1SW	;DO .ACCESS TO BEGINNING OF THIS BLOCK
	POPJ P,
	MOVE T,FBLK0(D)
	TLNE T,-1	;CHECK TO SEE IF BITS ON IN LEFT HALF
	JSR QUIT	;SYSTEM DIES ON ACCESS POINTERS WITH BITS ON IN LEFT HALF
	.ACCESS UTYIC,T
	POPJ P,

		;OUTPUT ROUTINES

SBOUT:	.IOT UTYOC,T	;DO BLOCK .IOT USING C(T) AS POINTER
	JUMPGE T,CPOPJ
	JSR QUIT	;????

ACCESO:	PUSH P,T
	MOVE T,BLK0(D)
	TLNE T,-1	;CHECK FOR BITS ON IN LEFT HALF
	JSR QUIT	;SYSTEM DIES ON ACCESS POINTERS WITH BITS ON IN LEFT HALF
	POP P,T
	.ACCESS UTYOC,BLK0(D)	;DO .ACCESS FOR OUTPUT FILE, TO BEGINNING OF THIS BLOCK
	POPJ P,

		;COPY OUT BLOCKS 0 AND 1

BK01C:	SKIPGE BUF1SW	;FILE OPEN FOR READ?
	JRST BK01C2	;NO, JUST OUTPUT NEW STUFF
	MOVE T,[-NWB0,,FBLK0]	;YES, PREPARE TO READ FILE'S BLOCK 0
	PUSHJ P,RSBLK	;READ IT
BK01C2:	MOVEI A,BLK0
	PUSHJ P,OUTBLK	;OUTPUT INACCURATELY, WILL REWRITE LATER
	MOVEI A,BLK1
	PUSHJ P,OUTBLK	;OUTPUT BLOCK 1
	JRST ACCESS	;DO .ACCESS TO BEGINNING OF BLOCK 2, AND RETURN

		;DONE WRITING OUT OTHER BLOCKS, REWRITE BLOCK 0 SO AS TO BE ACCURATE

BK0R:	PUSHJ P,ACCESO	;CLOBBER .ACCESS POINTER SO .IOT WILL BE TO BEGINNING
	MOVE T,[-NWB0,,BLK0]
	JRST SBOUT

		;COPY OUT BLOCK 2

BK2C:	SKIPGE BUF1SW
	POPJ P,		;NOTHING TO READ IN => NOTHING TO COPY
	MOVE A,FBLK0+1(D)
	SUB A,FBLK0(D)	;GET NUMBER OF WORDS IN BLOCK 2
	JUMPG A,.+3
	JUMPE A,CPOPJ
	JSR QUIT	;BLOCK 2 OF FILE BEING READ HAS NEGATIVE WORD COUNT
	IDIVI A,BKBFL	;GET # COMPLETE BUFFERS-FULL IN A, REMAINDER IN B
	JUMPE A,BK2C4B	;JUMP IF NO COMPLETE BUFFER LOADS
BK2C4A:	MOVE T,[-BKBFL,,BKBF]	;PROCESS COMPLETE BUFFERS
	PUSHJ P,RSBLK
	MOVE T,[-BKBFL,,BKBF]
	PUSHJ P,SBOUT
	SOJG A,BK2C4A	;LOOP FOR NUMBER OF COMPLETE BUFFERS
BK2C4B:	JUMPE B,CPOPJ	;PROCESS REMAINDER, JUMP IF ZERO
	HRLOI B,-1(B)
	EQVI B,BKBF
	MOVE T,B
	PUSHJ P,RSBLK
	MOVE T,B
	JRST SBOUT	;THAT'S ALL, FOLKS

		;ADD TO BLOCK 2
		;IN THIS ROUTINE, D HAS BEEN SAVED, AND THEREFORE IS CLOBBERABLE;
		;E HAS # WORDS ADDED SO FAR (SET UP BEFORE CALL)

BK2A:	PUSH P,D	;SAVE D, DON'T NEED IT FOR AWHILE
	MOVNI B,DMNSZ	;INITIALIZE COMPARISON COUNTER (TO SEE WHEN DONE)
	MOVEI C,LS DMNBF	;GET INDEX INTO DMNBF
	JRST .+2	;FALL IN (USED TO BE TDZA E,E)
BK2A8:	.SUSET INTON	;HERE FROM BK2A9, RE-ENABLE INTERRUPTS
BK2A1:	CAML B,DMNBP
	JRST BK2A9	;MAYBE DONE
	PUSH P,B	;SAVE B SO INDIVIDUAL ROUTINE CAN CLOBBER IT
	PUSH P,C	;SAVE INDEX INTO DMNBF SO INDIVIDUAL ROUTINE CAN CLOBBER IT
		;BUT NOTE THAT ON PUSHJ TO ROUTINE, IT IS SET UP RIGHT AND MAY BE USED
	LDB A,BK2A1T	;GET TYPE FIELD FROM SYSTEM ENTRY
	CAIL A,BK2TPE	;BIGGER THAN BIGGEST KNOWN?
	MOVEI A,0	;YES, CLOBBER TO ZERO
	SETZM BKBF	;CLEAR HEADER
	PUSHJ P,@BK2TPT(A)	;CALL INDIVIDUAL ROUTINE TO PROCESS THIS TYPE OF ENTRY
	POP P,C
	POP P,B
	ADDI C,S DMNBEL	;UPDATE INDEX
	AOJA B,BK2A1

BK2A1T:	TYPBP,,(C)S DMNBLM	;BYTE POINTER TO TYPE FIELD IN BLOCK FROM SYSTEM

BK2A9:	.SUSET INTOFF	;BK2A1 THINKS DONE WITH ENTRIES, CHECK AGAIN WITH INTERRUPTS DISABLED
	CAMGE B,DMNBP
	JRST BK2A8	;NO, LOGU GOT IN THERE AND ADDED ANOTHER ONE
	CAME B,DMNBP
	JSR QUIT	;GOT INCREMENTED BY INCORRECT AMOUNT SOMEWHERE ALONG THE LINE
	MOVNI A,DMNSZ	;WIN, RE-INITIALIZE DMNBF POINTERS
	MOVEM A,DMNBP
	.SUSET INTON	;RE-ENABLE INTERRUPTS, LOGU WILL FILL FROM BEGINNING OF BUFFER AGAIN
	PUSHJ P,TIME	;TELL HOW .RDTIME IS TRACKING .RLPDT
	MOVE A,E	;GET COUNT OF # WORDS ADDED
	POP P,D		;RESTORE BLOCK #
	AOJA D,UPDALL	;UPDATE BLK0 POINTERS

		;ADDING TO BLOCK 2, DISPATCH TABLE ON TYPE (PUSHJ P,@BK2TPT(A))

BK2TPT:	BK2UK	;UNKNOWN TYPE
	BK2LI	;1 LOGIN
	BK2LO	;2 LOGOUT
	BK2UK	;3 TIME (TRACKAGE OF .RDTIME WITH .RLPDT)
	BK2UK	;4 LIST OF NEEDED (UNDEFINED) SYSTEM (S) SYMS
	   ;^ ADD MORE TYPES HERE AS NEEDED
BK2TPE::	;END OF TABLE

BK2PSH==PUSH D,	;(USED TO BE A MACRO)

BK2UK:	PUSHJ P,SETHED	;UNKNOWN TYPE FROM SYSTEM, JUST COPY (& SET UP HEADER)
	MOVSI T,(C)	;SET UP LH OF BLT POINTER
	HRRI T,1(D)	;FIRST LOCATION TO BLT INTO
	ADDI D,S DMNBEL	;CALCULATE LAST LOCATION TO BLT INTO
	BLT T,(D)	;BLT THE STUFF IN
BKBFOT:	MOVEI A,-BKBF(D)	;ROUTINE TO OUTPUT BKBF, D POINTS TO LAST WORD ACTIVE
	DPB A,[CNTBP,,BKBF]	;STORE COUNT OF # DATA WORDS
	ADDI E,1(A)	;UPDATE TOTAL OUTPUT COUNT
	HRLOI T,-1+1(A)	;-1 FOR EQVI, +1 FOR HEADER
	EQVI T,BKBF
	JRST SBOUT

		;FREQUENTLY CALLED ROUTINE TO SET UP THE HEADER FOR OUTPUT
		;ASSUMES AC'S STILL SET UP FROM CALL FROM BK2A

SETHED:	MOVEI D,BKBF	;SET UP "PDL POINTER" FOR BK2PSH'S
	DPB A,[TYPBP,,BKBF]	;STORE TYPE FIELD, SAME AS SYSTEM TYPE FIELD (EXCEPT ON BK2UK)
	HRRZ T,1(C)	;GET USER INDEX FIELD FROM SYSTEM'S VERSION
	IDIVI T,S L	;DIVIDE TO GET USER #
	DPB T,[INDXBP,,BKBF]	;STORE IN INDEX FIELD OF HEADER
	POPJ P,

		;INDIVIDUAL ROUTINES FOR BK2A

		;DOCUMENT LOGIN

BK2LI:	PUSHJ P,SETHED	;SET UP HEADER IN STANDARD MANNER
		;NOW OUTPUT LOGIN ENTRY, WRD 0 = HEADER
	BK2PSH (C)	;WRD 1 LOGIN .RDTIME
	ADDI C,S DMNBLM	;RELOCATE INDEX INTO DMNBF TO POINT TO FIRST WRD PECULIAR TO .LOGIN
	BK2PSH 1(C)	;2 UNAME
	BK2PSH 2(C)	;3 JNAME
	BK2PSH 3(C)	;4 NOT NULL => DIAL-IN TERMINAL NAME (IN SIXBIT)
	JRST BKBFOT	;OUTPUT BUFFER AND RETURN

		;DOCUMENT LOGOUT

BK2LO:	PUSHJ P,SETHED	;SET UP STANDARD HEADER
		;LOGOUT BLOCK, WRD 0 HEADER
	BK2PSH (C)	;1 .RDTIME OF LOGOUT
	ADDI C,S DMNBLM
	LDB T,[TTYIBP,,(C)]	;PICK UP 1 + TTY #
	DPB T,[TTYOBP,,-1(D)]	;STORE IN HEADER
	BK2PSH 1(C)	;2 UNAME
	BK2PSH 2(C)	;3 JNAME
	BK2PSH 3(C)	;4 TIME USED (4.069 USEC UNITS)
	CAIL F,2	;DOES THIS SYSTEM HAVE SWAPIN RQ?
	BK2PSH 4(C)	;5 # SWAPIN REQUESTS
	JRST BKBFOT

		;DOCUMENT HOW .RDTIME IS TRACKING .RLPDT

TIME:	SETZM BKBF
	MOVEI A,3
	DPB A,[TYPBP,,BKBF]	;STORE BLOCK TYPE
	MOVEI D,BKBF	;INITIALIZE POINTER FOR PUSHING
	BK2PSH S TIME	;STORE .RDTIME
	.RLPDT T,
		;USE EVEN IF NOT KNOWN
	BK2PSH T	;2 1ST WRD .RLPDT
	BK2PSH TT	;3 2ND WRD .RLPDT
	BK2PSH S SUSRS	;4 # LOGGED IN USERS
	BK2PSH S NULTIM	;5 TIME USED BY NULL JOB (IN SIXTIETHS)
	JRST BKBFOT

		;DOCUMENT UNDEFINED SYSTEM SYMS NEEDED

UNDDOC:	SKIPG SYSYFL	;CHECK UNDEFINED SYM COUNT
	POPJ P,		;NO UNDEFINED SYMS (IGNORE LS SYMS)
	PUSH P,D	;SAVE BLOCK NUMBER
	SETZM BKBF	;CLEAR OUT HEADER
	MOVEI A,4	;SUB-BLOCK TYPE
	DPB A,[TYPBP,,BKBF]	;STORE BLOCK TYPE
	MOVEI D,BKBF	;INITIALIZE PDL POINTER FOR FILLING OUT ENTRY
	MOVSI C,-<SYSSTE-SYSST>/SYSGWS	;AOBJN POINTER FOR CHECKING TABLE
UNDDC1:	SKIPL ICOD+1(C)	;CHECK THIS SYM: DEFINED?
	JRST UNDDC2	;DEFINED, DON'T PUT IT ON THE LIST
	BK2PSH ICOD(C)	;WRD 1 SYM (SQUOZE)
	BK2PSH ICOD+1(C)	;2 SIGN,,ADR OF LAST REQUEST
UNDDC2:	ADDI C,SYSGWS-1	;INCREMENT ALMOST TO NEXT ENTRY IN TABLE
	AOBJN C,UNDDC1	;LOOP BACK FOR NEXT
	PUSHJ P,BKBFOT	;OUTPUT BKBF
	POP P,D		;RESTORE BLOCK NUMBER
	POPJ P,		;THAT'S ALL

	;IO VARIABLES AND ROUTINES FOR ZUSERS FILE BUT PROBABLY GOBBLEABLE

SNAM:	DFSNAM		;SYSTEM NAME, SET TO INITIAL SYSTEM NAME IF NOT FOR REAL (TOP LEVEL)

RSTBLK:	0		;.RCHST BLOCK, DEVICE NAME
	0		;FN1
TGTFN2:	0		;FN2, ONLY ONE REALLY INTERESTED IN
	BLOCK 6		;SYSTEM NAME, ACCESS POINTER + ROOM FOR EXPANSION

		;AREA FOR .FDELE'S AND .OPEN'S
		;.-1 MUST BE TEMPORARILY CLOBBERABLE

FDLB1:	0		;RENAME FILE WHILE OPEN
	UTYOC		;ON UTYOC
	SIXBIT /ZUSERS/
	SIXBIT />/

FDLB3:	SIXBIT /_DRGN_/
	SIXBIT /BUFFER/

FDLB2:	SIXBIT /ZUSERS/
	0		;REAL FN2 OF FILE, FROM TGTFN2

FDLB4:	SIXBIT /_DRGN_/
	SIXBIT /FLUSH/
FDLB5:	0		;0 FOR DELETE
	0		;FOR RENAME AT CNC2LZ

		;.FDELE THE FILE POINTED TO BY -1(A) (READ THE CODING!)

FDELCM:	.SUSET [.SSNAM,,SNAM]	;SYSTEM NAME IMPORTANT
	MOVEI TT,(SIXBIT /DSK/)
	EXCH TT,-1(A)	;SET DEVICE NAME TEMPORARILY TO DSK
	.FDELE -1(A)
	AOS (P)		;SKIPS IF UNSUCCESSFUL
	EXCH TT,-1(A)	;RESTORE NORMAL CONTENTS OF -1(A)
	POPJ P,

		;ASSORTED .FDELE ROUTINES, ALL OF WHICH HACK THE BLOCK STARTING AT -1(A)

FDELEQ:	PUSHJ P,FDELCM	;VERSION TO QUIT IF UNSUCCESSFUL
	POPJ P,
	JSR QUIT

DELFLS:	MOVEI A,FDLB4	;ENTRY TOO DELETE _DRGN_ FLUSH
FDELEN:	PUSHJ P,FDELCM	;VERSION TO NOT CARE WHETHER SUCCESSFUL
	POPJ P,
	POPJ P,

FDELES:	PUSHJ P,FDELCM	;VERSION TO SKIP IF SUCCESSFUL
	AOS (P)
	POPJ P,

		;OPEN THE FILE (BLOCK STARTING AT -1(A)) IN MODE IN LH(T)

BUFOPN:	.SUSET [.SSNAM,,SNAM]	;SET SYSTEM NAME TO NORMAL
	HRRI T,(SIXBIT /DSK/)	;TURN MODE SPECIFICATION INTO DEVICE NAME
	EXCH T,-1(A)		;STORE DEVICE NAME
	.OPEN UTYOC,-1(A)	;TRY OPENING IT
	SOS (P)		;DOESN'T SKIP IF NOT SUCCESSFUL
	EXCH T,-1(A)	;STORE BACK ORIGINAL CONTENTS OF -1(A)
	JRST POPJ1

BUF1SW:	-1		;-1 => THIS FIRST TIME FILE BEING WRITTEN

		;FILE OUTPUT, OPEN FOR INPUT (CHANNEL NUMBER IN A)

FILBUF:	DPB A,[270400,,FILBF9]	;STORE CHANNEL NUMBER IN .IOPOP
	AOSN BUF1SW
	JRST FILBF1	;THIS IS FIRST TIME HERE
	PUSHJ P,DELFLS	;ED_DRGN_ FLUSH$
	MOVEI A,FDLB2
	PUSHJ P,FDELEN	;ENZUSERS 69$_DRGN_ FLUSH$	;RENAME FILE ALREADY THERE
	MOVSI T,.BII
	MOVEI A,FDLB3
	PUSHJ P,BUFOPN	;EF_DRGN_ BUFFER$ER$	;CLOSE FILE AND RE-OPEN FOR INPUT
	JSR QUIT	;OH YEAH?
	PUSHJ P,FDELEQ	;EN$ZUSERS 69$	;RENAME FILE ALREADY THERE
	PUSHJ P,DELFLS	;ED_DRGN_ FLUSH$
FILBF2:	.IOPUSH UTYOC,
FILBF9:	.IOPOP		;(AC FIELD MODIFIED) POP INTO DESIRED CHANNEL
	POPJ P,

		;FILE NEW ONE WITH NEW NAME

FILBF1:	MOVEI A,FDLB1
	PUSHJ P,FDELEQ	;RENAME ZUSERS > WHILE STILL OPEN
	MOVE A,[UTYOC,,RSTBLK]
	.RCHST A,	;WANT REAL SECOND FILE NAME
	MOVE A,TGTFN2	;GET SECOND FILE NAME
	MOVEM A,FDLB2+1	;STORE IN MAIN .OPEN/.FDELE BLOCK
	MOVEM A,BLK1+4	;ALSO STORE IN BLK1 AS ORIGINAL FNAM2
	MOVEI D,1
	;PUSHJ P,ACCESO	;(SEMICOLON SINCE UNNECESSARY AT PRESENT)
	MOVEI A,BLK1
	PUSHJ P,OUTBLK	;REWRITE BLOCK 1 WITH ZUSERS FN2
	MOVEI A,FDLB2
	MOVSI T,.BII
	PUSHJ P,BUFOPN	;CLOSE AND RE-OPEN
	JSR QUIT	;.OPEN LOST
	JRST FILBF2	;MOVE TO DESIRED CHANNEL

		;;CONCATENATE THE LAST TWO ZUSERS FILES

CNCFIL:	.IOPUSH UTYIC,	;SAVE UTYIC, FILE OPEN IN IT
	PUSH P,FDLB2+1	;SAVE CURRENT FN2, WILL CLOBBER LATER
	.SUSET [.SSNAM,,SNAM]	;MAKE SURE SYSTEM NAME OK
	.OPEN UTYIC,DIRBLK	;OPEN FILE DIRECTORY
	 JRST CNCER	;CAN'T OPEN DIRECTORY
	PUSHJ P,GETUFD	;GET A BLOCK OF CORE TO PUT IT IN
	 JRST CNCER	;.CBLK LOST
	MOVE T,[-2000,,UFD]
	.IOT UTYIC,T	;READ IN FILE DIRECTORY
	.CLOSE UTYIC,	;DONE WITH DIRECTORY READ
	SETOM QFVAL	;INITIALIZE VALUES
	SETOM QFVAL+1
	MOVE B,FDLB2+1	;GET CURRENT FNAM2
	PUSHJ P,QTRNS	;CONVERT TO DIGITS
	 JRST CNCFR0	;HUH?
	MOVEM A,QFVAL+2	;STORE AS ONE HIGHER THAN HIGHEST TO MATCH
	PUSHJ P,QUFINI	;RESET UFD INDEX
	MOVE C,FDLB2	;GET FNAM1, STAYS IN C FOR AWHILE
CNCFL1:	PUSHJ P,QRFILE	;FIND A NON-NULL FILE
	 JRST CNCFL2	;NO MORE FILES, EXIT FROM LOOP
	MOVE A,UNRNDM+QFILE	;GET FLAGS WORD
	TLNN A,UNIGFL\UNLINK
	CAME C,UNFN1+QFILE
	JRST CNCFL1	;FILE NOT REALLY THERE, OR FNAM1'S DON'T MATCK
	MOVE B,UNFN2+QFILE	;GET FNAM2
	PUSHJ P,QTRNS	;CONVERT TO DIGITS
	 JRST CNCFL1	;NOT ALL DIGITS, IGNORE THIS ONE
	MOVEI T,1	;NOW SEE IF IT'S AN ALMOST > FILE
CNCF1B:	CAMLE A,QFVAL(T)
	CAML A,QFVAL+1(T)
	JRST CNCF1C	;.LE. EARLIER OR .GE. LATER
	EXCH A,QFVAL(T)	;BETWEEN, MAKE EARLIER
	EXCH B,QFNM2(T)
CNCF1C:	SOJGE T,CNCF1B
	JRST CNCFL1	;BACK FOR NEXT FILE

CNCFR0:	PUSHJ P,FLSUFD	;VARIOUS EXIT ROUTINES, FLUSH UFD BLOCK OF CORE
CNCER:	MOVE U,S USER
	MOVE T,(U)S SUPPRO
	CAME T,[-1]
	.VALUE		;NOT TOP LEVEL, MAYBE THE GUY RUNNING DDT WANTS TO WORRY ABOUT IT
CNCEX:	POP P,FDLB2+1	;NORMAL EXIT, RESTORE STUFF PUSHED
	.IOPOP UTYIC,	;RESTORE MAIN FILE OPEN IN UTYIC
	.CLOSE UTYOC,
	POPJ P,

		;(CONCATENATING FILES) DONE WITH SCAN THROUGH USER DIRECTORY

CNCFL2:	PUSHJ P,FLSUFD	;SURRENDER UFD BLOCK OF CORE
	SKIPL QFVAL
	SKIPGE QFVAL+1
	JRST CNCEX	;FEWER THAN TWO FILES THERE
	MOVE A,QFNM2+1	;GET LATER (HEREINAFTER CALLED "SECOND") FNAM2
	PUSHJ P,FMTCHK	;CHECK SECOND FILE, .IOPUSH IF IT LOOKS GOOD
	JRST CNCER	;LOOKS BAD
	PUSH P,B	;POINTER TO BLOCK 1
	PUSH P,D	;SIZE OF FILE
	MOVE A,QFNM2
	PUSHJ P,FMTCHK	;NOW CHECK FIRST FILE
	JRST CNCFX3	;BAD
	MOVSI T,7	;BLOCK IMAGE OUTPUT
	MOVEI A,FDLB3	;_DRGN_ BUFFER
	PUSHJ P,BUFOPN	;OPEN _DRGN_ BUFFER FOR OUTPUT
	JRST CNCFX2	;LOSE?
	JSP Q,BADPSH	;PUT .IOT AT BKCPRD ON LIST
	 BILLOP\BIOCER
	 CPOPJ,,FCPX
	MOVE C,D	;SIZE OF FIRST FILE
	MOVE G,D	; "
	ADD G,(P)	;G := EXPECTED SIZE OF OUTPUT FILE
	PUSHJ P,CNCWFL	;COPY OUT FIRST FILE
	JRST CNCFX3	;LOSE
	POP P,C		;SIZE OF SECOND FILE
	POP P,B		;BLOCK 1 POINTER OF SECOND FILE
	MOVEI G,0	;EOF WORD TO WRITE IN BLOCK 1 OF SECOND FILE
	PUSHJ P,CNCWFL	;COPY OUT SECOND FILE
	JRST CNCER	;LOSE
	MOVE T,[CNCER,,CNCF2X]
	MOVEM T,(F)
CNCF2X:	.CLOSE UTYOC,	;EF_DRGN_ BUFFER$
	PUSHJ P,BADPOP	;SURVIVED .CLOSE, FLUSH TRAP
	PUSHJ P,DELFLS	;ED_DRGN_ FLUSH$
	MOVEI A,2*30.	;TWO SECONDS
	.SLEEP A,	;WAIT AWHILE, GIVE IT TIME TO ALL GET ONTO THE DISK
	MOVEI A,FDLB2
	PUSHJ P,FDELES	;ENZUSERS >-2$_DRGN_ FLUSH$
	JRST CNCER	;MISSING?
	MOVEI A,FDLB3
	PUSHJ P,FDELES	;EN_DRGN_ BUFFER$ZUSERS >-2$
	JRST CNC2LZ	;LOSE, TRY UNDOING THE DAMAGE
	MOVE A,QFNM2+1
	MOVEM A,FDLB2+1
	PUSH P,FDLB2+2
	SETZM FDLB2+2	;CLEAR OUT FOR DELETE
	MOVEI A,FDLB2
	PUSHJ P,FDELEN	;EDZUSERS >-1$
	POP P,FDLB2+2	;RESTORE, DELETE DONE
	PUSHJ P,DELFLS	;ED_DRGN_ FLUSH$
	JRST CNCEX

		;LOSSAGE ROUTINES FOR CNCFL2

CNCFX2:	.IOPOP UTYOC,
CNCFX3:	SUB P,[2,,2]
CNCFX1:	.IOPOP UTYOC,
	JRST CNCER

CNC2LZ:	MOVE A,FDLB2
	MOVEM A,FDLB5
	MOVE A,FDLB2+1
	MOVEM A,FDLB5+1
	PUSHJ P,DELFLS
	SETZM FDLB5
	JRST CNCER

		;COPY OUT THE LATEST .IOPUSHED FILE ONTO UTYOC
		;B HAS POINTER TO BLOCK 1
		;C HAS SIZE OF FILE
		;G HAS WORD TO PUT IN "REAL EOF" WORD IN BLOCK 1

CNCWFL:	.IOPOP UTYIC,
	IDIVI C,BKBFL
	JSP Q,BKCPRD
	 JRST BADPOP	;SHOULDN'T HAPPEN
	MOVEM G,BKBF+2(B)
CNCWF2:	MOVE T,[CPOPJ,,CNCWFX]
	EXCH T,(F)
CNCWFX:	.IOT UTYOC,TT
	MOVEM T,(F)
	JSP Q,BKCPRD
	JRST POPJ1
	JRST CNCWF2

BKCPRD:	SOJGE C,BKCPR2	;BKCPRD TO READ IN BLOCK FOR COPYING OUT
	JUMPE D,(Q)	;LESS THAN A BUFFER FULL LEFT, JUMP IF NOTHING LEFT
	HRLOI T,-1(D)
	EQVI T,BKBF
	TDZA D,D	;CLEAR OUT COUNT REMAINING AND FALL IN
BKCPR2:	MOVE T,[-BKBFL,,BKBF]	;HERE TO READ ENTIRE BKBF FULL
	MOVE TT,T	;SAVE BLOCK IOT POINTER IN TT FOR LATER WRITING OUT
FCPX:	.IOT UTYIC,T	;READ IN BLOCK, FCPX CHECKED FOR ON IO CHANNEL ERROR
	JUMPGE T,1(Q)	;RETURN IF OK
	JRST BADPOP	;EARLY EOF (SHOULDN'T HAPPEN)

FCKACC:	MOVE T,[CPOPJ,,FCKACX]
	EXCH T,(F)
	TLNE A,-1	;CHECK FOR BITS ON IN LEFT HALF
	JRST BADPOP	;DON'T ALLOW, SYSTEM DIES ON ACCESS POINTERS WITH BITS ON IN LEFT HALF
FCKACX:	.ACCESS UTYOC,A
	MOVEM T,(F)
	JRST (Q)

		;A HAS FNAM2, OPEN THAT ZUSERS FILE ON UTYOC (FOR INPUT)
		;MAKE SURE IT IS A VALID ZUSERS FILE
		;SKIPS IF YES, LEAVES .ACCESS POINTER TO EOF IN D
		;ALSO LEAVES .ACCESS POINTER TO BLOCK 1 OF FIRST SUB-FILE IN B

FMTCHK:	MOVSI T,6	;BLOCK IMAGE INPUT
	MOVEM A,FDLB2+1	;STORE FNAM2
	MOVEI A,FDLB2	;SET UP INDEX REGISTER FOR .OPEN AT BUFOPN
	PUSHJ P,BUFOPN	;TRY OPENING FILE
	 POPJ P,	;CAN'T OPEN FILE
	JSP Q,BADPSH	;NOW SET UP JUMP TO CPOPJ ON IO CHANNEL ERRORS ON READ
	 BIOCER\BILLOP
	 CPOPJ,,FCKX
	MOVE T,[-3,,BKBF]
	JSP Q,FCKRD	;READ FIRST THREE WORDS OF FILE
	SKIPN BKBF
	SKIPG B,BKBF+1	;GET .ACCESS POINTER TO BLOCK 1 OF FIRST SUB-FILE
	 JRST BADPOP	;FIRST WORD NON-ZERO, OR SECOND NON-POSITIVE
	SKIPLE D,BKBF+2	;GET .ACCESS POINTER TO BLOCK 2 (END OF BLOCK 1)
	CAML B,D
	JRST BADPOP	;BLOCK 1 OF NEGATIVE OR ZERO LENGTH
	CAIGE B,15.
	CAIL D,75.
	JRST BADPOP	;BLOCK 0 15. OR MORE WORDS LONG, OR BLOCK 0 + BLOCK 1 75. OR MORE
	HRLOI T,3-2-1(B)
	EQVI T,BKBF+3
	JSP Q,FCKRD	;READ REST OF BLOCK 0, AND FIRST 3 WORDS OF BLOCK 1
	MOVE D,BKBF-1(B)	;GET POINTER TO END OF SUB-FILE
	SKIPL C,BKBF+2(B)	;PICK UP WHAT MAY BE POINTER TO REAL EOF
	CAIL C,15.*2000	;FLUSH FILES 15. K OR MORE LONG
	JRST BADPOP
	JUMPE C,FMTCK2	;JUMP IF NO REAL EOF SPECIFIED, USE END OF SUB-FILE AS REAL EOF
	CAMGE C,D
	JRST BADPOP	;SUB-FILE BIGGER THAN ENTIRE FILE?
	MOVE D,C	;LOOKS OK, USE IT AS REAL EOF POINTER
FMTCK2:	MOVE A,BKBF(B)	;GET IDENTIFIER
	CAME A,BLK1
	JRST BADPOP	;IDENTIFIERS DIFFER
	MOVEI A,-1(D)	;NOW FOR THE CRUCIAL TEST!
	JSP Q,FCKACC	;DO .ACCESS TO EOF - 1
	HRROI T,A
	JSP Q,FCKRD	;IF FILE IS SHORT, THIS WILL IOCER OUT
	.ACCESS UTYOC,[0]	;ACCESS BACK TO BEGINNING OF FILE
	.IOPUSH UTYOC,	;SAVE FILE, WILL WANT IN UTYIC LATER (BESIDES, WANT REVERSE ORDER)
	JRST BADPJ1	;BY GOLLY THIS FILE LOOKS OK!

FCKX::		;FCKX CHECKED FOR BY IOCER ROUTINE
FCKRD:	.IOT UTYOC,T
	JUMPGE T,(Q)
	JRST BADPOP

		;B HAS WHAT SHOULD BE SIXBIT DECIMAL CHARACTER REPRESENTATION OF A NUMBER
		;(LEFT JUSTIFIED). CONVERT IT TO ACTUAL NUMBER, LEAVE
		;ACTUAL IN A, LEAVE B ALONE, CLOBBER ONLY T, TT

QTRNS:	MOVEI A,0	;INITIALIZE A TO RECEIVE NUMBER
	MOVE TT,B	;GET SIXBIT IN TT
QTRN1:	MOVEI T,0	;CLEAR T TO RECEIVE CHARACTER
	LSHC T,6	;SHIFT IN CHAR
	CAIL T,'0
	CAILE T,'9
	POPJ P,		;NOT DIGIT
	IMULI A,10.	;DIGIT, UPDATE
	ADDI A,-'0(T)
	JUMPN TT,QTRN1	;LOOP FOR ALL CHARS
	JRST POPJ1	;AT LEAST ONE NON-BLANK CHAR, ALL OF WHICH ARE DIGITS

		;VARIABLES USED FOR FINDING LAST TWO ZUSERS FILES

QFVAL:	-1	;NUMERIC OF OLDER FILE
	-1	;NEWER
	-1	;CURRENT (BEING WRITTEN)

QFNM2:	0	;FNAM2 OF OLDER
	0	;NEWER
	;NO NEED TO STORE NEWER

UFDIN:	-1	;UFD EXISTENCE SWITCH: -1 => DOESN'T EXIST
		;0 BEING GOTTEN, 1 EXISTS

GETUFD:	SKIPL UFDIN	;PUSHJ P,GETUFD GET UFD BLOCK, SKIPS IF SUCCESSFUL
	JSR QUIT	;DIES IF TRYING TO GET UFD ON TOP OF ITSELF
	AOS UFDIN	;SIEZE SWITCH
	JSP Q,GETPG	;NOW GET THE BLOCK
	 4400,,SIGN+UFD_-1
	 1
	 JRST FLSUF2	;.CLBLK LOST
	AOS UFDIN	;CBLK WON, INDICATE BLOCK EXISTS NOW
	JRST POPJ1

FLSUFD:	JSP Q,GETPG	;ROUTINE TO FLUSH USER DIRECTORY BLOCK OF CORE
	 UFD_-1
	 1
	 JFCL		;.CBLK LOST?
FLSUF2:	SETOM UFDIN	;NO LONGER HAVE BLOCK
	POPJ P,

DIRBLK:	6,,(SIXBIT /DSK/)	;.OPEN BLOCK FOR FILE DIRECTORY OPENS
	SIXBIT /.FILE./
	SIXBIT /(DIR)/

		;ROUTINE TO SCAN USER DIRECTORY
		;DOESN'T CLOBBER ANY AC'S WHATSOEVER

QFILE:	BLOCK LUNBLK	;NAME BLOCK THIS FILE (READ INTO)

UFDPT:	2000		;INDEX INTO UFD OF NAME AREA OF FILE SLOT FIRST AFTER CURRENT

		;PUSHJ P,QRFILE	;GET NAME AREA OF A FILE
		;SKIPS UNLESS NO MORE FILES THIS USER DIRECTORY

QRFILE:	PUSH P,A	;SAVE A
	MOVE A,UFDPT	;GET INDEX INTO DIRECTORY, AND FALL IN
QRFIL1:	ADDI A,LUNBLK	;LOOP POINT, INCREMENT TO NEXT FILE
	CAILE A,2000
	JRST QLOSE	;END OF DIRECTORY
	SKIPN UFD+UNFN1-LUNBLK(A)
	SKIPE UFD+UNFN2-LUNBLK(A)
	JRST .+2	;USE THIS FILE
	JRST QRFIL1	;THIS ISN'T REALLY A FILE, IGNORE IT
	MOVEM A,UFDPT	;STORE BACK UPDATED INDEX
	PUSH P,B	;SAVE B
	MOVSI A,UFD-LUNBLK(A)
	HRRI A,QFILE
	BLT A,QFILE+LUNBLK-1	;BLT IN NAME AREA THIS FILE
	POP P,B
	AOS -1(P)
QLOSE:	POP P,A
	POPJ P,

QUFINI:	MOVE A,UFD+UDNAMP	;INITIALIZE UFD INDEX
	MOVEM A,UFDPT
	POPJ P,
IFN 0,[
		;MAKE FILE OPEN ON UTYOC LOOK NEW

MAKNUF:	JSP Q,BADPSH	;SET UP FOR RETURN ON ILLOP OR IOCERR
	 BILLOP\BIOCER
	 CPOPJ,,DMPCHX	;DMPCHX FIRST RELEVANT INSTRUCTION
	MOVE A,[200000,,UTYOC]
DMPCHX:	.DMPCH A,	;CLEAR DUMP BIT
	JFCL
MAKN2:	MOVE A,S QDATE	;GET DISK DATE FROM SYSTEM
	MOVE B,S TIMOFF	;GET TIME
	CAME A,S QDATE	;COMPARE TO SEE IF SKIPPED TO ANOTHER DAY
	JRST MAKN2	;SKIPPED TO ANOTHER DAY, TRY AGAIN
	HRR A,B
	MOVEI T,.+2
	HRRM T,(F)	;STORE NEW PC CHECK FOR TSINT
	.CALL MAKNB	;SET FILE'S DATE OF CREATION
	JRST BADPOP	;DIDN'T SKIP
	JRST BADPOP	;SKIPPED

MAKNB:	SETZ		;.CALL BLOCK TO SET FILE'S DATE OF CREATION
	SIXBIT /SFDATE/
	[UTYOC]
	SETZ A
]

		;;QUIT ROUTINES

		;JSR INITX SOMETHING WENT WRONG WHEN NOT POSSIBLE TO CALL QUIT

INITX:	0
	SOS INITX	;BACK UP PC TO POINT TO JSR
	.LOGOUT		;FLUSH SELF, SOMEHOW
	.VALUE
	JRST .-2

		;JSR QUIT SOMETHING WENT WRONG, DIE
		;DUMP SELF OUT IN PROCESS

QUIT:	0
	SOS QUIT	;MAKE IT POINT TO THE JSR
	MOVEM U,AC0Q+U
	MOVE U,S USER
	MOVE U,(U)S SUPPRO
	CAME U,[-1]
	.VALUE		;NOT TOP LEVEL, GO BACK TO DDT AND LET HIM WORRY ABOUT IT NOW
	MOVEI U,AC0Q
	BLT U,AC0Q+U-1	;SAVE THE AC'S
	MOVE U,S USER
	JSP Q,QUVRS	;SAVE RELEVANT USER VARIABLES (DON'T USE PDL, IMPORTANT THAT PERSON LOOKING
		;AT DUMP BE ABLE TO EXAMINE IT)
	.SUSET INTOFF	;BACK FROM SAVING USER VARIABLES, CAN DO SYSTEM CALL NOW, SO INHIBIT INTERRUPTS
	MOVSI A,(U)S IOCHNM
	HRRI A,QICHN
	BLT A,EQBLT-1	;SAVE IOCHNM ETC.
	JSR PDUMP	;DUMP OUT SELF (DON'T CLOBBER U)
	SETZM PDMST+2	;.OPEN DIDN'T SKIP
	MOVE P,[-LPDL,,PDL]	;OK TO CLOBBER PDL NOW
	MOVE B,PDMST+2	;GET FNAM2 OF FILE WRITTEN
	SKIPL @DEADP	;SYSTEM DEAD?
	PUSHJ P,QTRNS	;GET TRANSLATION OF FNAM2
	JSR INITX	;SYSTEM DEAD, OR FNAM2 NOT NUMERIC, JUST DIE
	CAIGE A,NTRIES	;SKIP IF TRIES EXHAUSTED, DON'T TRY TO RELOAD
	SKIPGE (U)S APRC	;SKIP IF DISOWNED
	.LOGOUT		;TOO MANY TRIES, OR DISOWNED AND .VALUE WON'T RELOAD
	.VALUE		;NOT TOO MANY YET, RELOAD
	JRST .-2

		;SAVE USER VARIABLES (OVERWRITES ROUTINE)

QUVRS:	MOVEI D,.	;SET UP POINTER FOR PUSHING
QSV40:	PUSH D,(U)S SV40	
QSUOH:	PUSH D,(U)S SUUOH
QJPC:	PUSH D,(U)S UPGML	;MAYBE NOT RELOADED YET
		;INSERT OTHERS HERE WIPED OUT BY SCHEDULE
QLSUUO:	PUSH D,(U)S LSUUO
QUUOH:	PUSH D,(U)S SUUOH
QPICL:	PUSH D,(U)S PICLR
QSNAM:	PUSH D,(U)S USYSNM	;SYSTEM NAME
QTUSR:	PUSH D,S USER	;USER INDEX (FOR QICHPP, ETC.)
	MOVE A,.+2
	MOVEM A,QUVRS	;DON'T ALLOW RE-ENTERING
	JRST (Q)

AC0Q:	BLOCK 20	;AC'S SAVED AT QUIT

QICHN:	BLOCK 20	;IOCHNM'S SAVED AT QUIT
QICHP:	BLOCK 20	;IO PDL
QICHPP:	0		;IO PDL POINTER
QICHS:	BLOCK 20	;IOCHST SAVED AT QUIT
EQBLT::		;END OF AREA BLTED INTO FROM BEGINNING OF USER VARIABLES AT QUIT

PDMOPN:	7,,(SIXBIT /DSK/)	;.OPEN BLOCK FOR PDUMP
	SIXBIT /DRDMP/
	SIXBIT />/

PDMST:	BLOCK 10.	;.RCHST BLOCK FOR PDUMP, HAS FILE SPEC ON RETURN

PDMJBK:	0		;JUMP BLOCK ENDING PROGRAM
	0		;JUMP BLOCK ENDING SYMBOL TABLE

IFN SYPDMP,[
PDMCAL:	SETZ		;.CALL BLOCK FOR PDUMP
	SIXBIT /PDUMP/
	[-1]		;DUMPING SELF,
	[UTYOC]		;ONTO FILE
	402000,,A	;(STATE WORD USED BY SYSTEM)
]
IFE SYPDMP,[	;MORE CODING FOR PDUMP SIMULATION
		;PUT ENTRIES IN PAGE MAP

PUTPG:	MOVE T,(Q)	;CALLED WITH JSP Q, NEXT WORD INITIAL PAGE MAP ENTRY
	SKIPLE TT,1(Q)	;WORD AFTER THAT -# PAGES,,FIRST VIRTUAL PAGE #
	JRST 2(Q)	;NO PAGES TO STORE
	MOVEM T,PDMBLK+1(TT)	;STORE THIS MAP WORD
	ADDI T,1		;INCREMENT MAP WORD IN CASE DOING EXEC, LINK, OR WHATEVER
	AOBJN TT,.-2	;LOOP FOR ALL ENTRIES REQUESTED
	JRST 2(Q)
]

		;JSR PDUMP	;DUMP SELF OUT AS DRDMP >

PDUMP:	0		;SKIPS IF .OPEN DOES; DOESN'T CLOBBER U
	.SUSET [.SSNAM,,SNAM]
	.OPEN UTYOC,PDMOPN
	JRST @PDUMP	;.OPEN LOST
	AOS PDUMP	;.OPEN WON, CAUSE RETURN TO SKIP EVEN IF SOMETHING ELSE GOES WRONG
	MOVE A,[UTYOC,,PDMST]
	.RCHST A,	;GET CHANNEL STATUS (FOR FNAM2 ON RETURN)
IFN SYPDMP,[	;USE SYSTEM'S PDUMP
	MOVEI A,0	;INITIALIZE STATE WORD
	.CALL PDMCAL	;TELL THE SYSTEM TO DO IT
	JFCL
]IFE SYPDMP,[	;HAVE TO SIMULATE PDUMP
	JSP Q,GETPG	;GET CORE BLOCK FOR PAGE MAP BLOCK
	 4400,,SIGN+PDMBLK_-1
	 1
	JRST @PDUMP	;DIDN'T GET BLOCK
	MOVEI A,600000	;NOW SET UP PAGE MAP
	MOVEM A,PDMBLK+1+0	;PAGE 0
	JSP Q,PUTPG	;HBLKS
	 600000+HIBEG/2000	;READ/WRITE
	 -HBLKS,,HIBEG/2000
	JSP Q,PUTPG	;SYSTEM'S PAGE 0
	 SETZ 200000	;ABSOLUTE, READ-ONLY
	 -1,,SYSLOR/2000
	JSP Q,PUTPG	;REST OF SYSTEM
	 SETZ 200001	;READ ONLY
	 -177,,1
		;DON'T BOTHER WITH EXEC DDT, IT WAS ONLY NEEDED ONCE
	MOVEI A,600000+UFD/2000
	SKIPLE UFDIN
	MOVEM A,PDMBLK+1+UFD/2000	;UFD PAGE, SINCE UFD IN NOW
	MOVE T,[-2000,,PDMBLK]
	.IOT UTYOC,T	;OUTPUT PAGE MAP
	MOVSI C,-400	;AOBJN POINTER TO PAGE TABLE, RH HAS VIRTUAL PAGE #
PDUMP5:	SKIPG PDMBLK+1(C)
	JRST PDUMP6	;THIS PAGE NOT REALLY THERE (NO ACCESS, OR EXEC)
	MOVEI T,(C)	;VIRTUAL PAGE NUMBER
	LSH T,10.	;CONVERT TO ADDRESS
	HRLI T,-2000	;CONVERT TO BLOCK IOT POINTER
	.IOT UTYOC,T	;DUMP OUT BLOCK
PDUMP6:	AOBJN C,PDUMP5	;LOOP FOR ENTIRE PAGE MAP
]		;END THIS PORTION OF PDUMP SIMULATION CODING
	MOVE T,[-2,,PDMBLK]
	.IOT UTYOC,T	;OUTPUT JUMP BLOCKS
	.CLOSE UTYOC,
	JRST @PDUMP

		;END OF QUIT ROUTINES (BUT SEE ALSO INIT FOR CODING RENAMING DRDMP FILES)

		;MAIN PROGRAM LEVEL STUFF
LBLK

GO::
BEG:	JSP A,INIT	;INITIALIZE
	PUSHJ P,ICLR	;FLUSH INITIALIZATION CODING

.INSRT PJ;GATHER >

	JSR QUIT	;A GOT CLOBBERED
HBLK

		;FILL SYMBOL REQUESTS
		;VALUE OF SYM IS IN A, T HAS ADR OF FIRST REQUEST

DFSLST:	SOS LSYMFL	;ENTRY CORRESPONDING TO LS MACRO, DECREMENT COUNTDOWN
	PUSH P,T	;SAVE JSP PC FOR RETURN
	AOS (P)		;INCREMENT TO SKIP OVER REQUEST WORD
SYSYDF:	MOVSI TT,SIGN
	TDNN TT,(T)	;CHECK SIGN BIT OF REQUEST, SHOULD BE ON
	JSR QUIT	;SYM ALREADY DEFINED
	ANDCAB TT,(T)	;CLEAR OUT SIGN BIT
	TLZ TT,-1	;CLEAR OUT LEFT HALF OF AC
SYSYD2:	HRRM A,(T)	;NOW CHASE DOWN THE LIST: STORE VALUE IN THIS WORD
	SKIPN T,TT	;GET ADR OF NEXT REQUEST
	POPJ P,		;THAT'S ALL
	HRRZ TT,(T)	;SWITCH AC'S
	JRST SYSYD2	;LOOP BACK FOR THIS ONE

		;DO CTLY$G FROM DDT TO GOBBLE USED SYSTEM SYMS

CTLY:	.VALUE		;BECOMES A NO-OP AT ICLR, AND ANOTHER .VALUE A FEW INSTRUCTIONS FROM NOW
	.VALUE [.ASCII /!<SYSST-SYSSTE,,ICOD>,$P/]
	MOVEM U,CTLY
	MOVSI U,(.VALUE)
	EXCH U,CTLY
	JRST 35	;BACK TO DDT

		;INITIALIZATION CODING

		;CLEAR OUT REST OF INITIALIZATION CODING

ICLR:	MOVE A,[SYSST,,ICOD]
	BLT A,ICOD+SYSSTE-SYSST-1	;MOVE INITIAL SYMBOL TABLE DOWN
	MOVSI A,(JFCL)
	MOVEM A,CTLY	;ALLOW CTLY$G FROM DDT TO GOBBLE SYMS
	SETZM ICOD+SYSSTE-SYSST	;CLEAR OUT FIRST LOCATION FOR BLT
	MOVE A,[ICOD+SYSSTE-SYSST,,ICOD+SYSSTE-SYSST+1]	;SET UP BLT POINTER
	MOVE B,EDNCOD	;GET LAST ADR TO CLEAR + 1
	BLT A,-1(B)	;CLEAR OUT CODING, DON'T REFERENCE CONSTANTS BETWEEN NOW AND POPJ OUT OF HERE
	SETZM LICOD
	MOVE A,[LICOD,,LICOD+1]
	MOVE B,EDLCOD
	BLT A,-1(B)
	.SUSET INTON	;OK TO TAKE INTERRUPTS NOW
	POPJ P,

LBLK		;DUMP OUT CONSTANTS AND VARIABLES IN LOW BLOCK
		;CODING NOT CLEARED OUT:

PUREL:	-1	;-1 IFF NOT PURIFIED
EDLCOD:	LICOD	;HAS ADR OF FIRST WORD IN LOW CORE NOT ALLOCATED
EDNCOD:	ICOD	;FIRST LOCATION NOT ALLOCATED AT EXECUTION TIME
SYSYFL:	<SYSSTE-SYSST>/SYSGWS	;# S SYMS REQUESTED BUT NOT DEFINED
LSYMFL:	LSYCT			;# LS SYMS REQUESTED BUT NOT DEFINED

		;JSP Q,GETPG	;GET PAGES
		 ;INITIAL .CBLK WORD
		 ;# CONSECUTIVE PAGES TO GET
		 ;ERROR RETURN
		;NORMAL RETURN

GETPG:	MOVE T,(Q)	;CLOBBERS T,TT; GET INITIAL .CBLK WORD
	SKIPG TT,1(Q)	;GET COUNT
	JRST 3(Q)	;NO PAGES, RETURN NOW
	.CBLK T,	;GET PAGE
	JRST 2(Q)	;.CBLK LOST
	ADDI T,1001	;INCREMENT .CBLK WORD TO NEXT PAGE
	SOJG TT,.-3	;BACK FOR NEXT
	JRST 3(Q)	;ALL DONE

PDL:	BLOCK LPDL+20	;EXTRA FOR GROSS OVERFLOW GENERATED BY SAVE MACRO

VARIAB
CONSTA

PATCH:		;PATCH AREA
PAT:	BLOCK 40
PATCHE=.-1

LICOD::		;FIRST LOW BLOCK LOCATION ALLOCATED BY ALLOC

HBLK
ICOD:		;BEGINNING OF CODING CLEARED OUT BY ICLR AND ALLOCATED BY ALLOC
		;END CORE-RESIDENT CODING, BEGIN INITIALIZATION CODING
		;WIPED OUT BY INITIALIZATION AND ALLOCATED FOR USE AS STORAGE

		;SORT SYSST
		;A POINTS TO FIRST ENTRY
		;B POINTS TO LAST ENTRY + 1
		;C HAS ONE BIT SET, THAT BIT MOST SIGNIFICANT BIT TO SORT ON

SORT:	HRLM B,(P)	;SAVE UPPER BOUND
	CAIL A,-SYSGWS(B)
	JRST SORT7	;ONE OR ZERO ENTRIES
	PUSH P,A	;SAVE LOWER BOUND
SORT3:	TDNN C,(A)	;BIT SET IN LOWER ENTRY?
	JRST SORT4	;NO, INCREMENT TO NEXT AND MAYBE TRY AGAIN
	SUBI B,SYSGWS	;YES, NOW BACK UP UPPER POINT	
	TDNE C,(B)	;BIT CLEAR IN UPPER ENTRY?
	JRST SORT5	;NO, CHECK FOR END, DECREMENT B, AND TRY AGAIN
REPEAT SYSGWS,[		;BIT SET IN LOWER ENTRY AND CLEAR IN UPPER => EXCHANGE ENTRIES
	MOVE T,.RPCNT(A)
	EXCH T,.RPCNT(B)
	MOVEM T,.RPCNT(A)
]
SORT4:	ADDI A,SYSGWS	;INCREMENT LOWER BOUND POINTER TO NEXT ENTRY
SORT5:	CAME A,B	;ANY MORE ENTRIES LEFT?
	JRST SORT3	;YES, GO PROCESS THEM
		;A AND B NOW BOTH POINT TO FIRST ENTRY WITH BIT SET
	ROT C,-1	;ROTATE BIT INDICATOR TO NEXT (LESS SIGNIFICANT) BIT
	POP P,A		;RESTORE LOWER BOUND OF ENTIRE SORT
	JUMPL C,SORT6	;JUMP IF NO MORE KEY TO SORT ON
	PUSHJ P,SORT	;SORT BOTTOM PART OF TABLE
	HLRZ B,(P)	;RESTORE UPPER BOUND (SORT CLOBBERED A TO MIDDLE)
	PUSHJ P,SORT	;SORT TOP PART OF TABLE
SORT6:	ROT C,1		;BACK UP KEY AGAIN SO AS TOO "NOT CLOBBER C"
SORT7:	HLRZ A,(P)	;MAKE A POINT ABOVE TABLE ENTRIES SORTED
	POPJ P,

LBLK
		;INITIALIZE; CALLED FROM BEG WITH JSP A,

INIT:	MOVE P,[-LPDL,,PDL]	;INITIALIZE P
	PUSH P,A	;SAVE RETURN POINT SO CAN RETURN WITH POPJ
	AOSN PUREL	;ALREADY PURIFIED?
	PUSHJ P,PURIF1	;NO, DO SO
	JRST INIT1	;HIGH CORE IN RIGHT PLACE NOW, GO THERE
HBLK
INIT1:	.SUSET [.RUNAM,,B]	;GET UNAME (DON'T USE S UNAME SINCE NOT DEFINED YET)
	CAMN B,[LGNM]	;LOGGED IN FOR REAL?
	JRST INIT2	;FOR REAL AND QUIT OUT OF LAST TIME, MAYBE REPLACE WITH RECOVERY CODE
	.CALL LOGCAL	;TRY LOGGING IN
	.SUSET [.RSNAM,,SNAM]	;ALREADY LOGGED IN, USE INITIAL SYSTEM NAME INSTEAD OF DFSNM
INIT2:	PUSHJ P,SYSYMG	;GOBBLE SYSTEM SYMS
	MOVE U,S USER	;SET U TO USER, MAY BE USEFUL IN DEFINING LS SYMS
	MOVEI C,ICOD+SYSSTE-SYSST	;INITIALIZE C AS LOCATION COUNTER FOR EXECUTION TIME LOCATION ASSIGNMENTS
	PUSHJ P,ALLOC	;ALLOCATE STUFF
	.RSYSI A,	;GET SYSTEM VERSION
	MOVEM A,BLK1+6	;STORE FOR OUTPUT IN ZUSERS FILE
	MOVE A,S DMNBD	;GET # THINGS ALREADY HANDLED BY SYSTEM
	SUBI A,S DMNSZ
	ADDI A,2
	TLNE A,SIGN
	MOVEI A,0
	MOVEM A,DMNBB	;STORE INDICATION OF FIRST ENTRY TO PROCESS
IFN CLISW,[MOVEI A,(U)S UNAME
	DEFSYM UNAME
	MOVEI A,(U)S APRC
	DEFSYM UAPRC
]	MOVE A,(U)S UNAME
	MOVEM A,BLK1+7	;STORE USER NAME IN BLOCK 1
IFN CLISW,MOVEM A,IUNAM
		;^ INSERT MOST LS SYM DEFINITION ROUTINES HERE
	MOVE A,[JSR INITX]
	MOVEM A,BEG	;CAUSE INSTANT LOSSAGE IF RESTARTED
	MOVEM A,PURIFY	;ALSO DON'T ALLOW RE-PURIFY
	.CLOSE 1,	;CLOSE CHANNEL MAYBE LOADED SELF ON
	.SUSET [.SSNAM,,SNAM]	;SET SYSTEM NAME
	MOVEI A,30.*30.
	CAML A,S TIME
	.FDELE QTRNBK	;RENAME NEW DUMP FILES OLD ONES
	JRST .+2	;LOST, SKIP OUT OF LOOP
	JRST .-2	;WON, KEEP LOOPING UNTIL ALL RENAMED
	.CLOSE		;CLEAR OUT IOCHST TO SAVE JSF'S PEACE OF MIND
	MOVEI A,5
	MOVEI B,CLKBR1
	PUSHJ P,CKQADI	;DO FIRST CLKBR1 IN FIVE SECONDS (DISABLES INTERRUPTS)
	MOVE A,[620000,,[60.]]
	.REALT A,	;CAUSE INTERRUPT EVERY SECOND
	MOVE A,[-ISUSBL,,ISUSBK]
	.SUSET A
	POPJ P,

LOGCAL:	SETZ		;.CALL BLOCK FOR ATTEMPTING TO LOG IN
	SIXBIT /LOGIN/
	[LGNM]
	SETZ [0]

ISUSBK:	.SMASK,,BADBTS
	.SIMASK,,IMSK
ISUSBL==.-ISUSBK

QTRNBK:	(SIXBIT /DSK/)	;RENAME BLOCK TO MAKE NEW DRDMP FILES LOOK OLD
	SIXBIT /DRDMP/
	SIXBIT /</
	SIXBIT /DRDOMP/
	SIXBIT />/

		;LOCATION COUNTER IS C, DO "GLOBAL" BLOCKS
IF1,[ALLLC==LICOD	;CHECK TO SEE WHETHER THERE'S LIKELY TO BE ENOUGH SPACE

DEFINE A.EVAL NAME
.OP .OPER@ SQUOZE 0,NAME,.EVAL,TERMIN
]
DEFINE ALRLC EXPR/
IF1,ALLLC==ALLLC+EXPR
TERMIN

ALLOC:		;DMNBF:	BLOCK DMNSZ*S DMNBEL
	MOVE A,C
	DEFSYM DMNBF
	MOVEI T,S DMNBEL	;LENGTH PER ENTRY
	IMULI T,DMNSZ	;# ENTRIES
	ADD C,T		;UPDATE LOCATION COUNTER TO POINT TO NEXT
	ALRLC DMNSZ*A.EVAL DMNBEL,	;UPDATE AT ASSEMBLY TIME FOR POSSIBLE ERROR PRINTOUT
		; ^ ADD MORE HERE
	MOVEM C,EDNCOD	;STORE FINAL LOCATION COUNTER
	POPJ P,

		;GIVE PROGRAM SYSTEM SYMBOLS

SYSYMG:	MOVE B,DDPTR	;GET EXEC DDT SYMBOL TABLE POINTER
	ASH B,-1	;DIVIDE COUNT FIELD BY 2
	ADDI B,SIGN	;FLUSH HALF-ENTRY
	HRR B,DDPTR	;UNCLOBBER ADDRESS PART
SYSYG2:	LDB TT,[400300,,(B)]	;LOOP POINT FOR NEW ITS SYM, GET FLAGS EXCEPT HALF-KILL
	SOJE TT,SYSYG3	;JUMP IF GLOBAL (CHECK IT FIRST, MOST COMMON)
	JUMPG TT,SYSYGK	;JUMP UNLESS PROGRAM NAME
	LDB C,[4000,,(B)]	;GET PROGRAM NAME
	AOJ B,
	CAME C,[SQUOZE 0,DDT]	;DDT?
SYSYGL:	AOBJN B,SYSYG2	;LOOP BACK UNLESS TABLE EXHAUSTED
	POPJ P,		;DONE

SYSST:	SMTBM		;DUMP OUT SYMBOL REQUESTS
SYSSTE::		;END OF SYSST
		;IF SYSSTE IS A FIRST MDT IN ASSEMBLY, A NEW SYMBOL WAS
		;REQUESTED AFTER THIS POINT IN THE ASSEMBLY; PLEASE UNDO

RADIX 2
SYSGNC==CONCAT .LENGTH /,\<SYSSTE-SYSST>/SYSGWS-1,/	;# TIMES CHECK TO BE MADE DURING SEARCH
RADIX 8		;BACK TO NORMAL

SYSYG3:	LDB C,[4300,,(B)]	;SYM IS GLOBAL
	MOVEI T,SYSST+1	;INITIALIZE INDEX INTO REQUEST TABLE, +1 TO POINT TO VALUE FOR SYSYDF
REPEAT SYSGNC,[FOO==SYSGWS_<SYSGNC-.RPCNT-1>	;INDEX INTO TABLE
	CAIGE T,SYSSTE-<FOO-1>	;NEW SLOT TOO HIGH?
	CAMGE C,FOO-1(T)	;NO, INCREMENT TO THERE?
	JRST .+2	;TOO HIGH OR NO INCREMENT
	ADDI T,FOO	;INCREMENT TO NEXT
]
	CAME C,-1(T)	;CHECK TO SEE IF SYM FOUND
	AOJA B,SYSYGL	;SYM NOT IN REQUEST TABLE
	MOVE A,1(B)	;GET VALUE OF SYSTEM SYM
	SOS SYSYFL	;ANOTHER SYSTEM SYMBOL DEFINED
SYSYG9:	PUSHJ P,SYSYDF	;DEFINE SYM (CLOBBERED DURING DEBUG)
SYSYGK:	AOJA B,SYSYGL	;BACK INTO LOOP

LBLK
		;PURIFICATION CODING (IN LOW BLOCK)

IFGE .-2000,PRINTA PURIFY MISPLACED INTO HIGH CORE.

PURIFY:	AOSE PUREL	;INCREMENT SWITCH (MUNGED AT INIT)
	JRST PURIFX	;DON'T DISCOURAGE MULTIPLE PURIFICATION
	MOVE P,[-LPDL,,PDL]
	PUSHJ P,PURIF1
	MOVE A,[PDL,,PDL+1]
	SETZM PDL
	BLT A,PDL+LPDL-1
PURIFX:	MOVE 0,[1,,2]
	MOVEI 1,0
	BLT 0,40
	MOVEI 0,0
	SETOM 34	;DON'T LET $Y WIN TO SYSTEM (NOT RECOMMENDED ELSEWHERE EITHER)
	.VALUE [ASCIZ /:PURIFIED/]
	JSR INITX

		;GUTS OF PURIFY ROUTINE

		;MACRO, HAS VALUE OF PAGE WORD WITH INSERT BIT SET

DEFINE PGWRD TYPE,WRBIT,VIRNR,ABSNR
<TYPE>_9+<WRBIT>_8,,SIGN+<VIRNR>_9+<ABSNR>TERMIN

PURIF1:	JSP Q,GETPG	;GET PAGES
	 PGWRD 0,1,HIBEG/2000,1,	;GET FROM SELF, RQ WRITE, UNDO OFFSET
	 HBLKS
	 .VALUE
	JSP Q,GETPG	;NOW INSERT SYSTEM IN LOW CORE (EXCEPT PAGE ZERO UNAVAILABLE)
	 PGWRD 1,0,1,1,	;GET FROM SYSTEM, READ ONLY
	 HIBEG/2000-1
	 .VALUE
MM.OP==.OP MOVEI 0,0	;MIDAS EFFECTIVE ADDRESS FOR .OP, .AOP
.AOP .OPER@ <DDPTR,,MM.OP>,.GETLOC	;GET DDPTR NOW
FOO==<,.AVAL2>/2000-10.	;LOWEST HIGH PAGE TO INSERT
	JSP Q,GETPG	;NOW GET SYSTEM SYMBOL TABLE
	 PGWRD 1,1,FOO,FOO
	 <-.AVAL2>_-<18.+10.>+12.	;EXTRA TWO FOR LAUGHS
	 .VALUE
	MOVEI A,SYSST	;NOW TO SORT SYSST: SET UP LOWER POINTER
	MOVEI B,SYSSTE	;SET UP LOWER POINTER
	MOVSI C,20000	;SET BIT TO SORT ON FIRST (FIRST BIT OF SQUOZE)
	JRST SORT	;SORT AND RETURN

CONSTA	;DUMP OUT CONSTANTS FOR INITIALIZATION CODING IN LOW BLOCKS
VARIAB
HBLK
EICOD::	;END OF HIGH INITIALIZATION CODING
HBLKS==<EICOD-HIBEG+1777>/2000	;# BLOCKS HIGH CODING
LBLK
ELICOD::	;END OF LOW INITIALIZATION CODING

PRINTA \<SYSSTE-SYSST>/SYSGWS, SYSTEM SYMS REQUESTED.
PRINTA \LSYCT, LS SYMS REQUESTED
IFN LSYCU,[PRINTA UNDEFINED LS SYMBOLS:
IF1,SLLOS		;DUMP OUT ERROR MESSAGES
]
PRINTA LOW CORE ROOM = ,\2000-ALLLC, WORDS.
PRINTA CORE = ,\HBLKS+1, BLOCKS.


END BEG
