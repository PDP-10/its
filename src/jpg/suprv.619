;;; -*- Mode: Lisp; Package: Macsyma; Ibase: 10 -*-

;	** (c) Copyright 1982 Massachusetts Institute of Technology **

(macsyma-module suprv)

;; #+MACLISP is ITS, Twenex, or Multics MacLisp.
;; #+PDP10 is ITS or Twenex MacLisp.
;; #+LISPM is the Lisp Machine or the Lisp Machine compiler running on ITS.
;; #+MACLISP and #+LISPM indicate which system a piece of code is intended
;; "for", not which system the code is being compiled "in".
;; #+GC means include gctime messages, and ok to call GCTWA here and there.
;; #-MAXII means not needed in new macsyma I/O and system organization.

;; Setting BASE to 10 at compile time needed for LAP to work.

(EVAL-WHEN (EVAL COMPILE)
  	   (SETQ OLD-IBASE IBASE OLD-BASE BASE) 
	   (SETQ IBASE 10. BASE 10.))

#+NIL
(EVAL-WHEN (EVAL COMPILE)
  (SET-FEATURE 'MAXII))

(DECLARE (GENPREFIX /\S) 
	 (SPECIAL M$+ GCFLAG GCT $LASTTIME $PARSETIME $DISPTIME
		  BINDLIST LOCLIST ERRSET $LABELS LINELABLE $BATCOUNT $FILESIZE
		  ST REPHRASE $DISPFLAG REFCHKL BAKTRCL RUBOUT TTYHEIGHT
		  CNTLY NEWLINE DSKFNP DSKSAVEP MOPL *RSET CNTL@
		  ^W ^R ^Q ^D LF TAB FF CNTLC ALT BATCONL CR VT ^H ^S BSP
		  $VALUES $FUNCTIONS $ARRAYS $ALIASES $GRADEFS $DEPENDENCIES
		  $RULES $PROPS $RATVARS $RATVARSWITCH DEBUG ERRBRKSW ERRCATCH
		  VARLIST GENVAR $DEVICE $FILENAME $FILENUM LBP RBP
		  $GENSUMNUM CHECKFACTORS $FEATURES FEATUREL $BACKTRACE
		  $WEIGHTLEVELS TELLRATLIST $DONTFACTOR $INFOLISTS LOADFILES
		  $DSKALL ERRLIST ALLBUTL LISPERRPRINT BACKRUB
		  GC-DAEMON GC-OVERFLOW DEMONL $DYNAMALLOC ALLOCLEVEL INFILE
		  ALARMCLOCK $C18MAXTIME $FILEID DCOUNT GCLINENUM THISTIME
		  $NOLABELS $BATCHKILL DISPFLAG SAVENO MCATCH BRKLVL SAVEFILE
		  STRING ST1 $PROMPT STIME0 $%% $ERROR
		  *IN-$BATCHLOAD* *IN-TRANSLATE-FILE*
		  LESSORDER GREATORDER $ERRORFUN MBREAK REPRINT POS $STRDISP
		  $DSKUSE SMART-TTY RUBOUT-TTY MORE-^W OLDST ALPHABET
		  $LOADPRINT TTYINTS OPERS
		  *RATWEIGHTS $RATWEIGHTS QUITMSG MQUITMSG CONTMSG
		  LOADF DISPLAY-FILE $GRIND SCROLLP $CURSORDISP
		  STRINGDISP $LISPDISP MEXPRP DEFAULTF READING
		  BPORG GCSYML ^AMSG ^BMSG ^HMSG
		  STATE-PDL PROMPTMSG GCPROMPT COMMAND PRINTMSG MRG-PUNT
		  NEW-C-LINE-HOOK TRANSP $CONTEXTS $SETCHECK $MACROS
		  UNDF-FNCTN AUTOLOAD)
#+LISPM  (SPECIAL ERROR-CALL)
#+Franz  (special ptport display-to-disk)
	 (*EXPR REPRINT)
	 (*LEXPR CONCAT $FILEDEFAULTS $PRINT)
	 (FIXNUM $FILESIZE DCOUNT $BATCOUNT I N N1 N2 TTYHEIGHT
		 $FILENUM THISTIME GCT TIM GCLINENUM ALLOCLEVEL
		 BRKLVL CMTCNT BPORG BPORG0 (COMPUTIME FIXNUM FIXNUM)
		 (CASIFY FIXNUM) (GETLABCHARN))
	 (FLONUM U1 STIME0)
	 (NOTYPE (ASCII-NUMBERP FIXNUM))
	 (ARRAY* (FIXNUM DISPLAY-FILE 1)))

;; This affects the runtime environment.  ALJABR;LOADER also does this, but
;; leave it here for other systems.  On the Lisp Machine, this is bound
;; per stack group.

#-LISPM (SETQ BASE 10. IBASE 10. *NOPOINT T)

#+PDP10
(PROG1 '(AUTOLOAD properties)
 (LET ((FILESPEC (PURCOPY '(FASL DSK MACSYM))))
   (MAPC #'(LAMBDA (X)
	    (LET ((FILE (IF (ATOM (CAR X)) (CONS (CAR X) FILESPEC) (CAR X))))
		 (DOLIST (FUN (CDR X)) (PUTPROP FUN FILE 'AUTOLOAD))))
	 '((LIMIT $LIMIT $LDEFINT) (IRINTE INTE)
	   (MATCOM $MATCHDECLARE $DEFMATCH $TELLSIMP $TELLSIMPAFTER $DEFRULE)
	   (MATRUN $DISPRULE $REMRULE $APPLY1 $APPLYB1 $APPLY2 $APPLYB2
		   APPLY1 APPLY1HACK APPLY2 APPLY2HACK
		   FINDBE FINDFUN FINDEXPON FINDBASE PART+ PART*)
;	   (MATCH $MATCHDECLARE $DEFRULE $DEFMATCH $RPPLY $MARKOV $MARKOB
;		  $APPLYTD1 $APPLYTD2 $APPLYBP1 $APPLYBP2 $ENABLE $DISABLE
;		  $TELLSIMP $TELLSIMPAFTER $TELLPRESIMP $TELLPOSTSIMP $BUILTIN
;		  $RULES $DISPRULE $REMRULE NEWRULE PRENABLE SIMPRULE DEFMRUN
;		  $APPLY1 $APPLY2 $APPLYB1 $APPLYB2 KILLRULE)
	   (TLIMIT $TLIMIT $TLDEFINT TLIMP) (HOMOG HREDUCE)
	   ((APLOT2 FASL DSK SHARE)
	    $PLOT2 $PLOT3D $PARAMPLOT2 $CONTOURPLOT2 $LOADPLOTS $GRAPH2
	    $GRAPH3D $NAMEPLOT $REPLOT $REPLOT4 $SAVEPLOTS)
	   ((TEKPLT FASL DSK SHARE)
	    $PLOTMODE $CLEAR $HARDCOPY $NAMEFILE PLOTMODE1)
	   ((LISPT FASL DSK LIBLSP) $TECO $TSTRING $EMACS)
	   (FORTRA $FORTRAN $FORTMX) (SCS $SCSIMP $DISTRIB $FACOUT)
	   (TRANSS $TRANSLATE $TRANSLATE_FILE $COMPFILE)
	   (TRANSL TRANSLATE-FUNCTION TRANSLATE-AND-EVAL-MACSYMA-EXPRESSION)
	   (MCOMPI $COMPILE $COMPILE_LISP_FILE)
	   (ALGFAC CPBGZASS CPTOM FIXMINPOLY FINDIBASE)
	   (NALGFA $SPLITFIELD $ALGFAC $PFACTORALG NALGFAC)
	   (OPTION $OPTIONS) (CPOLY $ALLROOTS) (LDISP LINEAR-DISPLA)
	   (DEFINT $DEFINT) (POLYRZ $NROOTS $REALROOTS STURM1)
	   (RISCH $RISCH RISCHINT) (OPTIM $OPTIMIZE $COLLAPSE)
	   (POIS3 $POISSIMP $PRINTPOIS $INTOPOIS $OUTOFPOIS) (POIS2 POISLIM1)
	   (ALGSYS $ALGSYS) (RESIDU $RESIDUE)
	   (MTRACE $TRACE $UNTRACE MACSYMA-UNTRACE $TIMER) (PRIMER $PRIMER)
	   (NEWDET $NEWDET $PERMANENT) ((CTENSR FASL DSK SHARE) $TSETUP)
	   (LAPLAC $LAPLACE $ILT) (SIN SININT INTEGRATOR)
	   (PADE $PADE) (SININT RATINT) (UFACT CPRES1)
	   (SERIES $POWERSERIES) (TRGRED $TRIGREDUCE SP1)
	   (HAYAT SRDISREP SRF SRCONVERT $TAYLOR $TAYLORINFO TAY-ORDER PSCOEFF1)
	   (FLOAT FPFORMAT BIGFLOAT2RAT FPPREC1 $BFLOAT FPSCAN FPENTIER
		  *FPATAN DIM-BIGFLOAT FP2FLO)
	   (EEZ EEZGCD) (NEWFAC NMULTFACT LCCHECK NCPBER3)
	   ((FASDMP FASL DSK LIBLSP) *FASDUMP) (SCHATC M1 M2 SCHATCHEN)
	   (NISIMP $LET $LETSIMP) (MDOT SIMPNCT SIMPNCEXPT)
	   (SUMCON $SUMCONTRACT $INTOSUM $BASHINDICES $NICEINDICES)
	   (SYNEX $PREFIX $INFIX $POSTFIX $NOFIX $MATCHFIX $NARY)
	   (RPART $REALPART $IMAGPART RIPART CABS $RECTFORM $POLARFORM $CABS
		  $CARG TRISPLIT)
	   (ZERO $ZEROEQUIV) (LOGARC $LOGARC LOGARC HALFANGLE) (SPRDET SPRDET)
	   (NEWINV NEWINV) (LINNEW TMLATTICE) (APROPO $APROPOS)
	   (NUMTH $PRIME $TOTIENT $DIVSUM $JACOBI $GCFACTOR)
	   ((ODE FASL DSK ODE) $ODE)
	   ((ODE2 FASL DSK SHARE) $ODE2) ((ELIM FASL DSK SHARE1) $ELIMINATE)
	   (ROMBRG $ROMBERG $ROMBERG_SUBR) ((DESOLN LISP DSK SHARE) $DESOLVE)
	   (NUMAPL SUBRCALLP SUBRCALL$P MACSYMACALLP FMAPPLY)
	   ((BESSEL FASL DSK SHARE) $BESSEL) ((INTSCE LISP DSK SHARE1) $INTSCE)
	   ((NUSUM > DSK SHARE) $NUSUM $FUNCSOLVE)
	   (SOLVE $SOLVE $LINSOLVE SOLVE SOLVEX)
	   (EZGCD $EZGCD FASTCONT EZGCD EZGCD2) ((HENSEL FASL DSK NRAT) SPHGCD)
	   ((INVERT LISP DSK SHARE1) $ADJOINT $INVERT)
	   (ASKP $ASKINTEGER ASK-INTEGER ASK-EVOD ASK-INTEGERP ASK-PROP)
	   ((DUMP FASL DSK SHARE) $DUMPARRAYS $LOADARRAYS)
	   (UPDATE $UPDATE_SAVED_FILE) (CHAR $GETCHARN)
	   (FCALL MFUNCTION-CALL TRD-MSYMEVAL EXPT$ M-TLAMBDA M-TLAMBDA& 
		  M-TLAMBDA&ENV M-TLAMBDA&ENV& FUNGEN&ENV-FOR-MEVAL 
		  FUNGEN&ENV-FOR-MEVALSUMARG M-TLAMBDA-I
		  COMPILE-FORMS-TO-COMPILE-QUEUE)
	   (EVALW $EVAL_WHEN) (SUSPEN $SUSPEND)
	   ((TRGSMP FASL DSK SHARE) $TRIGSIMP)
	   (INTPOL $INTERPOLATE $INTERPOLATE_SUBR)
	   ((ARRAY FASL DSK SHARE) $LISTARRAY $FILLARRAY $REARRAY)
	   ((DSKUSE FASL DSK SHARE2) $DISKUSE $FULLDISKUSE $PRINTDISKUSE $DISKFREE)
	   ((EIGEN FASL DSK SHARE) $EIGENVALUES $EIGENVECTORS)
	   (ACALL MARRAYREF MARRAYSET $ARRAYAPPLY $ARRAYSETAPPLY MFUNCALL 
		  DISPLAY-FOR-TR INSURE-ARRAY-PROPS MAPPLY-TR INTERVAL-ERROR
		  IS-BOOLE-CHECK MAKE-ALAMBDA $MAYBE *MMINUS)
	   (TRMODE $MODEDECLARE $DEFINE_VARIABLE DEF-MTRVAR $MODE_IDENTITY
		   ASSIGN-MODE-CHECK FLUIDIZE $BIND_DURING_TRANSLATION)
	   (TRPROP META-ADD2LNC META-PUTPROP META-MPUTPROP META-FSET)
	   (SUBLIS $SUBLIS) (MTREE $APPLY_NOUNS)
	   (MDEFUN MDEFUN MDEFUN-TR DEFMTRFUN DEFMTRFUN-EXTERNAL)
	   ((FILEOP FASL DSK SHARE)
	    $PRINTFILE $LISTFILES $QLISTFILES $FILELENGTH $FILELIST $RENAMEFILE)
	   (MMACRO MDEFMACRO $MACROEXPAND $MACROEXPAND1 MMACRO-APPLY MMACROEXPANDED
		   MMACROEXPAND MMACROEXPAND1)
	   ((LRATS FASL DSK SHARE2) $LRATSUBST $FULLRATSUBST)
	   ((PACKG FASL DSK SHAREM) $HERALD_PACKAGE $LOAD_PACKAGE)
	   ((STENSR > DSK LSH) $TRIGSUM)
	   (DOVER $DOVER_FILE $DOVARD_FILE)
	   (TRDEBG $LISPDEBUGMODE) (MTAGS TAGS-START//END)
	   (AR $MAKE_ARRAY DIMENSION-ARRAY-OBJECT ARRSTORE-EXTEND
	       MEVAL1-EXTEND)
	   (NUMER GET-ARRAY MAKE-TRAMP$)
	   ((QQ FASL DSK SHARE1) $QUANC8)
	   ((HYP FASL DSK SHARE1) $HGFRED HGFSIMP-EXEC CHECKSIGNTM)
	   ((HYPGEO FASL DSK SHARE1) $SPECINT)
	   (BUILDQ $BUILDQ MBUILDQ-SUBST)))))

; This page is for SPLITFILE AUTOLOAD properties

#+PDP10
(PROG1 '(SPLITFILE AUTOLOAD properties)
 (LET ((FILESPEC (PURCOPY '(FASL DSK MAXOUT))))
   (MAPC #'(LAMBDA (X)
	    (LET ((FILE (CONS (CAR X) FILESPEC)))
		 (DOLIST (FUN (CDR X)) (PUTPROP FUN FILE 'AUTOLOAD))))
	 '((DIFF2 DIFFINT DIFFSUM DIFFLAPLACE DIFFNCEXPT STOTALDIFF)  ; JPG;COMM2
	   (AT $ATVALUE $AT AT1) (DERIVD $DERIVDEGREE)
	   (BOX $DPART $LPART $BOX $REMBOX)
	   (ATAN2 SIMPATAN2) (ARITHF $FIBTOPHI $NUMERVAL)
	   (MAPF $SCANMAP SUBGEN) (LOGCON $LOGCONTRACT)
	   (RTCON $ROOTSCONTRACT) (NTERMS $NTERMS)
	   (GENMAT $GENMATRIX $COPYMATRIX $COPYLIST)
	   (ARRAYF $ARRAYMAKE $ARRAYINFO) (ADDROW $ADDROW $ADDCOL)
	   (ALIAS $MAKEATOMIC $ORDERGREAT $ORDERLESS $UNORDER)
	   (CONCAT $CONCAT $GETCHAR) (TTYINI $TTY_INIT)
	   (PLOG SIMPPLOG) (BINOML SIMPBINOCOEF BINOCOMP)  ; PAULW;CSIMP2
	   (GAMMA SIMPBETA SIMPGAMMA) (ERF SIMPERF)
	   (EMATRIX $ZEROMATRIX $EMATRIX) (COEFM $COEFMATRIX $AUGCOEFMATRIX)
	   (ENTERM $ENTERMATRIX) (XTHRU $XTHRU) (XRTOUT XRUTOUT)
	   (KRONEC PKRONECK) (RATWT $RATWEIGHT WTPTIMES WTPEXPT)  ; RAT;RATOUT
	   (FASTT $FASTTIMES) (HORNER $HORNER) (RATDIF $RATDIFF) (PFET $PFET)
	   (PFRAC $PARTFRAC PARTFRAC) (MODGCD NEWGCD)
	   (MRESUL $RESULTANT RESULTANT $POLY_DISCRIMINANT) ;RAT;RESULT
	   (SUBRES SUBRESULT)
	   (REDRES REDRESULT) (MODRES MODRESULT) (BEZOUT $BEZOUT)
	   (PLYGAM PSISIMP) (PLYLOG LISIMP)  ;WGD;SPECFN
	   (MSORT $SORT) (MAKEL $MAKELIST $SUBLIST)  ; DAS;MSTUFF
	   (SCUBIC SOLVECUBIC) (SQUART SOLVEQUARTIC)  ; MAXSRC;PSOLVE
	   (GRAPH $PLOT $GRAPH) (GRAPH2 $PARAMPLOT $MULTIGRAPH)  ; JPG;PLOT
	   (CFFUN $CF $CFEXPAND $CFDISREP $QUNIT)  ; RZ;COMBIN
	   (SUM SIMPSUM2) (MINFCT $MINFACTORIAL $FACTCOMB $MAKEFACT $MAKEGAMMA)
	   (DECOMP $POLYDECOMP POLYDECOMP)
	   (EULBRN $EULER SIMPEULER $BERN SIMPBERN $BERNPOLY)
	   (ZETA $ZETA $FIB) (PRODCT $PRODUCT SIMPPROD)
	   (TAYRAT $TAYTORAT)
	   (TRIGEX $TRIGEXPAND TRIGEXPAND)  ; MRG;TRIGO
	   (HYPER SIMP-%SINH SIMP-%COSH SIMP-%TANH SIMP-%COTH SIMP-%CSCH SIMP-%SECH)
	   (ATRIG SIMP-%ASIN SIMP-%ACOS SIMP-%ACOT SIMP-%ACSC SIMP-%ASEC)
	   (AHYPER SIMP-%ASINH SIMP-%ACOSH SIMP-%ATANH SIMP-%ACOTH SIMP-%ACSCH SIMP-%ASECH)
	   (OUTEX $MAKE_INDEX_FILE) (OUTEY $OPEN_INDEX_FILE)  ; MAXSRC;OUTEX
	   (DESCR $DESCRIBE MDESCRIBE $HELP) (EXAMPL $EXAMPLE)  ; MAXSRC;DESCRI
	   (STATUS $ALARMCLOCK $SEND $BUG $MAIL $WHO $TIMEDATE)  ; MAXSRC;OUTMIS
	   (ISOLAT $ISOLATE $PICKAPART $REVEAL)
	   (PROPFN $PROPERTIES $PROPVARS $PRINTPROPS)
	   (SCREEN $PAUSE $CLEARSCREEN)
	   (CHANGV $CHANGEVAR) (COMBF $COMBINE)
	   (FACSUM $FACTORSUM $GFACTORSUM) (FACOUT $FACTOROUT)))))

#+Franz
(eval-when (compile eval) (setsyntax '/ 2))  ; make esc a character
#+Franz (setq infile nil)

(PROGN (MAPC #'(LAMBDA (X) (PUTPROP (CAR X) (CADR X) 'OPALIAS))
	     '((+ $+) (- $-) (* $*) (// $//) (^ $^) (/. $/.) (< $<) (= $=)
	       (> $>) (/( $/() (/) $/)) (/[ $/[) (/] $/]) (/, $/,) (/: $/:)
	       (/! $/!) (/# $/#) (/' $/') (/; $/;)))
       #-MAXII
       (MAPC #'(LAMBDA (X) (PUTPROP (CAR X) (CADR X) 'OP2C))
	     '((* ((#/* . $**))) (^ ((#/^ . $^^)))
	       (/: ((#/= . $/:=) (#/: . $/:/:))) (/! ((#/! . $/!/!)))
	       (< ((#/= . $<=))) (> ((#/= . $>=))) (/' ((#/' . $/'/')))))
       #-MAXII
       (DEFPROP /: (((#/: #/=) . $/:/:=)) OP3C)       
       (MAPC #'(LAMBDA (X) (SET (CAR X) (ASCII (CADR X))))
	     '((CNTL@ #^@) (CNTLC #^C) (BSP #\BS) (TAB #\TAB) (LF #\LF)
	       (VT #\VT) (FF #\FF) (CR #\CR) (CNTLY #^Y) (SP #\SP)
	       (NEWLINE #\NEWLINE) (RUBOUT #\RUBOUT)))
       (SETQ GCSYML NIL)
       (DOTIMES (I 14.) (PUSH (GENSYM) GCSYML))
       (SETQ ALT #-MULTICS ' #+MULTICS '&)
#-LISPM (SETQ $PLOTUNDEFINED (*$ 2.0 -8.5070591E+37))
       (SETQ $LASTTIME '((MLIST) 0 0) THISTIME 0 GCT 0 GCFLAG NIL
	     $PARSETIME NIL $DISPTIME NIL MEXPRP NIL)
       (SETQ BATCONL NIL $BATCOUNT 0 $BATCHKILL NIL $STRDISP T $GRIND NIL)
       (SETQ $RATVARSWITCH T ZUNDERFLOW T MOPL NIL ALIASCNTR 100.)
       (SETQ REFCHKL NIL DEBUG NIL BAKTRCL NIL ERRBRKSW NIL MBREAK NIL $ERRORFUN NIL
	     ERRCATCH NIL DEMONL (LIST NIL) MCATCH NIL BRKLVL -1
	     ALLBUTL NIL LOADF NIL $BACKTRACE '$BACKTRACE)
       (SETQ *IN-$BATCHLOAD* NIL *IN-TRANSLATE-FILE* NIL)
       (SETQ BACKRUB #-Franz nil #+Franz t)
       (SETQ $DEBUGMODE NIL $BOTHCASES NIL
	     $PAGEPAUSE NIL $DSKGC NIL $POISLIM 5)
       (SETQ $PROMPT '_ $LOADPRINT T ^S NIL LOADFILES NIL)
;      (SETQ $FILEID NIL $C18MAXTIME 150.0E6)
       (SETQ $NOLABELS NIL $ALIASES '((MLIST SIMP)) LESSORDER NIL GREATORDER NIL)
       (SETQ $INFOLISTS
	     (PURCOPY '((MLIST SIMP) $LABELS $VALUES $FUNCTIONS $MACROS $ARRAYS
				     $MYOPTIONS $PROPS $ALIASES $RULES $GRADEFS
				     $DEPENDENCIES $LET_RULE_PACKAGES)))
       (SETQ $LABELS '((MLIST SIMP)) $DSKUSE NIL $DEVICE '$DSK $DISPFLAG T LINELABLE NIL)
       (SETQ REPHRASE NIL ST NIL OLDST NIL REPRINT NIL POS NIL)
       (SETQ DCOUNT 0 $FILENUM 0 $STORENUM 1000. $FILESIZE 16. $DSKALL T
	     NEW-C-LINE-HOOK NIL DSKFNP NIL TTYINTS T
	     GCLINENUM 0 DSKSAVEP NIL SAVENO 0 $DYNAMALLOC NIL ALLOCLEVEL 0)
       (SETQ QUITMSG  " "
	     MQUITMSG " (Into LISP.  Type control-G to get to MACSYMA.)" 
	     CONTMSG  "(Type <space> to continue, <return> to terminate.)"
	     ^AMSG    "  (Type EXIT; to exit.)"
	     ^BMSG   #-Multics "LISP  (Type <Alt>P<Space> to continue.)" 
		     #+Multics "LISP  (Type <Dollarsign>P<Carriage Return> to continue)"
	     ^HMSG "
(Use the RUBOUT or DEL(ETE) key to erase a character.)" ^DMSG-ON "
(Printout of GC statistics turned on.  Type control-D again to turn them off.)
"	     ^DMSG-OFF "
(Printout of GC statistics turned off.)
"	     GCPROMPT "Type ALL; NONE; a level-no. or the name of the space.
"	     MORE-^W NIL 
	     LISPERRPRINT T PRINTMSG NIL PROMPTMSG NIL MRG-PUNT NIL READING NIL)
;      (SETQ $CALCOMPNUM 100.)
       (SETQ STATE-PDL (PURCOPY (NCONS 'LISP-TOPLEVEL)))
#+MULTICS (SETQ $PLOT3DSIZE 20 $MULTGRAPH T)
#+MACLISP (SSTATUS _ T)
#+MACLISP (SSTATUS FEATURE NOLDMSG)
#+MULTICS (ALLOC '(LIST (150000. NIL 0.2)))
       '(Random properties))

;; Global variables defined by this package.

(DEFMVAR $% '$% "The last D-line computed, corresponds to lisp *" NO-RESET)
(DEFMVAR $INCHAR '$C
  "The alphabetic prefix of the names of expressions typed by the user.")
(DEFMVAR $OUTCHAR '$D
  "The alphabetic prefix of the names of expressions returned by the system.")
(DEFMVAR $LINECHAR '$E
  "The alphabetic prefix of the names of intermediate displayed expressions.")
(DEFMVAR $LINENUM 1 "the line number of the last expression." FIXNUM NO-RESET)
(DEFMVAR $DIREC 'JRMU
  "The default file directory for SAVE, STORE, FASSAVE, and STRINGOUT."
  NO-RESET)
(DEFMVAR CASEP T
  "Causes translation of characters from lower to upper case on ITS, 
   and from upper to lower case on Multics and Franz.")
;(DEFMVAR $ERREXP '$ERREXP)
(DEFMVAR USER-TIMESOFAR NIL)

#+Franz
(defmvar $ignoreeof nil
  "Causes EOFs at top level to be ignored, else an EOF brings the user to LISP level.")

#+PDP10 (DEFMVAR $TTYINTNUM #^U)
#+PDP10 (DEFMVAR $TTYINTFUN NIL)

(DEFVAR MOREMSG "--Pause--")
(DEFVAR MORECONTINUE "--Continued--")
(DEFVAR MOREFLUSH NIL)
(DEFMVAR $MOREWAIT NIL "needs to be documented" NO-RESET)

(DEFMVAR ALIASLIST NIL
 "is used by the MAKEATOMIC scheme which has never been completed"
 NO-RESET)

;; Again, something to do with a LAP intermediate.
#-NIL
(DECLARE (SETQ BASE 8))

;; Various system incompatibilities.  This should be restructured at some point.
;; System dependent functions are prefixed with "SYS-".

#-Multics
(DEFMACRO SYS-DEFAULTF (X) `(DEFAULTF ,X))

#+Multics
(DEFUN SYS-DEFAULTF (X)
       (SETQ X (NAMELIST X))
       (IF (EQ (CAR X) '*)
	   (DEFAULTF (CONS (CAR (DEFAULTF NIL)) (CDR X)))
	   (DEFAULTF X)))

(DEFUN SYS-GCTIME ()
  #-Franz (STATUS GCTIME)
  #+Franz (cadr (ptime)))

#.(SETQ NALT #-MULTICS #\ALT #+MULTICS #/&)

(DEFMVAR $CHANGE_FILEDEFAULTS #+PDP10 T #-PDP10 NIL
	 "Does DDT-style file defaulting iff T")

(DEFMVAR $FILE_STRING_PRINT #+PDP10 NIL #-PDP10 T
	 "If TRUE, filenames are output as strings; if FALSE, as lists.")

(DEFMVAR $SHOWTIME #-MULTICS NIL #+MULTICS T)

#-MAXII
(DEFUN CONTINUE NIL
  (LET ((STATE-PDL (CONS 'MACSYMA-TOPLEVEL STATE-PDL)))
       (PROG ($DISPFLAG TEST N REPRINT POS)
     #-(or Multics Franz) (SETQ ERRLIST '((ERRLFUN NIL)) QUITMSG MQUITMSG)
     #+(or Multics Franz) (SETQ ERRLIST '((SUPUNBIND) (CONTINUE)))
	     (IF (NULL REPHRASE) (SETQ ST NIL))
	A2   (IF (NOT (CHECKLABEL $INCHAR)) (SETQ $LINENUM (1+ $LINENUM)))
	A    (MAKELABEL $INCHAR) 
	A1   (IF ^S (SETQ #.TTYOFF NIL ^S NIL))
	     (MTERPRI)
	     (PRINTLABEL) 
	     (SETQ POS (CURSORPOS))
	     (IF (NOT (ZEROP (LISTEN))) (SETQ REPRINT T))
	     (IF NEW-C-LINE-HOOK (FUNCALL NEW-C-LINE-HOOK))
	B    (SETQ N (LET ((READING T)) (TYI)))
     #+Franz (cond ((greaterp n 0))
		   ($ignoreeof (go b))
		   (t (*break T '|Entering lisp:|) (go b)))
	     (COND ((= N #\FF) (FORMFEED) (GO VT))
		   ((= N #\VT) (GO VT)) 
		   ((= N #\BS) (COND (BACKRUB (IF ST (POP ST)) (GO B))
				     (T (LET (#.WRITEFILEP) (PRINC ^HMSG)) (GO VT))))
	   #+Franz ((= N #^B) (*break T '|Entering lisp:|) (go b))
		   ((= N #^Y)
		    (IF REPHRASE (SETQ REPHRASE NIL) (SETQ ST (APPEND OLDST ST)))
		    (GO REPRT)) 
		   ((OR (= N #\SP) (= N #\CR) (= N #\TAB))
		    (COND ((AND (NOT REPHRASE) ST) (PUSH N ST))
			  ((AND (NULL ST) (= N #\CR)) (SETQ POS (CURSORPOS))))
		    (GO B))
		   #-LISPM
		   ((= N #.NALT)  ; Enter the editor
		    (SETQ TEST (EDIT* (REVERSE ST))) (SETQ REPHRASE NIL)
		    (WHEN TEST (SETQ REPRINT T) (GO A1)) (GO REPRT))
		   (#-LISPM (< N 32.) #+LISPM (NOT (ZEROP (LDB %%KBD-CONTROL N)))
		    (SETQ REPRINT T) (GO B))  ; Test for control characters
		   (REPHRASE (SETQ REPHRASE NIL ST NIL)))
	     (COND ((= N #/;) (SETQ $DISPFLAG T) (GO D))
		   ((= N #/$) (SETQ $DISPFLAG NIL) (GO D))
		   ((= N #/?)
		    (WHEN (AND ST (= (CAR ST) #/?)
			       (NOT (AND (CDR ST) (= (CADR ST) #/\))))
			  (SETQ ST NIL) (GO A1))) 
		   ((AND (= N #/\) (PROG2 (SETQ ST (CONS N ST) N (TYI)) NIL)))
		   #-(or Franz Multics)
		   ((= N #\RUBOUT) (RUBOUT* ST) (IF ST (POP ST)) (GO B)))
	     (PUSH N ST) 
	     (GO B) 
	VT   (IF REPHRASE (SETQ REPHRASE NIL ST NIL)) 
	REPRT(REPRINT ST (= N #\FF)) (GO B)
	D    (SETQ REPRINT NIL)
	     (COND ((NULL ST) (GO A1))
		   (#.WRITEFILEP
		      (LET ((#.TTYOFF T))
			 (PRINC (MAKNAM (REVERSE (CONS N ST))))
	         #+Franz (terpr))))
	     (SETQ REPHRASE T OLDST ST)
	     (COND ((NULL (SETQ TEST (PARSE1))) (GO A))
		   ((NULL (SETQ TEST (CONTINUE1 (CAR TEST))))
		    (COND (MBREAK (ERRLFUN1 MBREAK)) (T (ERRLFUN T) (GO A2))))
		   (T (SETQ $% (CAR TEST)) (MAKELABEL $OUTCHAR)
		      (WHEN (NOT $NOLABELS)
			    (SET LINELABLE $%)
			    (PUTPROP LINELABLE (CONS (CADR $LASTTIME) (CADDR $LASTTIME))
				     'TIME))
		      (COND ($DISPFLAG (REMPROP LINELABLE 'NODISP) (DISPLAY*))
			    (T (PUTPROP LINELABLE T 'NODISP)))
		      (SETQ $LINENUM (1+ $LINENUM))))
	     (GO A))))
#+NIL
(DEFUN LINE-PROMPT ()
  (FORMAT () "(~A) " (MAKNAM (CDR (EXPLODEN LINELABLE)))))
#+NIL
;; this can be used anywere MREAD-WITH-PROMPT is defined.
(DEFUN CONTINUE ()
  (IF (NOT (CHECKLABEL $INCHAR)) (SETQ $LINENUM (1+ $LINENUM)))
  (DO ((STATE-PDL (CONS 'MACSYMA-TOPLEVEL STATE-PDL))
       ($DISPFLAG)
       (TEST))
      (())
    (MAKELABEL $INCHAR)
    (SETQ TEST (MREAD-WITH-PROMPT (LINE-PROMPT)))
    (IF (EQ (CAAR TEST) 'DISPLAYINPUT) (SETQ $DISPFLAG T))
    (SETQ TEST (CONTINUE1 (CADDR TEST)))
    (SETQ $% TEST)
    (MAKELABEL $OUTCHAR)
    (WHEN (NOT $NOLABELS)
	  (SET LINELABLE $%)
	  (PUTPROP LINELABLE (CONS (CADR $LASTTIME) (CADDR $LASTTIME))
		   'TIME))
    (COND ($DISPFLAG (REMPROP LINELABLE 'NODISP) (DISPLAY*))
	  (T (PUTPROP LINELABLE T 'NODISP)))
    (SETQ $LINENUM (1+ $LINENUM))))

#-MAXII
(DEFUN CONTINUE1 (TEST) 
 (LET ((STATE-PDL (CONS 'COMPUTING STATE-PDL)))
      (PROG (X THISTIME #+GC GCT)
	    #-Franz (MTERPRI)
	    (SETQ M$+ TEST)
	    (WHEN (NOT $NOLABELS)
		  (SET LINELABLE TEST)
		  (IF $DISPFLAG (REMPROP LINELABLE 'NODISP)
				(PUTPROP LINELABLE T 'NODISP)))
	    #+GC (IF GCFLAG (LET (^D) (GC)))
       	    #+GC (SETQ GCT (SYS-GCTIME))
	    (SETQ THISTIME (RUNTIME))
	    (SETQ TEST #-LISPM (ERRSET (MEVAL* TEST)) 
		       #+LISPM (TOP-MEVAL TEST)
		  $LASTTIME (LIST '(MLIST SIMP)
				  (COMPUTIME (RUNTIME) THISTIME)
				  #+GC (COMPUTIME (SYS-GCTIME) GCT) 
				  #-GC 0))
	    (WHEN $SHOWTIME (IF (NOT (ZEROP (CHARPOS T))) (MTERPRI))
			    (SETQ X (GCTIMEP $SHOWTIME (CADDR $LASTTIME)))
			    (MTELL-OPEN "~A msec." (CADR $LASTTIME))
			    (IF (NULL TEST) (PRINC " so far"))
			    #+GC (IF X (MTELL-OPEN "  GCtime= ~A msec."
						   (CADDR $LASTTIME)))
			    (MTERPRI))
	    (RETURN TEST))))
#+NIL
(DEFUN CONTINUE1 (TEST) 
 (LET ((STATE-PDL (CONS 'COMPUTING STATE-PDL))
       X THISTIME #+GC GCT WIN)
   (MTERPRI)
   (WHEN (NOT $NOLABELS)
	 (SET LINELABLE TEST)
	 (IF $DISPFLAG (REMPROP LINELABLE 'NODISP)
	     (PUTPROP LINELABLE T 'NODISP)))
   #+GC (IF GCFLAG (LET (^D) (GC)))
   #+GC (SETQ GCT (SYS-GCTIME))
   (SETQ THISTIME (RUNTIME))
   (UNWIND-PROTECT
    (PROG1 (MEVAL* TEST) (SETQ WIN T))
    (SETQ $LASTTIME (LIST '(MLIST SIMP)
			  (COMPUTIME (RUNTIME) THISTIME)
			  #+GC (COMPUTIME (SYS-GCTIME) GCT) 
			  #-GC 0))
    (WHEN $SHOWTIME (IF (NOT (ZEROP (CHARPOS T))) (MTERPRI))
	  (SETQ X (GCTIMEP $SHOWTIME (CADDR $LASTTIME)))
	  (MTELL-OPEN "~A msec." (CADR $LASTTIME))
	  #+GC (IF X (MTELL-OPEN "  GCtime= ~A msec."
				 (CADDR $LASTTIME)))
	  (IF (NOT WIN) (PRINC " so far"))
	  (MTERPRI)))))

(DEFMFUN MEVAL* (TEST)
 (LET (REFCHKL BAKTRCL CHECKFACTORS)
      (PROG2 (IF $RATVARSWITCH (SETQ VARLIST (CDR $RATVARS)))
	     (MEVAL TEST)
	     (CLEARSIGN))))

(DEFMFUN MAKELABEL (X)
 (WHEN (AND $DSKUSE (NOT $NOLABELS) (> (SETQ DCOUNT (1+ DCOUNT)) $FILESIZE))
       (SETQ DCOUNT 0) (DSKSAVE))
 (SETQ LINELABLE (CONCAT X $LINENUM))
 (IF (NOT $NOLABELS)
     (IF (OR (NULL (CDR $LABELS))
	     (WHEN (MEMQ LINELABLE (CDDR $LABELS))
		   (DELQ LINELABLE $LABELS 1) T)
	     (NOT (EQ LINELABLE (CADR $LABELS))))
	 (SETQ $LABELS (CONS (CAR $LABELS) (CONS LINELABLE (CDR $LABELS))))))
 LINELABLE)

(DEFMFUN PRINTLABEL NIL
 (MTELL-OPEN "(~A) " (MAKNAM (CDR (EXPLODEN LINELABLE)))))

(DEFMFUN MEXPLODEN (X &AUX (BASE 10.) (*NOPOINT T)) (EXPLODEN X))

(DEFMFUN ADDLABEL (LABEL)
 (SETQ $LABELS (CONS (CAR $LABELS) (CONS LABEL (DELQ LABEL (CDR $LABELS) 1)))))

(DEFMFUN TYI* NIL
 #+Multics (CLEAR-INPUT NIL)
 (DO N (TYI) (TYI) NIL
     (COND ((OR (= N #\NewLine) (AND (> N 31) (NOT (= N #\RUBOUT))))
	    (RETURN N))
	   ((= N #\FORM) (FORMFEED) (PRINC (STRIPDOLLAR $PROMPT))))))

(DEFUN CONTINUEP NIL
 (PRINC (STRIPDOLLAR $PROMPT))
 (= (TYI*) #-Multics #\Space #+Multics #\NewLine))

(DEFUN CHECKLABEL (X)  ; CHECKLABEL returns T iff label is not in use
 (NOT (OR $NOLABELS (= $LINENUM 0) (BOUNDP (CONCAT X $LINENUM)))))

(DEFUN GCTIMEP (TIMEP TIM)
 (COND ((AND (EQ TIMEP '$ALL) (NOT (ZEROP TIM))) (PRINC "Totaltime= ") T)
       (T (PRINC "Time= ") NIL)))

;; If $BOTHCASES is T, lower case letters will not be converted to upper case.

(DEFMFUN $BOTHCASES (X) (BOTHCASES1 NIL X))

(DEFUN BOTHCASES1 (SYMBOL VALUE)
 SYMBOL ;Always bound to $BOTHCASES.  Ignored.
 ;; This won't work with the Lisp Machine reader.
 #+MacLisp (DO I 97. (1+ I) (> I 122.)
	       (SETSYNTAX I (IF VALUE 1 321.) (IF VALUE I (- I 32.))))
 (SETQ CASEP (NOT VALUE)) VALUE)

;(DEFUN BACKSPACE1 (NIL X)
; (COND (X (ADD2LNC 8 ALPHABET)
;	  (SETSYNTAX 8 322. NIL))
;       (T (DELETE 8 ALPHABET 1)
;	  (SETSYNTAX 8 131392. NIL)))
; (SETQ BSPP X))

#+LISPM
(DEFUN LISTEN () 0)  ; Doesn't exist yet.

(DEFUN DISPLAY* (&AUX (RET NIL) (TIM 0))
 #+GC (IF (EQ GCFLAG '$ALL) (LET (^D) (GC)))
 (SETQ TIM (RUNTIME)
       RET (LET ((ERRSET 'ERRBREAK2) (THISTIME -1))
		(ERRSET (DISPLA (LIST '(MLABLE) LINELABLE $%)))))
 (IF (NULL RET) (MTELL "~%Error during display~%"))
 (IF $DISPTIME (MTELL-OPEN "Displaytime= ~A msec.~%" (COMPUTIME (RUNTIME) TIM)))
 RET)

#+PDP10
(DEFMFUN FORMFEED NIL (LET (#.TTYOFF) (CURSORPOS 'C)))

#+Franz
(defmfun formfeed nil (tyo #\ff))

#+MULTICS
(DEFMFUN FORMFEED NIL
 (IF (NOT (ZEROP (PAGEL NIL)))
     (IOG VT (MAPC 'TYO '(31. 32. 48. 119. 100. 74. 126. 36. 13.))
	  (CHARPOS NIL 0) (LINENUM NIL 0))
     (TYO 12.)))

#-(or Franz Multics)
(DEFMFUN RUBOUT* (STG)
 (LET (#.TTYOFF #.WRITEFILEP)
      (COND (RUBOUT-TTY
	     (COND ((OR REPRINT (NULL STG)
			(= (CAR STG) #\CR) (= (CAR STG) #\TAB))
		    (COND (SMART-TTY
			   (CURSORPOS (CAR POS) (CDR POS)) (CURSORPOS 'L)
			   (IF (CDR STG) (PRINC (MAKNAM (REVERSE (CDR STG)))))
			   (SETQ REPRINT NIL))
			  ((OR REPRINT STG) (REPRINT (CDR STG) NIL))))
		   (T (CURSORPOS 'X))))
	    (STG (TYO (CAR STG))))))

(DEFMFUN REPRINT (STG FFP)
 (LET (#.TTYOFF #.WRITEFILEP)
      (IF (NOT FFP) (MTERPRI))
      (CASEQ (CAR STATE-PDL)
	     (MACSYMA-TOPLEVEL (PRINTLABEL))
	     (RETRIEVE (IF (EQ MRG-PUNT 'BREAK) (PRINC (STRIPDOLLAR $PROMPT)))))
      (SETQ POS (CURSORPOS))
      (IF STG (PRINC (MAKNAM (REVERSE STG))))
      (SETQ REPRINT NIL)))

;; The PDP10 is one of the only systems which autoload.
;; The definition for non-autoloading systems is in MAXMAC. - CWH
;; For now we'll let a USER put autoload properties on symbols
;; and at least let them get found on Multics. - Jim 3/24/81
;; Franz also autoloads -- jkf
;;
#+(or Franz PDP10)
(DEFMFUN FIND-FUNCTION (FUNC) (OR (FBOUNDP FUNC) (LOAD-FUNCTION FUNC NIL)))

#+(or Franz MACLISP)
(DEFMFUN LOAD-FUNCTION (FUNC MEXPRP)  ; The dynamic loader
 (LET ((FILE (GET FUNC 'AUTOLOAD)))
      (IF FILE (FUNCALL AUTOLOAD (CONS FUNC FILE)))))

#+(or Franz MACLISP)
(DEFMFUN FIND0 (FUNCPAIR)  ; This is the normal value of AUTOLOAD.
 (LET (((FUNC . FILE) FUNCPAIR))
      (LET (MEXPRP) (LOAD-FILE FILE))
      (COND ((AND MEXPRP (GET FUNC 'MACRO))
	     (MERROR "LISP MACROs may not be called from MACSYMA level."))
	    ((OR (FBOUNDP FUNC) (AND MEXPRP (MFBOUNDP FUNC)))
	     ;; Win.  Lisp-defined, or called from macsyma level and
	     ;; is macsyma-defined.
	     (NCONS FUNC))
	    ((AND (NOT MEXPRP) (MFBOUNDP FUNC))
	     ;; Sort of a loss, called from lisp level, but defined
	     ;; only at macsyma level.  We want the undefined function
	     ;; handler to take over now, and make sure we never get called
	     ;; on this loser again.
	     (REMPROP FUNC 'AUTOLOAD)
	     (FUNCALL UNDF-FNCTN (NCONS FUNC)))
	    (T (MERROR "~A not found" FUNC)))))

(DEFMFUN LOAD-FILE (FILE) ($LOAD (TO-MACSYMA-NAMESTRING FILE)))

(DEFMSPEC $LOADFILE (FORM)
 (LOADFILE (FILESTRIP (CDR FORM)) NIL (NOT (MEMQ $LOADPRINT '(NIL $AUTOLOAD)))))



#-Franz
(DEFMSPEC $SETUP_AUTOLOAD (L)
 (SETQ L (CDR L))
 (IF (NULL (CDR L)) (WNA-ERR '$SETUP_AUTOLOAD))
 (LET ((FILE (NAMELIST (MERGEF ($FILENAME_MERGE (CAR L))
			       `((DSK ,(STATUS UDIR)) NOFILE)))))
      (DOLIST (FUNC (CDR L))
	      (NONSYMCHK FUNC '$SETUP_AUTOLOAD)
	      (PUTPROP (SETQ FUNC (DOLLARIFY-NAME FUNC)) FILE 'AUTOLOAD)
	      (ADD2LNC FUNC $PROPS)))
 '$DONE)

(DEFMFUN DOLLARIFY (L)
 (LET ((ERRSET 'ERRBREAK1))
      (CONS '(MLIST SIMP)
	    (MAPCAR #'(LAMBDA (X)
		       (LET (Y)
			    (COND ((NUMBERP X) X)
				  ((NUMBERP (SETQ Y (CAR (ERRSET
							  (READLIST
							   (MEXPLODEN X))
							  NIL))))
				   Y)
				  (T (MAKEALIAS X)))))
		    L))))

(DEFMFUN MFBOUNDP (FUNC)
 (OR (MGETL FUNC '(MEXPR MMACRO))
     (GETL FUNC '(TRANSLATED-MMACRO MFEXPR* MFEXPR*S))))

(DEFMFUN FILENAMEL (FILE)
 (COND ((ATOM FILE) (SETQ FILE (NCONS FILE)))
       (($LISTP FILE) (SETQ FILE (CDR FILE)))
       (T (MERROR "Not a proper filename ~M" FILE)))
 (FILESTRIP FILE))

#+MACLISP
(DEFMFUN LOADFILE (FILE FINDP PRINTP)  ; FILE may be in any acceptable LISP format.
 (LET ((TIM 0) ERROR (SAVENO 0) TRUEF RECURP (BPORG0 BPORG))
      (WHEN FINDP (SETQ TIM (RUNTIME))
		  (IF (NULL LOADF) (SETQ LOADF DEFAULTF) (SETQ RECURP T))
		  (IF (MEMQ $LOADPRINT '(NIL $LOADFILE)) (SETQ PRINTP NIL)))
      (SETQ TRUEF (TRUEFNAME FILE)) 
      (WHEN PRINTP (OR RECURP (MTERPRI))
		   (IF $FILE_STRING_PRINT
		       (MTELL-OPEN "~A being loaded" (NAMESTRING TRUEF))
		       (PRINL (APPEND (CDR TRUEF) (CAR TRUEF) '(|being loaded|))))
		   (MTERPRI))
      (WHEN (NULL
	     (ERRSET
	      (COND (FINDP (LET ((Y (NOINTERRUPT 'TTY))) (LOAD FILE) (NOINTERRUPT Y)))
		    (T (IF $CHANGE_FILEDEFAULTS (SYS-DEFAULTF FILE)) (LOAD FILE)))))
	    (NOINTERRUPT NIL) (SETQ ERROR T))
      (IF (NOT (= BPORG BPORG0))
	  (SETQ LOADFILES (CONS (LIST (NAMESTRING TRUEF) BPORG0 BPORG) LOADFILES)))
      (COND ((NOT FINDP) (IF $CHANGE_FILEDEFAULTS (SYS-DEFAULTF FILE)))
	    ((NOT RECURP) (IF LOADF (SETQ DEFAULTF LOADF LOADF NIL)) (TIMEORG TIM)))
      (WHEN ERROR
	    (WHEN (AND (= (SYS-FREE-MEMORY) 0) FINDP (FASLP TRUEF))
		  (MTELL-OPEN "Package not entirely loaded in.~%")
		  (MTELL-OPEN "You will probably have to load up a new MACSYMA!!~%"))
	    (LET ((ERRSET 'ERRBREAK1))
		 (MTELL-OPEN "~%Error in LOADFILE attempt") (ERROR)))
      (IF PRINTP (MTELL-OPEN "Loading done~%"))
      '$DONE))

#+LISPM  ; This is quite different from the Maclisp version.
(DEFMFUN LOADFILE (FILE FINDP PRINTP &AUX (SAVENO 0))
  (AND FINDP (MEMQ $LOADPRINT '(NIL $LOADFILE)) (SETQ PRINTP NIL))
  ;; Should really get the truename of FILE.
  (IF PRINTP (FORMAT T "~%~A being loaded.~%" FILE))
  (LOAD FILE)  ; LOAD will decide whether fasl or not, etc.
  '$DONE)

#+Franz
(DEFUN LOADFILE (FILE FINDP PRINTP )
  (AND FINDP (MEMQ $LOADPRINT '(NIL $LOADFILE)) (SETQ PRINTP NIL))
  (COND (PRINTP (MTERPRI)
		(PRINC FILE)  ; Should really get the truename.
		(PRINC '| being loaded.|)
		(MTERPRI)))
  (Load FILE)  ; LOAD will have to figure out whether fasl or not, etc.
  '$DONE)

(DEFMFUN TRUEFNAME (FILE)
 (OR (PROBEF FILE)
     (CLOSE (OPEN FILE '(IN FIXNUM)))
	; The OPEN is to generate the appropriate error handling.
	; The CLOSE is just to be nice.
     #+Multics FILE
	; The Multics CLOSE function returns T always. 
	; At least we know we can open and close the file.
	; On Multics PROBEF calls ALLFILES which demands access to
	; the directory. 
     ))

#-LISPM
(DEFMFUN MTRUENAME (FILEOBJ)
 (LET ((FILE (IF (EQ (STATUS OPSYS) 'ITS)
		 (TRUENAME FILEOBJ)
		 (TRUEFNAME (NAMELIST FILEOBJ)))))
      (MFILE-OUT FILE)))

#+LISPM
(DEFMFUN MTRUENAME (STREAM)
  (MFILE-OUT (UNEXPAND-PATHNAME (FUNCALL STREAM ':NAME))))

(DEFMFUN CARFILE (FILE)  ; FILE is in OldIO list format.
 (IF (= (LENGTH FILE) 3) (CDR FILE) FILE))

#-MAXII
(DEFMSPEC $BATCON (L) (SETQ L (CDR L))
 (COND ((OR (NULL L) (> (LENGTH L) 2)) (WNA-ERR '$BATCON))
       ((NULL BATCONL) (MERROR "BATCH and DEMO have never been called.")))
 (LET ((X (MEVAL (CAR L))))
      (BATCH1 (LIST (CONS '(MLIST) (CAR BATCONL))
		    (COND ((NULL X) $BATCOUNT)
			  ((EQ (TYPEP X) 'FIXNUM) X)
			  ((NOT (EQ X T)) (CAR L))
			  (T (1+ $BATCOUNT)))
		    (COND ((NULL (CDR L))
			   (COND ((EQ (TYPEP X) 'FIXNUM) (1- X))
				 ((OR (NULL X) (EQ X T)) (CADR BATCONL))
				 (T T)))
			  (T (MEVAL (CADR L)))))
	      (CADDR BATCONL)
	      $BATCOUNT
	      NIL)))

#-MAXII
(DEFMSPEC $BATCH (L) (BATCH1 (CDR L) NIL NIL NIL))

#-MAXII
(DEFMSPEC $DEMO (L) (BATCH1 (CDR L) T NIL NIL)) 

;; SPECP is T if the file is being batched for TRANSL, or $LOAD, 
;;	or some other special purpose.
#-Franz
(DEFMACRO FILEPOS-CHECK () `(IF SPECP (SETQ FILEPOS (FILEPOS FILE-OBJ))))
#+Franz
(defmacro filepos-check () nil)

#-MAXII
(DEFMFUN BATCH1 (L DEMOP BATCONP SPECP) 
 (LET ((FN (IF DEMOP '$DEMO '$BATCH)))
  (LET ((STATE-PDL (LIST* 'BATCH (IF *IN-TRANSLATE-FILE* '$TRANSLATE FN) STATE-PDL))
	(INFILE INFILE)
	(TRANSLP (AND SPECP (NOT *IN-$BATCHLOAD*))))
       (PROG (FILE TEST TEST1 TEST2 INDEX HIGH $DISPFLAG
	      FILEPOS ;; set to filepos at first token of expression read.
	      EOF /\FLAG X CMTP ^Q CMTCNT FILE-OBJ FILE-NAME)
	     (SETQ EOF (NCONS NIL) INDEX 1 HIGH -1 CMTCNT 0)
     
	     (COND ((OR (NULL L) (ATOM (CAR L)))
		    (SETQ FILE L)
		    (GO Z))
		   ((NOT (EQ (CAAAR L) 'MLIST)) (IMPROPER-ARG-ERR (CAR L) FN))
		   (T (SETQ FILE (CDAR L))))
	 Z1  (COND ((NULL (SETQ L (CDR L))) (GO Z))
		   ((NOT (ATOM (SETQ INDEX (MEVAL (CAR L)))))
		    (IMPROPER-ARG-ERR INDEX FN))
		   ((MEMQ INDEX '(T NIL)) (SETQ INDEX 1) (GO Z1))
		   ((NOT (EQ (TYPEP INDEX) 'FIXNUM))
		    (SETQ INDEX (MAKSTRING* INDEX))))
	     (WHEN (CDR L)
		   (IF (CDDR L) (WNA-ERR FN))
		   (SETQ X (MEVAL (CADR L)))
		   (COND ((AND (EQ (TYPEP INDEX) 'FIXNUM) (EQ (TYPEP X) 'FIXNUM))
			  (SETQ HIGH (- X INDEX)))
			 ((NULL X) (SETQ HIGH NIL))
			 ((NOT (EQ X T)) (IMPROPER-ARG-ERR X FN))))
	     
	     
	Z    (SETQ FILE (COND (BATCONP FILE)
			      ((AND BATCONL (NULL FILE)) (CAR (LAST BATCONL)))
			      (T (FILESTRIP FILE))))

	     (SETQ INFILE (SETQ FILE-OBJ (OPEN FILE '(READ ASCII))))
	     ;; If user does BATCH or DEMO, update the file defaults.
	     ;; Don't do this for file translation.
   #+MACLISP (IF (AND (NOT TRANSLP) $CHANGE_FILEDEFAULTS) (SYS-DEFAULTF FILE))
   #+LISPM   (SETQ FILE-NAME (FILE-EXPAND-PATHNAME FILE))
   #+MACLISP (SETQ FILE-NAME (TRUENAME FILE-OBJ))
   #+Franz   (setq file-name file)
		; Multics returns a true STRING from TRUENAME above. -JIM
   #+PDP10   (SETQ FILE-NAME (APPEND (CDR FILE-NAME) (CAR FILE-NAME)))
	     (IF TRANSLP (GO A))
	     (WHEN (AND $BATCHKILL BATCONL
			#+MACLISP (NOT (EQUAL FILE-NAME (CAR BATCONL)))
			#+LISPM   (NOT (EQUAL FILE-NAME (CAR (LAST BATCONL)))))
		   (KILL1 $BATCHKILL)
		   (IF (EQ $BATCHKILL T) ($RESET))
		   #+GC (GCTWA))
	     (SETQ BATCONL (LIST #-LISPM FILE-NAME
				 #+LISPM (UNEXPAND-PATHNAME FILE-NAME)
				 HIGH DEMOP
				 #+PDP10 FILE #-PDP10 FILE-NAME)
		   $BATCOUNT 0)

	     
	     (COND (SPECP (GO A))
		   ((EQUAL INDEX 1) (GO READ))
		   ((NOT (EQ (TYPEP INDEX) 'FIXNUM)) (GO ALOOP)))
	     
	     ;; skip over 'index' input expressions.
	     ;; 'test' will be the current character and 'test1' the
	     ;; previous character
	     
	     
      ILOOP  (COND ((EQ (SETQ TEST (READCH FILE-OBJ EOF)) EOF)
		    (SETQ $BATCOUNT (OR BATCONP 0))
		    (MERROR "Premature EOF in file"))
		   ((EQ TEST '/\) (READCH FILE-OBJ))
		   ((AND (EQ TEST '*) (EQ TEST1 '//)) (SETQ TEST1 NIL CMTP 1) (GO CMT))
		   ((MEMQ TEST '(/; $))
		    (SETQ $BATCOUNT (1+ $BATCOUNT))
		    (IF (= (SETQ INDEX (1- INDEX)) 1) (GO READ))))
	     (SETQ TEST1 TEST)
	     (GO ILOOP)
	     
      ALOOP  (COND ((= (SETQ TEST2 (TYI FILE-OBJ -1)) -1)
		    (SETQ $BATCOUNT (OR BATCONP 0))
		    (MERROR "~A not found in file" (MAKNAM INDEX)))
		   ((AND (PROG2 (SETQ TEST (ASCII (CASIFY TEST2))) (NULL TEST1))
			 (OR (< TEST2 32.) (EQ TEST '/ )))
		    (GO ALOOP))
		   ((AND (EQ TEST '*) (EQ (CAR TEST1) '//)) (SETQ CMTP 2) (GO CMT))
		   ((MEMQ TEST '(/; $))
		    (SETQ $BATCOUNT (1+ $BATCOUNT) TEST1 NIL) (GO ALOOP))
		   ((EQ TEST #-Franz CR #+Franz LF)
		    (SETQ TEST1 NIL)
		    (GO ALOOP))
		   ((EQ TEST '/\) (SETQ TEST1 (CONS TEST TEST1) TEST (READCH FILE-OBJ)))
		   ((EQ TEST '&)
		    (IF (EQ (CAR TEST1) '/ ) (SETQ TEST1 (CDR TEST1)))
		    (IF (AND (EQ (CAR TEST1) '&) (CDR TEST1) (NOT (EQ (CADR TEST1) '/\))
			     (EQUAL INDEX (REVERSE (CDR TEST1))))
			(GO READ))))
	     (SETQ TEST1 (CONS TEST TEST1))
	     (GO ALOOP)
	READ (SETQ $LINENUM (1+ $LINENUM)) 
	A    #+(OR PDP10 LISPM)
	     (SETQ TEST (IF #+PDP10 (NULL (STATUS FILEMODE FILE-OBJ))
			    #+LISPM (NOT (FILE-OPEN FILE-OBJ))
			    EOF
			    (READCH FILE-OBJ EOF)))
	     #-(OR PDP10 LISPM)
	     (SETQ TEST (READCH FILE-OBJ EOF))
	     (COND ((EQ TEST EOF) (MTERPRI)
				  ;; PDP10 Lisps do this automatically
				  #-PDP10 (CLOSE FILE-OBJ)
				  (RETURN '|&BATCH DONE|))
		   ((OR (EQ TEST '/ ) (EQ TEST #-Franz CR #+Franz LF)
			(EQ TEST LF) (EQ TEST FF) (EQ TEST TAB)
			#+MACLISP (OR (EQ TEST CNTLC) (EQ TEST CNTL@)))
		    (GO A))
		   (T ;; end of whitespace loop.
		    (FILEPOS-CHECK)))
	     (SETQ ST NIL)
	     (MAKELABEL $INCHAR) (MTERPRI) (PRINTLABEL)
	     (WHEN TEST2 (SETQ TEST2 NIL) (PRINC (MAKNAM INDEX)) (PRINC '|&& |))
	     (GO B1)

	     ;; collecting loop
	     ;; characters are collected in list 'st'.
	     ;; Collection ends when a ; or $ is seen and in that case
	     ;; control transfers to label 'd'
	     ;;
	B    (SETQ TEST (READCH FILE-OBJ EOF)) 
	B1   (COND (/\FLAG (SETQ /\FLAG NIL))
		   ((EQ TEST EOF)
		    (WHEN (NULL ST)
			  (MTERPRI) #+LISPM (CLOSE FILE-OBJ) (RETURN '|&BATCH DONE|))
		    (IF SPECP (SETQ #.TTYOFF NIL))
		    (MTELL "~%EOF met") (SETQ REPHRASE T) (GO ERR)) 
		   ((OR (EQ TEST '/ )
			(EQ TEST #-Franz CR #+Franz LF)
			(EQ TEST TAB))
		    (IF (NULL ST) (GO B)))
		   ((EQ TEST LF) (GO B))
#+MACLISP	   ((OR (EQ TEST CNTLC) (EQ TEST CNTL@)) (GO B))
		   ((EQ TEST FF) (WHEN ST (MTERPRI) (SETQ TEST '/ ) (GO C)) (GO B)) 
		   ((PROG2 (FILEPOS-CHECK)
			   ;; must be set here too because of whitespace loop above.
			   (AND (EQ TEST '*) ST (EQ (CAR ST) '//)))
		    (PRINC '*) (SETQ TEST1 NIL) (GO CMT))
		   ((EQ TEST '&)
		    (WHEN (AND (EQ (CAR ST) '&) (CDR ST) (NOT (EQ (CADR ST) '/\)))
			  (PRINC TEST) (PRINC '/ ) (SETQ ST NIL)
			  (WHEN (NULL HIGH) (CLOSE FILE-OBJ)
					    (RETURN '|&BATCH TERMINATED|))
			  (GO B)))
		   ((EQ TEST '/\) (SETQ /\FLAG T)) 
		   ((EQ TEST '/;) (SETQ $DISPFLAG T) (GO D)) 
		   ((EQ TEST '$) (SETQ $DISPFLAG NIL) (GO D))) 
	     (PRINC TEST) 	
	C    (IF REPHRASE (SETQ REPHRASE NIL ST NIL)) 
	     (SETQ ST (CONS TEST ST))
	     (GO B)
	     
	CMT  ;; comment scanner
	     ;; this is reached via a 'go' from a number of places.
	     ;; If 'cmtp' is 1 then go to 'iloop' after comment
	     ;; If 'cmtp' is 2 then go to 'aloop' after comment
	     ;; Otherwise go to B
	     (SETQ TEST (READCH FILE-OBJ EOF)) 
	     (COND ((EQ TEST EOF) (IF SPECP (SETQ #.TTYOFF NIL))
				  (MTELL "EOF met inside of comment")
				  (SETQ REPHRASE T) (GO ERR))
		   ((NOT (OR CMTP 
			     #-(or Franz Multics) (EQ TEST LF)
			     #+MACLISP (OR (EQ TEST CNTLC) (EQ TEST CNTL@))))
		    (PRINC TEST)))
	     (COND ((AND (EQ TEST '//) (EQ TEST1 '*)) 
		    (UNLESS (ZEROP CMTCNT)
			    (SETQ TEST1 NIL CMTCNT (1- CMTCNT)) (GO CMT))
		    (COND ((EQUAL CMTP 1) (SETQ CMTP NIL) (GO ILOOP))
			  ((EQUAL CMTP 2) (SETQ TEST1 NIL CMTP NIL) (GO ALOOP)))
		    (WHEN (NULL (SETQ ST (CDR ST))) (MTERPRI) (MTERPRI)) (GO B))
		   ((AND (EQ TEST '*) (EQ TEST1 '//))
		    (SETQ TEST1 NIL CMTCNT (1+ CMTCNT)) (GO CMT))) 
	     (SETQ TEST1 TEST)
 	     (GO CMT)

	     ;; end of scan.  At this point, a $ or ; has terminated
	     ;; a line of input which is sitting reversed in the list 'st'.
	     ;; The symbol 'test' still holds the $ or ;
	     ;;
	D    (PRINC TEST)

     #+Franz (terpr)
	
	     (DO L ST (CDR L) (NULL L) (RPLACA L (ASCII-CHK (CAR L))))
	     (SETQ OLDST ST $BATCOUNT (1+ $BATCOUNT))
	     (COND ((NULL ST) (GO D1))
		   ((NULL (SETQ REPHRASE T
				TEST (IF SPECP (LET (#.TTYOFF) (PARSE1)) (PARSE1))))
		    (GO ERR))
		   (SPECP (TRANSLATE-MACEXPR (CAR TEST) FILEPOS) (GO A))
		   ((NULL (SETQ TEST (CONTINUE1 (CAR TEST)))) (GO ERR)))
	     (SETQ $% (CAR TEST))
	     (MAKELABEL $OUTCHAR)
	     (UNLESS $NOLABELS
		     (SET LINELABLE $%)
		     (PUTPROP LINELABLE (CONS (CADR $LASTTIME) (CADDR $LASTTIME)) 'TIME))
	     (COND ($DISPFLAG (REMPROP LINELABLE 'NODISP)
			      (IF (NULL (DISPLAY*)) (GO ERR)))
		   (T (PUTPROP LINELABLE T 'NODISP)))
	     (SETQ $LINENUM (1+ $LINENUM)) 
	D1   (WHEN (AND DEMOP (LET (#.TTYOFF) (NOT (CONTINUEP))))
		   (CLOSE FILE-OBJ) (RETURN '|&DEMO TERMINATED|))
	     (WHEN (AND (EQ (TYPEP HIGH) 'FIXNUM)
			(NOT (< HIGH 0))
			(< (SETQ HIGH (1- HIGH)) 0))
		   (CLOSE FILE-OBJ) (RETURN '|&BATCH DONE|))
	     (GO A) 
	ERR  (CLOSE FILE-OBJ)
	     (LET ((ERRSET 'ERRBREAK1))
		  (IF SPECP (SETQ #.TTYOFF NIL))
		  (DO L ST (CDR L) (NULL L) (RPLACA L (ASCII-CHK (CAR L))))
		  (MERROR "~%Error in ~:M file"
			  (IF *IN-TRANSLATE-FILE* '$TRANSLATE FN)))))))

(DEFMSPEC $KILL (FORM) (MAPC #'KILL1 (CDR FORM)) #+GC (GCTWA) '$DONE)
 
(DEFMFUN KILL1 (X)
 ((LAMBDA (Z)
   (COND ((AND ALLBUTL (MEMQ X ALLBUTL)))
	 ((EQ (SETQ X (GETOPR X)) '$LABELS)
	  (DOLIST (U (CDR $LABELS))
		  (COND ((AND ALLBUTL (MEMQ U ALLBUTL))
			 (SETQ Z (NCONC Z (NCONS U))))
			(T (MAKUNBOUND U) (REMPROP U 'TIME)
			   (REMPROP U 'NODISP))))
	  (SETQ $LABELS (CONS '(MLIST SIMP) Z) $LINENUM 0 DCOUNT 0))
	 ((MEMQ X '($VALUES $ARRAYS $ALIASES $RULES $PROPS $LET_RULE_PACKAGES))
	  (MAPC #'KILL1 (CDR (SYMEVAL X))))
	 ((MEMQ X '($FUNCTIONS $MACROS $GRADEFS $DEPENDENCIES))
	  (MAPC #'(LAMBDA (Y) (KILL1 (CAAR Y))) (CDR (SYMEVAL X))))
	 ((EQ X '$MYOPTIONS))
	 ((EQ X '$TELLRATS) (SETQ TELLRATLIST NIL))
	 ((EQ X '$RATWEIGHTS) (SETQ *RATWEIGHTS NIL $RATWEIGHTS '((MLIST SIMP))))
	 ((EQ X '$FEATURES)
	  (COND ((NOT (EQUAL (CDR $FEATURES) FEATUREL))
		 (SETQ $FEATURES (CONS '(MLIST SIMP) (APPEND FEATUREL NIL))))))
	 ((OR (EQ X T) (EQ X '$ALL))
	  (MAPC #'KILL1 (CDR $INFOLISTS))
	  (SETQ $RATVARS '((MLIST SIMP)) VARLIST NIL GENVAR NIL
		CHECKFACTORS NIL GREATORDER NIL LESSORDER NIL $GENSUMNUM 0
		$WEIGHTLEVELS '((MLIST)) *RATWEIGHTS NIL $RATWEIGHTS '((MLIST SIMP))
		TELLRATLIST NIL $DONTFACTOR '((MLIST)) $SETCHECK NIL)
	  (KILLALLCONTEXTS))
	 ((SETQ Z (ASSQ X '(($CLABELS . $INCHAR) ($DLABELS . $OUTCHAR)
			    ($ELABELS . $LINECHAR))))
	  (MAPC #'(LAMBDA (Y) (REMVALUE Y '$KILL)) (GETLABELS* (EVAL (CDR Z)) NIL)))
	 ((AND (EQ (TYPEP X) 'FIXNUM) (NOT (< X 0))) (REMLABELS X))
	 ((ATOM X)
	  (SETQ Z (OR (AND (MEMQ X (CDR $ALIASES)) (GET X 'NOUN)) (GET X 'VERB)))
	  (COND ((OR (NULL ALLBUTL) (NOT (MEMQ Z ALLBUTL)))
		 (REMVALUE X '$KILL) (REMCOMPARY X)
		 (IF (MEMQ X (CDR $CONTEXTS)) ($KILLCONTEXT X))
		 (IF (MGET X '$RULE)
		     (LET ((Y (RULEOF X)))
			  (COND (Y ($REMRULE Y X))
				(T #+MACLISP (REMPROP X 'EXPR)
				   #-MACLISP (FMAKUNBOUND X)
				   (DELQ X $RULES 1)))))
		 (IF (AND (GET X 'OPERATORS) (RULECHK X)) ($REMRULE X '$ALL))
		 (IF (MGET X 'TRACE) (MACSYMA-UNTRACE X))
		 (WHEN (GET X 'TRANSLATED)
		       (REMOVE-TRANSL-FUN-PROPS X) 
		       (REMOVE-TRANSL-ARRAY-FUN-PROPS X))
		 (IF (NOT (GET X 'SYSCONST)) (REMPROP X 'MPROPS))
		 (DOLIST (U '(BINDTEST NONARRAY EVFUN EVFLAG OPERS SPECIAL MODE))
			 (REMPROP X U))
		 (DOLIST (U OPERS)
		         (IF (AND (REMPROP X U)
				  (EQ (GET X 'OPERATORS) 'SIMPARGS1))
			     (REMPROP X 'OPERATORS)))
		 (WHEN (MEMQ X (CDR $PROPS))
		       (REMPROP X 'SP2) (KILLFRAME X)
		       (LET ((Y (STRIPDOLLAR X)))
			    (REMPROP Y 'ALPHABET) (DELETE (GETCHARN Y 1) ALPHABET 1)))
		 (LET ((Y (GET X 'OP)))
		      (IF (AND Y (NOT (MEMQ Y MOPL)) (MEMQ Y (CDR $PROPS)))
			  (KILL-OPERATOR X)))
		 (REMALIAS X NIL) (DELQ X $ARRAYS 1) (REMPROPCHK X)
		 #+MACLISP (ARGS X NIL)
		 (DELETE (ASSOC (NCONS X) $FUNCTIONS) $FUNCTIONS 1)
		 (DELETE (ASSOC (NCONS X) $MACROS) $MACROS 1)
		 (LET ((Y (ASSOC (NCONS X) $GRADEFS)))
		      (WHEN Y (REMPROP X 'GRAD) (DELETE Y $GRADEFS 1)))
		 (DELETE (ASSOC (NCONS X) $DEPENDENCIES) $DEPENDENCIES 1)
		 (IF Z (KILL1 Z)))))
	 ((AND (EQ (CAAR X) 'MLIST) (EQ (TYPEP (CADR X)) 'FIXNUM)
	       (OR (AND (NULL (CDDR X)) (SETQ X (APPEND X (NCONS (CADR X)))))
		   (AND (EQ (TYPEP (CADDR X)) 'FIXNUM) (NOT (> (CADR X) (CADDR X))))))
	  (LET (($LINENUM (CADDR X))) (REMLABELS (- (CADDR X) (CADR X)))))
	 ((SETQ Z (MGETL (CAAR X) '(HASHAR ARRAY))) (REMARRELEM Z X))
	 ((AND (EQ (CAAR X) '$ALLBUT)
	       (NOT (DOLIST (U (CDR X)) (IF (NOT (SYMBOLP U)) (RETURN T)))))
	  (LET ((ALLBUTL (CDR X))) (KILL1 T)))
	 (T (IMPROPER-ARG-ERR X '$KILL))))
  NIL))

(DEFMFUN REMLABELS (N)
       (PROG (L X)
	     (SETQ L (LIST (EXPLODEN $INCHAR) (EXPLODEN $OUTCHAR) (EXPLODEN $LINECHAR)))
	LOOP (SETQ X (MEXPLODEN $LINENUM))
	     (DO L L (CDR L) (NULL L) (REMVALUE (IMPLODE (APPEND (CAR L) X)) '$KILL))
	     (IF (OR (MINUSP (SETQ N (1- N))) (= $LINENUM 0)) (RETURN NIL))
	     (SETQ $LINENUM (1- $LINENUM))
	     (GO LOOP)))

(DEFMFUN REMVALUE (X FN)
 (COND ((NOT (SYMBOLP X)) (IMPROPER-ARG-ERR X FN))
       ((BOUNDP X)
	(LET (Y)
	     (COND ((OR (SETQ Y (MEMQ X (CDR $VALUES))) (MEMQ X (CDR $LABELS)))
		    (COND (Y (DELQ X $VALUES 1))
			  (T (DELQ X $LABELS 1)
			     (REMPROP X 'TIME) (REMPROP X 'NODISP)
			     (IF (NOT (ZEROP DCOUNT)) (SETQ DCOUNT (1- DCOUNT)))))
		    (MAKUNBOUND X) T)
		   ((GET X 'SPECIAL) (MAKUNBOUND X) T)
		   (TRANSP (SET X X) T)
		   ((EQ X '$DEFAULT_LET_RULE_PACKAGE) T)
		   (T (MTELL "Warning: Illegal REMVALUE attempt:~%~M" X) NIL))))))

(DEFMFUN RULEOF (RULE)
 (OR (MGET RULE 'RULEOF)
     (LET ((OP (CAAADR (MGET RULE '$RULE))) L)
	  (AND (SETQ L (GET OP 'RULES)) (MEMQ RULE L) OP))))

(DEFMFUN $DEBUGMODE (X) (DEBUGMODE1 NIL X))

#-NIL
(DEFUN DEBUGMODE1 (ASSIGN-VAR Y)
 ASSIGN-VAR  ; ignored
 #+MACLISP (SETQ DEBUG (COND (Y (*RSET T) Y) (T (*RSET NIL))))
 #+Franz   (prog2 (setq debug y) (debugging y))
 #+LISPM   (SETQ DEBUG (SETQ *RSET Y)))

#-NIL
(DEFMFUN ERRBREAK (Y)  ; The ERRSET interrupt function
 (COND
  (DEBUG
   ((LAMBDA (BRKLVL VARLIST GENVAR ERRBRKL LINELABLE)
     (PROG (X ^Q #.TTYOFF O^R #+MACLISP ERRSET #+LISPM ERROR-CALL TIM $%% 
	    #+Franz errset
	    $BACKTRACE #+LISPM RETVAL OLDST)
           (SETQ #+(or Franz MACLISP) ERRSET #+LISPM ERROR-CALL 'ERRBREAK1)
	   (SETQ TIM (RUNTIME) $%% '$%%
		 $BACKTRACE (CONS '(MLIST SIMP) BAKTRCL))
           (SETQ O^R #.WRITEFILEP #.WRITEFILEP (AND #.WRITEFILEP (NOT DSKFNP)))
	   (MTERPRI)
	   (IF Y (PRINC 'MACSYMA-BREAK) (PRINC 'ERROR-BREAK))
	   (UNLESS (ZEROP BRKLVL) (PRINC " level ") (PRINC BRKLVL))
	   (PRINC ^AMSG)
	   (MTERPRI)
      A    (COND
	    ((NULL
	      (*CATCH 'MACSYMA-BREAK
		      (LET ((STATE-PDL (CONS 'MACSYMA-BREAK STATE-PDL)))
			   (ERRSET 
			    (COND ((EQ (SETQ X (RETRIEVE1 NIL 'BREAK)) '$EXIT)
				   (TIMEORG TIM) #+LISPM (SETQ RETVAL 'EXIT) (GO END))
				  ((EQ X '$LISP)
#+MACLISP			   (LET ((STATE-PDL (CONS 'LISP-BREAK STATE-PDL)))
					(*BREAK T 'LISP) (MTERPRI))  ; ^B also works
#+LISPM				   (SETQ RETVAL 'LISP)
#+LISPM				   (GO END))
				  ((EQ X '$TOPLEVEL)
				   (COND ((*CATCH 'MBREAK
						  (LET (ST OLDST REPHRASE
							(MBREAK (CONS BINDLIST LOCLIST)))
						       (SETQ $LINENUM (1+ $LINENUM))
						       (CONTINUE)))
					  (GO END))
					 (T (MTELL-OPEN "Back to the break~%"))))
				  (T (LET (($DISPFLAG DISPFLAG)) (SETQ $%% (MEVAL X)))
				     (IF DISPFLAG (DISPLA $%%) (MTERPRI))))))))
	     (ERRLFUN1 ERRBRKL)
	     (MTELL-OPEN "~%(Still in break loop)~%")))
	     (GO A)
      END  (PRINC "Exited from the break ")
	   (IF (NOT (ZEROP BRKLVL)) (PRINC BRKLVL))
	   (MTERPRI)
           (IF O^R (SETQ #.WRITEFILEP T))
#+(or Franz MACLISP)   (RETURN NIL) #+LISPM (RETURN RETVAL)))
    (1+ BRKLVL) VARLIST GENVAR (CONS BINDLIST LOCLIST) LINELABLE))))

#-NIL
(DEFUN ERRBREAK1 (IGNORE) IGNORE NIL)  ; Used to nullify ERRSETBREAKs

#-NIL
(DEFUN ERRBREAK2 (IGNORE)
	; An alternate ERRSET interr. function; used by PARSE and DISPLAY
 IGNORE  ; ignored
 (LET ((STATE-PDL (CONS 'LISP-BREAK STATE-PDL))) (*BREAK ERRBRKSW 'ERST)))

#-MAXII
(DEFUN MERRBREAK (X)  ; The ^A interrupt function
 (COND ((NOT (MEMQ 'EDIT STATE-PDL))
	(LET ((DEBUG T)
	      (STATE-PDL (CONS '^A-BREAK STATE-PDL))
	      #-Multics (MOREMSG "--Pause--"))
	     #+PDP10 (ENDPAGEFN T 'MORE-FUN)
	     #+PDP10 (IF (NULL X) (BUFFCLEAR NIL))
	     (IF (OR (NULL X) $SHOWTIME) (TIMESOFAR T))
	     #+MACLISP (NOINTERRUPT NIL)
	     (ERRBREAK T))
	#+PDP10 (TTYRETFUN T))
       (T (MTELL "~%Control-A does not work while editing~%"))))

;; The ^B interrupt function
(DEFUN MPAUSE (X)
  X ;Ignored       
  (LET ((STATE-PDL (LIST* 'LISP-BREAK '^B-BREAK STATE-PDL))
	(MOREMSG "--Pause--"))
       #+PDP10 (ENDPAGEFN T 'MORE-FUN)
       #+PDP10 (BUFFCLEAR NIL)
       (TIMESOFAR T)
       #+MACLISP (NOINTERRUPT NIL)
       (*BREAK T ^BMSG))
  #+PDP10 (TTYRETFUN T))

#+PDP10
(DEFUN BUFFCLEAR (FLAG)
 (COND (SMART-TTY (CLEAR-INPUT T) (IF FLAG (CLEAR-OUTPUT T)))
       (T (IF FLAG (CLEAR-OUTPUT T)) (CLEAR-INPUT T))))

#+(or Franz MACLISP)
(DEFUN TIMESOFAR (X)  ; The ^] interrupt function
 (LET ((#.TTYOFF (AND (EQUAL X 1) #.TTYOFF))
       (#.WRITEFILEP (AND #.WRITEFILEP (NOT DSKFNP))))
      (COND ((= THISTIME -1) (MTELL-OPEN "~%Computing the display now"))
	    ((NOT (ZEROP THISTIME))
	     (LET ((BASE 10.) (N 0))
		  (MTELL-OPEN "~%~A msec." (COMPUTIME (RUNTIME) THISTIME))
		  (IF (AND (EQ $SHOWTIME '$ALL)
			   (NOT (ZEROP GCT))
			   (NOT (ZEROP (SETQ N (COMPUTIME (SYS-GCTIME) GCT)))))
		      (MTELL-OPEN " (~A msec.)" N))
		  (IF USER-TIMESOFAR (MAPC #'FUNCALL (REVERSE USER-TIMESOFAR))))))
      (IF (NULL X) (MTERPRI))))

#+MACLISP
(DEFUN MQUIT (X)  ; The ^G interrupt function
 (IF (NULL X) (BUFFCLEAR T))
 (ERRLFUN 'MQUIT) (SETQ ERRLIST '((SUPUNBIND) (CONTINUE))) (^G))

#+PDP10
;; The ^S interrupt function
(DEFUN MQUIET (X Y)
       X Y ;Ignored.
       (CLEAR-OUTPUT T) (SETQ #.TTYOFF T ^S T))

(DEFMSPEC $TOBREAK (X)
 (IF MBREAK (*THROW 'MBREAK (CDR X))
	    (MERROR "TOBREAK may be used only within a MACSYMA break.")))

(DEFUN ERRLFUN (X)
 (WHEN (NULL
	(ERRSET
	 (PROGN #-LISPM (SETQ ^S NIL)
		#+PDP10 (CLOSE SAVEFILE)
		#-LISPM (IF LOADF (SETQ DEFAULTF LOADF LOADF NIL))
		#+PDP10 (ENDPAGEFN T 'MORE-FUN))))
       #-LISPM (SETQ ^Q NIL) (MTELL-OPEN "~%ERRLFUN has been clobbered."))
 (IF $ERRORFUN (IF (NULL (ERRSET (MAPPLY $ERRORFUN NIL $ERRORFUN)))
		   (MTELL "~%Incorrect ERRORFUN")))
 (WHEN (NULL
	(ERRSET
	 (PROGN (IF (NOT (EQ X 'MQUIT)) (SUPUNBIND)) (CLEARSIGN))))
       #-LISPM (SETQ ^Q NIL) (MTELL-OPEN "~%ERRLFUN has been clobbered."))
 (WHEN (NULL X) (PRINC QUITMSG) (SETQ QUITMSG " ")))

(DEFUN SUPUNBIND NIL
 (MUNBIND (REVERSE BINDLIST)) (DO NIL ((NULL LOCLIST)) (MUNLOCAL)))

(DEFUN ERRLFUN1 (MPDLS)
       (DO ((L BINDLIST (CDR L)) (L1)) ((EQ L (CAR MPDLS)) (MUNBIND L1))
	   (SETQ L1 (CONS (CAR L) L1)))
       (DO NIL ((EQ LOCLIST (CDR MPDLS))) (MUNLOCAL)))

(DEFUN GETALIAS (X) (COND ((GET X 'ALIAS)) ((EQ X '$FALSE) NIL) (T X)))

(DEFUN MAKEALIAS (X) (IMPLODE (CONS #/$ (EXPLODEN X))))

#-MAXII
(PROGN 'COMPILE

(DEFUN PARSE1 NIL
 (LET (RET (TIM 0))
      #+GC (IF (EQ GCFLAG '$ALL) (LET (^D) (GC)))
      (SETQ TIM (RUNTIME) RET (PARSE2))
      (IF $PARSETIME (MTELL-OPEN "~%Parsetime= ~A msec." (COMPUTIME (RUNTIME) TIM)))
      RET))

(DEFUN PARSE2 NIL
 (LET ((ERRSET #+(OR Franz MACLISP) 'ERRBREAK2 #+LISPM NIL))
      (ERRSET (PARSE3 (SCAN (REVERSE (CONS #/; ST)))) #+LISPM NIL)))

(DEFUN PARSE3 (STRING)
 (LET ((LINELABLE LINELABLE) (ST1 STRING)) (PARSE '$ANY 0)))

(DEFUN SCAN (INPUT)
       (PROG (ANS TOKEN CHAR X DOTP FLAG)
	B    (COND ((NULL INPUT) (COND ((NOT (EQ (CAR ANS) '$/;))
					(MERROR "~%Dangling /\")))
				 (RETURN (NREVERSE ANS)))
		   ((ASCII-NUMBERP (CAR INPUT)) (SETQ DOTP NIL) (GO NLOOP))
		   ((AND (= (CAR INPUT) #/.) (ASCII-NUMBERP (CADR INPUT)))
		    (SETQ DOTP T) (GO NLOOP))
		   ((= (CAR INPUT) #/") (GO DQUOT))
		   ((MEMBER (CAR INPUT) '(#\SP #\CR #\newline #\TAB)) (GO C))
		   ((ALPHABETP (CAR INPUT)) (GO VLOOP))
		   ((= (CAR INPUT) #/\)
		    (COND ((NOT (ALPHABETP (CADR INPUT))) (SETQ FLAG '/\))) (GO V\))
		   ((= (CAR INPUT) #/?)
		    (SETQ FLAG '?)
		    (COND ((= (CADR INPUT) #/") (SETQ INPUT (CDR INPUT)) (GO DQUOT))
			  ((= (CADR INPUT) #/\)
			   (SETQ TOKEN (CONS '// TOKEN)) (SETQ INPUT (CDR INPUT))))
		    (COND ((NULL (CDDR INPUT)) (MERROR "~%Misuse of ?")))
		    (GO V\)))
	     (SETQ CHAR (ASCII (CAR INPUT)))
	     (COND ((AND (SETQ X (GET CHAR 'OP3C))
			 (SETQ X (ASSOC (LIST (CADR INPUT) (CADDR INPUT)) X)))
		    (SETQ ANS (CONS (CDR X) ANS) INPUT (CDDDR INPUT)) (GO B))
		   ((AND (SETQ X (GET CHAR 'OP2C)) (SETQ X (ASSQ (CADR INPUT) X)))
		    (SETQ ANS (CONS (CDR X) ANS) INPUT (CDDR INPUT)) (GO B)))
	     (SETQ ANS (CONS (OR (GET CHAR 'OPALIAS)
				 (IMPLODE (LIST '$ (CAR INPUT))))
			     ANS))
	C    (SETQ INPUT (CDR INPUT))
	     (GO B)
	V\   (SETQ INPUT (CDR INPUT))
	     (SETQ TOKEN (CONS (CAR INPUT) TOKEN) INPUT (CDR INPUT))
	     (GO VL1)
	VLOOP(SETQ TOKEN (CONS (CASIFY (CAR INPUT)) TOKEN) INPUT (CDR INPUT))
	VL1  (COND ((NULL INPUT) (MERROR "~%Dangling /\"))
		   ((OR (ASCII-NUMBERP (CAR INPUT)) (ALPHABETP (CAR INPUT)))
		    (GO VLOOP))
		   ((= (CAR INPUT) #/\)
		    (COND ((EQ FLAG '?) (SETQ TOKEN (CONS '// TOKEN)))) (GO V\)))
	     (SETQ ANS (CONS (COND (FLAG (PROG2 NIL
						(COND ((EQ FLAG '/\)
						       (IMPLODE (CONS '& (NREVERSE TOKEN))))
						      ((NULL (SETQ TOKEN (ERRSET
									  (READLIST
									   (NREVERSE TOKEN))
									  NIL)))
						       (MERROR "~%Misuse of ?"))
						      (T (CAR TOKEN)))
						(SETQ FLAG NIL)))
				   (T (GETALIAS (IMPLODE (CONS '$ (NREVERSE TOKEN))))))
			; note that only $-ed tokens are GETALIASed.
			     ANS)
		   TOKEN NIL)
	     (GO B)
	NLOOP(SETQ TOKEN (CONS (CASIFY (CAR INPUT)) TOKEN) INPUT (CDR INPUT))
	     (COND ((OR (ASCII-NUMBERP (CAR INPUT))
			(AND (= (CAR INPUT) #/.) (NOT DOTP) (SETQ DOTP T)))
		    (GO NLOOP))
		   ((AND (= (CAR TOKEN) #/.) (SETQ TOKEN (CONS '/0 TOKEN)) NIL))
		   ((AND (MEMBER (CAR INPUT) '(#/E #/B #/e #/b)) DOTP (NULL FLAG)
			 (OR (AND (OR (= (CADR INPUT) #/+) (= (CADR INPUT) #/-))
				  (ASCII-NUMBERP (CADDR INPUT)))
			     (ASCII-NUMBERP (CADR INPUT))))
		    (SETQ TOKEN (CONS (CASIFY (CAR INPUT)) TOKEN)
			  FLAG (CASIFY (CAR INPUT))
			  INPUT (CDR INPUT))
		    (GO NLOOP)))
	     (SETQ ANS (CONS (COND ((MEMBER FLAG '(#/B #/b)) (SCANBF TOKEN))
				   (T (READLIST (NREVERSE TOKEN))))
			     ANS)
		   TOKEN NIL FLAG NIL)
	     (GO B)
	DQUOT(SETQ INPUT (CDR INPUT))
	     (COND ((NULL INPUT) (MERROR "~%/" must occur in pairs."))
		   ((= (CAR INPUT) #/\) (SETQ INPUT (CDR INPUT)))
		   ((= (CAR INPUT) #/")
		    (SETQ INPUT (CDR INPUT)
			  ANS (CONS (IMPLODE
				     (COND (FLAG (SETQ FLAG NIL) (NREVERSE TOKEN))
					   (T (CONS '& (NREVERSE TOKEN)))))
				    ANS)
			  TOKEN NIL)
		    (GO B)))
	     (SETQ TOKEN (CONS (CAR INPUT) TOKEN))
	     (GO DQUOT)))

#+PDP10
(DEFUN CASIFY (N)  ; lower case to upper case
 (IF (AND (>= N #/a) (<= N #/z) CASEP) (- N #.(- #/a #/A)) N))

#+(or Franz Multics)
(DEFUN CASIFY (N)  ; upper case to lower case
 (IF (AND (>= N #/A) (<= N #/Z) CASEP) (+ N #.(- #/a #/A)) N))

#+LISPM
(DEFUN CASIFY (N)
 (IF (OR CASEP (NOT (ZEROP (LDB %%KBD-CONTROL-META N)))) (CHAR-UPCASE N) N))

(DEFUN SCANBF (TOKEN)
       (PROG (FRAC XPT)
	     (IF (MEMBER (CAR TOKEN) '(#/+ #/-)) (SETQ TOKEN (CONS #/0 TOKEN)))
	XPT  (SETQ XPT (CONS (CAR TOKEN) XPT) TOKEN (CDR TOKEN))
	     (IF (NOT (MEMBER (CAR TOKEN) '(#/B #/b))) (GO XPT))
	     (SETQ TOKEN (CDR TOKEN))
	FRAC (SETQ FRAC (CONS (CAR TOKEN) FRAC) TOKEN (CDR TOKEN))
	     (IF (NOT (= (CAR TOKEN) #/.)) (GO FRAC))
	     (SETQ TOKEN (CDR TOKEN))
	     (RETURN (FPSCAN (CONS #/0 (NREVERSE TOKEN)) FRAC XPT))))

(DEFUN ASCII-CHK (X) (IF (NUMBERP X) X (GETCHARN X 1)))

;; END of MOBY #-MAXII PROGN 'COMPILE
)

;; (DEFMSPEC $F (FORM) (SETQ FORM (FEXPRCHECK FORM)) ...)
;; makes sure that F was called with exactly one argument and
;; returns that argument.

(DEFMFUN FEXPRCHECK (FORM)
 (IF (OR (NULL (CDR FORM)) (CDDR FORM))
     (MERROR "~:M takes just one argument." (CAAR FORM))
     (CADR FORM)))

(DEFMFUN NONSYMCHK (X FN)
 (UNLESS (SYMBOLP X)
	 (MERROR "The argument to ~:M must be a symbolic name. ~M" FN X)))

(DEFMFUN NONVARCHK (X FN FLAG 2NDP)
 (WHEN (OR (MNUMP X) (INTEGERP X) (AND FLAG (ATOM X) (CONSTANT X))
	   (AND (NOT (ATOM X)) (NOT (EQ (CAAR X) 'MQAPPLY)) (MOPP1 (CAAR X))))
       (MERROR "Non-variable~Margument to ~:M: ~M"
	       (IF 2NDP '|& 2nd | '|& |) FN X)))

(DEFMFUN PRINL (L) (DOLIST (X L) (PRINC X) (TYO #\SP)))

(DEFMFUN $PRINT N
 (IF (= N 0)
     '((MLIST SIMP))
     (LET ((L (LISTIFY N)))
	  (DO L L (CDDR L) (NULL L) (RPLACD L (CONS '| | (CDR L))))
	  (DISPLA (SETQ PRINTMSG (CONS '(MTEXT) L)))
	  (CADR (REVERSE L)))))

#-MAXII
(DEFMFUN $READ N
 (LET (PRINTMSG)
      (IF (> N 0) (APPLY #'$PRINT (LISTIFY N)))
      (MEVAL (RETRIEVE PRINTMSG 'NOPRINT))))

#-MAXII
(DEFMFUN $READONLY N
 (LET (PRINTMSG)
      (IF (> N 0) (APPLY #'$PRINT (LISTIFY N))) (RETRIEVE PRINTMSG 'NOPRINT)))

#-MAXII
(DEFUN RETR-PRINT (MSG FLAG)
 (COND ((NULL MSG))
       ((ATOM MSG) (PRINC MSG) (MTERPRI))
       (FLAG (MAPC #'PRINC (CDR MSG)) (MTERPRI))
       (T (DISPLA MSG) (MTERPRI))))

#-MAXII
(DEFMFUN RETRIEVE (MSG FLAG) (LET (OLDST) (RETRIEVE1 MSG FLAG)))

; RETRIEVE1 is also called by ERRBREAK.
; If MRG-PUNT is T, a (MAPC 'PRINC (CDR PROMPTMSG)) is done.
; This is to get around DISPLA bugs re terpri's in atoms
#-MAXII
(DEFUN RETRIEVE1 (MSG MRG-PUNT)
  (COND ((NOT (EQ MRG-PUNT 'NOPRINT)) (RETR-PRINT MSG MRG-PUNT)))
  (LET ((PROMPTMSG MSG) (STATE-PDL (CONS 'RETRIEVE STATE-PDL)))
       (PROG (TEST N ST REPRINT POS #.TTYOFF)
	A    (IF (EQ MRG-PUNT 'BREAK) (PRINC (STRIPDOLLAR $PROMPT)))
     #-Franz (SETQ POS (CURSORPOS))
     #-Franz (IF (NOT (ZEROP (LISTEN))) (SETQ REPRINT T))
	B    (SETQ N (LET ((READING T)) (TYI)))
	C    (COND ((= N #.NALT)
		    (WHEN (EDIT* (REVERSE ST)) (SETQ REPRINT T) (MTERPRI) (GO A))
		    (GO VT))
		   ((= N #/?)
		    (WHEN (AND ST (= (CAR ST) #/?)
			       (NOT (AND (CDR ST) (= (CADR ST) #/\))))
			  (SETQ ST NIL) (MTERPRI) (GO A)))
		   ((= N #\VT) (GO VT))
		   ((= N #\BS) (COND (BACKRUB (IF ST (POP ST)) (GO B))
				     (T (LET (#.WRITEFILEP) (PRINC ^HMSG)) (GO VT))))
		   ((= N #\FF) (FORMFEED) (GO FF))
		   (#+(or Franz MACLISP) (= N #^Y)
		    #+LISPM (AND (NOT (ZEROP (LDB %%KBD-CONTROL N))) (= N #^Y))
		    (SETQ ST (APPEND OLDST ST)) (GO VT))
		   ((OR (= N #\SP) (= N #\CR) (= N #\TAB))
		    (WHEN (NULL ST) (IF (= N #\CR) (SETQ POS (CURSORPOS))) (GO B)))
		   ((< N 32.) (SETQ REPRINT T) (GO B))  ; Test for control characters
		   ((OR (= N #/;) (= N #/$))
		    (IF (EQ MRG-PUNT 'BREAK) (SETQ DISPFLAG (= N #/;))) (GO D))
		   ((AND (= N #/\) (PROG2 (SETQ ST (CONS N ST) N (TYI)) NIL)))
		   ((= N #\RUBOUT) (RUBOUT* ST) (IF ST (POP ST)) (GO B)))
	     (PUSH N ST)
	     (GO B)
	FF   (LET (#.TTYOFF #.WRITEFILEP) (RETR-PRINT MSG (EQ MRG-PUNT T)))
	VT   (REPRINT ST (= N #\FF))
	     (GO B) 
	D    (SETQ REPRINT NIL)
	     (COND ((NULL ST) (MTERPRI) (GO A))
		   (#.WRITEFILEP
		      (LET ((#.TTYOFF T))
			 (PRINC (MAKNAM (REVERSE (CONS N ST))))
			 #+Franz (terpr))))
	     (SETQ OLDST ST)
	     (WHEN (SETQ TEST (PARSE2))
		   (IF (NULL ^Q) (MTERPRI)) (RETURN (CAR TEST)))
	     (MTERPRI)
	     (IF (EQ MRG-PUNT 'BREAK) (PRINC (STRIPDOLLAR $PROMPT)))
     #-Franz (SETQ POS (CURSORPOS))
     #-Franz (IF (NOT (ZEROP (LISTEN))) (SETQ REPRINT T))
	     (SETQ N (LET ((READING T)) (TYI)))
	     (COND (#+(or Franz MACLISP) (= N #^Y)
		    #+LISPM (AND (NOT (ZEROP (LDB %%KBD-CONTROL N))) (= N #^Y))
		    (GO VT))
		   ((NOT (= N #.NALT)) (SETQ ST NIL)))
	     (GO C))))

(DEFMSPEC $PLAYBACK (X) (SETQ X (CDR X))
  (LET ((STATE-PDL (CONS 'PLAYBACK STATE-PDL)))
       (PROG (L L1 L2 NUMBP SLOWP NOSTRINGP INPUTP TIMEP GRINDP INCHAR LARGP)
	     (SETQ INCHAR (GETLABCHARN $INCHAR))
			; Only the 1st alphabetic char. of $INCHAR is tested
	     (SETQ TIMEP $SHOWTIME GRINDP $GRIND)
	     (DO X X (CDR X) (NULL X)
		 (COND ((EQ (TYPEP (CAR X)) 'FIXNUM) (SETQ NUMBP (CAR X)))
		       ((EQ (CAR X) '$ALL))
		       ((EQ (CAR X) '$SLOW) (SETQ SLOWP T))
		       ((EQ (CAR X) '$NOSTRING) (SETQ NOSTRINGP T))
		       ((EQ (CAR X) '$GRIND) (SETQ GRINDP T))
		       ((EQ (CAR X) '$INPUT) (SETQ INPUTP T))
		       ((MEMQ (CAR X) '($SHOWTIME $TIME)) (SETQ TIMEP (OR TIMEP T)))
		       ((MEMQ (CAR X) '($GCTIME $TOTALTIME)) (SETQ TIMEP '$ALL))
		       ((SETQ L2 (LISTARGP (CAR X)))
			(SETQ L1 (NCONC L1 (GETLABELS (CAR L2) (CDR L2) NIL)) LARGP T))
		       (T (IMPROPER-ARG-ERR (CAR X) '$PLAYBACK))))
	     (COND ((AND LARGP (NULL NUMBP)) (GO LOOP))
		   ((AND (SETQ L (CDR $LABELS)) (NOT $NOLABELS)) (SETQ L (CDR L))))
	     (WHEN (OR (NULL NUMBP) (< (LENGTH L) NUMBP))
		   (SETQ L1 (REVERSE L)) (GO LOOP))
	     (DO ((I NUMBP (1- I)) (L2)) ((ZEROP I) (SETQ L1 (NCONC L1 L2)))
		 (SETQ L2 (CONS (CAR L) L2) L (CDR L)))
	LOOP (IF (NULL L1) (RETURN '$DONE))
	     ((LAMBDA (ERRSET INCHARP)
	       (ERRSET
		(COND ((AND (NOT NOSTRINGP) INCHARP)
		       (LET ((LINELABLE (CAR L1))) (MTERPRI) (PRINTLABEL))
		       (IF GRINDP (MGRIND (MEVAL1 (CAR L1)) NIL)
				  (MAPC #'TYO (MSTRING (MEVAL1 (CAR L1)))))
		       (IF (GET (CAR L1) 'NODISP) (PRINC '$) (PRINC '/;))
		       (MTERPRI))
		      ((OR INCHARP
			   (PROG2 (WHEN (AND TIMEP (SETQ L (GET (CAR L1) 'TIME)))
					(SETQ X (GCTIMEP TIMEP (CDR L)))
					(MTELL-OPEN "~A msec." (CAR L))
				   #+GC (IF X (MTELL-OPEN "  GCtime= ~A msec." (CDR L)))
					(MTERPRI))
				  (NOT (OR INPUTP (GET (CAR L1) 'NODISP)))))
		       (MTERPRI) (DISPLA (LIST '(MLABLE) (CAR L1) (MEVAL1 (CAR L1)))))
		      (T (GO A)))))
	      'ERRBREAK2 (= (GETLABCHARN (CAR L1)) INCHAR))
	     (IF (AND SLOWP (CDR L1) (NOT (CONTINUEP))) (RETURN '$TERMINATED))
	A    (SETQ L1 (CDR L1))
	     (GO LOOP))))

(DEFUN LISTARGP (X)
 (LET (HIGH)
      (IF (AND ($LISTP X) (EQ (TYPEP (CADR X)) 'FIXNUM)
	       (OR (AND (NULL (CDDR X)) (SETQ HIGH (CADR X)))
		   (AND (EQ (TYPEP (SETQ HIGH (CADDR X))) 'FIXNUM)
			(NOT (> (CADR X) HIGH)))))
	  (CONS (CADR X) HIGH))))

;(DEFUN C18BATCHER NIL 
;       ((LAMBDA (L USER)
;	 (GCTWA)
;	 (SETQ ALARMCLOCK '(LAMBDA (X) (*THROW 'TIMECHECK 'TOOMUCHTIME)))
;	 (ALARMCLOCK 'RUNTIME $C18MAXTIME)
;	 (COND ((NULL (ERRSET (UREAD BATIN /< DSK C18) NIL)) ($QUIT)))
;	 (TERPRI)
;	 (PRINL (APPEND (STATUS UREAD) '(BEGUN)))
;	 (TERPRI)
;	 (UWRITE DSK C18)
;	 (SETQ #.WRITEFILEP T #.TTYOFF T)
;	 (ERRSET (COND ((EQ (*CATCH 'TIMECHECK ($BATCH BATIN /< DSK C18)) 'TOOMUCHTIME)
;			(PRINC '|/
;you've taken more than the allotted time!|))
;		       (T (SETQ $% '$BATCH/ DONE) (MAKELABEL $OUTCHAR) (DISPLAY*))))
;	 (APPLY #'UFILE (LIST 'BATOUT (MAKNAM (COND ($FILEID (SETQ L (STRING* $FILEID)))
;						   (T (NREVERSE (MEXPLODEN (RUNTIME))))))))
;	 (UKILL BATIN /< DSK C18)
; 	 (COND ((AND $FILEID (> (LENGTH L) 3))
;		(SETQ USER (LIST (CAR L) (CADR L) (CADDR L)))
;		(VALRET (MAKNAM (APPEND (EXPLODEN '/:SEND/ ) USER (EXPLODEN '/ BATOUT/ )
;					L (EXPLODEN '/ IS/ NOW/ AVAILABLE/./
;// P))))))
;	 (COND ((NULL (ERRSET (UREAD BATIN /< DSK C18) NIL)) ($QUIT))
;	       (T (VALRET '/:MACSYMA/
;))))
;	NIL NIL))

(DEFMSPEC $ALIAS (FORM)
  (IF (ODDP (LENGTH (SETQ FORM (CDR FORM))))
      (MERROR "ALIAS takes an even number of arguments."))
  (DO ((L NIL (CONS (ALIAS (POP FORM) (POP FORM))
		    L)))
      ((NULL FORM)
       `((MLIST SIMP),@(NREVERSE L)))))

(DEFMFUN ALIAS (X Y)
  (COND ((NONSYMCHK X '$ALIAS))
	((NONSYMCHK Y '$ALIAS))
	((NOT (EQ (GETCHAR X 1) '$))
	 (MERROR "/"-ed symbols may not be aliased. ~M" X))
	((GET X 'REVERSEALIAS)
	 (IF (NOT (EQ X Y))
	     (MERROR "~M already is aliased." X)))
	(T (PUTPROP X Y'ALIAS)
	   (PUTPROP Y (STRIPDOLLAR X) 'REVERSEALIAS)
	   (ADD2LNC Y $ALIASES)
	   Y)))

(DEFMFUN REMALIAS (X REMP)
 (LET ((Y (AND (OR REMP (MEMQ X (CDR $ALIASES))) (GET X 'REVERSEALIAS))))
      (COND ((AND Y (EQ X '%DERIVATIVE))
	     (REMPROP X 'REVERSEALIAS) (DELQ X $ALIASES 1)
	     (REMPROP '$DIFF 'ALIAS) '$DIFF)
	    (Y (REMPROP X 'REVERSEALIAS) (REMPROP X 'NOUN) (DELQ X $ALIASES 1)
	       (REMPROP (SETQ X (MAKEALIAS Y)) 'ALIAS) (REMPROP X 'VERB) X))))

(DEFMFUN STRIPDOLLAR (X)
 (COND ((NOT (ATOM X))
	(COND ((AND (EQ (CAAR X) 'BIGFLOAT) (NOT (MINUSP (CADR X)))) (IMPLODE (FPFORMAT X)))
	      (T (MERROR "Atomic arg required:~%~M" X))))
       ((NUMBERP X) X)
       ((NULL X) 'FALSE)
       ((EQ X T) 'TRUE)
       ((MEMQ (GETCHAR X 1) '($ % &)) #-Franz (IMPLODE (CDR (EXPLODEN X)))
				      #+Franz (concat (substring x 2)))
       (T X)))

(DEFMFUN FULLSTRIP (X) (MAPCAR #'FULLSTRIP1 X))

(DEFMFUN FULLSTRIP1 (X)
 (OR (AND (NUMBERP X) X)
     (GET X 'REVERSEALIAS)
     (LET ((U (ASSQR X ALIASLIST))) (IF U (IMPLODE (STRING*1 (CAR U)))))
     (STRIPDOLLAR X)))

(DEFUN STRING* (X)
 (OR (AND (NUMBERP X) (EXPLODEN X))
     (LET ((U (ASSQR X ALIASLIST))) (IF U (STRING*1 (CAR U))))
     (STRING*1 X)))

(DEFUN STRING*1 (X) (LET (STRINGDISP $LISPDISP) (MAKESTRING X)))

(DEFUN MAKSTRING* (X)
 (SETQ X (STRING* X))
 (DO L X (CDR L) (NULL L) (RPLACA L (ASCII (CAR L))))
 X)

(DEFMFUN $NOUNIFY (X)
 (LET (Y U)
      (NONSYMCHK X '$NOUNIFY)
      (SETQ X (AMPERCHK X))
      (COND ((GET X 'VERB))
	    ((GET X 'NOUN) X)
	    ((OR (SETQ U (MEMQ (CAR (SETQ Y (EXPLODEC X))) '($ M)))
		 (NOT (EQ (CAR Y) '%)))
	     (SETQ Y (IMPLODE (CONS '% (IF U (CDR Y) Y))))
	     (PUTPROP Y X 'NOUN) (PUTPROP X Y 'VERB))
	    (T X))))

(DEFMFUN $VERBIFY (X)
 (NONSYMCHK X '$VERBIFY)
 (SETQ X (AMPERCHK X))
 (COND ((GET X 'NOUN))
       ((AND (= (GETCHARN X 1) #/%)
	     (PROG2 ($NOUNIFY (IMPLODE (CONS #/$ (CDR (EXPLODEN X))))) (GET X 'NOUN))))
       (T X)))

(DEFMFUN AMPERCHK (NAME)
 (IF (= (GETCHARN NAME 1) #/&)
     (OR (GET NAME 'OPR) (IMPLODE (CONS #/$ (CASIFY-EXPLODEN NAME))))
     NAME))

(DEFMFUN DOLLARIFY-NAME (NAME)
 (LET ((N (GETCHARN NAME 1)))
      (COND ((= N #/&)
	     (OR (GET NAME 'OPR)
		 (LET ((NAMEL (CASIFY-EXPLODEN NAME)) AMPNAME DOLNAME)
		      (COND ((GET (SETQ AMPNAME (IMPLODE (CONS #/& NAMEL))) 'OPR))
			    (T (SETQ DOLNAME (IMPLODE (CONS #/$ NAMEL)))
			       (PUTPROP DOLNAME AMPNAME 'OP)
			       (PUTPROP AMPNAME DOLNAME 'OPR)
			       (ADD2LNC AMPNAME $PROPS)
			       DOLNAME)))))
	    ((= N #/%) ($VERBIFY NAME))
	    (T NAME))))

(DEFMFUN $RANDOM N (APPLY #'RANDOM (LISTIFY N)))

(DEFMSPEC $STRING (FORM)
 (SETQ FORM (STRMEVAL (FEXPRCHECK FORM)))
 (SETQ FORM (IF $GRIND (STRGRIND FORM) (MSTRING FORM)))
 (SETQ ST (REVERSE FORM) REPHRASE T)
 (IMPLODE (CONS #/& FORM)))

(DEFMFUN MAKSTRING (X)
 (SETQ X (MSTRING X)) (DO L X (CDR L) (NULL L) (RPLACA L (ASCII (CAR L)))) X)

(DEFMFUN STRMEVAL (X)
 (COND ((ATOM X) (MEVAL1 X))
       ((MEMQ (CAAR X) '(MSETQ MDEFINE MDEFMACRO)) X)
       (T (MEVAL X))))

(PROG1 '(ALIAS properties)
       (MAPC #'(LAMBDA (X) (PUTPROP (CAR X) (CADR X) 'ALIAS)
			   (PUTPROP (CADR X) (CADDR X) 'REVERSEALIAS))
	     '(($BLOCK MPROG BLOCK) ($LAMBDA LAMBDA LAMBDA)
	       ($ABS MABS ABS) ($SUBST $SUBSTITUTE SUBST)
	       ($GO MGO GO) ($SIGNUM %SIGNUM SIGNUM)
	       ($RETURN MRETURN RETURN) ($FACTORIAL MFACTORIAL FACTORIAL)
	       ($NOUUO NOUUO NOUUO) ($RSET *RSET RSET)
	       ($IBASE IBASE IBASE) ($OBASE BASE OBASE) ($NOPOINT *NOPOINT NOPOINT)
	       ($MODULUS MODULUS MODULUS) ($ZUNDERFLOW ZUNDERFLOW ZUNDERFLOW)
	       ($TTYOFF #.TTYOFF TTYOFF) ($WRITEFILE_ON #.WRITEFILEP WRITEFILE_ON)
	       ($MODE_DECLARE $MODEDECLARE MODE_DECLARE)))
       (MAPC #'(LAMBDA (X) (PUTPROP (CAR X) (CADR X) 'ALIAS))
	     '(($RATCOEFF $RATCOEF) ($RATNUM $RATNUMER) ($TRUE T)
	       ($BINOM %BINOMIAL) ($DERIVATIVE $DIFF) ($PROD $PRODUCT)
	       ($BOTHCOEFF $BOTHCOEF))))

(DEFMFUN CASIFY-EXPLODEN (X)
 (SETQ X (EXPLODEN X))
 (IF (= (CAR X) #/&) (MAPCAR #'CASIFY (CDR X)) (CDR X)))

(DEFMSPEC $STRINGOUT (X)  (SETQ X (CDR X))
 ((LAMBDA (FILE ERROR L1)
  (SETQ FILE #-Franz (IF ($LISTP (CAR X))
			 (PROG1 #+MACLISP (FILESTRIP (CDAR X))
				 #+LISPM   (FULLSTRIP (CDAR X))
				 (SETQ X (CDR X)))
			 (MFILE))
	     #+Franz (prog1 (filestrip x) (setq x (cdr x))))
#+MACLISP
   (OPEN (CNAMEF SAVEFILE (CONS (CARFILE (CDDR FILE)) '(|!STRG!| OUTPUT))) '(OUT ASCII))
#+LISPM
   (SETQ SAVEFILE (OPEN (FILESTRIP (APPEND '(|!STRG!| OUTPUT) (CDDR FILE))) '(OUT ASCII)))
#+Franz
   (setq savefile (outfile file))
   (COND ((NULL
	   (ERRSET
	    (DO L X (CDR L) (NULL L)
		(COND ((MEMQ (CAR L) '($ALL $INPUT))
		       (SETQ L (NCONC (GETLABELS* $INCHAR T) (CDR L))))
		      ((EQ (CAR L) '$VALUES)
		       (SETQ L (NCONC (MAPCAN
				       #'(LAMBDA (X)
					  (IF (BOUNDP X)
					      (NCONS (LIST '(MSETQ) X (SYMEVAL X)))))
				       (CDR $VALUES))
				      (CDR L))))
		      ((EQ (CAR L) '$FUNCTIONS)
		       (SETQ L (NCONC (MAPCAR
				       #'(LAMBDA (X) (CONSFUNDEF (CAAR X) NIL NIL))
				       (CDR $FUNCTIONS))
				      (MAPCAN
				       #'(LAMBDA (X)
					  (IF (MGET X 'AEXPR)
					      (NCONS (CONSFUNDEF X T NIL))))
				       (CDR $ARRAYS))
				      (MAPCAR
				       #'(LAMBDA (X) (CONSFUNDEF (CAAR X) NIL NIL))
				       (CDR $MACROS))
				      (CDR L))))
		      ((SETQ L1 (LISTARGP (CAR L)))
		       (SETQ L (NCONC (GETLABELS (CAR L1) (CDR L1) T) (CDR L)))))
		(IF (NULL L) (RETURN NIL))
		(TERPRI SAVEFILE)
		(IF $GRIND (MGRIND (STRMEVAL (CAR L)) SAVEFILE)
		   #-Franz (PRINC (MAKNAM (MSTRING (STRMEVAL (CAR L))))
				  SAVEFILE)
		   #+Franz (mapc #'(lambda (ch) (tyo ch savefile))
				   (mstring (strmeval (car l)))))
		(IF (OR (AND (ATOM (CAR L)) (GET (CAR L) 'NODISP)) (NOT $STRDISP))
		    (TYO #/$ SAVEFILE)
		    (TYO #/; SAVEFILE)))))
	  (SETQ ERROR T)))
   (TERPRI SAVEFILE)
   #-Franz            (RENAMEF SAVEFILE FILE)
   #+(OR LISPM Franz) (CLOSE SAVEFILE)
   #+MacLisp          (SYS-DEFAULTF FILE)
   (IF ERROR (LET ((ERRSET 'ERRBREAK1)) (MERROR "Error in STRINGOUT attempt")))
   #+MACLISP (MTRUENAME SAVEFILE)
   #+(or Franz LISPM) (MFILE-OUT FILE))
  NIL NIL NIL))


;; Obsolete.  FPPREC:10 is the replacement.

#+PDP10 (PROGN 'COMPILE
	     (DEFMFUN $FPPREC (X) (FPPREC1 NIL X))
	     (DEFMFUN $POISLIM (X) (POISLIM1 NIL X)))

(DEFMSPEC $LABELS (CHAR)
 (SETQ CHAR (FEXPRCHECK CHAR))
 (NONSYMCHK CHAR '$LABELS)
 (CONS '(MLIST SIMP) (NREVERSE (GETLABELS* CHAR NIL))))

(DEFMFUN $%TH (X)
       (PROG (L OUTCHAR)
	     (IF (OR (NOT (EQ (TYPEP X) 'FIXNUM)) (= X 0))
		 (IMPROPER-ARG-ERR X '$%TH))
	     (IF (> X 0) (SETQ X (- X)))
	     (IF (CDR $LABELS)
		 (SETQ L (CDDR $LABELS) OUTCHAR (GETLABCHARN $OUTCHAR)))
	LOOP (IF (NULL L) (MERROR "Improper call to %TH"))
	     (IF (AND (= (GETLABCHARN (CAR L)) OUTCHAR) (= (SETQ X (1+ X)) 0))
		   ; Only the 1st alphabetic character of $OUTCHAR is tested.
		 (RETURN (MEVAL (CAR L))))
	     (SETQ L (CDR L))
	     (GO LOOP)))

(DEFMFUN GETLABELS (N1 N2 FLAG)  ; FLAG = T for STRINGOUT, = NIL for PLAYBACK and SAVE.
 (DO ((I N1 (1+ I)) (L1)
      (L (IF FLAG (LIST (EXPLODEN $INCHAR))
		  (LIST (EXPLODEN $INCHAR) (EXPLODEN $LINECHAR)
			(EXPLODEN $OUTCHAR)))))
     ((> I N2) (NREVERSE L1))
     (DO ((L L (CDR L)) (X (MEXPLODEN I)) (Z)) ((NULL L))
	 (IF (BOUNDP (SETQ Z (IMPLODE (APPEND (CAR L) X))))
	     (SETQ L1 (CONS Z L1))))))

(DEFMFUN GETLABELS* (CHAR FLAG)  ; FLAG = T only for STRINGOUT
 (DO ((L (IF FLAG (CDDR $LABELS) (CDR $LABELS)) (CDR L))
      (CHAR (GETLABCHARN CHAR)) (L1))
     ((NULL L) L1)
     (IF (= (GETLABCHARN (CAR L)) CHAR)
			; Only the 1st alphabetic character is tested.
	 (SETQ L1 (CONS (CAR L) L1)))))

(DEFMFUN GETLABCHARN (LABEL)
 (LET ((CHAR (GETCHARN LABEL 2))) (IF (= CHAR #/%) (GETCHARN LABEL 3) CHAR)))

#+MACLISP
(DEFMFUN $UUO NIL (SSTATUS UUOLINKS))

#+MULTICS
(DEFMFUN $CLINE (X) (CLINE (GET_PNAME (STRIPDOLLAR X))) '$DONE)

; Error-handling stuff, not converted for lisp-machine yet.

(DEFMSPEC $ERRCATCH (FORM)
 (LET ((ERRCATCH (CONS BINDLIST LOCLIST)) RET)
      (IF (NULL (SETQ RET (LET (DEBUG)
			       (ERRSET (MEVALN (CDR FORM)) LISPERRPRINT))))
	  (ERRLFUN1 ERRCATCH))
      (CONS '(MLIST) RET)))

;(DEFMFUN $ERROR N  ; Moved to MAXSRC;MERROR
; (LET ((MSG (LISTIFY N)))
;      (IF (> N 0) (APPLY #'$PRINT MSG))
;      (IF ERRCATCH (ERROR))
;      (IF DEBUG (LET (($ERROR (CONS '(MLIST SIMP) (FSTRINGC MSG))))
;		      (ERRBREAK NIL)))
;      (MQUIT T)))

#-MAXII
(DEFMFUN $BREAK N (PROG1 (APPLY #'$PRINT (LISTIFY N)) (MERRBREAK T)))

(DEFMSPEC $CATCH (FORM)
 (LET ((MCATCH (CONS BINDLIST LOCLIST)))
      (PROG1 (*CATCH 'MCATCH (MEVALN (CDR FORM))) (ERRLFUN1 MCATCH))))

(DEFMFUN $THROW (EXP)
 (IF (NULL MCATCH) (MERROR "THROW not within CATCH:~%~M" EXP))
 (*THROW 'MCATCH EXP))

(DEFMSPEC $TIME (L) (SETQ L (CDR L))
 (MTELL-OPEN "TIME or [TOTALTIME, GCTIME] in msecs.:~%")
 (CONS '(MLIST SIMP)
       (MAPCAR
	#'(LAMBDA (X)
	   (OR (AND (SETQ X (OR (GET X 'TIME)
				(AND (EQ X '$%) (CONS (CADR $LASTTIME)
						      (CADDR $LASTTIME)))))
		    (IF (= (CDR X) 0)
			(CAR X)
			(LIST '(MLIST SIMP) (CAR X) (CDR X))))
	       '$UNKNOWN))
	L)))

(DEFMFUN TIMEORG (TIM)
 (IF (> THISTIME 0) (SETQ THISTIME (+ THISTIME (- (RUNTIME) TIM)))))

; Take difference of two times, return result in milliseconds.
#+LISPM (DEFMFUN COMPUTIME (N1 N2) (// (* 50. (TIME-DIFFERENCE N1 N2)) 3.))

#+MACLISP
(DEFMFUN COMPUTIME (N1 N2) (// (- (+ N1 500.) N2) 1000.))

#+Franz (progn 'compile

;--- computime (n1,n2) :: compute time difference in milliseconds
;	n1,n2 : times in jiffies (1/60 ths of a second) 
; return: length of time from n2 to n1 in milliseconds
(defmfun computime (n1 n2) (// (* (- n1 n2) 1000.) 60.))

;--- runtime :: return total runtime for this process (in jiffies)
(defun runtime nil (car (ptime)))

)

#+PDP10 (PROGN 'COMPILE

(DEFMFUN $TO_LISP NIL (^G))

(DEFMFUN $QUIT NIL (VALRET '//.))  ; this format does a silent kill

(DEFMFUN $LOGOUT NIL
 (IF (STATUS HACTRN) (VALRET '/:LOGOUT/
)		     ($QUIT)))

;;Circlecross does something to the Lisp Machine reader at a very
;;low level.  It must be slashified here.

(DEFMFUN $DDT NIL (VALRET '|:/into DDT: //
|) '$DONE)
)

#+LISPM (PROGN 'COMPILE
(DEFMFUN $QUIT () (*THROW 'MACSYMA-QUIT NIL))
(DEFMFUN $LOGOUT () (LOGOUT))
)

#+Multics (PROGN 'COMPILE
(DEFMFUN $QUIT   () (QUIT))
(DEFMFUN $LOGOUT () (CLINE "logout"))
(DEFMFUN $DDT    () (IOC Z))
)

#+PDP10
(DEFMFUN FILESTRIP (X)
 (COND ((NULL X) (APPEND (CDR DEFAULTF) (CAR DEFAULTF)))
       ((NULL (CDR (SETQ X (FULLSTRIP X))))
	(SETQ X (MERGEF (CAR X) (CONS (CAR DEFAULTF)
				      (IF (EQ (STATUS OPSYS) 'ITS) '(* >)
								   '(* /1)))))
	(APPEND (CDR X) (CAR X)))
       ((NULL (CDDR X)) (APPEND X (CAR DEFAULTF)))
       ((NULL (CDDDR X))
	(IF (NUMBERP (CADDR X)) (MERROR "Bad file specification"))
		; To get around a bug in MERGEF.
	(SETQ X (MERGEF X DEFAULTF)) (APPEND (CDR X) (CAR X)))
       (T X)))

#+MULTICS
(DEFMFUN FILESTRIP (X)
 (COND ((NULL X) NIL)
       ((ATOM X) (FULLSTRIP1 X))
       (T (IF (NULL (CDR (SETQ X (FULLSTRIP X)))) (SETQ X (CAR X))) X)))


;--- filestrip
; argument is a list containing the filename, which is a symbol or string.
;
#+Franz
(defmfun filestrip (f)
   (cond ((null f) (merror "You must supply a filename~%"))
	 ((and (dtpr f)
	       (cond ((or (symbolp (car f)) (stringp (car f)))
		      (stripdollar (car f))))))
	 (t (merror "Illegal filename ~M" f))))

(DEFMFUN FILEPRINT (FNAME)  ; Takes filename in NAMELIST format.
 (COND ($FILE_STRING_PRINT (PRINC (NAMESTRING FNAME)) (PRINC "  "))
       (T (PRINC "[")
	  (PRINC (CADR FNAME)) (PRINC ", ")
	  (PRINC (CADDR FNAME)) (PRINC ", ")
	  (WHEN (CDDDR FNAME) (PRINC (CADDDR FNAME)) (PRINC ", "))  ; For TOPS-20
	  (PRINC (CAAR FNAME)) (PRINC ", ")
	  (PRINC (CADAR FNAME)) (PRINC "]  "))))

(DEFMFUN MFILE-OUT (FNAME)  ; Takes filename in NAMELIST or OldIO list format.
 (IF $FILE_STRING_PRINT
     (IMPLODE (CONS #/& (EXPLODEN (NAMESTRING FNAME))))
     (DOLLARIFY (IF (ATOM (CAR FNAME)) FNAME (APPEND (CDR FNAME) (CAR FNAME))))))

; File-processing stuff.  Lisp Machine version in MC:LMMAX;LMSUP.

#+PDP10
(DEFMSPEC $WRITEFILE (L) (SETQ L (CDR L))
 (IF #.WRITEFILEP (MERROR "File already open for writing."))
 (IF (> (LENGTH L) 2) (WNA-ERR '$WRITEFILE))
 (LET (U) (SETQ U (IF (AND L (NULL (CDR L))
			   (PROG2 (SETQ U (NAMELIST (FULLSTRIP1 (CAR L))))
				  (NOT (EQUAL (CAR U) (IF (EQ (STATUS OPSYS) 'ITS)
							  '(* *)
							  '(|| ||))))))
		      (CAR U)
		      (FULLSTRIP L)))
	  (SETQ U (APPLY #'UWRITE U) #.WRITEFILEP T)
	  (IF $FILE_STRING_PRINT
	      (IF (EQ (STATUS OPSYS) 'ITS)
		  (CONCAT '/& (CAR U) '/: (CADR U) '/;)
		  (CONCAT '/& (CAR U) '/: '< (CADR U) '>))
	      (DOLLARIFY U))))

#+Franz
(defmspec $writefile (l) 
   (setq display-to-disk (cadr l))
   (setq ptport (outfile (filestrip  (cdr l))))
   display-to-disk)

#+PDP10
(DEFMSPEC $APPENDFILE (L) (SETQ L (CDR L))
 (IF #.WRITEFILEP (MERROR "File already open for writing."))
 (APPLY #'UAPPEND (FILESTRIP L)) (SETQ #.WRITEFILEP T) ($FILEDEFAULTS))

#+Franz
(DEFMSPEC $APPENDFILE (L)
   (setq display-to-disk (cadr l))
   (setq ptport (outfile (filestrip (cdr l)) 'append))
   display-to-disk)

#+PDP10
(DEFMSPEC $CLOSEFILE (L) (SETQ L (CDR L))
 (APPLY #'UFILE (IF (NULL L) (MFILE) (FILESTRIP L)))
 (IF (AND (= (LENGTH L) 4) (NOT (EQ (CADAR DEFAULTF) (FULLSTRIP1 (CAR (LAST L))))))
     (MTELL "Warning: Specified CLOSEFILE directory is incorrect."))
 ($FILEDEFAULTS))

#+Franz
(DEFMSPEC $closefile (l) (SETQ L (CDR L))
   (close ptport)
   (setq l display-to-disk display-to-disk nil)
   l)

#-Franz
(DEFUN MFILE NIL
   (FULLSTRIP (LIST $FILENAME (SETQ $FILENUM (1+ $FILENUM)) $DEVICE $DIREC)))


#+MACLISP
(DEFMSPEC $DELFILE (L) (SETQ L (CDR L))
 (PROG2 (SETQ L (SYS-DEFAULTF (FILESTRIP L))) ($FILEDEFAULTS) (DELETEF L)))

#+MACLISP
(DEFMFUN $FILEDEFAULTS N
 (COND ((= N 1) (SYS-DEFAULTF (FILENAMEL (ARG 1))))
       ((> N 1) (WNA-ERR '$FILEDEFAULTS)))
 (LET ((FILE (OR (PROBEF DEFAULTF) DEFAULTF))) (MFILE-OUT FILE)))

;;; The Multics Version of Writefile and Closefile.
;;; Appendfile is not implemented yet.
#+MULTICS (PROGN 'COMPILE
(LOAD-MACSYMA-MACROS SYSTEM_ERROR_HANDLER)

(DEFMVAR WRITEFILE-IN-PROGRESS () "T if there is a writefile happening")
(DEFMVAR WRITEFILE-^R () "Value of ^R before writefile")
(DEFMVAR WRITEFILE-NAME "" "Full pathname of temporary writefile file")

(DEFUN MAKE-WRITEFILE-FILENAME (USER-SUPPLIED-NAME)
 (LET ((IS-A-DIR (SYSTEM-INTERFACE-ERROR ("Writefile")
		   (DIRECTORY-OR-FILE USER-SUPPLIED-NAME ""))))
   (COND ((NOT (STRING-EQUAL IS-A-DIR "directory"))
	  (MERROR "Writefile: ~:M is not a directory" USER-SUPPLIED-NAME))))
 (COND ((SYSTEM-INTERFACE-ERROR ("Writefile") 
	  (DIRECTORY-P USER-SUPPLIED-NAME 'APPEND))
	(STRING-APPEND USER-SUPPLIED-NAME ">writefile.output"))
       (T (MERROR "Writefile: You have incorrect directory access to ~:M."
		  USER-SUPPLIED-NAME))))
 
(DEFUN MAKE-CLOSEFILE-FILENAME (TEMPORARY-WRITEFILE-NAME ENTRYNAME 
			     &AUX (DIR-NAME 
				   (DIRECTORY-NAME TEMPORARY-WRITEFILE-NAME)))
  (IF (OR (STRING-SEARCH-CHAR #/> ENTRYNAME)
	  (STRING-SEARCH-CHAR #/< ENTRYNAME))
    (MERROR "Closefile: illegal entryname. ~:M" ENTRYNAME))
  (LET ((PATHNAME (SYSTEM-INTERFACE-ERROR ("Closefile")
		    (ABSOLUTE-PATHNAME (STRING-APPEND DIR-NAME ">" 
						      ENTRYNAME)))))
    PATHNAME))

(DEFMSPEC $WRITEFILE (X) (SETQ X (CDR X))
  (IF (NOT (NULL WRITEFILE-IN-PROGRESS))
    (MERROR "Writefile: writefile already in progress."))
  (LET ((USER-SUPPLIED-NAME ()))
    (COND ((> (LENGTH X) 1) (WNA-ERR '$WRITEFILE))
	  ((= (LENGTH X) 1) (SETQ USER-SUPPLIED-NAME (STRIPDOLLAR (CAR X))))
	  (T (SETQ USER-SUPPLIED-NAME (PATHNAME-UTIL "hd"))))
    (SETQ WRITEFILE-NAME (MAKE-WRITEFILE-FILENAME USER-SUPPLIED-NAME))
;;;THE ABOVE EITHER ERRS OUT OR GIVES SOMETHING BACK.
    (PUSH (OPEN WRITEFILE-NAME '(OUT ASCII)) OUTFILES)
    (SETQ WRITEFILE-^R #.WRITEFILEP)
    (SETQ #.WRITEFILEP T)
    (SETQ WRITEFILE-IN-PROGRESS T)
    `((MLIST) ,(STRING-TO-MSTRING WRITEFILE-NAME))))
    
(DEFMSPEC $CLOSEFILE (ENTRY-NAME) (SETQ ENTRY-NAME (CDR ENTRY-NAME))
  (IF (NOT (EQUAL (LENGTH ENTRY-NAME) 1))
    (WNA-ERR '$CLOSEFILE))
  (SETQ ENTRY-NAME (CAR ENTRY-NAME))
  (COND ((MSTRINGP ENTRY-NAME)
	 (SETQ ENTRY-NAME (MSTRING-TO-STRING ENTRY-NAME)))
	((SYMBOLP ENTRY-NAME)
	 (SETQ ENTRY-NAME (STRING (STRIPDOLLAR ENTRY-NAME))))
	(T (MERROR "Closefile: ~:M illegal argument" ENTRY-NAME)))
  (LET ((NEW-FILENAME (MAKE-CLOSEFILE-FILENAME WRITEFILE-NAME ENTRY-NAME))
	(OPEN-WRITEFILE (CAR OUTFILES)))
    (CLOSE OPEN-WRITEFILE)
    (RENAMEF OPEN-WRITEFILE NEW-FILENAME)
    (POP OUTFILES)
    (SETQ #.WRITEFILEP WRITEFILE-^R)
    (SETQ WRITEFILE-^R ())
    (SETQ WRITEFILE-IN-PROGRESS ())
    (SETQ WRITEFILE-NAME ())
    `((MLIST) ,(STRING-TO-MSTRING NEW-FILENAME))))
)
;;; End of Multics version of WRITEFILE, CLOSEFILE code.

;; This prevents single blank lines from appearing at the top of video 
;; terminals.  If at the upper left corner and we want to print a blank 
;; line, leave the cursor there and send the blank line to transcript 
;; files only.

#+(OR PDP10 NIL LISPM)
(DEFMFUN MTERPRI (&AUX (X (CURSORPOS)))
 (IF (AND SMART-TTY X (EQUAL X '(0 . 0)))
     (LET ((#.TTYOFF T)) (TERPRI))
     (TERPRI)))

#+(or Franz Multics) 
(DEFMFUN MTERPRI () (TERPRI))

#+PDP10
(DEFMFUN MORE-FUN (NIL)
 (ENDPAGEFN T NIL)
 (COND ((NOT (OR (< (CAR (OR (CURSORPOS) '(0 . 0))) 10.)
		 (= (- TTYHEIGHT 2) (CAR (CURSORPOS)))))
	(CURSORPOS 'E) (SLEEP .01)))
 (NOINTERRUPT NIL)
 (COND ((= 0 (BOOLE 1 1_25. (CADDR (STATUS TTY))))
	(CURSORPOS 'Z) (CURSORPOS '/])
	((LAMBDA (^Q)
	  ((LAMBDA (#.WRITEFILEP #.TTYOFF STATE-PDL)
	    (PRINC MOREMSG) (TYIPEEK)
	    (IF $MOREWAIT
		(DO ((L (IF (EQ $MOREWAIT '$ALL)
			    '(#\SP #\CR)
			    '(#\SP #\CR #\RUBOUT))))
		    ((MEMBER (TYIPEEK) L))
		    (TYI))
		(DO () ((NOT (MEMBER (TYIPEEK) '(#^D #^S #^V #^]))))
		       (TYI)))
	    (COND (SMART-TTY (CURSORPOS 'Z) (CURSORPOS '/])) (T (TERPRI))))
	   NIL NIL (CONS 'MORE-WAIT STATE-PDL))
	  (COND ((= #\SP (TYIPEEK))
		 (IF MORECONTINUE (LET (#.WRITEFILEP #.TTYOFF) (PRINC MORECONTINUE))) (TYI))
		((= #\RUBOUT (TYIPEEK))
		 (LET ((#.TTYOFF T)) (TERPRI))
		 (IF MOREFLUSH (PRINC MOREFLUSH))
		 (TYI)
		 (SETQ MORE-^W (OR MORE-^W (AND MOREFLUSH T))
		       #.WRITEFILEP (AND #.WRITEFILEP (NULL MOREFLUSH))))
		(T (COND ((OR (MEMQ 'BATCH STATE-PDL)
			      (AND (< (TYIPEEK) 32.)
				   (NOT (MEMBER (TYIPEEK)
						'(2 7 11. 12. 25. 27.
						  28. 29. 30.)))))
			  (TYI)))
		   (IF MOREFLUSH (LET (#.WRITEFILEP #.TTYOFF) (PRINC MOREFLUSH)))
		   (SETQ MORE-^W (OR MORE-^W (AND MOREFLUSH T))))))
	 NIL)))
 (IF (AND SMART-TTY (NOT (AND SCROLLP (NOT $CURSORDISP))))
     (COND (RUBOUT-TTY (LET (#.TTYOFF) (CURSORPOS T T) (CURSORPOS '/])))
	   (T (SLEEP 0.4) (FORMFEED)))
     (LET (#.TTYOFF #.WRITEFILEP) (TERPRI)))
 (ENDPAGEFN T 'MORE-FUN))

#+PDP10 (ENDPAGEFN T 'MORE-FUN)

; More processing stuff.
; This isn't the best way to do it on the Lisp machine,
; it's a minimally modified version of the Maclisp one.

#+LISPM (DECLARE (SPECIAL TV:MORE-PROCESSING-GLOBAL-ENABLE))

#+LISPM
(DEFMFUN MORE-FUN (FILE)
  FILE ;ignored
  (FUNCALL TERMINAL-IO ':MORE-EXCEPTION))

#+LISPM
(DEFUN MORE-FUN-INTERNAL (TERMINAL-IO &AUX (STANDARD-INPUT 'SI:TERMINAL-IO-SYN-STREAM))
 ; This clears the rest of the screen, unless we're at the bottom
 ; or too close to the top.
 (COND ((NOT (OR (< (CAR (CURSORPOS)) 10.)
		 (= (- TTYHEIGHT 2) (CAR (CURSORPOS)))))
	(CURSORPOS 'E)))
 ; Now go to the bottom of the screen and cause a more, unless disabled.
 (COND (TV:MORE-PROCESSING-GLOBAL-ENABLE
	(CURSORPOS 'Z) (CURSORPOS 'L)
	((LAMBDA (^Q)
	  ((LAMBDA (#.WRITEFILEP #.TTYOFF STATE-PDL)
	    (PRINC MOREMSG) (TYIPEEK)
	    ; Now see what the user feels like typing in.
	    (COND ($MOREWAIT
		   (DO ((L (COND ((EQ $MOREWAIT '$ALL) '(32. 141.)) ; sp, cr
				 (T '(32. 141. 135.)))))  ; sp, cr, rubout
		       ((MEMBER (TYIPEEK) L))
		      (TYI T))) ; eat other characters
		  (T (DO () ((NOT (MEMBER (TYIPEEK) '(4 19. 22. 29.))))
			 (TYI T)))) ; eat ^], etc. 
	    ; Now erase the MORE message
	    (COND (SMART-TTY (CURSORPOS 'Z) (CURSORPOS 'L)) (T (TERPRI))))
	   NIL NIL (CONS 'MORE-WAIT STATE-PDL))
	  ; Now decide whether to continue or flush
	  (COND ((= #\SP (TYIPEEK))
		 (IF MORECONTINUE (LET (#.WRITEFILEP #.TTYOFF) (PRINC MORECONTINUE)))
		 (TYI T)) ; eat the space
		((= #\RUBOUT (TYIPEEK))
		 (LET ((#.TTYOFF T)) (TERPRI))
		 (IF MOREFLUSH (PRINC MOREFLUSH))
		 (TYI T)  ; eat the rubout
		 (SETQ MORE-^W (OR MORE-^W (AND MOREFLUSH T))
		       #.WRITEFILEP (AND #.WRITEFILEP (NULL MOREFLUSH))))
		(T (COND ((OR (MEMQ 'BATCH STATE-PDL)
			      (AND (< (TYIPEEK) 32.)
				   (NOT (MEMBER (TYIPEEK)
						'(2 7 11. 12. 25. 27. 28. 29. 30.))))
			      (>= (TYIPEEK) 128.))
			  (TYI T)))  ; eat cr or other control character.
		   (IF MOREFLUSH (LET (#.WRITEFILEP #.TTYOFF) (PRINC MOREFLUSH)))
		   (SETQ MORE-^W (OR MORE-^W (AND MOREFLUSH T))))))
	 NIL)))
 ; Now home up, or advance to next line, and continue display.
 (IF SMART-TTY
     (COND (RUBOUT-TTY (LET (#.TTYOFF) (CURSORPOS T T) (CURSORPOS 'L)))
	   (T (SLEEP 0.4) (FORMFEED)))
     (LET (#.TTYOFF #.WRITEFILEP) (TERPRI))))

;; More PDP10-only stuff

#+PDP10 (PROGN 'COMPILE

(DEFMFUN $PAGEPAUSE (X) (PAGEPAUSE1 NIL X))

(DEFUN PAGEPAUSE1 (NIL X) 
 (SYSCALL 0 'TTYSET TYO (CAR (STATUS TTY)) (CADR (STATUS TTY))
	  (BOOLE (COND (X 4) (T 7)) (CADDR (STATUS TTY)) 1_25.)))
				; Bit 3.8 (%TSMOR) of TTYSTS

(DEFUN TTYINTSOFF NIL
 (COND ((STATUS TTY)  ; If NIL, we don't have the TTY
	(NOINTERRUPT 'TTY)
	(SSTATUS TTY (CAR (STATUS TTY)) (CADR (STATUS TTY)) ; Defer echoing
		 (BOOLE 7 8._18. (CADDR (STATUS TTY))))
				; Bit 3.4 (%TSNOE) of TTYSTS
	(SETQ TTYINTS NIL))))

(DEFUN TTYINTSON NIL
 ((LAMBDA (TTY-STATUS)
   (SSTATUS TTY (CAR TTY-STATUS) (CADR TTY-STATUS) ; Allow echoing
		(BOOLE 2 8._18. (CADDR TTY-STATUS)))
   (SETQ TTYINTS T) (NOINTERRUPT NIL))
  (SYSCALL 3 'TTYGET TYO)))

(DEFUN SETCURSORPOS (N1 N2) (SYSCALL 0 'SCPOS TYO N1 N2))

) ;; End of PDP10-only stuff

;;; TRANSL properties for STATUS and SSTATUS in MAXSRC;TRANS5 >
#+(or Franz MACLISP NIL)
(DEFMSPEC $STATUS (L)  (SETQ L (CDR L))
 (IF L (NONSYMCHK (CAR L) '$STATUS))
 (COND ((OR (NULL L)
	    (AND (EQ (CAR L) '$FEATURE) (CDDR L))
	    (AND (NOT (EQ (CAR L) '$FEATURE)) (CDR L)))
	(WNA-ERR '$STATUS)))
 (LET ((KEYWORD (CAR L)))
      (CASEQ KEYWORD
	     ($RUNTIME (LIST '(MTIMES SIMP) (// (+ (RUNTIME) 500.) 1000.) '$MSEC))
	     ($TOTALGCTIME (LIST '(MTIMES SIMP) (COMPUTIME (STATUS GCTIME) 0) '$MSEC))
	     ($TIME (COND ((PLUSP THISTIME)
			   (LIST '(MTIMES SIMP) (COMPUTIME (RUNTIME) THISTIME) '$MSEC))
			  (T '$UNKNOWN)))
	     ($GCTIME (COND ((PLUSP GCT)
			     (LIST '(MTIMES SIMP) (COMPUTIME (STATUS GCTIME) GCT) '$MSEC))
			    (T '$UNKNOWN)))
	     ($REALTIME (LIST '(MTIMES SIMP) (-$ (TIME) STIME0) '%SEC))
	     ($DAYTIME (CONS '(MLIST) (STATUS DAYTIME)))
	     ($DATE (CONS '(MLIST) (STATUS DATE)))
	     ($DAY (MAKEALIAS (STATUS DOW)))
	     ($FREECORE (LIST '(MTIMES SIMP) (// (sys-free-memory) 1024.)
			      '$BLOCKS))
	     ($FEATURE (COND ((NULL (CDR L)) (DOLLARIFY (STATUS FEATURES)))
			     (T #-NIL
				(APPLY #'STATUS 
				       `(FEATURE ,(FULLSTRIP1 (CADR L))))
				#+NIL
				(FEATUREP (FULLSTRIP1 (CADR L)))
				)))
	     ($STATUS '((MLIST SIMP) $RUNTIME $TOTALGCTIME $TIME $GCTIME $REALTIME $DAYTIME
				    $DATE $DAY $FREECORE $FEATURE $STATUS))
	     (T (MERROR "Unknown argument - STATUS:~%~M" KEYWORD)))))

#+LISPM
(DEFMSPEC $STATUS (FORM) (POP FORM)
  (LET ((KEYWORD (POP FORM))
	(FEATURE (POP FORM)))
    (CHECK-ARG KEYWORD SYMBOLP "a symbolic name")
    (CHECK-ARG FEATURE SYMBOLP "a symbolic name")
    (COMPILER-LET ((OBSOLETE-FUNCTION-WARNING-SWITCH NIL))
      (CASEQ KEYWORD
	($FEATURE (COND ((NULL FEATURE) (DOLLARIFY (STATUS FEATURES)))
			((MEMQ (FULLSTRIP1 FEATURE) (STATUS FEATURES)) T)))
	($STATUS '((MLIST SIMP) $FEATURE $STATUS))
	(T (MERROR "Unknown argument - STATUS:~%~M" KEYWORD))))))

#+(or Franz MACLISP)
(DEFMSPEC $SSTATUS (L) (SETQ L (CDR L))
 (COND ((OR (NULL L) (NULL (CDR L))) (MERROR "SSTATUS takes >1 argument.")))
 (LET (((KEYWORD ACT . REST) L))
      (NONSYMCHK KEYWORD '$SSTATUS)
      (COND ((EQ KEYWORD '$FEATURE)
	     (COND ((NOT (NULL REST)) (WNA-ERR '$SSTATUS)))
	     (NONSYMCHK ACT '$SSTATUS)
	     (APPLY #'SSTATUS `(FEATURE ,(FULLSTRIP1 ACT))))
	    (T (MERROR "Unknown argument - SSTATUS:~%~M" KEYWORD)))))

; Allocation level 0 is
; (ALLOC '(LIST (16000. 30000. 0.3) FIXNUM (5000. 9000. 0.3)
;	   FLONUM (1600. 3000. 0.3) BIGNUM (1600. 3000. 0.3)
;	   SYMBOL (6200. 7200. 0.15) ARRAY (150. 400. 50.)))

#+MACLISP
(PROGN 'COMPILE
(DEFMSPEC $ALLOC (FORM) (I-$ALLOC (CDR FORM)))
(DEFMFUN I-$ALLOC (L)
 (DO ((L L (CDR L)) (X)) ((NULL L) '$DONE)
     (COND ((OR (AND (EQ (TYPEP (CAR L)) 'FIXNUM) (> (CAR L) 0) (< (CAR L) 5)
		     (OR (NOT (> (CAR L) ALLOCLEVEL)) (SETQ ALLOCLEVEL (1- (CAR L)))))
		(MEMQ (CAR L) '($ALL $LIST)))
	    (COND ((= ALLOCLEVEL 0)
		   (ALLOC '(LIST (16000. 39000. NIL) FIXNUM (5000. 10000. NIL)
			    FLONUM (1600. 3500. NIL) BIGNUM (1600. 3500. NIL)
			    SYMBOL (6200. 7600. NIL) ARRAY (150. 450. NIL))))
		  ((= ALLOCLEVEL 1) 
		   (ALLOC '(LIST (18000. 48000. NIL) FIXNUM (6000. 11000. NIL)
			    FLONUM (1800. 4000. NIL) BIGNUM (1800. 4000. NIL)
			    SYMBOL (6500. 8000. NIL) ARRAY (180. 500. NIL))))
		  ((= ALLOCLEVEL 2)
		   (ALLOC '(LIST (18000. 57000. NIL) FIXNUM (6000. 12000. NIL)
			    FLONUM (1800. 4500. NIL) BIGNUM (1800. 4500. NIL)
			    SYMBOL (6500. 8500. NIL) ARRAY (180. 550. NIL))))
		  ((= ALLOCLEVEL 3)
		   (ALLOC '(LIST (20000. 67000. NIL) FIXNUM (8000. 14000. NIL)
			    FLONUM (2000. 5000. NIL) BIGNUM (2000. 5000. NIL)
			    SYMBOL (7000. 9000. NIL) ARRAY (200. 600. NIL))))
		  (T (PRINC "You're already at maximum allocation") (RETURN '$DONE)))
	    (SETQ ALLOCLEVEL (1+ ALLOCLEVEL)))
	   ((SETQ X (ASSQ (STRIPDOLLAR (CAR L))
			  '((FIXNUM . 2000.) (FLONUM . 1500.) (BIGNUM . 1500.)
			    (SYMBOL . 1000.) (ARRAY . 100.) (HUNK2 . 1000.) (HUNK4 . 1000.)
			    (HUNK8 . 1000.) (HUNK16 . 1000.) (HUNK32 . 1000.))))
	    (ALLOC (LIST (CAR X)
			 (LIST NIL (+ (CDR X) (CADR (GET (CONS NIL (ALLOC T)) (CAR X))))
			       NIL))))
	   (T (MERROR "Incorrect argument to ALLOC:~%~M" (CAR L))))))
)
#+Franz
(defmfun $alloc (type pages) (allocate (stripdollar type) pages))
; type should be list, fixnum etc.


;; GC Interrupt functions.

#+PDP10 (PROGN 'COMPILE

(DEFUN GCLFUN (SPACE)  ; The GC-LOSSAGE and PDL-OVERFLOW interrupt function
 (COND ((AND (NOT (= ALLOCLEVEL 5)) (= (SYS-FREE-MEMORY) 0)
			; i.e. state is "NO CORE AVAILABLE".
	     (MEMQ SPACE '(LIST FIXNUM FLONUM BIGNUM SYMBOL ARRAY)))
	(SETQ ALLOCLEVEL 4) (GCOFUN SPACE))
       (T (LET (FREECOREP)
	       (WHEN (EQ SPACE 'SYMBOL) (SETQ GCSYML NIL) (GCTWA))
	       (TERPRI)
	       (COND ((AND (= (SYS-FREE-MEMORY) 0)
			   (NOT (MEMQ SPACE '(REGPDL SPECPDL))))
		      (MTELL-OPEN "CORE capacity exceeded (while requesting ~A space).~%"
			     SPACE)
		      (MTELL-OPEN "SAVE a few expressions if you can.~%")
		      (PRINC "You will probably have to load up a new MACSYMA!!"))
		     (T (SETQ FREECOREP T)
			(MTELL-OPEN "~A storage capacity exceeded " SPACE)))
	       (IF (MEMQ SPACE '(REGPDL SPECPDL)) (PRINC "(Infinite recursion?)"))
	       (TERPRI)
	       (LET ((MTOP (MEMQ 'MACSYMA-TOPLEVEL STATE-PDL)))
		    (WHEN MTOP (TIMESOFAR 1)
			       (IF (> THISTIME 0) (MTELL-OPEN " so far~%")
						  (TERPRI)))
		    (COND (DEBUG (LET (($ERROR (CONS '(MLIST SIMP)
						     (IF FREECOREP
							 (LIST "~A storage capacity exceeded " SPACE)
							 (LIST "CORE capacity exceeded (while requesting ~A space).~%"
							       SPACE)))))
				      (ERRBREAK NIL)))
			  ((AND *RSET (NOT MTOP)) (*RSETFUN NIL)))
		    (COND (ERRCATCH (ERROR)) (MTOP (MQUIT T)) (T (^G))))))))

(DEFUN GCOFUN (SPACE)  ; The GC-OVERFLOW interrupt function
 (IF (NULL TTYINTS) (PROG2 (TTYINTSON) (GCOFUN1 SPACE) (TTYINTSOFF))
		    (GCOFUN1 SPACE)))

(DEFUN GCOFUN1 (SPACE)
 ((LAMBDA (#.TTYOFF #.WRITEFILEP)
   (PROG (^Q X)
	 (COND ((= ALLOCLEVEL 4)
		(ALLOC '(LIST (NIL NIL 1000) FIXNUM (NIL NIL 100)
			 FLONUM (NIL NIL 100) BIGNUM (NIL NIL 100)
			 SYMBOL (NIL NIL 100) ARRAY (NIL NIL 6)))
		(SETQ ALLOCLEVEL 5) (RETURN '(T)))
	       ((= ALLOCLEVEL 5) (MTELL-OPEN "~%Maximum allocation exceeded")
				 (GCLFUN SPACE))
	       ($DYNAMALLOC
		(SETQ X (COND ((MEMQ SPACE '(FIXNUM FLONUM BIGNUM SYMBOL ARRAY
					     HUNK2 HUNK4 HUNK8 HUNK16 HUNK32))
			       SPACE)
			      (T '$ALL)))
		(COND ((EQ $DYNAMALLOC '$PRINT)
		       (MTELL-OPEN "~%More ~A space was needed.~%" SPACE)))
		(GO ALLOC)))
	 (SETQ #.TTYOFF NIL)
	 (IF (= THISTIME -1) (MTELL-OPEN "~%(Computing the display now)"))
	 (SETQ X (LIST '(MTEXT)
		       "
You have run out of " SPACE " space.
Do you want more?
"		       GCPROMPT))
	 (SETQ X (RETRIEVE X T))
    LOOP (COND ((NOT (MEMQ X '($ALL $NONE $OK 1 2 3 4 $LIST $FIXNUM
				    $FLONUM $BIGNUM $SYMBOL $ARRAY
				    $HUNK2 $HUNK4 $HUNK8 $HUNK16 $HUNK32)))
		(CURSORPOS 'A)
		(SETQ X (RETRIEVE GCPROMPT NIL))
		(GO LOOP))
	       ((EQ X '$NONE) (GCLFUN SPACE))
	       ((EQ X '$OK) (RETURN '(T))))
    ALLOC(I-$ALLOC (LIST X)) (RETURN '(T))))
   #.TTYOFF (AND #.WRITEFILEP (NOT DSKFNP))))

(DEFUN GCDEMON (SPACES)  ; The GC-DAEMON interrupt function
 (DO ((X (IF (= (SYS-FREE-MEMORY) 0) (SETQ GC-DAEMON NIL) SPACES) (CDR X))
      (Y) (N1 0) (N2 0))
     ((NULL X))
     (COND ((ZEROP (CADAR X))
	    ((LAMBDA (U1)
	      (COND ((OR (NOT (EQ (CAR DEMONL) (CAAR X)))
			 (> (ABS (//$ (-$ U1 (CAR (LAST DEMONL))) U1)) 0.03))
		     (SETQ DEMONL (LIST (CAAR X) U1)))
		    ((= (LENGTH DEMONL) 3)
		     (SETQ Y (GET (CONS NIL (ALLOC T)) (CAAR X)))
		     (COND ((AND Y (PROG2 (SETQ N1 (CAR Y) N2 (CADR Y)) (< N1 (- N2 1000))))
			    (ALLOC (LIST (CAAR X) (LIST (MIN N2 (+ N1 2000)) NIL NIL)))))
		     (SETQ DEMONL (LIST NIL)))
		    (T (NCONC DEMONL (NCONS U1))))
	      (RETURN T))
	     (FLOAT (CADDAR X)))))))

) ;; End of GC interrupt functions.

;; DSKGC(TRUE); will cause user defined values, functions, arrays and line
;; labelled expressions to be stored on disk whenever the system determines
;; storage is getting low.  Only needed on PDP10s.  Other systems have this
;; built in.  Its called paging.

#+PDP10 (PROGN 'COMPILE

(DEFMFUN $DSKGC (X) (DSKGC1 NIL X))

(DEFUN DSKGC1 (NIL X)
 (SETQ GC-OVERFLOW
       (COND (X (IF (< ALLOCLEVEL 4) (I-$ALLOC '(4))) 'GCDFUN)
	     (T 'GCOFUN)))
 '$DONE)

(DEFUN GCDFUN (SPACE)  ; The DSKGC interrupt function
 (COND ((OR (= GCLINENUM $LINENUM) (STATUS FILEMODE SAVEFILE)) (GCOFUN SPACE))
       (T (SETQ GCLINENUM $LINENUM)
	  (LET ((GC-OVERFLOW 'GCOFUN) (DSKSAVEP T))
	       (I-$STORE  '($LABELS $VALUES $FUNCTIONS $ARRAYS))))))

) ;; End of disk GC conditionalization.

#-PDP10 (PROGN 'COMPILE
(DEFMFUN $DSKGC (X) X NIL)
(DEFUN DSKGC1 (X Y) X Y NIL)
)

;; Various functions which get run when interrupts go off.  The interrupt
;; functions in this form are present only in PDP10 and Multics MacLisp.

#+MacLisp
(PROGN 'COMPILE

(DEFUN *RSETFUN (NIL)  ; The *RSET interrupt function
 (AND *RSET (PROG (#.TTYOFF ^Q) (*BREAK T '*RSET))))

(DEFUN FAILFUN (X)  ; The FAIL-ACT interrupt function
 (COND #+PDP10 ((EQ (CAR X) 'ERRLIST) '(T))
       ((MEMQ (CAR X) '(BASE IBASE)) (SET (CAR X) 10) '(T))
       (T (ERRPRINT NIL) NIL)))

) ;; End of *RSET, FAIL-ACT interrupt functions.

#+PDP10  (PROGN 'COMPILE

;; Functions for the Macsyma-user-level tty interrupt facility.

(DEFMFUN TTYINTFUNSETUP (NIL FLAG)
 (IF FLAG (SSTATUS TTYINT $TTYINTNUM 'TTYINTFUN)
	  (SSTATUS TTYINT $TTYINTNUM NIL)))

(DEFMFUN TTYINTFUN (NIL NIL)  ; The ^U (or other) interrupt function
 (NOINTERRUPT NIL)
 (MAPPLY $TTYINTFUN NIL $TTYINTFUN))

;; These interrupt functions are present only in PDP10 MacLisp.

;; This function gets called when the operating system supervisor
;; returns the console to Macsyma.  It reprints the current c-line, or the
;; editor buffer, or whatever is appropriate.

(defmfun ttyretfun (x)
 (let (#.TTYOFF #.WRITEFILEP (readp (and reading (zerop (listen)))))
      (cursorpos 'a)
      (when (not (or (eq x T)
		     (and (eq (car state-pdl) 'MACSYMA-TOPLEVEL) readp)))
		; Do nothing if you never left MACSYMA or are at 
		; top level MACSYMA read.
	    (PRINC "Back to MACSYMA")
	    (caseq (memq-stpdl '(LISP-TOPLEVEL LISP-BREAK RETRIEVE
				 MACSYMA-TOPLEVEL))
		   ((LISP-TOPLEVEL LISP-BREAK)
		    (PRINC ", at LISP level.  "))
		   (T (PRINC ".  "))))

      (or (memq (car state-pdl) '(COMPUTING PLAYBACK BATCH))
	  (let ((F (TO-MACSYMA-NAMESTRING
		    `((DSK ,(STATUS HSNAME)) ,(STATUS UNAME) |_MAXIM|))))
	    ;; $LOAD is good for hacking lisp or macsyma level code.
	    (AND (PROBEF F)
		 (UNWIND-PROTECT (ERRSET ($LOAD F))
				 (DELETEF F)
				 (CURSORPOS 'a)))))
		 
      (caseq (car state-pdl)
	     (COMPUTING (PRINC "Computation continuing."))
	     (EDIT (PRINC "Inside Editor."))
	     ((RETRIEVE MACSYMA-BREAK)
	      (COND ((OR (EQ (CAR STATE-PDL) 'MACSYMA-BREAK)
			 (EQ (CADR STATE-PDL) 'MACSYMA-BREAK))
		     (PRINC "MACSYMA-BREAK")
		     (UNLESS (ZEROP BRKLVL) (PRINC " level ") (PRINC BRKLVL))
		     (PRINC "."))
		    (T (PRINC "Waiting for input."))))
	     (BATCH (caseq (cadr state-pdl)
			   ($TRANSLATE (PRINC "TRANSLATE_FILE continuing."))
			   ($DEMO (PRINC "DEMO continuing."))
			   (T (PRINC "BATCH continuing."))))
	     (PLAYBACK (PRINC "PLAYBACK continuing."))
	     (LISP-BREAK (PRINC "LISP-BREAK.")))
      (if (not (and (eq (car state-pdl) 'MACSYMA-TOPLEVEL) readp)) (terpri))
;; Maybe do some redisplay
      (caseq (car state-pdl)
	     (EDIT (prtext) (if readp (reprint command t)))
	     ((MACSYMA-TOPLEVEL RETRIEVE)
	      (retr-print promptmsg (eq mrg-punt t))
	      (if readp (reprint (if (or (not rephrase)
					 (eq (car state-pdl) 'RETRIEVE))
				     st)
				 t)))
	     (MORE-WAIT (PRINC moremsg)))))

;;; MEMQ-STPDL is like a MEMQ, except that it finds the first cons of the 
;;; STATE-PDL who's car is an EQ member of a list, rather than EQ to a 
;;; single item.

(DEFUN MEMQ-STPDL (ATOMS)
 (DO ((LIST STATE-PDL (CDR LIST)))
     ((OR (NULL LIST) (MEMQ (CAR LIST) ATOMS)) (CAR LIST))))

(DEFMFUN IOLFUN (X)  ; The IO-LOSSAGE interrupt function
 (COND ((EQ (CAR X) 'OPEN)
	(FILEPRINT (NAMELIST (CADR X)))  ; the file
	(PRINC (CAADDR (ERRFRAME NIL))))  ; the error msg
       (T (ERRPRINT NIL)))
 NIL)

(DEFMFUN MACHERRFUN (TYPE LOC PC JPC)  ; Machine Error Handler
 LOC JPC ;Ignored.
 (TERPRI)
 (COND ((EQ TYPE 'EXAMINE) (MTELL ";reference to non-existent memory"))
       ((EQ TYPE 'DEPOSIT) (MTELL ";write into read-only memory"))
       ((EQ TYPE 'EVAL)	   (MTELL ";illegal machine operation"))
       ((EQ TYPE 'ODDP)	   (MTELL ";parity error"))
       (T (MTELL ";~A error" TYPE)))
 (MERROR " from location ~S~%;program trapped while in ~S" PC (SUBR PC)))

) ;; End of PDP-10 only interrupt functions.

;; TTY interrupt functions.  This form for PDP10 MacLisp only.

#+PDP10 (PROGN 'COMPILE

(DECLARE (SETQ BASE 10.))  ; Must be set to 10 for outputting lap code.

(DEFUN XQUIT (NIL NIL)  ; The ^X interrupt function
 (CASEQ (MEMQ-STPDL '(MACSYMA-TOPLEVEL MACSYMA-BREAK LISP-TOPLEVEL LISP-BREAK))
	(MACSYMA-BREAK (*THROW 'MACSYMA-BREAK NIL))
	(MACSYMA-TOPLEVEL (COND (MBREAK (*THROW 'MBREAK NIL)) (T (MQUIT NIL))))
	(T (ERROR 'QUIT))))

(PROGN (SSTATUS TTYINT #^A '(LAMBDA (NIL NIL) (MERRBREAK NIL)))
       (SSTATUS TTYINT #^B '(LAMBDA (NIL NIL) (MPAUSE NIL)))
       (SSTATUS TTYINT #^C NIL)
       (SSTATUS TTYINT #^D
		'(LAMBDA (NIL NIL)
		  (COND (^D (PRINC ^DMSG-OFF) (SETQ ^D NIL))
			(T (PRINC ^DMSG-ON) (SETQ ^D T)))))
       (SSTATUS TTYINT #^G '(LAMBDA (NIL NIL) (MQUIT NIL)))
       (SSTATUS TTYINT #^H NIL)  ; This line is unnecessary.
       (SSTATUS MACRO #^Q NIL)
       (SSTATUS TTYINT #^R NIL)
       (SSTATUS TTYINT #^S 'MQUIET)
       (SSTATUS TTYINT #^T NIL)
       (SSTATUS TTYINT #^X 'XQUIT)
       (SSTATUS TTYINT #^] '(LAMBDA (NIL NIL) (TIMESOFAR NIL)))
       (SSTATUS TTYINT #^^ #^G)    ; quits into LISP
       '(Setup of TTY interrupt functions))
) ;; End of TTY interrupt functions.

#+Multics (PROGN 'COMPILE

(DECLARE (SETQ BASE 10.))  ; Must be set to 10 for outputting lap code.

(PROGN (SSTATUS interrupt 2 'MERRBREAK) ;^A break.
       (SSTATUS interrupt 1 'MPAUSE) ;^B break.
      ;(SSTATUS TTYINT #^C NIL) ;Done by the LISP.
      ;(SSTATUS TTYINT #^D
      ;		'(LAMBDA (NIL NIL)
      ;		  (COND (^D (PRINC ^DMSG-OFF) (SETQ ^D NIL))
      ;			(T (PRINC ^DMSG-ON) (SETQ ^D T))))) ;Done by the LISP.
      ;(SSTATUS TTYINT #^G '(LAMBDA (NIL NIL) (MQUIT NIL))) ;Doesn't exist.
      ;(SSTATUS TTYINT #^H NIL)  ; This line is unnecessary.
      ;(SSTATUS MACRO #^Q NIL) ;I don't know what this is for -Jim.
      ;(SSTATUS TTYINT #^R NIL)
      ;(SSTATUS TTYINT #^S 'MQUIET)
      ;(SSTATUS TTYINT #^T NIL)
      ;(SSTATUS TTYINT #^X 'XQUIT) ;This has gotta get caught by an errset.
       (sstatus interrupt 15. '(lambda (x)
				 x ;ignored
				 (timesofar nil))) ;^] interrupt.
       (sstatus interrupt 16 '(lambda (x)
				((lambda (errlist)
				   (^g))
				 '((errlfun ()))))) ;^^ interrupt.
       '(Setup of TTY interrupt functions))
)

#+LISPM (SETQ ERROR-CALL 'ERRBREAK)

(PROGN (DO L '($SQRT $ERF $SIN $COS $TAN $LOG $PLOG $SEC $CSC $COT $SINH $COSH
	       $TANH $SECH $CSCH $COTH $ASIN $ACOS $ATAN $ACOT $ACSC $ASEC $ASINH
	       $ACOSH $ATANH $ACSCH $ASECH $ACOTH $BINOMIAL $GAMMA $GENFACT $DEL)
	   (CDR L) (NULL L)
	   ((LAMBDA (X)
	     (PUTPROP (CAR L) X 'ALIAS)
	     (PUTPROP X (STRIPDOLLAR (CAR L)) 'REVERSEALIAS))
	    ($NOUNIFY (CAR L))))
       ($NOUNIFY '$SUM) ($NOUNIFY '$PRODUCT)
       ($NOUNIFY '$INTEGRATE) ($NOUNIFY '$LIMIT)
       (DEFPROP $DIFF %DERIVATIVE VERB) (DEFPROP %DERIVATIVE $DIFF NOUN)
       '(NOUN properties))

(PROGN (MAPC #'(LAMBDA (X) (PUTPROP (CAR X) (CADR X) 'ASSIGN))
	     '(($DEBUGMODE DEBUGMODE1) ($BOTHCASES BOTHCASES1)
	       ($PAGEPAUSE PAGEPAUSE1) ($DSKGC DSKGC1) ($TTYINTFUN TTYINTFUNSETUP)
	       ($FPPREC FPPREC1) ($POISLIM POISLIM1)))
       (MAPC #'(LAMBDA (X) (PUTPROP X 'NEVERSET 'ASSIGN)) (CDR $INFOLISTS))
       (DEFPROP $CONTEXTS NEVERSET ASSIGN)
       '(ASSIGN properties))

;; Do this last so that all of the preceding forms are evaluated using
;; the standard error handlers and interrupt functions.

#+MACLISP
(SETQ ERRSET 'ERRBREAK ALARMCLOCK NIL AUTOLOAD 'FIND0
      UNDF-FNCTN 'UUF-HANDLER UNBND-VRBL 'M-UBV-EH WRNG-TYPE-ARG 'M-WTA-EH
      UNSEEN-GO-TAG NIL
      WRNG-NO-ARGS 'M-WNA-EH FAIL-ACT 'FAILFUN *RSET-TRAP '*RSETFUN)

#+Franz
(setq errset 'errbreak  undf-fnctn 'uuf-handler autoload 'find0)

#+Franz
(signal 2 'errbreak)   ; have errbreak handle interrupts

#+PDP10
(SETQ GC-LOSSAGE 'GCLFUN GC-DAEMON 'GCDEMON GC-OVERFLOW 'GCOFUN
      PDL-OVERFLOW 'GCLFUN IO-LOSSAGE 'IOLFUN MACHINE-ERROR 'MACHERRFUN)


; Undeclarations for the file:
(DECLARE (NOTYPE I N N1 N2 U1))

(EVAL-WHEN (EVAL COMPILE) (SETQ BASE OLD-BASE IBASE OLD-IBASE))

