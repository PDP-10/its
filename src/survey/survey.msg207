TITLE SURVEY

;--------------------------------------------------------------------------------

;	Note:  many of the parameters and output formats are specified in external
;	documents.  Things should not be seriously disturbed without first
;	consulting AV as to their external world implications.

;	Some documents which mention this data, are ARPANET NWG RFC's 308, 523, 530
;	Also reference NIC # 20248 by A.K.Bhushan dated 11/14/73

;	P. Johnson at BBN has some knowledge and interest in the effects of this program
;	notably, the TENEX program HOSTAT, which uses the DMS program SURGIV.

;	S. Galley, M. Brescia, A. Chan, M. Seriff, A. Bhushan, R. Metcalfe at MIT
;	have had parts in keeping this program up to date.
;	(put your name at the front of the list)

;--------------------------------------------------------------------------------

.MLLIT==1	;MIDAS CONTROL
.XCREF	A,B,C,D,E,F,P,I,M

A=1		;STANDARD AC DEFS
B=2
C=3
D=4
E=5
F=6
P=17

I=1000,,	;FOR .CALL PARAMATERS
M=2000,,	; "

GNCPTR==15	; TABLE PTR USED BY GETNXC
GNSPTR==16	; TABLE PTR USED BY GETNXS
TESTS==96.	; ROOM FOR THIS MANY SURVEYS ON CURRENT FILE
WORDS==8.	; # OF WORDS OF SURVEY DATA FOR EACH HOST IN CURRENT FILE
FIN==1		; CURRENT FILE INPUT CHANNEL
MIN==2		; MASTER FILE INPUT CHANNEL
FOUT==3		; CURRENT FILE OUTPUT CHANNEL
MOUT==4		; MASTER FILE OUTPUT CHANNEL
NETIN==5	; ICP INPUT CHANNEL
NETOUT==6	; NETWORK OUTPUT CHANNEL FOR TESTING
TNETIN==8.	; TELNET INPUT CHANNEL
TNETOU==9.	; TELNET OUTPUT CHANNEL
NDBOUT==10.	; CHANNEL FOR WRITING OUT NEW DATA BASE TO DISK
DSKIN==11.	; CHANNEL TO CHECK EXISTENCE OF FILES TO BE SENT TO DC

WAIT==900.	; (30THS OF SEC) WAIT UP TO 30 SECONDS FOR A REPLY FROM A HOST

  ; HOST TABLE - SOCKET # IN L.H., HOST # IN R.H.

HLIST:
;title	hostm -- macros by MB to translate name -> number from ITS host table (1/27/78)

.begin hosts

define	host	name,number,status,system,machine,nicknames
ifse	system,TIP,conc sur,\number,==number
.else {	hstnum==number
	host1	name
	irp	n,,[nicknames]
	host1	n
	termin}
ifse	status,SERVER,conc srv,\hstnum,==hstnum
termin

define	host1	name,\gen
	irps	n,s,name
	ifse	s,-,{
	  irpnc <1+<.length /n/>>,<<.length /name/>-<.length /n/>>,1,nn,,[name]
	  host1 n!!nn
	  termin
	 gen=1
	 .stop}
	ifse	s,,{
		ifndef gen,{
			ifdef n,{
				ifn n-hstnum,n==0
}
			.else n==hstnum
}
}
termin
expunge gen
termin

define conc a,b
a!b!termin

define survey hst
irp h,,[hst]
 if1,[
	ifndef h,.err h has no number in SYSENG;HOSTS >
	ife h,.err h has multiple definitions - use a nickname
	conc ifdef sur,\h,,.err h already on list
]
 ifdef h,conc sur,\h,==h
 termin
termin

if1,[	.lstoff
	.insrt syseng;hosts >
	.tyo6 .ifnm1 ? .tyo 40 ? .tyo6 .ifnm2 ? printx / included in this assembly
/
	.lston
]

;Hosts are listed in alphabetical order.
;Hosts to be surveyed are arguments to the SURVEY macro.
; ??? Hosts having STATUS of SERVER may be omitted by being arg to OMIT macro.

;Hosts having SYSTEM of TIP are always included in survey automatically by
; the HOST macro noticing that the SYSTEM is TIP.


SURVEY	AFWL
SURVEY	AMES11
SURVEY	AMES67
SURVEY	ANL
SURVEY	ARCRD
SURVEY	ARPADMS
SURVEY	BBNINLAT
SURVEY	BBNSPEECH11
SURVEY	[BBNA,BBNB,BBNC,BBND,BBNE]
SURVEY	BNL
SURVEY	CCATENEX
SURVEY	CHII
SURVEY	CMU10A
SURVEY	CMU10B
SURVEY	CMU10D
SURVEY	DECMARLBORO
SURVEY	EGLIN
SURVEY	GUNTERELF	;PER GEOFF@ARC 5/19/75
SURVEY	HARV10
SURVEY	I4BTENEX
SURVEY	I4ELF		;PER GEOFF@ARC 2/19/75
SURVEY	I4TENEX
SURVEY	ILLCAC		;PER GEOFF@ARC 1/20/75
SURVEY	ISISPEECH11
SURVEY	LBL		;PER GEOFF@ARC 5/19/75
SURVEY	LL
SURVEY	LLLCOMP
SURVEY	LOGICON
SURVEY	LONEPSGATE	;11/7/74
SURVEY	MITAI
SURVEY	MITDEVMULTICS
SURVEY	MITDMS
SURVEY	MITMC
SURVEY	MITML
SURVEY	MITMULTICS
SURVEY	NBS10
SURVEY	NBSUNIX
SURVEY	NYU
SURVEY	OFFICE1
SURVEY	PARCMAXC
SURVEY	RADC20
SURVEY	RADCMULTICS
SURVEY	RADCXPER	;6/21/76
SURVEY	RANDRCC
SURVEY	RANDUNIX
SURVEY	RUTGERS10
SURVEY	SCI
SURVEY	SCRLDEV		;PER GEOFF@ARC 1/20/75
SURVEY	SCRLRSX
SURVEY	SDAC44
SURVEY	SDACUNIX
SURVEY	SRIC3PO		;PER GEOFF@ARC 2/19/75
SURVEY	SRIKA
SURVEY	SRIKL
SURVEY	SRIR2D2		;PER GEOFF@ARC 2/19/75
SURVEY	SRIUNIX
SURVEY	SRIVIS11
SURVEY	SUAI
SURVEY	SUMEXAIM
SURVEY	UCLAATS
SURVEY	UCLACCN
SURVEY	UCLASECURITY
SURVEY	UKICS370
SURVEY	USCECL
SURVEY	[ISIA,ISIB,ISIC,ISIE]
SURVEY	UTEXAS
SURVEY	WHARTON
SURVEY	WPAFB
SURVEY	WPAFBAFAL


stuff:	repeat 400,[
	conc ifdef sur,\.rpcnt,,1,,.rpcnt
.else	conc [if2,ifdef srv]\.rpcnt,,conc .err SERVER ,\.rpcnt, not being surveyed
]
stuffe:
	conc printx /,\.-stuff, survey entries
/

203,,CCA		; DATA COMPUTER V 1.0 (SOC 203 770103)

.end hosts

;	end

NUMHOS==.-HLIST		; # OF HOST SOCKET COMBINATION BEING SURVEYED

DCBLEN==NUMHOS*23./5+1

HLAST:	-1		; DUMMY HOST (SIGNALS END OF TABLE)
	-1		; CLUDGE FOR STOPPING READ

PDL:	BLOCK	50
FINOPN:	0		; -1 => CURRENT FILE OPEN FOR READ
REINIT:	0		; -1 => REINITIALIZE CSDATA NOW FILE
MINOPN:	0		; -1 => MASTER FILE OPEN FOR READ
DCDPTR:	0		; BYTE POINTER FOR DC DATA
DCDBUF:  BLOCK	DCBLEN	; BUFFER FOR DATA COMPUTER
FOOBAR:	BLOCK	100
BUFLEN:	0		; # OF WORDS TO WRITE OUT TO THE NDCDAT FILE FOR EACH SURVEY
EPNTR:	0		; BYTE POINTER FOR DEPOSITING SURVEY STATUS IN CURRENT FILE
HEADER:	0		; # OF VALID ENTRIES,, # OF TESTS SINCE LAST SUMMARIZATION
	0		; DATE OF INITIALIZATION OF CURRENT FILE
	0		; TIME OF INITIALIZATION OF CURRENT FILE
	0		; DATE OF LAST SURVEY
	0		; TIME OF LAST SURVEY
DATBGN:	0		; DATE OF BEGINNING OF SURVEY IN CURRENT
TIMBGN:	0		; TIME OF BEGINNING OF SURVEY
DATEND:	0		; DATE OF COMPLETION OF SURVEY
TIMEND:	0		; TIME OF COMPLETION OF SURVEY
DATTIM:	BLOCK	96.*4	; OLD DATE AND TIME READ IN FROM CSDATA FILE
MHEAD:	BLOCK	5	; MASTER FILE HEADER
ENTRY:	0		; SOCKET,, HOST
	0		; TOTAL RESPONSE TIME
	BLOCK	10	; 8 WORDS OF SURVEY DATA FOR EACH HOST
MENTRY:	BLOCK	10	; MASTER FILE ENTRY
FSUM:	BLOCK	10
DCIOTP:	0		; PTR FOR IOTING TO DC (NETWORK BLOCK ASCII HACK)
TIME:	0
GNCBUF:	BLOCK	10.	; BUFFER USED BY GETNXC
GNSBUF:	BLOCK	10	; BUFFER USED BY GETNXS
FILLER:	666666666666
	666666666666
	666666666666
	666666666666
	666666666666
	666666666666
	666666666666
	666666666666
ZEROS:	BLOCK	10

DEMSIG:	SETZ ? 'DEMSIG ? ['SURSND] ? SETZ [0]

; CHKIOT MACRO CHECKS TO MAKE SURE IOT COMPLETED CORRECTLY.

DEFINE	CHKIOT	AC
	JUMPL	AC,DIE
TERMIN


RCHSTB:	BLOCK	7	; BLOCK FOR READ CHANNEL STATUS

LOGBLK:	SETZ ? SIXBIT /LOGIN/ ? ['SURVEY] ? SETZ [0]

FILLEN: SETZ ? 'FILLEN ? C ? SETZM B

NETBLK:	40056,,(SIXBIT/NET/)
	0
	0
	0

NET1:	60,,(SIXBIT/NET/)	; LISTENING SOCKET FOR INITIAL CHECKING
	6
	0
	0

NET2:	51,,(SIXBIT/NET/)	; SENDING SOCKET FOR INITIAL CHECKING
	0
	6
	106

CSDATI:	SIXBIT /  &DSKCSDATANOW/ ; TO READ CURRENT SURVEY FILE

CSDATO:	SIXBIT/  'DSKCSDATATRASH/ ; TO WRITE CURRENT SURVEY FILE
	0			; USE FOR DELETING EXTRA TRASH
	0

CSDATR:	0			; FOR RENAMING CURRENT OUTPUT FILE
	0
	FOUT
	SIXBIT/CSDATANOW/

SUMRYI:	SIXBIT/  &DSKCSMSTRNOW/	; TO INPUT SUMMARY FILE

SUMRYO:	SIXBIT/  'DSKCSMSTRTRASH/ ; TO OUTPUT SUMMARY FILE
	0			; TO DELETE EXTRA OUTPUT FILE ALSO
	0

SUMRYR:	0			; TO RENAME SUMMARY OUTPUT FILE
	0
	MOUT
	SIXBIT/CSMSTRNOW/

; PROGRAM BEGINS EXECUTION EACH TIME AT SURVEY

SURVEY: .SUSET	[.RUNAME,,A]	; GET UNAME TO SEE IF AT TOP LEVEL
	HLLOS	A		;NEW SYS
	AOSE	A		; TOP LEVEL UNAME = -1,,INDEX
	JRST	TOP		; SKIP DEMON SECTION - IN DEBUG MODE
SLEEP:	.DEMON			; FIND OUT REQUEST COUNT
	JFCL
	.CALL	LOGBLK		; LOGIN IN AS "SURVEY"
	JRST	DIE		; QUIT IF CAN'T LOGIN
TOP:	.SUSET	[.SSNAME,,[SIXBIT/NETWRK/]]	; SET SNAME TO NETWRK TO USE THAT DIR
	.FDELE	[SIXBIT /   DSKCSDATATRASH! /]	;DELETE PROBABLE TRASH FROM CRASH
	 JFCL
	MOVE	P,[-50,,PDL-1]	; OPEN SMALL PDL FOR NETWAIT
	.DIETIM	A,		; SEE IF SYSTEM GOING DOWN
	JUMPLE	A,TOPGO		; IF NOT GO ON
	CAIGE	A,9000.	 	; WILL IT DIE WITHIN 5 MINUTS
	JRST	DIE		; YES - QUIT NOW
TOPGO:	.OPEN	NETIN,NET1	; CHECK TO MAKE SURE NETWORK IS UP
	JRST	NDEAD		; BY TRYING TO CONNECT TO SELF
	.OPEN	NETOUT,NET2	; CONNECT TO SOCKET JUST OPENED
	JRST	NDEAD
	MOVEI	A,5*30.
	.SLEEP	A,		; ALLOW 5 SECONS FOR OPENS TO MATCH (AVOID NETRFC)
	.CLOSE	NETIN,
	.CLOSE	NETOUT,
	MOVE	A,[JRST TSINT]	; SET UP FOR INTERRUPTS
	MOVEM	A,42
	MOVEI	A,400		; LOOK FOR IOC ERROR
	SETZM	B
	.SETM2	A,		; SET INTERRUPT MASK
	SETZM	FINOPN		; MARK FILE NOT OPEN FIRST
	.OPEN	FIN,CSDATI	; TRY TO OPEN CURRENT SUMMARY FILE
	JRST	INIT		; OPEN FAILED - THERE IS NO CURRENT FILE - START ONE
	SETOM	FINOPN		; MARK FILE OPEN

; FALL THROUGH TO READ THE FILE IF THE OPEN SUCCEEDS

READ:	SETZM	REINIT
	MOVE	B,[-5,,HEADER]
	.IOT	FIN,B		; READ IN CURRENT FILE HEADER
	HRRZ	B,HEADER	; GET NUMBER OF TESTS ALREADY ON THIS FILE
	JUMPE	B,INIT		; IF FILE IS EMPTY - GO INITIALIIZE
	CAIN	B,TESTS		; SEE IF MORE ON FILE
	PUSHJ	P,FULL		; GO SUMMARIZE AND WIPEOUT IF FULL
	JRST	BGLOOP		; GO RUN A SURVEY

; INIT EXECUTED ONLY WHEN FIRST SURVEY IS PUT INTO A FILE

INIT:	.RTIME	A,		; COME HERE TO INITIALIZE THE FILE WITH TIME AND DATE
	MOVEM	A,HEADER+1
	.RDATE	A,
	ROT	A,12.		; REARRANGE DATE
	MOVEM	A,HEADER+2
	SETZM	HEADER
	HRLI	A,-96.*4	; ZERO OUT TIME AND DATE FOR EACH OF 96 ENTRIES
	HRRI	A,DATTIM
	SETZM	(A)
	AOBJN	A,.-1

; THE FOLLOWING MUST BE DONE AT THE BEGINNING OF EACH SURVEY

BGLOOP:	HLRZ	A,HEADER	; GET # OF VALID ENTRIES IN FILE
	AOS	A		; INCREMENT
	CAIG	A,96.		; MAXIMUM OF 96
	HRLM	A,HEADER	; STORE IN HEADER
	.RTIME	A,		; GET CURRENT TIME
	MOVEM	A,HEADER+3	; STORE AS TIME OF MOST RECENT SURVEY
	MOVEM	A,TIMBGN
	.RDATE	A,		; GET CURRENT DATE
	ROT	A,12.
	MOVEM	A,HEADER+4	; STORE AS DATE OF MOST RECENT SURVEY
	MOVEM	A,DATBGN
	MOVE	A,[440300,,ENTRY+2]
	HRRZ	C,HEADER	; # OF SURVEYS SINCE LAST SUMMARIZATION
	JUMPE	C,SAVPTR
	IDIVI	C,12.		; GET WORD # TO ENTER STATUS
	IMULI	D,3
	MOVEI	B,44
	SUB	B,D
	DPB	B,[360600,,A]	; SET UP BYTE PTR TO ENTER STATUS CODE
SAVPTR:	ADD	A,C
	MOVEM	A,EPNTR		; SAVE POINTER
	AOS	HEADER		; INCREMENT SURVEY COUNT SINCE LAST SUMMARIZATION
	.FDELE	CSDATO		; BEFORE OPENING OUTPUT, DELETE EXTRA TRASH
	JFCL			; IF CAN'T, DON'T WORRY - MAYBE ISN'T ONE
	.OPEN	FOUT,CSDATO	; OPEN THE OUTPUT FILE
	JRST	DIE		; IF CAN'T - QUIT BEFORE DAMAGE DONE
	MOVE	B,[-5,,HEADER]
	.IOT	FOUT,B		; OUTPUT THE HEADER TO THE NEW FILE
	MOVEI	A,NUMHOS	; number of hosts in ac A
	IMULI	A,23.		; multiply by number of char per host
	IDIVI	A,5		; divide by 5 to get buffer length
	SKIPE	B		; if remainder is 0,buffer size is OK
	ADDI	A,1		; remainder not 0, increase buffer length by 1
	MOVEM	A,BUFLEN	; SAVE LENGTH OF BUFFER
	MOVE	C,B
	SKIPN	B
	MOVEI	C,5
	ADDI	C,2
	MOVNS	A		; set up iot ptr (net block ascii hack)
	HRL	A,A
	DPB	C,[410300,,A]
	MOVEM	A,DCIOTP
	MOVE	A,[440700,,DCDBUF]	; setting up incremental byte ptr
	JUMPE	B,CON
	MOVEI	C,5
	SUB	C,B
	MOVEI	B,12		; pad with this
PAD:	SOJL	C,CON		; as many characters as are "extra"
	IDPB	B,A
	JRST	PAD
CON:	MOVEM	A,DCDPTR	; save adjust byte ptr
	SETZM	GNCPTR		; INITIALIZE HOST TABLE PTR


; THE FOLLOWING IS THE SURVEY ITSELF IT WILL BE EXECUTED ONCE FOR
; EACH HOST IN THE HOST TABLE (BLOCK)

STLOOP:	PUSHJ	P,GETNXC	; GET NEXT ENTRY FROM CURRENT FILE
	SKIPG	ENTRY		; LAST ENTRY MARKED BY -1
	JRST	ADDNDB		; END OF HOST TABLE REACHED
	SKIPE	REINIT
	SETZM	ENTRY+1		; ZERO OUT TOTAL RESPONSE TIME IF CSMSTR FILE JUST UPDATED

;TRANSLATING DATE AND TIME AND ADDING THEM TO DC BUFFER

	.RDATE	E,
	MOVE	A,[440600,,E]	; BYTE POINTER---FIRST DIGIT SKIPPED
	MOVEI	C,6		; LOOP 4 TIME
SIXASC: ILDB	D,A		; GET NEXT DIGIT AND PUT IN D
	ADDI	D,40		; CHANGE TO ASCII
	IDPB	D,DCDPTR	; DEPOSIT ASCII DIGIT IN BUFFER
	SOJN	C,SIXASC	; LOOP UNTIL C IS 0
	.RTIME  E,		; GET TIME IN HHMMSS
	MOVE	A,[440600,,E]	; SET UP BYTE POINTER
	MOVEI	C,4		; LOOP 4 TIMES
SIXAS2: ILDB	D,A		; GET NEXT DIGIT
	ADDI   	D,40		; CHANGE TO ASCII
	IDPB	D,DCDPTR	; PUT CHAR IN BUFFER
	SOJN	C,SIXAS2	; LOOP UNTIL FOUR DIGITS ARE DONE

; NOW ADDING HOST TO DC BUFFER

	HRRZ 	C,ENTRY		; PUT OCTAL HOST # IN C
	MOVEM	C,NETBLK+3	; PUT IN OPEN BLOCK
	MOVEI	D,3		; SETTING UP FOR CALL, 3 DIGITS IN HOST #
	PUSHJ	P,NUMOUT	; CALL ROUTINE THAT CHANGES OCTALTO ASCII DECIMAL
				; ROUTINE ALSO ADDS HOST TO DC BUFFER
	HLRZ	C,ENTRY		; GET SOCKET #
	MOVEM	C,NETBLK+2	; STORE IN OPEN BLOCK
SURICP:	.RDTIME E,
	MOVEM	E,TIME		;TIME FOR INITIAL OPEN
	.OPEN	NETIN,NETBLK	; ATTEMPT NETWORK CONNECTION
	 JRST	DEAD		; OPEN REJECTED - HOST DEAD
	.RDTIME	E,		; GET CLOCK READING
	MOVEM	E,TIME
	MOVE	B,[NETIN,,RCHSTB]	; ARG FOR .RCHST
	.RCHST	B,		; GET CHANNEL STATUS
	MOVE	C,RCHSTB+1	; GET SOCKET U
	ADDI	C,2		; U+2
	MOVE	B,[60,,(SIXBIT/NET/)]
	.OPEN	TNETIN,B	; RECONNECT INPUT
	JFCL
	HRLI	B,61		; OUTPUT MODE
	ADDI	C,1		; U+3
	.OPEN	TNETOU,B	; RECONNECT OUTPUT
	JFCL
	MOVEI	B,WAIT		; (B)=TIME WILLING TO WAIT FOR RESPONSE
;	NETWAIT	NETIN,4,[5,10,11][(B)]
;	JRST	NRSP		; TIME LIMIT REACHED
;	JRST	ERROR		; ERROR DETECTED
	.CALL	[SETZ? 'NETBLK? I NETIN? I 4? B? M C? SETZM B]
	 JRST	ERROR
	JUMPLE	B,TIMEUP	;TIMED OUT
	JUMPE	C,REJLOG	;CLS CAME BACK
	HRLI	C,1
	LSH	C,(C)		;FLAG BIT MOVES TO MASK CURRENT STATE
	TLNN	C,1_5+1_10+1_11	;GOOD STATES
	 JRST	ERROR

; SUCCESFUL CONNECTION FALLS THROUGH

;	NETWAIT	TNETIN,1,2,150.	; 150 IS SUFFICIENT FOR 5 SECOND WAIT
;	JRST	TIMEUP
;	JRST	ERROR
	.CALL	[SETZ? 'NETBLK? I TNETIN? I 1? B? M C? SETZM B]
	 JRST	ERROR
	JUMPLE	B,TIMEUP
	JUMPE	C,REJLOG
	CAIE	C,2		;ONLY GOOD STATE
	 JRST	ERROR
	.NETAC	TNETIN,
	 JRST	ERROR
;	NETWAIT	TNETOU,1,2,150.
;	JRST	TIMEUP
;	JRST	ERROR
	.CALL	[SETZ? 'NETBLK? I TNETOU? I 1? B? M C? SETZM B]
	 JRST	ERROR
	JUMPLE	B,TIMEUP
	JUMPE	C,REJLOG	;CLS CAME BACK
	CAIE	C,2
	 JRST	ERROR
	.NETAC	TNETOU,
	 JRST	ERROR
	.CLOSE	TNETIN,
	.CLOSE	TNETOU,
	.RDTIME	E,		; GET CLOCK READING NOW
	SUB	E,TIME		; GET ELAPSED TIME
	ADDM	E,ENTRY+1	; UPDATE TIME RECORDS IN TABLE
	MOVEI	B,5		; STATUS CODE FOR LOGGER AVAILABLE
	JRST	ELOOP1		; STORE STATUS AND RESPONSE TIME IN BUFFER

DEAD:	.STATUS	NETIN,A		; GET CHANNEL STATUS
	LDB	A,[220600,,A]	; GET ERROR CODE IN B
	MOVEI	B,0		; CODE FOR STATUS OF UNDETERMINED
	CAIN	A,20		; 20 IS REALLY DOWN
	MOVEI	B,1		; STATUS=1 (HOST DEAD)
	.RDTIME E,
	SUB	E,TIME		;TIME SINCE OPEN, TO CHECK IF RESET TIME-OUT
	CAIL	E,14.*30.	;SEE IF 15 SECONDS, MORE OR LESS
	 MOVEI	B,2		; STATUS=2 (NO RESPONSE FOR INITIAL CONNECTION ATTEMPT)
	JRST	ELOOP1		;STORE STATUS AND TIME FOR DEAD ALSO.

TIMEUP:	MOVEI	B,3		; STATUS=3 (NO RESPONSE)
	JRST	ELOOPT		; STORE STATUS

REJLOG:	MOVEI	B,4		; STATUS=4 (LOGGER REJECTING)
	JRST	ELOOPT		; STORE STATUS

ERROR:	.STATUS	NETIN,B		; ERROR OCCURRED - DETERMINE STATUS
	LDB	B,[140600,,B]	; GET NEEDED BITS
	SKIPN	B	
	JRST	REJLOG		; NONE SET - LOGGER REJECTING (CONNECTION CLOSED)
 	MOVEI	B,0		; STATUS=0 (UNDETERMINED)

ELOOPT:	.RDTIME E,
	SUB	E,TIME
ELOOP1:	.CLOSE	NETIN,
	.CLOSE	TNETIN,
	.CLOSE	TNETOU,
	MOVE 	C,B		; PUT STATUS IN C
	MOVEI	D,1		; ONE DIGIT ONLY IN STATUS
	PUSHJ	P,NUMOUT	; CONVERT TO ASCII DECIMAL AND ADD TO DC BUFFER
;	CAIE	B,5		; IF UP, DON'T PUT IN DEFAULT RESPNSETIME
;	SETZM	E		; NO RESPONSE TIMEIF LOGGER UNAVAILABLE
	MOVE	C,E		; THAT'S THE RESPONSE TIME
	IDIVI	C,3		; GET TENTHS OF SECOND
	MOVEI   D,3		; 3 DIGITS IN RESPONSETIME
	PUSHJ	P,NUMOUT	; CONVERT AND ADD TO DC BUFFER
	HLRZ	C,ENTRY		; GET SOCKET #
	MOVEI	D,3		; 3 DIGITS
	PUSHJ	P,NUMOUT	; PUT IN BUFFER
	MOVEI	C,2		; SCHEDULE OF HOST TO BE UP OR DOWN UNKNOWN
	MOVEI	D,1
	PUSHJ	P,NUMOUT	; STORE CODE IN BUFFER
	MOVEI 	C,15		; CR
	IDPB	C,DCDPTR	; PUT IN BUFFER
	MOVEI 	C,12		; LF TO FOLLOW CR AT END
	IDPB	C,DCDPTR	; PUT IN BUFFER
	MOVE	C,EPNTR		; GET BYTE POINTER
	IDPB	B,C		; STORE THIS STATUS IN HOST'S TABLE
	MOVE	B,[-WORDS-2,,ENTRY]
	.IOT	FOUT,B		; PUT UPDATED ENTRY ON NEW CURRENT FILE
	JRST	STLOOP		; GO BACK FOR MORE HOSTS

; THE FOLLOWING ROUTINE CONVERTS OCTAL NUMBERS TO ASCII DECIMAL
; AND ADDS THEM TO THE DATACOMPUTER BUFFER

NUMOUT: PUSH	P,A
	PUSH	P,B
	PUSH	P,[-1]
	MOVE	A,C
NMLP:	IDIVI	A,10.
	ADDI	B,"0
	PUSH	P,B
	SOJG	D,NMLP
NMLP2:  POP	P,B
	JUMPL	B,NMPLX
	IDPB	B,DCDPTR
	JRST	NMLP2
NMPLX:  POP	P,B
	POP	P,A
	POPJ	P,

; routine to add data to new data base; a separate file is used to contain the survey
; data for each day.  The first file name will be NDCDAT, and the second file name will
; be the date read from a .rdate system call.  Eventually, sending of the survey
; data will be done by a separate demon program once a day, using this new data base.

ADDNDB:	MOVE	A,[100007,,(SIXBIT/DSK/)]	; ATTEMPT TO OPEN IN WRITE OVER MODE
	MOVE	B,[SIXBIT/NDCDAT/]	; FN1
	.RDATE	C,			; FN2
	.OPEN	NDBOUT,A		; OPEN
	JRST	CRNFIL			; CREATE NEW FILE
	MOVEI	C,NDBOUT		; CHAN #
	.CALL	FILLEN			; FIND LENGTH OF FILE
	JRST	CLDATF			; FAIL, GO CLOSE CSDATA FILE
	.ACCESS	NDBOUT,B		; SET PTR TO END OF FILE
	JRST	WRTNDB			; WRITE
CRNFIL:	HRLI	A,7			; CHANGE OPEN MODE
	.OPEN	NDBOUT,A		; TRY TO OPEN AGAIN
	JRST	CLDATF
	HRROI	A,[1]
	.IOT	NDBOUT,A	; INITIALIZE ACCESS POINTER
WRTNDB:	SETOM	C		; WORD TO MARK BEGINNING OF AN ENTRY
	MOVE	D,DCIOTP	; LEFT HALF OF IOT PTR
	MOVE	B,[-2,,C]	; IOT PTR
	.IOT	NDBOUT,B	; WRITE OUT MARKER AND DATA COUNT
	MOVN	B,BUFLEN
	HRL	B,B		; SET UP IOT PTR FOR DATA
	HRRI	B,DCDBUF	; BUFFER ADDRESS
	.IOT	NDBOUT,B	; WRITE OUT THE DATA
	.CLOSE	NDBOUT,		; CLOSE CHANNEL

CLDATF:	SETOM	ENTRY		; WRITE OUT A TRAILER FOR CURRENT FILE
	MOVE	B,[-WORDS-2,,ENTRY]
	.IOT	FOUT,B		; OUTPUT TO THE END OF THE CURRENT FILE
	.RDATE	A,
	ROT	A,12.
	MOVEM	A,DATEND
	.RTIME	A,
	MOVEM	A,TIMEND
	MOVE	B,[-96.*4,,DATTIM]
	SKIPE	FINOPN
	.IOT	FIN,B
	MOVE	B,[-96.*4,,DATBGN]
	.IOT	FOUT,B
	.CLOSE	FIN,		; CLOSE INPUT FILE
	.FDELE	CSDATR		; IF WE MAKE IT BACK RENAME THE FILE TO A GOOD NAME
	JRST	DIE		; QUIT
LPDONE:	.CLOSE	FOUT,		; CLOSE THE FILE
	.OPEN	DSKIN,[SIXBIT/   DSKNDCDAT</]
	JRST	LPDON1
	MOVE	A,[DSKIN,,A]
	.RCHST	A,		; FIND FILE NAME
	.RDATE	D,
	CAMN	C,D		; CHECK IF THERE EXISTS A FILE NOT CREATED TODAY
	JRST	LPDON1
	.CALL	DEMSIG		; SIGNAL SENDING PROCESS
	JFCL
LPDON1:	.LOGOUT			; ALL FINISHED - LOGOUT
	.VALUE			; IF IN DEBUG MODE, LOGOUT WILL FAIL.  INCLUDE A .VALUE

; FULL WILL BE JUMPD TO WHEN SURVEY READS IN A FILE THAT HAS NO MORE
; ROOM ON IT.  IT READS IN A SUMMARY FILE, UPDATES IT WITH THE CURRENT
; INFORMATION AND WRITES IT BACK OUT.  IT THEN ZEROS THE CURRENT ARRAY
; AND STARTS FRESH.

FULL:	SETZM	GNCPTR		; INITIALIZE HOST TABLE PTRS
	SETZM	GNSPTR
	SETZM	MINOPN		; MARK CHAN NOT OPEN
	.OPEN	MIN,SUMRYI	; OPEN THE LATEST SUMMARY FILE
	JRST	NOSUM		; IF THERE ISN'T ONE - ASSUME AN ALL ZERO SUMMARY
	SETOM	MINOPN		; MARK CHAN OPEN
FULL2:	MOVE	A,[-5,,MHEAD]
	.IOT	MIN,A		; READ IN THE MASTER FILE HEADER
	CHKIOT	A

SUMUP:	HRRZ	A,HEADER	; GET CURRENT TEST COUNT
	ADDM	A,MHEAD		; ADD IT TO SUMMARY TEST COUNT
	MOVE	A,HEADER+3	; GET LAST TIME
	MOVEM	A,MHEAD+3	; MAKE IT LAST SUMMARY TIME
	MOVE	A,HEADER+4	; GET LAST DATE
	MOVEM	A,MHEAD+4	; MAKE IT LAST SUMMARY DATE
	SKIPE	MHEAD+1		; SEE IF SUMMARY FIRST TIME IS ZERO
	JRST	FSETUP		; NO - GO ON
	MOVE	B,HEADER+1	; YES - GET FIRST DATE AND TIME FROM CURRENT TO SUMMARY
	MOVEM	B,MHEAD+1	; INIT TIME
	MOVE	B,HEADER+2
	MOVEM	B,MHEAD+2	; INIT TIME
FSETUP:	.OPEN	MOUT,SUMRYO	; OPEN THE MASTER OUTPUT FILE (WITH FAKE NAME)
	JRST	DIE		; DIE IF CAN'T
	MOVE	B,[-5,,MHEAD]
	.IOT	MOUT,B		; OUTPUT HEADER TO NEW MASTER FILE

FLOOP:	PUSHJ	P,GETNXS	; GET NEXT ENTRY FROM MASTER SUMMARY FILE
FFIN:	PUSHJ	P,GETNXC	; GET NEXT ENTRY FROM CURRENT FILE
	MOVE	C,ENTRY		; GET CURRENT HOST NUMBER
FCHECK:	MOVE	B,MENTRY	; GET MASTER HOST NUMBER
	JUMPL	B,FCK2		; END OF MASTER FILE REACHED
	CAML	B,C		; COMPARE
	JRST	FCK2		; GO DO MORE CHECKING
	MOVE	B,[-8.,,MENTRY]
	.IOT	MOUT,B		; OUTPUT THE MASTER ENTRY (HOST IS NO LONGER IN TABLES)
	PUSHJ	P,GETNXS	; GET NEXT ENTRY FROM MASTER SUMMARY FILE
	JRST	FCHECK		; GO BACK TO CHECK IT

FCK2:	CAME	B,C		; SEE IF HOST NUMBERS ARE THE SAME
	JRST	FCK2ON		; NO - KEEP CHECKING
	JUMPL	B,FLDONE	; DONE IF -1 READ
FCK2ON:	MOVEI	D,6		; WILL NEED SUM OF CURRENT ENTRY SO COMPUTE IT
FZLP:	SETZM	FSUM+1(D)	; ZERO OUT THE CURRENT ENTRY SUM AREA
	SOJGE	D,FZLP
	HRLI	D,440300	; SET UP BYTE POINTER TO STATUS LIST
	HRRI	D,ENTRY+2
	MOVE	E,ENTRY+1	; GET TOTAL RESPONSE TIME
	MOVEM	E,FSUM+1
	HRRZ	E,HEADER	; GET TEST COUNT
FSMLP:	ILDB	F,D		; GET NEXT STATUS
	CAIGE	F,6		; NOT INTERESTED IN STATUS OVER 5
	AOS	FSUM+2(F)	; ADD ONE TO COUNT FOR THIS STATUS
	SOJG	E,FSMLP		; LOOP UNTIL ALL STATUSES COUNTED
	CAME	B,C		; NOW COMPARE CURRENT AND MASTER HOST NUMBERS AGAIN
	JRST	FUENT		; CURRENT SMALLER THAN MASTER - PASS CURRENT ONLY
	MOVEI	F,6		; NUMBERS THE SAME - ADD CURRENT COUNT LIST TO MASTER LIST
FSMLP2:	MOVE	B,FSUM+1(F)	; GET SUM FROM CURRENT COUNT LIST
	ADDM	B,MENTRY+1(F)	; UPDATE MASTER COUNT LIST
	SOJGE	F,FSMLP2
	MOVE	F,[-8.,,MENTRY]
	.IOT	MOUT,F		; PASS UPDATED MASTER COUNT LIST
	JRST	FLOOP		; GO BACK FOR ANOTHER HOST IF NO DUMP NEEDED

; NEED THE CURRENT COUNT LIST ONLY.  COME TO HERE ONLY IF THE CURRENT HOST
; DOES NOT APPEAR ON THE MASTER FILE. THIS MEANS THAT IT WAS ADDED TO THE
; SURVEY LIST SINCE THE LAST SUMMARIZE.

FUENT:	MOVE	F,ENTRY		; PUT HOST NUMBER IN THE NEW ENTRY
	MOVEM	F,FSUM
	MOVE	F,ENTRY+1	; PUT THE TOTAL RESPONSE TIME IN THE NEW ENTRY
	MOVEM	F,FSUM+1
	MOVE	F,[-8.,,FSUM]
	.IOT	MOUT,F		; OUTPUT TO THE NEW MASTER FILE 
	JRST	FFIN		; GO BACK AND READ ANOTHER CURRENT ENTRY

; SUMMARIZING IS FINISHED.  WRITE THE TRAILER AND CLOSE THE FILE

FLDONE:	SETOM	ENTRY		; MARK END OF HOST DATA
	MOVE	B,[-8.,,ENTRY]
	.IOT	MOUT,B		; OUTPUT THIS FAKE ENTRY TO THE MASTER FILE
NOCTPL:	.CLOSE	MIN,		; CLOSE THE MASTER INPUT FILE
	.FDELE	SUMRYR		; RENAME CURRENT OUTPUT CSMSTR NOW
	JRST	DIE		; QUIT IF CAN'T
	.CLOSE	MOUT,		; CLOSE THE FILE

; NOW WE HAVE SUMMARIZED THE CURRENT FILE, SO ZERO IT OUT AND START OVER AGAIN

	SETZM	A
	HRRM	A,HEADER	; ZERO OUT COUNT IN HEADER
	MOVEI	A,5
	.ACCES	FIN,A		; RESET ACCESS POINTER
	SETOM	REINIT		; SET FLAG TO REINITIALIZE TOTAL REPONSE TIME
				; IN CURRENT FILE
	POPJ	P,		; RETURN


NOSUM:	MOVEI	A,4		; ZERO OUT THE MASTER FILE HEADER
NSLOOP:	SETZM	MHEAD(A)
	SOJGE	A,NSLOOP
	JRST	SUMUP		; GO SUMMARIZE THE CURRENT FILE

NDEAD:	.CLOSE	NETIN,
	.CLOSE	NETOUT,

DIE:	.LOGOUT			; IF ANYTHING GOES WRONG, QUIT BEFORE DAMAGE IS DONE
	.VALUE			; IF IN DEBUG MODE, LOGOUT WLL FAIL

TSINT:	0
	0
	.DISMIS	[0,,DIE]

GETNXC:	SKIPL	FINOPN		; SKIP IF FILE OPEN
	JRST	GNC2		; INITIALIZE
	SKIPE	A,GNCBUF	; CHECK IF GOT ANYTHING IN BUFFER
	JRST	GNC1		; YES
GNC0:	MOVE	A,[-10.,,GNCBUF]	; IOT PTR
	.IOT	FIN,A		; READ IN
GNC1:	MOVE	A,GNCBUF	; GET HOST AND SOCK #s
	CAMGE	A,HLIST(GNCPTR)
	JRST	GNC0		; NO LONGER IN SURVEY TABLE
	CAME	A,HLIST(GNCPTR)
	JRST	GNC2		; NOT EQUAL OR LESS THAN
	AOS	GNCPTR		; INCREMENT TABLE PTR
	MOVE	A,[GNCBUF,,ENTRY]	; BLT PTR
	MOVEI	B,ENTRY+9.	; BLT EFFECTIVE ADDRESS
	BLT	A,@B		; MOVE BLOCK FROM BUFFER TO ENTRY
	SETZM	GNCBUF		; MARK NOTHING LEFT IN BUFFER
	POPJ	P,		; RETURN

GNC2:	MOVE	A,HLIST(GNCPTR)
	AOS	GNCPTR		; INCREMENT TABLE PTR
	MOVEM	A,ENTRY
	SETZM	ENTRY+1		; ZERO OUT RESPONSE TIME
	MOVE	A,[FILLER,,ENTRY+2]	; BLT PTR
	MOVEI	B,ENTRY+9.	; BLT EFFECTIVE ADDRESS
	BLT	A,@B		; PUT FILLERS IN ENTRY
	POPJ	P,

GETNXS:	SKIPL	MINOPN		; SKIP IF FILE OPEN
	JRST	GNS2		; INITIALIZE
	SKIPE	A,GNSBUF	; CHECK IF GOT ANYTHING IN BUFFER
	JRST	GNS1		; YES
	MOVE	A,[-10,,GNSBUF]	; IOT PTR
	.IOT	MIN,A		; READ IN
GNS1:	MOVE	A,GNSBUF	; GET HOST AND SOCK #s
	CAMLE	A,HLIST(GNSPTR)
	JRST	GNS2		; NOT EQUAL OR LESS THAN
	CAML	A,HLIST(GNSPTR)
	AOS	GNSPTR		; INCREMENT TABLE PTR
	MOVE	A,[GNSBUF,,MENTRY]	; BLT PTR
	MOVEI	B,MENTRY+7	; BLT EFFECTIVE ADDRESS
	BLT	A,@B		; MOVE BLOCK FROM BUFFER TO ENTRY
	SETZM	GNSBUF		; MARK BUFFER EMPTY
	POPJ	P,		; RETURN

GNS2:	MOVE	A,HLIST(GNSPTR)	; GET HOST AND SOCKET FROM TABLE
	MOVEM	A,MENTRY
	AOS	GNSPTR		; INCREMENT TABLE PTR
	MOVE	A,[ZEROS,,MENTRY+1]	; BLT PTR
	MOVEI	B,MENTRY+7	; BLT EFFECTIVE ADDRESS
	BLT	A,@B		; PUT FILLERS IN ENTRY
	POPJ	P,

	END	SURVEY
