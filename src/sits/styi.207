.STITL TELETYPE MACROS

.MACR	ZEPT A,B
	Z==0
	.REPT	A
	B
	Z==Z+1
	.ENDR
.ENDM

.MACR	CONS	A,B,C
	A'B'C
.ENDM

	.STITL SYSTEM DISPATCH TABLE (BYTE ONE)

;FLAG DEFINITIONS
FSF==200	;SPECIAL INPUT
FOF==100	;SPECIAL OUTPUT
FQF==20		;QUOTING
SEPF==4		;SEPARATOR
WSF==2		;WORD SEPARATOR
NNUMF==40	;NOT A NUMBER
OPERF==10	;OPERATOR

;TYPES OF LOGICAL TTYS
MXORF==100000	;MULTIPLEXOR
MXEEF==40000	;MULTIPLEXEE
TTYF==20000	;TTY
MODMF==10000	;MODEM

;HARDWARE TYPES OF TTYS
DHF==4000	;DH11 TTY
DCF==2000	;DC11 TTY
DLF==1000	;DL11 TTY
SYF==400	;SYSTEM CONSOLE
.IIF NZ NTVS,TVF==200	;TV
NLF==0		;NULL (FOR MULTIPLEXEE'S AND PSEUDO TTYS)
SMARTRUBOUTS==1

;INITIALIEZE COUNTERS
NTY==0
NDCTY==0
NDHTY==0
NSYTY==0
NDLTY==0
NNLTY==0	;NUMBER OF MULTIPLEXEE'S ALSO
.IIF GT NTVS,NTVTY==0
NTTY==0
NMODM==0
NMXEE==0
NMXOR==0

.MACRO TTYDEF HARD,ISPEED,OSPEED,PAD,TYPE,MXNUM,DISPNO
.IF2
.=TYINFO+<NTY*2>
.WORD ISPEED!<OSPEED*20>!<PAD*400>
.=TTYTBL+<NTY*2>
FOO==0
.IIF NB MXNUM,FOO==MXNUM*2
.IIF IDN TYPE,MODM,FOO==TTYF
.WORD TYPE'F!'HARD'F!FOO
.=TYDISP+<NTY*2>
.IIF B DISPNO,-1
.IIF NB DISPNO,DISPNO
.IIF NDF NF'HARD',NF'HARD'==NTY*2
.ENDC
N'HARD'TY==N'HARD'TY+1
N'TYPE'==N'TYPE'+1
NTY==NTY+1
.ENDM

FOOBAR==.
TTYDEF SY,0,0,3,TTY
TTYDEF DH,7,7,3,TTY
TTYDEF DH,7,7,3,TTY,,0
TTYDEF DH,7,7,3,TTY,,1
TTYDEF DH,7,7,3,TTY,,2
TTYDEF DH,7,7,3,TTY,,3
TTYDEF DH,7,7,3,MODM
TTYDEF DH,7,7,3,MODM
TTYDEF DH,13,13,3,TTY		;the 2500
TTYDEF DH,7,7,3,TTY
TTYDEF DH,7,7,3,TTY
TTYDEF DH,7,7,3,TTY
TTYDEF DH,7,7,3,TTY
TTYDEF DH,7,7,3,TTY
TTYDEF DH,7,7,3,TTY
TTYDEF DH,13,13,3,TTY		;THE OTHER 2500
TTYDEF DH,7,7,3,TTY
.IFNZ NTVS
TTYDEF DC,0,0,0,MXOR
.REPT NTVS
TTYDEF TV,0,0,0,TTY
.ENDR
.ENDC
.REPT 4
TTYDEF NL,0,0,0,MXEE,21
.ENDR
NDH==<NDHTY+17>/20
NDC==NDCTY
NSY==NSYTY
.IFZ NTVS
NTTYS==NSYTY+NDHTY+NDCTY+NMXEE
.IFF
NTTYS==NSYTY+NDHTY+NDCTY+NMXEE+NTVTY
.ENDC

.=FOOBAR


DTBL:
.BYTE	NNUMF,FOF!NNUMF		;^@	;^A ECHOES AS CR
.BYTE	FSF!NNUMF,FSF!NNUMF	;^B IS CONVERTED TO %
				;^C COPYS NEXT CHARACTER
.BYTE	FSF!NNUMF,NNUMF		;^D DELETES NEXT CHARACTER	;^E
.BYTE	NNUMF,FSF!FOF!NNUMF	;^F	;^G BREAK
.BYTE	FOF!NNUMF,FOF!SEPF!WSF!NNUMF	;^H BACKSPACE	;^I TABULATE
.BYTE	FOF!SEPF!WSF!NNUMF,FOF!SEPF!WSF!NNUMF	;^J LINE FEED
				;^K TABULATE VERTICALLY
.BYTE	FOF!SEPF!WSF!NNUMF,FSF!FOF!SEPF!WSF!NNUMF	;^L FORM FEED
				;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	FSF!NNUMF,NNUMF		;^N GET NEXT WORD	;^O
.BYTE	NNUMF,FSF!NNUMF		;^P	;^Q SUPER-QUOTE
.BYTE	FSF!NNUMF,FSF!NNUMF	;^R COPY REST OF LINE
				;^S SKIP NEXT WORD
.BYTE	NNUMF,NNUMF		;^T	;^U
.BYTE	NNUMF,FSF!NNUMF		;^V	;^W ERASE LAST WORD
.BYTE	FSF!NNUMF,FSF!NNUMF	;^X CLARIFY INPUT
				;^Y EDIT PREVIOUS LINE
.BYTE	FSF!NNUMF,NNUMF		;^Z DESTROY INPUT BUFFER
				;^[ MAYBE ALTMODE
.BYTE	NNUMF,NNUMF		;^\	;^]
.BYTE	NNUMF,NNUMF		;^^	;^_ ANY BETTER IDEAS FOR THEM?
.BYTE	SEPF!WSF!NNUMF,NNUMF!SEPF!OPERF	;SP	;! COMMENT?
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;"	;# ACTION OF
.BYTE	NNUMF,NNUMF		;$	;%
.BYTE	NNUMF,NNUMF!OPERF	;&	;' (MAYBE LE)
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;( ARITH GROUP	;) DITTO
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;* MULTIPLY	;+ ADD
.BYTE	NNUMF,SEPF!NNUMF!OPERF	;,	;- SUBTRACT
 .BYTE	0,SEPF!NNUMF!OPERF
.BYTE	0,0	;0	;1
.BYTE	0,0	;2	;3
.BYTE	0,0	;4	;5
.BYTE	0,0	;6	;7
.BYTE	0,0	;8.	;9.
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF	;: THING OF	;; PROPERTY OF
.BYTE	SEPF!NNUMF!OPERF,SEPF!NNUMF!OPERF	;<	;=
.BYTE	SEPF!NNUMF!OPERF,NNUMF	;>	;?
.BYTE	NNUMF,NNUMF		;@	;A
.BYTE	NNUMF,NNUMF		;B	;C
.BYTE	NNUMF,0			;D	;E
.BYTE	NNUMF,NNUMF		;F	;G
.BYTE	NNUMF,NNUMF		;H	;I
.BYTE	NNUMF,NNUMF		;J	;K
.BYTE	NNUMF,NNUMF		;L	;M
.BYTE	0,NNUMF			;N	;O
.BYTE	NNUMF,NNUMF		;P	;Q
.BYTE	NNUMF,NNUMF		;R	;S
.BYTE	NNUMF,NNUMF		;T	;U
.BYTE	NNUMF,NNUMF		;V	;W
.BYTE	NNUMF,NNUMF		;X	;Y
.BYTE	NNUMF,FSF!FQF!SEPF!WSF!NNUMF	;Z	;[
.BYTE	SEPF!NNUMF!OPERF,FSF!FQF!SEPF!WSF!NNUMF	;\ MODULO	;]
.BYTE	SEPF!NNUMF,SEPF!NNUMF!OPERF	;^ EXPONENT	;_ MAKE
.BYTE	NNUMF,NNUMF		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	NNUMF,NNUMF		;b LOWER CASE	;c LOWER CASE
.BYTE	NNUMF,NNUMF		;d LOWER CASE	;e LOWER CASE
.BYTE	NNUMF,NNUMF		;f LOWER CASE	;g LOWER CASE
.BYTE	NNUMF,NNUMF		;h LOWER CASE	;i LOWER CASE
.BYTE	NNUMF,NNUMF		;j LOWER CASE	;k LOWER CASE
.BYTE	NNUMF,NNUMF		;l LOWER CASE	;m LOWER CASE
.BYTE	NNUMF,NNUMF		;n LOWER CASE	;o LOWER CASE
.BYTE	NNUMF,NNUMF		;p LOWER CASE	;q LOWER CASE
.BYTE	NNUMF,NNUMF		;r LOWER CASE	;s LOWER CASE
.BYTE	NNUMF,NNUMF		;t LOWER CASE	;u LOWER CASE
.BYTE	NNUMF,NNUMF		;v LOWER CASE	;w LOWER CASE
.BYTE	NNUMF,NNUMF		;x LOWER CASE	;y LOWER CASE
.BYTE	NNUMF,NNUMF		;Z LOWER CASE	;LEFT BRACE
.BYTE	NNUMF,NNUMF		;VERTICAL BAR	;RIGHT BRACE
.BYTE	NNUMF,FSF!NNUMF		;TILDE	;RUBOUT
	.STITLE SYSTEM DISPATCH TABLE (BYTE TWO)
;NUMBERS POINT TO OTHER TABLES
;$ POINTS TO SYSTEM OBLIST

DTBL2:
.BYTE	0,0		;^@ 			;^A
.BYTE	36,0		;^B BECOMES %, PRINTS AS SPACE IN STRINGS
			;^C COPY NEXT CHARACTER
.BYTE 2,0		;^D DELETES NEXT CHAR	;^E
.BYTE	0,4		;^F 			;^G BREAK
.BYTE	2,10		;^H BACKSPACE		;^I TABULATE
.BYTE	12,14		;^J LINE FEED		;^K TABULATE VERTICALLY
.BYTE	16,6		;^L FORM FEED
			;^M CARRIAGE RETURN	ECHOES AS CRLF
.BYTE	10,0		;^N GET NEXT WORD		;^O
.BYTE	0,12		;^P 			;^Q SUPER-QUOTE
.BYTE	14,16		;^R 			;^S SKIP NEXT WORD
.BYTE	0,0		;^T	;^U
.BYTE	0,20		;^V	;^W ERASE LAST WORD
.BYTE	22,24		;^X CLARIFY INPUT	;^Y
.BYTE	26,0		;^Z DESTROY INPUT BUFFER
			;^[ MAYBE ALTMODE
.BYTE	0,0		;^\	;^]
.BYTE	0,0		;^^	;^_ WELL, ANY BETTER IDEAS FOR THEM?
.BYTE	0,0		;SP	;! COMMENT?
.BYTE	0,0		;"	;# ACTION OF
.BYTE	0,0		;$	;%
.BYTE	0,0		;&	;' (MAYBE LE)
.BYTE	0,0		;( ARITHMETIC GROUPING	;) DITTO
.BYTE	0,0	;* MULTIPLY	;+ ADD
.BYTE	0,0		;,	;- SUBTRACT
.BYTE	0,0		;.	;/ DIVIDE
.BYTE	0,0		;0	;1
.BYTE	0,0		;2	;3
.BYTE	0,0		;4	;5
.BYTE	0,0		;6	;7
.BYTE	0,0		;8.	;9.
.BYTE	0,0		;: THING OF	;; PROPERTY OF
.BYTE	0,0	;<	;=
.BYTE	0,0		;>	;?
.BYTE	0,0		;@	;A
.BYTE	0,0		;B	;C
.BYTE	0,0		;D	;E
.BYTE	0,0		;F	;G
.BYTE	0,0		;H	;I
.BYTE	0,0		;J	;K
.BYTE	0,0		;L	;M
.BYTE	0,0		;N	;O
.BYTE	0,0		;P	;Q
.BYTE	0,0		;R	;S
.BYTE	0,0		;T	;U
.BYTE	0,0		;V	;W
.BYTE	0,0		;X	;Y
.BYTE	0,32		;Z	;[
.BYTE	0,34	;\ MODULO	;]
.BYTE	0,0		;^ (MAYBE EXPONENTIATE)		;_ MAKE
.BYTE	0,0		;` GRAVE ACCENT	;a LOWER CASE
.BYTE	0,0		;b LOWER CASE	;c LOWER CASE
.BYTE	0,0		;d LOWER CASE	;e LOWER CASE
.BYTE	0,0		;f LOWER CASE	;g LOWER CASE
.BYTE	0,0		;h LOWER CASE	;i LOWER CASE
.BYTE	0,0		;j LOWER CASE	;k LOWER CASE
.BYTE	0,0		;l LOWER CASE	;m LOWER CASE
.BYTE	0,0		;n LOWER CASE	;o LOWER CASE
.BYTE	0,0		;p LOWER CASE	;q LOWER CASE
.BYTE	0,0		;r LOWER CASE	;s LOWER CASE
.BYTE	0,0		;t LOWER CASE	;u LOWER CASE
.BYTE	0,0		;v LOWER CASE	;w LOWER CASE
.BYTE	0,0		;x LOWER CASE	;y LOWER CASE
.BYTE	0,0		;z LOWER CASE	;{ OPEN BRACE
.BYTE	0,0		;| VERTICAL BAR, MAYBE OR, MAYBE XOR
			;} CLOSE BRACE
.BYTE	0,30		;~ TILDE, LOGICAL NOT	;RBO	RUBOUT
.STITL TELETYPE DISPATCH TABLES--DATA SPACE
;ALL FOLLOWING CODE CAN BE IN DATA SPACE ONLY!!!!!!!!!!

;DISPATCH TABLE FOR SPECIAL INPUT CHARS WITH EFFECT ON TYPEOUT LEVEL
TIICTB:	TOICC	;^C COPY NXT CHAR FROM EDIT TO TYI BUFFER
	TOICD	;^D DELETE NEXT CHAR FROM EDIT BUFFER
	RTSPCS	;^G ADDRESS OF AN RTS PC
	TOICM	;^M POSSIBLE END OF LINE
	TOICN	;^N COPY NEXT WD FROM EDIT TO TYI BUFFER
	TOICQ	;^Q JUST ECHO
	TOICR	;^R COPY REST OF EDIT BUFFER TO TYI BUF
	TOICS	;^S SKIP NXT WD IN ED. BUF.
	TOICW	;^W RUB OUT UP TO PREVIOUS WD SEPERATOR
	TOICX	;^X CLARIFY INPUT
	TOICY	;^Y RECOVER PREVIOUS LINE
	RTSPCS	;^Z ADDRESS OF AN RTS PC
	TOIRB	;RUBOUT
	TOIOB	;[ INCREMENT LIST COUNT
	TOICB	;] DECREMENT LIST COUNT
	TICB


;DISPATCH TABLE FOR CHARS SPECIAL ON OUTPUT
;(HAVE FOF ON IN DTBL(CHARACTER)
TOOCTB:	TOOCA	;^A PRINTS AS C.R.
	TOOCH	;^H BACKSPACE, DECREMENTS CHARNO
	TOTYOC	;^G PRINTS AS SELF
	TOOCM	;^M PRINTS AS CR, LF
	TOOCI	;^I (TAB) SPACES TO NEXT TAB STOP
	TOTYOC	;^J (LINEFEED) PRINTS AS SELF
	TOTYOC	;^K (VERTICAL TAB) PRINTS AS SELF
	TOTYOC	;^L (FORMFEED) PRINTS AS SELF

;DISPATCH TABLE FOR CHARS WITH SPECIAL RUBOUT PROPERTIES
DTBLRO:	TRBOUT,TRBOCA,TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOCG
	TRBOUT,TRBOCI,TRBOCJ,TRBOUT,TRBOCL,TRBOCM,TRBOUT,TRBOUT
	TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT
	TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT,TRBOUT
	.STITL	FLOATING TRAP VECTORS & DEVICE INFO

	FOO==.
	.=300	;START OF FLOATING VECTORS
;DC11 (BR5)
ZEPT	NDC,<
	CONS DC,\Z,<RS=174000+<Z*10>>	;RCV STATUS REG
	CONS DC,\Z,<RB=174002+<Z*10>>	;RCV BUFFER
	CONS DC,\Z,<TS=174004+<Z*10>>	;TRANSMIT STATUS
	CONS DC,\Z,<TB=174006+<Z*10>>	;TRANS BUF
	CONS DC,\Z,RV=.			;RCV VECTOR
	CONS DC,\Z,TV=.+4		;TRANS VECTOR
	CONS DC,\Z,RK
	240
	CONS DC,\Z,TK
	240
>

;DH11 (BR5)
ZEPT	NDH,<
	CONS DH,\Z,<SCR=160020+<Z*20>>	;SYSTEM CONTROL REGISTER
	CONS DH,\Z,<NRC=160022+<Z*20>>	;NEXT RECIEVED CHARACTER
	CONS DH,\Z,<LPR=160024+<Z*20>>	;LINE PARAMTER REGISTER
	CONS DH,\Z,<CAR=160026+<Z*20>>	;CORE ADDRESS REGISTER
	CONS DH,\Z,<BCR=160030+<Z*20>>	;BYTE COUNT REGISTER
	CONS DH,\Z,<BAR=160032+<Z*20>>	;BUFFER ACTIVE REGISTER
	CONS DH,\Z,<BRC=160034+<Z*20>>	;BREAK CONTROL REGISTER
	CONS DH,\Z,<SSR=160036+<Z*20>>	;SILO STATUS REGISTER
;CROCK
.=340
	CONS DH,\Z,RV=.
	CONS DH,\Z,TV=.+4
	CONS DH,\Z,RK
	240
	CONS DH,\Z,TK
	240
>
	.=FOO
;STANDARD DEVICE REGISTER BITS
%ER==1_15	;ERROR
%RDY==1_7	;READY
%INT==1_6	;INTERRUPT ENABLE
%CRDT==1_2	;CARRIER DETECT
%ENB==1		;ENABLE
%DTRDY==1	;DATA TERMINAL READY


OMXRES=.-NFNLTY		;SO THAT THE INDEX OF A PSEUDO TTY NO. WILL POINT INTO
			;THIS TABLE AT THE RIGHT PLACE
	OMXNUL==OMXRES+1	;RH--RESET CHAR, LH--NULL CHAR
	.BYTE 0,40	;TURT 1
	.BYTE 0,40	;TU 2
	0	;MBX
	.BYTE 0,21	;DUMMY
.STITL TELETYPE VARIABLES
	NFTY==0
	NFDHTY==2*NSYTY
	NFDCTY==2*<NSYTY+NDHTY>
	NFTV==<NSYTY+NDHTY+NDCTY>*2
	NFNLTY==<NSYTY+NDHTY+NDCTY+NTVS>*2


TTYITM:	.BLKW NTTYS
TYINFO:	.BLKW NTTYS
TYPAD==TYINFO+1		;NUMBER OF CHARACTERS TO PAD
TTYTBL:	.BLKW NTTYS
TYDISP:	.BLKW NTTYS

DHMAX==10	;MAXIMUM # CHARS TO SEND TO EACH DH11 TELETYPE
DHBIT:		ZEPT 20,1_.RPCNT	;MASKS FOR THE DH11 BUFFER ACTIVE REGISTER
DHBUF:		ZEPT 20,DHOBUF+<DHMAX*.RPCNT>	;PNTR TO DHOBUF

DHOBUF:	.BLKB DHMAX*16.*NDH	;WHERE DH11 SENDS CHARS FROM
DH0PBR:	0	;PSEUDO BAR
TTYCL:	-1	;CONTAINS ITEM NO. OF THE CORE LINK THAT ENDS AT THE SYSJOB


.INSRT SITS;TVTTY >

;BREAK VECTORS POINT TO THESE RECEIVE INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TKBRK:	SAVE <E,D>
	MOV	#NFTY,E
	MOV #TKS,D
	JMP	GENRBK
.ENDC


DC0RK:	SAVE <E,D>
	MOV #NFDCTY,E
	MOV #DC0RS,D
	JMP	GENRBK


.IFNZ	NTY+NDCTY
;GENRBK--
;GENERAL RECEIVE BREAK FOR TTYS, TBOXS, ETC.
;CALLED WITH	SAVE <E,D>
;		MOV #TTY INDEX,E
;		MOV #TTY STATUS REG,D
;		JMP GENBRK

GENRBK:	JSR	F,ACSAV
	MOV	D,F	
	MOV (F),D	;RG CONTENTS
	BIT	#%ER,D
	BNE	TGENER	;BR IF ERROR BIT ON
	MOV	2(F),D	;CHARACTER
	BIC	#177600,D	;ONLY 7 BITS
	BIT	#TIRST,TTYST1(E)
	BEQ	1$
	JSR	PC,TYIRT1	;RESET INPUT
1$:	BIT #MXORF,TTYTBL(E)
	BEQ TYBRK
	JSR PC,MXRCV
	BR GENRB1
TYBRK:	JSR PC,TYRCV
GENRB1:	JSR	F,ACRES
	REST	<D,E>
	CHECKP
	RTT

TGENER:		;PRINT ERROR MESSAGE
	BR	GENRB1

.ENDC

.IFNZ NDH
DH0RK:	JSR F,ACSAV
	MOV #-1,A
	JSR PC,ITM2PL		;FAKE PUSH
DH0RK2:	MOV DH0NRC,C		;GET THE CHARACTER
	BGE DH0RK3		;NO CHARACTER
	BIC #110200,C		;CLEAR SILLY BITS
	BIT #60000,C		;IS IT A BREAK?
	BEQ DH0RK1		;NOPE
	BIC #60377,C		;CLEAR CHARACTER AND BREAK BITS
	ADD #7,C		;BREAK
DH0RK1:	MOV C,E			;COPY IT
	SWAB E			;GET LINE NUMBER
	BIC #177760,E		;FLUSH CRAP
	ASL E			;CHANGE LINE NO. INTO A PARTIAL TTY INDEX
	ADD #NFDHTY,E		;MAKE THE INDEX CORRECT
	MOV C,D			;COPY AGAIN
	BIC #177600,D		;JUST THE CHARACTER
	MOV TTYITM(E),A		;THE TTY ITEM
	BLE DH0RK4		;NOT REALLY THERE
	JSR PC,ITM2LD		;LOAD THE TTY
	BIT #TIRST,TTYST1(A)	;RESET INPUT?
	BEQ 1$
	JSR PC,TYIRT1		;GO RESET IT
1$:	BIT #MXORF,TTYTBL(E)	;IS IT A MULTIPLEXOR
	BEQ DHTTY		;NO
	JSR PC,MXRCV		;GO TO THE MULTIPLEXOR RECEIVE
	BR DH0RK2		;ANY MORE
DHTTY:	JSR PC,TYRCV		;GO TO THE TELETYPE RECEIVE
	BR DH0RK2		;ANY MORE?
DH0RK3:	JSR PC,ITM2PO		;POP IT
	JSR F,ACRES
	CHECKP
	RTT
DH0RK4:	JSR PC,TYRCV2		;MAKE ME A TTY ITEM
	BR DH0RK2
.ENDC

;MULTIPLEXOR RECIEVE INTERRUPT
MXRCV:	TST TTYITM(E)		;DOES HE HAVE AN ITEM
	BEQ RTSPC		;NOPE
;HERE CAUSE THE ITEM TO BE CREATED
MXRCV4:	MOV TTYITM(E),A		;GET THIS TTY'S ITEM NO. IN A
	JSR PC,ITM0PL		;LOAD THE TTY ITEM
	SAVE	E		;SAVE MULTIPLEXOR'S TTY NO.
	JSR	PC,MXGTY	;GET INDEX OF LOG DEV THIS CHAR BELONGS TO
	BEQ	MXRCV1		;FAIL, THIS CHAR DOESN'T BELONG TO ANYONE
	JSR PC,TYRCV1		;THE DEVICE BETTER NOT BE A MULIPLEXOR
MXRCV1:	JSR PC,ITM0PO		;RESTORE THE PREVIOUS ITEM
	REST E
RTSPCS:
MXRCV2:	SEZ
RTSPC:	RTS PC


MXGTY:	;GETS TTY # OF NEXT LOG. DEV. IN MX Q, UPDATES Q,
	;FAILS IF NOTHING IN QUEUE
	TST	TIQN(A)
	BLE	MXRCV2		;Q EMPTY, FAIL
	SAVE	D
	MOV TIQN(A),C		;THE NUMBER OF CHAR IN QUE
	MOV #TIQM,D		;RELATIVE POINTER TO BEGINNING OF QUE
	ADD A,D			;MAKE IT ABSOLUTE
	MOVB	(D)+,E		;GET THE IDENTIFIER CHAR
MXGTY1:	MOVB	(D)+,-2(D)	;MOVE REST OF Q UP ONE BYTE
	SOB C,MXGTY1
	DEC	TIQN(A)		;DEC MULTIPLEXOR'S CHAR COUNT
	REST	D
	CLZ
	RTS PC

;ADD CHAR IN D TO BOTTOM OF MX Q
;THIS SHOULD BE THE FIRST THING DONE WHEN SENDING A CHAR TO A MULTIPLEXEE
MXQLAD:	CMP TIQN(A),#TIQSZ	;IS THE MULTIPLEXOR'S QUE FULL
	BGE	MXRCV2		;YES GO AWAY
	MOV TIQI(A),B		;GET RELATIVE POINTER TO NEXT CHAR IN
	ADD A,B			;MAKE IT ABSOLUTE	
	MOVB D,(B)		;MOVE THE CHAR THERE
	INC TIQN(A)		;INCREMENT THE CHAR COUNT
	INC TIQI(A)		;INCREMENT THE CHAR IN POINTER
	CLZ
	RTS PC
.STITL TYPEIN--INTERRUPT LEVEL
;TELETYPE RECIEVE
;PROCESS CHAR IN D FOR TTY IN E
;CAN CLOBBER A,F

TYRCV:	TST TTYITM(E)		;DOES THIS TTY HAVE AN ITEM YET?
	BNE TYRCV4		;YES IT DOES
TYRCV2:	MOV TTYCL,A		;THE CORE LINK TO SYSJOB
	BMI TYRET1		;NOT SET UP YET
.IFNZ NTVS
	CMPB D,TVDOIT+LKBTAB	;WAS "DO IT" TYPED?
	BEQ TYRCV3		;YES
.ENDC
	CMPB D,#32		;TYPED CTL-Z
	BNE TYRET1		;NOPE, FORGET IT
TYRCV3:	JSR PC,ITM0PL		;LOAD THE CORE LINK
	MOV CLNUM(A),D		;THE NUMBER OF SLOTS
	SUB CLCNT(A),D		;GET THE NUMBER OF FREE SLOTS
	CMP D,#1		;ARE THERE 1
	BLO TYRET
	MOV E,D			;THE TTY NO.
	ASR D			;GET THE NUMBER FROM THE INDEX
	JSR PC,CLDPBY		;DEPOSITE THE BYTE INTO CORE LINK
	MOV #-1,TTYITM(E)	;SAY WE ARE IN THE PROCESS OF CREATING ONE FOR HIM
	BR TYRET		;RETURN NOW	
TYRCV4:	MOV TTYITM(E),A		;GET ITS ITEM INDEX
	BMI TYRET1		;TTY ITEM IS IN PROCESS OF BEING CREATED
	JSR PC,ITM0PL		;LOAD THE TTY ITEM
	BIT #TILIPM,TTYST1(A)		;IN LOGO LINE INPUT MODE?
	BEQ TYRCV1		;NO JUST PUT THE CHAR IN BUFFER
	MOV TTYU(A),F		;IS THERE A USER FOR THIS TTY
	BLT TYRCV1		;NOPE
	;HERE DETERMINE IF HE HAS TYPED A BREAK
TYRCV1:	BIT #TICVM,TTYST1(A)	;DOES HE WANT LOWER CASE CONVERTED TO UPPER?
	BEQ 1$			;NO
	JSR PC,TICVLU		;CONVERT LOWER CASE LETTERS TO UPPER
1$:	BIT #TICTM,TTYST1(A)	;CONTROLIFY MODE?
	BEQ TYRCV6		;NO
	CMPB D,#37		;IS IT THE CONTROLIFY CHAR IE CONTROL UNDERSCORE
	BNE TYRCV5		;NO, CHECK IF THE CONTROLIFY FLAG IS SET
	BIT #TICTF,TTYST1(A)	;IF CONTROLIFY FLAG ALREADY SET,
	BNE TYRCV5		;PASS THE CONTROLIFY CHAR ON TO PROGRAM
	BIS #TICTF,TTYST1(A)	;ELSE TURN ON THE CONTROLIFY FLAG
	BR TYRET		;AND DO NOT PASS THE CONTROLIFY CHAR ON
TYRCV5:	BIT #TICTF,TTYST1(A)	;IS THE CONTROLIFY FLAG SET?
	BEQ TYRCV6		;NO
	BIC #100,D		;IF IT WAS ON, CONVERT THE CHAR TO CONTROL CHAR
	BIC #TICTF,TTYST1(A)	;AND TURN OFF THE CONTROLIFY FLAG
TYRCV6:	MOV D,TLAST(A)		;SAVE IT AWAY AS LAST CHAR TYPED
	CMP #TIBSZ,TIBN(A)	;IS NO. OF CHAR IN BUFFER=BUFFER SIZE
	BEQ TYRET		;YES GO AWAY
	MOV TIBI(A),C		;GET RELATIVE CHAR IN POINTER
	ADD A,C			;MAKE IT ABSOLUTE
	MOVB D,(C)		;PUT CHAR IN BUFFER
	INC TIBN(A)		;INC CHAR COUNT
	INC TIBI(A)		;INC CHAR IN POINTER
	CMP #TIBT,TIBI(A)	;ARE WE AT THE END OF THE BUFFER YET
	BHI TYRET	;NOPE
	MOV #TIBB,TIBI(A)	;RESET THE CHAR IN POINTER
TYRET:	JSR PC,ITM0PO		;RESTORE THE ORIGINAL ITEM0
TYRET1:	RTS PC
;THIS ROUTINE ASSUMES THE TTY ITEM IS IN ITEM1
;AND THE ADR OF ITEM IN A
;THIS ROUTINE SHOULD JUST PUT CHARS IN BUFFER IF NOT IN LOGO INPUT MODE
TICP:	SAVE B
	BIT #TIRST,TTYST1(A)	;SHOULD THE TTY BE RESET
	BEQ TICPLT		;NOPE
	JSR PC,TYIRT1		;RESET IT
TICPLT:	CMP #TIBT,TIBO(A)	;HAVE WE REACHED THE TOP OF THE INPUT BUFFER?
	BHI TICP7		;NO
	MOV #TIBB,TIBO(A)	;RESET THE POINTER AND CONTINUE
TICP7:	MOV TIBO(A),D		;GET RELATIVE ADR. OF THE NEXT CHAR.
	ADD A,D			;MAKE IT ABSOLUTE
	MOVB (D),D		;GET THE CHAR. INTO D
	INC TIBO(A)		;INC POINTER
	DEC TIBN(A)		;DECREMENT COUNT
	BIT #TILIPM,TTYST1(A)
	BEQ TICP3
	BIT #TIQF,TTYST1(A)	;TEST TO SEE IF WE ARE QUOTING THIS CHAR.
	BEQ TICP4		;WE AREN'T
	BIC #TIQF,TTYST1(A)	;CLEAR QUOTING FLAG
	BIS #200,D		;SET PARITY BIT TO QUOTE
	BR TICP3		;DON'T CHECK FOR SPECIAL MEANING
TICP4:	BITB #FSF,DTBL(D)	;DOES IT HAVE SPECIAL MEANING?
	BEQ TICP3		;NOPE
	MOVB DTBL2(D),C		;GET INDEX OF CHAR. INTO SPECIAL CHAR. TABLES
	JSR PC,@TIICTB(C)	;GO DO SPECIAL THING
	BEQ TICPLB		;IF Z BIT SET DONT PUT THIS CHAR. INTO INPUT BUFFER
TICP3:	JSR PC,TYINQ		;PUT THIS CHAR. INTO INPUT BUFFER
	BEQ TICPRT		;FAILED SO GO AWAY
TICPLB:	TST TIBN(A)		;ANY MORE CHAR TO PROCESS
	BNE TICPLT		;YES THERE ARE
TICPRT:	JSR PC,TOCINT		;CAUSE AN OUTPUT INTERUPT (ECHO CHAR.)
TICP5:	REST B
	RTS PC

;PUT CHAR IN D INTO CONSOLE IN E'S INPUT QUE
TYINQ:	SAVE F
	CMP TIQN(A),#TIQSZ	;NO. OF CHAR IN BUFFER=SIZE OF BUFFER?
	BGE	TIINQ1		;BR IF QUE FULL
	MOV TIQI(A),F		;GET RELATIVE AADR. OF NEXT CHAR IN
	ADD A,F			;MAKE IT ABSOLUTE
	MOVB	D,(F)		;PUT THE CHAR. IN THE INPUT QUE
	INC	TIQI(A)		;INC POINTER
	INC	TIQN(A)		;INC COUNTER
	INC	TIQTON(A)	;INC NO. OF CHAR FOR ECHONG TO PROCESS
	INC TITQN(A)		;INC TOTAL NO. OF CHAR IN QUE
	REST F
	CLZ
	RTS PC

TIINQ1:	REST F
	SEZ
	RTS PC

;THIS ROUTINE TAKES THE NO. OF CHAR DESIRED IN B AND
;RETURNS WITH CONDITION CODES SET IF ENOUGH CHAR
CHARCK:	BIT #TILIPM,TTYST1(A)	;IN LINE INPUT MODE
	BNE CHRCK1	;YES
	MOV TIBN(A),B
	RTS PC
CHRCK1:	MOV TIEQTN(A),B
	RTS PC

;PUT A CHAR INTO THE OUTPUT BUFFER EXPECTS TTY IN ITEM2
;HANG IF FULL
TYO:	BIT #TERST,TTYST1(A)	;RESET THE EDIT BUFFER
	BEQ 2$		;NO
	JSR PC,TYERT	;RESET THE EDIT BUFFER
2$:	BIT #TMORM,TTYST1(A)	;ARE WE IN MORE MODE?
	BEQ 3$		;NO
	JSR PC,TMORE	;CHECK FOR POSSIBLE MORE BREAK
3$:	BIT #TILIPM,TTYST1(A)	;IN LINE INPUT MODE?
	BEQ 1$		;NO, FORGET THE EDIT MODE
	BIT #.TTEDM,E	;IS THIS AN EDIT MODE WRITE
	BNE TYO3	;YES
1$:	TST TOPC(A)	;IS THE OUTPUT BUFFER FULL
	BEQ TYO2	;NOPE
TYO1:	JSR PC,TOSOP
	BR 1$
	BR TYO6
1$:	JSR PC,LFLUSH	;GET RID OF YOURSELF FOR A LONG TIME
	TST TOPC(A)	;STILL FULL
	BNE TYO1	;YES
TYO6:	JSR PC,RUNME	;GOT IT
	BR TYO		;JUST TO MAKE SURE
TYO2:	SAVE C
	JSR PC,TOTYO	;PUT THE CHARACTER INTO THE OUTPUT BUFFER
	REST C
	JSR PC,TOCINT	;CAUSE AN INTERUPT
	RTS PC
TYO3:	CMP TITQN(A),#TIQSZ,	;INPUT BUFFER FULL?
	BLT TYO4	;PLENTY OF ROOM
TYO5:	JSR PC,LFLUSH
	CMP TITQN(A),#TIQSZ	;STILL FULL
	BGE TYO5
	JSR PC,RUNME	;I AM DONE
	BR TYO3		;MAKE SURE
TYO4:	SAVE <C,D>	;GET A REG.
	DEC TIEQO(A)	;POINT TO THE CHARACTER
	MOV TIEQO(A),C	;GET POINTER TO WHERE TO PUT THE CHARACTERS
	ADD A,C		;POINT TO IT DIRECTLY
	MOV TIEQN(A),D	;NUMBER OF BYTES
	BEQ TYO7	;NONE
1$:	MOVB 1(C),(C)+	;COPY BUFFER DOWN
	SOB D,1$
TYO7:	MOVB (P)+,(C)+	;PUT IT INTO THE BUFFER
	INC TITQN(A)	;SAY ANOTHER BYTE IN THE INPUT QUE
	INC TIEQN(A)	;SAY ANOTHER BYTE FOR READING OUT OF THE OUTPUT QUE
	REST C
	RTS PC	

;TLINE UPDATES THE LINENO VARIABLE. THIS VARIABLE CHANGES ONLY WHEN THE CHARS
;CONTROL L, P AND N, AND LF ARE OUTPUT. ALL OTHER CHARS HAVE NO EFFECT.
TLINE:	CMPB D,#12	;LF?
	BNE TLINE2	;NO
	INC LINENO(A)	;LINEFEED CAUSES THE CURSOR TO ADVANCE ONE LINE
.IFNZ NTVS
	CMP LINENO(A),TVHIGH(A)	;ARE WE PAST THE LAST LINE?
	BNE TLINE5	;NO
	BIT #.TSCRL,TTYST2(A)	;ARE WE IN SCROL MODE?
	BEQ TLINE1	;NO
	SUB TVNLSC(A),LINENO(A)	;GO BACK UP BY NO. OF LINES TO SCROLL
	BR TLINE5
TLINE1:	CLR LINENO(A)	;GO BACK TO THE TOP LINE IN WRAP MODE
	BR TLINE5
TLINE2:	CMPB D,#20	;^P?
	BNE TLINE3
	TST LINENO(A)	;ARE WE AT THE TOP NOW?
	BEQ TLINE5	;YES, DO NOT GO UP ANYMORE
	DEC LINENO(A)	;ELSE GO BACK UP ONE LINE
	BR TLINE5
TLINE3:	CMPB D,#16	;^N?
	BNE TLINE4	;NO
	INC LINENO(A)	;GO DOWN ONE LINE
	CMP LINENO(A),TVHIGH(A)	;UNLESS WE ARE ALREADY PAST THE LAST LINE
	BLT TLINE5	;NO WE'RE NOT
	DEC LINENO(A)	;YES WE ARE. DO NOT GO ANY FURTHER DOWN
	BR TLINE5
.IFF
TLINE2:
.ENDC
TLINE4:	CMPB D,#14	;^L?
	BNE TLINE5	;NO
	CLR LINENO(A)	;LINEFEED CAUSES THE CURSOR TO HOME UP
TLINE5:	RTS PC

;TMORE DOES THE MORE PROCESSING
TMORE:	.IFNZ NTVS	;ONLY IF TVS ARE ENABLED
	SAVE <C,E>	;GET SOME REGISTERS
	BIT #.TTMBK,E	;DOES HE WANT TO MORE BREAK ON THIS TYO
	BEQ TMORE2	;NO
	MOV TVHIGH(A),C	;THE NUMBER OF LINES ON THE SCREEN
	DEC C		;THE LAST LINE ON THE SCREEN
	CMP LINENO(A),C	;ARE WE ON THIS LINE?
	BNE TMORE2	;NO
	TST CHARNO(A)	;ARE WE TRYING TO TYPE THE FIRST CHAR
	BNE TMORE2	;NO
	BIS #.TMORF,TTYST1(A)	;TRIGGER MORE BREAK
TMORE1:	JSR PC,LFLUSH	;GO AWAY FOR A WHILE
	BIT #.TMORF,TTYST1(A)	;ARE WE STILL MORE BLOCKED?
	BNE TMORE1	;YES
	JSR PC,RUNME	;GO
TMORE2:	REST <E,C>	;CLEAN UP
.ENDC
	RTS PC
	

;*****TIOQ RUNS AT USER LEVEL ALSO******
;GET A CHAR FROM INPUT QUEUE
;THIS ROUTINE EXPECTS TTY ITEM IN ITEM2 AND ADDRESS IN A

TIOQ:	BIT #TILIPM,TTYST1(A)	;IS IT IN LINE INPUT MODE
	BEQ TIOQ1		;NOPE
	TST TIEQTN(A)		;ANY CHARACTERS
	BLE TIOQ3		;NOPE
	MOV TIEQTO(A),D		;GET RELATIVE ADRS. OF CHAR
	ADD A,D			;MAKE IT ABSOLUTE
	MOVB (D),D		;GET THE CHAR
	BIC #177400,D		;CLEAR THE EXTRA BITS
	INC TIEQTO(A)		;INC THE POINTER
	DEC TIEQTN(A)		;DEC THE CHAR COUNT
	CLZ
	RTS PC
TIOQ1:	TST TIBN(A)		;ANY CHARACTERS
	BLE TIOQ3		;NOPE
	CMP #TIBT,TIBO(A)	;AT THE END OF THE BUFFER YET
	BHI TIOQ2
	MOV #TIBB,TIBO(A)	;RESET POINTER
TIOQ2:	MOV TIBO(A),D		;GET POINTER TO NEXT CHAR. OUT
	ADD A,D			;MAKE THE POINTER ABSOLUTE
	MOVB (D),D		;GET THE CHAR
	BIC #177400,D		;CLEAR THE EXTRA BITS
	DEC TIBN(A)		;UPDATE THE COUNT
	INC TIBO(A)		;UPDATE THE POINTER
	CLZ
	RTS PC

TIOQ3:	SEZ
	RTS PC

;IF CHAR IN D IS LOWER CASE, CONVERT TO UPPER
TICVLU:	CMP	D,#'_
	BLE	TICVL1		;BR IF UPPER CASE
	CMP	D,#177
	BGE	TICVL1		;DON'T CONVERT RUBOUT
	SUB	#40,D
TICVL1:	RTS PC


;QUOTE NEXT CHAR
TICQ:	BIT	#TIQF,TTYST1(A)
	BNE	TICQ1		;BR IF ^Q WAS PREVIOUS CHAR
	BIS	#TIQF,TTYST1(A)
	RTS PC
TICQ1:	BIC	#TIQF,TTYST1(A)
	RTS PC

;RESET TTY
TTYRT:	JSR	PC,TYORT	;RESET THE OUTPUT BUFFER
	JSR	PC,TYIRT	;RESET THE INPUT QUE
	JSR PC,TYBRT		;RESET THE INPUT BUFFER
	RTS PC
;RESET DEVCE
TTYRT1:	JSR PC,TYORT	;RESET THE OUTPUT BUFFER
	JSR PC,TYIRT1	;RESET THE INPUT QUE
	JSR PC,TYBRT	;RESET THE INPUT BUFFER
	RTS PC


;RESET TYPEOUT PNTRS
TYORT:	SAVE <A,F>
	BIT #MXEEF,TTYTBL(E)	;IS IT A MULTIPLEXEE
	BEQ TYORT1		;NOPE
	MOV TOQN(A),F		;GET THE NUMBER OF CHAR. IN THIS OUTPUT BUFFER
	MOVB TTYTBL(E),A	;GET THE MULTIPLEXOR TTY NO.
	MOV TTYITM(A),A		;GET THE MULTIPLEXOR ITEM INDEX
	JSR PC,ITM0PL		;LOAD THE MULTIPLEXOR TTY ITEM
	SUB F,TOQN(A)		;SUB THE NUMBER OF CHAR IN MXEE FROM MXOR
	JSR PC,ITM0PO		;RESTORE THE MULTIPLEXEE'S TTY ITEM
	MOV ITM0A,A		;RELOAD THE ITEM INDEX INTO A
TYORT1:	REST F
	CLR	TOQN(A)		;CLR CHAR COUNT
	MOV #TOQM,TOQI(A)	;RESET CHAR IN POINTER
	MOV #TOQM,TOQO(A)	;RESET CHAR OUT POINTER
	CLR	TOPC(A)		;CLR SAVED PC
	CLR	TOIPC(A)	;CLR SAVED PC
	BIC #TORST,TTYST1(A)	;CLEAR THE OUTPUT RESET BIT
	REST A
	RTS PC

;*** TYIRT RUNS AT USER LEVEL ALSO ***
;RESET INPUT PNTRS
TYIRT:	BIC	#TIEDM!TIQF!TIRBM,TTYST1(A)	;CLR MISC FLAGS
TYIRT1:	BIC	#TIRST,TTYST1(A)	;RESET FLAG
	BIT #TILIPM,TTYST1(A)	;ARE WE IN LINE INPUT MODE
	BNE TYIRT2		;YES
	CLR TIEQTN(A)		;RESET THE CHAR OUTPUT COUNT
	MOV #TIQM,TIEQTO(A)	;RESET THE CHAR OUT POINTER
TYIRT2:	CLR	TIQTON(A)		;CLR ECHOING COUNT
	CLR	TIQN(A)		;CLR CHAR COUNT
	MOV #TIQM,TIQI(A)	;RESET THE CHAR IN POINTER
	MOV #TIQM,TIQO(A)	;RESET THE CHAR OUT POINTER
	MOV #TIQM,TIQTO(A)	;RESET THE ECHOING CHAR POINTER
	MOV TIEQN(A),TITQN(A)	;THE NO. OF CHAR IN EDIT QUE IS TOTAL NO. OF CHAR
	CLR	TIBC(A)		;CLR BRACKET COUNT
	BIC #TTHANG,TTYST2(A)	;CLEAR THE HANG BIT
	RTS PC

;RESET EDIT PNTRS
TYERT:	BIC #TERST,TTYST1(A)	;CLEAR THE RESET BIT
	CLR	TIEQN(A)	;CLR CHAR COUNT
	MOV #TOQM,TIEQO(A)	;RESET CHAR OUT POINTER
	MOV TIQN(A),TITQN(A)	;NO. OF CHAR IN INPUT QUE IS TOTAL NO. OF CHAR
	RTS PC

TYBRT:	CLR TIBN(A)		;CLR CHAR COUNT
	MOV #TIBB,TIBO(A)	;RESET CHAR IN POINTER
	MOV #TIBB,TIBI(A)	;RESET CHAR OUT POINTER
	RTS PC


;*** USER AND INTERRUPT LEVEL ***

;IF NOT TRANSMITTING, CAUSE OUTPUT INTERRUPT
TOCINT:	SAVE E
	MOV TTLTTY(A),E	;GET THE LOGICAL TTY NO
	BIT	#MXEEF,TTYTBL(E)
	BNE	TOCIN3
.IFNZ NTVS
	BIT #TVF,TTYTBL(E)	;IS IT A TV
	BNE 	TOCIN0		;YES
.ENDC
	BIT #DHF,TTYTBL(E)
	BEQ	TOCIN1		;BR IF NOT A DH11 TTY
	SUB #NFDHTY,E		;GET DH LINE INDEX
	BIS DHBIT(E),DH0PBR	;SET WANT TO TRANSMIT BIT
	BR TOCIN2
TOCIN0:	BIS	#100000,@TOTSR(A)	;SET TRANS INT BIT
	BR	TOCIN2
TOCIN1:	BIC	#100,@TOTSR(A)	;CLEAR AND SET INTERRUPT ENABLE
	BIS	#100,@TOTSR(A)
TOCIN2:	REST E
	RTS PC

TOCIN3:	SAVE A			;SAVE THE TTY NO. AND ADDRESS
	MOVB TTYTBL(E),E	;GET MULTIPLEXOR NO. OF THIS MULTIPLEXEE
	MOV TTYITM(E),A		;GET MULTIPLEXORS ITEM INDEX
	JSR PC,ITM0PL		;LOAD MULTIPLEXORS TTY ITEM
	JSR PC,TOCINT		;CAUSE THE MULTIPLEXOR TO INTERUPT
				;(THAT'S WHAT WE WANTED IN THE FIRST PLACE)
	JSR PC,ITM0PO		;RELOAD THE MULTIPLEXEE'S TTY ITEM
	REST <A,E>		;RESTORE THE TTY NO. AND ADDRESS
	RTS PC



.STITL TYPE OUT--INTERRUPT LEVEL

;BREAK VECTORS POINT TO THESE TRANSMIT INTERRUPT ROUTINES

.IFNZ NTY	;CONSOLE TTY
TPBRK:	SAVE <E,D>
	MOV	#NFTY,E
	MOV TPS,D
	JMP	GENTBK
.ENDC

DC0TK:	SAVE <E,D>
	MOV #NFDCTY,E
	MOV DC0TS,D
	JMP	GENTBK

.IFNZ NDH
DH0TK:	JSR F,ACSAV
	MOV #DH0SCR,B
	;	BIT #42000,(B)		;ANYTHING BAD IN THE STATUS REGISTER?
	;	BEQ .+6		NOPE
	;	JSR PC,DEVER	PRINT AN ERROR MESSAGE
	;	INCB 1(B)	RESET NXM
	BIC #100000,(B)		;RESET DONE
	ADD #12,B		;GET BAR ADDRESS
	CLR F			;F CONTAINS THE DH11 LINE NO.*2
	MOV DH0PBR,C		;GET THE PEUDO BAR
	BIC (B),C		;IF LINES ARE TRANSMITTING FORGET THEM
	BEQ DHTK9		;NOBODY HOME
	BIC C,DH0PBR		;THESE LINES WILL GET SERVICE
	MOV #-1,A
	JSR PC,ITM2PL		;BOGUS PUSH
	MOV #1,A		;A CONTAINS 1_LINE NO.
DHTK2:	BIT A,C			;THAT LINE WANT SERVICE?
	BEQ DHTK3		;NOPE
	BIC A,DH0BRC		;CLEAR BREAK
	MOV F,E			;COPY LINE NO.*2
	ADD #NFDHTY,E		;TURN IT INTO A TTY NO.
	SAVE <C,A>			;TRANSMIT ROUTINES CRUNCH A
	MOV TTYITM(E),A		;GET THE TTY
	BLE DHTK4		;SUPIOUS INTERRUPT
	JSR PC,ITM2LD		;LOAD THAT TTY
	BIT #TTBK,TTYST2(A)	;SHOULD BE TRANSMIT BREAK?
	BNE DHTKBR		;TRANSMIT BREAK
	JSR PC,TYXMT		;SEND ANYTHING YOU GOT
DHTK4:	REST <A,C>
DHTK3:	TST (F)+		;NEXT LINE
	ASL A			;NEXT BAR BIT
	BNE DHTK2		;OUT OF LINES?
	JSR PC,ITM2PO		;POP THE TTY
DHTK9:	JSR F,ACRES
	CHECKP
	RTT
DHTKBR:	BIC #17,DH0SCR		;CLEAR OUT LINE NUMBER
	ASR F			;GET LINE NUMBER
	BIS F,DH0SCR		;SET IT IN
	ASL F			;BACK TO NUM*2
	BIC #60,DH0SCR		;CLEAR MEMORY EXTENSION FOR THIS LINE
	CLR DH0CAR		;START A ZERO (SO NO NXM)
	MOV TTBRKL(A),D		;GET THE LENGTH OF THE BREAK
	NEG D			;INTO TWO'S COMPLEMENT
	MOV D,DH0BCR		;BYTE COUNT
	CLR TTBRKL(A)		;NO MORE BREAK COUNT
	BIC #TTBK,TTYST2(A)	;CLEAR THE BREAK BIT
	BIS (P),DH0BRC		;SET BREAK CONDITION
	BIS (P),DH0PBR		;IN PSEUDO BAR ALSO
	BIS (P),(B)		;SET IN BUFFER ACTIVE CONDITION
	BR DHTK4
.ENDC

;GENERAL TRANSMIT BREAK
GENTBK:	JSR	F,ACSAV
	BIT	#%RDY,D
	BEQ	GENTB2		;BR IF NOT RDY, SPURIOUS INTERRUPT
GENTB1:	MOV TTYITM(E),A		;GET THE TTY ITEM
	BLE GENTB2		;NO ITEM SPURIOUS INTERUPT
	JSR PC,ITM2PL		;LOAD IT UP
	JSR PC,TYXMT		;TRANSMIT CHARACTERS
	JSR PC,ITM2PO		;POP THE TTY ITEM
GENTB2:	JSR	F,ACRES
	REST <D,E>
	CHECKP
	RTT

;GET NEXT MULTIPLEXOR OUTPUT CHARACTER
;FROM MULTIPLEXEE'S OUTPUT QUE INTO D
;CHAR IN MULTIPLEXOR'S OUTPUT QUE TELL WHICH ORDER TO SEND THEM
;SKIP ONE WORD IF SUCESSFULL
MXGOC:	TST	TOQN(A)		;ANY MULTIPLEXEE'S IN THE QUE (ANY CHAR TO SEND)
	BLE	MXGOC4		;BR IF NO CHARS TO SEND
	CMP TOQO(A),#TOQM+4	;ONLY 4 BYTE OUTPUT QUE?
	BLO	1$		;BR IF OUTPUT PNTR NOT PAST END OF QUEUE
	MOV #TOQM,TOQO(A)	;RESET POINTER
1$:	SAVE <E,A>		;SAVE THE TTY NO. AND ADDRESS OF THE MULTIPLEXOR'S TTY
	MOV TOQO(A),E		;GET POINTER TO CHAR IN MULTIPLEXOR OUTPUT QUE
	ADD A,E			;MAKE THE POINTER ABSOLUTE
	MOVB (E),E		;THE CHAR IS THE MULTIPLEXEE'S TTY NO.
	MOV TTYITM(E),A		;GET THE MULTIPLEXEE'S TTY ITEM INDEX
	BLE MXGOC3		;NO TTY, JUST SEND NULL FOR THIS BABY
	JSR PC,ITM0PL		;LOAD THE MULTIPLEXEE'S TTY ITEM
	JSR	PC,TOSOP	;START OUTPUT
	BR	2$	;OUTPUT Q FULL
2$:	JSR PC,TYGOC		;GET A CHAR FROM THE MULTIPLEXEE'S OUTPUT QUE
	BR	MXGOC7		;NO CHARS
	REST <A,E>		;RESTORE TTY NO. AND ITEM INDEX OF MULTIPLEXOR'S TTY
	JSR PC,ITM0PO		;RELOAD THE MULTIPLEXOR'S TTY ITEM
	DEC	TOQN(A)		;DECREMENT MPXRS CHAR COUNT
MXGOC6:	INC	TOQO(A)		;INC MULTIPLEXOR'S POINTER
MXGOC5:	ADD	#2,@P		;SKIP RETURN
MXGOC2:	RTS PC

;MULTIPLEXOR HAS CHARS TO SEND, BUT CURRENT MULTIPLEXEE DOESN'T
MXGOC7:	JSR PC,ITM0PO		;POP THE MULTIPLEXEE'S ITEM
MXGOC3:	MOVB	OMXNUL(E),D	;RETURN NULL CHAR FOR MULTIPLEXEE
	REST <A,E>		;RESTORE MULTIPLEXOR'S TTY NO. AND ITEM INDEX
	BR MXGOC6		;RETURN IN STYLE


;NO CHARACTERS FOR MULTIPLEXOR
MXGOC4:	CMP TOQO(A),#TOQM
	BEQ MXGOC2
	MOV #TOQM,TOQO(A)
	MOVB	#21,D		;SEND MULTIPLEXOR RESET CHARACTER
	BR	MXGOC5

;GET NEXT TTY OUTPUT CHARACTER
;SKIP ONE WD IF SUCCESSFUL
TYGOC:	BIT #TTYF,TTYST1(A)
	BNE TYGOC1		;BR IF IN IMAGE MODE (DON'T PAD)
	TSTB TOPAD(A)
	BGT TYGOC4		;BR IF SOME PADDING LEFT
TYGOC1:	JSR PC,TOOQ		;GET CHAR FROM OUTPUT BUFFER
	BR TYGOC3		;BR IF BUFFER EMPTY
	BIT #TIMAGO,TTYST1(A)
	BNE TYGOC2		;BR IF IN IMAGE MODE
	CMP D,#15
	BNE TYGOC2
	MOVB TYPAD(E),TOPAD(A)	;IF CR, SET UP PADDING
TYGOC2:	ADD #2,@P		;SKIP RETURN
TYGOC3:	RTS PC
;SEND PADDING CHAR INSTEAD OF NEXT CHAR FROM QUEUE
TYGOC4:	CLR	D
	DECB	TOPAD(A)	;DEC # OF PADS
	BR	TYGOC2


;REMOVE CHAR FROM CIRCULAR OUTPUT QUEUE AND RETURN IT IN D
;SKIP ONE WORD IF SUCCESSFUL
TOOQ:	TST	TOQN(A)
	BLE	TOOQ2		;BR IF NOTHING IN Q
	CMP TOQO(A),#TOQLM
	BLO TOOQ1
	MOV #TOQM,TOQO(A)
TOOQ1:	MOV TOQO(A),D	;GET THE POINTER
	ADD A,D		;MAKE IT ABSOLUTE
	MOVB (D),D	;GET CHAR
	INC	TOQO(A)		;INC PNTR
	DEC	TOQN(A)		;DEC CHARACTER COUNT
	ADD	#2,@P		;SKIP RETURN
TOOQ2:	RTS	PC

;TTY TRANSMIT INTERRUPT
;FIRST SEND CHARS IN OUTPUT Q
;THEN PROCESS CHARS IN INPUT Q
;CAN CLOBBER A&C
TYXMT:	BIC	#TOTRAN,TTYST1(A)	;CLEAR XMT INT PENDING BIT
	BIT #TORST,TTYST1(A)	;RESET THE OUTPUT
	BEQ 1$			;NOPE
	JSR PC,TYORT		;RESET THE BUFFER
1$:	JSR	PC,TOSOP	;START OUTPUT
	BR	TYXMT3		;OUTPUT BUFFER FILLED AGAIN
TYXMT1:	JSR	PC,TOPIC	;PROCESS CHARS FROM INPUT BUFFER
TYXMT3:				;ACTUALLY SEND CHARACTERS!!!
	BIT #DHF,TTYTBL(E)
	BNE	TYXMT5		;BR IF DH11 TTY
.IFNZ NTVS
	BIT #TVF,TTYTBL(E)
	BNE	TYXMT7		;BR IF TV TTY
.ENDC
	SAVE C
	BIT #MXORF,TTYTBL(E)	;IS IT A MULTIPLEXOR?
	BEQ TYXTTY		;NOPE
	MOV #MXGOC,C		;JMP TO THE MULTIPLEXOR ROUTINES
	BR TYXMT6		;GO JUMP
TYXTTY:	MOV #TYGOC,C		;JMP TO THE TELETYPES ROUTINES
TYXMT6:	JSR PC,(C)		;GO JUMP TO THE APPROPRIATE ROUTINES
	BR	TYXMT4		;NONE
	MOV TOTSR(A),B		;POINTER TO TRANSMIT STATUS REG.
	MOV	D,2(B)		;PUT CHAR IN DEVICES OUTPUT BUFFER
	BIS	#TOTRAN,TTYST1(A)	;SET XMT INT PENDING FLAG
TYXMT4:	REST C
	RTS PC

;START OUTPUT
;SKIP RETURN IF OUTPUT BUFFER NOT FULL
TOSOP:	SAVE PS
	SPL 7
	CMP TOQN(A),#TOQSZ
	BGE	TOSOP2		;BR IF Q FULL
	TST	TOPC(A)		;DID WE EXIT FROM MIDDLE OF PROCESSING CHAR TO OUTPUT Q
	BEQ	TOSOP1		;BR IF NO
	SAVE <C,D>		;DONT CLOBBER THESE
	MOV	TOSVC(A),C	;RESTORE MISC AC'S
	MOV	TOSVD(A),D
	SAVE	TOPC(A)		;LOCATION TO JSR TO
	MOV (P),TOOPC(A)	;SAVE TO FIND A BUG
	CLR	TOPC(A)
	JSR	PC,@(P)+	;CALL AS COROUTINE
	240
	REST <D,C>		;GET THEM BACK
	TST TOPC(A)
	BEQ TOSOP2
TOSOP1:	ADD	#2,2(P)		;SKIP RETURN
TOSOP2:	REST PS
	RTS	PC

.IFNZ NTVS
TYXMT7:	JSR PC,TVSND		;TRANSMIT CHARS TO TV TTY
	RTS PC
.ENDC
.IFG NDH
TYXMT5:	JSR	PC,DHSND	;TRANSMIT CHARS TO DH TTY
	RTS	PC

;TRANSMIT CHARS TO DH11 TTY
DHSND:	JSR	F,ACSAV
	CLR -(P)		;CONTAINS NEGATIVE OF THE CHAR COUNT
	MOV E,F
	SUB #NFDHTY,F
	MOV	DHBUF(F),B	;WHERE CHARS ACTUALLY SENT FROM
	BIC #17,DH0SCR
	ASR F
	BIS F,DH0SCR		;SET LINE NUMBER
	ASL F
	MOV B,DH0CAR		;SET THE ADDRESS
	MOV	#DHMAX,C	;MAX NUM OF CHARS TO SEND
	SAVE A			;A CLOBBERED BELOW AND BY GET CHAR ROUTINES
DHSND1:	BIT #MXORF,TTYTBL(E)	;IS IT A MULTIPLEXOR
	BEQ DHSND4		;NO
	SAVE #MXGOC		;MAKE SURE WE GO TO THE MULTIPLEXOR ROUTINES
	BR DHSND5
DHSND4:	SAVE #TYGOC		;MAKE SURE WE GO TO THE TELETYPE ROUTINES
DHSND5:	JSR PC,@(P)+		;GO TO THE APPROPRIATE PLACE
	BR	DHSND6		;RETURN HERE IF NO CHARS
	MOVB	D,(B)+		;PUT CHAR IN BUFFER
	DEC 2(P)		;NEGATIVE CHAR COUNT
	SOB C,DHSND1		;MAX NUM OF CHARS TO SEND
	REST A			;RESTORE ADDRESS OF TTY ITEM
DHSND2:	TST (P)
	BGE	DHSND7		;BR IF NOTHING TO SEND
	MOV (P),DH0BCR		;SET BYTE COUNT
	BIS DHBIT(F),DH0BAR	;START LINE UP
	BIS DHBIT(F),DH0PBR	;ALSO SET PSEUDO BAR
	BIS	#TOTRAN,TTYST1(A)	;SET XMT INT PENDING FLAG
DHSND3:	TST (P)+		;POP OF THE CHAR COUNT
	JSR	F,ACRES
	RTS	PC

DHSND6:	REST A
	TST TTBRKL(A)		;CAUSE BREAK ON THIS LINE?
	BEQ DHSND2		;NO, FORGET IT AND GO AWAY
	MOV #ZERO,DH0CAR	;POINT TO TWO ZERO BYTES
	MOV #-2,(P)		;MAKE BELIEVE THAT THERE ARE TWO CHARACTERS TO SEND
	BIS #TTBK,TTYST2(A)	;AND SET BIT FOR BREAK WHEN WE ARE FINISHED	
	BR DHSND2

DHSND7:	BIC #TOTRAN,TTYST1(A)
	BR DHSND3

.ENDC

;PROCESS CHARS IN INPUT BUFFER
TOPIC1:	INC	TIQTO(A)	;INC CHAR PNTR
	DEC	TIQTON(A)	;DEC CHAR COUNT
	JSR	PC,TOIEC	;ECHO CHAR
TOPIC:	TST	TOPC(A)
	BNE	TOICM4		;IF OUTPUT BUFFER FULL, GO AWAY
	TST	TIQTON(A)
	BLE	TOICM4		;NO CHARS LEFT TO PROCESS
	MOV TIQTO(A),D		;GET POINTER TO NEXT CHAR TO BE ECHOED
	ADD A,D			;MAKE POINTER ABSOLUTE
	MOVB (D),D		;GET THE CHAR
	BR TOPIC1		;ECHO IT

;^M POSSIBLE END OF LINE
TOICGZ:	CLR TIBC(A)
TOICM:	BIT	#TILIPM,TTYST1(A)
	BEQ	TOICM3		;BR IF NOT IN LINE INPUT MODE
	TST	TIBC(A)
	BGT	TOICM3		;BR IF INSIDE BRACKETS
	INC	TIQTO(A)	;INCREMENT CHAR ECHOING POINTER
	DEC	TIQTON(A)	;DEC CHAR ECHOING COUNT
	JSR	PC,TOIEC	;ECHO CHAR
	JSR PC,TYINQ		;PUT CR. INTO QUE (ECHOING IT)
	SAVE <A,B,C,F>
	MOV A,F			;SO THAT THE POINTER WILL BE ABSOLUTE
	ADD TIQI(A),F		;ADD THE RELATVE POINTER TO ABSOLUTE ADDRESS
	MOV #TOQM,B		;POINTER TO THE TOP OF QUE
	ADD A,B			;MAKE POINTER ABSOLUTE
	MOV TIQN(A),C		;GET NO. OF CHAR TO MOVE
	MOV C,TIEQN(A)		;THE NO. OF CHAR IN INPUT QUE IS THE NO. OF CHAR IN EDIT QUE
1$:	MOVB -(F),-(B)		;MOV THE ENTIRE INPUT QUE TO EDIT QUE
	SOB C,1$
	SUB A,B			;MAKE THE POINTER RELATIVE
	MOV B,TIEQO(A)		;POINTER TO WHERE LAST CHAR WENT IN IS POINTER TO WHERE
				;NEXT CHAR COMES OUT OF EDIT QUE
	REST <F,C,B,A>
	JSR	PC,TYIRT	;RESET INPUT BUFFER
	MOV TIEQN(A),TIEQTN(A)	;INITIALIZE POINTERS FOR LOGO LINE INPUT MODE
	MOV TIEQO(A),TIEQTO(A)	;TYI USES THESE POINTERS TO GET NEXT CHAR IN COMMAND LINE
	MOV #TICP5,(P)		;THIS CROCK SO THAT WE STOP PROCESSING CHARS
	BIC #TTHANG,TTYST2(A)	;CLEAR THE HANG BIT
	JSR PC,TOCINT		;CAUSE AN OUTPUT INTERUPT FOR THE THINGS WE PUT IN AT THE TOP
	SEZ			;RETURN TO TICP5, WHICH WILL ALLOW US TO RETURN PROPERLY
TOICM4:	RTS	PC
TOICM3:	CLZ			;NOT REALLY SPECIAL
	RTS PC

;^Y EDIT PREVIOUS LINE
TOICY:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^Y?
	JSR	PC,TOIECS	;IF NO, JMP HERE, ECHO ^Y
	MOV	#15,D
	JSR	PC,TOIECS	;ECHO CR
	MOV	#'_,D
	JSR	PC,TOIEC	;ECHO _
	BIS	#TIEDM,TTYST1(A)	;PUT TTY IN EDIT MODE
	SEZ
	RTS	PC

;^X CLARIFY INPUT
;TYPE CR, REST OF EDIT BUFFER, CR, INPUT BUFFER
TOICX:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^X?
	MOV	#15,D		;NO
	BIT	#TIEDM,TTYST1(A)
	BEQ	TOICX2		;BR IF NOT EDITING
	TST	TIEQN(A)
	BLE	TOICX2		;BR IF NOTHING IN EDIT BUFFER
	MOV	TIEQO(A),B
	ADD A,B		;MAKE POINTER TO CHAR ABSOLUTE
TOICX1:	JSR	PC,TOIECS	;ECHO CHAR IN D (SKIPS LEVEL IF Q FULL)
	MOVB	(B)+,D		;GET NEXT EDIT CHAR
	CMP B,#TOQM
	BLO	TOICX1		;BR IF STILL CHARS TO PRINT
	BHI	TOICX5		;BR IF JUST PRINTED LAST CHAR
	CMP	D,#15
	BNE	TOICX1		;LAST CHAR NOT CR, PRINT IT, THEN PRINT CR.
TOICX5:	MOV	#15,D
TOICX2:	TST	TIQN(A)		;ANY CHAR IN INPUT QUE?
	BLE	TOICX4		;NOPE
	MOV #TIQM,B
	ADD A,B			;MAKE B POINT TO THE ABSOLUTE STARTING ADR OF QUE
TOICX3:	JSR	PC,TOIECS	;DID WE GET STOPPED BEFORE WHILE TRYING TO ECHO?
	MOVB	(B)+,D		;GET THE A CHAR FROM THE BOTTOM OF INPUT QUE
	CMP	B,TIQTO(A)	;ARE WE TO THE END OF THE CHARS
	BLOS	TOICX3		;BR IF MORE INPUT CHARS TO PRINT
TOICX4:	SEZ
	RTS PC


;ECHO CHAR FROM SPECIAL INPUT CHAR SUBR
TOIECS:	SAVE	A
	JSR	PC,TOIEC	;ECHO
TOIES1:	REST	A
	TST	TOPC(A)		;DID WE GET STOPPED TRYING TO ECHO
	BEQ	TOIECR		;NOPE WE SUCCEEDED
	MOV	(P)+,TOIPC(A)	;WHERE TO RETURN TO
	MOV	A,TOISVA(A)	;SAVE AC A
TOIECR:	RTS	PC

;ECHO RUBBED OUT CHAR
TOIRCS:	SAVE	A
	JSR	PC,TOPRB	;RUB OUT CHAR AND ECHO
	BR	TOIES1		;MAKE SURE WE DIDN'T GET STOPPED TRYING TO ECHO

;ENTER SUBR THAT TOIECS EXITED
TOIENT:	TST	TOIPC(A)	;DID WE GET STOPPED LAST TIME 
	BEQ	TOIEN1		;NOPE
	MOV	TOIPC(A),@P	;RETURN HERE INSTEAD OF CALLING ROUTINE
	CLR	TOIPC(A)	;SAY WE DIDN'T GET STOPPED THIS TIME
	MOV	TOISVA(A),A	;RESTORE RANDOM REGISTER
TOIEN1:	RTS	PC

;^C COPIES NEXT CHAR FROM EDIT QUEUE TO TYI QUEUE
TOICC:	BIT	#TIEDM,TTYST1(A)	;ARE WE IN EDIT MODE
	BEQ	TOICC1		;BR IF NOT IN EDIT MODE
	JSR PC,TOICN4		;GET A CHAR FROM EDIT QUE INTO INPUT QUE
TOICC1:	SEZ
	RTS PC


;^N COPIES NEXT WORD FROM EDIT TO TYI Q

TOICN:	BIT #TIEDM,TTYST1(A)	;ARE WE IN EDIT MODE
	BEQ TOICN3		;NOPE
TOICN5:	JSR PC,TOICN4		;GET A CHAR FROM EDIT QUE INTO INPUT QUE
	BEQ TOICN3		;FAILED
	JSR PC,TOISWS		;IS IT A SEPARATOR CHAR
	BEQ TOICN5		;NO, GO BACK AND GET NEXT CHAR
TOICN3:	SEZ			;REACHED SEPARATOR, RETURN SUCESSFUL
	RTS PC

TOICN4:	JSR PC,TOGED		;GET A CHAR FROM INPUT QUE
	BEQ TOICN3		;FAILED THERE SO FAIL HERE
	MOV TIQI(A),B		;GET POINTER TO NEXT CHAR IN INPUT QUE
	ADD A,B			;MAKE POINTER ABSOLUTE
	MOVB D,(B)		;PUT THE CHAR FROM EDIT QUE THERE
	JSR PC,TIBCK		;CHECK IF ITS A BRACKET
	INC TIQN(A)		;INC CHAR COUNT OF INPUT QUE
	INC TIQI(A)		;INC CHAR POINTER
	INC TIQTON(A)		;INC NO OF CHAR THAT HAVE TO BE ECHOED
	RTS PC

TIBCK:	CMP D,#'[		;IS IT A LEFT BRACKET
	BNE 1$			;NOPE
	INC TIBC(A)		;INC UNMATCHED BRACKET COUNT
1$:	CMP D,#']		;IS IT A RIGHT BRAKET
	BNE 2$			;NOPE
	DEC TIBC(A)		;DECREMENT UNMATCHED BRACKET COUNT
2$:	RTS PC


;^R COPY REST OF EDIT BUFFER TO INPUT BUFFER
TOICR:	BIT	#TIEDM,TTYST1(A)
	BEQ	TOICC1	;BR IF NOT IN EDIT MODE
TOICR1:	JSR PC,TOICN4
	BEQ TOICC1
	BR TOICR1



;SKIP IF CHAR IN D IS WD SEPERATOR
TOISWS:	TSTB	D
	BMI	TOISW1	;BR IF QUOTED (HIGH BIT ON)
	BITB	#WSF,DTBL(D)
TOISW1:	RTS PC

;^D DELETES NEXT CHAR FROM EDIT QUEUE
TOICD:	BIT	#TIEDM,TTYST1(A)
	BEQ	TOISW1	;BR IF NOT IN EDIT MODE
	JSR	PC,TOGED	;GET NXT EDIT CHAR
	BEQ TOISW1
.IFNZ SMARTRUBOUT
	BIT #TVF,TTYTBL(E)	;TV?
	BNE TOICD1	;IF SO, DON'T ECHO AS RUBOUT
.ENDC
	JSR PC,TOPRB	;ECHO RUBBED OUT CHAR
TOICD1:	SEZ
	RTS PC


;REPLACE ^B WITH %
TICB:	MOV #'%,D
	RTS PC


;^S SKIPS NXT WD IN EDIT QUEUE
TOICS:	BIT #TIEDM,TTYST1(A)
	BEQ TOICD1
TOICS1:	JSR PC,TOGED
	BEQ TOICD1
.IFNZ SMARTRUBOUT
	BIT #TVF,TTYTBL(E)	;TV?
	BNE 1$		;IF SO, DON'T ECHO AS RUBOUT
.ENDC
	JSR PC,TOPRB
1$:	JSR PC,TOISWS
	BNE TOICD1
	BR TOICS1


;^Q HAD EFFECT ON INPUT, DELETE FROM Q & ECHO
TOICQ:	JSR PC,TICQ
	JSR PC,TOIECS	;ECHO ^Q
	SEZ
	RTS PC
	
;RUBOUT RUBS OUT PREVIOUSLY PROCESSED CHAR
TOIRB:	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW3	;FAIL
	JSR	PC,TOPRB	;PRINT RUBBED OUT CHAR
	JSR	PC,TOIBCK	;CHECK FOR RUBBED OUT [ OR ]
	JSR PC,TOIOWP	;OVERWRITE RUBBED OUT CHAR
	SEZ
	RTS PC

;^W RUBS OUT PREVIOUS WD
TOICW:	JSR	PC,TOIENT	;IN MIDDLE OF PROCESSING ^W?
	JSR	PC,TOIQP	;NO, GET PREVIOUS CHAR
	BEQ	TOICW3	;FAIL
TOICW1:	JSR	PC,TOIBCK	;CHECK FOR BRACKET
	JSR	PC,TOIRCS	;PRINT CHAR
	JSR	PC,TOIOWP	;BLT OVER CHAR
	JSR	PC,TOIQP	;GET PREVIOUS CHAR
	BEQ	TOICW3
	JSR	PC,TOISWS	;SKIP IF WD SEPERATOR
	BEQ	TOICW1
TOICW3:	SEZ
	RTS PC

;[ INCS BRACKET COUNT
TOIOB:	INC TIBC(A)
	BGE	TOICB2
	BPT	;-BRACKETS
	BR TOICB2

;] DECS BRACKET COUNT IF THERE ARE ANY
TOICB:	TST	TIBC(A)
	BLE	TOICW3	;NO BRACKETS, IGNORE
	DEC	TIBC(A)	;DEC COUNT
TOICB2:	CLZ
	RTS PC


;GET PREVIOUS CHARACTER IN INPUT BUFFER AND SKIP
TOIQP:	SAVE	A
	MOV	TIQTO(A),A	;GET POINTER TO CURRENT CHARACTER
	DEC A
	CMP A,#TIQM
	BLO	TOIQP1	;BR IF NO PREVIOUS CHARACTER
	ADD (P),A	;MAKE THE POINTER ABSOLUTE
	MOVB	(A),D
	REST	A
	CLZ
	RTS PC
TOIQP1:
	REST	A
	SEZ
	RTS	PC

;CHECK FOR RUBBED OUT [ & ]
TOIBCK:	CMP	D,#'[
	BNE	1$
	DEC	TIBC(A)	;IF CHAR WAS [, DECREMENT BRACKET COUNT
1$:	CMP	D,#']
	BNE	2$
	INC	TIBC(A)	;IF RUBBED OUT A ], INC BRACKET COUNT
2$:	RTS	PC

;OVERWRITE PREVIOUS CHARACTER
TOIOWP:	DEC TIQTO(A)
	DEC TIQN(A)
	DEC TITQN(A)
	DEC TIQI(A)
	RTS PC

;GET NEXT CHAR FROM EDIT BUFFER INTO D AND SKIP IF SUCCESSFUL
TOGED:	TST	TIEQN(A)
	BLE	TOGED2-2	;BR IF NOTHING LEFT IN EDIT BUFFER
	DEC	TIEQN(A)	;DEC CHAR COUNT
	MOV TIEQO(A),D		;POINTER TO WHERE IT COMES OUT
	ADD A,D
	MOVB (D),D		;GET THE NEXT CHAR
	INC	TIEQO(A)
	CMP	D,#'[
	BNE	2$
	INC	TIEBC(A)	;CHAR WAS [
2$:	CMP	D,#']
	BNE	1$
	DEC	TIEBC(A)	;CHAR WAS ]
1$:	CMP	D,#15
	BNE	TOGED2	;NOT A CR
	TST	TIEBC(A)	;CR, TEST FOR END OF EDIT LINE
	BGT	TOGED2
	CLR	TIEQN(A)	;EOL, CLR THIS TO BE XTRA CAREFUL
	SEZ
TOGED2:	RTS	PC


;PRINT RUBBED OUT CHAR IN D ON E'S TTY
TOPRB:	BIT	#TIECM,TTYST1(A)
	BEQ	TOGED2	;RETURN IF IN NO ECHO MODE

.IFNZ SMARTRUBOUTS
	BIT #TVF,TTYTBL(E)	;TV?
	BEQ TOPRB2	;NO, BACKSLASH/ECHO RUBOUT
	BIT #200,D	;YES, SMART RUBOUT. CTRL CHAR?
	BNE TOPRB1	;YES, DISPATCH
	JMP TRBOUT	;NO, NORMAL CHAR RUBOUT
TOPRB1:	JMP @DTBLRO(D)
.ENDC

TOPRB2:	BIT	#TIRBM,TTYST1(A)
	BNE	TOIEC2	;ALREADY IN RUBOUT MODE
	BIS	#TIRBM,TTYST1(A)
	BR	TOIEC1	;TYPE OPENING \

;ECHO CHARACTER IN D ON E'S TTY
TOIEC:	BIT	#TIECM,TTYST1(A)
	BEQ	TOTYC1	;RETURN IF IN NO ECHO MODE
	BIT	#TIRBM,TTYST1(A)
	BEQ	TOIEC2	;ALREADY NOT IN RUBOUT MODE
	BIC	#TIRBM,TTYST1(A)
	;PRINT CLOSING \
;PRINT \:
TOIEC1:	MOV	D,C	;SAVE CHAR
	MOV	#'\,D
	JSR	PC,TOCINQ	;PUT \ INTO OUTPUT Q
	JSR	PC,TOEXT	;FILLED UP Q
	MOV	C,D	;RESTORE CHAR
TOIEC2:		;PRINT CHAR IN D

;FALLS THROUGH!!!
;FALLS IN!!!

;PROCESS CHAR IN D INTO TTY IN E'S OUTPUT BUFFER
;IF BUFFER FILLS SAVE ACS C,D,PC AND EXIT
TOTYO:	BIT	#TIMAGO,TTYST1(A)
	BEQ	TOTYO1	;BR IF NOT IN IMAGE MODE
TOTYOC:	JSR	PC,TOINQ	;PUT CHAR IN OUTPUT BUFFER
	JSR	PC,TOEXT
;SMARTRUBOUTS? OR JUST FLUSH ALTOGETHER?
;	BIT #TTYF,TTYTBL(E)	;IS IT A TTY?
;	BNE 1$			;YUP
;	JMP TOCLTO		;SEE IF THE LINE IS TOO LONG
1$:	RTS PC

TOTYO1:	MOVB	D,C
	BMI	TOTYOC	;BR IF CHAR HAS IMAGE MODE BIT SET
	BITB	#FOF,DTBL(C)
	BNE	TOTYO3	;BR IF SPECIAL ON OUTPUT
	CMP	D,#40
	BLT	TOTYO4	;BR IF CONTROL CHAR
	JSR	PC,TOCINQ
	JSR	PC,TOEXT
TOTYO2:	JMP	TOCLTO	;CHECK FOR LINE TOO LONG

;SPECIAL ON OUTPUT
TOTYO3:	MOVB	DTBL2(C),C
	JMP	@TOOCTB(C)
;CONTROL CHAR
TOTYO4:	MOV	#'^,D
	JSR	PC,TOCINQ	;PRINT ^
	JSR	PC,TOEXT
	MOV	C,D
	ADD	#100,D
	JSR	PC,TOCINQ	;PRINT CHAR +100
	JSR	PC,TOEXT
	MOV	C,D
	BR	TOTYO2

;OUTPUT BUFFER FULL, SAVE STATE OF WORLD AND RETURN ONE LEVEL UP
TOEXT:	MOV	C,TOSVC(A)
	MOV	D,TOSVD(A)
	MOV	(P)+,TOPC(A)
TOTYC1:	RTS	PC

TRBOUT:	MOV D,C		;SAVE D
	TST CHARNO(A)	;ARE WE AT THE BEGINNING OF A LINE?
	BEQ TROUT1	;YES, DO SPECIAL THINGS
	DEC CHARNO(A)	;NO, 1 LESS CHAR ON THIS LINE
	MOV #37,D	;BACKSPACE/ERASE
	BR TROUT5

TROUT1:	TST LINENO(A)	;TOP OF THE PAGE, TOO?
	BNE TROUT2	;NO, JUST GO TO PREVIOUS LINE
1$:	MOV #12,D	;LF UNTIL THE BOTTOM OF THE PG IS REACHED
	JSR PC,TOINQ	;OUTPUT-QUE THE LF
	JSR PC,TOEXT
	MOV LINENO(A),D	;SEE WHAT THE NEW LINE NUMBER IS
	INC D
	CMP D,TVHIGH(A)	;1 LESS THAN OVERFLOW?
	BLT 1$		;IF LESS THAN THAT, KEEP GOING
	BR TROUT3
TROUT2:	MOV #32,D	;LINESTARVE, GO TO PREVIOUS LINE
	JSR PC,TOINQ
	JSR PC,TOEXT
TROUT3:	MOV #30,D	;SPACE WITHOUT ERASE CHAR
	JSR PC,TOCINQ	;OUTPUT-QUE IT
	JSR PC,TOEXT
	MOV CHARNO(A),D	;SEE WHAT THE NEW CHARNO IS
	INC D
	CMP D,LINEL(A)	;END OF THE LINE YET?
	BLT TROUT3	;NO, KEEP GOING
	MOV #36,D	;CLEAR END OF LINE, IE LAST CHAR HERE
TROUT5:	JSR PC,TOINQ	;OUTPUT-QUE ERASURE CHAR
	JSR PC,TOEXT
TROUT4:	MOV C,D		;RESTORE C
	RTS PC

TRBOCH:	MOV #30,D	;RUBOUT BACKSP/NER WITH SP/NER
	JSR PC,TOCINQ	;OUTPUT-QUE IT
	JSR PC,TOEXT
	MOV #37,D		;RESTORE D
	RTS PC


TRBOCM:			;IT SHOULDN'T BE POSSIBLE TO RBOUT A CR IN LIPM
TRBOCA:			;THIS ISN'T RIGHT, BUT WHAT ELSE CAN BE DONE?
TRBOCL:			;SAME HERE
TRBOCI:			;SIGH, HERE TOO
TRBOCG:	RTS PC		;NOOP, NOTHING NEEDS TO BE DONE
	
TRBOCJ:	MOV #32,D	;RUBOUT LINEFEED WITH LINESTARVE
	JSR PC,TOINQ	;OUTPUT-QUE IT
	JSR PC,TOEXT
	MOV #12,D	;RESTORE D
	RTS PC

;^A PRINTS AS CR
TOOCA:	CLR	CHARNO(A)
	MOV	#15,D
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	MOV	#1,D
	RTS	PC

;^H BACKSPACE DECREMENTS CHARNO IF NOT AT BEGINNING OF LINE
TOOCH:	TST	CHARNO(A)
	BLE	TOOCH1
	JSR	PC,TOINQ
	JSR	PC,TOEXT
	DEC CHARNO(A)
TOOCH1:	RTS	PC

;CHECK IF LINE TOO LONG, IF SO PRINT CRLF
TOCLTO:	CMP	CHARNO(A),LINEL(A)
	BLT	TOOCM1	;BR IF NOT TOO LONG
;^M PRINTS AS CR LF
TOOCM:	MOV	D,C	;SAVE D
	CLR	CHARNO(A)	;CLR CHAR COUNT
	MOV	#15,D
	JSR	PC,TOINQ	;PRINT CR
	JSR	PC,TOEXT
	MOV	#12,D
	JSR	PC,TOINQ	;PRINT LINEFEED
	JSR	PC,TOEXT
	MOV	C,D
TOOCM1:	RTS	PC

;^I PRINTS SPACES TILL NEXT TAB STOP
TOOCI:	MOV D,C
	MOV #40,D
TOOCI1:	JSR	PC,TOCINQ
	JSR	PC,TOEXT
	BIT	#7,CHARNO(A)
	BNE	TOOCI1
	MOV C,D
	RTS	PC

;*** INTERRUPT AND USER LEVEL ***

;PUT CHAR IN D INTO TTY IN E'S CIRCULAR OUTPUT QUEUE
;SKIP TWO WORDS IF SUCESSFULL
TOCINQ:	INC	CHARNO(A)
TOINQ:	JSR PC,TLINE	;ADJUST THE LINENO IF NECESSARY
	CMP TOQN(A),#TOQSZ
	BGE TOINQ2
	CMP TOQI(A),#TOQLM
	BLO TOINQ1
	MOV #TOQM,TOQI(A)
TOINQ1:	SAVE	E
	MOV TOQI(A),E	;GET POINTER TO CHAR IN
	ADD A,E		;MAKE IT LESS RELATIVE
	MOVB	D,(E)	;PUT CHAR IN BUFFER
	INC	TOQI(A)
	INC	TOQN(A)	;INC # OF CHARS IN OUTPUT BUFFER
	MOV TTLTTY(A),E	;THE TTY NO.
	BIT #MXEEF,TTYTBL(E)	;IS IT MXEE?
	BEQ TOINQ4	;NO
	SAVE A
	MOVB TTYTBL(E),E	;TTY OF MXOR
	MOV TTYITM(E),A		;THE ITEM NO. OF TTY OF MXOR
	JSR PC,ITM0PL		;LOAD IT UP
	INC TOQN(A)		;SAY ANOTHER BYTE TO TRANSMIT
	JSR PC,ITM0PO		;POP TTY
	REST A			;GET BACK A
TOINQ4:	REST	E
	CMP TOQN(A),#TOQSZ
	BGE	TOINQ3	;BR IF Q FILLED NOW
	ADD	#4,@P	;SKIP RETURN TO SUCESS
TOINQ3:	RTS	PC

TOINQ2:	;SHOULD BE A BPT HERE
;	BPT	;TRIED TO PUT CHAR IN OUTPUT Q WHEN ALREADY FULL
	RTS	PC	;RETURN TO FAILURE

TIANTM:	500.	;TIME TO WAIT FOR CARRIER BEFORE HANGING UP
	.STITL INITIALIZE A TTY ROUTINES
CRTTY:	MOV #TTYLEN,A	;LENGTH OF TTY ITEM
	JSR PC,CRITEM	;CREATE THE ITEM
	BEQ CRTT1	;FAILED
	JSR PC,CLITEM	;CLEAR THE ITEM
	MOV #ITTTY,(A)	;SET IN THE TYPE
	MOV ITEM1,TTITM(A)	;SET THE INITIAL OWNER
	INC TTYREF(A)	;INCREMENT THE REFERENCE COUNTER
	MOV E,TTLTTY(A)	;THE LOGICAL TTY NO.
	MOV #60.,LINEL(A) ;THE LINE LENGTH
	MOV TTYTBL(E),C	;THE FLAGS FOR THIS TTY
	BIT #MXORF,C	;IS IT A MULTIPLEXOR
	BNE CRMXOR	;YES
	MOV CURUSR,TTYU(A)	;SAY THE CURRENT USER OWNS THIS TTY
	BIT #MXEEF,C	;IS IT A MULTIPLEXEE
	BNE CRMXOR	;YES
	JSR PC,TTYRT	;RESET THE TTY
	BIS #TILIPM!TIECM!TICVM!TICTM,TTYST1(A)	;SET INITIAL STATUS
CRTT2:	BIT #DHF,C
	BNE CRDH11	;YES
	BIT #SYF,C	;SYSTEM TTY?
	BNE CRSYS	;YES
.IFNZ NTVS
	BIT #TVF,C	;IS IT A TV
	BNE CRTV	;YES
.ENDC
	MOV #DC0TS,C	;THE ADDRESS OF THE FIRST TRANSMIT STATUS REG
	MOV #NFDCTY,D	;THE TTY NO. OF THE FIRST ORDINARY TTY
CRTT3:	CMP D,E		;IS THE TTY NO. CREATED THE CURRENT ONE
	BEQ CRTT4	;YES
	ADD #2,D	;GET THE NEXT TTY NO.
	ADD #10,C	;GET THE NEXT TRAN. STATUS REG.
	BR CRTT3
CRTT4:	MOV C,TOTSR(A)	;SET THE TRANSMIT REG. POINTER
CRTT5:	MOV B,TTYITM(E)	;SET THE TTY ITEM INTO THE SYSTEM VARIABLE
	JSR PC,ITM0PO	;POP THE TTY ITEM
	CLZ
CRTT1:	RTS PC
CRSYS:	MOV #TPS,TOTSR(A)	;TRANSMIT REGISTER
	BR CRTT5
CRDH11:	MOV #DH0SCR,TOTSR(A)
	BR CRTT5
CRMXOR:	JSR PC,TTYRT1	;RESET THE BUFFERS
	BR CRTT2
.IFNZ NTVS
CRTV:	MOV #38.,TVHIGH(A)	;FOR THE DEFAULT FONT, 38 CHAR LINES ON SCREEN
	MOV #7,TVNLSC(A)	;DEFAULT NUMBER OF LINES TO SCROLL
	BIS #.TSCRL,TTYST2(A)	;DEFAULT IS SCROLL MODE
	MOV #-1,TVBUF(A)	;NO BUFFER ALLOCATED
	MOV E,C			;THE LOGICAL TTY NUMBER
	ADD #TVSTAT,C		;GET A POINTER TO THE STATUS WORD FOR THIS TV
	MOV C,TOTSR(A)		;SO THE INTERRUPT BIT WILL BE SET
	MOV #174000,TVMSK1(A)	;INITIAL CURSOR MASK
	MOV #10.,TVSHCT(A)	;INITIAL SHIFT COUNT
	MOV #174000,TVMSK1(A)	;INITIAL CURSOR MASK
	MOV #10.,TVSHCT(A)	;INITIAL SHIFT COUNT
	MOV #-9.,TVLCNT(A)	;INITIAL LINES IN CHAR COUNT (FOR TVWC)
	MOV #96.,LINEL(A)	;LINE LENGTH OF 96 CHARS
	BR CRTT5
.ENDC
CLKTTY:	CLR E
	MOV #NTTYS,B	;NUMBE OF TELETYPES
	MOV ITEM1,A	;FOR A BOGUS PUSH
	JSR PC,ITM1PL	;LOAD UP THE SAME THING AGAIN
CLKTT1:	MOV TTYITM(E),A	;DOES IT HAVE AN ITEM
	BLE CLKTT2	;NOPE FORGET IT
	JSR PC,ITM1LD	;LOAD IT UP
	BIT #TTHANG,TTYST2(A)	;TEST THE STATUS BIT
	BEQ CLKTT2	;NOPE FORGET IT
	TST TIBN(A)	;ANY CHAR
	BEQ CLKTT2	;NOPE, FORGET THIS ONE TOO
	JSR PC,TICP	;PROCESS ITS CHARACTERS
CLKTT2:	ADD #2,E	;GET THE NEXT TTY
	SOB B,CLKTT1	;GO CHECK IT OUT
	JSR PC,ITM1PO	;DONE, POP BOGUS ITEM
	RTS PC	;GO BACK TO CLOCK ROUTINE

	;SET INTERRUPT ENABLE FOR ALL TTYS
TYINIT:	MOV #100,TKS
	MOV #100,TPS
	MOV #113,DC0TS	;SET UP THE SPEED FOR THE DC11'S
	MOV #111,DC0RS
	MOV #NDHTY,A	;NUMBER OF DH11 TTYS
	MOV #DH0SCR,B	;POINTER TO CONTROL REGISTER
	MOV #DH0LPR,C	;POINTER TO LINE PARAMETER REGISTER
	CLR (B)		;CLEAR RANDOM FLAGS
	MOV #NFDHTY,E	;POINT TO THE FIRST DH11 TTY
DHLP:	MOV TYINFO(E),F	;THE SPEEDS OF THE TTY
	BIC #177400,F	;CLEAR ALL BUT THE SPEED
	ASH #6,F	;SET INTO THE RIGHT BITS
	BIS #22,F	;SET IN 7 BITS/CHAR, AND ODD PARITY
	MOV F,(C)	;INTO THE LINE PAR. REG
	INC (B)		;GET NEXT LINE
	TST (E)+	;GET THE NEXT TTY
	SOB A,DHLP
	MOV #30100,(B)	;SET INTERUPT ENABLES
	RTS PC

	.SBTTL PAPER TAPE ROUTINES
TPSPCK:	MOV #PTPSZ,B	;NUMBER OF AVAILABLE BYTE POSITIONS
	SUB PTPNO(A),B	;NUMBER OF BYTES IN THE PAPERTAPE READER
	RTS PC		;RETURN IT

;OUTPUT THE BYTE IN D TO THE PAPER TAPE PUNCH
TPO:	SAVE E		;GET A REGIESTER
TPO3:	TST PTPSR	;ERROR?
	ERRORC MI,DEVE	;YES, DEVICE ERRROR
	CMP PTPNO(A),#PTPSZ	;ANY SPACE LEFT
	BLO TPO1		;YES, FINE
TPO2:	JSR PC,LFLUSH	;WAIT FOR SOME ROOM
	TST PTPSR	;ERROR?
	BMI TPO4	;YES
	CMP PTPNO(A),#PTPSZ	;ANY ROOM NOW
	BHIS TPO2	;FLUSH AWAY
TPO4:	JSR PC,RUNME
	BR TPO3		;TRY AGAIN
TPO1:	MOV PTPDAI(A),E	;POINT TO THE BUFFER
	ADD A,E		;MAKE IT ABSOLUTE
	MOVB D,(E)+	;PUT IN THE BYTE
	INC PTPNO(A)	;SAY ANOTHER BYTE
	SUB A,E		;MAKE POINTER RELATIVE AGAIN
	CMP E,#PTPEND	;DOES IT POINT TO THE END
	BLO 1$		;NOT YET
	MOV #PTPBUF,E	;MAKE IT POINT TO THE START AGAIN
1$:	MOV E,PTPDAI(A)	;SET IT BACK IN
	BIS #100,PTPSR	;KEEP THE INTERUPT ROUTINES AWAKE
	REST E
	RTS PC

PTRBRK:	SAVE <A,B>	;GET SOME REGISTERS
	TST PTRSR	;ERROR?
	BMI PTRDON	;YES, UNPLUGGED OR OUT OF TAPE
	MOV PTRITM,A
	BEQ PTRDON	;NO ITEM JUST RANDOM INTERRRUPT?
	JSR PC,ITM2PL	;LOAD UP THE PTR ITEM
	MOV A,B		;COPY THE POINTER
	ADD PTRDAI(A),B	;POINT TO THE PLACE TO PUT CHARACTER
	MOVB PTRBR,(B)+	;PUT THE CHARACTER INTO THE BUFFER
	SUB A,B		;BACK TO RELATIVE
	CMP B,#PTREND	;AT THE END OF THE BUFFER
	BLO 1$		;NO
	MOV #PTRBUF,B	;POINT TO THE START
1$:	MOV B,PTRDAI(A)	;REPLACE THE POINTER
	INC PTRNO(A)	;GOT SOME CHARACTERS?
	MOV PTRNO(A),B	;COPY NUMBER
	JSR PC,ITM2PO	;POP PTR ITEM
	CMP B,#PTRSZ	;BUFFER FULL?
	BEQ PTRDON	;YES, DONT GET ANY MORE CHARACTERS
	REST <B,A>	;GET BACK REG.
	INC PTRSR	;GET ANOTHER CHARACTER
	CHECKP
	RTT
PTRDON:	REST <B,A>	;GET BACK THE REGISTERS
	MOV #1,PTRSR	;READ A CHARACTER BUT WITHOUT INTERRUPTING
	CHECKP
	RTT

PTPBRK:	SAVE <A,B>
	MOV PTPITM,A	;ITEM WITH THE BARFER
	BEQ PTPBRE	;NO BARFER, SPURIOUS INT
	TST PTPSR	;ERROR?
	BMI PTPBE1	;T
	JSR PC,ITM2PL	;LOAD INTO MAP
	TST PTPNO(A)	;GOT ANYTHN FER ME?
	BEQ PTPBE1	;NOPE, BETTER LUCK NEXT TIME
	DEC PTPNO(A)	;I'M GOING TO TAKE IT AWAY (HAHA!)
	MOV PTPDAO(A),B	;RELATIVE POINTER INTO BUFFER
	ADD A,B		;ABSOLUTE
	MOVB (B),PTPBR	;THE CHARACTER
	SUB A,B		;RELATIVE AGAIN
	INC B
	CMP B,#PTPEND	;OFF END OF BUFFER?
	BLO 1$
	MOV #PTPBUF,B	;RESET POINTER
1$:	MOV B,PTPDAO(A)	;AND SAVE IT AWAY
	JSR PC,ITM2PO	;RESTORE ITEM 2
PTPBR1:	REST <B,A>	;REGISTERS
	CHECKP
	RTT		;AND PC AND PS

PTPBE1:	JSR PC,ITM2PO
PTPBRE:	CLR PTPSR	;NOTHING TO DO, GO TO SLEEP
	BR PTPBR1

TRCHAR:	CMP PTRNO(A),#PTRSZ	;IS IT FULL?
	BEQ 1$	;YES
	BIS #100,PTRSR	;CAUSE INTERRUPT IF THERE ISN'T ONE PENDING
1$:	MOV PTRNO(A),B	;GET THE NUMBER OF BYTES IN THE READER BUFFER
	BNE 3$		;NO MORE CHARACTERS, CHECK FOR ERROR
	TST PTRSR	;ERROR?
	BPL 3$		;NO
	COM B		;MAKE B NEGATIVE
3$:	RTS PC

TRGTBY:	TST PTRNO(A)	;ANY CHARACTERS
	BEQ TRGTB1	;NO, RETURN WITH Z SET
	MOV PTRDAO(A),D	;GET POINTER TO WHERE DATA COMES OUT
	ADD A,D		;MAKE IT POINT TO THE BYTE DIRECTLY
	MOVB (D),D	;GET THE BYTE
	DEC PTRNO(A)	;ONE LESS BYTE
	INC PTRDAO(A)	;INCREMENT POINTER
	CMP PTRDAO(A),#PTREND	;DOES IT POINT TO THE END?
	BLO TRGTB1	;NO
	MOV #PTRBUF,PTRDAO(A)	;RESET THE POINTER
TRGTB1:	RTS PC

	.STITL LINE PRINTER ROUTINES

PRTBRK:	TST PRTCSR	;ERROR
	BPL 1$
	CHECKP
	RTT		;JUST RETURN
1$:	JSR F,ACSAV	;SAVE SOME AC'S
	MOV LPTITM,A	;GET THE ITEM
	NBUGC EQ	;BETTER BE ONE
	JSR PC,ITM2PL	;LOAD IT UP
	TST LPTMOD(A)	;BETTER BE IN PRINT MODE
	NBUGC NE	;NO, ITS PLODDING???
	MOV LPTWCT(A),B	;GET NUMBER OF BYTES TRANSFERED LAST TIME
	SUB B,LPTNUM(A)	;FIX THE NUMBER OF BYTES LEFT
	MOV LPTDAO(A),F	;GET THE POINTER TO THE DATA OUT
	ADD B,F		;GET THE NEW DATA OUT POINTER
	CMP F,#LPTBUF+LPTBSZ	;IS IT BIGGER THAN THE BUFFER
	BLO LPTBR1	;NO
	SUB #LPTBSZ,F	;RESET IT
LPTBR1:	BIT #1,F	;STARTING ON AN ODD BYTE BOUNDARY?
	BEQ LPTBR5	;NO, EVERYTHING IS FINE
	TST LPTNUM(A)	;NO MORE BYTES
	BEQ LPTBR5	;FORGET IT
	INC LPTNUM(A)	;SAY THAT THERE IS ONE MORE BYTE (ABOUT TO PAD BEG WITH NULL)
	ADD A,F		;POINT TO BUFFER EXACTLY
	CLRB -(F)	;CLEAR THE PREVIOUS BYTE
	SUB A,F		;BACK TO RELATIVE
LPTBR5:	MOV F,LPTDAO(A)	;PUT BACK THE DATA OUT POINTER
	MOV LPTNUM(A),C	;GET THE NUMBER OF BYTES LEFT
	BEQ LPTDN1	;FORGET IT
	CMP C,#LPTBSZ/2	;IS IT MORE THAN HALF A BUFFER?
	BLOS LPTBR2
	MOV #LPTBSZ/2,C	;ONLY HALF THE BUFFER GOES AT ONCE
LPTBR2:	MOV C,D		;COPY IT
	ADD F,D		;GET WHERE THE TRANSFER WILL END
	CMP D,#LPTBUF+LPTBSZ	;WILL IT OVERFLOW THE BUFFER
	BLOS LPTBR3	;NO
	SUB #LPTBUF+LPTBSZ,D	;GET THE DIFFERENCE
	SUB D,C		;AND SHORTEN THE TRANSFER BY THAT MUCH
LPTBR3:	MOV C,LPTWCT(A)	;SET IN THE NUMBER FOR THE NEXT TRANSFER
LPTBR4:	MOV A,D		;SAVE POINTER
	MOV ITM2AR,B	;GET THE ADDRESS REG FOR THIS ITEM
	CLR A		;FOR THE ASHC
	ASHC #6,A	;GET IT INTO NUMBER OF BYTES
	ADD F,B		;ADD THE BYTE OFFSET
	ADC A		;DOUBLE PRECISION ADD
	ASH #4,A	;PUT INTO RIGHT BITS
	MOV B,LPTBA	;SET IT INTO THE BUSS ADDRESS
	MOV A,LPTMEX	;SET IN THE MEMORY EXTENTION
	MOV LPTCSR(D),D	;GET PIONTER TO THE CONTROL STATUS REGISTER
	ADD #PRTBCR-PRTCSR,D	;POINT TO THE BYTE CONTROL REGISTER
	MOV C,(D)	;START IT UP PRINTING OR PLOTTING
	JSR PC,ITM2PO	;POP THE ITEM
	JSR F,ACRES
	RTT	
LPTDN1:	CLR LPTWCT(A)	;NO WORD COUNT
LPTDN2:	MOV LPTCSR(A),D	;SAVE POINTER TO THE CSR
	JSR PC,ITM2PO	;POP ITEM AND GET OUT
	BIC #40000,(D)	;CLEAR THE INTERRUPT
	JSR F,ACRES
	RTT

PLTBRK:	TST PLTCSR	;ERROR?
	BPL 1$
	CHECKP
	RTT		;FORGET IT
1$:	JSR F,ACSAV	;SAVE THE AC'S
	MOV LPTITM,A	;GET THE ITEM
	NBUGC EQ	;BETTTER BE ONE
	JSR PC,ITM2PL	;LOAD IT UP
	MOV LPTMOD(A),F	;GET THE MODE
	NBUGC EQ	;BETTER BE PLOTTING
	BIS #40,@LPTCSR(A)	;SEND A REMOTE LINE TERMINATE
	TST LPTLCT(A)	;MORE ITERATIONS ON THIS LINE?
	BEQ PLTBR1	;NO
PLTSND:	DEC LPTLCT(A)	;ONE FEWER
	MOV #LPTLBF,F	;POINTER TO THE LINE BUFFER
	MOV LPTWCT(A),C	;THE NUMBER OF BYTES IN THE BUFFER
	BR LPTBR4	;TRANSMIT THE BUFFER
PLTBR1:	MOV LPTNUM(A),B	;GET THE NUMBER OF BYTES IN THE BUFFER
	CMP B,#2	;ARE THERE AT LEAST 2?
	BLO LPTDN1	;NO, JUST GO AWAY, AND WAIT
	MOV LPTEND(A),E	;GET THE END OF THE BUFFER
	ADD A,E		;MAKE IT ABSOLUTE
	MOV LPTDAO(A),D	;POINT TO THE DATA
	ADD A,D		;MAKE IT ABSOLUTE
	MOVB (D)+,C	;GET THE COUNT
	CMP D,E		;PAST THE END OF BUFFER
	BLO PLTBR2	;NO
	SUB LPTEND(A),D	;RESET THE POINTER
	ADD #LPTBUF,D	;POINT BACK INTO THE BUFFER
PLTBR2:	SWAB C		;GET THE BYTE
	BIC #377,C	;CLEAR THE BOTTOM BYTE
	BISB (D)+,C	;SET IN THE SECOND BYTE
	CMP D,E		;END OF BUFFER?
	BLO PLTBR4	;NO
	SUB LPTEND(A),D	;RESET IT
	ADD #LPTBUF,D	;POINT BACK INTO THE BUFFER
PLTBR4:	SWAB C		;BACK TO COUNT
	SUB #2,B	;2 FEWER BYTES LEFT IN BUFFER
	CMP C,B		;ARE THERE ENOUGH BYTES LEFT FOR FULL LINE?
	BHI LPTDN1	;NO, JUST GO AWAY FOR A WHILE
	MOV C,LPTWCT(A)	;SET IN THE WORD COUNT
	MOV C,B		;GET THE NUMBER OF BYTES IN THIS LINE
	SAVE <#0,B>	;THE NUMBER OF BYTES TO TRANSFER
	SUB B,LPTNUM(A)	;FIX UP NUMBER OF BYTES IN BUFFER
	SUB #2,LPTNUM(A)	;ALSO SUB THE COUNT BYTES
	ADD D,B		;GET THE NEW DATA OUT POINTER
	SUB A,B		;MAKE IT RELATIVE
	CMP B,LPTEND(A)	;IS IT PAST THE END OF THE BUFFER
	BLO PLTBR3	;NO
	SUB LPTEND(A),B	;RESET IT
	MOV B,2(P)	;SET UP THE SECOND COUNT
	SUB B,(P)	;AND THE FIRST ONE
	ADD #LPTBUF,B	;MAKE IT POINT TO THE BUFFER
PLTBR3:	MOV B,LPTDAO(A)	;NOW POINTER IS ACCURATE
	MOV F,LPTLCT(A)	;RESET THE LINE COUNTER
	MOV #LPTLBF,E	;POINT TO THE LINE BUFFER
	ADD A,E		;MAKE IT AN ABSOLUTE POINTER
	CMP F,#1	;IS IT EASY CASE?
	BEQ PLTSIM	;EASY
	SAVE <E,F>	;SAVE THE LINE POINTER THEN THE EXP MODE
	CLR E		;TO BUILD THE BITS TO SET IN
;FALLS THROUGH
;FALLS IN
PLTBIT:	SEC		;SET THE CARRY
	ROR E		;CARRY IT IN
	SOB F,PLTBIT	;CREATE E WITH THE EXPANSION NUMBER OF BITS IN IT
	REST F		;GET THE EXP. MODE
	NEG F		;WANT TO SHIFT TO THE RIGHT	
NXTBYT:	MOVB (D)+,C	;LOAD IT INTO C
	SAVE D		;SAVE THE BUFFER POINTER
	MOV #8.,D	;COUNTER FOR THE EXPANSION
EXPLOP:	ASHC F,A	;SHIFT THE REGS BY THE EXP. FACTOR
	BIC E,A		;OH FOR A LSH
	ROR C		;SHIFT OUT ONE BYTE OF THE DATA
	BCC EXPLP1	;LEAVE THE BITS 0
	BIS E,A		;SET THE CORRECT NUMBER OF BITS TO 1
EXPLP1:	SOB D,EXPLOP	;LOOP FOR THE ENTIRE BYTE
	REST D		;GET BACK BUFFER POINTER
	MOV (P),C	;POINT TO THE LINE BUFFER
	SWAB A		;WANT THE TOP BYTE FIRST
	MOVB A,(C)+	;PUT IT AWAY
	SWAB A		;GET TO THE SECOND BYTE
	MOVB A,(C)+	;STORE IT
	SWAB B		;WANT THE TOP BYTE AGAIN
	MOVB B,(C)+	;STORE ANOTHER ONE
	SWAB B		;AND FINALLY
	MOVB B,(C)+	;STORE THEM ALL
	SUB F,(P)	;SET THE LINE POINTER TO THE RIGHT THING
	DEC 2(P)	;THE COUNTER FOR THE BUFFER BEFORE HAVING TO RESET POINTER
	BNE NXTBYT	;GO GET THE NEXT ONE
	TST 4(P)	;ANY MORE AT ALL?
	BEQ EXPDON	;NO, WE ARE FINISHED
	MOV 4(P),2(P)	;RESET THE COUNT
	CLR 4(P)	;DONT DO ANY MORE WHEN THIS COUNT EXPIRES
	MOV #LPTBUF+ITM2AD,D	;RESET THE BUFFER POINTER
	BR NXTBYT	;PROCEED AS NORMAL
EXPDON:	ADD #6,P	;POP OFF ALL THAT CRUFT
	MOV ITM2A,A	;RESET A TO POINT TO THE ITEM
	NEG F		;MAKE THE MODE POSITIVE
	MUL LPTWCT(A),F	;GET THE REAL WORD COUNT
	MOV F,LPTWCT(A)	;AND SET IT UP
EXPDN1:	LBR ,PLTSND	;SEND IT
PLTSIM:	REST <B,C>	;GET THE COUNTS
PLTSM1:	MOVB (D)+,(E)+	;GET THE BYTE OUT OF THE BUFFER AND INTO LINE
	SOB B,PLTSM1
	MOV C,B		;GET THE SECOND COUNT
	BEQ EXPDN1	;NO MORE, WE IS FINISHED
	CLR C		;SO THAT WE FINISH NEXT TIME
	MOV #ITM2AD+LPTBUF,D	;POINT TO THE START OF THE BUFFER
	BR PLTSM1	;TRY AGAIN
