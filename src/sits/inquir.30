.TITLE INQUIR
.=20000
	A=%0
	B=%1
	C=%2
	D=%3
	E=%4
	F=%5
	P=%6
	PC=%7
	.INSRT SITS;SITMAC
	.INSRT SITS;SITSS SYMS

FILLN0:	ASCIZ ^/FILE HAS LENGTH ZERO	/
RIGHT:	ASCIZ ^/IS THIS RIGHT? (<CR> INDICATES YES)	/
MODE:	ASCIZ ^/MODE: (FOR ASSISTANCE TYPE ?)	/
QUEST:	ASCIZ ^/USERS (L)		LIST USERS I KNOW
LPUSERS (LP)		LIST USERS ON LPT
ENTER (E) <USER>	ENTER A NEW USER
QUIT (Q)		QUIT
DELETE (D) <USER>	DELETE A USER
CHANGE (C) <USER>	CHANGE FACTS ABOUT A USER
WHOIS (W) <USER>	TELL ME ABOUT <USER>
HELP (?)		HELP	/
NEWMSG:	.ASCIZ /USER NAME:/
PPLNAM:	.ASCIZ /FULL NAME:/
DIRNAM:	.ASCIZ /DIRECTORY NAME:/
DEFALT:	.ASCIZ /DEFALT PROGRAM (LOGO,DDT):/
USED:	.ASCIZ /FILE BEING USED, TRY AGAIN? (Y OR N) /
UZRHER:	.ASCIZ /USER NAME ALREADY EXISTS	/
NOLUZ:	.ASCIZ /NON-EXISTANT USER	/
NOLPT:	.ASCIZ /LPT NOT AVAILABLE/
.EVEN
OUTCAP:	3
CHARNO:	0
LENGTH:	0
BLOCK:	.BLKW 150
NLFN:	0
NBLOCK:	.BLKW 150
LZRNAM:	.BLKW 10
RLNAM:	.BLKW 50
DRNAM:	.BLKW 50
DFALT:	.BLKW 10
CONDIT:	1
ENTFLG:	1
DELFLG:	1
CHGFLG:	1
FILCPI:	0
FILCPO:	0
USRCAP:	0	;CAP TO USERINFO DIR
USRDIR:	ASCIZ ^/USRINFO/
FILNAM:	ASCIZ ^/USERS>/
OLFIL:	ASCIZ ^/USERS</
FRST:	1
	.BLKW 40
PDL:	
PAT:
PATCH:	.BLKW 100
TBL1:	.WORD NEWMSG,LZRNAM,0
	.WORD PPLNAM,RLNAM,12.
	.WORD DIRNAM,DRNAM,34.
	.WORD DEFALT,DFALT,70.
	0
.EVEN

.MACRO CMD CMD,ADDR
	.ASCIZ ÃMDŠ	.EVEN
	.IIF B ADDR,CMD
	.IIF NB ADDR,ADDR
NCMDS==NCMDS+1
.ENDM
NCMDS==0

CMDTAB:	CMD C,CHANGE
	CMD CHANGE
	CMD D,DELETE
	CMD DELETE
	CMD E,ENTER
	CMD ENTER
	CMD LP,LPUSER
	CMD LPUSERS
	CMD L,USERS
	CMD USERS
	CMD Q,QUIT
	CMD QUIT
	CMD W,WHOIS
	CMD WHOIS
	CMD ?,HELP
	CMD HELP

INQUIR:	MOV #PDL,P	;SET UP STACK
	MOV PC,CHGFLG	;SET FLAGS
	MOV PC,DELFLG
	MOV PC,ENTFLG
	TST USRCAP	;ALREADY MUTATED?
	BNE INQUI1	;YES
	SAVE <#-1,#0,#.CPYCP+10>
	$INVOK
	REST USRCAP
	SAVE <#0,#USRDIR,USRCAP>	
	BIS #.FAMU,(P)
	$INVOK		;MAKE A CAP TO THE USER DIR
INQUI1:	SAVE <#0,#.TICVM,#<.TTBIS*400>+2>	;SET TTYCAP
	$INVOK
	SAVE <#-1,#0,USRCAP>	;GET FILE CAP
	BIS #.CPYCP,(P)
	$INVOK
	REST FILCPI
	SAVE <#0, #FILNAM,FILCPI>	;MUTATE TO FILE
	BIS #.FAMU,(P)
	.INVOK
	BNE NWUZR		;FILE NOT HERE.  START NEW ONE
	ADD #6,P	;CALL FAILED
	JSR PC,FIRSTM
	BR NWUZR1
NWUZR:	SAVE <#0,#0,FILCPI,#<.CRWRT>+1>
	MOVB #20,3(P)
	$MAP
	DEC 0
	BEQ GOUZR
	MOV #USED,A
	JSR PC,TYPEIT
	JSR PC,TYI
	CMPB #'Y,A
	BEQ NWUZR1
	JMP QUIT
GOUZR:	MOV #MODE,A	;ASK FOR CMD
	JSR PC,TYPEIT
	JSR PC,CRLF
	SAVE FILCPI
	.WRDI
	JSR PC,CLOOP	;GO PROCESS IT
NWUZR1:	INC 0
	MOV PC,FRST
	SAVE <#0,#0,FILCPI>	;DELETE FILE CAP
	BIS #.DELCP,(P)
	$INVOK
	JMP INQUIR	;GET NEXT CMD


FIRSTM:	MOV #1,CONDIT	;SO ONLY ONE ENTRY IS MADE PER PASS
	CLR ENTFLG	;GET IN ENTRY MODE
	CLR FRST	;SO YOU DON'T DELETE THE FILE
	MOV #TBL1,F	;SET UP TABLE
	MOV (F)+,A	;MAKE INQUIREY
	JSR PC,TYPEIT
	JSR PC,CRLF
	MOV (F)+,E	;SET UP BUFFER
	TST (F)+	;SKIP LINE POS
 	MOV E,D
	MOV #20,C
	JSR PC,GETLIN	;GET HIS ENTRY
	JSR PC,CREATE	;CREATE THE FILE
	JMP OK

CLOOP:	MOV #NBLOCK,E	;PROCESS HIS COMMAND
	MOV E,D
	MOV 100,C
	JSR PC,GETLIN
CLOOPD:	MOV #NCMDS,A
	MOV #CMDTAB,B
CMDLOP:	MOV E,C
CMDLO3:	CMPB (B)+,(C)+
	BNE CMDLO1	;NOT THIS CMD
	TSTB (B)	;END OF CMD NAME?
	BNE CMDLO2	;NO, MAYBE THIS CMD
	CMPB #40,(C)	;IS THE CHAR A SEPERATOR?
	BLT CMDLO1	;NOPE, NOT THIS CMD
	INC B		;THIS CMD, GET DISPATCH
	BIT #1,B	;TO .EVEN
	BEQ .+4
	INC B
	JSR  PC,@(B)	;GO EXECUTE CMD
	RTS PC
CMDLO1:	TSTB (B)+	;END OF CMD NAME?
	BNE CMDLO1	;NOPE
	BIT #1,B	;.EVEN?
	BEQ .+4
	INC B
	TST (B)+	;SKIP DISPATCH ADDR
	SOB A,CMDLOP	;CHECK NEXT ONE IF ANY
	RTS PC
CMDLO2:	CMPB #40,(C)	;HAVE WE HIT A SEPERATOR?
	BGE CMDLO1	;YES, NOT THIS CMD
	BR CMDLO3	;NO, MAYBE THIS CMD

GETARG:	CMPB #' ,(C)+	;GET RID OF SPACES AFTER CMD
	BEQ GETARG
	MOV #LZRNAM,E	;SET UP BUFFER FOR LZRNAM
	TSTB -(C)	;DID HE GIVE AN ARGUMENT
	BEQ ARGOT	;NO, GO BACK AND START AGAIN
GTARG1:	MOVB (C)+,(E)+	;TRANSFER ARG TO LZRNAM BUFFER
	BEQ ARGOT1	;FINISHED?
	BR GTARG1	;NO KEEP GOING
ARGOT:	SEZ	;INDICATE NO USER NAME GIVEN
	RTS PC	;GO BACK
ARGOT1:	MOV #LZRNAM,C	;PUT START OF BUFFER IN C
	MOV C,E		;AND E
	CLZ	;USER NAME WAS INDICATED
	RTS PC	;RETURN

CHANGE:	CLR CHGFLG	;PUT IN CHANGE MODE
	JSR PC,GETARG	;GET USER NAME
	BNE CH		;WAS THERE ONE
	RTS PC	;NO
CH:	JSR PC,NEWLZR		;YES, GO CHANGE IT
	RTS PC	;RETURN TO TOP
DELETE:	CLR DELFLG	;PUT IN DELETE MODE
	JSR PC,GETARG	;GET USER NAME
	BNE DE	;WAS THERE ONE
	RTS PC	;NO
DE:	JSR PC,NEWLZR	;YES, GO DELETE IT
	RTS PC	;RETURN TO TOP
ENTER:	CLR ENTFLG	;GET IN ENTER MODE
	JSR PC,GETARG	;GET USER NAME
	BNE EN	;WAS THERE ONE
	RTS PC	;NO
EN:	JSR PC,NEWLZR	;YES, ENTER HIM
	RTS PC	;RETURN TO TOP
HELP:	MOV #QUEST,A	;TYPEOUT COMANDS
	JSR PC,TYPEIT
	JSR PC,CRLF
	RTS PC	;RETURN

LPUSER:	SAVE OUTCAP
	SAVE <#-1,,#.LPCAP*400+0>
	.INVOK
	BNE 1$
	ADD #10,P
	MOV #NOLPT,A
	JMP TYPECR
1$:	REST OUTCAP	;MAKE OUTCAP LPT CAP
	JSR PC,USERS	;OUTPUT LIST
	MOV #14,A
	JSR PC,TYO
	SAVE <,,OUTCAP>		
	BIS #.DELCP,(P)
	$INVOK		;FREE THE LPT
	REST OUTCAP	;BACK TO THE TTY
	RTS PC

USERS:	MOV PC,CONDIT	;DON'T TRY TO ENTER
	JSR PC,WWRIT	;TYPE OUT HEADING LINE
USER1:	JSR PC,GETBLK	;GET A BLOCK
	TST LENGTH	;IS IT THE LAST ONE?
	BEQ USER2	;YES
	MOV #TBL1,F	;SET UP BUFFER
	DEC B	;SET UP FOR SUB ROUTINE
	JSR PC,WLOP	;GET THE ENTRY SORTED
	JSR PC,WWRIT1	;WRITE IT
	BR USER1	;GO BACK AND GET NEXT ENTRY
USER2:	RTS PC	;RETURN TO TOP

WHOIS:	JSR PC,GETARG	;GET THE USER NAME
	BNE WHOIS1	;IS THERE ONE?
	RTS PC	;NO
WHOIS1:	MOV C,E	;RESET BUFFER
	JSR PC,GETBLK
	TST LENGTH
	BEQ WHOIS3
WHOIS2:	CMPB (B),(E)+
	BLT WHOIS1
	BEQ WSAME
WHOIS3:	MOV #NOLUZ,A
TYPECR:	JSR PC,TYPEIT
	JSR PC,CRLF
	RTS PC

WSAME:	TSTB (B)+
	BEQ .+4
	BR WHOIS2
	JSR PC,WFND
	JSR PC,WWRIT
	JSR PC,WWRIT1
	RTS PC

WWRIT:	MOV #TBL1,F
WWRIT0:	MOV (F)+,A
	BEQ WWRIT2	
	TST (F)+
	JSR PC,CARPOS	;POSITION TH ECARRIAGE
	JSR PC,TYPEIT
	TST (F)+
	BR WWRIT0
WWRIT1:	MOV #TBL1,F
WWRIT3:	TST (F)+
	BEQ WWRIT2
	MOV (F)+,A
	JSR PC,CARPOS
	JSR PC,TYPEIT
	TST (F)+
	BR WWRIT3
WWRIT2:	JSR PC,CRLF
	RTS PC
NEWLZR:	JSR PC,CREATE
	MOV #1,CONDIT	;COND ARG TO ALLOW 1 ENTRY
	MOV #TBL1,F
	ADD #6,F
	JSR PC,GETBLK	;GET FIRST BLOCK FROM OLD FILE

BACK:	TST LENGTH
	BNE .+6
	JMP OK
	CMPB (B),(E)+	;COMP USER NAMES (1 LETTER)
	BEQ SAME	;IF ALIKE GO TO SAME
	BGT OK		;IF OLD ENTRY GREATER PUT IN NEW ONE
	JSR PC,PUTBLK	;PUT AWAY OLD ENTRY
	JSR PC,GETBLK	;GET A NEW ONE
	MOV #LZRNAM,E	;RESET POINTER TO BEG OF INPUT BUFFR
	BR BACK		;TRY AGAIN


SAME:	TSTB (B)+	;ARE EQUAL BYTES ZERO??
	BEQ EXISTS	;USER ALREADY IN FILE
	BR BACK		;NO, CMP NEXT LETTER

EXISTS:	TST CHGFLG
	BEQ CHANG
	TST DELFLG
	BEQ DELET
	MOV #UZRHER,A	;TELL HIM USER EXISTS
	JSR PC,TYPEIT
	JSR PC,CRLF
	CLR CONDIT
	JMP FINISH
CHANG:	JSR PC,WFND
CHANG1:	MOV #TBL1,F	;GET TO BEGINNING OF TABLE
	ADD #4,F	;JUMP PAST UID ENTRY
CHLOP1:	TST (F)+
	SAVE <#0,#.TICVM,#<.TTBIS*400>+2>	;SET TTYCAP
	$INVOK
	TST (F)		;ARE WE FINISHED?
	BEQ CHNGND	;YES
	MOV #RIGHT,A	;ASK HIM IF IT IS RIGHT
	JSR PC,TYPEIT
	JSR PC,CRLF
	CMP (F),#PPLNAM
	BNE CHLOP0
	SAVE <#0,#.TICVM,#<.TTBIC*400>+2>	;SET TTYCAP
	$INVOK
CHLOP0:	MOV (F)+,A	;NO. TELL HIM WHAT HE'S CHANGING
	JSR PC,TYPEIT
	JSR PC,CRLF
	MOV (F)+,A	;GIVE HIM THE PRESENT ENTRY
	JSR PC,TYPEIT
	JSR PC,CRLF
	JSR PC,TYI	;GET HIS RESPONSE
	CMPB #15,A
	BEQ CHLOP1	;YES, MOVE TO NEXT ENTRY
	TST -(F)
	MOV (F),D	;SET UP BUFFER
	MOV D,E
	CLR C
	CMP #DFALT,D	;FIND THE BUFFERS LENGTH
	BEQ .+6
	MOV #40,C
	ADD #10,C
	MOVB A,(D)+
	JSR PC,TYO
	DEC C
	JSR PC,GETLIN	;GET THE NEW ENTRY
	CMP -(F),-(F)
	BR CHLOP1	;GO BACK AND RECHECK NEW ENTRY
CHNGND:	JSR PC,GETBLK	;CLEAN UP AND CLEAR OUT
	CLR CONDIT
	JSR PC,PTBLK2
	BR FINISH
DELET:	CLR CONDIT
	JSR PC,GETBLK	;GET NEXT ENTRY
	BR FINISH	;CLEAN UP AND CLEAR OUT

OK:	TST CONDIT	;HAS NEW ENTRY ALREADY BEEN ENTERED?
	BEQ NQUIT	;YES, DONE
	TST ENTFLG
	BEQ .+6
	JMP NQUIT1
	CLR CONDIT
LOOP:	TST (F)
	BEQ LOOP2
	SAVE <#0,#.TICVM,#<.TTBIS*400>+2>	;SET TTYCAP
	$INVOK
	CMP (F),#PPLNAM
	BNE LOOP0
	SAVE <#0,#.TICVM,#<.TTBIC*400>+2>	;SET TTYCAP
	$INVOK
LOOP0:	MOV (F)+,A	;ASK FOR ENTRY
	JSR PC,TYPEIT
	JSR PC,CRLF
	MOV (F)+,D	;SET UP INPUT BUFFER
	TST (F)+
	MOV D,E
	CLR C
	CMP #DFALT,D	;GET LENGTH OF BUFFER
	BEQ .+6
	MOV #40,C
	ADD #10,C
LOOP3:	JSR PC,GETLIN	;GET HIS ENTRY
	MOV #RIGHT,A	;ASK HIM IF HE ENTERED IT RIGHT
	JSR PC,TYPEIT
	JSR PC,CRLF
	MOV E,A
	JSR PC,TYPEIT	;WRITE OUT THE ENTRY YOU HAVE
	JSR PC,CRLF
	JSR PC,TYI	;GET HIS RESPONSE
	CMPB #15,A
	BEQ LOOP	;ITS RIGHT, GET NEXT ENTRY
	JSR PC,TYO
	SAVE E
	SUB E,D
	ADD D,C
	REST D
	MOVB A,(D)+
	DEC C
	BR LOOP3
LOOP2:	JSR PC,PTBLK2	;PUT AWAY NEWUSER


FINISH:	TST	LENGTH
	BEQ	NQUIT
	JSR	PC,PUTBLK	;PUT AWAY REST OF OLD FILE
	JSR	PC,GETBLK
	BR	FINISH

NQUIT1:	TST CHGFLG
	BEQ NQUIT
	TST DELFLG
	BEQ NQUIT
	TST (P)+
	RTS PC
NQUIT:	JSR	PC,PUTBLK	;PUT AWAY ZERO ENTRY
	TST	FRST
	BEQ	MUMBLE
	SAVE	<#0,#0,FILCPI>	;DELETE OLD FILE
	BIS	#.FADL,(P)
	$INVOK
	SAVE	<#0,#0,FILCPI>	;DELETE CAP TO OLD FILE
	BIS	#.DELCP,(P)
	$INVOK
MUMBLE:	MOV FILCPO,FILCPI
	RTS PC

WFND:	MOV #TBL1,F
	SUB C,E
	SUB E,B
	DEC B
WLOP:	TST (F)+
	BNE WLOP1
	RTS PC
WLOP1:	MOV (F)+,A
	TST (F)+
WLOOP:	INC B
	MOVB (B),(A)+
	BNE WLOOP
	BR WLOP

GETBLK:	SAVE	FILCPI	;GET ENTRY LENGTH
	.WRDI
	BEQ GOOF
	REST LENGTH	;GET LENGTH IN LENGTH AND F
	BNE GTBLK1	;ZERO LENGTH, PUT IN NEW ENTRY OR QUIT
	RTS PC
GTBLK1:	SAVE	<#BLOCK,LENGTH,FILCPI>	;GET ENTRY
	$BLKI
	MOV	#BLOCK,B
	RTS	PC

GOOF:	MOV #FILLN0,A	;TELL HIM FILE HAS ZERO LENGTH
	JSR PC,TYPEIT
	JSR PC,CRLF
	RTS PC


PUTBLK:	SAVE	<#LENGTH,LENGTH,FILCPO>
	SUB	#2,2(P)
	$BLKO
	RTS	PC


PTBLK2:	MOV #NBLOCK,E
	MOV #TBL1,F
LUPE:	TST (F)
	BEQ LUPE2	;MOVE ALL SMALL BUFFERS INTO ONE
	TST (F)+
	MOV (F)+,A
	TST (F)+
LUPE1:	MOVB (A)+,(E)+
	BNE LUPE1
	BR LUPE
LUPE2:	MOV #NBLOCK,F	;FIND THE LENGTH OF THE NEW BLOCK
	SUB E,F
	MOV F,NLFN
	BIC #1,NLFN
	SAVE	<#NLFN,NLFN,FILCPO>
	SUB	#2,2(P)
	$BLKO		;PUT AWAY NEW BLOCK
	RTS	PC

CREATE:	SAVE	<#-1,#0,USRCAP>
	BIS #.CPYCP,(P)
	$INVOK
	REST	FILCPO
	SAVE	<#0,#FILNAM,FILCPO>	;CREATE NEW FILE
	BIS	#.FAAD,(P)
	$INVOK
	SAVE <#0,FILCPO>
	$WRDO
	SAVE <#0,#0,FILCPO,#<.CRWRT>+1>
	MOVB #20,3(P)
	$MAP
	RTS	PC
;READ A LINE FROM TTY INTO THE LOGLIN BUFFER
;RETURN WITH Z CLEAR IF ANYTHING TYPED BEFORE <RETURN>
;AFTER LAST CHAR THERE IS A ZERO IN THE BUFFER
;D POINTS TO LAST CHAR IN THE BUFFER


GETLIN:	DEC	C

GETLI3:	JSR PC,GETLI1	;GET A NON-RUBOUT


GETLI7:	CMP #15,A	;RETURN?
	BEQ GETLI2
	JSR PC,TYO
	MOVB A,(D)+	;SAVE TEH CHARACTER
	SOB C,GETLI3


GETLI4:	JSR PC,GETLI1	;GET A NON-RUBOUT
	CMP #15,A
	BEQ GETLI2
	TST C		;DID HE RUBOUT?
	BNE GETLI3
	BR GETLI4


GETLI2:	JSR PC,CRLF
	CLRB (D)
	CMP D,E		;WAS ANYTHING TYPED?
	RTS PC




GETLI1:	JSR PC,TYI	;GET A CHAR
	CMPB #177,A	;IS IT A RUBOUT?
	BEQ GETL10
	RTS PC		;NO, RETURN WITH IT


GETL10:	CMP E,D		;ANYTHING TO RUB?
	BEQ GETLI1	;NOPE
	JSR PC,SLTYPE	;TYPE THE OPEN SLASH


GETLI5:	MOVB -(D),A
	JSR PC,TYO	;ECHO RUBBED OUT CHAR
	INC C		;ONE MORE SPACE IN BUFFER
	CMP E,D		;ALL RUBBED OUT?
	BEQ GETLI6	;MAKE OFF HE HIT OTHER CHAR
	JSR PC,TYI	;GET NEXT CHAR
	CMP #177,A	;IS IT ANOTHER RUBBOUT?
	BEQ GETLI5
	JMP SLTYPE


GETLI6:	JSR PC,SLTYPE	;END SLASH
	JSR PC,CRLF
	BR GETLI1




SLTYPE:	SAVE <A>
	MOVB #'\,A
	JSR PC,TYO	;TELL HIM HE IS RUBBING OUT
	REST <A>
	RTS PC
TYO:	SAVE <A,OUTCAP>
	$BYTO		;TYPE THE CHARACTER
	INC CHARNO
	CMP #15,A
	BNE 1$
	CLR CHARNO
1$:	RTS PC

TYI:	SAVE <#2>
	$BYTI		;GET AN INPUT CHARACTER
	REST <A>	;PUT IT IN A
	RTS PC

CRLF:	SAVE <A>
	MOV #15,A
	JSR PC,TYO
	REST <A>
	RTS PC

TYPEIT:	SAVE <A>
TYPEI2:	MOVB @(P),A
	BEQ TYPEI1
	JSR PC,TYO
	INC (P)
	BR TYPEI2

TYPEI1:	REST <A>
	RTS PC

QUIT:	INC 0
	SAVE	<#0,#0,FILCPI>
	BIS	#.DELCP,(P)
	$INVOK
	BPT

CARPOS:	SAVE A
	MOV #' ,A
2$:	CMP (F),CHARNO
	BLE 1$
	JSR PC,TYO	
	BR 2$
1$:	REST A
	RTS PC

;PUT CARRIAGE AT MULTIPLE OF 32 POSTION
TABOUT:	SAVE A
	MOV #' ,A
1$:	JSR PC,TYO
	BIT #17,CHARNO
	BNE 1$	
	REST A
	RTS PC

.END INQUIR
