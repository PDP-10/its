;TV VARIABLES
TVINCR=164140	;THE INCREMENT REGISTER FOR THE TV'S
TVINC==77	;THE MASK FOR THE INCREMENT
TVINT==100000	;INTERRUPT BIT FOR THE PSEUDO TV STATUS WORDS
TVRSET==100000	;THE RESET BIT
TVCLRW==400	;THE COLOR WRITE BIT
TVSEL=164142	;THE CONSOLE SELECT REGISTER
TVRCNS==77	;THE CONSOLE NUMBER MASK
TVRWMD==300	;THE REGULAR WRITE MODE MASK
TVNSH==0	;NO SHIFT WRITE MODE
TVIOR==100	;THE INCLUSIVE OR MODE
TVXOR==200	;THE XOR MODE
TVMOV==300	;THE MOVE FUNCTION
TVDCNS==TVRCNS*400	;THE DISK CONSOLE NUMBER (SAME, BUT IN TOP BYTE)
TVDWMD==TVRWMD*400	;THE DISK WRITE MODE MASK
TVRADR=164144	;THE REGULAR ADDRESS REGISTER
TVWC=164146	;THE WORD COUNT FOR THE BLOCK WRITE
TVDADR=164150	;THE DISK TRANSFER ADDRESS REGISTER
TVSHR=164152	;THE SHIFT REGISTER
TVSHCN==17	;THE SHIFT COUNT
;TVMAP==17400	;THE START OF THE 16K PAGE (IN 4K BLOCKS)
TVAMAP==20000	;THE ACTIVATE TVMAP BIT
TVMSK=164154	;THE MASK REGISTER
TVDWIN=164156	;THE WINDOW FOR DISK TRANSFERS
TVRWIN=164160	;THE WINDOW FOR REGULAR TRANSFERS
TVCNSL=164162	;THE CONSOLE REGISTER FOR THE MEMORY
TVCLR==160000	;THE COLOR NUMBER

LKBB==164100	;LEBEL KEYBOARD INTERFACE
VIDSW=164104	;VIDEO SWITCH
TVDOIT==11

COLORA==164106
COLORD==164102

TVBLTM==7.	;TV CURSOR BLINK TIME

.IFNZ NTVS
;TRANSLATION TABLE FOR LEBEL KEYBOARDS
LKBTAB:
.BYTE '^,'+,4,'(
.BYTE '),37,0,12
.BYTE 0,33,11,14
.BYTE 6,15,0,0
.BYTE '-,0,0,0
.BYTE 0,0,0,'/
.BYTE '*,177,'\,'_
.BYTE 7,34,35,36
.BYTE 40,'!,';,'#
.BYTE '$,'%,'',':
.BYTE '`,'~,'@,'\
.BYTE ',,'=,'.,'?
.BYTE '0,'1,'2,'3
.BYTE '4,'5,'6,'7
.BYTE '8,'9,'','"
.BYTE ',,'<,'.,'!
.BYTE '",'A,'B,'C
.BYTE 'D,'E,'F,'G
.BYTE 'H,'I,'J,'K
.BYTE 'L,'M,'N,'O
.BYTE 'P,'Q,'R,'S
.BYTE 'T,'U,'V,'W
.BYTE 'X,'Y,'Z,'[
.BYTE '],'[,'&,'^
.BYTE '>,'a,'b,'c
.BYTE 'd,'e,'f,'g
.BYTE 'h,'i,'j,'k
.BYTE 'l,'m,'n,'o
.BYTE 'p,'q,'r,'s
.BYTE 't,'u,'v,'w
.BYTE 'x,'y,'z,'%
.BYTE '],'$,'|,25

;DISPATCH TABLE FOR SPECIAL CHARACTER ROUTINES
TVSCJT:	.WORD 0,0,TVBLON,0,TVSPDN,0,0,0
	.WORD TVSPB,0,TVLF,TVCEOL,TVCS,TVCR,TVBLOF,0
	.WORD 0,0,REVSCR,0,0,TVHOMU,0,0
	.WORD TVSPF,TVSPB,TVSPU,0,0,0,TVCEOL,TVSPBE

TVUBR:	0	;IF YOU WANT THE UBR RESTORED YOU BETTER PUT IT HERE
FOO==NFTV
TVKBS:	.REPT NTVS	;THIS TABLE GIVES THE LOGICAL TTY NO. OF KEYBOARDS
	.WORD FOO
FOO==FOO+2
.ENDR
FOO==0
TVMAP:	.REPT NTVS
	.WORD FOO
FOO==FOO+1
.ENDR
;THE FOLLOWING TABLE CONTAINS STATUS BITS, PARTICULARLY THE INTERRUPT
;BIT IN THE HIGH BYTE AND THE BLINK COUNT IN THE LOW BYTE.
TVSTAT==.-NFTV
TVBLNK==.-NFTV
	ZEPT NTVS,0




;TV CLOCK TICK ROUTINE
TVTICK:	JSR F,ACSAV
	JSR F,TVSAV	;SAVE TV REGISTERS
	JSR PC,LKBBRK	;GO COLLECT KEYBOARD CHARACTERS
	JSR PC,TVOUT	;GO EMPTY TV OUTPUT BUFFERS
	JSR F,TVRES	;RESTORE TV REGISTERS
	JSR F,ACRES
	RTS PC

TVSAV:	TST (P)+
	TST TVWC
	BNE .-4
	SAVE <TVMSK,TVRADR,TVSEL,TVINCR,TVSHR>
	JMP (F)

TVRES:	TST (P)+
	TST TVWC
	BNE .-4
	REST <TVSHR,TVINCR,TVSEL,TVRADR,TVMSK>
	JMP (F)

;RECEIVE CHARS FROM THE TV KEYBOARDS AND INSERT INTO QUE
LKBBRK:	MOV LKBB,C		;GET ANY CHARACTER THAT MIGHT BE THERE
	BEQ LKBBR1		;NONE
	BIC #160200,C		;CLEAR THE GARBAGE
	MOV C,E			;COPY
	SWAB E			;TO GET KEYBOARD NUMBER
	BIC #177740,E
	ASL E
	MOV TVKBS(E),E		;GET THE "REAL" TTY NUMBER (LOGICAL, I HOPE)
	MOVB C,D
	MOVB LKBTAB(D),D	;TRANSLATE TO REAL CHARACTERS
	BEQ LKBBRK		;IMAGINARY CHARACTER TYPED
	JSR PC,TYRCV		;PUT THE CHAR INTO THE QUE
	BR LKBBRK		;TRY TO GET ANOTHER CHAR
LKBBR1:	RTS PC

;TVOUT CHECKS IF ANY OF THE CURSORS SHOULD BE BLINKED AND IF ANY
;OF THE TTY OUTPUT BUFFERS FOR TVS HAVE CHARS IN THEM
TVOUT:	MOV #NFTV,E		;OFFSET OF THE FIRST TV IN TTY TABLES
	MOV #-1,A		;ARG TO ITM2PL
	JSR PC,ITM2PL		;DUMMY PUSH
TVOUT1:	BIT #TVINT,TVSTAT(E)	;IS THE OUTPUT INTERRUPT BIT SET ON THIS TV
	BEQ TVOUT2		;NO
	MOV TTYITM(E),A		;THE ITEM NUMBER OF THIS TV
	JSR PC,ITM2LD		;LOAD IT UP
	JSR PC,TYXMT		;START UP TRANSMISSION
	BIC #TVINT,TVSTAT(E)	;CLEAR INTERRUPT BIT
TVOUT2:	TSTB TVBLNK(E)		;CHECK THE BLINK COUNT FOR THIS TV
	BEQ TVOUT5		;IF ZERO, THEN CURSOR IS OFF
	BLT TVOUT3		;CURSOR IS OFF
	DECB TVBLNK(E)		;TIME TO TURN IT OFF?
	BNE TVOUT5		;NOT YET
	MOVB #-TVBLTM,TVBLNK(E)	;NOW LEAVE IT OFF FOR .25 SEC
	BR TVOUT4		;BLINK IT
TVOUT3:	INCB TVBLNK(E)		;TIME TO TURN IT ON?
	BNE TVOUT5		;NOT YET
	MOVB #TVBLTM,TVBLNK(E)	;LEAVE IT ON FOR .25 SEC
TVOUT4:	MOV TTYITM(E),A		;THE ITEM OF THIS TV
	JSR PC,ITM2LD		;LOAD IT
	JSR PC,BLINK		;CHANGE STATE OF CURSOR
TVOUT5:	ADD #2,E		;ADVANCE TO NEXT TV
	CMP E,#NFTV+<2*NTVS>	;HAVE WE GOTTEN ALL OF THEM YET?
	BLT TVOUT1		;NO
	JSR PC,ITM2PO		;POP THE DUMMY
	RTS PC

;THIS ROUTINE IS CALLED BY TYXMT AND SETS UP THE ARGUMENTS FOR
;THE ACTUAL CHAR GENERATION ROUTINES. IT GETS CHAR FROM THE TTY
;OUTPUT BUFFER VIA TOOQ UNTIL THERE IS NOTHING LEFT IN THE BUFFER.
TVSND:	SAVE E			;FREE UP A REGISTER
	TSTB TVBLNK(E)		;IS THE CURSOR OFF?
	BLE TVSND0		;BLINKER IS ALREADY OFF
	JSR PC,BLINK		;OTHERWISE, TURN IT OFF
	MOVB #-TVBLTM,TVBLNK(E)	;AND RESET ITS COUNT
TVSND0:	MOV TVFONT(A),A		;GET THE FONT NUMBER
	BLT TVSND6		;BAD FONT NUMBER
	MOV FNTITM(A),A		;GET THE FONT NUMBER OF THIS FONT
	BLE TVSND6		;NO FONT ITEM AT THIS NUMBER
	JSR PC,ITM1PL		;LOAD IT UP
	MOV A,B			;COPY ITEM1 ADDRESS
	MOV ITM2A,A		;GET ITEM 2 ADDRESS
TVSND1:	TST TVWC		;WAIT FOR PREVIOUS OPERATION
	BNE .-4
	MOVB TVBUF(A),TVSEL	;SPECIFY WHICH BUFFER
	TST TVBUF(A)		;NO BUFFER?
	BLT TVSND5		;JUST FLUSH OUTPUT IF NO BUFFER
	MOV #1044,TVINCR	;INCREMENT ONE LINE AT A TIME
TVSND2:	JSR PC,TOOQ		;TRY TO GET A CHAR FROM OUTPUT QUE. SKIP IF OK
	BR TVSND5		;NOT SUCCESS FULL, THIS BUFFER EMPTY
	BIC #177600,D		;CLEAN GARBAGE
	ASL D			;CONVERT TO WORD OFFSET
	TST TVWC		;IS THE PREVIOUS OPERATION COMPLETE
	BNE .-4			;NO, THEN WAIT FOR IT TO COMPLETE
	CMP D,#40*2		;CONTROL CHARACTER?
	BGE 1$			;NO, GO TO THE FONT
	MOV TVSCJT(D),E		;GET THE SPECIAL ROUTINE
	BEQ 1$			;THERE ISN'T ONE,GO TO THE FONT
	JSR PC,(E)		;CALL THE ROUTINE
	BR TVSND1		;GET THE NEXT CHARACTER
1$:	MOV D,E			;COPY THE CHAR
	ADD B,E			;GET OFFSET INTO FONT
	MOV FNTPNT(E),E		;GET THE ACTUAL FONT POINTER
	BEQ TVSND3		;NO CHAR, JUST SPACE FORWARD
	ADD B,E			;MAKE FONT POINTER LESS RELATIVE
	MOV TVMSK1(A),TVMSK	;GET THE CURSOR MASK
	COM TVMSK		;MASK IS REVERSED
	MOVB TVSHCT(A),TVSHR	;SHIFT COUNT GOES INTO THE SHIFT REGISTER
	MOV #TVRWIN,F		;ADDRESS OF TV WINDOW
	MOV FNHIGH(B),C		;COUNT OF LINES TO GENERATE
	MOV TVCRLN(A),TVRADR	;SET UP THE ADDRESS
	CMP FNWIDE(B),#8.	;SHOULD WE DO BYTES OR WORDS
	BGT TVSND8		;WORDS
	MOVB (E)+,(F)		;MOV FONT DATA INTO THE WINDOW
	SOB C,.-2		;DO IT THE CORRECT NUMBER OF TIMES
	BR TVSND9
TVSND8:	MOV (E)+,(F)		;MOVE FONT DATA INTO THE WINDOW
	SOB C,.-2
TVSND9:	TST TVMSK2(A)		;DO WE CROSS A WORD BOUNDRY?
	BEQ TVSND3		;NO
	MOV TVMSK2(A),TVMSK	;GET THE OTHER PART OF THE CURSOR MASK
	COM TVMSK
	MOV FNHIGH(B),C		;THE COUNT
	SUB C,E			;BACK UP THE FONT POINTER
	CMP FNWIDE(B),#8.	;WERE WE DOING BYTES?
	BLE .+4			;YES
	SUB C,E			;DO IT TWICE CAUSE IT'S A WORD POINTER
	MOV TVCRLN(A),TVRADR	;SET UP THE ADDRESS AGAIN
	ADD #2,TVRADR		;DO THE NEXT WORD NOW
	CMP FNWIDE(B),#8.	;SHOULD WE DO WORDS?
	BGT TVSND7		;YES
	MOVB (E)+,(F)		;DO IT AGAIN
	SOB C,.-2
	BR TVSND3
TVSND7:	MOV (E)+,(F)		;MOVE FONT DATA
	SOB C,.-2
TVSND3:	JSR PC,TVSPF		;SPACE FORWARD
	BR TVSND2		;TRY TO GET ANOTHER CHAR
TVSND5:	JSR PC,ITM1PO		;POP THE FONT ITEM
TVSND6:	REST E			;PUT THE TTY NUMBER BACK
	RTS PC


;DISPLAY A LF
TVLF:	BIT #.TSCRL,TTYST2(A)	;ARE WE IN SCROLL MODE?
	BNE TVLF3		;YES
	JSR PC,TVSPDN		;SPACE DOWN ONE LINE
	JSR PC,TVCEOL		;CLEAR TO END OF LINE
TVLF4:	RTS PC
TVLF3:	JSR PC,TVSPDN		;NO, JUST SPACE DOWN ONE LINE
	JSR PC,TVCEOL		;CLEAR NEXT LINE
	TST TVWC		;DONE YET?
	BNE .-4			;NO, WAIT
	CMP TVLINE(A),TVHIGH(A)	;ARE WE AT THE LAST LINE YET?
	BEQ TVLF5		;YES, SCROLL
	RTS PC
TVLF5:	MOV TVNLSC(A),C		;NUMBER OF LINES TO SCROLL
	MUL FLFINC(B),C		;THERE ARE TVHIGH LINES PER CHAR
	ASH #-3,D		;BECAUSE SCRL IS IN 64 BIT WORDS
	ADD D,TVSCRL(A)		;UPDATE THE SCROLL POINTER
	CMP #7766,TVSCRL(A)	;ARE WE AT THE THE SCROLL WRAPAROUND POINT?
	BGT .+10		;NO
	SUB #7766,TVSCRL(A)	;WRAP THE SCROLL AROUND THE BUFFER
	MOV TVSCRL(A),F		;GET THE SCROLL POINTER
	BIC #7777,TVST(A)	;CLEAR OUT THE OLD SCROLL POINTER
	BIC #170000,F		;MAKE SURE THERE IS NO GARBAGE PRESENT
	BIS F,TVST(A)		;PUT IN THE NEW SCROLL POINTER
	MOV TVST(A),TVCNSL	;SET IN THE STATUS FOR THIS TV
	MOV TVNLSC(A),F		;CLEAR THIS MANY LINES
	SAVE TVCRLN(A)		;SAVE CURSOR ADDRESS
	ADD FNREM(B),TVCRLN(A)	;ADD THE REMAINING BYTES IN THE SCREEN BEFOR TOP
	BGE TVLF6		;WE DID NOT WRAP AROUND
	ADD #77660,TVCRLN(A)	;WRAP AROUND
	BR TVLF2		;NOW WE SHOULD CLEAR EXACTLY ON THE TOP LINE
TVLF6:	CMP TVCRLN(A),#77660	;DID WE WRAP AROUND?
	BLO TVLF2		;NO
	SUB #77660,TVCRLN(A)	;WRAP AROUND
TVLF2:	JSR PC,TVCEOL		;CLEAR THIS LINE TO END OF LINE
	TST TVWC		;ARE WE DONE YET?
	BNE .-4			;NO WAIT
	ADD FLFINC(B),TVCRLN(A)	;ADVANCE CURSOR ADDRESS TO NEXT LINE
	CMP #77660,TVCRLN(A)	;ARE WE AT BUFFER WRAP AROUND YET?
	BHI .+10		;NO
	SUB #77660,TVCRLN(A)	;WRAP AROUND THE BUFFER
	SOB F,TVLF2		;KEEP CLEARING LINES
	REST TVCRLN(A)
	SUB TVNLSC(A),TVLINE(A)	;BACK UP BY THE NUMBER OF LINES WE SCROLLED
	JMP RSCUR		;RESET THE CURSOR TO THE PROPER PLACE


;SPACE UP THE CURSOR
TVSPU:	TST TVLINE(A)		;ARE WE AT LINE 0?
	BLE TVSPU1		;YES, CAN'T SPACE UP ANY MORE
	DEC TVLINE(A)		;THE LINE NUMBER
	SUB FLFINC(B),TVCRSN(A)	;MOV THE START OF THE LINE UP
	BGE .+10		;DID NOT WRAP AROUND
	ADD #77660,TVCRSN(A)	;YES WE DID
	SUB FLFINC(B),TVCRLN(A)	;GO BACK UP ONE LINE
	BGE .+10		;WE DID NOT WRAP AROUND THE BUFFER
	ADD #77660,TVCRLN(A)	;OH YES WE DID
TVSPU1:	RTS PC

;SPACE DOWN THE CURSOR
TVSPDN:	INC TVLINE(A)		;INCREMENT THE LINE NUMBER
	CMP TVLINE(A),TVHIGH(A)	;ARE WE AT THE END YET?
	BLT TVSPD1		;NO
	BIT #.TSCRL,TTYST2(A)	;ARE WE IN SCROLL MODE?
	BNE TVSPD1		;YES
	MOV TVOFFL(A),TVLINE(A)	;GO TO THIS LINE
	JMP RSCUR		;RESET THE VARIABLES
TVSPD1:	ADD FLFINC(B),TVCRSN(A)	;ALSO ADJUST THE START OF THE LINE
	CMP #77660,TVCRSN(A)	;DID WE WRAP AROUND?
	BHI .+10		;NO
	SUB #77660,TVCRSN(A)	;YES
	ADD FLFINC(B),TVCRLN(A)	;GO DOWN ONE LINE
	CMP #77660,TVCRLN(A)	;DID WE WRAP AROUND?
	BHI .+10		;NO
	SUB #77660,TVCRLN(A)	;YES
TVSPD2:	RTS PC

;SPACE THE CURSOR FORWARD, BUT DO NOT ERASE WHAT'S THERE
TVSPF:	INC TVCUR(A)		;ADVANCE CURSOR 1 CHAR
	ADD FNWIDE(B),TVHBIT(A)	;ADVANCE THE HORIZONTAL BIT POSITION
TVSPF1:	MOV TVHBIT(A),D		;GET THE HORIZONTAL BIT POS
	MOV D,E			;GET A COPY
	ASH #-4,E		;FIND WHICH WORD IT'S ON
	ASL E			;WE NEED A BYTE ADDRESS
	ADD TVCRSN(A),E		;ADD THE BYTE ADDRESS OF THE START OF LINE
	MOV E,TVCRLN(A)		;RESET THE CURSOR ADDRESS
	JMP SETMSK		;RESET THE MASK

;SPACE BACK ONE CHAR
TVSPB:	TST TVCUR(A)		;ARE WE AT BEGINNING OF LINE
	BEQ TVSPB1		;YES DO NOT BACKSPACE ANY MORE
	DEC TVCUR(A)		;GO BACK 1 CHAR
	SUB FNWIDE(B),TVHBIT(A)	;ADJUST BIT POSITION
	BR TVSPF1		;RESET TVCRLN AND THE MASKS
TVSPB1:	RTS PC

;HOME UP
TVHOMU:	CLR TVCUR(A)		;SET CURSOR TO BEG OF LINE
	MOV TVOFFL(A),TVLINE(A)	;SET LINE TO THE TOP OF VIRTUAL SCREEN
	JMP RSCUR		;RESET THE CURSOR
1
;TURN OFF CURSOR BLINKING
TVBLOF:	MOV TTLTTY(A),E		;GET THE TTY NUMBER
	CLR TVBLNK(E)		;TURN IT OFF
	RTS PC			;THAT IS ALL

TVBLON:	MOV TTLTTY(A),E		;GET THE TTY NUMBER
	MOV #-TVBLTM,TVBLNK(E)	;RESET THE COUNT FOR IT
	RTS PC


;RESET THE CURSOR BYTE POSITION AND MASK ON THE BASIS OF THE LINE
;NUMBER AND CHAR NUMBER OF THE LINE.
RSCUR:	MOV TVLINE(A),C		;THE LINE NUMBER
	MUL FLFINC(B),C		;GET THE BYTE OFFSET FROM START OF BUFFER
	MOV TVSCRL(A),F		;THE SCROLL POINTER (MUL RESULT IN D)
	ASH #3,F		;BECAUSE SCROLL IS MEASURED IN 64 BIT WORDS
	ADD D,F			;GET THE BYTE POSITION
	CMP F,#77660		;SHOULD WE WRAP AROUND
	BLO .+6			;NO
	SUB #77660,F		;WRAP AROUND
	MOV F,TVCRSN(A)		;BYTE ADDRESS OF THE START OF THE LINE
	MOV TVCUR(A),C		;GET THE CHAR NUMBER
	MUL FNWIDE(B),C		;GET THE BIT POSITION
	MOV D,TVHBIT(A)		;THE HORIZONTAL BIT POSTITION
	MOV D,C			;GET A COPY, SETMSK EXPECTS THIS IN D
	ASH #-4,C		;DIVIDE BY 16 TO GET THE WORD OFFSET
	ASL C			;NOW MAKE IT A BYTE OFFSET (TVCRLN MUST BE EVEN)
	ADD C,F			;GET THE BYTE NUMBER OF THE CURSOR
	CMP F,#77660		;THE WRAPAROUND POINT
	BLO .+6
	SUB #77660,F		;WRAP AROUND
	MOV F,TVCRLN(A)		;RESET THE CURSOR BYTE POSITION
;FALL INTO SET MASK

;PUT A MASK IN THE CORRECT BIT POSITION FOR THIS CHAR NUMBER
;EXPECT TVHBIT IN D
SETMSK:	ADD FNWIDE(B),D		;BECAUSE CHARS ARE RIGHT ADJUSTED
	BIC #177760,D		;GET RESULT MOD 16
	CMP D,FNWIDE(B)		;FIGURE THE NEXT FEW LINES FOR YOURSELF
	BGE RSMSK1		
	NEG D
	BR RSMSK2
RSMSK1:	NEG D
	ADD #16.,D
RSMSK2:	MOV D,F			;THIS IS NOW THE SHIFT COUNT
	CLR D			;PUT ALL ZEROS IN D
	MOV FNMSK(B),C		;THE MASK FOR CHARS WHICH IS RIGHT ADJUSTED
	ASHC F,C		;YOU MAY SHIFT LEFT OR RIGHT
	MOV C,TVMSK1(A)		;THIS IS ALWAYS THE FIRST WORD OF THE MASK
	MOV D,TVMSK2(A)		;AND THIS THE SECOND
	TST F			;SHIFT IS ALWAYS POSITIVE
	BGE .+6
	ADD #16.,F
	MOV F,TVSHCT(A)		;SAVE AS THE SHIFT COUNT FOR THIS POSITION
	MOV TVCUR(A),CHARNO(A)	;SET UP THE CURSOR POSITION
	RTS PC

;BACK SPACE AND ERASE THE CHAR (LIKE RUBOUT)
TVSPBE:	JSR PC,TVSPB
	MOVB TVBUF(A),TVSEL
	TST TVBUF(A)		;BUFFER?
	BLT TSPBE1		;IN CASE THERE IS NO BUFFER
	BIC #TVMOV,TVSEL	;CLEAR OUT THE CURRENT FUNCTION
	BIS #TVIOR,TVSEL	;SET IT TO INCLUSIVE OR
	JSR PC,BLINK1		;WRITE ALL ONES OVER THIS CHAR
	JSR PC,BLINK		;NOW CLOBBER THE ONES TO ZEROS
TSPBE1:	RTS PC

;CARRIAGE RETURN SIMPLY CLEARS CURSOR POSITION
TVCR:	CLR TVCUR(A)		;CHAR POSITION 0
	CLR D			;SETMASK EXPECTS TVHBIT IN D
	MOV D,TVHBIT(A)		;BIT POSITION 0
	MOV TVCRSN(A),TVCRLN(A)	;RESET CURSOR BYTE ADDRESS TO BEGINNING OF LINE
	JMP SETMSK		;RESET THE MASK FOR THE CURSOR

;CLEAR TO END OF LINE
TVCEOL:	BIC #300,TVSEL		;SPECIFY MOVE FUNCTION
	CLR TVMSK		;DO NOT MASK ANY OF THE ZEROS
	MOV TVCRLN(A),TVRADR	;THIS IS EASY. SET UP THE ADDRESS
	TST TVCUR(A)
	BNE TVCEO1		;NO, DAMN
	MOV #1001,TVINCR	;CLEAR EVERY WORD
	MOV FLFINC(B),C		;NUMBER OF BYTES IN A LINE
	MOV TVHIGH(A),D		;THE NUMBER OF LINES ON THE SCREEN
	DEC D			;THIS GIVES THE LINE NUMBER OF LAST LINE ON SCREEN
	CMP TVLINE(A),D		;ARE WE ON THE LAST LINE OF THE SCREEN?
	BNE TVCEO4		;NO
	ADD FNREM(B),C		;PLUS ANY LEFTOVER SPACE (MAY BE NEGATIVE)
TVCEO4:	ASR C			;WORD COUNT IS FOR WORDS NOT BYTES
	DEC C			;WRITING INTO THE WINDOW COUNTS FOR 1
	NEG C			;TVWC EXPECTS A NEGATIVE COUNT
	CLR TVRWIN		;CLEAR THIS WORD
	MOV C,TVWC		;KEEP CLEARING
	RTS PC

;IN THIS CASE, WE ARE IN THE MIDDLE OF A LINE
TVCEO1:	MOV #1044,TVINCR	;INCREMENT A LINES WORTH
	SAVE F			;CANT CLOBBER THIS
	MOV TVSHCT(A),C		;THE SHIFT COUNT FOR THIS BIT POS
	ADD FNWIDE(B),C		;ADD CHAR WIDTH
	CMP C,#16.		;CAN'T BE 16 OR GREATER
	BLE .+6			;IT'S NOT
	SUB #16.,C		;MAKE IT LESS THAN 16
	MOV #177777,D		;ALL ONES
	ASH C,D			;PUT ZEROS IN THE PART WE WANT TO CLEAR
	MOV D,TVMSK		;MASK PART OF THE FIELD
	CLR TVRWIN		;WRITE ZEROS
	CLR E			;INITIALIZE TO ZERO
	MOV TVHIGH(A),F		;NUMBER OF LINES IN THE SCREEN
	DEC F			;THE LINE NUMBER OF THE LAST LINE
	CMP TVLINE(A),F		;ARE WE ON THE LAST LINE OF THE SCREEN?
	BNE TVCEO5		;NO
	MOV FNREM(B),F		;NUMBER OF LEFTOVER BYTES AT BOTTOM OF SCREEN
	DIV #110,E		;COMPUTE THE NUMBER OF LEFTOVER LINES, RESULT IN E
TVCEO5:	ADD FNTLCL(B),E		;NUMBER OF LINES IN A CHAR LINE MINUS 1
	DEC E			;BECAUSE WRITING INTO TVRWIN COUNTS AS ONE
	MOV E,F			;THE WORD COUNT
	NEG F			;TVWC LIKES A NEGATIVE COUNT
	MOV F,TVWC		;CLEAR FOR THIS MANY LINES
	MOV TVCRLN(A),D		;THE CURSOR ADDRESS
	ADD #2,D		;GO TO NEXT WORD
	MOV TVHBIT(A),C		;THE HORIZONTAL BIT POSITION
	ASH #-3,C		;GIVES THE BYTE POSITION FOR THIS LINE
	SUB #106,C		;GIVING BYTES ON THIS LINE TO CLEAR, NEGATIVE
	BEQ TVCEO3		;THUS WE ARE DONE
	ASR C			;CONVERT FROM BYTES TO WORDS
	INC C			;FOR LOADING TVRWIN CAUSES ONE WORD TO BE WRITTEN
	TST TVWC		;DID WE FINISH CLEARING THE FIRST PART YET
	BNE .-4			;NO
	MOV D,TVRADR		;SET UP THE ADDRESS
	CLR TVMSK		;SO WE WRITE ALL THE ZEROS
	MOV #1001,TVINCR	;INCREMENT ONE WORD AT A TIME WITH WRAPAROUND
TVCEO2:	CLR TVRWIN		;START CLEARING THE SCREEN
	MOV C,TVWC		;THIS MANY WORDS TO CLEAR
	TST TVWC		;ARE WE DONE YET?
	BNE .-4			;NO YET
	ADD #110,D		;GO TO NEXT LINE
	MOV D,TVRADR		;RESET THE ADDRESS
	SOB E,TVCEO2		;UNTIL ALL LINES IN THIS CHAR LINE ARE CLEAR
TVCEO3:	REST F
	RTS PC


;BLINK THE CURSOR BY XORING IT WITH ITSELF
BLINK:	TST TVWC		;ARE WE DONE WITH PREVIOUS OPERATION
	BNE .-4			;NO, WAIT FOR IT
	MOVB TVBUF(A),TVSEL	;GET THE BUFFER NUMBER
	TST TVBUF(A)		;BUFFER?
	BLT BLINK2		;IN CASE HE HAS NO BUFFER
	BIC #TVMOV,TVSEL	;CLEAR OUT THE OLD FUNCTION
	BIS #TVXOR,TVSEL	;TOGGLE THE CURSOR
BLINK1:	CLR TVMSK		;NO MASK
	CLRB TVSHR		;NO SHIFT
	MOV #1044,TVINCR	;INCREMENT ONE LINE PER WORD
	MOV TVCRLN(A),TVRADR	;SET UP THE ADDRESS
	MOV TVMSK1(A),TVRWIN	;THE MASK
	MOV TVLCNT(A),TVWC	;THE COUNT
	TST TVMSK2(A)		;MUST WE DO THE OTHER WORD?
	BEQ BLINK2		;NO
	TST TVWC		;ARE WE DONE WITH PREVIOUS OPERATION?
	BNE .-4			;NO
	MOV TVCRLN(A),TVRADR	;SET UP THE ADDRESS
	ADD #2,TVRADR		;SINCE WE'RE DOING THE NEXT WORD
	MOV TVMSK2(A),TVRWIN	;THE MASK
	MOV TVLCNT(A),TVWC	;THE COUNT
BLINK2:	RTS PC

;ROUTINE TO CLEAR THE SCREEN BETWEEN TVOFFL AND TVHIGH
TVCS:	BIT #.TSCRL,TTYST2(A)	;ARE WE IN SCROLL MODE?
	BNE TVCS2		;YES
	CLR TVCUR(A)		;SET CURSOR TO BEGINNING OF LINE
	MOV TVOFFL(A),TVLINE(A)	;SET LINE TO TVOFFL
	JSR PC,RSCUR		;FIX UP THE VARIABLES
TVCS1:	TST TVWC		;WAIT FOR PREVIOUS OPERATION
	BNE .-4
	JSR PC,TVCEOL		;CLEAR THIS LINE
	JSR PC,TVSPDN		;GO DOWN TO NEXT LINE
	CMP TVLINE(A),TVOFFL(A)	;ARE WE DONE YET
	BNE TVCS1		;NO
	RTS PC
TVCS2:	BIS #TVMOV,TVSEL	;TV MOV MODE
	CLR TVCUR(A)		;SET CURSOR TO BEGINNING OF LINE
	CLR TVCRLN(A)		;CURSOR AT ADDRESS 0
	CLR TVCRSN(A)		;BYTE ADDRESS OF START OF LINE
	CLR D			;SETMSK EXPECTS TVHBIT IN D
	MOV D,TVHBIT(A)		;HORIZONTAL BIT POSITION
	BIC #7777,TVST(A)	;SET SCROLL POINT TO ZERO IN STATUS
	MOV TVST(A),TVCNSL	;LET THE TV KNOW ABOUT IT
	CLR TVSCRL(A)		;SCROLL POINTER TO ZERO
	CLR TVLINE(A)		;GO BACK TO LINE ZERO
	CLR TVRADR		;START AT BEGINNING OF SCREEN
	CLR TVMSK		;TO MAKE SURE WE GET ALL THE ZEROS
	MOV #1,TVINCR		;INCREMENT 1 WORD FOR EACH COUNT
	CLR TVRWIN		;WRITE ZEROS
	CLR TVWC		;THIS MEANS DO 16K WORTH
	TST TVWC		;WAIT FOR THIS OPERATION TO COMPLETE
	BNE .-4
	JMP SETMSK		;SET THE MASKS AND SHIFT COUNT

;A HACK TO ALLOW TOGGLE OF THE IMAGE SENSE
REVSCR:	MOV #10000,C		;WE WANT TO TOGGLE THIS BIT
	XOR C,TVST(A)		;IN THE STATUS WORD FOR THIS TV
	MOV TVST(A),TVCNSL	;TELL THE TV ABOUT THIS
	RTS PC


;A ROUTINE TO SET UP TV VARIABLE FOR OPERATIONS ON THEM. CALLED BY TV INVOKES.
;ASSUMES TTY ITEM IN ITEM2 WITH A POINTING AT IT. PUSHES THE FONT ITEM IN
;ITEM1 WHICH MUST BE POPPED WHEN THE OPERATION IS COMPLETE.
TVINIT:	MOV TTLTTY(A),E	;THE LOGICAL TTY NUMBER
	NBUGC LT		;IT HAD BETTER BE LEGAL
	CMP E,#NTTYS*2	;SINCE E IS ACTUALLY A WORD INDEX
	NBUGC GE
	BIT #TVF,TTYTBL(E)	;MAKE SURE THAT THE TTY IS A TV
	BEQ TVIN3	;IT'S NOT SO FAIL
	MOV TVFONT(A),A	;THE FONT NUMBER
	NBUGC LT
	CMP A,#NFONTS*2	;A WILL BE A WORD OFFSET
	NBUGC GE
	MOV FNTITM(A),A	;GET THE FONT ITEM NUMBER
	BLE TVIN3	;MAKE SURE A FONT IS ASSIGNED TO THIS NUMBER
	JSR PC,ITM1PL	;LOAD IT UP
	MOV A,B		;COPY ITEM 1 ADDRESS
	MOV ITM2A,A	;ADDRESS OF THE TTY ITEM
	TST TVWC	;WAIT FOR PREVIOUS OPERATION
	BNE .-4
	MOVB TVBUF(A),TVSEL	;SELECT THE PROPER BUFFER
	TST TVBUF(A)	;BUFFER?
	BLT TVIN2	;IN CASE THERE IS NO BUFFER
	TSTB TVBLNK(E)	;MAKE SURE THE CURSOR IS OFF
	BLE TVIN1	;IT IS
	JSR PC,BLINK	;ELSE TURN IT OFF
	MOVB #-15,TVBLNK(E)	;RESET THE BLINK COUNT
TVIN1:	CLZ		;SUCCEED
	RTS PC
TVIN2:	JSR PC,ITM2PO	;CLEAN UP THE ITEM WE PUSHED
TVIN3:	SEZ		;FAIL
	RTS PC

;LINE DRAWER FOR TV'S
;EXPECTS:
;A - STARTING Y POSITION 0-473
;B - STARTING X POSITION 0-575
;C - DELTA Y
;D - DELTA X
;E - BUFFER NUMBER AND MODE. (GOES INTO TVSEL)

DRAW:	SAVE E			;THIS WILL GO INTO TVSEL
	TST D			;DO WE HAVE A NEGATIVE DELTA X
	BGE DRAW5		;NO
	ADD C,A
	ADD D,B
	NEG C
	NEG D			;REVERSE THE DIRECTION THE LINE IS DRAWN
DRAW5:	JSR PC,GETADR		;GET THE BYTE ADDRESS IN B, X MOD 16 IN A
	SAVE B			;THIS WILL GO INTO TVRADR
	MOV #1,E		;BIT STARTS AT LEFT SIDE
	NEG A			;GETADR LEFT H BIT POS MOD 16 IN A
	ADD #15.,A		;SO WE SHIFT LEFT
	ASH A,E			;SHIFT THE BIT RIGHT BY THE APPROPRIATE AMOUNT
	TST C			;IS DELTA Y POSITIVE?
	BGE DRAW4		;YES
	MOV #-110,A		;THE Y STEP IS ONE LINE UP THE SCREEN
	NEG C			;TO MAKE DELTA Y POSITIVE
	BR .+6
DRAW4:	MOV #110,A		;THE Y STEP IS ONE LINE DOWN THE SCREEN
	CLR B			;THIS WILL BE FLAG FOR HORIZONTAL OR VERTICAL
	CMP C,D			;IS DELTA Y GREATER THAN DELTA X
	BGE DRAW1		;YES
	SAVE D			;SINCE D > C, D WILL BE DIVISOR
	MOV C,D			;C WILL BE THE DIVIDEND
	BR DRAW3
DRAW1:	SAVE C			;SINCE C > D, C WILL BE DIVISOR
	MOV #2,B		;DRAW A VERTICAL LINE
DRAW3:	CLR C			;FOR THE DIVIDE
	ASHC #14.,C		;SO WE GET A FRACTIONAL RESULT
	DIV (P),C		;GET A QUOTIENT IN C
	MOV #40000,D		;ADD TO THIS NUMBER TO GET A CARRY
	REST F			;THE NUMBER OF STEPS WE WILL MOVE
	INC F			;SO WE SHOW THE INITIAL POINT
	SAVE PS
	SPL 7			;SO THE TVREGISTERS REMAIN INTACT
	TST TVWC		;WAIT FOR PREVIOUS OPERATION
	BNE .-4
	CLR TVINCR		;INCREMENT 0
	CLRB TVSHR		;NO SHIFT
	CLR TVMSK		;NO MASK
	MOV 2(P),TVRADR		;SET UP THE ADDRESS
	MOVB 4(P),TVSEL		;THE VALUE OF E WE WERE CALLED WITH
	JSR PC,@DRAWTB(B)	;DRAW EITHER A HORIZONTAL OR VERTICAL LINE
	REST PS			;BACK TO NORMAL PRIORITY
	CMP (P)+,(P)+		;POP THE TWO ARGS WE SAVED
	RTS PC

DRAWTB:	DRAWH			;HORIZONTAL LINE
	DRAWV			;VERTICAL LINE

DRAWH:	MOV E,TVRWIN		;DISPLAY A POINT
	ADD C,D			;ADD INCREMENT UNTIL WE OVERFLOW TO NEGATIVE
	BVC DRAWH1
	BIC #100000,D		;GO BACK TO A POSITIVE NUMBER
	BIS #40000,D		;SO WE WILL OVERFLOW AT THE RIGHT PLACE
	ADD A,TVRADR		;IF WE DID, THEN GO UP OR DOWN ONE LINE
	CLC			;IN CASE PREVIOUS OP CAUSES CARRY
DRAWH1:	ROR E			;SHIFT THE BIT RIGHT ONE POSITION
	BCC DRAWH2		;WE DID NOT OVERFLOW
	ROR E			;MOVE CARRY INTO BIT 15
	ADD #2,TVRADR		;ADVANCE TO NEXT WORD
DRAWH2:	SOB F,DRAWH		;DRAW A MORE HORIZONTAL LINE
	RTS PC

DRAWV:	MOV E,TVRWIN		;DISPLAY A POINT
	ADD C,D			;ADD INCREMENT UNTIL WE OVERFLOW
	BVC DRAWV1
	BIC #100000,D		;GO BACK TO POSITIVE
	BIS #40000,D		;SO WE WILL OVERFLOW AGAIN AT RIGHT PLACE
	ROR E			;MOVE THE BIT RIGHT ONE POSITION
	BCC DRAWV1		;NO OVERFLOW
	ROR E			;MOVE BIT FROM CARRY INTO BIT 15
	ADD #2,TVRADR		;NOW DOING THE NEXT WORD
DRAWV1:	ADD A,TVRADR		;ADD THE Y INCREMENT TO THE TV ADDRESS
	SOB F,DRAWV		;LOOP UNTIL WE FINISH DRAWING THE LINE
	RTS PC

;SCRCLR CLEARS PORTIONS OF THE SCREEN.  IT EXPECTS ARGUMENT LIKE DRAW
;BUT INTERPRETS THEM DIFFBRENTLY. DELTA Y AND DELTA X ARE EXPECTED TO
;BE POSITIVE VALUES. THE X AND Y POSITION MARKS THE UPPER LEFT CORNER
;OF A FIELD TO BE CLEARED. THE FIELD IS DELTA Y HIGH AND DELTA X WIDE.
SCRCLR:	SAVE E			;NEED A REGISTER
	JSR PC,GETADR		;GET THE BYTE ADDRESS IN E
	DEC C			;CLRING TVRADR COUNTS AS ONE
	BLE SCRCL4		;WE CANNOT DO JUST 1 WORD
	NEG C			;TVWC LIKES NEGATIVE COUNT
	MOV A,E			;COPY H BIT POSITION MOD 16
	NEG E			;CONTAINS H BIT POSITION MOD 16
	ADD #16.,E		;TO GET NUMBER OF BITS FROM RIGHT SIDE OF WORD
	MOV #177777,F		;ALL ONES
	ASH E,F			;SHIFT LEFT TO GET THE MASK
	CMP D,A			;D CONTAINS DELTA X
	BGT SCRCL1		;THE FIELD IS GREATER THAN THIS WORD.
	SUB D,A			;THE FIELD TO CLEAR DOES NOT CROSS WORD BOUNDRY
	MOV #177777,E		;WE MUST THUS CREATE MORE MASK FOR RIGHT SIDE
	ASH A,E			;FIELD OF ZEROS THE APPROPRIATE WIDTH
	COM E			;THE MASK SHOULD BE ONES
	BIS E,F			;SET IN THE OTHER SIDE OF THE MASK
	REST E
	JSR PC,CLRBLK		;CLEAR OUT A VERTICAL BLOCK
	RTS PC

SCRCL1:	REST E			;PUT THE PROPER TV NUMBER BACK
	JSR PC,CLRBLK		;CLEAR OUT THE FIRST WORD
	ADD A,D			;THE NUMBER OF BITS WE DIDN'T DO IN THIS WORD
	SUB #16.,D		;WE HAVE DONE THIS MUCH OF DELTA X
SCRCL2:	CMP D,#16.		;DO WE HAVE A FULL WORD LEFT?
	BLT SCRCL3		;NO
	CLR F			;DON'T MASK ANY
	JSR PC,CLRBLK		;CLEAR OUT A VERTICAL STRIP ONE WORD WIDE
	SUB #16.,D		;WE HAVE CLEARED THIS MUCH MORE OF DELTA X
	BR SCRCL2		;KEEP CLEARING WORDS UNTIL THERE ARE NO MORE
SCRCL3:	TST D			;IS THERE ANYTHING LEFT?
	BEQ SCRCL4		;NO
	DEC D			;THE HIGH BIT WILL ALREADY BE ZERO (SEE NEXT INST.)
	NEG D			;SINCE WE ARE SHIFTING RIGHT
	MOV #77777,F		;MAKE A NEW MASK. BIT 15 IS ZERO SO WE SHIFT IN ZEROS
	ASH D,F			;PUT ZEROS IN THE AMOUNT OF DELTA X WE HAVE LEFT
	JSR PC,CLRBLK		;CLEAR OUT THE LAST STRIP
SCRCL4:	RTS PC

;CLEAR A VERTICAL STRIP OF THE SCREEN
CLRBLK:	SAVE PS
	SPL 7
	TST TVWC		;WAIT FOR PREVIOUS OPERATION
	BNE .-4
	BIS #TVMOV,E		;MOVE MODE
	MOVB E,TVSEL		;SELECT THE PROPER BUFFER
	MOV F,TVMSK		;EXPECTS THE MASK IN F
	MOV B,TVRADR		;SET UP THE ADDRESS
	CLRB TVSHR		;NO SHIFT
	MOV #1044,TVINCR	;INCREMENT ONE LINE AT A TIME
	CLR TVRWIN		;CLEAR OUT THE WORD
	MOV C,TVWC		;DO IT THIS MANY TIMES
	ADD #2,B		;DO THE NEXT WORD NEXT TIME
	REST PS			;BACK TO NORMAL PRIORITY
	RTS PC

;GETADR USES THE Y POSITION IN A AND THE X POSITION IN B TO GIVE A BYTE ADDRESS
;IN B AND X MOD 16 IN A.
GETADR:	SAVE C			;NEED A REGISTER
	MOV B,C			;PUT X POSITION IN C
	MUL #110,A		;ADDRESS OF THE START OF THE LINE
	MOV C,A			;PUT X BACK, THE HIGH ORDER OF MUL SHOULD BE ZERO
	ASH #-4,C		;GET WORD FROM START OF LINE
	ASL C			;BYTE
	ADD C,B			;GET THE FINAL BYTE ADDRESS
	BIC #177760,A		;GET X MOD 16 IN A
	REST C
	RTS PC
	
.ENDC

